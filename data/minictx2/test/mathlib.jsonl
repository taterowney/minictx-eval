{"srcContext": "/-\nCopyright (c) 2018 Robert Y. Lewis. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Robert Y. Lewis, Mario Carneiro, Johan Commelin\n-/\nimport Mathlib.NumberTheory.Padics.PadicNumbers\nimport Mathlib.RingTheory.DiscreteValuationRing.Basic\n\n/-!\n# p-adic integers\n\nThis file defines the `p`-adic integers `\u2124_[p]` as the subtype of `\u211a_[p]` with norm `\u2264 1`.\nWe show that `\u2124_[p]`\n* is complete,\n* is nonarchimedean,\n* is a normed ring,\n* is a local ring, and\n* is a discrete valuation ring.\n\nThe relation between `\u2124_[p]` and `ZMod p` is established in another file.\n\n## Important definitions\n\n* `PadicInt` : the type of `p`-adic integers\n\n## Notation\n\nWe introduce the notation `\u2124_[p]` for the `p`-adic integers.\n\n## Implementation notes\n\nMuch, but not all, of this file assumes that `p` is prime. This assumption is inferred automatically\nby taking `[Fact p.Prime]` as a type class argument.\n\nCoercions into `\u2124_[p]` are set up to work with the `norm_cast` tactic.\n\n## References\n\n* [F. Q. Gouv\u00eaa, *p-adic numbers*][gouvea1997]\n* [R. Y. Lewis, *A formal proof of Hensel's lemma over the p-adic integers*][lewis2019]\n* <https://en.wikipedia.org/wiki/P-adic_number>\n\n## Tags\n\np-adic, p adic, padic, p-adic integer\n-/\n\n\nopen Padic Metric IsLocalRing\n\nnoncomputable section\n\nvariable (p : \u2115) [hp : Fact p.Prime]\n\n/-- The `p`-adic integers `\u2124_[p]` are the `p`-adic numbers with norm `\u2264 1`. -/\ndef PadicInt : Type := {x : \u211a_[p] // \u2016x\u2016 \u2264 1}\n\n/-- The ring of `p`-adic integers. -/\nnotation \"\u2124_[\" p \"]\" => PadicInt p\n\nnamespace PadicInt\nvariable {p} {x y : \u2124_[p]}\n\n/-! ### Ring structure and coercion to `\u211a_[p]` -/\n\ninstance : Coe \u2124_[p] \u211a_[p] :=\n  \u27e8Subtype.val\u27e9\n\ntheorem ext {x y : \u2124_[p]} : (x : \u211a_[p]) = y \u2192 x = y :=\n  Subtype.ext\n\nvariable (p)\n\n/-- The `p`-adic integers as a subring of `\u211a_[p]`. -/\ndef subring : Subring \u211a_[p] where\n  carrier := { x : \u211a_[p] | \u2016x\u2016 \u2264 1 }\n  zero_mem' := by norm_num\n  one_mem' := by norm_num\n  add_mem' hx hy := (padicNormE.nonarchimedean _ _).trans <| max_le_iff.2 \u27e8hx, hy\u27e9\n  mul_mem' hx hy := (padicNormE.mul _ _).trans_le <| mul_le_one\u2080 hx (norm_nonneg _) hy\n  neg_mem' hx := (norm_neg _).trans_le hx\n\n@[simp]\ntheorem mem_subring_iff {x : \u211a_[p]} : x \u2208 subring p \u2194 \u2016x\u2016 \u2264 1 := Iff.rfl\n\nvariable {p}\n\n/-- Addition on `\u2124_[p]` is inherited from `\u211a_[p]`. -/\ninstance : Add \u2124_[p] := (by infer_instance : Add (subring p))\n\n/-- Multiplication on `\u2124_[p]` is inherited from `\u211a_[p]`. -/\ninstance : Mul \u2124_[p] := (by infer_instance : Mul (subring p))\n\n/-- Negation on `\u2124_[p]` is inherited from `\u211a_[p]`. -/\ninstance : Neg \u2124_[p] := (by infer_instance : Neg (subring p))\n\n/-- Subtraction on `\u2124_[p]` is inherited from `\u211a_[p]`. -/\ninstance : Sub \u2124_[p] := (by infer_instance : Sub (subring p))\n\n/-- Zero on `\u2124_[p]` is inherited from `\u211a_[p]`. -/\ninstance : Zero \u2124_[p] := (by infer_instance : Zero (subring p))\n\ninstance : Inhabited \u2124_[p] := \u27e80\u27e9\n\n/-- One on `\u2124_[p]` is inherited from `\u211a_[p]`. -/\ninstance : One \u2124_[p] := \u27e8\u27e81, by norm_num\u27e9\u27e9\n\n@[simp]\ntheorem mk_zero {h} : (\u27e80, h\u27e9 : \u2124_[p]) = (0 : \u2124_[p]) := rfl\n\n@[simp, norm_cast]\ntheorem coe_add (z1 z2 : \u2124_[p]) : ((z1 + z2 : \u2124_[p]) : \u211a_[p]) = z1 + z2 := rfl\n\n@[simp, norm_cast]\ntheorem coe_mul (z1 z2 : \u2124_[p]) : ((z1 * z2 : \u2124_[p]) : \u211a_[p]) = z1 * z2 := rfl\n\n@[simp, norm_cast]\ntheorem coe_neg (z1 : \u2124_[p]) : ((-z1 : \u2124_[p]) : \u211a_[p]) = -z1 := rfl\n\n@[simp, norm_cast]\ntheorem coe_sub (z1 z2 : \u2124_[p]) : ((z1 - z2 : \u2124_[p]) : \u211a_[p]) = z1 - z2 := rfl\n\n@[simp, norm_cast]\ntheorem coe_one : ((1 : \u2124_[p]) : \u211a_[p]) = 1 := rfl\n\n@[simp, norm_cast]\ntheorem coe_zero : ((0 : \u2124_[p]) : \u211a_[p]) = 0 := rfl\n\n@[simp] lemma coe_eq_zero : (x : \u211a_[p]) = 0 \u2194 x = 0 := by rw [\u2190 coe_zero, Subtype.coe_inj]\n\nlemma coe_ne_zero : (x : \u211a_[p]) \u2260 0 \u2194 x \u2260 0 := coe_eq_zero.not\n\ninstance : AddCommGroup \u2124_[p] := (by infer_instance : AddCommGroup (subring p))\n\ninstance instCommRing : CommRing \u2124_[p] := (by infer_instance : CommRing (subring p))\n\n@[simp, norm_cast]\ntheorem coe_natCast (n : \u2115) : ((n : \u2124_[p]) : \u211a_[p]) = n := rfl\n\n@[simp, norm_cast]\ntheorem coe_intCast (z : \u2124) : ((z : \u2124_[p]) : \u211a_[p]) = z := rfl\n\n/-- The coercion from `\u2124_[p]` to `\u211a_[p]` as a ring homomorphism. -/\ndef Coe.ringHom : \u2124_[p] \u2192+* \u211a_[p] := (subring p).subtype\n\n@[simp, norm_cast]\ntheorem coe_pow (x : \u2124_[p]) (n : \u2115) : (\u2191(x ^ n) : \u211a_[p]) = (\u2191x : \u211a_[p]) ^ n := rfl\n\ntheorem mk_coe (k : \u2124_[p]) : (\u27e8k, k.2\u27e9 : \u2124_[p]) = k := by simp\n\n/-- The inverse of a `p`-adic integer with norm equal to `1` is also a `p`-adic integer.\nOtherwise, the inverse is defined to be `0`. -/\ndef inv : \u2124_[p] \u2192 \u2124_[p]\n  | \u27e8k, _\u27e9 => if h : \u2016k\u2016 = 1 then \u27e8k\u207b\u00b9, by simp [h]\u27e9 else 0\n\ninstance : CharZero \u2124_[p] where\n  cast_injective m n h :=\n    Nat.cast_injective (R := \u211a_[p]) (by rw [Subtype.ext_iff] at h; norm_cast at h)\n\n@[norm_cast]\ntheorem intCast_eq (z1 z2 : \u2124) : (z1 : \u2124_[p]) = z2 \u2194 z1 = z2 := by simp\n\n/-- A sequence of integers that is Cauchy with respect to the `p`-adic norm converges to a `p`-adic\ninteger. -/\ndef ofIntSeq (seq : \u2115 \u2192 \u2124) (h : IsCauSeq (padicNorm p) fun n => seq n) : \u2124_[p] :=\n  \u27e8\u27e6\u27e8_, h\u27e9\u27e7,\n    show \u2191(PadicSeq.norm _) \u2264 (1 : \u211d) by\n      rw [PadicSeq.norm]\n      split_ifs with hne <;> norm_cast\n      apply padicNorm.of_int\u27e9\n\n/-! ### Instances\n\nWe now show that `\u2124_[p]` is a\n* complete metric space\n* normed ring\n* integral domain\n-/\n\nvariable (p)\n\ninstance : MetricSpace \u2124_[p] := Subtype.metricSpace\n\ninstance : IsUltrametricDist \u2124_[p] := IsUltrametricDist.subtype _\n\ninstance completeSpace : CompleteSpace \u2124_[p] :=\n  have : IsClosed { x : \u211a_[p] | \u2016x\u2016 \u2264 1 } := isClosed_le continuous_norm continuous_const\n  this.completeSpace_coe\n\ninstance : Norm \u2124_[p] := \u27e8fun z => \u2016(z : \u211a_[p])\u2016\u27e9\n\nvariable {p}\n\ntheorem norm_def {z : \u2124_[p]} : \u2016z\u2016 = \u2016(z : \u211a_[p])\u2016 := rfl\n\nvariable (p)\n\ninstance : NormedCommRing \u2124_[p] :=\n  { PadicInt.instCommRing with\n    dist_eq := fun \u27e8_, _\u27e9 \u27e8_, _\u27e9 => rfl\n    norm_mul := by simp [norm_def]\n    norm := norm }\n\ninstance : NormOneClass \u2124_[p] :=\n  \u27e8norm_def.trans norm_one\u27e9\n\ninstance isAbsoluteValue : IsAbsoluteValue fun z : \u2124_[p] => \u2016z\u2016 where\n  abv_nonneg' := norm_nonneg\n  abv_eq_zero' := by simp [norm_eq_zero]\n  abv_add' := fun \u27e8_, _\u27e9 \u27e8_, _\u27e9 => norm_add_le _ _\n  abv_mul' _ _ := by simp only [norm_def, padicNormE.mul, PadicInt.coe_mul]\n\nvariable {p}\n\ninstance : IsDomain \u2124_[p] := Function.Injective.isDomain (subring p).subtype Subtype.coe_injective\n\n/-! ### Norm -/\n\ntheorem norm_le_one (z : \u2124_[p]) : \u2016z\u2016 \u2264 1 := z.2\n\n@[simp]\ntheorem norm_mul (z1 z2 : \u2124_[p]) : \u2016z1 * z2\u2016 = \u2016z1\u2016 * \u2016z2\u2016 := by simp [norm_def]\n\n@[simp]\ntheorem norm_pow (z : \u2124_[p]) : \u2200 n : \u2115, \u2016z ^ n\u2016 = \u2016z\u2016 ^ n\n  | 0 => by simp\n  | k + 1 => by\n    rw [pow_succ, pow_succ, norm_mul]\n    congr\n    apply norm_pow\n\ntheorem nonarchimedean (q r : \u2124_[p]) : \u2016q + r\u2016 \u2264 max \u2016q\u2016 \u2016r\u2016 := padicNormE.nonarchimedean _ _\n\ntheorem norm_add_eq_max_of_ne {q r : \u2124_[p]} : \u2016q\u2016 \u2260 \u2016r\u2016 \u2192 \u2016q + r\u2016 = max \u2016q\u2016 \u2016r\u2016 :=\n  padicNormE.add_eq_max_of_ne\n\ntheorem norm_eq_of_norm_add_lt_right {z1 z2 : \u2124_[p]} (h : \u2016z1 + z2\u2016 < \u2016z2\u2016) : \u2016z1\u2016 = \u2016z2\u2016 :=\n  by_contra fun hne =>\n    not_lt_of_ge (by rw [norm_add_eq_max_of_ne hne]; apply le_max_right) h\n\ntheorem norm_eq_of_norm_add_lt_left {z1 z2 : \u2124_[p]} (h : \u2016z1 + z2\u2016 < \u2016z1\u2016) : \u2016z1\u2016 = \u2016z2\u2016 :=\n  by_contra fun hne =>\n    not_lt_of_ge (by rw [norm_add_eq_max_of_ne hne]; apply le_max_left) h\n\n@[simp]\ntheorem padic_norm_e_of_padicInt (z : \u2124_[p]) : \u2016(z : \u211a_[p])\u2016 = \u2016z\u2016 := by simp [norm_def]\n\ntheorem norm_intCast_eq_padic_norm (z : \u2124) : \u2016(z : \u2124_[p])\u2016 = \u2016(z : \u211a_[p])\u2016 := by simp [norm_def]\n\n@[simp]\ntheorem norm_eq_padic_norm {q : \u211a_[p]} (hq : \u2016q\u2016 \u2264 1) : @norm \u2124_[p] _ \u27e8q, hq\u27e9 = \u2016q\u2016 := rfl\n\n@[simp]\ntheorem norm_p : \u2016(p : \u2124_[p])\u2016 = (p : \u211d)\u207b\u00b9 := padicNormE.norm_p\n\ntheorem norm_p_pow (n : \u2115) : \u2016(p : \u2124_[p]) ^ n\u2016 = (p : \u211d) ^ (-n : \u2124) := by simp\n\nprivate def cauSeq_to_rat_cauSeq (f : CauSeq \u2124_[p] norm) : CauSeq \u211a_[p] fun a => \u2016a\u2016 :=\n  \u27e8fun n => f n, fun _ h\u03b5 => by simpa [norm, norm_def] using f.cauchy h\u03b5\u27e9\n\nvariable (p)\n\ninstance complete : CauSeq.IsComplete \u2124_[p] norm :=\n  \u27e8fun f =>\n    have hqn : \u2016CauSeq.lim (cauSeq_to_rat_cauSeq f)\u2016 \u2264 1 :=\n      padicNormE_lim_le zero_lt_one fun _ => norm_le_one _\n    \u27e8\u27e8_, hqn\u27e9, fun \u03b5 => by\n      simpa [norm, norm_def] using CauSeq.equiv_lim (cauSeq_to_rat_cauSeq f) \u03b5\u27e9\u27e9\n\ntheorem exists_pow_neg_lt {\u03b5 : \u211d} (h\u03b5 : 0 < \u03b5) : \u2203 k : \u2115, (p : \u211d) ^ (-(k : \u2124)) < \u03b5 := by\n  obtain \u27e8k, hk\u27e9 := exists_nat_gt \u03b5\u207b\u00b9\n  use k\n  rw [\u2190 inv_lt_inv\u2080 h\u03b5 (zpow_pos _ _)]\n  \u00b7 rw [zpow_neg, inv_inv, zpow_natCast]\n    apply lt_of_lt_of_le hk\n    norm_cast\n    apply le_of_lt\n    convert Nat.lt_pow_self _ using 1\n    exact hp.1.one_lt\n  \u00b7 exact mod_cast hp.1.pos\n\ntheorem exists_pow_neg_lt_rat {\u03b5 : \u211a} (h\u03b5 : 0 < \u03b5) : \u2203 k : \u2115, (p : \u211a) ^ (-(k : \u2124)) < \u03b5 := by\n  obtain \u27e8k, hk\u27e9 := @exists_pow_neg_lt p _ \u03b5 (mod_cast h\u03b5)\n  use k\n  rw [show (p : \u211d) = (p : \u211a) by simp] at hk\n  exact mod_cast hk\n\nvariable {p}\n\ntheorem norm_int_lt_one_iff_dvd (k : \u2124) : \u2016(k : \u2124_[p])\u2016 < 1 \u2194 (p : \u2124) \u2223 k :=\n  suffices \u2016(k : \u211a_[p])\u2016 < 1 \u2194 \u2191p \u2223 k by rwa [norm_intCast_eq_padic_norm]\n  padicNormE.norm_int_lt_one_iff_dvd k\n\ntheorem norm_int_le_pow_iff_dvd {k : \u2124} {n : \u2115} :\n    \u2016(k : \u2124_[p])\u2016 \u2264 (p : \u211d) ^ (-n : \u2124) \u2194 (p ^ n : \u2124) \u2223 k :=\n  suffices \u2016(k : \u211a_[p])\u2016 \u2264 (p : \u211d) ^ (-n : \u2124) \u2194 (p ^ n : \u2124) \u2223 k by\n    simpa [norm_intCast_eq_padic_norm]\n  padicNormE.norm_int_le_pow_iff_dvd _ _\n\n/-! ### Valuation on `\u2124_[p]` -/\n\n", "theoremStatement": "lemma valuation_coe_nonneg : 0 \u2264 (x : \u211a_[p]).valuation ", "theoremName": "PadicInt.valuation_coe_nonneg", "fileCreated": {"commit": "63d78da6a358d613bff5f34c62ed9481dbbc52c2", "date": "2023-05-25"}, "theoremCreated": {"commit": "1c080cc45939aaef448022267a6965a19e53c7bf", "date": "2024-12-21"}, "file": "mathlib/Mathlib/NumberTheory/Padics/PadicIntegers.lean", "module": "Mathlib.NumberTheory.Padics.PadicIntegers", "jsonFile": "Mathlib.NumberTheory.Padics.PadicIntegers.jsonl", "positionMetadata": {"lineInFile": 302, "tokenPositionInFile": 9232, "theoremPositionInFile": 37}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 78, "numPremises": 111}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  obtain rfl | hx := eq_or_ne x 0\n  \u00b7 simp\n  have := x.2\n  rwa [Padic.norm_eq_zpow_neg_valuation <| coe_ne_zero.2 hx, zpow_le_one_iff_right\u2080, neg_nonpos]\n    at this\n  exact mod_cast hp.out.one_lt", "proofType": "tactic", "proofLengthLines": 6, "proofLengthTokens": 202}}
{"srcContext": "/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Chris Hughes, Anne Baanen\n-/\nimport Mathlib.Data.Matrix.Basic\nimport Mathlib.Data.Matrix.Block\nimport Mathlib.Data.Matrix.Notation\nimport Mathlib.Data.Matrix.RowCol\nimport Mathlib.GroupTheory.GroupAction.Ring\nimport Mathlib.GroupTheory.Perm.Fin\nimport Mathlib.LinearAlgebra.Alternating.Basic\nimport Mathlib.LinearAlgebra.Matrix.SemiringInverse\n\n/-!\n# Determinant of a matrix\n\nThis file defines the determinant of a matrix, `Matrix.det`, and its essential properties.\n\n## Main definitions\n\n - `Matrix.det`: the determinant of a square matrix, as a sum over permutations\n - `Matrix.detRowAlternating`: the determinant, as an `AlternatingMap` in the rows of the matrix\n\n## Main results\n\n - `det_mul`: the determinant of `A * B` is the product of determinants\n - `det_zero_of_row_eq`: the determinant is zero if there is a repeated row\n - `det_block_diagonal`: the determinant of a block diagonal matrix is a product\n   of the blocks' determinants\n\n## Implementation notes\n\nIt is possible to configure `simp` to compute determinants. See the file\n`MathlibTest/matrix.lean` for some examples.\n\n-/\n\n\nuniverse u v w z\n\nopen Equiv Equiv.Perm Finset Function\n\nnamespace Matrix\n\nvariable {m n : Type*} [DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m]\nvariable {R : Type v} [CommRing R]\n\nlocal notation \"\u03b5 \" \u03c3:arg => ((sign \u03c3 : \u2124) : R)\n\n/-- `det` is an `AlternatingMap` in the rows of the matrix. -/\ndef detRowAlternating : (n \u2192 R) [\u22c0^n]\u2192\u2097[R] R :=\n  MultilinearMap.alternatization ((MultilinearMap.mkPiAlgebra R n R).compLinearMap LinearMap.proj)\n\n/-- The determinant of a matrix given by the Leibniz formula. -/\nabbrev det (M : Matrix n n R) : R :=\n  detRowAlternating M\n\ntheorem det_apply (M : Matrix n n R) : M.det = \u2211 \u03c3 : Perm n, Equiv.Perm.sign \u03c3 \u2022 \u220f i, M (\u03c3 i) i :=\n  MultilinearMap.alternatization_apply _ M\n\n-- This is what the old definition was. We use it to avoid having to change the old proofs below\ntheorem det_apply' (M : Matrix n n R) : M.det = \u2211 \u03c3 : Perm n, \u03b5 \u03c3 * \u220f i, M (\u03c3 i) i := by\n  simp [det_apply, Units.smul_def]\n\ntheorem det_eq_detp_sub_detp (M : Matrix n n R) : M.det = M.detp 1 - M.detp (-1) := by\n  rw [det_apply, \u2190 Equiv.sum_comp (Equiv.inv (Perm n)), \u2190 ofSign_disjUnion, sum_disjUnion]\n  simp_rw [inv_apply, sign_inv, sub_eq_add_neg, detp, \u2190 sum_neg_distrib]\n  refine congr_arg\u2082 (\u00b7 + \u00b7) (sum_congr rfl fun \u03c3 h\u03c3 \u21a6 ?_) (sum_congr rfl fun \u03c3 h\u03c3 \u21a6 ?_) <;>\n    rw [mem_ofSign.mp h\u03c3, \u2190 Equiv.prod_comp \u03c3] <;> simp\n\n@[simp]\ntheorem det_diagonal {d : n \u2192 R} : det (diagonal d) = \u220f i, d i := by\n  rw [det_apply']\n  refine (Finset.sum_eq_single 1 ?_ ?_).trans ?_\n  \u00b7 rintro \u03c3 - h2\n    cases' not_forall.1 (mt Equiv.ext h2) with x h3\n    convert mul_zero (\u03b5 \u03c3)\n    apply Finset.prod_eq_zero (mem_univ x)\n    exact if_neg h3\n  \u00b7 simp\n  \u00b7 simp\n\ntheorem det_zero (_ : Nonempty n) : det (0 : Matrix n n R) = 0 :=\n  (detRowAlternating : (n \u2192 R) [\u22c0^n]\u2192\u2097[R] R).map_zero\n\n@[simp]\ntheorem det_one : det (1 : Matrix n n R) = 1 := by rw [\u2190 diagonal_one]; simp [-diagonal_one]\n\ntheorem det_isEmpty [IsEmpty n] {A : Matrix n n R} : det A = 1 := by simp [det_apply]\n\n@[simp]\ntheorem coe_det_isEmpty [IsEmpty n] : (det : Matrix n n R \u2192 R) = Function.const _ 1 := by\n  ext\n  exact det_isEmpty\n\ntheorem det_eq_one_of_card_eq_zero {A : Matrix n n R} (h : Fintype.card n = 0) : det A = 1 :=\n  haveI : IsEmpty n := Fintype.card_eq_zero_iff.mp h\n  det_isEmpty\n\n/-- If `n` has only one element, the determinant of an `n` by `n` matrix is just that element.\nAlthough `Unique` implies `DecidableEq` and `Fintype`, the instances might\nnot be syntactically equal. Thus, we need to fill in the args explicitly. -/\n@[simp]\ntheorem det_unique {n : Type*} [Unique n] [DecidableEq n] [Fintype n] (A : Matrix n n R) :\n    det A = A default default := by simp [det_apply, univ_unique]\n\ntheorem det_eq_elem_of_subsingleton [Subsingleton n] (A : Matrix n n R) (k : n) :\n    det A = A k k := by\n  have := uniqueOfSubsingleton k\n  convert det_unique A\n\ntheorem det_eq_elem_of_card_eq_one {A : Matrix n n R} (h : Fintype.card n = 1) (k : n) :\n    det A = A k k :=\n  haveI : Subsingleton n := Fintype.card_le_one_iff_subsingleton.mp h.le\n  det_eq_elem_of_subsingleton _ _\n\ntheorem det_mul_aux {M N : Matrix n n R} {p : n \u2192 n} (H : \u00acBijective p) :\n    (\u2211 \u03c3 : Perm n, \u03b5 \u03c3 * \u220f x, M (\u03c3 x) (p x) * N (p x) x) = 0 := by\n  obtain \u27e8i, j, hpij, hij\u27e9 : \u2203 i j, p i = p j \u2227 i \u2260 j := by\n    rw [\u2190 Finite.injective_iff_bijective, Injective] at H\n    push_neg at H\n    exact H\n  exact\n    sum_involution (fun \u03c3 _ => \u03c3 * Equiv.swap i j)\n      (fun \u03c3 _ => by\n        have : (\u220f x, M (\u03c3 x) (p x)) = \u220f x, M ((\u03c3 * Equiv.swap i j) x) (p x) :=\n          Fintype.prod_equiv (swap i j) _ _ (by simp [apply_swap_eq_self hpij])\n        simp [this, sign_swap hij, -sign_swap', prod_mul_distrib])\n      (fun \u03c3 _ _ => (not_congr mul_swap_eq_iff).mpr hij) (fun _ _ => mem_univ _) fun \u03c3 _ =>\n      mul_swap_involutive i j \u03c3\n\n@[simp]\ntheorem det_mul (M N : Matrix n n R) : det (M * N) = det M * det N :=\n  calc\n    det (M * N) = \u2211 p : n \u2192 n, \u2211 \u03c3 : Perm n, \u03b5 \u03c3 * \u220f i, M (\u03c3 i) (p i) * N (p i) i := by\n      simp only [det_apply', mul_apply, prod_univ_sum, mul_sum, Fintype.piFinset_univ]\n      rw [Finset.sum_comm]\n    _ = \u2211 p : n \u2192 n with Bijective p, \u2211 \u03c3 : Perm n, \u03b5 \u03c3 * \u220f i, M (\u03c3 i) (p i) * N (p i) i := by\n      refine (sum_subset (filter_subset _ _) fun f _ hbij \u21a6 det_mul_aux ?_).symm\n      simpa only [true_and, mem_filter, mem_univ] using hbij\n    _ = \u2211 \u03c4 : Perm n, \u2211 \u03c3 : Perm n, \u03b5 \u03c3 * \u220f i, M (\u03c3 i) (\u03c4 i) * N (\u03c4 i) i :=\n      sum_bij (fun p h \u21a6 Equiv.ofBijective p (mem_filter.1 h).2) (fun _ _ \u21a6 mem_univ _)\n        (fun _ _ _ _ h \u21a6 by injection h)\n        (fun b _ \u21a6 \u27e8b, mem_filter.2 \u27e8mem_univ _, b.bijective\u27e9, coe_fn_injective rfl\u27e9) fun _ _ \u21a6 rfl\n    _ = \u2211 \u03c3 : Perm n, \u2211 \u03c4 : Perm n, (\u220f i, N (\u03c3 i) i) * \u03b5 \u03c4 * \u220f j, M (\u03c4 j) (\u03c3 j) := by\n      simp only [mul_comm, mul_left_comm, prod_mul_distrib, mul_assoc]\n    _ = \u2211 \u03c3 : Perm n, \u2211 \u03c4 : Perm n, (\u220f i, N (\u03c3 i) i) * (\u03b5 \u03c3 * \u03b5 \u03c4) * \u220f i, M (\u03c4 i) i :=\n      (sum_congr rfl fun \u03c3 _ =>\n        Fintype.sum_equiv (Equiv.mulRight \u03c3\u207b\u00b9) _ _ fun \u03c4 => by\n          have : (\u220f j, M (\u03c4 j) (\u03c3 j)) = \u220f j, M ((\u03c4 * \u03c3\u207b\u00b9) j) j := by\n            rw [\u2190 (\u03c3\u207b\u00b9 : _ \u2243 _).prod_comp]\n            simp only [Equiv.Perm.coe_mul, apply_inv_self, Function.comp_apply]\n          have h : \u03b5 \u03c3 * \u03b5 (\u03c4 * \u03c3\u207b\u00b9) = \u03b5 \u03c4 :=\n            calc\n              \u03b5 \u03c3 * \u03b5 (\u03c4 * \u03c3\u207b\u00b9) = \u03b5 (\u03c4 * \u03c3\u207b\u00b9 * \u03c3) := by\n                rw [mul_comm, sign_mul (\u03c4 * \u03c3\u207b\u00b9)]\n                simp only [Int.cast_mul, Units.val_mul]\n              _ = \u03b5 \u03c4 := by simp only [inv_mul_cancel_right]\n\n          simp_rw [Equiv.coe_mulRight, h]\n          simp only [this])\n    _ = det M * det N := by\n      simp only [det_apply', Finset.mul_sum, mul_comm, mul_left_comm, mul_assoc]\n\n/-- The determinant of a matrix, as a monoid homomorphism. -/\ndef detMonoidHom : Matrix n n R \u2192* R where\n  toFun := det\n  map_one' := det_one\n  map_mul' := det_mul\n\n@[simp]\ntheorem coe_detMonoidHom : (detMonoidHom : Matrix n n R \u2192 R) = det :=\n  rfl\n\n/-- On square matrices, `mul_comm` applies under `det`. -/\ntheorem det_mul_comm (M N : Matrix m m R) : det (M * N) = det (N * M) := by\n  rw [det_mul, det_mul, mul_comm]\n\n/-- On square matrices, `mul_left_comm` applies under `det`. -/\ntheorem det_mul_left_comm (M N P : Matrix m m R) : det (M * (N * P)) = det (N * (M * P)) := by\n  rw [\u2190 Matrix.mul_assoc, \u2190 Matrix.mul_assoc, det_mul, det_mul_comm M N, \u2190 det_mul]\n\n/-- On square matrices, `mul_right_comm` applies under `det`. -/\ntheorem det_mul_right_comm (M N P : Matrix m m R) : det (M * N * P) = det (M * P * N) := by\n  rw [Matrix.mul_assoc, Matrix.mul_assoc, det_mul, det_mul_comm N P, \u2190 det_mul]\n\n-- TODO(https://github.com/leanprover-community/mathlib4/issues/6607): fix elaboration so `val` isn't needed\ntheorem det_units_conj (M : (Matrix m m R)\u02e3) (N : Matrix m m R) :\n    det (M.val * N * M\u207b\u00b9.val) = det N := by\n  rw [det_mul_right_comm, Units.mul_inv, one_mul]\n\n-- TODO(https://github.com/leanprover-community/mathlib4/issues/6607): fix elaboration so `val` isn't needed\ntheorem det_units_conj' (M : (Matrix m m R)\u02e3) (N : Matrix m m R) :\n    det (M\u207b\u00b9.val * N * \u2191M.val) = det N :=\n  det_units_conj M\u207b\u00b9 N\n\n/-- Transposing a matrix preserves the determinant. -/\n@[simp]\ntheorem det_transpose (M : Matrix n n R) : M\u1d40.det = M.det := by\n  rw [det_apply', det_apply']\n  refine Fintype.sum_bijective _ inv_involutive.bijective _ _ ?_\n  intro \u03c3\n  rw [sign_inv]\n  congr 1\n  apply Fintype.prod_equiv \u03c3\n  simp\n\n/-- Permuting the columns changes the sign of the determinant. -/\ntheorem det_permute (\u03c3 : Perm n) (M : Matrix n n R) :\n    (M.submatrix \u03c3 id).det = Perm.sign \u03c3 * M.det :=\n  ((detRowAlternating : (n \u2192 R) [\u22c0^n]\u2192\u2097[R] R).map_perm M \u03c3).trans (by simp [Units.smul_def])\n\n/-- Permuting the rows changes the sign of the determinant. -/\ntheorem det_permute' (\u03c3 : Perm n) (M : Matrix n n R) :\n    (M.submatrix id \u03c3).det = Perm.sign \u03c3 * M.det := by\n  rw [\u2190 det_transpose, transpose_submatrix, det_permute, det_transpose]\n\n/-- Permuting rows and columns with the same equivalence does not change the determinant. -/\n@[simp]\ntheorem det_submatrix_equiv_self (e : n \u2243 m) (A : Matrix m m R) :\n    det (A.submatrix e e) = det A := by\n  rw [det_apply', det_apply']\n  apply Fintype.sum_equiv (Equiv.permCongr e)\n  intro \u03c3\n  rw [Equiv.Perm.sign_permCongr e \u03c3]\n  congr 1\n  apply Fintype.prod_equiv e\n  intro i\n  rw [Equiv.permCongr_apply, Equiv.symm_apply_apply, submatrix_apply]\n\n/-- Permuting rows and columns with two equivalences does not change the absolute value of the\ndeterminant. -/\n@[simp]\ntheorem abs_det_submatrix_equiv_equiv {R : Type*} [LinearOrderedCommRing R]\n    (e\u2081 e\u2082 : n \u2243 m) (A : Matrix m m R) :\n    |(A.submatrix e\u2081 e\u2082).det| = |A.det| := by\n  have hee : e\u2082 = e\u2081.trans (e\u2081.symm.trans e\u2082) := by ext; simp\n  rw [hee]\n  show |((A.submatrix id (e\u2081.symm.trans e\u2082)).submatrix e\u2081 e\u2081).det| = |A.det|\n  rw [Matrix.det_submatrix_equiv_self, Matrix.det_permute', abs_mul, abs_unit_intCast, one_mul]\n\n/-- Reindexing both indices along the same equivalence preserves the determinant.\n\nFor the `simp` version of this lemma, see `det_submatrix_equiv_self`; this one is unsuitable because\n`Matrix.reindex_apply` unfolds `reindex` first.\n-/\ntheorem det_reindex_self (e : m \u2243 n) (A : Matrix m m R) : det (reindex e e A) = det A :=\n  det_submatrix_equiv_self e.symm A\n\ntheorem det_smul (A : Matrix n n R) (c : R) : det (c \u2022 A) = c ^ Fintype.card n * det A :=\n  calc\n    det (c \u2022 A) = det ((diagonal fun _ => c) * A) := by rw [smul_eq_diagonal_mul]\n    _ = det (diagonal fun _ => c) * det A := det_mul _ _\n    _ = c ^ Fintype.card n * det A := by simp [card_univ]\n\n@[simp]\ntheorem det_smul_of_tower {\u03b1} [Monoid \u03b1] [DistribMulAction \u03b1 R] [IsScalarTower \u03b1 R R]\n    [SMulCommClass \u03b1 R R] (c : \u03b1) (A : Matrix n n R) :\n    det (c \u2022 A) = c ^ Fintype.card n \u2022 det A := by\n  rw [\u2190 smul_one_smul R c A, det_smul, smul_pow, one_pow, smul_mul_assoc, one_mul]\n\ntheorem det_neg (A : Matrix n n R) : det (-A) = (-1) ^ Fintype.card n * det A := by\n  rw [\u2190 det_smul, neg_one_smul]\n\n/-- A variant of `Matrix.det_neg` with scalar multiplication by `Units \u2124` instead of multiplication\nby `R`. -/\ntheorem det_neg_eq_smul (A : Matrix n n R) :\n    det (-A) = (-1 : Units \u2124) ^ Fintype.card n \u2022 det A := by\n  rw [\u2190 det_smul_of_tower, Units.neg_smul, one_smul]\n\n/-- Multiplying each row by a fixed `v i` multiplies the determinant by\nthe product of the `v`s. -/\ntheorem det_mul_row (v : n \u2192 R) (A : Matrix n n R) :\n    det (of fun i j => v j * A i j) = (\u220f i, v i) * det A :=\n  calc\n    det (of fun i j => v j * A i j) = det (A * diagonal v) :=\n      congr_arg det <| by\n        ext\n        simp [mul_comm]\n    _ = (\u220f i, v i) * det A := by rw [det_mul, det_diagonal, mul_comm]\n\n/-- Multiplying each column by a fixed `v j` multiplies the determinant by\nthe product of the `v`s. -/\ntheorem det_mul_column (v : n \u2192 R) (A : Matrix n n R) :\n    det (of fun i j => v i * A i j) = (\u220f i, v i) * det A :=\n  MultilinearMap.map_smul_univ _ v A\n\n@[simp]\ntheorem det_pow (M : Matrix m m R) (n : \u2115) : det (M ^ n) = det M ^ n :=\n  (detMonoidHom : Matrix m m R \u2192* R).map_pow M n\n\nsection HomMap\n\nvariable {S : Type w} [CommRing S]\n\ntheorem _root_.RingHom.map_det (f : R \u2192+* S) (M : Matrix n n R) :\n    f M.det = Matrix.det (f.mapMatrix M) := by\n  simp [Matrix.det_apply', map_sum f, map_prod f]\n\ntheorem _root_.RingEquiv.map_det (f : R \u2243+* S) (M : Matrix n n R) :\n    f M.det = Matrix.det (f.mapMatrix M) :=\n  f.toRingHom.map_det _\n\ntheorem _root_.AlgHom.map_det [Algebra R S] {T : Type z} [CommRing T] [Algebra R T] (f : S \u2192\u2090[R] T)\n    (M : Matrix n n S) : f M.det = Matrix.det (f.mapMatrix M) :=\n  f.toRingHom.map_det _\n\ntheorem _root_.AlgEquiv.map_det [Algebra R S] {T : Type z} [CommRing T] [Algebra R T]\n    (f : S \u2243\u2090[R] T) (M : Matrix n n S) : f M.det = Matrix.det (f.mapMatrix M) :=\n  f.toAlgHom.map_det _\n\nend HomMap\n\n@[simp]\ntheorem det_conjTranspose [StarRing R] (M : Matrix m m R) : det M\u1d34 = star (det M) :=\n  ((starRingEnd R).map_det _).symm.trans <| congr_arg star M.det_transpose\n\nsection DetZero\n\n/-!\n### `det_zero` section\n\nProve that a matrix with a repeated column has determinant equal to zero.\n-/\n\n\ntheorem det_eq_zero_of_row_eq_zero {A : Matrix n n R} (i : n) (h : \u2200 j, A i j = 0) : det A = 0 :=\n  (detRowAlternating : (n \u2192 R) [\u22c0^n]\u2192\u2097[R] R).map_coord_zero i (funext h)\n\ntheorem det_eq_zero_of_column_eq_zero {A : Matrix n n R} (j : n) (h : \u2200 i, A i j = 0) :\n    det A = 0 := by\n  rw [\u2190 det_transpose]\n  exact det_eq_zero_of_row_eq_zero j h\n\nvariable {M : Matrix n n R} {i j : n}\n\n/-- If a matrix has a repeated row, the determinant will be zero. -/\ntheorem det_zero_of_row_eq (i_ne_j : i \u2260 j) (hij : M i = M j) : M.det = 0 :=\n  (detRowAlternating : (n \u2192 R) [\u22c0^n]\u2192\u2097[R] R).map_eq_zero_of_eq M hij i_ne_j\n\n/-- If a matrix has a repeated column, the determinant will be zero. -/\ntheorem det_zero_of_column_eq (i_ne_j : i \u2260 j) (hij : \u2200 k, M k i = M k j) : M.det = 0 := by\n  rw [\u2190 det_transpose, det_zero_of_row_eq i_ne_j]\n  exact funext hij\n\n/-- If we repeat a row of a matrix, we get a matrix of determinant zero. -/\ntheorem det_updateRow_eq_zero (h : i \u2260 j) :\n    (M.updateRow j (M i)).det = 0 := det_zero_of_row_eq h (by simp [h])\n\n", "theoremStatement": "/-- If we repeat a column of a matrix, we get a matrix of determinant zero. -/\ntheorem det_updateCol_eq_zero (h : i \u2260 j) :\n    (M.updateCol j (fun k \u21a6 M k i)).det = 0 ", "theoremName": "Matrix.det_updateCol_eq_zero", "fileCreated": {"commit": "3438911a821fa2fb5ba37cdbec993e952646aeca", "date": "2024-06-03"}, "theoremCreated": {"commit": "afdb9499da5095474266bcb3b723120eaf923aec", "date": "2024-12-11"}, "file": "mathlib/Mathlib/LinearAlgebra/Matrix/Determinant/Basic.lean", "module": "Mathlib.LinearAlgebra.Matrix.Determinant.Basic", "jsonFile": "Mathlib.LinearAlgebra.Matrix.Determinant.Basic.jsonl", "positionMetadata": {"lineInFile": 351, "tokenPositionInFile": 14238, "theoremPositionInFile": 45}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 14, "numPremises": 31}, "proofMetadata": {"hasProof": true, "proof": ":= det_zero_of_column_eq h (by simp [h])", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 40}}
{"srcContext": "/-\nCopyright (c) 2024 Xavier Roblot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Xavier Roblot\n-/\nimport Mathlib.Analysis.BoxIntegral.UnitPartition\nimport Mathlib.MeasureTheory.Measure.Haar.InnerProductSpace\n\n/-!\n# Covolume of \u2124-lattices\n\nLet `E` be a finite dimensional real vector space.\n\nLet `L` be a `\u2124`-lattice `L` defined as a discrete `\u2124`-submodule of `E` that spans `E` over `\u211d`.\n\n## Main definitions and results\n\n* `ZLattice.covolume`: the covolume of `L` defined as the volume of an arbitrary fundamental\ndomain of `L`.\n\n* `ZLattice.covolume_eq_measure_fundamentalDomain`: the covolume of `L` does not depend on the\nchoice of the fundamental domain of `L`.\n\n* `ZLattice.covolume_eq_det`: if `L` is a lattice in `\u211d^n`, then its covolume is the absolute\nvalue of the determinant of any `\u2124`-basis of `L`.\n\n* `ZLattice.covolume.tendsto_card_div_pow`: Let `s` be a bounded measurable set of `\u03b9 \u2192 \u211d`, then\nthe number of points in `s \u2229 n\u207b\u00b9 \u2022 L` divided by `n ^ card \u03b9` tends to `volume s / covolume L`\nwhen `n : \u2115` tends to infinity. See also `ZLattice.covolume.tendsto_card_div_pow'` for a version\nfor `InnerProductSpace \u211d E` and `ZLattice.covolume.tendsto_card_div_pow''` for the general version.\n\n* `ZLattice.covolume.tendsto_card_le_div`: Let `X` be a cone in `\u03b9 \u2192 \u211d` and let `F : (\u03b9 \u2192 \u211d) \u2192 \u211d`\nbe a function such that `F (c \u2022 x) = c ^ card \u03b9 * F x`. Then the number of points `x \u2208 X` such that\n`F x \u2264 c` divided by `c` tends to `volume {x \u2208 X | F x \u2264 1} / covolume L` when `c : \u211d` tends to\ninfinity. See also `ZLattice.covolume.tendsto_card_le_div'` for a version for\n`InnerProductSpace \u211d E` and `ZLattice.covolume.tendsto_card_le_div''` for the general version.\n\n## Naming convention\n\nSome results are true in the case where the ambient finite dimensional real vector space is the\npi-space `\u03b9 \u2192 \u211d` and in the case where it is an `InnerProductSpace`. We use the following\nconvention: the plain name is for the pi case, for eg. `volume_image_eq_volume_div_covolume`. For\nthe same result in the `InnerProductSpace` case, we add a `prime`, for eg.\n`volume_image_eq_volume_div_covolume'`. When the same result exists in the\ngeneral case, we had two primes, eg. `covolume.tendsto_card_div_pow''`.\n\n-/\n\nnoncomputable section\n\nnamespace ZLattice\n\nopen Submodule MeasureTheory Module MeasureTheory Module ZSpan\n\nsection General\n\nvariable {E : Type*} [NormedAddCommGroup E] [MeasurableSpace E] (L : Submodule \u2124 E)\n\n/-- The covolume of a `\u2124`-lattice is the volume of some fundamental domain; see\n`ZLattice.covolume_eq_volume` for the proof that the volume does not depend on the choice of\nthe fundamental domain. -/\ndef covolume (\u03bc : Measure E := by volume_tac) : \u211d := (addCovolume L E \u03bc).toReal\n\nend General\n\nsection Basic\n\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] [FiniteDimensional \u211d E]\nvariable [MeasurableSpace E] [BorelSpace E]\nvariable (L : Submodule \u2124 E) [DiscreteTopology L] [IsZLattice \u211d L]\nvariable (\u03bc : Measure E := by volume_tac) [Measure.IsAddHaarMeasure \u03bc]\n\ntheorem covolume_eq_measure_fundamentalDomain {F : Set E} (h : IsAddFundamentalDomain L F \u03bc) :\n    covolume L \u03bc = (\u03bc F).toReal := by\n  have : MeasurableVAdd L E := (inferInstance : MeasurableVAdd L.toAddSubgroup E)\n  have : VAddInvariantMeasure L E \u03bc := (inferInstance : VAddInvariantMeasure L.toAddSubgroup E \u03bc)\n  exact congr_arg ENNReal.toReal (h.covolume_eq_volume \u03bc)\n\ntheorem covolume_ne_zero : covolume L \u03bc \u2260 0 := by\n  rw [covolume_eq_measure_fundamentalDomain L \u03bc (isAddFundamentalDomain (Free.chooseBasis \u2124 L) \u03bc),\n    ENNReal.toReal_ne_zero]\n  refine \u27e8measure_fundamentalDomain_ne_zero _, ne_of_lt ?_\u27e9\n  exact Bornology.IsBounded.measure_lt_top (fundamentalDomain_isBounded _)\n\ntheorem covolume_pos : 0 < covolume L \u03bc :=\n  lt_of_le_of_ne ENNReal.toReal_nonneg (covolume_ne_zero L \u03bc).symm\n\ntheorem covolume_comap {F : Type*} [NormedAddCommGroup F] [NormedSpace \u211d F] [FiniteDimensional \u211d F]\n    [MeasurableSpace F] [BorelSpace F] (\u03bd : Measure F := by volume_tac) [Measure.IsAddHaarMeasure \u03bd]\n    {e : F \u2243L[\u211d] E} (he : MeasurePreserving e \u03bd \u03bc) :\n    covolume (ZLattice.comap \u211d L e.toLinearMap) \u03bd = covolume L \u03bc := by\n  rw [covolume_eq_measure_fundamentalDomain _ _ (isAddFundamentalDomain (Free.chooseBasis \u2124 L) \u03bc),\n    covolume_eq_measure_fundamentalDomain _ _ ((isAddFundamentalDomain\n    ((Free.chooseBasis \u2124 L).ofZLatticeComap \u211d L e.toLinearEquiv) \u03bd)), \u2190 he.measure_preimage\n    (fundamentalDomain_measurableSet _).nullMeasurableSet, \u2190 e.image_symm_eq_preimage,\n    \u2190 e.symm.coe_toLinearEquiv, map_fundamentalDomain]\n  congr!\n  ext; simp\n\ntheorem covolume_eq_det_mul_measure {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (b : Basis \u03b9 \u2124 L)\n    (b\u2080 : Basis \u03b9 \u211d E) :\n    covolume L \u03bc = |b\u2080.det ((\u2191) \u2218 b)| * (\u03bc (fundamentalDomain b\u2080)).toReal := by\n  rw [covolume_eq_measure_fundamentalDomain L \u03bc (isAddFundamentalDomain b \u03bc),\n    measure_fundamentalDomain _ _ b\u2080,\n    measure_congr (fundamentalDomain_ae_parallelepiped b\u2080 \u03bc), ENNReal.toReal_mul,\n    ENNReal.toReal_ofReal (by positivity)]\n  congr\n  ext\n  exact b.ofZLatticeBasis_apply \u211d L _\n\ntheorem covolume_eq_det {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (L : Submodule \u2124 (\u03b9 \u2192 \u211d))\n    [DiscreteTopology L] [IsZLattice \u211d L] (b : Basis \u03b9 \u2124 L) :\n    covolume L = |(Matrix.of ((\u2191) \u2218 b)).det| := by\n  rw [covolume_eq_measure_fundamentalDomain L volume (isAddFundamentalDomain b volume),\n    volume_fundamentalDomain, ENNReal.toReal_ofReal (by positivity)]\n  congr\n  ext1\n  exact b.ofZLatticeBasis_apply \u211d L _\n\ntheorem covolume_eq_det_inv {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (L : Submodule \u2124 (\u03b9 \u2192 \u211d))\n    [DiscreteTopology L] [IsZLattice \u211d L] (b : Basis \u03b9 \u2124 L) :\n    covolume L = |(LinearEquiv.det (b.ofZLatticeBasis \u211d L).equivFun : \u211d)|\u207b\u00b9 := by\n  rw [covolume_eq_det L b, \u2190 Pi.basisFun_det_apply, show (((\u2191) : L \u2192 _) \u2218 \u21d1b) =\n    (b.ofZLatticeBasis \u211d) by ext; simp, \u2190 Basis.det_inv, \u2190 abs_inv, Units.val_inv_eq_inv_val,\n    IsUnit.unit_spec, \u2190 Basis.det_basis, LinearEquiv.coe_det]\n  rfl\n\ntheorem volume_image_eq_volume_div_covolume {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9]\n    (L : Submodule \u2124 (\u03b9 \u2192 \u211d)) [DiscreteTopology L] [IsZLattice \u211d L] (b : Basis \u03b9 \u2124 L)\n    {s : Set (\u03b9 \u2192 \u211d)} :\n    volume ((b.ofZLatticeBasis \u211d L).equivFun '' s) = volume s / ENNReal.ofReal (covolume L) := by\n  rw [LinearEquiv.image_eq_preimage, Measure.addHaar_preimage_linearEquiv, LinearEquiv.symm_symm,\n    covolume_eq_det_inv L b, ENNReal.div_eq_inv_mul, ENNReal.ofReal_inv_of_pos\n    (abs_pos.mpr (LinearEquiv.det _).ne_zero), inv_inv, LinearEquiv.coe_det]\n\n/-- A more general version of `ZLattice.volume_image_eq_volume_div_covolume`;\nsee the `Naming conventions` section in the introduction. -/\ntheorem volume_image_eq_volume_div_covolume' {E : Type*} [NormedAddCommGroup E]\n    [InnerProductSpace \u211d E] [FiniteDimensional \u211d E] [MeasurableSpace E] [BorelSpace E]\n    (L : Submodule \u2124 E) [DiscreteTopology L] [IsZLattice \u211d L] {\u03b9 : Type*} [Fintype \u03b9]\n    (b : Basis \u03b9 \u2124 L) {s : Set E} (hs : NullMeasurableSet s) :\n    volume ((b.ofZLatticeBasis \u211d).equivFun '' s) = volume s / ENNReal.ofReal (covolume L) := by\n  classical\n  let e : Fin (finrank \u211d E) \u2243 \u03b9 :=\n    Fintype.equivOfCardEq (by rw [Fintype.card_fin, finrank_eq_card_basis (b.ofZLatticeBasis \u211d)])\n  let f := (EuclideanSpace.equiv \u03b9 \u211d).symm.trans\n    ((stdOrthonormalBasis \u211d E).reindex e).repr.toContinuousLinearEquiv.symm\n  have hf : MeasurePreserving f :=\n    ((stdOrthonormalBasis \u211d E).reindex e).measurePreserving_repr_symm.comp\n      (EuclideanSpace.volume_preserving_measurableEquiv \u03b9).symm\n  rw [\u2190 hf.measure_preimage hs, \u2190 (covolume_comap L volume volume hf),\n    \u2190 volume_image_eq_volume_div_covolume (ZLattice.comap \u211d L f.toLinearMap)\n    (b.ofZLatticeComap \u211d L f.toLinearEquiv), Basis.ofZLatticeBasis_comap,\n    \u2190 f.image_symm_eq_preimage, \u2190 Set.image_comp]\n  simp only [Basis.equivFun_apply, ContinuousLinearEquiv.symm_toLinearEquiv, Basis.map_equivFun,\n    LinearEquiv.symm_symm, Function.comp_apply, LinearEquiv.trans_apply,\n    ContinuousLinearEquiv.coe_toLinearEquiv, ContinuousLinearEquiv.apply_symm_apply]\n\nend Basic\n\nnamespace covolume\n\nsection General\n\nopen Filter Fintype Pointwise Topology BoxIntegral Bornology\n\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]\nvariable {L : Submodule \u2124 E} [DiscreteTopology L] [IsZLattice \u211d L]\nvariable {\u03b9 : Type*} [Fintype \u03b9] (b : Basis \u03b9 \u2124 L)\n\n/-- A version of `ZLattice.covolume.tendsto_card_div_pow` for the general case;\nsee the `Naming convention` section in the introduction. -/\ntheorem tendsto_card_div_pow'' [FiniteDimensional \u211d E] [MeasurableSpace E] [BorelSpace E]\n    {s : Set E} (hs\u2081 : IsBounded s) (hs\u2082 : MeasurableSet s)\n    (hs\u2083 : volume (frontier ((b.ofZLatticeBasis \u211d).equivFun '' s)) = 0):\n    Tendsto (fun n : \u2115 \u21a6 (Nat.card (s \u2229 (n : \u211d)\u207b\u00b9 \u2022 L : Set E) : \u211d) / n ^ card \u03b9)\n      atTop (\ud835\udcdd (volume ((b.ofZLatticeBasis \u211d).equivFun '' s)).toReal) := by\n  refine Tendsto.congr' ?_\n    (tendsto_card_div_pow_atTop_volume ((b.ofZLatticeBasis \u211d).equivFun '' s) ?_ ?_ hs\u2083)\n  \u00b7 filter_upwards [eventually_gt_atTop 0] with n hn\n    congr\n    refine Nat.card_congr <| ((b.ofZLatticeBasis \u211d).equivFun.toEquiv.subtypeEquiv fun x \u21a6 ?_).symm\n    simp_rw [Set.mem_inter_iff, \u2190 b.ofZLatticeBasis_span \u211d, LinearEquiv.coe_toEquiv,\n      Basis.equivFun_apply, Set.mem_image, DFunLike.coe_fn_eq, EmbeddingLike.apply_eq_iff_eq,\n      exists_eq_right, and_congr_right_iff, Set.mem_inv_smul_set_iff\u2080\n      (mod_cast hn.ne' : (n : \u211d) \u2260 0), \u2190 Finsupp.coe_smul, \u2190 LinearEquiv.map_smul, SetLike.mem_coe,\n      Basis.mem_span_iff_repr_mem, Pi.basisFun_repr, implies_true]\n  \u00b7 rw [\u2190 NormedSpace.isVonNBounded_iff \u211d] at hs\u2081 \u22a2\n    exact Bornology.IsVonNBounded.image hs\u2081 ((b.ofZLatticeBasis \u211d).equivFunL : E \u2192L[\u211d] \u03b9 \u2192 \u211d)\n  \u00b7 exact (b.ofZLatticeBasis \u211d).equivFunL.toHomeomorph.toMeasurableEquiv.measurableSet_image.mpr hs\u2082\n\nprivate theorem tendsto_card_le_div''_aux {X : Set E} (hX : \u2200 \u2983x\u2984 \u2983r:\u211d\u2984, x \u2208 X \u2192 0 < r \u2192 r \u2022 x \u2208 X)\n    {F : E \u2192 \u211d} (hF\u2081 : \u2200 x \u2983r : \u211d\u2984, 0 \u2264 r \u2192 F (r \u2022 x) = r ^ card \u03b9 * (F x)) {c : \u211d} (hc : 0 < c) :\n    c \u2022 {x \u2208 X | F x \u2264 1} = {x \u2208 X | F x \u2264 c ^ card \u03b9} := by\n  ext x\n  simp_rw [Set.mem_smul_set_iff_inv_smul_mem\u2080 hc.ne', Set.mem_setOf_eq, hF\u2081 _\n    (inv_pos_of_pos hc).le, inv_pow, inv_mul_le_iff\u2080 (pow_pos hc _), mul_one, and_congr_left_iff]\n  exact fun _ \u21a6 \u27e8fun h \u21a6 (smul_inv_smul\u2080 hc.ne' x) \u25b8 hX h hc, fun h \u21a6 hX h (inv_pos_of_pos hc)\u27e9\n\n/-- A version of `ZLattice.covolume.tendsto_card_le_div` for the general case;\nsee the `Naming conventions` section in the introduction. -/\ntheorem tendsto_card_le_div'' [FiniteDimensional \u211d E] [MeasurableSpace E] [BorelSpace E]\n    [Nonempty \u03b9] {X : Set E} (hX : \u2200 \u2983x\u2984 \u2983r : \u211d\u2984, x \u2208 X \u2192 0 < r \u2192 r \u2022 x \u2208 X)\n    {F : E \u2192 \u211d} (h\u2081 : \u2200 x \u2983r : \u211d\u2984, 0 \u2264 r \u2192  F (r \u2022 x) = r ^ card \u03b9 * (F x))\n    (h\u2082 : IsBounded {x \u2208 X | F x \u2264 1}) (h\u2083 : MeasurableSet {x \u2208 X | F x \u2264 1})\n    (h\u2084 : volume (frontier ((b.ofZLatticeBasis \u211d L).equivFun '' {x | x \u2208 X \u2227 F x \u2264 1})) = 0) :\n    Tendsto (fun c : \u211d \u21a6\n      Nat.card ({x \u2208 X | F x \u2264 c} \u2229 L : Set E) / (c : \u211d))\n        atTop (\ud835\udcdd (volume ((b.ofZLatticeBasis \u211d).equivFun '' {x \u2208 X | F x \u2264 1})).toReal) := by\n\n  refine Tendsto.congr' ?_ <| (tendsto_card_div_pow_atTop_volume'\n      ((b.ofZLatticeBasis \u211d).equivFun '' {x \u2208 X | F x \u2264 1}) ?_ ?_ h\u2084 fun x y hx hy \u21a6 ?_).comp\n        (tendsto_rpow_atTop <| inv_pos.mpr\n          (Nat.cast_pos.mpr card_pos) : Tendsto (fun x \u21a6 x ^ (card \u03b9 : \u211d)\u207b\u00b9) atTop atTop)\n  \u00b7 filter_upwards [eventually_gt_atTop 0] with c hc\n    have aux\u2081 : (card \u03b9 : \u211d) \u2260 0 := Nat.cast_ne_zero.mpr card_ne_zero\n    have aux\u2082 : 0 < c ^ (card \u03b9 : \u211d)\u207b\u00b9 := Real.rpow_pos_of_pos hc _\n    have aux\u2083 : (c ^ (card \u03b9 : \u211d)\u207b\u00b9)\u207b\u00b9 \u2260 0 := inv_ne_zero aux\u2082.ne'\n    have aux\u2084 : c ^ (-(card \u03b9 : \u211d)\u207b\u00b9) \u2260 0 := (Real.rpow_pos_of_pos hc _).ne'\n    obtain \u27e8hc\u2081, hc\u2082\u27e9 := lt_iff_le_and_ne.mp hc\n    rw [Function.comp_apply, \u2190 Real.rpow_natCast, Real.rpow_inv_rpow hc\u2081 aux\u2081, eq_comm]\n    congr\n    refine Nat.card_congr <| Equiv.subtypeEquiv ((b.ofZLatticeBasis \u211d).equivFun.toEquiv.trans\n          (Equiv.smulRight aux\u2084)) fun _ \u21a6 ?_\n    rw [Set.mem_inter_iff, Set.mem_inter_iff, Equiv.trans_apply, LinearEquiv.coe_toEquiv,\n      Equiv.smulRight_apply, Real.rpow_neg hc\u2081, Set.smul_mem_smul_set_iff\u2080 aux\u2083,\n      \u2190 Set.mem_smul_set_iff_inv_smul_mem\u2080 aux\u2082.ne', \u2190 image_smul_set,\n      tendsto_card_le_div''_aux hX h\u2081 aux\u2082, \u2190 Real.rpow_natCast, \u2190 Real.rpow_mul hc\u2081,\n      inv_mul_cancel\u2080 aux\u2081, Real.rpow_one]\n    simp_rw [SetLike.mem_coe, Set.mem_image, EmbeddingLike.apply_eq_iff_eq, exists_eq_right,\n      and_congr_right_iff, \u2190 b.ofZLatticeBasis_span \u211d, Basis.mem_span_iff_repr_mem,\n      Pi.basisFun_repr, Basis.equivFun_apply, implies_true]\n  \u00b7 rw [\u2190 NormedSpace.isVonNBounded_iff \u211d] at h\u2082 \u22a2\n    exact Bornology.IsVonNBounded.image h\u2082 ((b.ofZLatticeBasis \u211d).equivFunL : E \u2192L[\u211d] \u03b9 \u2192 \u211d)\n  \u00b7 exact (b.ofZLatticeBasis \u211d).equivFunL.toHomeomorph.toMeasurableEquiv.measurableSet_image.mpr h\u2083\n  \u00b7 simp_rw [\u2190 image_smul_set]\n    apply Set.image_mono\n    rw [tendsto_card_le_div''_aux hX h\u2081 hx,\n      tendsto_card_le_div''_aux hX h\u2081 (lt_of_lt_of_le hx hy)]\n    exact fun a \u27e8ha\u2081, ha\u2082\u27e9 \u21a6 \u27e8ha\u2081, le_trans ha\u2082 <| pow_le_pow_left\u2080 (le_of_lt hx) hy _\u27e9\n\nend General\n\nsection Pi\n\nopen Filter Fintype Pointwise Topology Bornology\n\n", "theoremStatement": "private theorem frontier_equivFun {E : Type*} [AddCommGroup E] [Module \u211d E] {\u03b9 : Type*} [Fintype \u03b9]\n    [TopologicalSpace E] [TopologicalAddGroup E] [ContinuousSMul \u211d E] [T2Space E]\n    (b : Basis \u03b9 \u211d E) (s : Set E) :\n    frontier (b.equivFun '' s) = b.equivFun '' (frontier s) ", "theoremName": "ZLattice.covolume.frontier_equivFun", "fileCreated": {"commit": "85d6c78ac5782869d041c2ca6d3ca83cdde412c3", "date": "2024-09-09"}, "theoremCreated": {"commit": "211dc533566a173988a01067bb50d7917a097103", "date": "2024-12-18"}, "file": "mathlib/Mathlib/Algebra/Module/ZLattice/Covolume.lean", "module": "Mathlib.Algebra.Module.ZLattice.Covolume", "jsonFile": "Mathlib.Algebra.Module.ZLattice.Covolume.jsonl", "positionMetadata": {"lineInFile": 248, "tokenPositionInFile": 13168, "theoremPositionInFile": 13}, "dependencyMetadata": {"inFilePremises": null, "numInFilePremises": null, "repositoryPremises": null, "numRepositoryPremises": null, "numPremises": null}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [LinearEquiv.image_eq_preimage, LinearEquiv.image_eq_preimage]\n  exact (Homeomorph.preimage_frontier b.equivFunL.toHomeomorph.symm s).symm", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 149}}
{"srcContext": "/-\nCopyright (c) 2024 Jo\u00ebl Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jo\u00ebl Riou\n-/\nimport Mathlib.Algebra.Homology.Embedding.Extend\nimport Mathlib.Algebra.Homology.Embedding.IsSupported\nimport Mathlib.Algebra.Homology.QuasiIso\n\n/-!\n# Homology of the extension of an homological complex\n\nGiven an embedding `e : c.Embedding c'` and `K : HomologicalComplex C c`, we shall\ncompute the homology of `K.extend e`. In degrees that are not in the image of `e.f`,\nthe homology is obviously zero. When `e.f j = j`, we construct an isomorphism\n`(K.extend e).homology j' \u2245 K.homology j`.\n\n-/\n\nopen CategoryTheory Limits Category\n\nnamespace HomologicalComplex\n\nvariable {\u03b9 \u03b9' : Type*} {c : ComplexShape \u03b9} {c' : ComplexShape \u03b9'}\n  {C : Type*} [Category C] [HasZeroMorphisms C]\n  [HasZeroObject C]\n\nvariable (K L M : HomologicalComplex C c) (\u03c6 : K \u27f6 L) (\u03c6' : L \u27f6 M) (e : c.Embedding c')\n\nnamespace extend\n\nsection HomologyData\n\nvariable {i j k : \u03b9} {i' j' k' : \u03b9'} (hj' : e.f j = j')\n  (hi : c.prev j = i) (hi' : c'.prev j' = i') (hk : c.next j = k) (hk' : c'.next j' = k')\n\ninclude hk hk' in\nlemma comp_d_eq_zero_iff \u2983W : C\u2984 (\u03c6 : W \u27f6 K.X j) :\n    \u03c6 \u226b K.d j k = 0 \u2194 \u03c6 \u226b (K.extendXIso e hj').inv \u226b (K.extend e).d j' k' = 0 := by\n  by_cases hjk : c.Rel j k\n  \u00b7 have hk' : e.f k = k' := by rw [\u2190 hk', \u2190 hj', c'.next_eq' (e.rel hjk)]\n    rw [K.extend_d_eq e hj' hk', Iso.inv_hom_id_assoc,\n      \u2190 cancel_mono (K.extendXIso e hk').inv, zero_comp, assoc]\n  \u00b7 simp only [K.shape _ _ hjk, comp_zero, true_iff]\n    rw [K.extend_d_from_eq_zero e j' k' j hj', comp_zero, comp_zero]\n    rw [hk]\n    exact hjk\n\ninclude hi hi' in\nlemma d_comp_eq_zero_iff \u2983W : C\u2984 (\u03c6 : K.X j \u27f6 W) :\n    K.d i j \u226b \u03c6 = 0 \u2194 (K.extend e).d i' j' \u226b (K.extendXIso e hj').hom \u226b \u03c6 = 0 := by\n  by_cases hij : c.Rel i j\n  \u00b7 have hi' : e.f i = i' := by rw [\u2190 hi', \u2190 hj', c'.prev_eq' (e.rel hij)]\n    rw [K.extend_d_eq e hi' hj', assoc, assoc, Iso.inv_hom_id_assoc,\n      \u2190 cancel_epi (K.extendXIso e hi').hom, comp_zero]\n  \u00b7 simp only [K.shape _ _ hij, zero_comp, true_iff]\n    rw [K.extend_d_to_eq_zero e i' j' j hj', zero_comp]\n    rw [hi]\n    exact hij\n\nnamespace leftHomologyData\n\nvariable (cone : KernelFork (K.d j k)) (hcone : IsLimit cone)\n\n/-- The kernel fork of `(K.extend e).d j' k'` that is deduced from a kernel\nfork of `K.d j k `. -/\n@[simp]\nnoncomputable def kernelFork : KernelFork ((K.extend e).d j' k') :=\n  KernelFork.of\u03b9 (cone.\u03b9 \u226b (extendXIso K e hj').inv)\n    (by rw [assoc, \u2190 comp_d_eq_zero_iff K e hj' hk hk' cone.\u03b9, cone.condition])\n\n/-- The limit kernel fork of `(K.extend e).d j' k'` that is deduced from a limit\nkernel fork of `K.d j k `. -/\nnoncomputable def isLimitKernelFork : IsLimit (kernelFork K e hj' hk hk' cone) :=\n  KernelFork.isLimitOfIsLimitOfIff hcone ((K.extend e).d j' k')\n    (extendXIso K e hj').symm (comp_d_eq_zero_iff K e hj' hk hk')\n\nvariable (cocone : CokernelCofork (hcone.lift (KernelFork.of\u03b9 (K.d i j) (K.d_comp_d i j k))))\n  (hcocone : IsColimit cocone)\n\ninclude hi hi' hcone in\n/-- Auxiliary lemma for `lift_d_comp_eq_zero_iff`. -/\nlemma lift_d_comp_eq_zero_iff' \u2983W : C\u2984 (f' : K.X i \u27f6 cone.pt)\n    (hf' : f' \u226b cone.\u03b9 = K.d i j)\n    (f'' : (K.extend e).X i' \u27f6 cone.pt)\n    (hf'' : f'' \u226b cone.\u03b9 \u226b (extendXIso K e hj').inv = (K.extend e).d i' j')\n    (\u03c6 : cone.pt \u27f6 W) :\n    f' \u226b \u03c6 = 0 \u2194 f'' \u226b \u03c6 = 0 := by\n  by_cases hij : c.Rel i j\n  \u00b7 have hi'' : e.f i = i' := by rw [\u2190 hi', \u2190 hj', c'.prev_eq' (e.rel hij)]\n    have : (K.extendXIso e hi'').hom \u226b f' = f'' := by\n      apply Fork.IsLimit.hom_ext hcone\n      rw [assoc, hf', \u2190 cancel_mono (extendXIso K e hj').inv, assoc, assoc, hf'',\n        K.extend_d_eq e hi'' hj']\n    rw [\u2190 cancel_epi (K.extendXIso e hi'').hom, comp_zero, \u2190 this, assoc]\n  \u00b7 have h\u2081 : f' = 0 := by\n      apply Fork.IsLimit.hom_ext hcone\n      simp only [zero_comp, hf', K.shape _ _ hij]\n    have h\u2082 : f'' = 0 := by\n      apply Fork.IsLimit.hom_ext hcone\n      dsimp\n      rw [\u2190 cancel_mono (extendXIso K e hj').inv, assoc, hf'', zero_comp, zero_comp,\n        K.extend_d_to_eq_zero e i' j' j hj']\n      rw [hi]\n      exact hij\n    simp [h\u2081, h\u2082]\n\ninclude hi hi' in\nlemma lift_d_comp_eq_zero_iff \u2983W : C\u2984 (\u03c6 : cone.pt \u27f6 W) :\n    hcone.lift (KernelFork.of\u03b9 (K.d i j) (K.d_comp_d i j k)) \u226b \u03c6 = 0 \u2194\n      ((isLimitKernelFork K e hj' hk hk' cone hcone).lift\n      (KernelFork.of\u03b9 ((K.extend e).d i' j') (d_comp_d _ _ _ _))) \u226b \u03c6 = 0 :=\n  lift_d_comp_eq_zero_iff' K e hj' hi hi' cone hcone _ (hcone.fac _ _) _\n    (IsLimit.fac _ _ WalkingParallelPair.zero) _\n\n/-- Auxiliary definition for `extend.leftHomologyData`. -/\nnoncomputable def cokernelCofork :\n    CokernelCofork ((isLimitKernelFork K e hj' hk hk' cone hcone).lift\n      (KernelFork.of\u03b9 ((K.extend e).d i' j') (d_comp_d _ _ _ _))) :=\n  CokernelCofork.of\u03c0 cocone.\u03c0 (by\n    rw [\u2190 lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' cone hcone]\n    exact cocone.condition)\n\n/-- Auxiliary definition for `extend.leftHomologyData`. -/\nnoncomputable def isColimitCokernelCofork :\n    IsColimit (cokernelCofork K e hj' hi hi' hk hk' cone hcone cocone) :=\n  CokernelCofork.isColimitOfIsColimitOfIff' hcocone _\n    (lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' cone hcone)\n\nend leftHomologyData\n\nopen leftHomologyData in\n/-- The left homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a left homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def leftHomologyData (h : (K.sc' i j k).LeftHomologyData) :\n    ((K.extend e).sc' i' j' k').LeftHomologyData where\n  K := h.K\n  H := h.H\n  i := h.i \u226b (extendXIso K e hj').inv\n  \u03c0 := h.\u03c0\n  wi := by\n    dsimp\n    rw [assoc, \u2190 comp_d_eq_zero_iff K e hj' hk hk']\n    exact h.wi\n  hi := isLimitKernelFork K e hj' hk hk' _ h.hi\n  w\u03c0 := by\n    dsimp\n    rw [\u2190 lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' _ h.hi]\n    exact h.w\u03c0\n  h\u03c0 := isColimitCokernelCofork K e hj' hi hi' hk hk' _ h.hi _ h.h\u03c0\n\nnamespace rightHomologyData\n\nvariable (cocone : CokernelCofork (K.d i j)) (hcocone : IsColimit cocone)\n\n/-- The cokernel cofork of `(K.extend e).d i' j'` that is deduced from a cokernel\ncofork of `K.d i j`. -/\n@[simp]\nnoncomputable def cokernelCofork : CokernelCofork ((K.extend e).d i' j') :=\n  CokernelCofork.of\u03c0 ((extendXIso K e hj').hom \u226b cocone.\u03c0) (by\n    rw [\u2190 d_comp_eq_zero_iff K e hj' hi hi' cocone.\u03c0, cocone.condition])\n\n/-- The colimit cokernel cofork of `(K.extend e).d i' j'` that is deduced from a\ncolimit cokernel cofork of `K.d i j`. -/\nnoncomputable def isColimitCokernelCofork : IsColimit (cokernelCofork K e hj' hi hi' cocone) :=\n  CokernelCofork.isColimitOfIsColimitOfIff hcocone ((K.extend e).d i' j')\n    (extendXIso K e hj') (d_comp_eq_zero_iff K e hj' hi hi')\n\nvariable (cone : KernelFork (hcocone.desc (CokernelCofork.of\u03c0 (K.d j k) (K.d_comp_d i j k))))\n  (hcone : IsLimit cone)\n\ninclude hk hk' hcocone in\nlemma d_comp_desc_eq_zero_iff' \u2983W : C\u2984 (f' : cocone.pt \u27f6 K.X k)\n    (hf' : cocone.\u03c0 \u226b f' = K.d j k)\n    (f'' : cocone.pt \u27f6 (K.extend e).X k')\n    (hf'' : (extendXIso K e hj').hom \u226b cocone.\u03c0 \u226b f'' = (K.extend e).d j' k')\n    (\u03c6 : W \u27f6 cocone.pt) :\n    \u03c6 \u226b f' = 0 \u2194 \u03c6 \u226b f'' = 0 := by\n  by_cases hjk : c.Rel j k\n  \u00b7 have hk'' : e.f k = k' := by rw [\u2190 hk', \u2190 hj', c'.next_eq' (e.rel hjk)]\n    have : f' \u226b (K.extendXIso e hk'').inv = f'' := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      rw [reassoc_of% hf', \u2190 cancel_epi (extendXIso K e hj').hom, hf'',\n        K.extend_d_eq e hj' hk'']\n    rw [\u2190 cancel_mono (K.extendXIso e hk'').inv, zero_comp, assoc, this]\n  \u00b7 have h\u2081 : f' = 0 := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      simp only [hf', comp_zero, K.shape _ _ hjk]\n    have h\u2082 : f'' = 0 := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      rw [\u2190 cancel_epi (extendXIso K e hj').hom, hf'', comp_zero, comp_zero,\n        K.extend_d_from_eq_zero e j' k' j hj']\n      rw [hk]\n      exact hjk\n    simp [h\u2081, h\u2082]\n\ninclude hk hk' in\nlemma d_comp_desc_eq_zero_iff \u2983W : C\u2984 (\u03c6 : W \u27f6 cocone.pt) :\n    \u03c6 \u226b hcocone.desc (CokernelCofork.of\u03c0 (K.d j k) (K.d_comp_d i j k)) = 0 \u2194\n      \u03c6 \u226b ((isColimitCokernelCofork K e hj' hi hi' cocone hcocone).desc\n      (CokernelCofork.of\u03c0 ((K.extend e).d j' k') (d_comp_d _ _ _ _))) = 0 :=\n  d_comp_desc_eq_zero_iff' K e hj' hk hk' cocone hcocone _ (hcocone.fac _ _) _ (by\n    simpa using (isColimitCokernelCofork K e hj' hi hi' cocone hcocone).fac _\n      WalkingParallelPair.one) _\n\n/-- Auxiliary definition for `extend.rightHomologyData`. -/\nnoncomputable def kernelFork :\n    KernelFork ((isColimitCokernelCofork K e hj' hi hi' cocone hcocone).desc\n      (CokernelCofork.of\u03c0 ((K.extend e).d j' k') (d_comp_d _ _ _ _))) :=\n  KernelFork.of\u03b9 cone.\u03b9 (by\n    rw [\u2190 d_comp_desc_eq_zero_iff K e hj' hi hi' hk hk' cocone hcocone]\n    exact cone.condition)\n\n/-- Auxiliary definition for `extend.rightHomologyData`. -/\nnoncomputable def isLimitKernelFork :\n    IsLimit (kernelFork K e hj' hi hi' hk hk' cocone hcocone cone) :=\n  KernelFork.isLimitOfIsLimitOfIff' hcone _\n    (d_comp_desc_eq_zero_iff K e hj' hi hi' hk hk' cocone hcocone)\n\nend rightHomologyData\n\nopen rightHomologyData in\n/-- The right homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a right homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def rightHomologyData (h : (K.sc' i j k).RightHomologyData) :\n    ((K.extend e).sc' i' j' k').RightHomologyData where\n  Q := h.Q\n  H := h.H\n  p := (extendXIso K e hj').hom \u226b h.p\n  \u03b9 := h.\u03b9\n  wp := by\n    dsimp\n    rw [\u2190 d_comp_eq_zero_iff K e hj' hi hi']\n    exact h.wp\n  hp := isColimitCokernelCofork K e hj' hi hi' _ h.hp\n  w\u03b9 := by\n    dsimp\n    rw [\u2190 d_comp_desc_eq_zero_iff K e hj' hi hi' hk hk' _ h.hp]\n    exact h.w\u03b9\n  h\u03b9 := isLimitKernelFork K e hj' hi hi' hk hk' _ h.hp _ h.h\u03b9\n\n/-- Computation of the `g'` field of `extend.rightHomologyData`. -/\nlemma rightHomologyData_g' (h : (K.sc' i j k).RightHomologyData) (hk'' : e.f k = k') :\n    (rightHomologyData K e hj' hi hi' hk hk' h).g' = h.g' \u226b (K.extendXIso e hk'').inv := by\n  rw [\u2190 cancel_epi h.p, \u2190 cancel_epi (extendXIso K e hj').hom]\n  have := (rightHomologyData K e hj' hi hi' hk hk' h).p_g'\n  dsimp at this\n  rw [assoc] at this\n  rw [this, K.extend_d_eq e hj' hk'', h.p_g'_assoc, shortComplexFunctor'_obj_g]\n\n/-- The homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def homologyData (h : (K.sc' i j k).HomologyData) :\n    ((K.extend e).sc' i' j' k').HomologyData where\n  left := leftHomologyData K e hj' hi hi' hk hk' h.left\n  right := rightHomologyData K e hj' hi hi' hk hk' h.right\n  iso := h.iso\n\n/-- The homology data of `(K.extend e).sc j'` that is deduced\nfrom a homology data of `K.sc' i j k`. -/\n@[simps!]\nnoncomputable def homologyData' (h : (K.sc' i j k).HomologyData) :\n    ((K.extend e).sc j').HomologyData :=\n  homologyData K e hj' hi rfl hk rfl h\n\nend HomologyData\n\nlemma hasHomology {j : \u03b9} {j' : \u03b9'} (hj' : e.f j = j') [K.HasHomology j] :\n    (K.extend e).HasHomology j' :=\n  ShortComplex.HasHomology.mk'\n    (homologyData' K e hj' rfl rfl ((K.sc j).homologyData))\n\ninstance (j : \u03b9) [K.HasHomology j] : (K.extend e).HasHomology (e.f j) :=\n  hasHomology K e rfl\n\ninstance [\u2200 j, K.HasHomology j] (j' : \u03b9') : (K.extend e).HasHomology j' := by\n  by_cases h : \u2203 j, e.f j = j'\n  \u00b7 obtain \u27e8j, rfl\u27e9 := h\n    infer_instance\n  \u00b7 have hj := isZero_extend_X K e j' (by tauto)\n    exact ShortComplex.HasHomology.mk'\n      (ShortComplex.HomologyData.ofZeros _ (hj.eq_of_tgt _ _) (hj.eq_of_src _ _))\n\nend extend\n\nlemma extend_exactAt (j' : \u03b9') (hj' : \u2200 j, e.f j \u2260 j') :\n    (K.extend e).ExactAt j' :=\n  exactAt_of_isSupported _ e j' hj'\n\nsection\n\nvariable {j : \u03b9} {j' : \u03b9'} (hj' : e.f j = j') [K.HasHomology j] [L.HasHomology j]\n  [(K.extend e).HasHomology j'] [(L.extend e).HasHomology j']\n\n/-- The isomorphism `(K.extend e).cycles j' \u2245 K.cycles j` when `e.f j = j'`. -/\nnoncomputable def extendCyclesIso :\n    (K.extend e).cycles j' \u2245 K.cycles j :=\n  (extend.homologyData' K e hj' rfl rfl (K.sc j).homologyData).left.cyclesIso \u226a\u226b\n    (K.sc j).homologyData.left.cyclesIso.symm\n\n/-- The isomorphism `(K.extend e).opcycles j' \u2245 K.opcycles j` when `e.f j = j'`. -/\nnoncomputable def extendOpcyclesIso :\n    (K.extend e).opcycles j' \u2245 K.opcycles j :=\n  (extend.homologyData' K e hj' rfl rfl (K.sc j).homologyData).right.opcyclesIso \u226a\u226b\n    (K.sc j).homologyData.right.opcyclesIso.symm\n\n/-- The isomorphism `(K.extend e).homology j' \u2245 K.homology j` when `e.f j = j'`. -/\nnoncomputable def extendHomologyIso :\n    (K.extend e).homology j' \u2245 K.homology j :=\n  (extend.homologyData' K e hj' rfl rfl (K.sc j).homologyData).left.homologyIso \u226a\u226b\n    (K.sc j).homologyData.left.homologyIso.symm\n\ninclude hj' in\nlemma extend_exactAt_iff :\n    (K.extend e).ExactAt j' \u2194 K.ExactAt j := by\n  simp only [HomologicalComplex.exactAt_iff_isZero_homology]\n  exact (K.extendHomologyIso e hj').isZero_iff\n\n@[reassoc (attr := simp)]\nlemma extendCyclesIso_hom_iCycles :\n    (K.extendCyclesIso e hj').hom \u226b K.iCycles j =\n      (K.extend e).iCycles j' \u226b (K.extendXIso e hj').hom := by\n  rw [\u2190 cancel_epi (K.extendCyclesIso e hj').inv, Iso.inv_hom_id_assoc]\n  dsimp [extendCyclesIso, iCycles]\n  rw [assoc, ShortComplex.LeftHomologyData.cyclesIso_inv_comp_iCycles_assoc]\n  dsimp\n  rw [assoc, Iso.inv_hom_id, comp_id,\n    ShortComplex.LeftHomologyData.cyclesIso_hom_comp_i]\n\n@[reassoc (attr := simp)]\nlemma extendCyclesIso_inv_iCycles :\n    (K.extendCyclesIso e hj').inv \u226b (K.extend e).iCycles j' =\n      K.iCycles j \u226b (K.extendXIso e hj').inv := by\n  simp only [\u2190 cancel_epi (K.extendCyclesIso e hj').hom, Iso.hom_inv_id_assoc,\n    extendCyclesIso_hom_iCycles_assoc, Iso.hom_inv_id, comp_id]\n\n@[reassoc (attr := simp)]\nlemma homology\u03c0_extendHomologyIso_hom :\n    (K.extend e).homology\u03c0 j' \u226b (K.extendHomologyIso e hj').hom =\n      (K.extendCyclesIso e hj').hom \u226b K.homology\u03c0 j := by\n  dsimp [extendHomologyIso, homology\u03c0]\n  rw [ShortComplex.LeftHomologyData.homology\u03c0_comp_homologyIso_hom_assoc,\n    \u2190 cancel_mono (K.sc j).homologyData.left.homologyIso.hom,\n    assoc, assoc, assoc, Iso.inv_hom_id, comp_id,\n    ShortComplex.LeftHomologyData.homology\u03c0_comp_homologyIso_hom]\n  dsimp [extendCyclesIso]\n  simp only [assoc, Iso.inv_hom_id_assoc]\n\n@[reassoc (attr := simp)]\nlemma homology\u03c0_extendHomologyIso_inv :\n    K.homology\u03c0 j \u226b (K.extendHomologyIso e hj').inv =\n      (K.extendCyclesIso e hj').inv \u226b (K.extend e).homology\u03c0 j' := by\n  simp only [\u2190 cancel_mono (K.extendHomologyIso e hj').hom,\n    assoc, Iso.inv_hom_id, comp_id, homology\u03c0_extendHomologyIso_hom, Iso.inv_hom_id_assoc]\n\n@[reassoc (attr := simp)]\nlemma pOpcycles_extendOpcyclesIso_inv :\n    K.pOpcycles j \u226b (K.extendOpcyclesIso e hj').inv =\n      (K.extendXIso e hj').inv \u226b (K.extend e).pOpcycles j' := by\n  rw [\u2190 cancel_mono (K.extendOpcyclesIso e hj').hom, assoc, assoc, Iso.inv_hom_id, comp_id]\n  dsimp [extendOpcyclesIso, pOpcycles]\n  rw [ShortComplex.RightHomologyData.pOpcycles_comp_opcyclesIso_hom_assoc]\n  dsimp\n  rw [assoc, Iso.inv_hom_id_assoc, ShortComplex.RightHomologyData.p_comp_opcyclesIso_inv]\n  rfl\n\n@[reassoc (attr := simp)]\nlemma pOpcycles_extendOpcyclesIso_hom :\n    (K.extend e).pOpcycles j' \u226b (K.extendOpcyclesIso e hj').hom =\n      (K.extendXIso e hj').hom \u226b K.pOpcycles j := by\n  simp only [\u2190 cancel_mono (K.extendOpcyclesIso e hj').inv,\n    assoc, Iso.hom_inv_id, comp_id, pOpcycles_extendOpcyclesIso_inv, Iso.hom_inv_id_assoc]\n\n@[reassoc (attr := simp)]\nlemma extendHomologyIso_hom_homology\u03b9 :\n    (K.extendHomologyIso e hj').hom \u226b K.homology\u03b9 j =\n      (K.extend e).homology\u03b9 j' \u226b (K.extendOpcyclesIso e hj').hom := by\n  simp only [\u2190 cancel_epi ((K.extend e).homology\u03c0 j'),\n    homology\u03c0_extendHomologyIso_hom_assoc, homology_\u03c0_\u03b9, extendCyclesIso_hom_iCycles_assoc,\n    homology_\u03c0_\u03b9_assoc, pOpcycles_extendOpcyclesIso_hom]\n\n@[reassoc (attr := simp)]\nlemma extendHomologyIso_inv_homology\u03b9 :\n    (K.extendHomologyIso e hj').inv \u226b (K.extend e).homology\u03b9 j' =\n      K.homology\u03b9 j \u226b (K.extendOpcyclesIso e hj').inv := by\n  simp only [\u2190 cancel_epi (K.extendHomologyIso e hj').hom,\n    Iso.hom_inv_id_assoc, extendHomologyIso_hom_homology\u03b9_assoc, Iso.hom_inv_id, comp_id]\n\nvariable {K L}\n\n@[reassoc (attr := simp)]\nlemma extendCyclesIso_hom_naturality :\n    cyclesMap (extendMap \u03c6 e) j' \u226b (L.extendCyclesIso e hj').hom =\n      (K.extendCyclesIso e hj').hom \u226b cyclesMap \u03c6 j := by\n  simp [\u2190 cancel_mono (L.iCycles j), extendMap_f \u03c6 e hj']\n\n", "theoremStatement": "@[reassoc (attr := simp)]\nlemma extendHomologyIso_hom_naturality :\n    homologyMap (extendMap \u03c6 e) j' \u226b (L.extendHomologyIso e hj').hom =\n      (K.extendHomologyIso e hj').hom \u226b homologyMap \u03c6 j ", "theoremName": "HomologicalComplex.extendHomologyIso_hom_naturality", "fileCreated": {"commit": "9bdc1af76cf75d960f42c29f1c09917785066c8b", "date": "2024-11-30"}, "theoremCreated": {"commit": "b07a551a1451cbf8615f4e2a6c47052affadbae4", "date": "2025-01-17"}, "file": "mathlib/Mathlib/Algebra/Homology/Embedding/ExtendHomology.lean", "module": "Mathlib.Algebra.Homology.Embedding.ExtendHomology", "jsonFile": "Mathlib.Algebra.Homology.Embedding.ExtendHomology.jsonl", "positionMetadata": {"lineInFile": 400, "tokenPositionInFile": 16305, "theoremPositionInFile": 31}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 5, "repositoryPremises": true, "numRepositoryPremises": 30, "numPremises": 39}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp [\u2190 cancel_epi ((K.extend e).homology\u03c0 _)]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 54}}
{"srcContext": "/-\nCopyright (c) 2018 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes, Abhimanyu Pallavi Sudhir, Jean Lo, Calle S\u00f6nne, S\u00e9bastien Gou\u00ebzel,\n  R\u00e9my Degenne\n-/\nimport Mathlib.Analysis.SpecialFunctions.Pow.Continuity\nimport Mathlib.Analysis.SpecialFunctions.Complex.LogDeriv\nimport Mathlib.Analysis.Calculus.FDeriv.Extend\nimport Mathlib.Analysis.Calculus.Deriv.Prod\nimport Mathlib.Analysis.SpecialFunctions.Log.Deriv\nimport Mathlib.Analysis.SpecialFunctions.Trigonometric.Deriv\n\n/-!\n# Derivatives of power function on `\u2102`, `\u211d`, `\u211d\u22650`, and `\u211d\u22650\u221e`\n\nWe also prove differentiability and provide derivatives for the power functions `x ^ y`.\n-/\n\n\nnoncomputable section\n\nopen scoped Real Topology NNReal ENNReal\nopen Filter\n\nnamespace Complex\n\ntheorem hasStrictFDerivAt_cpow {p : \u2102 \u00d7 \u2102} (hp : p.1 \u2208 slitPlane) :\n    HasStrictFDerivAt (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2)\n      ((p.2 * p.1 ^ (p.2 - 1)) \u2022 ContinuousLinearMap.fst \u2102 \u2102 \u2102 +\n        (p.1 ^ p.2 * log p.1) \u2022 ContinuousLinearMap.snd \u2102 \u2102 \u2102) p := by\n  have A : p.1 \u2260 0 := slitPlane_ne_zero hp\n  have : (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2) =\u1da0[\ud835\udcdd p] fun x => exp (log x.1 * x.2) :=\n    ((isOpen_ne.preimage continuous_fst).eventually_mem A).mono fun p hp =>\n      cpow_def_of_ne_zero hp _\n  rw [cpow_sub _ _ A, cpow_one, mul_div_left_comm, mul_smul, mul_smul]\n  refine HasStrictFDerivAt.congr_of_eventuallyEq ?_ this.symm\n  simpa only [cpow_def_of_ne_zero A, div_eq_mul_inv, mul_smul, add_comm, smul_add] using\n    ((hasStrictFDerivAt_fst.clog hp).mul hasStrictFDerivAt_snd).cexp\n\ntheorem hasStrictFDerivAt_cpow' {x y : \u2102} (hp : x \u2208 slitPlane) :\n    HasStrictFDerivAt (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2)\n      ((y * x ^ (y - 1)) \u2022 ContinuousLinearMap.fst \u2102 \u2102 \u2102 +\n        (x ^ y * log x) \u2022 ContinuousLinearMap.snd \u2102 \u2102 \u2102) (x, y) :=\n  @hasStrictFDerivAt_cpow (x, y) hp\n\ntheorem hasStrictDerivAt_const_cpow {x y : \u2102} (h : x \u2260 0 \u2228 y \u2260 0) :\n    HasStrictDerivAt (fun y => x ^ y) (x ^ y * log x) y := by\n  rcases em (x = 0) with (rfl | hx)\n  \u00b7 replace h := h.neg_resolve_left rfl\n    rw [log_zero, mul_zero]\n    refine (hasStrictDerivAt_const y 0).congr_of_eventuallyEq ?_\n    exact (isOpen_ne.eventually_mem h).mono fun y hy => (zero_cpow hy).symm\n  \u00b7 simpa only [cpow_def_of_ne_zero hx, mul_one] using\n      ((hasStrictDerivAt_id y).const_mul (log x)).cexp\n\ntheorem hasFDerivAt_cpow {p : \u2102 \u00d7 \u2102} (hp : p.1 \u2208 slitPlane) :\n    HasFDerivAt (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2)\n      ((p.2 * p.1 ^ (p.2 - 1)) \u2022 ContinuousLinearMap.fst \u2102 \u2102 \u2102 +\n        (p.1 ^ p.2 * log p.1) \u2022 ContinuousLinearMap.snd \u2102 \u2102 \u2102) p :=\n  (hasStrictFDerivAt_cpow hp).hasFDerivAt\n\nend Complex\n\nsection fderiv\n\nopen Complex\n\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f g : E \u2192 \u2102} {f' g' : E \u2192L[\u2102] \u2102}\n  {x : E} {s : Set E} {c : \u2102}\n\ntheorem HasStrictFDerivAt.cpow (hf : HasStrictFDerivAt f f' x) (hg : HasStrictFDerivAt g g' x)\n    (h0 : f x \u2208 slitPlane) : HasStrictFDerivAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) \u2022 f' + (f x ^ g x * Complex.log (f x)) \u2022 g') x := by\n  convert (@hasStrictFDerivAt_cpow ((fun x => (f x, g x)) x) h0).comp x (hf.prod hg)\n\ntheorem HasStrictFDerivAt.const_cpow (hf : HasStrictFDerivAt f f' x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasStrictFDerivAt (fun x => c ^ f x) ((c ^ f x * Complex.log c) \u2022 f') x :=\n  (hasStrictDerivAt_const_cpow h0).comp_hasStrictFDerivAt x hf\n\ntheorem HasFDerivAt.cpow (hf : HasFDerivAt f f' x) (hg : HasFDerivAt g g' x)\n    (h0 : f x \u2208 slitPlane) : HasFDerivAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) \u2022 f' + (f x ^ g x * Complex.log (f x)) \u2022 g') x := by\n  convert (@Complex.hasFDerivAt_cpow ((fun x => (f x, g x)) x) h0).comp x (hf.prod hg)\n\ntheorem HasFDerivAt.const_cpow (hf : HasFDerivAt f f' x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasFDerivAt (fun x => c ^ f x) ((c ^ f x * Complex.log c) \u2022 f') x :=\n  (hasStrictDerivAt_const_cpow h0).hasDerivAt.comp_hasFDerivAt x hf\n\ntheorem HasFDerivWithinAt.cpow (hf : HasFDerivWithinAt f f' s x) (hg : HasFDerivWithinAt g g' s x)\n    (h0 : f x \u2208 slitPlane) : HasFDerivWithinAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) \u2022 f' + (f x ^ g x * Complex.log (f x)) \u2022 g') s x := by\n  convert\n    (@Complex.hasFDerivAt_cpow ((fun x => (f x, g x)) x) h0).comp_hasFDerivWithinAt x (hf.prod hg)\n\ntheorem HasFDerivWithinAt.const_cpow (hf : HasFDerivWithinAt f f' s x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasFDerivWithinAt (fun x => c ^ f x) ((c ^ f x * Complex.log c) \u2022 f') s x :=\n  (hasStrictDerivAt_const_cpow h0).hasDerivAt.comp_hasFDerivWithinAt x hf\n\ntheorem DifferentiableAt.cpow (hf : DifferentiableAt \u2102 f x) (hg : DifferentiableAt \u2102 g x)\n    (h0 : f x \u2208 slitPlane) : DifferentiableAt \u2102 (fun x => f x ^ g x) x :=\n  (hf.hasFDerivAt.cpow hg.hasFDerivAt h0).differentiableAt\n\ntheorem DifferentiableAt.const_cpow (hf : DifferentiableAt \u2102 f x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    DifferentiableAt \u2102 (fun x => c ^ f x) x :=\n  (hf.hasFDerivAt.const_cpow h0).differentiableAt\n\ntheorem DifferentiableAt.cpow_const (hf : DifferentiableAt \u2102 f x) (h0 : f x \u2208 slitPlane) :\n    DifferentiableAt \u2102 (fun x => f x ^ c) x :=\n  hf.cpow (differentiableAt_const c) h0\n\ntheorem DifferentiableWithinAt.cpow (hf : DifferentiableWithinAt \u2102 f s x)\n    (hg : DifferentiableWithinAt \u2102 g s x) (h0 : f x \u2208 slitPlane) :\n    DifferentiableWithinAt \u2102 (fun x => f x ^ g x) s x :=\n  (hf.hasFDerivWithinAt.cpow hg.hasFDerivWithinAt h0).differentiableWithinAt\n\ntheorem DifferentiableWithinAt.const_cpow (hf : DifferentiableWithinAt \u2102 f s x)\n    (h0 : c \u2260 0 \u2228 f x \u2260 0) : DifferentiableWithinAt \u2102 (fun x => c ^ f x) s x :=\n  (hf.hasFDerivWithinAt.const_cpow h0).differentiableWithinAt\n\ntheorem DifferentiableWithinAt.cpow_const (hf : DifferentiableWithinAt \u2102 f s x)\n    (h0 : f x \u2208 slitPlane) :\n    DifferentiableWithinAt \u2102 (fun x => f x ^ c) s x :=\n  hf.cpow (differentiableWithinAt_const c) h0\n\ntheorem DifferentiableOn.cpow (hf : DifferentiableOn \u2102 f s) (hg : DifferentiableOn \u2102 g s)\n    (h0 : Set.MapsTo f s slitPlane) : DifferentiableOn \u2102 (fun x \u21a6 f x ^ g x) s :=\n  fun x hx \u21a6 (hf x hx).cpow (hg x hx) (h0 hx)\n\ntheorem DifferentiableOn.const_cpow (hf : DifferentiableOn \u2102 f s)\n    (h0 : c \u2260 0 \u2228 \u2200 x \u2208 s, f x \u2260 0) : DifferentiableOn \u2102 (fun x \u21a6 c ^ f x) s :=\n  fun x hx \u21a6 (hf x hx).const_cpow (h0.imp_right fun h \u21a6 h x hx)\n\ntheorem DifferentiableOn.cpow_const (hf : DifferentiableOn \u2102 f s)\n    (h0 : \u2200 x \u2208 s, f x \u2208 slitPlane) :\n    DifferentiableOn \u2102 (fun x => f x ^ c) s :=\n  hf.cpow (differentiableOn_const c) h0\n\ntheorem Differentiable.cpow (hf : Differentiable \u2102 f) (hg : Differentiable \u2102 g)\n    (h0 : \u2200 x, f x \u2208 slitPlane) : Differentiable \u2102 (fun x \u21a6 f x ^ g x) :=\n  fun x \u21a6 (hf x).cpow (hg x) (h0 x)\n\ntheorem Differentiable.const_cpow (hf : Differentiable \u2102 f)\n    (h0 : c \u2260 0 \u2228 \u2200 x, f x \u2260 0) : Differentiable \u2102 (fun x \u21a6 c ^ f x) :=\n  fun x \u21a6 (hf x).const_cpow (h0.imp_right fun h \u21a6 h x)\n\n@[fun_prop]\nlemma differentiable_const_cpow_of_neZero (z : \u2102) [NeZero z] :\n    Differentiable \u2102 fun s : \u2102 \u21a6 z ^ s :=\n  differentiable_id.const_cpow (.inl <| NeZero.ne z)\n\n@[fun_prop]\nlemma differentiableAt_const_cpow_of_neZero (z : \u2102) [NeZero z] (t : \u2102) :\n    DifferentiableAt \u2102 (fun s : \u2102 \u21a6 z ^ s) t :=\n  differentiableAt_id.const_cpow (.inl <| NeZero.ne z)\n\nend fderiv\n\nsection deriv\n\nopen Complex\n\nvariable {f g : \u2102 \u2192 \u2102} {s : Set \u2102} {f' g' x c : \u2102}\n\n/-- A private lemma that rewrites the output of lemmas like `HasFDerivAt.cpow` to the form\nexpected by lemmas like `HasDerivAt.cpow`. -/\nprivate theorem aux : ((g x * f x ^ (g x - 1)) \u2022 (1 : \u2102 \u2192L[\u2102] \u2102).smulRight f' +\n    (f x ^ g x * log (f x)) \u2022 (1 : \u2102 \u2192L[\u2102] \u2102).smulRight g') 1 =\n      g x * f x ^ (g x - 1) * f' + f x ^ g x * log (f x) * g' := by\n  simp only [Algebra.id.smul_eq_mul, one_mul, ContinuousLinearMap.one_apply,\n    ContinuousLinearMap.smulRight_apply, ContinuousLinearMap.add_apply, Pi.smul_apply,\n    ContinuousLinearMap.coe_smul']\n\nnonrec theorem HasStrictDerivAt.cpow (hf : HasStrictDerivAt f f' x) (hg : HasStrictDerivAt g g' x)\n    (h0 : f x \u2208 slitPlane) : HasStrictDerivAt (fun x => f x ^ g x)\n      (g x * f x ^ (g x - 1) * f' + f x ^ g x * Complex.log (f x) * g') x := by\n  simpa using (hf.cpow hg h0).hasStrictDerivAt\n\ntheorem HasStrictDerivAt.const_cpow (hf : HasStrictDerivAt f f' x) (h : c \u2260 0 \u2228 f x \u2260 0) :\n    HasStrictDerivAt (fun x => c ^ f x) (c ^ f x * Complex.log c * f') x :=\n  (hasStrictDerivAt_const_cpow h).comp x hf\n\ntheorem Complex.hasStrictDerivAt_cpow_const (h : x \u2208 slitPlane) :\n    HasStrictDerivAt (fun z : \u2102 => z ^ c) (c * x ^ (c - 1)) x := by\n  simpa only [mul_zero, add_zero, mul_one] using\n    (hasStrictDerivAt_id x).cpow (hasStrictDerivAt_const x c) h\n\ntheorem HasStrictDerivAt.cpow_const (hf : HasStrictDerivAt f f' x)\n    (h0 : f x \u2208 slitPlane) :\n    HasStrictDerivAt (fun x => f x ^ c) (c * f x ^ (c - 1) * f') x :=\n  (Complex.hasStrictDerivAt_cpow_const h0).comp x hf\n\ntheorem HasDerivAt.cpow (hf : HasDerivAt f f' x) (hg : HasDerivAt g g' x)\n    (h0 : f x \u2208 slitPlane) : HasDerivAt (fun x => f x ^ g x)\n      (g x * f x ^ (g x - 1) * f' + f x ^ g x * Complex.log (f x) * g') x := by\n  simpa only [aux] using (hf.hasFDerivAt.cpow hg h0).hasDerivAt\n\ntheorem HasDerivAt.const_cpow (hf : HasDerivAt f f' x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasDerivAt (fun x => c ^ f x) (c ^ f x * Complex.log c * f') x :=\n  (hasStrictDerivAt_const_cpow h0).hasDerivAt.comp x hf\n\ntheorem HasDerivAt.cpow_const (hf : HasDerivAt f f' x) (h0 : f x \u2208 slitPlane) :\n    HasDerivAt (fun x => f x ^ c) (c * f x ^ (c - 1) * f') x :=\n  (Complex.hasStrictDerivAt_cpow_const h0).hasDerivAt.comp x hf\n\ntheorem HasDerivWithinAt.cpow (hf : HasDerivWithinAt f f' s x) (hg : HasDerivWithinAt g g' s x)\n    (h0 : f x \u2208 slitPlane) : HasDerivWithinAt (fun x => f x ^ g x)\n      (g x * f x ^ (g x - 1) * f' + f x ^ g x * Complex.log (f x) * g') s x := by\n  simpa only [aux] using (hf.hasFDerivWithinAt.cpow hg h0).hasDerivWithinAt\n\ntheorem HasDerivWithinAt.const_cpow (hf : HasDerivWithinAt f f' s x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasDerivWithinAt (fun x => c ^ f x) (c ^ f x * Complex.log c * f') s x :=\n  (hasStrictDerivAt_const_cpow h0).hasDerivAt.comp_hasDerivWithinAt x hf\n\ntheorem HasDerivWithinAt.cpow_const (hf : HasDerivWithinAt f f' s x)\n    (h0 : f x \u2208 slitPlane) :\n    HasDerivWithinAt (fun x => f x ^ c) (c * f x ^ (c - 1) * f') s x :=\n  (Complex.hasStrictDerivAt_cpow_const h0).hasDerivAt.comp_hasDerivWithinAt x hf\n\n/-- Although `fun x => x ^ r` for fixed `r` is *not* complex-differentiable along the negative real\nline, it is still real-differentiable, and the derivative is what one would formally expect.\nSee `hasDerivAt_ofReal_cpow_const` for an alternate formulation. -/\ntheorem hasDerivAt_ofReal_cpow_const' {x : \u211d} (hx : x \u2260 0) {r : \u2102} (hr : r \u2260 -1) :\n    HasDerivAt (fun y : \u211d => (y : \u2102) ^ (r + 1) / (r + 1)) (x ^ r) x := by\n  rw [Ne, \u2190 add_eq_zero_iff_eq_neg, \u2190 Ne] at hr\n  rcases lt_or_gt_of_ne hx.symm with (hx | hx)\n  \u00b7 -- easy case : `0 < x`\n    -- Porting note: proof used to be\n    -- convert (((hasDerivAt_id (x : \u2102)).cpow_const _).div_const (r + 1)).comp_ofReal using 1\n    -- \u00b7 rw [add_sub_cancel, id.def, mul_one, mul_comm, mul_div_cancel _ hr]\n    -- \u00b7 rw [id.def, ofReal_re]; exact Or.inl hx\n    apply HasDerivAt.comp_ofReal (e := fun y => (y : \u2102) ^ (r + 1) / (r + 1))\n    convert HasDerivAt.div_const (\ud835\udd5c := \u2102) ?_ (r + 1) using 1\n    \u00b7 exact (mul_div_cancel_right\u2080 _ hr).symm\n    \u00b7 convert HasDerivAt.cpow_const ?_ ?_ using 1\n      \u00b7 rw [add_sub_cancel_right, mul_comm]; exact (mul_one _).symm\n      \u00b7 exact hasDerivAt_id (x : \u2102)\n      \u00b7 simp [hx]\n  \u00b7 -- harder case : `x < 0`\n    have : \u2200\u1da0 y : \u211d in \ud835\udcdd x,\n        (y : \u2102) ^ (r + 1) / (r + 1) = (-y : \u2102) ^ (r + 1) * exp (\u03c0 * I * (r + 1)) / (r + 1) := by\n      refine Filter.eventually_of_mem (Iio_mem_nhds hx) fun y hy => ?_\n      rw [ofReal_cpow_of_nonpos (le_of_lt hy)]\n    refine HasDerivAt.congr_of_eventuallyEq ?_ this\n    rw [ofReal_cpow_of_nonpos (le_of_lt hx)]\n    suffices HasDerivAt (fun y : \u211d => (-\u2191y) ^ (r + 1) * exp (\u2191\u03c0 * I * (r + 1)))\n        ((r + 1) * (-\u2191x) ^ r * exp (\u2191\u03c0 * I * r)) x by\n      convert this.div_const (r + 1) using 1\n      conv_rhs => rw [mul_assoc, mul_comm, mul_div_cancel_right\u2080 _ hr]\n    rw [mul_add ((\u03c0 : \u2102) * _), mul_one, exp_add, exp_pi_mul_I, mul_comm (_ : \u2102) (-1 : \u2102),\n      neg_one_mul]\n    simp_rw [mul_neg, \u2190 neg_mul, \u2190 ofReal_neg]\n    suffices HasDerivAt (fun y : \u211d => (\u2191(-y) : \u2102) ^ (r + 1)) (-(r + 1) * \u2191(-x) ^ r) x by\n      convert this.neg.mul_const _ using 1; ring\n    suffices HasDerivAt (fun y : \u211d => (y : \u2102) ^ (r + 1)) ((r + 1) * \u2191(-x) ^ r) (-x) by\n      convert @HasDerivAt.scomp \u211d _ \u2102 _ _ x \u211d _ _ _ _ _ _ _ _ this (hasDerivAt_neg x) using 1\n      rw [real_smul, ofReal_neg 1, ofReal_one]; ring\n    suffices HasDerivAt (fun y : \u2102 => y ^ (r + 1)) ((r + 1) * \u2191(-x) ^ r) \u2191(-x) by\n      exact this.comp_ofReal\n    conv in \u2191_ ^ _ => rw [(by ring : r = r + 1 - 1)]\n    convert HasDerivAt.cpow_const ?_ ?_ using 1\n    \u00b7 rw [add_sub_cancel_right, add_sub_cancel_right]; exact (mul_one _).symm\n    \u00b7 exact hasDerivAt_id ((-x : \u211d) : \u2102)\n    \u00b7 simp [hx]\n\n@[deprecated (since := \"2024-12-15\")] alias hasDerivAt_ofReal_cpow := hasDerivAt_ofReal_cpow_const'\n\n/-- An alternate formulation of `hasDerivAt_ofReal_cpow_const'`. -/\ntheorem hasDerivAt_ofReal_cpow_const {x : \u211d} (hx : x \u2260 0) {r : \u2102} (hr : r \u2260 0) :\n    HasDerivAt (fun y : \u211d => (y : \u2102) ^ r) (r * x ^ (r - 1)) x := by\n  have := HasDerivAt.const_mul r <| hasDerivAt_ofReal_cpow_const' hx\n    (by rwa [ne_eq, sub_eq_neg_self])\n  simpa [sub_add_cancel, mul_div_cancel\u2080 _ hr] using this\n\n/-- A version of `DifferentiableAt.cpow_const` for a real function. -/\ntheorem DifferentiableAt.ofReal_cpow_const {f : \u211d \u2192 \u211d} {x : \u211d} (hf : DifferentiableAt \u211d f x)\n    (h0 : f x \u2260 0) (h1 : c \u2260 0) :\n    DifferentiableAt \u211d (fun (y : \u211d) => (f y : \u2102) ^ c) x :=\n  (hasDerivAt_ofReal_cpow_const h0 h1).differentiableAt.comp x hf\n\n", "theoremStatement": "theorem Complex.deriv_cpow_const (hx : x \u2208 Complex.slitPlane) :\n    deriv (fun (x : \u2102) \u21a6 x ^ c) x = c * x ^ (c - 1) ", "theoremName": "Complex.deriv_cpow_const", "fileCreated": {"commit": "a9359cb30d5d2eb08c3c66959305c82fe45fab66", "date": "2023-06-06"}, "theoremCreated": {"commit": "006641492734e60b369ac830260c46c2dcdb7342", "date": "2025-01-20"}, "file": "mathlib/Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean", "module": "Mathlib.Analysis.SpecialFunctions.Pow.Deriv", "jsonFile": "Mathlib.Analysis.SpecialFunctions.Pow.Deriv.jsonl", "positionMetadata": {"lineInFile": 281, "tokenPositionInFile": 13774, "theoremPositionInFile": 37}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 30, "numPremises": 39}, "proofMetadata": {"hasProof": true, "proof": ":=\n  (hasStrictDerivAt_cpow_const hx).hasDerivAt.deriv", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 54}}
{"srcContext": "/-\nCopyright (c) 2022 Ya\u00ebl Dillies. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Ya\u00ebl Dillies, Yury Kudryashov\n-/\nimport Mathlib.Analysis.Convex.Normed\nimport Mathlib.Analysis.Normed.Module.Ray\n\n/-!\n# Strictly convex spaces\n\nThis file defines strictly convex spaces. A normed space is strictly convex if all closed balls are\nstrictly convex. This does **not** mean that the norm is strictly convex (in fact, it never is).\n\n## Main definitions\n\n`StrictConvexSpace`: a typeclass saying that a given normed space over a normed linear ordered\nfield (e.g., `\u211d` or `\u211a`) is strictly convex. The definition requires strict convexity of a closed\nball of positive radius with center at the origin; strict convexity of any other closed ball follows\nfrom this assumption.\n\n## Main results\n\nIn a strictly convex space, we prove\n\n- `strictConvex_closedBall`: a closed ball is strictly convex.\n- `combo_mem_ball_of_ne`, `openSegment_subset_ball_of_ne`, `norm_combo_lt_of_ne`:\n  a nontrivial convex combination of two points in a closed ball belong to the corresponding open\n  ball;\n- `norm_add_lt_of_not_sameRay`, `sameRay_iff_norm_add`, `dist_add_dist_eq_iff`:\n  the triangle inequality `dist x y + dist y z \u2264 dist x z` is a strict inequality unless `y` belongs\n  to the segment `[x -[\u211d] z]`.\n- `Isometry.affineIsometryOfStrictConvexSpace`: an isometry of `NormedAddTorsor`s for real\n  normed spaces, strictly convex in the case of the codomain, is an affine isometry.\n\nWe also provide several lemmas that can be used as alternative constructors for `StrictConvex \u211d E`:\n\n- `StrictConvexSpace.of_strictConvex_unitClosedBall`: if `closed_ball (0 : E) 1` is strictly\n  convex, then `E` is a strictly convex space;\n\n- `StrictConvexSpace.of_norm_add`: if `\u2016x + y\u2016 = \u2016x\u2016 + \u2016y\u2016` implies `SameRay \u211d x y` for all\n  nonzero `x y : E`, then `E` is a strictly convex space.\n\n## Implementation notes\n\nWhile the definition is formulated for any normed linear ordered field, most of the lemmas are\nformulated only for the case `\ud835\udd5c = \u211d`.\n\n## Tags\n\nconvex, strictly convex\n-/\n\nopen Convex Pointwise Set Metric\n\n/-- A *strictly convex space* is a normed space where the closed balls are strictly convex. We only\nrequire balls of positive radius with center at the origin to be strictly convex in the definition,\nthen prove that any closed ball is strictly convex in `strictConvex_closedBall` below.\n\nSee also `StrictConvexSpace.of_strictConvex_unitClosedBall`. -/\nclass StrictConvexSpace (\ud835\udd5c E : Type*) [NormedLinearOrderedField \ud835\udd5c] [NormedAddCommGroup E]\n  [NormedSpace \ud835\udd5c E] : Prop where\n  strictConvex_closedBall : \u2200 r : \u211d, 0 < r \u2192 StrictConvex \ud835\udd5c (closedBall (0 : E) r)\n\nvariable (\ud835\udd5c : Type*) {E : Type*} [NormedLinearOrderedField \ud835\udd5c] [NormedAddCommGroup E]\n  [NormedSpace \ud835\udd5c E]\n\n/-- A closed ball in a strictly convex space is strictly convex. -/\ntheorem strictConvex_closedBall [StrictConvexSpace \ud835\udd5c E] (x : E) (r : \u211d) :\n    StrictConvex \ud835\udd5c (closedBall x r) := by\n  rcases le_or_lt r 0 with hr | hr\n  \u00b7 exact (subsingleton_closedBall x hr).strictConvex\n  rw [\u2190 vadd_closedBall_zero]\n  exact (StrictConvexSpace.strictConvex_closedBall r hr).vadd _\n\nvariable [NormedSpace \u211d E]\n\n", "theoremStatement": "/-- A real normed vector space is strictly convex provided that the unit ball is strictly convex. -/\ntheorem StrictConvexSpace.of_strictConvex_unitClosedBall [LinearMap.CompatibleSMul E E \ud835\udd5c \u211d]\n    (h : StrictConvex \ud835\udd5c (closedBall (0 : E) 1)) : StrictConvexSpace \ud835\udd5c E ", "theoremName": "StrictConvexSpace.of_strictConvex_unitClosedBall", "fileCreated": {"commit": "0500ff5e151c067712d54b27a6c191b7e937aea2", "date": "2023-05-20"}, "theoremCreated": {"commit": "79dae4b2147c58f873a92001dcfd20688afd8618", "date": "2024-12-18"}, "file": "mathlib/Mathlib/Analysis/Convex/StrictConvexSpace.lean", "module": "Mathlib.Analysis.Convex.StrictConvexSpace", "jsonFile": "Mathlib.Analysis.Convex.StrictConvexSpace.jsonl", "positionMetadata": {"lineInFile": 78, "tokenPositionInFile": 3193, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 67, "numPremises": 72}, "proofMetadata": {"hasProof": true, "proof": ":=\n  \u27e8fun r hr => by simpa only [smul_unitClosedBall_of_nonneg hr.le] using h.smul r\u27e9", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 85}}
{"srcContext": "/-\nCopyright (c) 2016 Jeremy Avigad. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jeremy Avigad, Leonardo de Moura, Mario Carneiro\n-/\nimport Mathlib.Algebra.Order.Monoid.Canonical.Defs\nimport Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Order.Sub.Basic\nimport Mathlib.Algebra.Ring.Parity\n\n/-!\n# Canonically ordered rings and semirings.\n-/\n\n\nopen Function\n\nuniverse u\n\nvariable {\u03b1 : Type u}\n\nset_option linter.deprecated false in\n/-- A canonically ordered commutative semiring is an ordered, commutative semiring in which `a \u2264 b`\niff there exists `c` with `b = a + c`. This is satisfied by the natural numbers, for example, but\nnot the integers or other ordered groups. -/\n@[deprecated \"Use `[OrderedCommSemiring \u03b1] [CanonicallyOrderedAdd \u03b1] [NoZeroDivisors \u03b1]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyOrderedCommSemiring (\u03b1 : Type*) extends CanonicallyOrderedAddCommMonoid \u03b1,\n    CommSemiring \u03b1 where\n  /-- No zero divisors. -/\n  protected eq_zero_or_eq_zero_of_mul_eq_zero : \u2200 {a b : \u03b1}, a * b = 0 \u2192 a = 0 \u2228 b = 0\n\nattribute [nolint docBlame] CanonicallyOrderedCommSemiring.toCommSemiring\n\n-- see Note [lower instance priority]\ninstance (priority := 10) CanonicallyOrderedAdd.toZeroLEOneClass\n    [AddZeroClass \u03b1] [One \u03b1] [LE \u03b1] [CanonicallyOrderedAdd \u03b1] : ZeroLEOneClass \u03b1 where\n  zero_le_one := zero_le _\n\n-- this holds more generally if we refactor `Odd` to use\n-- either `2 \u2022 t` or `t + t` instead of `2 * t`.\nlemma Odd.pos [Semiring \u03b1] [PartialOrder \u03b1] [CanonicallyOrderedAdd \u03b1] [Nontrivial \u03b1] {a : \u03b1} :\n    Odd a \u2192 0 < a := by\n  rintro \u27e8k, rfl\u27e9; simp\n\nnamespace CanonicallyOrderedAdd\n\n-- see Note [lower instance priority]\ninstance (priority := 100) toMulLeftMono [NonUnitalNonAssocSemiring \u03b1]\n    [LE \u03b1] [CanonicallyOrderedAdd \u03b1] : MulLeftMono \u03b1 := by\n  refine \u27e8fun a b c h => ?_\u27e9; dsimp\n  rcases exists_add_of_le h with \u27e8c, rfl\u27e9\n  rw [mul_add]\n  apply self_le_add_right\n\nvariable [CommSemiring \u03b1] [PartialOrder \u03b1] [CanonicallyOrderedAdd \u03b1]\n\n-- See note [reducible non-instances]\n/-- Construct an `OrderedCommMonoid` from a canonically ordered `CommSemiring`. -/\nabbrev toOrderedCommMonoid : OrderedCommMonoid \u03b1 where\n  mul_le_mul_left _ _ := mul_le_mul_left'\n\n-- See note [reducible non-instances]\n/-- Construct an `OrderedCommSemiring` from a canonically ordered `CommSemiring`. -/\nabbrev toOrderedCommSemiring : OrderedCommSemiring \u03b1 where\n  mul_comm := mul_comm\n  zero_le_one := zero_le _\n  add_le_add_left _ _ := add_le_add_left\n  mul_le_mul_of_nonneg_left := fun _ _ _ h _ => mul_le_mul_left' h _\n  mul_le_mul_of_nonneg_right := fun _ _ _ h _ => mul_le_mul_right' h _\n\n@[simp]\nprotected theorem mul_pos [NoZeroDivisors \u03b1] {a b : \u03b1} :\n    0 < a * b \u2194 0 < a \u2227 0 < b := by\n  simp only [pos_iff_ne_zero, ne_eq, mul_eq_zero, not_or]\n\n", "theoremStatement": "lemma pow_pos [NoZeroDivisors \u03b1] {a : \u03b1} (ha : 0 < a) (n : \u2115) : 0 < a ^ n ", "theoremName": "CanonicallyOrderedAdd.pow_pos", "fileCreated": {"commit": "51eda27af18442eba843165dd41a0895d7220038", "date": "2022-12-08"}, "theoremCreated": {"commit": "e9450cdc3e8f6ab0d8f2aaf93a66fb92350f8167", "date": "2025-01-16"}, "file": "mathlib/Mathlib/Algebra/Order/Ring/Canonical.lean", "module": "Mathlib.Algebra.Order.Ring.Canonical", "jsonFile": "Mathlib.Algebra.Order.Ring.Canonical.jsonl", "positionMetadata": {"lineInFile": 77, "tokenPositionInFile": 2824, "theoremPositionInFile": 2}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 26, "numPremises": 34}, "proofMetadata": {"hasProof": true, "proof": ":=\n  pos_iff_ne_zero.2 <| pow_ne_zero _ ha.ne'", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 46}}
{"srcContext": "/-\nCopyright (c) 2018 Robert Y. Lewis. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Robert Y. Lewis, Mario Carneiro, Johan Commelin\n-/\nimport Mathlib.NumberTheory.Padics.PadicNumbers\nimport Mathlib.RingTheory.DiscreteValuationRing.Basic\n\n/-!\n# p-adic integers\n\nThis file defines the `p`-adic integers `\u2124_[p]` as the subtype of `\u211a_[p]` with norm `\u2264 1`.\nWe show that `\u2124_[p]`\n* is complete,\n* is nonarchimedean,\n* is a normed ring,\n* is a local ring, and\n* is a discrete valuation ring.\n\nThe relation between `\u2124_[p]` and `ZMod p` is established in another file.\n\n## Important definitions\n\n* `PadicInt` : the type of `p`-adic integers\n\n## Notation\n\nWe introduce the notation `\u2124_[p]` for the `p`-adic integers.\n\n## Implementation notes\n\nMuch, but not all, of this file assumes that `p` is prime. This assumption is inferred automatically\nby taking `[Fact p.Prime]` as a type class argument.\n\nCoercions into `\u2124_[p]` are set up to work with the `norm_cast` tactic.\n\n## References\n\n* [F. Q. Gouv\u00eaa, *p-adic numbers*][gouvea1997]\n* [R. Y. Lewis, *A formal proof of Hensel's lemma over the p-adic integers*][lewis2019]\n* <https://en.wikipedia.org/wiki/P-adic_number>\n\n## Tags\n\np-adic, p adic, padic, p-adic integer\n-/\n\n\nopen Padic Metric IsLocalRing\n\nnoncomputable section\n\nvariable (p : \u2115) [hp : Fact p.Prime]\n\n/-- The `p`-adic integers `\u2124_[p]` are the `p`-adic numbers with norm `\u2264 1`. -/\ndef PadicInt : Type := {x : \u211a_[p] // \u2016x\u2016 \u2264 1}\n\n/-- The ring of `p`-adic integers. -/\nnotation \"\u2124_[\" p \"]\" => PadicInt p\n\nnamespace PadicInt\nvariable {p} {x y : \u2124_[p]}\n\n/-! ### Ring structure and coercion to `\u211a_[p]` -/\n\ninstance : Coe \u2124_[p] \u211a_[p] :=\n  \u27e8Subtype.val\u27e9\n\ntheorem ext {x y : \u2124_[p]} : (x : \u211a_[p]) = y \u2192 x = y :=\n  Subtype.ext\n\nvariable (p)\n\n/-- The `p`-adic integers as a subring of `\u211a_[p]`. -/\ndef subring : Subring \u211a_[p] where\n  carrier := { x : \u211a_[p] | \u2016x\u2016 \u2264 1 }\n  zero_mem' := by norm_num\n  one_mem' := by norm_num\n  add_mem' hx hy := (padicNormE.nonarchimedean _ _).trans <| max_le_iff.2 \u27e8hx, hy\u27e9\n  mul_mem' hx hy := (padicNormE.mul _ _).trans_le <| mul_le_one\u2080 hx (norm_nonneg _) hy\n  neg_mem' hx := (norm_neg _).trans_le hx\n\n@[simp]\ntheorem mem_subring_iff {x : \u211a_[p]} : x \u2208 subring p \u2194 \u2016x\u2016 \u2264 1 := Iff.rfl\n\nvariable {p}\n\n/-- Addition on `\u2124_[p]` is inherited from `\u211a_[p]`. -/\ninstance : Add \u2124_[p] := (by infer_instance : Add (subring p))\n\n/-- Multiplication on `\u2124_[p]` is inherited from `\u211a_[p]`. -/\ninstance : Mul \u2124_[p] := (by infer_instance : Mul (subring p))\n\n/-- Negation on `\u2124_[p]` is inherited from `\u211a_[p]`. -/\ninstance : Neg \u2124_[p] := (by infer_instance : Neg (subring p))\n\n/-- Subtraction on `\u2124_[p]` is inherited from `\u211a_[p]`. -/\ninstance : Sub \u2124_[p] := (by infer_instance : Sub (subring p))\n\n/-- Zero on `\u2124_[p]` is inherited from `\u211a_[p]`. -/\ninstance : Zero \u2124_[p] := (by infer_instance : Zero (subring p))\n\ninstance : Inhabited \u2124_[p] := \u27e80\u27e9\n\n/-- One on `\u2124_[p]` is inherited from `\u211a_[p]`. -/\ninstance : One \u2124_[p] := \u27e8\u27e81, by norm_num\u27e9\u27e9\n\n@[simp]\ntheorem mk_zero {h} : (\u27e80, h\u27e9 : \u2124_[p]) = (0 : \u2124_[p]) := rfl\n\n@[simp, norm_cast]\ntheorem coe_add (z1 z2 : \u2124_[p]) : ((z1 + z2 : \u2124_[p]) : \u211a_[p]) = z1 + z2 := rfl\n\n@[simp, norm_cast]\ntheorem coe_mul (z1 z2 : \u2124_[p]) : ((z1 * z2 : \u2124_[p]) : \u211a_[p]) = z1 * z2 := rfl\n\n@[simp, norm_cast]\ntheorem coe_neg (z1 : \u2124_[p]) : ((-z1 : \u2124_[p]) : \u211a_[p]) = -z1 := rfl\n\n@[simp, norm_cast]\ntheorem coe_sub (z1 z2 : \u2124_[p]) : ((z1 - z2 : \u2124_[p]) : \u211a_[p]) = z1 - z2 := rfl\n\n@[simp, norm_cast]\ntheorem coe_one : ((1 : \u2124_[p]) : \u211a_[p]) = 1 := rfl\n\n@[simp, norm_cast]\ntheorem coe_zero : ((0 : \u2124_[p]) : \u211a_[p]) = 0 := rfl\n\n@[simp] lemma coe_eq_zero : (x : \u211a_[p]) = 0 \u2194 x = 0 := by rw [\u2190 coe_zero, Subtype.coe_inj]\n\nlemma coe_ne_zero : (x : \u211a_[p]) \u2260 0 \u2194 x \u2260 0 := coe_eq_zero.not\n\ninstance : AddCommGroup \u2124_[p] := (by infer_instance : AddCommGroup (subring p))\n\ninstance instCommRing : CommRing \u2124_[p] := (by infer_instance : CommRing (subring p))\n\n@[simp, norm_cast]\ntheorem coe_natCast (n : \u2115) : ((n : \u2124_[p]) : \u211a_[p]) = n := rfl\n\n@[simp, norm_cast]\ntheorem coe_intCast (z : \u2124) : ((z : \u2124_[p]) : \u211a_[p]) = z := rfl\n\n/-- The coercion from `\u2124_[p]` to `\u211a_[p]` as a ring homomorphism. -/\ndef Coe.ringHom : \u2124_[p] \u2192+* \u211a_[p] := (subring p).subtype\n\n@[simp, norm_cast]\ntheorem coe_pow (x : \u2124_[p]) (n : \u2115) : (\u2191(x ^ n) : \u211a_[p]) = (\u2191x : \u211a_[p]) ^ n := rfl\n\ntheorem mk_coe (k : \u2124_[p]) : (\u27e8k, k.2\u27e9 : \u2124_[p]) = k := by simp\n\n/-- The inverse of a `p`-adic integer with norm equal to `1` is also a `p`-adic integer.\nOtherwise, the inverse is defined to be `0`. -/\ndef inv : \u2124_[p] \u2192 \u2124_[p]\n  | \u27e8k, _\u27e9 => if h : \u2016k\u2016 = 1 then \u27e8k\u207b\u00b9, by simp [h]\u27e9 else 0\n\ninstance : CharZero \u2124_[p] where\n  cast_injective m n h :=\n    Nat.cast_injective (R := \u211a_[p]) (by rw [Subtype.ext_iff] at h; norm_cast at h)\n\n@[norm_cast]\ntheorem intCast_eq (z1 z2 : \u2124) : (z1 : \u2124_[p]) = z2 \u2194 z1 = z2 := by simp\n\n/-- A sequence of integers that is Cauchy with respect to the `p`-adic norm converges to a `p`-adic\ninteger. -/\ndef ofIntSeq (seq : \u2115 \u2192 \u2124) (h : IsCauSeq (padicNorm p) fun n => seq n) : \u2124_[p] :=\n  \u27e8\u27e6\u27e8_, h\u27e9\u27e7,\n    show \u2191(PadicSeq.norm _) \u2264 (1 : \u211d) by\n      rw [PadicSeq.norm]\n      split_ifs with hne <;> norm_cast\n      apply padicNorm.of_int\u27e9\n\n/-! ### Instances\n\nWe now show that `\u2124_[p]` is a\n* complete metric space\n* normed ring\n* integral domain\n-/\n\nvariable (p)\n\ninstance : MetricSpace \u2124_[p] := Subtype.metricSpace\n\ninstance : IsUltrametricDist \u2124_[p] := IsUltrametricDist.subtype _\n\ninstance completeSpace : CompleteSpace \u2124_[p] :=\n  have : IsClosed { x : \u211a_[p] | \u2016x\u2016 \u2264 1 } := isClosed_le continuous_norm continuous_const\n  this.completeSpace_coe\n\ninstance : Norm \u2124_[p] := \u27e8fun z => \u2016(z : \u211a_[p])\u2016\u27e9\n\nvariable {p}\n\ntheorem norm_def {z : \u2124_[p]} : \u2016z\u2016 = \u2016(z : \u211a_[p])\u2016 := rfl\n\nvariable (p)\n\ninstance : NormedCommRing \u2124_[p] :=\n  { PadicInt.instCommRing with\n    dist_eq := fun \u27e8_, _\u27e9 \u27e8_, _\u27e9 => rfl\n    norm_mul := by simp [norm_def]\n    norm := norm }\n\ninstance : NormOneClass \u2124_[p] :=\n  \u27e8norm_def.trans norm_one\u27e9\n\ninstance isAbsoluteValue : IsAbsoluteValue fun z : \u2124_[p] => \u2016z\u2016 where\n  abv_nonneg' := norm_nonneg\n  abv_eq_zero' := by simp [norm_eq_zero]\n  abv_add' := fun \u27e8_, _\u27e9 \u27e8_, _\u27e9 => norm_add_le _ _\n  abv_mul' _ _ := by simp only [norm_def, padicNormE.mul, PadicInt.coe_mul]\n\nvariable {p}\n\ninstance : IsDomain \u2124_[p] := Function.Injective.isDomain (subring p).subtype Subtype.coe_injective\n\n/-! ### Norm -/\n\ntheorem norm_le_one (z : \u2124_[p]) : \u2016z\u2016 \u2264 1 := z.2\n\n@[simp]\ntheorem norm_mul (z1 z2 : \u2124_[p]) : \u2016z1 * z2\u2016 = \u2016z1\u2016 * \u2016z2\u2016 := by simp [norm_def]\n\n@[simp]\ntheorem norm_pow (z : \u2124_[p]) : \u2200 n : \u2115, \u2016z ^ n\u2016 = \u2016z\u2016 ^ n\n  | 0 => by simp\n  | k + 1 => by\n    rw [pow_succ, pow_succ, norm_mul]\n    congr\n    apply norm_pow\n\ntheorem nonarchimedean (q r : \u2124_[p]) : \u2016q + r\u2016 \u2264 max \u2016q\u2016 \u2016r\u2016 := padicNormE.nonarchimedean _ _\n\ntheorem norm_add_eq_max_of_ne {q r : \u2124_[p]} : \u2016q\u2016 \u2260 \u2016r\u2016 \u2192 \u2016q + r\u2016 = max \u2016q\u2016 \u2016r\u2016 :=\n  padicNormE.add_eq_max_of_ne\n\ntheorem norm_eq_of_norm_add_lt_right {z1 z2 : \u2124_[p]} (h : \u2016z1 + z2\u2016 < \u2016z2\u2016) : \u2016z1\u2016 = \u2016z2\u2016 :=\n  by_contra fun hne =>\n    not_lt_of_ge (by rw [norm_add_eq_max_of_ne hne]; apply le_max_right) h\n\ntheorem norm_eq_of_norm_add_lt_left {z1 z2 : \u2124_[p]} (h : \u2016z1 + z2\u2016 < \u2016z1\u2016) : \u2016z1\u2016 = \u2016z2\u2016 :=\n  by_contra fun hne =>\n    not_lt_of_ge (by rw [norm_add_eq_max_of_ne hne]; apply le_max_left) h\n\n@[simp]\ntheorem padic_norm_e_of_padicInt (z : \u2124_[p]) : \u2016(z : \u211a_[p])\u2016 = \u2016z\u2016 := by simp [norm_def]\n\ntheorem norm_intCast_eq_padic_norm (z : \u2124) : \u2016(z : \u2124_[p])\u2016 = \u2016(z : \u211a_[p])\u2016 := by simp [norm_def]\n\n@[simp]\ntheorem norm_eq_padic_norm {q : \u211a_[p]} (hq : \u2016q\u2016 \u2264 1) : @norm \u2124_[p] _ \u27e8q, hq\u27e9 = \u2016q\u2016 := rfl\n\n@[simp]\ntheorem norm_p : \u2016(p : \u2124_[p])\u2016 = (p : \u211d)\u207b\u00b9 := padicNormE.norm_p\n\ntheorem norm_p_pow (n : \u2115) : \u2016(p : \u2124_[p]) ^ n\u2016 = (p : \u211d) ^ (-n : \u2124) := by simp\n\nprivate def cauSeq_to_rat_cauSeq (f : CauSeq \u2124_[p] norm) : CauSeq \u211a_[p] fun a => \u2016a\u2016 :=\n  \u27e8fun n => f n, fun _ h\u03b5 => by simpa [norm, norm_def] using f.cauchy h\u03b5\u27e9\n\nvariable (p)\n\ninstance complete : CauSeq.IsComplete \u2124_[p] norm :=\n  \u27e8fun f =>\n    have hqn : \u2016CauSeq.lim (cauSeq_to_rat_cauSeq f)\u2016 \u2264 1 :=\n      padicNormE_lim_le zero_lt_one fun _ => norm_le_one _\n    \u27e8\u27e8_, hqn\u27e9, fun \u03b5 => by\n      simpa [norm, norm_def] using CauSeq.equiv_lim (cauSeq_to_rat_cauSeq f) \u03b5\u27e9\u27e9\n\ntheorem exists_pow_neg_lt {\u03b5 : \u211d} (h\u03b5 : 0 < \u03b5) : \u2203 k : \u2115, (p : \u211d) ^ (-(k : \u2124)) < \u03b5 := by\n  obtain \u27e8k, hk\u27e9 := exists_nat_gt \u03b5\u207b\u00b9\n  use k\n  rw [\u2190 inv_lt_inv\u2080 h\u03b5 (zpow_pos _ _)]\n  \u00b7 rw [zpow_neg, inv_inv, zpow_natCast]\n    apply lt_of_lt_of_le hk\n    norm_cast\n    apply le_of_lt\n    convert Nat.lt_pow_self _ using 1\n    exact hp.1.one_lt\n  \u00b7 exact mod_cast hp.1.pos\n\ntheorem exists_pow_neg_lt_rat {\u03b5 : \u211a} (h\u03b5 : 0 < \u03b5) : \u2203 k : \u2115, (p : \u211a) ^ (-(k : \u2124)) < \u03b5 := by\n  obtain \u27e8k, hk\u27e9 := @exists_pow_neg_lt p _ \u03b5 (mod_cast h\u03b5)\n  use k\n  rw [show (p : \u211d) = (p : \u211a) by simp] at hk\n  exact mod_cast hk\n\nvariable {p}\n\ntheorem norm_int_lt_one_iff_dvd (k : \u2124) : \u2016(k : \u2124_[p])\u2016 < 1 \u2194 (p : \u2124) \u2223 k :=\n  suffices \u2016(k : \u211a_[p])\u2016 < 1 \u2194 \u2191p \u2223 k by rwa [norm_intCast_eq_padic_norm]\n  padicNormE.norm_int_lt_one_iff_dvd k\n\ntheorem norm_int_le_pow_iff_dvd {k : \u2124} {n : \u2115} :\n    \u2016(k : \u2124_[p])\u2016 \u2264 (p : \u211d) ^ (-n : \u2124) \u2194 (p ^ n : \u2124) \u2223 k :=\n  suffices \u2016(k : \u211a_[p])\u2016 \u2264 (p : \u211d) ^ (-n : \u2124) \u2194 (p ^ n : \u2124) \u2223 k by\n    simpa [norm_intCast_eq_padic_norm]\n  padicNormE.norm_int_le_pow_iff_dvd _ _\n\n/-! ### Valuation on `\u2124_[p]` -/\n\nlemma valuation_coe_nonneg : 0 \u2264 (x : \u211a_[p]).valuation := by\n  obtain rfl | hx := eq_or_ne x 0\n  \u00b7 simp\n  have := x.2\n  rwa [Padic.norm_eq_zpow_neg_valuation <| coe_ne_zero.2 hx, zpow_le_one_iff_right\u2080, neg_nonpos]\n    at this\n  exact mod_cast hp.out.one_lt\n\n/-- `PadicInt.valuation` lifts the `p`-adic valuation on `\u211a` to `\u2124_[p]`. -/\ndef valuation (x : \u2124_[p]) : \u2115 := (x : \u211a_[p]).valuation.toNat\n\n@[simp, norm_cast] lemma valuation_coe (x : \u2124_[p]) : (x : \u211a_[p]).valuation = x.valuation := by\n  simp [valuation, valuation_coe_nonneg]\n\n@[simp] lemma valuation_zero : valuation (0 : \u2124_[p]) = 0 := by simp [valuation]\n@[simp] lemma valuation_one : valuation (1 : \u2124_[p]) = 0 := by simp [valuation]\n@[simp] lemma valuation_p : valuation (p : \u2124_[p]) = 1 := by simp [valuation]\n\nlemma le_valuation_add (hxy : x + y \u2260 0) : min x.valuation y.valuation \u2264 (x + y).valuation := by\n  zify; simpa [\u2190 valuation_coe] using Padic.le_valuation_add <| coe_ne_zero.2 hxy\n\n", "theoremStatement": "@[simp] lemma valuation_mul (hx : x \u2260 0) (hy : y \u2260 0) :\n    (x * y).valuation = x.valuation + y.valuation ", "theoremName": "PadicInt.valuation_mul", "fileCreated": {"commit": "63d78da6a358d613bff5f34c62ed9481dbbc52c2", "date": "2023-05-25"}, "theoremCreated": {"commit": "1c080cc45939aaef448022267a6965a19e53c7bf", "date": "2024-12-21"}, "file": "mathlib/Mathlib/NumberTheory/Padics/PadicIntegers.lean", "module": "Mathlib.NumberTheory.Padics.PadicIntegers", "jsonFile": "Mathlib.NumberTheory.Padics.PadicIntegers.jsonl", "positionMetadata": {"lineInFile": 323, "tokenPositionInFile": 10183, "theoremPositionInFile": 44}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 6, "repositoryPremises": true, "numRepositoryPremises": 27, "numPremises": 54}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  zify; simp [\u2190 valuation_coe, Padic.valuation_mul (coe_ne_zero.2 hx) (coe_ne_zero.2 hy)]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 95}}
{"srcContext": "/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Chris Hughes, Anne Baanen\n-/\nimport Mathlib.Data.Matrix.Basic\nimport Mathlib.Data.Matrix.Block\nimport Mathlib.Data.Matrix.Notation\nimport Mathlib.Data.Matrix.RowCol\nimport Mathlib.GroupTheory.GroupAction.Ring\nimport Mathlib.GroupTheory.Perm.Fin\nimport Mathlib.LinearAlgebra.Alternating.Basic\nimport Mathlib.LinearAlgebra.Matrix.SemiringInverse\n\n/-!\n# Determinant of a matrix\n\nThis file defines the determinant of a matrix, `Matrix.det`, and its essential properties.\n\n## Main definitions\n\n - `Matrix.det`: the determinant of a square matrix, as a sum over permutations\n - `Matrix.detRowAlternating`: the determinant, as an `AlternatingMap` in the rows of the matrix\n\n## Main results\n\n - `det_mul`: the determinant of `A * B` is the product of determinants\n - `det_zero_of_row_eq`: the determinant is zero if there is a repeated row\n - `det_block_diagonal`: the determinant of a block diagonal matrix is a product\n   of the blocks' determinants\n\n## Implementation notes\n\nIt is possible to configure `simp` to compute determinants. See the file\n`MathlibTest/matrix.lean` for some examples.\n\n-/\n\n\nuniverse u v w z\n\nopen Equiv Equiv.Perm Finset Function\n\nnamespace Matrix\n\nvariable {m n : Type*} [DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m]\nvariable {R : Type v} [CommRing R]\n\nlocal notation \"\u03b5 \" \u03c3:arg => ((sign \u03c3 : \u2124) : R)\n\n/-- `det` is an `AlternatingMap` in the rows of the matrix. -/\ndef detRowAlternating : (n \u2192 R) [\u22c0^n]\u2192\u2097[R] R :=\n  MultilinearMap.alternatization ((MultilinearMap.mkPiAlgebra R n R).compLinearMap LinearMap.proj)\n\n/-- The determinant of a matrix given by the Leibniz formula. -/\nabbrev det (M : Matrix n n R) : R :=\n  detRowAlternating M\n\ntheorem det_apply (M : Matrix n n R) : M.det = \u2211 \u03c3 : Perm n, Equiv.Perm.sign \u03c3 \u2022 \u220f i, M (\u03c3 i) i :=\n  MultilinearMap.alternatization_apply _ M\n\n-- This is what the old definition was. We use it to avoid having to change the old proofs below\ntheorem det_apply' (M : Matrix n n R) : M.det = \u2211 \u03c3 : Perm n, \u03b5 \u03c3 * \u220f i, M (\u03c3 i) i := by\n  simp [det_apply, Units.smul_def]\n\n", "theoremStatement": "theorem det_eq_detp_sub_detp (M : Matrix n n R) : M.det = M.detp 1 - M.detp (-1) ", "theoremName": "Matrix.det_eq_detp_sub_detp", "fileCreated": {"commit": "3438911a821fa2fb5ba37cdbec993e952646aeca", "date": "2024-06-03"}, "theoremCreated": {"commit": "9eb9253e89f61175c0284c6df0874b616e67e167", "date": "2024-12-11"}, "file": "mathlib/Mathlib/LinearAlgebra/Matrix/Determinant/Basic.lean", "module": "Mathlib.LinearAlgebra.Matrix.Determinant.Basic", "jsonFile": "Mathlib.LinearAlgebra.Matrix.Determinant.Basic.jsonl", "positionMetadata": {"lineInFile": 66, "tokenPositionInFile": 2176, "theoremPositionInFile": 4}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 109, "numPremises": 132}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [det_apply, \u2190 Equiv.sum_comp (Equiv.inv (Perm n)), \u2190 ofSign_disjUnion, sum_disjUnion]\n  simp_rw [inv_apply, sign_inv, sub_eq_add_neg, detp, \u2190 sum_neg_distrib]\n  refine congr_arg\u2082 (\u00b7 + \u00b7) (sum_congr rfl fun \u03c3 h\u03c3 \u21a6 ?_) (sum_congr rfl fun \u03c3 h\u03c3 \u21a6 ?_) <;>\n    rw [mem_ofSign.mp h\u03c3, \u2190 Equiv.prod_comp \u03c3] <;> simp", "proofType": "tactic", "proofLengthLines": 4, "proofLengthTokens": 317}}
{"srcContext": "/-\nCopyright (c) 2024 Fangming Li. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Fangming Li, Jujian Zhang\n-/\nimport Mathlib.Algebra.Polynomial.AlgebraMap\nimport Mathlib.Algebra.Polynomial.Eval.SMul\nimport Mathlib.Algebra.Polynomial.Roots\nimport Mathlib.Order.Interval.Set.Infinite\nimport Mathlib.RingTheory.Polynomial.Pochhammer\nimport Mathlib.RingTheory.PowerSeries.WellKnown\nimport Mathlib.Tactic.FieldSimp\n\n/-!\n# Hilbert polynomials\n\nIn this file, we formalise the following statement: if `F` is a field with characteristic `0`, then\ngiven any `p : F[X]` and `d : \u2115`, there exists some `h : F[X]` such that for any large enough\n`n : \u2115`, `h(n)` is equal to the coefficient of `X\u207f` in the power series expansion of `p/(1 - X)\u1d48`.\nThis `h` is unique and is denoted as `Polynomial.hilbertPoly p d`.\n\nFor example, given `d : \u2115`, the power series expansion of `1/(1 - X)\u1d48\u207a\u00b9` in `F[X]`\nis `\u03a3\u2099 ((d + n).choose d)X\u207f`, which equals `\u03a3\u2099 ((n + 1)\u00b7\u00b7\u00b7(n + d)/d!)X\u207f` and hence\n`Polynomial.hilbertPoly (1 : F[X]) (d + 1)` is the polynomial `(X + 1)\u00b7\u00b7\u00b7(X + d)/d!`. Note that\nif `d! = 0` in `F`, then the polynomial `(X + 1)\u00b7\u00b7\u00b7(X + d)/d!` no longer works, so we do not want\nthe characteristic of `F` to be divisible by `d!`. As `Polynomial.hilbertPoly` may take any\n`p : F[X]` and `d : \u2115` as its inputs, it is necessary for us to assume that `CharZero F`.\n\n## Main definitions\n\n* `Polynomial.hilbertPoly p d`. Given a field `F`, a polynomial `p : F[X]` and a natural number `d`,\n  if `F` is of characteristic `0`, then `Polynomial.hilbertPoly p d : F[X]` is the polynomial whose\n  value at `n` equals the coefficient of `X\u207f` in the power series expansion of `p/(1 - X)\u1d48`.\n\n## TODO\n\n* Hilbert polynomials of finitely generated graded modules over Noetherian rings.\n-/\n\nopen Nat PowerSeries\n\nvariable (F : Type*) [Field F]\n\nnamespace Polynomial\n\n/--\nFor any field `F` and natural numbers `d` and `k`, `Polynomial.preHilbertPoly F d k`\nis defined as `(d.factorial : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (X - (C (k : F)) + 1))`.\nThis is the most basic form of Hilbert polynomials. `Polynomial.preHilbertPoly \u211a d 0`\nis exactly the Hilbert polynomial of the polynomial ring `\u211a[X_0,...,X_d]` viewed as\na graded module over itself. In fact, `Polynomial.preHilbertPoly F d k` is the\nsame as `Polynomial.hilbertPoly ((X : F[X]) ^ k) (d + 1)` for any field `F` and\n`d k : \u2115` (see the lemma `Polynomial.hilbertPoly_X_pow_succ`). See also the lemma\n`Polynomial.preHilbertPoly_eq_choose_sub_add`, which states that if `CharZero F`,\nthen for any `d k n : \u2115` with `k \u2264 n`, `(Polynomial.preHilbertPoly F d k).eval (n : F)`\nequals `(n - k + d).choose d`.\n-/\nnoncomputable def preHilbertPoly (d k : \u2115) : F[X] :=\n  (d.factorial : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (Polynomial.X - (C (k : F)) + 1))\n\nlemma natDegree_preHilbertPoly [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).natDegree = d := by\n  have hne : (d ! : F) \u2260 0 := by norm_cast; positivity\n  rw [preHilbertPoly, natDegree_smul _ (inv_ne_zero hne), natDegree_comp, ascPochhammer_natDegree,\n    add_comm_sub, \u2190 C_1, \u2190 map_sub, natDegree_add_C, natDegree_X, mul_one]\n\nlemma coeff_preHilbertPoly_self [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).coeff d = (d ! : F)\u207b\u00b9 := by\n  delta preHilbertPoly\n  have hne : (d ! : F) \u2260 0 := by norm_cast; positivity\n  have heq : d = ((ascPochhammer F d).comp (X - C (k : F) + 1)).natDegree :=\n    (natDegree_preHilbertPoly F d k).symm.trans (natDegree_smul _ (inv_ne_zero hne))\n  nth_rw 3 [heq]\n  calc\n  _ = (d ! : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (X - C ((k : F) - 1))).leadingCoeff := by\n    simp only [sub_add, \u2190 C_1, \u2190 map_sub, coeff_smul, coeff_natDegree]\n  _ = (d ! : F)\u207b\u00b9 := by\n    simp only [leadingCoeff_comp (ne_of_eq_of_ne (natDegree_X_sub_C _) one_ne_zero), Monic.def.1\n      (monic_ascPochhammer _ _), one_mul, leadingCoeff_X_sub_C, one_pow, smul_eq_mul, mul_one]\n\nlemma leadingCoeff_preHilbertPoly [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).leadingCoeff = (d ! : F)\u207b\u00b9 := by\n  rw [leadingCoeff, natDegree_preHilbertPoly, coeff_preHilbertPoly_self]\n\nlemma preHilbertPoly_eq_choose_sub_add [CharZero F] (d : \u2115) {k n : \u2115} (hkn : k \u2264 n):\n    (preHilbertPoly F d k).eval (n : F) = (n - k + d).choose d := by\n  have : (d ! : F) \u2260 0 := by norm_cast; positivity\n  calc\n  _ = (\u2191d !)\u207b\u00b9 * eval (\u2191(n - k + 1)) (ascPochhammer F d) := by simp [cast_sub hkn, preHilbertPoly]\n  _ = (n - k + d).choose d := by\n    rw [ascPochhammer_nat_eq_natCast_ascFactorial];\n    field_simp [ascFactorial_eq_factorial_mul_choose]\n\nvariable {F}\n\n/--\n`Polynomial.hilbertPoly p 0 = 0`; for any `d : \u2115`, `Polynomial.hilbertPoly p (d + 1)`\nis defined as `\u2211 i \u2208 p.support, (p.coeff i) \u2022 Polynomial.preHilbertPoly F d i`. If\n`M` is a graded module whose Poincar\u00e9 series can be written as `p(X)/(1 - X)\u1d48` for some\n`p : \u211a[X]` with integer coefficients, then `Polynomial.hilbertPoly p d` is the Hilbert\npolynomial of `M`. See also `Polynomial.coeff_mul_invOneSubPow_eq_hilbertPoly_eval`,\nwhich says that `PowerSeries.coeff F n (p * PowerSeries.invOneSubPow F d)` equals\n`(Polynomial.hilbertPoly p d).eval (n : F)` for any large enough `n : \u2115`.\n-/\nnoncomputable def hilbertPoly (p : F[X]) : (d : \u2115) \u2192 F[X]\n  | 0 => 0\n  | d + 1 => \u2211 i \u2208 p.support, (p.coeff i) \u2022 preHilbertPoly F d i\n\nlemma hilbertPoly_zero_left (d : \u2115) : hilbertPoly (0 : F[X]) d = 0 := by\n  delta hilbertPoly; induction d with\n  | zero => simp only\n  | succ d _ => simp only [coeff_zero, zero_smul, Finset.sum_const_zero]\n\nlemma hilbertPoly_zero_right (p : F[X]) : hilbertPoly p 0 = 0 := rfl\n\nlemma hilbertPoly_succ (p : F[X]) (d : \u2115) :\n    hilbertPoly p (d + 1) = \u2211 i \u2208 p.support, (p.coeff i) \u2022 preHilbertPoly F d i := rfl\n\nlemma hilbertPoly_X_pow_succ (d k : \u2115) :\n    hilbertPoly ((X : F[X]) ^ k) (d + 1) = preHilbertPoly F d k := by\n  delta hilbertPoly; simp\n\nlemma hilbertPoly_add_left (p q : F[X]) (d : \u2115) :\n    hilbertPoly (p + q) d = hilbertPoly p d + hilbertPoly q d := by\n  delta hilbertPoly\n  induction d with\n  | zero => simp only [add_zero]\n  | succ d _ =>\n      simp only [\u2190 coeff_add]\n      rw [\u2190 sum_def _ fun _ r => r \u2022 _]\n      exact sum_add_index _ _ _ (fun _ => zero_smul ..) (fun _ _ _ => add_smul ..)\n\nlemma hilbertPoly_smul (a : F) (p : F[X]) (d : \u2115) :\n    hilbertPoly (a \u2022 p) d = a \u2022 hilbertPoly p d := by\n  delta hilbertPoly\n  induction d with\n  | zero => simp only [smul_zero]\n  | succ d _ =>\n      simp only\n      rw [\u2190 sum_def _ fun _ r => r \u2022 _, \u2190 sum_def _ fun _ r => r \u2022 _, Polynomial.smul_sum,\n        sum_smul_index' _ _ _ fun i => zero_smul F (preHilbertPoly F d i)]\n      simp only [smul_assoc]\n\nvariable (F) in\n/--\nThe function that sends any `p : F[X]` to `Polynomial.hilbertPoly p d` is an `F`-linear map from\n`F[X]` to `F[X]`.\n-/\nnoncomputable def hilbertPoly_linearMap (d : \u2115) : F[X] \u2192\u2097[F] F[X] where\n  toFun p := hilbertPoly p d\n  map_add' p q := hilbertPoly_add_left p q d\n  map_smul' r p := hilbertPoly_smul r p d\n\nvariable [CharZero F]\n\n/--\nThe key property of Hilbert polynomials. If `F` is a field with characteristic `0`, `p : F[X]` and\n`d : \u2115`, then for any large enough `n : \u2115`, `(Polynomial.hilbertPoly p d).eval (n : F)` equals the\ncoefficient of `X\u207f` in the power series expansion of `p/(1 - X)\u1d48`.\n-/\ntheorem coeff_mul_invOneSubPow_eq_hilbertPoly_eval\n    {p : F[X]} (d : \u2115) {n : \u2115} (hn : p.natDegree < n) :\n    PowerSeries.coeff F n (p * invOneSubPow F d) = (hilbertPoly p d).eval (n : F) := by\n  delta hilbertPoly; induction d with\n  | zero => simp only [invOneSubPow_zero, Units.val_one, mul_one, coeff_coe, eval_zero]\n            exact coeff_eq_zero_of_natDegree_lt hn\n  | succ d hd =>\n      simp only [eval_finset_sum, eval_smul, smul_eq_mul]\n      rw [\u2190 Finset.sum_coe_sort]\n      have h_le (i : p.support) : (i : \u2115) \u2264 n :=\n        le_trans (le_natDegree_of_ne_zero <| mem_support_iff.1 i.2) hn.le\n      have h (i : p.support) : eval \u2191n (preHilbertPoly F d \u2191i) = (n + d - \u2191i).choose d := by\n        rw [preHilbertPoly_eq_choose_sub_add _ _ (h_le i), Nat.sub_add_comm (h_le i)]\n      simp_rw [h]\n      rw [Finset.sum_coe_sort _ (fun x => (p.coeff \u2191x) * (_ + d - \u2191x).choose _),\n        PowerSeries.coeff_mul, Finset.Nat.sum_antidiagonal_eq_sum_range_succ_mk,\n        invOneSubPow_val_eq_mk_sub_one_add_choose_of_pos _ _ (zero_lt_succ d)]\n      simp only [coeff_coe, coeff_mk]\n      symm\n      refine Finset.sum_subset_zero_on_sdiff (fun s hs \u21a6 ?_) (fun x hx \u21a6 ?_) (fun x hx \u21a6 ?_)\n      \u00b7 rw [Finset.mem_range_succ_iff]\n        exact h_le \u27e8s, hs\u27e9\n      \u00b7 simp only [Finset.mem_sdiff, mem_support_iff, not_not] at hx\n        rw [hx.2, zero_mul]\n      \u00b7 rw [add_comm, Nat.add_sub_assoc (h_le \u27e8x, hx\u27e9), succ_eq_add_one, add_tsub_cancel_right]\n\n/--\nThe polynomial satisfying the key property of `Polynomial.hilbertPoly p d` is unique.\n-/\ntheorem existsUnique_hilbertPoly (p : F[X]) (d : \u2115) :\n    \u2203! h : F[X], \u2203 N : \u2115, \u2200 n > N,\n    PowerSeries.coeff F n (p * invOneSubPow F d) = h.eval (n : F) := by\n  use hilbertPoly p d; constructor\n  \u00b7 use p.natDegree\n    exact fun n => coeff_mul_invOneSubPow_eq_hilbertPoly_eval d\n  \u00b7 rintro h \u27e8N, hhN\u27e9\n    apply eq_of_infinite_eval_eq h (hilbertPoly p d)\n    apply ((Set.Ioi_infinite (max N p.natDegree)).image cast_injective.injOn).mono\n    rintro x \u27e8n, hn, rfl\u27e9\n    simp only [Set.mem_Ioi, sup_lt_iff, Set.mem_setOf_eq] at hn \u22a2\n    rw [\u2190 coeff_mul_invOneSubPow_eq_hilbertPoly_eval d hn.2, hhN n hn.1]\n\n@[deprecated (since := \"2024-12-17\")] alias exists_unique_hilbertPoly := existsUnique_hilbertPoly\n\n/--\nIf `h : F[X]` and there exists some `N : \u2115` such that for any number `n : \u2115` bigger than `N`\nwe have `PowerSeries.coeff F n (p * invOneSubPow F d) = h.eval (n : F)`, then `h` is exactly\n`Polynomial.hilbertPoly p d`.\n-/\ntheorem eq_hilbertPoly_of_forall_coeff_eq_eval\n    {p h : F[X]} {d : \u2115} (N : \u2115) (hhN : \u2200 n > N,\n    PowerSeries.coeff F n (p * invOneSubPow F d) = h.eval (n : F)) :\n    h = hilbertPoly p d :=\n  ExistsUnique.unique (existsUnique_hilbertPoly p d) \u27e8N, hhN\u27e9\n    \u27e8p.natDegree, fun _ x => coeff_mul_invOneSubPow_eq_hilbertPoly_eval d x\u27e9\n\nlemma hilbertPoly_mul_one_sub_succ (p : F[X]) (d : \u2115) :\n    hilbertPoly (p * (1 - X)) (d + 1) = hilbertPoly p d := by\n  apply eq_hilbertPoly_of_forall_coeff_eq_eval (p * (1 - X)).natDegree\n  intro n hn\n  have heq : 1 - PowerSeries.X = ((1 - X : F[X]) : F\u27e6X\u27e7) := by simp only [coe_sub, coe_one, coe_X]\n  rw [\u2190 one_sub_pow_mul_invOneSubPow_val_add_eq_invOneSubPow_val F d 1, pow_one, \u2190 mul_assoc, heq,\n    \u2190 coe_mul, coeff_mul_invOneSubPow_eq_hilbertPoly_eval (d + 1) hn]\n\nlemma hilbertPoly_mul_one_sub_pow_add (p : F[X]) (d e : \u2115) :\n    hilbertPoly (p * (1 - X) ^ e) (d + e) = hilbertPoly p d := by\n  induction e with\n  | zero => simp\n  | succ e he => rw [pow_add, pow_one, \u2190 mul_assoc, \u2190 add_assoc, hilbertPoly_mul_one_sub_succ, he]\n\nlemma hilbertPoly_eq_zero_of_le_rootMultiplicity_one\n    {p : F[X]} {d : \u2115} (hdp : d \u2264 p.rootMultiplicity 1) :\n    hilbertPoly p d = 0 := by\n  by_cases hp : p = 0\n  \u00b7 rw [hp, hilbertPoly_zero_left]\n  \u00b7 rcases exists_eq_pow_rootMultiplicity_mul_and_not_dvd p hp 1 with \u27e8q, hq1, hq2\u27e9\n    have heq : p = q * (- 1) ^ p.rootMultiplicity 1 * (1 - X) ^ p.rootMultiplicity 1 := by\n      simp only [mul_assoc, \u2190 mul_pow, neg_mul, one_mul, neg_sub]\n      exact hq1.trans (mul_comm _ _)\n    rw [heq, \u2190 zero_add d, \u2190 Nat.sub_add_cancel hdp, pow_add (1 - X), \u2190 mul_assoc,\n      hilbertPoly_mul_one_sub_pow_add, hilbertPoly]\n\ntheorem natDegree_hilbertPoly_of_ne_zero_of_rootMultiplicity_lt\n    {p : F[X]} {d : \u2115} (hp : p \u2260 0) (hpd : p.rootMultiplicity 1 < d) :\n    (hilbertPoly p d).natDegree = d - p.rootMultiplicity 1 - 1 := by\n  rcases exists_eq_pow_rootMultiplicity_mul_and_not_dvd p hp 1 with \u27e8q, hq1, hq2\u27e9\n  have heq : p = q * (- 1) ^ p.rootMultiplicity 1 * (1 - X) ^ p.rootMultiplicity 1 := by\n    simp only [mul_assoc, \u2190 mul_pow, neg_mul, one_mul, neg_sub]\n    exact hq1.trans (mul_comm _ _)\n  nth_rw 1 [heq, \u2190 Nat.sub_add_cancel (le_of_lt hpd), hilbertPoly_mul_one_sub_pow_add,\n    \u2190 Nat.sub_add_cancel (Nat.le_sub_of_add_le' <| add_one_le_of_lt hpd)]\n  delta hilbertPoly\n  apply natDegree_eq_of_le_of_coeff_ne_zero\n  \u00b7 apply natDegree_sum_le_of_forall_le _ _ <| fun _ _ => ?_\n    apply le_trans (natDegree_smul_le _ _)\n    rw [natDegree_preHilbertPoly]\n  \u00b7 have : (fun (x : \u2115) (a : F) => a) = fun x a => a * 1 ^ x := by simp only [one_pow, mul_one]\n    simp only [finset_sum_coeff, coeff_smul, smul_eq_mul, coeff_preHilbertPoly_self,\n      \u2190 Finset.sum_mul, \u2190 sum_def _ (fun _ a => a), this, \u2190 eval_eq_sum, eval_mul, eval_pow,\n      eval_neg, eval_one, _root_.mul_eq_zero, pow_eq_zero_iff', neg_eq_zero, one_ne_zero, ne_eq,\n      false_and, or_false, inv_eq_zero, cast_eq_zero, not_or]\n    exact \u27e8(not_iff_not.2 dvd_iff_isRoot).1 hq2, factorial_ne_zero _\u27e9\n\n", "theoremStatement": "theorem natDegree_hilbertPoly_of_ne_zero\n    {p : F[X]} {d : \u2115} (hh : hilbertPoly p d \u2260 0) :\n    (hilbertPoly p d).natDegree = d - p.rootMultiplicity 1 - 1 ", "theoremName": "Polynomial.natDegree_hilbertPoly_of_ne_zero", "fileCreated": {"commit": "561e050467d2caa2e4ea5d81ca62600bf268b747", "date": "2024-12-02"}, "theoremCreated": {"commit": "bd9aea4b2403dcb1ec3998335f71109212ada88e", "date": "2024-12-09"}, "file": "mathlib/Mathlib/RingTheory/Polynomial/HilbertPoly.lean", "module": "Mathlib.RingTheory.Polynomial.HilbertPoly", "jsonFile": "Mathlib.RingTheory.Polynomial.HilbertPoly.jsonl", "positionMetadata": {"lineInFile": 264, "tokenPositionInFile": 12698, "theoremPositionInFile": 18}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 25, "numPremises": 44}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  have hp : p \u2260 0 := by\n    intro h\n    rw [h] at hh\n    exact hh (hilbertPoly_zero_left d)\n  have hpd : p.rootMultiplicity 1 < d := by\n    by_contra h\n    exact hh (hilbertPoly_eq_zero_of_le_rootMultiplicity_one <| not_lt.1 h)\n  exact natDegree_hilbertPoly_of_ne_zero_of_rootMultiplicity_lt hp hpd", "proofType": "tactic", "proofLengthLines": 8, "proofLengthTokens": 304}}
{"srcContext": "/-\nCopyright (c) 2024 Jo\u00ebl Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jo\u00ebl Riou\n-/\nimport Mathlib.Algebra.Homology.Embedding.Extend\nimport Mathlib.Algebra.Homology.Embedding.IsSupported\nimport Mathlib.Algebra.Homology.QuasiIso\n\n/-!\n# Homology of the extension of an homological complex\n\nGiven an embedding `e : c.Embedding c'` and `K : HomologicalComplex C c`, we shall\ncompute the homology of `K.extend e`. In degrees that are not in the image of `e.f`,\nthe homology is obviously zero. When `e.f j = j`, we construct an isomorphism\n`(K.extend e).homology j' \u2245 K.homology j`.\n\n-/\n\nopen CategoryTheory Limits Category\n\nnamespace HomologicalComplex\n\nvariable {\u03b9 \u03b9' : Type*} {c : ComplexShape \u03b9} {c' : ComplexShape \u03b9'}\n  {C : Type*} [Category C] [HasZeroMorphisms C]\n  [HasZeroObject C]\n\nvariable (K L M : HomologicalComplex C c) (\u03c6 : K \u27f6 L) (\u03c6' : L \u27f6 M) (e : c.Embedding c')\n\nnamespace extend\n\nsection HomologyData\n\nvariable {i j k : \u03b9} {i' j' k' : \u03b9'} (hj' : e.f j = j')\n  (hi : c.prev j = i) (hi' : c'.prev j' = i') (hk : c.next j = k) (hk' : c'.next j' = k')\n\ninclude hk hk' in\nlemma comp_d_eq_zero_iff \u2983W : C\u2984 (\u03c6 : W \u27f6 K.X j) :\n    \u03c6 \u226b K.d j k = 0 \u2194 \u03c6 \u226b (K.extendXIso e hj').inv \u226b (K.extend e).d j' k' = 0 := by\n  by_cases hjk : c.Rel j k\n  \u00b7 have hk' : e.f k = k' := by rw [\u2190 hk', \u2190 hj', c'.next_eq' (e.rel hjk)]\n    rw [K.extend_d_eq e hj' hk', Iso.inv_hom_id_assoc,\n      \u2190 cancel_mono (K.extendXIso e hk').inv, zero_comp, assoc]\n  \u00b7 simp only [K.shape _ _ hjk, comp_zero, true_iff]\n    rw [K.extend_d_from_eq_zero e j' k' j hj', comp_zero, comp_zero]\n    rw [hk]\n    exact hjk\n\ninclude hi hi' in\nlemma d_comp_eq_zero_iff \u2983W : C\u2984 (\u03c6 : K.X j \u27f6 W) :\n    K.d i j \u226b \u03c6 = 0 \u2194 (K.extend e).d i' j' \u226b (K.extendXIso e hj').hom \u226b \u03c6 = 0 := by\n  by_cases hij : c.Rel i j\n  \u00b7 have hi' : e.f i = i' := by rw [\u2190 hi', \u2190 hj', c'.prev_eq' (e.rel hij)]\n    rw [K.extend_d_eq e hi' hj', assoc, assoc, Iso.inv_hom_id_assoc,\n      \u2190 cancel_epi (K.extendXIso e hi').hom, comp_zero]\n  \u00b7 simp only [K.shape _ _ hij, zero_comp, true_iff]\n    rw [K.extend_d_to_eq_zero e i' j' j hj', zero_comp]\n    rw [hi]\n    exact hij\n\nnamespace leftHomologyData\n\nvariable (cone : KernelFork (K.d j k)) (hcone : IsLimit cone)\n\n/-- The kernel fork of `(K.extend e).d j' k'` that is deduced from a kernel\nfork of `K.d j k `. -/\n@[simp]\nnoncomputable def kernelFork : KernelFork ((K.extend e).d j' k') :=\n  KernelFork.of\u03b9 (cone.\u03b9 \u226b (extendXIso K e hj').inv)\n    (by rw [assoc, \u2190 comp_d_eq_zero_iff K e hj' hk hk' cone.\u03b9, cone.condition])\n\n/-- The limit kernel fork of `(K.extend e).d j' k'` that is deduced from a limit\nkernel fork of `K.d j k `. -/\nnoncomputable def isLimitKernelFork : IsLimit (kernelFork K e hj' hk hk' cone) :=\n  KernelFork.isLimitOfIsLimitOfIff hcone ((K.extend e).d j' k')\n    (extendXIso K e hj').symm (comp_d_eq_zero_iff K e hj' hk hk')\n\nvariable (cocone : CokernelCofork (hcone.lift (KernelFork.of\u03b9 (K.d i j) (K.d_comp_d i j k))))\n  (hcocone : IsColimit cocone)\n\ninclude hi hi' hcone in\n/-- Auxiliary lemma for `lift_d_comp_eq_zero_iff`. -/\nlemma lift_d_comp_eq_zero_iff' \u2983W : C\u2984 (f' : K.X i \u27f6 cone.pt)\n    (hf' : f' \u226b cone.\u03b9 = K.d i j)\n    (f'' : (K.extend e).X i' \u27f6 cone.pt)\n    (hf'' : f'' \u226b cone.\u03b9 \u226b (extendXIso K e hj').inv = (K.extend e).d i' j')\n    (\u03c6 : cone.pt \u27f6 W) :\n    f' \u226b \u03c6 = 0 \u2194 f'' \u226b \u03c6 = 0 := by\n  by_cases hij : c.Rel i j\n  \u00b7 have hi'' : e.f i = i' := by rw [\u2190 hi', \u2190 hj', c'.prev_eq' (e.rel hij)]\n    have : (K.extendXIso e hi'').hom \u226b f' = f'' := by\n      apply Fork.IsLimit.hom_ext hcone\n      rw [assoc, hf', \u2190 cancel_mono (extendXIso K e hj').inv, assoc, assoc, hf'',\n        K.extend_d_eq e hi'' hj']\n    rw [\u2190 cancel_epi (K.extendXIso e hi'').hom, comp_zero, \u2190 this, assoc]\n  \u00b7 have h\u2081 : f' = 0 := by\n      apply Fork.IsLimit.hom_ext hcone\n      simp only [zero_comp, hf', K.shape _ _ hij]\n    have h\u2082 : f'' = 0 := by\n      apply Fork.IsLimit.hom_ext hcone\n      dsimp\n      rw [\u2190 cancel_mono (extendXIso K e hj').inv, assoc, hf'', zero_comp, zero_comp,\n        K.extend_d_to_eq_zero e i' j' j hj']\n      rw [hi]\n      exact hij\n    simp [h\u2081, h\u2082]\n\ninclude hi hi' in\nlemma lift_d_comp_eq_zero_iff \u2983W : C\u2984 (\u03c6 : cone.pt \u27f6 W) :\n    hcone.lift (KernelFork.of\u03b9 (K.d i j) (K.d_comp_d i j k)) \u226b \u03c6 = 0 \u2194\n      ((isLimitKernelFork K e hj' hk hk' cone hcone).lift\n      (KernelFork.of\u03b9 ((K.extend e).d i' j') (d_comp_d _ _ _ _))) \u226b \u03c6 = 0 :=\n  lift_d_comp_eq_zero_iff' K e hj' hi hi' cone hcone _ (hcone.fac _ _) _\n    (IsLimit.fac _ _ WalkingParallelPair.zero) _\n\n/-- Auxiliary definition for `extend.leftHomologyData`. -/\nnoncomputable def cokernelCofork :\n    CokernelCofork ((isLimitKernelFork K e hj' hk hk' cone hcone).lift\n      (KernelFork.of\u03b9 ((K.extend e).d i' j') (d_comp_d _ _ _ _))) :=\n  CokernelCofork.of\u03c0 cocone.\u03c0 (by\n    rw [\u2190 lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' cone hcone]\n    exact cocone.condition)\n\n/-- Auxiliary definition for `extend.leftHomologyData`. -/\nnoncomputable def isColimitCokernelCofork :\n    IsColimit (cokernelCofork K e hj' hi hi' hk hk' cone hcone cocone) :=\n  CokernelCofork.isColimitOfIsColimitOfIff' hcocone _\n    (lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' cone hcone)\n\nend leftHomologyData\n\nopen leftHomologyData in\n/-- The left homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a left homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def leftHomologyData (h : (K.sc' i j k).LeftHomologyData) :\n    ((K.extend e).sc' i' j' k').LeftHomologyData where\n  K := h.K\n  H := h.H\n  i := h.i \u226b (extendXIso K e hj').inv\n  \u03c0 := h.\u03c0\n  wi := by\n    dsimp\n    rw [assoc, \u2190 comp_d_eq_zero_iff K e hj' hk hk']\n    exact h.wi\n  hi := isLimitKernelFork K e hj' hk hk' _ h.hi\n  w\u03c0 := by\n    dsimp\n    rw [\u2190 lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' _ h.hi]\n    exact h.w\u03c0\n  h\u03c0 := isColimitCokernelCofork K e hj' hi hi' hk hk' _ h.hi _ h.h\u03c0\n\nnamespace rightHomologyData\n\nvariable (cocone : CokernelCofork (K.d i j)) (hcocone : IsColimit cocone)\n\n/-- The cokernel cofork of `(K.extend e).d i' j'` that is deduced from a cokernel\ncofork of `K.d i j`. -/\n@[simp]\nnoncomputable def cokernelCofork : CokernelCofork ((K.extend e).d i' j') :=\n  CokernelCofork.of\u03c0 ((extendXIso K e hj').hom \u226b cocone.\u03c0) (by\n    rw [\u2190 d_comp_eq_zero_iff K e hj' hi hi' cocone.\u03c0, cocone.condition])\n\n/-- The colimit cokernel cofork of `(K.extend e).d i' j'` that is deduced from a\ncolimit cokernel cofork of `K.d i j`. -/\nnoncomputable def isColimitCokernelCofork : IsColimit (cokernelCofork K e hj' hi hi' cocone) :=\n  CokernelCofork.isColimitOfIsColimitOfIff hcocone ((K.extend e).d i' j')\n    (extendXIso K e hj') (d_comp_eq_zero_iff K e hj' hi hi')\n\nvariable (cone : KernelFork (hcocone.desc (CokernelCofork.of\u03c0 (K.d j k) (K.d_comp_d i j k))))\n  (hcone : IsLimit cone)\n\ninclude hk hk' hcocone in\nlemma d_comp_desc_eq_zero_iff' \u2983W : C\u2984 (f' : cocone.pt \u27f6 K.X k)\n    (hf' : cocone.\u03c0 \u226b f' = K.d j k)\n    (f'' : cocone.pt \u27f6 (K.extend e).X k')\n    (hf'' : (extendXIso K e hj').hom \u226b cocone.\u03c0 \u226b f'' = (K.extend e).d j' k')\n    (\u03c6 : W \u27f6 cocone.pt) :\n    \u03c6 \u226b f' = 0 \u2194 \u03c6 \u226b f'' = 0 := by\n  by_cases hjk : c.Rel j k\n  \u00b7 have hk'' : e.f k = k' := by rw [\u2190 hk', \u2190 hj', c'.next_eq' (e.rel hjk)]\n    have : f' \u226b (K.extendXIso e hk'').inv = f'' := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      rw [reassoc_of% hf', \u2190 cancel_epi (extendXIso K e hj').hom, hf'',\n        K.extend_d_eq e hj' hk'']\n    rw [\u2190 cancel_mono (K.extendXIso e hk'').inv, zero_comp, assoc, this]\n  \u00b7 have h\u2081 : f' = 0 := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      simp only [hf', comp_zero, K.shape _ _ hjk]\n    have h\u2082 : f'' = 0 := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      rw [\u2190 cancel_epi (extendXIso K e hj').hom, hf'', comp_zero, comp_zero,\n        K.extend_d_from_eq_zero e j' k' j hj']\n      rw [hk]\n      exact hjk\n    simp [h\u2081, h\u2082]\n\ninclude hk hk' in\nlemma d_comp_desc_eq_zero_iff \u2983W : C\u2984 (\u03c6 : W \u27f6 cocone.pt) :\n    \u03c6 \u226b hcocone.desc (CokernelCofork.of\u03c0 (K.d j k) (K.d_comp_d i j k)) = 0 \u2194\n      \u03c6 \u226b ((isColimitCokernelCofork K e hj' hi hi' cocone hcocone).desc\n      (CokernelCofork.of\u03c0 ((K.extend e).d j' k') (d_comp_d _ _ _ _))) = 0 :=\n  d_comp_desc_eq_zero_iff' K e hj' hk hk' cocone hcocone _ (hcocone.fac _ _) _ (by\n    simpa using (isColimitCokernelCofork K e hj' hi hi' cocone hcocone).fac _\n      WalkingParallelPair.one) _\n\n/-- Auxiliary definition for `extend.rightHomologyData`. -/\nnoncomputable def kernelFork :\n    KernelFork ((isColimitCokernelCofork K e hj' hi hi' cocone hcocone).desc\n      (CokernelCofork.of\u03c0 ((K.extend e).d j' k') (d_comp_d _ _ _ _))) :=\n  KernelFork.of\u03b9 cone.\u03b9 (by\n    rw [\u2190 d_comp_desc_eq_zero_iff K e hj' hi hi' hk hk' cocone hcocone]\n    exact cone.condition)\n\n/-- Auxiliary definition for `extend.rightHomologyData`. -/\nnoncomputable def isLimitKernelFork :\n    IsLimit (kernelFork K e hj' hi hi' hk hk' cocone hcocone cone) :=\n  KernelFork.isLimitOfIsLimitOfIff' hcone _\n    (d_comp_desc_eq_zero_iff K e hj' hi hi' hk hk' cocone hcocone)\n\nend rightHomologyData\n\nopen rightHomologyData in\n/-- The right homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a right homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def rightHomologyData (h : (K.sc' i j k).RightHomologyData) :\n    ((K.extend e).sc' i' j' k').RightHomologyData where\n  Q := h.Q\n  H := h.H\n  p := (extendXIso K e hj').hom \u226b h.p\n  \u03b9 := h.\u03b9\n  wp := by\n    dsimp\n    rw [\u2190 d_comp_eq_zero_iff K e hj' hi hi']\n    exact h.wp\n  hp := isColimitCokernelCofork K e hj' hi hi' _ h.hp\n  w\u03b9 := by\n    dsimp\n    rw [\u2190 d_comp_desc_eq_zero_iff K e hj' hi hi' hk hk' _ h.hp]\n    exact h.w\u03b9\n  h\u03b9 := isLimitKernelFork K e hj' hi hi' hk hk' _ h.hp _ h.h\u03b9\n\n/-- Computation of the `g'` field of `extend.rightHomologyData`. -/\nlemma rightHomologyData_g' (h : (K.sc' i j k).RightHomologyData) (hk'' : e.f k = k') :\n    (rightHomologyData K e hj' hi hi' hk hk' h).g' = h.g' \u226b (K.extendXIso e hk'').inv := by\n  rw [\u2190 cancel_epi h.p, \u2190 cancel_epi (extendXIso K e hj').hom]\n  have := (rightHomologyData K e hj' hi hi' hk hk' h).p_g'\n  dsimp at this\n  rw [assoc] at this\n  rw [this, K.extend_d_eq e hj' hk'', h.p_g'_assoc, shortComplexFunctor'_obj_g]\n\n/-- The homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def homologyData (h : (K.sc' i j k).HomologyData) :\n    ((K.extend e).sc' i' j' k').HomologyData where\n  left := leftHomologyData K e hj' hi hi' hk hk' h.left\n  right := rightHomologyData K e hj' hi hi' hk hk' h.right\n  iso := h.iso\n\n/-- The homology data of `(K.extend e).sc j'` that is deduced\nfrom a homology data of `K.sc' i j k`. -/\n@[simps!]\nnoncomputable def homologyData' (h : (K.sc' i j k).HomologyData) :\n    ((K.extend e).sc j').HomologyData :=\n  homologyData K e hj' hi rfl hk rfl h\n\nend HomologyData\n\nlemma hasHomology {j : \u03b9} {j' : \u03b9'} (hj' : e.f j = j') [K.HasHomology j] :\n    (K.extend e).HasHomology j' :=\n  ShortComplex.HasHomology.mk'\n    (homologyData' K e hj' rfl rfl ((K.sc j).homologyData))\n\ninstance (j : \u03b9) [K.HasHomology j] : (K.extend e).HasHomology (e.f j) :=\n  hasHomology K e rfl\n\ninstance [\u2200 j, K.HasHomology j] (j' : \u03b9') : (K.extend e).HasHomology j' := by\n  by_cases h : \u2203 j, e.f j = j'\n  \u00b7 obtain \u27e8j, rfl\u27e9 := h\n    infer_instance\n  \u00b7 have hj := isZero_extend_X K e j' (by tauto)\n    exact ShortComplex.HasHomology.mk'\n      (ShortComplex.HomologyData.ofZeros _ (hj.eq_of_tgt _ _) (hj.eq_of_src _ _))\n\nend extend\n\nlemma extend_exactAt (j' : \u03b9') (hj' : \u2200 j, e.f j \u2260 j') :\n    (K.extend e).ExactAt j' :=\n  exactAt_of_isSupported _ e j' hj'\n\nsection\n\nvariable {j : \u03b9} {j' : \u03b9'} (hj' : e.f j = j') [K.HasHomology j] [L.HasHomology j]\n  [(K.extend e).HasHomology j'] [(L.extend e).HasHomology j']\n\n/-- The isomorphism `(K.extend e).cycles j' \u2245 K.cycles j` when `e.f j = j'`. -/\nnoncomputable def extendCyclesIso :\n    (K.extend e).cycles j' \u2245 K.cycles j :=\n  (extend.homologyData' K e hj' rfl rfl (K.sc j).homologyData).left.cyclesIso \u226a\u226b\n    (K.sc j).homologyData.left.cyclesIso.symm\n\n/-- The isomorphism `(K.extend e).opcycles j' \u2245 K.opcycles j` when `e.f j = j'`. -/\nnoncomputable def extendOpcyclesIso :\n    (K.extend e).opcycles j' \u2245 K.opcycles j :=\n  (extend.homologyData' K e hj' rfl rfl (K.sc j).homologyData).right.opcyclesIso \u226a\u226b\n    (K.sc j).homologyData.right.opcyclesIso.symm\n\n/-- The isomorphism `(K.extend e).homology j' \u2245 K.homology j` when `e.f j = j'`. -/\nnoncomputable def extendHomologyIso :\n    (K.extend e).homology j' \u2245 K.homology j :=\n  (extend.homologyData' K e hj' rfl rfl (K.sc j).homologyData).left.homologyIso \u226a\u226b\n    (K.sc j).homologyData.left.homologyIso.symm\n\ninclude hj' in\nlemma extend_exactAt_iff :\n    (K.extend e).ExactAt j' \u2194 K.ExactAt j := by\n  simp only [HomologicalComplex.exactAt_iff_isZero_homology]\n  exact (K.extendHomologyIso e hj').isZero_iff\n\n@[reassoc (attr := simp)]\nlemma extendCyclesIso_hom_iCycles :\n    (K.extendCyclesIso e hj').hom \u226b K.iCycles j =\n      (K.extend e).iCycles j' \u226b (K.extendXIso e hj').hom := by\n  rw [\u2190 cancel_epi (K.extendCyclesIso e hj').inv, Iso.inv_hom_id_assoc]\n  dsimp [extendCyclesIso, iCycles]\n  rw [assoc, ShortComplex.LeftHomologyData.cyclesIso_inv_comp_iCycles_assoc]\n  dsimp\n  rw [assoc, Iso.inv_hom_id, comp_id,\n    ShortComplex.LeftHomologyData.cyclesIso_hom_comp_i]\n\n@[reassoc (attr := simp)]\nlemma extendCyclesIso_inv_iCycles :\n    (K.extendCyclesIso e hj').inv \u226b (K.extend e).iCycles j' =\n      K.iCycles j \u226b (K.extendXIso e hj').inv := by\n  simp only [\u2190 cancel_epi (K.extendCyclesIso e hj').hom, Iso.hom_inv_id_assoc,\n    extendCyclesIso_hom_iCycles_assoc, Iso.hom_inv_id, comp_id]\n\n@[reassoc (attr := simp)]\nlemma homology\u03c0_extendHomologyIso_hom :\n    (K.extend e).homology\u03c0 j' \u226b (K.extendHomologyIso e hj').hom =\n      (K.extendCyclesIso e hj').hom \u226b K.homology\u03c0 j := by\n  dsimp [extendHomologyIso, homology\u03c0]\n  rw [ShortComplex.LeftHomologyData.homology\u03c0_comp_homologyIso_hom_assoc,\n    \u2190 cancel_mono (K.sc j).homologyData.left.homologyIso.hom,\n    assoc, assoc, assoc, Iso.inv_hom_id, comp_id,\n    ShortComplex.LeftHomologyData.homology\u03c0_comp_homologyIso_hom]\n  dsimp [extendCyclesIso]\n  simp only [assoc, Iso.inv_hom_id_assoc]\n\n@[reassoc (attr := simp)]\nlemma homology\u03c0_extendHomologyIso_inv :\n    K.homology\u03c0 j \u226b (K.extendHomologyIso e hj').inv =\n      (K.extendCyclesIso e hj').inv \u226b (K.extend e).homology\u03c0 j' := by\n  simp only [\u2190 cancel_mono (K.extendHomologyIso e hj').hom,\n    assoc, Iso.inv_hom_id, comp_id, homology\u03c0_extendHomologyIso_hom, Iso.inv_hom_id_assoc]\n\n", "theoremStatement": "@[reassoc (attr := simp)]\nlemma pOpcycles_extendOpcyclesIso_inv :\n    K.pOpcycles j \u226b (K.extendOpcyclesIso e hj').inv =\n      (K.extendXIso e hj').inv \u226b (K.extend e).pOpcycles j' ", "theoremName": "HomologicalComplex.pOpcycles_extendOpcyclesIso_inv", "fileCreated": {"commit": "9bdc1af76cf75d960f42c29f1c09917785066c8b", "date": "2024-11-30"}, "theoremCreated": {"commit": "b07a551a1451cbf8615f4e2a6c47052affadbae4", "date": "2025-01-17"}, "file": "mathlib/Mathlib/Algebra/Homology/Embedding/ExtendHomology.lean", "module": "Mathlib.Algebra.Homology.Embedding.ExtendHomology", "jsonFile": "Mathlib.Algebra.Homology.Embedding.ExtendHomology.jsonl", "positionMetadata": {"lineInFile": 359, "tokenPositionInFile": 14468, "theoremPositionInFile": 26}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 45, "numPremises": 57}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [\u2190 cancel_mono (K.extendOpcyclesIso e hj').hom, assoc, assoc, Iso.inv_hom_id, comp_id]\n  dsimp [extendOpcyclesIso, pOpcycles]\n  rw [ShortComplex.RightHomologyData.pOpcycles_comp_opcyclesIso_hom_assoc]\n  dsimp\n  rw [assoc, Iso.inv_hom_id_assoc, ShortComplex.RightHomologyData.p_comp_opcyclesIso_inv]\n  rfl", "proofType": "tactic", "proofLengthLines": 6, "proofLengthTokens": 315}}
{"srcContext": "/-\nCopyright (c) 2020 Yakov Pechersky. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yakov Pechersky, Anthony DeRossi\n-/\nimport Mathlib.Data.List.Basic\n\n/-!\n# Properties of `List.reduceOption`\n\nIn this file we prove basic lemmas about `List.reduceOption`.\n-/\n\nnamespace List\n\nvariable {\u03b1 \u03b2 : Type*}\n\n@[simp]\ntheorem reduceOption_cons_of_some (x : \u03b1) (l : List (Option \u03b1)) :\n    reduceOption (some x :: l) = x :: l.reduceOption := by\n  simp only [reduceOption, filterMap, id, eq_self_iff_true, and_self_iff]\n\n@[simp]\ntheorem reduceOption_cons_of_none (l : List (Option \u03b1)) :\n    reduceOption (none :: l) = l.reduceOption := by simp only [reduceOption, filterMap, id]\n\n@[simp]\ntheorem reduceOption_nil : @reduceOption \u03b1 [] = [] :=\n  rfl\n\n@[simp]\ntheorem reduceOption_map {l : List (Option \u03b1)} {f : \u03b1 \u2192 \u03b2} :\n    reduceOption (map (Option.map f) l) = map f (reduceOption l) := by\n  induction' l with hd tl hl\n  \u00b7 simp only [reduceOption_nil, map_nil]\n  \u00b7 cases hd <;>\n      simpa [Option.map_some', map, eq_self_iff_true, reduceOption_cons_of_some] using hl\n\ntheorem reduceOption_append (l l' : List (Option \u03b1)) :\n    (l ++ l').reduceOption = l.reduceOption ++ l'.reduceOption :=\n  filterMap_append l l' id\n\n@[simp]\ntheorem reduceOption_replicate_none {n : \u2115} : (replicate n (@none \u03b1)).reduceOption = [] := by\n  dsimp [reduceOption]\n  rw [filterMap_replicate_of_none]\n  rfl\n\ntheorem reduceOption_eq_nil_iff (l : List (Option \u03b1)) :\n    l.reduceOption = [] \u2194 \u2203 n, l = replicate n none := by\n  dsimp [reduceOption]\n  rw [filterMap_eq_nil_iff]\n  constructor\n  \u00b7 intro h\n    exact \u27e8l.length, eq_replicate_of_mem h\u27e9\n  \u00b7 intro \u27e8_, h\u27e9\n    simp_rw [h, mem_replicate]\n    tauto\n\n", "theoremStatement": "theorem reduceOption_eq_singleton_iff (l : List (Option \u03b1)) (a : \u03b1) :\n    l.reduceOption = [a] \u2194 \u2203 m n, l = replicate m none ++ some a :: replicate n none ", "theoremName": "List.reduceOption_eq_singleton_iff", "fileCreated": {"commit": "5cc0a412b7d0d30421a2b126c6ebf629f735b59f", "date": "2024-03-26"}, "theoremCreated": {"commit": "c675cb586e7054488ba6962911a6e348356d8f33", "date": "2025-01-11"}, "file": "mathlib/Mathlib/Data/List/ReduceOption.lean", "module": "Mathlib.Data.List.ReduceOption", "jsonFile": "Mathlib.Data.List.ReduceOption.jsonl", "positionMetadata": {"lineInFile": 60, "tokenPositionInFile": 1717, "theoremPositionInFile": 7}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 48}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  dsimp [reduceOption]\n  constructor\n  \u00b7 intro h\n    rw [filterMap_eq_cons_iff] at h\n    obtain \u27e8l\u2081, _, l\u2082, h, hl\u2081, \u27e8\u27e9, hl\u2082\u27e9 := h\n    rw [filterMap_eq_nil_iff] at hl\u2082\n    apply eq_replicate_of_mem at hl\u2081\n    apply eq_replicate_of_mem at hl\u2082\n    rw [h, hl\u2081, hl\u2082]\n    use l\u2081.length, l\u2082.length\n  \u00b7 intro \u27e8_, _, h\u27e9\n    simp only [h, filterMap_append, filterMap_cons_some, filterMap_replicate_of_none, id_eq,\n      nil_append, Option.some.injEq]", "proofType": "tactic", "proofLengthLines": 13, "proofLengthTokens": 446}}
{"srcContext": "/-\nCopyright (c) 2020 Nicol\u00f2 Cavalleri. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Nicol\u00f2 Cavalleri\n-/\nimport Mathlib.Geometry.Manifold.Algebra.Structures\n\n/-!\n# Algebraic structures over `C^n` functions\n\nIn this file, we define instances of algebraic structures over `C^n` functions.\n-/\n\n\nnoncomputable section\n\nopen scoped Manifold ContDiff\n\nopen TopologicalSpace\n\nvariable {\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] {E : Type*} [NormedAddCommGroup E]\n  [NormedSpace \ud835\udd5c E] {E' : Type*} [NormedAddCommGroup E'] [NormedSpace \ud835\udd5c E'] {H : Type*}\n  [TopologicalSpace H] {I : ModelWithCorners \ud835\udd5c E H} {H' : Type*} [TopologicalSpace H']\n  {I' : ModelWithCorners \ud835\udd5c E' H'} {N : Type*} [TopologicalSpace N] [ChartedSpace H N]\n  {E'' : Type*} [NormedAddCommGroup E''] [NormedSpace \ud835\udd5c E''] {H'' : Type*} [TopologicalSpace H'']\n  {I'' : ModelWithCorners \ud835\udd5c E'' H''} {N' : Type*} [TopologicalSpace N'] [ChartedSpace H'' N']\n  {n : WithTop \u2115\u221e}\n\nnamespace ContMDiffMap\n\n@[to_additive]\nprotected instance instMul {G : Type*} [Mul G] [TopologicalSpace G] [ChartedSpace H' G]\n    [ContMDiffMul I' n G] : Mul C^n\u27eeI, N; I', G\u27ef :=\n  \u27e8fun f g => \u27e8f * g, f.contMDiff.mul g.contMDiff\u27e9\u27e9\n\n@[to_additive (attr := simp)]\ntheorem coe_mul {G : Type*} [Mul G] [TopologicalSpace G] [ChartedSpace H' G] [ContMDiffMul I' n G]\n    (f g : C^n\u27eeI, N; I', G\u27ef) : \u21d1(f * g) = f * g :=\n  rfl\n\n@[to_additive (attr := simp)]\ntheorem mul_comp {G : Type*} [Mul G] [TopologicalSpace G] [ChartedSpace H' G] [ContMDiffMul I' n G]\n    (f g : C^n\u27eeI'', N'; I', G\u27ef) (h : C^n\u27eeI, N; I'', N'\u27ef) : (f * g).comp h = f.comp h * g.comp h :=\n  rfl\n\n@[to_additive]\nprotected instance instOne {G : Type*} [One G] [TopologicalSpace G] [ChartedSpace H' G] :\n    One C^n\u27eeI, N; I', G\u27ef :=\n  \u27e8ContMDiffMap.const (1 : G)\u27e9\n\n", "theoremStatement": "@[to_additive (attr := simp)]\ntheorem coe_one {G : Type*} [One G] [TopologicalSpace G] [ChartedSpace H' G] :\n    \u21d1(1 : C^n\u27eeI, N; I', G\u27ef) = 1 ", "theoremName": "ContMDiffMap.coe_one", "fileCreated": {"commit": "a9b3aae8d8902f554ca8ba9bae7e9da186ad25b8", "date": "2023-07-01"}, "theoremCreated": {"commit": "3dff5d2cec1b740fa02835cb4127421688b85634", "date": "2025-01-09"}, "file": "mathlib/Mathlib/Geometry/Manifold/Algebra/SmoothFunctions.lean", "module": "Mathlib.Geometry.Manifold.Algebra.SmoothFunctions", "jsonFile": "Mathlib.Geometry.Manifold.Algebra.SmoothFunctions.jsonl", "positionMetadata": {"lineInFile": 51, "tokenPositionInFile": 1799, "theoremPositionInFile": 2}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 17, "numPremises": 20}, "proofMetadata": {"hasProof": true, "proof": ":=\n  rfl", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 8}}
{"srcContext": "/-\nCopyright (c) 2017 Johannes H\u00f6lzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes H\u00f6lzl\n-/\nimport Mathlib.Data.Set.Lattice\nimport Mathlib.Data.Set.Pairwise.Basic\n\n/-!\n# Relations holding pairwise\n\nIn this file we prove many facts about `Pairwise` and the set lattice.\n-/\n\n\nopen Function Set Order\n\nvariable {\u03b1 \u03b9 \u03b9' : Type*} {\u03ba : Sort*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nsection Pairwise\n\nvariable {f : \u03b9 \u2192 \u03b1} {s : Set \u03b1}\n\nnamespace Set\n\ntheorem pairwise_iUnion {f : \u03ba \u2192 Set \u03b1} (h : Directed (\u00b7 \u2286 \u00b7) f) :\n    (\u22c3 n, f n).Pairwise r \u2194 \u2200 n, (f n).Pairwise r := by\n  constructor\n  \u00b7 intro H n\n    exact Pairwise.mono (subset_iUnion _ _) H\n  \u00b7 intro H i hi j hj hij\n    rcases mem_iUnion.1 hi with \u27e8m, hm\u27e9\n    rcases mem_iUnion.1 hj with \u27e8n, hn\u27e9\n    rcases h m n with \u27e8p, mp, np\u27e9\n    exact H p (mp hm) (np hn) hij\n\ntheorem pairwise_sUnion {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : Set (Set \u03b1)} (h : DirectedOn (\u00b7 \u2286 \u00b7) s) :\n    (\u22c3\u2080 s).Pairwise r \u2194 \u2200 a \u2208 s, Set.Pairwise a r := by\n  rw [sUnion_eq_iUnion, pairwise_iUnion h.directed_val, SetCoe.forall]\n\nend Set\n\nend Pairwise\n\nnamespace Set\n\nsection PartialOrderBot\n\nvariable [PartialOrder \u03b1] [OrderBot \u03b1] {s : Set \u03b9} {f : \u03b9 \u2192 \u03b1}\n\ntheorem pairwiseDisjoint_iUnion {g : \u03b9' \u2192 Set \u03b9} (h : Directed (\u00b7 \u2286 \u00b7) g) :\n    (\u22c3 n, g n).PairwiseDisjoint f \u2194 \u2200 \u2983n\u2984, (g n).PairwiseDisjoint f :=\n  pairwise_iUnion h\n\ntheorem pairwiseDisjoint_sUnion {s : Set (Set \u03b9)} (h : DirectedOn (\u00b7 \u2286 \u00b7) s) :\n    (\u22c3\u2080 s).PairwiseDisjoint f \u2194 \u2200 \u2983a\u2984, a \u2208 s \u2192 Set.PairwiseDisjoint a f :=\n  pairwise_sUnion h\n\nend PartialOrderBot\n\nsection CompleteLattice\n\nvariable [CompleteLattice \u03b1] {s : Set \u03b9} {t : Set \u03b9'}\n\n/-- Bind operation for `Set.PairwiseDisjoint`. If you want to only consider finsets of indices, you\ncan use `Set.PairwiseDisjoint.biUnion_finset`. -/\ntheorem PairwiseDisjoint.biUnion {s : Set \u03b9'} {g : \u03b9' \u2192 Set \u03b9} {f : \u03b9 \u2192 \u03b1}\n    (hs : s.PairwiseDisjoint fun i' : \u03b9' => \u2a06 i \u2208 g i', f i)\n    (hg : \u2200 i \u2208 s, (g i).PairwiseDisjoint f) : (\u22c3 i \u2208 s, g i).PairwiseDisjoint f := by\n  rintro a ha b hb hab\n  simp_rw [Set.mem_iUnion] at ha hb\n  obtain \u27e8c, hc, ha\u27e9 := ha\n  obtain \u27e8d, hd, hb\u27e9 := hb\n  obtain hcd | hcd := eq_or_ne (g c) (g d)\n  \u00b7 exact hg d hd (hcd \u25b8 ha) hb hab\n  -- Porting note: the elaborator couldn't figure out `f` here.\n  \u00b7 exact (hs hc hd <| ne_of_apply_ne _ hcd).mono\n      (le_iSup\u2082 (f := fun i (_ : i \u2208 g c) => f i) a ha)\n      (le_iSup\u2082 (f := fun i (_ : i \u2208 g d) => f i) b hb)\n\n/-- If the suprema of columns are pairwise disjoint and suprema of rows as well, then everything is\npairwise disjoint. Not to be confused with `Set.PairwiseDisjoint.prod`. -/\ntheorem PairwiseDisjoint.prod_left {f : \u03b9 \u00d7 \u03b9' \u2192 \u03b1}\n    (hs : s.PairwiseDisjoint fun i => \u2a06 i' \u2208 t, f (i, i'))\n    (ht : t.PairwiseDisjoint fun i' => \u2a06 i \u2208 s, f (i, i')) :\n    (s \u00d7\u02e2 t : Set (\u03b9 \u00d7 \u03b9')).PairwiseDisjoint f := by\n  rintro \u27e8i, i'\u27e9 hi \u27e8j, j'\u27e9 hj h\n  rw [mem_prod] at hi hj\n  obtain rfl | hij := eq_or_ne i j\n  \u00b7 refine (ht hi.2 hj.2 <| (Prod.mk.inj_left _).ne_iff.1 h).mono ?_ ?_\n    \u00b7 convert le_iSup\u2082 (\u03b1 := \u03b1) i hi.1; rfl\n    \u00b7 convert le_iSup\u2082 (\u03b1 := \u03b1) i hj.1; rfl\n  \u00b7 refine (hs hi.1 hj.1 hij).mono ?_ ?_\n    \u00b7 convert le_iSup\u2082 (\u03b1 := \u03b1) i' hi.2; rfl\n    \u00b7 convert le_iSup\u2082 (\u03b1 := \u03b1) j' hj.2; rfl\n\nend CompleteLattice\n\nsection Frame\n\nvariable [Frame \u03b1]\n\ntheorem pairwiseDisjoint_prod_left {s : Set \u03b9} {t : Set \u03b9'} {f : \u03b9 \u00d7 \u03b9' \u2192 \u03b1} :\n    (s \u00d7\u02e2 t : Set (\u03b9 \u00d7 \u03b9')).PairwiseDisjoint f \u2194\n      (s.PairwiseDisjoint fun i => \u2a06 i' \u2208 t, f (i, i')) \u2227\n        t.PairwiseDisjoint fun i' => \u2a06 i \u2208 s, f (i, i') := by\n  refine\n      \u27e8fun h => \u27e8fun i hi j hj hij => ?_, fun i hi j hj hij => ?_\u27e9, fun h => h.1.prod_left h.2\u27e9 <;>\n    simp_rw [Function.onFun, iSup_disjoint_iff, disjoint_iSup_iff] <;>\n    intro i' hi' j' hj'\n  \u00b7 exact h (mk_mem_prod hi hi') (mk_mem_prod hj hj') (ne_of_apply_ne Prod.fst hij)\n  \u00b7 exact h (mk_mem_prod hi' hi) (mk_mem_prod hj' hj) (ne_of_apply_ne Prod.snd hij)\n\nend Frame\n\ntheorem biUnion_diff_biUnion_eq {s t : Set \u03b9} {f : \u03b9 \u2192 Set \u03b1} (h : (s \u222a t).PairwiseDisjoint f) :\n    ((\u22c3 i \u2208 s, f i) \\ \u22c3 i \u2208 t, f i) = \u22c3 i \u2208 s \\ t, f i := by\n  refine\n    (biUnion_diff_biUnion_subset f s t).antisymm\n      (iUnion\u2082_subset fun i hi a ha => (mem_diff _).2 \u27e8mem_biUnion hi.1 ha, ?_\u27e9)\n  rw [mem_iUnion\u2082]; rintro \u27e8j, hj, haj\u27e9\n  exact (h (Or.inl hi.1) (Or.inr hj) (ne_of_mem_of_not_mem hj hi.2).symm).le_bot \u27e8ha, haj\u27e9\n\n\n/-- Equivalence between a disjoint bounded union and a dependent sum. -/\nnoncomputable def biUnionEqSigmaOfDisjoint {s : Set \u03b9} {f : \u03b9 \u2192 Set \u03b1} (h : s.PairwiseDisjoint f) :\n    (\u22c3 i \u2208 s, f i) \u2243 \u03a3i : s, f i :=\n  (Equiv.setCongr (biUnion_eq_iUnion _ _)).trans <|\n    unionEqSigmaOfDisjoint fun \u27e8_i, hi\u27e9 \u27e8_j, hj\u27e9 ne => h hi hj fun eq => ne <| Subtype.eq eq\n\nend Set\n\nsection\n\nvariable {f : \u03b9 \u2192 Set \u03b1} {s t : Set \u03b9}\n\n", "theoremStatement": "lemma Set.pairwiseDisjoint_iff :\n    s.PairwiseDisjoint f \u2194 \u2200 \u2983i\u2984, i \u2208 s \u2192 \u2200 \u2983j\u2984, j \u2208 s \u2192 (f i \u2229 f j).Nonempty \u2192 i = j ", "theoremName": "Set.pairwiseDisjoint_iff", "fileCreated": {"commit": "39576edbef1ad1edeb62df39455cec569f88d5ca", "date": "2023-03-27"}, "theoremCreated": {"commit": "914ded280ba36b9fefd047679ff2e7eb562370af", "date": "2025-01-20"}, "file": "mathlib/Mathlib/Data/Set/Pairwise/Lattice.lean", "module": "Mathlib.Data.Set.Pairwise.Lattice", "jsonFile": "Mathlib.Data.Set.Pairwise.Lattice.jsonl", "positionMetadata": {"lineInFile": 136, "tokenPositionInFile": 4754, "theoremPositionInFile": 9}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 25, "numPremises": 39}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp [Set.PairwiseDisjoint, Set.Pairwise, Function.onFun, not_imp_comm (a := _ = _),\n    not_disjoint_iff_nonempty_inter]", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 129}}
{"srcContext": "/-\nCopyright (c) 2016 Jeremy Avigad. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jeremy Avigad, Leonardo de Moura, Mario Carneiro\n-/\nimport Mathlib.Algebra.Order.Monoid.Canonical.Defs\nimport Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Order.Sub.Basic\nimport Mathlib.Algebra.Ring.Parity\n\n/-!\n# Canonically ordered rings and semirings.\n-/\n\n\nopen Function\n\nuniverse u\n\nvariable {\u03b1 : Type u}\n\nset_option linter.deprecated false in\n/-- A canonically ordered commutative semiring is an ordered, commutative semiring in which `a \u2264 b`\niff there exists `c` with `b = a + c`. This is satisfied by the natural numbers, for example, but\nnot the integers or other ordered groups. -/\n@[deprecated \"Use `[OrderedCommSemiring \u03b1] [CanonicallyOrderedAdd \u03b1] [NoZeroDivisors \u03b1]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyOrderedCommSemiring (\u03b1 : Type*) extends CanonicallyOrderedAddCommMonoid \u03b1,\n    CommSemiring \u03b1 where\n  /-- No zero divisors. -/\n  protected eq_zero_or_eq_zero_of_mul_eq_zero : \u2200 {a b : \u03b1}, a * b = 0 \u2192 a = 0 \u2228 b = 0\n\nattribute [nolint docBlame] CanonicallyOrderedCommSemiring.toCommSemiring\n\n-- see Note [lower instance priority]\ninstance (priority := 10) CanonicallyOrderedAdd.toZeroLEOneClass\n    [AddZeroClass \u03b1] [One \u03b1] [LE \u03b1] [CanonicallyOrderedAdd \u03b1] : ZeroLEOneClass \u03b1 where\n  zero_le_one := zero_le _\n\n-- this holds more generally if we refactor `Odd` to use\n-- either `2 \u2022 t` or `t + t` instead of `2 * t`.\nlemma Odd.pos [Semiring \u03b1] [PartialOrder \u03b1] [CanonicallyOrderedAdd \u03b1] [Nontrivial \u03b1] {a : \u03b1} :\n    Odd a \u2192 0 < a := by\n  rintro \u27e8k, rfl\u27e9; simp\n\nnamespace CanonicallyOrderedAdd\n\n-- see Note [lower instance priority]\ninstance (priority := 100) toMulLeftMono [NonUnitalNonAssocSemiring \u03b1]\n    [LE \u03b1] [CanonicallyOrderedAdd \u03b1] : MulLeftMono \u03b1 := by\n  refine \u27e8fun a b c h => ?_\u27e9; dsimp\n  rcases exists_add_of_le h with \u27e8c, rfl\u27e9\n  rw [mul_add]\n  apply self_le_add_right\n\nvariable [CommSemiring \u03b1] [PartialOrder \u03b1] [CanonicallyOrderedAdd \u03b1]\n\n-- See note [reducible non-instances]\n/-- Construct an `OrderedCommMonoid` from a canonically ordered `CommSemiring`. -/\nabbrev toOrderedCommMonoid : OrderedCommMonoid \u03b1 where\n  mul_le_mul_left _ _ := mul_le_mul_left'\n\n-- See note [reducible non-instances]\n/-- Construct an `OrderedCommSemiring` from a canonically ordered `CommSemiring`. -/\nabbrev toOrderedCommSemiring : OrderedCommSemiring \u03b1 where\n  mul_comm := mul_comm\n  zero_le_one := zero_le _\n  add_le_add_left _ _ := add_le_add_left\n  mul_le_mul_of_nonneg_left := fun _ _ _ h _ => mul_le_mul_left' h _\n  mul_le_mul_of_nonneg_right := fun _ _ _ h _ => mul_le_mul_right' h _\n\n", "theoremStatement": "@[simp]\nprotected theorem mul_pos [NoZeroDivisors \u03b1] {a b : \u03b1} :\n    0 < a * b \u2194 0 < a \u2227 0 < b ", "theoremName": "CanonicallyOrderedAdd.mul_pos", "fileCreated": {"commit": "51eda27af18442eba843165dd41a0895d7220038", "date": "2022-12-08"}, "theoremCreated": {"commit": "e9450cdc3e8f6ab0d8f2aaf93a66fb92350f8167", "date": "2025-01-16"}, "file": "mathlib/Mathlib/Algebra/Order/Ring/Canonical.lean", "module": "Mathlib.Algebra.Order.Ring.Canonical", "jsonFile": "Mathlib.Algebra.Order.Ring.Canonical.jsonl", "positionMetadata": {"lineInFile": 72, "tokenPositionInFile": 2664, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 26, "numPremises": 45}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp only [pos_iff_ne_zero, ne_eq, mul_eq_zero, not_or]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 63}}
{"srcContext": "/-\nCopyright (c) 2024 Fangming Li. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Fangming Li, Jujian Zhang\n-/\nimport Mathlib.Algebra.Polynomial.AlgebraMap\nimport Mathlib.Algebra.Polynomial.Eval.SMul\nimport Mathlib.Algebra.Polynomial.Roots\nimport Mathlib.Order.Interval.Set.Infinite\nimport Mathlib.RingTheory.Polynomial.Pochhammer\nimport Mathlib.RingTheory.PowerSeries.WellKnown\nimport Mathlib.Tactic.FieldSimp\n\n/-!\n# Hilbert polynomials\n\nIn this file, we formalise the following statement: if `F` is a field with characteristic `0`, then\ngiven any `p : F[X]` and `d : \u2115`, there exists some `h : F[X]` such that for any large enough\n`n : \u2115`, `h(n)` is equal to the coefficient of `X\u207f` in the power series expansion of `p/(1 - X)\u1d48`.\nThis `h` is unique and is denoted as `Polynomial.hilbertPoly p d`.\n\nFor example, given `d : \u2115`, the power series expansion of `1/(1 - X)\u1d48\u207a\u00b9` in `F[X]`\nis `\u03a3\u2099 ((d + n).choose d)X\u207f`, which equals `\u03a3\u2099 ((n + 1)\u00b7\u00b7\u00b7(n + d)/d!)X\u207f` and hence\n`Polynomial.hilbertPoly (1 : F[X]) (d + 1)` is the polynomial `(X + 1)\u00b7\u00b7\u00b7(X + d)/d!`. Note that\nif `d! = 0` in `F`, then the polynomial `(X + 1)\u00b7\u00b7\u00b7(X + d)/d!` no longer works, so we do not want\nthe characteristic of `F` to be divisible by `d!`. As `Polynomial.hilbertPoly` may take any\n`p : F[X]` and `d : \u2115` as its inputs, it is necessary for us to assume that `CharZero F`.\n\n## Main definitions\n\n* `Polynomial.hilbertPoly p d`. Given a field `F`, a polynomial `p : F[X]` and a natural number `d`,\n  if `F` is of characteristic `0`, then `Polynomial.hilbertPoly p d : F[X]` is the polynomial whose\n  value at `n` equals the coefficient of `X\u207f` in the power series expansion of `p/(1 - X)\u1d48`.\n\n## TODO\n\n* Hilbert polynomials of finitely generated graded modules over Noetherian rings.\n-/\n\nopen Nat PowerSeries\n\nvariable (F : Type*) [Field F]\n\nnamespace Polynomial\n\n/--\nFor any field `F` and natural numbers `d` and `k`, `Polynomial.preHilbertPoly F d k`\nis defined as `(d.factorial : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (X - (C (k : F)) + 1))`.\nThis is the most basic form of Hilbert polynomials. `Polynomial.preHilbertPoly \u211a d 0`\nis exactly the Hilbert polynomial of the polynomial ring `\u211a[X_0,...,X_d]` viewed as\na graded module over itself. In fact, `Polynomial.preHilbertPoly F d k` is the\nsame as `Polynomial.hilbertPoly ((X : F[X]) ^ k) (d + 1)` for any field `F` and\n`d k : \u2115` (see the lemma `Polynomial.hilbertPoly_X_pow_succ`). See also the lemma\n`Polynomial.preHilbertPoly_eq_choose_sub_add`, which states that if `CharZero F`,\nthen for any `d k n : \u2115` with `k \u2264 n`, `(Polynomial.preHilbertPoly F d k).eval (n : F)`\nequals `(n - k + d).choose d`.\n-/\nnoncomputable def preHilbertPoly (d k : \u2115) : F[X] :=\n  (d.factorial : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (Polynomial.X - (C (k : F)) + 1))\n\nlemma natDegree_preHilbertPoly [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).natDegree = d := by\n  have hne : (d ! : F) \u2260 0 := by norm_cast; positivity\n  rw [preHilbertPoly, natDegree_smul _ (inv_ne_zero hne), natDegree_comp, ascPochhammer_natDegree,\n    add_comm_sub, \u2190 C_1, \u2190 map_sub, natDegree_add_C, natDegree_X, mul_one]\n\nlemma coeff_preHilbertPoly_self [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).coeff d = (d ! : F)\u207b\u00b9 := by\n  delta preHilbertPoly\n  have hne : (d ! : F) \u2260 0 := by norm_cast; positivity\n  have heq : d = ((ascPochhammer F d).comp (X - C (k : F) + 1)).natDegree :=\n    (natDegree_preHilbertPoly F d k).symm.trans (natDegree_smul _ (inv_ne_zero hne))\n  nth_rw 3 [heq]\n  calc\n  _ = (d ! : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (X - C ((k : F) - 1))).leadingCoeff := by\n    simp only [sub_add, \u2190 C_1, \u2190 map_sub, coeff_smul, coeff_natDegree]\n  _ = (d ! : F)\u207b\u00b9 := by\n    simp only [leadingCoeff_comp (ne_of_eq_of_ne (natDegree_X_sub_C _) one_ne_zero), Monic.def.1\n      (monic_ascPochhammer _ _), one_mul, leadingCoeff_X_sub_C, one_pow, smul_eq_mul, mul_one]\n\nlemma leadingCoeff_preHilbertPoly [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).leadingCoeff = (d ! : F)\u207b\u00b9 := by\n  rw [leadingCoeff, natDegree_preHilbertPoly, coeff_preHilbertPoly_self]\n\nlemma preHilbertPoly_eq_choose_sub_add [CharZero F] (d : \u2115) {k n : \u2115} (hkn : k \u2264 n):\n    (preHilbertPoly F d k).eval (n : F) = (n - k + d).choose d := by\n  have : (d ! : F) \u2260 0 := by norm_cast; positivity\n  calc\n  _ = (\u2191d !)\u207b\u00b9 * eval (\u2191(n - k + 1)) (ascPochhammer F d) := by simp [cast_sub hkn, preHilbertPoly]\n  _ = (n - k + d).choose d := by\n    rw [ascPochhammer_nat_eq_natCast_ascFactorial];\n    field_simp [ascFactorial_eq_factorial_mul_choose]\n\nvariable {F}\n\n/--\n`Polynomial.hilbertPoly p 0 = 0`; for any `d : \u2115`, `Polynomial.hilbertPoly p (d + 1)`\nis defined as `\u2211 i \u2208 p.support, (p.coeff i) \u2022 Polynomial.preHilbertPoly F d i`. If\n`M` is a graded module whose Poincar\u00e9 series can be written as `p(X)/(1 - X)\u1d48` for some\n`p : \u211a[X]` with integer coefficients, then `Polynomial.hilbertPoly p d` is the Hilbert\npolynomial of `M`. See also `Polynomial.coeff_mul_invOneSubPow_eq_hilbertPoly_eval`,\nwhich says that `PowerSeries.coeff F n (p * PowerSeries.invOneSubPow F d)` equals\n`(Polynomial.hilbertPoly p d).eval (n : F)` for any large enough `n : \u2115`.\n-/\nnoncomputable def hilbertPoly (p : F[X]) : (d : \u2115) \u2192 F[X]\n  | 0 => 0\n  | d + 1 => \u2211 i \u2208 p.support, (p.coeff i) \u2022 preHilbertPoly F d i\n\nlemma hilbertPoly_zero_left (d : \u2115) : hilbertPoly (0 : F[X]) d = 0 := by\n  delta hilbertPoly; induction d with\n  | zero => simp only\n  | succ d _ => simp only [coeff_zero, zero_smul, Finset.sum_const_zero]\n\nlemma hilbertPoly_zero_right (p : F[X]) : hilbertPoly p 0 = 0 := rfl\n\n", "theoremStatement": "lemma hilbertPoly_succ (p : F[X]) (d : \u2115) :\n    hilbertPoly p (d + 1) = \u2211 i \u2208 p.support, (p.coeff i) \u2022 preHilbertPoly F d i ", "theoremName": "Polynomial.hilbertPoly_succ", "fileCreated": {"commit": "561e050467d2caa2e4ea5d81ca62600bf268b747", "date": "2024-12-02"}, "theoremCreated": {"commit": "e0cf109cd53a9eab08403037e1190790ed020a9d", "date": "2024-12-20"}, "file": "mathlib/Mathlib/RingTheory/Polynomial/HilbertPoly.lean", "module": "Mathlib.RingTheory.Polynomial.HilbertPoly", "jsonFile": "Mathlib.RingTheory.Polynomial.HilbertPoly.jsonl", "positionMetadata": {"lineInFile": 116, "tokenPositionInFile": 5558, "theoremPositionInFile": 7}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 24, "numPremises": 32}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "/-\nCopyright (c) 2024 Jo\u00ebl Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jo\u00ebl Riou\n-/\nimport Mathlib.Algebra.Homology.Embedding.Extend\nimport Mathlib.Algebra.Homology.Embedding.IsSupported\nimport Mathlib.Algebra.Homology.QuasiIso\n\n/-!\n# Homology of the extension of an homological complex\n\nGiven an embedding `e : c.Embedding c'` and `K : HomologicalComplex C c`, we shall\ncompute the homology of `K.extend e`. In degrees that are not in the image of `e.f`,\nthe homology is obviously zero. When `e.f j = j`, we construct an isomorphism\n`(K.extend e).homology j' \u2245 K.homology j`.\n\n-/\n\nopen CategoryTheory Limits Category\n\nnamespace HomologicalComplex\n\nvariable {\u03b9 \u03b9' : Type*} {c : ComplexShape \u03b9} {c' : ComplexShape \u03b9'}\n  {C : Type*} [Category C] [HasZeroMorphisms C]\n  [HasZeroObject C]\n\nvariable (K L M : HomologicalComplex C c) (\u03c6 : K \u27f6 L) (\u03c6' : L \u27f6 M) (e : c.Embedding c')\n\nnamespace extend\n\nsection HomologyData\n\nvariable {i j k : \u03b9} {i' j' k' : \u03b9'} (hj' : e.f j = j')\n  (hi : c.prev j = i) (hi' : c'.prev j' = i') (hk : c.next j = k) (hk' : c'.next j' = k')\n\ninclude hk hk' in\nlemma comp_d_eq_zero_iff \u2983W : C\u2984 (\u03c6 : W \u27f6 K.X j) :\n    \u03c6 \u226b K.d j k = 0 \u2194 \u03c6 \u226b (K.extendXIso e hj').inv \u226b (K.extend e).d j' k' = 0 := by\n  by_cases hjk : c.Rel j k\n  \u00b7 have hk' : e.f k = k' := by rw [\u2190 hk', \u2190 hj', c'.next_eq' (e.rel hjk)]\n    rw [K.extend_d_eq e hj' hk', Iso.inv_hom_id_assoc,\n      \u2190 cancel_mono (K.extendXIso e hk').inv, zero_comp, assoc]\n  \u00b7 simp only [K.shape _ _ hjk, comp_zero, true_iff]\n    rw [K.extend_d_from_eq_zero e j' k' j hj', comp_zero, comp_zero]\n    rw [hk]\n    exact hjk\n\ninclude hi hi' in\nlemma d_comp_eq_zero_iff \u2983W : C\u2984 (\u03c6 : K.X j \u27f6 W) :\n    K.d i j \u226b \u03c6 = 0 \u2194 (K.extend e).d i' j' \u226b (K.extendXIso e hj').hom \u226b \u03c6 = 0 := by\n  by_cases hij : c.Rel i j\n  \u00b7 have hi' : e.f i = i' := by rw [\u2190 hi', \u2190 hj', c'.prev_eq' (e.rel hij)]\n    rw [K.extend_d_eq e hi' hj', assoc, assoc, Iso.inv_hom_id_assoc,\n      \u2190 cancel_epi (K.extendXIso e hi').hom, comp_zero]\n  \u00b7 simp only [K.shape _ _ hij, zero_comp, true_iff]\n    rw [K.extend_d_to_eq_zero e i' j' j hj', zero_comp]\n    rw [hi]\n    exact hij\n\nnamespace leftHomologyData\n\nvariable (cone : KernelFork (K.d j k)) (hcone : IsLimit cone)\n\n/-- The kernel fork of `(K.extend e).d j' k'` that is deduced from a kernel\nfork of `K.d j k `. -/\n@[simp]\nnoncomputable def kernelFork : KernelFork ((K.extend e).d j' k') :=\n  KernelFork.of\u03b9 (cone.\u03b9 \u226b (extendXIso K e hj').inv)\n    (by rw [assoc, \u2190 comp_d_eq_zero_iff K e hj' hk hk' cone.\u03b9, cone.condition])\n\n/-- The limit kernel fork of `(K.extend e).d j' k'` that is deduced from a limit\nkernel fork of `K.d j k `. -/\nnoncomputable def isLimitKernelFork : IsLimit (kernelFork K e hj' hk hk' cone) :=\n  KernelFork.isLimitOfIsLimitOfIff hcone ((K.extend e).d j' k')\n    (extendXIso K e hj').symm (comp_d_eq_zero_iff K e hj' hk hk')\n\nvariable (cocone : CokernelCofork (hcone.lift (KernelFork.of\u03b9 (K.d i j) (K.d_comp_d i j k))))\n  (hcocone : IsColimit cocone)\n\ninclude hi hi' hcone in\n/-- Auxiliary lemma for `lift_d_comp_eq_zero_iff`. -/\nlemma lift_d_comp_eq_zero_iff' \u2983W : C\u2984 (f' : K.X i \u27f6 cone.pt)\n    (hf' : f' \u226b cone.\u03b9 = K.d i j)\n    (f'' : (K.extend e).X i' \u27f6 cone.pt)\n    (hf'' : f'' \u226b cone.\u03b9 \u226b (extendXIso K e hj').inv = (K.extend e).d i' j')\n    (\u03c6 : cone.pt \u27f6 W) :\n    f' \u226b \u03c6 = 0 \u2194 f'' \u226b \u03c6 = 0 := by\n  by_cases hij : c.Rel i j\n  \u00b7 have hi'' : e.f i = i' := by rw [\u2190 hi', \u2190 hj', c'.prev_eq' (e.rel hij)]\n    have : (K.extendXIso e hi'').hom \u226b f' = f'' := by\n      apply Fork.IsLimit.hom_ext hcone\n      rw [assoc, hf', \u2190 cancel_mono (extendXIso K e hj').inv, assoc, assoc, hf'',\n        K.extend_d_eq e hi'' hj']\n    rw [\u2190 cancel_epi (K.extendXIso e hi'').hom, comp_zero, \u2190 this, assoc]\n  \u00b7 have h\u2081 : f' = 0 := by\n      apply Fork.IsLimit.hom_ext hcone\n      simp only [zero_comp, hf', K.shape _ _ hij]\n    have h\u2082 : f'' = 0 := by\n      apply Fork.IsLimit.hom_ext hcone\n      dsimp\n      rw [\u2190 cancel_mono (extendXIso K e hj').inv, assoc, hf'', zero_comp, zero_comp,\n        K.extend_d_to_eq_zero e i' j' j hj']\n      rw [hi]\n      exact hij\n    simp [h\u2081, h\u2082]\n\ninclude hi hi' in\nlemma lift_d_comp_eq_zero_iff \u2983W : C\u2984 (\u03c6 : cone.pt \u27f6 W) :\n    hcone.lift (KernelFork.of\u03b9 (K.d i j) (K.d_comp_d i j k)) \u226b \u03c6 = 0 \u2194\n      ((isLimitKernelFork K e hj' hk hk' cone hcone).lift\n      (KernelFork.of\u03b9 ((K.extend e).d i' j') (d_comp_d _ _ _ _))) \u226b \u03c6 = 0 :=\n  lift_d_comp_eq_zero_iff' K e hj' hi hi' cone hcone _ (hcone.fac _ _) _\n    (IsLimit.fac _ _ WalkingParallelPair.zero) _\n\n/-- Auxiliary definition for `extend.leftHomologyData`. -/\nnoncomputable def cokernelCofork :\n    CokernelCofork ((isLimitKernelFork K e hj' hk hk' cone hcone).lift\n      (KernelFork.of\u03b9 ((K.extend e).d i' j') (d_comp_d _ _ _ _))) :=\n  CokernelCofork.of\u03c0 cocone.\u03c0 (by\n    rw [\u2190 lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' cone hcone]\n    exact cocone.condition)\n\n/-- Auxiliary definition for `extend.leftHomologyData`. -/\nnoncomputable def isColimitCokernelCofork :\n    IsColimit (cokernelCofork K e hj' hi hi' hk hk' cone hcone cocone) :=\n  CokernelCofork.isColimitOfIsColimitOfIff' hcocone _\n    (lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' cone hcone)\n\nend leftHomologyData\n\nopen leftHomologyData in\n/-- The left homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a left homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def leftHomologyData (h : (K.sc' i j k).LeftHomologyData) :\n    ((K.extend e).sc' i' j' k').LeftHomologyData where\n  K := h.K\n  H := h.H\n  i := h.i \u226b (extendXIso K e hj').inv\n  \u03c0 := h.\u03c0\n  wi := by\n    dsimp\n    rw [assoc, \u2190 comp_d_eq_zero_iff K e hj' hk hk']\n    exact h.wi\n  hi := isLimitKernelFork K e hj' hk hk' _ h.hi\n  w\u03c0 := by\n    dsimp\n    rw [\u2190 lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' _ h.hi]\n    exact h.w\u03c0\n  h\u03c0 := isColimitCokernelCofork K e hj' hi hi' hk hk' _ h.hi _ h.h\u03c0\n\nnamespace rightHomologyData\n\nvariable (cocone : CokernelCofork (K.d i j)) (hcocone : IsColimit cocone)\n\n/-- The cokernel cofork of `(K.extend e).d i' j'` that is deduced from a cokernel\ncofork of `K.d i j`. -/\n@[simp]\nnoncomputable def cokernelCofork : CokernelCofork ((K.extend e).d i' j') :=\n  CokernelCofork.of\u03c0 ((extendXIso K e hj').hom \u226b cocone.\u03c0) (by\n    rw [\u2190 d_comp_eq_zero_iff K e hj' hi hi' cocone.\u03c0, cocone.condition])\n\n/-- The colimit cokernel cofork of `(K.extend e).d i' j'` that is deduced from a\ncolimit cokernel cofork of `K.d i j`. -/\nnoncomputable def isColimitCokernelCofork : IsColimit (cokernelCofork K e hj' hi hi' cocone) :=\n  CokernelCofork.isColimitOfIsColimitOfIff hcocone ((K.extend e).d i' j')\n    (extendXIso K e hj') (d_comp_eq_zero_iff K e hj' hi hi')\n\nvariable (cone : KernelFork (hcocone.desc (CokernelCofork.of\u03c0 (K.d j k) (K.d_comp_d i j k))))\n  (hcone : IsLimit cone)\n\ninclude hk hk' hcocone in\nlemma d_comp_desc_eq_zero_iff' \u2983W : C\u2984 (f' : cocone.pt \u27f6 K.X k)\n    (hf' : cocone.\u03c0 \u226b f' = K.d j k)\n    (f'' : cocone.pt \u27f6 (K.extend e).X k')\n    (hf'' : (extendXIso K e hj').hom \u226b cocone.\u03c0 \u226b f'' = (K.extend e).d j' k')\n    (\u03c6 : W \u27f6 cocone.pt) :\n    \u03c6 \u226b f' = 0 \u2194 \u03c6 \u226b f'' = 0 := by\n  by_cases hjk : c.Rel j k\n  \u00b7 have hk'' : e.f k = k' := by rw [\u2190 hk', \u2190 hj', c'.next_eq' (e.rel hjk)]\n    have : f' \u226b (K.extendXIso e hk'').inv = f'' := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      rw [reassoc_of% hf', \u2190 cancel_epi (extendXIso K e hj').hom, hf'',\n        K.extend_d_eq e hj' hk'']\n    rw [\u2190 cancel_mono (K.extendXIso e hk'').inv, zero_comp, assoc, this]\n  \u00b7 have h\u2081 : f' = 0 := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      simp only [hf', comp_zero, K.shape _ _ hjk]\n    have h\u2082 : f'' = 0 := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      rw [\u2190 cancel_epi (extendXIso K e hj').hom, hf'', comp_zero, comp_zero,\n        K.extend_d_from_eq_zero e j' k' j hj']\n      rw [hk]\n      exact hjk\n    simp [h\u2081, h\u2082]\n\ninclude hk hk' in\nlemma d_comp_desc_eq_zero_iff \u2983W : C\u2984 (\u03c6 : W \u27f6 cocone.pt) :\n    \u03c6 \u226b hcocone.desc (CokernelCofork.of\u03c0 (K.d j k) (K.d_comp_d i j k)) = 0 \u2194\n      \u03c6 \u226b ((isColimitCokernelCofork K e hj' hi hi' cocone hcocone).desc\n      (CokernelCofork.of\u03c0 ((K.extend e).d j' k') (d_comp_d _ _ _ _))) = 0 :=\n  d_comp_desc_eq_zero_iff' K e hj' hk hk' cocone hcocone _ (hcocone.fac _ _) _ (by\n    simpa using (isColimitCokernelCofork K e hj' hi hi' cocone hcocone).fac _\n      WalkingParallelPair.one) _\n\n/-- Auxiliary definition for `extend.rightHomologyData`. -/\nnoncomputable def kernelFork :\n    KernelFork ((isColimitCokernelCofork K e hj' hi hi' cocone hcocone).desc\n      (CokernelCofork.of\u03c0 ((K.extend e).d j' k') (d_comp_d _ _ _ _))) :=\n  KernelFork.of\u03b9 cone.\u03b9 (by\n    rw [\u2190 d_comp_desc_eq_zero_iff K e hj' hi hi' hk hk' cocone hcocone]\n    exact cone.condition)\n\n/-- Auxiliary definition for `extend.rightHomologyData`. -/\nnoncomputable def isLimitKernelFork :\n    IsLimit (kernelFork K e hj' hi hi' hk hk' cocone hcocone cone) :=\n  KernelFork.isLimitOfIsLimitOfIff' hcone _\n    (d_comp_desc_eq_zero_iff K e hj' hi hi' hk hk' cocone hcocone)\n\nend rightHomologyData\n\nopen rightHomologyData in\n/-- The right homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a right homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def rightHomologyData (h : (K.sc' i j k).RightHomologyData) :\n    ((K.extend e).sc' i' j' k').RightHomologyData where\n  Q := h.Q\n  H := h.H\n  p := (extendXIso K e hj').hom \u226b h.p\n  \u03b9 := h.\u03b9\n  wp := by\n    dsimp\n    rw [\u2190 d_comp_eq_zero_iff K e hj' hi hi']\n    exact h.wp\n  hp := isColimitCokernelCofork K e hj' hi hi' _ h.hp\n  w\u03b9 := by\n    dsimp\n    rw [\u2190 d_comp_desc_eq_zero_iff K e hj' hi hi' hk hk' _ h.hp]\n    exact h.w\u03b9\n  h\u03b9 := isLimitKernelFork K e hj' hi hi' hk hk' _ h.hp _ h.h\u03b9\n\n/-- Computation of the `g'` field of `extend.rightHomologyData`. -/\nlemma rightHomologyData_g' (h : (K.sc' i j k).RightHomologyData) (hk'' : e.f k = k') :\n    (rightHomologyData K e hj' hi hi' hk hk' h).g' = h.g' \u226b (K.extendXIso e hk'').inv := by\n  rw [\u2190 cancel_epi h.p, \u2190 cancel_epi (extendXIso K e hj').hom]\n  have := (rightHomologyData K e hj' hi hi' hk hk' h).p_g'\n  dsimp at this\n  rw [assoc] at this\n  rw [this, K.extend_d_eq e hj' hk'', h.p_g'_assoc, shortComplexFunctor'_obj_g]\n\n/-- The homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def homologyData (h : (K.sc' i j k).HomologyData) :\n    ((K.extend e).sc' i' j' k').HomologyData where\n  left := leftHomologyData K e hj' hi hi' hk hk' h.left\n  right := rightHomologyData K e hj' hi hi' hk hk' h.right\n  iso := h.iso\n\n/-- The homology data of `(K.extend e).sc j'` that is deduced\nfrom a homology data of `K.sc' i j k`. -/\n@[simps!]\nnoncomputable def homologyData' (h : (K.sc' i j k).HomologyData) :\n    ((K.extend e).sc j').HomologyData :=\n  homologyData K e hj' hi rfl hk rfl h\n\nend HomologyData\n\nlemma hasHomology {j : \u03b9} {j' : \u03b9'} (hj' : e.f j = j') [K.HasHomology j] :\n    (K.extend e).HasHomology j' :=\n  ShortComplex.HasHomology.mk'\n    (homologyData' K e hj' rfl rfl ((K.sc j).homologyData))\n\ninstance (j : \u03b9) [K.HasHomology j] : (K.extend e).HasHomology (e.f j) :=\n  hasHomology K e rfl\n\ninstance [\u2200 j, K.HasHomology j] (j' : \u03b9') : (K.extend e).HasHomology j' := by\n  by_cases h : \u2203 j, e.f j = j'\n  \u00b7 obtain \u27e8j, rfl\u27e9 := h\n    infer_instance\n  \u00b7 have hj := isZero_extend_X K e j' (by tauto)\n    exact ShortComplex.HasHomology.mk'\n      (ShortComplex.HomologyData.ofZeros _ (hj.eq_of_tgt _ _) (hj.eq_of_src _ _))\n\nend extend\n\nlemma extend_exactAt (j' : \u03b9') (hj' : \u2200 j, e.f j \u2260 j') :\n    (K.extend e).ExactAt j' :=\n  exactAt_of_isSupported _ e j' hj'\n\nsection\n\nvariable {j : \u03b9} {j' : \u03b9'} (hj' : e.f j = j') [K.HasHomology j] [L.HasHomology j]\n  [(K.extend e).HasHomology j'] [(L.extend e).HasHomology j']\n\n/-- The isomorphism `(K.extend e).cycles j' \u2245 K.cycles j` when `e.f j = j'`. -/\nnoncomputable def extendCyclesIso :\n    (K.extend e).cycles j' \u2245 K.cycles j :=\n  (extend.homologyData' K e hj' rfl rfl (K.sc j).homologyData).left.cyclesIso \u226a\u226b\n    (K.sc j).homologyData.left.cyclesIso.symm\n\n/-- The isomorphism `(K.extend e).opcycles j' \u2245 K.opcycles j` when `e.f j = j'`. -/\nnoncomputable def extendOpcyclesIso :\n    (K.extend e).opcycles j' \u2245 K.opcycles j :=\n  (extend.homologyData' K e hj' rfl rfl (K.sc j).homologyData).right.opcyclesIso \u226a\u226b\n    (K.sc j).homologyData.right.opcyclesIso.symm\n\n/-- The isomorphism `(K.extend e).homology j' \u2245 K.homology j` when `e.f j = j'`. -/\nnoncomputable def extendHomologyIso :\n    (K.extend e).homology j' \u2245 K.homology j :=\n  (extend.homologyData' K e hj' rfl rfl (K.sc j).homologyData).left.homologyIso \u226a\u226b\n    (K.sc j).homologyData.left.homologyIso.symm\n\ninclude hj' in\nlemma extend_exactAt_iff :\n    (K.extend e).ExactAt j' \u2194 K.ExactAt j := by\n  simp only [HomologicalComplex.exactAt_iff_isZero_homology]\n  exact (K.extendHomologyIso e hj').isZero_iff\n\n@[reassoc (attr := simp)]\nlemma extendCyclesIso_hom_iCycles :\n    (K.extendCyclesIso e hj').hom \u226b K.iCycles j =\n      (K.extend e).iCycles j' \u226b (K.extendXIso e hj').hom := by\n  rw [\u2190 cancel_epi (K.extendCyclesIso e hj').inv, Iso.inv_hom_id_assoc]\n  dsimp [extendCyclesIso, iCycles]\n  rw [assoc, ShortComplex.LeftHomologyData.cyclesIso_inv_comp_iCycles_assoc]\n  dsimp\n  rw [assoc, Iso.inv_hom_id, comp_id,\n    ShortComplex.LeftHomologyData.cyclesIso_hom_comp_i]\n\n@[reassoc (attr := simp)]\nlemma extendCyclesIso_inv_iCycles :\n    (K.extendCyclesIso e hj').inv \u226b (K.extend e).iCycles j' =\n      K.iCycles j \u226b (K.extendXIso e hj').inv := by\n  simp only [\u2190 cancel_epi (K.extendCyclesIso e hj').hom, Iso.hom_inv_id_assoc,\n    extendCyclesIso_hom_iCycles_assoc, Iso.hom_inv_id, comp_id]\n\n@[reassoc (attr := simp)]\nlemma homology\u03c0_extendHomologyIso_hom :\n    (K.extend e).homology\u03c0 j' \u226b (K.extendHomologyIso e hj').hom =\n      (K.extendCyclesIso e hj').hom \u226b K.homology\u03c0 j := by\n  dsimp [extendHomologyIso, homology\u03c0]\n  rw [ShortComplex.LeftHomologyData.homology\u03c0_comp_homologyIso_hom_assoc,\n    \u2190 cancel_mono (K.sc j).homologyData.left.homologyIso.hom,\n    assoc, assoc, assoc, Iso.inv_hom_id, comp_id,\n    ShortComplex.LeftHomologyData.homology\u03c0_comp_homologyIso_hom]\n  dsimp [extendCyclesIso]\n  simp only [assoc, Iso.inv_hom_id_assoc]\n\n@[reassoc (attr := simp)]\nlemma homology\u03c0_extendHomologyIso_inv :\n    K.homology\u03c0 j \u226b (K.extendHomologyIso e hj').inv =\n      (K.extendCyclesIso e hj').inv \u226b (K.extend e).homology\u03c0 j' := by\n  simp only [\u2190 cancel_mono (K.extendHomologyIso e hj').hom,\n    assoc, Iso.inv_hom_id, comp_id, homology\u03c0_extendHomologyIso_hom, Iso.inv_hom_id_assoc]\n\n@[reassoc (attr := simp)]\nlemma pOpcycles_extendOpcyclesIso_inv :\n    K.pOpcycles j \u226b (K.extendOpcyclesIso e hj').inv =\n      (K.extendXIso e hj').inv \u226b (K.extend e).pOpcycles j' := by\n  rw [\u2190 cancel_mono (K.extendOpcyclesIso e hj').hom, assoc, assoc, Iso.inv_hom_id, comp_id]\n  dsimp [extendOpcyclesIso, pOpcycles]\n  rw [ShortComplex.RightHomologyData.pOpcycles_comp_opcyclesIso_hom_assoc]\n  dsimp\n  rw [assoc, Iso.inv_hom_id_assoc, ShortComplex.RightHomologyData.p_comp_opcyclesIso_inv]\n  rfl\n\n@[reassoc (attr := simp)]\nlemma pOpcycles_extendOpcyclesIso_hom :\n    (K.extend e).pOpcycles j' \u226b (K.extendOpcyclesIso e hj').hom =\n      (K.extendXIso e hj').hom \u226b K.pOpcycles j := by\n  simp only [\u2190 cancel_mono (K.extendOpcyclesIso e hj').inv,\n    assoc, Iso.hom_inv_id, comp_id, pOpcycles_extendOpcyclesIso_inv, Iso.hom_inv_id_assoc]\n\n@[reassoc (attr := simp)]\nlemma extendHomologyIso_hom_homology\u03b9 :\n    (K.extendHomologyIso e hj').hom \u226b K.homology\u03b9 j =\n      (K.extend e).homology\u03b9 j' \u226b (K.extendOpcyclesIso e hj').hom := by\n  simp only [\u2190 cancel_epi ((K.extend e).homology\u03c0 j'),\n    homology\u03c0_extendHomologyIso_hom_assoc, homology_\u03c0_\u03b9, extendCyclesIso_hom_iCycles_assoc,\n    homology_\u03c0_\u03b9_assoc, pOpcycles_extendOpcyclesIso_hom]\n\n", "theoremStatement": "@[reassoc (attr := simp)]\nlemma extendHomologyIso_inv_homology\u03b9 :\n    (K.extendHomologyIso e hj').inv \u226b (K.extend e).homology\u03b9 j' =\n      K.homology\u03b9 j \u226b (K.extendOpcyclesIso e hj').inv ", "theoremName": "HomologicalComplex.extendHomologyIso_inv_homology\u03b9", "fileCreated": {"commit": "9bdc1af76cf75d960f42c29f1c09917785066c8b", "date": "2024-11-30"}, "theoremCreated": {"commit": "b07a551a1451cbf8615f4e2a6c47052affadbae4", "date": "2025-01-17"}, "file": "mathlib/Mathlib/Algebra/Homology/Embedding/ExtendHomology.lean", "module": "Mathlib.Algebra.Homology.Embedding.ExtendHomology", "jsonFile": "Mathlib.Algebra.Homology.Embedding.ExtendHomology.jsonl", "positionMetadata": {"lineInFile": 385, "tokenPositionInFile": 15698, "theoremPositionInFile": 29}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 30, "numPremises": 39}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp only [\u2190 cancel_epi (K.extendHomologyIso e hj').hom,\n    Iso.hom_inv_id_assoc, extendHomologyIso_hom_homology\u03b9_assoc, Iso.hom_inv_id, comp_id]", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 154}}
{"srcContext": "/-\nCopyright (c) 2020 Aaron Anderson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Aaron Anderson\n-/\nimport Mathlib.Data.Set.Lattice\nimport Mathlib.Data.SetLike.Basic\nimport Mathlib.Order.ModularLattice\nimport Mathlib.Order.SuccPred.Basic\nimport Mathlib.Order.WellFounded\nimport Mathlib.Tactic.Nontriviality\nimport Mathlib.Order.ConditionallyCompleteLattice.Indexed\n\n/-!\n# Atoms, Coatoms, and Simple Lattices\n\nThis module defines atoms, which are minimal non-`\u22a5` elements in bounded lattices, simple lattices,\nwhich are lattices with only two elements, and related ideas.\n\n## Main definitions\n\n### Atoms and Coatoms\n  * `IsAtom a` indicates that the only element below `a` is `\u22a5`.\n  * `IsCoatom a` indicates that the only element above `a` is `\u22a4`.\n\n### Atomic and Atomistic Lattices\n  * `IsAtomic` indicates that every element other than `\u22a5` is above an atom.\n  * `IsCoatomic` indicates that every element other than `\u22a4` is below a coatom.\n  * `IsAtomistic` indicates that every element is the `sSup` of a set of atoms.\n  * `IsCoatomistic` indicates that every element is the `sInf` of a set of coatoms.\n  * `IsStronglyAtomic` indicates that for all `a < b`, there is some `x` with `a \u22d6 x \u2264 b`.\n  * `IsStronglyCoatomic` indicates that for all `a < b`, there is some `x` with `a \u2264 x \u22d6 b`.\n\n### Simple Lattices\n  * `IsSimpleOrder` indicates that an order has only two unique elements, `\u22a5` and `\u22a4`.\n  * `IsSimpleOrder.boundedOrder`\n  * `IsSimpleOrder.distribLattice`\n  * Given an instance of `IsSimpleOrder`, we provide the following definitions. These are not\n    made global instances as they contain data :\n    * `IsSimpleOrder.booleanAlgebra`\n    * `IsSimpleOrder.completeLattice`\n    * `IsSimpleOrder.completeBooleanAlgebra`\n\n## Main results\n  * `isAtom_dual_iff_isCoatom` and `isCoatom_dual_iff_isAtom` express the (definitional) duality\n   of `IsAtom` and `IsCoatom`.\n  * `isSimpleOrder_iff_isAtom_top` and `isSimpleOrder_iff_isCoatom_bot` express the\n  connection between atoms, coatoms, and simple lattices\n  * `IsCompl.isAtom_iff_isCoatom` and `IsCompl.isCoatom_if_isAtom`: In a modular\n  bounded lattice, a complement of an atom is a coatom and vice versa.\n  * `isAtomic_iff_isCoatomic`: A modular complemented lattice is atomic iff it is coatomic.\n\n-/\n\nvariable {\u03b9 : Sort*} {\u03b1 \u03b2 : Type*}\n\nsection Atoms\n\nsection IsAtom\n\nsection Preorder\n\nvariable [Preorder \u03b1] [OrderBot \u03b1] {a b x : \u03b1}\n\n/-- An atom of an `OrderBot` is an element with no other element between it and `\u22a5`,\n  which is not `\u22a5`. -/\ndef IsAtom (a : \u03b1) : Prop :=\n  a \u2260 \u22a5 \u2227 \u2200 b, b < a \u2192 b = \u22a5\n\ntheorem IsAtom.Iic (ha : IsAtom a) (hax : a \u2264 x) : IsAtom (\u27e8a, hax\u27e9 : Set.Iic x) :=\n  \u27e8fun con => ha.1 (Subtype.mk_eq_mk.1 con), fun \u27e8b, _\u27e9 hba => Subtype.mk_eq_mk.2 (ha.2 b hba)\u27e9\n\ntheorem IsAtom.of_isAtom_coe_Iic {a : Set.Iic x} (ha : IsAtom a) : IsAtom (a : \u03b1) :=\n  \u27e8fun con => ha.1 (Subtype.ext con), fun b hba =>\n    Subtype.mk_eq_mk.1 (ha.2 \u27e8b, hba.le.trans a.prop\u27e9 hba)\u27e9\n\ntheorem isAtom_iff_le_of_ge : IsAtom a \u2194 a \u2260 \u22a5 \u2227 \u2200 b \u2260 \u22a5, b \u2264 a \u2192 a \u2264 b :=\n  and_congr Iff.rfl <|\n    forall_congr' fun b => by\n      simp only [Ne, @not_imp_comm (b = \u22a5), Classical.not_imp, lt_iff_le_not_le]\n\nend Preorder\n\nsection PartialOrder\n\nvariable [PartialOrder \u03b1] [OrderBot \u03b1] {a b x : \u03b1}\n\ntheorem IsAtom.lt_iff (h : IsAtom a) : x < a \u2194 x = \u22a5 :=\n  \u27e8h.2 x, fun hx => hx.symm \u25b8 h.1.bot_lt\u27e9\n\ntheorem IsAtom.le_iff (h : IsAtom a) : x \u2264 a \u2194 x = \u22a5 \u2228 x = a := by rw [le_iff_lt_or_eq, h.lt_iff]\n\nlemma IsAtom.bot_lt (h : IsAtom a) : \u22a5 < a :=\n  h.lt_iff.mpr rfl\n\nlemma IsAtom.le_iff_eq (ha : IsAtom a) (hb : b \u2260 \u22a5) : b \u2264 a \u2194 b = a :=\n  ha.le_iff.trans <| or_iff_right hb\n\ntheorem IsAtom.Iic_eq (h : IsAtom a) : Set.Iic a = {\u22a5, a} :=\n  Set.ext fun _ => h.le_iff\n\n@[simp]\ntheorem bot_covBy_iff : \u22a5 \u22d6 a \u2194 IsAtom a := by\n  simp only [CovBy, bot_lt_iff_ne_bot, IsAtom, not_imp_not]\n\nalias \u27e8CovBy.is_atom, IsAtom.bot_covBy\u27e9 := bot_covBy_iff\n\nend PartialOrder\n\ntheorem atom_le_iSup [Order.Frame \u03b1] {a : \u03b1} (ha : IsAtom a) {f : \u03b9 \u2192 \u03b1} :\n    a \u2264 iSup f \u2194 \u2203 i, a \u2264 f i := by\n  refine \u27e8?_, fun \u27e8i, hi\u27e9 => le_trans hi (le_iSup _ _)\u27e9\n  show (a \u2264 \u2a06 i, f i) \u2192 _\n  refine fun h => of_not_not fun ha' => ?_\n  push_neg at ha'\n  have ha'' : Disjoint a (\u2a06 i, f i) :=\n    disjoint_iSup_iff.2 fun i => fun x hxa hxf => le_bot_iff.2 <| of_not_not fun hx =>\n      have hxa : x < a := (le_iff_eq_or_lt.1 hxa).resolve_left (by rintro rfl; exact ha' _ hxf)\n      hx (ha.2 _ hxa)\n  obtain rfl := le_bot_iff.1 (ha'' le_rfl h)\n  exact ha.1 rfl\n\nend IsAtom\n\nsection IsCoatom\n\nsection Preorder\n\nvariable [Preorder \u03b1]\n\n/-- A coatom of an `OrderTop` is an element with no other element between it and `\u22a4`,\n  which is not `\u22a4`. -/\ndef IsCoatom [OrderTop \u03b1] (a : \u03b1) : Prop :=\n  a \u2260 \u22a4 \u2227 \u2200 b, a < b \u2192 b = \u22a4\n\n@[simp]\ntheorem isCoatom_dual_iff_isAtom [OrderBot \u03b1] {a : \u03b1} :\n    IsCoatom (OrderDual.toDual a) \u2194 IsAtom a :=\n  Iff.rfl\n\n@[simp]\ntheorem isAtom_dual_iff_isCoatom [OrderTop \u03b1] {a : \u03b1} :\n    IsAtom (OrderDual.toDual a) \u2194 IsCoatom a :=\n  Iff.rfl\n\nalias \u27e8_, IsAtom.dual\u27e9 := isCoatom_dual_iff_isAtom\n\nalias \u27e8_, IsCoatom.dual\u27e9 := isAtom_dual_iff_isCoatom\n\nvariable [OrderTop \u03b1] {a x : \u03b1}\n\ntheorem IsCoatom.Ici (ha : IsCoatom a) (hax : x \u2264 a) : IsCoatom (\u27e8a, hax\u27e9 : Set.Ici x) :=\n  ha.dual.Iic hax\n\ntheorem IsCoatom.of_isCoatom_coe_Ici {a : Set.Ici x} (ha : IsCoatom a) : IsCoatom (a : \u03b1) :=\n  @IsAtom.of_isAtom_coe_Iic \u03b1\u1d52\u1d48 _ _ x a ha\n\ntheorem isCoatom_iff_ge_of_le : IsCoatom a \u2194 a \u2260 \u22a4 \u2227 \u2200 b \u2260 \u22a4, a \u2264 b \u2192 b \u2264 a :=\n  isAtom_iff_le_of_ge (\u03b1 := \u03b1\u1d52\u1d48)\n\nend Preorder\n\nsection PartialOrder\n\nvariable [PartialOrder \u03b1] [OrderTop \u03b1] {a b x : \u03b1}\n\ntheorem IsCoatom.lt_iff (h : IsCoatom a) : a < x \u2194 x = \u22a4 :=\n  h.dual.lt_iff\n\ntheorem IsCoatom.le_iff (h : IsCoatom a) : a \u2264 x \u2194 x = \u22a4 \u2228 x = a :=\n  h.dual.le_iff\n\nlemma IsCoatom.lt_top (h : IsCoatom a) : a < \u22a4 :=\n  h.lt_iff.mpr rfl\n\nlemma IsCoatom.le_iff_eq (ha : IsCoatom a) (hb : b \u2260 \u22a4) : a \u2264 b \u2194 b = a := ha.dual.le_iff_eq hb\n\ntheorem IsCoatom.Ici_eq (h : IsCoatom a) : Set.Ici a = {\u22a4, a} :=\n  h.dual.Iic_eq\n\n@[simp]\ntheorem covBy_top_iff : a \u22d6 \u22a4 \u2194 IsCoatom a :=\n  toDual_covBy_toDual_iff.symm.trans bot_covBy_iff\n\nalias \u27e8CovBy.isCoatom, IsCoatom.covBy_top\u27e9 := covBy_top_iff\n\nnamespace SetLike\n\nvariable {A B : Type*} [SetLike A B]\n\ntheorem isAtom_iff [OrderBot A] {K : A} :\n    IsAtom K \u2194 K \u2260 \u22a5 \u2227 \u2200 H g, H \u2264 K \u2192 g \u2209 H \u2192 g \u2208 K \u2192 H = \u22a5 := by\n  simp_rw [IsAtom, lt_iff_le_not_le, SetLike.not_le_iff_exists,\n    and_comm (a := _ \u2264 _), and_imp, exists_imp, \u2190 and_imp, and_comm]\n\n", "theoremStatement": "theorem isCoatom_iff [OrderTop A] {K : A} :\n    IsCoatom K \u2194 K \u2260 \u22a4 \u2227 \u2200 H g, K \u2264 H \u2192 g \u2209 K \u2192 g \u2208 H \u2192 H = \u22a4 ", "theoremName": "SetLike.isCoatom_iff", "fileCreated": {"commit": "8618f40d51539454fe06511d5c8504a77f30c598", "date": "2022-12-30"}, "theoremCreated": {"commit": "74fff29536e0a0eeca1aa8421089b76b157a3b2f", "date": "2025-01-14"}, "file": "mathlib/Mathlib/Order/Atoms.lean", "module": "Mathlib.Order.Atoms", "jsonFile": "Mathlib.Order.Atoms.jsonl", "positionMetadata": {"lineInFile": 196, "tokenPositionInFile": 6470, "theoremPositionInFile": 24}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 13, "numPremises": 39}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp_rw [IsCoatom, lt_iff_le_not_le, SetLike.not_le_iff_exists,\n    and_comm (a := _ \u2264 _), and_imp, exists_imp, \u2190 and_imp, and_comm]", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 140}}
{"srcContext": "/-\nCopyright (c) 2024 Fangming Li. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Fangming Li, Jujian Zhang\n-/\nimport Mathlib.Algebra.Polynomial.AlgebraMap\nimport Mathlib.Algebra.Polynomial.Eval.SMul\nimport Mathlib.Algebra.Polynomial.Roots\nimport Mathlib.Order.Interval.Set.Infinite\nimport Mathlib.RingTheory.Polynomial.Pochhammer\nimport Mathlib.RingTheory.PowerSeries.WellKnown\nimport Mathlib.Tactic.FieldSimp\n\n/-!\n# Hilbert polynomials\n\nIn this file, we formalise the following statement: if `F` is a field with characteristic `0`, then\ngiven any `p : F[X]` and `d : \u2115`, there exists some `h : F[X]` such that for any large enough\n`n : \u2115`, `h(n)` is equal to the coefficient of `X\u207f` in the power series expansion of `p/(1 - X)\u1d48`.\nThis `h` is unique and is denoted as `Polynomial.hilbertPoly p d`.\n\nFor example, given `d : \u2115`, the power series expansion of `1/(1 - X)\u1d48\u207a\u00b9` in `F[X]`\nis `\u03a3\u2099 ((d + n).choose d)X\u207f`, which equals `\u03a3\u2099 ((n + 1)\u00b7\u00b7\u00b7(n + d)/d!)X\u207f` and hence\n`Polynomial.hilbertPoly (1 : F[X]) (d + 1)` is the polynomial `(X + 1)\u00b7\u00b7\u00b7(X + d)/d!`. Note that\nif `d! = 0` in `F`, then the polynomial `(X + 1)\u00b7\u00b7\u00b7(X + d)/d!` no longer works, so we do not want\nthe characteristic of `F` to be divisible by `d!`. As `Polynomial.hilbertPoly` may take any\n`p : F[X]` and `d : \u2115` as its inputs, it is necessary for us to assume that `CharZero F`.\n\n## Main definitions\n\n* `Polynomial.hilbertPoly p d`. Given a field `F`, a polynomial `p : F[X]` and a natural number `d`,\n  if `F` is of characteristic `0`, then `Polynomial.hilbertPoly p d : F[X]` is the polynomial whose\n  value at `n` equals the coefficient of `X\u207f` in the power series expansion of `p/(1 - X)\u1d48`.\n\n## TODO\n\n* Hilbert polynomials of finitely generated graded modules over Noetherian rings.\n-/\n\nopen Nat PowerSeries\n\nvariable (F : Type*) [Field F]\n\nnamespace Polynomial\n\n/--\nFor any field `F` and natural numbers `d` and `k`, `Polynomial.preHilbertPoly F d k`\nis defined as `(d.factorial : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (X - (C (k : F)) + 1))`.\nThis is the most basic form of Hilbert polynomials. `Polynomial.preHilbertPoly \u211a d 0`\nis exactly the Hilbert polynomial of the polynomial ring `\u211a[X_0,...,X_d]` viewed as\na graded module over itself. In fact, `Polynomial.preHilbertPoly F d k` is the\nsame as `Polynomial.hilbertPoly ((X : F[X]) ^ k) (d + 1)` for any field `F` and\n`d k : \u2115` (see the lemma `Polynomial.hilbertPoly_X_pow_succ`). See also the lemma\n`Polynomial.preHilbertPoly_eq_choose_sub_add`, which states that if `CharZero F`,\nthen for any `d k n : \u2115` with `k \u2264 n`, `(Polynomial.preHilbertPoly F d k).eval (n : F)`\nequals `(n - k + d).choose d`.\n-/\nnoncomputable def preHilbertPoly (d k : \u2115) : F[X] :=\n  (d.factorial : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (Polynomial.X - (C (k : F)) + 1))\n\nlemma natDegree_preHilbertPoly [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).natDegree = d := by\n  have hne : (d ! : F) \u2260 0 := by norm_cast; positivity\n  rw [preHilbertPoly, natDegree_smul _ (inv_ne_zero hne), natDegree_comp, ascPochhammer_natDegree,\n    add_comm_sub, \u2190 C_1, \u2190 map_sub, natDegree_add_C, natDegree_X, mul_one]\n\nlemma coeff_preHilbertPoly_self [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).coeff d = (d ! : F)\u207b\u00b9 := by\n  delta preHilbertPoly\n  have hne : (d ! : F) \u2260 0 := by norm_cast; positivity\n  have heq : d = ((ascPochhammer F d).comp (X - C (k : F) + 1)).natDegree :=\n    (natDegree_preHilbertPoly F d k).symm.trans (natDegree_smul _ (inv_ne_zero hne))\n  nth_rw 3 [heq]\n  calc\n  _ = (d ! : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (X - C ((k : F) - 1))).leadingCoeff := by\n    simp only [sub_add, \u2190 C_1, \u2190 map_sub, coeff_smul, coeff_natDegree]\n  _ = (d ! : F)\u207b\u00b9 := by\n    simp only [leadingCoeff_comp (ne_of_eq_of_ne (natDegree_X_sub_C _) one_ne_zero), Monic.def.1\n      (monic_ascPochhammer _ _), one_mul, leadingCoeff_X_sub_C, one_pow, smul_eq_mul, mul_one]\n\nlemma leadingCoeff_preHilbertPoly [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).leadingCoeff = (d ! : F)\u207b\u00b9 := by\n  rw [leadingCoeff, natDegree_preHilbertPoly, coeff_preHilbertPoly_self]\n\nlemma preHilbertPoly_eq_choose_sub_add [CharZero F] (d : \u2115) {k n : \u2115} (hkn : k \u2264 n):\n    (preHilbertPoly F d k).eval (n : F) = (n - k + d).choose d := by\n  have : (d ! : F) \u2260 0 := by norm_cast; positivity\n  calc\n  _ = (\u2191d !)\u207b\u00b9 * eval (\u2191(n - k + 1)) (ascPochhammer F d) := by simp [cast_sub hkn, preHilbertPoly]\n  _ = (n - k + d).choose d := by\n    rw [ascPochhammer_nat_eq_natCast_ascFactorial];\n    field_simp [ascFactorial_eq_factorial_mul_choose]\n\nvariable {F}\n\n/--\n`Polynomial.hilbertPoly p 0 = 0`; for any `d : \u2115`, `Polynomial.hilbertPoly p (d + 1)`\nis defined as `\u2211 i \u2208 p.support, (p.coeff i) \u2022 Polynomial.preHilbertPoly F d i`. If\n`M` is a graded module whose Poincar\u00e9 series can be written as `p(X)/(1 - X)\u1d48` for some\n`p : \u211a[X]` with integer coefficients, then `Polynomial.hilbertPoly p d` is the Hilbert\npolynomial of `M`. See also `Polynomial.coeff_mul_invOneSubPow_eq_hilbertPoly_eval`,\nwhich says that `PowerSeries.coeff F n (p * PowerSeries.invOneSubPow F d)` equals\n`(Polynomial.hilbertPoly p d).eval (n : F)` for any large enough `n : \u2115`.\n-/\nnoncomputable def hilbertPoly (p : F[X]) : (d : \u2115) \u2192 F[X]\n  | 0 => 0\n  | d + 1 => \u2211 i \u2208 p.support, (p.coeff i) \u2022 preHilbertPoly F d i\n\nlemma hilbertPoly_zero_left (d : \u2115) : hilbertPoly (0 : F[X]) d = 0 := by\n  delta hilbertPoly; induction d with\n  | zero => simp only\n  | succ d _ => simp only [coeff_zero, zero_smul, Finset.sum_const_zero]\n\nlemma hilbertPoly_zero_right (p : F[X]) : hilbertPoly p 0 = 0 := rfl\n\nlemma hilbertPoly_succ (p : F[X]) (d : \u2115) :\n    hilbertPoly p (d + 1) = \u2211 i \u2208 p.support, (p.coeff i) \u2022 preHilbertPoly F d i := rfl\n\nlemma hilbertPoly_X_pow_succ (d k : \u2115) :\n    hilbertPoly ((X : F[X]) ^ k) (d + 1) = preHilbertPoly F d k := by\n  delta hilbertPoly; simp\n\nlemma hilbertPoly_add_left (p q : F[X]) (d : \u2115) :\n    hilbertPoly (p + q) d = hilbertPoly p d + hilbertPoly q d := by\n  delta hilbertPoly\n  induction d with\n  | zero => simp only [add_zero]\n  | succ d _ =>\n      simp only [\u2190 coeff_add]\n      rw [\u2190 sum_def _ fun _ r => r \u2022 _]\n      exact sum_add_index _ _ _ (fun _ => zero_smul ..) (fun _ _ _ => add_smul ..)\n\nlemma hilbertPoly_smul (a : F) (p : F[X]) (d : \u2115) :\n    hilbertPoly (a \u2022 p) d = a \u2022 hilbertPoly p d := by\n  delta hilbertPoly\n  induction d with\n  | zero => simp only [smul_zero]\n  | succ d _ =>\n      simp only\n      rw [\u2190 sum_def _ fun _ r => r \u2022 _, \u2190 sum_def _ fun _ r => r \u2022 _, Polynomial.smul_sum,\n        sum_smul_index' _ _ _ fun i => zero_smul F (preHilbertPoly F d i)]\n      simp only [smul_assoc]\n\nvariable (F) in\n/--\nThe function that sends any `p : F[X]` to `Polynomial.hilbertPoly p d` is an `F`-linear map from\n`F[X]` to `F[X]`.\n-/\nnoncomputable def hilbertPoly_linearMap (d : \u2115) : F[X] \u2192\u2097[F] F[X] where\n  toFun p := hilbertPoly p d\n  map_add' p q := hilbertPoly_add_left p q d\n  map_smul' r p := hilbertPoly_smul r p d\n\nvariable [CharZero F]\n\n/--\nThe key property of Hilbert polynomials. If `F` is a field with characteristic `0`, `p : F[X]` and\n`d : \u2115`, then for any large enough `n : \u2115`, `(Polynomial.hilbertPoly p d).eval (n : F)` equals the\ncoefficient of `X\u207f` in the power series expansion of `p/(1 - X)\u1d48`.\n-/\ntheorem coeff_mul_invOneSubPow_eq_hilbertPoly_eval\n    {p : F[X]} (d : \u2115) {n : \u2115} (hn : p.natDegree < n) :\n    PowerSeries.coeff F n (p * invOneSubPow F d) = (hilbertPoly p d).eval (n : F) := by\n  delta hilbertPoly; induction d with\n  | zero => simp only [invOneSubPow_zero, Units.val_one, mul_one, coeff_coe, eval_zero]\n            exact coeff_eq_zero_of_natDegree_lt hn\n  | succ d hd =>\n      simp only [eval_finset_sum, eval_smul, smul_eq_mul]\n      rw [\u2190 Finset.sum_coe_sort]\n      have h_le (i : p.support) : (i : \u2115) \u2264 n :=\n        le_trans (le_natDegree_of_ne_zero <| mem_support_iff.1 i.2) hn.le\n      have h (i : p.support) : eval \u2191n (preHilbertPoly F d \u2191i) = (n + d - \u2191i).choose d := by\n        rw [preHilbertPoly_eq_choose_sub_add _ _ (h_le i), Nat.sub_add_comm (h_le i)]\n      simp_rw [h]\n      rw [Finset.sum_coe_sort _ (fun x => (p.coeff \u2191x) * (_ + d - \u2191x).choose _),\n        PowerSeries.coeff_mul, Finset.Nat.sum_antidiagonal_eq_sum_range_succ_mk,\n        invOneSubPow_val_eq_mk_sub_one_add_choose_of_pos _ _ (zero_lt_succ d)]\n      simp only [coeff_coe, coeff_mk]\n      symm\n      refine Finset.sum_subset_zero_on_sdiff (fun s hs \u21a6 ?_) (fun x hx \u21a6 ?_) (fun x hx \u21a6 ?_)\n      \u00b7 rw [Finset.mem_range_succ_iff]\n        exact h_le \u27e8s, hs\u27e9\n      \u00b7 simp only [Finset.mem_sdiff, mem_support_iff, not_not] at hx\n        rw [hx.2, zero_mul]\n      \u00b7 rw [add_comm, Nat.add_sub_assoc (h_le \u27e8x, hx\u27e9), succ_eq_add_one, add_tsub_cancel_right]\n\n/--\nThe polynomial satisfying the key property of `Polynomial.hilbertPoly p d` is unique.\n-/\ntheorem existsUnique_hilbertPoly (p : F[X]) (d : \u2115) :\n    \u2203! h : F[X], \u2203 N : \u2115, \u2200 n > N,\n    PowerSeries.coeff F n (p * invOneSubPow F d) = h.eval (n : F) := by\n  use hilbertPoly p d; constructor\n  \u00b7 use p.natDegree\n    exact fun n => coeff_mul_invOneSubPow_eq_hilbertPoly_eval d\n  \u00b7 rintro h \u27e8N, hhN\u27e9\n    apply eq_of_infinite_eval_eq h (hilbertPoly p d)\n    apply ((Set.Ioi_infinite (max N p.natDegree)).image cast_injective.injOn).mono\n    rintro x \u27e8n, hn, rfl\u27e9\n    simp only [Set.mem_Ioi, sup_lt_iff, Set.mem_setOf_eq] at hn \u22a2\n    rw [\u2190 coeff_mul_invOneSubPow_eq_hilbertPoly_eval d hn.2, hhN n hn.1]\n\n@[deprecated (since := \"2024-12-17\")] alias exists_unique_hilbertPoly := existsUnique_hilbertPoly\n\n/--\nIf `h : F[X]` and there exists some `N : \u2115` such that for any number `n : \u2115` bigger than `N`\nwe have `PowerSeries.coeff F n (p * invOneSubPow F d) = h.eval (n : F)`, then `h` is exactly\n`Polynomial.hilbertPoly p d`.\n-/\ntheorem eq_hilbertPoly_of_forall_coeff_eq_eval\n    {p h : F[X]} {d : \u2115} (N : \u2115) (hhN : \u2200 n > N,\n    PowerSeries.coeff F n (p * invOneSubPow F d) = h.eval (n : F)) :\n    h = hilbertPoly p d :=\n  ExistsUnique.unique (existsUnique_hilbertPoly p d) \u27e8N, hhN\u27e9\n    \u27e8p.natDegree, fun _ x => coeff_mul_invOneSubPow_eq_hilbertPoly_eval d x\u27e9\n\nlemma hilbertPoly_mul_one_sub_succ (p : F[X]) (d : \u2115) :\n    hilbertPoly (p * (1 - X)) (d + 1) = hilbertPoly p d := by\n  apply eq_hilbertPoly_of_forall_coeff_eq_eval (p * (1 - X)).natDegree\n  intro n hn\n  have heq : 1 - PowerSeries.X = ((1 - X : F[X]) : F\u27e6X\u27e7) := by simp only [coe_sub, coe_one, coe_X]\n  rw [\u2190 one_sub_pow_mul_invOneSubPow_val_add_eq_invOneSubPow_val F d 1, pow_one, \u2190 mul_assoc, heq,\n    \u2190 coe_mul, coeff_mul_invOneSubPow_eq_hilbertPoly_eval (d + 1) hn]\n\nlemma hilbertPoly_mul_one_sub_pow_add (p : F[X]) (d e : \u2115) :\n    hilbertPoly (p * (1 - X) ^ e) (d + e) = hilbertPoly p d := by\n  induction e with\n  | zero => simp\n  | succ e he => rw [pow_add, pow_one, \u2190 mul_assoc, \u2190 add_assoc, hilbertPoly_mul_one_sub_succ, he]\n\n", "theoremStatement": "lemma hilbertPoly_eq_zero_of_le_rootMultiplicity_one\n    {p : F[X]} {d : \u2115} (hdp : d \u2264 p.rootMultiplicity 1) :\n    hilbertPoly p d = 0 ", "theoremName": "Polynomial.hilbertPoly_eq_zero_of_le_rootMultiplicity_one", "fileCreated": {"commit": "561e050467d2caa2e4ea5d81ca62600bf268b747", "date": "2024-12-02"}, "theoremCreated": {"commit": "bd9aea4b2403dcb1ec3998335f71109212ada88e", "date": "2024-12-09"}, "file": "mathlib/Mathlib/RingTheory/Polynomial/HilbertPoly.lean", "module": "Mathlib.RingTheory.Polynomial.HilbertPoly", "jsonFile": "Mathlib.RingTheory.Polynomial.HilbertPoly.jsonl", "positionMetadata": {"lineInFile": 231, "tokenPositionInFile": 10745, "theoremPositionInFile": 16}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 80, "numPremises": 115}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  by_cases hp : p = 0\n  \u00b7 rw [hp, hilbertPoly_zero_left]\n  \u00b7 rcases exists_eq_pow_rootMultiplicity_mul_and_not_dvd p hp 1 with \u27e8q, hq1, hq2\u27e9\n    have heq : p = q * (- 1) ^ p.rootMultiplicity 1 * (1 - X) ^ p.rootMultiplicity 1 := by\n      simp only [mul_assoc, \u2190 mul_pow, neg_mul, one_mul, neg_sub]\n      exact hq1.trans (mul_comm _ _)\n    rw [heq, \u2190 zero_add d, \u2190 Nat.sub_add_cancel hdp, pow_add (1 - X), \u2190 mul_assoc,\n      hilbertPoly_mul_one_sub_pow_add, hilbertPoly]", "proofType": "tactic", "proofLengthLines": 8, "proofLengthTokens": 475}}
{"srcContext": "/-\nCopyright (c) 2017 Johannes H\u00f6lzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes H\u00f6lzl\n-/\nimport Mathlib.Data.Set.Lattice\nimport Mathlib.Data.Set.Pairwise.Basic\n\n/-!\n# Relations holding pairwise\n\nIn this file we prove many facts about `Pairwise` and the set lattice.\n-/\n\n\nopen Function Set Order\n\nvariable {\u03b1 \u03b9 \u03b9' : Type*} {\u03ba : Sort*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nsection Pairwise\n\nvariable {f : \u03b9 \u2192 \u03b1} {s : Set \u03b1}\n\nnamespace Set\n\ntheorem pairwise_iUnion {f : \u03ba \u2192 Set \u03b1} (h : Directed (\u00b7 \u2286 \u00b7) f) :\n    (\u22c3 n, f n).Pairwise r \u2194 \u2200 n, (f n).Pairwise r := by\n  constructor\n  \u00b7 intro H n\n    exact Pairwise.mono (subset_iUnion _ _) H\n  \u00b7 intro H i hi j hj hij\n    rcases mem_iUnion.1 hi with \u27e8m, hm\u27e9\n    rcases mem_iUnion.1 hj with \u27e8n, hn\u27e9\n    rcases h m n with \u27e8p, mp, np\u27e9\n    exact H p (mp hm) (np hn) hij\n\ntheorem pairwise_sUnion {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : Set (Set \u03b1)} (h : DirectedOn (\u00b7 \u2286 \u00b7) s) :\n    (\u22c3\u2080 s).Pairwise r \u2194 \u2200 a \u2208 s, Set.Pairwise a r := by\n  rw [sUnion_eq_iUnion, pairwise_iUnion h.directed_val, SetCoe.forall]\n\nend Set\n\nend Pairwise\n\nnamespace Set\n\nsection PartialOrderBot\n\nvariable [PartialOrder \u03b1] [OrderBot \u03b1] {s : Set \u03b9} {f : \u03b9 \u2192 \u03b1}\n\ntheorem pairwiseDisjoint_iUnion {g : \u03b9' \u2192 Set \u03b9} (h : Directed (\u00b7 \u2286 \u00b7) g) :\n    (\u22c3 n, g n).PairwiseDisjoint f \u2194 \u2200 \u2983n\u2984, (g n).PairwiseDisjoint f :=\n  pairwise_iUnion h\n\ntheorem pairwiseDisjoint_sUnion {s : Set (Set \u03b9)} (h : DirectedOn (\u00b7 \u2286 \u00b7) s) :\n    (\u22c3\u2080 s).PairwiseDisjoint f \u2194 \u2200 \u2983a\u2984, a \u2208 s \u2192 Set.PairwiseDisjoint a f :=\n  pairwise_sUnion h\n\nend PartialOrderBot\n\nsection CompleteLattice\n\nvariable [CompleteLattice \u03b1] {s : Set \u03b9} {t : Set \u03b9'}\n\n/-- Bind operation for `Set.PairwiseDisjoint`. If you want to only consider finsets of indices, you\ncan use `Set.PairwiseDisjoint.biUnion_finset`. -/\ntheorem PairwiseDisjoint.biUnion {s : Set \u03b9'} {g : \u03b9' \u2192 Set \u03b9} {f : \u03b9 \u2192 \u03b1}\n    (hs : s.PairwiseDisjoint fun i' : \u03b9' => \u2a06 i \u2208 g i', f i)\n    (hg : \u2200 i \u2208 s, (g i).PairwiseDisjoint f) : (\u22c3 i \u2208 s, g i).PairwiseDisjoint f := by\n  rintro a ha b hb hab\n  simp_rw [Set.mem_iUnion] at ha hb\n  obtain \u27e8c, hc, ha\u27e9 := ha\n  obtain \u27e8d, hd, hb\u27e9 := hb\n  obtain hcd | hcd := eq_or_ne (g c) (g d)\n  \u00b7 exact hg d hd (hcd \u25b8 ha) hb hab\n  -- Porting note: the elaborator couldn't figure out `f` here.\n  \u00b7 exact (hs hc hd <| ne_of_apply_ne _ hcd).mono\n      (le_iSup\u2082 (f := fun i (_ : i \u2208 g c) => f i) a ha)\n      (le_iSup\u2082 (f := fun i (_ : i \u2208 g d) => f i) b hb)\n\n/-- If the suprema of columns are pairwise disjoint and suprema of rows as well, then everything is\npairwise disjoint. Not to be confused with `Set.PairwiseDisjoint.prod`. -/\ntheorem PairwiseDisjoint.prod_left {f : \u03b9 \u00d7 \u03b9' \u2192 \u03b1}\n    (hs : s.PairwiseDisjoint fun i => \u2a06 i' \u2208 t, f (i, i'))\n    (ht : t.PairwiseDisjoint fun i' => \u2a06 i \u2208 s, f (i, i')) :\n    (s \u00d7\u02e2 t : Set (\u03b9 \u00d7 \u03b9')).PairwiseDisjoint f := by\n  rintro \u27e8i, i'\u27e9 hi \u27e8j, j'\u27e9 hj h\n  rw [mem_prod] at hi hj\n  obtain rfl | hij := eq_or_ne i j\n  \u00b7 refine (ht hi.2 hj.2 <| (Prod.mk.inj_left _).ne_iff.1 h).mono ?_ ?_\n    \u00b7 convert le_iSup\u2082 (\u03b1 := \u03b1) i hi.1; rfl\n    \u00b7 convert le_iSup\u2082 (\u03b1 := \u03b1) i hj.1; rfl\n  \u00b7 refine (hs hi.1 hj.1 hij).mono ?_ ?_\n    \u00b7 convert le_iSup\u2082 (\u03b1 := \u03b1) i' hi.2; rfl\n    \u00b7 convert le_iSup\u2082 (\u03b1 := \u03b1) j' hj.2; rfl\n\nend CompleteLattice\n\nsection Frame\n\nvariable [Frame \u03b1]\n\ntheorem pairwiseDisjoint_prod_left {s : Set \u03b9} {t : Set \u03b9'} {f : \u03b9 \u00d7 \u03b9' \u2192 \u03b1} :\n    (s \u00d7\u02e2 t : Set (\u03b9 \u00d7 \u03b9')).PairwiseDisjoint f \u2194\n      (s.PairwiseDisjoint fun i => \u2a06 i' \u2208 t, f (i, i')) \u2227\n        t.PairwiseDisjoint fun i' => \u2a06 i \u2208 s, f (i, i') := by\n  refine\n      \u27e8fun h => \u27e8fun i hi j hj hij => ?_, fun i hi j hj hij => ?_\u27e9, fun h => h.1.prod_left h.2\u27e9 <;>\n    simp_rw [Function.onFun, iSup_disjoint_iff, disjoint_iSup_iff] <;>\n    intro i' hi' j' hj'\n  \u00b7 exact h (mk_mem_prod hi hi') (mk_mem_prod hj hj') (ne_of_apply_ne Prod.fst hij)\n  \u00b7 exact h (mk_mem_prod hi' hi) (mk_mem_prod hj' hj) (ne_of_apply_ne Prod.snd hij)\n\nend Frame\n\ntheorem biUnion_diff_biUnion_eq {s t : Set \u03b9} {f : \u03b9 \u2192 Set \u03b1} (h : (s \u222a t).PairwiseDisjoint f) :\n    ((\u22c3 i \u2208 s, f i) \\ \u22c3 i \u2208 t, f i) = \u22c3 i \u2208 s \\ t, f i := by\n  refine\n    (biUnion_diff_biUnion_subset f s t).antisymm\n      (iUnion\u2082_subset fun i hi a ha => (mem_diff _).2 \u27e8mem_biUnion hi.1 ha, ?_\u27e9)\n  rw [mem_iUnion\u2082]; rintro \u27e8j, hj, haj\u27e9\n  exact (h (Or.inl hi.1) (Or.inr hj) (ne_of_mem_of_not_mem hj hi.2).symm).le_bot \u27e8ha, haj\u27e9\n\n\n/-- Equivalence between a disjoint bounded union and a dependent sum. -/\nnoncomputable def biUnionEqSigmaOfDisjoint {s : Set \u03b9} {f : \u03b9 \u2192 Set \u03b1} (h : s.PairwiseDisjoint f) :\n    (\u22c3 i \u2208 s, f i) \u2243 \u03a3i : s, f i :=\n  (Equiv.setCongr (biUnion_eq_iUnion _ _)).trans <|\n    unionEqSigmaOfDisjoint fun \u27e8_i, hi\u27e9 \u27e8_j, hj\u27e9 ne => h hi hj fun eq => ne <| Subtype.eq eq\n\nend Set\n\nsection\n\nvariable {f : \u03b9 \u2192 Set \u03b1} {s t : Set \u03b9}\n\nlemma Set.pairwiseDisjoint_iff :\n    s.PairwiseDisjoint f \u2194 \u2200 \u2983i\u2984, i \u2208 s \u2192 \u2200 \u2983j\u2984, j \u2208 s \u2192 (f i \u2229 f j).Nonempty \u2192 i = j := by\n  simp [Set.PairwiseDisjoint, Set.Pairwise, Function.onFun, not_imp_comm (a := _ = _),\n    not_disjoint_iff_nonempty_inter]\n\n", "theoremStatement": "lemma Set.pairwiseDisjoint_pair_insert {s : Set \u03b1} {a : \u03b1} (ha : a \u2209 s) :\n    s.powerset.PairwiseDisjoint fun t \u21a6 ({t, insert a t} : Set (Set \u03b1)) ", "theoremName": "Set.pairwiseDisjoint_pair_insert", "fileCreated": {"commit": "39576edbef1ad1edeb62df39455cec569f88d5ca", "date": "2023-03-27"}, "theoremCreated": {"commit": "914ded280ba36b9fefd047679ff2e7eb562370af", "date": "2025-01-20"}, "file": "mathlib/Mathlib/Data/Set/Pairwise/Lattice.lean", "module": "Mathlib.Data.Set.Pairwise.Lattice", "jsonFile": "Mathlib.Data.Set.Pairwise.Lattice.jsonl", "positionMetadata": {"lineInFile": 141, "tokenPositionInFile": 5004, "theoremPositionInFile": 10}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 32, "numPremises": 73}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [pairwiseDisjoint_iff]\n  rintro i hi j hj\n  have := insert_erase_invOn.2.injOn (not_mem_subset hi ha) (not_mem_subset hj ha)\n  aesop (add simp [Set.Nonempty, Set.subset_def])", "proofType": "tactic", "proofLengthLines": 4, "proofLengthTokens": 185}}
{"srcContext": "/-\nCopyright (c) 2023 Jujian Zhang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jujian Zhang, Junyan Xu\n-/\n\nimport Mathlib.Algebra.Category.ModuleCat.Basic\nimport Mathlib.Algebra.Category.Grp.Injective\nimport Mathlib.Topology.Instances.AddCircle\nimport Mathlib.LinearAlgebra.Isomorphisms\n\n/-!\n# Character module of a module\n\nFor commutative ring `R` and an `R`-module `M` and an injective module `D`, its character module\n`M\u22c6` is defined to be `R`-linear maps `M \u27f6 D`.\n\n`M\u22c6` also has an `R`-module structure given by `(r \u2022 f) m = f (r \u2022 m)`.\n\n## Main results\n\n- `CharacterModuleFunctor` : the contravariant functor of `R`-modules where `M \u21a6 M\u22c6` and\nan `R`-linear map `l : M \u27f6 N` induces an `R`-linear map `l\u22c6 : f \u21a6 f \u2218 l` where `f : N\u22c6`.\n- `LinearMap.dual_surjective_of_injective` : If `l` is injective then `l\u22c6` is surjective,\n  in another word taking character module as a functor sends monos to epis.\n- `CharacterModule.homEquiv` : there is a bijection between linear map `Hom(N, M\u22c6)` and\n  `(N \u2297 M)\u22c6` given by `curry` and `uncurry`.\n\n-/\n\nopen CategoryTheory\n\nuniverse uR uA uB\n\nvariable (R : Type uR) [CommRing R]\nvariable (A : Type uA) [AddCommGroup A]\nvariable (A' : Type*) [AddCommGroup A']\nvariable (B : Type uB) [AddCommGroup B]\n\n/--\nThe character module of an abelian group `A` in the unit rational circle is `A\u22c6 := Hom_\u2124(A, \u211a \u29f8 \u2124)`.\n-/\ndef CharacterModule : Type uA := A \u2192+ AddCircle (1 : \u211a)\n\nnamespace CharacterModule\n\ninstance : FunLike (CharacterModule A) A (AddCircle (1 : \u211a)) where\n  coe c := c.toFun\n  coe_injective' _ _ _ := by aesop\n\ninstance : LinearMapClass (CharacterModule A) \u2124 A (AddCircle (1 : \u211a)) where\n  map_add _ _ _ := by rw [AddMonoidHom.map_add]\n  map_smul\u209b\u2097 _ _ _ := by rw [AddMonoidHom.map_zsmul, RingHom.id_apply]\n\ninstance : AddCommGroup (CharacterModule A) :=\n  inferInstanceAs (AddCommGroup (A \u2192+ _))\n\n@[ext] theorem ext {c c' : CharacterModule A} (h : \u2200 x, c x = c' x) : c = c' := DFunLike.ext _ _ h\n\nsection module\n\nvariable [Module R A] [Module R A'] [Module R B]\n\ninstance : Module R (CharacterModule A) :=\n  Module.compHom (A \u2192+ _) (RingEquiv.toOpposite _ |>.toRingHom : R \u2192+* R\u1d48\u1d50\u1d43)\n\nvariable {R A B}\n\n@[simp] lemma smul_apply (c : CharacterModule A) (r : R) (a : A) : (r \u2022 c) a = c (r \u2022 a) := rfl\n\n/--\nGiven an abelian group homomorphism `f : A \u2192 B`, `f\u22c6(L) := L \u2218 f` defines a linear map\nfrom `B\u22c6` to `A\u22c6`.\n-/\n@[simps] def dual (f : A \u2192\u2097[R] B) : CharacterModule B \u2192\u2097[R] CharacterModule A where\n  toFun L := L.comp f.toAddMonoidHom\n  map_add' := by aesop\n  map_smul' r c := by ext x; exact congr(c $(f.map_smul r x)).symm\n\n@[simp]\nlemma dual_zero : dual (0 : A \u2192\u2097[R] B) = 0 := by\n  ext f\n  exact map_zero f\n\nlemma dual_comp {C : Type*} [AddCommGroup C] [Module R C] (f : A \u2192\u2097[R] B) (g : B \u2192\u2097[R] C) :\n    dual (g.comp f) = (dual f).comp (dual g) := by\n  ext\n  rfl\n\nlemma dual_injective_of_surjective (f : A \u2192\u2097[R] B) (hf : Function.Surjective f) :\n    Function.Injective (dual f) := by\n  intro \u03c6 \u03c8 eq\n  ext x\n  obtain \u27e8y, rfl\u27e9 := hf x\n  change (dual f) \u03c6 _ = (dual f) \u03c8 _\n  rw [eq]\n\nlemma dual_surjective_of_injective (f : A \u2192\u2097[R] B) (hf : Function.Injective f) :\n    Function.Surjective (dual f) :=\n  (Module.Baer.of_divisible _).extension_property_addMonoidHom _ hf\n\n/--\nTwo isomorphic modules have isomorphic character modules.\n-/\ndef congr (e : A \u2243\u2097[R] B) : CharacterModule A \u2243\u2097[R] CharacterModule B :=\n  .ofLinear (dual e.symm) (dual e)\n    (by ext c _; exact congr(c $(e.right_inv _)))\n    (by ext c _; exact congr(c $(e.left_inv _)))\n\nopen TensorProduct\n\n/--\nAny linear map `L : A \u2192 B\u22c6` induces a character in `(A \u2297 B)\u22c6` by `a \u2297 b \u21a6 L a b`.\n-/\n@[simps] noncomputable def uncurry :\n    (A \u2192\u2097[R] CharacterModule B) \u2192\u2097[R] CharacterModule (A \u2297[R] B) where\n  toFun c := TensorProduct.liftAddHom c.toAddMonoidHom fun r a b \u21a6 congr($(c.map_smul r a) b)\n  map_add' c c' := DFunLike.ext _ _ fun x \u21a6 by refine x.induction_on ?_ ?_ ?_ <;> aesop\n  map_smul' r c := DFunLike.ext _ _ fun x \u21a6 x.induction_on\n    (by simp_rw [map_zero]) (fun a b \u21a6 congr($(c.map_smul r a) b).symm) (by aesop)\n\n/--\nAny character `c` in `(A \u2297 B)\u22c6` induces a linear map `A \u2192 B\u22c6` by `a \u21a6 b \u21a6 c (a \u2297 b)`.\n-/\n@[simps] noncomputable def curry :\n    CharacterModule (A \u2297[R] B) \u2192\u2097[R] (A \u2192\u2097[R] CharacterModule B) where\n  toFun c :=\n  { toFun := (c.comp <| TensorProduct.mk R A B \u00b7)\n    map_add' := fun _ _ \u21a6 DFunLike.ext _ _ fun b \u21a6\n      congr(c <| $(map_add (mk R A B) _ _) b).trans (c.map_add _ _)\n    map_smul' := fun r a \u21a6 by ext; exact congr(c $(TensorProduct.tmul_smul _ _ _)).symm }\n  map_add' _ _ := rfl\n  map_smul' r c := by ext; exact congr(c $(TensorProduct.tmul_smul _ _ _)).symm\n\n/--\nLinear maps into a character module are exactly characters of the tensor product.\n-/\n@[simps!] noncomputable def homEquiv :\n    (A \u2192\u2097[R] CharacterModule B) \u2243\u2097[R] CharacterModule (A \u2297[R] B) :=\n  .ofLinear uncurry curry (by ext _ z; refine z.induction_on ?_ ?_ ?_ <;> aesop) (by aesop)\n\ntheorem dual_rTensor_conj_homEquiv (f : A \u2192\u2097[R] A') :\n    homEquiv.symm.toLinearMap \u2218\u2097 dual (f.rTensor B) \u2218\u2097 homEquiv.toLinearMap = f.lcomp R _ := rfl\n\nend module\n\n/--\n`\u2124\u22c6`, the character module of `\u2124` in the unit rational circle.\n-/\nprotected abbrev int : Type := CharacterModule \u2124\n\n/-- Given `n : \u2115`, the map `m \u21a6 m / n`. -/\nprotected abbrev int.divByNat (n : \u2115) : CharacterModule.int :=\n  LinearMap.toSpanSingleton \u2124 _ (QuotientAddGroup.mk (n : \u211a)\u207b\u00b9) |>.toAddMonoidHom\n\nprotected lemma int.divByNat_self (n : \u2115) :\n    int.divByNat n n = 0 := by\n  obtain rfl | h0 := eq_or_ne n 0\n  \u00b7 apply map_zero\n  exact (AddCircle.coe_eq_zero_iff _).mpr\n    \u27e81, by simp [mul_inv_cancel\u2080 (Nat.cast_ne_zero (R := \u211a).mpr h0)]\u27e9\n\nvariable {A}\n\n/-- The `\u2124`-submodule spanned by a single element `a` is isomorphic to the quotient of `\u2124`\nby the ideal generated by the order of `a`. -/\n@[simps!] noncomputable def intSpanEquivQuotAddOrderOf (a : A) :\n    (\u2124 \u2219 a) \u2243\u2097[\u2124] \u2124 \u29f8 Ideal.span {(addOrderOf a : \u2124)} :=\n  LinearEquiv.ofEq _ _ (LinearMap.span_singleton_eq_range \u2124 A a) \u226a\u226b\u2097\n  (LinearMap.quotKerEquivRange <| LinearMap.toSpanSingleton \u2124 A a).symm \u226a\u226b\u2097\n  Submodule.quotEquivOfEq _ _ (by\n    ext1 x\n    rw [Ideal.mem_span_singleton, addOrderOf_dvd_iff_zsmul_eq_zero, LinearMap.mem_ker,\n      LinearMap.toSpanSingleton_apply])\n\nlemma intSpanEquivQuotAddOrderOf_apply_self (a : A) :\n    intSpanEquivQuotAddOrderOf a \u27e8a, Submodule.mem_span_singleton_self a\u27e9 =\n    Submodule.Quotient.mk 1 :=\n  (LinearEquiv.eq_symm_apply _).mp <| Subtype.ext (one_zsmul _).symm\n\n/--\nFor an abelian group `A` and an element `a \u2208 A`, there is a character `c : \u2124 \u2219 a \u2192 \u211a \u29f8 \u2124` given by\n`m \u2022 a \u21a6 m / n` where `n` is the smallest positive integer such that `n \u2022 a = 0` and when such `n`\ndoes not exist, `c` is defined by `m \u2022 a \u21a6 m / 2`.\n-/\nnoncomputable def ofSpanSingleton (a : A) : CharacterModule (\u2124 \u2219 a) :=\n  let l :  \u2124 \u29f8 Ideal.span {(addOrderOf a : \u2124)} \u2192\u2097[\u2124] AddCircle (1 : \u211a) :=\n    Submodule.liftQSpanSingleton _\n      (CharacterModule.int.divByNat <|\n        if addOrderOf a = 0 then 2 else addOrderOf a).toIntLinearMap <| by\n        split_ifs with h\n        \u00b7 rw [h, Nat.cast_zero, map_zero]\n        \u00b7 apply CharacterModule.int.divByNat_self\n  l \u2218\u2097 intSpanEquivQuotAddOrderOf a |>.toAddMonoidHom\n\nlemma eq_zero_of_ofSpanSingleton_apply_self (a : A)\n    (h : ofSpanSingleton a \u27e8a, Submodule.mem_span_singleton_self a\u27e9 = 0) : a = 0 := by\n  erw [ofSpanSingleton, LinearMap.toAddMonoidHom_coe, LinearMap.comp_apply,\n     intSpanEquivQuotAddOrderOf_apply_self, Submodule.liftQSpanSingleton_apply,\n    AddMonoidHom.coe_toIntLinearMap, int.divByNat, LinearMap.toSpanSingleton_one,\n    AddCircle.coe_eq_zero_iff] at h\n  rcases h with \u27e8n, hn\u27e9\n  apply_fun Rat.den at hn\n  rw [zsmul_one, Rat.den_intCast, Rat.inv_natCast_den_of_pos] at hn\n  \u00b7 split_ifs at hn\n    \u00b7 cases hn\n    \u00b7 rwa [eq_comm, AddMonoid.addOrderOf_eq_one_iff] at hn\n  \u00b7 split_ifs with h\n    \u00b7 norm_num\n    \u00b7 exact Nat.pos_of_ne_zero h\n\nlemma exists_character_apply_ne_zero_of_ne_zero {a : A} (ne_zero : a \u2260 0) :\n    \u2203 (c : CharacterModule A), c a \u2260 0 :=\n  have \u27e8c, hc\u27e9 := dual_surjective_of_injective _ (Submodule.injective_subtype _) (ofSpanSingleton a)\n  \u27e8c, fun h \u21a6 ne_zero <| eq_zero_of_ofSpanSingleton_apply_self a <| by rwa [\u2190 hc]\u27e9\n\nlemma eq_zero_of_character_apply {a : A} (h : \u2200 c : CharacterModule A, c a = 0) : a = 0 := by\n  contrapose! h; exact exists_character_apply_ne_zero_of_ne_zero h\n\nvariable [Module R A] [Module R A'] [Module R B] {R A' B}\n\nlemma dual_surjective_iff_injective {f : A \u2192\u2097[R] A'} :\n    Function.Surjective (dual f) \u2194 Function.Injective f :=\n  \u27e8fun h \u21a6 (injective_iff_map_eq_zero _).2 fun a h0 \u21a6 eq_zero_of_character_apply fun c \u21a6 by\n    obtain \u27e8c, rfl\u27e9 := h c; exact congr(c $h0).trans c.map_zero,\n  dual_surjective_of_injective f\u27e9\n\ntheorem _root_.rTensor_injective_iff_lcomp_surjective {f : A \u2192\u2097[R] A'} :\n    Function.Injective (f.rTensor B) \u2194 Function.Surjective (f.lcomp R <| CharacterModule B) := by\n  simp [\u2190 dual_rTensor_conj_homEquiv, dual_surjective_iff_injective]\n\nlemma surjective_of_dual_injective (f : A \u2192\u2097[R] A') (hf : Function.Injective (dual f)) :\n    Function.Surjective f := by\n  rw [\u2190 LinearMap.range_eq_top, \u2190 Submodule.unique_quotient_iff_eq_top]\n  refine \u27e8Unique.mk inferInstance fun a \u21a6 eq_zero_of_character_apply fun c \u21a6 ?_\u27e9\n  obtain \u27e8b, rfl\u27e9 := QuotientAddGroup.mk'_surjective _ a\n  suffices eq : dual (Submodule.mkQ _) c = 0 from congr($eq b)\n  refine hf ?_\n  rw [\u2190 LinearMap.comp_apply, \u2190 dual_comp, LinearMap.range_mkQ_comp, dual_zero]\n  rfl\n\n", "theoremStatement": "lemma dual_injective_iff_surjective {f : A \u2192\u2097[R] A'} :\n    Function.Injective (dual f) \u2194 Function.Surjective f ", "theoremName": "CharacterModule.dual_injective_iff_surjective", "fileCreated": {"commit": "65d37dc6412f280a667037cd83fc1f1423cb14cb", "date": "2024-02-27"}, "theoremCreated": {"commit": "f227e4af164386c81166cdc4e8e263323b586a36", "date": "2025-01-09"}, "file": "mathlib/Mathlib/Algebra/Module/CharacterModule.lean", "module": "Mathlib.Algebra.Module.CharacterModule", "jsonFile": "Mathlib.Algebra.Module.CharacterModule.jsonl", "positionMetadata": {"lineInFile": 242, "tokenPositionInFile": 9463, "theoremPositionInFile": 22}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 6, "repositoryPremises": true, "numRepositoryPremises": 19, "numPremises": 21}, "proofMetadata": {"hasProof": true, "proof": ":=\n  \u27e8fun h \u21a6 surjective_of_dual_injective f h, fun h \u21a6 dual_injective_of_surjective f h\u27e9", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 89}}
{"srcContext": "/-\nCopyright (c) 2024 Xavier Roblot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Xavier Roblot\n-/\nimport Mathlib.Analysis.BoxIntegral.UnitPartition\nimport Mathlib.MeasureTheory.Measure.Haar.InnerProductSpace\n\n/-!\n# Covolume of \u2124-lattices\n\nLet `E` be a finite dimensional real vector space.\n\nLet `L` be a `\u2124`-lattice `L` defined as a discrete `\u2124`-submodule of `E` that spans `E` over `\u211d`.\n\n## Main definitions and results\n\n* `ZLattice.covolume`: the covolume of `L` defined as the volume of an arbitrary fundamental\ndomain of `L`.\n\n* `ZLattice.covolume_eq_measure_fundamentalDomain`: the covolume of `L` does not depend on the\nchoice of the fundamental domain of `L`.\n\n* `ZLattice.covolume_eq_det`: if `L` is a lattice in `\u211d^n`, then its covolume is the absolute\nvalue of the determinant of any `\u2124`-basis of `L`.\n\n* `ZLattice.covolume.tendsto_card_div_pow`: Let `s` be a bounded measurable set of `\u03b9 \u2192 \u211d`, then\nthe number of points in `s \u2229 n\u207b\u00b9 \u2022 L` divided by `n ^ card \u03b9` tends to `volume s / covolume L`\nwhen `n : \u2115` tends to infinity. See also `ZLattice.covolume.tendsto_card_div_pow'` for a version\nfor `InnerProductSpace \u211d E` and `ZLattice.covolume.tendsto_card_div_pow''` for the general version.\n\n* `ZLattice.covolume.tendsto_card_le_div`: Let `X` be a cone in `\u03b9 \u2192 \u211d` and let `F : (\u03b9 \u2192 \u211d) \u2192 \u211d`\nbe a function such that `F (c \u2022 x) = c ^ card \u03b9 * F x`. Then the number of points `x \u2208 X` such that\n`F x \u2264 c` divided by `c` tends to `volume {x \u2208 X | F x \u2264 1} / covolume L` when `c : \u211d` tends to\ninfinity. See also `ZLattice.covolume.tendsto_card_le_div'` for a version for\n`InnerProductSpace \u211d E` and `ZLattice.covolume.tendsto_card_le_div''` for the general version.\n\n## Naming convention\n\nSome results are true in the case where the ambient finite dimensional real vector space is the\npi-space `\u03b9 \u2192 \u211d` and in the case where it is an `InnerProductSpace`. We use the following\nconvention: the plain name is for the pi case, for eg. `volume_image_eq_volume_div_covolume`. For\nthe same result in the `InnerProductSpace` case, we add a `prime`, for eg.\n`volume_image_eq_volume_div_covolume'`. When the same result exists in the\ngeneral case, we had two primes, eg. `covolume.tendsto_card_div_pow''`.\n\n-/\n\nnoncomputable section\n\nnamespace ZLattice\n\nopen Submodule MeasureTheory Module MeasureTheory Module ZSpan\n\nsection General\n\nvariable {E : Type*} [NormedAddCommGroup E] [MeasurableSpace E] (L : Submodule \u2124 E)\n\n/-- The covolume of a `\u2124`-lattice is the volume of some fundamental domain; see\n`ZLattice.covolume_eq_volume` for the proof that the volume does not depend on the choice of\nthe fundamental domain. -/\ndef covolume (\u03bc : Measure E := by volume_tac) : \u211d := (addCovolume L E \u03bc).toReal\n\nend General\n\nsection Basic\n\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] [FiniteDimensional \u211d E]\nvariable [MeasurableSpace E] [BorelSpace E]\nvariable (L : Submodule \u2124 E) [DiscreteTopology L] [IsZLattice \u211d L]\nvariable (\u03bc : Measure E := by volume_tac) [Measure.IsAddHaarMeasure \u03bc]\n\ntheorem covolume_eq_measure_fundamentalDomain {F : Set E} (h : IsAddFundamentalDomain L F \u03bc) :\n    covolume L \u03bc = (\u03bc F).toReal := by\n  have : MeasurableVAdd L E := (inferInstance : MeasurableVAdd L.toAddSubgroup E)\n  have : VAddInvariantMeasure L E \u03bc := (inferInstance : VAddInvariantMeasure L.toAddSubgroup E \u03bc)\n  exact congr_arg ENNReal.toReal (h.covolume_eq_volume \u03bc)\n\ntheorem covolume_ne_zero : covolume L \u03bc \u2260 0 := by\n  rw [covolume_eq_measure_fundamentalDomain L \u03bc (isAddFundamentalDomain (Free.chooseBasis \u2124 L) \u03bc),\n    ENNReal.toReal_ne_zero]\n  refine \u27e8measure_fundamentalDomain_ne_zero _, ne_of_lt ?_\u27e9\n  exact Bornology.IsBounded.measure_lt_top (fundamentalDomain_isBounded _)\n\ntheorem covolume_pos : 0 < covolume L \u03bc :=\n  lt_of_le_of_ne ENNReal.toReal_nonneg (covolume_ne_zero L \u03bc).symm\n\ntheorem covolume_comap {F : Type*} [NormedAddCommGroup F] [NormedSpace \u211d F] [FiniteDimensional \u211d F]\n    [MeasurableSpace F] [BorelSpace F] (\u03bd : Measure F := by volume_tac) [Measure.IsAddHaarMeasure \u03bd]\n    {e : F \u2243L[\u211d] E} (he : MeasurePreserving e \u03bd \u03bc) :\n    covolume (ZLattice.comap \u211d L e.toLinearMap) \u03bd = covolume L \u03bc := by\n  rw [covolume_eq_measure_fundamentalDomain _ _ (isAddFundamentalDomain (Free.chooseBasis \u2124 L) \u03bc),\n    covolume_eq_measure_fundamentalDomain _ _ ((isAddFundamentalDomain\n    ((Free.chooseBasis \u2124 L).ofZLatticeComap \u211d L e.toLinearEquiv) \u03bd)), \u2190 he.measure_preimage\n    (fundamentalDomain_measurableSet _).nullMeasurableSet, \u2190 e.image_symm_eq_preimage,\n    \u2190 e.symm.coe_toLinearEquiv, map_fundamentalDomain]\n  congr!\n  ext; simp\n\ntheorem covolume_eq_det_mul_measure {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (b : Basis \u03b9 \u2124 L)\n    (b\u2080 : Basis \u03b9 \u211d E) :\n    covolume L \u03bc = |b\u2080.det ((\u2191) \u2218 b)| * (\u03bc (fundamentalDomain b\u2080)).toReal := by\n  rw [covolume_eq_measure_fundamentalDomain L \u03bc (isAddFundamentalDomain b \u03bc),\n    measure_fundamentalDomain _ _ b\u2080,\n    measure_congr (fundamentalDomain_ae_parallelepiped b\u2080 \u03bc), ENNReal.toReal_mul,\n    ENNReal.toReal_ofReal (by positivity)]\n  congr\n  ext\n  exact b.ofZLatticeBasis_apply \u211d L _\n\ntheorem covolume_eq_det {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (L : Submodule \u2124 (\u03b9 \u2192 \u211d))\n    [DiscreteTopology L] [IsZLattice \u211d L] (b : Basis \u03b9 \u2124 L) :\n    covolume L = |(Matrix.of ((\u2191) \u2218 b)).det| := by\n  rw [covolume_eq_measure_fundamentalDomain L volume (isAddFundamentalDomain b volume),\n    volume_fundamentalDomain, ENNReal.toReal_ofReal (by positivity)]\n  congr\n  ext1\n  exact b.ofZLatticeBasis_apply \u211d L _\n\ntheorem covolume_eq_det_inv {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (L : Submodule \u2124 (\u03b9 \u2192 \u211d))\n    [DiscreteTopology L] [IsZLattice \u211d L] (b : Basis \u03b9 \u2124 L) :\n    covolume L = |(LinearEquiv.det (b.ofZLatticeBasis \u211d L).equivFun : \u211d)|\u207b\u00b9 := by\n  rw [covolume_eq_det L b, \u2190 Pi.basisFun_det_apply, show (((\u2191) : L \u2192 _) \u2218 \u21d1b) =\n    (b.ofZLatticeBasis \u211d) by ext; simp, \u2190 Basis.det_inv, \u2190 abs_inv, Units.val_inv_eq_inv_val,\n    IsUnit.unit_spec, \u2190 Basis.det_basis, LinearEquiv.coe_det]\n  rfl\n\ntheorem volume_image_eq_volume_div_covolume {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9]\n    (L : Submodule \u2124 (\u03b9 \u2192 \u211d)) [DiscreteTopology L] [IsZLattice \u211d L] (b : Basis \u03b9 \u2124 L)\n    {s : Set (\u03b9 \u2192 \u211d)} :\n    volume ((b.ofZLatticeBasis \u211d L).equivFun '' s) = volume s / ENNReal.ofReal (covolume L) := by\n  rw [LinearEquiv.image_eq_preimage, Measure.addHaar_preimage_linearEquiv, LinearEquiv.symm_symm,\n    covolume_eq_det_inv L b, ENNReal.div_eq_inv_mul, ENNReal.ofReal_inv_of_pos\n    (abs_pos.mpr (LinearEquiv.det _).ne_zero), inv_inv, LinearEquiv.coe_det]\n\n/-- A more general version of `ZLattice.volume_image_eq_volume_div_covolume`;\nsee the `Naming conventions` section in the introduction. -/\ntheorem volume_image_eq_volume_div_covolume' {E : Type*} [NormedAddCommGroup E]\n    [InnerProductSpace \u211d E] [FiniteDimensional \u211d E] [MeasurableSpace E] [BorelSpace E]\n    (L : Submodule \u2124 E) [DiscreteTopology L] [IsZLattice \u211d L] {\u03b9 : Type*} [Fintype \u03b9]\n    (b : Basis \u03b9 \u2124 L) {s : Set E} (hs : NullMeasurableSet s) :\n    volume ((b.ofZLatticeBasis \u211d).equivFun '' s) = volume s / ENNReal.ofReal (covolume L) := by\n  classical\n  let e : Fin (finrank \u211d E) \u2243 \u03b9 :=\n    Fintype.equivOfCardEq (by rw [Fintype.card_fin, finrank_eq_card_basis (b.ofZLatticeBasis \u211d)])\n  let f := (EuclideanSpace.equiv \u03b9 \u211d).symm.trans\n    ((stdOrthonormalBasis \u211d E).reindex e).repr.toContinuousLinearEquiv.symm\n  have hf : MeasurePreserving f :=\n    ((stdOrthonormalBasis \u211d E).reindex e).measurePreserving_repr_symm.comp\n      (EuclideanSpace.volume_preserving_measurableEquiv \u03b9).symm\n  rw [\u2190 hf.measure_preimage hs, \u2190 (covolume_comap L volume volume hf),\n    \u2190 volume_image_eq_volume_div_covolume (ZLattice.comap \u211d L f.toLinearMap)\n    (b.ofZLatticeComap \u211d L f.toLinearEquiv), Basis.ofZLatticeBasis_comap,\n    \u2190 f.image_symm_eq_preimage, \u2190 Set.image_comp]\n  simp only [Basis.equivFun_apply, ContinuousLinearEquiv.symm_toLinearEquiv, Basis.map_equivFun,\n    LinearEquiv.symm_symm, Function.comp_apply, LinearEquiv.trans_apply,\n    ContinuousLinearEquiv.coe_toLinearEquiv, ContinuousLinearEquiv.apply_symm_apply]\n\nend Basic\n\nnamespace covolume\n\nsection General\n\nopen Filter Fintype Pointwise Topology BoxIntegral Bornology\n\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]\nvariable {L : Submodule \u2124 E} [DiscreteTopology L] [IsZLattice \u211d L]\nvariable {\u03b9 : Type*} [Fintype \u03b9] (b : Basis \u03b9 \u2124 L)\n\n/-- A version of `ZLattice.covolume.tendsto_card_div_pow` for the general case;\nsee the `Naming convention` section in the introduction. -/\ntheorem tendsto_card_div_pow'' [FiniteDimensional \u211d E] [MeasurableSpace E] [BorelSpace E]\n    {s : Set E} (hs\u2081 : IsBounded s) (hs\u2082 : MeasurableSet s)\n    (hs\u2083 : volume (frontier ((b.ofZLatticeBasis \u211d).equivFun '' s)) = 0):\n    Tendsto (fun n : \u2115 \u21a6 (Nat.card (s \u2229 (n : \u211d)\u207b\u00b9 \u2022 L : Set E) : \u211d) / n ^ card \u03b9)\n      atTop (\ud835\udcdd (volume ((b.ofZLatticeBasis \u211d).equivFun '' s)).toReal) := by\n  refine Tendsto.congr' ?_\n    (tendsto_card_div_pow_atTop_volume ((b.ofZLatticeBasis \u211d).equivFun '' s) ?_ ?_ hs\u2083)\n  \u00b7 filter_upwards [eventually_gt_atTop 0] with n hn\n    congr\n    refine Nat.card_congr <| ((b.ofZLatticeBasis \u211d).equivFun.toEquiv.subtypeEquiv fun x \u21a6 ?_).symm\n    simp_rw [Set.mem_inter_iff, \u2190 b.ofZLatticeBasis_span \u211d, LinearEquiv.coe_toEquiv,\n      Basis.equivFun_apply, Set.mem_image, DFunLike.coe_fn_eq, EmbeddingLike.apply_eq_iff_eq,\n      exists_eq_right, and_congr_right_iff, Set.mem_inv_smul_set_iff\u2080\n      (mod_cast hn.ne' : (n : \u211d) \u2260 0), \u2190 Finsupp.coe_smul, \u2190 LinearEquiv.map_smul, SetLike.mem_coe,\n      Basis.mem_span_iff_repr_mem, Pi.basisFun_repr, implies_true]\n  \u00b7 rw [\u2190 NormedSpace.isVonNBounded_iff \u211d] at hs\u2081 \u22a2\n    exact Bornology.IsVonNBounded.image hs\u2081 ((b.ofZLatticeBasis \u211d).equivFunL : E \u2192L[\u211d] \u03b9 \u2192 \u211d)\n  \u00b7 exact (b.ofZLatticeBasis \u211d).equivFunL.toHomeomorph.toMeasurableEquiv.measurableSet_image.mpr hs\u2082\n\nprivate theorem tendsto_card_le_div''_aux {X : Set E} (hX : \u2200 \u2983x\u2984 \u2983r:\u211d\u2984, x \u2208 X \u2192 0 < r \u2192 r \u2022 x \u2208 X)\n    {F : E \u2192 \u211d} (hF\u2081 : \u2200 x \u2983r : \u211d\u2984, 0 \u2264 r \u2192 F (r \u2022 x) = r ^ card \u03b9 * (F x)) {c : \u211d} (hc : 0 < c) :\n    c \u2022 {x \u2208 X | F x \u2264 1} = {x \u2208 X | F x \u2264 c ^ card \u03b9} := by\n  ext x\n  simp_rw [Set.mem_smul_set_iff_inv_smul_mem\u2080 hc.ne', Set.mem_setOf_eq, hF\u2081 _\n    (inv_pos_of_pos hc).le, inv_pow, inv_mul_le_iff\u2080 (pow_pos hc _), mul_one, and_congr_left_iff]\n  exact fun _ \u21a6 \u27e8fun h \u21a6 (smul_inv_smul\u2080 hc.ne' x) \u25b8 hX h hc, fun h \u21a6 hX h (inv_pos_of_pos hc)\u27e9\n\n/-- A version of `ZLattice.covolume.tendsto_card_le_div` for the general case;\nsee the `Naming conventions` section in the introduction. -/\ntheorem tendsto_card_le_div'' [FiniteDimensional \u211d E] [MeasurableSpace E] [BorelSpace E]\n    [Nonempty \u03b9] {X : Set E} (hX : \u2200 \u2983x\u2984 \u2983r : \u211d\u2984, x \u2208 X \u2192 0 < r \u2192 r \u2022 x \u2208 X)\n    {F : E \u2192 \u211d} (h\u2081 : \u2200 x \u2983r : \u211d\u2984, 0 \u2264 r \u2192  F (r \u2022 x) = r ^ card \u03b9 * (F x))\n    (h\u2082 : IsBounded {x \u2208 X | F x \u2264 1}) (h\u2083 : MeasurableSet {x \u2208 X | F x \u2264 1})\n    (h\u2084 : volume (frontier ((b.ofZLatticeBasis \u211d L).equivFun '' {x | x \u2208 X \u2227 F x \u2264 1})) = 0) :\n    Tendsto (fun c : \u211d \u21a6\n      Nat.card ({x \u2208 X | F x \u2264 c} \u2229 L : Set E) / (c : \u211d))\n        atTop (\ud835\udcdd (volume ((b.ofZLatticeBasis \u211d).equivFun '' {x \u2208 X | F x \u2264 1})).toReal) := by\n\n  refine Tendsto.congr' ?_ <| (tendsto_card_div_pow_atTop_volume'\n      ((b.ofZLatticeBasis \u211d).equivFun '' {x \u2208 X | F x \u2264 1}) ?_ ?_ h\u2084 fun x y hx hy \u21a6 ?_).comp\n        (tendsto_rpow_atTop <| inv_pos.mpr\n          (Nat.cast_pos.mpr card_pos) : Tendsto (fun x \u21a6 x ^ (card \u03b9 : \u211d)\u207b\u00b9) atTop atTop)\n  \u00b7 filter_upwards [eventually_gt_atTop 0] with c hc\n    have aux\u2081 : (card \u03b9 : \u211d) \u2260 0 := Nat.cast_ne_zero.mpr card_ne_zero\n    have aux\u2082 : 0 < c ^ (card \u03b9 : \u211d)\u207b\u00b9 := Real.rpow_pos_of_pos hc _\n    have aux\u2083 : (c ^ (card \u03b9 : \u211d)\u207b\u00b9)\u207b\u00b9 \u2260 0 := inv_ne_zero aux\u2082.ne'\n    have aux\u2084 : c ^ (-(card \u03b9 : \u211d)\u207b\u00b9) \u2260 0 := (Real.rpow_pos_of_pos hc _).ne'\n    obtain \u27e8hc\u2081, hc\u2082\u27e9 := lt_iff_le_and_ne.mp hc\n    rw [Function.comp_apply, \u2190 Real.rpow_natCast, Real.rpow_inv_rpow hc\u2081 aux\u2081, eq_comm]\n    congr\n    refine Nat.card_congr <| Equiv.subtypeEquiv ((b.ofZLatticeBasis \u211d).equivFun.toEquiv.trans\n          (Equiv.smulRight aux\u2084)) fun _ \u21a6 ?_\n    rw [Set.mem_inter_iff, Set.mem_inter_iff, Equiv.trans_apply, LinearEquiv.coe_toEquiv,\n      Equiv.smulRight_apply, Real.rpow_neg hc\u2081, Set.smul_mem_smul_set_iff\u2080 aux\u2083,\n      \u2190 Set.mem_smul_set_iff_inv_smul_mem\u2080 aux\u2082.ne', \u2190 image_smul_set,\n      tendsto_card_le_div''_aux hX h\u2081 aux\u2082, \u2190 Real.rpow_natCast, \u2190 Real.rpow_mul hc\u2081,\n      inv_mul_cancel\u2080 aux\u2081, Real.rpow_one]\n    simp_rw [SetLike.mem_coe, Set.mem_image, EmbeddingLike.apply_eq_iff_eq, exists_eq_right,\n      and_congr_right_iff, \u2190 b.ofZLatticeBasis_span \u211d, Basis.mem_span_iff_repr_mem,\n      Pi.basisFun_repr, Basis.equivFun_apply, implies_true]\n  \u00b7 rw [\u2190 NormedSpace.isVonNBounded_iff \u211d] at h\u2082 \u22a2\n    exact Bornology.IsVonNBounded.image h\u2082 ((b.ofZLatticeBasis \u211d).equivFunL : E \u2192L[\u211d] \u03b9 \u2192 \u211d)\n  \u00b7 exact (b.ofZLatticeBasis \u211d).equivFunL.toHomeomorph.toMeasurableEquiv.measurableSet_image.mpr h\u2083\n  \u00b7 simp_rw [\u2190 image_smul_set]\n    apply Set.image_mono\n    rw [tendsto_card_le_div''_aux hX h\u2081 hx,\n      tendsto_card_le_div''_aux hX h\u2081 (lt_of_lt_of_le hx hy)]\n    exact fun a \u27e8ha\u2081, ha\u2082\u27e9 \u21a6 \u27e8ha\u2081, le_trans ha\u2082 <| pow_le_pow_left\u2080 (le_of_lt hx) hy _\u27e9\n\nend General\n\nsection Pi\n\nopen Filter Fintype Pointwise Topology Bornology\n\nprivate theorem frontier_equivFun {E : Type*} [AddCommGroup E] [Module \u211d E] {\u03b9 : Type*} [Fintype \u03b9]\n    [TopologicalSpace E] [TopologicalAddGroup E] [ContinuousSMul \u211d E] [T2Space E]\n    (b : Basis \u03b9 \u211d E) (s : Set E) :\n    frontier (b.equivFun '' s) = b.equivFun '' (frontier s) := by\n  rw [LinearEquiv.image_eq_preimage, LinearEquiv.image_eq_preimage]\n  exact (Homeomorph.preimage_frontier b.equivFunL.toHomeomorph.symm s).symm\n\nvariable {\u03b9 : Type*} [Fintype \u03b9]\nvariable (L : Submodule \u2124 (\u03b9 \u2192 \u211d)) [DiscreteTopology L] [IsZLattice \u211d L]\n\ntheorem tendsto_card_div_pow (b : Basis \u03b9 \u2124 L) {s : Set (\u03b9 \u2192 \u211d)} (hs\u2081 : IsBounded s)\n    (hs\u2082 : MeasurableSet s) (hs\u2083 : volume (frontier s) = 0) :\n    Tendsto (fun n : \u2115 \u21a6 (Nat.card (s \u2229 (n : \u211d)\u207b\u00b9 \u2022 L : Set (\u03b9 \u2192 \u211d)) : \u211d) / n ^ card \u03b9)\n      atTop (\ud835\udcdd ((volume s).toReal / covolume L)) := by\n  classical\n  convert tendsto_card_div_pow'' b hs\u2081 hs\u2082 ?_\n  \u00b7 rw [volume_image_eq_volume_div_covolume L b, ENNReal.toReal_div,\n      ENNReal.toReal_ofReal (covolume_pos L volume).le]\n  \u00b7 rw [frontier_equivFun, volume_image_eq_volume_div_covolume, hs\u2083, ENNReal.zero_div]\n\n", "theoremStatement": "theorem tendsto_card_le_div {X : Set (\u03b9 \u2192 \u211d)} (hX : \u2200 \u2983x\u2984 \u2983r : \u211d\u2984, x \u2208 X \u2192 0 < r \u2192 r \u2022 x \u2208 X)\n    {F : (\u03b9 \u2192 \u211d) \u2192 \u211d} (h\u2081 : \u2200 x \u2983r : \u211d\u2984, 0 \u2264 r \u2192  F (r \u2022 x) = r ^ card \u03b9 * (F x))\n    (h\u2082 : IsBounded {x \u2208 X | F x \u2264 1}) (h\u2083 : MeasurableSet {x \u2208 X | F x \u2264 1})\n    (h\u2084 : volume (frontier {x | x \u2208 X \u2227 F x \u2264 1}) = 0) [Nonempty \u03b9] :\n    Tendsto (fun c : \u211d \u21a6\n      Nat.card ({x \u2208 X | F x \u2264 c} \u2229 L : Set (\u03b9 \u2192 \u211d)) / (c : \u211d))\n        atTop (\ud835\udcdd ((volume {x \u2208 X | F x \u2264 1}).toReal / covolume L)) ", "theoremName": "ZLattice.covolume.tendsto_card_le_div", "fileCreated": {"commit": "85d6c78ac5782869d041c2ca6d3ca83cdde412c3", "date": "2024-09-09"}, "theoremCreated": {"commit": "211dc533566a173988a01067bb50d7917a097103", "date": "2024-12-18"}, "file": "mathlib/Mathlib/Algebra/Module/ZLattice/Covolume.lean", "module": "Mathlib.Algebra.Module.ZLattice.Covolume", "jsonFile": "Mathlib.Algebra.Module.ZLattice.Covolume.jsonl", "positionMetadata": {"lineInFile": 268, "tokenPositionInFile": 14265, "theoremPositionInFile": 15}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 174, "numPremises": 205}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  classical\n  let e : Free.ChooseBasisIndex \u2124 \u21a5L \u2243 \u03b9 := by\n    refine Fintype.equivOfCardEq ?_\n    rw [\u2190 finrank_eq_card_chooseBasisIndex, ZLattice.rank \u211d, finrank_fintype_fun_eq_card]\n  let b := (Module.Free.chooseBasis \u2124 L).reindex e\n  convert tendsto_card_le_div'' b hX h\u2081 h\u2082 h\u2083 ?_\n  \u00b7 rw [volume_image_eq_volume_div_covolume L b, ENNReal.toReal_div,\n      ENNReal.toReal_ofReal (covolume_pos L volume).le]\n  \u00b7 rw [frontier_equivFun, volume_image_eq_volume_div_covolume, h\u2084, ENNReal.zero_div]", "proofType": "tactic", "proofLengthLines": 9, "proofLengthTokens": 501}}
{"srcContext": "/-\nCopyright (c) 2020 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kevin Buzzard, Johan Commelin, Patrick Massot\n-/\nimport Mathlib.Algebra.Order.Hom.Monoid\nimport Mathlib.Algebra.Order.Ring.Basic\nimport Mathlib.RingTheory.Ideal.Maps\nimport Mathlib.Tactic.TFAE\n\n/-!\n\n# The basics of valuation theory.\n\nThe basic theory of valuations (non-archimedean norms) on a commutative ring,\nfollowing T. Wedhorn's unpublished notes \u201cAdic Spaces\u201d ([wedhorn_adic]).\n\nThe definition of a valuation we use here is Definition 1.22 of [wedhorn_adic].\nA valuation on a ring `R` is a monoid homomorphism `v` to a linearly ordered\ncommutative monoid with zero, that in addition satisfies the following two axioms:\n * `v 0 = 0`\n * `\u2200 x y, v (x + y) \u2264 max (v x) (v y)`\n\n`Valuation R \u0393\u2080`is the type of valuations `R \u2192 \u0393\u2080`, with a coercion to the underlying\nfunction. If `v` is a valuation from `R` to `\u0393\u2080` then the induced group\nhomomorphism `Units(R) \u2192 \u0393\u2080` is called `unit_map v`.\n\nThe equivalence \"relation\" `IsEquiv v\u2081 v\u2082 : Prop` defined in 1.27 of [wedhorn_adic] is not strictly\nspeaking a relation, because `v\u2081 : Valuation R \u0393\u2081` and `v\u2082 : Valuation R \u0393\u2082` might\nnot have the same type. This corresponds in ZFC to the set-theoretic difficulty\nthat the class of all valuations (as `\u0393\u2080` varies) on a ring `R` is not a set.\nThe \"relation\" is however reflexive, symmetric and transitive in the obvious\nsense. Note that we use 1.27(iii) of [wedhorn_adic] as the definition of equivalence.\n\n## Main definitions\n\n* `Valuation R \u0393\u2080`, the type of valuations on `R` with values in `\u0393\u2080`\n* `Valuation.IsEquiv`, the heterogeneous equivalence relation on valuations\n* `Valuation.supp`, the support of a valuation\n\n* `AddValuation R \u0393\u2080`, the type of additive valuations on `R` with values in a\n  linearly ordered additive commutative group with a top element, `\u0393\u2080`.\n\n## Implementation Details\n\n`AddValuation R \u0393\u2080` is implemented as `Valuation R (Multiplicative \u0393\u2080)\u1d52\u1d48`.\n\n## Notation\n\nIn the `DiscreteValuation` locale:\n\n * `\u2115\u2098\u2080` is a shorthand for `WithZero (Multiplicative \u2115)`\n * `\u2124\u2098\u2080` is a shorthand for `WithZero (Multiplicative \u2124)`\n\n## TODO\n\nIf ever someone extends `Valuation`, we should fully comply to the `DFunLike` by migrating the\nboilerplate lemmas to `ValuationClass`.\n-/\n\nopen Function Ideal\n\nnoncomputable section\n\nvariable {K F R : Type*} [DivisionRing K]\n\nsection\n\nvariable (F R) (\u0393\u2080 : Type*) [LinearOrderedCommMonoidWithZero \u0393\u2080] [Ring R]\n\n/-- The type of `\u0393\u2080`-valued valuations on `R`.\n\nWhen you extend this structure, make sure to extend `ValuationClass`. -/\nstructure Valuation extends R \u2192*\u2080 \u0393\u2080 where\n  /-- The valuation of a a sum is less that the sum of the valuations -/\n  map_add_le_max' : \u2200 x y, toFun (x + y) \u2264 max (toFun x) (toFun y)\n\n/-- `ValuationClass F \u03b1 \u03b2` states that `F` is a type of valuations.\n\nYou should also extend this typeclass when you extend `Valuation`. -/\nclass ValuationClass (F) (R \u0393\u2080 : outParam Type*) [LinearOrderedCommMonoidWithZero \u0393\u2080] [Ring R]\n  [FunLike F R \u0393\u2080]\n  extends MonoidWithZeroHomClass F R \u0393\u2080 : Prop where\n  /-- The valuation of a a sum is less that the sum of the valuations -/\n  map_add_le_max (f : F) (x y : R) : f (x + y) \u2264 max (f x) (f y)\n\nexport ValuationClass (map_add_le_max)\n\ninstance [FunLike F R \u0393\u2080] [ValuationClass F R \u0393\u2080] : CoeTC F (Valuation R \u0393\u2080) :=\n  \u27e8fun f =>\n    { toFun := f\n      map_one' := map_one f\n      map_zero' := map_zero f\n      map_mul' := map_mul f\n      map_add_le_max' := map_add_le_max f }\u27e9\n\nend\n\nnamespace Valuation\n\nvariable {\u0393\u2080 : Type*}\nvariable {\u0393'\u2080 : Type*}\nvariable {\u0393''\u2080 : Type*} [LinearOrderedCommMonoidWithZero \u0393''\u2080]\n\nsection Basic\n\nvariable [Ring R]\n\nsection Monoid\n\nvariable [LinearOrderedCommMonoidWithZero \u0393\u2080] [LinearOrderedCommMonoidWithZero \u0393'\u2080]\n\ninstance : FunLike (Valuation R \u0393\u2080) R \u0393\u2080 where\n  coe f := f.toFun\n  coe_injective' f g h := by\n    obtain \u27e8\u27e8\u27e8_,_\u27e9, _\u27e9, _\u27e9 := f\n    congr\n\ninstance : ValuationClass (Valuation R \u0393\u2080) R \u0393\u2080 where\n  map_mul f := f.map_mul'\n  map_one f := f.map_one'\n  map_zero f := f.map_zero'\n  map_add_le_max f := f.map_add_le_max'\n\n@[simp]\ntheorem coe_mk (f : R \u2192*\u2080 \u0393\u2080) (h) : \u21d1(Valuation.mk f h) = f := rfl\n\ntheorem toFun_eq_coe (v : Valuation R \u0393\u2080) : v.toFun = v := rfl\n\n@[simp]\ntheorem toMonoidWithZeroHom_coe_eq_coe (v : Valuation R \u0393\u2080) :\n    (v.toMonoidWithZeroHom : R \u2192 \u0393\u2080) = v := rfl\n\n@[ext]\ntheorem ext {v\u2081 v\u2082 : Valuation R \u0393\u2080} (h : \u2200 r, v\u2081 r = v\u2082 r) : v\u2081 = v\u2082 :=\n  DFunLike.ext _ _ h\n\nvariable (v : Valuation R \u0393\u2080)\n\n@[simp, norm_cast]\ntheorem coe_coe : \u21d1(v : R \u2192*\u2080 \u0393\u2080) = v := rfl\n\ntheorem map_zero : v 0 = 0 :=\n  v.map_zero'\n\ntheorem map_one : v 1 = 1 :=\n  v.map_one'\n\ntheorem map_mul : \u2200 x y, v (x * y) = v x * v y :=\n  v.map_mul'\n\n-- Porting note: LHS side simplified so created map_add'\ntheorem map_add : \u2200 x y, v (x + y) \u2264 max (v x) (v y) :=\n  v.map_add_le_max'\n\n@[simp]\ntheorem map_add' : \u2200 x y, v (x + y) \u2264 v x \u2228 v (x + y) \u2264 v y := by\n  intro x y\n  rw [\u2190 le_max_iff, \u2190 ge_iff_le]\n  apply map_add\n\ntheorem map_add_le {x y g} (hx : v x \u2264 g) (hy : v y \u2264 g) : v (x + y) \u2264 g :=\n  le_trans (v.map_add x y) <| max_le hx hy\n\ntheorem map_add_lt {x y g} (hx : v x < g) (hy : v y < g) : v (x + y) < g :=\n  lt_of_le_of_lt (v.map_add x y) <| max_lt hx hy\n\ntheorem map_sum_le {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hf : \u2200 i \u2208 s, v (f i) \u2264 g) :\n    v (\u2211 i \u2208 s, f i) \u2264 g := by\n  classical\n  refine\n    Finset.induction_on s (fun _ => v.map_zero \u25b8 zero_le')\n      (fun a s has ih hf => ?_) hf\n  rw [Finset.forall_mem_insert] at hf; rw [Finset.sum_insert has]\n  exact v.map_add_le hf.1 (ih hf.2)\n\ntheorem map_sum_lt {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hg : g \u2260 0)\n    (hf : \u2200 i \u2208 s, v (f i) < g) : v (\u2211 i \u2208 s, f i) < g := by\n  classical\n  refine\n    Finset.induction_on s (fun _ => v.map_zero \u25b8 (zero_lt_iff.2 hg))\n      (fun a s has ih hf => ?_) hf\n  rw [Finset.forall_mem_insert] at hf; rw [Finset.sum_insert has]\n  exact v.map_add_lt hf.1 (ih hf.2)\n\ntheorem map_sum_lt' {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hg : 0 < g)\n    (hf : \u2200 i \u2208 s, v (f i) < g) : v (\u2211 i \u2208 s, f i) < g :=\n  v.map_sum_lt (ne_of_gt hg) hf\n\ntheorem map_pow : \u2200 (x) (n : \u2115), v (x ^ n) = v x ^ n :=\n  v.toMonoidWithZeroHom.toMonoidHom.map_pow\n\n-- The following definition is not an instance, because we have more than one `v` on a given `R`.\n-- In addition, type class inference would not be able to infer `v`.\n/-- A valuation gives a preorder on the underlying ring. -/\ndef toPreorder : Preorder R :=\n  Preorder.lift v\n\n/-- If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. -/\ntheorem zero_iff [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) {x : K} : v x = 0 \u2194 x = 0 :=\n  map_eq_zero v\n\ntheorem ne_zero_iff [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) {x : K} : v x \u2260 0 \u2194 x \u2260 0 :=\n  map_ne_zero v\n\nlemma pos_iff [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) {x : K} : 0 < v x \u2194 x \u2260 0 := by\n  rw [zero_lt_iff, ne_zero_iff]\n\ntheorem unit_map_eq (u : R\u02e3) : (Units.map (v : R \u2192* \u0393\u2080) u : \u0393\u2080) = v u :=\n  rfl\n\ntheorem ne_zero_of_unit [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) (x : K\u02e3) : v x \u2260 (0 : \u0393\u2080) := by\n  simp only [ne_eq, Valuation.zero_iff, Units.ne_zero x, not_false_iff]\n\ntheorem ne_zero_of_isUnit [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) (x : K) (hx : IsUnit x) :\n    v x \u2260 (0 : \u0393\u2080) := by\n  simpa [hx.choose_spec] using ne_zero_of_unit v hx.choose\n\n/-- A ring homomorphism `S \u2192 R` induces a map `Valuation R \u0393\u2080 \u2192 Valuation S \u0393\u2080`. -/\ndef comap {S : Type*} [Ring S] (f : S \u2192+* R) (v : Valuation R \u0393\u2080) : Valuation S \u0393\u2080 :=\n  { v.toMonoidWithZeroHom.comp f.toMonoidWithZeroHom with\n    toFun := v \u2218 f\n    map_add_le_max' := fun x y => by simp only [comp_apply, map_add, f.map_add] }\n\n@[simp]\ntheorem comap_apply {S : Type*} [Ring S] (f : S \u2192+* R) (v : Valuation R \u0393\u2080) (s : S) :\n    v.comap f s = v (f s) := rfl\n\n@[simp]\ntheorem comap_id : v.comap (RingHom.id R) = v :=\n  ext fun _r => rfl\n\ntheorem comap_comp {S\u2081 : Type*} {S\u2082 : Type*} [Ring S\u2081] [Ring S\u2082] (f : S\u2081 \u2192+* S\u2082) (g : S\u2082 \u2192+* R) :\n    v.comap (g.comp f) = (v.comap g).comap f :=\n  ext fun _r => rfl\n\n/-- A `\u2264`-preserving group homomorphism `\u0393\u2080 \u2192 \u0393'\u2080` induces a map `Valuation R \u0393\u2080 \u2192 Valuation R \u0393'\u2080`.\n-/\ndef map (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080) (hf : Monotone f) (v : Valuation R \u0393\u2080) : Valuation R \u0393'\u2080 :=\n  { MonoidWithZeroHom.comp f v.toMonoidWithZeroHom with\n    toFun := f \u2218 v\n    map_add_le_max' := fun r s =>\n      calc\n        f (v (r + s)) \u2264 f (max (v r) (v s)) := hf (v.map_add r s)\n        _ = max (f (v r)) (f (v s)) := hf.map_max\n         }\n\n@[simp]\nlemma map_apply (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080) (hf : Monotone f) (v : Valuation R \u0393\u2080) (r : R) :\n    v.map f hf r = f (v r) := rfl\n\n/-- Two valuations on `R` are defined to be equivalent if they induce the same preorder on `R`. -/\ndef IsEquiv (v\u2081 : Valuation R \u0393\u2080) (v\u2082 : Valuation R \u0393'\u2080) : Prop :=\n  \u2200 r s, v\u2081 r \u2264 v\u2081 s \u2194 v\u2082 r \u2264 v\u2082 s\n\n@[simp]\ntheorem map_neg (x : R) : v (-x) = v x :=\n  v.toMonoidWithZeroHom.toMonoidHom.map_neg x\n\ntheorem map_sub_swap (x y : R) : v (x - y) = v (y - x) :=\n  v.toMonoidWithZeroHom.toMonoidHom.map_sub_swap x y\n\ntheorem map_sub (x y : R) : v (x - y) \u2264 max (v x) (v y) :=\n  calc\n    v (x - y) = v (x + -y) := by rw [sub_eq_add_neg]\n    _ \u2264 max (v x) (v <| -y) := v.map_add _ _\n    _ = max (v x) (v y) := by rw [map_neg]\n\ntheorem map_sub_le {x y g} (hx : v x \u2264 g) (hy : v y \u2264 g) : v (x - y) \u2264 g := by\n  rw [sub_eq_add_neg]\n  exact v.map_add_le hx (le_trans (le_of_eq (v.map_neg y)) hy)\n\nvariable {x y : R}\n\ntheorem map_add_of_distinct_val (h : v x \u2260 v y) : v (x + y) = max (v x) (v y) := by\n  suffices \u00acv (x + y) < max (v x) (v y) from\n    or_iff_not_imp_right.1 (le_iff_eq_or_lt.1 (v.map_add x y)) this\n  intro h'\n  wlog vyx : v y < v x generalizing x y\n  \u00b7 refine this h.symm ?_ (h.lt_or_lt.resolve_right vyx)\n    rwa [add_comm, max_comm]\n  rw [max_eq_left_of_lt vyx] at h'\n  apply lt_irrefl (v x)\n  calc\n    v x = v (x + y - y) := by simp\n    _ \u2264 max (v <| x + y) (v y) := map_sub _ _ _\n    _ < v x := max_lt h' vyx\n\ntheorem map_add_eq_of_lt_right (h : v x < v y) : v (x + y) = v y :=\n  (v.map_add_of_distinct_val h.ne).trans (max_eq_right_iff.mpr h.le)\n\ntheorem map_add_eq_of_lt_left (h : v y < v x) : v (x + y) = v x := by\n  rw [add_comm]; exact map_add_eq_of_lt_right _ h\n\ntheorem map_sub_eq_of_lt_right (h : v x < v y) : v (x - y) = v y := by\n  rw [sub_eq_add_neg, map_add_eq_of_lt_right, map_neg]\n  rwa [map_neg]\n\nopen scoped Classical in\ntheorem map_sum_eq_of_lt {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {j : \u03b9}\n    (hj : j \u2208 s) (h0 : v (f j) \u2260 0) (hf : \u2200 i \u2208 s \\ {j}, v (f i) < v (f j)) :\n    v (\u2211 i \u2208 s, f i) = v (f j) := by\n  rw [Finset.sum_eq_add_sum_diff_singleton hj]\n  exact map_add_eq_of_lt_left _ (map_sum_lt _ h0 hf)\n\ntheorem map_sub_eq_of_lt_left (h : v y < v x) : v (x - y) = v x := by\n  rw [sub_eq_add_neg, map_add_eq_of_lt_left]\n  rwa [map_neg]\n\ntheorem map_eq_of_sub_lt (h : v (y - x) < v x) : v y = v x := by\n  have := Valuation.map_add_of_distinct_val v (ne_of_gt h).symm\n  rw [max_eq_right (le_of_lt h)] at this\n  simpa using this\n\ntheorem map_one_add_of_lt (h : v x < 1) : v (1 + x) = 1 := by\n  rw [\u2190 v.map_one] at h\n  simpa only [v.map_one] using v.map_add_eq_of_lt_left h\n\ntheorem map_one_sub_of_lt (h : v x < 1) : v (1 - x) = 1 := by\n  rw [\u2190 v.map_one, \u2190 v.map_neg] at h\n  rw [sub_eq_add_neg 1 x]\n  simpa only [v.map_one, v.map_neg] using v.map_add_eq_of_lt_left h\n\n/-- An ordered monoid isomorphism `\u0393\u2080 \u2243 \u0393'\u2080` induces an equivalence\n`Valuation R \u0393\u2080 \u2243 Valuation R \u0393'\u2080`. -/\ndef congr (f : \u0393\u2080 \u2243*o \u0393'\u2080) : Valuation R \u0393\u2080 \u2243 Valuation R \u0393'\u2080 where\n  toFun := map f f.toOrderIso.monotone\n  invFun := map f.symm f.toOrderIso.symm.monotone\n  left_inv \u03bd := by ext; simp\n  right_inv \u03bd := by ext; simp\n\nend Monoid\n\nsection Group\n\nvariable [LinearOrderedCommGroupWithZero \u0393\u2080] (v : Valuation R \u0393\u2080) {x y : R}\n\ntheorem map_inv {R : Type*} [DivisionRing R] (v : Valuation R \u0393\u2080) : \u2200 x, v x\u207b\u00b9 = (v x)\u207b\u00b9 :=\n  map_inv\u2080 _\n\ntheorem map_div {R : Type*} [DivisionRing R] (v : Valuation R \u0393\u2080) : \u2200 x y, v (x / y) = v x / v y :=\n  map_div\u2080 _\n\ntheorem one_lt_val_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : 1 < v x \u2194 v x\u207b\u00b9 < 1 := by\n  simp [inv_lt_one\u2080 (v.pos_iff.2 h)]\n\ntheorem one_le_val_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : 1 \u2264 v x \u2194 v x\u207b\u00b9 \u2264 1 := by\n  simp [inv_le_one\u2080 (v.pos_iff.2 h)]\n\ntheorem val_lt_one_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : v x < 1 \u2194 1 < v x\u207b\u00b9 := by\n  simp [one_lt_inv\u2080 (v.pos_iff.2 h)]\n\ntheorem val_le_one_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : v x \u2264 1 \u2194 1 \u2264 v x\u207b\u00b9 := by\n  simp [one_le_inv\u2080 (v.pos_iff.2 h)]\n\ntheorem val_eq_one_iff (v : Valuation K \u0393\u2080) {x : K} : v x = 1 \u2194 v x\u207b\u00b9 = 1 := by\n  by_cases h : x = 0\n  \u00b7 simp only [map_inv\u2080, inv_eq_one]\n  \u00b7 simpa only [le_antisymm_iff, And.comm] using and_congr (one_le_val_iff v h) (val_le_one_iff v h)\n\ntheorem val_le_one_or_val_inv_lt_one (v : Valuation K \u0393\u2080) (x : K) : v x \u2264 1 \u2228 v x\u207b\u00b9 < 1 := by\n  by_cases h : x = 0\n  \u00b7 simp only [h, _root_.map_zero, zero_le', inv_zero, zero_lt_one, or_self]\n  \u00b7 simp only [\u2190 one_lt_val_iff v h, le_or_lt]\n\n/--\nThis theorem is a weaker version of `Valuation.val_le_one_or_val_inv_lt_one`, but more symmetric\nin `x` and `x\u207b\u00b9`.\n-/\ntheorem val_le_one_or_val_inv_le_one (v : Valuation K \u0393\u2080) (x : K) : v x \u2264 1 \u2228 v x\u207b\u00b9 \u2264 1 := by\n  by_cases h : x = 0\n  \u00b7 simp only [h, _root_.map_zero, zero_le', inv_zero, or_self]\n  \u00b7 simp only [\u2190 one_le_val_iff v h, le_total]\n\n/-- The subgroup of elements whose valuation is less than a certain unit. -/\ndef ltAddSubgroup (v : Valuation R \u0393\u2080) (\u03b3 : \u0393\u2080\u02e3) : AddSubgroup R where\n  carrier := { x | v x < \u03b3 }\n  zero_mem' := by simp\n  add_mem' {x y} x_in y_in := lt_of_le_of_lt (v.map_add x y) (max_lt x_in y_in)\n  neg_mem' x_in := by rwa [Set.mem_setOf, map_neg]\n\nend Group\n\nend Basic\n\n-- end of section\nnamespace IsEquiv\n\nvariable [Ring R] [LinearOrderedCommMonoidWithZero \u0393\u2080] [LinearOrderedCommMonoidWithZero \u0393'\u2080]\n  {v : Valuation R \u0393\u2080} {v\u2081 : Valuation R \u0393\u2080} {v\u2082 : Valuation R \u0393'\u2080} {v\u2083 : Valuation R \u0393''\u2080}\n\n@[refl]\ntheorem refl : v.IsEquiv v := fun _ _ => Iff.refl _\n\n@[symm]\ntheorem symm (h : v\u2081.IsEquiv v\u2082) : v\u2082.IsEquiv v\u2081 := fun _ _ => Iff.symm (h _ _)\n\n@[trans]\ntheorem trans (h\u2081\u2082 : v\u2081.IsEquiv v\u2082) (h\u2082\u2083 : v\u2082.IsEquiv v\u2083) : v\u2081.IsEquiv v\u2083 := fun _ _ =>\n  Iff.trans (h\u2081\u2082 _ _) (h\u2082\u2083 _ _)\n\ntheorem of_eq {v' : Valuation R \u0393\u2080} (h : v = v') : v.IsEquiv v' := by subst h; rfl\n\ntheorem map {v' : Valuation R \u0393\u2080} (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080) (hf : Monotone f) (inf : Injective f)\n    (h : v.IsEquiv v') : (v.map f hf).IsEquiv (v'.map f hf) :=\n  let H : StrictMono f := hf.strictMono_of_injective inf\n  fun r s =>\n  calc\n    f (v r) \u2264 f (v s) \u2194 v r \u2264 v s := by rw [H.le_iff_le]\n    _ \u2194 v' r \u2264 v' s := h r s\n    _ \u2194 f (v' r) \u2264 f (v' s) := by rw [H.le_iff_le]\n\n/-- `comap` preserves equivalence. -/\ntheorem comap {S : Type*} [Ring S] (f : S \u2192+* R) (h : v\u2081.IsEquiv v\u2082) :\n    (v\u2081.comap f).IsEquiv (v\u2082.comap f) := fun r s => h (f r) (f s)\n\ntheorem val_eq (h : v\u2081.IsEquiv v\u2082) {r s : R} : v\u2081 r = v\u2081 s \u2194 v\u2082 r = v\u2082 s := by\n  simpa only [le_antisymm_iff] using and_congr (h r s) (h s r)\n\ntheorem ne_zero (h : v\u2081.IsEquiv v\u2082) {r : R} : v\u2081 r \u2260 0 \u2194 v\u2082 r \u2260 0 := by\n  have : v\u2081 r \u2260 v\u2081 0 \u2194 v\u2082 r \u2260 v\u2082 0 := not_congr h.val_eq\n  rwa [v\u2081.map_zero, v\u2082.map_zero] at this\n\nend IsEquiv\n\n-- end of namespace\nsection\n\ntheorem isEquiv_of_map_strictMono [LinearOrderedCommMonoidWithZero \u0393\u2080]\n    [LinearOrderedCommMonoidWithZero \u0393'\u2080] [Ring R] {v : Valuation R \u0393\u2080} (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080)\n    (H : StrictMono f) : IsEquiv (v.map f H.monotone) v := fun _x _y =>\n  \u27e8H.le_iff_le.mp, fun h => H.monotone h\u27e9\n\ntheorem isEquiv_iff_val_lt_val [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x y : K}, v x < v y \u2194 v' x < v' y := by\n  simp only [IsEquiv, le_iff_le_iff_lt_iff_lt]\n  exact forall_comm\n\nalias \u27e8IsEquiv.lt_iff_lt, _\u27e9 := isEquiv_iff_val_lt_val\n\ntheorem isEquiv_of_val_le_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080}\n    (h : \u2200 {x : K}, v x \u2264 1 \u2194 v' x \u2264 1) : v.IsEquiv v' := by\n  intro x y\n  obtain rfl | hy := eq_or_ne y 0\n  \u00b7 simp\n  \u00b7 rw [\u2190 div_le_one\u2080, \u2190 v.map_div, h, v'.map_div, div_le_one\u2080] <;>\n      rwa [zero_lt_iff, ne_zero_iff]\n\ntheorem isEquiv_iff_val_le_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v x \u2264 1 \u2194 v' x \u2264 1 :=\n  \u27e8fun h x => by simpa using h x 1, isEquiv_of_val_le_one\u27e9\n\nalias \u27e8IsEquiv.le_one_iff_le_one, _\u27e9 := isEquiv_iff_val_le_one\n\ntheorem isEquiv_iff_val_eq_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v x = 1 \u2194 v' x = 1 := by\n  constructor\n  \u00b7 intro h x\n    simpa using @IsEquiv.val_eq _ _ _ _ _ _ v v' h x 1\n  \u00b7 intro h\n    apply isEquiv_of_val_le_one\n    intro x\n    constructor\n    \u00b7 intro hx\n      rcases lt_or_eq_of_le hx with hx' | hx'\n      \u00b7 have : v (1 + x) = 1 := by\n          rw [\u2190 v.map_one]\n          apply map_add_eq_of_lt_left\n          simpa\n        rw [h] at this\n        rw [show x = -1 + (1 + x) by simp]\n        refine le_trans (v'.map_add _ _) ?_\n        simp [this]\n      \u00b7 rw [h] at hx'\n        exact le_of_eq hx'\n    \u00b7 intro hx\n      rcases lt_or_eq_of_le hx with hx' | hx'\n      \u00b7 have : v' (1 + x) = 1 := by\n          rw [\u2190 v'.map_one]\n          apply map_add_eq_of_lt_left\n          simpa\n        rw [\u2190 h] at this\n        rw [show x = -1 + (1 + x) by simp]\n        refine le_trans (v.map_add _ _) ?_\n        simp [this]\n      \u00b7 rw [\u2190 h] at hx'\n        exact le_of_eq hx'\n\nalias \u27e8IsEquiv.eq_one_iff_eq_one, _\u27e9 := isEquiv_iff_val_eq_one\n\ntheorem isEquiv_iff_val_lt_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v x < 1 \u2194 v' x < 1 := by\n  constructor\n  \u00b7 intro h x\n    simp only [lt_iff_le_and_ne,\n      and_congr h.le_one_iff_le_one h.eq_one_iff_eq_one.not]\n  \u00b7 rw [isEquiv_iff_val_eq_one]\n    intro h x\n    by_cases hx : x = 0\n    \u00b7 simp only [(zero_iff _).2 hx, zero_ne_one]\n    constructor\n    \u00b7 intro hh\n      by_contra h_1\n      cases ne_iff_lt_or_gt.1 h_1 with\n      | inl h_2 => simpa [hh, lt_self_iff_false] using h.2 h_2\n      | inr h_2 =>\n          rw [\u2190 inv_one, \u2190 inv_eq_iff_eq_inv, \u2190 map_inv\u2080] at hh\n          exact hh.not_lt (h.2 ((one_lt_val_iff v' hx).1 h_2))\n    \u00b7 intro hh\n      by_contra h_1\n      cases ne_iff_lt_or_gt.1 h_1 with\n      | inl h_2 => simpa [hh, lt_self_iff_false] using h.1 h_2\n      | inr h_2 =>\n        rw [\u2190 inv_one, \u2190 inv_eq_iff_eq_inv, \u2190 map_inv\u2080] at hh\n        exact hh.not_lt (h.1 ((one_lt_val_iff v hx).1 h_2))\n\nalias \u27e8IsEquiv.lt_one_iff_lt_one, _\u27e9 := isEquiv_iff_val_lt_one\n\ntheorem isEquiv_iff_val_sub_one_lt_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v (x - 1) < 1 \u2194 v' (x - 1) < 1 := by\n  rw [isEquiv_iff_val_lt_one]\n  exact (Equiv.subRight 1).surjective.forall\n\nalias \u27e8IsEquiv.val_sub_one_lt_one_iff, _\u27e9 := isEquiv_iff_val_sub_one_lt_one\n\ntheorem isEquiv_tfae [LinearOrderedCommGroupWithZero \u0393\u2080] [LinearOrderedCommGroupWithZero \u0393'\u2080]\n    (v : Valuation K \u0393\u2080) (v' : Valuation K \u0393'\u2080) :\n    [ v.IsEquiv v',\n      \u2200 {x y}, v x < v y \u2194 v' x < v' y,\n      \u2200 {x}, v x \u2264 1 \u2194 v' x \u2264 1,\n      \u2200 {x}, v x = 1 \u2194 v' x = 1,\n      \u2200 {x}, v x < 1 \u2194 v' x < 1,\n      \u2200 {x}, v (x - 1) < 1 \u2194 v' (x - 1) < 1 ].TFAE := by\n  tfae_have 1 \u2194 2 := isEquiv_iff_val_lt_val\n  tfae_have 1 \u2194 3 := isEquiv_iff_val_le_one\n  tfae_have 1 \u2194 4 := isEquiv_iff_val_eq_one\n  tfae_have 1 \u2194 5 := isEquiv_iff_val_lt_one\n  tfae_have 1 \u2194 6 := isEquiv_iff_val_sub_one_lt_one\n  tfae_finish\n\nend\n\nsection Supp\n\nvariable [CommRing R] [LinearOrderedCommMonoidWithZero \u0393\u2080] (v : Valuation R \u0393\u2080)\n\n/-- The support of a valuation `v : R \u2192 \u0393\u2080` is the ideal of `R` where `v` vanishes. -/\ndef supp : Ideal R where\n  carrier := { x | v x = 0 }\n  zero_mem' := map_zero v\n  add_mem' {x y} hx hy := le_zero_iff.mp <|\n    calc\n      v (x + y) \u2264 max (v x) (v y) := v.map_add x y\n      _ \u2264 0 := max_le (le_zero_iff.mpr hx) (le_zero_iff.mpr hy)\n  smul_mem' c x hx :=\n    calc\n      v (c * x) = v c * v x := map_mul v c x\n      _ = v c * 0 := congr_arg _ hx\n      _ = 0 := mul_zero _\n\n@[simp]\ntheorem mem_supp_iff (x : R) : x \u2208 supp v \u2194 v x = 0 :=\n  Iff.rfl\n\n/-- The support of a valuation is a prime ideal. -/\ninstance [Nontrivial \u0393\u2080] [NoZeroDivisors \u0393\u2080] : Ideal.IsPrime (supp v) :=\n  \u27e8fun h =>\n    one_ne_zero (\u03b1 := \u0393\u2080) <|\n      calc\n        1 = v 1 := v.map_one.symm\n        _ = 0 := by rw [\u2190 mem_supp_iff, h]; exact Submodule.mem_top,\n   fun {x y} hxy => by\n    simp only [mem_supp_iff] at hxy \u22a2\n    rw [v.map_mul x y] at hxy\n    exact eq_zero_or_eq_zero_of_mul_eq_zero hxy\u27e9\n\ntheorem map_add_supp (a : R) {s : R} (h : s \u2208 supp v) : v (a + s) = v a := by\n  have aux : \u2200 a s, v s = 0 \u2192 v (a + s) \u2264 v a := by\n    intro a' s' h'\n    refine le_trans (v.map_add a' s') (max_le le_rfl ?_)\n    simp [h']\n  apply le_antisymm (aux a s h)\n  calc\n    v a = v (a + s + -s) := by simp\n    _ \u2264 v (a + s) := aux (a + s) (-s) (by rwa [\u2190 Ideal.neg_mem_iff] at h)\n\ntheorem comap_supp {S : Type*} [CommRing S] (f : S \u2192+* R) :\n    supp (v.comap f) = Ideal.comap f v.supp :=\n  Ideal.ext fun x => by rw [mem_supp_iff, Ideal.mem_comap, mem_supp_iff, comap_apply]\n\nend Supp\n\n-- end of section\nend Valuation\n\nsection AddMonoid\n\nvariable (R) [Ring R] (\u0393\u2080 : Type*) [LinearOrderedAddCommMonoidWithTop \u0393\u2080]\n\n/-- The type of `\u0393\u2080`-valued additive valuations on `R`. -/\ndef AddValuation :=\n  Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48)\n\nend AddMonoid\n\nnamespace AddValuation\n\nvariable {\u0393\u2080 : Type*} {\u0393'\u2080 : Type*}\n\nsection Basic\n\nsection Monoid\n\n/-- A valuation is coerced to the underlying function `R \u2192 \u0393\u2080`. -/\ninstance (R) (\u0393\u2080) [Ring R] [LinearOrderedAddCommMonoidWithTop \u0393\u2080] :\n    FunLike (AddValuation R \u0393\u2080) R \u0393\u2080 where\n  coe v := v.toMonoidWithZeroHom.toFun\n  coe_injective' f g := by cases f; cases g; simp (config := {contextual := true})\n\nvariable [Ring R] [LinearOrderedAddCommMonoidWithTop \u0393\u2080] [LinearOrderedAddCommMonoidWithTop \u0393'\u2080]\n  (v : AddValuation R \u0393\u2080)\n\nsection\n\nvariable (f : R \u2192 \u0393\u2080) (h0 : f 0 = \u22a4) (h1 : f 1 = 0)\nvariable (hadd : \u2200 x y, min (f x) (f y) \u2264 f (x + y)) (hmul : \u2200 x y, f (x * y) = f x + f y)\n\n/-- An alternate constructor of `AddValuation`, that doesn't reference `Multiplicative \u0393\u2080\u1d52\u1d48` -/\ndef of : AddValuation R \u0393\u2080 where\n  toFun := f\n  map_one' := h1\n  map_zero' := h0\n  map_add_le_max' := hadd\n  map_mul' := hmul\n\nvariable {h0} {h1} {hadd} {hmul} {r : R}\n\n@[simp]\ntheorem of_apply : (of f h0 h1 hadd hmul) r = f r := rfl\n\n/-- The `Valuation` associated to an `AddValuation` (useful if the latter is constructed using\n`AddValuation.of`). -/\ndef toValuation : AddValuation R \u0393\u2080 \u2243 Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48) :=\n  Equiv.refl _\n\n@[deprecated (since := \"2024-11-09\")]\nalias valuation := toValuation\n\n/-- The `AddValuation` associated to a `Valuation`.\n-/\ndef ofValuation : Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48) \u2243 AddValuation R \u0393\u2080 :=\n  Equiv.refl _\n\n", "theoremStatement": "@[simp]\nlemma ofValuation_symm_eq : ofValuation.symm = toValuation (R := R) (\u0393\u2080 := \u0393\u2080) ", "theoremName": "AddValuation.ofValuation_symm_eq", "fileCreated": {"commit": "a9138cdba12f2110c86195f5eac26cb36dee2627", "date": "2023-03-17"}, "theoremCreated": {"commit": "625ac34a53dfa0eca4fb8a3a933409238e4f43f0", "date": "2024-12-16"}, "file": "mathlib/Mathlib/RingTheory/Valuation/Basic.lean", "module": "Mathlib.RingTheory.Valuation.Basic", "jsonFile": "Mathlib.RingTheory.Valuation.Basic.jsonl", "positionMetadata": {"lineInFile": 660, "tokenPositionInFile": 22970, "theoremPositionInFile": 75}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 11, "numPremises": 13}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "/-\nCopyright (c) 2018 Robert Y. Lewis. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Robert Y. Lewis, Mario Carneiro, Johan Commelin\n-/\nimport Mathlib.NumberTheory.Padics.PadicNumbers\nimport Mathlib.RingTheory.DiscreteValuationRing.Basic\n\n/-!\n# p-adic integers\n\nThis file defines the `p`-adic integers `\u2124_[p]` as the subtype of `\u211a_[p]` with norm `\u2264 1`.\nWe show that `\u2124_[p]`\n* is complete,\n* is nonarchimedean,\n* is a normed ring,\n* is a local ring, and\n* is a discrete valuation ring.\n\nThe relation between `\u2124_[p]` and `ZMod p` is established in another file.\n\n## Important definitions\n\n* `PadicInt` : the type of `p`-adic integers\n\n## Notation\n\nWe introduce the notation `\u2124_[p]` for the `p`-adic integers.\n\n## Implementation notes\n\nMuch, but not all, of this file assumes that `p` is prime. This assumption is inferred automatically\nby taking `[Fact p.Prime]` as a type class argument.\n\nCoercions into `\u2124_[p]` are set up to work with the `norm_cast` tactic.\n\n## References\n\n* [F. Q. Gouv\u00eaa, *p-adic numbers*][gouvea1997]\n* [R. Y. Lewis, *A formal proof of Hensel's lemma over the p-adic integers*][lewis2019]\n* <https://en.wikipedia.org/wiki/P-adic_number>\n\n## Tags\n\np-adic, p adic, padic, p-adic integer\n-/\n\n\nopen Padic Metric IsLocalRing\n\nnoncomputable section\n\nvariable (p : \u2115) [hp : Fact p.Prime]\n\n/-- The `p`-adic integers `\u2124_[p]` are the `p`-adic numbers with norm `\u2264 1`. -/\ndef PadicInt : Type := {x : \u211a_[p] // \u2016x\u2016 \u2264 1}\n\n/-- The ring of `p`-adic integers. -/\nnotation \"\u2124_[\" p \"]\" => PadicInt p\n\nnamespace PadicInt\nvariable {p} {x y : \u2124_[p]}\n\n/-! ### Ring structure and coercion to `\u211a_[p]` -/\n\ninstance : Coe \u2124_[p] \u211a_[p] :=\n  \u27e8Subtype.val\u27e9\n\ntheorem ext {x y : \u2124_[p]} : (x : \u211a_[p]) = y \u2192 x = y :=\n  Subtype.ext\n\nvariable (p)\n\n/-- The `p`-adic integers as a subring of `\u211a_[p]`. -/\ndef subring : Subring \u211a_[p] where\n  carrier := { x : \u211a_[p] | \u2016x\u2016 \u2264 1 }\n  zero_mem' := by norm_num\n  one_mem' := by norm_num\n  add_mem' hx hy := (padicNormE.nonarchimedean _ _).trans <| max_le_iff.2 \u27e8hx, hy\u27e9\n  mul_mem' hx hy := (padicNormE.mul _ _).trans_le <| mul_le_one\u2080 hx (norm_nonneg _) hy\n  neg_mem' hx := (norm_neg _).trans_le hx\n\n@[simp]\ntheorem mem_subring_iff {x : \u211a_[p]} : x \u2208 subring p \u2194 \u2016x\u2016 \u2264 1 := Iff.rfl\n\nvariable {p}\n\n/-- Addition on `\u2124_[p]` is inherited from `\u211a_[p]`. -/\ninstance : Add \u2124_[p] := (by infer_instance : Add (subring p))\n\n/-- Multiplication on `\u2124_[p]` is inherited from `\u211a_[p]`. -/\ninstance : Mul \u2124_[p] := (by infer_instance : Mul (subring p))\n\n/-- Negation on `\u2124_[p]` is inherited from `\u211a_[p]`. -/\ninstance : Neg \u2124_[p] := (by infer_instance : Neg (subring p))\n\n/-- Subtraction on `\u2124_[p]` is inherited from `\u211a_[p]`. -/\ninstance : Sub \u2124_[p] := (by infer_instance : Sub (subring p))\n\n/-- Zero on `\u2124_[p]` is inherited from `\u211a_[p]`. -/\ninstance : Zero \u2124_[p] := (by infer_instance : Zero (subring p))\n\ninstance : Inhabited \u2124_[p] := \u27e80\u27e9\n\n/-- One on `\u2124_[p]` is inherited from `\u211a_[p]`. -/\ninstance : One \u2124_[p] := \u27e8\u27e81, by norm_num\u27e9\u27e9\n\n@[simp]\ntheorem mk_zero {h} : (\u27e80, h\u27e9 : \u2124_[p]) = (0 : \u2124_[p]) := rfl\n\n@[simp, norm_cast]\ntheorem coe_add (z1 z2 : \u2124_[p]) : ((z1 + z2 : \u2124_[p]) : \u211a_[p]) = z1 + z2 := rfl\n\n@[simp, norm_cast]\ntheorem coe_mul (z1 z2 : \u2124_[p]) : ((z1 * z2 : \u2124_[p]) : \u211a_[p]) = z1 * z2 := rfl\n\n@[simp, norm_cast]\ntheorem coe_neg (z1 : \u2124_[p]) : ((-z1 : \u2124_[p]) : \u211a_[p]) = -z1 := rfl\n\n@[simp, norm_cast]\ntheorem coe_sub (z1 z2 : \u2124_[p]) : ((z1 - z2 : \u2124_[p]) : \u211a_[p]) = z1 - z2 := rfl\n\n@[simp, norm_cast]\ntheorem coe_one : ((1 : \u2124_[p]) : \u211a_[p]) = 1 := rfl\n\n@[simp, norm_cast]\ntheorem coe_zero : ((0 : \u2124_[p]) : \u211a_[p]) = 0 := rfl\n\n@[simp] lemma coe_eq_zero : (x : \u211a_[p]) = 0 \u2194 x = 0 := by rw [\u2190 coe_zero, Subtype.coe_inj]\n\nlemma coe_ne_zero : (x : \u211a_[p]) \u2260 0 \u2194 x \u2260 0 := coe_eq_zero.not\n\ninstance : AddCommGroup \u2124_[p] := (by infer_instance : AddCommGroup (subring p))\n\ninstance instCommRing : CommRing \u2124_[p] := (by infer_instance : CommRing (subring p))\n\n@[simp, norm_cast]\ntheorem coe_natCast (n : \u2115) : ((n : \u2124_[p]) : \u211a_[p]) = n := rfl\n\n@[simp, norm_cast]\ntheorem coe_intCast (z : \u2124) : ((z : \u2124_[p]) : \u211a_[p]) = z := rfl\n\n/-- The coercion from `\u2124_[p]` to `\u211a_[p]` as a ring homomorphism. -/\ndef Coe.ringHom : \u2124_[p] \u2192+* \u211a_[p] := (subring p).subtype\n\n@[simp, norm_cast]\ntheorem coe_pow (x : \u2124_[p]) (n : \u2115) : (\u2191(x ^ n) : \u211a_[p]) = (\u2191x : \u211a_[p]) ^ n := rfl\n\ntheorem mk_coe (k : \u2124_[p]) : (\u27e8k, k.2\u27e9 : \u2124_[p]) = k := by simp\n\n/-- The inverse of a `p`-adic integer with norm equal to `1` is also a `p`-adic integer.\nOtherwise, the inverse is defined to be `0`. -/\ndef inv : \u2124_[p] \u2192 \u2124_[p]\n  | \u27e8k, _\u27e9 => if h : \u2016k\u2016 = 1 then \u27e8k\u207b\u00b9, by simp [h]\u27e9 else 0\n\ninstance : CharZero \u2124_[p] where\n  cast_injective m n h :=\n    Nat.cast_injective (R := \u211a_[p]) (by rw [Subtype.ext_iff] at h; norm_cast at h)\n\n@[norm_cast]\ntheorem intCast_eq (z1 z2 : \u2124) : (z1 : \u2124_[p]) = z2 \u2194 z1 = z2 := by simp\n\n/-- A sequence of integers that is Cauchy with respect to the `p`-adic norm converges to a `p`-adic\ninteger. -/\ndef ofIntSeq (seq : \u2115 \u2192 \u2124) (h : IsCauSeq (padicNorm p) fun n => seq n) : \u2124_[p] :=\n  \u27e8\u27e6\u27e8_, h\u27e9\u27e7,\n    show \u2191(PadicSeq.norm _) \u2264 (1 : \u211d) by\n      rw [PadicSeq.norm]\n      split_ifs with hne <;> norm_cast\n      apply padicNorm.of_int\u27e9\n\n/-! ### Instances\n\nWe now show that `\u2124_[p]` is a\n* complete metric space\n* normed ring\n* integral domain\n-/\n\nvariable (p)\n\ninstance : MetricSpace \u2124_[p] := Subtype.metricSpace\n\ninstance : IsUltrametricDist \u2124_[p] := IsUltrametricDist.subtype _\n\ninstance completeSpace : CompleteSpace \u2124_[p] :=\n  have : IsClosed { x : \u211a_[p] | \u2016x\u2016 \u2264 1 } := isClosed_le continuous_norm continuous_const\n  this.completeSpace_coe\n\ninstance : Norm \u2124_[p] := \u27e8fun z => \u2016(z : \u211a_[p])\u2016\u27e9\n\nvariable {p}\n\ntheorem norm_def {z : \u2124_[p]} : \u2016z\u2016 = \u2016(z : \u211a_[p])\u2016 := rfl\n\nvariable (p)\n\ninstance : NormedCommRing \u2124_[p] :=\n  { PadicInt.instCommRing with\n    dist_eq := fun \u27e8_, _\u27e9 \u27e8_, _\u27e9 => rfl\n    norm_mul := by simp [norm_def]\n    norm := norm }\n\ninstance : NormOneClass \u2124_[p] :=\n  \u27e8norm_def.trans norm_one\u27e9\n\ninstance isAbsoluteValue : IsAbsoluteValue fun z : \u2124_[p] => \u2016z\u2016 where\n  abv_nonneg' := norm_nonneg\n  abv_eq_zero' := by simp [norm_eq_zero]\n  abv_add' := fun \u27e8_, _\u27e9 \u27e8_, _\u27e9 => norm_add_le _ _\n  abv_mul' _ _ := by simp only [norm_def, padicNormE.mul, PadicInt.coe_mul]\n\nvariable {p}\n\ninstance : IsDomain \u2124_[p] := Function.Injective.isDomain (subring p).subtype Subtype.coe_injective\n\n/-! ### Norm -/\n\ntheorem norm_le_one (z : \u2124_[p]) : \u2016z\u2016 \u2264 1 := z.2\n\n@[simp]\ntheorem norm_mul (z1 z2 : \u2124_[p]) : \u2016z1 * z2\u2016 = \u2016z1\u2016 * \u2016z2\u2016 := by simp [norm_def]\n\n@[simp]\ntheorem norm_pow (z : \u2124_[p]) : \u2200 n : \u2115, \u2016z ^ n\u2016 = \u2016z\u2016 ^ n\n  | 0 => by simp\n  | k + 1 => by\n    rw [pow_succ, pow_succ, norm_mul]\n    congr\n    apply norm_pow\n\ntheorem nonarchimedean (q r : \u2124_[p]) : \u2016q + r\u2016 \u2264 max \u2016q\u2016 \u2016r\u2016 := padicNormE.nonarchimedean _ _\n\ntheorem norm_add_eq_max_of_ne {q r : \u2124_[p]} : \u2016q\u2016 \u2260 \u2016r\u2016 \u2192 \u2016q + r\u2016 = max \u2016q\u2016 \u2016r\u2016 :=\n  padicNormE.add_eq_max_of_ne\n\ntheorem norm_eq_of_norm_add_lt_right {z1 z2 : \u2124_[p]} (h : \u2016z1 + z2\u2016 < \u2016z2\u2016) : \u2016z1\u2016 = \u2016z2\u2016 :=\n  by_contra fun hne =>\n    not_lt_of_ge (by rw [norm_add_eq_max_of_ne hne]; apply le_max_right) h\n\ntheorem norm_eq_of_norm_add_lt_left {z1 z2 : \u2124_[p]} (h : \u2016z1 + z2\u2016 < \u2016z1\u2016) : \u2016z1\u2016 = \u2016z2\u2016 :=\n  by_contra fun hne =>\n    not_lt_of_ge (by rw [norm_add_eq_max_of_ne hne]; apply le_max_left) h\n\n@[simp]\ntheorem padic_norm_e_of_padicInt (z : \u2124_[p]) : \u2016(z : \u211a_[p])\u2016 = \u2016z\u2016 := by simp [norm_def]\n\ntheorem norm_intCast_eq_padic_norm (z : \u2124) : \u2016(z : \u2124_[p])\u2016 = \u2016(z : \u211a_[p])\u2016 := by simp [norm_def]\n\n@[simp]\ntheorem norm_eq_padic_norm {q : \u211a_[p]} (hq : \u2016q\u2016 \u2264 1) : @norm \u2124_[p] _ \u27e8q, hq\u27e9 = \u2016q\u2016 := rfl\n\n@[simp]\ntheorem norm_p : \u2016(p : \u2124_[p])\u2016 = (p : \u211d)\u207b\u00b9 := padicNormE.norm_p\n\ntheorem norm_p_pow (n : \u2115) : \u2016(p : \u2124_[p]) ^ n\u2016 = (p : \u211d) ^ (-n : \u2124) := by simp\n\nprivate def cauSeq_to_rat_cauSeq (f : CauSeq \u2124_[p] norm) : CauSeq \u211a_[p] fun a => \u2016a\u2016 :=\n  \u27e8fun n => f n, fun _ h\u03b5 => by simpa [norm, norm_def] using f.cauchy h\u03b5\u27e9\n\nvariable (p)\n\ninstance complete : CauSeq.IsComplete \u2124_[p] norm :=\n  \u27e8fun f =>\n    have hqn : \u2016CauSeq.lim (cauSeq_to_rat_cauSeq f)\u2016 \u2264 1 :=\n      padicNormE_lim_le zero_lt_one fun _ => norm_le_one _\n    \u27e8\u27e8_, hqn\u27e9, fun \u03b5 => by\n      simpa [norm, norm_def] using CauSeq.equiv_lim (cauSeq_to_rat_cauSeq f) \u03b5\u27e9\u27e9\n\ntheorem exists_pow_neg_lt {\u03b5 : \u211d} (h\u03b5 : 0 < \u03b5) : \u2203 k : \u2115, (p : \u211d) ^ (-(k : \u2124)) < \u03b5 := by\n  obtain \u27e8k, hk\u27e9 := exists_nat_gt \u03b5\u207b\u00b9\n  use k\n  rw [\u2190 inv_lt_inv\u2080 h\u03b5 (zpow_pos _ _)]\n  \u00b7 rw [zpow_neg, inv_inv, zpow_natCast]\n    apply lt_of_lt_of_le hk\n    norm_cast\n    apply le_of_lt\n    convert Nat.lt_pow_self _ using 1\n    exact hp.1.one_lt\n  \u00b7 exact mod_cast hp.1.pos\n\ntheorem exists_pow_neg_lt_rat {\u03b5 : \u211a} (h\u03b5 : 0 < \u03b5) : \u2203 k : \u2115, (p : \u211a) ^ (-(k : \u2124)) < \u03b5 := by\n  obtain \u27e8k, hk\u27e9 := @exists_pow_neg_lt p _ \u03b5 (mod_cast h\u03b5)\n  use k\n  rw [show (p : \u211d) = (p : \u211a) by simp] at hk\n  exact mod_cast hk\n\nvariable {p}\n\ntheorem norm_int_lt_one_iff_dvd (k : \u2124) : \u2016(k : \u2124_[p])\u2016 < 1 \u2194 (p : \u2124) \u2223 k :=\n  suffices \u2016(k : \u211a_[p])\u2016 < 1 \u2194 \u2191p \u2223 k by rwa [norm_intCast_eq_padic_norm]\n  padicNormE.norm_int_lt_one_iff_dvd k\n\ntheorem norm_int_le_pow_iff_dvd {k : \u2124} {n : \u2115} :\n    \u2016(k : \u2124_[p])\u2016 \u2264 (p : \u211d) ^ (-n : \u2124) \u2194 (p ^ n : \u2124) \u2223 k :=\n  suffices \u2016(k : \u211a_[p])\u2016 \u2264 (p : \u211d) ^ (-n : \u2124) \u2194 (p ^ n : \u2124) \u2223 k by\n    simpa [norm_intCast_eq_padic_norm]\n  padicNormE.norm_int_le_pow_iff_dvd _ _\n\n/-! ### Valuation on `\u2124_[p]` -/\n\nlemma valuation_coe_nonneg : 0 \u2264 (x : \u211a_[p]).valuation := by\n  obtain rfl | hx := eq_or_ne x 0\n  \u00b7 simp\n  have := x.2\n  rwa [Padic.norm_eq_zpow_neg_valuation <| coe_ne_zero.2 hx, zpow_le_one_iff_right\u2080, neg_nonpos]\n    at this\n  exact mod_cast hp.out.one_lt\n\n/-- `PadicInt.valuation` lifts the `p`-adic valuation on `\u211a` to `\u2124_[p]`. -/\ndef valuation (x : \u2124_[p]) : \u2115 := (x : \u211a_[p]).valuation.toNat\n\n@[simp, norm_cast] lemma valuation_coe (x : \u2124_[p]) : (x : \u211a_[p]).valuation = x.valuation := by\n  simp [valuation, valuation_coe_nonneg]\n\n@[simp] lemma valuation_zero : valuation (0 : \u2124_[p]) = 0 := by simp [valuation]\n@[simp] lemma valuation_one : valuation (1 : \u2124_[p]) = 0 := by simp [valuation]\n@[simp] lemma valuation_p : valuation (p : \u2124_[p]) = 1 := by simp [valuation]\n\nlemma le_valuation_add (hxy : x + y \u2260 0) : min x.valuation y.valuation \u2264 (x + y).valuation := by\n  zify; simpa [\u2190 valuation_coe] using Padic.le_valuation_add <| coe_ne_zero.2 hxy\n\n@[simp] lemma valuation_mul (hx : x \u2260 0) (hy : y \u2260 0) :\n    (x * y).valuation = x.valuation + y.valuation := by\n  zify; simp [\u2190 valuation_coe, Padic.valuation_mul (coe_ne_zero.2 hx) (coe_ne_zero.2 hy)]\n\n@[simp]\nlemma valuation_pow (x : \u2124_[p]) (n : \u2115) : (x ^ n).valuation = n * x.valuation := by\n  zify; simp [\u2190 valuation_coe]\n\n", "theoremStatement": "lemma norm_eq_zpow_neg_valuation {x : \u2124_[p]} (hx : x \u2260 0) : \u2016x\u2016 = p ^ (-x.valuation : \u2124) ", "theoremName": "PadicInt.norm_eq_zpow_neg_valuation", "fileCreated": {"commit": "63d78da6a358d613bff5f34c62ed9481dbbc52c2", "date": "2023-05-25"}, "theoremCreated": {"commit": "1c080cc45939aaef448022267a6965a19e53c7bf", "date": "2024-12-21"}, "file": "mathlib/Mathlib/NumberTheory/Padics/PadicIntegers.lean", "module": "Mathlib.NumberTheory.Padics.PadicIntegers", "jsonFile": "Mathlib.NumberTheory.Padics.PadicIntegers.jsonl", "positionMetadata": {"lineInFile": 331, "tokenPositionInFile": 10510, "theoremPositionInFile": 46}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 6, "repositoryPremises": true, "numRepositoryPremises": 36, "numPremises": 57}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp [norm_def, Padic.norm_eq_zpow_neg_valuation <| coe_ne_zero.2 hx]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 77}}
{"srcContext": "/-\nCopyright (c) 2024 Fangming Li. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Fangming Li, Jujian Zhang\n-/\nimport Mathlib.Algebra.Polynomial.AlgebraMap\nimport Mathlib.Algebra.Polynomial.Eval.SMul\nimport Mathlib.Algebra.Polynomial.Roots\nimport Mathlib.Order.Interval.Set.Infinite\nimport Mathlib.RingTheory.Polynomial.Pochhammer\nimport Mathlib.RingTheory.PowerSeries.WellKnown\nimport Mathlib.Tactic.FieldSimp\n\n/-!\n# Hilbert polynomials\n\nIn this file, we formalise the following statement: if `F` is a field with characteristic `0`, then\ngiven any `p : F[X]` and `d : \u2115`, there exists some `h : F[X]` such that for any large enough\n`n : \u2115`, `h(n)` is equal to the coefficient of `X\u207f` in the power series expansion of `p/(1 - X)\u1d48`.\nThis `h` is unique and is denoted as `Polynomial.hilbertPoly p d`.\n\nFor example, given `d : \u2115`, the power series expansion of `1/(1 - X)\u1d48\u207a\u00b9` in `F[X]`\nis `\u03a3\u2099 ((d + n).choose d)X\u207f`, which equals `\u03a3\u2099 ((n + 1)\u00b7\u00b7\u00b7(n + d)/d!)X\u207f` and hence\n`Polynomial.hilbertPoly (1 : F[X]) (d + 1)` is the polynomial `(X + 1)\u00b7\u00b7\u00b7(X + d)/d!`. Note that\nif `d! = 0` in `F`, then the polynomial `(X + 1)\u00b7\u00b7\u00b7(X + d)/d!` no longer works, so we do not want\nthe characteristic of `F` to be divisible by `d!`. As `Polynomial.hilbertPoly` may take any\n`p : F[X]` and `d : \u2115` as its inputs, it is necessary for us to assume that `CharZero F`.\n\n## Main definitions\n\n* `Polynomial.hilbertPoly p d`. Given a field `F`, a polynomial `p : F[X]` and a natural number `d`,\n  if `F` is of characteristic `0`, then `Polynomial.hilbertPoly p d : F[X]` is the polynomial whose\n  value at `n` equals the coefficient of `X\u207f` in the power series expansion of `p/(1 - X)\u1d48`.\n\n## TODO\n\n* Hilbert polynomials of finitely generated graded modules over Noetherian rings.\n-/\n\nopen Nat PowerSeries\n\nvariable (F : Type*) [Field F]\n\nnamespace Polynomial\n\n/--\nFor any field `F` and natural numbers `d` and `k`, `Polynomial.preHilbertPoly F d k`\nis defined as `(d.factorial : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (X - (C (k : F)) + 1))`.\nThis is the most basic form of Hilbert polynomials. `Polynomial.preHilbertPoly \u211a d 0`\nis exactly the Hilbert polynomial of the polynomial ring `\u211a[X_0,...,X_d]` viewed as\na graded module over itself. In fact, `Polynomial.preHilbertPoly F d k` is the\nsame as `Polynomial.hilbertPoly ((X : F[X]) ^ k) (d + 1)` for any field `F` and\n`d k : \u2115` (see the lemma `Polynomial.hilbertPoly_X_pow_succ`). See also the lemma\n`Polynomial.preHilbertPoly_eq_choose_sub_add`, which states that if `CharZero F`,\nthen for any `d k n : \u2115` with `k \u2264 n`, `(Polynomial.preHilbertPoly F d k).eval (n : F)`\nequals `(n - k + d).choose d`.\n-/\nnoncomputable def preHilbertPoly (d k : \u2115) : F[X] :=\n  (d.factorial : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (Polynomial.X - (C (k : F)) + 1))\n\nlemma natDegree_preHilbertPoly [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).natDegree = d := by\n  have hne : (d ! : F) \u2260 0 := by norm_cast; positivity\n  rw [preHilbertPoly, natDegree_smul _ (inv_ne_zero hne), natDegree_comp, ascPochhammer_natDegree,\n    add_comm_sub, \u2190 C_1, \u2190 map_sub, natDegree_add_C, natDegree_X, mul_one]\n\nlemma coeff_preHilbertPoly_self [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).coeff d = (d ! : F)\u207b\u00b9 := by\n  delta preHilbertPoly\n  have hne : (d ! : F) \u2260 0 := by norm_cast; positivity\n  have heq : d = ((ascPochhammer F d).comp (X - C (k : F) + 1)).natDegree :=\n    (natDegree_preHilbertPoly F d k).symm.trans (natDegree_smul _ (inv_ne_zero hne))\n  nth_rw 3 [heq]\n  calc\n  _ = (d ! : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (X - C ((k : F) - 1))).leadingCoeff := by\n    simp only [sub_add, \u2190 C_1, \u2190 map_sub, coeff_smul, coeff_natDegree]\n  _ = (d ! : F)\u207b\u00b9 := by\n    simp only [leadingCoeff_comp (ne_of_eq_of_ne (natDegree_X_sub_C _) one_ne_zero), Monic.def.1\n      (monic_ascPochhammer _ _), one_mul, leadingCoeff_X_sub_C, one_pow, smul_eq_mul, mul_one]\n\nlemma leadingCoeff_preHilbertPoly [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).leadingCoeff = (d ! : F)\u207b\u00b9 := by\n  rw [leadingCoeff, natDegree_preHilbertPoly, coeff_preHilbertPoly_self]\n\nlemma preHilbertPoly_eq_choose_sub_add [CharZero F] (d : \u2115) {k n : \u2115} (hkn : k \u2264 n):\n    (preHilbertPoly F d k).eval (n : F) = (n - k + d).choose d := by\n  have : (d ! : F) \u2260 0 := by norm_cast; positivity\n  calc\n  _ = (\u2191d !)\u207b\u00b9 * eval (\u2191(n - k + 1)) (ascPochhammer F d) := by simp [cast_sub hkn, preHilbertPoly]\n  _ = (n - k + d).choose d := by\n    rw [ascPochhammer_nat_eq_natCast_ascFactorial];\n    field_simp [ascFactorial_eq_factorial_mul_choose]\n\nvariable {F}\n\n/--\n`Polynomial.hilbertPoly p 0 = 0`; for any `d : \u2115`, `Polynomial.hilbertPoly p (d + 1)`\nis defined as `\u2211 i \u2208 p.support, (p.coeff i) \u2022 Polynomial.preHilbertPoly F d i`. If\n`M` is a graded module whose Poincar\u00e9 series can be written as `p(X)/(1 - X)\u1d48` for some\n`p : \u211a[X]` with integer coefficients, then `Polynomial.hilbertPoly p d` is the Hilbert\npolynomial of `M`. See also `Polynomial.coeff_mul_invOneSubPow_eq_hilbertPoly_eval`,\nwhich says that `PowerSeries.coeff F n (p * PowerSeries.invOneSubPow F d)` equals\n`(Polynomial.hilbertPoly p d).eval (n : F)` for any large enough `n : \u2115`.\n-/\nnoncomputable def hilbertPoly (p : F[X]) : (d : \u2115) \u2192 F[X]\n  | 0 => 0\n  | d + 1 => \u2211 i \u2208 p.support, (p.coeff i) \u2022 preHilbertPoly F d i\n\nlemma hilbertPoly_zero_left (d : \u2115) : hilbertPoly (0 : F[X]) d = 0 := by\n  delta hilbertPoly; induction d with\n  | zero => simp only\n  | succ d _ => simp only [coeff_zero, zero_smul, Finset.sum_const_zero]\n\nlemma hilbertPoly_zero_right (p : F[X]) : hilbertPoly p 0 = 0 := rfl\n\nlemma hilbertPoly_succ (p : F[X]) (d : \u2115) :\n    hilbertPoly p (d + 1) = \u2211 i \u2208 p.support, (p.coeff i) \u2022 preHilbertPoly F d i := rfl\n\nlemma hilbertPoly_X_pow_succ (d k : \u2115) :\n    hilbertPoly ((X : F[X]) ^ k) (d + 1) = preHilbertPoly F d k := by\n  delta hilbertPoly; simp\n\nlemma hilbertPoly_add_left (p q : F[X]) (d : \u2115) :\n    hilbertPoly (p + q) d = hilbertPoly p d + hilbertPoly q d := by\n  delta hilbertPoly\n  induction d with\n  | zero => simp only [add_zero]\n  | succ d _ =>\n      simp only [\u2190 coeff_add]\n      rw [\u2190 sum_def _ fun _ r => r \u2022 _]\n      exact sum_add_index _ _ _ (fun _ => zero_smul ..) (fun _ _ _ => add_smul ..)\n\nlemma hilbertPoly_smul (a : F) (p : F[X]) (d : \u2115) :\n    hilbertPoly (a \u2022 p) d = a \u2022 hilbertPoly p d := by\n  delta hilbertPoly\n  induction d with\n  | zero => simp only [smul_zero]\n  | succ d _ =>\n      simp only\n      rw [\u2190 sum_def _ fun _ r => r \u2022 _, \u2190 sum_def _ fun _ r => r \u2022 _, Polynomial.smul_sum,\n        sum_smul_index' _ _ _ fun i => zero_smul F (preHilbertPoly F d i)]\n      simp only [smul_assoc]\n\nvariable (F) in\n/--\nThe function that sends any `p : F[X]` to `Polynomial.hilbertPoly p d` is an `F`-linear map from\n`F[X]` to `F[X]`.\n-/\nnoncomputable def hilbertPoly_linearMap (d : \u2115) : F[X] \u2192\u2097[F] F[X] where\n  toFun p := hilbertPoly p d\n  map_add' p q := hilbertPoly_add_left p q d\n  map_smul' r p := hilbertPoly_smul r p d\n\nvariable [CharZero F]\n\n/--\nThe key property of Hilbert polynomials. If `F` is a field with characteristic `0`, `p : F[X]` and\n`d : \u2115`, then for any large enough `n : \u2115`, `(Polynomial.hilbertPoly p d).eval (n : F)` equals the\ncoefficient of `X\u207f` in the power series expansion of `p/(1 - X)\u1d48`.\n-/\ntheorem coeff_mul_invOneSubPow_eq_hilbertPoly_eval\n    {p : F[X]} (d : \u2115) {n : \u2115} (hn : p.natDegree < n) :\n    PowerSeries.coeff F n (p * invOneSubPow F d) = (hilbertPoly p d).eval (n : F) := by\n  delta hilbertPoly; induction d with\n  | zero => simp only [invOneSubPow_zero, Units.val_one, mul_one, coeff_coe, eval_zero]\n            exact coeff_eq_zero_of_natDegree_lt hn\n  | succ d hd =>\n      simp only [eval_finset_sum, eval_smul, smul_eq_mul]\n      rw [\u2190 Finset.sum_coe_sort]\n      have h_le (i : p.support) : (i : \u2115) \u2264 n :=\n        le_trans (le_natDegree_of_ne_zero <| mem_support_iff.1 i.2) hn.le\n      have h (i : p.support) : eval \u2191n (preHilbertPoly F d \u2191i) = (n + d - \u2191i).choose d := by\n        rw [preHilbertPoly_eq_choose_sub_add _ _ (h_le i), Nat.sub_add_comm (h_le i)]\n      simp_rw [h]\n      rw [Finset.sum_coe_sort _ (fun x => (p.coeff \u2191x) * (_ + d - \u2191x).choose _),\n        PowerSeries.coeff_mul, Finset.Nat.sum_antidiagonal_eq_sum_range_succ_mk,\n        invOneSubPow_val_eq_mk_sub_one_add_choose_of_pos _ _ (zero_lt_succ d)]\n      simp only [coeff_coe, coeff_mk]\n      symm\n      refine Finset.sum_subset_zero_on_sdiff (fun s hs \u21a6 ?_) (fun x hx \u21a6 ?_) (fun x hx \u21a6 ?_)\n      \u00b7 rw [Finset.mem_range_succ_iff]\n        exact h_le \u27e8s, hs\u27e9\n      \u00b7 simp only [Finset.mem_sdiff, mem_support_iff, not_not] at hx\n        rw [hx.2, zero_mul]\n      \u00b7 rw [add_comm, Nat.add_sub_assoc (h_le \u27e8x, hx\u27e9), succ_eq_add_one, add_tsub_cancel_right]\n\n", "theoremStatement": "/--\nThe polynomial satisfying the key property of `Polynomial.hilbertPoly p d` is unique.\n-/\ntheorem existsUnique_hilbertPoly (p : F[X]) (d : \u2115) :\n    \u2203! h : F[X], \u2203 N : \u2115, \u2200 n > N,\n    PowerSeries.coeff F n (p * invOneSubPow F d) = h.eval (n : F) ", "theoremName": "Polynomial.existsUnique_hilbertPoly", "fileCreated": {"commit": "561e050467d2caa2e4ea5d81ca62600bf268b747", "date": "2024-12-02"}, "theoremCreated": {"commit": "933ad5493803f4c495f252678466ede6e1e2ee79", "date": "2024-12-18"}, "file": "mathlib/Mathlib/RingTheory/Polynomial/HilbertPoly.lean", "module": "Mathlib.RingTheory.Polynomial.HilbertPoly", "jsonFile": "Mathlib.RingTheory.Polynomial.HilbertPoly.jsonl", "positionMetadata": {"lineInFile": 187, "tokenPositionInFile": 8660, "theoremPositionInFile": 12}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 67, "numPremises": 96}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  use hilbertPoly p d; constructor\n  \u00b7 use p.natDegree\n    exact fun n => coeff_mul_invOneSubPow_eq_hilbertPoly_eval d\n  \u00b7 rintro h \u27e8N, hhN\u27e9\n    apply eq_of_infinite_eval_eq h (hilbertPoly p d)\n    apply ((Set.Ioi_infinite (max N p.natDegree)).image cast_injective.injOn).mono\n    rintro x \u27e8n, hn, rfl\u27e9\n    simp only [Set.mem_Ioi, sup_lt_iff, Set.mem_setOf_eq] at hn \u22a2\n    rw [\u2190 coeff_mul_invOneSubPow_eq_hilbertPoly_eval d hn.2, hhN n hn.1]", "proofType": "tactic", "proofLengthLines": 9, "proofLengthTokens": 447}}
{"srcContext": "/-\nCopyright (c) 2024 Jo\u00ebl Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jo\u00ebl Riou\n-/\nimport Mathlib.Algebra.Homology.Embedding.Extend\nimport Mathlib.Algebra.Homology.Embedding.IsSupported\nimport Mathlib.Algebra.Homology.QuasiIso\n\n/-!\n# Homology of the extension of an homological complex\n\nGiven an embedding `e : c.Embedding c'` and `K : HomologicalComplex C c`, we shall\ncompute the homology of `K.extend e`. In degrees that are not in the image of `e.f`,\nthe homology is obviously zero. When `e.f j = j`, we construct an isomorphism\n`(K.extend e).homology j' \u2245 K.homology j`.\n\n-/\n\nopen CategoryTheory Limits Category\n\nnamespace HomologicalComplex\n\nvariable {\u03b9 \u03b9' : Type*} {c : ComplexShape \u03b9} {c' : ComplexShape \u03b9'}\n  {C : Type*} [Category C] [HasZeroMorphisms C]\n  [HasZeroObject C]\n\nvariable (K L M : HomologicalComplex C c) (\u03c6 : K \u27f6 L) (\u03c6' : L \u27f6 M) (e : c.Embedding c')\n\nnamespace extend\n\nsection HomologyData\n\nvariable {i j k : \u03b9} {i' j' k' : \u03b9'} (hj' : e.f j = j')\n  (hi : c.prev j = i) (hi' : c'.prev j' = i') (hk : c.next j = k) (hk' : c'.next j' = k')\n\ninclude hk hk' in\nlemma comp_d_eq_zero_iff \u2983W : C\u2984 (\u03c6 : W \u27f6 K.X j) :\n    \u03c6 \u226b K.d j k = 0 \u2194 \u03c6 \u226b (K.extendXIso e hj').inv \u226b (K.extend e).d j' k' = 0 := by\n  by_cases hjk : c.Rel j k\n  \u00b7 have hk' : e.f k = k' := by rw [\u2190 hk', \u2190 hj', c'.next_eq' (e.rel hjk)]\n    rw [K.extend_d_eq e hj' hk', Iso.inv_hom_id_assoc,\n      \u2190 cancel_mono (K.extendXIso e hk').inv, zero_comp, assoc]\n  \u00b7 simp only [K.shape _ _ hjk, comp_zero, true_iff]\n    rw [K.extend_d_from_eq_zero e j' k' j hj', comp_zero, comp_zero]\n    rw [hk]\n    exact hjk\n\ninclude hi hi' in\nlemma d_comp_eq_zero_iff \u2983W : C\u2984 (\u03c6 : K.X j \u27f6 W) :\n    K.d i j \u226b \u03c6 = 0 \u2194 (K.extend e).d i' j' \u226b (K.extendXIso e hj').hom \u226b \u03c6 = 0 := by\n  by_cases hij : c.Rel i j\n  \u00b7 have hi' : e.f i = i' := by rw [\u2190 hi', \u2190 hj', c'.prev_eq' (e.rel hij)]\n    rw [K.extend_d_eq e hi' hj', assoc, assoc, Iso.inv_hom_id_assoc,\n      \u2190 cancel_epi (K.extendXIso e hi').hom, comp_zero]\n  \u00b7 simp only [K.shape _ _ hij, zero_comp, true_iff]\n    rw [K.extend_d_to_eq_zero e i' j' j hj', zero_comp]\n    rw [hi]\n    exact hij\n\nnamespace leftHomologyData\n\nvariable (cone : KernelFork (K.d j k)) (hcone : IsLimit cone)\n\n/-- The kernel fork of `(K.extend e).d j' k'` that is deduced from a kernel\nfork of `K.d j k `. -/\n@[simp]\nnoncomputable def kernelFork : KernelFork ((K.extend e).d j' k') :=\n  KernelFork.of\u03b9 (cone.\u03b9 \u226b (extendXIso K e hj').inv)\n    (by rw [assoc, \u2190 comp_d_eq_zero_iff K e hj' hk hk' cone.\u03b9, cone.condition])\n\n/-- The limit kernel fork of `(K.extend e).d j' k'` that is deduced from a limit\nkernel fork of `K.d j k `. -/\nnoncomputable def isLimitKernelFork : IsLimit (kernelFork K e hj' hk hk' cone) :=\n  KernelFork.isLimitOfIsLimitOfIff hcone ((K.extend e).d j' k')\n    (extendXIso K e hj').symm (comp_d_eq_zero_iff K e hj' hk hk')\n\nvariable (cocone : CokernelCofork (hcone.lift (KernelFork.of\u03b9 (K.d i j) (K.d_comp_d i j k))))\n  (hcocone : IsColimit cocone)\n\ninclude hi hi' hcone in\n/-- Auxiliary lemma for `lift_d_comp_eq_zero_iff`. -/\nlemma lift_d_comp_eq_zero_iff' \u2983W : C\u2984 (f' : K.X i \u27f6 cone.pt)\n    (hf' : f' \u226b cone.\u03b9 = K.d i j)\n    (f'' : (K.extend e).X i' \u27f6 cone.pt)\n    (hf'' : f'' \u226b cone.\u03b9 \u226b (extendXIso K e hj').inv = (K.extend e).d i' j')\n    (\u03c6 : cone.pt \u27f6 W) :\n    f' \u226b \u03c6 = 0 \u2194 f'' \u226b \u03c6 = 0 := by\n  by_cases hij : c.Rel i j\n  \u00b7 have hi'' : e.f i = i' := by rw [\u2190 hi', \u2190 hj', c'.prev_eq' (e.rel hij)]\n    have : (K.extendXIso e hi'').hom \u226b f' = f'' := by\n      apply Fork.IsLimit.hom_ext hcone\n      rw [assoc, hf', \u2190 cancel_mono (extendXIso K e hj').inv, assoc, assoc, hf'',\n        K.extend_d_eq e hi'' hj']\n    rw [\u2190 cancel_epi (K.extendXIso e hi'').hom, comp_zero, \u2190 this, assoc]\n  \u00b7 have h\u2081 : f' = 0 := by\n      apply Fork.IsLimit.hom_ext hcone\n      simp only [zero_comp, hf', K.shape _ _ hij]\n    have h\u2082 : f'' = 0 := by\n      apply Fork.IsLimit.hom_ext hcone\n      dsimp\n      rw [\u2190 cancel_mono (extendXIso K e hj').inv, assoc, hf'', zero_comp, zero_comp,\n        K.extend_d_to_eq_zero e i' j' j hj']\n      rw [hi]\n      exact hij\n    simp [h\u2081, h\u2082]\n\ninclude hi hi' in\nlemma lift_d_comp_eq_zero_iff \u2983W : C\u2984 (\u03c6 : cone.pt \u27f6 W) :\n    hcone.lift (KernelFork.of\u03b9 (K.d i j) (K.d_comp_d i j k)) \u226b \u03c6 = 0 \u2194\n      ((isLimitKernelFork K e hj' hk hk' cone hcone).lift\n      (KernelFork.of\u03b9 ((K.extend e).d i' j') (d_comp_d _ _ _ _))) \u226b \u03c6 = 0 :=\n  lift_d_comp_eq_zero_iff' K e hj' hi hi' cone hcone _ (hcone.fac _ _) _\n    (IsLimit.fac _ _ WalkingParallelPair.zero) _\n\n/-- Auxiliary definition for `extend.leftHomologyData`. -/\nnoncomputable def cokernelCofork :\n    CokernelCofork ((isLimitKernelFork K e hj' hk hk' cone hcone).lift\n      (KernelFork.of\u03b9 ((K.extend e).d i' j') (d_comp_d _ _ _ _))) :=\n  CokernelCofork.of\u03c0 cocone.\u03c0 (by\n    rw [\u2190 lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' cone hcone]\n    exact cocone.condition)\n\n/-- Auxiliary definition for `extend.leftHomologyData`. -/\nnoncomputable def isColimitCokernelCofork :\n    IsColimit (cokernelCofork K e hj' hi hi' hk hk' cone hcone cocone) :=\n  CokernelCofork.isColimitOfIsColimitOfIff' hcocone _\n    (lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' cone hcone)\n\nend leftHomologyData\n\nopen leftHomologyData in\n/-- The left homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a left homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def leftHomologyData (h : (K.sc' i j k).LeftHomologyData) :\n    ((K.extend e).sc' i' j' k').LeftHomologyData where\n  K := h.K\n  H := h.H\n  i := h.i \u226b (extendXIso K e hj').inv\n  \u03c0 := h.\u03c0\n  wi := by\n    dsimp\n    rw [assoc, \u2190 comp_d_eq_zero_iff K e hj' hk hk']\n    exact h.wi\n  hi := isLimitKernelFork K e hj' hk hk' _ h.hi\n  w\u03c0 := by\n    dsimp\n    rw [\u2190 lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' _ h.hi]\n    exact h.w\u03c0\n  h\u03c0 := isColimitCokernelCofork K e hj' hi hi' hk hk' _ h.hi _ h.h\u03c0\n\nnamespace rightHomologyData\n\nvariable (cocone : CokernelCofork (K.d i j)) (hcocone : IsColimit cocone)\n\n/-- The cokernel cofork of `(K.extend e).d i' j'` that is deduced from a cokernel\ncofork of `K.d i j`. -/\n@[simp]\nnoncomputable def cokernelCofork : CokernelCofork ((K.extend e).d i' j') :=\n  CokernelCofork.of\u03c0 ((extendXIso K e hj').hom \u226b cocone.\u03c0) (by\n    rw [\u2190 d_comp_eq_zero_iff K e hj' hi hi' cocone.\u03c0, cocone.condition])\n\n/-- The colimit cokernel cofork of `(K.extend e).d i' j'` that is deduced from a\ncolimit cokernel cofork of `K.d i j`. -/\nnoncomputable def isColimitCokernelCofork : IsColimit (cokernelCofork K e hj' hi hi' cocone) :=\n  CokernelCofork.isColimitOfIsColimitOfIff hcocone ((K.extend e).d i' j')\n    (extendXIso K e hj') (d_comp_eq_zero_iff K e hj' hi hi')\n\nvariable (cone : KernelFork (hcocone.desc (CokernelCofork.of\u03c0 (K.d j k) (K.d_comp_d i j k))))\n  (hcone : IsLimit cone)\n\ninclude hk hk' hcocone in\nlemma d_comp_desc_eq_zero_iff' \u2983W : C\u2984 (f' : cocone.pt \u27f6 K.X k)\n    (hf' : cocone.\u03c0 \u226b f' = K.d j k)\n    (f'' : cocone.pt \u27f6 (K.extend e).X k')\n    (hf'' : (extendXIso K e hj').hom \u226b cocone.\u03c0 \u226b f'' = (K.extend e).d j' k')\n    (\u03c6 : W \u27f6 cocone.pt) :\n    \u03c6 \u226b f' = 0 \u2194 \u03c6 \u226b f'' = 0 := by\n  by_cases hjk : c.Rel j k\n  \u00b7 have hk'' : e.f k = k' := by rw [\u2190 hk', \u2190 hj', c'.next_eq' (e.rel hjk)]\n    have : f' \u226b (K.extendXIso e hk'').inv = f'' := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      rw [reassoc_of% hf', \u2190 cancel_epi (extendXIso K e hj').hom, hf'',\n        K.extend_d_eq e hj' hk'']\n    rw [\u2190 cancel_mono (K.extendXIso e hk'').inv, zero_comp, assoc, this]\n  \u00b7 have h\u2081 : f' = 0 := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      simp only [hf', comp_zero, K.shape _ _ hjk]\n    have h\u2082 : f'' = 0 := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      rw [\u2190 cancel_epi (extendXIso K e hj').hom, hf'', comp_zero, comp_zero,\n        K.extend_d_from_eq_zero e j' k' j hj']\n      rw [hk]\n      exact hjk\n    simp [h\u2081, h\u2082]\n\ninclude hk hk' in\nlemma d_comp_desc_eq_zero_iff \u2983W : C\u2984 (\u03c6 : W \u27f6 cocone.pt) :\n    \u03c6 \u226b hcocone.desc (CokernelCofork.of\u03c0 (K.d j k) (K.d_comp_d i j k)) = 0 \u2194\n      \u03c6 \u226b ((isColimitCokernelCofork K e hj' hi hi' cocone hcocone).desc\n      (CokernelCofork.of\u03c0 ((K.extend e).d j' k') (d_comp_d _ _ _ _))) = 0 :=\n  d_comp_desc_eq_zero_iff' K e hj' hk hk' cocone hcocone _ (hcocone.fac _ _) _ (by\n    simpa using (isColimitCokernelCofork K e hj' hi hi' cocone hcocone).fac _\n      WalkingParallelPair.one) _\n\n/-- Auxiliary definition for `extend.rightHomologyData`. -/\nnoncomputable def kernelFork :\n    KernelFork ((isColimitCokernelCofork K e hj' hi hi' cocone hcocone).desc\n      (CokernelCofork.of\u03c0 ((K.extend e).d j' k') (d_comp_d _ _ _ _))) :=\n  KernelFork.of\u03b9 cone.\u03b9 (by\n    rw [\u2190 d_comp_desc_eq_zero_iff K e hj' hi hi' hk hk' cocone hcocone]\n    exact cone.condition)\n\n/-- Auxiliary definition for `extend.rightHomologyData`. -/\nnoncomputable def isLimitKernelFork :\n    IsLimit (kernelFork K e hj' hi hi' hk hk' cocone hcocone cone) :=\n  KernelFork.isLimitOfIsLimitOfIff' hcone _\n    (d_comp_desc_eq_zero_iff K e hj' hi hi' hk hk' cocone hcocone)\n\nend rightHomologyData\n\nopen rightHomologyData in\n/-- The right homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a right homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def rightHomologyData (h : (K.sc' i j k).RightHomologyData) :\n    ((K.extend e).sc' i' j' k').RightHomologyData where\n  Q := h.Q\n  H := h.H\n  p := (extendXIso K e hj').hom \u226b h.p\n  \u03b9 := h.\u03b9\n  wp := by\n    dsimp\n    rw [\u2190 d_comp_eq_zero_iff K e hj' hi hi']\n    exact h.wp\n  hp := isColimitCokernelCofork K e hj' hi hi' _ h.hp\n  w\u03b9 := by\n    dsimp\n    rw [\u2190 d_comp_desc_eq_zero_iff K e hj' hi hi' hk hk' _ h.hp]\n    exact h.w\u03b9\n  h\u03b9 := isLimitKernelFork K e hj' hi hi' hk hk' _ h.hp _ h.h\u03b9\n\n/-- Computation of the `g'` field of `extend.rightHomologyData`. -/\nlemma rightHomologyData_g' (h : (K.sc' i j k).RightHomologyData) (hk'' : e.f k = k') :\n    (rightHomologyData K e hj' hi hi' hk hk' h).g' = h.g' \u226b (K.extendXIso e hk'').inv := by\n  rw [\u2190 cancel_epi h.p, \u2190 cancel_epi (extendXIso K e hj').hom]\n  have := (rightHomologyData K e hj' hi hi' hk hk' h).p_g'\n  dsimp at this\n  rw [assoc] at this\n  rw [this, K.extend_d_eq e hj' hk'', h.p_g'_assoc, shortComplexFunctor'_obj_g]\n\n/-- The homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def homologyData (h : (K.sc' i j k).HomologyData) :\n    ((K.extend e).sc' i' j' k').HomologyData where\n  left := leftHomologyData K e hj' hi hi' hk hk' h.left\n  right := rightHomologyData K e hj' hi hi' hk hk' h.right\n  iso := h.iso\n\n/-- The homology data of `(K.extend e).sc j'` that is deduced\nfrom a homology data of `K.sc' i j k`. -/\n@[simps!]\nnoncomputable def homologyData' (h : (K.sc' i j k).HomologyData) :\n    ((K.extend e).sc j').HomologyData :=\n  homologyData K e hj' hi rfl hk rfl h\n\nend HomologyData\n\nlemma hasHomology {j : \u03b9} {j' : \u03b9'} (hj' : e.f j = j') [K.HasHomology j] :\n    (K.extend e).HasHomology j' :=\n  ShortComplex.HasHomology.mk'\n    (homologyData' K e hj' rfl rfl ((K.sc j).homologyData))\n\ninstance (j : \u03b9) [K.HasHomology j] : (K.extend e).HasHomology (e.f j) :=\n  hasHomology K e rfl\n\ninstance [\u2200 j, K.HasHomology j] (j' : \u03b9') : (K.extend e).HasHomology j' := by\n  by_cases h : \u2203 j, e.f j = j'\n  \u00b7 obtain \u27e8j, rfl\u27e9 := h\n    infer_instance\n  \u00b7 have hj := isZero_extend_X K e j' (by tauto)\n    exact ShortComplex.HasHomology.mk'\n      (ShortComplex.HomologyData.ofZeros _ (hj.eq_of_tgt _ _) (hj.eq_of_src _ _))\n\nend extend\n\nlemma extend_exactAt (j' : \u03b9') (hj' : \u2200 j, e.f j \u2260 j') :\n    (K.extend e).ExactAt j' :=\n  exactAt_of_isSupported _ e j' hj'\n\nsection\n\nvariable {j : \u03b9} {j' : \u03b9'} (hj' : e.f j = j') [K.HasHomology j] [L.HasHomology j]\n  [(K.extend e).HasHomology j'] [(L.extend e).HasHomology j']\n\n/-- The isomorphism `(K.extend e).cycles j' \u2245 K.cycles j` when `e.f j = j'`. -/\nnoncomputable def extendCyclesIso :\n    (K.extend e).cycles j' \u2245 K.cycles j :=\n  (extend.homologyData' K e hj' rfl rfl (K.sc j).homologyData).left.cyclesIso \u226a\u226b\n    (K.sc j).homologyData.left.cyclesIso.symm\n\n/-- The isomorphism `(K.extend e).opcycles j' \u2245 K.opcycles j` when `e.f j = j'`. -/\nnoncomputable def extendOpcyclesIso :\n    (K.extend e).opcycles j' \u2245 K.opcycles j :=\n  (extend.homologyData' K e hj' rfl rfl (K.sc j).homologyData).right.opcyclesIso \u226a\u226b\n    (K.sc j).homologyData.right.opcyclesIso.symm\n\n/-- The isomorphism `(K.extend e).homology j' \u2245 K.homology j` when `e.f j = j'`. -/\nnoncomputable def extendHomologyIso :\n    (K.extend e).homology j' \u2245 K.homology j :=\n  (extend.homologyData' K e hj' rfl rfl (K.sc j).homologyData).left.homologyIso \u226a\u226b\n    (K.sc j).homologyData.left.homologyIso.symm\n\ninclude hj' in\nlemma extend_exactAt_iff :\n    (K.extend e).ExactAt j' \u2194 K.ExactAt j := by\n  simp only [HomologicalComplex.exactAt_iff_isZero_homology]\n  exact (K.extendHomologyIso e hj').isZero_iff\n\n@[reassoc (attr := simp)]\nlemma extendCyclesIso_hom_iCycles :\n    (K.extendCyclesIso e hj').hom \u226b K.iCycles j =\n      (K.extend e).iCycles j' \u226b (K.extendXIso e hj').hom := by\n  rw [\u2190 cancel_epi (K.extendCyclesIso e hj').inv, Iso.inv_hom_id_assoc]\n  dsimp [extendCyclesIso, iCycles]\n  rw [assoc, ShortComplex.LeftHomologyData.cyclesIso_inv_comp_iCycles_assoc]\n  dsimp\n  rw [assoc, Iso.inv_hom_id, comp_id,\n    ShortComplex.LeftHomologyData.cyclesIso_hom_comp_i]\n\n@[reassoc (attr := simp)]\nlemma extendCyclesIso_inv_iCycles :\n    (K.extendCyclesIso e hj').inv \u226b (K.extend e).iCycles j' =\n      K.iCycles j \u226b (K.extendXIso e hj').inv := by\n  simp only [\u2190 cancel_epi (K.extendCyclesIso e hj').hom, Iso.hom_inv_id_assoc,\n    extendCyclesIso_hom_iCycles_assoc, Iso.hom_inv_id, comp_id]\n\n@[reassoc (attr := simp)]\nlemma homology\u03c0_extendHomologyIso_hom :\n    (K.extend e).homology\u03c0 j' \u226b (K.extendHomologyIso e hj').hom =\n      (K.extendCyclesIso e hj').hom \u226b K.homology\u03c0 j := by\n  dsimp [extendHomologyIso, homology\u03c0]\n  rw [ShortComplex.LeftHomologyData.homology\u03c0_comp_homologyIso_hom_assoc,\n    \u2190 cancel_mono (K.sc j).homologyData.left.homologyIso.hom,\n    assoc, assoc, assoc, Iso.inv_hom_id, comp_id,\n    ShortComplex.LeftHomologyData.homology\u03c0_comp_homologyIso_hom]\n  dsimp [extendCyclesIso]\n  simp only [assoc, Iso.inv_hom_id_assoc]\n\n@[reassoc (attr := simp)]\nlemma homology\u03c0_extendHomologyIso_inv :\n    K.homology\u03c0 j \u226b (K.extendHomologyIso e hj').inv =\n      (K.extendCyclesIso e hj').inv \u226b (K.extend e).homology\u03c0 j' := by\n  simp only [\u2190 cancel_mono (K.extendHomologyIso e hj').hom,\n    assoc, Iso.inv_hom_id, comp_id, homology\u03c0_extendHomologyIso_hom, Iso.inv_hom_id_assoc]\n\n@[reassoc (attr := simp)]\nlemma pOpcycles_extendOpcyclesIso_inv :\n    K.pOpcycles j \u226b (K.extendOpcyclesIso e hj').inv =\n      (K.extendXIso e hj').inv \u226b (K.extend e).pOpcycles j' := by\n  rw [\u2190 cancel_mono (K.extendOpcyclesIso e hj').hom, assoc, assoc, Iso.inv_hom_id, comp_id]\n  dsimp [extendOpcyclesIso, pOpcycles]\n  rw [ShortComplex.RightHomologyData.pOpcycles_comp_opcyclesIso_hom_assoc]\n  dsimp\n  rw [assoc, Iso.inv_hom_id_assoc, ShortComplex.RightHomologyData.p_comp_opcyclesIso_inv]\n  rfl\n\n@[reassoc (attr := simp)]\nlemma pOpcycles_extendOpcyclesIso_hom :\n    (K.extend e).pOpcycles j' \u226b (K.extendOpcyclesIso e hj').hom =\n      (K.extendXIso e hj').hom \u226b K.pOpcycles j := by\n  simp only [\u2190 cancel_mono (K.extendOpcyclesIso e hj').inv,\n    assoc, Iso.hom_inv_id, comp_id, pOpcycles_extendOpcyclesIso_inv, Iso.hom_inv_id_assoc]\n\n@[reassoc (attr := simp)]\nlemma extendHomologyIso_hom_homology\u03b9 :\n    (K.extendHomologyIso e hj').hom \u226b K.homology\u03b9 j =\n      (K.extend e).homology\u03b9 j' \u226b (K.extendOpcyclesIso e hj').hom := by\n  simp only [\u2190 cancel_epi ((K.extend e).homology\u03c0 j'),\n    homology\u03c0_extendHomologyIso_hom_assoc, homology_\u03c0_\u03b9, extendCyclesIso_hom_iCycles_assoc,\n    homology_\u03c0_\u03b9_assoc, pOpcycles_extendOpcyclesIso_hom]\n\n@[reassoc (attr := simp)]\nlemma extendHomologyIso_inv_homology\u03b9 :\n    (K.extendHomologyIso e hj').inv \u226b (K.extend e).homology\u03b9 j' =\n      K.homology\u03b9 j \u226b (K.extendOpcyclesIso e hj').inv := by\n  simp only [\u2190 cancel_epi (K.extendHomologyIso e hj').hom,\n    Iso.hom_inv_id_assoc, extendHomologyIso_hom_homology\u03b9_assoc, Iso.hom_inv_id, comp_id]\n\nvariable {K L}\n\n@[reassoc (attr := simp)]\nlemma extendCyclesIso_hom_naturality :\n    cyclesMap (extendMap \u03c6 e) j' \u226b (L.extendCyclesIso e hj').hom =\n      (K.extendCyclesIso e hj').hom \u226b cyclesMap \u03c6 j := by\n  simp [\u2190 cancel_mono (L.iCycles j), extendMap_f \u03c6 e hj']\n\n@[reassoc (attr := simp)]\nlemma extendHomologyIso_hom_naturality :\n    homologyMap (extendMap \u03c6 e) j' \u226b (L.extendHomologyIso e hj').hom =\n      (K.extendHomologyIso e hj').hom \u226b homologyMap \u03c6 j := by\n  simp [\u2190 cancel_epi ((K.extend e).homology\u03c0 _)]\n\ninclude hj' in\nlemma quasiIsoAt_extendMap_iff :\n    QuasiIsoAt (extendMap \u03c6 e) j' \u2194 QuasiIsoAt \u03c6 j := by\n  simp only [quasiIsoAt_iff_isIso_homologyMap]\n  exact (MorphismProperty.isomorphisms C).arrow_mk_iso_iff\n    (Arrow.isoMk (K.extendHomologyIso e hj') (L.extendHomologyIso e hj'))\n\nend\n\n", "theoremStatement": "lemma quasiIso_extendMap_iff [\u2200 j, K.HasHomology j] [\u2200 j, L.HasHomology j] :\n    QuasiIso (extendMap \u03c6 e) \u2194 QuasiIso \u03c6 ", "theoremName": "HomologicalComplex.quasiIso_extendMap_iff", "fileCreated": {"commit": "9bdc1af76cf75d960f42c29f1c09917785066c8b", "date": "2024-11-30"}, "theoremCreated": {"commit": "b07a551a1451cbf8615f4e2a6c47052affadbae4", "date": "2025-01-17"}, "file": "mathlib/Mathlib/Algebra/Homology/Embedding/ExtendHomology.lean", "module": "Mathlib.Algebra.Homology.Embedding.ExtendHomology", "jsonFile": "Mathlib.Algebra.Homology.Embedding.ExtendHomology.jsonl", "positionMetadata": {"lineInFile": 415, "tokenPositionInFile": 16846, "theoremPositionInFile": 33}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 23, "numPremises": 44}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp only [quasiIso_iff, \u2190 fun j \u21a6 quasiIsoAt_extendMap_iff \u03c6 e (j := j) (hj' := rfl)]\n  constructor\n  \u00b7 tauto\n  \u00b7 intro h j'\n    by_cases hj' : \u2203 j, e.f j = j'\n    \u00b7 obtain \u27e8j, rfl\u27e9 := hj'\n      exact h j\n    \u00b7 rw [quasiIsoAt_iff_exactAt]\n      all_goals\n        exact extend_exactAt _ _ _ (by simpa using hj')", "proofType": "tactic", "proofLengthLines": 10, "proofLengthTokens": 319}}
{"srcContext": "/-\nCopyright (c) 2020 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kevin Buzzard, Johan Commelin, Patrick Massot\n-/\nimport Mathlib.Algebra.Order.Hom.Monoid\nimport Mathlib.Algebra.Order.Ring.Basic\nimport Mathlib.RingTheory.Ideal.Maps\nimport Mathlib.Tactic.TFAE\n\n/-!\n\n# The basics of valuation theory.\n\nThe basic theory of valuations (non-archimedean norms) on a commutative ring,\nfollowing T. Wedhorn's unpublished notes \u201cAdic Spaces\u201d ([wedhorn_adic]).\n\nThe definition of a valuation we use here is Definition 1.22 of [wedhorn_adic].\nA valuation on a ring `R` is a monoid homomorphism `v` to a linearly ordered\ncommutative monoid with zero, that in addition satisfies the following two axioms:\n * `v 0 = 0`\n * `\u2200 x y, v (x + y) \u2264 max (v x) (v y)`\n\n`Valuation R \u0393\u2080`is the type of valuations `R \u2192 \u0393\u2080`, with a coercion to the underlying\nfunction. If `v` is a valuation from `R` to `\u0393\u2080` then the induced group\nhomomorphism `Units(R) \u2192 \u0393\u2080` is called `unit_map v`.\n\nThe equivalence \"relation\" `IsEquiv v\u2081 v\u2082 : Prop` defined in 1.27 of [wedhorn_adic] is not strictly\nspeaking a relation, because `v\u2081 : Valuation R \u0393\u2081` and `v\u2082 : Valuation R \u0393\u2082` might\nnot have the same type. This corresponds in ZFC to the set-theoretic difficulty\nthat the class of all valuations (as `\u0393\u2080` varies) on a ring `R` is not a set.\nThe \"relation\" is however reflexive, symmetric and transitive in the obvious\nsense. Note that we use 1.27(iii) of [wedhorn_adic] as the definition of equivalence.\n\n## Main definitions\n\n* `Valuation R \u0393\u2080`, the type of valuations on `R` with values in `\u0393\u2080`\n* `Valuation.IsEquiv`, the heterogeneous equivalence relation on valuations\n* `Valuation.supp`, the support of a valuation\n\n* `AddValuation R \u0393\u2080`, the type of additive valuations on `R` with values in a\n  linearly ordered additive commutative group with a top element, `\u0393\u2080`.\n\n## Implementation Details\n\n`AddValuation R \u0393\u2080` is implemented as `Valuation R (Multiplicative \u0393\u2080)\u1d52\u1d48`.\n\n## Notation\n\nIn the `DiscreteValuation` locale:\n\n * `\u2115\u2098\u2080` is a shorthand for `WithZero (Multiplicative \u2115)`\n * `\u2124\u2098\u2080` is a shorthand for `WithZero (Multiplicative \u2124)`\n\n## TODO\n\nIf ever someone extends `Valuation`, we should fully comply to the `DFunLike` by migrating the\nboilerplate lemmas to `ValuationClass`.\n-/\n\nopen Function Ideal\n\nnoncomputable section\n\nvariable {K F R : Type*} [DivisionRing K]\n\nsection\n\nvariable (F R) (\u0393\u2080 : Type*) [LinearOrderedCommMonoidWithZero \u0393\u2080] [Ring R]\n\n/-- The type of `\u0393\u2080`-valued valuations on `R`.\n\nWhen you extend this structure, make sure to extend `ValuationClass`. -/\nstructure Valuation extends R \u2192*\u2080 \u0393\u2080 where\n  /-- The valuation of a a sum is less that the sum of the valuations -/\n  map_add_le_max' : \u2200 x y, toFun (x + y) \u2264 max (toFun x) (toFun y)\n\n/-- `ValuationClass F \u03b1 \u03b2` states that `F` is a type of valuations.\n\nYou should also extend this typeclass when you extend `Valuation`. -/\nclass ValuationClass (F) (R \u0393\u2080 : outParam Type*) [LinearOrderedCommMonoidWithZero \u0393\u2080] [Ring R]\n  [FunLike F R \u0393\u2080]\n  extends MonoidWithZeroHomClass F R \u0393\u2080 : Prop where\n  /-- The valuation of a a sum is less that the sum of the valuations -/\n  map_add_le_max (f : F) (x y : R) : f (x + y) \u2264 max (f x) (f y)\n\nexport ValuationClass (map_add_le_max)\n\ninstance [FunLike F R \u0393\u2080] [ValuationClass F R \u0393\u2080] : CoeTC F (Valuation R \u0393\u2080) :=\n  \u27e8fun f =>\n    { toFun := f\n      map_one' := map_one f\n      map_zero' := map_zero f\n      map_mul' := map_mul f\n      map_add_le_max' := map_add_le_max f }\u27e9\n\nend\n\nnamespace Valuation\n\nvariable {\u0393\u2080 : Type*}\nvariable {\u0393'\u2080 : Type*}\nvariable {\u0393''\u2080 : Type*} [LinearOrderedCommMonoidWithZero \u0393''\u2080]\n\nsection Basic\n\nvariable [Ring R]\n\nsection Monoid\n\nvariable [LinearOrderedCommMonoidWithZero \u0393\u2080] [LinearOrderedCommMonoidWithZero \u0393'\u2080]\n\ninstance : FunLike (Valuation R \u0393\u2080) R \u0393\u2080 where\n  coe f := f.toFun\n  coe_injective' f g h := by\n    obtain \u27e8\u27e8\u27e8_,_\u27e9, _\u27e9, _\u27e9 := f\n    congr\n\ninstance : ValuationClass (Valuation R \u0393\u2080) R \u0393\u2080 where\n  map_mul f := f.map_mul'\n  map_one f := f.map_one'\n  map_zero f := f.map_zero'\n  map_add_le_max f := f.map_add_le_max'\n\n@[simp]\ntheorem coe_mk (f : R \u2192*\u2080 \u0393\u2080) (h) : \u21d1(Valuation.mk f h) = f := rfl\n\ntheorem toFun_eq_coe (v : Valuation R \u0393\u2080) : v.toFun = v := rfl\n\n@[simp]\ntheorem toMonoidWithZeroHom_coe_eq_coe (v : Valuation R \u0393\u2080) :\n    (v.toMonoidWithZeroHom : R \u2192 \u0393\u2080) = v := rfl\n\n@[ext]\ntheorem ext {v\u2081 v\u2082 : Valuation R \u0393\u2080} (h : \u2200 r, v\u2081 r = v\u2082 r) : v\u2081 = v\u2082 :=\n  DFunLike.ext _ _ h\n\nvariable (v : Valuation R \u0393\u2080)\n\n@[simp, norm_cast]\ntheorem coe_coe : \u21d1(v : R \u2192*\u2080 \u0393\u2080) = v := rfl\n\ntheorem map_zero : v 0 = 0 :=\n  v.map_zero'\n\ntheorem map_one : v 1 = 1 :=\n  v.map_one'\n\ntheorem map_mul : \u2200 x y, v (x * y) = v x * v y :=\n  v.map_mul'\n\n-- Porting note: LHS side simplified so created map_add'\ntheorem map_add : \u2200 x y, v (x + y) \u2264 max (v x) (v y) :=\n  v.map_add_le_max'\n\n@[simp]\ntheorem map_add' : \u2200 x y, v (x + y) \u2264 v x \u2228 v (x + y) \u2264 v y := by\n  intro x y\n  rw [\u2190 le_max_iff, \u2190 ge_iff_le]\n  apply map_add\n\ntheorem map_add_le {x y g} (hx : v x \u2264 g) (hy : v y \u2264 g) : v (x + y) \u2264 g :=\n  le_trans (v.map_add x y) <| max_le hx hy\n\ntheorem map_add_lt {x y g} (hx : v x < g) (hy : v y < g) : v (x + y) < g :=\n  lt_of_le_of_lt (v.map_add x y) <| max_lt hx hy\n\ntheorem map_sum_le {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hf : \u2200 i \u2208 s, v (f i) \u2264 g) :\n    v (\u2211 i \u2208 s, f i) \u2264 g := by\n  classical\n  refine\n    Finset.induction_on s (fun _ => v.map_zero \u25b8 zero_le')\n      (fun a s has ih hf => ?_) hf\n  rw [Finset.forall_mem_insert] at hf; rw [Finset.sum_insert has]\n  exact v.map_add_le hf.1 (ih hf.2)\n\ntheorem map_sum_lt {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hg : g \u2260 0)\n    (hf : \u2200 i \u2208 s, v (f i) < g) : v (\u2211 i \u2208 s, f i) < g := by\n  classical\n  refine\n    Finset.induction_on s (fun _ => v.map_zero \u25b8 (zero_lt_iff.2 hg))\n      (fun a s has ih hf => ?_) hf\n  rw [Finset.forall_mem_insert] at hf; rw [Finset.sum_insert has]\n  exact v.map_add_lt hf.1 (ih hf.2)\n\ntheorem map_sum_lt' {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hg : 0 < g)\n    (hf : \u2200 i \u2208 s, v (f i) < g) : v (\u2211 i \u2208 s, f i) < g :=\n  v.map_sum_lt (ne_of_gt hg) hf\n\ntheorem map_pow : \u2200 (x) (n : \u2115), v (x ^ n) = v x ^ n :=\n  v.toMonoidWithZeroHom.toMonoidHom.map_pow\n\n-- The following definition is not an instance, because we have more than one `v` on a given `R`.\n-- In addition, type class inference would not be able to infer `v`.\n/-- A valuation gives a preorder on the underlying ring. -/\ndef toPreorder : Preorder R :=\n  Preorder.lift v\n\n/-- If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. -/\ntheorem zero_iff [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) {x : K} : v x = 0 \u2194 x = 0 :=\n  map_eq_zero v\n\ntheorem ne_zero_iff [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) {x : K} : v x \u2260 0 \u2194 x \u2260 0 :=\n  map_ne_zero v\n\nlemma pos_iff [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) {x : K} : 0 < v x \u2194 x \u2260 0 := by\n  rw [zero_lt_iff, ne_zero_iff]\n\ntheorem unit_map_eq (u : R\u02e3) : (Units.map (v : R \u2192* \u0393\u2080) u : \u0393\u2080) = v u :=\n  rfl\n\ntheorem ne_zero_of_unit [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) (x : K\u02e3) : v x \u2260 (0 : \u0393\u2080) := by\n  simp only [ne_eq, Valuation.zero_iff, Units.ne_zero x, not_false_iff]\n\ntheorem ne_zero_of_isUnit [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) (x : K) (hx : IsUnit x) :\n    v x \u2260 (0 : \u0393\u2080) := by\n  simpa [hx.choose_spec] using ne_zero_of_unit v hx.choose\n\n/-- A ring homomorphism `S \u2192 R` induces a map `Valuation R \u0393\u2080 \u2192 Valuation S \u0393\u2080`. -/\ndef comap {S : Type*} [Ring S] (f : S \u2192+* R) (v : Valuation R \u0393\u2080) : Valuation S \u0393\u2080 :=\n  { v.toMonoidWithZeroHom.comp f.toMonoidWithZeroHom with\n    toFun := v \u2218 f\n    map_add_le_max' := fun x y => by simp only [comp_apply, map_add, f.map_add] }\n\n@[simp]\ntheorem comap_apply {S : Type*} [Ring S] (f : S \u2192+* R) (v : Valuation R \u0393\u2080) (s : S) :\n    v.comap f s = v (f s) := rfl\n\n@[simp]\ntheorem comap_id : v.comap (RingHom.id R) = v :=\n  ext fun _r => rfl\n\ntheorem comap_comp {S\u2081 : Type*} {S\u2082 : Type*} [Ring S\u2081] [Ring S\u2082] (f : S\u2081 \u2192+* S\u2082) (g : S\u2082 \u2192+* R) :\n    v.comap (g.comp f) = (v.comap g).comap f :=\n  ext fun _r => rfl\n\n/-- A `\u2264`-preserving group homomorphism `\u0393\u2080 \u2192 \u0393'\u2080` induces a map `Valuation R \u0393\u2080 \u2192 Valuation R \u0393'\u2080`.\n-/\ndef map (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080) (hf : Monotone f) (v : Valuation R \u0393\u2080) : Valuation R \u0393'\u2080 :=\n  { MonoidWithZeroHom.comp f v.toMonoidWithZeroHom with\n    toFun := f \u2218 v\n    map_add_le_max' := fun r s =>\n      calc\n        f (v (r + s)) \u2264 f (max (v r) (v s)) := hf (v.map_add r s)\n        _ = max (f (v r)) (f (v s)) := hf.map_max\n         }\n\n@[simp]\nlemma map_apply (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080) (hf : Monotone f) (v : Valuation R \u0393\u2080) (r : R) :\n    v.map f hf r = f (v r) := rfl\n\n/-- Two valuations on `R` are defined to be equivalent if they induce the same preorder on `R`. -/\ndef IsEquiv (v\u2081 : Valuation R \u0393\u2080) (v\u2082 : Valuation R \u0393'\u2080) : Prop :=\n  \u2200 r s, v\u2081 r \u2264 v\u2081 s \u2194 v\u2082 r \u2264 v\u2082 s\n\n@[simp]\ntheorem map_neg (x : R) : v (-x) = v x :=\n  v.toMonoidWithZeroHom.toMonoidHom.map_neg x\n\ntheorem map_sub_swap (x y : R) : v (x - y) = v (y - x) :=\n  v.toMonoidWithZeroHom.toMonoidHom.map_sub_swap x y\n\ntheorem map_sub (x y : R) : v (x - y) \u2264 max (v x) (v y) :=\n  calc\n    v (x - y) = v (x + -y) := by rw [sub_eq_add_neg]\n    _ \u2264 max (v x) (v <| -y) := v.map_add _ _\n    _ = max (v x) (v y) := by rw [map_neg]\n\ntheorem map_sub_le {x y g} (hx : v x \u2264 g) (hy : v y \u2264 g) : v (x - y) \u2264 g := by\n  rw [sub_eq_add_neg]\n  exact v.map_add_le hx (le_trans (le_of_eq (v.map_neg y)) hy)\n\nvariable {x y : R}\n\ntheorem map_add_of_distinct_val (h : v x \u2260 v y) : v (x + y) = max (v x) (v y) := by\n  suffices \u00acv (x + y) < max (v x) (v y) from\n    or_iff_not_imp_right.1 (le_iff_eq_or_lt.1 (v.map_add x y)) this\n  intro h'\n  wlog vyx : v y < v x generalizing x y\n  \u00b7 refine this h.symm ?_ (h.lt_or_lt.resolve_right vyx)\n    rwa [add_comm, max_comm]\n  rw [max_eq_left_of_lt vyx] at h'\n  apply lt_irrefl (v x)\n  calc\n    v x = v (x + y - y) := by simp\n    _ \u2264 max (v <| x + y) (v y) := map_sub _ _ _\n    _ < v x := max_lt h' vyx\n\ntheorem map_add_eq_of_lt_right (h : v x < v y) : v (x + y) = v y :=\n  (v.map_add_of_distinct_val h.ne).trans (max_eq_right_iff.mpr h.le)\n\ntheorem map_add_eq_of_lt_left (h : v y < v x) : v (x + y) = v x := by\n  rw [add_comm]; exact map_add_eq_of_lt_right _ h\n\ntheorem map_sub_eq_of_lt_right (h : v x < v y) : v (x - y) = v y := by\n  rw [sub_eq_add_neg, map_add_eq_of_lt_right, map_neg]\n  rwa [map_neg]\n\nopen scoped Classical in\ntheorem map_sum_eq_of_lt {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {j : \u03b9}\n    (hj : j \u2208 s) (h0 : v (f j) \u2260 0) (hf : \u2200 i \u2208 s \\ {j}, v (f i) < v (f j)) :\n    v (\u2211 i \u2208 s, f i) = v (f j) := by\n  rw [Finset.sum_eq_add_sum_diff_singleton hj]\n  exact map_add_eq_of_lt_left _ (map_sum_lt _ h0 hf)\n\ntheorem map_sub_eq_of_lt_left (h : v y < v x) : v (x - y) = v x := by\n  rw [sub_eq_add_neg, map_add_eq_of_lt_left]\n  rwa [map_neg]\n\ntheorem map_eq_of_sub_lt (h : v (y - x) < v x) : v y = v x := by\n  have := Valuation.map_add_of_distinct_val v (ne_of_gt h).symm\n  rw [max_eq_right (le_of_lt h)] at this\n  simpa using this\n\ntheorem map_one_add_of_lt (h : v x < 1) : v (1 + x) = 1 := by\n  rw [\u2190 v.map_one] at h\n  simpa only [v.map_one] using v.map_add_eq_of_lt_left h\n\ntheorem map_one_sub_of_lt (h : v x < 1) : v (1 - x) = 1 := by\n  rw [\u2190 v.map_one, \u2190 v.map_neg] at h\n  rw [sub_eq_add_neg 1 x]\n  simpa only [v.map_one, v.map_neg] using v.map_add_eq_of_lt_left h\n\n/-- An ordered monoid isomorphism `\u0393\u2080 \u2243 \u0393'\u2080` induces an equivalence\n`Valuation R \u0393\u2080 \u2243 Valuation R \u0393'\u2080`. -/\ndef congr (f : \u0393\u2080 \u2243*o \u0393'\u2080) : Valuation R \u0393\u2080 \u2243 Valuation R \u0393'\u2080 where\n  toFun := map f f.toOrderIso.monotone\n  invFun := map f.symm f.toOrderIso.symm.monotone\n  left_inv \u03bd := by ext; simp\n  right_inv \u03bd := by ext; simp\n\nend Monoid\n\nsection Group\n\nvariable [LinearOrderedCommGroupWithZero \u0393\u2080] (v : Valuation R \u0393\u2080) {x y : R}\n\ntheorem map_inv {R : Type*} [DivisionRing R] (v : Valuation R \u0393\u2080) : \u2200 x, v x\u207b\u00b9 = (v x)\u207b\u00b9 :=\n  map_inv\u2080 _\n\ntheorem map_div {R : Type*} [DivisionRing R] (v : Valuation R \u0393\u2080) : \u2200 x y, v (x / y) = v x / v y :=\n  map_div\u2080 _\n\ntheorem one_lt_val_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : 1 < v x \u2194 v x\u207b\u00b9 < 1 := by\n  simp [inv_lt_one\u2080 (v.pos_iff.2 h)]\n\ntheorem one_le_val_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : 1 \u2264 v x \u2194 v x\u207b\u00b9 \u2264 1 := by\n  simp [inv_le_one\u2080 (v.pos_iff.2 h)]\n\ntheorem val_lt_one_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : v x < 1 \u2194 1 < v x\u207b\u00b9 := by\n  simp [one_lt_inv\u2080 (v.pos_iff.2 h)]\n\ntheorem val_le_one_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : v x \u2264 1 \u2194 1 \u2264 v x\u207b\u00b9 := by\n  simp [one_le_inv\u2080 (v.pos_iff.2 h)]\n\ntheorem val_eq_one_iff (v : Valuation K \u0393\u2080) {x : K} : v x = 1 \u2194 v x\u207b\u00b9 = 1 := by\n  by_cases h : x = 0\n  \u00b7 simp only [map_inv\u2080, inv_eq_one]\n  \u00b7 simpa only [le_antisymm_iff, And.comm] using and_congr (one_le_val_iff v h) (val_le_one_iff v h)\n\ntheorem val_le_one_or_val_inv_lt_one (v : Valuation K \u0393\u2080) (x : K) : v x \u2264 1 \u2228 v x\u207b\u00b9 < 1 := by\n  by_cases h : x = 0\n  \u00b7 simp only [h, _root_.map_zero, zero_le', inv_zero, zero_lt_one, or_self]\n  \u00b7 simp only [\u2190 one_lt_val_iff v h, le_or_lt]\n\n/--\nThis theorem is a weaker version of `Valuation.val_le_one_or_val_inv_lt_one`, but more symmetric\nin `x` and `x\u207b\u00b9`.\n-/\ntheorem val_le_one_or_val_inv_le_one (v : Valuation K \u0393\u2080) (x : K) : v x \u2264 1 \u2228 v x\u207b\u00b9 \u2264 1 := by\n  by_cases h : x = 0\n  \u00b7 simp only [h, _root_.map_zero, zero_le', inv_zero, or_self]\n  \u00b7 simp only [\u2190 one_le_val_iff v h, le_total]\n\n/-- The subgroup of elements whose valuation is less than a certain unit. -/\ndef ltAddSubgroup (v : Valuation R \u0393\u2080) (\u03b3 : \u0393\u2080\u02e3) : AddSubgroup R where\n  carrier := { x | v x < \u03b3 }\n  zero_mem' := by simp\n  add_mem' {x y} x_in y_in := lt_of_le_of_lt (v.map_add x y) (max_lt x_in y_in)\n  neg_mem' x_in := by rwa [Set.mem_setOf, map_neg]\n\nend Group\n\nend Basic\n\n-- end of section\nnamespace IsEquiv\n\nvariable [Ring R] [LinearOrderedCommMonoidWithZero \u0393\u2080] [LinearOrderedCommMonoidWithZero \u0393'\u2080]\n  {v : Valuation R \u0393\u2080} {v\u2081 : Valuation R \u0393\u2080} {v\u2082 : Valuation R \u0393'\u2080} {v\u2083 : Valuation R \u0393''\u2080}\n\n@[refl]\ntheorem refl : v.IsEquiv v := fun _ _ => Iff.refl _\n\n@[symm]\ntheorem symm (h : v\u2081.IsEquiv v\u2082) : v\u2082.IsEquiv v\u2081 := fun _ _ => Iff.symm (h _ _)\n\n@[trans]\ntheorem trans (h\u2081\u2082 : v\u2081.IsEquiv v\u2082) (h\u2082\u2083 : v\u2082.IsEquiv v\u2083) : v\u2081.IsEquiv v\u2083 := fun _ _ =>\n  Iff.trans (h\u2081\u2082 _ _) (h\u2082\u2083 _ _)\n\ntheorem of_eq {v' : Valuation R \u0393\u2080} (h : v = v') : v.IsEquiv v' := by subst h; rfl\n\ntheorem map {v' : Valuation R \u0393\u2080} (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080) (hf : Monotone f) (inf : Injective f)\n    (h : v.IsEquiv v') : (v.map f hf).IsEquiv (v'.map f hf) :=\n  let H : StrictMono f := hf.strictMono_of_injective inf\n  fun r s =>\n  calc\n    f (v r) \u2264 f (v s) \u2194 v r \u2264 v s := by rw [H.le_iff_le]\n    _ \u2194 v' r \u2264 v' s := h r s\n    _ \u2194 f (v' r) \u2264 f (v' s) := by rw [H.le_iff_le]\n\n/-- `comap` preserves equivalence. -/\ntheorem comap {S : Type*} [Ring S] (f : S \u2192+* R) (h : v\u2081.IsEquiv v\u2082) :\n    (v\u2081.comap f).IsEquiv (v\u2082.comap f) := fun r s => h (f r) (f s)\n\ntheorem val_eq (h : v\u2081.IsEquiv v\u2082) {r s : R} : v\u2081 r = v\u2081 s \u2194 v\u2082 r = v\u2082 s := by\n  simpa only [le_antisymm_iff] using and_congr (h r s) (h s r)\n\ntheorem ne_zero (h : v\u2081.IsEquiv v\u2082) {r : R} : v\u2081 r \u2260 0 \u2194 v\u2082 r \u2260 0 := by\n  have : v\u2081 r \u2260 v\u2081 0 \u2194 v\u2082 r \u2260 v\u2082 0 := not_congr h.val_eq\n  rwa [v\u2081.map_zero, v\u2082.map_zero] at this\n\nend IsEquiv\n\n-- end of namespace\nsection\n\ntheorem isEquiv_of_map_strictMono [LinearOrderedCommMonoidWithZero \u0393\u2080]\n    [LinearOrderedCommMonoidWithZero \u0393'\u2080] [Ring R] {v : Valuation R \u0393\u2080} (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080)\n    (H : StrictMono f) : IsEquiv (v.map f H.monotone) v := fun _x _y =>\n  \u27e8H.le_iff_le.mp, fun h => H.monotone h\u27e9\n\ntheorem isEquiv_iff_val_lt_val [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x y : K}, v x < v y \u2194 v' x < v' y := by\n  simp only [IsEquiv, le_iff_le_iff_lt_iff_lt]\n  exact forall_comm\n\nalias \u27e8IsEquiv.lt_iff_lt, _\u27e9 := isEquiv_iff_val_lt_val\n\ntheorem isEquiv_of_val_le_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080}\n    (h : \u2200 {x : K}, v x \u2264 1 \u2194 v' x \u2264 1) : v.IsEquiv v' := by\n  intro x y\n  obtain rfl | hy := eq_or_ne y 0\n  \u00b7 simp\n  \u00b7 rw [\u2190 div_le_one\u2080, \u2190 v.map_div, h, v'.map_div, div_le_one\u2080] <;>\n      rwa [zero_lt_iff, ne_zero_iff]\n\ntheorem isEquiv_iff_val_le_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v x \u2264 1 \u2194 v' x \u2264 1 :=\n  \u27e8fun h x => by simpa using h x 1, isEquiv_of_val_le_one\u27e9\n\nalias \u27e8IsEquiv.le_one_iff_le_one, _\u27e9 := isEquiv_iff_val_le_one\n\ntheorem isEquiv_iff_val_eq_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v x = 1 \u2194 v' x = 1 := by\n  constructor\n  \u00b7 intro h x\n    simpa using @IsEquiv.val_eq _ _ _ _ _ _ v v' h x 1\n  \u00b7 intro h\n    apply isEquiv_of_val_le_one\n    intro x\n    constructor\n    \u00b7 intro hx\n      rcases lt_or_eq_of_le hx with hx' | hx'\n      \u00b7 have : v (1 + x) = 1 := by\n          rw [\u2190 v.map_one]\n          apply map_add_eq_of_lt_left\n          simpa\n        rw [h] at this\n        rw [show x = -1 + (1 + x) by simp]\n        refine le_trans (v'.map_add _ _) ?_\n        simp [this]\n      \u00b7 rw [h] at hx'\n        exact le_of_eq hx'\n    \u00b7 intro hx\n      rcases lt_or_eq_of_le hx with hx' | hx'\n      \u00b7 have : v' (1 + x) = 1 := by\n          rw [\u2190 v'.map_one]\n          apply map_add_eq_of_lt_left\n          simpa\n        rw [\u2190 h] at this\n        rw [show x = -1 + (1 + x) by simp]\n        refine le_trans (v.map_add _ _) ?_\n        simp [this]\n      \u00b7 rw [\u2190 h] at hx'\n        exact le_of_eq hx'\n\nalias \u27e8IsEquiv.eq_one_iff_eq_one, _\u27e9 := isEquiv_iff_val_eq_one\n\ntheorem isEquiv_iff_val_lt_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v x < 1 \u2194 v' x < 1 := by\n  constructor\n  \u00b7 intro h x\n    simp only [lt_iff_le_and_ne,\n      and_congr h.le_one_iff_le_one h.eq_one_iff_eq_one.not]\n  \u00b7 rw [isEquiv_iff_val_eq_one]\n    intro h x\n    by_cases hx : x = 0\n    \u00b7 simp only [(zero_iff _).2 hx, zero_ne_one]\n    constructor\n    \u00b7 intro hh\n      by_contra h_1\n      cases ne_iff_lt_or_gt.1 h_1 with\n      | inl h_2 => simpa [hh, lt_self_iff_false] using h.2 h_2\n      | inr h_2 =>\n          rw [\u2190 inv_one, \u2190 inv_eq_iff_eq_inv, \u2190 map_inv\u2080] at hh\n          exact hh.not_lt (h.2 ((one_lt_val_iff v' hx).1 h_2))\n    \u00b7 intro hh\n      by_contra h_1\n      cases ne_iff_lt_or_gt.1 h_1 with\n      | inl h_2 => simpa [hh, lt_self_iff_false] using h.1 h_2\n      | inr h_2 =>\n        rw [\u2190 inv_one, \u2190 inv_eq_iff_eq_inv, \u2190 map_inv\u2080] at hh\n        exact hh.not_lt (h.1 ((one_lt_val_iff v hx).1 h_2))\n\nalias \u27e8IsEquiv.lt_one_iff_lt_one, _\u27e9 := isEquiv_iff_val_lt_one\n\ntheorem isEquiv_iff_val_sub_one_lt_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v (x - 1) < 1 \u2194 v' (x - 1) < 1 := by\n  rw [isEquiv_iff_val_lt_one]\n  exact (Equiv.subRight 1).surjective.forall\n\nalias \u27e8IsEquiv.val_sub_one_lt_one_iff, _\u27e9 := isEquiv_iff_val_sub_one_lt_one\n\ntheorem isEquiv_tfae [LinearOrderedCommGroupWithZero \u0393\u2080] [LinearOrderedCommGroupWithZero \u0393'\u2080]\n    (v : Valuation K \u0393\u2080) (v' : Valuation K \u0393'\u2080) :\n    [ v.IsEquiv v',\n      \u2200 {x y}, v x < v y \u2194 v' x < v' y,\n      \u2200 {x}, v x \u2264 1 \u2194 v' x \u2264 1,\n      \u2200 {x}, v x = 1 \u2194 v' x = 1,\n      \u2200 {x}, v x < 1 \u2194 v' x < 1,\n      \u2200 {x}, v (x - 1) < 1 \u2194 v' (x - 1) < 1 ].TFAE := by\n  tfae_have 1 \u2194 2 := isEquiv_iff_val_lt_val\n  tfae_have 1 \u2194 3 := isEquiv_iff_val_le_one\n  tfae_have 1 \u2194 4 := isEquiv_iff_val_eq_one\n  tfae_have 1 \u2194 5 := isEquiv_iff_val_lt_one\n  tfae_have 1 \u2194 6 := isEquiv_iff_val_sub_one_lt_one\n  tfae_finish\n\nend\n\nsection Supp\n\nvariable [CommRing R] [LinearOrderedCommMonoidWithZero \u0393\u2080] (v : Valuation R \u0393\u2080)\n\n/-- The support of a valuation `v : R \u2192 \u0393\u2080` is the ideal of `R` where `v` vanishes. -/\ndef supp : Ideal R where\n  carrier := { x | v x = 0 }\n  zero_mem' := map_zero v\n  add_mem' {x y} hx hy := le_zero_iff.mp <|\n    calc\n      v (x + y) \u2264 max (v x) (v y) := v.map_add x y\n      _ \u2264 0 := max_le (le_zero_iff.mpr hx) (le_zero_iff.mpr hy)\n  smul_mem' c x hx :=\n    calc\n      v (c * x) = v c * v x := map_mul v c x\n      _ = v c * 0 := congr_arg _ hx\n      _ = 0 := mul_zero _\n\n@[simp]\ntheorem mem_supp_iff (x : R) : x \u2208 supp v \u2194 v x = 0 :=\n  Iff.rfl\n\n/-- The support of a valuation is a prime ideal. -/\ninstance [Nontrivial \u0393\u2080] [NoZeroDivisors \u0393\u2080] : Ideal.IsPrime (supp v) :=\n  \u27e8fun h =>\n    one_ne_zero (\u03b1 := \u0393\u2080) <|\n      calc\n        1 = v 1 := v.map_one.symm\n        _ = 0 := by rw [\u2190 mem_supp_iff, h]; exact Submodule.mem_top,\n   fun {x y} hxy => by\n    simp only [mem_supp_iff] at hxy \u22a2\n    rw [v.map_mul x y] at hxy\n    exact eq_zero_or_eq_zero_of_mul_eq_zero hxy\u27e9\n\ntheorem map_add_supp (a : R) {s : R} (h : s \u2208 supp v) : v (a + s) = v a := by\n  have aux : \u2200 a s, v s = 0 \u2192 v (a + s) \u2264 v a := by\n    intro a' s' h'\n    refine le_trans (v.map_add a' s') (max_le le_rfl ?_)\n    simp [h']\n  apply le_antisymm (aux a s h)\n  calc\n    v a = v (a + s + -s) := by simp\n    _ \u2264 v (a + s) := aux (a + s) (-s) (by rwa [\u2190 Ideal.neg_mem_iff] at h)\n\ntheorem comap_supp {S : Type*} [CommRing S] (f : S \u2192+* R) :\n    supp (v.comap f) = Ideal.comap f v.supp :=\n  Ideal.ext fun x => by rw [mem_supp_iff, Ideal.mem_comap, mem_supp_iff, comap_apply]\n\nend Supp\n\n-- end of section\nend Valuation\n\nsection AddMonoid\n\nvariable (R) [Ring R] (\u0393\u2080 : Type*) [LinearOrderedAddCommMonoidWithTop \u0393\u2080]\n\n/-- The type of `\u0393\u2080`-valued additive valuations on `R`. -/\ndef AddValuation :=\n  Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48)\n\nend AddMonoid\n\nnamespace AddValuation\n\nvariable {\u0393\u2080 : Type*} {\u0393'\u2080 : Type*}\n\nsection Basic\n\nsection Monoid\n\n/-- A valuation is coerced to the underlying function `R \u2192 \u0393\u2080`. -/\ninstance (R) (\u0393\u2080) [Ring R] [LinearOrderedAddCommMonoidWithTop \u0393\u2080] :\n    FunLike (AddValuation R \u0393\u2080) R \u0393\u2080 where\n  coe v := v.toMonoidWithZeroHom.toFun\n  coe_injective' f g := by cases f; cases g; simp (config := {contextual := true})\n\nvariable [Ring R] [LinearOrderedAddCommMonoidWithTop \u0393\u2080] [LinearOrderedAddCommMonoidWithTop \u0393'\u2080]\n  (v : AddValuation R \u0393\u2080)\n\nsection\n\nvariable (f : R \u2192 \u0393\u2080) (h0 : f 0 = \u22a4) (h1 : f 1 = 0)\nvariable (hadd : \u2200 x y, min (f x) (f y) \u2264 f (x + y)) (hmul : \u2200 x y, f (x * y) = f x + f y)\n\n/-- An alternate constructor of `AddValuation`, that doesn't reference `Multiplicative \u0393\u2080\u1d52\u1d48` -/\ndef of : AddValuation R \u0393\u2080 where\n  toFun := f\n  map_one' := h1\n  map_zero' := h0\n  map_add_le_max' := hadd\n  map_mul' := hmul\n\nvariable {h0} {h1} {hadd} {hmul} {r : R}\n\n@[simp]\ntheorem of_apply : (of f h0 h1 hadd hmul) r = f r := rfl\n\n/-- The `Valuation` associated to an `AddValuation` (useful if the latter is constructed using\n`AddValuation.of`). -/\ndef toValuation : AddValuation R \u0393\u2080 \u2243 Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48) :=\n  Equiv.refl _\n\n@[deprecated (since := \"2024-11-09\")]\nalias valuation := toValuation\n\n/-- The `AddValuation` associated to a `Valuation`.\n-/\ndef ofValuation : Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48) \u2243 AddValuation R \u0393\u2080 :=\n  Equiv.refl _\n\n@[simp]\nlemma ofValuation_symm_eq : ofValuation.symm = toValuation (R := R) (\u0393\u2080 := \u0393\u2080) := rfl\n\n@[simp]\nlemma toValuation_symm_eq : toValuation.symm = ofValuation (R := R) (\u0393\u2080 := \u0393\u2080) := rfl\n\n@[simp]\nlemma ofValuation_toValuation : ofValuation (toValuation v) = v := rfl\n\n@[simp]\nlemma toValuation_ofValuation (v : Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48)) :\n    toValuation (ofValuation v) = v := rfl\n\n@[simp]\ntheorem toValuation_apply (r : R) :\n    toValuation v r = Multiplicative.ofAdd (OrderDual.toDual (v r)) :=\n  rfl\n\n@[deprecated (since := \"2024-11-09\")]\nalias valuation_apply := toValuation_apply\n\n@[simp]\ntheorem ofValuation_apply (v : Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48)) (r : R) :\n    ofValuation v r = OrderDual.ofDual (Multiplicative.toAdd (v r)) :=\n  rfl\n\nend\n\n-- Porting note: Lean get confused about namespaces and instances below\n@[simp]\ntheorem map_zero : v 0 = (\u22a4 : \u0393\u2080) :=\n  Valuation.map_zero v\n\n@[simp]\ntheorem map_one : v 1 = (0 : \u0393\u2080) :=\n  Valuation.map_one v\n\n/- Porting note: helper wrapper to coerce `v` to the correct function type -/\n/-- A helper function for Lean to inferring types correctly -/\ndef asFun : R \u2192 \u0393\u2080 := v\n\n@[simp]\ntheorem map_mul : \u2200 (x y : R), v (x * y) = v x + v y :=\n  Valuation.map_mul v\n\n-- Porting note: LHS simplified so created map_add' and removed simp tag\ntheorem map_add : \u2200 (x y : R), min (v x) (v y) \u2264 v (x + y) :=\n  Valuation.map_add v\n\n@[simp]\ntheorem map_add' : \u2200 (x y : R), v x \u2264 v (x + y) \u2228 v y \u2264 v (x + y) := by\n  intro x y\n  rw [\u2190 @min_le_iff _ _ (v x) (v y) (v (x+y)), \u2190 ge_iff_le]\n  apply map_add\n\ntheorem map_le_add {x y : R} {g : \u0393\u2080} (hx : g \u2264 v x) (hy : g \u2264 v y) : g \u2264 v (x + y) :=\n  Valuation.map_add_le v hx hy\n\ntheorem map_lt_add {x y : R} {g : \u0393\u2080} (hx : g < v x) (hy : g < v y) : g < v (x + y) :=\n  Valuation.map_add_lt v hx hy\n\ntheorem map_le_sum {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hf : \u2200 i \u2208 s, g \u2264 v (f i)) :\n    g \u2264 v (\u2211 i \u2208 s, f i) :=\n  v.map_sum_le hf\n\ntheorem map_lt_sum {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hg : g \u2260 \u22a4)\n    (hf : \u2200 i \u2208 s, g < v (f i)) : g < v (\u2211 i \u2208 s, f i) :=\n  v.map_sum_lt hg hf\n\ntheorem map_lt_sum' {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hg : g < \u22a4)\n    (hf : \u2200 i \u2208 s, g < v (f i)) : g < v (\u2211 i \u2208 s, f i) :=\n  v.map_sum_lt' hg hf\n\n@[simp]\ntheorem map_pow : \u2200 (x : R) (n : \u2115), v (x ^ n) = n \u2022 (v x) :=\n  Valuation.map_pow v\n\n@[ext]\ntheorem ext {v\u2081 v\u2082 : AddValuation R \u0393\u2080} (h : \u2200 r, v\u2081 r = v\u2082 r) : v\u2081 = v\u2082 :=\n  Valuation.ext h\n\n-- The following definition is not an instance, because we have more than one `v` on a given `R`.\n-- In addition, type class inference would not be able to infer `v`.\n/-- A valuation gives a preorder on the underlying ring. -/\ndef toPreorder : Preorder R :=\n  Preorder.lift v\n\n/-- If `v` is an additive valuation on a division ring then `v(x) = \u22a4` iff `x = 0`. -/\n@[simp]\ntheorem top_iff [Nontrivial \u0393\u2080] (v : AddValuation K \u0393\u2080) {x : K} : v x = (\u22a4 : \u0393\u2080) \u2194 x = 0 :=\n  v.zero_iff\n\ntheorem ne_top_iff [Nontrivial \u0393\u2080] (v : AddValuation K \u0393\u2080) {x : K} : v x \u2260 (\u22a4 : \u0393\u2080) \u2194 x \u2260 0 :=\n  v.ne_zero_iff\n\n/-- A ring homomorphism `S \u2192 R` induces a map `AddValuation R \u0393\u2080 \u2192 AddValuation S \u0393\u2080`. -/\ndef comap {S : Type*} [Ring S] (f : S \u2192+* R) (v : AddValuation R \u0393\u2080) : AddValuation S \u0393\u2080 :=\n  Valuation.comap f v\n\n@[simp]\ntheorem comap_id : v.comap (RingHom.id R) = v :=\n  Valuation.comap_id v\n\ntheorem comap_comp {S\u2081 : Type*} {S\u2082 : Type*} [Ring S\u2081] [Ring S\u2082] (f : S\u2081 \u2192+* S\u2082) (g : S\u2082 \u2192+* R) :\n    v.comap (g.comp f) = (v.comap g).comap f :=\n  Valuation.comap_comp v f g\n\n/-- A `\u2264`-preserving, `\u22a4`-preserving group homomorphism `\u0393\u2080 \u2192 \u0393'\u2080` induces a map\n  `AddValuation R \u0393\u2080 \u2192 AddValuation R \u0393'\u2080`.\n-/\ndef map (f : \u0393\u2080 \u2192+ \u0393'\u2080) (ht : f \u22a4 = \u22a4) (hf : Monotone f) (v : AddValuation R \u0393\u2080) :\n    AddValuation R \u0393'\u2080 :=\n  @Valuation.map R (Multiplicative \u0393\u2080\u1d52\u1d48) (Multiplicative \u0393'\u2080\u1d52\u1d48) _ _ _\n    { toFun := f\n      map_mul' := f.map_add\n      map_one' := f.map_zero\n      map_zero' := ht } (fun _ _ h => hf h) v\n\n@[simp]\nlemma map_apply (f : \u0393\u2080 \u2192+ \u0393'\u2080) (ht : f \u22a4 = \u22a4) (hf : Monotone f) (v : AddValuation R \u0393\u2080) (r : R) :\n    v.map f ht hf r = f (v r) := rfl\n\n/-- Two additive valuations on `R` are defined to be equivalent if they induce the same\n  preorder on `R`. -/\ndef IsEquiv (v\u2081 : AddValuation R \u0393\u2080) (v\u2082 : AddValuation R \u0393'\u2080) : Prop :=\n  Valuation.IsEquiv v\u2081 v\u2082\n\n@[simp]\ntheorem map_neg (x : R) : v (-x) = v x :=\n  Valuation.map_neg v x\n\ntheorem map_sub_swap (x y : R) : v (x - y) = v (y - x) :=\n  Valuation.map_sub_swap v x y\n\ntheorem map_sub (x y : R) : min (v x) (v y) \u2264 v (x - y) :=\n  Valuation.map_sub v x y\n\ntheorem map_le_sub {x y : R} {g : \u0393\u2080} (hx : g \u2264 v x) (hy : g \u2264 v y) : g \u2264 v (x - y) :=\n  Valuation.map_sub_le v hx hy\n\nvariable {x y : R}\n\ntheorem map_add_of_distinct_val (h : v x \u2260 v y) : v (x + y) = @Min.min \u0393\u2080 _ (v x) (v y) :=\n  Valuation.map_add_of_distinct_val v h\n\ntheorem map_add_eq_of_lt_left {x y : R} (h : v x < v y) :\n    v (x + y) = v x := by\n  rw [map_add_of_distinct_val _ h.ne, min_eq_left h.le]\n\ntheorem map_add_eq_of_lt_right {x y : R} (hx : v y < v x) :\n    v (x + y) = v y := add_comm y x \u25b8 map_add_eq_of_lt_left v hx\n\ntheorem map_sub_eq_of_lt_left {x y : R} (hx : v x < v y) :\n    v (x - y) = v x := by\n  rw [sub_eq_add_neg]\n  apply map_add_eq_of_lt_left\n  rwa [map_neg]\n\ntheorem map_sub_eq_of_lt_right {x y : R} (hx : v y < v x) :\n    v (x - y) = v y := map_sub_swap v x y \u25b8 map_sub_eq_of_lt_left v hx\n\ntheorem map_eq_of_lt_sub (h : v x < v (y - x)) : v y = v x :=\n  Valuation.map_eq_of_sub_lt v h\n\nend Monoid\n\nsection Group\n\nvariable [LinearOrderedAddCommGroupWithTop \u0393\u2080] [Ring R] (v : AddValuation R \u0393\u2080) {x y : R}\n\n@[simp]\ntheorem map_inv (v : AddValuation K \u0393\u2080) {x : K} : v x\u207b\u00b9 = - (v x) :=\n  map_inv\u2080 (toValuation v) x\n\n@[simp]\ntheorem map_div (v : AddValuation K \u0393\u2080) {x y : K} : v (x / y) = v x - v y :=\n  map_div\u2080 (toValuation v) x y\n\nend Group\n\nend Basic\n\nnamespace IsEquiv\n\nvariable [LinearOrderedAddCommMonoidWithTop \u0393\u2080] [LinearOrderedAddCommMonoidWithTop \u0393'\u2080]\n  [Ring R]\n  {\u0393''\u2080 : Type*} [LinearOrderedAddCommMonoidWithTop \u0393''\u2080]\n  {v : AddValuation R \u0393\u2080}\n   {v\u2081 : AddValuation R \u0393\u2080} {v\u2082 : AddValuation R \u0393'\u2080} {v\u2083 : AddValuation R \u0393''\u2080}\n\n@[refl]\ntheorem refl : v.IsEquiv v :=\n  Valuation.IsEquiv.refl\n\n@[symm]\ntheorem symm (h : v\u2081.IsEquiv v\u2082) : v\u2082.IsEquiv v\u2081 :=\n  Valuation.IsEquiv.symm h\n\n@[trans]\ntheorem trans (h\u2081\u2082 : v\u2081.IsEquiv v\u2082) (h\u2082\u2083 : v\u2082.IsEquiv v\u2083) : v\u2081.IsEquiv v\u2083 :=\n  Valuation.IsEquiv.trans h\u2081\u2082 h\u2082\u2083\n\ntheorem of_eq {v' : AddValuation R \u0393\u2080} (h : v = v') : v.IsEquiv v' :=\n  Valuation.IsEquiv.of_eq h\n\ntheorem map {v' : AddValuation R \u0393\u2080} (f : \u0393\u2080 \u2192+ \u0393'\u2080) (ht : f \u22a4 = \u22a4) (hf : Monotone f)\n    (inf : Injective f) (h : v.IsEquiv v') : (v.map f ht hf).IsEquiv (v'.map f ht hf) :=\n  @Valuation.IsEquiv.map R (Multiplicative \u0393\u2080\u1d52\u1d48) (Multiplicative \u0393'\u2080\u1d52\u1d48) _ _ _ _ _\n    { toFun := f\n      map_mul' := f.map_add\n      map_one' := f.map_zero\n      map_zero' := ht } (fun _x _y h => hf h) inf h\n\n/-- `comap` preserves equivalence. -/\ntheorem comap {S : Type*} [Ring S] (f : S \u2192+* R) (h : v\u2081.IsEquiv v\u2082) :\n    (v\u2081.comap f).IsEquiv (v\u2082.comap f) :=\n  Valuation.IsEquiv.comap f h\n\ntheorem val_eq (h : v\u2081.IsEquiv v\u2082) {r s : R} : v\u2081 r = v\u2081 s \u2194 v\u2082 r = v\u2082 s :=\n  Valuation.IsEquiv.val_eq h\n\ntheorem ne_top (h : v\u2081.IsEquiv v\u2082) {r : R} : v\u2081 r \u2260 (\u22a4 : \u0393\u2080) \u2194 v\u2082 r \u2260 (\u22a4 : \u0393'\u2080) :=\n  Valuation.IsEquiv.ne_zero h\n\nend IsEquiv\n\nsection Supp\n\nvariable [LinearOrderedAddCommMonoidWithTop \u0393\u2080] [CommRing R] (v : AddValuation R \u0393\u2080)\n\n/-- The support of an additive valuation `v : R \u2192 \u0393\u2080` is the ideal of `R` where `v x = \u22a4` -/\ndef supp : Ideal R :=\n  Valuation.supp v\n\n@[simp]\ntheorem mem_supp_iff (x : R) : x \u2208 supp v \u2194 v x = (\u22a4 : \u0393\u2080) :=\n  Valuation.mem_supp_iff v x\n\ntheorem map_add_supp (a : R) {s : R} (h : s \u2208 supp v) : v (a + s) = v a :=\n  Valuation.map_add_supp v a h\n\nend Supp\n\n-- end of section\nend AddValuation\n\nnamespace Valuation\n\nvariable {K \u0393\u2080 : Type*} [Ring R] [LinearOrderedCommMonoidWithZero \u0393\u2080]\n\n/-- The `AddValuation` associated to a `Valuation`. -/\ndef toAddValuation : Valuation R \u0393\u2080 \u2243 AddValuation R (Additive \u0393\u2080)\u1d52\u1d48 :=\n  .trans (congr\n    { toFun := fun x \u21a6 .ofAdd <| .toDual <| .toDual <| .ofMul x\n      invFun := fun x \u21a6 x.toAdd.ofDual.ofDual.toMul\n      left_inv := fun _x \u21a6 rfl\n      right_inv := fun _x \u21a6 rfl\n      map_mul' := fun _x _y \u21a6 rfl\n      map_le_map_iff' := .rfl }) (AddValuation.ofValuation (R := R) (\u0393\u2080 := (Additive \u0393\u2080)\u1d52\u1d48))\n\n/-- The `Valuation` associated to a `AddValuation`.\n-/\ndef ofAddValuation : AddValuation R (Additive \u0393\u2080)\u1d52\u1d48 \u2243 Valuation R \u0393\u2080 :=\n  AddValuation.toValuation.trans <| congr <|\n    { toFun := fun x \u21a6 x.toAdd.ofDual.ofDual.toMul\n      invFun := fun x \u21a6 .ofAdd <| .toDual <| .toDual <| .ofMul x\n      left_inv := fun _x \u21a6 rfl\n      right_inv := fun _x \u21a6 rfl\n      map_mul' := fun _x _y \u21a6 rfl\n      map_le_map_iff' := .rfl }\n\n@[simp]\nlemma ofAddValuation_symm_eq : ofAddValuation.symm = toAddValuation (R := R) (\u0393\u2080 := \u0393\u2080) := rfl\n\n@[simp]\nlemma toAddValuation_symm_eq : toAddValuation.symm = ofAddValuation (R := R) (\u0393\u2080 := \u0393\u2080) := rfl\n\n@[simp]\nlemma ofAddValuation_toAddValuation (v : Valuation R \u0393\u2080) :\n  ofAddValuation (toAddValuation v) = v := rfl\n\n@[simp]\nlemma toValuation_ofValuation (v : AddValuation R (Additive \u0393\u2080)\u1d52\u1d48) :\n    toAddValuation (ofAddValuation v) = v := rfl\n\n@[simp]\ntheorem toAddValuation_apply (v : Valuation R \u0393\u2080) (r : R) :\n    toAddValuation v r = OrderDual.toDual (Additive.ofMul (v r)) :=\n  rfl\n\n", "theoremStatement": "@[simp]\ntheorem ofAddValuation_apply (v : AddValuation R (Additive \u0393\u2080)\u1d52\u1d48) (r : R) :\n    ofAddValuation v r = Additive.toMul (OrderDual.ofDual (v r)) ", "theoremName": "Valuation.ofAddValuation_apply", "fileCreated": {"commit": "a9138cdba12f2110c86195f5eac26cb36dee2627", "date": "2023-03-17"}, "theoremCreated": {"commit": "625ac34a53dfa0eca4fb8a3a933409238e4f43f0", "date": "2024-12-16"}, "file": "mathlib/Mathlib/RingTheory/Valuation/Basic.lean", "module": "Mathlib.RingTheory.Valuation.Basic", "jsonFile": "Mathlib.RingTheory.Valuation.Basic.jsonl", "positionMetadata": {"lineInFile": 950, "tokenPositionInFile": 32287, "theoremPositionInFile": 133}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 5, "repositoryPremises": true, "numRepositoryPremises": 15, "numPremises": 17}, "proofMetadata": {"hasProof": true, "proof": ":=\n  rfl", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 8}}
{"srcContext": "/-\nCopyright (c) 2018 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes, Abhimanyu Pallavi Sudhir, Jean Lo, Calle S\u00f6nne, S\u00e9bastien Gou\u00ebzel,\n  R\u00e9my Degenne\n-/\nimport Mathlib.Analysis.SpecialFunctions.Pow.Continuity\nimport Mathlib.Analysis.SpecialFunctions.Complex.LogDeriv\nimport Mathlib.Analysis.Calculus.FDeriv.Extend\nimport Mathlib.Analysis.Calculus.Deriv.Prod\nimport Mathlib.Analysis.SpecialFunctions.Log.Deriv\nimport Mathlib.Analysis.SpecialFunctions.Trigonometric.Deriv\n\n/-!\n# Derivatives of power function on `\u2102`, `\u211d`, `\u211d\u22650`, and `\u211d\u22650\u221e`\n\nWe also prove differentiability and provide derivatives for the power functions `x ^ y`.\n-/\n\n\nnoncomputable section\n\nopen scoped Real Topology NNReal ENNReal\nopen Filter\n\nnamespace Complex\n\ntheorem hasStrictFDerivAt_cpow {p : \u2102 \u00d7 \u2102} (hp : p.1 \u2208 slitPlane) :\n    HasStrictFDerivAt (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2)\n      ((p.2 * p.1 ^ (p.2 - 1)) \u2022 ContinuousLinearMap.fst \u2102 \u2102 \u2102 +\n        (p.1 ^ p.2 * log p.1) \u2022 ContinuousLinearMap.snd \u2102 \u2102 \u2102) p := by\n  have A : p.1 \u2260 0 := slitPlane_ne_zero hp\n  have : (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2) =\u1da0[\ud835\udcdd p] fun x => exp (log x.1 * x.2) :=\n    ((isOpen_ne.preimage continuous_fst).eventually_mem A).mono fun p hp =>\n      cpow_def_of_ne_zero hp _\n  rw [cpow_sub _ _ A, cpow_one, mul_div_left_comm, mul_smul, mul_smul]\n  refine HasStrictFDerivAt.congr_of_eventuallyEq ?_ this.symm\n  simpa only [cpow_def_of_ne_zero A, div_eq_mul_inv, mul_smul, add_comm, smul_add] using\n    ((hasStrictFDerivAt_fst.clog hp).mul hasStrictFDerivAt_snd).cexp\n\ntheorem hasStrictFDerivAt_cpow' {x y : \u2102} (hp : x \u2208 slitPlane) :\n    HasStrictFDerivAt (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2)\n      ((y * x ^ (y - 1)) \u2022 ContinuousLinearMap.fst \u2102 \u2102 \u2102 +\n        (x ^ y * log x) \u2022 ContinuousLinearMap.snd \u2102 \u2102 \u2102) (x, y) :=\n  @hasStrictFDerivAt_cpow (x, y) hp\n\ntheorem hasStrictDerivAt_const_cpow {x y : \u2102} (h : x \u2260 0 \u2228 y \u2260 0) :\n    HasStrictDerivAt (fun y => x ^ y) (x ^ y * log x) y := by\n  rcases em (x = 0) with (rfl | hx)\n  \u00b7 replace h := h.neg_resolve_left rfl\n    rw [log_zero, mul_zero]\n    refine (hasStrictDerivAt_const y 0).congr_of_eventuallyEq ?_\n    exact (isOpen_ne.eventually_mem h).mono fun y hy => (zero_cpow hy).symm\n  \u00b7 simpa only [cpow_def_of_ne_zero hx, mul_one] using\n      ((hasStrictDerivAt_id y).const_mul (log x)).cexp\n\ntheorem hasFDerivAt_cpow {p : \u2102 \u00d7 \u2102} (hp : p.1 \u2208 slitPlane) :\n    HasFDerivAt (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2)\n      ((p.2 * p.1 ^ (p.2 - 1)) \u2022 ContinuousLinearMap.fst \u2102 \u2102 \u2102 +\n        (p.1 ^ p.2 * log p.1) \u2022 ContinuousLinearMap.snd \u2102 \u2102 \u2102) p :=\n  (hasStrictFDerivAt_cpow hp).hasFDerivAt\n\nend Complex\n\nsection fderiv\n\nopen Complex\n\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f g : E \u2192 \u2102} {f' g' : E \u2192L[\u2102] \u2102}\n  {x : E} {s : Set E} {c : \u2102}\n\ntheorem HasStrictFDerivAt.cpow (hf : HasStrictFDerivAt f f' x) (hg : HasStrictFDerivAt g g' x)\n    (h0 : f x \u2208 slitPlane) : HasStrictFDerivAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) \u2022 f' + (f x ^ g x * Complex.log (f x)) \u2022 g') x := by\n  convert (@hasStrictFDerivAt_cpow ((fun x => (f x, g x)) x) h0).comp x (hf.prod hg)\n\ntheorem HasStrictFDerivAt.const_cpow (hf : HasStrictFDerivAt f f' x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasStrictFDerivAt (fun x => c ^ f x) ((c ^ f x * Complex.log c) \u2022 f') x :=\n  (hasStrictDerivAt_const_cpow h0).comp_hasStrictFDerivAt x hf\n\ntheorem HasFDerivAt.cpow (hf : HasFDerivAt f f' x) (hg : HasFDerivAt g g' x)\n    (h0 : f x \u2208 slitPlane) : HasFDerivAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) \u2022 f' + (f x ^ g x * Complex.log (f x)) \u2022 g') x := by\n  convert (@Complex.hasFDerivAt_cpow ((fun x => (f x, g x)) x) h0).comp x (hf.prod hg)\n\ntheorem HasFDerivAt.const_cpow (hf : HasFDerivAt f f' x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasFDerivAt (fun x => c ^ f x) ((c ^ f x * Complex.log c) \u2022 f') x :=\n  (hasStrictDerivAt_const_cpow h0).hasDerivAt.comp_hasFDerivAt x hf\n\ntheorem HasFDerivWithinAt.cpow (hf : HasFDerivWithinAt f f' s x) (hg : HasFDerivWithinAt g g' s x)\n    (h0 : f x \u2208 slitPlane) : HasFDerivWithinAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) \u2022 f' + (f x ^ g x * Complex.log (f x)) \u2022 g') s x := by\n  convert\n    (@Complex.hasFDerivAt_cpow ((fun x => (f x, g x)) x) h0).comp_hasFDerivWithinAt x (hf.prod hg)\n\ntheorem HasFDerivWithinAt.const_cpow (hf : HasFDerivWithinAt f f' s x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasFDerivWithinAt (fun x => c ^ f x) ((c ^ f x * Complex.log c) \u2022 f') s x :=\n  (hasStrictDerivAt_const_cpow h0).hasDerivAt.comp_hasFDerivWithinAt x hf\n\ntheorem DifferentiableAt.cpow (hf : DifferentiableAt \u2102 f x) (hg : DifferentiableAt \u2102 g x)\n    (h0 : f x \u2208 slitPlane) : DifferentiableAt \u2102 (fun x => f x ^ g x) x :=\n  (hf.hasFDerivAt.cpow hg.hasFDerivAt h0).differentiableAt\n\ntheorem DifferentiableAt.const_cpow (hf : DifferentiableAt \u2102 f x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    DifferentiableAt \u2102 (fun x => c ^ f x) x :=\n  (hf.hasFDerivAt.const_cpow h0).differentiableAt\n\ntheorem DifferentiableAt.cpow_const (hf : DifferentiableAt \u2102 f x) (h0 : f x \u2208 slitPlane) :\n    DifferentiableAt \u2102 (fun x => f x ^ c) x :=\n  hf.cpow (differentiableAt_const c) h0\n\ntheorem DifferentiableWithinAt.cpow (hf : DifferentiableWithinAt \u2102 f s x)\n    (hg : DifferentiableWithinAt \u2102 g s x) (h0 : f x \u2208 slitPlane) :\n    DifferentiableWithinAt \u2102 (fun x => f x ^ g x) s x :=\n  (hf.hasFDerivWithinAt.cpow hg.hasFDerivWithinAt h0).differentiableWithinAt\n\ntheorem DifferentiableWithinAt.const_cpow (hf : DifferentiableWithinAt \u2102 f s x)\n    (h0 : c \u2260 0 \u2228 f x \u2260 0) : DifferentiableWithinAt \u2102 (fun x => c ^ f x) s x :=\n  (hf.hasFDerivWithinAt.const_cpow h0).differentiableWithinAt\n\ntheorem DifferentiableWithinAt.cpow_const (hf : DifferentiableWithinAt \u2102 f s x)\n    (h0 : f x \u2208 slitPlane) :\n    DifferentiableWithinAt \u2102 (fun x => f x ^ c) s x :=\n  hf.cpow (differentiableWithinAt_const c) h0\n\ntheorem DifferentiableOn.cpow (hf : DifferentiableOn \u2102 f s) (hg : DifferentiableOn \u2102 g s)\n    (h0 : Set.MapsTo f s slitPlane) : DifferentiableOn \u2102 (fun x \u21a6 f x ^ g x) s :=\n  fun x hx \u21a6 (hf x hx).cpow (hg x hx) (h0 hx)\n\ntheorem DifferentiableOn.const_cpow (hf : DifferentiableOn \u2102 f s)\n    (h0 : c \u2260 0 \u2228 \u2200 x \u2208 s, f x \u2260 0) : DifferentiableOn \u2102 (fun x \u21a6 c ^ f x) s :=\n  fun x hx \u21a6 (hf x hx).const_cpow (h0.imp_right fun h \u21a6 h x hx)\n\ntheorem DifferentiableOn.cpow_const (hf : DifferentiableOn \u2102 f s)\n    (h0 : \u2200 x \u2208 s, f x \u2208 slitPlane) :\n    DifferentiableOn \u2102 (fun x => f x ^ c) s :=\n  hf.cpow (differentiableOn_const c) h0\n\ntheorem Differentiable.cpow (hf : Differentiable \u2102 f) (hg : Differentiable \u2102 g)\n    (h0 : \u2200 x, f x \u2208 slitPlane) : Differentiable \u2102 (fun x \u21a6 f x ^ g x) :=\n  fun x \u21a6 (hf x).cpow (hg x) (h0 x)\n\ntheorem Differentiable.const_cpow (hf : Differentiable \u2102 f)\n    (h0 : c \u2260 0 \u2228 \u2200 x, f x \u2260 0) : Differentiable \u2102 (fun x \u21a6 c ^ f x) :=\n  fun x \u21a6 (hf x).const_cpow (h0.imp_right fun h \u21a6 h x)\n\n@[fun_prop]\nlemma differentiable_const_cpow_of_neZero (z : \u2102) [NeZero z] :\n    Differentiable \u2102 fun s : \u2102 \u21a6 z ^ s :=\n  differentiable_id.const_cpow (.inl <| NeZero.ne z)\n\n@[fun_prop]\nlemma differentiableAt_const_cpow_of_neZero (z : \u2102) [NeZero z] (t : \u2102) :\n    DifferentiableAt \u2102 (fun s : \u2102 \u21a6 z ^ s) t :=\n  differentiableAt_id.const_cpow (.inl <| NeZero.ne z)\n\nend fderiv\n\nsection deriv\n\nopen Complex\n\nvariable {f g : \u2102 \u2192 \u2102} {s : Set \u2102} {f' g' x c : \u2102}\n\n/-- A private lemma that rewrites the output of lemmas like `HasFDerivAt.cpow` to the form\nexpected by lemmas like `HasDerivAt.cpow`. -/\nprivate theorem aux : ((g x * f x ^ (g x - 1)) \u2022 (1 : \u2102 \u2192L[\u2102] \u2102).smulRight f' +\n    (f x ^ g x * log (f x)) \u2022 (1 : \u2102 \u2192L[\u2102] \u2102).smulRight g') 1 =\n      g x * f x ^ (g x - 1) * f' + f x ^ g x * log (f x) * g' := by\n  simp only [Algebra.id.smul_eq_mul, one_mul, ContinuousLinearMap.one_apply,\n    ContinuousLinearMap.smulRight_apply, ContinuousLinearMap.add_apply, Pi.smul_apply,\n    ContinuousLinearMap.coe_smul']\n\nnonrec theorem HasStrictDerivAt.cpow (hf : HasStrictDerivAt f f' x) (hg : HasStrictDerivAt g g' x)\n    (h0 : f x \u2208 slitPlane) : HasStrictDerivAt (fun x => f x ^ g x)\n      (g x * f x ^ (g x - 1) * f' + f x ^ g x * Complex.log (f x) * g') x := by\n  simpa using (hf.cpow hg h0).hasStrictDerivAt\n\ntheorem HasStrictDerivAt.const_cpow (hf : HasStrictDerivAt f f' x) (h : c \u2260 0 \u2228 f x \u2260 0) :\n    HasStrictDerivAt (fun x => c ^ f x) (c ^ f x * Complex.log c * f') x :=\n  (hasStrictDerivAt_const_cpow h).comp x hf\n\ntheorem Complex.hasStrictDerivAt_cpow_const (h : x \u2208 slitPlane) :\n    HasStrictDerivAt (fun z : \u2102 => z ^ c) (c * x ^ (c - 1)) x := by\n  simpa only [mul_zero, add_zero, mul_one] using\n    (hasStrictDerivAt_id x).cpow (hasStrictDerivAt_const x c) h\n\ntheorem HasStrictDerivAt.cpow_const (hf : HasStrictDerivAt f f' x)\n    (h0 : f x \u2208 slitPlane) :\n    HasStrictDerivAt (fun x => f x ^ c) (c * f x ^ (c - 1) * f') x :=\n  (Complex.hasStrictDerivAt_cpow_const h0).comp x hf\n\ntheorem HasDerivAt.cpow (hf : HasDerivAt f f' x) (hg : HasDerivAt g g' x)\n    (h0 : f x \u2208 slitPlane) : HasDerivAt (fun x => f x ^ g x)\n      (g x * f x ^ (g x - 1) * f' + f x ^ g x * Complex.log (f x) * g') x := by\n  simpa only [aux] using (hf.hasFDerivAt.cpow hg h0).hasDerivAt\n\ntheorem HasDerivAt.const_cpow (hf : HasDerivAt f f' x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasDerivAt (fun x => c ^ f x) (c ^ f x * Complex.log c * f') x :=\n  (hasStrictDerivAt_const_cpow h0).hasDerivAt.comp x hf\n\ntheorem HasDerivAt.cpow_const (hf : HasDerivAt f f' x) (h0 : f x \u2208 slitPlane) :\n    HasDerivAt (fun x => f x ^ c) (c * f x ^ (c - 1) * f') x :=\n  (Complex.hasStrictDerivAt_cpow_const h0).hasDerivAt.comp x hf\n\ntheorem HasDerivWithinAt.cpow (hf : HasDerivWithinAt f f' s x) (hg : HasDerivWithinAt g g' s x)\n    (h0 : f x \u2208 slitPlane) : HasDerivWithinAt (fun x => f x ^ g x)\n      (g x * f x ^ (g x - 1) * f' + f x ^ g x * Complex.log (f x) * g') s x := by\n  simpa only [aux] using (hf.hasFDerivWithinAt.cpow hg h0).hasDerivWithinAt\n\ntheorem HasDerivWithinAt.const_cpow (hf : HasDerivWithinAt f f' s x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasDerivWithinAt (fun x => c ^ f x) (c ^ f x * Complex.log c * f') s x :=\n  (hasStrictDerivAt_const_cpow h0).hasDerivAt.comp_hasDerivWithinAt x hf\n\ntheorem HasDerivWithinAt.cpow_const (hf : HasDerivWithinAt f f' s x)\n    (h0 : f x \u2208 slitPlane) :\n    HasDerivWithinAt (fun x => f x ^ c) (c * f x ^ (c - 1) * f') s x :=\n  (Complex.hasStrictDerivAt_cpow_const h0).hasDerivAt.comp_hasDerivWithinAt x hf\n\n/-- Although `fun x => x ^ r` for fixed `r` is *not* complex-differentiable along the negative real\nline, it is still real-differentiable, and the derivative is what one would formally expect.\nSee `hasDerivAt_ofReal_cpow_const` for an alternate formulation. -/\ntheorem hasDerivAt_ofReal_cpow_const' {x : \u211d} (hx : x \u2260 0) {r : \u2102} (hr : r \u2260 -1) :\n    HasDerivAt (fun y : \u211d => (y : \u2102) ^ (r + 1) / (r + 1)) (x ^ r) x := by\n  rw [Ne, \u2190 add_eq_zero_iff_eq_neg, \u2190 Ne] at hr\n  rcases lt_or_gt_of_ne hx.symm with (hx | hx)\n  \u00b7 -- easy case : `0 < x`\n    -- Porting note: proof used to be\n    -- convert (((hasDerivAt_id (x : \u2102)).cpow_const _).div_const (r + 1)).comp_ofReal using 1\n    -- \u00b7 rw [add_sub_cancel, id.def, mul_one, mul_comm, mul_div_cancel _ hr]\n    -- \u00b7 rw [id.def, ofReal_re]; exact Or.inl hx\n    apply HasDerivAt.comp_ofReal (e := fun y => (y : \u2102) ^ (r + 1) / (r + 1))\n    convert HasDerivAt.div_const (\ud835\udd5c := \u2102) ?_ (r + 1) using 1\n    \u00b7 exact (mul_div_cancel_right\u2080 _ hr).symm\n    \u00b7 convert HasDerivAt.cpow_const ?_ ?_ using 1\n      \u00b7 rw [add_sub_cancel_right, mul_comm]; exact (mul_one _).symm\n      \u00b7 exact hasDerivAt_id (x : \u2102)\n      \u00b7 simp [hx]\n  \u00b7 -- harder case : `x < 0`\n    have : \u2200\u1da0 y : \u211d in \ud835\udcdd x,\n        (y : \u2102) ^ (r + 1) / (r + 1) = (-y : \u2102) ^ (r + 1) * exp (\u03c0 * I * (r + 1)) / (r + 1) := by\n      refine Filter.eventually_of_mem (Iio_mem_nhds hx) fun y hy => ?_\n      rw [ofReal_cpow_of_nonpos (le_of_lt hy)]\n    refine HasDerivAt.congr_of_eventuallyEq ?_ this\n    rw [ofReal_cpow_of_nonpos (le_of_lt hx)]\n    suffices HasDerivAt (fun y : \u211d => (-\u2191y) ^ (r + 1) * exp (\u2191\u03c0 * I * (r + 1)))\n        ((r + 1) * (-\u2191x) ^ r * exp (\u2191\u03c0 * I * r)) x by\n      convert this.div_const (r + 1) using 1\n      conv_rhs => rw [mul_assoc, mul_comm, mul_div_cancel_right\u2080 _ hr]\n    rw [mul_add ((\u03c0 : \u2102) * _), mul_one, exp_add, exp_pi_mul_I, mul_comm (_ : \u2102) (-1 : \u2102),\n      neg_one_mul]\n    simp_rw [mul_neg, \u2190 neg_mul, \u2190 ofReal_neg]\n    suffices HasDerivAt (fun y : \u211d => (\u2191(-y) : \u2102) ^ (r + 1)) (-(r + 1) * \u2191(-x) ^ r) x by\n      convert this.neg.mul_const _ using 1; ring\n    suffices HasDerivAt (fun y : \u211d => (y : \u2102) ^ (r + 1)) ((r + 1) * \u2191(-x) ^ r) (-x) by\n      convert @HasDerivAt.scomp \u211d _ \u2102 _ _ x \u211d _ _ _ _ _ _ _ _ this (hasDerivAt_neg x) using 1\n      rw [real_smul, ofReal_neg 1, ofReal_one]; ring\n    suffices HasDerivAt (fun y : \u2102 => y ^ (r + 1)) ((r + 1) * \u2191(-x) ^ r) \u2191(-x) by\n      exact this.comp_ofReal\n    conv in \u2191_ ^ _ => rw [(by ring : r = r + 1 - 1)]\n    convert HasDerivAt.cpow_const ?_ ?_ using 1\n    \u00b7 rw [add_sub_cancel_right, add_sub_cancel_right]; exact (mul_one _).symm\n    \u00b7 exact hasDerivAt_id ((-x : \u211d) : \u2102)\n    \u00b7 simp [hx]\n\n@[deprecated (since := \"2024-12-15\")] alias hasDerivAt_ofReal_cpow := hasDerivAt_ofReal_cpow_const'\n\n/-- An alternate formulation of `hasDerivAt_ofReal_cpow_const'`. -/\ntheorem hasDerivAt_ofReal_cpow_const {x : \u211d} (hx : x \u2260 0) {r : \u2102} (hr : r \u2260 0) :\n    HasDerivAt (fun y : \u211d => (y : \u2102) ^ r) (r * x ^ (r - 1)) x := by\n  have := HasDerivAt.const_mul r <| hasDerivAt_ofReal_cpow_const' hx\n    (by rwa [ne_eq, sub_eq_neg_self])\n  simpa [sub_add_cancel, mul_div_cancel\u2080 _ hr] using this\n\n/-- A version of `DifferentiableAt.cpow_const` for a real function. -/\ntheorem DifferentiableAt.ofReal_cpow_const {f : \u211d \u2192 \u211d} {x : \u211d} (hf : DifferentiableAt \u211d f x)\n    (h0 : f x \u2260 0) (h1 : c \u2260 0) :\n    DifferentiableAt \u211d (fun (y : \u211d) => (f y : \u2102) ^ c) x :=\n  (hasDerivAt_ofReal_cpow_const h0 h1).differentiableAt.comp x hf\n\ntheorem Complex.deriv_cpow_const (hx : x \u2208 Complex.slitPlane) :\n    deriv (fun (x : \u2102) \u21a6 x ^ c) x = c * x ^ (c - 1) :=\n  (hasStrictDerivAt_cpow_const hx).hasDerivAt.deriv\n\n/-- A version of `Complex.deriv_cpow_const` for a real variable. -/\ntheorem Complex.deriv_ofReal_cpow_const {x : \u211d} (hx : x \u2260 0) (hc : c \u2260 0) :\n    deriv (fun x : \u211d \u21a6 (x : \u2102) ^ c) x = c * x ^ (c - 1) :=\n  (hasDerivAt_ofReal_cpow_const hx hc).deriv\n\ntheorem deriv_cpow_const (hf : DifferentiableAt \u2102 f x) (hx : f x \u2208 Complex.slitPlane) :\n    deriv (fun (x : \u2102) \u21a6 f x ^ c) x = c * f x ^ (c - 1) * deriv f x :=\n  (hf.hasDerivAt.cpow_const hx).deriv\n\n", "theoremStatement": "theorem isTheta_deriv_ofReal_cpow_const_atTop {c : \u2102} (hc : c \u2260 0) :\n    deriv (fun (x : \u211d) => (x : \u2102) ^ c) =\u0398[atTop] fun x => x ^ (c.re - 1) ", "theoremName": "isTheta_deriv_ofReal_cpow_const_atTop", "fileCreated": {"commit": "a9359cb30d5d2eb08c3c66959305c82fe45fab66", "date": "2023-06-06"}, "theoremCreated": {"commit": "006641492734e60b369ac830260c46c2dcdb7342", "date": "2025-01-20"}, "file": "mathlib/Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean", "module": "Mathlib.Analysis.SpecialFunctions.Pow.Deriv", "jsonFile": "Mathlib.Analysis.SpecialFunctions.Pow.Deriv.jsonl", "positionMetadata": {"lineInFile": 294, "tokenPositionInFile": 14393, "theoremPositionInFile": 40}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 66, "numPremises": 83}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  calc\n    _ =\u1da0[atTop] fun x : \u211d \u21a6 c * x ^ (c - 1) := by\n      filter_upwards [eventually_ne_atTop 0] with x hx using by rw [deriv_ofReal_cpow_const hx hc]\n    _ =\u0398[atTop] fun x : \u211d \u21a6 \u2016(x : \u2102) ^ (c - 1)\u2016 :=\n      (Asymptotics.IsTheta.of_norm_eventuallyEq EventuallyEq.rfl).const_mul_left hc\n    _ =\u1da0[atTop] fun x \u21a6 x ^ (c.re - 1) := by\n      filter_upwards [eventually_gt_atTop 0] with x hx\n      rw [norm_eq_abs, abs_cpow_eq_rpow_re_of_pos hx, sub_re, one_re]", "proofType": "tactic", "proofLengthLines": 8, "proofLengthTokens": 466}}
{"srcContext": "/-\nCopyright (c) 2024 Jo\u00ebl Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jo\u00ebl Riou\n-/\nimport Mathlib.Algebra.Homology.Embedding.Basic\nimport Mathlib.Algebra.Homology.HomologicalComplex\n\n/-!\n# Boundary of an embedding of complex shapes\n\nIn the file `Mathlib.Algebra.Homology.Embedding.Basic`, given `p : \u2124`, we have defined\nan embedding `embeddingUpIntGE p` of `ComplexShape.up \u2115` in `ComplexShape.up \u2124`\nwhich sends `n : \u2115` to `p + n`. The (canonical) truncation (`\u2265 p`) of\n`K : CochainComplex C \u2124` shall be defined as the extension to `\u2124`\n(see `Mathlib.Algebra.Homology.Embedding.Extend`) of\na certain cochain complex indexed by `\u2115`:\n\n`Q \u27f6 K.X (p + 1) \u27f6 K.X (p + 2) \u27f6 K.X (p + 3) \u27f6 ...`\n\nwhere in degree `0`, the object `Q` identifies to the cokernel\nof `K.X (p - 1) \u27f6 K.X p` (this is `K.opcycles p`). In this case,\nwe see that the degree `0 : \u2115` needs a particular attention when\nconstructing the truncation.\n\nIn this file, more generally, for `e : Embedding c c'`, we define\na predicate `\u03b9 \u2192 Prop` named `e.BoundaryGE` which shall be relevant\nwhen constructing the truncation `K.truncGE e` when `e.IsTruncGE`.\nIn the case of `embeddingUpIntGE p`, we show that `0 : \u2115` is the\nonly element in this lower boundary. Similarly, we define\n`Embedding.BoundaryLE`.\n\n-/\n\nnamespace ComplexShape\n\nnamespace Embedding\n\nvariable {\u03b9 \u03b9' : Type*} {c : ComplexShape \u03b9} {c' : ComplexShape \u03b9'} (e : Embedding c c')\n\n/-- The lower boundary of an embedding `e : Embedding c c'`, as a predicate on `\u03b9`.\nIt is satisfied by `j : \u03b9` when there exists `i' : \u03b9'` not in the image of `e.f`\nsuch that `c'.Rel i' (e.f j)`. -/\ndef BoundaryGE (j : \u03b9) : Prop :=\n  c'.Rel (c'.prev (e.f j)) (e.f j) \u2227 \u2200 i, \u00acc'.Rel (e.f i) (e.f j)\n\nlemma boundaryGE {i' : \u03b9'} {j : \u03b9} (hj : c'.Rel i' (e.f j)) (hi' : \u2200 i, e.f i \u2260 i') :\n    e.BoundaryGE j := by\n  constructor\n  \u00b7 simpa only [c'.prev_eq' hj] using hj\n  \u00b7 intro i hi\n    apply hi' i\n    rw [\u2190 c'.prev_eq' hj, c'.prev_eq' hi]\n\nlemma not_boundaryGE_next [e.IsRelIff] {j k : \u03b9} (hk : c.Rel j k) :\n    \u00ac e.BoundaryGE k := by\n  dsimp [BoundaryGE]\n  simp only [not_and, not_forall, not_not]\n  intro\n  exact \u27e8j, by simpa only [e.rel_iff] using hk\u27e9\n\nlemma not_boundaryGE_next' [e.IsRelIff] {j k : \u03b9} (hj : \u00ac e.BoundaryGE j) (hk : c.next j = k) :\n    \u00ac e.BoundaryGE k := by\n  by_cases hjk : c.Rel j k\n  \u00b7 exact e.not_boundaryGE_next hjk\n  \u00b7 subst hk\n    simpa only [c.next_eq_self j hjk] using hj\n\nvariable {e} in\nlemma BoundaryGE.not_mem {j : \u03b9} (hj : e.BoundaryGE j) {i' : \u03b9'} (hi' : c'.Rel i' (e.f j))\n    (a : \u03b9) : e.f a \u2260 i' := fun ha =>\n  hj.2 a (by simpa only [ha] using hi')\n\nlemma prev_f_of_not_boundaryGE [e.IsRelIff] {i j : \u03b9} (hij : c.prev j = i)\n    (hj : \u00ac e.BoundaryGE j) :\n    c'.prev (e.f j) = e.f i := by\n  by_cases hij' : c.Rel i j\n  \u00b7 exact c'.prev_eq' (by simpa only [e.rel_iff] using hij')\n  \u00b7 obtain rfl : j = i := by\n      simpa only [c.prev_eq_self j (by simpa only [hij] using hij')] using hij\n    apply c'.prev_eq_self\n    intro hj'\n    simp only [BoundaryGE, not_and, not_forall, not_not] at hj\n    obtain \u27e8i, hi\u27e9 := hj hj'\n    rw [e.rel_iff] at hi\n    rw [c.prev_eq' hi] at hij\n    exact hij' (by simpa only [hij] using hi)\n\nvariable {e} in\nlemma BoundaryGE.false_of_isTruncLE {j : \u03b9} (hj : e.BoundaryGE j) [e.IsTruncLE] : False := by\n  obtain \u27e8i, hi\u27e9 := e.mem_prev hj.1\n  exact hj.2 i (by simpa only [hi] using hj.1)\n\n/-- The upper boundary of an embedding `e : Embedding c c'`, as a predicate on `\u03b9`.\nIt is satisfied by `j : \u03b9` when there exists `k' : \u03b9'` not in the image of `e.f`\nsuch that `c'.Rel (e.f j) k'`. -/\ndef BoundaryLE (j : \u03b9) : Prop :=\n  c'.Rel (e.f j) (c'.next (e.f j)) \u2227 \u2200 k, \u00acc'.Rel (e.f j) (e.f k)\n\nlemma boundaryLE {k' : \u03b9'} {j : \u03b9} (hj : c'.Rel (e.f j) k') (hk' : \u2200 i, e.f i \u2260 k') :\n    e.BoundaryLE j := by\n  constructor\n  \u00b7 simpa only [c'.next_eq' hj] using hj\n  \u00b7 intro k hk\n    apply hk' k\n    rw [\u2190 c'.next_eq' hj, c'.next_eq' hk]\n\nlemma not_boundaryLE_prev [e.IsRelIff] {i j : \u03b9} (hi : c.Rel i j) :\n    \u00ac e.BoundaryLE i := by\n  dsimp [BoundaryLE]\n  simp only [not_and, not_forall, not_not]\n  intro\n  exact \u27e8j, by simpa only [e.rel_iff] using hi\u27e9\n\nlemma not_boundaryLE_prev' [e.IsRelIff] {i j : \u03b9} (hj : \u00ac e.BoundaryLE j) (hk : c.prev j = i) :\n    \u00ac e.BoundaryLE i := by\n  by_cases hij : c.Rel i j\n  \u00b7 exact e.not_boundaryLE_prev hij\n  \u00b7 subst hk\n    simpa only [c.prev_eq_self j hij] using hj\n\nvariable {e} in\nlemma BoundaryLE.not_mem {j : \u03b9} (hj : e.BoundaryLE j) {k' : \u03b9'} (hk' : c'.Rel (e.f j) k')\n    (a : \u03b9) : e.f a \u2260 k' := fun ha =>\n  hj.2 a (by simpa only [ha] using hk')\n\nlemma next_f_of_not_boundaryLE [e.IsRelIff] {j k : \u03b9} (hjk : c.next j = k)\n    (hj : \u00ac e.BoundaryLE j) :\n    c'.next (e.f j) = e.f k := by\n  by_cases hjk' : c.Rel j k\n  \u00b7 exact c'.next_eq' (by simpa only [e.rel_iff] using hjk')\n  \u00b7 obtain rfl : j = k := by\n      simpa only [c.next_eq_self j (by simpa only [hjk] using hjk')] using hjk\n    apply c'.next_eq_self\n    intro hj'\n    simp only [BoundaryLE, not_and, not_forall, not_not] at hj\n    obtain \u27e8k, hk\u27e9 := hj hj'\n    rw [e.rel_iff] at hk\n    rw [c.next_eq' hk] at hjk\n    exact hjk' (by simpa only [hjk] using hk)\n\nlemma next_f [e.IsTruncGE] {j k : \u03b9} (hjk : c.next j = k) : c'.next (e.f j) = e.f k := by\n  by_cases hj : c'.Rel (e.f j) (c'.next (e.f j))\n  \u00b7 obtain \u27e8k', hk'\u27e9 := e.mem_next hj\n    rw [\u2190 hk', e.rel_iff] at hj\n    rw [\u2190 hk', \u2190 c.next_eq' hj, hjk]\n  \u00b7 rw [c'.next_eq_self _ hj, \u2190 hjk, c.next_eq_self j]\n    intro hj'\n    apply hj\n    rw [\u2190 e.rel_iff] at hj'\n    simpa only [c'.next_eq' hj'] using hj'\n\nlemma prev_f [e.IsTruncLE] {i j : \u03b9} (hij : c.prev j = i) : c'.prev (e.f j) = e.f i :=\n  e.op.next_f hij\n\nvariable {e} in\nlemma BoundaryLE.false_of_isTruncGE {j : \u03b9} (hj : e.BoundaryLE j) [e.IsTruncGE] : False := by\n  obtain \u27e8k, hk\u27e9 := e.mem_next hj.1\n  exact hj.2 k (by simpa only [hk] using hj.1)\n\n", "theoremStatement": "@[simp] lemma op_boundaryLE_iff {j : \u03b9} : e.op.BoundaryLE j \u2194 e.BoundaryGE j ", "theoremName": "ComplexShape.Embedding.op_boundaryLE_iff", "fileCreated": {"commit": "a365570f25dcf0cf70a9c3296a29c92cd71a5b8a", "date": "2024-07-17"}, "theoremCreated": {"commit": "1af25077805df4670d88f3e48778af0c90c7aa98", "date": "2025-01-17"}, "file": "mathlib/Mathlib/Algebra/Homology/Embedding/Boundary.lean", "module": "Mathlib.Algebra.Homology.Embedding.Boundary", "jsonFile": "Mathlib.Algebra.Homology.Embedding.Boundary.jsonl", "positionMetadata": {"lineInFile": 161, "tokenPositionInFile": 5867, "theoremPositionInFile": 16}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 6, "numPremises": 8}, "proofMetadata": {"hasProof": true, "proof": ":= by rfl", "proofType": "tactic", "proofLengthLines": 0, "proofLengthTokens": 9}}
{"srcContext": "/-\nCopyright (c) 2020 Aaron Anderson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Aaron Anderson\n-/\nimport Mathlib.Data.Set.Lattice\nimport Mathlib.Data.SetLike.Basic\nimport Mathlib.Order.ModularLattice\nimport Mathlib.Order.SuccPred.Basic\nimport Mathlib.Order.WellFounded\nimport Mathlib.Tactic.Nontriviality\nimport Mathlib.Order.ConditionallyCompleteLattice.Indexed\n\n/-!\n# Atoms, Coatoms, and Simple Lattices\n\nThis module defines atoms, which are minimal non-`\u22a5` elements in bounded lattices, simple lattices,\nwhich are lattices with only two elements, and related ideas.\n\n## Main definitions\n\n### Atoms and Coatoms\n  * `IsAtom a` indicates that the only element below `a` is `\u22a5`.\n  * `IsCoatom a` indicates that the only element above `a` is `\u22a4`.\n\n### Atomic and Atomistic Lattices\n  * `IsAtomic` indicates that every element other than `\u22a5` is above an atom.\n  * `IsCoatomic` indicates that every element other than `\u22a4` is below a coatom.\n  * `IsAtomistic` indicates that every element is the `sSup` of a set of atoms.\n  * `IsCoatomistic` indicates that every element is the `sInf` of a set of coatoms.\n  * `IsStronglyAtomic` indicates that for all `a < b`, there is some `x` with `a \u22d6 x \u2264 b`.\n  * `IsStronglyCoatomic` indicates that for all `a < b`, there is some `x` with `a \u2264 x \u22d6 b`.\n\n### Simple Lattices\n  * `IsSimpleOrder` indicates that an order has only two unique elements, `\u22a5` and `\u22a4`.\n  * `IsSimpleOrder.boundedOrder`\n  * `IsSimpleOrder.distribLattice`\n  * Given an instance of `IsSimpleOrder`, we provide the following definitions. These are not\n    made global instances as they contain data :\n    * `IsSimpleOrder.booleanAlgebra`\n    * `IsSimpleOrder.completeLattice`\n    * `IsSimpleOrder.completeBooleanAlgebra`\n\n## Main results\n  * `isAtom_dual_iff_isCoatom` and `isCoatom_dual_iff_isAtom` express the (definitional) duality\n   of `IsAtom` and `IsCoatom`.\n  * `isSimpleOrder_iff_isAtom_top` and `isSimpleOrder_iff_isCoatom_bot` express the\n  connection between atoms, coatoms, and simple lattices\n  * `IsCompl.isAtom_iff_isCoatom` and `IsCompl.isCoatom_if_isAtom`: In a modular\n  bounded lattice, a complement of an atom is a coatom and vice versa.\n  * `isAtomic_iff_isCoatomic`: A modular complemented lattice is atomic iff it is coatomic.\n\n-/\n\nvariable {\u03b9 : Sort*} {\u03b1 \u03b2 : Type*}\n\nsection Atoms\n\nsection IsAtom\n\nsection Preorder\n\nvariable [Preorder \u03b1] [OrderBot \u03b1] {a b x : \u03b1}\n\n/-- An atom of an `OrderBot` is an element with no other element between it and `\u22a5`,\n  which is not `\u22a5`. -/\ndef IsAtom (a : \u03b1) : Prop :=\n  a \u2260 \u22a5 \u2227 \u2200 b, b < a \u2192 b = \u22a5\n\ntheorem IsAtom.Iic (ha : IsAtom a) (hax : a \u2264 x) : IsAtom (\u27e8a, hax\u27e9 : Set.Iic x) :=\n  \u27e8fun con => ha.1 (Subtype.mk_eq_mk.1 con), fun \u27e8b, _\u27e9 hba => Subtype.mk_eq_mk.2 (ha.2 b hba)\u27e9\n\ntheorem IsAtom.of_isAtom_coe_Iic {a : Set.Iic x} (ha : IsAtom a) : IsAtom (a : \u03b1) :=\n  \u27e8fun con => ha.1 (Subtype.ext con), fun b hba =>\n    Subtype.mk_eq_mk.1 (ha.2 \u27e8b, hba.le.trans a.prop\u27e9 hba)\u27e9\n\ntheorem isAtom_iff_le_of_ge : IsAtom a \u2194 a \u2260 \u22a5 \u2227 \u2200 b \u2260 \u22a5, b \u2264 a \u2192 a \u2264 b :=\n  and_congr Iff.rfl <|\n    forall_congr' fun b => by\n      simp only [Ne, @not_imp_comm (b = \u22a5), Classical.not_imp, lt_iff_le_not_le]\n\nend Preorder\n\nsection PartialOrder\n\nvariable [PartialOrder \u03b1] [OrderBot \u03b1] {a b x : \u03b1}\n\ntheorem IsAtom.lt_iff (h : IsAtom a) : x < a \u2194 x = \u22a5 :=\n  \u27e8h.2 x, fun hx => hx.symm \u25b8 h.1.bot_lt\u27e9\n\ntheorem IsAtom.le_iff (h : IsAtom a) : x \u2264 a \u2194 x = \u22a5 \u2228 x = a := by rw [le_iff_lt_or_eq, h.lt_iff]\n\nlemma IsAtom.bot_lt (h : IsAtom a) : \u22a5 < a :=\n  h.lt_iff.mpr rfl\n\nlemma IsAtom.le_iff_eq (ha : IsAtom a) (hb : b \u2260 \u22a5) : b \u2264 a \u2194 b = a :=\n  ha.le_iff.trans <| or_iff_right hb\n\ntheorem IsAtom.Iic_eq (h : IsAtom a) : Set.Iic a = {\u22a5, a} :=\n  Set.ext fun _ => h.le_iff\n\n@[simp]\ntheorem bot_covBy_iff : \u22a5 \u22d6 a \u2194 IsAtom a := by\n  simp only [CovBy, bot_lt_iff_ne_bot, IsAtom, not_imp_not]\n\nalias \u27e8CovBy.is_atom, IsAtom.bot_covBy\u27e9 := bot_covBy_iff\n\nend PartialOrder\n\ntheorem atom_le_iSup [Order.Frame \u03b1] {a : \u03b1} (ha : IsAtom a) {f : \u03b9 \u2192 \u03b1} :\n    a \u2264 iSup f \u2194 \u2203 i, a \u2264 f i := by\n  refine \u27e8?_, fun \u27e8i, hi\u27e9 => le_trans hi (le_iSup _ _)\u27e9\n  show (a \u2264 \u2a06 i, f i) \u2192 _\n  refine fun h => of_not_not fun ha' => ?_\n  push_neg at ha'\n  have ha'' : Disjoint a (\u2a06 i, f i) :=\n    disjoint_iSup_iff.2 fun i => fun x hxa hxf => le_bot_iff.2 <| of_not_not fun hx =>\n      have hxa : x < a := (le_iff_eq_or_lt.1 hxa).resolve_left (by rintro rfl; exact ha' _ hxf)\n      hx (ha.2 _ hxa)\n  obtain rfl := le_bot_iff.1 (ha'' le_rfl h)\n  exact ha.1 rfl\n\nend IsAtom\n\nsection IsCoatom\n\nsection Preorder\n\nvariable [Preorder \u03b1]\n\n/-- A coatom of an `OrderTop` is an element with no other element between it and `\u22a4`,\n  which is not `\u22a4`. -/\ndef IsCoatom [OrderTop \u03b1] (a : \u03b1) : Prop :=\n  a \u2260 \u22a4 \u2227 \u2200 b, a < b \u2192 b = \u22a4\n\n@[simp]\ntheorem isCoatom_dual_iff_isAtom [OrderBot \u03b1] {a : \u03b1} :\n    IsCoatom (OrderDual.toDual a) \u2194 IsAtom a :=\n  Iff.rfl\n\n@[simp]\ntheorem isAtom_dual_iff_isCoatom [OrderTop \u03b1] {a : \u03b1} :\n    IsAtom (OrderDual.toDual a) \u2194 IsCoatom a :=\n  Iff.rfl\n\nalias \u27e8_, IsAtom.dual\u27e9 := isCoatom_dual_iff_isAtom\n\nalias \u27e8_, IsCoatom.dual\u27e9 := isAtom_dual_iff_isCoatom\n\nvariable [OrderTop \u03b1] {a x : \u03b1}\n\ntheorem IsCoatom.Ici (ha : IsCoatom a) (hax : x \u2264 a) : IsCoatom (\u27e8a, hax\u27e9 : Set.Ici x) :=\n  ha.dual.Iic hax\n\ntheorem IsCoatom.of_isCoatom_coe_Ici {a : Set.Ici x} (ha : IsCoatom a) : IsCoatom (a : \u03b1) :=\n  @IsAtom.of_isAtom_coe_Iic \u03b1\u1d52\u1d48 _ _ x a ha\n\ntheorem isCoatom_iff_ge_of_le : IsCoatom a \u2194 a \u2260 \u22a4 \u2227 \u2200 b \u2260 \u22a4, a \u2264 b \u2192 b \u2264 a :=\n  isAtom_iff_le_of_ge (\u03b1 := \u03b1\u1d52\u1d48)\n\nend Preorder\n\nsection PartialOrder\n\nvariable [PartialOrder \u03b1] [OrderTop \u03b1] {a b x : \u03b1}\n\ntheorem IsCoatom.lt_iff (h : IsCoatom a) : a < x \u2194 x = \u22a4 :=\n  h.dual.lt_iff\n\ntheorem IsCoatom.le_iff (h : IsCoatom a) : a \u2264 x \u2194 x = \u22a4 \u2228 x = a :=\n  h.dual.le_iff\n\nlemma IsCoatom.lt_top (h : IsCoatom a) : a < \u22a4 :=\n  h.lt_iff.mpr rfl\n\nlemma IsCoatom.le_iff_eq (ha : IsCoatom a) (hb : b \u2260 \u22a4) : a \u2264 b \u2194 b = a := ha.dual.le_iff_eq hb\n\ntheorem IsCoatom.Ici_eq (h : IsCoatom a) : Set.Ici a = {\u22a4, a} :=\n  h.dual.Iic_eq\n\n@[simp]\ntheorem covBy_top_iff : a \u22d6 \u22a4 \u2194 IsCoatom a :=\n  toDual_covBy_toDual_iff.symm.trans bot_covBy_iff\n\nalias \u27e8CovBy.isCoatom, IsCoatom.covBy_top\u27e9 := covBy_top_iff\n\nnamespace SetLike\n\nvariable {A B : Type*} [SetLike A B]\n\ntheorem isAtom_iff [OrderBot A] {K : A} :\n    IsAtom K \u2194 K \u2260 \u22a5 \u2227 \u2200 H g, H \u2264 K \u2192 g \u2209 H \u2192 g \u2208 K \u2192 H = \u22a5 := by\n  simp_rw [IsAtom, lt_iff_le_not_le, SetLike.not_le_iff_exists,\n    and_comm (a := _ \u2264 _), and_imp, exists_imp, \u2190 and_imp, and_comm]\n\ntheorem isCoatom_iff [OrderTop A] {K : A} :\n    IsCoatom K \u2194 K \u2260 \u22a4 \u2227 \u2200 H g, K \u2264 H \u2192 g \u2209 K \u2192 g \u2208 H \u2192 H = \u22a4 := by\n  simp_rw [IsCoatom, lt_iff_le_not_le, SetLike.not_le_iff_exists,\n    and_comm (a := _ \u2264 _), and_imp, exists_imp, \u2190 and_imp, and_comm]\n\n", "theoremStatement": "theorem covBy_iff {K L : A} :\n    K \u22d6 L \u2194 K < L \u2227 \u2200 H g, K \u2264 H \u2192 H \u2264 L \u2192 g \u2209 K \u2192 g \u2208 H \u2192 H = L ", "theoremName": "SetLike.covBy_iff", "fileCreated": {"commit": "8618f40d51539454fe06511d5c8504a77f30c598", "date": "2022-12-30"}, "theoremCreated": {"commit": "74fff29536e0a0eeca1aa8421089b76b157a3b2f", "date": "2025-01-14"}, "file": "mathlib/Mathlib/Order/Atoms.lean", "module": "Mathlib.Order.Atoms", "jsonFile": "Mathlib.Order.Atoms.jsonl", "positionMetadata": {"lineInFile": 201, "tokenPositionInFile": 6718, "theoremPositionInFile": 25}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 14, "numPremises": 45}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  refine and_congr_right fun _ \u21a6 forall_congr' fun H \u21a6 not_iff_not.mp ?_\n  push_neg\n  rw [lt_iff_le_not_le, lt_iff_le_and_ne, and_and_and_comm]\n  simp_rw [exists_and_left, and_assoc, and_congr_right_iff, \u2190 and_assoc, and_comm, exists_and_left,\n    SetLike.not_le_iff_exists, and_comm, implies_true]", "proofType": "tactic", "proofLengthLines": 5, "proofLengthTokens": 304}}
{"srcContext": "/-\nCopyright (c) 2020 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\nimport Mathlib.Algebra.Algebra.Rat\nimport Mathlib.Algebra.BigOperators.NatAntidiagonal\nimport Mathlib.Data.Nat.Choose.Sum\nimport Mathlib.RingTheory.PowerSeries.Basic\n\n/-!\n# Definition of well-known power series\n\nIn this file we define the following power series:\n\n* `PowerSeries.invUnitsSub`: given `u : R\u02e3`, this is the series for `1 / (u - x)`.\n  It is given by `\u2211 n, x ^ n /\u209a u ^ (n + 1)`.\n\n* `PowerSeries.invOneSubPow`: given a commutative ring `S` and a number `d : \u2115`,\n  `PowerSeries.invOneSubPow S d` is the multiplicative inverse of `(1 - X) ^ d` in `S\u27e6X\u27e7\u02e3`.\n  When `d` is `0`, `PowerSeries.invOneSubPow S d` will just be `1`. When `d` is positive,\n  `PowerSeries.invOneSubPow S d` will be `\u2211 n, Nat.choose (d - 1 + n) (d - 1)`.\n\n* `PowerSeries.sin`, `PowerSeries.cos`, `PowerSeries.exp` : power series for sin, cosine, and\n  exponential functions.\n-/\n\n\nnamespace PowerSeries\n\nsection Ring\n\nvariable {R S : Type*} [Ring R] [Ring S]\n\n/-- The power series for `1 / (u - x)`. -/\ndef invUnitsSub (u : R\u02e3) : PowerSeries R :=\n  mk fun n => 1 /\u209a u ^ (n + 1)\n\n@[simp]\ntheorem coeff_invUnitsSub (u : R\u02e3) (n : \u2115) : coeff R n (invUnitsSub u) = 1 /\u209a u ^ (n + 1) :=\n  coeff_mk _ _\n\n@[simp]\ntheorem constantCoeff_invUnitsSub (u : R\u02e3) : constantCoeff R (invUnitsSub u) = 1 /\u209a u := by\n  rw [\u2190 coeff_zero_eq_constantCoeff_apply, coeff_invUnitsSub, zero_add, pow_one]\n\n@[simp]\ntheorem invUnitsSub_mul_X (u : R\u02e3) : invUnitsSub u * X = invUnitsSub u * C R u - 1 := by\n  ext (_ | n)\n  \u00b7 simp\n  \u00b7 simp [n.succ_ne_zero, pow_succ']\n\n@[simp]\ntheorem invUnitsSub_mul_sub (u : R\u02e3) : invUnitsSub u * (C R u - X) = 1 := by\n  simp [mul_sub, sub_sub_cancel]\n\ntheorem map_invUnitsSub (f : R \u2192+* S) (u : R\u02e3) :\n    map f (invUnitsSub u) = invUnitsSub (Units.map (f : R \u2192* S) u) := by\n  ext\n  simp only [\u2190 map_pow, coeff_map, coeff_invUnitsSub, one_divp]\n  rfl\n\nend Ring\n\nsection invOneSubPow\n\nvariable (S : Type*) [CommRing S] (d : \u2115)\n\n/--\n(1 + X + X^2 + ...) * (1 - X) = 1.\n\nNote that the power series `1 + X + X^2 + ...` is written as `mk 1` where `1` is the constant\nfunction so that `mk 1` is the power series with all coefficients equal to one.\n-/\ntheorem mk_one_mul_one_sub_eq_one : (mk 1 : S\u27e6X\u27e7) * (1 - X) = 1 := by\n  rw [mul_comm, PowerSeries.ext_iff]\n  intro n\n  cases n with\n  | zero => simp\n  | succ n => simp [sub_mul]\n\n/--\nNote that `mk 1` is the constant function `1` so the power series `1 + X + X^2 + ...`. This theorem\nstates that for any `d : \u2115`, `(1 + X + X^2 + ... : S\u27e6X\u27e7) ^ (d + 1)` is equal to the power series\n`mk fun n => Nat.choose (d + n) d : S\u27e6X\u27e7`.\n-/\ntheorem mk_one_pow_eq_mk_choose_add :\n    (mk 1 : S\u27e6X\u27e7) ^ (d + 1) = (mk fun n => Nat.choose (d + n) d : S\u27e6X\u27e7) := by\n  induction d with\n  | zero => ext; simp\n  | succ d hd =>\n      ext n\n      rw [pow_add, hd, pow_one, mul_comm, coeff_mul]\n      simp_rw [coeff_mk, Pi.one_apply, one_mul]\n      norm_cast\n      rw [Finset.sum_antidiagonal_choose_add, add_right_comm]\n\n/--\nGiven a natural number `d : \u2115` and a commutative ring `S`, `PowerSeries.invOneSubPow S d` is the\nmultiplicative inverse of `(1 - X) ^ d` in `S\u27e6X\u27e7\u02e3`. When `d` is `0`, `PowerSeries.invOneSubPow S d`\nwill just be `1`. When `d` is positive, `PowerSeries.invOneSubPow S d` will be the power series\n`mk fun n => Nat.choose (d - 1 + n) (d - 1)`.\n-/\nnoncomputable def invOneSubPow : \u2115 \u2192 S\u27e6X\u27e7\u02e3\n  | 0 => 1\n  | d + 1 => {\n    val := mk fun n => Nat.choose (d + n) d\n    inv := (1 - X) ^ (d + 1)\n    val_inv := by\n      rw [\u2190 mk_one_pow_eq_mk_choose_add, \u2190 mul_pow, mk_one_mul_one_sub_eq_one, one_pow]\n    inv_val := by\n      rw [\u2190 mk_one_pow_eq_mk_choose_add, \u2190 mul_pow, mul_comm, mk_one_mul_one_sub_eq_one, one_pow]\n    }\n\ntheorem invOneSubPow_zero : invOneSubPow S 0 = 1 := by\n  delta invOneSubPow\n  simp only [Units.val_one]\n\ntheorem invOneSubPow_val_eq_mk_sub_one_add_choose_of_pos (h : 0 < d) :\n    (invOneSubPow S d).val = (mk fun n => Nat.choose (d - 1 + n) (d - 1) : S\u27e6X\u27e7) := by\n  rw [\u2190 Nat.sub_one_add_one_eq_of_pos h, invOneSubPow, add_tsub_cancel_right]\n\ntheorem invOneSubPow_val_succ_eq_mk_add_choose :\n    (invOneSubPow S (d + 1)).val = (mk fun n => Nat.choose (d + n) d : S\u27e6X\u27e7) := rfl\n\ntheorem invOneSubPow_val_one_eq_invUnitSub_one :\n    (invOneSubPow S 1).val = invUnitsSub (1 : S\u02e3) := by\n  simp [invOneSubPow, invUnitsSub]\n\n/--\nThe theorem `PowerSeries.mk_one_mul_one_sub_eq_one` implies that `1 - X` is a unit in `S\u27e6X\u27e7`\nwhose inverse is the power series `1 + X + X^2 + ...`. This theorem states that for any `d : \u2115`,\n`PowerSeries.invOneSubPow S d` is equal to `(1 - X)\u207b\u00b9 ^ d`.\n-/\ntheorem invOneSubPow_eq_inv_one_sub_pow :\n    invOneSubPow S d =\n      (Units.mkOfMulEqOne (1 - X) (mk 1 : S\u27e6X\u27e7) <|\n        Eq.trans (mul_comm _ _) (mk_one_mul_one_sub_eq_one S))\u207b\u00b9 ^ d := by\n  induction d with\n  | zero => exact Eq.symm <| pow_zero _\n  | succ d _ =>\n      rw [inv_pow]\n      exact (DivisionMonoid.inv_eq_of_mul _ (invOneSubPow S (d + 1)) <| by\n        rw [\u2190 Units.val_eq_one, Units.val_mul, Units.val_pow_eq_pow_val]\n        exact (invOneSubPow S (d + 1)).inv_val).symm\n\ntheorem invOneSubPow_inv_eq_one_sub_pow :\n    (invOneSubPow S d).inv = (1 - X : S\u27e6X\u27e7) ^ d := by\n  induction d with\n  | zero => exact Eq.symm <| pow_zero _\n  | succ d => rfl\n\n", "theoremStatement": "theorem invOneSubPow_inv_zero_eq_one : (invOneSubPow S 0).inv = 1 ", "theoremName": "PowerSeries.invOneSubPow_inv_zero_eq_one", "fileCreated": {"commit": "d22d5a028da58fd6edc1f288ee97594ef5b586a1", "date": "2023-05-22"}, "theoremCreated": {"commit": "561e050467d2caa2e4ea5d81ca62600bf268b747", "date": "2024-12-02"}, "file": "mathlib/Mathlib/RingTheory/PowerSeries/WellKnown.lean", "module": "Mathlib.RingTheory.PowerSeries.WellKnown", "jsonFile": "Mathlib.RingTheory.PowerSeries.WellKnown.jsonl", "positionMetadata": {"lineInFile": 153, "tokenPositionInFile": 5327, "theoremPositionInFile": 14}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 26, "numPremises": 37}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  delta invOneSubPow\n  simp only [Units.inv_eq_val_inv, inv_one, Units.val_one]", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 85}}
{"srcContext": "/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Chris Hughes, Anne Baanen\n-/\nimport Mathlib.Data.Matrix.Basic\nimport Mathlib.Data.Matrix.Block\nimport Mathlib.Data.Matrix.Notation\nimport Mathlib.Data.Matrix.RowCol\nimport Mathlib.GroupTheory.GroupAction.Ring\nimport Mathlib.GroupTheory.Perm.Fin\nimport Mathlib.LinearAlgebra.Alternating.Basic\nimport Mathlib.LinearAlgebra.Matrix.SemiringInverse\n\n/-!\n# Determinant of a matrix\n\nThis file defines the determinant of a matrix, `Matrix.det`, and its essential properties.\n\n## Main definitions\n\n - `Matrix.det`: the determinant of a square matrix, as a sum over permutations\n - `Matrix.detRowAlternating`: the determinant, as an `AlternatingMap` in the rows of the matrix\n\n## Main results\n\n - `det_mul`: the determinant of `A * B` is the product of determinants\n - `det_zero_of_row_eq`: the determinant is zero if there is a repeated row\n - `det_block_diagonal`: the determinant of a block diagonal matrix is a product\n   of the blocks' determinants\n\n## Implementation notes\n\nIt is possible to configure `simp` to compute determinants. See the file\n`MathlibTest/matrix.lean` for some examples.\n\n-/\n\n\nuniverse u v w z\n\nopen Equiv Equiv.Perm Finset Function\n\nnamespace Matrix\n\nvariable {m n : Type*} [DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m]\nvariable {R : Type v} [CommRing R]\n\nlocal notation \"\u03b5 \" \u03c3:arg => ((sign \u03c3 : \u2124) : R)\n\n/-- `det` is an `AlternatingMap` in the rows of the matrix. -/\ndef detRowAlternating : (n \u2192 R) [\u22c0^n]\u2192\u2097[R] R :=\n  MultilinearMap.alternatization ((MultilinearMap.mkPiAlgebra R n R).compLinearMap LinearMap.proj)\n\n/-- The determinant of a matrix given by the Leibniz formula. -/\nabbrev det (M : Matrix n n R) : R :=\n  detRowAlternating M\n\ntheorem det_apply (M : Matrix n n R) : M.det = \u2211 \u03c3 : Perm n, Equiv.Perm.sign \u03c3 \u2022 \u220f i, M (\u03c3 i) i :=\n  MultilinearMap.alternatization_apply _ M\n\n-- This is what the old definition was. We use it to avoid having to change the old proofs below\ntheorem det_apply' (M : Matrix n n R) : M.det = \u2211 \u03c3 : Perm n, \u03b5 \u03c3 * \u220f i, M (\u03c3 i) i := by\n  simp [det_apply, Units.smul_def]\n\ntheorem det_eq_detp_sub_detp (M : Matrix n n R) : M.det = M.detp 1 - M.detp (-1) := by\n  rw [det_apply, \u2190 Equiv.sum_comp (Equiv.inv (Perm n)), \u2190 ofSign_disjUnion, sum_disjUnion]\n  simp_rw [inv_apply, sign_inv, sub_eq_add_neg, detp, \u2190 sum_neg_distrib]\n  refine congr_arg\u2082 (\u00b7 + \u00b7) (sum_congr rfl fun \u03c3 h\u03c3 \u21a6 ?_) (sum_congr rfl fun \u03c3 h\u03c3 \u21a6 ?_) <;>\n    rw [mem_ofSign.mp h\u03c3, \u2190 Equiv.prod_comp \u03c3] <;> simp\n\n@[simp]\ntheorem det_diagonal {d : n \u2192 R} : det (diagonal d) = \u220f i, d i := by\n  rw [det_apply']\n  refine (Finset.sum_eq_single 1 ?_ ?_).trans ?_\n  \u00b7 rintro \u03c3 - h2\n    cases' not_forall.1 (mt Equiv.ext h2) with x h3\n    convert mul_zero (\u03b5 \u03c3)\n    apply Finset.prod_eq_zero (mem_univ x)\n    exact if_neg h3\n  \u00b7 simp\n  \u00b7 simp\n\ntheorem det_zero (_ : Nonempty n) : det (0 : Matrix n n R) = 0 :=\n  (detRowAlternating : (n \u2192 R) [\u22c0^n]\u2192\u2097[R] R).map_zero\n\n@[simp]\ntheorem det_one : det (1 : Matrix n n R) = 1 := by rw [\u2190 diagonal_one]; simp [-diagonal_one]\n\ntheorem det_isEmpty [IsEmpty n] {A : Matrix n n R} : det A = 1 := by simp [det_apply]\n\n@[simp]\ntheorem coe_det_isEmpty [IsEmpty n] : (det : Matrix n n R \u2192 R) = Function.const _ 1 := by\n  ext\n  exact det_isEmpty\n\ntheorem det_eq_one_of_card_eq_zero {A : Matrix n n R} (h : Fintype.card n = 0) : det A = 1 :=\n  haveI : IsEmpty n := Fintype.card_eq_zero_iff.mp h\n  det_isEmpty\n\n/-- If `n` has only one element, the determinant of an `n` by `n` matrix is just that element.\nAlthough `Unique` implies `DecidableEq` and `Fintype`, the instances might\nnot be syntactically equal. Thus, we need to fill in the args explicitly. -/\n@[simp]\ntheorem det_unique {n : Type*} [Unique n] [DecidableEq n] [Fintype n] (A : Matrix n n R) :\n    det A = A default default := by simp [det_apply, univ_unique]\n\ntheorem det_eq_elem_of_subsingleton [Subsingleton n] (A : Matrix n n R) (k : n) :\n    det A = A k k := by\n  have := uniqueOfSubsingleton k\n  convert det_unique A\n\ntheorem det_eq_elem_of_card_eq_one {A : Matrix n n R} (h : Fintype.card n = 1) (k : n) :\n    det A = A k k :=\n  haveI : Subsingleton n := Fintype.card_le_one_iff_subsingleton.mp h.le\n  det_eq_elem_of_subsingleton _ _\n\ntheorem det_mul_aux {M N : Matrix n n R} {p : n \u2192 n} (H : \u00acBijective p) :\n    (\u2211 \u03c3 : Perm n, \u03b5 \u03c3 * \u220f x, M (\u03c3 x) (p x) * N (p x) x) = 0 := by\n  obtain \u27e8i, j, hpij, hij\u27e9 : \u2203 i j, p i = p j \u2227 i \u2260 j := by\n    rw [\u2190 Finite.injective_iff_bijective, Injective] at H\n    push_neg at H\n    exact H\n  exact\n    sum_involution (fun \u03c3 _ => \u03c3 * Equiv.swap i j)\n      (fun \u03c3 _ => by\n        have : (\u220f x, M (\u03c3 x) (p x)) = \u220f x, M ((\u03c3 * Equiv.swap i j) x) (p x) :=\n          Fintype.prod_equiv (swap i j) _ _ (by simp [apply_swap_eq_self hpij])\n        simp [this, sign_swap hij, -sign_swap', prod_mul_distrib])\n      (fun \u03c3 _ _ => (not_congr mul_swap_eq_iff).mpr hij) (fun _ _ => mem_univ _) fun \u03c3 _ =>\n      mul_swap_involutive i j \u03c3\n\n@[simp]\ntheorem det_mul (M N : Matrix n n R) : det (M * N) = det M * det N :=\n  calc\n    det (M * N) = \u2211 p : n \u2192 n, \u2211 \u03c3 : Perm n, \u03b5 \u03c3 * \u220f i, M (\u03c3 i) (p i) * N (p i) i := by\n      simp only [det_apply', mul_apply, prod_univ_sum, mul_sum, Fintype.piFinset_univ]\n      rw [Finset.sum_comm]\n    _ = \u2211 p : n \u2192 n with Bijective p, \u2211 \u03c3 : Perm n, \u03b5 \u03c3 * \u220f i, M (\u03c3 i) (p i) * N (p i) i := by\n      refine (sum_subset (filter_subset _ _) fun f _ hbij \u21a6 det_mul_aux ?_).symm\n      simpa only [true_and, mem_filter, mem_univ] using hbij\n    _ = \u2211 \u03c4 : Perm n, \u2211 \u03c3 : Perm n, \u03b5 \u03c3 * \u220f i, M (\u03c3 i) (\u03c4 i) * N (\u03c4 i) i :=\n      sum_bij (fun p h \u21a6 Equiv.ofBijective p (mem_filter.1 h).2) (fun _ _ \u21a6 mem_univ _)\n        (fun _ _ _ _ h \u21a6 by injection h)\n        (fun b _ \u21a6 \u27e8b, mem_filter.2 \u27e8mem_univ _, b.bijective\u27e9, coe_fn_injective rfl\u27e9) fun _ _ \u21a6 rfl\n    _ = \u2211 \u03c3 : Perm n, \u2211 \u03c4 : Perm n, (\u220f i, N (\u03c3 i) i) * \u03b5 \u03c4 * \u220f j, M (\u03c4 j) (\u03c3 j) := by\n      simp only [mul_comm, mul_left_comm, prod_mul_distrib, mul_assoc]\n    _ = \u2211 \u03c3 : Perm n, \u2211 \u03c4 : Perm n, (\u220f i, N (\u03c3 i) i) * (\u03b5 \u03c3 * \u03b5 \u03c4) * \u220f i, M (\u03c4 i) i :=\n      (sum_congr rfl fun \u03c3 _ =>\n        Fintype.sum_equiv (Equiv.mulRight \u03c3\u207b\u00b9) _ _ fun \u03c4 => by\n          have : (\u220f j, M (\u03c4 j) (\u03c3 j)) = \u220f j, M ((\u03c4 * \u03c3\u207b\u00b9) j) j := by\n            rw [\u2190 (\u03c3\u207b\u00b9 : _ \u2243 _).prod_comp]\n            simp only [Equiv.Perm.coe_mul, apply_inv_self, Function.comp_apply]\n          have h : \u03b5 \u03c3 * \u03b5 (\u03c4 * \u03c3\u207b\u00b9) = \u03b5 \u03c4 :=\n            calc\n              \u03b5 \u03c3 * \u03b5 (\u03c4 * \u03c3\u207b\u00b9) = \u03b5 (\u03c4 * \u03c3\u207b\u00b9 * \u03c3) := by\n                rw [mul_comm, sign_mul (\u03c4 * \u03c3\u207b\u00b9)]\n                simp only [Int.cast_mul, Units.val_mul]\n              _ = \u03b5 \u03c4 := by simp only [inv_mul_cancel_right]\n\n          simp_rw [Equiv.coe_mulRight, h]\n          simp only [this])\n    _ = det M * det N := by\n      simp only [det_apply', Finset.mul_sum, mul_comm, mul_left_comm, mul_assoc]\n\n/-- The determinant of a matrix, as a monoid homomorphism. -/\ndef detMonoidHom : Matrix n n R \u2192* R where\n  toFun := det\n  map_one' := det_one\n  map_mul' := det_mul\n\n@[simp]\ntheorem coe_detMonoidHom : (detMonoidHom : Matrix n n R \u2192 R) = det :=\n  rfl\n\n/-- On square matrices, `mul_comm` applies under `det`. -/\ntheorem det_mul_comm (M N : Matrix m m R) : det (M * N) = det (N * M) := by\n  rw [det_mul, det_mul, mul_comm]\n\n/-- On square matrices, `mul_left_comm` applies under `det`. -/\ntheorem det_mul_left_comm (M N P : Matrix m m R) : det (M * (N * P)) = det (N * (M * P)) := by\n  rw [\u2190 Matrix.mul_assoc, \u2190 Matrix.mul_assoc, det_mul, det_mul_comm M N, \u2190 det_mul]\n\n/-- On square matrices, `mul_right_comm` applies under `det`. -/\ntheorem det_mul_right_comm (M N P : Matrix m m R) : det (M * N * P) = det (M * P * N) := by\n  rw [Matrix.mul_assoc, Matrix.mul_assoc, det_mul, det_mul_comm N P, \u2190 det_mul]\n\n-- TODO(https://github.com/leanprover-community/mathlib4/issues/6607): fix elaboration so `val` isn't needed\ntheorem det_units_conj (M : (Matrix m m R)\u02e3) (N : Matrix m m R) :\n    det (M.val * N * M\u207b\u00b9.val) = det N := by\n  rw [det_mul_right_comm, Units.mul_inv, one_mul]\n\n-- TODO(https://github.com/leanprover-community/mathlib4/issues/6607): fix elaboration so `val` isn't needed\ntheorem det_units_conj' (M : (Matrix m m R)\u02e3) (N : Matrix m m R) :\n    det (M\u207b\u00b9.val * N * \u2191M.val) = det N :=\n  det_units_conj M\u207b\u00b9 N\n\n/-- Transposing a matrix preserves the determinant. -/\n@[simp]\ntheorem det_transpose (M : Matrix n n R) : M\u1d40.det = M.det := by\n  rw [det_apply', det_apply']\n  refine Fintype.sum_bijective _ inv_involutive.bijective _ _ ?_\n  intro \u03c3\n  rw [sign_inv]\n  congr 1\n  apply Fintype.prod_equiv \u03c3\n  simp\n\n/-- Permuting the columns changes the sign of the determinant. -/\ntheorem det_permute (\u03c3 : Perm n) (M : Matrix n n R) :\n    (M.submatrix \u03c3 id).det = Perm.sign \u03c3 * M.det :=\n  ((detRowAlternating : (n \u2192 R) [\u22c0^n]\u2192\u2097[R] R).map_perm M \u03c3).trans (by simp [Units.smul_def])\n\n/-- Permuting the rows changes the sign of the determinant. -/\ntheorem det_permute' (\u03c3 : Perm n) (M : Matrix n n R) :\n    (M.submatrix id \u03c3).det = Perm.sign \u03c3 * M.det := by\n  rw [\u2190 det_transpose, transpose_submatrix, det_permute, det_transpose]\n\n/-- Permuting rows and columns with the same equivalence does not change the determinant. -/\n@[simp]\ntheorem det_submatrix_equiv_self (e : n \u2243 m) (A : Matrix m m R) :\n    det (A.submatrix e e) = det A := by\n  rw [det_apply', det_apply']\n  apply Fintype.sum_equiv (Equiv.permCongr e)\n  intro \u03c3\n  rw [Equiv.Perm.sign_permCongr e \u03c3]\n  congr 1\n  apply Fintype.prod_equiv e\n  intro i\n  rw [Equiv.permCongr_apply, Equiv.symm_apply_apply, submatrix_apply]\n\n/-- Permuting rows and columns with two equivalences does not change the absolute value of the\ndeterminant. -/\n@[simp]\ntheorem abs_det_submatrix_equiv_equiv {R : Type*} [LinearOrderedCommRing R]\n    (e\u2081 e\u2082 : n \u2243 m) (A : Matrix m m R) :\n    |(A.submatrix e\u2081 e\u2082).det| = |A.det| := by\n  have hee : e\u2082 = e\u2081.trans (e\u2081.symm.trans e\u2082) := by ext; simp\n  rw [hee]\n  show |((A.submatrix id (e\u2081.symm.trans e\u2082)).submatrix e\u2081 e\u2081).det| = |A.det|\n  rw [Matrix.det_submatrix_equiv_self, Matrix.det_permute', abs_mul, abs_unit_intCast, one_mul]\n\n/-- Reindexing both indices along the same equivalence preserves the determinant.\n\nFor the `simp` version of this lemma, see `det_submatrix_equiv_self`; this one is unsuitable because\n`Matrix.reindex_apply` unfolds `reindex` first.\n-/\ntheorem det_reindex_self (e : m \u2243 n) (A : Matrix m m R) : det (reindex e e A) = det A :=\n  det_submatrix_equiv_self e.symm A\n\ntheorem det_smul (A : Matrix n n R) (c : R) : det (c \u2022 A) = c ^ Fintype.card n * det A :=\n  calc\n    det (c \u2022 A) = det ((diagonal fun _ => c) * A) := by rw [smul_eq_diagonal_mul]\n    _ = det (diagonal fun _ => c) * det A := det_mul _ _\n    _ = c ^ Fintype.card n * det A := by simp [card_univ]\n\n@[simp]\ntheorem det_smul_of_tower {\u03b1} [Monoid \u03b1] [DistribMulAction \u03b1 R] [IsScalarTower \u03b1 R R]\n    [SMulCommClass \u03b1 R R] (c : \u03b1) (A : Matrix n n R) :\n    det (c \u2022 A) = c ^ Fintype.card n \u2022 det A := by\n  rw [\u2190 smul_one_smul R c A, det_smul, smul_pow, one_pow, smul_mul_assoc, one_mul]\n\ntheorem det_neg (A : Matrix n n R) : det (-A) = (-1) ^ Fintype.card n * det A := by\n  rw [\u2190 det_smul, neg_one_smul]\n\n/-- A variant of `Matrix.det_neg` with scalar multiplication by `Units \u2124` instead of multiplication\nby `R`. -/\ntheorem det_neg_eq_smul (A : Matrix n n R) :\n    det (-A) = (-1 : Units \u2124) ^ Fintype.card n \u2022 det A := by\n  rw [\u2190 det_smul_of_tower, Units.neg_smul, one_smul]\n\n/-- Multiplying each row by a fixed `v i` multiplies the determinant by\nthe product of the `v`s. -/\ntheorem det_mul_row (v : n \u2192 R) (A : Matrix n n R) :\n    det (of fun i j => v j * A i j) = (\u220f i, v i) * det A :=\n  calc\n    det (of fun i j => v j * A i j) = det (A * diagonal v) :=\n      congr_arg det <| by\n        ext\n        simp [mul_comm]\n    _ = (\u220f i, v i) * det A := by rw [det_mul, det_diagonal, mul_comm]\n\n/-- Multiplying each column by a fixed `v j` multiplies the determinant by\nthe product of the `v`s. -/\ntheorem det_mul_column (v : n \u2192 R) (A : Matrix n n R) :\n    det (of fun i j => v i * A i j) = (\u220f i, v i) * det A :=\n  MultilinearMap.map_smul_univ _ v A\n\n@[simp]\ntheorem det_pow (M : Matrix m m R) (n : \u2115) : det (M ^ n) = det M ^ n :=\n  (detMonoidHom : Matrix m m R \u2192* R).map_pow M n\n\nsection HomMap\n\nvariable {S : Type w} [CommRing S]\n\ntheorem _root_.RingHom.map_det (f : R \u2192+* S) (M : Matrix n n R) :\n    f M.det = Matrix.det (f.mapMatrix M) := by\n  simp [Matrix.det_apply', map_sum f, map_prod f]\n\ntheorem _root_.RingEquiv.map_det (f : R \u2243+* S) (M : Matrix n n R) :\n    f M.det = Matrix.det (f.mapMatrix M) :=\n  f.toRingHom.map_det _\n\ntheorem _root_.AlgHom.map_det [Algebra R S] {T : Type z} [CommRing T] [Algebra R T] (f : S \u2192\u2090[R] T)\n    (M : Matrix n n S) : f M.det = Matrix.det (f.mapMatrix M) :=\n  f.toRingHom.map_det _\n\ntheorem _root_.AlgEquiv.map_det [Algebra R S] {T : Type z} [CommRing T] [Algebra R T]\n    (f : S \u2243\u2090[R] T) (M : Matrix n n S) : f M.det = Matrix.det (f.mapMatrix M) :=\n  f.toAlgHom.map_det _\n\nend HomMap\n\n@[simp]\ntheorem det_conjTranspose [StarRing R] (M : Matrix m m R) : det M\u1d34 = star (det M) :=\n  ((starRingEnd R).map_det _).symm.trans <| congr_arg star M.det_transpose\n\nsection DetZero\n\n/-!\n### `det_zero` section\n\nProve that a matrix with a repeated column has determinant equal to zero.\n-/\n\n\ntheorem det_eq_zero_of_row_eq_zero {A : Matrix n n R} (i : n) (h : \u2200 j, A i j = 0) : det A = 0 :=\n  (detRowAlternating : (n \u2192 R) [\u22c0^n]\u2192\u2097[R] R).map_coord_zero i (funext h)\n\ntheorem det_eq_zero_of_column_eq_zero {A : Matrix n n R} (j : n) (h : \u2200 i, A i j = 0) :\n    det A = 0 := by\n  rw [\u2190 det_transpose]\n  exact det_eq_zero_of_row_eq_zero j h\n\nvariable {M : Matrix n n R} {i j : n}\n\n/-- If a matrix has a repeated row, the determinant will be zero. -/\ntheorem det_zero_of_row_eq (i_ne_j : i \u2260 j) (hij : M i = M j) : M.det = 0 :=\n  (detRowAlternating : (n \u2192 R) [\u22c0^n]\u2192\u2097[R] R).map_eq_zero_of_eq M hij i_ne_j\n\n/-- If a matrix has a repeated column, the determinant will be zero. -/\ntheorem det_zero_of_column_eq (i_ne_j : i \u2260 j) (hij : \u2200 k, M k i = M k j) : M.det = 0 := by\n  rw [\u2190 det_transpose, det_zero_of_row_eq i_ne_j]\n  exact funext hij\n\n/-- If we repeat a row of a matrix, we get a matrix of determinant zero. -/\ntheorem det_updateRow_eq_zero (h : i \u2260 j) :\n    (M.updateRow j (M i)).det = 0 := det_zero_of_row_eq h (by simp [h])\n\n/-- If we repeat a column of a matrix, we get a matrix of determinant zero. -/\ntheorem det_updateCol_eq_zero (h : i \u2260 j) :\n    (M.updateCol j (fun k \u21a6 M k i)).det = 0 := det_zero_of_column_eq h (by simp [h])\n\n@[deprecated (since := \"2024-12-11\")] alias det_updateColumn_eq_zero := det_updateCol_eq_zero\n\nend DetZero\n\ntheorem det_updateRow_add (M : Matrix n n R) (j : n) (u v : n \u2192 R) :\n    det (updateRow M j <| u + v) = det (updateRow M j u) + det (updateRow M j v) :=\n  (detRowAlternating : (n \u2192 R) [\u22c0^n]\u2192\u2097[R] R).map_update_add M j u v\n\ntheorem det_updateCol_add (M : Matrix n n R) (j : n) (u v : n \u2192 R) :\n    det (updateCol M j <| u + v) = det (updateCol M j u) + det (updateCol M j v) := by\n  rw [\u2190 det_transpose, \u2190 updateRow_transpose, det_updateRow_add]\n  simp [updateRow_transpose, det_transpose]\n\n@[deprecated (since := \"2024-12-11\")] alias det_updateColumn_add := det_updateCol_add\n\ntheorem det_updateRow_smul (M : Matrix n n R) (j : n) (s : R) (u : n \u2192 R) :\n    det (updateRow M j <| s \u2022 u) = s * det (updateRow M j u) :=\n  (detRowAlternating : (n \u2192 R) [\u22c0^n]\u2192\u2097[R] R).map_update_smul M j s u\n\ntheorem det_updateCol_smul (M : Matrix n n R) (j : n) (s : R) (u : n \u2192 R) :\n    det (updateCol M j <| s \u2022 u) = s * det (updateCol M j u) := by\n  rw [\u2190 det_transpose, \u2190 updateRow_transpose, det_updateRow_smul]\n  simp [updateRow_transpose, det_transpose]\n\n@[deprecated (since := \"2024-12-11\")] alias det_updateColumn_smul := det_updateCol_smul\n\ntheorem det_updateRow_smul_left (M : Matrix n n R) (j : n) (s : R) (u : n \u2192 R) :\n    det (updateRow (s \u2022 M) j u) = s ^ (Fintype.card n - 1) * det (updateRow M j u) :=\n  MultilinearMap.map_update_smul_left _ M j s u\n\n@[deprecated (since := \"2024-11-03\")] alias det_updateRow_smul' := det_updateRow_smul_left\n\ntheorem det_updateCol_smul_left (M : Matrix n n R) (j : n) (s : R) (u : n \u2192 R) :\n    det (updateCol (s \u2022 M) j u) = s ^ (Fintype.card n - 1) * det (updateCol M j u) := by\n  rw [\u2190 det_transpose, \u2190 updateRow_transpose, transpose_smul, det_updateRow_smul_left]\n  simp [updateRow_transpose, det_transpose]\n\n@[deprecated (since := \"2024-12-11\")] alias det_updateColumn_smul' := det_updateCol_smul_left\n@[deprecated (since := \"2024-12-11\")] alias det_updateColumn_smul_left := det_updateCol_smul_left\n\ntheorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j \u2209 s) (c : n \u2192 R)\n    (a : R) :\n    (M.updateRow j (a \u2022 M j + \u2211 k \u2208 s, (c k) \u2022 M k)).det = a \u2022 M.det := by\n  induction s using Finset.induction_on with\n  | empty => rw [Finset.sum_empty, add_zero, smul_eq_mul, det_updateRow_smul, updateRow_eq_self]\n  | @insert k _ hk h_ind =>\n      have h : k \u2260 j := fun h \u21a6 (h \u25b8 hj) (Finset.mem_insert_self _ _)\n      rw [Finset.sum_insert hk, add_comm ((c k) \u2022 M k), \u2190 add_assoc, det_updateRow_add,\n        det_updateRow_smul, det_updateRow_eq_zero h, mul_zero, add_zero, h_ind]\n      exact fun h \u21a6 hj (Finset.mem_insert_of_mem h)\n\n/-- If we replace a row of a matrix by a linear combination of its rows, then the determinant is\nmultiplied by the coefficient of that row. -/\ntheorem det_updateRow_sum (A : Matrix n n R) (j : n) (c : n \u2192 R) :\n    (A.updateRow j (\u2211 k, (c k) \u2022 A k)).det = (c j) \u2022 A.det := by\n  convert det_updateRow_sum_aux A (Finset.univ.erase j) (Finset.univ.not_mem_erase j) c (c j)\n  rw [\u2190 Finset.univ.add_sum_erase _ (Finset.mem_univ j)]\n\n", "theoremStatement": "/-- If we replace a column of a matrix by a linear combination of its columns, then the determinant\nis multiplied by the coefficient of that column. -/\ntheorem det_updateCol_sum (A : Matrix n n R) (j : n) (c : n \u2192 R) :\n    (A.updateCol j (fun k \u21a6 \u2211 i, (c i) \u2022 A k i)).det = (c j) \u2022 A.det ", "theoremName": "Matrix.det_updateCol_sum", "fileCreated": {"commit": "3438911a821fa2fb5ba37cdbec993e952646aeca", "date": "2024-06-03"}, "theoremCreated": {"commit": "afdb9499da5095474266bcb3b723120eaf923aec", "date": "2024-12-11"}, "file": "mathlib/Mathlib/LinearAlgebra/Matrix/Determinant/Basic.lean", "module": "Mathlib.LinearAlgebra.Matrix.Determinant.Basic", "jsonFile": "Mathlib.LinearAlgebra.Matrix.Determinant.Basic.jsonl", "positionMetadata": {"lineInFile": 413, "tokenPositionInFile": 17560, "theoremPositionInFile": 54}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 33, "numPremises": 54}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [\u2190 det_transpose, \u2190 updateRow_transpose, \u2190 det_transpose A]\n  convert det_updateRow_sum A.transpose j c\n  simp only [smul_eq_mul, Finset.sum_apply, Pi.smul_apply, transpose_apply]", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 190}}
{"srcContext": "/-\nCopyright (c) 2024 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\nimport Mathlib.RingTheory.Etale.Pi\nimport Mathlib.RingTheory.Unramified.Field\n\n/-!\n# Etale algebras over fields\n\n## Main results\n\nLet `K` be a field, `A` be a `K`-algebra and `L` be a field extension of `K`.\n\n- `Algebra.FormallyEtale.of_isSeparable`:\n    If `L` is separable over `K`, then `L` is formally \u00e9tale over `K`.\n- `Algebra.FormallyEtale.iff_isSeparable`:\n    If `L` is (essentially) of finite type over `K`, then `L/K` is \u00e9tale iff `L/K` is separable.\n- `Algebra.FormallyEtale.iff_exists_algEquiv_prod`:\n    If `A` is (essentially) of finite type over `K`,\n    then `A/K` is \u00e9tale iff `A` is a finite product of separable field extensions.\n- `Algebra.Etale.iff_exists_algEquiv_prod`:\n    `A/K` is \u00e9tale iff `A` is a finite product of finite separable field extensions.\n\n## References\n\n- [B. Iversen, *Generic Local Structure of the Morphisms in Commutative Algebra*][iversen]\n\n-/\n\n\nuniverse u\n\nvariable (K L A : Type u) [Field K] [Field L] [CommRing A] [Algebra K L] [Algebra K A]\n\nopen Algebra Polynomial\n\nopen scoped TensorProduct\n\nnamespace Algebra.FormallyEtale\n\n/--\nThis is a weaker version of `of_isSeparable` that additionally assumes `EssFiniteType K L`.\nUse that instead.\n\nThis is Iversen Corollary II.5.3.\n-/\ntheorem of_isSeparable_aux [Algebra.IsSeparable K L] [EssFiniteType K L] :\n    FormallyEtale K L := by\n  -- We already know that for field extensions\n  -- IsSeparable + EssFiniteType => FormallyUnramified + Finite\n  have := FormallyUnramified.of_isSeparable K L\n  have := FormallyUnramified.finite_of_free (R := K) (S := L)\n  constructor\n  -- We shall show that any `f : L \u2192 B/I` can be lifted to `L \u2192 B` if `I^2 = \u22a5`\n  intros B _ _ I h\n  refine \u27e8FormallyUnramified.iff_comp_injective.mp (FormallyUnramified.of_isSeparable K L) I h, ?_\u27e9\n  intro f\n  -- By separability and finiteness, we may assume `L = K(\u03b1)` with `p` the minpoly of `\u03b1`.\n  let pb := Field.powerBasisOfFiniteOfSeparable K L\n  -- Let `x : B` such that `f(\u03b1) = x` in `B / I`.\n  obtain \u27e8x, hx\u27e9 := Ideal.Quotient.mk_surjective (f pb.gen)\n  have helper : \u2200 x, IsScalarTower.toAlgHom K B (B \u29f8 I) x = Ideal.Quotient.mk I x := fun _ \u21a6 rfl\n  -- Then `p(x) = 0 mod I`, and the goal is to find some `\u03b5 \u2208 I` such that\n  -- `p(x + \u03b5) = p(x) + \u03b5 p'(x) = 0`, and we will get our lift into `B`.\n  have hx' : Ideal.Quotient.mk I (aeval x (minpoly K pb.gen)) = 0 := by\n    rw [\u2190 helper, \u2190 aeval_algHom_apply, helper, hx, aeval_algHom_apply, minpoly.aeval, map_zero]\n  -- Since `p` is separable, `-p'(x)` is invertible in `B \u29f8 I`,\n  obtain \u27e8u, hu\u27e9 : \u2203 u, (aeval x) (derivative (minpoly K pb.gen)) * u + 1 \u2208 I := by\n    have := (isUnit_iff_ne_zero.mpr ((Algebra.IsSeparable.isSeparable K\n      pb.gen).aeval_derivative_ne_zero (minpoly.aeval K _))).map f\n    rw [\u2190 aeval_algHom_apply, \u2190 hx, \u2190 helper, aeval_algHom_apply, helper] at this\n    obtain \u27e8u, hu\u27e9 := Ideal.Quotient.mk_surjective (-this.unit\u207b\u00b9 : B \u29f8 I)\n    use u\n    rw [\u2190 Ideal.Quotient.eq_zero_iff_mem, map_add, map_mul, map_one, hu, mul_neg,\n      IsUnit.mul_val_inv, neg_add_cancel]\n  -- And `\u03b5 = p(x)/(-p'(x))` works.\n  use pb.liftEquiv.symm \u27e8x + u * aeval x (minpoly K pb.gen), ?_\u27e9\n  \u00b7 apply pb.algHom_ext\n    simp [hx, hx']\n  \u00b7 rw [\u2190 eval_map_algebraMap, Polynomial.eval_add_of_sq_eq_zero, derivative_map,\n      \u2190 one_mul (eval x _), eval_map_algebraMap, eval_map_algebraMap, \u2190 mul_assoc, \u2190 add_mul,\n      \u2190 Ideal.mem_bot, \u2190 h, pow_two, add_comm]\n    \u00b7 exact Ideal.mul_mem_mul hu (Ideal.Quotient.eq_zero_iff_mem.mp hx')\n    rw [\u2190 Ideal.mem_bot, \u2190 h]\n    apply Ideal.pow_mem_pow\n    rw [\u2190 Ideal.Quotient.eq_zero_iff_mem, map_mul, hx', mul_zero]\n\nopen scoped IntermediateField in\nlemma of_isSeparable [Algebra.IsSeparable K L] : FormallyEtale K L := by\n  constructor\n  intros B _ _ I h\n  -- We shall show that any `f : L \u2192 B/I` can be lifted to `L \u2192 B` if `I^2 = \u22a5`.\n  -- But we already know that there exists a unique lift for every finite subfield of `L`\n  -- by `of_isSeparable_aux`, so we can glue them all together.\n  refine \u27e8FormallyUnramified.iff_comp_injective.mp (FormallyUnramified.of_isSeparable K L) I h, ?_\u27e9\n  intro f\n  have : \u2200 k : L, \u2203! g : K\u27eek\u27ef \u2192\u2090[K] B,\n      (Ideal.Quotient.mk\u2090 K I).comp g = f.comp (IsScalarTower.toAlgHom K _ L) := by\n    intro k\n    have := IsSeparable.of_algHom _ _ (IsScalarTower.toAlgHom K (K\u27eek\u27ef) L)\n    have := IntermediateField.adjoin.finiteDimensional\n      (Algebra.IsSeparable.isSeparable K k).isIntegral\n    have := FormallyEtale.of_isSeparable_aux K (K\u27eek\u27ef)\n    have := FormallyEtale.comp_bijective (R := K) (A := K\u27eek\u27ef) I h\n    exact this.existsUnique _\n  choose g hg\u2081 hg\u2082 using this\n  have hg\u2083 : \u2200 x y (h : x \u2208 K\u27eey\u27ef), g y \u27e8x, h\u27e9 = g x (IntermediateField.AdjoinSimple.gen K x) := by\n    intro x y h\n    have e : K\u27eex\u27ef \u2264 K\u27eey\u27ef := by\n      rw [IntermediateField.adjoin_le_iff]\n      rintro _ rfl\n      exact h\n    rw [\u2190 hg\u2082 _ ((g _).comp (IntermediateField.inclusion e))]\n    \u00b7 rfl\n    apply AlgHom.ext\n    intro \u27e8a, _\u27e9\n    rw [\u2190 AlgHom.comp_assoc, hg\u2081, AlgHom.comp_assoc]\n    simp\n  have H : \u2200 x y : L, \u2203 \u03b1 : L, x \u2208 K\u27ee\u03b1\u27ef \u2227 y \u2208 K\u27ee\u03b1\u27ef := by\n    intro x y\n    have : FiniteDimensional K K\u27eex, y\u27ef := by\n      apply IntermediateField.finiteDimensional_adjoin\n      intro x _; exact (Algebra.IsSeparable.isSeparable K x).isIntegral\n    have := IsSeparable.of_algHom _ _ (IsScalarTower.toAlgHom K (K\u27eex, y\u27ef) L)\n    obtain \u27e8\u27e8\u03b1, h\u03b1\u27e9, e\u27e9 := Field.exists_primitive_element K K\u27eex,y\u27ef\n    apply_fun (IntermediateField.map (IntermediateField.val _)) at e\n    rw [IntermediateField.adjoin_map, \u2190 AlgHom.fieldRange_eq_map] at e\n    simp only [IntermediateField.coe_val, Set.image_singleton,\n      IntermediateField.fieldRange_val] at e\n    have hx : x \u2208 K\u27ee\u03b1\u27ef := e \u25b8 IntermediateField.subset_adjoin K {x, y} (by simp)\n    have hy : y \u2208 K\u27ee\u03b1\u27ef := e \u25b8 IntermediateField.subset_adjoin K {x, y} (by simp)\n    exact \u27e8\u03b1, hx, hy\u27e9\n  refine \u27e8\u27e8\u27e8\u27e8\u27e8fun x \u21a6 g x (IntermediateField.AdjoinSimple.gen K x), ?_\u27e9, ?_\u27e9, ?_, ?_\u27e9, ?_\u27e9, ?_\u27e9\n  \u00b7 show g 1 1 = 1; rw [map_one]\n  \u00b7 intros x y\n    obtain \u27e8\u03b1, hx, hy\u27e9 := H x y\n    simp only [\u2190 hg\u2083 _ _ hx, \u2190 hg\u2083 _ _ hy, \u2190 map_mul, \u2190 hg\u2083 _ _ (mul_mem hx hy)]\n    rfl\n  \u00b7 show g 0 0 = 0; rw [map_zero]\n  \u00b7 intros x y\n    obtain \u27e8\u03b1, hx, hy\u27e9 := H x y\n    simp only [\u2190 hg\u2083 _ _ hx, \u2190 hg\u2083 _ _ hy, \u2190 map_add, \u2190 hg\u2083 _ _ (add_mem hx hy)]\n    rfl\n  \u00b7 intro r\n    show g _ (algebraMap K _ r) = _\n    rw [AlgHom.commutes]\n  \u00b7 ext x\n    simpa using AlgHom.congr_fun (hg\u2081 x) (IntermediateField.AdjoinSimple.gen K x)\n\ntheorem iff_isSeparable [EssFiniteType K L] :\n    FormallyEtale K L \u2194 Algebra.IsSeparable K L :=\n  \u27e8fun _ \u21a6 FormallyUnramified.isSeparable K L, fun _ \u21a6 of_isSeparable K L\u27e9\n\nattribute [local instance] IsArtinianRing.fieldOfSubtypeIsMaximal in\n/--\nIf `A` is an essentially of finite type algebra over a field `K`, then `A` is formally \u00e9tale\nover `K` if and only if `A` is a finite product of separable field extensions.\n-/\ntheorem iff_exists_algEquiv_prod [EssFiniteType K A] :\n    FormallyEtale K A \u2194\n      \u2203 (I : Type u) (_ : Finite I) (Ai : I \u2192 Type u) (_ : \u2200 i, Field (Ai i))\n        (_ : \u2200 i, Algebra K (Ai i)) (_ : A \u2243\u2090[K] \u03a0 i, Ai i),\n        \u2200 i, Algebra.IsSeparable K (Ai i) := by\n  classical\n  constructor\n  \u00b7 intro H\n    have := FormallyUnramified.finite_of_free K A\n    have := FormallyUnramified.isReduced_of_field K A\n    have : IsArtinianRing A := isArtinian_of_tower K inferInstance\n    letI : Fintype (MaximalSpectrum A) := (nonempty_fintype _).some\n    let v (i : MaximalSpectrum A) : A := (IsArtinianRing.equivPi A).symm (Pi.single i 1)\n    let e : A \u2243\u2090[K] _ := { __ := IsArtinianRing.equivPi A, commutes' := fun r \u21a6 rfl }\n    have := (FormallyEtale.iff_of_equiv e).mp inferInstance\n    rw [FormallyEtale.pi_iff] at this\n    exact \u27e8_, inferInstance, _, _, _, e, fun I \u21a6 (iff_isSeparable _ _).mp inferInstance\u27e9\n  \u00b7 intro \u27e8I, _, Ai, _, _, e, _\u27e9\n    rw [FormallyEtale.iff_of_equiv e, FormallyEtale.pi_iff]\n    have (i) : EssFiniteType K (Ai i) := by\n      letI := ((Pi.evalRingHom Ai i).comp e.toRingHom).toAlgebra\n      have : IsScalarTower K A (Ai i) :=\n        .of_algebraMap_eq fun r \u21a6 by simp [RingHom.algebraMap_toAlgebra]\n      have : Algebra.FiniteType A (Ai i) := .of_surjective inferInstance (Algebra.ofId _ _)\n        (RingHomSurjective.is_surjective (\u03c3 := Pi.evalRingHom Ai i).comp e.surjective)\n      exact EssFiniteType.comp K A (Ai i)\n    exact fun I \u21a6 (iff_isSeparable _ _).mpr inferInstance\n\nend Algebra.FormallyEtale\n\n", "theoremStatement": "/--\n`A` is \u00e9tale over a field `K` if and only if\n`A` is a finite product of finite separable field extensions.\n-/\ntheorem Algebra.Etale.iff_exists_algEquiv_prod :\n    Etale K A \u2194\n      \u2203 (I : Type u) (_ : Finite I) (Ai : I \u2192 Type u) (_ : \u2200 i, Field (Ai i))\n        (_ : \u2200 i, Algebra K (Ai i)) (_ : A \u2243\u2090[K] \u03a0 i, Ai i),\n        \u2200 i, Module.Finite K (Ai i) \u2227 Algebra.IsSeparable K (Ai i) ", "theoremName": "Algebra.Etale.iff_exists_algEquiv_prod", "fileCreated": {"commit": "e2338ffc272658ed73b8c5a708aafc386b30e1b7", "date": "2024-10-26"}, "theoremCreated": {"commit": "d5cc7c85a7795dcbd6fca653498bd3e643edba0a", "date": "2025-01-06"}, "file": "mathlib/Mathlib/RingTheory/Etale/Field.lean", "module": "Mathlib.RingTheory.Etale.Field", "jsonFile": "Mathlib.RingTheory.Etale.Field.jsonl", "positionMetadata": {"lineInFile": 191, "tokenPositionInFile": 8479, "theoremPositionInFile": 4}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 73, "numPremises": 87}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  constructor\n  \u00b7 intro H\n    obtain \u27e8I, _, Ai, _, _, e, _\u27e9 := (FormallyEtale.iff_exists_algEquiv_prod K A).mp inferInstance\n    have := FormallyUnramified.finite_of_free K A\n    exact \u27e8_, \u2039_\u203a, _, _, _, e, fun i \u21a6 \u27e8.of_surjective ((LinearMap.proj i).comp e.toLinearMap)\n      ((Function.surjective_eval i).comp e.surjective), inferInstance\u27e9\u27e9\n  \u00b7 intro \u27e8I, _, Ai, _, _, e, H\u27e9\n    choose h\u2081 h\u2082 using H\n    have := Module.Finite.of_surjective e.symm.toLinearMap e.symm.surjective\n    refine \u27e8?_, FinitePresentation.of_finiteType.mp inferInstance\u27e9\n    exact (FormallyEtale.iff_exists_algEquiv_prod K A).mpr \u27e8_, inferInstance, _, _, _, e, h\u2082\u27e9", "proofType": "tactic", "proofLengthLines": 11, "proofLengthTokens": 643}}
{"srcContext": "/-\nCopyright (c) 2024 Xavier Roblot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Xavier Roblot\n-/\nimport Mathlib.Analysis.BoxIntegral.UnitPartition\nimport Mathlib.MeasureTheory.Measure.Haar.InnerProductSpace\n\n/-!\n# Covolume of \u2124-lattices\n\nLet `E` be a finite dimensional real vector space.\n\nLet `L` be a `\u2124`-lattice `L` defined as a discrete `\u2124`-submodule of `E` that spans `E` over `\u211d`.\n\n## Main definitions and results\n\n* `ZLattice.covolume`: the covolume of `L` defined as the volume of an arbitrary fundamental\ndomain of `L`.\n\n* `ZLattice.covolume_eq_measure_fundamentalDomain`: the covolume of `L` does not depend on the\nchoice of the fundamental domain of `L`.\n\n* `ZLattice.covolume_eq_det`: if `L` is a lattice in `\u211d^n`, then its covolume is the absolute\nvalue of the determinant of any `\u2124`-basis of `L`.\n\n* `ZLattice.covolume.tendsto_card_div_pow`: Let `s` be a bounded measurable set of `\u03b9 \u2192 \u211d`, then\nthe number of points in `s \u2229 n\u207b\u00b9 \u2022 L` divided by `n ^ card \u03b9` tends to `volume s / covolume L`\nwhen `n : \u2115` tends to infinity. See also `ZLattice.covolume.tendsto_card_div_pow'` for a version\nfor `InnerProductSpace \u211d E` and `ZLattice.covolume.tendsto_card_div_pow''` for the general version.\n\n* `ZLattice.covolume.tendsto_card_le_div`: Let `X` be a cone in `\u03b9 \u2192 \u211d` and let `F : (\u03b9 \u2192 \u211d) \u2192 \u211d`\nbe a function such that `F (c \u2022 x) = c ^ card \u03b9 * F x`. Then the number of points `x \u2208 X` such that\n`F x \u2264 c` divided by `c` tends to `volume {x \u2208 X | F x \u2264 1} / covolume L` when `c : \u211d` tends to\ninfinity. See also `ZLattice.covolume.tendsto_card_le_div'` for a version for\n`InnerProductSpace \u211d E` and `ZLattice.covolume.tendsto_card_le_div''` for the general version.\n\n## Naming convention\n\nSome results are true in the case where the ambient finite dimensional real vector space is the\npi-space `\u03b9 \u2192 \u211d` and in the case where it is an `InnerProductSpace`. We use the following\nconvention: the plain name is for the pi case, for eg. `volume_image_eq_volume_div_covolume`. For\nthe same result in the `InnerProductSpace` case, we add a `prime`, for eg.\n`volume_image_eq_volume_div_covolume'`. When the same result exists in the\ngeneral case, we had two primes, eg. `covolume.tendsto_card_div_pow''`.\n\n-/\n\nnoncomputable section\n\nnamespace ZLattice\n\nopen Submodule MeasureTheory Module MeasureTheory Module ZSpan\n\nsection General\n\nvariable {E : Type*} [NormedAddCommGroup E] [MeasurableSpace E] (L : Submodule \u2124 E)\n\n/-- The covolume of a `\u2124`-lattice is the volume of some fundamental domain; see\n`ZLattice.covolume_eq_volume` for the proof that the volume does not depend on the choice of\nthe fundamental domain. -/\ndef covolume (\u03bc : Measure E := by volume_tac) : \u211d := (addCovolume L E \u03bc).toReal\n\nend General\n\nsection Basic\n\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] [FiniteDimensional \u211d E]\nvariable [MeasurableSpace E] [BorelSpace E]\nvariable (L : Submodule \u2124 E) [DiscreteTopology L] [IsZLattice \u211d L]\nvariable (\u03bc : Measure E := by volume_tac) [Measure.IsAddHaarMeasure \u03bc]\n\ntheorem covolume_eq_measure_fundamentalDomain {F : Set E} (h : IsAddFundamentalDomain L F \u03bc) :\n    covolume L \u03bc = (\u03bc F).toReal := by\n  have : MeasurableVAdd L E := (inferInstance : MeasurableVAdd L.toAddSubgroup E)\n  have : VAddInvariantMeasure L E \u03bc := (inferInstance : VAddInvariantMeasure L.toAddSubgroup E \u03bc)\n  exact congr_arg ENNReal.toReal (h.covolume_eq_volume \u03bc)\n\ntheorem covolume_ne_zero : covolume L \u03bc \u2260 0 := by\n  rw [covolume_eq_measure_fundamentalDomain L \u03bc (isAddFundamentalDomain (Free.chooseBasis \u2124 L) \u03bc),\n    ENNReal.toReal_ne_zero]\n  refine \u27e8measure_fundamentalDomain_ne_zero _, ne_of_lt ?_\u27e9\n  exact Bornology.IsBounded.measure_lt_top (fundamentalDomain_isBounded _)\n\ntheorem covolume_pos : 0 < covolume L \u03bc :=\n  lt_of_le_of_ne ENNReal.toReal_nonneg (covolume_ne_zero L \u03bc).symm\n\ntheorem covolume_comap {F : Type*} [NormedAddCommGroup F] [NormedSpace \u211d F] [FiniteDimensional \u211d F]\n    [MeasurableSpace F] [BorelSpace F] (\u03bd : Measure F := by volume_tac) [Measure.IsAddHaarMeasure \u03bd]\n    {e : F \u2243L[\u211d] E} (he : MeasurePreserving e \u03bd \u03bc) :\n    covolume (ZLattice.comap \u211d L e.toLinearMap) \u03bd = covolume L \u03bc := by\n  rw [covolume_eq_measure_fundamentalDomain _ _ (isAddFundamentalDomain (Free.chooseBasis \u2124 L) \u03bc),\n    covolume_eq_measure_fundamentalDomain _ _ ((isAddFundamentalDomain\n    ((Free.chooseBasis \u2124 L).ofZLatticeComap \u211d L e.toLinearEquiv) \u03bd)), \u2190 he.measure_preimage\n    (fundamentalDomain_measurableSet _).nullMeasurableSet, \u2190 e.image_symm_eq_preimage,\n    \u2190 e.symm.coe_toLinearEquiv, map_fundamentalDomain]\n  congr!\n  ext; simp\n\ntheorem covolume_eq_det_mul_measure {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (b : Basis \u03b9 \u2124 L)\n    (b\u2080 : Basis \u03b9 \u211d E) :\n    covolume L \u03bc = |b\u2080.det ((\u2191) \u2218 b)| * (\u03bc (fundamentalDomain b\u2080)).toReal := by\n  rw [covolume_eq_measure_fundamentalDomain L \u03bc (isAddFundamentalDomain b \u03bc),\n    measure_fundamentalDomain _ _ b\u2080,\n    measure_congr (fundamentalDomain_ae_parallelepiped b\u2080 \u03bc), ENNReal.toReal_mul,\n    ENNReal.toReal_ofReal (by positivity)]\n  congr\n  ext\n  exact b.ofZLatticeBasis_apply \u211d L _\n\ntheorem covolume_eq_det {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (L : Submodule \u2124 (\u03b9 \u2192 \u211d))\n    [DiscreteTopology L] [IsZLattice \u211d L] (b : Basis \u03b9 \u2124 L) :\n    covolume L = |(Matrix.of ((\u2191) \u2218 b)).det| := by\n  rw [covolume_eq_measure_fundamentalDomain L volume (isAddFundamentalDomain b volume),\n    volume_fundamentalDomain, ENNReal.toReal_ofReal (by positivity)]\n  congr\n  ext1\n  exact b.ofZLatticeBasis_apply \u211d L _\n\ntheorem covolume_eq_det_inv {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (L : Submodule \u2124 (\u03b9 \u2192 \u211d))\n    [DiscreteTopology L] [IsZLattice \u211d L] (b : Basis \u03b9 \u2124 L) :\n    covolume L = |(LinearEquiv.det (b.ofZLatticeBasis \u211d L).equivFun : \u211d)|\u207b\u00b9 := by\n  rw [covolume_eq_det L b, \u2190 Pi.basisFun_det_apply, show (((\u2191) : L \u2192 _) \u2218 \u21d1b) =\n    (b.ofZLatticeBasis \u211d) by ext; simp, \u2190 Basis.det_inv, \u2190 abs_inv, Units.val_inv_eq_inv_val,\n    IsUnit.unit_spec, \u2190 Basis.det_basis, LinearEquiv.coe_det]\n  rfl\n\ntheorem volume_image_eq_volume_div_covolume {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9]\n    (L : Submodule \u2124 (\u03b9 \u2192 \u211d)) [DiscreteTopology L] [IsZLattice \u211d L] (b : Basis \u03b9 \u2124 L)\n    {s : Set (\u03b9 \u2192 \u211d)} :\n    volume ((b.ofZLatticeBasis \u211d L).equivFun '' s) = volume s / ENNReal.ofReal (covolume L) := by\n  rw [LinearEquiv.image_eq_preimage, Measure.addHaar_preimage_linearEquiv, LinearEquiv.symm_symm,\n    covolume_eq_det_inv L b, ENNReal.div_eq_inv_mul, ENNReal.ofReal_inv_of_pos\n    (abs_pos.mpr (LinearEquiv.det _).ne_zero), inv_inv, LinearEquiv.coe_det]\n\n/-- A more general version of `ZLattice.volume_image_eq_volume_div_covolume`;\nsee the `Naming conventions` section in the introduction. -/\ntheorem volume_image_eq_volume_div_covolume' {E : Type*} [NormedAddCommGroup E]\n    [InnerProductSpace \u211d E] [FiniteDimensional \u211d E] [MeasurableSpace E] [BorelSpace E]\n    (L : Submodule \u2124 E) [DiscreteTopology L] [IsZLattice \u211d L] {\u03b9 : Type*} [Fintype \u03b9]\n    (b : Basis \u03b9 \u2124 L) {s : Set E} (hs : NullMeasurableSet s) :\n    volume ((b.ofZLatticeBasis \u211d).equivFun '' s) = volume s / ENNReal.ofReal (covolume L) := by\n  classical\n  let e : Fin (finrank \u211d E) \u2243 \u03b9 :=\n    Fintype.equivOfCardEq (by rw [Fintype.card_fin, finrank_eq_card_basis (b.ofZLatticeBasis \u211d)])\n  let f := (EuclideanSpace.equiv \u03b9 \u211d).symm.trans\n    ((stdOrthonormalBasis \u211d E).reindex e).repr.toContinuousLinearEquiv.symm\n  have hf : MeasurePreserving f :=\n    ((stdOrthonormalBasis \u211d E).reindex e).measurePreserving_repr_symm.comp\n      (EuclideanSpace.volume_preserving_measurableEquiv \u03b9).symm\n  rw [\u2190 hf.measure_preimage hs, \u2190 (covolume_comap L volume volume hf),\n    \u2190 volume_image_eq_volume_div_covolume (ZLattice.comap \u211d L f.toLinearMap)\n    (b.ofZLatticeComap \u211d L f.toLinearEquiv), Basis.ofZLatticeBasis_comap,\n    \u2190 f.image_symm_eq_preimage, \u2190 Set.image_comp]\n  simp only [Basis.equivFun_apply, ContinuousLinearEquiv.symm_toLinearEquiv, Basis.map_equivFun,\n    LinearEquiv.symm_symm, Function.comp_apply, LinearEquiv.trans_apply,\n    ContinuousLinearEquiv.coe_toLinearEquiv, ContinuousLinearEquiv.apply_symm_apply]\n\nend Basic\n\nnamespace covolume\n\nsection General\n\nopen Filter Fintype Pointwise Topology BoxIntegral Bornology\n\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]\nvariable {L : Submodule \u2124 E} [DiscreteTopology L] [IsZLattice \u211d L]\nvariable {\u03b9 : Type*} [Fintype \u03b9] (b : Basis \u03b9 \u2124 L)\n\n/-- A version of `ZLattice.covolume.tendsto_card_div_pow` for the general case;\nsee the `Naming convention` section in the introduction. -/\ntheorem tendsto_card_div_pow'' [FiniteDimensional \u211d E] [MeasurableSpace E] [BorelSpace E]\n    {s : Set E} (hs\u2081 : IsBounded s) (hs\u2082 : MeasurableSet s)\n    (hs\u2083 : volume (frontier ((b.ofZLatticeBasis \u211d).equivFun '' s)) = 0):\n    Tendsto (fun n : \u2115 \u21a6 (Nat.card (s \u2229 (n : \u211d)\u207b\u00b9 \u2022 L : Set E) : \u211d) / n ^ card \u03b9)\n      atTop (\ud835\udcdd (volume ((b.ofZLatticeBasis \u211d).equivFun '' s)).toReal) := by\n  refine Tendsto.congr' ?_\n    (tendsto_card_div_pow_atTop_volume ((b.ofZLatticeBasis \u211d).equivFun '' s) ?_ ?_ hs\u2083)\n  \u00b7 filter_upwards [eventually_gt_atTop 0] with n hn\n    congr\n    refine Nat.card_congr <| ((b.ofZLatticeBasis \u211d).equivFun.toEquiv.subtypeEquiv fun x \u21a6 ?_).symm\n    simp_rw [Set.mem_inter_iff, \u2190 b.ofZLatticeBasis_span \u211d, LinearEquiv.coe_toEquiv,\n      Basis.equivFun_apply, Set.mem_image, DFunLike.coe_fn_eq, EmbeddingLike.apply_eq_iff_eq,\n      exists_eq_right, and_congr_right_iff, Set.mem_inv_smul_set_iff\u2080\n      (mod_cast hn.ne' : (n : \u211d) \u2260 0), \u2190 Finsupp.coe_smul, \u2190 LinearEquiv.map_smul, SetLike.mem_coe,\n      Basis.mem_span_iff_repr_mem, Pi.basisFun_repr, implies_true]\n  \u00b7 rw [\u2190 NormedSpace.isVonNBounded_iff \u211d] at hs\u2081 \u22a2\n    exact Bornology.IsVonNBounded.image hs\u2081 ((b.ofZLatticeBasis \u211d).equivFunL : E \u2192L[\u211d] \u03b9 \u2192 \u211d)\n  \u00b7 exact (b.ofZLatticeBasis \u211d).equivFunL.toHomeomorph.toMeasurableEquiv.measurableSet_image.mpr hs\u2082\n\nprivate theorem tendsto_card_le_div''_aux {X : Set E} (hX : \u2200 \u2983x\u2984 \u2983r:\u211d\u2984, x \u2208 X \u2192 0 < r \u2192 r \u2022 x \u2208 X)\n    {F : E \u2192 \u211d} (hF\u2081 : \u2200 x \u2983r : \u211d\u2984, 0 \u2264 r \u2192 F (r \u2022 x) = r ^ card \u03b9 * (F x)) {c : \u211d} (hc : 0 < c) :\n    c \u2022 {x \u2208 X | F x \u2264 1} = {x \u2208 X | F x \u2264 c ^ card \u03b9} := by\n  ext x\n  simp_rw [Set.mem_smul_set_iff_inv_smul_mem\u2080 hc.ne', Set.mem_setOf_eq, hF\u2081 _\n    (inv_pos_of_pos hc).le, inv_pow, inv_mul_le_iff\u2080 (pow_pos hc _), mul_one, and_congr_left_iff]\n  exact fun _ \u21a6 \u27e8fun h \u21a6 (smul_inv_smul\u2080 hc.ne' x) \u25b8 hX h hc, fun h \u21a6 hX h (inv_pos_of_pos hc)\u27e9\n\n", "theoremStatement": "/-- A version of `ZLattice.covolume.tendsto_card_le_div` for the general case;\nsee the `Naming conventions` section in the introduction. -/\ntheorem tendsto_card_le_div'' [FiniteDimensional \u211d E] [MeasurableSpace E] [BorelSpace E]\n    [Nonempty \u03b9] {X : Set E} (hX : \u2200 \u2983x\u2984 \u2983r : \u211d\u2984, x \u2208 X \u2192 0 < r \u2192 r \u2022 x \u2208 X)\n    {F : E \u2192 \u211d} (h\u2081 : \u2200 x \u2983r : \u211d\u2984, 0 \u2264 r \u2192  F (r \u2022 x) = r ^ card \u03b9 * (F x))\n    (h\u2082 : IsBounded {x \u2208 X | F x \u2264 1}) (h\u2083 : MeasurableSet {x \u2208 X | F x \u2264 1})\n    (h\u2084 : volume (frontier ((b.ofZLatticeBasis \u211d L).equivFun '' {x | x \u2208 X \u2227 F x \u2264 1})) = 0) :\n    Tendsto (fun c : \u211d \u21a6\n      Nat.card ({x \u2208 X | F x \u2264 c} \u2229 L : Set E) / (c : \u211d))\n        atTop (\ud835\udcdd (volume ((b.ofZLatticeBasis \u211d).equivFun '' {x \u2208 X | F x \u2264 1})).toReal) ", "theoremName": "ZLattice.covolume.tendsto_card_le_div''", "fileCreated": {"commit": "85d6c78ac5782869d041c2ca6d3ca83cdde412c3", "date": "2024-09-09"}, "theoremCreated": {"commit": "211dc533566a173988a01067bb50d7917a097103", "date": "2024-12-18"}, "file": "mathlib/Mathlib/Algebra/Module/ZLattice/Covolume.lean", "module": "Mathlib.Algebra.Module.ZLattice.Covolume", "jsonFile": "Mathlib.Algebra.Module.ZLattice.Covolume.jsonl", "positionMetadata": {"lineInFile": 200, "tokenPositionInFile": 10344, "theoremPositionInFile": 12}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 317, "numPremises": 374}, "proofMetadata": {"hasProof": true, "proof": ":= by\n\n  refine Tendsto.congr' ?_ <| (tendsto_card_div_pow_atTop_volume'\n      ((b.ofZLatticeBasis \u211d).equivFun '' {x \u2208 X | F x \u2264 1}) ?_ ?_ h\u2084 fun x y hx hy \u21a6 ?_).comp\n        (tendsto_rpow_atTop <| inv_pos.mpr\n          (Nat.cast_pos.mpr card_pos) : Tendsto (fun x \u21a6 x ^ (card \u03b9 : \u211d)\u207b\u00b9) atTop atTop)\n  \u00b7 filter_upwards [eventually_gt_atTop 0] with c hc\n    have aux\u2081 : (card \u03b9 : \u211d) \u2260 0 := Nat.cast_ne_zero.mpr card_ne_zero\n    have aux\u2082 : 0 < c ^ (card \u03b9 : \u211d)\u207b\u00b9 := Real.rpow_pos_of_pos hc _\n    have aux\u2083 : (c ^ (card \u03b9 : \u211d)\u207b\u00b9)\u207b\u00b9 \u2260 0 := inv_ne_zero aux\u2082.ne'\n    have aux\u2084 : c ^ (-(card \u03b9 : \u211d)\u207b\u00b9) \u2260 0 := (Real.rpow_pos_of_pos hc _).ne'\n    obtain \u27e8hc\u2081, hc\u2082\u27e9 := lt_iff_le_and_ne.mp hc\n    rw [Function.comp_apply, \u2190 Real.rpow_natCast, Real.rpow_inv_rpow hc\u2081 aux\u2081, eq_comm]\n    congr\n    refine Nat.card_congr <| Equiv.subtypeEquiv ((b.ofZLatticeBasis \u211d).equivFun.toEquiv.trans\n          (Equiv.smulRight aux\u2084)) fun _ \u21a6 ?_\n    rw [Set.mem_inter_iff, Set.mem_inter_iff, Equiv.trans_apply, LinearEquiv.coe_toEquiv,\n      Equiv.smulRight_apply, Real.rpow_neg hc\u2081, Set.smul_mem_smul_set_iff\u2080 aux\u2083,\n      \u2190 Set.mem_smul_set_iff_inv_smul_mem\u2080 aux\u2082.ne', \u2190 image_smul_set,\n      tendsto_card_le_div''_aux hX h\u2081 aux\u2082, \u2190 Real.rpow_natCast, \u2190 Real.rpow_mul hc\u2081,\n      inv_mul_cancel\u2080 aux\u2081, Real.rpow_one]\n    simp_rw [SetLike.mem_coe, Set.mem_image, EmbeddingLike.apply_eq_iff_eq, exists_eq_right,\n      and_congr_right_iff, \u2190 b.ofZLatticeBasis_span \u211d, Basis.mem_span_iff_repr_mem,\n      Pi.basisFun_repr, Basis.equivFun_apply, implies_true]\n  \u00b7 rw [\u2190 NormedSpace.isVonNBounded_iff \u211d] at h\u2082 \u22a2\n    exact Bornology.IsVonNBounded.image h\u2082 ((b.ofZLatticeBasis \u211d).equivFunL : E \u2192L[\u211d] \u03b9 \u2192 \u211d)\n  \u00b7 exact (b.ofZLatticeBasis \u211d).equivFunL.toHomeomorph.toMeasurableEquiv.measurableSet_image.mpr h\u2083\n  \u00b7 simp_rw [\u2190 image_smul_set]\n    apply Set.image_mono\n    rw [tendsto_card_le_div''_aux hX h\u2081 hx,\n      tendsto_card_le_div''_aux hX h\u2081 (lt_of_lt_of_le hx hy)]\n    exact fun a \u27e8ha\u2081, ha\u2082\u27e9 \u21a6 \u27e8ha\u2081, le_trans ha\u2082 <| pow_le_pow_left\u2080 (le_of_lt hx) hy _\u27e9", "proofType": "tactic", "proofLengthLines": 31, "proofLengthTokens": 2021}}
{"srcContext": "/-\nCopyright (c) 2020 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kevin Buzzard, Johan Commelin, Patrick Massot\n-/\nimport Mathlib.Algebra.Order.Hom.Monoid\nimport Mathlib.Algebra.Order.Ring.Basic\nimport Mathlib.RingTheory.Ideal.Maps\nimport Mathlib.Tactic.TFAE\n\n/-!\n\n# The basics of valuation theory.\n\nThe basic theory of valuations (non-archimedean norms) on a commutative ring,\nfollowing T. Wedhorn's unpublished notes \u201cAdic Spaces\u201d ([wedhorn_adic]).\n\nThe definition of a valuation we use here is Definition 1.22 of [wedhorn_adic].\nA valuation on a ring `R` is a monoid homomorphism `v` to a linearly ordered\ncommutative monoid with zero, that in addition satisfies the following two axioms:\n * `v 0 = 0`\n * `\u2200 x y, v (x + y) \u2264 max (v x) (v y)`\n\n`Valuation R \u0393\u2080`is the type of valuations `R \u2192 \u0393\u2080`, with a coercion to the underlying\nfunction. If `v` is a valuation from `R` to `\u0393\u2080` then the induced group\nhomomorphism `Units(R) \u2192 \u0393\u2080` is called `unit_map v`.\n\nThe equivalence \"relation\" `IsEquiv v\u2081 v\u2082 : Prop` defined in 1.27 of [wedhorn_adic] is not strictly\nspeaking a relation, because `v\u2081 : Valuation R \u0393\u2081` and `v\u2082 : Valuation R \u0393\u2082` might\nnot have the same type. This corresponds in ZFC to the set-theoretic difficulty\nthat the class of all valuations (as `\u0393\u2080` varies) on a ring `R` is not a set.\nThe \"relation\" is however reflexive, symmetric and transitive in the obvious\nsense. Note that we use 1.27(iii) of [wedhorn_adic] as the definition of equivalence.\n\n## Main definitions\n\n* `Valuation R \u0393\u2080`, the type of valuations on `R` with values in `\u0393\u2080`\n* `Valuation.IsEquiv`, the heterogeneous equivalence relation on valuations\n* `Valuation.supp`, the support of a valuation\n\n* `AddValuation R \u0393\u2080`, the type of additive valuations on `R` with values in a\n  linearly ordered additive commutative group with a top element, `\u0393\u2080`.\n\n## Implementation Details\n\n`AddValuation R \u0393\u2080` is implemented as `Valuation R (Multiplicative \u0393\u2080)\u1d52\u1d48`.\n\n## Notation\n\nIn the `DiscreteValuation` locale:\n\n * `\u2115\u2098\u2080` is a shorthand for `WithZero (Multiplicative \u2115)`\n * `\u2124\u2098\u2080` is a shorthand for `WithZero (Multiplicative \u2124)`\n\n## TODO\n\nIf ever someone extends `Valuation`, we should fully comply to the `DFunLike` by migrating the\nboilerplate lemmas to `ValuationClass`.\n-/\n\nopen Function Ideal\n\nnoncomputable section\n\nvariable {K F R : Type*} [DivisionRing K]\n\nsection\n\nvariable (F R) (\u0393\u2080 : Type*) [LinearOrderedCommMonoidWithZero \u0393\u2080] [Ring R]\n\n/-- The type of `\u0393\u2080`-valued valuations on `R`.\n\nWhen you extend this structure, make sure to extend `ValuationClass`. -/\nstructure Valuation extends R \u2192*\u2080 \u0393\u2080 where\n  /-- The valuation of a a sum is less that the sum of the valuations -/\n  map_add_le_max' : \u2200 x y, toFun (x + y) \u2264 max (toFun x) (toFun y)\n\n/-- `ValuationClass F \u03b1 \u03b2` states that `F` is a type of valuations.\n\nYou should also extend this typeclass when you extend `Valuation`. -/\nclass ValuationClass (F) (R \u0393\u2080 : outParam Type*) [LinearOrderedCommMonoidWithZero \u0393\u2080] [Ring R]\n  [FunLike F R \u0393\u2080]\n  extends MonoidWithZeroHomClass F R \u0393\u2080 : Prop where\n  /-- The valuation of a a sum is less that the sum of the valuations -/\n  map_add_le_max (f : F) (x y : R) : f (x + y) \u2264 max (f x) (f y)\n\nexport ValuationClass (map_add_le_max)\n\ninstance [FunLike F R \u0393\u2080] [ValuationClass F R \u0393\u2080] : CoeTC F (Valuation R \u0393\u2080) :=\n  \u27e8fun f =>\n    { toFun := f\n      map_one' := map_one f\n      map_zero' := map_zero f\n      map_mul' := map_mul f\n      map_add_le_max' := map_add_le_max f }\u27e9\n\nend\n\nnamespace Valuation\n\nvariable {\u0393\u2080 : Type*}\nvariable {\u0393'\u2080 : Type*}\nvariable {\u0393''\u2080 : Type*} [LinearOrderedCommMonoidWithZero \u0393''\u2080]\n\nsection Basic\n\nvariable [Ring R]\n\nsection Monoid\n\nvariable [LinearOrderedCommMonoidWithZero \u0393\u2080] [LinearOrderedCommMonoidWithZero \u0393'\u2080]\n\ninstance : FunLike (Valuation R \u0393\u2080) R \u0393\u2080 where\n  coe f := f.toFun\n  coe_injective' f g h := by\n    obtain \u27e8\u27e8\u27e8_,_\u27e9, _\u27e9, _\u27e9 := f\n    congr\n\ninstance : ValuationClass (Valuation R \u0393\u2080) R \u0393\u2080 where\n  map_mul f := f.map_mul'\n  map_one f := f.map_one'\n  map_zero f := f.map_zero'\n  map_add_le_max f := f.map_add_le_max'\n\n@[simp]\ntheorem coe_mk (f : R \u2192*\u2080 \u0393\u2080) (h) : \u21d1(Valuation.mk f h) = f := rfl\n\ntheorem toFun_eq_coe (v : Valuation R \u0393\u2080) : v.toFun = v := rfl\n\n@[simp]\ntheorem toMonoidWithZeroHom_coe_eq_coe (v : Valuation R \u0393\u2080) :\n    (v.toMonoidWithZeroHom : R \u2192 \u0393\u2080) = v := rfl\n\n@[ext]\ntheorem ext {v\u2081 v\u2082 : Valuation R \u0393\u2080} (h : \u2200 r, v\u2081 r = v\u2082 r) : v\u2081 = v\u2082 :=\n  DFunLike.ext _ _ h\n\nvariable (v : Valuation R \u0393\u2080)\n\n@[simp, norm_cast]\ntheorem coe_coe : \u21d1(v : R \u2192*\u2080 \u0393\u2080) = v := rfl\n\ntheorem map_zero : v 0 = 0 :=\n  v.map_zero'\n\ntheorem map_one : v 1 = 1 :=\n  v.map_one'\n\ntheorem map_mul : \u2200 x y, v (x * y) = v x * v y :=\n  v.map_mul'\n\n-- Porting note: LHS side simplified so created map_add'\ntheorem map_add : \u2200 x y, v (x + y) \u2264 max (v x) (v y) :=\n  v.map_add_le_max'\n\n@[simp]\ntheorem map_add' : \u2200 x y, v (x + y) \u2264 v x \u2228 v (x + y) \u2264 v y := by\n  intro x y\n  rw [\u2190 le_max_iff, \u2190 ge_iff_le]\n  apply map_add\n\ntheorem map_add_le {x y g} (hx : v x \u2264 g) (hy : v y \u2264 g) : v (x + y) \u2264 g :=\n  le_trans (v.map_add x y) <| max_le hx hy\n\ntheorem map_add_lt {x y g} (hx : v x < g) (hy : v y < g) : v (x + y) < g :=\n  lt_of_le_of_lt (v.map_add x y) <| max_lt hx hy\n\ntheorem map_sum_le {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hf : \u2200 i \u2208 s, v (f i) \u2264 g) :\n    v (\u2211 i \u2208 s, f i) \u2264 g := by\n  classical\n  refine\n    Finset.induction_on s (fun _ => v.map_zero \u25b8 zero_le')\n      (fun a s has ih hf => ?_) hf\n  rw [Finset.forall_mem_insert] at hf; rw [Finset.sum_insert has]\n  exact v.map_add_le hf.1 (ih hf.2)\n\ntheorem map_sum_lt {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hg : g \u2260 0)\n    (hf : \u2200 i \u2208 s, v (f i) < g) : v (\u2211 i \u2208 s, f i) < g := by\n  classical\n  refine\n    Finset.induction_on s (fun _ => v.map_zero \u25b8 (zero_lt_iff.2 hg))\n      (fun a s has ih hf => ?_) hf\n  rw [Finset.forall_mem_insert] at hf; rw [Finset.sum_insert has]\n  exact v.map_add_lt hf.1 (ih hf.2)\n\ntheorem map_sum_lt' {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hg : 0 < g)\n    (hf : \u2200 i \u2208 s, v (f i) < g) : v (\u2211 i \u2208 s, f i) < g :=\n  v.map_sum_lt (ne_of_gt hg) hf\n\ntheorem map_pow : \u2200 (x) (n : \u2115), v (x ^ n) = v x ^ n :=\n  v.toMonoidWithZeroHom.toMonoidHom.map_pow\n\n-- The following definition is not an instance, because we have more than one `v` on a given `R`.\n-- In addition, type class inference would not be able to infer `v`.\n/-- A valuation gives a preorder on the underlying ring. -/\ndef toPreorder : Preorder R :=\n  Preorder.lift v\n\n/-- If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. -/\ntheorem zero_iff [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) {x : K} : v x = 0 \u2194 x = 0 :=\n  map_eq_zero v\n\ntheorem ne_zero_iff [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) {x : K} : v x \u2260 0 \u2194 x \u2260 0 :=\n  map_ne_zero v\n\nlemma pos_iff [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) {x : K} : 0 < v x \u2194 x \u2260 0 := by\n  rw [zero_lt_iff, ne_zero_iff]\n\ntheorem unit_map_eq (u : R\u02e3) : (Units.map (v : R \u2192* \u0393\u2080) u : \u0393\u2080) = v u :=\n  rfl\n\ntheorem ne_zero_of_unit [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) (x : K\u02e3) : v x \u2260 (0 : \u0393\u2080) := by\n  simp only [ne_eq, Valuation.zero_iff, Units.ne_zero x, not_false_iff]\n\ntheorem ne_zero_of_isUnit [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) (x : K) (hx : IsUnit x) :\n    v x \u2260 (0 : \u0393\u2080) := by\n  simpa [hx.choose_spec] using ne_zero_of_unit v hx.choose\n\n/-- A ring homomorphism `S \u2192 R` induces a map `Valuation R \u0393\u2080 \u2192 Valuation S \u0393\u2080`. -/\ndef comap {S : Type*} [Ring S] (f : S \u2192+* R) (v : Valuation R \u0393\u2080) : Valuation S \u0393\u2080 :=\n  { v.toMonoidWithZeroHom.comp f.toMonoidWithZeroHom with\n    toFun := v \u2218 f\n    map_add_le_max' := fun x y => by simp only [comp_apply, map_add, f.map_add] }\n\n@[simp]\ntheorem comap_apply {S : Type*} [Ring S] (f : S \u2192+* R) (v : Valuation R \u0393\u2080) (s : S) :\n    v.comap f s = v (f s) := rfl\n\n@[simp]\ntheorem comap_id : v.comap (RingHom.id R) = v :=\n  ext fun _r => rfl\n\ntheorem comap_comp {S\u2081 : Type*} {S\u2082 : Type*} [Ring S\u2081] [Ring S\u2082] (f : S\u2081 \u2192+* S\u2082) (g : S\u2082 \u2192+* R) :\n    v.comap (g.comp f) = (v.comap g).comap f :=\n  ext fun _r => rfl\n\n/-- A `\u2264`-preserving group homomorphism `\u0393\u2080 \u2192 \u0393'\u2080` induces a map `Valuation R \u0393\u2080 \u2192 Valuation R \u0393'\u2080`.\n-/\ndef map (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080) (hf : Monotone f) (v : Valuation R \u0393\u2080) : Valuation R \u0393'\u2080 :=\n  { MonoidWithZeroHom.comp f v.toMonoidWithZeroHom with\n    toFun := f \u2218 v\n    map_add_le_max' := fun r s =>\n      calc\n        f (v (r + s)) \u2264 f (max (v r) (v s)) := hf (v.map_add r s)\n        _ = max (f (v r)) (f (v s)) := hf.map_max\n         }\n\n@[simp]\nlemma map_apply (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080) (hf : Monotone f) (v : Valuation R \u0393\u2080) (r : R) :\n    v.map f hf r = f (v r) := rfl\n\n/-- Two valuations on `R` are defined to be equivalent if they induce the same preorder on `R`. -/\ndef IsEquiv (v\u2081 : Valuation R \u0393\u2080) (v\u2082 : Valuation R \u0393'\u2080) : Prop :=\n  \u2200 r s, v\u2081 r \u2264 v\u2081 s \u2194 v\u2082 r \u2264 v\u2082 s\n\n@[simp]\ntheorem map_neg (x : R) : v (-x) = v x :=\n  v.toMonoidWithZeroHom.toMonoidHom.map_neg x\n\ntheorem map_sub_swap (x y : R) : v (x - y) = v (y - x) :=\n  v.toMonoidWithZeroHom.toMonoidHom.map_sub_swap x y\n\ntheorem map_sub (x y : R) : v (x - y) \u2264 max (v x) (v y) :=\n  calc\n    v (x - y) = v (x + -y) := by rw [sub_eq_add_neg]\n    _ \u2264 max (v x) (v <| -y) := v.map_add _ _\n    _ = max (v x) (v y) := by rw [map_neg]\n\ntheorem map_sub_le {x y g} (hx : v x \u2264 g) (hy : v y \u2264 g) : v (x - y) \u2264 g := by\n  rw [sub_eq_add_neg]\n  exact v.map_add_le hx (le_trans (le_of_eq (v.map_neg y)) hy)\n\nvariable {x y : R}\n\ntheorem map_add_of_distinct_val (h : v x \u2260 v y) : v (x + y) = max (v x) (v y) := by\n  suffices \u00acv (x + y) < max (v x) (v y) from\n    or_iff_not_imp_right.1 (le_iff_eq_or_lt.1 (v.map_add x y)) this\n  intro h'\n  wlog vyx : v y < v x generalizing x y\n  \u00b7 refine this h.symm ?_ (h.lt_or_lt.resolve_right vyx)\n    rwa [add_comm, max_comm]\n  rw [max_eq_left_of_lt vyx] at h'\n  apply lt_irrefl (v x)\n  calc\n    v x = v (x + y - y) := by simp\n    _ \u2264 max (v <| x + y) (v y) := map_sub _ _ _\n    _ < v x := max_lt h' vyx\n\ntheorem map_add_eq_of_lt_right (h : v x < v y) : v (x + y) = v y :=\n  (v.map_add_of_distinct_val h.ne).trans (max_eq_right_iff.mpr h.le)\n\ntheorem map_add_eq_of_lt_left (h : v y < v x) : v (x + y) = v x := by\n  rw [add_comm]; exact map_add_eq_of_lt_right _ h\n\ntheorem map_sub_eq_of_lt_right (h : v x < v y) : v (x - y) = v y := by\n  rw [sub_eq_add_neg, map_add_eq_of_lt_right, map_neg]\n  rwa [map_neg]\n\nopen scoped Classical in\ntheorem map_sum_eq_of_lt {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {j : \u03b9}\n    (hj : j \u2208 s) (h0 : v (f j) \u2260 0) (hf : \u2200 i \u2208 s \\ {j}, v (f i) < v (f j)) :\n    v (\u2211 i \u2208 s, f i) = v (f j) := by\n  rw [Finset.sum_eq_add_sum_diff_singleton hj]\n  exact map_add_eq_of_lt_left _ (map_sum_lt _ h0 hf)\n\ntheorem map_sub_eq_of_lt_left (h : v y < v x) : v (x - y) = v x := by\n  rw [sub_eq_add_neg, map_add_eq_of_lt_left]\n  rwa [map_neg]\n\ntheorem map_eq_of_sub_lt (h : v (y - x) < v x) : v y = v x := by\n  have := Valuation.map_add_of_distinct_val v (ne_of_gt h).symm\n  rw [max_eq_right (le_of_lt h)] at this\n  simpa using this\n\ntheorem map_one_add_of_lt (h : v x < 1) : v (1 + x) = 1 := by\n  rw [\u2190 v.map_one] at h\n  simpa only [v.map_one] using v.map_add_eq_of_lt_left h\n\ntheorem map_one_sub_of_lt (h : v x < 1) : v (1 - x) = 1 := by\n  rw [\u2190 v.map_one, \u2190 v.map_neg] at h\n  rw [sub_eq_add_neg 1 x]\n  simpa only [v.map_one, v.map_neg] using v.map_add_eq_of_lt_left h\n\n/-- An ordered monoid isomorphism `\u0393\u2080 \u2243 \u0393'\u2080` induces an equivalence\n`Valuation R \u0393\u2080 \u2243 Valuation R \u0393'\u2080`. -/\ndef congr (f : \u0393\u2080 \u2243*o \u0393'\u2080) : Valuation R \u0393\u2080 \u2243 Valuation R \u0393'\u2080 where\n  toFun := map f f.toOrderIso.monotone\n  invFun := map f.symm f.toOrderIso.symm.monotone\n  left_inv \u03bd := by ext; simp\n  right_inv \u03bd := by ext; simp\n\nend Monoid\n\nsection Group\n\nvariable [LinearOrderedCommGroupWithZero \u0393\u2080] (v : Valuation R \u0393\u2080) {x y : R}\n\ntheorem map_inv {R : Type*} [DivisionRing R] (v : Valuation R \u0393\u2080) : \u2200 x, v x\u207b\u00b9 = (v x)\u207b\u00b9 :=\n  map_inv\u2080 _\n\ntheorem map_div {R : Type*} [DivisionRing R] (v : Valuation R \u0393\u2080) : \u2200 x y, v (x / y) = v x / v y :=\n  map_div\u2080 _\n\ntheorem one_lt_val_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : 1 < v x \u2194 v x\u207b\u00b9 < 1 := by\n  simp [inv_lt_one\u2080 (v.pos_iff.2 h)]\n\ntheorem one_le_val_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : 1 \u2264 v x \u2194 v x\u207b\u00b9 \u2264 1 := by\n  simp [inv_le_one\u2080 (v.pos_iff.2 h)]\n\ntheorem val_lt_one_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : v x < 1 \u2194 1 < v x\u207b\u00b9 := by\n  simp [one_lt_inv\u2080 (v.pos_iff.2 h)]\n\ntheorem val_le_one_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : v x \u2264 1 \u2194 1 \u2264 v x\u207b\u00b9 := by\n  simp [one_le_inv\u2080 (v.pos_iff.2 h)]\n\ntheorem val_eq_one_iff (v : Valuation K \u0393\u2080) {x : K} : v x = 1 \u2194 v x\u207b\u00b9 = 1 := by\n  by_cases h : x = 0\n  \u00b7 simp only [map_inv\u2080, inv_eq_one]\n  \u00b7 simpa only [le_antisymm_iff, And.comm] using and_congr (one_le_val_iff v h) (val_le_one_iff v h)\n\ntheorem val_le_one_or_val_inv_lt_one (v : Valuation K \u0393\u2080) (x : K) : v x \u2264 1 \u2228 v x\u207b\u00b9 < 1 := by\n  by_cases h : x = 0\n  \u00b7 simp only [h, _root_.map_zero, zero_le', inv_zero, zero_lt_one, or_self]\n  \u00b7 simp only [\u2190 one_lt_val_iff v h, le_or_lt]\n\n/--\nThis theorem is a weaker version of `Valuation.val_le_one_or_val_inv_lt_one`, but more symmetric\nin `x` and `x\u207b\u00b9`.\n-/\ntheorem val_le_one_or_val_inv_le_one (v : Valuation K \u0393\u2080) (x : K) : v x \u2264 1 \u2228 v x\u207b\u00b9 \u2264 1 := by\n  by_cases h : x = 0\n  \u00b7 simp only [h, _root_.map_zero, zero_le', inv_zero, or_self]\n  \u00b7 simp only [\u2190 one_le_val_iff v h, le_total]\n\n/-- The subgroup of elements whose valuation is less than a certain unit. -/\ndef ltAddSubgroup (v : Valuation R \u0393\u2080) (\u03b3 : \u0393\u2080\u02e3) : AddSubgroup R where\n  carrier := { x | v x < \u03b3 }\n  zero_mem' := by simp\n  add_mem' {x y} x_in y_in := lt_of_le_of_lt (v.map_add x y) (max_lt x_in y_in)\n  neg_mem' x_in := by rwa [Set.mem_setOf, map_neg]\n\nend Group\n\nend Basic\n\n-- end of section\nnamespace IsEquiv\n\nvariable [Ring R] [LinearOrderedCommMonoidWithZero \u0393\u2080] [LinearOrderedCommMonoidWithZero \u0393'\u2080]\n  {v : Valuation R \u0393\u2080} {v\u2081 : Valuation R \u0393\u2080} {v\u2082 : Valuation R \u0393'\u2080} {v\u2083 : Valuation R \u0393''\u2080}\n\n@[refl]\ntheorem refl : v.IsEquiv v := fun _ _ => Iff.refl _\n\n@[symm]\ntheorem symm (h : v\u2081.IsEquiv v\u2082) : v\u2082.IsEquiv v\u2081 := fun _ _ => Iff.symm (h _ _)\n\n@[trans]\ntheorem trans (h\u2081\u2082 : v\u2081.IsEquiv v\u2082) (h\u2082\u2083 : v\u2082.IsEquiv v\u2083) : v\u2081.IsEquiv v\u2083 := fun _ _ =>\n  Iff.trans (h\u2081\u2082 _ _) (h\u2082\u2083 _ _)\n\ntheorem of_eq {v' : Valuation R \u0393\u2080} (h : v = v') : v.IsEquiv v' := by subst h; rfl\n\ntheorem map {v' : Valuation R \u0393\u2080} (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080) (hf : Monotone f) (inf : Injective f)\n    (h : v.IsEquiv v') : (v.map f hf).IsEquiv (v'.map f hf) :=\n  let H : StrictMono f := hf.strictMono_of_injective inf\n  fun r s =>\n  calc\n    f (v r) \u2264 f (v s) \u2194 v r \u2264 v s := by rw [H.le_iff_le]\n    _ \u2194 v' r \u2264 v' s := h r s\n    _ \u2194 f (v' r) \u2264 f (v' s) := by rw [H.le_iff_le]\n\n/-- `comap` preserves equivalence. -/\ntheorem comap {S : Type*} [Ring S] (f : S \u2192+* R) (h : v\u2081.IsEquiv v\u2082) :\n    (v\u2081.comap f).IsEquiv (v\u2082.comap f) := fun r s => h (f r) (f s)\n\ntheorem val_eq (h : v\u2081.IsEquiv v\u2082) {r s : R} : v\u2081 r = v\u2081 s \u2194 v\u2082 r = v\u2082 s := by\n  simpa only [le_antisymm_iff] using and_congr (h r s) (h s r)\n\ntheorem ne_zero (h : v\u2081.IsEquiv v\u2082) {r : R} : v\u2081 r \u2260 0 \u2194 v\u2082 r \u2260 0 := by\n  have : v\u2081 r \u2260 v\u2081 0 \u2194 v\u2082 r \u2260 v\u2082 0 := not_congr h.val_eq\n  rwa [v\u2081.map_zero, v\u2082.map_zero] at this\n\nend IsEquiv\n\n-- end of namespace\nsection\n\ntheorem isEquiv_of_map_strictMono [LinearOrderedCommMonoidWithZero \u0393\u2080]\n    [LinearOrderedCommMonoidWithZero \u0393'\u2080] [Ring R] {v : Valuation R \u0393\u2080} (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080)\n    (H : StrictMono f) : IsEquiv (v.map f H.monotone) v := fun _x _y =>\n  \u27e8H.le_iff_le.mp, fun h => H.monotone h\u27e9\n\ntheorem isEquiv_iff_val_lt_val [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x y : K}, v x < v y \u2194 v' x < v' y := by\n  simp only [IsEquiv, le_iff_le_iff_lt_iff_lt]\n  exact forall_comm\n\nalias \u27e8IsEquiv.lt_iff_lt, _\u27e9 := isEquiv_iff_val_lt_val\n\ntheorem isEquiv_of_val_le_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080}\n    (h : \u2200 {x : K}, v x \u2264 1 \u2194 v' x \u2264 1) : v.IsEquiv v' := by\n  intro x y\n  obtain rfl | hy := eq_or_ne y 0\n  \u00b7 simp\n  \u00b7 rw [\u2190 div_le_one\u2080, \u2190 v.map_div, h, v'.map_div, div_le_one\u2080] <;>\n      rwa [zero_lt_iff, ne_zero_iff]\n\ntheorem isEquiv_iff_val_le_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v x \u2264 1 \u2194 v' x \u2264 1 :=\n  \u27e8fun h x => by simpa using h x 1, isEquiv_of_val_le_one\u27e9\n\nalias \u27e8IsEquiv.le_one_iff_le_one, _\u27e9 := isEquiv_iff_val_le_one\n\ntheorem isEquiv_iff_val_eq_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v x = 1 \u2194 v' x = 1 := by\n  constructor\n  \u00b7 intro h x\n    simpa using @IsEquiv.val_eq _ _ _ _ _ _ v v' h x 1\n  \u00b7 intro h\n    apply isEquiv_of_val_le_one\n    intro x\n    constructor\n    \u00b7 intro hx\n      rcases lt_or_eq_of_le hx with hx' | hx'\n      \u00b7 have : v (1 + x) = 1 := by\n          rw [\u2190 v.map_one]\n          apply map_add_eq_of_lt_left\n          simpa\n        rw [h] at this\n        rw [show x = -1 + (1 + x) by simp]\n        refine le_trans (v'.map_add _ _) ?_\n        simp [this]\n      \u00b7 rw [h] at hx'\n        exact le_of_eq hx'\n    \u00b7 intro hx\n      rcases lt_or_eq_of_le hx with hx' | hx'\n      \u00b7 have : v' (1 + x) = 1 := by\n          rw [\u2190 v'.map_one]\n          apply map_add_eq_of_lt_left\n          simpa\n        rw [\u2190 h] at this\n        rw [show x = -1 + (1 + x) by simp]\n        refine le_trans (v.map_add _ _) ?_\n        simp [this]\n      \u00b7 rw [\u2190 h] at hx'\n        exact le_of_eq hx'\n\nalias \u27e8IsEquiv.eq_one_iff_eq_one, _\u27e9 := isEquiv_iff_val_eq_one\n\ntheorem isEquiv_iff_val_lt_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v x < 1 \u2194 v' x < 1 := by\n  constructor\n  \u00b7 intro h x\n    simp only [lt_iff_le_and_ne,\n      and_congr h.le_one_iff_le_one h.eq_one_iff_eq_one.not]\n  \u00b7 rw [isEquiv_iff_val_eq_one]\n    intro h x\n    by_cases hx : x = 0\n    \u00b7 simp only [(zero_iff _).2 hx, zero_ne_one]\n    constructor\n    \u00b7 intro hh\n      by_contra h_1\n      cases ne_iff_lt_or_gt.1 h_1 with\n      | inl h_2 => simpa [hh, lt_self_iff_false] using h.2 h_2\n      | inr h_2 =>\n          rw [\u2190 inv_one, \u2190 inv_eq_iff_eq_inv, \u2190 map_inv\u2080] at hh\n          exact hh.not_lt (h.2 ((one_lt_val_iff v' hx).1 h_2))\n    \u00b7 intro hh\n      by_contra h_1\n      cases ne_iff_lt_or_gt.1 h_1 with\n      | inl h_2 => simpa [hh, lt_self_iff_false] using h.1 h_2\n      | inr h_2 =>\n        rw [\u2190 inv_one, \u2190 inv_eq_iff_eq_inv, \u2190 map_inv\u2080] at hh\n        exact hh.not_lt (h.1 ((one_lt_val_iff v hx).1 h_2))\n\nalias \u27e8IsEquiv.lt_one_iff_lt_one, _\u27e9 := isEquiv_iff_val_lt_one\n\ntheorem isEquiv_iff_val_sub_one_lt_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v (x - 1) < 1 \u2194 v' (x - 1) < 1 := by\n  rw [isEquiv_iff_val_lt_one]\n  exact (Equiv.subRight 1).surjective.forall\n\nalias \u27e8IsEquiv.val_sub_one_lt_one_iff, _\u27e9 := isEquiv_iff_val_sub_one_lt_one\n\ntheorem isEquiv_tfae [LinearOrderedCommGroupWithZero \u0393\u2080] [LinearOrderedCommGroupWithZero \u0393'\u2080]\n    (v : Valuation K \u0393\u2080) (v' : Valuation K \u0393'\u2080) :\n    [ v.IsEquiv v',\n      \u2200 {x y}, v x < v y \u2194 v' x < v' y,\n      \u2200 {x}, v x \u2264 1 \u2194 v' x \u2264 1,\n      \u2200 {x}, v x = 1 \u2194 v' x = 1,\n      \u2200 {x}, v x < 1 \u2194 v' x < 1,\n      \u2200 {x}, v (x - 1) < 1 \u2194 v' (x - 1) < 1 ].TFAE := by\n  tfae_have 1 \u2194 2 := isEquiv_iff_val_lt_val\n  tfae_have 1 \u2194 3 := isEquiv_iff_val_le_one\n  tfae_have 1 \u2194 4 := isEquiv_iff_val_eq_one\n  tfae_have 1 \u2194 5 := isEquiv_iff_val_lt_one\n  tfae_have 1 \u2194 6 := isEquiv_iff_val_sub_one_lt_one\n  tfae_finish\n\nend\n\nsection Supp\n\nvariable [CommRing R] [LinearOrderedCommMonoidWithZero \u0393\u2080] (v : Valuation R \u0393\u2080)\n\n/-- The support of a valuation `v : R \u2192 \u0393\u2080` is the ideal of `R` where `v` vanishes. -/\ndef supp : Ideal R where\n  carrier := { x | v x = 0 }\n  zero_mem' := map_zero v\n  add_mem' {x y} hx hy := le_zero_iff.mp <|\n    calc\n      v (x + y) \u2264 max (v x) (v y) := v.map_add x y\n      _ \u2264 0 := max_le (le_zero_iff.mpr hx) (le_zero_iff.mpr hy)\n  smul_mem' c x hx :=\n    calc\n      v (c * x) = v c * v x := map_mul v c x\n      _ = v c * 0 := congr_arg _ hx\n      _ = 0 := mul_zero _\n\n@[simp]\ntheorem mem_supp_iff (x : R) : x \u2208 supp v \u2194 v x = 0 :=\n  Iff.rfl\n\n/-- The support of a valuation is a prime ideal. -/\ninstance [Nontrivial \u0393\u2080] [NoZeroDivisors \u0393\u2080] : Ideal.IsPrime (supp v) :=\n  \u27e8fun h =>\n    one_ne_zero (\u03b1 := \u0393\u2080) <|\n      calc\n        1 = v 1 := v.map_one.symm\n        _ = 0 := by rw [\u2190 mem_supp_iff, h]; exact Submodule.mem_top,\n   fun {x y} hxy => by\n    simp only [mem_supp_iff] at hxy \u22a2\n    rw [v.map_mul x y] at hxy\n    exact eq_zero_or_eq_zero_of_mul_eq_zero hxy\u27e9\n\ntheorem map_add_supp (a : R) {s : R} (h : s \u2208 supp v) : v (a + s) = v a := by\n  have aux : \u2200 a s, v s = 0 \u2192 v (a + s) \u2264 v a := by\n    intro a' s' h'\n    refine le_trans (v.map_add a' s') (max_le le_rfl ?_)\n    simp [h']\n  apply le_antisymm (aux a s h)\n  calc\n    v a = v (a + s + -s) := by simp\n    _ \u2264 v (a + s) := aux (a + s) (-s) (by rwa [\u2190 Ideal.neg_mem_iff] at h)\n\ntheorem comap_supp {S : Type*} [CommRing S] (f : S \u2192+* R) :\n    supp (v.comap f) = Ideal.comap f v.supp :=\n  Ideal.ext fun x => by rw [mem_supp_iff, Ideal.mem_comap, mem_supp_iff, comap_apply]\n\nend Supp\n\n-- end of section\nend Valuation\n\nsection AddMonoid\n\nvariable (R) [Ring R] (\u0393\u2080 : Type*) [LinearOrderedAddCommMonoidWithTop \u0393\u2080]\n\n/-- The type of `\u0393\u2080`-valued additive valuations on `R`. -/\ndef AddValuation :=\n  Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48)\n\nend AddMonoid\n\nnamespace AddValuation\n\nvariable {\u0393\u2080 : Type*} {\u0393'\u2080 : Type*}\n\nsection Basic\n\nsection Monoid\n\n/-- A valuation is coerced to the underlying function `R \u2192 \u0393\u2080`. -/\ninstance (R) (\u0393\u2080) [Ring R] [LinearOrderedAddCommMonoidWithTop \u0393\u2080] :\n    FunLike (AddValuation R \u0393\u2080) R \u0393\u2080 where\n  coe v := v.toMonoidWithZeroHom.toFun\n  coe_injective' f g := by cases f; cases g; simp (config := {contextual := true})\n\nvariable [Ring R] [LinearOrderedAddCommMonoidWithTop \u0393\u2080] [LinearOrderedAddCommMonoidWithTop \u0393'\u2080]\n  (v : AddValuation R \u0393\u2080)\n\nsection\n\nvariable (f : R \u2192 \u0393\u2080) (h0 : f 0 = \u22a4) (h1 : f 1 = 0)\nvariable (hadd : \u2200 x y, min (f x) (f y) \u2264 f (x + y)) (hmul : \u2200 x y, f (x * y) = f x + f y)\n\n/-- An alternate constructor of `AddValuation`, that doesn't reference `Multiplicative \u0393\u2080\u1d52\u1d48` -/\ndef of : AddValuation R \u0393\u2080 where\n  toFun := f\n  map_one' := h1\n  map_zero' := h0\n  map_add_le_max' := hadd\n  map_mul' := hmul\n\nvariable {h0} {h1} {hadd} {hmul} {r : R}\n\n@[simp]\ntheorem of_apply : (of f h0 h1 hadd hmul) r = f r := rfl\n\n/-- The `Valuation` associated to an `AddValuation` (useful if the latter is constructed using\n`AddValuation.of`). -/\ndef toValuation : AddValuation R \u0393\u2080 \u2243 Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48) :=\n  Equiv.refl _\n\n@[deprecated (since := \"2024-11-09\")]\nalias valuation := toValuation\n\n/-- The `AddValuation` associated to a `Valuation`.\n-/\ndef ofValuation : Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48) \u2243 AddValuation R \u0393\u2080 :=\n  Equiv.refl _\n\n@[simp]\nlemma ofValuation_symm_eq : ofValuation.symm = toValuation (R := R) (\u0393\u2080 := \u0393\u2080) := rfl\n\n@[simp]\nlemma toValuation_symm_eq : toValuation.symm = ofValuation (R := R) (\u0393\u2080 := \u0393\u2080) := rfl\n\n@[simp]\nlemma ofValuation_toValuation : ofValuation (toValuation v) = v := rfl\n\n@[simp]\nlemma toValuation_ofValuation (v : Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48)) :\n    toValuation (ofValuation v) = v := rfl\n\n@[simp]\ntheorem toValuation_apply (r : R) :\n    toValuation v r = Multiplicative.ofAdd (OrderDual.toDual (v r)) :=\n  rfl\n\n@[deprecated (since := \"2024-11-09\")]\nalias valuation_apply := toValuation_apply\n\n@[simp]\ntheorem ofValuation_apply (v : Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48)) (r : R) :\n    ofValuation v r = OrderDual.ofDual (Multiplicative.toAdd (v r)) :=\n  rfl\n\nend\n\n-- Porting note: Lean get confused about namespaces and instances below\n@[simp]\ntheorem map_zero : v 0 = (\u22a4 : \u0393\u2080) :=\n  Valuation.map_zero v\n\n@[simp]\ntheorem map_one : v 1 = (0 : \u0393\u2080) :=\n  Valuation.map_one v\n\n/- Porting note: helper wrapper to coerce `v` to the correct function type -/\n/-- A helper function for Lean to inferring types correctly -/\ndef asFun : R \u2192 \u0393\u2080 := v\n\n@[simp]\ntheorem map_mul : \u2200 (x y : R), v (x * y) = v x + v y :=\n  Valuation.map_mul v\n\n-- Porting note: LHS simplified so created map_add' and removed simp tag\ntheorem map_add : \u2200 (x y : R), min (v x) (v y) \u2264 v (x + y) :=\n  Valuation.map_add v\n\n@[simp]\ntheorem map_add' : \u2200 (x y : R), v x \u2264 v (x + y) \u2228 v y \u2264 v (x + y) := by\n  intro x y\n  rw [\u2190 @min_le_iff _ _ (v x) (v y) (v (x+y)), \u2190 ge_iff_le]\n  apply map_add\n\ntheorem map_le_add {x y : R} {g : \u0393\u2080} (hx : g \u2264 v x) (hy : g \u2264 v y) : g \u2264 v (x + y) :=\n  Valuation.map_add_le v hx hy\n\ntheorem map_lt_add {x y : R} {g : \u0393\u2080} (hx : g < v x) (hy : g < v y) : g < v (x + y) :=\n  Valuation.map_add_lt v hx hy\n\ntheorem map_le_sum {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hf : \u2200 i \u2208 s, g \u2264 v (f i)) :\n    g \u2264 v (\u2211 i \u2208 s, f i) :=\n  v.map_sum_le hf\n\ntheorem map_lt_sum {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hg : g \u2260 \u22a4)\n    (hf : \u2200 i \u2208 s, g < v (f i)) : g < v (\u2211 i \u2208 s, f i) :=\n  v.map_sum_lt hg hf\n\ntheorem map_lt_sum' {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hg : g < \u22a4)\n    (hf : \u2200 i \u2208 s, g < v (f i)) : g < v (\u2211 i \u2208 s, f i) :=\n  v.map_sum_lt' hg hf\n\n@[simp]\ntheorem map_pow : \u2200 (x : R) (n : \u2115), v (x ^ n) = n \u2022 (v x) :=\n  Valuation.map_pow v\n\n@[ext]\ntheorem ext {v\u2081 v\u2082 : AddValuation R \u0393\u2080} (h : \u2200 r, v\u2081 r = v\u2082 r) : v\u2081 = v\u2082 :=\n  Valuation.ext h\n\n-- The following definition is not an instance, because we have more than one `v` on a given `R`.\n-- In addition, type class inference would not be able to infer `v`.\n/-- A valuation gives a preorder on the underlying ring. -/\ndef toPreorder : Preorder R :=\n  Preorder.lift v\n\n/-- If `v` is an additive valuation on a division ring then `v(x) = \u22a4` iff `x = 0`. -/\n@[simp]\ntheorem top_iff [Nontrivial \u0393\u2080] (v : AddValuation K \u0393\u2080) {x : K} : v x = (\u22a4 : \u0393\u2080) \u2194 x = 0 :=\n  v.zero_iff\n\ntheorem ne_top_iff [Nontrivial \u0393\u2080] (v : AddValuation K \u0393\u2080) {x : K} : v x \u2260 (\u22a4 : \u0393\u2080) \u2194 x \u2260 0 :=\n  v.ne_zero_iff\n\n/-- A ring homomorphism `S \u2192 R` induces a map `AddValuation R \u0393\u2080 \u2192 AddValuation S \u0393\u2080`. -/\ndef comap {S : Type*} [Ring S] (f : S \u2192+* R) (v : AddValuation R \u0393\u2080) : AddValuation S \u0393\u2080 :=\n  Valuation.comap f v\n\n@[simp]\ntheorem comap_id : v.comap (RingHom.id R) = v :=\n  Valuation.comap_id v\n\ntheorem comap_comp {S\u2081 : Type*} {S\u2082 : Type*} [Ring S\u2081] [Ring S\u2082] (f : S\u2081 \u2192+* S\u2082) (g : S\u2082 \u2192+* R) :\n    v.comap (g.comp f) = (v.comap g).comap f :=\n  Valuation.comap_comp v f g\n\n/-- A `\u2264`-preserving, `\u22a4`-preserving group homomorphism `\u0393\u2080 \u2192 \u0393'\u2080` induces a map\n  `AddValuation R \u0393\u2080 \u2192 AddValuation R \u0393'\u2080`.\n-/\ndef map (f : \u0393\u2080 \u2192+ \u0393'\u2080) (ht : f \u22a4 = \u22a4) (hf : Monotone f) (v : AddValuation R \u0393\u2080) :\n    AddValuation R \u0393'\u2080 :=\n  @Valuation.map R (Multiplicative \u0393\u2080\u1d52\u1d48) (Multiplicative \u0393'\u2080\u1d52\u1d48) _ _ _\n    { toFun := f\n      map_mul' := f.map_add\n      map_one' := f.map_zero\n      map_zero' := ht } (fun _ _ h => hf h) v\n\n@[simp]\nlemma map_apply (f : \u0393\u2080 \u2192+ \u0393'\u2080) (ht : f \u22a4 = \u22a4) (hf : Monotone f) (v : AddValuation R \u0393\u2080) (r : R) :\n    v.map f ht hf r = f (v r) := rfl\n\n/-- Two additive valuations on `R` are defined to be equivalent if they induce the same\n  preorder on `R`. -/\ndef IsEquiv (v\u2081 : AddValuation R \u0393\u2080) (v\u2082 : AddValuation R \u0393'\u2080) : Prop :=\n  Valuation.IsEquiv v\u2081 v\u2082\n\n@[simp]\ntheorem map_neg (x : R) : v (-x) = v x :=\n  Valuation.map_neg v x\n\ntheorem map_sub_swap (x y : R) : v (x - y) = v (y - x) :=\n  Valuation.map_sub_swap v x y\n\ntheorem map_sub (x y : R) : min (v x) (v y) \u2264 v (x - y) :=\n  Valuation.map_sub v x y\n\ntheorem map_le_sub {x y : R} {g : \u0393\u2080} (hx : g \u2264 v x) (hy : g \u2264 v y) : g \u2264 v (x - y) :=\n  Valuation.map_sub_le v hx hy\n\nvariable {x y : R}\n\ntheorem map_add_of_distinct_val (h : v x \u2260 v y) : v (x + y) = @Min.min \u0393\u2080 _ (v x) (v y) :=\n  Valuation.map_add_of_distinct_val v h\n\ntheorem map_add_eq_of_lt_left {x y : R} (h : v x < v y) :\n    v (x + y) = v x := by\n  rw [map_add_of_distinct_val _ h.ne, min_eq_left h.le]\n\ntheorem map_add_eq_of_lt_right {x y : R} (hx : v y < v x) :\n    v (x + y) = v y := add_comm y x \u25b8 map_add_eq_of_lt_left v hx\n\ntheorem map_sub_eq_of_lt_left {x y : R} (hx : v x < v y) :\n    v (x - y) = v x := by\n  rw [sub_eq_add_neg]\n  apply map_add_eq_of_lt_left\n  rwa [map_neg]\n\ntheorem map_sub_eq_of_lt_right {x y : R} (hx : v y < v x) :\n    v (x - y) = v y := map_sub_swap v x y \u25b8 map_sub_eq_of_lt_left v hx\n\ntheorem map_eq_of_lt_sub (h : v x < v (y - x)) : v y = v x :=\n  Valuation.map_eq_of_sub_lt v h\n\nend Monoid\n\nsection Group\n\nvariable [LinearOrderedAddCommGroupWithTop \u0393\u2080] [Ring R] (v : AddValuation R \u0393\u2080) {x y : R}\n\n@[simp]\ntheorem map_inv (v : AddValuation K \u0393\u2080) {x : K} : v x\u207b\u00b9 = - (v x) :=\n  map_inv\u2080 (toValuation v) x\n\n@[simp]\ntheorem map_div (v : AddValuation K \u0393\u2080) {x y : K} : v (x / y) = v x - v y :=\n  map_div\u2080 (toValuation v) x y\n\nend Group\n\nend Basic\n\nnamespace IsEquiv\n\nvariable [LinearOrderedAddCommMonoidWithTop \u0393\u2080] [LinearOrderedAddCommMonoidWithTop \u0393'\u2080]\n  [Ring R]\n  {\u0393''\u2080 : Type*} [LinearOrderedAddCommMonoidWithTop \u0393''\u2080]\n  {v : AddValuation R \u0393\u2080}\n   {v\u2081 : AddValuation R \u0393\u2080} {v\u2082 : AddValuation R \u0393'\u2080} {v\u2083 : AddValuation R \u0393''\u2080}\n\n@[refl]\ntheorem refl : v.IsEquiv v :=\n  Valuation.IsEquiv.refl\n\n@[symm]\ntheorem symm (h : v\u2081.IsEquiv v\u2082) : v\u2082.IsEquiv v\u2081 :=\n  Valuation.IsEquiv.symm h\n\n@[trans]\ntheorem trans (h\u2081\u2082 : v\u2081.IsEquiv v\u2082) (h\u2082\u2083 : v\u2082.IsEquiv v\u2083) : v\u2081.IsEquiv v\u2083 :=\n  Valuation.IsEquiv.trans h\u2081\u2082 h\u2082\u2083\n\ntheorem of_eq {v' : AddValuation R \u0393\u2080} (h : v = v') : v.IsEquiv v' :=\n  Valuation.IsEquiv.of_eq h\n\ntheorem map {v' : AddValuation R \u0393\u2080} (f : \u0393\u2080 \u2192+ \u0393'\u2080) (ht : f \u22a4 = \u22a4) (hf : Monotone f)\n    (inf : Injective f) (h : v.IsEquiv v') : (v.map f ht hf).IsEquiv (v'.map f ht hf) :=\n  @Valuation.IsEquiv.map R (Multiplicative \u0393\u2080\u1d52\u1d48) (Multiplicative \u0393'\u2080\u1d52\u1d48) _ _ _ _ _\n    { toFun := f\n      map_mul' := f.map_add\n      map_one' := f.map_zero\n      map_zero' := ht } (fun _x _y h => hf h) inf h\n\n/-- `comap` preserves equivalence. -/\ntheorem comap {S : Type*} [Ring S] (f : S \u2192+* R) (h : v\u2081.IsEquiv v\u2082) :\n    (v\u2081.comap f).IsEquiv (v\u2082.comap f) :=\n  Valuation.IsEquiv.comap f h\n\ntheorem val_eq (h : v\u2081.IsEquiv v\u2082) {r s : R} : v\u2081 r = v\u2081 s \u2194 v\u2082 r = v\u2082 s :=\n  Valuation.IsEquiv.val_eq h\n\ntheorem ne_top (h : v\u2081.IsEquiv v\u2082) {r : R} : v\u2081 r \u2260 (\u22a4 : \u0393\u2080) \u2194 v\u2082 r \u2260 (\u22a4 : \u0393'\u2080) :=\n  Valuation.IsEquiv.ne_zero h\n\nend IsEquiv\n\nsection Supp\n\nvariable [LinearOrderedAddCommMonoidWithTop \u0393\u2080] [CommRing R] (v : AddValuation R \u0393\u2080)\n\n/-- The support of an additive valuation `v : R \u2192 \u0393\u2080` is the ideal of `R` where `v x = \u22a4` -/\ndef supp : Ideal R :=\n  Valuation.supp v\n\n@[simp]\ntheorem mem_supp_iff (x : R) : x \u2208 supp v \u2194 v x = (\u22a4 : \u0393\u2080) :=\n  Valuation.mem_supp_iff v x\n\ntheorem map_add_supp (a : R) {s : R} (h : s \u2208 supp v) : v (a + s) = v a :=\n  Valuation.map_add_supp v a h\n\nend Supp\n\n-- end of section\nend AddValuation\n\nnamespace Valuation\n\nvariable {K \u0393\u2080 : Type*} [Ring R] [LinearOrderedCommMonoidWithZero \u0393\u2080]\n\n/-- The `AddValuation` associated to a `Valuation`. -/\ndef toAddValuation : Valuation R \u0393\u2080 \u2243 AddValuation R (Additive \u0393\u2080)\u1d52\u1d48 :=\n  .trans (congr\n    { toFun := fun x \u21a6 .ofAdd <| .toDual <| .toDual <| .ofMul x\n      invFun := fun x \u21a6 x.toAdd.ofDual.ofDual.toMul\n      left_inv := fun _x \u21a6 rfl\n      right_inv := fun _x \u21a6 rfl\n      map_mul' := fun _x _y \u21a6 rfl\n      map_le_map_iff' := .rfl }) (AddValuation.ofValuation (R := R) (\u0393\u2080 := (Additive \u0393\u2080)\u1d52\u1d48))\n\n/-- The `Valuation` associated to a `AddValuation`.\n-/\ndef ofAddValuation : AddValuation R (Additive \u0393\u2080)\u1d52\u1d48 \u2243 Valuation R \u0393\u2080 :=\n  AddValuation.toValuation.trans <| congr <|\n    { toFun := fun x \u21a6 x.toAdd.ofDual.ofDual.toMul\n      invFun := fun x \u21a6 .ofAdd <| .toDual <| .toDual <| .ofMul x\n      left_inv := fun _x \u21a6 rfl\n      right_inv := fun _x \u21a6 rfl\n      map_mul' := fun _x _y \u21a6 rfl\n      map_le_map_iff' := .rfl }\n\n@[simp]\nlemma ofAddValuation_symm_eq : ofAddValuation.symm = toAddValuation (R := R) (\u0393\u2080 := \u0393\u2080) := rfl\n\n@[simp]\nlemma toAddValuation_symm_eq : toAddValuation.symm = ofAddValuation (R := R) (\u0393\u2080 := \u0393\u2080) := rfl\n\n", "theoremStatement": "@[simp]\nlemma ofAddValuation_toAddValuation (v : Valuation R \u0393\u2080) :\n  ofAddValuation (toAddValuation v) = v ", "theoremName": "Valuation.ofAddValuation_toAddValuation", "fileCreated": {"commit": "a9138cdba12f2110c86195f5eac26cb36dee2627", "date": "2023-03-17"}, "theoremCreated": {"commit": "625ac34a53dfa0eca4fb8a3a933409238e4f43f0", "date": "2024-12-16"}, "file": "mathlib/Mathlib/RingTheory/Valuation/Basic.lean", "module": "Mathlib.RingTheory.Valuation.Basic", "jsonFile": "Mathlib.RingTheory.Valuation.Basic.jsonl", "positionMetadata": {"lineInFile": 937, "tokenPositionInFile": 31902, "theoremPositionInFile": 130}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 12, "numPremises": 14}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "/-\nCopyright (c) 2020 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\nimport Mathlib.Algebra.Algebra.Rat\nimport Mathlib.Algebra.BigOperators.NatAntidiagonal\nimport Mathlib.Data.Nat.Choose.Sum\nimport Mathlib.RingTheory.PowerSeries.Basic\n\n/-!\n# Definition of well-known power series\n\nIn this file we define the following power series:\n\n* `PowerSeries.invUnitsSub`: given `u : R\u02e3`, this is the series for `1 / (u - x)`.\n  It is given by `\u2211 n, x ^ n /\u209a u ^ (n + 1)`.\n\n* `PowerSeries.invOneSubPow`: given a commutative ring `S` and a number `d : \u2115`,\n  `PowerSeries.invOneSubPow S d` is the multiplicative inverse of `(1 - X) ^ d` in `S\u27e6X\u27e7\u02e3`.\n  When `d` is `0`, `PowerSeries.invOneSubPow S d` will just be `1`. When `d` is positive,\n  `PowerSeries.invOneSubPow S d` will be `\u2211 n, Nat.choose (d - 1 + n) (d - 1)`.\n\n* `PowerSeries.sin`, `PowerSeries.cos`, `PowerSeries.exp` : power series for sin, cosine, and\n  exponential functions.\n-/\n\n\nnamespace PowerSeries\n\nsection Ring\n\nvariable {R S : Type*} [Ring R] [Ring S]\n\n/-- The power series for `1 / (u - x)`. -/\ndef invUnitsSub (u : R\u02e3) : PowerSeries R :=\n  mk fun n => 1 /\u209a u ^ (n + 1)\n\n@[simp]\ntheorem coeff_invUnitsSub (u : R\u02e3) (n : \u2115) : coeff R n (invUnitsSub u) = 1 /\u209a u ^ (n + 1) :=\n  coeff_mk _ _\n\n@[simp]\ntheorem constantCoeff_invUnitsSub (u : R\u02e3) : constantCoeff R (invUnitsSub u) = 1 /\u209a u := by\n  rw [\u2190 coeff_zero_eq_constantCoeff_apply, coeff_invUnitsSub, zero_add, pow_one]\n\n@[simp]\ntheorem invUnitsSub_mul_X (u : R\u02e3) : invUnitsSub u * X = invUnitsSub u * C R u - 1 := by\n  ext (_ | n)\n  \u00b7 simp\n  \u00b7 simp [n.succ_ne_zero, pow_succ']\n\n@[simp]\ntheorem invUnitsSub_mul_sub (u : R\u02e3) : invUnitsSub u * (C R u - X) = 1 := by\n  simp [mul_sub, sub_sub_cancel]\n\ntheorem map_invUnitsSub (f : R \u2192+* S) (u : R\u02e3) :\n    map f (invUnitsSub u) = invUnitsSub (Units.map (f : R \u2192* S) u) := by\n  ext\n  simp only [\u2190 map_pow, coeff_map, coeff_invUnitsSub, one_divp]\n  rfl\n\nend Ring\n\nsection invOneSubPow\n\nvariable (S : Type*) [CommRing S] (d : \u2115)\n\n/--\n(1 + X + X^2 + ...) * (1 - X) = 1.\n\nNote that the power series `1 + X + X^2 + ...` is written as `mk 1` where `1` is the constant\nfunction so that `mk 1` is the power series with all coefficients equal to one.\n-/\ntheorem mk_one_mul_one_sub_eq_one : (mk 1 : S\u27e6X\u27e7) * (1 - X) = 1 := by\n  rw [mul_comm, PowerSeries.ext_iff]\n  intro n\n  cases n with\n  | zero => simp\n  | succ n => simp [sub_mul]\n\n/--\nNote that `mk 1` is the constant function `1` so the power series `1 + X + X^2 + ...`. This theorem\nstates that for any `d : \u2115`, `(1 + X + X^2 + ... : S\u27e6X\u27e7) ^ (d + 1)` is equal to the power series\n`mk fun n => Nat.choose (d + n) d : S\u27e6X\u27e7`.\n-/\ntheorem mk_one_pow_eq_mk_choose_add :\n    (mk 1 : S\u27e6X\u27e7) ^ (d + 1) = (mk fun n => Nat.choose (d + n) d : S\u27e6X\u27e7) := by\n  induction d with\n  | zero => ext; simp\n  | succ d hd =>\n      ext n\n      rw [pow_add, hd, pow_one, mul_comm, coeff_mul]\n      simp_rw [coeff_mk, Pi.one_apply, one_mul]\n      norm_cast\n      rw [Finset.sum_antidiagonal_choose_add, add_right_comm]\n\n/--\nGiven a natural number `d : \u2115` and a commutative ring `S`, `PowerSeries.invOneSubPow S d` is the\nmultiplicative inverse of `(1 - X) ^ d` in `S\u27e6X\u27e7\u02e3`. When `d` is `0`, `PowerSeries.invOneSubPow S d`\nwill just be `1`. When `d` is positive, `PowerSeries.invOneSubPow S d` will be the power series\n`mk fun n => Nat.choose (d - 1 + n) (d - 1)`.\n-/\nnoncomputable def invOneSubPow : \u2115 \u2192 S\u27e6X\u27e7\u02e3\n  | 0 => 1\n  | d + 1 => {\n    val := mk fun n => Nat.choose (d + n) d\n    inv := (1 - X) ^ (d + 1)\n    val_inv := by\n      rw [\u2190 mk_one_pow_eq_mk_choose_add, \u2190 mul_pow, mk_one_mul_one_sub_eq_one, one_pow]\n    inv_val := by\n      rw [\u2190 mk_one_pow_eq_mk_choose_add, \u2190 mul_pow, mul_comm, mk_one_mul_one_sub_eq_one, one_pow]\n    }\n\ntheorem invOneSubPow_zero : invOneSubPow S 0 = 1 := by\n  delta invOneSubPow\n  simp only [Units.val_one]\n\ntheorem invOneSubPow_val_eq_mk_sub_one_add_choose_of_pos (h : 0 < d) :\n    (invOneSubPow S d).val = (mk fun n => Nat.choose (d - 1 + n) (d - 1) : S\u27e6X\u27e7) := by\n  rw [\u2190 Nat.sub_one_add_one_eq_of_pos h, invOneSubPow, add_tsub_cancel_right]\n\ntheorem invOneSubPow_val_succ_eq_mk_add_choose :\n    (invOneSubPow S (d + 1)).val = (mk fun n => Nat.choose (d + n) d : S\u27e6X\u27e7) := rfl\n\ntheorem invOneSubPow_val_one_eq_invUnitSub_one :\n    (invOneSubPow S 1).val = invUnitsSub (1 : S\u02e3) := by\n  simp [invOneSubPow, invUnitsSub]\n\n/--\nThe theorem `PowerSeries.mk_one_mul_one_sub_eq_one` implies that `1 - X` is a unit in `S\u27e6X\u27e7`\nwhose inverse is the power series `1 + X + X^2 + ...`. This theorem states that for any `d : \u2115`,\n`PowerSeries.invOneSubPow S d` is equal to `(1 - X)\u207b\u00b9 ^ d`.\n-/\ntheorem invOneSubPow_eq_inv_one_sub_pow :\n    invOneSubPow S d =\n      (Units.mkOfMulEqOne (1 - X) (mk 1 : S\u27e6X\u27e7) <|\n        Eq.trans (mul_comm _ _) (mk_one_mul_one_sub_eq_one S))\u207b\u00b9 ^ d := by\n  induction d with\n  | zero => exact Eq.symm <| pow_zero _\n  | succ d _ =>\n      rw [inv_pow]\n      exact (DivisionMonoid.inv_eq_of_mul _ (invOneSubPow S (d + 1)) <| by\n        rw [\u2190 Units.val_eq_one, Units.val_mul, Units.val_pow_eq_pow_val]\n        exact (invOneSubPow S (d + 1)).inv_val).symm\n\ntheorem invOneSubPow_inv_eq_one_sub_pow :\n    (invOneSubPow S d).inv = (1 - X : S\u27e6X\u27e7) ^ d := by\n  induction d with\n  | zero => exact Eq.symm <| pow_zero _\n  | succ d => rfl\n\ntheorem invOneSubPow_inv_zero_eq_one : (invOneSubPow S 0).inv = 1 := by\n  delta invOneSubPow\n  simp only [Units.inv_eq_val_inv, inv_one, Units.val_one]\n\ntheorem mk_add_choose_mul_one_sub_pow_eq_one :\n    (mk fun n \u21a6 Nat.choose (d + n) d : S\u27e6X\u27e7) * ((1 - X) ^ (d + 1)) = 1 :=\n  (invOneSubPow S (d + 1)).val_inv\n\ntheorem invOneSubPow_add (e : \u2115) :\n    invOneSubPow S (d + e) = invOneSubPow S d * invOneSubPow S e := by\n  simp_rw [invOneSubPow_eq_inv_one_sub_pow, pow_add]\n\ntheorem one_sub_pow_mul_invOneSubPow_val_add_eq_invOneSubPow_val (e : \u2115) :\n    (1 - X) ^ e * (invOneSubPow S (d + e)).val = (invOneSubPow S d).val := by\n  simp [invOneSubPow_add, Units.val_mul, mul_comm, mul_assoc, \u2190 invOneSubPow_inv_eq_one_sub_pow]\n\n", "theoremStatement": "theorem one_sub_pow_add_mul_invOneSubPow_val_eq_one_sub_pow (e : \u2115) :\n    (1 - X) ^ (d + e) * (invOneSubPow S e).val = (1 - X) ^ d ", "theoremName": "PowerSeries.one_sub_pow_add_mul_invOneSubPow_val_eq_one_sub_pow", "fileCreated": {"commit": "d22d5a028da58fd6edc1f288ee97594ef5b586a1", "date": "2023-05-22"}, "theoremCreated": {"commit": "7a05b449ac13af0118fd6b2c133d08e33e7e74ad", "date": "2024-12-04"}, "file": "mathlib/Mathlib/RingTheory/PowerSeries/WellKnown.lean", "module": "Mathlib.RingTheory.PowerSeries.WellKnown", "jsonFile": "Mathlib.RingTheory.PowerSeries.WellKnown.jsonl", "positionMetadata": {"lineInFile": 169, "tokenPositionInFile": 6048, "theoremPositionInFile": 18}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 42, "numPremises": 61}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp [pow_add, mul_assoc, \u2190 invOneSubPow_inv_eq_one_sub_pow S e]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 72}}
{"srcContext": "/-\nCopyright (c) 2024 Jo\u00ebl Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jo\u00ebl Riou\n-/\nimport Mathlib.Algebra.Homology.Embedding.Extend\nimport Mathlib.Algebra.Homology.Embedding.IsSupported\nimport Mathlib.Algebra.Homology.QuasiIso\n\n/-!\n# Homology of the extension of an homological complex\n\nGiven an embedding `e : c.Embedding c'` and `K : HomologicalComplex C c`, we shall\ncompute the homology of `K.extend e`. In degrees that are not in the image of `e.f`,\nthe homology is obviously zero. When `e.f j = j`, we construct an isomorphism\n`(K.extend e).homology j' \u2245 K.homology j`.\n\n-/\n\nopen CategoryTheory Limits Category\n\nnamespace HomologicalComplex\n\nvariable {\u03b9 \u03b9' : Type*} {c : ComplexShape \u03b9} {c' : ComplexShape \u03b9'}\n  {C : Type*} [Category C] [HasZeroMorphisms C]\n  [HasZeroObject C]\n\nvariable (K L M : HomologicalComplex C c) (\u03c6 : K \u27f6 L) (\u03c6' : L \u27f6 M) (e : c.Embedding c')\n\nnamespace extend\n\nsection HomologyData\n\nvariable {i j k : \u03b9} {i' j' k' : \u03b9'} (hj' : e.f j = j')\n  (hi : c.prev j = i) (hi' : c'.prev j' = i') (hk : c.next j = k) (hk' : c'.next j' = k')\n\ninclude hk hk' in\nlemma comp_d_eq_zero_iff \u2983W : C\u2984 (\u03c6 : W \u27f6 K.X j) :\n    \u03c6 \u226b K.d j k = 0 \u2194 \u03c6 \u226b (K.extendXIso e hj').inv \u226b (K.extend e).d j' k' = 0 := by\n  by_cases hjk : c.Rel j k\n  \u00b7 have hk' : e.f k = k' := by rw [\u2190 hk', \u2190 hj', c'.next_eq' (e.rel hjk)]\n    rw [K.extend_d_eq e hj' hk', Iso.inv_hom_id_assoc,\n      \u2190 cancel_mono (K.extendXIso e hk').inv, zero_comp, assoc]\n  \u00b7 simp only [K.shape _ _ hjk, comp_zero, true_iff]\n    rw [K.extend_d_from_eq_zero e j' k' j hj', comp_zero, comp_zero]\n    rw [hk]\n    exact hjk\n\ninclude hi hi' in\nlemma d_comp_eq_zero_iff \u2983W : C\u2984 (\u03c6 : K.X j \u27f6 W) :\n    K.d i j \u226b \u03c6 = 0 \u2194 (K.extend e).d i' j' \u226b (K.extendXIso e hj').hom \u226b \u03c6 = 0 := by\n  by_cases hij : c.Rel i j\n  \u00b7 have hi' : e.f i = i' := by rw [\u2190 hi', \u2190 hj', c'.prev_eq' (e.rel hij)]\n    rw [K.extend_d_eq e hi' hj', assoc, assoc, Iso.inv_hom_id_assoc,\n      \u2190 cancel_epi (K.extendXIso e hi').hom, comp_zero]\n  \u00b7 simp only [K.shape _ _ hij, zero_comp, true_iff]\n    rw [K.extend_d_to_eq_zero e i' j' j hj', zero_comp]\n    rw [hi]\n    exact hij\n\nnamespace leftHomologyData\n\nvariable (cone : KernelFork (K.d j k)) (hcone : IsLimit cone)\n\n/-- The kernel fork of `(K.extend e).d j' k'` that is deduced from a kernel\nfork of `K.d j k `. -/\n@[simp]\nnoncomputable def kernelFork : KernelFork ((K.extend e).d j' k') :=\n  KernelFork.of\u03b9 (cone.\u03b9 \u226b (extendXIso K e hj').inv)\n    (by rw [assoc, \u2190 comp_d_eq_zero_iff K e hj' hk hk' cone.\u03b9, cone.condition])\n\n/-- The limit kernel fork of `(K.extend e).d j' k'` that is deduced from a limit\nkernel fork of `K.d j k `. -/\nnoncomputable def isLimitKernelFork : IsLimit (kernelFork K e hj' hk hk' cone) :=\n  KernelFork.isLimitOfIsLimitOfIff hcone ((K.extend e).d j' k')\n    (extendXIso K e hj').symm (comp_d_eq_zero_iff K e hj' hk hk')\n\nvariable (cocone : CokernelCofork (hcone.lift (KernelFork.of\u03b9 (K.d i j) (K.d_comp_d i j k))))\n  (hcocone : IsColimit cocone)\n\ninclude hi hi' hcone in\n/-- Auxiliary lemma for `lift_d_comp_eq_zero_iff`. -/\nlemma lift_d_comp_eq_zero_iff' \u2983W : C\u2984 (f' : K.X i \u27f6 cone.pt)\n    (hf' : f' \u226b cone.\u03b9 = K.d i j)\n    (f'' : (K.extend e).X i' \u27f6 cone.pt)\n    (hf'' : f'' \u226b cone.\u03b9 \u226b (extendXIso K e hj').inv = (K.extend e).d i' j')\n    (\u03c6 : cone.pt \u27f6 W) :\n    f' \u226b \u03c6 = 0 \u2194 f'' \u226b \u03c6 = 0 := by\n  by_cases hij : c.Rel i j\n  \u00b7 have hi'' : e.f i = i' := by rw [\u2190 hi', \u2190 hj', c'.prev_eq' (e.rel hij)]\n    have : (K.extendXIso e hi'').hom \u226b f' = f'' := by\n      apply Fork.IsLimit.hom_ext hcone\n      rw [assoc, hf', \u2190 cancel_mono (extendXIso K e hj').inv, assoc, assoc, hf'',\n        K.extend_d_eq e hi'' hj']\n    rw [\u2190 cancel_epi (K.extendXIso e hi'').hom, comp_zero, \u2190 this, assoc]\n  \u00b7 have h\u2081 : f' = 0 := by\n      apply Fork.IsLimit.hom_ext hcone\n      simp only [zero_comp, hf', K.shape _ _ hij]\n    have h\u2082 : f'' = 0 := by\n      apply Fork.IsLimit.hom_ext hcone\n      dsimp\n      rw [\u2190 cancel_mono (extendXIso K e hj').inv, assoc, hf'', zero_comp, zero_comp,\n        K.extend_d_to_eq_zero e i' j' j hj']\n      rw [hi]\n      exact hij\n    simp [h\u2081, h\u2082]\n\ninclude hi hi' in\nlemma lift_d_comp_eq_zero_iff \u2983W : C\u2984 (\u03c6 : cone.pt \u27f6 W) :\n    hcone.lift (KernelFork.of\u03b9 (K.d i j) (K.d_comp_d i j k)) \u226b \u03c6 = 0 \u2194\n      ((isLimitKernelFork K e hj' hk hk' cone hcone).lift\n      (KernelFork.of\u03b9 ((K.extend e).d i' j') (d_comp_d _ _ _ _))) \u226b \u03c6 = 0 :=\n  lift_d_comp_eq_zero_iff' K e hj' hi hi' cone hcone _ (hcone.fac _ _) _\n    (IsLimit.fac _ _ WalkingParallelPair.zero) _\n\n/-- Auxiliary definition for `extend.leftHomologyData`. -/\nnoncomputable def cokernelCofork :\n    CokernelCofork ((isLimitKernelFork K e hj' hk hk' cone hcone).lift\n      (KernelFork.of\u03b9 ((K.extend e).d i' j') (d_comp_d _ _ _ _))) :=\n  CokernelCofork.of\u03c0 cocone.\u03c0 (by\n    rw [\u2190 lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' cone hcone]\n    exact cocone.condition)\n\n/-- Auxiliary definition for `extend.leftHomologyData`. -/\nnoncomputable def isColimitCokernelCofork :\n    IsColimit (cokernelCofork K e hj' hi hi' hk hk' cone hcone cocone) :=\n  CokernelCofork.isColimitOfIsColimitOfIff' hcocone _\n    (lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' cone hcone)\n\nend leftHomologyData\n\nopen leftHomologyData in\n/-- The left homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a left homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def leftHomologyData (h : (K.sc' i j k).LeftHomologyData) :\n    ((K.extend e).sc' i' j' k').LeftHomologyData where\n  K := h.K\n  H := h.H\n  i := h.i \u226b (extendXIso K e hj').inv\n  \u03c0 := h.\u03c0\n  wi := by\n    dsimp\n    rw [assoc, \u2190 comp_d_eq_zero_iff K e hj' hk hk']\n    exact h.wi\n  hi := isLimitKernelFork K e hj' hk hk' _ h.hi\n  w\u03c0 := by\n    dsimp\n    rw [\u2190 lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' _ h.hi]\n    exact h.w\u03c0\n  h\u03c0 := isColimitCokernelCofork K e hj' hi hi' hk hk' _ h.hi _ h.h\u03c0\n\nnamespace rightHomologyData\n\nvariable (cocone : CokernelCofork (K.d i j)) (hcocone : IsColimit cocone)\n\n/-- The cokernel cofork of `(K.extend e).d i' j'` that is deduced from a cokernel\ncofork of `K.d i j`. -/\n@[simp]\nnoncomputable def cokernelCofork : CokernelCofork ((K.extend e).d i' j') :=\n  CokernelCofork.of\u03c0 ((extendXIso K e hj').hom \u226b cocone.\u03c0) (by\n    rw [\u2190 d_comp_eq_zero_iff K e hj' hi hi' cocone.\u03c0, cocone.condition])\n\n/-- The colimit cokernel cofork of `(K.extend e).d i' j'` that is deduced from a\ncolimit cokernel cofork of `K.d i j`. -/\nnoncomputable def isColimitCokernelCofork : IsColimit (cokernelCofork K e hj' hi hi' cocone) :=\n  CokernelCofork.isColimitOfIsColimitOfIff hcocone ((K.extend e).d i' j')\n    (extendXIso K e hj') (d_comp_eq_zero_iff K e hj' hi hi')\n\nvariable (cone : KernelFork (hcocone.desc (CokernelCofork.of\u03c0 (K.d j k) (K.d_comp_d i j k))))\n  (hcone : IsLimit cone)\n\ninclude hk hk' hcocone in\nlemma d_comp_desc_eq_zero_iff' \u2983W : C\u2984 (f' : cocone.pt \u27f6 K.X k)\n    (hf' : cocone.\u03c0 \u226b f' = K.d j k)\n    (f'' : cocone.pt \u27f6 (K.extend e).X k')\n    (hf'' : (extendXIso K e hj').hom \u226b cocone.\u03c0 \u226b f'' = (K.extend e).d j' k')\n    (\u03c6 : W \u27f6 cocone.pt) :\n    \u03c6 \u226b f' = 0 \u2194 \u03c6 \u226b f'' = 0 := by\n  by_cases hjk : c.Rel j k\n  \u00b7 have hk'' : e.f k = k' := by rw [\u2190 hk', \u2190 hj', c'.next_eq' (e.rel hjk)]\n    have : f' \u226b (K.extendXIso e hk'').inv = f'' := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      rw [reassoc_of% hf', \u2190 cancel_epi (extendXIso K e hj').hom, hf'',\n        K.extend_d_eq e hj' hk'']\n    rw [\u2190 cancel_mono (K.extendXIso e hk'').inv, zero_comp, assoc, this]\n  \u00b7 have h\u2081 : f' = 0 := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      simp only [hf', comp_zero, K.shape _ _ hjk]\n    have h\u2082 : f'' = 0 := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      rw [\u2190 cancel_epi (extendXIso K e hj').hom, hf'', comp_zero, comp_zero,\n        K.extend_d_from_eq_zero e j' k' j hj']\n      rw [hk]\n      exact hjk\n    simp [h\u2081, h\u2082]\n\ninclude hk hk' in\nlemma d_comp_desc_eq_zero_iff \u2983W : C\u2984 (\u03c6 : W \u27f6 cocone.pt) :\n    \u03c6 \u226b hcocone.desc (CokernelCofork.of\u03c0 (K.d j k) (K.d_comp_d i j k)) = 0 \u2194\n      \u03c6 \u226b ((isColimitCokernelCofork K e hj' hi hi' cocone hcocone).desc\n      (CokernelCofork.of\u03c0 ((K.extend e).d j' k') (d_comp_d _ _ _ _))) = 0 :=\n  d_comp_desc_eq_zero_iff' K e hj' hk hk' cocone hcocone _ (hcocone.fac _ _) _ (by\n    simpa using (isColimitCokernelCofork K e hj' hi hi' cocone hcocone).fac _\n      WalkingParallelPair.one) _\n\n/-- Auxiliary definition for `extend.rightHomologyData`. -/\nnoncomputable def kernelFork :\n    KernelFork ((isColimitCokernelCofork K e hj' hi hi' cocone hcocone).desc\n      (CokernelCofork.of\u03c0 ((K.extend e).d j' k') (d_comp_d _ _ _ _))) :=\n  KernelFork.of\u03b9 cone.\u03b9 (by\n    rw [\u2190 d_comp_desc_eq_zero_iff K e hj' hi hi' hk hk' cocone hcocone]\n    exact cone.condition)\n\n/-- Auxiliary definition for `extend.rightHomologyData`. -/\nnoncomputable def isLimitKernelFork :\n    IsLimit (kernelFork K e hj' hi hi' hk hk' cocone hcocone cone) :=\n  KernelFork.isLimitOfIsLimitOfIff' hcone _\n    (d_comp_desc_eq_zero_iff K e hj' hi hi' hk hk' cocone hcocone)\n\nend rightHomologyData\n\nopen rightHomologyData in\n/-- The right homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a right homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def rightHomologyData (h : (K.sc' i j k).RightHomologyData) :\n    ((K.extend e).sc' i' j' k').RightHomologyData where\n  Q := h.Q\n  H := h.H\n  p := (extendXIso K e hj').hom \u226b h.p\n  \u03b9 := h.\u03b9\n  wp := by\n    dsimp\n    rw [\u2190 d_comp_eq_zero_iff K e hj' hi hi']\n    exact h.wp\n  hp := isColimitCokernelCofork K e hj' hi hi' _ h.hp\n  w\u03b9 := by\n    dsimp\n    rw [\u2190 d_comp_desc_eq_zero_iff K e hj' hi hi' hk hk' _ h.hp]\n    exact h.w\u03b9\n  h\u03b9 := isLimitKernelFork K e hj' hi hi' hk hk' _ h.hp _ h.h\u03b9\n\n/-- Computation of the `g'` field of `extend.rightHomologyData`. -/\nlemma rightHomologyData_g' (h : (K.sc' i j k).RightHomologyData) (hk'' : e.f k = k') :\n    (rightHomologyData K e hj' hi hi' hk hk' h).g' = h.g' \u226b (K.extendXIso e hk'').inv := by\n  rw [\u2190 cancel_epi h.p, \u2190 cancel_epi (extendXIso K e hj').hom]\n  have := (rightHomologyData K e hj' hi hi' hk hk' h).p_g'\n  dsimp at this\n  rw [assoc] at this\n  rw [this, K.extend_d_eq e hj' hk'', h.p_g'_assoc, shortComplexFunctor'_obj_g]\n\n/-- The homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def homologyData (h : (K.sc' i j k).HomologyData) :\n    ((K.extend e).sc' i' j' k').HomologyData where\n  left := leftHomologyData K e hj' hi hi' hk hk' h.left\n  right := rightHomologyData K e hj' hi hi' hk hk' h.right\n  iso := h.iso\n\n/-- The homology data of `(K.extend e).sc j'` that is deduced\nfrom a homology data of `K.sc' i j k`. -/\n@[simps!]\nnoncomputable def homologyData' (h : (K.sc' i j k).HomologyData) :\n    ((K.extend e).sc j').HomologyData :=\n  homologyData K e hj' hi rfl hk rfl h\n\nend HomologyData\n\nlemma hasHomology {j : \u03b9} {j' : \u03b9'} (hj' : e.f j = j') [K.HasHomology j] :\n    (K.extend e).HasHomology j' :=\n  ShortComplex.HasHomology.mk'\n    (homologyData' K e hj' rfl rfl ((K.sc j).homologyData))\n\ninstance (j : \u03b9) [K.HasHomology j] : (K.extend e).HasHomology (e.f j) :=\n  hasHomology K e rfl\n\ninstance [\u2200 j, K.HasHomology j] (j' : \u03b9') : (K.extend e).HasHomology j' := by\n  by_cases h : \u2203 j, e.f j = j'\n  \u00b7 obtain \u27e8j, rfl\u27e9 := h\n    infer_instance\n  \u00b7 have hj := isZero_extend_X K e j' (by tauto)\n    exact ShortComplex.HasHomology.mk'\n      (ShortComplex.HomologyData.ofZeros _ (hj.eq_of_tgt _ _) (hj.eq_of_src _ _))\n\nend extend\n\nlemma extend_exactAt (j' : \u03b9') (hj' : \u2200 j, e.f j \u2260 j') :\n    (K.extend e).ExactAt j' :=\n  exactAt_of_isSupported _ e j' hj'\n\nsection\n\nvariable {j : \u03b9} {j' : \u03b9'} (hj' : e.f j = j') [K.HasHomology j] [L.HasHomology j]\n  [(K.extend e).HasHomology j'] [(L.extend e).HasHomology j']\n\n/-- The isomorphism `(K.extend e).cycles j' \u2245 K.cycles j` when `e.f j = j'`. -/\nnoncomputable def extendCyclesIso :\n    (K.extend e).cycles j' \u2245 K.cycles j :=\n  (extend.homologyData' K e hj' rfl rfl (K.sc j).homologyData).left.cyclesIso \u226a\u226b\n    (K.sc j).homologyData.left.cyclesIso.symm\n\n/-- The isomorphism `(K.extend e).opcycles j' \u2245 K.opcycles j` when `e.f j = j'`. -/\nnoncomputable def extendOpcyclesIso :\n    (K.extend e).opcycles j' \u2245 K.opcycles j :=\n  (extend.homologyData' K e hj' rfl rfl (K.sc j).homologyData).right.opcyclesIso \u226a\u226b\n    (K.sc j).homologyData.right.opcyclesIso.symm\n\n/-- The isomorphism `(K.extend e).homology j' \u2245 K.homology j` when `e.f j = j'`. -/\nnoncomputable def extendHomologyIso :\n    (K.extend e).homology j' \u2245 K.homology j :=\n  (extend.homologyData' K e hj' rfl rfl (K.sc j).homologyData).left.homologyIso \u226a\u226b\n    (K.sc j).homologyData.left.homologyIso.symm\n\ninclude hj' in\nlemma extend_exactAt_iff :\n    (K.extend e).ExactAt j' \u2194 K.ExactAt j := by\n  simp only [HomologicalComplex.exactAt_iff_isZero_homology]\n  exact (K.extendHomologyIso e hj').isZero_iff\n\n@[reassoc (attr := simp)]\nlemma extendCyclesIso_hom_iCycles :\n    (K.extendCyclesIso e hj').hom \u226b K.iCycles j =\n      (K.extend e).iCycles j' \u226b (K.extendXIso e hj').hom := by\n  rw [\u2190 cancel_epi (K.extendCyclesIso e hj').inv, Iso.inv_hom_id_assoc]\n  dsimp [extendCyclesIso, iCycles]\n  rw [assoc, ShortComplex.LeftHomologyData.cyclesIso_inv_comp_iCycles_assoc]\n  dsimp\n  rw [assoc, Iso.inv_hom_id, comp_id,\n    ShortComplex.LeftHomologyData.cyclesIso_hom_comp_i]\n\n@[reassoc (attr := simp)]\nlemma extendCyclesIso_inv_iCycles :\n    (K.extendCyclesIso e hj').inv \u226b (K.extend e).iCycles j' =\n      K.iCycles j \u226b (K.extendXIso e hj').inv := by\n  simp only [\u2190 cancel_epi (K.extendCyclesIso e hj').hom, Iso.hom_inv_id_assoc,\n    extendCyclesIso_hom_iCycles_assoc, Iso.hom_inv_id, comp_id]\n\n@[reassoc (attr := simp)]\nlemma homology\u03c0_extendHomologyIso_hom :\n    (K.extend e).homology\u03c0 j' \u226b (K.extendHomologyIso e hj').hom =\n      (K.extendCyclesIso e hj').hom \u226b K.homology\u03c0 j := by\n  dsimp [extendHomologyIso, homology\u03c0]\n  rw [ShortComplex.LeftHomologyData.homology\u03c0_comp_homologyIso_hom_assoc,\n    \u2190 cancel_mono (K.sc j).homologyData.left.homologyIso.hom,\n    assoc, assoc, assoc, Iso.inv_hom_id, comp_id,\n    ShortComplex.LeftHomologyData.homology\u03c0_comp_homologyIso_hom]\n  dsimp [extendCyclesIso]\n  simp only [assoc, Iso.inv_hom_id_assoc]\n\n", "theoremStatement": "@[reassoc (attr := simp)]\nlemma homology\u03c0_extendHomologyIso_inv :\n    K.homology\u03c0 j \u226b (K.extendHomologyIso e hj').inv =\n      (K.extendCyclesIso e hj').inv \u226b (K.extend e).homology\u03c0 j' ", "theoremName": "HomologicalComplex.homology\u03c0_extendHomologyIso_inv", "fileCreated": {"commit": "9bdc1af76cf75d960f42c29f1c09917785066c8b", "date": "2024-11-30"}, "theoremCreated": {"commit": "b07a551a1451cbf8615f4e2a6c47052affadbae4", "date": "2025-01-17"}, "file": "mathlib/Mathlib/Algebra/Homology/Embedding/ExtendHomology.lean", "module": "Mathlib.Algebra.Homology.Embedding.ExtendHomology", "jsonFile": "Mathlib.Algebra.Homology.Embedding.ExtendHomology.jsonl", "positionMetadata": {"lineInFile": 352, "tokenPositionInFile": 14126, "theoremPositionInFile": 25}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 31, "numPremises": 40}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp only [\u2190 cancel_mono (K.extendHomologyIso e hj').hom,\n    assoc, Iso.inv_hom_id, comp_id, homology\u03c0_extendHomologyIso_hom, Iso.inv_hom_id_assoc]", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 156}}
{"srcContext": "/-\nCopyright (c) 2024 Ya\u00ebl Dillies. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Ya\u00ebl Dillies, Bhavik Mehta\n-/\nimport Mathlib.Algebra.Group.Subgroup.Pointwise\nimport Mathlib.Combinatorics.Additive.CovBySMul\nimport Mathlib.Combinatorics.Additive.RuzsaCovering\nimport Mathlib.Combinatorics.Additive.SmallTripling\n\n/-!\n# Approximate subgroups\n\nThis file defines approximate subgroups of a group, namely symmetric sets `A` such that `A * A` can\nbe covered by a small number of translates of `A`.\n\n## Main results\n\nApproximate subgroups are a central concept in additive combinatorics, as a natural weakening and\nflexible substitute of genuine subgroups. As such, they share numerous properties with subgroups:\n* `IsApproximateSubgroup.image`: Group homomorphisms send approximate subgroups to approximate\n  subgroups\n* `IsApproximateSubgroup.pow_inter_pow`: The intersection of (non-trivial powers of) two approximate\n  subgroups is an approximate subgroup. Warning: The intersection of two approximate subgroups isn't\n  an approximate subgroup in general.\n\nApproximate subgroups are close qualitatively and quantitatively to other concepts in additive\ncombinatorics:\n* `IsApproximateSubgroup.card_pow_le`: An approximate subgroup has small powers.\n* `IsApproximateSubgroup.of_small_tripling`: A set of small tripling can be made an approximate\n  subgroup by squaring.\n\nIt can be readily confirmed that approximate subgroups are a weakening of subgroups:\n* `isApproximateSubgroup_one`: A 1-approximate subgroup is the same thing as a subgroup.\n-/\n\nopen scoped Finset Pointwise\n\nvariable {G : Type*} [Group G] {A B : Set G} {K L : \u211d} {m n : \u2115}\n\n/--\nAn approximate subgroup in a group is a symmetric set `A` containing the identity and such that\n`A + A` can be covered by a small number of translates of `A`.\n\nIn practice, we will take `K` fixed and `A` large but finite.\n-/\nstructure IsApproximateAddSubgroup {G : Type*} [AddGroup G] (K : \u211d) (A : Set G) : Prop where\n  zero_mem : 0 \u2208 A\n  neg_eq_self : -A = A\n  two_nsmul_covByVAdd : CovByVAdd G K (2 \u2022 A) A\n\n/--\nAn approximate subgroup in a group is a symmetric set `A` containing the identity and such that\n`A * A` can be covered by a small number of translates of `A`.\n\nIn practice, we will take `K` fixed and `A` large but finite.\n-/\n@[to_additive]\nstructure IsApproximateSubgroup (K : \u211d) (A : Set G) : Prop where\n  one_mem : 1 \u2208 A\n  inv_eq_self : A\u207b\u00b9 = A\n  sq_covBySMul : CovBySMul G K (A ^ 2) A\n\nnamespace IsApproximateSubgroup\n\n@[to_additive] lemma nonempty (hA : IsApproximateSubgroup K A) : A.Nonempty := \u27e81, hA.one_mem\u27e9\n\n@[to_additive one_le]\nlemma one_le (hA : IsApproximateSubgroup K A) : 1 \u2264 K := by\n  obtain \u27e8F, hF, hSF\u27e9 := hA.sq_covBySMul\n  have hF\u2080 : F \u2260 \u2205 := by rintro rfl; simp [hA.nonempty.pow.ne_empty] at hSF\n  exact hF.trans' <| by simpa [Finset.nonempty_iff_ne_empty]\n\n@[to_additive]\nlemma mono (hKL : K \u2264 L) (hA : IsApproximateSubgroup K A) : IsApproximateSubgroup L A where\n  one_mem := hA.one_mem\n  inv_eq_self := hA.inv_eq_self\n  sq_covBySMul := hA.sq_covBySMul.mono hKL\n\n@[to_additive]\nlemma card_pow_le [DecidableEq G] {A : Finset G} (hA : IsApproximateSubgroup K (A : Set G)) :\n    \u2200 {n}, #(A ^ n) \u2264 K ^ (n - 1) * #A\n  | 0 => by simpa using hA.nonempty\n  | 1 => by simp\n  | n + 2 => by\n    obtain \u27e8F, hF, hSF\u27e9 := hA.sq_covBySMul\n    calc\n      (#(A ^ (n + 2)) : \u211d) \u2264 #(F ^ (n + 1) * A) := by\n        gcongr; exact mod_cast Set.pow_subset_pow_mul_of_sq_subset_mul hSF (by omega)\n      _ \u2264 #(F ^ (n + 1)) * #A := mod_cast Finset.card_mul_le\n      _ \u2264 #F ^ (n + 1) * #A := by gcongr; exact mod_cast Finset.card_pow_le\n      _ \u2264 K ^ (n + 1) * #A := by gcongr\n\n@[to_additive]\nlemma card_mul_self_le [DecidableEq G] {A : Finset G} (hA : IsApproximateSubgroup K (A : Set G)) :\n    #(A * A) \u2264 K * #A := by simpa [sq] using hA.card_pow_le (n := 2)\n\n@[to_additive]\nlemma image {F H : Type*} [Group H] [FunLike F G H] [MonoidHomClass F G H] (f : F)\n    (hA : IsApproximateSubgroup K A) : IsApproximateSubgroup K (f '' A) where\n  one_mem := \u27e81, hA.one_mem, map_one _\u27e9\n  inv_eq_self := by simp [\u2190 Set.image_inv, hA.inv_eq_self]\n  sq_covBySMul := by\n    classical\n    obtain \u27e8F, hF, hAF\u27e9 := hA.sq_covBySMul\n    refine \u27e8F.image f, ?_, ?_\u27e9\n    \u00b7 calc\n        (#(F.image f) : \u211d) \u2264 #F := mod_cast F.card_image_le\n        _ \u2264 K := hF\n    \u00b7 simp only [\u2190 Set.image_pow, Finset.coe_image, \u2190 Set.image_mul, smul_eq_mul] at hAF \u22a2\n      gcongr\n\n@[to_additive]\nlemma subgroup {S : Type*} [SetLike S G] [SubgroupClass S G] {H : S} :\n    IsApproximateSubgroup 1 (H : Set G) where\n  one_mem := OneMemClass.one_mem H\n  inv_eq_self := inv_coe_set\n  sq_covBySMul := \u27e8{1}, by simp\u27e9\n\nopen Finset in\n@[to_additive]\nlemma of_small_tripling [DecidableEq G] {A : Finset G} (hA\u2081 : 1 \u2208 A) (hAsymm : A\u207b\u00b9 = A)\n    (hA : #(A ^ 3) \u2264 K * #A) : IsApproximateSubgroup (K ^ 3) (A ^ 2 : Set G) where\n  one_mem := by rw [sq, \u2190 one_mul 1]; exact Set.mul_mem_mul hA\u2081 hA\u2081\n  inv_eq_self := by simp [\u2190 inv_pow, hAsymm, \u2190 coe_inv]\n  sq_covBySMul := by\n    replace hA := calc (#(A ^ 4 * A) : \u211d)\n      _ = #(A ^ 5) := by rw [\u2190 pow_succ]\n      _ \u2264 K ^ 3 * #A := small_pow_of_small_tripling (by omega) hA hAsymm\n    have hA\u2080 : A.Nonempty := \u27e81, hA\u2081\u27e9\n    obtain \u27e8F, -, hF, hAF\u27e9 := ruzsa_covering_mul hA\u2080 hA\n    exact \u27e8F, hF, by norm_cast; simpa [div_eq_mul_inv, pow_succ, mul_assoc, hAsymm] using hAF\u27e9\n\nopen Set in\n", "theoremStatement": "@[to_additive]\nlemma pow_inter_pow_covBySMul_sq_inter_sq\n    (hA : IsApproximateSubgroup K A) (hB : IsApproximateSubgroup L B) (hm : 2 \u2264 m) (hn : 2 \u2264 n) :\n    CovBySMul G (K ^ (m - 1) * L ^ (n - 1)) (A ^ m \u2229 B ^ n) (A ^ 2 \u2229 B ^ 2) ", "theoremName": "IsApproximateSubgroup.pow_inter_pow_covBySMul_sq_inter_sq", "fileCreated": {"commit": "781c75b11cc46547f0f22ec4d138080a85b659ba", "date": "2025-01-11"}, "theoremCreated": {"commit": "781c75b11cc46547f0f22ec4d138080a85b659ba", "date": "2025-01-11"}, "file": "mathlib/Mathlib/Combinatorics/Additive/ApproximateSubgroup.lean", "module": "Mathlib.Combinatorics.Additive.ApproximateSubgroup", "jsonFile": "Mathlib.Combinatorics.Additive.ApproximateSubgroup.jsonl", "positionMetadata": {"lineInFile": 135, "tokenPositionInFile": 5381, "theoremPositionInFile": 3}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 128, "numPremises": 214}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  classical\n  obtain \u27e8F\u2081, hF\u2081, hAF\u2081\u27e9 := hA.sq_covBySMul\n  obtain \u27e8F\u2082, hF\u2082, hBF\u2082\u27e9 := hB.sq_covBySMul\n  have := hA.one_le\n  choose f hf using exists_smul_inter_smul_subset_smul_inv_mul_inter_inv_mul A B\n  refine \u27e8.image\u2082 f (F\u2081 ^ (m - 1)) (F\u2082 ^ (n - 1)), ?_, ?_\u27e9\n  \u00b7 calc\n      (#(.image\u2082 f (F\u2081 ^ (m - 1)) (F\u2082 ^ (n - 1))) : \u211d)\n      _ \u2264 #(F\u2081 ^ (m - 1)) * #(F\u2082 ^ (n - 1)) := mod_cast Finset.card_image\u2082_le ..\n      _ \u2264 #F\u2081 ^ (m - 1) * #F\u2082 ^ (n - 1) := by gcongr <;> exact mod_cast Finset.card_pow_le\n      _ \u2264 K ^ (m - 1) * L ^ (n - 1) := by gcongr\n  \u00b7 calc\n      A ^ m \u2229 B ^ n \u2286 (F\u2081 ^ (m - 1) * A) \u2229 (F\u2082 ^ (n - 1) * B) := by\n        gcongr <;> apply pow_subset_pow_mul_of_sq_subset_mul <;> norm_cast <;> omega\n      _ = \u22c3 (a \u2208 F\u2081 ^ (m - 1)) (b \u2208 F\u2082 ^ (n - 1)), a \u2022 A \u2229 b \u2022 B := by\n        simp_rw [\u2190 smul_eq_mul, \u2190 iUnion_smul_set, iUnion\u2082_inter_iUnion\u2082]; norm_cast\n      _ \u2286 \u22c3 (a \u2208 F\u2081 ^ (m - 1)) (b \u2208 F\u2082 ^ (n - 1)), f a b \u2022 (A\u207b\u00b9 * A \u2229 (B\u207b\u00b9 * B)) := by\n        gcongr; exact hf ..\n      _ = (Finset.image\u2082 f (F\u2081 ^ (m - 1)) (F\u2082 ^ (n - 1))) * (A ^ 2 \u2229 B ^ 2) := by\n        simp_rw [hA.inv_eq_self, hB.inv_eq_self, \u2190 sq]\n        rw [Finset.coe_image\u2082, \u2190 smul_eq_mul, \u2190 iUnion_smul_set, biUnion_image2]\n        simp_rw [Finset.mem_coe]", "proofType": "tactic", "proofLengthLines": 22, "proofLengthTokens": 1234}}
{"srcContext": "/-\nCopyright (c) 2018 Robert Y. Lewis. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Robert Y. Lewis, Mario Carneiro, Johan Commelin\n-/\nimport Mathlib.NumberTheory.Padics.PadicNumbers\nimport Mathlib.RingTheory.DiscreteValuationRing.Basic\n\n/-!\n# p-adic integers\n\nThis file defines the `p`-adic integers `\u2124_[p]` as the subtype of `\u211a_[p]` with norm `\u2264 1`.\nWe show that `\u2124_[p]`\n* is complete,\n* is nonarchimedean,\n* is a normed ring,\n* is a local ring, and\n* is a discrete valuation ring.\n\nThe relation between `\u2124_[p]` and `ZMod p` is established in another file.\n\n## Important definitions\n\n* `PadicInt` : the type of `p`-adic integers\n\n## Notation\n\nWe introduce the notation `\u2124_[p]` for the `p`-adic integers.\n\n## Implementation notes\n\nMuch, but not all, of this file assumes that `p` is prime. This assumption is inferred automatically\nby taking `[Fact p.Prime]` as a type class argument.\n\nCoercions into `\u2124_[p]` are set up to work with the `norm_cast` tactic.\n\n## References\n\n* [F. Q. Gouv\u00eaa, *p-adic numbers*][gouvea1997]\n* [R. Y. Lewis, *A formal proof of Hensel's lemma over the p-adic integers*][lewis2019]\n* <https://en.wikipedia.org/wiki/P-adic_number>\n\n## Tags\n\np-adic, p adic, padic, p-adic integer\n-/\n\n\nopen Padic Metric IsLocalRing\n\nnoncomputable section\n\nvariable (p : \u2115) [hp : Fact p.Prime]\n\n/-- The `p`-adic integers `\u2124_[p]` are the `p`-adic numbers with norm `\u2264 1`. -/\ndef PadicInt : Type := {x : \u211a_[p] // \u2016x\u2016 \u2264 1}\n\n/-- The ring of `p`-adic integers. -/\nnotation \"\u2124_[\" p \"]\" => PadicInt p\n\nnamespace PadicInt\nvariable {p} {x y : \u2124_[p]}\n\n/-! ### Ring structure and coercion to `\u211a_[p]` -/\n\ninstance : Coe \u2124_[p] \u211a_[p] :=\n  \u27e8Subtype.val\u27e9\n\ntheorem ext {x y : \u2124_[p]} : (x : \u211a_[p]) = y \u2192 x = y :=\n  Subtype.ext\n\nvariable (p)\n\n/-- The `p`-adic integers as a subring of `\u211a_[p]`. -/\ndef subring : Subring \u211a_[p] where\n  carrier := { x : \u211a_[p] | \u2016x\u2016 \u2264 1 }\n  zero_mem' := by norm_num\n  one_mem' := by norm_num\n  add_mem' hx hy := (padicNormE.nonarchimedean _ _).trans <| max_le_iff.2 \u27e8hx, hy\u27e9\n  mul_mem' hx hy := (padicNormE.mul _ _).trans_le <| mul_le_one\u2080 hx (norm_nonneg _) hy\n  neg_mem' hx := (norm_neg _).trans_le hx\n\n@[simp]\ntheorem mem_subring_iff {x : \u211a_[p]} : x \u2208 subring p \u2194 \u2016x\u2016 \u2264 1 := Iff.rfl\n\nvariable {p}\n\n/-- Addition on `\u2124_[p]` is inherited from `\u211a_[p]`. -/\ninstance : Add \u2124_[p] := (by infer_instance : Add (subring p))\n\n/-- Multiplication on `\u2124_[p]` is inherited from `\u211a_[p]`. -/\ninstance : Mul \u2124_[p] := (by infer_instance : Mul (subring p))\n\n/-- Negation on `\u2124_[p]` is inherited from `\u211a_[p]`. -/\ninstance : Neg \u2124_[p] := (by infer_instance : Neg (subring p))\n\n/-- Subtraction on `\u2124_[p]` is inherited from `\u211a_[p]`. -/\ninstance : Sub \u2124_[p] := (by infer_instance : Sub (subring p))\n\n/-- Zero on `\u2124_[p]` is inherited from `\u211a_[p]`. -/\ninstance : Zero \u2124_[p] := (by infer_instance : Zero (subring p))\n\ninstance : Inhabited \u2124_[p] := \u27e80\u27e9\n\n/-- One on `\u2124_[p]` is inherited from `\u211a_[p]`. -/\ninstance : One \u2124_[p] := \u27e8\u27e81, by norm_num\u27e9\u27e9\n\n@[simp]\ntheorem mk_zero {h} : (\u27e80, h\u27e9 : \u2124_[p]) = (0 : \u2124_[p]) := rfl\n\n@[simp, norm_cast]\ntheorem coe_add (z1 z2 : \u2124_[p]) : ((z1 + z2 : \u2124_[p]) : \u211a_[p]) = z1 + z2 := rfl\n\n@[simp, norm_cast]\ntheorem coe_mul (z1 z2 : \u2124_[p]) : ((z1 * z2 : \u2124_[p]) : \u211a_[p]) = z1 * z2 := rfl\n\n@[simp, norm_cast]\ntheorem coe_neg (z1 : \u2124_[p]) : ((-z1 : \u2124_[p]) : \u211a_[p]) = -z1 := rfl\n\n@[simp, norm_cast]\ntheorem coe_sub (z1 z2 : \u2124_[p]) : ((z1 - z2 : \u2124_[p]) : \u211a_[p]) = z1 - z2 := rfl\n\n@[simp, norm_cast]\ntheorem coe_one : ((1 : \u2124_[p]) : \u211a_[p]) = 1 := rfl\n\n@[simp, norm_cast]\ntheorem coe_zero : ((0 : \u2124_[p]) : \u211a_[p]) = 0 := rfl\n\n@[simp] lemma coe_eq_zero : (x : \u211a_[p]) = 0 \u2194 x = 0 := by rw [\u2190 coe_zero, Subtype.coe_inj]\n\nlemma coe_ne_zero : (x : \u211a_[p]) \u2260 0 \u2194 x \u2260 0 := coe_eq_zero.not\n\ninstance : AddCommGroup \u2124_[p] := (by infer_instance : AddCommGroup (subring p))\n\ninstance instCommRing : CommRing \u2124_[p] := (by infer_instance : CommRing (subring p))\n\n@[simp, norm_cast]\ntheorem coe_natCast (n : \u2115) : ((n : \u2124_[p]) : \u211a_[p]) = n := rfl\n\n@[simp, norm_cast]\ntheorem coe_intCast (z : \u2124) : ((z : \u2124_[p]) : \u211a_[p]) = z := rfl\n\n/-- The coercion from `\u2124_[p]` to `\u211a_[p]` as a ring homomorphism. -/\ndef Coe.ringHom : \u2124_[p] \u2192+* \u211a_[p] := (subring p).subtype\n\n@[simp, norm_cast]\ntheorem coe_pow (x : \u2124_[p]) (n : \u2115) : (\u2191(x ^ n) : \u211a_[p]) = (\u2191x : \u211a_[p]) ^ n := rfl\n\ntheorem mk_coe (k : \u2124_[p]) : (\u27e8k, k.2\u27e9 : \u2124_[p]) = k := by simp\n\n/-- The inverse of a `p`-adic integer with norm equal to `1` is also a `p`-adic integer.\nOtherwise, the inverse is defined to be `0`. -/\ndef inv : \u2124_[p] \u2192 \u2124_[p]\n  | \u27e8k, _\u27e9 => if h : \u2016k\u2016 = 1 then \u27e8k\u207b\u00b9, by simp [h]\u27e9 else 0\n\ninstance : CharZero \u2124_[p] where\n  cast_injective m n h :=\n    Nat.cast_injective (R := \u211a_[p]) (by rw [Subtype.ext_iff] at h; norm_cast at h)\n\n@[norm_cast]\ntheorem intCast_eq (z1 z2 : \u2124) : (z1 : \u2124_[p]) = z2 \u2194 z1 = z2 := by simp\n\n/-- A sequence of integers that is Cauchy with respect to the `p`-adic norm converges to a `p`-adic\ninteger. -/\ndef ofIntSeq (seq : \u2115 \u2192 \u2124) (h : IsCauSeq (padicNorm p) fun n => seq n) : \u2124_[p] :=\n  \u27e8\u27e6\u27e8_, h\u27e9\u27e7,\n    show \u2191(PadicSeq.norm _) \u2264 (1 : \u211d) by\n      rw [PadicSeq.norm]\n      split_ifs with hne <;> norm_cast\n      apply padicNorm.of_int\u27e9\n\n/-! ### Instances\n\nWe now show that `\u2124_[p]` is a\n* complete metric space\n* normed ring\n* integral domain\n-/\n\nvariable (p)\n\ninstance : MetricSpace \u2124_[p] := Subtype.metricSpace\n\ninstance : IsUltrametricDist \u2124_[p] := IsUltrametricDist.subtype _\n\ninstance completeSpace : CompleteSpace \u2124_[p] :=\n  have : IsClosed { x : \u211a_[p] | \u2016x\u2016 \u2264 1 } := isClosed_le continuous_norm continuous_const\n  this.completeSpace_coe\n\ninstance : Norm \u2124_[p] := \u27e8fun z => \u2016(z : \u211a_[p])\u2016\u27e9\n\nvariable {p}\n\ntheorem norm_def {z : \u2124_[p]} : \u2016z\u2016 = \u2016(z : \u211a_[p])\u2016 := rfl\n\nvariable (p)\n\ninstance : NormedCommRing \u2124_[p] :=\n  { PadicInt.instCommRing with\n    dist_eq := fun \u27e8_, _\u27e9 \u27e8_, _\u27e9 => rfl\n    norm_mul := by simp [norm_def]\n    norm := norm }\n\ninstance : NormOneClass \u2124_[p] :=\n  \u27e8norm_def.trans norm_one\u27e9\n\ninstance isAbsoluteValue : IsAbsoluteValue fun z : \u2124_[p] => \u2016z\u2016 where\n  abv_nonneg' := norm_nonneg\n  abv_eq_zero' := by simp [norm_eq_zero]\n  abv_add' := fun \u27e8_, _\u27e9 \u27e8_, _\u27e9 => norm_add_le _ _\n  abv_mul' _ _ := by simp only [norm_def, padicNormE.mul, PadicInt.coe_mul]\n\nvariable {p}\n\ninstance : IsDomain \u2124_[p] := Function.Injective.isDomain (subring p).subtype Subtype.coe_injective\n\n/-! ### Norm -/\n\ntheorem norm_le_one (z : \u2124_[p]) : \u2016z\u2016 \u2264 1 := z.2\n\n@[simp]\ntheorem norm_mul (z1 z2 : \u2124_[p]) : \u2016z1 * z2\u2016 = \u2016z1\u2016 * \u2016z2\u2016 := by simp [norm_def]\n\n@[simp]\ntheorem norm_pow (z : \u2124_[p]) : \u2200 n : \u2115, \u2016z ^ n\u2016 = \u2016z\u2016 ^ n\n  | 0 => by simp\n  | k + 1 => by\n    rw [pow_succ, pow_succ, norm_mul]\n    congr\n    apply norm_pow\n\ntheorem nonarchimedean (q r : \u2124_[p]) : \u2016q + r\u2016 \u2264 max \u2016q\u2016 \u2016r\u2016 := padicNormE.nonarchimedean _ _\n\ntheorem norm_add_eq_max_of_ne {q r : \u2124_[p]} : \u2016q\u2016 \u2260 \u2016r\u2016 \u2192 \u2016q + r\u2016 = max \u2016q\u2016 \u2016r\u2016 :=\n  padicNormE.add_eq_max_of_ne\n\ntheorem norm_eq_of_norm_add_lt_right {z1 z2 : \u2124_[p]} (h : \u2016z1 + z2\u2016 < \u2016z2\u2016) : \u2016z1\u2016 = \u2016z2\u2016 :=\n  by_contra fun hne =>\n    not_lt_of_ge (by rw [norm_add_eq_max_of_ne hne]; apply le_max_right) h\n\ntheorem norm_eq_of_norm_add_lt_left {z1 z2 : \u2124_[p]} (h : \u2016z1 + z2\u2016 < \u2016z1\u2016) : \u2016z1\u2016 = \u2016z2\u2016 :=\n  by_contra fun hne =>\n    not_lt_of_ge (by rw [norm_add_eq_max_of_ne hne]; apply le_max_left) h\n\n@[simp]\ntheorem padic_norm_e_of_padicInt (z : \u2124_[p]) : \u2016(z : \u211a_[p])\u2016 = \u2016z\u2016 := by simp [norm_def]\n\ntheorem norm_intCast_eq_padic_norm (z : \u2124) : \u2016(z : \u2124_[p])\u2016 = \u2016(z : \u211a_[p])\u2016 := by simp [norm_def]\n\n@[simp]\ntheorem norm_eq_padic_norm {q : \u211a_[p]} (hq : \u2016q\u2016 \u2264 1) : @norm \u2124_[p] _ \u27e8q, hq\u27e9 = \u2016q\u2016 := rfl\n\n@[simp]\ntheorem norm_p : \u2016(p : \u2124_[p])\u2016 = (p : \u211d)\u207b\u00b9 := padicNormE.norm_p\n\ntheorem norm_p_pow (n : \u2115) : \u2016(p : \u2124_[p]) ^ n\u2016 = (p : \u211d) ^ (-n : \u2124) := by simp\n\nprivate def cauSeq_to_rat_cauSeq (f : CauSeq \u2124_[p] norm) : CauSeq \u211a_[p] fun a => \u2016a\u2016 :=\n  \u27e8fun n => f n, fun _ h\u03b5 => by simpa [norm, norm_def] using f.cauchy h\u03b5\u27e9\n\nvariable (p)\n\ninstance complete : CauSeq.IsComplete \u2124_[p] norm :=\n  \u27e8fun f =>\n    have hqn : \u2016CauSeq.lim (cauSeq_to_rat_cauSeq f)\u2016 \u2264 1 :=\n      padicNormE_lim_le zero_lt_one fun _ => norm_le_one _\n    \u27e8\u27e8_, hqn\u27e9, fun \u03b5 => by\n      simpa [norm, norm_def] using CauSeq.equiv_lim (cauSeq_to_rat_cauSeq f) \u03b5\u27e9\u27e9\n\ntheorem exists_pow_neg_lt {\u03b5 : \u211d} (h\u03b5 : 0 < \u03b5) : \u2203 k : \u2115, (p : \u211d) ^ (-(k : \u2124)) < \u03b5 := by\n  obtain \u27e8k, hk\u27e9 := exists_nat_gt \u03b5\u207b\u00b9\n  use k\n  rw [\u2190 inv_lt_inv\u2080 h\u03b5 (zpow_pos _ _)]\n  \u00b7 rw [zpow_neg, inv_inv, zpow_natCast]\n    apply lt_of_lt_of_le hk\n    norm_cast\n    apply le_of_lt\n    convert Nat.lt_pow_self _ using 1\n    exact hp.1.one_lt\n  \u00b7 exact mod_cast hp.1.pos\n\ntheorem exists_pow_neg_lt_rat {\u03b5 : \u211a} (h\u03b5 : 0 < \u03b5) : \u2203 k : \u2115, (p : \u211a) ^ (-(k : \u2124)) < \u03b5 := by\n  obtain \u27e8k, hk\u27e9 := @exists_pow_neg_lt p _ \u03b5 (mod_cast h\u03b5)\n  use k\n  rw [show (p : \u211d) = (p : \u211a) by simp] at hk\n  exact mod_cast hk\n\nvariable {p}\n\ntheorem norm_int_lt_one_iff_dvd (k : \u2124) : \u2016(k : \u2124_[p])\u2016 < 1 \u2194 (p : \u2124) \u2223 k :=\n  suffices \u2016(k : \u211a_[p])\u2016 < 1 \u2194 \u2191p \u2223 k by rwa [norm_intCast_eq_padic_norm]\n  padicNormE.norm_int_lt_one_iff_dvd k\n\ntheorem norm_int_le_pow_iff_dvd {k : \u2124} {n : \u2115} :\n    \u2016(k : \u2124_[p])\u2016 \u2264 (p : \u211d) ^ (-n : \u2124) \u2194 (p ^ n : \u2124) \u2223 k :=\n  suffices \u2016(k : \u211a_[p])\u2016 \u2264 (p : \u211d) ^ (-n : \u2124) \u2194 (p ^ n : \u2124) \u2223 k by\n    simpa [norm_intCast_eq_padic_norm]\n  padicNormE.norm_int_le_pow_iff_dvd _ _\n\n/-! ### Valuation on `\u2124_[p]` -/\n\nlemma valuation_coe_nonneg : 0 \u2264 (x : \u211a_[p]).valuation := by\n  obtain rfl | hx := eq_or_ne x 0\n  \u00b7 simp\n  have := x.2\n  rwa [Padic.norm_eq_zpow_neg_valuation <| coe_ne_zero.2 hx, zpow_le_one_iff_right\u2080, neg_nonpos]\n    at this\n  exact mod_cast hp.out.one_lt\n\n/-- `PadicInt.valuation` lifts the `p`-adic valuation on `\u211a` to `\u2124_[p]`. -/\ndef valuation (x : \u2124_[p]) : \u2115 := (x : \u211a_[p]).valuation.toNat\n\n@[simp, norm_cast] lemma valuation_coe (x : \u2124_[p]) : (x : \u211a_[p]).valuation = x.valuation := by\n  simp [valuation, valuation_coe_nonneg]\n\n@[simp] lemma valuation_zero : valuation (0 : \u2124_[p]) = 0 := by simp [valuation]\n@[simp] lemma valuation_one : valuation (1 : \u2124_[p]) = 0 := by simp [valuation]\n@[simp] lemma valuation_p : valuation (p : \u2124_[p]) = 1 := by simp [valuation]\n\nlemma le_valuation_add (hxy : x + y \u2260 0) : min x.valuation y.valuation \u2264 (x + y).valuation := by\n  zify; simpa [\u2190 valuation_coe] using Padic.le_valuation_add <| coe_ne_zero.2 hxy\n\n@[simp] lemma valuation_mul (hx : x \u2260 0) (hy : y \u2260 0) :\n    (x * y).valuation = x.valuation + y.valuation := by\n  zify; simp [\u2190 valuation_coe, Padic.valuation_mul (coe_ne_zero.2 hx) (coe_ne_zero.2 hy)]\n\n", "theoremStatement": "@[simp]\nlemma valuation_pow (x : \u2124_[p]) (n : \u2115) : (x ^ n).valuation = n * x.valuation ", "theoremName": "PadicInt.valuation_pow", "fileCreated": {"commit": "63d78da6a358d613bff5f34c62ed9481dbbc52c2", "date": "2023-05-25"}, "theoremCreated": {"commit": "1c080cc45939aaef448022267a6965a19e53c7bf", "date": "2024-12-21"}, "file": "mathlib/Mathlib/NumberTheory/Padics/PadicIntegers.lean", "module": "Mathlib.NumberTheory.Padics.PadicIntegers", "jsonFile": "Mathlib.NumberTheory.Padics.PadicIntegers.jsonl", "positionMetadata": {"lineInFile": 327, "tokenPositionInFile": 10386, "theoremPositionInFile": 45}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 30, "numPremises": 54}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  zify; simp [\u2190 valuation_coe]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 36}}
{"srcContext": "/-\nCopyright (c) 2018 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes, Abhimanyu Pallavi Sudhir, Jean Lo, Calle S\u00f6nne, S\u00e9bastien Gou\u00ebzel,\n  R\u00e9my Degenne\n-/\nimport Mathlib.Analysis.SpecialFunctions.Pow.Continuity\nimport Mathlib.Analysis.SpecialFunctions.Complex.LogDeriv\nimport Mathlib.Analysis.Calculus.FDeriv.Extend\nimport Mathlib.Analysis.Calculus.Deriv.Prod\nimport Mathlib.Analysis.SpecialFunctions.Log.Deriv\nimport Mathlib.Analysis.SpecialFunctions.Trigonometric.Deriv\n\n/-!\n# Derivatives of power function on `\u2102`, `\u211d`, `\u211d\u22650`, and `\u211d\u22650\u221e`\n\nWe also prove differentiability and provide derivatives for the power functions `x ^ y`.\n-/\n\n\nnoncomputable section\n\nopen scoped Real Topology NNReal ENNReal\nopen Filter\n\nnamespace Complex\n\ntheorem hasStrictFDerivAt_cpow {p : \u2102 \u00d7 \u2102} (hp : p.1 \u2208 slitPlane) :\n    HasStrictFDerivAt (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2)\n      ((p.2 * p.1 ^ (p.2 - 1)) \u2022 ContinuousLinearMap.fst \u2102 \u2102 \u2102 +\n        (p.1 ^ p.2 * log p.1) \u2022 ContinuousLinearMap.snd \u2102 \u2102 \u2102) p := by\n  have A : p.1 \u2260 0 := slitPlane_ne_zero hp\n  have : (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2) =\u1da0[\ud835\udcdd p] fun x => exp (log x.1 * x.2) :=\n    ((isOpen_ne.preimage continuous_fst).eventually_mem A).mono fun p hp =>\n      cpow_def_of_ne_zero hp _\n  rw [cpow_sub _ _ A, cpow_one, mul_div_left_comm, mul_smul, mul_smul]\n  refine HasStrictFDerivAt.congr_of_eventuallyEq ?_ this.symm\n  simpa only [cpow_def_of_ne_zero A, div_eq_mul_inv, mul_smul, add_comm, smul_add] using\n    ((hasStrictFDerivAt_fst.clog hp).mul hasStrictFDerivAt_snd).cexp\n\ntheorem hasStrictFDerivAt_cpow' {x y : \u2102} (hp : x \u2208 slitPlane) :\n    HasStrictFDerivAt (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2)\n      ((y * x ^ (y - 1)) \u2022 ContinuousLinearMap.fst \u2102 \u2102 \u2102 +\n        (x ^ y * log x) \u2022 ContinuousLinearMap.snd \u2102 \u2102 \u2102) (x, y) :=\n  @hasStrictFDerivAt_cpow (x, y) hp\n\ntheorem hasStrictDerivAt_const_cpow {x y : \u2102} (h : x \u2260 0 \u2228 y \u2260 0) :\n    HasStrictDerivAt (fun y => x ^ y) (x ^ y * log x) y := by\n  rcases em (x = 0) with (rfl | hx)\n  \u00b7 replace h := h.neg_resolve_left rfl\n    rw [log_zero, mul_zero]\n    refine (hasStrictDerivAt_const y 0).congr_of_eventuallyEq ?_\n    exact (isOpen_ne.eventually_mem h).mono fun y hy => (zero_cpow hy).symm\n  \u00b7 simpa only [cpow_def_of_ne_zero hx, mul_one] using\n      ((hasStrictDerivAt_id y).const_mul (log x)).cexp\n\ntheorem hasFDerivAt_cpow {p : \u2102 \u00d7 \u2102} (hp : p.1 \u2208 slitPlane) :\n    HasFDerivAt (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2)\n      ((p.2 * p.1 ^ (p.2 - 1)) \u2022 ContinuousLinearMap.fst \u2102 \u2102 \u2102 +\n        (p.1 ^ p.2 * log p.1) \u2022 ContinuousLinearMap.snd \u2102 \u2102 \u2102) p :=\n  (hasStrictFDerivAt_cpow hp).hasFDerivAt\n\nend Complex\n\nsection fderiv\n\nopen Complex\n\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f g : E \u2192 \u2102} {f' g' : E \u2192L[\u2102] \u2102}\n  {x : E} {s : Set E} {c : \u2102}\n\ntheorem HasStrictFDerivAt.cpow (hf : HasStrictFDerivAt f f' x) (hg : HasStrictFDerivAt g g' x)\n    (h0 : f x \u2208 slitPlane) : HasStrictFDerivAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) \u2022 f' + (f x ^ g x * Complex.log (f x)) \u2022 g') x := by\n  convert (@hasStrictFDerivAt_cpow ((fun x => (f x, g x)) x) h0).comp x (hf.prod hg)\n\ntheorem HasStrictFDerivAt.const_cpow (hf : HasStrictFDerivAt f f' x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasStrictFDerivAt (fun x => c ^ f x) ((c ^ f x * Complex.log c) \u2022 f') x :=\n  (hasStrictDerivAt_const_cpow h0).comp_hasStrictFDerivAt x hf\n\ntheorem HasFDerivAt.cpow (hf : HasFDerivAt f f' x) (hg : HasFDerivAt g g' x)\n    (h0 : f x \u2208 slitPlane) : HasFDerivAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) \u2022 f' + (f x ^ g x * Complex.log (f x)) \u2022 g') x := by\n  convert (@Complex.hasFDerivAt_cpow ((fun x => (f x, g x)) x) h0).comp x (hf.prod hg)\n\ntheorem HasFDerivAt.const_cpow (hf : HasFDerivAt f f' x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasFDerivAt (fun x => c ^ f x) ((c ^ f x * Complex.log c) \u2022 f') x :=\n  (hasStrictDerivAt_const_cpow h0).hasDerivAt.comp_hasFDerivAt x hf\n\ntheorem HasFDerivWithinAt.cpow (hf : HasFDerivWithinAt f f' s x) (hg : HasFDerivWithinAt g g' s x)\n    (h0 : f x \u2208 slitPlane) : HasFDerivWithinAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) \u2022 f' + (f x ^ g x * Complex.log (f x)) \u2022 g') s x := by\n  convert\n    (@Complex.hasFDerivAt_cpow ((fun x => (f x, g x)) x) h0).comp_hasFDerivWithinAt x (hf.prod hg)\n\ntheorem HasFDerivWithinAt.const_cpow (hf : HasFDerivWithinAt f f' s x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasFDerivWithinAt (fun x => c ^ f x) ((c ^ f x * Complex.log c) \u2022 f') s x :=\n  (hasStrictDerivAt_const_cpow h0).hasDerivAt.comp_hasFDerivWithinAt x hf\n\ntheorem DifferentiableAt.cpow (hf : DifferentiableAt \u2102 f x) (hg : DifferentiableAt \u2102 g x)\n    (h0 : f x \u2208 slitPlane) : DifferentiableAt \u2102 (fun x => f x ^ g x) x :=\n  (hf.hasFDerivAt.cpow hg.hasFDerivAt h0).differentiableAt\n\ntheorem DifferentiableAt.const_cpow (hf : DifferentiableAt \u2102 f x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    DifferentiableAt \u2102 (fun x => c ^ f x) x :=\n  (hf.hasFDerivAt.const_cpow h0).differentiableAt\n\ntheorem DifferentiableAt.cpow_const (hf : DifferentiableAt \u2102 f x) (h0 : f x \u2208 slitPlane) :\n    DifferentiableAt \u2102 (fun x => f x ^ c) x :=\n  hf.cpow (differentiableAt_const c) h0\n\ntheorem DifferentiableWithinAt.cpow (hf : DifferentiableWithinAt \u2102 f s x)\n    (hg : DifferentiableWithinAt \u2102 g s x) (h0 : f x \u2208 slitPlane) :\n    DifferentiableWithinAt \u2102 (fun x => f x ^ g x) s x :=\n  (hf.hasFDerivWithinAt.cpow hg.hasFDerivWithinAt h0).differentiableWithinAt\n\ntheorem DifferentiableWithinAt.const_cpow (hf : DifferentiableWithinAt \u2102 f s x)\n    (h0 : c \u2260 0 \u2228 f x \u2260 0) : DifferentiableWithinAt \u2102 (fun x => c ^ f x) s x :=\n  (hf.hasFDerivWithinAt.const_cpow h0).differentiableWithinAt\n\ntheorem DifferentiableWithinAt.cpow_const (hf : DifferentiableWithinAt \u2102 f s x)\n    (h0 : f x \u2208 slitPlane) :\n    DifferentiableWithinAt \u2102 (fun x => f x ^ c) s x :=\n  hf.cpow (differentiableWithinAt_const c) h0\n\ntheorem DifferentiableOn.cpow (hf : DifferentiableOn \u2102 f s) (hg : DifferentiableOn \u2102 g s)\n    (h0 : Set.MapsTo f s slitPlane) : DifferentiableOn \u2102 (fun x \u21a6 f x ^ g x) s :=\n  fun x hx \u21a6 (hf x hx).cpow (hg x hx) (h0 hx)\n\ntheorem DifferentiableOn.const_cpow (hf : DifferentiableOn \u2102 f s)\n    (h0 : c \u2260 0 \u2228 \u2200 x \u2208 s, f x \u2260 0) : DifferentiableOn \u2102 (fun x \u21a6 c ^ f x) s :=\n  fun x hx \u21a6 (hf x hx).const_cpow (h0.imp_right fun h \u21a6 h x hx)\n\ntheorem DifferentiableOn.cpow_const (hf : DifferentiableOn \u2102 f s)\n    (h0 : \u2200 x \u2208 s, f x \u2208 slitPlane) :\n    DifferentiableOn \u2102 (fun x => f x ^ c) s :=\n  hf.cpow (differentiableOn_const c) h0\n\ntheorem Differentiable.cpow (hf : Differentiable \u2102 f) (hg : Differentiable \u2102 g)\n    (h0 : \u2200 x, f x \u2208 slitPlane) : Differentiable \u2102 (fun x \u21a6 f x ^ g x) :=\n  fun x \u21a6 (hf x).cpow (hg x) (h0 x)\n\ntheorem Differentiable.const_cpow (hf : Differentiable \u2102 f)\n    (h0 : c \u2260 0 \u2228 \u2200 x, f x \u2260 0) : Differentiable \u2102 (fun x \u21a6 c ^ f x) :=\n  fun x \u21a6 (hf x).const_cpow (h0.imp_right fun h \u21a6 h x)\n\n@[fun_prop]\nlemma differentiable_const_cpow_of_neZero (z : \u2102) [NeZero z] :\n    Differentiable \u2102 fun s : \u2102 \u21a6 z ^ s :=\n  differentiable_id.const_cpow (.inl <| NeZero.ne z)\n\n@[fun_prop]\nlemma differentiableAt_const_cpow_of_neZero (z : \u2102) [NeZero z] (t : \u2102) :\n    DifferentiableAt \u2102 (fun s : \u2102 \u21a6 z ^ s) t :=\n  differentiableAt_id.const_cpow (.inl <| NeZero.ne z)\n\nend fderiv\n\nsection deriv\n\nopen Complex\n\nvariable {f g : \u2102 \u2192 \u2102} {s : Set \u2102} {f' g' x c : \u2102}\n\n/-- A private lemma that rewrites the output of lemmas like `HasFDerivAt.cpow` to the form\nexpected by lemmas like `HasDerivAt.cpow`. -/\nprivate theorem aux : ((g x * f x ^ (g x - 1)) \u2022 (1 : \u2102 \u2192L[\u2102] \u2102).smulRight f' +\n    (f x ^ g x * log (f x)) \u2022 (1 : \u2102 \u2192L[\u2102] \u2102).smulRight g') 1 =\n      g x * f x ^ (g x - 1) * f' + f x ^ g x * log (f x) * g' := by\n  simp only [Algebra.id.smul_eq_mul, one_mul, ContinuousLinearMap.one_apply,\n    ContinuousLinearMap.smulRight_apply, ContinuousLinearMap.add_apply, Pi.smul_apply,\n    ContinuousLinearMap.coe_smul']\n\nnonrec theorem HasStrictDerivAt.cpow (hf : HasStrictDerivAt f f' x) (hg : HasStrictDerivAt g g' x)\n    (h0 : f x \u2208 slitPlane) : HasStrictDerivAt (fun x => f x ^ g x)\n      (g x * f x ^ (g x - 1) * f' + f x ^ g x * Complex.log (f x) * g') x := by\n  simpa using (hf.cpow hg h0).hasStrictDerivAt\n\ntheorem HasStrictDerivAt.const_cpow (hf : HasStrictDerivAt f f' x) (h : c \u2260 0 \u2228 f x \u2260 0) :\n    HasStrictDerivAt (fun x => c ^ f x) (c ^ f x * Complex.log c * f') x :=\n  (hasStrictDerivAt_const_cpow h).comp x hf\n\ntheorem Complex.hasStrictDerivAt_cpow_const (h : x \u2208 slitPlane) :\n    HasStrictDerivAt (fun z : \u2102 => z ^ c) (c * x ^ (c - 1)) x := by\n  simpa only [mul_zero, add_zero, mul_one] using\n    (hasStrictDerivAt_id x).cpow (hasStrictDerivAt_const x c) h\n\ntheorem HasStrictDerivAt.cpow_const (hf : HasStrictDerivAt f f' x)\n    (h0 : f x \u2208 slitPlane) :\n    HasStrictDerivAt (fun x => f x ^ c) (c * f x ^ (c - 1) * f') x :=\n  (Complex.hasStrictDerivAt_cpow_const h0).comp x hf\n\ntheorem HasDerivAt.cpow (hf : HasDerivAt f f' x) (hg : HasDerivAt g g' x)\n    (h0 : f x \u2208 slitPlane) : HasDerivAt (fun x => f x ^ g x)\n      (g x * f x ^ (g x - 1) * f' + f x ^ g x * Complex.log (f x) * g') x := by\n  simpa only [aux] using (hf.hasFDerivAt.cpow hg h0).hasDerivAt\n\ntheorem HasDerivAt.const_cpow (hf : HasDerivAt f f' x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasDerivAt (fun x => c ^ f x) (c ^ f x * Complex.log c * f') x :=\n  (hasStrictDerivAt_const_cpow h0).hasDerivAt.comp x hf\n\ntheorem HasDerivAt.cpow_const (hf : HasDerivAt f f' x) (h0 : f x \u2208 slitPlane) :\n    HasDerivAt (fun x => f x ^ c) (c * f x ^ (c - 1) * f') x :=\n  (Complex.hasStrictDerivAt_cpow_const h0).hasDerivAt.comp x hf\n\ntheorem HasDerivWithinAt.cpow (hf : HasDerivWithinAt f f' s x) (hg : HasDerivWithinAt g g' s x)\n    (h0 : f x \u2208 slitPlane) : HasDerivWithinAt (fun x => f x ^ g x)\n      (g x * f x ^ (g x - 1) * f' + f x ^ g x * Complex.log (f x) * g') s x := by\n  simpa only [aux] using (hf.hasFDerivWithinAt.cpow hg h0).hasDerivWithinAt\n\ntheorem HasDerivWithinAt.const_cpow (hf : HasDerivWithinAt f f' s x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasDerivWithinAt (fun x => c ^ f x) (c ^ f x * Complex.log c * f') s x :=\n  (hasStrictDerivAt_const_cpow h0).hasDerivAt.comp_hasDerivWithinAt x hf\n\ntheorem HasDerivWithinAt.cpow_const (hf : HasDerivWithinAt f f' s x)\n    (h0 : f x \u2208 slitPlane) :\n    HasDerivWithinAt (fun x => f x ^ c) (c * f x ^ (c - 1) * f') s x :=\n  (Complex.hasStrictDerivAt_cpow_const h0).hasDerivAt.comp_hasDerivWithinAt x hf\n\n", "theoremStatement": "/-- Although `fun x => x ^ r` for fixed `r` is *not* complex-differentiable along the negative real\nline, it is still real-differentiable, and the derivative is what one would formally expect.\nSee `hasDerivAt_ofReal_cpow_const` for an alternate formulation. -/\ntheorem hasDerivAt_ofReal_cpow_const' {x : \u211d} (hx : x \u2260 0) {r : \u2102} (hr : r \u2260 -1) :\n    HasDerivAt (fun y : \u211d => (y : \u2102) ^ (r + 1) / (r + 1)) (x ^ r) x ", "theoremName": "hasDerivAt_ofReal_cpow_const'", "fileCreated": {"commit": "a9359cb30d5d2eb08c3c66959305c82fe45fab66", "date": "2023-06-06"}, "theoremCreated": {"commit": "006641492734e60b369ac830260c46c2dcdb7342", "date": "2025-01-20"}, "file": "mathlib/Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean", "module": "Mathlib.Analysis.SpecialFunctions.Pow.Deriv", "jsonFile": "Mathlib.Analysis.SpecialFunctions.Pow.Deriv.jsonl", "positionMetadata": {"lineInFile": 220, "tokenPositionInFile": 10317, "theoremPositionInFile": 34}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 249, "numPremises": 299}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [Ne, \u2190 add_eq_zero_iff_eq_neg, \u2190 Ne] at hr\n  rcases lt_or_gt_of_ne hx.symm with (hx | hx)\n  \u00b7 -- easy case : `0 < x`\n    -- Porting note: proof used to be\n    -- convert (((hasDerivAt_id (x : \u2102)).cpow_const _).div_const (r + 1)).comp_ofReal using 1\n    -- \u00b7 rw [add_sub_cancel, id.def, mul_one, mul_comm, mul_div_cancel _ hr]\n    -- \u00b7 rw [id.def, ofReal_re]; exact Or.inl hx\n    apply HasDerivAt.comp_ofReal (e := fun y => (y : \u2102) ^ (r + 1) / (r + 1))\n    convert HasDerivAt.div_const (\ud835\udd5c := \u2102) ?_ (r + 1) using 1\n    \u00b7 exact (mul_div_cancel_right\u2080 _ hr).symm\n    \u00b7 convert HasDerivAt.cpow_const ?_ ?_ using 1\n      \u00b7 rw [add_sub_cancel_right, mul_comm]; exact (mul_one _).symm\n      \u00b7 exact hasDerivAt_id (x : \u2102)\n      \u00b7 simp [hx]\n  \u00b7 -- harder case : `x < 0`\n    have : \u2200\u1da0 y : \u211d in \ud835\udcdd x,\n        (y : \u2102) ^ (r + 1) / (r + 1) = (-y : \u2102) ^ (r + 1) * exp (\u03c0 * I * (r + 1)) / (r + 1) := by\n      refine Filter.eventually_of_mem (Iio_mem_nhds hx) fun y hy => ?_\n      rw [ofReal_cpow_of_nonpos (le_of_lt hy)]\n    refine HasDerivAt.congr_of_eventuallyEq ?_ this\n    rw [ofReal_cpow_of_nonpos (le_of_lt hx)]\n    suffices HasDerivAt (fun y : \u211d => (-\u2191y) ^ (r + 1) * exp (\u2191\u03c0 * I * (r + 1)))\n        ((r + 1) * (-\u2191x) ^ r * exp (\u2191\u03c0 * I * r)) x by\n      convert this.div_const (r + 1) using 1\n      conv_rhs => rw [mul_assoc, mul_comm, mul_div_cancel_right\u2080 _ hr]\n    rw [mul_add ((\u03c0 : \u2102) * _), mul_one, exp_add, exp_pi_mul_I, mul_comm (_ : \u2102) (-1 : \u2102),\n      neg_one_mul]\n    simp_rw [mul_neg, \u2190 neg_mul, \u2190 ofReal_neg]\n    suffices HasDerivAt (fun y : \u211d => (\u2191(-y) : \u2102) ^ (r + 1)) (-(r + 1) * \u2191(-x) ^ r) x by\n      convert this.neg.mul_const _ using 1; ring\n    suffices HasDerivAt (fun y : \u211d => (y : \u2102) ^ (r + 1)) ((r + 1) * \u2191(-x) ^ r) (-x) by\n      convert @HasDerivAt.scomp \u211d _ \u2102 _ _ x \u211d _ _ _ _ _ _ _ _ this (hasDerivAt_neg x) using 1\n      rw [real_smul, ofReal_neg 1, ofReal_one]; ring\n    suffices HasDerivAt (fun y : \u2102 => y ^ (r + 1)) ((r + 1) * \u2191(-x) ^ r) \u2191(-x) by\n      exact this.comp_ofReal\n    conv in \u2191_ ^ _ => rw [(by ring : r = r + 1 - 1)]\n    convert HasDerivAt.cpow_const ?_ ?_ using 1\n    \u00b7 rw [add_sub_cancel_right, add_sub_cancel_right]; exact (mul_one _).symm\n    \u00b7 exact hasDerivAt_id ((-x : \u211d) : \u2102)\n    \u00b7 simp [hx]", "proofType": "tactic", "proofLengthLines": 40, "proofLengthTokens": 2235}}
{"srcContext": "/-\nCopyright (c) 2024 Jo\u00ebl Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jo\u00ebl Riou\n-/\nimport Mathlib.Algebra.Homology.Embedding.Extend\nimport Mathlib.Algebra.Homology.Embedding.IsSupported\nimport Mathlib.Algebra.Homology.QuasiIso\n\n/-!\n# Homology of the extension of an homological complex\n\nGiven an embedding `e : c.Embedding c'` and `K : HomologicalComplex C c`, we shall\ncompute the homology of `K.extend e`. In degrees that are not in the image of `e.f`,\nthe homology is obviously zero. When `e.f j = j`, we construct an isomorphism\n`(K.extend e).homology j' \u2245 K.homology j`.\n\n-/\n\nopen CategoryTheory Limits Category\n\nnamespace HomologicalComplex\n\nvariable {\u03b9 \u03b9' : Type*} {c : ComplexShape \u03b9} {c' : ComplexShape \u03b9'}\n  {C : Type*} [Category C] [HasZeroMorphisms C]\n  [HasZeroObject C]\n\nvariable (K L M : HomologicalComplex C c) (\u03c6 : K \u27f6 L) (\u03c6' : L \u27f6 M) (e : c.Embedding c')\n\nnamespace extend\n\nsection HomologyData\n\nvariable {i j k : \u03b9} {i' j' k' : \u03b9'} (hj' : e.f j = j')\n  (hi : c.prev j = i) (hi' : c'.prev j' = i') (hk : c.next j = k) (hk' : c'.next j' = k')\n\ninclude hk hk' in\nlemma comp_d_eq_zero_iff \u2983W : C\u2984 (\u03c6 : W \u27f6 K.X j) :\n    \u03c6 \u226b K.d j k = 0 \u2194 \u03c6 \u226b (K.extendXIso e hj').inv \u226b (K.extend e).d j' k' = 0 := by\n  by_cases hjk : c.Rel j k\n  \u00b7 have hk' : e.f k = k' := by rw [\u2190 hk', \u2190 hj', c'.next_eq' (e.rel hjk)]\n    rw [K.extend_d_eq e hj' hk', Iso.inv_hom_id_assoc,\n      \u2190 cancel_mono (K.extendXIso e hk').inv, zero_comp, assoc]\n  \u00b7 simp only [K.shape _ _ hjk, comp_zero, true_iff]\n    rw [K.extend_d_from_eq_zero e j' k' j hj', comp_zero, comp_zero]\n    rw [hk]\n    exact hjk\n\ninclude hi hi' in\nlemma d_comp_eq_zero_iff \u2983W : C\u2984 (\u03c6 : K.X j \u27f6 W) :\n    K.d i j \u226b \u03c6 = 0 \u2194 (K.extend e).d i' j' \u226b (K.extendXIso e hj').hom \u226b \u03c6 = 0 := by\n  by_cases hij : c.Rel i j\n  \u00b7 have hi' : e.f i = i' := by rw [\u2190 hi', \u2190 hj', c'.prev_eq' (e.rel hij)]\n    rw [K.extend_d_eq e hi' hj', assoc, assoc, Iso.inv_hom_id_assoc,\n      \u2190 cancel_epi (K.extendXIso e hi').hom, comp_zero]\n  \u00b7 simp only [K.shape _ _ hij, zero_comp, true_iff]\n    rw [K.extend_d_to_eq_zero e i' j' j hj', zero_comp]\n    rw [hi]\n    exact hij\n\nnamespace leftHomologyData\n\nvariable (cone : KernelFork (K.d j k)) (hcone : IsLimit cone)\n\n/-- The kernel fork of `(K.extend e).d j' k'` that is deduced from a kernel\nfork of `K.d j k `. -/\n@[simp]\nnoncomputable def kernelFork : KernelFork ((K.extend e).d j' k') :=\n  KernelFork.of\u03b9 (cone.\u03b9 \u226b (extendXIso K e hj').inv)\n    (by rw [assoc, \u2190 comp_d_eq_zero_iff K e hj' hk hk' cone.\u03b9, cone.condition])\n\n/-- The limit kernel fork of `(K.extend e).d j' k'` that is deduced from a limit\nkernel fork of `K.d j k `. -/\nnoncomputable def isLimitKernelFork : IsLimit (kernelFork K e hj' hk hk' cone) :=\n  KernelFork.isLimitOfIsLimitOfIff hcone ((K.extend e).d j' k')\n    (extendXIso K e hj').symm (comp_d_eq_zero_iff K e hj' hk hk')\n\nvariable (cocone : CokernelCofork (hcone.lift (KernelFork.of\u03b9 (K.d i j) (K.d_comp_d i j k))))\n  (hcocone : IsColimit cocone)\n\ninclude hi hi' hcone in\n/-- Auxiliary lemma for `lift_d_comp_eq_zero_iff`. -/\nlemma lift_d_comp_eq_zero_iff' \u2983W : C\u2984 (f' : K.X i \u27f6 cone.pt)\n    (hf' : f' \u226b cone.\u03b9 = K.d i j)\n    (f'' : (K.extend e).X i' \u27f6 cone.pt)\n    (hf'' : f'' \u226b cone.\u03b9 \u226b (extendXIso K e hj').inv = (K.extend e).d i' j')\n    (\u03c6 : cone.pt \u27f6 W) :\n    f' \u226b \u03c6 = 0 \u2194 f'' \u226b \u03c6 = 0 := by\n  by_cases hij : c.Rel i j\n  \u00b7 have hi'' : e.f i = i' := by rw [\u2190 hi', \u2190 hj', c'.prev_eq' (e.rel hij)]\n    have : (K.extendXIso e hi'').hom \u226b f' = f'' := by\n      apply Fork.IsLimit.hom_ext hcone\n      rw [assoc, hf', \u2190 cancel_mono (extendXIso K e hj').inv, assoc, assoc, hf'',\n        K.extend_d_eq e hi'' hj']\n    rw [\u2190 cancel_epi (K.extendXIso e hi'').hom, comp_zero, \u2190 this, assoc]\n  \u00b7 have h\u2081 : f' = 0 := by\n      apply Fork.IsLimit.hom_ext hcone\n      simp only [zero_comp, hf', K.shape _ _ hij]\n    have h\u2082 : f'' = 0 := by\n      apply Fork.IsLimit.hom_ext hcone\n      dsimp\n      rw [\u2190 cancel_mono (extendXIso K e hj').inv, assoc, hf'', zero_comp, zero_comp,\n        K.extend_d_to_eq_zero e i' j' j hj']\n      rw [hi]\n      exact hij\n    simp [h\u2081, h\u2082]\n\ninclude hi hi' in\nlemma lift_d_comp_eq_zero_iff \u2983W : C\u2984 (\u03c6 : cone.pt \u27f6 W) :\n    hcone.lift (KernelFork.of\u03b9 (K.d i j) (K.d_comp_d i j k)) \u226b \u03c6 = 0 \u2194\n      ((isLimitKernelFork K e hj' hk hk' cone hcone).lift\n      (KernelFork.of\u03b9 ((K.extend e).d i' j') (d_comp_d _ _ _ _))) \u226b \u03c6 = 0 :=\n  lift_d_comp_eq_zero_iff' K e hj' hi hi' cone hcone _ (hcone.fac _ _) _\n    (IsLimit.fac _ _ WalkingParallelPair.zero) _\n\n/-- Auxiliary definition for `extend.leftHomologyData`. -/\nnoncomputable def cokernelCofork :\n    CokernelCofork ((isLimitKernelFork K e hj' hk hk' cone hcone).lift\n      (KernelFork.of\u03b9 ((K.extend e).d i' j') (d_comp_d _ _ _ _))) :=\n  CokernelCofork.of\u03c0 cocone.\u03c0 (by\n    rw [\u2190 lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' cone hcone]\n    exact cocone.condition)\n\n/-- Auxiliary definition for `extend.leftHomologyData`. -/\nnoncomputable def isColimitCokernelCofork :\n    IsColimit (cokernelCofork K e hj' hi hi' hk hk' cone hcone cocone) :=\n  CokernelCofork.isColimitOfIsColimitOfIff' hcocone _\n    (lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' cone hcone)\n\nend leftHomologyData\n\nopen leftHomologyData in\n/-- The left homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a left homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def leftHomologyData (h : (K.sc' i j k).LeftHomologyData) :\n    ((K.extend e).sc' i' j' k').LeftHomologyData where\n  K := h.K\n  H := h.H\n  i := h.i \u226b (extendXIso K e hj').inv\n  \u03c0 := h.\u03c0\n  wi := by\n    dsimp\n    rw [assoc, \u2190 comp_d_eq_zero_iff K e hj' hk hk']\n    exact h.wi\n  hi := isLimitKernelFork K e hj' hk hk' _ h.hi\n  w\u03c0 := by\n    dsimp\n    rw [\u2190 lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' _ h.hi]\n    exact h.w\u03c0\n  h\u03c0 := isColimitCokernelCofork K e hj' hi hi' hk hk' _ h.hi _ h.h\u03c0\n\nnamespace rightHomologyData\n\nvariable (cocone : CokernelCofork (K.d i j)) (hcocone : IsColimit cocone)\n\n/-- The cokernel cofork of `(K.extend e).d i' j'` that is deduced from a cokernel\ncofork of `K.d i j`. -/\n@[simp]\nnoncomputable def cokernelCofork : CokernelCofork ((K.extend e).d i' j') :=\n  CokernelCofork.of\u03c0 ((extendXIso K e hj').hom \u226b cocone.\u03c0) (by\n    rw [\u2190 d_comp_eq_zero_iff K e hj' hi hi' cocone.\u03c0, cocone.condition])\n\n/-- The colimit cokernel cofork of `(K.extend e).d i' j'` that is deduced from a\ncolimit cokernel cofork of `K.d i j`. -/\nnoncomputable def isColimitCokernelCofork : IsColimit (cokernelCofork K e hj' hi hi' cocone) :=\n  CokernelCofork.isColimitOfIsColimitOfIff hcocone ((K.extend e).d i' j')\n    (extendXIso K e hj') (d_comp_eq_zero_iff K e hj' hi hi')\n\nvariable (cone : KernelFork (hcocone.desc (CokernelCofork.of\u03c0 (K.d j k) (K.d_comp_d i j k))))\n  (hcone : IsLimit cone)\n\ninclude hk hk' hcocone in\nlemma d_comp_desc_eq_zero_iff' \u2983W : C\u2984 (f' : cocone.pt \u27f6 K.X k)\n    (hf' : cocone.\u03c0 \u226b f' = K.d j k)\n    (f'' : cocone.pt \u27f6 (K.extend e).X k')\n    (hf'' : (extendXIso K e hj').hom \u226b cocone.\u03c0 \u226b f'' = (K.extend e).d j' k')\n    (\u03c6 : W \u27f6 cocone.pt) :\n    \u03c6 \u226b f' = 0 \u2194 \u03c6 \u226b f'' = 0 := by\n  by_cases hjk : c.Rel j k\n  \u00b7 have hk'' : e.f k = k' := by rw [\u2190 hk', \u2190 hj', c'.next_eq' (e.rel hjk)]\n    have : f' \u226b (K.extendXIso e hk'').inv = f'' := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      rw [reassoc_of% hf', \u2190 cancel_epi (extendXIso K e hj').hom, hf'',\n        K.extend_d_eq e hj' hk'']\n    rw [\u2190 cancel_mono (K.extendXIso e hk'').inv, zero_comp, assoc, this]\n  \u00b7 have h\u2081 : f' = 0 := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      simp only [hf', comp_zero, K.shape _ _ hjk]\n    have h\u2082 : f'' = 0 := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      rw [\u2190 cancel_epi (extendXIso K e hj').hom, hf'', comp_zero, comp_zero,\n        K.extend_d_from_eq_zero e j' k' j hj']\n      rw [hk]\n      exact hjk\n    simp [h\u2081, h\u2082]\n\ninclude hk hk' in\nlemma d_comp_desc_eq_zero_iff \u2983W : C\u2984 (\u03c6 : W \u27f6 cocone.pt) :\n    \u03c6 \u226b hcocone.desc (CokernelCofork.of\u03c0 (K.d j k) (K.d_comp_d i j k)) = 0 \u2194\n      \u03c6 \u226b ((isColimitCokernelCofork K e hj' hi hi' cocone hcocone).desc\n      (CokernelCofork.of\u03c0 ((K.extend e).d j' k') (d_comp_d _ _ _ _))) = 0 :=\n  d_comp_desc_eq_zero_iff' K e hj' hk hk' cocone hcocone _ (hcocone.fac _ _) _ (by\n    simpa using (isColimitCokernelCofork K e hj' hi hi' cocone hcocone).fac _\n      WalkingParallelPair.one) _\n\n/-- Auxiliary definition for `extend.rightHomologyData`. -/\nnoncomputable def kernelFork :\n    KernelFork ((isColimitCokernelCofork K e hj' hi hi' cocone hcocone).desc\n      (CokernelCofork.of\u03c0 ((K.extend e).d j' k') (d_comp_d _ _ _ _))) :=\n  KernelFork.of\u03b9 cone.\u03b9 (by\n    rw [\u2190 d_comp_desc_eq_zero_iff K e hj' hi hi' hk hk' cocone hcocone]\n    exact cone.condition)\n\n/-- Auxiliary definition for `extend.rightHomologyData`. -/\nnoncomputable def isLimitKernelFork :\n    IsLimit (kernelFork K e hj' hi hi' hk hk' cocone hcocone cone) :=\n  KernelFork.isLimitOfIsLimitOfIff' hcone _\n    (d_comp_desc_eq_zero_iff K e hj' hi hi' hk hk' cocone hcocone)\n\nend rightHomologyData\n\nopen rightHomologyData in\n/-- The right homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a right homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def rightHomologyData (h : (K.sc' i j k).RightHomologyData) :\n    ((K.extend e).sc' i' j' k').RightHomologyData where\n  Q := h.Q\n  H := h.H\n  p := (extendXIso K e hj').hom \u226b h.p\n  \u03b9 := h.\u03b9\n  wp := by\n    dsimp\n    rw [\u2190 d_comp_eq_zero_iff K e hj' hi hi']\n    exact h.wp\n  hp := isColimitCokernelCofork K e hj' hi hi' _ h.hp\n  w\u03b9 := by\n    dsimp\n    rw [\u2190 d_comp_desc_eq_zero_iff K e hj' hi hi' hk hk' _ h.hp]\n    exact h.w\u03b9\n  h\u03b9 := isLimitKernelFork K e hj' hi hi' hk hk' _ h.hp _ h.h\u03b9\n\n/-- Computation of the `g'` field of `extend.rightHomologyData`. -/\nlemma rightHomologyData_g' (h : (K.sc' i j k).RightHomologyData) (hk'' : e.f k = k') :\n    (rightHomologyData K e hj' hi hi' hk hk' h).g' = h.g' \u226b (K.extendXIso e hk'').inv := by\n  rw [\u2190 cancel_epi h.p, \u2190 cancel_epi (extendXIso K e hj').hom]\n  have := (rightHomologyData K e hj' hi hi' hk hk' h).p_g'\n  dsimp at this\n  rw [assoc] at this\n  rw [this, K.extend_d_eq e hj' hk'', h.p_g'_assoc, shortComplexFunctor'_obj_g]\n\n/-- The homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def homologyData (h : (K.sc' i j k).HomologyData) :\n    ((K.extend e).sc' i' j' k').HomologyData where\n  left := leftHomologyData K e hj' hi hi' hk hk' h.left\n  right := rightHomologyData K e hj' hi hi' hk hk' h.right\n  iso := h.iso\n\n/-- The homology data of `(K.extend e).sc j'` that is deduced\nfrom a homology data of `K.sc' i j k`. -/\n@[simps!]\nnoncomputable def homologyData' (h : (K.sc' i j k).HomologyData) :\n    ((K.extend e).sc j').HomologyData :=\n  homologyData K e hj' hi rfl hk rfl h\n\nend HomologyData\n\nlemma hasHomology {j : \u03b9} {j' : \u03b9'} (hj' : e.f j = j') [K.HasHomology j] :\n    (K.extend e).HasHomology j' :=\n  ShortComplex.HasHomology.mk'\n    (homologyData' K e hj' rfl rfl ((K.sc j).homologyData))\n\ninstance (j : \u03b9) [K.HasHomology j] : (K.extend e).HasHomology (e.f j) :=\n  hasHomology K e rfl\n\ninstance [\u2200 j, K.HasHomology j] (j' : \u03b9') : (K.extend e).HasHomology j' := by\n  by_cases h : \u2203 j, e.f j = j'\n  \u00b7 obtain \u27e8j, rfl\u27e9 := h\n    infer_instance\n  \u00b7 have hj := isZero_extend_X K e j' (by tauto)\n    exact ShortComplex.HasHomology.mk'\n      (ShortComplex.HomologyData.ofZeros _ (hj.eq_of_tgt _ _) (hj.eq_of_src _ _))\n\nend extend\n\n", "theoremStatement": "lemma extend_exactAt (j' : \u03b9') (hj' : \u2200 j, e.f j \u2260 j') :\n    (K.extend e).ExactAt j' ", "theoremName": "HomologicalComplex.extend_exactAt", "fileCreated": {"commit": "9bdc1af76cf75d960f42c29f1c09917785066c8b", "date": "2024-11-30"}, "theoremCreated": {"commit": "b07a551a1451cbf8615f4e2a6c47052affadbae4", "date": "2025-01-17"}, "file": "mathlib/Mathlib/Algebra/Homology/Embedding/ExtendHomology.lean", "module": "Mathlib.Algebra.Homology.Embedding.ExtendHomology", "jsonFile": "Mathlib.Algebra.Homology.Embedding.ExtendHomology.jsonl", "positionMetadata": {"lineInFile": 289, "tokenPositionInFile": 11426, "theoremPositionInFile": 17}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 12, "numPremises": 13}, "proofMetadata": {"hasProof": true, "proof": ":=\n  exactAt_of_isSupported _ e j' hj'", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 38}}
{"srcContext": "/-\nCopyright (c) 2020 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\nimport Mathlib.Algebra.Algebra.Rat\nimport Mathlib.Algebra.BigOperators.NatAntidiagonal\nimport Mathlib.Data.Nat.Choose.Sum\nimport Mathlib.RingTheory.PowerSeries.Basic\n\n/-!\n# Definition of well-known power series\n\nIn this file we define the following power series:\n\n* `PowerSeries.invUnitsSub`: given `u : R\u02e3`, this is the series for `1 / (u - x)`.\n  It is given by `\u2211 n, x ^ n /\u209a u ^ (n + 1)`.\n\n* `PowerSeries.invOneSubPow`: given a commutative ring `S` and a number `d : \u2115`,\n  `PowerSeries.invOneSubPow S d` is the multiplicative inverse of `(1 - X) ^ d` in `S\u27e6X\u27e7\u02e3`.\n  When `d` is `0`, `PowerSeries.invOneSubPow S d` will just be `1`. When `d` is positive,\n  `PowerSeries.invOneSubPow S d` will be `\u2211 n, Nat.choose (d - 1 + n) (d - 1)`.\n\n* `PowerSeries.sin`, `PowerSeries.cos`, `PowerSeries.exp` : power series for sin, cosine, and\n  exponential functions.\n-/\n\n\nnamespace PowerSeries\n\nsection Ring\n\nvariable {R S : Type*} [Ring R] [Ring S]\n\n/-- The power series for `1 / (u - x)`. -/\ndef invUnitsSub (u : R\u02e3) : PowerSeries R :=\n  mk fun n => 1 /\u209a u ^ (n + 1)\n\n@[simp]\ntheorem coeff_invUnitsSub (u : R\u02e3) (n : \u2115) : coeff R n (invUnitsSub u) = 1 /\u209a u ^ (n + 1) :=\n  coeff_mk _ _\n\n@[simp]\ntheorem constantCoeff_invUnitsSub (u : R\u02e3) : constantCoeff R (invUnitsSub u) = 1 /\u209a u := by\n  rw [\u2190 coeff_zero_eq_constantCoeff_apply, coeff_invUnitsSub, zero_add, pow_one]\n\n@[simp]\ntheorem invUnitsSub_mul_X (u : R\u02e3) : invUnitsSub u * X = invUnitsSub u * C R u - 1 := by\n  ext (_ | n)\n  \u00b7 simp\n  \u00b7 simp [n.succ_ne_zero, pow_succ']\n\n@[simp]\ntheorem invUnitsSub_mul_sub (u : R\u02e3) : invUnitsSub u * (C R u - X) = 1 := by\n  simp [mul_sub, sub_sub_cancel]\n\ntheorem map_invUnitsSub (f : R \u2192+* S) (u : R\u02e3) :\n    map f (invUnitsSub u) = invUnitsSub (Units.map (f : R \u2192* S) u) := by\n  ext\n  simp only [\u2190 map_pow, coeff_map, coeff_invUnitsSub, one_divp]\n  rfl\n\nend Ring\n\nsection invOneSubPow\n\nvariable (S : Type*) [CommRing S] (d : \u2115)\n\n/--\n(1 + X + X^2 + ...) * (1 - X) = 1.\n\nNote that the power series `1 + X + X^2 + ...` is written as `mk 1` where `1` is the constant\nfunction so that `mk 1` is the power series with all coefficients equal to one.\n-/\ntheorem mk_one_mul_one_sub_eq_one : (mk 1 : S\u27e6X\u27e7) * (1 - X) = 1 := by\n  rw [mul_comm, PowerSeries.ext_iff]\n  intro n\n  cases n with\n  | zero => simp\n  | succ n => simp [sub_mul]\n\n/--\nNote that `mk 1` is the constant function `1` so the power series `1 + X + X^2 + ...`. This theorem\nstates that for any `d : \u2115`, `(1 + X + X^2 + ... : S\u27e6X\u27e7) ^ (d + 1)` is equal to the power series\n`mk fun n => Nat.choose (d + n) d : S\u27e6X\u27e7`.\n-/\ntheorem mk_one_pow_eq_mk_choose_add :\n    (mk 1 : S\u27e6X\u27e7) ^ (d + 1) = (mk fun n => Nat.choose (d + n) d : S\u27e6X\u27e7) := by\n  induction d with\n  | zero => ext; simp\n  | succ d hd =>\n      ext n\n      rw [pow_add, hd, pow_one, mul_comm, coeff_mul]\n      simp_rw [coeff_mk, Pi.one_apply, one_mul]\n      norm_cast\n      rw [Finset.sum_antidiagonal_choose_add, add_right_comm]\n\n/--\nGiven a natural number `d : \u2115` and a commutative ring `S`, `PowerSeries.invOneSubPow S d` is the\nmultiplicative inverse of `(1 - X) ^ d` in `S\u27e6X\u27e7\u02e3`. When `d` is `0`, `PowerSeries.invOneSubPow S d`\nwill just be `1`. When `d` is positive, `PowerSeries.invOneSubPow S d` will be the power series\n`mk fun n => Nat.choose (d - 1 + n) (d - 1)`.\n-/\nnoncomputable def invOneSubPow : \u2115 \u2192 S\u27e6X\u27e7\u02e3\n  | 0 => 1\n  | d + 1 => {\n    val := mk fun n => Nat.choose (d + n) d\n    inv := (1 - X) ^ (d + 1)\n    val_inv := by\n      rw [\u2190 mk_one_pow_eq_mk_choose_add, \u2190 mul_pow, mk_one_mul_one_sub_eq_one, one_pow]\n    inv_val := by\n      rw [\u2190 mk_one_pow_eq_mk_choose_add, \u2190 mul_pow, mul_comm, mk_one_mul_one_sub_eq_one, one_pow]\n    }\n\ntheorem invOneSubPow_zero : invOneSubPow S 0 = 1 := by\n  delta invOneSubPow\n  simp only [Units.val_one]\n\ntheorem invOneSubPow_val_eq_mk_sub_one_add_choose_of_pos (h : 0 < d) :\n    (invOneSubPow S d).val = (mk fun n => Nat.choose (d - 1 + n) (d - 1) : S\u27e6X\u27e7) := by\n  rw [\u2190 Nat.sub_one_add_one_eq_of_pos h, invOneSubPow, add_tsub_cancel_right]\n\ntheorem invOneSubPow_val_succ_eq_mk_add_choose :\n    (invOneSubPow S (d + 1)).val = (mk fun n => Nat.choose (d + n) d : S\u27e6X\u27e7) := rfl\n\ntheorem invOneSubPow_val_one_eq_invUnitSub_one :\n    (invOneSubPow S 1).val = invUnitsSub (1 : S\u02e3) := by\n  simp [invOneSubPow, invUnitsSub]\n\n/--\nThe theorem `PowerSeries.mk_one_mul_one_sub_eq_one` implies that `1 - X` is a unit in `S\u27e6X\u27e7`\nwhose inverse is the power series `1 + X + X^2 + ...`. This theorem states that for any `d : \u2115`,\n`PowerSeries.invOneSubPow S d` is equal to `(1 - X)\u207b\u00b9 ^ d`.\n-/\ntheorem invOneSubPow_eq_inv_one_sub_pow :\n    invOneSubPow S d =\n      (Units.mkOfMulEqOne (1 - X) (mk 1 : S\u27e6X\u27e7) <|\n        Eq.trans (mul_comm _ _) (mk_one_mul_one_sub_eq_one S))\u207b\u00b9 ^ d := by\n  induction d with\n  | zero => exact Eq.symm <| pow_zero _\n  | succ d _ =>\n      rw [inv_pow]\n      exact (DivisionMonoid.inv_eq_of_mul _ (invOneSubPow S (d + 1)) <| by\n        rw [\u2190 Units.val_eq_one, Units.val_mul, Units.val_pow_eq_pow_val]\n        exact (invOneSubPow S (d + 1)).inv_val).symm\n\ntheorem invOneSubPow_inv_eq_one_sub_pow :\n    (invOneSubPow S d).inv = (1 - X : S\u27e6X\u27e7) ^ d := by\n  induction d with\n  | zero => exact Eq.symm <| pow_zero _\n  | succ d => rfl\n\ntheorem invOneSubPow_inv_zero_eq_one : (invOneSubPow S 0).inv = 1 := by\n  delta invOneSubPow\n  simp only [Units.inv_eq_val_inv, inv_one, Units.val_one]\n\ntheorem mk_add_choose_mul_one_sub_pow_eq_one :\n    (mk fun n \u21a6 Nat.choose (d + n) d : S\u27e6X\u27e7) * ((1 - X) ^ (d + 1)) = 1 :=\n  (invOneSubPow S (d + 1)).val_inv\n\n", "theoremStatement": "theorem invOneSubPow_add (e : \u2115) :\n    invOneSubPow S (d + e) = invOneSubPow S d * invOneSubPow S e ", "theoremName": "PowerSeries.invOneSubPow_add", "fileCreated": {"commit": "d22d5a028da58fd6edc1f288ee97594ef5b586a1", "date": "2023-05-22"}, "theoremCreated": {"commit": "7a05b449ac13af0118fd6b2c133d08e33e7e74ad", "date": "2024-12-04"}, "file": "mathlib/Mathlib/RingTheory/PowerSeries/WellKnown.lean", "module": "Mathlib.RingTheory.PowerSeries.WellKnown", "jsonFile": "Mathlib.RingTheory.PowerSeries.WellKnown.jsonl", "positionMetadata": {"lineInFile": 161, "tokenPositionInFile": 5637, "theoremPositionInFile": 16}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 43, "numPremises": 64}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp_rw [invOneSubPow_eq_inv_one_sub_pow, pow_add]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 58}}
{"srcContext": "/-\nCopyright (c) 2024 Jo\u00ebl Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jo\u00ebl Riou\n-/\nimport Mathlib.Algebra.Homology.Embedding.Basic\nimport Mathlib.Algebra.Homology.HomologicalComplex\n\n/-!\n# Boundary of an embedding of complex shapes\n\nIn the file `Mathlib.Algebra.Homology.Embedding.Basic`, given `p : \u2124`, we have defined\nan embedding `embeddingUpIntGE p` of `ComplexShape.up \u2115` in `ComplexShape.up \u2124`\nwhich sends `n : \u2115` to `p + n`. The (canonical) truncation (`\u2265 p`) of\n`K : CochainComplex C \u2124` shall be defined as the extension to `\u2124`\n(see `Mathlib.Algebra.Homology.Embedding.Extend`) of\na certain cochain complex indexed by `\u2115`:\n\n`Q \u27f6 K.X (p + 1) \u27f6 K.X (p + 2) \u27f6 K.X (p + 3) \u27f6 ...`\n\nwhere in degree `0`, the object `Q` identifies to the cokernel\nof `K.X (p - 1) \u27f6 K.X p` (this is `K.opcycles p`). In this case,\nwe see that the degree `0 : \u2115` needs a particular attention when\nconstructing the truncation.\n\nIn this file, more generally, for `e : Embedding c c'`, we define\na predicate `\u03b9 \u2192 Prop` named `e.BoundaryGE` which shall be relevant\nwhen constructing the truncation `K.truncGE e` when `e.IsTruncGE`.\nIn the case of `embeddingUpIntGE p`, we show that `0 : \u2115` is the\nonly element in this lower boundary. Similarly, we define\n`Embedding.BoundaryLE`.\n\n-/\n\nnamespace ComplexShape\n\nnamespace Embedding\n\nvariable {\u03b9 \u03b9' : Type*} {c : ComplexShape \u03b9} {c' : ComplexShape \u03b9'} (e : Embedding c c')\n\n/-- The lower boundary of an embedding `e : Embedding c c'`, as a predicate on `\u03b9`.\nIt is satisfied by `j : \u03b9` when there exists `i' : \u03b9'` not in the image of `e.f`\nsuch that `c'.Rel i' (e.f j)`. -/\ndef BoundaryGE (j : \u03b9) : Prop :=\n  c'.Rel (c'.prev (e.f j)) (e.f j) \u2227 \u2200 i, \u00acc'.Rel (e.f i) (e.f j)\n\nlemma boundaryGE {i' : \u03b9'} {j : \u03b9} (hj : c'.Rel i' (e.f j)) (hi' : \u2200 i, e.f i \u2260 i') :\n    e.BoundaryGE j := by\n  constructor\n  \u00b7 simpa only [c'.prev_eq' hj] using hj\n  \u00b7 intro i hi\n    apply hi' i\n    rw [\u2190 c'.prev_eq' hj, c'.prev_eq' hi]\n\nlemma not_boundaryGE_next [e.IsRelIff] {j k : \u03b9} (hk : c.Rel j k) :\n    \u00ac e.BoundaryGE k := by\n  dsimp [BoundaryGE]\n  simp only [not_and, not_forall, not_not]\n  intro\n  exact \u27e8j, by simpa only [e.rel_iff] using hk\u27e9\n\nlemma not_boundaryGE_next' [e.IsRelIff] {j k : \u03b9} (hj : \u00ac e.BoundaryGE j) (hk : c.next j = k) :\n    \u00ac e.BoundaryGE k := by\n  by_cases hjk : c.Rel j k\n  \u00b7 exact e.not_boundaryGE_next hjk\n  \u00b7 subst hk\n    simpa only [c.next_eq_self j hjk] using hj\n\nvariable {e} in\nlemma BoundaryGE.not_mem {j : \u03b9} (hj : e.BoundaryGE j) {i' : \u03b9'} (hi' : c'.Rel i' (e.f j))\n    (a : \u03b9) : e.f a \u2260 i' := fun ha =>\n  hj.2 a (by simpa only [ha] using hi')\n\nlemma prev_f_of_not_boundaryGE [e.IsRelIff] {i j : \u03b9} (hij : c.prev j = i)\n    (hj : \u00ac e.BoundaryGE j) :\n    c'.prev (e.f j) = e.f i := by\n  by_cases hij' : c.Rel i j\n  \u00b7 exact c'.prev_eq' (by simpa only [e.rel_iff] using hij')\n  \u00b7 obtain rfl : j = i := by\n      simpa only [c.prev_eq_self j (by simpa only [hij] using hij')] using hij\n    apply c'.prev_eq_self\n    intro hj'\n    simp only [BoundaryGE, not_and, not_forall, not_not] at hj\n    obtain \u27e8i, hi\u27e9 := hj hj'\n    rw [e.rel_iff] at hi\n    rw [c.prev_eq' hi] at hij\n    exact hij' (by simpa only [hij] using hi)\n\nvariable {e} in\nlemma BoundaryGE.false_of_isTruncLE {j : \u03b9} (hj : e.BoundaryGE j) [e.IsTruncLE] : False := by\n  obtain \u27e8i, hi\u27e9 := e.mem_prev hj.1\n  exact hj.2 i (by simpa only [hi] using hj.1)\n\n/-- The upper boundary of an embedding `e : Embedding c c'`, as a predicate on `\u03b9`.\nIt is satisfied by `j : \u03b9` when there exists `k' : \u03b9'` not in the image of `e.f`\nsuch that `c'.Rel (e.f j) k'`. -/\ndef BoundaryLE (j : \u03b9) : Prop :=\n  c'.Rel (e.f j) (c'.next (e.f j)) \u2227 \u2200 k, \u00acc'.Rel (e.f j) (e.f k)\n\nlemma boundaryLE {k' : \u03b9'} {j : \u03b9} (hj : c'.Rel (e.f j) k') (hk' : \u2200 i, e.f i \u2260 k') :\n    e.BoundaryLE j := by\n  constructor\n  \u00b7 simpa only [c'.next_eq' hj] using hj\n  \u00b7 intro k hk\n    apply hk' k\n    rw [\u2190 c'.next_eq' hj, c'.next_eq' hk]\n\nlemma not_boundaryLE_prev [e.IsRelIff] {i j : \u03b9} (hi : c.Rel i j) :\n    \u00ac e.BoundaryLE i := by\n  dsimp [BoundaryLE]\n  simp only [not_and, not_forall, not_not]\n  intro\n  exact \u27e8j, by simpa only [e.rel_iff] using hi\u27e9\n\nlemma not_boundaryLE_prev' [e.IsRelIff] {i j : \u03b9} (hj : \u00ac e.BoundaryLE j) (hk : c.prev j = i) :\n    \u00ac e.BoundaryLE i := by\n  by_cases hij : c.Rel i j\n  \u00b7 exact e.not_boundaryLE_prev hij\n  \u00b7 subst hk\n    simpa only [c.prev_eq_self j hij] using hj\n\nvariable {e} in\nlemma BoundaryLE.not_mem {j : \u03b9} (hj : e.BoundaryLE j) {k' : \u03b9'} (hk' : c'.Rel (e.f j) k')\n    (a : \u03b9) : e.f a \u2260 k' := fun ha =>\n  hj.2 a (by simpa only [ha] using hk')\n\nlemma next_f_of_not_boundaryLE [e.IsRelIff] {j k : \u03b9} (hjk : c.next j = k)\n    (hj : \u00ac e.BoundaryLE j) :\n    c'.next (e.f j) = e.f k := by\n  by_cases hjk' : c.Rel j k\n  \u00b7 exact c'.next_eq' (by simpa only [e.rel_iff] using hjk')\n  \u00b7 obtain rfl : j = k := by\n      simpa only [c.next_eq_self j (by simpa only [hjk] using hjk')] using hjk\n    apply c'.next_eq_self\n    intro hj'\n    simp only [BoundaryLE, not_and, not_forall, not_not] at hj\n    obtain \u27e8k, hk\u27e9 := hj hj'\n    rw [e.rel_iff] at hk\n    rw [c.next_eq' hk] at hjk\n    exact hjk' (by simpa only [hjk] using hk)\n\nlemma next_f [e.IsTruncGE] {j k : \u03b9} (hjk : c.next j = k) : c'.next (e.f j) = e.f k := by\n  by_cases hj : c'.Rel (e.f j) (c'.next (e.f j))\n  \u00b7 obtain \u27e8k', hk'\u27e9 := e.mem_next hj\n    rw [\u2190 hk', e.rel_iff] at hj\n    rw [\u2190 hk', \u2190 c.next_eq' hj, hjk]\n  \u00b7 rw [c'.next_eq_self _ hj, \u2190 hjk, c.next_eq_self j]\n    intro hj'\n    apply hj\n    rw [\u2190 e.rel_iff] at hj'\n    simpa only [c'.next_eq' hj'] using hj'\n\nlemma prev_f [e.IsTruncLE] {i j : \u03b9} (hij : c.prev j = i) : c'.prev (e.f j) = e.f i :=\n  e.op.next_f hij\n\nvariable {e} in\nlemma BoundaryLE.false_of_isTruncGE {j : \u03b9} (hj : e.BoundaryLE j) [e.IsTruncGE] : False := by\n  obtain \u27e8k, hk\u27e9 := e.mem_next hj.1\n  exact hj.2 k (by simpa only [hk] using hj.1)\n\n@[simp] lemma op_boundaryLE_iff {j : \u03b9} : e.op.BoundaryLE j \u2194 e.BoundaryGE j := by rfl\n", "theoremStatement": "@[simp] lemma op_boundaryGE_iff {j : \u03b9} : e.op.BoundaryGE j \u2194 e.BoundaryLE j ", "theoremName": "ComplexShape.Embedding.op_boundaryGE_iff", "fileCreated": {"commit": "a365570f25dcf0cf70a9c3296a29c92cd71a5b8a", "date": "2024-07-17"}, "theoremCreated": {"commit": "1af25077805df4670d88f3e48778af0c90c7aa98", "date": "2025-01-17"}, "file": "mathlib/Mathlib/Algebra/Homology/Embedding/Boundary.lean", "module": "Mathlib.Algebra.Homology.Embedding.Boundary", "jsonFile": "Mathlib.Algebra.Homology.Embedding.Boundary.jsonl", "positionMetadata": {"lineInFile": 162, "tokenPositionInFile": 5954, "theoremPositionInFile": 17}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 6, "numPremises": 8}, "proofMetadata": {"hasProof": true, "proof": ":= by rfl", "proofType": "tactic", "proofLengthLines": 0, "proofLengthTokens": 9}}
{"srcContext": "/-\nCopyright (c) 2020 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kevin Buzzard, Johan Commelin, Patrick Massot\n-/\nimport Mathlib.Algebra.Order.Hom.Monoid\nimport Mathlib.Algebra.Order.Ring.Basic\nimport Mathlib.RingTheory.Ideal.Maps\nimport Mathlib.Tactic.TFAE\n\n/-!\n\n# The basics of valuation theory.\n\nThe basic theory of valuations (non-archimedean norms) on a commutative ring,\nfollowing T. Wedhorn's unpublished notes \u201cAdic Spaces\u201d ([wedhorn_adic]).\n\nThe definition of a valuation we use here is Definition 1.22 of [wedhorn_adic].\nA valuation on a ring `R` is a monoid homomorphism `v` to a linearly ordered\ncommutative monoid with zero, that in addition satisfies the following two axioms:\n * `v 0 = 0`\n * `\u2200 x y, v (x + y) \u2264 max (v x) (v y)`\n\n`Valuation R \u0393\u2080`is the type of valuations `R \u2192 \u0393\u2080`, with a coercion to the underlying\nfunction. If `v` is a valuation from `R` to `\u0393\u2080` then the induced group\nhomomorphism `Units(R) \u2192 \u0393\u2080` is called `unit_map v`.\n\nThe equivalence \"relation\" `IsEquiv v\u2081 v\u2082 : Prop` defined in 1.27 of [wedhorn_adic] is not strictly\nspeaking a relation, because `v\u2081 : Valuation R \u0393\u2081` and `v\u2082 : Valuation R \u0393\u2082` might\nnot have the same type. This corresponds in ZFC to the set-theoretic difficulty\nthat the class of all valuations (as `\u0393\u2080` varies) on a ring `R` is not a set.\nThe \"relation\" is however reflexive, symmetric and transitive in the obvious\nsense. Note that we use 1.27(iii) of [wedhorn_adic] as the definition of equivalence.\n\n## Main definitions\n\n* `Valuation R \u0393\u2080`, the type of valuations on `R` with values in `\u0393\u2080`\n* `Valuation.IsEquiv`, the heterogeneous equivalence relation on valuations\n* `Valuation.supp`, the support of a valuation\n\n* `AddValuation R \u0393\u2080`, the type of additive valuations on `R` with values in a\n  linearly ordered additive commutative group with a top element, `\u0393\u2080`.\n\n## Implementation Details\n\n`AddValuation R \u0393\u2080` is implemented as `Valuation R (Multiplicative \u0393\u2080)\u1d52\u1d48`.\n\n## Notation\n\nIn the `DiscreteValuation` locale:\n\n * `\u2115\u2098\u2080` is a shorthand for `WithZero (Multiplicative \u2115)`\n * `\u2124\u2098\u2080` is a shorthand for `WithZero (Multiplicative \u2124)`\n\n## TODO\n\nIf ever someone extends `Valuation`, we should fully comply to the `DFunLike` by migrating the\nboilerplate lemmas to `ValuationClass`.\n-/\n\nopen Function Ideal\n\nnoncomputable section\n\nvariable {K F R : Type*} [DivisionRing K]\n\nsection\n\nvariable (F R) (\u0393\u2080 : Type*) [LinearOrderedCommMonoidWithZero \u0393\u2080] [Ring R]\n\n/-- The type of `\u0393\u2080`-valued valuations on `R`.\n\nWhen you extend this structure, make sure to extend `ValuationClass`. -/\nstructure Valuation extends R \u2192*\u2080 \u0393\u2080 where\n  /-- The valuation of a a sum is less that the sum of the valuations -/\n  map_add_le_max' : \u2200 x y, toFun (x + y) \u2264 max (toFun x) (toFun y)\n\n/-- `ValuationClass F \u03b1 \u03b2` states that `F` is a type of valuations.\n\nYou should also extend this typeclass when you extend `Valuation`. -/\nclass ValuationClass (F) (R \u0393\u2080 : outParam Type*) [LinearOrderedCommMonoidWithZero \u0393\u2080] [Ring R]\n  [FunLike F R \u0393\u2080]\n  extends MonoidWithZeroHomClass F R \u0393\u2080 : Prop where\n  /-- The valuation of a a sum is less that the sum of the valuations -/\n  map_add_le_max (f : F) (x y : R) : f (x + y) \u2264 max (f x) (f y)\n\nexport ValuationClass (map_add_le_max)\n\ninstance [FunLike F R \u0393\u2080] [ValuationClass F R \u0393\u2080] : CoeTC F (Valuation R \u0393\u2080) :=\n  \u27e8fun f =>\n    { toFun := f\n      map_one' := map_one f\n      map_zero' := map_zero f\n      map_mul' := map_mul f\n      map_add_le_max' := map_add_le_max f }\u27e9\n\nend\n\nnamespace Valuation\n\nvariable {\u0393\u2080 : Type*}\nvariable {\u0393'\u2080 : Type*}\nvariable {\u0393''\u2080 : Type*} [LinearOrderedCommMonoidWithZero \u0393''\u2080]\n\nsection Basic\n\nvariable [Ring R]\n\nsection Monoid\n\nvariable [LinearOrderedCommMonoidWithZero \u0393\u2080] [LinearOrderedCommMonoidWithZero \u0393'\u2080]\n\ninstance : FunLike (Valuation R \u0393\u2080) R \u0393\u2080 where\n  coe f := f.toFun\n  coe_injective' f g h := by\n    obtain \u27e8\u27e8\u27e8_,_\u27e9, _\u27e9, _\u27e9 := f\n    congr\n\ninstance : ValuationClass (Valuation R \u0393\u2080) R \u0393\u2080 where\n  map_mul f := f.map_mul'\n  map_one f := f.map_one'\n  map_zero f := f.map_zero'\n  map_add_le_max f := f.map_add_le_max'\n\n@[simp]\ntheorem coe_mk (f : R \u2192*\u2080 \u0393\u2080) (h) : \u21d1(Valuation.mk f h) = f := rfl\n\ntheorem toFun_eq_coe (v : Valuation R \u0393\u2080) : v.toFun = v := rfl\n\n@[simp]\ntheorem toMonoidWithZeroHom_coe_eq_coe (v : Valuation R \u0393\u2080) :\n    (v.toMonoidWithZeroHom : R \u2192 \u0393\u2080) = v := rfl\n\n@[ext]\ntheorem ext {v\u2081 v\u2082 : Valuation R \u0393\u2080} (h : \u2200 r, v\u2081 r = v\u2082 r) : v\u2081 = v\u2082 :=\n  DFunLike.ext _ _ h\n\nvariable (v : Valuation R \u0393\u2080)\n\n@[simp, norm_cast]\ntheorem coe_coe : \u21d1(v : R \u2192*\u2080 \u0393\u2080) = v := rfl\n\ntheorem map_zero : v 0 = 0 :=\n  v.map_zero'\n\ntheorem map_one : v 1 = 1 :=\n  v.map_one'\n\ntheorem map_mul : \u2200 x y, v (x * y) = v x * v y :=\n  v.map_mul'\n\n-- Porting note: LHS side simplified so created map_add'\ntheorem map_add : \u2200 x y, v (x + y) \u2264 max (v x) (v y) :=\n  v.map_add_le_max'\n\n@[simp]\ntheorem map_add' : \u2200 x y, v (x + y) \u2264 v x \u2228 v (x + y) \u2264 v y := by\n  intro x y\n  rw [\u2190 le_max_iff, \u2190 ge_iff_le]\n  apply map_add\n\ntheorem map_add_le {x y g} (hx : v x \u2264 g) (hy : v y \u2264 g) : v (x + y) \u2264 g :=\n  le_trans (v.map_add x y) <| max_le hx hy\n\ntheorem map_add_lt {x y g} (hx : v x < g) (hy : v y < g) : v (x + y) < g :=\n  lt_of_le_of_lt (v.map_add x y) <| max_lt hx hy\n\ntheorem map_sum_le {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hf : \u2200 i \u2208 s, v (f i) \u2264 g) :\n    v (\u2211 i \u2208 s, f i) \u2264 g := by\n  classical\n  refine\n    Finset.induction_on s (fun _ => v.map_zero \u25b8 zero_le')\n      (fun a s has ih hf => ?_) hf\n  rw [Finset.forall_mem_insert] at hf; rw [Finset.sum_insert has]\n  exact v.map_add_le hf.1 (ih hf.2)\n\ntheorem map_sum_lt {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hg : g \u2260 0)\n    (hf : \u2200 i \u2208 s, v (f i) < g) : v (\u2211 i \u2208 s, f i) < g := by\n  classical\n  refine\n    Finset.induction_on s (fun _ => v.map_zero \u25b8 (zero_lt_iff.2 hg))\n      (fun a s has ih hf => ?_) hf\n  rw [Finset.forall_mem_insert] at hf; rw [Finset.sum_insert has]\n  exact v.map_add_lt hf.1 (ih hf.2)\n\ntheorem map_sum_lt' {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hg : 0 < g)\n    (hf : \u2200 i \u2208 s, v (f i) < g) : v (\u2211 i \u2208 s, f i) < g :=\n  v.map_sum_lt (ne_of_gt hg) hf\n\ntheorem map_pow : \u2200 (x) (n : \u2115), v (x ^ n) = v x ^ n :=\n  v.toMonoidWithZeroHom.toMonoidHom.map_pow\n\n-- The following definition is not an instance, because we have more than one `v` on a given `R`.\n-- In addition, type class inference would not be able to infer `v`.\n/-- A valuation gives a preorder on the underlying ring. -/\ndef toPreorder : Preorder R :=\n  Preorder.lift v\n\n/-- If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. -/\ntheorem zero_iff [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) {x : K} : v x = 0 \u2194 x = 0 :=\n  map_eq_zero v\n\ntheorem ne_zero_iff [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) {x : K} : v x \u2260 0 \u2194 x \u2260 0 :=\n  map_ne_zero v\n\nlemma pos_iff [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) {x : K} : 0 < v x \u2194 x \u2260 0 := by\n  rw [zero_lt_iff, ne_zero_iff]\n\ntheorem unit_map_eq (u : R\u02e3) : (Units.map (v : R \u2192* \u0393\u2080) u : \u0393\u2080) = v u :=\n  rfl\n\ntheorem ne_zero_of_unit [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) (x : K\u02e3) : v x \u2260 (0 : \u0393\u2080) := by\n  simp only [ne_eq, Valuation.zero_iff, Units.ne_zero x, not_false_iff]\n\ntheorem ne_zero_of_isUnit [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) (x : K) (hx : IsUnit x) :\n    v x \u2260 (0 : \u0393\u2080) := by\n  simpa [hx.choose_spec] using ne_zero_of_unit v hx.choose\n\n/-- A ring homomorphism `S \u2192 R` induces a map `Valuation R \u0393\u2080 \u2192 Valuation S \u0393\u2080`. -/\ndef comap {S : Type*} [Ring S] (f : S \u2192+* R) (v : Valuation R \u0393\u2080) : Valuation S \u0393\u2080 :=\n  { v.toMonoidWithZeroHom.comp f.toMonoidWithZeroHom with\n    toFun := v \u2218 f\n    map_add_le_max' := fun x y => by simp only [comp_apply, map_add, f.map_add] }\n\n@[simp]\ntheorem comap_apply {S : Type*} [Ring S] (f : S \u2192+* R) (v : Valuation R \u0393\u2080) (s : S) :\n    v.comap f s = v (f s) := rfl\n\n@[simp]\ntheorem comap_id : v.comap (RingHom.id R) = v :=\n  ext fun _r => rfl\n\ntheorem comap_comp {S\u2081 : Type*} {S\u2082 : Type*} [Ring S\u2081] [Ring S\u2082] (f : S\u2081 \u2192+* S\u2082) (g : S\u2082 \u2192+* R) :\n    v.comap (g.comp f) = (v.comap g).comap f :=\n  ext fun _r => rfl\n\n/-- A `\u2264`-preserving group homomorphism `\u0393\u2080 \u2192 \u0393'\u2080` induces a map `Valuation R \u0393\u2080 \u2192 Valuation R \u0393'\u2080`.\n-/\ndef map (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080) (hf : Monotone f) (v : Valuation R \u0393\u2080) : Valuation R \u0393'\u2080 :=\n  { MonoidWithZeroHom.comp f v.toMonoidWithZeroHom with\n    toFun := f \u2218 v\n    map_add_le_max' := fun r s =>\n      calc\n        f (v (r + s)) \u2264 f (max (v r) (v s)) := hf (v.map_add r s)\n        _ = max (f (v r)) (f (v s)) := hf.map_max\n         }\n\n@[simp]\nlemma map_apply (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080) (hf : Monotone f) (v : Valuation R \u0393\u2080) (r : R) :\n    v.map f hf r = f (v r) := rfl\n\n/-- Two valuations on `R` are defined to be equivalent if they induce the same preorder on `R`. -/\ndef IsEquiv (v\u2081 : Valuation R \u0393\u2080) (v\u2082 : Valuation R \u0393'\u2080) : Prop :=\n  \u2200 r s, v\u2081 r \u2264 v\u2081 s \u2194 v\u2082 r \u2264 v\u2082 s\n\n@[simp]\ntheorem map_neg (x : R) : v (-x) = v x :=\n  v.toMonoidWithZeroHom.toMonoidHom.map_neg x\n\ntheorem map_sub_swap (x y : R) : v (x - y) = v (y - x) :=\n  v.toMonoidWithZeroHom.toMonoidHom.map_sub_swap x y\n\ntheorem map_sub (x y : R) : v (x - y) \u2264 max (v x) (v y) :=\n  calc\n    v (x - y) = v (x + -y) := by rw [sub_eq_add_neg]\n    _ \u2264 max (v x) (v <| -y) := v.map_add _ _\n    _ = max (v x) (v y) := by rw [map_neg]\n\ntheorem map_sub_le {x y g} (hx : v x \u2264 g) (hy : v y \u2264 g) : v (x - y) \u2264 g := by\n  rw [sub_eq_add_neg]\n  exact v.map_add_le hx (le_trans (le_of_eq (v.map_neg y)) hy)\n\nvariable {x y : R}\n\ntheorem map_add_of_distinct_val (h : v x \u2260 v y) : v (x + y) = max (v x) (v y) := by\n  suffices \u00acv (x + y) < max (v x) (v y) from\n    or_iff_not_imp_right.1 (le_iff_eq_or_lt.1 (v.map_add x y)) this\n  intro h'\n  wlog vyx : v y < v x generalizing x y\n  \u00b7 refine this h.symm ?_ (h.lt_or_lt.resolve_right vyx)\n    rwa [add_comm, max_comm]\n  rw [max_eq_left_of_lt vyx] at h'\n  apply lt_irrefl (v x)\n  calc\n    v x = v (x + y - y) := by simp\n    _ \u2264 max (v <| x + y) (v y) := map_sub _ _ _\n    _ < v x := max_lt h' vyx\n\ntheorem map_add_eq_of_lt_right (h : v x < v y) : v (x + y) = v y :=\n  (v.map_add_of_distinct_val h.ne).trans (max_eq_right_iff.mpr h.le)\n\ntheorem map_add_eq_of_lt_left (h : v y < v x) : v (x + y) = v x := by\n  rw [add_comm]; exact map_add_eq_of_lt_right _ h\n\ntheorem map_sub_eq_of_lt_right (h : v x < v y) : v (x - y) = v y := by\n  rw [sub_eq_add_neg, map_add_eq_of_lt_right, map_neg]\n  rwa [map_neg]\n\nopen scoped Classical in\ntheorem map_sum_eq_of_lt {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {j : \u03b9}\n    (hj : j \u2208 s) (h0 : v (f j) \u2260 0) (hf : \u2200 i \u2208 s \\ {j}, v (f i) < v (f j)) :\n    v (\u2211 i \u2208 s, f i) = v (f j) := by\n  rw [Finset.sum_eq_add_sum_diff_singleton hj]\n  exact map_add_eq_of_lt_left _ (map_sum_lt _ h0 hf)\n\ntheorem map_sub_eq_of_lt_left (h : v y < v x) : v (x - y) = v x := by\n  rw [sub_eq_add_neg, map_add_eq_of_lt_left]\n  rwa [map_neg]\n\ntheorem map_eq_of_sub_lt (h : v (y - x) < v x) : v y = v x := by\n  have := Valuation.map_add_of_distinct_val v (ne_of_gt h).symm\n  rw [max_eq_right (le_of_lt h)] at this\n  simpa using this\n\ntheorem map_one_add_of_lt (h : v x < 1) : v (1 + x) = 1 := by\n  rw [\u2190 v.map_one] at h\n  simpa only [v.map_one] using v.map_add_eq_of_lt_left h\n\ntheorem map_one_sub_of_lt (h : v x < 1) : v (1 - x) = 1 := by\n  rw [\u2190 v.map_one, \u2190 v.map_neg] at h\n  rw [sub_eq_add_neg 1 x]\n  simpa only [v.map_one, v.map_neg] using v.map_add_eq_of_lt_left h\n\n/-- An ordered monoid isomorphism `\u0393\u2080 \u2243 \u0393'\u2080` induces an equivalence\n`Valuation R \u0393\u2080 \u2243 Valuation R \u0393'\u2080`. -/\ndef congr (f : \u0393\u2080 \u2243*o \u0393'\u2080) : Valuation R \u0393\u2080 \u2243 Valuation R \u0393'\u2080 where\n  toFun := map f f.toOrderIso.monotone\n  invFun := map f.symm f.toOrderIso.symm.monotone\n  left_inv \u03bd := by ext; simp\n  right_inv \u03bd := by ext; simp\n\nend Monoid\n\nsection Group\n\nvariable [LinearOrderedCommGroupWithZero \u0393\u2080] (v : Valuation R \u0393\u2080) {x y : R}\n\ntheorem map_inv {R : Type*} [DivisionRing R] (v : Valuation R \u0393\u2080) : \u2200 x, v x\u207b\u00b9 = (v x)\u207b\u00b9 :=\n  map_inv\u2080 _\n\ntheorem map_div {R : Type*} [DivisionRing R] (v : Valuation R \u0393\u2080) : \u2200 x y, v (x / y) = v x / v y :=\n  map_div\u2080 _\n\ntheorem one_lt_val_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : 1 < v x \u2194 v x\u207b\u00b9 < 1 := by\n  simp [inv_lt_one\u2080 (v.pos_iff.2 h)]\n\ntheorem one_le_val_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : 1 \u2264 v x \u2194 v x\u207b\u00b9 \u2264 1 := by\n  simp [inv_le_one\u2080 (v.pos_iff.2 h)]\n\ntheorem val_lt_one_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : v x < 1 \u2194 1 < v x\u207b\u00b9 := by\n  simp [one_lt_inv\u2080 (v.pos_iff.2 h)]\n\ntheorem val_le_one_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : v x \u2264 1 \u2194 1 \u2264 v x\u207b\u00b9 := by\n  simp [one_le_inv\u2080 (v.pos_iff.2 h)]\n\ntheorem val_eq_one_iff (v : Valuation K \u0393\u2080) {x : K} : v x = 1 \u2194 v x\u207b\u00b9 = 1 := by\n  by_cases h : x = 0\n  \u00b7 simp only [map_inv\u2080, inv_eq_one]\n  \u00b7 simpa only [le_antisymm_iff, And.comm] using and_congr (one_le_val_iff v h) (val_le_one_iff v h)\n\ntheorem val_le_one_or_val_inv_lt_one (v : Valuation K \u0393\u2080) (x : K) : v x \u2264 1 \u2228 v x\u207b\u00b9 < 1 := by\n  by_cases h : x = 0\n  \u00b7 simp only [h, _root_.map_zero, zero_le', inv_zero, zero_lt_one, or_self]\n  \u00b7 simp only [\u2190 one_lt_val_iff v h, le_or_lt]\n\n/--\nThis theorem is a weaker version of `Valuation.val_le_one_or_val_inv_lt_one`, but more symmetric\nin `x` and `x\u207b\u00b9`.\n-/\ntheorem val_le_one_or_val_inv_le_one (v : Valuation K \u0393\u2080) (x : K) : v x \u2264 1 \u2228 v x\u207b\u00b9 \u2264 1 := by\n  by_cases h : x = 0\n  \u00b7 simp only [h, _root_.map_zero, zero_le', inv_zero, or_self]\n  \u00b7 simp only [\u2190 one_le_val_iff v h, le_total]\n\n/-- The subgroup of elements whose valuation is less than a certain unit. -/\ndef ltAddSubgroup (v : Valuation R \u0393\u2080) (\u03b3 : \u0393\u2080\u02e3) : AddSubgroup R where\n  carrier := { x | v x < \u03b3 }\n  zero_mem' := by simp\n  add_mem' {x y} x_in y_in := lt_of_le_of_lt (v.map_add x y) (max_lt x_in y_in)\n  neg_mem' x_in := by rwa [Set.mem_setOf, map_neg]\n\nend Group\n\nend Basic\n\n-- end of section\nnamespace IsEquiv\n\nvariable [Ring R] [LinearOrderedCommMonoidWithZero \u0393\u2080] [LinearOrderedCommMonoidWithZero \u0393'\u2080]\n  {v : Valuation R \u0393\u2080} {v\u2081 : Valuation R \u0393\u2080} {v\u2082 : Valuation R \u0393'\u2080} {v\u2083 : Valuation R \u0393''\u2080}\n\n@[refl]\ntheorem refl : v.IsEquiv v := fun _ _ => Iff.refl _\n\n@[symm]\ntheorem symm (h : v\u2081.IsEquiv v\u2082) : v\u2082.IsEquiv v\u2081 := fun _ _ => Iff.symm (h _ _)\n\n@[trans]\ntheorem trans (h\u2081\u2082 : v\u2081.IsEquiv v\u2082) (h\u2082\u2083 : v\u2082.IsEquiv v\u2083) : v\u2081.IsEquiv v\u2083 := fun _ _ =>\n  Iff.trans (h\u2081\u2082 _ _) (h\u2082\u2083 _ _)\n\ntheorem of_eq {v' : Valuation R \u0393\u2080} (h : v = v') : v.IsEquiv v' := by subst h; rfl\n\ntheorem map {v' : Valuation R \u0393\u2080} (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080) (hf : Monotone f) (inf : Injective f)\n    (h : v.IsEquiv v') : (v.map f hf).IsEquiv (v'.map f hf) :=\n  let H : StrictMono f := hf.strictMono_of_injective inf\n  fun r s =>\n  calc\n    f (v r) \u2264 f (v s) \u2194 v r \u2264 v s := by rw [H.le_iff_le]\n    _ \u2194 v' r \u2264 v' s := h r s\n    _ \u2194 f (v' r) \u2264 f (v' s) := by rw [H.le_iff_le]\n\n/-- `comap` preserves equivalence. -/\ntheorem comap {S : Type*} [Ring S] (f : S \u2192+* R) (h : v\u2081.IsEquiv v\u2082) :\n    (v\u2081.comap f).IsEquiv (v\u2082.comap f) := fun r s => h (f r) (f s)\n\ntheorem val_eq (h : v\u2081.IsEquiv v\u2082) {r s : R} : v\u2081 r = v\u2081 s \u2194 v\u2082 r = v\u2082 s := by\n  simpa only [le_antisymm_iff] using and_congr (h r s) (h s r)\n\ntheorem ne_zero (h : v\u2081.IsEquiv v\u2082) {r : R} : v\u2081 r \u2260 0 \u2194 v\u2082 r \u2260 0 := by\n  have : v\u2081 r \u2260 v\u2081 0 \u2194 v\u2082 r \u2260 v\u2082 0 := not_congr h.val_eq\n  rwa [v\u2081.map_zero, v\u2082.map_zero] at this\n\nend IsEquiv\n\n-- end of namespace\nsection\n\ntheorem isEquiv_of_map_strictMono [LinearOrderedCommMonoidWithZero \u0393\u2080]\n    [LinearOrderedCommMonoidWithZero \u0393'\u2080] [Ring R] {v : Valuation R \u0393\u2080} (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080)\n    (H : StrictMono f) : IsEquiv (v.map f H.monotone) v := fun _x _y =>\n  \u27e8H.le_iff_le.mp, fun h => H.monotone h\u27e9\n\ntheorem isEquiv_iff_val_lt_val [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x y : K}, v x < v y \u2194 v' x < v' y := by\n  simp only [IsEquiv, le_iff_le_iff_lt_iff_lt]\n  exact forall_comm\n\nalias \u27e8IsEquiv.lt_iff_lt, _\u27e9 := isEquiv_iff_val_lt_val\n\ntheorem isEquiv_of_val_le_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080}\n    (h : \u2200 {x : K}, v x \u2264 1 \u2194 v' x \u2264 1) : v.IsEquiv v' := by\n  intro x y\n  obtain rfl | hy := eq_or_ne y 0\n  \u00b7 simp\n  \u00b7 rw [\u2190 div_le_one\u2080, \u2190 v.map_div, h, v'.map_div, div_le_one\u2080] <;>\n      rwa [zero_lt_iff, ne_zero_iff]\n\ntheorem isEquiv_iff_val_le_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v x \u2264 1 \u2194 v' x \u2264 1 :=\n  \u27e8fun h x => by simpa using h x 1, isEquiv_of_val_le_one\u27e9\n\nalias \u27e8IsEquiv.le_one_iff_le_one, _\u27e9 := isEquiv_iff_val_le_one\n\ntheorem isEquiv_iff_val_eq_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v x = 1 \u2194 v' x = 1 := by\n  constructor\n  \u00b7 intro h x\n    simpa using @IsEquiv.val_eq _ _ _ _ _ _ v v' h x 1\n  \u00b7 intro h\n    apply isEquiv_of_val_le_one\n    intro x\n    constructor\n    \u00b7 intro hx\n      rcases lt_or_eq_of_le hx with hx' | hx'\n      \u00b7 have : v (1 + x) = 1 := by\n          rw [\u2190 v.map_one]\n          apply map_add_eq_of_lt_left\n          simpa\n        rw [h] at this\n        rw [show x = -1 + (1 + x) by simp]\n        refine le_trans (v'.map_add _ _) ?_\n        simp [this]\n      \u00b7 rw [h] at hx'\n        exact le_of_eq hx'\n    \u00b7 intro hx\n      rcases lt_or_eq_of_le hx with hx' | hx'\n      \u00b7 have : v' (1 + x) = 1 := by\n          rw [\u2190 v'.map_one]\n          apply map_add_eq_of_lt_left\n          simpa\n        rw [\u2190 h] at this\n        rw [show x = -1 + (1 + x) by simp]\n        refine le_trans (v.map_add _ _) ?_\n        simp [this]\n      \u00b7 rw [\u2190 h] at hx'\n        exact le_of_eq hx'\n\nalias \u27e8IsEquiv.eq_one_iff_eq_one, _\u27e9 := isEquiv_iff_val_eq_one\n\ntheorem isEquiv_iff_val_lt_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v x < 1 \u2194 v' x < 1 := by\n  constructor\n  \u00b7 intro h x\n    simp only [lt_iff_le_and_ne,\n      and_congr h.le_one_iff_le_one h.eq_one_iff_eq_one.not]\n  \u00b7 rw [isEquiv_iff_val_eq_one]\n    intro h x\n    by_cases hx : x = 0\n    \u00b7 simp only [(zero_iff _).2 hx, zero_ne_one]\n    constructor\n    \u00b7 intro hh\n      by_contra h_1\n      cases ne_iff_lt_or_gt.1 h_1 with\n      | inl h_2 => simpa [hh, lt_self_iff_false] using h.2 h_2\n      | inr h_2 =>\n          rw [\u2190 inv_one, \u2190 inv_eq_iff_eq_inv, \u2190 map_inv\u2080] at hh\n          exact hh.not_lt (h.2 ((one_lt_val_iff v' hx).1 h_2))\n    \u00b7 intro hh\n      by_contra h_1\n      cases ne_iff_lt_or_gt.1 h_1 with\n      | inl h_2 => simpa [hh, lt_self_iff_false] using h.1 h_2\n      | inr h_2 =>\n        rw [\u2190 inv_one, \u2190 inv_eq_iff_eq_inv, \u2190 map_inv\u2080] at hh\n        exact hh.not_lt (h.1 ((one_lt_val_iff v hx).1 h_2))\n\nalias \u27e8IsEquiv.lt_one_iff_lt_one, _\u27e9 := isEquiv_iff_val_lt_one\n\ntheorem isEquiv_iff_val_sub_one_lt_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v (x - 1) < 1 \u2194 v' (x - 1) < 1 := by\n  rw [isEquiv_iff_val_lt_one]\n  exact (Equiv.subRight 1).surjective.forall\n\nalias \u27e8IsEquiv.val_sub_one_lt_one_iff, _\u27e9 := isEquiv_iff_val_sub_one_lt_one\n\ntheorem isEquiv_tfae [LinearOrderedCommGroupWithZero \u0393\u2080] [LinearOrderedCommGroupWithZero \u0393'\u2080]\n    (v : Valuation K \u0393\u2080) (v' : Valuation K \u0393'\u2080) :\n    [ v.IsEquiv v',\n      \u2200 {x y}, v x < v y \u2194 v' x < v' y,\n      \u2200 {x}, v x \u2264 1 \u2194 v' x \u2264 1,\n      \u2200 {x}, v x = 1 \u2194 v' x = 1,\n      \u2200 {x}, v x < 1 \u2194 v' x < 1,\n      \u2200 {x}, v (x - 1) < 1 \u2194 v' (x - 1) < 1 ].TFAE := by\n  tfae_have 1 \u2194 2 := isEquiv_iff_val_lt_val\n  tfae_have 1 \u2194 3 := isEquiv_iff_val_le_one\n  tfae_have 1 \u2194 4 := isEquiv_iff_val_eq_one\n  tfae_have 1 \u2194 5 := isEquiv_iff_val_lt_one\n  tfae_have 1 \u2194 6 := isEquiv_iff_val_sub_one_lt_one\n  tfae_finish\n\nend\n\nsection Supp\n\nvariable [CommRing R] [LinearOrderedCommMonoidWithZero \u0393\u2080] (v : Valuation R \u0393\u2080)\n\n/-- The support of a valuation `v : R \u2192 \u0393\u2080` is the ideal of `R` where `v` vanishes. -/\ndef supp : Ideal R where\n  carrier := { x | v x = 0 }\n  zero_mem' := map_zero v\n  add_mem' {x y} hx hy := le_zero_iff.mp <|\n    calc\n      v (x + y) \u2264 max (v x) (v y) := v.map_add x y\n      _ \u2264 0 := max_le (le_zero_iff.mpr hx) (le_zero_iff.mpr hy)\n  smul_mem' c x hx :=\n    calc\n      v (c * x) = v c * v x := map_mul v c x\n      _ = v c * 0 := congr_arg _ hx\n      _ = 0 := mul_zero _\n\n@[simp]\ntheorem mem_supp_iff (x : R) : x \u2208 supp v \u2194 v x = 0 :=\n  Iff.rfl\n\n/-- The support of a valuation is a prime ideal. -/\ninstance [Nontrivial \u0393\u2080] [NoZeroDivisors \u0393\u2080] : Ideal.IsPrime (supp v) :=\n  \u27e8fun h =>\n    one_ne_zero (\u03b1 := \u0393\u2080) <|\n      calc\n        1 = v 1 := v.map_one.symm\n        _ = 0 := by rw [\u2190 mem_supp_iff, h]; exact Submodule.mem_top,\n   fun {x y} hxy => by\n    simp only [mem_supp_iff] at hxy \u22a2\n    rw [v.map_mul x y] at hxy\n    exact eq_zero_or_eq_zero_of_mul_eq_zero hxy\u27e9\n\ntheorem map_add_supp (a : R) {s : R} (h : s \u2208 supp v) : v (a + s) = v a := by\n  have aux : \u2200 a s, v s = 0 \u2192 v (a + s) \u2264 v a := by\n    intro a' s' h'\n    refine le_trans (v.map_add a' s') (max_le le_rfl ?_)\n    simp [h']\n  apply le_antisymm (aux a s h)\n  calc\n    v a = v (a + s + -s) := by simp\n    _ \u2264 v (a + s) := aux (a + s) (-s) (by rwa [\u2190 Ideal.neg_mem_iff] at h)\n\ntheorem comap_supp {S : Type*} [CommRing S] (f : S \u2192+* R) :\n    supp (v.comap f) = Ideal.comap f v.supp :=\n  Ideal.ext fun x => by rw [mem_supp_iff, Ideal.mem_comap, mem_supp_iff, comap_apply]\n\nend Supp\n\n-- end of section\nend Valuation\n\nsection AddMonoid\n\nvariable (R) [Ring R] (\u0393\u2080 : Type*) [LinearOrderedAddCommMonoidWithTop \u0393\u2080]\n\n/-- The type of `\u0393\u2080`-valued additive valuations on `R`. -/\ndef AddValuation :=\n  Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48)\n\nend AddMonoid\n\nnamespace AddValuation\n\nvariable {\u0393\u2080 : Type*} {\u0393'\u2080 : Type*}\n\nsection Basic\n\nsection Monoid\n\n/-- A valuation is coerced to the underlying function `R \u2192 \u0393\u2080`. -/\ninstance (R) (\u0393\u2080) [Ring R] [LinearOrderedAddCommMonoidWithTop \u0393\u2080] :\n    FunLike (AddValuation R \u0393\u2080) R \u0393\u2080 where\n  coe v := v.toMonoidWithZeroHom.toFun\n  coe_injective' f g := by cases f; cases g; simp (config := {contextual := true})\n\nvariable [Ring R] [LinearOrderedAddCommMonoidWithTop \u0393\u2080] [LinearOrderedAddCommMonoidWithTop \u0393'\u2080]\n  (v : AddValuation R \u0393\u2080)\n\nsection\n\nvariable (f : R \u2192 \u0393\u2080) (h0 : f 0 = \u22a4) (h1 : f 1 = 0)\nvariable (hadd : \u2200 x y, min (f x) (f y) \u2264 f (x + y)) (hmul : \u2200 x y, f (x * y) = f x + f y)\n\n/-- An alternate constructor of `AddValuation`, that doesn't reference `Multiplicative \u0393\u2080\u1d52\u1d48` -/\ndef of : AddValuation R \u0393\u2080 where\n  toFun := f\n  map_one' := h1\n  map_zero' := h0\n  map_add_le_max' := hadd\n  map_mul' := hmul\n\nvariable {h0} {h1} {hadd} {hmul} {r : R}\n\n@[simp]\ntheorem of_apply : (of f h0 h1 hadd hmul) r = f r := rfl\n\n/-- The `Valuation` associated to an `AddValuation` (useful if the latter is constructed using\n`AddValuation.of`). -/\ndef toValuation : AddValuation R \u0393\u2080 \u2243 Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48) :=\n  Equiv.refl _\n\n@[deprecated (since := \"2024-11-09\")]\nalias valuation := toValuation\n\n/-- The `AddValuation` associated to a `Valuation`.\n-/\ndef ofValuation : Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48) \u2243 AddValuation R \u0393\u2080 :=\n  Equiv.refl _\n\n@[simp]\nlemma ofValuation_symm_eq : ofValuation.symm = toValuation (R := R) (\u0393\u2080 := \u0393\u2080) := rfl\n\n@[simp]\nlemma toValuation_symm_eq : toValuation.symm = ofValuation (R := R) (\u0393\u2080 := \u0393\u2080) := rfl\n\n", "theoremStatement": "@[simp]\nlemma ofValuation_toValuation : ofValuation (toValuation v) = v ", "theoremName": "AddValuation.ofValuation_toValuation", "fileCreated": {"commit": "a9138cdba12f2110c86195f5eac26cb36dee2627", "date": "2023-03-17"}, "theoremCreated": {"commit": "625ac34a53dfa0eca4fb8a3a933409238e4f43f0", "date": "2024-12-16"}, "file": "mathlib/Mathlib/RingTheory/Valuation/Basic.lean", "module": "Mathlib.RingTheory.Valuation.Basic", "jsonFile": "Mathlib.RingTheory.Valuation.Basic.jsonl", "positionMetadata": {"lineInFile": 666, "tokenPositionInFile": 23160, "theoremPositionInFile": 77}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 12, "numPremises": 14}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "/-\nCopyright (c) 2024 Fangming Li. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Fangming Li, Jujian Zhang\n-/\nimport Mathlib.Algebra.Polynomial.AlgebraMap\nimport Mathlib.Algebra.Polynomial.Eval.SMul\nimport Mathlib.Algebra.Polynomial.Roots\nimport Mathlib.Order.Interval.Set.Infinite\nimport Mathlib.RingTheory.Polynomial.Pochhammer\nimport Mathlib.RingTheory.PowerSeries.WellKnown\nimport Mathlib.Tactic.FieldSimp\n\n/-!\n# Hilbert polynomials\n\nIn this file, we formalise the following statement: if `F` is a field with characteristic `0`, then\ngiven any `p : F[X]` and `d : \u2115`, there exists some `h : F[X]` such that for any large enough\n`n : \u2115`, `h(n)` is equal to the coefficient of `X\u207f` in the power series expansion of `p/(1 - X)\u1d48`.\nThis `h` is unique and is denoted as `Polynomial.hilbertPoly p d`.\n\nFor example, given `d : \u2115`, the power series expansion of `1/(1 - X)\u1d48\u207a\u00b9` in `F[X]`\nis `\u03a3\u2099 ((d + n).choose d)X\u207f`, which equals `\u03a3\u2099 ((n + 1)\u00b7\u00b7\u00b7(n + d)/d!)X\u207f` and hence\n`Polynomial.hilbertPoly (1 : F[X]) (d + 1)` is the polynomial `(X + 1)\u00b7\u00b7\u00b7(X + d)/d!`. Note that\nif `d! = 0` in `F`, then the polynomial `(X + 1)\u00b7\u00b7\u00b7(X + d)/d!` no longer works, so we do not want\nthe characteristic of `F` to be divisible by `d!`. As `Polynomial.hilbertPoly` may take any\n`p : F[X]` and `d : \u2115` as its inputs, it is necessary for us to assume that `CharZero F`.\n\n## Main definitions\n\n* `Polynomial.hilbertPoly p d`. Given a field `F`, a polynomial `p : F[X]` and a natural number `d`,\n  if `F` is of characteristic `0`, then `Polynomial.hilbertPoly p d : F[X]` is the polynomial whose\n  value at `n` equals the coefficient of `X\u207f` in the power series expansion of `p/(1 - X)\u1d48`.\n\n## TODO\n\n* Hilbert polynomials of finitely generated graded modules over Noetherian rings.\n-/\n\nopen Nat PowerSeries\n\nvariable (F : Type*) [Field F]\n\nnamespace Polynomial\n\n/--\nFor any field `F` and natural numbers `d` and `k`, `Polynomial.preHilbertPoly F d k`\nis defined as `(d.factorial : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (X - (C (k : F)) + 1))`.\nThis is the most basic form of Hilbert polynomials. `Polynomial.preHilbertPoly \u211a d 0`\nis exactly the Hilbert polynomial of the polynomial ring `\u211a[X_0,...,X_d]` viewed as\na graded module over itself. In fact, `Polynomial.preHilbertPoly F d k` is the\nsame as `Polynomial.hilbertPoly ((X : F[X]) ^ k) (d + 1)` for any field `F` and\n`d k : \u2115` (see the lemma `Polynomial.hilbertPoly_X_pow_succ`). See also the lemma\n`Polynomial.preHilbertPoly_eq_choose_sub_add`, which states that if `CharZero F`,\nthen for any `d k n : \u2115` with `k \u2264 n`, `(Polynomial.preHilbertPoly F d k).eval (n : F)`\nequals `(n - k + d).choose d`.\n-/\nnoncomputable def preHilbertPoly (d k : \u2115) : F[X] :=\n  (d.factorial : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (Polynomial.X - (C (k : F)) + 1))\n\nlemma natDegree_preHilbertPoly [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).natDegree = d := by\n  have hne : (d ! : F) \u2260 0 := by norm_cast; positivity\n  rw [preHilbertPoly, natDegree_smul _ (inv_ne_zero hne), natDegree_comp, ascPochhammer_natDegree,\n    add_comm_sub, \u2190 C_1, \u2190 map_sub, natDegree_add_C, natDegree_X, mul_one]\n\nlemma coeff_preHilbertPoly_self [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).coeff d = (d ! : F)\u207b\u00b9 := by\n  delta preHilbertPoly\n  have hne : (d ! : F) \u2260 0 := by norm_cast; positivity\n  have heq : d = ((ascPochhammer F d).comp (X - C (k : F) + 1)).natDegree :=\n    (natDegree_preHilbertPoly F d k).symm.trans (natDegree_smul _ (inv_ne_zero hne))\n  nth_rw 3 [heq]\n  calc\n  _ = (d ! : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (X - C ((k : F) - 1))).leadingCoeff := by\n    simp only [sub_add, \u2190 C_1, \u2190 map_sub, coeff_smul, coeff_natDegree]\n  _ = (d ! : F)\u207b\u00b9 := by\n    simp only [leadingCoeff_comp (ne_of_eq_of_ne (natDegree_X_sub_C _) one_ne_zero), Monic.def.1\n      (monic_ascPochhammer _ _), one_mul, leadingCoeff_X_sub_C, one_pow, smul_eq_mul, mul_one]\n\nlemma leadingCoeff_preHilbertPoly [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).leadingCoeff = (d ! : F)\u207b\u00b9 := by\n  rw [leadingCoeff, natDegree_preHilbertPoly, coeff_preHilbertPoly_self]\n\nlemma preHilbertPoly_eq_choose_sub_add [CharZero F] (d : \u2115) {k n : \u2115} (hkn : k \u2264 n):\n    (preHilbertPoly F d k).eval (n : F) = (n - k + d).choose d := by\n  have : (d ! : F) \u2260 0 := by norm_cast; positivity\n  calc\n  _ = (\u2191d !)\u207b\u00b9 * eval (\u2191(n - k + 1)) (ascPochhammer F d) := by simp [cast_sub hkn, preHilbertPoly]\n  _ = (n - k + d).choose d := by\n    rw [ascPochhammer_nat_eq_natCast_ascFactorial];\n    field_simp [ascFactorial_eq_factorial_mul_choose]\n\nvariable {F}\n\n/--\n`Polynomial.hilbertPoly p 0 = 0`; for any `d : \u2115`, `Polynomial.hilbertPoly p (d + 1)`\nis defined as `\u2211 i \u2208 p.support, (p.coeff i) \u2022 Polynomial.preHilbertPoly F d i`. If\n`M` is a graded module whose Poincar\u00e9 series can be written as `p(X)/(1 - X)\u1d48` for some\n`p : \u211a[X]` with integer coefficients, then `Polynomial.hilbertPoly p d` is the Hilbert\npolynomial of `M`. See also `Polynomial.coeff_mul_invOneSubPow_eq_hilbertPoly_eval`,\nwhich says that `PowerSeries.coeff F n (p * PowerSeries.invOneSubPow F d)` equals\n`(Polynomial.hilbertPoly p d).eval (n : F)` for any large enough `n : \u2115`.\n-/\nnoncomputable def hilbertPoly (p : F[X]) : (d : \u2115) \u2192 F[X]\n  | 0 => 0\n  | d + 1 => \u2211 i \u2208 p.support, (p.coeff i) \u2022 preHilbertPoly F d i\n\nlemma hilbertPoly_zero_left (d : \u2115) : hilbertPoly (0 : F[X]) d = 0 := by\n  delta hilbertPoly; induction d with\n  | zero => simp only\n  | succ d _ => simp only [coeff_zero, zero_smul, Finset.sum_const_zero]\n\n", "theoremStatement": "lemma hilbertPoly_zero_right (p : F[X]) : hilbertPoly p 0 = 0 ", "theoremName": "Polynomial.hilbertPoly_zero_right", "fileCreated": {"commit": "561e050467d2caa2e4ea5d81ca62600bf268b747", "date": "2024-12-02"}, "theoremCreated": {"commit": "e0cf109cd53a9eab08403037e1190790ed020a9d", "date": "2024-12-20"}, "file": "mathlib/Mathlib/RingTheory/Polynomial/HilbertPoly.lean", "module": "Mathlib.RingTheory.Polynomial.HilbertPoly", "jsonFile": "Mathlib.RingTheory.Polynomial.HilbertPoly.jsonl", "positionMetadata": {"lineInFile": 114, "tokenPositionInFile": 5488, "theoremPositionInFile": 6}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 7, "numPremises": 13}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "/-\nCopyright (c) 2024 Ya\u00ebl Dillies. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Ya\u00ebl Dillies, Bhavik Mehta\n-/\nimport Mathlib.Algebra.Group.Subgroup.Pointwise\nimport Mathlib.Combinatorics.Additive.CovBySMul\nimport Mathlib.Combinatorics.Additive.RuzsaCovering\nimport Mathlib.Combinatorics.Additive.SmallTripling\n\n/-!\n# Approximate subgroups\n\nThis file defines approximate subgroups of a group, namely symmetric sets `A` such that `A * A` can\nbe covered by a small number of translates of `A`.\n\n## Main results\n\nApproximate subgroups are a central concept in additive combinatorics, as a natural weakening and\nflexible substitute of genuine subgroups. As such, they share numerous properties with subgroups:\n* `IsApproximateSubgroup.image`: Group homomorphisms send approximate subgroups to approximate\n  subgroups\n* `IsApproximateSubgroup.pow_inter_pow`: The intersection of (non-trivial powers of) two approximate\n  subgroups is an approximate subgroup. Warning: The intersection of two approximate subgroups isn't\n  an approximate subgroup in general.\n\nApproximate subgroups are close qualitatively and quantitatively to other concepts in additive\ncombinatorics:\n* `IsApproximateSubgroup.card_pow_le`: An approximate subgroup has small powers.\n* `IsApproximateSubgroup.of_small_tripling`: A set of small tripling can be made an approximate\n  subgroup by squaring.\n\nIt can be readily confirmed that approximate subgroups are a weakening of subgroups:\n* `isApproximateSubgroup_one`: A 1-approximate subgroup is the same thing as a subgroup.\n-/\n\nopen scoped Finset Pointwise\n\nvariable {G : Type*} [Group G] {A B : Set G} {K L : \u211d} {m n : \u2115}\n\n/--\nAn approximate subgroup in a group is a symmetric set `A` containing the identity and such that\n`A + A` can be covered by a small number of translates of `A`.\n\nIn practice, we will take `K` fixed and `A` large but finite.\n-/\nstructure IsApproximateAddSubgroup {G : Type*} [AddGroup G] (K : \u211d) (A : Set G) : Prop where\n  zero_mem : 0 \u2208 A\n  neg_eq_self : -A = A\n  two_nsmul_covByVAdd : CovByVAdd G K (2 \u2022 A) A\n\n/--\nAn approximate subgroup in a group is a symmetric set `A` containing the identity and such that\n`A * A` can be covered by a small number of translates of `A`.\n\nIn practice, we will take `K` fixed and `A` large but finite.\n-/\n@[to_additive]\nstructure IsApproximateSubgroup (K : \u211d) (A : Set G) : Prop where\n  one_mem : 1 \u2208 A\n  inv_eq_self : A\u207b\u00b9 = A\n  sq_covBySMul : CovBySMul G K (A ^ 2) A\n\nnamespace IsApproximateSubgroup\n\n@[to_additive] lemma nonempty (hA : IsApproximateSubgroup K A) : A.Nonempty := \u27e81, hA.one_mem\u27e9\n\n@[to_additive one_le]\nlemma one_le (hA : IsApproximateSubgroup K A) : 1 \u2264 K := by\n  obtain \u27e8F, hF, hSF\u27e9 := hA.sq_covBySMul\n  have hF\u2080 : F \u2260 \u2205 := by rintro rfl; simp [hA.nonempty.pow.ne_empty] at hSF\n  exact hF.trans' <| by simpa [Finset.nonempty_iff_ne_empty]\n\n@[to_additive]\nlemma mono (hKL : K \u2264 L) (hA : IsApproximateSubgroup K A) : IsApproximateSubgroup L A where\n  one_mem := hA.one_mem\n  inv_eq_self := hA.inv_eq_self\n  sq_covBySMul := hA.sq_covBySMul.mono hKL\n\n@[to_additive]\nlemma card_pow_le [DecidableEq G] {A : Finset G} (hA : IsApproximateSubgroup K (A : Set G)) :\n    \u2200 {n}, #(A ^ n) \u2264 K ^ (n - 1) * #A\n  | 0 => by simpa using hA.nonempty\n  | 1 => by simp\n  | n + 2 => by\n    obtain \u27e8F, hF, hSF\u27e9 := hA.sq_covBySMul\n    calc\n      (#(A ^ (n + 2)) : \u211d) \u2264 #(F ^ (n + 1) * A) := by\n        gcongr; exact mod_cast Set.pow_subset_pow_mul_of_sq_subset_mul hSF (by omega)\n      _ \u2264 #(F ^ (n + 1)) * #A := mod_cast Finset.card_mul_le\n      _ \u2264 #F ^ (n + 1) * #A := by gcongr; exact mod_cast Finset.card_pow_le\n      _ \u2264 K ^ (n + 1) * #A := by gcongr\n\n", "theoremStatement": "@[to_additive]\nlemma card_mul_self_le [DecidableEq G] {A : Finset G} (hA : IsApproximateSubgroup K (A : Set G)) :\n    #(A * A) \u2264 K * #A ", "theoremName": "IsApproximateSubgroup.card_mul_self_le", "fileCreated": {"commit": "781c75b11cc46547f0f22ec4d138080a85b659ba", "date": "2025-01-11"}, "theoremCreated": {"commit": "781c75b11cc46547f0f22ec4d138080a85b659ba", "date": "2025-01-11"}, "file": "mathlib/Mathlib/Combinatorics/Additive/ApproximateSubgroup.lean", "module": "Mathlib.Combinatorics.Additive.ApproximateSubgroup", "jsonFile": "Mathlib.Combinatorics.Additive.ApproximateSubgroup.jsonl", "positionMetadata": {"lineInFile": 94, "tokenPositionInFile": 3683, "theoremPositionInFile": 2}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 20, "numPremises": 33}, "proofMetadata": {"hasProof": true, "proof": ":= by simpa [sq] using hA.card_pow_le (n := 2)", "proofType": "tactic", "proofLengthLines": 0, "proofLengthTokens": 46}}
{"srcContext": "/-\nCopyright (c) 2018 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes, Abhimanyu Pallavi Sudhir, Jean Lo, Calle S\u00f6nne, S\u00e9bastien Gou\u00ebzel,\n  R\u00e9my Degenne\n-/\nimport Mathlib.Analysis.SpecialFunctions.Pow.Continuity\nimport Mathlib.Analysis.SpecialFunctions.Complex.LogDeriv\nimport Mathlib.Analysis.Calculus.FDeriv.Extend\nimport Mathlib.Analysis.Calculus.Deriv.Prod\nimport Mathlib.Analysis.SpecialFunctions.Log.Deriv\nimport Mathlib.Analysis.SpecialFunctions.Trigonometric.Deriv\n\n/-!\n# Derivatives of power function on `\u2102`, `\u211d`, `\u211d\u22650`, and `\u211d\u22650\u221e`\n\nWe also prove differentiability and provide derivatives for the power functions `x ^ y`.\n-/\n\n\nnoncomputable section\n\nopen scoped Real Topology NNReal ENNReal\nopen Filter\n\nnamespace Complex\n\ntheorem hasStrictFDerivAt_cpow {p : \u2102 \u00d7 \u2102} (hp : p.1 \u2208 slitPlane) :\n    HasStrictFDerivAt (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2)\n      ((p.2 * p.1 ^ (p.2 - 1)) \u2022 ContinuousLinearMap.fst \u2102 \u2102 \u2102 +\n        (p.1 ^ p.2 * log p.1) \u2022 ContinuousLinearMap.snd \u2102 \u2102 \u2102) p := by\n  have A : p.1 \u2260 0 := slitPlane_ne_zero hp\n  have : (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2) =\u1da0[\ud835\udcdd p] fun x => exp (log x.1 * x.2) :=\n    ((isOpen_ne.preimage continuous_fst).eventually_mem A).mono fun p hp =>\n      cpow_def_of_ne_zero hp _\n  rw [cpow_sub _ _ A, cpow_one, mul_div_left_comm, mul_smul, mul_smul]\n  refine HasStrictFDerivAt.congr_of_eventuallyEq ?_ this.symm\n  simpa only [cpow_def_of_ne_zero A, div_eq_mul_inv, mul_smul, add_comm, smul_add] using\n    ((hasStrictFDerivAt_fst.clog hp).mul hasStrictFDerivAt_snd).cexp\n\ntheorem hasStrictFDerivAt_cpow' {x y : \u2102} (hp : x \u2208 slitPlane) :\n    HasStrictFDerivAt (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2)\n      ((y * x ^ (y - 1)) \u2022 ContinuousLinearMap.fst \u2102 \u2102 \u2102 +\n        (x ^ y * log x) \u2022 ContinuousLinearMap.snd \u2102 \u2102 \u2102) (x, y) :=\n  @hasStrictFDerivAt_cpow (x, y) hp\n\ntheorem hasStrictDerivAt_const_cpow {x y : \u2102} (h : x \u2260 0 \u2228 y \u2260 0) :\n    HasStrictDerivAt (fun y => x ^ y) (x ^ y * log x) y := by\n  rcases em (x = 0) with (rfl | hx)\n  \u00b7 replace h := h.neg_resolve_left rfl\n    rw [log_zero, mul_zero]\n    refine (hasStrictDerivAt_const y 0).congr_of_eventuallyEq ?_\n    exact (isOpen_ne.eventually_mem h).mono fun y hy => (zero_cpow hy).symm\n  \u00b7 simpa only [cpow_def_of_ne_zero hx, mul_one] using\n      ((hasStrictDerivAt_id y).const_mul (log x)).cexp\n\ntheorem hasFDerivAt_cpow {p : \u2102 \u00d7 \u2102} (hp : p.1 \u2208 slitPlane) :\n    HasFDerivAt (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2)\n      ((p.2 * p.1 ^ (p.2 - 1)) \u2022 ContinuousLinearMap.fst \u2102 \u2102 \u2102 +\n        (p.1 ^ p.2 * log p.1) \u2022 ContinuousLinearMap.snd \u2102 \u2102 \u2102) p :=\n  (hasStrictFDerivAt_cpow hp).hasFDerivAt\n\nend Complex\n\nsection fderiv\n\nopen Complex\n\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f g : E \u2192 \u2102} {f' g' : E \u2192L[\u2102] \u2102}\n  {x : E} {s : Set E} {c : \u2102}\n\ntheorem HasStrictFDerivAt.cpow (hf : HasStrictFDerivAt f f' x) (hg : HasStrictFDerivAt g g' x)\n    (h0 : f x \u2208 slitPlane) : HasStrictFDerivAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) \u2022 f' + (f x ^ g x * Complex.log (f x)) \u2022 g') x := by\n  convert (@hasStrictFDerivAt_cpow ((fun x => (f x, g x)) x) h0).comp x (hf.prod hg)\n\ntheorem HasStrictFDerivAt.const_cpow (hf : HasStrictFDerivAt f f' x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasStrictFDerivAt (fun x => c ^ f x) ((c ^ f x * Complex.log c) \u2022 f') x :=\n  (hasStrictDerivAt_const_cpow h0).comp_hasStrictFDerivAt x hf\n\ntheorem HasFDerivAt.cpow (hf : HasFDerivAt f f' x) (hg : HasFDerivAt g g' x)\n    (h0 : f x \u2208 slitPlane) : HasFDerivAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) \u2022 f' + (f x ^ g x * Complex.log (f x)) \u2022 g') x := by\n  convert (@Complex.hasFDerivAt_cpow ((fun x => (f x, g x)) x) h0).comp x (hf.prod hg)\n\ntheorem HasFDerivAt.const_cpow (hf : HasFDerivAt f f' x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasFDerivAt (fun x => c ^ f x) ((c ^ f x * Complex.log c) \u2022 f') x :=\n  (hasStrictDerivAt_const_cpow h0).hasDerivAt.comp_hasFDerivAt x hf\n\ntheorem HasFDerivWithinAt.cpow (hf : HasFDerivWithinAt f f' s x) (hg : HasFDerivWithinAt g g' s x)\n    (h0 : f x \u2208 slitPlane) : HasFDerivWithinAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) \u2022 f' + (f x ^ g x * Complex.log (f x)) \u2022 g') s x := by\n  convert\n    (@Complex.hasFDerivAt_cpow ((fun x => (f x, g x)) x) h0).comp_hasFDerivWithinAt x (hf.prod hg)\n\ntheorem HasFDerivWithinAt.const_cpow (hf : HasFDerivWithinAt f f' s x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasFDerivWithinAt (fun x => c ^ f x) ((c ^ f x * Complex.log c) \u2022 f') s x :=\n  (hasStrictDerivAt_const_cpow h0).hasDerivAt.comp_hasFDerivWithinAt x hf\n\ntheorem DifferentiableAt.cpow (hf : DifferentiableAt \u2102 f x) (hg : DifferentiableAt \u2102 g x)\n    (h0 : f x \u2208 slitPlane) : DifferentiableAt \u2102 (fun x => f x ^ g x) x :=\n  (hf.hasFDerivAt.cpow hg.hasFDerivAt h0).differentiableAt\n\ntheorem DifferentiableAt.const_cpow (hf : DifferentiableAt \u2102 f x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    DifferentiableAt \u2102 (fun x => c ^ f x) x :=\n  (hf.hasFDerivAt.const_cpow h0).differentiableAt\n\ntheorem DifferentiableAt.cpow_const (hf : DifferentiableAt \u2102 f x) (h0 : f x \u2208 slitPlane) :\n    DifferentiableAt \u2102 (fun x => f x ^ c) x :=\n  hf.cpow (differentiableAt_const c) h0\n\ntheorem DifferentiableWithinAt.cpow (hf : DifferentiableWithinAt \u2102 f s x)\n    (hg : DifferentiableWithinAt \u2102 g s x) (h0 : f x \u2208 slitPlane) :\n    DifferentiableWithinAt \u2102 (fun x => f x ^ g x) s x :=\n  (hf.hasFDerivWithinAt.cpow hg.hasFDerivWithinAt h0).differentiableWithinAt\n\ntheorem DifferentiableWithinAt.const_cpow (hf : DifferentiableWithinAt \u2102 f s x)\n    (h0 : c \u2260 0 \u2228 f x \u2260 0) : DifferentiableWithinAt \u2102 (fun x => c ^ f x) s x :=\n  (hf.hasFDerivWithinAt.const_cpow h0).differentiableWithinAt\n\ntheorem DifferentiableWithinAt.cpow_const (hf : DifferentiableWithinAt \u2102 f s x)\n    (h0 : f x \u2208 slitPlane) :\n    DifferentiableWithinAt \u2102 (fun x => f x ^ c) s x :=\n  hf.cpow (differentiableWithinAt_const c) h0\n\ntheorem DifferentiableOn.cpow (hf : DifferentiableOn \u2102 f s) (hg : DifferentiableOn \u2102 g s)\n    (h0 : Set.MapsTo f s slitPlane) : DifferentiableOn \u2102 (fun x \u21a6 f x ^ g x) s :=\n  fun x hx \u21a6 (hf x hx).cpow (hg x hx) (h0 hx)\n\ntheorem DifferentiableOn.const_cpow (hf : DifferentiableOn \u2102 f s)\n    (h0 : c \u2260 0 \u2228 \u2200 x \u2208 s, f x \u2260 0) : DifferentiableOn \u2102 (fun x \u21a6 c ^ f x) s :=\n  fun x hx \u21a6 (hf x hx).const_cpow (h0.imp_right fun h \u21a6 h x hx)\n\ntheorem DifferentiableOn.cpow_const (hf : DifferentiableOn \u2102 f s)\n    (h0 : \u2200 x \u2208 s, f x \u2208 slitPlane) :\n    DifferentiableOn \u2102 (fun x => f x ^ c) s :=\n  hf.cpow (differentiableOn_const c) h0\n\ntheorem Differentiable.cpow (hf : Differentiable \u2102 f) (hg : Differentiable \u2102 g)\n    (h0 : \u2200 x, f x \u2208 slitPlane) : Differentiable \u2102 (fun x \u21a6 f x ^ g x) :=\n  fun x \u21a6 (hf x).cpow (hg x) (h0 x)\n\ntheorem Differentiable.const_cpow (hf : Differentiable \u2102 f)\n    (h0 : c \u2260 0 \u2228 \u2200 x, f x \u2260 0) : Differentiable \u2102 (fun x \u21a6 c ^ f x) :=\n  fun x \u21a6 (hf x).const_cpow (h0.imp_right fun h \u21a6 h x)\n\n@[fun_prop]\nlemma differentiable_const_cpow_of_neZero (z : \u2102) [NeZero z] :\n    Differentiable \u2102 fun s : \u2102 \u21a6 z ^ s :=\n  differentiable_id.const_cpow (.inl <| NeZero.ne z)\n\n@[fun_prop]\nlemma differentiableAt_const_cpow_of_neZero (z : \u2102) [NeZero z] (t : \u2102) :\n    DifferentiableAt \u2102 (fun s : \u2102 \u21a6 z ^ s) t :=\n  differentiableAt_id.const_cpow (.inl <| NeZero.ne z)\n\nend fderiv\n\nsection deriv\n\nopen Complex\n\nvariable {f g : \u2102 \u2192 \u2102} {s : Set \u2102} {f' g' x c : \u2102}\n\n/-- A private lemma that rewrites the output of lemmas like `HasFDerivAt.cpow` to the form\nexpected by lemmas like `HasDerivAt.cpow`. -/\nprivate theorem aux : ((g x * f x ^ (g x - 1)) \u2022 (1 : \u2102 \u2192L[\u2102] \u2102).smulRight f' +\n    (f x ^ g x * log (f x)) \u2022 (1 : \u2102 \u2192L[\u2102] \u2102).smulRight g') 1 =\n      g x * f x ^ (g x - 1) * f' + f x ^ g x * log (f x) * g' := by\n  simp only [Algebra.id.smul_eq_mul, one_mul, ContinuousLinearMap.one_apply,\n    ContinuousLinearMap.smulRight_apply, ContinuousLinearMap.add_apply, Pi.smul_apply,\n    ContinuousLinearMap.coe_smul']\n\nnonrec theorem HasStrictDerivAt.cpow (hf : HasStrictDerivAt f f' x) (hg : HasStrictDerivAt g g' x)\n    (h0 : f x \u2208 slitPlane) : HasStrictDerivAt (fun x => f x ^ g x)\n      (g x * f x ^ (g x - 1) * f' + f x ^ g x * Complex.log (f x) * g') x := by\n  simpa using (hf.cpow hg h0).hasStrictDerivAt\n\ntheorem HasStrictDerivAt.const_cpow (hf : HasStrictDerivAt f f' x) (h : c \u2260 0 \u2228 f x \u2260 0) :\n    HasStrictDerivAt (fun x => c ^ f x) (c ^ f x * Complex.log c * f') x :=\n  (hasStrictDerivAt_const_cpow h).comp x hf\n\ntheorem Complex.hasStrictDerivAt_cpow_const (h : x \u2208 slitPlane) :\n    HasStrictDerivAt (fun z : \u2102 => z ^ c) (c * x ^ (c - 1)) x := by\n  simpa only [mul_zero, add_zero, mul_one] using\n    (hasStrictDerivAt_id x).cpow (hasStrictDerivAt_const x c) h\n\ntheorem HasStrictDerivAt.cpow_const (hf : HasStrictDerivAt f f' x)\n    (h0 : f x \u2208 slitPlane) :\n    HasStrictDerivAt (fun x => f x ^ c) (c * f x ^ (c - 1) * f') x :=\n  (Complex.hasStrictDerivAt_cpow_const h0).comp x hf\n\ntheorem HasDerivAt.cpow (hf : HasDerivAt f f' x) (hg : HasDerivAt g g' x)\n    (h0 : f x \u2208 slitPlane) : HasDerivAt (fun x => f x ^ g x)\n      (g x * f x ^ (g x - 1) * f' + f x ^ g x * Complex.log (f x) * g') x := by\n  simpa only [aux] using (hf.hasFDerivAt.cpow hg h0).hasDerivAt\n\ntheorem HasDerivAt.const_cpow (hf : HasDerivAt f f' x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasDerivAt (fun x => c ^ f x) (c ^ f x * Complex.log c * f') x :=\n  (hasStrictDerivAt_const_cpow h0).hasDerivAt.comp x hf\n\ntheorem HasDerivAt.cpow_const (hf : HasDerivAt f f' x) (h0 : f x \u2208 slitPlane) :\n    HasDerivAt (fun x => f x ^ c) (c * f x ^ (c - 1) * f') x :=\n  (Complex.hasStrictDerivAt_cpow_const h0).hasDerivAt.comp x hf\n\ntheorem HasDerivWithinAt.cpow (hf : HasDerivWithinAt f f' s x) (hg : HasDerivWithinAt g g' s x)\n    (h0 : f x \u2208 slitPlane) : HasDerivWithinAt (fun x => f x ^ g x)\n      (g x * f x ^ (g x - 1) * f' + f x ^ g x * Complex.log (f x) * g') s x := by\n  simpa only [aux] using (hf.hasFDerivWithinAt.cpow hg h0).hasDerivWithinAt\n\ntheorem HasDerivWithinAt.const_cpow (hf : HasDerivWithinAt f f' s x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasDerivWithinAt (fun x => c ^ f x) (c ^ f x * Complex.log c * f') s x :=\n  (hasStrictDerivAt_const_cpow h0).hasDerivAt.comp_hasDerivWithinAt x hf\n\ntheorem HasDerivWithinAt.cpow_const (hf : HasDerivWithinAt f f' s x)\n    (h0 : f x \u2208 slitPlane) :\n    HasDerivWithinAt (fun x => f x ^ c) (c * f x ^ (c - 1) * f') s x :=\n  (Complex.hasStrictDerivAt_cpow_const h0).hasDerivAt.comp_hasDerivWithinAt x hf\n\n/-- Although `fun x => x ^ r` for fixed `r` is *not* complex-differentiable along the negative real\nline, it is still real-differentiable, and the derivative is what one would formally expect.\nSee `hasDerivAt_ofReal_cpow_const` for an alternate formulation. -/\ntheorem hasDerivAt_ofReal_cpow_const' {x : \u211d} (hx : x \u2260 0) {r : \u2102} (hr : r \u2260 -1) :\n    HasDerivAt (fun y : \u211d => (y : \u2102) ^ (r + 1) / (r + 1)) (x ^ r) x := by\n  rw [Ne, \u2190 add_eq_zero_iff_eq_neg, \u2190 Ne] at hr\n  rcases lt_or_gt_of_ne hx.symm with (hx | hx)\n  \u00b7 -- easy case : `0 < x`\n    -- Porting note: proof used to be\n    -- convert (((hasDerivAt_id (x : \u2102)).cpow_const _).div_const (r + 1)).comp_ofReal using 1\n    -- \u00b7 rw [add_sub_cancel, id.def, mul_one, mul_comm, mul_div_cancel _ hr]\n    -- \u00b7 rw [id.def, ofReal_re]; exact Or.inl hx\n    apply HasDerivAt.comp_ofReal (e := fun y => (y : \u2102) ^ (r + 1) / (r + 1))\n    convert HasDerivAt.div_const (\ud835\udd5c := \u2102) ?_ (r + 1) using 1\n    \u00b7 exact (mul_div_cancel_right\u2080 _ hr).symm\n    \u00b7 convert HasDerivAt.cpow_const ?_ ?_ using 1\n      \u00b7 rw [add_sub_cancel_right, mul_comm]; exact (mul_one _).symm\n      \u00b7 exact hasDerivAt_id (x : \u2102)\n      \u00b7 simp [hx]\n  \u00b7 -- harder case : `x < 0`\n    have : \u2200\u1da0 y : \u211d in \ud835\udcdd x,\n        (y : \u2102) ^ (r + 1) / (r + 1) = (-y : \u2102) ^ (r + 1) * exp (\u03c0 * I * (r + 1)) / (r + 1) := by\n      refine Filter.eventually_of_mem (Iio_mem_nhds hx) fun y hy => ?_\n      rw [ofReal_cpow_of_nonpos (le_of_lt hy)]\n    refine HasDerivAt.congr_of_eventuallyEq ?_ this\n    rw [ofReal_cpow_of_nonpos (le_of_lt hx)]\n    suffices HasDerivAt (fun y : \u211d => (-\u2191y) ^ (r + 1) * exp (\u2191\u03c0 * I * (r + 1)))\n        ((r + 1) * (-\u2191x) ^ r * exp (\u2191\u03c0 * I * r)) x by\n      convert this.div_const (r + 1) using 1\n      conv_rhs => rw [mul_assoc, mul_comm, mul_div_cancel_right\u2080 _ hr]\n    rw [mul_add ((\u03c0 : \u2102) * _), mul_one, exp_add, exp_pi_mul_I, mul_comm (_ : \u2102) (-1 : \u2102),\n      neg_one_mul]\n    simp_rw [mul_neg, \u2190 neg_mul, \u2190 ofReal_neg]\n    suffices HasDerivAt (fun y : \u211d => (\u2191(-y) : \u2102) ^ (r + 1)) (-(r + 1) * \u2191(-x) ^ r) x by\n      convert this.neg.mul_const _ using 1; ring\n    suffices HasDerivAt (fun y : \u211d => (y : \u2102) ^ (r + 1)) ((r + 1) * \u2191(-x) ^ r) (-x) by\n      convert @HasDerivAt.scomp \u211d _ \u2102 _ _ x \u211d _ _ _ _ _ _ _ _ this (hasDerivAt_neg x) using 1\n      rw [real_smul, ofReal_neg 1, ofReal_one]; ring\n    suffices HasDerivAt (fun y : \u2102 => y ^ (r + 1)) ((r + 1) * \u2191(-x) ^ r) \u2191(-x) by\n      exact this.comp_ofReal\n    conv in \u2191_ ^ _ => rw [(by ring : r = r + 1 - 1)]\n    convert HasDerivAt.cpow_const ?_ ?_ using 1\n    \u00b7 rw [add_sub_cancel_right, add_sub_cancel_right]; exact (mul_one _).symm\n    \u00b7 exact hasDerivAt_id ((-x : \u211d) : \u2102)\n    \u00b7 simp [hx]\n\n@[deprecated (since := \"2024-12-15\")] alias hasDerivAt_ofReal_cpow := hasDerivAt_ofReal_cpow_const'\n\n", "theoremStatement": "/-- An alternate formulation of `hasDerivAt_ofReal_cpow_const'`. -/\ntheorem hasDerivAt_ofReal_cpow_const {x : \u211d} (hx : x \u2260 0) {r : \u2102} (hr : r \u2260 0) :\n    HasDerivAt (fun y : \u211d => (y : \u2102) ^ r) (r * x ^ (r - 1)) x ", "theoremName": "hasDerivAt_ofReal_cpow_const", "fileCreated": {"commit": "a9359cb30d5d2eb08c3c66959305c82fe45fab66", "date": "2023-06-06"}, "theoremCreated": {"commit": "006641492734e60b369ac830260c46c2dcdb7342", "date": "2025-01-20"}, "file": "mathlib/Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean", "module": "Mathlib.Analysis.SpecialFunctions.Pow.Deriv", "jsonFile": "Mathlib.Analysis.SpecialFunctions.Pow.Deriv.jsonl", "positionMetadata": {"lineInFile": 268, "tokenPositionInFile": 13067, "theoremPositionInFile": 35}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 96, "numPremises": 124}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  have := HasDerivAt.const_mul r <| hasDerivAt_ofReal_cpow_const' hx\n    (by rwa [ne_eq, sub_eq_neg_self])\n  simpa [sub_add_cancel, mul_div_cancel\u2080 _ hr] using this", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 170}}
{"srcContext": "/-\nCopyright (c) 2024 Jo\u00ebl Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jo\u00ebl Riou\n-/\nimport Mathlib.Algebra.Homology.Embedding.Extend\nimport Mathlib.Algebra.Homology.Embedding.IsSupported\nimport Mathlib.Algebra.Homology.QuasiIso\n\n/-!\n# Homology of the extension of an homological complex\n\nGiven an embedding `e : c.Embedding c'` and `K : HomologicalComplex C c`, we shall\ncompute the homology of `K.extend e`. In degrees that are not in the image of `e.f`,\nthe homology is obviously zero. When `e.f j = j`, we construct an isomorphism\n`(K.extend e).homology j' \u2245 K.homology j`.\n\n-/\n\nopen CategoryTheory Limits Category\n\nnamespace HomologicalComplex\n\nvariable {\u03b9 \u03b9' : Type*} {c : ComplexShape \u03b9} {c' : ComplexShape \u03b9'}\n  {C : Type*} [Category C] [HasZeroMorphisms C]\n  [HasZeroObject C]\n\nvariable (K L M : HomologicalComplex C c) (\u03c6 : K \u27f6 L) (\u03c6' : L \u27f6 M) (e : c.Embedding c')\n\nnamespace extend\n\nsection HomologyData\n\nvariable {i j k : \u03b9} {i' j' k' : \u03b9'} (hj' : e.f j = j')\n  (hi : c.prev j = i) (hi' : c'.prev j' = i') (hk : c.next j = k) (hk' : c'.next j' = k')\n\ninclude hk hk' in\nlemma comp_d_eq_zero_iff \u2983W : C\u2984 (\u03c6 : W \u27f6 K.X j) :\n    \u03c6 \u226b K.d j k = 0 \u2194 \u03c6 \u226b (K.extendXIso e hj').inv \u226b (K.extend e).d j' k' = 0 := by\n  by_cases hjk : c.Rel j k\n  \u00b7 have hk' : e.f k = k' := by rw [\u2190 hk', \u2190 hj', c'.next_eq' (e.rel hjk)]\n    rw [K.extend_d_eq e hj' hk', Iso.inv_hom_id_assoc,\n      \u2190 cancel_mono (K.extendXIso e hk').inv, zero_comp, assoc]\n  \u00b7 simp only [K.shape _ _ hjk, comp_zero, true_iff]\n    rw [K.extend_d_from_eq_zero e j' k' j hj', comp_zero, comp_zero]\n    rw [hk]\n    exact hjk\n\ninclude hi hi' in\nlemma d_comp_eq_zero_iff \u2983W : C\u2984 (\u03c6 : K.X j \u27f6 W) :\n    K.d i j \u226b \u03c6 = 0 \u2194 (K.extend e).d i' j' \u226b (K.extendXIso e hj').hom \u226b \u03c6 = 0 := by\n  by_cases hij : c.Rel i j\n  \u00b7 have hi' : e.f i = i' := by rw [\u2190 hi', \u2190 hj', c'.prev_eq' (e.rel hij)]\n    rw [K.extend_d_eq e hi' hj', assoc, assoc, Iso.inv_hom_id_assoc,\n      \u2190 cancel_epi (K.extendXIso e hi').hom, comp_zero]\n  \u00b7 simp only [K.shape _ _ hij, zero_comp, true_iff]\n    rw [K.extend_d_to_eq_zero e i' j' j hj', zero_comp]\n    rw [hi]\n    exact hij\n\nnamespace leftHomologyData\n\nvariable (cone : KernelFork (K.d j k)) (hcone : IsLimit cone)\n\n/-- The kernel fork of `(K.extend e).d j' k'` that is deduced from a kernel\nfork of `K.d j k `. -/\n@[simp]\nnoncomputable def kernelFork : KernelFork ((K.extend e).d j' k') :=\n  KernelFork.of\u03b9 (cone.\u03b9 \u226b (extendXIso K e hj').inv)\n    (by rw [assoc, \u2190 comp_d_eq_zero_iff K e hj' hk hk' cone.\u03b9, cone.condition])\n\n/-- The limit kernel fork of `(K.extend e).d j' k'` that is deduced from a limit\nkernel fork of `K.d j k `. -/\nnoncomputable def isLimitKernelFork : IsLimit (kernelFork K e hj' hk hk' cone) :=\n  KernelFork.isLimitOfIsLimitOfIff hcone ((K.extend e).d j' k')\n    (extendXIso K e hj').symm (comp_d_eq_zero_iff K e hj' hk hk')\n\nvariable (cocone : CokernelCofork (hcone.lift (KernelFork.of\u03b9 (K.d i j) (K.d_comp_d i j k))))\n  (hcocone : IsColimit cocone)\n\ninclude hi hi' hcone in\n/-- Auxiliary lemma for `lift_d_comp_eq_zero_iff`. -/\nlemma lift_d_comp_eq_zero_iff' \u2983W : C\u2984 (f' : K.X i \u27f6 cone.pt)\n    (hf' : f' \u226b cone.\u03b9 = K.d i j)\n    (f'' : (K.extend e).X i' \u27f6 cone.pt)\n    (hf'' : f'' \u226b cone.\u03b9 \u226b (extendXIso K e hj').inv = (K.extend e).d i' j')\n    (\u03c6 : cone.pt \u27f6 W) :\n    f' \u226b \u03c6 = 0 \u2194 f'' \u226b \u03c6 = 0 := by\n  by_cases hij : c.Rel i j\n  \u00b7 have hi'' : e.f i = i' := by rw [\u2190 hi', \u2190 hj', c'.prev_eq' (e.rel hij)]\n    have : (K.extendXIso e hi'').hom \u226b f' = f'' := by\n      apply Fork.IsLimit.hom_ext hcone\n      rw [assoc, hf', \u2190 cancel_mono (extendXIso K e hj').inv, assoc, assoc, hf'',\n        K.extend_d_eq e hi'' hj']\n    rw [\u2190 cancel_epi (K.extendXIso e hi'').hom, comp_zero, \u2190 this, assoc]\n  \u00b7 have h\u2081 : f' = 0 := by\n      apply Fork.IsLimit.hom_ext hcone\n      simp only [zero_comp, hf', K.shape _ _ hij]\n    have h\u2082 : f'' = 0 := by\n      apply Fork.IsLimit.hom_ext hcone\n      dsimp\n      rw [\u2190 cancel_mono (extendXIso K e hj').inv, assoc, hf'', zero_comp, zero_comp,\n        K.extend_d_to_eq_zero e i' j' j hj']\n      rw [hi]\n      exact hij\n    simp [h\u2081, h\u2082]\n\ninclude hi hi' in\nlemma lift_d_comp_eq_zero_iff \u2983W : C\u2984 (\u03c6 : cone.pt \u27f6 W) :\n    hcone.lift (KernelFork.of\u03b9 (K.d i j) (K.d_comp_d i j k)) \u226b \u03c6 = 0 \u2194\n      ((isLimitKernelFork K e hj' hk hk' cone hcone).lift\n      (KernelFork.of\u03b9 ((K.extend e).d i' j') (d_comp_d _ _ _ _))) \u226b \u03c6 = 0 :=\n  lift_d_comp_eq_zero_iff' K e hj' hi hi' cone hcone _ (hcone.fac _ _) _\n    (IsLimit.fac _ _ WalkingParallelPair.zero) _\n\n/-- Auxiliary definition for `extend.leftHomologyData`. -/\nnoncomputable def cokernelCofork :\n    CokernelCofork ((isLimitKernelFork K e hj' hk hk' cone hcone).lift\n      (KernelFork.of\u03b9 ((K.extend e).d i' j') (d_comp_d _ _ _ _))) :=\n  CokernelCofork.of\u03c0 cocone.\u03c0 (by\n    rw [\u2190 lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' cone hcone]\n    exact cocone.condition)\n\n/-- Auxiliary definition for `extend.leftHomologyData`. -/\nnoncomputable def isColimitCokernelCofork :\n    IsColimit (cokernelCofork K e hj' hi hi' hk hk' cone hcone cocone) :=\n  CokernelCofork.isColimitOfIsColimitOfIff' hcocone _\n    (lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' cone hcone)\n\nend leftHomologyData\n\nopen leftHomologyData in\n/-- The left homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a left homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def leftHomologyData (h : (K.sc' i j k).LeftHomologyData) :\n    ((K.extend e).sc' i' j' k').LeftHomologyData where\n  K := h.K\n  H := h.H\n  i := h.i \u226b (extendXIso K e hj').inv\n  \u03c0 := h.\u03c0\n  wi := by\n    dsimp\n    rw [assoc, \u2190 comp_d_eq_zero_iff K e hj' hk hk']\n    exact h.wi\n  hi := isLimitKernelFork K e hj' hk hk' _ h.hi\n  w\u03c0 := by\n    dsimp\n    rw [\u2190 lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' _ h.hi]\n    exact h.w\u03c0\n  h\u03c0 := isColimitCokernelCofork K e hj' hi hi' hk hk' _ h.hi _ h.h\u03c0\n\nnamespace rightHomologyData\n\nvariable (cocone : CokernelCofork (K.d i j)) (hcocone : IsColimit cocone)\n\n/-- The cokernel cofork of `(K.extend e).d i' j'` that is deduced from a cokernel\ncofork of `K.d i j`. -/\n@[simp]\nnoncomputable def cokernelCofork : CokernelCofork ((K.extend e).d i' j') :=\n  CokernelCofork.of\u03c0 ((extendXIso K e hj').hom \u226b cocone.\u03c0) (by\n    rw [\u2190 d_comp_eq_zero_iff K e hj' hi hi' cocone.\u03c0, cocone.condition])\n\n/-- The colimit cokernel cofork of `(K.extend e).d i' j'` that is deduced from a\ncolimit cokernel cofork of `K.d i j`. -/\nnoncomputable def isColimitCokernelCofork : IsColimit (cokernelCofork K e hj' hi hi' cocone) :=\n  CokernelCofork.isColimitOfIsColimitOfIff hcocone ((K.extend e).d i' j')\n    (extendXIso K e hj') (d_comp_eq_zero_iff K e hj' hi hi')\n\nvariable (cone : KernelFork (hcocone.desc (CokernelCofork.of\u03c0 (K.d j k) (K.d_comp_d i j k))))\n  (hcone : IsLimit cone)\n\ninclude hk hk' hcocone in\nlemma d_comp_desc_eq_zero_iff' \u2983W : C\u2984 (f' : cocone.pt \u27f6 K.X k)\n    (hf' : cocone.\u03c0 \u226b f' = K.d j k)\n    (f'' : cocone.pt \u27f6 (K.extend e).X k')\n    (hf'' : (extendXIso K e hj').hom \u226b cocone.\u03c0 \u226b f'' = (K.extend e).d j' k')\n    (\u03c6 : W \u27f6 cocone.pt) :\n    \u03c6 \u226b f' = 0 \u2194 \u03c6 \u226b f'' = 0 := by\n  by_cases hjk : c.Rel j k\n  \u00b7 have hk'' : e.f k = k' := by rw [\u2190 hk', \u2190 hj', c'.next_eq' (e.rel hjk)]\n    have : f' \u226b (K.extendXIso e hk'').inv = f'' := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      rw [reassoc_of% hf', \u2190 cancel_epi (extendXIso K e hj').hom, hf'',\n        K.extend_d_eq e hj' hk'']\n    rw [\u2190 cancel_mono (K.extendXIso e hk'').inv, zero_comp, assoc, this]\n  \u00b7 have h\u2081 : f' = 0 := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      simp only [hf', comp_zero, K.shape _ _ hjk]\n    have h\u2082 : f'' = 0 := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      rw [\u2190 cancel_epi (extendXIso K e hj').hom, hf'', comp_zero, comp_zero,\n        K.extend_d_from_eq_zero e j' k' j hj']\n      rw [hk]\n      exact hjk\n    simp [h\u2081, h\u2082]\n\ninclude hk hk' in\nlemma d_comp_desc_eq_zero_iff \u2983W : C\u2984 (\u03c6 : W \u27f6 cocone.pt) :\n    \u03c6 \u226b hcocone.desc (CokernelCofork.of\u03c0 (K.d j k) (K.d_comp_d i j k)) = 0 \u2194\n      \u03c6 \u226b ((isColimitCokernelCofork K e hj' hi hi' cocone hcocone).desc\n      (CokernelCofork.of\u03c0 ((K.extend e).d j' k') (d_comp_d _ _ _ _))) = 0 :=\n  d_comp_desc_eq_zero_iff' K e hj' hk hk' cocone hcocone _ (hcocone.fac _ _) _ (by\n    simpa using (isColimitCokernelCofork K e hj' hi hi' cocone hcocone).fac _\n      WalkingParallelPair.one) _\n\n/-- Auxiliary definition for `extend.rightHomologyData`. -/\nnoncomputable def kernelFork :\n    KernelFork ((isColimitCokernelCofork K e hj' hi hi' cocone hcocone).desc\n      (CokernelCofork.of\u03c0 ((K.extend e).d j' k') (d_comp_d _ _ _ _))) :=\n  KernelFork.of\u03b9 cone.\u03b9 (by\n    rw [\u2190 d_comp_desc_eq_zero_iff K e hj' hi hi' hk hk' cocone hcocone]\n    exact cone.condition)\n\n/-- Auxiliary definition for `extend.rightHomologyData`. -/\nnoncomputable def isLimitKernelFork :\n    IsLimit (kernelFork K e hj' hi hi' hk hk' cocone hcocone cone) :=\n  KernelFork.isLimitOfIsLimitOfIff' hcone _\n    (d_comp_desc_eq_zero_iff K e hj' hi hi' hk hk' cocone hcocone)\n\nend rightHomologyData\n\nopen rightHomologyData in\n/-- The right homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a right homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def rightHomologyData (h : (K.sc' i j k).RightHomologyData) :\n    ((K.extend e).sc' i' j' k').RightHomologyData where\n  Q := h.Q\n  H := h.H\n  p := (extendXIso K e hj').hom \u226b h.p\n  \u03b9 := h.\u03b9\n  wp := by\n    dsimp\n    rw [\u2190 d_comp_eq_zero_iff K e hj' hi hi']\n    exact h.wp\n  hp := isColimitCokernelCofork K e hj' hi hi' _ h.hp\n  w\u03b9 := by\n    dsimp\n    rw [\u2190 d_comp_desc_eq_zero_iff K e hj' hi hi' hk hk' _ h.hp]\n    exact h.w\u03b9\n  h\u03b9 := isLimitKernelFork K e hj' hi hi' hk hk' _ h.hp _ h.h\u03b9\n\n/-- Computation of the `g'` field of `extend.rightHomologyData`. -/\nlemma rightHomologyData_g' (h : (K.sc' i j k).RightHomologyData) (hk'' : e.f k = k') :\n    (rightHomologyData K e hj' hi hi' hk hk' h).g' = h.g' \u226b (K.extendXIso e hk'').inv := by\n  rw [\u2190 cancel_epi h.p, \u2190 cancel_epi (extendXIso K e hj').hom]\n  have := (rightHomologyData K e hj' hi hi' hk hk' h).p_g'\n  dsimp at this\n  rw [assoc] at this\n  rw [this, K.extend_d_eq e hj' hk'', h.p_g'_assoc, shortComplexFunctor'_obj_g]\n\n/-- The homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def homologyData (h : (K.sc' i j k).HomologyData) :\n    ((K.extend e).sc' i' j' k').HomologyData where\n  left := leftHomologyData K e hj' hi hi' hk hk' h.left\n  right := rightHomologyData K e hj' hi hi' hk hk' h.right\n  iso := h.iso\n\n/-- The homology data of `(K.extend e).sc j'` that is deduced\nfrom a homology data of `K.sc' i j k`. -/\n@[simps!]\nnoncomputable def homologyData' (h : (K.sc' i j k).HomologyData) :\n    ((K.extend e).sc j').HomologyData :=\n  homologyData K e hj' hi rfl hk rfl h\n\nend HomologyData\n\nlemma hasHomology {j : \u03b9} {j' : \u03b9'} (hj' : e.f j = j') [K.HasHomology j] :\n    (K.extend e).HasHomology j' :=\n  ShortComplex.HasHomology.mk'\n    (homologyData' K e hj' rfl rfl ((K.sc j).homologyData))\n\ninstance (j : \u03b9) [K.HasHomology j] : (K.extend e).HasHomology (e.f j) :=\n  hasHomology K e rfl\n\ninstance [\u2200 j, K.HasHomology j] (j' : \u03b9') : (K.extend e).HasHomology j' := by\n  by_cases h : \u2203 j, e.f j = j'\n  \u00b7 obtain \u27e8j, rfl\u27e9 := h\n    infer_instance\n  \u00b7 have hj := isZero_extend_X K e j' (by tauto)\n    exact ShortComplex.HasHomology.mk'\n      (ShortComplex.HomologyData.ofZeros _ (hj.eq_of_tgt _ _) (hj.eq_of_src _ _))\n\nend extend\n\nlemma extend_exactAt (j' : \u03b9') (hj' : \u2200 j, e.f j \u2260 j') :\n    (K.extend e).ExactAt j' :=\n  exactAt_of_isSupported _ e j' hj'\n\nsection\n\nvariable {j : \u03b9} {j' : \u03b9'} (hj' : e.f j = j') [K.HasHomology j] [L.HasHomology j]\n  [(K.extend e).HasHomology j'] [(L.extend e).HasHomology j']\n\n/-- The isomorphism `(K.extend e).cycles j' \u2245 K.cycles j` when `e.f j = j'`. -/\nnoncomputable def extendCyclesIso :\n    (K.extend e).cycles j' \u2245 K.cycles j :=\n  (extend.homologyData' K e hj' rfl rfl (K.sc j).homologyData).left.cyclesIso \u226a\u226b\n    (K.sc j).homologyData.left.cyclesIso.symm\n\n/-- The isomorphism `(K.extend e).opcycles j' \u2245 K.opcycles j` when `e.f j = j'`. -/\nnoncomputable def extendOpcyclesIso :\n    (K.extend e).opcycles j' \u2245 K.opcycles j :=\n  (extend.homologyData' K e hj' rfl rfl (K.sc j).homologyData).right.opcyclesIso \u226a\u226b\n    (K.sc j).homologyData.right.opcyclesIso.symm\n\n/-- The isomorphism `(K.extend e).homology j' \u2245 K.homology j` when `e.f j = j'`. -/\nnoncomputable def extendHomologyIso :\n    (K.extend e).homology j' \u2245 K.homology j :=\n  (extend.homologyData' K e hj' rfl rfl (K.sc j).homologyData).left.homologyIso \u226a\u226b\n    (K.sc j).homologyData.left.homologyIso.symm\n\ninclude hj' in\n", "theoremStatement": "lemma extend_exactAt_iff :\n    (K.extend e).ExactAt j' \u2194 K.ExactAt j ", "theoremName": "HomologicalComplex.extend_exactAt_iff", "fileCreated": {"commit": "9bdc1af76cf75d960f42c29f1c09917785066c8b", "date": "2024-11-30"}, "theoremCreated": {"commit": "b07a551a1451cbf8615f4e2a6c47052affadbae4", "date": "2025-01-17"}, "file": "mathlib/Mathlib/Algebra/Homology/Embedding/ExtendHomology.lean", "module": "Mathlib.Algebra.Homology.Embedding.ExtendHomology", "jsonFile": "Mathlib.Algebra.Homology.Embedding.ExtendHomology.jsonl", "positionMetadata": {"lineInFile": 317, "tokenPositionInFile": 12611, "theoremPositionInFile": 21}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 15, "numPremises": 22}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp only [HomologicalComplex.exactAt_iff_isZero_homology]\n  exact (K.extendHomologyIso e hj').isZero_iff", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 113}}
{"srcContext": "/-\nCopyright (c) 2018 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes, Abhimanyu Pallavi Sudhir, Jean Lo, Calle S\u00f6nne, S\u00e9bastien Gou\u00ebzel,\n  R\u00e9my Degenne\n-/\nimport Mathlib.Analysis.SpecialFunctions.Pow.Continuity\nimport Mathlib.Analysis.SpecialFunctions.Complex.LogDeriv\nimport Mathlib.Analysis.Calculus.FDeriv.Extend\nimport Mathlib.Analysis.Calculus.Deriv.Prod\nimport Mathlib.Analysis.SpecialFunctions.Log.Deriv\nimport Mathlib.Analysis.SpecialFunctions.Trigonometric.Deriv\n\n/-!\n# Derivatives of power function on `\u2102`, `\u211d`, `\u211d\u22650`, and `\u211d\u22650\u221e`\n\nWe also prove differentiability and provide derivatives for the power functions `x ^ y`.\n-/\n\n\nnoncomputable section\n\nopen scoped Real Topology NNReal ENNReal\nopen Filter\n\nnamespace Complex\n\ntheorem hasStrictFDerivAt_cpow {p : \u2102 \u00d7 \u2102} (hp : p.1 \u2208 slitPlane) :\n    HasStrictFDerivAt (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2)\n      ((p.2 * p.1 ^ (p.2 - 1)) \u2022 ContinuousLinearMap.fst \u2102 \u2102 \u2102 +\n        (p.1 ^ p.2 * log p.1) \u2022 ContinuousLinearMap.snd \u2102 \u2102 \u2102) p := by\n  have A : p.1 \u2260 0 := slitPlane_ne_zero hp\n  have : (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2) =\u1da0[\ud835\udcdd p] fun x => exp (log x.1 * x.2) :=\n    ((isOpen_ne.preimage continuous_fst).eventually_mem A).mono fun p hp =>\n      cpow_def_of_ne_zero hp _\n  rw [cpow_sub _ _ A, cpow_one, mul_div_left_comm, mul_smul, mul_smul]\n  refine HasStrictFDerivAt.congr_of_eventuallyEq ?_ this.symm\n  simpa only [cpow_def_of_ne_zero A, div_eq_mul_inv, mul_smul, add_comm, smul_add] using\n    ((hasStrictFDerivAt_fst.clog hp).mul hasStrictFDerivAt_snd).cexp\n\ntheorem hasStrictFDerivAt_cpow' {x y : \u2102} (hp : x \u2208 slitPlane) :\n    HasStrictFDerivAt (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2)\n      ((y * x ^ (y - 1)) \u2022 ContinuousLinearMap.fst \u2102 \u2102 \u2102 +\n        (x ^ y * log x) \u2022 ContinuousLinearMap.snd \u2102 \u2102 \u2102) (x, y) :=\n  @hasStrictFDerivAt_cpow (x, y) hp\n\ntheorem hasStrictDerivAt_const_cpow {x y : \u2102} (h : x \u2260 0 \u2228 y \u2260 0) :\n    HasStrictDerivAt (fun y => x ^ y) (x ^ y * log x) y := by\n  rcases em (x = 0) with (rfl | hx)\n  \u00b7 replace h := h.neg_resolve_left rfl\n    rw [log_zero, mul_zero]\n    refine (hasStrictDerivAt_const y 0).congr_of_eventuallyEq ?_\n    exact (isOpen_ne.eventually_mem h).mono fun y hy => (zero_cpow hy).symm\n  \u00b7 simpa only [cpow_def_of_ne_zero hx, mul_one] using\n      ((hasStrictDerivAt_id y).const_mul (log x)).cexp\n\ntheorem hasFDerivAt_cpow {p : \u2102 \u00d7 \u2102} (hp : p.1 \u2208 slitPlane) :\n    HasFDerivAt (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2)\n      ((p.2 * p.1 ^ (p.2 - 1)) \u2022 ContinuousLinearMap.fst \u2102 \u2102 \u2102 +\n        (p.1 ^ p.2 * log p.1) \u2022 ContinuousLinearMap.snd \u2102 \u2102 \u2102) p :=\n  (hasStrictFDerivAt_cpow hp).hasFDerivAt\n\nend Complex\n\nsection fderiv\n\nopen Complex\n\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f g : E \u2192 \u2102} {f' g' : E \u2192L[\u2102] \u2102}\n  {x : E} {s : Set E} {c : \u2102}\n\ntheorem HasStrictFDerivAt.cpow (hf : HasStrictFDerivAt f f' x) (hg : HasStrictFDerivAt g g' x)\n    (h0 : f x \u2208 slitPlane) : HasStrictFDerivAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) \u2022 f' + (f x ^ g x * Complex.log (f x)) \u2022 g') x := by\n  convert (@hasStrictFDerivAt_cpow ((fun x => (f x, g x)) x) h0).comp x (hf.prod hg)\n\ntheorem HasStrictFDerivAt.const_cpow (hf : HasStrictFDerivAt f f' x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasStrictFDerivAt (fun x => c ^ f x) ((c ^ f x * Complex.log c) \u2022 f') x :=\n  (hasStrictDerivAt_const_cpow h0).comp_hasStrictFDerivAt x hf\n\ntheorem HasFDerivAt.cpow (hf : HasFDerivAt f f' x) (hg : HasFDerivAt g g' x)\n    (h0 : f x \u2208 slitPlane) : HasFDerivAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) \u2022 f' + (f x ^ g x * Complex.log (f x)) \u2022 g') x := by\n  convert (@Complex.hasFDerivAt_cpow ((fun x => (f x, g x)) x) h0).comp x (hf.prod hg)\n\ntheorem HasFDerivAt.const_cpow (hf : HasFDerivAt f f' x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasFDerivAt (fun x => c ^ f x) ((c ^ f x * Complex.log c) \u2022 f') x :=\n  (hasStrictDerivAt_const_cpow h0).hasDerivAt.comp_hasFDerivAt x hf\n\ntheorem HasFDerivWithinAt.cpow (hf : HasFDerivWithinAt f f' s x) (hg : HasFDerivWithinAt g g' s x)\n    (h0 : f x \u2208 slitPlane) : HasFDerivWithinAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) \u2022 f' + (f x ^ g x * Complex.log (f x)) \u2022 g') s x := by\n  convert\n    (@Complex.hasFDerivAt_cpow ((fun x => (f x, g x)) x) h0).comp_hasFDerivWithinAt x (hf.prod hg)\n\ntheorem HasFDerivWithinAt.const_cpow (hf : HasFDerivWithinAt f f' s x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasFDerivWithinAt (fun x => c ^ f x) ((c ^ f x * Complex.log c) \u2022 f') s x :=\n  (hasStrictDerivAt_const_cpow h0).hasDerivAt.comp_hasFDerivWithinAt x hf\n\ntheorem DifferentiableAt.cpow (hf : DifferentiableAt \u2102 f x) (hg : DifferentiableAt \u2102 g x)\n    (h0 : f x \u2208 slitPlane) : DifferentiableAt \u2102 (fun x => f x ^ g x) x :=\n  (hf.hasFDerivAt.cpow hg.hasFDerivAt h0).differentiableAt\n\ntheorem DifferentiableAt.const_cpow (hf : DifferentiableAt \u2102 f x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    DifferentiableAt \u2102 (fun x => c ^ f x) x :=\n  (hf.hasFDerivAt.const_cpow h0).differentiableAt\n\ntheorem DifferentiableAt.cpow_const (hf : DifferentiableAt \u2102 f x) (h0 : f x \u2208 slitPlane) :\n    DifferentiableAt \u2102 (fun x => f x ^ c) x :=\n  hf.cpow (differentiableAt_const c) h0\n\ntheorem DifferentiableWithinAt.cpow (hf : DifferentiableWithinAt \u2102 f s x)\n    (hg : DifferentiableWithinAt \u2102 g s x) (h0 : f x \u2208 slitPlane) :\n    DifferentiableWithinAt \u2102 (fun x => f x ^ g x) s x :=\n  (hf.hasFDerivWithinAt.cpow hg.hasFDerivWithinAt h0).differentiableWithinAt\n\ntheorem DifferentiableWithinAt.const_cpow (hf : DifferentiableWithinAt \u2102 f s x)\n    (h0 : c \u2260 0 \u2228 f x \u2260 0) : DifferentiableWithinAt \u2102 (fun x => c ^ f x) s x :=\n  (hf.hasFDerivWithinAt.const_cpow h0).differentiableWithinAt\n\ntheorem DifferentiableWithinAt.cpow_const (hf : DifferentiableWithinAt \u2102 f s x)\n    (h0 : f x \u2208 slitPlane) :\n    DifferentiableWithinAt \u2102 (fun x => f x ^ c) s x :=\n  hf.cpow (differentiableWithinAt_const c) h0\n\ntheorem DifferentiableOn.cpow (hf : DifferentiableOn \u2102 f s) (hg : DifferentiableOn \u2102 g s)\n    (h0 : Set.MapsTo f s slitPlane) : DifferentiableOn \u2102 (fun x \u21a6 f x ^ g x) s :=\n  fun x hx \u21a6 (hf x hx).cpow (hg x hx) (h0 hx)\n\ntheorem DifferentiableOn.const_cpow (hf : DifferentiableOn \u2102 f s)\n    (h0 : c \u2260 0 \u2228 \u2200 x \u2208 s, f x \u2260 0) : DifferentiableOn \u2102 (fun x \u21a6 c ^ f x) s :=\n  fun x hx \u21a6 (hf x hx).const_cpow (h0.imp_right fun h \u21a6 h x hx)\n\ntheorem DifferentiableOn.cpow_const (hf : DifferentiableOn \u2102 f s)\n    (h0 : \u2200 x \u2208 s, f x \u2208 slitPlane) :\n    DifferentiableOn \u2102 (fun x => f x ^ c) s :=\n  hf.cpow (differentiableOn_const c) h0\n\ntheorem Differentiable.cpow (hf : Differentiable \u2102 f) (hg : Differentiable \u2102 g)\n    (h0 : \u2200 x, f x \u2208 slitPlane) : Differentiable \u2102 (fun x \u21a6 f x ^ g x) :=\n  fun x \u21a6 (hf x).cpow (hg x) (h0 x)\n\ntheorem Differentiable.const_cpow (hf : Differentiable \u2102 f)\n    (h0 : c \u2260 0 \u2228 \u2200 x, f x \u2260 0) : Differentiable \u2102 (fun x \u21a6 c ^ f x) :=\n  fun x \u21a6 (hf x).const_cpow (h0.imp_right fun h \u21a6 h x)\n\n@[fun_prop]\nlemma differentiable_const_cpow_of_neZero (z : \u2102) [NeZero z] :\n    Differentiable \u2102 fun s : \u2102 \u21a6 z ^ s :=\n  differentiable_id.const_cpow (.inl <| NeZero.ne z)\n\n@[fun_prop]\nlemma differentiableAt_const_cpow_of_neZero (z : \u2102) [NeZero z] (t : \u2102) :\n    DifferentiableAt \u2102 (fun s : \u2102 \u21a6 z ^ s) t :=\n  differentiableAt_id.const_cpow (.inl <| NeZero.ne z)\n\nend fderiv\n\nsection deriv\n\nopen Complex\n\nvariable {f g : \u2102 \u2192 \u2102} {s : Set \u2102} {f' g' x c : \u2102}\n\n/-- A private lemma that rewrites the output of lemmas like `HasFDerivAt.cpow` to the form\nexpected by lemmas like `HasDerivAt.cpow`. -/\nprivate theorem aux : ((g x * f x ^ (g x - 1)) \u2022 (1 : \u2102 \u2192L[\u2102] \u2102).smulRight f' +\n    (f x ^ g x * log (f x)) \u2022 (1 : \u2102 \u2192L[\u2102] \u2102).smulRight g') 1 =\n      g x * f x ^ (g x - 1) * f' + f x ^ g x * log (f x) * g' := by\n  simp only [Algebra.id.smul_eq_mul, one_mul, ContinuousLinearMap.one_apply,\n    ContinuousLinearMap.smulRight_apply, ContinuousLinearMap.add_apply, Pi.smul_apply,\n    ContinuousLinearMap.coe_smul']\n\nnonrec theorem HasStrictDerivAt.cpow (hf : HasStrictDerivAt f f' x) (hg : HasStrictDerivAt g g' x)\n    (h0 : f x \u2208 slitPlane) : HasStrictDerivAt (fun x => f x ^ g x)\n      (g x * f x ^ (g x - 1) * f' + f x ^ g x * Complex.log (f x) * g') x := by\n  simpa using (hf.cpow hg h0).hasStrictDerivAt\n\ntheorem HasStrictDerivAt.const_cpow (hf : HasStrictDerivAt f f' x) (h : c \u2260 0 \u2228 f x \u2260 0) :\n    HasStrictDerivAt (fun x => c ^ f x) (c ^ f x * Complex.log c * f') x :=\n  (hasStrictDerivAt_const_cpow h).comp x hf\n\ntheorem Complex.hasStrictDerivAt_cpow_const (h : x \u2208 slitPlane) :\n    HasStrictDerivAt (fun z : \u2102 => z ^ c) (c * x ^ (c - 1)) x := by\n  simpa only [mul_zero, add_zero, mul_one] using\n    (hasStrictDerivAt_id x).cpow (hasStrictDerivAt_const x c) h\n\ntheorem HasStrictDerivAt.cpow_const (hf : HasStrictDerivAt f f' x)\n    (h0 : f x \u2208 slitPlane) :\n    HasStrictDerivAt (fun x => f x ^ c) (c * f x ^ (c - 1) * f') x :=\n  (Complex.hasStrictDerivAt_cpow_const h0).comp x hf\n\ntheorem HasDerivAt.cpow (hf : HasDerivAt f f' x) (hg : HasDerivAt g g' x)\n    (h0 : f x \u2208 slitPlane) : HasDerivAt (fun x => f x ^ g x)\n      (g x * f x ^ (g x - 1) * f' + f x ^ g x * Complex.log (f x) * g') x := by\n  simpa only [aux] using (hf.hasFDerivAt.cpow hg h0).hasDerivAt\n\ntheorem HasDerivAt.const_cpow (hf : HasDerivAt f f' x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasDerivAt (fun x => c ^ f x) (c ^ f x * Complex.log c * f') x :=\n  (hasStrictDerivAt_const_cpow h0).hasDerivAt.comp x hf\n\ntheorem HasDerivAt.cpow_const (hf : HasDerivAt f f' x) (h0 : f x \u2208 slitPlane) :\n    HasDerivAt (fun x => f x ^ c) (c * f x ^ (c - 1) * f') x :=\n  (Complex.hasStrictDerivAt_cpow_const h0).hasDerivAt.comp x hf\n\ntheorem HasDerivWithinAt.cpow (hf : HasDerivWithinAt f f' s x) (hg : HasDerivWithinAt g g' s x)\n    (h0 : f x \u2208 slitPlane) : HasDerivWithinAt (fun x => f x ^ g x)\n      (g x * f x ^ (g x - 1) * f' + f x ^ g x * Complex.log (f x) * g') s x := by\n  simpa only [aux] using (hf.hasFDerivWithinAt.cpow hg h0).hasDerivWithinAt\n\ntheorem HasDerivWithinAt.const_cpow (hf : HasDerivWithinAt f f' s x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasDerivWithinAt (fun x => c ^ f x) (c ^ f x * Complex.log c * f') s x :=\n  (hasStrictDerivAt_const_cpow h0).hasDerivAt.comp_hasDerivWithinAt x hf\n\ntheorem HasDerivWithinAt.cpow_const (hf : HasDerivWithinAt f f' s x)\n    (h0 : f x \u2208 slitPlane) :\n    HasDerivWithinAt (fun x => f x ^ c) (c * f x ^ (c - 1) * f') s x :=\n  (Complex.hasStrictDerivAt_cpow_const h0).hasDerivAt.comp_hasDerivWithinAt x hf\n\n/-- Although `fun x => x ^ r` for fixed `r` is *not* complex-differentiable along the negative real\nline, it is still real-differentiable, and the derivative is what one would formally expect.\nSee `hasDerivAt_ofReal_cpow_const` for an alternate formulation. -/\ntheorem hasDerivAt_ofReal_cpow_const' {x : \u211d} (hx : x \u2260 0) {r : \u2102} (hr : r \u2260 -1) :\n    HasDerivAt (fun y : \u211d => (y : \u2102) ^ (r + 1) / (r + 1)) (x ^ r) x := by\n  rw [Ne, \u2190 add_eq_zero_iff_eq_neg, \u2190 Ne] at hr\n  rcases lt_or_gt_of_ne hx.symm with (hx | hx)\n  \u00b7 -- easy case : `0 < x`\n    -- Porting note: proof used to be\n    -- convert (((hasDerivAt_id (x : \u2102)).cpow_const _).div_const (r + 1)).comp_ofReal using 1\n    -- \u00b7 rw [add_sub_cancel, id.def, mul_one, mul_comm, mul_div_cancel _ hr]\n    -- \u00b7 rw [id.def, ofReal_re]; exact Or.inl hx\n    apply HasDerivAt.comp_ofReal (e := fun y => (y : \u2102) ^ (r + 1) / (r + 1))\n    convert HasDerivAt.div_const (\ud835\udd5c := \u2102) ?_ (r + 1) using 1\n    \u00b7 exact (mul_div_cancel_right\u2080 _ hr).symm\n    \u00b7 convert HasDerivAt.cpow_const ?_ ?_ using 1\n      \u00b7 rw [add_sub_cancel_right, mul_comm]; exact (mul_one _).symm\n      \u00b7 exact hasDerivAt_id (x : \u2102)\n      \u00b7 simp [hx]\n  \u00b7 -- harder case : `x < 0`\n    have : \u2200\u1da0 y : \u211d in \ud835\udcdd x,\n        (y : \u2102) ^ (r + 1) / (r + 1) = (-y : \u2102) ^ (r + 1) * exp (\u03c0 * I * (r + 1)) / (r + 1) := by\n      refine Filter.eventually_of_mem (Iio_mem_nhds hx) fun y hy => ?_\n      rw [ofReal_cpow_of_nonpos (le_of_lt hy)]\n    refine HasDerivAt.congr_of_eventuallyEq ?_ this\n    rw [ofReal_cpow_of_nonpos (le_of_lt hx)]\n    suffices HasDerivAt (fun y : \u211d => (-\u2191y) ^ (r + 1) * exp (\u2191\u03c0 * I * (r + 1)))\n        ((r + 1) * (-\u2191x) ^ r * exp (\u2191\u03c0 * I * r)) x by\n      convert this.div_const (r + 1) using 1\n      conv_rhs => rw [mul_assoc, mul_comm, mul_div_cancel_right\u2080 _ hr]\n    rw [mul_add ((\u03c0 : \u2102) * _), mul_one, exp_add, exp_pi_mul_I, mul_comm (_ : \u2102) (-1 : \u2102),\n      neg_one_mul]\n    simp_rw [mul_neg, \u2190 neg_mul, \u2190 ofReal_neg]\n    suffices HasDerivAt (fun y : \u211d => (\u2191(-y) : \u2102) ^ (r + 1)) (-(r + 1) * \u2191(-x) ^ r) x by\n      convert this.neg.mul_const _ using 1; ring\n    suffices HasDerivAt (fun y : \u211d => (y : \u2102) ^ (r + 1)) ((r + 1) * \u2191(-x) ^ r) (-x) by\n      convert @HasDerivAt.scomp \u211d _ \u2102 _ _ x \u211d _ _ _ _ _ _ _ _ this (hasDerivAt_neg x) using 1\n      rw [real_smul, ofReal_neg 1, ofReal_one]; ring\n    suffices HasDerivAt (fun y : \u2102 => y ^ (r + 1)) ((r + 1) * \u2191(-x) ^ r) \u2191(-x) by\n      exact this.comp_ofReal\n    conv in \u2191_ ^ _ => rw [(by ring : r = r + 1 - 1)]\n    convert HasDerivAt.cpow_const ?_ ?_ using 1\n    \u00b7 rw [add_sub_cancel_right, add_sub_cancel_right]; exact (mul_one _).symm\n    \u00b7 exact hasDerivAt_id ((-x : \u211d) : \u2102)\n    \u00b7 simp [hx]\n\n@[deprecated (since := \"2024-12-15\")] alias hasDerivAt_ofReal_cpow := hasDerivAt_ofReal_cpow_const'\n\n/-- An alternate formulation of `hasDerivAt_ofReal_cpow_const'`. -/\ntheorem hasDerivAt_ofReal_cpow_const {x : \u211d} (hx : x \u2260 0) {r : \u2102} (hr : r \u2260 0) :\n    HasDerivAt (fun y : \u211d => (y : \u2102) ^ r) (r * x ^ (r - 1)) x := by\n  have := HasDerivAt.const_mul r <| hasDerivAt_ofReal_cpow_const' hx\n    (by rwa [ne_eq, sub_eq_neg_self])\n  simpa [sub_add_cancel, mul_div_cancel\u2080 _ hr] using this\n\n/-- A version of `DifferentiableAt.cpow_const` for a real function. -/\ntheorem DifferentiableAt.ofReal_cpow_const {f : \u211d \u2192 \u211d} {x : \u211d} (hf : DifferentiableAt \u211d f x)\n    (h0 : f x \u2260 0) (h1 : c \u2260 0) :\n    DifferentiableAt \u211d (fun (y : \u211d) => (f y : \u2102) ^ c) x :=\n  (hasDerivAt_ofReal_cpow_const h0 h1).differentiableAt.comp x hf\n\ntheorem Complex.deriv_cpow_const (hx : x \u2208 Complex.slitPlane) :\n    deriv (fun (x : \u2102) \u21a6 x ^ c) x = c * x ^ (c - 1) :=\n  (hasStrictDerivAt_cpow_const hx).hasDerivAt.deriv\n\n/-- A version of `Complex.deriv_cpow_const` for a real variable. -/\ntheorem Complex.deriv_ofReal_cpow_const {x : \u211d} (hx : x \u2260 0) (hc : c \u2260 0) :\n    deriv (fun x : \u211d \u21a6 (x : \u2102) ^ c) x = c * x ^ (c - 1) :=\n  (hasDerivAt_ofReal_cpow_const hx hc).deriv\n\ntheorem deriv_cpow_const (hf : DifferentiableAt \u2102 f x) (hx : f x \u2208 Complex.slitPlane) :\n    deriv (fun (x : \u2102) \u21a6 f x ^ c) x = c * f x ^ (c - 1) * deriv f x :=\n  (hf.hasDerivAt.cpow_const hx).deriv\n\ntheorem isTheta_deriv_ofReal_cpow_const_atTop {c : \u2102} (hc : c \u2260 0) :\n    deriv (fun (x : \u211d) => (x : \u2102) ^ c) =\u0398[atTop] fun x => x ^ (c.re - 1) := by\n  calc\n    _ =\u1da0[atTop] fun x : \u211d \u21a6 c * x ^ (c - 1) := by\n      filter_upwards [eventually_ne_atTop 0] with x hx using by rw [deriv_ofReal_cpow_const hx hc]\n    _ =\u0398[atTop] fun x : \u211d \u21a6 \u2016(x : \u2102) ^ (c - 1)\u2016 :=\n      (Asymptotics.IsTheta.of_norm_eventuallyEq EventuallyEq.rfl).const_mul_left hc\n    _ =\u1da0[atTop] fun x \u21a6 x ^ (c.re - 1) := by\n      filter_upwards [eventually_gt_atTop 0] with x hx\n      rw [norm_eq_abs, abs_cpow_eq_rpow_re_of_pos hx, sub_re, one_re]\n\ntheorem isBigO_deriv_ofReal_cpow_const_atTop (c : \u2102) :\n    deriv (fun (x : \u211d) => (x : \u2102) ^ c) =O[atTop] fun x => x ^ (c.re - 1) := by\n  obtain rfl | hc := eq_or_ne c 0\n  \u00b7 simp_rw [cpow_zero, deriv_const', Asymptotics.isBigO_zero]\n  \u00b7 exact (isTheta_deriv_ofReal_cpow_const_atTop hc).1\n\nend deriv\n\nnamespace Real\n\nvariable {x y z : \u211d}\n\n/-- `(x, y) \u21a6 x ^ y` is strictly differentiable at `p : \u211d \u00d7 \u211d` such that `0 < p.fst`. -/\ntheorem hasStrictFDerivAt_rpow_of_pos (p : \u211d \u00d7 \u211d) (hp : 0 < p.1) :\n    HasStrictFDerivAt (fun x : \u211d \u00d7 \u211d => x.1 ^ x.2)\n      ((p.2 * p.1 ^ (p.2 - 1)) \u2022 ContinuousLinearMap.fst \u211d \u211d \u211d +\n        (p.1 ^ p.2 * log p.1) \u2022 ContinuousLinearMap.snd \u211d \u211d \u211d) p := by\n  have : (fun x : \u211d \u00d7 \u211d => x.1 ^ x.2) =\u1da0[\ud835\udcdd p] fun x => exp (log x.1 * x.2) :=\n    (continuousAt_fst.eventually (lt_mem_nhds hp)).mono fun p hp => rpow_def_of_pos hp _\n  refine HasStrictFDerivAt.congr_of_eventuallyEq ?_ this.symm\n  convert ((hasStrictFDerivAt_fst.log hp.ne').mul hasStrictFDerivAt_snd).exp using 1\n  rw [rpow_sub_one hp.ne', \u2190 rpow_def_of_pos hp, smul_add, smul_smul, mul_div_left_comm,\n    div_eq_mul_inv, smul_smul, smul_smul, mul_assoc, add_comm]\n\n/-- `(x, y) \u21a6 x ^ y` is strictly differentiable at `p : \u211d \u00d7 \u211d` such that `p.fst < 0`. -/\ntheorem hasStrictFDerivAt_rpow_of_neg (p : \u211d \u00d7 \u211d) (hp : p.1 < 0) :\n    HasStrictFDerivAt (fun x : \u211d \u00d7 \u211d => x.1 ^ x.2)\n      ((p.2 * p.1 ^ (p.2 - 1)) \u2022 ContinuousLinearMap.fst \u211d \u211d \u211d +\n        (p.1 ^ p.2 * log p.1 - exp (log p.1 * p.2) * sin (p.2 * \u03c0) * \u03c0) \u2022\n          ContinuousLinearMap.snd \u211d \u211d \u211d) p := by\n  have : (fun x : \u211d \u00d7 \u211d => x.1 ^ x.2) =\u1da0[\ud835\udcdd p] fun x => exp (log x.1 * x.2) * cos (x.2 * \u03c0) :=\n    (continuousAt_fst.eventually (gt_mem_nhds hp)).mono fun p hp => rpow_def_of_neg hp _\n  refine HasStrictFDerivAt.congr_of_eventuallyEq ?_ this.symm\n  convert ((hasStrictFDerivAt_fst.log hp.ne).mul hasStrictFDerivAt_snd).exp.mul\n    (hasStrictFDerivAt_snd.mul_const \u03c0).cos using 1\n  simp_rw [rpow_sub_one hp.ne, smul_add, \u2190 add_assoc, smul_smul, \u2190 add_smul, \u2190 mul_assoc,\n    mul_comm (cos _), \u2190 rpow_def_of_neg hp]\n  rw [div_eq_mul_inv, add_comm]; congr 2 <;> ring\n\n/-- The function `fun (x, y) => x ^ y` is infinitely smooth at `(x, y)` unless `x = 0`. -/\ntheorem contDiffAt_rpow_of_ne (p : \u211d \u00d7 \u211d) (hp : p.1 \u2260 0) {n : WithTop \u2115\u221e} :\n    ContDiffAt \u211d n (fun p : \u211d \u00d7 \u211d => p.1 ^ p.2) p := by\n  cases' hp.lt_or_lt with hneg hpos\n  exacts\n    [(((contDiffAt_fst.log hneg.ne).mul contDiffAt_snd).exp.mul\n          (contDiffAt_snd.mul contDiffAt_const).cos).congr_of_eventuallyEq\n      ((continuousAt_fst.eventually (gt_mem_nhds hneg)).mono fun p hp => rpow_def_of_neg hp _),\n    ((contDiffAt_fst.log hpos.ne').mul contDiffAt_snd).exp.congr_of_eventuallyEq\n      ((continuousAt_fst.eventually (lt_mem_nhds hpos)).mono fun p hp => rpow_def_of_pos hp _)]\n\ntheorem differentiableAt_rpow_of_ne (p : \u211d \u00d7 \u211d) (hp : p.1 \u2260 0) :\n    DifferentiableAt \u211d (fun p : \u211d \u00d7 \u211d => p.1 ^ p.2) p :=\n  (contDiffAt_rpow_of_ne p hp).differentiableAt le_rfl\n\ntheorem _root_.HasStrictDerivAt.rpow {f g : \u211d \u2192 \u211d} {f' g' : \u211d} (hf : HasStrictDerivAt f f' x)\n    (hg : HasStrictDerivAt g g' x) (h : 0 < f x) : HasStrictDerivAt (fun x => f x ^ g x)\n      (f' * g x * f x ^ (g x - 1) + g' * f x ^ g x * Real.log (f x)) x := by\n  convert (hasStrictFDerivAt_rpow_of_pos ((fun x => (f x, g x)) x) h).comp_hasStrictDerivAt x\n    (hf.prod hg) using 1\n  simp [mul_assoc, mul_comm, mul_left_comm]\n\ntheorem hasStrictDerivAt_rpow_const_of_ne {x : \u211d} (hx : x \u2260 0) (p : \u211d) :\n    HasStrictDerivAt (fun x => x ^ p) (p * x ^ (p - 1)) x := by\n  cases' hx.lt_or_lt with hx hx\n  \u00b7 have := (hasStrictFDerivAt_rpow_of_neg (x, p) hx).comp_hasStrictDerivAt x\n      ((hasStrictDerivAt_id x).prod (hasStrictDerivAt_const x p))\n    convert this using 1; simp\n  \u00b7 simpa using (hasStrictDerivAt_id x).rpow (hasStrictDerivAt_const x p) hx\n\ntheorem hasStrictDerivAt_const_rpow {a : \u211d} (ha : 0 < a) (x : \u211d) :\n    HasStrictDerivAt (fun x => a ^ x) (a ^ x * log a) x := by\n  simpa using (hasStrictDerivAt_const _ _).rpow (hasStrictDerivAt_id x) ha\n\nlemma differentiableAt_rpow_const_of_ne (p : \u211d) {x : \u211d} (hx : x \u2260 0) :\n    DifferentiableAt \u211d (fun x => x ^ p) x :=\n  (hasStrictDerivAt_rpow_const_of_ne hx p).differentiableAt\n\nlemma differentiableOn_rpow_const (p : \u211d) :\n    DifferentiableOn \u211d (fun x => (x : \u211d) ^ p) {0}\u1d9c :=\n  fun _ hx => (Real.differentiableAt_rpow_const_of_ne p hx).differentiableWithinAt\n\n/-- This lemma says that `fun x => a ^ x` is strictly differentiable for `a < 0`. Note that these\nvalues of `a` are outside of the \"official\" domain of `a ^ x`, and we may redefine `a ^ x`\nfor negative `a` if some other definition will be more convenient. -/\ntheorem hasStrictDerivAt_const_rpow_of_neg {a x : \u211d} (ha : a < 0) :\n    HasStrictDerivAt (fun x => a ^ x) (a ^ x * log a - exp (log a * x) * sin (x * \u03c0) * \u03c0) x := by\n  simpa using (hasStrictFDerivAt_rpow_of_neg (a, x) ha).comp_hasStrictDerivAt x\n    ((hasStrictDerivAt_const _ _).prod (hasStrictDerivAt_id _))\n\nend Real\n\nnamespace Real\n\nvariable {z x y : \u211d}\n\ntheorem hasDerivAt_rpow_const {x p : \u211d} (h : x \u2260 0 \u2228 1 \u2264 p) :\n    HasDerivAt (fun x => x ^ p) (p * x ^ (p - 1)) x := by\n  rcases ne_or_eq x 0 with (hx | rfl)\n  \u00b7 exact (hasStrictDerivAt_rpow_const_of_ne hx _).hasDerivAt\n  replace h : 1 \u2264 p := h.neg_resolve_left rfl\n  apply hasDerivAt_of_hasDerivAt_of_ne fun x hx =>\n    (hasStrictDerivAt_rpow_const_of_ne hx p).hasDerivAt\n  exacts [continuousAt_id.rpow_const (Or.inr (zero_le_one.trans h)),\n    continuousAt_const.mul (continuousAt_id.rpow_const (Or.inr (sub_nonneg.2 h)))]\n\ntheorem differentiable_rpow_const {p : \u211d} (hp : 1 \u2264 p) : Differentiable \u211d fun x : \u211d => x ^ p :=\n  fun _ => (hasDerivAt_rpow_const (Or.inr hp)).differentiableAt\n\ntheorem deriv_rpow_const {x p : \u211d} (h : x \u2260 0 \u2228 1 \u2264 p) :\n    deriv (fun x : \u211d => x ^ p) x = p * x ^ (p - 1) :=\n  (hasDerivAt_rpow_const h).deriv\n\ntheorem deriv_rpow_const' {p : \u211d} (h : 1 \u2264 p) :\n    (deriv fun x : \u211d => x ^ p) = fun x => p * x ^ (p - 1) :=\n  funext fun _ => deriv_rpow_const (Or.inr h)\n\ntheorem contDiffAt_rpow_const_of_ne {x p : \u211d} {n : WithTop \u2115\u221e} (h : x \u2260 0) :\n    ContDiffAt \u211d n (fun x => x ^ p) x :=\n  (contDiffAt_rpow_of_ne (x, p) h).comp x (contDiffAt_id.prod contDiffAt_const)\n\ntheorem contDiff_rpow_const_of_le {p : \u211d} {n : \u2115} (h : \u2191n \u2264 p) :\n    ContDiff \u211d n fun x : \u211d => x ^ p := by\n  induction' n with n ihn generalizing p\n  \u00b7 exact contDiff_zero.2 (continuous_id.rpow_const fun x => Or.inr <| by simpa using h)\n  \u00b7 have h1 : 1 \u2264 p := le_trans (by simp) h\n    rw [Nat.cast_succ, \u2190 le_sub_iff_add_le] at h\n    rw [show ((n + 1 : \u2115) : WithTop \u2115\u221e) = n + 1 from rfl,\n      contDiff_succ_iff_deriv, deriv_rpow_const' h1]\n    simp only [WithTop.natCast_ne_top, analyticOn_univ, IsEmpty.forall_iff, true_and]\n    exact \u27e8differentiable_rpow_const h1, contDiff_const.mul (ihn h)\u27e9\n\ntheorem contDiffAt_rpow_const_of_le {x p : \u211d} {n : \u2115} (h : \u2191n \u2264 p) :\n    ContDiffAt \u211d n (fun x : \u211d => x ^ p) x :=\n  (contDiff_rpow_const_of_le h).contDiffAt\n\ntheorem contDiffAt_rpow_const {x p : \u211d} {n : \u2115} (h : x \u2260 0 \u2228 \u2191n \u2264 p) :\n    ContDiffAt \u211d n (fun x : \u211d => x ^ p) x :=\n  h.elim contDiffAt_rpow_const_of_ne contDiffAt_rpow_const_of_le\n\ntheorem hasStrictDerivAt_rpow_const {x p : \u211d} (hx : x \u2260 0 \u2228 1 \u2264 p) :\n    HasStrictDerivAt (fun x => x ^ p) (p * x ^ (p - 1)) x :=\n  ContDiffAt.hasStrictDerivAt' (contDiffAt_rpow_const (by rwa [\u2190 Nat.cast_one] at hx))\n    (hasDerivAt_rpow_const hx) le_rfl\n\nend Real\n\nsection Differentiability\n\nopen Real\n\nsection fderiv\n\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {f g : E \u2192 \u211d} {f' g' : E \u2192L[\u211d] \u211d}\n  {x : E} {s : Set E} {c p : \u211d} {n : WithTop \u2115\u221e}\n\n#adaptation_note /-- https://github.com/leanprover/lean4/pull/6024\n  added `by exact` to deal with unification issues. -/\ntheorem HasFDerivWithinAt.rpow (hf : HasFDerivWithinAt f f' s x) (hg : HasFDerivWithinAt g g' s x)\n    (h : 0 < f x) : HasFDerivWithinAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) \u2022 f' + (f x ^ g x * Real.log (f x)) \u2022 g') s x := by\n  exact (hasStrictFDerivAt_rpow_of_pos (f x, g x) h).hasFDerivAt.comp_hasFDerivWithinAt x\n    (hf.prod hg)\n\ntheorem HasFDerivAt.rpow (hf : HasFDerivAt f f' x) (hg : HasFDerivAt g g' x) (h : 0 < f x) :\n    HasFDerivAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) \u2022 f' + (f x ^ g x * Real.log (f x)) \u2022 g') x := by\n  exact (hasStrictFDerivAt_rpow_of_pos (f x, g x) h).hasFDerivAt.comp x (hf.prod hg)\n\ntheorem HasStrictFDerivAt.rpow (hf : HasStrictFDerivAt f f' x) (hg : HasStrictFDerivAt g g' x)\n    (h : 0 < f x) : HasStrictFDerivAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) \u2022 f' + (f x ^ g x * Real.log (f x)) \u2022 g') x :=\n  (hasStrictFDerivAt_rpow_of_pos (f x, g x) h).comp x (hf.prod hg)\n\n#adaptation_note /-- https://github.com/leanprover/lean4/pull/6024\n  added `by exact` to deal with unification issues. -/\ntheorem DifferentiableWithinAt.rpow (hf : DifferentiableWithinAt \u211d f s x)\n    (hg : DifferentiableWithinAt \u211d g s x) (h : f x \u2260 0) :\n    DifferentiableWithinAt \u211d (fun x => f x ^ g x) s x := by\n  exact (differentiableAt_rpow_of_ne (f x, g x) h).comp_differentiableWithinAt x (hf.prod hg)\n\n#adaptation_note /-- https://github.com/leanprover/lean4/pull/6024\n  added `by exact` to deal with unification issues. -/\ntheorem DifferentiableAt.rpow (hf : DifferentiableAt \u211d f x) (hg : DifferentiableAt \u211d g x)\n    (h : f x \u2260 0) : DifferentiableAt \u211d (fun x => f x ^ g x) x := by\n  exact (differentiableAt_rpow_of_ne (f x, g x) h).comp x (hf.prod hg)\n\ntheorem DifferentiableOn.rpow (hf : DifferentiableOn \u211d f s) (hg : DifferentiableOn \u211d g s)\n    (h : \u2200 x \u2208 s, f x \u2260 0) : DifferentiableOn \u211d (fun x => f x ^ g x) s := fun x hx =>\n  (hf x hx).rpow (hg x hx) (h x hx)\n\ntheorem Differentiable.rpow (hf : Differentiable \u211d f) (hg : Differentiable \u211d g) (h : \u2200 x, f x \u2260 0) :\n    Differentiable \u211d fun x => f x ^ g x := fun x => (hf x).rpow (hg x) (h x)\n\ntheorem HasFDerivWithinAt.rpow_const (hf : HasFDerivWithinAt f f' s x) (h : f x \u2260 0 \u2228 1 \u2264 p) :\n    HasFDerivWithinAt (fun x => f x ^ p) ((p * f x ^ (p - 1)) \u2022 f') s x :=\n  (hasDerivAt_rpow_const h).comp_hasFDerivWithinAt x hf\n\ntheorem HasFDerivAt.rpow_const (hf : HasFDerivAt f f' x) (h : f x \u2260 0 \u2228 1 \u2264 p) :\n    HasFDerivAt (fun x => f x ^ p) ((p * f x ^ (p - 1)) \u2022 f') x :=\n  (hasDerivAt_rpow_const h).comp_hasFDerivAt x hf\n\ntheorem HasStrictFDerivAt.rpow_const (hf : HasStrictFDerivAt f f' x) (h : f x \u2260 0 \u2228 1 \u2264 p) :\n    HasStrictFDerivAt (fun x => f x ^ p) ((p * f x ^ (p - 1)) \u2022 f') x :=\n  (hasStrictDerivAt_rpow_const h).comp_hasStrictFDerivAt x hf\n\ntheorem DifferentiableWithinAt.rpow_const (hf : DifferentiableWithinAt \u211d f s x)\n    (h : f x \u2260 0 \u2228 1 \u2264 p) : DifferentiableWithinAt \u211d (fun x => f x ^ p) s x :=\n  (hf.hasFDerivWithinAt.rpow_const h).differentiableWithinAt\n\n@[simp]\ntheorem DifferentiableAt.rpow_const (hf : DifferentiableAt \u211d f x) (h : f x \u2260 0 \u2228 1 \u2264 p) :\n    DifferentiableAt \u211d (fun x => f x ^ p) x :=\n  (hf.hasFDerivAt.rpow_const h).differentiableAt\n\ntheorem DifferentiableOn.rpow_const (hf : DifferentiableOn \u211d f s) (h : \u2200 x \u2208 s, f x \u2260 0 \u2228 1 \u2264 p) :\n    DifferentiableOn \u211d (fun x => f x ^ p) s := fun x hx => (hf x hx).rpow_const (h x hx)\n\ntheorem Differentiable.rpow_const (hf : Differentiable \u211d f) (h : \u2200 x, f x \u2260 0 \u2228 1 \u2264 p) :\n    Differentiable \u211d fun x => f x ^ p := fun x => (hf x).rpow_const (h x)\n\ntheorem HasFDerivWithinAt.const_rpow (hf : HasFDerivWithinAt f f' s x) (hc : 0 < c) :\n    HasFDerivWithinAt (fun x => c ^ f x) ((c ^ f x * Real.log c) \u2022 f') s x :=\n  (hasStrictDerivAt_const_rpow hc (f x)).hasDerivAt.comp_hasFDerivWithinAt x hf\n\ntheorem HasFDerivAt.const_rpow (hf : HasFDerivAt f f' x) (hc : 0 < c) :\n    HasFDerivAt (fun x => c ^ f x) ((c ^ f x * Real.log c) \u2022 f') x :=\n  (hasStrictDerivAt_const_rpow hc (f x)).hasDerivAt.comp_hasFDerivAt x hf\n\ntheorem HasStrictFDerivAt.const_rpow (hf : HasStrictFDerivAt f f' x) (hc : 0 < c) :\n    HasStrictFDerivAt (fun x => c ^ f x) ((c ^ f x * Real.log c) \u2022 f') x :=\n  (hasStrictDerivAt_const_rpow hc (f x)).comp_hasStrictFDerivAt x hf\n\n#adaptation_note /-- https://github.com/leanprover/lean4/pull/6024\n  added `by exact` to deal with unification issues. -/\ntheorem ContDiffWithinAt.rpow (hf : ContDiffWithinAt \u211d n f s x) (hg : ContDiffWithinAt \u211d n g s x)\n    (h : f x \u2260 0) : ContDiffWithinAt \u211d n (fun x => f x ^ g x) s x := by\n  exact (contDiffAt_rpow_of_ne (f x, g x) h).comp_contDiffWithinAt x (hf.prod hg)\n\n#adaptation_note /-- https://github.com/leanprover/lean4/pull/6024\n  added `by exact` to deal with unification issues. -/\ntheorem ContDiffAt.rpow (hf : ContDiffAt \u211d n f x) (hg : ContDiffAt \u211d n g x) (h : f x \u2260 0) :\n    ContDiffAt \u211d n (fun x => f x ^ g x) x := by\n  exact (contDiffAt_rpow_of_ne (f x, g x) h).comp x (hf.prod hg)\n\ntheorem ContDiffOn.rpow (hf : ContDiffOn \u211d n f s) (hg : ContDiffOn \u211d n g s) (h : \u2200 x \u2208 s, f x \u2260 0) :\n    ContDiffOn \u211d n (fun x => f x ^ g x) s := fun x hx => (hf x hx).rpow (hg x hx) (h x hx)\n\ntheorem ContDiff.rpow (hf : ContDiff \u211d n f) (hg : ContDiff \u211d n g) (h : \u2200 x, f x \u2260 0) :\n    ContDiff \u211d n fun x => f x ^ g x :=\n  contDiff_iff_contDiffAt.mpr fun x => hf.contDiffAt.rpow hg.contDiffAt (h x)\n\ntheorem ContDiffWithinAt.rpow_const_of_ne (hf : ContDiffWithinAt \u211d n f s x) (h : f x \u2260 0) :\n    ContDiffWithinAt \u211d n (fun x => f x ^ p) s x :=\n  hf.rpow contDiffWithinAt_const h\n\ntheorem ContDiffAt.rpow_const_of_ne (hf : ContDiffAt \u211d n f x) (h : f x \u2260 0) :\n    ContDiffAt \u211d n (fun x => f x ^ p) x :=\n  hf.rpow contDiffAt_const h\n\ntheorem ContDiffOn.rpow_const_of_ne (hf : ContDiffOn \u211d n f s) (h : \u2200 x \u2208 s, f x \u2260 0) :\n    ContDiffOn \u211d n (fun x => f x ^ p) s := fun x hx => (hf x hx).rpow_const_of_ne (h x hx)\n\ntheorem ContDiff.rpow_const_of_ne (hf : ContDiff \u211d n f) (h : \u2200 x, f x \u2260 0) :\n    ContDiff \u211d n fun x => f x ^ p :=\n  hf.rpow contDiff_const h\n\nvariable {m : \u2115}\n\ntheorem ContDiffWithinAt.rpow_const_of_le (hf : ContDiffWithinAt \u211d m f s x) (h : \u2191m \u2264 p) :\n    ContDiffWithinAt \u211d m (fun x => f x ^ p) s x :=\n  (contDiffAt_rpow_const_of_le h).comp_contDiffWithinAt x hf\n\ntheorem ContDiffAt.rpow_const_of_le (hf : ContDiffAt \u211d m f x) (h : \u2191m \u2264 p) :\n    ContDiffAt \u211d m (fun x => f x ^ p) x := by\n  rw [\u2190 contDiffWithinAt_univ] at *; exact hf.rpow_const_of_le h\n\ntheorem ContDiffOn.rpow_const_of_le (hf : ContDiffOn \u211d m f s) (h : \u2191m \u2264 p) :\n    ContDiffOn \u211d m (fun x => f x ^ p) s := fun x hx => (hf x hx).rpow_const_of_le h\n\ntheorem ContDiff.rpow_const_of_le (hf : ContDiff \u211d m f) (h : \u2191m \u2264 p) :\n    ContDiff \u211d m fun x => f x ^ p :=\n  contDiff_iff_contDiffAt.mpr fun _ => hf.contDiffAt.rpow_const_of_le h\n\nend fderiv\n\nsection deriv\n\nvariable {f g : \u211d \u2192 \u211d} {f' g' x y p : \u211d} {s : Set \u211d}\n\ntheorem HasDerivWithinAt.rpow (hf : HasDerivWithinAt f f' s x) (hg : HasDerivWithinAt g g' s x)\n    (h : 0 < f x) : HasDerivWithinAt (fun x => f x ^ g x)\n      (f' * g x * f x ^ (g x - 1) + g' * f x ^ g x * Real.log (f x)) s x := by\n  convert (hf.hasFDerivWithinAt.rpow hg.hasFDerivWithinAt h).hasDerivWithinAt using 1\n  dsimp; ring\n\ntheorem HasDerivAt.rpow (hf : HasDerivAt f f' x) (hg : HasDerivAt g g' x) (h : 0 < f x) :\n    HasDerivAt (fun x => f x ^ g x)\n      (f' * g x * f x ^ (g x - 1) + g' * f x ^ g x * Real.log (f x)) x := by\n  rw [\u2190 hasDerivWithinAt_univ] at *\n  exact hf.rpow hg h\n\ntheorem HasDerivWithinAt.rpow_const (hf : HasDerivWithinAt f f' s x) (hx : f x \u2260 0 \u2228 1 \u2264 p) :\n    HasDerivWithinAt (fun y => f y ^ p) (f' * p * f x ^ (p - 1)) s x := by\n  convert (hasDerivAt_rpow_const hx).comp_hasDerivWithinAt x hf using 1\n  ring\n\ntheorem HasDerivAt.rpow_const (hf : HasDerivAt f f' x) (hx : f x \u2260 0 \u2228 1 \u2264 p) :\n    HasDerivAt (fun y => f y ^ p) (f' * p * f x ^ (p - 1)) x := by\n  rw [\u2190 hasDerivWithinAt_univ] at *\n  exact hf.rpow_const hx\n\ntheorem derivWithin_rpow_const (hf : DifferentiableWithinAt \u211d f s x) (hx : f x \u2260 0 \u2228 1 \u2264 p)\n    (hxs : UniqueDiffWithinAt \u211d s x) :\n    derivWithin (fun x => f x ^ p) s x = derivWithin f s x * p * f x ^ (p - 1) :=\n  (hf.hasDerivWithinAt.rpow_const hx).derivWithin hxs\n\n@[simp]\ntheorem deriv_rpow_const (hf : DifferentiableAt \u211d f x) (hx : f x \u2260 0 \u2228 1 \u2264 p) :\n    deriv (fun x => f x ^ p) x = deriv f x * p * f x ^ (p - 1) :=\n  (hf.hasDerivAt.rpow_const hx).deriv\n\n", "theoremStatement": "theorem deriv_norm_ofReal_cpow (c : \u2102) {t : \u211d} (ht : 0 < t) :\n    (deriv fun x : \u211d \u21a6 \u2016(x : \u2102) ^ c\u2016) t = c.re * t ^ (c.re - 1) ", "theoremName": "deriv_norm_ofReal_cpow", "fileCreated": {"commit": "a9359cb30d5d2eb08c3c66959305c82fe45fab66", "date": "2023-06-06"}, "theoremCreated": {"commit": "c33fe046f64d7570c10713af5fb4ffd95d1d0613", "date": "2025-01-27"}, "file": "mathlib/Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean", "module": "Mathlib.Analysis.SpecialFunctions.Pow.Deriv", "jsonFile": "Mathlib.Analysis.SpecialFunctions.Pow.Deriv.jsonl", "positionMetadata": {"lineInFile": 626, "tokenPositionInFile": 31022, "theoremPositionInFile": 96}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 67, "numPremises": 85}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [EventuallyEq.deriv_eq (f := fun x \u21a6 x ^ c.re)]\n  \u00b7 rw [Real.deriv_rpow_const (Or.inl ht.ne')]\n  \u00b7 filter_upwards [eventually_gt_nhds ht] with x hx\n    rw [Complex.norm_eq_abs, Complex.abs_cpow_eq_rpow_re_of_pos hx]", "proofType": "tactic", "proofLengthLines": 4, "proofLengthTokens": 226}}
{"srcContext": "/-\nCopyright (c) 2024 Fangming Li. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Fangming Li, Jujian Zhang\n-/\nimport Mathlib.Algebra.Polynomial.AlgebraMap\nimport Mathlib.Algebra.Polynomial.Eval.SMul\nimport Mathlib.Algebra.Polynomial.Roots\nimport Mathlib.Order.Interval.Set.Infinite\nimport Mathlib.RingTheory.Polynomial.Pochhammer\nimport Mathlib.RingTheory.PowerSeries.WellKnown\nimport Mathlib.Tactic.FieldSimp\n\n/-!\n# Hilbert polynomials\n\nIn this file, we formalise the following statement: if `F` is a field with characteristic `0`, then\ngiven any `p : F[X]` and `d : \u2115`, there exists some `h : F[X]` such that for any large enough\n`n : \u2115`, `h(n)` is equal to the coefficient of `X\u207f` in the power series expansion of `p/(1 - X)\u1d48`.\nThis `h` is unique and is denoted as `Polynomial.hilbertPoly p d`.\n\nFor example, given `d : \u2115`, the power series expansion of `1/(1 - X)\u1d48\u207a\u00b9` in `F[X]`\nis `\u03a3\u2099 ((d + n).choose d)X\u207f`, which equals `\u03a3\u2099 ((n + 1)\u00b7\u00b7\u00b7(n + d)/d!)X\u207f` and hence\n`Polynomial.hilbertPoly (1 : F[X]) (d + 1)` is the polynomial `(X + 1)\u00b7\u00b7\u00b7(X + d)/d!`. Note that\nif `d! = 0` in `F`, then the polynomial `(X + 1)\u00b7\u00b7\u00b7(X + d)/d!` no longer works, so we do not want\nthe characteristic of `F` to be divisible by `d!`. As `Polynomial.hilbertPoly` may take any\n`p : F[X]` and `d : \u2115` as its inputs, it is necessary for us to assume that `CharZero F`.\n\n## Main definitions\n\n* `Polynomial.hilbertPoly p d`. Given a field `F`, a polynomial `p : F[X]` and a natural number `d`,\n  if `F` is of characteristic `0`, then `Polynomial.hilbertPoly p d : F[X]` is the polynomial whose\n  value at `n` equals the coefficient of `X\u207f` in the power series expansion of `p/(1 - X)\u1d48`.\n\n## TODO\n\n* Hilbert polynomials of finitely generated graded modules over Noetherian rings.\n-/\n\nopen Nat PowerSeries\n\nvariable (F : Type*) [Field F]\n\nnamespace Polynomial\n\n/--\nFor any field `F` and natural numbers `d` and `k`, `Polynomial.preHilbertPoly F d k`\nis defined as `(d.factorial : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (X - (C (k : F)) + 1))`.\nThis is the most basic form of Hilbert polynomials. `Polynomial.preHilbertPoly \u211a d 0`\nis exactly the Hilbert polynomial of the polynomial ring `\u211a[X_0,...,X_d]` viewed as\na graded module over itself. In fact, `Polynomial.preHilbertPoly F d k` is the\nsame as `Polynomial.hilbertPoly ((X : F[X]) ^ k) (d + 1)` for any field `F` and\n`d k : \u2115` (see the lemma `Polynomial.hilbertPoly_X_pow_succ`). See also the lemma\n`Polynomial.preHilbertPoly_eq_choose_sub_add`, which states that if `CharZero F`,\nthen for any `d k n : \u2115` with `k \u2264 n`, `(Polynomial.preHilbertPoly F d k).eval (n : F)`\nequals `(n - k + d).choose d`.\n-/\nnoncomputable def preHilbertPoly (d k : \u2115) : F[X] :=\n  (d.factorial : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (Polynomial.X - (C (k : F)) + 1))\n\nlemma natDegree_preHilbertPoly [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).natDegree = d := by\n  have hne : (d ! : F) \u2260 0 := by norm_cast; positivity\n  rw [preHilbertPoly, natDegree_smul _ (inv_ne_zero hne), natDegree_comp, ascPochhammer_natDegree,\n    add_comm_sub, \u2190 C_1, \u2190 map_sub, natDegree_add_C, natDegree_X, mul_one]\n\nlemma coeff_preHilbertPoly_self [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).coeff d = (d ! : F)\u207b\u00b9 := by\n  delta preHilbertPoly\n  have hne : (d ! : F) \u2260 0 := by norm_cast; positivity\n  have heq : d = ((ascPochhammer F d).comp (X - C (k : F) + 1)).natDegree :=\n    (natDegree_preHilbertPoly F d k).symm.trans (natDegree_smul _ (inv_ne_zero hne))\n  nth_rw 3 [heq]\n  calc\n  _ = (d ! : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (X - C ((k : F) - 1))).leadingCoeff := by\n    simp only [sub_add, \u2190 C_1, \u2190 map_sub, coeff_smul, coeff_natDegree]\n  _ = (d ! : F)\u207b\u00b9 := by\n    simp only [leadingCoeff_comp (ne_of_eq_of_ne (natDegree_X_sub_C _) one_ne_zero), Monic.def.1\n      (monic_ascPochhammer _ _), one_mul, leadingCoeff_X_sub_C, one_pow, smul_eq_mul, mul_one]\n\nlemma leadingCoeff_preHilbertPoly [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).leadingCoeff = (d ! : F)\u207b\u00b9 := by\n  rw [leadingCoeff, natDegree_preHilbertPoly, coeff_preHilbertPoly_self]\n\nlemma preHilbertPoly_eq_choose_sub_add [CharZero F] (d : \u2115) {k n : \u2115} (hkn : k \u2264 n):\n    (preHilbertPoly F d k).eval (n : F) = (n - k + d).choose d := by\n  have : (d ! : F) \u2260 0 := by norm_cast; positivity\n  calc\n  _ = (\u2191d !)\u207b\u00b9 * eval (\u2191(n - k + 1)) (ascPochhammer F d) := by simp [cast_sub hkn, preHilbertPoly]\n  _ = (n - k + d).choose d := by\n    rw [ascPochhammer_nat_eq_natCast_ascFactorial];\n    field_simp [ascFactorial_eq_factorial_mul_choose]\n\nvariable {F}\n\n/--\n`Polynomial.hilbertPoly p 0 = 0`; for any `d : \u2115`, `Polynomial.hilbertPoly p (d + 1)`\nis defined as `\u2211 i \u2208 p.support, (p.coeff i) \u2022 Polynomial.preHilbertPoly F d i`. If\n`M` is a graded module whose Poincar\u00e9 series can be written as `p(X)/(1 - X)\u1d48` for some\n`p : \u211a[X]` with integer coefficients, then `Polynomial.hilbertPoly p d` is the Hilbert\npolynomial of `M`. See also `Polynomial.coeff_mul_invOneSubPow_eq_hilbertPoly_eval`,\nwhich says that `PowerSeries.coeff F n (p * PowerSeries.invOneSubPow F d)` equals\n`(Polynomial.hilbertPoly p d).eval (n : F)` for any large enough `n : \u2115`.\n-/\nnoncomputable def hilbertPoly (p : F[X]) : (d : \u2115) \u2192 F[X]\n  | 0 => 0\n  | d + 1 => \u2211 i \u2208 p.support, (p.coeff i) \u2022 preHilbertPoly F d i\n\nlemma hilbertPoly_zero_left (d : \u2115) : hilbertPoly (0 : F[X]) d = 0 := by\n  delta hilbertPoly; induction d with\n  | zero => simp only\n  | succ d _ => simp only [coeff_zero, zero_smul, Finset.sum_const_zero]\n\nlemma hilbertPoly_zero_right (p : F[X]) : hilbertPoly p 0 = 0 := rfl\n\nlemma hilbertPoly_succ (p : F[X]) (d : \u2115) :\n    hilbertPoly p (d + 1) = \u2211 i \u2208 p.support, (p.coeff i) \u2022 preHilbertPoly F d i := rfl\n\nlemma hilbertPoly_X_pow_succ (d k : \u2115) :\n    hilbertPoly ((X : F[X]) ^ k) (d + 1) = preHilbertPoly F d k := by\n  delta hilbertPoly; simp\n\nlemma hilbertPoly_add_left (p q : F[X]) (d : \u2115) :\n    hilbertPoly (p + q) d = hilbertPoly p d + hilbertPoly q d := by\n  delta hilbertPoly\n  induction d with\n  | zero => simp only [add_zero]\n  | succ d _ =>\n      simp only [\u2190 coeff_add]\n      rw [\u2190 sum_def _ fun _ r => r \u2022 _]\n      exact sum_add_index _ _ _ (fun _ => zero_smul ..) (fun _ _ _ => add_smul ..)\n\nlemma hilbertPoly_smul (a : F) (p : F[X]) (d : \u2115) :\n    hilbertPoly (a \u2022 p) d = a \u2022 hilbertPoly p d := by\n  delta hilbertPoly\n  induction d with\n  | zero => simp only [smul_zero]\n  | succ d _ =>\n      simp only\n      rw [\u2190 sum_def _ fun _ r => r \u2022 _, \u2190 sum_def _ fun _ r => r \u2022 _, Polynomial.smul_sum,\n        sum_smul_index' _ _ _ fun i => zero_smul F (preHilbertPoly F d i)]\n      simp only [smul_assoc]\n\nvariable (F) in\n/--\nThe function that sends any `p : F[X]` to `Polynomial.hilbertPoly p d` is an `F`-linear map from\n`F[X]` to `F[X]`.\n-/\nnoncomputable def hilbertPoly_linearMap (d : \u2115) : F[X] \u2192\u2097[F] F[X] where\n  toFun p := hilbertPoly p d\n  map_add' p q := hilbertPoly_add_left p q d\n  map_smul' r p := hilbertPoly_smul r p d\n\nvariable [CharZero F]\n\n/--\nThe key property of Hilbert polynomials. If `F` is a field with characteristic `0`, `p : F[X]` and\n`d : \u2115`, then for any large enough `n : \u2115`, `(Polynomial.hilbertPoly p d).eval (n : F)` equals the\ncoefficient of `X\u207f` in the power series expansion of `p/(1 - X)\u1d48`.\n-/\ntheorem coeff_mul_invOneSubPow_eq_hilbertPoly_eval\n    {p : F[X]} (d : \u2115) {n : \u2115} (hn : p.natDegree < n) :\n    PowerSeries.coeff F n (p * invOneSubPow F d) = (hilbertPoly p d).eval (n : F) := by\n  delta hilbertPoly; induction d with\n  | zero => simp only [invOneSubPow_zero, Units.val_one, mul_one, coeff_coe, eval_zero]\n            exact coeff_eq_zero_of_natDegree_lt hn\n  | succ d hd =>\n      simp only [eval_finset_sum, eval_smul, smul_eq_mul]\n      rw [\u2190 Finset.sum_coe_sort]\n      have h_le (i : p.support) : (i : \u2115) \u2264 n :=\n        le_trans (le_natDegree_of_ne_zero <| mem_support_iff.1 i.2) hn.le\n      have h (i : p.support) : eval \u2191n (preHilbertPoly F d \u2191i) = (n + d - \u2191i).choose d := by\n        rw [preHilbertPoly_eq_choose_sub_add _ _ (h_le i), Nat.sub_add_comm (h_le i)]\n      simp_rw [h]\n      rw [Finset.sum_coe_sort _ (fun x => (p.coeff \u2191x) * (_ + d - \u2191x).choose _),\n        PowerSeries.coeff_mul, Finset.Nat.sum_antidiagonal_eq_sum_range_succ_mk,\n        invOneSubPow_val_eq_mk_sub_one_add_choose_of_pos _ _ (zero_lt_succ d)]\n      simp only [coeff_coe, coeff_mk]\n      symm\n      refine Finset.sum_subset_zero_on_sdiff (fun s hs \u21a6 ?_) (fun x hx \u21a6 ?_) (fun x hx \u21a6 ?_)\n      \u00b7 rw [Finset.mem_range_succ_iff]\n        exact h_le \u27e8s, hs\u27e9\n      \u00b7 simp only [Finset.mem_sdiff, mem_support_iff, not_not] at hx\n        rw [hx.2, zero_mul]\n      \u00b7 rw [add_comm, Nat.add_sub_assoc (h_le \u27e8x, hx\u27e9), succ_eq_add_one, add_tsub_cancel_right]\n\n/--\nThe polynomial satisfying the key property of `Polynomial.hilbertPoly p d` is unique.\n-/\ntheorem existsUnique_hilbertPoly (p : F[X]) (d : \u2115) :\n    \u2203! h : F[X], \u2203 N : \u2115, \u2200 n > N,\n    PowerSeries.coeff F n (p * invOneSubPow F d) = h.eval (n : F) := by\n  use hilbertPoly p d; constructor\n  \u00b7 use p.natDegree\n    exact fun n => coeff_mul_invOneSubPow_eq_hilbertPoly_eval d\n  \u00b7 rintro h \u27e8N, hhN\u27e9\n    apply eq_of_infinite_eval_eq h (hilbertPoly p d)\n    apply ((Set.Ioi_infinite (max N p.natDegree)).image cast_injective.injOn).mono\n    rintro x \u27e8n, hn, rfl\u27e9\n    simp only [Set.mem_Ioi, sup_lt_iff, Set.mem_setOf_eq] at hn \u22a2\n    rw [\u2190 coeff_mul_invOneSubPow_eq_hilbertPoly_eval d hn.2, hhN n hn.1]\n\n@[deprecated (since := \"2024-12-17\")] alias exists_unique_hilbertPoly := existsUnique_hilbertPoly\n\n", "theoremStatement": "/--\nIf `h : F[X]` and there exists some `N : \u2115` such that for any number `n : \u2115` bigger than `N`\nwe have `PowerSeries.coeff F n (p * invOneSubPow F d) = h.eval (n : F)`, then `h` is exactly\n`Polynomial.hilbertPoly p d`.\n-/\ntheorem eq_hilbertPoly_of_forall_coeff_eq_eval\n    {p h : F[X]} {d : \u2115} (N : \u2115) (hhN : \u2200 n > N,\n    PowerSeries.coeff F n (p * invOneSubPow F d) = h.eval (n : F)) :\n    h = hilbertPoly p d ", "theoremName": "Polynomial.eq_hilbertPoly_of_forall_coeff_eq_eval", "fileCreated": {"commit": "561e050467d2caa2e4ea5d81ca62600bf268b747", "date": "2024-12-02"}, "theoremCreated": {"commit": "bd9aea4b2403dcb1ec3998335f71109212ada88e", "date": "2024-12-09"}, "file": "mathlib/Mathlib/RingTheory/Polynomial/HilbertPoly.lean", "module": "Mathlib.RingTheory.Polynomial.HilbertPoly", "jsonFile": "Mathlib.RingTheory.Polynomial.HilbertPoly.jsonl", "positionMetadata": {"lineInFile": 205, "tokenPositionInFile": 9456, "theoremPositionInFile": 13}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 40, "numPremises": 50}, "proofMetadata": {"hasProof": true, "proof": ":=\n  ExistsUnique.unique (existsUnique_hilbertPoly p d) \u27e8N, hhN\u27e9\n    \u27e8p.natDegree, fun _ x => coeff_mul_invOneSubPow_eq_hilbertPoly_eval d x\u27e9", "proofType": "term", "proofLengthLines": 2, "proofLengthTokens": 141}}
