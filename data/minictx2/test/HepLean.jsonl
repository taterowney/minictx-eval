{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.SuperCommute\nimport Mathlib.Algebra.RingQuot\nimport Mathlib.RingTheory.TwoSidedIdeal.Operations\n/-!\n\n# Field operator algebra\n\n-/\n\nnamespace FieldSpecification\nopen FieldOpFreeAlgebra\nopen HepLean.List\nopen FieldStatistic\n\nvariable (\ud835\udcd5 : FieldSpecification)\n\n/-- The set contains the super-commutators equal to zero in the operator algebra.\n  This contains e.g. the super-commutator of two creation operators. -/\ndef fieldOpIdealSet : Set (FieldOpFreeAlgebra \ud835\udcd5) :=\n  { x |\n    (\u2203 (\u03c61 \u03c62 \u03c63 : \ud835\udcd5.CrAnFieldOp),\n        x = [ofCrAnOpF \u03c61, [ofCrAnOpF \u03c62, ofCrAnOpF \u03c63]\u209bca]\u209bca)\n    \u2228 (\u2203 (\u03c6c \u03c6c' : \ud835\udcd5.CrAnFieldOp) (_ : \ud835\udcd5 |>\u1d9c \u03c6c = .create) (_ : \ud835\udcd5 |>\u1d9c \u03c6c' = .create),\n      x = [ofCrAnOpF \u03c6c, ofCrAnOpF \u03c6c']\u209bca)\n    \u2228 (\u2203 (\u03c6a \u03c6a' : \ud835\udcd5.CrAnFieldOp) (_ : \ud835\udcd5 |>\u1d9c \u03c6a = .annihilate) (_ : \ud835\udcd5 |>\u1d9c \u03c6a' = .annihilate),\n      x = [ofCrAnOpF \u03c6a, ofCrAnOpF \u03c6a']\u209bca)\n    \u2228 (\u2203 (\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp) (_ : \u00ac (\ud835\udcd5 |>\u209b \u03c6) = (\ud835\udcd5 |>\u209b \u03c6')),\n      x = [ofCrAnOpF \u03c6, ofCrAnOpF \u03c6']\u209bca)}\n\n/-- For a field specification `\ud835\udcd5`, the algebra `\ud835\udcd5.FieldOpAlgebra` is defined as the quotient\n  of the free algebra `\ud835\udcd5.FieldOpFreeAlgebra` by the ideal generated by\n- `[ofCrAnOpF \u03c6c, ofCrAnOpF \u03c6c']\u209bca` for `\u03c6c` and `\u03c6c'` field creation operators.\n  This corresponds to the condition that two creation operators always super-commute.\n- `[ofCrAnOpF \u03c6a, ofCrAnOpF \u03c6a']\u209bca` for `\u03c6a` and `\u03c6a'` field annihilation operators.\n  This corresponds to the condition that two annihilation operators always super-commute.\n- `[ofCrAnOpF \u03c6, ofCrAnOpF \u03c6']\u209bca` for `\u03c6` and `\u03c6'` operators with different statistics.\n  This corresponds to the condition that two operators with different statistics always\n  super-commute. In other words, fermions and bosons always super-commute.\n- `[ofCrAnOpF \u03c61, [ofCrAnOpF \u03c62, ofCrAnOpF \u03c63]\u209bca]\u209bca`. This corresponds to the condition,\n  when combined with the conditions above, that the super-commutator is in the center of the\n  of the algebra.\n-/\nabbrev FieldOpAlgebra : Type := (TwoSidedIdeal.span \ud835\udcd5.fieldOpIdealSet).ringCon.Quotient\n\nnamespace FieldOpAlgebra\nvariable {\ud835\udcd5 : FieldSpecification}\n\n/-- The instance of a setoid on `FieldOpFreeAlgebra` from the ideal `TwoSidedIdeal`. -/\ninstance : Setoid (FieldOpFreeAlgebra \ud835\udcd5) := (TwoSidedIdeal.span \ud835\udcd5.fieldOpIdealSet).ringCon.toSetoid\n\nlemma equiv_iff_sub_mem_ideal (x y : FieldOpFreeAlgebra \ud835\udcd5) :\n    x \u2248 y \u2194 x - y \u2208 TwoSidedIdeal.span \ud835\udcd5.fieldOpIdealSet := by\n  rw [\u2190 TwoSidedIdeal.rel_iff]\n  rfl\n\nlemma equiv_iff_exists_add (x y : FieldOpFreeAlgebra \ud835\udcd5) :\n    x \u2248 y \u2194 \u2203 a, x = y + a \u2227 a \u2208 TwoSidedIdeal.span \ud835\udcd5.fieldOpIdealSet := by\n  apply Iff.intro\n  \u00b7 intro h\n    rw [equiv_iff_sub_mem_ideal] at h\n    use x - y\n    simp [h]\n  \u00b7 intro h\n    obtain \u27e8a, rfl, ha\u27e9 := h\n    rw [equiv_iff_sub_mem_ideal]\n    simp [ha]\n\n/-- For a field specification `\ud835\udcd5`, the projection\n\n`\ud835\udcd5.FieldOpFreeAlgebra \u2192\u2090[\u2102] FieldOpAlgebra \ud835\udcd5`\n\ntaking each element of `\ud835\udcd5.FieldOpFreeAlgebra` to its equivalence class in `FieldOpAlgebra \ud835\udcd5`. -/\ndef \u03b9 : FieldOpFreeAlgebra \ud835\udcd5 \u2192\u2090[\u2102] FieldOpAlgebra \ud835\udcd5 where\n  toFun := (TwoSidedIdeal.span \ud835\udcd5.fieldOpIdealSet).ringCon.mk'\n  map_one' := by rfl\n  map_mul' x y := by rfl\n  map_zero' := by rfl\n  map_add' x y := by rfl\n  commutes' x := by rfl\n\nlemma \u03b9_surjective : Function.Surjective (@\u03b9 \ud835\udcd5) := by\n  intro x\n  obtain \u27e8x\u27e9 := x\n  use x\n  rfl\n\nlemma \u03b9_apply (x : FieldOpFreeAlgebra \ud835\udcd5) : \u03b9 x = Quotient.mk _ x := rfl\n\nlemma \u03b9_of_mem_fieldOpIdealSet (x : FieldOpFreeAlgebra \ud835\udcd5) (hx : x \u2208 \ud835\udcd5.fieldOpIdealSet) :\n    \u03b9 x = 0 := by\n  rw [\u03b9_apply]\n  change \u27e6x\u27e7 = \u27e60\u27e7\n  simp only [ringConGen, Quotient.eq]\n  refine RingConGen.Rel.of x 0 ?_\n  simpa using hx\n\nlemma \u03b9_superCommuteF_of_create_create (\u03c6c \u03c6c' : \ud835\udcd5.CrAnFieldOp) (h\u03c6c : \ud835\udcd5 |>\u1d9c \u03c6c = .create)\n    (h\u03c6c' : \ud835\udcd5 |>\u1d9c \u03c6c' = .create) : \u03b9 [ofCrAnOpF \u03c6c, ofCrAnOpF \u03c6c']\u209bca = 0 := by\n  apply \u03b9_of_mem_fieldOpIdealSet\n  simp only [fieldOpIdealSet, exists_and_left, Set.mem_setOf_eq]\n  simp only [exists_prop]\n  right\n  left\n  use \u03c6c, \u03c6c', h\u03c6c, h\u03c6c'\n\nlemma \u03b9_superCommuteF_of_annihilate_annihilate (\u03c6a \u03c6a' : \ud835\udcd5.CrAnFieldOp)\n    (h\u03c6a : \ud835\udcd5 |>\u1d9c \u03c6a = .annihilate) (h\u03c6a' : \ud835\udcd5 |>\u1d9c \u03c6a' = .annihilate) :\n    \u03b9 [ofCrAnOpF \u03c6a, ofCrAnOpF \u03c6a']\u209bca = 0 := by\n  apply \u03b9_of_mem_fieldOpIdealSet\n  simp only [fieldOpIdealSet, exists_and_left, Set.mem_setOf_eq]\n  simp only [exists_prop]\n  right\n  right\n  left\n  use \u03c6a, \u03c6a', h\u03c6a, h\u03c6a'\n\nlemma \u03b9_superCommuteF_of_diff_statistic {\u03c6 \u03c8 : \ud835\udcd5.CrAnFieldOp}\n    (h : (\ud835\udcd5 |>\u209b \u03c6) \u2260 (\ud835\udcd5 |>\u209b \u03c8)) : \u03b9 [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca = 0 := by\n  apply \u03b9_of_mem_fieldOpIdealSet\n  simp only [fieldOpIdealSet, exists_prop, exists_and_left, Set.mem_setOf_eq]\n  right\n  right\n  right\n  use \u03c6, \u03c8\n\nlemma \u03b9_superCommuteF_zero_of_fermionic (\u03c6 \u03c8 : \ud835\udcd5.CrAnFieldOp)\n    (h : [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca \u2208 statisticSubmodule fermionic) :\n    \u03b9 [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca = 0 := by\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton] at h \u22a2\n  rcases statistic_neq_of_superCommuteF_fermionic h with h | h\n  \u00b7 simp only [ofCrAnListF_singleton]\n    apply \u03b9_superCommuteF_of_diff_statistic\n    simpa using h\n  \u00b7 simp [h]\n\nlemma \u03b9_superCommuteF_ofCrAnOpF_ofCrAnOpF_bosonic_or_zero (\u03c6 \u03c8 : \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca \u2208 statisticSubmodule bosonic \u2228\n    \u03b9 [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca = 0 := by\n  rcases superCommuteF_ofCrAnListF_ofCrAnListF_bosonic_or_fermionic [\u03c6] [\u03c8] with h | h\n  \u00b7 simp_all [ofCrAnListF_singleton]\n  \u00b7 simp_all only [ofCrAnListF_singleton]\n    right\n    exact \u03b9_superCommuteF_zero_of_fermionic _ _ h\n\n/-!\n\n## Super-commutes are in the center\n\n-/\n\n@[simp]\nlemma \u03b9_superCommuteF_ofCrAnOpF_superCommuteF_ofCrAnOpF_ofCrAnOpF (\u03c61 \u03c62 \u03c63 : \ud835\udcd5.CrAnFieldOp) :\n    \u03b9 [ofCrAnOpF \u03c61, [ofCrAnOpF \u03c62, ofCrAnOpF \u03c63]\u209bca]\u209bca = 0 := by\n  apply \u03b9_of_mem_fieldOpIdealSet\n  simp only [fieldOpIdealSet, exists_prop, exists_and_left, Set.mem_setOf_eq]\n  left\n  use \u03c61, \u03c62, \u03c63\n\nlemma \u03b9_superCommuteF_superCommuteF_ofCrAnOpF_ofCrAnOpF_ofCrAnOpF (\u03c61 \u03c62 \u03c63 : \ud835\udcd5.CrAnFieldOp) :\n    \u03b9 [[ofCrAnOpF \u03c61, ofCrAnOpF \u03c62]\u209bca, ofCrAnOpF \u03c63]\u209bca = 0 := by\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton]\n  rcases superCommuteF_ofCrAnListF_ofCrAnListF_bosonic_or_fermionic [\u03c61] [\u03c62] with h | h\n  \u00b7 rw [bonsonic_superCommuteF_symm h]\n    simp [ofCrAnListF_singleton]\n  \u00b7 rcases ofCrAnListF_bosonic_or_fermionic [\u03c63] with h' | h'\n    \u00b7 rw [superCommuteF_bonsonic_symm h']\n      simp [ofCrAnListF_singleton]\n    \u00b7 rw [superCommuteF_fermionic_fermionic_symm h h']\n      simp [ofCrAnListF_singleton]\n\nlemma \u03b9_superCommuteF_superCommuteF_ofCrAnOpF_ofCrAnOpF_ofCrAnListF (\u03c61 \u03c62 : \ud835\udcd5.CrAnFieldOp)\n    (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    \u03b9 [[ofCrAnOpF \u03c61, ofCrAnOpF \u03c62]\u209bca, ofCrAnListF \u03c6s]\u209bca = 0 := by\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton]\n  rcases superCommuteF_ofCrAnListF_ofCrAnListF_bosonic_or_fermionic [\u03c61] [\u03c62] with h | h\n  \u00b7 rw [superCommuteF_bosonic_ofCrAnListF_eq_sum _ _ h]\n    simp [ofCrAnListF_singleton, \u03b9_superCommuteF_superCommuteF_ofCrAnOpF_ofCrAnOpF_ofCrAnOpF]\n  \u00b7 rw [superCommuteF_fermionic_ofCrAnListF_eq_sum _ _ h]\n    simp [ofCrAnListF_singleton, \u03b9_superCommuteF_superCommuteF_ofCrAnOpF_ofCrAnOpF_ofCrAnOpF]\n\n@[simp]\nlemma \u03b9_superCommuteF_superCommuteF_ofCrAnOpF_ofCrAnOpF_fieldOpFreeAlgebra (\u03c61 \u03c62 : \ud835\udcd5.CrAnFieldOp)\n    (a : \ud835\udcd5.FieldOpFreeAlgebra) : \u03b9 [[ofCrAnOpF \u03c61, ofCrAnOpF \u03c62]\u209bca, a]\u209bca = 0 := by\n  change (\u03b9.toLinearMap \u2218\u2097 superCommuteF [ofCrAnOpF \u03c61, ofCrAnOpF \u03c62]\u209bca) a = _\n  have h1 : (\u03b9.toLinearMap \u2218\u2097 superCommuteF [ofCrAnOpF \u03c61, ofCrAnOpF \u03c62]\u209bca) = 0 := by\n    apply (ofCrAnListFBasis.ext fun l \u21a6 ?_)\n    simp [\u03b9_superCommuteF_superCommuteF_ofCrAnOpF_ofCrAnOpF_ofCrAnListF]\n  rw [h1]\n  simp\n\n", "theoremStatement": "lemma \u03b9_commute_fieldOpFreeAlgebra_superCommuteF_ofCrAnOpF_ofCrAnOpF (\u03c61 \u03c62 : \ud835\udcd5.CrAnFieldOp)\n    (a : \ud835\udcd5.FieldOpFreeAlgebra) : \u03b9 a * \u03b9 [ofCrAnOpF \u03c61, ofCrAnOpF \u03c62]\u209bca -\n    \u03b9 [ofCrAnOpF \u03c61, ofCrAnOpF \u03c62]\u209bca * \u03b9 a = 0 ", "theoremName": "FieldSpecification.FieldOpAlgebra.\u03b9_commute_fieldOpFreeAlgebra_superCommuteF_ofCrAnOpF_ofCrAnOpF", "fileCreated": {"commit": "ea6e12829370d9630a7e65200c8349e9086c05ba", "date": "2025-02-03"}, "theoremCreated": {"commit": "171e80fc04016aed422340742f3e0a14de6d20b0", "date": "2025-02-03"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpAlgebra/Basic.lean", "module": "HepLean.PerturbationTheory.FieldOpAlgebra.Basic", "jsonFile": "HepLean.PerturbationTheory.FieldOpAlgebra.Basic.jsonl", "positionMetadata": {"lineInFile": 196, "tokenPositionInFile": 7726, "theoremPositionInFile": 16}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 5, "repositoryPremises": true, "numRepositoryPremises": 13, "numPremises": 124}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rcases \u03b9_superCommuteF_ofCrAnOpF_ofCrAnOpF_bosonic_or_zero \u03c61 \u03c62 with h | h\n  swap\n  \u00b7 simp [h]\n  trans - \u03b9 [[ofCrAnOpF \u03c61, ofCrAnOpF \u03c62]\u209bca, a]\u209bca\n  \u00b7 rw [bosonic_superCommuteF h]\n    simp\n  \u00b7 simp", "proofType": "tactic", "proofLengthLines": 7, "proofLengthTokens": 206}}
{"srcContext": "/-\nCopyright (c) 2025 Gordon Hsu. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Gordon Hsu\n-/\nimport Mathlib.LinearAlgebra.Matrix.SchurComplement\nimport HepLean.Mathematics.SchurTriangulation\n\n/-! # Extra lemmas regarding `Lorentz.SL2C.toSelfAdjointMap`\n\nThis file redefines `Lorentz.SL2C.toSelfAdjointMap` by dropping the special linear condition for its\nfirst argument `M`. Then, `Lorentz.SL2C.toSelfAdjointMap_det_one` is proved for `M` being upper\ntriangular.\n\n## Main definitions\n\n- `Lorentz.SL2C.toSelfAdjointMap'`: definitionally equal to `Lorentz.SL2C.toSelfAdjointMap` but `M`\nis not required to be special linear.\n- `Lorentz.SL2C.toSelfAdjointMap_det_one'`: proves `Lorentz.SL2C.toSelfAdjointMap_det_one` with the\nadditional requirement that `M` be upper triangular. The general case is reduced to this special\ncase via `Matrix.schur_triangulation` in `Lorentz.SL2C.toSelfAdjointMap_det_one`.\n\n-/\n\nnamespace Lorentz\n\nopen scoped Matrix\nopen scoped ComplexConjugate\n\n/-- A notation for the type of complex 2-by-2 matrices. It would have been better to make it an\nabbreviation if it wasn't for Lean's inability to recognize `\u2102\u00b2\u02e3\u00b2` as an identifier. -/\nscoped notation \"\u2102\u00b2\u02e3\u00b2\" => Matrix (Fin 2) (Fin 2) \u2102\n\n/-- A convenient abbreviation for the type of self-adjoint complex 2-by-2 matrices. -/\nnoncomputable abbrev \u210d\u2082 := selfAdjoint \u2102\u00b2\u02e3\u00b2\n\nnamespace SL2C\n\n/-- Definitionally equal to `Lorentz.SL2C.toSelfAdjointMap` but dropping the requirement that `M` be\nspecial linear. -/\nnoncomputable def toSelfAdjointMap' (M : \u2102\u00b2\u02e3\u00b2) : \u210d\u2082 \u2192\u2097[\u211d] \u210d\u2082 where\n  toFun | \u27e8A, hA\u27e9 => \u27e8M * A * M\u1d34, hA.conjugate M\u27e9\n  map_add' | \u27e8A, _\u27e9, \u27e8B, _\u27e9 => Subtype.ext <|\n    show M * (A + B) * M\u1d34 = M * A * M\u1d34 + M * B * M\u1d34 by noncomm_ring\n  map_smul' | r, \u27e8A, _\u27e9 => Subtype.ext <| by simp\n\n/-! ## Showing `Lorentz.SL2C.toSelfAdjointMap` has determinant 1\n\nSince `Lorentz.\u210d\u2082` as a real vector space has the 4 Pauli matrices as basis, we know that its vector\nrepresentation consists of 4 real components. This makes the matrix representation of\n`toSelfAdjointMap M` a 4-by-4 real matrix `F`. To make the computation of `F.det` manageable, the\nfollowing basis is used instead of the Pauli matrices to induce as many zeros as possible in `F`:\n$$\nE_0 = \\begin{bmatrix} 1 & 0 \\\\ 0 & 0 \\end{bmatrix},\nE_1 = \\begin{bmatrix} 0 & 0 \\\\ 0 & 1 \\end{bmatrix},\nE_2 = \\sigma_1 = \\begin{bmatrix} 0 & 1 \\\\ 1 & 0 \\end{bmatrix},\nE_3 = -\\sigma_2 = \\begin{bmatrix} 0 & i \\\\ -i & 0 \\end{bmatrix},\n$$\nSuppose that $M = \\begin{bmatrix} x & \u25a1 \\\\ 0 & y \\end{bmatrix}$ is upper triangular, the basis\n$\\{E_k\\}_{k=0}^3$ induces the matrix representation\n$$\nF = \\begin{bmatrix}\n  \\lvert x\\rvert^2 & \u25a1 & \u25a1 & \u25a1 \\\\\n  0 & \\lvert y\\rvert^2 & 0 & 0 \\\\\n  0 & \u25a1 & \\operatorname{Re}(x\\bar{y}) & -\\operatorname{Im}(x\\bar{y}) \\\\\n  0 & \u25a1 & \\operatorname{Im}(x\\bar{y}) & \\operatorname{Re}(x\\bar{y}) \\\\\n\\end{bmatrix}.\n$$\nIf $xy = 1$, the Schur complement formula `Matrix.det_fromBlocks\u2082\u2082` yields\n$$\\begin{align}\n\\det F &=\n\\begin{vmatrix}\n  \\operatorname{Re}(x\\bar{y}) & -\\operatorname{Im}(x\\bar{y}) \\\\\n  \\operatorname{Im}(x\\bar{y}) & \\operatorname{Re}(x\\bar{y})\n\\end{vmatrix} \\det\\left(\n  \\begin{bmatrix} \\lvert x\\rvert^2 & \u25a1 \\\\ 0 & \\lvert y\\rvert^2 \\end{bmatrix} -\n  \\begin{bmatrix} \u25a1 & \u25a1 \\\\ 0 & 0 \\end{bmatrix}\n  \\begin{bmatrix} \u25a1 & \u25a1 \\\\ \u25a1 & \u25a1 \\end{bmatrix}\n  \\begin{bmatrix} 0 & \u25a1 \\\\ 0 & \u25a1 \\end{bmatrix}\n\\right) \\\\ &=\n\\lvert x\\bar{y}\\rvert^2 \\lvert x\\rvert^2 \\lvert y\\rvert^2 = \\lvert xy\\rvert^4 = 1.\n\\end{align}$$\nThis concludes `Lorentz.SL2C.toSelfAdjointMap_det_one'`. To get\n`Lorentz.SL2C.toSelfAdjointMap_det_one`, triangulate the special linear matrix using\n`Matrix.schur_triangulation`, and observe that `Matrix.schurTriangulation` preserves the determinant\nwhich is 1.\n\n-/\n\nopen Complex (I normSq) in\nlemma toSelfAdjointMap_det_one' {M : \u2102\u00b2\u02e3\u00b2} (hM : M.IsUpperTriangular) (detM : M.det = 1) :\n    LinearMap.det (toSelfAdjointMap' M) = 1 :=\n  let b : Basis (Fin 2 \u2295 Fin 2) \u211d \u210d\u2082 := Basis.ofEquivFun {\n    toFun := fun \u27e8A, _\u27e9 => ![(A 0 0).re, (A 1 1).re] \u2295\u1d65 ![(A 0 1).re, (A 0 1).im]\n    map_add' := fun _ _ => funext fun | .inl 0 | .inl 1 | .inr 0 | .inr 1 => rfl\n    map_smul' := fun _ _ => funext fun | .inl 0 | .inl 1 | .inr 0 | .inr 1 => by simp\n    invFun := fun p => {\n      val :=\n        let z : \u2102 := \u27e8p (.inr 0), p (.inr 1)\u27e9\n        !![p (.inl 0), z; conj z, p (.inl 1)]\n      property := Matrix.ext fun | 0, 0 | 0, 1 | 1, 0 | 1, 1 => by simp\n    }\n    left_inv := fun \u27e8A, hA\u27e9 => Subtype.ext <| Matrix.ext fun\n      | 0, 1 => rfl\n      | 1, 0 => show conj (A 0 1) = A 1 0 from congrFun\u2082 hA 1 0\n      | 0, 0 => show (A 0 0).re = A 0 0 from Complex.conj_eq_iff_re.mp (congrFun\u2082 hA 0 0)\n      | 1, 1 => show (A 1 1).re = A 1 1 from Complex.conj_eq_iff_re.mp (congrFun\u2082 hA 1 1)\n    right_inv := fun _ => funext fun | .inl 0 | .inl 1 | .inr 0 | .inr 1 => rfl\n  }\n  let E\u2080 : \u2102\u00b2\u02e3\u00b2 := !![1, 0; conj 0, 0] -- b (.inl 0)\n  let E\u2081 : \u2102\u00b2\u02e3\u00b2 := !![0, 0; conj 0, 1] -- b (.inl 1)\n  let E\u2082 : \u2102\u00b2\u02e3\u00b2 := !![0, 1; conj 1, 0] -- b (.inr 0)\n  let E\u2083 : \u2102\u00b2\u02e3\u00b2 := !![0, I; conj I, 0] -- b (.inr 1)\n  let F : Matrix (Fin 2 \u2295 Fin 2) (Fin 2 \u2295 Fin 2) \u211d := LinearMap.toMatrix b b (toSelfAdjointMap' M)\n  let A := F.toBlocks\u2081\u2081; let B := F.toBlocks\u2081\u2082; let C := F.toBlocks\u2082\u2081; let D := F.toBlocks\u2082\u2082\n  let x := M 0 0; let y := M 1 1; have hM10 : M 1 0 = 0 := hM <| show 0 < 1 by decide\n  have he : M = !![x, _; 0, y] := Matrix.ext fun | 0, 0 | 0, 1 | 1, 1 => rfl | 1, 0 => hM10\n  have he' : M\u1d34 = !![conj x, 0; _, conj y] :=\n    Matrix.ext fun | 0, 0 | 1, 0 | 1, 1 => rfl | 0, 1 => by simp [hM10]\n  have detA_one : normSq x * normSq y = 1 := congrArg Complex.re <|\n    calc \u2191(normSq x * normSq y)\n      _ = x * conj x * (y * conj y) := by simp [Complex.mul_conj]\n      _ = x * y * (conj y * conj x) := by ring\n      _ = x * y * conj (x * y) := congrArg _ (star_mul ..).symm\n      _ = 1 := suffices x * y = 1 by simp [this]\n        calc x * y\n          _ = !![x, _; 0, y].det := by simp\n          _ = M.det := congrArg _ he.symm\n          _ = 1 := detM\n  have detD_one : D.det = 1 :=\n    let z := x * conj y\n    have k\u2080 : (M * E\u2082 * M\u1d34) 0 1 = z := by rw [he', he]; simp [E\u2082, z]\n    have k\u2081 : (M * E\u2083 * M\u1d34) 0 1 = \u27e8-z.im, z.re\u27e9 :=\n      calc\n        _ = x * I * conj y := by rw [he', he]; simp [E\u2083]\n        _ = Complex.I * z := by ring\n        _ = \u27e8-z.im, z.re\u27e9 := z.I_mul\n    have hD : D = !![z.re, -z.im; z.im, z.re] := Matrix.ext fun\n      | 0, 0 => congrArg Complex.re k\u2080 | 1, 0 => congrArg Complex.im k\u2080\n      | 0, 1 => congrArg Complex.re k\u2081 | 1, 1 => congrArg Complex.im k\u2081\n    calc D.det\n      _ = normSq z := by simp [hD, z.normSq_apply]\n      _ = normSq x * normSq y := by simp [x.normSq_mul, z]\n      _ = 1 := detA_one\n\n  letI : Invertible D.det := detD_one \u25b8 invertibleOne\n  letI : Invertible D := D.invertibleOfDetInvertible\n  have hE : A - B * \u215fD * C = !![normSq x, _; 0, normSq y] :=\n    have k : (M * E\u2080 * M\u1d34) 0 1 = 0 := by rw [he', he]; simp [E\u2080]\n    have hC00 : C 0 0 = 0 := congrArg Complex.re k\n    have hC10 : C 1 0 = 0 := congrArg Complex.im k\n    Matrix.ext fun\n      | 0, 1 => rfl\n      | 1, 0 =>\n        have hA10 : A 1 0 = 0 := congrArg Complex.re <|\n          show (M * E\u2080 * M\u1d34) 1 1 = 0 by rw [he', he]; simp [E\u2080]\n        show A 1 0 - (B * \u215fD) 1 \u2b1d\u1d65 (C \u00b7 0) = 0 by simp [hC00, hC10, hA10]\n      | 0, 0 =>\n        have hA00 : A 0 0 = normSq x := congrArg Complex.re <|\n          show (M * E\u2080 * M\u1d34) 0 0 = normSq x by rw [he', he]; simp [E\u2080, x.mul_conj]\n        show A 0 0 - (B * \u215fD) 0 \u2b1d\u1d65 (C \u00b7 0) = normSq x by simp [hC00, hC10, hA00]\n      | 1, 1 =>\n        have hA11 : A 1 1 = normSq y := congrArg Complex.re <|\n          show (M * E\u2081 * M\u1d34) 1 1 = normSq y by rw [he', he]; simp [E\u2081, y.mul_conj]\n        have hB10 : B 1 0 = 0 := congrArg Complex.re <|\n          show (M * E\u2082 * M\u1d34) 1 1 = 0 by rw [he', he]; simp [E\u2082]\n        have hB11 : B 1 1 = 0 := congrArg Complex.re <|\n          show (M * E\u2083 * M\u1d34) 1 1 = 0 by rw [he', he]; simp [E\u2083]\n        calc A 1 1 - (B * \u215fD * C) 1 1\n          _ = A 1 1 - B 1 \u2b1d\u1d65 ((\u215fD * C) \u00b7 1) := by noncomm_ring\n          _ = normSq y := by simp [hB10, hB11, hA11]\n  calc LinearMap.det (toSelfAdjointMap' M)\n    _ = F.det := (LinearMap.det_toMatrix ..).symm\n    _ = D.det * (A - B * \u215fD * C).det := F.fromBlocks_toBlocks \u25b8 Matrix.det_fromBlocks\u2082\u2082 ..\n    _ = 1 := by rw [hE]; simp [detD_one, detA_one]\n\n/-- This promotes `Lorentz.SL2C.toSelfAdjointMap M` and its definitional equivalence,\n`Lorentz.SL2C.toSelfAdjointMap' M`, to a linear equivalence by recognizing the linear inverse to be\n`Lorentz.SL2C.toSelfAdjointMap M\u207b\u00b9`, i.e., `Lorentz.SL2C.toSelfAdjointMap' M\u207b\u00b9`. -/\nnoncomputable def toSelfAdjointEquiv (M : \u2102\u00b2\u02e3\u00b2) [Invertible M] : \u210d\u2082 \u2243\u2097[\u211d] \u210d\u2082 where\n  toLinearMap := toSelfAdjointMap' M\n  invFun := toSelfAdjointMap' M\u207b\u00b9\n  left_inv | \u27e8A, _\u27e9 => Subtype.ext <|\n    calc M\u207b\u00b9 * (M * A * M\u1d34) * M\u207b\u00b9\u1d34\n      _ = M\u207b\u00b9 * \u2191M * A * (M\u207b\u00b9 * M)\u1d34 := by noncomm_ring [Matrix.conjTranspose_mul]\n      _ = A := by simp\n  right_inv | \u27e8A, _\u27e9 => Subtype.ext <|\n    calc M * (M\u207b\u00b9 * A * M\u207b\u00b9\u1d34) * M\u1d34\n      _ = M * M\u207b\u00b9 * A * (M * M\u207b\u00b9)\u1d34 := by noncomm_ring [Matrix.conjTranspose_mul]\n      _ = A := by simp\n\n", "theoremStatement": "lemma toSelfAdjointMap_mul (M N : \u2102\u00b2\u02e3\u00b2) :\n    toSelfAdjointMap' (M * N) = toSelfAdjointMap' M \u2218\u2097 toSelfAdjointMap' N ", "theoremName": "Lorentz.SL2C.toSelfAdjointMap_mul", "fileCreated": {"commit": "0297f0e288f1fb8219be17c1e5ceaaae33a3da3c", "date": "2025-01-10"}, "theoremCreated": {"commit": "0297f0e288f1fb8219be17c1e5ceaaae33a3da3c", "date": "2025-01-10"}, "file": "HepLean/HepLean/Lorentz/SL2C/SelfAdjoint.lean", "module": "HepLean.Lorentz.SL2C.SelfAdjoint", "jsonFile": "HepLean.Lorentz.SL2C.SelfAdjoint.jsonl", "positionMetadata": {"lineInFile": 192, "tokenPositionInFile": 9084, "theoremPositionInFile": 3}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 100}, "proofMetadata": {"hasProof": true, "proof": ":=\n  LinearMap.ext fun A => Subtype.ext <|\n    show M * N * A * (M * N)\u1d34 = M * (N * A * N\u1d34) * M\u1d34 by noncomm_ring [Matrix.conjTranspose_mul]", "proofType": "term", "proofLengthLines": 2, "proofLengthTokens": 139}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.WickContraction.Join\n/-!\n\n# Sign associated with joining two Wick contractions\n\n-/\n\nopen FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\nnamespace WickContraction\nvariable {n : \u2115} (c : WickContraction n)\nopen HepLean.List\nopen FieldOpAlgebra\n\nopen FieldStatistic\n\nlemma stat_signFinset_right {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) (i j : Fin [\u03c6s\u039b]\u1d58\u1d9c.length) :\n    (\ud835\udcd5 |>\u209b \u27e8[\u03c6s\u039b]\u1d58\u1d9c.get, \u03c6suc\u039b.signFinset i j\u27e9) =\n    (\ud835\udcd5 |>\u209b \u27e8\u03c6s.get, (\u03c6suc\u039b.signFinset i j).map uncontractedListEmd\u27e9) := by\n  simp only [ofFinset]\n  congr 1\n  rw [\u2190 fin_finset_sort_map_monotone]\n  simp only [List.map_map, List.map_inj_left, Finset.mem_sort, List.get_eq_getElem,\n    Function.comp_apply, getElem_uncontractedListEmd, implies_true]\n  intro i j h\n  exact uncontractedListEmd_strictMono h\n\nlemma signFinset_right_map_uncontractedListEmd_eq_filter {\u03c6s : List \ud835\udcd5.FieldOp}\n    (\u03c6s\u039b : WickContraction \u03c6s.length) (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length)\n    (i j : Fin [\u03c6s\u039b]\u1d58\u1d9c.length) : (\u03c6suc\u039b.signFinset i j).map uncontractedListEmd =\n    ((join \u03c6s\u039b \u03c6suc\u039b).signFinset (uncontractedListEmd i) (uncontractedListEmd j)).filter\n    (fun c => c \u2208 \u03c6s\u039b.uncontracted) := by\n  ext a\n  simp only [Finset.mem_map, Finset.mem_filter]\n  apply Iff.intro\n  \u00b7 intro h\n    obtain \u27e8a, ha, rfl\u27e9 := h\n    apply And.intro\n    \u00b7 simp_all only [signFinset, Finset.mem_filter, Finset.mem_univ, true_and,\n      join_getDual?_apply_uncontractedListEmb, Option.map_eq_none', Option.isSome_map']\n      apply And.intro\n      \u00b7 exact uncontractedListEmd_strictMono ha.1\n      \u00b7 apply And.intro\n        \u00b7 exact uncontractedListEmd_strictMono ha.2.1\n        \u00b7 have ha2 := ha.2.2\n          simp_all only [and_true]\n          rcases ha2 with ha2 | ha2\n          \u00b7 simp [ha2]\n          \u00b7 right\n            intro h\n            apply lt_of_lt_of_eq (uncontractedListEmd_strictMono (ha2 h))\n            rw [Option.get_map]\n    \u00b7 exact uncontractedListEmd_mem_uncontracted a\n  \u00b7 intro h\n    have h2 := h.2\n    have h2' := uncontractedListEmd_surjective_mem_uncontracted a h.2\n    obtain \u27e8a, rfl\u27e9 := h2'\n    use a\n    simp_all only [signFinset, Finset.mem_filter, Finset.mem_univ,\n      join_getDual?_apply_uncontractedListEmb, Option.map_eq_none', Option.isSome_map', true_and,\n      and_true, and_self]\n    apply And.intro\n    \u00b7 have h1 := h.1\n      rw [StrictMono.lt_iff_lt] at h1\n      exact h1\n      exact fun _ _ h => uncontractedListEmd_strictMono h\n    \u00b7 apply And.intro\n      \u00b7 have h1 := h.2.1\n        rw [StrictMono.lt_iff_lt] at h1\n        exact h1\n        exact fun _ _ h => uncontractedListEmd_strictMono h\n      \u00b7 have h1 := h.2.2\n        simp_all only [and_true]\n        rcases h1 with h1 | h1\n        \u00b7 simp [h1]\n        \u00b7 right\n          intro h\n          have h1' := h1 h\n          have hl : uncontractedListEmd i < uncontractedListEmd ((\u03c6suc\u039b.getDual? a).get h) := by\n            apply lt_of_lt_of_eq h1'\n            simp [Option.get_map]\n          rw [StrictMono.lt_iff_lt] at hl\n          exact hl\n          exact fun _ _ h => uncontractedListEmd_strictMono h\n\nlemma sign_right_eq_prod_mul_prod {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) :\n    \u03c6suc\u039b.sign = (\u220f a, \ud835\udce2(\ud835\udcd5|>\u209b [\u03c6s\u039b]\u1d58\u1d9c[\u03c6suc\u039b.sndFieldOfContract a], \ud835\udcd5|>\u209b \u27e8\u03c6s.get,\n    ((join \u03c6s\u039b \u03c6suc\u039b).signFinset (uncontractedListEmd (\u03c6suc\u039b.fstFieldOfContract a))\n      (uncontractedListEmd (\u03c6suc\u039b.sndFieldOfContract a))).filter\n      (fun c => \u00ac c \u2208 \u03c6s\u039b.uncontracted)\u27e9)) *\n    (\u220f a, \ud835\udce2(\ud835\udcd5|>\u209b [\u03c6s\u039b]\u1d58\u1d9c[\u03c6suc\u039b.sndFieldOfContract a], \ud835\udcd5|>\u209b \u27e8\u03c6s.get,\n      ((join \u03c6s\u039b \u03c6suc\u039b).signFinset (uncontractedListEmd (\u03c6suc\u039b.fstFieldOfContract a))\n        (uncontractedListEmd (\u03c6suc\u039b.sndFieldOfContract a)))\u27e9)) := by\n  rw [\u2190 Finset.prod_mul_distrib, sign]\n  congr\n  funext a\n  rw [\u2190 map_mul]\n  congr\n  rw [stat_signFinset_right, signFinset_right_map_uncontractedListEmd_eq_filter]\n  rw [ofFinset_filter]\n\nlemma join_singleton_signFinset_eq_filter {\u03c6s : List \ud835\udcd5.FieldOp}\n    {i j : Fin \u03c6s.length} (h : i < j)\n    (\u03c6suc\u039b : WickContraction [singleton h]\u1d58\u1d9c.length) :\n    (join (singleton h) \u03c6suc\u039b).signFinset i j =\n    ((singleton h).signFinset i j).filter (fun c => \u00ac\n    (((join (singleton h) \u03c6suc\u039b).getDual? c).isSome \u2227\n    ((h1 : ((join (singleton h) \u03c6suc\u039b).getDual? c).isSome) \u2192\n    (((join (singleton h) \u03c6suc\u039b).getDual? c).get h1) < i))) := by\n  ext a\n  simp only [signFinset, Finset.mem_filter, Finset.mem_univ, true_and, not_and, not_forall, not_lt,\n    and_assoc, and_congr_right_iff]\n  intro h1 h2\n  have h1 : (singleton h).getDual? a = none := by\n    rw [singleton_getDual?_eq_none_iff_neq]\n    omega\n  simp only [h1, Option.isSome_none, Bool.false_eq_true, IsEmpty.forall_iff, or_self, true_and]\n  apply Iff.intro\n  \u00b7 intro h1 h2\n    rcases h1 with h1 | h1\n    \u00b7 simp only [h1, Option.isSome_none, Bool.false_eq_true, IsEmpty.exists_iff]\n      have h2' : \u00ac (((singleton h).join \u03c6suc\u039b).getDual? a).isSome := by\n        exact Option.not_isSome_iff_eq_none.mpr h1\n      exact h2' h2\n    use h2\n    have h1 := h1 h2\n    omega\n  \u00b7 intro h2\n    by_cases h2' : (((singleton h).join \u03c6suc\u039b).getDual? a).isSome = true\n    \u00b7 have h2 := h2 h2'\n      obtain \u27e8hb, h2\u27e9 := h2\n      right\n      intro hl\n      apply lt_of_le_of_ne h2\n      by_contra hn\n      have hij : ((singleton h).join \u03c6suc\u039b).getDual? i = j := by\n        rw [@getDual?_eq_some_iff_mem]\n        simp [join, singleton]\n      simp only [hn, getDual?_getDual?_get_get, Option.some.injEq] at hij\n      omega\n    \u00b7 simp only [Bool.not_eq_true, Option.not_isSome, Option.isNone_iff_eq_none] at h2'\n      simp [h2']\n\nlemma join_singleton_left_signFinset_eq_filter {\u03c6s : List \ud835\udcd5.FieldOp}\n    {i j : Fin \u03c6s.length} (h : i < j)\n    (\u03c6suc\u039b : WickContraction [singleton h]\u1d58\u1d9c.length) :\n    (\ud835\udcd5 |>\u209b \u27e8\u03c6s.get, (singleton h).signFinset i j\u27e9)\n    = (\ud835\udcd5 |>\u209b \u27e8\u03c6s.get, (join (singleton h) \u03c6suc\u039b).signFinset i j\u27e9) *\n      (\ud835\udcd5 |>\u209b \u27e8\u03c6s.get, ((singleton h).signFinset i j).filter (fun c =>\n      (((join (singleton h) \u03c6suc\u039b).getDual? c).isSome \u2227\n      ((h1 : ((join (singleton h) \u03c6suc\u039b).getDual? c).isSome) \u2192\n      (((join (singleton h) \u03c6suc\u039b).getDual? c).get h1) < i)))\u27e9) := by\n  conv_rhs =>\n    left\n    rw [join_singleton_signFinset_eq_filter]\n  rw [mul_comm]\n  exact (ofFinset_filter_mul_neg \ud835\udcd5.fieldOpStatistic _ _ _).symm\n\n/-- The difference in sign between `\u03c6suc\u039b.sign` and the direct contribution of `\u03c6suc\u039b` to\n  `(join (singleton h) \u03c6suc\u039b)`. -/\ndef joinSignRightExtra {\u03c6s : List \ud835\udcd5.FieldOp}\n    {i j : Fin \u03c6s.length} (h : i < j)\n    (\u03c6suc\u039b : WickContraction [singleton h]\u1d58\u1d9c.length) : \u2102 :=\n    \u220f a, \ud835\udce2(\ud835\udcd5|>\u209b [singleton h]\u1d58\u1d9c[\u03c6suc\u039b.sndFieldOfContract a], \ud835\udcd5|>\u209b \u27e8\u03c6s.get,\n    ((join (singleton h) \u03c6suc\u039b).signFinset (uncontractedListEmd (\u03c6suc\u039b.fstFieldOfContract a))\n    (uncontractedListEmd (\u03c6suc\u039b.sndFieldOfContract a))).filter\n    (fun c => \u00ac c \u2208 (singleton h).uncontracted)\u27e9)\n\n/-- The difference in sign between `(singleton h).sign` and the direct contribution of\n  `(singleton h)` to `(join (singleton h) \u03c6suc\u039b)`. -/\ndef joinSignLeftExtra {\u03c6s : List \ud835\udcd5.FieldOp}\n    {i j : Fin \u03c6s.length} (h : i < j)\n    (\u03c6suc\u039b : WickContraction [singleton h]\u1d58\u1d9c.length) : \u2102 :=\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s[j], (\ud835\udcd5 |>\u209b \u27e8\u03c6s.get, ((singleton h).signFinset i j).filter (fun c =>\n      (((join (singleton h) \u03c6suc\u039b).getDual? c).isSome \u2227\n      ((h1 : ((join (singleton h) \u03c6suc\u039b).getDual? c).isSome) \u2192\n      (((join (singleton h) \u03c6suc\u039b).getDual? c).get h1) < i)))\u27e9))\n\nlemma join_singleton_sign_left {\u03c6s : List \ud835\udcd5.FieldOp}\n    {i j : Fin \u03c6s.length} (h : i < j)\n    (\u03c6suc\u039b : WickContraction [singleton h]\u1d58\u1d9c.length) :\n    (singleton h).sign = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s[j],\n    (\ud835\udcd5 |>\u209b \u27e8\u03c6s.get, (join (singleton h) \u03c6suc\u039b).signFinset i j\u27e9)) * (joinSignLeftExtra h \u03c6suc\u039b) := by\n  rw [singleton_sign_expand]\n  rw [join_singleton_left_signFinset_eq_filter h \u03c6suc\u039b]\n  rw [map_mul]\n  rfl\n\n", "theoremStatement": "lemma join_singleton_sign_right {\u03c6s : List \ud835\udcd5.FieldOp}\n    {i j : Fin \u03c6s.length} (h : i < j)\n    (\u03c6suc\u039b : WickContraction [singleton h]\u1d58\u1d9c.length) :\n    \u03c6suc\u039b.sign =\n    (joinSignRightExtra h \u03c6suc\u039b) *\n    (\u220f a, \ud835\udce2(\ud835\udcd5|>\u209b [singleton h]\u1d58\u1d9c[\u03c6suc\u039b.sndFieldOfContract a], \ud835\udcd5|>\u209b \u27e8\u03c6s.get,\n      ((join (singleton h) \u03c6suc\u039b).signFinset (uncontractedListEmd (\u03c6suc\u039b.fstFieldOfContract a))\n        (uncontractedListEmd (\u03c6suc\u039b.sndFieldOfContract a)))\u27e9)) ", "theoremName": "WickContraction.join_singleton_sign_right", "fileCreated": {"commit": "ff4a56226cdb330ba2e2fb86afe224b906b97b64", "date": "2025-02-03"}, "theoremCreated": {"commit": "12d36dc1d9c726c035301091e57be0b29015e4ae", "date": "2025-01-31"}, "file": "HepLean/HepLean/PerturbationTheory/WickContraction/Sign/Join.lean", "module": "HepLean.PerturbationTheory.WickContraction.Sign.Join", "jsonFile": "HepLean.PerturbationTheory.WickContraction.Sign.Join.jsonl", "positionMetadata": {"lineInFile": 197, "tokenPositionInFile": 7949, "theoremPositionInFile": 8}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 19, "numPremises": 81}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [sign_right_eq_prod_mul_prod]\n  rfl", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 46}}
{"srcContext": "/-\nCopyright (c) 2024 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport Mathlib.Algebra.FreeAlgebra\nimport Mathlib.Algebra.Lie.OfAssociative\nimport Mathlib.Analysis.Complex.Basic\nimport HepLean.Mathematics.List.InsertIdx\n/-!\n\n# Field statistics\n\nBasic properties related to whether a field, or list of fields, is bosonic or fermionic.\n\n-/\n\n/-- The type `FieldStatistic` is the type containing two elements `bosonic` and `fermionic`.\n  This type is used to specify if a field or operator obeys bosonic or fermionic statistics. -/\ninductive FieldStatistic : Type where\n  | bosonic : FieldStatistic\n  | fermionic : FieldStatistic\nderiving DecidableEq\n\nnamespace FieldStatistic\n\nvariable {\ud835\udcd5 : Type}\n\n/-- The type `FieldStatistic` carries an instance of a commutative group in which\n- `bosonic * bosonic = bosonic`\n- `bosonic * fermionic = fermionic`\n- `fermionic * bosonic = fermionic`\n- `fermionic * fermionic = bosonic`\n\nThis group is isomorphic to `\u2124\u2082`. -/\n@[simp]\ninstance : CommGroup FieldStatistic where\n  one := bosonic\n  mul a b :=\n    match a, b with\n    | bosonic, bosonic => bosonic\n    | bosonic, fermionic => fermionic\n    | fermionic, bosonic => fermionic\n    | fermionic, fermionic => bosonic\n  inv a := a\n  mul_assoc a b c := by\n    cases a <;> cases b <;> cases c <;>\n    dsimp [HMul.hMul]\n  one_mul a := by\n    cases a <;> dsimp [HMul.hMul]\n  mul_one a := by\n    cases a <;> dsimp [HMul.hMul]\n  inv_mul_cancel a := by\n    cases a <;> dsimp only [HMul.hMul, Nat.succ_eq_add_one] <;> rfl\n  mul_comm a b := by\n    cases a <;> cases b <;> rfl\n\n@[simp]\nlemma bosonic_mul_bosonic : bosonic * bosonic = bosonic := rfl\n\n@[simp]\nlemma bosonic_mul_fermionic : bosonic * fermionic = fermionic := rfl\n\n@[simp]\nlemma fermionic_mul_bosonic : fermionic * bosonic = fermionic := rfl\n\n@[simp]\nlemma fermionic_mul_fermionic : fermionic * fermionic = bosonic := rfl\n\n@[simp]\nlemma mul_bosonic (a : FieldStatistic) : a * bosonic = a := by\n  cases a <;> rfl\n\n@[simp]\nlemma mul_self (a : FieldStatistic) : a * a = 1 := by\n  cases a <;> rfl\n\n/-- Field statics form a finite type. -/\ninstance : Fintype FieldStatistic where\n  elems := {bosonic, fermionic}\n  complete := by\n    intro c\n    cases c\n    \u00b7 exact Finset.mem_insert_self bosonic {fermionic}\n    \u00b7 refine Finset.insert_eq_self.mp ?_\n      exact rfl\n\n@[simp]\nlemma fermionic_not_eq_bonsic : \u00ac fermionic = bosonic := by\n  intro h\n  exact FieldStatistic.noConfusion h\n\nlemma bonsic_eq_fermionic_false : bosonic = fermionic \u2194 false := by\n  simp only [reduceCtorEq, Bool.false_eq_true]\n\n@[simp]\nlemma neq_fermionic_iff_eq_bosonic (a : FieldStatistic) : \u00ac a = fermionic \u2194 a = bosonic := by\n  fin_cases a\n  \u00b7 simp\n  \u00b7 simp\n\n@[simp]\nlemma neq_bosonic_iff_eq_fermionic (a : FieldStatistic) : \u00ac a = bosonic \u2194 a = fermionic := by\n  fin_cases a\n  \u00b7 simp\n  \u00b7 simp\n\n@[simp]\nlemma bosonic_neq_iff_fermionic_eq (a : FieldStatistic) : \u00ac bosonic = a \u2194 fermionic = a := by\n  fin_cases a\n  \u00b7 simp\n  \u00b7 simp\n\n@[simp]\nlemma fermionic_neq_iff_bosonic_eq (a : FieldStatistic) : \u00ac fermionic = a \u2194 bosonic = a := by\n  fin_cases a\n  \u00b7 simp\n  \u00b7 simp\n\nlemma eq_self_if_eq_bosonic {a : FieldStatistic} :\n    (if a = bosonic then bosonic else fermionic) = a := by\n  fin_cases a <;> rfl\n\nlemma eq_self_if_bosonic_eq {a : FieldStatistic} :\n    (if bosonic = a then bosonic else fermionic) = a := by\n  fin_cases a <;> rfl\n\nlemma mul_eq_one_iff (a b : FieldStatistic) : a * b = 1 \u2194 a = b := by\n  fin_cases a <;> fin_cases b <;> simp\n\nlemma one_eq_mul_iff (a b : FieldStatistic) : 1 = a * b \u2194 a = b := by\n  fin_cases a <;> fin_cases b <;> simp\n\nlemma mul_eq_iff_eq_mul (a b c : FieldStatistic) : a * b = c \u2194 a = b * c := by\n  fin_cases a <;> fin_cases b <;> fin_cases c <;>\n    simp only [bosonic_mul_fermionic, fermionic_not_eq_bonsic, mul_self,\n      reduceCtorEq, fermionic_mul_bosonic, true_iff, iff_true]\n  all_goals rfl\n\nlemma mul_eq_iff_eq_mul' (a b c : FieldStatistic) : a * b = c \u2194 b = a * c := by\n  fin_cases a <;> fin_cases b <;> fin_cases c <;>\n    simp only [bosonic_mul_fermionic, fermionic_not_eq_bonsic, mul_self,\n      reduceCtorEq, fermionic_mul_bosonic, true_iff, iff_true]\n  all_goals rfl\n\n/-- The field statistics of a list of fields is fermionic if there is an odd number of fermions,\n  otherwise it is bosonic. -/\ndef ofList (s : \ud835\udcd5 \u2192 FieldStatistic) : (\u03c6s : List \ud835\udcd5) \u2192 FieldStatistic\n  | [] => bosonic\n  | \u03c6 :: \u03c6s => if s \u03c6 = ofList s \u03c6s then bosonic else fermionic\n\nlemma ofList_cons_eq_mul (s : \ud835\udcd5 \u2192 FieldStatistic) (\u03c6 : \ud835\udcd5) (\u03c6s : List \ud835\udcd5) :\n    ofList s (\u03c6 :: \u03c6s) = s \u03c6 * ofList s \u03c6s := by\n  have ha (a b : FieldStatistic) : (if a = b then bosonic else fermionic) = a * b := by\n    fin_cases a <;> fin_cases b <;> rfl\n  exact ha (s \u03c6) (ofList s \u03c6s)\n\nlemma ofList_eq_prod (s : \ud835\udcd5 \u2192 FieldStatistic) : (\u03c6s : List \ud835\udcd5) \u2192\n    ofList s \u03c6s = (List.map s \u03c6s).prod\n  | [] => rfl\n  | \u03c6 :: \u03c6s => by\n    rw [ofList_cons_eq_mul, List.map_cons, List.prod_cons, ofList_eq_prod]\n\n@[simp]\nlemma ofList_singleton (s : \ud835\udcd5 \u2192 FieldStatistic) (\u03c6 : \ud835\udcd5) : ofList s [\u03c6] = s \u03c6 := by\n  simp only [ofList, Fin.isValue]\n  rw [eq_self_if_eq_bosonic]\n\n", "theoremStatement": "@[simp]\nlemma ofList_freeMonoid (s : \ud835\udcd5 \u2192 FieldStatistic) (\u03c6 : \ud835\udcd5) : ofList s (FreeMonoid.of \u03c6) = s \u03c6 ", "theoremName": "FieldStatistic.ofList_freeMonoid", "fileCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "theoremCreated": {"commit": "83f5fc5e9cd0d22073c4d86838a04ed84144105d", "date": "2024-12-20"}, "file": "HepLean/HepLean/PerturbationTheory/FieldStatistics/Basic.lean", "module": "HepLean.PerturbationTheory.FieldStatistics.Basic", "jsonFile": "HepLean.PerturbationTheory.FieldStatistics.Basic.jsonl", "positionMetadata": {"lineInFile": 169, "tokenPositionInFile": 5148, "theoremPositionInFile": 20}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 3, "numPremises": 5}, "proofMetadata": {"hasProof": true, "proof": ":=\n  ofList_singleton s \u03c6", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 25}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.WickContraction.ExtractEquiv\n/-!\n\n# List of uncontracted elements of a Wick contraction\n\n-/\n\nopen FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\nnamespace WickContraction\nvariable {n : \u2115} (c : WickContraction n)\nopen HepLean.List\nopen HepLean.Fin\n\n/-!\n\n## Some properties of lists of fin\n\n-/\n\nlemma fin_list_sorted_monotone_sorted {n m : \u2115} (l: List (Fin n)) (hl : l.Sorted (\u00b7 \u2264 \u00b7))\n    (f : Fin n \u2192 Fin m) (hf : StrictMono f) : ((List.map f l)).Sorted (\u00b7 \u2264 \u00b7) := by\n  induction l with\n  | nil => simp\n  | cons a l ih =>\n    simp only [List.map_cons, List.sorted_cons, List.mem_map, forall_exists_index, and_imp,\n      forall_apply_eq_imp_iff\u2082]\n    apply And.intro\n    \u00b7 simp only [List.sorted_cons] at hl\n      intro b hb\n      have hl1 := hl.1 b hb\n      exact (StrictMono.le_iff_le hf).mpr hl1\n    \u00b7 simp only [List.sorted_cons] at hl\n      exact ih hl.2\n\nlemma fin_list_sorted_succAboveEmb_sorted (l: List (Fin n)) (hl : l.Sorted (\u00b7 \u2264 \u00b7))\n    (i : Fin n.succ) : ((List.map i.succAboveEmb l)).Sorted (\u00b7 \u2264 \u00b7) := by\n  apply fin_list_sorted_monotone_sorted\n  exact hl\n  simp only [Fin.coe_succAboveEmb]\n  exact Fin.strictMono_succAbove i\n\nlemma fin_finset_sort_map_monotone {n m : \u2115} (a : Finset (Fin n)) (f : Fin n \u21aa Fin m)\n    (hf : StrictMono f) : (Finset.sort (\u00b7 \u2264 \u00b7) a).map f =\n    (Finset.sort (\u00b7 \u2264 \u00b7) (a.map f)) := by\n  have h1 : ((Finset.sort (\u00b7 \u2264 \u00b7) a).map f).Sorted (\u00b7 \u2264 \u00b7) := by\n    apply fin_list_sorted_monotone_sorted\n    exact Finset.sort_sorted (fun x1 x2 => x1 \u2264 x2) a\n    exact hf\n  have h2 : ((Finset.sort (\u00b7 \u2264 \u00b7) a).map f).Nodup := by\n    refine (List.nodup_map_iff_inj_on ?_).mpr ?_\n    exact Finset.sort_nodup (fun x1 x2 => x1 \u2264 x2) a\n    intro a ha b hb hf\n    exact f.2 hf\n  have h3 : ((Finset.sort (\u00b7 \u2264 \u00b7) a).map f).toFinset = (a.map f) := by\n    ext a\n    simp\n  rw [\u2190 h3]\n  exact ((List.toFinset_sort (\u00b7 \u2264 \u00b7) h2).mpr h1).symm\n\nlemma fin_list_sorted_split :\n    (l : List (Fin n)) \u2192 (hl : l.Sorted (\u00b7 \u2264 \u00b7)) \u2192 (i : \u2115) \u2192\n    l = l.filter (fun x => x.1 < i) ++ l.filter (fun x => i \u2264 x.1)\n  | [], _, _ => by simp\n  | a :: l, hl, i => by\n    simp only [List.sorted_cons] at hl\n    by_cases ha : a < i\n    \u00b7 conv_lhs => rw [fin_list_sorted_split l hl.2 i]\n      rw [\u2190 List.cons_append]\n      rw [List.filter_cons_of_pos, List.filter_cons_of_neg]\n      simp only [decide_eq_true_eq, not_le, ha]\n      simp [ha]\n    \u00b7 have hx : List.filter (fun x => decide (x.1 < i)) (a :: l) = [] := by\n        simp only [ha, decide_false, Bool.false_eq_true, not_false_eq_true, List.filter_cons_of_neg,\n          List.filter_eq_nil_iff, decide_eq_true_eq, not_lt]\n        intro b hb\n        have hb' := hl.1 b hb\n        omega\n      simp only [hx, List.nil_append]\n      rw [List.filter_cons_of_pos]\n      simp only [List.cons.injEq, true_and]\n      have hl' := fin_list_sorted_split l hl.2 i\n      have hx : List.filter (fun x => decide (x.1 < i)) (l) = [] := by\n        simp only [List.filter_eq_nil_iff, decide_eq_true_eq, not_lt]\n        intro b hb\n        have hb' := hl.1 b hb\n        omega\n      simp only [hx, List.nil_append] at hl'\n      conv_lhs => rw [hl']\n      simp only [decide_eq_true_eq]\n      omega\n\nlemma fin_list_sorted_indexOf_filter_le_mem :\n    (l : List (Fin n)) \u2192 (hl : l.Sorted (\u00b7 \u2264 \u00b7)) \u2192 (i : Fin n) \u2192\n    (hl : i \u2208 l) \u2192\n    List.indexOf i (List.filter (fun x => decide (\u2191i \u2264 \u2191x)) l) = 0\n  | [], _, _, _ => by simp\n  | a :: l, hl, i, hi => by\n    simp only [List.sorted_cons] at hl\n    by_cases ha : i \u2264 a\n    \u00b7 simp only [ha, decide_true, List.filter_cons_of_pos]\n      have ha : a = i := by\n        simp only [List.mem_cons] at hi\n        rcases hi with hi | hi\n        \u00b7 subst hi\n          rfl\n        \u00b7 have hl' := hl.1 i hi\n          exact Fin.le_antisymm hl' ha\n      subst ha\n      simp\n    \u00b7 simp only [not_le] at ha\n      rw [List.filter_cons_of_neg (by simpa using ha)]\n      rw [fin_list_sorted_indexOf_filter_le_mem l hl.2]\n      simp only [List.mem_cons] at hi\n      rcases hi with hi | hi\n      \u00b7 omega\n      \u00b7 exact hi\n\n", "theoremStatement": "lemma fin_list_sorted_indexOf_mem :\n    (l : List (Fin n)) \u2192 (hl : l.Sorted (\u00b7 \u2264 \u00b7)) \u2192 (i : Fin n) \u2192\n    (hi : i \u2208 l) \u2192\n    l.indexOf i = (l.filter (fun x => x.1 < i.1)).length ", "theoremName": "WickContraction.fin_list_sorted_indexOf_mem", "fileCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "theoremCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "file": "HepLean/HepLean/PerturbationTheory/WickContraction/UncontractedList.lean", "module": "HepLean.PerturbationTheory.WickContraction.UncontractedList", "jsonFile": "HepLean.PerturbationTheory.WickContraction.UncontractedList.jsonl", "positionMetadata": {"lineInFile": 125, "tokenPositionInFile": 4170, "theoremPositionInFile": 3}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 72}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  intro l hl i hi\n  conv_lhs => rw [fin_list_sorted_split l hl i]\n  rw [List.indexOf_append_of_not_mem]\n  erw [fin_list_sorted_indexOf_filter_le_mem l hl i hi]\n  \u00b7 simp\n  \u00b7 simp", "proofType": "tactic", "proofLengthLines": 6, "proofLengthTokens": 183}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldSpecification.TimeOrder\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.SuperCommute\nimport HepLean.PerturbationTheory.Koszul.KoszulSign\n/-!\n\n# Time Ordering in the FieldOpFreeAlgebra\n\n-/\n\nnamespace FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\nopen FieldStatistic\n\nnamespace FieldOpFreeAlgebra\n\nnoncomputable section\nopen HepLean.List\n/-!\n\n## Time order\n\n-/\n\n/-- For a field specification `\ud835\udcd5`, `timeOrderF` is the linear map\n\n  `FieldOpFreeAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpFreeAlgebra \ud835\udcd5`\n\n  defined by its action on the basis `ofCrAnListF \u03c6s`, taking\n  `ofCrAnListF \u03c6s` to\n\n  `crAnTimeOrderSign \u03c6s \u2022 ofCrAnListF (crAnTimeOrderList \u03c6s)`.\n\n  That is, `timeOrderF` time-orders the field operators and multiplies by the sign of the\n  time order.\n\n  The notation `\ud835\udce3\u1da0(a)` is used for `timeOrderF a` -/\ndef timeOrderF : FieldOpFreeAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpFreeAlgebra \ud835\udcd5 :=\n  Basis.constr ofCrAnListFBasis \u2102 fun \u03c6s =>\n  crAnTimeOrderSign \u03c6s \u2022 ofCrAnListF (crAnTimeOrderList \u03c6s)\n\n@[inherit_doc timeOrderF]\nscoped[FieldSpecification.FieldOpFreeAlgebra] notation \"\ud835\udce3\u1da0(\" a \")\" => timeOrderF a\n\nlemma timeOrderF_ofCrAnListF (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    \ud835\udce3\u1da0(ofCrAnListF \u03c6s) = crAnTimeOrderSign \u03c6s \u2022 ofCrAnListF (crAnTimeOrderList \u03c6s) := by\n  rw [\u2190 ofListBasis_eq_ofList]\n  simp only [timeOrderF, Basis.constr_basis]\n\nlemma timeOrderF_timeOrderF_mid (a b c : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \ud835\udce3\u1da0(a * b * c) = \ud835\udce3\u1da0(a * \ud835\udce3\u1da0(b) * c) := by\n  let pc (c : \ud835\udcd5.FieldOpFreeAlgebra) (hc : c \u2208 Submodule.span \u2102 (Set.range ofCrAnListFBasis)) :\n    Prop := \ud835\udce3\u1da0(a * b * c) = \ud835\udce3\u1da0(a * \ud835\udce3\u1da0(b) * c)\n  change pc c (Basis.mem_span _ c)\n  apply Submodule.span_induction\n  \u00b7 intro x hx\n    obtain \u27e8\u03c6s, rfl\u27e9 := hx\n    simp only [ofListBasis_eq_ofList, pc]\n    let pb (b : \ud835\udcd5.FieldOpFreeAlgebra) (hb : b \u2208 Submodule.span \u2102 (Set.range ofCrAnListFBasis)) :\n      Prop := \ud835\udce3\u1da0(a * b * ofCrAnListF \u03c6s) = \ud835\udce3\u1da0(a * \ud835\udce3\u1da0(b) * ofCrAnListF \u03c6s)\n    change pb b (Basis.mem_span _ b)\n    apply Submodule.span_induction\n    \u00b7 intro x hx\n      obtain \u27e8\u03c6s', rfl\u27e9 := hx\n      simp only [ofListBasis_eq_ofList, pb]\n      let pa (a : \ud835\udcd5.FieldOpFreeAlgebra) (ha : a \u2208 Submodule.span \u2102 (Set.range ofCrAnListFBasis)) :\n        Prop := \ud835\udce3\u1da0(a * ofCrAnListF \u03c6s' * ofCrAnListF \u03c6s) =\n          \ud835\udce3\u1da0(a * \ud835\udce3\u1da0(ofCrAnListF \u03c6s') * ofCrAnListF \u03c6s)\n      change pa a (Basis.mem_span _ a)\n      apply Submodule.span_induction\n      \u00b7 intro x hx\n        obtain \u27e8\u03c6s'', rfl\u27e9 := hx\n        simp only [ofListBasis_eq_ofList, pa]\n        rw [timeOrderF_ofCrAnListF]\n        simp only [\u2190 ofCrAnListF_append, Algebra.mul_smul_comm,\n          Algebra.smul_mul_assoc, map_smul]\n        rw [timeOrderF_ofCrAnListF, timeOrderF_ofCrAnListF, smul_smul]\n        congr 1\n        \u00b7 simp only [crAnTimeOrderSign, crAnTimeOrderList]\n          rw [Wick.koszulSign_of_append_eq_insertionSort, mul_comm]\n        \u00b7 congr 1\n          simp only [crAnTimeOrderList]\n          rw [insertionSort_append_insertionSort_append]\n      \u00b7 simp [pa]\n      \u00b7 intro x y hx hy h1 h2\n        simp_all [pa, add_mul]\n      \u00b7 intro x hx h\n        simp_all [pa]\n    \u00b7 simp [pb]\n    \u00b7 intro x y hx hy h1 h2\n      simp_all [pb, mul_add, add_mul]\n    \u00b7 intro x hx h\n      simp_all [pb]\n  \u00b7 simp [pc]\n  \u00b7 intro x y hx hy h1 h2\n    simp_all [pc, mul_add]\n  \u00b7 intro x hx h hp\n    simp_all [pc]\n\nlemma timeOrderF_timeOrderF_right (a b : \ud835\udcd5.FieldOpFreeAlgebra) : \ud835\udce3\u1da0(a * b) = \ud835\udce3\u1da0(a * \ud835\udce3\u1da0(b)) := by\n  trans \ud835\udce3\u1da0(a * b * 1)\n  \u00b7 simp\n  \u00b7 rw [timeOrderF_timeOrderF_mid]\n    simp\n\n", "theoremStatement": "lemma timeOrderF_timeOrderF_left (a b : \ud835\udcd5.FieldOpFreeAlgebra) : \ud835\udce3\u1da0(a * b) = \ud835\udce3\u1da0(\ud835\udce3\u1da0(a) * b) ", "theoremName": "FieldSpecification.FieldOpFreeAlgebra.timeOrderF_timeOrderF_left", "fileCreated": {"commit": "ea6e12829370d9630a7e65200c8349e9086c05ba", "date": "2025-02-03"}, "theoremCreated": {"commit": "c53299d40a1b625549e794ce81600fd7232d737b", "date": "2025-01-30"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpFreeAlgebra/TimeOrder.lean", "module": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.TimeOrder", "jsonFile": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.TimeOrder.jsonl", "positionMetadata": {"lineInFile": 110, "tokenPositionInFile": 3624, "theoremPositionInFile": 5}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 5, "numPremises": 44}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  trans \ud835\udce3\u1da0(1 * a * b)\n  \u00b7 simp\n  \u00b7 rw [timeOrderF_timeOrderF_mid]\n    simp", "proofType": "tactic", "proofLengthLines": 4, "proofLengthTokens": 80}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.WickContraction.UncontractedList\n/-!\n\n# Inserting an element into a contraction based on a list\n\n-/\n\nopen FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\nnamespace WickContraction\nvariable {n : \u2115} (c : WickContraction n)\nopen HepLean.List\nopen HepLean.Fin\n\n/-!\n\n## Inserting an element into a list\n\n-/\n\n/-- Given a Wick contraction `\u03c6s\u039b` for a list `\u03c6s` of `\ud835\udcd5.FieldOp`,\n  an element `\u03c6` of `\ud835\udcd5.FieldOp`, an `i \u2264 \u03c6s.length` and a `j` which is either `none` or\n  some element of `\u03c6s\u039b.uncontracted`, the new Wick contraction\n  `\u03c6s\u039b.insertAndContract \u03c6 i j` is defined by inserting `\u03c6` into `\u03c6s` after\n  the first `i`-elements and moving the values representing the contracted pairs in `\u03c6s\u039b`\n  accordingly.\n  If `j` is not `none`, but rather `some j`, to this contraction is added the contraction\n  of `\u03c6` (at position `i`) with the new position of `j` after `\u03c6` is added.\n\n  In other words, `\u03c6s\u039b.insertAndContract \u03c6 i j` is formed by adding `\u03c6` to `\u03c6s` at position `i`,\n  and contracting `\u03c6` with the field originally at position `j` if `j` is not none.\n  It is a Wick contraction of `\u03c6s.insertIdx \u03c6 i`, the list `\u03c6s` with `\u03c6` inserted at\n  position `i`.\n\n  The notation `\u03c6s\u039b \u21a9\u039b \u03c6 i j` is used to denote `\u03c6s\u039b.insertAndContract \u03c6 i j`. -/\ndef insertAndContract {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (i : Fin \u03c6s.length.succ) (j : Option \u03c6s\u039b.uncontracted) :\n    WickContraction (\u03c6s.insertIdx i \u03c6).length :=\n  congr (by simp) (\u03c6s\u039b.insertAndContractNat i j)\n\n@[inherit_doc insertAndContract]\nscoped[WickContraction] notation \u03c6s \"\u21a9\u039b\" \u03c6:max i:max j => insertAndContract \u03c6 \u03c6s i j\n\n@[simp]\nlemma insertAndContract_fstFieldOfContract (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp)\n    (\u03c6s\u039b : WickContraction \u03c6s.length) (i : Fin \u03c6s.length.succ) (j : Option \u03c6s\u039b.uncontracted)\n    (a : \u03c6s\u039b.1) : (\u03c6s\u039b \u21a9\u039b \u03c6 i j).fstFieldOfContract\n    (congrLift (insertIdx_length_fin \u03c6 \u03c6s i).symm (insertLift i j a)) =\n    finCongr (insertIdx_length_fin \u03c6 \u03c6s i).symm (i.succAbove (\u03c6s\u039b.fstFieldOfContract a)) := by\n  simp [insertAndContract]\n\n@[simp]\nlemma insertAndContract_sndFieldOfContract (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp)\n    (\u03c6s\u039b : WickContraction \u03c6s.length) (i : Fin \u03c6s.length.succ) (j : Option (\u03c6s\u039b.uncontracted))\n    (a : \u03c6s\u039b.1) : (\u03c6s\u039b \u21a9\u039b \u03c6 i j).sndFieldOfContract\n    (congrLift (insertIdx_length_fin \u03c6 \u03c6s i).symm (insertLift i j a)) =\n    finCongr (insertIdx_length_fin \u03c6 \u03c6s i).symm (i.succAbove (\u03c6s\u039b.sndFieldOfContract a)) := by\n  simp [insertAndContract]\n\n@[simp]\nlemma insertAndContract_fstFieldOfContract_some_incl (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp)\n    (\u03c6s\u039b : WickContraction \u03c6s.length) (i : Fin \u03c6s.length.succ) (j : \u03c6s\u039b.uncontracted) :\n      (insertAndContract \u03c6 \u03c6s\u039b i (some j)).fstFieldOfContract\n      (congrLift (insertIdx_length_fin \u03c6 \u03c6s i).symm \u27e8{i, i.succAbove j}, by\n        simp [insertAndContractNat]\u27e9) =\n      if i < i.succAbove j.1 then\n      finCongr (insertIdx_length_fin \u03c6 \u03c6s i).symm i else\n      finCongr (insertIdx_length_fin \u03c6 \u03c6s i).symm (i.succAbove j.1) := by\n  split\n  \u00b7 rename_i h\n    refine (insertAndContract \u03c6 \u03c6s\u039b i (some j)).eq_fstFieldOfContract_of_mem\n      (a := congrLift (insertIdx_length_fin \u03c6 \u03c6s i).symm \u27e8{i, i.succAbove j}, by\n        simp [insertAndContractNat]\u27e9)\n      (i := finCongr (insertIdx_length_fin \u03c6 \u03c6s i).symm i) (j :=\n        finCongr (insertIdx_length_fin \u03c6 \u03c6s i).symm (i.succAbove j)) ?_ ?_ ?_\n    \u00b7 simp [congrLift]\n    \u00b7 simp [congrLift]\n    \u00b7 rw [Fin.lt_def] at h \u22a2\n      simp_all\n  \u00b7 rename_i h\n    refine (insertAndContract \u03c6 \u03c6s\u039b i (some j)).eq_fstFieldOfContract_of_mem\n      (a := congrLift (insertIdx_length_fin \u03c6 \u03c6s i).symm \u27e8{i, i.succAbove j}, by\n        simp [insertAndContractNat]\u27e9)\n      (i := finCongr (insertIdx_length_fin \u03c6 \u03c6s i).symm (i.succAbove j))\n      (j := finCongr (insertIdx_length_fin \u03c6 \u03c6s i).symm i) ?_ ?_ ?_\n    \u00b7 simp [congrLift]\n    \u00b7 simp [congrLift]\n    \u00b7 rw [Fin.lt_def] at h \u22a2\n      simp_all only [Nat.succ_eq_add_one, Fin.val_fin_lt, not_lt, finCongr_apply, Fin.coe_cast]\n      have hi : i.succAbove j \u2260 i := Fin.succAbove_ne i j\n      omega\n\n/-!\n\n## insertAndContract and getDual?\n\n-/\n\n@[simp]\nlemma insertAndContract_none_getDual?_self (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp)\n    (\u03c6s\u039b : WickContraction \u03c6s.length) (i : Fin \u03c6s.length.succ) :\n    (\u03c6s\u039b \u21a9\u039b \u03c6 i none).getDual? (Fin.cast (insertIdx_length_fin \u03c6 \u03c6s i).symm i) = none := by\n  simp only [Nat.succ_eq_add_one, insertAndContract, getDual?_congr, finCongr_apply, Fin.cast_trans,\n    Fin.cast_eq_self, Option.map_eq_none']\n  simp\n\n", "theoremStatement": "lemma insertAndContract_isSome_getDual?_self (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp)\n    (\u03c6s\u039b : WickContraction \u03c6s.length) (i : Fin \u03c6s.length.succ) (j : \u03c6s\u039b.uncontracted) :\n    ((\u03c6s\u039b \u21a9\u039b \u03c6 i (some j)).getDual?\n    (Fin.cast (insertIdx_length_fin \u03c6 \u03c6s i).symm i)).isSome ", "theoremName": "WickContraction.insertAndContract_isSome_getDual?_self", "fileCreated": {"commit": "fa7536bea9b5acc23e09f201a7765792caebb199", "date": "2025-01-24"}, "theoremCreated": {"commit": "fa7536bea9b5acc23e09f201a7765792caebb199", "date": "2025-01-24"}, "file": "HepLean/HepLean/PerturbationTheory/WickContraction/InsertAndContract.lean", "module": "HepLean.PerturbationTheory.WickContraction.InsertAndContract", "jsonFile": "HepLean.PerturbationTheory.WickContraction.InsertAndContract.jsonl", "positionMetadata": {"lineInFile": 113, "tokenPositionInFile": 4687, "theoremPositionInFile": 6}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 11, "numPremises": 48}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp [insertAndContract, getDual?_congr]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 48}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.NormalOrder\nimport HepLean.PerturbationTheory.FieldOpAlgebra.SuperCommute\n/-!\n\n# Normal Ordering on Field operator algebra\n\n-/\n\nnamespace FieldSpecification\nopen FieldOpFreeAlgebra\nopen HepLean.List\nopen FieldStatistic\n\nnamespace FieldOpAlgebra\nvariable {\ud835\udcd5 : FieldSpecification}\n\n/-!\n\n## Normal order on super-commutators.\n\nThe main result of this is\n`\u03b9_normalOrderF_superCommuteF_eq_zero_mul`\nwhich states that applying `\u03b9` to the normal order of something containing a super-commutator\nis zero.\n\n-/\n\nlemma \u03b9_normalOrderF_superCommuteF_ofCrAnListF_ofCrAnListF_eq_zero\n    (\u03c6a \u03c6a' : \ud835\udcd5.CrAnFieldOp) (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    \u03b9 \ud835\udcdd\u1da0(ofCrAnListF \u03c6s * [ofCrAnOpF \u03c6a, ofCrAnOpF \u03c6a']\u209bca * ofCrAnListF \u03c6s') = 0 := by\n  rcases CreateAnnihilate.eq_create_or_annihilate (\ud835\udcd5 |>\u1d9c \u03c6a) with h\u03c6a | h\u03c6a\n  <;> rcases CreateAnnihilate.eq_create_or_annihilate (\ud835\udcd5 |>\u1d9c \u03c6a') with h\u03c6a' | h\u03c6a'\n  \u00b7 rw [normalOrderF_superCommuteF_ofCrAnListF_create_create_ofCrAnListF \u03c6a \u03c6a' h\u03c6a h\u03c6a' \u03c6s \u03c6s']\n    rw [map_smul, map_mul, map_mul, map_mul, \u03b9_superCommuteF_of_create_create \u03c6a \u03c6a' h\u03c6a h\u03c6a']\n    simp\n  \u00b7 rw [normalOrderF_superCommuteF_create_annihilate \u03c6a \u03c6a' h\u03c6a h\u03c6a' (ofCrAnListF \u03c6s)\n      (ofCrAnListF \u03c6s')]\n    simp\n  \u00b7 rw [normalOrderF_superCommuteF_annihilate_create \u03c6a' \u03c6a h\u03c6a' h\u03c6a (ofCrAnListF \u03c6s)\n      (ofCrAnListF \u03c6s')]\n    simp\n  \u00b7 rw [normalOrderF_superCommuteF_ofCrAnListF_annihilate_annihilate_ofCrAnListF\n      \u03c6a \u03c6a' h\u03c6a h\u03c6a' \u03c6s \u03c6s']\n    rw [map_smul, map_mul, map_mul, map_mul,\n      \u03b9_superCommuteF_of_annihilate_annihilate \u03c6a \u03c6a' h\u03c6a h\u03c6a']\n    simp\n\nlemma \u03b9_normalOrderF_superCommuteF_ofCrAnListF_eq_zero\n    (\u03c6a \u03c6a' : \ud835\udcd5.CrAnFieldOp) (\u03c6s : List \ud835\udcd5.CrAnFieldOp)\n    (a : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \u03b9 \ud835\udcdd\u1da0(ofCrAnListF \u03c6s * [ofCrAnOpF \u03c6a, ofCrAnOpF \u03c6a']\u209bca * a) = 0 := by\n  have hf : \u03b9.toLinearMap \u2218\u2097 normalOrderF \u2218\u2097\n      mulLinearMap (ofCrAnListF \u03c6s * [ofCrAnOpF \u03c6a, ofCrAnOpF \u03c6a']\u209bca) = 0 := by\n    apply ofCrAnListFBasis.ext\n    intro l\n    simp only [FieldOpFreeAlgebra.ofListBasis_eq_ofList, LinearMap.coe_comp, Function.comp_apply,\n      AlgHom.toLinearMap_apply, LinearMap.zero_apply]\n    exact \u03b9_normalOrderF_superCommuteF_ofCrAnListF_ofCrAnListF_eq_zero \u03c6a \u03c6a' \u03c6s l\n  change (\u03b9.toLinearMap \u2218\u2097 normalOrderF \u2218\u2097\n    mulLinearMap ((ofCrAnListF \u03c6s * [ofCrAnOpF \u03c6a, ofCrAnOpF \u03c6a']\u209bca))) a = 0\n  rw [hf]\n  simp\n\nlemma \u03b9_normalOrderF_superCommuteF_ofCrAnOpF_eq_zero_mul (\u03c6a \u03c6a' : \ud835\udcd5.CrAnFieldOp)\n    (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \u03b9 \ud835\udcdd\u1da0(a * [ofCrAnOpF \u03c6a, ofCrAnOpF \u03c6a']\u209bca * b) = 0 := by\n  rw [mul_assoc]\n  change (\u03b9.toLinearMap \u2218\u2097 normalOrderF \u2218\u2097 mulLinearMap.flip\n    ([ofCrAnOpF \u03c6a, ofCrAnOpF \u03c6a']\u209bca * b)) a = 0\n  have hf : \u03b9.toLinearMap \u2218\u2097 normalOrderF \u2218\u2097 mulLinearMap.flip\n      ([ofCrAnOpF \u03c6a, ofCrAnOpF \u03c6a']\u209bca * b) = 0 := by\n    apply ofCrAnListFBasis.ext\n    intro l\n    simp only [mulLinearMap, FieldOpFreeAlgebra.ofListBasis_eq_ofList, LinearMap.coe_comp,\n      Function.comp_apply, LinearMap.flip_apply, LinearMap.coe_mk, AddHom.coe_mk,\n      AlgHom.toLinearMap_apply, LinearMap.zero_apply]\n    rw [\u2190 mul_assoc]\n    exact \u03b9_normalOrderF_superCommuteF_ofCrAnListF_eq_zero \u03c6a \u03c6a' _ _\n  rw [hf]\n  simp\n\nlemma \u03b9_normalOrderF_superCommuteF_ofCrAnOpF_ofCrAnListF_eq_zero_mul (\u03c6a : \ud835\udcd5.CrAnFieldOp)\n    (\u03c6s : List \ud835\udcd5.CrAnFieldOp) (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \u03b9 \ud835\udcdd\u1da0(a * [ofCrAnOpF \u03c6a, ofCrAnListF \u03c6s]\u209bca * b) = 0 := by\n  rw [\u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF_eq_sum]\n  rw [Finset.mul_sum, Finset.sum_mul]\n  rw [map_sum, map_sum]\n  apply Fintype.sum_eq_zero\n  intro n\n  rw [\u2190 mul_assoc, \u2190 mul_assoc]\n  rw [mul_assoc _ _ b, ofCrAnListF_singleton]\n  rw [\u03b9_normalOrderF_superCommuteF_ofCrAnOpF_eq_zero_mul]\n\nlemma \u03b9_normalOrderF_superCommuteF_ofCrAnListF_ofCrAnOpF_eq_zero_mul (\u03c6a : \ud835\udcd5.CrAnFieldOp)\n    (\u03c6s : List \ud835\udcd5.CrAnFieldOp) (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \u03b9 \ud835\udcdd\u1da0(a * [ofCrAnListF \u03c6s, ofCrAnOpF \u03c6a]\u209bca * b) = 0 := by\n  rw [\u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF_symm, ofCrAnListF_singleton]\n  simp only [FieldStatistic.instCommGroup.eq_1, FieldStatistic.ofList_singleton, mul_neg,\n    Algebra.mul_smul_comm, neg_mul, Algebra.smul_mul_assoc, map_neg, map_smul]\n  rw [\u03b9_normalOrderF_superCommuteF_ofCrAnOpF_ofCrAnListF_eq_zero_mul]\n  simp\n\nlemma \u03b9_normalOrderF_superCommuteF_ofCrAnListF_ofCrAnListF_eq_zero_mul\n    (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \u03b9 \ud835\udcdd\u1da0(a * [ofCrAnListF \u03c6s, ofCrAnListF \u03c6s']\u209bca * b) = 0 := by\n  rw [superCommuteF_ofCrAnListF_ofCrAnListF_eq_sum, Finset.mul_sum, Finset.sum_mul]\n  rw [map_sum, map_sum]\n  apply Fintype.sum_eq_zero\n  intro n\n  rw [\u2190 mul_assoc, \u2190 mul_assoc]\n  rw [mul_assoc _ _ b]\n  rw [\u03b9_normalOrderF_superCommuteF_ofCrAnListF_ofCrAnOpF_eq_zero_mul]\n\nlemma \u03b9_normalOrderF_superCommuteF_ofCrAnListF_eq_zero_mul\n    (\u03c6s : List \ud835\udcd5.CrAnFieldOp)\n    (a b c : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \u03b9 \ud835\udcdd\u1da0(a * [ofCrAnListF \u03c6s, c]\u209bca * b) = 0 := by\n  change (\u03b9.toLinearMap \u2218\u2097 normalOrderF \u2218\u2097\n    mulLinearMap.flip b \u2218\u2097 mulLinearMap a \u2218\u2097 superCommuteF (ofCrAnListF \u03c6s)) c = 0\n  have hf : (\u03b9.toLinearMap \u2218\u2097 normalOrderF \u2218\u2097\n    mulLinearMap.flip b \u2218\u2097 mulLinearMap a \u2218\u2097 superCommuteF (ofCrAnListF \u03c6s)) = 0 := by\n    apply ofCrAnListFBasis.ext\n    intro \u03c6s'\n    simp only [mulLinearMap, LinearMap.coe_mk, AddHom.coe_mk, ofListBasis_eq_ofList,\n      LinearMap.coe_comp, Function.comp_apply, LinearMap.flip_apply, AlgHom.toLinearMap_apply,\n      LinearMap.zero_apply]\n    rw [\u03b9_normalOrderF_superCommuteF_ofCrAnListF_ofCrAnListF_eq_zero_mul]\n  rw [hf]\n  simp\n\n@[simp]\nlemma \u03b9_normalOrderF_superCommuteF_eq_zero_mul\n    (a b c d : \ud835\udcd5.FieldOpFreeAlgebra) : \u03b9 \ud835\udcdd\u1da0(a * [d, c]\u209bca * b) = 0 := by\n  change (\u03b9.toLinearMap \u2218\u2097 normalOrderF \u2218\u2097\n    mulLinearMap.flip b \u2218\u2097 mulLinearMap a \u2218\u2097 superCommuteF.flip c) d = 0\n  have hf : (\u03b9.toLinearMap \u2218\u2097 normalOrderF \u2218\u2097\n    mulLinearMap.flip b \u2218\u2097 mulLinearMap a \u2218\u2097 superCommuteF.flip c) = 0 := by\n    apply ofCrAnListFBasis.ext\n    intro \u03c6s\n    simp only [mulLinearMap, LinearMap.coe_mk, AddHom.coe_mk, ofListBasis_eq_ofList,\n      LinearMap.coe_comp, Function.comp_apply, LinearMap.flip_apply, AlgHom.toLinearMap_apply,\n      LinearMap.zero_apply]\n    rw [\u03b9_normalOrderF_superCommuteF_ofCrAnListF_eq_zero_mul]\n  rw [hf]\n  simp\n\n@[simp]\nlemma \u03b9_normalOrder_superCommuteF_eq_zero_mul_right (b c d : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \u03b9 \ud835\udcdd\u1da0([d, c]\u209bca * b) = 0 := by\n  rw [\u2190 \u03b9_normalOrderF_superCommuteF_eq_zero_mul 1 b c d]\n  simp\n\n@[simp]\nlemma \u03b9_normalOrderF_superCommuteF_eq_zero_mul_left (a c d : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \u03b9 \ud835\udcdd\u1da0(a * [d, c]\u209bca) = 0 := by\n  rw [\u2190 \u03b9_normalOrderF_superCommuteF_eq_zero_mul a 1 c d]\n  simp\n\n@[simp]\nlemma \u03b9_normalOrderF_superCommuteF_eq_zero_mul_mul_right (a b1 b2 c d: \ud835\udcd5.FieldOpFreeAlgebra) :\n    \u03b9 \ud835\udcdd\u1da0(a * [d, c]\u209bca * b1 * b2) = 0 := by\n  rw [\u2190 \u03b9_normalOrderF_superCommuteF_eq_zero_mul a (b1 * b2) c d]\n  congr 2\n  noncomm_ring\n\n@[simp]\nlemma \u03b9_normalOrderF_superCommuteF_eq_zero (c d : \ud835\udcd5.FieldOpFreeAlgebra) : \u03b9 \ud835\udcdd\u1da0([d, c]\u209bca) = 0 := by\n  rw [\u2190 \u03b9_normalOrderF_superCommuteF_eq_zero_mul 1 1 c d]\n  simp\n\n/-!\n\n## Defining normal order for `FiedOpAlgebra`.\n\n-/\n\n", "theoremStatement": "lemma \u03b9_normalOrderF_zero_of_mem_ideal (a : \ud835\udcd5.FieldOpFreeAlgebra)\n    (h : a \u2208 TwoSidedIdeal.span \ud835\udcd5.fieldOpIdealSet) : \u03b9 \ud835\udcdd\u1da0(a) = 0 ", "theoremName": "FieldSpecification.FieldOpAlgebra.\u03b9_normalOrderF_zero_of_mem_ideal", "fileCreated": {"commit": "2e82f842a242717b98517656fc34b1b92f579b2e", "date": "2025-02-05"}, "theoremCreated": {"commit": "f5e7bbad5971e380f8e9aa4f340d21a1d324f1a4", "date": "2025-01-30"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpAlgebra/NormalOrder/Basic.lean", "module": "HepLean.PerturbationTheory.FieldOpAlgebra.NormalOrder.Basic", "jsonFile": "HepLean.PerturbationTheory.FieldOpAlgebra.NormalOrder.Basic.jsonl", "positionMetadata": {"lineInFile": 182, "tokenPositionInFile": 7219, "theoremPositionInFile": 12}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 16, "numPremises": 175}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [TwoSidedIdeal.mem_span_iff_mem_addSubgroup_closure] at h\n  let p {k : Set \ud835\udcd5.FieldOpFreeAlgebra} (a : FieldOpFreeAlgebra \ud835\udcd5)\n    (h : a \u2208 AddSubgroup.closure k) := \u03b9 \ud835\udcdd\u1da0(a) = 0\n  change p a h\n  apply AddSubgroup.closure_induction\n  \u00b7 intro x hx\n    obtain \u27e8a, ha, b, hb, rfl\u27e9 := Set.mem_mul.mp hx\n    obtain \u27e8a, ha, c, hc, rfl\u27e9 := ha\n    simp only [p]\n    simp only [fieldOpIdealSet, exists_prop, exists_and_left, Set.mem_setOf_eq] at hc\n    match hc with\n    | Or.inl hc =>\n      obtain \u27e8\u03c6a, \u03c6a', h\u03c6a, h\u03c6a', rfl\u27e9 := hc\n      simp [mul_sub, sub_mul, \u2190 mul_assoc]\n    | Or.inr (Or.inl hc) =>\n      obtain \u27e8\u03c6a, \u03c6a', h\u03c6a, h\u03c6a', rfl\u27e9 := hc\n      simp [mul_sub, sub_mul, \u2190 mul_assoc]\n    | Or.inr (Or.inr (Or.inl hc)) =>\n      obtain \u27e8\u03c6a, \u03c6a', h\u03c6a, h\u03c6a', rfl\u27e9 := hc\n      simp [mul_sub, sub_mul, \u2190 mul_assoc]\n    | Or.inr (Or.inr (Or.inr hc)) =>\n      obtain \u27e8\u03c6a, \u03c6a', h\u03c6a, h\u03c6a', rfl\u27e9 := hc\n      simp [mul_sub, sub_mul, \u2190 mul_assoc]\n  \u00b7 simp [p]\n  \u00b7 intro x y hx hy\n    simp only [map_add, p]\n    intro h1 h2\n    simp [h1, h2]\n  \u00b7 intro x hx\n    simp [p]", "proofType": "tactic", "proofLengthLines": 30, "proofLengthTokens": 1059}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpAlgebra.NormalOrder.Basic\n/-!\n\n# Basic properties of normal ordering\n\n-/\n\nnamespace FieldSpecification\nopen FieldOpFreeAlgebra\nopen HepLean.List\nopen FieldStatistic\n\nnamespace FieldOpAlgebra\nvariable {\ud835\udcd5 : FieldSpecification}\n\n/-!\n\n## Properties of normal ordering.\n\n-/\n\nlemma normalOrder_eq_\u03b9_normalOrderF (a : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \ud835\udcdd(\u03b9 a) = \u03b9 \ud835\udcdd\u1da0(a) := rfl\n\nlemma normalOrder_ofCrAnList (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    \ud835\udcdd(ofCrAnList \u03c6s) = normalOrderSign \u03c6s \u2022 ofCrAnList (normalOrderList \u03c6s) := by\n  rw [ofCrAnList, normalOrder_eq_\u03b9_normalOrderF, normalOrderF_ofCrAnListF]\n  rfl\n\n@[simp]\nlemma normalOrder_one_eq_one : normalOrder (\ud835\udcd5 := \ud835\udcd5) 1 = 1 := by\n  have h1 : 1 = ofCrAnList (\ud835\udcd5 := \ud835\udcd5) [] := by simp [ofCrAnList]\n  rw [h1]\n  rw [normalOrder_ofCrAnList]\n  simp\n\n@[simp]\nlemma normalOrder_ofFieldOpList_nil : normalOrder (\ud835\udcd5 := \ud835\udcd5) (ofFieldOpList []) = 1 := by\n  rw [ofFieldOpList]\n  rw [normalOrder_eq_\u03b9_normalOrderF]\n  simp only [ofFieldOpListF_nil]\n  change normalOrder (\ud835\udcd5 := \ud835\udcd5) 1 = _\n  simp\n\n@[simp]\nlemma normalOrder_ofCrAnList_nil : normalOrder (\ud835\udcd5 := \ud835\udcd5) (ofCrAnList []) = 1 := by\n  rw [normalOrder_ofCrAnList]\n  simp only [normalOrderSign_nil, normalOrderList_nil, one_smul]\n  rfl\n\nlemma ofCrAnList_eq_normalOrder (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnList (normalOrderList \u03c6s) = normalOrderSign \u03c6s \u2022 \ud835\udcdd(ofCrAnList \u03c6s) := by\n  rw [normalOrder_ofCrAnList, smul_smul, normalOrderSign, Wick.koszulSign_mul_self,\n    one_smul]\n\nlemma normalOrder_normalOrder_mid (a b c : \ud835\udcd5.FieldOpAlgebra) :\n    \ud835\udcdd(a * b * c) = \ud835\udcdd(a * \ud835\udcdd(b) * c) := by\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n  obtain \u27e8c, rfl\u27e9 := \u03b9_surjective c\n  rw [normalOrder_eq_\u03b9_normalOrderF]\n  simp only [\u2190 map_mul]\n  rw [normalOrder_eq_\u03b9_normalOrderF]\n  rw [normalOrderF_normalOrderF_mid]\n  rfl\n\nlemma normalOrder_normalOrder_left (a b : \ud835\udcd5.FieldOpAlgebra) :\n    \ud835\udcdd(a * b) = \ud835\udcdd(\ud835\udcdd(a) * b) := by\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n  rw [normalOrder_eq_\u03b9_normalOrderF]\n  simp only [\u2190 map_mul]\n  rw [normalOrder_eq_\u03b9_normalOrderF]\n  rw [normalOrderF_normalOrderF_left]\n  rfl\n\nlemma normalOrder_normalOrder_right (a b : \ud835\udcd5.FieldOpAlgebra) :\n    \ud835\udcdd(a * b) = \ud835\udcdd(a * \ud835\udcdd(b)) := by\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n  rw [normalOrder_eq_\u03b9_normalOrderF]\n  simp only [\u2190 map_mul]\n  rw [normalOrder_eq_\u03b9_normalOrderF]\n  rw [normalOrderF_normalOrderF_right]\n  rfl\n\nlemma normalOrder_normalOrder (a : \ud835\udcd5.FieldOpAlgebra) : \ud835\udcdd(\ud835\udcdd(a)) = \ud835\udcdd(a) := by\n  trans \ud835\udcdd(\ud835\udcdd(a) * 1)\n  \u00b7 simp\n  \u00b7 rw [\u2190 normalOrder_normalOrder_left]\n    simp\n\n/-!\n\n## mul anpart and crpart\n-/\n\nlemma normalOrder_mul_anPart (\u03c6 : \ud835\udcd5.FieldOp) (a : \ud835\udcd5.FieldOpAlgebra) :\n    \ud835\udcdd(a * anPart \u03c6) = \ud835\udcdd(a) * anPart \u03c6 := by\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  rw [anPart, \u2190 map_mul, normalOrder_eq_\u03b9_normalOrderF, normalOrderF_mul_anPartF]\n  rfl\n\nlemma crPart_mul_normalOrder (\u03c6 : \ud835\udcd5.FieldOp) (a : \ud835\udcd5.FieldOpAlgebra) :\n    \ud835\udcdd(crPart \u03c6 * a) = crPart \u03c6 * \ud835\udcdd(a) := by\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  rw [crPart, \u2190 map_mul, normalOrder_eq_\u03b9_normalOrderF, normalOrderF_crPartF_mul]\n  rfl\n\n/-!\n\n### Normal order and super commutes\n\n-/\n\n/-- For a field specification `\ud835\udcd5`, and `a` and `b` in `\ud835\udcd5.FieldOpAlgebra` the normal ordering\n  of the super commutator of `a` and `b` vanishes, i.e. `\ud835\udcdd([a,b]\u209b) = 0`. -/\n@[simp]\nlemma normalOrder_superCommute_eq_zero (a b : \ud835\udcd5.FieldOpAlgebra) :\n    \ud835\udcdd([a, b]\u209b) = 0 := by\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n  rw [superCommute_eq_\u03b9_superCommuteF, normalOrder_eq_\u03b9_normalOrderF]\n  simp\n\n@[simp]\nlemma normalOrder_superCommute_left_eq_zero (a b c: \ud835\udcd5.FieldOpAlgebra) :\n    \ud835\udcdd([a, b]\u209b * c) = 0 := by\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n  obtain \u27e8c, rfl\u27e9 := \u03b9_surjective c\n  rw [superCommute_eq_\u03b9_superCommuteF, \u2190 map_mul, normalOrder_eq_\u03b9_normalOrderF]\n  simp\n\n@[simp]\nlemma normalOrder_superCommute_right_eq_zero (a b c: \ud835\udcd5.FieldOpAlgebra) :\n    \ud835\udcdd(c * [a, b]\u209b) = 0 := by\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n  obtain \u27e8c, rfl\u27e9 := \u03b9_surjective c\n  rw [superCommute_eq_\u03b9_superCommuteF, \u2190 map_mul, normalOrder_eq_\u03b9_normalOrderF]\n  simp\n\n@[simp]\nlemma normalOrder_superCommute_mid_eq_zero (a b c d : \ud835\udcd5.FieldOpAlgebra) :\n    \ud835\udcdd(a * [c, d]\u209b * b) = 0 := by\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n  obtain \u27e8c, rfl\u27e9 := \u03b9_surjective c\n  obtain \u27e8d, rfl\u27e9 := \u03b9_surjective d\n  rw [superCommute_eq_\u03b9_superCommuteF, \u2190 map_mul, \u2190 map_mul, normalOrder_eq_\u03b9_normalOrderF]\n  simp\n\n/-!\n\n### Swapping terms in a normal order.\n\n-/\n\nlemma normalOrder_ofFieldOp_ofFieldOp_swap (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    \ud835\udcdd(ofFieldOp \u03c6 * ofFieldOp \u03c6') = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 \ud835\udcdd(ofFieldOp \u03c6' * ofFieldOp \u03c6) := by\n  rw [ofFieldOp_mul_ofFieldOp_eq_superCommute]\n  simp\n\nlemma normalOrder_ofCrAnOp_ofCrAnList (\u03c6 : \ud835\udcd5.CrAnFieldOp)\n    (\u03c6s : List \ud835\udcd5.CrAnFieldOp) : \ud835\udcdd(ofCrAnOp \u03c6 * ofCrAnList \u03c6s) =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 \ud835\udcdd(ofCrAnList \u03c6s * ofCrAnOp \u03c6) := by\n  rw [\u2190 ofCrAnList_singleton, ofCrAnList_mul_ofCrAnList_eq_superCommute]\n  simp\n\nlemma normalOrder_ofCrAnOp_ofFieldOpList_swap (\u03c6 : \ud835\udcd5.CrAnFieldOp) (\u03c6' : List \ud835\udcd5.FieldOp) :\n    \ud835\udcdd(ofCrAnOp \u03c6 * ofFieldOpList \u03c6') = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022\n    \ud835\udcdd(ofFieldOpList \u03c6' * ofCrAnOp \u03c6) := by\n  rw [\u2190 ofCrAnList_singleton, ofCrAnList_mul_ofFieldOpList_eq_superCommute]\n  simp\n\nlemma normalOrder_anPart_ofFieldOpList_swap (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6' : List \ud835\udcd5.FieldOp) :\n    \ud835\udcdd(anPart \u03c6 * ofFieldOpList \u03c6') = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 \ud835\udcdd(ofFieldOpList \u03c6' * anPart \u03c6) := by\n  match \u03c6 with\n  | .inAsymp \u03c6 =>\n    simp\n  | .position \u03c6 =>\n    simp only [anPart_position, instCommGroup.eq_1]\n    rw [normalOrder_ofCrAnOp_ofFieldOpList_swap]\n    rfl\n  | .outAsymp \u03c6 =>\n    simp only [anPart_posAsymp, instCommGroup.eq_1]\n    rw [normalOrder_ofCrAnOp_ofFieldOpList_swap]\n    rfl\n\nlemma normalOrder_ofFieldOpList_anPart_swap (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6' : List \ud835\udcd5.FieldOp) :\n    \ud835\udcdd(ofFieldOpList \u03c6' * anPart \u03c6) = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 \ud835\udcdd(anPart \u03c6 * ofFieldOpList \u03c6') := by\n  rw [normalOrder_anPart_ofFieldOpList_swap]\n  simp [smul_smul, FieldStatistic.exchangeSign_mul_self]\n\n", "theoremStatement": "lemma normalOrder_ofFieldOpList_mul_anPart_swap (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    \ud835\udcdd(ofFieldOpList \u03c6s) * anPart \u03c6 = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 \ud835\udcdd(anPart \u03c6 * ofFieldOpList \u03c6s) ", "theoremName": "FieldSpecification.FieldOpAlgebra.normalOrder_ofFieldOpList_mul_anPart_swap", "fileCreated": {"commit": "2e82f842a242717b98517656fc34b1b92f579b2e", "date": "2025-02-05"}, "theoremCreated": {"commit": "fc2009928299f5a839dd880670f22245b6a09f72", "date": "2025-01-30"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpAlgebra/NormalOrder/Lemmas.lean", "module": "HepLean.PerturbationTheory.FieldOpAlgebra.NormalOrder.Lemmas", "jsonFile": "HepLean.PerturbationTheory.FieldOpAlgebra.NormalOrder.Lemmas.jsonl", "positionMetadata": {"lineInFile": 201, "tokenPositionInFile": 6285, "theoremPositionInFile": 21}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 16, "numPremises": 71}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [\u2190 normalOrder_mul_anPart]\n  rw [normalOrder_ofFieldOpList_anPart_swap]", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 82}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.Basic\nimport Mathlib.RingTheory.GradedAlgebra.Basic\n/-!\n\n# Grading on the FieldOpFreeAlgebra\n\n-/\n\nnamespace FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\nopen FieldStatistic\n\nnamespace FieldOpFreeAlgebra\n\nnoncomputable section\n\n/-- The submodule of `FieldOpFreeAlgebra` spanned by lists of field statistic `f`. -/\ndef statisticSubmodule (f : FieldStatistic) : Submodule \u2102 \ud835\udcd5.FieldOpFreeAlgebra :=\n  Submodule.span \u2102 {a | \u2203 \u03c6s, a = ofCrAnListF \u03c6s \u2227 (\ud835\udcd5 |>\u209b \u03c6s) = f}\n\nlemma ofCrAnListF_mem_statisticSubmodule_of (\u03c6s : List \ud835\udcd5.CrAnFieldOp) (f : FieldStatistic)\n    (h : (\ud835\udcd5 |>\u209b \u03c6s) = f) :\n    ofCrAnListF \u03c6s \u2208 statisticSubmodule f := by\n  refine Submodule.mem_span.mpr fun _ a => a \u27e8\u03c6s, \u27e8rfl, h\u27e9\u27e9\n\nlemma ofCrAnListF_bosonic_or_fermionic (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnListF \u03c6s \u2208 statisticSubmodule bosonic \u2228\n    ofCrAnListF \u03c6s \u2208 statisticSubmodule fermionic := by\n  by_cases h : (\ud835\udcd5 |>\u209b \u03c6s) = bosonic\n  \u00b7 left\n    exact ofCrAnListF_mem_statisticSubmodule_of \u03c6s bosonic h\n  \u00b7 right\n    exact ofCrAnListF_mem_statisticSubmodule_of \u03c6s fermionic (by simpa using h)\n\nlemma ofCrAnOpF_bosonic_or_fermionic (\u03c6 : \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnOpF \u03c6 \u2208 statisticSubmodule bosonic \u2228 ofCrAnOpF \u03c6 \u2208 statisticSubmodule fermionic := by\n  rw [\u2190 ofCrAnListF_singleton]\n  exact ofCrAnListF_bosonic_or_fermionic [\u03c6]\n\n/-- The projection of an element of `FieldOpFreeAlgebra` onto it's bosonic part. -/\ndef bosonicProjF : \ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102] statisticSubmodule (\ud835\udcd5 := \ud835\udcd5) bosonic :=\n  Basis.constr ofCrAnListFBasis \u2102 fun \u03c6s =>\n  if h : (\ud835\udcd5 |>\u209b \u03c6s) = bosonic then\n    \u27e8ofCrAnListF \u03c6s, Submodule.mem_span.mpr fun _ a => a \u27e8\u03c6s, \u27e8rfl, h\u27e9\u27e9\u27e9\n  else\n    0\n\nlemma bosonicProjF_ofCrAnListF (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    bosonicProjF (ofCrAnListF \u03c6s) = if h : (\ud835\udcd5 |>\u209b \u03c6s) = bosonic then\n      \u27e8ofCrAnListF \u03c6s, Submodule.mem_span.mpr fun _ a => a \u27e8\u03c6s, \u27e8rfl, h\u27e9\u27e9\u27e9 else 0 := by\n  conv_lhs =>\n    rw [\u2190 ofListBasis_eq_ofList, bosonicProjF, Basis.constr_basis]\n\nlemma bosonicProjF_of_mem_bosonic (a : \ud835\udcd5.FieldOpFreeAlgebra) (h : a \u2208 statisticSubmodule bosonic) :\n    bosonicProjF a = \u27e8a, h\u27e9 := by\n  let p (a : \ud835\udcd5.FieldOpFreeAlgebra) (hx : a \u2208 statisticSubmodule bosonic) : Prop :=\n    bosonicProjF a = \u27e8a, hx\u27e9\n  change p a h\n  apply Submodule.span_induction\n  \u00b7 intro x hx\n    simp only [Set.mem_setOf_eq] at hx\n    obtain \u27e8\u03c6s, rfl, h\u27e9 := hx\n    simp [p, bosonicProjF_ofCrAnListF, h]\n  \u00b7 simp only [map_zero, p]\n    rfl\n  \u00b7 intro x y hx hy hpx hpy\n    simp_all [p]\n  \u00b7 intro a x hx hy\n    simp_all [p]\n\nlemma bosonicProjF_of_mem_fermionic (a : \ud835\udcd5.FieldOpFreeAlgebra)\n    (h : a \u2208 statisticSubmodule fermionic) :\n    bosonicProjF a = 0 := by\n  let p (a : \ud835\udcd5.FieldOpFreeAlgebra) (hx : a \u2208 statisticSubmodule fermionic) : Prop :=\n    bosonicProjF a = 0\n  change p a h\n  apply Submodule.span_induction\n  \u00b7 intro x hx\n    simp only [Set.mem_setOf_eq] at hx\n    obtain \u27e8\u03c6s, rfl, h\u27e9 := hx\n    simp [p, bosonicProjF_ofCrAnListF, h]\n  \u00b7 simp [p]\n  \u00b7 intro x y hx hy hpx hpy\n    simp_all [p]\n  \u00b7 intro a x hx hy\n    simp_all [p]\n\n@[simp]\nlemma bosonicProjF_of_bonosic_part\n    (a : DirectSum FieldStatistic (fun i => (statisticSubmodule (\ud835\udcd5 := \ud835\udcd5) i))) :\n    bosonicProjF (a bosonic) = a bosonic := by\n  apply bosonicProjF_of_mem_bosonic\n\n", "theoremStatement": "@[simp]\nlemma bosonicProjF_of_fermionic_part\n    (a : DirectSum FieldStatistic (fun i => (statisticSubmodule (\ud835\udcd5 := \ud835\udcd5) i))) :\n    bosonicProjF (a fermionic).1 = 0 ", "theoremName": "FieldSpecification.FieldOpFreeAlgebra.bosonicProjF_of_fermionic_part", "fileCreated": {"commit": "ea6e12829370d9630a7e65200c8349e9086c05ba", "date": "2025-02-03"}, "theoremCreated": {"commit": "7d9e6af80c57599f68481948604d9f0aaba4a40f", "date": "2025-02-05"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpFreeAlgebra/Grading.lean", "module": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.Grading", "jsonFile": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.Grading.jsonl", "positionMetadata": {"lineInFile": 99, "tokenPositionInFile": 3409, "theoremPositionInFile": 9}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 9, "numPremises": 46}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  apply bosonicProjF_of_mem_fermionic\n  exact Submodule.coe_mem (a.toFun fermionic)", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 89}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.TimeOrder\nimport HepLean.PerturbationTheory.FieldOpAlgebra.Basic\n/-!\n\n# SuperCommute on Field operator algebra\n\n-/\n\nnamespace FieldSpecification\nopen FieldOpFreeAlgebra\nopen HepLean.List\nopen FieldStatistic\n\nnamespace FieldOpAlgebra\nvariable {\ud835\udcd5 : FieldSpecification}\n\nlemma \u03b9_superCommuteF_eq_zero_of_\u03b9_right_zero (a b : \ud835\udcd5.FieldOpFreeAlgebra) (h : \u03b9 b = 0) :\n    \u03b9 [a, b]\u209bca = 0 := by\n  rw [superCommuteF_expand_bosonicProjF_fermionicProjF]\n  rw [\u03b9_eq_zero_iff_\u03b9_bosonicProjF_fermonicProj_zero] at h\n  simp_all\n\nlemma \u03b9_superCommuteF_eq_zero_of_\u03b9_left_zero (a b : \ud835\udcd5.FieldOpFreeAlgebra) (h : \u03b9 a = 0) :\n    \u03b9 [a, b]\u209bca = 0 := by\n  rw [superCommuteF_expand_bosonicProjF_fermionicProjF]\n  rw [\u03b9_eq_zero_iff_\u03b9_bosonicProjF_fermonicProj_zero] at h\n  simp_all\n\n/-!\n\n## Defining normal order for `FiedOpAlgebra`.\n\n-/\n\nlemma \u03b9_superCommuteF_right_zero_of_mem_ideal (a b : \ud835\udcd5.FieldOpFreeAlgebra)\n    (h : b \u2208 TwoSidedIdeal.span \ud835\udcd5.fieldOpIdealSet) : \u03b9 [a, b]\u209bca = 0 := by\n  apply \u03b9_superCommuteF_eq_zero_of_\u03b9_right_zero\n  exact (\u03b9_eq_zero_iff_mem_ideal b).mpr h\n\nlemma \u03b9_superCommuteF_eq_of_equiv_right (a b1 b2 : \ud835\udcd5.FieldOpFreeAlgebra) (h : b1 \u2248 b2) :\n    \u03b9 [a, b1]\u209bca = \u03b9 [a, b2]\u209bca := by\n  rw [equiv_iff_sub_mem_ideal] at h\n  rw [LinearMap.sub_mem_ker_iff.mp]\n  simp only [LinearMap.mem_ker, \u2190 map_sub]\n  exact \u03b9_superCommuteF_right_zero_of_mem_ideal a (b1 - b2) h\n\n/-- The super commutator on the `FieldOpAlgebra` defined as a linear map `[a,_]\u209b`. -/\nnoncomputable def superCommuteRight (a : \ud835\udcd5.FieldOpFreeAlgebra) :\n  FieldOpAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpAlgebra \ud835\udcd5 where\n  toFun := Quotient.lift (\u03b9.toLinearMap \u2218\u2097 superCommuteF a)\n    (\u03b9_superCommuteF_eq_of_equiv_right a)\n  map_add' x y := by\n    obtain \u27e8x, hx\u27e9 := \u03b9_surjective x\n    obtain \u27e8y, hy\u27e9 := \u03b9_surjective y\n    subst hx hy\n    rw [\u2190 map_add, \u03b9_apply, \u03b9_apply, \u03b9_apply]\n    rw [Quotient.lift_mk, Quotient.lift_mk, Quotient.lift_mk]\n    simp\n  map_smul' c y := by\n    obtain \u27e8y, hy\u27e9 := \u03b9_surjective y\n    subst hy\n    rw [\u2190 map_smul, \u03b9_apply, \u03b9_apply]\n    simp\n\nlemma superCommuteRight_apply_\u03b9 (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    superCommuteRight a (\u03b9 b) = \u03b9 [a, b]\u209bca := by rfl\n\nlemma superCommuteRight_apply_quot (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    superCommuteRight a \u27e6b\u27e7= \u03b9 [a, b]\u209bca := by rfl\n\nlemma superCommuteRight_eq_of_equiv (a1 a2 : \ud835\udcd5.FieldOpFreeAlgebra) (h : a1 \u2248 a2) :\n    superCommuteRight a1 = superCommuteRight a2 := by\n  rw [equiv_iff_sub_mem_ideal] at h\n  ext b\n  obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n  have ha1b1 : (superCommuteRight (a1 - a2)) (\u03b9 b) = 0 := by\n    rw [superCommuteRight_apply_\u03b9]\n    apply \u03b9_superCommuteF_eq_zero_of_\u03b9_left_zero\n    exact (\u03b9_eq_zero_iff_mem_ideal (a1 - a2)).mpr h\n  simp_all only [superCommuteRight_apply_\u03b9, map_sub, LinearMap.sub_apply]\n  trans \u03b9 ((superCommuteF a2) b) + 0\n  rw [\u2190 ha1b1]\n  simp only [add_sub_cancel]\n  simp\n\n/-- For a field specification `\ud835\udcd5`, `superCommute` is the linear map\n\n  `FieldOpAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpAlgebra \ud835\udcd5`\n\n  defined as the decent of `\u03b9 \u2218 superCommuteF` in both arguments.\n  In particular for `\u03c6s` and `\u03c6s'` lists of `\ud835\udcd5.CrAnFieldOp` in `FieldOpAlgebra \ud835\udcd5` the following\n  relation holds:\n\n  `superCommute \u03c6s \u03c6s' = \u03c6s * \u03c6s' - \ud835\udce2(\u03c6s, \u03c6s') \u2022 \u03c6s' * \u03c6s`\n\n  The notation `[a, b]\u209b` is used for `superCommute a b`.\n  -/\nnoncomputable def superCommute : FieldOpAlgebra \ud835\udcd5 \u2192\u2097[\u2102]\n    FieldOpAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpAlgebra \ud835\udcd5 where\n  toFun := Quotient.lift superCommuteRight superCommuteRight_eq_of_equiv\n  map_add' x y := by\n    obtain \u27e8x, rfl\u27e9 := \u03b9_surjective x\n    obtain \u27e8y, rfl\u27e9 := \u03b9_surjective y\n    ext b\n    obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n    rw [\u2190 map_add, \u03b9_apply, \u03b9_apply, \u03b9_apply, \u03b9_apply]\n    rw [Quotient.lift_mk, Quotient.lift_mk, Quotient.lift_mk]\n    simp only [LinearMap.add_apply]\n    rw [superCommuteRight_apply_quot, superCommuteRight_apply_quot, superCommuteRight_apply_quot]\n    simp\n  map_smul' c y := by\n    obtain \u27e8y, rfl\u27e9 := \u03b9_surjective y\n    ext b\n    obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n    rw [\u2190 map_smul, \u03b9_apply, \u03b9_apply, \u03b9_apply]\n    simp only [Quotient.lift_mk, RingHom.id_apply, LinearMap.smul_apply]\n    rw [superCommuteRight_apply_quot, superCommuteRight_apply_quot]\n    simp\n\n@[inherit_doc superCommute]\nscoped[FieldSpecification.FieldOpAlgebra] notation \"[\" a \",\" b \"]\u209b\" => superCommute a b\n\nlemma superCommute_eq_\u03b9_superCommuteF (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    [\u03b9 a, \u03b9 b]\u209b = \u03b9 [a, b]\u209bca := rfl\n\n/-!\n\n## Properties of `superCommute`.\n\n-/\n\n/-!\n\n## Properties from the definition of FieldOpAlgebra\n\n-/\n\nlemma superCommute_create_create {\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp}\n    (h : \ud835\udcd5 |>\u1d9c \u03c6 = .create) (h' : \ud835\udcd5 |>\u1d9c \u03c6' = .create) :\n    [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b = 0 := by\n  rw [ofCrAnOp, ofCrAnOp]\n  rw [superCommute_eq_\u03b9_superCommuteF, \u03b9_superCommuteF_of_create_create _ _ h h']\n\nlemma superCommute_annihilate_annihilate {\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp}\n    (h : \ud835\udcd5 |>\u1d9c \u03c6 = .annihilate) (h' : \ud835\udcd5 |>\u1d9c \u03c6' = .annihilate) :\n    [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b = 0 := by\n  rw [ofCrAnOp, ofCrAnOp]\n  rw [superCommute_eq_\u03b9_superCommuteF, \u03b9_superCommuteF_of_annihilate_annihilate _ _ h h']\n\nlemma superCommute_diff_statistic {\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp} (h : (\ud835\udcd5 |>\u209b \u03c6) \u2260 \ud835\udcd5 |>\u209b \u03c6') :\n    [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b = 0 := by\n  rw [ofCrAnOp, ofCrAnOp]\n  rw [superCommute_eq_\u03b9_superCommuteF, \u03b9_superCommuteF_of_diff_statistic h]\n\nlemma superCommute_ofCrAnOp_ofFieldOp_diff_stat_zero (\u03c6 : \ud835\udcd5.CrAnFieldOp) (\u03c8 : \ud835\udcd5.FieldOp)\n    (h : (\ud835\udcd5 |>\u209b \u03c6) \u2260 (\ud835\udcd5 |>\u209b \u03c8)) : [ofCrAnOp \u03c6, ofFieldOp \u03c8]\u209b = 0 := by\n  rw [ofFieldOp_eq_sum, map_sum]\n  rw [Finset.sum_eq_zero]\n  intro x hx\n  apply superCommute_diff_statistic\n  simpa [crAnStatistics] using h\n\nlemma superCommute_anPart_ofFieldOpF_diff_grade_zero (\u03c6 \u03c8 : \ud835\udcd5.FieldOp)\n    (h : (\ud835\udcd5 |>\u209b \u03c6) \u2260 (\ud835\udcd5 |>\u209b \u03c8)) : [anPart \u03c6, ofFieldOp \u03c8]\u209b = 0 := by\n  match \u03c6 with\n  | FieldOp.inAsymp _ =>\n    simp\n  | FieldOp.position \u03c6 =>\n    simp only [anPartF_position]\n    apply superCommute_ofCrAnOp_ofFieldOp_diff_stat_zero _ _ _\n    simpa [crAnStatistics] using h\n  | FieldOp.outAsymp _ =>\n    simp only [anPartF_posAsymp]\n    apply superCommute_ofCrAnOp_ofFieldOp_diff_stat_zero _ _\n    simpa [crAnStatistics] using h\n\nlemma superCommute_ofCrAnOp_ofCrAnOp_mem_center (\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b \u2208 Subalgebra.center \u2102 (FieldOpAlgebra \ud835\udcd5) := by\n  rw [ofCrAnOp, ofCrAnOp, superCommute_eq_\u03b9_superCommuteF]\n  exact \u03b9_superCommuteF_ofCrAnOpF_ofCrAnOpF_mem_center \u03c6 \u03c6'\n\nlemma superCommute_ofCrAnOp_ofCrAnOp_commute (\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp)\n    (a : FieldOpAlgebra \ud835\udcd5) :\n    a * [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b = [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b * a := by\n  have h1 := superCommute_ofCrAnOp_ofCrAnOp_mem_center \u03c6 \u03c6'\n  rw [@Subalgebra.mem_center_iff] at h1\n  exact h1 a\n\nlemma superCommute_ofCrAnOp_ofFieldOp_mem_center (\u03c6 : \ud835\udcd5.CrAnFieldOp) (\u03c6' : \ud835\udcd5.FieldOp) :\n    [ofCrAnOp \u03c6, ofFieldOp \u03c6']\u209b \u2208 Subalgebra.center \u2102 (FieldOpAlgebra \ud835\udcd5) := by\n  rw [ofFieldOp_eq_sum]\n  simp only [map_sum]\n  refine Subalgebra.sum_mem (Subalgebra.center \u2102 \ud835\udcd5.FieldOpAlgebra) ?_\n  intro x hx\n  exact superCommute_ofCrAnOp_ofCrAnOp_mem_center \u03c6 \u27e8\u03c6', x\u27e9\n\nlemma superCommute_ofCrAnOp_ofFieldOp_commute (\u03c6 : \ud835\udcd5.CrAnFieldOp) (\u03c6' : \ud835\udcd5.FieldOp)\n    (a : FieldOpAlgebra \ud835\udcd5) : a * [ofCrAnOp \u03c6, ofFieldOp \u03c6']\u209b =\n    [ofCrAnOp \u03c6, ofFieldOp \u03c6']\u209b * a := by\n  have h1 := superCommute_ofCrAnOp_ofFieldOp_mem_center \u03c6 \u03c6'\n  rw [@Subalgebra.mem_center_iff] at h1\n  exact h1 a\n\nlemma superCommute_anPart_ofFieldOp_mem_center (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [anPart \u03c6, ofFieldOp \u03c6']\u209b \u2208 Subalgebra.center \u2102 (FieldOpAlgebra \ud835\udcd5) := by\n  match \u03c6 with\n  | FieldOp.inAsymp _ =>\n    simp only [anPart_negAsymp, map_zero, LinearMap.zero_apply]\n    exact Subalgebra.zero_mem (Subalgebra.center \u2102 _)\n  | FieldOp.position \u03c6 =>\n    exact superCommute_ofCrAnOp_ofFieldOp_mem_center _ _\n  | FieldOp.outAsymp _ =>\n    exact superCommute_ofCrAnOp_ofFieldOp_mem_center _ _\n\n/-!\n\n### `superCommute` on different constructors.\n\n-/\n\nlemma superCommute_ofCrAnList_ofCrAnList (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnList \u03c6s, ofCrAnList \u03c6s']\u209b =\n    ofCrAnList (\u03c6s ++ \u03c6s') - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnList (\u03c6s' ++ \u03c6s) := by\n  rw [ofCrAnList_eq_\u03b9_ofCrAnListF, ofCrAnList_eq_\u03b9_ofCrAnListF]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_ofCrAnListF_ofCrAnListF]\n  rfl\n\nlemma superCommute_ofCrAnOp_ofCrAnOp (\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b = ofCrAnOp \u03c6 * ofCrAnOp \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 ofCrAnOp \u03c6' * ofCrAnOp \u03c6 := by\n  rw [ofCrAnOp, ofCrAnOp]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_ofCrAnOpF_ofCrAnOpF]\n  rfl\n\n", "theoremStatement": "lemma superCommute_ofCrAnList_ofFieldOpList (\u03c6cas : List \ud835\udcd5.CrAnFieldOp)\n    (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [ofCrAnList \u03c6cas, ofFieldOpList \u03c6s]\u209b = ofCrAnList \u03c6cas * ofFieldOpList \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6cas, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpList \u03c6s * ofCrAnList \u03c6cas ", "theoremName": "FieldSpecification.FieldOpAlgebra.superCommute_ofCrAnList_ofFieldOpList", "fileCreated": {"commit": "ea6e12829370d9630a7e65200c8349e9086c05ba", "date": "2025-02-03"}, "theoremCreated": {"commit": "48e3417d5d558b5f1fcd618091baa0eae36f95a5", "date": "2025-02-06"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpAlgebra/SuperCommute.lean", "module": "HepLean.PerturbationTheory.FieldOpAlgebra.SuperCommute", "jsonFile": "HepLean.PerturbationTheory.FieldOpAlgebra.SuperCommute.jsonl", "positionMetadata": {"lineInFile": 240, "tokenPositionInFile": 8648, "theoremPositionInFile": 21}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 21, "numPremises": 101}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [ofCrAnList, ofFieldOpList]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_ofCrAnListF_ofFieldOpFsList]\n  rfl", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 126}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldSpecification.CrAnFieldOp\nimport HepLean.PerturbationTheory.FieldSpecification.CrAnSection\n/-!\n\n# Creation and annihilation free-algebra\n\nThis module defines the creation and annihilation algebra for a field structure.\n\nThe creation and annihilation algebra extends from the state algebra by adding information about\nwhether a state is a creation or annihilation operator.\n\nThe algebra is spanned by lists of creation/annihilation states.\n\nThe main structures defined in this module are:\n\n* `FieldOpFreeAlgebra` - The creation and annihilation algebra\n* `ofCrAnOpF` - Maps a creation/annihilation state to the algebra\n* `ofCrAnListF` - Maps a list of creation/annihilation states to the algebra\n* `ofFieldOpF` - Maps a state to a sum of creation and annihilation operators\n* `crPartF` - The creation part of a state in the algebra\n* `anPartF` - The annihilation part of a state in the algebra\n* `superCommuteF` - The super commutator on the algebra\n\nThe key lemmas show how these operators interact, particularly focusing on the\nsuper commutation relations between creation and annihilation operators.\n\n-/\n\nnamespace FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\n/-- For a field specification `\ud835\udcd5`, the algebra `\ud835\udcd5.FieldOpFreeAlgebra` is\n  the free algebra generated by `\ud835\udcd5.CrAnFieldOp`. -/\nabbrev FieldOpFreeAlgebra (\ud835\udcd5 : FieldSpecification) : Type := FreeAlgebra \u2102 \ud835\udcd5.CrAnFieldOp\n\nnamespace FieldOpFreeAlgebra\n\nremark naming_convention := \"\n  For mathematicial objects defined in relation to `FieldOpFreeAlgebra` the postfix `F`\n  may be given to\n  their names to indicate that they are related to the free algebra.\n  This is to avoid confusion when working within the context of `FieldOpAlgebra` which is defined\n  as a quotient of `FieldOpFreeAlgebra`.\"\n\n/-- For a field specification `\ud835\udcd5`, and a element `\u03c6` of `\ud835\udcd5.CrAnFieldOp`,\n  `ofCrAnOpF \u03c6` is defined as the element of `\ud835\udcd5.FieldOpFreeAlgebra` formed by `\u03c6`. -/\ndef ofCrAnOpF (\u03c6 : \ud835\udcd5.CrAnFieldOp) : FieldOpFreeAlgebra \ud835\udcd5 :=\n  FreeAlgebra.\u03b9 \u2102 \u03c6\n\n/--\nThe algebra `\ud835\udcd5.FieldOpFreeAlgebra` satisfies the universal property that for any other algebra\n  `A` (e.g. the operator algebra of the theory) with a map `f : \ud835\udcd5.CrAnFieldOp \u2192 A` (e.g.\n  the inclusion of the creation and annihilation parts of field operators into the\n  operator algebra) there is a unique algebra map `g : \ud835\udcd5.FieldOpFreeAlgebra \u2192 A`\n  such that `g \u2218 ofCrAnOpF = f`.\n\n  The unique `g` is given by `FreeAlgebra.lift \u2102 f`.\n-/\nlemma universality {A : Type} [Semiring A] [Algebra \u2102 A] (f : \ud835\udcd5.CrAnFieldOp \u2192 A) :\n    \u2203! g : FieldOpFreeAlgebra \ud835\udcd5 \u2192\u2090[\u2102] A, g \u2218 ofCrAnOpF = f := by\n  use FreeAlgebra.lift \u2102 f\n  apply And.intro\n  \u00b7 funext x\n    simp [ofCrAnOpF]\n  \u00b7 intro g hg\n    ext x\n    simpa using congrFun hg x\n\n/-- For a field specification `\ud835\udcd5`, and a list `\u03c6s` of `\ud835\udcd5.CrAnFieldOp`,\n `ofCrAnListF \u03c6s` is defined as the element of `\ud835\udcd5.FieldOpFreeAlgebra`\n  obtained by the product of `ofCrAnListF \u03c6` for each `\u03c6` in `\u03c6s`.\n  For example `ofCrAnListF [\u03c6\u2081, \u03c6\u2082, \u03c6\u2083] = ofCrAnOpF \u03c6\u2081 * ofCrAnOpF \u03c6\u2082 * ofCrAnOpF \u03c6\u2083`.\n  The set of all `ofCrAnListF \u03c6s` forms a basis of `FieldOpFreeAlgebra \ud835\udcd5`. -/\ndef ofCrAnListF (\u03c6s : List \ud835\udcd5.CrAnFieldOp) : FieldOpFreeAlgebra \ud835\udcd5 := (List.map ofCrAnOpF \u03c6s).prod\n\n@[simp]\nlemma ofCrAnListF_nil : ofCrAnListF ([] : List \ud835\udcd5.CrAnFieldOp) = 1 := rfl\n\nlemma ofCrAnListF_cons (\u03c6 : \ud835\udcd5.CrAnFieldOp) (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnListF (\u03c6 :: \u03c6s) = ofCrAnOpF \u03c6 * ofCrAnListF \u03c6s := rfl\n\nlemma ofCrAnListF_append (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnListF (\u03c6s ++ \u03c6s') = ofCrAnListF \u03c6s * ofCrAnListF \u03c6s' := by\n  simp [ofCrAnListF, List.map_append]\n\nlemma ofCrAnListF_singleton (\u03c6 : \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnListF [\u03c6] = ofCrAnOpF \u03c6 := by simp [ofCrAnListF]\n\n/-- For a field specification `\ud835\udcd5`, and an element `\u03c6` of  `\ud835\udcd5.FieldOp`,\n  `ofFieldOpF \u03c6` is the element of `\ud835\udcd5.FieldOpFreeAlgebra` formed  by summing over\n  `ofCrAnOpF` of the\n  creation and annihilation parts of `\u03c6`.\n\n  For example for `\u03c6` an incoming asymptotic field operator we get\n  `ofCrAnOpF \u27e8\u03c6, ()\u27e9`, and for `\u03c6` a\n  position field operator we get `ofCrAnOpF \u27e8\u03c6, .create\u27e9 + ofCrAnOpF \u27e8\u03c6, .annihilate\u27e9`. -/\ndef ofFieldOpF (\u03c6 : \ud835\udcd5.FieldOp) : FieldOpFreeAlgebra \ud835\udcd5 :=\n  \u2211 (i : \ud835\udcd5.fieldOpToCrAnType \u03c6), ofCrAnOpF \u27e8\u03c6, i\u27e9\n\n/-- For a field specification `\ud835\udcd5`, and a list `\u03c6s` of `\ud835\udcd5.FieldOp`,\n  `\ud835\udcd5.ofFieldOpListF \u03c6s` is defined as the element of `\ud835\udcd5.FieldOpFreeAlgebra`\n  obtained by the product of `ofFieldOpF \u03c6` for each `\u03c6` in `\u03c6s`.\n  For example `ofFieldOpListF [\u03c6\u2081, \u03c6\u2082, \u03c6\u2083] = ofFieldOpF \u03c6\u2081 * ofFieldOpF \u03c6\u2082 * ofFieldOpF \u03c6\u2083`. -/\ndef ofFieldOpListF (\u03c6s : List \ud835\udcd5.FieldOp) : FieldOpFreeAlgebra \ud835\udcd5 := (List.map ofFieldOpF \u03c6s).prod\n\nremark notation_drop := \"In doc-strings explicit applications of `ofCrAnOpF`,\n`ofCrAnListF`, `ofFieldOpF`, and `ofFieldOpListF` will often be dropped.\"\n\n/-- Coercion from `List \ud835\udcd5.FieldOp` to `FieldOpFreeAlgebra \ud835\udcd5` through `ofFieldOpListF`. -/\ninstance : Coe (List \ud835\udcd5.FieldOp) (FieldOpFreeAlgebra \ud835\udcd5) := \u27e8ofFieldOpListF\u27e9\n\n@[simp]\nlemma ofFieldOpListF_nil : ofFieldOpListF ([] : List \ud835\udcd5.FieldOp) = 1 := rfl\n\nlemma ofFieldOpListF_cons (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    ofFieldOpListF (\u03c6 :: \u03c6s) = ofFieldOpF \u03c6 * ofFieldOpListF \u03c6s := rfl\n\nlemma ofFieldOpListF_singleton (\u03c6 : \ud835\udcd5.FieldOp) :\n    ofFieldOpListF [\u03c6] = ofFieldOpF \u03c6 := by simp [ofFieldOpListF]\n\nlemma ofFieldOpListF_append (\u03c6s \u03c6s' : List \ud835\udcd5.FieldOp) :\n    ofFieldOpListF (\u03c6s ++ \u03c6s') = ofFieldOpListF \u03c6s * ofFieldOpListF \u03c6s' := by\n  dsimp only [ofFieldOpListF]\n  rw [List.map_append, List.prod_append]\n\nlemma ofFieldOpListF_sum (\u03c6s : List \ud835\udcd5.FieldOp) :\n    ofFieldOpListF \u03c6s = \u2211 (s : CrAnSection \u03c6s), ofCrAnListF s.1 := by\n  induction \u03c6s with\n  | nil => simp\n  | cons \u03c6 \u03c6s ih =>\n    rw [CrAnSection.sum_cons]\n    dsimp only [CrAnSection.cons, ofCrAnListF_cons]\n    conv_rhs =>\n      enter [2, x]\n      rw [\u2190 Finset.mul_sum]\n    rw [\u2190 Finset.sum_mul, ofFieldOpListF_cons, \u2190 ih]\n    rfl\n\n/-!\n\n## Creation and annihilation parts of a state\n\n-/\n\n/-- The algebra map taking an element of the free-state algebra to\n  the part of it in the creation and annihilation free algebra\n  spanned by creation operators. -/\ndef crPartF : \ud835\udcd5.FieldOp \u2192 \ud835\udcd5.FieldOpFreeAlgebra := fun \u03c6 =>\n  match \u03c6 with\n  | FieldOp.inAsymp \u03c6 => ofCrAnOpF \u27e8FieldOp.inAsymp \u03c6, ()\u27e9\n  | FieldOp.position \u03c6 => ofCrAnOpF \u27e8FieldOp.position \u03c6, CreateAnnihilate.create\u27e9\n  | FieldOp.outAsymp _ => 0\n\n@[simp]\nlemma crPartF_negAsymp (\u03c6 : (\u03a3 f, \ud835\udcd5.AsymptoticLabel f) \u00d7 (Fin 3 \u2192 \u211d)) :\n    crPartF (FieldOp.inAsymp \u03c6) = ofCrAnOpF \u27e8FieldOp.inAsymp \u03c6, ()\u27e9 := by\n  simp [crPartF]\n\n@[simp]\nlemma crPartF_position (\u03c6 : (\u03a3 f, \ud835\udcd5.PositionLabel f) \u00d7 SpaceTime) :\n    crPartF (FieldOp.position \u03c6) =\n    ofCrAnOpF \u27e8FieldOp.position \u03c6, CreateAnnihilate.create\u27e9 := by\n  simp [crPartF]\n\n@[simp]\nlemma crPartF_posAsymp (\u03c6 : (\u03a3 f, \ud835\udcd5.AsymptoticLabel f) \u00d7 (Fin 3 \u2192 \u211d)) :\n    crPartF (FieldOp.outAsymp \u03c6) = 0 := by\n  simp [crPartF]\n\n/-- The algebra map taking an element of the free-state algebra to\n  the part of it in the creation and annihilation free algebra\n  spanned by annihilation operators. -/\ndef anPartF : \ud835\udcd5.FieldOp \u2192 \ud835\udcd5.FieldOpFreeAlgebra := fun \u03c6 =>\n  match \u03c6 with\n  | FieldOp.inAsymp _ => 0\n  | FieldOp.position \u03c6 => ofCrAnOpF \u27e8FieldOp.position \u03c6, CreateAnnihilate.annihilate\u27e9\n  | FieldOp.outAsymp \u03c6 => ofCrAnOpF \u27e8FieldOp.outAsymp \u03c6, ()\u27e9\n\n@[simp]\nlemma anPartF_negAsymp (\u03c6 : (\u03a3 f, \ud835\udcd5.AsymptoticLabel f) \u00d7 (Fin 3 \u2192 \u211d)) :\n    anPartF (FieldOp.inAsymp \u03c6) = 0 := by\n  simp [anPartF]\n\n@[simp]\nlemma anPartF_position (\u03c6 : (\u03a3 f, \ud835\udcd5.PositionLabel f) \u00d7 SpaceTime) :\n    anPartF (FieldOp.position \u03c6) =\n    ofCrAnOpF \u27e8FieldOp.position \u03c6, CreateAnnihilate.annihilate\u27e9 := by\n  simp [anPartF]\n\n@[simp]\nlemma anPartF_posAsymp (\u03c6 : (\u03a3 f, \ud835\udcd5.AsymptoticLabel f) \u00d7 (Fin 3 \u2192 \u211d)) :\n    anPartF (FieldOp.outAsymp \u03c6) = ofCrAnOpF \u27e8FieldOp.outAsymp \u03c6, ()\u27e9 := by\n  simp [anPartF]\n\nlemma ofFieldOpF_eq_crPartF_add_anPartF (\u03c6 : \ud835\udcd5.FieldOp) :\n    ofFieldOpF \u03c6 = crPartF \u03c6 + anPartF \u03c6 := by\n  rw [ofFieldOpF]\n  cases \u03c6 with\n  | inAsymp \u03c6 => simp [fieldOpToCrAnType]\n  | position \u03c6 => simp [fieldOpToCrAnType, CreateAnnihilate.sum_eq]\n  | outAsymp \u03c6 => simp [fieldOpToCrAnType]\n\n/-!\n\n## The basis of the creation and annihilation free-algebra.\n\n-/\n\n/-- The basis of the free creation and annihilation algebra formed by lists of CrAnFieldOp. -/\nnoncomputable def ofCrAnListFBasis : Basis (List \ud835\udcd5.CrAnFieldOp) \u2102 (FieldOpFreeAlgebra \ud835\udcd5) where\n  repr := FreeAlgebra.equivMonoidAlgebraFreeMonoid.toLinearEquiv\n\n@[simp]\nlemma ofListBasis_eq_ofList (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnListFBasis \u03c6s = ofCrAnListF \u03c6s := by\n  simp only [ofCrAnListFBasis, FreeAlgebra.equivMonoidAlgebraFreeMonoid, MonoidAlgebra.of_apply,\n    Basis.coe_ofRepr, AlgEquiv.toLinearEquiv_symm, AlgEquiv.toLinearEquiv_apply,\n    AlgEquiv.ofAlgHom_symm_apply, ofCrAnListF]\n  erw [MonoidAlgebra.lift_apply]\n  simp only [zero_smul, Finsupp.sum_single_index, one_smul]\n  rw [@FreeMonoid.lift_apply]\n  match \u03c6s with\n  | [] => rfl\n  | \u03c6 :: \u03c6s => erw [List.map_cons]\n\n/-!\n\n## Some useful multi-linear maps.\n\n-/\n\n/-- The bi-linear map associated with multiplication in `FieldOpFreeAlgebra`. -/\nnoncomputable def mulLinearMap : FieldOpFreeAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpFreeAlgebra \ud835\udcd5 \u2192\u2097[\u2102]\n    FieldOpFreeAlgebra \ud835\udcd5 where\n  toFun a := {\n    toFun := fun b => a * b,\n    map_add' := fun c d => by simp [mul_add]\n    map_smul' := by simp}\n  map_add' := fun a b => by\n    ext c\n    simp [add_mul]\n  map_smul' := by\n    intros\n    ext c\n    simp [smul_mul']\n\n", "theoremStatement": "lemma mulLinearMap_apply (a b : FieldOpFreeAlgebra \ud835\udcd5) :\n    mulLinearMap a b = a * b ", "theoremName": "FieldSpecification.FieldOpFreeAlgebra.mulLinearMap_apply", "fileCreated": {"commit": "ea6e12829370d9630a7e65200c8349e9086c05ba", "date": "2025-02-03"}, "theoremCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpFreeAlgebra/Basic.lean", "module": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.Basic", "jsonFile": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.Basic.jsonl", "positionMetadata": {"lineInFile": 252, "tokenPositionInFile": 9585, "theoremPositionInFile": 25}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 4, "numPremises": 29}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpAlgebra.Basic\n/-!\n\n# Grading on the field operation algebra\n\n-/\n\nnamespace FieldSpecification\nopen FieldOpFreeAlgebra\nopen HepLean.List\nopen FieldStatistic\n\nnamespace FieldOpAlgebra\nvariable {\ud835\udcd5 : FieldSpecification}\n\n/-- The submodule of `\ud835\udcd5.FieldOpAlgebra` spanned by lists of field statistic `f`. -/\ndef statSubmodule (f : FieldStatistic) : Submodule \u2102 \ud835\udcd5.FieldOpAlgebra :=\n  Submodule.span \u2102 {a | \u2203 \u03c6s, a = ofCrAnList \u03c6s \u2227 (\ud835\udcd5 |>\u209b \u03c6s) = f}\n\nlemma ofCrAnList_mem_statSubmodule_of_eq (\u03c6s : List \ud835\udcd5.CrAnFieldOp) (f : FieldStatistic)\n    (h : (\ud835\udcd5 |>\u209b \u03c6s) = f) : ofCrAnList \u03c6s \u2208 statSubmodule f :=\n  Submodule.mem_span.mpr fun _ a => a \u27e8\u03c6s, \u27e8rfl, h\u27e9\u27e9\n\nlemma ofCrAnList_mem_statSubmodule (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnList \u03c6s \u2208 statSubmodule (\ud835\udcd5 |>\u209b \u03c6s) :=\n  Submodule.mem_span.mpr fun _ a => a \u27e8\u03c6s, \u27e8rfl, rfl\u27e9\u27e9\n\nlemma mem_bosonic_of_mem_free_bosonic (a : \ud835\udcd5.FieldOpFreeAlgebra)\n    (h : a \u2208 statisticSubmodule bosonic) : \u03b9 a \u2208 statSubmodule .bosonic := by\n  let p (a : \ud835\udcd5.FieldOpFreeAlgebra) (hx : a \u2208 statisticSubmodule bosonic) : Prop :=\n    \u03b9 a \u2208 statSubmodule .bosonic\n  change p a h\n  apply Submodule.span_induction\n  \u00b7 intro x hx\n    simp only [Set.mem_setOf_eq] at hx\n    obtain \u27e8\u03c6s, rfl, h\u27e9 := hx\n    simp [p]\n    apply ofCrAnList_mem_statSubmodule_of_eq\n    exact h\n  \u00b7 simp only [map_zero, p]\n    exact Submodule.zero_mem (statSubmodule bosonic)\n  \u00b7 intro x y hx hy hpx hpy\n    simp_all only [p, map_add]\n    exact Submodule.add_mem _ hpx hpy\n  \u00b7 intro a x hx hy\n    simp_all only [p, map_smul]\n    exact Submodule.smul_mem _ _ hy\n\nlemma mem_fermionic_of_mem_free_fermionic (a : \ud835\udcd5.FieldOpFreeAlgebra)\n    (h : a \u2208 statisticSubmodule fermionic) : \u03b9 a \u2208 statSubmodule .fermionic := by\n  let p (a : \ud835\udcd5.FieldOpFreeAlgebra) (hx : a \u2208 statisticSubmodule fermionic) : Prop :=\n    \u03b9 a \u2208 statSubmodule .fermionic\n  change p a h\n  apply Submodule.span_induction\n  \u00b7 intro x hx\n    simp only [Set.mem_setOf_eq] at hx\n    obtain \u27e8\u03c6s, rfl, h\u27e9 := hx\n    simp [p]\n    apply ofCrAnList_mem_statSubmodule_of_eq\n    exact h\n  \u00b7 simp only [map_zero, p]\n    exact Submodule.zero_mem (statSubmodule fermionic)\n  \u00b7 intro x y hx hy hpx hpy\n    simp_all only [p, map_add]\n    exact Submodule.add_mem _ hpx hpy\n  \u00b7 intro a x hx hy\n    simp_all only [p, map_smul]\n    exact Submodule.smul_mem _ _ hy\n\nlemma mem_statSubmodule_of_mem_statisticSubmodule (f : FieldStatistic) (a : \ud835\udcd5.FieldOpFreeAlgebra)\n    (h : a \u2208 statisticSubmodule f) : \u03b9 a \u2208 statSubmodule f := by\n  fin_cases f\n  \u00b7 exact mem_bosonic_of_mem_free_bosonic a h\n  \u00b7 exact mem_fermionic_of_mem_free_fermionic a h\n\n/-- The projection of `statisticSubmodule (\ud835\udcd5 := \ud835\udcd5) f` defined in the free algebra to\n  `statSubmodule (\ud835\udcd5 := \ud835\udcd5) f`. -/\ndef \u03b9StateSubmodule (f : FieldStatistic) :\n    statisticSubmodule (\ud835\udcd5 := \ud835\udcd5) f \u2192\u2097[\u2102] statSubmodule (\ud835\udcd5 := \ud835\udcd5) f where\n  toFun a := \u27e8a.1, mem_statSubmodule_of_mem_statisticSubmodule f a.1 a.2\u27e9\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n\nnoncomputable section\n\n/-!\n\n## Defining bosonicProj\n\n-/\n\n/-- The projection of `\ud835\udcd5.FieldOpFreeAlgebra` to `statSubmodule (\ud835\udcd5 := \ud835\udcd5) bosonic`. -/\ndef bosonicProjFree : \ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102] statSubmodule (\ud835\udcd5 := \ud835\udcd5) bosonic :=\n  \u03b9StateSubmodule .bosonic \u2218\u2097 bosonicProjF\n\nlemma bosonicProjFree_eq_\u03b9_bosonicProjF (a : \ud835\udcd5.FieldOpFreeAlgebra) :\n    (bosonicProjFree a).1 = \u03b9 (bosonicProjF a) := rfl\n\nlemma bosonicProjFree_zero_of_\u03b9_zero (a : \ud835\udcd5.FieldOpFreeAlgebra) (h : \u03b9 a = 0) :\n    bosonicProjFree a = 0 := by\n  rw [\u03b9_eq_zero_iff_\u03b9_bosonicProjF_fermonicProj_zero] at h\n  apply Subtype.eq\n  rw [bosonicProjFree_eq_\u03b9_bosonicProjF]\n  exact h.1\n\nlemma bosonicProjFree_eq_of_equiv (a b : \ud835\udcd5.FieldOpFreeAlgebra) (h : a \u2248 b) :\n    bosonicProjFree a = bosonicProjFree b := by\n  rw [equiv_iff_sub_mem_ideal, \u2190 \u03b9_eq_zero_iff_mem_ideal] at h\n  rw [LinearMap.sub_mem_ker_iff.mp]\n  simp only [LinearMap.mem_ker, \u2190 map_sub]\n  exact bosonicProjFree_zero_of_\u03b9_zero (a - b) h\n\n/-- The projection of `\ud835\udcd5.FieldOpAlgebra` to `statSubmodule (\ud835\udcd5 := \ud835\udcd5) bosonic`. -/\ndef bosonicProj : \ud835\udcd5.FieldOpAlgebra \u2192\u2097[\u2102] statSubmodule (\ud835\udcd5 := \ud835\udcd5) bosonic where\n  toFun := Quotient.lift bosonicProjFree bosonicProjFree_eq_of_equiv\n  map_add' x y := by\n    obtain \u27e8x, hx\u27e9 := \u03b9_surjective x\n    obtain \u27e8y, hy\u27e9 := \u03b9_surjective y\n    subst hx hy\n    rw [\u2190 map_add, \u03b9_apply, \u03b9_apply, \u03b9_apply]\n    rw [Quotient.lift_mk, Quotient.lift_mk, Quotient.lift_mk]\n    simp\n  map_smul' c y := by\n    obtain \u27e8y, hy\u27e9 := \u03b9_surjective y\n    subst hy\n    rw [\u2190 map_smul, \u03b9_apply, \u03b9_apply]\n    simp\n\nlemma bosonicProj_eq_bosonicProjFree (a : \ud835\udcd5.FieldOpFreeAlgebra) :\n    bosonicProj (\u03b9 a) = bosonicProjFree a := rfl\n\n/-!\n\n## Defining fermionicProj\n\n-/\n\n/-- The projection of `\ud835\udcd5.FieldOpFreeAlgebra` to `statSubmodule (\ud835\udcd5 := \ud835\udcd5) fermionic`. -/\ndef fermionicProjFree : \ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102] statSubmodule (\ud835\udcd5 := \ud835\udcd5) fermionic :=\n  \u03b9StateSubmodule .fermionic \u2218\u2097 fermionicProjF\n\nlemma fermionicProjFree_eq_\u03b9_fermionicProjF (a : \ud835\udcd5.FieldOpFreeAlgebra) :\n    (fermionicProjFree a).1 = \u03b9 (fermionicProjF a) := rfl\n\n", "theoremStatement": "lemma fermionicProjFree_zero_of_\u03b9_zero (a : \ud835\udcd5.FieldOpFreeAlgebra) (h : \u03b9 a = 0) :\n    fermionicProjFree a = 0 ", "theoremName": "FieldSpecification.FieldOpAlgebra.fermionicProjFree_zero_of_\u03b9_zero", "fileCreated": {"commit": "7d9e6af80c57599f68481948604d9f0aaba4a40f", "date": "2025-02-05"}, "theoremCreated": {"commit": "7d9e6af80c57599f68481948604d9f0aaba4a40f", "date": "2025-02-05"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpAlgebra/Grading.lean", "module": "HepLean.PerturbationTheory.FieldOpAlgebra.Grading", "jsonFile": "HepLean.PerturbationTheory.FieldOpAlgebra.Grading.jsonl", "positionMetadata": {"lineInFile": 150, "tokenPositionInFile": 5147, "theoremPositionInFile": 13}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 15, "numPremises": 72}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [\u03b9_eq_zero_iff_\u03b9_bosonicProjF_fermonicProj_zero] at h\n  apply Subtype.eq\n  rw [fermionicProjFree_eq_\u03b9_fermionicProjF]\n  exact h.2", "proofType": "tactic", "proofLengthLines": 4, "proofLengthTokens": 140}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpAlgebra.NormalOrder.Basic\n/-!\n\n# Basic properties of normal ordering\n\n-/\n\nnamespace FieldSpecification\nopen FieldOpFreeAlgebra\nopen HepLean.List\nopen FieldStatistic\n\nnamespace FieldOpAlgebra\nvariable {\ud835\udcd5 : FieldSpecification}\n\n/-!\n\n## Properties of normal ordering.\n\n-/\n\nlemma normalOrder_eq_\u03b9_normalOrderF (a : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \ud835\udcdd(\u03b9 a) = \u03b9 \ud835\udcdd\u1da0(a) := rfl\n\nlemma normalOrder_ofCrAnList (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    \ud835\udcdd(ofCrAnList \u03c6s) = normalOrderSign \u03c6s \u2022 ofCrAnList (normalOrderList \u03c6s) := by\n  rw [ofCrAnList, normalOrder_eq_\u03b9_normalOrderF, normalOrderF_ofCrAnListF]\n  rfl\n\n@[simp]\nlemma normalOrder_one_eq_one : normalOrder (\ud835\udcd5 := \ud835\udcd5) 1 = 1 := by\n  have h1 : 1 = ofCrAnList (\ud835\udcd5 := \ud835\udcd5) [] := by simp [ofCrAnList]\n  rw [h1]\n  rw [normalOrder_ofCrAnList]\n  simp\n\n@[simp]\nlemma normalOrder_ofFieldOpList_nil : normalOrder (\ud835\udcd5 := \ud835\udcd5) (ofFieldOpList []) = 1 := by\n  rw [ofFieldOpList]\n  rw [normalOrder_eq_\u03b9_normalOrderF]\n  simp only [ofFieldOpListF_nil]\n  change normalOrder (\ud835\udcd5 := \ud835\udcd5) 1 = _\n  simp\n\n@[simp]\nlemma normalOrder_ofCrAnList_nil : normalOrder (\ud835\udcd5 := \ud835\udcd5) (ofCrAnList []) = 1 := by\n  rw [normalOrder_ofCrAnList]\n  simp only [normalOrderSign_nil, normalOrderList_nil, one_smul]\n  rfl\n\nlemma ofCrAnList_eq_normalOrder (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnList (normalOrderList \u03c6s) = normalOrderSign \u03c6s \u2022 \ud835\udcdd(ofCrAnList \u03c6s) := by\n  rw [normalOrder_ofCrAnList, smul_smul, normalOrderSign, Wick.koszulSign_mul_self,\n    one_smul]\n\nlemma normalOrder_normalOrder_mid (a b c : \ud835\udcd5.FieldOpAlgebra) :\n    \ud835\udcdd(a * b * c) = \ud835\udcdd(a * \ud835\udcdd(b) * c) := by\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n  obtain \u27e8c, rfl\u27e9 := \u03b9_surjective c\n  rw [normalOrder_eq_\u03b9_normalOrderF]\n  simp only [\u2190 map_mul]\n  rw [normalOrder_eq_\u03b9_normalOrderF]\n  rw [normalOrderF_normalOrderF_mid]\n  rfl\n\nlemma normalOrder_normalOrder_left (a b : \ud835\udcd5.FieldOpAlgebra) :\n    \ud835\udcdd(a * b) = \ud835\udcdd(\ud835\udcdd(a) * b) := by\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n  rw [normalOrder_eq_\u03b9_normalOrderF]\n  simp only [\u2190 map_mul]\n  rw [normalOrder_eq_\u03b9_normalOrderF]\n  rw [normalOrderF_normalOrderF_left]\n  rfl\n\nlemma normalOrder_normalOrder_right (a b : \ud835\udcd5.FieldOpAlgebra) :\n    \ud835\udcdd(a * b) = \ud835\udcdd(a * \ud835\udcdd(b)) := by\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n  rw [normalOrder_eq_\u03b9_normalOrderF]\n  simp only [\u2190 map_mul]\n  rw [normalOrder_eq_\u03b9_normalOrderF]\n  rw [normalOrderF_normalOrderF_right]\n  rfl\n\nlemma normalOrder_normalOrder (a : \ud835\udcd5.FieldOpAlgebra) : \ud835\udcdd(\ud835\udcdd(a)) = \ud835\udcdd(a) := by\n  trans \ud835\udcdd(\ud835\udcdd(a) * 1)\n  \u00b7 simp\n  \u00b7 rw [\u2190 normalOrder_normalOrder_left]\n    simp\n\n/-!\n\n## mul anpart and crpart\n-/\n\nlemma normalOrder_mul_anPart (\u03c6 : \ud835\udcd5.FieldOp) (a : \ud835\udcd5.FieldOpAlgebra) :\n    \ud835\udcdd(a * anPart \u03c6) = \ud835\udcdd(a) * anPart \u03c6 := by\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  rw [anPart, \u2190 map_mul, normalOrder_eq_\u03b9_normalOrderF, normalOrderF_mul_anPartF]\n  rfl\n\nlemma crPart_mul_normalOrder (\u03c6 : \ud835\udcd5.FieldOp) (a : \ud835\udcd5.FieldOpAlgebra) :\n    \ud835\udcdd(crPart \u03c6 * a) = crPart \u03c6 * \ud835\udcdd(a) := by\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  rw [crPart, \u2190 map_mul, normalOrder_eq_\u03b9_normalOrderF, normalOrderF_crPartF_mul]\n  rfl\n\n/-!\n\n### Normal order and super commutes\n\n-/\n\n", "theoremStatement": "/-- For a field specification `\ud835\udcd5`, and `a` and `b` in `\ud835\udcd5.FieldOpAlgebra` the normal ordering\n  of the super commutator of `a` and `b` vanishes, i.e. `\ud835\udcdd([a,b]\u209b) = 0`. -/\n@[simp]\nlemma normalOrder_superCommute_eq_zero (a b : \ud835\udcd5.FieldOpAlgebra) :\n    \ud835\udcdd([a, b]\u209b) = 0 ", "theoremName": "FieldSpecification.FieldOpAlgebra.normalOrder_superCommute_eq_zero", "fileCreated": {"commit": "2e82f842a242717b98517656fc34b1b92f579b2e", "date": "2025-02-05"}, "theoremCreated": {"commit": "c9607c459f71be528cf35463d49a47013a33b0e3", "date": "2025-02-07"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpAlgebra/NormalOrder/Lemmas.lean", "module": "HepLean.PerturbationTheory.FieldOpAlgebra.NormalOrder.Lemmas", "jsonFile": "HepLean.PerturbationTheory.FieldOpAlgebra.NormalOrder.Lemmas.jsonl", "positionMetadata": {"lineInFile": 121, "tokenPositionInFile": 3324, "theoremPositionInFile": 12}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 14, "numPremises": 76}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n  rw [superCommute_eq_\u03b9_superCommuteF, normalOrder_eq_\u03b9_normalOrderF]\n  simp", "proofType": "tactic", "proofLengthLines": 4, "proofLengthTokens": 154}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.WickContraction.TimeContract\nimport HepLean.PerturbationTheory.WickContraction.StaticContract\nimport HepLean.PerturbationTheory.FieldOpAlgebra.TimeContraction\n/-!\n\n# Sub contractions\n\n-/\n\nopen FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\nnamespace WickContraction\nvariable {n : \u2115} {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\nopen HepLean.List\nopen FieldOpAlgebra\n\n/-- Given a Wick contraction `\u03c6s\u039b`, and a subset of `\u03c6s\u039b.1`, the Wick contraction\n  consisting of contracted pairs within that subset. -/\ndef subContraction (S : Finset (Finset (Fin \u03c6s.length))) (ha : S \u2286 \u03c6s\u039b.1) :\n    WickContraction \u03c6s.length :=\n  \u27e8S, by\n    intro i hi\n    exact \u03c6s\u039b.2.1 i (ha hi),\n    by\n    intro i hi j hj\n    exact \u03c6s\u039b.2.2 i (ha hi) j (ha hj)\u27e9\n\nlemma mem_of_mem_subContraction {S : Finset (Finset (Fin \u03c6s.length))} {hs : S \u2286 \u03c6s\u039b.1}\n    {a : Finset (Fin \u03c6s.length)} (ha : a \u2208 (\u03c6s\u039b.subContraction S hs).1) : a \u2208 \u03c6s\u039b.1 := by\n  exact hs ha\n\n/-- Given a Wick contraction `\u03c6s\u039b`, and a subset `S` of `\u03c6s\u039b.1`, the Wick contraction\n  on the uncontracted list `[\u03c6s\u039b.subContraction S ha]\u1d58\u1d9c`\n  consisting of the remaining contracted pairs of `\u03c6s\u039b` not in `S`. -/\ndef quotContraction (S : Finset (Finset (Fin \u03c6s.length))) (ha : S \u2286 \u03c6s\u039b.1) :\n    WickContraction [\u03c6s\u039b.subContraction S ha]\u1d58\u1d9c.length :=\n  \u27e8Finset.filter (fun a => Finset.map uncontractedListEmd a \u2208 \u03c6s\u039b.1) Finset.univ,\n  by\n    intro a ha'\n    simp only [Finset.mem_filter, Finset.mem_univ, true_and] at ha'\n    simpa using \u03c6s\u039b.2.1 (Finset.map uncontractedListEmd a) ha', by\n  intro a ha b hb\n  simp only [Finset.mem_filter, Finset.mem_univ, true_and] at ha hb\n  by_cases hab : a = b\n  \u00b7 simp [hab]\n  \u00b7 simp only [hab, false_or]\n    have hx := \u03c6s\u039b.2.2 (Finset.map uncontractedListEmd a) ha (Finset.map uncontractedListEmd b) hb\n    simp_all\u27e9\n\nlemma mem_of_mem_quotContraction {S : Finset (Finset (Fin \u03c6s.length))} {hs : S \u2286 \u03c6s\u039b.1}\n    {a : Finset (Fin [\u03c6s\u039b.subContraction S hs]\u1d58\u1d9c.length)}\n    (ha : a \u2208 (quotContraction S hs).1) : Finset.map uncontractedListEmd a \u2208 \u03c6s\u039b.1 := by\n  simp only [quotContraction, Finset.mem_filter, Finset.mem_univ, true_and] at ha\n  exact ha\n\nlemma mem_subContraction_or_quotContraction {S : Finset (Finset (Fin \u03c6s.length))} {hs : S \u2286 \u03c6s\u039b.1}\n    {a : Finset (Fin \u03c6s.length)} (ha : a \u2208 \u03c6s\u039b.1) :\n    a \u2208 (\u03c6s\u039b.subContraction S hs).1 \u2228\n    \u2203 a', Finset.map uncontractedListEmd a' = a \u2227 a' \u2208 (quotContraction S hs).1 := by\n  by_cases h1 : a \u2208 (\u03c6s\u039b.subContraction S hs).1\n  \u00b7 simp [h1]\n  simp only [h1, false_or]\n  simp only [subContraction] at h1\n  have h2 := \u03c6s\u039b.2.1 a ha\n  rw [@Finset.card_eq_two] at h2\n  obtain \u27e8i, j, hij, rfl\u27e9 := h2\n  have hi : i \u2208 (\u03c6s\u039b.subContraction S hs).uncontracted := by\n    rw [mem_uncontracted_iff_not_contracted]\n    intro p hp\n    have hp' : p \u2208 \u03c6s\u039b.1 := hs hp\n    have hp2 := \u03c6s\u039b.2.2 p hp' {i, j} ha\n    simp only [subContraction] at hp\n    rcases hp2 with hp2 | hp2\n    \u00b7 simp_all\n    simp only [Finset.disjoint_insert_right, Finset.disjoint_singleton_right] at hp2\n    exact hp2.1\n  have hj : j \u2208 (\u03c6s\u039b.subContraction S hs).uncontracted := by\n    rw [mem_uncontracted_iff_not_contracted]\n    intro p hp\n    have hp' : p \u2208 \u03c6s\u039b.1 := hs hp\n    have hp2 := \u03c6s\u039b.2.2 p hp' {i, j} ha\n    simp only [subContraction] at hp\n    rcases hp2 with hp2 | hp2\n    \u00b7 simp_all\n    simp only [Finset.disjoint_insert_right, Finset.disjoint_singleton_right] at hp2\n    exact hp2.2\n  obtain \u27e8i, rfl\u27e9 := uncontractedListEmd_surjective_mem_uncontracted i hi\n  obtain \u27e8j, rfl\u27e9 := uncontractedListEmd_surjective_mem_uncontracted j hj\n  use {i, j}\n  simp only [Finset.map_insert, Finset.map_singleton, quotContraction, Finset.mem_filter,\n    Finset.mem_univ, true_and]\n  exact ha\n\n@[simp]\nlemma subContraction_uncontractedList_get {S : Finset (Finset (Fin \u03c6s.length))} {hs : S \u2286 \u03c6s\u039b.1}\n    {a : Fin [subContraction S hs]\u1d58\u1d9c.length} :\n    [subContraction S hs]\u1d58\u1d9c[a] = \u03c6s[uncontractedListEmd a] := by\n  erw [\u2190 getElem_uncontractedListEmd]\n  rfl\n\n@[simp]\nlemma subContraction_fstFieldOfContract {S : Finset (Finset (Fin \u03c6s.length))} {hs : S \u2286 \u03c6s\u039b.1}\n    (a : (subContraction S hs).1) :\n    (subContraction S hs).fstFieldOfContract a =\n    \u03c6s\u039b.fstFieldOfContract \u27e8a.1, mem_of_mem_subContraction a.2\u27e9:= by\n  apply eq_fstFieldOfContract_of_mem _ _ _\n    (\u03c6s\u039b.sndFieldOfContract \u27e8a.1, mem_of_mem_subContraction a.2\u27e9)\n  \u00b7 have ha := finset_eq_fstFieldOfContract_sndFieldOfContract _\n      \u27e8a.1, mem_of_mem_subContraction a.2\u27e9\n    simp only at ha\n    conv_lhs =>\n      rw [ha]\n    simp\n  \u00b7 have ha := finset_eq_fstFieldOfContract_sndFieldOfContract _\n      \u27e8a.1, mem_of_mem_subContraction a.2\u27e9\n    simp only at ha\n    conv_lhs =>\n      rw [ha]\n    simp\n  \u00b7 exact fstFieldOfContract_lt_sndFieldOfContract \u03c6s\u039b \u27e8\u2191a, mem_of_mem_subContraction a.property\u27e9\n\n@[simp]\nlemma subContraction_sndFieldOfContract {S : Finset (Finset (Fin \u03c6s.length))} {hs : S \u2286 \u03c6s\u039b.1}\n    (a : (subContraction S hs).1) :\n    (subContraction S hs).sndFieldOfContract a =\n    \u03c6s\u039b.sndFieldOfContract \u27e8a.1, mem_of_mem_subContraction a.2\u27e9:= by\n  apply eq_sndFieldOfContract_of_mem _ _\n    (\u03c6s\u039b.fstFieldOfContract \u27e8a.1, mem_of_mem_subContraction a.2\u27e9)\n  \u00b7 have ha := finset_eq_fstFieldOfContract_sndFieldOfContract _\n      \u27e8a.1, mem_of_mem_subContraction a.2\u27e9\n    simp only at ha\n    conv_lhs =>\n      rw [ha]\n    simp\n  \u00b7 have ha := finset_eq_fstFieldOfContract_sndFieldOfContract _\n      \u27e8a.1, mem_of_mem_subContraction a.2\u27e9\n    simp only at ha\n    conv_lhs =>\n      rw [ha]\n    simp\n  \u00b7 exact fstFieldOfContract_lt_sndFieldOfContract \u03c6s\u039b \u27e8\u2191a, mem_of_mem_subContraction a.property\u27e9\n\n", "theoremStatement": "@[simp]\nlemma quotContraction_fstFieldOfContract_uncontractedListEmd {S : Finset (Finset (Fin \u03c6s.length))}\n    {hs : S \u2286 \u03c6s\u039b.1} (a : (quotContraction S hs).1) :\n    uncontractedListEmd ((quotContraction S hs).fstFieldOfContract a) =\n    (\u03c6s\u039b.fstFieldOfContract\n    \u27e8Finset.map uncontractedListEmd a.1, mem_of_mem_quotContraction a.2\u27e9) ", "theoremName": "WickContraction.quotContraction_fstFieldOfContract_uncontractedListEmd", "fileCreated": {"commit": "12d36dc1d9c726c035301091e57be0b29015e4ae", "date": "2025-01-31"}, "theoremCreated": {"commit": "12d36dc1d9c726c035301091e57be0b29015e4ae", "date": "2025-01-31"}, "file": "HepLean/HepLean/PerturbationTheory/WickContraction/SubContraction.lean", "module": "HepLean.PerturbationTheory.WickContraction.SubContraction", "jsonFile": "HepLean.PerturbationTheory.WickContraction.SubContraction.jsonl", "positionMetadata": {"lineInFile": 149, "tokenPositionInFile": 5722, "theoremPositionInFile": 8}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 15, "numPremises": 48}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  symm\n  apply eq_fstFieldOfContract_of_mem _ _ _\n    (uncontractedListEmd ((quotContraction S hs).sndFieldOfContract a))\n  \u00b7 simp only [Finset.mem_map', fstFieldOfContract_mem]\n  \u00b7 simp\n  \u00b7 apply uncontractedListEmd_strictMono\n    exact fstFieldOfContract_lt_sndFieldOfContract (quotContraction S hs) a", "proofType": "tactic", "proofLengthLines": 7, "proofLengthTokens": 309}}
{"srcContext": "/-\nCopyright (c) 2024 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.Mathematics.List\n/-!\n# List lemmas\n\n-/\nnamespace HepLean.List\n\nopen Fin\nopen HepLean\nvariable {n : Nat}\n\nlemma insertIdx_map {I J : Type} (f : I \u2192 J) : (i : \u2115) \u2192 (r : List I) \u2192 (r0 : I) \u2192\n    (List.insertIdx i r0 r).map f = List.insertIdx i (f r0) (r.map f)\n  | 0, [], r0 => by simp\n  | n+1, [], r0 => by simp\n  | 0, a::as, r0 => by simp\n  | n+1, a::as, r0 => by\n    simp only [List.insertIdx_succ_cons, List.map_cons, List.cons.injEq, true_and]\n    exact insertIdx_map f n as r0\n\nlemma eraseIdx_sorted {I : Type} (le : I \u2192 I \u2192 Prop) :\n    (r : List I) \u2192 (n : \u2115) \u2192\n    List.Sorted le r \u2192 List.Sorted le (r.eraseIdx n)\n  | [], _, _ => by simp\n  | a::as, 0, h => by\n    simp only [List.eraseIdx]\n    simp only [List.sorted_cons] at h\n    exact h.2\n  | a::as, n+1, h => by\n    simp only [List.eraseIdx_cons_succ, List.sorted_cons]\n    simp only [List.sorted_cons] at h\n    refine And.intro ?_ (eraseIdx_sorted le as n h.2)\n    intro b hb\n    refine h.1 _ ?_\n    exact List.mem_of_mem_eraseIdx hb\n\nlemma mem_eraseIdx_nodup {I : Type} (i : I) :\n    (l : List I) \u2192 (n : \u2115) \u2192 (hn : n < l.length) \u2192 (h : List.Nodup l) \u2192\n    i \u2208 l.eraseIdx n \u2194 i \u2208 l \u2227 i \u2260 l[n]\n  | [], _, _, _ => by simp\n  | a1 :: as, 0, _, h => by\n    simp only [List.eraseIdx_zero, List.tail_cons, List.mem_cons, List.getElem_cons_zero, ne_eq]\n    by_cases hi : i = a1\n    \u00b7 subst hi\n      simp only [List.nodup_cons] at h\n      simp [h]\n    \u00b7 simp [hi]\n  | a1 :: as, n+1, hn, h => by\n    simp only [List.eraseIdx_cons_succ, List.mem_cons, List.getElem_cons_succ, ne_eq]\n    simp only [List.nodup_cons] at h\n    rw [mem_eraseIdx_nodup i as n (Nat.succ_lt_succ_iff.mp hn) h.2]\n    simp_all only [ne_eq]\n    obtain \u27e8left, right\u27e9 := h\n    apply Iff.intro\n    \u00b7 intro a\n      cases a with\n      | inl h =>\n        subst h\n        simp_all only [or_false, true_and]\n        apply Aesop.BuiltinRules.not_intro\n        intro a\n        simp_all only [List.getElem_mem, not_true_eq_false]\n      | inr h_1 => simp_all only [or_true, not_false_eq_true, and_self]\n    \u00b7 intro a\n      simp_all only [not_false_eq_true, and_true]\n\nlemma insertIdx_eq_take_drop {I : Type} (i : I) : (r : List I) \u2192 (n : Fin r.length.succ) \u2192\n    List.insertIdx n i r = List.take n r ++ i :: r.drop n\n  | [], 0 => by simp\n  | a :: as, 0 => by\n    simp\n  | a :: as, \u27e8n + 1, h\u27e9 => by\n    simp only [List.insertIdx_succ_cons, List.take_succ_cons, List.drop_succ_cons, List.cons_append,\n      List.cons.injEq, true_and]\n    exact insertIdx_eq_take_drop i as \u27e8n, Nat.succ_lt_succ_iff.mp h\u27e9\n\n@[simp]\nlemma insertIdx_length_fin {I : Type} (i : I) :\n    (r : List I) \u2192 (n : Fin r.length.succ) \u2192\n    (List.insertIdx n i r).length = r.length.succ\n  | [], 0 => by simp\n  | a :: as, 0 => by simp\n  | a :: as, \u27e8n + 1, h\u27e9 => by\n    simp only [List.insertIdx_succ_cons, List.length_cons, Nat.succ_eq_add_one, add_left_inj]\n    exact insertIdx_length_fin i as \u27e8n, Nat.succ_lt_succ_iff.mp h\u27e9\n\n@[simp]\nlemma insertIdx_getElem_fin {I : Type} (i : I) :\n    (r : List I) \u2192 (k : Fin r.length.succ) \u2192 (m : Fin r.length) \u2192\n    (List.insertIdx k i r)[(k.succAbove m).val] = r[m.val]\n  | [], 0, m => by exact Fin.elim0 m\n  | a :: as, 0, m => by simp\n  | a :: as, \u27e8n + 1, h\u27e9, \u27e80, h0\u27e9 => by\n    simp [Fin.succAbove, Fin.lt_def]\n  | a :: as, \u27e8n + 1, h\u27e9, \u27e8m+1, hm\u27e9 => by\n    simp only [List.insertIdx_succ_cons, List.length_cons, Nat.succ_eq_add_one,\n      List.getElem_cons_succ]\n    conv_rhs => rw [\u2190 insertIdx_getElem_fin i as \u27e8n, Nat.succ_lt_succ_iff.mp h\u27e9\n      \u27e8m, Nat.lt_of_succ_lt_succ hm\u27e9]\n    simp only [Fin.succAbove, Fin.castSucc_mk, Fin.lt_def, add_lt_add_iff_right, Fin.succ_mk,\n      Nat.succ_eq_add_one]\n    split\n    \u00b7 simp_all only [List.getElem_cons_succ]\n    \u00b7 simp_all only [List.getElem_cons_succ]\n\nlemma insertIdx_eraseIdx_fin {I : Type} :\n    (r : List I) \u2192 (k : Fin r.length) \u2192\n    (List.eraseIdx r k).insertIdx k r[k] = r\n  | [], k => by exact Fin.elim0 k\n  | a :: as, \u27e80, h\u27e9 => by simp\n  | a :: as, \u27e8n + 1, h\u27e9 => by\n    simp only [List.length_cons, Fin.getElem_fin, List.getElem_cons_succ, List.eraseIdx_cons_succ,\n      List.insertIdx_succ_cons, List.cons.injEq, true_and]\n    exact insertIdx_eraseIdx_fin as \u27e8n, Nat.lt_of_succ_lt_succ h\u27e9\n\nlemma insertIdx_length_fst_append {I : Type} (\u03c6 : I) : (\u03c6s \u03c6s' : List I) \u2192\n    List.insertIdx \u03c6s.length \u03c6 (\u03c6s ++ \u03c6s') = (\u03c6s ++ \u03c6 :: \u03c6s')\n  | [], \u03c6s' => by simp\n  | \u03c6' :: \u03c6s, \u03c6s' => by\n    simp only [List.length_cons, List.cons_append, List.insertIdx_succ_cons, List.cons.injEq,\n      true_and]\n    exact insertIdx_length_fst_append \u03c6 \u03c6s \u03c6s'\n\n", "theoremStatement": "lemma get_eq_insertIdx_succAbove {I : Type} (i : I) (r : List I) (k : Fin r.length.succ) :\n    r.get = (List.insertIdx k i r).get \u2218\n    (finCongr (insertIdx_length_fin i r k).symm) \u2218 k.succAbove ", "theoremName": "HepLean.List.get_eq_insertIdx_succAbove", "fileCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "theoremCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "file": "HepLean/HepLean/Mathematics/List/InsertIdx.lean", "module": "HepLean.Mathematics.List.InsertIdx", "jsonFile": "HepLean.Mathematics.List.InsertIdx.jsonl", "positionMetadata": {"lineInFile": 129, "tokenPositionInFile": 4682, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 42}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  funext i\n  simp", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 23}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.WickContraction.TimeContract\nimport HepLean.PerturbationTheory.WickContraction.StaticContract\nimport HepLean.PerturbationTheory.FieldOpAlgebra.TimeContraction\nimport HepLean.PerturbationTheory.WickContraction.SubContraction\nimport HepLean.PerturbationTheory.WickContraction.Singleton\n\n/-!\n\n# Join of contractions\n\n-/\n\nopen FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\nnamespace WickContraction\nvariable {n : \u2115} (c : WickContraction n)\nopen HepLean.List\nopen FieldOpAlgebra\n\n/-- Given a list `\u03c6s` of `\ud835\udcd5.FieldOp`, a Wick contraction `\u03c6s\u039b` of `\u03c6s` and a Wick contraction\n  `\u03c6suc\u039b` of `[\u03c6s\u039b]\u1d58\u1d9c`, `join \u03c6s\u039b \u03c6suc\u039b` is defined as the Wick contraction of `\u03c6s` consisting of\n  the contractions in `\u03c6s\u039b` and those in `\u03c6suc\u039b`.\n\n  As an example, for `\u03c6s = [\u03c61, \u03c62, \u03c63, \u03c64]`,\n  `\u03c6s\u039b = {{0, 1}}` corresponding to the contraction of `\u03c61` and `\u03c62` in `\u03c6s` and\n  `\u03c6suc\u039b = {{0, 1}}`\n  corresponding to the contraction of `\u03c63` and `\u03c64` in `[\u03c6s\u039b]\u1d58\u1d9c = [\u03c63, \u03c64]`, then\n  `join \u03c6s\u039b \u03c6suc\u039b` is the contraction `{{0, 1}, {2, 3}}` of `\u03c6s`. -/\ndef join {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) : WickContraction \u03c6s.length :=\n  \u27e8\u03c6s\u039b.1 \u222a \u03c6suc\u039b.1.map (Finset.mapEmbedding uncontractedListEmd).toEmbedding, by\n    intro a ha\n    simp only [Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,\n      RelEmbedding.coe_toEmbedding] at ha\n    rcases ha with ha | ha\n    \u00b7 exact \u03c6s\u039b.2.1 a ha\n    \u00b7 obtain \u27e8a, ha, rfl\u27e9 := ha\n      rw [Finset.mapEmbedding_apply]\n      simp only [Finset.card_map]\n      exact \u03c6suc\u039b.2.1 a ha, by\n    intro a ha b hb\n    simp only [Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,\n      RelEmbedding.coe_toEmbedding] at ha hb\n    rcases ha with ha | ha <;> rcases hb with hb | hb\n    \u00b7 exact \u03c6s\u039b.2.2 a ha b hb\n    \u00b7 obtain \u27e8b, hb, rfl\u27e9 := hb\n      right\n      symm\n      rw [Finset.mapEmbedding_apply]\n      apply uncontractedListEmd_finset_disjoint_left\n      exact ha\n    \u00b7 obtain \u27e8a, ha, rfl\u27e9 := ha\n      right\n      rw [Finset.mapEmbedding_apply]\n      apply uncontractedListEmd_finset_disjoint_left\n      exact hb\n    \u00b7 obtain \u27e8a, ha, rfl\u27e9 := ha\n      obtain \u27e8b, hb, rfl\u27e9 := hb\n      simp only [EmbeddingLike.apply_eq_iff_eq]\n      rw [Finset.mapEmbedding_apply, Finset.mapEmbedding_apply]\n      rw [Finset.disjoint_map]\n      exact \u03c6suc\u039b.2.2 a ha b hb\u27e9\n\nlemma join_congr {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} {\u03c6s\u039b' : WickContraction \u03c6s.length}\n    (h1 : \u03c6s\u039b = \u03c6s\u039b') :\n    join \u03c6s\u039b \u03c6suc\u039b = join \u03c6s\u039b' (congr (by simp [h1]) \u03c6suc\u039b) := by\n  subst h1\n  rfl\n\n/-- Given a contracting pair within `\u03c6s\u039b` the corresponding contracting pair within\n  `(join \u03c6s\u039b \u03c6suc\u039b)`. -/\ndef joinLiftLeft {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} : \u03c6s\u039b.1 \u2192 (join \u03c6s\u039b \u03c6suc\u039b).1 :=\n  fun a => \u27e8a, by simp [join]\u27e9\n\nlemma jointLiftLeft_injective {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} :\n    Function.Injective (@joinLiftLeft _ _ \u03c6s\u039b \u03c6suc\u039b) := by\n  intro a b h\n  simp only [joinLiftLeft] at h\n  rw [Subtype.mk_eq_mk] at h\n  refine Subtype.eq h\n\n/-- Given a contracting pair within `\u03c6suc\u039b` the corresponding contracting pair within\n  `(join \u03c6s\u039b \u03c6suc\u039b)`. -/\ndef joinLiftRight {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} : \u03c6suc\u039b.1 \u2192 (join \u03c6s\u039b \u03c6suc\u039b).1 :=\n  fun a => \u27e8a.1.map uncontractedListEmd, by\n    simp only [join, Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,\n      RelEmbedding.coe_toEmbedding]\n    right\n    use a.1\n    simp only [Finset.coe_mem, true_and]\n    rfl\u27e9\n\nlemma joinLiftRight_injective {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} :\n    Function.Injective (@joinLiftRight _ _ \u03c6s\u039b \u03c6suc\u039b) := by\n  intro a b h\n  simp only [joinLiftRight] at h\n  rw [Subtype.mk_eq_mk] at h\n  simp only [Finset.map_inj] at h\n  refine Subtype.eq h\n\nlemma jointLiftLeft_disjoint_joinLiftRight {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} (a : \u03c6s\u039b.1) (b : \u03c6suc\u039b.1) :\n    Disjoint (@joinLiftLeft _ _ _ \u03c6suc\u039b a).1 (joinLiftRight b).1 := by\n  simp only [joinLiftLeft, joinLiftRight]\n  symm\n  apply uncontractedListEmd_finset_disjoint_left\n  exact a.2\n\nlemma jointLiftLeft_neq_joinLiftRight {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} (a : \u03c6s\u039b.1) (b : \u03c6suc\u039b.1) :\n    joinLiftLeft a \u2260 joinLiftRight b := by\n  by_contra hn\n  have h1 := jointLiftLeft_disjoint_joinLiftRight a b\n  rw [hn] at h1\n  simp only [disjoint_self, Finset.bot_eq_empty] at h1\n  have hj := (join \u03c6s\u039b \u03c6suc\u039b).2.1 (joinLiftRight b).1 (joinLiftRight b).2\n  rw [h1] at hj\n  simp at hj\n\n/-- The map from contracted pairs of `\u03c6s\u039b` and `\u03c6suc\u039b` to contracted pairs in\n  `(join \u03c6s\u039b \u03c6suc\u039b)`. -/\ndef joinLift {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} : \u03c6s\u039b.1 \u2295 \u03c6suc\u039b.1 \u2192 (join \u03c6s\u039b \u03c6suc\u039b).1 := fun a =>\n  match a with\n  | Sum.inl a => joinLiftLeft a\n  | Sum.inr a => joinLiftRight a\n\nlemma joinLift_injective {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} : Function.Injective (@joinLift _ _ \u03c6s\u039b \u03c6suc\u039b) := by\n  intro a b h\n  match a, b with\n  | Sum.inl a, Sum.inl b =>\n    simp only [Sum.inl.injEq]\n    exact jointLiftLeft_injective h\n  | Sum.inr a, Sum.inr b =>\n    simp only [Sum.inr.injEq]\n    exact joinLiftRight_injective h\n  | Sum.inl a, Sum.inr b =>\n    simp only [joinLift] at h\n    have h1 := jointLiftLeft_neq_joinLiftRight a b\n    simp_all\n  | Sum.inr a, Sum.inl b =>\n    simp only [joinLift] at h\n    have h1 := jointLiftLeft_neq_joinLiftRight b a\n    simp_all\n\nlemma joinLift_surjective {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} : Function.Surjective (@joinLift _ _ \u03c6s\u039b \u03c6suc\u039b) := by\n  intro a\n  have ha2 := a.2\n  simp only [join, Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,\n    RelEmbedding.coe_toEmbedding] at ha2\n  rcases ha2 with ha2 | \u27e8a2, ha3\u27e9\n  \u00b7 use Sum.inl \u27e8a, ha2\u27e9\n    simp [joinLift, joinLiftLeft]\n  \u00b7 rw [Finset.mapEmbedding_apply] at ha3\n    use Sum.inr \u27e8a2, ha3.1\u27e9\n    simp only [joinLift, joinLiftRight]\n    refine Subtype.eq ?_\n    exact ha3.2\n\nlemma joinLift_bijective {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} : Function.Bijective (@joinLift _ _ \u03c6s\u039b \u03c6suc\u039b) := by\n  apply And.intro\n  \u00b7 exact joinLift_injective\n  \u00b7 exact joinLift_surjective\n\nlemma prod_join {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) (f : (join \u03c6s\u039b \u03c6suc\u039b).1 \u2192 M) [CommMonoid M]:\n      \u220f (a : (join \u03c6s\u039b \u03c6suc\u039b).1), f a = (\u220f (a : \u03c6s\u039b.1), f (joinLiftLeft a)) *\n      \u220f (a : \u03c6suc\u039b.1), f (joinLiftRight a) := by\n  let e1 := Equiv.ofBijective (@joinLift _ _ \u03c6s\u039b \u03c6suc\u039b) joinLift_bijective\n  rw [\u2190 e1.prod_comp]\n  simp only [Fintype.prod_sum_type, Finset.univ_eq_attach]\n  rfl\n\nlemma joinLiftLeft_or_joinLiftRight_of_mem_join {\u03c6s : List \ud835\udcd5.FieldOp}\n    (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) {a : Finset (Fin \u03c6s.length)}\n    (ha : a \u2208 (join \u03c6s\u039b \u03c6suc\u039b).1) :\n    (\u2203 b, a = (joinLiftLeft (\u03c6suc\u039b := \u03c6suc\u039b) b).1) \u2228\n    (\u2203 b, a = (joinLiftRight (\u03c6suc\u039b := \u03c6suc\u039b) b).1) := by\n  simp only [join, Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,\n    RelEmbedding.coe_toEmbedding] at ha\n  rcases ha with ha | \u27e8a, ha, rfl\u27e9\n  \u00b7 left\n    use \u27e8a, ha\u27e9\n    rfl\n  \u00b7 right\n    use \u27e8a, ha\u27e9\n    rfl\n\n@[simp]\nlemma join_fstFieldOfContract_joinLiftRight {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) (a : \u03c6suc\u039b.1) :\n    (join \u03c6s\u039b \u03c6suc\u039b).fstFieldOfContract (joinLiftRight a) =\n    uncontractedListEmd (\u03c6suc\u039b.fstFieldOfContract a) := by\n  apply eq_fstFieldOfContract_of_mem _ _ _ (uncontractedListEmd (\u03c6suc\u039b.sndFieldOfContract a))\n  \u00b7 simp [joinLiftRight]\n  \u00b7 simp [joinLiftRight]\n  \u00b7 apply uncontractedListEmd_strictMono\n    exact fstFieldOfContract_lt_sndFieldOfContract \u03c6suc\u039b a\n\n@[simp]\nlemma join_sndFieldOfContract_joinLiftRight {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) (a : \u03c6suc\u039b.1) :\n    (join \u03c6s\u039b \u03c6suc\u039b).sndFieldOfContract (joinLiftRight a) =\n    uncontractedListEmd (\u03c6suc\u039b.sndFieldOfContract a) := by\n  apply eq_sndFieldOfContract_of_mem _ _ (uncontractedListEmd (\u03c6suc\u039b.fstFieldOfContract a))\n  \u00b7 simp [joinLiftRight]\n  \u00b7 simp [joinLiftRight]\n  \u00b7 apply uncontractedListEmd_strictMono\n    exact fstFieldOfContract_lt_sndFieldOfContract \u03c6suc\u039b a\n\n", "theoremStatement": "@[simp]\nlemma join_fstFieldOfContract_joinLiftLeft {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) (a : \u03c6s\u039b.1) :\n    (join \u03c6s\u039b \u03c6suc\u039b).fstFieldOfContract (joinLiftLeft a) =\n    (\u03c6s\u039b.fstFieldOfContract a) ", "theoremName": "WickContraction.join_fstFieldOfContract_joinLiftLeft", "fileCreated": {"commit": "12d36dc1d9c726c035301091e57be0b29015e4ae", "date": "2025-01-31"}, "theoremCreated": {"commit": "12d36dc1d9c726c035301091e57be0b29015e4ae", "date": "2025-01-31"}, "file": "HepLean/HepLean/PerturbationTheory/WickContraction/Join.lean", "module": "HepLean.PerturbationTheory.WickContraction.Join", "jsonFile": "HepLean.PerturbationTheory.WickContraction.Join.jsonl", "positionMetadata": {"lineInFile": 226, "tokenPositionInFile": 8875, "theoremPositionInFile": 16}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 12, "numPremises": 33}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  apply eq_fstFieldOfContract_of_mem _ _ _ (\u03c6s\u039b.sndFieldOfContract a)\n  \u00b7 simp [joinLiftLeft]\n  \u00b7 simp [joinLiftLeft]\n  \u00b7 exact fstFieldOfContract_lt_sndFieldOfContract \u03c6s\u039b a", "proofType": "tactic", "proofLengthLines": 4, "proofLengthTokens": 180}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.NormalOrder\nimport HepLean.PerturbationTheory.FieldOpAlgebra.SuperCommute\n/-!\n\n# Normal Ordering on Field operator algebra\n\n-/\n\nnamespace FieldSpecification\nopen FieldOpFreeAlgebra\nopen HepLean.List\nopen FieldStatistic\n\nnamespace FieldOpAlgebra\nvariable {\ud835\udcd5 : FieldSpecification}\n\n/-!\n\n## Normal order on super-commutators.\n\nThe main result of this is\n`\u03b9_normalOrderF_superCommuteF_eq_zero_mul`\nwhich states that applying `\u03b9` to the normal order of something containing a super-commutator\nis zero.\n\n-/\n\nlemma \u03b9_normalOrderF_superCommuteF_ofCrAnListF_ofCrAnListF_eq_zero\n    (\u03c6a \u03c6a' : \ud835\udcd5.CrAnFieldOp) (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    \u03b9 \ud835\udcdd\u1da0(ofCrAnListF \u03c6s * [ofCrAnOpF \u03c6a, ofCrAnOpF \u03c6a']\u209bca * ofCrAnListF \u03c6s') = 0 := by\n  rcases CreateAnnihilate.eq_create_or_annihilate (\ud835\udcd5 |>\u1d9c \u03c6a) with h\u03c6a | h\u03c6a\n  <;> rcases CreateAnnihilate.eq_create_or_annihilate (\ud835\udcd5 |>\u1d9c \u03c6a') with h\u03c6a' | h\u03c6a'\n  \u00b7 rw [normalOrderF_superCommuteF_ofCrAnListF_create_create_ofCrAnListF \u03c6a \u03c6a' h\u03c6a h\u03c6a' \u03c6s \u03c6s']\n    rw [map_smul, map_mul, map_mul, map_mul, \u03b9_superCommuteF_of_create_create \u03c6a \u03c6a' h\u03c6a h\u03c6a']\n    simp\n  \u00b7 rw [normalOrderF_superCommuteF_create_annihilate \u03c6a \u03c6a' h\u03c6a h\u03c6a' (ofCrAnListF \u03c6s)\n      (ofCrAnListF \u03c6s')]\n    simp\n  \u00b7 rw [normalOrderF_superCommuteF_annihilate_create \u03c6a' \u03c6a h\u03c6a' h\u03c6a (ofCrAnListF \u03c6s)\n      (ofCrAnListF \u03c6s')]\n    simp\n  \u00b7 rw [normalOrderF_superCommuteF_ofCrAnListF_annihilate_annihilate_ofCrAnListF\n      \u03c6a \u03c6a' h\u03c6a h\u03c6a' \u03c6s \u03c6s']\n    rw [map_smul, map_mul, map_mul, map_mul,\n      \u03b9_superCommuteF_of_annihilate_annihilate \u03c6a \u03c6a' h\u03c6a h\u03c6a']\n    simp\n\nlemma \u03b9_normalOrderF_superCommuteF_ofCrAnListF_eq_zero\n    (\u03c6a \u03c6a' : \ud835\udcd5.CrAnFieldOp) (\u03c6s : List \ud835\udcd5.CrAnFieldOp)\n    (a : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \u03b9 \ud835\udcdd\u1da0(ofCrAnListF \u03c6s * [ofCrAnOpF \u03c6a, ofCrAnOpF \u03c6a']\u209bca * a) = 0 := by\n  have hf : \u03b9.toLinearMap \u2218\u2097 normalOrderF \u2218\u2097\n      mulLinearMap (ofCrAnListF \u03c6s * [ofCrAnOpF \u03c6a, ofCrAnOpF \u03c6a']\u209bca) = 0 := by\n    apply ofCrAnListFBasis.ext\n    intro l\n    simp only [FieldOpFreeAlgebra.ofListBasis_eq_ofList, LinearMap.coe_comp, Function.comp_apply,\n      AlgHom.toLinearMap_apply, LinearMap.zero_apply]\n    exact \u03b9_normalOrderF_superCommuteF_ofCrAnListF_ofCrAnListF_eq_zero \u03c6a \u03c6a' \u03c6s l\n  change (\u03b9.toLinearMap \u2218\u2097 normalOrderF \u2218\u2097\n    mulLinearMap ((ofCrAnListF \u03c6s * [ofCrAnOpF \u03c6a, ofCrAnOpF \u03c6a']\u209bca))) a = 0\n  rw [hf]\n  simp\n\nlemma \u03b9_normalOrderF_superCommuteF_ofCrAnOpF_eq_zero_mul (\u03c6a \u03c6a' : \ud835\udcd5.CrAnFieldOp)\n    (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \u03b9 \ud835\udcdd\u1da0(a * [ofCrAnOpF \u03c6a, ofCrAnOpF \u03c6a']\u209bca * b) = 0 := by\n  rw [mul_assoc]\n  change (\u03b9.toLinearMap \u2218\u2097 normalOrderF \u2218\u2097 mulLinearMap.flip\n    ([ofCrAnOpF \u03c6a, ofCrAnOpF \u03c6a']\u209bca * b)) a = 0\n  have hf : \u03b9.toLinearMap \u2218\u2097 normalOrderF \u2218\u2097 mulLinearMap.flip\n      ([ofCrAnOpF \u03c6a, ofCrAnOpF \u03c6a']\u209bca * b) = 0 := by\n    apply ofCrAnListFBasis.ext\n    intro l\n    simp only [mulLinearMap, FieldOpFreeAlgebra.ofListBasis_eq_ofList, LinearMap.coe_comp,\n      Function.comp_apply, LinearMap.flip_apply, LinearMap.coe_mk, AddHom.coe_mk,\n      AlgHom.toLinearMap_apply, LinearMap.zero_apply]\n    rw [\u2190 mul_assoc]\n    exact \u03b9_normalOrderF_superCommuteF_ofCrAnListF_eq_zero \u03c6a \u03c6a' _ _\n  rw [hf]\n  simp\n\nlemma \u03b9_normalOrderF_superCommuteF_ofCrAnOpF_ofCrAnListF_eq_zero_mul (\u03c6a : \ud835\udcd5.CrAnFieldOp)\n    (\u03c6s : List \ud835\udcd5.CrAnFieldOp) (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \u03b9 \ud835\udcdd\u1da0(a * [ofCrAnOpF \u03c6a, ofCrAnListF \u03c6s]\u209bca * b) = 0 := by\n  rw [\u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF_eq_sum]\n  rw [Finset.mul_sum, Finset.sum_mul]\n  rw [map_sum, map_sum]\n  apply Fintype.sum_eq_zero\n  intro n\n  rw [\u2190 mul_assoc, \u2190 mul_assoc]\n  rw [mul_assoc _ _ b, ofCrAnListF_singleton]\n  rw [\u03b9_normalOrderF_superCommuteF_ofCrAnOpF_eq_zero_mul]\n\nlemma \u03b9_normalOrderF_superCommuteF_ofCrAnListF_ofCrAnOpF_eq_zero_mul (\u03c6a : \ud835\udcd5.CrAnFieldOp)\n    (\u03c6s : List \ud835\udcd5.CrAnFieldOp) (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \u03b9 \ud835\udcdd\u1da0(a * [ofCrAnListF \u03c6s, ofCrAnOpF \u03c6a]\u209bca * b) = 0 := by\n  rw [\u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF_symm, ofCrAnListF_singleton]\n  simp only [FieldStatistic.instCommGroup.eq_1, FieldStatistic.ofList_singleton, mul_neg,\n    Algebra.mul_smul_comm, neg_mul, Algebra.smul_mul_assoc, map_neg, map_smul]\n  rw [\u03b9_normalOrderF_superCommuteF_ofCrAnOpF_ofCrAnListF_eq_zero_mul]\n  simp\n\n", "theoremStatement": "lemma \u03b9_normalOrderF_superCommuteF_ofCrAnListF_ofCrAnListF_eq_zero_mul\n    (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \u03b9 \ud835\udcdd\u1da0(a * [ofCrAnListF \u03c6s, ofCrAnListF \u03c6s']\u209bca * b) = 0 ", "theoremName": "FieldSpecification.FieldOpAlgebra.\u03b9_normalOrderF_superCommuteF_ofCrAnListF_ofCrAnListF_eq_zero_mul", "fileCreated": {"commit": "2e82f842a242717b98517656fc34b1b92f579b2e", "date": "2025-02-05"}, "theoremCreated": {"commit": "171e80fc04016aed422340742f3e0a14de6d20b0", "date": "2025-02-03"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpAlgebra/NormalOrder/Basic.lean", "module": "HepLean.PerturbationTheory.FieldOpAlgebra.NormalOrder.Basic", "jsonFile": "HepLean.PerturbationTheory.FieldOpAlgebra.NormalOrder.Basic.jsonl", "positionMetadata": {"lineInFile": 108, "tokenPositionInFile": 4411, "theoremPositionInFile": 5}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 17, "numPremises": 123}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [superCommuteF_ofCrAnListF_ofCrAnListF_eq_sum, Finset.mul_sum, Finset.sum_mul]\n  rw [map_sum, map_sum]\n  apply Fintype.sum_eq_zero\n  intro n\n  rw [\u2190 mul_assoc, \u2190 mul_assoc]\n  rw [mul_assoc _ _ b]\n  rw [\u03b9_normalOrderF_superCommuteF_ofCrAnListF_ofCrAnOpF_eq_zero_mul]", "proofType": "tactic", "proofLengthLines": 7, "proofLengthTokens": 276}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.TimeOrder\nimport HepLean.PerturbationTheory.FieldOpAlgebra.SuperCommute\n/-!\n\n# Time Ordering on Field operator algebra\n\n-/\n\nnamespace FieldSpecification\nopen FieldOpFreeAlgebra\nopen HepLean.List\nopen FieldStatistic\n\nnamespace FieldOpAlgebra\nvariable {\ud835\udcd5 : FieldSpecification}\n\nlemma \u03b9_timeOrderF_superCommuteF_superCommuteF_eq_time_ofCrAnListF {\u03c61 \u03c62 \u03c63 : \ud835\udcd5.CrAnFieldOp}\n    (\u03c6s1 \u03c6s2 : List \ud835\udcd5.CrAnFieldOp) (h :\n      crAnTimeOrderRel \u03c61 \u03c62 \u2227 crAnTimeOrderRel \u03c61 \u03c63 \u2227\n      crAnTimeOrderRel \u03c62 \u03c61 \u2227 crAnTimeOrderRel \u03c62 \u03c63 \u2227\n      crAnTimeOrderRel \u03c63 \u03c61 \u2227 crAnTimeOrderRel \u03c63 \u03c62) :\n    \u03b9 \ud835\udce3\u1da0(ofCrAnListF \u03c6s1 * [ofCrAnOpF \u03c61, [ofCrAnOpF \u03c62, ofCrAnOpF \u03c63]\u209bca]\u209bca *\n    ofCrAnListF \u03c6s2) = 0 := by\n  let l1 :=\n    (List.takeWhile (fun c => \u00ac crAnTimeOrderRel \u03c61 c)\n    ((\u03c6s1 ++ \u03c6s2).insertionSort crAnTimeOrderRel))\n    ++ (List.filter (fun c => crAnTimeOrderRel \u03c61 c \u2227 crAnTimeOrderRel c \u03c61) \u03c6s1)\n  let l2 := (List.filter (fun c => crAnTimeOrderRel \u03c61 c \u2227 crAnTimeOrderRel c \u03c61) \u03c6s2)\n    ++ (List.filter (fun c => crAnTimeOrderRel \u03c61 c \u2227 \u00ac crAnTimeOrderRel c \u03c61)\n    ((\u03c6s1 ++ \u03c6s2).insertionSort crAnTimeOrderRel))\n  have h123 : \u03b9 \ud835\udce3\u1da0(ofCrAnListF (\u03c6s1 ++ \u03c61 :: \u03c62 :: \u03c63 :: \u03c6s2)) =\n      crAnTimeOrderSign (\u03c6s1 ++ \u03c61 :: \u03c62 :: \u03c63 :: \u03c6s2)\n      \u2022 (\u03b9 (ofCrAnListF l1) * \u03b9 (ofCrAnListF [\u03c61, \u03c62, \u03c63]) * \u03b9 (ofCrAnListF l2)) := by\n    have h1 := insertionSort_of_eq_list \ud835\udcd5.crAnTimeOrderRel \u03c61 \u03c6s1 [\u03c61, \u03c62, \u03c63] \u03c6s2\n      (by simp_all)\n    rw [timeOrderF_ofCrAnListF, show \u03c6s1 ++ \u03c61 :: \u03c62 :: \u03c63 :: \u03c6s2 = \u03c6s1 ++ [\u03c61, \u03c62, \u03c63] ++ \u03c6s2\n      by simp, crAnTimeOrderList, h1]\n    simp only [List.append_assoc, List.singleton_append, decide_not,\n      Bool.decide_and, ofCrAnListF_append, map_smul, map_mul, l1, l2, mul_assoc]\n  have h132 : \u03b9 \ud835\udce3\u1da0(ofCrAnListF (\u03c6s1 ++ \u03c61 :: \u03c63 :: \u03c62 :: \u03c6s2)) =\n      crAnTimeOrderSign (\u03c6s1 ++ \u03c61 :: \u03c62 :: \u03c63 :: \u03c6s2)\n      \u2022 (\u03b9 (ofCrAnListF l1) * \u03b9 (ofCrAnListF [\u03c61, \u03c63, \u03c62]) * \u03b9 (ofCrAnListF l2)) := by\n    have h1 := insertionSort_of_eq_list \ud835\udcd5.crAnTimeOrderRel \u03c61 \u03c6s1 [\u03c61, \u03c63, \u03c62] \u03c6s2\n        (by simp_all)\n    rw [timeOrderF_ofCrAnListF, show \u03c6s1 ++ \u03c61 :: \u03c63 :: \u03c62 :: \u03c6s2 = \u03c6s1 ++ [\u03c61, \u03c63, \u03c62] ++ \u03c6s2\n      by simp, crAnTimeOrderList, h1]\n    simp only [List.singleton_append, decide_not,\n      Bool.decide_and, ofCrAnListF_append, map_smul, map_mul, l1, l2, mul_assoc]\n    congr 1\n    have hp : List.Perm [\u03c61, \u03c63, \u03c62] [\u03c61, \u03c62, \u03c63] := by\n      refine List.Perm.cons \u03c61 ?_\n      exact List.Perm.swap \u03c62 \u03c63 []\n    rw [crAnTimeOrderSign, Wick.koszulSign_perm_eq _ _ \u03c61 _ _ _ _ _ hp, \u2190 crAnTimeOrderSign]\n    \u00b7 simp\n    \u00b7 intro \u03c64 h\u03c64\n      simp only [List.mem_cons, List.mem_singleton, List.not_mem_nil, or_false] at h\u03c64\n      rcases h\u03c64 with h\u03c64 | h\u03c64 | h\u03c64\n      all_goals\n        subst h\u03c64\n        simp_all\n  have hp231 : List.Perm [\u03c62, \u03c63, \u03c61] [\u03c61, \u03c62, \u03c63] := by\n      refine List.Perm.trans (l\u2082 := [\u03c62, \u03c61, \u03c63]) ?_ ?_\n      refine List.Perm.cons \u03c62 (List.Perm.swap \u03c61 \u03c63 [])\n      exact List.Perm.swap \u03c61 \u03c62 [\u03c63]\n  have h231 : \u03b9 \ud835\udce3\u1da0(ofCrAnListF (\u03c6s1 ++ \u03c62 :: \u03c63 :: \u03c61 :: \u03c6s2)) =\n      crAnTimeOrderSign (\u03c6s1 ++ \u03c61 :: \u03c62 :: \u03c63 :: \u03c6s2)\n      \u2022 (\u03b9 (ofCrAnListF l1) * \u03b9 (ofCrAnListF [\u03c62, \u03c63, \u03c61]) * \u03b9 (ofCrAnListF l2)) := by\n    have h1 := insertionSort_of_eq_list \ud835\udcd5.crAnTimeOrderRel \u03c61 \u03c6s1 [\u03c62, \u03c63, \u03c61] \u03c6s2\n        (by simp_all)\n    rw [timeOrderF_ofCrAnListF, show \u03c6s1 ++ \u03c62 :: \u03c63 :: \u03c61 :: \u03c6s2 = \u03c6s1 ++ [\u03c62, \u03c63, \u03c61] ++ \u03c6s2\n      by simp, crAnTimeOrderList, h1]\n    simp only [List.singleton_append, decide_not,\n      Bool.decide_and, ofCrAnListF_append, map_smul, map_mul, l1, l2, mul_assoc]\n    congr 1\n    rw [crAnTimeOrderSign, Wick.koszulSign_perm_eq _ _ \u03c61 _ _ _ _ _ hp231, \u2190 crAnTimeOrderSign]\n    \u00b7 simp\n    \u00b7 intro \u03c64 h\u03c64\n      simp only [List.mem_cons, List.mem_singleton, List.not_mem_nil, or_false] at h\u03c64\n      rcases h\u03c64 with h\u03c64 | h\u03c64 | h\u03c64\n      all_goals\n        subst h\u03c64\n        simp_all\n  have h321 : \u03b9 \ud835\udce3\u1da0(ofCrAnListF (\u03c6s1 ++ \u03c63 :: \u03c62 :: \u03c61 :: \u03c6s2)) =\n      crAnTimeOrderSign (\u03c6s1 ++ \u03c61 :: \u03c62 :: \u03c63 :: \u03c6s2)\n      \u2022 (\u03b9 (ofCrAnListF l1) * \u03b9 (ofCrAnListF [\u03c63, \u03c62, \u03c61]) * \u03b9 (ofCrAnListF l2)) := by\n    have h1 := insertionSort_of_eq_list \ud835\udcd5.crAnTimeOrderRel \u03c61 \u03c6s1 [\u03c63, \u03c62, \u03c61] \u03c6s2\n        (by simp_all)\n    rw [timeOrderF_ofCrAnListF, show \u03c6s1 ++ \u03c63 :: \u03c62 :: \u03c61 :: \u03c6s2 = \u03c6s1 ++ [\u03c63, \u03c62, \u03c61] ++ \u03c6s2\n      by simp, crAnTimeOrderList, h1]\n    simp only [List.singleton_append, decide_not,\n      Bool.decide_and, ofCrAnListF_append, map_smul, map_mul, l1, l2, mul_assoc]\n    congr 1\n    have hp : List.Perm [\u03c63, \u03c62, \u03c61] [\u03c61, \u03c62, \u03c63] := by\n      refine List.Perm.trans ?_ hp231\n      exact List.Perm.swap \u03c62 \u03c63 [\u03c61]\n    rw [crAnTimeOrderSign, Wick.koszulSign_perm_eq _ _ \u03c61 _ _ _ _ _ hp, \u2190 crAnTimeOrderSign]\n    \u00b7 simp\n    \u00b7 intro \u03c64 h\u03c64\n      simp only [List.mem_cons, List.mem_singleton, List.not_mem_nil, or_false] at h\u03c64\n      rcases h\u03c64 with h\u03c64 | h\u03c64 | h\u03c64\n      all_goals\n        subst h\u03c64\n        simp_all\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton]\n  rw [superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp only [List.singleton_append, instCommGroup.eq_1, ofList_singleton, map_sub, map_smul]\n  rw [superCommuteF_ofCrAnListF_ofCrAnListF, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp only [List.cons_append, List.nil_append, instCommGroup.eq_1, ofList_singleton, mul_sub, \u2190\n    ofCrAnListF_append, Algebra.mul_smul_comm, sub_mul, List.append_assoc, Algebra.smul_mul_assoc,\n    map_sub, map_smul]\n  rw [h123, h132, h231, h321]\n  simp only [smul_smul]\n  rw [mul_comm, \u2190 smul_smul, mul_comm, \u2190 smul_smul]\n  rw [\u2190 smul_sub, \u2190 smul_sub, smul_smul, mul_comm, \u2190 smul_smul, \u2190 smul_sub]\n  simp only [smul_eq_zero]\n  right\n  rw [\u2190 smul_mul_assoc, \u2190 mul_smul_comm, mul_assoc]\n  rw [\u2190 smul_mul_assoc, \u2190 mul_smul_comm]\n  rw [smul_sub]\n  rw [\u2190 smul_mul_assoc, \u2190 mul_smul_comm]\n  rw [\u2190 smul_mul_assoc, \u2190 mul_smul_comm]\n  repeat rw [mul_assoc]\n  rw [\u2190 mul_sub, \u2190 mul_sub, \u2190 mul_sub]\n  rw [\u2190 sub_mul, \u2190 sub_mul, \u2190 sub_mul]\n  trans \u03b9 (ofCrAnListF l1) * \u03b9 [ofCrAnOpF \u03c61, [ofCrAnOpF \u03c62, ofCrAnOpF \u03c63]\u209bca]\u209bca *\n    \u03b9 (ofCrAnListF l2)\n  rw [mul_assoc]\n  congr\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton]\n  rw [superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp only [List.singleton_append, instCommGroup.eq_1, ofList_singleton, map_sub, map_smul]\n  rw [superCommuteF_ofCrAnListF_ofCrAnListF, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp only [List.cons_append, List.nil_append, instCommGroup.eq_1, ofList_singleton, map_sub,\n    map_smul, smul_sub]\n  simp_all\n\nlemma \u03b9_timeOrderF_superCommuteF_superCommuteF_ofCrAnListF {\u03c61 \u03c62 \u03c63 : \ud835\udcd5.CrAnFieldOp}\n    (\u03c6s1 \u03c6s2 : List \ud835\udcd5.CrAnFieldOp) :\n    \u03b9 \ud835\udce3\u1da0(ofCrAnListF \u03c6s1 * [ofCrAnOpF \u03c61, [ofCrAnOpF \u03c62, ofCrAnOpF \u03c63]\u209bca]\u209bca * ofCrAnListF \u03c6s2)\n    = 0 := by\n  by_cases h :\n      crAnTimeOrderRel \u03c61 \u03c62 \u2227 crAnTimeOrderRel \u03c61 \u03c63 \u2227\n      crAnTimeOrderRel \u03c62 \u03c61 \u2227 crAnTimeOrderRel \u03c62 \u03c63 \u2227\n      crAnTimeOrderRel \u03c63 \u03c61 \u2227 crAnTimeOrderRel \u03c63 \u03c62\n  \u00b7 exact \u03b9_timeOrderF_superCommuteF_superCommuteF_eq_time_ofCrAnListF \u03c6s1 \u03c6s2 h\n  \u00b7 rw [timeOrderF_timeOrderF_mid]\n    rw [timeOrderF_superCommuteF_ofCrAnOpF_superCommuteF_all_not_crAnTimeOrderRel _ _ _ h]\n    simp\n\n@[simp]\nlemma \u03b9_timeOrderF_superCommuteF_superCommuteF {\u03c61 \u03c62 \u03c63 : \ud835\udcd5.CrAnFieldOp}\n    (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \u03b9 \ud835\udce3\u1da0(a * [ofCrAnOpF \u03c61, [ofCrAnOpF \u03c62, ofCrAnOpF \u03c63]\u209bca]\u209bca * b) = 0 := by\n  let pb (b : \ud835\udcd5.FieldOpFreeAlgebra) (hc : b \u2208 Submodule.span \u2102 (Set.range ofCrAnListFBasis)) :\n    Prop := \u03b9 \ud835\udce3\u1da0(a * [ofCrAnOpF \u03c61, [ofCrAnOpF \u03c62, ofCrAnOpF \u03c63]\u209bca]\u209bca * b) = 0\n  change pb b (Basis.mem_span _ b)\n  apply Submodule.span_induction\n  \u00b7 intro x hx\n    obtain \u27e8\u03c6s, rfl\u27e9 := hx\n    simp only [ofListBasis_eq_ofList, pb]\n    let pa (a : \ud835\udcd5.FieldOpFreeAlgebra) (hc : a \u2208 Submodule.span \u2102 (Set.range ofCrAnListFBasis)) :\n      Prop := \u03b9 \ud835\udce3\u1da0(a * [ofCrAnOpF \u03c61, [ofCrAnOpF \u03c62, ofCrAnOpF \u03c63]\u209bca]\u209bca * ofCrAnListF \u03c6s) = 0\n    change pa a (Basis.mem_span _ a)\n    apply Submodule.span_induction\n    \u00b7 intro x hx\n      obtain \u27e8\u03c6s', rfl\u27e9 := hx\n      simp only [ofListBasis_eq_ofList, pa]\n      exact \u03b9_timeOrderF_superCommuteF_superCommuteF_ofCrAnListF \u03c6s' \u03c6s\n    \u00b7 simp [pa]\n    \u00b7 intro x y hx hy hpx hpy\n      simp_all [pa,mul_add, add_mul]\n    \u00b7 intro x hx hpx\n      simp_all [pa, hpx]\n  \u00b7 simp [pb]\n  \u00b7 intro x y hx hy hpx hpy\n    simp_all [pb,mul_add, add_mul]\n  \u00b7 intro x hx hpx\n    simp_all [pb, hpx]\n\nlemma \u03b9_timeOrderF_superCommuteF_eq_time {\u03c6 \u03c8 : \ud835\udcd5.CrAnFieldOp}\n    (h\u03c6\u03c8 : crAnTimeOrderRel \u03c6 \u03c8) (h\u03c8\u03c6 : crAnTimeOrderRel \u03c8 \u03c6) (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \u03b9 \ud835\udce3\u1da0(a * [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca * b) =\n    \u03b9 ([ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca * \ud835\udce3\u1da0(a * b)) := by\n  let pb (b : \ud835\udcd5.FieldOpFreeAlgebra) (hc : b \u2208 Submodule.span \u2102 (Set.range ofCrAnListFBasis)) :\n    Prop := \u03b9 \ud835\udce3\u1da0(a * [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca * b) =\n    \u03b9 ([ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca * \ud835\udce3\u1da0(a * b))\n  change pb b (Basis.mem_span _ b)\n  apply Submodule.span_induction\n  \u00b7 intro x hx\n    obtain \u27e8\u03c6s, rfl\u27e9 := hx\n    simp only [ofListBasis_eq_ofList, map_mul, pb]\n    let pa (a : \ud835\udcd5.FieldOpFreeAlgebra) (hc : a \u2208 Submodule.span \u2102 (Set.range ofCrAnListFBasis)) :\n      Prop := \u03b9 \ud835\udce3\u1da0(a * [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca * ofCrAnListF \u03c6s) =\n      \u03b9 ([ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca * \ud835\udce3\u1da0(a* ofCrAnListF \u03c6s))\n    change pa a (Basis.mem_span _ a)\n    apply Submodule.span_induction\n    \u00b7 intro x hx\n      obtain \u27e8\u03c6s', rfl\u27e9 := hx\n      simp only [ofListBasis_eq_ofList, map_mul, pa]\n      conv_lhs =>\n        rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n        simp [mul_sub, sub_mul, \u2190 ofCrAnListF_append]\n        rw [timeOrderF_ofCrAnListF, timeOrderF_ofCrAnListF]\n      have h1 : crAnTimeOrderSign (\u03c6s' ++ \u03c6 :: \u03c8 :: \u03c6s) =\n          crAnTimeOrderSign (\u03c6s' ++ \u03c8 :: \u03c6 :: \u03c6s) := by\n        trans crAnTimeOrderSign (\u03c6s' ++ [\u03c6, \u03c8] ++ \u03c6s)\n        simp only [List.append_assoc, List.cons_append, List.nil_append]\n        rw [crAnTimeOrderSign]\n        have hp : List.Perm [\u03c6,\u03c8] [\u03c8,\u03c6] := by exact List.Perm.swap \u03c8 \u03c6 []\n        rw [Wick.koszulSign_perm_eq _ _ \u03c6 _ _ _ _ _ hp]\n        simp only [List.append_assoc, List.cons_append, List.singleton_append]\n        rfl\n        simp_all\n      rw [h1]\n      simp only [map_smul]\n      have h1 := insertionSort_of_eq_list \ud835\udcd5.crAnTimeOrderRel \u03c6 \u03c6s' [\u03c6, \u03c8] \u03c6s\n        (by simp_all)\n      rw [crAnTimeOrderList, show \u03c6s' ++ \u03c6 :: \u03c8 :: \u03c6s = \u03c6s' ++ [\u03c6, \u03c8] ++ \u03c6s by simp, h1]\n      have h2 := insertionSort_of_eq_list \ud835\udcd5.crAnTimeOrderRel \u03c6 \u03c6s' [\u03c8, \u03c6] \u03c6s\n        (by simp_all)\n      rw [crAnTimeOrderList, show \u03c6s' ++ \u03c8 :: \u03c6 :: \u03c6s = \u03c6s' ++ [\u03c8, \u03c6] ++ \u03c6s by simp, h2]\n      repeat rw [ofCrAnListF_append]\n      rw [smul_smul, mul_comm, \u2190 smul_smul, \u2190 smul_sub]\n      rw [map_mul, map_mul, map_mul, map_mul, map_mul, map_mul, map_mul, map_mul]\n      rw [\u2190 mul_smul_comm]\n      rw [mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc]\n      rw [\u2190 mul_sub, \u2190 mul_sub, mul_smul_comm, mul_smul_comm, \u2190 smul_mul_assoc,\n        \u2190 smul_mul_assoc]\n      rw [\u2190 sub_mul]\n      have h1 : (\u03b9 (ofCrAnListF [\u03c6, \u03c8]) -\n          (exchangeSign (\ud835\udcd5.crAnStatistics \u03c6)) (\ud835\udcd5.crAnStatistics \u03c8) \u2022 \u03b9 (ofCrAnListF [\u03c8, \u03c6])) =\n        \u03b9 [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca := by\n        rw [superCommuteF_ofCrAnOpF_ofCrAnOpF]\n        rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_append]\n        simp only [instCommGroup.eq_1, List.singleton_append, Algebra.smul_mul_assoc, map_sub,\n          map_smul]\n        rw [\u2190 ofCrAnListF_append]\n        simp\n      rw [h1]\n      have hc : \u03b9 ((superCommuteF (ofCrAnOpF \u03c6)) (ofCrAnOpF \u03c8)) \u2208\n          Subalgebra.center \u2102 \ud835\udcd5.FieldOpAlgebra := by\n        apply \u03b9_superCommuteF_ofCrAnOpF_ofCrAnOpF_mem_center\n      rw [Subalgebra.mem_center_iff] at hc\n      repeat rw [\u2190 mul_assoc]\n      rw [hc]\n      repeat rw [mul_assoc]\n      rw [smul_mul_assoc]\n      rw [\u2190 map_mul, \u2190 map_mul, \u2190 map_mul, \u2190 map_mul]\n      rw [\u2190 ofCrAnListF_append, \u2190 ofCrAnListF_append, \u2190 ofCrAnListF_append, \u2190 ofCrAnListF_append]\n      have h1 := insertionSort_of_takeWhile_filter \ud835\udcd5.crAnTimeOrderRel \u03c6 \u03c6s' \u03c6s\n      simp only [decide_not, Bool.decide_and, List.append_assoc, List.cons_append,\n        List.singleton_append, Algebra.mul_smul_comm, map_mul] at h1 \u22a2\n      rw [\u2190 h1]\n      rw [\u2190 crAnTimeOrderList]\n      by_cases hq : (\ud835\udcd5 |>\u209b \u03c6) \u2260 (\ud835\udcd5 |>\u209b \u03c8)\n      \u00b7 rw [\u03b9_superCommuteF_of_diff_statistic hq]\n        simp\n      \u00b7 rw [crAnTimeOrderSign, Wick.koszulSign_eq_rel_eq_stat _ _, \u2190 crAnTimeOrderSign]\n        rw [timeOrderF_ofCrAnListF]\n        simp only [map_smul, Algebra.mul_smul_comm]\n        simp only [List.nil_append]\n        exact h\u03c8\u03c6\n        exact h\u03c6\u03c8\n        simpa using hq\n    \u00b7 simp only [map_mul, zero_mul, map_zero, mul_zero, pa]\n    \u00b7 intro x y hx hy hpx hpy\n      simp_all [pa,mul_add, add_mul]\n    \u00b7 intro x hx hpx\n      simp_all [pa, hpx]\n  \u00b7 simp only [map_mul, mul_zero, map_zero, pb]\n  \u00b7 intro x y hx hy hpx hpy\n    simp_all [pb,mul_add, add_mul]\n  \u00b7 intro x hx hpx\n    simp_all [pb, hpx]\n\n", "theoremStatement": "lemma \u03b9_timeOrderF_superCommuteF_neq_time {\u03c6 \u03c8 : \ud835\udcd5.CrAnFieldOp}\n    (h\u03c6\u03c8 : \u00ac (crAnTimeOrderRel \u03c6 \u03c8 \u2227 crAnTimeOrderRel \u03c8 \u03c6)) (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \u03b9 \ud835\udce3\u1da0(a * [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca * b) = 0 ", "theoremName": "FieldSpecification.FieldOpAlgebra.\u03b9_timeOrderF_superCommuteF_neq_time", "fileCreated": {"commit": "ea6e12829370d9630a7e65200c8349e9086c05ba", "date": "2025-02-03"}, "theoremCreated": {"commit": "c53299d40a1b625549e794ce81600fd7232d737b", "date": "2025-01-30"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpAlgebra/TimeOrder.lean", "module": "HepLean.PerturbationTheory.FieldOpAlgebra.TimeOrder", "jsonFile": "HepLean.PerturbationTheory.FieldOpAlgebra.TimeOrder.jsonl", "positionMetadata": {"lineInFile": 281, "tokenPositionInFile": 13019, "theoremPositionInFile": 4}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 20, "numPremises": 203}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [timeOrderF_timeOrderF_mid]\n  have h\u03c6\u03c8 : \u00ac (crAnTimeOrderRel \u03c6 \u03c8) \u2228 \u00ac (crAnTimeOrderRel \u03c8 \u03c6) := by\n    exact Decidable.not_and_iff_or_not.mp h\u03c6\u03c8\n  rcases h\u03c6\u03c8 with h\u03c6\u03c8 | h\u03c6\u03c8\n  \u00b7 rw [timeOrderF_superCommuteF_ofCrAnOpF_ofCrAnOpF_not_crAnTimeOrderRel]\n    simp_all only [false_and, not_false_eq_true, false_or, mul_zero, zero_mul, map_zero]\n    simp_all\n  \u00b7 rw [superCommuteF_ofCrAnOpF_ofCrAnOpF_symm]\n    simp only [instCommGroup.eq_1, neg_smul, map_neg, map_smul, mul_neg, Algebra.mul_smul_comm,\n      neg_mul, Algebra.smul_mul_assoc, neg_eq_zero, smul_eq_zero]\n    rw [timeOrderF_superCommuteF_ofCrAnOpF_ofCrAnOpF_not_crAnTimeOrderRel]\n    simp only [mul_zero, zero_mul, map_zero, or_true]\n    simp_all", "proofType": "tactic", "proofLengthLines": 13, "proofLengthTokens": 712}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.WickContraction.InsertAndContractNat\n/-!\n\n# Equivalence extracting element from contraction\n\n-/\n\nopen FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\nnamespace WickContraction\nvariable {n : \u2115} (c : WickContraction n)\nopen HepLean.List\nopen HepLean.Fin\n\n", "theoremStatement": "lemma extractEquiv_equiv {c1 c2 : (c : WickContraction n) \u00d7 Option c.uncontracted}\n    (h : c1.1 = c2.1) (ho : c1.2 = uncontractedCongr (by rw [h]) c2.2) : c1 = c2 ", "theoremName": "WickContraction.extractEquiv_equiv", "fileCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "theoremCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "file": "HepLean/HepLean/PerturbationTheory/WickContraction/ExtractEquiv.lean", "module": "HepLean.PerturbationTheory.WickContraction.ExtractEquiv", "jsonFile": "HepLean.PerturbationTheory.WickContraction.ExtractEquiv.jsonl", "positionMetadata": {"lineInFile": 21, "tokenPositionInFile": 455, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 3, "numPremises": 48}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  cases c1\n  cases c2\n  simp_all only [Sigma.mk.inj_iff]\n  simp only at h\n  subst h\n  simp only [uncontractedCongr, Equiv.optionCongr_apply, heq_eq_eq, true_and]\n  rename_i a\n  match a with\n  | none => simp\n  | some a =>\n    simp only [Option.map_some', Option.some.injEq]\n    ext\n    simp", "proofType": "tactic", "proofLengthLines": 13, "proofLengthTokens": 295}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.TimeOrder\nimport HepLean.PerturbationTheory.FieldOpAlgebra.SuperCommute\n/-!\n\n# Time Ordering on Field operator algebra\n\n-/\n\nnamespace FieldSpecification\nopen FieldOpFreeAlgebra\nopen HepLean.List\nopen FieldStatistic\n\nnamespace FieldOpAlgebra\nvariable {\ud835\udcd5 : FieldSpecification}\n\nlemma \u03b9_timeOrderF_superCommuteF_superCommuteF_eq_time_ofCrAnListF {\u03c61 \u03c62 \u03c63 : \ud835\udcd5.CrAnFieldOp}\n    (\u03c6s1 \u03c6s2 : List \ud835\udcd5.CrAnFieldOp) (h :\n      crAnTimeOrderRel \u03c61 \u03c62 \u2227 crAnTimeOrderRel \u03c61 \u03c63 \u2227\n      crAnTimeOrderRel \u03c62 \u03c61 \u2227 crAnTimeOrderRel \u03c62 \u03c63 \u2227\n      crAnTimeOrderRel \u03c63 \u03c61 \u2227 crAnTimeOrderRel \u03c63 \u03c62) :\n    \u03b9 \ud835\udce3\u1da0(ofCrAnListF \u03c6s1 * [ofCrAnOpF \u03c61, [ofCrAnOpF \u03c62, ofCrAnOpF \u03c63]\u209bca]\u209bca *\n    ofCrAnListF \u03c6s2) = 0 := by\n  let l1 :=\n    (List.takeWhile (fun c => \u00ac crAnTimeOrderRel \u03c61 c)\n    ((\u03c6s1 ++ \u03c6s2).insertionSort crAnTimeOrderRel))\n    ++ (List.filter (fun c => crAnTimeOrderRel \u03c61 c \u2227 crAnTimeOrderRel c \u03c61) \u03c6s1)\n  let l2 := (List.filter (fun c => crAnTimeOrderRel \u03c61 c \u2227 crAnTimeOrderRel c \u03c61) \u03c6s2)\n    ++ (List.filter (fun c => crAnTimeOrderRel \u03c61 c \u2227 \u00ac crAnTimeOrderRel c \u03c61)\n    ((\u03c6s1 ++ \u03c6s2).insertionSort crAnTimeOrderRel))\n  have h123 : \u03b9 \ud835\udce3\u1da0(ofCrAnListF (\u03c6s1 ++ \u03c61 :: \u03c62 :: \u03c63 :: \u03c6s2)) =\n      crAnTimeOrderSign (\u03c6s1 ++ \u03c61 :: \u03c62 :: \u03c63 :: \u03c6s2)\n      \u2022 (\u03b9 (ofCrAnListF l1) * \u03b9 (ofCrAnListF [\u03c61, \u03c62, \u03c63]) * \u03b9 (ofCrAnListF l2)) := by\n    have h1 := insertionSort_of_eq_list \ud835\udcd5.crAnTimeOrderRel \u03c61 \u03c6s1 [\u03c61, \u03c62, \u03c63] \u03c6s2\n      (by simp_all)\n    rw [timeOrderF_ofCrAnListF, show \u03c6s1 ++ \u03c61 :: \u03c62 :: \u03c63 :: \u03c6s2 = \u03c6s1 ++ [\u03c61, \u03c62, \u03c63] ++ \u03c6s2\n      by simp, crAnTimeOrderList, h1]\n    simp only [List.append_assoc, List.singleton_append, decide_not,\n      Bool.decide_and, ofCrAnListF_append, map_smul, map_mul, l1, l2, mul_assoc]\n  have h132 : \u03b9 \ud835\udce3\u1da0(ofCrAnListF (\u03c6s1 ++ \u03c61 :: \u03c63 :: \u03c62 :: \u03c6s2)) =\n      crAnTimeOrderSign (\u03c6s1 ++ \u03c61 :: \u03c62 :: \u03c63 :: \u03c6s2)\n      \u2022 (\u03b9 (ofCrAnListF l1) * \u03b9 (ofCrAnListF [\u03c61, \u03c63, \u03c62]) * \u03b9 (ofCrAnListF l2)) := by\n    have h1 := insertionSort_of_eq_list \ud835\udcd5.crAnTimeOrderRel \u03c61 \u03c6s1 [\u03c61, \u03c63, \u03c62] \u03c6s2\n        (by simp_all)\n    rw [timeOrderF_ofCrAnListF, show \u03c6s1 ++ \u03c61 :: \u03c63 :: \u03c62 :: \u03c6s2 = \u03c6s1 ++ [\u03c61, \u03c63, \u03c62] ++ \u03c6s2\n      by simp, crAnTimeOrderList, h1]\n    simp only [List.singleton_append, decide_not,\n      Bool.decide_and, ofCrAnListF_append, map_smul, map_mul, l1, l2, mul_assoc]\n    congr 1\n    have hp : List.Perm [\u03c61, \u03c63, \u03c62] [\u03c61, \u03c62, \u03c63] := by\n      refine List.Perm.cons \u03c61 ?_\n      exact List.Perm.swap \u03c62 \u03c63 []\n    rw [crAnTimeOrderSign, Wick.koszulSign_perm_eq _ _ \u03c61 _ _ _ _ _ hp, \u2190 crAnTimeOrderSign]\n    \u00b7 simp\n    \u00b7 intro \u03c64 h\u03c64\n      simp only [List.mem_cons, List.mem_singleton, List.not_mem_nil, or_false] at h\u03c64\n      rcases h\u03c64 with h\u03c64 | h\u03c64 | h\u03c64\n      all_goals\n        subst h\u03c64\n        simp_all\n  have hp231 : List.Perm [\u03c62, \u03c63, \u03c61] [\u03c61, \u03c62, \u03c63] := by\n      refine List.Perm.trans (l\u2082 := [\u03c62, \u03c61, \u03c63]) ?_ ?_\n      refine List.Perm.cons \u03c62 (List.Perm.swap \u03c61 \u03c63 [])\n      exact List.Perm.swap \u03c61 \u03c62 [\u03c63]\n  have h231 : \u03b9 \ud835\udce3\u1da0(ofCrAnListF (\u03c6s1 ++ \u03c62 :: \u03c63 :: \u03c61 :: \u03c6s2)) =\n      crAnTimeOrderSign (\u03c6s1 ++ \u03c61 :: \u03c62 :: \u03c63 :: \u03c6s2)\n      \u2022 (\u03b9 (ofCrAnListF l1) * \u03b9 (ofCrAnListF [\u03c62, \u03c63, \u03c61]) * \u03b9 (ofCrAnListF l2)) := by\n    have h1 := insertionSort_of_eq_list \ud835\udcd5.crAnTimeOrderRel \u03c61 \u03c6s1 [\u03c62, \u03c63, \u03c61] \u03c6s2\n        (by simp_all)\n    rw [timeOrderF_ofCrAnListF, show \u03c6s1 ++ \u03c62 :: \u03c63 :: \u03c61 :: \u03c6s2 = \u03c6s1 ++ [\u03c62, \u03c63, \u03c61] ++ \u03c6s2\n      by simp, crAnTimeOrderList, h1]\n    simp only [List.singleton_append, decide_not,\n      Bool.decide_and, ofCrAnListF_append, map_smul, map_mul, l1, l2, mul_assoc]\n    congr 1\n    rw [crAnTimeOrderSign, Wick.koszulSign_perm_eq _ _ \u03c61 _ _ _ _ _ hp231, \u2190 crAnTimeOrderSign]\n    \u00b7 simp\n    \u00b7 intro \u03c64 h\u03c64\n      simp only [List.mem_cons, List.mem_singleton, List.not_mem_nil, or_false] at h\u03c64\n      rcases h\u03c64 with h\u03c64 | h\u03c64 | h\u03c64\n      all_goals\n        subst h\u03c64\n        simp_all\n  have h321 : \u03b9 \ud835\udce3\u1da0(ofCrAnListF (\u03c6s1 ++ \u03c63 :: \u03c62 :: \u03c61 :: \u03c6s2)) =\n      crAnTimeOrderSign (\u03c6s1 ++ \u03c61 :: \u03c62 :: \u03c63 :: \u03c6s2)\n      \u2022 (\u03b9 (ofCrAnListF l1) * \u03b9 (ofCrAnListF [\u03c63, \u03c62, \u03c61]) * \u03b9 (ofCrAnListF l2)) := by\n    have h1 := insertionSort_of_eq_list \ud835\udcd5.crAnTimeOrderRel \u03c61 \u03c6s1 [\u03c63, \u03c62, \u03c61] \u03c6s2\n        (by simp_all)\n    rw [timeOrderF_ofCrAnListF, show \u03c6s1 ++ \u03c63 :: \u03c62 :: \u03c61 :: \u03c6s2 = \u03c6s1 ++ [\u03c63, \u03c62, \u03c61] ++ \u03c6s2\n      by simp, crAnTimeOrderList, h1]\n    simp only [List.singleton_append, decide_not,\n      Bool.decide_and, ofCrAnListF_append, map_smul, map_mul, l1, l2, mul_assoc]\n    congr 1\n    have hp : List.Perm [\u03c63, \u03c62, \u03c61] [\u03c61, \u03c62, \u03c63] := by\n      refine List.Perm.trans ?_ hp231\n      exact List.Perm.swap \u03c62 \u03c63 [\u03c61]\n    rw [crAnTimeOrderSign, Wick.koszulSign_perm_eq _ _ \u03c61 _ _ _ _ _ hp, \u2190 crAnTimeOrderSign]\n    \u00b7 simp\n    \u00b7 intro \u03c64 h\u03c64\n      simp only [List.mem_cons, List.mem_singleton, List.not_mem_nil, or_false] at h\u03c64\n      rcases h\u03c64 with h\u03c64 | h\u03c64 | h\u03c64\n      all_goals\n        subst h\u03c64\n        simp_all\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton]\n  rw [superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp only [List.singleton_append, instCommGroup.eq_1, ofList_singleton, map_sub, map_smul]\n  rw [superCommuteF_ofCrAnListF_ofCrAnListF, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp only [List.cons_append, List.nil_append, instCommGroup.eq_1, ofList_singleton, mul_sub, \u2190\n    ofCrAnListF_append, Algebra.mul_smul_comm, sub_mul, List.append_assoc, Algebra.smul_mul_assoc,\n    map_sub, map_smul]\n  rw [h123, h132, h231, h321]\n  simp only [smul_smul]\n  rw [mul_comm, \u2190 smul_smul, mul_comm, \u2190 smul_smul]\n  rw [\u2190 smul_sub, \u2190 smul_sub, smul_smul, mul_comm, \u2190 smul_smul, \u2190 smul_sub]\n  simp only [smul_eq_zero]\n  right\n  rw [\u2190 smul_mul_assoc, \u2190 mul_smul_comm, mul_assoc]\n  rw [\u2190 smul_mul_assoc, \u2190 mul_smul_comm]\n  rw [smul_sub]\n  rw [\u2190 smul_mul_assoc, \u2190 mul_smul_comm]\n  rw [\u2190 smul_mul_assoc, \u2190 mul_smul_comm]\n  repeat rw [mul_assoc]\n  rw [\u2190 mul_sub, \u2190 mul_sub, \u2190 mul_sub]\n  rw [\u2190 sub_mul, \u2190 sub_mul, \u2190 sub_mul]\n  trans \u03b9 (ofCrAnListF l1) * \u03b9 [ofCrAnOpF \u03c61, [ofCrAnOpF \u03c62, ofCrAnOpF \u03c63]\u209bca]\u209bca *\n    \u03b9 (ofCrAnListF l2)\n  rw [mul_assoc]\n  congr\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton]\n  rw [superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp only [List.singleton_append, instCommGroup.eq_1, ofList_singleton, map_sub, map_smul]\n  rw [superCommuteF_ofCrAnListF_ofCrAnListF, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp only [List.cons_append, List.nil_append, instCommGroup.eq_1, ofList_singleton, map_sub,\n    map_smul, smul_sub]\n  simp_all\n\nlemma \u03b9_timeOrderF_superCommuteF_superCommuteF_ofCrAnListF {\u03c61 \u03c62 \u03c63 : \ud835\udcd5.CrAnFieldOp}\n    (\u03c6s1 \u03c6s2 : List \ud835\udcd5.CrAnFieldOp) :\n    \u03b9 \ud835\udce3\u1da0(ofCrAnListF \u03c6s1 * [ofCrAnOpF \u03c61, [ofCrAnOpF \u03c62, ofCrAnOpF \u03c63]\u209bca]\u209bca * ofCrAnListF \u03c6s2)\n    = 0 := by\n  by_cases h :\n      crAnTimeOrderRel \u03c61 \u03c62 \u2227 crAnTimeOrderRel \u03c61 \u03c63 \u2227\n      crAnTimeOrderRel \u03c62 \u03c61 \u2227 crAnTimeOrderRel \u03c62 \u03c63 \u2227\n      crAnTimeOrderRel \u03c63 \u03c61 \u2227 crAnTimeOrderRel \u03c63 \u03c62\n  \u00b7 exact \u03b9_timeOrderF_superCommuteF_superCommuteF_eq_time_ofCrAnListF \u03c6s1 \u03c6s2 h\n  \u00b7 rw [timeOrderF_timeOrderF_mid]\n    rw [timeOrderF_superCommuteF_ofCrAnOpF_superCommuteF_all_not_crAnTimeOrderRel _ _ _ h]\n    simp\n\n@[simp]\nlemma \u03b9_timeOrderF_superCommuteF_superCommuteF {\u03c61 \u03c62 \u03c63 : \ud835\udcd5.CrAnFieldOp}\n    (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \u03b9 \ud835\udce3\u1da0(a * [ofCrAnOpF \u03c61, [ofCrAnOpF \u03c62, ofCrAnOpF \u03c63]\u209bca]\u209bca * b) = 0 := by\n  let pb (b : \ud835\udcd5.FieldOpFreeAlgebra) (hc : b \u2208 Submodule.span \u2102 (Set.range ofCrAnListFBasis)) :\n    Prop := \u03b9 \ud835\udce3\u1da0(a * [ofCrAnOpF \u03c61, [ofCrAnOpF \u03c62, ofCrAnOpF \u03c63]\u209bca]\u209bca * b) = 0\n  change pb b (Basis.mem_span _ b)\n  apply Submodule.span_induction\n  \u00b7 intro x hx\n    obtain \u27e8\u03c6s, rfl\u27e9 := hx\n    simp only [ofListBasis_eq_ofList, pb]\n    let pa (a : \ud835\udcd5.FieldOpFreeAlgebra) (hc : a \u2208 Submodule.span \u2102 (Set.range ofCrAnListFBasis)) :\n      Prop := \u03b9 \ud835\udce3\u1da0(a * [ofCrAnOpF \u03c61, [ofCrAnOpF \u03c62, ofCrAnOpF \u03c63]\u209bca]\u209bca * ofCrAnListF \u03c6s) = 0\n    change pa a (Basis.mem_span _ a)\n    apply Submodule.span_induction\n    \u00b7 intro x hx\n      obtain \u27e8\u03c6s', rfl\u27e9 := hx\n      simp only [ofListBasis_eq_ofList, pa]\n      exact \u03b9_timeOrderF_superCommuteF_superCommuteF_ofCrAnListF \u03c6s' \u03c6s\n    \u00b7 simp [pa]\n    \u00b7 intro x y hx hy hpx hpy\n      simp_all [pa,mul_add, add_mul]\n    \u00b7 intro x hx hpx\n      simp_all [pa, hpx]\n  \u00b7 simp [pb]\n  \u00b7 intro x y hx hy hpx hpy\n    simp_all [pb,mul_add, add_mul]\n  \u00b7 intro x hx hpx\n    simp_all [pb, hpx]\n\nlemma \u03b9_timeOrderF_superCommuteF_eq_time {\u03c6 \u03c8 : \ud835\udcd5.CrAnFieldOp}\n    (h\u03c6\u03c8 : crAnTimeOrderRel \u03c6 \u03c8) (h\u03c8\u03c6 : crAnTimeOrderRel \u03c8 \u03c6) (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \u03b9 \ud835\udce3\u1da0(a * [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca * b) =\n    \u03b9 ([ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca * \ud835\udce3\u1da0(a * b)) := by\n  let pb (b : \ud835\udcd5.FieldOpFreeAlgebra) (hc : b \u2208 Submodule.span \u2102 (Set.range ofCrAnListFBasis)) :\n    Prop := \u03b9 \ud835\udce3\u1da0(a * [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca * b) =\n    \u03b9 ([ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca * \ud835\udce3\u1da0(a * b))\n  change pb b (Basis.mem_span _ b)\n  apply Submodule.span_induction\n  \u00b7 intro x hx\n    obtain \u27e8\u03c6s, rfl\u27e9 := hx\n    simp only [ofListBasis_eq_ofList, map_mul, pb]\n    let pa (a : \ud835\udcd5.FieldOpFreeAlgebra) (hc : a \u2208 Submodule.span \u2102 (Set.range ofCrAnListFBasis)) :\n      Prop := \u03b9 \ud835\udce3\u1da0(a * [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca * ofCrAnListF \u03c6s) =\n      \u03b9 ([ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca * \ud835\udce3\u1da0(a* ofCrAnListF \u03c6s))\n    change pa a (Basis.mem_span _ a)\n    apply Submodule.span_induction\n    \u00b7 intro x hx\n      obtain \u27e8\u03c6s', rfl\u27e9 := hx\n      simp only [ofListBasis_eq_ofList, map_mul, pa]\n      conv_lhs =>\n        rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n        simp [mul_sub, sub_mul, \u2190 ofCrAnListF_append]\n        rw [timeOrderF_ofCrAnListF, timeOrderF_ofCrAnListF]\n      have h1 : crAnTimeOrderSign (\u03c6s' ++ \u03c6 :: \u03c8 :: \u03c6s) =\n          crAnTimeOrderSign (\u03c6s' ++ \u03c8 :: \u03c6 :: \u03c6s) := by\n        trans crAnTimeOrderSign (\u03c6s' ++ [\u03c6, \u03c8] ++ \u03c6s)\n        simp only [List.append_assoc, List.cons_append, List.nil_append]\n        rw [crAnTimeOrderSign]\n        have hp : List.Perm [\u03c6,\u03c8] [\u03c8,\u03c6] := by exact List.Perm.swap \u03c8 \u03c6 []\n        rw [Wick.koszulSign_perm_eq _ _ \u03c6 _ _ _ _ _ hp]\n        simp only [List.append_assoc, List.cons_append, List.singleton_append]\n        rfl\n        simp_all\n      rw [h1]\n      simp only [map_smul]\n      have h1 := insertionSort_of_eq_list \ud835\udcd5.crAnTimeOrderRel \u03c6 \u03c6s' [\u03c6, \u03c8] \u03c6s\n        (by simp_all)\n      rw [crAnTimeOrderList, show \u03c6s' ++ \u03c6 :: \u03c8 :: \u03c6s = \u03c6s' ++ [\u03c6, \u03c8] ++ \u03c6s by simp, h1]\n      have h2 := insertionSort_of_eq_list \ud835\udcd5.crAnTimeOrderRel \u03c6 \u03c6s' [\u03c8, \u03c6] \u03c6s\n        (by simp_all)\n      rw [crAnTimeOrderList, show \u03c6s' ++ \u03c8 :: \u03c6 :: \u03c6s = \u03c6s' ++ [\u03c8, \u03c6] ++ \u03c6s by simp, h2]\n      repeat rw [ofCrAnListF_append]\n      rw [smul_smul, mul_comm, \u2190 smul_smul, \u2190 smul_sub]\n      rw [map_mul, map_mul, map_mul, map_mul, map_mul, map_mul, map_mul, map_mul]\n      rw [\u2190 mul_smul_comm]\n      rw [mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc]\n      rw [\u2190 mul_sub, \u2190 mul_sub, mul_smul_comm, mul_smul_comm, \u2190 smul_mul_assoc,\n        \u2190 smul_mul_assoc]\n      rw [\u2190 sub_mul]\n      have h1 : (\u03b9 (ofCrAnListF [\u03c6, \u03c8]) -\n          (exchangeSign (\ud835\udcd5.crAnStatistics \u03c6)) (\ud835\udcd5.crAnStatistics \u03c8) \u2022 \u03b9 (ofCrAnListF [\u03c8, \u03c6])) =\n        \u03b9 [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca := by\n        rw [superCommuteF_ofCrAnOpF_ofCrAnOpF]\n        rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_append]\n        simp only [instCommGroup.eq_1, List.singleton_append, Algebra.smul_mul_assoc, map_sub,\n          map_smul]\n        rw [\u2190 ofCrAnListF_append]\n        simp\n      rw [h1]\n      have hc : \u03b9 ((superCommuteF (ofCrAnOpF \u03c6)) (ofCrAnOpF \u03c8)) \u2208\n          Subalgebra.center \u2102 \ud835\udcd5.FieldOpAlgebra := by\n        apply \u03b9_superCommuteF_ofCrAnOpF_ofCrAnOpF_mem_center\n      rw [Subalgebra.mem_center_iff] at hc\n      repeat rw [\u2190 mul_assoc]\n      rw [hc]\n      repeat rw [mul_assoc]\n      rw [smul_mul_assoc]\n      rw [\u2190 map_mul, \u2190 map_mul, \u2190 map_mul, \u2190 map_mul]\n      rw [\u2190 ofCrAnListF_append, \u2190 ofCrAnListF_append, \u2190 ofCrAnListF_append, \u2190 ofCrAnListF_append]\n      have h1 := insertionSort_of_takeWhile_filter \ud835\udcd5.crAnTimeOrderRel \u03c6 \u03c6s' \u03c6s\n      simp only [decide_not, Bool.decide_and, List.append_assoc, List.cons_append,\n        List.singleton_append, Algebra.mul_smul_comm, map_mul] at h1 \u22a2\n      rw [\u2190 h1]\n      rw [\u2190 crAnTimeOrderList]\n      by_cases hq : (\ud835\udcd5 |>\u209b \u03c6) \u2260 (\ud835\udcd5 |>\u209b \u03c8)\n      \u00b7 rw [\u03b9_superCommuteF_of_diff_statistic hq]\n        simp\n      \u00b7 rw [crAnTimeOrderSign, Wick.koszulSign_eq_rel_eq_stat _ _, \u2190 crAnTimeOrderSign]\n        rw [timeOrderF_ofCrAnListF]\n        simp only [map_smul, Algebra.mul_smul_comm]\n        simp only [List.nil_append]\n        exact h\u03c8\u03c6\n        exact h\u03c6\u03c8\n        simpa using hq\n    \u00b7 simp only [map_mul, zero_mul, map_zero, mul_zero, pa]\n    \u00b7 intro x y hx hy hpx hpy\n      simp_all [pa,mul_add, add_mul]\n    \u00b7 intro x hx hpx\n      simp_all [pa, hpx]\n  \u00b7 simp only [map_mul, mul_zero, map_zero, pb]\n  \u00b7 intro x y hx hy hpx hpy\n    simp_all [pb,mul_add, add_mul]\n  \u00b7 intro x hx hpx\n    simp_all [pb, hpx]\n\nlemma \u03b9_timeOrderF_superCommuteF_neq_time {\u03c6 \u03c8 : \ud835\udcd5.CrAnFieldOp}\n    (h\u03c6\u03c8 : \u00ac (crAnTimeOrderRel \u03c6 \u03c8 \u2227 crAnTimeOrderRel \u03c8 \u03c6)) (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \u03b9 \ud835\udce3\u1da0(a * [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca * b) = 0 := by\n  rw [timeOrderF_timeOrderF_mid]\n  have h\u03c6\u03c8 : \u00ac (crAnTimeOrderRel \u03c6 \u03c8) \u2228 \u00ac (crAnTimeOrderRel \u03c8 \u03c6) := by\n    exact Decidable.not_and_iff_or_not.mp h\u03c6\u03c8\n  rcases h\u03c6\u03c8 with h\u03c6\u03c8 | h\u03c6\u03c8\n  \u00b7 rw [timeOrderF_superCommuteF_ofCrAnOpF_ofCrAnOpF_not_crAnTimeOrderRel]\n    simp_all only [false_and, not_false_eq_true, false_or, mul_zero, zero_mul, map_zero]\n    simp_all\n  \u00b7 rw [superCommuteF_ofCrAnOpF_ofCrAnOpF_symm]\n    simp only [instCommGroup.eq_1, neg_smul, map_neg, map_smul, mul_neg, Algebra.mul_smul_comm,\n      neg_mul, Algebra.smul_mul_assoc, neg_eq_zero, smul_eq_zero]\n    rw [timeOrderF_superCommuteF_ofCrAnOpF_ofCrAnOpF_not_crAnTimeOrderRel]\n    simp only [mul_zero, zero_mul, map_zero, or_true]\n    simp_all\n\n/-!\n\n## Defining time order for `FiedOpAlgebra`.\n\n-/\n\n", "theoremStatement": "lemma \u03b9_timeOrderF_zero_of_mem_ideal (a : \ud835\udcd5.FieldOpFreeAlgebra)\n    (h : a \u2208 TwoSidedIdeal.span \ud835\udcd5.fieldOpIdealSet) : \u03b9 \ud835\udce3\u1da0(a) = 0 ", "theoremName": "FieldSpecification.FieldOpAlgebra.\u03b9_timeOrderF_zero_of_mem_ideal", "fileCreated": {"commit": "ea6e12829370d9630a7e65200c8349e9086c05ba", "date": "2025-02-03"}, "theoremCreated": {"commit": "c53299d40a1b625549e794ce81600fd7232d737b", "date": "2025-01-30"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpAlgebra/TimeOrder.lean", "module": "HepLean.PerturbationTheory.FieldOpAlgebra.TimeOrder", "jsonFile": "HepLean.PerturbationTheory.FieldOpAlgebra.TimeOrder.jsonl", "positionMetadata": {"lineInFile": 304, "tokenPositionInFile": 13994, "theoremPositionInFile": 5}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 23, "numPremises": 193}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [TwoSidedIdeal.mem_span_iff_mem_addSubgroup_closure] at h\n  let p {k : Set \ud835\udcd5.FieldOpFreeAlgebra} (a : FieldOpFreeAlgebra \ud835\udcd5)\n    (h : a \u2208 AddSubgroup.closure k) := \u03b9 \ud835\udce3\u1da0(a) = 0\n  change p a h\n  apply AddSubgroup.closure_induction\n  \u00b7 intro x hx\n    obtain \u27e8a, ha, b, hb, rfl\u27e9 := Set.mem_mul.mp hx\n    obtain \u27e8a, ha, c, hc, rfl\u27e9 := ha\n    simp only [p]\n    simp only [fieldOpIdealSet, exists_prop, exists_and_left, Set.mem_setOf_eq] at hc\n    match hc with\n    | Or.inl hc =>\n      obtain \u27e8\u03c6a, \u03c6a', h\u03c6a, h\u03c6a', rfl\u27e9 := hc\n      simp only [\u03b9_timeOrderF_superCommuteF_superCommuteF]\n    | Or.inr (Or.inl hc) =>\n      obtain \u27e8\u03c6a, h\u03c6a, \u03c6b, h\u03c6b, rfl\u27e9 := hc\n      by_cases heqt : (crAnTimeOrderRel \u03c6a \u03c6b \u2227 crAnTimeOrderRel \u03c6b \u03c6a)\n      \u00b7 rw [\u03b9_timeOrderF_superCommuteF_eq_time]\n        simp only [map_mul]\n        rw [\u03b9_superCommuteF_of_create_create]\n        simp only [zero_mul]\n        \u00b7 exact h\u03c6a\n        \u00b7 exact h\u03c6b\n        \u00b7 exact heqt.1\n        \u00b7 exact heqt.2\n      \u00b7 rw [\u03b9_timeOrderF_superCommuteF_neq_time heqt]\n    | Or.inr (Or.inr (Or.inl hc)) =>\n      obtain \u27e8\u03c6a, h\u03c6a, \u03c6b, h\u03c6b, rfl\u27e9 := hc\n      by_cases heqt : (crAnTimeOrderRel \u03c6a \u03c6b \u2227 crAnTimeOrderRel \u03c6b \u03c6a)\n      \u00b7 rw [\u03b9_timeOrderF_superCommuteF_eq_time]\n        simp only [map_mul]\n        rw [\u03b9_superCommuteF_of_annihilate_annihilate]\n        simp only [zero_mul]\n        \u00b7 exact h\u03c6a\n        \u00b7 exact h\u03c6b\n        \u00b7 exact heqt.1\n        \u00b7 exact heqt.2\n      \u00b7 rw [\u03b9_timeOrderF_superCommuteF_neq_time heqt]\n    | Or.inr (Or.inr (Or.inr hc)) =>\n      obtain \u27e8\u03c6a, \u03c6b, hdiff, rfl\u27e9 := hc\n      by_cases heqt : (crAnTimeOrderRel \u03c6a \u03c6b \u2227 crAnTimeOrderRel \u03c6b \u03c6a)\n      \u00b7 rw [\u03b9_timeOrderF_superCommuteF_eq_time]\n        simp only [map_mul]\n        rw [\u03b9_superCommuteF_of_diff_statistic]\n        simp only [zero_mul]\n        \u00b7 exact hdiff\n        \u00b7 exact heqt.1\n        \u00b7 exact heqt.2\n      \u00b7 rw [\u03b9_timeOrderF_superCommuteF_neq_time heqt]\n  \u00b7 simp [p]\n  \u00b7 intro x y hx hy\n    simp only [map_add, p]\n    intro h1 h2\n    simp [h1, h2]\n  \u00b7 intro x hx\n    simp [p]", "proofType": "tactic", "proofLengthLines": 56, "proofLengthTokens": 2017}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.WickContraction.Join\n/-!\n\n# Sign associated with joining two Wick contractions\n\n-/\n\nopen FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\nnamespace WickContraction\nvariable {n : \u2115} (c : WickContraction n)\nopen HepLean.List\nopen FieldOpAlgebra\n\nopen FieldStatistic\n\nlemma stat_signFinset_right {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) (i j : Fin [\u03c6s\u039b]\u1d58\u1d9c.length) :\n    (\ud835\udcd5 |>\u209b \u27e8[\u03c6s\u039b]\u1d58\u1d9c.get, \u03c6suc\u039b.signFinset i j\u27e9) =\n    (\ud835\udcd5 |>\u209b \u27e8\u03c6s.get, (\u03c6suc\u039b.signFinset i j).map uncontractedListEmd\u27e9) := by\n  simp only [ofFinset]\n  congr 1\n  rw [\u2190 fin_finset_sort_map_monotone]\n  simp only [List.map_map, List.map_inj_left, Finset.mem_sort, List.get_eq_getElem,\n    Function.comp_apply, getElem_uncontractedListEmd, implies_true]\n  intro i j h\n  exact uncontractedListEmd_strictMono h\n\nlemma signFinset_right_map_uncontractedListEmd_eq_filter {\u03c6s : List \ud835\udcd5.FieldOp}\n    (\u03c6s\u039b : WickContraction \u03c6s.length) (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length)\n    (i j : Fin [\u03c6s\u039b]\u1d58\u1d9c.length) : (\u03c6suc\u039b.signFinset i j).map uncontractedListEmd =\n    ((join \u03c6s\u039b \u03c6suc\u039b).signFinset (uncontractedListEmd i) (uncontractedListEmd j)).filter\n    (fun c => c \u2208 \u03c6s\u039b.uncontracted) := by\n  ext a\n  simp only [Finset.mem_map, Finset.mem_filter]\n  apply Iff.intro\n  \u00b7 intro h\n    obtain \u27e8a, ha, rfl\u27e9 := h\n    apply And.intro\n    \u00b7 simp_all only [signFinset, Finset.mem_filter, Finset.mem_univ, true_and,\n      join_getDual?_apply_uncontractedListEmb, Option.map_eq_none', Option.isSome_map']\n      apply And.intro\n      \u00b7 exact uncontractedListEmd_strictMono ha.1\n      \u00b7 apply And.intro\n        \u00b7 exact uncontractedListEmd_strictMono ha.2.1\n        \u00b7 have ha2 := ha.2.2\n          simp_all only [and_true]\n          rcases ha2 with ha2 | ha2\n          \u00b7 simp [ha2]\n          \u00b7 right\n            intro h\n            apply lt_of_lt_of_eq (uncontractedListEmd_strictMono (ha2 h))\n            rw [Option.get_map]\n    \u00b7 exact uncontractedListEmd_mem_uncontracted a\n  \u00b7 intro h\n    have h2 := h.2\n    have h2' := uncontractedListEmd_surjective_mem_uncontracted a h.2\n    obtain \u27e8a, rfl\u27e9 := h2'\n    use a\n    simp_all only [signFinset, Finset.mem_filter, Finset.mem_univ,\n      join_getDual?_apply_uncontractedListEmb, Option.map_eq_none', Option.isSome_map', true_and,\n      and_true, and_self]\n    apply And.intro\n    \u00b7 have h1 := h.1\n      rw [StrictMono.lt_iff_lt] at h1\n      exact h1\n      exact fun _ _ h => uncontractedListEmd_strictMono h\n    \u00b7 apply And.intro\n      \u00b7 have h1 := h.2.1\n        rw [StrictMono.lt_iff_lt] at h1\n        exact h1\n        exact fun _ _ h => uncontractedListEmd_strictMono h\n      \u00b7 have h1 := h.2.2\n        simp_all only [and_true]\n        rcases h1 with h1 | h1\n        \u00b7 simp [h1]\n        \u00b7 right\n          intro h\n          have h1' := h1 h\n          have hl : uncontractedListEmd i < uncontractedListEmd ((\u03c6suc\u039b.getDual? a).get h) := by\n            apply lt_of_lt_of_eq h1'\n            simp [Option.get_map]\n          rw [StrictMono.lt_iff_lt] at hl\n          exact hl\n          exact fun _ _ h => uncontractedListEmd_strictMono h\n\nlemma sign_right_eq_prod_mul_prod {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) :\n    \u03c6suc\u039b.sign = (\u220f a, \ud835\udce2(\ud835\udcd5|>\u209b [\u03c6s\u039b]\u1d58\u1d9c[\u03c6suc\u039b.sndFieldOfContract a], \ud835\udcd5|>\u209b \u27e8\u03c6s.get,\n    ((join \u03c6s\u039b \u03c6suc\u039b).signFinset (uncontractedListEmd (\u03c6suc\u039b.fstFieldOfContract a))\n      (uncontractedListEmd (\u03c6suc\u039b.sndFieldOfContract a))).filter\n      (fun c => \u00ac c \u2208 \u03c6s\u039b.uncontracted)\u27e9)) *\n    (\u220f a, \ud835\udce2(\ud835\udcd5|>\u209b [\u03c6s\u039b]\u1d58\u1d9c[\u03c6suc\u039b.sndFieldOfContract a], \ud835\udcd5|>\u209b \u27e8\u03c6s.get,\n      ((join \u03c6s\u039b \u03c6suc\u039b).signFinset (uncontractedListEmd (\u03c6suc\u039b.fstFieldOfContract a))\n        (uncontractedListEmd (\u03c6suc\u039b.sndFieldOfContract a)))\u27e9)) := by\n  rw [\u2190 Finset.prod_mul_distrib, sign]\n  congr\n  funext a\n  rw [\u2190 map_mul]\n  congr\n  rw [stat_signFinset_right, signFinset_right_map_uncontractedListEmd_eq_filter]\n  rw [ofFinset_filter]\n\n", "theoremStatement": "lemma join_singleton_signFinset_eq_filter {\u03c6s : List \ud835\udcd5.FieldOp}\n    {i j : Fin \u03c6s.length} (h : i < j)\n    (\u03c6suc\u039b : WickContraction [singleton h]\u1d58\u1d9c.length) :\n    (join (singleton h) \u03c6suc\u039b).signFinset i j =\n    ((singleton h).signFinset i j).filter (fun c => \u00ac\n    (((join (singleton h) \u03c6suc\u039b).getDual? c).isSome \u2227\n    ((h1 : ((join (singleton h) \u03c6suc\u039b).getDual? c).isSome) \u2192\n    (((join (singleton h) \u03c6suc\u039b).getDual? c).get h1) < i))) ", "theoremName": "WickContraction.join_singleton_signFinset_eq_filter", "fileCreated": {"commit": "ff4a56226cdb330ba2e2fb86afe224b906b97b64", "date": "2025-02-03"}, "theoremCreated": {"commit": "12d36dc1d9c726c035301091e57be0b29015e4ae", "date": "2025-01-31"}, "file": "HepLean/HepLean/PerturbationTheory/WickContraction/Sign/Join.lean", "module": "HepLean.PerturbationTheory.WickContraction.Sign.Join", "jsonFile": "HepLean.PerturbationTheory.WickContraction.Sign.Join.jsonl", "positionMetadata": {"lineInFile": 110, "tokenPositionInFile": 4099, "theoremPositionInFile": 3}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 12, "numPremises": 201}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  ext a\n  simp only [signFinset, Finset.mem_filter, Finset.mem_univ, true_and, not_and, not_forall, not_lt,\n    and_assoc, and_congr_right_iff]\n  intro h1 h2\n  have h1 : (singleton h).getDual? a = none := by\n    rw [singleton_getDual?_eq_none_iff_neq]\n    omega\n  simp only [h1, Option.isSome_none, Bool.false_eq_true, IsEmpty.forall_iff, or_self, true_and]\n  apply Iff.intro\n  \u00b7 intro h1 h2\n    rcases h1 with h1 | h1\n    \u00b7 simp only [h1, Option.isSome_none, Bool.false_eq_true, IsEmpty.exists_iff]\n      have h2' : \u00ac (((singleton h).join \u03c6suc\u039b).getDual? a).isSome := by\n        exact Option.not_isSome_iff_eq_none.mpr h1\n      exact h2' h2\n    use h2\n    have h1 := h1 h2\n    omega\n  \u00b7 intro h2\n    by_cases h2' : (((singleton h).join \u03c6suc\u039b).getDual? a).isSome = true\n    \u00b7 have h2 := h2 h2'\n      obtain \u27e8hb, h2\u27e9 := h2\n      right\n      intro hl\n      apply lt_of_le_of_ne h2\n      by_contra hn\n      have hij : ((singleton h).join \u03c6suc\u039b).getDual? i = j := by\n        rw [@getDual?_eq_some_iff_mem]\n        simp [join, singleton]\n      simp only [hn, getDual?_getDual?_get_get, Option.some.injEq] at hij\n      omega\n    \u00b7 simp only [Bool.not_eq_true, Option.not_isSome, Option.isNone_iff_eq_none] at h2'\n      simp [h2']", "proofType": "tactic", "proofLengthLines": 33, "proofLengthTokens": 1229}}
{"srcContext": "/-\nCopyright (c) 2024 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport Mathlib.LinearAlgebra.PiTensorProduct\nimport Mathlib.Tactic.Polyrith\nimport Mathlib.Tactic.Linarith\nimport Mathlib.Data.Nat.Factorial.DoubleFactorial\n/-!\n# Fin involutions\n\nSome properties of involutions of `Fin n`.\n\nThese involutions are used in e.g. proving results about Wick contractions.\n\n-/\nnamespace HepLean.Fin\n\nopen Nat\n\n/-- There is an equivalence between involutions of `Fin n.succ` and involutions of\n  `Fin n` and an optional valid choice of an element in `Fin n` (which is where `0`\n    in `Fin n.succ` will be sent). -/\ndef involutionCons (n : \u2115) : {f : Fin n.succ \u2192 Fin n.succ // Function.Involutive f } \u2243\n    (f : {f : Fin n \u2192 Fin n // Function.Involutive f}) \u00d7 {i : Option (Fin n) //\n      \u2200 (h : i.isSome), f.1 (Option.get i h) = (Option.get i h)} where\n  toFun f := \u27e8\u27e8\n    fun i =>\n    if h : f.1 i.succ = 0 then i\n    else Fin.pred (f.1 i.succ) h, by\n    intro i\n    by_cases h : f.1 i.succ = 0\n    \u00b7 simp [h]\n    \u00b7 simp only [succ_eq_add_one, h, \u2193reduceDIte, Fin.succ_pred]\n      simp only [f.2 i.succ, Fin.pred_succ, dite_eq_ite, ite_eq_right_iff]\n      intro h\n      exact False.elim (Fin.succ_ne_zero i h)\u27e9,\n    \u27e8if h : f.1 0 = 0 then none else Fin.pred (f.1 0) h, by\n    by_cases h0 : f.1 0 = 0\n    \u00b7 simp [h0]\n    \u00b7 simp only [succ_eq_add_one, h0, \u2193reduceDIte, Option.isSome_some, Option.get_some,\n      Fin.succ_pred, dite_eq_left_iff, Fin.pred_inj, forall_const]\n      refine fun h => False.elim (h (f.2 0))\u27e9\u27e9\n  invFun f := \u27e8\n      if h : (f.2.1).isSome then\n        Fin.cons (f.2.1.get h).succ (Function.update (Fin.succ \u2218 f.1.1) (f.2.1.get h) 0)\n      else\n        Fin.cons 0 (Fin.succ \u2218 f.1.1), by\n    by_cases hs : (f.2.1).isSome\n    \u00b7 simp only [Nat.succ_eq_add_one, hs, \u2193reduceDIte, Fin.coe_eq_castSucc]\n      let a := f.2.1.get hs\n      change Function.Involutive (Fin.cons a.succ (Function.update (Fin.succ \u2218 \u2191f.fst) a 0))\n      intro i\n      rcases Fin.eq_zero_or_eq_succ i with hi | \u27e8j, hj\u27e9\n      \u00b7 subst hi\n        rw [Fin.cons_zero, Fin.cons_succ]\n        simp\n      \u00b7 subst hj\n        rw [Fin.cons_succ]\n        by_cases hja : j = a\n        \u00b7 subst hja\n          simp\n        \u00b7 rw [Function.update_apply]\n          rw [if_neg hja]\n          simp only [Function.comp_apply, Fin.cons_succ]\n          have hf2 := f.2.2 hs\n          change f.1.1 a = a at hf2\n          have hjf1 : f.1.1 j \u2260 a := by\n            by_contra hn\n            have haj : j = f.1.1 a := by\n              rw [\u2190 hn]\n              rw [f.1.2]\n            rw [hf2] at haj\n            exact hja haj\n          rw [Function.update_apply, if_neg hjf1]\n          simp only [Function.comp_apply, Fin.succ_inj]\n          rw [f.1.2]\n    \u00b7 simp only [succ_eq_add_one, hs, Bool.false_eq_true, \u2193reduceDIte]\n      intro i\n      rcases Fin.eq_zero_or_eq_succ i with hi | \u27e8j, hj\u27e9\n      \u00b7 subst hi\n        simp\n      \u00b7 subst hj\n        simp only [Fin.cons_succ, Function.comp_apply, Fin.succ_inj]\n        rw [f.1.2]\u27e9\n  left_inv f := by\n    match f with\n    | \u27e8f, hf\u27e9 =>\n    simp only [succ_eq_add_one, Option.isSome_dite', Option.get_dite', Fin.succ_pred,\n      Fin.cons_update, dite_eq_ite, ite_not, Subtype.mk.injEq]\n    ext i\n    by_cases h0 : f 0 = 0\n    \u00b7 simp only [h0, \u2193reduceIte]\n      rcases Fin.eq_zero_or_eq_succ i with hi | \u27e8j, hj\u27e9\n      \u00b7 subst hi\n        simp [h0]\n      \u00b7 subst hj\n        simp only [Fin.cons_succ, Function.comp_apply, Fin.val_succ]\n        by_cases hj : f j.succ =0\n        \u00b7 rw [\u2190 h0] at hj\n          have hn := Function.Involutive.injective hf hj\n          exact False.elim (Fin.succ_ne_zero j hn)\n        \u00b7 simp only [hj, \u2193reduceDIte, Fin.coe_pred]\n          rw [Fin.ext_iff] at hj\n          simp only [succ_eq_add_one, Fin.val_zero] at hj\n          omega\n    \u00b7 rw [if_neg h0]\n      by_cases hf' : i = f 0\n      \u00b7 subst hf'\n        simp only [Function.update_self, Fin.val_zero]\n        rw [hf]\n        simp\n      \u00b7 rw [Function.update_apply, if_neg hf']\n        rcases Fin.eq_zero_or_eq_succ i with hi | \u27e8j, hj\u27e9\n        \u00b7 subst hi\n          simp\n        \u00b7 subst hj\n          simp only [Fin.cons_succ, Function.comp_apply, Fin.val_succ]\n          by_cases hj : f j.succ =0\n          \u00b7 rw [\u2190 hj] at hf'\n            rw [hf] at hf'\n            simp only [not_true_eq_false] at hf'\n          \u00b7 simp only [hj, \u2193reduceDIte, Fin.coe_pred]\n            rw [Fin.ext_iff] at hj\n            simp only [succ_eq_add_one, Fin.val_zero] at hj\n            omega\n  right_inv f := by\n    match f with\n    | \u27e8\u27e8f, hf\u27e9, \u27e8f0, hf0\u27e9\u27e9 =>\n    ext i\n    \u00b7 simp only [succ_eq_add_one, Fin.cons_update]\n      by_cases hs : f0.isSome\n      \u00b7 simp only [hs, \u2193reduceDIte]\n        by_cases hi : i = f0.get hs\n        \u00b7 simp only [Function.update_apply, hi, \u2193reduceIte, \u2193reduceDIte]\n          exact Eq.symm (Fin.val_eq_of_eq (hf0 hs))\n        \u00b7 simp only [ne_eq, Fin.succ_inj, hi, not_false_eq_true, Function.update_of_ne,\n          Fin.cons_succ, Function.comp_apply, Fin.pred_succ, dite_eq_ite]\n          split\n          \u00b7 rename_i h\n            exact False.elim (Fin.succ_ne_zero (f i) h)\n          \u00b7 rfl\n      \u00b7 simp only [hs, Bool.false_eq_true, \u2193reduceDIte, Fin.cons_succ, Function.comp_apply,\n        Fin.pred_succ, dite_eq_ite]\n        split\n        \u00b7 rename_i h\n          exact False.elim (Fin.succ_ne_zero (f i) h)\n        \u00b7 rfl\n    \u00b7 simp only [Nat.succ_eq_add_one, Option.mem_def,\n      Option.dite_none_left_eq_some, Option.some.injEq]\n      by_cases hs : f0.isSome\n      \u00b7 simp only [hs, \u2193reduceDIte]\n        simp only [Fin.cons_zero, Fin.pred_succ, exists_prop]\n        have hx : \u00ac (f0.get hs).succ = 0 := (Fin.succ_ne_zero (f0.get hs))\n        simp only [hx, not_false_eq_true, true_and]\n        refine Iff.intro (fun hi => ?_) (fun hi => ?_)\n        \u00b7 rw [\u2190 hi]\n          exact\n            Option.eq_some_of_isSome\n              (Eq.mpr_prop (Eq.refl (f0.isSome = true))\n                (of_eq_true (Eq.trans (congrArg (fun x => x = true) hs) (eq_self true))))\n        \u00b7 subst hi\n          exact rfl\n      \u00b7 simp only [hs, Bool.false_eq_true, \u2193reduceDIte, Fin.cons_zero, not_true_eq_false,\n        IsEmpty.exists_iff, false_iff]\n        simp only [Bool.not_eq_true, Option.not_isSome, Option.isNone_iff_eq_none] at hs\n        subst hs\n        exact ne_of_beq_false rfl\n\nlemma involutionCons_ext {n : \u2115} {f1 f2 : (f : {f : Fin n \u2192 Fin n // Function.Involutive f}) \u00d7\n    {i : Option (Fin n) // \u2200 (h : i.isSome), f.1 (Option.get i h) = (Option.get i h)}}\n    (h1 : f1.1 = f2.1) (h2 : f1.2 = Equiv.subtypeEquivRight (by rw [h1]; simp) f2.2) : f1 = f2 := by\n  cases f1\n  cases f2\n  simp only at h1 h2\n  subst h1\n  rename_i fst snd snd_1\n  simp_all only [Sigma.mk.inj_iff, heq_eq_eq, true_and]\n  obtain \u27e8val, property\u27e9 := fst\n  obtain \u27e8val_1, property_1\u27e9 := snd\n  obtain \u27e8val_2, property_2\u27e9 := snd_1\n  simp_all only\n  rfl\n\n/-- Given an involution of `Fin n`, the optional choice of an element in `Fin n` which\n  maps to itself is equivalent to the optional choice of an element in\n  `Fin (Finset.univ.filter fun i => f.1 i = i).card`. -/\ndef involutionAddEquiv {n : \u2115} (f : {f : Fin n \u2192 Fin n // Function.Involutive f}) :\n    {i : Option (Fin n) // \u2200 (h : i.isSome), f.1 (Option.get i h) = (Option.get i h)} \u2243\n    Option (Fin (Finset.univ.filter fun i => f.1 i = i).card) := by\n  let e1 : {i : Option (Fin n) // \u2200 (h : i.isSome), f.1 (Option.get i h) = (Option.get i h)}\n        \u2243 Option {i : Fin n // f.1 i = i} :=\n    { toFun := fun i => match i with\n        | \u27e8some i, h\u27e9 => some \u27e8i, by simpa using h\u27e9\n        | \u27e8none, h\u27e9 => none\n      invFun := fun i => match i with\n        | some \u27e8i, h\u27e9 => \u27e8some i, by simpa using h\u27e9\n        | none => \u27e8none, by simp\u27e9\n      left_inv := by\n        intro a\n        cases a\n        aesop\n      right_inv := by\n        intro a\n        cases a\n        rfl\n        simp_all only [Subtype.coe_eta] }\n  let s : Finset (Fin n) := Finset.univ.filter fun i => f.1 i = i\n  let e2' : { i : Fin n // f.1 i = i} \u2243 {i // i \u2208 s} := by\n    apply Equiv.subtypeEquivProp\n    simp [s]\n  let e2 : {i // i \u2208 s} \u2243 Fin (Finset.card s) := by\n    refine (Finset.orderIsoOfFin _ ?_).symm.toEquiv\n    simp [s]\n  refine e1.trans (Equiv.optionCongr (e2'.trans (e2)))\n\nlemma involutionAddEquiv_none_image_zero {n : \u2115} :\n    {f : {f : Fin n.succ \u2192 Fin n.succ // Function.Involutive f}}\n    \u2192 involutionAddEquiv (involutionCons n f).1 (involutionCons n f).2 = none\n    \u2192 f.1 \u27e80, Nat.zero_lt_succ n\u27e9 = \u27e80, Nat.zero_lt_succ n\u27e9 := by\n  intro f h\n  simp only [Nat.succ_eq_add_one, involutionCons, Equiv.coe_fn_mk, involutionAddEquiv,\n    Option.isSome_some, Option.get_some, Option.isSome_none, Equiv.trans_apply,\n    Equiv.optionCongr_apply, Equiv.coe_trans, RelIso.coe_fn_toEquiv, Option.map_eq_none'] at h\n  simp_all only [List.length_cons, Fin.zero_eta]\n  obtain \u27e8val, property\u27e9 := f\n  simp_all only [List.length_cons]\n  split at h\n  next i i_1 h_1 heq =>\n    split at heq\n    next h_2 => simp_all only [reduceCtorEq]\n    next h_2 => simp_all only [reduceCtorEq]\n  next i h_1 heq =>\n    split at heq\n    next h_2 => simp_all only\n    next h_2 => simp_all only [Subtype.mk.injEq, reduceCtorEq]\n\n", "theoremStatement": "lemma involutionAddEquiv_cast {n : \u2115} {f1 f2 : {f : Fin n \u2192 Fin n // Function.Involutive f}}\n    (hf : f1 = f2) :\n    involutionAddEquiv f1 = (Equiv.subtypeEquivRight (by rw [hf]; simp)).trans\n      ((involutionAddEquiv f2).trans (Equiv.optionCongr (finCongr (by rw [hf])))) ", "theoremName": "HepLean.Fin.involutionAddEquiv_cast", "fileCreated": {"commit": "1ab0c6f76904b49d21f9c1e09d26746f52caa4eb", "date": "2025-01-05"}, "theoremCreated": {"commit": "1ab0c6f76904b49d21f9c1e09d26746f52caa4eb", "date": "2025-01-05"}, "file": "HepLean/HepLean/Mathematics/Fin/Involutions.lean", "module": "HepLean.Mathematics.Fin.Involutions", "jsonFile": "HepLean.Mathematics.Fin.Involutions.jsonl", "positionMetadata": {"lineInFile": 239, "tokenPositionInFile": 9173, "theoremPositionInFile": 3}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 1, "numPremises": 38}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  subst hf\n  rw [finCongr_refl, Equiv.optionCongr_refl]\n  rfl", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 67}}
{"srcContext": "/-\nCopyright (c) 2024 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.Koszul.KoszulSignInsert\nimport HepLean.Mathematics.List.InsertionSort\n/-!\n\n# Koszul sign\n\n-/\n\nnamespace Wick\n\nopen HepLean.List\nopen FieldStatistic\n\nvariable {\ud835\udcd5 : Type} (q : \ud835\udcd5 \u2192 FieldStatistic) (le : \ud835\udcd5 \u2192 \ud835\udcd5 \u2192 Prop) [DecidableRel le]\n\n/-- Gives a factor of `- 1` for every fermion-fermion (`q` is `1`) crossing that occurs when sorting\n  a list of based on `r`. -/\ndef koszulSign (q : \ud835\udcd5 \u2192 FieldStatistic) (le : \ud835\udcd5 \u2192 \ud835\udcd5 \u2192 Prop) [DecidableRel le] :\n    List \ud835\udcd5 \u2192 \u2102\n  | [] => 1\n  | a :: l => koszulSignInsert q le a l * koszulSign q le l\n\n@[simp]\nlemma koszulSign_singleton (q : \ud835\udcd5 \u2192 FieldStatistic) (le : \ud835\udcd5 \u2192 \ud835\udcd5 \u2192 Prop) [DecidableRel le] (\u03c6 : \ud835\udcd5) :\n    koszulSign q le [\u03c6] = 1 := by\n  simp [koszulSign, koszulSignInsert]\n\nlemma koszulSign_mul_self (l : List \ud835\udcd5) : koszulSign q le l * koszulSign q le l = 1 := by\n  induction l with\n  | nil => simp [koszulSign]\n  | cons a l ih =>\n    simp only [koszulSign]\n    trans (koszulSignInsert q le a l * koszulSignInsert q le a l) *\n      (koszulSign q le l * koszulSign q le l)\n    \u00b7 ring\n    \u00b7 rw [ih, koszulSignInsert_mul_self, mul_one]\n\n@[simp]\nlemma koszulSign_freeMonoid_of (\u03c6 : \ud835\udcd5) : koszulSign q le (FreeMonoid.of \u03c6) = 1 := by\n  change koszulSign q le [\u03c6] = 1\n  simp only [koszulSign, mul_one]\n  rfl\n\nlemma koszulSignInsert_erase_boson {\ud835\udcd5 : Type} (q : \ud835\udcd5 \u2192 FieldStatistic)\n    (le : \ud835\udcd5 \u2192 \ud835\udcd5 \u2192 Prop) [DecidableRel le] (\u03c6 : \ud835\udcd5) :\n    (\u03c6s : List \ud835\udcd5) \u2192 (n : Fin \u03c6s.length) \u2192 (heq : q (\u03c6s.get n) = bosonic) \u2192\n    koszulSignInsert q le \u03c6 (\u03c6s.eraseIdx n) = koszulSignInsert q le \u03c6 \u03c6s\n  | [], _, _ => by\n    simp\n  | r1 :: r, \u27e80, h\u27e9, hr => by\n    simp only [List.eraseIdx_zero, List.tail_cons]\n    simp only [List.length_cons, Fin.zero_eta, List.get_eq_getElem, Fin.val_zero,\n      List.getElem_cons_zero] at hr\n    rw [koszulSignInsert]\n    simp [hr]\n  | r1 :: r, \u27e8n + 1, h\u27e9, hr => by\n    simp only [List.eraseIdx_cons_succ]\n    rw [koszulSignInsert, koszulSignInsert]\n    rw [koszulSignInsert_erase_boson q le \u03c6 r \u27e8n, Nat.succ_lt_succ_iff.mp h\u27e9 hr]\n\nlemma koszulSign_erase_boson {\ud835\udcd5 : Type} (q : \ud835\udcd5 \u2192 FieldStatistic) (le : \ud835\udcd5 \u2192 \ud835\udcd5 \u2192 Prop)\n    [DecidableRel le] :\n    (\u03c6s : List \ud835\udcd5) \u2192 (n : Fin \u03c6s.length) \u2192 (heq : q (\u03c6s.get n) = bosonic) \u2192\n    koszulSign q le (\u03c6s.eraseIdx n) = koszulSign q le \u03c6s\n  | [], _ => by\n    simp\n  | \u03c6 :: \u03c6s, \u27e80, h\u27e9 => by\n    simp only [List.length_cons, Fin.zero_eta, List.get_eq_getElem, Fin.val_zero,\n      List.getElem_cons_zero, Fin.isValue, List.eraseIdx_zero, List.tail_cons, koszulSign]\n    intro h\n    rw [koszulSignInsert_boson]\n    simp only [one_mul]\n    exact h\n  | \u03c6 :: \u03c6s, \u27e8n + 1, h\u27e9 => by\n    simp only [List.length_cons, List.get_eq_getElem, List.getElem_cons_succ, Fin.isValue,\n      List.eraseIdx_cons_succ]\n    intro h'\n    rw [koszulSign, koszulSign, koszulSign_erase_boson q le \u03c6s \u27e8n, Nat.succ_lt_succ_iff.mp h\u27e9]\n    congr 1\n    rw [koszulSignInsert_erase_boson q le \u03c6 \u03c6s \u27e8n, Nat.succ_lt_succ_iff.mp h\u27e9 h']\n    exact h'\n\nlemma koszulSign_insertIdx [IsTotal \ud835\udcd5 le] [IsTrans \ud835\udcd5 le] (\u03c6 : \ud835\udcd5) :\n    (\u03c6s : List \ud835\udcd5) \u2192 (n : \u2115) \u2192 (hn : n \u2264 \u03c6s.length) \u2192\n    koszulSign q le (List.insertIdx n \u03c6 \u03c6s) = \ud835\udce2(q \u03c6, ofList q (\u03c6s.take n)) * koszulSign q le \u03c6s *\n      \ud835\udce2(q \u03c6, ofList q ((List.insertionSort le (List.insertIdx n \u03c6 \u03c6s)).take\n      (insertionSortEquiv le (List.insertIdx n \u03c6 \u03c6s) \u27e8n, by\n        rw [List.length_insertIdx _ _]\n        simp only [hn, \u2193reduceIte]\n        omega\u27e9)))\n  | [], 0, h => by\n    simp [koszulSign, koszulSignInsert]\n  | [], n + 1, h => by\n    simp at h\n  | \u03c61 :: \u03c6s, 0, h => by\n    simp only [List.insertIdx_zero, List.insertionSort, List.length_cons, Fin.zero_eta]\n    rw [koszulSign]\n    trans koszulSign q le (\u03c61 :: \u03c6s) * koszulSignInsert q le \u03c6 (\u03c61 :: \u03c6s)\n    ring\n    simp only [insertionSortEquiv, List.length_cons, Nat.succ_eq_add_one, List.insertionSort,\n      orderedInsertEquiv, OrderIso.toEquiv_symm, Fin.symm_castOrderIso, HepLean.Fin.equivCons_trans,\n      Equiv.trans_apply, HepLean.Fin.equivCons_zero, HepLean.Fin.finExtractOne_apply_eq,\n      Fin.isValue, HepLean.Fin.finExtractOne_symm_inl_apply, RelIso.coe_fn_toEquiv,\n      Fin.castOrderIso_apply, Fin.cast_mk, Fin.eta]\n    conv_rhs =>\n      enter [2,2, 2, 2]\n      rw [orderedInsert_eq_insertIdx_orderedInsertPos]\n    conv_rhs =>\n      rhs\n      rw [\u2190 ofList_take_insert]\n      change \ud835\udce2(q \u03c6, ofList q ((List.insertionSort le (\u03c61 :: \u03c6s)).take\n        (\u2191(orderedInsertPos le ((List.insertionSort le (\u03c61 :: \u03c6s))) \u03c6))))\n      rw [\u2190 koszulSignInsert_eq_exchangeSign_take q le]\n    rw [ofList_take_zero]\n    simp\n  | \u03c61 :: \u03c6s, n + 1, h => by\n    conv_lhs =>\n      rw [List.insertIdx_succ_cons]\n      rw [koszulSign]\n    rw [koszulSign_insertIdx]\n    conv_rhs =>\n      rhs\n      simp only [List.insertIdx_succ_cons]\n      simp only [List.insertionSort, List.length_cons, insertionSortEquiv, Nat.succ_eq_add_one,\n        Equiv.trans_apply, HepLean.Fin.equivCons_succ]\n      erw [orderedInsertEquiv_fin_succ]\n      simp only [Fin.eta, Fin.coe_cast]\n      rhs\n      simp [orderedInsert_eq_insertIdx_orderedInsertPos]\n    conv_rhs =>\n      lhs\n      rw [ofList_take_succ_cons, map_mul, koszulSign]\n    ring_nf\n    conv_lhs =>\n      lhs\n      rw [mul_assoc, mul_comm]\n    rw [mul_assoc]\n    conv_rhs =>\n      rw [mul_assoc, mul_assoc]\n    congr 1\n    let rs := (List.insertionSort le (List.insertIdx n \u03c6 \u03c6s))\n    have hnsL : n < (List.insertIdx n \u03c6 \u03c6s).length := by\n      rw [List.length_insertIdx _ _]\n      simp only [List.length_cons, add_le_add_iff_right] at h\n      simp only [h, \u2193reduceIte]\n      omega\n    let ni : Fin rs.length := (insertionSortEquiv le (List.insertIdx n \u03c6 \u03c6s))\n      \u27e8n, hnsL\u27e9\n    let nro : Fin (rs.length + 1) :=\n      \u27e8\u2191(orderedInsertPos le rs \u03c61), orderedInsertPos_lt_length le rs \u03c61\u27e9\n    rw [koszulSignInsert_insertIdx, koszulSignInsert_cons]\n    trans koszulSignInsert q le \u03c61 \u03c6s * (koszulSignCons q le \u03c61 \u03c6 *\n      \ud835\udce2(q \u03c6, ofList q (rs.take ni)))\n    \u00b7 simp only [rs, ni]\n      ring\n    trans koszulSignInsert q le \u03c61 \u03c6s * (\ud835\udce2(q \u03c6, q \u03c61) *\n          \ud835\udce2(q \u03c6, ofList q ((List.insertIdx nro \u03c61 rs).take (nro.succAbove ni))))\n    swap\n    \u00b7 simp only [rs, nro, ni]\n      ring\n    congr 1\n    simp only [Fin.succAbove]\n    have hns : rs.get ni = \u03c6 := by\n      simp only [Fin.eta, rs]\n      rw [\u2190 insertionSortEquiv_get]\n      simp only [Function.comp_apply, Equiv.symm_apply_apply, List.get_eq_getElem, ni]\n      simp_all only [List.length_cons, add_le_add_iff_right, List.getElem_insertIdx_self]\n    have hc1 (hninro : ni.castSucc < nro) : \u00ac le \u03c61 \u03c6 := by\n      rw [\u2190 hns]\n      exact lt_orderedInsertPos_rel le \u03c61 rs ni hninro\n    have hc2 (hninro : \u00ac ni.castSucc < nro) : le \u03c61 \u03c6 := by\n      rw [\u2190 hns]\n      refine gt_orderedInsertPos_rel le \u03c61 rs ?_ ni hninro\n      exact List.sorted_insertionSort le (List.insertIdx n \u03c6 \u03c6s)\n    by_cases hn : ni.castSucc < nro\n    \u00b7 simp only [hn, \u2193reduceIte, Fin.coe_castSucc]\n      rw [ofList_take_insertIdx_gt]\n      swap\n      \u00b7 exact hn\n      congr 1\n      rw [koszulSignCons_eq_exchangeSign]\n      simp only [hc1 hn, \u2193reduceIte]\n      rw [exchangeSign_symm]\n    \u00b7 simp only [hn, \u2193reduceIte, Fin.val_succ]\n      rw [ofList_take_insertIdx_le, map_mul, \u2190 mul_assoc]\n      congr 1\n      rw [exchangeSign_mul_self, koszulSignCons]\n      simp only [hc2 hn, \u2193reduceIte]\n      exact Nat.le_of_not_lt hn\n      exact Nat.le_of_lt_succ (orderedInsertPos_lt_length le rs \u03c61)\n    \u00b7 exact Nat.le_of_lt_succ h\n    \u00b7 exact Nat.le_of_lt_succ h\n\nlemma insertIdx_eraseIdx {I : Type} : (n : \u2115) \u2192 (r : List I) \u2192 (hn : n < r.length) \u2192\n    List.insertIdx n (r.get \u27e8n, hn\u27e9) (r.eraseIdx n) = r\n  | n, [], hn => by\n    simp at hn\n  | 0, r0 :: r, hn => by\n    simp\n  | n + 1, r0 :: r, hn => by\n    simp only [List.length_cons, List.get_eq_getElem, List.getElem_cons_succ,\n      List.eraseIdx_cons_succ, List.insertIdx_succ_cons, List.cons.injEq, true_and]\n    exact insertIdx_eraseIdx n r _\n\nlemma koszulSign_eraseIdx [IsTotal \ud835\udcd5 le] [IsTrans \ud835\udcd5 le] (\u03c6s : List \ud835\udcd5) (n : Fin \u03c6s.length) :\n    koszulSign q le (\u03c6s.eraseIdx n) = koszulSign q le \u03c6s * \ud835\udce2(q (\u03c6s.get n), ofList q (\u03c6s.take n)) *\n    \ud835\udce2(q (\u03c6s.get n), ofList q (List.take (\u2191(insertionSortEquiv le \u03c6s n))\n    (List.insertionSort le \u03c6s))) := by\n  let \u03c6s' := \u03c6s.eraseIdx \u2191n\n  have h\u03c6s : List.insertIdx n (\u03c6s.get n) \u03c6s' = \u03c6s := by\n    exact insertIdx_eraseIdx n.1 \u03c6s n.prop\n  conv_rhs =>\n    lhs\n    lhs\n    rw [\u2190 h\u03c6s]\n    rw [koszulSign_insertIdx q le (\u03c6s.get n) ((\u03c6s.eraseIdx \u2191n)) n (by\n      rw [List.length_eraseIdx]\n      simp only [Fin.is_lt, \u2193reduceIte]\n      omega)]\n    rhs\n    enter [2, 2, 2]\n    rw [h\u03c6s]\n  conv_rhs =>\n    enter [1, 1, 2, 2, 2, 1, 1]\n    rw [insertionSortEquiv_congr _ _ h\u03c6s]\n  simp only [instCommGroup.eq_1, List.get_eq_getElem, Equiv.trans_apply, RelIso.coe_fn_toEquiv,\n    Fin.castOrderIso_apply, Fin.cast_mk, Fin.eta, Fin.coe_cast]\n  trans koszulSign q le (\u03c6s.eraseIdx \u2191n) *\n    (\ud835\udce2(q \u03c6s[\u2191n], ofList q ((\u03c6s.eraseIdx \u2191n).take n)) * \ud835\udce2(q \u03c6s[\u2191n], ofList q (List.take (\u2191n) \u03c6s))) *\n    (\ud835\udce2(q \u03c6s[\u2191n], ofList q ((List.insertionSort le \u03c6s).take (\u2191((insertionSortEquiv le \u03c6s) n)))) *\n    \ud835\udce2(q \u03c6s[\u2191n], ofList q (List.take (\u2191((insertionSortEquiv le \u03c6s) n)) (List.insertionSort le \u03c6s))))\n  swap\n  \u00b7 simp only [Fin.getElem_fin]\n    rw [Equiv.trans_apply, Equiv.trans_apply]\n    simp only [instCommGroup.eq_1, mul_one, Fin.castOrderIso,\n      Equiv.coe_fn_mk, Fin.cast_mk, Fin.eta, Fin.coe_cast]\n    ring\n  conv_rhs =>\n    rhs\n    rw [exchangeSign_mul_self]\n  simp only [instCommGroup.eq_1, Fin.getElem_fin, mul_one]\n  conv_rhs =>\n    rhs\n    rw [ofList_take_eraseIdx, exchangeSign_mul_self]\n  simp\n\nlemma koszulSign_eraseIdx_insertionSortMinPos [IsTotal \ud835\udcd5 le] [IsTrans \ud835\udcd5 le] (\u03c6 : \ud835\udcd5) (\u03c6s : List \ud835\udcd5) :\n    koszulSign q le ((\u03c6 :: \u03c6s).eraseIdx (insertionSortMinPos le \u03c6 \u03c6s)) = koszulSign q le (\u03c6 :: \u03c6s)\n    * \ud835\udce2(q (insertionSortMin le \u03c6 \u03c6s), ofList q ((\u03c6 :: \u03c6s).take (insertionSortMinPos le \u03c6 \u03c6s))) := by\n  rw [koszulSign_eraseIdx]\n  conv_lhs =>\n    rhs\n    rhs\n    lhs\n    simp [insertionSortMinPos]\n  erw [Equiv.apply_symm_apply]\n  simp only [instCommGroup.eq_1, List.get_eq_getElem, List.length_cons, List.insertionSort,\n    List.take_zero, ofList_empty, exchangeSign_bosonic, mul_one, mul_eq_mul_left_iff]\n  apply Or.inl\n  rfl\n\nlemma koszulSign_swap_eq_rel_cons {\u03c8 \u03c6 : \ud835\udcd5}\n    (h1 : le \u03c6 \u03c8) (h2 : le \u03c8 \u03c6) (\u03c6s' : List \ud835\udcd5) :\n    koszulSign q le (\u03c6 :: \u03c8 :: \u03c6s') = koszulSign q le (\u03c8 :: \u03c6 :: \u03c6s') := by\n  simp only [Wick.koszulSign, \u2190 mul_assoc, mul_eq_mul_right_iff]\n  left\n  rw [mul_comm]\n  simp [Wick.koszulSignInsert, h1, h2]\n\nlemma koszulSign_swap_eq_rel {\u03c8 \u03c6 : \ud835\udcd5} (h1 : le \u03c6 \u03c8) (h2 : le \u03c8 \u03c6) : (\u03c6s \u03c6s' : List \ud835\udcd5) \u2192\n    koszulSign q le (\u03c6s ++ \u03c6 :: \u03c8 :: \u03c6s') = koszulSign q le (\u03c6s ++ \u03c8 :: \u03c6 :: \u03c6s')\n  | [], \u03c6s' => by\n    simp only [List.nil_append]\n    exact koszulSign_swap_eq_rel_cons q le h1 h2 \u03c6s'\n  | \u03c6'' :: \u03c6s, \u03c6s' => by\n    simp only [List.cons_append, koszulSign]\n    rw [koszulSign_swap_eq_rel h1 h2]\n    congr 1\n    apply Wick.koszulSignInsert_eq_perm\n    exact List.Perm.append_left \u03c6s (List.Perm.swap \u03c8 \u03c6 \u03c6s')\n\nlemma koszulSign_eq_rel_eq_stat_append {\u03c8 \u03c6 : \ud835\udcd5} [IsTrans \ud835\udcd5 le]\n    (h1 : le \u03c6 \u03c8) (h2 : le \u03c8 \u03c6) (hq : q \u03c8 = q \u03c6) : (\u03c6s : List \ud835\udcd5) \u2192\n    koszulSign q le (\u03c6 :: \u03c8 :: \u03c6s) = koszulSign q le \u03c6s := by\n  intro \u03c6s\n  simp only [koszulSign, \u2190 mul_assoc]\n  trans 1 * koszulSign q le \u03c6s\n  swap\n  simp only [one_mul]\n  congr\n  simp only [koszulSignInsert, ite_mul, neg_mul]\n  simp_all only [and_self, ite_true]\n  rw [koszulSignInsert_eq_rel_eq_stat q le h1 h2 hq]\n  simp\n\nlemma koszulSign_eq_rel_eq_stat {\u03c8 \u03c6 : \ud835\udcd5} [IsTrans \ud835\udcd5 le]\n    (h1 : le \u03c6 \u03c8) (h2 : le \u03c8 \u03c6) (hq : q \u03c8 = q \u03c6) : (\u03c6s' \u03c6s : List \ud835\udcd5) \u2192\n    koszulSign q le (\u03c6s' ++ \u03c6 :: \u03c8 :: \u03c6s) = koszulSign q le (\u03c6s' ++ \u03c6s)\n  | [], \u03c6s => by\n    simp only [List.nil_append]\n    exact koszulSign_eq_rel_eq_stat_append q le h1 h2 hq \u03c6s\n  | \u03c6'' :: \u03c6s', \u03c6s => by\n    simp only [List.cons_append, koszulSign]\n    rw [koszulSign_eq_rel_eq_stat h1 h2 hq \u03c6s' \u03c6s]\n    simp only [mul_eq_mul_right_iff]\n    left\n    trans koszulSignInsert q le \u03c6'' (\u03c6 :: \u03c8 :: (\u03c6s' ++ \u03c6s))\n    apply koszulSignInsert_eq_perm\n    refine List.Perm.symm (List.perm_cons_append_cons \u03c6 ?_)\n    exact List.Perm.symm List.perm_middle\n    rw [koszulSignInsert_eq_remove_same_stat_append q le]\n    exact h1\n    exact h2\n    exact hq\n\nlemma koszulSign_of_sorted : (\u03c6s : List \ud835\udcd5)\n    \u2192 (hs : List.Sorted le \u03c6s) \u2192 koszulSign q le \u03c6s = 1\n  | [], _ => by\n    simp [koszulSign]\n  | \u03c6 :: \u03c6s, h => by\n    simp only [koszulSign]\n    simp only [List.sorted_cons] at h\n    rw [koszulSign_of_sorted \u03c6s h.2]\n    simp only [mul_one]\n    exact koszulSignInsert_of_le_mem _ _ _ _ h.1\n\n@[simp]\nlemma koszulSign_of_insertionSort [IsTotal \ud835\udcd5 le] [IsTrans \ud835\udcd5 le] (\u03c6s : List \ud835\udcd5) :\n    koszulSign q le (List.insertionSort le \u03c6s) = 1 := by\n  apply koszulSign_of_sorted\n  exact List.sorted_insertionSort le \u03c6s\n\nlemma koszulSign_of_append_eq_insertionSort_left [IsTotal \ud835\udcd5 le] [IsTrans \ud835\udcd5 le] :\n    (\u03c6s \u03c6s' : List \ud835\udcd5) \u2192 koszulSign q le (\u03c6s ++ \u03c6s') =\n    koszulSign q le (List.insertionSort le \u03c6s ++ \u03c6s') * koszulSign q le \u03c6s\n  | \u03c6s, [] => by\n    simp\n  | \u03c6s, \u03c6 :: \u03c6s' => by\n    have h1 : (\u03c6s ++ \u03c6 :: \u03c6s') = List.insertIdx \u03c6s.length \u03c6 (\u03c6s ++ \u03c6s') := by\n      rw [insertIdx_length_fst_append]\n    have h2 : (List.insertionSort le \u03c6s ++ \u03c6 :: \u03c6s') =\n        List.insertIdx (List.insertionSort le \u03c6s).length \u03c6 (List.insertionSort le \u03c6s ++ \u03c6s') := by\n      rw [insertIdx_length_fst_append]\n    rw [h1, h2]\n    rw [koszulSign_insertIdx]\n    simp only [instCommGroup.eq_1, List.take_left', List.length_insertionSort]\n    rw [koszulSign_insertIdx]\n    simp only [mul_assoc, instCommGroup.eq_1, List.length_insertionSort, List.take_left',\n      ofList_insertionSort, mul_eq_mul_left_iff]\n    left\n    rw [koszulSign_of_append_eq_insertionSort_left \u03c6s \u03c6s']\n    simp only [mul_assoc, mul_eq_mul_left_iff]\n    left\n    simp only [mul_comm, mul_eq_mul_left_iff]\n    left\n    congr 3\n    \u00b7 have h2 : (List.insertionSort le \u03c6s ++ \u03c6 :: \u03c6s') =\n          List.insertIdx \u03c6s.length \u03c6 (List.insertionSort le \u03c6s ++ \u03c6s') := by\n        rw [\u2190 insertIdx_length_fst_append]\n        simp\n      rw [insertionSortEquiv_congr _ _ h2.symm]\n      simp only [Equiv.trans_apply, RelIso.coe_fn_toEquiv, Fin.castOrderIso_apply, Fin.cast_mk,\n        Fin.coe_cast]\n      rw [insertionSortEquiv_insertionSort_append]\n      simp only [finCongr_apply, Fin.coe_cast]\n      rw [insertionSortEquiv_congr _ _ h1.symm]\n      simp\n    \u00b7 rw [insertIdx_length_fst_append]\n      rw [show \u03c6s.length = (List.insertionSort le \u03c6s).length by simp]\n      rw [insertIdx_length_fst_append]\n      symm\n      apply insertionSort_insertionSort_append\n    \u00b7 simp\n    \u00b7 simp\n\nlemma koszulSign_of_append_eq_insertionSort [IsTotal \ud835\udcd5 le] [IsTrans \ud835\udcd5 le] : (\u03c6s'' \u03c6s \u03c6s' : List \ud835\udcd5) \u2192\n    koszulSign q le (\u03c6s'' ++ \u03c6s ++ \u03c6s') =\n    koszulSign q le (\u03c6s'' ++ List.insertionSort le \u03c6s ++ \u03c6s') * koszulSign q le \u03c6s\n  | [], \u03c6s, \u03c6s'=> by\n    simp only [List.nil_append]\n    exact koszulSign_of_append_eq_insertionSort_left q le \u03c6s \u03c6s'\n  | \u03c6'' :: \u03c6s'', \u03c6s, \u03c6s' => by\n    simp only [List.cons_append, koszulSign]\n    rw [koszulSign_of_append_eq_insertionSort \u03c6s'' \u03c6s \u03c6s', \u2190 mul_assoc]\n    congr 2\n    apply koszulSignInsert_eq_perm\n    refine (List.perm_append_right_iff \u03c6s').mpr ?_\n    refine List.Perm.append_left \u03c6s'' ?_\n    exact List.Perm.symm (List.perm_insertionSort le \u03c6s)\n\n/-!\n\n# koszulSign with permutations\n\n-/\n\n", "theoremStatement": "lemma koszulSign_perm_eq_append [IsTrans \ud835\udcd5 le] (\u03c6 : \ud835\udcd5) (\u03c6s \u03c6s' \u03c6s2 : List \ud835\udcd5)\n    (hp : \u03c6s.Perm \u03c6s') : (h : \u2200 \u03c6' \u2208 \u03c6s, le \u03c6 \u03c6' \u2227 le \u03c6' \u03c6) \u2192\n    koszulSign q le (\u03c6s ++ \u03c6s2) = koszulSign q le (\u03c6s' ++ \u03c6s2) ", "theoremName": "Wick.koszulSign_perm_eq_append", "fileCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "theoremCreated": {"commit": "c2d89cc093bf5dd434a6370089300f103d249974", "date": "2025-01-29"}, "file": "HepLean/HepLean/PerturbationTheory/Koszul/KoszulSign.lean", "module": "HepLean.PerturbationTheory.Koszul.KoszulSign", "jsonFile": "HepLean.PerturbationTheory.Koszul.KoszulSign.jsonl", "positionMetadata": {"lineInFile": 402, "tokenPositionInFile": 15357, "theoremPositionInFile": 8}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 5, "numPremises": 75}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  let motive (\u03c6s \u03c6s' : List \ud835\udcd5) (hp : \u03c6s.Perm \u03c6s') : Prop :=\n    (h : \u2200 \u03c6' \u2208 \u03c6s, le \u03c6 \u03c6' \u2227 le \u03c6' \u03c6) \u2192\n    koszulSign q le (\u03c6s ++ \u03c6s2) = koszulSign q le (\u03c6s' ++ \u03c6s2)\n  change motive \u03c6s \u03c6s' hp\n  apply List.Perm.recOn\n  \u00b7 simp [motive]\n  \u00b7 intro x l1 l2 h ih hx\u03c6\n    simp_all only [List.mem_cons, or_true, and_self, implies_true, nonempty_prop, forall_const,\n      forall_eq_or_imp, List.cons_append, motive]\n    simp only [koszulSign, ih, mul_eq_mul_right_iff]\n    left\n    apply koszulSignInsert_eq_perm\n    exact (List.perm_append_right_iff \u03c6s2).mpr h\n  \u00b7 intro x y l h\n    simp_all only [List.mem_cons, forall_eq_or_imp, List.cons_append]\n    apply Wick.koszulSign_swap_eq_rel_cons\n    exact IsTrans.trans y \u03c6 x h.1.2 h.2.1.1\n    exact IsTrans.trans x \u03c6 y h.2.1.2 h.1.1\n  \u00b7 intro l1 l2 l3 h1 h2 ih1 ih2 h\n    simp_all only [and_self, implies_true, nonempty_prop, forall_const, motive]\n    refine (ih2 ?_)\n    intro \u03c6' h\u03c6\n    refine h \u03c6' ?_\n    exact (List.Perm.mem_iff (id (List.Perm.symm h1))).mp h\u03c6", "proofType": "tactic", "proofLengthLines": 24, "proofLengthTokens": 1006}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.TimeOrder\nimport HepLean.PerturbationTheory.FieldOpAlgebra.Basic\n/-!\n\n# SuperCommute on Field operator algebra\n\n-/\n\nnamespace FieldSpecification\nopen FieldOpFreeAlgebra\nopen HepLean.List\nopen FieldStatistic\n\nnamespace FieldOpAlgebra\nvariable {\ud835\udcd5 : FieldSpecification}\n\nlemma \u03b9_superCommuteF_eq_zero_of_\u03b9_right_zero (a b : \ud835\udcd5.FieldOpFreeAlgebra) (h : \u03b9 b = 0) :\n    \u03b9 [a, b]\u209bca = 0 := by\n  rw [superCommuteF_expand_bosonicProjF_fermionicProjF]\n  rw [\u03b9_eq_zero_iff_\u03b9_bosonicProjF_fermonicProj_zero] at h\n  simp_all\n\nlemma \u03b9_superCommuteF_eq_zero_of_\u03b9_left_zero (a b : \ud835\udcd5.FieldOpFreeAlgebra) (h : \u03b9 a = 0) :\n    \u03b9 [a, b]\u209bca = 0 := by\n  rw [superCommuteF_expand_bosonicProjF_fermionicProjF]\n  rw [\u03b9_eq_zero_iff_\u03b9_bosonicProjF_fermonicProj_zero] at h\n  simp_all\n\n/-!\n\n## Defining normal order for `FiedOpAlgebra`.\n\n-/\n\nlemma \u03b9_superCommuteF_right_zero_of_mem_ideal (a b : \ud835\udcd5.FieldOpFreeAlgebra)\n    (h : b \u2208 TwoSidedIdeal.span \ud835\udcd5.fieldOpIdealSet) : \u03b9 [a, b]\u209bca = 0 := by\n  apply \u03b9_superCommuteF_eq_zero_of_\u03b9_right_zero\n  exact (\u03b9_eq_zero_iff_mem_ideal b).mpr h\n\nlemma \u03b9_superCommuteF_eq_of_equiv_right (a b1 b2 : \ud835\udcd5.FieldOpFreeAlgebra) (h : b1 \u2248 b2) :\n    \u03b9 [a, b1]\u209bca = \u03b9 [a, b2]\u209bca := by\n  rw [equiv_iff_sub_mem_ideal] at h\n  rw [LinearMap.sub_mem_ker_iff.mp]\n  simp only [LinearMap.mem_ker, \u2190 map_sub]\n  exact \u03b9_superCommuteF_right_zero_of_mem_ideal a (b1 - b2) h\n\n/-- The super commutator on the `FieldOpAlgebra` defined as a linear map `[a,_]\u209b`. -/\nnoncomputable def superCommuteRight (a : \ud835\udcd5.FieldOpFreeAlgebra) :\n  FieldOpAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpAlgebra \ud835\udcd5 where\n  toFun := Quotient.lift (\u03b9.toLinearMap \u2218\u2097 superCommuteF a)\n    (\u03b9_superCommuteF_eq_of_equiv_right a)\n  map_add' x y := by\n    obtain \u27e8x, hx\u27e9 := \u03b9_surjective x\n    obtain \u27e8y, hy\u27e9 := \u03b9_surjective y\n    subst hx hy\n    rw [\u2190 map_add, \u03b9_apply, \u03b9_apply, \u03b9_apply]\n    rw [Quotient.lift_mk, Quotient.lift_mk, Quotient.lift_mk]\n    simp\n  map_smul' c y := by\n    obtain \u27e8y, hy\u27e9 := \u03b9_surjective y\n    subst hy\n    rw [\u2190 map_smul, \u03b9_apply, \u03b9_apply]\n    simp\n\nlemma superCommuteRight_apply_\u03b9 (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    superCommuteRight a (\u03b9 b) = \u03b9 [a, b]\u209bca := by rfl\n\nlemma superCommuteRight_apply_quot (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    superCommuteRight a \u27e6b\u27e7= \u03b9 [a, b]\u209bca := by rfl\n\nlemma superCommuteRight_eq_of_equiv (a1 a2 : \ud835\udcd5.FieldOpFreeAlgebra) (h : a1 \u2248 a2) :\n    superCommuteRight a1 = superCommuteRight a2 := by\n  rw [equiv_iff_sub_mem_ideal] at h\n  ext b\n  obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n  have ha1b1 : (superCommuteRight (a1 - a2)) (\u03b9 b) = 0 := by\n    rw [superCommuteRight_apply_\u03b9]\n    apply \u03b9_superCommuteF_eq_zero_of_\u03b9_left_zero\n    exact (\u03b9_eq_zero_iff_mem_ideal (a1 - a2)).mpr h\n  simp_all only [superCommuteRight_apply_\u03b9, map_sub, LinearMap.sub_apply]\n  trans \u03b9 ((superCommuteF a2) b) + 0\n  rw [\u2190 ha1b1]\n  simp only [add_sub_cancel]\n  simp\n\n/-- For a field specification `\ud835\udcd5`, `superCommute` is the linear map\n\n  `FieldOpAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpAlgebra \ud835\udcd5`\n\n  defined as the decent of `\u03b9 \u2218 superCommuteF` in both arguments.\n  In particular for `\u03c6s` and `\u03c6s'` lists of `\ud835\udcd5.CrAnFieldOp` in `FieldOpAlgebra \ud835\udcd5` the following\n  relation holds:\n\n  `superCommute \u03c6s \u03c6s' = \u03c6s * \u03c6s' - \ud835\udce2(\u03c6s, \u03c6s') \u2022 \u03c6s' * \u03c6s`\n\n  The notation `[a, b]\u209b` is used for `superCommute a b`.\n  -/\nnoncomputable def superCommute : FieldOpAlgebra \ud835\udcd5 \u2192\u2097[\u2102]\n    FieldOpAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpAlgebra \ud835\udcd5 where\n  toFun := Quotient.lift superCommuteRight superCommuteRight_eq_of_equiv\n  map_add' x y := by\n    obtain \u27e8x, rfl\u27e9 := \u03b9_surjective x\n    obtain \u27e8y, rfl\u27e9 := \u03b9_surjective y\n    ext b\n    obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n    rw [\u2190 map_add, \u03b9_apply, \u03b9_apply, \u03b9_apply, \u03b9_apply]\n    rw [Quotient.lift_mk, Quotient.lift_mk, Quotient.lift_mk]\n    simp only [LinearMap.add_apply]\n    rw [superCommuteRight_apply_quot, superCommuteRight_apply_quot, superCommuteRight_apply_quot]\n    simp\n  map_smul' c y := by\n    obtain \u27e8y, rfl\u27e9 := \u03b9_surjective y\n    ext b\n    obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n    rw [\u2190 map_smul, \u03b9_apply, \u03b9_apply, \u03b9_apply]\n    simp only [Quotient.lift_mk, RingHom.id_apply, LinearMap.smul_apply]\n    rw [superCommuteRight_apply_quot, superCommuteRight_apply_quot]\n    simp\n\n@[inherit_doc superCommute]\nscoped[FieldSpecification.FieldOpAlgebra] notation \"[\" a \",\" b \"]\u209b\" => superCommute a b\n\nlemma superCommute_eq_\u03b9_superCommuteF (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    [\u03b9 a, \u03b9 b]\u209b = \u03b9 [a, b]\u209bca := rfl\n\n/-!\n\n## Properties of `superCommute`.\n\n-/\n\n/-!\n\n## Properties from the definition of FieldOpAlgebra\n\n-/\n\nlemma superCommute_create_create {\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp}\n    (h : \ud835\udcd5 |>\u1d9c \u03c6 = .create) (h' : \ud835\udcd5 |>\u1d9c \u03c6' = .create) :\n    [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b = 0 := by\n  rw [ofCrAnOp, ofCrAnOp]\n  rw [superCommute_eq_\u03b9_superCommuteF, \u03b9_superCommuteF_of_create_create _ _ h h']\n\nlemma superCommute_annihilate_annihilate {\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp}\n    (h : \ud835\udcd5 |>\u1d9c \u03c6 = .annihilate) (h' : \ud835\udcd5 |>\u1d9c \u03c6' = .annihilate) :\n    [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b = 0 := by\n  rw [ofCrAnOp, ofCrAnOp]\n  rw [superCommute_eq_\u03b9_superCommuteF, \u03b9_superCommuteF_of_annihilate_annihilate _ _ h h']\n\nlemma superCommute_diff_statistic {\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp} (h : (\ud835\udcd5 |>\u209b \u03c6) \u2260 \ud835\udcd5 |>\u209b \u03c6') :\n    [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b = 0 := by\n  rw [ofCrAnOp, ofCrAnOp]\n  rw [superCommute_eq_\u03b9_superCommuteF, \u03b9_superCommuteF_of_diff_statistic h]\n\nlemma superCommute_ofCrAnOp_ofFieldOp_diff_stat_zero (\u03c6 : \ud835\udcd5.CrAnFieldOp) (\u03c8 : \ud835\udcd5.FieldOp)\n    (h : (\ud835\udcd5 |>\u209b \u03c6) \u2260 (\ud835\udcd5 |>\u209b \u03c8)) : [ofCrAnOp \u03c6, ofFieldOp \u03c8]\u209b = 0 := by\n  rw [ofFieldOp_eq_sum, map_sum]\n  rw [Finset.sum_eq_zero]\n  intro x hx\n  apply superCommute_diff_statistic\n  simpa [crAnStatistics] using h\n\nlemma superCommute_anPart_ofFieldOpF_diff_grade_zero (\u03c6 \u03c8 : \ud835\udcd5.FieldOp)\n    (h : (\ud835\udcd5 |>\u209b \u03c6) \u2260 (\ud835\udcd5 |>\u209b \u03c8)) : [anPart \u03c6, ofFieldOp \u03c8]\u209b = 0 := by\n  match \u03c6 with\n  | FieldOp.inAsymp _ =>\n    simp\n  | FieldOp.position \u03c6 =>\n    simp only [anPartF_position]\n    apply superCommute_ofCrAnOp_ofFieldOp_diff_stat_zero _ _ _\n    simpa [crAnStatistics] using h\n  | FieldOp.outAsymp _ =>\n    simp only [anPartF_posAsymp]\n    apply superCommute_ofCrAnOp_ofFieldOp_diff_stat_zero _ _\n    simpa [crAnStatistics] using h\n\nlemma superCommute_ofCrAnOp_ofCrAnOp_mem_center (\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b \u2208 Subalgebra.center \u2102 (FieldOpAlgebra \ud835\udcd5) := by\n  rw [ofCrAnOp, ofCrAnOp, superCommute_eq_\u03b9_superCommuteF]\n  exact \u03b9_superCommuteF_ofCrAnOpF_ofCrAnOpF_mem_center \u03c6 \u03c6'\n\nlemma superCommute_ofCrAnOp_ofCrAnOp_commute (\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp)\n    (a : FieldOpAlgebra \ud835\udcd5) :\n    a * [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b = [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b * a := by\n  have h1 := superCommute_ofCrAnOp_ofCrAnOp_mem_center \u03c6 \u03c6'\n  rw [@Subalgebra.mem_center_iff] at h1\n  exact h1 a\n\nlemma superCommute_ofCrAnOp_ofFieldOp_mem_center (\u03c6 : \ud835\udcd5.CrAnFieldOp) (\u03c6' : \ud835\udcd5.FieldOp) :\n    [ofCrAnOp \u03c6, ofFieldOp \u03c6']\u209b \u2208 Subalgebra.center \u2102 (FieldOpAlgebra \ud835\udcd5) := by\n  rw [ofFieldOp_eq_sum]\n  simp only [map_sum]\n  refine Subalgebra.sum_mem (Subalgebra.center \u2102 \ud835\udcd5.FieldOpAlgebra) ?_\n  intro x hx\n  exact superCommute_ofCrAnOp_ofCrAnOp_mem_center \u03c6 \u27e8\u03c6', x\u27e9\n\nlemma superCommute_ofCrAnOp_ofFieldOp_commute (\u03c6 : \ud835\udcd5.CrAnFieldOp) (\u03c6' : \ud835\udcd5.FieldOp)\n    (a : FieldOpAlgebra \ud835\udcd5) : a * [ofCrAnOp \u03c6, ofFieldOp \u03c6']\u209b =\n    [ofCrAnOp \u03c6, ofFieldOp \u03c6']\u209b * a := by\n  have h1 := superCommute_ofCrAnOp_ofFieldOp_mem_center \u03c6 \u03c6'\n  rw [@Subalgebra.mem_center_iff] at h1\n  exact h1 a\n\nlemma superCommute_anPart_ofFieldOp_mem_center (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [anPart \u03c6, ofFieldOp \u03c6']\u209b \u2208 Subalgebra.center \u2102 (FieldOpAlgebra \ud835\udcd5) := by\n  match \u03c6 with\n  | FieldOp.inAsymp _ =>\n    simp only [anPart_negAsymp, map_zero, LinearMap.zero_apply]\n    exact Subalgebra.zero_mem (Subalgebra.center \u2102 _)\n  | FieldOp.position \u03c6 =>\n    exact superCommute_ofCrAnOp_ofFieldOp_mem_center _ _\n  | FieldOp.outAsymp _ =>\n    exact superCommute_ofCrAnOp_ofFieldOp_mem_center _ _\n\n/-!\n\n### `superCommute` on different constructors.\n\n-/\n\nlemma superCommute_ofCrAnList_ofCrAnList (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnList \u03c6s, ofCrAnList \u03c6s']\u209b =\n    ofCrAnList (\u03c6s ++ \u03c6s') - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnList (\u03c6s' ++ \u03c6s) := by\n  rw [ofCrAnList_eq_\u03b9_ofCrAnListF, ofCrAnList_eq_\u03b9_ofCrAnListF]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_ofCrAnListF_ofCrAnListF]\n  rfl\n\nlemma superCommute_ofCrAnOp_ofCrAnOp (\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b = ofCrAnOp \u03c6 * ofCrAnOp \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 ofCrAnOp \u03c6' * ofCrAnOp \u03c6 := by\n  rw [ofCrAnOp, ofCrAnOp]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_ofCrAnOpF_ofCrAnOpF]\n  rfl\n\nlemma superCommute_ofCrAnList_ofFieldOpList (\u03c6cas : List \ud835\udcd5.CrAnFieldOp)\n    (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [ofCrAnList \u03c6cas, ofFieldOpList \u03c6s]\u209b = ofCrAnList \u03c6cas * ofFieldOpList \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6cas, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpList \u03c6s * ofCrAnList \u03c6cas := by\n  rw [ofCrAnList, ofFieldOpList]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_ofCrAnListF_ofFieldOpFsList]\n  rfl\n\nlemma superCommute_ofFieldOpList_ofFieldOpList (\u03c6s \u03c6s' : List \ud835\udcd5.FieldOp) :\n    [ofFieldOpList \u03c6s, ofFieldOpList \u03c6s']\u209b = ofFieldOpList \u03c6s * ofFieldOpList \u03c6s' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofFieldOpList \u03c6s' * ofFieldOpList \u03c6s := by\n  rw [ofFieldOpList, ofFieldOpList]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_ofFieldOpListF_ofFieldOpFsList]\n  rfl\n\nlemma superCommute_ofFieldOp_ofFieldOpList (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [ofFieldOp \u03c6, ofFieldOpList \u03c6s]\u209b = ofFieldOp \u03c6 * ofFieldOpList \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpList \u03c6s * ofFieldOp \u03c6 := by\n  rw [ofFieldOp, ofFieldOpList]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_ofFieldOpF_ofFieldOpFsList]\n  rfl\n\nlemma superCommute_ofFieldOpList_ofFieldOp (\u03c6s : List \ud835\udcd5.FieldOp) (\u03c6 : \ud835\udcd5.FieldOp) :\n    [ofFieldOpList \u03c6s, ofFieldOp \u03c6]\u209b = ofFieldOpList \u03c6s * ofFieldOp \u03c6 -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6) \u2022 ofFieldOp \u03c6 * ofFieldOpList \u03c6s := by\n  rw [ofFieldOpList, ofFieldOp]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_ofFieldOpListF_ofFieldOpF]\n  rfl\n\nlemma superCommute_anPart_crPart (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [anPart \u03c6, crPart \u03c6']\u209b = anPart \u03c6 * crPart \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 crPart \u03c6' * anPart \u03c6 := by\n  rw [anPart, crPart]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_anPartF_crPartF]\n  rfl\n\nlemma superCommute_crPart_anPart (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [crPart \u03c6, anPart \u03c6']\u209b = crPart \u03c6 * anPart \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 anPart \u03c6' * crPart \u03c6 := by\n  rw [anPart, crPart]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_crPartF_anPartF]\n  rfl\n\n@[simp]\nlemma superCommute_crPart_crPart (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) : [crPart \u03c6, crPart \u03c6']\u209b = 0 := by\n  match \u03c6, \u03c6' with\n  | FieldOp.outAsymp \u03c6, _ =>\n    simp\n  | _, FieldOp.outAsymp \u03c6 =>\n    simp\n  | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n    simp only [crPart_position]\n    apply superCommute_create_create\n    \u00b7 rfl\n    \u00b7 rfl\n  | FieldOp.position \u03c6, FieldOp.inAsymp \u03c6' =>\n    simp only [crPart_position, crPart_negAsymp]\n    apply superCommute_create_create\n    \u00b7 rfl\n    \u00b7 rfl\n  | FieldOp.inAsymp \u03c6, FieldOp.inAsymp \u03c6' =>\n    simp only [crPart_negAsymp]\n    apply superCommute_create_create\n    \u00b7 rfl\n    \u00b7 rfl\n  | FieldOp.inAsymp \u03c6, FieldOp.position \u03c6' =>\n    simp only [crPart_negAsymp, crPart_position]\n    apply superCommute_create_create\n    \u00b7 rfl\n    \u00b7 rfl\n\n@[simp]\nlemma superCommute_anPart_anPart (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) : [anPart \u03c6, anPart \u03c6']\u209b = 0 := by\n  match \u03c6, \u03c6' with\n  | FieldOp.inAsymp \u03c6, _ =>\n    simp\n  | _, FieldOp.inAsymp \u03c6 =>\n    simp\n  | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n    simp only [anPart_position]\n    apply superCommute_annihilate_annihilate\n    \u00b7 rfl\n    \u00b7 rfl\n  | FieldOp.position \u03c6, FieldOp.outAsymp \u03c6' =>\n    simp only [anPart_position, anPart_posAsymp]\n    apply superCommute_annihilate_annihilate\n    \u00b7 rfl\n    \u00b7 rfl\n  | FieldOp.outAsymp \u03c6, FieldOp.outAsymp \u03c6' =>\n    simp only [anPart_posAsymp]\n    apply superCommute_annihilate_annihilate\n    \u00b7 rfl\n    \u00b7 rfl\n  | FieldOp.outAsymp \u03c6, FieldOp.position \u03c6' =>\n    simp only [anPart_posAsymp, anPart_position]\n    apply superCommute_annihilate_annihilate\n    \u00b7 rfl\n    \u00b7 rfl\n\nlemma superCommute_crPart_ofFieldOpList (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [crPart \u03c6, ofFieldOpList \u03c6s]\u209b = crPart \u03c6 * ofFieldOpList \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpList \u03c6s * crPart \u03c6 := by\n  rw [crPart, ofFieldOpList]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_crPartF_ofFieldOpListF]\n  rfl\n\nlemma superCommute_anPart_ofFieldOpList (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [anPart \u03c6, ofFieldOpList \u03c6s]\u209b = anPart \u03c6 * ofFieldOpList \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpList \u03c6s * anPart \u03c6 := by\n  rw [anPart, ofFieldOpList]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_anPartF_ofFieldOpListF]\n  rfl\n\nlemma superCommute_crPart_ofFieldOp (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [crPart \u03c6, ofFieldOp \u03c6']\u209b = crPart \u03c6 * ofFieldOp \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 ofFieldOp \u03c6' * crPart \u03c6 := by\n  rw [crPart, ofFieldOp]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_crPartF_ofFieldOpF]\n  rfl\n\nlemma superCommute_anPart_ofFieldOp (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [anPart \u03c6, ofFieldOp \u03c6']\u209b = anPart \u03c6 * ofFieldOp \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 ofFieldOp \u03c6' * anPart \u03c6 := by\n  rw [anPart, ofFieldOp]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_anPartF_ofFieldOpF]\n  rfl\n\n/-!\n\n## Mul equal superCommute\n\nLemmas which rewrite a multiplication of two elements of the algebra as their commuted\nmultiplication with a sign plus the super commutator.\n\n-/\n\nlemma ofCrAnList_mul_ofCrAnList_eq_superCommute (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnList \u03c6s * ofCrAnList \u03c6s' =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnList \u03c6s' * ofCrAnList \u03c6s\n    + [ofCrAnList \u03c6s, ofCrAnList \u03c6s']\u209b := by\n  rw [superCommute_ofCrAnList_ofCrAnList]\n  simp [ofCrAnList_append]\n\nlemma ofCrAnOp_mul_ofCrAnList_eq_superCommute (\u03c6 : \ud835\udcd5.CrAnFieldOp)\n    (\u03c6s' : List \ud835\udcd5.CrAnFieldOp) : ofCrAnOp \u03c6 * ofCrAnList \u03c6s' =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnList \u03c6s' * ofCrAnOp \u03c6\n    + [ofCrAnOp \u03c6, ofCrAnList \u03c6s']\u209b := by\n  rw [\u2190 ofCrAnList_singleton, ofCrAnList_mul_ofCrAnList_eq_superCommute]\n  simp\n\nlemma ofFieldOpList_mul_ofFieldOpList_eq_superCommute (\u03c6s \u03c6s' : List \ud835\udcd5.FieldOp) :\n    ofFieldOpList \u03c6s * ofFieldOpList \u03c6s' =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofFieldOpList \u03c6s' * ofFieldOpList \u03c6s\n    + [ofFieldOpList \u03c6s, ofFieldOpList \u03c6s']\u209b := by\n  rw [superCommute_ofFieldOpList_ofFieldOpList]\n  simp\n\nlemma ofFieldOp_mul_ofFieldOpList_eq_superCommute (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s' : List \ud835\udcd5.FieldOp) :\n    ofFieldOp \u03c6 * ofFieldOpList \u03c6s' = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofFieldOpList \u03c6s' * ofFieldOp \u03c6\n    + [ofFieldOp \u03c6, ofFieldOpList \u03c6s']\u209b := by\n  rw [superCommute_ofFieldOp_ofFieldOpList]\n  simp\n\n", "theoremStatement": "lemma ofFieldOp_mul_ofFieldOp_eq_superCommute (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    ofFieldOp \u03c6 * ofFieldOp \u03c6' = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 ofFieldOp \u03c6' * ofFieldOp \u03c6\n    + [ofFieldOp \u03c6, ofFieldOp \u03c6']\u209b ", "theoremName": "FieldSpecification.FieldOpAlgebra.ofFieldOp_mul_ofFieldOp_eq_superCommute", "fileCreated": {"commit": "ea6e12829370d9630a7e65200c8349e9086c05ba", "date": "2025-02-03"}, "theoremCreated": {"commit": "fc2009928299f5a839dd880670f22245b6a09f72", "date": "2025-01-30"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpAlgebra/SuperCommute.lean", "module": "HepLean.PerturbationTheory.FieldOpAlgebra.SuperCommute", "jsonFile": "HepLean.PerturbationTheory.FieldOpAlgebra.SuperCommute.jsonl", "positionMetadata": {"lineInFile": 403, "tokenPositionInFile": 14692, "theoremPositionInFile": 37}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 19, "numPremises": 119}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [\u2190 ofFieldOpList_singleton, \u2190 ofFieldOpList_singleton]\n  rw [ofFieldOpList_mul_ofFieldOpList_eq_superCommute, ofFieldOpList_singleton]\n  simp", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 152}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldSpecification.CrAnFieldOp\n/-!\n\n# Filters of lists of CrAnFieldOp\n\n-/\n\nnamespace FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\n/-- Given a list of creation and annihilation states, the filtered list only containing\n  the creation states. As a schematic example, for the list:\n  - `[\u03c61c, \u03c61a, \u03c62c, \u03c62a]` this will return `[\u03c61c, \u03c62c]`.\n-/\ndef createFilter (\u03c6s : List \ud835\udcd5.CrAnFieldOp) : List \ud835\udcd5.CrAnFieldOp :=\n  List.filter (fun \u03c6 => \ud835\udcd5 |>\u1d9c \u03c6 = CreateAnnihilate.create) \u03c6s\n\nlemma createFilter_cons_create {\u03c6 : \ud835\udcd5.CrAnFieldOp}\n    (h\u03c6 : \ud835\udcd5 |>\u1d9c \u03c6 = CreateAnnihilate.create) (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    createFilter (\u03c6 :: \u03c6s) = \u03c6 :: createFilter \u03c6s := by\n  simp only [createFilter]\n  rw [List.filter_cons_of_pos]\n  simp [h\u03c6]\n\nlemma createFilter_cons_annihilate {\u03c6 : \ud835\udcd5.CrAnFieldOp}\n    (h\u03c6 : \ud835\udcd5 |>\u1d9c \u03c6 = CreateAnnihilate.annihilate) (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    createFilter (\u03c6 :: \u03c6s) = createFilter \u03c6s := by\n  simp only [createFilter]\n  rw [List.filter_cons_of_neg]\n  simp [h\u03c6]\n\nlemma createFilter_append (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    createFilter (\u03c6s ++ \u03c6s') = createFilter \u03c6s ++ createFilter \u03c6s' := by\n  rw [createFilter, List.filter_append]\n  rfl\n\nlemma createFilter_singleton_create (\u03c6 : \ud835\udcd5.CrAnFieldOp)\n    (h\u03c6 : \ud835\udcd5 |>\u1d9c \u03c6 = CreateAnnihilate.create) :\n    createFilter [\u03c6] = [\u03c6] := by\n  simp [createFilter, h\u03c6]\n\nlemma createFilter_singleton_annihilate (\u03c6 : \ud835\udcd5.CrAnFieldOp)\n    (h\u03c6 : \ud835\udcd5 |>\u1d9c \u03c6 = CreateAnnihilate.annihilate) : createFilter [\u03c6] = [] := by\n  simp [createFilter, h\u03c6]\n\n/-- Given a list of creation and annihilation states, the filtered list only containing\n  the annihilation states.\n  As a schematic example, for the list:\n  - `[\u03c61c, \u03c61a, \u03c62c, \u03c62a]` this will return `[\u03c61a, \u03c62a]`.\n-/\ndef annihilateFilter (\u03c6s : List \ud835\udcd5.CrAnFieldOp) : List \ud835\udcd5.CrAnFieldOp :=\n  List.filter (fun \u03c6 => \ud835\udcd5 |>\u1d9c \u03c6 = CreateAnnihilate.annihilate) \u03c6s\n\n", "theoremStatement": "lemma annihilateFilter_cons_create {\u03c6 : \ud835\udcd5.CrAnFieldOp}\n    (h\u03c6 : \ud835\udcd5 |>\u1d9c \u03c6 = CreateAnnihilate.create) (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    annihilateFilter (\u03c6 :: \u03c6s) = annihilateFilter \u03c6s ", "theoremName": "FieldSpecification.annihilateFilter_cons_create", "fileCreated": {"commit": "b5c987180a78e45ea7ddb402cd866df26a7c1fa1", "date": "2025-01-21"}, "theoremCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "file": "HepLean/HepLean/PerturbationTheory/FieldSpecification/Filters.lean", "module": "HepLean.PerturbationTheory.FieldSpecification.Filters", "jsonFile": "HepLean.PerturbationTheory.FieldSpecification.Filters.jsonl", "positionMetadata": {"lineInFile": 59, "tokenPositionInFile": 2041, "theoremPositionInFile": 7}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 8, "numPremises": 37}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp only [annihilateFilter]\n  rw [List.filter_cons_of_neg]\n  simp [h\u03c6]", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 79}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.Basic\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.Grading\n/-!\n\n# Super Commute\n-/\n\nnamespace FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\nnamespace FieldOpFreeAlgebra\n\n/-!\n\n## The super commutator on the FieldOpFreeAlgebra.\n\n-/\n\nopen FieldStatistic\n\n/-- For a field specification `\ud835\udcd5`, the super commutator `superCommuteF` is defined as the linear\n  map `\ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102] \ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102] \ud835\udcd5.FieldOpFreeAlgebra`\n  which on the lists `\u03c6s` and `\u03c6s'` of `\ud835\udcd5.CrAnFieldOp` gives\n\n  `superCommuteF \u03c6s \u03c6s' = \u03c6s * \u03c6s' - \ud835\udce2(\u03c6s, \u03c6s') \u2022 \u03c6s' * \u03c6s`.\n\n  The notation `[a, b]\u209bca` can be used for `superCommuteF a b`. -/\nnoncomputable def superCommuteF : \ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102] \ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102]\n    \ud835\udcd5.FieldOpFreeAlgebra :=\n  Basis.constr ofCrAnListFBasis \u2102 fun \u03c6s =>\n  Basis.constr ofCrAnListFBasis \u2102 fun \u03c6s' =>\n  ofCrAnListF (\u03c6s ++ \u03c6s') - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnListF (\u03c6s' ++ \u03c6s)\n\n@[inherit_doc superCommuteF]\nscoped[FieldSpecification.FieldOpFreeAlgebra] notation \"[\" \u03c6s \",\" \u03c6s' \"]\u209bca\" => superCommuteF \u03c6s \u03c6s'\n\n/-!\n\n## The super commutator of different types of elements\n\n-/\n\n", "theoremStatement": "lemma superCommuteF_ofCrAnListF_ofCrAnListF (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnListF \u03c6s, ofCrAnListF \u03c6s']\u209bca =\n    ofCrAnListF (\u03c6s ++ \u03c6s') - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnListF (\u03c6s' ++ \u03c6s) ", "theoremName": "FieldSpecification.FieldOpFreeAlgebra.superCommuteF_ofCrAnListF_ofCrAnListF", "fileCreated": {"commit": "ea6e12829370d9630a7e65200c8349e9086c05ba", "date": "2025-02-03"}, "theoremCreated": {"commit": "2614e0bd925dd8b05bd8c40c1dbab4c1c9fa3652", "date": "2025-02-06"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpFreeAlgebra/SuperCommute.lean", "module": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.SuperCommute", "jsonFile": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.SuperCommute.jsonl", "positionMetadata": {"lineInFile": 48, "tokenPositionInFile": 1333, "theoremPositionInFile": 2}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 12, "numPremises": 78}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [\u2190 ofListBasis_eq_ofList, \u2190 ofListBasis_eq_ofList]\n  simp only [superCommuteF, Basis.constr_basis]", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 109}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldSpecification.TimeOrder\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.Basic\nimport HepLean.PerturbationTheory.Koszul.KoszulSign\n/-!\n\n# Norm-time Ordering in the FieldOpFreeAlgebra\n\n-/\n\nnamespace FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\nopen FieldStatistic\n\nnamespace FieldOpFreeAlgebra\n\nnoncomputable section\nopen HepLean.List\n\n/-!\n\n## Norm-time order\n\n-/\n\n/-- The normal-time ordering on `FieldOpFreeAlgebra`. -/\ndef normTimeOrder : FieldOpFreeAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpFreeAlgebra \ud835\udcd5 :=\n  Basis.constr ofCrAnListFBasis \u2102 fun \u03c6s =>\n  normTimeOrderSign \u03c6s \u2022 ofCrAnListF (normTimeOrderList \u03c6s)\n\n@[inherit_doc normTimeOrder]\nscoped[FieldSpecification.FieldOpFreeAlgebra] notation \"\ud835\udce3\ud835\udcdd\u1da0(\" a \")\" => normTimeOrder a\n\n", "theoremStatement": "lemma normTimeOrder_ofCrAnListF (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    \ud835\udce3\ud835\udcdd\u1da0(ofCrAnListF \u03c6s) = normTimeOrderSign \u03c6s \u2022 ofCrAnListF (normTimeOrderList \u03c6s) ", "theoremName": "FieldSpecification.FieldOpFreeAlgebra.normTimeOrder_ofCrAnListF", "fileCreated": {"commit": "ea6e12829370d9630a7e65200c8349e9086c05ba", "date": "2025-02-03"}, "theoremCreated": {"commit": "171e80fc04016aed422340742f3e0a14de6d20b0", "date": "2025-02-03"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpFreeAlgebra/NormTimeOrder.lean", "module": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.NormTimeOrder", "jsonFile": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.NormTimeOrder.jsonl", "positionMetadata": {"lineInFile": 38, "tokenPositionInFile": 927, "theoremPositionInFile": 2}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 9, "numPremises": 52}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [\u2190 ofListBasis_eq_ofList]\n  simp only [normTimeOrder, Basis.constr_basis]", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 84}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.TimeOrder\nimport HepLean.PerturbationTheory.FieldOpAlgebra.Basic\n/-!\n\n# SuperCommute on Field operator algebra\n\n-/\n\nnamespace FieldSpecification\nopen FieldOpFreeAlgebra\nopen HepLean.List\nopen FieldStatistic\n\nnamespace FieldOpAlgebra\nvariable {\ud835\udcd5 : FieldSpecification}\n\nlemma \u03b9_superCommuteF_eq_zero_of_\u03b9_right_zero (a b : \ud835\udcd5.FieldOpFreeAlgebra) (h : \u03b9 b = 0) :\n    \u03b9 [a, b]\u209bca = 0 := by\n  rw [superCommuteF_expand_bosonicProjF_fermionicProjF]\n  rw [\u03b9_eq_zero_iff_\u03b9_bosonicProjF_fermonicProj_zero] at h\n  simp_all\n\nlemma \u03b9_superCommuteF_eq_zero_of_\u03b9_left_zero (a b : \ud835\udcd5.FieldOpFreeAlgebra) (h : \u03b9 a = 0) :\n    \u03b9 [a, b]\u209bca = 0 := by\n  rw [superCommuteF_expand_bosonicProjF_fermionicProjF]\n  rw [\u03b9_eq_zero_iff_\u03b9_bosonicProjF_fermonicProj_zero] at h\n  simp_all\n\n/-!\n\n## Defining normal order for `FiedOpAlgebra`.\n\n-/\n\nlemma \u03b9_superCommuteF_right_zero_of_mem_ideal (a b : \ud835\udcd5.FieldOpFreeAlgebra)\n    (h : b \u2208 TwoSidedIdeal.span \ud835\udcd5.fieldOpIdealSet) : \u03b9 [a, b]\u209bca = 0 := by\n  apply \u03b9_superCommuteF_eq_zero_of_\u03b9_right_zero\n  exact (\u03b9_eq_zero_iff_mem_ideal b).mpr h\n\nlemma \u03b9_superCommuteF_eq_of_equiv_right (a b1 b2 : \ud835\udcd5.FieldOpFreeAlgebra) (h : b1 \u2248 b2) :\n    \u03b9 [a, b1]\u209bca = \u03b9 [a, b2]\u209bca := by\n  rw [equiv_iff_sub_mem_ideal] at h\n  rw [LinearMap.sub_mem_ker_iff.mp]\n  simp only [LinearMap.mem_ker, \u2190 map_sub]\n  exact \u03b9_superCommuteF_right_zero_of_mem_ideal a (b1 - b2) h\n\n/-- The super commutator on the `FieldOpAlgebra` defined as a linear map `[a,_]\u209b`. -/\nnoncomputable def superCommuteRight (a : \ud835\udcd5.FieldOpFreeAlgebra) :\n  FieldOpAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpAlgebra \ud835\udcd5 where\n  toFun := Quotient.lift (\u03b9.toLinearMap \u2218\u2097 superCommuteF a)\n    (\u03b9_superCommuteF_eq_of_equiv_right a)\n  map_add' x y := by\n    obtain \u27e8x, hx\u27e9 := \u03b9_surjective x\n    obtain \u27e8y, hy\u27e9 := \u03b9_surjective y\n    subst hx hy\n    rw [\u2190 map_add, \u03b9_apply, \u03b9_apply, \u03b9_apply]\n    rw [Quotient.lift_mk, Quotient.lift_mk, Quotient.lift_mk]\n    simp\n  map_smul' c y := by\n    obtain \u27e8y, hy\u27e9 := \u03b9_surjective y\n    subst hy\n    rw [\u2190 map_smul, \u03b9_apply, \u03b9_apply]\n    simp\n\nlemma superCommuteRight_apply_\u03b9 (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    superCommuteRight a (\u03b9 b) = \u03b9 [a, b]\u209bca := by rfl\n\nlemma superCommuteRight_apply_quot (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    superCommuteRight a \u27e6b\u27e7= \u03b9 [a, b]\u209bca := by rfl\n\nlemma superCommuteRight_eq_of_equiv (a1 a2 : \ud835\udcd5.FieldOpFreeAlgebra) (h : a1 \u2248 a2) :\n    superCommuteRight a1 = superCommuteRight a2 := by\n  rw [equiv_iff_sub_mem_ideal] at h\n  ext b\n  obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n  have ha1b1 : (superCommuteRight (a1 - a2)) (\u03b9 b) = 0 := by\n    rw [superCommuteRight_apply_\u03b9]\n    apply \u03b9_superCommuteF_eq_zero_of_\u03b9_left_zero\n    exact (\u03b9_eq_zero_iff_mem_ideal (a1 - a2)).mpr h\n  simp_all only [superCommuteRight_apply_\u03b9, map_sub, LinearMap.sub_apply]\n  trans \u03b9 ((superCommuteF a2) b) + 0\n  rw [\u2190 ha1b1]\n  simp only [add_sub_cancel]\n  simp\n\n/-- For a field specification `\ud835\udcd5`, `superCommute` is the linear map\n\n  `FieldOpAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpAlgebra \ud835\udcd5`\n\n  defined as the decent of `\u03b9 \u2218 superCommuteF` in both arguments.\n  In particular for `\u03c6s` and `\u03c6s'` lists of `\ud835\udcd5.CrAnFieldOp` in `FieldOpAlgebra \ud835\udcd5` the following\n  relation holds:\n\n  `superCommute \u03c6s \u03c6s' = \u03c6s * \u03c6s' - \ud835\udce2(\u03c6s, \u03c6s') \u2022 \u03c6s' * \u03c6s`\n\n  The notation `[a, b]\u209b` is used for `superCommute a b`.\n  -/\nnoncomputable def superCommute : FieldOpAlgebra \ud835\udcd5 \u2192\u2097[\u2102]\n    FieldOpAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpAlgebra \ud835\udcd5 where\n  toFun := Quotient.lift superCommuteRight superCommuteRight_eq_of_equiv\n  map_add' x y := by\n    obtain \u27e8x, rfl\u27e9 := \u03b9_surjective x\n    obtain \u27e8y, rfl\u27e9 := \u03b9_surjective y\n    ext b\n    obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n    rw [\u2190 map_add, \u03b9_apply, \u03b9_apply, \u03b9_apply, \u03b9_apply]\n    rw [Quotient.lift_mk, Quotient.lift_mk, Quotient.lift_mk]\n    simp only [LinearMap.add_apply]\n    rw [superCommuteRight_apply_quot, superCommuteRight_apply_quot, superCommuteRight_apply_quot]\n    simp\n  map_smul' c y := by\n    obtain \u27e8y, rfl\u27e9 := \u03b9_surjective y\n    ext b\n    obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n    rw [\u2190 map_smul, \u03b9_apply, \u03b9_apply, \u03b9_apply]\n    simp only [Quotient.lift_mk, RingHom.id_apply, LinearMap.smul_apply]\n    rw [superCommuteRight_apply_quot, superCommuteRight_apply_quot]\n    simp\n\n@[inherit_doc superCommute]\nscoped[FieldSpecification.FieldOpAlgebra] notation \"[\" a \",\" b \"]\u209b\" => superCommute a b\n\nlemma superCommute_eq_\u03b9_superCommuteF (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    [\u03b9 a, \u03b9 b]\u209b = \u03b9 [a, b]\u209bca := rfl\n\n/-!\n\n## Properties of `superCommute`.\n\n-/\n\n/-!\n\n## Properties from the definition of FieldOpAlgebra\n\n-/\n\nlemma superCommute_create_create {\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp}\n    (h : \ud835\udcd5 |>\u1d9c \u03c6 = .create) (h' : \ud835\udcd5 |>\u1d9c \u03c6' = .create) :\n    [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b = 0 := by\n  rw [ofCrAnOp, ofCrAnOp]\n  rw [superCommute_eq_\u03b9_superCommuteF, \u03b9_superCommuteF_of_create_create _ _ h h']\n\nlemma superCommute_annihilate_annihilate {\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp}\n    (h : \ud835\udcd5 |>\u1d9c \u03c6 = .annihilate) (h' : \ud835\udcd5 |>\u1d9c \u03c6' = .annihilate) :\n    [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b = 0 := by\n  rw [ofCrAnOp, ofCrAnOp]\n  rw [superCommute_eq_\u03b9_superCommuteF, \u03b9_superCommuteF_of_annihilate_annihilate _ _ h h']\n\nlemma superCommute_diff_statistic {\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp} (h : (\ud835\udcd5 |>\u209b \u03c6) \u2260 \ud835\udcd5 |>\u209b \u03c6') :\n    [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b = 0 := by\n  rw [ofCrAnOp, ofCrAnOp]\n  rw [superCommute_eq_\u03b9_superCommuteF, \u03b9_superCommuteF_of_diff_statistic h]\n\nlemma superCommute_ofCrAnOp_ofFieldOp_diff_stat_zero (\u03c6 : \ud835\udcd5.CrAnFieldOp) (\u03c8 : \ud835\udcd5.FieldOp)\n    (h : (\ud835\udcd5 |>\u209b \u03c6) \u2260 (\ud835\udcd5 |>\u209b \u03c8)) : [ofCrAnOp \u03c6, ofFieldOp \u03c8]\u209b = 0 := by\n  rw [ofFieldOp_eq_sum, map_sum]\n  rw [Finset.sum_eq_zero]\n  intro x hx\n  apply superCommute_diff_statistic\n  simpa [crAnStatistics] using h\n\nlemma superCommute_anPart_ofFieldOpF_diff_grade_zero (\u03c6 \u03c8 : \ud835\udcd5.FieldOp)\n    (h : (\ud835\udcd5 |>\u209b \u03c6) \u2260 (\ud835\udcd5 |>\u209b \u03c8)) : [anPart \u03c6, ofFieldOp \u03c8]\u209b = 0 := by\n  match \u03c6 with\n  | FieldOp.inAsymp _ =>\n    simp\n  | FieldOp.position \u03c6 =>\n    simp only [anPartF_position]\n    apply superCommute_ofCrAnOp_ofFieldOp_diff_stat_zero _ _ _\n    simpa [crAnStatistics] using h\n  | FieldOp.outAsymp _ =>\n    simp only [anPartF_posAsymp]\n    apply superCommute_ofCrAnOp_ofFieldOp_diff_stat_zero _ _\n    simpa [crAnStatistics] using h\n\nlemma superCommute_ofCrAnOp_ofCrAnOp_mem_center (\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b \u2208 Subalgebra.center \u2102 (FieldOpAlgebra \ud835\udcd5) := by\n  rw [ofCrAnOp, ofCrAnOp, superCommute_eq_\u03b9_superCommuteF]\n  exact \u03b9_superCommuteF_ofCrAnOpF_ofCrAnOpF_mem_center \u03c6 \u03c6'\n\nlemma superCommute_ofCrAnOp_ofCrAnOp_commute (\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp)\n    (a : FieldOpAlgebra \ud835\udcd5) :\n    a * [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b = [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b * a := by\n  have h1 := superCommute_ofCrAnOp_ofCrAnOp_mem_center \u03c6 \u03c6'\n  rw [@Subalgebra.mem_center_iff] at h1\n  exact h1 a\n\nlemma superCommute_ofCrAnOp_ofFieldOp_mem_center (\u03c6 : \ud835\udcd5.CrAnFieldOp) (\u03c6' : \ud835\udcd5.FieldOp) :\n    [ofCrAnOp \u03c6, ofFieldOp \u03c6']\u209b \u2208 Subalgebra.center \u2102 (FieldOpAlgebra \ud835\udcd5) := by\n  rw [ofFieldOp_eq_sum]\n  simp only [map_sum]\n  refine Subalgebra.sum_mem (Subalgebra.center \u2102 \ud835\udcd5.FieldOpAlgebra) ?_\n  intro x hx\n  exact superCommute_ofCrAnOp_ofCrAnOp_mem_center \u03c6 \u27e8\u03c6', x\u27e9\n\nlemma superCommute_ofCrAnOp_ofFieldOp_commute (\u03c6 : \ud835\udcd5.CrAnFieldOp) (\u03c6' : \ud835\udcd5.FieldOp)\n    (a : FieldOpAlgebra \ud835\udcd5) : a * [ofCrAnOp \u03c6, ofFieldOp \u03c6']\u209b =\n    [ofCrAnOp \u03c6, ofFieldOp \u03c6']\u209b * a := by\n  have h1 := superCommute_ofCrAnOp_ofFieldOp_mem_center \u03c6 \u03c6'\n  rw [@Subalgebra.mem_center_iff] at h1\n  exact h1 a\n\nlemma superCommute_anPart_ofFieldOp_mem_center (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [anPart \u03c6, ofFieldOp \u03c6']\u209b \u2208 Subalgebra.center \u2102 (FieldOpAlgebra \ud835\udcd5) := by\n  match \u03c6 with\n  | FieldOp.inAsymp _ =>\n    simp only [anPart_negAsymp, map_zero, LinearMap.zero_apply]\n    exact Subalgebra.zero_mem (Subalgebra.center \u2102 _)\n  | FieldOp.position \u03c6 =>\n    exact superCommute_ofCrAnOp_ofFieldOp_mem_center _ _\n  | FieldOp.outAsymp _ =>\n    exact superCommute_ofCrAnOp_ofFieldOp_mem_center _ _\n\n/-!\n\n### `superCommute` on different constructors.\n\n-/\n\nlemma superCommute_ofCrAnList_ofCrAnList (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnList \u03c6s, ofCrAnList \u03c6s']\u209b =\n    ofCrAnList (\u03c6s ++ \u03c6s') - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnList (\u03c6s' ++ \u03c6s) := by\n  rw [ofCrAnList_eq_\u03b9_ofCrAnListF, ofCrAnList_eq_\u03b9_ofCrAnListF]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_ofCrAnListF_ofCrAnListF]\n  rfl\n\nlemma superCommute_ofCrAnOp_ofCrAnOp (\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b = ofCrAnOp \u03c6 * ofCrAnOp \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 ofCrAnOp \u03c6' * ofCrAnOp \u03c6 := by\n  rw [ofCrAnOp, ofCrAnOp]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_ofCrAnOpF_ofCrAnOpF]\n  rfl\n\nlemma superCommute_ofCrAnList_ofFieldOpList (\u03c6cas : List \ud835\udcd5.CrAnFieldOp)\n    (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [ofCrAnList \u03c6cas, ofFieldOpList \u03c6s]\u209b = ofCrAnList \u03c6cas * ofFieldOpList \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6cas, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpList \u03c6s * ofCrAnList \u03c6cas := by\n  rw [ofCrAnList, ofFieldOpList]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_ofCrAnListF_ofFieldOpFsList]\n  rfl\n\nlemma superCommute_ofFieldOpList_ofFieldOpList (\u03c6s \u03c6s' : List \ud835\udcd5.FieldOp) :\n    [ofFieldOpList \u03c6s, ofFieldOpList \u03c6s']\u209b = ofFieldOpList \u03c6s * ofFieldOpList \u03c6s' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofFieldOpList \u03c6s' * ofFieldOpList \u03c6s := by\n  rw [ofFieldOpList, ofFieldOpList]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_ofFieldOpListF_ofFieldOpFsList]\n  rfl\n\nlemma superCommute_ofFieldOp_ofFieldOpList (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [ofFieldOp \u03c6, ofFieldOpList \u03c6s]\u209b = ofFieldOp \u03c6 * ofFieldOpList \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpList \u03c6s * ofFieldOp \u03c6 := by\n  rw [ofFieldOp, ofFieldOpList]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_ofFieldOpF_ofFieldOpFsList]\n  rfl\n\nlemma superCommute_ofFieldOpList_ofFieldOp (\u03c6s : List \ud835\udcd5.FieldOp) (\u03c6 : \ud835\udcd5.FieldOp) :\n    [ofFieldOpList \u03c6s, ofFieldOp \u03c6]\u209b = ofFieldOpList \u03c6s * ofFieldOp \u03c6 -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6) \u2022 ofFieldOp \u03c6 * ofFieldOpList \u03c6s := by\n  rw [ofFieldOpList, ofFieldOp]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_ofFieldOpListF_ofFieldOpF]\n  rfl\n\nlemma superCommute_anPart_crPart (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [anPart \u03c6, crPart \u03c6']\u209b = anPart \u03c6 * crPart \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 crPart \u03c6' * anPart \u03c6 := by\n  rw [anPart, crPart]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_anPartF_crPartF]\n  rfl\n\nlemma superCommute_crPart_anPart (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [crPart \u03c6, anPart \u03c6']\u209b = crPart \u03c6 * anPart \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 anPart \u03c6' * crPart \u03c6 := by\n  rw [anPart, crPart]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_crPartF_anPartF]\n  rfl\n\n@[simp]\nlemma superCommute_crPart_crPart (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) : [crPart \u03c6, crPart \u03c6']\u209b = 0 := by\n  match \u03c6, \u03c6' with\n  | FieldOp.outAsymp \u03c6, _ =>\n    simp\n  | _, FieldOp.outAsymp \u03c6 =>\n    simp\n  | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n    simp only [crPart_position]\n    apply superCommute_create_create\n    \u00b7 rfl\n    \u00b7 rfl\n  | FieldOp.position \u03c6, FieldOp.inAsymp \u03c6' =>\n    simp only [crPart_position, crPart_negAsymp]\n    apply superCommute_create_create\n    \u00b7 rfl\n    \u00b7 rfl\n  | FieldOp.inAsymp \u03c6, FieldOp.inAsymp \u03c6' =>\n    simp only [crPart_negAsymp]\n    apply superCommute_create_create\n    \u00b7 rfl\n    \u00b7 rfl\n  | FieldOp.inAsymp \u03c6, FieldOp.position \u03c6' =>\n    simp only [crPart_negAsymp, crPart_position]\n    apply superCommute_create_create\n    \u00b7 rfl\n    \u00b7 rfl\n\n@[simp]\nlemma superCommute_anPart_anPart (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) : [anPart \u03c6, anPart \u03c6']\u209b = 0 := by\n  match \u03c6, \u03c6' with\n  | FieldOp.inAsymp \u03c6, _ =>\n    simp\n  | _, FieldOp.inAsymp \u03c6 =>\n    simp\n  | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n    simp only [anPart_position]\n    apply superCommute_annihilate_annihilate\n    \u00b7 rfl\n    \u00b7 rfl\n  | FieldOp.position \u03c6, FieldOp.outAsymp \u03c6' =>\n    simp only [anPart_position, anPart_posAsymp]\n    apply superCommute_annihilate_annihilate\n    \u00b7 rfl\n    \u00b7 rfl\n  | FieldOp.outAsymp \u03c6, FieldOp.outAsymp \u03c6' =>\n    simp only [anPart_posAsymp]\n    apply superCommute_annihilate_annihilate\n    \u00b7 rfl\n    \u00b7 rfl\n  | FieldOp.outAsymp \u03c6, FieldOp.position \u03c6' =>\n    simp only [anPart_posAsymp, anPart_position]\n    apply superCommute_annihilate_annihilate\n    \u00b7 rfl\n    \u00b7 rfl\n\nlemma superCommute_crPart_ofFieldOpList (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [crPart \u03c6, ofFieldOpList \u03c6s]\u209b = crPart \u03c6 * ofFieldOpList \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpList \u03c6s * crPart \u03c6 := by\n  rw [crPart, ofFieldOpList]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_crPartF_ofFieldOpListF]\n  rfl\n\nlemma superCommute_anPart_ofFieldOpList (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [anPart \u03c6, ofFieldOpList \u03c6s]\u209b = anPart \u03c6 * ofFieldOpList \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpList \u03c6s * anPart \u03c6 := by\n  rw [anPart, ofFieldOpList]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_anPartF_ofFieldOpListF]\n  rfl\n\nlemma superCommute_crPart_ofFieldOp (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [crPart \u03c6, ofFieldOp \u03c6']\u209b = crPart \u03c6 * ofFieldOp \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 ofFieldOp \u03c6' * crPart \u03c6 := by\n  rw [crPart, ofFieldOp]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_crPartF_ofFieldOpF]\n  rfl\n\nlemma superCommute_anPart_ofFieldOp (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [anPart \u03c6, ofFieldOp \u03c6']\u209b = anPart \u03c6 * ofFieldOp \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 ofFieldOp \u03c6' * anPart \u03c6 := by\n  rw [anPart, ofFieldOp]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_anPartF_ofFieldOpF]\n  rfl\n\n/-!\n\n## Mul equal superCommute\n\nLemmas which rewrite a multiplication of two elements of the algebra as their commuted\nmultiplication with a sign plus the super commutator.\n\n-/\n\nlemma ofCrAnList_mul_ofCrAnList_eq_superCommute (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnList \u03c6s * ofCrAnList \u03c6s' =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnList \u03c6s' * ofCrAnList \u03c6s\n    + [ofCrAnList \u03c6s, ofCrAnList \u03c6s']\u209b := by\n  rw [superCommute_ofCrAnList_ofCrAnList]\n  simp [ofCrAnList_append]\n\nlemma ofCrAnOp_mul_ofCrAnList_eq_superCommute (\u03c6 : \ud835\udcd5.CrAnFieldOp)\n    (\u03c6s' : List \ud835\udcd5.CrAnFieldOp) : ofCrAnOp \u03c6 * ofCrAnList \u03c6s' =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnList \u03c6s' * ofCrAnOp \u03c6\n    + [ofCrAnOp \u03c6, ofCrAnList \u03c6s']\u209b := by\n  rw [\u2190 ofCrAnList_singleton, ofCrAnList_mul_ofCrAnList_eq_superCommute]\n  simp\n\nlemma ofFieldOpList_mul_ofFieldOpList_eq_superCommute (\u03c6s \u03c6s' : List \ud835\udcd5.FieldOp) :\n    ofFieldOpList \u03c6s * ofFieldOpList \u03c6s' =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofFieldOpList \u03c6s' * ofFieldOpList \u03c6s\n    + [ofFieldOpList \u03c6s, ofFieldOpList \u03c6s']\u209b := by\n  rw [superCommute_ofFieldOpList_ofFieldOpList]\n  simp\n\nlemma ofFieldOp_mul_ofFieldOpList_eq_superCommute (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s' : List \ud835\udcd5.FieldOp) :\n    ofFieldOp \u03c6 * ofFieldOpList \u03c6s' = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofFieldOpList \u03c6s' * ofFieldOp \u03c6\n    + [ofFieldOp \u03c6, ofFieldOpList \u03c6s']\u209b := by\n  rw [superCommute_ofFieldOp_ofFieldOpList]\n  simp\n\nlemma ofFieldOp_mul_ofFieldOp_eq_superCommute (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    ofFieldOp \u03c6 * ofFieldOp \u03c6' = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 ofFieldOp \u03c6' * ofFieldOp \u03c6\n    + [ofFieldOp \u03c6, ofFieldOp \u03c6']\u209b := by\n  rw [\u2190 ofFieldOpList_singleton, \u2190 ofFieldOpList_singleton]\n  rw [ofFieldOpList_mul_ofFieldOpList_eq_superCommute, ofFieldOpList_singleton]\n  simp\n\nlemma ofFieldOpList_mul_ofFieldOp_eq_superCommute (\u03c6s : List \ud835\udcd5.FieldOp) (\u03c6 : \ud835\udcd5.FieldOp) :\n    ofFieldOpList \u03c6s * ofFieldOp \u03c6 = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6) \u2022 ofFieldOp \u03c6 * ofFieldOpList \u03c6s\n    + [ofFieldOpList \u03c6s, ofFieldOp \u03c6]\u209b := by\n  rw [superCommute_ofFieldOpList_ofFieldOp]\n  simp\n\nlemma ofCrAnList_mul_ofFieldOpList_eq_superCommute (\u03c6s : List \ud835\udcd5.CrAnFieldOp)\n    (\u03c6s' : List \ud835\udcd5.FieldOp) : ofCrAnList \u03c6s * ofFieldOpList \u03c6s' =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofFieldOpList \u03c6s' * ofCrAnList \u03c6s\n    + [ofCrAnList \u03c6s, ofFieldOpList \u03c6s']\u209b := by\n  rw [superCommute_ofCrAnList_ofFieldOpList]\n  simp\n\nlemma crPart_mul_anPart_eq_superCommute (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    crPart \u03c6 * anPart \u03c6' = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 anPart \u03c6' * crPart \u03c6\n    + [crPart \u03c6, anPart \u03c6']\u209b := by\n  rw [superCommute_crPart_anPart]\n  simp\n\nlemma anPart_mul_crPart_eq_superCommute (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    anPart \u03c6 * crPart \u03c6' = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 crPart \u03c6' * anPart \u03c6\n    + [anPart \u03c6, crPart \u03c6']\u209b := by\n  rw [superCommute_anPart_crPart]\n  simp\n\nlemma crPart_mul_crPart_swap (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    crPart \u03c6 * crPart \u03c6' = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 crPart \u03c6' * crPart \u03c6 := by\n  trans \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 crPart \u03c6' * crPart \u03c6 + [crPart \u03c6, crPart \u03c6']\u209b\n  \u00b7 rw [crPart, crPart, superCommute_eq_\u03b9_superCommuteF, superCommuteF_crPartF_crPartF]\n    simp\n  \u00b7 simp\n\nlemma anPart_mul_anPart_swap (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    anPart \u03c6 * anPart \u03c6' = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 anPart \u03c6' * anPart \u03c6 := by\n  trans \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 anPart \u03c6' * anPart \u03c6 + [anPart \u03c6, anPart \u03c6']\u209b\n  \u00b7 rw [anPart, anPart, superCommute_eq_\u03b9_superCommuteF, superCommuteF_anPartF_anPartF]\n    simp\n  \u00b7 simp\n\n/-!\n\n## Symmetry of the super commutator.\n\n-/\n\nlemma superCommute_ofCrAnList_ofCrAnList_symm (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnList \u03c6s, ofCrAnList \u03c6s']\u209b =\n    (- \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s')) \u2022 [ofCrAnList \u03c6s', ofCrAnList \u03c6s]\u209b := by\n  rw [ofCrAnList, ofCrAnList, superCommute_eq_\u03b9_superCommuteF,\n    superCommuteF_ofCrAnListF_ofCrAnListF_symm]\n  rfl\n\nlemma superCommute_ofCrAnOp_ofCrAnOp_symm (\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b =\n    (- \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6')) \u2022 [ofCrAnOp \u03c6', ofCrAnOp \u03c6]\u209b := by\n  rw [ofCrAnOp, ofCrAnOp, superCommute_eq_\u03b9_superCommuteF,\n    superCommuteF_ofCrAnOpF_ofCrAnOpF_symm]\n  rfl\n\n/-!\n\n## splitting the super commute into sums\n\n-/\n\nlemma superCommute_ofCrAnList_ofCrAnList_eq_sum (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnList \u03c6s, ofCrAnList \u03c6s']\u209b =\n    \u2211 (n : Fin \u03c6s'.length), \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s'.take n) \u2022\n    ofCrAnList (\u03c6s'.take n) * [ofCrAnList \u03c6s, ofCrAnOp (\u03c6s'.get n)]\u209b *\n    ofCrAnList (\u03c6s'.drop (n + 1)) := by\n  conv_lhs =>\n    rw [ofCrAnList, ofCrAnList, superCommute_eq_\u03b9_superCommuteF,\n      superCommuteF_ofCrAnListF_ofCrAnListF_eq_sum]\n  rw [map_sum]\n  rfl\n\nlemma superCommute_ofCrAnOp_ofCrAnList_eq_sum (\u03c6 : \ud835\udcd5.CrAnFieldOp)\n    (\u03c6s' : List \ud835\udcd5.CrAnFieldOp) : [ofCrAnOp \u03c6, ofCrAnList \u03c6s']\u209b =\n    \u2211 (n : Fin \u03c6s'.length), \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s'.take n) \u2022\n    [ofCrAnOp \u03c6, ofCrAnOp (\u03c6s'.get n)]\u209b * ofCrAnList (\u03c6s'.eraseIdx n) := by\n  conv_lhs =>\n    rw [\u2190 ofCrAnList_singleton, superCommute_ofCrAnList_ofCrAnList_eq_sum]\n  congr\n  funext n\n  simp only [instCommGroup.eq_1, ofList_singleton, List.get_eq_getElem, Algebra.smul_mul_assoc]\n  congr 1\n  rw [ofCrAnList_singleton, superCommute_ofCrAnOp_ofCrAnOp_commute]\n  rw [mul_assoc, \u2190 ofCrAnList_append]\n  congr\n  exact Eq.symm (List.eraseIdx_eq_take_drop_succ \u03c6s' \u2191n)\n\n", "theoremStatement": "lemma superCommute_ofCrAnList_ofFieldOpList_eq_sum (\u03c6s : List \ud835\udcd5.CrAnFieldOp)\n    (\u03c6s' : List \ud835\udcd5.FieldOp) : [ofCrAnList \u03c6s, ofFieldOpList \u03c6s']\u209b =\n    \u2211 (n : Fin \u03c6s'.length), \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s'.take n) \u2022\n    ofFieldOpList (\u03c6s'.take n) * [ofCrAnList \u03c6s, ofFieldOp (\u03c6s'.get n)]\u209b *\n    ofFieldOpList (\u03c6s'.drop (n + 1)) ", "theoremName": "FieldSpecification.FieldOpAlgebra.superCommute_ofCrAnList_ofFieldOpList_eq_sum", "fileCreated": {"commit": "ea6e12829370d9630a7e65200c8349e9086c05ba", "date": "2025-02-03"}, "theoremCreated": {"commit": "48e3417d5d558b5f1fcd618091baa0eae36f95a5", "date": "2025-02-06"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpAlgebra/SuperCommute.lean", "module": "HepLean.PerturbationTheory.FieldOpAlgebra.SuperCommute", "jsonFile": "HepLean.PerturbationTheory.FieldOpAlgebra.SuperCommute.jsonl", "positionMetadata": {"lineInFile": 501, "tokenPositionInFile": 18429, "theoremPositionInFile": 48}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 23, "numPremises": 125}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  conv_lhs =>\n    rw [ofCrAnList, ofFieldOpList, superCommute_eq_\u03b9_superCommuteF,\n      superCommuteF_ofCrAnListF_ofFieldOpListF_eq_sum]\n  rw [map_sum]\n  rfl", "proofType": "tactic", "proofLengthLines": 5, "proofLengthTokens": 163}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.WickContraction.Join\n/-!\n\n# Time contractions\n\n-/\n\nopen FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\nnamespace WickContraction\nvariable {n : \u2115} (c : WickContraction n)\nopen HepLean.List\nopen FieldOpAlgebra\n\n/-- The condition on a Wick contraction which is true iff and only if every contraction\n  is between two fields of equal time. -/\ndef EqTimeOnly {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length) : Prop :=\n  \u2200 (i j), {i, j} \u2208 \u03c6s\u039b.1 \u2192 timeOrderRel \u03c6s[i] \u03c6s[j]\nnoncomputable section\n\ninstance {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length) :\n    Decidable (EqTimeOnly \u03c6s\u039b) :=\n    inferInstanceAs (Decidable (\u2200 (i j), {i, j} \u2208 \u03c6s\u039b.1 \u2192 timeOrderRel \u03c6s[i] \u03c6s[j]))\n\nnamespace EqTimeOnly\nvariable {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n\nlemma timeOrderRel_of_eqTimeOnly_pair {i j : Fin \u03c6s.length} (h : {i, j} \u2208 \u03c6s\u039b.1)\n    (hc : EqTimeOnly \u03c6s\u039b) :\n    timeOrderRel \u03c6s[i] \u03c6s[j] := by\n  have h' := hc\n  simp only [EqTimeOnly, ne_eq, Fin.getElem_fin, Finset.mem_filter, Finset.mem_univ,\n    true_and] at h'\n  exact h' i j h\n\nlemma timeOrderRel_both_of_eqTimeOnly {i j : Fin \u03c6s.length} (h : {i, j} \u2208 \u03c6s\u039b.1)\n    (hc : EqTimeOnly \u03c6s\u039b) :\n    timeOrderRel \u03c6s[i] \u03c6s[j] \u2227 timeOrderRel \u03c6s[j] \u03c6s[i] := by\n  apply And.intro\n  \u00b7 exact timeOrderRel_of_eqTimeOnly_pair \u03c6s\u039b h hc\n  \u00b7 apply timeOrderRel_of_eqTimeOnly_pair \u03c6s\u039b _ hc\n    rw [@Finset.pair_comm]\n    exact h\n\nlemma eqTimeOnly_iff_forall_finset {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length) :\n    \u03c6s\u039b.EqTimeOnly \u2194 \u2200 (a : \u03c6s\u039b.1),\n      timeOrderRel (\u03c6s[\u03c6s\u039b.fstFieldOfContract a]) (\u03c6s[\u03c6s\u039b.sndFieldOfContract a])\n      \u2227 timeOrderRel (\u03c6s[\u03c6s\u039b.sndFieldOfContract a]) (\u03c6s[\u03c6s\u039b.fstFieldOfContract a]) := by\n  apply Iff.intro\n  \u00b7 intro h a\n    apply timeOrderRel_both_of_eqTimeOnly \u03c6s\u039b _ h\n    rw [\u2190 finset_eq_fstFieldOfContract_sndFieldOfContract]\n    simp\n  \u00b7 intro h\n    simp only [EqTimeOnly, Fin.getElem_fin, Finset.mem_filter, Finset.mem_univ,\n      true_and]\n    intro i j h1\n    have h' := h \u27e8{i, j}, h1\u27e9\n    by_cases hij: i < j\n    \u00b7 have hi : \u03c6s\u039b.fstFieldOfContract \u27e8{i, j}, h1\u27e9 = i := by\n        apply eq_fstFieldOfContract_of_mem _ _ i j\n        \u00b7 simp\n        \u00b7 simp\n        \u00b7 exact hij\n      have hj : \u03c6s\u039b.sndFieldOfContract \u27e8{i, j}, h1\u27e9 = j := by\n        apply eq_sndFieldOfContract_of_mem _ _ i j\n        \u00b7 simp\n        \u00b7 simp\n        \u00b7 exact hij\n      simp_all\n    \u00b7 have hij : i \u2260 j := by\n        by_contra hij\n        subst hij\n        have h2 := \u03c6s\u039b.2.1 {i, i} h1\n        simp at h2\n      have hj : \u03c6s\u039b.fstFieldOfContract \u27e8{i, j}, h1\u27e9 = j := by\n        apply eq_fstFieldOfContract_of_mem _ _ j i\n        \u00b7 simp\n        \u00b7 simp\n        \u00b7 omega\n      have hi : \u03c6s\u039b.sndFieldOfContract \u27e8{i, j}, h1\u27e9 = i := by\n        apply eq_sndFieldOfContract_of_mem _ _ j i\n        \u00b7 simp\n        \u00b7 simp\n        \u00b7 omega\n      simp_all\n\n@[simp]\nlemma empty_mem {\u03c6s : List \ud835\udcd5.FieldOp} : empty (n := \u03c6s.length).EqTimeOnly := by\n  rw [eqTimeOnly_iff_forall_finset]\n  simp [empty]\n\n/-- Let `\u03c6s` be a list of `\ud835\udcd5.FieldOp` and `\u03c6s\u039b` a `WickContraction` of `\u03c6s` with\n  in which every contraction involves two `\ud835\udcd5FieldOp`s that have the same time, then\n  `\u03c6s\u039b.staticContract = \u03c6s\u039b.timeContract`. -/\nlemma staticContract_eq_timeContract_of_eqTimeOnly (h : \u03c6s\u039b.EqTimeOnly) :\n    \u03c6s\u039b.staticContract = \u03c6s\u039b.timeContract := by\n  simp only [staticContract, timeContract]\n  apply congrArg\n  funext a\n  ext\n  simp only [List.get_eq_getElem]\n  rw [timeContract_of_timeOrderRel]\n  apply timeOrderRel_of_eqTimeOnly_pair \u03c6s\u039b\n  rw [\u2190 finset_eq_fstFieldOfContract_sndFieldOfContract]\n  exact a.2\n  exact h\n\nlemma eqTimeOnly_congr {\u03c6s \u03c6s' : List \ud835\udcd5.FieldOp} (h : \u03c6s = \u03c6s') (\u03c6s\u039b : WickContraction \u03c6s.length) :\n    (congr (by simp [h]) \u03c6s\u039b).EqTimeOnly (\u03c6s := \u03c6s') \u2194 \u03c6s\u039b.EqTimeOnly := by\n  subst h\n  simp\n\nlemma quotContraction_eqTimeOnly {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    (h : \u03c6s\u039b.EqTimeOnly) (S : Finset (Finset (Fin \u03c6s.length))) (ha : S \u2286 \u03c6s\u039b.1) :\n    (\u03c6s\u039b.quotContraction S ha).EqTimeOnly := by\n  rw [eqTimeOnly_iff_forall_finset]\n  intro a\n  simp only [Fin.getElem_fin]\n  erw [subContraction_uncontractedList_get]\n  erw [subContraction_uncontractedList_get]\n  simp only [quotContraction_fstFieldOfContract_uncontractedListEmd, Fin.getElem_fin,\n    quotContraction_sndFieldOfContract_uncontractedListEmd]\n  rw [eqTimeOnly_iff_forall_finset] at h\n  apply h\n\nlemma exists_join_singleton_of_card_ge_zero {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (h : 0 < \u03c6s\u039b.1.card) (h1 : \u03c6s\u039b.EqTimeOnly) :\n    \u2203 (i j : Fin \u03c6s.length) (h : i < j) (\u03c6suc\u039b : WickContraction [singleton h]\u1d58\u1d9c.length),\n    \u03c6s\u039b = join (singleton h) \u03c6suc\u039b \u2227 (timeOrderRel \u03c6s[i] \u03c6s[j] \u2227 timeOrderRel \u03c6s[j] \u03c6s[i])\n    \u2227 \u03c6suc\u039b.EqTimeOnly \u2227 \u03c6suc\u039b.1.card + 1 = \u03c6s\u039b.1.card := by\n  obtain \u27e8a, ha\u27e9 := exists_contraction_pair_of_card_ge_zero \u03c6s\u039b h\n  use \u03c6s\u039b.fstFieldOfContract \u27e8a, ha\u27e9\n  use \u03c6s\u039b.sndFieldOfContract \u27e8a, ha\u27e9\n  use \u03c6s\u039b.fstFieldOfContract_lt_sndFieldOfContract \u27e8a, ha\u27e9\n  let \u03c6suc\u039b :\n    WickContraction [singleton (\u03c6s\u039b.fstFieldOfContract_lt_sndFieldOfContract \u27e8a, ha\u27e9)]\u1d58\u1d9c.length :=\n    congr (by simp [\u2190 subContraction_singleton_eq_singleton])\n    (\u03c6s\u039b.quotContraction {a} (by simpa using ha))\n  use \u03c6suc\u039b\n  simp only [Fin.getElem_fin]\n  apply And.intro\n  \u00b7 have h1 := join_congr (subContraction_singleton_eq_singleton _ \u27e8a, ha\u27e9).symm (\u03c6suc\u039b := \u03c6suc\u039b)\n    simp only [id_eq, eq_mpr_eq_cast, h1, congr_trans_apply, congr_refl, \u03c6suc\u039b]\n    rw [join_sub_quot]\n  \u00b7 apply And.intro\n    \u00b7 apply timeOrderRel_both_of_eqTimeOnly \u03c6s\u039b _ h1\n      rw [\u2190 finset_eq_fstFieldOfContract_sndFieldOfContract]\n      simp [ha]\n    apply And.intro\n    \u00b7 simp only [id_eq, eq_mpr_eq_cast, \u03c6suc\u039b]\n      rw [eqTimeOnly_congr (\u03c6s := [(\u03c6s\u039b.subContraction {a} (by simpa using ha))]\u1d58\u1d9c)]\n      simp only [id_eq, eq_mpr_eq_cast]\n      exact quotContraction_eqTimeOnly h1 _ _\n      rw [\u2190 subContraction_singleton_eq_singleton]\n    \u00b7 simp only [id_eq, eq_mpr_eq_cast, card_congr, \u03c6suc\u039b]\n      have h1 := subContraction_card_plus_quotContraction_card_eq _ {a} (by simpa using ha)\n      simp only [subContraction, Finset.card_singleton, id_eq, eq_mpr_eq_cast] at h1\n      omega\n\nlemma timeOrder_timeContract_mul_of_eqTimeOnly_mid_induction {\u03c6s : List \ud835\udcd5.FieldOp}\n    (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (hl : \u03c6s\u039b.EqTimeOnly) (a b: \ud835\udcd5.FieldOpAlgebra) : (n : \u2115) \u2192 (hn : \u03c6s\u039b.1.card = n) \u2192\n    \ud835\udce3(a * \u03c6s\u039b.timeContract.1 * b) = \u03c6s\u039b.timeContract.1 * \ud835\udce3(a * b)\n  | 0, hn => by\n    rw [@card_zero_iff_empty] at hn\n    subst hn\n    simp\n  | Nat.succ n, hn => by\n    obtain \u27e8i, j, hij, \u03c6suc\u039b, rfl, h2, h3, h4\u27e9 :=\n      exists_join_singleton_of_card_ge_zero \u03c6s\u039b (by simp [hn]) hl\n    rw [join_timeContract]\n    rw [singleton_timeContract]\n    simp only [Fin.getElem_fin, MulMemClass.coe_mul]\n    trans timeOrder (a * FieldOpAlgebra.timeContract \u03c6s[\u2191i] \u03c6s[\u2191j] * (\u03c6suc\u039b.timeContract.1 * b))\n    simp only [mul_assoc, Fin.getElem_fin]\n    rw [timeOrder_timeContract_eq_time_mid]\n    have ih := timeOrder_timeContract_mul_of_eqTimeOnly_mid_induction \u03c6suc\u039b h3 a b n (by omega)\n    rw [\u2190 mul_assoc, ih]\n    simp only [Fin.getElem_fin, mul_assoc]\n    simp_all only [Nat.succ_eq_add_one, Fin.getElem_fin, add_left_inj]\n    simp_all\n\nlemma timeOrder_timeContract_mul_of_eqTimeOnly_mid {\u03c6s : List \ud835\udcd5.FieldOp}\n    (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (hl : \u03c6s\u039b.EqTimeOnly) (a b : \ud835\udcd5.FieldOpAlgebra) :\n    \ud835\udce3(a * \u03c6s\u039b.timeContract.1 * b) = \u03c6s\u039b.timeContract.1 * \ud835\udce3(a * b) := by\n  exact timeOrder_timeContract_mul_of_eqTimeOnly_mid_induction \u03c6s\u039b hl a b \u03c6s\u039b.1.card rfl\n\n/-- Let `\u03c6s` be a list of `\ud835\udcd5.FieldOp`, `\u03c6s\u039b` a `WickContraction` of `\u03c6s` with\n  in which every contraction involves two `\ud835\udcd5.FieldOp`s that have the same time and\n  `b` a general element in `\ud835\udcd5.FieldOpAlgebra`. Then\n  `\ud835\udce3(\u03c6s\u039b.timeContract.1 * b) = \u03c6s\u039b.timeContract.1 * \ud835\udce3(b)`.\n\n  This follows from properties of orderings and the ideal defining `\ud835\udcd5.FieldOpAlgebra`. -/\nlemma timeOrder_timeContract_mul_of_eqTimeOnly_left {\u03c6s : List \ud835\udcd5.FieldOp}\n    (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (hl : \u03c6s\u039b.EqTimeOnly) (b : \ud835\udcd5.FieldOpAlgebra) :\n    \ud835\udce3(\u03c6s\u039b.timeContract.1 * b) = \u03c6s\u039b.timeContract.1 * \ud835\udce3(b) := by\n  trans \ud835\udce3(1 * \u03c6s\u039b.timeContract.1 * b)\n  simp only [one_mul]\n  rw [timeOrder_timeContract_mul_of_eqTimeOnly_mid \u03c6s\u039b hl]\n  simp\n\nlemma exists_join_singleton_of_not_eqTimeOnly {\u03c6s : List \ud835\udcd5.FieldOp}\n    (\u03c6s\u039b : WickContraction \u03c6s.length) (h1 : \u00ac \u03c6s\u039b.EqTimeOnly) :\n    \u2203 (i j : Fin \u03c6s.length) (h : i < j) (\u03c6suc\u039b : WickContraction [singleton h]\u1d58\u1d9c.length),\n    \u03c6s\u039b = join (singleton h) \u03c6suc\u039b \u2227 (\u00ac timeOrderRel \u03c6s[i] \u03c6s[j] \u2228 \u00ac timeOrderRel \u03c6s[j] \u03c6s[i]) := by\n  rw [eqTimeOnly_iff_forall_finset] at h1\n  simp only [Fin.getElem_fin, Subtype.forall, not_forall, not_and] at h1\n  obtain \u27e8a, ha, hr\u27e9 := h1\n  use \u03c6s\u039b.fstFieldOfContract \u27e8a, ha\u27e9\n  use \u03c6s\u039b.sndFieldOfContract \u27e8a, ha\u27e9\n  use \u03c6s\u039b.fstFieldOfContract_lt_sndFieldOfContract \u27e8a, ha\u27e9\n  let \u03c6suc\u039b :\n    WickContraction [singleton (\u03c6s\u039b.fstFieldOfContract_lt_sndFieldOfContract \u27e8a, ha\u27e9)]\u1d58\u1d9c.length :=\n    congr (by simp [\u2190 subContraction_singleton_eq_singleton])\n      (\u03c6s\u039b.quotContraction {a} (by simpa using ha))\n  use \u03c6suc\u039b\n  simp only [Fin.getElem_fin]\n  apply And.intro\n  \u00b7 have h1 := join_congr (subContraction_singleton_eq_singleton _ \u27e8a, ha\u27e9).symm (\u03c6suc\u039b := \u03c6suc\u039b)\n    simp only [id_eq, eq_mpr_eq_cast, h1, congr_trans_apply, congr_refl, \u03c6suc\u039b]\n    rw [join_sub_quot]\n  \u00b7 by_cases h1 : timeOrderRel \u03c6s[\u2191(\u03c6s\u039b.fstFieldOfContract \u27e8a, ha\u27e9)]\n      \u03c6s[\u2191(\u03c6s\u039b.sndFieldOfContract \u27e8a, ha\u27e9)]\n    \u00b7 simp_all [h1]\n    \u00b7 simp_all [h1]\n\nlemma timeOrder_timeContract_of_not_eqTimeOnly {\u03c6s : List \ud835\udcd5.FieldOp}\n    (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (hl : \u00ac \u03c6s\u039b.EqTimeOnly) : \ud835\udce3(\u03c6s\u039b.timeContract.1) = 0 := by\n  obtain \u27e8i, j, hij, \u03c6suc\u039b, rfl, hr\u27e9 := exists_join_singleton_of_not_eqTimeOnly \u03c6s\u039b hl\n  rw [join_timeContract]\n  rw [singleton_timeContract]\n  simp only [Fin.getElem_fin, MulMemClass.coe_mul]\n  rw [timeOrder_timeOrder_left]\n  rw [timeOrder_timeContract_neq_time]\n  simp only [zero_mul, map_zero]\n  simp_all only [Fin.getElem_fin, not_and]\n  intro h\n  simp_all\n\n/-- Let `\u03c6s` be a list of `\ud835\udcd5.FieldOp` and `\u03c6s\u039b` a `WickContraction` with\n  at least one contraction between `\ud835\udcd5.FieldOp` that do not have the same time. Then\n  `\ud835\udce3(\u03c6s\u039b.staticContract.1) = 0`. -/\nlemma timeOrder_staticContract_of_not_mem {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (hl : \u00ac \u03c6s\u039b.EqTimeOnly) : \ud835\udce3(\u03c6s\u039b.staticContract.1) = 0 := by\n  obtain \u27e8i, j, hij, \u03c6suc\u039b, rfl, hr\u27e9 := exists_join_singleton_of_not_eqTimeOnly \u03c6s\u039b hl\n  rw [join_staticContract]\n  simp only [MulMemClass.coe_mul]\n  rw [singleton_staticContract]\n  rw [timeOrder_timeOrder_left]\n  rw [timeOrder_superCommute_anPart_ofFieldOp_neq_time]\n  simp only [zero_mul, map_zero]\n  intro h\n  simp_all\n\nend EqTimeOnly\n\n/-- The condition on a Wick contraction which is true if it has at least one contraction\n  which is between two equal time fields. -/\ndef HaveEqTime {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length) : Prop :=\n  \u2203 (i j : Fin \u03c6s.length) (h : {i, j} \u2208 \u03c6s\u039b.1),\n  timeOrderRel \u03c6s[i] \u03c6s[j] \u2227 timeOrderRel \u03c6s[j] \u03c6s[i]\n\nnoncomputable instance {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length) :\n    Decidable (HaveEqTime \u03c6s\u039b) :=\n  inferInstanceAs (Decidable (\u2203 (i j : Fin \u03c6s.length)\n    (h : ({i, j} : Finset (Fin \u03c6s.length)) \u2208 \u03c6s\u039b.1),\n    timeOrderRel \u03c6s[i] \u03c6s[j] \u2227 timeOrderRel \u03c6s[j] \u03c6s[i]))\n\nlemma haveEqTime_iff_finset {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length) :\n    HaveEqTime \u03c6s\u039b \u2194 \u2203 (a : Finset (Fin \u03c6s.length)) (h : a \u2208 \u03c6s\u039b.1),\n      timeOrderRel \u03c6s[\u03c6s\u039b.fstFieldOfContract \u27e8a, h\u27e9] \u03c6s[\u03c6s\u039b.sndFieldOfContract \u27e8a, h\u27e9]\n    \u2227 timeOrderRel \u03c6s[\u03c6s\u039b.sndFieldOfContract \u27e8a, h\u27e9] \u03c6s[\u03c6s\u039b.fstFieldOfContract \u27e8a, h\u27e9] := by\n  simp only [HaveEqTime, Fin.getElem_fin, exists_and_left, exists_prop]\n  apply Iff.intro\n  \u00b7 intro h\n    obtain \u27e8i, j, hij, h1, h2\u27e9 := h\n    use {i, j}, h1\n    by_cases hij : i < j\n    \u00b7 have h1n := eq_fstFieldOfContract_of_mem \u03c6s\u039b \u27e8{i,j}, h1\u27e9 i j (by simp) (by simp) hij\n      have h2n := eq_sndFieldOfContract_of_mem \u03c6s\u039b \u27e8{i,j}, h1\u27e9 i j (by simp) (by simp) hij\n      simp only [h1n, h2n]\n      simp_all only [forall_true_left, true_and]\n    \u00b7 have hineqj : i \u2260 j := by\n        by_contra hineqj\n        subst hineqj\n        have h2 := \u03c6s\u039b.2.1 {i, i} h1\n        simp_all\n      have hji : j < i := by omega\n      have h1n := eq_fstFieldOfContract_of_mem \u03c6s\u039b \u27e8{i,j}, h1\u27e9 j i (by simp) (by simp) hji\n      have h2n := eq_sndFieldOfContract_of_mem \u03c6s\u039b \u27e8{i,j}, h1\u27e9 j i (by simp) (by simp) hji\n      simp only [h1n, h2n]\n      simp_all\n  \u00b7 intro h\n    obtain \u27e8a, h1, h2, h3\u27e9 := h\n    use \u03c6s\u039b.fstFieldOfContract \u27e8a, h1\u27e9\n    use \u03c6s\u039b.sndFieldOfContract \u27e8a, h1\u27e9\n    simp_all only [and_true, true_and]\n    rw [\u2190 finset_eq_fstFieldOfContract_sndFieldOfContract]\n    exact h1\n\n@[simp]\nlemma empty_not_haveEqTime {\u03c6s : List \ud835\udcd5.FieldOp} :\n    \u00ac HaveEqTime (empty : WickContraction \u03c6s.length) := by\n  rw [haveEqTime_iff_finset]\n  simp [empty]\n\n/-- Given a Wick contraction the subset of contracted pairs between equal time fields. -/\ndef eqTimeContractSet {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length) :\n    Finset (Finset (Fin \u03c6s.length)) :=\n  Finset.univ.filter (fun a =>\n    a \u2208 \u03c6s\u039b.1 \u2227 \u2200 (h : a \u2208 \u03c6s\u039b.1),\n    timeOrderRel \u03c6s[\u03c6s\u039b.fstFieldOfContract \u27e8a, h\u27e9] \u03c6s[\u03c6s\u039b.sndFieldOfContract \u27e8a, h\u27e9]\n    \u2227 timeOrderRel \u03c6s[\u03c6s\u039b.sndFieldOfContract \u27e8a, h\u27e9] \u03c6s[\u03c6s\u039b.fstFieldOfContract \u27e8a, h\u27e9])\n\nlemma eqTimeContractSet_subset {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length) :\n    eqTimeContractSet \u03c6s\u039b \u2286 \u03c6s\u039b.1 := by\n  simp only [eqTimeContractSet, Fin.getElem_fin]\n  intro a\n  simp only [Finset.mem_filter, Finset.mem_univ, true_and, and_imp]\n  intro h _\n  exact h\n\nlemma mem_of_mem_eqTimeContractSet{\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {a : Finset (Fin \u03c6s.length)} (h : a \u2208 eqTimeContractSet \u03c6s\u039b) : a \u2208 \u03c6s\u039b.1 := by\n  simp only [eqTimeContractSet, Fin.getElem_fin, Finset.mem_filter, Finset.mem_univ, true_and] at h\n  exact h.1\n\nlemma join_eqTimeContractSet {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) :\n    eqTimeContractSet (join \u03c6s\u039b \u03c6suc\u039b) = \u03c6s\u039b.eqTimeContractSet \u222a\n    \u03c6suc\u039b.eqTimeContractSet.map (Finset.mapEmbedding uncontractedListEmd).toEmbedding := by\n  ext a\n  apply Iff.intro\n  \u00b7 intro h\n    have hmem := mem_of_mem_eqTimeContractSet h\n    have ht := joinLiftLeft_or_joinLiftRight_of_mem_join (\u03c6suc\u039b := \u03c6suc\u039b) _ hmem\n    rcases ht with ht | ht\n    \u00b7 obtain \u27e8b, rfl\u27e9 := ht\n      simp only [Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,\n        RelEmbedding.coe_toEmbedding]\n      left\n      simp only [eqTimeContractSet, Fin.getElem_fin, Finset.mem_filter, Finset.mem_univ, true_and]\n      apply And.intro (by simp [joinLiftLeft])\n      intro h'\n      simp only [eqTimeContractSet, Fin.getElem_fin, Finset.mem_filter, Finset.mem_univ,\n        Finset.coe_mem, Subtype.coe_eta, join_fstFieldOfContract_joinLiftLeft,\n        join_sndFieldOfContract_joinLift, forall_true_left, true_and] at h\n      exact h\n    \u00b7 obtain \u27e8b, rfl\u27e9 := ht\n      simp only [Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,\n        RelEmbedding.coe_toEmbedding]\n      right\n      use b\n      rw [Finset.mapEmbedding_apply]\n      simp only [joinLiftRight, and_true]\n      simpa [eqTimeContractSet] using h\n  \u00b7 intro h\n    simp only [Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,\n      RelEmbedding.coe_toEmbedding] at h\n    rcases h with h | h\n    \u00b7 simp only [eqTimeContractSet, Fin.getElem_fin, Finset.mem_filter, Finset.mem_univ, true_and]\n      simp only [eqTimeContractSet, Fin.getElem_fin, Finset.mem_filter, Finset.mem_univ,\n        true_and] at h\n      apply And.intro\n      \u00b7 simp [join, h.1]\n      \u00b7 intro h'\n        have h2 := h.2 h.1\n        exact h2\n    \u00b7 simp only [eqTimeContractSet, Fin.getElem_fin, Finset.mem_filter, Finset.mem_univ, true_and]\n      simp only [eqTimeContractSet, Fin.getElem_fin, Finset.mem_filter, Finset.mem_univ,\n        true_and] at h\n      obtain \u27e8b, h1, h2, rfl\u27e9 := h\n      apply And.intro\n      \u00b7 simp [join, h1]\n      \u00b7 intro h'\n        have h2 := h1.2 h1.1\n        have hj : \u27e8(Finset.mapEmbedding uncontractedListEmd) b, h'\u27e9\n          = joinLiftRight \u27e8b, h1.1\u27e9 := by rfl\n        simp only [hj, join_fstFieldOfContract_joinLiftRight, getElem_uncontractedListEmd,\n          join_sndFieldOfContract_joinLiftRight]\n        simpa using h2\n\n", "theoremStatement": "lemma eqTimeContractSet_of_not_haveEqTime {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    (h : \u00ac HaveEqTime \u03c6s\u039b) : eqTimeContractSet \u03c6s\u039b = \u2205 ", "theoremName": "WickContraction.eqTimeContractSet_of_not_haveEqTime", "fileCreated": {"commit": "6f9350691ec587ce5a2e2002d88bcfe95e670cc8", "date": "2025-02-03"}, "theoremCreated": {"commit": "006e29fd08e20d8c1c3d81de0e3bfcb268782a3d", "date": "2025-02-01"}, "file": "HepLean/HepLean/PerturbationTheory/WickContraction/TimeCond.lean", "module": "HepLean.PerturbationTheory.WickContraction.TimeCond", "jsonFile": "HepLean.PerturbationTheory.WickContraction.TimeCond.jsonl", "positionMetadata": {"lineInFile": 393, "tokenPositionInFile": 16428, "theoremPositionInFile": 21}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 10, "numPremises": 95}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  ext a\n  simp only [Finset.not_mem_empty, iff_false]\n  by_contra hn\n  rw [haveEqTime_iff_finset] at h\n  simp only [Fin.getElem_fin, not_exists, not_and] at h\n  simp only [eqTimeContractSet, Fin.getElem_fin, Finset.mem_filter, Finset.mem_univ, true_and] at hn\n  have h2 := hn.2 hn.1\n  simp_all", "proofType": "tactic", "proofLengthLines": 8, "proofLengthTokens": 299}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.TimeOrder\nimport HepLean.PerturbationTheory.FieldOpAlgebra.SuperCommute\n/-!\n\n# Time Ordering on Field operator algebra\n\n-/\n\nnamespace FieldSpecification\nopen FieldOpFreeAlgebra\nopen HepLean.List\nopen FieldStatistic\n\nnamespace FieldOpAlgebra\nvariable {\ud835\udcd5 : FieldSpecification}\n\nlemma \u03b9_timeOrderF_superCommuteF_superCommuteF_eq_time_ofCrAnListF {\u03c61 \u03c62 \u03c63 : \ud835\udcd5.CrAnFieldOp}\n    (\u03c6s1 \u03c6s2 : List \ud835\udcd5.CrAnFieldOp) (h :\n      crAnTimeOrderRel \u03c61 \u03c62 \u2227 crAnTimeOrderRel \u03c61 \u03c63 \u2227\n      crAnTimeOrderRel \u03c62 \u03c61 \u2227 crAnTimeOrderRel \u03c62 \u03c63 \u2227\n      crAnTimeOrderRel \u03c63 \u03c61 \u2227 crAnTimeOrderRel \u03c63 \u03c62) :\n    \u03b9 \ud835\udce3\u1da0(ofCrAnListF \u03c6s1 * [ofCrAnOpF \u03c61, [ofCrAnOpF \u03c62, ofCrAnOpF \u03c63]\u209bca]\u209bca *\n    ofCrAnListF \u03c6s2) = 0 := by\n  let l1 :=\n    (List.takeWhile (fun c => \u00ac crAnTimeOrderRel \u03c61 c)\n    ((\u03c6s1 ++ \u03c6s2).insertionSort crAnTimeOrderRel))\n    ++ (List.filter (fun c => crAnTimeOrderRel \u03c61 c \u2227 crAnTimeOrderRel c \u03c61) \u03c6s1)\n  let l2 := (List.filter (fun c => crAnTimeOrderRel \u03c61 c \u2227 crAnTimeOrderRel c \u03c61) \u03c6s2)\n    ++ (List.filter (fun c => crAnTimeOrderRel \u03c61 c \u2227 \u00ac crAnTimeOrderRel c \u03c61)\n    ((\u03c6s1 ++ \u03c6s2).insertionSort crAnTimeOrderRel))\n  have h123 : \u03b9 \ud835\udce3\u1da0(ofCrAnListF (\u03c6s1 ++ \u03c61 :: \u03c62 :: \u03c63 :: \u03c6s2)) =\n      crAnTimeOrderSign (\u03c6s1 ++ \u03c61 :: \u03c62 :: \u03c63 :: \u03c6s2)\n      \u2022 (\u03b9 (ofCrAnListF l1) * \u03b9 (ofCrAnListF [\u03c61, \u03c62, \u03c63]) * \u03b9 (ofCrAnListF l2)) := by\n    have h1 := insertionSort_of_eq_list \ud835\udcd5.crAnTimeOrderRel \u03c61 \u03c6s1 [\u03c61, \u03c62, \u03c63] \u03c6s2\n      (by simp_all)\n    rw [timeOrderF_ofCrAnListF, show \u03c6s1 ++ \u03c61 :: \u03c62 :: \u03c63 :: \u03c6s2 = \u03c6s1 ++ [\u03c61, \u03c62, \u03c63] ++ \u03c6s2\n      by simp, crAnTimeOrderList, h1]\n    simp only [List.append_assoc, List.singleton_append, decide_not,\n      Bool.decide_and, ofCrAnListF_append, map_smul, map_mul, l1, l2, mul_assoc]\n  have h132 : \u03b9 \ud835\udce3\u1da0(ofCrAnListF (\u03c6s1 ++ \u03c61 :: \u03c63 :: \u03c62 :: \u03c6s2)) =\n      crAnTimeOrderSign (\u03c6s1 ++ \u03c61 :: \u03c62 :: \u03c63 :: \u03c6s2)\n      \u2022 (\u03b9 (ofCrAnListF l1) * \u03b9 (ofCrAnListF [\u03c61, \u03c63, \u03c62]) * \u03b9 (ofCrAnListF l2)) := by\n    have h1 := insertionSort_of_eq_list \ud835\udcd5.crAnTimeOrderRel \u03c61 \u03c6s1 [\u03c61, \u03c63, \u03c62] \u03c6s2\n        (by simp_all)\n    rw [timeOrderF_ofCrAnListF, show \u03c6s1 ++ \u03c61 :: \u03c63 :: \u03c62 :: \u03c6s2 = \u03c6s1 ++ [\u03c61, \u03c63, \u03c62] ++ \u03c6s2\n      by simp, crAnTimeOrderList, h1]\n    simp only [List.singleton_append, decide_not,\n      Bool.decide_and, ofCrAnListF_append, map_smul, map_mul, l1, l2, mul_assoc]\n    congr 1\n    have hp : List.Perm [\u03c61, \u03c63, \u03c62] [\u03c61, \u03c62, \u03c63] := by\n      refine List.Perm.cons \u03c61 ?_\n      exact List.Perm.swap \u03c62 \u03c63 []\n    rw [crAnTimeOrderSign, Wick.koszulSign_perm_eq _ _ \u03c61 _ _ _ _ _ hp, \u2190 crAnTimeOrderSign]\n    \u00b7 simp\n    \u00b7 intro \u03c64 h\u03c64\n      simp only [List.mem_cons, List.mem_singleton, List.not_mem_nil, or_false] at h\u03c64\n      rcases h\u03c64 with h\u03c64 | h\u03c64 | h\u03c64\n      all_goals\n        subst h\u03c64\n        simp_all\n  have hp231 : List.Perm [\u03c62, \u03c63, \u03c61] [\u03c61, \u03c62, \u03c63] := by\n      refine List.Perm.trans (l\u2082 := [\u03c62, \u03c61, \u03c63]) ?_ ?_\n      refine List.Perm.cons \u03c62 (List.Perm.swap \u03c61 \u03c63 [])\n      exact List.Perm.swap \u03c61 \u03c62 [\u03c63]\n  have h231 : \u03b9 \ud835\udce3\u1da0(ofCrAnListF (\u03c6s1 ++ \u03c62 :: \u03c63 :: \u03c61 :: \u03c6s2)) =\n      crAnTimeOrderSign (\u03c6s1 ++ \u03c61 :: \u03c62 :: \u03c63 :: \u03c6s2)\n      \u2022 (\u03b9 (ofCrAnListF l1) * \u03b9 (ofCrAnListF [\u03c62, \u03c63, \u03c61]) * \u03b9 (ofCrAnListF l2)) := by\n    have h1 := insertionSort_of_eq_list \ud835\udcd5.crAnTimeOrderRel \u03c61 \u03c6s1 [\u03c62, \u03c63, \u03c61] \u03c6s2\n        (by simp_all)\n    rw [timeOrderF_ofCrAnListF, show \u03c6s1 ++ \u03c62 :: \u03c63 :: \u03c61 :: \u03c6s2 = \u03c6s1 ++ [\u03c62, \u03c63, \u03c61] ++ \u03c6s2\n      by simp, crAnTimeOrderList, h1]\n    simp only [List.singleton_append, decide_not,\n      Bool.decide_and, ofCrAnListF_append, map_smul, map_mul, l1, l2, mul_assoc]\n    congr 1\n    rw [crAnTimeOrderSign, Wick.koszulSign_perm_eq _ _ \u03c61 _ _ _ _ _ hp231, \u2190 crAnTimeOrderSign]\n    \u00b7 simp\n    \u00b7 intro \u03c64 h\u03c64\n      simp only [List.mem_cons, List.mem_singleton, List.not_mem_nil, or_false] at h\u03c64\n      rcases h\u03c64 with h\u03c64 | h\u03c64 | h\u03c64\n      all_goals\n        subst h\u03c64\n        simp_all\n  have h321 : \u03b9 \ud835\udce3\u1da0(ofCrAnListF (\u03c6s1 ++ \u03c63 :: \u03c62 :: \u03c61 :: \u03c6s2)) =\n      crAnTimeOrderSign (\u03c6s1 ++ \u03c61 :: \u03c62 :: \u03c63 :: \u03c6s2)\n      \u2022 (\u03b9 (ofCrAnListF l1) * \u03b9 (ofCrAnListF [\u03c63, \u03c62, \u03c61]) * \u03b9 (ofCrAnListF l2)) := by\n    have h1 := insertionSort_of_eq_list \ud835\udcd5.crAnTimeOrderRel \u03c61 \u03c6s1 [\u03c63, \u03c62, \u03c61] \u03c6s2\n        (by simp_all)\n    rw [timeOrderF_ofCrAnListF, show \u03c6s1 ++ \u03c63 :: \u03c62 :: \u03c61 :: \u03c6s2 = \u03c6s1 ++ [\u03c63, \u03c62, \u03c61] ++ \u03c6s2\n      by simp, crAnTimeOrderList, h1]\n    simp only [List.singleton_append, decide_not,\n      Bool.decide_and, ofCrAnListF_append, map_smul, map_mul, l1, l2, mul_assoc]\n    congr 1\n    have hp : List.Perm [\u03c63, \u03c62, \u03c61] [\u03c61, \u03c62, \u03c63] := by\n      refine List.Perm.trans ?_ hp231\n      exact List.Perm.swap \u03c62 \u03c63 [\u03c61]\n    rw [crAnTimeOrderSign, Wick.koszulSign_perm_eq _ _ \u03c61 _ _ _ _ _ hp, \u2190 crAnTimeOrderSign]\n    \u00b7 simp\n    \u00b7 intro \u03c64 h\u03c64\n      simp only [List.mem_cons, List.mem_singleton, List.not_mem_nil, or_false] at h\u03c64\n      rcases h\u03c64 with h\u03c64 | h\u03c64 | h\u03c64\n      all_goals\n        subst h\u03c64\n        simp_all\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton]\n  rw [superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp only [List.singleton_append, instCommGroup.eq_1, ofList_singleton, map_sub, map_smul]\n  rw [superCommuteF_ofCrAnListF_ofCrAnListF, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp only [List.cons_append, List.nil_append, instCommGroup.eq_1, ofList_singleton, mul_sub, \u2190\n    ofCrAnListF_append, Algebra.mul_smul_comm, sub_mul, List.append_assoc, Algebra.smul_mul_assoc,\n    map_sub, map_smul]\n  rw [h123, h132, h231, h321]\n  simp only [smul_smul]\n  rw [mul_comm, \u2190 smul_smul, mul_comm, \u2190 smul_smul]\n  rw [\u2190 smul_sub, \u2190 smul_sub, smul_smul, mul_comm, \u2190 smul_smul, \u2190 smul_sub]\n  simp only [smul_eq_zero]\n  right\n  rw [\u2190 smul_mul_assoc, \u2190 mul_smul_comm, mul_assoc]\n  rw [\u2190 smul_mul_assoc, \u2190 mul_smul_comm]\n  rw [smul_sub]\n  rw [\u2190 smul_mul_assoc, \u2190 mul_smul_comm]\n  rw [\u2190 smul_mul_assoc, \u2190 mul_smul_comm]\n  repeat rw [mul_assoc]\n  rw [\u2190 mul_sub, \u2190 mul_sub, \u2190 mul_sub]\n  rw [\u2190 sub_mul, \u2190 sub_mul, \u2190 sub_mul]\n  trans \u03b9 (ofCrAnListF l1) * \u03b9 [ofCrAnOpF \u03c61, [ofCrAnOpF \u03c62, ofCrAnOpF \u03c63]\u209bca]\u209bca *\n    \u03b9 (ofCrAnListF l2)\n  rw [mul_assoc]\n  congr\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton]\n  rw [superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp only [List.singleton_append, instCommGroup.eq_1, ofList_singleton, map_sub, map_smul]\n  rw [superCommuteF_ofCrAnListF_ofCrAnListF, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp only [List.cons_append, List.nil_append, instCommGroup.eq_1, ofList_singleton, map_sub,\n    map_smul, smul_sub]\n  simp_all\n\nlemma \u03b9_timeOrderF_superCommuteF_superCommuteF_ofCrAnListF {\u03c61 \u03c62 \u03c63 : \ud835\udcd5.CrAnFieldOp}\n    (\u03c6s1 \u03c6s2 : List \ud835\udcd5.CrAnFieldOp) :\n    \u03b9 \ud835\udce3\u1da0(ofCrAnListF \u03c6s1 * [ofCrAnOpF \u03c61, [ofCrAnOpF \u03c62, ofCrAnOpF \u03c63]\u209bca]\u209bca * ofCrAnListF \u03c6s2)\n    = 0 := by\n  by_cases h :\n      crAnTimeOrderRel \u03c61 \u03c62 \u2227 crAnTimeOrderRel \u03c61 \u03c63 \u2227\n      crAnTimeOrderRel \u03c62 \u03c61 \u2227 crAnTimeOrderRel \u03c62 \u03c63 \u2227\n      crAnTimeOrderRel \u03c63 \u03c61 \u2227 crAnTimeOrderRel \u03c63 \u03c62\n  \u00b7 exact \u03b9_timeOrderF_superCommuteF_superCommuteF_eq_time_ofCrAnListF \u03c6s1 \u03c6s2 h\n  \u00b7 rw [timeOrderF_timeOrderF_mid]\n    rw [timeOrderF_superCommuteF_ofCrAnOpF_superCommuteF_all_not_crAnTimeOrderRel _ _ _ h]\n    simp\n\n@[simp]\nlemma \u03b9_timeOrderF_superCommuteF_superCommuteF {\u03c61 \u03c62 \u03c63 : \ud835\udcd5.CrAnFieldOp}\n    (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \u03b9 \ud835\udce3\u1da0(a * [ofCrAnOpF \u03c61, [ofCrAnOpF \u03c62, ofCrAnOpF \u03c63]\u209bca]\u209bca * b) = 0 := by\n  let pb (b : \ud835\udcd5.FieldOpFreeAlgebra) (hc : b \u2208 Submodule.span \u2102 (Set.range ofCrAnListFBasis)) :\n    Prop := \u03b9 \ud835\udce3\u1da0(a * [ofCrAnOpF \u03c61, [ofCrAnOpF \u03c62, ofCrAnOpF \u03c63]\u209bca]\u209bca * b) = 0\n  change pb b (Basis.mem_span _ b)\n  apply Submodule.span_induction\n  \u00b7 intro x hx\n    obtain \u27e8\u03c6s, rfl\u27e9 := hx\n    simp only [ofListBasis_eq_ofList, pb]\n    let pa (a : \ud835\udcd5.FieldOpFreeAlgebra) (hc : a \u2208 Submodule.span \u2102 (Set.range ofCrAnListFBasis)) :\n      Prop := \u03b9 \ud835\udce3\u1da0(a * [ofCrAnOpF \u03c61, [ofCrAnOpF \u03c62, ofCrAnOpF \u03c63]\u209bca]\u209bca * ofCrAnListF \u03c6s) = 0\n    change pa a (Basis.mem_span _ a)\n    apply Submodule.span_induction\n    \u00b7 intro x hx\n      obtain \u27e8\u03c6s', rfl\u27e9 := hx\n      simp only [ofListBasis_eq_ofList, pa]\n      exact \u03b9_timeOrderF_superCommuteF_superCommuteF_ofCrAnListF \u03c6s' \u03c6s\n    \u00b7 simp [pa]\n    \u00b7 intro x y hx hy hpx hpy\n      simp_all [pa,mul_add, add_mul]\n    \u00b7 intro x hx hpx\n      simp_all [pa, hpx]\n  \u00b7 simp [pb]\n  \u00b7 intro x y hx hy hpx hpy\n    simp_all [pb,mul_add, add_mul]\n  \u00b7 intro x hx hpx\n    simp_all [pb, hpx]\n\nlemma \u03b9_timeOrderF_superCommuteF_eq_time {\u03c6 \u03c8 : \ud835\udcd5.CrAnFieldOp}\n    (h\u03c6\u03c8 : crAnTimeOrderRel \u03c6 \u03c8) (h\u03c8\u03c6 : crAnTimeOrderRel \u03c8 \u03c6) (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \u03b9 \ud835\udce3\u1da0(a * [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca * b) =\n    \u03b9 ([ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca * \ud835\udce3\u1da0(a * b)) := by\n  let pb (b : \ud835\udcd5.FieldOpFreeAlgebra) (hc : b \u2208 Submodule.span \u2102 (Set.range ofCrAnListFBasis)) :\n    Prop := \u03b9 \ud835\udce3\u1da0(a * [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca * b) =\n    \u03b9 ([ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca * \ud835\udce3\u1da0(a * b))\n  change pb b (Basis.mem_span _ b)\n  apply Submodule.span_induction\n  \u00b7 intro x hx\n    obtain \u27e8\u03c6s, rfl\u27e9 := hx\n    simp only [ofListBasis_eq_ofList, map_mul, pb]\n    let pa (a : \ud835\udcd5.FieldOpFreeAlgebra) (hc : a \u2208 Submodule.span \u2102 (Set.range ofCrAnListFBasis)) :\n      Prop := \u03b9 \ud835\udce3\u1da0(a * [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca * ofCrAnListF \u03c6s) =\n      \u03b9 ([ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca * \ud835\udce3\u1da0(a* ofCrAnListF \u03c6s))\n    change pa a (Basis.mem_span _ a)\n    apply Submodule.span_induction\n    \u00b7 intro x hx\n      obtain \u27e8\u03c6s', rfl\u27e9 := hx\n      simp only [ofListBasis_eq_ofList, map_mul, pa]\n      conv_lhs =>\n        rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n        simp [mul_sub, sub_mul, \u2190 ofCrAnListF_append]\n        rw [timeOrderF_ofCrAnListF, timeOrderF_ofCrAnListF]\n      have h1 : crAnTimeOrderSign (\u03c6s' ++ \u03c6 :: \u03c8 :: \u03c6s) =\n          crAnTimeOrderSign (\u03c6s' ++ \u03c8 :: \u03c6 :: \u03c6s) := by\n        trans crAnTimeOrderSign (\u03c6s' ++ [\u03c6, \u03c8] ++ \u03c6s)\n        simp only [List.append_assoc, List.cons_append, List.nil_append]\n        rw [crAnTimeOrderSign]\n        have hp : List.Perm [\u03c6,\u03c8] [\u03c8,\u03c6] := by exact List.Perm.swap \u03c8 \u03c6 []\n        rw [Wick.koszulSign_perm_eq _ _ \u03c6 _ _ _ _ _ hp]\n        simp only [List.append_assoc, List.cons_append, List.singleton_append]\n        rfl\n        simp_all\n      rw [h1]\n      simp only [map_smul]\n      have h1 := insertionSort_of_eq_list \ud835\udcd5.crAnTimeOrderRel \u03c6 \u03c6s' [\u03c6, \u03c8] \u03c6s\n        (by simp_all)\n      rw [crAnTimeOrderList, show \u03c6s' ++ \u03c6 :: \u03c8 :: \u03c6s = \u03c6s' ++ [\u03c6, \u03c8] ++ \u03c6s by simp, h1]\n      have h2 := insertionSort_of_eq_list \ud835\udcd5.crAnTimeOrderRel \u03c6 \u03c6s' [\u03c8, \u03c6] \u03c6s\n        (by simp_all)\n      rw [crAnTimeOrderList, show \u03c6s' ++ \u03c8 :: \u03c6 :: \u03c6s = \u03c6s' ++ [\u03c8, \u03c6] ++ \u03c6s by simp, h2]\n      repeat rw [ofCrAnListF_append]\n      rw [smul_smul, mul_comm, \u2190 smul_smul, \u2190 smul_sub]\n      rw [map_mul, map_mul, map_mul, map_mul, map_mul, map_mul, map_mul, map_mul]\n      rw [\u2190 mul_smul_comm]\n      rw [mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc]\n      rw [\u2190 mul_sub, \u2190 mul_sub, mul_smul_comm, mul_smul_comm, \u2190 smul_mul_assoc,\n        \u2190 smul_mul_assoc]\n      rw [\u2190 sub_mul]\n      have h1 : (\u03b9 (ofCrAnListF [\u03c6, \u03c8]) -\n          (exchangeSign (\ud835\udcd5.crAnStatistics \u03c6)) (\ud835\udcd5.crAnStatistics \u03c8) \u2022 \u03b9 (ofCrAnListF [\u03c8, \u03c6])) =\n        \u03b9 [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca := by\n        rw [superCommuteF_ofCrAnOpF_ofCrAnOpF]\n        rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_append]\n        simp only [instCommGroup.eq_1, List.singleton_append, Algebra.smul_mul_assoc, map_sub,\n          map_smul]\n        rw [\u2190 ofCrAnListF_append]\n        simp\n      rw [h1]\n      have hc : \u03b9 ((superCommuteF (ofCrAnOpF \u03c6)) (ofCrAnOpF \u03c8)) \u2208\n          Subalgebra.center \u2102 \ud835\udcd5.FieldOpAlgebra := by\n        apply \u03b9_superCommuteF_ofCrAnOpF_ofCrAnOpF_mem_center\n      rw [Subalgebra.mem_center_iff] at hc\n      repeat rw [\u2190 mul_assoc]\n      rw [hc]\n      repeat rw [mul_assoc]\n      rw [smul_mul_assoc]\n      rw [\u2190 map_mul, \u2190 map_mul, \u2190 map_mul, \u2190 map_mul]\n      rw [\u2190 ofCrAnListF_append, \u2190 ofCrAnListF_append, \u2190 ofCrAnListF_append, \u2190 ofCrAnListF_append]\n      have h1 := insertionSort_of_takeWhile_filter \ud835\udcd5.crAnTimeOrderRel \u03c6 \u03c6s' \u03c6s\n      simp only [decide_not, Bool.decide_and, List.append_assoc, List.cons_append,\n        List.singleton_append, Algebra.mul_smul_comm, map_mul] at h1 \u22a2\n      rw [\u2190 h1]\n      rw [\u2190 crAnTimeOrderList]\n      by_cases hq : (\ud835\udcd5 |>\u209b \u03c6) \u2260 (\ud835\udcd5 |>\u209b \u03c8)\n      \u00b7 rw [\u03b9_superCommuteF_of_diff_statistic hq]\n        simp\n      \u00b7 rw [crAnTimeOrderSign, Wick.koszulSign_eq_rel_eq_stat _ _, \u2190 crAnTimeOrderSign]\n        rw [timeOrderF_ofCrAnListF]\n        simp only [map_smul, Algebra.mul_smul_comm]\n        simp only [List.nil_append]\n        exact h\u03c8\u03c6\n        exact h\u03c6\u03c8\n        simpa using hq\n    \u00b7 simp only [map_mul, zero_mul, map_zero, mul_zero, pa]\n    \u00b7 intro x y hx hy hpx hpy\n      simp_all [pa,mul_add, add_mul]\n    \u00b7 intro x hx hpx\n      simp_all [pa, hpx]\n  \u00b7 simp only [map_mul, mul_zero, map_zero, pb]\n  \u00b7 intro x y hx hy hpx hpy\n    simp_all [pb,mul_add, add_mul]\n  \u00b7 intro x hx hpx\n    simp_all [pb, hpx]\n\nlemma \u03b9_timeOrderF_superCommuteF_neq_time {\u03c6 \u03c8 : \ud835\udcd5.CrAnFieldOp}\n    (h\u03c6\u03c8 : \u00ac (crAnTimeOrderRel \u03c6 \u03c8 \u2227 crAnTimeOrderRel \u03c8 \u03c6)) (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \u03b9 \ud835\udce3\u1da0(a * [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca * b) = 0 := by\n  rw [timeOrderF_timeOrderF_mid]\n  have h\u03c6\u03c8 : \u00ac (crAnTimeOrderRel \u03c6 \u03c8) \u2228 \u00ac (crAnTimeOrderRel \u03c8 \u03c6) := by\n    exact Decidable.not_and_iff_or_not.mp h\u03c6\u03c8\n  rcases h\u03c6\u03c8 with h\u03c6\u03c8 | h\u03c6\u03c8\n  \u00b7 rw [timeOrderF_superCommuteF_ofCrAnOpF_ofCrAnOpF_not_crAnTimeOrderRel]\n    simp_all only [false_and, not_false_eq_true, false_or, mul_zero, zero_mul, map_zero]\n    simp_all\n  \u00b7 rw [superCommuteF_ofCrAnOpF_ofCrAnOpF_symm]\n    simp only [instCommGroup.eq_1, neg_smul, map_neg, map_smul, mul_neg, Algebra.mul_smul_comm,\n      neg_mul, Algebra.smul_mul_assoc, neg_eq_zero, smul_eq_zero]\n    rw [timeOrderF_superCommuteF_ofCrAnOpF_ofCrAnOpF_not_crAnTimeOrderRel]\n    simp only [mul_zero, zero_mul, map_zero, or_true]\n    simp_all\n\n/-!\n\n## Defining time order for `FiedOpAlgebra`.\n\n-/\n\nlemma \u03b9_timeOrderF_zero_of_mem_ideal (a : \ud835\udcd5.FieldOpFreeAlgebra)\n    (h : a \u2208 TwoSidedIdeal.span \ud835\udcd5.fieldOpIdealSet) : \u03b9 \ud835\udce3\u1da0(a) = 0 := by\n  rw [TwoSidedIdeal.mem_span_iff_mem_addSubgroup_closure] at h\n  let p {k : Set \ud835\udcd5.FieldOpFreeAlgebra} (a : FieldOpFreeAlgebra \ud835\udcd5)\n    (h : a \u2208 AddSubgroup.closure k) := \u03b9 \ud835\udce3\u1da0(a) = 0\n  change p a h\n  apply AddSubgroup.closure_induction\n  \u00b7 intro x hx\n    obtain \u27e8a, ha, b, hb, rfl\u27e9 := Set.mem_mul.mp hx\n    obtain \u27e8a, ha, c, hc, rfl\u27e9 := ha\n    simp only [p]\n    simp only [fieldOpIdealSet, exists_prop, exists_and_left, Set.mem_setOf_eq] at hc\n    match hc with\n    | Or.inl hc =>\n      obtain \u27e8\u03c6a, \u03c6a', h\u03c6a, h\u03c6a', rfl\u27e9 := hc\n      simp only [\u03b9_timeOrderF_superCommuteF_superCommuteF]\n    | Or.inr (Or.inl hc) =>\n      obtain \u27e8\u03c6a, h\u03c6a, \u03c6b, h\u03c6b, rfl\u27e9 := hc\n      by_cases heqt : (crAnTimeOrderRel \u03c6a \u03c6b \u2227 crAnTimeOrderRel \u03c6b \u03c6a)\n      \u00b7 rw [\u03b9_timeOrderF_superCommuteF_eq_time]\n        simp only [map_mul]\n        rw [\u03b9_superCommuteF_of_create_create]\n        simp only [zero_mul]\n        \u00b7 exact h\u03c6a\n        \u00b7 exact h\u03c6b\n        \u00b7 exact heqt.1\n        \u00b7 exact heqt.2\n      \u00b7 rw [\u03b9_timeOrderF_superCommuteF_neq_time heqt]\n    | Or.inr (Or.inr (Or.inl hc)) =>\n      obtain \u27e8\u03c6a, h\u03c6a, \u03c6b, h\u03c6b, rfl\u27e9 := hc\n      by_cases heqt : (crAnTimeOrderRel \u03c6a \u03c6b \u2227 crAnTimeOrderRel \u03c6b \u03c6a)\n      \u00b7 rw [\u03b9_timeOrderF_superCommuteF_eq_time]\n        simp only [map_mul]\n        rw [\u03b9_superCommuteF_of_annihilate_annihilate]\n        simp only [zero_mul]\n        \u00b7 exact h\u03c6a\n        \u00b7 exact h\u03c6b\n        \u00b7 exact heqt.1\n        \u00b7 exact heqt.2\n      \u00b7 rw [\u03b9_timeOrderF_superCommuteF_neq_time heqt]\n    | Or.inr (Or.inr (Or.inr hc)) =>\n      obtain \u27e8\u03c6a, \u03c6b, hdiff, rfl\u27e9 := hc\n      by_cases heqt : (crAnTimeOrderRel \u03c6a \u03c6b \u2227 crAnTimeOrderRel \u03c6b \u03c6a)\n      \u00b7 rw [\u03b9_timeOrderF_superCommuteF_eq_time]\n        simp only [map_mul]\n        rw [\u03b9_superCommuteF_of_diff_statistic]\n        simp only [zero_mul]\n        \u00b7 exact hdiff\n        \u00b7 exact heqt.1\n        \u00b7 exact heqt.2\n      \u00b7 rw [\u03b9_timeOrderF_superCommuteF_neq_time heqt]\n  \u00b7 simp [p]\n  \u00b7 intro x y hx hy\n    simp only [map_add, p]\n    intro h1 h2\n    simp [h1, h2]\n  \u00b7 intro x hx\n    simp [p]\n\nlemma \u03b9_timeOrderF_eq_of_equiv (a b : \ud835\udcd5.FieldOpFreeAlgebra) (h : a \u2248 b) :\n    \u03b9 \ud835\udce3\u1da0(a) = \u03b9 \ud835\udce3\u1da0(b) := by\n  rw [equiv_iff_sub_mem_ideal] at h\n  rw [LinearMap.sub_mem_ker_iff.mp]\n  simp only [LinearMap.mem_ker, \u2190 map_sub]\n  exact \u03b9_timeOrderF_zero_of_mem_ideal (a - b) h\n\n/-- For a field specification `\ud835\udcd5`, `timeOrder` is the linear map\n\n`FieldOpAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpAlgebra \ud835\udcd5`\n\ndefined as the decent of `\u03b9 \u2218\u2097 timeOrderF : FieldOpFreeAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpAlgebra \ud835\udcd5` from\n`FieldOpFreeAlgebra \ud835\udcd5` to `FieldOpAlgebra \ud835\udcd5`.\nThis decent exists because `\u03b9 \u2218\u2097 timeOrderF` is well-defined on equivalence classes.\n\nThe notation `\ud835\udce3(a)` is used for `timeOrder a`. -/\nnoncomputable def timeOrder : FieldOpAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpAlgebra \ud835\udcd5 where\n  toFun := Quotient.lift (\u03b9.toLinearMap \u2218\u2097 timeOrderF) \u03b9_timeOrderF_eq_of_equiv\n  map_add' x y := by\n    obtain \u27e8x, hx\u27e9 := \u03b9_surjective x\n    obtain \u27e8y, hy\u27e9 := \u03b9_surjective y\n    subst hx hy\n    rw [\u2190 map_add, \u03b9_apply, \u03b9_apply, \u03b9_apply]\n    rw [Quotient.lift_mk, Quotient.lift_mk, Quotient.lift_mk]\n    simp\n  map_smul' c y := by\n    obtain \u27e8y, hy\u27e9 := \u03b9_surjective y\n    subst hy\n    rw [\u2190 map_smul, \u03b9_apply, \u03b9_apply]\n    simp\n\n@[inherit_doc timeOrder]\nscoped[FieldSpecification.FieldOpAlgebra] notation \"\ud835\udce3(\" a \")\" => timeOrder a\n\n/-!\n\n## Properties of time ordering\n\n-/\n\nlemma timeOrder_eq_\u03b9_timeOrderF (a : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \ud835\udce3(\u03b9 a) = \u03b9 \ud835\udce3\u1da0(a) := rfl\n\nlemma timeOrder_ofFieldOp_ofFieldOp_ordered {\u03c6 \u03c8 : \ud835\udcd5.FieldOp} (h : timeOrderRel \u03c6 \u03c8) :\n    \ud835\udce3(ofFieldOp \u03c6 * ofFieldOp \u03c8) = ofFieldOp \u03c6 * ofFieldOp \u03c8 := by\n  rw [ofFieldOp, ofFieldOp, \u2190 map_mul, timeOrder_eq_\u03b9_timeOrderF,\n    timeOrderF_ofFieldOpF_ofFieldOpF_ordered h]\n\nlemma timeOrder_ofFieldOp_ofFieldOp_not_ordered {\u03c6 \u03c8 : \ud835\udcd5.FieldOp} (h : \u00ac timeOrderRel \u03c6 \u03c8) :\n    \ud835\udce3(ofFieldOp \u03c6 * ofFieldOp \u03c8) = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c8) \u2022 ofFieldOp \u03c8 * ofFieldOp \u03c6 := by\n  rw [ofFieldOp, ofFieldOp, \u2190 map_mul, timeOrder_eq_\u03b9_timeOrderF,\n    timeOrderF_ofFieldOpF_ofFieldOpF_not_ordered h]\n  simp\n\nlemma timeOrder_ofFieldOp_ofFieldOp_not_ordered_eq_timeOrder {\u03c6 \u03c8 : \ud835\udcd5.FieldOp}\n    (h : \u00ac timeOrderRel \u03c6 \u03c8) :\n    \ud835\udce3(ofFieldOp \u03c6 * ofFieldOp \u03c8) = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c8) \u2022 \ud835\udce3(ofFieldOp \u03c8 * ofFieldOp \u03c6) := by\n  rw [ofFieldOp, ofFieldOp, \u2190 map_mul, timeOrder_eq_\u03b9_timeOrderF,\n    timeOrderF_ofFieldOpF_ofFieldOpF_not_ordered_eq_timeOrderF h]\n  simp only [instCommGroup.eq_1, map_smul]\n  rfl\n\nlemma timeOrder_ofFieldOpList_nil : \ud835\udce3(ofFieldOpList (\ud835\udcd5 := \ud835\udcd5) []) = 1 := by\n  rw [ofFieldOpList, timeOrder_eq_\u03b9_timeOrderF, timeOrderF_ofFieldOpListF_nil]\n  simp\n\n", "theoremStatement": "@[simp]\nlemma timeOrder_ofFieldOpList_singleton (\u03c6 : \ud835\udcd5.FieldOp) :\n    \ud835\udce3(ofFieldOpList [\u03c6]) = ofFieldOpList [\u03c6] ", "theoremName": "FieldSpecification.FieldOpAlgebra.timeOrder_ofFieldOpList_singleton", "fileCreated": {"commit": "ea6e12829370d9630a7e65200c8349e9086c05ba", "date": "2025-02-03"}, "theoremCreated": {"commit": "fc2009928299f5a839dd880670f22245b6a09f72", "date": "2025-01-30"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpAlgebra/TimeOrder.lean", "module": "HepLean.PerturbationTheory.FieldOpAlgebra.TimeOrder", "jsonFile": "HepLean.PerturbationTheory.FieldOpAlgebra.TimeOrder.jsonl", "positionMetadata": {"lineInFile": 429, "tokenPositionInFile": 18655, "theoremPositionInFile": 13}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 13, "numPremises": 51}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [ofFieldOpList, timeOrder_eq_\u03b9_timeOrderF, timeOrderF_ofFieldOpListF_singleton]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 90}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpAlgebra.Basic\n/-!\n\n# Grading on the field operation algebra\n\n-/\n\nnamespace FieldSpecification\nopen FieldOpFreeAlgebra\nopen HepLean.List\nopen FieldStatistic\n\nnamespace FieldOpAlgebra\nvariable {\ud835\udcd5 : FieldSpecification}\n\n/-- The submodule of `\ud835\udcd5.FieldOpAlgebra` spanned by lists of field statistic `f`. -/\ndef statSubmodule (f : FieldStatistic) : Submodule \u2102 \ud835\udcd5.FieldOpAlgebra :=\n  Submodule.span \u2102 {a | \u2203 \u03c6s, a = ofCrAnList \u03c6s \u2227 (\ud835\udcd5 |>\u209b \u03c6s) = f}\n\nlemma ofCrAnList_mem_statSubmodule_of_eq (\u03c6s : List \ud835\udcd5.CrAnFieldOp) (f : FieldStatistic)\n    (h : (\ud835\udcd5 |>\u209b \u03c6s) = f) : ofCrAnList \u03c6s \u2208 statSubmodule f :=\n  Submodule.mem_span.mpr fun _ a => a \u27e8\u03c6s, \u27e8rfl, h\u27e9\u27e9\n\nlemma ofCrAnList_mem_statSubmodule (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnList \u03c6s \u2208 statSubmodule (\ud835\udcd5 |>\u209b \u03c6s) :=\n  Submodule.mem_span.mpr fun _ a => a \u27e8\u03c6s, \u27e8rfl, rfl\u27e9\u27e9\n\nlemma mem_bosonic_of_mem_free_bosonic (a : \ud835\udcd5.FieldOpFreeAlgebra)\n    (h : a \u2208 statisticSubmodule bosonic) : \u03b9 a \u2208 statSubmodule .bosonic := by\n  let p (a : \ud835\udcd5.FieldOpFreeAlgebra) (hx : a \u2208 statisticSubmodule bosonic) : Prop :=\n    \u03b9 a \u2208 statSubmodule .bosonic\n  change p a h\n  apply Submodule.span_induction\n  \u00b7 intro x hx\n    simp only [Set.mem_setOf_eq] at hx\n    obtain \u27e8\u03c6s, rfl, h\u27e9 := hx\n    simp [p]\n    apply ofCrAnList_mem_statSubmodule_of_eq\n    exact h\n  \u00b7 simp only [map_zero, p]\n    exact Submodule.zero_mem (statSubmodule bosonic)\n  \u00b7 intro x y hx hy hpx hpy\n    simp_all only [p, map_add]\n    exact Submodule.add_mem _ hpx hpy\n  \u00b7 intro a x hx hy\n    simp_all only [p, map_smul]\n    exact Submodule.smul_mem _ _ hy\n\nlemma mem_fermionic_of_mem_free_fermionic (a : \ud835\udcd5.FieldOpFreeAlgebra)\n    (h : a \u2208 statisticSubmodule fermionic) : \u03b9 a \u2208 statSubmodule .fermionic := by\n  let p (a : \ud835\udcd5.FieldOpFreeAlgebra) (hx : a \u2208 statisticSubmodule fermionic) : Prop :=\n    \u03b9 a \u2208 statSubmodule .fermionic\n  change p a h\n  apply Submodule.span_induction\n  \u00b7 intro x hx\n    simp only [Set.mem_setOf_eq] at hx\n    obtain \u27e8\u03c6s, rfl, h\u27e9 := hx\n    simp [p]\n    apply ofCrAnList_mem_statSubmodule_of_eq\n    exact h\n  \u00b7 simp only [map_zero, p]\n    exact Submodule.zero_mem (statSubmodule fermionic)\n  \u00b7 intro x y hx hy hpx hpy\n    simp_all only [p, map_add]\n    exact Submodule.add_mem _ hpx hpy\n  \u00b7 intro a x hx hy\n    simp_all only [p, map_smul]\n    exact Submodule.smul_mem _ _ hy\n\nlemma mem_statSubmodule_of_mem_statisticSubmodule (f : FieldStatistic) (a : \ud835\udcd5.FieldOpFreeAlgebra)\n    (h : a \u2208 statisticSubmodule f) : \u03b9 a \u2208 statSubmodule f := by\n  fin_cases f\n  \u00b7 exact mem_bosonic_of_mem_free_bosonic a h\n  \u00b7 exact mem_fermionic_of_mem_free_fermionic a h\n\n/-- The projection of `statisticSubmodule (\ud835\udcd5 := \ud835\udcd5) f` defined in the free algebra to\n  `statSubmodule (\ud835\udcd5 := \ud835\udcd5) f`. -/\ndef \u03b9StateSubmodule (f : FieldStatistic) :\n    statisticSubmodule (\ud835\udcd5 := \ud835\udcd5) f \u2192\u2097[\u2102] statSubmodule (\ud835\udcd5 := \ud835\udcd5) f where\n  toFun a := \u27e8a.1, mem_statSubmodule_of_mem_statisticSubmodule f a.1 a.2\u27e9\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n\nnoncomputable section\n\n/-!\n\n## Defining bosonicProj\n\n-/\n\n/-- The projection of `\ud835\udcd5.FieldOpFreeAlgebra` to `statSubmodule (\ud835\udcd5 := \ud835\udcd5) bosonic`. -/\ndef bosonicProjFree : \ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102] statSubmodule (\ud835\udcd5 := \ud835\udcd5) bosonic :=\n  \u03b9StateSubmodule .bosonic \u2218\u2097 bosonicProjF\n\nlemma bosonicProjFree_eq_\u03b9_bosonicProjF (a : \ud835\udcd5.FieldOpFreeAlgebra) :\n    (bosonicProjFree a).1 = \u03b9 (bosonicProjF a) := rfl\n\nlemma bosonicProjFree_zero_of_\u03b9_zero (a : \ud835\udcd5.FieldOpFreeAlgebra) (h : \u03b9 a = 0) :\n    bosonicProjFree a = 0 := by\n  rw [\u03b9_eq_zero_iff_\u03b9_bosonicProjF_fermonicProj_zero] at h\n  apply Subtype.eq\n  rw [bosonicProjFree_eq_\u03b9_bosonicProjF]\n  exact h.1\n\nlemma bosonicProjFree_eq_of_equiv (a b : \ud835\udcd5.FieldOpFreeAlgebra) (h : a \u2248 b) :\n    bosonicProjFree a = bosonicProjFree b := by\n  rw [equiv_iff_sub_mem_ideal, \u2190 \u03b9_eq_zero_iff_mem_ideal] at h\n  rw [LinearMap.sub_mem_ker_iff.mp]\n  simp only [LinearMap.mem_ker, \u2190 map_sub]\n  exact bosonicProjFree_zero_of_\u03b9_zero (a - b) h\n\n/-- The projection of `\ud835\udcd5.FieldOpAlgebra` to `statSubmodule (\ud835\udcd5 := \ud835\udcd5) bosonic`. -/\ndef bosonicProj : \ud835\udcd5.FieldOpAlgebra \u2192\u2097[\u2102] statSubmodule (\ud835\udcd5 := \ud835\udcd5) bosonic where\n  toFun := Quotient.lift bosonicProjFree bosonicProjFree_eq_of_equiv\n  map_add' x y := by\n    obtain \u27e8x, hx\u27e9 := \u03b9_surjective x\n    obtain \u27e8y, hy\u27e9 := \u03b9_surjective y\n    subst hx hy\n    rw [\u2190 map_add, \u03b9_apply, \u03b9_apply, \u03b9_apply]\n    rw [Quotient.lift_mk, Quotient.lift_mk, Quotient.lift_mk]\n    simp\n  map_smul' c y := by\n    obtain \u27e8y, hy\u27e9 := \u03b9_surjective y\n    subst hy\n    rw [\u2190 map_smul, \u03b9_apply, \u03b9_apply]\n    simp\n\nlemma bosonicProj_eq_bosonicProjFree (a : \ud835\udcd5.FieldOpFreeAlgebra) :\n    bosonicProj (\u03b9 a) = bosonicProjFree a := rfl\n\n/-!\n\n## Defining fermionicProj\n\n-/\n\n/-- The projection of `\ud835\udcd5.FieldOpFreeAlgebra` to `statSubmodule (\ud835\udcd5 := \ud835\udcd5) fermionic`. -/\ndef fermionicProjFree : \ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102] statSubmodule (\ud835\udcd5 := \ud835\udcd5) fermionic :=\n  \u03b9StateSubmodule .fermionic \u2218\u2097 fermionicProjF\n\nlemma fermionicProjFree_eq_\u03b9_fermionicProjF (a : \ud835\udcd5.FieldOpFreeAlgebra) :\n    (fermionicProjFree a).1 = \u03b9 (fermionicProjF a) := rfl\n\nlemma fermionicProjFree_zero_of_\u03b9_zero (a : \ud835\udcd5.FieldOpFreeAlgebra) (h : \u03b9 a = 0) :\n    fermionicProjFree a = 0 := by\n  rw [\u03b9_eq_zero_iff_\u03b9_bosonicProjF_fermonicProj_zero] at h\n  apply Subtype.eq\n  rw [fermionicProjFree_eq_\u03b9_fermionicProjF]\n  exact h.2\n\nlemma fermionicProjFree_eq_of_equiv (a b : \ud835\udcd5.FieldOpFreeAlgebra) (h : a \u2248 b) :\n    fermionicProjFree a = fermionicProjFree b := by\n  rw [equiv_iff_sub_mem_ideal, \u2190 \u03b9_eq_zero_iff_mem_ideal] at h\n  rw [LinearMap.sub_mem_ker_iff.mp]\n  simp only [LinearMap.mem_ker, \u2190 map_sub]\n  exact fermionicProjFree_zero_of_\u03b9_zero (a - b) h\n\n/-- The projection of `\ud835\udcd5.FieldOpAlgebra` to `statSubmodule (\ud835\udcd5 := \ud835\udcd5) fermionic`. -/\ndef fermionicProj : \ud835\udcd5.FieldOpAlgebra \u2192\u2097[\u2102] statSubmodule (\ud835\udcd5 := \ud835\udcd5) fermionic where\n  toFun := Quotient.lift fermionicProjFree fermionicProjFree_eq_of_equiv\n  map_add' x y := by\n    obtain \u27e8x, hx\u27e9 := \u03b9_surjective x\n    obtain \u27e8y, hy\u27e9 := \u03b9_surjective y\n    subst hx hy\n    rw [\u2190 map_add, \u03b9_apply, \u03b9_apply, \u03b9_apply]\n    rw [Quotient.lift_mk, Quotient.lift_mk, Quotient.lift_mk]\n    simp\n  map_smul' c y := by\n    obtain \u27e8y, hy\u27e9 := \u03b9_surjective y\n    subst hy\n    rw [\u2190 map_smul, \u03b9_apply, \u03b9_apply]\n    simp\n\nlemma fermionicProj_eq_fermionicProjFree (a : \ud835\udcd5.FieldOpFreeAlgebra) :\n    fermionicProj (\u03b9 a) = fermionicProjFree a := rfl\n\n/-!\n\n## Interactino between bosonicProj and fermionicProj\n\n-/\n\nlemma bosonicProj_add_fermionicProj (a : \ud835\udcd5.FieldOpAlgebra) :\n    bosonicProj a + (fermionicProj a).1 = a := by\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  rw [fermionicProj_eq_fermionicProjFree, bosonicProj_eq_bosonicProjFree]\n  rw [bosonicProjFree_eq_\u03b9_bosonicProjF, fermionicProjFree_eq_\u03b9_fermionicProjF]\n  rw [\u2190 map_add, bosonicProjF_add_fermionicProjF]\n\nlemma bosonicProj_mem_bosonic (a : \ud835\udcd5.FieldOpAlgebra) (ha : a \u2208 statSubmodule .bosonic) :\n    bosonicProj a = \u27e8a, ha\u27e9 := by\n  let p (a : \ud835\udcd5.FieldOpAlgebra) (hx : a \u2208 statSubmodule bosonic) : Prop :=\n    (bosonicProj a) = \u27e8a, hx\u27e9\n  change p a ha\n  apply Submodule.span_induction\n  \u00b7 intro x hx\n    obtain \u27e8\u03c6s, rfl, h\u27e9 := hx\n    simp only [p]\n    apply Subtype.eq\n    simp only\n    rw [ofCrAnList]\n    rw [bosonicProj_eq_bosonicProjFree]\n    rw [bosonicProjFree_eq_\u03b9_bosonicProjF]\n    rw [bosonicProjF_of_mem_bosonic]\n    exact ofCrAnListF_mem_statisticSubmodule_of _ _ h\n  \u00b7 simp only [map_zero, p]\n    rfl\n  \u00b7 intro x y hx hy hpx hpy\n    simp_all [p]\n  \u00b7 intro a x hx hy\n    simp_all [p]\n\nlemma fermionicProj_mem_fermionic (a : \ud835\udcd5.FieldOpAlgebra) (ha : a \u2208 statSubmodule .fermionic) :\n    fermionicProj a = \u27e8a, ha\u27e9 := by\n  let p (a : \ud835\udcd5.FieldOpAlgebra) (hx : a \u2208 statSubmodule fermionic) : Prop :=\n    (fermionicProj a) = \u27e8a, hx\u27e9\n  change p a ha\n  apply Submodule.span_induction\n  \u00b7 intro x hx\n    obtain \u27e8\u03c6s, rfl, h\u27e9 := hx\n    simp only [p]\n    apply Subtype.eq\n    simp only\n    rw [ofCrAnList]\n    rw [fermionicProj_eq_fermionicProjFree]\n    rw [fermionicProjFree_eq_\u03b9_fermionicProjF]\n    rw [fermionicProjF_of_mem_fermionic]\n    exact ofCrAnListF_mem_statisticSubmodule_of _ _ h\n  \u00b7 simp only [map_zero, p]\n    rfl\n  \u00b7 intro x y hx hy hpx hpy\n    simp_all [p]\n  \u00b7 intro a x hx hy\n    simp_all [p]\n\nlemma bosonicProj_mem_fermionic (a : \ud835\udcd5.FieldOpAlgebra) (ha : a \u2208 statSubmodule .fermionic) :\n    bosonicProj a = 0 := by\n  have h := bosonicProj_add_fermionicProj a\n  rw [fermionicProj_mem_fermionic a ha] at h\n  simpa using h\n\n", "theoremStatement": "lemma fermionicProj_mem_bosonic (a : \ud835\udcd5.FieldOpAlgebra) (ha : a \u2208 statSubmodule .bosonic) :\n    fermionicProj a = 0 ", "theoremName": "FieldSpecification.FieldOpAlgebra.fermionicProj_mem_bosonic", "fileCreated": {"commit": "7d9e6af80c57599f68481948604d9f0aaba4a40f", "date": "2025-02-05"}, "theoremCreated": {"commit": "7d9e6af80c57599f68481948604d9f0aaba4a40f", "date": "2025-02-05"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpAlgebra/Grading.lean", "module": "HepLean.PerturbationTheory.FieldOpAlgebra.Grading", "jsonFile": "HepLean.PerturbationTheory.FieldOpAlgebra.Grading.jsonl", "positionMetadata": {"lineInFile": 248, "tokenPositionInFile": 8474, "theoremPositionInFile": 20}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 5, "repositoryPremises": true, "numRepositoryPremises": 12, "numPremises": 89}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  have h := bosonicProj_add_fermionicProj a\n  rw [bosonicProj_mem_bosonic a ha] at h\n  simpa using h", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 106}}
{"srcContext": "/-\nCopyright (c) 2024 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport Mathlib.LinearAlgebra.PiTensorProduct\nimport Mathlib.Tactic.Polyrith\nimport Mathlib.Tactic.Linarith\nimport Mathlib.Data.Nat.Factorial.DoubleFactorial\n/-!\n# Fin involutions\n\nSome properties of involutions of `Fin n`.\n\nThese involutions are used in e.g. proving results about Wick contractions.\n\n-/\nnamespace HepLean.Fin\n\nopen Nat\n\n/-- There is an equivalence between involutions of `Fin n.succ` and involutions of\n  `Fin n` and an optional valid choice of an element in `Fin n` (which is where `0`\n    in `Fin n.succ` will be sent). -/\ndef involutionCons (n : \u2115) : {f : Fin n.succ \u2192 Fin n.succ // Function.Involutive f } \u2243\n    (f : {f : Fin n \u2192 Fin n // Function.Involutive f}) \u00d7 {i : Option (Fin n) //\n      \u2200 (h : i.isSome), f.1 (Option.get i h) = (Option.get i h)} where\n  toFun f := \u27e8\u27e8\n    fun i =>\n    if h : f.1 i.succ = 0 then i\n    else Fin.pred (f.1 i.succ) h, by\n    intro i\n    by_cases h : f.1 i.succ = 0\n    \u00b7 simp [h]\n    \u00b7 simp only [succ_eq_add_one, h, \u2193reduceDIte, Fin.succ_pred]\n      simp only [f.2 i.succ, Fin.pred_succ, dite_eq_ite, ite_eq_right_iff]\n      intro h\n      exact False.elim (Fin.succ_ne_zero i h)\u27e9,\n    \u27e8if h : f.1 0 = 0 then none else Fin.pred (f.1 0) h, by\n    by_cases h0 : f.1 0 = 0\n    \u00b7 simp [h0]\n    \u00b7 simp only [succ_eq_add_one, h0, \u2193reduceDIte, Option.isSome_some, Option.get_some,\n      Fin.succ_pred, dite_eq_left_iff, Fin.pred_inj, forall_const]\n      refine fun h => False.elim (h (f.2 0))\u27e9\u27e9\n  invFun f := \u27e8\n      if h : (f.2.1).isSome then\n        Fin.cons (f.2.1.get h).succ (Function.update (Fin.succ \u2218 f.1.1) (f.2.1.get h) 0)\n      else\n        Fin.cons 0 (Fin.succ \u2218 f.1.1), by\n    by_cases hs : (f.2.1).isSome\n    \u00b7 simp only [Nat.succ_eq_add_one, hs, \u2193reduceDIte, Fin.coe_eq_castSucc]\n      let a := f.2.1.get hs\n      change Function.Involutive (Fin.cons a.succ (Function.update (Fin.succ \u2218 \u2191f.fst) a 0))\n      intro i\n      rcases Fin.eq_zero_or_eq_succ i with hi | \u27e8j, hj\u27e9\n      \u00b7 subst hi\n        rw [Fin.cons_zero, Fin.cons_succ]\n        simp\n      \u00b7 subst hj\n        rw [Fin.cons_succ]\n        by_cases hja : j = a\n        \u00b7 subst hja\n          simp\n        \u00b7 rw [Function.update_apply]\n          rw [if_neg hja]\n          simp only [Function.comp_apply, Fin.cons_succ]\n          have hf2 := f.2.2 hs\n          change f.1.1 a = a at hf2\n          have hjf1 : f.1.1 j \u2260 a := by\n            by_contra hn\n            have haj : j = f.1.1 a := by\n              rw [\u2190 hn]\n              rw [f.1.2]\n            rw [hf2] at haj\n            exact hja haj\n          rw [Function.update_apply, if_neg hjf1]\n          simp only [Function.comp_apply, Fin.succ_inj]\n          rw [f.1.2]\n    \u00b7 simp only [succ_eq_add_one, hs, Bool.false_eq_true, \u2193reduceDIte]\n      intro i\n      rcases Fin.eq_zero_or_eq_succ i with hi | \u27e8j, hj\u27e9\n      \u00b7 subst hi\n        simp\n      \u00b7 subst hj\n        simp only [Fin.cons_succ, Function.comp_apply, Fin.succ_inj]\n        rw [f.1.2]\u27e9\n  left_inv f := by\n    match f with\n    | \u27e8f, hf\u27e9 =>\n    simp only [succ_eq_add_one, Option.isSome_dite', Option.get_dite', Fin.succ_pred,\n      Fin.cons_update, dite_eq_ite, ite_not, Subtype.mk.injEq]\n    ext i\n    by_cases h0 : f 0 = 0\n    \u00b7 simp only [h0, \u2193reduceIte]\n      rcases Fin.eq_zero_or_eq_succ i with hi | \u27e8j, hj\u27e9\n      \u00b7 subst hi\n        simp [h0]\n      \u00b7 subst hj\n        simp only [Fin.cons_succ, Function.comp_apply, Fin.val_succ]\n        by_cases hj : f j.succ =0\n        \u00b7 rw [\u2190 h0] at hj\n          have hn := Function.Involutive.injective hf hj\n          exact False.elim (Fin.succ_ne_zero j hn)\n        \u00b7 simp only [hj, \u2193reduceDIte, Fin.coe_pred]\n          rw [Fin.ext_iff] at hj\n          simp only [succ_eq_add_one, Fin.val_zero] at hj\n          omega\n    \u00b7 rw [if_neg h0]\n      by_cases hf' : i = f 0\n      \u00b7 subst hf'\n        simp only [Function.update_self, Fin.val_zero]\n        rw [hf]\n        simp\n      \u00b7 rw [Function.update_apply, if_neg hf']\n        rcases Fin.eq_zero_or_eq_succ i with hi | \u27e8j, hj\u27e9\n        \u00b7 subst hi\n          simp\n        \u00b7 subst hj\n          simp only [Fin.cons_succ, Function.comp_apply, Fin.val_succ]\n          by_cases hj : f j.succ =0\n          \u00b7 rw [\u2190 hj] at hf'\n            rw [hf] at hf'\n            simp only [not_true_eq_false] at hf'\n          \u00b7 simp only [hj, \u2193reduceDIte, Fin.coe_pred]\n            rw [Fin.ext_iff] at hj\n            simp only [succ_eq_add_one, Fin.val_zero] at hj\n            omega\n  right_inv f := by\n    match f with\n    | \u27e8\u27e8f, hf\u27e9, \u27e8f0, hf0\u27e9\u27e9 =>\n    ext i\n    \u00b7 simp only [succ_eq_add_one, Fin.cons_update]\n      by_cases hs : f0.isSome\n      \u00b7 simp only [hs, \u2193reduceDIte]\n        by_cases hi : i = f0.get hs\n        \u00b7 simp only [Function.update_apply, hi, \u2193reduceIte, \u2193reduceDIte]\n          exact Eq.symm (Fin.val_eq_of_eq (hf0 hs))\n        \u00b7 simp only [ne_eq, Fin.succ_inj, hi, not_false_eq_true, Function.update_of_ne,\n          Fin.cons_succ, Function.comp_apply, Fin.pred_succ, dite_eq_ite]\n          split\n          \u00b7 rename_i h\n            exact False.elim (Fin.succ_ne_zero (f i) h)\n          \u00b7 rfl\n      \u00b7 simp only [hs, Bool.false_eq_true, \u2193reduceDIte, Fin.cons_succ, Function.comp_apply,\n        Fin.pred_succ, dite_eq_ite]\n        split\n        \u00b7 rename_i h\n          exact False.elim (Fin.succ_ne_zero (f i) h)\n        \u00b7 rfl\n    \u00b7 simp only [Nat.succ_eq_add_one, Option.mem_def,\n      Option.dite_none_left_eq_some, Option.some.injEq]\n      by_cases hs : f0.isSome\n      \u00b7 simp only [hs, \u2193reduceDIte]\n        simp only [Fin.cons_zero, Fin.pred_succ, exists_prop]\n        have hx : \u00ac (f0.get hs).succ = 0 := (Fin.succ_ne_zero (f0.get hs))\n        simp only [hx, not_false_eq_true, true_and]\n        refine Iff.intro (fun hi => ?_) (fun hi => ?_)\n        \u00b7 rw [\u2190 hi]\n          exact\n            Option.eq_some_of_isSome\n              (Eq.mpr_prop (Eq.refl (f0.isSome = true))\n                (of_eq_true (Eq.trans (congrArg (fun x => x = true) hs) (eq_self true))))\n        \u00b7 subst hi\n          exact rfl\n      \u00b7 simp only [hs, Bool.false_eq_true, \u2193reduceDIte, Fin.cons_zero, not_true_eq_false,\n        IsEmpty.exists_iff, false_iff]\n        simp only [Bool.not_eq_true, Option.not_isSome, Option.isNone_iff_eq_none] at hs\n        subst hs\n        exact ne_of_beq_false rfl\n\nlemma involutionCons_ext {n : \u2115} {f1 f2 : (f : {f : Fin n \u2192 Fin n // Function.Involutive f}) \u00d7\n    {i : Option (Fin n) // \u2200 (h : i.isSome), f.1 (Option.get i h) = (Option.get i h)}}\n    (h1 : f1.1 = f2.1) (h2 : f1.2 = Equiv.subtypeEquivRight (by rw [h1]; simp) f2.2) : f1 = f2 := by\n  cases f1\n  cases f2\n  simp only at h1 h2\n  subst h1\n  rename_i fst snd snd_1\n  simp_all only [Sigma.mk.inj_iff, heq_eq_eq, true_and]\n  obtain \u27e8val, property\u27e9 := fst\n  obtain \u27e8val_1, property_1\u27e9 := snd\n  obtain \u27e8val_2, property_2\u27e9 := snd_1\n  simp_all only\n  rfl\n\n/-- Given an involution of `Fin n`, the optional choice of an element in `Fin n` which\n  maps to itself is equivalent to the optional choice of an element in\n  `Fin (Finset.univ.filter fun i => f.1 i = i).card`. -/\ndef involutionAddEquiv {n : \u2115} (f : {f : Fin n \u2192 Fin n // Function.Involutive f}) :\n    {i : Option (Fin n) // \u2200 (h : i.isSome), f.1 (Option.get i h) = (Option.get i h)} \u2243\n    Option (Fin (Finset.univ.filter fun i => f.1 i = i).card) := by\n  let e1 : {i : Option (Fin n) // \u2200 (h : i.isSome), f.1 (Option.get i h) = (Option.get i h)}\n        \u2243 Option {i : Fin n // f.1 i = i} :=\n    { toFun := fun i => match i with\n        | \u27e8some i, h\u27e9 => some \u27e8i, by simpa using h\u27e9\n        | \u27e8none, h\u27e9 => none\n      invFun := fun i => match i with\n        | some \u27e8i, h\u27e9 => \u27e8some i, by simpa using h\u27e9\n        | none => \u27e8none, by simp\u27e9\n      left_inv := by\n        intro a\n        cases a\n        aesop\n      right_inv := by\n        intro a\n        cases a\n        rfl\n        simp_all only [Subtype.coe_eta] }\n  let s : Finset (Fin n) := Finset.univ.filter fun i => f.1 i = i\n  let e2' : { i : Fin n // f.1 i = i} \u2243 {i // i \u2208 s} := by\n    apply Equiv.subtypeEquivProp\n    simp [s]\n  let e2 : {i // i \u2208 s} \u2243 Fin (Finset.card s) := by\n    refine (Finset.orderIsoOfFin _ ?_).symm.toEquiv\n    simp [s]\n  refine e1.trans (Equiv.optionCongr (e2'.trans (e2)))\n\nlemma involutionAddEquiv_none_image_zero {n : \u2115} :\n    {f : {f : Fin n.succ \u2192 Fin n.succ // Function.Involutive f}}\n    \u2192 involutionAddEquiv (involutionCons n f).1 (involutionCons n f).2 = none\n    \u2192 f.1 \u27e80, Nat.zero_lt_succ n\u27e9 = \u27e80, Nat.zero_lt_succ n\u27e9 := by\n  intro f h\n  simp only [Nat.succ_eq_add_one, involutionCons, Equiv.coe_fn_mk, involutionAddEquiv,\n    Option.isSome_some, Option.get_some, Option.isSome_none, Equiv.trans_apply,\n    Equiv.optionCongr_apply, Equiv.coe_trans, RelIso.coe_fn_toEquiv, Option.map_eq_none'] at h\n  simp_all only [List.length_cons, Fin.zero_eta]\n  obtain \u27e8val, property\u27e9 := f\n  simp_all only [List.length_cons]\n  split at h\n  next i i_1 h_1 heq =>\n    split at heq\n    next h_2 => simp_all only [reduceCtorEq]\n    next h_2 => simp_all only [reduceCtorEq]\n  next i h_1 heq =>\n    split at heq\n    next h_2 => simp_all only\n    next h_2 => simp_all only [Subtype.mk.injEq, reduceCtorEq]\n\nlemma involutionAddEquiv_cast {n : \u2115} {f1 f2 : {f : Fin n \u2192 Fin n // Function.Involutive f}}\n    (hf : f1 = f2) :\n    involutionAddEquiv f1 = (Equiv.subtypeEquivRight (by rw [hf]; simp)).trans\n      ((involutionAddEquiv f2).trans (Equiv.optionCongr (finCongr (by rw [hf])))) := by\n  subst hf\n  rw [finCongr_refl, Equiv.optionCongr_refl]\n  rfl\n\nlemma involutionAddEquiv_cast' {m : \u2115} {f1 f2 : {f : Fin m \u2192 Fin m // Function.Involutive f}}\n    {N : \u2115} (hf : f1 = f2) (n : Option (Fin N))\n    (hn1 : N = (Finset.filter (fun i => f1.1 i = i) Finset.univ).card)\n    (hn2 : N = (Finset.filter (fun i => f2.1 i = i) Finset.univ).card) :\n    HEq ((involutionAddEquiv f1).symm (Option.map (finCongr hn1) n))\n    ((involutionAddEquiv f2).symm (Option.map (finCongr hn2) n)) := by\n  subst hf\n  rfl\n\nlemma involutionAddEquiv_none_succ {n : \u2115}\n    {f : {f : Fin n.succ \u2192 Fin n.succ // Function.Involutive f}}\n    (h : involutionAddEquiv (involutionCons n f).1 (involutionCons n f).2 = none)\n    (x : Fin n) : f.1 x.succ = x.succ \u2194 (involutionCons n f).1.1 x = x := by\n  simp only [succ_eq_add_one, involutionCons, Fin.cons_update, Equiv.coe_fn_mk, dite_eq_left_iff]\n  have hx : \u00ac f.1 x.succ = \u27e80, Nat.zero_lt_succ n\u27e9:=\n    involutionAddEquiv_none_image_zero h \u25b8\n      fun hn => Fin.succ_ne_zero x (Function.Involutive.injective f.2 hn)\n  exact Iff.intro (fun h2 \u21a6 by simp [h2]) (fun h2 \u21a6 (Fin.pred_eq_iff_eq_succ hx).mp (h2 hx))\n\nlemma involutionAddEquiv_isSome_image_zero {n : \u2115} :\n    {f : {f : Fin n.succ \u2192 Fin n.succ // Function.Involutive f}}\n    \u2192 (involutionAddEquiv (involutionCons n f).1 (involutionCons n f).2).isSome\n    \u2192 \u00ac f.1 \u27e80, Nat.zero_lt_succ n\u27e9 = \u27e80, Nat.zero_lt_succ n\u27e9 := by\n  intro f hf a\n  simp only [succ_eq_add_one, involutionCons, Equiv.coe_fn_mk, involutionAddEquiv] at hf\n  simp_all\n\n/-!\n\n## Equivalences of involutions with no fixed points.\n\nThe main aim of these equivalences is to define `involutionNoFixedZeroEquivProd`.\n\n-/\n\n/-- Fixed point free involutions of `Fin n.succ` can be separated based on where they sent\n  `0`. -/\ndef involutionNoFixedEquivSum {n : \u2115} :\n    {f : Fin n.succ \u2192 Fin n.succ // Function.Involutive f\n    \u2227 \u2200 i, f i \u2260 i} \u2243 \u03a3 (k : Fin n), {f : Fin n.succ \u2192 Fin n.succ // Function.Involutive f\n    \u2227 (\u2200 i, f i \u2260 i) \u2227 f 0 = k.succ} where\n  toFun f := \u27e8(f.1 0).pred (f.2.2 0), \u27e8f.1, f.2.1, by simpa using f.2.2\u27e9\u27e9\n  invFun f := \u27e8f.2.1, \u27e8f.2.2.1, f.2.2.2.1\u27e9\u27e9\n  left_inv f := rfl\n  right_inv f := by\n    ext\n    \u00b7 simp [f.2.2.2.2]\n    \u00b7 rfl\n\n/-- The condition on fixed point free involutions of `Fin n.succ` for a fixed value of `f 0`,\n  can be modified by conjugation with an equivalence. -/\ndef involutionNoFixedZeroSetEquivEquiv {n : \u2115}\n    (k : Fin n) (e : Fin n.succ \u2243 Fin n.succ) :\n    {f : Fin n.succ \u2192 Fin n.succ // Function.Involutive f \u2227 (\u2200 i, f i \u2260 i) \u2227 f 0 = k.succ} \u2243\n    {f : Fin n.succ \u2192 Fin n.succ // Function.Involutive (e.symm \u2218 f \u2218 e) \u2227\n      (\u2200 i, (e.symm \u2218 f \u2218 e) i \u2260 i) \u2227 (e.symm \u2218 f \u2218 e) 0 = k.succ} where\n  toFun f := \u27e8e \u2218 f.1 \u2218 e.symm, by\n    intro i\n    simp only [succ_eq_add_one, ne_eq, Function.comp_apply, Equiv.symm_apply_apply]\n    rw [f.2.1], by\n      simpa using f.2.2.1, by simpa using f.2.2.2\u27e9\n  invFun f := \u27e8e.symm \u2218 f.1 \u2218 e, by\n    intro i\n    simp only [succ_eq_add_one, Function.comp_apply, ne_eq, Equiv.apply_symm_apply]\n    have hf2 := f.2.1 i\n    simpa using hf2, by simpa using f.2.2.1, by simpa using f.2.2.2\u27e9\n  left_inv f := by\n    ext i\n    simp\n  right_inv f := by\n    ext i\n    simp\n\n/-- The condition on fixed point free involutions of `Fin n.succ` for a fixed value of `f 0`\n  given an equivalence `e`,\n  can be modified so that only the condition on `f 0` is up-to the equivalence `e`. -/\ndef involutionNoFixedZeroSetEquivSetEquiv {n : \u2115} (k : Fin n)\n    (e : Fin n.succ \u2243 Fin n.succ) :\n    {f : Fin n.succ \u2192 Fin n.succ // Function.Involutive (e.symm \u2218 f \u2218 e) \u2227\n    (\u2200 i, (e.symm \u2218 f \u2218 e) i \u2260 i) \u2227 (e.symm \u2218 f \u2218 e) 0 = k.succ} \u2243\n    {f : Fin n.succ \u2192 Fin n.succ // Function.Involutive f \u2227\n      (\u2200 i, f i \u2260 i) \u2227 (e.symm \u2218 f \u2218 e) 0 = k.succ} := by\n  refine Equiv.subtypeEquivRight ?_\n  intro f\n  have h1 : Function.Involutive (\u21d1e.symm \u2218 f \u2218 \u21d1e) \u2194 Function.Involutive f := by\n    apply Iff.intro\n    \u00b7 intro h i\n      have hi := h (e.symm i)\n      simpa using hi\n    \u00b7 intro h i\n      have hi := h (e i)\n      simp [hi]\n  rw [h1]\n  simp only [succ_eq_add_one, Function.comp_apply, ne_eq, and_congr_right_iff, and_congr_left_iff]\n  intro h1 h2\n  apply Iff.intro\n  \u00b7 intro h i\n    have hi := h (e.symm i)\n    simpa using hi\n  \u00b7 intro h i\n    have hi := h (e i)\n    by_contra hn\n    nth_rewrite 2 [\u2190 hn] at hi\n    simp at hi\n\n/-- Fixed point free involutions of `Fin n.succ` fixing `(e.symm \u2218 f \u2218 e) = k.succ` for a given `e`\n  are equivalent to fixing `f (e 0) = e k.succ`. -/\ndef involutionNoFixedZeroSetEquivEquiv' {n : \u2115} (k : Fin n) (e : Fin n.succ \u2243 Fin n.succ) :\n    {f : Fin n.succ \u2192 Fin n.succ // Function.Involutive f \u2227\n    (\u2200 i, f i \u2260 i) \u2227 (e.symm \u2218 f \u2218 e) 0 = k.succ} \u2243\n    {f : Fin n.succ \u2192 Fin n.succ // Function.Involutive f \u2227\n    (\u2200 i, f i \u2260 i) \u2227 f (e 0) = e k.succ} := by\n  refine Equiv.subtypeEquivRight ?_\n  simp only [succ_eq_add_one, ne_eq, Function.comp_apply, and_congr_right_iff]\n  intro f hi h1\n  exact Equiv.symm_apply_eq e\n\n/-- Fixed point involutions of `Fin n.succ.succ` with `f 0 = k.succ` are equivalent\n  to fixed point involutions with `f 0 = 1`. -/\ndef involutionNoFixedZeroSetEquivSetOne {n : \u2115} (k : Fin n.succ) :\n    {f : Fin n.succ.succ \u2192 Fin n.succ.succ // Function.Involutive f \u2227\n      (\u2200 i, f i \u2260 i) \u2227 f 0 = k.succ}\n      \u2243 {f : Fin n.succ.succ \u2192 Fin n.succ.succ // Function.Involutive f \u2227\n      (\u2200 i, f i \u2260 i) \u2227 f 0 = 1} := by\n  refine Equiv.trans (involutionNoFixedZeroSetEquivEquiv k (Equiv.swap k.succ 1)) ?_\n  refine Equiv.trans (involutionNoFixedZeroSetEquivSetEquiv k (Equiv.swap k.succ 1)) ?_\n  refine Equiv.trans (involutionNoFixedZeroSetEquivEquiv' k (Equiv.swap k.succ 1)) ?_\n  refine Equiv.subtypeEquivRight ?_\n  simp only [succ_eq_add_one, ne_eq, Equiv.swap_apply_left, and_congr_right_iff]\n  intro f hi h1\n  rw [Equiv.swap_apply_of_ne_of_ne]\n  \u00b7 exact Ne.symm (Fin.succ_ne_zero k)\n  \u00b7 exact Fin.zero_ne_one\n\n/-- Fixed point involutions of `Fin n.succ.succ` fixing `f 0 = 1` are equivalent to\n  fixed point involutions of `Fin n`. -/\ndef involutionNoFixedSetOne {n : \u2115} :\n    {f : Fin n.succ.succ \u2192 Fin n.succ.succ // Function.Involutive f \u2227\n    (\u2200 i, f i \u2260 i) \u2227 f 0 = 1} \u2243 {f : Fin n \u2192 Fin n // Function.Involutive f \u2227\n    (\u2200 i, f i \u2260 i)} where\n  toFun f := by\n    have hf1 : f.1 1 = 0 := by\n      have hf := f.2.2.2\n      simp only [succ_eq_add_one, ne_eq, \u2190 hf]\n      rw [f.2.1]\n    let f' := f.1 \u2218 Fin.succ \u2218 Fin.succ\n    have hf' (i : Fin n) : f' i \u2260 0 := by\n      simp only [succ_eq_add_one, mul_eq, ne_eq, Function.comp_apply, f']\n      simp only [\u2190 hf1, succ_eq_add_one, ne_eq]\n      by_contra hn\n      have hn' := Function.Involutive.injective f.2.1 hn\n      simp [Fin.ext_iff] at hn'\n    let f'' := fun i => (f' i).pred (hf' i)\n    have hf'' (i : Fin n) : f'' i \u2260 0 := by\n      simp only [mul_eq, ne_eq, f'']\n      rw [@Fin.pred_eq_iff_eq_succ]\n      simp only [mul_eq, succ_eq_add_one, ne_eq, Function.comp_apply, Fin.succ_zero_eq_one, f']\n      simp only [\u2190 f.2.2.2, succ_eq_add_one, ne_eq]\n      by_contra hn\n      have hn' := Function.Involutive.injective f.2.1 hn\n      simp [Fin.ext_iff] at hn'\n    let f''' := fun i => (f'' i).pred (hf'' i)\n    refine \u27e8f''', ?_, ?_\u27e9\n    \u00b7 intro i\n      simp only [mul_eq, succ_eq_add_one, ne_eq, Function.comp_apply, Fin.succ_pred, f''', f'', f']\n      simp [f.2.1 i.succ.succ]\n    \u00b7 intro i\n      simp only [mul_eq, succ_eq_add_one, ne_eq, Function.comp_apply, f''', f'', f']\n      rw [Fin.pred_eq_iff_eq_succ, Fin.pred_eq_iff_eq_succ]\n      exact f.2.2.1 i.succ.succ\n  invFun f := by\n    let f' := fun (i : Fin n.succ.succ)=>\n      match i with\n      | \u27e80, h\u27e9 => 1\n      | \u27e81, h\u27e9 => 0\n      | \u27e8(Nat.succ (Nat.succ n)), h\u27e9 => (f.1 \u27e8n, by omega\u27e9).succ.succ\n    refine \u27e8f', ?_, ?_, ?_\u27e9\n    \u00b7 intro i\n      match i with\n      | \u27e80, h\u27e9 => rfl\n      | \u27e81, h\u27e9 => rfl\n      | \u27e8(Nat.succ (Nat.succ m)), h\u27e9 =>\n        simp only [succ_eq_add_one, ne_eq, f']\n        split\n        \u00b7 rename_i h\n          simp only [succ_eq_add_one, Fin.zero_eta] at h\n          exact False.elim (Fin.succ_ne_zero (f.1 \u27e8m, _\u27e9).succ h)\n        \u00b7 rename_i h\n          simp [Fin.ext_iff] at h\n        \u00b7 rename_i h\n          rename_i x r\n          simp_all only [succ_eq_add_one, Fin.ext_iff, Fin.val_succ, add_left_inj]\n          have hfn {a b : \u2115} {ha : a < n} {hb : b < n}\n            (hab : \u2191(f.1 \u27e8a, ha\u27e9) = b) : \u2191(f.1 \u27e8b, hb\u27e9) = a := by\n            have ht : f.1 \u27e8a, ha\u27e9 = \u27e8b, hb\u27e9 := by\n              simp [hab, Fin.ext_iff]\n            rw [\u2190 ht, f.2.1]\n          exact hfn h\n    \u00b7 intro i\n      match i with\n      | \u27e80, h\u27e9 =>\n        simp only [succ_eq_add_one, ne_eq, Fin.zero_eta, f']\n        split\n        \u00b7 rename_i h\n          simp\n        \u00b7 rename_i h\n          simp [Fin.ext_iff] at h\n        \u00b7 rename_i h\n          simp [Fin.ext_iff] at h\n      | \u27e81, h\u27e9 =>\n        simp only [succ_eq_add_one, ne_eq, Fin.mk_one, f']\n        split\n        \u00b7 rename_i h\n          simp at h\n        \u00b7 rename_i h\n          simp\n        \u00b7 rename_i h\n          simp [Fin.ext_iff] at h\n      | \u27e8(Nat.succ (Nat.succ m)), h\u27e9 =>\n        simp only [succ_eq_add_one, ne_eq, Fin.ext_iff, Fin.val_succ, add_left_inj, f']\n        have hf:= f.2.2 \u27e8m, Nat.add_lt_add_iff_right.mp h\u27e9\n        simp only [ne_eq, Fin.ext_iff] at hf\n        omega\n    \u00b7 simp only [succ_eq_add_one, ne_eq, f']\n      split\n      \u00b7 rename_i h\n        simp\n      \u00b7 rename_i h\n        simp at h\n      \u00b7 rename_i h\n        simp [Fin.ext_iff] at h\n  left_inv f := by\n    have hf1 : f.1 1 = 0 := by\n      have hf := f.2.2.2\n      simp only [succ_eq_add_one, ne_eq, \u2190 hf]\n      rw [f.2.1]\n    simp only [succ_eq_add_one, ne_eq, mul_eq, Function.comp_apply, Fin.succ_mk, Fin.succ_pred]\n    ext i\n    simp only\n    split\n    \u00b7 simp [Fin.val_one, succ_eq_add_one, Fin.zero_eta, f.2.2.2]\n    \u00b7 exact congrArg Fin.val (id (Eq.symm hf1))\n    \u00b7 exact rfl\n  right_inv f := by\n    simp only [ne_eq, mul_eq, succ_eq_add_one, Function.comp_apply]\n    ext i\n    simp only [Fin.coe_pred]\n    split\n    \u00b7 rename_i h\n      simp [Fin.ext_iff] at h\n    \u00b7 rename_i h\n      simp [Fin.ext_iff] at h\n    \u00b7 simp only [Fin.val_succ, add_tsub_cancel_right]\n      congr\n      apply congrArg\n      simp_all [Fin.ext_iff]\n\n/-- Fixed point involutions of `Fin n.succ.succ` for fixed `f 0 = k.succ` are\n  equivalent to fixed point involutions of `Fin n`. -/\ndef involutionNoFixedZeroSetEquiv {n : \u2115} (k : Fin n.succ) :\n    {f : Fin n.succ.succ \u2192 Fin n.succ.succ // Function.Involutive f \u2227\n      (\u2200 i, f i \u2260 i) \u2227 f 0 = k.succ}\n      \u2243 {f : Fin n \u2192 Fin n // Function.Involutive f \u2227 (\u2200 i, f i \u2260 i)} := by\n  refine Equiv.trans (involutionNoFixedZeroSetEquivSetOne k) involutionNoFixedSetOne\n\n/-- The type of fixed point free involutions of `Fin n.succ.succ` is equivalent to the sum\n  of `Fin n.succ` copies of fixed point involutions of `Fin n`. -/\ndef involutionNoFixedEquivSumSame {n : \u2115} :\n    {f : Fin n.succ.succ \u2192 Fin n.succ.succ // Function.Involutive f \u2227 (\u2200 i, f i \u2260 i)}\n    \u2243 \u03a3 (_ : Fin n.succ),\n      {f : Fin n \u2192 Fin n // Function.Involutive f \u2227 (\u2200 i, f i \u2260 i)} := by\n  refine Equiv.trans involutionNoFixedEquivSum ?_\n  refine Equiv.sigmaCongrRight involutionNoFixedZeroSetEquiv\n\n/-- Ever fixed-point free involutions of `Fin n.succ.succ` can be decomposed into a\n  element of `Fin n.succ` (where `0` is sent) and a fixed-point free involution of\n  `Fin n`. -/\ndef involutionNoFixedZeroEquivProd {n : \u2115} :\n    {f : Fin n.succ.succ \u2192 Fin n.succ.succ // Function.Involutive f \u2227 (\u2200 i, f i \u2260 i)}\n    \u2243 Fin n.succ \u00d7\n    {f : Fin n \u2192 Fin n // Function.Involutive f \u2227 (\u2200 i, f i \u2260 i)} := by\n  refine Equiv.trans involutionNoFixedEquivSumSame ?_\n  exact Equiv.sigmaEquivProd (Fin n.succ) { f // Function.Involutive f \u2227 \u2200 (i : Fin n), f i \u2260 i }\n\n/-!\n\n## Cardinality\n\n-/\n\n/-- The type of fixed-point free involutions of `Fin n` is finite. -/\ninstance {n : \u2115} : Fintype { f // Function.Involutive f \u2227 \u2200 (i : Fin n), f i \u2260 i } := by\n  haveI : DecidablePred fun x => Function.Involutive x :=\n    fun f => Fintype.decidableForallFintype (\u03b1 := Fin n)\n  haveI : DecidablePred fun x => Function.Involutive x \u2227 \u2200 (i : Fin n), x i \u2260 i :=\n    fun x => instDecidableAnd\n  apply Subtype.fintype\n\n", "theoremStatement": "lemma involutionNoFixed_card_succ {n : \u2115} :\n    Fintype.card\n    {f : Fin n.succ.succ \u2192 Fin n.succ.succ // Function.Involutive f \u2227 (\u2200 i, f i \u2260 i)}\n    = n.succ *\n    Fintype.card {f : Fin n \u2192 Fin n // Function.Involutive f \u2227 (\u2200 i, f i \u2260 i)} ", "theoremName": "HepLean.Fin.involutionNoFixed_card_succ", "fileCreated": {"commit": "1ab0c6f76904b49d21f9c1e09d26746f52caa4eb", "date": "2025-01-05"}, "theoremCreated": {"commit": "840d16a581a7cfa08b79f3f33bec11d3545abe3b", "date": "2025-01-04"}, "file": "HepLean/HepLean/Mathematics/Fin/Involutions.lean", "module": "HepLean.Mathematics.Fin.Involutions", "jsonFile": "HepLean.Mathematics.Fin.Involutions.jsonl", "positionMetadata": {"lineInFile": 545, "tokenPositionInFile": 21530, "theoremPositionInFile": 13}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 26}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [Fintype.card_congr (involutionNoFixedZeroEquivProd), Fintype.card_prod]\n  congr\n  exact Fintype.card_fin n.succ", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 123}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.WickContraction.Sign.Basic\n\n/-!\n\n# Sign on inserting and not contracting\n\n-/\n\nopen FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\nnamespace WickContraction\nvariable {n : \u2115} (c : WickContraction n)\nopen HepLean.List\nopen FieldStatistic\n\nlemma signFinset_insertAndContract_none (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp)\n    (\u03c6s\u039b : WickContraction \u03c6s.length) (i : Fin \u03c6s.length.succ) (i1 i2 : Fin \u03c6s.length) :\n    (\u03c6s\u039b \u21a9\u039b \u03c6 i none).signFinset (finCongr (insertIdx_length_fin \u03c6 \u03c6s i).symm\n    (i.succAbove i1)) (finCongr (insertIdx_length_fin \u03c6 \u03c6s i).symm (i.succAbove i2)) =\n    if i.succAbove i1 < i \u2227 i < i.succAbove i2 then\n      Insert.insert (finCongr (insertIdx_length_fin \u03c6 \u03c6s i).symm i)\n      (insertAndContractLiftFinset \u03c6 i (\u03c6s\u039b.signFinset i1 i2))\n    else\n      (insertAndContractLiftFinset \u03c6 i (\u03c6s\u039b.signFinset i1 i2)) := by\n  ext k\n  rcases insert_fin_eq_self \u03c6 i k with hk | hk\n  \u00b7 subst hk\n    conv_lhs => simp only [Nat.succ_eq_add_one, signFinset, finCongr_apply, Finset.mem_filter,\n      Finset.mem_univ, insertAndContract_none_getDual?_self, Option.isSome_none, Bool.false_eq_true,\n      IsEmpty.forall_iff, or_self, and_true, true_and]\n    by_cases h : i.succAbove i1 < i \u2227 i < i.succAbove i2\n    \u00b7 simp [h, Fin.lt_def]\n    \u00b7 simp only [Nat.succ_eq_add_one, h, \u2193reduceIte, self_not_mem_insertAndContractLiftFinset,\n      iff_false]\n      rw [Fin.lt_def, Fin.lt_def] at h \u22a2\n      simp_all\n  \u00b7 obtain \u27e8k, hk\u27e9 := hk\n    subst hk\n    have h1 : Fin.cast (insertIdx_length_fin \u03c6 \u03c6s i).symm (i.succAbove k) \u2208\n      (if i.succAbove i1 < i \u2227 i < i.succAbove i2 then\n        Insert.insert ((finCongr (insertIdx_length_fin \u03c6 \u03c6s i).symm) i)\n        (insertAndContractLiftFinset \u03c6 i (\u03c6s\u039b.signFinset i1 i2))\n      else insertAndContractLiftFinset \u03c6 i (\u03c6s\u039b.signFinset i1 i2)) \u2194\n      Fin.cast (insertIdx_length_fin \u03c6 \u03c6s i).symm (i.succAbove k) \u2208\n        insertAndContractLiftFinset \u03c6 i (\u03c6s\u039b.signFinset i1 i2) := by\n      split\n      \u00b7 simp only [Nat.succ_eq_add_one, finCongr_apply, Finset.mem_insert, Fin.ext_iff,\n        Fin.coe_cast, or_iff_right_iff_imp]\n        intro h\n        have h1 : i.succAbove k \u2260 i := by\n          exact Fin.succAbove_ne i k\n        omega\n      \u00b7 simp\n    rw [h1]\n    rw [succAbove_mem_insertAndContractLiftFinset]\n    simp only [Nat.succ_eq_add_one, signFinset, finCongr_apply, Finset.mem_filter, Finset.mem_univ,\n      insertAndContract_none_succAbove_getDual?_eq_none_iff, true_and,\n      insertAndContract_none_succAbove_getDual?_isSome_iff, insertAndContract_none_getDual?_get_eq]\n    rw [Fin.lt_def, Fin.lt_def, Fin.lt_def, Fin.lt_def]\n    simp only [Fin.coe_cast, Fin.val_fin_lt]\n    rw [Fin.succAbove_lt_succAbove_iff, Fin.succAbove_lt_succAbove_iff]\n    simp only [and_congr_right_iff]\n    intro h1 h2\n    conv_lhs =>\n      rhs\n      enter [h]\n      rw [Fin.lt_def]\n      simp only [Fin.coe_cast, Fin.val_fin_lt]\n      rw [Fin.succAbove_lt_succAbove_iff]\n\n/-- Given a Wick contraction `\u03c6s\u039b` associated with a list of states `\u03c6s`\n  and an `i : Fin \u03c6s.length.succ`, the change in sign of the contraction associated with\n  inserting `\u03c6` into `\u03c6s` at position `i` without contracting it.\n\n  For each contracted pair `{a1, a2}` in `\u03c6s\u039b` if `a1 < a2` such that `i` is within the range\n  `a1 < i < a2` we pick up a sign equal to `\ud835\udce2(\u03c6, \u03c6s[a2])`. -/\ndef signInsertNone (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (i : Fin \u03c6s.length.succ) : \u2102 :=\n  \u220f (a : \u03c6s\u039b.1),\n    if i.succAbove (\u03c6s\u039b.fstFieldOfContract a) < i \u2227 i < i.succAbove (\u03c6s\u039b.sndFieldOfContract a) then\n      \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s[\u03c6s\u039b.sndFieldOfContract a])\n    else 1\n\nlemma sign_insert_none_eq_signInsertNone_mul_sign (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp)\n    (\u03c6s\u039b : WickContraction \u03c6s.length) (i : Fin \u03c6s.length.succ) :\n    (\u03c6s\u039b \u21a9\u039b \u03c6 i none).sign = (\u03c6s\u039b.signInsertNone \u03c6 \u03c6s i) * \u03c6s\u039b.sign := by\n  rw [sign]\n  rw [signInsertNone, sign, \u2190 Finset.prod_mul_distrib]\n  rw [insertAndContract_none_prod_contractions]\n  congr\n  funext a\n  simp only [instCommGroup, Nat.succ_eq_add_one, insertAndContract_sndFieldOfContract,\n    finCongr_apply, Fin.getElem_fin, Fin.coe_cast, insertIdx_getElem_fin,\n    insertAndContract_fstFieldOfContract, ite_mul, one_mul]\n  erw [signFinset_insertAndContract_none]\n  split\n  \u00b7 rw [ofFinset_insert]\n    simp only [instCommGroup, Nat.succ_eq_add_one, finCongr_apply, Fin.getElem_fin, Fin.coe_cast,\n      List.getElem_insertIdx_self, map_mul]\n    rw [stat_ofFinset_of_insertAndContractLiftFinset]\n    simp only [exchangeSign_symm, instCommGroup.eq_1]\n    simp\n  \u00b7 rw [stat_ofFinset_of_insertAndContractLiftFinset]\n\nlemma signInsertNone_eq_mul_fst_snd (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp)\n    (\u03c6s\u039b : WickContraction \u03c6s.length) (i : Fin \u03c6s.length.succ) :\n  \u03c6s\u039b.signInsertNone \u03c6 \u03c6s i = \u220f (a : \u03c6s\u039b.1),\n    (if i.succAbove (\u03c6s\u039b.fstFieldOfContract a) < i then\n      \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s[\u03c6s\u039b.sndFieldOfContract a])\n    else 1) *\n    (if i.succAbove (\u03c6s\u039b.sndFieldOfContract a) < i then\n      \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s[\u03c6s\u039b.sndFieldOfContract a])\n    else 1) := by\n  rw [signInsertNone]\n  congr\n  funext a\n  split\n  \u00b7 rename_i h\n    simp only [instCommGroup.eq_1, Fin.getElem_fin, h.1, \u2193reduceIte, mul_ite, exchangeSign_mul_self,\n      mul_one]\n    rw [if_neg]\n    omega\n  \u00b7 rename_i h\n    simp only [Nat.succ_eq_add_one, not_and, not_lt] at h\n    split <;> rename_i h1\n    \u00b7 simp_all only [forall_const, instCommGroup.eq_1, Fin.getElem_fin, mul_ite,\n      exchangeSign_mul_self, mul_one]\n      rw [if_pos]\n      have h1 :i.succAbove (\u03c6s\u039b.sndFieldOfContract a) \u2260 i :=\n        Fin.succAbove_ne i (\u03c6s\u039b.sndFieldOfContract a)\n      omega\n    \u00b7 simp only [not_lt] at h1\n      rw [if_neg]\n      simp only [mul_one]\n      have hn := fstFieldOfContract_lt_sndFieldOfContract \u03c6s\u039b a\n      have hx := (Fin.succAbove_lt_succAbove_iff (p := i)).mpr hn\n      omega\n\nlemma signInsertNone_eq_prod_prod (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp)\n    (\u03c6s\u039b : WickContraction \u03c6s.length) (i : Fin \u03c6s.length.succ) (hG : GradingCompliant \u03c6s \u03c6s\u039b) :\n    \u03c6s\u039b.signInsertNone \u03c6 \u03c6s i = \u220f (a : \u03c6s\u039b.1), \u220f (x : a),\n      (if i.succAbove x < i then \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s[x.1]) else 1) := by\n  rw [signInsertNone_eq_mul_fst_snd]\n  congr\n  funext a\n  rw [prod_finset_eq_mul_fst_snd]\n  congr 1\n  congr 1\n  congr 1\n  simp only [Fin.getElem_fin]\n  erw [hG a]\n  rfl\n\nlemma signInsertNone_eq_prod_getDual?_Some (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp)\n    (\u03c6s\u039b : WickContraction \u03c6s.length) (i : Fin \u03c6s.length.succ) (hG : GradingCompliant \u03c6s \u03c6s\u039b) :\n    \u03c6s\u039b.signInsertNone \u03c6 \u03c6s i = \u220f (x : Fin \u03c6s.length),\n      if (\u03c6s\u039b.getDual? x).isSome then\n        (if i.succAbove x < i then \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s[x.1]) else 1)\n      else 1 := by\n  rw [signInsertNone_eq_prod_prod]\n  trans \u220f (x : (a : \u03c6s\u039b.1) \u00d7 a), (if i.succAbove x.2 < i then \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s[x.2.1]) else 1)\n  \u00b7 rw [Finset.prod_sigma']\n    rfl\n  rw [\u2190 \u03c6s\u039b.sigmaContractedEquiv.symm.prod_comp]\n  let e2 : Fin \u03c6s.length \u2243 {x // (\u03c6s\u039b.getDual? x).isSome} \u2295 {x // \u00ac (\u03c6s\u039b.getDual? x).isSome} := by\n    exact (Equiv.sumCompl fun a => (\u03c6s\u039b.getDual? a).isSome = true).symm\n  rw [\u2190 e2.symm.prod_comp]\n  simp only [instCommGroup.eq_1, Fin.getElem_fin, Fintype.prod_sum_type]\n  conv_rhs =>\n    rhs\n    enter [2, a]\n    rw [if_neg (by simpa [e2] using a.2)]\n  conv_rhs =>\n    lhs\n    enter [2, a]\n    rw [if_pos (by simpa [e2] using a.2)]\n  simp only [Equiv.symm_symm, Equiv.sumCompl_apply_inl, Finset.prod_const_one, mul_one, e2]\n  rfl\n  exact hG\n\n", "theoremStatement": "lemma signInsertNone_eq_filter_map (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp)\n    (\u03c6s\u039b : WickContraction \u03c6s.length) (i : Fin \u03c6s.length.succ) (hG : GradingCompliant \u03c6s \u03c6s\u039b) :\n    \u03c6s\u039b.signInsertNone \u03c6 \u03c6s i =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b ((List.filter (fun x => (\u03c6s\u039b.getDual? x).isSome \u2227 i.succAbove x < i)\n    (List.finRange \u03c6s.length)).map \u03c6s.get)) ", "theoremName": "WickContraction.signInsertNone_eq_filter_map", "fileCreated": {"commit": "ff4a56226cdb330ba2e2fb86afe224b906b97b64", "date": "2025-02-03"}, "theoremCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "file": "HepLean/HepLean/PerturbationTheory/WickContraction/Sign/InsertNone.lean", "module": "HepLean.PerturbationTheory.WickContraction.Sign.InsertNone", "jsonFile": "HepLean.PerturbationTheory.WickContraction.Sign.InsertNone.jsonl", "positionMetadata": {"lineInFile": 187, "tokenPositionInFile": 7568, "theoremPositionInFile": 6}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 15, "numPremises": 139}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [signInsertNone_eq_prod_getDual?_Some]\n  rw [FieldStatistic.ofList_map_eq_finset_prod]\n  rw [map_prod]\n  congr\n  funext a\n  simp only [instCommGroup.eq_1, Bool.decide_and, Bool.decide_eq_true, List.mem_filter,\n    List.mem_finRange, Bool.and_eq_true, decide_eq_true_eq, true_and, Fin.getElem_fin]\n  split\n  \u00b7 rename_i h\n    simp only [h, true_and]\n    split\n    \u00b7 rfl\n    \u00b7 simp only [map_one]\n  \u00b7 rename_i h\n    simp [h]\n  \u00b7 refine List.Nodup.filter _ ?_\n    exact List.nodup_finRange \u03c6s.length\n  \u00b7 exact hG", "proofType": "tactic", "proofLengthLines": 18, "proofLengthTokens": 519}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldSpecification.NormalOrder\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.SuperCommute\nimport HepLean.PerturbationTheory.Koszul.KoszulSign\n/-!\n\n# Normal Ordering in the FieldOpFreeAlgebra\n\nIn the module\n`HepLean.PerturbationTheory.FieldSpecification.NormalOrder`\nwe defined the normal ordering of a list of `CrAnFieldOp`.\nIn this module we extend the normal ordering to a linear map on `FieldOpFreeAlgebra`.\n\nWe derive properties of this normal ordering.\n\n-/\n\nnamespace FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\nopen FieldStatistic\n\nnamespace FieldOpFreeAlgebra\n\nnoncomputable section\n\n/-- For a field specification `\ud835\udcd5`, `normalOrderF` is the linear map\n\n  `FieldOpFreeAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpFreeAlgebra \ud835\udcd5`\n\n  defined by its action on the basis `ofCrAnListF \u03c6s`, taking `ofCrAnListF \u03c6s` to\n\n  `normalOrderSign \u03c6s \u2022 ofCrAnListF (normalOrderList \u03c6s)`.\n\n  That is, `normalOrderF` normal-orders the field operators and multiplies by the sign of the\n  normal order.\n\n  The notation `\ud835\udcdd\u1da0(a)` is used for `normalOrderF a` for `a` an element of\n  `FieldOpFreeAlgebra \ud835\udcd5`. -/\ndef normalOrderF : FieldOpFreeAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpFreeAlgebra \ud835\udcd5 :=\n  Basis.constr ofCrAnListFBasis \u2102 fun \u03c6s =>\n  normalOrderSign \u03c6s \u2022 ofCrAnListF (normalOrderList \u03c6s)\n\n@[inherit_doc normalOrderF]\nscoped[FieldSpecification.FieldOpFreeAlgebra] notation \"\ud835\udcdd\u1da0(\" a \")\" => normalOrderF a\n\nlemma normalOrderF_ofCrAnListF (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    \ud835\udcdd\u1da0(ofCrAnListF \u03c6s) = normalOrderSign \u03c6s \u2022 ofCrAnListF (normalOrderList \u03c6s) := by\n  rw [\u2190 ofListBasis_eq_ofList, normalOrderF, Basis.constr_basis]\n\nlemma ofCrAnListF_eq_normalOrderF (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnListF (normalOrderList \u03c6s) = normalOrderSign \u03c6s \u2022 \ud835\udcdd\u1da0(ofCrAnListF \u03c6s) := by\n  rw [normalOrderF_ofCrAnListF, normalOrderList, smul_smul, normalOrderSign,\n    Wick.koszulSign_mul_self, one_smul]\n\nlemma normalOrderF_one : normalOrderF (\ud835\udcd5 := \ud835\udcd5) 1 = 1 := by\n  rw [\u2190 ofCrAnListF_nil, normalOrderF_ofCrAnListF, normalOrderSign_nil, normalOrderList_nil,\n    ofCrAnListF_nil, one_smul]\n\nlemma normalOrderF_normalOrderF_mid (a b c : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \ud835\udcdd\u1da0(a * b * c) = \ud835\udcdd\u1da0(a * \ud835\udcdd\u1da0(b) * c) := by\n  let pc (c : \ud835\udcd5.FieldOpFreeAlgebra) (hc : c \u2208 Submodule.span \u2102 (Set.range ofCrAnListFBasis)) :\n    Prop := \ud835\udcdd\u1da0(a * b * c) = \ud835\udcdd\u1da0(a * \ud835\udcdd\u1da0(b) * c)\n  change pc c (Basis.mem_span _ c)\n  apply Submodule.span_induction\n  \u00b7 intro x hx\n    obtain \u27e8\u03c6s, rfl\u27e9 := hx\n    simp only [ofListBasis_eq_ofList, pc]\n    let pb (b : \ud835\udcd5.FieldOpFreeAlgebra) (hb : b \u2208 Submodule.span \u2102 (Set.range ofCrAnListFBasis)) :\n      Prop := \ud835\udcdd\u1da0(a * b * ofCrAnListF \u03c6s) = \ud835\udcdd\u1da0(a * \ud835\udcdd\u1da0(b) * ofCrAnListF \u03c6s)\n    change pb b (Basis.mem_span _ b)\n    apply Submodule.span_induction\n    \u00b7 intro x hx\n      obtain \u27e8\u03c6s', rfl\u27e9 := hx\n      simp only [ofListBasis_eq_ofList, pb]\n      let pa (a : \ud835\udcd5.FieldOpFreeAlgebra) (ha : a \u2208 Submodule.span \u2102 (Set.range ofCrAnListFBasis)) :\n        Prop := \ud835\udcdd\u1da0(a * ofCrAnListF \u03c6s' * ofCrAnListF \u03c6s) =\n        \ud835\udcdd\u1da0(a * \ud835\udcdd\u1da0(ofCrAnListF \u03c6s') * ofCrAnListF \u03c6s)\n      change pa a (Basis.mem_span _ a)\n      apply Submodule.span_induction\n      \u00b7 intro x hx\n        obtain \u27e8\u03c6s'', rfl\u27e9 := hx\n        simp only [ofListBasis_eq_ofList, pa]\n        rw [normalOrderF_ofCrAnListF]\n        simp only [\u2190 ofCrAnListF_append, Algebra.mul_smul_comm,\n          Algebra.smul_mul_assoc, map_smul]\n        rw [normalOrderF_ofCrAnListF, normalOrderF_ofCrAnListF, smul_smul]\n        congr 1\n        \u00b7 simp only [normalOrderSign, normalOrderList]\n          rw [Wick.koszulSign_of_append_eq_insertionSort, mul_comm]\n        \u00b7 congr 1\n          simp only [normalOrderList]\n          rw [HepLean.List.insertionSort_append_insertionSort_append]\n      \u00b7 simp [pa]\n      \u00b7 intro x y hx hy h1 h2\n        simp_all [pa, add_mul]\n      \u00b7 intro x hx h\n        simp_all [pa]\n    \u00b7 simp [pb]\n    \u00b7 intro x y hx hy h1 h2\n      simp_all [pb, mul_add, add_mul]\n    \u00b7 intro x hx h\n      simp_all [pb]\n  \u00b7 simp [pc]\n  \u00b7 intro x y hx hy h1 h2\n    simp_all [pc, mul_add]\n  \u00b7 intro x hx h hp\n    simp_all [pc]\n\nlemma normalOrderF_normalOrderF_right (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \ud835\udcdd\u1da0(a * b) = \ud835\udcdd\u1da0(a * \ud835\udcdd\u1da0(b)) := by\n  trans \ud835\udcdd\u1da0(a * b * 1)\n  \u00b7 simp\n  \u00b7 rw [normalOrderF_normalOrderF_mid]\n    simp\n\nlemma normalOrderF_normalOrderF_left (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \ud835\udcdd\u1da0(a * b) = \ud835\udcdd\u1da0(\ud835\udcdd\u1da0(a) * b) := by\n  trans \ud835\udcdd\u1da0(1 * a * b)\n  \u00b7 simp\n  \u00b7 rw [normalOrderF_normalOrderF_mid]\n    simp\n\n/-!\n\n## Normal ordering with a creation operator on the left or annihilation on the right\n\n-/\n\nlemma normalOrderF_ofCrAnListF_cons_create (\u03c6 : \ud835\udcd5.CrAnFieldOp)\n    (h\u03c6 : \ud835\udcd5 |>\u1d9c \u03c6 = CreateAnnihilate.create) (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    \ud835\udcdd\u1da0(ofCrAnListF (\u03c6 :: \u03c6s)) = ofCrAnOpF \u03c6 * \ud835\udcdd\u1da0(ofCrAnListF \u03c6s) := by\n  rw [normalOrderF_ofCrAnListF, normalOrderSign_cons_create \u03c6 h\u03c6,\n    normalOrderList_cons_create \u03c6 h\u03c6 \u03c6s]\n  rw [ofCrAnListF_cons, normalOrderF_ofCrAnListF, mul_smul_comm]\n\nlemma normalOrderF_create_mul (\u03c6 : \ud835\udcd5.CrAnFieldOp)\n    (h\u03c6 : \ud835\udcd5 |>\u1d9c \u03c6 = CreateAnnihilate.create) (a : FieldOpFreeAlgebra \ud835\udcd5) :\n    \ud835\udcdd\u1da0(ofCrAnOpF \u03c6 * a) = ofCrAnOpF \u03c6 * \ud835\udcdd\u1da0(a) := by\n  change (normalOrderF \u2218\u2097 mulLinearMap (ofCrAnOpF \u03c6)) a =\n    (mulLinearMap (ofCrAnOpF \u03c6) \u2218\u2097 normalOrderF) a\n  refine LinearMap.congr_fun (ofCrAnListFBasis.ext fun l \u21a6 ?_) a\n  simp only [mulLinearMap, LinearMap.coe_mk, AddHom.coe_mk, ofListBasis_eq_ofList,\n    LinearMap.coe_comp, Function.comp_apply]\n  rw [\u2190 ofCrAnListF_cons, normalOrderF_ofCrAnListF_cons_create \u03c6 h\u03c6]\n\nlemma normalOrderF_ofCrAnListF_append_annihilate (\u03c6 : \ud835\udcd5.CrAnFieldOp)\n    (h\u03c6 : \ud835\udcd5 |>\u1d9c \u03c6 = CreateAnnihilate.annihilate) (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    \ud835\udcdd\u1da0(ofCrAnListF (\u03c6s ++ [\u03c6])) = \ud835\udcdd\u1da0(ofCrAnListF \u03c6s) * ofCrAnOpF \u03c6 := by\n  rw [normalOrderF_ofCrAnListF, normalOrderSign_append_annihilate \u03c6 h\u03c6 \u03c6s,\n    normalOrderList_append_annihilate \u03c6 h\u03c6 \u03c6s, ofCrAnListF_append, ofCrAnListF_singleton,\n      normalOrderF_ofCrAnListF, smul_mul_assoc]\n\nlemma normalOrderF_mul_annihilate (\u03c6 : \ud835\udcd5.CrAnFieldOp)\n    (h\u03c6 : \ud835\udcd5 |>\u1d9c \u03c6 = CreateAnnihilate.annihilate)\n    (a : FieldOpFreeAlgebra \ud835\udcd5) : \ud835\udcdd\u1da0(a * ofCrAnOpF \u03c6) = \ud835\udcdd\u1da0(a) * ofCrAnOpF \u03c6 := by\n  change (normalOrderF \u2218\u2097 mulLinearMap.flip (ofCrAnOpF \u03c6)) a =\n    (mulLinearMap.flip (ofCrAnOpF \u03c6) \u2218\u2097 normalOrderF) a\n  refine LinearMap.congr_fun (ofCrAnListFBasis.ext fun l \u21a6 ?_) a\n  simp only [mulLinearMap, ofListBasis_eq_ofList, LinearMap.coe_comp, Function.comp_apply,\n    LinearMap.flip_apply, LinearMap.coe_mk, AddHom.coe_mk]\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_append, ofCrAnListF_singleton,\n    normalOrderF_ofCrAnListF_append_annihilate \u03c6 h\u03c6]\n\nlemma normalOrderF_crPartF_mul (\u03c6 : \ud835\udcd5.FieldOp) (a : FieldOpFreeAlgebra \ud835\udcd5) :\n    \ud835\udcdd\u1da0(crPartF \u03c6 * a) =\n    crPartF \u03c6 * \ud835\udcdd\u1da0(a) := by\n  match \u03c6 with\n  | .inAsymp \u03c6 =>\n    rw [crPartF]\n    exact normalOrderF_create_mul \u27e8FieldOp.inAsymp \u03c6, ()\u27e9 rfl a\n  | .position \u03c6 =>\n    rw [crPartF]\n    exact normalOrderF_create_mul _ rfl _\n  | .outAsymp \u03c6 => simp\n\nlemma normalOrderF_mul_anPartF (\u03c6 : \ud835\udcd5.FieldOp) (a : FieldOpFreeAlgebra \ud835\udcd5) :\n    \ud835\udcdd\u1da0(a * anPartF \u03c6) =\n    \ud835\udcdd\u1da0(a) * anPartF \u03c6 := by\n  match \u03c6 with\n  | .inAsymp \u03c6 => simp\n  | .position \u03c6 =>\n    rw [anPartF]\n    exact normalOrderF_mul_annihilate _ rfl _\n  | .outAsymp \u03c6 =>\n    rw [anPartF]\n    refine normalOrderF_mul_annihilate _ rfl _\n\n/-!\n\n## Normal ordering for an adjacent creation and annihliation state\n\nThe main result of this section is `normalOrderF_superCommuteF_annihilate_create`.\n-/\n\nlemma normalOrderF_swap_create_annihilate_ofCrAnListF_ofCrAnListF (\u03c6c \u03c6a : \ud835\udcd5.CrAnFieldOp)\n    (h\u03c6c : \ud835\udcd5 |>\u1d9c \u03c6c = CreateAnnihilate.create) (h\u03c6a : \ud835\udcd5 |>\u1d9c \u03c6a = CreateAnnihilate.annihilate)\n    (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    \ud835\udcdd\u1da0(ofCrAnListF \u03c6s' * ofCrAnOpF \u03c6c * ofCrAnOpF \u03c6a * ofCrAnListF \u03c6s) = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6c, \ud835\udcd5 |>\u209b \u03c6a) \u2022\n    \ud835\udcdd\u1da0(ofCrAnListF \u03c6s' * ofCrAnOpF \u03c6a * ofCrAnOpF \u03c6c * ofCrAnListF \u03c6s) := by\n  rw [mul_assoc, mul_assoc, \u2190 ofCrAnListF_cons, \u2190 ofCrAnListF_cons, \u2190 ofCrAnListF_append]\n  rw [normalOrderF_ofCrAnListF, normalOrderSign_swap_create_annihilate \u03c6c \u03c6a h\u03c6c h\u03c6a]\n  rw [normalOrderList_swap_create_annihilate \u03c6c \u03c6a h\u03c6c h\u03c6a, \u2190 smul_smul, \u2190 normalOrderF_ofCrAnListF]\n  rw [ofCrAnListF_append, ofCrAnListF_cons, ofCrAnListF_cons]\n  noncomm_ring\n\nlemma normalOrderF_swap_create_annihilate_ofCrAnListF (\u03c6c \u03c6a : \ud835\udcd5.CrAnFieldOp)\n    (h\u03c6c : \ud835\udcd5 |>\u1d9c \u03c6c = CreateAnnihilate.create) (h\u03c6a : \ud835\udcd5 |>\u1d9c \u03c6a = CreateAnnihilate.annihilate)\n    (\u03c6s : List \ud835\udcd5.CrAnFieldOp) (a : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \ud835\udcdd\u1da0(ofCrAnListF \u03c6s * ofCrAnOpF \u03c6c * ofCrAnOpF \u03c6a * a) = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6c, \ud835\udcd5 |>\u209b \u03c6a) \u2022\n    \ud835\udcdd\u1da0(ofCrAnListF \u03c6s * ofCrAnOpF \u03c6a * ofCrAnOpF \u03c6c * a) := by\n  change (normalOrderF \u2218\u2097 mulLinearMap (ofCrAnListF \u03c6s * ofCrAnOpF \u03c6c * ofCrAnOpF \u03c6a)) a =\n    (smulLinearMap _ \u2218\u2097 normalOrderF \u2218\u2097\n    mulLinearMap (ofCrAnListF \u03c6s * ofCrAnOpF \u03c6a * ofCrAnOpF \u03c6c)) a\n  refine LinearMap.congr_fun (ofCrAnListFBasis.ext fun l \u21a6 ?_) a\n  simp only [mulLinearMap, LinearMap.coe_mk, AddHom.coe_mk, ofListBasis_eq_ofList,\n    LinearMap.coe_comp, Function.comp_apply, instCommGroup.eq_1]\n  rw [normalOrderF_swap_create_annihilate_ofCrAnListF_ofCrAnListF \u03c6c \u03c6a h\u03c6c h\u03c6a]\n  rfl\n\nlemma normalOrderF_swap_create_annihilate (\u03c6c \u03c6a : \ud835\udcd5.CrAnFieldOp)\n    (h\u03c6c : \ud835\udcd5 |>\u1d9c \u03c6c = CreateAnnihilate.create) (h\u03c6a : \ud835\udcd5 |>\u1d9c \u03c6a = CreateAnnihilate.annihilate)\n    (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \ud835\udcdd\u1da0(a * ofCrAnOpF \u03c6c * ofCrAnOpF \u03c6a * b) = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6c, \ud835\udcd5 |>\u209b \u03c6a) \u2022\n    \ud835\udcdd\u1da0(a * ofCrAnOpF \u03c6a * ofCrAnOpF \u03c6c * b) := by\n  rw [mul_assoc, mul_assoc, mul_assoc, mul_assoc]\n  change (normalOrderF \u2218\u2097 mulLinearMap.flip (ofCrAnOpF \u03c6c * (ofCrAnOpF \u03c6a * b))) a =\n    (smulLinearMap (\ud835\udce2(\ud835\udcd5 |>\u209b \u03c6c, \ud835\udcd5 |>\u209b \u03c6a)) \u2218\u2097\n    normalOrderF \u2218\u2097 mulLinearMap.flip (ofCrAnOpF \u03c6a * (ofCrAnOpF \u03c6c * b))) a\n  refine LinearMap.congr_fun (ofCrAnListFBasis.ext fun l \u21a6 ?_) _\n  simp only [mulLinearMap, ofListBasis_eq_ofList, LinearMap.coe_comp, Function.comp_apply,\n    LinearMap.flip_apply, LinearMap.coe_mk, AddHom.coe_mk, instCommGroup.eq_1, \u2190 mul_assoc,\n      normalOrderF_swap_create_annihilate_ofCrAnListF \u03c6c \u03c6a h\u03c6c h\u03c6a]\n  rfl\n\nlemma normalOrderF_superCommuteF_create_annihilate (\u03c6c \u03c6a : \ud835\udcd5.CrAnFieldOp)\n    (h\u03c6c : \ud835\udcd5 |>\u1d9c \u03c6c = CreateAnnihilate.create) (h\u03c6a : \ud835\udcd5 |>\u1d9c \u03c6a = CreateAnnihilate.annihilate)\n    (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \ud835\udcdd\u1da0(a * [ofCrAnOpF \u03c6c, ofCrAnOpF \u03c6a]\u209bca * b) = 0 := by\n  simp only [superCommuteF_ofCrAnOpF_ofCrAnOpF, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n  rw [mul_sub, sub_mul, map_sub, \u2190 smul_mul_assoc, \u2190 mul_assoc, \u2190 mul_assoc,\n    normalOrderF_swap_create_annihilate \u03c6c \u03c6a h\u03c6c h\u03c6a]\n  simp\n\n", "theoremStatement": "lemma normalOrderF_superCommuteF_annihilate_create (\u03c6c \u03c6a : \ud835\udcd5.CrAnFieldOp)\n    (h\u03c6c : \ud835\udcd5 |>\u1d9c \u03c6c = CreateAnnihilate.create) (h\u03c6a : \ud835\udcd5 |>\u1d9c \u03c6a = CreateAnnihilate.annihilate)\n    (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \ud835\udcdd\u1da0(a * [ofCrAnOpF \u03c6a, ofCrAnOpF \u03c6c]\u209bca * b) = 0 ", "theoremName": "FieldSpecification.FieldOpFreeAlgebra.normalOrderF_superCommuteF_annihilate_create", "fileCreated": {"commit": "ea6e12829370d9630a7e65200c8349e9086c05ba", "date": "2025-02-03"}, "theoremCreated": {"commit": "f5e7bbad5971e380f8e9aa4f340d21a1d324f1a4", "date": "2025-01-30"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpFreeAlgebra/NormalOrder.lean", "module": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.NormalOrder", "jsonFile": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.NormalOrder.jsonl", "positionMetadata": {"lineInFile": 248, "tokenPositionInFile": 10512, "theoremPositionInFile": 18}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 18, "numPremises": 146}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [superCommuteF_ofCrAnOpF_ofCrAnOpF_symm]\n  simp only [instCommGroup.eq_1, neg_smul, mul_neg, Algebra.mul_smul_comm, neg_mul,\n    Algebra.smul_mul_assoc, map_neg, map_smul, neg_eq_zero, smul_eq_zero]\n  exact Or.inr (normalOrderF_superCommuteF_create_annihilate \u03c6c \u03c6a h\u03c6c h\u03c6a ..)", "proofType": "tactic", "proofLengthLines": 4, "proofLengthTokens": 288}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.SuperCommute\nimport Mathlib.Algebra.RingQuot\nimport Mathlib.RingTheory.TwoSidedIdeal.Operations\n/-!\n\n# Field operator algebra\n\n-/\n\nnamespace FieldSpecification\nopen FieldOpFreeAlgebra\nopen HepLean.List\nopen FieldStatistic\n\nvariable (\ud835\udcd5 : FieldSpecification)\n\n/-- The set contains the super-commutators equal to zero in the operator algebra.\n  This contains e.g. the super-commutator of two creation operators. -/\ndef fieldOpIdealSet : Set (FieldOpFreeAlgebra \ud835\udcd5) :=\n  { x |\n    (\u2203 (\u03c61 \u03c62 \u03c63 : \ud835\udcd5.CrAnFieldOp),\n        x = [ofCrAnOpF \u03c61, [ofCrAnOpF \u03c62, ofCrAnOpF \u03c63]\u209bca]\u209bca)\n    \u2228 (\u2203 (\u03c6c \u03c6c' : \ud835\udcd5.CrAnFieldOp) (_ : \ud835\udcd5 |>\u1d9c \u03c6c = .create) (_ : \ud835\udcd5 |>\u1d9c \u03c6c' = .create),\n      x = [ofCrAnOpF \u03c6c, ofCrAnOpF \u03c6c']\u209bca)\n    \u2228 (\u2203 (\u03c6a \u03c6a' : \ud835\udcd5.CrAnFieldOp) (_ : \ud835\udcd5 |>\u1d9c \u03c6a = .annihilate) (_ : \ud835\udcd5 |>\u1d9c \u03c6a' = .annihilate),\n      x = [ofCrAnOpF \u03c6a, ofCrAnOpF \u03c6a']\u209bca)\n    \u2228 (\u2203 (\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp) (_ : \u00ac (\ud835\udcd5 |>\u209b \u03c6) = (\ud835\udcd5 |>\u209b \u03c6')),\n      x = [ofCrAnOpF \u03c6, ofCrAnOpF \u03c6']\u209bca)}\n\n/-- For a field specification `\ud835\udcd5`, the algebra `\ud835\udcd5.FieldOpAlgebra` is defined as the quotient\n  of the free algebra `\ud835\udcd5.FieldOpFreeAlgebra` by the ideal generated by\n- `[ofCrAnOpF \u03c6c, ofCrAnOpF \u03c6c']\u209bca` for `\u03c6c` and `\u03c6c'` field creation operators.\n  This corresponds to the condition that two creation operators always super-commute.\n- `[ofCrAnOpF \u03c6a, ofCrAnOpF \u03c6a']\u209bca` for `\u03c6a` and `\u03c6a'` field annihilation operators.\n  This corresponds to the condition that two annihilation operators always super-commute.\n- `[ofCrAnOpF \u03c6, ofCrAnOpF \u03c6']\u209bca` for `\u03c6` and `\u03c6'` operators with different statistics.\n  This corresponds to the condition that two operators with different statistics always\n  super-commute. In other words, fermions and bosons always super-commute.\n- `[ofCrAnOpF \u03c61, [ofCrAnOpF \u03c62, ofCrAnOpF \u03c63]\u209bca]\u209bca`. This corresponds to the condition,\n  when combined with the conditions above, that the super-commutator is in the center of the\n  of the algebra.\n-/\nabbrev FieldOpAlgebra : Type := (TwoSidedIdeal.span \ud835\udcd5.fieldOpIdealSet).ringCon.Quotient\n\nnamespace FieldOpAlgebra\nvariable {\ud835\udcd5 : FieldSpecification}\n\n/-- The instance of a setoid on `FieldOpFreeAlgebra` from the ideal `TwoSidedIdeal`. -/\ninstance : Setoid (FieldOpFreeAlgebra \ud835\udcd5) := (TwoSidedIdeal.span \ud835\udcd5.fieldOpIdealSet).ringCon.toSetoid\n\nlemma equiv_iff_sub_mem_ideal (x y : FieldOpFreeAlgebra \ud835\udcd5) :\n    x \u2248 y \u2194 x - y \u2208 TwoSidedIdeal.span \ud835\udcd5.fieldOpIdealSet := by\n  rw [\u2190 TwoSidedIdeal.rel_iff]\n  rfl\n\nlemma equiv_iff_exists_add (x y : FieldOpFreeAlgebra \ud835\udcd5) :\n    x \u2248 y \u2194 \u2203 a, x = y + a \u2227 a \u2208 TwoSidedIdeal.span \ud835\udcd5.fieldOpIdealSet := by\n  apply Iff.intro\n  \u00b7 intro h\n    rw [equiv_iff_sub_mem_ideal] at h\n    use x - y\n    simp [h]\n  \u00b7 intro h\n    obtain \u27e8a, rfl, ha\u27e9 := h\n    rw [equiv_iff_sub_mem_ideal]\n    simp [ha]\n\n/-- For a field specification `\ud835\udcd5`, the projection\n\n`\ud835\udcd5.FieldOpFreeAlgebra \u2192\u2090[\u2102] FieldOpAlgebra \ud835\udcd5`\n\ntaking each element of `\ud835\udcd5.FieldOpFreeAlgebra` to its equivalence class in `FieldOpAlgebra \ud835\udcd5`. -/\ndef \u03b9 : FieldOpFreeAlgebra \ud835\udcd5 \u2192\u2090[\u2102] FieldOpAlgebra \ud835\udcd5 where\n  toFun := (TwoSidedIdeal.span \ud835\udcd5.fieldOpIdealSet).ringCon.mk'\n  map_one' := by rfl\n  map_mul' x y := by rfl\n  map_zero' := by rfl\n  map_add' x y := by rfl\n  commutes' x := by rfl\n\nlemma \u03b9_surjective : Function.Surjective (@\u03b9 \ud835\udcd5) := by\n  intro x\n  obtain \u27e8x\u27e9 := x\n  use x\n  rfl\n\nlemma \u03b9_apply (x : FieldOpFreeAlgebra \ud835\udcd5) : \u03b9 x = Quotient.mk _ x := rfl\n\nlemma \u03b9_of_mem_fieldOpIdealSet (x : FieldOpFreeAlgebra \ud835\udcd5) (hx : x \u2208 \ud835\udcd5.fieldOpIdealSet) :\n    \u03b9 x = 0 := by\n  rw [\u03b9_apply]\n  change \u27e6x\u27e7 = \u27e60\u27e7\n  simp only [ringConGen, Quotient.eq]\n  refine RingConGen.Rel.of x 0 ?_\n  simpa using hx\n\nlemma \u03b9_superCommuteF_of_create_create (\u03c6c \u03c6c' : \ud835\udcd5.CrAnFieldOp) (h\u03c6c : \ud835\udcd5 |>\u1d9c \u03c6c = .create)\n    (h\u03c6c' : \ud835\udcd5 |>\u1d9c \u03c6c' = .create) : \u03b9 [ofCrAnOpF \u03c6c, ofCrAnOpF \u03c6c']\u209bca = 0 := by\n  apply \u03b9_of_mem_fieldOpIdealSet\n  simp only [fieldOpIdealSet, exists_and_left, Set.mem_setOf_eq]\n  simp only [exists_prop]\n  right\n  left\n  use \u03c6c, \u03c6c', h\u03c6c, h\u03c6c'\n\nlemma \u03b9_superCommuteF_of_annihilate_annihilate (\u03c6a \u03c6a' : \ud835\udcd5.CrAnFieldOp)\n    (h\u03c6a : \ud835\udcd5 |>\u1d9c \u03c6a = .annihilate) (h\u03c6a' : \ud835\udcd5 |>\u1d9c \u03c6a' = .annihilate) :\n    \u03b9 [ofCrAnOpF \u03c6a, ofCrAnOpF \u03c6a']\u209bca = 0 := by\n  apply \u03b9_of_mem_fieldOpIdealSet\n  simp only [fieldOpIdealSet, exists_and_left, Set.mem_setOf_eq]\n  simp only [exists_prop]\n  right\n  right\n  left\n  use \u03c6a, \u03c6a', h\u03c6a, h\u03c6a'\n\nlemma \u03b9_superCommuteF_of_diff_statistic {\u03c6 \u03c8 : \ud835\udcd5.CrAnFieldOp}\n    (h : (\ud835\udcd5 |>\u209b \u03c6) \u2260 (\ud835\udcd5 |>\u209b \u03c8)) : \u03b9 [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca = 0 := by\n  apply \u03b9_of_mem_fieldOpIdealSet\n  simp only [fieldOpIdealSet, exists_prop, exists_and_left, Set.mem_setOf_eq]\n  right\n  right\n  right\n  use \u03c6, \u03c8\n\nlemma \u03b9_superCommuteF_zero_of_fermionic (\u03c6 \u03c8 : \ud835\udcd5.CrAnFieldOp)\n    (h : [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca \u2208 statisticSubmodule fermionic) :\n    \u03b9 [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca = 0 := by\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton] at h \u22a2\n  rcases statistic_neq_of_superCommuteF_fermionic h with h | h\n  \u00b7 simp only [ofCrAnListF_singleton]\n    apply \u03b9_superCommuteF_of_diff_statistic\n    simpa using h\n  \u00b7 simp [h]\n\nlemma \u03b9_superCommuteF_ofCrAnOpF_ofCrAnOpF_bosonic_or_zero (\u03c6 \u03c8 : \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca \u2208 statisticSubmodule bosonic \u2228\n    \u03b9 [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca = 0 := by\n  rcases superCommuteF_ofCrAnListF_ofCrAnListF_bosonic_or_fermionic [\u03c6] [\u03c8] with h | h\n  \u00b7 simp_all [ofCrAnListF_singleton]\n  \u00b7 simp_all only [ofCrAnListF_singleton]\n    right\n    exact \u03b9_superCommuteF_zero_of_fermionic _ _ h\n\n/-!\n\n## Super-commutes are in the center\n\n-/\n\n@[simp]\nlemma \u03b9_superCommuteF_ofCrAnOpF_superCommuteF_ofCrAnOpF_ofCrAnOpF (\u03c61 \u03c62 \u03c63 : \ud835\udcd5.CrAnFieldOp) :\n    \u03b9 [ofCrAnOpF \u03c61, [ofCrAnOpF \u03c62, ofCrAnOpF \u03c63]\u209bca]\u209bca = 0 := by\n  apply \u03b9_of_mem_fieldOpIdealSet\n  simp only [fieldOpIdealSet, exists_prop, exists_and_left, Set.mem_setOf_eq]\n  left\n  use \u03c61, \u03c62, \u03c63\n\nlemma \u03b9_superCommuteF_superCommuteF_ofCrAnOpF_ofCrAnOpF_ofCrAnOpF (\u03c61 \u03c62 \u03c63 : \ud835\udcd5.CrAnFieldOp) :\n    \u03b9 [[ofCrAnOpF \u03c61, ofCrAnOpF \u03c62]\u209bca, ofCrAnOpF \u03c63]\u209bca = 0 := by\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton]\n  rcases superCommuteF_ofCrAnListF_ofCrAnListF_bosonic_or_fermionic [\u03c61] [\u03c62] with h | h\n  \u00b7 rw [bonsonic_superCommuteF_symm h]\n    simp [ofCrAnListF_singleton]\n  \u00b7 rcases ofCrAnListF_bosonic_or_fermionic [\u03c63] with h' | h'\n    \u00b7 rw [superCommuteF_bonsonic_symm h']\n      simp [ofCrAnListF_singleton]\n    \u00b7 rw [superCommuteF_fermionic_fermionic_symm h h']\n      simp [ofCrAnListF_singleton]\n\nlemma \u03b9_superCommuteF_superCommuteF_ofCrAnOpF_ofCrAnOpF_ofCrAnListF (\u03c61 \u03c62 : \ud835\udcd5.CrAnFieldOp)\n    (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    \u03b9 [[ofCrAnOpF \u03c61, ofCrAnOpF \u03c62]\u209bca, ofCrAnListF \u03c6s]\u209bca = 0 := by\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton]\n  rcases superCommuteF_ofCrAnListF_ofCrAnListF_bosonic_or_fermionic [\u03c61] [\u03c62] with h | h\n  \u00b7 rw [superCommuteF_bosonic_ofCrAnListF_eq_sum _ _ h]\n    simp [ofCrAnListF_singleton, \u03b9_superCommuteF_superCommuteF_ofCrAnOpF_ofCrAnOpF_ofCrAnOpF]\n  \u00b7 rw [superCommuteF_fermionic_ofCrAnListF_eq_sum _ _ h]\n    simp [ofCrAnListF_singleton, \u03b9_superCommuteF_superCommuteF_ofCrAnOpF_ofCrAnOpF_ofCrAnOpF]\n\n@[simp]\nlemma \u03b9_superCommuteF_superCommuteF_ofCrAnOpF_ofCrAnOpF_fieldOpFreeAlgebra (\u03c61 \u03c62 : \ud835\udcd5.CrAnFieldOp)\n    (a : \ud835\udcd5.FieldOpFreeAlgebra) : \u03b9 [[ofCrAnOpF \u03c61, ofCrAnOpF \u03c62]\u209bca, a]\u209bca = 0 := by\n  change (\u03b9.toLinearMap \u2218\u2097 superCommuteF [ofCrAnOpF \u03c61, ofCrAnOpF \u03c62]\u209bca) a = _\n  have h1 : (\u03b9.toLinearMap \u2218\u2097 superCommuteF [ofCrAnOpF \u03c61, ofCrAnOpF \u03c62]\u209bca) = 0 := by\n    apply (ofCrAnListFBasis.ext fun l \u21a6 ?_)\n    simp [\u03b9_superCommuteF_superCommuteF_ofCrAnOpF_ofCrAnOpF_ofCrAnListF]\n  rw [h1]\n  simp\n\nlemma \u03b9_commute_fieldOpFreeAlgebra_superCommuteF_ofCrAnOpF_ofCrAnOpF (\u03c61 \u03c62 : \ud835\udcd5.CrAnFieldOp)\n    (a : \ud835\udcd5.FieldOpFreeAlgebra) : \u03b9 a * \u03b9 [ofCrAnOpF \u03c61, ofCrAnOpF \u03c62]\u209bca -\n    \u03b9 [ofCrAnOpF \u03c61, ofCrAnOpF \u03c62]\u209bca * \u03b9 a = 0 := by\n  rcases \u03b9_superCommuteF_ofCrAnOpF_ofCrAnOpF_bosonic_or_zero \u03c61 \u03c62 with h | h\n  swap\n  \u00b7 simp [h]\n  trans - \u03b9 [[ofCrAnOpF \u03c61, ofCrAnOpF \u03c62]\u209bca, a]\u209bca\n  \u00b7 rw [bosonic_superCommuteF h]\n    simp\n  \u00b7 simp\n\nlemma \u03b9_superCommuteF_ofCrAnOpF_ofCrAnOpF_mem_center (\u03c6 \u03c8 : \ud835\udcd5.CrAnFieldOp) :\n    \u03b9 [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca \u2208 Subalgebra.center \u2102 \ud835\udcd5.FieldOpAlgebra := by\n  rw [Subalgebra.mem_center_iff]\n  intro a\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  have h0 := \u03b9_commute_fieldOpFreeAlgebra_superCommuteF_ofCrAnOpF_ofCrAnOpF \u03c6 \u03c8 a\n  trans \u03b9 ((superCommuteF (ofCrAnOpF \u03c6)) (ofCrAnOpF \u03c8)) * \u03b9 a + 0\n  swap\n  simp only [add_zero]\n  rw [\u2190 h0]\n  abel\n\n/-!\n\n## The kernel of \u03b9\n-/\n\nlemma \u03b9_eq_zero_iff_mem_ideal (x : FieldOpFreeAlgebra \ud835\udcd5) :\n    \u03b9 x = 0 \u2194 x \u2208 TwoSidedIdeal.span \ud835\udcd5.fieldOpIdealSet := by\n  rw [\u03b9_apply]\n  change \u27e6x\u27e7 = \u27e60\u27e7 \u2194 _\n  simp only [ringConGen, Quotient.eq]\n  rw [TwoSidedIdeal.mem_iff]\n  simp only\n  rfl\n\nlemma bosonicProjF_mem_fieldOpIdealSet_or_zero (x : FieldOpFreeAlgebra \ud835\udcd5)\n    (hx : x \u2208 \ud835\udcd5.fieldOpIdealSet) :\n    x.bosonicProjF.1 \u2208 \ud835\udcd5.fieldOpIdealSet \u2228 x.bosonicProjF = 0 := by\n  have hx' := hx\n  simp only [fieldOpIdealSet, exists_prop, Set.mem_setOf_eq] at hx\n  rcases hx with \u27e8\u03c61, \u03c62, \u03c63, rfl\u27e9 | \u27e8\u03c6c, \u03c6c', h\u03c6c, h\u03c6c', rfl\u27e9 | \u27e8\u03c6a, \u03c6a', h\u03c6a, h\u03c6a', rfl\u27e9 |\n    \u27e8\u03c6, \u03c6', hdiff, rfl\u27e9\n  \u00b7 rcases superCommuteF_superCommuteF_ofCrAnOpF_bosonic_or_fermionic \u03c61 \u03c62 \u03c63 with h | h\n    \u00b7 left\n      rw [bosonicProjF_of_mem_bosonic _ h]\n      simpa using hx'\n    \u00b7 right\n      rw [bosonicProjF_of_mem_fermionic _ h]\n  \u00b7 rcases superCommuteF_ofCrAnOpF_ofCrAnOpF_bosonic_or_fermionic \u03c6c \u03c6c' with h | h\n    \u00b7 left\n      rw [bosonicProjF_of_mem_bosonic _ h]\n      simpa using hx'\n    \u00b7 right\n      rw [bosonicProjF_of_mem_fermionic _ h]\n  \u00b7 rcases superCommuteF_ofCrAnOpF_ofCrAnOpF_bosonic_or_fermionic \u03c6a \u03c6a' with h | h\n    \u00b7 left\n      rw [bosonicProjF_of_mem_bosonic _ h]\n      simpa using hx'\n    \u00b7 right\n      rw [bosonicProjF_of_mem_fermionic _ h]\n  \u00b7 rcases superCommuteF_ofCrAnOpF_ofCrAnOpF_bosonic_or_fermionic \u03c6 \u03c6' with h | h\n    \u00b7 left\n      rw [bosonicProjF_of_mem_bosonic _ h]\n      simpa using hx'\n    \u00b7 right\n      rw [bosonicProjF_of_mem_fermionic _ h]\n\nlemma fermionicProjF_mem_fieldOpIdealSet_or_zero (x : FieldOpFreeAlgebra \ud835\udcd5)\n    (hx : x \u2208 \ud835\udcd5.fieldOpIdealSet) :\n    x.fermionicProjF.1 \u2208 \ud835\udcd5.fieldOpIdealSet \u2228 x.fermionicProjF = 0 := by\n  have hx' := hx\n  simp only [fieldOpIdealSet, exists_prop, Set.mem_setOf_eq] at hx\n  rcases hx with \u27e8\u03c61, \u03c62, \u03c63, rfl\u27e9 | \u27e8\u03c6c, \u03c6c', h\u03c6c, h\u03c6c', rfl\u27e9 | \u27e8\u03c6a, \u03c6a', h\u03c6a, h\u03c6a', rfl\u27e9 |\n    \u27e8\u03c6, \u03c6', hdiff, rfl\u27e9\n  \u00b7 rcases superCommuteF_superCommuteF_ofCrAnOpF_bosonic_or_fermionic \u03c61 \u03c62 \u03c63 with h | h\n    \u00b7 right\n      rw [fermionicProjF_of_mem_bosonic _ h]\n    \u00b7 left\n      rw [fermionicProjF_of_mem_fermionic _ h]\n      simpa using hx'\n  \u00b7 rcases superCommuteF_ofCrAnOpF_ofCrAnOpF_bosonic_or_fermionic \u03c6c \u03c6c' with h | h\n    \u00b7 right\n      rw [fermionicProjF_of_mem_bosonic _ h]\n    \u00b7 left\n      rw [fermionicProjF_of_mem_fermionic _ h]\n      simpa using hx'\n  \u00b7 rcases superCommuteF_ofCrAnOpF_ofCrAnOpF_bosonic_or_fermionic \u03c6a \u03c6a' with h | h\n    \u00b7 right\n      rw [fermionicProjF_of_mem_bosonic _ h]\n    \u00b7 left\n      rw [fermionicProjF_of_mem_fermionic _ h]\n      simpa using hx'\n  \u00b7 rcases superCommuteF_ofCrAnOpF_ofCrAnOpF_bosonic_or_fermionic \u03c6 \u03c6' with h | h\n    \u00b7 right\n      rw [fermionicProjF_of_mem_bosonic _ h]\n    \u00b7 left\n      rw [fermionicProjF_of_mem_fermionic _ h]\n      simpa using hx'\n\nlemma bosonicProjF_mem_ideal (x : FieldOpFreeAlgebra \ud835\udcd5)\n    (hx : x \u2208 TwoSidedIdeal.span \ud835\udcd5.fieldOpIdealSet) :\n    x.bosonicProjF.1 \u2208 TwoSidedIdeal.span \ud835\udcd5.fieldOpIdealSet := by\n  rw [TwoSidedIdeal.mem_span_iff_mem_addSubgroup_closure] at hx\n  let p {k : Set \ud835\udcd5.FieldOpFreeAlgebra} (a : FieldOpFreeAlgebra \ud835\udcd5)\n    (h : a \u2208 AddSubgroup.closure k) : Prop :=\n    a.bosonicProjF.1 \u2208 TwoSidedIdeal.span \ud835\udcd5.fieldOpIdealSet\n  change p x hx\n  apply AddSubgroup.closure_induction\n  \u00b7 intro x hx\n    simp only [p]\n    obtain \u27e8a, ha, b, hb, rfl\u27e9 := Set.mem_mul.mp hx\n    obtain \u27e8d, hd, y, hy, rfl\u27e9 := Set.mem_mul.mp ha\n    rw [bosonicProjF_mul, bosonicProjF_mul, fermionicProjF_mul]\n    simp only [add_mul]\n    rcases fermionicProjF_mem_fieldOpIdealSet_or_zero y hy with hfy | hfy\n      <;> rcases bosonicProjF_mem_fieldOpIdealSet_or_zero y hy with hby | hby\n    \u00b7 apply TwoSidedIdeal.add_mem\n      apply TwoSidedIdeal.add_mem\n      \u00b7 /- boson, boson, boson mem-/\n        rw [TwoSidedIdeal.mem_span_iff_mem_addSubgroup_closure]\n        refine Set.mem_of_mem_of_subset ?_ AddSubgroup.subset_closure\n        apply Set.mem_mul.mpr\n        use \u2191(bosonicProjF d) * \u2191(bosonicProjF y)\n        apply And.intro\n        \u00b7 apply Set.mem_mul.mpr\n          use bosonicProjF d\n          simp only [Set.mem_univ, mul_eq_mul_left_iff, ZeroMemClass.coe_eq_zero, true_and]\n          use (bosonicProjF y).1\n          simp [hby]\n        \u00b7 use \u2191(bosonicProjF b)\n          simp\n      \u00b7 /- fermion, fermion, boson mem-/\n        rw [TwoSidedIdeal.mem_span_iff_mem_addSubgroup_closure]\n        refine Set.mem_of_mem_of_subset ?_ AddSubgroup.subset_closure\n        apply Set.mem_mul.mpr\n        use \u2191(fermionicProjF d) * \u2191(fermionicProjF y)\n        apply And.intro\n        \u00b7 apply Set.mem_mul.mpr\n          use fermionicProjF d\n          simp only [Set.mem_univ, mul_eq_mul_left_iff, ZeroMemClass.coe_eq_zero, true_and]\n          use (fermionicProjF y).1\n          simp [hby, hfy]\n        \u00b7 use \u2191(bosonicProjF b)\n          simp\n      apply TwoSidedIdeal.add_mem\n      \u00b7 /- boson, fermion, fermion mem-/\n        rw [TwoSidedIdeal.mem_span_iff_mem_addSubgroup_closure]\n        refine Set.mem_of_mem_of_subset ?_ AddSubgroup.subset_closure\n        apply Set.mem_mul.mpr\n        use \u2191(bosonicProjF d) * \u2191(fermionicProjF y)\n        apply And.intro\n        \u00b7 apply Set.mem_mul.mpr\n          use bosonicProjF d\n          simp only [Set.mem_univ, mul_eq_mul_left_iff, ZeroMemClass.coe_eq_zero, true_and]\n          use (fermionicProjF y).1\n          simp [hby, hfy]\n        \u00b7 use \u2191(fermionicProjF b)\n          simp\n      \u00b7 /- fermion, boson, fermion mem-/\n        rw [TwoSidedIdeal.mem_span_iff_mem_addSubgroup_closure]\n        refine Set.mem_of_mem_of_subset ?_ AddSubgroup.subset_closure\n        apply Set.mem_mul.mpr\n        use \u2191(fermionicProjF d) * \u2191(bosonicProjF y)\n        apply And.intro\n        \u00b7 apply Set.mem_mul.mpr\n          use fermionicProjF d\n          simp only [Set.mem_univ, mul_eq_mul_left_iff, ZeroMemClass.coe_eq_zero, true_and]\n          use (bosonicProjF y).1\n          simp [hby, hfy]\n        \u00b7 use \u2191(fermionicProjF b)\n          simp\n    \u00b7 simp only [hby, ZeroMemClass.coe_zero, mul_zero, zero_mul, zero_add, add_zero]\n      apply TwoSidedIdeal.add_mem\n      \u00b7 /- fermion, fermion, boson mem-/\n        rw [TwoSidedIdeal.mem_span_iff_mem_addSubgroup_closure]\n        refine Set.mem_of_mem_of_subset ?_ AddSubgroup.subset_closure\n        apply Set.mem_mul.mpr\n        use \u2191(fermionicProjF d) * \u2191(fermionicProjF y)\n        apply And.intro\n        \u00b7 apply Set.mem_mul.mpr\n          use fermionicProjF d\n          simp only [Set.mem_univ, mul_eq_mul_left_iff, ZeroMemClass.coe_eq_zero, true_and]\n          use (fermionicProjF y).1\n          simp [hby, hfy]\n        \u00b7 use \u2191(bosonicProjF b)\n          simp\n      \u00b7 /- boson, fermion, fermion mem-/\n        rw [TwoSidedIdeal.mem_span_iff_mem_addSubgroup_closure]\n        refine Set.mem_of_mem_of_subset ?_ AddSubgroup.subset_closure\n        apply Set.mem_mul.mpr\n        use \u2191(bosonicProjF d) * \u2191(fermionicProjF y)\n        apply And.intro\n        \u00b7 apply Set.mem_mul.mpr\n          use bosonicProjF d\n          simp only [Set.mem_univ, mul_eq_mul_left_iff, ZeroMemClass.coe_eq_zero, true_and]\n          use (fermionicProjF y).1\n          simp [hby, hfy]\n        \u00b7 use \u2191(fermionicProjF b)\n          simp\n    \u00b7 simp only [hfy, ZeroMemClass.coe_zero, mul_zero, zero_mul, add_zero, zero_add]\n      apply TwoSidedIdeal.add_mem\n      \u00b7 /- boson, boson, boson mem-/\n        rw [TwoSidedIdeal.mem_span_iff_mem_addSubgroup_closure]\n        refine Set.mem_of_mem_of_subset ?_ AddSubgroup.subset_closure\n        apply Set.mem_mul.mpr\n        use \u2191(bosonicProjF d) * \u2191(bosonicProjF y)\n        apply And.intro\n        \u00b7 apply Set.mem_mul.mpr\n          use bosonicProjF d\n          simp only [Set.mem_univ, mul_eq_mul_left_iff, ZeroMemClass.coe_eq_zero, true_and]\n          use (bosonicProjF y).1\n          simp [hby]\n        \u00b7 use \u2191(bosonicProjF b)\n          simp\n      \u00b7 /- fermion, boson, fermion mem-/\n        rw [TwoSidedIdeal.mem_span_iff_mem_addSubgroup_closure]\n        refine Set.mem_of_mem_of_subset ?_ AddSubgroup.subset_closure\n        apply Set.mem_mul.mpr\n        use \u2191(fermionicProjF d) * \u2191(bosonicProjF y)\n        apply And.intro\n        \u00b7 apply Set.mem_mul.mpr\n          use fermionicProjF d\n          simp only [Set.mem_univ, mul_eq_mul_left_iff, ZeroMemClass.coe_eq_zero, true_and]\n          use (bosonicProjF y).1\n          simp [hby, hfy]\n        \u00b7 use \u2191(fermionicProjF b)\n          simp\n    \u00b7 simp [hfy, hby]\n  \u00b7 simp [p]\n  \u00b7 intro x y hx hy hpx hpy\n    simp_all only [map_add, Submodule.coe_add, p]\n    apply TwoSidedIdeal.add_mem\n    \u00b7 exact hpx\n    \u00b7 exact hpy\n  \u00b7 intro x hx\n    simp [p]\n\n", "theoremStatement": "lemma fermionicProjF_mem_ideal (x : FieldOpFreeAlgebra \ud835\udcd5)\n    (hx : x \u2208 TwoSidedIdeal.span \ud835\udcd5.fieldOpIdealSet) :\n    x.fermionicProjF.1 \u2208 TwoSidedIdeal.span \ud835\udcd5.fieldOpIdealSet ", "theoremName": "FieldSpecification.FieldOpAlgebra.fermionicProjF_mem_ideal", "fileCreated": {"commit": "ea6e12829370d9630a7e65200c8349e9086c05ba", "date": "2025-02-03"}, "theoremCreated": {"commit": "7d9e6af80c57599f68481948604d9f0aaba4a40f", "date": "2025-02-05"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpAlgebra/Basic.lean", "module": "HepLean.PerturbationTheory.FieldOpAlgebra.Basic", "jsonFile": "HepLean.PerturbationTheory.FieldOpAlgebra.Basic.jsonl", "positionMetadata": {"lineInFile": 435, "tokenPositionInFile": 17096, "theoremPositionInFile": 22}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 5, "repositoryPremises": true, "numRepositoryPremises": 14, "numPremises": 96}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  have hb := bosonicProjF_mem_ideal x hx\n  rw [\u2190 \u03b9_eq_zero_iff_mem_ideal] at hx hb \u22a2\n  rw [\u2190 bosonicProjF_add_fermionicProjF x] at hx\n  simp only [map_add] at hx\n  simp_all", "proofType": "tactic", "proofLengthLines": 5, "proofLengthTokens": 178}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldSpecification.Basic\n/-!\n\n# Wick contractions\n\n-/\nopen FieldSpecification\n\nvariable {\ud835\udcd5 : FieldSpecification}\n\n/--\nGiven a natural number `n`, which will correspond to the number of fields needing\ncontracting, a Wick contraction\nis a finite set of pairs of `Fin n` (numbers `0`, \u2026, `n-1`), such that no\nelement of `Fin n` occurs in more then one pair. The pairs are the positions of fields we\n'contract' together.\n-/\ndef WickContraction (n : \u2115) : Type :=\n  {f : Finset ((Finset (Fin n))) // (\u2200 a \u2208 f, a.card = 2) \u2227\n    (\u2200 a \u2208 f, \u2200 b \u2208 f, a = b \u2228 Disjoint a b)}\n\nnamespace WickContraction\nvariable {n : \u2115} (c : WickContraction n)\nopen HepLean.List\n\nremark contraction_notation := \"Given a field specification `\ud835\udcd5`, and a list `\u03c6s`\n  of `\ud835\udcd5.FieldOp`, a Wick contraction of `\u03c6s` will mean a Wick contraction in\n  `WickContraction \u03c6s.length`. The notation `\u03c6s\u039b` will be used for such contractions.\n  The terminology that `\u03c6s\u039b` contracts pairs within of `\u03c6s` will also be used, even though\n  `\u03c6s\u039b` is really contains positions of `\u03c6s`.\"\n\n/-- Wick contractions are decidable. -/\ninstance : DecidableEq (WickContraction n) := Subtype.instDecidableEq\n\n/-- The contraction consisting of no contracted pairs. -/\ndef empty : WickContraction n := \u27e8\u2205, by simp, by simp\u27e9\n\nlemma card_zero_iff_empty (c : WickContraction n) : c.1.card = 0 \u2194 c = empty := by\n  rw [Subtype.eq_iff]\n  simp [empty]\n\nlemma exists_pair_of_not_eq_empty (c : WickContraction n) (h : c \u2260 empty) :\n    \u2203 i j, {i, j} \u2208 c.1 := by\n  by_contra hn\n  simp only [not_exists] at hn\n  have hc : c.1 = \u2205 := by\n    ext a\n    simp only [Finset.not_mem_empty, iff_false]\n    by_contra hn'\n    have hc := c.2.1 a hn'\n    rw [@Finset.card_eq_two] at hc\n    obtain \u27e8x, y, hx, rfl\u27e9 := hc\n    exact hn x y hn'\n  apply h\n  apply Subtype.eq\n  simp [empty, hc]\n\n/-- The equivalence between `WickContraction n` and `WickContraction m`\n  derived from a propositional equality of `n` and `m`. -/\ndef congr : {n m : \u2115} \u2192 (h : n = m) \u2192 WickContraction n \u2243 WickContraction m\n  | n, .(n), rfl => Equiv.refl _\n\n@[simp]\nlemma congr_refl : c.congr rfl = c := by\n  rfl\n\n@[simp]\nlemma card_congr {n m : \u2115} (h : n = m) (c : WickContraction n) :\n    (congr h c).1.card = c.1.card := by\n  subst h\n  simp\n\nlemma congr_contractions {n m : \u2115} (h : n = m) (c : WickContraction n) :\n    ((congr h) c).1 = Finset.map (Finset.mapEmbedding (finCongr h)).toEmbedding c.1 := by\n  subst h\n  simp only [congr_refl, Finset.le_eq_subset, finCongr_refl, Equiv.refl_toEmbedding]\n  ext a\n  apply Iff.intro\n  \u00b7 intro ha\n    simp only [Finset.mem_map, RelEmbedding.coe_toEmbedding]\n    use a\n    simp only [ha, true_and]\n    rw [Finset.mapEmbedding_apply]\n    simp\n  \u00b7 intro ha\n    simp only [Finset.mem_map, RelEmbedding.coe_toEmbedding] at ha\n    obtain \u27e8b, hb, hab\u27e9 := ha\n    rw [Finset.mapEmbedding_apply] at hab\n    simp only [Finset.map_refl] at hab\n    subst hab\n    exact hb\n\n@[simp]\nlemma congr_trans {n m o : \u2115} (h1 : n = m) (h2 : m = o) :\n    (congr h1).trans (congr h2) = congr (h1.trans h2) := by\n  subst h1 h2\n  simp [congr]\n\n@[simp]\nlemma congr_trans_apply {n m o : \u2115} (h1 : n = m) (h2 : m = o) (c : WickContraction n) :\n    (congr h2) ((congr h1) c) = congr (h1.trans h2) c := by\n  subst h1 h2\n  simp\n\nlemma mem_congr_iff {n m : \u2115} (h : n = m) {c : WickContraction n } {a : Finset (Fin m)} :\n    a \u2208 (congr h c).1 \u2194 Finset.map (finCongr h.symm).toEmbedding a \u2208 c.1 := by\n  subst h\n  simp\n\n/-- Given a contracted pair in `c : WickContraction n` the contracted pair\n  in `congr h c`. -/\ndef congrLift {n m : \u2115} (h : n = m) {c : WickContraction n} (a : c.1) : (congr h c).1 :=\n  \u27e8a.1.map (finCongr h).toEmbedding, by\n    subst h\n    simp\u27e9\n\n@[simp]\nlemma congrLift_rfl {n : \u2115} {c : WickContraction n} :\n    c.congrLift rfl = id := by\n  funext a\n  simp [congrLift]\n\nlemma congrLift_injective {n m : \u2115} {c : WickContraction n} (h : n = m) :\n    Function.Injective (c.congrLift h) := by\n  subst h\n  simp only [congrLift_rfl]\n  exact fun \u2983a\u2081 a\u2082\u2984 a => a\n\nlemma congrLift_surjective {n m : \u2115} {c : WickContraction n} (h : n = m) :\n    Function.Surjective (c.congrLift h) := by\n  subst h\n  simp only [congrLift_rfl]\n  exact Function.surjective_id\n\nlemma congrLift_bijective {n m : \u2115} {c : WickContraction n} (h : n = m) :\n    Function.Bijective (c.congrLift h) := by\n  exact \u27e8c.congrLift_injective h, c.congrLift_surjective h\u27e9\n\n/-- Given a contracted pair in `c : WickContraction n` the contracted pair\n  in `congr h c`. -/\ndef congrLiftInv {n m : \u2115} (h : n = m) {c : WickContraction n} (a : (congr h c).1) : c.1 :=\n  \u27e8a.1.map (finCongr h.symm).toEmbedding, by\n    subst h\n    simp\u27e9\n\nlemma congrLiftInv_rfl {n : \u2115} {c : WickContraction n} :\n    c.congrLiftInv rfl = id := by\n  funext a\n  simp [congrLiftInv]\n\nlemma eq_filter_mem_self : c.1 = Finset.filter (fun x => x \u2208 c.1) Finset.univ := by\n  exact Eq.symm (Finset.filter_univ_mem c.1)\n\n/-- For a contraction `c : WickContraction n` and `i : Fin n` the `j` such that\n  `{i, j}` is a contracted pair in `c`. If such an `j` does not exist, this returns `none`. -/\ndef getDual? (i : Fin n) : Option (Fin n) := Fin.find (fun j => {i, j} \u2208 c.1)\n\nlemma getDual?_congr {n m : \u2115} (h : n = m) (c : WickContraction n) (i : Fin m) :\n    (congr h c).getDual? i = Option.map (finCongr h) (c.getDual? (finCongr h.symm i)) := by\n  subst h\n  simp\n\nlemma getDual?_congr_get {n m : \u2115} (h : n = m) (c : WickContraction n) (i : Fin m)\n    (hg : ((congr h c).getDual? i).isSome) :\n    ((congr h c).getDual? i).get hg =\n    (finCongr h ((c.getDual? (finCongr h.symm i)).get (by simpa [getDual?_congr] using hg))) := by\n  simp only [getDual?_congr, finCongr_apply]\n  exact Option.get_map\n\nlemma getDual?_eq_some_iff_mem (i j : Fin n) :\n    c.getDual? i = some j \u2194 {i, j} \u2208 c.1 := by\n  simp only [getDual?]\n  rw [Fin.find_eq_some_iff]\n  apply Iff.intro\n  \u00b7 intro h\n    exact h.1\n  \u00b7 intro h\n    simp only [h, true_and]\n    intro k hk\n    have hc := c.2.2 _ h _ hk\n    simp only [Finset.disjoint_insert_right, Finset.mem_insert, Finset.mem_singleton, true_or,\n      not_true_eq_false, Finset.disjoint_singleton_right, not_or, false_and, or_false] at hc\n    have hj : k \u2208 ({i, j} : Finset (Fin n)) := by\n      simp [hc]\n    simp only [Finset.mem_insert, Finset.mem_singleton] at hj\n    rcases hj with hj | hj\n    \u00b7 subst hj\n      simp only [Finset.mem_singleton, Finset.insert_eq_of_mem] at hk\n      have hc := c.2.1 _ hk\n      simp at hc\n    \u00b7 subst hj\n      simp\n\n@[simp]\nlemma getDual?_one_eq_none (c : WickContraction 1) (i : Fin 1) : c.getDual? i = none := by\n  by_contra h\n  have hn : (c.getDual? i).isSome := by\n    rw [\u2190 Option.not_isSome_iff_eq_none] at h\n    simpa [- Option.not_isSome, -Option.isNone_iff_eq_none] using h\n  rw [@Option.isSome_iff_exists] at hn\n  obtain \u27e8a, hn\u27e9 := hn\n  rw [getDual?_eq_some_iff_mem] at hn\n  have hc := c.2.1 {i, a} hn\n  fin_cases i\n  fin_cases a\n  simp at hc\n\n@[simp]\nlemma getDual?_get_self_mem (i : Fin n) (h : (c.getDual? i).isSome) :\n    {(c.getDual? i).get h, i} \u2208 c.1 := by\n  rw [@Finset.pair_comm]\n  rw [\u2190 getDual?_eq_some_iff_mem]\n  simp\n\n@[simp]\nlemma self_getDual?_get_mem (i : Fin n) (h : (c.getDual? i).isSome) :\n    {i, (c.getDual? i).get h} \u2208 c.1 := by\n  rw [\u2190 getDual?_eq_some_iff_mem]\n  simp\n\nlemma getDual?_eq_some_neq (i j : Fin n) (h : c.getDual? i = some j) :\n    \u00ac i = j := by\n  rw [getDual?_eq_some_iff_mem] at h\n  by_contra hn\n  subst hn\n  have hc := c.2.1 _ h\n  simp at hc\n\n@[simp]\nlemma self_neq_getDual?_get (i : Fin n) (h : (c.getDual? i).isSome) :\n    \u00ac i = (c.getDual? i).get h := by\n  by_contra hn\n  have hx : {i, (c.getDual? i).get h} \u2208 c.1 := by simp\n  have hc := c.2.1 _ hx\n  nth_rewrite 1 [hn] at hc\n  simp at hc\n\n@[simp]\nlemma getDual?_get_self_neq (i : Fin n) (h : (c.getDual? i).isSome) :\n    \u00ac (c.getDual? i).get h = i := by\n  by_contra hn\n  have hx : {i, (c.getDual? i).get h} \u2208 c.1 := by simp\n  have hc := c.2.1 _ hx\n  nth_rewrite 1 [hn] at hc\n  simp at hc\n\nlemma getDual?_isSome_iff (i : Fin n) : (c.getDual? i).isSome \u2194 \u2203 (a : c.1), i \u2208 a.1 := by\n  apply Iff.intro\n  \u00b7 intro h\n    simp only [getDual?] at h\n    rw [Fin.isSome_find_iff] at h\n    obtain \u27e8a, ha\u27e9 := h\n    use \u27e8{i, a}, ha\u27e9\n    simp\n  \u00b7 intro h\n    obtain \u27e8a, ha\u27e9 := h\n    have ha := c.2.1 a a.2\n    rw [@Finset.card_eq_two] at ha\n    obtain \u27e8x, y, hx, hy\u27e9 := ha\n    rw [hy] at ha\n    simp only [Finset.mem_insert, Finset.mem_singleton] at ha\n    match ha with\n    | Or.inl ha =>\n      subst ha\n      simp only [getDual?]\n      rw [Fin.isSome_find_iff]\n      use y\n      rw [\u2190 hy]\n      exact a.2\n    | Or.inr ha =>\n      subst ha\n      simp only [getDual?]\n      rw [Fin.isSome_find_iff]\n      use x\n      rw [Finset.pair_comm]\n      rw [\u2190 hy]\n      exact a.2\n\nlemma getDual?_isSome_of_mem (a : c.1) (i : a.1) : (c.getDual? i).isSome := by\n  rw [getDual?_isSome_iff]\n  use \u27e8a.1, a.2\u27e9\n  simp\n\n@[simp]\nlemma getDual?_getDual?_get_get (i : Fin n) (h : (c.getDual? i).isSome) :\n    c.getDual? ((c.getDual? i).get h) = some i := by\n  rw [getDual?_eq_some_iff_mem]\n  simp\n\nlemma getDual?_getDual?_get_isSome (i : Fin n) (h : (c.getDual? i).isSome) :\n    (c.getDual? ((c.getDual? i).get h)).isSome := by\n  simp\n\nlemma getDual?_getDual?_get_not_none (i : Fin n) (h : (c.getDual? i).isSome) :\n    \u00ac (c.getDual? ((c.getDual? i).get h)) = none := by\n  simp\n\n/-!\n\n## Extracting parts from a contraction.\n\n-/\n\n/-- The smallest of the two positions in a contracted pair given a Wick contraction. -/\ndef fstFieldOfContract (c : WickContraction n) (a : c.1) : Fin n :=\n  (a.1.sort (\u00b7 \u2264 \u00b7)).head (by\n    have hx : (Finset.sort (fun x1 x2 => x1 \u2264 x2) a.1).length = a.1.card := by\n      exact Finset.length_sort fun x1 x2 => x1 \u2264 x2\n    by_contra hn\n    rw [hn, c.2.1 a.1 a.2] at hx\n    simp at hx)\n\n@[simp]\nlemma fstFieldOfContract_congr {n m : \u2115} (h : n = m) (c : WickContraction n) (a : c.1) :\n    (congr h c).fstFieldOfContract (c.congrLift h a) = (finCongr h) (c.fstFieldOfContract a) := by\n  subst h\n  simp [congr]\n\n/-- The largest of the two positions in a contracted pair given a Wick contraction. -/\ndef sndFieldOfContract (c : WickContraction n) (a : c.1) : Fin n :=\n  (a.1.sort (\u00b7 \u2264 \u00b7)).tail.head (by\n    have hx : (Finset.sort (fun x1 x2 => x1 \u2264 x2) a.1).length = a.1.card := by\n      exact Finset.length_sort fun x1 x2 => x1 \u2264 x2\n    by_contra hn\n    have hn := congrArg List.length hn\n    simp only [List.length_tail, Finset.length_sort, List.length_nil] at hn\n    rw [c.2.1 a.1 a.2] at hn\n    omega)\n\n@[simp]\nlemma sndFieldOfContract_congr {n m : \u2115} (h : n = m) (c : WickContraction n) (a : c.1) :\n    (congr h c).sndFieldOfContract (c.congrLift h a) = (finCongr h) (c.sndFieldOfContract a) := by\n  subst h\n  simp [congr]\n\nlemma finset_eq_fstFieldOfContract_sndFieldOfContract (c : WickContraction n) (a : c.1) :\n    a.1 = {c.fstFieldOfContract a, c.sndFieldOfContract a} := by\n  have h1 := c.2.1 a.1 a.2\n  rw [Finset.card_eq_two] at h1\n  obtain \u27e8x, y, hxy, ha\u27e9 := h1\n  rw [ha]\n  by_cases hxyle : x \u2264 y\n  \u00b7 have ha : a.1.sort (\u00b7 \u2264 \u00b7) = [x, y] := by\n      rw [ha]\n      trans Finset.sort (\u00b7 \u2264 \u00b7) (Finset.cons x {y} (by simp [hxy]))\n      \u00b7 congr\n        simp\n      rw [Finset.sort_cons]\n      simp only [Finset.sort_singleton]\n      intro b hb\n      simp only [Finset.mem_singleton] at hb\n      subst hb\n      omega\n    simp [fstFieldOfContract, ha, sndFieldOfContract]\n  \u00b7 have ha : a.1.sort (\u00b7 \u2264 \u00b7) = [y, x] := by\n      rw [ha]\n      trans Finset.sort (\u00b7 \u2264 \u00b7) (Finset.cons y {x} (by simp only [Finset.mem_singleton]; omega))\n      \u00b7 congr\n        simp only [Finset.cons_eq_insert]\n        rw [@Finset.pair_comm]\n      rw [Finset.sort_cons]\n      simp only [Finset.sort_singleton]\n      intro b hb\n      simp only [Finset.mem_singleton] at hb\n      subst hb\n      omega\n    simp only [fstFieldOfContract, ha, List.head_cons, sndFieldOfContract, List.tail_cons]\n    rw [Finset.pair_comm]\n\nlemma fstFieldOfContract_neq_sndFieldOfContract (c : WickContraction n) (a : c.1) :\n    c.fstFieldOfContract a \u2260 c.sndFieldOfContract a := by\n  have h1 := c.2.1 a.1 a.2\n  have h2 := c.finset_eq_fstFieldOfContract_sndFieldOfContract a\n  by_contra hn\n  rw [h2, hn] at h1\n  simp at h1\n\nlemma fstFieldOfContract_le_sndFieldOfContract (c : WickContraction n) (a : c.1) :\n    c.fstFieldOfContract a \u2264 c.sndFieldOfContract a := by\n  simp only [fstFieldOfContract, sndFieldOfContract, List.head_tail]\n  have h1 (n : \u2115) (l : List (Fin n)) (h : l \u2260 []) (hl : l.Sorted (\u00b7 \u2264 \u00b7)) :\n      \u2200 a \u2208 l, l.head h \u2264 a := by\n    induction l with\n    | nil => simp at h\n    | cons i l ih =>\n      simp only [List.sorted_cons] at hl\n      simpa using hl.1\n  apply h1\n  \u00b7 exact Finset.sort_sorted (fun x1 x2 => x1 \u2264 x2) _\n  \u00b7 exact List.getElem_mem _\n\nlemma fstFieldOfContract_lt_sndFieldOfContract (c : WickContraction n) (a : c.1) :\n    c.fstFieldOfContract a < c.sndFieldOfContract a :=\n  lt_of_le_of_ne (c.fstFieldOfContract_le_sndFieldOfContract a)\n    (c.fstFieldOfContract_neq_sndFieldOfContract a)\n\n@[simp]\nlemma fstFieldOfContract_mem (c : WickContraction n) (a : c.1) :\n    c.fstFieldOfContract a \u2208 a.1 := by\n  rw [finset_eq_fstFieldOfContract_sndFieldOfContract]\n  simp\n\nlemma fstFieldOfContract_getDual?_isSome (c : WickContraction n) (a : c.1) :\n    (c.getDual? (c.fstFieldOfContract a)).isSome := by\n  rw [getDual?_isSome_iff]\n  use a\n  simp\n\n@[simp]\nlemma fstFieldOfContract_getDual? (c : WickContraction n) (a : c.1) :\n    c.getDual? (c.fstFieldOfContract a) = some (c.sndFieldOfContract a) := by\n  rw [getDual?_eq_some_iff_mem]\n  erw [\u2190 finset_eq_fstFieldOfContract_sndFieldOfContract]\n  exact a.2\n\n", "theoremStatement": "@[simp]\nlemma sndFieldOfContract_mem (c : WickContraction n) (a : c.1) :\n    c.sndFieldOfContract a \u2208 a.1 ", "theoremName": "WickContraction.sndFieldOfContract_mem", "fileCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "theoremCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "file": "HepLean/HepLean/PerturbationTheory/WickContraction/Basic.lean", "module": "HepLean.PerturbationTheory.WickContraction.Basic", "jsonFile": "HepLean.PerturbationTheory.WickContraction.Basic.jsonl", "positionMetadata": {"lineInFile": 421, "tokenPositionInFile": 13654, "theoremPositionInFile": 44}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 4, "numPremises": 37}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [finset_eq_fstFieldOfContract_sndFieldOfContract]\n  simp", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 67}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.WickContraction.SubContraction\n/-!\n\n# Singleton of contractions\n\n-/\n\nopen FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\nnamespace WickContraction\nvariable {n : \u2115} (c : WickContraction n)\nopen HepLean.List\nopen FieldOpAlgebra\nopen FieldStatistic\n\n/-- The Wick contraction formed from a single ordered pair. -/\ndef singleton {i j : Fin n} (hij : i < j) : WickContraction n :=\n  \u27e8{{i, j}}, by\n    intro i hi\n    simp only [Finset.mem_singleton] at hi\n    subst hi\n    rw [@Finset.card_eq_two]\n    use i, j\n    simp only [ne_eq, and_true]\n    omega, by\n    intro i hi j hj\n    simp_all\u27e9\n\nlemma mem_singleton {i j : Fin n} (hij : i < j) :\n    {i, j} \u2208 (singleton hij).1 := by\n  simp [singleton]\n\nlemma mem_singleton_iff {i j : Fin n} (hij : i < j) {a : Finset (Fin n)} :\n    a \u2208 (singleton hij).1 \u2194 a = {i, j} := by\n  simp [singleton]\n\n", "theoremStatement": "lemma of_singleton_eq {i j : Fin n} (hij : i < j) (a : (singleton hij).1) :\n    a = \u27e8{i, j}, mem_singleton hij\u27e9 ", "theoremName": "WickContraction.of_singleton_eq", "fileCreated": {"commit": "12d36dc1d9c726c035301091e57be0b29015e4ae", "date": "2025-01-31"}, "theoremCreated": {"commit": "12d36dc1d9c726c035301091e57be0b29015e4ae", "date": "2025-01-31"}, "file": "HepLean/HepLean/PerturbationTheory/WickContraction/Singleton.lean", "module": "HepLean.PerturbationTheory.WickContraction.Singleton", "jsonFile": "HepLean.PerturbationTheory.WickContraction.Singleton.jsonl", "positionMetadata": {"lineInFile": 43, "tokenPositionInFile": 1035, "theoremPositionInFile": 3}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 3, "numPremises": 33}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  have ha2 := a.2\n  rw [@mem_singleton_iff] at ha2\n  exact Subtype.coe_eq_of_eq_mk ha2", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 92}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpAlgebra.NormalOrder.Basic\n/-!\n\n# Basic properties of normal ordering\n\n-/\n\nnamespace FieldSpecification\nopen FieldOpFreeAlgebra\nopen HepLean.List\nopen FieldStatistic\n\nnamespace FieldOpAlgebra\nvariable {\ud835\udcd5 : FieldSpecification}\n\n/-!\n\n## Properties of normal ordering.\n\n-/\n\nlemma normalOrder_eq_\u03b9_normalOrderF (a : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \ud835\udcdd(\u03b9 a) = \u03b9 \ud835\udcdd\u1da0(a) := rfl\n\nlemma normalOrder_ofCrAnList (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    \ud835\udcdd(ofCrAnList \u03c6s) = normalOrderSign \u03c6s \u2022 ofCrAnList (normalOrderList \u03c6s) := by\n  rw [ofCrAnList, normalOrder_eq_\u03b9_normalOrderF, normalOrderF_ofCrAnListF]\n  rfl\n\n@[simp]\nlemma normalOrder_one_eq_one : normalOrder (\ud835\udcd5 := \ud835\udcd5) 1 = 1 := by\n  have h1 : 1 = ofCrAnList (\ud835\udcd5 := \ud835\udcd5) [] := by simp [ofCrAnList]\n  rw [h1]\n  rw [normalOrder_ofCrAnList]\n  simp\n\n@[simp]\nlemma normalOrder_ofFieldOpList_nil : normalOrder (\ud835\udcd5 := \ud835\udcd5) (ofFieldOpList []) = 1 := by\n  rw [ofFieldOpList]\n  rw [normalOrder_eq_\u03b9_normalOrderF]\n  simp only [ofFieldOpListF_nil]\n  change normalOrder (\ud835\udcd5 := \ud835\udcd5) 1 = _\n  simp\n\n@[simp]\nlemma normalOrder_ofCrAnList_nil : normalOrder (\ud835\udcd5 := \ud835\udcd5) (ofCrAnList []) = 1 := by\n  rw [normalOrder_ofCrAnList]\n  simp only [normalOrderSign_nil, normalOrderList_nil, one_smul]\n  rfl\n\nlemma ofCrAnList_eq_normalOrder (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnList (normalOrderList \u03c6s) = normalOrderSign \u03c6s \u2022 \ud835\udcdd(ofCrAnList \u03c6s) := by\n  rw [normalOrder_ofCrAnList, smul_smul, normalOrderSign, Wick.koszulSign_mul_self,\n    one_smul]\n\nlemma normalOrder_normalOrder_mid (a b c : \ud835\udcd5.FieldOpAlgebra) :\n    \ud835\udcdd(a * b * c) = \ud835\udcdd(a * \ud835\udcdd(b) * c) := by\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n  obtain \u27e8c, rfl\u27e9 := \u03b9_surjective c\n  rw [normalOrder_eq_\u03b9_normalOrderF]\n  simp only [\u2190 map_mul]\n  rw [normalOrder_eq_\u03b9_normalOrderF]\n  rw [normalOrderF_normalOrderF_mid]\n  rfl\n\n", "theoremStatement": "lemma normalOrder_normalOrder_left (a b : \ud835\udcd5.FieldOpAlgebra) :\n    \ud835\udcdd(a * b) = \ud835\udcdd(\ud835\udcdd(a) * b) ", "theoremName": "FieldSpecification.FieldOpAlgebra.normalOrder_normalOrder_left", "fileCreated": {"commit": "2e82f842a242717b98517656fc34b1b92f579b2e", "date": "2025-02-05"}, "theoremCreated": {"commit": "12d36dc1d9c726c035301091e57be0b29015e4ae", "date": "2025-01-31"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpAlgebra/NormalOrder/Lemmas.lean", "module": "HepLean.PerturbationTheory.FieldOpAlgebra.NormalOrder.Lemmas", "jsonFile": "HepLean.PerturbationTheory.FieldOpAlgebra.NormalOrder.Lemmas.jsonl", "positionMetadata": {"lineInFile": 72, "tokenPositionInFile": 1989, "theoremPositionInFile": 7}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 11, "numPremises": 83}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n  rw [normalOrder_eq_\u03b9_normalOrderF]\n  simp only [\u2190 map_mul]\n  rw [normalOrder_eq_\u03b9_normalOrderF]\n  rw [normalOrderF_normalOrderF_left]\n  rfl", "proofType": "tactic", "proofLengthLines": 7, "proofLengthTokens": 219}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.Basic\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.Grading\n/-!\n\n# Super Commute\n-/\n\nnamespace FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\nnamespace FieldOpFreeAlgebra\n\n/-!\n\n## The super commutator on the FieldOpFreeAlgebra.\n\n-/\n\nopen FieldStatistic\n\n/-- For a field specification `\ud835\udcd5`, the super commutator `superCommuteF` is defined as the linear\n  map `\ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102] \ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102] \ud835\udcd5.FieldOpFreeAlgebra`\n  which on the lists `\u03c6s` and `\u03c6s'` of `\ud835\udcd5.CrAnFieldOp` gives\n\n  `superCommuteF \u03c6s \u03c6s' = \u03c6s * \u03c6s' - \ud835\udce2(\u03c6s, \u03c6s') \u2022 \u03c6s' * \u03c6s`.\n\n  The notation `[a, b]\u209bca` can be used for `superCommuteF a b`. -/\nnoncomputable def superCommuteF : \ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102] \ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102]\n    \ud835\udcd5.FieldOpFreeAlgebra :=\n  Basis.constr ofCrAnListFBasis \u2102 fun \u03c6s =>\n  Basis.constr ofCrAnListFBasis \u2102 fun \u03c6s' =>\n  ofCrAnListF (\u03c6s ++ \u03c6s') - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnListF (\u03c6s' ++ \u03c6s)\n\n@[inherit_doc superCommuteF]\nscoped[FieldSpecification.FieldOpFreeAlgebra] notation \"[\" \u03c6s \",\" \u03c6s' \"]\u209bca\" => superCommuteF \u03c6s \u03c6s'\n\n/-!\n\n## The super commutator of different types of elements\n\n-/\n\nlemma superCommuteF_ofCrAnListF_ofCrAnListF (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnListF \u03c6s, ofCrAnListF \u03c6s']\u209bca =\n    ofCrAnListF (\u03c6s ++ \u03c6s') - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnListF (\u03c6s' ++ \u03c6s) := by\n  rw [\u2190 ofListBasis_eq_ofList, \u2190 ofListBasis_eq_ofList]\n  simp only [superCommuteF, Basis.constr_basis]\n\nlemma superCommuteF_ofCrAnOpF_ofCrAnOpF (\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnOpF \u03c6, ofCrAnOpF \u03c6']\u209bca =\n    ofCrAnOpF \u03c6 * ofCrAnOpF \u03c6' - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 ofCrAnOpF \u03c6' * ofCrAnOpF \u03c6 := by\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton]\n  rw [superCommuteF_ofCrAnListF_ofCrAnListF, ofCrAnListF_append]\n  congr\n  rw [ofCrAnListF_append]\n  rw [FieldStatistic.ofList_singleton, FieldStatistic.ofList_singleton, smul_mul_assoc]\n\nlemma superCommuteF_ofCrAnListF_ofFieldOpFsList (\u03c6cas : List \ud835\udcd5.CrAnFieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [ofCrAnListF \u03c6cas, ofFieldOpListF \u03c6s]\u209bca = ofCrAnListF \u03c6cas * ofFieldOpListF \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6cas, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpListF \u03c6s * ofCrAnListF \u03c6cas := by\n  conv_lhs => rw [ofFieldOpListF_sum]\n  rw [map_sum]\n  conv_lhs =>\n    enter [2, x]\n    rw [superCommuteF_ofCrAnListF_ofCrAnListF, CrAnSection.statistics_eq_state_statistics,\n      ofCrAnListF_append, ofCrAnListF_append]\n  rw [Finset.sum_sub_distrib, \u2190 Finset.mul_sum, \u2190 Finset.smul_sum,\n    \u2190 Finset.sum_mul, \u2190 ofFieldOpListF_sum]\n  simp\n\nlemma superCommuteF_ofFieldOpListF_ofFieldOpFsList (\u03c6 : List \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [ofFieldOpListF \u03c6, ofFieldOpListF \u03c6s]\u209bca = ofFieldOpListF \u03c6 * ofFieldOpListF \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpListF \u03c6s * ofFieldOpListF \u03c6 := by\n  conv_lhs => rw [ofFieldOpListF_sum]\n  simp only [map_sum, LinearMap.coeFn_sum, Finset.sum_apply, instCommGroup.eq_1,\n    Algebra.smul_mul_assoc]\n  conv_lhs =>\n    enter [2, x]\n    rw [superCommuteF_ofCrAnListF_ofFieldOpFsList]\n  simp only [instCommGroup.eq_1, CrAnSection.statistics_eq_state_statistics,\n    Algebra.smul_mul_assoc, Finset.sum_sub_distrib]\n  rw [\u2190 Finset.sum_mul, \u2190 Finset.smul_sum, \u2190 Finset.mul_sum, \u2190 ofFieldOpListF_sum]\n\nlemma superCommuteF_ofFieldOpF_ofFieldOpFsList (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [ofFieldOpF \u03c6, ofFieldOpListF \u03c6s]\u209bca = ofFieldOpF \u03c6 * ofFieldOpListF \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpListF \u03c6s * ofFieldOpF \u03c6 := by\n  rw [\u2190 ofFieldOpListF_singleton, superCommuteF_ofFieldOpListF_ofFieldOpFsList,\n    ofFieldOpListF_singleton]\n  simp\n\nlemma superCommuteF_ofFieldOpListF_ofFieldOpF (\u03c6s : List \ud835\udcd5.FieldOp) (\u03c6 : \ud835\udcd5.FieldOp) :\n    [ofFieldOpListF \u03c6s, ofFieldOpF \u03c6]\u209bca = ofFieldOpListF \u03c6s * ofFieldOpF \u03c6 -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6) \u2022 ofFieldOpF \u03c6 * ofFieldOpListF \u03c6s := by\n  rw [\u2190 ofFieldOpListF_singleton, superCommuteF_ofFieldOpListF_ofFieldOpFsList,\n    ofFieldOpListF_singleton]\n  simp\n\nlemma superCommuteF_anPartF_crPartF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [anPartF \u03c6, crPartF \u03c6']\u209bca = anPartF \u03c6 * crPartF \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 crPartF \u03c6' * anPartF \u03c6 := by\n  match \u03c6, \u03c6' with\n  | FieldOp.inAsymp \u03c6, _ =>\n    simp\n  | _, FieldOp.outAsymp \u03c6 =>\n    simp only [crPartF_posAsymp, map_zero, mul_zero, instCommGroup.eq_1, smul_zero, zero_mul,\n      sub_self]\n  | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n    simp only [anPartF_position, crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.outAsymp \u03c6, FieldOp.position \u03c6' =>\n    simp only [anPartF_posAsymp, crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.position \u03c6, FieldOp.inAsymp \u03c6' =>\n    simp only [anPartF_position, crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp only [List.singleton_append, instCommGroup.eq_1, crAnStatistics,\n      FieldStatistic.ofList_singleton, Function.comp_apply, crAnFieldOpToFieldOp_prod, \u2190\n      ofCrAnListF_append]\n  | FieldOp.outAsymp \u03c6, FieldOp.inAsymp \u03c6' =>\n    simp only [anPartF_posAsymp, crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n\nlemma superCommuteF_crPartF_anPartF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [crPartF \u03c6, anPartF \u03c6']\u209bca = crPartF \u03c6 * anPartF \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 anPartF \u03c6' * crPartF \u03c6 := by\n    match \u03c6, \u03c6' with\n    | FieldOp.outAsymp \u03c6, _ =>\n    simp only [crPartF_posAsymp, map_zero, LinearMap.zero_apply, zero_mul, instCommGroup.eq_1,\n      mul_zero, sub_self]\n    | _, FieldOp.inAsymp \u03c6 =>\n    simp only [anPartF_negAsymp, map_zero, mul_zero, instCommGroup.eq_1, smul_zero, zero_mul,\n      sub_self]\n    | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n    simp only [crPartF_position, anPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n    | FieldOp.position \u03c6, FieldOp.outAsymp \u03c6' =>\n    simp only [crPartF_position, anPartF_posAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n    | FieldOp.inAsymp \u03c6, FieldOp.position \u03c6' =>\n    simp only [crPartF_negAsymp, anPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n    | FieldOp.inAsymp \u03c6, FieldOp.outAsymp \u03c6' =>\n    simp only [crPartF_negAsymp, anPartF_posAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n\nlemma superCommuteF_crPartF_crPartF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [crPartF \u03c6, crPartF \u03c6']\u209bca = crPartF \u03c6 * crPartF \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 crPartF \u03c6' * crPartF \u03c6 := by\n  match \u03c6, \u03c6' with\n  | FieldOp.outAsymp \u03c6, _ =>\n  simp only [crPartF_posAsymp, map_zero, LinearMap.zero_apply, zero_mul, instCommGroup.eq_1,\n    mul_zero, sub_self]\n  | _, FieldOp.outAsymp \u03c6 =>\n  simp only [crPartF_posAsymp, map_zero, mul_zero, instCommGroup.eq_1, smul_zero, zero_mul,\n    sub_self]\n  | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n  simp only [crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.position \u03c6, FieldOp.inAsymp \u03c6' =>\n  simp only [crPartF_position, crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.inAsymp \u03c6, FieldOp.position \u03c6' =>\n  simp only [crPartF_negAsymp, crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.inAsymp \u03c6, FieldOp.inAsymp \u03c6' =>\n  simp only [crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp [crAnStatistics, \u2190 ofCrAnListF_append]\n\nlemma superCommuteF_anPartF_anPartF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [anPartF \u03c6, anPartF \u03c6']\u209bca =\n    anPartF \u03c6 * anPartF \u03c6' - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 anPartF \u03c6' * anPartF \u03c6 := by\n  match \u03c6, \u03c6' with\n  | FieldOp.inAsymp \u03c6, _ =>\n    simp\n  | _, FieldOp.inAsymp \u03c6 =>\n    simp\n  | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n    simp only [anPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.position \u03c6, FieldOp.outAsymp \u03c6' =>\n    simp only [anPartF_position, anPartF_posAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.outAsymp \u03c6, FieldOp.position \u03c6' =>\n    simp only [anPartF_posAsymp, anPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.outAsymp \u03c6, FieldOp.outAsymp \u03c6' =>\n    simp only [anPartF_posAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n\nlemma superCommuteF_crPartF_ofFieldOpListF (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [crPartF \u03c6, ofFieldOpListF \u03c6s]\u209bca =\n    crPartF \u03c6 * ofFieldOpListF \u03c6s - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpListF \u03c6s *\n    crPartF \u03c6 := by\n  match \u03c6 with\n  | FieldOp.inAsymp \u03c6 =>\n    simp only [crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofFieldOpFsList]\n    simp [crAnStatistics]\n  | FieldOp.position \u03c6 =>\n    simp only [crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofFieldOpFsList]\n    simp [crAnStatistics]\n  | FieldOp.outAsymp \u03c6 =>\n    simp\n\nlemma superCommuteF_anPartF_ofFieldOpListF (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [anPartF \u03c6, ofFieldOpListF \u03c6s]\u209bca =\n    anPartF \u03c6 * ofFieldOpListF \u03c6s - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022\n    ofFieldOpListF \u03c6s * anPartF \u03c6 := by\n  match \u03c6 with\n  | FieldOp.inAsymp \u03c6 =>\n    simp\n  | FieldOp.position \u03c6 =>\n    simp only [anPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofFieldOpFsList]\n    simp [crAnStatistics]\n  | FieldOp.outAsymp \u03c6 =>\n    simp only [anPartF_posAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofFieldOpFsList]\n    simp [crAnStatistics]\n\nlemma superCommuteF_crPartF_ofFieldOpF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [crPartF \u03c6, ofFieldOpF \u03c6']\u209bca =\n    crPartF \u03c6 * ofFieldOpF \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 ofFieldOpF \u03c6' * crPartF \u03c6 := by\n  rw [\u2190 ofFieldOpListF_singleton, superCommuteF_crPartF_ofFieldOpListF]\n  simp\n\nlemma superCommuteF_anPartF_ofFieldOpF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [anPartF \u03c6, ofFieldOpF \u03c6']\u209bca =\n    anPartF \u03c6 * ofFieldOpF \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 ofFieldOpF \u03c6' * anPartF \u03c6 := by\n  rw [\u2190 ofFieldOpListF_singleton, superCommuteF_anPartF_ofFieldOpListF]\n  simp\n\n/-!\n\n## Mul equal superCommuteF\n\nLemmas which rewrite a multiplication of two elements of the algebra as their commuted\nmultiplication with a sign plus the super commutator.\n\n-/\nlemma ofCrAnListF_mul_ofCrAnListF_eq_superCommuteF (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnListF \u03c6s * ofCrAnListF \u03c6s' = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnListF \u03c6s' * ofCrAnListF \u03c6s\n    + [ofCrAnListF \u03c6s, ofCrAnListF \u03c6s']\u209bca := by\n  rw [superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp [ofCrAnListF_append]\n\nlemma ofCrAnOpF_mul_ofCrAnListF_eq_superCommuteF (\u03c6 : \ud835\udcd5.CrAnFieldOp) (\u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnOpF \u03c6 * ofCrAnListF \u03c6s' = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnListF \u03c6s' * ofCrAnOpF \u03c6\n    + [ofCrAnOpF \u03c6, ofCrAnListF \u03c6s']\u209bca := by\n  rw [\u2190 ofCrAnListF_singleton, ofCrAnListF_mul_ofCrAnListF_eq_superCommuteF]\n  simp\n\nlemma ofFieldOpListF_mul_ofFieldOpListF_eq_superCommuteF (\u03c6s \u03c6s' : List \ud835\udcd5.FieldOp) :\n    ofFieldOpListF \u03c6s * ofFieldOpListF \u03c6s' =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofFieldOpListF \u03c6s' * ofFieldOpListF \u03c6s\n    + [ofFieldOpListF \u03c6s, ofFieldOpListF \u03c6s']\u209bca := by\n  rw [superCommuteF_ofFieldOpListF_ofFieldOpFsList]\n  simp\n\nlemma ofFieldOpF_mul_ofFieldOpListF_eq_superCommuteF (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s' : List \ud835\udcd5.FieldOp) :\n    ofFieldOpF \u03c6 * ofFieldOpListF \u03c6s' = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofFieldOpListF \u03c6s' * ofFieldOpF \u03c6\n    + [ofFieldOpF \u03c6, ofFieldOpListF \u03c6s']\u209bca := by\n  rw [superCommuteF_ofFieldOpF_ofFieldOpFsList]\n  simp\n\nlemma ofFieldOpListF_mul_ofFieldOpF_eq_superCommuteF (\u03c6s : List \ud835\udcd5.FieldOp) (\u03c6 : \ud835\udcd5.FieldOp) :\n    ofFieldOpListF \u03c6s * ofFieldOpF \u03c6 = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6) \u2022 ofFieldOpF \u03c6 * ofFieldOpListF \u03c6s\n    + [ofFieldOpListF \u03c6s, ofFieldOpF \u03c6]\u209bca := by\n  rw [superCommuteF_ofFieldOpListF_ofFieldOpF]\n  simp\n\nlemma crPartF_mul_anPartF_eq_superCommuteF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    crPartF \u03c6 * anPartF \u03c6' =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 anPartF \u03c6' * crPartF \u03c6 +\n    [crPartF \u03c6, anPartF \u03c6']\u209bca := by\n  rw [superCommuteF_crPartF_anPartF]\n  simp\n\nlemma anPartF_mul_crPartF_eq_superCommuteF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    anPartF \u03c6 * crPartF \u03c6' =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022\n    crPartF \u03c6' * anPartF \u03c6 +\n    [anPartF \u03c6, crPartF \u03c6']\u209bca := by\n  rw [superCommuteF_anPartF_crPartF]\n  simp\n\nlemma crPartF_mul_crPartF_eq_superCommuteF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    crPartF \u03c6 * crPartF \u03c6' =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 crPartF \u03c6' * crPartF \u03c6 +\n    [crPartF \u03c6, crPartF \u03c6']\u209bca := by\n  rw [superCommuteF_crPartF_crPartF]\n  simp\n\nlemma anPartF_mul_anPartF_eq_superCommuteF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    anPartF \u03c6 * anPartF \u03c6' = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 anPartF \u03c6' * anPartF \u03c6 +\n    [anPartF \u03c6, anPartF \u03c6']\u209bca := by\n  rw [superCommuteF_anPartF_anPartF]\n  simp\n\nlemma ofCrAnListF_mul_ofFieldOpListF_eq_superCommuteF (\u03c6s : List \ud835\udcd5.CrAnFieldOp)\n    (\u03c6s' : List \ud835\udcd5.FieldOp) : ofCrAnListF \u03c6s * ofFieldOpListF \u03c6s' =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofFieldOpListF \u03c6s' * ofCrAnListF \u03c6s\n    + [ofCrAnListF \u03c6s, ofFieldOpListF \u03c6s']\u209bca := by\n  rw [superCommuteF_ofCrAnListF_ofFieldOpFsList]\n  simp\n\n/-!\n\n## Symmetry of the super commutator.\n\n-/\n\nlemma superCommuteF_ofCrAnListF_ofCrAnListF_symm (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnListF \u03c6s, ofCrAnListF \u03c6s']\u209bca =\n    (- \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s')) \u2022 [ofCrAnListF \u03c6s', ofCrAnListF \u03c6s]\u209bca := by\n  rw [superCommuteF_ofCrAnListF_ofCrAnListF, superCommuteF_ofCrAnListF_ofCrAnListF, smul_sub]\n  simp only [instCommGroup.eq_1, neg_smul, sub_neg_eq_add]\n  rw [smul_smul]\n  conv_rhs =>\n    rhs\n    rw [exchangeSign_symm, exchangeSign_mul_self]\n  simp only [one_smul]\n  abel\n\nlemma superCommuteF_ofCrAnOpF_ofCrAnOpF_symm (\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnOpF \u03c6, ofCrAnOpF \u03c6']\u209bca =\n    (- \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6')) \u2022 [ofCrAnOpF \u03c6', ofCrAnOpF \u03c6]\u209bca := by\n  rw [superCommuteF_ofCrAnOpF_ofCrAnOpF, superCommuteF_ofCrAnOpF_ofCrAnOpF]\n  rw [smul_sub]\n  simp only [instCommGroup.eq_1, Algebra.smul_mul_assoc, neg_smul, sub_neg_eq_add]\n  rw [smul_smul]\n  conv_rhs =>\n    rhs\n    rw [exchangeSign_symm, exchangeSign_mul_self]\n  simp only [one_smul]\n  abel\n\n/-!\n\n## Splitting the super commutator on lists into sums.\n\n-/\n\nlemma superCommuteF_ofCrAnListF_ofCrAnListF_cons (\u03c6 : \ud835\udcd5.CrAnFieldOp) (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnListF \u03c6s, ofCrAnListF (\u03c6 :: \u03c6s')]\u209bca =\n    [ofCrAnListF \u03c6s, ofCrAnOpF \u03c6]\u209bca * ofCrAnListF \u03c6s' +\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6)\n    \u2022 ofCrAnOpF \u03c6 * [ofCrAnListF \u03c6s, ofCrAnListF \u03c6s']\u209bca := by\n  rw [superCommuteF_ofCrAnListF_ofCrAnListF]\n  conv_rhs =>\n    lhs\n    rw [\u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF, sub_mul,\n      \u2190 ofCrAnListF_append]\n    rhs\n    rw [FieldStatistic.ofList_singleton, ofCrAnListF_append, ofCrAnListF_singleton, smul_mul_assoc,\n      mul_assoc, \u2190 ofCrAnListF_append]\n  conv_rhs =>\n    rhs\n    rw [superCommuteF_ofCrAnListF_ofCrAnListF, mul_sub, smul_mul_assoc]\n  simp only [instCommGroup.eq_1, List.cons_append, List.append_assoc, List.nil_append,\n    Algebra.mul_smul_comm, Algebra.smul_mul_assoc, sub_add_sub_cancel, sub_right_inj]\n  rw [\u2190 ofCrAnListF_cons, smul_smul, FieldStatistic.ofList_cons_eq_mul]\n  simp only [instCommGroup, map_mul, mul_comm]\n\nlemma superCommuteF_ofCrAnListF_ofFieldOpListF_cons (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.CrAnFieldOp)\n    (\u03c6s' : List \ud835\udcd5.FieldOp) : [ofCrAnListF \u03c6s, ofFieldOpListF (\u03c6 :: \u03c6s')]\u209bca =\n    [ofCrAnListF \u03c6s, ofFieldOpF \u03c6]\u209bca * ofFieldOpListF \u03c6s' +\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6) \u2022 ofFieldOpF \u03c6 * [ofCrAnListF \u03c6s, ofFieldOpListF \u03c6s']\u209bca := by\n  rw [superCommuteF_ofCrAnListF_ofFieldOpFsList]\n  conv_rhs =>\n    lhs\n    rw [\u2190 ofFieldOpListF_singleton, superCommuteF_ofCrAnListF_ofFieldOpFsList, sub_mul, mul_assoc,\n      \u2190 ofFieldOpListF_append]\n    rhs\n    rw [FieldStatistic.ofList_singleton, ofFieldOpListF_singleton, smul_mul_assoc,\n      smul_mul_assoc, mul_assoc]\n  conv_rhs =>\n    rhs\n    rw [superCommuteF_ofCrAnListF_ofFieldOpFsList, mul_sub, smul_mul_assoc]\n  simp only [instCommGroup, Algebra.smul_mul_assoc, List.singleton_append, Algebra.mul_smul_comm,\n    sub_add_sub_cancel, sub_right_inj]\n  rw [ofFieldOpListF_cons, mul_assoc, smul_smul, FieldStatistic.ofList_cons_eq_mul]\n  simp [mul_comm]\n\n/--\nFor a field specification `\ud835\udcd5`, and two lists `\u03c6s = \u03c6\u2080\u2026\u03c6\u2099` and `\u03c6s'` of `\ud835\udcd5.CrAnFieldOp`\nthe following super commutation relation holds:\n\n`[\u03c6s', \u03c6\u2080\u2026\u03c6\u2099]\u209bca = \u2211 i, \ud835\udce2(\u03c6s', \u03c6\u2080\u2026\u03c6\u1d62\u208b\u2081) \u2022 \u03c6\u2080\u2026\u03c6\u1d62\u208b\u2081 * [\u03c6s', \u03c6\u1d62]\u209bca * \u03c6\u1d62\u208a\u2081 \u2026 \u03c6\u2099`\n\nThe proof of this relation is via induction on the length of `\u03c6s`.\n-/\nlemma superCommuteF_ofCrAnListF_ofCrAnListF_eq_sum (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    (\u03c6s' : List \ud835\udcd5.CrAnFieldOp) \u2192 [ofCrAnListF \u03c6s, ofCrAnListF \u03c6s']\u209bca =\n    \u2211 (n : Fin \u03c6s'.length), \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s'.take n) \u2022\n    ofCrAnListF (\u03c6s'.take n) * [ofCrAnListF \u03c6s, ofCrAnOpF (\u03c6s'.get n)]\u209bca *\n    ofCrAnListF (\u03c6s'.drop (n + 1))\n  | [] => by\n    simp [\u2190 ofCrAnListF_nil, superCommuteF_ofCrAnListF_ofCrAnListF]\n  | \u03c6 :: \u03c6s' => by\n    rw [superCommuteF_ofCrAnListF_ofCrAnListF_cons,\n      superCommuteF_ofCrAnListF_ofCrAnListF_eq_sum \u03c6s \u03c6s']\n    conv_rhs => erw [Fin.sum_univ_succ]\n    congr 1\n    \u00b7 simp\n    \u00b7 simp [Finset.mul_sum, smul_smul, ofCrAnListF_cons, mul_assoc,\n        FieldStatistic.ofList_cons_eq_mul, mul_comm]\n\nlemma superCommuteF_ofCrAnListF_ofFieldOpListF_eq_sum (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    (\u03c6s' : List \ud835\udcd5.FieldOp) \u2192\n    [ofCrAnListF \u03c6s, ofFieldOpListF \u03c6s']\u209bca =\n    \u2211 (n : Fin \u03c6s'.length), \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s'.take n) \u2022\n      ofFieldOpListF (\u03c6s'.take n) * [ofCrAnListF \u03c6s, ofFieldOpF (\u03c6s'.get n)]\u209bca *\n      ofFieldOpListF (\u03c6s'.drop (n + 1))\n  | [] => by\n    simp only [superCommuteF_ofCrAnListF_ofFieldOpFsList, instCommGroup, ofList_empty,\n      exchangeSign_bosonic, one_smul, List.length_nil, Finset.univ_eq_empty, List.take_nil,\n      List.get_eq_getElem, List.drop_nil, Finset.sum_empty]\n    simp\n  | \u03c6 :: \u03c6s' => by\n    rw [superCommuteF_ofCrAnListF_ofFieldOpListF_cons,\n      superCommuteF_ofCrAnListF_ofFieldOpListF_eq_sum \u03c6s \u03c6s']\n    conv_rhs => erw [Fin.sum_univ_succ]\n    congr 1\n    \u00b7 simp\n    \u00b7 simp [Finset.mul_sum, smul_smul, ofFieldOpListF_cons, mul_assoc,\n        FieldStatistic.ofList_cons_eq_mul, mul_comm]\n\n", "theoremStatement": "lemma summerCommute_jacobi_ofCrAnListF (\u03c6s1 \u03c6s2 \u03c6s3 : List \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnListF \u03c6s1, [ofCrAnListF \u03c6s2, ofCrAnListF \u03c6s3]\u209bca]\u209bca =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s1, \ud835\udcd5 |>\u209b \u03c6s3) \u2022\n    (- \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s2, \ud835\udcd5 |>\u209b \u03c6s3) \u2022 [ofCrAnListF \u03c6s3, [ofCrAnListF \u03c6s1, ofCrAnListF \u03c6s2]\u209bca]\u209bca -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s1, \ud835\udcd5 |>\u209b \u03c6s2) \u2022 [ofCrAnListF \u03c6s2, [ofCrAnListF \u03c6s3, ofCrAnListF \u03c6s1]\u209bca]\u209bca) ", "theoremName": "FieldSpecification.FieldOpFreeAlgebra.summerCommute_jacobi_ofCrAnListF", "fileCreated": {"commit": "ea6e12829370d9630a7e65200c8349e9086c05ba", "date": "2025-02-03"}, "theoremCreated": {"commit": "171e80fc04016aed422340742f3e0a14de6d20b0", "date": "2025-02-03"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpFreeAlgebra/SuperCommute.lean", "module": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.SuperCommute", "jsonFile": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.SuperCommute.jsonl", "positionMetadata": {"lineInFile": 452, "tokenPositionInFile": 20098, "theoremPositionInFile": 30}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 20, "numPremises": 184}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  repeat rw [superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp only [instCommGroup, map_sub, map_smul, neg_smul]\n  repeat rw [superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp only [instCommGroup.eq_1, ofList_append_eq_mul, List.append_assoc]\n  by_cases h1 : (\ud835\udcd5 |>\u209b \u03c6s1) = bosonic <;>\n    by_cases h2 : (\ud835\udcd5 |>\u209b \u03c6s2) = bosonic <;>\n    by_cases h3 : (\ud835\udcd5 |>\u209b \u03c6s3) = bosonic\n  \u00b7 simp only [h1, h2, h3, mul_self, bosonic_exchangeSign, one_smul, exchangeSign_bosonic, neg_sub]\n    abel\n  \u00b7 simp only [h1, h2, bosonic_exchangeSign, one_smul, mul_bosonic, mul_self, map_one,\n    exchangeSign_bosonic, neg_sub]\n    abel\n  \u00b7 simp only [h1, h3, mul_bosonic, bosonic_exchangeSign, one_smul, exchangeSign_bosonic, neg_sub,\n    mul_self, map_one]\n    abel\n  \u00b7 simp only [neq_bosonic_iff_eq_fermionic] at h1 h2 h3\n    simp only [h1, h2, h3, mul_self, bosonic_exchangeSign, one_smul,\n      fermionic_exchangeSign_fermionic, neg_smul, neg_sub, bosonic_mul_fermionic, sub_neg_eq_add,\n      mul_bosonic, smul_add, exchangeSign_bosonic]\n    abel\n  \u00b7 simp only [neq_bosonic_iff_eq_fermionic] at h1 h2 h3\n    simp only [h1, h2, h3, mul_self, map_one, one_smul, exchangeSign_bosonic, mul_bosonic,\n      bosonic_exchangeSign, bosonic_mul_fermionic, neg_sub]\n    abel\n  \u00b7 simp only [neq_bosonic_iff_eq_fermionic] at h1 h2 h3\n    simp only [h1, h2, h3, bosonic_mul_fermionic, fermionic_exchangeSign_fermionic, neg_smul,\n      one_smul, sub_neg_eq_add, bosonic_exchangeSign, mul_bosonic, smul_add, exchangeSign_bosonic,\n      neg_sub, mul_self]\n    abel\n  \u00b7 simp only [neq_bosonic_iff_eq_fermionic] at h1 h2 h3\n    simp only [h1, h2, h3, mul_bosonic, fermionic_exchangeSign_fermionic, neg_smul, one_smul,\n      sub_neg_eq_add, exchangeSign_bosonic, bosonic_mul_fermionic, smul_add, mul_self,\n      bosonic_exchangeSign, neg_sub]\n    abel\n  \u00b7 simp only [neq_bosonic_iff_eq_fermionic] at h1 h2 h3\n    simp only [h1, h2, h3, mul_self, map_one, one_smul, fermionic_exchangeSign_fermionic, neg_smul,\n      neg_sub]\n    abel", "proofType": "tactic", "proofLengthLines": 38, "proofLengthTokens": 1987}}
{"srcContext": "/-\nCopyright (c) 2024 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport Mathlib.LinearAlgebra.PiTensorProduct\nimport Mathlib.Tactic.Polyrith\nimport Mathlib.Tactic.Linarith\nimport Mathlib.Data.Nat.Factorial.DoubleFactorial\n/-!\n# Fin involutions\n\nSome properties of involutions of `Fin n`.\n\nThese involutions are used in e.g. proving results about Wick contractions.\n\n-/\nnamespace HepLean.Fin\n\nopen Nat\n\n/-- There is an equivalence between involutions of `Fin n.succ` and involutions of\n  `Fin n` and an optional valid choice of an element in `Fin n` (which is where `0`\n    in `Fin n.succ` will be sent). -/\ndef involutionCons (n : \u2115) : {f : Fin n.succ \u2192 Fin n.succ // Function.Involutive f } \u2243\n    (f : {f : Fin n \u2192 Fin n // Function.Involutive f}) \u00d7 {i : Option (Fin n) //\n      \u2200 (h : i.isSome), f.1 (Option.get i h) = (Option.get i h)} where\n  toFun f := \u27e8\u27e8\n    fun i =>\n    if h : f.1 i.succ = 0 then i\n    else Fin.pred (f.1 i.succ) h, by\n    intro i\n    by_cases h : f.1 i.succ = 0\n    \u00b7 simp [h]\n    \u00b7 simp only [succ_eq_add_one, h, \u2193reduceDIte, Fin.succ_pred]\n      simp only [f.2 i.succ, Fin.pred_succ, dite_eq_ite, ite_eq_right_iff]\n      intro h\n      exact False.elim (Fin.succ_ne_zero i h)\u27e9,\n    \u27e8if h : f.1 0 = 0 then none else Fin.pred (f.1 0) h, by\n    by_cases h0 : f.1 0 = 0\n    \u00b7 simp [h0]\n    \u00b7 simp only [succ_eq_add_one, h0, \u2193reduceDIte, Option.isSome_some, Option.get_some,\n      Fin.succ_pred, dite_eq_left_iff, Fin.pred_inj, forall_const]\n      refine fun h => False.elim (h (f.2 0))\u27e9\u27e9\n  invFun f := \u27e8\n      if h : (f.2.1).isSome then\n        Fin.cons (f.2.1.get h).succ (Function.update (Fin.succ \u2218 f.1.1) (f.2.1.get h) 0)\n      else\n        Fin.cons 0 (Fin.succ \u2218 f.1.1), by\n    by_cases hs : (f.2.1).isSome\n    \u00b7 simp only [Nat.succ_eq_add_one, hs, \u2193reduceDIte, Fin.coe_eq_castSucc]\n      let a := f.2.1.get hs\n      change Function.Involutive (Fin.cons a.succ (Function.update (Fin.succ \u2218 \u2191f.fst) a 0))\n      intro i\n      rcases Fin.eq_zero_or_eq_succ i with hi | \u27e8j, hj\u27e9\n      \u00b7 subst hi\n        rw [Fin.cons_zero, Fin.cons_succ]\n        simp\n      \u00b7 subst hj\n        rw [Fin.cons_succ]\n        by_cases hja : j = a\n        \u00b7 subst hja\n          simp\n        \u00b7 rw [Function.update_apply]\n          rw [if_neg hja]\n          simp only [Function.comp_apply, Fin.cons_succ]\n          have hf2 := f.2.2 hs\n          change f.1.1 a = a at hf2\n          have hjf1 : f.1.1 j \u2260 a := by\n            by_contra hn\n            have haj : j = f.1.1 a := by\n              rw [\u2190 hn]\n              rw [f.1.2]\n            rw [hf2] at haj\n            exact hja haj\n          rw [Function.update_apply, if_neg hjf1]\n          simp only [Function.comp_apply, Fin.succ_inj]\n          rw [f.1.2]\n    \u00b7 simp only [succ_eq_add_one, hs, Bool.false_eq_true, \u2193reduceDIte]\n      intro i\n      rcases Fin.eq_zero_or_eq_succ i with hi | \u27e8j, hj\u27e9\n      \u00b7 subst hi\n        simp\n      \u00b7 subst hj\n        simp only [Fin.cons_succ, Function.comp_apply, Fin.succ_inj]\n        rw [f.1.2]\u27e9\n  left_inv f := by\n    match f with\n    | \u27e8f, hf\u27e9 =>\n    simp only [succ_eq_add_one, Option.isSome_dite', Option.get_dite', Fin.succ_pred,\n      Fin.cons_update, dite_eq_ite, ite_not, Subtype.mk.injEq]\n    ext i\n    by_cases h0 : f 0 = 0\n    \u00b7 simp only [h0, \u2193reduceIte]\n      rcases Fin.eq_zero_or_eq_succ i with hi | \u27e8j, hj\u27e9\n      \u00b7 subst hi\n        simp [h0]\n      \u00b7 subst hj\n        simp only [Fin.cons_succ, Function.comp_apply, Fin.val_succ]\n        by_cases hj : f j.succ =0\n        \u00b7 rw [\u2190 h0] at hj\n          have hn := Function.Involutive.injective hf hj\n          exact False.elim (Fin.succ_ne_zero j hn)\n        \u00b7 simp only [hj, \u2193reduceDIte, Fin.coe_pred]\n          rw [Fin.ext_iff] at hj\n          simp only [succ_eq_add_one, Fin.val_zero] at hj\n          omega\n    \u00b7 rw [if_neg h0]\n      by_cases hf' : i = f 0\n      \u00b7 subst hf'\n        simp only [Function.update_self, Fin.val_zero]\n        rw [hf]\n        simp\n      \u00b7 rw [Function.update_apply, if_neg hf']\n        rcases Fin.eq_zero_or_eq_succ i with hi | \u27e8j, hj\u27e9\n        \u00b7 subst hi\n          simp\n        \u00b7 subst hj\n          simp only [Fin.cons_succ, Function.comp_apply, Fin.val_succ]\n          by_cases hj : f j.succ =0\n          \u00b7 rw [\u2190 hj] at hf'\n            rw [hf] at hf'\n            simp only [not_true_eq_false] at hf'\n          \u00b7 simp only [hj, \u2193reduceDIte, Fin.coe_pred]\n            rw [Fin.ext_iff] at hj\n            simp only [succ_eq_add_one, Fin.val_zero] at hj\n            omega\n  right_inv f := by\n    match f with\n    | \u27e8\u27e8f, hf\u27e9, \u27e8f0, hf0\u27e9\u27e9 =>\n    ext i\n    \u00b7 simp only [succ_eq_add_one, Fin.cons_update]\n      by_cases hs : f0.isSome\n      \u00b7 simp only [hs, \u2193reduceDIte]\n        by_cases hi : i = f0.get hs\n        \u00b7 simp only [Function.update_apply, hi, \u2193reduceIte, \u2193reduceDIte]\n          exact Eq.symm (Fin.val_eq_of_eq (hf0 hs))\n        \u00b7 simp only [ne_eq, Fin.succ_inj, hi, not_false_eq_true, Function.update_of_ne,\n          Fin.cons_succ, Function.comp_apply, Fin.pred_succ, dite_eq_ite]\n          split\n          \u00b7 rename_i h\n            exact False.elim (Fin.succ_ne_zero (f i) h)\n          \u00b7 rfl\n      \u00b7 simp only [hs, Bool.false_eq_true, \u2193reduceDIte, Fin.cons_succ, Function.comp_apply,\n        Fin.pred_succ, dite_eq_ite]\n        split\n        \u00b7 rename_i h\n          exact False.elim (Fin.succ_ne_zero (f i) h)\n        \u00b7 rfl\n    \u00b7 simp only [Nat.succ_eq_add_one, Option.mem_def,\n      Option.dite_none_left_eq_some, Option.some.injEq]\n      by_cases hs : f0.isSome\n      \u00b7 simp only [hs, \u2193reduceDIte]\n        simp only [Fin.cons_zero, Fin.pred_succ, exists_prop]\n        have hx : \u00ac (f0.get hs).succ = 0 := (Fin.succ_ne_zero (f0.get hs))\n        simp only [hx, not_false_eq_true, true_and]\n        refine Iff.intro (fun hi => ?_) (fun hi => ?_)\n        \u00b7 rw [\u2190 hi]\n          exact\n            Option.eq_some_of_isSome\n              (Eq.mpr_prop (Eq.refl (f0.isSome = true))\n                (of_eq_true (Eq.trans (congrArg (fun x => x = true) hs) (eq_self true))))\n        \u00b7 subst hi\n          exact rfl\n      \u00b7 simp only [hs, Bool.false_eq_true, \u2193reduceDIte, Fin.cons_zero, not_true_eq_false,\n        IsEmpty.exists_iff, false_iff]\n        simp only [Bool.not_eq_true, Option.not_isSome, Option.isNone_iff_eq_none] at hs\n        subst hs\n        exact ne_of_beq_false rfl\n\nlemma involutionCons_ext {n : \u2115} {f1 f2 : (f : {f : Fin n \u2192 Fin n // Function.Involutive f}) \u00d7\n    {i : Option (Fin n) // \u2200 (h : i.isSome), f.1 (Option.get i h) = (Option.get i h)}}\n    (h1 : f1.1 = f2.1) (h2 : f1.2 = Equiv.subtypeEquivRight (by rw [h1]; simp) f2.2) : f1 = f2 := by\n  cases f1\n  cases f2\n  simp only at h1 h2\n  subst h1\n  rename_i fst snd snd_1\n  simp_all only [Sigma.mk.inj_iff, heq_eq_eq, true_and]\n  obtain \u27e8val, property\u27e9 := fst\n  obtain \u27e8val_1, property_1\u27e9 := snd\n  obtain \u27e8val_2, property_2\u27e9 := snd_1\n  simp_all only\n  rfl\n\n/-- Given an involution of `Fin n`, the optional choice of an element in `Fin n` which\n  maps to itself is equivalent to the optional choice of an element in\n  `Fin (Finset.univ.filter fun i => f.1 i = i).card`. -/\ndef involutionAddEquiv {n : \u2115} (f : {f : Fin n \u2192 Fin n // Function.Involutive f}) :\n    {i : Option (Fin n) // \u2200 (h : i.isSome), f.1 (Option.get i h) = (Option.get i h)} \u2243\n    Option (Fin (Finset.univ.filter fun i => f.1 i = i).card) := by\n  let e1 : {i : Option (Fin n) // \u2200 (h : i.isSome), f.1 (Option.get i h) = (Option.get i h)}\n        \u2243 Option {i : Fin n // f.1 i = i} :=\n    { toFun := fun i => match i with\n        | \u27e8some i, h\u27e9 => some \u27e8i, by simpa using h\u27e9\n        | \u27e8none, h\u27e9 => none\n      invFun := fun i => match i with\n        | some \u27e8i, h\u27e9 => \u27e8some i, by simpa using h\u27e9\n        | none => \u27e8none, by simp\u27e9\n      left_inv := by\n        intro a\n        cases a\n        aesop\n      right_inv := by\n        intro a\n        cases a\n        rfl\n        simp_all only [Subtype.coe_eta] }\n  let s : Finset (Fin n) := Finset.univ.filter fun i => f.1 i = i\n  let e2' : { i : Fin n // f.1 i = i} \u2243 {i // i \u2208 s} := by\n    apply Equiv.subtypeEquivProp\n    simp [s]\n  let e2 : {i // i \u2208 s} \u2243 Fin (Finset.card s) := by\n    refine (Finset.orderIsoOfFin _ ?_).symm.toEquiv\n    simp [s]\n  refine e1.trans (Equiv.optionCongr (e2'.trans (e2)))\n\nlemma involutionAddEquiv_none_image_zero {n : \u2115} :\n    {f : {f : Fin n.succ \u2192 Fin n.succ // Function.Involutive f}}\n    \u2192 involutionAddEquiv (involutionCons n f).1 (involutionCons n f).2 = none\n    \u2192 f.1 \u27e80, Nat.zero_lt_succ n\u27e9 = \u27e80, Nat.zero_lt_succ n\u27e9 := by\n  intro f h\n  simp only [Nat.succ_eq_add_one, involutionCons, Equiv.coe_fn_mk, involutionAddEquiv,\n    Option.isSome_some, Option.get_some, Option.isSome_none, Equiv.trans_apply,\n    Equiv.optionCongr_apply, Equiv.coe_trans, RelIso.coe_fn_toEquiv, Option.map_eq_none'] at h\n  simp_all only [List.length_cons, Fin.zero_eta]\n  obtain \u27e8val, property\u27e9 := f\n  simp_all only [List.length_cons]\n  split at h\n  next i i_1 h_1 heq =>\n    split at heq\n    next h_2 => simp_all only [reduceCtorEq]\n    next h_2 => simp_all only [reduceCtorEq]\n  next i h_1 heq =>\n    split at heq\n    next h_2 => simp_all only\n    next h_2 => simp_all only [Subtype.mk.injEq, reduceCtorEq]\n\nlemma involutionAddEquiv_cast {n : \u2115} {f1 f2 : {f : Fin n \u2192 Fin n // Function.Involutive f}}\n    (hf : f1 = f2) :\n    involutionAddEquiv f1 = (Equiv.subtypeEquivRight (by rw [hf]; simp)).trans\n      ((involutionAddEquiv f2).trans (Equiv.optionCongr (finCongr (by rw [hf])))) := by\n  subst hf\n  rw [finCongr_refl, Equiv.optionCongr_refl]\n  rfl\n\nlemma involutionAddEquiv_cast' {m : \u2115} {f1 f2 : {f : Fin m \u2192 Fin m // Function.Involutive f}}\n    {N : \u2115} (hf : f1 = f2) (n : Option (Fin N))\n    (hn1 : N = (Finset.filter (fun i => f1.1 i = i) Finset.univ).card)\n    (hn2 : N = (Finset.filter (fun i => f2.1 i = i) Finset.univ).card) :\n    HEq ((involutionAddEquiv f1).symm (Option.map (finCongr hn1) n))\n    ((involutionAddEquiv f2).symm (Option.map (finCongr hn2) n)) := by\n  subst hf\n  rfl\n\nlemma involutionAddEquiv_none_succ {n : \u2115}\n    {f : {f : Fin n.succ \u2192 Fin n.succ // Function.Involutive f}}\n    (h : involutionAddEquiv (involutionCons n f).1 (involutionCons n f).2 = none)\n    (x : Fin n) : f.1 x.succ = x.succ \u2194 (involutionCons n f).1.1 x = x := by\n  simp only [succ_eq_add_one, involutionCons, Fin.cons_update, Equiv.coe_fn_mk, dite_eq_left_iff]\n  have hx : \u00ac f.1 x.succ = \u27e80, Nat.zero_lt_succ n\u27e9:=\n    involutionAddEquiv_none_image_zero h \u25b8\n      fun hn => Fin.succ_ne_zero x (Function.Involutive.injective f.2 hn)\n  exact Iff.intro (fun h2 \u21a6 by simp [h2]) (fun h2 \u21a6 (Fin.pred_eq_iff_eq_succ hx).mp (h2 hx))\n\nlemma involutionAddEquiv_isSome_image_zero {n : \u2115} :\n    {f : {f : Fin n.succ \u2192 Fin n.succ // Function.Involutive f}}\n    \u2192 (involutionAddEquiv (involutionCons n f).1 (involutionCons n f).2).isSome\n    \u2192 \u00ac f.1 \u27e80, Nat.zero_lt_succ n\u27e9 = \u27e80, Nat.zero_lt_succ n\u27e9 := by\n  intro f hf a\n  simp only [succ_eq_add_one, involutionCons, Equiv.coe_fn_mk, involutionAddEquiv] at hf\n  simp_all\n\n/-!\n\n## Equivalences of involutions with no fixed points.\n\nThe main aim of these equivalences is to define `involutionNoFixedZeroEquivProd`.\n\n-/\n\n/-- Fixed point free involutions of `Fin n.succ` can be separated based on where they sent\n  `0`. -/\ndef involutionNoFixedEquivSum {n : \u2115} :\n    {f : Fin n.succ \u2192 Fin n.succ // Function.Involutive f\n    \u2227 \u2200 i, f i \u2260 i} \u2243 \u03a3 (k : Fin n), {f : Fin n.succ \u2192 Fin n.succ // Function.Involutive f\n    \u2227 (\u2200 i, f i \u2260 i) \u2227 f 0 = k.succ} where\n  toFun f := \u27e8(f.1 0).pred (f.2.2 0), \u27e8f.1, f.2.1, by simpa using f.2.2\u27e9\u27e9\n  invFun f := \u27e8f.2.1, \u27e8f.2.2.1, f.2.2.2.1\u27e9\u27e9\n  left_inv f := rfl\n  right_inv f := by\n    ext\n    \u00b7 simp [f.2.2.2.2]\n    \u00b7 rfl\n\n/-- The condition on fixed point free involutions of `Fin n.succ` for a fixed value of `f 0`,\n  can be modified by conjugation with an equivalence. -/\ndef involutionNoFixedZeroSetEquivEquiv {n : \u2115}\n    (k : Fin n) (e : Fin n.succ \u2243 Fin n.succ) :\n    {f : Fin n.succ \u2192 Fin n.succ // Function.Involutive f \u2227 (\u2200 i, f i \u2260 i) \u2227 f 0 = k.succ} \u2243\n    {f : Fin n.succ \u2192 Fin n.succ // Function.Involutive (e.symm \u2218 f \u2218 e) \u2227\n      (\u2200 i, (e.symm \u2218 f \u2218 e) i \u2260 i) \u2227 (e.symm \u2218 f \u2218 e) 0 = k.succ} where\n  toFun f := \u27e8e \u2218 f.1 \u2218 e.symm, by\n    intro i\n    simp only [succ_eq_add_one, ne_eq, Function.comp_apply, Equiv.symm_apply_apply]\n    rw [f.2.1], by\n      simpa using f.2.2.1, by simpa using f.2.2.2\u27e9\n  invFun f := \u27e8e.symm \u2218 f.1 \u2218 e, by\n    intro i\n    simp only [succ_eq_add_one, Function.comp_apply, ne_eq, Equiv.apply_symm_apply]\n    have hf2 := f.2.1 i\n    simpa using hf2, by simpa using f.2.2.1, by simpa using f.2.2.2\u27e9\n  left_inv f := by\n    ext i\n    simp\n  right_inv f := by\n    ext i\n    simp\n\n/-- The condition on fixed point free involutions of `Fin n.succ` for a fixed value of `f 0`\n  given an equivalence `e`,\n  can be modified so that only the condition on `f 0` is up-to the equivalence `e`. -/\ndef involutionNoFixedZeroSetEquivSetEquiv {n : \u2115} (k : Fin n)\n    (e : Fin n.succ \u2243 Fin n.succ) :\n    {f : Fin n.succ \u2192 Fin n.succ // Function.Involutive (e.symm \u2218 f \u2218 e) \u2227\n    (\u2200 i, (e.symm \u2218 f \u2218 e) i \u2260 i) \u2227 (e.symm \u2218 f \u2218 e) 0 = k.succ} \u2243\n    {f : Fin n.succ \u2192 Fin n.succ // Function.Involutive f \u2227\n      (\u2200 i, f i \u2260 i) \u2227 (e.symm \u2218 f \u2218 e) 0 = k.succ} := by\n  refine Equiv.subtypeEquivRight ?_\n  intro f\n  have h1 : Function.Involutive (\u21d1e.symm \u2218 f \u2218 \u21d1e) \u2194 Function.Involutive f := by\n    apply Iff.intro\n    \u00b7 intro h i\n      have hi := h (e.symm i)\n      simpa using hi\n    \u00b7 intro h i\n      have hi := h (e i)\n      simp [hi]\n  rw [h1]\n  simp only [succ_eq_add_one, Function.comp_apply, ne_eq, and_congr_right_iff, and_congr_left_iff]\n  intro h1 h2\n  apply Iff.intro\n  \u00b7 intro h i\n    have hi := h (e.symm i)\n    simpa using hi\n  \u00b7 intro h i\n    have hi := h (e i)\n    by_contra hn\n    nth_rewrite 2 [\u2190 hn] at hi\n    simp at hi\n\n/-- Fixed point free involutions of `Fin n.succ` fixing `(e.symm \u2218 f \u2218 e) = k.succ` for a given `e`\n  are equivalent to fixing `f (e 0) = e k.succ`. -/\ndef involutionNoFixedZeroSetEquivEquiv' {n : \u2115} (k : Fin n) (e : Fin n.succ \u2243 Fin n.succ) :\n    {f : Fin n.succ \u2192 Fin n.succ // Function.Involutive f \u2227\n    (\u2200 i, f i \u2260 i) \u2227 (e.symm \u2218 f \u2218 e) 0 = k.succ} \u2243\n    {f : Fin n.succ \u2192 Fin n.succ // Function.Involutive f \u2227\n    (\u2200 i, f i \u2260 i) \u2227 f (e 0) = e k.succ} := by\n  refine Equiv.subtypeEquivRight ?_\n  simp only [succ_eq_add_one, ne_eq, Function.comp_apply, and_congr_right_iff]\n  intro f hi h1\n  exact Equiv.symm_apply_eq e\n\n/-- Fixed point involutions of `Fin n.succ.succ` with `f 0 = k.succ` are equivalent\n  to fixed point involutions with `f 0 = 1`. -/\ndef involutionNoFixedZeroSetEquivSetOne {n : \u2115} (k : Fin n.succ) :\n    {f : Fin n.succ.succ \u2192 Fin n.succ.succ // Function.Involutive f \u2227\n      (\u2200 i, f i \u2260 i) \u2227 f 0 = k.succ}\n      \u2243 {f : Fin n.succ.succ \u2192 Fin n.succ.succ // Function.Involutive f \u2227\n      (\u2200 i, f i \u2260 i) \u2227 f 0 = 1} := by\n  refine Equiv.trans (involutionNoFixedZeroSetEquivEquiv k (Equiv.swap k.succ 1)) ?_\n  refine Equiv.trans (involutionNoFixedZeroSetEquivSetEquiv k (Equiv.swap k.succ 1)) ?_\n  refine Equiv.trans (involutionNoFixedZeroSetEquivEquiv' k (Equiv.swap k.succ 1)) ?_\n  refine Equiv.subtypeEquivRight ?_\n  simp only [succ_eq_add_one, ne_eq, Equiv.swap_apply_left, and_congr_right_iff]\n  intro f hi h1\n  rw [Equiv.swap_apply_of_ne_of_ne]\n  \u00b7 exact Ne.symm (Fin.succ_ne_zero k)\n  \u00b7 exact Fin.zero_ne_one\n\n/-- Fixed point involutions of `Fin n.succ.succ` fixing `f 0 = 1` are equivalent to\n  fixed point involutions of `Fin n`. -/\ndef involutionNoFixedSetOne {n : \u2115} :\n    {f : Fin n.succ.succ \u2192 Fin n.succ.succ // Function.Involutive f \u2227\n    (\u2200 i, f i \u2260 i) \u2227 f 0 = 1} \u2243 {f : Fin n \u2192 Fin n // Function.Involutive f \u2227\n    (\u2200 i, f i \u2260 i)} where\n  toFun f := by\n    have hf1 : f.1 1 = 0 := by\n      have hf := f.2.2.2\n      simp only [succ_eq_add_one, ne_eq, \u2190 hf]\n      rw [f.2.1]\n    let f' := f.1 \u2218 Fin.succ \u2218 Fin.succ\n    have hf' (i : Fin n) : f' i \u2260 0 := by\n      simp only [succ_eq_add_one, mul_eq, ne_eq, Function.comp_apply, f']\n      simp only [\u2190 hf1, succ_eq_add_one, ne_eq]\n      by_contra hn\n      have hn' := Function.Involutive.injective f.2.1 hn\n      simp [Fin.ext_iff] at hn'\n    let f'' := fun i => (f' i).pred (hf' i)\n    have hf'' (i : Fin n) : f'' i \u2260 0 := by\n      simp only [mul_eq, ne_eq, f'']\n      rw [@Fin.pred_eq_iff_eq_succ]\n      simp only [mul_eq, succ_eq_add_one, ne_eq, Function.comp_apply, Fin.succ_zero_eq_one, f']\n      simp only [\u2190 f.2.2.2, succ_eq_add_one, ne_eq]\n      by_contra hn\n      have hn' := Function.Involutive.injective f.2.1 hn\n      simp [Fin.ext_iff] at hn'\n    let f''' := fun i => (f'' i).pred (hf'' i)\n    refine \u27e8f''', ?_, ?_\u27e9\n    \u00b7 intro i\n      simp only [mul_eq, succ_eq_add_one, ne_eq, Function.comp_apply, Fin.succ_pred, f''', f'', f']\n      simp [f.2.1 i.succ.succ]\n    \u00b7 intro i\n      simp only [mul_eq, succ_eq_add_one, ne_eq, Function.comp_apply, f''', f'', f']\n      rw [Fin.pred_eq_iff_eq_succ, Fin.pred_eq_iff_eq_succ]\n      exact f.2.2.1 i.succ.succ\n  invFun f := by\n    let f' := fun (i : Fin n.succ.succ)=>\n      match i with\n      | \u27e80, h\u27e9 => 1\n      | \u27e81, h\u27e9 => 0\n      | \u27e8(Nat.succ (Nat.succ n)), h\u27e9 => (f.1 \u27e8n, by omega\u27e9).succ.succ\n    refine \u27e8f', ?_, ?_, ?_\u27e9\n    \u00b7 intro i\n      match i with\n      | \u27e80, h\u27e9 => rfl\n      | \u27e81, h\u27e9 => rfl\n      | \u27e8(Nat.succ (Nat.succ m)), h\u27e9 =>\n        simp only [succ_eq_add_one, ne_eq, f']\n        split\n        \u00b7 rename_i h\n          simp only [succ_eq_add_one, Fin.zero_eta] at h\n          exact False.elim (Fin.succ_ne_zero (f.1 \u27e8m, _\u27e9).succ h)\n        \u00b7 rename_i h\n          simp [Fin.ext_iff] at h\n        \u00b7 rename_i h\n          rename_i x r\n          simp_all only [succ_eq_add_one, Fin.ext_iff, Fin.val_succ, add_left_inj]\n          have hfn {a b : \u2115} {ha : a < n} {hb : b < n}\n            (hab : \u2191(f.1 \u27e8a, ha\u27e9) = b) : \u2191(f.1 \u27e8b, hb\u27e9) = a := by\n            have ht : f.1 \u27e8a, ha\u27e9 = \u27e8b, hb\u27e9 := by\n              simp [hab, Fin.ext_iff]\n            rw [\u2190 ht, f.2.1]\n          exact hfn h\n    \u00b7 intro i\n      match i with\n      | \u27e80, h\u27e9 =>\n        simp only [succ_eq_add_one, ne_eq, Fin.zero_eta, f']\n        split\n        \u00b7 rename_i h\n          simp\n        \u00b7 rename_i h\n          simp [Fin.ext_iff] at h\n        \u00b7 rename_i h\n          simp [Fin.ext_iff] at h\n      | \u27e81, h\u27e9 =>\n        simp only [succ_eq_add_one, ne_eq, Fin.mk_one, f']\n        split\n        \u00b7 rename_i h\n          simp at h\n        \u00b7 rename_i h\n          simp\n        \u00b7 rename_i h\n          simp [Fin.ext_iff] at h\n      | \u27e8(Nat.succ (Nat.succ m)), h\u27e9 =>\n        simp only [succ_eq_add_one, ne_eq, Fin.ext_iff, Fin.val_succ, add_left_inj, f']\n        have hf:= f.2.2 \u27e8m, Nat.add_lt_add_iff_right.mp h\u27e9\n        simp only [ne_eq, Fin.ext_iff] at hf\n        omega\n    \u00b7 simp only [succ_eq_add_one, ne_eq, f']\n      split\n      \u00b7 rename_i h\n        simp\n      \u00b7 rename_i h\n        simp at h\n      \u00b7 rename_i h\n        simp [Fin.ext_iff] at h\n  left_inv f := by\n    have hf1 : f.1 1 = 0 := by\n      have hf := f.2.2.2\n      simp only [succ_eq_add_one, ne_eq, \u2190 hf]\n      rw [f.2.1]\n    simp only [succ_eq_add_one, ne_eq, mul_eq, Function.comp_apply, Fin.succ_mk, Fin.succ_pred]\n    ext i\n    simp only\n    split\n    \u00b7 simp [Fin.val_one, succ_eq_add_one, Fin.zero_eta, f.2.2.2]\n    \u00b7 exact congrArg Fin.val (id (Eq.symm hf1))\n    \u00b7 exact rfl\n  right_inv f := by\n    simp only [ne_eq, mul_eq, succ_eq_add_one, Function.comp_apply]\n    ext i\n    simp only [Fin.coe_pred]\n    split\n    \u00b7 rename_i h\n      simp [Fin.ext_iff] at h\n    \u00b7 rename_i h\n      simp [Fin.ext_iff] at h\n    \u00b7 simp only [Fin.val_succ, add_tsub_cancel_right]\n      congr\n      apply congrArg\n      simp_all [Fin.ext_iff]\n\n/-- Fixed point involutions of `Fin n.succ.succ` for fixed `f 0 = k.succ` are\n  equivalent to fixed point involutions of `Fin n`. -/\ndef involutionNoFixedZeroSetEquiv {n : \u2115} (k : Fin n.succ) :\n    {f : Fin n.succ.succ \u2192 Fin n.succ.succ // Function.Involutive f \u2227\n      (\u2200 i, f i \u2260 i) \u2227 f 0 = k.succ}\n      \u2243 {f : Fin n \u2192 Fin n // Function.Involutive f \u2227 (\u2200 i, f i \u2260 i)} := by\n  refine Equiv.trans (involutionNoFixedZeroSetEquivSetOne k) involutionNoFixedSetOne\n\n/-- The type of fixed point free involutions of `Fin n.succ.succ` is equivalent to the sum\n  of `Fin n.succ` copies of fixed point involutions of `Fin n`. -/\ndef involutionNoFixedEquivSumSame {n : \u2115} :\n    {f : Fin n.succ.succ \u2192 Fin n.succ.succ // Function.Involutive f \u2227 (\u2200 i, f i \u2260 i)}\n    \u2243 \u03a3 (_ : Fin n.succ),\n      {f : Fin n \u2192 Fin n // Function.Involutive f \u2227 (\u2200 i, f i \u2260 i)} := by\n  refine Equiv.trans involutionNoFixedEquivSum ?_\n  refine Equiv.sigmaCongrRight involutionNoFixedZeroSetEquiv\n\n/-- Ever fixed-point free involutions of `Fin n.succ.succ` can be decomposed into a\n  element of `Fin n.succ` (where `0` is sent) and a fixed-point free involution of\n  `Fin n`. -/\ndef involutionNoFixedZeroEquivProd {n : \u2115} :\n    {f : Fin n.succ.succ \u2192 Fin n.succ.succ // Function.Involutive f \u2227 (\u2200 i, f i \u2260 i)}\n    \u2243 Fin n.succ \u00d7\n    {f : Fin n \u2192 Fin n // Function.Involutive f \u2227 (\u2200 i, f i \u2260 i)} := by\n  refine Equiv.trans involutionNoFixedEquivSumSame ?_\n  exact Equiv.sigmaEquivProd (Fin n.succ) { f // Function.Involutive f \u2227 \u2200 (i : Fin n), f i \u2260 i }\n\n/-!\n\n## Cardinality\n\n-/\n\n/-- The type of fixed-point free involutions of `Fin n` is finite. -/\ninstance {n : \u2115} : Fintype { f // Function.Involutive f \u2227 \u2200 (i : Fin n), f i \u2260 i } := by\n  haveI : DecidablePred fun x => Function.Involutive x :=\n    fun f => Fintype.decidableForallFintype (\u03b1 := Fin n)\n  haveI : DecidablePred fun x => Function.Involutive x \u2227 \u2200 (i : Fin n), x i \u2260 i :=\n    fun x => instDecidableAnd\n  apply Subtype.fintype\n\nlemma involutionNoFixed_card_succ {n : \u2115} :\n    Fintype.card\n    {f : Fin n.succ.succ \u2192 Fin n.succ.succ // Function.Involutive f \u2227 (\u2200 i, f i \u2260 i)}\n    = n.succ *\n    Fintype.card {f : Fin n \u2192 Fin n // Function.Involutive f \u2227 (\u2200 i, f i \u2260 i)} := by\n  rw [Fintype.card_congr (involutionNoFixedZeroEquivProd), Fintype.card_prod]\n  congr\n  exact Fintype.card_fin n.succ\n\nlemma involutionNoFixed_card_mul_two : (n : \u2115) \u2192\n    Fintype.card {f : Fin (2 * n) \u2192 Fin (2 * n) // Function.Involutive f \u2227 (\u2200 i, f i \u2260 i)}\n    = (2 * n - 1)\u203c\n  | 0 => rfl\n  | Nat.succ n => by\n    erw [involutionNoFixed_card_succ]\n    erw [involutionNoFixed_card_mul_two n]\n    exact Eq.symm (Nat.doubleFactorial_add_one (Nat.mul 2 n))\n\nlemma involutionNoFixed_card_mul_two_plus_one : (n : \u2115) \u2192\n    Fintype.card {f : Fin (2 * n + 1) \u2192 Fin (2 * n + 1) // Function.Involutive f \u2227 (\u2200 i, f i \u2260 i)}\n    = 0\n  | 0 => rfl\n  | Nat.succ n => by\n    erw [involutionNoFixed_card_succ]\n    erw [involutionNoFixed_card_mul_two_plus_one n]\n    exact rfl\n\nlemma involutionNoFixed_card_even : (n : \u2115) \u2192 (he : Even n) \u2192\n    Fintype.card {f : Fin n \u2192 Fin n // Function.Involutive f \u2227 (\u2200 i, f i \u2260 i)} = (n - 1)\u203c := by\n  intro n he\n  obtain \u27e8r, hr\u27e9 := he\n  have hr' : n = 2 * r := by omega\n  subst hr'\n  exact involutionNoFixed_card_mul_two r\n\n", "theoremStatement": "lemma involutionNoFixed_card_odd : (n : \u2115) \u2192 (ho : Odd n) \u2192\n    Fintype.card {f : Fin n \u2192 Fin n // Function.Involutive f \u2227 (\u2200 i, f i \u2260 i)} = 0 ", "theoremName": "HepLean.Fin.involutionNoFixed_card_odd", "fileCreated": {"commit": "1ab0c6f76904b49d21f9c1e09d26746f52caa4eb", "date": "2025-01-05"}, "theoremCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "file": "HepLean/HepLean/Mathematics/Fin/Involutions.lean", "module": "HepLean.Mathematics.Fin.Involutions", "jsonFile": "HepLean.Mathematics.Fin.Involutions.jsonl", "positionMetadata": {"lineInFile": 580, "tokenPositionInFile": 22820, "theoremPositionInFile": 15}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 33}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  intro n ho\n  obtain \u27e8r, hr\u27e9 := ho\n  subst hr\n  exact involutionNoFixed_card_mul_two_plus_one r", "proofType": "tactic", "proofLengthLines": 4, "proofLengthTokens": 102}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.WickContraction.TimeContract\nimport HepLean.PerturbationTheory.WickContraction.StaticContract\nimport HepLean.PerturbationTheory.FieldOpAlgebra.TimeContraction\n/-!\n\n# Sub contractions\n\n-/\n\nopen FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\nnamespace WickContraction\nvariable {n : \u2115} {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\nopen HepLean.List\nopen FieldOpAlgebra\n\n/-- Given a Wick contraction `\u03c6s\u039b`, and a subset of `\u03c6s\u039b.1`, the Wick contraction\n  consisting of contracted pairs within that subset. -/\ndef subContraction (S : Finset (Finset (Fin \u03c6s.length))) (ha : S \u2286 \u03c6s\u039b.1) :\n    WickContraction \u03c6s.length :=\n  \u27e8S, by\n    intro i hi\n    exact \u03c6s\u039b.2.1 i (ha hi),\n    by\n    intro i hi j hj\n    exact \u03c6s\u039b.2.2 i (ha hi) j (ha hj)\u27e9\n\nlemma mem_of_mem_subContraction {S : Finset (Finset (Fin \u03c6s.length))} {hs : S \u2286 \u03c6s\u039b.1}\n    {a : Finset (Fin \u03c6s.length)} (ha : a \u2208 (\u03c6s\u039b.subContraction S hs).1) : a \u2208 \u03c6s\u039b.1 := by\n  exact hs ha\n\n/-- Given a Wick contraction `\u03c6s\u039b`, and a subset `S` of `\u03c6s\u039b.1`, the Wick contraction\n  on the uncontracted list `[\u03c6s\u039b.subContraction S ha]\u1d58\u1d9c`\n  consisting of the remaining contracted pairs of `\u03c6s\u039b` not in `S`. -/\ndef quotContraction (S : Finset (Finset (Fin \u03c6s.length))) (ha : S \u2286 \u03c6s\u039b.1) :\n    WickContraction [\u03c6s\u039b.subContraction S ha]\u1d58\u1d9c.length :=\n  \u27e8Finset.filter (fun a => Finset.map uncontractedListEmd a \u2208 \u03c6s\u039b.1) Finset.univ,\n  by\n    intro a ha'\n    simp only [Finset.mem_filter, Finset.mem_univ, true_and] at ha'\n    simpa using \u03c6s\u039b.2.1 (Finset.map uncontractedListEmd a) ha', by\n  intro a ha b hb\n  simp only [Finset.mem_filter, Finset.mem_univ, true_and] at ha hb\n  by_cases hab : a = b\n  \u00b7 simp [hab]\n  \u00b7 simp only [hab, false_or]\n    have hx := \u03c6s\u039b.2.2 (Finset.map uncontractedListEmd a) ha (Finset.map uncontractedListEmd b) hb\n    simp_all\u27e9\n\nlemma mem_of_mem_quotContraction {S : Finset (Finset (Fin \u03c6s.length))} {hs : S \u2286 \u03c6s\u039b.1}\n    {a : Finset (Fin [\u03c6s\u039b.subContraction S hs]\u1d58\u1d9c.length)}\n    (ha : a \u2208 (quotContraction S hs).1) : Finset.map uncontractedListEmd a \u2208 \u03c6s\u039b.1 := by\n  simp only [quotContraction, Finset.mem_filter, Finset.mem_univ, true_and] at ha\n  exact ha\n\n", "theoremStatement": "lemma mem_subContraction_or_quotContraction {S : Finset (Finset (Fin \u03c6s.length))} {hs : S \u2286 \u03c6s\u039b.1}\n    {a : Finset (Fin \u03c6s.length)} (ha : a \u2208 \u03c6s\u039b.1) :\n    a \u2208 (\u03c6s\u039b.subContraction S hs).1 \u2228\n    \u2203 a', Finset.map uncontractedListEmd a' = a \u2227 a' \u2208 (quotContraction S hs).1 ", "theoremName": "WickContraction.mem_subContraction_or_quotContraction", "fileCreated": {"commit": "12d36dc1d9c726c035301091e57be0b29015e4ae", "date": "2025-01-31"}, "theoremCreated": {"commit": "12d36dc1d9c726c035301091e57be0b29015e4ae", "date": "2025-01-31"}, "file": "HepLean/HepLean/PerturbationTheory/WickContraction/SubContraction.lean", "module": "HepLean.PerturbationTheory.WickContraction.SubContraction", "jsonFile": "HepLean.PerturbationTheory.WickContraction.SubContraction.jsonl", "positionMetadata": {"lineInFile": 62, "tokenPositionInFile": 2324, "theoremPositionInFile": 4}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 10, "numPremises": 85}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  by_cases h1 : a \u2208 (\u03c6s\u039b.subContraction S hs).1\n  \u00b7 simp [h1]\n  simp only [h1, false_or]\n  simp only [subContraction] at h1\n  have h2 := \u03c6s\u039b.2.1 a ha\n  rw [@Finset.card_eq_two] at h2\n  obtain \u27e8i, j, hij, rfl\u27e9 := h2\n  have hi : i \u2208 (\u03c6s\u039b.subContraction S hs).uncontracted := by\n    rw [mem_uncontracted_iff_not_contracted]\n    intro p hp\n    have hp' : p \u2208 \u03c6s\u039b.1 := hs hp\n    have hp2 := \u03c6s\u039b.2.2 p hp' {i, j} ha\n    simp only [subContraction] at hp\n    rcases hp2 with hp2 | hp2\n    \u00b7 simp_all\n    simp only [Finset.disjoint_insert_right, Finset.disjoint_singleton_right] at hp2\n    exact hp2.1\n  have hj : j \u2208 (\u03c6s\u039b.subContraction S hs).uncontracted := by\n    rw [mem_uncontracted_iff_not_contracted]\n    intro p hp\n    have hp' : p \u2208 \u03c6s\u039b.1 := hs hp\n    have hp2 := \u03c6s\u039b.2.2 p hp' {i, j} ha\n    simp only [subContraction] at hp\n    rcases hp2 with hp2 | hp2\n    \u00b7 simp_all\n    simp only [Finset.disjoint_insert_right, Finset.disjoint_singleton_right] at hp2\n    exact hp2.2\n  obtain \u27e8i, rfl\u27e9 := uncontractedListEmd_surjective_mem_uncontracted i hi\n  obtain \u27e8j, rfl\u27e9 := uncontractedListEmd_surjective_mem_uncontracted j hj\n  use {i, j}\n  simp only [Finset.map_insert, Finset.map_singleton, quotContraction, Finset.mem_filter,\n    Finset.mem_univ, true_and]\n  exact ha", "proofType": "tactic", "proofLengthLines": 33, "proofLengthTokens": 1269}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.WickContraction.ExtractEquiv\n/-!\n\n# List of uncontracted elements of a Wick contraction\n\n-/\n\nopen FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\nnamespace WickContraction\nvariable {n : \u2115} (c : WickContraction n)\nopen HepLean.List\nopen HepLean.Fin\n\n/-!\n\n## Some properties of lists of fin\n\n-/\n\nlemma fin_list_sorted_monotone_sorted {n m : \u2115} (l: List (Fin n)) (hl : l.Sorted (\u00b7 \u2264 \u00b7))\n    (f : Fin n \u2192 Fin m) (hf : StrictMono f) : ((List.map f l)).Sorted (\u00b7 \u2264 \u00b7) := by\n  induction l with\n  | nil => simp\n  | cons a l ih =>\n    simp only [List.map_cons, List.sorted_cons, List.mem_map, forall_exists_index, and_imp,\n      forall_apply_eq_imp_iff\u2082]\n    apply And.intro\n    \u00b7 simp only [List.sorted_cons] at hl\n      intro b hb\n      have hl1 := hl.1 b hb\n      exact (StrictMono.le_iff_le hf).mpr hl1\n    \u00b7 simp only [List.sorted_cons] at hl\n      exact ih hl.2\n\nlemma fin_list_sorted_succAboveEmb_sorted (l: List (Fin n)) (hl : l.Sorted (\u00b7 \u2264 \u00b7))\n    (i : Fin n.succ) : ((List.map i.succAboveEmb l)).Sorted (\u00b7 \u2264 \u00b7) := by\n  apply fin_list_sorted_monotone_sorted\n  exact hl\n  simp only [Fin.coe_succAboveEmb]\n  exact Fin.strictMono_succAbove i\n\nlemma fin_finset_sort_map_monotone {n m : \u2115} (a : Finset (Fin n)) (f : Fin n \u21aa Fin m)\n    (hf : StrictMono f) : (Finset.sort (\u00b7 \u2264 \u00b7) a).map f =\n    (Finset.sort (\u00b7 \u2264 \u00b7) (a.map f)) := by\n  have h1 : ((Finset.sort (\u00b7 \u2264 \u00b7) a).map f).Sorted (\u00b7 \u2264 \u00b7) := by\n    apply fin_list_sorted_monotone_sorted\n    exact Finset.sort_sorted (fun x1 x2 => x1 \u2264 x2) a\n    exact hf\n  have h2 : ((Finset.sort (\u00b7 \u2264 \u00b7) a).map f).Nodup := by\n    refine (List.nodup_map_iff_inj_on ?_).mpr ?_\n    exact Finset.sort_nodup (fun x1 x2 => x1 \u2264 x2) a\n    intro a ha b hb hf\n    exact f.2 hf\n  have h3 : ((Finset.sort (\u00b7 \u2264 \u00b7) a).map f).toFinset = (a.map f) := by\n    ext a\n    simp\n  rw [\u2190 h3]\n  exact ((List.toFinset_sort (\u00b7 \u2264 \u00b7) h2).mpr h1).symm\n\nlemma fin_list_sorted_split :\n    (l : List (Fin n)) \u2192 (hl : l.Sorted (\u00b7 \u2264 \u00b7)) \u2192 (i : \u2115) \u2192\n    l = l.filter (fun x => x.1 < i) ++ l.filter (fun x => i \u2264 x.1)\n  | [], _, _ => by simp\n  | a :: l, hl, i => by\n    simp only [List.sorted_cons] at hl\n    by_cases ha : a < i\n    \u00b7 conv_lhs => rw [fin_list_sorted_split l hl.2 i]\n      rw [\u2190 List.cons_append]\n      rw [List.filter_cons_of_pos, List.filter_cons_of_neg]\n      simp only [decide_eq_true_eq, not_le, ha]\n      simp [ha]\n    \u00b7 have hx : List.filter (fun x => decide (x.1 < i)) (a :: l) = [] := by\n        simp only [ha, decide_false, Bool.false_eq_true, not_false_eq_true, List.filter_cons_of_neg,\n          List.filter_eq_nil_iff, decide_eq_true_eq, not_lt]\n        intro b hb\n        have hb' := hl.1 b hb\n        omega\n      simp only [hx, List.nil_append]\n      rw [List.filter_cons_of_pos]\n      simp only [List.cons.injEq, true_and]\n      have hl' := fin_list_sorted_split l hl.2 i\n      have hx : List.filter (fun x => decide (x.1 < i)) (l) = [] := by\n        simp only [List.filter_eq_nil_iff, decide_eq_true_eq, not_lt]\n        intro b hb\n        have hb' := hl.1 b hb\n        omega\n      simp only [hx, List.nil_append] at hl'\n      conv_lhs => rw [hl']\n      simp only [decide_eq_true_eq]\n      omega\n\nlemma fin_list_sorted_indexOf_filter_le_mem :\n    (l : List (Fin n)) \u2192 (hl : l.Sorted (\u00b7 \u2264 \u00b7)) \u2192 (i : Fin n) \u2192\n    (hl : i \u2208 l) \u2192\n    List.indexOf i (List.filter (fun x => decide (\u2191i \u2264 \u2191x)) l) = 0\n  | [], _, _, _ => by simp\n  | a :: l, hl, i, hi => by\n    simp only [List.sorted_cons] at hl\n    by_cases ha : i \u2264 a\n    \u00b7 simp only [ha, decide_true, List.filter_cons_of_pos]\n      have ha : a = i := by\n        simp only [List.mem_cons] at hi\n        rcases hi with hi | hi\n        \u00b7 subst hi\n          rfl\n        \u00b7 have hl' := hl.1 i hi\n          exact Fin.le_antisymm hl' ha\n      subst ha\n      simp\n    \u00b7 simp only [not_le] at ha\n      rw [List.filter_cons_of_neg (by simpa using ha)]\n      rw [fin_list_sorted_indexOf_filter_le_mem l hl.2]\n      simp only [List.mem_cons] at hi\n      rcases hi with hi | hi\n      \u00b7 omega\n      \u00b7 exact hi\n\nlemma fin_list_sorted_indexOf_mem :\n    (l : List (Fin n)) \u2192 (hl : l.Sorted (\u00b7 \u2264 \u00b7)) \u2192 (i : Fin n) \u2192\n    (hi : i \u2208 l) \u2192\n    l.indexOf i = (l.filter (fun x => x.1 < i.1)).length := by\n  intro l hl i hi\n  conv_lhs => rw [fin_list_sorted_split l hl i]\n  rw [List.indexOf_append_of_not_mem]\n  erw [fin_list_sorted_indexOf_filter_le_mem l hl i hi]\n  \u00b7 simp\n  \u00b7 simp\n\nlemma orderedInsert_of_fin_list_sorted :\n    (l : List (Fin n)) \u2192 (hl : l.Sorted (\u00b7 \u2264 \u00b7)) \u2192 (i : Fin n) \u2192\n    List.orderedInsert (\u00b7 \u2264 \u00b7) i l = l.filter (fun x => x.1 < i.1) ++\n    i :: l.filter (fun x => i.1 \u2264 x.1)\n  | [], _, _ => by simp\n  | a :: l, hl, i => by\n    simp only [List.sorted_cons] at hl\n    by_cases ha : i \u2264 a\n    \u00b7 simp only [List.orderedInsert, ha, \u2193reduceIte, Fin.val_fin_lt, decide_eq_true_eq, not_lt,\n      List.filter_cons_of_neg, Fin.val_fin_le, decide_true, List.filter_cons_of_pos]\n      have h1 : List.filter (fun x => decide (\u2191x < \u2191i)) l = [] := by\n        simp only [List.filter_eq_nil_iff, decide_eq_true_eq, not_lt]\n        intro a ha\n        have ha' := hl.1 a ha\n        omega\n      have hl : l = List.filter (fun x => decide (i \u2264 x)) l := by\n        conv_lhs => rw [fin_list_sorted_split l hl.2 i]\n        simp [h1]\n      simp [\u2190 hl, h1]\n    \u00b7 simp only [List.orderedInsert, ha, \u2193reduceIte, Fin.val_fin_lt, Fin.val_fin_le, decide_false,\n      Bool.false_eq_true, not_false_eq_true, List.filter_cons_of_neg]\n      rw [List.filter_cons_of_pos]\n      rw [orderedInsert_of_fin_list_sorted l hl.2 i]\n      simp only [Fin.val_fin_lt, Fin.val_fin_le, List.cons_append]\n      simp only [decide_eq_true_eq]\n      omega\n\nlemma orderedInsert_eq_insertIdx_of_fin_list_sorted (l : List (Fin n)) (hl : l.Sorted (\u00b7 \u2264 \u00b7))\n    (i : Fin n) :\n    List.orderedInsert (\u00b7 \u2264 \u00b7) i l = l.insertIdx (l.filter (fun x => x.1 < i.1)).length i := by\n  let n : Fin l.length.succ := \u27e8(List.filter (fun x => decide (x < i)) l).length, by\n    have h1 := l.length_filter_le (fun x => x.1 < i.1)\n    simp only [Fin.val_fin_lt] at h1\n    omega\u27e9\n  simp only [Fin.val_fin_lt]\n  conv_rhs => rw [insertIdx_eq_take_drop _ _ n]\n  rw [orderedInsert_of_fin_list_sorted]\n  congr\n  \u00b7 conv_rhs =>\n      rhs\n      rw [fin_list_sorted_split l hl i]\n    simp [n]\n  \u00b7 conv_rhs =>\n      rhs\n      rw [fin_list_sorted_split l hl i]\n    simp [n]\n  exact hl\n\n/-!\n\n## Uncontracted List\n\n-/\n\n/-- Given a Wick contraction `c`, the ordered list of elements of `Fin n` which are not contracted,\n  i.e. do not appear anywhere in `c.1`. -/\ndef uncontractedList : List (Fin n) := List.filter (fun x => x \u2208 c.uncontracted) (List.finRange n)\n\nlemma uncontractedList_mem_iff (i : Fin n) :\n    i \u2208 c.uncontractedList \u2194 i \u2208 c.uncontracted := by\n  simp [uncontractedList]\n\n@[simp]\nlemma uncontractedList_empty : (empty (n := n)).uncontractedList = List.finRange n := by\n  simp [uncontractedList]\n\nlemma nil_zero_uncontractedList : (empty (n := 0)).uncontractedList = [] := by\n  simp [empty, uncontractedList]\n\nlemma congr_uncontractedList {n m : \u2115} (h : n = m) (c : WickContraction n) :\n    ((congr h) c).uncontractedList = List.map (finCongr h) c.uncontractedList := by\n  subst h\n  simp [congr]\n\nlemma uncontractedList_get_mem_uncontracted (i : Fin c.uncontractedList.length) :\n    c.uncontractedList.get i \u2208 c.uncontracted := by\n  rw [\u2190 uncontractedList_mem_iff]\n  simp\n\nlemma uncontractedList_sorted : List.Sorted (\u00b7 \u2264 \u00b7) c.uncontractedList := by\n  rw [uncontractedList]\n  apply List.Sorted.filter\n  rw [\u2190 List.ofFn_id]\n  exact Monotone.ofFn_sorted fun \u2983a b\u2984 a => a\n\nlemma uncontractedList_sorted_lt : List.Sorted (\u00b7 < \u00b7) c.uncontractedList := by\n  rw [uncontractedList]\n  apply List.Sorted.filter\n  rw [\u2190 List.ofFn_id]\n  exact List.sorted_lt_ofFn_iff.mpr fun \u2983a b\u2984 a => a\n\nlemma uncontractedList_nodup : c.uncontractedList.Nodup := by\n  rw [uncontractedList]\n  refine List.Nodup.filter (fun x => decide (x \u2208 c.uncontracted)) ?_\n  exact List.nodup_finRange n\n\nlemma uncontractedList_toFinset (c : WickContraction n) :\n    c.uncontractedList.toFinset = c.uncontracted := by\n  simp [uncontractedList]\n\nlemma uncontractedList_eq_sort (c : WickContraction n) :\n    c.uncontractedList = c.uncontracted.sort (\u00b7 \u2264 \u00b7) := by\n  symm\n  rw [\u2190 uncontractedList_toFinset]\n  refine (List.toFinset_sort (\u03b1 := Fin n) (\u00b7 \u2264 \u00b7) ?_).mpr ?_\n  \u00b7 exact uncontractedList_nodup c\n  \u00b7 exact uncontractedList_sorted c\n\nlemma uncontractedList_length_eq_card (c : WickContraction n) :\n    c.uncontractedList.length = c.uncontracted.card := by\n  rw [uncontractedList_eq_sort]\n  exact Finset.length_sort fun x1 x2 => x1 \u2264 x2\n\nlemma filter_uncontractedList (c : WickContraction n) (p : Fin n \u2192 Prop) [DecidablePred p] :\n    (c.uncontractedList.filter p) = (c.uncontracted.filter p).sort (\u00b7 \u2264 \u00b7) := by\n  have h1 : (c.uncontractedList.filter p).Sorted (\u00b7 \u2264 \u00b7) := by\n    apply List.Sorted.filter\n    exact uncontractedList_sorted c\n  have h2 : (c.uncontractedList.filter p).Nodup := by\n    refine List.Nodup.filter _ ?_\n    exact uncontractedList_nodup c\n  have h3 : (c.uncontractedList.filter p).toFinset = (c.uncontracted.filter p) := by\n    ext a\n    simp only [List.toFinset_filter, decide_eq_true_eq, Finset.mem_filter, List.mem_toFinset,\n      and_congr_left_iff]\n    rw [uncontractedList_mem_iff]\n    simp\n  have hx := (List.toFinset_sort (\u00b7 \u2264 \u00b7) h2).mpr h1\n  rw [\u2190 hx, h3]\n\n/-!\n\n## uncontractedIndexEquiv\n\n-/\n\n/-- The equivalence between the positions of `c.uncontractedList` i.e. elements of\n  `Fin (c.uncontractedList).length` and the finite set `c.uncontracted` considered as a finite type.\n-/\ndef uncontractedIndexEquiv (c : WickContraction n) :\n    Fin (c.uncontractedList).length \u2243 c.uncontracted where\n  toFun i := \u27e8c.uncontractedList.get i, c.uncontractedList_get_mem_uncontracted i\u27e9\n  invFun i := \u27e8List.indexOf i.1 c.uncontractedList,\n    List.indexOf_lt_length_iff.mpr ((c.uncontractedList_mem_iff i.1).mpr i.2)\u27e9\n  left_inv i := by\n    ext\n    exact List.get_indexOf (uncontractedList_nodup c) _\n  right_inv i := by\n    ext\n    simp\n\n", "theoremStatement": "@[simp]\nlemma uncontractedList_getElem_uncontractedIndexEquiv_symm (k : c.uncontracted) :\n    c.uncontractedList[(c.uncontractedIndexEquiv.symm k).val] = k ", "theoremName": "WickContraction.uncontractedList_getElem_uncontractedIndexEquiv_symm", "fileCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "theoremCreated": {"commit": "4ca4eac8c57dfcc6b830beb846b485e40e2f5f9c", "date": "2025-01-22"}, "file": "HepLean/HepLean/PerturbationTheory/WickContraction/UncontractedList.lean", "module": "HepLean.PerturbationTheory.WickContraction.UncontractedList", "jsonFile": "HepLean.PerturbationTheory.WickContraction.UncontractedList.jsonl", "positionMetadata": {"lineInFile": 287, "tokenPositionInFile": 10114, "theoremPositionInFile": 18}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 4, "numPremises": 38}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp [uncontractedIndexEquiv]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 37}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpAlgebra.Basic\n/-!\n\n# Grading on the field operation algebra\n\n-/\n\nnamespace FieldSpecification\nopen FieldOpFreeAlgebra\nopen HepLean.List\nopen FieldStatistic\n\nnamespace FieldOpAlgebra\nvariable {\ud835\udcd5 : FieldSpecification}\n\n/-- The submodule of `\ud835\udcd5.FieldOpAlgebra` spanned by lists of field statistic `f`. -/\ndef statSubmodule (f : FieldStatistic) : Submodule \u2102 \ud835\udcd5.FieldOpAlgebra :=\n  Submodule.span \u2102 {a | \u2203 \u03c6s, a = ofCrAnList \u03c6s \u2227 (\ud835\udcd5 |>\u209b \u03c6s) = f}\n\nlemma ofCrAnList_mem_statSubmodule_of_eq (\u03c6s : List \ud835\udcd5.CrAnFieldOp) (f : FieldStatistic)\n    (h : (\ud835\udcd5 |>\u209b \u03c6s) = f) : ofCrAnList \u03c6s \u2208 statSubmodule f :=\n  Submodule.mem_span.mpr fun _ a => a \u27e8\u03c6s, \u27e8rfl, h\u27e9\u27e9\n\nlemma ofCrAnList_mem_statSubmodule (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnList \u03c6s \u2208 statSubmodule (\ud835\udcd5 |>\u209b \u03c6s) :=\n  Submodule.mem_span.mpr fun _ a => a \u27e8\u03c6s, \u27e8rfl, rfl\u27e9\u27e9\n\nlemma mem_bosonic_of_mem_free_bosonic (a : \ud835\udcd5.FieldOpFreeAlgebra)\n    (h : a \u2208 statisticSubmodule bosonic) : \u03b9 a \u2208 statSubmodule .bosonic := by\n  let p (a : \ud835\udcd5.FieldOpFreeAlgebra) (hx : a \u2208 statisticSubmodule bosonic) : Prop :=\n    \u03b9 a \u2208 statSubmodule .bosonic\n  change p a h\n  apply Submodule.span_induction\n  \u00b7 intro x hx\n    simp only [Set.mem_setOf_eq] at hx\n    obtain \u27e8\u03c6s, rfl, h\u27e9 := hx\n    simp [p]\n    apply ofCrAnList_mem_statSubmodule_of_eq\n    exact h\n  \u00b7 simp only [map_zero, p]\n    exact Submodule.zero_mem (statSubmodule bosonic)\n  \u00b7 intro x y hx hy hpx hpy\n    simp_all only [p, map_add]\n    exact Submodule.add_mem _ hpx hpy\n  \u00b7 intro a x hx hy\n    simp_all only [p, map_smul]\n    exact Submodule.smul_mem _ _ hy\n\nlemma mem_fermionic_of_mem_free_fermionic (a : \ud835\udcd5.FieldOpFreeAlgebra)\n    (h : a \u2208 statisticSubmodule fermionic) : \u03b9 a \u2208 statSubmodule .fermionic := by\n  let p (a : \ud835\udcd5.FieldOpFreeAlgebra) (hx : a \u2208 statisticSubmodule fermionic) : Prop :=\n    \u03b9 a \u2208 statSubmodule .fermionic\n  change p a h\n  apply Submodule.span_induction\n  \u00b7 intro x hx\n    simp only [Set.mem_setOf_eq] at hx\n    obtain \u27e8\u03c6s, rfl, h\u27e9 := hx\n    simp [p]\n    apply ofCrAnList_mem_statSubmodule_of_eq\n    exact h\n  \u00b7 simp only [map_zero, p]\n    exact Submodule.zero_mem (statSubmodule fermionic)\n  \u00b7 intro x y hx hy hpx hpy\n    simp_all only [p, map_add]\n    exact Submodule.add_mem _ hpx hpy\n  \u00b7 intro a x hx hy\n    simp_all only [p, map_smul]\n    exact Submodule.smul_mem _ _ hy\n\nlemma mem_statSubmodule_of_mem_statisticSubmodule (f : FieldStatistic) (a : \ud835\udcd5.FieldOpFreeAlgebra)\n    (h : a \u2208 statisticSubmodule f) : \u03b9 a \u2208 statSubmodule f := by\n  fin_cases f\n  \u00b7 exact mem_bosonic_of_mem_free_bosonic a h\n  \u00b7 exact mem_fermionic_of_mem_free_fermionic a h\n\n/-- The projection of `statisticSubmodule (\ud835\udcd5 := \ud835\udcd5) f` defined in the free algebra to\n  `statSubmodule (\ud835\udcd5 := \ud835\udcd5) f`. -/\ndef \u03b9StateSubmodule (f : FieldStatistic) :\n    statisticSubmodule (\ud835\udcd5 := \ud835\udcd5) f \u2192\u2097[\u2102] statSubmodule (\ud835\udcd5 := \ud835\udcd5) f where\n  toFun a := \u27e8a.1, mem_statSubmodule_of_mem_statisticSubmodule f a.1 a.2\u27e9\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n\nnoncomputable section\n\n/-!\n\n## Defining bosonicProj\n\n-/\n\n/-- The projection of `\ud835\udcd5.FieldOpFreeAlgebra` to `statSubmodule (\ud835\udcd5 := \ud835\udcd5) bosonic`. -/\ndef bosonicProjFree : \ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102] statSubmodule (\ud835\udcd5 := \ud835\udcd5) bosonic :=\n  \u03b9StateSubmodule .bosonic \u2218\u2097 bosonicProjF\n\nlemma bosonicProjFree_eq_\u03b9_bosonicProjF (a : \ud835\udcd5.FieldOpFreeAlgebra) :\n    (bosonicProjFree a).1 = \u03b9 (bosonicProjF a) := rfl\n\nlemma bosonicProjFree_zero_of_\u03b9_zero (a : \ud835\udcd5.FieldOpFreeAlgebra) (h : \u03b9 a = 0) :\n    bosonicProjFree a = 0 := by\n  rw [\u03b9_eq_zero_iff_\u03b9_bosonicProjF_fermonicProj_zero] at h\n  apply Subtype.eq\n  rw [bosonicProjFree_eq_\u03b9_bosonicProjF]\n  exact h.1\n\nlemma bosonicProjFree_eq_of_equiv (a b : \ud835\udcd5.FieldOpFreeAlgebra) (h : a \u2248 b) :\n    bosonicProjFree a = bosonicProjFree b := by\n  rw [equiv_iff_sub_mem_ideal, \u2190 \u03b9_eq_zero_iff_mem_ideal] at h\n  rw [LinearMap.sub_mem_ker_iff.mp]\n  simp only [LinearMap.mem_ker, \u2190 map_sub]\n  exact bosonicProjFree_zero_of_\u03b9_zero (a - b) h\n\n/-- The projection of `\ud835\udcd5.FieldOpAlgebra` to `statSubmodule (\ud835\udcd5 := \ud835\udcd5) bosonic`. -/\ndef bosonicProj : \ud835\udcd5.FieldOpAlgebra \u2192\u2097[\u2102] statSubmodule (\ud835\udcd5 := \ud835\udcd5) bosonic where\n  toFun := Quotient.lift bosonicProjFree bosonicProjFree_eq_of_equiv\n  map_add' x y := by\n    obtain \u27e8x, hx\u27e9 := \u03b9_surjective x\n    obtain \u27e8y, hy\u27e9 := \u03b9_surjective y\n    subst hx hy\n    rw [\u2190 map_add, \u03b9_apply, \u03b9_apply, \u03b9_apply]\n    rw [Quotient.lift_mk, Quotient.lift_mk, Quotient.lift_mk]\n    simp\n  map_smul' c y := by\n    obtain \u27e8y, hy\u27e9 := \u03b9_surjective y\n    subst hy\n    rw [\u2190 map_smul, \u03b9_apply, \u03b9_apply]\n    simp\n\nlemma bosonicProj_eq_bosonicProjFree (a : \ud835\udcd5.FieldOpFreeAlgebra) :\n    bosonicProj (\u03b9 a) = bosonicProjFree a := rfl\n\n/-!\n\n## Defining fermionicProj\n\n-/\n\n/-- The projection of `\ud835\udcd5.FieldOpFreeAlgebra` to `statSubmodule (\ud835\udcd5 := \ud835\udcd5) fermionic`. -/\ndef fermionicProjFree : \ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102] statSubmodule (\ud835\udcd5 := \ud835\udcd5) fermionic :=\n  \u03b9StateSubmodule .fermionic \u2218\u2097 fermionicProjF\n\nlemma fermionicProjFree_eq_\u03b9_fermionicProjF (a : \ud835\udcd5.FieldOpFreeAlgebra) :\n    (fermionicProjFree a).1 = \u03b9 (fermionicProjF a) := rfl\n\nlemma fermionicProjFree_zero_of_\u03b9_zero (a : \ud835\udcd5.FieldOpFreeAlgebra) (h : \u03b9 a = 0) :\n    fermionicProjFree a = 0 := by\n  rw [\u03b9_eq_zero_iff_\u03b9_bosonicProjF_fermonicProj_zero] at h\n  apply Subtype.eq\n  rw [fermionicProjFree_eq_\u03b9_fermionicProjF]\n  exact h.2\n\nlemma fermionicProjFree_eq_of_equiv (a b : \ud835\udcd5.FieldOpFreeAlgebra) (h : a \u2248 b) :\n    fermionicProjFree a = fermionicProjFree b := by\n  rw [equiv_iff_sub_mem_ideal, \u2190 \u03b9_eq_zero_iff_mem_ideal] at h\n  rw [LinearMap.sub_mem_ker_iff.mp]\n  simp only [LinearMap.mem_ker, \u2190 map_sub]\n  exact fermionicProjFree_zero_of_\u03b9_zero (a - b) h\n\n/-- The projection of `\ud835\udcd5.FieldOpAlgebra` to `statSubmodule (\ud835\udcd5 := \ud835\udcd5) fermionic`. -/\ndef fermionicProj : \ud835\udcd5.FieldOpAlgebra \u2192\u2097[\u2102] statSubmodule (\ud835\udcd5 := \ud835\udcd5) fermionic where\n  toFun := Quotient.lift fermionicProjFree fermionicProjFree_eq_of_equiv\n  map_add' x y := by\n    obtain \u27e8x, hx\u27e9 := \u03b9_surjective x\n    obtain \u27e8y, hy\u27e9 := \u03b9_surjective y\n    subst hx hy\n    rw [\u2190 map_add, \u03b9_apply, \u03b9_apply, \u03b9_apply]\n    rw [Quotient.lift_mk, Quotient.lift_mk, Quotient.lift_mk]\n    simp\n  map_smul' c y := by\n    obtain \u27e8y, hy\u27e9 := \u03b9_surjective y\n    subst hy\n    rw [\u2190 map_smul, \u03b9_apply, \u03b9_apply]\n    simp\n\nlemma fermionicProj_eq_fermionicProjFree (a : \ud835\udcd5.FieldOpFreeAlgebra) :\n    fermionicProj (\u03b9 a) = fermionicProjFree a := rfl\n\n/-!\n\n## Interactino between bosonicProj and fermionicProj\n\n-/\n\nlemma bosonicProj_add_fermionicProj (a : \ud835\udcd5.FieldOpAlgebra) :\n    bosonicProj a + (fermionicProj a).1 = a := by\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  rw [fermionicProj_eq_fermionicProjFree, bosonicProj_eq_bosonicProjFree]\n  rw [bosonicProjFree_eq_\u03b9_bosonicProjF, fermionicProjFree_eq_\u03b9_fermionicProjF]\n  rw [\u2190 map_add, bosonicProjF_add_fermionicProjF]\n\nlemma bosonicProj_mem_bosonic (a : \ud835\udcd5.FieldOpAlgebra) (ha : a \u2208 statSubmodule .bosonic) :\n    bosonicProj a = \u27e8a, ha\u27e9 := by\n  let p (a : \ud835\udcd5.FieldOpAlgebra) (hx : a \u2208 statSubmodule bosonic) : Prop :=\n    (bosonicProj a) = \u27e8a, hx\u27e9\n  change p a ha\n  apply Submodule.span_induction\n  \u00b7 intro x hx\n    obtain \u27e8\u03c6s, rfl, h\u27e9 := hx\n    simp only [p]\n    apply Subtype.eq\n    simp only\n    rw [ofCrAnList]\n    rw [bosonicProj_eq_bosonicProjFree]\n    rw [bosonicProjFree_eq_\u03b9_bosonicProjF]\n    rw [bosonicProjF_of_mem_bosonic]\n    exact ofCrAnListF_mem_statisticSubmodule_of _ _ h\n  \u00b7 simp only [map_zero, p]\n    rfl\n  \u00b7 intro x y hx hy hpx hpy\n    simp_all [p]\n  \u00b7 intro a x hx hy\n    simp_all [p]\n\nlemma fermionicProj_mem_fermionic (a : \ud835\udcd5.FieldOpAlgebra) (ha : a \u2208 statSubmodule .fermionic) :\n    fermionicProj a = \u27e8a, ha\u27e9 := by\n  let p (a : \ud835\udcd5.FieldOpAlgebra) (hx : a \u2208 statSubmodule fermionic) : Prop :=\n    (fermionicProj a) = \u27e8a, hx\u27e9\n  change p a ha\n  apply Submodule.span_induction\n  \u00b7 intro x hx\n    obtain \u27e8\u03c6s, rfl, h\u27e9 := hx\n    simp only [p]\n    apply Subtype.eq\n    simp only\n    rw [ofCrAnList]\n    rw [fermionicProj_eq_fermionicProjFree]\n    rw [fermionicProjFree_eq_\u03b9_fermionicProjF]\n    rw [fermionicProjF_of_mem_fermionic]\n    exact ofCrAnListF_mem_statisticSubmodule_of _ _ h\n  \u00b7 simp only [map_zero, p]\n    rfl\n  \u00b7 intro x y hx hy hpx hpy\n    simp_all [p]\n  \u00b7 intro a x hx hy\n    simp_all [p]\n\nlemma bosonicProj_mem_fermionic (a : \ud835\udcd5.FieldOpAlgebra) (ha : a \u2208 statSubmodule .fermionic) :\n    bosonicProj a = 0 := by\n  have h := bosonicProj_add_fermionicProj a\n  rw [fermionicProj_mem_fermionic a ha] at h\n  simpa using h\n\nlemma fermionicProj_mem_bosonic (a : \ud835\udcd5.FieldOpAlgebra) (ha : a \u2208 statSubmodule .bosonic) :\n    fermionicProj a = 0 := by\n  have h := bosonicProj_add_fermionicProj a\n  rw [bosonicProj_mem_bosonic a ha] at h\n  simpa using h\n\nlemma mem_bosonic_iff_fermionicProj_eq_zero (a : \ud835\udcd5.FieldOpAlgebra) :\n    a \u2208 statSubmodule bosonic \u2194 fermionicProj a = 0 := by\n  apply Iff.intro\n  \u00b7 intro h\n    exact fermionicProj_mem_bosonic a h\n  \u00b7 intro h\n    have ha := bosonicProj_add_fermionicProj a\n    rw [h] at ha\n    simp_all\n    rw [\u2190 ha]\n    exact (bosonicProj a).2\n\nlemma mem_fermionic_iff_bosonicProj_eq_zero (a : \ud835\udcd5.FieldOpAlgebra) :\n    a \u2208 statSubmodule fermionic \u2194 bosonicProj a = 0 := by\n  apply Iff.intro\n  \u00b7 intro h\n    exact bosonicProj_mem_fermionic a h\n  \u00b7 intro h\n    have ha := bosonicProj_add_fermionicProj a\n    rw [h] at ha\n    simp_all\n    rw [\u2190 ha]\n    exact (fermionicProj a).2\n\nlemma eq_zero_of_bosonic_and_fermionic {a : \ud835\udcd5.FieldOpAlgebra}\n    (hb : a \u2208 statSubmodule bosonic) (hf : a \u2208 statSubmodule fermionic) : a = 0 := by\n  have ha := bosonicProj_mem_bosonic a hb\n  have hb := fermionicProj_mem_fermionic a hf\n  have hc := (bosonicProj_add_fermionicProj a)\n  rw [ha, hb] at hc\n  simpa using hc\n\n@[simp]\nlemma bosonicProj_fermionicProj_eq_zero (a : \ud835\udcd5.FieldOpAlgebra) :\n    bosonicProj (fermionicProj a).1 = 0 := by\n  apply bosonicProj_mem_fermionic\n  exact Submodule.coe_mem (fermionicProj a)\n\n@[simp]\nlemma fermionicProj_bosonicProj_eq_zero (a : \ud835\udcd5.FieldOpAlgebra) :\n    fermionicProj (bosonicProj a).1 = 0 := by\n  apply fermionicProj_mem_bosonic\n  exact Submodule.coe_mem (bosonicProj a)\n\n", "theoremStatement": "@[simp]\nlemma bosonicProj_bosonicProj_eq_bosonicProj (a : \ud835\udcd5.FieldOpAlgebra) :\n    bosonicProj (bosonicProj a).1 = bosonicProj a ", "theoremName": "FieldSpecification.FieldOpAlgebra.bosonicProj_bosonicProj_eq_bosonicProj", "fileCreated": {"commit": "7d9e6af80c57599f68481948604d9f0aaba4a40f", "date": "2025-02-05"}, "theoremCreated": {"commit": "7d9e6af80c57599f68481948604d9f0aaba4a40f", "date": "2025-02-05"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpAlgebra/Grading.lean", "module": "HepLean.PerturbationTheory.FieldOpAlgebra.Grading", "jsonFile": "HepLean.PerturbationTheory.FieldOpAlgebra.Grading.jsonl", "positionMetadata": {"lineInFile": 298, "tokenPositionInFile": 10072, "theoremPositionInFile": 26}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 5, "repositoryPremises": true, "numRepositoryPremises": 11, "numPremises": 56}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  apply bosonicProj_mem_bosonic", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 37}}
{"srcContext": "/-\nCopyright (c) 2024 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.Koszul.KoszulSignInsert\nimport HepLean.Mathematics.List.InsertionSort\n/-!\n\n# Koszul sign\n\n-/\n\nnamespace Wick\n\nopen HepLean.List\nopen FieldStatistic\n\nvariable {\ud835\udcd5 : Type} (q : \ud835\udcd5 \u2192 FieldStatistic) (le : \ud835\udcd5 \u2192 \ud835\udcd5 \u2192 Prop) [DecidableRel le]\n\n/-- Gives a factor of `- 1` for every fermion-fermion (`q` is `1`) crossing that occurs when sorting\n  a list of based on `r`. -/\ndef koszulSign (q : \ud835\udcd5 \u2192 FieldStatistic) (le : \ud835\udcd5 \u2192 \ud835\udcd5 \u2192 Prop) [DecidableRel le] :\n    List \ud835\udcd5 \u2192 \u2102\n  | [] => 1\n  | a :: l => koszulSignInsert q le a l * koszulSign q le l\n\n", "theoremStatement": "@[simp]\nlemma koszulSign_singleton (q : \ud835\udcd5 \u2192 FieldStatistic) (le : \ud835\udcd5 \u2192 \ud835\udcd5 \u2192 Prop) [DecidableRel le] (\u03c6 : \ud835\udcd5) :\n    koszulSign q le [\u03c6] = 1 ", "theoremName": "Wick.koszulSign_singleton", "fileCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "theoremCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "file": "HepLean/HepLean/PerturbationTheory/Koszul/KoszulSign.lean", "module": "HepLean.PerturbationTheory.Koszul.KoszulSign", "jsonFile": "HepLean.PerturbationTheory.Koszul.KoszulSign.jsonl", "positionMetadata": {"lineInFile": 28, "tokenPositionInFile": 727, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 24}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp [koszulSign, koszulSignInsert]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 43}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.WickContraction.Erase\n/-!\n\n# Inserting an element into a contraction\n\n-/\n\nopen FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\nnamespace WickContraction\nvariable {n : \u2115} (c : WickContraction n)\nopen HepLean.List\nopen HepLean.Fin\n\n/-!\n\n## Inserting an element into a contraction\n\n-/\n\n/-- Given a Wick contraction `c` for `n`, a position `i : Fin n.succ` and\n  an optional uncontracted element `j : Option (c.uncontracted)` of `c`.\n  The Wick contraction for `n.succ` formed by 'inserting' `i` into `Fin n`\n  and contracting it optionally with `j`. -/\ndef insertAndContractNat (c : WickContraction n) (i : Fin n.succ) (j : Option (c.uncontracted)) :\n    WickContraction n.succ := by\n  let f := Finset.map (Finset.mapEmbedding i.succAboveEmb).toEmbedding c.1\n  let f' := match j with | none => f | some j => Insert.insert {i, i.succAbove j} f\n  refine \u27e8f', ?_, ?_\u27e9\n  \u00b7 simp only [Nat.succ_eq_add_one, f']\n    match j with\n    | none =>\n      simp only [Finset.le_eq_subset, Finset.mem_map, RelEmbedding.coe_toEmbedding,\n        forall_exists_index, and_imp, forall_apply_eq_imp_iff\u2082, f]\n      intro a ha\n      rw [Finset.mapEmbedding_apply]\n      simp only [Finset.card_map]\n      exact c.2.1 a ha\n    | some j =>\n      simp only [Finset.mem_insert, forall_eq_or_imp]\n      apply And.intro\n      \u00b7 rw [@Finset.card_eq_two]\n        use i\n        use (i.succAbove j)\n        simp only [ne_eq, and_true]\n        exact Fin.ne_succAbove i j\n      \u00b7 simp only [Finset.le_eq_subset, Finset.mem_map, RelEmbedding.coe_toEmbedding,\n        forall_exists_index, and_imp, forall_apply_eq_imp_iff\u2082, f]\n        intro a ha\n        rw [Finset.mapEmbedding_apply]\n        simp only [Finset.card_map]\n        exact c.2.1 a ha\n  \u00b7 intro a ha b hb\n    simp only [Nat.succ_eq_add_one, f'] at ha hb\n    match j with\n    | none =>\n      simp_all only [f, Finset.le_eq_subset, Finset.mem_map, RelEmbedding.coe_toEmbedding,\n        Nat.succ_eq_add_one]\n      obtain \u27e8a', ha', ha''\u27e9 := ha\n      obtain \u27e8b', hb', hb''\u27e9 := hb\n      subst ha''\n      subst hb''\n      simp only [EmbeddingLike.apply_eq_iff_eq]\n      rw [Finset.mapEmbedding_apply, Finset.mapEmbedding_apply, Finset.disjoint_map]\n      exact c.2.2 a' ha' b' hb'\n    | some j =>\n      simp_all only [Finset.mem_insert, Nat.succ_eq_add_one]\n      match ha, hb with\n      | Or.inl ha, Or.inl hb =>\n        rw [ha, hb]\n        simp\n      | Or.inl ha, Or.inr hb =>\n        apply Or.inr\n        subst ha\n        simp only [Finset.disjoint_insert_left, Finset.disjoint_singleton_left]\n        simp only [Finset.le_eq_subset, Finset.mem_map, RelEmbedding.coe_toEmbedding, f] at hb\n        obtain \u27e8a', hb', hb''\u27e9 := hb\n        subst hb''\n        rw [Finset.mapEmbedding_apply]\n        apply And.intro\n        \u00b7 simp only [Finset.mem_map, Fin.succAboveEmb_apply, not_exists, not_and]\n          exact fun x _ => Fin.succAbove_ne i x\n        \u00b7 simp only [Finset.mem_map, Fin.succAboveEmb_apply, not_exists, not_and]\n          have hj := j.2\n          rw [mem_uncontracted_iff_not_contracted] at hj\n          intro a ha hja\n          rw [Function.Injective.eq_iff (Fin.succAbove_right_injective)] at hja\n          subst hja\n          exact False.elim (hj a' hb' ha)\n      | Or.inr ha, Or.inl hb =>\n        apply Or.inr\n        subst hb\n        simp only [Finset.disjoint_insert_right, Nat.succ_eq_add_one,\n          Finset.disjoint_singleton_right]\n        simp only [Finset.le_eq_subset, Finset.mem_map, RelEmbedding.coe_toEmbedding, f] at ha\n        obtain \u27e8a', ha', ha''\u27e9 := ha\n        subst ha''\n        rw [Finset.mapEmbedding_apply]\n        apply And.intro\n        \u00b7 simp only [Finset.mem_map, Fin.succAboveEmb_apply, not_exists, not_and]\n          exact fun x _ => Fin.succAbove_ne i x\n        \u00b7 simp only [Finset.mem_map, Fin.succAboveEmb_apply, not_exists, not_and]\n          have hj := j.2\n          rw [mem_uncontracted_iff_not_contracted] at hj\n          intro a ha hja\n          rw [Function.Injective.eq_iff (Fin.succAbove_right_injective)] at hja\n          subst hja\n          exact False.elim (hj a' ha' ha)\n      | Or.inr ha, Or.inr hb =>\n        simp_all only [f, Finset.le_eq_subset,\n          or_true, Finset.mem_map, RelEmbedding.coe_toEmbedding]\n        obtain \u27e8a', ha', ha''\u27e9 := ha\n        obtain \u27e8b', hb', hb''\u27e9 := hb\n        subst ha''\n        subst hb''\n        simp only [EmbeddingLike.apply_eq_iff_eq]\n        rw [Finset.mapEmbedding_apply, Finset.mapEmbedding_apply, Finset.disjoint_map]\n        exact c.2.2 a' ha' b' hb'\n\nlemma insertAndContractNat_of_isSome (c : WickContraction n) (i : Fin n.succ)\n    (j : Option c.uncontracted) (hj : j.isSome) :\n    (insertAndContractNat c i j).1 = Insert.insert {i, i.succAbove (j.get hj)}\n    (Finset.map (Finset.mapEmbedding i.succAboveEmb).toEmbedding c.1) := by\n  simp only [Nat.succ_eq_add_one, insertAndContractNat, Finset.le_eq_subset]\n  rw [@Option.isSome_iff_exists] at hj\n  obtain \u27e8j, hj\u27e9 := hj\n  subst hj\n  simp\n\n@[simp]\nlemma self_mem_uncontracted_of_insertAndContractNat_none (c : WickContraction n) (i : Fin n.succ) :\n    i \u2208 (insertAndContractNat c i none).uncontracted := by\n  rw [mem_uncontracted_iff_not_contracted]\n  intro p hp\n  simp only [Nat.succ_eq_add_one, insertAndContractNat, Finset.le_eq_subset, Finset.mem_map,\n    RelEmbedding.coe_toEmbedding] at hp\n  obtain \u27e8a, ha, ha'\u27e9 := hp\n  have hc := c.2.1 a ha\n  rw [@Finset.card_eq_two] at hc\n  obtain \u27e8x, y, hxy, ha\u27e9 := hc\n  subst ha\n  subst ha'\n  rw [Finset.mapEmbedding_apply]\n  simp only [Nat.succ_eq_add_one, Finset.map_insert, Fin.succAboveEmb_apply, Finset.map_singleton,\n    Finset.mem_insert, Finset.mem_singleton, not_or]\n  apply And.intro\n  \u00b7 exact Fin.ne_succAbove i x\n  \u00b7 exact Fin.ne_succAbove i y\n\n@[simp]\nlemma self_not_mem_uncontracted_of_insertAndContractNat_some (c : WickContraction n)\n    (i : Fin n.succ) (j : c.uncontracted) :\n    i \u2209 (insertAndContractNat c i (some j)).uncontracted := by\n  rw [mem_uncontracted_iff_not_contracted]\n  simp [insertAndContractNat]\n\nlemma insertAndContractNat_succAbove_mem_uncontracted_iff (c : WickContraction n) (i : Fin n.succ)\n    (j : Fin n) :\n    (i.succAbove j) \u2208 (insertAndContractNat c i none).uncontracted \u2194 j \u2208 c.uncontracted := by\n  rw [mem_uncontracted_iff_not_contracted, mem_uncontracted_iff_not_contracted]\n  simp only [Nat.succ_eq_add_one, insertAndContractNat, Finset.le_eq_subset, Finset.mem_map,\n    RelEmbedding.coe_toEmbedding, forall_exists_index, and_imp, forall_apply_eq_imp_iff\u2082]\n  apply Iff.intro\n  \u00b7 intro h p hp\n    have hp' := h p hp\n    have hc := c.2.1 p hp\n    rw [Finset.card_eq_two] at hc\n    obtain \u27e8x, y, hxy, hp\u27e9 := hc\n    subst hp\n    rw [Finset.mapEmbedding_apply] at hp'\n    simp only [Finset.map_insert, Fin.succAboveEmb_apply, Finset.map_singleton, Finset.mem_insert,\n      Finset.mem_singleton, not_or] at hp'\n    simp only [Finset.mem_insert, Finset.mem_singleton, not_or]\n    exact And.intro (fun a => hp'.1 (congrArg i.succAbove a))\n      (fun a => hp'.2 (congrArg i.succAbove a))\n  \u00b7 intro h p hp\n    have hc := c.2.1 p hp\n    rw [Finset.card_eq_two] at hc\n    obtain \u27e8x, y, hxy, hp\u27e9 := hc\n    subst hp\n    rw [Finset.mapEmbedding_apply]\n    simp only [Finset.map_insert, Fin.succAboveEmb_apply, Finset.map_singleton, Finset.mem_insert,\n      Finset.mem_singleton, not_or]\n    have hp' := h {x, y} hp\n    simp only [Finset.mem_insert, Finset.mem_singleton, not_or] at hp'\n    apply And.intro\n      (fun a => hp'.1 (i.succAbove_right_injective a))\n      (fun a => hp'.2 (i.succAbove_right_injective a))\n\n@[simp]\nlemma mem_uncontracted_insertAndContractNat_none_iff (c : WickContraction n) (i : Fin n.succ)\n    (k : Fin n.succ) : k \u2208 (insertAndContractNat c i none).uncontracted \u2194\n    k = i \u2228 \u2203 j, k = i.succAbove j \u2227 j \u2208 c.uncontracted := by\n  by_cases hi : k = i\n  \u00b7 subst hi\n    simp\n  \u00b7 simp only [Nat.succ_eq_add_one, \u2190 Fin.exists_succAbove_eq_iff] at hi\n    obtain \u27e8z, hk\u27e9 := hi\n    subst hk\n    have hn : \u00ac i.succAbove z = i := Fin.succAbove_ne i z\n    simp only [Nat.succ_eq_add_one, insertAndContractNat_succAbove_mem_uncontracted_iff, hn,\n      false_or]\n    apply Iff.intro\n    \u00b7 intro h\n      exact \u27e8z, rfl, h\u27e9\n    \u00b7 intro h\n      obtain \u27e8j, hk\u27e9 := h\n      have hjk : z = j := Fin.succAbove_right_inj.mp hk.1\n      subst hjk\n      exact hk.2\n\nlemma insertAndContractNat_none_uncontracted (c : WickContraction n) (i : Fin n.succ) :\n    (insertAndContractNat c i none).uncontracted =\n    Insert.insert i (c.uncontracted.map i.succAboveEmb) := by\n  ext a\n  simp only [Nat.succ_eq_add_one, mem_uncontracted_insertAndContractNat_none_iff, Finset.mem_insert,\n    Finset.mem_map, Fin.succAboveEmb_apply]\n  apply Iff.intro\n  \u00b7 intro a_1\n    cases a_1 with\n    | inl h =>\n      subst h\n      simp_all only [true_or]\n    | inr h_1 =>\n      obtain \u27e8w, h\u27e9 := h_1\n      obtain \u27e8left, right\u27e9 := h\n      subst left\n      apply Or.inr\n      apply Exists.intro\n      \u00b7 apply And.intro\n        on_goal 2 => {rfl\n        }\n        \u00b7 simp_all only\n  \u00b7 intro a_1\n    cases a_1 with\n    | inl h =>\n      subst h\n      simp_all only [true_or]\n    | inr h_1 =>\n      obtain \u27e8w, h\u27e9 := h_1\n      obtain \u27e8left, right\u27e9 := h\n      subst right\n      apply Or.inr\n      apply Exists.intro\n      \u00b7 apply And.intro\n        on_goal 2 => {exact left\n        }\n        \u00b7 simp_all only\n\n@[simp]\nlemma mem_uncontracted_insertAndContractNat_some_iff (c : WickContraction n) (i : Fin n.succ)\n    (k : Fin n.succ) (j : c.uncontracted) :\n    k \u2208 (insertAndContractNat c i (some j)).uncontracted \u2194\n    \u2203 z, k = i.succAbove z \u2227 z \u2208 c.uncontracted \u2227 z \u2260 j := by\n  by_cases hki : k = i\n  \u00b7 subst hki\n    simp only [Nat.succ_eq_add_one, self_not_mem_uncontracted_of_insertAndContractNat_some, ne_eq,\n      false_iff, not_exists, not_and, Decidable.not_not]\n    exact fun x hx => False.elim (Fin.ne_succAbove k x hx)\n  \u00b7 simp only [Nat.succ_eq_add_one, \u2190 Fin.exists_succAbove_eq_iff] at hki\n    obtain \u27e8z, hk\u27e9 := hki\n    subst hk\n    by_cases hjz : j = z\n    \u00b7 subst hjz\n      rw [mem_uncontracted_iff_not_contracted]\n      simp only [Nat.succ_eq_add_one, insertAndContractNat, Finset.le_eq_subset, Finset.mem_insert,\n        Finset.mem_map, RelEmbedding.coe_toEmbedding, forall_eq_or_imp, Finset.mem_singleton,\n        or_true, not_true_eq_false, forall_exists_index, and_imp, forall_apply_eq_imp_iff\u2082,\n        false_and, ne_eq, false_iff, not_exists, not_and, Decidable.not_not]\n      intro x\n      rw [Function.Injective.eq_iff (Fin.succAbove_right_injective)]\n      exact fun a _a => a.symm\n    \u00b7 apply Iff.intro\n      \u00b7 intro h\n        use z\n        simp only [Nat.succ_eq_add_one, ne_eq, true_and]\n        refine And.intro ?_ (fun a => hjz a.symm)\n        rw [mem_uncontracted_iff_not_contracted]\n        intro p hp\n        rw [mem_uncontracted_iff_not_contracted] at h\n        simp only [Nat.succ_eq_add_one, insertAndContractNat, Finset.le_eq_subset,\n          Finset.mem_insert, Finset.mem_map, RelEmbedding.coe_toEmbedding, forall_eq_or_imp,\n          Finset.mem_singleton, not_or, forall_exists_index, and_imp, forall_apply_eq_imp_iff\u2082] at h\n        have hc := h.2 p hp\n        rw [Finset.mapEmbedding_apply] at hc\n        exact (Finset.mem_map' (i.succAboveEmb)).mpr.mt hc\n      \u00b7 intro h\n        obtain \u27e8z', hz'1, hz'\u27e9 := h\n        rw [Function.Injective.eq_iff (Fin.succAbove_right_injective)] at hz'1\n        subst hz'1\n        rw [mem_uncontracted_iff_not_contracted]\n        simp only [Nat.succ_eq_add_one, insertAndContractNat, Finset.le_eq_subset,\n          Finset.mem_insert, Finset.mem_map, RelEmbedding.coe_toEmbedding, forall_eq_or_imp,\n          Finset.mem_singleton, not_or, forall_exists_index, and_imp, forall_apply_eq_imp_iff\u2082]\n        apply And.intro\n        \u00b7 rw [Function.Injective.eq_iff (Fin.succAbove_right_injective)]\n          exact And.intro (Fin.succAbove_ne i z) (fun a => hjz a.symm)\n        \u00b7 rw [mem_uncontracted_iff_not_contracted] at hz'\n          exact fun a ha hc => hz'.1 a ha ((Finset.mem_map' (i.succAboveEmb)).mp hc)\n\nlemma insertAndContractNat_some_uncontracted (c : WickContraction n) (i : Fin n.succ)\n    (j : c.uncontracted) :\n    (insertAndContractNat c i (some j)).uncontracted =\n    (c.uncontracted.erase j).map i.succAboveEmb := by\n  ext a\n  simp only [Nat.succ_eq_add_one, mem_uncontracted_insertAndContractNat_some_iff, ne_eq,\n    Finset.map_erase, Fin.succAboveEmb_apply, Finset.mem_erase, Finset.mem_map]\n  apply Iff.intro\n  \u00b7 intro h\n    obtain \u27e8z, h1, h2, h3\u27e9 := h\n    subst h1\n    rw [Function.Injective.eq_iff (Fin.succAbove_right_injective)]\n    simp only [h3, not_false_eq_true, true_and]\n    use z\n  \u00b7 intro h\n    obtain \u27e8z, h1, h2\u27e9 := h.2\n    use z\n    subst h2\n    simp only [true_and]\n    obtain \u27e8a, ha1, ha2\u27e9 := h.2\n    rw [Function.Injective.eq_iff (Fin.succAbove_right_injective)] at ha2\n    subst ha2\n    simp_all only [true_and]\n    rw [Function.Injective.eq_iff (Fin.succAbove_right_injective)] at h\n    exact h.1\n\n/-!\n\n## Insert and getDual?\n\n-/\n\nlemma insertAndContractNat_none_getDual?_isNone (c : WickContraction n) (i : Fin n.succ) :\n    ((insertAndContractNat c i none).getDual? i).isNone := by\n  have hi : i \u2208 (insertAndContractNat c i none).uncontracted := by\n    simp\n  simp only [Nat.succ_eq_add_one, uncontracted, Finset.mem_filter, Finset.mem_univ, true_and] at hi\n  rw [hi]\n  simp\n\n@[simp]\nlemma insertAndContractNat_none_getDual?_eq_none (c : WickContraction n) (i : Fin n.succ) :\n    (insertAndContractNat c i none).getDual? i = none := by\n  have hi : i \u2208 (insertAndContractNat c i none).uncontracted := by\n    simp\n  simp only [Nat.succ_eq_add_one, uncontracted, Finset.mem_filter, Finset.mem_univ, true_and] at hi\n  rw [hi]\n\n@[simp]\nlemma insertAndContractNat_succAbove_getDual?_eq_none_iff (c : WickContraction n) (i : Fin n.succ)\n    (j : Fin n) :\n    (insertAndContractNat c i none).getDual? (i.succAbove j) = none \u2194 c.getDual? j = none := by\n  have h1 := insertAndContractNat_succAbove_mem_uncontracted_iff c i j\n  simpa [uncontracted] using h1\n\n@[simp]\nlemma insertAndContractNat_succAbove_getDual?_isSome_iff (c : WickContraction n) (i : Fin n.succ)\n    (j : Fin n) :\n    ((insertAndContractNat c i none).getDual? (i.succAbove j)).isSome \u2194 (c.getDual? j).isSome := by\n  rw [\u2190 not_iff_not]\n  simp\n\n@[simp]\nlemma insertAndContractNat_succAbove_getDual?_get (c : WickContraction n) (i : Fin n.succ)\n    (j : Fin n) (h : ((insertAndContractNat c i none).getDual? (i.succAbove j)).isSome) :\n    ((insertAndContractNat c i none).getDual? (i.succAbove j)).get h =\n    i.succAbove ((c.getDual? j).get (by simpa using h)) := by\n  have h1 : (insertAndContractNat c i none).getDual? (i.succAbove j) = some\n      (i.succAbove ((c.getDual? j).get (by simpa using h))) := by\n    rw [getDual?_eq_some_iff_mem]\n    simp only [Nat.succ_eq_add_one, insertAndContractNat, Finset.le_eq_subset, Finset.mem_map,\n      RelEmbedding.coe_toEmbedding]\n    use {j, ((c.getDual? j).get (by simpa using h))}\n    simp only [self_getDual?_get_mem, true_and]\n    rw [Finset.mapEmbedding_apply]\n    simp\n  exact Option.get_of_mem h h1\n\n@[simp]\nlemma insertAndContractNat_some_getDual?_eq (c : WickContraction n) (i : Fin n.succ)\n    (j : c.uncontracted) :\n    (insertAndContractNat c i (some j)).getDual? i = some (i.succAbove j) := by\n  rw [getDual?_eq_some_iff_mem]\n  simp [insertAndContractNat]\n\n@[simp]\nlemma insertAndContractNat_some_getDual?_neq_none (c : WickContraction n) (i : Fin n.succ)\n    (j : c.uncontracted) (k : Fin n) (hkj : k \u2260 j.1) :\n    (insertAndContractNat c i (some j)).getDual? (i.succAbove k) = none \u2194 c.getDual? k = none := by\n  apply Iff.intro\n  \u00b7 intro h\n    have hk : (i.succAbove k) \u2208 (insertAndContractNat c i (some j)).uncontracted := by\n      simp only [Nat.succ_eq_add_one, uncontracted, Finset.mem_filter, Finset.mem_univ, true_and]\n      exact h\n    simp only [Nat.succ_eq_add_one, mem_uncontracted_insertAndContractNat_some_iff, ne_eq] at hk\n    obtain \u27e8z, hz1, hz2, hz3\u27e9 := hk\n    rw [Function.Injective.eq_iff (Fin.succAbove_right_injective)] at hz1\n    subst hz1\n    simpa [uncontracted] using hz2\n  \u00b7 intro h\n    have hk : (i.succAbove k) \u2208 (insertAndContractNat c i (some j)).uncontracted := by\n      simp only [Nat.succ_eq_add_one, mem_uncontracted_insertAndContractNat_some_iff, ne_eq]\n      use k\n      simp only [hkj, not_false_eq_true, and_true, true_and]\n      simpa [uncontracted] using h\n    simpa [uncontracted, -mem_uncontracted_insertAndContractNat_some_iff, ne_eq] using hk\n\n@[simp]\nlemma insertAndContractNat_some_getDual?_neq_isSome (c : WickContraction n) (i : Fin n.succ)\n    (j : c.uncontracted) (k : Fin n) (hkj : k \u2260 j.1) :\n    ((insertAndContractNat c i (some j)).getDual? (i.succAbove k)).isSome \u2194\n    (c.getDual? k).isSome := by\n  rw [\u2190 not_iff_not]\n  simp [hkj]\n\n@[simp]\nlemma insertAndContractNat_some_getDual?_neq_isSome_get (c : WickContraction n) (i : Fin n.succ)\n    (j : c.uncontracted) (k : Fin n) (hkj : k \u2260 j.1)\n    (h : ((insertAndContractNat c i (some j)).getDual? (i.succAbove k)).isSome) :\n    ((insertAndContractNat c i (some j)).getDual? (i.succAbove k)).get h =\n    i.succAbove ((c.getDual? k).get (by simpa [hkj] using h)) := by\n  have h1 : ((insertAndContractNat c i (some j)).getDual? (i.succAbove k))\n    = some (i.succAbove ((c.getDual? k).get (by simpa [hkj] using h))) := by\n    rw [getDual?_eq_some_iff_mem]\n    simp only [Nat.succ_eq_add_one, insertAndContractNat, Finset.le_eq_subset, Finset.mem_insert,\n      Finset.mem_map, RelEmbedding.coe_toEmbedding]\n    apply Or.inr\n    use { k, ((c.getDual? k).get (by simpa [hkj] using h))}\n    simp only [self_getDual?_get_mem, true_and]\n    rw [Finset.mapEmbedding_apply]\n    simp\n  exact Option.get_of_mem h h1\n\n@[simp]\nlemma insertAndContractNat_some_getDual?_of_neq (c : WickContraction n) (i : Fin n.succ)\n    (j : c.uncontracted) (k : Fin n) (hkj : k \u2260 j.1) :\n    (insertAndContractNat c i (some j)).getDual? (i.succAbove k) =\n    Option.map i.succAbove (c.getDual? k) := by\n  by_cases h : (c.getDual? k).isSome\n  \u00b7 have h1 : (c.insertAndContractNat i (some j)).getDual? (i.succAbove k) =\n        some (i.succAbove ((c.getDual? k).get h)) := by\n      rw [\u2190 insertAndContractNat_some_getDual?_neq_isSome_get c i j k hkj]\n      refine Eq.symm (Option.some_get ?_)\n      simpa [hkj] using h\n    rw [h1]\n    have h2 :(c.getDual? k) = some ((c.getDual? k).get h) := by simp\n    conv_rhs => rw [h2]\n    rw [@Option.map_coe']\n  \u00b7 simp only [Bool.not_eq_true, Option.not_isSome, Option.isNone_iff_eq_none] at h\n    simp only [Nat.succ_eq_add_one, h, Option.map_none']\n    simp only [ne_eq, hkj, not_false_eq_true, insertAndContractNat_some_getDual?_neq_none]\n    exact h\n\n/-!\n\n## Interaction with erase.\n\n-/\n@[simp]\nlemma insertAndContractNat_erase (c : WickContraction n) (i : Fin n.succ)\n    (j : Option c.uncontracted) : erase (insertAndContractNat c i j) i = c := by\n  refine Subtype.eq ?_\n  simp only [erase, Nat.succ_eq_add_one, insertAndContractNat, Finset.le_eq_subset]\n  conv_rhs => rw [c.eq_filter_mem_self]\n  refine Finset.filter_inj'.mpr ?_\n  intro a _\n  match j with\n  | none =>\n    simp only [Finset.mem_map, RelEmbedding.coe_toEmbedding]\n    apply Iff.intro\n    \u00b7 intro ha\n      obtain \u27e8a', ha', ha''\u27e9 := ha\n      rw [Finset.mapEmbedding_apply] at ha''\n      simp only [Finset.map_inj] at ha''\n      subst ha''\n      exact ha'\n    \u00b7 intro ha\n      use a\n      simp only [ha, true_and]\n      rw [Finset.mapEmbedding_apply]\n  | some j =>\n    simp only [Finset.mem_insert, Finset.mem_map, RelEmbedding.coe_toEmbedding]\n    apply Iff.intro\n    \u00b7 intro ha\n      rcases ha with ha | ha\n      \u00b7 have hin : \u00ac i \u2208 Finset.map i.succAboveEmb a := by\n          simp only [Nat.succ_eq_add_one, Finset.mem_map, Fin.succAboveEmb_apply, not_exists,\n            not_and]\n          intro x\n          exact fun a => Fin.succAbove_ne i x\n        refine False.elim (hin ?_)\n        rw [ha]\n        simp\n      \u00b7 obtain \u27e8a', ha', ha''\u27e9 := ha\n        rw [Finset.mapEmbedding_apply] at ha''\n        simp only [Finset.map_inj] at ha''\n        subst ha''\n        exact ha'\n    \u00b7 intro ha\n      apply Or.inr\n      use a\n      simp only [ha, true_and]\n      rw [Finset.mapEmbedding_apply]\n\nlemma insertAndContractNat_getDualErase (c : WickContraction n) (i : Fin n.succ)\n    (j : Option c.uncontracted) : (insertAndContractNat c i j).getDualErase i =\n    uncontractedCongr (c := c) (c' := (c.insertAndContractNat i j).erase i) (by simp) j := by\n  match n with\n  | 0 =>\n    simp only [insertAndContractNat, Nat.succ_eq_add_one, Nat.reduceAdd, Finset.le_eq_subset,\n      getDualErase]\n    fin_cases j\n    simp\n  | Nat.succ n =>\n  match j with\n  | none =>\n    simp [getDualErase]\n  | some j =>\n    simp only [Nat.succ_eq_add_one, getDualErase, insertAndContractNat_some_getDual?_eq,\n      Option.isSome_some, \u2193reduceDIte, Option.get_some, predAboveI_succAbove,\n      uncontractedCongr_some, Option.some.injEq]\n    rfl\n\n@[simp]\nlemma erase_insert (c : WickContraction n.succ) (i : Fin n.succ) :\n    insertAndContractNat (erase c i) i (getDualErase c i) = c := by\n  match n with\n  | 0 =>\n    apply Subtype.eq\n    simp only [Nat.succ_eq_add_one, Nat.reduceAdd, insertAndContractNat, getDualErase,\n      Finset.le_eq_subset]\n    ext a\n    simp only [Finset.mem_map, RelEmbedding.coe_toEmbedding]\n    apply Iff.intro\n    \u00b7 intro h\n      simp only [erase, Nat.reduceAdd, Nat.succ_eq_add_one, Finset.mem_filter, Finset.mem_univ,\n        true_and] at h\n      obtain \u27e8a', ha', ha''\u27e9 := h\n      subst ha''\n      exact ha'\n    \u00b7 intro ha\n      obtain \u27e8a, ha\u27e9 := c.mem_not_eq_erase_of_isNone (a := a) i (by simp) ha\n      simp_all only [Nat.succ_eq_add_one]\n      obtain \u27e8left, right\u27e9 := ha\n      subst right\n      apply Exists.intro\n      \u00b7 apply And.intro\n        on_goal 2 => {rfl\n        }\n        \u00b7 simp_all only\n  | Nat.succ n =>\n  apply Subtype.eq\n  by_cases hi : (c.getDual? i).isSome\n  \u00b7 rw [insertAndContractNat_of_isSome]\n    simp only [Nat.succ_eq_add_one, getDualErase, hi, \u2193reduceDIte, Option.get_some,\n      Finset.le_eq_subset]\n    rw [succsAbove_predAboveI]\n    ext a\n    apply Iff.intro\n    \u00b7 simp only [Finset.mem_insert, Finset.mem_map, RelEmbedding.coe_toEmbedding]\n      intro ha\n      rcases ha with ha | ha\n      \u00b7 subst ha\n        simp\n      \u00b7 obtain \u27e8a', ha', ha''\u27e9 := ha\n        subst ha''\n        simpa [erase] using ha'\n    \u00b7 intro ha\n      simp only [Finset.mem_insert, Finset.mem_map, RelEmbedding.coe_toEmbedding]\n      by_cases hia : a = {i, (c.getDual? i).get hi}\n      \u00b7 subst hia\n        simp\n      \u00b7 apply Or.inr\n        simp only [erase, Nat.succ_eq_add_one, Finset.mem_filter, Finset.mem_univ, true_and]\n        obtain \u27e8a', ha'\u27e9 := c.mem_not_eq_erase_of_isSome (a := a) i hi ha hia\n        use a'\n        simp_all only [Nat.succ_eq_add_one, true_and]\n        obtain \u27e8left, right\u27e9 := ha'\n        subst right\n        rfl\n    simp only [Nat.succ_eq_add_one, ne_eq, self_neq_getDual?_get, not_false_eq_true]\n    exact (getDualErase_isSome_iff_getDual?_isSome c i).mpr hi\n  \u00b7 simp only [Nat.succ_eq_add_one, insertAndContractNat, getDualErase, hi, Bool.false_eq_true,\n    \u2193reduceDIte, Finset.le_eq_subset]\n    ext a\n    simp only [Finset.mem_map, RelEmbedding.coe_toEmbedding]\n    apply Iff.intro\n    \u00b7 intro h\n      simp only [erase, Nat.succ_eq_add_one, Finset.mem_filter, Finset.mem_univ, true_and] at h\n      obtain \u27e8a', ha', ha''\u27e9 := h\n      subst ha''\n      exact ha'\n    \u00b7 intro ha\n      obtain \u27e8a, ha\u27e9 := c.mem_not_eq_erase_of_isNone (a := a) i (by simpa using hi) ha\n      simp_all only [Nat.succ_eq_add_one, Bool.not_eq_true, Option.not_isSome,\n        Option.isNone_iff_eq_none]\n      obtain \u27e8left, right\u27e9 := ha\n      subst right\n      apply Exists.intro\n      \u00b7 apply And.intro\n        on_goal 2 => {rfl\n        }\n        \u00b7 simp_all only\n\n/-- Lifts a contraction in `c` to a contraction in `(c.insert i j)`. -/\ndef insertLift {c : WickContraction n} (i : Fin n.succ) (j : Option (c.uncontracted))\n    (a : c.1) : (c.insertAndContractNat i j).1 := \u27e8a.1.map (Fin.succAboveEmb i), by\n  simp only [Nat.succ_eq_add_one, insertAndContractNat, Finset.le_eq_subset]\n  match j with\n  | none =>\n    simp only [Finset.mem_map, RelEmbedding.coe_toEmbedding]\n    use a\n    simp only [a.2, true_and]\n    rfl\n  | some j =>\n    simp only [Finset.mem_insert, Finset.mem_map, RelEmbedding.coe_toEmbedding]\n    apply Or.inr\n    use a\n    simp only [a.2, true_and]\n    rfl\u27e9\n\n", "theoremStatement": "lemma insertLift_injective {c : WickContraction n} (i : Fin n.succ) (j : Option (c.uncontracted)) :\n    Function.Injective (insertLift i j) ", "theoremName": "WickContraction.insertLift_injective", "fileCreated": {"commit": "fa7536bea9b5acc23e09f201a7765792caebb199", "date": "2025-01-24"}, "theoremCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "file": "HepLean/HepLean/PerturbationTheory/WickContraction/InsertAndContractNat.lean", "module": "HepLean.PerturbationTheory.WickContraction.InsertAndContractNat", "jsonFile": "HepLean.PerturbationTheory.WickContraction.InsertAndContractNat.jsonl", "positionMetadata": {"lineInFile": 628, "tokenPositionInFile": 24399, "theoremPositionInFile": 23}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 4, "numPremises": 37}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  intro a b hab\n  simp only [Nat.succ_eq_add_one, insertLift, Subtype.mk.injEq, Finset.map_inj] at hab\n  exact Subtype.eq hab", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 131}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport Mathlib.Algebra.BigOperators.Group.Finset.Basic\n/-!\n\n# Creation and annihilation parts of fields\n\n-/\n\n/-- The type `CreateAnnihilate` is the type containing two elements `create` and `annihilate`.\n  This type is used to specify if an operator is a creation, or annihilation, operator\n  or the sum thereof or integral thereover etc. -/\ninductive CreateAnnihilate where\n  | create : CreateAnnihilate\n  | annihilate : CreateAnnihilate\nderiving Inhabited, BEq, DecidableEq\n\nnamespace CreateAnnihilate\n\n/-- The type `CreateAnnihilate` is finite. -/\ninstance : Fintype CreateAnnihilate where\n  elems := {create, annihilate}\n  complete := by\n    intro c\n    cases c\n    \u00b7 exact Finset.mem_insert_self create {annihilate}\n    \u00b7 refine Finset.insert_eq_self.mp ?_\n      exact rfl\n\nlemma eq_create_or_annihilate (\u03c6 : CreateAnnihilate) : \u03c6 = create \u2228 \u03c6 = annihilate := by\n  cases \u03c6 <;> simp\n\n/-- The normal ordering on creation and annihilation operators.\n  Under this relation, `normalOrder a b` is false only if `a` is annihilate and `b` is create. -/\ndef normalOrder : CreateAnnihilate \u2192 CreateAnnihilate \u2192 Prop\n  | create, _ => True\n  | annihilate, annihilate => True\n  | annihilate, create => False\n\n/-- The normal ordering on `CreateAnnihilate` is decidable. -/\ninstance : (\u03c6 \u03c6' : CreateAnnihilate) \u2192 Decidable (normalOrder \u03c6 \u03c6')\n  | create, create => isTrue True.intro\n  | annihilate, annihilate => isTrue True.intro\n  | create, annihilate => isTrue True.intro\n  | annihilate, create => isFalse False.elim\n\n/-- Normal ordering is total. -/\ninstance : IsTotal CreateAnnihilate normalOrder where\n  total a b := by\n    cases a <;> cases b <;> simp [normalOrder]\n\n/-- Normal ordering is transitive. -/\ninstance : IsTrans CreateAnnihilate normalOrder where\n  trans a b c := by\n    cases a <;> cases b <;> cases c <;> simp [normalOrder]\n\n@[simp]\nlemma not_normalOrder_annihilate_iff_false (a : CreateAnnihilate) :\n    (\u00ac normalOrder a annihilate) \u2194 False := by\n  cases a\n  \u00b7 simp [normalOrder]\n  \u00b7 simp [normalOrder]\n\n", "theoremStatement": "lemma sum_eq {M : Type} [AddCommMonoid M] (f : CreateAnnihilate \u2192 M) :\n    \u2211 i, f i = f create + f annihilate ", "theoremName": "CreateAnnihilate.sum_eq", "fileCreated": {"commit": "fb311354268a39f2884e1b3c07dc698145717b46", "date": "2025-01-06"}, "theoremCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "file": "HepLean/HepLean/PerturbationTheory/CreateAnnihilate.lean", "module": "HepLean.PerturbationTheory.CreateAnnihilate", "jsonFile": "HepLean.PerturbationTheory.CreateAnnihilate.jsonl", "positionMetadata": {"lineInFile": 67, "tokenPositionInFile": 2177, "theoremPositionInFile": 2}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 5, "repositoryPremises": true, "numRepositoryPremises": 5, "numPremises": 39}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  change \u2211 i \u2208 {create, annihilate}, f i = f create + f annihilate\n  simp", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 79}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.Basic\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.Grading\n/-!\n\n# Super Commute\n-/\n\nnamespace FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\nnamespace FieldOpFreeAlgebra\n\n/-!\n\n## The super commutator on the FieldOpFreeAlgebra.\n\n-/\n\nopen FieldStatistic\n\n/-- For a field specification `\ud835\udcd5`, the super commutator `superCommuteF` is defined as the linear\n  map `\ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102] \ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102] \ud835\udcd5.FieldOpFreeAlgebra`\n  which on the lists `\u03c6s` and `\u03c6s'` of `\ud835\udcd5.CrAnFieldOp` gives\n\n  `superCommuteF \u03c6s \u03c6s' = \u03c6s * \u03c6s' - \ud835\udce2(\u03c6s, \u03c6s') \u2022 \u03c6s' * \u03c6s`.\n\n  The notation `[a, b]\u209bca` can be used for `superCommuteF a b`. -/\nnoncomputable def superCommuteF : \ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102] \ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102]\n    \ud835\udcd5.FieldOpFreeAlgebra :=\n  Basis.constr ofCrAnListFBasis \u2102 fun \u03c6s =>\n  Basis.constr ofCrAnListFBasis \u2102 fun \u03c6s' =>\n  ofCrAnListF (\u03c6s ++ \u03c6s') - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnListF (\u03c6s' ++ \u03c6s)\n\n@[inherit_doc superCommuteF]\nscoped[FieldSpecification.FieldOpFreeAlgebra] notation \"[\" \u03c6s \",\" \u03c6s' \"]\u209bca\" => superCommuteF \u03c6s \u03c6s'\n\n/-!\n\n## The super commutator of different types of elements\n\n-/\n\nlemma superCommuteF_ofCrAnListF_ofCrAnListF (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnListF \u03c6s, ofCrAnListF \u03c6s']\u209bca =\n    ofCrAnListF (\u03c6s ++ \u03c6s') - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnListF (\u03c6s' ++ \u03c6s) := by\n  rw [\u2190 ofListBasis_eq_ofList, \u2190 ofListBasis_eq_ofList]\n  simp only [superCommuteF, Basis.constr_basis]\n\nlemma superCommuteF_ofCrAnOpF_ofCrAnOpF (\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnOpF \u03c6, ofCrAnOpF \u03c6']\u209bca =\n    ofCrAnOpF \u03c6 * ofCrAnOpF \u03c6' - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 ofCrAnOpF \u03c6' * ofCrAnOpF \u03c6 := by\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton]\n  rw [superCommuteF_ofCrAnListF_ofCrAnListF, ofCrAnListF_append]\n  congr\n  rw [ofCrAnListF_append]\n  rw [FieldStatistic.ofList_singleton, FieldStatistic.ofList_singleton, smul_mul_assoc]\n\nlemma superCommuteF_ofCrAnListF_ofFieldOpFsList (\u03c6cas : List \ud835\udcd5.CrAnFieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [ofCrAnListF \u03c6cas, ofFieldOpListF \u03c6s]\u209bca = ofCrAnListF \u03c6cas * ofFieldOpListF \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6cas, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpListF \u03c6s * ofCrAnListF \u03c6cas := by\n  conv_lhs => rw [ofFieldOpListF_sum]\n  rw [map_sum]\n  conv_lhs =>\n    enter [2, x]\n    rw [superCommuteF_ofCrAnListF_ofCrAnListF, CrAnSection.statistics_eq_state_statistics,\n      ofCrAnListF_append, ofCrAnListF_append]\n  rw [Finset.sum_sub_distrib, \u2190 Finset.mul_sum, \u2190 Finset.smul_sum,\n    \u2190 Finset.sum_mul, \u2190 ofFieldOpListF_sum]\n  simp\n\nlemma superCommuteF_ofFieldOpListF_ofFieldOpFsList (\u03c6 : List \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [ofFieldOpListF \u03c6, ofFieldOpListF \u03c6s]\u209bca = ofFieldOpListF \u03c6 * ofFieldOpListF \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpListF \u03c6s * ofFieldOpListF \u03c6 := by\n  conv_lhs => rw [ofFieldOpListF_sum]\n  simp only [map_sum, LinearMap.coeFn_sum, Finset.sum_apply, instCommGroup.eq_1,\n    Algebra.smul_mul_assoc]\n  conv_lhs =>\n    enter [2, x]\n    rw [superCommuteF_ofCrAnListF_ofFieldOpFsList]\n  simp only [instCommGroup.eq_1, CrAnSection.statistics_eq_state_statistics,\n    Algebra.smul_mul_assoc, Finset.sum_sub_distrib]\n  rw [\u2190 Finset.sum_mul, \u2190 Finset.smul_sum, \u2190 Finset.mul_sum, \u2190 ofFieldOpListF_sum]\n\nlemma superCommuteF_ofFieldOpF_ofFieldOpFsList (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [ofFieldOpF \u03c6, ofFieldOpListF \u03c6s]\u209bca = ofFieldOpF \u03c6 * ofFieldOpListF \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpListF \u03c6s * ofFieldOpF \u03c6 := by\n  rw [\u2190 ofFieldOpListF_singleton, superCommuteF_ofFieldOpListF_ofFieldOpFsList,\n    ofFieldOpListF_singleton]\n  simp\n\nlemma superCommuteF_ofFieldOpListF_ofFieldOpF (\u03c6s : List \ud835\udcd5.FieldOp) (\u03c6 : \ud835\udcd5.FieldOp) :\n    [ofFieldOpListF \u03c6s, ofFieldOpF \u03c6]\u209bca = ofFieldOpListF \u03c6s * ofFieldOpF \u03c6 -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6) \u2022 ofFieldOpF \u03c6 * ofFieldOpListF \u03c6s := by\n  rw [\u2190 ofFieldOpListF_singleton, superCommuteF_ofFieldOpListF_ofFieldOpFsList,\n    ofFieldOpListF_singleton]\n  simp\n\nlemma superCommuteF_anPartF_crPartF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [anPartF \u03c6, crPartF \u03c6']\u209bca = anPartF \u03c6 * crPartF \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 crPartF \u03c6' * anPartF \u03c6 := by\n  match \u03c6, \u03c6' with\n  | FieldOp.inAsymp \u03c6, _ =>\n    simp\n  | _, FieldOp.outAsymp \u03c6 =>\n    simp only [crPartF_posAsymp, map_zero, mul_zero, instCommGroup.eq_1, smul_zero, zero_mul,\n      sub_self]\n  | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n    simp only [anPartF_position, crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.outAsymp \u03c6, FieldOp.position \u03c6' =>\n    simp only [anPartF_posAsymp, crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.position \u03c6, FieldOp.inAsymp \u03c6' =>\n    simp only [anPartF_position, crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp only [List.singleton_append, instCommGroup.eq_1, crAnStatistics,\n      FieldStatistic.ofList_singleton, Function.comp_apply, crAnFieldOpToFieldOp_prod, \u2190\n      ofCrAnListF_append]\n  | FieldOp.outAsymp \u03c6, FieldOp.inAsymp \u03c6' =>\n    simp only [anPartF_posAsymp, crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n\nlemma superCommuteF_crPartF_anPartF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [crPartF \u03c6, anPartF \u03c6']\u209bca = crPartF \u03c6 * anPartF \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 anPartF \u03c6' * crPartF \u03c6 := by\n    match \u03c6, \u03c6' with\n    | FieldOp.outAsymp \u03c6, _ =>\n    simp only [crPartF_posAsymp, map_zero, LinearMap.zero_apply, zero_mul, instCommGroup.eq_1,\n      mul_zero, sub_self]\n    | _, FieldOp.inAsymp \u03c6 =>\n    simp only [anPartF_negAsymp, map_zero, mul_zero, instCommGroup.eq_1, smul_zero, zero_mul,\n      sub_self]\n    | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n    simp only [crPartF_position, anPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n    | FieldOp.position \u03c6, FieldOp.outAsymp \u03c6' =>\n    simp only [crPartF_position, anPartF_posAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n    | FieldOp.inAsymp \u03c6, FieldOp.position \u03c6' =>\n    simp only [crPartF_negAsymp, anPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n    | FieldOp.inAsymp \u03c6, FieldOp.outAsymp \u03c6' =>\n    simp only [crPartF_negAsymp, anPartF_posAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n\nlemma superCommuteF_crPartF_crPartF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [crPartF \u03c6, crPartF \u03c6']\u209bca = crPartF \u03c6 * crPartF \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 crPartF \u03c6' * crPartF \u03c6 := by\n  match \u03c6, \u03c6' with\n  | FieldOp.outAsymp \u03c6, _ =>\n  simp only [crPartF_posAsymp, map_zero, LinearMap.zero_apply, zero_mul, instCommGroup.eq_1,\n    mul_zero, sub_self]\n  | _, FieldOp.outAsymp \u03c6 =>\n  simp only [crPartF_posAsymp, map_zero, mul_zero, instCommGroup.eq_1, smul_zero, zero_mul,\n    sub_self]\n  | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n  simp only [crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.position \u03c6, FieldOp.inAsymp \u03c6' =>\n  simp only [crPartF_position, crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.inAsymp \u03c6, FieldOp.position \u03c6' =>\n  simp only [crPartF_negAsymp, crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.inAsymp \u03c6, FieldOp.inAsymp \u03c6' =>\n  simp only [crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp [crAnStatistics, \u2190 ofCrAnListF_append]\n\nlemma superCommuteF_anPartF_anPartF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [anPartF \u03c6, anPartF \u03c6']\u209bca =\n    anPartF \u03c6 * anPartF \u03c6' - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 anPartF \u03c6' * anPartF \u03c6 := by\n  match \u03c6, \u03c6' with\n  | FieldOp.inAsymp \u03c6, _ =>\n    simp\n  | _, FieldOp.inAsymp \u03c6 =>\n    simp\n  | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n    simp only [anPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.position \u03c6, FieldOp.outAsymp \u03c6' =>\n    simp only [anPartF_position, anPartF_posAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.outAsymp \u03c6, FieldOp.position \u03c6' =>\n    simp only [anPartF_posAsymp, anPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.outAsymp \u03c6, FieldOp.outAsymp \u03c6' =>\n    simp only [anPartF_posAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n\nlemma superCommuteF_crPartF_ofFieldOpListF (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [crPartF \u03c6, ofFieldOpListF \u03c6s]\u209bca =\n    crPartF \u03c6 * ofFieldOpListF \u03c6s - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpListF \u03c6s *\n    crPartF \u03c6 := by\n  match \u03c6 with\n  | FieldOp.inAsymp \u03c6 =>\n    simp only [crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofFieldOpFsList]\n    simp [crAnStatistics]\n  | FieldOp.position \u03c6 =>\n    simp only [crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofFieldOpFsList]\n    simp [crAnStatistics]\n  | FieldOp.outAsymp \u03c6 =>\n    simp\n\nlemma superCommuteF_anPartF_ofFieldOpListF (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [anPartF \u03c6, ofFieldOpListF \u03c6s]\u209bca =\n    anPartF \u03c6 * ofFieldOpListF \u03c6s - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022\n    ofFieldOpListF \u03c6s * anPartF \u03c6 := by\n  match \u03c6 with\n  | FieldOp.inAsymp \u03c6 =>\n    simp\n  | FieldOp.position \u03c6 =>\n    simp only [anPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofFieldOpFsList]\n    simp [crAnStatistics]\n  | FieldOp.outAsymp \u03c6 =>\n    simp only [anPartF_posAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofFieldOpFsList]\n    simp [crAnStatistics]\n\nlemma superCommuteF_crPartF_ofFieldOpF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [crPartF \u03c6, ofFieldOpF \u03c6']\u209bca =\n    crPartF \u03c6 * ofFieldOpF \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 ofFieldOpF \u03c6' * crPartF \u03c6 := by\n  rw [\u2190 ofFieldOpListF_singleton, superCommuteF_crPartF_ofFieldOpListF]\n  simp\n\nlemma superCommuteF_anPartF_ofFieldOpF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [anPartF \u03c6, ofFieldOpF \u03c6']\u209bca =\n    anPartF \u03c6 * ofFieldOpF \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 ofFieldOpF \u03c6' * anPartF \u03c6 := by\n  rw [\u2190 ofFieldOpListF_singleton, superCommuteF_anPartF_ofFieldOpListF]\n  simp\n\n/-!\n\n## Mul equal superCommuteF\n\nLemmas which rewrite a multiplication of two elements of the algebra as their commuted\nmultiplication with a sign plus the super commutator.\n\n-/\nlemma ofCrAnListF_mul_ofCrAnListF_eq_superCommuteF (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnListF \u03c6s * ofCrAnListF \u03c6s' = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnListF \u03c6s' * ofCrAnListF \u03c6s\n    + [ofCrAnListF \u03c6s, ofCrAnListF \u03c6s']\u209bca := by\n  rw [superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp [ofCrAnListF_append]\n\nlemma ofCrAnOpF_mul_ofCrAnListF_eq_superCommuteF (\u03c6 : \ud835\udcd5.CrAnFieldOp) (\u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnOpF \u03c6 * ofCrAnListF \u03c6s' = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnListF \u03c6s' * ofCrAnOpF \u03c6\n    + [ofCrAnOpF \u03c6, ofCrAnListF \u03c6s']\u209bca := by\n  rw [\u2190 ofCrAnListF_singleton, ofCrAnListF_mul_ofCrAnListF_eq_superCommuteF]\n  simp\n\nlemma ofFieldOpListF_mul_ofFieldOpListF_eq_superCommuteF (\u03c6s \u03c6s' : List \ud835\udcd5.FieldOp) :\n    ofFieldOpListF \u03c6s * ofFieldOpListF \u03c6s' =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofFieldOpListF \u03c6s' * ofFieldOpListF \u03c6s\n    + [ofFieldOpListF \u03c6s, ofFieldOpListF \u03c6s']\u209bca := by\n  rw [superCommuteF_ofFieldOpListF_ofFieldOpFsList]\n  simp\n\nlemma ofFieldOpF_mul_ofFieldOpListF_eq_superCommuteF (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s' : List \ud835\udcd5.FieldOp) :\n    ofFieldOpF \u03c6 * ofFieldOpListF \u03c6s' = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofFieldOpListF \u03c6s' * ofFieldOpF \u03c6\n    + [ofFieldOpF \u03c6, ofFieldOpListF \u03c6s']\u209bca := by\n  rw [superCommuteF_ofFieldOpF_ofFieldOpFsList]\n  simp\n\nlemma ofFieldOpListF_mul_ofFieldOpF_eq_superCommuteF (\u03c6s : List \ud835\udcd5.FieldOp) (\u03c6 : \ud835\udcd5.FieldOp) :\n    ofFieldOpListF \u03c6s * ofFieldOpF \u03c6 = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6) \u2022 ofFieldOpF \u03c6 * ofFieldOpListF \u03c6s\n    + [ofFieldOpListF \u03c6s, ofFieldOpF \u03c6]\u209bca := by\n  rw [superCommuteF_ofFieldOpListF_ofFieldOpF]\n  simp\n\nlemma crPartF_mul_anPartF_eq_superCommuteF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    crPartF \u03c6 * anPartF \u03c6' =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 anPartF \u03c6' * crPartF \u03c6 +\n    [crPartF \u03c6, anPartF \u03c6']\u209bca := by\n  rw [superCommuteF_crPartF_anPartF]\n  simp\n\n", "theoremStatement": "lemma anPartF_mul_crPartF_eq_superCommuteF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    anPartF \u03c6 * crPartF \u03c6' =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022\n    crPartF \u03c6' * anPartF \u03c6 +\n    [anPartF \u03c6, crPartF \u03c6']\u209bca ", "theoremName": "FieldSpecification.FieldOpFreeAlgebra.anPartF_mul_crPartF_eq_superCommuteF", "fileCreated": {"commit": "ea6e12829370d9630a7e65200c8349e9086c05ba", "date": "2025-02-03"}, "theoremCreated": {"commit": "f7e669910ceee9df476eef0815080acbaa61ee61", "date": "2025-01-30"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpFreeAlgebra/SuperCommute.lean", "module": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.SuperCommute", "jsonFile": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.SuperCommute.jsonl", "positionMetadata": {"lineInFile": 302, "tokenPositionInFile": 14121, "theoremPositionInFile": 22}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 14, "numPremises": 89}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [superCommuteF_anPartF_crPartF]\n  simp", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 49}}
{"srcContext": "/-\nCopyright (c) 2024 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport Mathlib.Algebra.FreeAlgebra\nimport Mathlib.Algebra.Lie.OfAssociative\nimport Mathlib.Analysis.Complex.Basic\nimport HepLean.Mathematics.List.InsertIdx\n/-!\n\n# Field statistics\n\nBasic properties related to whether a field, or list of fields, is bosonic or fermionic.\n\n-/\n\n/-- The type `FieldStatistic` is the type containing two elements `bosonic` and `fermionic`.\n  This type is used to specify if a field or operator obeys bosonic or fermionic statistics. -/\ninductive FieldStatistic : Type where\n  | bosonic : FieldStatistic\n  | fermionic : FieldStatistic\nderiving DecidableEq\n\nnamespace FieldStatistic\n\nvariable {\ud835\udcd5 : Type}\n\n/-- The type `FieldStatistic` carries an instance of a commutative group in which\n- `bosonic * bosonic = bosonic`\n- `bosonic * fermionic = fermionic`\n- `fermionic * bosonic = fermionic`\n- `fermionic * fermionic = bosonic`\n\nThis group is isomorphic to `\u2124\u2082`. -/\n@[simp]\ninstance : CommGroup FieldStatistic where\n  one := bosonic\n  mul a b :=\n    match a, b with\n    | bosonic, bosonic => bosonic\n    | bosonic, fermionic => fermionic\n    | fermionic, bosonic => fermionic\n    | fermionic, fermionic => bosonic\n  inv a := a\n  mul_assoc a b c := by\n    cases a <;> cases b <;> cases c <;>\n    dsimp [HMul.hMul]\n  one_mul a := by\n    cases a <;> dsimp [HMul.hMul]\n  mul_one a := by\n    cases a <;> dsimp [HMul.hMul]\n  inv_mul_cancel a := by\n    cases a <;> dsimp only [HMul.hMul, Nat.succ_eq_add_one] <;> rfl\n  mul_comm a b := by\n    cases a <;> cases b <;> rfl\n\n@[simp]\nlemma bosonic_mul_bosonic : bosonic * bosonic = bosonic := rfl\n\n@[simp]\nlemma bosonic_mul_fermionic : bosonic * fermionic = fermionic := rfl\n\n@[simp]\nlemma fermionic_mul_bosonic : fermionic * bosonic = fermionic := rfl\n\n@[simp]\nlemma fermionic_mul_fermionic : fermionic * fermionic = bosonic := rfl\n\n@[simp]\nlemma mul_bosonic (a : FieldStatistic) : a * bosonic = a := by\n  cases a <;> rfl\n\n@[simp]\nlemma mul_self (a : FieldStatistic) : a * a = 1 := by\n  cases a <;> rfl\n\n/-- Field statics form a finite type. -/\ninstance : Fintype FieldStatistic where\n  elems := {bosonic, fermionic}\n  complete := by\n    intro c\n    cases c\n    \u00b7 exact Finset.mem_insert_self bosonic {fermionic}\n    \u00b7 refine Finset.insert_eq_self.mp ?_\n      exact rfl\n\n@[simp]\nlemma fermionic_not_eq_bonsic : \u00ac fermionic = bosonic := by\n  intro h\n  exact FieldStatistic.noConfusion h\n\nlemma bonsic_eq_fermionic_false : bosonic = fermionic \u2194 false := by\n  simp only [reduceCtorEq, Bool.false_eq_true]\n\n@[simp]\nlemma neq_fermionic_iff_eq_bosonic (a : FieldStatistic) : \u00ac a = fermionic \u2194 a = bosonic := by\n  fin_cases a\n  \u00b7 simp\n  \u00b7 simp\n\n@[simp]\nlemma neq_bosonic_iff_eq_fermionic (a : FieldStatistic) : \u00ac a = bosonic \u2194 a = fermionic := by\n  fin_cases a\n  \u00b7 simp\n  \u00b7 simp\n\n@[simp]\nlemma bosonic_neq_iff_fermionic_eq (a : FieldStatistic) : \u00ac bosonic = a \u2194 fermionic = a := by\n  fin_cases a\n  \u00b7 simp\n  \u00b7 simp\n\n@[simp]\nlemma fermionic_neq_iff_bosonic_eq (a : FieldStatistic) : \u00ac fermionic = a \u2194 bosonic = a := by\n  fin_cases a\n  \u00b7 simp\n  \u00b7 simp\n\nlemma eq_self_if_eq_bosonic {a : FieldStatistic} :\n    (if a = bosonic then bosonic else fermionic) = a := by\n  fin_cases a <;> rfl\n\nlemma eq_self_if_bosonic_eq {a : FieldStatistic} :\n    (if bosonic = a then bosonic else fermionic) = a := by\n  fin_cases a <;> rfl\n\nlemma mul_eq_one_iff (a b : FieldStatistic) : a * b = 1 \u2194 a = b := by\n  fin_cases a <;> fin_cases b <;> simp\n\nlemma one_eq_mul_iff (a b : FieldStatistic) : 1 = a * b \u2194 a = b := by\n  fin_cases a <;> fin_cases b <;> simp\n\nlemma mul_eq_iff_eq_mul (a b c : FieldStatistic) : a * b = c \u2194 a = b * c := by\n  fin_cases a <;> fin_cases b <;> fin_cases c <;>\n    simp only [bosonic_mul_fermionic, fermionic_not_eq_bonsic, mul_self,\n      reduceCtorEq, fermionic_mul_bosonic, true_iff, iff_true]\n  all_goals rfl\n\nlemma mul_eq_iff_eq_mul' (a b c : FieldStatistic) : a * b = c \u2194 b = a * c := by\n  fin_cases a <;> fin_cases b <;> fin_cases c <;>\n    simp only [bosonic_mul_fermionic, fermionic_not_eq_bonsic, mul_self,\n      reduceCtorEq, fermionic_mul_bosonic, true_iff, iff_true]\n  all_goals rfl\n\n/-- The field statistics of a list of fields is fermionic if there is an odd number of fermions,\n  otherwise it is bosonic. -/\ndef ofList (s : \ud835\udcd5 \u2192 FieldStatistic) : (\u03c6s : List \ud835\udcd5) \u2192 FieldStatistic\n  | [] => bosonic\n  | \u03c6 :: \u03c6s => if s \u03c6 = ofList s \u03c6s then bosonic else fermionic\n\nlemma ofList_cons_eq_mul (s : \ud835\udcd5 \u2192 FieldStatistic) (\u03c6 : \ud835\udcd5) (\u03c6s : List \ud835\udcd5) :\n    ofList s (\u03c6 :: \u03c6s) = s \u03c6 * ofList s \u03c6s := by\n  have ha (a b : FieldStatistic) : (if a = b then bosonic else fermionic) = a * b := by\n    fin_cases a <;> fin_cases b <;> rfl\n  exact ha (s \u03c6) (ofList s \u03c6s)\n\nlemma ofList_eq_prod (s : \ud835\udcd5 \u2192 FieldStatistic) : (\u03c6s : List \ud835\udcd5) \u2192\n    ofList s \u03c6s = (List.map s \u03c6s).prod\n  | [] => rfl\n  | \u03c6 :: \u03c6s => by\n    rw [ofList_cons_eq_mul, List.map_cons, List.prod_cons, ofList_eq_prod]\n\n@[simp]\nlemma ofList_singleton (s : \ud835\udcd5 \u2192 FieldStatistic) (\u03c6 : \ud835\udcd5) : ofList s [\u03c6] = s \u03c6 := by\n  simp only [ofList, Fin.isValue]\n  rw [eq_self_if_eq_bosonic]\n\n@[simp]\nlemma ofList_freeMonoid (s : \ud835\udcd5 \u2192 FieldStatistic) (\u03c6 : \ud835\udcd5) : ofList s (FreeMonoid.of \u03c6) = s \u03c6 :=\n  ofList_singleton s \u03c6\n\n@[simp]\nlemma ofList_empty (s : \ud835\udcd5 \u2192 FieldStatistic) : ofList s [] = bosonic := rfl\n\n", "theoremStatement": "@[simp]\nlemma ofList_append (s : \ud835\udcd5 \u2192 FieldStatistic) (\u03c6s \u03c6s' : List \ud835\udcd5) :\n    ofList s (\u03c6s ++ \u03c6s') = if ofList s \u03c6s = ofList s \u03c6s' then bosonic else fermionic ", "theoremName": "FieldStatistic.ofList_append", "fileCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "theoremCreated": {"commit": "83f5fc5e9cd0d22073c4d86838a04ed84144105d", "date": "2024-12-20"}, "file": "HepLean/HepLean/PerturbationTheory/FieldStatistics/Basic.lean", "module": "HepLean.PerturbationTheory.FieldStatistics.Basic", "jsonFile": "HepLean.PerturbationTheory.FieldStatistics.Basic.jsonl", "positionMetadata": {"lineInFile": 176, "tokenPositionInFile": 5359, "theoremPositionInFile": 22}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 7, "repositoryPremises": true, "numRepositoryPremises": 7, "numPremises": 40}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  induction \u03c6s with\n  | nil =>\n    simp only [List.nil_append, ofList_empty, Fin.isValue, eq_self_if_bosonic_eq]\n  | cons a l ih =>\n    have hab (a b c : FieldStatistic) :\n        (if a = (if b = c then bosonic else fermionic) then bosonic else fermionic) =\n        if (if a = b then bosonic else fermionic) = c then bosonic else fermionic := by\n      fin_cases a <;> fin_cases b <;> fin_cases c <;> rfl\n    simp only [List.cons_append, ofList, ih, hab]", "proofType": "tactic", "proofLengthLines": 9, "proofLengthTokens": 459}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.WickContraction.ExtractEquiv\n/-!\n\n# List of uncontracted elements of a Wick contraction\n\n-/\n\nopen FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\nnamespace WickContraction\nvariable {n : \u2115} (c : WickContraction n)\nopen HepLean.List\nopen HepLean.Fin\n\n/-!\n\n## Some properties of lists of fin\n\n-/\n\nlemma fin_list_sorted_monotone_sorted {n m : \u2115} (l: List (Fin n)) (hl : l.Sorted (\u00b7 \u2264 \u00b7))\n    (f : Fin n \u2192 Fin m) (hf : StrictMono f) : ((List.map f l)).Sorted (\u00b7 \u2264 \u00b7) := by\n  induction l with\n  | nil => simp\n  | cons a l ih =>\n    simp only [List.map_cons, List.sorted_cons, List.mem_map, forall_exists_index, and_imp,\n      forall_apply_eq_imp_iff\u2082]\n    apply And.intro\n    \u00b7 simp only [List.sorted_cons] at hl\n      intro b hb\n      have hl1 := hl.1 b hb\n      exact (StrictMono.le_iff_le hf).mpr hl1\n    \u00b7 simp only [List.sorted_cons] at hl\n      exact ih hl.2\n\nlemma fin_list_sorted_succAboveEmb_sorted (l: List (Fin n)) (hl : l.Sorted (\u00b7 \u2264 \u00b7))\n    (i : Fin n.succ) : ((List.map i.succAboveEmb l)).Sorted (\u00b7 \u2264 \u00b7) := by\n  apply fin_list_sorted_monotone_sorted\n  exact hl\n  simp only [Fin.coe_succAboveEmb]\n  exact Fin.strictMono_succAbove i\n\nlemma fin_finset_sort_map_monotone {n m : \u2115} (a : Finset (Fin n)) (f : Fin n \u21aa Fin m)\n    (hf : StrictMono f) : (Finset.sort (\u00b7 \u2264 \u00b7) a).map f =\n    (Finset.sort (\u00b7 \u2264 \u00b7) (a.map f)) := by\n  have h1 : ((Finset.sort (\u00b7 \u2264 \u00b7) a).map f).Sorted (\u00b7 \u2264 \u00b7) := by\n    apply fin_list_sorted_monotone_sorted\n    exact Finset.sort_sorted (fun x1 x2 => x1 \u2264 x2) a\n    exact hf\n  have h2 : ((Finset.sort (\u00b7 \u2264 \u00b7) a).map f).Nodup := by\n    refine (List.nodup_map_iff_inj_on ?_).mpr ?_\n    exact Finset.sort_nodup (fun x1 x2 => x1 \u2264 x2) a\n    intro a ha b hb hf\n    exact f.2 hf\n  have h3 : ((Finset.sort (\u00b7 \u2264 \u00b7) a).map f).toFinset = (a.map f) := by\n    ext a\n    simp\n  rw [\u2190 h3]\n  exact ((List.toFinset_sort (\u00b7 \u2264 \u00b7) h2).mpr h1).symm\n\nlemma fin_list_sorted_split :\n    (l : List (Fin n)) \u2192 (hl : l.Sorted (\u00b7 \u2264 \u00b7)) \u2192 (i : \u2115) \u2192\n    l = l.filter (fun x => x.1 < i) ++ l.filter (fun x => i \u2264 x.1)\n  | [], _, _ => by simp\n  | a :: l, hl, i => by\n    simp only [List.sorted_cons] at hl\n    by_cases ha : a < i\n    \u00b7 conv_lhs => rw [fin_list_sorted_split l hl.2 i]\n      rw [\u2190 List.cons_append]\n      rw [List.filter_cons_of_pos, List.filter_cons_of_neg]\n      simp only [decide_eq_true_eq, not_le, ha]\n      simp [ha]\n    \u00b7 have hx : List.filter (fun x => decide (x.1 < i)) (a :: l) = [] := by\n        simp only [ha, decide_false, Bool.false_eq_true, not_false_eq_true, List.filter_cons_of_neg,\n          List.filter_eq_nil_iff, decide_eq_true_eq, not_lt]\n        intro b hb\n        have hb' := hl.1 b hb\n        omega\n      simp only [hx, List.nil_append]\n      rw [List.filter_cons_of_pos]\n      simp only [List.cons.injEq, true_and]\n      have hl' := fin_list_sorted_split l hl.2 i\n      have hx : List.filter (fun x => decide (x.1 < i)) (l) = [] := by\n        simp only [List.filter_eq_nil_iff, decide_eq_true_eq, not_lt]\n        intro b hb\n        have hb' := hl.1 b hb\n        omega\n      simp only [hx, List.nil_append] at hl'\n      conv_lhs => rw [hl']\n      simp only [decide_eq_true_eq]\n      omega\n\nlemma fin_list_sorted_indexOf_filter_le_mem :\n    (l : List (Fin n)) \u2192 (hl : l.Sorted (\u00b7 \u2264 \u00b7)) \u2192 (i : Fin n) \u2192\n    (hl : i \u2208 l) \u2192\n    List.indexOf i (List.filter (fun x => decide (\u2191i \u2264 \u2191x)) l) = 0\n  | [], _, _, _ => by simp\n  | a :: l, hl, i, hi => by\n    simp only [List.sorted_cons] at hl\n    by_cases ha : i \u2264 a\n    \u00b7 simp only [ha, decide_true, List.filter_cons_of_pos]\n      have ha : a = i := by\n        simp only [List.mem_cons] at hi\n        rcases hi with hi | hi\n        \u00b7 subst hi\n          rfl\n        \u00b7 have hl' := hl.1 i hi\n          exact Fin.le_antisymm hl' ha\n      subst ha\n      simp\n    \u00b7 simp only [not_le] at ha\n      rw [List.filter_cons_of_neg (by simpa using ha)]\n      rw [fin_list_sorted_indexOf_filter_le_mem l hl.2]\n      simp only [List.mem_cons] at hi\n      rcases hi with hi | hi\n      \u00b7 omega\n      \u00b7 exact hi\n\nlemma fin_list_sorted_indexOf_mem :\n    (l : List (Fin n)) \u2192 (hl : l.Sorted (\u00b7 \u2264 \u00b7)) \u2192 (i : Fin n) \u2192\n    (hi : i \u2208 l) \u2192\n    l.indexOf i = (l.filter (fun x => x.1 < i.1)).length := by\n  intro l hl i hi\n  conv_lhs => rw [fin_list_sorted_split l hl i]\n  rw [List.indexOf_append_of_not_mem]\n  erw [fin_list_sorted_indexOf_filter_le_mem l hl i hi]\n  \u00b7 simp\n  \u00b7 simp\n\nlemma orderedInsert_of_fin_list_sorted :\n    (l : List (Fin n)) \u2192 (hl : l.Sorted (\u00b7 \u2264 \u00b7)) \u2192 (i : Fin n) \u2192\n    List.orderedInsert (\u00b7 \u2264 \u00b7) i l = l.filter (fun x => x.1 < i.1) ++\n    i :: l.filter (fun x => i.1 \u2264 x.1)\n  | [], _, _ => by simp\n  | a :: l, hl, i => by\n    simp only [List.sorted_cons] at hl\n    by_cases ha : i \u2264 a\n    \u00b7 simp only [List.orderedInsert, ha, \u2193reduceIte, Fin.val_fin_lt, decide_eq_true_eq, not_lt,\n      List.filter_cons_of_neg, Fin.val_fin_le, decide_true, List.filter_cons_of_pos]\n      have h1 : List.filter (fun x => decide (\u2191x < \u2191i)) l = [] := by\n        simp only [List.filter_eq_nil_iff, decide_eq_true_eq, not_lt]\n        intro a ha\n        have ha' := hl.1 a ha\n        omega\n      have hl : l = List.filter (fun x => decide (i \u2264 x)) l := by\n        conv_lhs => rw [fin_list_sorted_split l hl.2 i]\n        simp [h1]\n      simp [\u2190 hl, h1]\n    \u00b7 simp only [List.orderedInsert, ha, \u2193reduceIte, Fin.val_fin_lt, Fin.val_fin_le, decide_false,\n      Bool.false_eq_true, not_false_eq_true, List.filter_cons_of_neg]\n      rw [List.filter_cons_of_pos]\n      rw [orderedInsert_of_fin_list_sorted l hl.2 i]\n      simp only [Fin.val_fin_lt, Fin.val_fin_le, List.cons_append]\n      simp only [decide_eq_true_eq]\n      omega\n\nlemma orderedInsert_eq_insertIdx_of_fin_list_sorted (l : List (Fin n)) (hl : l.Sorted (\u00b7 \u2264 \u00b7))\n    (i : Fin n) :\n    List.orderedInsert (\u00b7 \u2264 \u00b7) i l = l.insertIdx (l.filter (fun x => x.1 < i.1)).length i := by\n  let n : Fin l.length.succ := \u27e8(List.filter (fun x => decide (x < i)) l).length, by\n    have h1 := l.length_filter_le (fun x => x.1 < i.1)\n    simp only [Fin.val_fin_lt] at h1\n    omega\u27e9\n  simp only [Fin.val_fin_lt]\n  conv_rhs => rw [insertIdx_eq_take_drop _ _ n]\n  rw [orderedInsert_of_fin_list_sorted]\n  congr\n  \u00b7 conv_rhs =>\n      rhs\n      rw [fin_list_sorted_split l hl i]\n    simp [n]\n  \u00b7 conv_rhs =>\n      rhs\n      rw [fin_list_sorted_split l hl i]\n    simp [n]\n  exact hl\n\n/-!\n\n## Uncontracted List\n\n-/\n\n/-- Given a Wick contraction `c`, the ordered list of elements of `Fin n` which are not contracted,\n  i.e. do not appear anywhere in `c.1`. -/\ndef uncontractedList : List (Fin n) := List.filter (fun x => x \u2208 c.uncontracted) (List.finRange n)\n\nlemma uncontractedList_mem_iff (i : Fin n) :\n    i \u2208 c.uncontractedList \u2194 i \u2208 c.uncontracted := by\n  simp [uncontractedList]\n\n@[simp]\nlemma uncontractedList_empty : (empty (n := n)).uncontractedList = List.finRange n := by\n  simp [uncontractedList]\n\nlemma nil_zero_uncontractedList : (empty (n := 0)).uncontractedList = [] := by\n  simp [empty, uncontractedList]\n\nlemma congr_uncontractedList {n m : \u2115} (h : n = m) (c : WickContraction n) :\n    ((congr h) c).uncontractedList = List.map (finCongr h) c.uncontractedList := by\n  subst h\n  simp [congr]\n\nlemma uncontractedList_get_mem_uncontracted (i : Fin c.uncontractedList.length) :\n    c.uncontractedList.get i \u2208 c.uncontracted := by\n  rw [\u2190 uncontractedList_mem_iff]\n  simp\n\nlemma uncontractedList_sorted : List.Sorted (\u00b7 \u2264 \u00b7) c.uncontractedList := by\n  rw [uncontractedList]\n  apply List.Sorted.filter\n  rw [\u2190 List.ofFn_id]\n  exact Monotone.ofFn_sorted fun \u2983a b\u2984 a => a\n\nlemma uncontractedList_sorted_lt : List.Sorted (\u00b7 < \u00b7) c.uncontractedList := by\n  rw [uncontractedList]\n  apply List.Sorted.filter\n  rw [\u2190 List.ofFn_id]\n  exact List.sorted_lt_ofFn_iff.mpr fun \u2983a b\u2984 a => a\n\nlemma uncontractedList_nodup : c.uncontractedList.Nodup := by\n  rw [uncontractedList]\n  refine List.Nodup.filter (fun x => decide (x \u2208 c.uncontracted)) ?_\n  exact List.nodup_finRange n\n\nlemma uncontractedList_toFinset (c : WickContraction n) :\n    c.uncontractedList.toFinset = c.uncontracted := by\n  simp [uncontractedList]\n\nlemma uncontractedList_eq_sort (c : WickContraction n) :\n    c.uncontractedList = c.uncontracted.sort (\u00b7 \u2264 \u00b7) := by\n  symm\n  rw [\u2190 uncontractedList_toFinset]\n  refine (List.toFinset_sort (\u03b1 := Fin n) (\u00b7 \u2264 \u00b7) ?_).mpr ?_\n  \u00b7 exact uncontractedList_nodup c\n  \u00b7 exact uncontractedList_sorted c\n\nlemma uncontractedList_length_eq_card (c : WickContraction n) :\n    c.uncontractedList.length = c.uncontracted.card := by\n  rw [uncontractedList_eq_sort]\n  exact Finset.length_sort fun x1 x2 => x1 \u2264 x2\n\nlemma filter_uncontractedList (c : WickContraction n) (p : Fin n \u2192 Prop) [DecidablePred p] :\n    (c.uncontractedList.filter p) = (c.uncontracted.filter p).sort (\u00b7 \u2264 \u00b7) := by\n  have h1 : (c.uncontractedList.filter p).Sorted (\u00b7 \u2264 \u00b7) := by\n    apply List.Sorted.filter\n    exact uncontractedList_sorted c\n  have h2 : (c.uncontractedList.filter p).Nodup := by\n    refine List.Nodup.filter _ ?_\n    exact uncontractedList_nodup c\n  have h3 : (c.uncontractedList.filter p).toFinset = (c.uncontracted.filter p) := by\n    ext a\n    simp only [List.toFinset_filter, decide_eq_true_eq, Finset.mem_filter, List.mem_toFinset,\n      and_congr_left_iff]\n    rw [uncontractedList_mem_iff]\n    simp\n  have hx := (List.toFinset_sort (\u00b7 \u2264 \u00b7) h2).mpr h1\n  rw [\u2190 hx, h3]\n\n/-!\n\n## uncontractedIndexEquiv\n\n-/\n\n/-- The equivalence between the positions of `c.uncontractedList` i.e. elements of\n  `Fin (c.uncontractedList).length` and the finite set `c.uncontracted` considered as a finite type.\n-/\ndef uncontractedIndexEquiv (c : WickContraction n) :\n    Fin (c.uncontractedList).length \u2243 c.uncontracted where\n  toFun i := \u27e8c.uncontractedList.get i, c.uncontractedList_get_mem_uncontracted i\u27e9\n  invFun i := \u27e8List.indexOf i.1 c.uncontractedList,\n    List.indexOf_lt_length_iff.mpr ((c.uncontractedList_mem_iff i.1).mpr i.2)\u27e9\n  left_inv i := by\n    ext\n    exact List.get_indexOf (uncontractedList_nodup c) _\n  right_inv i := by\n    ext\n    simp\n\n@[simp]\nlemma uncontractedList_getElem_uncontractedIndexEquiv_symm (k : c.uncontracted) :\n    c.uncontractedList[(c.uncontractedIndexEquiv.symm k).val] = k := by\n  simp [uncontractedIndexEquiv]\n\nlemma uncontractedIndexEquiv_symm_eq_filter_length (k : c.uncontracted) :\n    (c.uncontractedIndexEquiv.symm k).val =\n    (List.filter (fun i => i < k.val) c.uncontractedList).length := by\n  simp only [uncontractedIndexEquiv, List.get_eq_getElem, Equiv.coe_fn_symm_mk]\n  rw [fin_list_sorted_indexOf_mem]\n  \u00b7 simp\n  \u00b7 exact uncontractedList_sorted c\n  \u00b7 rw [uncontractedList_mem_iff]\n    exact k.2\n\nlemma take_uncontractedIndexEquiv_symm (k : c.uncontracted) :\n    c.uncontractedList.take (c.uncontractedIndexEquiv.symm k).val =\n    c.uncontractedList.filter (fun i => i < k.val) := by\n  have hl := fin_list_sorted_split c.uncontractedList (uncontractedList_sorted c) k.val\n  conv_lhs =>\n    rhs\n    rw [hl]\n  rw [uncontractedIndexEquiv_symm_eq_filter_length]\n  simp\n/-!\n\n## Uncontracted List get\n\n-/\n\n/-- Given a Wick Contraction `\u03c6s\u039b` of a list `\u03c6s` of `\ud835\udcd5.FieldOp`. The list\n  `\u03c6s\u039b.uncontractedListGet` of `\ud835\udcd5.FieldOp` is defined as the list `\u03c6s` with\n  all contracted positions removed, leaving the uncontracted `\ud835\udcd5.FieldOp`.\n\n  The notation `[\u03c6s\u039b]\u1d58\u1d9c` is used for `\u03c6s\u039b.uncontractedListGet`. -/\ndef uncontractedListGet {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length) :\n    List \ud835\udcd5.FieldOp := \u03c6s\u039b.uncontractedList.map \u03c6s.get\n\n@[inherit_doc uncontractedListGet]\nscoped[WickContraction] notation \"[\" \u03c6s\u039b \"]\u1d58\u1d9c\" => uncontractedListGet \u03c6s\u039b\n\n@[simp]\nlemma uncontractedListGet_empty {\u03c6s : List \ud835\udcd5.FieldOp} :\n    (empty (n := \u03c6s.length)).uncontractedListGet = \u03c6s := by\n  simp [uncontractedListGet]\n\n/-!\n\n## uncontractedFieldOpEquiv\n\n-/\n\n/-- The equivalence between the type `Option c.uncontracted` for `WickContraction \u03c6s.length` and\n  `Option (Fin (c.uncontractedList.map \u03c6s.get).length)`, that is optional positions of\n  `c.uncontractedList.map \u03c6s.get` induced by `uncontractedIndexEquiv`. -/\ndef uncontractedFieldOpEquiv (\u03c6s : List \ud835\udcd5.FieldOp) (\u03c6s\u039b : WickContraction \u03c6s.length) :\n    Option \u03c6s\u039b.uncontracted \u2243 Option (Fin [\u03c6s\u039b]\u1d58\u1d9c.length) :=\n  Equiv.optionCongr (\u03c6s\u039b.uncontractedIndexEquiv.symm.trans\n    (finCongr (by simp [uncontractedListGet])))\n\n@[simp]\nlemma uncontractedFieldOpEquiv_none (\u03c6s : List \ud835\udcd5.FieldOp) (\u03c6s\u039b : WickContraction \u03c6s.length) :\n    (uncontractedFieldOpEquiv \u03c6s \u03c6s\u039b).toFun none = none := by\n  simp [uncontractedFieldOpEquiv]\n\nlemma uncontractedFieldOpEquiv_list_sum [AddCommMonoid \u03b1] (\u03c6s : List \ud835\udcd5.FieldOp)\n    (\u03c6s\u039b : WickContraction \u03c6s.length) (f : Option (Fin [\u03c6s\u039b]\u1d58\u1d9c.length) \u2192 \u03b1) :\n    \u2211 (i : Option (Fin [\u03c6s\u039b]\u1d58\u1d9c.length)), f i =\n    \u2211 (i : Option \u03c6s\u039b.uncontracted), f (\u03c6s\u039b.uncontractedFieldOpEquiv \u03c6s i) := by\n  rw [(\u03c6s\u039b.uncontractedFieldOpEquiv \u03c6s).sum_comp]\n\n/-!\n\n## uncontractedListEmd\n\n-/\n\n/-- The embedding of `Fin [\u03c6s\u039b]\u1d58\u1d9c.length` into `Fin \u03c6s.length`. -/\ndef uncontractedListEmd {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length} :\n    Fin [\u03c6s\u039b]\u1d58\u1d9c.length \u21aa Fin \u03c6s.length := ((finCongr (by simp [uncontractedListGet])).trans\n  \u03c6s\u039b.uncontractedIndexEquiv).toEmbedding.trans\n  (Function.Embedding.subtype fun x => x \u2208 \u03c6s\u039b.uncontracted)\n\nlemma uncontractedListEmd_congr {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b \u03c6s\u039b' : WickContraction \u03c6s.length}\n    (h : \u03c6s\u039b = \u03c6s\u039b') : \u03c6s\u039b.uncontractedListEmd =\n    (finCongr (by simp [h])).toEmbedding.trans \u03c6s\u039b'.uncontractedListEmd := by\n  subst h\n  rfl\n\nlemma uncontractedListEmd_toFun_eq_get (\u03c6s : List \ud835\udcd5.FieldOp) (\u03c6s\u039b : WickContraction \u03c6s.length) :\n    (uncontractedListEmd (\u03c6s\u039b := \u03c6s\u039b)).toFun =\n    \u03c6s\u039b.uncontractedList.get \u2218 (finCongr (by simp [uncontractedListGet])) := by\n  rfl\n\nlemma uncontractedListEmd_strictMono {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {i j : Fin [\u03c6s\u039b]\u1d58\u1d9c.length} (h : i < j) : uncontractedListEmd i < uncontractedListEmd j := by\n  simp only [uncontractedListEmd, uncontractedIndexEquiv, List.get_eq_getElem,\n    Equiv.trans_toEmbedding, Function.Embedding.trans_apply, Equiv.coe_toEmbedding, finCongr_apply,\n    Equiv.coe_fn_mk, Fin.coe_cast, Function.Embedding.coe_subtype]\n  exact List.Sorted.get_strictMono \u03c6s\u039b.uncontractedList_sorted_lt h\n\n", "theoremStatement": "lemma uncontractedListEmd_mem_uncontracted {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    (i : Fin [\u03c6s\u039b]\u1d58\u1d9c.length) : uncontractedListEmd i \u2208 \u03c6s\u039b.uncontracted ", "theoremName": "WickContraction.uncontractedListEmd_mem_uncontracted", "fileCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "theoremCreated": {"commit": "12d36dc1d9c726c035301091e57be0b29015e4ae", "date": "2025-01-31"}, "file": "HepLean/HepLean/PerturbationTheory/WickContraction/UncontractedList.lean", "module": "HepLean.PerturbationTheory.WickContraction.UncontractedList", "jsonFile": "HepLean.PerturbationTheory.WickContraction.UncontractedList.jsonl", "positionMetadata": {"lineInFile": 388, "tokenPositionInFile": 14249, "theoremPositionInFile": 31}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 8, "numPremises": 32}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp [uncontractedListEmd]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 34}}
