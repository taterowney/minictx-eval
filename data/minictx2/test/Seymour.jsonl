{"srcContext": "import Mathlib.Data.Set.SymmDiff\nimport Mathlib.Order.CompletePartialOrder\nimport Mathlib.Order.Disjoint\nimport Mathlib.Order.SymmDiff\nimport Mathlib.Tactic\n\nimport Seymour.Basic\n\n/-!\nThis provides lemmas about sets (mostly dealing with disjointness) that are missing in Mathlib.\n-/\n\nvariable {\u03b1 : Type}\n\nsection Other\n\nlemma set_union_union_eq_rev (X Y Z : Set \u03b1) : X \u222a Y \u222a Z = Z \u222a Y \u222a X := by\n  rw [Set.union_assoc, Set.union_comm, Set.union_comm Y Z]\n\nlemma setminus_inter_union_eq_union {X Y : Set \u03b1} : X \\ (X \u2229 Y) \u222a Y = X \u222a Y := by\n  tauto_set\n\nlemma nonempty_inter_not_ssubset_empty_inter {A B E : Set \u03b1} (hA : (A \u2229 E).Nonempty) (hB : B \u2229 E = \u2205) :\n    \u00ac(A \u2282 B) := by\n  intro \u27e8hAB, _\u27e9\n  obtain \u27e8x, hxAE\u27e9 := hA\n  have hxBE : x \u2208 B \u2229 E := (Set.inter_subset_inter hAB fun _ => id) hxAE\n  rw [hB] at hxBE\n  tauto\n\nlemma ssubset_self_union_other_elem {a : \u03b1} {X : Set \u03b1} (ha : a \u2209 X) :\n    X \u2282 X \u222a {a} := by\n  constructor\n  \u00b7 exact Set.subset_union_left\n  \u00b7 by_contra hX\n    rw [Set.union_subset_iff] at hX\n    obtain \u27e8_, haa\u27e9 := hX\n    tauto\n\nlemma singleton_union_ssubset_union_iff {a : \u03b1} {A B : Set \u03b1} (haA : a \u2209 A) (haB : a \u2209 B) :\n    A \u222a {a} \u2282 B \u222a {a} \u2194 A \u2282 B := by\n  constructor\n  \u00b7 intro hAB\n    obtain \u27e8hABl, hABr\u27e9 := hAB\n    constructor\n    \u00b7 intro x hx\n      apply ne_of_mem_of_not_mem hx at haA\n      cases hABl (Set.mem_union_left {a} hx) <;> tauto\n    \u00b7 by_contra hBA\n      apply Set.union_subset_union_left {a} at hBA\n      tauto\n  \u00b7 intro hAB\n    obtain \u27e8hABl, hABr\u27e9 := hAB\n    constructor\n    \u00b7 exact Set.union_subset_union_left {a} hABl\n    \u00b7 by_contra hBA\n      rw [Set.union_singleton, Set.union_singleton] at hBA\n      apply (Set.insert_subset_insert_iff haB).\u2192 at hBA\n      tauto\n\nlemma ssub_parts_ssub {A B E\u2081 E\u2082 : Set \u03b1}\n    (hA : A \u2286 E\u2081 \u222a E\u2082) (hB : B \u2286 E\u2081 \u222a E\u2082) (hAB\u2081 : A \u2229 E\u2081 \u2282 B \u2229 E\u2081) (hAB\u2082 : A \u2229 E\u2082 \u2282 B \u2229 E\u2082) :\n    A \u2282 B := by\n  constructor\n  \u00b7 obtain \u27e8hE\u2081, _\u27e9 := hAB\u2081\n    obtain \u27e8hE\u2082, _\u27e9 := hAB\u2082\n    rw [Set.left_eq_inter.\u2190 hA, Set.left_eq_inter.\u2190 hB, Set.inter_union_distrib_left, Set.inter_union_distrib_left]\n    exact Set.union_subset_union hE\u2081 hE\u2082\n  \u00b7 intro hBA\n    obtain \u27e8_, hE\u2081\u27e9 := hAB\u2081\n    obtain \u27e8x, hxBE\u2081, hxnAE\u2081\u27e9 := Set.not_subset.\u2192 hE\u2081\n    have hxB : x \u2208 B := Set.mem_of_mem_inter_left hxBE\u2081\n    have hxE\u2081 : x \u2208 E\u2081 := Set.mem_of_mem_inter_right hxBE\u2081\n    tauto\n\nlemma HasSubset.Subset.parts_eq {A E\u2081 E\u2082 : Set \u03b1} (hA : A \u2286 E\u2081 \u222a E\u2082) : (A \u2229 E\u2081) \u222a (A \u2229 E\u2082) = A :=\n  ((subset_of_subset_of_eq\n    (Set.subset_inter (fun _ => id) hA)\n    (Set.inter_union_distrib_left A E\u2081 E\u2082)).antisymm\n  (Set.union_subset Set.inter_subset_left Set.inter_subset_left)).symm\n\nlemma elem_notin_set_minus_singleton (a : \u03b1) (X : Set \u03b1) : a \u2209 X \\ {a} := Set.not_mem_diff_of_mem rfl\n\nlemma sub_union_diff_sub_union {A B C : Set \u03b1} (hA : A \u2286 B \\ C) : A \u2286 B :=\n  fun _ hA' => Set.diff_subset (hA hA')\n\nlemma singleton_inter_in_left {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : a \u2208 X :=\n  Set.mem_of_mem_inter_left (ha.symm.subset rfl)\n\nlemma singleton_inter_in_right {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : a \u2208 Y :=\n  Set.mem_of_mem_inter_right (ha.symm.subset rfl)\n\nlemma singleton_inter_subset_left {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : {a} \u2286 X := by\n  rw [Set.singleton_subset_iff]\n  exact singleton_inter_in_left ha\n\n", "theoremStatement": "lemma singleton_inter_subset_right {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : {a} \u2286 Y ", "theoremName": "singleton_inter_subset_right", "fileCreated": {"commit": "b44bff2f1ee71349fa9fa251579a0f5a0e575538", "date": "2024-12-19"}, "theoremCreated": {"commit": "4d9233309fad6a3c9d3d0d88dcfa6420fcb14dcb", "date": "2024-12-18"}, "file": "Seymour/Seymour/ForMathlib/SetTheory.lean", "module": "Seymour.ForMathlib.SetTheory", "jsonFile": "Seymour.ForMathlib.SetTheory.jsonl", "positionMetadata": {"lineInFile": 97, "tokenPositionInFile": 3238, "theoremPositionInFile": 12}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 1, "numPremises": 16}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [Set.singleton_subset_iff]\n  exact singleton_inter_in_right ha", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 73}}
{"srcContext": "import Mathlib.Data.Set.SymmDiff\nimport Mathlib.Order.CompletePartialOrder\nimport Mathlib.Order.Disjoint\nimport Mathlib.Order.SymmDiff\nimport Mathlib.Tactic\n\nimport Seymour.Basic\n\n/-!\nThis provides lemmas about sets (mostly dealing with disjointness) that are missing in Mathlib.\n-/\n\nvariable {\u03b1 : Type}\n\nsection Other\n\nlemma set_union_union_eq_rev (X Y Z : Set \u03b1) : X \u222a Y \u222a Z = Z \u222a Y \u222a X := by\n  rw [Set.union_assoc, Set.union_comm, Set.union_comm Y Z]\n\nlemma setminus_inter_union_eq_union {X Y : Set \u03b1} : X \\ (X \u2229 Y) \u222a Y = X \u222a Y := by\n  tauto_set\n\nlemma nonempty_inter_not_ssubset_empty_inter {A B E : Set \u03b1} (hA : (A \u2229 E).Nonempty) (hB : B \u2229 E = \u2205) :\n    \u00ac(A \u2282 B) := by\n  intro \u27e8hAB, _\u27e9\n  obtain \u27e8x, hxAE\u27e9 := hA\n  have hxBE : x \u2208 B \u2229 E := (Set.inter_subset_inter hAB fun _ => id) hxAE\n  rw [hB] at hxBE\n  tauto\n\nlemma ssubset_self_union_other_elem {a : \u03b1} {X : Set \u03b1} (ha : a \u2209 X) :\n    X \u2282 X \u222a {a} := by\n  constructor\n  \u00b7 exact Set.subset_union_left\n  \u00b7 by_contra hX\n    rw [Set.union_subset_iff] at hX\n    obtain \u27e8_, haa\u27e9 := hX\n    tauto\n\nlemma singleton_union_ssubset_union_iff {a : \u03b1} {A B : Set \u03b1} (haA : a \u2209 A) (haB : a \u2209 B) :\n    A \u222a {a} \u2282 B \u222a {a} \u2194 A \u2282 B := by\n  constructor\n  \u00b7 intro hAB\n    obtain \u27e8hABl, hABr\u27e9 := hAB\n    constructor\n    \u00b7 intro x hx\n      apply ne_of_mem_of_not_mem hx at haA\n      cases hABl (Set.mem_union_left {a} hx) <;> tauto\n    \u00b7 by_contra hBA\n      apply Set.union_subset_union_left {a} at hBA\n      tauto\n  \u00b7 intro hAB\n    obtain \u27e8hABl, hABr\u27e9 := hAB\n    constructor\n    \u00b7 exact Set.union_subset_union_left {a} hABl\n    \u00b7 by_contra hBA\n      rw [Set.union_singleton, Set.union_singleton] at hBA\n      apply (Set.insert_subset_insert_iff haB).\u2192 at hBA\n      tauto\n\nlemma ssub_parts_ssub {A B E\u2081 E\u2082 : Set \u03b1}\n    (hA : A \u2286 E\u2081 \u222a E\u2082) (hB : B \u2286 E\u2081 \u222a E\u2082) (hAB\u2081 : A \u2229 E\u2081 \u2282 B \u2229 E\u2081) (hAB\u2082 : A \u2229 E\u2082 \u2282 B \u2229 E\u2082) :\n    A \u2282 B := by\n  constructor\n  \u00b7 obtain \u27e8hE\u2081, _\u27e9 := hAB\u2081\n    obtain \u27e8hE\u2082, _\u27e9 := hAB\u2082\n    rw [Set.left_eq_inter.\u2190 hA, Set.left_eq_inter.\u2190 hB, Set.inter_union_distrib_left, Set.inter_union_distrib_left]\n    exact Set.union_subset_union hE\u2081 hE\u2082\n  \u00b7 intro hBA\n    obtain \u27e8_, hE\u2081\u27e9 := hAB\u2081\n    obtain \u27e8x, hxBE\u2081, hxnAE\u2081\u27e9 := Set.not_subset.\u2192 hE\u2081\n    have hxB : x \u2208 B := Set.mem_of_mem_inter_left hxBE\u2081\n    have hxE\u2081 : x \u2208 E\u2081 := Set.mem_of_mem_inter_right hxBE\u2081\n    tauto\n\nlemma HasSubset.Subset.parts_eq {A E\u2081 E\u2082 : Set \u03b1} (hA : A \u2286 E\u2081 \u222a E\u2082) : (A \u2229 E\u2081) \u222a (A \u2229 E\u2082) = A :=\n  ((subset_of_subset_of_eq\n    (Set.subset_inter (fun _ => id) hA)\n    (Set.inter_union_distrib_left A E\u2081 E\u2082)).antisymm\n  (Set.union_subset Set.inter_subset_left Set.inter_subset_left)).symm\n\nlemma elem_notin_set_minus_singleton (a : \u03b1) (X : Set \u03b1) : a \u2209 X \\ {a} := Set.not_mem_diff_of_mem rfl\n\nlemma sub_union_diff_sub_union {A B C : Set \u03b1} (hA : A \u2286 B \\ C) : A \u2286 B :=\n  fun _ hA' => Set.diff_subset (hA hA')\n\nlemma singleton_inter_in_left {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : a \u2208 X :=\n  Set.mem_of_mem_inter_left (ha.symm.subset rfl)\n\nlemma singleton_inter_in_right {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : a \u2208 Y :=\n  Set.mem_of_mem_inter_right (ha.symm.subset rfl)\n\nlemma singleton_inter_subset_left {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : {a} \u2286 X := by\n  rw [Set.singleton_subset_iff]\n  exact singleton_inter_in_left ha\n\nlemma singleton_inter_subset_right {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : {a} \u2286 Y := by\n  rw [Set.singleton_subset_iff]\n  exact singleton_inter_in_right ha\n\n/-- Being a subset is preserved under subtracting sets. -/\nlemma diff_subset_parent {X\u2081 X\u2082 E : Set \u03b1} (hX\u2081E : X\u2081 \u2286 E) :\n    X\u2081 \\ X\u2082 \u2286 E :=\n  Set.diff_subset_iff.\u2190 (Set.subset_union_of_subset_right hX\u2081E X\u2082)\n\n/-- Being a subset is preserved under taking intersections. -/\nlemma inter_subset_parent_left {X\u2081 X\u2082 E : Set \u03b1} (hX\u2081E : X\u2081 \u2286 E) :\n    X\u2081 \u2229 X\u2082 \u2286 E :=\n  (Set.inter_subset_inter_left X\u2082 hX\u2081E).trans Set.inter_subset_left\n\n/-- Being a subset is preserved under taking intersections. -/\nlemma inter_subset_parent_right {X\u2081 X\u2082 E : Set \u03b1} (hX\u2082E : X\u2082 \u2286 E) :\n    X\u2081 \u2229 X\u2082 \u2286 E := by\n  rw [Set.inter_comm]\n  exact inter_subset_parent_left hX\u2082E\n\n/-- Intersection of two sets is subset of their union. -/\nlemma inter_subset_union {X\u2081 X\u2082 : Set \u03b1} :\n    X\u2081 \u2229 X\u2082 \u2286 X\u2081 \u222a X\u2082 :=\n  inter_subset_parent_left Set.subset_union_left\n\nlemma subset_diff_empty_eq {A B : Set \u03b1} (hAB : A \u2286 B) (hBA : B \\ A = \u2205) : A = B :=\n  A.union_empty \u25b8 hBA \u25b8 Set.union_diff_cancel hAB\n\nend Other\n\n\nsection Disjoint\n\nlemma Disjoint.ni_of_in {X Y : Set \u03b1} {a : \u03b1} (hXY : X \u2ad7 Y) (ha : a \u2208 X) :\n    a \u2209 Y := by\n  intro ha'\n  simpa [hXY.inter_eq] using Set.mem_inter ha ha'\n\nlemma disjoint_of_singleton_inter_left_wo {X Y : Set \u03b1} {a : \u03b1} (hXY : X \u2229 Y = {a}) :\n    X \\ {a} \u2ad7 Y := by\n  tauto_set\n\nlemma disjoint_of_singleton_inter_right_wo {X Y : Set \u03b1} {a : \u03b1} (hXY : X \u2229 Y = {a}) :\n    X \u2ad7 Y \\ {a} := by\n  rw [disjoint_comm]\n  rw [Set.inter_comm] at hXY\n  exact disjoint_of_singleton_inter_left_wo hXY\n\nlemma disjoint_of_singleton_inter_both_wo {X Y : Set \u03b1} {a : \u03b1} (hXY : X \u2229 Y = {a}) :\n    X \\ {a} \u2ad7 Y \\ {a} :=\n  Disjoint.disjoint_sdiff_left (disjoint_of_singleton_inter_right_wo hXY)\n\nlemma disjoint_of_singleton_inter_subset_left {X Y Z : Set \u03b1} {a : \u03b1} (hXY : X \u2229 Y = {a}) (hZ : Z \u2286 X) (haZ : a \u2209 Z) :\n    Z \u2ad7 Y := by\n  have hY : (Y \\ {a}) \u222a {a} = Y := (Set.diff_union_of_subset (singleton_inter_subset_right hXY))\n  rw [\u2190hY, Set.disjoint_union_right]\n  constructor\n  \u00b7 exact Set.disjoint_of_subset_left hZ (disjoint_of_singleton_inter_right_wo hXY)\n  \u00b7 exact Set.disjoint_singleton_right.\u2190 haZ\n\nlemma disjoint_of_singleton_inter_subset_right {X Y Z : Set \u03b1} {a : \u03b1} (hXY : X \u2229 Y = {a}) (hZ : Z \u2286 Y) (haZ : a \u2209 Z) :\n    X \u2ad7 Z := by\n  rw [Set.inter_comm] at hXY\n  rw [disjoint_comm]\n  exact disjoint_of_singleton_inter_subset_left hXY hZ haZ\n\nlemma disjoint_nonempty_not_subset {A B : Set \u03b1} (hAB : A \u2ad7 B) (hA : A.Nonempty) :\n    \u00ac(A \u2286 B) := by\n  intro contr\n  simp [Disjoint.eq_bot_of_le hAB, contr] at hA\n\nlemma disjoint_nonempty_not_ssubset {A B : Set \u03b1} (hAB : A \u2ad7 B) (hA : A.Nonempty) :\n    \u00ac(A \u2282 B) := by\n  apply disjoint_nonempty_not_subset hAB at hA\n  intro \u27e8_, _\u27e9\n  tauto\n\nlemma ssubset_union_disjoint_nonempty {X Y : Set \u03b1} (hXY : X \u2ad7 Y) (hY : Y.Nonempty) :\n    X \u2282 X \u222a Y := by\n  constructor\n  \u00b7 exact Set.subset_union_left\n  \u00b7 by_contra hX\n    apply Set.diff_subset_diff_left at hX\n    rw [Set.union_diff_cancel_left (Set.disjoint_iff.\u2192 hXY), Set.diff_self] at hX\n    exact Set.not_nonempty_empty (Set.eq_empty_of_subset_empty hX \u25b8 hY)\n\nlemma union_ssubset_union_iff {A B X : Set \u03b1} (hAX : A \u2ad7 X) (hBX : B \u2ad7 X) :\n    A \u222a X \u2282 B \u222a X \u2194 A \u2282 B := by\n  constructor\n  \u00b7 intro hAB\n    rw [Set.ssubset_iff_subset_ne] at hAB \u22a2\n    constructor\n    \u00b7 have hXX : X \u2286 X := Set.Subset.rfl\n      have hAXXBXX := Set.diff_subset_diff hAB.left hXX\n      rwa [Set.union_diff_cancel_right, Set.union_diff_cancel_right] at hAXXBXX\n      \u00b7 rwa [Set.disjoint_iff] at hBX\n      \u00b7 rwa [Set.disjoint_iff] at hAX\n    \u00b7 intro\n      simp_all\n  \u00b7 intro hAB\n    have hAB' : A \u2286 B := hAB.subset\n    rw [Set.ssubset_iff_of_subset hAB'] at hAB\n    obtain \u27e8x, hx\u27e9 := hAB\n    rw [Set.ssubset_iff_of_subset (Set.union_subset_union_left X hAB')]\n    refine \u27e8x, Set.mem_union_left X hx.left, fun hx' => ?_\u27e9\n    rw [Set.mem_union] at hx'\n    cases hx' with\n    | inl hA => exact hx.right hA\n    | inr hX => exact hBX.ni_of_in hx.left hX\n\nlemma union_subset_union_iff {A B X : Set \u03b1} (hAX : A \u2ad7 X) (hBX : B \u2ad7 X) :\n    A \u222a X \u2286 B \u222a X \u2194 A \u2286 B := by\n  constructor\n  \u00b7 intro hABX\n    have hXX : (A \u222a X) \\ X \u2286 (B \u222a X) \\ X := Set.diff_subset_diff_left hABX\n    have hXA : (A \u222a X) \\ X = A := Set.union_diff_cancel_right (Set.disjoint_iff.\u2192 hAX)\n    have hXB : (B \u222a X) \\ X = B := Set.union_diff_cancel_right (Set.disjoint_iff.\u2192 hBX)\n    rwa [hXA, hXB] at hXX\n  \u00b7 exact Set.union_subset_union_left X\n\nlemma ssubset_disjoint_union_nonempty {X\u2081 X\u2082 : Set \u03b1} (hXX : X\u2081 \u2ad7 X\u2082) (hX\u2082 : X\u2082.Nonempty) :\n    X\u2081 \u2282 X\u2081 \u222a X\u2082 := by\n  rw [Set.ssubset_iff_of_subset Set.subset_union_left]\n  obtain \u27e8x, hx\u27e9 := hX\u2082\n  exact \u27e8x, Set.mem_union_right X\u2081 hx, Disjoint.ni_of_in hXX.symm hx\u27e9\n\n", "theoremStatement": "lemma ssubset_disjoint_nonempty_union {X\u2081 X\u2082 : Set \u03b1} (hXX : X\u2081 \u2ad7 X\u2082) (hX\u2081 : X\u2081.Nonempty) :\n    X\u2082 \u2282 X\u2081 \u222a X\u2082 ", "theoremName": "ssubset_disjoint_nonempty_union", "fileCreated": {"commit": "b44bff2f1ee71349fa9fa251579a0f5a0e575538", "date": "2024-12-19"}, "theoremCreated": {"commit": "aa9b46679cd5e621d8d7b316e3b520d57d9a2157", "date": "2024-12-19"}, "file": "Seymour/Seymour/ForMathlib/SetTheory.lean", "module": "Seymour.ForMathlib.SetTheory", "jsonFile": "Seymour.ForMathlib.SetTheory.jsonl", "positionMetadata": {"lineInFile": 223, "tokenPositionInFile": 7990, "theoremPositionInFile": 30}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 1, "numPremises": 25}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [disjoint_comm] at hXX\n  rw [Set.union_comm]\n  exact ssubset_disjoint_union_nonempty hXX hX\u2081", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 103}}
{"srcContext": "import Seymour.Matroid.Operations.SumDelta.Basic\nimport Seymour.ForMathlib.SetTheory\n\nset_option linter.unusedVariables false\n\nvariable {\u03b1 : Type} [DecidableEq \u03b1]\n\n\nsection Basic\n\n/-- Nonempty union of disjoint circuits of `M\u2081` satisfies circuit form of `M\u2081 \u0394 M\u2082`  -/\nlemma deltaSumCircuitForm_left {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : C.Nonempty) (hCE : C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)) (hCM\u2081 : M\u2081.toMatroid.IsUnionDisjointCircuits C) :\n    DeltaSumCircuitForm M\u2081 M\u2082 C :=\n  \u27e8hC, hCE, C, \u2205, by simp, hCM\u2081, M\u2082.toMatroid.emptyUnionDisjointCircuits\u27e9\n\n/-- Nonempty union of disjoint circuits of `M\u2082` satisfies circuit form of `M\u2081 \u0394 M\u2082`  -/\nlemma deltaSumCircuitForm_right {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : C.Nonempty) (hCE : C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)) (hCM\u2082 : M\u2082.toMatroid.IsUnionDisjointCircuits C) :\n    DeltaSumCircuitForm M\u2081 M\u2082 C :=\n  \u27e8hC, hCE, \u2205, C, by simp, M\u2081.toMatroid.emptyUnionDisjointCircuits, hCM\u2082\u27e9\n\nend Basic\n\n\nsection CircuitForm1\n\n/-- Form 1 of circuits in `M\u2081 \u0394 M\u2082`: circuits of `M\u2081` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef DeltaSumCircuitForm1 (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.toMatroid.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Circuit of form 1 is a circuit in `M\u2081` -/\nlemma DeltaSumCircuitForm1.circuit_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    M\u2081.toMatroid.Circuit C :=\n  hC.left\n\n/-- Circuit of form 1 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm1.disjoint_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of form 1 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma DeltaSumCircuitForm1.subset_union {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_left hC.circuit_M\u2081.subset_ground M\u2082.E\n\n/-- Circuit of form 1 lies in ground set of `M\u2081 \u0394 M\u2082` -/\nlemma DeltaSumCircuitForm1.subset_ground {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of form 1 lies in `M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma DeltaSumCircuitForm1.subset_M\u2081_diff_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2286 M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2081.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of form 1 is disjoint with `M\u2082.E` -/\nlemma DeltaSumCircuitForm1.disjoint_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2ad7 M\u2082.E := by\n  have hMM := diff_inter_disjoint_diff_inter M\u2081.E M\u2082.E\n  have hCM\u2082 := Set.disjoint_of_subset_left hC.subset_M\u2081_diff_inter hMM\n  have hCM\u2082 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2082, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_right] at hCM\u2082\n  exact hCM\u2082\n\n/-- Circuit of form 1 satisfies circuit form of `M\u2081 \u0394 M\u2082` -/\nlemma DeltaSumCircuitForm1.circuit_form {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    DeltaSumCircuitForm M\u2081 M\u2082 C :=\n  deltaSumCircuitForm_left hC.circuit_M\u2081.nonempty hC.subset_ground hC.circuit_M\u2081.isUnionDisjointCircuits\n\n/-- If `C` satisfies circuit predicate and is a union of disjoint circuits of `M\u2081`, then `C` is a circuit of `M\u2081` -/\nlemma DeltaSumCircuitPred.udc_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (C_pred : DeltaSumCircuitPred M\u2081 M\u2082 C) (C_udc : M\u2081.toMatroid.IsUnionDisjointCircuits C) :\n    M\u2081.toMatroid.Circuit C :=\n  have \u27e8\u27e8hC, hCE, _\u27e9, hCmin\u27e9 := C_pred\n  \u27e8C_udc.nonempty_dep hC, fun D hD hDC =>\n    have \u27e8_, D', hD', hDD'\u27e9 := M\u2081.toMatroid.dep_iff_has_circuit.\u2192 hD\n    (hCmin\n        (DeltaSumCircuitForm1.circuit_form \u27e8hD', (Set.subset_diff.\u2192 ((hDD'.trans hDC).trans hCE)).right\u27e9)\n        (hDD'.trans hDC)\n      ).trans hDD'\u27e9\n\nend CircuitForm1\n\n\nsection CircuitForm2\n\n/-- Form 2 of circuits in `M\u2081 \u0394 M\u2082`: circuits of `M\u2082` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef DeltaSumCircuitForm2 (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2082.toMatroid.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Circuit of form 2 is a circuit in `M\u2081` -/\nlemma DeltaSumCircuitForm2.circuit_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    M\u2082.toMatroid.Circuit C :=\n  hC.left\n\n/-- Circuit of form 2 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm2.disjoint_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of form 2 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma DeltaSumCircuitForm2.subset_union {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_right hC.circuit_M\u2082.subset_ground M\u2081.E\n\n/-- Circuit of form 2 lies in ground set of `M\u2081 \u0394 M\u2082` -/\nlemma DeltaSumCircuitForm2.subset_ground {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of form 2 lies in `M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma DeltaSumCircuitForm2.subset_M\u2082_diff_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2286 M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2082.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of form 2 is disjoint with `M\u2082.E` -/\nlemma DeltaSumCircuitForm2.disjoint_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2ad7 M\u2081.E := by\n  have hMM := diff_inter_disjoint_diff_inter M\u2081.E M\u2082.E\n  have hCM\u2082 := Set.disjoint_of_subset_right hC.subset_M\u2082_diff_inter hMM\n  have hCM\u2082 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2082.symm, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_left] at hCM\u2082\n  exact hCM\u2082\n\n/-- Circuit of form 2 satisfies circuit form of `M\u2081 \u0394 M\u2082` -/\nlemma DeltaSumCircuitForm2.circuit_form {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    DeltaSumCircuitForm M\u2081 M\u2082 C :=\n  deltaSumCircuitForm_right hC.circuit_M\u2082.nonempty hC.subset_ground hC.circuit_M\u2082.isUnionDisjointCircuits\n\n/-- If `C` satisfies circuit predicate and is a union of disjoint circuits of `M\u2082`, then `C` is a circuit of `M\u2082` -/\nlemma DeltaSumCircuitPred.udc_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hCpred : DeltaSumCircuitPred M\u2081 M\u2082 C) (hCudc : M\u2082.toMatroid.IsUnionDisjointCircuits C) :\n    M\u2082.toMatroid.Circuit C :=\n  have \u27e8\u27e8C_nempty, hCE, _\u27e9, hCmin\u27e9 := hCpred\n  \u27e8hCudc.nonempty_dep C_nempty, fun D hD hDC =>\n    have \u27e8_, D', hD', hDD'\u27e9 := M\u2082.toMatroid.dep_iff_has_circuit.\u2192 hD\n    (hCmin\n        (DeltaSumCircuitForm2.circuit_form \u27e8hD', (Set.subset_diff.\u2192 ((hDD'.trans hDC).trans hCE)).right\u27e9)\n        (hDD'.trans hDC)\n      ).trans hDD'\u27e9\n\nend CircuitForm2\n\n\nsection CircuitForm3\n\n/-- Form 3 of circuits in `M\u2081 \u0394 M\u2082`:\n    sets `C\u2081 \u0394 C\u2082` where `C\u2081` and `C\u2082` are circuits in `M\u2081` and `M\u2082`, respectively,\n    with `C\u2081 \u2229 (M\u2081.E \u2229 M\u2082.E)` and `C\u2082 \u2229 (M\u2081.E \u2229 M\u2082.E)` being the same one-element set.\n    Here we use equivalent definition by denoting `p` the single element in `C\u2081 \u2229 C\u2082` and\n    expressing `C\u2081` and `C\u2082` via `p`, `C`, and ground sets of `M\u2081` and `M\u2082`. -/\ndef DeltaSumCircuitForm3 (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C : Set \u03b1) (p : \u03b1) : Prop :=\n  M\u2081.toMatroid.Circuit ((C \u2229 M\u2081.E) \u222a {p}) \u2227\n  M\u2082.toMatroid.Circuit ((C \u2229 M\u2082.E) \u222a {p}) \u2227\n  C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)\n\n/-- Existential version of form 3 of circuits -/\ndef IsDeltaSumCircuitForm3 (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C : Set \u03b1) : Prop :=\n  \u2203 p \u2208 M\u2081.E \u2229 M\u2082.E, DeltaSumCircuitForm3 M\u2081 M\u2082 C p\n\nvariable {C : Set \u03b1} {p : \u03b1}\n\n/-- Circuit of form 3 yields a circuit in `M\u2081` after intersecting it with `M\u2081.E` and adding `p` -/\ndef DeltaSumCircuitForm3.to_circuit_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    M\u2081.toMatroid.Circuit ((C \u2229 M\u2081.E) \u222a {p}) :=\n  hC.left\n\n/-- Circuit of form 3 yields a circuit in `M\u2082` after intersecting it with `M\u2081.E` and adding `p` -/\ndef DeltaSumCircuitForm3.to_circuit_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    M\u2082.toMatroid.Circuit ((C \u2229 M\u2082.E) \u222a {p}) :=\n  hC.right.left\n\n/-- Circuit of form 3 is subset of ground set of `M\u2081 \u0394 M\u2082` -/\ndef DeltaSumCircuitForm3.subset_ground {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E) :=\n  hC.right.right\n\n/-- Singleton element in definition of circuit form 3 lies in `M\u2081.E` -/\nlemma DeltaSumCircuitForm3.singleton_subset_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    {p} \u2286 M\u2081.E :=\n  (Set.union_subset_iff.\u2192 hC.to_circuit_M\u2081.subset_ground).right\n\n/-- Singleton element in definition of circuit form 3 lies in `M\u2082.E` -/\nlemma DeltaSumCircuitForm3.singleton_subset_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    {p} \u2286 M\u2082.E :=\n  (Set.union_subset_iff.\u2192 hC.to_circuit_M\u2082.subset_ground).right\n\n", "theoremStatement": "/-- Singleton element in definition of circuit form 3 lies in `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm3.singleton_subset_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    {p} \u2286 M\u2081.E \u2229 M\u2082.E ", "theoremName": "DeltaSumCircuitForm3.singleton_subset_inter", "fileCreated": {"commit": "aae07a69b2ec95e3d9a1436952a123dcb7d0d06f", "date": "2025-01-03"}, "theoremCreated": {"commit": "67629d2b74be7b972786897531b678f585a7af28", "date": "2025-02-03"}, "file": "Seymour/Seymour/Matroid/Operations/SumDelta/CircuitForms.lean", "module": "Seymour.Matroid.Operations.SumDelta.CircuitForms", "jsonFile": "Seymour.Matroid.Operations.SumDelta.CircuitForms.jsonl", "positionMetadata": {"lineInFile": 208, "tokenPositionInFile": 8891, "theoremPositionInFile": 27}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 6, "numPremises": 15}, "proofMetadata": {"hasProof": true, "proof": ":=\n  Set.subset_inter hC.singleton_subset_M\u2081 hC.singleton_subset_M\u2082", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 67}}
{"srcContext": "import Mathlib.Order.RelClasses\nimport Mathlib.Data.Matroid.Basic\n\nimport Seymour.Basic\nimport Seymour.Matroid.Notions.IndepAxioms\n\n\n/-- Circuit predicate, defines which sets are circuits. -/\nabbrev CircuitPredicate (\u03b1 : Type) := Set \u03b1 \u2192 Prop\n\n\nvariable {\u03b1 : Type}\n\n\nsection ValidFamily\n\n/-- Family of circuits satisfying assumptions of circuit axiom (C3) from Bruhn et al. -/\nstructure ValidFamily (P : CircuitPredicate \u03b1) (X : Set \u03b1) where\n  F : X.Elem \u2192 Set \u03b1\n  hPF : \u2200 x : X.Elem, P (F x)\n  hF : \u2200 x y : X.Elem, x.val \u2208 F y \u2194 x = y -- `F y` may nevertheless contain multiple elements of `X\u1d9c`\n\n/-- Shorthand for union of sets in `ValidFamily` -/\nabbrev ValidFamily.union {P : CircuitPredicate \u03b1} {X : Set \u03b1} (F : ValidFamily P X) : Set \u03b1 :=\n  Set.iUnion F.F\n\n-- question: unused API?\nlemma ValidFamily.mem_of_elem {P : CircuitPredicate \u03b1} {X : Set \u03b1} (F : ValidFamily P X) (x : X.Elem) :\n    x.val \u2208 F.F x := by\n  rw [F.hF]\n\n-- question: unused API?\nlemma ValidFamily.outside {P : CircuitPredicate \u03b1} {C X : Set \u03b1} {F : ValidFamily P X} {z : \u03b1} (hzCF : z \u2208 C \\ F.union) :\n    z \u2209 X := by\n  intro hz\n  have := F.hF \u27e8z, hz\u27e9 \u27e8z, hz\u27e9\n  simp_all\n\nend ValidFamily\n\n\nsection CircuitAxioms\n\n/-- Circuit predicate `P` defines independence predicate: independent sets are all non-circuits. -/\ndef CircuitPredicate.toIndepPredicate (P : CircuitPredicate \u03b1) (E : Set \u03b1) : IndepPredicate \u03b1 :=\n  fun I : Set \u03b1 => I \u2286 E \u2227 \u2200 C : Set \u03b1, C \u2286 I \u2192 \u00ac(P C)\n\n/-- Axiom (C1): empty set is not a circuit. -/\ndef CircuitPredicate.NotCircuitEmpty (P : CircuitPredicate \u03b1) : Prop :=\n  \u00ac(P \u2205)\nalias CircuitPredicate.BruhnC1 := CircuitPredicate.NotCircuitEmpty\n\n/-- Axiom (C2): no circuit is a subset of another circuit. -/\ndef CircuitPredicate.CircuitNotSsubset (P : CircuitPredicate \u03b1) : Prop :=\n  \u2200 C C' : Set \u03b1, P C \u2192 P C' \u2192 \u00ac(C' \u2282 C)  -- todo: swap to \u00acC \u2282 C'\nalias CircuitPredicate.BruhnC2 := CircuitPredicate.CircuitNotSsubset\n\n/-- Axiom (C3) from Bruhn et al. -/\ndef CircuitPredicate.BruhnC3 (P : CircuitPredicate \u03b1) : Prop :=\n  \u2200 X C : Set \u03b1, \u2200 F : ValidFamily P X, \u2200 z \u2208 C \\ F.union, \u2203 C' : Set \u03b1, P C' \u2227 z \u2208 C' \u2227 C' \u2286 (C \u222a F.union) \\ X\n\n/-- Axiom (CM) from Bruhn et al.: set of all independent sets has the maximal subset property. -/\ndef CircuitPredicate.CircuitMaximal (P : CircuitPredicate \u03b1) (E : Set \u03b1) : Prop :=\n  \u2200 X : Set \u03b1, X \u2286 E \u2192 Matroid.ExistsMaximalSubsetProperty (P.toIndepPredicate E) X\nalias CircuitPredicate.BruhnCM := CircuitPredicate.CircuitMaximal\n\n/-- Every circuit is a subset of the ground set. -/\ndef CircuitPredicate.SubsetGround (P : CircuitPredicate \u03b1) (E : Set \u03b1) : Prop :=\n  \u2200 C : Set \u03b1, P C \u2192 C \u2286 E\nalias CircuitPredicate.BruhnCE := CircuitPredicate.SubsetGround\n\n/-- Strong circuit elimination axiom: if `C\u2081` and `C\u2082` are circuits with `e \u2208 C\u2081 \u2229 C\u2082` and `f \u2208 C\u2081 \\ C\u2082`,\n    then there is circuit `C\u2083` such that `f \u2208 C\u2083 \u2286 C\u2081 \u222a C\u2082 \\ {e}`. -/\ndef CircuitPredicate.StrongCircuitElim (P : CircuitPredicate \u03b1) : Prop :=\n  \u2200 C\u2081 C\u2082 : Set \u03b1, \u2200 e f, P C\u2081 \u2227 P C\u2082 \u2227 e \u2208 C\u2081 \u2229 C\u2082 \u2227 f \u2208 C\u2081 \\ C\u2082 \u2192 \u2203 C\u2083, P C\u2083 \u2227 f \u2208 C\u2083 \u2227 C\u2083 \u2286 (C\u2081 \u222a C\u2082) \\ {e}\n\n/-- Weak circuit elimination axiom: if `C\u2081` and `C\u2082` are distinct circuits and `e \u2208 C\u2081 \u2229 C\u2082`,\n    then there is circuit `C\u2083` such that `C\u2083 \u2286 C\u2081 \u222a C\u2082 \\ {e}`. -/\ndef CircuitPredicate.WeakCircuitElim (P : CircuitPredicate \u03b1) : Prop :=\n  \u2200 C\u2081 C\u2082 : Set \u03b1, C\u2081 \u2260 C\u2082 \u2192 P C\u2081 \u2192 P C\u2082 \u2192 \u2200 e \u2208 C\u2081 \u2229 C\u2082, \u2203 C\u2083, P C\u2083 \u2227 C\u2083 \u2286 (C\u2081 \u222a C\u2082) \\ {e}\n\nend CircuitAxioms\n\n\nsection CircuitAxiomRelations\n\n/-- Alternative formulation of axiom (C2). -/\nlemma CircuitPredicate.circuit_not_ssubset_iff (P : CircuitPredicate \u03b1) :\n    P.CircuitNotSsubset \u2194 \u2200 C C' : Set \u03b1, P C \u2192 P C' \u2192 C' \u2286 C \u2192 C \u2286 C' := by\n  constructor\n  \u00b7 intro hP C C' hC hC' hCC'\n    apply hP C C' hC at hC'\n    rw [ssubset_iff_subset_ne] at hC'\n    push_neg at hC'\n    exact (hC' hCC').symm.subset\n  \u00b7 intro hP C C' hC hC' hCC'\n    apply hP C C' hC at hC'\n    rw [ssubset_iff_subset_ne] at hCC'\n    exact hCC'.right.symm (Set.Subset.antisymm (hC' hCC'.left) hCC'.left)\n\n", "theoremStatement": "/-- Axiom (C3) implies strong circuit elimination. -/\nlemma CircuitPredicate.C3_strong_circuit_elim (P : CircuitPredicate \u03b1) :\n    P.BruhnC3 \u2192 P.StrongCircuitElim ", "theoremName": "CircuitPredicate.C3_strong_circuit_elim", "fileCreated": {"commit": "ee35fddd27b04eb576eb64b8bb74af513408f6ef", "date": "2024-12-21"}, "theoremCreated": {"commit": "ee35fddd27b04eb576eb64b8bb74af513408f6ef", "date": "2024-12-21"}, "file": "Seymour/Seymour/Matroid/Notions/CircuitAxioms.lean", "module": "Seymour.Matroid.Notions.CircuitAxioms", "jsonFile": "Seymour.Matroid.Notions.CircuitAxioms.jsonl", "positionMetadata": {"lineInFile": 101, "tokenPositionInFile": 3948, "theoremPositionInFile": 13}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 6, "repositoryPremises": true, "numRepositoryPremises": 6, "numPremises": 55}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  intro hPC3 C\u2081 C\u2082 x z hxz\n  obtain \u27e8_hC\u2081, hC\u2082, hx, hz\u27e9 := hxz\n  let F : ValidFamily P {x} :=\n  \u27e8\n    (fun _ => C\u2082),\n    (fun _ => hC\u2082),\n    (by simpa using Set.mem_of_mem_inter_right hx)\n  \u27e9\n  specialize hPC3 {x} C\u2081 F\n  simp only [ValidFamily.union, Set.iUnion_coe_set, Set.mem_singleton_iff, Set.iUnion_iUnion_eq_left] at hPC3\n  specialize hPC3 z hz\n  exact hPC3", "proofType": "tactic", "proofLengthLines": 12, "proofLengthTokens": 370}}
{"srcContext": "import Mathlib.Data.Matroid.IndepAxioms\nimport Mathlib.Data.Matroid.Dual\n\nimport Seymour.Basic\n\n\nsection Definition\n\n/-- Vector matroid `M[A]` of matrix `A`. -/\nstructure VectorMatroid (\u03b1 R : Type) where\n  /-- Row indices. -/\n  X : Type\n  /-- Column indices. -/\n  Y : Type\n  /-- Full representation matrix. -/\n  A : Matrix X Y R\n  /-- The matrix has finite number of columns. -/\n  finY : Fintype Y\n  /-- How the columns correspond to the elements of the resulting matroid. -/\n  emb : Y \u21aa \u03b1\n\nattribute [instance] VectorMatroid.finY\n\nopen scoped Matrix\n\nvariable {\u03b1 R : Type} [DecidableEq \u03b1] [Semiring R]\n\ndef VectorMatroid.E (M : VectorMatroid \u03b1 R) : Set \u03b1 :=\n  Set.range M.emb\n\n/-- A set `S` is independent in `M[A]` iff\n    `S \u2286 Y` and `S` corresponds to a linearly independent submultiset of columns in `A`. -/\ndef VectorMatroid.IndepCols (M : VectorMatroid \u03b1 R) (S : Set \u03b1) : Prop :=\n  \u2203 hS : S \u2286 M.E, LinearIndependent R (fun s : S => (M.A \u00b7 (M.emb.invOfMemRange (hS.elem s))))\n\n/-- A set `S` is independent in `M[A]` iff\n    `S \u2286 Y` and the submatrix that contains only columns of `S` has linearly independent columns. -/\nlemma VectorMatroid.indepCols_iff_submatrix (M : VectorMatroid \u03b1 R) (S : Set \u03b1) :\n    M.IndepCols S \u2194 \u2203 hS : S \u2286 M.E, LinearIndependent R (M.A.submatrix id (M.emb.invOfMemRange \u2218 hS.elem))\u1d40 := by\n  rfl\n\n/-- Empty set is independent. -/\ntheorem VectorMatroid.indepCols_empty (M : VectorMatroid \u03b1 R) :\n    M.IndepCols \u2205 :=\n  \u27e8M.E.empty_subset, linearIndependent_empty_type\u27e9\n\n/-- A subset of a linearly independent set of columns is linearly independent. -/\ntheorem VectorMatroid.indepCols_subset (M : VectorMatroid \u03b1 R) (I J : Set \u03b1) (hMJ : M.IndepCols J) (hIJ : I \u2286 J) :\n    M.IndepCols I :=\n  have \u27e8hJ, hM\u27e9 := hMJ\n  \u27e8hIJ.trans hJ, hM.comp hIJ.elem hIJ.elem_injective\u27e9\n\n/-- A non-maximal linearly independent set of columns can be augmented with another linearly independent column. -/\ntheorem VectorMatroid.indepCols_aug (M : VectorMatroid \u03b1 R) (I J : Set \u03b1)\n    (hMI : M.IndepCols I) (hMI' : \u00acMaximal M.IndepCols I) (hMJ : Maximal M.IndepCols J) :\n    \u2203 x \u2208 J \\ I, M.IndepCols (x \u1543 I) := by\n  by_contra! non_aug\n  rw [Maximal] at hMI'\n  push_neg at hMI'\n  obtain \u27e8hI, I_indep\u27e9 := hMI\n  obtain \u27e8\u27e8hJ, J_indep\u27e9, hJ'\u27e9 := hMJ\n\n  -- let I' : Set M.E := { x : M.E.Elem | x.val \u2208 I }\n  -- let J' : Set M.E := { x : M.E.Elem | x.val \u2208 J }\n  -- let I\u1d65 : Set (M.X \u2192 R) := M.A\u1d40 '' I'\n  -- let J\u1d65 : Set (M.X \u2192 R) := M.A\u1d40 '' J'\n  -- let I\u209b : Submodule R (M.X \u2192 R) := Submodule.span R I\u1d65\n  -- let J\u209b : Submodule R (M.X \u2192 R) := Submodule.span R J\u1d65\n\n  -- have J\u1d65_ss_I\u209b : J\u1d65 \u2286 I\u209b\n  -- \u00b7 intro v \u27e8x, hxJ, hxv\u27e9\n  --   by_cases hvI : v \u2208 I\u1d65\n  --   \u00b7 aesop\n  --   \u00b7 have x_in_J : \u2191x \u2208 J := hxJ\n  --     have x_ni_I : \u2191x \u2209 I := by aesop\n  --     have x_in_JwoI : \u2191x \u2208 J \\ I := Set.mem_diff_of_mem x_in_J x_ni_I\n  --     have hMxI : \u00acM.IndepCols (\u2191x \u1543 I) := non_aug \u2191x x_in_JwoI\n  --     sorry\n  -- have I\u1d65_ss_J\u209b : I\u1d65 \u2286 J\u209b\n  -- \u00b7 intro v \u27e8x, hxI, hxv\u27e9\n  --   have hMxJ : M.IndepCols (\u2191x \u1543 J)\n  --   \u00b7 have hxJ : (\u2191x \u1543 J) \u2286 M.E := Set.insert_subset (hI hxI) hJ\n  --     have hvJ : (M.A.submatrix id hxJ.elem)\u1d40 '' Set.univ = v \u1543 J\u1d65\n  --     \u00b7 sorry\n  --     sorry\n  --   have v_in_J\u1d65 : v \u2208 J\u1d65 := by aesop\n  --   exact Set.mem_of_mem_of_subset v_in_J\u1d65 Submodule.subset_span\n  -- have J\u209b_le_I\u209b : J\u209b \u2264 I\u209b := Submodule.span_le.\u2190 J\u1d65_ss_I\u209b\n  -- have I\u209b_le_J\u209b : I\u209b \u2264 J\u209b := Submodule.span_le.\u2190 I\u1d65_ss_J\u209b\n  -- have I\u209b_eq_J\u209b : I\u209b = J\u209b := Submodule.span_eq_span I\u1d65_ss_J\u209b J\u1d65_ss_I\u209b\n  -- clear J\u1d65_ss_I\u209b I\u1d65_ss_J\u209b J\u209b_le_I\u209b I\u209b_le_J\u209b\n  sorry\n\n/-- Every set of columns contains a maximal independent subset of columns. -/\ntheorem VectorMatroid.indepCols_maximal (M : VectorMatroid \u03b1 R) (S : Set \u03b1) :\n    Matroid.ExistsMaximalSubsetProperty M.IndepCols S := by\n  sorry\n\n/-- Vector matroid expressed as `IndepMatroid`. -/\ndef VectorMatroid.toIndepMatroid (M : VectorMatroid \u03b1 R) : IndepMatroid \u03b1 where\n  E := M.E\n  Indep := M.IndepCols\n  indep_empty := M.indepCols_empty\n  indep_subset := M.indepCols_subset\n  indep_aug := M.indepCols_aug\n  indep_maximal S _ := M.indepCols_maximal S\n  subset_ground _ := Exists.choose\n\nend Definition\n\n\nsection API\n\nvariable {\u03b1 R : Type} [DecidableEq \u03b1] [Semiring R]\n\n/-- Vector matroid converted to `Matroid`. -/\ndef VectorMatroid.toMatroid (M : VectorMatroid \u03b1 R) : Matroid \u03b1 :=\n  M.toIndepMatroid.matroid\n\n@[simp]\nlemma VectorMatroid.toMatroid_E (M : VectorMatroid \u03b1 R) : M.toMatroid.E = Set.range M.emb :=\n  rfl\n\n@[simp]\nlemma VectorMatroid.toMatroid_indep (M : VectorMatroid \u03b1 R) : M.toMatroid.Indep = M.IndepCols :=\n  rfl\n\nend API\n\n\nsection EquivalentTransformations\n\n-- todo: section 2.2/6.3 from Oxley: Different matroid representations\n-- the following operations on `A` do not change `M[A]`:\n-- 2.2.1 Interchange two rows.  <-- can be generalized for free to reindexing of rows\n-- 2.2.2 Multiply a row by non-zero.\n-- 2.2.3 Replace a row by the sum of that row and another.\n-- 2.2.4 Adjoin or remove a zero row.\n-- 2.2.5 Interchange two columns (the labels moving with the columns).  <-- trivial in lean: indices are labeled and unordered\n-- 2.2.6 Multiply a column by a non-zero member of F.\n-- 2.2.7 Replace each matrix entry by its image under some automorphism of F.\n\n-- todo: if A is non-zero, it can be reduced to [I | B] by a sequence of operations of types 2.2.1-2.2.5\n\nend EquivalentTransformations\n\n\nsection StandardRepr\n\n/-- Standard matrix representation of a vector matroid.\nNot in sync with `Matroid.Operations.MatrixSums.Basic/StandardRepresentation` currently! -/\nstructure StandardRepr (\u03b1 R : Type) where\n  /-- Row indices. -/\n  X : Type\n  /-- Column indices. -/\n  Y : Type\n  /-- Standard representation matrix. -/\n  B : Matrix X Y R\n  /-- The matrix has finite number of rows and columns. -/\n  fntp : Fintype (X \u2295 Y) -- TODO two things?\n  /-- The computer can distinguish the rows from each other. -/\n  deceqX : DecidableEq X\n  /-- The computer can distinguish the cols from each other. -/\n  deceqY : DecidableEq Y\n  /-- How the rows and columns correspond to the elements of the resulting matroid. -/\n  emb : X \u2295 Y \u21aa \u03b1\n\nattribute [instance] StandardRepr.fntp\nattribute [instance] StandardRepr.deceqX\nattribute [instance] StandardRepr.deceqY\n\nvariable {\u03b1 R : Type} [Ring R]\n\n/-- Vector matroid constructed from standard representation. -/\ndef StandardRepr.toVectorMatroid (S : StandardRepr \u03b1 R) : VectorMatroid \u03b1 R :=\n  \u27e8S.X, S.X \u2295 S.Y, Matrix.fromCols 1 S.B, S.fntp, S.emb\u27e9\n\n/-- Ground set of a vector matroid is union of row and column index sets of its standard matrix representation. -/\n@[simp]\nlemma StandardRepr.toVectorMatroid_E (S : StandardRepr \u03b1 R) [DecidableEq \u03b1] :\n    S.toVectorMatroid.toMatroid.E = Set.range S.emb :=\n  rfl\n\n/-- Full representation matrix of vector matroid is `[1 | B]`. -/\n@[simp]\nlemma StandardRepr.toVectorMatroid_A (S : StandardRepr \u03b1 R) :\n    S.toVectorMatroid.A = Matrix.fromCols 1 S.B :=\n  rfl\n\n/-- Set is independent in vector matroid iff corresponding set of columns of `[1 | B]` is linearly independent over `R`. -/\n@[simp]\nlemma StandardRepr.toVectorMatroid_indep (S : StandardRepr \u03b1 R) [DecidableEq \u03b1] :\n    S.toVectorMatroid.toMatroid.Indep = S.toVectorMatroid.IndepCols :=\n  rfl\n\n/-- todo: desc -/\nlemma VectorMatroid.exists_standardRepr (M : VectorMatroid \u03b1 R) :\n    \u2203 S : StandardRepr \u03b1 R, M = S.toVectorMatroid := by\n  sorry\n\n/-- todo: desc -/\nlemma VectorMatroid.exists_standardRepr_base [DecidableEq \u03b1] {B : Set \u03b1}\n    (M : VectorMatroid \u03b1 R) (hB : M.toMatroid.Base B) (hBE : B \u2286 M.E) :\n    \u2203 S : StandardRepr \u03b1 R, M.X = B \u2227 M = S.toVectorMatroid := by\n  sorry\n\n/-- Matroid constructed from standard representation. -/\ndef StandardRepr.toMatroid [DecidableEq \u03b1] (S : StandardRepr \u03b1 R) : Matroid \u03b1 :=\n  S.toVectorMatroid.toMatroid\n\n/-- The identity matrix has linearly independent rows. -/\nlemma Matrix.one_linearIndependent [DecidableEq \u03b1] : LinearIndependent R (1 : Matrix \u03b1 \u03b1 R) := by\n-- Riccardo Brasca proved:\n  rw [linearIndependent_iff]\n  intro l hl\n  ext j\n  simpa [Finsupp.linearCombination_apply, Pi.zero_apply, Finsupp.sum_apply', Matrix.one_apply] using congr_fun hl j\n-- TODO replace with Mathlib version when available\n\n/-- todo: desc -/\nlemma StandardRepr.toMatroid_base [DecidableEq \u03b1] (S : StandardRepr \u03b1 R) :\n    S.toMatroid.Base (S.emb '' Set.range Sum.inl) := by\n  unfold StandardRepr.toMatroid StandardRepr.toVectorMatroid VectorMatroid.toMatroid\n  apply Matroid.Indep.base_of_forall_insert\n  \u00b7 simp [VectorMatroid.toIndepMatroid, VectorMatroid.IndepCols]\n    sorry\n  \u00b7 intro e he\n    -- TODO if you add anything extra to the identity matrix, it becomes singular.\n    sorry\n\nlemma Sum.swap_inj {\u03b1 \u03b2 : Type} : (@Sum.swap \u03b1 \u03b2).Injective := by\n  intro\n  aesop\n\ndef StandardRepr.dual (S : StandardRepr \u03b1 R) : StandardRepr \u03b1 R where\n  X := S.Y\n  Y := S.X\n  B := - S.B.transpose\n  fntp := Fintype.ofEquiv _ (Equiv.sumComm S.X S.Y)\n  deceqX := S.deceqY\n  deceqY := S.deceqX\n  emb := \u27e8(S.emb \u00b7.swap), S.emb.injective.comp Sum.swap_inj\u27e9\n\npostfix:max \"\u2736\" => StandardRepr.dual\n\n/-- todo: desc -/\nlemma StandardRepr.toMatroid_dual [DecidableEq \u03b1] (S : StandardRepr \u03b1 R) :\n    S.toMatroid\u2736 = S\u2736.toMatroid :=\n  sorry -- Theorem 2.2.8 in Oxley\n\n", "theoremStatement": "/-- todo: desc -/\nlemma VectorMatroid.dual_exists_standardRepr [DecidableEq \u03b1] (M : VectorMatroid \u03b1 R) :\n    \u2203 S' : StandardRepr \u03b1 R, M.toMatroid\u2736 = S'.toMatroid ", "theoremName": "VectorMatroid.dual_exists_standardRepr", "fileCreated": {"commit": "b44bff2f1ee71349fa9fa251579a0f5a0e575538", "date": "2024-12-19"}, "theoremCreated": {"commit": "bf43676cb2f39b2473eb162d9b855d46616cd5a4", "date": "2025-01-08"}, "file": "Seymour/Seymour/Matroid/Constructors/VectorMatroid.lean", "module": "Seymour.Matroid.Constructors.VectorMatroid", "jsonFile": "Seymour.Matroid.Constructors.VectorMatroid.jsonl", "positionMetadata": {"lineInFile": 251, "tokenPositionInFile": 9142, "theoremPositionInFile": 22}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 8, "repositoryPremises": true, "numRepositoryPremises": 8, "numPremises": 19}, "proofMetadata": {"hasProof": true, "proof": ":=\n  have \u27e8S, hS\u27e9 := M.exists_standardRepr\n  \u27e8S\u2736, hS \u25b8 S.toMatroid_dual\u27e9", "proofType": "term", "proofLengthLines": 2, "proofLengthTokens": 72}}
{"srcContext": "import Mathlib.Data.Set.SymmDiff\nimport Mathlib.Order.CompletePartialOrder\nimport Mathlib.Order.Disjoint\nimport Mathlib.Order.SymmDiff\nimport Mathlib.Tactic\n\nimport Seymour.Basic\n\n/-!\nThis provides lemmas about sets (mostly dealing with disjointness) that are missing in Mathlib.\n-/\n\nvariable {\u03b1 : Type}\n\nsection Other\n\nlemma set_union_union_eq_rev (X Y Z : Set \u03b1) : X \u222a Y \u222a Z = Z \u222a Y \u222a X := by\n  rw [Set.union_assoc, Set.union_comm, Set.union_comm Y Z]\n\nlemma setminus_inter_union_eq_union {X Y : Set \u03b1} : X \\ (X \u2229 Y) \u222a Y = X \u222a Y := by\n  tauto_set\n\nlemma nonempty_inter_not_ssubset_empty_inter {A B E : Set \u03b1} (hA : (A \u2229 E).Nonempty) (hB : B \u2229 E = \u2205) :\n    \u00ac(A \u2282 B) := by\n  intro \u27e8hAB, _\u27e9\n  obtain \u27e8x, hxAE\u27e9 := hA\n  have hxBE : x \u2208 B \u2229 E := (Set.inter_subset_inter hAB fun _ => id) hxAE\n  rw [hB] at hxBE\n  tauto\n\nlemma ssubset_self_union_other_elem {a : \u03b1} {X : Set \u03b1} (ha : a \u2209 X) :\n    X \u2282 X \u222a {a} := by\n  constructor\n  \u00b7 exact Set.subset_union_left\n  \u00b7 by_contra hX\n    rw [Set.union_subset_iff] at hX\n    obtain \u27e8_, haa\u27e9 := hX\n    tauto\n\nlemma singleton_union_ssubset_union_iff {a : \u03b1} {A B : Set \u03b1} (haA : a \u2209 A) (haB : a \u2209 B) :\n    A \u222a {a} \u2282 B \u222a {a} \u2194 A \u2282 B := by\n  constructor\n  \u00b7 intro hAB\n    obtain \u27e8hABl, hABr\u27e9 := hAB\n    constructor\n    \u00b7 intro x hx\n      apply ne_of_mem_of_not_mem hx at haA\n      cases hABl (Set.mem_union_left {a} hx) <;> tauto\n    \u00b7 by_contra hBA\n      apply Set.union_subset_union_left {a} at hBA\n      tauto\n  \u00b7 intro hAB\n    obtain \u27e8hABl, hABr\u27e9 := hAB\n    constructor\n    \u00b7 exact Set.union_subset_union_left {a} hABl\n    \u00b7 by_contra hBA\n      rw [Set.union_singleton, Set.union_singleton] at hBA\n      apply (Set.insert_subset_insert_iff haB).\u2192 at hBA\n      tauto\n\nlemma ssub_parts_ssub {A B E\u2081 E\u2082 : Set \u03b1}\n    (hA : A \u2286 E\u2081 \u222a E\u2082) (hB : B \u2286 E\u2081 \u222a E\u2082) (hAB\u2081 : A \u2229 E\u2081 \u2282 B \u2229 E\u2081) (hAB\u2082 : A \u2229 E\u2082 \u2282 B \u2229 E\u2082) :\n    A \u2282 B := by\n  constructor\n  \u00b7 obtain \u27e8hE\u2081, _\u27e9 := hAB\u2081\n    obtain \u27e8hE\u2082, _\u27e9 := hAB\u2082\n    rw [Set.left_eq_inter.\u2190 hA, Set.left_eq_inter.\u2190 hB, Set.inter_union_distrib_left, Set.inter_union_distrib_left]\n    exact Set.union_subset_union hE\u2081 hE\u2082\n  \u00b7 intro hBA\n    obtain \u27e8_, hE\u2081\u27e9 := hAB\u2081\n    obtain \u27e8x, hxBE\u2081, hxnAE\u2081\u27e9 := Set.not_subset.\u2192 hE\u2081\n    have hxB : x \u2208 B := Set.mem_of_mem_inter_left hxBE\u2081\n    have hxE\u2081 : x \u2208 E\u2081 := Set.mem_of_mem_inter_right hxBE\u2081\n    tauto\n\nlemma HasSubset.Subset.parts_eq {A E\u2081 E\u2082 : Set \u03b1} (hA : A \u2286 E\u2081 \u222a E\u2082) : (A \u2229 E\u2081) \u222a (A \u2229 E\u2082) = A :=\n  ((subset_of_subset_of_eq\n    (Set.subset_inter (fun _ => id) hA)\n    (Set.inter_union_distrib_left A E\u2081 E\u2082)).antisymm\n  (Set.union_subset Set.inter_subset_left Set.inter_subset_left)).symm\n\nlemma elem_notin_set_minus_singleton (a : \u03b1) (X : Set \u03b1) : a \u2209 X \\ {a} := Set.not_mem_diff_of_mem rfl\n\nlemma sub_union_diff_sub_union {A B C : Set \u03b1} (hA : A \u2286 B \\ C) : A \u2286 B :=\n  fun _ hA' => Set.diff_subset (hA hA')\n\nlemma singleton_inter_in_left {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : a \u2208 X :=\n  Set.mem_of_mem_inter_left (ha.symm.subset rfl)\n\nlemma singleton_inter_in_right {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : a \u2208 Y :=\n  Set.mem_of_mem_inter_right (ha.symm.subset rfl)\n\nlemma singleton_inter_subset_left {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : {a} \u2286 X := by\n  rw [Set.singleton_subset_iff]\n  exact singleton_inter_in_left ha\n\nlemma singleton_inter_subset_right {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : {a} \u2286 Y := by\n  rw [Set.singleton_subset_iff]\n  exact singleton_inter_in_right ha\n\n/-- Being a subset is preserved under subtracting sets. -/\nlemma diff_subset_parent {X\u2081 X\u2082 E : Set \u03b1} (hX\u2081E : X\u2081 \u2286 E) :\n    X\u2081 \\ X\u2082 \u2286 E :=\n  Set.diff_subset_iff.\u2190 (Set.subset_union_of_subset_right hX\u2081E X\u2082)\n\n/-- Being a subset is preserved under taking intersections. -/\nlemma inter_subset_parent_left {X\u2081 X\u2082 E : Set \u03b1} (hX\u2081E : X\u2081 \u2286 E) :\n    X\u2081 \u2229 X\u2082 \u2286 E :=\n  (Set.inter_subset_inter_left X\u2082 hX\u2081E).trans Set.inter_subset_left\n\n/-- Being a subset is preserved under taking intersections. -/\nlemma inter_subset_parent_right {X\u2081 X\u2082 E : Set \u03b1} (hX\u2082E : X\u2082 \u2286 E) :\n    X\u2081 \u2229 X\u2082 \u2286 E := by\n  rw [Set.inter_comm]\n  exact inter_subset_parent_left hX\u2082E\n\n/-- Intersection of two sets is subset of their union. -/\nlemma inter_subset_union {X\u2081 X\u2082 : Set \u03b1} :\n    X\u2081 \u2229 X\u2082 \u2286 X\u2081 \u222a X\u2082 :=\n  inter_subset_parent_left Set.subset_union_left\n\nlemma subset_diff_empty_eq {A B : Set \u03b1} (hAB : A \u2286 B) (hBA : B \\ A = \u2205) : A = B :=\n  A.union_empty \u25b8 hBA \u25b8 Set.union_diff_cancel hAB\n\nend Other\n\n\nsection Disjoint\n\nlemma Disjoint.ni_of_in {X Y : Set \u03b1} {a : \u03b1} (hXY : X \u2ad7 Y) (ha : a \u2208 X) :\n    a \u2209 Y := by\n  intro ha'\n  simpa [hXY.inter_eq] using Set.mem_inter ha ha'\n\nlemma disjoint_of_singleton_inter_left_wo {X Y : Set \u03b1} {a : \u03b1} (hXY : X \u2229 Y = {a}) :\n    X \\ {a} \u2ad7 Y := by\n  tauto_set\n\nlemma disjoint_of_singleton_inter_right_wo {X Y : Set \u03b1} {a : \u03b1} (hXY : X \u2229 Y = {a}) :\n    X \u2ad7 Y \\ {a} := by\n  rw [disjoint_comm]\n  rw [Set.inter_comm] at hXY\n  exact disjoint_of_singleton_inter_left_wo hXY\n\nlemma disjoint_of_singleton_inter_both_wo {X Y : Set \u03b1} {a : \u03b1} (hXY : X \u2229 Y = {a}) :\n    X \\ {a} \u2ad7 Y \\ {a} :=\n  Disjoint.disjoint_sdiff_left (disjoint_of_singleton_inter_right_wo hXY)\n\n", "theoremStatement": "lemma disjoint_of_singleton_inter_subset_left {X Y Z : Set \u03b1} {a : \u03b1} (hXY : X \u2229 Y = {a}) (hZ : Z \u2286 X) (haZ : a \u2209 Z) :\n    Z \u2ad7 Y ", "theoremName": "disjoint_of_singleton_inter_subset_left", "fileCreated": {"commit": "b44bff2f1ee71349fa9fa251579a0f5a0e575538", "date": "2024-12-19"}, "theoremCreated": {"commit": "f9d717ecfb54b3a7b794411b4c1af1f5c8ffb7c3", "date": "2024-12-26"}, "file": "Seymour/Seymour/ForMathlib/SetTheory.lean", "module": "Seymour.ForMathlib.SetTheory", "jsonFile": "Seymour.ForMathlib.SetTheory.jsonl", "positionMetadata": {"lineInFile": 149, "tokenPositionInFile": 5048, "theoremPositionInFile": 22}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 48}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  have hY : (Y \\ {a}) \u222a {a} = Y := (Set.diff_union_of_subset (singleton_inter_subset_right hXY))\n  rw [\u2190hY, Set.disjoint_union_right]\n  constructor\n  \u00b7 exact Set.disjoint_of_subset_left hZ (disjoint_of_singleton_inter_right_wo hXY)\n  \u00b7 exact Set.disjoint_singleton_right.\u2190 haZ", "proofType": "tactic", "proofLengthLines": 5, "proofLengthTokens": 282}}
{"srcContext": "import Mathlib.Data.Set.Card\nimport Mathlib.Data.Matroid.Dual\n\nimport Seymour.ForMathlib.SetTheory\nimport Seymour.Matroid.Notions.Circuit\nimport Seymour.Matroid.Notions.CircuitAxioms\nimport Seymour.Matroid.Notions.Connectivity\nimport Seymour.Matroid.Constructors.CircuitMatroid\n\n/-!\nThis file defines 2-sum of two (general) matroids `M\u2081` and `M\u2082`, denoted as `M\u2081 \u2295\u2082 M\u2082`.\n-/\n\nvariable {\u03b1 : Type}\n\n\nsection MainDefinitions\n\n/-- `M\u2081 \u2295\u2082 M\u2082` is defined if `M\u2081` and `M\u2082` satisfy the following assumptions -/\nstructure TwoSumAssumptions (M\u2081 M\u2082 : Matroid \u03b1) : Prop where\n  /-- `M\u2081` is finite -/\n  M\u2081fin : M\u2081.Finite\n  /-- `M\u2082` is finite -/\n  M\u2082fin : M\u2082.Finite\n  /-- `M\u2081` contains at least 2 elements -/\n  M\u2081card : M\u2081.E.encard \u2265 2\n  /-- `M\u2082` contains at least 2 elements -/\n  M\u2082card : M\u2082.E.encard \u2265 2\n  /-- `M\u2081` and `M\u2082` have exactly one element in common -/\n  interSingleton : (M\u2081.E \u2229 M\u2082.E).encard = 1\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2081` -/\n  M\u2081sep : \u00acM\u2081.Separator (M\u2081.E \u2229 M\u2082.E)\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2082` -/\n  M\u2082sep : \u00acM\u2082.Separator (M\u2081.E \u2229 M\u2082.E)\n\n-- question: can avoid this assumption? -- which assumption? the finiteness?\n\n/-- Ground set of `M\u2081 \u2295\u2082 M\u2082` -/\ndef twoSumGround (M\u2081 M\u2082 : Matroid \u03b1) : Set \u03b1 :=\n  (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)\n\n/-- Type 1 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2081` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType1 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 2 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2082` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType2 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2082.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 3 of circuits in `M\u2081 \u2295\u2082 M\u2082`:\n    sets `(C\u2081 \u222a C\u2082) \\ (M\u2081.E \u2229 M\u2082.E)` where `C\u2081` and `C\u2082` are circuits in `M\u2081` and `M\u2082`, respectively,\n    and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2081` and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2082` -/\ndef TwoSumCircuitType3 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit ((C \u2229 M\u2081.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 M\u2082.Circuit ((C \u2229 M\u2082.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 C \u2286 twoSumGround M\u2081 M\u2082\n\n/-- Circuit predicate of `M\u2081 \u2295\u2082 M\u2082`, which defines 2-sum as `CircuitMatroid` -/\ndef TwoSumCircuitPred (M\u2081 M\u2082 : Matroid \u03b1) : CircuitPredicate \u03b1 :=\n  fun C : Set \u03b1 =>\n    TwoSumCircuitType1 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType2 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType3 M\u2081 M\u2082 C\n\nend MainDefinitions\n\n\nsection PropertiesAssumptions\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1}\n\n/-- 2-sum assumptions are symmetric -/\nlemma TwoSumAssumptions.symm (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    TwoSumAssumptions M\u2082 M\u2081 :=\n  \u27e8\n    assumptions.M\u2082fin,\n    assumptions.M\u2081fin,\n    assumptions.M\u2082card,\n    assumptions.M\u2081card,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.interSingleton,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2082sep,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2081sep,\n  \u27e9\n\n/-- Intersection of ground sets is nonempty -/\nlemma TwoSumAssumptions.inter_nonempty (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (M\u2081.E \u2229 M\u2082.E).Nonempty :=\n  Set.one_le_encard_iff_nonempty.\u2192 assumptions.interSingleton.symm.le\n\n/-- Intersection of ground sets is a singleton set -/\nlemma TwoSumAssumptions.inter_singleton (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    \u2203 p : \u03b1, M\u2081.E \u2229 M\u2082.E = {p} :=\n  Set.encard_eq_one.\u2192 assumptions.interSingleton\n\nvariable {p : \u03b1}\n\n/-- Singleton element in intersection of ground sets in not a loop in `M\u2081` -/\nlemma TwoSumAssumptions.inter_singleton_not_loop_M\u2081 (assumptions : TwoSumAssumptions M\u2081 M\u2082)\n    (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2081.Loop p) :=\n  (hp \u25b8 assumptions.M\u2081sep <| Matroid.separator_loop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a coloop in `M\u2081` -/\nlemma TwoSumAssumptions.inter_singleton_not_coloop_M\u2081 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2081.Coloop p) :=\n  (hp \u25b8 assumptions.M\u2081sep <| Matroid.separator_coloop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a loop in `M\u2082` -/\nlemma TwoSumAssumptions.inter_singleton_not_loop_M\u2082 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2082.Loop p) :=\n  (hp \u25b8 assumptions.M\u2082sep <| Matroid.separator_loop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a coloop in `M\u2082` -/\nlemma TwoSumAssumptions.inter_singleton_not_coloop_M\u2082 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2082.Coloop p) :=\n  (hp \u25b8 assumptions.M\u2082sep <| Matroid.separator_coloop \u00b7)\n\nend PropertiesAssumptions\n\n\nsection PropertiesGroundSet\n\n/-- Ground set of 2-sum is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma twoSumGround_disjoint_inter (M\u2081 M\u2082 : Matroid \u03b1) :\n    twoSumGround M\u2081 M\u2082 \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  Set.disjoint_sdiff_left\n\n/-- Ground sets minus their intersection are disjoint sets -/\nlemma twoSum_disjoint_grounds_diff_inter (M\u2081 M\u2082 : Matroid \u03b1) :\n    M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) \u2ad7 M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E) := by\n  rw [Set.diff_self_inter, Set.diff_inter_self_eq_diff]\n  exact disjoint_sdiff_sdiff\n\nend PropertiesGroundSet\n\n\nsection PropertiesCircuitType1\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1} {C : Set \u03b1}\n\n/-- Circuit of type 1 is a circuit in `M\u2081` -/\nlemma TwoSumCircuitType1.circuit_M\u2081 (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : M\u2081.Circuit C :=\n  hC.left\n\n/-- Circuit of type 1 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType1.disjoint_inter (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of type 1 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma TwoSumCircuitType1.subset_union (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_left hC.circuit_M\u2081.subset_ground M\u2082.E\n\n/-- Circuit of type 1 lies in ground set of `M\u2081 \u2295\u2082 M\u2082` -/\nlemma TwoSumCircuitType1.subset_ground (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 twoSumGround M\u2081 M\u2082 :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 1 lies in `M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma TwoSumCircuitType1.subset_M\u2081_diff_inter (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2081.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 1 is disjoint with `M\u2082.E` -/\nlemma TwoSumCircuitType1.disjoint_M\u2082 (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2ad7 M\u2082.E := by\n  have hMM := twoSum_disjoint_grounds_diff_inter M\u2081 M\u2082\n  have hCM\u2082 := Set.disjoint_of_subset_left hC.subset_M\u2081_diff_inter hMM\n  have hCM\u2082 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2082, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_right] at hCM\u2082\n  exact hCM\u2082\n\nend PropertiesCircuitType1\n\n\nsection PropertiesCircuitType2\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1} {C : Set \u03b1}\n\n/-- Circuit of type 2 is a circuit in `M\u2082` -/\nlemma TwoSumCircuitType2.circuit_M\u2082 (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : M\u2082.Circuit C :=\n  hC.left\n\n", "theoremStatement": "/-- Circuit of type 2 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType2.disjoint_inter (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E \u2229 M\u2082.E ", "theoremName": "TwoSumCircuitType2.disjoint_inter", "fileCreated": {"commit": "d0eaaa305c96cd81ac061f505a81614db6856b21", "date": "2025-01-09"}, "theoremCreated": {"commit": "439c72996f29168161b974bc602629cac773728f", "date": "2025-01-08"}, "file": "Seymour/Seymour/Matroid/Operations/Sum2/Basic.lean", "module": "Seymour.Matroid.Operations.Sum2.Basic", "jsonFile": "Seymour.Matroid.Operations.Sum2.Basic.jsonl", "positionMetadata": {"lineInFile": 178, "tokenPositionInFile": 6617, "theoremPositionInFile": 21}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 18}, "proofMetadata": {"hasProof": true, "proof": ":=\n  hC.right", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 13}}
{"srcContext": "import Mathlib.Data.Matroid.IndepAxioms\nimport Mathlib.Data.Matroid.Dual\n\nimport Seymour.Basic\n\n\nsection Definition\n\n/-- Vector matroid `M[A]` of matrix `A`. -/\nstructure VectorMatroid (\u03b1 R : Type) where\n  /-- Row indices. -/\n  X : Type\n  /-- Column indices. -/\n  Y : Type\n  /-- Full representation matrix. -/\n  A : Matrix X Y R\n  /-- The matrix has finite number of columns. -/\n  finY : Fintype Y\n  /-- How the columns correspond to the elements of the resulting matroid. -/\n  emb : Y \u21aa \u03b1\n\nattribute [instance] VectorMatroid.finY\n\nopen scoped Matrix\n\nvariable {\u03b1 R : Type} [DecidableEq \u03b1] [Semiring R]\n\ndef VectorMatroid.E (M : VectorMatroid \u03b1 R) : Set \u03b1 :=\n  Set.range M.emb\n\n/-- A set `S` is independent in `M[A]` iff\n    `S \u2286 Y` and `S` corresponds to a linearly independent submultiset of columns in `A`. -/\ndef VectorMatroid.IndepCols (M : VectorMatroid \u03b1 R) (S : Set \u03b1) : Prop :=\n  \u2203 hS : S \u2286 M.E, LinearIndependent R (fun s : S => (M.A \u00b7 (M.emb.invOfMemRange (hS.elem s))))\n\n/-- A set `S` is independent in `M[A]` iff\n    `S \u2286 Y` and the submatrix that contains only columns of `S` has linearly independent columns. -/\nlemma VectorMatroid.indepCols_iff_submatrix (M : VectorMatroid \u03b1 R) (S : Set \u03b1) :\n    M.IndepCols S \u2194 \u2203 hS : S \u2286 M.E, LinearIndependent R (M.A.submatrix id (M.emb.invOfMemRange \u2218 hS.elem))\u1d40 := by\n  rfl\n\n/-- Empty set is independent. -/\ntheorem VectorMatroid.indepCols_empty (M : VectorMatroid \u03b1 R) :\n    M.IndepCols \u2205 :=\n  \u27e8M.E.empty_subset, linearIndependent_empty_type\u27e9\n\n/-- A subset of a linearly independent set of columns is linearly independent. -/\ntheorem VectorMatroid.indepCols_subset (M : VectorMatroid \u03b1 R) (I J : Set \u03b1) (hMJ : M.IndepCols J) (hIJ : I \u2286 J) :\n    M.IndepCols I :=\n  have \u27e8hJ, hM\u27e9 := hMJ\n  \u27e8hIJ.trans hJ, hM.comp hIJ.elem hIJ.elem_injective\u27e9\n\n/-- A non-maximal linearly independent set of columns can be augmented with another linearly independent column. -/\ntheorem VectorMatroid.indepCols_aug (M : VectorMatroid \u03b1 R) (I J : Set \u03b1)\n    (hMI : M.IndepCols I) (hMI' : \u00acMaximal M.IndepCols I) (hMJ : Maximal M.IndepCols J) :\n    \u2203 x \u2208 J \\ I, M.IndepCols (x \u1543 I) := by\n  by_contra! non_aug\n  rw [Maximal] at hMI'\n  push_neg at hMI'\n  obtain \u27e8hI, I_indep\u27e9 := hMI\n  obtain \u27e8\u27e8hJ, J_indep\u27e9, hJ'\u27e9 := hMJ\n\n  -- let I' : Set M.E := { x : M.E.Elem | x.val \u2208 I }\n  -- let J' : Set M.E := { x : M.E.Elem | x.val \u2208 J }\n  -- let I\u1d65 : Set (M.X \u2192 R) := M.A\u1d40 '' I'\n  -- let J\u1d65 : Set (M.X \u2192 R) := M.A\u1d40 '' J'\n  -- let I\u209b : Submodule R (M.X \u2192 R) := Submodule.span R I\u1d65\n  -- let J\u209b : Submodule R (M.X \u2192 R) := Submodule.span R J\u1d65\n\n  -- have J\u1d65_ss_I\u209b : J\u1d65 \u2286 I\u209b\n  -- \u00b7 intro v \u27e8x, hxJ, hxv\u27e9\n  --   by_cases hvI : v \u2208 I\u1d65\n  --   \u00b7 aesop\n  --   \u00b7 have x_in_J : \u2191x \u2208 J := hxJ\n  --     have x_ni_I : \u2191x \u2209 I := by aesop\n  --     have x_in_JwoI : \u2191x \u2208 J \\ I := Set.mem_diff_of_mem x_in_J x_ni_I\n  --     have hMxI : \u00acM.IndepCols (\u2191x \u1543 I) := non_aug \u2191x x_in_JwoI\n  --     sorry\n  -- have I\u1d65_ss_J\u209b : I\u1d65 \u2286 J\u209b\n  -- \u00b7 intro v \u27e8x, hxI, hxv\u27e9\n  --   have hMxJ : M.IndepCols (\u2191x \u1543 J)\n  --   \u00b7 have hxJ : (\u2191x \u1543 J) \u2286 M.E := Set.insert_subset (hI hxI) hJ\n  --     have hvJ : (M.A.submatrix id hxJ.elem)\u1d40 '' Set.univ = v \u1543 J\u1d65\n  --     \u00b7 sorry\n  --     sorry\n  --   have v_in_J\u1d65 : v \u2208 J\u1d65 := by aesop\n  --   exact Set.mem_of_mem_of_subset v_in_J\u1d65 Submodule.subset_span\n  -- have J\u209b_le_I\u209b : J\u209b \u2264 I\u209b := Submodule.span_le.\u2190 J\u1d65_ss_I\u209b\n  -- have I\u209b_le_J\u209b : I\u209b \u2264 J\u209b := Submodule.span_le.\u2190 I\u1d65_ss_J\u209b\n  -- have I\u209b_eq_J\u209b : I\u209b = J\u209b := Submodule.span_eq_span I\u1d65_ss_J\u209b J\u1d65_ss_I\u209b\n  -- clear J\u1d65_ss_I\u209b I\u1d65_ss_J\u209b J\u209b_le_I\u209b I\u209b_le_J\u209b\n  sorry\n\n/-- Every set of columns contains a maximal independent subset of columns. -/\ntheorem VectorMatroid.indepCols_maximal (M : VectorMatroid \u03b1 R) (S : Set \u03b1) :\n    Matroid.ExistsMaximalSubsetProperty M.IndepCols S := by\n  sorry\n\n/-- Vector matroid expressed as `IndepMatroid`. -/\ndef VectorMatroid.toIndepMatroid (M : VectorMatroid \u03b1 R) : IndepMatroid \u03b1 where\n  E := M.E\n  Indep := M.IndepCols\n  indep_empty := M.indepCols_empty\n  indep_subset := M.indepCols_subset\n  indep_aug := M.indepCols_aug\n  indep_maximal S _ := M.indepCols_maximal S\n  subset_ground _ := Exists.choose\n\nend Definition\n\n\nsection API\n\nvariable {\u03b1 R : Type} [DecidableEq \u03b1] [Semiring R]\n\n/-- Vector matroid converted to `Matroid`. -/\ndef VectorMatroid.toMatroid (M : VectorMatroid \u03b1 R) : Matroid \u03b1 :=\n  M.toIndepMatroid.matroid\n\n@[simp]\nlemma VectorMatroid.toMatroid_E (M : VectorMatroid \u03b1 R) : M.toMatroid.E = Set.range M.emb :=\n  rfl\n\n@[simp]\nlemma VectorMatroid.toMatroid_indep (M : VectorMatroid \u03b1 R) : M.toMatroid.Indep = M.IndepCols :=\n  rfl\n\nend API\n\n\nsection EquivalentTransformations\n\n-- todo: section 2.2/6.3 from Oxley: Different matroid representations\n-- the following operations on `A` do not change `M[A]`:\n-- 2.2.1 Interchange two rows.  <-- can be generalized for free to reindexing of rows\n-- 2.2.2 Multiply a row by non-zero.\n-- 2.2.3 Replace a row by the sum of that row and another.\n-- 2.2.4 Adjoin or remove a zero row.\n-- 2.2.5 Interchange two columns (the labels moving with the columns).  <-- trivial in lean: indices are labeled and unordered\n-- 2.2.6 Multiply a column by a non-zero member of F.\n-- 2.2.7 Replace each matrix entry by its image under some automorphism of F.\n\n-- todo: if A is non-zero, it can be reduced to [I | B] by a sequence of operations of types 2.2.1-2.2.5\n\nend EquivalentTransformations\n\n\nsection StandardRepr\n\n/-- Standard matrix representation of a vector matroid.\nNot in sync with `Matroid.Operations.MatrixSums.Basic/StandardRepresentation` currently! -/\nstructure StandardRepr (\u03b1 R : Type) where\n  /-- Row indices. -/\n  X : Type\n  /-- Column indices. -/\n  Y : Type\n  /-- Standard representation matrix. -/\n  B : Matrix X Y R\n  /-- The matrix has finite number of rows and columns. -/\n  fntp : Fintype (X \u2295 Y) -- TODO two things?\n  /-- The computer can distinguish the rows from each other. -/\n  deceqX : DecidableEq X\n  /-- The computer can distinguish the cols from each other. -/\n  deceqY : DecidableEq Y\n  /-- How the rows and columns correspond to the elements of the resulting matroid. -/\n  emb : X \u2295 Y \u21aa \u03b1\n\nattribute [instance] StandardRepr.fntp\nattribute [instance] StandardRepr.deceqX\nattribute [instance] StandardRepr.deceqY\n\nvariable {\u03b1 R : Type} [Ring R]\n\n/-- Vector matroid constructed from standard representation. -/\ndef StandardRepr.toVectorMatroid (S : StandardRepr \u03b1 R) : VectorMatroid \u03b1 R :=\n  \u27e8S.X, S.X \u2295 S.Y, Matrix.fromCols 1 S.B, S.fntp, S.emb\u27e9\n\n/-- Ground set of a vector matroid is union of row and column index sets of its standard matrix representation. -/\n@[simp]\nlemma StandardRepr.toVectorMatroid_E (S : StandardRepr \u03b1 R) [DecidableEq \u03b1] :\n    S.toVectorMatroid.toMatroid.E = Set.range S.emb :=\n  rfl\n\n", "theoremStatement": "/-- Full representation matrix of vector matroid is `[1 | B]`. -/\n@[simp]\nlemma StandardRepr.toVectorMatroid_A (S : StandardRepr \u03b1 R) :\n    S.toVectorMatroid.A = Matrix.fromCols 1 S.B ", "theoremName": "StandardRepr.toVectorMatroid_A", "fileCreated": {"commit": "b44bff2f1ee71349fa9fa251579a0f5a0e575538", "date": "2024-12-19"}, "theoremCreated": {"commit": "2d1a3fae44547e6345fe578dcc09d47887797f9b", "date": "2025-01-08"}, "file": "Seymour/Seymour/Matroid/Constructors/VectorMatroid.lean", "module": "Seymour.Matroid.Constructors.VectorMatroid", "jsonFile": "Seymour.Matroid.Constructors.VectorMatroid.jsonl", "positionMetadata": {"lineInFile": 184, "tokenPositionInFile": 6681, "theoremPositionInFile": 12}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 9, "repositoryPremises": true, "numRepositoryPremises": 9, "numPremises": 25}, "proofMetadata": {"hasProof": true, "proof": ":=\n  rfl", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 8}}
{"srcContext": "import Mathlib.Data.Set.Card\nimport Mathlib.Data.Matroid.Dual\n\nimport Seymour.ForMathlib.SetTheory\nimport Seymour.Matroid.Notions.Circuit\nimport Seymour.Matroid.Notions.CircuitAxioms\nimport Seymour.Matroid.Notions.Connectivity\nimport Seymour.Matroid.Constructors.CircuitMatroid\n\n/-!\nThis file defines 2-sum of two (general) matroids `M\u2081` and `M\u2082`, denoted as `M\u2081 \u2295\u2082 M\u2082`.\n-/\n\nvariable {\u03b1 : Type}\n\n\nsection MainDefinitions\n\n/-- `M\u2081 \u2295\u2082 M\u2082` is defined if `M\u2081` and `M\u2082` satisfy the following assumptions -/\nstructure TwoSumAssumptions (M\u2081 M\u2082 : Matroid \u03b1) : Prop where\n  /-- `M\u2081` is finite -/\n  M\u2081fin : M\u2081.Finite\n  /-- `M\u2082` is finite -/\n  M\u2082fin : M\u2082.Finite\n  /-- `M\u2081` contains at least 2 elements -/\n  M\u2081card : M\u2081.E.encard \u2265 2\n  /-- `M\u2082` contains at least 2 elements -/\n  M\u2082card : M\u2082.E.encard \u2265 2\n  /-- `M\u2081` and `M\u2082` have exactly one element in common -/\n  interSingleton : (M\u2081.E \u2229 M\u2082.E).encard = 1\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2081` -/\n  M\u2081sep : \u00acM\u2081.Separator (M\u2081.E \u2229 M\u2082.E)\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2082` -/\n  M\u2082sep : \u00acM\u2082.Separator (M\u2081.E \u2229 M\u2082.E)\n\n-- question: can avoid this assumption? -- which assumption? the finiteness?\n\n/-- Ground set of `M\u2081 \u2295\u2082 M\u2082` -/\ndef twoSumGround (M\u2081 M\u2082 : Matroid \u03b1) : Set \u03b1 :=\n  (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)\n\n/-- Type 1 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2081` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType1 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 2 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2082` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType2 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2082.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 3 of circuits in `M\u2081 \u2295\u2082 M\u2082`:\n    sets `(C\u2081 \u222a C\u2082) \\ (M\u2081.E \u2229 M\u2082.E)` where `C\u2081` and `C\u2082` are circuits in `M\u2081` and `M\u2082`, respectively,\n    and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2081` and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2082` -/\ndef TwoSumCircuitType3 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit ((C \u2229 M\u2081.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 M\u2082.Circuit ((C \u2229 M\u2082.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 C \u2286 twoSumGround M\u2081 M\u2082\n\n/-- Circuit predicate of `M\u2081 \u2295\u2082 M\u2082`, which defines 2-sum as `CircuitMatroid` -/\ndef TwoSumCircuitPred (M\u2081 M\u2082 : Matroid \u03b1) : CircuitPredicate \u03b1 :=\n  fun C : Set \u03b1 =>\n    TwoSumCircuitType1 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType2 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType3 M\u2081 M\u2082 C\n\nend MainDefinitions\n\n\nsection PropertiesAssumptions\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1}\n\n/-- 2-sum assumptions are symmetric -/\nlemma TwoSumAssumptions.symm (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    TwoSumAssumptions M\u2082 M\u2081 :=\n  \u27e8\n    assumptions.M\u2082fin,\n    assumptions.M\u2081fin,\n    assumptions.M\u2082card,\n    assumptions.M\u2081card,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.interSingleton,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2082sep,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2081sep,\n  \u27e9\n\n/-- Intersection of ground sets is nonempty -/\nlemma TwoSumAssumptions.inter_nonempty (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (M\u2081.E \u2229 M\u2082.E).Nonempty :=\n  Set.one_le_encard_iff_nonempty.\u2192 assumptions.interSingleton.symm.le\n\n/-- Intersection of ground sets is a singleton set -/\nlemma TwoSumAssumptions.inter_singleton (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    \u2203 p : \u03b1, M\u2081.E \u2229 M\u2082.E = {p} :=\n  Set.encard_eq_one.\u2192 assumptions.interSingleton\n\nvariable {p : \u03b1}\n\n/-- Singleton element in intersection of ground sets in not a loop in `M\u2081` -/\nlemma TwoSumAssumptions.inter_singleton_not_loop_M\u2081 (assumptions : TwoSumAssumptions M\u2081 M\u2082)\n    (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2081.Loop p) :=\n  (hp \u25b8 assumptions.M\u2081sep <| Matroid.separator_loop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a coloop in `M\u2081` -/\nlemma TwoSumAssumptions.inter_singleton_not_coloop_M\u2081 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2081.Coloop p) :=\n  (hp \u25b8 assumptions.M\u2081sep <| Matroid.separator_coloop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a loop in `M\u2082` -/\nlemma TwoSumAssumptions.inter_singleton_not_loop_M\u2082 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2082.Loop p) :=\n  (hp \u25b8 assumptions.M\u2082sep <| Matroid.separator_loop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a coloop in `M\u2082` -/\nlemma TwoSumAssumptions.inter_singleton_not_coloop_M\u2082 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2082.Coloop p) :=\n  (hp \u25b8 assumptions.M\u2082sep <| Matroid.separator_coloop \u00b7)\n\nend PropertiesAssumptions\n\n\nsection PropertiesGroundSet\n\n/-- Ground set of 2-sum is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma twoSumGround_disjoint_inter (M\u2081 M\u2082 : Matroid \u03b1) :\n    twoSumGround M\u2081 M\u2082 \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  Set.disjoint_sdiff_left\n\n/-- Ground sets minus their intersection are disjoint sets -/\nlemma twoSum_disjoint_grounds_diff_inter (M\u2081 M\u2082 : Matroid \u03b1) :\n    M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) \u2ad7 M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E) := by\n  rw [Set.diff_self_inter, Set.diff_inter_self_eq_diff]\n  exact disjoint_sdiff_sdiff\n\nend PropertiesGroundSet\n\n\nsection PropertiesCircuitType1\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1} {C : Set \u03b1}\n\n/-- Circuit of type 1 is a circuit in `M\u2081` -/\nlemma TwoSumCircuitType1.circuit_M\u2081 (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : M\u2081.Circuit C :=\n  hC.left\n\n/-- Circuit of type 1 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType1.disjoint_inter (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of type 1 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma TwoSumCircuitType1.subset_union (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_left hC.circuit_M\u2081.subset_ground M\u2082.E\n\n/-- Circuit of type 1 lies in ground set of `M\u2081 \u2295\u2082 M\u2082` -/\nlemma TwoSumCircuitType1.subset_ground (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 twoSumGround M\u2081 M\u2082 :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 1 lies in `M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma TwoSumCircuitType1.subset_M\u2081_diff_inter (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2081.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 1 is disjoint with `M\u2082.E` -/\nlemma TwoSumCircuitType1.disjoint_M\u2082 (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2ad7 M\u2082.E := by\n  have hMM := twoSum_disjoint_grounds_diff_inter M\u2081 M\u2082\n  have hCM\u2082 := Set.disjoint_of_subset_left hC.subset_M\u2081_diff_inter hMM\n  have hCM\u2082 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2082, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_right] at hCM\u2082\n  exact hCM\u2082\n\nend PropertiesCircuitType1\n\n\nsection PropertiesCircuitType2\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1} {C : Set \u03b1}\n\n/-- Circuit of type 2 is a circuit in `M\u2082` -/\nlemma TwoSumCircuitType2.circuit_M\u2082 (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : M\u2082.Circuit C :=\n  hC.left\n\n/-- Circuit of type 2 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType2.disjoint_inter (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of type 2 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma TwoSumCircuitType2.subset_union (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_right hC.circuit_M\u2082.subset_ground M\u2081.E\n\n/-- Circuit of type 2 lies in ground set of `M\u2081 \u2295\u2082 M\u2082` -/\nlemma TwoSumCircuitType2.subset_ground (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2286 twoSumGround M\u2081 M\u2082 :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 2 lies in `M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma TwoSumCircuitType2.subset_M\u2082_diff_inter (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2286 M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2082.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 2 is disjoint with `M\u2081.E` -/\nlemma TwoSumCircuitType2.disjoint_M\u2081 (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E := by\n  have hMM := twoSum_disjoint_grounds_diff_inter M\u2081 M\u2082\n  have hCM\u2081 := (Set.disjoint_of_subset_right hC.subset_M\u2082_diff_inter hMM).symm\n  have hCM\u2081 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2081, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_left] at hCM\u2081\n  exact hCM\u2081\n\nend PropertiesCircuitType2\n\n\nsection PropertiesCircuitType3\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1} {C : Set \u03b1}\n\n/-- Circuit of type 3 yields a circuit in `M\u2081` after intersecting it with `M\u2081.E` and adding `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType3.to_circuit_M\u2081 (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : M\u2081.Circuit ((C \u2229 M\u2081.E) \u222a (M\u2081.E \u2229 M\u2082.E)) :=\n  hC.left\n\n/-- Circuit of type 3 yields a circuit in `M\u2082` after intersecting it with `M\u2081.E` and adding `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType3.to_circuit_M\u2082 (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : M\u2082.Circuit ((C \u2229 M\u2082.E) \u222a (M\u2081.E \u2229 M\u2082.E)) :=\n  hC.right.left\n\n/-- Circuit of type 3 is subset of ground set of `M\u2081 \u2295\u2082 M\u2082` -/\ndef TwoSumCircuitType3.subset_ground (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2286 twoSumGround M\u2081 M\u2082 :=\n  hC.right.right\n\n/-- Circuit of type 3 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma TwoSumCircuitType3.subset_union (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \u222a M\u2082.E :=\n  sub_union_diff_sub_union hC.subset_ground\n\n/-- Circuit of type 3 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType3.disjoint_inter (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  Set.disjoint_of_subset_left hC.subset_ground (twoSumGround_disjoint_inter M\u2081 M\u2082)\n\n/-- Circuit of type 3 intersected with `M\u2081.E` is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType3.disjoint_inter_M\u2081_inter (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2229 M\u2081.E \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.disjoint_inter.inter_left M\u2081.E\n\n/-- Circuit of type 3 intersected with `M\u2082.E` is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType3.disjoint_inter_M\u2082_inter (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2229 M\u2082.E \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.disjoint_inter.inter_left M\u2082.E\n\n/-- Circuit of type 3 has nonempty intersection with `M\u2081.E` -/\nlemma TwoSumCircuitType3.inter_M\u2081_nonempty (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (C \u2229 M\u2081.E).Nonempty := by\n  by_contra! hCM\u2081\n  have hM\u2081 := hC.to_circuit_M\u2081\n  have \u27e8p, hp\u27e9 := assumptions.inter_singleton\n  rw [hCM\u2081, Set.empty_union, hp, \u2190Matroid.loop_iff_circuit M\u2081] at hM\u2081\n  have hpM\u2081 := assumptions.inter_singleton_not_loop_M\u2081 hp\n  exact hpM\u2081 hM\u2081\n\n/-- Circuit of type 3 has nonempty intersection with `M\u2082.E` -/\nlemma TwoSumCircuitType3.inter_M\u2082_nonempty (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (C \u2229 M\u2082.E).Nonempty := by\n  by_contra! hCM\u2082empty\n  have hCM\u2082 := hC.to_circuit_M\u2082\n  have \u27e8p, hp\u27e9 := assumptions.inter_singleton\n  rw [hCM\u2082empty, Set.empty_union, hp, \u2190Matroid.loop_iff_circuit M\u2082] at hCM\u2082\n  exact assumptions.inter_singleton_not_loop_M\u2082 hp hCM\u2082\n\nend PropertiesCircuitType3\n\n\nsection PropertiesCircuitTypePairs1\n\n/-- Circuit of type 1 is not a strict subset of any circuit of type 1 -/\nlemma TwoSumCircuitType1.not_ssubset_circuit_type_1 {M\u2081 M\u2082 : Matroid \u03b1} {C C' : Set \u03b1}\n    (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) (hC' : TwoSumCircuitType1 M\u2081 M\u2082 C') :\n    \u00ac(C \u2282 C') :=\n  hC.circuit_M\u2081.not_ssubset_circuit hC'.circuit_M\u2081\n\n/-- Circuit of type 1 is disjoint with any circuit of type 2 -/\nlemma TwoSumCircuitType1.disjoint_circuit_type_2 {M\u2081 M\u2082 : Matroid \u03b1} {C\u2081 C\u2082 : Set \u03b1}\n    (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) :\n    C\u2081 \u2ad7 C\u2082 := by\n  have hC\u2081M\u2081 := hC\u2081.subset_M\u2081_diff_inter\n  have hC\u2082M\u2082 := hC\u2082.subset_M\u2082_diff_inter\n  have hMM := twoSum_disjoint_grounds_diff_inter M\u2081 M\u2082\n  exact Set.disjoint_of_subset hC\u2081M\u2081 hC\u2082M\u2082 hMM\n\n/-- Circuit of type 1 is not a strict subset of any circuit of type 2 -/\nlemma TwoSumCircuitType1.not_ssubset_circuit_type_2 {M\u2081 M\u2082 : Matroid \u03b1} {C\u2081 C\u2082 : Set \u03b1}\n    (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) :\n    \u00ac(C\u2081 \u2282 C\u2082) :=\n  disjoint_nonempty_not_ssubset (hC\u2081.disjoint_circuit_type_2 hC\u2082) hC\u2081.circuit_M\u2081.nonempty\n\n/-- Circuit of type 1 is not a strict subset of any circuit of type 3 -/\nlemma TwoSumCircuitType1.not_ssubset_circuit_type_3 {M\u2081 M\u2082 : Matroid \u03b1} {C\u2081 C\u2083 : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) (hC\u2083 : TwoSumCircuitType3 M\u2081 M\u2082 C\u2083) :\n    \u00ac(C\u2081 \u2282 C\u2083) :=\n  fun hCC =>\n    hC\u2081.circuit_M\u2081.not_ssubset_circuit hC\u2083.to_circuit_M\u2081\n      (Set.ssubset_of_ssubset_of_subset (ssubset_union_disjoint_nonempty hC\u2081.disjoint_inter assumptions.inter_nonempty)\n        (Set.union_subset_union_left (M\u2081.E \u2229 M\u2082.E) (Set.subset_inter hCC.left hC\u2081.circuit_M\u2081.subset_ground)))\n\n/-- Circuit of type 1 is not a strict subset of any other circuit -/\nlemma TwoSumCircuitType1.not_ssubset_circuit {M\u2081 M\u2082 : Matroid \u03b1} {C\u2081 C : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) (hC : TwoSumCircuitPred M\u2081 M\u2082 C) :\n    \u00ac(C\u2081 \u2282 C) := by\n  cases hC with\n  | inl hC => exact hC\u2081.not_ssubset_circuit_type_1 hC\n  | inr hC => cases hC with\n    | inl hC => exact hC\u2081.not_ssubset_circuit_type_2 hC\n    | inr hC => exact hC\u2081.not_ssubset_circuit_type_3 assumptions hC\n\nend PropertiesCircuitTypePairs1\n\n\nsection PropertiesCircuitTypePairs2\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1}\n\n/-- Circuits of type 2 are disjoint with circuits of type 1 -/\nlemma TwoSumCircuitType2.disjoint_circuitType1 {C\u2081 C\u2082 : Set \u03b1}\n    (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) :\n    C\u2082 \u2ad7 C\u2081 :=\n  (hC\u2081.disjoint_circuit_type_2 hC\u2082).symm\n\n/-- Circuit of type 2 is not a strict subset of any circuit of type 1 -/\nlemma TwoSumCircuitType2.not_ssubset_circuitType1 {C\u2081 C\u2082 : Set \u03b1}\n    (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) :\n    \u00ac(C\u2082 \u2282 C\u2081) :=\n  disjoint_nonempty_not_ssubset (hC\u2082.disjoint_circuitType1 hC\u2081) hC\u2082.circuit_M\u2082.nonempty\n\n/-- Circuit of type 2 is not a strict subset of any circuit of type 2 -/\nlemma TwoSumCircuitType2.not_ssubset_circuitType2 {C C' : Set \u03b1}\n    (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) (hC' : TwoSumCircuitType2 M\u2081 M\u2082 C') :\n    \u00ac(C \u2282 C') :=\n  hC.circuit_M\u2082.not_ssubset_circuit hC'.circuit_M\u2082\n\n/-- Circuit of type 2 is not a strict subset of any circuit of type 3 -/\nlemma TwoSumAssumptions.circuitType2_not_ssubset_circuitType3 {C\u2082 C\u2083 : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) (hC\u2083 : TwoSumCircuitType3 M\u2081 M\u2082 C\u2083) :\n    \u00ac(C\u2082 \u2282 C\u2083) :=\n  fun hCC =>\n    hC\u2082.circuit_M\u2082.not_ssubset_circuit hC\u2083.to_circuit_M\u2082\n      (Set.ssubset_of_ssubset_of_subset (ssubset_union_disjoint_nonempty hC\u2082.disjoint_inter assumptions.inter_nonempty)\n        (Set.union_subset_union_left (M\u2081.E \u2229 M\u2082.E) (Set.subset_inter hCC.left hC\u2082.circuit_M\u2082.subset_ground)))\n\n/-- Circuit of type 2 is not a strict subset of any other circuit -/\nlemma TwoSumAssumptions.circuitType2_not_ssubset {C\u2082 C : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) (hC : TwoSumCircuitPred M\u2081 M\u2082 C) :\n    \u00ac(C\u2082 \u2282 C) := by\n  cases hC with\n  | inl hC => exact hC\u2082.not_ssubset_circuitType1 hC\n  | inr hC => cases hC with\n    | inl hC => exact hC\u2082.not_ssubset_circuitType2 hC\n    | inr hC => exact assumptions.circuitType2_not_ssubset_circuitType3 hC\u2082 hC\n\nend PropertiesCircuitTypePairs2\n\n\nsection PropertiesCircuitTypePairs3\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1}\n\n/-- Circuit of type 3 is not a strict subset of any circuit of type 1 -/\nlemma TwoSumAssumptions.circuitType3_not_ssubset_circuitType1 {C\u2081 C\u2083 : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2083 : TwoSumCircuitType3 M\u2081 M\u2082 C\u2083) (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) :\n    \u00ac(C\u2083 \u2282 C\u2081) :=\n  nonempty_inter_not_ssubset_empty_inter (hC\u2083.inter_M\u2082_nonempty assumptions) hC\u2081.disjoint_M\u2082.inter_eq\n\n/-- Circuit of type 3 is not a strict subset of any circuit of type 2 -/\nlemma TwoSumAssumptions.circuitType3_not_ssubset_circuitType2 {C\u2082 C\u2083 : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2083 : TwoSumCircuitType3 M\u2081 M\u2082 C\u2083) (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) :\n    \u00ac(C\u2083 \u2282 C\u2082) :=\n  nonempty_inter_not_ssubset_empty_inter (hC\u2083.inter_M\u2081_nonempty assumptions) hC\u2082.disjoint_M\u2081.inter_eq\n\n/-- Circuit of type 3 is not a strict subset of any circuit of type 3 -/\nlemma TwoSumCircuitType3.not_ssubset_circuitType3 {C C' : Set \u03b1}\n    (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) (hC' : TwoSumCircuitType3 M\u2081 M\u2082 C') :\n    \u00ac(C \u2282 C') := by\n  intro \u27e8hCC', hnCC'\u27e9\n  have M\u2081_circ_nssub := Set.ssubset_def \u25b8 hC.to_circuit_M\u2081.not_ssubset_circuit hC'.to_circuit_M\u2081\n  have M\u2082_circ_nssub := Set.ssubset_def \u25b8 hC.to_circuit_M\u2082.not_ssubset_circuit hC'.to_circuit_M\u2082\n  push_neg at M\u2081_circ_nssub\n  push_neg at M\u2082_circ_nssub\n  have M\u2081_circ_sub := (union_subset_union_iff hC'.disjoint_inter_M\u2081_inter hC.disjoint_inter_M\u2081_inter).\u2192\n    (M\u2081_circ_nssub (Set.union_subset_union_left (M\u2081.E \u2229 M\u2082.E) (Set.inter_subset_inter_left M\u2081.E hCC')))\n  have M\u2082_circ_sub := (union_subset_union_iff hC'.disjoint_inter_M\u2082_inter hC.disjoint_inter_M\u2082_inter).\u2192\n    (M\u2082_circ_nssub (Set.union_subset_union_left (M\u2081.E \u2229 M\u2082.E) (Set.inter_subset_inter_left M\u2082.E hCC')))\n  exact hnCC' (hC.subset_union.parts_eq \u25b8 hC'.subset_union.parts_eq \u25b8 Set.union_subset_union M\u2081_circ_sub M\u2082_circ_sub)\n\n/-- Circuit of type 3 is not a strict subset of any other circuit -/\nlemma TwoSumAssumptions.circuitType3_not_ssubset_circuit {C\u2083 C : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2083 : TwoSumCircuitType3 M\u2081 M\u2082 C\u2083) (hC : TwoSumCircuitPred M\u2081 M\u2082 C) :\n    \u00ac(C\u2083 \u2282 C) := by\n  cases hC with\n  | inl hC => exact assumptions.circuitType3_not_ssubset_circuitType1 hC\u2083 hC\n  | inr hC => cases hC with\n    | inl hC => exact assumptions.circuitType3_not_ssubset_circuitType2 hC\u2083 hC\n    | inr hC => exact hC\u2083.not_ssubset_circuitType3 hC\n\nend PropertiesCircuitTypePairs3\n\n\nsection PropertiesCircuitPred\n\n/-- In definition of 2-sum, empty set is not a circuit -/\nlemma TwoSumAssumptions.twoSumCircuitPred_notCircuitEmpty {M\u2081 M\u2082 : Matroid \u03b1} (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (TwoSumCircuitPred M\u2081 M\u2082).NotCircuitEmpty := by\n  unfold CircuitPredicate.NotCircuitEmpty TwoSumCircuitPred\n  push_neg\n  refine \u27e8(\u00b7.circuit_M\u2081.nonempty.ne_empty rfl), (\u00b7.circuit_M\u2082.nonempty.ne_empty rfl), fun \u27e8hpM\u2081, hpM\u2082, hE\u27e9 => ?_\u27e9\n  have \u27e8p, hp\u27e9 := assumptions.inter_singleton\n  rw [Set.empty_inter, Set.empty_union, hp, \u2190Matroid.loop_iff_circuit M\u2081] at hpM\u2081\n  exact (hp \u25b8 assumptions.M\u2081sep) (Matroid.separator_loop hpM\u2081)\n\n/-- In definition of 2-sum, no circuit is a strict subset of another -/\nlemma TwoSumAssumptions.twoSumCircuitPred_circuitNotSsubset {M\u2081 M\u2082 : Matroid \u03b1} (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (TwoSumCircuitPred M\u2081 M\u2082).CircuitNotSsubset := by\n  intro C\u2081 C\u2082 hC\u2081 hC\u2082\n  cases hC\u2082 with\n  | inl hC\u2082 => exact hC\u2082.not_ssubset_circuit assumptions hC\u2081\n  | inr hC\u2082 => cases hC\u2082 with\n    | inl hC\u2082 => exact assumptions.circuitType2_not_ssubset hC\u2082 hC\u2081\n    | inr hC\u2082 => exact assumptions.circuitType3_not_ssubset_circuit hC\u2082 hC\u2081\n\n-- todo: remaining circuit axioms\n\n/-- todo: desc -/\nlemma TwoSumAssumptions.CircuitPred.subset_ground (M\u2081 M\u2082 : Matroid \u03b1) :\n    (TwoSumCircuitPred M\u2081 M\u2082).SubsetGround (twoSumGround M\u2081 M\u2082) := by\n  intro C hC\n  cases hC with\n  | inl hC => exact hC.subset_ground\n  | inr hC => cases hC with\n    | inl hC => exact hC.subset_ground\n    | inr hC => exact hC.subset_ground\n\nend PropertiesCircuitPred\n\n\nsection TwoSumDefinition\n\n/-- `CircuitMatroid` defining `M\u2081 \u2295\u2082 M\u2082` -/\ndef TwoSumAssumptions.build2sumCircuitMatroid {M\u2081 M\u2082 : Matroid \u03b1} (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    CircuitMatroid \u03b1 where\n  E := twoSumGround M\u2081 M\u2082\n  CircuitPred := TwoSumCircuitPred M\u2081 M\u2082\n  not_circuit_empty := assumptions.twoSumCircuitPred_notCircuitEmpty\n  circuit_not_ssubset := assumptions.twoSumCircuitPred_circuitNotSsubset\n  circuit_c3 := sorry -- todo: should simplify in finite case\n  circuit_maximal := sorry -- todo: should simplify in finite case\n  subset_ground := CircuitPred.subset_ground M\u2081 M\u2082\n\n", "theoremStatement": "@[simp]\nlemma TwoSumAssumptions.build2sumCircuitMatroid_circuitPred {M\u2081 M\u2082 : Matroid \u03b1} (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    assumptions.build2sumCircuitMatroid.CircuitPred = TwoSumCircuitPred M\u2081 M\u2082 ", "theoremName": "TwoSumAssumptions.build2sumCircuitMatroid_circuitPred", "fileCreated": {"commit": "d0eaaa305c96cd81ac061f505a81614db6856b21", "date": "2025-01-09"}, "theoremCreated": {"commit": "439c72996f29168161b974bc602629cac773728f", "date": "2025-01-08"}, "file": "Seymour/Seymour/Matroid/Operations/Sum2/Basic.lean", "module": "Seymour.Matroid.Operations.Sum2.Basic", "jsonFile": "Seymour.Matroid.Operations.Sum2.Basic.jsonl", "positionMetadata": {"lineInFile": 442, "tokenPositionInFile": 19341, "theoremPositionInFile": 52}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 5, "numPremises": 8}, "proofMetadata": {"hasProof": true, "proof": ":=\n  rfl", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 8}}
{"srcContext": "import Mathlib.Data.Set.Card\nimport Mathlib.Data.Matroid.Dual\n\nimport Seymour.ForMathlib.SetTheory\nimport Seymour.Matroid.Notions.Circuit\nimport Seymour.Matroid.Notions.CircuitAxioms\nimport Seymour.Matroid.Notions.Connectivity\nimport Seymour.Matroid.Constructors.CircuitMatroid\n\n/-!\nThis file defines 2-sum of two (general) matroids `M\u2081` and `M\u2082`, denoted as `M\u2081 \u2295\u2082 M\u2082`.\n-/\n\nvariable {\u03b1 : Type}\n\n\nsection MainDefinitions\n\n/-- `M\u2081 \u2295\u2082 M\u2082` is defined if `M\u2081` and `M\u2082` satisfy the following assumptions -/\nstructure TwoSumAssumptions (M\u2081 M\u2082 : Matroid \u03b1) : Prop where\n  /-- `M\u2081` is finite -/\n  M\u2081fin : M\u2081.Finite\n  /-- `M\u2082` is finite -/\n  M\u2082fin : M\u2082.Finite\n  /-- `M\u2081` contains at least 2 elements -/\n  M\u2081card : M\u2081.E.encard \u2265 2\n  /-- `M\u2082` contains at least 2 elements -/\n  M\u2082card : M\u2082.E.encard \u2265 2\n  /-- `M\u2081` and `M\u2082` have exactly one element in common -/\n  interSingleton : (M\u2081.E \u2229 M\u2082.E).encard = 1\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2081` -/\n  M\u2081sep : \u00acM\u2081.Separator (M\u2081.E \u2229 M\u2082.E)\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2082` -/\n  M\u2082sep : \u00acM\u2082.Separator (M\u2081.E \u2229 M\u2082.E)\n\n-- question: can avoid this assumption? -- which assumption? the finiteness?\n\n/-- Ground set of `M\u2081 \u2295\u2082 M\u2082` -/\ndef twoSumGround (M\u2081 M\u2082 : Matroid \u03b1) : Set \u03b1 :=\n  (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)\n\n/-- Type 1 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2081` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType1 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 2 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2082` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType2 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2082.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 3 of circuits in `M\u2081 \u2295\u2082 M\u2082`:\n    sets `(C\u2081 \u222a C\u2082) \\ (M\u2081.E \u2229 M\u2082.E)` where `C\u2081` and `C\u2082` are circuits in `M\u2081` and `M\u2082`, respectively,\n    and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2081` and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2082` -/\ndef TwoSumCircuitType3 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit ((C \u2229 M\u2081.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 M\u2082.Circuit ((C \u2229 M\u2082.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 C \u2286 twoSumGround M\u2081 M\u2082\n\n/-- Circuit predicate of `M\u2081 \u2295\u2082 M\u2082`, which defines 2-sum as `CircuitMatroid` -/\ndef TwoSumCircuitPred (M\u2081 M\u2082 : Matroid \u03b1) : CircuitPredicate \u03b1 :=\n  fun C : Set \u03b1 =>\n    TwoSumCircuitType1 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType2 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType3 M\u2081 M\u2082 C\n\nend MainDefinitions\n\n\nsection PropertiesAssumptions\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1}\n\n/-- 2-sum assumptions are symmetric -/\nlemma TwoSumAssumptions.symm (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    TwoSumAssumptions M\u2082 M\u2081 :=\n  \u27e8\n    assumptions.M\u2082fin,\n    assumptions.M\u2081fin,\n    assumptions.M\u2082card,\n    assumptions.M\u2081card,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.interSingleton,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2082sep,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2081sep,\n  \u27e9\n\n/-- Intersection of ground sets is nonempty -/\nlemma TwoSumAssumptions.inter_nonempty (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (M\u2081.E \u2229 M\u2082.E).Nonempty :=\n  Set.one_le_encard_iff_nonempty.\u2192 assumptions.interSingleton.symm.le\n\n/-- Intersection of ground sets is a singleton set -/\nlemma TwoSumAssumptions.inter_singleton (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    \u2203 p : \u03b1, M\u2081.E \u2229 M\u2082.E = {p} :=\n  Set.encard_eq_one.\u2192 assumptions.interSingleton\n\nvariable {p : \u03b1}\n\n/-- Singleton element in intersection of ground sets in not a loop in `M\u2081` -/\nlemma TwoSumAssumptions.inter_singleton_not_loop_M\u2081 (assumptions : TwoSumAssumptions M\u2081 M\u2082)\n    (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2081.Loop p) :=\n  (hp \u25b8 assumptions.M\u2081sep <| Matroid.separator_loop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a coloop in `M\u2081` -/\nlemma TwoSumAssumptions.inter_singleton_not_coloop_M\u2081 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2081.Coloop p) :=\n  (hp \u25b8 assumptions.M\u2081sep <| Matroid.separator_coloop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a loop in `M\u2082` -/\nlemma TwoSumAssumptions.inter_singleton_not_loop_M\u2082 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2082.Loop p) :=\n  (hp \u25b8 assumptions.M\u2082sep <| Matroid.separator_loop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a coloop in `M\u2082` -/\nlemma TwoSumAssumptions.inter_singleton_not_coloop_M\u2082 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2082.Coloop p) :=\n  (hp \u25b8 assumptions.M\u2082sep <| Matroid.separator_coloop \u00b7)\n\nend PropertiesAssumptions\n\n\nsection PropertiesGroundSet\n\n/-- Ground set of 2-sum is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma twoSumGround_disjoint_inter (M\u2081 M\u2082 : Matroid \u03b1) :\n    twoSumGround M\u2081 M\u2082 \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  Set.disjoint_sdiff_left\n\n/-- Ground sets minus their intersection are disjoint sets -/\nlemma twoSum_disjoint_grounds_diff_inter (M\u2081 M\u2082 : Matroid \u03b1) :\n    M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) \u2ad7 M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E) := by\n  rw [Set.diff_self_inter, Set.diff_inter_self_eq_diff]\n  exact disjoint_sdiff_sdiff\n\nend PropertiesGroundSet\n\n\nsection PropertiesCircuitType1\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1} {C : Set \u03b1}\n\n/-- Circuit of type 1 is a circuit in `M\u2081` -/\nlemma TwoSumCircuitType1.circuit_M\u2081 (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : M\u2081.Circuit C :=\n  hC.left\n\n", "theoremStatement": "/-- Circuit of type 1 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType1.disjoint_inter (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E \u2229 M\u2082.E ", "theoremName": "TwoSumCircuitType1.disjoint_inter", "fileCreated": {"commit": "d0eaaa305c96cd81ac061f505a81614db6856b21", "date": "2025-01-09"}, "theoremCreated": {"commit": "439c72996f29168161b974bc602629cac773728f", "date": "2025-01-08"}, "file": "Seymour/Seymour/Matroid/Operations/Sum2/Basic.lean", "module": "Seymour.Matroid.Operations.Sum2.Basic", "jsonFile": "Seymour.Matroid.Operations.Sum2.Basic.jsonl", "positionMetadata": {"lineInFile": 143, "tokenPositionInFile": 5137, "theoremPositionInFile": 15}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 18}, "proofMetadata": {"hasProof": true, "proof": ":=\n  hC.right", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 13}}
{"srcContext": "import Mathlib.Data.Matroid.Closure\nimport Seymour.Basic\n\n-- we should use https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Data/Matroid/Circuit.lean instead\n\nvariable {\u03b1 : Type}\n\n/-- Circuit is minimal dependent subset. -/\ndef Matroid.Circuit (M : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  Minimal M.Dep C\n\n/-- Every circuit is dependent. -/\nlemma Matroid.Circuit.dep (M : Matroid \u03b1) {C : Set \u03b1} (hC : M.Circuit C) : M.Dep C :=\n  hC.left\n\n/-- Every circuit is a subset of the ground set. -/\nlemma Matroid.Circuit.subset_ground (M : Matroid \u03b1) {C : Set \u03b1} (hC : M.Circuit C) : C \u2286 M.E :=\n  hC.left.right\n\n/-- Equivalence with explicit definition of circuits. -/\nlemma Matroid.circuit_iff_def (M : Matroid \u03b1) (C : Set \u03b1) :\n    M.Circuit C \u2194 M.Dep C \u2227 \u2200 C' : Set \u03b1, M.Dep C' \u2192 C' \u2286 C \u2192 C \u2286 C' :=\n  rfl.to_iff\n\n/-- Every strict subset of a circuit is independent. -/\nlemma Matroid.Circuit.indep_ssub {M : Matroid \u03b1} {C C' : Set \u03b1} (hC : M.Circuit C) (hC' : C' \u2282 C) :\n    M.Indep C' := by\n  by_contra notIndep_M_C'\n  have C'_sub_C : C' \u2286 C := subset_of_ssubset hC'\n  have C_sub_E : C \u2286 M.E := hC.subset_ground\n  have C'_sub_E : C' \u2286 M.E := hC'.subset.trans C_sub_E\n  exact hC'.ne.symm ((hC.right (M.dep_of_not_indep notIndep_M_C' C'_sub_E) C'_sub_C).antisymm C'_sub_C)\n\n", "theoremStatement": "/-- Deleting one element from a circuit produces an independent set. -/\nlemma Matroid.Circuit.indep_diff_singleton {M : Matroid \u03b1} {C : Set \u03b1} {a : \u03b1} (hC : M.Circuit C) (ha : a \u2208 C) :\n    M.Indep (C \\ {a}) ", "theoremName": "Matroid.Circuit.indep_diff_singleton", "fileCreated": {"commit": "b44bff2f1ee71349fa9fa251579a0f5a0e575538", "date": "2024-12-19"}, "theoremCreated": {"commit": "ee35fddd27b04eb576eb64b8bb74af513408f6ef", "date": "2024-12-21"}, "file": "Seymour/Seymour/Matroid/Notions/Circuit.lean", "module": "Seymour.Matroid.Notions.Circuit", "jsonFile": "Seymour.Matroid.Notions.Circuit.jsonl", "positionMetadata": {"lineInFile": 34, "tokenPositionInFile": 1279, "theoremPositionInFile": 5}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 15}, "proofMetadata": {"hasProof": true, "proof": ":=\n  hC.indep_ssub (Set.diff_singleton_sSubset.\u2190 ha)", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 52}}
{"srcContext": "import Mathlib.Data.Matroid.Closure\nimport Seymour.Basic\n\n-- we should use https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Data/Matroid/Circuit.lean instead\n\nvariable {\u03b1 : Type}\n\n/-- Circuit is minimal dependent subset. -/\ndef Matroid.Circuit (M : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  Minimal M.Dep C\n\n/-- Every circuit is dependent. -/\nlemma Matroid.Circuit.dep (M : Matroid \u03b1) {C : Set \u03b1} (hC : M.Circuit C) : M.Dep C :=\n  hC.left\n\n/-- Every circuit is a subset of the ground set. -/\nlemma Matroid.Circuit.subset_ground (M : Matroid \u03b1) {C : Set \u03b1} (hC : M.Circuit C) : C \u2286 M.E :=\n  hC.left.right\n\n/-- Equivalence with explicit definition of circuits. -/\nlemma Matroid.circuit_iff_def (M : Matroid \u03b1) (C : Set \u03b1) :\n    M.Circuit C \u2194 M.Dep C \u2227 \u2200 C' : Set \u03b1, M.Dep C' \u2192 C' \u2286 C \u2192 C \u2286 C' :=\n  rfl.to_iff\n\n/-- Every strict subset of a circuit is independent. -/\nlemma Matroid.Circuit.indep_ssub {M : Matroid \u03b1} {C C' : Set \u03b1} (hC : M.Circuit C) (hC' : C' \u2282 C) :\n    M.Indep C' := by\n  by_contra notIndep_M_C'\n  have C'_sub_C : C' \u2286 C := subset_of_ssubset hC'\n  have C_sub_E : C \u2286 M.E := hC.subset_ground\n  have C'_sub_E : C' \u2286 M.E := hC'.subset.trans C_sub_E\n  exact hC'.ne.symm ((hC.right (M.dep_of_not_indep notIndep_M_C' C'_sub_E) C'_sub_C).antisymm C'_sub_C)\n\n/-- Deleting one element from a circuit produces an independent set. -/\nlemma Matroid.Circuit.indep_diff_singleton {M : Matroid \u03b1} {C : Set \u03b1} {a : \u03b1} (hC : M.Circuit C) (ha : a \u2208 C) :\n    M.Indep (C \\ {a}) :=\n  hC.indep_ssub (Set.diff_singleton_sSubset.\u2190 ha)\n\n/-- Empty set is not a circuit. -/\nlemma Matroid.Circuit.not_empty {M : Matroid \u03b1} (hM : M.Circuit \u2205) : False :=\n  hM.left.left M.empty_indep\n\n/-- Every circuit is nonempty. -/\nlemma Matroid.Circuit.nonempty {M : Matroid \u03b1} {C : Set \u03b1} (hC : M.Circuit C) : C.Nonempty := by\n  by_contra! C_empty\n  rw [C_empty] at hC\n  exact hC.not_empty\n\n/-- Independent set is not a circuit. -/\nlemma Matroid.Indep.not_circuit {M : Matroid \u03b1} {I : Set \u03b1} (hI : M.Indep I) : \u00ac(M.Circuit I) :=\n  (\u00b7.left.left hI)\n\n", "theoremStatement": "/-- No circuit is a subset of another circuit -/\nlemma Matroid.Circuit.not_ssubset_circuit {M : Matroid \u03b1} {C C' : Set \u03b1} (hC : M.Circuit C) (hC' : M.Circuit C') :\n    \u00ac(C \u2282 C') ", "theoremName": "Matroid.Circuit.not_ssubset_circuit", "fileCreated": {"commit": "b44bff2f1ee71349fa9fa251579a0f5a0e575538", "date": "2024-12-19"}, "theoremCreated": {"commit": "ee35fddd27b04eb576eb64b8bb74af513408f6ef", "date": "2024-12-21"}, "file": "Seymour/Seymour/Matroid/Notions/Circuit.lean", "module": "Seymour.Matroid.Notions.Circuit", "jsonFile": "Seymour.Matroid.Notions.Circuit.jsonl", "positionMetadata": {"lineInFile": 53, "tokenPositionInFile": 2036, "theoremPositionInFile": 9}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 1, "numPremises": 15}, "proofMetadata": {"hasProof": true, "proof": ":=\n  fun hCC => hCC.right (hC'.right hC.left hCC.subset)", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 56}}
{"srcContext": "import Seymour.Matroid.Notions.Circuit\n\n\nvariable {\u03b1 : Type}\n\n\nsection DisjointCircuitFamily\n\n/-- Family of disjoint circuits of matroid `M`. -/\nstructure Matroid.DisjointCircuitFamily (M : Matroid \u03b1) where\n  /-- Indexing set -/\n  \u03b9 : Set \u03b1\n  -- question: upgrade from indexing by Set \u03b1 to indexing by Sort v (see Set.iUnion in Mathlib.Order.SetNotation)?\n  -- note: if we know that `C` is a disjoint union of circuits of `M`,\n  -- then wlog we can choose `\u03b9` to be set of representatives of those circuits\n  /-- Set family indexed by `\u03b9` -/\n  F : \u03b9 \u2192 Set \u03b1\n  /-- All sets in family are circuits in `M` -/\n  AllCircuits : \u2200 x : \u03b9, M.Circuit (F x)\n  /-- All sets in family are disjoint -/\n  AllDisjoint : \u2200 x y : \u03b9, x \u2260 y \u2192 F x \u2ad7 F y\n\n/-- Shorthand for union of sets in `M.DisjointCircuitFamily`. -/\ndef Matroid.DisjointCircuitFamily.union {M : Matroid \u03b1} (F : M.DisjointCircuitFamily) : Set \u03b1 :=\n  Set.iUnion F.F\n\n/-- Every element in `M.DisjointCircuitFamily` is subset of ground set. -/\nlemma Matroid.DisjointCircuitFamily.mem_subset_ground {M : Matroid \u03b1} (F : M.DisjointCircuitFamily) (x : F.\u03b9) :\n    F.F x \u2286 M.E :=\n  (F.AllCircuits x).subset_ground\n\n/-- Union of sets in `M.DisjointCircuitFamily` is subset of ground set. -/\nlemma Matroid.DisjointCircuitFamily.union_subset_ground {M : Matroid \u03b1} (F : M.DisjointCircuitFamily) :\n    F.union \u2286 M.E := by\n  simp only [Matroid.DisjointCircuitFamily.union, Set.iUnion_coe_set, Set.iUnion_subset_iff]\n  exact fun i hi => mem_subset_ground F \u27e8i, hi\u27e9\n\n/-- If union of disjoint circuits is independent, then it is empty. -/\nlemma Matroid.DisjointCircuitFamily.union_indep_empty {M : Matroid \u03b1} (F : M.DisjointCircuitFamily) (hMF : M.Indep F.union):\n    F.union = \u2205 := by\n  by_contra\n  obtain \u27e8x, -\u27e9 : \u2203 x : F.\u03b9.Elem, (F.F x).Nonempty\n  \u00b7 by_contra!\n    simp_all only [Matroid.DisjointCircuitFamily.union, Set.iUnion_coe_set, Set.iUnion_empty, not_true_eq_false]\n  exact (F.AllCircuits x).left.not_indep (hMF.subset (Set.subset_iUnion_of_subset x Set.Subset.rfl))\n\n/-- Nonempty union of disjoint circuits is dependent. -/\nlemma Matroid.DisjointCircuitFamily.union_nonempty_dep {M : Matroid \u03b1} (F : M.DisjointCircuitFamily) (hF : F.union.Nonempty) :\n    M.Dep F.union := by\n  by_contra contr\n  exact Set.not_nonempty_empty (F.union_indep_empty (Matroid.indep_of_not_dep contr F.union_subset_ground) \u25b8 hF)\n\n/-- Union of disjoint circuits is either dependent or empty. -/\nlemma Matroid.DisjointCircuitFamily.dep_or_empty {M : Matroid \u03b1} (F : M.DisjointCircuitFamily) :\n    M.Dep F.union \u2228 F.union = \u2205 := by\n  if hMF : M.Indep F.union then\n    exact Or.inr (F.union_indep_empty hMF)\n  else\n    exact Or.inl \u27e8hMF, F.union_subset_ground\u27e9\n\n/-- Empty family of disjoint circuits. -/\ndef Matroid.emptyDisjointCircuitFamily (M : Matroid \u03b1) :\n    M.DisjointCircuitFamily where\n  \u03b9 := \u2205\n  F _ := \u2205\n  AllCircuits x := x.property.elim\n  AllDisjoint x := x.property.elim\n\n/-- Union of sets in empty family is empty. -/\nlemma Matroid.emptyDisjointCircuitFamily_union (M : Matroid \u03b1) :\n    M.emptyDisjointCircuitFamily.union = \u2205 :=\n  Set.iUnion_empty\n\n/-- Family of one circuit, indexed by one element --- that circuit. -/\ndef Matroid.Circuit.singleDisjointCircuitFamily {M : Matroid \u03b1} {C : Set \u03b1} (hC : M.Circuit C) (p : \u03b1) :\n    M.DisjointCircuitFamily where\n  \u03b9 := {p}\n  F _ := C\n  AllCircuits _ := hC\n  AllDisjoint x y hxy := ((x.property \u25b8 y.property \u25b8 Subtype.coe_ne_coe.\u2190 hxy) rfl).elim\n\n/-- Union of sets in family of one circuit is that circuit. -/\nlemma Matroid.Circuit.singleDisjointCircuitFamily_union {M : Matroid \u03b1} {C : Set \u03b1} (hC : M.Circuit C) (p : \u03b1) :\n    (hC.singleDisjointCircuitFamily p).union = C := by\n  simp only [Matroid.Circuit.singleDisjointCircuitFamily, Matroid.DisjointCircuitFamily.union, Set.iUnion_coe_set,\n    Set.mem_singleton_iff, Set.iUnion_iUnion_eq_left]\n\nend DisjointCircuitFamily\n\n\nsection UnionDisjointCircuits\n\n/-- Set `C` can be represented as disjoint union of circuits of `M`. -/\ndef Matroid.IsUnionDisjointCircuits (M : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  \u2203 F : M.DisjointCircuitFamily, F.union = C\n\n/-- Empty set is disjoint union of circuits. -/\nlemma Matroid.emptyUnionDisjointCircuits (M : Matroid \u03b1) :\n    M.IsUnionDisjointCircuits \u2205 :=\n  \u27e8M.emptyDisjointCircuitFamily, M.emptyDisjointCircuitFamily_union\u27e9\n\n/-- If union of disjoint circuits is independent, then it is empty. -/\nlemma Matroid.IsUnionDisjointCircuits.indep_empty {M : Matroid \u03b1} {X : Set \u03b1}\n    (hMX : M.IsUnionDisjointCircuits X) (hMX' : M.Indep X) :\n    X = \u2205 :=\n  have \u27e8F, hXF\u27e9 := hMX\n  F.union_indep_empty (hXF \u25b8 hMX') \u25b8 hXF.symm\n\n/-- Nonempty union of disjoint circuits is dependent. -/\nlemma Matroid.IsUnionDisjointCircuits.nonempty_dep {M : Matroid \u03b1} {X : Set \u03b1}\n    (hMX : M.IsUnionDisjointCircuits X) (hX : X.Nonempty) :\n    M.Dep X :=\n  have \u27e8F, hXF\u27e9 := hMX\n  hXF \u25b8 F.union_nonempty_dep (hXF \u25b8 hX)\n\n", "theoremStatement": "/-- Union of disjoint circuits is either dependent or empty. -/\nlemma Matroid.IsUnionDisjointCircuits.dep_or_empty {M : Matroid \u03b1} {X : Set \u03b1} (hMX : M.IsUnionDisjointCircuits X) :\n    M.Dep X \u2228 X = \u2205 ", "theoremName": "Matroid.IsUnionDisjointCircuits.dep_or_empty", "fileCreated": {"commit": "67629d2b74be7b972786897531b678f585a7af28", "date": "2025-02-03"}, "theoremCreated": {"commit": "1a6d79dfb5649dbdf07194ae0bd21376f5682084", "date": "2025-01-07"}, "file": "Seymour/Seymour/Matroid/Notions/DisjointCircuitFamily.lean", "module": "Seymour.Matroid.Notions.DisjointCircuitFamily", "jsonFile": "Seymour.Matroid.Notions.DisjointCircuitFamily.jsonl", "positionMetadata": {"lineInFile": 116, "tokenPositionInFile": 4857, "theoremPositionInFile": 12}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 4, "numPremises": 13}, "proofMetadata": {"hasProof": true, "proof": ":=\n  have \u27e8F, hXF\u27e9 := hMX\n  hXF \u25b8 F.dep_or_empty", "proofType": "term", "proofLengthLines": 2, "proofLengthTokens": 48}}
{"srcContext": "import Mathlib.Order.RelClasses\nimport Mathlib.Data.Matroid.Basic\n\nimport Seymour.Basic\nimport Seymour.Matroid.Notions.IndepAxioms\n\n\n/-- Circuit predicate, defines which sets are circuits. -/\nabbrev CircuitPredicate (\u03b1 : Type) := Set \u03b1 \u2192 Prop\n\n\nvariable {\u03b1 : Type}\n\n\nsection ValidFamily\n\n/-- Family of circuits satisfying assumptions of circuit axiom (C3) from Bruhn et al. -/\nstructure ValidFamily (P : CircuitPredicate \u03b1) (X : Set \u03b1) where\n  F : X.Elem \u2192 Set \u03b1\n  hPF : \u2200 x : X.Elem, P (F x)\n  hF : \u2200 x y : X.Elem, x.val \u2208 F y \u2194 x = y -- `F y` may nevertheless contain multiple elements of `X\u1d9c`\n\n/-- Shorthand for union of sets in `ValidFamily` -/\nabbrev ValidFamily.union {P : CircuitPredicate \u03b1} {X : Set \u03b1} (F : ValidFamily P X) : Set \u03b1 :=\n  Set.iUnion F.F\n\n-- question: unused API?\n", "theoremStatement": "lemma ValidFamily.mem_of_elem {P : CircuitPredicate \u03b1} {X : Set \u03b1} (F : ValidFamily P X) (x : X.Elem) :\n    x.val \u2208 F.F x ", "theoremName": "ValidFamily.mem_of_elem", "fileCreated": {"commit": "ee35fddd27b04eb576eb64b8bb74af513408f6ef", "date": "2024-12-21"}, "theoremCreated": {"commit": "3937be9ff2724b131db903ab8cd973ac32bc21de", "date": "2025-01-14"}, "file": "Seymour/Seymour/Matroid/Notions/CircuitAxioms.lean", "module": "Seymour.Matroid.Notions.CircuitAxioms", "jsonFile": "Seymour.Matroid.Notions.CircuitAxioms.jsonl", "positionMetadata": {"lineInFile": 28, "tokenPositionInFile": 787, "theoremPositionInFile": 2}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 4, "numPremises": 15}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [F.hF]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 17}}
{"srcContext": "import Mathlib.Data.Matroid.Basic\nimport Seymour.Matroid.Notions.Circuit\n\n\nvariable {\u03b1 : Type}\n\n/-- Loop is an element of the ground set that is not independent when viewed as a singleton set. -/\ndef Matroid.Loop (M : Matroid \u03b1) (a : \u03b1) : Prop :=\n  a \u2208 M.E \u2227 M.Dep {a}\n\n", "theoremStatement": "/-- An element is a loop iff its singleton set is a circuit. -/\nlemma Matroid.loop_iff_circuit (M : Matroid \u03b1) {a : \u03b1} :\n    M.Loop a \u2194 M.Circuit {a} ", "theoremName": "Matroid.loop_iff_circuit", "fileCreated": {"commit": "b44bff2f1ee71349fa9fa251579a0f5a0e575538", "date": "2024-12-19"}, "theoremCreated": {"commit": "aa94b9eb8a1b85573a7b945cf5c5bf96cb4b388b", "date": "2025-01-16"}, "file": "Seymour/Seymour/Matroid/Notions/Loop.lean", "module": "Seymour.Matroid.Notions.Loop", "jsonFile": "Seymour.Matroid.Notions.Loop.jsonl", "positionMetadata": {"lineInFile": 11, "tokenPositionInFile": 270, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 3, "numPremises": 36}, "proofMetadata": {"hasProof": true, "proof": ":=\n  \u27e8\n    fun ha => \u27e8\n      ha.right,\n      fun _ hM hMa => (Set.subset_singleton_iff_eq.\u2192 hMa).casesOn\n        (\u00b7 \u25b8 hM |>.not_indep M.empty_indep |>.elim)\n        (\u00b7.symm.subset)\n      \u27e9,\n    fun ha => \u27e8ha.left.right rfl, ha.dep\u27e9\n  \u27e9", "proofType": "term", "proofLengthLines": 9, "proofLengthTokens": 235}}
{"srcContext": "import Mathlib.Data.Matroid.IndepAxioms\n\nimport Seymour.Basic\nimport Seymour.ForMathlib.SetTheory\n\n\n/-- Data describing a binary matroid on the ground set `X \u222a Y` where `X` and `Y` are bundled.\nNot in sync with `Matroid.Constructors.VectorMatroid/StandardRepr` currently! -/\nstructure StandardRepresentation (\u03b1 : Type) [DecidableEq \u03b1] where\n  /-- Basis elements \u2192 row indices of [`1 | B`] -/\n  X : Set \u03b1\n  /-- Non-basis elements \u2192 column indices of `B` -/\n  Y : Set \u03b1\n  /-- Necessary decidability -/\n  decmemX : \u2200 a, Decidable (a \u2208 X)\n  /-- Necessary decidability -/\n  decmemY : \u2200 a, Decidable (a \u2208 Y)\n  /-- Basis and nonbasis elements are disjoint -/\n  hXY : X \u2ad7 Y\n  /-- The standard representation matrix -/\n  B : Matrix X Y Z2\n\n-- Automatically infer decidability when `StandardRepresentation` is present.\nattribute [instance] StandardRepresentation.decmemX\nattribute [instance] StandardRepresentation.decmemY\n\nvariable {\u03b1 : Type} [DecidableEq \u03b1] {X Y : Set \u03b1} [\u2200 a, Decidable (a \u2208 X)] [\u2200 a, Decidable (a \u2208 Y)]\n\n/-- Given matrix `B`, whether the set of columns `S` in the (standard) representation [`1 | B`] `Z2`-independent. -/\ndef Matrix.IndepCols (B : Matrix X Y Z2) (S : Set \u03b1) : Prop :=\n  \u2203 hs : S \u2286 X \u222a Y, LinearIndependent Z2 ((Matrix.fromCols 1 B).submatrix id (Subtype.toSum \u2218 hs.elem)).transpose\n\n\n/-- The empty set of columns is linearly independent. -/\ntheorem Matrix.indepCols_empty {B : Matrix X Y Z2} : B.IndepCols \u2205 := by\n  use Set.empty_subset (X \u222a Y)\n  exact linearIndependent_empty_type\n\n", "theoremStatement": "/-- A subset of a linearly independent set of columns is linearly independent. -/\ntheorem Matrix.indepCols_subset {B : Matrix X Y Z2} (I J : Set \u03b1) (hBJ : B.IndepCols J) (hIJ : I \u2286 J) :\n    B.IndepCols I ", "theoremName": "Matrix.indepCols_subset", "fileCreated": {"commit": "614ecc7fe89749171933326a0f077e8d8a24cecb", "date": "2025-02-03"}, "theoremCreated": {"commit": "614ecc7fe89749171933326a0f077e8d8a24cecb", "date": "2025-02-03"}, "file": "Seymour/Seymour/Matroid/Operations/MatrixSums/BinaryMatroids.lean", "module": "Seymour.Matroid.Operations.MatrixSums.BinaryMatroids", "jsonFile": "Seymour.Matroid.Operations.MatrixSums.BinaryMatroids.jsonl", "positionMetadata": {"lineInFile": 39, "tokenPositionInFile": 1510, "theoremPositionInFile": 2}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 4, "numPremises": 66}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  obtain \u27e8hJ, hB\u27e9 := hBJ\n  use hIJ.trans hJ\n  show LinearIndependent Z2 (fun i x => Matrix.fromCols 1 B x ((hJ.elem (Subtype.map id hIJ i)).toSum))\n  apply hB.comp\n  intro _ _ hf\n  apply Subtype.eq\n  simpa [Subtype.map] using hf", "proofType": "tactic", "proofLengthLines": 7, "proofLengthTokens": 234}}
{"srcContext": "import Mathlib.Data.Matroid.Basic\nimport Seymour.Basic\n\n\n/-- Independence predicate, defines which sets are independent. -/\nabbrev IndepPredicate (\u03b1 : Type) := Set \u03b1 \u2192 Prop\n\n\nvariable {\u03b1 : Type}\n\n/-- Independence predicate of matroid. -/\ndef Matroid.IndepPredicate (M : Matroid \u03b1) : IndepPredicate \u03b1 := M.Indep\n-- TODO why does this definition exist?\n\n\nsection IndepAxioms\n\n/-- Axiom (I1): empty set is independent. -/\ndef IndepPredicate.IndepEmpty (P : IndepPredicate \u03b1) : Prop := P \u2205\nalias IndepPredicate.BruhnI1 := IndepPredicate.IndepEmpty\n\n/-- Axiom (I2): subset of independent set is independent. -/\ndef IndepPredicate.IndepSubset (P : IndepPredicate \u03b1) : Prop := \u2200 I J : Set \u03b1, P J \u2192 I \u2286 J \u2192 P I\nalias IndepPredicate.BruhnI2 := IndepPredicate.IndepSubset\n\n/-- Axiom (I3): augmentation property. -/\ndef IndepPredicate.IndepAug (P : IndepPredicate \u03b1) : Prop :=\n  \u2200 I B : Set \u03b1, P I \u2192 \u00acMaximal P I \u2192 Maximal P B \u2192 \u2203 x \u2208 B \\ I, P (x \u1543 I)\nalias IndepPredicate.BruhnI3 := IndepPredicate.IndepAug\n\n/-- Axiom (IM): set of all independent sets has the maximal subset property. -/\ndef IndepPredicate.IndepMaximal (P : IndepPredicate \u03b1) (E : Set \u03b1) : Prop :=\n  \u2200 X : Set \u03b1, X \u2286 E \u2192 Matroid.ExistsMaximalSubsetProperty P X\nalias IndepPredicate.BruhnIM := IndepPredicate.IndepMaximal\n\n/-- Every independent set is a subset of the ground set. -/\ndef IndepPredicate.SubsetGround (P : IndepPredicate \u03b1) (E : Set \u03b1) : Prop := \u2200 C : Set \u03b1, P C \u2192 C \u2286 E\nalias IndepPredicate.BruhnCE := IndepPredicate.SubsetGround\n\nend IndepAxioms\n\n\nsection MatroidIndepAxioms\n\n", "theoremStatement": "/-- Independence predicate of matroid satisfies (I1): empty set is independent. -/\nlemma Matroid.indepEmpty (M : Matroid \u03b1) :\n    M.IndepPredicate.IndepEmpty ", "theoremName": "Matroid.indepEmpty", "fileCreated": {"commit": "ee35fddd27b04eb576eb64b8bb74af513408f6ef", "date": "2024-12-21"}, "theoremCreated": {"commit": "43c746e51146ac13aa709eefe36b9f185633ea8b", "date": "2025-02-03"}, "file": "Seymour/Seymour/Matroid/Notions/IndepAxioms.lean", "module": "Seymour.Matroid.Notions.IndepAxioms", "jsonFile": "Seymour.Matroid.Notions.IndepAxioms.jsonl", "positionMetadata": {"lineInFile": 45, "tokenPositionInFile": 1548, "theoremPositionInFile": 7}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 4}, "proofMetadata": {"hasProof": true, "proof": ":=\n  M.empty_indep", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 18}}
{"srcContext": "import Mathlib.Data.Set.SymmDiff\nimport Mathlib.Order.CompletePartialOrder\nimport Mathlib.Order.Disjoint\nimport Mathlib.Order.SymmDiff\nimport Mathlib.Tactic\n\nimport Seymour.Basic\n\n/-!\nThis provides lemmas about sets (mostly dealing with disjointness) that are missing in Mathlib.\n-/\n\nvariable {\u03b1 : Type}\n\nsection Other\n\nlemma set_union_union_eq_rev (X Y Z : Set \u03b1) : X \u222a Y \u222a Z = Z \u222a Y \u222a X := by\n  rw [Set.union_assoc, Set.union_comm, Set.union_comm Y Z]\n\nlemma setminus_inter_union_eq_union {X Y : Set \u03b1} : X \\ (X \u2229 Y) \u222a Y = X \u222a Y := by\n  tauto_set\n\nlemma nonempty_inter_not_ssubset_empty_inter {A B E : Set \u03b1} (hA : (A \u2229 E).Nonempty) (hB : B \u2229 E = \u2205) :\n    \u00ac(A \u2282 B) := by\n  intro \u27e8hAB, _\u27e9\n  obtain \u27e8x, hxAE\u27e9 := hA\n  have hxBE : x \u2208 B \u2229 E := (Set.inter_subset_inter hAB fun _ => id) hxAE\n  rw [hB] at hxBE\n  tauto\n\nlemma ssubset_self_union_other_elem {a : \u03b1} {X : Set \u03b1} (ha : a \u2209 X) :\n    X \u2282 X \u222a {a} := by\n  constructor\n  \u00b7 exact Set.subset_union_left\n  \u00b7 by_contra hX\n    rw [Set.union_subset_iff] at hX\n    obtain \u27e8_, haa\u27e9 := hX\n    tauto\n\nlemma singleton_union_ssubset_union_iff {a : \u03b1} {A B : Set \u03b1} (haA : a \u2209 A) (haB : a \u2209 B) :\n    A \u222a {a} \u2282 B \u222a {a} \u2194 A \u2282 B := by\n  constructor\n  \u00b7 intro hAB\n    obtain \u27e8hABl, hABr\u27e9 := hAB\n    constructor\n    \u00b7 intro x hx\n      apply ne_of_mem_of_not_mem hx at haA\n      cases hABl (Set.mem_union_left {a} hx) <;> tauto\n    \u00b7 by_contra hBA\n      apply Set.union_subset_union_left {a} at hBA\n      tauto\n  \u00b7 intro hAB\n    obtain \u27e8hABl, hABr\u27e9 := hAB\n    constructor\n    \u00b7 exact Set.union_subset_union_left {a} hABl\n    \u00b7 by_contra hBA\n      rw [Set.union_singleton, Set.union_singleton] at hBA\n      apply (Set.insert_subset_insert_iff haB).\u2192 at hBA\n      tauto\n\nlemma ssub_parts_ssub {A B E\u2081 E\u2082 : Set \u03b1}\n    (hA : A \u2286 E\u2081 \u222a E\u2082) (hB : B \u2286 E\u2081 \u222a E\u2082) (hAB\u2081 : A \u2229 E\u2081 \u2282 B \u2229 E\u2081) (hAB\u2082 : A \u2229 E\u2082 \u2282 B \u2229 E\u2082) :\n    A \u2282 B := by\n  constructor\n  \u00b7 obtain \u27e8hE\u2081, _\u27e9 := hAB\u2081\n    obtain \u27e8hE\u2082, _\u27e9 := hAB\u2082\n    rw [Set.left_eq_inter.\u2190 hA, Set.left_eq_inter.\u2190 hB, Set.inter_union_distrib_left, Set.inter_union_distrib_left]\n    exact Set.union_subset_union hE\u2081 hE\u2082\n  \u00b7 intro hBA\n    obtain \u27e8_, hE\u2081\u27e9 := hAB\u2081\n    obtain \u27e8x, hxBE\u2081, hxnAE\u2081\u27e9 := Set.not_subset.\u2192 hE\u2081\n    have hxB : x \u2208 B := Set.mem_of_mem_inter_left hxBE\u2081\n    have hxE\u2081 : x \u2208 E\u2081 := Set.mem_of_mem_inter_right hxBE\u2081\n    tauto\n\nlemma HasSubset.Subset.parts_eq {A E\u2081 E\u2082 : Set \u03b1} (hA : A \u2286 E\u2081 \u222a E\u2082) : (A \u2229 E\u2081) \u222a (A \u2229 E\u2082) = A :=\n  ((subset_of_subset_of_eq\n    (Set.subset_inter (fun _ => id) hA)\n    (Set.inter_union_distrib_left A E\u2081 E\u2082)).antisymm\n  (Set.union_subset Set.inter_subset_left Set.inter_subset_left)).symm\n\nlemma elem_notin_set_minus_singleton (a : \u03b1) (X : Set \u03b1) : a \u2209 X \\ {a} := Set.not_mem_diff_of_mem rfl\n\n", "theoremStatement": "lemma sub_union_diff_sub_union {A B C : Set \u03b1} (hA : A \u2286 B \\ C) : A \u2286 B ", "theoremName": "sub_union_diff_sub_union", "fileCreated": {"commit": "b44bff2f1ee71349fa9fa251579a0f5a0e575538", "date": "2024-12-19"}, "theoremCreated": {"commit": "dfc0fd9206db9d5842f974860199dc7aff1fb0f5", "date": "2024-12-14"}, "file": "Seymour/Seymour/ForMathlib/SetTheory.lean", "module": "Seymour.ForMathlib.SetTheory", "jsonFile": "Seymour.ForMathlib.SetTheory.jsonl", "positionMetadata": {"lineInFile": 84, "tokenPositionInFile": 2697, "theoremPositionInFile": 8}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 8}, "proofMetadata": {"hasProof": true, "proof": ":=\n  fun _ hA' => Set.diff_subset (hA hA')", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 42}}
{"srcContext": "import Seymour.Matroid.Operations.SumDelta.Basic\nimport Seymour.ForMathlib.SetTheory\n\nset_option linter.unusedVariables false\n\nvariable {\u03b1 : Type} [DecidableEq \u03b1]\n\n\nsection Basic\n\n/-- Nonempty union of disjoint circuits of `M\u2081` satisfies circuit form of `M\u2081 \u0394 M\u2082`  -/\nlemma deltaSumCircuitForm_left {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : C.Nonempty) (hCE : C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)) (hCM\u2081 : M\u2081.toMatroid.IsUnionDisjointCircuits C) :\n    DeltaSumCircuitForm M\u2081 M\u2082 C :=\n  \u27e8hC, hCE, C, \u2205, by simp, hCM\u2081, M\u2082.toMatroid.emptyUnionDisjointCircuits\u27e9\n\n/-- Nonempty union of disjoint circuits of `M\u2082` satisfies circuit form of `M\u2081 \u0394 M\u2082`  -/\nlemma deltaSumCircuitForm_right {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : C.Nonempty) (hCE : C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)) (hCM\u2082 : M\u2082.toMatroid.IsUnionDisjointCircuits C) :\n    DeltaSumCircuitForm M\u2081 M\u2082 C :=\n  \u27e8hC, hCE, \u2205, C, by simp, M\u2081.toMatroid.emptyUnionDisjointCircuits, hCM\u2082\u27e9\n\nend Basic\n\n\nsection CircuitForm1\n\n/-- Form 1 of circuits in `M\u2081 \u0394 M\u2082`: circuits of `M\u2081` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef DeltaSumCircuitForm1 (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.toMatroid.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Circuit of form 1 is a circuit in `M\u2081` -/\nlemma DeltaSumCircuitForm1.circuit_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    M\u2081.toMatroid.Circuit C :=\n  hC.left\n\n/-- Circuit of form 1 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm1.disjoint_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of form 1 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma DeltaSumCircuitForm1.subset_union {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_left hC.circuit_M\u2081.subset_ground M\u2082.E\n\n/-- Circuit of form 1 lies in ground set of `M\u2081 \u0394 M\u2082` -/\nlemma DeltaSumCircuitForm1.subset_ground {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of form 1 lies in `M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma DeltaSumCircuitForm1.subset_M\u2081_diff_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2286 M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2081.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of form 1 is disjoint with `M\u2082.E` -/\nlemma DeltaSumCircuitForm1.disjoint_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2ad7 M\u2082.E := by\n  have hMM := diff_inter_disjoint_diff_inter M\u2081.E M\u2082.E\n  have hCM\u2082 := Set.disjoint_of_subset_left hC.subset_M\u2081_diff_inter hMM\n  have hCM\u2082 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2082, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_right] at hCM\u2082\n  exact hCM\u2082\n\n/-- Circuit of form 1 satisfies circuit form of `M\u2081 \u0394 M\u2082` -/\nlemma DeltaSumCircuitForm1.circuit_form {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    DeltaSumCircuitForm M\u2081 M\u2082 C :=\n  deltaSumCircuitForm_left hC.circuit_M\u2081.nonempty hC.subset_ground hC.circuit_M\u2081.isUnionDisjointCircuits\n\n/-- If `C` satisfies circuit predicate and is a union of disjoint circuits of `M\u2081`, then `C` is a circuit of `M\u2081` -/\nlemma DeltaSumCircuitPred.udc_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (C_pred : DeltaSumCircuitPred M\u2081 M\u2082 C) (C_udc : M\u2081.toMatroid.IsUnionDisjointCircuits C) :\n    M\u2081.toMatroid.Circuit C :=\n  have \u27e8\u27e8hC, hCE, _\u27e9, hCmin\u27e9 := C_pred\n  \u27e8C_udc.nonempty_dep hC, fun D hD hDC =>\n    have \u27e8_, D', hD', hDD'\u27e9 := M\u2081.toMatroid.dep_iff_has_circuit.\u2192 hD\n    (hCmin\n        (DeltaSumCircuitForm1.circuit_form \u27e8hD', (Set.subset_diff.\u2192 ((hDD'.trans hDC).trans hCE)).right\u27e9)\n        (hDD'.trans hDC)\n      ).trans hDD'\u27e9\n\nend CircuitForm1\n\n\nsection CircuitForm2\n\n/-- Form 2 of circuits in `M\u2081 \u0394 M\u2082`: circuits of `M\u2082` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef DeltaSumCircuitForm2 (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2082.toMatroid.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Circuit of form 2 is a circuit in `M\u2081` -/\nlemma DeltaSumCircuitForm2.circuit_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    M\u2082.toMatroid.Circuit C :=\n  hC.left\n\n/-- Circuit of form 2 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm2.disjoint_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of form 2 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma DeltaSumCircuitForm2.subset_union {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_right hC.circuit_M\u2082.subset_ground M\u2081.E\n\n/-- Circuit of form 2 lies in ground set of `M\u2081 \u0394 M\u2082` -/\nlemma DeltaSumCircuitForm2.subset_ground {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of form 2 lies in `M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma DeltaSumCircuitForm2.subset_M\u2082_diff_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2286 M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2082.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of form 2 is disjoint with `M\u2082.E` -/\nlemma DeltaSumCircuitForm2.disjoint_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2ad7 M\u2081.E := by\n  have hMM := diff_inter_disjoint_diff_inter M\u2081.E M\u2082.E\n  have hCM\u2082 := Set.disjoint_of_subset_right hC.subset_M\u2082_diff_inter hMM\n  have hCM\u2082 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2082.symm, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_left] at hCM\u2082\n  exact hCM\u2082\n\n/-- Circuit of form 2 satisfies circuit form of `M\u2081 \u0394 M\u2082` -/\nlemma DeltaSumCircuitForm2.circuit_form {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    DeltaSumCircuitForm M\u2081 M\u2082 C :=\n  deltaSumCircuitForm_right hC.circuit_M\u2082.nonempty hC.subset_ground hC.circuit_M\u2082.isUnionDisjointCircuits\n\n/-- If `C` satisfies circuit predicate and is a union of disjoint circuits of `M\u2082`, then `C` is a circuit of `M\u2082` -/\nlemma DeltaSumCircuitPred.udc_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hCpred : DeltaSumCircuitPred M\u2081 M\u2082 C) (hCudc : M\u2082.toMatroid.IsUnionDisjointCircuits C) :\n    M\u2082.toMatroid.Circuit C :=\n  have \u27e8\u27e8C_nempty, hCE, _\u27e9, hCmin\u27e9 := hCpred\n  \u27e8hCudc.nonempty_dep C_nempty, fun D hD hDC =>\n    have \u27e8_, D', hD', hDD'\u27e9 := M\u2082.toMatroid.dep_iff_has_circuit.\u2192 hD\n    (hCmin\n        (DeltaSumCircuitForm2.circuit_form \u27e8hD', (Set.subset_diff.\u2192 ((hDD'.trans hDC).trans hCE)).right\u27e9)\n        (hDD'.trans hDC)\n      ).trans hDD'\u27e9\n\nend CircuitForm2\n\n\nsection CircuitForm3\n\n/-- Form 3 of circuits in `M\u2081 \u0394 M\u2082`:\n    sets `C\u2081 \u0394 C\u2082` where `C\u2081` and `C\u2082` are circuits in `M\u2081` and `M\u2082`, respectively,\n    with `C\u2081 \u2229 (M\u2081.E \u2229 M\u2082.E)` and `C\u2082 \u2229 (M\u2081.E \u2229 M\u2082.E)` being the same one-element set.\n    Here we use equivalent definition by denoting `p` the single element in `C\u2081 \u2229 C\u2082` and\n    expressing `C\u2081` and `C\u2082` via `p`, `C`, and ground sets of `M\u2081` and `M\u2082`. -/\ndef DeltaSumCircuitForm3 (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C : Set \u03b1) (p : \u03b1) : Prop :=\n  M\u2081.toMatroid.Circuit ((C \u2229 M\u2081.E) \u222a {p}) \u2227\n  M\u2082.toMatroid.Circuit ((C \u2229 M\u2082.E) \u222a {p}) \u2227\n  C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)\n\n/-- Existential version of form 3 of circuits -/\ndef IsDeltaSumCircuitForm3 (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C : Set \u03b1) : Prop :=\n  \u2203 p \u2208 M\u2081.E \u2229 M\u2082.E, DeltaSumCircuitForm3 M\u2081 M\u2082 C p\n\nvariable {C : Set \u03b1} {p : \u03b1}\n\n/-- Circuit of form 3 yields a circuit in `M\u2081` after intersecting it with `M\u2081.E` and adding `p` -/\ndef DeltaSumCircuitForm3.to_circuit_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    M\u2081.toMatroid.Circuit ((C \u2229 M\u2081.E) \u222a {p}) :=\n  hC.left\n\n/-- Circuit of form 3 yields a circuit in `M\u2082` after intersecting it with `M\u2081.E` and adding `p` -/\ndef DeltaSumCircuitForm3.to_circuit_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    M\u2082.toMatroid.Circuit ((C \u2229 M\u2082.E) \u222a {p}) :=\n  hC.right.left\n\n/-- Circuit of form 3 is subset of ground set of `M\u2081 \u0394 M\u2082` -/\ndef DeltaSumCircuitForm3.subset_ground {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E) :=\n  hC.right.right\n\n/-- Singleton element in definition of circuit form 3 lies in `M\u2081.E` -/\nlemma DeltaSumCircuitForm3.singleton_subset_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    {p} \u2286 M\u2081.E :=\n  (Set.union_subset_iff.\u2192 hC.to_circuit_M\u2081.subset_ground).right\n\n/-- Singleton element in definition of circuit form 3 lies in `M\u2082.E` -/\nlemma DeltaSumCircuitForm3.singleton_subset_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    {p} \u2286 M\u2082.E :=\n  (Set.union_subset_iff.\u2192 hC.to_circuit_M\u2082.subset_ground).right\n\n/-- Singleton element in definition of circuit form 3 lies in `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm3.singleton_subset_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    {p} \u2286 M\u2081.E \u2229 M\u2082.E :=\n  Set.subset_inter hC.singleton_subset_M\u2081 hC.singleton_subset_M\u2082\n\n/-- Circuit of form 3 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma DeltaSumCircuitForm3.subset_union {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    C \u2286 M\u2081.E \u222a M\u2082.E :=\n  sub_union_diff_sub_union hC.subset_ground\n\n/-- Circuit of form 3 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm3.disjoint_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  Set.disjoint_of_subset_left hC.subset_ground Set.disjoint_sdiff_left\n\n/-- Circuit of form 3 intersected with `M\u2081.E` is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm3.disjoint_inter_M\u2081_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    C \u2229 M\u2081.E \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.disjoint_inter.inter_left M\u2081.E\n\n", "theoremStatement": "/-- Circuit of form 3 intersected with `M\u2081.E` is disjoint with `M\u2082.E` -/\nlemma DeltaSumCircuitForm3.disjoint_inter_M\u2081_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    C \u2229 M\u2081.E \u2ad7 M\u2082.E ", "theoremName": "DeltaSumCircuitForm3.disjoint_inter_M\u2081_M\u2082", "fileCreated": {"commit": "aae07a69b2ec95e3d9a1436952a123dcb7d0d06f", "date": "2025-01-03"}, "theoremCreated": {"commit": "67629d2b74be7b972786897531b678f585a7af28", "date": "2025-02-03"}, "file": "Seymour/Seymour/Matroid/Operations/SumDelta/CircuitForms.lean", "module": "Seymour.Matroid.Operations.SumDelta.CircuitForms", "jsonFile": "Seymour.Matroid.Operations.SumDelta.CircuitForms.jsonl", "positionMetadata": {"lineInFile": 232, "tokenPositionInFile": 9937, "theoremPositionInFile": 31}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 5, "numPremises": 37}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [Set.disjoint_iff_inter_eq_empty, Set.inter_assoc, \u2190Set.disjoint_iff_inter_eq_empty]\n  exact hC.disjoint_inter", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 121}}
{"srcContext": "import Mathlib.Data.Set.Card\nimport Mathlib.Data.Matroid.Dual\n\nimport Seymour.ForMathlib.SetTheory\nimport Seymour.Matroid.Notions.Circuit\nimport Seymour.Matroid.Notions.CircuitAxioms\nimport Seymour.Matroid.Notions.Connectivity\nimport Seymour.Matroid.Constructors.CircuitMatroid\n\n/-!\nThis file defines 2-sum of two (general) matroids `M\u2081` and `M\u2082`, denoted as `M\u2081 \u2295\u2082 M\u2082`.\n-/\n\nvariable {\u03b1 : Type}\n\n\nsection MainDefinitions\n\n/-- `M\u2081 \u2295\u2082 M\u2082` is defined if `M\u2081` and `M\u2082` satisfy the following assumptions -/\nstructure TwoSumAssumptions (M\u2081 M\u2082 : Matroid \u03b1) : Prop where\n  /-- `M\u2081` is finite -/\n  M\u2081fin : M\u2081.Finite\n  /-- `M\u2082` is finite -/\n  M\u2082fin : M\u2082.Finite\n  /-- `M\u2081` contains at least 2 elements -/\n  M\u2081card : M\u2081.E.encard \u2265 2\n  /-- `M\u2082` contains at least 2 elements -/\n  M\u2082card : M\u2082.E.encard \u2265 2\n  /-- `M\u2081` and `M\u2082` have exactly one element in common -/\n  interSingleton : (M\u2081.E \u2229 M\u2082.E).encard = 1\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2081` -/\n  M\u2081sep : \u00acM\u2081.Separator (M\u2081.E \u2229 M\u2082.E)\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2082` -/\n  M\u2082sep : \u00acM\u2082.Separator (M\u2081.E \u2229 M\u2082.E)\n\n-- question: can avoid this assumption? -- which assumption? the finiteness?\n\n/-- Ground set of `M\u2081 \u2295\u2082 M\u2082` -/\ndef twoSumGround (M\u2081 M\u2082 : Matroid \u03b1) : Set \u03b1 :=\n  (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)\n\n/-- Type 1 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2081` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType1 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 2 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2082` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType2 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2082.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 3 of circuits in `M\u2081 \u2295\u2082 M\u2082`:\n    sets `(C\u2081 \u222a C\u2082) \\ (M\u2081.E \u2229 M\u2082.E)` where `C\u2081` and `C\u2082` are circuits in `M\u2081` and `M\u2082`, respectively,\n    and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2081` and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2082` -/\ndef TwoSumCircuitType3 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit ((C \u2229 M\u2081.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 M\u2082.Circuit ((C \u2229 M\u2082.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 C \u2286 twoSumGround M\u2081 M\u2082\n\n/-- Circuit predicate of `M\u2081 \u2295\u2082 M\u2082`, which defines 2-sum as `CircuitMatroid` -/\ndef TwoSumCircuitPred (M\u2081 M\u2082 : Matroid \u03b1) : CircuitPredicate \u03b1 :=\n  fun C : Set \u03b1 =>\n    TwoSumCircuitType1 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType2 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType3 M\u2081 M\u2082 C\n\nend MainDefinitions\n\n\nsection PropertiesAssumptions\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1}\n\n/-- 2-sum assumptions are symmetric -/\nlemma TwoSumAssumptions.symm (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    TwoSumAssumptions M\u2082 M\u2081 :=\n  \u27e8\n    assumptions.M\u2082fin,\n    assumptions.M\u2081fin,\n    assumptions.M\u2082card,\n    assumptions.M\u2081card,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.interSingleton,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2082sep,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2081sep,\n  \u27e9\n\n/-- Intersection of ground sets is nonempty -/\nlemma TwoSumAssumptions.inter_nonempty (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (M\u2081.E \u2229 M\u2082.E).Nonempty :=\n  Set.one_le_encard_iff_nonempty.\u2192 assumptions.interSingleton.symm.le\n\n/-- Intersection of ground sets is a singleton set -/\nlemma TwoSumAssumptions.inter_singleton (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    \u2203 p : \u03b1, M\u2081.E \u2229 M\u2082.E = {p} :=\n  Set.encard_eq_one.\u2192 assumptions.interSingleton\n\nvariable {p : \u03b1}\n\n/-- Singleton element in intersection of ground sets in not a loop in `M\u2081` -/\nlemma TwoSumAssumptions.inter_singleton_not_loop_M\u2081 (assumptions : TwoSumAssumptions M\u2081 M\u2082)\n    (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2081.Loop p) :=\n  (hp \u25b8 assumptions.M\u2081sep <| Matroid.separator_loop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a coloop in `M\u2081` -/\nlemma TwoSumAssumptions.inter_singleton_not_coloop_M\u2081 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2081.Coloop p) :=\n  (hp \u25b8 assumptions.M\u2081sep <| Matroid.separator_coloop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a loop in `M\u2082` -/\nlemma TwoSumAssumptions.inter_singleton_not_loop_M\u2082 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2082.Loop p) :=\n  (hp \u25b8 assumptions.M\u2082sep <| Matroid.separator_loop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a coloop in `M\u2082` -/\nlemma TwoSumAssumptions.inter_singleton_not_coloop_M\u2082 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2082.Coloop p) :=\n  (hp \u25b8 assumptions.M\u2082sep <| Matroid.separator_coloop \u00b7)\n\nend PropertiesAssumptions\n\n\nsection PropertiesGroundSet\n\n/-- Ground set of 2-sum is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma twoSumGround_disjoint_inter (M\u2081 M\u2082 : Matroid \u03b1) :\n    twoSumGround M\u2081 M\u2082 \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  Set.disjoint_sdiff_left\n\n/-- Ground sets minus their intersection are disjoint sets -/\nlemma twoSum_disjoint_grounds_diff_inter (M\u2081 M\u2082 : Matroid \u03b1) :\n    M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) \u2ad7 M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E) := by\n  rw [Set.diff_self_inter, Set.diff_inter_self_eq_diff]\n  exact disjoint_sdiff_sdiff\n\nend PropertiesGroundSet\n\n\nsection PropertiesCircuitType1\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1} {C : Set \u03b1}\n\n/-- Circuit of type 1 is a circuit in `M\u2081` -/\nlemma TwoSumCircuitType1.circuit_M\u2081 (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : M\u2081.Circuit C :=\n  hC.left\n\n/-- Circuit of type 1 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType1.disjoint_inter (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of type 1 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma TwoSumCircuitType1.subset_union (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_left hC.circuit_M\u2081.subset_ground M\u2082.E\n\n/-- Circuit of type 1 lies in ground set of `M\u2081 \u2295\u2082 M\u2082` -/\nlemma TwoSumCircuitType1.subset_ground (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 twoSumGround M\u2081 M\u2082 :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 1 lies in `M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma TwoSumCircuitType1.subset_M\u2081_diff_inter (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2081.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 1 is disjoint with `M\u2082.E` -/\nlemma TwoSumCircuitType1.disjoint_M\u2082 (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2ad7 M\u2082.E := by\n  have hMM := twoSum_disjoint_grounds_diff_inter M\u2081 M\u2082\n  have hCM\u2082 := Set.disjoint_of_subset_left hC.subset_M\u2081_diff_inter hMM\n  have hCM\u2082 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2082, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_right] at hCM\u2082\n  exact hCM\u2082\n\nend PropertiesCircuitType1\n\n\nsection PropertiesCircuitType2\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1} {C : Set \u03b1}\n\n/-- Circuit of type 2 is a circuit in `M\u2082` -/\nlemma TwoSumCircuitType2.circuit_M\u2082 (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : M\u2082.Circuit C :=\n  hC.left\n\n/-- Circuit of type 2 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType2.disjoint_inter (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of type 2 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma TwoSumCircuitType2.subset_union (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_right hC.circuit_M\u2082.subset_ground M\u2081.E\n\n/-- Circuit of type 2 lies in ground set of `M\u2081 \u2295\u2082 M\u2082` -/\nlemma TwoSumCircuitType2.subset_ground (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2286 twoSumGround M\u2081 M\u2082 :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n", "theoremStatement": "/-- Circuit of type 2 lies in `M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma TwoSumCircuitType2.subset_M\u2082_diff_inter (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2286 M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E) ", "theoremName": "TwoSumCircuitType2.subset_M\u2082_diff_inter", "fileCreated": {"commit": "d0eaaa305c96cd81ac061f505a81614db6856b21", "date": "2025-01-09"}, "theoremCreated": {"commit": "439c72996f29168161b974bc602629cac773728f", "date": "2025-01-08"}, "file": "Seymour/Seymour/Matroid/Operations/Sum2/Basic.lean", "module": "Seymour.Matroid.Operations.Sum2.Basic", "jsonFile": "Seymour.Matroid.Operations.Sum2.Basic.jsonl", "positionMetadata": {"lineInFile": 190, "tokenPositionInFile": 7206, "theoremPositionInFile": 24}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 4, "numPremises": 27}, "proofMetadata": {"hasProof": true, "proof": ":=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2082.subset_ground, hC.disjoint_inter\u27e9", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 71}}
{"srcContext": "import Mathlib.Data.Set.SymmDiff\nimport Mathlib.Order.CompletePartialOrder\nimport Mathlib.Order.Disjoint\nimport Mathlib.Order.SymmDiff\nimport Mathlib.Tactic\n\nimport Seymour.Basic\n\n/-!\nThis provides lemmas about sets (mostly dealing with disjointness) that are missing in Mathlib.\n-/\n\nvariable {\u03b1 : Type}\n\nsection Other\n\nlemma set_union_union_eq_rev (X Y Z : Set \u03b1) : X \u222a Y \u222a Z = Z \u222a Y \u222a X := by\n  rw [Set.union_assoc, Set.union_comm, Set.union_comm Y Z]\n\nlemma setminus_inter_union_eq_union {X Y : Set \u03b1} : X \\ (X \u2229 Y) \u222a Y = X \u222a Y := by\n  tauto_set\n\nlemma nonempty_inter_not_ssubset_empty_inter {A B E : Set \u03b1} (hA : (A \u2229 E).Nonempty) (hB : B \u2229 E = \u2205) :\n    \u00ac(A \u2282 B) := by\n  intro \u27e8hAB, _\u27e9\n  obtain \u27e8x, hxAE\u27e9 := hA\n  have hxBE : x \u2208 B \u2229 E := (Set.inter_subset_inter hAB fun _ => id) hxAE\n  rw [hB] at hxBE\n  tauto\n\nlemma ssubset_self_union_other_elem {a : \u03b1} {X : Set \u03b1} (ha : a \u2209 X) :\n    X \u2282 X \u222a {a} := by\n  constructor\n  \u00b7 exact Set.subset_union_left\n  \u00b7 by_contra hX\n    rw [Set.union_subset_iff] at hX\n    obtain \u27e8_, haa\u27e9 := hX\n    tauto\n\nlemma singleton_union_ssubset_union_iff {a : \u03b1} {A B : Set \u03b1} (haA : a \u2209 A) (haB : a \u2209 B) :\n    A \u222a {a} \u2282 B \u222a {a} \u2194 A \u2282 B := by\n  constructor\n  \u00b7 intro hAB\n    obtain \u27e8hABl, hABr\u27e9 := hAB\n    constructor\n    \u00b7 intro x hx\n      apply ne_of_mem_of_not_mem hx at haA\n      cases hABl (Set.mem_union_left {a} hx) <;> tauto\n    \u00b7 by_contra hBA\n      apply Set.union_subset_union_left {a} at hBA\n      tauto\n  \u00b7 intro hAB\n    obtain \u27e8hABl, hABr\u27e9 := hAB\n    constructor\n    \u00b7 exact Set.union_subset_union_left {a} hABl\n    \u00b7 by_contra hBA\n      rw [Set.union_singleton, Set.union_singleton] at hBA\n      apply (Set.insert_subset_insert_iff haB).\u2192 at hBA\n      tauto\n\nlemma ssub_parts_ssub {A B E\u2081 E\u2082 : Set \u03b1}\n    (hA : A \u2286 E\u2081 \u222a E\u2082) (hB : B \u2286 E\u2081 \u222a E\u2082) (hAB\u2081 : A \u2229 E\u2081 \u2282 B \u2229 E\u2081) (hAB\u2082 : A \u2229 E\u2082 \u2282 B \u2229 E\u2082) :\n    A \u2282 B := by\n  constructor\n  \u00b7 obtain \u27e8hE\u2081, _\u27e9 := hAB\u2081\n    obtain \u27e8hE\u2082, _\u27e9 := hAB\u2082\n    rw [Set.left_eq_inter.\u2190 hA, Set.left_eq_inter.\u2190 hB, Set.inter_union_distrib_left, Set.inter_union_distrib_left]\n    exact Set.union_subset_union hE\u2081 hE\u2082\n  \u00b7 intro hBA\n    obtain \u27e8_, hE\u2081\u27e9 := hAB\u2081\n    obtain \u27e8x, hxBE\u2081, hxnAE\u2081\u27e9 := Set.not_subset.\u2192 hE\u2081\n    have hxB : x \u2208 B := Set.mem_of_mem_inter_left hxBE\u2081\n    have hxE\u2081 : x \u2208 E\u2081 := Set.mem_of_mem_inter_right hxBE\u2081\n    tauto\n\nlemma HasSubset.Subset.parts_eq {A E\u2081 E\u2082 : Set \u03b1} (hA : A \u2286 E\u2081 \u222a E\u2082) : (A \u2229 E\u2081) \u222a (A \u2229 E\u2082) = A :=\n  ((subset_of_subset_of_eq\n    (Set.subset_inter (fun _ => id) hA)\n    (Set.inter_union_distrib_left A E\u2081 E\u2082)).antisymm\n  (Set.union_subset Set.inter_subset_left Set.inter_subset_left)).symm\n\nlemma elem_notin_set_minus_singleton (a : \u03b1) (X : Set \u03b1) : a \u2209 X \\ {a} := Set.not_mem_diff_of_mem rfl\n\nlemma sub_union_diff_sub_union {A B C : Set \u03b1} (hA : A \u2286 B \\ C) : A \u2286 B :=\n  fun _ hA' => Set.diff_subset (hA hA')\n\nlemma singleton_inter_in_left {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : a \u2208 X :=\n  Set.mem_of_mem_inter_left (ha.symm.subset rfl)\n\nlemma singleton_inter_in_right {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : a \u2208 Y :=\n  Set.mem_of_mem_inter_right (ha.symm.subset rfl)\n\nlemma singleton_inter_subset_left {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : {a} \u2286 X := by\n  rw [Set.singleton_subset_iff]\n  exact singleton_inter_in_left ha\n\nlemma singleton_inter_subset_right {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : {a} \u2286 Y := by\n  rw [Set.singleton_subset_iff]\n  exact singleton_inter_in_right ha\n\n/-- Being a subset is preserved under subtracting sets. -/\nlemma diff_subset_parent {X\u2081 X\u2082 E : Set \u03b1} (hX\u2081E : X\u2081 \u2286 E) :\n    X\u2081 \\ X\u2082 \u2286 E :=\n  Set.diff_subset_iff.\u2190 (Set.subset_union_of_subset_right hX\u2081E X\u2082)\n\n/-- Being a subset is preserved under taking intersections. -/\nlemma inter_subset_parent_left {X\u2081 X\u2082 E : Set \u03b1} (hX\u2081E : X\u2081 \u2286 E) :\n    X\u2081 \u2229 X\u2082 \u2286 E :=\n  (Set.inter_subset_inter_left X\u2082 hX\u2081E).trans Set.inter_subset_left\n\n/-- Being a subset is preserved under taking intersections. -/\nlemma inter_subset_parent_right {X\u2081 X\u2082 E : Set \u03b1} (hX\u2082E : X\u2082 \u2286 E) :\n    X\u2081 \u2229 X\u2082 \u2286 E := by\n  rw [Set.inter_comm]\n  exact inter_subset_parent_left hX\u2082E\n\n/-- Intersection of two sets is subset of their union. -/\nlemma inter_subset_union {X\u2081 X\u2082 : Set \u03b1} :\n    X\u2081 \u2229 X\u2082 \u2286 X\u2081 \u222a X\u2082 :=\n  inter_subset_parent_left Set.subset_union_left\n\nlemma subset_diff_empty_eq {A B : Set \u03b1} (hAB : A \u2286 B) (hBA : B \\ A = \u2205) : A = B :=\n  A.union_empty \u25b8 hBA \u25b8 Set.union_diff_cancel hAB\n\nend Other\n\n\nsection Disjoint\n\nlemma Disjoint.ni_of_in {X Y : Set \u03b1} {a : \u03b1} (hXY : X \u2ad7 Y) (ha : a \u2208 X) :\n    a \u2209 Y := by\n  intro ha'\n  simpa [hXY.inter_eq] using Set.mem_inter ha ha'\n\n", "theoremStatement": "lemma disjoint_of_singleton_inter_left_wo {X Y : Set \u03b1} {a : \u03b1} (hXY : X \u2229 Y = {a}) :\n    X \\ {a} \u2ad7 Y ", "theoremName": "disjoint_of_singleton_inter_left_wo", "fileCreated": {"commit": "b44bff2f1ee71349fa9fa251579a0f5a0e575538", "date": "2024-12-19"}, "theoremCreated": {"commit": "f9d717ecfb54b3a7b794411b4c1af1f5c8ffb7c3", "date": "2024-12-26"}, "file": "Seymour/Seymour/ForMathlib/SetTheory.lean", "module": "Seymour.ForMathlib.SetTheory", "jsonFile": "Seymour.ForMathlib.SetTheory.jsonl", "positionMetadata": {"lineInFile": 135, "tokenPositionInFile": 4533, "theoremPositionInFile": 19}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 59}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  tauto_set", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 17}}
{"srcContext": "import Seymour.Matroid.Notions.Circuit\nimport Seymour.Matroid.Notions.Loop\nimport Seymour.Matroid.Notions.Coloop\n\n\nvariable {\u03b1 : Type}\n\nsection SimpleConnectivity\n\n/-- The connectivity relation, aka \u03be in Oxley's book -/\ndef Matroid.ConnectivityRelation (M : Matroid \u03b1) (e f : \u03b1) : Prop :=\n  e = f \u2228 \u2203 C : Set \u03b1, C \u2286 M.E \u2227 M.Circuit C \u2227 e \u2208 C \u2227 f \u2208 C\n\n/-- The connectivity relation is reflexive -/\n@[refl]\nlemma Matroid.ConnectivityRelation.refl (M : Matroid \u03b1) {e : \u03b1} :\n    M.ConnectivityRelation e e :=\n  Or.inl rfl\n\n/-- The connectivity relation is symmetric -/\n@[symm]\nlemma Matroid.ConnectivityRelation.symm (M : Matroid \u03b1) {e f : \u03b1} :\n    M.ConnectivityRelation e f \u2192 M.ConnectivityRelation f e := by\n  intro hef\n  cases hef with\n  | inl hef => exact Or.inl hef.symm\n  | inr hef =>\n    right\n    obtain \u27e8C, _, _, _, _\u27e9 := hef\n    use C\n\n/-- The connectivity relation is transitive -/\n@[trans]\nlemma Matroid.ConnectivityRelation.trans (M : Matroid \u03b1) {e f g : \u03b1} :\n    M.ConnectivityRelation e f \u2192 M.ConnectivityRelation f g \u2192 M.ConnectivityRelation e g := by\n  intro hef hfg\n  cases hef with\n  | inl hef => exact hef \u25b8 hfg\n  | inr hef =>\n    cases hfg with\n    | inl hfg => exact Or.inr (hfg \u25b8 hef)\n    | inr hfg =>\n      obtain \u27e8C\u2081, hC\u2081, hMC\u2081, heC\u2081, hfC\u2081\u27e9 := hef\n      obtain \u27e8C\u2082, hC\u2082, hMC\u2082, hfC\u2082, hgC\u2082\u27e9 := hfg\n      right\n      -- todo: see proof of Lemma 7 in Bruhn Wollman 2011 (page 5)\n      -- note: that proof uses matroid contraction\n      sorry\n\n/-- A component is an equivalence class under the connectivity relation, i.e., a \u03be-equivalence class -/\ndef Matroid.Component (M : Matroid \u03b1) (X : Set \u03b1) : Prop :=\n  \u2200 e \u2208 X, \u2200 f \u2208 M.E, M.ConnectivityRelation e f \u2194 f \u2208 X\n\n/-- A separator is a union of components -/\ndef Matroid.Separator (M : Matroid \u03b1) (X : Set \u03b1) : Prop :=\n  \u2200 e \u2208 X, \u2200 f \u2208 M.E, M.ConnectivityRelation e f \u2192 f \u2208 X\n\n/-- Every component is a separator -/\nlemma Matroid.separator_component (M : Matroid \u03b1) {X : Set \u03b1} (hX : M.Component X) :\n    M.Separator X :=\n  fun e he f hf hef => (hX e he f hf).\u2192 hef\n\n/-- Every loop is a separator -/\nlemma Matroid.separator_loop {M : Matroid \u03b1} {x : \u03b1} (hx : M.Loop x) :\n    M.Separator {x} := by\n  intro e hex f hfE hf\n  cases hf with\n  | inl hef => exact Set.mem_of_eq_of_mem hef.symm hex\n  | inr hfC =>\n    obtain \u27e8C, hCE, circC, heC, hfC\u27e9 := hfC\n    rw [hex, \u2190Set.singleton_subset_iff] at heC\n    rw [Matroid.loop_iff_circuit] at hx\n    apply Matroid.Circuit.not_ssubset_circuit hx at circC\n    rw [Set.ssubset_def] at circC\n    push_neg at circC\n    exact circC heC hfC\n\n/-- Every coloop is a separator -/\nlemma Matroid.separator_coloop {M : Matroid \u03b1} {x : \u03b1} (hx : M.Coloop x) :\n    M.Separator {x} := by\n  intro e hex f hfE hf\n  cases hf with\n  | inl hef => exact Set.mem_of_eq_of_mem hef.symm hex\n  | inr hfC =>\n    rw [Matroid.coloop_iff_in_no_circuit] at hx\n    obtain \u27e8_hxE, hxC\u27e9 := hx\n    obtain \u27e8C, _hCE, hCcirc, heC, hfC\u27e9 := hfC\n    rw [hex, \u2190Set.singleton_subset_iff] at heC\n    specialize hxC C hCcirc\n    tauto\n\n/-- Every singleton separator is a loop or a coloop -/\nlemma Matroid.singleton_separator_loop_coloop {M : Matroid \u03b1} {x : \u03b1} (hx : x \u2208 M.E) :\n    M.Separator {x} \u2192 M.Loop x \u2228 M.Coloop x := by\n  intro sep_x\n  by_contra! contr\n  obtain \u27e8notLoop, notColoop\u27e9 := contr\n  rw [Matroid.loop_iff_circuit] at notLoop\n  rw [Matroid.coloop_iff_in_no_circuit] at notColoop\n  push_neg at notColoop\n  specialize notColoop hx\n  obtain \u27e8C, hC, hxC\u27e9 := notColoop\n  obtain \u27e8f, hfC, hfx\u27e9 : \u2203 f \u2208 C, f \u2260 x\n  \u00b7 by_contra! hf\n    have hCx : \u2200 f \u2208 C, f \u2208 ({x} : Set \u03b1)\n    \u00b7 by_contra! hg\n      obtain \u27e8f', hf'\u27e9 := hg\n      exact (hf f' hf'.left \u25b8 hf'.right) rfl\n    have x_sub_C : {x} \u2286 C := Set.singleton_subset_iff.\u2190 hxC\n    have hCeqx : {x} = C := x_sub_C.antisymm hf\n    rw [hCeqx] at notLoop\n    exact notLoop hC\n  have hCE := hC.subset_ground\n  exact hfx (sep_x x rfl f (hCE hfC) (Or.inr \u27e8C, hCE, hC, hxC, hfC\u27e9))\n\n", "theoremStatement": "/-- Singleton element is a separator iff it is a loop or a coloop -/\nlemma Matroid.singleton_separator_iff {M : Matroid \u03b1} (x : \u03b1) :\n    x \u2208 M.E \u2227 M.Separator {x} \u2194 M.Loop x \u2228 M.Coloop x ", "theoremName": "Matroid.singleton_separator_iff", "fileCreated": {"commit": "b44bff2f1ee71349fa9fa251579a0f5a0e575538", "date": "2024-12-19"}, "theoremCreated": {"commit": "f9d717ecfb54b3a7b794411b4c1af1f5c8ffb7c3", "date": "2024-12-26"}, "file": "Seymour/Seymour/Matroid/Notions/Connectivity.lean", "module": "Seymour.Matroid.Notions.Connectivity", "jsonFile": "Seymour.Matroid.Notions.Connectivity.jsonl", "positionMetadata": {"lineInFile": 116, "tokenPositionInFile": 3894, "theoremPositionInFile": 10}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 6, "numPremises": 27}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  constructor\n  \u00b7 intro hxE\n    exact M.singleton_separator_loop_coloop hxE.left hxE.right\n  \u00b7 intro hxx\n    cases hxx with\n    | inl xLoop => exact \u27e8xLoop.left, Matroid.separator_loop xLoop\u27e9\n    | inr xColoop => exact \u27e8xColoop.left, Matroid.separator_coloop xColoop\u27e9", "proofType": "tactic", "proofLengthLines": 7, "proofLengthTokens": 273}}
{"srcContext": "import Mathlib.Data.Matroid.Basic\nimport Seymour.Basic\n\n\n/-- Independence predicate, defines which sets are independent. -/\nabbrev IndepPredicate (\u03b1 : Type) := Set \u03b1 \u2192 Prop\n\n\nvariable {\u03b1 : Type}\n\n/-- Independence predicate of matroid. -/\ndef Matroid.IndepPredicate (M : Matroid \u03b1) : IndepPredicate \u03b1 := M.Indep\n-- TODO why does this definition exist?\n\n\nsection IndepAxioms\n\n/-- Axiom (I1): empty set is independent. -/\ndef IndepPredicate.IndepEmpty (P : IndepPredicate \u03b1) : Prop := P \u2205\nalias IndepPredicate.BruhnI1 := IndepPredicate.IndepEmpty\n\n/-- Axiom (I2): subset of independent set is independent. -/\ndef IndepPredicate.IndepSubset (P : IndepPredicate \u03b1) : Prop := \u2200 I J : Set \u03b1, P J \u2192 I \u2286 J \u2192 P I\nalias IndepPredicate.BruhnI2 := IndepPredicate.IndepSubset\n\n/-- Axiom (I3): augmentation property. -/\ndef IndepPredicate.IndepAug (P : IndepPredicate \u03b1) : Prop :=\n  \u2200 I B : Set \u03b1, P I \u2192 \u00acMaximal P I \u2192 Maximal P B \u2192 \u2203 x \u2208 B \\ I, P (x \u1543 I)\nalias IndepPredicate.BruhnI3 := IndepPredicate.IndepAug\n\n/-- Axiom (IM): set of all independent sets has the maximal subset property. -/\ndef IndepPredicate.IndepMaximal (P : IndepPredicate \u03b1) (E : Set \u03b1) : Prop :=\n  \u2200 X : Set \u03b1, X \u2286 E \u2192 Matroid.ExistsMaximalSubsetProperty P X\nalias IndepPredicate.BruhnIM := IndepPredicate.IndepMaximal\n\n/-- Every independent set is a subset of the ground set. -/\ndef IndepPredicate.SubsetGround (P : IndepPredicate \u03b1) (E : Set \u03b1) : Prop := \u2200 C : Set \u03b1, P C \u2192 C \u2286 E\nalias IndepPredicate.BruhnCE := IndepPredicate.SubsetGround\n\nend IndepAxioms\n\n\nsection MatroidIndepAxioms\n\n/-- Independence predicate of matroid satisfies (I1): empty set is independent. -/\nlemma Matroid.indepEmpty (M : Matroid \u03b1) :\n    M.IndepPredicate.IndepEmpty :=\n  M.empty_indep\n\n/-- Independence predicate of matroid satisfies (I2): subset of independent set is independent. -/\nlemma Matroid.indepSubset (M : Matroid \u03b1) :\n    M.IndepPredicate.IndepSubset :=\n  fun _ _ => Matroid.Indep.subset\n\n/-- Independence predicate of matroid satisfies (I3): augmentation property. -/\nlemma Matroid.indepAug (M : Matroid \u03b1) :\n    M.IndepPredicate.IndepAug :=\n  fun _ _ hI nonmaximal_M_I maximal_M_I' => Indep.exists_insert_of_not_maximal M hI nonmaximal_M_I maximal_M_I'\n\n", "theoremStatement": "/-- (Alternative proof.) Independence predicate of matroid satisfies (I3): augmentation property. -/\nlemma Matroid.indepAug' (M : Matroid \u03b1) :\n    M.IndepPredicate.IndepAug ", "theoremName": "Matroid.indepAug'", "fileCreated": {"commit": "ee35fddd27b04eb576eb64b8bb74af513408f6ef", "date": "2024-12-21"}, "theoremCreated": {"commit": "43c746e51146ac13aa709eefe36b9f185633ea8b", "date": "2025-02-03"}, "file": "Seymour/Seymour/Matroid/Notions/IndepAxioms.lean", "module": "Seymour.Matroid.Notions.IndepAxioms", "jsonFile": "Seymour.Matroid.Notions.IndepAxioms.jsonl", "positionMetadata": {"lineInFile": 60, "tokenPositionInFile": 2207, "theoremPositionInFile": 10}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 62}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  -- Follows part of proof from Theorem 4.1 (i) from Bruhn et al.\n  intro I I' hI nonmaximal_M_I maximal_M_I'\n  have \u27e8B, hIB, maximal_B\u27e9 := M.maximality M.E Set.Subset.rfl I hI (Matroid.Indep.subset_ground hI)\n  if hBI : (B \\ I).Nonempty then\n    obtain \u27e8x, hx\u27e9 := hBI\n    if hxI' : x \u2208 I' then\n      exact \u27e8x,\n        Set.mem_diff_of_mem hxI' (Set.not_mem_of_mem_diff hx),\n        Matroid.Indep.subset maximal_B.left.left (Set.insert_subset (Set.mem_of_mem_diff hx) hIB),\n      \u27e9\n    else\n      have hB : Maximal M.Indep B :=\n        \u27e8maximal_B.left.left, fun C hC hBC => maximal_B.right \u27e8hC, Matroid.Indep.subset_ground hC\u27e9 hBC\u27e9\n      unfold Matroid.IndepPredicate at maximal_M_I'\n      rw [\u2190Matroid.base_iff_maximal_indep] at maximal_M_I' hB\n      obtain \u27e8y, hy, hMyBx\u27e9 := M.base_exchange B I' hB maximal_M_I' x (Set.mem_diff_of_mem (Set.mem_of_mem_diff hx) hxI')\n      exact \u27e8y,\n        Set.mem_diff_of_mem (Set.mem_of_mem_diff hy) (fun a => (Set.not_mem_of_mem_diff hy) (hIB a)),\n        Matroid.Indep.subset (Matroid.Base.indep hMyBx)\n          (Set.insert_subset_insert (Set.subset_diff_singleton hIB (Set.not_mem_of_mem_diff hx))),\n      \u27e9\n  else\n    have I_eq_B : I = B := Set.union_empty I \u25b8 (Set.not_nonempty_iff_eq_empty.\u2192 hBI) \u25b8 Set.union_diff_cancel hIB\n    have maximal_B : Maximal M.Indep B :=\n      \u27e8maximal_B.left.left, fun _ hC hBC => maximal_B.right \u27e8hC, Matroid.Indep.subset_ground hC\u27e9 hBC\u27e9\n    exact (nonmaximal_M_I (I_eq_B \u25b8 maximal_B)).elim", "proofType": "tactic", "proofLengthLines": 26, "proofLengthTokens": 1470}}
{"srcContext": "import Mathlib.Order.RelClasses\nimport Mathlib.Data.Matroid.Basic\n\nimport Seymour.Basic\nimport Seymour.Matroid.Notions.IndepAxioms\n\n\n/-- Circuit predicate, defines which sets are circuits. -/\nabbrev CircuitPredicate (\u03b1 : Type) := Set \u03b1 \u2192 Prop\n\n\nvariable {\u03b1 : Type}\n\n\nsection ValidFamily\n\n/-- Family of circuits satisfying assumptions of circuit axiom (C3) from Bruhn et al. -/\nstructure ValidFamily (P : CircuitPredicate \u03b1) (X : Set \u03b1) where\n  F : X.Elem \u2192 Set \u03b1\n  hPF : \u2200 x : X.Elem, P (F x)\n  hF : \u2200 x y : X.Elem, x.val \u2208 F y \u2194 x = y -- `F y` may nevertheless contain multiple elements of `X\u1d9c`\n\n/-- Shorthand for union of sets in `ValidFamily` -/\nabbrev ValidFamily.union {P : CircuitPredicate \u03b1} {X : Set \u03b1} (F : ValidFamily P X) : Set \u03b1 :=\n  Set.iUnion F.F\n\n-- question: unused API?\nlemma ValidFamily.mem_of_elem {P : CircuitPredicate \u03b1} {X : Set \u03b1} (F : ValidFamily P X) (x : X.Elem) :\n    x.val \u2208 F.F x := by\n  rw [F.hF]\n\n-- question: unused API?\nlemma ValidFamily.outside {P : CircuitPredicate \u03b1} {C X : Set \u03b1} {F : ValidFamily P X} {z : \u03b1} (hzCF : z \u2208 C \\ F.union) :\n    z \u2209 X := by\n  intro hz\n  have := F.hF \u27e8z, hz\u27e9 \u27e8z, hz\u27e9\n  simp_all\n\nend ValidFamily\n\n\nsection CircuitAxioms\n\n/-- Circuit predicate `P` defines independence predicate: independent sets are all non-circuits. -/\ndef CircuitPredicate.toIndepPredicate (P : CircuitPredicate \u03b1) (E : Set \u03b1) : IndepPredicate \u03b1 :=\n  fun I : Set \u03b1 => I \u2286 E \u2227 \u2200 C : Set \u03b1, C \u2286 I \u2192 \u00ac(P C)\n\n/-- Axiom (C1): empty set is not a circuit. -/\ndef CircuitPredicate.NotCircuitEmpty (P : CircuitPredicate \u03b1) : Prop :=\n  \u00ac(P \u2205)\nalias CircuitPredicate.BruhnC1 := CircuitPredicate.NotCircuitEmpty\n\n/-- Axiom (C2): no circuit is a subset of another circuit. -/\ndef CircuitPredicate.CircuitNotSsubset (P : CircuitPredicate \u03b1) : Prop :=\n  \u2200 C C' : Set \u03b1, P C \u2192 P C' \u2192 \u00ac(C' \u2282 C)  -- todo: swap to \u00acC \u2282 C'\nalias CircuitPredicate.BruhnC2 := CircuitPredicate.CircuitNotSsubset\n\n/-- Axiom (C3) from Bruhn et al. -/\ndef CircuitPredicate.BruhnC3 (P : CircuitPredicate \u03b1) : Prop :=\n  \u2200 X C : Set \u03b1, \u2200 F : ValidFamily P X, \u2200 z \u2208 C \\ F.union, \u2203 C' : Set \u03b1, P C' \u2227 z \u2208 C' \u2227 C' \u2286 (C \u222a F.union) \\ X\n\n/-- Axiom (CM) from Bruhn et al.: set of all independent sets has the maximal subset property. -/\ndef CircuitPredicate.CircuitMaximal (P : CircuitPredicate \u03b1) (E : Set \u03b1) : Prop :=\n  \u2200 X : Set \u03b1, X \u2286 E \u2192 Matroid.ExistsMaximalSubsetProperty (P.toIndepPredicate E) X\nalias CircuitPredicate.BruhnCM := CircuitPredicate.CircuitMaximal\n\n/-- Every circuit is a subset of the ground set. -/\ndef CircuitPredicate.SubsetGround (P : CircuitPredicate \u03b1) (E : Set \u03b1) : Prop :=\n  \u2200 C : Set \u03b1, P C \u2192 C \u2286 E\nalias CircuitPredicate.BruhnCE := CircuitPredicate.SubsetGround\n\n/-- Strong circuit elimination axiom: if `C\u2081` and `C\u2082` are circuits with `e \u2208 C\u2081 \u2229 C\u2082` and `f \u2208 C\u2081 \\ C\u2082`,\n    then there is circuit `C\u2083` such that `f \u2208 C\u2083 \u2286 C\u2081 \u222a C\u2082 \\ {e}`. -/\ndef CircuitPredicate.StrongCircuitElim (P : CircuitPredicate \u03b1) : Prop :=\n  \u2200 C\u2081 C\u2082 : Set \u03b1, \u2200 e f, P C\u2081 \u2227 P C\u2082 \u2227 e \u2208 C\u2081 \u2229 C\u2082 \u2227 f \u2208 C\u2081 \\ C\u2082 \u2192 \u2203 C\u2083, P C\u2083 \u2227 f \u2208 C\u2083 \u2227 C\u2083 \u2286 (C\u2081 \u222a C\u2082) \\ {e}\n\n/-- Weak circuit elimination axiom: if `C\u2081` and `C\u2082` are distinct circuits and `e \u2208 C\u2081 \u2229 C\u2082`,\n    then there is circuit `C\u2083` such that `C\u2083 \u2286 C\u2081 \u222a C\u2082 \\ {e}`. -/\ndef CircuitPredicate.WeakCircuitElim (P : CircuitPredicate \u03b1) : Prop :=\n  \u2200 C\u2081 C\u2082 : Set \u03b1, C\u2081 \u2260 C\u2082 \u2192 P C\u2081 \u2192 P C\u2082 \u2192 \u2200 e \u2208 C\u2081 \u2229 C\u2082, \u2203 C\u2083, P C\u2083 \u2227 C\u2083 \u2286 (C\u2081 \u222a C\u2082) \\ {e}\n\nend CircuitAxioms\n\n\nsection CircuitAxiomRelations\n\n/-- Alternative formulation of axiom (C2). -/\nlemma CircuitPredicate.circuit_not_ssubset_iff (P : CircuitPredicate \u03b1) :\n    P.CircuitNotSsubset \u2194 \u2200 C C' : Set \u03b1, P C \u2192 P C' \u2192 C' \u2286 C \u2192 C \u2286 C' := by\n  constructor\n  \u00b7 intro hP C C' hC hC' hCC'\n    apply hP C C' hC at hC'\n    rw [ssubset_iff_subset_ne] at hC'\n    push_neg at hC'\n    exact (hC' hCC').symm.subset\n  \u00b7 intro hP C C' hC hC' hCC'\n    apply hP C C' hC at hC'\n    rw [ssubset_iff_subset_ne] at hCC'\n    exact hCC'.right.symm (Set.Subset.antisymm (hC' hCC'.left) hCC'.left)\n\n/-- Axiom (C3) implies strong circuit elimination. -/\nlemma CircuitPredicate.C3_strong_circuit_elim (P : CircuitPredicate \u03b1) :\n    P.BruhnC3 \u2192 P.StrongCircuitElim := by\n  intro hPC3 C\u2081 C\u2082 x z hxz\n  obtain \u27e8_hC\u2081, hC\u2082, hx, hz\u27e9 := hxz\n  let F : ValidFamily P {x} :=\n  \u27e8\n    (fun _ => C\u2082),\n    (fun _ => hC\u2082),\n    (by simpa using Set.mem_of_mem_inter_right hx)\n  \u27e9\n  specialize hPC3 {x} C\u2081 F\n  simp only [ValidFamily.union, Set.iUnion_coe_set, Set.mem_singleton_iff, Set.iUnion_iUnion_eq_left] at hPC3\n  specialize hPC3 z hz\n  exact hPC3\n\n/-- Strong circuit elimination implies weak circuit elimination. -/\nlemma CircuitPredicate.strong_circuit_elim_weak_circuit_elim (P : CircuitPredicate \u03b1) :\n    P.StrongCircuitElim \u2192 P.WeakCircuitElim := by\n  intro hP C\u2081 C\u2082 hCC hC\u2081 hC\u2082 e he\n  if hf : \u2203 f : \u03b1, f \u2208 C\u2081 \\ C\u2082 then\n    obtain \u27e8f, hf\u27e9 := hf\n    specialize hP C\u2081 C\u2082 e f (And.intro hC\u2081 (And.intro hC\u2082 (And.intro he hf)))\n    obtain \u27e8C\u2083, \u27e8hC\u2083, \u27e8-, _\u27e9\u27e9\u27e9 := hP\n    use C\u2083\n  else\n    push_neg at hf\n    simp only [Set.mem_diff, not_and, not_not] at hf\n    have C\u2081_sub_C\u2082 : C\u2081 \u2286 C\u2082 := hf\n    obtain \u27e8f, hff\u27e9 : (C\u2082 \\ C\u2081).Nonempty\n    \u00b7 rw [Set.diff_nonempty]\n      by_contra C\u2082_sub_C\u2081\n      exact hCC (C\u2081_sub_C\u2082.antisymm C\u2082_sub_C\u2081)\n    specialize hP C\u2082 C\u2081 e f (And.intro hC\u2082 (And.intro hC\u2081 (And.intro he.symm hff)))\n    obtain \u27e8C\u2083, \u27e8hC\u2083, \u27e8-, hCCCe\u27e9\u27e9\u27e9 := hP\n    rw [Set.union_comm] at hCCCe\n    use C\u2083\n\n/-- todo: desc -/\ndef CircuitPredicate.support (P : CircuitPredicate \u03b1) : Set \u03b1 :=\n  { C : Set \u03b1 | P C }.sUnion\n\n/-- todo: desc -/\nlemma CircuitPredicate.support_eq (P : CircuitPredicate \u03b1) :\n    Minimal (fun S : Set \u03b1 => \u2200 C : Set \u03b1, P C \u2192 C \u2286 S) P.support := by\n  sorry\n\n/-- Condition for circuit predicate to have finite support. -/\nlemma CircuitPredicate.finite_support_iff (P : CircuitPredicate \u03b1) :\n    P.support.Finite \u2194 \u2203 S : Set \u03b1, S.Finite \u2227 \u2200 C : Set \u03b1, P C \u2192 C \u2286 S := by\n  sorry\n\n/-- If `P` is finitely supported and `P` satisfies weak circuit elimination, then `P` satisfies (C3). -/\nlemma CircuitPredicate.finSup_weakCircuitElim_bruhnC3 {P : CircuitPredicate \u03b1} (hP_fin : P.support.Finite) :\n    P.WeakCircuitElim \u2192 P.BruhnC3 := by\n  sorry\n\nend CircuitAxiomRelations\n\n\nsection PredicateRelations\n\n/-- Independence predicate defines following circuit predicate: circuits are minimal dependent sets. -/\ndef IndepPredicate.ToCircuitPredicate (P : IndepPredicate \u03b1) (E : Set \u03b1) : CircuitPredicate \u03b1 :=\n  fun C : Set \u03b1 => Minimal (fun D : Set \u03b1 => \u00ac(P D) \u2227 D \u2286 E) C\n\n/-- Converting circuit predicate to independence predicate and then to circuit predicate\n    yields original independence predicate.-/\nlemma CircuitPredicate.toIndep_toCircuit (P : CircuitPredicate \u03b1) (E C : Set \u03b1) :\n    (P.toIndepPredicate E).ToCircuitPredicate E C \u2192 C \u2286 E \u2227 P C := by\n  intro \u27e8\u27e8C_dep, hCE\u27e9, C_min\u27e9\n  constructor\n  \u00b7 exact hCE\n  \u00b7 unfold CircuitPredicate.toIndepPredicate at C_dep C_min\n    push_neg at C_dep\n    obtain \u27e8D, hDC, hD\u27e9 := C_dep hCE\n    have D_ok : \u00ac(D \u2286 E \u2227 \u2200 C \u2286 D, \u00acP C) \u2227 D \u2286 E := \u27e8(by push_neg; intro; use D), hDC.trans hCE\u27e9\n    exact Set.eq_of_subset_of_subset (C_min D_ok hDC) hDC \u25b8 hD\n\n/-- todo: desc-/\nlemma CircuitPredicate.toIndep_toCircuit_iff {P : CircuitPredicate \u03b1} (hP : P.CircuitNotSsubset) (E C : Set \u03b1) :\n    (P.toIndepPredicate E).ToCircuitPredicate E C \u2194 C \u2286 E \u2227 P C := by\n  constructor\n  \u00b7 exact P.toIndep_toCircuit E C\n  \u00b7 intro \u27e8hCE, hC\u27e9\n    constructor\n    \u00b7 exact \u27e8fun \u27e8_, C_subset_E\u27e9 => (C_subset_E C Set.Subset.rfl) hC, hCE\u27e9\n    \u00b7 intro D \u27e8D_notIndep, hDE\u27e9 hDC\n      unfold CircuitPredicate.toIndepPredicate at D_notIndep\n      push_neg at D_notIndep\n      obtain \u27e8D', hDD, hD'\u27e9 := D_notIndep hDE\n      rw [CircuitPredicate.circuit_not_ssubset_iff] at hP\n      exact (hP C D' hC hD' (hDD.trans hDC)).trans hDD\n\n/-- Converting independence predicate to circuit predicate and then to independence predicate\n    yields original independence predicate.-/\nlemma IndepPredicate.toCircuit_toIndep_iff (P : IndepPredicate \u03b1) (E I : Set \u03b1) :\n    (P.ToCircuitPredicate E).toIndepPredicate E I \u2194 P I \u2227 I \u2286 E := by\n  constructor\n  \u00b7 intro \u27e8hIE, hI\u27e9\n    constructor\n    \u00b7 sorry\n    \u00b7 exact hIE\n  \u00b7 intro \u27e8hPI, hIE\u27e9\n    constructor\n    \u00b7 exact hIE\n    \u00b7 sorry\n\n/-- Converting independence predicate of matroid to circuit predicate and then to independence predicate\n    yields original independence predicate. -/\nlemma IndepPredicate.matroid_toCircuit_toIndep_iff (M : Matroid \u03b1) (I : Set \u03b1) :\n    (M.IndepPredicate.ToCircuitPredicate M.E).toIndepPredicate M.E I \u2194 I \u2286 M.E \u2227 M.Indep I := by\n  constructor\n  \u00b7 intro \u27e8hIE, hI\u27e9\n    constructor\n    \u00b7 exact hIE\n    \u00b7 -- hI : I contains no circuit\n      let hIE' := hIE\n      apply M.maximality at hIE\n      specialize hIE \u2205 M.empty_indep I.empty_subset\n      obtain \u27e8J, -, \u27e8J_indep, hJI\u27e9, hJ\u27e9 := hIE\n      simp at hJ\n      have J_eq_I : J = I\n      \u00b7 by_contra hJneqI\n        have haIJ : \u2203 a : \u03b1, a \u2208 I \\ J := Set.nonempty_of_ssubset (HasSubset.Subset.ssubset_of_ne hJI hJneqI)\n        obtain \u27e8a, ha\u27e9 := haIJ\n        have notIndep_J_a : \u00acM.Indep (J \u222a {a}) := sorry\n        have hC : \u2203 C : Set \u03b1, C \u2286 J \u222a {a} \u2227 \u00acM.Indep C \u2227 \u2200 C' \u2282 C, M.Indep C' := sorry\n        obtain \u27e8C, hCJa, C_notIndep, indep_ssub_C\u27e9 := hC\n        have hJE : J \u2286 M.E := fun \u2983a\u2984 a_1 => hIE (hJI a_1)\n        have haE : {a} \u2286 M.E := Set.singleton_subset_iff.\u2190 (hIE (Set.mem_of_mem_diff ha))\n        have hCE : C \u2286 M.E := fun _ a_1 => (Set.union_subset hJE haE) (hCJa a_1)\n        have haI : {a} \u2286 I := (Set.singleton_subset_iff.\u2190 (Set.mem_of_mem_diff ha))\n        have hJaI : J \u222a {a} \u2286 I := Set.union_subset hJI haI\n        have hCI : C \u2286 I := hCJa.trans hJaI\n        unfold IndepPredicate.ToCircuitPredicate Minimal at hI\n        push_neg at hI\n        specialize hI C hCI \u27e8C_notIndep, hCE\u27e9\n        obtain \u27e8D, \u27e8hDdep, hDE\u27e9, \u27e8hDC, hCD\u27e9\u27e9 := hI\n        sorry -- todo: finish\n      exact J_eq_I \u25b8 J_indep\n  \u00b7 intro \u27e8hIE, I_indep\u27e9\n    constructor\n    \u00b7 exact hIE\n    \u00b7 intro C hCI \u27e8\u27e8C_dep, hCE\u27e9, hCmin\u27e9\n      exact C_dep (Matroid.Indep.subset I_indep hCI)\n\nend PredicateRelations\n\n\nsection CircuitToIndepAxioms\n\n", "theoremStatement": "/-- Independence predicate constructed from circuit predicate satisfies (I1): empty set is independent. -/\nlemma CircuitPredicate.toIndepPredicate_indepEmpty {P : CircuitPredicate \u03b1}\n    (hP : P.NotCircuitEmpty) (E : Set \u03b1) :\n    (P.toIndepPredicate E).IndepEmpty ", "theoremName": "CircuitPredicate.toIndepPredicate_indepEmpty", "fileCreated": {"commit": "ee35fddd27b04eb576eb64b8bb74af513408f6ef", "date": "2024-12-21"}, "theoremCreated": {"commit": "43c746e51146ac13aa709eefe36b9f185633ea8b", "date": "2025-02-03"}, "file": "Seymour/Seymour/Matroid/Notions/CircuitAxioms.lean", "module": "Seymour.Matroid.Notions.CircuitAxioms", "jsonFile": "Seymour.Matroid.Notions.CircuitAxioms.jsonl", "positionMetadata": {"lineInFile": 253, "tokenPositionInFile": 9980, "theoremPositionInFile": 24}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 4, "numPremises": 16}, "proofMetadata": {"hasProof": true, "proof": ":=\n  \u27e8E.empty_subset, fun _ C_empty hC => hP (Set.subset_eq_empty C_empty rfl \u25b8 hC)\u27e9", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 84}}
{"srcContext": "import Mathlib.Data.Set.Card\nimport Mathlib.Data.Matroid.Dual\n\nimport Seymour.ForMathlib.SetTheory\nimport Seymour.Matroid.Notions.Circuit\nimport Seymour.Matroid.Notions.CircuitAxioms\nimport Seymour.Matroid.Notions.Connectivity\nimport Seymour.Matroid.Constructors.CircuitMatroid\n\n/-!\nThis file defines 2-sum of two (general) matroids `M\u2081` and `M\u2082`, denoted as `M\u2081 \u2295\u2082 M\u2082`.\n-/\n\nvariable {\u03b1 : Type}\n\n\nsection MainDefinitions\n\n/-- `M\u2081 \u2295\u2082 M\u2082` is defined if `M\u2081` and `M\u2082` satisfy the following assumptions -/\nstructure TwoSumAssumptions (M\u2081 M\u2082 : Matroid \u03b1) : Prop where\n  /-- `M\u2081` is finite -/\n  M\u2081fin : M\u2081.Finite\n  /-- `M\u2082` is finite -/\n  M\u2082fin : M\u2082.Finite\n  /-- `M\u2081` contains at least 2 elements -/\n  M\u2081card : M\u2081.E.encard \u2265 2\n  /-- `M\u2082` contains at least 2 elements -/\n  M\u2082card : M\u2082.E.encard \u2265 2\n  /-- `M\u2081` and `M\u2082` have exactly one element in common -/\n  interSingleton : (M\u2081.E \u2229 M\u2082.E).encard = 1\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2081` -/\n  M\u2081sep : \u00acM\u2081.Separator (M\u2081.E \u2229 M\u2082.E)\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2082` -/\n  M\u2082sep : \u00acM\u2082.Separator (M\u2081.E \u2229 M\u2082.E)\n\n-- question: can avoid this assumption? -- which assumption? the finiteness?\n\n/-- Ground set of `M\u2081 \u2295\u2082 M\u2082` -/\ndef twoSumGround (M\u2081 M\u2082 : Matroid \u03b1) : Set \u03b1 :=\n  (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)\n\n/-- Type 1 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2081` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType1 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 2 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2082` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType2 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2082.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 3 of circuits in `M\u2081 \u2295\u2082 M\u2082`:\n    sets `(C\u2081 \u222a C\u2082) \\ (M\u2081.E \u2229 M\u2082.E)` where `C\u2081` and `C\u2082` are circuits in `M\u2081` and `M\u2082`, respectively,\n    and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2081` and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2082` -/\ndef TwoSumCircuitType3 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit ((C \u2229 M\u2081.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 M\u2082.Circuit ((C \u2229 M\u2082.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 C \u2286 twoSumGround M\u2081 M\u2082\n\n/-- Circuit predicate of `M\u2081 \u2295\u2082 M\u2082`, which defines 2-sum as `CircuitMatroid` -/\ndef TwoSumCircuitPred (M\u2081 M\u2082 : Matroid \u03b1) : CircuitPredicate \u03b1 :=\n  fun C : Set \u03b1 =>\n    TwoSumCircuitType1 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType2 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType3 M\u2081 M\u2082 C\n\nend MainDefinitions\n\n\nsection PropertiesAssumptions\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1}\n\n/-- 2-sum assumptions are symmetric -/\nlemma TwoSumAssumptions.symm (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    TwoSumAssumptions M\u2082 M\u2081 :=\n  \u27e8\n    assumptions.M\u2082fin,\n    assumptions.M\u2081fin,\n    assumptions.M\u2082card,\n    assumptions.M\u2081card,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.interSingleton,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2082sep,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2081sep,\n  \u27e9\n\n/-- Intersection of ground sets is nonempty -/\nlemma TwoSumAssumptions.inter_nonempty (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (M\u2081.E \u2229 M\u2082.E).Nonempty :=\n  Set.one_le_encard_iff_nonempty.\u2192 assumptions.interSingleton.symm.le\n\n/-- Intersection of ground sets is a singleton set -/\nlemma TwoSumAssumptions.inter_singleton (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    \u2203 p : \u03b1, M\u2081.E \u2229 M\u2082.E = {p} :=\n  Set.encard_eq_one.\u2192 assumptions.interSingleton\n\nvariable {p : \u03b1}\n\n/-- Singleton element in intersection of ground sets in not a loop in `M\u2081` -/\nlemma TwoSumAssumptions.inter_singleton_not_loop_M\u2081 (assumptions : TwoSumAssumptions M\u2081 M\u2082)\n    (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2081.Loop p) :=\n  (hp \u25b8 assumptions.M\u2081sep <| Matroid.separator_loop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a coloop in `M\u2081` -/\nlemma TwoSumAssumptions.inter_singleton_not_coloop_M\u2081 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2081.Coloop p) :=\n  (hp \u25b8 assumptions.M\u2081sep <| Matroid.separator_coloop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a loop in `M\u2082` -/\nlemma TwoSumAssumptions.inter_singleton_not_loop_M\u2082 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2082.Loop p) :=\n  (hp \u25b8 assumptions.M\u2082sep <| Matroid.separator_loop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a coloop in `M\u2082` -/\nlemma TwoSumAssumptions.inter_singleton_not_coloop_M\u2082 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2082.Coloop p) :=\n  (hp \u25b8 assumptions.M\u2082sep <| Matroid.separator_coloop \u00b7)\n\nend PropertiesAssumptions\n\n\nsection PropertiesGroundSet\n\n/-- Ground set of 2-sum is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma twoSumGround_disjoint_inter (M\u2081 M\u2082 : Matroid \u03b1) :\n    twoSumGround M\u2081 M\u2082 \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  Set.disjoint_sdiff_left\n\n/-- Ground sets minus their intersection are disjoint sets -/\nlemma twoSum_disjoint_grounds_diff_inter (M\u2081 M\u2082 : Matroid \u03b1) :\n    M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) \u2ad7 M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E) := by\n  rw [Set.diff_self_inter, Set.diff_inter_self_eq_diff]\n  exact disjoint_sdiff_sdiff\n\nend PropertiesGroundSet\n\n\nsection PropertiesCircuitType1\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1} {C : Set \u03b1}\n\n/-- Circuit of type 1 is a circuit in `M\u2081` -/\nlemma TwoSumCircuitType1.circuit_M\u2081 (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : M\u2081.Circuit C :=\n  hC.left\n\n/-- Circuit of type 1 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType1.disjoint_inter (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of type 1 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma TwoSumCircuitType1.subset_union (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_left hC.circuit_M\u2081.subset_ground M\u2082.E\n\n/-- Circuit of type 1 lies in ground set of `M\u2081 \u2295\u2082 M\u2082` -/\nlemma TwoSumCircuitType1.subset_ground (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 twoSumGround M\u2081 M\u2082 :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 1 lies in `M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma TwoSumCircuitType1.subset_M\u2081_diff_inter (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2081.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 1 is disjoint with `M\u2082.E` -/\nlemma TwoSumCircuitType1.disjoint_M\u2082 (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2ad7 M\u2082.E := by\n  have hMM := twoSum_disjoint_grounds_diff_inter M\u2081 M\u2082\n  have hCM\u2082 := Set.disjoint_of_subset_left hC.subset_M\u2081_diff_inter hMM\n  have hCM\u2082 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2082, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_right] at hCM\u2082\n  exact hCM\u2082\n\nend PropertiesCircuitType1\n\n\nsection PropertiesCircuitType2\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1} {C : Set \u03b1}\n\n/-- Circuit of type 2 is a circuit in `M\u2082` -/\nlemma TwoSumCircuitType2.circuit_M\u2082 (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : M\u2082.Circuit C :=\n  hC.left\n\n/-- Circuit of type 2 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType2.disjoint_inter (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of type 2 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma TwoSumCircuitType2.subset_union (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_right hC.circuit_M\u2082.subset_ground M\u2081.E\n\n/-- Circuit of type 2 lies in ground set of `M\u2081 \u2295\u2082 M\u2082` -/\nlemma TwoSumCircuitType2.subset_ground (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2286 twoSumGround M\u2081 M\u2082 :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 2 lies in `M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma TwoSumCircuitType2.subset_M\u2082_diff_inter (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2286 M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2082.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 2 is disjoint with `M\u2081.E` -/\nlemma TwoSumCircuitType2.disjoint_M\u2081 (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E := by\n  have hMM := twoSum_disjoint_grounds_diff_inter M\u2081 M\u2082\n  have hCM\u2081 := (Set.disjoint_of_subset_right hC.subset_M\u2082_diff_inter hMM).symm\n  have hCM\u2081 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2081, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_left] at hCM\u2081\n  exact hCM\u2081\n\nend PropertiesCircuitType2\n\n\nsection PropertiesCircuitType3\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1} {C : Set \u03b1}\n\n/-- Circuit of type 3 yields a circuit in `M\u2081` after intersecting it with `M\u2081.E` and adding `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType3.to_circuit_M\u2081 (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : M\u2081.Circuit ((C \u2229 M\u2081.E) \u222a (M\u2081.E \u2229 M\u2082.E)) :=\n  hC.left\n\n/-- Circuit of type 3 yields a circuit in `M\u2082` after intersecting it with `M\u2081.E` and adding `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType3.to_circuit_M\u2082 (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : M\u2082.Circuit ((C \u2229 M\u2082.E) \u222a (M\u2081.E \u2229 M\u2082.E)) :=\n  hC.right.left\n\n/-- Circuit of type 3 is subset of ground set of `M\u2081 \u2295\u2082 M\u2082` -/\ndef TwoSumCircuitType3.subset_ground (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2286 twoSumGround M\u2081 M\u2082 :=\n  hC.right.right\n\n/-- Circuit of type 3 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma TwoSumCircuitType3.subset_union (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \u222a M\u2082.E :=\n  sub_union_diff_sub_union hC.subset_ground\n\n/-- Circuit of type 3 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType3.disjoint_inter (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  Set.disjoint_of_subset_left hC.subset_ground (twoSumGround_disjoint_inter M\u2081 M\u2082)\n\n/-- Circuit of type 3 intersected with `M\u2081.E` is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType3.disjoint_inter_M\u2081_inter (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2229 M\u2081.E \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.disjoint_inter.inter_left M\u2081.E\n\n/-- Circuit of type 3 intersected with `M\u2082.E` is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType3.disjoint_inter_M\u2082_inter (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2229 M\u2082.E \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.disjoint_inter.inter_left M\u2082.E\n\n/-- Circuit of type 3 has nonempty intersection with `M\u2081.E` -/\nlemma TwoSumCircuitType3.inter_M\u2081_nonempty (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (C \u2229 M\u2081.E).Nonempty := by\n  by_contra! hCM\u2081\n  have hM\u2081 := hC.to_circuit_M\u2081\n  have \u27e8p, hp\u27e9 := assumptions.inter_singleton\n  rw [hCM\u2081, Set.empty_union, hp, \u2190Matroid.loop_iff_circuit M\u2081] at hM\u2081\n  have hpM\u2081 := assumptions.inter_singleton_not_loop_M\u2081 hp\n  exact hpM\u2081 hM\u2081\n\n/-- Circuit of type 3 has nonempty intersection with `M\u2082.E` -/\nlemma TwoSumCircuitType3.inter_M\u2082_nonempty (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (C \u2229 M\u2082.E).Nonempty := by\n  by_contra! hCM\u2082empty\n  have hCM\u2082 := hC.to_circuit_M\u2082\n  have \u27e8p, hp\u27e9 := assumptions.inter_singleton\n  rw [hCM\u2082empty, Set.empty_union, hp, \u2190Matroid.loop_iff_circuit M\u2082] at hCM\u2082\n  exact assumptions.inter_singleton_not_loop_M\u2082 hp hCM\u2082\n\nend PropertiesCircuitType3\n\n\nsection PropertiesCircuitTypePairs1\n\n/-- Circuit of type 1 is not a strict subset of any circuit of type 1 -/\nlemma TwoSumCircuitType1.not_ssubset_circuit_type_1 {M\u2081 M\u2082 : Matroid \u03b1} {C C' : Set \u03b1}\n    (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) (hC' : TwoSumCircuitType1 M\u2081 M\u2082 C') :\n    \u00ac(C \u2282 C') :=\n  hC.circuit_M\u2081.not_ssubset_circuit hC'.circuit_M\u2081\n\n/-- Circuit of type 1 is disjoint with any circuit of type 2 -/\nlemma TwoSumCircuitType1.disjoint_circuit_type_2 {M\u2081 M\u2082 : Matroid \u03b1} {C\u2081 C\u2082 : Set \u03b1}\n    (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) :\n    C\u2081 \u2ad7 C\u2082 := by\n  have hC\u2081M\u2081 := hC\u2081.subset_M\u2081_diff_inter\n  have hC\u2082M\u2082 := hC\u2082.subset_M\u2082_diff_inter\n  have hMM := twoSum_disjoint_grounds_diff_inter M\u2081 M\u2082\n  exact Set.disjoint_of_subset hC\u2081M\u2081 hC\u2082M\u2082 hMM\n\n/-- Circuit of type 1 is not a strict subset of any circuit of type 2 -/\nlemma TwoSumCircuitType1.not_ssubset_circuit_type_2 {M\u2081 M\u2082 : Matroid \u03b1} {C\u2081 C\u2082 : Set \u03b1}\n    (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) :\n    \u00ac(C\u2081 \u2282 C\u2082) :=\n  disjoint_nonempty_not_ssubset (hC\u2081.disjoint_circuit_type_2 hC\u2082) hC\u2081.circuit_M\u2081.nonempty\n\n/-- Circuit of type 1 is not a strict subset of any circuit of type 3 -/\nlemma TwoSumCircuitType1.not_ssubset_circuit_type_3 {M\u2081 M\u2082 : Matroid \u03b1} {C\u2081 C\u2083 : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) (hC\u2083 : TwoSumCircuitType3 M\u2081 M\u2082 C\u2083) :\n    \u00ac(C\u2081 \u2282 C\u2083) :=\n  fun hCC =>\n    hC\u2081.circuit_M\u2081.not_ssubset_circuit hC\u2083.to_circuit_M\u2081\n      (Set.ssubset_of_ssubset_of_subset (ssubset_union_disjoint_nonempty hC\u2081.disjoint_inter assumptions.inter_nonempty)\n        (Set.union_subset_union_left (M\u2081.E \u2229 M\u2082.E) (Set.subset_inter hCC.left hC\u2081.circuit_M\u2081.subset_ground)))\n\n/-- Circuit of type 1 is not a strict subset of any other circuit -/\nlemma TwoSumCircuitType1.not_ssubset_circuit {M\u2081 M\u2082 : Matroid \u03b1} {C\u2081 C : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) (hC : TwoSumCircuitPred M\u2081 M\u2082 C) :\n    \u00ac(C\u2081 \u2282 C) := by\n  cases hC with\n  | inl hC => exact hC\u2081.not_ssubset_circuit_type_1 hC\n  | inr hC => cases hC with\n    | inl hC => exact hC\u2081.not_ssubset_circuit_type_2 hC\n    | inr hC => exact hC\u2081.not_ssubset_circuit_type_3 assumptions hC\n\nend PropertiesCircuitTypePairs1\n\n\nsection PropertiesCircuitTypePairs2\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1}\n\n/-- Circuits of type 2 are disjoint with circuits of type 1 -/\nlemma TwoSumCircuitType2.disjoint_circuitType1 {C\u2081 C\u2082 : Set \u03b1}\n    (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) :\n    C\u2082 \u2ad7 C\u2081 :=\n  (hC\u2081.disjoint_circuit_type_2 hC\u2082).symm\n\n/-- Circuit of type 2 is not a strict subset of any circuit of type 1 -/\nlemma TwoSumCircuitType2.not_ssubset_circuitType1 {C\u2081 C\u2082 : Set \u03b1}\n    (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) :\n    \u00ac(C\u2082 \u2282 C\u2081) :=\n  disjoint_nonempty_not_ssubset (hC\u2082.disjoint_circuitType1 hC\u2081) hC\u2082.circuit_M\u2082.nonempty\n\n/-- Circuit of type 2 is not a strict subset of any circuit of type 2 -/\nlemma TwoSumCircuitType2.not_ssubset_circuitType2 {C C' : Set \u03b1}\n    (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) (hC' : TwoSumCircuitType2 M\u2081 M\u2082 C') :\n    \u00ac(C \u2282 C') :=\n  hC.circuit_M\u2082.not_ssubset_circuit hC'.circuit_M\u2082\n\n/-- Circuit of type 2 is not a strict subset of any circuit of type 3 -/\nlemma TwoSumAssumptions.circuitType2_not_ssubset_circuitType3 {C\u2082 C\u2083 : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) (hC\u2083 : TwoSumCircuitType3 M\u2081 M\u2082 C\u2083) :\n    \u00ac(C\u2082 \u2282 C\u2083) :=\n  fun hCC =>\n    hC\u2082.circuit_M\u2082.not_ssubset_circuit hC\u2083.to_circuit_M\u2082\n      (Set.ssubset_of_ssubset_of_subset (ssubset_union_disjoint_nonempty hC\u2082.disjoint_inter assumptions.inter_nonempty)\n        (Set.union_subset_union_left (M\u2081.E \u2229 M\u2082.E) (Set.subset_inter hCC.left hC\u2082.circuit_M\u2082.subset_ground)))\n\n/-- Circuit of type 2 is not a strict subset of any other circuit -/\nlemma TwoSumAssumptions.circuitType2_not_ssubset {C\u2082 C : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) (hC : TwoSumCircuitPred M\u2081 M\u2082 C) :\n    \u00ac(C\u2082 \u2282 C) := by\n  cases hC with\n  | inl hC => exact hC\u2082.not_ssubset_circuitType1 hC\n  | inr hC => cases hC with\n    | inl hC => exact hC\u2082.not_ssubset_circuitType2 hC\n    | inr hC => exact assumptions.circuitType2_not_ssubset_circuitType3 hC\u2082 hC\n\nend PropertiesCircuitTypePairs2\n\n\nsection PropertiesCircuitTypePairs3\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1}\n\n/-- Circuit of type 3 is not a strict subset of any circuit of type 1 -/\nlemma TwoSumAssumptions.circuitType3_not_ssubset_circuitType1 {C\u2081 C\u2083 : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2083 : TwoSumCircuitType3 M\u2081 M\u2082 C\u2083) (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) :\n    \u00ac(C\u2083 \u2282 C\u2081) :=\n  nonempty_inter_not_ssubset_empty_inter (hC\u2083.inter_M\u2082_nonempty assumptions) hC\u2081.disjoint_M\u2082.inter_eq\n\n/-- Circuit of type 3 is not a strict subset of any circuit of type 2 -/\nlemma TwoSumAssumptions.circuitType3_not_ssubset_circuitType2 {C\u2082 C\u2083 : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2083 : TwoSumCircuitType3 M\u2081 M\u2082 C\u2083) (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) :\n    \u00ac(C\u2083 \u2282 C\u2082) :=\n  nonempty_inter_not_ssubset_empty_inter (hC\u2083.inter_M\u2081_nonempty assumptions) hC\u2082.disjoint_M\u2081.inter_eq\n\n/-- Circuit of type 3 is not a strict subset of any circuit of type 3 -/\nlemma TwoSumCircuitType3.not_ssubset_circuitType3 {C C' : Set \u03b1}\n    (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) (hC' : TwoSumCircuitType3 M\u2081 M\u2082 C') :\n    \u00ac(C \u2282 C') := by\n  intro \u27e8hCC', hnCC'\u27e9\n  have M\u2081_circ_nssub := Set.ssubset_def \u25b8 hC.to_circuit_M\u2081.not_ssubset_circuit hC'.to_circuit_M\u2081\n  have M\u2082_circ_nssub := Set.ssubset_def \u25b8 hC.to_circuit_M\u2082.not_ssubset_circuit hC'.to_circuit_M\u2082\n  push_neg at M\u2081_circ_nssub\n  push_neg at M\u2082_circ_nssub\n  have M\u2081_circ_sub := (union_subset_union_iff hC'.disjoint_inter_M\u2081_inter hC.disjoint_inter_M\u2081_inter).\u2192\n    (M\u2081_circ_nssub (Set.union_subset_union_left (M\u2081.E \u2229 M\u2082.E) (Set.inter_subset_inter_left M\u2081.E hCC')))\n  have M\u2082_circ_sub := (union_subset_union_iff hC'.disjoint_inter_M\u2082_inter hC.disjoint_inter_M\u2082_inter).\u2192\n    (M\u2082_circ_nssub (Set.union_subset_union_left (M\u2081.E \u2229 M\u2082.E) (Set.inter_subset_inter_left M\u2082.E hCC')))\n  exact hnCC' (hC.subset_union.parts_eq \u25b8 hC'.subset_union.parts_eq \u25b8 Set.union_subset_union M\u2081_circ_sub M\u2082_circ_sub)\n\n/-- Circuit of type 3 is not a strict subset of any other circuit -/\nlemma TwoSumAssumptions.circuitType3_not_ssubset_circuit {C\u2083 C : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2083 : TwoSumCircuitType3 M\u2081 M\u2082 C\u2083) (hC : TwoSumCircuitPred M\u2081 M\u2082 C) :\n    \u00ac(C\u2083 \u2282 C) := by\n  cases hC with\n  | inl hC => exact assumptions.circuitType3_not_ssubset_circuitType1 hC\u2083 hC\n  | inr hC => cases hC with\n    | inl hC => exact assumptions.circuitType3_not_ssubset_circuitType2 hC\u2083 hC\n    | inr hC => exact hC\u2083.not_ssubset_circuitType3 hC\n\nend PropertiesCircuitTypePairs3\n\n\nsection PropertiesCircuitPred\n\n", "theoremStatement": "/-- In definition of 2-sum, empty set is not a circuit -/\nlemma TwoSumAssumptions.twoSumCircuitPred_notCircuitEmpty {M\u2081 M\u2082 : Matroid \u03b1} (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (TwoSumCircuitPred M\u2081 M\u2082).NotCircuitEmpty ", "theoremName": "TwoSumAssumptions.twoSumCircuitPred_notCircuitEmpty", "fileCreated": {"commit": "d0eaaa305c96cd81ac061f505a81614db6856b21", "date": "2025-01-09"}, "theoremCreated": {"commit": "43c746e51146ac13aa709eefe36b9f185633ea8b", "date": "2025-02-03"}, "file": "Seymour/Seymour/Matroid/Operations/Sum2/Basic.lean", "module": "Seymour.Matroid.Operations.Sum2.Basic", "jsonFile": "Seymour.Matroid.Operations.Sum2.Basic.jsonl", "positionMetadata": {"lineInFile": 394, "tokenPositionInFile": 17220, "theoremPositionInFile": 49}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 10, "repositoryPremises": true, "numRepositoryPremises": 17, "numPremises": 52}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  unfold CircuitPredicate.NotCircuitEmpty TwoSumCircuitPred\n  push_neg\n  refine \u27e8(\u00b7.circuit_M\u2081.nonempty.ne_empty rfl), (\u00b7.circuit_M\u2082.nonempty.ne_empty rfl), fun \u27e8hpM\u2081, hpM\u2082, hE\u27e9 => ?_\u27e9\n  have \u27e8p, hp\u27e9 := assumptions.inter_singleton\n  rw [Set.empty_inter, Set.empty_union, hp, \u2190Matroid.loop_iff_circuit M\u2081] at hpM\u2081\n  exact (hp \u25b8 assumptions.M\u2081sep) (Matroid.separator_loop hpM\u2081)", "proofType": "tactic", "proofLengthLines": 6, "proofLengthTokens": 381}}
{"srcContext": "import Seymour.ForMathlib.MatrixTU\n\n/-!\nThis file provides notation used in the project and conversions between set-theoretical and type-theoretical definitions.\n-/\n\n/-- The finite field on 2 elements; write `Z2` for \"value\" type but `Fin 2` for \"indexing\" type. -/\nabbrev Z2 : Type := ZMod 2\n\n/-- The finite field on 3 elements; write `Z3` for \"value\" type but `Fin 3` for \"indexing\" type. -/\nabbrev Z3 : Type := ZMod 3\n\n/-- Roughly speaking `a \u1543 A` is `A \u222a {a}`. -/\ninfixr:66 \" \u1543 \" => Insert.insert\n\n/-- Writing `X \u2ad7 Y` is slightly more general than writing `X \u2229 Y = \u2205`. -/\ninfix:61 \" \u2ad7 \" => Disjoint\n\n/-- The left-to-right direction of `\u2194`. -/\npostfix:max \".\u2192\" => Iff.mp\n\n/-- The right-to-left direction of `\u2194`. -/\npostfix:max \".\u2190\" => Iff.mpr\n\n\nsection utils\n\nlemma Fin2_eq_1_of_ne_0 {a : Fin 2} (ha : a \u2260 0) : a = 1 := by\n  omega\n\nlemma Fin3_eq_2_of_ne_0_1 {a : Fin 3} (ha0 : a \u2260 0) (ha1 : a \u2260 1) : a = 2 := by\n  omega\n\n\nvariable {\u03b1 : Type}\n\n/-- Given `X \u2286 Y` cast an element of `X` as an element of `Y`. -/\ndef HasSubset.Subset.elem {X Y : Set \u03b1} (hXY : X \u2286 Y) (x : X.Elem) : Y.Elem :=\n  \u27e8x.val, hXY x.property\u27e9\n\nlemma HasSubset.Subset.elem_injective {X Y : Set \u03b1} (hXY : X \u2286 Y) : hXY.elem.Injective := by\n  intro x y hxy\n  ext\n  simpa [HasSubset.Subset.elem] using hxy\n\n/-- Convert `(X \u222a Y).Elem` to `X.Elem \u2295 Y.Elem`. -/\ndef Subtype.toSum {X Y : Set \u03b1} [\u2200 a, Decidable (a \u2208 X)] [\u2200 a, Decidable (a \u2208 Y)] (i : (X \u222a Y).Elem) : X.Elem \u2295 Y.Elem :=\n  if hiX : i.val \u2208 X then Sum.inl \u27e8i, hiX\u27e9 else\n  if hiY : i.val \u2208 Y then Sum.inr \u27e8i, hiY\u27e9 else\n  (i.property.elim hiX hiY).elim\n\n/-- Convert `X.Elem \u2295 Y.Elem` to `(X \u222a Y).Elem`. -/\ndef Sum.toUnion {X Y : Set \u03b1} (i : X.Elem \u2295 Y.Elem) : (X \u222a Y).Elem :=\n  i.casesOn Set.subset_union_left.elem Set.subset_union_right.elem\n\n/-- Converting `(X \u222a Y).Elem` to `X.Elem \u2295 Y.Elem` and back to `(X \u222a Y).Elem` gives the original element. -/\nlemma toSum_toUnion {X Y : Set \u03b1} [\u2200 a, Decidable (a \u2208 X)] [\u2200 a, Decidable (a \u2208 Y)] (i : (X \u222a Y).Elem) :\n    i.toSum.toUnion = i := by\n  if hiX : i.val \u2208 X then\n    simp_all [Subtype.toSum, Sum.toUnion, HasSubset.Subset.elem]\n  else if hiY : i.val \u2208 Y then\n    simp_all [Subtype.toSum, Sum.toUnion, HasSubset.Subset.elem]\n  else\n    exfalso\n    exact i.property.elim hiX hiY\n\n", "theoremStatement": "/-- Converting `X.Elem \u2295 Y.Elem` to `(X \u222a Y).Elem` and back to `X.Elem \u2295 Y.Elem` gives the original element, assuming that\n`X` and `Y` are disjoint. -/\nlemma toUnion_toSum {X Y : Set \u03b1} [\u2200 a, Decidable (a \u2208 X)] [\u2200 a, Decidable (a \u2208 Y)] (hXY : X \u2ad7 Y) (i : X.Elem \u2295 Y.Elem) :\n    i.toUnion.toSum = i ", "theoremName": "toUnion_toSum", "fileCreated": {"commit": "0e3e9cb42d2f02ece37a2344545c339b09a60217", "date": "2024-11-30"}, "theoremCreated": {"commit": "f5fbed2afa71a9f389c91e0a235a658c809f8b3d", "date": "2024-11-30"}, "file": "Seymour/Seymour/Basic.lean", "module": "Seymour.Basic", "jsonFile": "Seymour.Basic.jsonl", "positionMetadata": {"lineInFile": 67, "tokenPositionInFile": 2255, "theoremPositionInFile": 13}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 58}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [Set.disjoint_right] at hXY\n  cases i <;> simp [Subtype.toSum, Sum.toUnion, HasSubset.Subset.elem, hXY]", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 114}}
{"srcContext": "import Mathlib.Data.Set.Card\nimport Mathlib.Data.Matroid.Dual\n\nimport Seymour.ForMathlib.SetTheory\nimport Seymour.Matroid.Notions.Circuit\nimport Seymour.Matroid.Notions.CircuitAxioms\nimport Seymour.Matroid.Notions.Connectivity\nimport Seymour.Matroid.Constructors.CircuitMatroid\n\n/-!\nThis file defines 2-sum of two (general) matroids `M\u2081` and `M\u2082`, denoted as `M\u2081 \u2295\u2082 M\u2082`.\n-/\n\nvariable {\u03b1 : Type}\n\n\nsection MainDefinitions\n\n/-- `M\u2081 \u2295\u2082 M\u2082` is defined if `M\u2081` and `M\u2082` satisfy the following assumptions -/\nstructure TwoSumAssumptions (M\u2081 M\u2082 : Matroid \u03b1) : Prop where\n  /-- `M\u2081` is finite -/\n  M\u2081fin : M\u2081.Finite\n  /-- `M\u2082` is finite -/\n  M\u2082fin : M\u2082.Finite\n  /-- `M\u2081` contains at least 2 elements -/\n  M\u2081card : M\u2081.E.encard \u2265 2\n  /-- `M\u2082` contains at least 2 elements -/\n  M\u2082card : M\u2082.E.encard \u2265 2\n  /-- `M\u2081` and `M\u2082` have exactly one element in common -/\n  interSingleton : (M\u2081.E \u2229 M\u2082.E).encard = 1\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2081` -/\n  M\u2081sep : \u00acM\u2081.Separator (M\u2081.E \u2229 M\u2082.E)\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2082` -/\n  M\u2082sep : \u00acM\u2082.Separator (M\u2081.E \u2229 M\u2082.E)\n\n-- question: can avoid this assumption? -- which assumption? the finiteness?\n\n/-- Ground set of `M\u2081 \u2295\u2082 M\u2082` -/\ndef twoSumGround (M\u2081 M\u2082 : Matroid \u03b1) : Set \u03b1 :=\n  (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)\n\n/-- Type 1 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2081` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType1 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 2 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2082` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType2 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2082.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 3 of circuits in `M\u2081 \u2295\u2082 M\u2082`:\n    sets `(C\u2081 \u222a C\u2082) \\ (M\u2081.E \u2229 M\u2082.E)` where `C\u2081` and `C\u2082` are circuits in `M\u2081` and `M\u2082`, respectively,\n    and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2081` and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2082` -/\ndef TwoSumCircuitType3 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit ((C \u2229 M\u2081.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 M\u2082.Circuit ((C \u2229 M\u2082.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 C \u2286 twoSumGround M\u2081 M\u2082\n\n/-- Circuit predicate of `M\u2081 \u2295\u2082 M\u2082`, which defines 2-sum as `CircuitMatroid` -/\ndef TwoSumCircuitPred (M\u2081 M\u2082 : Matroid \u03b1) : CircuitPredicate \u03b1 :=\n  fun C : Set \u03b1 =>\n    TwoSumCircuitType1 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType2 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType3 M\u2081 M\u2082 C\n\nend MainDefinitions\n\n\nsection PropertiesAssumptions\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1}\n\n/-- 2-sum assumptions are symmetric -/\nlemma TwoSumAssumptions.symm (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    TwoSumAssumptions M\u2082 M\u2081 :=\n  \u27e8\n    assumptions.M\u2082fin,\n    assumptions.M\u2081fin,\n    assumptions.M\u2082card,\n    assumptions.M\u2081card,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.interSingleton,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2082sep,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2081sep,\n  \u27e9\n\n/-- Intersection of ground sets is nonempty -/\nlemma TwoSumAssumptions.inter_nonempty (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (M\u2081.E \u2229 M\u2082.E).Nonempty :=\n  Set.one_le_encard_iff_nonempty.\u2192 assumptions.interSingleton.symm.le\n\n/-- Intersection of ground sets is a singleton set -/\nlemma TwoSumAssumptions.inter_singleton (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    \u2203 p : \u03b1, M\u2081.E \u2229 M\u2082.E = {p} :=\n  Set.encard_eq_one.\u2192 assumptions.interSingleton\n\nvariable {p : \u03b1}\n\n/-- Singleton element in intersection of ground sets in not a loop in `M\u2081` -/\nlemma TwoSumAssumptions.inter_singleton_not_loop_M\u2081 (assumptions : TwoSumAssumptions M\u2081 M\u2082)\n    (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2081.Loop p) :=\n  (hp \u25b8 assumptions.M\u2081sep <| Matroid.separator_loop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a coloop in `M\u2081` -/\nlemma TwoSumAssumptions.inter_singleton_not_coloop_M\u2081 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2081.Coloop p) :=\n  (hp \u25b8 assumptions.M\u2081sep <| Matroid.separator_coloop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a loop in `M\u2082` -/\nlemma TwoSumAssumptions.inter_singleton_not_loop_M\u2082 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2082.Loop p) :=\n  (hp \u25b8 assumptions.M\u2082sep <| Matroid.separator_loop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a coloop in `M\u2082` -/\nlemma TwoSumAssumptions.inter_singleton_not_coloop_M\u2082 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2082.Coloop p) :=\n  (hp \u25b8 assumptions.M\u2082sep <| Matroid.separator_coloop \u00b7)\n\nend PropertiesAssumptions\n\n\nsection PropertiesGroundSet\n\n/-- Ground set of 2-sum is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma twoSumGround_disjoint_inter (M\u2081 M\u2082 : Matroid \u03b1) :\n    twoSumGround M\u2081 M\u2082 \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  Set.disjoint_sdiff_left\n\n/-- Ground sets minus their intersection are disjoint sets -/\nlemma twoSum_disjoint_grounds_diff_inter (M\u2081 M\u2082 : Matroid \u03b1) :\n    M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) \u2ad7 M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E) := by\n  rw [Set.diff_self_inter, Set.diff_inter_self_eq_diff]\n  exact disjoint_sdiff_sdiff\n\nend PropertiesGroundSet\n\n\nsection PropertiesCircuitType1\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1} {C : Set \u03b1}\n\n/-- Circuit of type 1 is a circuit in `M\u2081` -/\nlemma TwoSumCircuitType1.circuit_M\u2081 (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : M\u2081.Circuit C :=\n  hC.left\n\n/-- Circuit of type 1 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType1.disjoint_inter (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of type 1 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma TwoSumCircuitType1.subset_union (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_left hC.circuit_M\u2081.subset_ground M\u2082.E\n\n/-- Circuit of type 1 lies in ground set of `M\u2081 \u2295\u2082 M\u2082` -/\nlemma TwoSumCircuitType1.subset_ground (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 twoSumGround M\u2081 M\u2082 :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 1 lies in `M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma TwoSumCircuitType1.subset_M\u2081_diff_inter (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2081.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 1 is disjoint with `M\u2082.E` -/\nlemma TwoSumCircuitType1.disjoint_M\u2082 (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2ad7 M\u2082.E := by\n  have hMM := twoSum_disjoint_grounds_diff_inter M\u2081 M\u2082\n  have hCM\u2082 := Set.disjoint_of_subset_left hC.subset_M\u2081_diff_inter hMM\n  have hCM\u2082 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2082, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_right] at hCM\u2082\n  exact hCM\u2082\n\nend PropertiesCircuitType1\n\n\nsection PropertiesCircuitType2\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1} {C : Set \u03b1}\n\n", "theoremStatement": "/-- Circuit of type 2 is a circuit in `M\u2082` -/\nlemma TwoSumCircuitType2.circuit_M\u2082 (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : M\u2082.Circuit C ", "theoremName": "TwoSumCircuitType2.circuit_M\u2082", "fileCreated": {"commit": "d0eaaa305c96cd81ac061f505a81614db6856b21", "date": "2025-01-09"}, "theoremCreated": {"commit": "439c72996f29168161b974bc602629cac773728f", "date": "2025-01-08"}, "file": "Seymour/Seymour/Matroid/Operations/Sum2/Basic.lean", "module": "Seymour.Matroid.Operations.Sum2.Basic", "jsonFile": "Seymour.Matroid.Operations.Sum2.Basic.jsonl", "positionMetadata": {"lineInFile": 174, "tokenPositionInFile": 6472, "theoremPositionInFile": 20}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 18}, "proofMetadata": {"hasProof": true, "proof": ":=\n  hC.left", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 12}}
{"srcContext": "import Mathlib.Data.Matroid.Closure\nimport Seymour.Basic\n\n-- we should use https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Data/Matroid/Circuit.lean instead\n\nvariable {\u03b1 : Type}\n\n/-- Circuit is minimal dependent subset. -/\ndef Matroid.Circuit (M : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  Minimal M.Dep C\n\n/-- Every circuit is dependent. -/\nlemma Matroid.Circuit.dep (M : Matroid \u03b1) {C : Set \u03b1} (hC : M.Circuit C) : M.Dep C :=\n  hC.left\n\n/-- Every circuit is a subset of the ground set. -/\nlemma Matroid.Circuit.subset_ground (M : Matroid \u03b1) {C : Set \u03b1} (hC : M.Circuit C) : C \u2286 M.E :=\n  hC.left.right\n\n/-- Equivalence with explicit definition of circuits. -/\nlemma Matroid.circuit_iff_def (M : Matroid \u03b1) (C : Set \u03b1) :\n    M.Circuit C \u2194 M.Dep C \u2227 \u2200 C' : Set \u03b1, M.Dep C' \u2192 C' \u2286 C \u2192 C \u2286 C' :=\n  rfl.to_iff\n\n/-- Every strict subset of a circuit is independent. -/\nlemma Matroid.Circuit.indep_ssub {M : Matroid \u03b1} {C C' : Set \u03b1} (hC : M.Circuit C) (hC' : C' \u2282 C) :\n    M.Indep C' := by\n  by_contra notIndep_M_C'\n  have C'_sub_C : C' \u2286 C := subset_of_ssubset hC'\n  have C_sub_E : C \u2286 M.E := hC.subset_ground\n  have C'_sub_E : C' \u2286 M.E := hC'.subset.trans C_sub_E\n  exact hC'.ne.symm ((hC.right (M.dep_of_not_indep notIndep_M_C' C'_sub_E) C'_sub_C).antisymm C'_sub_C)\n\n/-- Deleting one element from a circuit produces an independent set. -/\nlemma Matroid.Circuit.indep_diff_singleton {M : Matroid \u03b1} {C : Set \u03b1} {a : \u03b1} (hC : M.Circuit C) (ha : a \u2208 C) :\n    M.Indep (C \\ {a}) :=\n  hC.indep_ssub (Set.diff_singleton_sSubset.\u2190 ha)\n\n/-- Empty set is not a circuit. -/\nlemma Matroid.Circuit.not_empty {M : Matroid \u03b1} (hM : M.Circuit \u2205) : False :=\n  hM.left.left M.empty_indep\n\n", "theoremStatement": "/-- Every circuit is nonempty. -/\nlemma Matroid.Circuit.nonempty {M : Matroid \u03b1} {C : Set \u03b1} (hC : M.Circuit C) : C.Nonempty ", "theoremName": "Matroid.Circuit.nonempty", "fileCreated": {"commit": "b44bff2f1ee71349fa9fa251579a0f5a0e575538", "date": "2024-12-19"}, "theoremCreated": {"commit": "ee35fddd27b04eb576eb64b8bb74af513408f6ef", "date": "2024-12-21"}, "file": "Seymour/Seymour/Matroid/Notions/Circuit.lean", "module": "Seymour.Matroid.Notions.Circuit", "jsonFile": "Seymour.Matroid.Notions.Circuit.jsonl", "positionMetadata": {"lineInFile": 43, "tokenPositionInFile": 1683, "theoremPositionInFile": 7}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 13}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  by_contra! C_empty\n  rw [C_empty] at hC\n  exact hC.not_empty", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 68}}
{"srcContext": "import Mathlib.LinearAlgebra.Matrix.Determinant.TotallyUnimodular\nimport Seymour.ForMathlib.Basic\nimport Seymour.ForMathlib.FunctionDecompose\n\n\nvariable {X\u2081 X\u2082 Z R : Type}\n\nlemma Matrix.IsTotallyUnimodular.comp_rows [CommRing R] {A : Matrix X\u2081 X\u2082 R}\n    (hA : A.IsTotallyUnimodular) (e : Z \u2192 X\u2081) :\n    Matrix.IsTotallyUnimodular (A \u2218 e) := by\n  rw [Matrix.isTotallyUnimodular_iff] at hA \u22a2\n  intro k f g\n  exact hA k (e \u2218 f) g\n\n", "theoremStatement": "lemma Matrix.IsTotallyUnimodular.comp_cols [CommRing R] {A : Matrix X\u2081 X\u2082 R}\n    (hA : A.IsTotallyUnimodular) (e : Z \u2192 X\u2082) :\n    Matrix.IsTotallyUnimodular (A \u00b7 \u2218 e) ", "theoremName": "Matrix.IsTotallyUnimodular.comp_cols", "fileCreated": {"commit": "0d6d3e28dde67309db0ac43d0d4fd6f74f500560", "date": "2024-11-03"}, "theoremCreated": {"commit": "d168101cdc0e5416bc0db8fd409e3a139171eed4", "date": "2024-12-20"}, "file": "Seymour/Seymour/ForMathlib/MatrixTU.lean", "module": "Seymour.ForMathlib.MatrixTU", "jsonFile": "Seymour.ForMathlib.MatrixTU.jsonl", "positionMetadata": {"lineInFile": 15, "tokenPositionInFile": 427, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 39}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [Matrix.isTotallyUnimodular_iff] at hA \u22a2\n  intro k f g\n  exact hA k f (e \u2218 g)", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 88}}
{"srcContext": "import Seymour.Matroid.Operations.MatrixSums.BinaryMatroids\n\n/-!\nThis file contains everything about 3-sum of binary matroids \u2014 the old version (in terms of explicit matrices).\n-/\n\nvariable {\u03b1 : Type}\n\n/-- `Matrix`-level 3-sum for matroids defined by their standard representation matrices; does not check legitimacy. -/\nnoncomputable abbrev Matrix_3sumComposition {\u03b2 : Type} [CommRing \u03b2] {X\u2081 Y\u2081 X\u2082 Y\u2082 : Set \u03b1}\n    (A\u2081 : Matrix X\u2081 (Y\u2081 \u2295 Fin 2) \u03b2) (A\u2082 : Matrix (Fin 2 \u2295 X\u2082) Y\u2082 \u03b2)\n    (z\u2081 : Y\u2081 \u2192 \u03b2) (z\u2082 : X\u2082 \u2192 \u03b2) (D : Matrix (Fin 2) (Fin 2) \u03b2) (D\u2081 : Matrix (Fin 2) Y\u2081 \u03b2) (D\u2082 : Matrix X\u2082 (Fin 2) \u03b2) :\n    Matrix ((X\u2081 \u2295 Unit) \u2295 (Fin 2 \u2295 X\u2082)) ((Y\u2081 \u2295 Fin 2) \u2295 (Unit \u2295 Y\u2082)) \u03b2 :=\n  -- Unfortunately `Ring.inverse` is `noncomputable` and upgrading `\u03b2` to `Field` does not help.\n  let D\u2081\u2082 : Matrix X\u2082 Y\u2081 \u03b2 := D\u2082 * D\u207b\u00b9 * D\u2081\n  Matrix.fromBlocks\n    (Matrix.fromRows A\u2081 (Matrix.row Unit (Sum.elim z\u2081 ![1, 1]))) 0\n    (Matrix.fromBlocks D\u2081 D D\u2081\u2082 D\u2082) (Matrix.fromCols (Matrix.col Unit (Sum.elim ![1, 1] z\u2082)) A\u2082)\n\nvariable [DecidableEq \u03b1] {M\u2081 M\u2082 : StandardRepresentation \u03b1}\n\n/-- `StandardRepresentation`-level 3-sum of two matroids.\nThe second part checks legitimacy (invertibility of a certain 2x2 submatrix and specific 1s and 0s on concrete positions). -/\nnoncomputable def StandardRepresentation_3sum {x\u2081 x\u2082 x\u2083 y\u2081 y\u2082 y\u2083 : \u03b1}\n    (hXX : M\u2081.X \u2229 M\u2082.X = {x\u2081, x\u2082, x\u2083}) (hYY : M\u2081.Y \u2229 M\u2082.Y = {y\u2081, y\u2082, y\u2083}) (hXY : M\u2081.X \u2ad7 M\u2082.Y) (hYX : M\u2081.Y \u2ad7 M\u2082.X) :\n    StandardRepresentation \u03b1 \u00d7 Prop :=\n  have hxxx\u2081 : {x\u2081, x\u2082, x\u2083} \u2286 M\u2081.X := hXX.symm.subset.trans Set.inter_subset_left\n  have hxxx\u2082 : {x\u2081, x\u2082, x\u2083} \u2286 M\u2082.X := hXX.symm.subset.trans Set.inter_subset_right\n  have hyyy\u2081 : {y\u2081, y\u2082, y\u2083} \u2286 M\u2081.Y := hYY.symm.subset.trans Set.inter_subset_left\n  have hyyy\u2082 : {y\u2081, y\u2082, y\u2083} \u2286 M\u2082.Y := hYY.symm.subset.trans Set.inter_subset_right\n  have x\u2081inX\u2081 : x\u2081 \u2208 M\u2081.X := hxxx\u2081 (Set.mem_insert x\u2081 {x\u2082, x\u2083})\n  have x\u2081inX\u2082 : x\u2081 \u2208 M\u2082.X := hxxx\u2082 (Set.mem_insert x\u2081 {x\u2082, x\u2083})\n  have x\u2082inX\u2081 : x\u2082 \u2208 M\u2081.X := hxxx\u2081 (Set.insert_comm x\u2081 x\u2082 {x\u2083} \u25b8 Set.mem_insert x\u2082 {x\u2081, x\u2083})\n  have x\u2082inX\u2082 : x\u2082 \u2208 M\u2082.X := hxxx\u2082 (Set.insert_comm x\u2081 x\u2082 {x\u2083} \u25b8 Set.mem_insert x\u2082 {x\u2081, x\u2083})\n  have x\u2083inX\u2081 : x\u2083 \u2208 M\u2081.X := hxxx\u2081 (by simp)\n  have x\u2083inX\u2082 : x\u2083 \u2208 M\u2082.X := hxxx\u2082 (by simp)\n  have y\u2083inY\u2081 : y\u2083 \u2208 M\u2081.Y := hyyy\u2081 (by simp)\n  have y\u2083inY\u2082 : y\u2083 \u2208 M\u2082.Y := hyyy\u2082 (by simp)\n  have y\u2082inY\u2081 : y\u2082 \u2208 M\u2081.Y := hyyy\u2081 (Set.insert_comm y\u2081 y\u2082 {y\u2083} \u25b8 Set.mem_insert y\u2082 {y\u2081, y\u2083})\n  have y\u2082inY\u2082 : y\u2082 \u2208 M\u2082.Y := hyyy\u2082 (Set.insert_comm y\u2081 y\u2082 {y\u2083} \u25b8 Set.mem_insert y\u2082 {y\u2081, y\u2083})\n  have y\u2081inY\u2081 : y\u2081 \u2208 M\u2081.Y := hyyy\u2081 (Set.mem_insert y\u2081 {y\u2082, y\u2083})\n  have y\u2081inY\u2082 : y\u2081 \u2208 M\u2082.Y := hyyy\u2082 (Set.mem_insert y\u2081 {y\u2082, y\u2083})\n  -- The actual definition starts here:\n  let A\u2081 : Matrix (M\u2081.X \\ {x\u2081, x\u2082, x\u2083}).Elem ((M\u2081.Y \\ {y\u2081, y\u2082, y\u2083}).Elem \u2295 Fin 2) Z2 := -- the top left submatrix\n    Matrix.of (fun i j => M\u2081.B\n        \u27e8i.val, Set.mem_of_mem_diff i.property\u27e9\n        (j.casesOn (fun j' => \u27e8j'.val, Set.mem_of_mem_diff j'.property\u27e9) ![\u27e8y\u2082, y\u2082inY\u2081\u27e9, \u27e8y\u2081, y\u2081inY\u2081\u27e9]))\n  let A\u2082 : Matrix (Fin 2 \u2295 (M\u2082.X \\ {x\u2081, x\u2082, x\u2083}).Elem) (M\u2082.Y \\ {y\u2081, y\u2082, y\u2083}).Elem Z2 := -- the bottom right submatrix\n    Matrix.of (fun i j => M\u2082.B\n        (i.casesOn ![\u27e8x\u2082, x\u2082inX\u2082\u27e9, \u27e8x\u2083, x\u2083inX\u2082\u27e9] (fun i' => \u27e8i'.val, Set.mem_of_mem_diff i'.property\u27e9))\n        \u27e8j.val, Set.mem_of_mem_diff j.property\u27e9)\n  let z\u2081 : (M\u2081.Y \\ {y\u2081, y\u2082, y\u2083}).Elem \u2192 Z2 := -- the middle left \"row vector\"\n    (fun j => M\u2081.B \u27e8x\u2081, x\u2081inX\u2081\u27e9 \u27e8j.val, Set.mem_of_mem_diff j.property\u27e9)\n  let z\u2082 : (M\u2082.X \\ {x\u2081, x\u2082, x\u2083}).Elem \u2192 Z2 := -- the bottom middle \"column vector\"\n    (fun i => M\u2082.B \u27e8i.val, Set.mem_of_mem_diff i.property\u27e9 \u27e8y\u2083, y\u2083inY\u2082\u27e9)\n  let D_\u2081 : Matrix (Fin 2) (Fin 2) Z2 := -- the bottom middle 2x2 submatrix\n    Matrix.of (fun i j => M\u2081.B (![\u27e8x\u2082, x\u2082inX\u2081\u27e9, \u27e8x\u2083, x\u2083inX\u2081\u27e9] i) (![\u27e8y\u2082, y\u2082inY\u2081\u27e9, \u27e8y\u2081, y\u2081inY\u2081\u27e9] j))\n  let D_\u2082 : Matrix (Fin 2) (Fin 2) Z2 := -- the middle left 2x2 submatrix\n    Matrix.of (fun i j => M\u2082.B (![\u27e8x\u2082, x\u2082inX\u2082\u27e9, \u27e8x\u2083, x\u2083inX\u2082\u27e9] i) (![\u27e8y\u2082, y\u2082inY\u2082\u27e9, \u27e8y\u2081, y\u2081inY\u2082\u27e9] j))\n  let D\u2081 : Matrix (Fin 2) (M\u2081.Y \\ {y\u2081, y\u2082, y\u2083}).Elem Z2 := -- the bottom left submatrix\n    Matrix.of (fun i j => M\u2081.B (![\u27e8x\u2082, x\u2082inX\u2081\u27e9, \u27e8x\u2083, x\u2083inX\u2081\u27e9] i) \u27e8j.val, Set.mem_of_mem_diff j.property\u27e9)\n  let D\u2082 : Matrix (M\u2082.X \\ {x\u2081, x\u2082, x\u2083}).Elem (Fin 2) Z2 := -- the bottom left submatrix\n    Matrix.of (fun i j => M\u2082.B \u27e8i.val, Set.mem_of_mem_diff i.property\u27e9 (![\u27e8y\u2082, y\u2082inY\u2082\u27e9, \u27e8y\u2081, y\u2081inY\u2082\u27e9] j))\n  \u27e8\n    \u27e8\n      (M\u2081.X \\ {x\u2081, x\u2082, x\u2083}) \u222a M\u2082.X,\n      M\u2081.Y \u222a (M\u2082.Y \\ {y\u2081, y\u2082, y\u2083}),\n      inferInstance,\n      inferInstance,\n      by\n        rw [Set.disjoint_union_right, Set.disjoint_union_left, Set.disjoint_union_left]\n        exact\n          \u27e8\u27e8M\u2081.hXY.disjoint_sdiff_left, hYX.symm\u27e9, \u27e8hXY.disjoint_sdiff_right.disjoint_sdiff_left, M\u2082.hXY.disjoint_sdiff_right\u27e9\u27e9,\n      Matrix.of (fun i j =>\n        Matrix_3sumComposition A\u2081 A\u2082 z\u2081 z\u2082 D_\u2081 D\u2081 D\u2082 (\n          if hi\u2081 : i.val \u2208 M\u2081.X \\ {x\u2081, x\u2082, x\u2083} then Sum.inl (Sum.inl \u27e8i, hi\u2081\u27e9) else\n          if hi\u2082 : i.val \u2208 M\u2082.X \\ {x\u2081, x\u2082, x\u2083} then Sum.inr (Sum.inr \u27e8i, hi\u2082\u27e9) else\n          if hx\u2081 : i.val = x\u2081 then Sum.inl (Sum.inr ()) else\n          if hx\u2082 : i.val = x\u2082 then Sum.inr (Sum.inl 0) else\n          if hx\u2083 : i.val = x\u2083 then Sum.inr (Sum.inl 1) else\n          (i.property.elim hi\u2081 (by simp_all)).elim\n          -- TODO can `Matrix.toMatrixUnionUnion` be combined with something else to simplify this definition?\n        ) (\n          if hj\u2081 : j.val \u2208 M\u2081.Y \\ {y\u2081, y\u2082, y\u2083} then Sum.inl (Sum.inl \u27e8j, hj\u2081\u27e9) else\n          if hj\u2082 : j.val \u2208 M\u2082.Y \\ {y\u2081, y\u2082, y\u2083} then Sum.inr (Sum.inr \u27e8j, hj\u2082\u27e9) else\n          if hy\u2081 : j.val = y\u2081 then Sum.inl (Sum.inr 1) else\n          if hy\u2082 : j.val = y\u2082 then Sum.inl (Sum.inr 0) else\n          if hy\u2083 : j.val = y\u2083 then Sum.inr (Sum.inl ()) else\n          (j.property.elim (by simp_all) hj\u2082).elim\n        )\n      )\n    \u27e9,\n    IsUnit D_\u2081 \u2227 D_\u2081 = D_\u2082 -- the matrix `D_\u2081 = D_\u2082` (called D-bar in the book) is invertible\n    \u2227 M\u2081.B \u27e8x\u2081, x\u2081inX\u2081\u27e9 \u27e8y\u2081, y\u2081inY\u2081\u27e9 = 1\n    \u2227 M\u2081.B \u27e8x\u2081, x\u2081inX\u2081\u27e9 \u27e8y\u2082, y\u2082inY\u2081\u27e9 = 1\n    \u2227 M\u2081.B \u27e8x\u2082, x\u2082inX\u2081\u27e9 \u27e8y\u2083, y\u2083inY\u2081\u27e9 = 1\n    \u2227 M\u2081.B \u27e8x\u2083, x\u2083inX\u2081\u27e9 \u27e8y\u2083, y\u2083inY\u2081\u27e9 = 1\n    \u2227 M\u2082.B \u27e8x\u2081, x\u2081inX\u2082\u27e9 \u27e8y\u2081, y\u2081inY\u2082\u27e9 = 1\n    \u2227 M\u2082.B \u27e8x\u2081, x\u2081inX\u2082\u27e9 \u27e8y\u2082, y\u2082inY\u2082\u27e9 = 1\n    \u2227 M\u2082.B \u27e8x\u2082, x\u2082inX\u2082\u27e9 \u27e8y\u2083, y\u2083inY\u2082\u27e9 = 1\n    \u2227 M\u2082.B \u27e8x\u2083, x\u2083inX\u2082\u27e9 \u27e8y\u2083, y\u2083inY\u2082\u27e9 = 1\n    \u2227 (\u2200 x : \u03b1, \u2200 hx : x \u2208 M\u2081.X, x \u2260 x\u2082 \u2227 x \u2260 x\u2083 \u2192 M\u2081.B \u27e8x, hx\u27e9 \u27e8y\u2083, y\u2083inY\u2081\u27e9 = 0) -- the rest of the rightmost column is `0`s\n    \u2227 (\u2200 y : \u03b1, \u2200 hy : y \u2208 M\u2082.Y, y \u2260 y\u2082 \u2227 y \u2260 y\u2081 \u2192 M\u2082.B \u27e8x\u2081, x\u2081inX\u2082\u27e9 \u27e8y, hy\u27e9 = 0) -- the rest of the topmost row is `0`s\n  \u27e9\n\n/-- Binary matroid `M` is a result of 3-summing `M\u2081` and `M\u2082` in some way. -/\ndef StandardRepresentation.Is3sumOf (M : StandardRepresentation \u03b1) (M\u2081 M\u2082 : StandardRepresentation \u03b1) : Prop :=\n  \u2203 x\u2081 x\u2082 x\u2083 y\u2081 y\u2082 y\u2083 : \u03b1,\n    \u2203 hXX : M\u2081.X \u2229 M\u2082.X = {x\u2081, x\u2082, x\u2083}, \u2203 hYY : M\u2081.Y \u2229 M\u2082.Y = {y\u2081, y\u2082, y\u2083}, \u2203 hXY : M\u2081.X \u2ad7 M\u2082.Y, \u2203 hYX : M\u2081.Y \u2ad7 M\u2082.X,\n      let M\u2080 := StandardRepresentation_3sum hXX hYY hXY hYX\n      M.toMatroid = M\u2080.fst.toMatroid \u2227 M\u2080.snd\n\nvariable {M : StandardRepresentation \u03b1}\n\n-- API for access to individual assumptions and identities in the definition of 3-sum\n\n", "theoremStatement": "lemma StandardRepresentation.Is3sumOf.interXX (hM : M.Is3sumOf M\u2081 M\u2082) :\n    \u2203 x\u2081 x\u2082 x\u2083 : \u03b1, M\u2081.X \u2229 M\u2082.X = {x\u2081, x\u2082, x\u2083} ", "theoremName": "StandardRepresentation.Is3sumOf.interXX", "fileCreated": {"commit": "614ecc7fe89749171933326a0f077e8d8a24cecb", "date": "2025-02-03"}, "theoremCreated": {"commit": "74722a3f54befb275eb7729e168db1478932de5e", "date": "2024-12-05"}, "file": "Seymour/Seymour/Matroid/Operations/MatrixSums/Sum3.lean", "module": "Seymour.Matroid.Operations.MatrixSums.Sum3", "jsonFile": "Seymour.Matroid.Operations.MatrixSums.Sum3.jsonl", "positionMetadata": {"lineInFile": 117, "tokenPositionInFile": 6930, "theoremPositionInFile": 3}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 6, "numPremises": 33}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  obtain \u27e8x\u2081, x\u2082, x\u2083, -, -, -, hXX, -\u27e9 := hM\n  exact \u27e8x\u2081, x\u2082, x\u2083, hXX\u27e9", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 76}}
{"srcContext": "import Seymour.Matroid.Operations.SumDelta.Basic\nimport Seymour.ForMathlib.SetTheory\n\nset_option linter.unusedVariables false\n\nvariable {\u03b1 : Type} [DecidableEq \u03b1]\n\n\nsection Basic\n\n/-- Nonempty union of disjoint circuits of `M\u2081` satisfies circuit form of `M\u2081 \u0394 M\u2082`  -/\nlemma deltaSumCircuitForm_left {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : C.Nonempty) (hCE : C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)) (hCM\u2081 : M\u2081.toMatroid.IsUnionDisjointCircuits C) :\n    DeltaSumCircuitForm M\u2081 M\u2082 C :=\n  \u27e8hC, hCE, C, \u2205, by simp, hCM\u2081, M\u2082.toMatroid.emptyUnionDisjointCircuits\u27e9\n\n/-- Nonempty union of disjoint circuits of `M\u2082` satisfies circuit form of `M\u2081 \u0394 M\u2082`  -/\nlemma deltaSumCircuitForm_right {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : C.Nonempty) (hCE : C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)) (hCM\u2082 : M\u2082.toMatroid.IsUnionDisjointCircuits C) :\n    DeltaSumCircuitForm M\u2081 M\u2082 C :=\n  \u27e8hC, hCE, \u2205, C, by simp, M\u2081.toMatroid.emptyUnionDisjointCircuits, hCM\u2082\u27e9\n\nend Basic\n\n\nsection CircuitForm1\n\n/-- Form 1 of circuits in `M\u2081 \u0394 M\u2082`: circuits of `M\u2081` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef DeltaSumCircuitForm1 (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.toMatroid.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Circuit of form 1 is a circuit in `M\u2081` -/\nlemma DeltaSumCircuitForm1.circuit_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    M\u2081.toMatroid.Circuit C :=\n  hC.left\n\n/-- Circuit of form 1 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm1.disjoint_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of form 1 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma DeltaSumCircuitForm1.subset_union {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_left hC.circuit_M\u2081.subset_ground M\u2082.E\n\n/-- Circuit of form 1 lies in ground set of `M\u2081 \u0394 M\u2082` -/\nlemma DeltaSumCircuitForm1.subset_ground {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of form 1 lies in `M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma DeltaSumCircuitForm1.subset_M\u2081_diff_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2286 M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2081.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of form 1 is disjoint with `M\u2082.E` -/\nlemma DeltaSumCircuitForm1.disjoint_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2ad7 M\u2082.E := by\n  have hMM := diff_inter_disjoint_diff_inter M\u2081.E M\u2082.E\n  have hCM\u2082 := Set.disjoint_of_subset_left hC.subset_M\u2081_diff_inter hMM\n  have hCM\u2082 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2082, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_right] at hCM\u2082\n  exact hCM\u2082\n\n/-- Circuit of form 1 satisfies circuit form of `M\u2081 \u0394 M\u2082` -/\nlemma DeltaSumCircuitForm1.circuit_form {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    DeltaSumCircuitForm M\u2081 M\u2082 C :=\n  deltaSumCircuitForm_left hC.circuit_M\u2081.nonempty hC.subset_ground hC.circuit_M\u2081.isUnionDisjointCircuits\n\n/-- If `C` satisfies circuit predicate and is a union of disjoint circuits of `M\u2081`, then `C` is a circuit of `M\u2081` -/\nlemma DeltaSumCircuitPred.udc_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (C_pred : DeltaSumCircuitPred M\u2081 M\u2082 C) (C_udc : M\u2081.toMatroid.IsUnionDisjointCircuits C) :\n    M\u2081.toMatroid.Circuit C :=\n  have \u27e8\u27e8hC, hCE, _\u27e9, hCmin\u27e9 := C_pred\n  \u27e8C_udc.nonempty_dep hC, fun D hD hDC =>\n    have \u27e8_, D', hD', hDD'\u27e9 := M\u2081.toMatroid.dep_iff_has_circuit.\u2192 hD\n    (hCmin\n        (DeltaSumCircuitForm1.circuit_form \u27e8hD', (Set.subset_diff.\u2192 ((hDD'.trans hDC).trans hCE)).right\u27e9)\n        (hDD'.trans hDC)\n      ).trans hDD'\u27e9\n\nend CircuitForm1\n\n\nsection CircuitForm2\n\n/-- Form 2 of circuits in `M\u2081 \u0394 M\u2082`: circuits of `M\u2082` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef DeltaSumCircuitForm2 (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2082.toMatroid.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Circuit of form 2 is a circuit in `M\u2081` -/\nlemma DeltaSumCircuitForm2.circuit_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    M\u2082.toMatroid.Circuit C :=\n  hC.left\n\n/-- Circuit of form 2 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm2.disjoint_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of form 2 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma DeltaSumCircuitForm2.subset_union {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_right hC.circuit_M\u2082.subset_ground M\u2081.E\n\n/-- Circuit of form 2 lies in ground set of `M\u2081 \u0394 M\u2082` -/\nlemma DeltaSumCircuitForm2.subset_ground {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of form 2 lies in `M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma DeltaSumCircuitForm2.subset_M\u2082_diff_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2286 M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2082.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of form 2 is disjoint with `M\u2082.E` -/\nlemma DeltaSumCircuitForm2.disjoint_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2ad7 M\u2081.E := by\n  have hMM := diff_inter_disjoint_diff_inter M\u2081.E M\u2082.E\n  have hCM\u2082 := Set.disjoint_of_subset_right hC.subset_M\u2082_diff_inter hMM\n  have hCM\u2082 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2082.symm, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_left] at hCM\u2082\n  exact hCM\u2082\n\n/-- Circuit of form 2 satisfies circuit form of `M\u2081 \u0394 M\u2082` -/\nlemma DeltaSumCircuitForm2.circuit_form {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    DeltaSumCircuitForm M\u2081 M\u2082 C :=\n  deltaSumCircuitForm_right hC.circuit_M\u2082.nonempty hC.subset_ground hC.circuit_M\u2082.isUnionDisjointCircuits\n\n/-- If `C` satisfies circuit predicate and is a union of disjoint circuits of `M\u2082`, then `C` is a circuit of `M\u2082` -/\nlemma DeltaSumCircuitPred.udc_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hCpred : DeltaSumCircuitPred M\u2081 M\u2082 C) (hCudc : M\u2082.toMatroid.IsUnionDisjointCircuits C) :\n    M\u2082.toMatroid.Circuit C :=\n  have \u27e8\u27e8C_nempty, hCE, _\u27e9, hCmin\u27e9 := hCpred\n  \u27e8hCudc.nonempty_dep C_nempty, fun D hD hDC =>\n    have \u27e8_, D', hD', hDD'\u27e9 := M\u2082.toMatroid.dep_iff_has_circuit.\u2192 hD\n    (hCmin\n        (DeltaSumCircuitForm2.circuit_form \u27e8hD', (Set.subset_diff.\u2192 ((hDD'.trans hDC).trans hCE)).right\u27e9)\n        (hDD'.trans hDC)\n      ).trans hDD'\u27e9\n\nend CircuitForm2\n\n\nsection CircuitForm3\n\n/-- Form 3 of circuits in `M\u2081 \u0394 M\u2082`:\n    sets `C\u2081 \u0394 C\u2082` where `C\u2081` and `C\u2082` are circuits in `M\u2081` and `M\u2082`, respectively,\n    with `C\u2081 \u2229 (M\u2081.E \u2229 M\u2082.E)` and `C\u2082 \u2229 (M\u2081.E \u2229 M\u2082.E)` being the same one-element set.\n    Here we use equivalent definition by denoting `p` the single element in `C\u2081 \u2229 C\u2082` and\n    expressing `C\u2081` and `C\u2082` via `p`, `C`, and ground sets of `M\u2081` and `M\u2082`. -/\ndef DeltaSumCircuitForm3 (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C : Set \u03b1) (p : \u03b1) : Prop :=\n  M\u2081.toMatroid.Circuit ((C \u2229 M\u2081.E) \u222a {p}) \u2227\n  M\u2082.toMatroid.Circuit ((C \u2229 M\u2082.E) \u222a {p}) \u2227\n  C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)\n\n/-- Existential version of form 3 of circuits -/\ndef IsDeltaSumCircuitForm3 (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C : Set \u03b1) : Prop :=\n  \u2203 p \u2208 M\u2081.E \u2229 M\u2082.E, DeltaSumCircuitForm3 M\u2081 M\u2082 C p\n\nvariable {C : Set \u03b1} {p : \u03b1}\n\n/-- Circuit of form 3 yields a circuit in `M\u2081` after intersecting it with `M\u2081.E` and adding `p` -/\ndef DeltaSumCircuitForm3.to_circuit_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    M\u2081.toMatroid.Circuit ((C \u2229 M\u2081.E) \u222a {p}) :=\n  hC.left\n\n/-- Circuit of form 3 yields a circuit in `M\u2082` after intersecting it with `M\u2081.E` and adding `p` -/\ndef DeltaSumCircuitForm3.to_circuit_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    M\u2082.toMatroid.Circuit ((C \u2229 M\u2082.E) \u222a {p}) :=\n  hC.right.left\n\n/-- Circuit of form 3 is subset of ground set of `M\u2081 \u0394 M\u2082` -/\ndef DeltaSumCircuitForm3.subset_ground {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E) :=\n  hC.right.right\n\n/-- Singleton element in definition of circuit form 3 lies in `M\u2081.E` -/\nlemma DeltaSumCircuitForm3.singleton_subset_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    {p} \u2286 M\u2081.E :=\n  (Set.union_subset_iff.\u2192 hC.to_circuit_M\u2081.subset_ground).right\n\n/-- Singleton element in definition of circuit form 3 lies in `M\u2082.E` -/\nlemma DeltaSumCircuitForm3.singleton_subset_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    {p} \u2286 M\u2082.E :=\n  (Set.union_subset_iff.\u2192 hC.to_circuit_M\u2082.subset_ground).right\n\n/-- Singleton element in definition of circuit form 3 lies in `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm3.singleton_subset_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    {p} \u2286 M\u2081.E \u2229 M\u2082.E :=\n  Set.subset_inter hC.singleton_subset_M\u2081 hC.singleton_subset_M\u2082\n\n/-- Circuit of form 3 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma DeltaSumCircuitForm3.subset_union {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    C \u2286 M\u2081.E \u222a M\u2082.E :=\n  sub_union_diff_sub_union hC.subset_ground\n\n/-- Circuit of form 3 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm3.disjoint_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  Set.disjoint_of_subset_left hC.subset_ground Set.disjoint_sdiff_left\n\n/-- Circuit of form 3 intersected with `M\u2081.E` is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm3.disjoint_inter_M\u2081_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    C \u2229 M\u2081.E \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.disjoint_inter.inter_left M\u2081.E\n\n/-- Circuit of form 3 intersected with `M\u2081.E` is disjoint with `M\u2082.E` -/\nlemma DeltaSumCircuitForm3.disjoint_inter_M\u2081_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    C \u2229 M\u2081.E \u2ad7 M\u2082.E := by\n  rw [Set.disjoint_iff_inter_eq_empty, Set.inter_assoc, \u2190Set.disjoint_iff_inter_eq_empty]\n  exact hC.disjoint_inter\n\n", "theoremStatement": "/-- Circuit of form 3 intersected with `M\u2081.E` is disjoint with its intersection with `M\u2082.E` -/\nlemma DeltaSumCircuitForm3.disjoint_inter_M\u2081_inter_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    C \u2229 M\u2081.E \u2ad7 C \u2229 M\u2082.E ", "theoremName": "DeltaSumCircuitForm3.disjoint_inter_M\u2081_inter_M\u2082", "fileCreated": {"commit": "aae07a69b2ec95e3d9a1436952a123dcb7d0d06f", "date": "2025-01-03"}, "theoremCreated": {"commit": "67629d2b74be7b972786897531b678f585a7af28", "date": "2025-02-03"}, "file": "Seymour/Seymour/Matroid/Operations/SumDelta/CircuitForms.lean", "module": "Seymour.Matroid.Operations.SumDelta.CircuitForms", "jsonFile": "Seymour.Matroid.Operations.SumDelta.CircuitForms.jsonl", "positionMetadata": {"lineInFile": 239, "tokenPositionInFile": 10271, "theoremPositionInFile": 32}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 5, "numPremises": 21}, "proofMetadata": {"hasProof": true, "proof": ":=\n  Set.disjoint_of_subset_right Set.inter_subset_right hC.disjoint_inter_M\u2081_M\u2082", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 80}}
{"srcContext": "import Mathlib.Data.Set.SymmDiff\nimport Mathlib.Order.CompletePartialOrder\nimport Mathlib.Order.Disjoint\nimport Mathlib.Order.SymmDiff\nimport Mathlib.Tactic\n\nimport Seymour.Basic\n\n/-!\nThis provides lemmas about sets (mostly dealing with disjointness) that are missing in Mathlib.\n-/\n\nvariable {\u03b1 : Type}\n\nsection Other\n\n", "theoremStatement": "lemma set_union_union_eq_rev (X Y Z : Set \u03b1) : X \u222a Y \u222a Z = Z \u222a Y \u222a X ", "theoremName": "set_union_union_eq_rev", "fileCreated": {"commit": "b44bff2f1ee71349fa9fa251579a0f5a0e575538", "date": "2024-12-19"}, "theoremCreated": {"commit": "d0eaaa305c96cd81ac061f505a81614db6856b21", "date": "2025-01-09"}, "file": "Seymour/Seymour/ForMathlib/SetTheory.lean", "module": "Seymour.ForMathlib.SetTheory", "jsonFile": "Seymour.ForMathlib.SetTheory.jsonl", "positionMetadata": {"lineInFile": 17, "tokenPositionInFile": 320, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 10}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [Set.union_assoc, Set.union_comm, Set.union_comm Y Z]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 64}}
{"srcContext": "import Seymour.Matroid.Operations.SumDelta.Basic\nimport Seymour.ForMathlib.SetTheory\n\nset_option linter.unusedVariables false\n\nvariable {\u03b1 : Type} [DecidableEq \u03b1]\n\n\nsection Basic\n\n/-- Nonempty union of disjoint circuits of `M\u2081` satisfies circuit form of `M\u2081 \u0394 M\u2082`  -/\nlemma deltaSumCircuitForm_left {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : C.Nonempty) (hCE : C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)) (hCM\u2081 : M\u2081.toMatroid.IsUnionDisjointCircuits C) :\n    DeltaSumCircuitForm M\u2081 M\u2082 C :=\n  \u27e8hC, hCE, C, \u2205, by simp, hCM\u2081, M\u2082.toMatroid.emptyUnionDisjointCircuits\u27e9\n\n/-- Nonempty union of disjoint circuits of `M\u2082` satisfies circuit form of `M\u2081 \u0394 M\u2082`  -/\nlemma deltaSumCircuitForm_right {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : C.Nonempty) (hCE : C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)) (hCM\u2082 : M\u2082.toMatroid.IsUnionDisjointCircuits C) :\n    DeltaSumCircuitForm M\u2081 M\u2082 C :=\n  \u27e8hC, hCE, \u2205, C, by simp, M\u2081.toMatroid.emptyUnionDisjointCircuits, hCM\u2082\u27e9\n\nend Basic\n\n\nsection CircuitForm1\n\n/-- Form 1 of circuits in `M\u2081 \u0394 M\u2082`: circuits of `M\u2081` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef DeltaSumCircuitForm1 (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.toMatroid.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Circuit of form 1 is a circuit in `M\u2081` -/\nlemma DeltaSumCircuitForm1.circuit_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    M\u2081.toMatroid.Circuit C :=\n  hC.left\n\n/-- Circuit of form 1 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm1.disjoint_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of form 1 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma DeltaSumCircuitForm1.subset_union {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_left hC.circuit_M\u2081.subset_ground M\u2082.E\n\n/-- Circuit of form 1 lies in ground set of `M\u2081 \u0394 M\u2082` -/\nlemma DeltaSumCircuitForm1.subset_ground {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of form 1 lies in `M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma DeltaSumCircuitForm1.subset_M\u2081_diff_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2286 M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2081.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of form 1 is disjoint with `M\u2082.E` -/\nlemma DeltaSumCircuitForm1.disjoint_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2ad7 M\u2082.E := by\n  have hMM := diff_inter_disjoint_diff_inter M\u2081.E M\u2082.E\n  have hCM\u2082 := Set.disjoint_of_subset_left hC.subset_M\u2081_diff_inter hMM\n  have hCM\u2082 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2082, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_right] at hCM\u2082\n  exact hCM\u2082\n\n/-- Circuit of form 1 satisfies circuit form of `M\u2081 \u0394 M\u2082` -/\nlemma DeltaSumCircuitForm1.circuit_form {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    DeltaSumCircuitForm M\u2081 M\u2082 C :=\n  deltaSumCircuitForm_left hC.circuit_M\u2081.nonempty hC.subset_ground hC.circuit_M\u2081.isUnionDisjointCircuits\n\n/-- If `C` satisfies circuit predicate and is a union of disjoint circuits of `M\u2081`, then `C` is a circuit of `M\u2081` -/\nlemma DeltaSumCircuitPred.udc_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (C_pred : DeltaSumCircuitPred M\u2081 M\u2082 C) (C_udc : M\u2081.toMatroid.IsUnionDisjointCircuits C) :\n    M\u2081.toMatroid.Circuit C :=\n  have \u27e8\u27e8hC, hCE, _\u27e9, hCmin\u27e9 := C_pred\n  \u27e8C_udc.nonempty_dep hC, fun D hD hDC =>\n    have \u27e8_, D', hD', hDD'\u27e9 := M\u2081.toMatroid.dep_iff_has_circuit.\u2192 hD\n    (hCmin\n        (DeltaSumCircuitForm1.circuit_form \u27e8hD', (Set.subset_diff.\u2192 ((hDD'.trans hDC).trans hCE)).right\u27e9)\n        (hDD'.trans hDC)\n      ).trans hDD'\u27e9\n\nend CircuitForm1\n\n\nsection CircuitForm2\n\n/-- Form 2 of circuits in `M\u2081 \u0394 M\u2082`: circuits of `M\u2082` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef DeltaSumCircuitForm2 (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2082.toMatroid.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Circuit of form 2 is a circuit in `M\u2081` -/\nlemma DeltaSumCircuitForm2.circuit_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    M\u2082.toMatroid.Circuit C :=\n  hC.left\n\n/-- Circuit of form 2 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm2.disjoint_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of form 2 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma DeltaSumCircuitForm2.subset_union {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_right hC.circuit_M\u2082.subset_ground M\u2081.E\n\n/-- Circuit of form 2 lies in ground set of `M\u2081 \u0394 M\u2082` -/\nlemma DeltaSumCircuitForm2.subset_ground {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of form 2 lies in `M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma DeltaSumCircuitForm2.subset_M\u2082_diff_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2286 M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2082.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of form 2 is disjoint with `M\u2082.E` -/\nlemma DeltaSumCircuitForm2.disjoint_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2ad7 M\u2081.E := by\n  have hMM := diff_inter_disjoint_diff_inter M\u2081.E M\u2082.E\n  have hCM\u2082 := Set.disjoint_of_subset_right hC.subset_M\u2082_diff_inter hMM\n  have hCM\u2082 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2082.symm, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_left] at hCM\u2082\n  exact hCM\u2082\n\n/-- Circuit of form 2 satisfies circuit form of `M\u2081 \u0394 M\u2082` -/\nlemma DeltaSumCircuitForm2.circuit_form {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    DeltaSumCircuitForm M\u2081 M\u2082 C :=\n  deltaSumCircuitForm_right hC.circuit_M\u2082.nonempty hC.subset_ground hC.circuit_M\u2082.isUnionDisjointCircuits\n\n/-- If `C` satisfies circuit predicate and is a union of disjoint circuits of `M\u2082`, then `C` is a circuit of `M\u2082` -/\nlemma DeltaSumCircuitPred.udc_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hCpred : DeltaSumCircuitPred M\u2081 M\u2082 C) (hCudc : M\u2082.toMatroid.IsUnionDisjointCircuits C) :\n    M\u2082.toMatroid.Circuit C :=\n  have \u27e8\u27e8C_nempty, hCE, _\u27e9, hCmin\u27e9 := hCpred\n  \u27e8hCudc.nonempty_dep C_nempty, fun D hD hDC =>\n    have \u27e8_, D', hD', hDD'\u27e9 := M\u2082.toMatroid.dep_iff_has_circuit.\u2192 hD\n    (hCmin\n        (DeltaSumCircuitForm2.circuit_form \u27e8hD', (Set.subset_diff.\u2192 ((hDD'.trans hDC).trans hCE)).right\u27e9)\n        (hDD'.trans hDC)\n      ).trans hDD'\u27e9\n\nend CircuitForm2\n\n\nsection CircuitForm3\n\n/-- Form 3 of circuits in `M\u2081 \u0394 M\u2082`:\n    sets `C\u2081 \u0394 C\u2082` where `C\u2081` and `C\u2082` are circuits in `M\u2081` and `M\u2082`, respectively,\n    with `C\u2081 \u2229 (M\u2081.E \u2229 M\u2082.E)` and `C\u2082 \u2229 (M\u2081.E \u2229 M\u2082.E)` being the same one-element set.\n    Here we use equivalent definition by denoting `p` the single element in `C\u2081 \u2229 C\u2082` and\n    expressing `C\u2081` and `C\u2082` via `p`, `C`, and ground sets of `M\u2081` and `M\u2082`. -/\ndef DeltaSumCircuitForm3 (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C : Set \u03b1) (p : \u03b1) : Prop :=\n  M\u2081.toMatroid.Circuit ((C \u2229 M\u2081.E) \u222a {p}) \u2227\n  M\u2082.toMatroid.Circuit ((C \u2229 M\u2082.E) \u222a {p}) \u2227\n  C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)\n\n/-- Existential version of form 3 of circuits -/\ndef IsDeltaSumCircuitForm3 (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C : Set \u03b1) : Prop :=\n  \u2203 p \u2208 M\u2081.E \u2229 M\u2082.E, DeltaSumCircuitForm3 M\u2081 M\u2082 C p\n\nvariable {C : Set \u03b1} {p : \u03b1}\n\n/-- Circuit of form 3 yields a circuit in `M\u2081` after intersecting it with `M\u2081.E` and adding `p` -/\ndef DeltaSumCircuitForm3.to_circuit_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    M\u2081.toMatroid.Circuit ((C \u2229 M\u2081.E) \u222a {p}) :=\n  hC.left\n\n/-- Circuit of form 3 yields a circuit in `M\u2082` after intersecting it with `M\u2081.E` and adding `p` -/\ndef DeltaSumCircuitForm3.to_circuit_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    M\u2082.toMatroid.Circuit ((C \u2229 M\u2082.E) \u222a {p}) :=\n  hC.right.left\n\n/-- Circuit of form 3 is subset of ground set of `M\u2081 \u0394 M\u2082` -/\ndef DeltaSumCircuitForm3.subset_ground {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E) :=\n  hC.right.right\n\n", "theoremStatement": "/-- Singleton element in definition of circuit form 3 lies in `M\u2081.E` -/\nlemma DeltaSumCircuitForm3.singleton_subset_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    {p} \u2286 M\u2081.E ", "theoremName": "DeltaSumCircuitForm3.singleton_subset_M\u2081", "fileCreated": {"commit": "aae07a69b2ec95e3d9a1436952a123dcb7d0d06f", "date": "2025-01-03"}, "theoremCreated": {"commit": "67629d2b74be7b972786897531b678f585a7af28", "date": "2025-02-03"}, "file": "Seymour/Seymour/Matroid/Operations/SumDelta/CircuitForms.lean", "module": "Seymour.Matroid.Operations.SumDelta.CircuitForms", "jsonFile": "Seymour.Matroid.Operations.SumDelta.CircuitForms.jsonl", "positionMetadata": {"lineInFile": 196, "tokenPositionInFile": 8347, "theoremPositionInFile": 25}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 7, "numPremises": 30}, "proofMetadata": {"hasProof": true, "proof": ":=\n  (Set.union_subset_iff.\u2192 hC.to_circuit_M\u2081.subset_ground).right", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 66}}
{"srcContext": "import Mathlib.Data.Matroid.Closure\nimport Seymour.Basic\n\n-- we should use https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Data/Matroid/Circuit.lean instead\n\nvariable {\u03b1 : Type}\n\n/-- Circuit is minimal dependent subset. -/\ndef Matroid.Circuit (M : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  Minimal M.Dep C\n\n/-- Every circuit is dependent. -/\nlemma Matroid.Circuit.dep (M : Matroid \u03b1) {C : Set \u03b1} (hC : M.Circuit C) : M.Dep C :=\n  hC.left\n\n/-- Every circuit is a subset of the ground set. -/\nlemma Matroid.Circuit.subset_ground (M : Matroid \u03b1) {C : Set \u03b1} (hC : M.Circuit C) : C \u2286 M.E :=\n  hC.left.right\n\n/-- Equivalence with explicit definition of circuits. -/\nlemma Matroid.circuit_iff_def (M : Matroid \u03b1) (C : Set \u03b1) :\n    M.Circuit C \u2194 M.Dep C \u2227 \u2200 C' : Set \u03b1, M.Dep C' \u2192 C' \u2286 C \u2192 C \u2286 C' :=\n  rfl.to_iff\n\n/-- Every strict subset of a circuit is independent. -/\nlemma Matroid.Circuit.indep_ssub {M : Matroid \u03b1} {C C' : Set \u03b1} (hC : M.Circuit C) (hC' : C' \u2282 C) :\n    M.Indep C' := by\n  by_contra notIndep_M_C'\n  have C'_sub_C : C' \u2286 C := subset_of_ssubset hC'\n  have C_sub_E : C \u2286 M.E := hC.subset_ground\n  have C'_sub_E : C' \u2286 M.E := hC'.subset.trans C_sub_E\n  exact hC'.ne.symm ((hC.right (M.dep_of_not_indep notIndep_M_C' C'_sub_E) C'_sub_C).antisymm C'_sub_C)\n\n/-- Deleting one element from a circuit produces an independent set. -/\nlemma Matroid.Circuit.indep_diff_singleton {M : Matroid \u03b1} {C : Set \u03b1} {a : \u03b1} (hC : M.Circuit C) (ha : a \u2208 C) :\n    M.Indep (C \\ {a}) :=\n  hC.indep_ssub (Set.diff_singleton_sSubset.\u2190 ha)\n\n/-- Empty set is not a circuit. -/\nlemma Matroid.Circuit.not_empty {M : Matroid \u03b1} (hM : M.Circuit \u2205) : False :=\n  hM.left.left M.empty_indep\n\n/-- Every circuit is nonempty. -/\nlemma Matroid.Circuit.nonempty {M : Matroid \u03b1} {C : Set \u03b1} (hC : M.Circuit C) : C.Nonempty := by\n  by_contra! C_empty\n  rw [C_empty] at hC\n  exact hC.not_empty\n\n/-- Independent set is not a circuit. -/\nlemma Matroid.Indep.not_circuit {M : Matroid \u03b1} {I : Set \u03b1} (hI : M.Indep I) : \u00ac(M.Circuit I) :=\n  (\u00b7.left.left hI)\n\n/-- No circuit is a subset of another circuit -/\nlemma Matroid.Circuit.not_ssubset_circuit {M : Matroid \u03b1} {C C' : Set \u03b1} (hC : M.Circuit C) (hC' : M.Circuit C') :\n    \u00ac(C \u2282 C') :=\n  fun hCC => hCC.right (hC'.right hC.left hCC.subset)\n\n/-- Strict subset of a circuit is not a circuit. -/\nlemma Matroid.Circuit.ssubset_not_circuit {M : Matroid \u03b1} {C C' : Set \u03b1} (hC : M.Circuit C) (hC' : C' \u2282 C) :\n    \u00ac(M.Circuit C') :=\n  (\u00b7.not_ssubset_circuit hC hC')\n\n/-- A set is dependent iff it is grounded and contains a circuit. -/\nlemma Matroid.dep_iff_has_circuit (M : Matroid \u03b1) {D : Set \u03b1} :\n    M.Dep D \u2194 D \u2286 M.E \u2227 \u2203 C : Set \u03b1, M.Circuit C \u2227 C \u2286 D := by\n  constructor\n  \u00b7 intro \u27e8hMD, hDE\u27e9\n    refine \u27e8hDE, ?_\u27e9\n    -- Source: https://github.com/apnelson1/Matroid/blob/1c75a026d1ea5162210ec53d0204d5900098b31c/Matroid/Circuit.lean#L300\n    rw [Matroid.indep_iff_forall_not_mem_closure_diff] at hMD\n    push_neg at hMD\n    obtain \u27e8a, haD, haM\u27e9 := hMD\n    obtain \u27e8B, hBDa\u27e9 := M.exists_basis (D \\ {a}) (Set.diff_subset.trans hDE)\n    rw [\u2190hBDa.closure_eq_closure] at haM\n    obtain \u27e8hDaB, hDaE\u27e9 := hBDa\n    -- `B` is the maximal independent subset of `D \\ {a}`\n    use D\n    constructor\n    \u00b7 sorry -- Can we finish the proof the same way Peter Nelson did?\n    \u00b7 rfl\n  \u00b7 intro \u27e8hDE, C, hMC, hCD\u27e9\n    obtain \u27e8hMC, hCE\u27e9 := Matroid.dep_iff.\u2192 hMC.dep\n    exact \u27e8(hMC <| \u00b7.subset hCD), hDE\u27e9\n\n/-- todo: desc -/\nlemma Matroid.Indep.circuit_of_insert_dep {M : Matroid \u03b1} {I : Set \u03b1} (hI : M.Indep I) {a : \u03b1} (hIa : M.Dep (a \u1543 I)) :\n    \u2203 C : Set \u03b1, M.Circuit C \u2227 C \u2286 a \u1543 I \u2227 a \u2208 C := by\n  obtain \u27e8-, C, hC, hCIa\u27e9 := M.dep_iff_has_circuit.\u2192 hIa\n  exact \u27e8C, hC, hCIa, by\n    by_contra haC\n    exact hC.left.left (hI.subset ((Set.disjoint_singleton_right.\u2190 haC).subset_right_of_subset_union hCIa))\n  \u27e9\n\n/-- If two matroids have the same ground sets and sets of circuits, then they are equal. -/\ntheorem Matroid.ext_circuit {M\u2081 M\u2082 : Matroid \u03b1} (hE : M\u2081.E = M\u2082.E) (hC : \u2200 C \u2286 M\u2081.E, M\u2081.Circuit C \u2194 M\u2082.Circuit C) :\n    M\u2081 = M\u2082 := by\n  apply Matroid.ext_indep hE\n  intro I hI\u2081\n  have hI\u2082 : I \u2286 M\u2082.E := hE \u25b8 hI\u2081\n  simp only [Matroid.indep_iff_not_dep, hI\u2081, hI\u2082, Matroid.dep_iff_has_circuit, true_and, and_true, not_iff_not]\n  constructor <;> intro \u27e8C, hMC, hCI\u27e9 <;> have hCE := hCI.trans hI\u2081 <;> refine \u27e8C, ?_, hCI\u27e9\n  \u00b7 rwa [hC _ hCE] at hMC\n  \u00b7 rwa [hC _ hCE]\n\n", "theoremStatement": "/-- Two matroids are equal iff they have the same ground sets and sets of circuits. -/\ntheorem Matroid.ext_iff_circuit (M\u2081 M\u2082 : Matroid \u03b1) :\n    M\u2081 = M\u2082 \u2194 M\u2081.E = M\u2082.E \u2227 \u2200 C \u2286 M\u2081.E, M\u2081.Circuit C \u2194 M\u2082.Circuit C ", "theoremName": "Matroid.ext_iff_circuit", "fileCreated": {"commit": "b44bff2f1ee71349fa9fa251579a0f5a0e575538", "date": "2024-12-19"}, "theoremCreated": {"commit": "eeca78b8370f4fb233777bcd872c3ecf81e93418", "date": "2025-01-09"}, "file": "Seymour/Seymour/Matroid/Notions/Circuit.lean", "module": "Seymour.Matroid.Notions.Circuit", "jsonFile": "Seymour.Matroid.Notions.Circuit.jsonl", "positionMetadata": {"lineInFile": 105, "tokenPositionInFile": 4372, "theoremPositionInFile": 14}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 26}, "proofMetadata": {"hasProof": true, "proof": ":=\n  \u27e8by aesop, fun hM => Matroid.ext_circuit hM.left hM.right\u27e9", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 63}}
{"srcContext": "import Mathlib.Data.Set.SymmDiff\nimport Mathlib.Order.CompletePartialOrder\nimport Mathlib.Order.Disjoint\nimport Mathlib.Order.SymmDiff\nimport Mathlib.Tactic\n\nimport Seymour.Basic\n\n/-!\nThis provides lemmas about sets (mostly dealing with disjointness) that are missing in Mathlib.\n-/\n\nvariable {\u03b1 : Type}\n\nsection Other\n\nlemma set_union_union_eq_rev (X Y Z : Set \u03b1) : X \u222a Y \u222a Z = Z \u222a Y \u222a X := by\n  rw [Set.union_assoc, Set.union_comm, Set.union_comm Y Z]\n\nlemma setminus_inter_union_eq_union {X Y : Set \u03b1} : X \\ (X \u2229 Y) \u222a Y = X \u222a Y := by\n  tauto_set\n\nlemma nonempty_inter_not_ssubset_empty_inter {A B E : Set \u03b1} (hA : (A \u2229 E).Nonempty) (hB : B \u2229 E = \u2205) :\n    \u00ac(A \u2282 B) := by\n  intro \u27e8hAB, _\u27e9\n  obtain \u27e8x, hxAE\u27e9 := hA\n  have hxBE : x \u2208 B \u2229 E := (Set.inter_subset_inter hAB fun _ => id) hxAE\n  rw [hB] at hxBE\n  tauto\n\nlemma ssubset_self_union_other_elem {a : \u03b1} {X : Set \u03b1} (ha : a \u2209 X) :\n    X \u2282 X \u222a {a} := by\n  constructor\n  \u00b7 exact Set.subset_union_left\n  \u00b7 by_contra hX\n    rw [Set.union_subset_iff] at hX\n    obtain \u27e8_, haa\u27e9 := hX\n    tauto\n\nlemma singleton_union_ssubset_union_iff {a : \u03b1} {A B : Set \u03b1} (haA : a \u2209 A) (haB : a \u2209 B) :\n    A \u222a {a} \u2282 B \u222a {a} \u2194 A \u2282 B := by\n  constructor\n  \u00b7 intro hAB\n    obtain \u27e8hABl, hABr\u27e9 := hAB\n    constructor\n    \u00b7 intro x hx\n      apply ne_of_mem_of_not_mem hx at haA\n      cases hABl (Set.mem_union_left {a} hx) <;> tauto\n    \u00b7 by_contra hBA\n      apply Set.union_subset_union_left {a} at hBA\n      tauto\n  \u00b7 intro hAB\n    obtain \u27e8hABl, hABr\u27e9 := hAB\n    constructor\n    \u00b7 exact Set.union_subset_union_left {a} hABl\n    \u00b7 by_contra hBA\n      rw [Set.union_singleton, Set.union_singleton] at hBA\n      apply (Set.insert_subset_insert_iff haB).\u2192 at hBA\n      tauto\n\nlemma ssub_parts_ssub {A B E\u2081 E\u2082 : Set \u03b1}\n    (hA : A \u2286 E\u2081 \u222a E\u2082) (hB : B \u2286 E\u2081 \u222a E\u2082) (hAB\u2081 : A \u2229 E\u2081 \u2282 B \u2229 E\u2081) (hAB\u2082 : A \u2229 E\u2082 \u2282 B \u2229 E\u2082) :\n    A \u2282 B := by\n  constructor\n  \u00b7 obtain \u27e8hE\u2081, _\u27e9 := hAB\u2081\n    obtain \u27e8hE\u2082, _\u27e9 := hAB\u2082\n    rw [Set.left_eq_inter.\u2190 hA, Set.left_eq_inter.\u2190 hB, Set.inter_union_distrib_left, Set.inter_union_distrib_left]\n    exact Set.union_subset_union hE\u2081 hE\u2082\n  \u00b7 intro hBA\n    obtain \u27e8_, hE\u2081\u27e9 := hAB\u2081\n    obtain \u27e8x, hxBE\u2081, hxnAE\u2081\u27e9 := Set.not_subset.\u2192 hE\u2081\n    have hxB : x \u2208 B := Set.mem_of_mem_inter_left hxBE\u2081\n    have hxE\u2081 : x \u2208 E\u2081 := Set.mem_of_mem_inter_right hxBE\u2081\n    tauto\n\nlemma HasSubset.Subset.parts_eq {A E\u2081 E\u2082 : Set \u03b1} (hA : A \u2286 E\u2081 \u222a E\u2082) : (A \u2229 E\u2081) \u222a (A \u2229 E\u2082) = A :=\n  ((subset_of_subset_of_eq\n    (Set.subset_inter (fun _ => id) hA)\n    (Set.inter_union_distrib_left A E\u2081 E\u2082)).antisymm\n  (Set.union_subset Set.inter_subset_left Set.inter_subset_left)).symm\n\nlemma elem_notin_set_minus_singleton (a : \u03b1) (X : Set \u03b1) : a \u2209 X \\ {a} := Set.not_mem_diff_of_mem rfl\n\nlemma sub_union_diff_sub_union {A B C : Set \u03b1} (hA : A \u2286 B \\ C) : A \u2286 B :=\n  fun _ hA' => Set.diff_subset (hA hA')\n\nlemma singleton_inter_in_left {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : a \u2208 X :=\n  Set.mem_of_mem_inter_left (ha.symm.subset rfl)\n\nlemma singleton_inter_in_right {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : a \u2208 Y :=\n  Set.mem_of_mem_inter_right (ha.symm.subset rfl)\n\nlemma singleton_inter_subset_left {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : {a} \u2286 X := by\n  rw [Set.singleton_subset_iff]\n  exact singleton_inter_in_left ha\n\nlemma singleton_inter_subset_right {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : {a} \u2286 Y := by\n  rw [Set.singleton_subset_iff]\n  exact singleton_inter_in_right ha\n\n/-- Being a subset is preserved under subtracting sets. -/\nlemma diff_subset_parent {X\u2081 X\u2082 E : Set \u03b1} (hX\u2081E : X\u2081 \u2286 E) :\n    X\u2081 \\ X\u2082 \u2286 E :=\n  Set.diff_subset_iff.\u2190 (Set.subset_union_of_subset_right hX\u2081E X\u2082)\n\n/-- Being a subset is preserved under taking intersections. -/\nlemma inter_subset_parent_left {X\u2081 X\u2082 E : Set \u03b1} (hX\u2081E : X\u2081 \u2286 E) :\n    X\u2081 \u2229 X\u2082 \u2286 E :=\n  (Set.inter_subset_inter_left X\u2082 hX\u2081E).trans Set.inter_subset_left\n\n/-- Being a subset is preserved under taking intersections. -/\nlemma inter_subset_parent_right {X\u2081 X\u2082 E : Set \u03b1} (hX\u2082E : X\u2082 \u2286 E) :\n    X\u2081 \u2229 X\u2082 \u2286 E := by\n  rw [Set.inter_comm]\n  exact inter_subset_parent_left hX\u2082E\n\n/-- Intersection of two sets is subset of their union. -/\nlemma inter_subset_union {X\u2081 X\u2082 : Set \u03b1} :\n    X\u2081 \u2229 X\u2082 \u2286 X\u2081 \u222a X\u2082 :=\n  inter_subset_parent_left Set.subset_union_left\n\nlemma subset_diff_empty_eq {A B : Set \u03b1} (hAB : A \u2286 B) (hBA : B \\ A = \u2205) : A = B :=\n  A.union_empty \u25b8 hBA \u25b8 Set.union_diff_cancel hAB\n\nend Other\n\n\nsection Disjoint\n\nlemma Disjoint.ni_of_in {X Y : Set \u03b1} {a : \u03b1} (hXY : X \u2ad7 Y) (ha : a \u2208 X) :\n    a \u2209 Y := by\n  intro ha'\n  simpa [hXY.inter_eq] using Set.mem_inter ha ha'\n\nlemma disjoint_of_singleton_inter_left_wo {X Y : Set \u03b1} {a : \u03b1} (hXY : X \u2229 Y = {a}) :\n    X \\ {a} \u2ad7 Y := by\n  tauto_set\n\nlemma disjoint_of_singleton_inter_right_wo {X Y : Set \u03b1} {a : \u03b1} (hXY : X \u2229 Y = {a}) :\n    X \u2ad7 Y \\ {a} := by\n  rw [disjoint_comm]\n  rw [Set.inter_comm] at hXY\n  exact disjoint_of_singleton_inter_left_wo hXY\n\nlemma disjoint_of_singleton_inter_both_wo {X Y : Set \u03b1} {a : \u03b1} (hXY : X \u2229 Y = {a}) :\n    X \\ {a} \u2ad7 Y \\ {a} :=\n  Disjoint.disjoint_sdiff_left (disjoint_of_singleton_inter_right_wo hXY)\n\nlemma disjoint_of_singleton_inter_subset_left {X Y Z : Set \u03b1} {a : \u03b1} (hXY : X \u2229 Y = {a}) (hZ : Z \u2286 X) (haZ : a \u2209 Z) :\n    Z \u2ad7 Y := by\n  have hY : (Y \\ {a}) \u222a {a} = Y := (Set.diff_union_of_subset (singleton_inter_subset_right hXY))\n  rw [\u2190hY, Set.disjoint_union_right]\n  constructor\n  \u00b7 exact Set.disjoint_of_subset_left hZ (disjoint_of_singleton_inter_right_wo hXY)\n  \u00b7 exact Set.disjoint_singleton_right.\u2190 haZ\n\nlemma disjoint_of_singleton_inter_subset_right {X Y Z : Set \u03b1} {a : \u03b1} (hXY : X \u2229 Y = {a}) (hZ : Z \u2286 Y) (haZ : a \u2209 Z) :\n    X \u2ad7 Z := by\n  rw [Set.inter_comm] at hXY\n  rw [disjoint_comm]\n  exact disjoint_of_singleton_inter_subset_left hXY hZ haZ\n\nlemma disjoint_nonempty_not_subset {A B : Set \u03b1} (hAB : A \u2ad7 B) (hA : A.Nonempty) :\n    \u00ac(A \u2286 B) := by\n  intro contr\n  simp [Disjoint.eq_bot_of_le hAB, contr] at hA\n\nlemma disjoint_nonempty_not_ssubset {A B : Set \u03b1} (hAB : A \u2ad7 B) (hA : A.Nonempty) :\n    \u00ac(A \u2282 B) := by\n  apply disjoint_nonempty_not_subset hAB at hA\n  intro \u27e8_, _\u27e9\n  tauto\n\nlemma ssubset_union_disjoint_nonempty {X Y : Set \u03b1} (hXY : X \u2ad7 Y) (hY : Y.Nonempty) :\n    X \u2282 X \u222a Y := by\n  constructor\n  \u00b7 exact Set.subset_union_left\n  \u00b7 by_contra hX\n    apply Set.diff_subset_diff_left at hX\n    rw [Set.union_diff_cancel_left (Set.disjoint_iff.\u2192 hXY), Set.diff_self] at hX\n    exact Set.not_nonempty_empty (Set.eq_empty_of_subset_empty hX \u25b8 hY)\n\nlemma union_ssubset_union_iff {A B X : Set \u03b1} (hAX : A \u2ad7 X) (hBX : B \u2ad7 X) :\n    A \u222a X \u2282 B \u222a X \u2194 A \u2282 B := by\n  constructor\n  \u00b7 intro hAB\n    rw [Set.ssubset_iff_subset_ne] at hAB \u22a2\n    constructor\n    \u00b7 have hXX : X \u2286 X := Set.Subset.rfl\n      have hAXXBXX := Set.diff_subset_diff hAB.left hXX\n      rwa [Set.union_diff_cancel_right, Set.union_diff_cancel_right] at hAXXBXX\n      \u00b7 rwa [Set.disjoint_iff] at hBX\n      \u00b7 rwa [Set.disjoint_iff] at hAX\n    \u00b7 intro\n      simp_all\n  \u00b7 intro hAB\n    have hAB' : A \u2286 B := hAB.subset\n    rw [Set.ssubset_iff_of_subset hAB'] at hAB\n    obtain \u27e8x, hx\u27e9 := hAB\n    rw [Set.ssubset_iff_of_subset (Set.union_subset_union_left X hAB')]\n    refine \u27e8x, Set.mem_union_left X hx.left, fun hx' => ?_\u27e9\n    rw [Set.mem_union] at hx'\n    cases hx' with\n    | inl hA => exact hx.right hA\n    | inr hX => exact hBX.ni_of_in hx.left hX\n\nlemma union_subset_union_iff {A B X : Set \u03b1} (hAX : A \u2ad7 X) (hBX : B \u2ad7 X) :\n    A \u222a X \u2286 B \u222a X \u2194 A \u2286 B := by\n  constructor\n  \u00b7 intro hABX\n    have hXX : (A \u222a X) \\ X \u2286 (B \u222a X) \\ X := Set.diff_subset_diff_left hABX\n    have hXA : (A \u222a X) \\ X = A := Set.union_diff_cancel_right (Set.disjoint_iff.\u2192 hAX)\n    have hXB : (B \u222a X) \\ X = B := Set.union_diff_cancel_right (Set.disjoint_iff.\u2192 hBX)\n    rwa [hXA, hXB] at hXX\n  \u00b7 exact Set.union_subset_union_left X\n\nlemma ssubset_disjoint_union_nonempty {X\u2081 X\u2082 : Set \u03b1} (hXX : X\u2081 \u2ad7 X\u2082) (hX\u2082 : X\u2082.Nonempty) :\n    X\u2081 \u2282 X\u2081 \u222a X\u2082 := by\n  rw [Set.ssubset_iff_of_subset Set.subset_union_left]\n  obtain \u27e8x, hx\u27e9 := hX\u2082\n  exact \u27e8x, Set.mem_union_right X\u2081 hx, Disjoint.ni_of_in hXX.symm hx\u27e9\n\nlemma ssubset_disjoint_nonempty_union {X\u2081 X\u2082 : Set \u03b1} (hXX : X\u2081 \u2ad7 X\u2082) (hX\u2081 : X\u2081.Nonempty) :\n    X\u2082 \u2282 X\u2081 \u222a X\u2082 := by\n  rw [disjoint_comm] at hXX\n  rw [Set.union_comm]\n  exact ssubset_disjoint_union_nonempty hXX hX\u2081\n\n/-- If two sets are disjoint, then any set is disjoint with their intersection -/\nlemma disjoint_inter_disjoint {A B : Set \u03b1} (C : Set \u03b1) (hAB : A \u2ad7 B) : C \u2ad7 A \u2229 B := by\n  rw [hAB.inter_eq]\n  exact Set.disjoint_empty C\n\n", "theoremStatement": "lemma diff_inter_disjoint_diff_inter (X\u2081 X\u2082 : Set \u03b1) :\n    X\u2081 \\ (X\u2081 \u2229 X\u2082) \u2ad7 X\u2082 \\ (X\u2081 \u2229 X\u2082) ", "theoremName": "diff_inter_disjoint_diff_inter", "fileCreated": {"commit": "b44bff2f1ee71349fa9fa251579a0f5a0e575538", "date": "2024-12-19"}, "theoremCreated": {"commit": "1b53227df59d92520ce7d3b6938ba345cdd5f245", "date": "2025-02-03"}, "file": "Seymour/Seymour/ForMathlib/SetTheory.lean", "module": "Seymour.ForMathlib.SetTheory", "jsonFile": "Seymour.ForMathlib.SetTheory.jsonl", "positionMetadata": {"lineInFile": 234, "tokenPositionInFile": 8424, "theoremPositionInFile": 32}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 24}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [Set.diff_self_inter, Set.diff_inter_self_eq_diff]\n  exact disjoint_sdiff_sdiff", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 90}}
{"srcContext": "import Mathlib.Data.Set.Card\nimport Mathlib.Data.Matroid.Dual\n\nimport Seymour.ForMathlib.SetTheory\nimport Seymour.Matroid.Notions.Circuit\nimport Seymour.Matroid.Notions.CircuitAxioms\nimport Seymour.Matroid.Notions.Connectivity\nimport Seymour.Matroid.Constructors.CircuitMatroid\n\n/-!\nThis file defines 2-sum of two (general) matroids `M\u2081` and `M\u2082`, denoted as `M\u2081 \u2295\u2082 M\u2082`.\n-/\n\nvariable {\u03b1 : Type}\n\n\nsection MainDefinitions\n\n/-- `M\u2081 \u2295\u2082 M\u2082` is defined if `M\u2081` and `M\u2082` satisfy the following assumptions -/\nstructure TwoSumAssumptions (M\u2081 M\u2082 : Matroid \u03b1) : Prop where\n  /-- `M\u2081` is finite -/\n  M\u2081fin : M\u2081.Finite\n  /-- `M\u2082` is finite -/\n  M\u2082fin : M\u2082.Finite\n  /-- `M\u2081` contains at least 2 elements -/\n  M\u2081card : M\u2081.E.encard \u2265 2\n  /-- `M\u2082` contains at least 2 elements -/\n  M\u2082card : M\u2082.E.encard \u2265 2\n  /-- `M\u2081` and `M\u2082` have exactly one element in common -/\n  interSingleton : (M\u2081.E \u2229 M\u2082.E).encard = 1\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2081` -/\n  M\u2081sep : \u00acM\u2081.Separator (M\u2081.E \u2229 M\u2082.E)\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2082` -/\n  M\u2082sep : \u00acM\u2082.Separator (M\u2081.E \u2229 M\u2082.E)\n\n-- question: can avoid this assumption? -- which assumption? the finiteness?\n\n/-- Ground set of `M\u2081 \u2295\u2082 M\u2082` -/\ndef twoSumGround (M\u2081 M\u2082 : Matroid \u03b1) : Set \u03b1 :=\n  (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)\n\n/-- Type 1 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2081` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType1 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 2 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2082` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType2 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2082.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 3 of circuits in `M\u2081 \u2295\u2082 M\u2082`:\n    sets `(C\u2081 \u222a C\u2082) \\ (M\u2081.E \u2229 M\u2082.E)` where `C\u2081` and `C\u2082` are circuits in `M\u2081` and `M\u2082`, respectively,\n    and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2081` and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2082` -/\ndef TwoSumCircuitType3 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit ((C \u2229 M\u2081.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 M\u2082.Circuit ((C \u2229 M\u2082.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 C \u2286 twoSumGround M\u2081 M\u2082\n\n/-- Circuit predicate of `M\u2081 \u2295\u2082 M\u2082`, which defines 2-sum as `CircuitMatroid` -/\ndef TwoSumCircuitPred (M\u2081 M\u2082 : Matroid \u03b1) : CircuitPredicate \u03b1 :=\n  fun C : Set \u03b1 =>\n    TwoSumCircuitType1 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType2 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType3 M\u2081 M\u2082 C\n\nend MainDefinitions\n\n\nsection PropertiesAssumptions\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1}\n\n/-- 2-sum assumptions are symmetric -/\nlemma TwoSumAssumptions.symm (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    TwoSumAssumptions M\u2082 M\u2081 :=\n  \u27e8\n    assumptions.M\u2082fin,\n    assumptions.M\u2081fin,\n    assumptions.M\u2082card,\n    assumptions.M\u2081card,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.interSingleton,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2082sep,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2081sep,\n  \u27e9\n\n/-- Intersection of ground sets is nonempty -/\nlemma TwoSumAssumptions.inter_nonempty (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (M\u2081.E \u2229 M\u2082.E).Nonempty :=\n  Set.one_le_encard_iff_nonempty.\u2192 assumptions.interSingleton.symm.le\n\n/-- Intersection of ground sets is a singleton set -/\nlemma TwoSumAssumptions.inter_singleton (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    \u2203 p : \u03b1, M\u2081.E \u2229 M\u2082.E = {p} :=\n  Set.encard_eq_one.\u2192 assumptions.interSingleton\n\nvariable {p : \u03b1}\n\n/-- Singleton element in intersection of ground sets in not a loop in `M\u2081` -/\nlemma TwoSumAssumptions.inter_singleton_not_loop_M\u2081 (assumptions : TwoSumAssumptions M\u2081 M\u2082)\n    (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2081.Loop p) :=\n  (hp \u25b8 assumptions.M\u2081sep <| Matroid.separator_loop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a coloop in `M\u2081` -/\nlemma TwoSumAssumptions.inter_singleton_not_coloop_M\u2081 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2081.Coloop p) :=\n  (hp \u25b8 assumptions.M\u2081sep <| Matroid.separator_coloop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a loop in `M\u2082` -/\nlemma TwoSumAssumptions.inter_singleton_not_loop_M\u2082 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2082.Loop p) :=\n  (hp \u25b8 assumptions.M\u2082sep <| Matroid.separator_loop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a coloop in `M\u2082` -/\nlemma TwoSumAssumptions.inter_singleton_not_coloop_M\u2082 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2082.Coloop p) :=\n  (hp \u25b8 assumptions.M\u2082sep <| Matroid.separator_coloop \u00b7)\n\nend PropertiesAssumptions\n\n\nsection PropertiesGroundSet\n\n/-- Ground set of 2-sum is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma twoSumGround_disjoint_inter (M\u2081 M\u2082 : Matroid \u03b1) :\n    twoSumGround M\u2081 M\u2082 \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  Set.disjoint_sdiff_left\n\n/-- Ground sets minus their intersection are disjoint sets -/\nlemma twoSum_disjoint_grounds_diff_inter (M\u2081 M\u2082 : Matroid \u03b1) :\n    M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) \u2ad7 M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E) := by\n  rw [Set.diff_self_inter, Set.diff_inter_self_eq_diff]\n  exact disjoint_sdiff_sdiff\n\nend PropertiesGroundSet\n\n\nsection PropertiesCircuitType1\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1} {C : Set \u03b1}\n\n/-- Circuit of type 1 is a circuit in `M\u2081` -/\nlemma TwoSumCircuitType1.circuit_M\u2081 (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : M\u2081.Circuit C :=\n  hC.left\n\n/-- Circuit of type 1 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType1.disjoint_inter (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of type 1 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma TwoSumCircuitType1.subset_union (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_left hC.circuit_M\u2081.subset_ground M\u2082.E\n\n/-- Circuit of type 1 lies in ground set of `M\u2081 \u2295\u2082 M\u2082` -/\nlemma TwoSumCircuitType1.subset_ground (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 twoSumGround M\u2081 M\u2082 :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 1 lies in `M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma TwoSumCircuitType1.subset_M\u2081_diff_inter (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2081.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 1 is disjoint with `M\u2082.E` -/\nlemma TwoSumCircuitType1.disjoint_M\u2082 (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2ad7 M\u2082.E := by\n  have hMM := twoSum_disjoint_grounds_diff_inter M\u2081 M\u2082\n  have hCM\u2082 := Set.disjoint_of_subset_left hC.subset_M\u2081_diff_inter hMM\n  have hCM\u2082 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2082, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_right] at hCM\u2082\n  exact hCM\u2082\n\nend PropertiesCircuitType1\n\n\nsection PropertiesCircuitType2\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1} {C : Set \u03b1}\n\n/-- Circuit of type 2 is a circuit in `M\u2082` -/\nlemma TwoSumCircuitType2.circuit_M\u2082 (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : M\u2082.Circuit C :=\n  hC.left\n\n/-- Circuit of type 2 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType2.disjoint_inter (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of type 2 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma TwoSumCircuitType2.subset_union (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_right hC.circuit_M\u2082.subset_ground M\u2081.E\n\n/-- Circuit of type 2 lies in ground set of `M\u2081 \u2295\u2082 M\u2082` -/\nlemma TwoSumCircuitType2.subset_ground (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2286 twoSumGround M\u2081 M\u2082 :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 2 lies in `M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma TwoSumCircuitType2.subset_M\u2082_diff_inter (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2286 M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2082.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 2 is disjoint with `M\u2081.E` -/\nlemma TwoSumCircuitType2.disjoint_M\u2081 (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E := by\n  have hMM := twoSum_disjoint_grounds_diff_inter M\u2081 M\u2082\n  have hCM\u2081 := (Set.disjoint_of_subset_right hC.subset_M\u2082_diff_inter hMM).symm\n  have hCM\u2081 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2081, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_left] at hCM\u2081\n  exact hCM\u2081\n\nend PropertiesCircuitType2\n\n\nsection PropertiesCircuitType3\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1} {C : Set \u03b1}\n\n/-- Circuit of type 3 yields a circuit in `M\u2081` after intersecting it with `M\u2081.E` and adding `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType3.to_circuit_M\u2081 (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : M\u2081.Circuit ((C \u2229 M\u2081.E) \u222a (M\u2081.E \u2229 M\u2082.E)) :=\n  hC.left\n\n/-- Circuit of type 3 yields a circuit in `M\u2082` after intersecting it with `M\u2081.E` and adding `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType3.to_circuit_M\u2082 (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : M\u2082.Circuit ((C \u2229 M\u2082.E) \u222a (M\u2081.E \u2229 M\u2082.E)) :=\n  hC.right.left\n\n/-- Circuit of type 3 is subset of ground set of `M\u2081 \u2295\u2082 M\u2082` -/\ndef TwoSumCircuitType3.subset_ground (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2286 twoSumGround M\u2081 M\u2082 :=\n  hC.right.right\n\n/-- Circuit of type 3 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma TwoSumCircuitType3.subset_union (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \u222a M\u2082.E :=\n  sub_union_diff_sub_union hC.subset_ground\n\n/-- Circuit of type 3 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType3.disjoint_inter (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  Set.disjoint_of_subset_left hC.subset_ground (twoSumGround_disjoint_inter M\u2081 M\u2082)\n\n/-- Circuit of type 3 intersected with `M\u2081.E` is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType3.disjoint_inter_M\u2081_inter (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2229 M\u2081.E \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.disjoint_inter.inter_left M\u2081.E\n\n/-- Circuit of type 3 intersected with `M\u2082.E` is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType3.disjoint_inter_M\u2082_inter (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2229 M\u2082.E \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.disjoint_inter.inter_left M\u2082.E\n\n/-- Circuit of type 3 has nonempty intersection with `M\u2081.E` -/\nlemma TwoSumCircuitType3.inter_M\u2081_nonempty (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (C \u2229 M\u2081.E).Nonempty := by\n  by_contra! hCM\u2081\n  have hM\u2081 := hC.to_circuit_M\u2081\n  have \u27e8p, hp\u27e9 := assumptions.inter_singleton\n  rw [hCM\u2081, Set.empty_union, hp, \u2190Matroid.loop_iff_circuit M\u2081] at hM\u2081\n  have hpM\u2081 := assumptions.inter_singleton_not_loop_M\u2081 hp\n  exact hpM\u2081 hM\u2081\n\n/-- Circuit of type 3 has nonempty intersection with `M\u2082.E` -/\nlemma TwoSumCircuitType3.inter_M\u2082_nonempty (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (C \u2229 M\u2082.E).Nonempty := by\n  by_contra! hCM\u2082empty\n  have hCM\u2082 := hC.to_circuit_M\u2082\n  have \u27e8p, hp\u27e9 := assumptions.inter_singleton\n  rw [hCM\u2082empty, Set.empty_union, hp, \u2190Matroid.loop_iff_circuit M\u2082] at hCM\u2082\n  exact assumptions.inter_singleton_not_loop_M\u2082 hp hCM\u2082\n\nend PropertiesCircuitType3\n\n\nsection PropertiesCircuitTypePairs1\n\n/-- Circuit of type 1 is not a strict subset of any circuit of type 1 -/\nlemma TwoSumCircuitType1.not_ssubset_circuit_type_1 {M\u2081 M\u2082 : Matroid \u03b1} {C C' : Set \u03b1}\n    (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) (hC' : TwoSumCircuitType1 M\u2081 M\u2082 C') :\n    \u00ac(C \u2282 C') :=\n  hC.circuit_M\u2081.not_ssubset_circuit hC'.circuit_M\u2081\n\n/-- Circuit of type 1 is disjoint with any circuit of type 2 -/\nlemma TwoSumCircuitType1.disjoint_circuit_type_2 {M\u2081 M\u2082 : Matroid \u03b1} {C\u2081 C\u2082 : Set \u03b1}\n    (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) :\n    C\u2081 \u2ad7 C\u2082 := by\n  have hC\u2081M\u2081 := hC\u2081.subset_M\u2081_diff_inter\n  have hC\u2082M\u2082 := hC\u2082.subset_M\u2082_diff_inter\n  have hMM := twoSum_disjoint_grounds_diff_inter M\u2081 M\u2082\n  exact Set.disjoint_of_subset hC\u2081M\u2081 hC\u2082M\u2082 hMM\n\n/-- Circuit of type 1 is not a strict subset of any circuit of type 2 -/\nlemma TwoSumCircuitType1.not_ssubset_circuit_type_2 {M\u2081 M\u2082 : Matroid \u03b1} {C\u2081 C\u2082 : Set \u03b1}\n    (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) :\n    \u00ac(C\u2081 \u2282 C\u2082) :=\n  disjoint_nonempty_not_ssubset (hC\u2081.disjoint_circuit_type_2 hC\u2082) hC\u2081.circuit_M\u2081.nonempty\n\n/-- Circuit of type 1 is not a strict subset of any circuit of type 3 -/\nlemma TwoSumCircuitType1.not_ssubset_circuit_type_3 {M\u2081 M\u2082 : Matroid \u03b1} {C\u2081 C\u2083 : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) (hC\u2083 : TwoSumCircuitType3 M\u2081 M\u2082 C\u2083) :\n    \u00ac(C\u2081 \u2282 C\u2083) :=\n  fun hCC =>\n    hC\u2081.circuit_M\u2081.not_ssubset_circuit hC\u2083.to_circuit_M\u2081\n      (Set.ssubset_of_ssubset_of_subset (ssubset_union_disjoint_nonempty hC\u2081.disjoint_inter assumptions.inter_nonempty)\n        (Set.union_subset_union_left (M\u2081.E \u2229 M\u2082.E) (Set.subset_inter hCC.left hC\u2081.circuit_M\u2081.subset_ground)))\n\n/-- Circuit of type 1 is not a strict subset of any other circuit -/\nlemma TwoSumCircuitType1.not_ssubset_circuit {M\u2081 M\u2082 : Matroid \u03b1} {C\u2081 C : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) (hC : TwoSumCircuitPred M\u2081 M\u2082 C) :\n    \u00ac(C\u2081 \u2282 C) := by\n  cases hC with\n  | inl hC => exact hC\u2081.not_ssubset_circuit_type_1 hC\n  | inr hC => cases hC with\n    | inl hC => exact hC\u2081.not_ssubset_circuit_type_2 hC\n    | inr hC => exact hC\u2081.not_ssubset_circuit_type_3 assumptions hC\n\nend PropertiesCircuitTypePairs1\n\n\nsection PropertiesCircuitTypePairs2\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1}\n\n/-- Circuits of type 2 are disjoint with circuits of type 1 -/\nlemma TwoSumCircuitType2.disjoint_circuitType1 {C\u2081 C\u2082 : Set \u03b1}\n    (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) :\n    C\u2082 \u2ad7 C\u2081 :=\n  (hC\u2081.disjoint_circuit_type_2 hC\u2082).symm\n\n/-- Circuit of type 2 is not a strict subset of any circuit of type 1 -/\nlemma TwoSumCircuitType2.not_ssubset_circuitType1 {C\u2081 C\u2082 : Set \u03b1}\n    (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) :\n    \u00ac(C\u2082 \u2282 C\u2081) :=\n  disjoint_nonempty_not_ssubset (hC\u2082.disjoint_circuitType1 hC\u2081) hC\u2082.circuit_M\u2082.nonempty\n\n/-- Circuit of type 2 is not a strict subset of any circuit of type 2 -/\nlemma TwoSumCircuitType2.not_ssubset_circuitType2 {C C' : Set \u03b1}\n    (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) (hC' : TwoSumCircuitType2 M\u2081 M\u2082 C') :\n    \u00ac(C \u2282 C') :=\n  hC.circuit_M\u2082.not_ssubset_circuit hC'.circuit_M\u2082\n\n/-- Circuit of type 2 is not a strict subset of any circuit of type 3 -/\nlemma TwoSumAssumptions.circuitType2_not_ssubset_circuitType3 {C\u2082 C\u2083 : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) (hC\u2083 : TwoSumCircuitType3 M\u2081 M\u2082 C\u2083) :\n    \u00ac(C\u2082 \u2282 C\u2083) :=\n  fun hCC =>\n    hC\u2082.circuit_M\u2082.not_ssubset_circuit hC\u2083.to_circuit_M\u2082\n      (Set.ssubset_of_ssubset_of_subset (ssubset_union_disjoint_nonempty hC\u2082.disjoint_inter assumptions.inter_nonempty)\n        (Set.union_subset_union_left (M\u2081.E \u2229 M\u2082.E) (Set.subset_inter hCC.left hC\u2082.circuit_M\u2082.subset_ground)))\n\n", "theoremStatement": "/-- Circuit of type 2 is not a strict subset of any other circuit -/\nlemma TwoSumAssumptions.circuitType2_not_ssubset {C\u2082 C : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) (hC : TwoSumCircuitPred M\u2081 M\u2082 C) :\n    \u00ac(C\u2082 \u2282 C) ", "theoremName": "TwoSumAssumptions.circuitType2_not_ssubset", "fileCreated": {"commit": "d0eaaa305c96cd81ac061f505a81614db6856b21", "date": "2025-01-09"}, "theoremCreated": {"commit": "439c72996f29168161b974bc602629cac773728f", "date": "2025-01-08"}, "file": "Seymour/Seymour/Matroid/Operations/Sum2/Basic.lean", "module": "Seymour.Matroid.Operations.Sum2.Basic", "jsonFile": "Seymour.Matroid.Operations.Sum2.Basic.jsonl", "positionMetadata": {"lineInFile": 335, "tokenPositionInFile": 14204, "theoremPositionInFile": 44}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 8, "repositoryPremises": true, "numRepositoryPremises": 8, "numPremises": 19}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  cases hC with\n  | inl hC => exact hC\u2082.not_ssubset_circuitType1 hC\n  | inr hC => cases hC with\n    | inl hC => exact hC\u2082.not_ssubset_circuitType2 hC\n    | inr hC => exact assumptions.circuitType2_not_ssubset_circuitType3 hC\u2082 hC", "proofType": "tactic", "proofLengthLines": 5, "proofLengthTokens": 234}}
{"srcContext": "import Mathlib.Data.Matroid.Dual\nimport Seymour.Matroid.Notions.Loop\n\n\nvariable {\u03b1 : Type}\n\n\n/-- Coloop is a loop in the dual matroid. -/\ndef Matroid.Coloop (M : Matroid \u03b1) (a : \u03b1) : Prop :=\n  M\u2736.Loop a\n\n", "theoremStatement": "/-- An element is a coloop iff it belongs to no circuit. -/\nlemma Matroid.coloop_iff_in_no_circuit (M : Matroid \u03b1) {a : \u03b1} :\n    M.Coloop a \u2194 a \u2208 M.E \u2227 \u2200 C : Set \u03b1, M.Circuit C \u2192 a \u2209 C ", "theoremName": "Matroid.coloop_iff_in_no_circuit", "fileCreated": {"commit": "b44bff2f1ee71349fa9fa251579a0f5a0e575538", "date": "2024-12-19"}, "theoremCreated": {"commit": "aa94b9eb8a1b85573a7b945cf5c5bf96cb4b388b", "date": "2025-01-16"}, "file": "Seymour/Seymour/Matroid/Notions/Coloop.lean", "module": "Seymour.Matroid.Notions.Coloop", "jsonFile": "Seymour.Matroid.Notions.Coloop.jsonl", "positionMetadata": {"lineInFile": 12, "tokenPositionInFile": 204, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 5, "numPremises": 64}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  constructor\n  \u00b7 intro \u27e8haE, M_dual_Dep_a\u27e9\n    refine \u27e8haE, fun C hC haC => ?_\u27e9\n    obtain \u27e8B, hB, hCaB\u27e9 := (hC.indep_diff_singleton haC).exists_base_superset\n    have haB := (Matroid.dual_dep_iff_forall.\u2192 M_dual_Dep_a).left B hB\n    have hMB : M.Dep B\n    \u00b7 rw [Matroid.dep_iff_has_circuit]\n      have hCB := Set.diff_union_of_subset (Set.singleton_subset_iff.\u2190 haC) \u25b8 Set.union_subset hCaB\n        (Set.singleton_subset_iff.\u2190 (Set.singleton_inter_nonempty.\u2192 haB))\n      exact \u27e8M.subset_ground B hB, C, hC, hCB\u27e9\n    exact hMB.not_indep hB.indep\n  \u00b7 intro \u27e8haE, haC\u27e9\n    constructor\n    \u00b7 exact haE\n    \u00b7 rw [Matroid.dual_dep_iff_forall]\n      constructor\n      \u00b7 intro B hB\n        by_contra! haB\n        obtain \u27e8C', hC', hC'aB, haC'\u27e9 := hB.indep.circuit_of_insert_dep\n          (hB.dep_of_insert (Set.singleton_inter_eq_empty.\u2192 haB) haE)\n        exact haC C' hC' haC'\n      \u00b7 rwa [Set.singleton_subset_iff]", "proofType": "tactic", "proofLengthLines": 22, "proofLengthTokens": 915}}
{"srcContext": "import Seymour.Matroid.Operations.Sum2.Basic\nimport Seymour.Matroid.Classes.Regular\n\n\nvariable {\u03b1 : Type} [DecidableEq \u03b1]\n\nsection Representations\n\n/-- representation for summands in 2-sum, see Proposition 7.1.24 in Oxley -/\nstructure TwoSumSummandRepr (M : Matroid \u03b1) {p : \u03b1} (hp : p \u2208 M.E) (R : Type) [Ring R] where\n  /-- row index collection -/\n  X : Set \u03b1\n  /-- matrix representation -/\n  A : Matrix X M.E R\n  /-- the row where the column `p` of `A` contains a one -/\n  r : \u03b1\n  hr : r \u2208 X\n  /-- column `p` of `A` has a one in row `r` and zeroes everywhere else -/\n  hA : A \u27e8r, hr\u27e9 \u27e8p, hp\u27e9 = 1 \u2227 \u2200 i : X, i \u2260 \u27e8r, hr\u27e9 \u2192 A i \u27e8p, hp\u27e9 = 0\n  -- additional decidability conditions\n  -- todo: avoid? simplify?\n  decmemX : \u2200 a, Decidable (a \u2208 X)\n  deceqr : \u2200 a, Decidable (a = r)\n\n-- Automatically infer decidability when `StandardRepr` is present.\nattribute [instance] TwoSumSummandRepr.decmemX\nattribute [instance] TwoSumSummandRepr.deceqr\n\n/-- todo: desc -/\ndef TwoSumSummandRepr.col_p {R : Type} [Ring R] {M : Matroid \u03b1} {p : \u03b1} {hp : p \u2208 M.E} (S : TwoSumSummandRepr M hp R) :\n    Matrix S.X ({p} : Set \u03b1) R :=\n  Matrix.of fun i j => S.A i \u27e8j, Set.mem_of_eq_of_mem j.property hp\u27e9\n\n/-- todo: desc -/\ndef TwoSumSummandRepr.row_p {R : Type} [Ring R] {M : Matroid \u03b1} {p : \u03b1} {hp : p \u2208 M.E} (S : TwoSumSummandRepr M hp R) :\n    Matrix ({S.r} : Set \u03b1) M.E R :=\n  Matrix.of fun _i j => S.A \u27e8S.r, S.hr\u27e9 j\n  -- alt, with i: Matrix.of fun i j => S.A \u27e8i, Set.mem_of_eq_of_mem i.property S.hr\u27e9 j\n\n/-- todo: desc -/\ndef TwoSumSummandRepr.row_p_del_1 {R : Type} [Ring R] {M : Matroid \u03b1} {p : \u03b1} {hp : p \u2208 M.E} (S : TwoSumSummandRepr M hp R) :\n    Matrix ({S.r} : Set \u03b1) (M.E \\ {p}).Elem R :=\n  Matrix.of fun _i j => S.A \u27e8S.r, S.hr\u27e9 \u27e8j, Set.mem_of_mem_diff j.property\u27e9\n  -- alt, with i: Matrix.of fun i j => S.A \u27e8i.val, Set.mem_of_eq_of_mem i.property S.hr\u27e9 \u27e8j, Set.mem_of_mem_diff j.property\u27e9\n\n/-- todo: desc -/\ndef TwoSumSummandRepr.A_del_col_p {R : Type} [Ring R] {M : Matroid \u03b1} {p : \u03b1} {hp : p \u2208 M.E} (S : TwoSumSummandRepr M hp R) :\n    Matrix S.X (M.E \\ {p}).Elem R :=\n  Matrix.of fun i j => S.A i \u27e8j, Set.mem_of_mem_diff j.property\u27e9\n\n/-- todo: desc -/\ndef TwoSumSummandRepr.A_block {R : Type} [Ring R] {M : Matroid \u03b1} {p : \u03b1} {hp : p \u2208 M.E} (S : TwoSumSummandRepr M hp R) :\n    Matrix (S.X \\ {S.r}).Elem (M.E \\ {p}).Elem R :=\n  Matrix.of fun i j => S.A \u27e8i, Set.mem_of_mem_diff i.property\u27e9 \u27e8j, Set.mem_of_mem_diff j.property\u27e9\n\n-- /-- todo: desc -/\n-- def TwoSumSummandRepr.A_block_p_zero {R : Type} [Ring R] {M : Matroid \u03b1} {p : \u03b1} {hp : p \u2208 M.E}\n--     (S : TwoSumSummandRepr M hp R) (Y : Set \u03b1) [\u2200 a, Decidable (a \u2208 Y)] (t : \u03b1) [\u2200 a, Decidable (a \u2208 ({t} : Set \u03b1))] :\n--     Matrix (S.X \\ {S.r} \u222a {t} \u222a Y).Elem (M.E \\ {p}).Elem R :=\n--   Matrix.fromRowsSetUnion\n--     (Matrix.fromRowsSetUnion S.A_block (S.row_p_del_1.reindex (Equiv.ofUnique _ _) (Equiv.setCongr rfl))) 0\n\n-- /-- todo: desc -/\n-- def TwoSumSummandRepr.A_zero_p_block {R : Type} [Ring R] {M : Matroid \u03b1} {p : \u03b1} {hp : p \u2208 M.E}\n--     (S : TwoSumSummandRepr M hp R) (Y : Set \u03b1) [\u2200 a, Decidable (a \u2208 Y)] (t : \u03b1) [\u2200 a, Decidable (a \u2208 ({t} : Set \u03b1))] :\n--     Matrix (Y \u222a {t} \u222a S.X \\ {S.r}).Elem (M.E \\ {p}).Elem R :=\n--   Matrix.castRowsSetUnion (S.A_block_p_zero Y t) (set_union_union_eq_rev (S.X \\ {S.r}) {t} Y)\n\nomit [DecidableEq \u03b1] in\nlemma TwoSumSummandRepr.twoSumGround_eq {M\u2081 M\u2082 : Matroid \u03b1} {p : \u03b1} (hp\u2081 : p \u2208 M\u2081.E) (hp\u2082 : p \u2208 M\u2082.E)\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) :  M\u2081.E \\ {p} \u222a M\u2082.E \\ {p} = twoSumGround M\u2081 M\u2082 := by\n  have \u27e8p', hp'\u27e9 := assumptions.inter_singleton\n  have hpp' : p \u2208 ({p'} : Set \u03b1) := hp' \u25b8 Set.mem_inter hp\u2081 hp\u2082\n  rw [\u2190Set.union_diff_distrib, twoSumGround, hp', hpp']\n\n-- /-- todo: desc -/ -- glue representations of M\u2081 and M\u2082 as shown in fig. 7.6(a) in Oxley, then delete column of {p}\n-- def TwoSumSummandRepr.compose {R : Type} [Ring R] {M\u2081 M\u2082 : Matroid \u03b1} {p : \u03b1} {hp\u2081 : p \u2208 M\u2081.E} {hp\u2082 : p \u2208 M\u2082.E}\n--     [\u2200 a : \u03b1, \u2200 A : Set \u03b1, Decidable (a \u2208 A)] -- todo: avoid?\n--     (S\u2081 : TwoSumSummandRepr M\u2081 hp\u2081 R) (S\u2082 : TwoSumSummandRepr M\u2082 hp\u2082 R) (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n--     Matrix ((S\u2081.X \\ {S\u2081.r}) \u222a {S\u2081.r} \u222a (S\u2082.X \\ {S\u2082.r})).Elem (twoSumGround M\u2081 M\u2082) R :=\n--   Matrix.castColsSetUnion\n--     (Matrix.fromColsSetUnion (S\u2081.A_block_p_zero (S\u2082.X \\ {S\u2082.r}) S\u2081.r) (S\u2082.A_zero_p_block (S\u2081.X \\ {S\u2081.r}) S\u2081.r))\n--     (twoSumGround_eq hp\u2081 hp\u2082 assumptions)\n\n/-- todo: desc -/\nlemma TwoSumSummandRepr.exists {R : Type} [Ring R] {M : Matroid \u03b1} [Fintype M.E] {p : \u03b1}\n    (hp : p \u2208 M.E) (hM : M.IsRepresentableOver R) :\n    \u2203 S : TwoSumSummandRepr M hp R, M.IsRepresentedBy S.A :=\n  sorry\n  -- todo: use standard matrix representation where rows correspond to a base that includes `p`\n\n-- /-- todo: desc -/\n-- lemma TwoSumSummandRepr.twoSum_repr {R : Type} [Ring R] {M\u2081 M\u2082 : Matroid \u03b1} {p : \u03b1} {hp\u2081 : p \u2208 M\u2081.E} {hp\u2082 : p \u2208 M\u2082.E}\n--     [\u2200 a : \u03b1, \u2200 A : Set \u03b1, Decidable (a \u2208 A)] -- todo: avoid?\n--     (assumptions : TwoSumAssumptions M\u2081 M\u2082) (S\u2081 : TwoSumSummandRepr M\u2081 hp\u2081 R) (S\u2082 : TwoSumSummandRepr M\u2082 hp\u2082 R) :\n--     assumptions.build2sum.IsRepresentedBy (S\u2081.compose S\u2082 assumptions) :=\n--   sorry\n\nend Representations\n\n\nsection Regularity\n\n/-- Any 2-sum of regular matroids is regular. -/\nlemma TwoSumAssumptions.composition_isRegular {M\u2081 M\u2082 : Matroid \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (regularity\u2081 : M\u2081.IsRegular) (regularity\u2082 : M\u2082.IsRegular) :\n    assumptions.build2sum.IsRegular := by\n  intro F hF\n  obtain \u27e8\u27e8X\u2081, E\u2081, A\u2081\u27e9, hM\u2081\u27e9 := regularity\u2081 F hF\n  obtain \u27e8\u27e8X\u2082, E\u2082, A\u2082\u27e9, hM\u2082\u27e9 := regularity\u2082 F hF\n  sorry\n\n/-- If a regular matroid is a 2-sum of binary matroids, the left summand is regular. -/\nlemma TwoSumAssumptions.decomposition_isRegular_left {M\u2081 M\u2082 : Matroid \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (regularity : assumptions.build2sum.IsRegular) :\n    M\u2081.IsRegular :=\n  sorry\n\n/-- If a regular matroid is a 2-sum of binary matroids, the right summand is regular. -/\nlemma TwoSumAssumptions.decomposition_isRegular_right {M\u2081 M\u2082 : Matroid \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (regularity : assumptions.build2sum.IsRegular) :\n    M\u2082.IsRegular :=\n  sorry\n\n", "theoremStatement": "/-- If a regular matroid is a 2-sum of binary matroids, both summand matroids are regular. -/\nlemma TwoSumAssumptions.decomposition_isRegular_both {M\u2081 M\u2082 : Matroid \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (regularity : assumptions.build2sum.IsRegular) :\n    M\u2081.IsRegular \u2227 M\u2082.IsRegular ", "theoremName": "TwoSumAssumptions.decomposition_isRegular_both", "fileCreated": {"commit": "d0eaaa305c96cd81ac061f505a81614db6856b21", "date": "2025-01-09"}, "theoremCreated": {"commit": "82da3e879b5e70117f930d5c7ceac4783bc3fe8c", "date": "2025-02-01"}, "file": "Seymour/Seymour/Matroid/Operations/Sum2/Regularity.lean", "module": "Seymour.Matroid.Operations.Sum2.Regularity", "jsonFile": "Seymour.Matroid.Operations.Sum2.Regularity.jsonl", "positionMetadata": {"lineInFile": 125, "tokenPositionInFile": 6087, "theoremPositionInFile": 10}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 5, "numPremises": 9}, "proofMetadata": {"hasProof": true, "proof": ":=\n  \u27e8assumptions.decomposition_isRegular_left regularity, assumptions.decomposition_isRegular_right regularity\u27e9", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 112}}
{"srcContext": "import Mathlib.Data.Set.Card\nimport Mathlib.Data.Matroid.Dual\n\nimport Seymour.ForMathlib.SetTheory\nimport Seymour.Matroid.Notions.Circuit\nimport Seymour.Matroid.Notions.CircuitAxioms\nimport Seymour.Matroid.Notions.Connectivity\nimport Seymour.Matroid.Constructors.CircuitMatroid\n\n/-!\nThis file defines 2-sum of two (general) matroids `M\u2081` and `M\u2082`, denoted as `M\u2081 \u2295\u2082 M\u2082`.\n-/\n\nvariable {\u03b1 : Type}\n\n\nsection MainDefinitions\n\n/-- `M\u2081 \u2295\u2082 M\u2082` is defined if `M\u2081` and `M\u2082` satisfy the following assumptions -/\nstructure TwoSumAssumptions (M\u2081 M\u2082 : Matroid \u03b1) : Prop where\n  /-- `M\u2081` is finite -/\n  M\u2081fin : M\u2081.Finite\n  /-- `M\u2082` is finite -/\n  M\u2082fin : M\u2082.Finite\n  /-- `M\u2081` contains at least 2 elements -/\n  M\u2081card : M\u2081.E.encard \u2265 2\n  /-- `M\u2082` contains at least 2 elements -/\n  M\u2082card : M\u2082.E.encard \u2265 2\n  /-- `M\u2081` and `M\u2082` have exactly one element in common -/\n  interSingleton : (M\u2081.E \u2229 M\u2082.E).encard = 1\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2081` -/\n  M\u2081sep : \u00acM\u2081.Separator (M\u2081.E \u2229 M\u2082.E)\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2082` -/\n  M\u2082sep : \u00acM\u2082.Separator (M\u2081.E \u2229 M\u2082.E)\n\n-- question: can avoid this assumption? -- which assumption? the finiteness?\n\n/-- Ground set of `M\u2081 \u2295\u2082 M\u2082` -/\ndef twoSumGround (M\u2081 M\u2082 : Matroid \u03b1) : Set \u03b1 :=\n  (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)\n\n/-- Type 1 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2081` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType1 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 2 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2082` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType2 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2082.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 3 of circuits in `M\u2081 \u2295\u2082 M\u2082`:\n    sets `(C\u2081 \u222a C\u2082) \\ (M\u2081.E \u2229 M\u2082.E)` where `C\u2081` and `C\u2082` are circuits in `M\u2081` and `M\u2082`, respectively,\n    and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2081` and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2082` -/\ndef TwoSumCircuitType3 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit ((C \u2229 M\u2081.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 M\u2082.Circuit ((C \u2229 M\u2082.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 C \u2286 twoSumGround M\u2081 M\u2082\n\n/-- Circuit predicate of `M\u2081 \u2295\u2082 M\u2082`, which defines 2-sum as `CircuitMatroid` -/\ndef TwoSumCircuitPred (M\u2081 M\u2082 : Matroid \u03b1) : CircuitPredicate \u03b1 :=\n  fun C : Set \u03b1 =>\n    TwoSumCircuitType1 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType2 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType3 M\u2081 M\u2082 C\n\nend MainDefinitions\n\n\nsection PropertiesAssumptions\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1}\n\n/-- 2-sum assumptions are symmetric -/\nlemma TwoSumAssumptions.symm (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    TwoSumAssumptions M\u2082 M\u2081 :=\n  \u27e8\n    assumptions.M\u2082fin,\n    assumptions.M\u2081fin,\n    assumptions.M\u2082card,\n    assumptions.M\u2081card,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.interSingleton,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2082sep,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2081sep,\n  \u27e9\n\n/-- Intersection of ground sets is nonempty -/\nlemma TwoSumAssumptions.inter_nonempty (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (M\u2081.E \u2229 M\u2082.E).Nonempty :=\n  Set.one_le_encard_iff_nonempty.\u2192 assumptions.interSingleton.symm.le\n\n/-- Intersection of ground sets is a singleton set -/\nlemma TwoSumAssumptions.inter_singleton (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    \u2203 p : \u03b1, M\u2081.E \u2229 M\u2082.E = {p} :=\n  Set.encard_eq_one.\u2192 assumptions.interSingleton\n\nvariable {p : \u03b1}\n\n/-- Singleton element in intersection of ground sets in not a loop in `M\u2081` -/\nlemma TwoSumAssumptions.inter_singleton_not_loop_M\u2081 (assumptions : TwoSumAssumptions M\u2081 M\u2082)\n    (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2081.Loop p) :=\n  (hp \u25b8 assumptions.M\u2081sep <| Matroid.separator_loop \u00b7)\n\n", "theoremStatement": "/-- Singleton element in intersection of ground sets in not a coloop in `M\u2081` -/\nlemma TwoSumAssumptions.inter_singleton_not_coloop_M\u2081 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2081.Coloop p) ", "theoremName": "TwoSumAssumptions.inter_singleton_not_coloop_M\u2081", "fileCreated": {"commit": "d0eaaa305c96cd81ac061f505a81614db6856b21", "date": "2025-01-09"}, "theoremCreated": {"commit": "439c72996f29168161b974bc602629cac773728f", "date": "2025-01-08"}, "file": "Seymour/Seymour/Matroid/Operations/Sum2/Basic.lean", "module": "Seymour.Matroid.Operations.Sum2.Basic", "jsonFile": "Seymour.Matroid.Operations.Sum2.Basic.jsonl", "positionMetadata": {"lineInFile": 101, "tokenPositionInFile": 3554, "theoremPositionInFile": 9}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 5, "numPremises": 15}, "proofMetadata": {"hasProof": true, "proof": ":=\n  (hp \u25b8 assumptions.M\u2081sep <| Matroid.separator_coloop \u00b7)", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 59}}
{"srcContext": "import Mathlib.Data.Matroid.Closure\nimport Seymour.Basic\n\n-- we should use https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Data/Matroid/Circuit.lean instead\n\nvariable {\u03b1 : Type}\n\n/-- Circuit is minimal dependent subset. -/\ndef Matroid.Circuit (M : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  Minimal M.Dep C\n\n/-- Every circuit is dependent. -/\nlemma Matroid.Circuit.dep (M : Matroid \u03b1) {C : Set \u03b1} (hC : M.Circuit C) : M.Dep C :=\n  hC.left\n\n/-- Every circuit is a subset of the ground set. -/\nlemma Matroid.Circuit.subset_ground (M : Matroid \u03b1) {C : Set \u03b1} (hC : M.Circuit C) : C \u2286 M.E :=\n  hC.left.right\n\n/-- Equivalence with explicit definition of circuits. -/\nlemma Matroid.circuit_iff_def (M : Matroid \u03b1) (C : Set \u03b1) :\n    M.Circuit C \u2194 M.Dep C \u2227 \u2200 C' : Set \u03b1, M.Dep C' \u2192 C' \u2286 C \u2192 C \u2286 C' :=\n  rfl.to_iff\n\n/-- Every strict subset of a circuit is independent. -/\nlemma Matroid.Circuit.indep_ssub {M : Matroid \u03b1} {C C' : Set \u03b1} (hC : M.Circuit C) (hC' : C' \u2282 C) :\n    M.Indep C' := by\n  by_contra notIndep_M_C'\n  have C'_sub_C : C' \u2286 C := subset_of_ssubset hC'\n  have C_sub_E : C \u2286 M.E := hC.subset_ground\n  have C'_sub_E : C' \u2286 M.E := hC'.subset.trans C_sub_E\n  exact hC'.ne.symm ((hC.right (M.dep_of_not_indep notIndep_M_C' C'_sub_E) C'_sub_C).antisymm C'_sub_C)\n\n/-- Deleting one element from a circuit produces an independent set. -/\nlemma Matroid.Circuit.indep_diff_singleton {M : Matroid \u03b1} {C : Set \u03b1} {a : \u03b1} (hC : M.Circuit C) (ha : a \u2208 C) :\n    M.Indep (C \\ {a}) :=\n  hC.indep_ssub (Set.diff_singleton_sSubset.\u2190 ha)\n\n/-- Empty set is not a circuit. -/\nlemma Matroid.Circuit.not_empty {M : Matroid \u03b1} (hM : M.Circuit \u2205) : False :=\n  hM.left.left M.empty_indep\n\n/-- Every circuit is nonempty. -/\nlemma Matroid.Circuit.nonempty {M : Matroid \u03b1} {C : Set \u03b1} (hC : M.Circuit C) : C.Nonempty := by\n  by_contra! C_empty\n  rw [C_empty] at hC\n  exact hC.not_empty\n\n/-- Independent set is not a circuit. -/\nlemma Matroid.Indep.not_circuit {M : Matroid \u03b1} {I : Set \u03b1} (hI : M.Indep I) : \u00ac(M.Circuit I) :=\n  (\u00b7.left.left hI)\n\n/-- No circuit is a subset of another circuit -/\nlemma Matroid.Circuit.not_ssubset_circuit {M : Matroid \u03b1} {C C' : Set \u03b1} (hC : M.Circuit C) (hC' : M.Circuit C') :\n    \u00ac(C \u2282 C') :=\n  fun hCC => hCC.right (hC'.right hC.left hCC.subset)\n\n", "theoremStatement": "/-- Strict subset of a circuit is not a circuit. -/\nlemma Matroid.Circuit.ssubset_not_circuit {M : Matroid \u03b1} {C C' : Set \u03b1} (hC : M.Circuit C) (hC' : C' \u2282 C) :\n    \u00ac(M.Circuit C') ", "theoremName": "Matroid.Circuit.ssubset_not_circuit", "fileCreated": {"commit": "b44bff2f1ee71349fa9fa251579a0f5a0e575538", "date": "2024-12-19"}, "theoremCreated": {"commit": "ee35fddd27b04eb576eb64b8bb74af513408f6ef", "date": "2024-12-21"}, "file": "Seymour/Seymour/Matroid/Notions/Circuit.lean", "module": "Seymour.Matroid.Notions.Circuit", "jsonFile": "Seymour.Matroid.Notions.Circuit.jsonl", "positionMetadata": {"lineInFile": 58, "tokenPositionInFile": 2272, "theoremPositionInFile": 10}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 7}, "proofMetadata": {"hasProof": true, "proof": ":=\n  (\u00b7.not_ssubset_circuit hC hC')", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 35}}
{"srcContext": "import Mathlib.Data.Matroid.Basic\nimport Mathlib.Data.Matroid.Dual\n\nimport Seymour.Matroid.Constructors.VectorMatroid\nimport Seymour.Matroid.Classes.Regular\n\n\nsection IsGraphic\n\n/-- todo: desc -/\n-- oriented incidence matrix of some graph, i.e.:\n-- * one row for each vertex, and one column for each edge\n-- * in each column, either: 1x `+1`, 1x `-1`, and `0` elsewhere\n-- todo: unit and zero columns representing loops\ndef Matrix.IsGraphic {m n : Type} (A : Matrix m n \u211a) : Prop :=\n  \u2200 y : n, \u2203 x\u2081 x\u2082 : m, A x\u2081 y = 1 \u2227 A x\u2082 y = -1 \u2227 \u2200 x : m, x \u2260 x\u2081 \u2192 x \u2260 x\u2082 \u2192 A x y = 0\n\n/-- Matroid is graphic iff it is represented by an incidence matrix of a graph. -/\ndef Matroid.IsGraphic {\u03b1 : Type} [DecidableEq \u03b1] (M : Matroid \u03b1) : Prop :=\n  \u2203 X Y : Type, \u2203 _ : Fintype Y, \u2203 A : Matrix X Y \u211a, M.IsRepresentedBy A \u2227 A.IsGraphic\n\n/-- Graphic matroid can be represented only by a TU matrix. -/\nlemma Matroid.IsRepresentedBy.isTotallyUnimodular_of_isGraphic {\u03b1 X Y : Type} [DecidableEq \u03b1] {M : Matroid \u03b1}\n    [Fintype Y] {A : Matrix X Y \u211a} (hMA : M.IsRepresentedBy A) (hA : A.IsGraphic) :\n    A.IsTotallyUnimodular := by\n  sorry\n\n", "theoremStatement": "/-- Graphic matroid is regular. -/\nlemma Matroid.IsGraphic.isRegular {\u03b1 : Type} [DecidableEq \u03b1] {M : Matroid \u03b1} (hM : M.IsGraphic) :\n    M.IsRegular ", "theoremName": "Matroid.IsGraphic.isRegular", "fileCreated": {"commit": "2d1a3fae44547e6345fe578dcc09d47887797f9b", "date": "2025-01-08"}, "theoremCreated": {"commit": "eeca78b8370f4fb233777bcd872c3ecf81e93418", "date": "2025-01-09"}, "file": "Seymour/Seymour/Matroid/Classes/Graphic.lean", "module": "Seymour.Matroid.Classes.Graphic", "jsonFile": "Seymour.Matroid.Classes.Graphic.jsonl", "positionMetadata": {"lineInFile": 28, "tokenPositionInFile": 1116, "theoremPositionInFile": 3}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 7, "numPremises": 29}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [Matroid.isRegular_iff_hasTuRepr]\n  obtain \u27e8X, Y, hY, A, hMA, hA\u27e9 := hM\n  exact \u27e8X, _, _, A, hMA.isTotallyUnimodular_of_isGraphic hA, hMA\u27e9", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 149}}
{"srcContext": "import Seymour.Matroid.Classes.Binary\nimport Seymour.Matroid.Constructors.CircuitMatroid\nimport Seymour.Matroid.Notions.DisjointCircuitFamily\n\n\nvariable {\u03b1 : Type}\n\n\nsection BasicDefinitions\n\n/-- Circuits in `M\u2081 \u0394 M\u2082` are nonempty subsets of the ground set of form `X\u2081 \u0394 X\u2082`\n    where `X\u2081` and `X\u2082` are disjoint unions of circuits in `M\u2081` and `M\u2082` respectively. -/\ndef DeltaSumCircuitsAux [DecidableEq \u03b1] (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C X\u2081 X\u2082 : Set \u03b1) : Prop :=\n  C = (X\u2081 \u222a X\u2082) \\ (X\u2081 \u2229 X\u2082) \u2227 M\u2081.toMatroid.IsUnionDisjointCircuits X\u2081 \u2227 M\u2082.toMatroid.IsUnionDisjointCircuits X\u2082\n\n/-- A set satisfies circuit form if for some `X\u2081` and `X\u2082` it has the form above. -/\ndef DeltaSumCircuitForm [DecidableEq \u03b1] (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C : Set \u03b1) : Prop :=\n  C.Nonempty \u2227 C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E) \u2227 \u2203 X\u2081 X\u2082 : Set \u03b1, DeltaSumCircuitsAux M\u2081 M\u2082 C X\u2081 X\u2082\n\n/-- Circuits of \u0394-sum are minimal non-empty subsets of `M\u2081.E \u0394 M\u2082.E` of the form `X\u2081 \u0394 X\u2082`\n    where `X\u2081` and `X\u2082` is a disjoint union of circuits of `M\u2081` and `M\u2082` respectively. -/\ndef DeltaSumCircuitPred [DecidableEq \u03b1] (M\u2081 M\u2082 : BinaryMatroid \u03b1) : CircuitPredicate \u03b1 :=\n  Minimal (DeltaSumCircuitForm M\u2081 M\u2082)\n\nend BasicDefinitions\n\n\nsection BasicProperties\n\n/-- A set of circuit form is nonempty. -/\nlemma deltaSumCircuitForm.nonempty [DecidableEq \u03b1] {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm M\u2081 M\u2082 C) :\n    C.Nonempty :=\n  hC.left\n\n/-- A set of circuit form is a subset of the ground set. -/\nlemma DeltaSumCircuitForm.subset_ground [DecidableEq \u03b1] {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm M\u2081 M\u2082 C) :\n    C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E) :=\n  hC.right.left\n\n", "theoremStatement": "/-- A set of circuit form is the symmetric difference of `X\u2081` and `X\u2082` -/\nlemma DeltaSumCircuitsAux.eq_symmDiff [DecidableEq \u03b1] {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C X\u2081 X\u2082 : Set \u03b1}\n    (hC : DeltaSumCircuitsAux M\u2081 M\u2082 C X\u2081 X\u2082) :\n    C = (X\u2081 \u222a X\u2082) \\ (X\u2081 \u2229 X\u2082) ", "theoremName": "DeltaSumCircuitsAux.eq_symmDiff", "fileCreated": {"commit": "aae07a69b2ec95e3d9a1436952a123dcb7d0d06f", "date": "2025-01-03"}, "theoremCreated": {"commit": "67629d2b74be7b972786897531b678f585a7af28", "date": "2025-02-03"}, "file": "Seymour/Seymour/Matroid/Operations/SumDelta/Basic.lean", "module": "Seymour.Matroid.Operations.SumDelta.Basic", "jsonFile": "Seymour.Matroid.Operations.SumDelta.Basic.jsonl", "positionMetadata": {"lineInFile": 42, "tokenPositionInFile": 1660, "theoremPositionInFile": 5}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 5, "numPremises": 24}, "proofMetadata": {"hasProof": true, "proof": ":=\n  hC.left", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 12}}
{"srcContext": "import Seymour.Matroid.Operations.MatrixSums.BinaryMatroids\n\n/-!\nThis file contains everything about 3-sum of binary matroids \u2014 the old version (in terms of explicit matrices).\n-/\n\nvariable {\u03b1 : Type}\n\n/-- `Matrix`-level 3-sum for matroids defined by their standard representation matrices; does not check legitimacy. -/\nnoncomputable abbrev Matrix_3sumComposition {\u03b2 : Type} [CommRing \u03b2] {X\u2081 Y\u2081 X\u2082 Y\u2082 : Set \u03b1}\n    (A\u2081 : Matrix X\u2081 (Y\u2081 \u2295 Fin 2) \u03b2) (A\u2082 : Matrix (Fin 2 \u2295 X\u2082) Y\u2082 \u03b2)\n    (z\u2081 : Y\u2081 \u2192 \u03b2) (z\u2082 : X\u2082 \u2192 \u03b2) (D : Matrix (Fin 2) (Fin 2) \u03b2) (D\u2081 : Matrix (Fin 2) Y\u2081 \u03b2) (D\u2082 : Matrix X\u2082 (Fin 2) \u03b2) :\n    Matrix ((X\u2081 \u2295 Unit) \u2295 (Fin 2 \u2295 X\u2082)) ((Y\u2081 \u2295 Fin 2) \u2295 (Unit \u2295 Y\u2082)) \u03b2 :=\n  -- Unfortunately `Ring.inverse` is `noncomputable` and upgrading `\u03b2` to `Field` does not help.\n  let D\u2081\u2082 : Matrix X\u2082 Y\u2081 \u03b2 := D\u2082 * D\u207b\u00b9 * D\u2081\n  Matrix.fromBlocks\n    (Matrix.fromRows A\u2081 (Matrix.row Unit (Sum.elim z\u2081 ![1, 1]))) 0\n    (Matrix.fromBlocks D\u2081 D D\u2081\u2082 D\u2082) (Matrix.fromCols (Matrix.col Unit (Sum.elim ![1, 1] z\u2082)) A\u2082)\n\nvariable [DecidableEq \u03b1] {M\u2081 M\u2082 : StandardRepresentation \u03b1}\n\n/-- `StandardRepresentation`-level 3-sum of two matroids.\nThe second part checks legitimacy (invertibility of a certain 2x2 submatrix and specific 1s and 0s on concrete positions). -/\nnoncomputable def StandardRepresentation_3sum {x\u2081 x\u2082 x\u2083 y\u2081 y\u2082 y\u2083 : \u03b1}\n    (hXX : M\u2081.X \u2229 M\u2082.X = {x\u2081, x\u2082, x\u2083}) (hYY : M\u2081.Y \u2229 M\u2082.Y = {y\u2081, y\u2082, y\u2083}) (hXY : M\u2081.X \u2ad7 M\u2082.Y) (hYX : M\u2081.Y \u2ad7 M\u2082.X) :\n    StandardRepresentation \u03b1 \u00d7 Prop :=\n  have hxxx\u2081 : {x\u2081, x\u2082, x\u2083} \u2286 M\u2081.X := hXX.symm.subset.trans Set.inter_subset_left\n  have hxxx\u2082 : {x\u2081, x\u2082, x\u2083} \u2286 M\u2082.X := hXX.symm.subset.trans Set.inter_subset_right\n  have hyyy\u2081 : {y\u2081, y\u2082, y\u2083} \u2286 M\u2081.Y := hYY.symm.subset.trans Set.inter_subset_left\n  have hyyy\u2082 : {y\u2081, y\u2082, y\u2083} \u2286 M\u2082.Y := hYY.symm.subset.trans Set.inter_subset_right\n  have x\u2081inX\u2081 : x\u2081 \u2208 M\u2081.X := hxxx\u2081 (Set.mem_insert x\u2081 {x\u2082, x\u2083})\n  have x\u2081inX\u2082 : x\u2081 \u2208 M\u2082.X := hxxx\u2082 (Set.mem_insert x\u2081 {x\u2082, x\u2083})\n  have x\u2082inX\u2081 : x\u2082 \u2208 M\u2081.X := hxxx\u2081 (Set.insert_comm x\u2081 x\u2082 {x\u2083} \u25b8 Set.mem_insert x\u2082 {x\u2081, x\u2083})\n  have x\u2082inX\u2082 : x\u2082 \u2208 M\u2082.X := hxxx\u2082 (Set.insert_comm x\u2081 x\u2082 {x\u2083} \u25b8 Set.mem_insert x\u2082 {x\u2081, x\u2083})\n  have x\u2083inX\u2081 : x\u2083 \u2208 M\u2081.X := hxxx\u2081 (by simp)\n  have x\u2083inX\u2082 : x\u2083 \u2208 M\u2082.X := hxxx\u2082 (by simp)\n  have y\u2083inY\u2081 : y\u2083 \u2208 M\u2081.Y := hyyy\u2081 (by simp)\n  have y\u2083inY\u2082 : y\u2083 \u2208 M\u2082.Y := hyyy\u2082 (by simp)\n  have y\u2082inY\u2081 : y\u2082 \u2208 M\u2081.Y := hyyy\u2081 (Set.insert_comm y\u2081 y\u2082 {y\u2083} \u25b8 Set.mem_insert y\u2082 {y\u2081, y\u2083})\n  have y\u2082inY\u2082 : y\u2082 \u2208 M\u2082.Y := hyyy\u2082 (Set.insert_comm y\u2081 y\u2082 {y\u2083} \u25b8 Set.mem_insert y\u2082 {y\u2081, y\u2083})\n  have y\u2081inY\u2081 : y\u2081 \u2208 M\u2081.Y := hyyy\u2081 (Set.mem_insert y\u2081 {y\u2082, y\u2083})\n  have y\u2081inY\u2082 : y\u2081 \u2208 M\u2082.Y := hyyy\u2082 (Set.mem_insert y\u2081 {y\u2082, y\u2083})\n  -- The actual definition starts here:\n  let A\u2081 : Matrix (M\u2081.X \\ {x\u2081, x\u2082, x\u2083}).Elem ((M\u2081.Y \\ {y\u2081, y\u2082, y\u2083}).Elem \u2295 Fin 2) Z2 := -- the top left submatrix\n    Matrix.of (fun i j => M\u2081.B\n        \u27e8i.val, Set.mem_of_mem_diff i.property\u27e9\n        (j.casesOn (fun j' => \u27e8j'.val, Set.mem_of_mem_diff j'.property\u27e9) ![\u27e8y\u2082, y\u2082inY\u2081\u27e9, \u27e8y\u2081, y\u2081inY\u2081\u27e9]))\n  let A\u2082 : Matrix (Fin 2 \u2295 (M\u2082.X \\ {x\u2081, x\u2082, x\u2083}).Elem) (M\u2082.Y \\ {y\u2081, y\u2082, y\u2083}).Elem Z2 := -- the bottom right submatrix\n    Matrix.of (fun i j => M\u2082.B\n        (i.casesOn ![\u27e8x\u2082, x\u2082inX\u2082\u27e9, \u27e8x\u2083, x\u2083inX\u2082\u27e9] (fun i' => \u27e8i'.val, Set.mem_of_mem_diff i'.property\u27e9))\n        \u27e8j.val, Set.mem_of_mem_diff j.property\u27e9)\n  let z\u2081 : (M\u2081.Y \\ {y\u2081, y\u2082, y\u2083}).Elem \u2192 Z2 := -- the middle left \"row vector\"\n    (fun j => M\u2081.B \u27e8x\u2081, x\u2081inX\u2081\u27e9 \u27e8j.val, Set.mem_of_mem_diff j.property\u27e9)\n  let z\u2082 : (M\u2082.X \\ {x\u2081, x\u2082, x\u2083}).Elem \u2192 Z2 := -- the bottom middle \"column vector\"\n    (fun i => M\u2082.B \u27e8i.val, Set.mem_of_mem_diff i.property\u27e9 \u27e8y\u2083, y\u2083inY\u2082\u27e9)\n  let D_\u2081 : Matrix (Fin 2) (Fin 2) Z2 := -- the bottom middle 2x2 submatrix\n    Matrix.of (fun i j => M\u2081.B (![\u27e8x\u2082, x\u2082inX\u2081\u27e9, \u27e8x\u2083, x\u2083inX\u2081\u27e9] i) (![\u27e8y\u2082, y\u2082inY\u2081\u27e9, \u27e8y\u2081, y\u2081inY\u2081\u27e9] j))\n  let D_\u2082 : Matrix (Fin 2) (Fin 2) Z2 := -- the middle left 2x2 submatrix\n    Matrix.of (fun i j => M\u2082.B (![\u27e8x\u2082, x\u2082inX\u2082\u27e9, \u27e8x\u2083, x\u2083inX\u2082\u27e9] i) (![\u27e8y\u2082, y\u2082inY\u2082\u27e9, \u27e8y\u2081, y\u2081inY\u2082\u27e9] j))\n  let D\u2081 : Matrix (Fin 2) (M\u2081.Y \\ {y\u2081, y\u2082, y\u2083}).Elem Z2 := -- the bottom left submatrix\n    Matrix.of (fun i j => M\u2081.B (![\u27e8x\u2082, x\u2082inX\u2081\u27e9, \u27e8x\u2083, x\u2083inX\u2081\u27e9] i) \u27e8j.val, Set.mem_of_mem_diff j.property\u27e9)\n  let D\u2082 : Matrix (M\u2082.X \\ {x\u2081, x\u2082, x\u2083}).Elem (Fin 2) Z2 := -- the bottom left submatrix\n    Matrix.of (fun i j => M\u2082.B \u27e8i.val, Set.mem_of_mem_diff i.property\u27e9 (![\u27e8y\u2082, y\u2082inY\u2082\u27e9, \u27e8y\u2081, y\u2081inY\u2082\u27e9] j))\n  \u27e8\n    \u27e8\n      (M\u2081.X \\ {x\u2081, x\u2082, x\u2083}) \u222a M\u2082.X,\n      M\u2081.Y \u222a (M\u2082.Y \\ {y\u2081, y\u2082, y\u2083}),\n      inferInstance,\n      inferInstance,\n      by\n        rw [Set.disjoint_union_right, Set.disjoint_union_left, Set.disjoint_union_left]\n        exact\n          \u27e8\u27e8M\u2081.hXY.disjoint_sdiff_left, hYX.symm\u27e9, \u27e8hXY.disjoint_sdiff_right.disjoint_sdiff_left, M\u2082.hXY.disjoint_sdiff_right\u27e9\u27e9,\n      Matrix.of (fun i j =>\n        Matrix_3sumComposition A\u2081 A\u2082 z\u2081 z\u2082 D_\u2081 D\u2081 D\u2082 (\n          if hi\u2081 : i.val \u2208 M\u2081.X \\ {x\u2081, x\u2082, x\u2083} then Sum.inl (Sum.inl \u27e8i, hi\u2081\u27e9) else\n          if hi\u2082 : i.val \u2208 M\u2082.X \\ {x\u2081, x\u2082, x\u2083} then Sum.inr (Sum.inr \u27e8i, hi\u2082\u27e9) else\n          if hx\u2081 : i.val = x\u2081 then Sum.inl (Sum.inr ()) else\n          if hx\u2082 : i.val = x\u2082 then Sum.inr (Sum.inl 0) else\n          if hx\u2083 : i.val = x\u2083 then Sum.inr (Sum.inl 1) else\n          (i.property.elim hi\u2081 (by simp_all)).elim\n          -- TODO can `Matrix.toMatrixUnionUnion` be combined with something else to simplify this definition?\n        ) (\n          if hj\u2081 : j.val \u2208 M\u2081.Y \\ {y\u2081, y\u2082, y\u2083} then Sum.inl (Sum.inl \u27e8j, hj\u2081\u27e9) else\n          if hj\u2082 : j.val \u2208 M\u2082.Y \\ {y\u2081, y\u2082, y\u2083} then Sum.inr (Sum.inr \u27e8j, hj\u2082\u27e9) else\n          if hy\u2081 : j.val = y\u2081 then Sum.inl (Sum.inr 1) else\n          if hy\u2082 : j.val = y\u2082 then Sum.inl (Sum.inr 0) else\n          if hy\u2083 : j.val = y\u2083 then Sum.inr (Sum.inl ()) else\n          (j.property.elim (by simp_all) hj\u2082).elim\n        )\n      )\n    \u27e9,\n    IsUnit D_\u2081 \u2227 D_\u2081 = D_\u2082 -- the matrix `D_\u2081 = D_\u2082` (called D-bar in the book) is invertible\n    \u2227 M\u2081.B \u27e8x\u2081, x\u2081inX\u2081\u27e9 \u27e8y\u2081, y\u2081inY\u2081\u27e9 = 1\n    \u2227 M\u2081.B \u27e8x\u2081, x\u2081inX\u2081\u27e9 \u27e8y\u2082, y\u2082inY\u2081\u27e9 = 1\n    \u2227 M\u2081.B \u27e8x\u2082, x\u2082inX\u2081\u27e9 \u27e8y\u2083, y\u2083inY\u2081\u27e9 = 1\n    \u2227 M\u2081.B \u27e8x\u2083, x\u2083inX\u2081\u27e9 \u27e8y\u2083, y\u2083inY\u2081\u27e9 = 1\n    \u2227 M\u2082.B \u27e8x\u2081, x\u2081inX\u2082\u27e9 \u27e8y\u2081, y\u2081inY\u2082\u27e9 = 1\n    \u2227 M\u2082.B \u27e8x\u2081, x\u2081inX\u2082\u27e9 \u27e8y\u2082, y\u2082inY\u2082\u27e9 = 1\n    \u2227 M\u2082.B \u27e8x\u2082, x\u2082inX\u2082\u27e9 \u27e8y\u2083, y\u2083inY\u2082\u27e9 = 1\n    \u2227 M\u2082.B \u27e8x\u2083, x\u2083inX\u2082\u27e9 \u27e8y\u2083, y\u2083inY\u2082\u27e9 = 1\n    \u2227 (\u2200 x : \u03b1, \u2200 hx : x \u2208 M\u2081.X, x \u2260 x\u2082 \u2227 x \u2260 x\u2083 \u2192 M\u2081.B \u27e8x, hx\u27e9 \u27e8y\u2083, y\u2083inY\u2081\u27e9 = 0) -- the rest of the rightmost column is `0`s\n    \u2227 (\u2200 y : \u03b1, \u2200 hy : y \u2208 M\u2082.Y, y \u2260 y\u2082 \u2227 y \u2260 y\u2081 \u2192 M\u2082.B \u27e8x\u2081, x\u2081inX\u2082\u27e9 \u27e8y, hy\u27e9 = 0) -- the rest of the topmost row is `0`s\n  \u27e9\n\n/-- Binary matroid `M` is a result of 3-summing `M\u2081` and `M\u2082` in some way. -/\ndef StandardRepresentation.Is3sumOf (M : StandardRepresentation \u03b1) (M\u2081 M\u2082 : StandardRepresentation \u03b1) : Prop :=\n  \u2203 x\u2081 x\u2082 x\u2083 y\u2081 y\u2082 y\u2083 : \u03b1,\n    \u2203 hXX : M\u2081.X \u2229 M\u2082.X = {x\u2081, x\u2082, x\u2083}, \u2203 hYY : M\u2081.Y \u2229 M\u2082.Y = {y\u2081, y\u2082, y\u2083}, \u2203 hXY : M\u2081.X \u2ad7 M\u2082.Y, \u2203 hYX : M\u2081.Y \u2ad7 M\u2082.X,\n      let M\u2080 := StandardRepresentation_3sum hXX hYY hXY hYX\n      M.toMatroid = M\u2080.fst.toMatroid \u2227 M\u2080.snd\n\nvariable {M : StandardRepresentation \u03b1}\n\n-- API for access to individual assumptions and identities in the definition of 3-sum\n\nlemma StandardRepresentation.Is3sumOf.interXX (hM : M.Is3sumOf M\u2081 M\u2082) :\n    \u2203 x\u2081 x\u2082 x\u2083 : \u03b1, M\u2081.X \u2229 M\u2082.X = {x\u2081, x\u2082, x\u2083} := by\n  obtain \u27e8x\u2081, x\u2082, x\u2083, -, -, -, hXX, -\u27e9 := hM\n  exact \u27e8x\u2081, x\u2082, x\u2083, hXX\u27e9\n\n", "theoremStatement": "lemma StandardRepresentation.Is3sumOf.interYY (hM : M.Is3sumOf M\u2081 M\u2082) :\n    \u2203 y\u2081 y\u2082 y\u2083 : \u03b1, M\u2081.Y \u2229 M\u2082.Y = {y\u2081, y\u2082, y\u2083} ", "theoremName": "StandardRepresentation.Is3sumOf.interYY", "fileCreated": {"commit": "614ecc7fe89749171933326a0f077e8d8a24cecb", "date": "2025-02-03"}, "theoremCreated": {"commit": "74722a3f54befb275eb7729e168db1478932de5e", "date": "2024-12-05"}, "file": "Seymour/Seymour/Matroid/Operations/MatrixSums/Sum3.lean", "module": "Seymour.Matroid.Operations.MatrixSums.Sum3", "jsonFile": "Seymour.Matroid.Operations.MatrixSums.Sum3.jsonl", "positionMetadata": {"lineInFile": 122, "tokenPositionInFile": 7127, "theoremPositionInFile": 4}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 6, "numPremises": 33}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  obtain \u27e8-, -, -, y\u2081, y\u2082, y\u2083, -, hYY, -\u27e9 := hM\n  exact \u27e8y\u2081, y\u2082, y\u2083, hYY\u27e9", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 79}}
{"srcContext": "import Mathlib.Data.Set.Card\nimport Mathlib.Data.Matroid.Dual\n\nimport Seymour.ForMathlib.SetTheory\nimport Seymour.Matroid.Notions.Circuit\nimport Seymour.Matroid.Notions.CircuitAxioms\nimport Seymour.Matroid.Notions.Connectivity\nimport Seymour.Matroid.Constructors.CircuitMatroid\n\n/-!\nThis file defines 2-sum of two (general) matroids `M\u2081` and `M\u2082`, denoted as `M\u2081 \u2295\u2082 M\u2082`.\n-/\n\nvariable {\u03b1 : Type}\n\n\nsection MainDefinitions\n\n/-- `M\u2081 \u2295\u2082 M\u2082` is defined if `M\u2081` and `M\u2082` satisfy the following assumptions -/\nstructure TwoSumAssumptions (M\u2081 M\u2082 : Matroid \u03b1) : Prop where\n  /-- `M\u2081` is finite -/\n  M\u2081fin : M\u2081.Finite\n  /-- `M\u2082` is finite -/\n  M\u2082fin : M\u2082.Finite\n  /-- `M\u2081` contains at least 2 elements -/\n  M\u2081card : M\u2081.E.encard \u2265 2\n  /-- `M\u2082` contains at least 2 elements -/\n  M\u2082card : M\u2082.E.encard \u2265 2\n  /-- `M\u2081` and `M\u2082` have exactly one element in common -/\n  interSingleton : (M\u2081.E \u2229 M\u2082.E).encard = 1\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2081` -/\n  M\u2081sep : \u00acM\u2081.Separator (M\u2081.E \u2229 M\u2082.E)\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2082` -/\n  M\u2082sep : \u00acM\u2082.Separator (M\u2081.E \u2229 M\u2082.E)\n\n-- question: can avoid this assumption? -- which assumption? the finiteness?\n\n/-- Ground set of `M\u2081 \u2295\u2082 M\u2082` -/\ndef twoSumGround (M\u2081 M\u2082 : Matroid \u03b1) : Set \u03b1 :=\n  (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)\n\n/-- Type 1 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2081` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType1 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 2 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2082` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType2 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2082.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 3 of circuits in `M\u2081 \u2295\u2082 M\u2082`:\n    sets `(C\u2081 \u222a C\u2082) \\ (M\u2081.E \u2229 M\u2082.E)` where `C\u2081` and `C\u2082` are circuits in `M\u2081` and `M\u2082`, respectively,\n    and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2081` and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2082` -/\ndef TwoSumCircuitType3 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit ((C \u2229 M\u2081.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 M\u2082.Circuit ((C \u2229 M\u2082.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 C \u2286 twoSumGround M\u2081 M\u2082\n\n/-- Circuit predicate of `M\u2081 \u2295\u2082 M\u2082`, which defines 2-sum as `CircuitMatroid` -/\ndef TwoSumCircuitPred (M\u2081 M\u2082 : Matroid \u03b1) : CircuitPredicate \u03b1 :=\n  fun C : Set \u03b1 =>\n    TwoSumCircuitType1 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType2 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType3 M\u2081 M\u2082 C\n\nend MainDefinitions\n\n\nsection PropertiesAssumptions\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1}\n\n/-- 2-sum assumptions are symmetric -/\nlemma TwoSumAssumptions.symm (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    TwoSumAssumptions M\u2082 M\u2081 :=\n  \u27e8\n    assumptions.M\u2082fin,\n    assumptions.M\u2081fin,\n    assumptions.M\u2082card,\n    assumptions.M\u2081card,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.interSingleton,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2082sep,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2081sep,\n  \u27e9\n\n/-- Intersection of ground sets is nonempty -/\nlemma TwoSumAssumptions.inter_nonempty (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (M\u2081.E \u2229 M\u2082.E).Nonempty :=\n  Set.one_le_encard_iff_nonempty.\u2192 assumptions.interSingleton.symm.le\n\n/-- Intersection of ground sets is a singleton set -/\nlemma TwoSumAssumptions.inter_singleton (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    \u2203 p : \u03b1, M\u2081.E \u2229 M\u2082.E = {p} :=\n  Set.encard_eq_one.\u2192 assumptions.interSingleton\n\nvariable {p : \u03b1}\n\n/-- Singleton element in intersection of ground sets in not a loop in `M\u2081` -/\nlemma TwoSumAssumptions.inter_singleton_not_loop_M\u2081 (assumptions : TwoSumAssumptions M\u2081 M\u2082)\n    (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2081.Loop p) :=\n  (hp \u25b8 assumptions.M\u2081sep <| Matroid.separator_loop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a coloop in `M\u2081` -/\nlemma TwoSumAssumptions.inter_singleton_not_coloop_M\u2081 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2081.Coloop p) :=\n  (hp \u25b8 assumptions.M\u2081sep <| Matroid.separator_coloop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a loop in `M\u2082` -/\nlemma TwoSumAssumptions.inter_singleton_not_loop_M\u2082 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2082.Loop p) :=\n  (hp \u25b8 assumptions.M\u2082sep <| Matroid.separator_loop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a coloop in `M\u2082` -/\nlemma TwoSumAssumptions.inter_singleton_not_coloop_M\u2082 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2082.Coloop p) :=\n  (hp \u25b8 assumptions.M\u2082sep <| Matroid.separator_coloop \u00b7)\n\nend PropertiesAssumptions\n\n\nsection PropertiesGroundSet\n\n/-- Ground set of 2-sum is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma twoSumGround_disjoint_inter (M\u2081 M\u2082 : Matroid \u03b1) :\n    twoSumGround M\u2081 M\u2082 \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  Set.disjoint_sdiff_left\n\n/-- Ground sets minus their intersection are disjoint sets -/\nlemma twoSum_disjoint_grounds_diff_inter (M\u2081 M\u2082 : Matroid \u03b1) :\n    M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) \u2ad7 M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E) := by\n  rw [Set.diff_self_inter, Set.diff_inter_self_eq_diff]\n  exact disjoint_sdiff_sdiff\n\nend PropertiesGroundSet\n\n\nsection PropertiesCircuitType1\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1} {C : Set \u03b1}\n\n/-- Circuit of type 1 is a circuit in `M\u2081` -/\nlemma TwoSumCircuitType1.circuit_M\u2081 (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : M\u2081.Circuit C :=\n  hC.left\n\n/-- Circuit of type 1 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType1.disjoint_inter (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of type 1 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma TwoSumCircuitType1.subset_union (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_left hC.circuit_M\u2081.subset_ground M\u2082.E\n\n/-- Circuit of type 1 lies in ground set of `M\u2081 \u2295\u2082 M\u2082` -/\nlemma TwoSumCircuitType1.subset_ground (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 twoSumGround M\u2081 M\u2082 :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 1 lies in `M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma TwoSumCircuitType1.subset_M\u2081_diff_inter (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2081.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 1 is disjoint with `M\u2082.E` -/\nlemma TwoSumCircuitType1.disjoint_M\u2082 (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2ad7 M\u2082.E := by\n  have hMM := twoSum_disjoint_grounds_diff_inter M\u2081 M\u2082\n  have hCM\u2082 := Set.disjoint_of_subset_left hC.subset_M\u2081_diff_inter hMM\n  have hCM\u2082 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2082, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_right] at hCM\u2082\n  exact hCM\u2082\n\nend PropertiesCircuitType1\n\n\nsection PropertiesCircuitType2\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1} {C : Set \u03b1}\n\n/-- Circuit of type 2 is a circuit in `M\u2082` -/\nlemma TwoSumCircuitType2.circuit_M\u2082 (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : M\u2082.Circuit C :=\n  hC.left\n\n/-- Circuit of type 2 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType2.disjoint_inter (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n", "theoremStatement": "/-- Circuit of type 2 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma TwoSumCircuitType2.subset_union (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \u222a M\u2082.E ", "theoremName": "TwoSumCircuitType2.subset_union", "fileCreated": {"commit": "d0eaaa305c96cd81ac061f505a81614db6856b21", "date": "2025-01-09"}, "theoremCreated": {"commit": "439c72996f29168161b974bc602629cac773728f", "date": "2025-01-08"}, "file": "Seymour/Seymour/Matroid/Operations/Sum2/Basic.lean", "module": "Seymour.Matroid.Operations.Sum2.Basic", "jsonFile": "Seymour.Matroid.Operations.Sum2.Basic.jsonl", "positionMetadata": {"lineInFile": 182, "tokenPositionInFile": 6780, "theoremPositionInFile": 22}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 3, "numPremises": 11}, "proofMetadata": {"hasProof": true, "proof": ":=\n  Set.subset_union_of_subset_right hC.circuit_M\u2082.subset_ground M\u2081.E", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 70}}
{"srcContext": "import Mathlib.Data.Set.Card\nimport Mathlib.Data.Matroid.Dual\n\nimport Seymour.ForMathlib.SetTheory\nimport Seymour.Matroid.Notions.Circuit\nimport Seymour.Matroid.Notions.CircuitAxioms\nimport Seymour.Matroid.Notions.Connectivity\nimport Seymour.Matroid.Constructors.CircuitMatroid\n\n/-!\nThis file defines 2-sum of two (general) matroids `M\u2081` and `M\u2082`, denoted as `M\u2081 \u2295\u2082 M\u2082`.\n-/\n\nvariable {\u03b1 : Type}\n\n\nsection MainDefinitions\n\n/-- `M\u2081 \u2295\u2082 M\u2082` is defined if `M\u2081` and `M\u2082` satisfy the following assumptions -/\nstructure TwoSumAssumptions (M\u2081 M\u2082 : Matroid \u03b1) : Prop where\n  /-- `M\u2081` is finite -/\n  M\u2081fin : M\u2081.Finite\n  /-- `M\u2082` is finite -/\n  M\u2082fin : M\u2082.Finite\n  /-- `M\u2081` contains at least 2 elements -/\n  M\u2081card : M\u2081.E.encard \u2265 2\n  /-- `M\u2082` contains at least 2 elements -/\n  M\u2082card : M\u2082.E.encard \u2265 2\n  /-- `M\u2081` and `M\u2082` have exactly one element in common -/\n  interSingleton : (M\u2081.E \u2229 M\u2082.E).encard = 1\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2081` -/\n  M\u2081sep : \u00acM\u2081.Separator (M\u2081.E \u2229 M\u2082.E)\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2082` -/\n  M\u2082sep : \u00acM\u2082.Separator (M\u2081.E \u2229 M\u2082.E)\n\n-- question: can avoid this assumption? -- which assumption? the finiteness?\n\n/-- Ground set of `M\u2081 \u2295\u2082 M\u2082` -/\ndef twoSumGround (M\u2081 M\u2082 : Matroid \u03b1) : Set \u03b1 :=\n  (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)\n\n/-- Type 1 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2081` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType1 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 2 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2082` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType2 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2082.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 3 of circuits in `M\u2081 \u2295\u2082 M\u2082`:\n    sets `(C\u2081 \u222a C\u2082) \\ (M\u2081.E \u2229 M\u2082.E)` where `C\u2081` and `C\u2082` are circuits in `M\u2081` and `M\u2082`, respectively,\n    and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2081` and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2082` -/\ndef TwoSumCircuitType3 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit ((C \u2229 M\u2081.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 M\u2082.Circuit ((C \u2229 M\u2082.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 C \u2286 twoSumGround M\u2081 M\u2082\n\n/-- Circuit predicate of `M\u2081 \u2295\u2082 M\u2082`, which defines 2-sum as `CircuitMatroid` -/\ndef TwoSumCircuitPred (M\u2081 M\u2082 : Matroid \u03b1) : CircuitPredicate \u03b1 :=\n  fun C : Set \u03b1 =>\n    TwoSumCircuitType1 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType2 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType3 M\u2081 M\u2082 C\n\nend MainDefinitions\n\n\nsection PropertiesAssumptions\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1}\n\n/-- 2-sum assumptions are symmetric -/\nlemma TwoSumAssumptions.symm (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    TwoSumAssumptions M\u2082 M\u2081 :=\n  \u27e8\n    assumptions.M\u2082fin,\n    assumptions.M\u2081fin,\n    assumptions.M\u2082card,\n    assumptions.M\u2081card,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.interSingleton,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2082sep,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2081sep,\n  \u27e9\n\n/-- Intersection of ground sets is nonempty -/\nlemma TwoSumAssumptions.inter_nonempty (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (M\u2081.E \u2229 M\u2082.E).Nonempty :=\n  Set.one_le_encard_iff_nonempty.\u2192 assumptions.interSingleton.symm.le\n\n/-- Intersection of ground sets is a singleton set -/\nlemma TwoSumAssumptions.inter_singleton (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    \u2203 p : \u03b1, M\u2081.E \u2229 M\u2082.E = {p} :=\n  Set.encard_eq_one.\u2192 assumptions.interSingleton\n\nvariable {p : \u03b1}\n\n/-- Singleton element in intersection of ground sets in not a loop in `M\u2081` -/\nlemma TwoSumAssumptions.inter_singleton_not_loop_M\u2081 (assumptions : TwoSumAssumptions M\u2081 M\u2082)\n    (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2081.Loop p) :=\n  (hp \u25b8 assumptions.M\u2081sep <| Matroid.separator_loop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a coloop in `M\u2081` -/\nlemma TwoSumAssumptions.inter_singleton_not_coloop_M\u2081 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2081.Coloop p) :=\n  (hp \u25b8 assumptions.M\u2081sep <| Matroid.separator_coloop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a loop in `M\u2082` -/\nlemma TwoSumAssumptions.inter_singleton_not_loop_M\u2082 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2082.Loop p) :=\n  (hp \u25b8 assumptions.M\u2082sep <| Matroid.separator_loop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a coloop in `M\u2082` -/\nlemma TwoSumAssumptions.inter_singleton_not_coloop_M\u2082 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2082.Coloop p) :=\n  (hp \u25b8 assumptions.M\u2082sep <| Matroid.separator_coloop \u00b7)\n\nend PropertiesAssumptions\n\n\nsection PropertiesGroundSet\n\n/-- Ground set of 2-sum is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma twoSumGround_disjoint_inter (M\u2081 M\u2082 : Matroid \u03b1) :\n    twoSumGround M\u2081 M\u2082 \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  Set.disjoint_sdiff_left\n\n/-- Ground sets minus their intersection are disjoint sets -/\nlemma twoSum_disjoint_grounds_diff_inter (M\u2081 M\u2082 : Matroid \u03b1) :\n    M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) \u2ad7 M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E) := by\n  rw [Set.diff_self_inter, Set.diff_inter_self_eq_diff]\n  exact disjoint_sdiff_sdiff\n\nend PropertiesGroundSet\n\n\nsection PropertiesCircuitType1\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1} {C : Set \u03b1}\n\n/-- Circuit of type 1 is a circuit in `M\u2081` -/\nlemma TwoSumCircuitType1.circuit_M\u2081 (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : M\u2081.Circuit C :=\n  hC.left\n\n/-- Circuit of type 1 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType1.disjoint_inter (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of type 1 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma TwoSumCircuitType1.subset_union (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_left hC.circuit_M\u2081.subset_ground M\u2082.E\n\n/-- Circuit of type 1 lies in ground set of `M\u2081 \u2295\u2082 M\u2082` -/\nlemma TwoSumCircuitType1.subset_ground (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 twoSumGround M\u2081 M\u2082 :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 1 lies in `M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma TwoSumCircuitType1.subset_M\u2081_diff_inter (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2081.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 1 is disjoint with `M\u2082.E` -/\nlemma TwoSumCircuitType1.disjoint_M\u2082 (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2ad7 M\u2082.E := by\n  have hMM := twoSum_disjoint_grounds_diff_inter M\u2081 M\u2082\n  have hCM\u2082 := Set.disjoint_of_subset_left hC.subset_M\u2081_diff_inter hMM\n  have hCM\u2082 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2082, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_right] at hCM\u2082\n  exact hCM\u2082\n\nend PropertiesCircuitType1\n\n\nsection PropertiesCircuitType2\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1} {C : Set \u03b1}\n\n/-- Circuit of type 2 is a circuit in `M\u2082` -/\nlemma TwoSumCircuitType2.circuit_M\u2082 (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : M\u2082.Circuit C :=\n  hC.left\n\n/-- Circuit of type 2 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType2.disjoint_inter (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of type 2 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma TwoSumCircuitType2.subset_union (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_right hC.circuit_M\u2082.subset_ground M\u2081.E\n\n/-- Circuit of type 2 lies in ground set of `M\u2081 \u2295\u2082 M\u2082` -/\nlemma TwoSumCircuitType2.subset_ground (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2286 twoSumGround M\u2081 M\u2082 :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 2 lies in `M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma TwoSumCircuitType2.subset_M\u2082_diff_inter (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2286 M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2082.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 2 is disjoint with `M\u2081.E` -/\nlemma TwoSumCircuitType2.disjoint_M\u2081 (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E := by\n  have hMM := twoSum_disjoint_grounds_diff_inter M\u2081 M\u2082\n  have hCM\u2081 := (Set.disjoint_of_subset_right hC.subset_M\u2082_diff_inter hMM).symm\n  have hCM\u2081 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2081, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_left] at hCM\u2081\n  exact hCM\u2081\n\nend PropertiesCircuitType2\n\n\nsection PropertiesCircuitType3\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1} {C : Set \u03b1}\n\n/-- Circuit of type 3 yields a circuit in `M\u2081` after intersecting it with `M\u2081.E` and adding `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType3.to_circuit_M\u2081 (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : M\u2081.Circuit ((C \u2229 M\u2081.E) \u222a (M\u2081.E \u2229 M\u2082.E)) :=\n  hC.left\n\n/-- Circuit of type 3 yields a circuit in `M\u2082` after intersecting it with `M\u2081.E` and adding `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType3.to_circuit_M\u2082 (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : M\u2082.Circuit ((C \u2229 M\u2082.E) \u222a (M\u2081.E \u2229 M\u2082.E)) :=\n  hC.right.left\n\n/-- Circuit of type 3 is subset of ground set of `M\u2081 \u2295\u2082 M\u2082` -/\ndef TwoSumCircuitType3.subset_ground (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2286 twoSumGround M\u2081 M\u2082 :=\n  hC.right.right\n\n/-- Circuit of type 3 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma TwoSumCircuitType3.subset_union (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \u222a M\u2082.E :=\n  sub_union_diff_sub_union hC.subset_ground\n\n/-- Circuit of type 3 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType3.disjoint_inter (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  Set.disjoint_of_subset_left hC.subset_ground (twoSumGround_disjoint_inter M\u2081 M\u2082)\n\n/-- Circuit of type 3 intersected with `M\u2081.E` is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType3.disjoint_inter_M\u2081_inter (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2229 M\u2081.E \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.disjoint_inter.inter_left M\u2081.E\n\n", "theoremStatement": "/-- Circuit of type 3 intersected with `M\u2082.E` is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType3.disjoint_inter_M\u2082_inter (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2229 M\u2082.E \u2ad7 M\u2081.E \u2229 M\u2082.E ", "theoremName": "TwoSumCircuitType3.disjoint_inter_M\u2082_inter", "fileCreated": {"commit": "d0eaaa305c96cd81ac061f505a81614db6856b21", "date": "2025-01-09"}, "theoremCreated": {"commit": "439c72996f29168161b974bc602629cac773728f", "date": "2025-01-08"}, "file": "Seymour/Seymour/Matroid/Operations/Sum2/Basic.lean", "module": "Seymour.Matroid.Operations.Sum2.Basic", "jsonFile": "Seymour.Matroid.Operations.Sum2.Basic.jsonl", "positionMetadata": {"lineInFile": 233, "tokenPositionInFile": 9266, "theoremPositionInFile": 32}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 18}, "proofMetadata": {"hasProof": true, "proof": ":=\n  hC.disjoint_inter.inter_left M\u2082.E", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 38}}
{"srcContext": "import Seymour.Matroid.Notions.Circuit\n\n\nvariable {\u03b1 : Type}\n\n\nsection DisjointCircuitFamily\n\n/-- Family of disjoint circuits of matroid `M`. -/\nstructure Matroid.DisjointCircuitFamily (M : Matroid \u03b1) where\n  /-- Indexing set -/\n  \u03b9 : Set \u03b1\n  -- question: upgrade from indexing by Set \u03b1 to indexing by Sort v (see Set.iUnion in Mathlib.Order.SetNotation)?\n  -- note: if we know that `C` is a disjoint union of circuits of `M`,\n  -- then wlog we can choose `\u03b9` to be set of representatives of those circuits\n  /-- Set family indexed by `\u03b9` -/\n  F : \u03b9 \u2192 Set \u03b1\n  /-- All sets in family are circuits in `M` -/\n  AllCircuits : \u2200 x : \u03b9, M.Circuit (F x)\n  /-- All sets in family are disjoint -/\n  AllDisjoint : \u2200 x y : \u03b9, x \u2260 y \u2192 F x \u2ad7 F y\n\n/-- Shorthand for union of sets in `M.DisjointCircuitFamily`. -/\ndef Matroid.DisjointCircuitFamily.union {M : Matroid \u03b1} (F : M.DisjointCircuitFamily) : Set \u03b1 :=\n  Set.iUnion F.F\n\n/-- Every element in `M.DisjointCircuitFamily` is subset of ground set. -/\nlemma Matroid.DisjointCircuitFamily.mem_subset_ground {M : Matroid \u03b1} (F : M.DisjointCircuitFamily) (x : F.\u03b9) :\n    F.F x \u2286 M.E :=\n  (F.AllCircuits x).subset_ground\n\n/-- Union of sets in `M.DisjointCircuitFamily` is subset of ground set. -/\nlemma Matroid.DisjointCircuitFamily.union_subset_ground {M : Matroid \u03b1} (F : M.DisjointCircuitFamily) :\n    F.union \u2286 M.E := by\n  simp only [Matroid.DisjointCircuitFamily.union, Set.iUnion_coe_set, Set.iUnion_subset_iff]\n  exact fun i hi => mem_subset_ground F \u27e8i, hi\u27e9\n\n/-- If union of disjoint circuits is independent, then it is empty. -/\nlemma Matroid.DisjointCircuitFamily.union_indep_empty {M : Matroid \u03b1} (F : M.DisjointCircuitFamily) (hMF : M.Indep F.union):\n    F.union = \u2205 := by\n  by_contra\n  obtain \u27e8x, -\u27e9 : \u2203 x : F.\u03b9.Elem, (F.F x).Nonempty\n  \u00b7 by_contra!\n    simp_all only [Matroid.DisjointCircuitFamily.union, Set.iUnion_coe_set, Set.iUnion_empty, not_true_eq_false]\n  exact (F.AllCircuits x).left.not_indep (hMF.subset (Set.subset_iUnion_of_subset x Set.Subset.rfl))\n\n/-- Nonempty union of disjoint circuits is dependent. -/\nlemma Matroid.DisjointCircuitFamily.union_nonempty_dep {M : Matroid \u03b1} (F : M.DisjointCircuitFamily) (hF : F.union.Nonempty) :\n    M.Dep F.union := by\n  by_contra contr\n  exact Set.not_nonempty_empty (F.union_indep_empty (Matroid.indep_of_not_dep contr F.union_subset_ground) \u25b8 hF)\n\n/-- Union of disjoint circuits is either dependent or empty. -/\nlemma Matroid.DisjointCircuitFamily.dep_or_empty {M : Matroid \u03b1} (F : M.DisjointCircuitFamily) :\n    M.Dep F.union \u2228 F.union = \u2205 := by\n  if hMF : M.Indep F.union then\n    exact Or.inr (F.union_indep_empty hMF)\n  else\n    exact Or.inl \u27e8hMF, F.union_subset_ground\u27e9\n\n/-- Empty family of disjoint circuits. -/\ndef Matroid.emptyDisjointCircuitFamily (M : Matroid \u03b1) :\n    M.DisjointCircuitFamily where\n  \u03b9 := \u2205\n  F _ := \u2205\n  AllCircuits x := x.property.elim\n  AllDisjoint x := x.property.elim\n\n/-- Union of sets in empty family is empty. -/\nlemma Matroid.emptyDisjointCircuitFamily_union (M : Matroid \u03b1) :\n    M.emptyDisjointCircuitFamily.union = \u2205 :=\n  Set.iUnion_empty\n\n/-- Family of one circuit, indexed by one element --- that circuit. -/\ndef Matroid.Circuit.singleDisjointCircuitFamily {M : Matroid \u03b1} {C : Set \u03b1} (hC : M.Circuit C) (p : \u03b1) :\n    M.DisjointCircuitFamily where\n  \u03b9 := {p}\n  F _ := C\n  AllCircuits _ := hC\n  AllDisjoint x y hxy := ((x.property \u25b8 y.property \u25b8 Subtype.coe_ne_coe.\u2190 hxy) rfl).elim\n\n/-- Union of sets in family of one circuit is that circuit. -/\nlemma Matroid.Circuit.singleDisjointCircuitFamily_union {M : Matroid \u03b1} {C : Set \u03b1} (hC : M.Circuit C) (p : \u03b1) :\n    (hC.singleDisjointCircuitFamily p).union = C := by\n  simp only [Matroid.Circuit.singleDisjointCircuitFamily, Matroid.DisjointCircuitFamily.union, Set.iUnion_coe_set,\n    Set.mem_singleton_iff, Set.iUnion_iUnion_eq_left]\n\nend DisjointCircuitFamily\n\n\nsection UnionDisjointCircuits\n\n/-- Set `C` can be represented as disjoint union of circuits of `M`. -/\ndef Matroid.IsUnionDisjointCircuits (M : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  \u2203 F : M.DisjointCircuitFamily, F.union = C\n\n", "theoremStatement": "/-- Empty set is disjoint union of circuits. -/\nlemma Matroid.emptyUnionDisjointCircuits (M : Matroid \u03b1) :\n    M.IsUnionDisjointCircuits \u2205 ", "theoremName": "Matroid.emptyUnionDisjointCircuits", "fileCreated": {"commit": "67629d2b74be7b972786897531b678f585a7af28", "date": "2025-02-03"}, "theoremCreated": {"commit": "1a6d79dfb5649dbdf07194ae0bd21376f5682084", "date": "2025-01-07"}, "file": "Seymour/Seymour/Matroid/Notions/DisjointCircuitFamily.lean", "module": "Seymour.Matroid.Notions.DisjointCircuitFamily", "jsonFile": "Seymour.Matroid.Notions.DisjointCircuitFamily.jsonl", "positionMetadata": {"lineInFile": 97, "tokenPositionInFile": 4077, "theoremPositionInFile": 9}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 5, "repositoryPremises": true, "numRepositoryPremises": 5, "numPremises": 11}, "proofMetadata": {"hasProof": true, "proof": ":=\n  \u27e8M.emptyDisjointCircuitFamily, M.emptyDisjointCircuitFamily_union\u27e9", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 71}}
{"srcContext": "import Mathlib.Data.Set.Card\nimport Mathlib.Data.Matroid.Dual\n\nimport Seymour.ForMathlib.SetTheory\nimport Seymour.Matroid.Notions.Circuit\nimport Seymour.Matroid.Notions.CircuitAxioms\nimport Seymour.Matroid.Notions.Connectivity\nimport Seymour.Matroid.Constructors.CircuitMatroid\n\n/-!\nThis file defines 2-sum of two (general) matroids `M\u2081` and `M\u2082`, denoted as `M\u2081 \u2295\u2082 M\u2082`.\n-/\n\nvariable {\u03b1 : Type}\n\n\nsection MainDefinitions\n\n/-- `M\u2081 \u2295\u2082 M\u2082` is defined if `M\u2081` and `M\u2082` satisfy the following assumptions -/\nstructure TwoSumAssumptions (M\u2081 M\u2082 : Matroid \u03b1) : Prop where\n  /-- `M\u2081` is finite -/\n  M\u2081fin : M\u2081.Finite\n  /-- `M\u2082` is finite -/\n  M\u2082fin : M\u2082.Finite\n  /-- `M\u2081` contains at least 2 elements -/\n  M\u2081card : M\u2081.E.encard \u2265 2\n  /-- `M\u2082` contains at least 2 elements -/\n  M\u2082card : M\u2082.E.encard \u2265 2\n  /-- `M\u2081` and `M\u2082` have exactly one element in common -/\n  interSingleton : (M\u2081.E \u2229 M\u2082.E).encard = 1\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2081` -/\n  M\u2081sep : \u00acM\u2081.Separator (M\u2081.E \u2229 M\u2082.E)\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2082` -/\n  M\u2082sep : \u00acM\u2082.Separator (M\u2081.E \u2229 M\u2082.E)\n\n-- question: can avoid this assumption? -- which assumption? the finiteness?\n\n/-- Ground set of `M\u2081 \u2295\u2082 M\u2082` -/\ndef twoSumGround (M\u2081 M\u2082 : Matroid \u03b1) : Set \u03b1 :=\n  (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)\n\n/-- Type 1 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2081` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType1 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 2 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2082` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType2 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2082.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 3 of circuits in `M\u2081 \u2295\u2082 M\u2082`:\n    sets `(C\u2081 \u222a C\u2082) \\ (M\u2081.E \u2229 M\u2082.E)` where `C\u2081` and `C\u2082` are circuits in `M\u2081` and `M\u2082`, respectively,\n    and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2081` and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2082` -/\ndef TwoSumCircuitType3 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit ((C \u2229 M\u2081.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 M\u2082.Circuit ((C \u2229 M\u2082.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 C \u2286 twoSumGround M\u2081 M\u2082\n\n/-- Circuit predicate of `M\u2081 \u2295\u2082 M\u2082`, which defines 2-sum as `CircuitMatroid` -/\ndef TwoSumCircuitPred (M\u2081 M\u2082 : Matroid \u03b1) : CircuitPredicate \u03b1 :=\n  fun C : Set \u03b1 =>\n    TwoSumCircuitType1 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType2 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType3 M\u2081 M\u2082 C\n\nend MainDefinitions\n\n\nsection PropertiesAssumptions\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1}\n\n/-- 2-sum assumptions are symmetric -/\nlemma TwoSumAssumptions.symm (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    TwoSumAssumptions M\u2082 M\u2081 :=\n  \u27e8\n    assumptions.M\u2082fin,\n    assumptions.M\u2081fin,\n    assumptions.M\u2082card,\n    assumptions.M\u2081card,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.interSingleton,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2082sep,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2081sep,\n  \u27e9\n\n/-- Intersection of ground sets is nonempty -/\nlemma TwoSumAssumptions.inter_nonempty (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (M\u2081.E \u2229 M\u2082.E).Nonempty :=\n  Set.one_le_encard_iff_nonempty.\u2192 assumptions.interSingleton.symm.le\n\n", "theoremStatement": "/-- Intersection of ground sets is a singleton set -/\nlemma TwoSumAssumptions.inter_singleton (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    \u2203 p : \u03b1, M\u2081.E \u2229 M\u2082.E = {p} ", "theoremName": "TwoSumAssumptions.inter_singleton", "fileCreated": {"commit": "d0eaaa305c96cd81ac061f505a81614db6856b21", "date": "2025-01-09"}, "theoremCreated": {"commit": "439c72996f29168161b974bc602629cac773728f", "date": "2025-01-08"}, "file": "Seymour/Seymour/Matroid/Operations/Sum2/Basic.lean", "module": "Seymour.Matroid.Operations.Sum2.Basic", "jsonFile": "Seymour.Matroid.Operations.Sum2.Basic.jsonl", "positionMetadata": {"lineInFile": 88, "tokenPositionInFile": 3039, "theoremPositionInFile": 7}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 24}, "proofMetadata": {"hasProof": true, "proof": ":=\n  Set.encard_eq_one.\u2192 assumptions.interSingleton", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 51}}
{"srcContext": "import Seymour.Matroid.Operations.Sum1.Basic\nimport Seymour.Matroid.Classes.Regular\n\n\nvariable {\u03b1 : Type} [DecidableEq \u03b1] {M\u2081 M\u2082 : Matroid \u03b1} [Fintype M\u2081.E.Elem] [Fintype M\u2082.E.Elem]\n\nsection Composition\n\nlemma Disjoint.build1sum_isRepresentedBy {R X\u2081 X\u2082 : Type} [Ring R] {A\u2081 : Matrix X\u2081 M\u2081.E R} {A\u2082 : Matrix X\u2082 M\u2082.E R}\n    (hE : M\u2081.E \u2ad7 M\u2082.E) (hA\u2081 : M\u2081.IsRepresentedBy A\u2081) (hA\u2082 : M\u2082.IsRepresentedBy A\u2082) :\n    hE.build1sum.IsRepresentedBy (Matrix.fromBlocks A\u2081 0 0 A\u2082) := by\n  sorry\n\nend Composition\n\n\nsection Decomposition\n\n/-- todo: desc-/\nlemma Matroid.oneSum.ofRepr\u2081 {X R : Type} [Ring R] (hE : M\u2081.E \u2ad7 M\u2082.E) {A : Matrix X hE.build1sum.E R}\n    (hA : have : Fintype hE.build1sum.E := (by sorry); -- should be somewhere already\n      hE.build1sum.IsRepresentedBy A) :\n    \u2203 X\u2081 : Type, \u2203 A\u2081 : Matrix X\u2081 M\u2081.E R, M\u2081.IsRepresentedBy A\u2081 :=\n  sorry\n\n/-- todo: desc-/\nlemma Matroid.oneSum.ofRepr\u2082 {X R : Type} [Ring R] (hE : M\u2081.E \u2ad7 M\u2082.E) {A : Matrix X hE.build1sum.E R}\n    (hA : have : Fintype hE.build1sum.E := (by sorry); -- should be somewhere already\n      hE.build1sum.IsRepresentedBy A) :\n    \u2203 X\u2082 : Type, \u2203 A\u2082 : Matrix X\u2082 M\u2082.E R, M\u2082.IsRepresentedBy A\u2082 :=\n  sorry\n\n/-- If a regular matroid is a 1-sum of binary matroids, the left summand is regular. -/\nlemma Disjoint.decomposition_isRegular_left (hE : M\u2081.E \u2ad7 M\u2082.E) (regularity : hE.build1sum.IsRegular) :\n    M\u2081.IsRegular := by\n  sorry\n\n/-- If a regular matroid is a 1-sum of binary matroids, the right summand is regular. -/\nlemma Disjoint.decomposition_isRegular_right (hE : M\u2081.E \u2ad7 M\u2082.E) (regularity : hE.build1sum.IsRegular) :\n    M\u2082.IsRegular :=\n  hE.symm.decomposition_isRegular_left (hE.symm.build1sum_comm \u25b8 regularity)\n\n", "theoremStatement": "/-- If a regular matroid is a 1-sum of binary matroids, both summand matroids are regular. -/\nlemma Disjoint.decomposition_isRegular_both (hE : M\u2081.E \u2ad7 M\u2082.E) (regularity : hE.build1sum.IsRegular) :\n    M\u2081.IsRegular \u2227 M\u2082.IsRegular ", "theoremName": "Disjoint.decomposition_isRegular_both", "fileCreated": {"commit": "82da3e879b5e70117f930d5c7ceac4783bc3fe8c", "date": "2025-02-01"}, "theoremCreated": {"commit": "82da3e879b5e70117f930d5c7ceac4783bc3fe8c", "date": "2025-02-01"}, "file": "Seymour/Seymour/Matroid/Operations/Sum1/Regularity.lean", "module": "Seymour.Matroid.Operations.Sum1.Regularity", "jsonFile": "Seymour.Matroid.Operations.Sum1.Regularity.jsonl", "positionMetadata": {"lineInFile": 43, "tokenPositionInFile": 1679, "theoremPositionInFile": 5}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 4, "numPremises": 22}, "proofMetadata": {"hasProof": true, "proof": ":=\n  \u27e8hE.decomposition_isRegular_left regularity, hE.decomposition_isRegular_right regularity\u27e9", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 94}}
{"srcContext": "import Seymour.Matroid.Classes.Binary\nimport Seymour.Matroid.Constructors.CircuitMatroid\nimport Seymour.Matroid.Notions.DisjointCircuitFamily\n\n\nvariable {\u03b1 : Type}\n\n\nsection BasicDefinitions\n\n/-- Circuits in `M\u2081 \u0394 M\u2082` are nonempty subsets of the ground set of form `X\u2081 \u0394 X\u2082`\n    where `X\u2081` and `X\u2082` are disjoint unions of circuits in `M\u2081` and `M\u2082` respectively. -/\ndef DeltaSumCircuitsAux [DecidableEq \u03b1] (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C X\u2081 X\u2082 : Set \u03b1) : Prop :=\n  C = (X\u2081 \u222a X\u2082) \\ (X\u2081 \u2229 X\u2082) \u2227 M\u2081.toMatroid.IsUnionDisjointCircuits X\u2081 \u2227 M\u2082.toMatroid.IsUnionDisjointCircuits X\u2082\n\n/-- A set satisfies circuit form if for some `X\u2081` and `X\u2082` it has the form above. -/\ndef DeltaSumCircuitForm [DecidableEq \u03b1] (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C : Set \u03b1) : Prop :=\n  C.Nonempty \u2227 C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E) \u2227 \u2203 X\u2081 X\u2082 : Set \u03b1, DeltaSumCircuitsAux M\u2081 M\u2082 C X\u2081 X\u2082\n\n/-- Circuits of \u0394-sum are minimal non-empty subsets of `M\u2081.E \u0394 M\u2082.E` of the form `X\u2081 \u0394 X\u2082`\n    where `X\u2081` and `X\u2082` is a disjoint union of circuits of `M\u2081` and `M\u2082` respectively. -/\ndef DeltaSumCircuitPred [DecidableEq \u03b1] (M\u2081 M\u2082 : BinaryMatroid \u03b1) : CircuitPredicate \u03b1 :=\n  Minimal (DeltaSumCircuitForm M\u2081 M\u2082)\n\nend BasicDefinitions\n\n\nsection BasicProperties\n\n/-- A set of circuit form is nonempty. -/\nlemma deltaSumCircuitForm.nonempty [DecidableEq \u03b1] {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm M\u2081 M\u2082 C) :\n    C.Nonempty :=\n  hC.left\n\n/-- A set of circuit form is a subset of the ground set. -/\nlemma DeltaSumCircuitForm.subset_ground [DecidableEq \u03b1] {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm M\u2081 M\u2082 C) :\n    C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E) :=\n  hC.right.left\n\n/-- A set of circuit form is the symmetric difference of `X\u2081` and `X\u2082` -/\nlemma DeltaSumCircuitsAux.eq_symmDiff [DecidableEq \u03b1] {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C X\u2081 X\u2082 : Set \u03b1}\n    (hC : DeltaSumCircuitsAux M\u2081 M\u2082 C X\u2081 X\u2082) :\n    C = (X\u2081 \u222a X\u2082) \\ (X\u2081 \u2229 X\u2082) :=\n  hC.left\n\n/-- A set of circuit form is related to a union of disjoint circuits of `M\u2081` -/\nlemma DeltaSumCircuitsAux.udc_left [DecidableEq \u03b1] {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C X\u2081 X\u2082 : Set \u03b1}\n    (hC : DeltaSumCircuitsAux M\u2081 M\u2082 C X\u2081 X\u2082) :\n    M\u2081.toMatroid.IsUnionDisjointCircuits X\u2081 :=\n  hC.right.left\n\n", "theoremStatement": "/-- A set of circuit form is related to a union of disjoint circuits of `M\u2082` -/\nlemma DeltaSumCircuitsAux.udc_right [DecidableEq \u03b1] {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C X\u2081 X\u2082 : Set \u03b1}\n    (hC : DeltaSumCircuitsAux M\u2081 M\u2082 C X\u2081 X\u2082) :\n    M\u2082.toMatroid.IsUnionDisjointCircuits X\u2082 ", "theoremName": "DeltaSumCircuitsAux.udc_right", "fileCreated": {"commit": "aae07a69b2ec95e3d9a1436952a123dcb7d0d06f", "date": "2025-01-03"}, "theoremCreated": {"commit": "67629d2b74be7b972786897531b678f585a7af28", "date": "2025-02-03"}, "file": "Seymour/Seymour/Matroid/Operations/SumDelta/Basic.lean", "module": "Seymour.Matroid.Operations.SumDelta.Basic", "jsonFile": "Seymour.Matroid.Operations.SumDelta.Basic.jsonl", "positionMetadata": {"lineInFile": 54, "tokenPositionInFile": 2209, "theoremPositionInFile": 7}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 5, "numPremises": 24}, "proofMetadata": {"hasProof": true, "proof": ":=\n  hC.right.right", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 19}}
{"srcContext": "import Mathlib.Order.RelClasses\nimport Mathlib.Data.Matroid.Basic\n\nimport Seymour.Basic\nimport Seymour.Matroid.Notions.IndepAxioms\n\n\n/-- Circuit predicate, defines which sets are circuits. -/\nabbrev CircuitPredicate (\u03b1 : Type) := Set \u03b1 \u2192 Prop\n\n\nvariable {\u03b1 : Type}\n\n\nsection ValidFamily\n\n/-- Family of circuits satisfying assumptions of circuit axiom (C3) from Bruhn et al. -/\nstructure ValidFamily (P : CircuitPredicate \u03b1) (X : Set \u03b1) where\n  F : X.Elem \u2192 Set \u03b1\n  hPF : \u2200 x : X.Elem, P (F x)\n  hF : \u2200 x y : X.Elem, x.val \u2208 F y \u2194 x = y -- `F y` may nevertheless contain multiple elements of `X\u1d9c`\n\n/-- Shorthand for union of sets in `ValidFamily` -/\nabbrev ValidFamily.union {P : CircuitPredicate \u03b1} {X : Set \u03b1} (F : ValidFamily P X) : Set \u03b1 :=\n  Set.iUnion F.F\n\n-- question: unused API?\nlemma ValidFamily.mem_of_elem {P : CircuitPredicate \u03b1} {X : Set \u03b1} (F : ValidFamily P X) (x : X.Elem) :\n    x.val \u2208 F.F x := by\n  rw [F.hF]\n\n-- question: unused API?\nlemma ValidFamily.outside {P : CircuitPredicate \u03b1} {C X : Set \u03b1} {F : ValidFamily P X} {z : \u03b1} (hzCF : z \u2208 C \\ F.union) :\n    z \u2209 X := by\n  intro hz\n  have := F.hF \u27e8z, hz\u27e9 \u27e8z, hz\u27e9\n  simp_all\n\nend ValidFamily\n\n\nsection CircuitAxioms\n\n/-- Circuit predicate `P` defines independence predicate: independent sets are all non-circuits. -/\ndef CircuitPredicate.toIndepPredicate (P : CircuitPredicate \u03b1) (E : Set \u03b1) : IndepPredicate \u03b1 :=\n  fun I : Set \u03b1 => I \u2286 E \u2227 \u2200 C : Set \u03b1, C \u2286 I \u2192 \u00ac(P C)\n\n/-- Axiom (C1): empty set is not a circuit. -/\ndef CircuitPredicate.NotCircuitEmpty (P : CircuitPredicate \u03b1) : Prop :=\n  \u00ac(P \u2205)\nalias CircuitPredicate.BruhnC1 := CircuitPredicate.NotCircuitEmpty\n\n/-- Axiom (C2): no circuit is a subset of another circuit. -/\ndef CircuitPredicate.CircuitNotSsubset (P : CircuitPredicate \u03b1) : Prop :=\n  \u2200 C C' : Set \u03b1, P C \u2192 P C' \u2192 \u00ac(C' \u2282 C)  -- todo: swap to \u00acC \u2282 C'\nalias CircuitPredicate.BruhnC2 := CircuitPredicate.CircuitNotSsubset\n\n/-- Axiom (C3) from Bruhn et al. -/\ndef CircuitPredicate.BruhnC3 (P : CircuitPredicate \u03b1) : Prop :=\n  \u2200 X C : Set \u03b1, \u2200 F : ValidFamily P X, \u2200 z \u2208 C \\ F.union, \u2203 C' : Set \u03b1, P C' \u2227 z \u2208 C' \u2227 C' \u2286 (C \u222a F.union) \\ X\n\n/-- Axiom (CM) from Bruhn et al.: set of all independent sets has the maximal subset property. -/\ndef CircuitPredicate.CircuitMaximal (P : CircuitPredicate \u03b1) (E : Set \u03b1) : Prop :=\n  \u2200 X : Set \u03b1, X \u2286 E \u2192 Matroid.ExistsMaximalSubsetProperty (P.toIndepPredicate E) X\nalias CircuitPredicate.BruhnCM := CircuitPredicate.CircuitMaximal\n\n/-- Every circuit is a subset of the ground set. -/\ndef CircuitPredicate.SubsetGround (P : CircuitPredicate \u03b1) (E : Set \u03b1) : Prop :=\n  \u2200 C : Set \u03b1, P C \u2192 C \u2286 E\nalias CircuitPredicate.BruhnCE := CircuitPredicate.SubsetGround\n\n/-- Strong circuit elimination axiom: if `C\u2081` and `C\u2082` are circuits with `e \u2208 C\u2081 \u2229 C\u2082` and `f \u2208 C\u2081 \\ C\u2082`,\n    then there is circuit `C\u2083` such that `f \u2208 C\u2083 \u2286 C\u2081 \u222a C\u2082 \\ {e}`. -/\ndef CircuitPredicate.StrongCircuitElim (P : CircuitPredicate \u03b1) : Prop :=\n  \u2200 C\u2081 C\u2082 : Set \u03b1, \u2200 e f, P C\u2081 \u2227 P C\u2082 \u2227 e \u2208 C\u2081 \u2229 C\u2082 \u2227 f \u2208 C\u2081 \\ C\u2082 \u2192 \u2203 C\u2083, P C\u2083 \u2227 f \u2208 C\u2083 \u2227 C\u2083 \u2286 (C\u2081 \u222a C\u2082) \\ {e}\n\n/-- Weak circuit elimination axiom: if `C\u2081` and `C\u2082` are distinct circuits and `e \u2208 C\u2081 \u2229 C\u2082`,\n    then there is circuit `C\u2083` such that `C\u2083 \u2286 C\u2081 \u222a C\u2082 \\ {e}`. -/\ndef CircuitPredicate.WeakCircuitElim (P : CircuitPredicate \u03b1) : Prop :=\n  \u2200 C\u2081 C\u2082 : Set \u03b1, C\u2081 \u2260 C\u2082 \u2192 P C\u2081 \u2192 P C\u2082 \u2192 \u2200 e \u2208 C\u2081 \u2229 C\u2082, \u2203 C\u2083, P C\u2083 \u2227 C\u2083 \u2286 (C\u2081 \u222a C\u2082) \\ {e}\n\nend CircuitAxioms\n\n\nsection CircuitAxiomRelations\n\n/-- Alternative formulation of axiom (C2). -/\nlemma CircuitPredicate.circuit_not_ssubset_iff (P : CircuitPredicate \u03b1) :\n    P.CircuitNotSsubset \u2194 \u2200 C C' : Set \u03b1, P C \u2192 P C' \u2192 C' \u2286 C \u2192 C \u2286 C' := by\n  constructor\n  \u00b7 intro hP C C' hC hC' hCC'\n    apply hP C C' hC at hC'\n    rw [ssubset_iff_subset_ne] at hC'\n    push_neg at hC'\n    exact (hC' hCC').symm.subset\n  \u00b7 intro hP C C' hC hC' hCC'\n    apply hP C C' hC at hC'\n    rw [ssubset_iff_subset_ne] at hCC'\n    exact hCC'.right.symm (Set.Subset.antisymm (hC' hCC'.left) hCC'.left)\n\n/-- Axiom (C3) implies strong circuit elimination. -/\nlemma CircuitPredicate.C3_strong_circuit_elim (P : CircuitPredicate \u03b1) :\n    P.BruhnC3 \u2192 P.StrongCircuitElim := by\n  intro hPC3 C\u2081 C\u2082 x z hxz\n  obtain \u27e8_hC\u2081, hC\u2082, hx, hz\u27e9 := hxz\n  let F : ValidFamily P {x} :=\n  \u27e8\n    (fun _ => C\u2082),\n    (fun _ => hC\u2082),\n    (by simpa using Set.mem_of_mem_inter_right hx)\n  \u27e9\n  specialize hPC3 {x} C\u2081 F\n  simp only [ValidFamily.union, Set.iUnion_coe_set, Set.mem_singleton_iff, Set.iUnion_iUnion_eq_left] at hPC3\n  specialize hPC3 z hz\n  exact hPC3\n\n", "theoremStatement": "/-- Strong circuit elimination implies weak circuit elimination. -/\nlemma CircuitPredicate.strong_circuit_elim_weak_circuit_elim (P : CircuitPredicate \u03b1) :\n    P.StrongCircuitElim \u2192 P.WeakCircuitElim ", "theoremName": "CircuitPredicate.strong_circuit_elim_weak_circuit_elim", "fileCreated": {"commit": "ee35fddd27b04eb576eb64b8bb74af513408f6ef", "date": "2024-12-21"}, "theoremCreated": {"commit": "ee35fddd27b04eb576eb64b8bb74af513408f6ef", "date": "2024-12-21"}, "file": "Seymour/Seymour/Matroid/Notions/CircuitAxioms.lean", "module": "Seymour.Matroid.Notions.CircuitAxioms", "jsonFile": "Seymour.Matroid.Notions.CircuitAxioms.jsonl", "positionMetadata": {"lineInFile": 117, "tokenPositionInFile": 4483, "theoremPositionInFile": 14}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 3, "numPremises": 47}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  intro hP C\u2081 C\u2082 hCC hC\u2081 hC\u2082 e he\n  if hf : \u2203 f : \u03b1, f \u2208 C\u2081 \\ C\u2082 then\n    obtain \u27e8f, hf\u27e9 := hf\n    specialize hP C\u2081 C\u2082 e f (And.intro hC\u2081 (And.intro hC\u2082 (And.intro he hf)))\n    obtain \u27e8C\u2083, \u27e8hC\u2083, \u27e8-, _\u27e9\u27e9\u27e9 := hP\n    use C\u2083\n  else\n    push_neg at hf\n    simp only [Set.mem_diff, not_and, not_not] at hf\n    have C\u2081_sub_C\u2082 : C\u2081 \u2286 C\u2082 := hf\n    obtain \u27e8f, hff\u27e9 : (C\u2082 \\ C\u2081).Nonempty\n    \u00b7 rw [Set.diff_nonempty]\n      by_contra C\u2082_sub_C\u2081\n      exact hCC (C\u2081_sub_C\u2082.antisymm C\u2082_sub_C\u2081)\n    specialize hP C\u2082 C\u2081 e f (And.intro hC\u2082 (And.intro hC\u2081 (And.intro he.symm hff)))\n    obtain \u27e8C\u2083, \u27e8hC\u2083, \u27e8-, hCCCe\u27e9\u27e9\u27e9 := hP\n    rw [Set.union_comm] at hCCCe\n    use C\u2083", "proofType": "tactic", "proofLengthLines": 18, "proofLengthTokens": 652}}
