{"srcContext": "import Carleson.Discrete.Defs\nimport Carleson.ForestOperator.Forests\nimport Carleson.Discrete.SumEstimates\n\nopen MeasureTheory Measure NNReal Metric Complex Set\nopen scoped ENNReal\nopen Classical -- We use quite some `Finset.filter`\nnoncomputable section\n\nopen scoped ShortVariables\nvariable {X : Type*} {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102} {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X}\n  [MetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] [TileStructure Q D \u03ba S o]\n\nvariable {k n j l : \u2115} {p p' u u' : \ud835\udd13 X} {x : X}\n\n/-! ## Section 5.3 -/\n\n/-! Note: the lemmas 5.3.1-5.3.3 are in `TileStructure`. -/\n\n/-- Lemma 5.3.4 -/\nlemma ordConnected_tilesAt : OrdConnected (TilesAt k : Set (\ud835\udd13 X)) := by\n  rw [ordConnected_def]; intro p mp p'' mp'' p' mp'\n  simp_rw [TilesAt, mem_preimage, \ud835\udcd2, mem_diff, aux\ud835\udcd2, mem_setOf] at mp mp'' \u22a2\n  constructor\n  \u00b7 obtain \u27e8J, hJ, _\u27e9 := mp''.1\n    use J, mp'.2.1.trans hJ\n  \u00b7 push_neg at mp \u22a2\n    exact fun J hJ \u21a6 mp.2 J (mp'.1.1.trans hJ)\n\n/-- Lemma 5.3.5 -/\nlemma ordConnected_C : OrdConnected (\u212d k n : Set (\ud835\udd13 X)) := by\n  rw [ordConnected_def]; intro p mp p'' mp'' p' mp'\n  rw [\u212d, mem_setOf] at mp mp'' \u22a2\n  have z := mem_of_mem_of_subset mp' (ordConnected_tilesAt.out mp.1 mp''.1)\n  refine \u27e8z, ?_\u27e9\n  have hk : \u2200 q' \u2208 TilesAt (X := X) k, \u2200 q \u2264 q', dens' k {q'} \u2264 dens' k {q} := fun q' _ q hq \u21a6 by\n    simp_rw [dens', mem_singleton_iff, iSup_iSup_eq_left]; gcongr with l hl a _\n    exact iSup_const_mono fun h \u21a6\n      wiggle_order_11_10 hq (C5_3_3_le (X := X).trans (by norm_num) |>.trans hl) |>.trans h\n  exact \u27e8mp''.2.1.trans_le (hk _ mp''.1 _ mp'.2), (hk _ z _ mp'.1).trans mp.2.2\u27e9\n\n/-- Lemma 5.3.6 -/\nlemma ordConnected_C1 : OrdConnected (\u212d\u2081 k n j : Set (\ud835\udd13 X)) := by\n  rw [ordConnected_def]; intro p mp p'' mp'' p' mp'\n  have mp'\u2081 : p' \u2208 \u212d (X := X) k n := mem_of_mem_of_subset mp'\n    (ordConnected_C.out (mem_of_mem_of_subset mp \u212d\u2081_subset_\u212d)\n      (mem_of_mem_of_subset mp'' \u212d\u2081_subset_\u212d))\n  simp_rw [\u212d\u2081, mem_diff, pre\u212d\u2081, mem_setOf, not_and, not_le] at mp mp'' \u22a2\n  simp_rw [mp.1.1, true_and, true_implies] at mp\n  simp_rw [mp'\u2081, true_and, true_implies]\n  simp_rw [mp''.1.1, true_and, true_implies] at mp''\n  constructor\n  \u00b7 refine mp''.1.trans (Finset.card_le_card fun b mb \u21a6 ?_)\n    simp_rw [Finset.mem_filter, Finset.mem_univ, true_and, \ud835\udd05, mem_setOf] at mb \u22a2\n    have h100 := wiggle_order_11_10 (n := 100) mp'.2 (C5_3_3_le (X := X).trans (by norm_num))\n    exact \u27e8mb.1, h100.trans mb.2\u27e9\n  \u00b7 refine (Finset.card_le_card fun b mb \u21a6 ?_).trans_lt mp.2\n    simp_rw [Finset.mem_filter, Finset.mem_univ, true_and, \ud835\udd05, mem_setOf] at mb \u22a2\n    have h100 := wiggle_order_11_10 (n := 100) mp'.1 (C5_3_3_le (X := X).trans (by norm_num))\n    exact \u27e8mb.1, h100.trans mb.2\u27e9\n\n/-- Lemma 5.3.7 -/\nlemma ordConnected_C2 : OrdConnected (\u212d\u2082 k n j : Set (\ud835\udd13 X)) := by\n  rw [ordConnected_def]; intro p mp p'' mp'' p' mp'\n  have mp\u2081 := mem_of_mem_of_subset mp \u212d\u2082_subset_\u212d\u2081\n  have mp'\u2081 : p' \u2208 \u212d\u2081 (X := X) k n j := mem_of_mem_of_subset mp'\n    (ordConnected_C1.out mp\u2081 (mem_of_mem_of_subset mp'' \u212d\u2082_subset_\u212d\u2081))\n  by_cases e : p = p'; \u00b7 rwa [e] at mp\n  simp_rw [\u212d\u2082, layersAbove, mem_diff, mp'\u2081, true_and]\n  by_contra h; rw [mem_iUnion\u2082] at h; obtain \u27e8l', bl', p'm\u27e9 := h\n  rw [minLayer, mem_setOf, minimal_iff] at p'm\n  have pnm : p \u2209 \u22c3 l'', \u22c3 (_ : l'' < l'), \ud835\udd0f\u2081 k n j l'' := by\n    replace mp := mp.2; contrapose! mp\n    exact mem_of_mem_of_subset mp\n      (iUnion_mono'' fun i \u21a6 iUnion_subset_iUnion_const fun hi \u21a6 (hi.trans_le bl').le)\n  exact absurd (p'm.2 \u27e8mp.1, pnm\u27e9 mp'.1).symm e\n\n/-- Lemma 5.3.8 -/\nlemma ordConnected_C3 : OrdConnected (\u212d\u2083 k n j : Set (\ud835\udd13 X)) := by\n  rw [ordConnected_def]; intro p mp p'' mp'' p' mp'\n  have mp\u2081 := mem_of_mem_of_subset mp \u212d\u2083_subset_\u212d\u2082\n  have mp''\u2081 := mem_of_mem_of_subset mp'' \u212d\u2083_subset_\u212d\u2082\n  have mp'\u2081 : p' \u2208 \u212d\u2082 (X := X) k n j := mem_of_mem_of_subset mp' (ordConnected_C2.out mp\u2081 mp''\u2081)\n  rw [\u212d\u2083_def] at mp'' \u22a2\n  obtain \u27e8-, u, mu, \ud835\udcd8nu, su\u27e9 := mp''; refine \u27e8mp'\u2081, \u27e8u, mu, ?_\u27e9\u27e9\n  exact \u27e8(mp'.2.1.trans_lt (lt_of_le_of_ne su.1 \ud835\udcd8nu)).ne,\n    (wiggle_order_11_10 mp'.2 (C5_3_3_le (X := X).trans (by norm_num))).trans su\u27e9\n\n/-- Lemma 5.3.9 -/\nlemma ordConnected_C4 : OrdConnected (\u212d\u2084 k n j : Set (\ud835\udd13 X)) := by\n  rw [ordConnected_def]; intro p mp p'' mp'' p' mp'\n  have mp''\u2081 := mem_of_mem_of_subset mp'' \u212d\u2084_subset_\u212d\u2083\n  have mp'\u2081 : p' \u2208 \u212d\u2083 (X := X) k n j := mem_of_mem_of_subset mp'\n    (ordConnected_C3.out (mem_of_mem_of_subset mp \u212d\u2084_subset_\u212d\u2083) mp''\u2081)\n  by_cases e : p' = p''; \u00b7 rwa [\u2190 e] at mp''\n  simp_rw [\u212d\u2084, layersBelow, mem_diff, mp'\u2081, true_and]\n  by_contra h; simp_rw [mem_iUnion] at h; obtain \u27e8l', hl', p'm\u27e9 := h\n  rw [maxLayer_def, mem_setOf, maximal_iff] at p'm\n  simp_rw [mem_diff] at p'm\n  have p''nm : p'' \u2209 \u22c3 l'', \u22c3 (_ : l'' < l'), \ud835\udd0f\u2083 k n j l'' := by\n    replace mp'' := mp''.2; contrapose! mp''\n    refine mem_of_mem_of_subset mp'' <| iUnion\u2082_mono' fun i hi \u21a6 \u27e8i, hi.le.trans hl', subset_rfl\u27e9\n  exact absurd (p'm.2 \u27e8mp''\u2081, p''nm\u27e9 mp'.2) e\n\n/-- Lemma 5.3.10 -/\nlemma ordConnected_C5 : OrdConnected (\u212d\u2085 k n j : Set (\ud835\udd13 X)) := by\n  rw [ordConnected_def]; intro p mp p'' mp'' p' mp'\n  have mp\u2081 := mem_of_mem_of_subset mp \u212d\u2085_subset_\u212d\u2084\n  have mp'\u2081 : p' \u2208 \u212d\u2084 (X := X) k n j := mem_of_mem_of_subset mp'\n    (ordConnected_C4.out mp\u2081 (mem_of_mem_of_subset mp'' \u212d\u2085_subset_\u212d\u2084))\n  simp_rw [\u212d\u2085, mem_diff, mp\u2081, mp'\u2081, true_and, \ud835\udd0f\u2084, mem_setOf,\n    mp\u2081, mp'\u2081, true_and] at mp \u22a2\n  contrapose! mp; obtain \u27e8u, mu, s\ud835\udcd8u\u27e9 := mp; use u, mu, mp'.1.1.1.trans s\ud835\udcd8u\n\n/-! ## Section 5.4 and Lemma 5.1.2 -/\n\n/-- The subset `\u212d\u2086(k, n, j)` of `\u212d\u2085(k, n, j)`, given above (5.4.1). -/\ndef \u212d\u2086 (k n j : \u2115) : Set (\ud835\udd13 X) :=\n  { p \u2208 \u212d\u2085 k n j | \u00ac (\ud835\udcd8 p : Set X) \u2286 G' }\n\nlemma \u212d\u2086_subset_\u212d\u2085 : \u212d\u2086 (X := X) k n j \u2286 \u212d\u2085 k n j := sep_subset ..\nlemma \u212d\u2086_subset_\u212d : \u212d\u2086 (X := X) k n j \u2286 \u212d k n := \u212d\u2086_subset_\u212d\u2085.trans \u212d\u2085_subset_\u212d\n\n/-- The subset `\ud835\udd17\u2081(u)` of `\u212d\u2081(k, n, j)`, given in (5.4.1).\nIn lemmas, we will assume `u \u2208 \ud835\udd18\u2081 k n l` -/\ndef \ud835\udd17\u2081 (k n j : \u2115) (u : \ud835\udd13 X) : Set (\ud835\udd13 X) :=\n  { p \u2208 \u212d\u2081 k n j | \ud835\udcd8 p \u2260 \ud835\udcd8 u \u2227 smul 2 p \u2264 smul 1 u }\n\nlemma \ud835\udcd8_lt_of_mem_\ud835\udd17\u2081 (h : p \u2208 \ud835\udd17\u2081 k n j p') : \ud835\udcd8 p < \ud835\udcd8 p' := by\n  rw [\ud835\udd17\u2081, mem_setOf] at h; exact lt_of_le_of_ne h.2.2.1 h.2.1\n\n/-- The subset `\ud835\udd18\u2082(k, n, j)` of `\ud835\udd18\u2081(k, n, j)`, given in (5.4.2). -/\ndef \ud835\udd18\u2082 (k n j : \u2115) : Set (\ud835\udd13 X) :=\n  { u \u2208 \ud835\udd18\u2081 k n j | \u00ac Disjoint (\ud835\udd17\u2081 k n j u) (\u212d\u2086 k n j) }\n\nlemma \ud835\udd18\u2082_subset_\ud835\udd18\u2081 : \ud835\udd18\u2082 k n j \u2286 \ud835\udd18\u2081 (X := X) k n j := fun _ mu \u21a6 mu.1\n\n/-- The relation `\u223c` defined below (5.4.2). It is an equivalence relation on `\ud835\udd18\u2082 k n j`. -/\ndef URel (k n j : \u2115) (u u' : \ud835\udd13 X) : Prop :=\n  u = u' \u2228 \u2203 p \u2208 \ud835\udd17\u2081 k n j u, smul 10 p \u2264 smul 1 u'\n\nnonrec lemma URel.rfl : URel k n j u u := Or.inl rfl\n\n/-- Lemma 5.4.1, part 2. -/\nlemma URel.not_disjoint (hu : u \u2208 \ud835\udd18\u2082 k n j) (hu' : u' \u2208 \ud835\udd18\u2082 k n j) (huu' : URel k n j u u') :\n    \u00acDisjoint (ball_(u) (\ud835\udcac u) 100) (ball_(u') (\ud835\udcac u') 100) := by\n  by_cases e : u = u'; \u00b7 rw [e]; simp\n  simp_rw [URel, e, false_or, \ud835\udd17\u2081, mem_setOf] at huu'; obtain \u27e8p, \u27e8mp, np, sl\u2081\u27e9, sl\u2082\u27e9 := huu'\n  by_cases e' : \ud835\udcd8 p = \ud835\udcd8 u'\n  \u00b7 refine not_disjoint_iff.mpr \u27e8\ud835\udcac u, mem_ball_self (by positivity), ?_\u27e9\n    rw [@mem_ball]\n    have i1 : ball_{\ud835\udcd8 u} (\ud835\udcac u) 1 \u2286 ball_{\ud835\udcd8 p} (\ud835\udcac p) 2 := sl\u2081.2\n    have i2 : ball_{\ud835\udcd8 u'} (\ud835\udcac u') 1 \u2286 ball_{\ud835\udcd8 p} (\ud835\udcac p) 10 := sl\u2082.2\n    replace i1 : \ud835\udcac u \u2208 ball_{\ud835\udcd8 p} (\ud835\udcac p) 2 := i1 (mem_ball_self zero_lt_one)\n    replace i2 : \ud835\udcac u' \u2208 ball_{\ud835\udcd8 p} (\ud835\udcac p) 10 := i2 (mem_ball_self zero_lt_one)\n    rw [e', @mem_ball] at i1 i2\n    calc\n      _ \u2264 dist_{\ud835\udcd8 u'} (\ud835\udcac u) (\ud835\udcac p) + dist_{\ud835\udcd8 u'} (\ud835\udcac u') (\ud835\udcac p) := dist_triangle_right ..\n      _ < 2 + 10 := add_lt_add i1 i2\n      _ < 100 := by norm_num\n  have plu : smul 100 p \u2264 smul 100 u := wiggle_order_100 (smul_mono sl\u2081 le_rfl (by norm_num)) np\n  have plu' : smul 100 p \u2264 smul 100 u' := wiggle_order_100 sl\u2082 e'\n  by_contra h\n  have \ud835\udd05dj : Disjoint (\ud835\udd05 k n u) (\ud835\udd05 k n u') := by\n    simp_rw [\ud835\udd05, disjoint_left, mem_setOf, not_and]; intro q \u27e8_, sl\u27e9 _\n    simp_rw [TileLike.le_def, smul_fst, smul_snd, not_and_or] at sl \u22a2; right\n    have := disjoint_left.mp (h.mono_left sl.2) (mem_ball_self zero_lt_one)\n    rw [not_subset]; use \ud835\udcac q, mem_ball_self zero_lt_one\n  have usp : \ud835\udd05 k n u \u2286 \ud835\udd05 k n p := fun q mq \u21a6 by\n    rw [\ud835\udd05, mem_setOf] at mq \u22a2; exact \u27e8mq.1, plu.trans mq.2\u27e9\n  have u'sp : \ud835\udd05 k n u' \u2286 \ud835\udd05 k n p := fun q mq \u21a6 by\n    rw [\ud835\udd05, mem_setOf] at mq \u22a2; exact \u27e8mq.1, plu'.trans mq.2\u27e9\n  rw [\ud835\udd18\u2082, mem_setOf, \ud835\udd18\u2081, mem_setOf] at hu hu'\n  apply absurd (card_\ud835\udd05_of_mem_\u212d\u2081 mp).2; rw [not_lt]\n  calc\n    _ = 2 ^ j + 2 ^ j := Nat.two_pow_succ j\n    _ \u2264 (\ud835\udd05 k n u).toFinset.card + (\ud835\udd05 k n u').toFinset.card :=\n      add_le_add (card_\ud835\udd05_of_mem_\u212d\u2081 hu.1.1).1 (card_\ud835\udd05_of_mem_\u212d\u2081 hu'.1.1).1\n    _ = (\ud835\udd05 k n u \u222a \ud835\udd05 k n u').toFinset.card := by\n      rw [toFinset_union]; refine (Finset.card_union_of_disjoint ?_).symm\n      simpa using \ud835\udd05dj\n    _ \u2264 _ := by\n      apply Finset.card_le_card\n      simp_rw [toFinset_union, subset_toFinset, Finset.coe_union, coe_toFinset, union_subset_iff]\n      exact \u27e8usp, u'sp\u27e9\n\n/-- Lemma 5.4.1, part 1. -/\nlemma URel.eq (hu : u \u2208 \ud835\udd18\u2082 k n j) (hu' : u' \u2208 \ud835\udd18\u2082 k n j) (huu' : URel k n j u u') : \ud835\udcd8 u = \ud835\udcd8 u' := by\n  by_cases e : u = u'; \u00b7 rw [e]\n  have ndj := not_disjoint hu hu' huu'\n  have n\u2081 := (hu.1.2 _ hu'.1.1).mt ndj\n  rw [disjoint_comm] at ndj\n  have n\u2082 := (hu'.1.2 _ hu.1.1).mt ndj\n  simp_rw [URel, e, false_or, \ud835\udd17\u2081, mem_setOf] at huu'; obtain \u27e8p, \u27e8_, _, sl\u2081\u27e9, sl\u2082\u27e9 := huu'\n  rcases le_or_lt (\ud835\udd30 u) (\ud835\udd30 u') with h | h\n  \u00b7 exact eq_of_le_of_not_lt (Grid.le_dyadic h sl\u2081.1 sl\u2082.1) n\u2081\n  \u00b7 exact (eq_of_le_of_not_lt (Grid.le_dyadic h.le sl\u2082.1 sl\u2081.1) n\u2082).symm\n\n/-- Helper for 5.4.2 that is also used in 5.4.9. -/\nlemma urel_of_not_disjoint {x y : \ud835\udd13 X} (my : y \u2208 \ud835\udd18\u2082 k n j) (xye : \ud835\udcd8 x = \ud835\udcd8 y)\n    (nd : \u00acDisjoint (ball_(x) (\ud835\udcac x) 100) (ball_(y) (\ud835\udcac y) 100)) : URel k n j y x := by\n  rw [not_disjoint_iff] at nd\n  obtain \u27e8(\u03d1 : \u0398 X), (\u03d1x : \u03d1 \u2208 ball_{\ud835\udcd8 x} (\ud835\udcac x) 100), (\u03d1y : \u03d1 \u2208 ball_{\ud835\udcd8 y} (\ud835\udcac y) 100)\u27e9 := nd\n  rw [\ud835\udd18\u2082, mem_setOf, not_disjoint_iff] at my; obtain \u27e8p, hp, _\u27e9 := my.2\n  suffices w : ball_(x) (\ud835\udcac x) 1 \u2286 ball_(y) (\ud835\udcac y) 500 by\n    right; use p, hp; obtain \u27e8_, np, sl\u27e9 := hp\n    have hpy : smul 10 p \u2264 smul 500 y :=\n      (smul_mono_left (by norm_num)).trans (wiggle_order_500 sl np)\n    exact \u27e8(xye \u25b8 sl.1 : \ud835\udcd8 p \u2264 \ud835\udcd8 x), hpy.2.trans w\u27e9\n  intro (q : \u0398 X) (mq : q \u2208 ball_{\ud835\udcd8 x} (\ud835\udcac x) 1)\n  rw [@mem_ball] at mq \u22a2\n  calc\n    _ \u2264 dist_(y) q \u03d1 + dist_(y) \u03d1 (\ud835\udcac y) := dist_triangle ..\n    _ \u2264 dist_(y) q (\ud835\udcac x) + dist_(y) \u03d1 (\ud835\udcac x) + dist_(y) \u03d1 (\ud835\udcac y) := by\n      gcongr; apply dist_triangle_right\n    _ < 1 + 100 + 100 := by\n      gcongr\n      \u00b7 rwa [xye] at mq\n      \u00b7 rwa [@mem_ball, xye] at \u03d1x\n      \u00b7 rwa [@mem_ball] at \u03d1y\n    _ < _ := by norm_num\n\n/-- Lemma 5.4.2. -/\nlemma equivalenceOn_urel : EquivalenceOn (URel (X := X) k n j) (\ud835\udd18\u2082 k n j) where\n  refl _ _ := .rfl\n  trans {x y z} mx my mz xy yz := by\n    by_cases xny : x = y; \u00b7 rwa [xny]\n    have xye := URel.eq mx my xy\n    have hxy := URel.not_disjoint mx my xy\n    rw [not_disjoint_iff] at hxy\n    obtain \u27e8(\u03d1 : \u0398 X), (\u03d1x : \u03d1 \u2208 ball_{\ud835\udcd8 x} (\ud835\udcac x) 100), (\u03d1y : \u03d1 \u2208 ball_{\ud835\udcd8 y} (\ud835\udcac y) 100)\u27e9 := hxy\n    have yze := URel.eq my mz yz\n    have hyz := URel.not_disjoint my mz yz\n    rw [not_disjoint_iff] at hyz\n    obtain \u27e8(\u03b8 : \u0398 X), (\u03b8y : \u03b8 \u2208 ball_{\ud835\udcd8 y} (\ud835\udcac y) 100), (\u03b8z : \u03b8 \u2208 ball_{\ud835\udcd8 z} (\ud835\udcac z) 100)\u27e9 := hyz\n    simp_rw [URel, xny, false_or] at xy; obtain \u27e8p, mp, sp\u27e9 := xy\n    suffices ball_(z) (\ud835\udcac z) 1 \u2286 ball_(x) (\ud835\udcac x) 500 by\n      right; use p, mp; obtain \u27e8_, np, sl\u27e9 := mp\n      have w : ball_(x) (\ud835\udcac x) 500 \u2286 ball_(p) (\ud835\udcac p) 4 := (wiggle_order_500 sl np).2\n      exact \u27e8(yze \u25b8 xye \u25b8 sl.1 : \ud835\udcd8 p \u2264 \ud835\udcd8 z), (this.trans w).trans (ball_subset_ball (by norm_num))\u27e9\n    intro (q : \u0398 X) (mq : q \u2208 ball_{\ud835\udcd8 z} (\ud835\udcac z) 1)\n    rw [@mem_ball] at mq \u22a2\n    calc\n      _ \u2264 dist_(x) q \u03d1 + dist_(x) \u03d1 (\ud835\udcac x) := dist_triangle ..\n      _ < dist_(x) q \u03d1 + 100 := by gcongr; rwa [@mem_ball] at \u03d1x\n      _ \u2264 dist_(x) q (\ud835\udcac y) + dist_(x) \u03d1 (\ud835\udcac y) + 100 := by gcongr; exact dist_triangle_right ..\n      _ < dist_(x) q (\ud835\udcac y) + 100 + 100 := by gcongr; rwa [@mem_ball, \u2190 xye] at \u03d1y\n      _ \u2264 dist_(x) q \u03b8 + dist_(x) \u03b8 (\ud835\udcac y) + 100 + 100 := by gcongr; exact dist_triangle ..\n      _ < dist_(x) q \u03b8 + 100 + 100 + 100 := by gcongr; rwa [@mem_ball, \u2190 xye] at \u03b8y\n      _ \u2264 dist_(x) q (\ud835\udcac z) + dist_(x) \u03b8 (\ud835\udcac z) + 100 + 100 + 100 := by\n        gcongr; exact dist_triangle_right ..\n      _ < 1 + 100 + 100 + 100 + 100 := by\n        gcongr\n        \u00b7 rwa [\u2190 yze, \u2190 xye] at mq\n        \u00b7 rwa [@mem_ball, \u2190 yze, \u2190 xye] at \u03b8z\n      _ < _ := by norm_num\n  symm {x y} mx my xy := urel_of_not_disjoint my (URel.eq mx my xy) (URel.not_disjoint mx my xy)\n\n/-- `\ud835\udd18\u2083(k, n, j) \u2286 \ud835\udd18\u2082 k n j` is an arbitary set of representatives of `URel` on `\ud835\udd18\u2082 k n j`,\ngiven above (5.4.5). -/\ndef \ud835\udd18\u2083 (k n j : \u2115) : Set (\ud835\udd13 X) :=\n  (equivalenceOn_urel (k := k) (n := n) (j := j)).reprs\n\nlemma \ud835\udd18\u2083_subset_\ud835\udd18\u2082 : \ud835\udd18\u2083 k n j \u2286 \ud835\udd18\u2082 (X := X) k n j := EquivalenceOn.reprs_subset\n\n/-- The subset `\ud835\udd17\u2082(u)` of `\u212d\u2086(k, n, j)`, given in (5.4.5).\nIn lemmas, we will assume `u \u2208 \ud835\udd18\u2083 k n l` -/\ndef \ud835\udd17\u2082 (k n j : \u2115) (u : \ud835\udd13 X) : Set (\ud835\udd13 X) :=\n  \u212d\u2086 k n j \u2229 \u22c3 (u' \u2208 \ud835\udd18\u2082 k n j) (_ : URel k n j u u'), \ud835\udd17\u2081 k n j u'\n\nlemma \ud835\udd17\u2082_subset_\u212d\u2086 : \ud835\udd17\u2082 k n j u \u2286 \u212d\u2086 k n j := inter_subset_left ..\n\n/-- Lemma 5.4.3 -/\nlemma C6_forest : \u212d\u2086 (X := X) k n j = \u22c3 u \u2208 \ud835\udd18\u2083 k n j, \ud835\udd17\u2082 k n j u := by\n  ext p; constructor <;> intro h\n  \u00b7 have hp : p \u2208 \u212d\u2083 k n j := (\u212d\u2086_subset_\u212d\u2085 |>.trans \u212d\u2085_subset_\u212d\u2084 |>.trans \u212d\u2084_subset_\u212d\u2083) h\n    rw [\u212d\u2083, mem_diff, \ud835\udd0f\u2082, mem_setOf] at hp\n    have mp := hp.1\n    simp_rw [hp.1, true_and, not_not] at hp\n    obtain \u27e8u, mu, np, sl\u27e9 := hp\n    have mp' : p \u2208 \ud835\udd17\u2081 k n j u := by\n      rw [\ud835\udd17\u2081, mem_setOf]; exact \u27e8\u212d\u2082_subset_\u212d\u2081 mp, np, sl\u27e9\n    have mu' : u \u2208 \ud835\udd18\u2082 k n j := by\n      rw [\ud835\udd18\u2082, mem_setOf]; exact \u27e8mu, not_disjoint_iff.mpr \u27e8_, mp', h\u27e9\u27e9\n    let rr := equivalenceOn_urel (X := X) (k := k) (n := n) (j := j)\n    rw [mem_iUnion\u2082]; use rr.out u, (rr.out_mem_reprs mu')\n    refine \u27e8h, ?_\u27e9; rw [mem_iUnion\u2082]; use u, mu'; rw [mem_iUnion]; use rr.out_rel mu'\n  \u00b7 rw [mem_iUnion\u2082] at h; obtain \u27e8_, _, mp, _\u27e9 := h; exact mp\n\n/-- This one could deserve a lemma in the blueprint, as it is needed to decompose the sum\nof Carleson operators over disjoint subfamilies. -/\nlemma forest_disjoint : (\ud835\udd18\u2083 k n j).PairwiseDisjoint (fun u \u21a6 \ud835\udd17\u2082 (X := X) k n j u) := by\n  intro u hu u' hu' huu'\n  simp only [Function.onFun]\n  apply disjoint_left.2 (fun p pu pu' \u21a6 huu' ?_)\n  simp only [\ud835\udd17\u2082, mem_inter_iff, mem_iUnion, exists_prop, exists_and_left] at pu pu'\n  rcases pu.2 with \u27e8v, v_mem, v_rel, pv\u27e9\n  rcases pu'.2 with \u27e8v', v'_mem, v'_rel, pv'\u27e9\n  have E : URel k n j v v' :=\n    Or.inr \u27e8p, pv, smul_mono pv'.2.2 le_rfl (by norm_num)\u27e9\n  have : URel k n j u v' :=\n    (equivalenceOn_urel (X := X)).trans (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 hu) v_mem v'_mem v_rel E\n  have : URel k n j u u' := by\n    apply (equivalenceOn_urel (X := X)).trans (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 hu) v'_mem (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 hu') this\n    exact (equivalenceOn_urel (X := X)).symm (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 hu') v'_mem v'_rel\n  exact (equivalenceOn_urel (X := X)).reprs_inj hu hu' this\n\n/-- Lemma 5.4.4, verifying (2.0.32) -/\nlemma forest_geometry (hu : u \u2208 \ud835\udd18\u2083 k n j) (hp : p \u2208 \ud835\udd17\u2082 k n j u) : smul 4 p \u2264 smul 1 u := by\n  rw [\ud835\udd17\u2082, mem_inter_iff, mem_iUnion\u2082] at hp\n  obtain \u27e8_, u', mu', w\u27e9 := hp; rw [mem_iUnion] at w; obtain \u27e8ru, mp'\u27e9 := w\n  rw [\ud835\udd17\u2081, mem_setOf] at mp'; obtain \u27e8_, np, sl\u27e9 := mp'\n  have xye := URel.eq (EquivalenceOn.reprs_subset hu) mu' ru\n  have huu' := URel.not_disjoint (EquivalenceOn.reprs_subset hu) mu' ru\n  rw [not_disjoint_iff] at huu'\n  obtain \u27e8(\u03d1 : \u0398 X), (\u03d1x : \u03d1 \u2208 ball_{\ud835\udcd8 u} (\ud835\udcac u) 100), (\u03d1y : \u03d1 \u2208 ball_{\ud835\udcd8 u'} (\ud835\udcac u') 100)\u27e9 := huu'\n  suffices ball_(u) (\ud835\udcac u) 1 \u2286 ball_(u') (\ud835\udcac u') 500 by\n    have w : smul 4 p \u2264 smul 500 u' := (wiggle_order_500 sl np)\n    exact \u27e8(xye \u25b8 sl.1 : \ud835\udcd8 p \u2264 \ud835\udcd8 u), w.2.trans this\u27e9\n  intro (q : \u0398 X) (mq : q \u2208 ball_{\ud835\udcd8 u} (\ud835\udcac u) 1)\n  rw [@mem_ball] at mq \u22a2\n  calc\n    _ \u2264 dist_(u') q \u03d1 + dist_(u') \u03d1 (\ud835\udcac u') := dist_triangle ..\n    _ \u2264 dist_(u') q (\ud835\udcac u) + dist_(u') \u03d1 (\ud835\udcac u) + dist_(u') \u03d1 (\ud835\udcac u') := by\n      gcongr; apply dist_triangle_right\n    _ < 1 + 100 + 100 := by\n      gcongr\n      \u00b7 rwa [xye] at mq\n      \u00b7 rwa [@mem_ball, xye] at \u03d1x\n      \u00b7 rwa [@mem_ball] at \u03d1y\n    _ < _ := by norm_num\n\n/-- Lemma 5.4.5, verifying (2.0.33) -/\nlemma forest_convex : OrdConnected (\ud835\udd17\u2082 k n j u) := by\n  rw [ordConnected_def]; intro p mp p'' mp'' p' mp'\n  have mp'\u2085 : p' \u2208 \u212d\u2085 (X := X) k n j :=\n    (ordConnected_C5.out ((\ud835\udd17\u2082_subset_\u212d\u2086.trans \u212d\u2086_subset_\u212d\u2085) mp)\n      ((\ud835\udd17\u2082_subset_\u212d\u2086.trans \u212d\u2086_subset_\u212d\u2085) mp'')) mp'\n  have mp'\u2086 : p' \u2208 \u212d\u2086 k n j := by\n    have hp := \ud835\udd17\u2082_subset_\u212d\u2086 mp; rw [\u212d\u2086, mem_setOf] at hp \u22a2\n    refine \u27e8mp'\u2085, ?_\u27e9; have hpG := hp.2; contrapose! hpG\n    exact mp'.1.1.1.trans hpG\n  simp_rw [\ud835\udd17\u2082, mem_inter_iff, mp'\u2086, true_and, mem_iUnion\u2082, mem_iUnion] at mp'' \u22a2\n  obtain \u27e8u', mu', ru, _, np'', sl\u27e9 := mp''.2\n  have pnu : \ud835\udcd8 p' < \ud835\udcd8 u' := (mp'.2.1).trans_lt (lt_of_le_of_ne sl.1 np'')\n  use u', mu', ru; rw [\ud835\udd17\u2081, mem_setOf]\n  use (\u212d\u2085_subset_\u212d\u2084 |>.trans \u212d\u2084_subset_\u212d\u2083 |>.trans \u212d\u2083_subset_\u212d\u2082 |>.trans \u212d\u2082_subset_\u212d\u2081) mp'\u2085, pnu.ne\n  exact (wiggle_order_11_10 mp'.2 (C5_3_3_le (X := X).trans (by norm_num))).trans sl\n\n/-- Lemma 5.4.6, verifying (2.0.36)\nNote: swapped `u` and `u'` to match (2.0.36) -/\nlemma forest_separation (hu : u \u2208 \ud835\udd18\u2083 k n j) (hu' : u' \u2208 \ud835\udd18\u2083 k n j) (huu' : u \u2260 u')\n    (hp : p \u2208 \ud835\udd17\u2082 k n j u') (h : \ud835\udcd8 p \u2264 \ud835\udcd8 u) : 2 ^ (Z * (n + 1)) < dist_(p) (\ud835\udcac p) (\ud835\udcac u) := by\n  simp_rw [\ud835\udd17\u2082, mem_inter_iff, mem_iUnion\u2082, mem_iUnion] at hp\n  obtain \u27e8mp\u2086, v, mv, rv, \u27e8-, np, sl\u27e9\u27e9 := hp\n  obtain \u27e8p', mp', lp', sp'\u27e9 := exists_scale_add_le_of_mem_layersAbove <|\n    (\u212d\u2086_subset_\u212d\u2085 |>.trans \u212d\u2085_subset_\u212d\u2084 |>.trans \u212d\u2084_subset_\u212d\u2083 |>.trans \u212d\u2083_subset_\u212d\u2082) mp\u2086\n  have np'u : \u00acURel k n j v u := by\n    by_contra h; apply absurd (Eq.symm _) huu'\n    replace h := equivalenceOn_urel.trans (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 hu') mv (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 hu) rv h\n    exact EquivalenceOn.reprs_inj hu' hu h\n  have vnu : v \u2260 u := by by_contra h; subst h; exact absurd URel.rfl np'u\n  simp_rw [URel, vnu, false_or, not_exists, not_and] at np'u\n  have mpt : p' \u2208 \ud835\udd17\u2081 k n j v := by\n    refine \u27e8minLayer_subset mp', ?_, ?_\u27e9\n    \u00b7 exact (lp'.1.trans_lt (lt_of_le_of_ne sl.1 np)).ne\n    \u00b7 exact (wiggle_order_11_10 lp' (C5_3_3_le (X := X).trans (by norm_num))).trans sl\n  specialize np'u p' mpt\n  have \ud835\udcd8p'u : \ud835\udcd8 p' \u2264 \ud835\udcd8 u := lp'.1.trans h\n  simp_rw [TileLike.le_def, smul_fst, smul_snd, \ud835\udcd8p'u, true_and,\n    not_subset_iff_exists_mem_not_mem] at np'u\n  obtain \u27e8(q : \u0398 X), mq, nq\u27e9 := np'u\n  simp_rw [mem_ball, not_lt] at mq nq\n  have d8 : 8 < dist_(p') (\ud835\udcac p) (\ud835\udcac u) :=\n    calc\n      _ = 10 - 1 - 1 := by norm_num\n      _ < 10 - 1 - dist_(u) q (\ud835\udcac u) := by gcongr\n      _ \u2264 10 - 1 - dist_(p') q (\ud835\udcac u) := tsub_le_tsub_left (Grid.dist_mono \ud835\udcd8p'u) _\n      _ \u2264 dist_(p') q (\ud835\udcac p') - 1 - dist_(p') q (\ud835\udcac u) := by gcongr\n      _ < dist_(p') q (\ud835\udcac p') - dist_(p') (\ud835\udcac p) (\ud835\udcac p') - dist_(p') q (\ud835\udcac u) := by\n        gcongr; rw [\u2190 @mem_ball]; exact subset_cball (lp'.2 \ud835\udcac_mem_\u03a9)\n      _ \u2264 _ := by\n        rw [sub_le_iff_le_add', sub_le_iff_le_add]\n        nth_rw 3 [dist_comm]; apply dist_triangle4\n  have Znpos : 0 < Z * (n + 1) := by rw [defaultZ]; positivity\n  let d : \u2115 := (\ud835\udd30 p - \ud835\udd30 p').toNat\n  have sd : \ud835\udd30 p' + d = \ud835\udd30 p := by simp_rw [d]; rw [Int.toNat_sub_of_le] <;> omega\n  have d1 : dist_(p') (\ud835\udcac p) (\ud835\udcac u) \u2264 C2_1_2 a ^ d * dist_(p) (\ud835\udcac p) (\ud835\udcac u) :=\n    Grid.dist_strictMono_iterate lp'.1 sd\n  have Cdpos : 0 < C2_1_2 a ^ d := by rw [C2_1_2]; positivity\n  have Cidpos : 0 < (C2_1_2 a)\u207b\u00b9 ^ d := by rw [C2_1_2]; positivity\n  calc\n    _ \u2264 (C2_1_2 a)\u207b\u00b9 ^ (Z * (n + 1)) := by\n      refine pow_le_pow_left\u2080 zero_le_two ?_ _\n      nth_rw 1 [C2_1_2, \u2190 Real.inv_rpow zero_le_two, \u2190 Real.rpow_neg_one,\n        \u2190 Real.rpow_mul zero_le_two, neg_one_mul, neg_mul, neg_neg, \u2190 Real.rpow_one 2]\n      apply Real.rpow_le_rpow_of_exponent_le one_le_two\n      norm_cast; linarith [four_le_a X]\n    _ \u2264 (C2_1_2 a)\u207b\u00b9 ^ d := by\n      refine pow_le_pow_right\u2080 ?_ (by omega)\n      simp_rw [one_le_inv_iff\u2080, C2_1_2_le_one (X := X), and_true, C2_1_2]; positivity\n    _ \u2264 (C2_1_2 a)\u207b\u00b9 ^ d * 8 := by nth_rw 1 [\u2190 mul_one (_ ^ d)]; gcongr; norm_num\n    _ < (C2_1_2 a)\u207b\u00b9 ^ d * dist_(p') (\ud835\udcac p) (\ud835\udcac u) := by gcongr\n    _ \u2264 _ := by\n      rwa [\u2190 mul_le_mul_iff_of_pos_left Cdpos, inv_pow, \u2190 mul_assoc, mul_inv_cancel\u2080 Cdpos.ne',\n        one_mul]\n\n/-- Lemma 5.4.7, verifying (2.0.37) -/\nlemma forest_inner (hu : u \u2208 \ud835\udd18\u2083 k n j) (hp : p \u2208 \ud835\udd17\u2082 k n j u) :\n    ball (\ud835\udd20 p) (8 * D ^ \ud835\udd30 p) \u2286 \ud835\udcd8 u := by\n  have p\u2084 := (\ud835\udd17\u2082_subset_\u212d\u2086.trans \u212d\u2086_subset_\u212d\u2085 |>.trans \u212d\u2085_subset_\u212d\u2084) hp\n  have p\u2081 := (\u212d\u2084_subset_\u212d\u2083.trans \u212d\u2083_subset_\u212d\u2082 |>.trans \u212d\u2082_subset_\u212d\u2081) p\u2084\n  obtain \u27e8q, mq, lq, sq\u27e9 := exists_le_add_scale_of_mem_layersBelow p\u2084\n  obtain \u27e8-, u'', mu'', nu'', sl\u27e9 := \u212d\u2083_def.mp (maxLayer_subset mq)\n  replace nu'' : \ud835\udcd8 q < \ud835\udcd8 u'' := lt_of_le_of_ne sl.1 nu''\n  have s2 : smul 2 p \u2264 smul 2 q := wiggle_order_11_10 lq (C5_3_3_le (X := X).trans (by norm_num))\n  have s2' : smul 2 p \u2264 smul 1 u'' := s2.trans sl\n  have s10 : smul 10 p \u2264 smul 1 u'' := smul_mono s2' le_rfl (by norm_num)\n  simp_rw [\ud835\udd17\u2082, mem_inter_iff, mem_iUnion\u2082, mem_iUnion] at hp\n  obtain \u27e8p\u2086, u', mu', ru', pu'\u27e9 := hp\n  have ur : URel k n j u' u'' := Or.inr \u27e8p, pu', s10\u27e9\n  have hu'' : u'' \u2208 \ud835\udd18\u2082 k n j := by\n    rw [\ud835\udd18\u2082, mem_setOf, not_disjoint_iff]\n    refine \u27e8mu'', \u27e8p, ?_, p\u2086\u27e9\u27e9\n    simpa [\ud835\udd17\u2081, p\u2081, s2'] using (lq.1.trans_lt nu'').ne\n  have ru'' : URel k n j u u'' := equivalenceOn_urel.trans (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 hu) mu' hu'' ru' ur\n  have qlu : \ud835\udcd8 q < \ud835\udcd8 u := URel.eq (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 hu) hu'' ru'' \u25b8 nu''\n  have squ : \ud835\udd30 q < \ud835\udd30 u := (Grid.lt_def.mp qlu).2\n  have spu : \ud835\udd30 p \u2264 \ud835\udd30 u - (Z * (n + 1) : \u2115) - 1 := by omega\n  have \u27e8I, sI, plI, Ilu\u27e9 : \u2203 I, s I = \ud835\udd30 u - (Z * (n + 1) : \u2115) - 1 \u2227 \ud835\udcd8 p \u2264 I \u2227 I \u2264 \ud835\udcd8 u := by\n    apply Grid.exists_sandwiched (lq.1.trans qlu.le) (\ud835\udd30 u - (Z * (n + 1) : \u2115) - 1)\n    refine \u27e8spu, ?_\u27e9\n    change _ \u2264 \ud835\udd30 u\n    omega\n  have bI : I \u2209 \ud835\udcdb n u := by\n    have p\u2085 := \u212d\u2086_subset_\u212d\u2085 p\u2086\n    rw [\u212d\u2085_def] at p\u2085; replace p\u2085 := p\u2085.2; contrapose! p\u2085\n    use u, (\ud835\udd18\u2083_subset_\ud835\udd18\u2082.trans \ud835\udd18\u2082_subset_\ud835\udd18\u2081) hu, plI.1.trans (subset_biUnion_of_mem p\u2085)\n  rw [\ud835\udcdb, mem_setOf, not_and] at bI; specialize bI Ilu\n  rw [not_and, not_not] at bI; specialize bI (by omega); rw [\u2190 sI] at spu\n  rcases spu.eq_or_lt with h | h\n  \u00b7 have hI : \ud835\udcd8 p = I := by\n      apply eq_of_le_of_not_lt plI; rw [Grid.lt_def, not_and_or, not_lt]; exact Or.inr h.symm.le\n    rwa [\u2190 hI] at bI\n  \u00b7 apply subset_trans (ball_subset_ball' _) bI\n    have ds : c (\ud835\udcd8 p) \u2208 ball (c I) (4 * D ^ s I) := (plI.1.trans Grid_subset_ball) Grid.c_mem_Grid\n    rw [mem_ball] at ds\n    calc\n      _ \u2264 4 * D * (D : \u211d) ^ \ud835\udd30 p + 4 * D ^ s I := by\n        gcongr\n        \u00b7 linarith [four_le_realD X]\n        \u00b7 exact ds.le\n      _ = 4 * D ^ (\ud835\udd30 p + 1) + 4 * D ^ s I := by\n        rw [mul_assoc]; congr; rw [mul_comm, \u2190 zpow_add_one\u2080 (defaultD_pos _).ne']\n      _ \u2264 4 * D ^ s I + 4 * D ^ s I := by\n        gcongr\n        \u00b7 exact one_le_D\n        \u00b7 omega\n      _ = _ := by ring\n\n/-- The multiplicity appearing in Lemma 5.4.8. -/\ndef C5_4_8 (n : \u2115) : \u2115 := (4 * n + 12) * 2 ^ n\n\nlemma exists_smul_le_of_\ud835\udd18\u2083 (u : \ud835\udd18\u2083 k n j) : \u2203 m : \ud835\udd10 (X := X) k n, smul 100 u.1 \u2264 smul 1 m.1 := by\n  obtain \u27e8u, mu\u27e9 := u\n  replace mu := (\ud835\udd18\u2083_subset_\ud835\udd18\u2082.trans \ud835\udd18\u2082_subset_\ud835\udd18\u2081 |>.trans \ud835\udd18\u2081_subset_\u212d\u2081) mu\n  rw [\u212d\u2081, mem_diff, pre\u212d\u2081, mem_setOf, filter_mem_univ_eq_toFinset] at mu\n  replace mu := (show 0 < 2 ^ j by positivity).trans_le mu.1.2\n  rw [Finset.card_pos] at mu; obtain \u27e8m, hm\u27e9 := mu\n  rw [mem_toFinset, \ud835\udd05] at hm; exact \u27e8\u27e8m, hm.1\u27e9, hm.2\u27e9\n\nvariable (k n j) in\n/-- The good choice of an element to get a contradiction in the proof of Lemma 5.4.8. -/\ndef mf (u : \ud835\udd18\u2083 (X := X) k n j) : \ud835\udd10 (X := X) k n := (exists_smul_le_of_\ud835\udd18\u2083 u).choose\n\nlemma mf_injOn : InjOn (mf k n j) {u | x \u2208 \ud835\udcd8 u.1} := fun u mu u' mu' e \u21a6 by\n  set m := mf k n j u\n  have iu : smul 100 u.1 \u2264 smul 1 m.1 := (exists_smul_le_of_\ud835\udd18\u2083 u).choose_spec\n  have iu' : smul 100 u'.1 \u2264 smul 1 m.1 := e \u25b8 (exists_smul_le_of_\ud835\udd18\u2083 u').choose_spec\n  have su : ball_{\ud835\udcd8 m.1} (\ud835\udcac m.1) 1 \u2286 ball_{\ud835\udcd8 u.1} (\ud835\udcac u.1) 100 := iu.2\n  have su' : ball_{\ud835\udcd8 m.1} (\ud835\udcac m.1) 1 \u2286 ball_{\ud835\udcd8 u'.1} (\ud835\udcac u'.1) 100 := iu'.2\n  have nd : \u00acDisjoint (ball_{\ud835\udcd8 u.1} (\ud835\udcac u.1) 100) (ball_{\ud835\udcd8 u'.1} (\ud835\udcac u'.1) 100) := by\n    rw [not_disjoint_iff]\n    use \ud835\udcac m.1, su (mem_ball_self zero_lt_one), su' (mem_ball_self zero_lt_one)\n  by_contra! h; rw [\u2190 Subtype.coe_ne_coe] at h; apply absurd _ nd\n  have nr : \u00acURel k n j u.1 u'.1 := by contrapose! h; exact EquivalenceOn.reprs_inj u.2 u'.2 h\n  have n\ud835\udcd8 : \ud835\udcd8 u.1 \u2260 \ud835\udcd8 u'.1 := by\n    contrapose! nr; rw [disjoint_comm] at nd\n    exact urel_of_not_disjoint (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 u.2) nr.symm nd\n  rcases le_or_lt (s (\ud835\udcd8 u.1)) (s (\ud835\udcd8 u'.1)) with hs | hs\n  \u00b7 have hu := lt_of_le_of_ne ((le_or_disjoint hs).resolve_right\n      (not_disjoint_iff.mpr \u27e8_, mu, mu'\u27e9)) n\ud835\udcd8\n    have u\u2081 := (\ud835\udd18\u2083_subset_\ud835\udd18\u2082.trans \ud835\udd18\u2082_subset_\ud835\udd18\u2081) u.2\n    exact u\u2081.2 u' ((\ud835\udd18\u2083_subset_\ud835\udd18\u2082.trans \ud835\udd18\u2082_subset_\ud835\udd18\u2081 |>.trans \ud835\udd18\u2081_subset_\u212d\u2081) u'.2) hu\n  \u00b7 have hu := lt_of_le_of_ne ((le_or_disjoint hs.le).resolve_right\n      (not_disjoint_iff.mpr \u27e8_, mu', mu\u27e9)) n\ud835\udcd8.symm\n    have u'\u2081 := (\ud835\udd18\u2083_subset_\ud835\udd18\u2082.trans \ud835\udd18\u2082_subset_\ud835\udd18\u2081) u'.2\n    exact (u'\u2081.2 u ((\ud835\udd18\u2083_subset_\ud835\udd18\u2082.trans \ud835\udd18\u2082_subset_\ud835\udd18\u2081 |>.trans \ud835\udd18\u2081_subset_\u212d\u2081) u.2) hu).symm\n\nlemma stackSize_\ud835\udd18\u2083_le_\ud835\udd10 (x : X) : stackSize (\ud835\udd18\u2083 k n j) x \u2264 stackSize (\ud835\udd10 k n) x := by\n  let mf' : \ud835\udd13 X \u2192 \ud835\udd13 X := fun u \u21a6 if mu : u \u2208 \ud835\udd18\u2083 k n j then mf k n j \u27e8u, mu\u27e9 else default\n  simp_rw [stackSize, indicator_apply, Pi.one_apply, Finset.sum_boole, Nat.cast_id]\n  refine Finset.card_le_card_of_injOn mf' (fun u mu \u21a6 ?_) (fun u mu u' mu' e \u21a6 ?_)\n  \u00b7 simp_rw [Finset.mem_filter, Finset.mem_univ, true_and] at mu \u22a2\n    simp_rw [mf', mu.1, dite_true]\n    have hu : \ud835\udcd8 u \u2264 \ud835\udcd8 (mf k n j \u27e8u, mu.1\u27e9) := (exists_smul_le_of_\ud835\udd18\u2083 \u27e8u, mu.1\u27e9).choose_spec.1\n    exact \u27e8(mf k n j \u27e8u, mu.1\u27e9).2, hu.1 mu.2\u27e9\n  \u00b7 simp_rw [Finset.coe_filter, mem_setOf, Finset.mem_filter, Finset.mem_univ, true_and] at mu mu'\n    simp_rw [mf', mu.1, mu'.1, dite_true, Subtype.val_inj] at e\n    simpa using mf_injOn mu.2 mu'.2 e\n\n/-- Lemma 5.4.8, used to verify that \ud835\udd18\u2084 satisfies 2.0.34. -/\nlemma forest_stacking (x : X) (hkn : k \u2264 n) : stackSize (\ud835\udd18\u2083 (X := X) k n j) x \u2264 C5_4_8 n := by\n  by_contra! h\n  let C : Finset (\ud835\udd13 X) := { u | u \u2208 \ud835\udd18\u2083 (X := X) k n j \u2227 x \u2208 \ud835\udcd8 u }\n  have Cc : C.card = stackSize (\ud835\udd18\u2083 k n j) x := by\n    simp_rw [stackSize, indicator_apply, Pi.one_apply, Finset.sum_boole, Nat.cast_id,\n      C, Grid.mem_def, Finset.filter_filter]\n  have Cn : C.Nonempty := by\n    by_contra! Ce; rw [Finset.not_nonempty_iff_eq_empty] at Ce\n    simp_rw [\u2190 Cc, Ce, Finset.card_empty, not_lt_zero'] at h\n  let C' : Finset (Grid X) := C.image \ud835\udcd8\n  have C'n : C'.Nonempty := by rwa [Finset.image_nonempty]\n  obtain \u27e8i, mi, li\u27e9 := C'.exists_minimal C'n\n  simp_rw [C', Finset.mem_image, C, Finset.mem_filter, Finset.mem_univ, true_and] at mi\n  obtain \u27e8u, \u27e8mu, mx\u27e9, uei\u27e9 := mi; subst uei\n  have uA : (\ud835\udcd8 u : Set X) \u2286 setA (2 * n + 6) k n := fun y my \u21a6\n    calc\n      _ = (4 * n + 12) * 2 ^ n := by ring\n      _ < stackSize (\ud835\udd18\u2083 k n j) x := h\n      _ \u2264 stackSize (\ud835\udd18\u2083 k n j) y := by\n        simp_rw [stackSize, indicator_apply, Pi.one_apply, Finset.sum_boole, Nat.cast_id]\n        apply Finset.card_le_card fun v mv \u21a6 ?_\n        simp_rw [Finset.mem_filter, Finset.mem_univ, true_and] at mv \u22a2\n        have mvC' : \ud835\udcd8 v \u2208 C' := by\n          simp_rw [C', Finset.mem_image]; use v\n          simp_rw [C, Finset.mem_filter, Finset.mem_univ, true_and, and_true]; exact mv\n        specialize li _ mvC'\n        have inc := (or_assoc.mpr (le_or_ge_or_disjoint (i := \ud835\udcd8 u) (j := \ud835\udcd8 v))).resolve_right\n          (not_disjoint_iff.mpr \u27e8_, mx, mv.2\u27e9)\n        simp_rw [le_iff_eq_or_lt] at inc\n        replace inc : \ud835\udcd8 u = \ud835\udcd8 v \u2228 \ud835\udcd8 u < \ud835\udcd8 v := by tauto\n        rw [\u2190 le_iff_eq_or_lt] at inc\n        exact \u27e8mv.1, inc.1 my\u27e9\n      _ \u2264 _ := stackSize_\ud835\udd18\u2083_le_\ud835\udd10 _\n  refine absurd (disjoint_left.mpr fun v mv \u21a6 ?_) (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 mu).2\n  rw [\ud835\udd17\u2081, mem_setOf] at mv; rw [\u212d\u2086, mem_setOf, not_and, not_not]\n  refine fun _ \u21a6 (mv.2.2.1).1.trans ?_\n  calc\n    _ \u2286 setA (2 * n + 6) k n := uA\n    _ \u2286 G\u2082 := subset_iUnion\u2082_of_subset n k (subset_iUnion_of_subset hkn subset_rfl)\n    _ \u2286 _ := subset_union_of_subset_left subset_union_right G\u2083\n\n/-- Define `\ud835\udd18\u2084 k n j l` as the union of `2 ^ n` disjoint subfamilies in `\ud835\udd18\u2083 k n j`, to make sure\nthe multiplicity is at most `2 ^ n` to get a forest. -/\ndef \ud835\udd18\u2084 (k n j l : \u2115) : Set (\ud835\udd13 X) :=\n  \u22c3 i \u2208 Ico (l * 2 ^ n) ((l + 1) * 2 ^ n), iteratedMaximalSubfamily (\ud835\udd18\u2083 k n j) i\n\nlemma \ud835\udd18\u2084_subset_\ud835\udd18\u2083 {k n j l} : \ud835\udd18\u2084 (X := X) k n j l \u2286 \ud835\udd18\u2083 k n j := by\n  simp [\ud835\udd18\u2084, iteratedMaximalSubfamily_subset]\n\n/-- The sets `(\ud835\udd18\u2084(k, n, j, l))_l` form a partition of `\ud835\udd18\u2083 k n j`. -/\nlemma iUnion_\ud835\udd18\u2084 (hkn : k \u2264 n) : \u22c3 l \u2208 Iio (4 * n + 12), \ud835\udd18\u2084 (X := X) k n j l = \ud835\udd18\u2083 k n j := by\n  have : \u22c3 l \u2208 Iio (4 * n + 12), \ud835\udd18\u2084 (X := X) k n j l =\n      \u22c3 i < (4 * n + 12) * 2 ^ n, iteratedMaximalSubfamily (\ud835\udd18\u2083 k n j) i := by\n    apply Subset.antisymm\n    \u00b7 simp only [mem_Iio, \ud835\udd18\u2084, mem_Ico, biUnion_and', iUnion_subset_iff]\n      intro l i hi hl h'i\n      apply subset_biUnion_of_mem\n      change i + 1 \u2264 (4 * n + 12) * 2 ^ n\n      suffices i < (4 * n + 12) * 2 ^ n by omega\n      exact h'i.trans_le (mul_le_mul' (by omega) le_rfl)\n    \u00b7 simp only [\ud835\udd18\u2084, iUnion_subset_iff]\n      intro i hi\n      let l := i / 2 ^ n\n      have : iteratedMaximalSubfamily (\ud835\udd18\u2083 k n j) i \u2286 \u22c3 i \u2208 Ico (l * 2 ^ n) ((l + 1) * 2 ^ n),\n          iteratedMaximalSubfamily (X := X) (\ud835\udd18\u2083 k n j) i := by\n        apply subset_biUnion_of_mem\n        refine \u27e8Nat.div_mul_le_self _ _, ?_\u27e9\n        rw [\u2190 Nat.div_lt_iff_lt_mul (Nat.two_pow_pos n)]\n        exact lt_add_one _\n      apply this.trans\n      apply subset_biUnion_of_mem (u := fun l \u21a6\n        \u22c3 i \u2208 Ico (l * 2 ^ n) ((l + 1) * 2 ^ n), iteratedMaximalSubfamily (\ud835\udd18\u2083 k n j) i)\n      simp only [mem_Iio, l]\n      rwa [Nat.div_lt_iff_lt_mul (Nat.two_pow_pos n)]\n  rw [this, eq_comm]\n  apply eq_biUnion_iteratedMaximalSubfamily\n  intro x\n  apply forest_stacking x hkn\n\n", "theoremStatement": "lemma C6_forest' (hkn : k \u2264 n) :\n    \u212d\u2086 (X := X) k n j = \u22c3 l \u2208 Iio (4 * n + 12), \u22c3 u \u2208 \ud835\udd18\u2084 k n j l, \ud835\udd17\u2082 k n j u ", "theoremName": "C6_forest'", "fileCreated": {"commit": "310e13d16e51600777fc841833f4bce112b5f73a", "date": "2024-09-24"}, "theoremCreated": {"commit": "88d85ba29f717ee3bb9fbd37379a6fb77b57265f", "date": "2025-01-06"}, "file": "carleson/Carleson/Discrete/ForestUnion.lean", "module": "Carleson.Discrete.ForestUnion", "jsonFile": "Carleson.Discrete.ForestUnion.jsonl", "positionMetadata": {"lineInFile": 592, "tokenPositionInFile": 29266, "theoremPositionInFile": 38}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 6, "repositoryPremises": true, "numRepositoryPremises": 20, "numPremises": 87}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [C6_forest, \u2190 iUnion_\ud835\udd18\u2084 hkn]\n  simp", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 46}}
{"srcContext": "import Carleson.ToMathlib.DoublingMeasure\nimport Carleson.ToMathlib.WeakType\nimport Mathlib.Algebra.Order.Group.Int\nimport Mathlib.Analysis.CStarAlgebra.Classes\nimport Mathlib.Data.Int.Star\n\nopen MeasureTheory Measure NNReal Metric Complex Set TopologicalSpace Bornology Function\nopen scoped ENNReal\nnoncomputable section\n\n-- todo: rename and protect `Real.RCLike`\n\n/-! Miscellaneous definitions.\nThese are mostly the definitions used to state the metric Carleson theorem.\nWe should move them to separate files once we start proving things about them. -/\n\nsection DoublingMeasure\nuniverse u\n\nvariable {\ud835\udd5c X : Type*} {A : \u2115} [_root_.RCLike \ud835\udd5c] [PseudoMetricSpace X]\n\nsection localOscillation\n\n/-- The local oscillation of two functions w.r.t. a set `E`. This is `d_E` in the blueprint. -/\ndef localOscillation (E : Set X) (f g : C(X, \ud835\udd5c)) : \u211d\u22650\u221e :=\n  \u2a06 z \u2208 E \u00d7\u02e2 E, ENNReal.ofReal \u2016f z.1 - g z.1 - f z.2 + g z.2\u2016\n\n-- example (E : Set X) (hE : IsBounded E) (f : C(X, \u211d)) :\n--     BddAbove (range fun z : E \u21a6 f z) := by\n--   have : IsCompact (closure E) := IsBounded.isCompact_closure hE\n--   sorry\n\n-- lemma bddAbove_localOscillation (E : Set X) [Fact (IsBounded E)] (f g : C(X, \ud835\udd5c)) :\n--     BddAbove ((fun z : X \u00d7 X \u21a6 \u2016f z.1 - g z.1 - f z.2 + g z.2\u2016) '' E \u00d7\u02e2 E) := sorry\n\nvariable {E : Set X} {f g : C(X, \ud835\udd5c)}\n\n--old\n/-- A ball w.r.t. the distance `localOscillation` -/\ndef localOscillationBall (E : Set X) (f : C(X, \ud835\udd5c)) (r : \u211d) :\n    Set C(X, \ud835\udd5c) :=\n  { g : C(X, \ud835\udd5c) | localOscillation E f g < ENNReal.ofReal r }\n\nend localOscillation\n\nlemma fact_isCompact_ball (x : X) (r : \u211d) : Fact (IsBounded (ball x r)) :=\n  \u27e8isBounded_ball\u27e9\nattribute [local instance] fact_isCompact_ball\n\n/-- A class stating that continuous functions have distances associated to every ball.\nWe use a separate type to conveniently index these functions. -/\nclass FunctionDistances (\ud835\udd5c : outParam Type*) (X : Type u)\n    [NormedField \ud835\udd5c] [TopologicalSpace X] where\n  \u0398 : Type u\n  coe\u0398 : \u0398 \u2192 C(X, \ud835\udd5c)\n  coe\u0398_injective {f g : \u0398} (h : \u2200 x, coe\u0398 f x = coe\u0398 g x) : f = g\n  metric : \u2200 (_x : X) (_r : \u211d), PseudoMetricSpace \u0398\n\nexport FunctionDistances (\u0398 coe\u0398)\n\nsection FunctionDistances\nvariable [FunctionDistances \ud835\udd5c X]\n\ninstance : Coe (\u0398 X) C(X, \ud835\udd5c) := \u27e8FunctionDistances.coe\u0398\u27e9\ninstance : FunLike (\u0398 X) X \ud835\udd5c where\n  coe := fun f \u21a6 (f : C(X, \ud835\udd5c))\n  coe_injective' _ _ hfg := FunctionDistances.coe\u0398_injective fun x \u21a6 congrFun hfg x\ninstance : ContinuousMapClass (\u0398 X) X \ud835\udd5c := \u27e8fun f \u21a6 (f : C(X, \ud835\udd5c)).2\u27e9\n\nset_option linter.unusedVariables false in\n@[nolint unusedArguments]\ndef WithFunctionDistance (x : X) (r : \u211d) := \u0398 X\n\nvariable {x : X} {r : \u211d}\n\ndef toWithFunctionDistance [FunctionDistances \ud835\udd5c X] : \u0398 X \u2243 WithFunctionDistance x r :=\n  .refl _\n\n-- instance : FunLike (WithFunctionDistance \u0398 x r) X \ud835\udd5c := ContinuousMap.funLike\n-- instance : ContinuousMapClass (WithFunctionDistance \u0398 x r) X \ud835\udd5c :=\n--   ContinuousMap.toContinuousMapClass\n\ninstance [d : FunctionDistances \ud835\udd5c X] : PseudoMetricSpace (WithFunctionDistance x r) :=\n  d.metric x r\n\nend FunctionDistances\n\nnotation3 \"dist_{\" x \" ,\" r \"}\" => @dist (WithFunctionDistance x r) _\nnotation3 \"nndist_{\" x \" ,\" r \"}\" => @nndist (WithFunctionDistance x r) _\nnotation3 \"ball_{\" x \" ,\" r \"}\" => @ball (WithFunctionDistance x r) _ in\n\n/-- A set `\u0398` of (continuous) functions is compatible. `A` will usually be `2 ^ a`. -/\nclass CompatibleFunctions (\ud835\udd5c : outParam Type*) (X : Type u) (A : outParam \u2115)\n  [RCLike \ud835\udd5c] [PseudoMetricSpace X] extends FunctionDistances \ud835\udd5c X where\n  eq_zero : \u2203 o : X, \u2200 f : \u0398, f o = 0\n  /-- The distance is bounded below by the local oscillation. (1.0.7) -/\n  localOscillation_le_cdist {x : X} {r : \u211d} {f g : \u0398} :\n    localOscillation (ball x r) (coe\u0398 f) (coe\u0398 g) \u2264 ENNReal.ofReal (dist_{x, r} f g)\n  /-- The distance is monotone in the ball. (1.0.9) -/\n  cdist_mono {x\u2081 x\u2082 : X} {r\u2081 r\u2082 : \u211d} {f g : \u0398}\n    (h : ball x\u2081 r\u2081 \u2286 ball x\u2082 r\u2082) : dist_{x\u2081, r\u2081} f g \u2264 dist_{x\u2082, r\u2082} f g\n  /-- The distance of a ball with large radius is bounded above. (1.0.8) -/\n  cdist_le {x\u2081 x\u2082 : X} {r : \u211d} {f g : \u0398} (h : dist x\u2081 x\u2082 < 2 * r) :\n    dist_{x\u2082, 2 * r} f g \u2264 A * dist_{x\u2081, r} f g\n  /-- The distance of a ball with large radius is bounded below. (1.0.10) -/\n  le_cdist {x\u2081 x\u2082 : X} {r : \u211d} {f g : \u0398} (h1 : ball x\u2081 r \u2286 ball x\u2082 (A * r)) :\n    /-(h2 : A * r \u2264 Metric.diam (univ : Set X))-/\n    2 * dist_{x\u2081, r} f g \u2264 dist_{x\u2082, A * r} f g\n  /-- The distance of a ball with large radius is bounded below. (1.0.11) -/\n  ballsCoverBalls {x : X} {r R : \u211d} :\n    BallsCoverBalls (X := WithFunctionDistance x r) (2 * R) R A\n\ninstance nonempty_Space [CompatibleFunctions \ud835\udd5c X A] : Nonempty X := by\n  obtain \u27e8x,_\u27e9 := \u2039CompatibleFunctions \ud835\udd5c X A\u203a.eq_zero\n  use x\n\ninstance inhabited_Space [CompatibleFunctions \ud835\udd5c X A] : Inhabited X :=\n  \u27e8nonempty_Space.some\u27e9\n\nlemma le_localOscillation [CompatibleFunctions \ud835\udd5c X A] (x : X) (r : \u211d) (f g : \u0398 X) {y z : X}\n    (hy : y \u2208 ball x r) (hz : z \u2208 ball x r) : \u2016coe\u0398 f y - coe\u0398 g y - coe\u0398 f z + coe\u0398 g z\u2016 \u2264\n    ENNReal.toReal (localOscillation (ball x r) (coe\u0398 f) (coe\u0398 g)) := by\n  rw [(ENNReal.toReal_ofReal (norm_nonneg _)).symm]\n  let f (z) := \u2a06 (_ : z \u2208 ball x r \u00d7\u02e2 ball x r), ENNReal.ofReal \u2016f z.1 - g z.1 - f z.2 + g z.2\u2016\n  apply ENNReal.toReal_mono\n  \u00b7 exact lt_of_le_of_lt CompatibleFunctions.localOscillation_le_cdist ENNReal.ofReal_lt_top |>.ne\n  \u00b7 exact le_of_eq_of_le (Eq.symm (iSup_pos \u27e8hy, hz\u27e9)) (le_iSup f \u27e8y, z\u27e9)\n\nlemma oscillation_le_cdist [CompatibleFunctions \ud835\udd5c X A] (x : X) (r : \u211d) (f g : \u0398 X) {y z : X}\n    (hy : y \u2208 ball x r) (hz : z \u2208 ball x r) :\n    \u2016coe\u0398 f y - coe\u0398 g y - coe\u0398 f z + coe\u0398 g z\u2016 \u2264 dist_{x, r} f g := by\n  apply le_trans <| le_localOscillation x r f g hy hz\n  rw [\u2190 ENNReal.toReal_ofReal dist_nonneg]\n  exact ENNReal.toReal_mono ENNReal.ofReal_ne_top CompatibleFunctions.localOscillation_le_cdist\n\nexport CompatibleFunctions (localOscillation_le_cdist cdist_mono cdist_le le_cdist)\n\nlemma dist_congr [FunctionDistances \ud835\udd5c X] {x\u2081 x\u2082 : X} {r\u2081 r\u2082 : \u211d} {f g : \u0398 X}\n    (e\u2081 : x\u2081 = x\u2082) (e\u2082 : r\u2081 = r\u2082) : dist_{x\u2081, r\u2081} f g = dist_{x\u2082, r\u2082} f g := by congr\n\nvariable (X) in\n/-- The point `o` in the blueprint -/\ndef cancelPt [CompatibleFunctions \ud835\udd5c X A] : X :=\n  CompatibleFunctions.eq_zero (\ud835\udd5c := \ud835\udd5c) |>.choose\nlemma cancelPt_eq_zero [CompatibleFunctions \ud835\udd5c X A] {f : \u0398 X} : f (cancelPt X) = 0 :=\n  CompatibleFunctions.eq_zero (\ud835\udd5c := \ud835\udd5c) |>.choose_spec f\n\n-- not sure if needed\n-- lemma CompatibleFunctions.IsSeparable [CompatibleFunctions \ud835\udd5c X A] :\n--   IsSeparable (range (coe\u0398 (X := X))) :=\n--   sorry\n\nset_option linter.unusedVariables false in\n/-- The inhomogeneous Lipschitz norm on a ball. -/\ndef iLipNorm {\ud835\udd5c} [NormedField \ud835\udd5c] (\u03d5 : X \u2192 \ud835\udd5c) (x\u2080 : X) (R : \u211d) : \u211d :=\n  (\u2a06 x \u2208 ball x\u2080 R, \u2016\u03d5 x\u2016) + R * \u2a06 (x : X) (y : X) (h : x \u2260 y), \u2016\u03d5 x - \u03d5 y\u2016 / dist x y\n\nlemma iLipNorm_nonneg {\ud835\udd5c} [NormedField \ud835\udd5c] {\u03d5 : X \u2192 \ud835\udd5c} {x\u2080 : X} {R : \u211d} (hR : 0 \u2264 R) :\n    0 \u2264 iLipNorm \u03d5 x\u2080 R :=\n  add_nonneg (Real.iSup_nonneg fun _ \u21a6 Real.iSup_nonneg fun _ \u21a6 norm_nonneg _)\n    (mul_nonneg hR (Real.iSup_nonneg fun _ \u21a6 Real.iSup_nonneg fun _ \u21a6 Real.iSup_nonneg\n    fun _ \u21a6 div_nonneg (norm_nonneg _) dist_nonneg))\n\nvariable [DoublingMeasure X A]\n\nvariable (X) in\n/-- \u0398 is \u03c4-cancellative. `\u03c4` will usually be `1 / a` -/\nclass IsCancellative (\u03c4 : \u211d) [CompatibleFunctions \u211d X A] : Prop where\n  norm_integral_exp_le {x : X} {r : \u211d} {\u03d5 : X \u2192 \u2102} {K : \u211d\u22650} (h1 : LipschitzWith K \u03d5)\n    (h2 : tsupport \u03d5 \u2286 ball x r) {f g : \u0398 X} :\n    \u2016\u222b x in ball x r, exp (I * (f x - g x)) * \u03d5 x\u2016 \u2264\n    A * volume.real (ball x r) * iLipNorm \u03d5 x r * (1 + dist_{x, r} f g) ^ (- \u03c4)\n\nexport IsCancellative (norm_integral_exp_le)\n\n/-- The \"volume function\" `V`. Note that we will need to assume\n`IsFiniteMeasureOnCompacts` and `ProperSpace` to actually know that this volume is finite. -/\ndef Real.vol {X : Type*} [PseudoMetricSpace X] [MeasureSpace X] (x y : X) : \u211d :=\n  volume.real (ball x (dist x y))\n\n-- /-- In Mathlib we only have the operator norm for continuous linear maps,\n-- and `T_*` is not linear.\n-- Here is the norm for an arbitrary map `T` between normed spaces\n-- (the infimum is defined to be 0 if the operator is not bounded). -/\n-- def operatorNorm {E F : Type*} [NormedAddCommGroup E] [NormedAddCommGroup F] (T : E \u2192 F) : \u211d :=\n--   sInf { c | 0 \u2264 c \u2227 \u2200 x, \u2016T x\u2016 \u2264 c * \u2016x\u2016 }\n\n/-- The Calderon Zygmund operator `T_r` in chapter Two-sided Metric Space Carleson -/\ndef CZOperator (K : X \u2192 X \u2192 \u2102) (r : \u211d) (f : X \u2192 \u2102) (x : X) : \u2102 :=\n  \u222b y in (ball x r)\u1d9c, K x y * f y\n\n/-- `R_Q(\u03b8, x)` defined in (1.0.20). -/\ndef upperRadius [FunctionDistances \u211d X] (Q : X \u2192 \u0398 X) (\u03b8 : \u0398 X) (x : X) : \u211d\u22650\u221e :=\n  \u2a06 (r : \u211d) (_ : dist_{x, r} \u03b8 (Q x) < 1), ENNReal.ofReal r\n\n", "theoremStatement": "lemma le_upperRadius [FunctionDistances \u211d X] {Q : X \u2192 \u0398 X} {\u03b8 : \u0398 X} {x : X} {r : \u211d}\n    (hr : dist_{x, r} \u03b8 (Q x) < 1) : ENNReal.ofReal r \u2264 upperRadius Q \u03b8 x ", "theoremName": "le_upperRadius", "fileCreated": {"commit": "238b977db22d5b1107a09468e95b78facfd58fd1", "date": "2023-10-20"}, "theoremCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "file": "carleson/Carleson/Defs.lean", "module": "Carleson.Defs", "jsonFile": "Carleson.Defs.jsonl", "positionMetadata": {"lineInFile": 196, "tokenPositionInFile": 8554, "theoremPositionInFile": 18}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 5, "repositoryPremises": true, "numRepositoryPremises": 5, "numPremises": 29}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  apply le_iSup\u2082 (f := fun r _ \u21a6 ENNReal.ofReal r) r hr", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 61}}
{"srcContext": "import Carleson.Classical.HilbertKernel\nimport Carleson.Classical.DirichletKernel\nimport Carleson.Classical.SpectralProjectionBound\n\n/- This file contains the proof that the Hilbert kernel is a bounded operator. -/\n\nnoncomputable section\n\nopen scoped Real ENNReal\nopen Complex ComplexConjugate MeasureTheory Bornology Set\n-- open MeasureTheory Function Metric Bornology Real ENNReal MeasureTheory.ENNReal MeasureTheory\n\n\n\nsection\n@[reducible]\ndef doublingMeasure_real_two : DoublingMeasure \u211d 2 :=\n  InnerProductSpace.DoublingMeasure.mono (by simp)\n\ninstance doublingMeasure_real_16 : DoublingMeasure \u211d (2 ^ 4 : \u2115) :=\n  doublingMeasure_real_two.mono (by norm_num)\nend\n\n/-- The modulation operator `M_n g`, defined in (11.3.1) -/\ndef modulationOperator (n : \u2124) (g : \u211d \u2192 \u2102) (x : \u211d) : \u2102 :=\n  g x * Complex.exp (.I * n * x)\n\n/-- The approximate Hilbert transform `L_N g`, defined in (11.3.2).\ndefined slightly differently. -/\ndef approxHilbertTransform (n : \u2115) (g : \u211d \u2192 \u2102) (x : \u211d) : \u2102 :=\n  (n : \u2102)\u207b\u00b9 * \u2211 k \u2208 .Ico n (2 * n),\n    modulationOperator (-k) (partialFourierSum k (modulationOperator k g)) x\n\n/-- The kernel `k_r(x)` defined in (11.3.11).\nWhen used, we may assume that `r \u2208 Ioo 0 1`.\nTodo: find better name? -/\ndef niceKernel (r : \u211d) (x : \u211d) : \u211d :=\n  if Complex.exp (.I * x) = 1 then r\u207b\u00b9 else\n    min r\u207b\u00b9 (1 + r / normSq (1 - Complex.exp (.I * x)))\n\n-- todo: write lemmas for `niceKernel` (periodicity, evenness)\n\n", "theoremStatement": "/-- Lemma 11.1.8 -/\nlemma mean_zero_oscillation {n : \u2124} (hn : n \u2260 0) :\n    \u222b x in (0)..2 * \u03c0, Complex.exp (.I * n * x) = 0 ", "theoremName": "mean_zero_oscillation", "fileCreated": {"commit": "068d8329dd78e1232054702f7bfdf1f8123a656a", "date": "2025-01-23"}, "theoremCreated": {"commit": "068d8329dd78e1232054702f7bfdf1f8123a656a", "date": "2025-01-23"}, "file": "carleson/Carleson/Classical/HilbertStrongType.lean", "module": "Carleson.Classical.HilbertStrongType", "jsonFile": "Carleson.Classical.HilbertStrongType.jsonl", "positionMetadata": {"lineInFile": 43, "tokenPositionInFile": 1418, "theoremPositionInFile": 4}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 139}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [integral_exp_mul_complex (by simp [hn])]\n  simp [sub_eq_zero, Complex.exp_eq_one_iff, hn, \u2190 mul_assoc, mul_comm Complex.I,\n    mul_right_comm _ Complex.I]", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 166}}
{"srcContext": "/-\nCopyright (c) 2024 James Sundstrom. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: James Sundstrom\n-/\nimport Mathlib.MeasureTheory.Constructions.BorelSpace.Metric\n\n/-!\n# Annulus\n\nIn this file we define an annulus in a pseudometric space `X` to be a set consisting of all `y`\nsuch that `dist x y` lies in an interval between `r` and `R`. An annulus is defined for each type\nof interval (`Ioo`, `Ioc`, etc.) with a parallel naming scheme, except that we do not define annuli\nfor `Iio` and `Ico`, as they would be balls.\n\nWe also define `EAnnulus` similarly using `edist` instead of `dist`.\n\n## Tags\n\nannulus, eannulus\n-/\n\nopen Set Metric ENNReal\n\nvariable {X : Type*} [PseudoMetricSpace X]\n\nnamespace Set\n\nnamespace Annulus\n\ndef oo (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d) := {y | dist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d) := {y | dist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d) := {y | dist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d) := {y | dist x y \u2208 Ici r}\n\nlemma oo_eq {x : X} {r R : \u211d} : oo x r R = ball x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oo, dist_comm, and_comm]\n\nlemma oc_eq {x : X} {r R : \u211d} : oc x r R = closedBall x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oc, dist_comm, and_comm]\n\nlemma co_eq {x : X} {r R : \u211d} : co x r R = ball x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [co, dist_comm, and_comm]\n\nlemma cc_eq {x : X} {r R : \u211d} : cc x r R = closedBall x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [cc, dist_comm, and_comm]\n\nlemma oi_eq {x : X} {r : \u211d} : oi x r = (closedBall x r)\u1d9c := by\n  ext; simp [oi, dist_comm]\n\nlemma ci_eq {x : X} {r : \u211d} : ci x r = (ball x r)\u1d9c := by\n  ext; simp [ci, dist_comm]\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : co x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma co_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : co x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\nlemma cc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : cc x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma cc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : cc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\n@[simp]\nlemma oc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    oc x r r' \u222a oo x r' R = oo x r R := by\n  ext; simp_rw [oc, oo, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioo_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    oc x r r' \u222a oc x r' R = oc x r R := by\n  ext; simp_rw [oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_co {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a co x r' R = oo x r R := by\n  ext; simp_rw [oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ico_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a cc x r' R = oc x r R := by\n  ext; simp_rw [oo, cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Icc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    cc x r r' \u222a oo x r' R = co x r R := by\n  ext; simp_rw [cc, oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioo_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    cc x r r' \u222a oc x r' R = cc x r R := by\n  ext; simp_rw [cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_co {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a co x r' R = co x r R := by\n  ext; simp_rw [co, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ico_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a cc x r' R = cc x r R := by\n  ext; simp_rw [co, cc, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Icc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : oc x r R \u222a oi x R = oi x r := by\n  ext; simp_rw [oc, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioi_eq_Ioi h]\n\n@[simp]\nlemma oo_union_ci {x : X} {r R : \u211d} (h : r < R) :\n    oo x r R \u222a ci x R = oi x r := by\n  ext; simp_rw [oo, ci, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ici_eq_Ioi h]\n\n@[simp]\nlemma cc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : cc x r R \u222a oi x R = ci x r := by\n  ext; simp_rw [cc, oi, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioi_eq_Ici h]\n\n@[simp]\nlemma co_union_ci {x : X} {r R : \u211d} (h : r \u2264 R) : co x r R \u222a ci x R = ci x r := by\n  ext; simp_rw [co, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ici_eq_Ici h]\n\n\nvariable [MeasurableSpace X] [OpensMeasurableSpace X]\n\n@[measurability]\nlemma measurableSet_oo {x : X} {r R : \u211d} : MeasurableSet (oo x r R) := by\n  rw [oo_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oc {x : X} {r R : \u211d} : MeasurableSet (oc x r R) := by\n rw [oc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_co {x : X} {r R : \u211d} : MeasurableSet (co x r R) := by\n  rw [co_eq]; measurability\n\n@[measurability]\nlemma measurableSet_cc {x : X} {r R : \u211d} : MeasurableSet (cc x r R) := by\n rw [cc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oi {x : X} {r : \u211d} : MeasurableSet (oi x r) := by\n  rw [oi_eq]; measurability\n\n@[measurability]\nlemma measurableSet_ci {x : X} {r : \u211d} : MeasurableSet (ci x r) := by\n  rw [ci_eq]; measurability\n\nend Annulus\n\nnamespace EAnnulus\n\ndef oo (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ici r}\n\n\nlemma oo_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oo x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oo x r R := by\n  simp_rw [oo, Annulus.oo, edist_dist, mem_Ioo, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma oc_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [oc, Annulus.oc, edist_dist, mem_Ioc, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  \u00b7 have R_le_r := (lt_of_lt_of_le (lt_of_not_ge hR) hr).le\n    rw [Annulus.oc_eq_empty R_le_r]\n    refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n    exact not_le_of_gt (lt_of_le_of_lt (ENNReal.ofReal_le_ofReal R_le_r) hy.1) hy.2\n\nlemma co_eq_annulus {x : X} {r R : \u211d} :\n    co x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.co x r R := by\n  simp_rw [co, Annulus.co, edist_dist, mem_Ico, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma cc_eq_annulus {x : X} {r R : \u211d} (h : r > 0 \u2228 R \u2265 0) :\n    cc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.cc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [cc, Annulus.cc, edist_dist, mem_Icc, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  have r0 := h.resolve_right hR\n  have R_lt_r := (lt_of_not_ge hR).trans r0\n  rw [Annulus.cc_eq_empty R_lt_r]\n  refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n  exact not_le_of_gt ((ENNReal.ofReal_lt_ofReal_iff r0).mpr R_lt_r) (hy.1.trans hy.2)\n\nlemma oi_eq_annulus {x : X} {r : \u211d} (hr : r \u2265 0) : oi x (ENNReal.ofReal r) = Annulus.oi x r := by\n  simp_rw [oi, Annulus.oi, edist_dist, mem_Ioi, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr]\n\nlemma ci_eq_annulus {x : X} {r : \u211d} : ci x (ENNReal.ofReal r) = Annulus.ci x r := by\n  simp_rw [ci, Annulus.ci, edist_dist, mem_Ici, ENNReal.ofReal_le_ofReal_iff dist_nonneg]\n\n\nlemma oo_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oo x r R = ball x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oo, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma oc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oc x r R = closedBall x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oc, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma co_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    co x r R = ball x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [co, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma cc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    cc x r R = closedBall x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [cc, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma oi_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : oi x r = (closedBall x r.toReal)\u1d9c := by\n  ext; simp [oi, edist_dist, dist_comm, lt_ofReal_iff_toReal_lt hr.ne]\n\nlemma ci_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : ci x r = (ball x r.toReal)\u1d9c := by\n  ext; simp [ci, edist_dist, dist_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg]\n\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n@[simp]\nlemma cc_top_eq_empty {x : X} {R : \u211d\u22650\u221e} : cc x \u22a4 R = \u2205 :=\n  eq_empty_of_forall_not_mem (fun y hy \u21a6 (edist_ne_top x y) (top_le_iff.mp hy.1))\n\n@[simp]\nlemma oi_eq_empty {x : X} : oi x \u22a4 = \u2205 := by simp [oi, edist_dist]\n\n@[simp]\nlemma ci_eq_empty {x : X} : ci x \u22a4 = \u2205 := by simp [ci, edist_dist]\n\n\nlemma oo_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) :\n    oo x r \u22a4 = (closedBall x r.toReal)\u1d9c := by\n  ext; simpa [oo, edist_dist, dist_comm] using lt_ofReal_iff_toReal_lt hr.ne\n\nlemma oc_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) :\n    oc x r \u22a4 = (closedBall x r.toReal)\u1d9c := by\n  ext; simpa [oc, edist_dist, dist_comm] using lt_ofReal_iff_toReal_lt hr.ne\n\nlemma co_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : co x r \u22a4 = (ball x r.toReal)\u1d9c := by\n  ext; simpa [co, edist_dist, dist_comm] using le_ofReal_iff_toReal_le hr.ne dist_nonneg\n\nlemma cc_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : cc x r \u22a4 = (ball x r.toReal)\u1d9c := by\n  ext; simpa [cc, edist_dist, dist_comm] using le_ofReal_iff_toReal_le hr.ne dist_nonneg\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\n", "theoremStatement": "lemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 ", "theoremName": "Set.EAnnulus.co_subset_oo", "fileCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "theoremCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "file": "carleson/Carleson/ToMathlib/Annulus.lean", "module": "Carleson.ToMathlib.Annulus", "jsonFile": "Carleson.ToMathlib.Annulus.jsonl", "positionMetadata": {"lineInFile": 412, "tokenPositionInFile": 16146, "theoremPositionInFile": 99}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 25}, "proofMetadata": {"hasProof": true, "proof": ":=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 70}}
{"srcContext": "import Carleson.Forest\nimport Carleson.ToMathlib.HardyLittlewood\nimport Carleson.ToMathlib.BoundedCompactSupport\nimport Carleson.ToMathlib.Misc\nimport Carleson.Psi\n\nopen ShortVariables TileStructure\nvariable {X : Type*} {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102} {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X}\n  [MetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] [TileStructure Q D \u03ba S o]\n  {n j j' : \u2115} {t : Forest X n} {u u\u2081 u\u2082 p : \ud835\udd13 X} {x x' : X} {\ud835\udd16 : Set (\ud835\udd13 X)}\n  {f f\u2081 f\u2082 g g\u2081 g\u2082 : X \u2192 \u2102} {I J J' L : Grid X}\nvariable {E' : Type*} [NormedAddCommGroup E'] [NormedSpace \u211d E']\n\nnoncomputable section\n\nopen Set MeasureTheory Metric Function Complex Bornology TileStructure Classical Filter\nopen scoped NNReal ENNReal ComplexConjugate\n\nnamespace TileStructure.Forest\n\n/-! ## Section 7.1 and Lemma 7.1.3 -/\n\nvariable (t) in\n/-- The definition `\u03c3(u, x)` given in Section 7.1.\nWe may assume `u \u2208 t` whenever proving things about this definition. -/\ndef \u03c3 (u : \ud835\udd13 X) (x : X) : Finset \u2124 := .image \ud835\udd30 { p | p \u2208 t u \u2227 x \u2208 E p }\n\nvariable (t) in\nprivate lemma exists_p_of_mem_\u03c3 (u : \ud835\udd13 X) (x : X) {s : \u2124} (hs : s \u2208 t.\u03c3 u x) :\n    \u2203 p \u2208 t.\ud835\udd17 u, x \u2208 E p \u2227 \ud835\udd30 p = s := by\n  have \u27e8p, hp\u27e9 := Finset.mem_image.mp hs\n  simp only [mem_\ud835\udd17, Finset.mem_filter] at hp\n  use p, hp.1.2.1, hp.1.2.2, hp.2\n\n/- \\overline{\u03c3} from the blueprint. -/\nvariable (t) in\ndef \u03c3Max (u : \ud835\udd13 X) (x : X) (h\u03c3 : (t.\u03c3 u x).Nonempty) : \u2124 :=\n  t.\u03c3 u x |>.max' h\u03c3\n\n/- \\underline{\u03c3} from the blueprint. -/\nvariable (t) in\ndef \u03c3Min (u : \ud835\udd13 X) (x : X) (h\u03c3 : (t.\u03c3 u x).Nonempty) : \u2124 :=\n  t.\u03c3 u x |>.min' h\u03c3\n\nvariable (t) in\nprivate lemma \u03c3Max_mem_\u03c3 (u : \ud835\udd13 X) (x : X) (h\u03c3 : (t.\u03c3 u x).Nonempty) : \u03c3Max t u x h\u03c3 \u2208 t.\u03c3 u x :=\n  (t.\u03c3 u x).max'_mem h\u03c3\n\n/-- The definition of `\ud835\udcd9\u2080(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcd9\u2080 (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {J : Grid X | s J = -S \u2228 \u2200 p \u2208 \ud835\udd16, \u00ac(\ud835\udcd8 p : Set X) \u2286 ball (c J) (100 * D ^ (s J + 1))}\n\n/-- The definition of `\ud835\udcd9(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcd9 (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {x | Maximal (\u00b7 \u2208 \ud835\udcd9\u2080 \ud835\udd16) x}\n\nlemma \ud835\udcd9_subset_\ud835\udcd9\u2080 {\ud835\udd16 : Set (\ud835\udd13 X)} : \ud835\udcd9 \ud835\udd16 \u2286 \ud835\udcd9\u2080 \ud835\udd16 := sep_subset ..\n\nlemma pairwiseDisjoint_\ud835\udcd9 : (\ud835\udcd9 \ud835\udd16).PairwiseDisjoint (fun I \u21a6 (I : Set X)) := fun I mI J mJ hn \u21a6 by\n  have : IsAntichain (\u00b7 \u2264 \u00b7) (\ud835\udcd9 \ud835\udd16) := setOf_maximal_antichain _\n  exact (le_or_ge_or_disjoint.resolve_left (this mI mJ hn)).resolve_left (this mJ mI hn.symm)\n\n/-- The definition of `\ud835\udcdb\u2080(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcdb\u2080 (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {L : Grid X | s L = -S \u2228 (\u2203 p \u2208 \ud835\udd16, L \u2264 \ud835\udcd8 p) \u2227 \u2200 p \u2208 \ud835\udd16, \u00ac\ud835\udcd8 p \u2264 L}\n\n/-- The definition of `\ud835\udcdb(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcdb (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {x | Maximal (\u00b7 \u2208 \ud835\udcdb\u2080 \ud835\udd16) x}\n\nlemma \ud835\udcdb_subset_\ud835\udcdb\u2080 {\ud835\udd16 : Set (\ud835\udd13 X)} : \ud835\udcdb \ud835\udd16 \u2286 \ud835\udcdb\u2080 \ud835\udd16 := sep_subset ..\n\nprivate lemma s_le_s_of_mem_\ud835\udcdb {\ud835\udd16 : Set (\ud835\udd13 X)} {L : Grid X} (hL : L \u2208 \ud835\udcdb \ud835\udd16)\n    {p : \ud835\udd13 X} (hp : p \u2208 \ud835\udd16) (hpL : \u00ac Disjoint (\ud835\udcd8 p : Set X) (L : Set X)) : s L \u2264 s (\ud835\udcd8 p) := by\n  simp only [\ud835\udcdb, \ud835\udcdb\u2080, Grid.le_def, not_and, not_le, and_imp] at hL\n  rcases hL.1 with h | h\n  \u00b7 exact h \u25b8 (range_s_subset \u27e8\ud835\udcd8 p, rfl\u27e9).1\n  \u00b7 by_contra!\n    exact lt_asymm this <| h.2 p hp <| (GridStructure.fundamental_dyadic' this.le).resolve_right hpL\n\nprivate lemma subset_of_mem_\ud835\udcdb {\ud835\udd16 : Set (\ud835\udd13 X)} {L : Grid X} (hL : L \u2208 \ud835\udcdb \ud835\udd16) {p : \ud835\udd13 X}\n    (hp : p \u2208 \ud835\udd16) (hpL : \u00ac Disjoint (\ud835\udcd8 p : Set X) (L : Set X)) : (L : Set X) \u2286 (\ud835\udcd8 p : Set X) :=\n  GridStructure.fundamental_dyadic' (s_le_s_of_mem_\ud835\udcdb hL hp hpL) |>.resolve_right fun h \u21a6 hpL h.symm\n\n/-- The projection operator `P_\ud835\udcd2 f(x)`, given above Lemma 7.1.3.\nIn lemmas the `c` will be pairwise disjoint on `C`. -/\ndef approxOnCube (C : Set (Grid X)) (f : X \u2192 E') (x : X) : E' :=\n  \u2211 J \u2208 { p | p \u2208 C }, (J : Set X).indicator (fun _ \u21a6 \u2a0d y in J, f y) x\n\nlemma stronglyMeasurable_approxOnCube (C : Set (Grid X)) (f : X \u2192 E') :\n    StronglyMeasurable (approxOnCube (X := X) (K := K) C f) :=\n  Finset.stronglyMeasurable_sum _ (fun _ _ \u21a6 stronglyMeasurable_const.indicator coeGrid_measurable)\n\nlemma integrable_approxOnCube (C : Set (Grid X)) {f : X \u2192 E'} : Integrable (approxOnCube C f) := by\n  refine integrable_finset_sum _ (fun i hi \u21a6 ?_)\n  constructor\n  \u00b7 exact (aestronglyMeasurable_indicator_iff coeGrid_measurable).mpr aestronglyMeasurable_const\n  \u00b7 simp_rw [hasFiniteIntegral_iff_enorm, enorm_indicator_eq_indicator_enorm]\n    apply lt_of_le_of_lt <| lintegral_indicator_const_le (i : Set X) _\n    exact ENNReal.mul_lt_top ENNReal.coe_lt_top volume_coeGrid_lt_top\n\nlemma approxOnCube_nonneg {C : Set (Grid X)} {f : X \u2192 \u211d} (hf : \u2200 (y : X), f y \u2265 0) {x : X} :\n    approxOnCube C f x \u2265 0 :=\n  Finset.sum_nonneg' (fun _ \u21a6 Set.indicator_nonneg (fun _ _ \u21a6 integral_nonneg hf) _)\n\nlemma approxOnCube_apply {C : Set (Grid X)} (hC : C.PairwiseDisjoint (fun I \u21a6 (I : Set X)))\n    (f : X \u2192 E') {x : X} {J : Grid X} (hJ : J \u2208 C) (xJ : x \u2208 J) :\n    (approxOnCube C f) x = \u2a0d y in J, f y := by\n  rw [approxOnCube, \u2190 Finset.sum_filter_not_add_sum_filter _ (J = \u00b7)]\n  have eq0 : \u2211 i \u2208 Finset.filter (\u00ac J = \u00b7) (Finset.univ.filter (\u00b7 \u2208 C)),\n      (i : Set X).indicator (fun _ \u21a6 \u2a0d y in i, f y) x = 0 := by\n    suffices \u2200 i \u2208 (Finset.univ.filter (\u00b7 \u2208 C)).filter (\u00ac J = \u00b7),\n      (i : Set X).indicator (fun _ \u21a6 \u2a0d y in i, f y) x = 0 by simp [Finset.sum_congr rfl this]\n    intro i hi\n    simp only [Finset.mem_filter, Finset.mem_univ, true_and] at hi\n    apply indicator_of_not_mem <|\n      Set.disjoint_left.mp ((hC.eq_or_disjoint hJ hi.1).resolve_left hi.2) xJ\n  have eq_ave : \u2211 i \u2208 (Finset.univ.filter (\u00b7 \u2208 C)).filter (J = \u00b7),\n      (i : Set X).indicator (fun _ \u21a6 \u2a0d y in i, f y) x = \u2a0d y in J, f y := by\n    suffices (Finset.univ.filter (\u00b7 \u2208 C)).filter (J = \u00b7) = {J} by simp [this, xJ, \u2190 Grid.mem_def]\n    exact subset_antisymm (fun _ h \u21a6 Finset.mem_singleton.mpr (Finset.mem_filter.mp h).2.symm)\n      (fun _ h \u21a6 by simp [Finset.mem_singleton.mp h, hJ])\n  rw [eq0, eq_ave, zero_add]\n\nlemma boundedCompactSupport_approxOnCube {\ud835\udd5c : Type*} [RCLike \ud835\udd5c] {C : Set (Grid X)} {f : X \u2192 \ud835\udd5c} :\n    BoundedCompactSupport (approxOnCube C f) :=\n  BoundedCompactSupport.finset_sum fun J hJ \u21a6\n    BoundedCompactSupport.indicator_of_isBounded_range (by simp) stronglyMeasurable_const\n    ((isBounded_iff_subset_ball (c J)).mpr \u27e84 * D ^ s J, Grid_subset_ball\u27e9) coeGrid_measurable\n\n-- Used in the proof of Lemma 7.1.6\nlemma integral_eq_lintegral_approxOnCube {C : Set (Grid X)}\n    (hC : C.PairwiseDisjoint fun I \u21a6 (I : Set X)) {J : Grid X} (hJ : J \u2208 C) {f : X \u2192 \u2102}\n    (hf : BoundedCompactSupport f) : ENNReal.ofReal (\u222b y in J, \u2016f y\u2016) =\n    \u222b\u207b (y : X) in J, \u2016approxOnCube C (fun x \u21a6 (\u2016f x\u2016 : \u2102)) y\u2016\u208a := by\n  have nonneg : 0 \u2264\u1da0[ae (volume.restrict J)] fun y \u21a6 \u2016f y\u2016 := Filter.Eventually.of_forall (by simp)\n  have vol_J_ne_zero := (volume_coeGrid_pos (X := X) (i := J) (defaultD_pos' a)).ne.symm\n  have eq : \u222b\u207b (y : X) in J, \u2016approxOnCube C (fun x \u21a6 (\u2016f x\u2016 : \u2102)) y\u2016\u208a =\n      \u222b\u207b y in (J : Set X), ENNReal.ofReal (\u2a0d z in J, \u2016f z\u2016) := by\n    refine setLIntegral_congr_fun coeGrid_measurable (Filter.Eventually.of_forall fun y hy \u21a6 ?_)\n    rw [approxOnCube_apply hC _ hJ hy, ENNReal.ofReal]\n    \u00b7 apply congrArg\n      have : \u2016\u2a0d y in J, (\u2016f y\u2016 : \u2102)\u2016\u208a = \u2016\u2a0d y in J, \u2016f y\u2016\u2016\u208a := by\n        convert congrArg (\u2016\u00b7\u2016\u208a) <| integral_ofReal (f := (\u2016f \u00b7\u2016)) using 1\n        simp [average]\n      exact this \u25b8 (Real.toNNReal_eq_nnnorm_of_nonneg <| integral_nonneg (fun y \u21a6 by simp)).symm\n  rw [ofReal_integral_eq_lintegral_ofReal hf.integrable.norm.restrict nonneg,\n    eq, lintegral_const, average_eq, smul_eq_mul, ENNReal.ofReal_mul, ENNReal.ofReal_inv_of_pos,\n    ENNReal.ofReal_toReal, ofReal_integral_eq_lintegral_ofReal hf.norm.integrable nonneg, mul_comm,\n    \u2190 mul_assoc, Measure.restrict_apply MeasurableSet.univ, univ_inter,\n    ENNReal.mul_inv_cancel vol_J_ne_zero volume_coeGrid_lt_top.ne, one_mul]\n  \u00b7 simp [volume_coeGrid_lt_top.ne]\n  \u00b7 simpa using ENNReal.toReal_pos vol_J_ne_zero volume_coeGrid_lt_top.ne\n  \u00b7 exact inv_nonneg.mpr ENNReal.toReal_nonneg\n\nlemma approxOnCube_ofReal (C : Set (Grid X)) (f : X \u2192 \u211d) (x : X) :\n    approxOnCube C (Complex.ofReal <| f \u00b7) x = Complex.ofReal (approxOnCube C f x) := by\n  simp_rw [approxOnCube, ofReal_sum]\n  refine Finset.sum_congr rfl (fun J _ \u21a6 ?_)\n  by_cases hx : x \u2208 (J : Set X)\n  \u00b7 simpa only [indicator_of_mem hx] using integral_ofReal\n  \u00b7 simp only [indicator_of_not_mem hx, ofReal_zero]\n\nlemma norm_approxOnCube_le_approxOnCube_norm {C : Set (Grid X)} {f : X \u2192 E'} {x : X} :\n    \u2016approxOnCube C f x\u2016 \u2264 approxOnCube C (\u2016f \u00b7\u2016) x := by\n  refine (norm_sum_le _ _).trans <| Finset.sum_le_sum (fun J hJ \u21a6 ?_)\n  rw [norm_indicator_eq_indicator_norm]\n  gcongr\n  apply norm_integral_le_integral_norm\n\n/-- The definition `I_i(x)`, given above Lemma 7.1.3.\nThe cube of scale `s` that contains `x`. There is at most 1 such cube, if it exists. -/\ndef cubeOf (i : \u2124) (x : X) : Grid X :=\n  Classical.epsilon (fun I \u21a6 x \u2208 I \u2227 s I = i)\n\nlemma cubeOf_spec {i : \u2124} (hi : i \u2208 Icc (-S : \u2124) S) (I : Grid X) {x : X} (hx : x \u2208 I) :\n    x \u2208 cubeOf i x \u2227 s (cubeOf i x) = i := by\n  apply epsilon_spec (p := fun I \u21a6 x \u2208 I \u2227 s I = i)\n  by_cases hiS : i = S\n  \u00b7 use topCube, subset_topCube hx, hiS \u25b8 s_topCube\n  simpa [and_comm] using Set.mem_iUnion\u2082.mp <| Grid_subset_biUnion i\n    \u27e8hi.1, s_topCube (X := X) \u25b8 lt_of_le_of_ne hi.2 hiS\u27e9 (subset_topCube hx)\n\n/-- The definition `T_\ud835\udcdd^\u03b8 f(x)`, given in (7.1.3).\nFor convenience, the suprema are written a bit differently than in the blueprint\n(avoiding `cubeOf`), but this should be equivalent.\nThis is `0` if `x` doesn't lie in a cube. -/\ndef nontangentialMaximalFunction (\u03b8 : \u0398 X) (f : X \u2192 \u2102) (x : X) : \u211d\u22650\u221e :=\n  \u2a06 (I : Grid X) (_ : x \u2208 I) (x' \u2208 I) (s\u2082 \u2208 Icc (s I) S)\n  (_ : ENNReal.ofReal (D ^ (s\u2082 - 1)) \u2264 upperRadius Q \u03b8 x'),\n  \u2016\u2211 i \u2208 Icc (s I) s\u2082, \u222b y, Ks i x' y * f y\u2016\u208a\n\nprotected theorem MeasureTheory.Measurable.nontangentialMaximalFunction {\u03b8 : \u0398 X} {f : X \u2192 \u2102} :\n    Measurable (nontangentialMaximalFunction \u03b8 f) := by\n  refine Measurable.iSup (fun I \u21a6 ?_)\n  let c := \u2a06 x' \u2208 I, \u2a06 s\u2082 \u2208 Icc (s I) S, \u2a06 (_ : ENNReal.ofReal (D ^ (s\u2082 - 1)) \u2264 upperRadius Q \u03b8 x'),\n    (\u2016\u2211 i \u2208 (Icc (s I) s\u2082), \u222b (y : X), Ks i x' y * f y\u2016\u208a : ENNReal)\n  have : (fun x \u21a6 \u2a06 (_ : x \u2208 I), c) = fun x \u21a6 ite (x \u2208 I) c 0 := by\n    ext x; by_cases hx : x \u2208 I <;> simp [hx]\n  convert (measurable_const.ite coeGrid_measurable measurable_const) using 1\n\n-- Set used in definition of `boundaryOperator`\nvariable (t) (u) in private def \ud835\udcd9' (x : X) (i : \u2124) : Finset (Grid X) :=\n  { J | J \u2208 \ud835\udcd9 (t u) \u2227 (J : Set X) \u2286 ball x (16 * D ^ i) \u2227 s J \u2264 i }\n\nprivate lemma mem_\ud835\udcd9_of_mem_\ud835\udcd9' {x : X} {i : \u2124} {J : Grid X} : J \u2208 \ud835\udcd9' t u x i \u2192 J \u2208 \ud835\udcd9 (t u) := by\n  intro hJ\n  simp only [\ud835\udcd9', Finset.mem_filter] at hJ\n  exact hJ.2.1\n\nvariable (t) in\n/-- The operator `S_{1,\ud835\udd32} f(x)`, given in (7.1.4). -/\ndef boundaryOperator (u : \ud835\udd13 X) (f : X \u2192 \u2102) (x : X) : \u211d\u22650\u221e :=\n  \u2211 I : Grid X, (I : Set X).indicator (x := x) fun _ \u21a6 \u2211 J \u2208 \ud835\udcd9' t u (c I) (s I),\n  D ^ ((s J - s I) / (a : \u211d)) / volume (ball (c I) (16 * D ^ (s I))) * \u222b\u207b y in (J : Set X), \u2016f y\u2016\u208a\n\nprotected theorem MeasureTheory.Measurable.boundaryOperator {u : \ud835\udd13 X} {f : X \u2192 \u2102} :\n    Measurable (t.boundaryOperator u f) := by\n  refine Finset.measurable_sum _ (fun I _ \u21a6 ?_)\n  exact (Finset.measurable_sum _ (fun J _ \u21a6 measurable_const)).indicator coeGrid_measurable\n\n-- Currently unused; uncomment if needed.\n/- lemma boundaryOperator_lt_top (hf : BoundedCompactSupport f) : t.boundaryOperator u f x < \u22a4 := by\n  refine ENNReal.sum_lt_top.mpr (fun I _ \u21a6 ?_)\n  by_cases hx : x \u2208 (I : Set X)\n  \u00b7 rw [indicator_of_mem hx]\n    refine ENNReal.sum_lt_top.mpr (fun J hJ \u21a6 ENNReal.mul_lt_top ?_ hf.integrable.integrableOn.2)\n    apply ENNReal.div_lt_top (by simp)\n    exact ne_of_gt <| measure_ball_pos volume _ <| mul_pos (by norm_num) (defaultD_pow_pos a (s I))\n  \u00b7 simp [hx] -/\n\n/-- The indexing set for the collection of balls \ud835\udcd1, defined above Lemma 7.1.3. -/\ndef \ud835\udcd1 : Set (\u2115 \u00d7 Grid X) := Icc 0 (S + 5) \u00d7\u02e2 univ\n\n/-- The center function for the collection of balls \ud835\udcd1. -/\ndef c\ud835\udcd1 (z : \u2115 \u00d7 Grid X) : X := c z.2\n\n/-- The radius function for the collection of balls \ud835\udcd1. -/\ndef r\ud835\udcd1 (z : \u2115 \u00d7 Grid X) : \u211d := 2 ^ z.1 * D ^ s z.2\n\nlemma \ud835\udcd1_finite : (\ud835\udcd1 (X := X)).Finite :=\n  finite_Icc .. |>.prod finite_univ\n\n/-- Lemma 7.1.1, freely translated. -/\nlemma convex_scales (hu : u \u2208 t) : OrdConnected (t.\u03c3 u x : Set \u2124) := by\n  rw [ordConnected_def]; intro i mi j mj k mk\n  simp_rw [Finset.mem_coe, \u03c3, Finset.mem_image, Finset.mem_filter, Finset.mem_univ,\n    true_and] at mi mj \u22a2\n  obtain \u27e8p, \u27e8mp, xp, Qxp, sxp\u27e9, sp\u27e9 := mi\n  obtain \u27e8p'', \u27e8mp'', xp'', Qxp'', sxp''\u27e9, sp''\u27e9 := mj\n  have ilj : i \u2264 j := nonempty_Icc.mp \u27e8k, mk\u27e9\n  rw [\u2190 sp, \u2190 sp''] at ilj mk\n  obtain \u27e8K, sK, lK, Kl\u27e9 := Grid.exists_sandwiched (le_of_mem_of_mem ilj xp xp'') k mk\n  have := range_subset_iff.mp (biUnion_\u03a9 (i := K)) x\n  simp_rw [mem_preimage, mem_singleton_iff, mem_iUnion, exists_prop] at this\n  obtain \u27e8(p' : \ud835\udd13 X), (\ud835\udcd8p' : \ud835\udcd8 p' = K), Qxp'\u27e9 := this\n  rw [\u2190 \ud835\udcd8p'] at lK Kl sK; refine \u27e8p', ?_, sK\u27e9\n  have l\u2081 : p \u2264 p' := \u27e8lK,\n    (relative_fundamental_dyadic lK).resolve_left (not_disjoint_iff.mpr \u27e8_, Qxp, Qxp'\u27e9)\u27e9\n  have l\u2082 : p' \u2264 p'' := \u27e8Kl,\n    (relative_fundamental_dyadic Kl).resolve_left (not_disjoint_iff.mpr \u27e8_, Qxp', Qxp''\u27e9)\u27e9\n  refine \u27e8(t.ordConnected hu).out mp mp'' \u27e8l\u2081, l\u2082\u27e9, \u27e8(Grid.le_def.mp lK).1 xp, Qxp', ?_\u27e9\u27e9\n  exact Icc_subset_Icc sxp.1 sxp''.2 \u27e8(Grid.le_def.mp lK).2, (Grid.le_def.mp Kl).2\u27e9\n\n/-- Part of Lemma 7.1.2 -/\n@[simp]\nlemma biUnion_\ud835\udcd9 : \u22c3 J \u2208 \ud835\udcd9 \ud835\udd16, J = \u22c3 I : Grid X, (I : Set X) := by\n  refine subset_antisymm (iUnion\u2082_subset_iUnion ..) fun x mx \u21a6 ?_\n  simp_rw [mem_iUnion] at mx \u22a2; obtain \u27e8I, mI\u27e9 := mx\n  obtain \u27e8J, sJ, mJ\u27e9 :=\n    Grid.exists_containing_subcube _ \u27e8le_rfl, scale_mem_Icc.1\u27e9 mI\n  have : J \u2208 (\ud835\udcd9\u2080 \ud835\udd16).toFinset := by rw [mem_toFinset]; left; exact sJ\n  obtain \u27e8M, lM, maxM\u27e9 := (\ud835\udcd9\u2080 \ud835\udd16).toFinset.exists_le_maximal this\n  simp_rw [mem_toFinset] at maxM\n  use M, maxM, (Grid.le_def.mp lM).1 mJ\n\n/-- Part of Lemma 7.1.2 -/\n@[simp]\nlemma biUnion_\ud835\udcdb : \u22c3 J \u2208 \ud835\udcdb \ud835\udd16, J = \u22c3 I : Grid X, (I : Set X) := by\n  refine subset_antisymm (iUnion\u2082_subset_iUnion ..) fun x mx \u21a6 ?_\n  simp_rw [mem_iUnion] at mx \u22a2; obtain \u27e8I, mI\u27e9 := mx\n  obtain \u27e8J, sJ, mJ\u27e9 :=\n    Grid.exists_containing_subcube _ \u27e8le_rfl, scale_mem_Icc.1\u27e9 mI\n  have : J \u2208 (\ud835\udcdb\u2080 \ud835\udd16).toFinset := by rw [mem_toFinset]; left; exact sJ\n  obtain \u27e8M, lM, maxM\u27e9 := (\ud835\udcdb\u2080 \ud835\udd16).toFinset.exists_le_maximal this\n  simp_rw [mem_toFinset] at maxM\n  use M, maxM, (Grid.le_def.mp lM).1 mJ\n\n/-- Part of Lemma 7.1.2 -/\nlemma pairwiseDisjoint_\ud835\udcdb : (\ud835\udcdb \ud835\udd16).PairwiseDisjoint (fun I \u21a6 (I : Set X)) := fun I mI J mJ hn \u21a6 by\n  have : IsAntichain (\u00b7 \u2264 \u00b7) (\ud835\udcdb \ud835\udd16) := setOf_maximal_antichain _\n  exact (le_or_ge_or_disjoint.resolve_left (this mI mJ hn)).resolve_left (this mJ mI hn.symm)\n\n/-- The constant used in `first_tree_pointwise`.\nHas value `10 * 2 ^ (104 * a ^ 3)` in the blueprint. -/\n-- Todo: define this recursively in terms of previous constants\nirreducible_def C7_1_4 (a : \u2115) : \u211d\u22650 := 10 * 2 ^ (104 * (a : \u211d) ^ 3)\n\n-- Used in the proof of `exp_sub_one_le`, which is used to prove Lemma 7.1.4\nprivate lemma exp_Lipschitz : LipschitzWith 1 (fun (t : \u211d) \u21a6 exp (.I * t)) := by\n  have mul_I : Differentiable \u211d fun (t : \u211d) \u21a6 I * t := Complex.ofRealCLM.differentiable.const_mul I\n  refine lipschitzWith_of_nnnorm_deriv_le mul_I.cexp (fun x \u21a6 ?_)\n  have : (fun (t : \u211d) \u21a6 cexp (I * t)) = cexp \u2218 (fun (t : \u211d) \u21a6 I * t) := rfl\n  rw [this, deriv_comp x differentiableAt_exp (mul_I x), Complex.deriv_exp, deriv_const_mul_field']\n  simp_rw [show deriv ofReal x = 1 from ofRealCLM.hasDerivAt.deriv, mul_one]\n  rw [nnnorm_mul, nnnorm_I, mul_one, \u2190 norm_toNNReal, mul_comm, Complex.norm_exp_ofReal_mul_I]\n  exact Real.toNNReal_one.le\n\n-- Used in the proof of Lemma 7.1.4\nprivate lemma exp_sub_one_le (t : \u211d) : \u2016exp (.I * t) - 1\u2016 \u2264 \u2016t\u2016 := by\n  simpa [enorm_eq_nnnorm] using exp_Lipschitz t 0\n\n-- Used in the proofs of Lemmas 7.1.4 and 7.1.5\nprivate lemma dist_lt_5 (hu : u \u2208 t) (mp : p \u2208 t.\ud835\udd17 u) (Qxp : Q x \u2208 \u03a9 p) :\n    dist_(p) (\ud835\udcac u) (Q x) < 5 := calc\n  _ \u2264 dist_(p) (\ud835\udcac u) (\ud835\udcac p) + dist_(p) (Q x) (\ud835\udcac p) := dist_triangle_right ..\n  _ < 4 + 1 :=\n    add_lt_add ((t.smul_four_le hu mp).2 (by convert mem_ball_self zero_lt_one)) (subset_cball Qxp)\n  _ = 5 := by norm_num\n\n-- The bound in the third display in the proof of Lemma 7.1.4\nprivate lemma L7_1_4_bound (hu : u \u2208 t) {s : \u2124} (hs : s \u2208 t.\u03c3 u x) {y : X} (hKxy : Ks s x y \u2260 0) :\n    \u2016exp (.I * (-\ud835\udcac u y + Q x y + \ud835\udcac u x - Q x x)) - 1\u2016 \u2264\n    5 * 2 ^ (4 * a) * 2 ^ (s - \u03c3Max t u x \u27e8s, hs\u27e9) :=\n  have \u27e8p\u209b, pu, xp\u209b, hp\u209b\u27e9 := t.exists_p_of_mem_\u03c3 u x hs\n  have \u27e8p', p'u, xp', hp'\u27e9 := t.exists_p_of_mem_\u03c3 u x (t.\u03c3Max_mem_\u03c3 u x \u27e8s, hs\u27e9)\n  have hr : (D : \u211d) ^ s / 2 > 0 := by rw [defaultD]; positivity\n  have s_le : GridStructure.s (\ud835\udcd8 p\u209b) \u2264 GridStructure.s (\ud835\udcd8 p') := by convert (\u03c3 t u x).le_max' s hs\n  have exp_bound :\n      \u2016exp (.I * (- \ud835\udcac u y + Q x y + \ud835\udcac u x - Q x x)) - 1\u2016 \u2264 \u2016\ud835\udcac u y - Q x y - \ud835\udcac u x + Q x x\u2016 := by\n    convert exp_sub_one_le (- \ud835\udcac u y + Q x y + \ud835\udcac u x - Q x x) using 1\n    \u00b7 simp\n    \u00b7 rw [\u2190 norm_neg]; ring_nf\n  have : dist_(p\u209b) (\ud835\udcac u) (Q x) \u2264 2 ^ (s - \u03c3Max t u x \u27e8s, hs\u27e9) * dist_(p') (\ud835\udcac u) (Q x) := by\n    have p\u209b_le_p' : \ud835\udcd8 p\u209b \u2264 \ud835\udcd8 p' := le_of_mem_of_mem s_le xp\u209b.1 xp'.1\n    have sub_ge_0 : t.\u03c3Max u x \u27e8s, hs\u27e9 - s \u2265 0 := by unfold \u03c3Max; linarith [(\u03c3 t u x).le_max' s hs]\n    have : GridStructure.s (\ud835\udcd8 p\u209b) + (\u03c3Max t u x \u27e8s, hs\u27e9 - s) = GridStructure.s (\ud835\udcd8 p') := by\n      simp_rw [\u2190 hp', \u2190 hp\u209b, \ud835\udd30, _root_.s]; ring\n    apply le_trans <| Grid.dist_strictMono_iterate' sub_ge_0 p\u209b_le_p' this\n    gcongr\n    calc  C2_1_2 a ^ (t.\u03c3Max u x \u27e8s, hs\u27e9 - s)\n      _ \u2264 C2_1_2 a ^ (t.\u03c3Max u x \u27e8s, hs\u27e9 - s : \u211d)                     := by norm_cast\n      _ \u2264 (1 / 2 : \u211d) ^ (t.\u03c3Max u x \u27e8s, hs\u27e9 - s : \u211d)                  :=\n        Real.rpow_le_rpow (by rw [C2_1_2]; positivity)\n          ((C2_1_2_le_inv_512 X).trans (by norm_num)) (by norm_cast)\n      _ = 2 ^ (s - \u03c3Max t u x \u27e8s, hs\u27e9)                                := by simp [\u2190 Int.cast_sub]\n  calc \u2016exp (.I * (-\ud835\udcac u y + Q x y + \ud835\udcac u x - Q x x)) - 1\u2016\n    _ \u2264 dist_{x, D ^ s / 2} (\ud835\udcac u) (Q x) :=\n      exp_bound.trans <| oscillation_le_cdist x _ (\ud835\udcac u) (Q x)\n        (mem_ball_comm.mp (mem_Ioo.mp (dist_mem_Ioo_of_Ks_ne_zero hKxy)).2) (mem_ball_self hr)\n    _ \u2264 _ := cdist_mono <| ball_subset_ball (show (D : \u211d) ^ s / 2 \u2264 4 * D ^ s by linarith)\n    _ \u2264 defaultA a * dist_{\ud835\udd20 p\u209b, 2 * D ^ s} (\ud835\udcac u) (Q x) := by\n      have two_mul_two : 2 * (2 * (D : \u211d) ^ s) = 4 * D ^ s := by ring\n      have x_in_ball : dist (\ud835\udd20 p\u209b) x < 2 * (2 * D ^ s) := by\n        rw [two_mul_two, \u2190 hp\u209b]\n        exact mem_ball'.mp <| Grid_subset_ball xp\u209b.1\n      refine le_of_eq_of_le ?_ (cdist_le x_in_ball)\n      rw [two_mul_two]\n    _ \u2264 defaultA a * (defaultA a ^ 3 * dist_(p\u209b) (\ud835\udcac u) (Q x)) := by\n      gcongr\n      convert cdist_le_iterate (div_pos (defaultD_pow_pos a s) four_pos) _ _ _ using 2\n      \u00b7 rw [show 2 ^ 3 * ((D : \u211d) ^ s / 4) = 2 * D ^ s by ring]\n      \u00b7 rw [hp\u209b]\n    _ = (defaultA a) ^ 4 * dist_(p\u209b) (\ud835\udcac u) (Q x) := by ring\n    _ \u2264 (2 ^ a) ^ 4 * (2 ^ (s - t.\u03c3Max u x _) * dist_(p') (\ud835\udcac u) (Q x)) := by norm_cast; gcongr\n    _ \u2264 (2 ^ a) ^ 4 * (2 ^ (s - t.\u03c3Max u x _) * 5) := by gcongr; exact (dist_lt_5 hu p'u xp'.2.1).le\n    _ = 5 * 2 ^ (4 * a) * 2 ^ (s - \u03c3Max t u x \u27e8s, hs\u27e9) := by ring\n\n-- The bound used implicitly in the fourth displayed inequality in the proof of Lemma 7.1.4\nvariable (f) in\n", "theoremStatement": "private lemma L7_1_4_integrand_bound (hu : u \u2208 t) {s : \u2124} (hs : s \u2208 t.\u03c3 u x) (y : X) :\n    \u2016(exp (.I * (- \ud835\udcac u y + Q x y + \ud835\udcac u x - Q x x)) - 1) * Ks s x y * f y\u2016 \u2264\n    5 * 2^(s - \u03c3Max t u x \u27e8s, hs\u27e9) * (2^(103 * a ^ 3) / volume.real (ball x (D ^ s))) * \u2016f y\u2016 ", "theoremName": "TileStructure.Forest.L7_1_4_integrand_bound", "fileCreated": {"commit": "5e49c3692f6d7344434caa7eea5f412f0ee35863", "date": "2024-09-27"}, "theoremCreated": {"commit": "3298f748e9eb26a242da5ee38cb50dc55e604935", "date": "2025-01-08"}, "file": "carleson/Carleson/ForestOperator/PointwiseEstimate.lean", "module": "Carleson.ForestOperator.PointwiseEstimate", "jsonFile": "Carleson.ForestOperator.PointwiseEstimate.jsonl", "positionMetadata": {"lineInFile": 371, "tokenPositionInFile": 19016, "theoremPositionInFile": 44}, "dependencyMetadata": {"inFilePremises": null, "numInFilePremises": null, "repositoryPremises": null, "numRepositoryPremises": null, "numPremises": null}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  by_cases hKxy : Ks s x y = 0\n  \u00b7 rw [hKxy, mul_zero, zero_mul, norm_zero]; positivity\n  \u00b7 rw [norm_mul, norm_mul]\n    refine mul_le_mul_of_nonneg_right ?_ (norm_nonneg (f y))\n    apply mul_le_mul (L7_1_4_bound hu hs hKxy) norm_Ks_le (norm_nonneg _) (by positivity) |>.trans\n    rw [mul_assoc 5, mul_comm (2 ^ (4 * a)), \u2190 mul_assoc, mul_assoc, mul_div, C2_1_3]\n    gcongr\n    norm_cast\n    rw_mod_cast [\u2190 pow_add]\n    refine Nat.pow_le_pow_of_le_right two_pos <| Nat.add_le_of_le_sub ?_ ?_\n    \u00b7 exact Nat.mul_le_mul_right _ (by norm_num)\n    \u00b7 rw [\u2190 Nat.sub_mul, (show a ^ 3 = a ^ 2 * a from rfl)]; nlinarith [four_le_a X]", "proofType": "tactic", "proofLengthLines": 12, "proofLengthTokens": 630}}
{"srcContext": "import Carleson.Forest\nimport Carleson.ToMathlib.HardyLittlewood\nimport Carleson.ToMathlib.BoundedCompactSupport\nimport Carleson.ToMathlib.Misc\nimport Carleson.Psi\n\nopen ShortVariables TileStructure\nvariable {X : Type*} {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102} {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X}\n  [MetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] [TileStructure Q D \u03ba S o]\n  {n j j' : \u2115} {t : Forest X n} {u u\u2081 u\u2082 p : \ud835\udd13 X} {x x' : X} {\ud835\udd16 : Set (\ud835\udd13 X)}\n  {f f\u2081 f\u2082 g g\u2081 g\u2082 : X \u2192 \u2102} {I J J' L : Grid X}\nvariable {E' : Type*} [NormedAddCommGroup E'] [NormedSpace \u211d E']\n\nnoncomputable section\n\nopen Set MeasureTheory Metric Function Complex Bornology TileStructure Classical Filter\nopen scoped NNReal ENNReal ComplexConjugate\n\nnamespace TileStructure.Forest\n\n/-! ## Section 7.1 and Lemma 7.1.3 -/\n\nvariable (t) in\n/-- The definition `\u03c3(u, x)` given in Section 7.1.\nWe may assume `u \u2208 t` whenever proving things about this definition. -/\ndef \u03c3 (u : \ud835\udd13 X) (x : X) : Finset \u2124 := .image \ud835\udd30 { p | p \u2208 t u \u2227 x \u2208 E p }\n\nvariable (t) in\nprivate lemma exists_p_of_mem_\u03c3 (u : \ud835\udd13 X) (x : X) {s : \u2124} (hs : s \u2208 t.\u03c3 u x) :\n    \u2203 p \u2208 t.\ud835\udd17 u, x \u2208 E p \u2227 \ud835\udd30 p = s := by\n  have \u27e8p, hp\u27e9 := Finset.mem_image.mp hs\n  simp only [mem_\ud835\udd17, Finset.mem_filter] at hp\n  use p, hp.1.2.1, hp.1.2.2, hp.2\n\n/- \\overline{\u03c3} from the blueprint. -/\nvariable (t) in\ndef \u03c3Max (u : \ud835\udd13 X) (x : X) (h\u03c3 : (t.\u03c3 u x).Nonempty) : \u2124 :=\n  t.\u03c3 u x |>.max' h\u03c3\n\n/- \\underline{\u03c3} from the blueprint. -/\nvariable (t) in\ndef \u03c3Min (u : \ud835\udd13 X) (x : X) (h\u03c3 : (t.\u03c3 u x).Nonempty) : \u2124 :=\n  t.\u03c3 u x |>.min' h\u03c3\n\nvariable (t) in\nprivate lemma \u03c3Max_mem_\u03c3 (u : \ud835\udd13 X) (x : X) (h\u03c3 : (t.\u03c3 u x).Nonempty) : \u03c3Max t u x h\u03c3 \u2208 t.\u03c3 u x :=\n  (t.\u03c3 u x).max'_mem h\u03c3\n\n/-- The definition of `\ud835\udcd9\u2080(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcd9\u2080 (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {J : Grid X | s J = -S \u2228 \u2200 p \u2208 \ud835\udd16, \u00ac(\ud835\udcd8 p : Set X) \u2286 ball (c J) (100 * D ^ (s J + 1))}\n\n/-- The definition of `\ud835\udcd9(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcd9 (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {x | Maximal (\u00b7 \u2208 \ud835\udcd9\u2080 \ud835\udd16) x}\n\nlemma \ud835\udcd9_subset_\ud835\udcd9\u2080 {\ud835\udd16 : Set (\ud835\udd13 X)} : \ud835\udcd9 \ud835\udd16 \u2286 \ud835\udcd9\u2080 \ud835\udd16 := sep_subset ..\n\nlemma pairwiseDisjoint_\ud835\udcd9 : (\ud835\udcd9 \ud835\udd16).PairwiseDisjoint (fun I \u21a6 (I : Set X)) := fun I mI J mJ hn \u21a6 by\n  have : IsAntichain (\u00b7 \u2264 \u00b7) (\ud835\udcd9 \ud835\udd16) := setOf_maximal_antichain _\n  exact (le_or_ge_or_disjoint.resolve_left (this mI mJ hn)).resolve_left (this mJ mI hn.symm)\n\n/-- The definition of `\ud835\udcdb\u2080(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcdb\u2080 (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {L : Grid X | s L = -S \u2228 (\u2203 p \u2208 \ud835\udd16, L \u2264 \ud835\udcd8 p) \u2227 \u2200 p \u2208 \ud835\udd16, \u00ac\ud835\udcd8 p \u2264 L}\n\n/-- The definition of `\ud835\udcdb(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcdb (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {x | Maximal (\u00b7 \u2208 \ud835\udcdb\u2080 \ud835\udd16) x}\n\nlemma \ud835\udcdb_subset_\ud835\udcdb\u2080 {\ud835\udd16 : Set (\ud835\udd13 X)} : \ud835\udcdb \ud835\udd16 \u2286 \ud835\udcdb\u2080 \ud835\udd16 := sep_subset ..\n\nprivate lemma s_le_s_of_mem_\ud835\udcdb {\ud835\udd16 : Set (\ud835\udd13 X)} {L : Grid X} (hL : L \u2208 \ud835\udcdb \ud835\udd16)\n    {p : \ud835\udd13 X} (hp : p \u2208 \ud835\udd16) (hpL : \u00ac Disjoint (\ud835\udcd8 p : Set X) (L : Set X)) : s L \u2264 s (\ud835\udcd8 p) := by\n  simp only [\ud835\udcdb, \ud835\udcdb\u2080, Grid.le_def, not_and, not_le, and_imp] at hL\n  rcases hL.1 with h | h\n  \u00b7 exact h \u25b8 (range_s_subset \u27e8\ud835\udcd8 p, rfl\u27e9).1\n  \u00b7 by_contra!\n    exact lt_asymm this <| h.2 p hp <| (GridStructure.fundamental_dyadic' this.le).resolve_right hpL\n\nprivate lemma subset_of_mem_\ud835\udcdb {\ud835\udd16 : Set (\ud835\udd13 X)} {L : Grid X} (hL : L \u2208 \ud835\udcdb \ud835\udd16) {p : \ud835\udd13 X}\n    (hp : p \u2208 \ud835\udd16) (hpL : \u00ac Disjoint (\ud835\udcd8 p : Set X) (L : Set X)) : (L : Set X) \u2286 (\ud835\udcd8 p : Set X) :=\n  GridStructure.fundamental_dyadic' (s_le_s_of_mem_\ud835\udcdb hL hp hpL) |>.resolve_right fun h \u21a6 hpL h.symm\n\n/-- The projection operator `P_\ud835\udcd2 f(x)`, given above Lemma 7.1.3.\nIn lemmas the `c` will be pairwise disjoint on `C`. -/\ndef approxOnCube (C : Set (Grid X)) (f : X \u2192 E') (x : X) : E' :=\n  \u2211 J \u2208 { p | p \u2208 C }, (J : Set X).indicator (fun _ \u21a6 \u2a0d y in J, f y) x\n\nlemma stronglyMeasurable_approxOnCube (C : Set (Grid X)) (f : X \u2192 E') :\n    StronglyMeasurable (approxOnCube (X := X) (K := K) C f) :=\n  Finset.stronglyMeasurable_sum _ (fun _ _ \u21a6 stronglyMeasurable_const.indicator coeGrid_measurable)\n\nlemma integrable_approxOnCube (C : Set (Grid X)) {f : X \u2192 E'} : Integrable (approxOnCube C f) := by\n  refine integrable_finset_sum _ (fun i hi \u21a6 ?_)\n  constructor\n  \u00b7 exact (aestronglyMeasurable_indicator_iff coeGrid_measurable).mpr aestronglyMeasurable_const\n  \u00b7 simp_rw [hasFiniteIntegral_iff_enorm, enorm_indicator_eq_indicator_enorm]\n    apply lt_of_le_of_lt <| lintegral_indicator_const_le (i : Set X) _\n    exact ENNReal.mul_lt_top ENNReal.coe_lt_top volume_coeGrid_lt_top\n\nlemma approxOnCube_nonneg {C : Set (Grid X)} {f : X \u2192 \u211d} (hf : \u2200 (y : X), f y \u2265 0) {x : X} :\n    approxOnCube C f x \u2265 0 :=\n  Finset.sum_nonneg' (fun _ \u21a6 Set.indicator_nonneg (fun _ _ \u21a6 integral_nonneg hf) _)\n\n", "theoremStatement": "lemma approxOnCube_apply {C : Set (Grid X)} (hC : C.PairwiseDisjoint (fun I \u21a6 (I : Set X)))\n    (f : X \u2192 E') {x : X} {J : Grid X} (hJ : J \u2208 C) (xJ : x \u2208 J) :\n    (approxOnCube C f) x = \u2a0d y in J, f y ", "theoremName": "TileStructure.Forest.approxOnCube_apply", "fileCreated": {"commit": "5e49c3692f6d7344434caa7eea5f412f0ee35863", "date": "2024-09-27"}, "theoremCreated": {"commit": "3298f748e9eb26a242da5ee38cb50dc55e604935", "date": "2025-01-08"}, "file": "carleson/Carleson/ForestOperator/PointwiseEstimate.lean", "module": "Carleson.ForestOperator.PointwiseEstimate", "jsonFile": "Carleson.ForestOperator.PointwiseEstimate.jsonl", "positionMetadata": {"lineInFile": 106, "tokenPositionInFile": 4535, "theoremPositionInFile": 18}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 27, "numPremises": 156}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [approxOnCube, \u2190 Finset.sum_filter_not_add_sum_filter _ (J = \u00b7)]\n  have eq0 : \u2211 i \u2208 Finset.filter (\u00ac J = \u00b7) (Finset.univ.filter (\u00b7 \u2208 C)),\n      (i : Set X).indicator (fun _ \u21a6 \u2a0d y in i, f y) x = 0 := by\n    suffices \u2200 i \u2208 (Finset.univ.filter (\u00b7 \u2208 C)).filter (\u00ac J = \u00b7),\n      (i : Set X).indicator (fun _ \u21a6 \u2a0d y in i, f y) x = 0 by simp [Finset.sum_congr rfl this]\n    intro i hi\n    simp only [Finset.mem_filter, Finset.mem_univ, true_and] at hi\n    apply indicator_of_not_mem <|\n      Set.disjoint_left.mp ((hC.eq_or_disjoint hJ hi.1).resolve_left hi.2) xJ\n  have eq_ave : \u2211 i \u2208 (Finset.univ.filter (\u00b7 \u2208 C)).filter (J = \u00b7),\n      (i : Set X).indicator (fun _ \u21a6 \u2a0d y in i, f y) x = \u2a0d y in J, f y := by\n    suffices (Finset.univ.filter (\u00b7 \u2208 C)).filter (J = \u00b7) = {J} by simp [this, xJ, \u2190 Grid.mem_def]\n    exact subset_antisymm (fun _ h \u21a6 Finset.mem_singleton.mpr (Finset.mem_filter.mp h).2.symm)\n      (fun _ h \u21a6 by simp [Finset.mem_singleton.mp h, hJ])\n  rw [eq0, eq_ave, zero_add]", "proofType": "tactic", "proofLengthLines": 15, "proofLengthTokens": 989}}
{"srcContext": "import Carleson.Discrete.Defs\nimport Carleson.ForestOperator.Forests\nimport Carleson.Discrete.SumEstimates\n\nopen MeasureTheory Measure NNReal Metric Complex Set\nopen scoped ENNReal\nopen Classical -- We use quite some `Finset.filter`\nnoncomputable section\n\nopen scoped ShortVariables\nvariable {X : Type*} {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102} {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X}\n  [MetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] [TileStructure Q D \u03ba S o]\n\nvariable {k n j l : \u2115} {p p' u u' : \ud835\udd13 X} {x : X}\n\n/-! ## Section 5.3 -/\n\n/-! Note: the lemmas 5.3.1-5.3.3 are in `TileStructure`. -/\n\n/-- Lemma 5.3.4 -/\nlemma ordConnected_tilesAt : OrdConnected (TilesAt k : Set (\ud835\udd13 X)) := by\n  rw [ordConnected_def]; intro p mp p'' mp'' p' mp'\n  simp_rw [TilesAt, mem_preimage, \ud835\udcd2, mem_diff, aux\ud835\udcd2, mem_setOf] at mp mp'' \u22a2\n  constructor\n  \u00b7 obtain \u27e8J, hJ, _\u27e9 := mp''.1\n    use J, mp'.2.1.trans hJ\n  \u00b7 push_neg at mp \u22a2\n    exact fun J hJ \u21a6 mp.2 J (mp'.1.1.trans hJ)\n\n/-- Lemma 5.3.5 -/\nlemma ordConnected_C : OrdConnected (\u212d k n : Set (\ud835\udd13 X)) := by\n  rw [ordConnected_def]; intro p mp p'' mp'' p' mp'\n  rw [\u212d, mem_setOf] at mp mp'' \u22a2\n  have z := mem_of_mem_of_subset mp' (ordConnected_tilesAt.out mp.1 mp''.1)\n  refine \u27e8z, ?_\u27e9\n  have hk : \u2200 q' \u2208 TilesAt (X := X) k, \u2200 q \u2264 q', dens' k {q'} \u2264 dens' k {q} := fun q' _ q hq \u21a6 by\n    simp_rw [dens', mem_singleton_iff, iSup_iSup_eq_left]; gcongr with l hl a _\n    exact iSup_const_mono fun h \u21a6\n      wiggle_order_11_10 hq (C5_3_3_le (X := X).trans (by norm_num) |>.trans hl) |>.trans h\n  exact \u27e8mp''.2.1.trans_le (hk _ mp''.1 _ mp'.2), (hk _ z _ mp'.1).trans mp.2.2\u27e9\n\n/-- Lemma 5.3.6 -/\nlemma ordConnected_C1 : OrdConnected (\u212d\u2081 k n j : Set (\ud835\udd13 X)) := by\n  rw [ordConnected_def]; intro p mp p'' mp'' p' mp'\n  have mp'\u2081 : p' \u2208 \u212d (X := X) k n := mem_of_mem_of_subset mp'\n    (ordConnected_C.out (mem_of_mem_of_subset mp \u212d\u2081_subset_\u212d)\n      (mem_of_mem_of_subset mp'' \u212d\u2081_subset_\u212d))\n  simp_rw [\u212d\u2081, mem_diff, pre\u212d\u2081, mem_setOf, not_and, not_le] at mp mp'' \u22a2\n  simp_rw [mp.1.1, true_and, true_implies] at mp\n  simp_rw [mp'\u2081, true_and, true_implies]\n  simp_rw [mp''.1.1, true_and, true_implies] at mp''\n  constructor\n  \u00b7 refine mp''.1.trans (Finset.card_le_card fun b mb \u21a6 ?_)\n    simp_rw [Finset.mem_filter, Finset.mem_univ, true_and, \ud835\udd05, mem_setOf] at mb \u22a2\n    have h100 := wiggle_order_11_10 (n := 100) mp'.2 (C5_3_3_le (X := X).trans (by norm_num))\n    exact \u27e8mb.1, h100.trans mb.2\u27e9\n  \u00b7 refine (Finset.card_le_card fun b mb \u21a6 ?_).trans_lt mp.2\n    simp_rw [Finset.mem_filter, Finset.mem_univ, true_and, \ud835\udd05, mem_setOf] at mb \u22a2\n    have h100 := wiggle_order_11_10 (n := 100) mp'.1 (C5_3_3_le (X := X).trans (by norm_num))\n    exact \u27e8mb.1, h100.trans mb.2\u27e9\n\n/-- Lemma 5.3.7 -/\nlemma ordConnected_C2 : OrdConnected (\u212d\u2082 k n j : Set (\ud835\udd13 X)) := by\n  rw [ordConnected_def]; intro p mp p'' mp'' p' mp'\n  have mp\u2081 := mem_of_mem_of_subset mp \u212d\u2082_subset_\u212d\u2081\n  have mp'\u2081 : p' \u2208 \u212d\u2081 (X := X) k n j := mem_of_mem_of_subset mp'\n    (ordConnected_C1.out mp\u2081 (mem_of_mem_of_subset mp'' \u212d\u2082_subset_\u212d\u2081))\n  by_cases e : p = p'; \u00b7 rwa [e] at mp\n  simp_rw [\u212d\u2082, layersAbove, mem_diff, mp'\u2081, true_and]\n  by_contra h; rw [mem_iUnion\u2082] at h; obtain \u27e8l', bl', p'm\u27e9 := h\n  rw [minLayer, mem_setOf, minimal_iff] at p'm\n  have pnm : p \u2209 \u22c3 l'', \u22c3 (_ : l'' < l'), \ud835\udd0f\u2081 k n j l'' := by\n    replace mp := mp.2; contrapose! mp\n    exact mem_of_mem_of_subset mp\n      (iUnion_mono'' fun i \u21a6 iUnion_subset_iUnion_const fun hi \u21a6 (hi.trans_le bl').le)\n  exact absurd (p'm.2 \u27e8mp.1, pnm\u27e9 mp'.1).symm e\n\n/-- Lemma 5.3.8 -/\nlemma ordConnected_C3 : OrdConnected (\u212d\u2083 k n j : Set (\ud835\udd13 X)) := by\n  rw [ordConnected_def]; intro p mp p'' mp'' p' mp'\n  have mp\u2081 := mem_of_mem_of_subset mp \u212d\u2083_subset_\u212d\u2082\n  have mp''\u2081 := mem_of_mem_of_subset mp'' \u212d\u2083_subset_\u212d\u2082\n  have mp'\u2081 : p' \u2208 \u212d\u2082 (X := X) k n j := mem_of_mem_of_subset mp' (ordConnected_C2.out mp\u2081 mp''\u2081)\n  rw [\u212d\u2083_def] at mp'' \u22a2\n  obtain \u27e8-, u, mu, \ud835\udcd8nu, su\u27e9 := mp''; refine \u27e8mp'\u2081, \u27e8u, mu, ?_\u27e9\u27e9\n  exact \u27e8(mp'.2.1.trans_lt (lt_of_le_of_ne su.1 \ud835\udcd8nu)).ne,\n    (wiggle_order_11_10 mp'.2 (C5_3_3_le (X := X).trans (by norm_num))).trans su\u27e9\n\n/-- Lemma 5.3.9 -/\nlemma ordConnected_C4 : OrdConnected (\u212d\u2084 k n j : Set (\ud835\udd13 X)) := by\n  rw [ordConnected_def]; intro p mp p'' mp'' p' mp'\n  have mp''\u2081 := mem_of_mem_of_subset mp'' \u212d\u2084_subset_\u212d\u2083\n  have mp'\u2081 : p' \u2208 \u212d\u2083 (X := X) k n j := mem_of_mem_of_subset mp'\n    (ordConnected_C3.out (mem_of_mem_of_subset mp \u212d\u2084_subset_\u212d\u2083) mp''\u2081)\n  by_cases e : p' = p''; \u00b7 rwa [\u2190 e] at mp''\n  simp_rw [\u212d\u2084, layersBelow, mem_diff, mp'\u2081, true_and]\n  by_contra h; simp_rw [mem_iUnion] at h; obtain \u27e8l', hl', p'm\u27e9 := h\n  rw [maxLayer_def, mem_setOf, maximal_iff] at p'm\n  simp_rw [mem_diff] at p'm\n  have p''nm : p'' \u2209 \u22c3 l'', \u22c3 (_ : l'' < l'), \ud835\udd0f\u2083 k n j l'' := by\n    replace mp'' := mp''.2; contrapose! mp''\n    refine mem_of_mem_of_subset mp'' <| iUnion\u2082_mono' fun i hi \u21a6 \u27e8i, hi.le.trans hl', subset_rfl\u27e9\n  exact absurd (p'm.2 \u27e8mp''\u2081, p''nm\u27e9 mp'.2) e\n\n/-- Lemma 5.3.10 -/\nlemma ordConnected_C5 : OrdConnected (\u212d\u2085 k n j : Set (\ud835\udd13 X)) := by\n  rw [ordConnected_def]; intro p mp p'' mp'' p' mp'\n  have mp\u2081 := mem_of_mem_of_subset mp \u212d\u2085_subset_\u212d\u2084\n  have mp'\u2081 : p' \u2208 \u212d\u2084 (X := X) k n j := mem_of_mem_of_subset mp'\n    (ordConnected_C4.out mp\u2081 (mem_of_mem_of_subset mp'' \u212d\u2085_subset_\u212d\u2084))\n  simp_rw [\u212d\u2085, mem_diff, mp\u2081, mp'\u2081, true_and, \ud835\udd0f\u2084, mem_setOf,\n    mp\u2081, mp'\u2081, true_and] at mp \u22a2\n  contrapose! mp; obtain \u27e8u, mu, s\ud835\udcd8u\u27e9 := mp; use u, mu, mp'.1.1.1.trans s\ud835\udcd8u\n\n/-! ## Section 5.4 and Lemma 5.1.2 -/\n\n/-- The subset `\u212d\u2086(k, n, j)` of `\u212d\u2085(k, n, j)`, given above (5.4.1). -/\ndef \u212d\u2086 (k n j : \u2115) : Set (\ud835\udd13 X) :=\n  { p \u2208 \u212d\u2085 k n j | \u00ac (\ud835\udcd8 p : Set X) \u2286 G' }\n\nlemma \u212d\u2086_subset_\u212d\u2085 : \u212d\u2086 (X := X) k n j \u2286 \u212d\u2085 k n j := sep_subset ..\nlemma \u212d\u2086_subset_\u212d : \u212d\u2086 (X := X) k n j \u2286 \u212d k n := \u212d\u2086_subset_\u212d\u2085.trans \u212d\u2085_subset_\u212d\n\n/-- The subset `\ud835\udd17\u2081(u)` of `\u212d\u2081(k, n, j)`, given in (5.4.1).\nIn lemmas, we will assume `u \u2208 \ud835\udd18\u2081 k n l` -/\ndef \ud835\udd17\u2081 (k n j : \u2115) (u : \ud835\udd13 X) : Set (\ud835\udd13 X) :=\n  { p \u2208 \u212d\u2081 k n j | \ud835\udcd8 p \u2260 \ud835\udcd8 u \u2227 smul 2 p \u2264 smul 1 u }\n\nlemma \ud835\udcd8_lt_of_mem_\ud835\udd17\u2081 (h : p \u2208 \ud835\udd17\u2081 k n j p') : \ud835\udcd8 p < \ud835\udcd8 p' := by\n  rw [\ud835\udd17\u2081, mem_setOf] at h; exact lt_of_le_of_ne h.2.2.1 h.2.1\n\n/-- The subset `\ud835\udd18\u2082(k, n, j)` of `\ud835\udd18\u2081(k, n, j)`, given in (5.4.2). -/\ndef \ud835\udd18\u2082 (k n j : \u2115) : Set (\ud835\udd13 X) :=\n  { u \u2208 \ud835\udd18\u2081 k n j | \u00ac Disjoint (\ud835\udd17\u2081 k n j u) (\u212d\u2086 k n j) }\n\nlemma \ud835\udd18\u2082_subset_\ud835\udd18\u2081 : \ud835\udd18\u2082 k n j \u2286 \ud835\udd18\u2081 (X := X) k n j := fun _ mu \u21a6 mu.1\n\n/-- The relation `\u223c` defined below (5.4.2). It is an equivalence relation on `\ud835\udd18\u2082 k n j`. -/\ndef URel (k n j : \u2115) (u u' : \ud835\udd13 X) : Prop :=\n  u = u' \u2228 \u2203 p \u2208 \ud835\udd17\u2081 k n j u, smul 10 p \u2264 smul 1 u'\n\nnonrec lemma URel.rfl : URel k n j u u := Or.inl rfl\n\n/-- Lemma 5.4.1, part 2. -/\nlemma URel.not_disjoint (hu : u \u2208 \ud835\udd18\u2082 k n j) (hu' : u' \u2208 \ud835\udd18\u2082 k n j) (huu' : URel k n j u u') :\n    \u00acDisjoint (ball_(u) (\ud835\udcac u) 100) (ball_(u') (\ud835\udcac u') 100) := by\n  by_cases e : u = u'; \u00b7 rw [e]; simp\n  simp_rw [URel, e, false_or, \ud835\udd17\u2081, mem_setOf] at huu'; obtain \u27e8p, \u27e8mp, np, sl\u2081\u27e9, sl\u2082\u27e9 := huu'\n  by_cases e' : \ud835\udcd8 p = \ud835\udcd8 u'\n  \u00b7 refine not_disjoint_iff.mpr \u27e8\ud835\udcac u, mem_ball_self (by positivity), ?_\u27e9\n    rw [@mem_ball]\n    have i1 : ball_{\ud835\udcd8 u} (\ud835\udcac u) 1 \u2286 ball_{\ud835\udcd8 p} (\ud835\udcac p) 2 := sl\u2081.2\n    have i2 : ball_{\ud835\udcd8 u'} (\ud835\udcac u') 1 \u2286 ball_{\ud835\udcd8 p} (\ud835\udcac p) 10 := sl\u2082.2\n    replace i1 : \ud835\udcac u \u2208 ball_{\ud835\udcd8 p} (\ud835\udcac p) 2 := i1 (mem_ball_self zero_lt_one)\n    replace i2 : \ud835\udcac u' \u2208 ball_{\ud835\udcd8 p} (\ud835\udcac p) 10 := i2 (mem_ball_self zero_lt_one)\n    rw [e', @mem_ball] at i1 i2\n    calc\n      _ \u2264 dist_{\ud835\udcd8 u'} (\ud835\udcac u) (\ud835\udcac p) + dist_{\ud835\udcd8 u'} (\ud835\udcac u') (\ud835\udcac p) := dist_triangle_right ..\n      _ < 2 + 10 := add_lt_add i1 i2\n      _ < 100 := by norm_num\n  have plu : smul 100 p \u2264 smul 100 u := wiggle_order_100 (smul_mono sl\u2081 le_rfl (by norm_num)) np\n  have plu' : smul 100 p \u2264 smul 100 u' := wiggle_order_100 sl\u2082 e'\n  by_contra h\n  have \ud835\udd05dj : Disjoint (\ud835\udd05 k n u) (\ud835\udd05 k n u') := by\n    simp_rw [\ud835\udd05, disjoint_left, mem_setOf, not_and]; intro q \u27e8_, sl\u27e9 _\n    simp_rw [TileLike.le_def, smul_fst, smul_snd, not_and_or] at sl \u22a2; right\n    have := disjoint_left.mp (h.mono_left sl.2) (mem_ball_self zero_lt_one)\n    rw [not_subset]; use \ud835\udcac q, mem_ball_self zero_lt_one\n  have usp : \ud835\udd05 k n u \u2286 \ud835\udd05 k n p := fun q mq \u21a6 by\n    rw [\ud835\udd05, mem_setOf] at mq \u22a2; exact \u27e8mq.1, plu.trans mq.2\u27e9\n  have u'sp : \ud835\udd05 k n u' \u2286 \ud835\udd05 k n p := fun q mq \u21a6 by\n    rw [\ud835\udd05, mem_setOf] at mq \u22a2; exact \u27e8mq.1, plu'.trans mq.2\u27e9\n  rw [\ud835\udd18\u2082, mem_setOf, \ud835\udd18\u2081, mem_setOf] at hu hu'\n  apply absurd (card_\ud835\udd05_of_mem_\u212d\u2081 mp).2; rw [not_lt]\n  calc\n    _ = 2 ^ j + 2 ^ j := Nat.two_pow_succ j\n    _ \u2264 (\ud835\udd05 k n u).toFinset.card + (\ud835\udd05 k n u').toFinset.card :=\n      add_le_add (card_\ud835\udd05_of_mem_\u212d\u2081 hu.1.1).1 (card_\ud835\udd05_of_mem_\u212d\u2081 hu'.1.1).1\n    _ = (\ud835\udd05 k n u \u222a \ud835\udd05 k n u').toFinset.card := by\n      rw [toFinset_union]; refine (Finset.card_union_of_disjoint ?_).symm\n      simpa using \ud835\udd05dj\n    _ \u2264 _ := by\n      apply Finset.card_le_card\n      simp_rw [toFinset_union, subset_toFinset, Finset.coe_union, coe_toFinset, union_subset_iff]\n      exact \u27e8usp, u'sp\u27e9\n\n/-- Lemma 5.4.1, part 1. -/\nlemma URel.eq (hu : u \u2208 \ud835\udd18\u2082 k n j) (hu' : u' \u2208 \ud835\udd18\u2082 k n j) (huu' : URel k n j u u') : \ud835\udcd8 u = \ud835\udcd8 u' := by\n  by_cases e : u = u'; \u00b7 rw [e]\n  have ndj := not_disjoint hu hu' huu'\n  have n\u2081 := (hu.1.2 _ hu'.1.1).mt ndj\n  rw [disjoint_comm] at ndj\n  have n\u2082 := (hu'.1.2 _ hu.1.1).mt ndj\n  simp_rw [URel, e, false_or, \ud835\udd17\u2081, mem_setOf] at huu'; obtain \u27e8p, \u27e8_, _, sl\u2081\u27e9, sl\u2082\u27e9 := huu'\n  rcases le_or_lt (\ud835\udd30 u) (\ud835\udd30 u') with h | h\n  \u00b7 exact eq_of_le_of_not_lt (Grid.le_dyadic h sl\u2081.1 sl\u2082.1) n\u2081\n  \u00b7 exact (eq_of_le_of_not_lt (Grid.le_dyadic h.le sl\u2082.1 sl\u2081.1) n\u2082).symm\n\n/-- Helper for 5.4.2 that is also used in 5.4.9. -/\nlemma urel_of_not_disjoint {x y : \ud835\udd13 X} (my : y \u2208 \ud835\udd18\u2082 k n j) (xye : \ud835\udcd8 x = \ud835\udcd8 y)\n    (nd : \u00acDisjoint (ball_(x) (\ud835\udcac x) 100) (ball_(y) (\ud835\udcac y) 100)) : URel k n j y x := by\n  rw [not_disjoint_iff] at nd\n  obtain \u27e8(\u03d1 : \u0398 X), (\u03d1x : \u03d1 \u2208 ball_{\ud835\udcd8 x} (\ud835\udcac x) 100), (\u03d1y : \u03d1 \u2208 ball_{\ud835\udcd8 y} (\ud835\udcac y) 100)\u27e9 := nd\n  rw [\ud835\udd18\u2082, mem_setOf, not_disjoint_iff] at my; obtain \u27e8p, hp, _\u27e9 := my.2\n  suffices w : ball_(x) (\ud835\udcac x) 1 \u2286 ball_(y) (\ud835\udcac y) 500 by\n    right; use p, hp; obtain \u27e8_, np, sl\u27e9 := hp\n    have hpy : smul 10 p \u2264 smul 500 y :=\n      (smul_mono_left (by norm_num)).trans (wiggle_order_500 sl np)\n    exact \u27e8(xye \u25b8 sl.1 : \ud835\udcd8 p \u2264 \ud835\udcd8 x), hpy.2.trans w\u27e9\n  intro (q : \u0398 X) (mq : q \u2208 ball_{\ud835\udcd8 x} (\ud835\udcac x) 1)\n  rw [@mem_ball] at mq \u22a2\n  calc\n    _ \u2264 dist_(y) q \u03d1 + dist_(y) \u03d1 (\ud835\udcac y) := dist_triangle ..\n    _ \u2264 dist_(y) q (\ud835\udcac x) + dist_(y) \u03d1 (\ud835\udcac x) + dist_(y) \u03d1 (\ud835\udcac y) := by\n      gcongr; apply dist_triangle_right\n    _ < 1 + 100 + 100 := by\n      gcongr\n      \u00b7 rwa [xye] at mq\n      \u00b7 rwa [@mem_ball, xye] at \u03d1x\n      \u00b7 rwa [@mem_ball] at \u03d1y\n    _ < _ := by norm_num\n\n/-- Lemma 5.4.2. -/\nlemma equivalenceOn_urel : EquivalenceOn (URel (X := X) k n j) (\ud835\udd18\u2082 k n j) where\n  refl _ _ := .rfl\n  trans {x y z} mx my mz xy yz := by\n    by_cases xny : x = y; \u00b7 rwa [xny]\n    have xye := URel.eq mx my xy\n    have hxy := URel.not_disjoint mx my xy\n    rw [not_disjoint_iff] at hxy\n    obtain \u27e8(\u03d1 : \u0398 X), (\u03d1x : \u03d1 \u2208 ball_{\ud835\udcd8 x} (\ud835\udcac x) 100), (\u03d1y : \u03d1 \u2208 ball_{\ud835\udcd8 y} (\ud835\udcac y) 100)\u27e9 := hxy\n    have yze := URel.eq my mz yz\n    have hyz := URel.not_disjoint my mz yz\n    rw [not_disjoint_iff] at hyz\n    obtain \u27e8(\u03b8 : \u0398 X), (\u03b8y : \u03b8 \u2208 ball_{\ud835\udcd8 y} (\ud835\udcac y) 100), (\u03b8z : \u03b8 \u2208 ball_{\ud835\udcd8 z} (\ud835\udcac z) 100)\u27e9 := hyz\n    simp_rw [URel, xny, false_or] at xy; obtain \u27e8p, mp, sp\u27e9 := xy\n    suffices ball_(z) (\ud835\udcac z) 1 \u2286 ball_(x) (\ud835\udcac x) 500 by\n      right; use p, mp; obtain \u27e8_, np, sl\u27e9 := mp\n      have w : ball_(x) (\ud835\udcac x) 500 \u2286 ball_(p) (\ud835\udcac p) 4 := (wiggle_order_500 sl np).2\n      exact \u27e8(yze \u25b8 xye \u25b8 sl.1 : \ud835\udcd8 p \u2264 \ud835\udcd8 z), (this.trans w).trans (ball_subset_ball (by norm_num))\u27e9\n    intro (q : \u0398 X) (mq : q \u2208 ball_{\ud835\udcd8 z} (\ud835\udcac z) 1)\n    rw [@mem_ball] at mq \u22a2\n    calc\n      _ \u2264 dist_(x) q \u03d1 + dist_(x) \u03d1 (\ud835\udcac x) := dist_triangle ..\n      _ < dist_(x) q \u03d1 + 100 := by gcongr; rwa [@mem_ball] at \u03d1x\n      _ \u2264 dist_(x) q (\ud835\udcac y) + dist_(x) \u03d1 (\ud835\udcac y) + 100 := by gcongr; exact dist_triangle_right ..\n      _ < dist_(x) q (\ud835\udcac y) + 100 + 100 := by gcongr; rwa [@mem_ball, \u2190 xye] at \u03d1y\n      _ \u2264 dist_(x) q \u03b8 + dist_(x) \u03b8 (\ud835\udcac y) + 100 + 100 := by gcongr; exact dist_triangle ..\n      _ < dist_(x) q \u03b8 + 100 + 100 + 100 := by gcongr; rwa [@mem_ball, \u2190 xye] at \u03b8y\n      _ \u2264 dist_(x) q (\ud835\udcac z) + dist_(x) \u03b8 (\ud835\udcac z) + 100 + 100 + 100 := by\n        gcongr; exact dist_triangle_right ..\n      _ < 1 + 100 + 100 + 100 + 100 := by\n        gcongr\n        \u00b7 rwa [\u2190 yze, \u2190 xye] at mq\n        \u00b7 rwa [@mem_ball, \u2190 yze, \u2190 xye] at \u03b8z\n      _ < _ := by norm_num\n  symm {x y} mx my xy := urel_of_not_disjoint my (URel.eq mx my xy) (URel.not_disjoint mx my xy)\n\n/-- `\ud835\udd18\u2083(k, n, j) \u2286 \ud835\udd18\u2082 k n j` is an arbitary set of representatives of `URel` on `\ud835\udd18\u2082 k n j`,\ngiven above (5.4.5). -/\ndef \ud835\udd18\u2083 (k n j : \u2115) : Set (\ud835\udd13 X) :=\n  (equivalenceOn_urel (k := k) (n := n) (j := j)).reprs\n\nlemma \ud835\udd18\u2083_subset_\ud835\udd18\u2082 : \ud835\udd18\u2083 k n j \u2286 \ud835\udd18\u2082 (X := X) k n j := EquivalenceOn.reprs_subset\n\n/-- The subset `\ud835\udd17\u2082(u)` of `\u212d\u2086(k, n, j)`, given in (5.4.5).\nIn lemmas, we will assume `u \u2208 \ud835\udd18\u2083 k n l` -/\ndef \ud835\udd17\u2082 (k n j : \u2115) (u : \ud835\udd13 X) : Set (\ud835\udd13 X) :=\n  \u212d\u2086 k n j \u2229 \u22c3 (u' \u2208 \ud835\udd18\u2082 k n j) (_ : URel k n j u u'), \ud835\udd17\u2081 k n j u'\n\nlemma \ud835\udd17\u2082_subset_\u212d\u2086 : \ud835\udd17\u2082 k n j u \u2286 \u212d\u2086 k n j := inter_subset_left ..\n\n/-- Lemma 5.4.3 -/\nlemma C6_forest : \u212d\u2086 (X := X) k n j = \u22c3 u \u2208 \ud835\udd18\u2083 k n j, \ud835\udd17\u2082 k n j u := by\n  ext p; constructor <;> intro h\n  \u00b7 have hp : p \u2208 \u212d\u2083 k n j := (\u212d\u2086_subset_\u212d\u2085 |>.trans \u212d\u2085_subset_\u212d\u2084 |>.trans \u212d\u2084_subset_\u212d\u2083) h\n    rw [\u212d\u2083, mem_diff, \ud835\udd0f\u2082, mem_setOf] at hp\n    have mp := hp.1\n    simp_rw [hp.1, true_and, not_not] at hp\n    obtain \u27e8u, mu, np, sl\u27e9 := hp\n    have mp' : p \u2208 \ud835\udd17\u2081 k n j u := by\n      rw [\ud835\udd17\u2081, mem_setOf]; exact \u27e8\u212d\u2082_subset_\u212d\u2081 mp, np, sl\u27e9\n    have mu' : u \u2208 \ud835\udd18\u2082 k n j := by\n      rw [\ud835\udd18\u2082, mem_setOf]; exact \u27e8mu, not_disjoint_iff.mpr \u27e8_, mp', h\u27e9\u27e9\n    let rr := equivalenceOn_urel (X := X) (k := k) (n := n) (j := j)\n    rw [mem_iUnion\u2082]; use rr.out u, (rr.out_mem_reprs mu')\n    refine \u27e8h, ?_\u27e9; rw [mem_iUnion\u2082]; use u, mu'; rw [mem_iUnion]; use rr.out_rel mu'\n  \u00b7 rw [mem_iUnion\u2082] at h; obtain \u27e8_, _, mp, _\u27e9 := h; exact mp\n\n/-- This one could deserve a lemma in the blueprint, as it is needed to decompose the sum\nof Carleson operators over disjoint subfamilies. -/\nlemma forest_disjoint : (\ud835\udd18\u2083 k n j).PairwiseDisjoint (fun u \u21a6 \ud835\udd17\u2082 (X := X) k n j u) := by\n  intro u hu u' hu' huu'\n  simp only [Function.onFun]\n  apply disjoint_left.2 (fun p pu pu' \u21a6 huu' ?_)\n  simp only [\ud835\udd17\u2082, mem_inter_iff, mem_iUnion, exists_prop, exists_and_left] at pu pu'\n  rcases pu.2 with \u27e8v, v_mem, v_rel, pv\u27e9\n  rcases pu'.2 with \u27e8v', v'_mem, v'_rel, pv'\u27e9\n  have E : URel k n j v v' :=\n    Or.inr \u27e8p, pv, smul_mono pv'.2.2 le_rfl (by norm_num)\u27e9\n  have : URel k n j u v' :=\n    (equivalenceOn_urel (X := X)).trans (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 hu) v_mem v'_mem v_rel E\n  have : URel k n j u u' := by\n    apply (equivalenceOn_urel (X := X)).trans (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 hu) v'_mem (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 hu') this\n    exact (equivalenceOn_urel (X := X)).symm (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 hu') v'_mem v'_rel\n  exact (equivalenceOn_urel (X := X)).reprs_inj hu hu' this\n\n/-- Lemma 5.4.4, verifying (2.0.32) -/\nlemma forest_geometry (hu : u \u2208 \ud835\udd18\u2083 k n j) (hp : p \u2208 \ud835\udd17\u2082 k n j u) : smul 4 p \u2264 smul 1 u := by\n  rw [\ud835\udd17\u2082, mem_inter_iff, mem_iUnion\u2082] at hp\n  obtain \u27e8_, u', mu', w\u27e9 := hp; rw [mem_iUnion] at w; obtain \u27e8ru, mp'\u27e9 := w\n  rw [\ud835\udd17\u2081, mem_setOf] at mp'; obtain \u27e8_, np, sl\u27e9 := mp'\n  have xye := URel.eq (EquivalenceOn.reprs_subset hu) mu' ru\n  have huu' := URel.not_disjoint (EquivalenceOn.reprs_subset hu) mu' ru\n  rw [not_disjoint_iff] at huu'\n  obtain \u27e8(\u03d1 : \u0398 X), (\u03d1x : \u03d1 \u2208 ball_{\ud835\udcd8 u} (\ud835\udcac u) 100), (\u03d1y : \u03d1 \u2208 ball_{\ud835\udcd8 u'} (\ud835\udcac u') 100)\u27e9 := huu'\n  suffices ball_(u) (\ud835\udcac u) 1 \u2286 ball_(u') (\ud835\udcac u') 500 by\n    have w : smul 4 p \u2264 smul 500 u' := (wiggle_order_500 sl np)\n    exact \u27e8(xye \u25b8 sl.1 : \ud835\udcd8 p \u2264 \ud835\udcd8 u), w.2.trans this\u27e9\n  intro (q : \u0398 X) (mq : q \u2208 ball_{\ud835\udcd8 u} (\ud835\udcac u) 1)\n  rw [@mem_ball] at mq \u22a2\n  calc\n    _ \u2264 dist_(u') q \u03d1 + dist_(u') \u03d1 (\ud835\udcac u') := dist_triangle ..\n    _ \u2264 dist_(u') q (\ud835\udcac u) + dist_(u') \u03d1 (\ud835\udcac u) + dist_(u') \u03d1 (\ud835\udcac u') := by\n      gcongr; apply dist_triangle_right\n    _ < 1 + 100 + 100 := by\n      gcongr\n      \u00b7 rwa [xye] at mq\n      \u00b7 rwa [@mem_ball, xye] at \u03d1x\n      \u00b7 rwa [@mem_ball] at \u03d1y\n    _ < _ := by norm_num\n\n/-- Lemma 5.4.5, verifying (2.0.33) -/\nlemma forest_convex : OrdConnected (\ud835\udd17\u2082 k n j u) := by\n  rw [ordConnected_def]; intro p mp p'' mp'' p' mp'\n  have mp'\u2085 : p' \u2208 \u212d\u2085 (X := X) k n j :=\n    (ordConnected_C5.out ((\ud835\udd17\u2082_subset_\u212d\u2086.trans \u212d\u2086_subset_\u212d\u2085) mp)\n      ((\ud835\udd17\u2082_subset_\u212d\u2086.trans \u212d\u2086_subset_\u212d\u2085) mp'')) mp'\n  have mp'\u2086 : p' \u2208 \u212d\u2086 k n j := by\n    have hp := \ud835\udd17\u2082_subset_\u212d\u2086 mp; rw [\u212d\u2086, mem_setOf] at hp \u22a2\n    refine \u27e8mp'\u2085, ?_\u27e9; have hpG := hp.2; contrapose! hpG\n    exact mp'.1.1.1.trans hpG\n  simp_rw [\ud835\udd17\u2082, mem_inter_iff, mp'\u2086, true_and, mem_iUnion\u2082, mem_iUnion] at mp'' \u22a2\n  obtain \u27e8u', mu', ru, _, np'', sl\u27e9 := mp''.2\n  have pnu : \ud835\udcd8 p' < \ud835\udcd8 u' := (mp'.2.1).trans_lt (lt_of_le_of_ne sl.1 np'')\n  use u', mu', ru; rw [\ud835\udd17\u2081, mem_setOf]\n  use (\u212d\u2085_subset_\u212d\u2084 |>.trans \u212d\u2084_subset_\u212d\u2083 |>.trans \u212d\u2083_subset_\u212d\u2082 |>.trans \u212d\u2082_subset_\u212d\u2081) mp'\u2085, pnu.ne\n  exact (wiggle_order_11_10 mp'.2 (C5_3_3_le (X := X).trans (by norm_num))).trans sl\n\n/-- Lemma 5.4.6, verifying (2.0.36)\nNote: swapped `u` and `u'` to match (2.0.36) -/\nlemma forest_separation (hu : u \u2208 \ud835\udd18\u2083 k n j) (hu' : u' \u2208 \ud835\udd18\u2083 k n j) (huu' : u \u2260 u')\n    (hp : p \u2208 \ud835\udd17\u2082 k n j u') (h : \ud835\udcd8 p \u2264 \ud835\udcd8 u) : 2 ^ (Z * (n + 1)) < dist_(p) (\ud835\udcac p) (\ud835\udcac u) := by\n  simp_rw [\ud835\udd17\u2082, mem_inter_iff, mem_iUnion\u2082, mem_iUnion] at hp\n  obtain \u27e8mp\u2086, v, mv, rv, \u27e8-, np, sl\u27e9\u27e9 := hp\n  obtain \u27e8p', mp', lp', sp'\u27e9 := exists_scale_add_le_of_mem_layersAbove <|\n    (\u212d\u2086_subset_\u212d\u2085 |>.trans \u212d\u2085_subset_\u212d\u2084 |>.trans \u212d\u2084_subset_\u212d\u2083 |>.trans \u212d\u2083_subset_\u212d\u2082) mp\u2086\n  have np'u : \u00acURel k n j v u := by\n    by_contra h; apply absurd (Eq.symm _) huu'\n    replace h := equivalenceOn_urel.trans (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 hu') mv (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 hu) rv h\n    exact EquivalenceOn.reprs_inj hu' hu h\n  have vnu : v \u2260 u := by by_contra h; subst h; exact absurd URel.rfl np'u\n  simp_rw [URel, vnu, false_or, not_exists, not_and] at np'u\n  have mpt : p' \u2208 \ud835\udd17\u2081 k n j v := by\n    refine \u27e8minLayer_subset mp', ?_, ?_\u27e9\n    \u00b7 exact (lp'.1.trans_lt (lt_of_le_of_ne sl.1 np)).ne\n    \u00b7 exact (wiggle_order_11_10 lp' (C5_3_3_le (X := X).trans (by norm_num))).trans sl\n  specialize np'u p' mpt\n  have \ud835\udcd8p'u : \ud835\udcd8 p' \u2264 \ud835\udcd8 u := lp'.1.trans h\n  simp_rw [TileLike.le_def, smul_fst, smul_snd, \ud835\udcd8p'u, true_and,\n    not_subset_iff_exists_mem_not_mem] at np'u\n  obtain \u27e8(q : \u0398 X), mq, nq\u27e9 := np'u\n  simp_rw [mem_ball, not_lt] at mq nq\n  have d8 : 8 < dist_(p') (\ud835\udcac p) (\ud835\udcac u) :=\n    calc\n      _ = 10 - 1 - 1 := by norm_num\n      _ < 10 - 1 - dist_(u) q (\ud835\udcac u) := by gcongr\n      _ \u2264 10 - 1 - dist_(p') q (\ud835\udcac u) := tsub_le_tsub_left (Grid.dist_mono \ud835\udcd8p'u) _\n      _ \u2264 dist_(p') q (\ud835\udcac p') - 1 - dist_(p') q (\ud835\udcac u) := by gcongr\n      _ < dist_(p') q (\ud835\udcac p') - dist_(p') (\ud835\udcac p) (\ud835\udcac p') - dist_(p') q (\ud835\udcac u) := by\n        gcongr; rw [\u2190 @mem_ball]; exact subset_cball (lp'.2 \ud835\udcac_mem_\u03a9)\n      _ \u2264 _ := by\n        rw [sub_le_iff_le_add', sub_le_iff_le_add]\n        nth_rw 3 [dist_comm]; apply dist_triangle4\n  have Znpos : 0 < Z * (n + 1) := by rw [defaultZ]; positivity\n  let d : \u2115 := (\ud835\udd30 p - \ud835\udd30 p').toNat\n  have sd : \ud835\udd30 p' + d = \ud835\udd30 p := by simp_rw [d]; rw [Int.toNat_sub_of_le] <;> omega\n  have d1 : dist_(p') (\ud835\udcac p) (\ud835\udcac u) \u2264 C2_1_2 a ^ d * dist_(p) (\ud835\udcac p) (\ud835\udcac u) :=\n    Grid.dist_strictMono_iterate lp'.1 sd\n  have Cdpos : 0 < C2_1_2 a ^ d := by rw [C2_1_2]; positivity\n  have Cidpos : 0 < (C2_1_2 a)\u207b\u00b9 ^ d := by rw [C2_1_2]; positivity\n  calc\n    _ \u2264 (C2_1_2 a)\u207b\u00b9 ^ (Z * (n + 1)) := by\n      refine pow_le_pow_left\u2080 zero_le_two ?_ _\n      nth_rw 1 [C2_1_2, \u2190 Real.inv_rpow zero_le_two, \u2190 Real.rpow_neg_one,\n        \u2190 Real.rpow_mul zero_le_two, neg_one_mul, neg_mul, neg_neg, \u2190 Real.rpow_one 2]\n      apply Real.rpow_le_rpow_of_exponent_le one_le_two\n      norm_cast; linarith [four_le_a X]\n    _ \u2264 (C2_1_2 a)\u207b\u00b9 ^ d := by\n      refine pow_le_pow_right\u2080 ?_ (by omega)\n      simp_rw [one_le_inv_iff\u2080, C2_1_2_le_one (X := X), and_true, C2_1_2]; positivity\n    _ \u2264 (C2_1_2 a)\u207b\u00b9 ^ d * 8 := by nth_rw 1 [\u2190 mul_one (_ ^ d)]; gcongr; norm_num\n    _ < (C2_1_2 a)\u207b\u00b9 ^ d * dist_(p') (\ud835\udcac p) (\ud835\udcac u) := by gcongr\n    _ \u2264 _ := by\n      rwa [\u2190 mul_le_mul_iff_of_pos_left Cdpos, inv_pow, \u2190 mul_assoc, mul_inv_cancel\u2080 Cdpos.ne',\n        one_mul]\n\n/-- Lemma 5.4.7, verifying (2.0.37) -/\nlemma forest_inner (hu : u \u2208 \ud835\udd18\u2083 k n j) (hp : p \u2208 \ud835\udd17\u2082 k n j u) :\n    ball (\ud835\udd20 p) (8 * D ^ \ud835\udd30 p) \u2286 \ud835\udcd8 u := by\n  have p\u2084 := (\ud835\udd17\u2082_subset_\u212d\u2086.trans \u212d\u2086_subset_\u212d\u2085 |>.trans \u212d\u2085_subset_\u212d\u2084) hp\n  have p\u2081 := (\u212d\u2084_subset_\u212d\u2083.trans \u212d\u2083_subset_\u212d\u2082 |>.trans \u212d\u2082_subset_\u212d\u2081) p\u2084\n  obtain \u27e8q, mq, lq, sq\u27e9 := exists_le_add_scale_of_mem_layersBelow p\u2084\n  obtain \u27e8-, u'', mu'', nu'', sl\u27e9 := \u212d\u2083_def.mp (maxLayer_subset mq)\n  replace nu'' : \ud835\udcd8 q < \ud835\udcd8 u'' := lt_of_le_of_ne sl.1 nu''\n  have s2 : smul 2 p \u2264 smul 2 q := wiggle_order_11_10 lq (C5_3_3_le (X := X).trans (by norm_num))\n  have s2' : smul 2 p \u2264 smul 1 u'' := s2.trans sl\n  have s10 : smul 10 p \u2264 smul 1 u'' := smul_mono s2' le_rfl (by norm_num)\n  simp_rw [\ud835\udd17\u2082, mem_inter_iff, mem_iUnion\u2082, mem_iUnion] at hp\n  obtain \u27e8p\u2086, u', mu', ru', pu'\u27e9 := hp\n  have ur : URel k n j u' u'' := Or.inr \u27e8p, pu', s10\u27e9\n  have hu'' : u'' \u2208 \ud835\udd18\u2082 k n j := by\n    rw [\ud835\udd18\u2082, mem_setOf, not_disjoint_iff]\n    refine \u27e8mu'', \u27e8p, ?_, p\u2086\u27e9\u27e9\n    simpa [\ud835\udd17\u2081, p\u2081, s2'] using (lq.1.trans_lt nu'').ne\n  have ru'' : URel k n j u u'' := equivalenceOn_urel.trans (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 hu) mu' hu'' ru' ur\n  have qlu : \ud835\udcd8 q < \ud835\udcd8 u := URel.eq (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 hu) hu'' ru'' \u25b8 nu''\n  have squ : \ud835\udd30 q < \ud835\udd30 u := (Grid.lt_def.mp qlu).2\n  have spu : \ud835\udd30 p \u2264 \ud835\udd30 u - (Z * (n + 1) : \u2115) - 1 := by omega\n  have \u27e8I, sI, plI, Ilu\u27e9 : \u2203 I, s I = \ud835\udd30 u - (Z * (n + 1) : \u2115) - 1 \u2227 \ud835\udcd8 p \u2264 I \u2227 I \u2264 \ud835\udcd8 u := by\n    apply Grid.exists_sandwiched (lq.1.trans qlu.le) (\ud835\udd30 u - (Z * (n + 1) : \u2115) - 1)\n    refine \u27e8spu, ?_\u27e9\n    change _ \u2264 \ud835\udd30 u\n    omega\n  have bI : I \u2209 \ud835\udcdb n u := by\n    have p\u2085 := \u212d\u2086_subset_\u212d\u2085 p\u2086\n    rw [\u212d\u2085_def] at p\u2085; replace p\u2085 := p\u2085.2; contrapose! p\u2085\n    use u, (\ud835\udd18\u2083_subset_\ud835\udd18\u2082.trans \ud835\udd18\u2082_subset_\ud835\udd18\u2081) hu, plI.1.trans (subset_biUnion_of_mem p\u2085)\n  rw [\ud835\udcdb, mem_setOf, not_and] at bI; specialize bI Ilu\n  rw [not_and, not_not] at bI; specialize bI (by omega); rw [\u2190 sI] at spu\n  rcases spu.eq_or_lt with h | h\n  \u00b7 have hI : \ud835\udcd8 p = I := by\n      apply eq_of_le_of_not_lt plI; rw [Grid.lt_def, not_and_or, not_lt]; exact Or.inr h.symm.le\n    rwa [\u2190 hI] at bI\n  \u00b7 apply subset_trans (ball_subset_ball' _) bI\n    have ds : c (\ud835\udcd8 p) \u2208 ball (c I) (4 * D ^ s I) := (plI.1.trans Grid_subset_ball) Grid.c_mem_Grid\n    rw [mem_ball] at ds\n    calc\n      _ \u2264 4 * D * (D : \u211d) ^ \ud835\udd30 p + 4 * D ^ s I := by\n        gcongr\n        \u00b7 linarith [four_le_realD X]\n        \u00b7 exact ds.le\n      _ = 4 * D ^ (\ud835\udd30 p + 1) + 4 * D ^ s I := by\n        rw [mul_assoc]; congr; rw [mul_comm, \u2190 zpow_add_one\u2080 (defaultD_pos _).ne']\n      _ \u2264 4 * D ^ s I + 4 * D ^ s I := by\n        gcongr\n        \u00b7 exact one_le_D\n        \u00b7 omega\n      _ = _ := by ring\n\n/-- The multiplicity appearing in Lemma 5.4.8. -/\ndef C5_4_8 (n : \u2115) : \u2115 := (4 * n + 12) * 2 ^ n\n\nlemma exists_smul_le_of_\ud835\udd18\u2083 (u : \ud835\udd18\u2083 k n j) : \u2203 m : \ud835\udd10 (X := X) k n, smul 100 u.1 \u2264 smul 1 m.1 := by\n  obtain \u27e8u, mu\u27e9 := u\n  replace mu := (\ud835\udd18\u2083_subset_\ud835\udd18\u2082.trans \ud835\udd18\u2082_subset_\ud835\udd18\u2081 |>.trans \ud835\udd18\u2081_subset_\u212d\u2081) mu\n  rw [\u212d\u2081, mem_diff, pre\u212d\u2081, mem_setOf, filter_mem_univ_eq_toFinset] at mu\n  replace mu := (show 0 < 2 ^ j by positivity).trans_le mu.1.2\n  rw [Finset.card_pos] at mu; obtain \u27e8m, hm\u27e9 := mu\n  rw [mem_toFinset, \ud835\udd05] at hm; exact \u27e8\u27e8m, hm.1\u27e9, hm.2\u27e9\n\nvariable (k n j) in\n/-- The good choice of an element to get a contradiction in the proof of Lemma 5.4.8. -/\ndef mf (u : \ud835\udd18\u2083 (X := X) k n j) : \ud835\udd10 (X := X) k n := (exists_smul_le_of_\ud835\udd18\u2083 u).choose\n\nlemma mf_injOn : InjOn (mf k n j) {u | x \u2208 \ud835\udcd8 u.1} := fun u mu u' mu' e \u21a6 by\n  set m := mf k n j u\n  have iu : smul 100 u.1 \u2264 smul 1 m.1 := (exists_smul_le_of_\ud835\udd18\u2083 u).choose_spec\n  have iu' : smul 100 u'.1 \u2264 smul 1 m.1 := e \u25b8 (exists_smul_le_of_\ud835\udd18\u2083 u').choose_spec\n  have su : ball_{\ud835\udcd8 m.1} (\ud835\udcac m.1) 1 \u2286 ball_{\ud835\udcd8 u.1} (\ud835\udcac u.1) 100 := iu.2\n  have su' : ball_{\ud835\udcd8 m.1} (\ud835\udcac m.1) 1 \u2286 ball_{\ud835\udcd8 u'.1} (\ud835\udcac u'.1) 100 := iu'.2\n  have nd : \u00acDisjoint (ball_{\ud835\udcd8 u.1} (\ud835\udcac u.1) 100) (ball_{\ud835\udcd8 u'.1} (\ud835\udcac u'.1) 100) := by\n    rw [not_disjoint_iff]\n    use \ud835\udcac m.1, su (mem_ball_self zero_lt_one), su' (mem_ball_self zero_lt_one)\n  by_contra! h; rw [\u2190 Subtype.coe_ne_coe] at h; apply absurd _ nd\n  have nr : \u00acURel k n j u.1 u'.1 := by contrapose! h; exact EquivalenceOn.reprs_inj u.2 u'.2 h\n  have n\ud835\udcd8 : \ud835\udcd8 u.1 \u2260 \ud835\udcd8 u'.1 := by\n    contrapose! nr; rw [disjoint_comm] at nd\n    exact urel_of_not_disjoint (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 u.2) nr.symm nd\n  rcases le_or_lt (s (\ud835\udcd8 u.1)) (s (\ud835\udcd8 u'.1)) with hs | hs\n  \u00b7 have hu := lt_of_le_of_ne ((le_or_disjoint hs).resolve_right\n      (not_disjoint_iff.mpr \u27e8_, mu, mu'\u27e9)) n\ud835\udcd8\n    have u\u2081 := (\ud835\udd18\u2083_subset_\ud835\udd18\u2082.trans \ud835\udd18\u2082_subset_\ud835\udd18\u2081) u.2\n    exact u\u2081.2 u' ((\ud835\udd18\u2083_subset_\ud835\udd18\u2082.trans \ud835\udd18\u2082_subset_\ud835\udd18\u2081 |>.trans \ud835\udd18\u2081_subset_\u212d\u2081) u'.2) hu\n  \u00b7 have hu := lt_of_le_of_ne ((le_or_disjoint hs.le).resolve_right\n      (not_disjoint_iff.mpr \u27e8_, mu', mu\u27e9)) n\ud835\udcd8.symm\n    have u'\u2081 := (\ud835\udd18\u2083_subset_\ud835\udd18\u2082.trans \ud835\udd18\u2082_subset_\ud835\udd18\u2081) u'.2\n    exact (u'\u2081.2 u ((\ud835\udd18\u2083_subset_\ud835\udd18\u2082.trans \ud835\udd18\u2082_subset_\ud835\udd18\u2081 |>.trans \ud835\udd18\u2081_subset_\u212d\u2081) u.2) hu).symm\n\nlemma stackSize_\ud835\udd18\u2083_le_\ud835\udd10 (x : X) : stackSize (\ud835\udd18\u2083 k n j) x \u2264 stackSize (\ud835\udd10 k n) x := by\n  let mf' : \ud835\udd13 X \u2192 \ud835\udd13 X := fun u \u21a6 if mu : u \u2208 \ud835\udd18\u2083 k n j then mf k n j \u27e8u, mu\u27e9 else default\n  simp_rw [stackSize, indicator_apply, Pi.one_apply, Finset.sum_boole, Nat.cast_id]\n  refine Finset.card_le_card_of_injOn mf' (fun u mu \u21a6 ?_) (fun u mu u' mu' e \u21a6 ?_)\n  \u00b7 simp_rw [Finset.mem_filter, Finset.mem_univ, true_and] at mu \u22a2\n    simp_rw [mf', mu.1, dite_true]\n    have hu : \ud835\udcd8 u \u2264 \ud835\udcd8 (mf k n j \u27e8u, mu.1\u27e9) := (exists_smul_le_of_\ud835\udd18\u2083 \u27e8u, mu.1\u27e9).choose_spec.1\n    exact \u27e8(mf k n j \u27e8u, mu.1\u27e9).2, hu.1 mu.2\u27e9\n  \u00b7 simp_rw [Finset.coe_filter, mem_setOf, Finset.mem_filter, Finset.mem_univ, true_and] at mu mu'\n    simp_rw [mf', mu.1, mu'.1, dite_true, Subtype.val_inj] at e\n    simpa using mf_injOn mu.2 mu'.2 e\n\n/-- Lemma 5.4.8, used to verify that \ud835\udd18\u2084 satisfies 2.0.34. -/\nlemma forest_stacking (x : X) (hkn : k \u2264 n) : stackSize (\ud835\udd18\u2083 (X := X) k n j) x \u2264 C5_4_8 n := by\n  by_contra! h\n  let C : Finset (\ud835\udd13 X) := { u | u \u2208 \ud835\udd18\u2083 (X := X) k n j \u2227 x \u2208 \ud835\udcd8 u }\n  have Cc : C.card = stackSize (\ud835\udd18\u2083 k n j) x := by\n    simp_rw [stackSize, indicator_apply, Pi.one_apply, Finset.sum_boole, Nat.cast_id,\n      C, Grid.mem_def, Finset.filter_filter]\n  have Cn : C.Nonempty := by\n    by_contra! Ce; rw [Finset.not_nonempty_iff_eq_empty] at Ce\n    simp_rw [\u2190 Cc, Ce, Finset.card_empty, not_lt_zero'] at h\n  let C' : Finset (Grid X) := C.image \ud835\udcd8\n  have C'n : C'.Nonempty := by rwa [Finset.image_nonempty]\n  obtain \u27e8i, mi, li\u27e9 := C'.exists_minimal C'n\n  simp_rw [C', Finset.mem_image, C, Finset.mem_filter, Finset.mem_univ, true_and] at mi\n  obtain \u27e8u, \u27e8mu, mx\u27e9, uei\u27e9 := mi; subst uei\n  have uA : (\ud835\udcd8 u : Set X) \u2286 setA (2 * n + 6) k n := fun y my \u21a6\n    calc\n      _ = (4 * n + 12) * 2 ^ n := by ring\n      _ < stackSize (\ud835\udd18\u2083 k n j) x := h\n      _ \u2264 stackSize (\ud835\udd18\u2083 k n j) y := by\n        simp_rw [stackSize, indicator_apply, Pi.one_apply, Finset.sum_boole, Nat.cast_id]\n        apply Finset.card_le_card fun v mv \u21a6 ?_\n        simp_rw [Finset.mem_filter, Finset.mem_univ, true_and] at mv \u22a2\n        have mvC' : \ud835\udcd8 v \u2208 C' := by\n          simp_rw [C', Finset.mem_image]; use v\n          simp_rw [C, Finset.mem_filter, Finset.mem_univ, true_and, and_true]; exact mv\n        specialize li _ mvC'\n        have inc := (or_assoc.mpr (le_or_ge_or_disjoint (i := \ud835\udcd8 u) (j := \ud835\udcd8 v))).resolve_right\n          (not_disjoint_iff.mpr \u27e8_, mx, mv.2\u27e9)\n        simp_rw [le_iff_eq_or_lt] at inc\n        replace inc : \ud835\udcd8 u = \ud835\udcd8 v \u2228 \ud835\udcd8 u < \ud835\udcd8 v := by tauto\n        rw [\u2190 le_iff_eq_or_lt] at inc\n        exact \u27e8mv.1, inc.1 my\u27e9\n      _ \u2264 _ := stackSize_\ud835\udd18\u2083_le_\ud835\udd10 _\n  refine absurd (disjoint_left.mpr fun v mv \u21a6 ?_) (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 mu).2\n  rw [\ud835\udd17\u2081, mem_setOf] at mv; rw [\u212d\u2086, mem_setOf, not_and, not_not]\n  refine fun _ \u21a6 (mv.2.2.1).1.trans ?_\n  calc\n    _ \u2286 setA (2 * n + 6) k n := uA\n    _ \u2286 G\u2082 := subset_iUnion\u2082_of_subset n k (subset_iUnion_of_subset hkn subset_rfl)\n    _ \u2286 _ := subset_union_of_subset_left subset_union_right G\u2083\n\n/-- Define `\ud835\udd18\u2084 k n j l` as the union of `2 ^ n` disjoint subfamilies in `\ud835\udd18\u2083 k n j`, to make sure\nthe multiplicity is at most `2 ^ n` to get a forest. -/\ndef \ud835\udd18\u2084 (k n j l : \u2115) : Set (\ud835\udd13 X) :=\n  \u22c3 i \u2208 Ico (l * 2 ^ n) ((l + 1) * 2 ^ n), iteratedMaximalSubfamily (\ud835\udd18\u2083 k n j) i\n\nlemma \ud835\udd18\u2084_subset_\ud835\udd18\u2083 {k n j l} : \ud835\udd18\u2084 (X := X) k n j l \u2286 \ud835\udd18\u2083 k n j := by\n  simp [\ud835\udd18\u2084, iteratedMaximalSubfamily_subset]\n\n/-- The sets `(\ud835\udd18\u2084(k, n, j, l))_l` form a partition of `\ud835\udd18\u2083 k n j`. -/\nlemma iUnion_\ud835\udd18\u2084 (hkn : k \u2264 n) : \u22c3 l \u2208 Iio (4 * n + 12), \ud835\udd18\u2084 (X := X) k n j l = \ud835\udd18\u2083 k n j := by\n  have : \u22c3 l \u2208 Iio (4 * n + 12), \ud835\udd18\u2084 (X := X) k n j l =\n      \u22c3 i < (4 * n + 12) * 2 ^ n, iteratedMaximalSubfamily (\ud835\udd18\u2083 k n j) i := by\n    apply Subset.antisymm\n    \u00b7 simp only [mem_Iio, \ud835\udd18\u2084, mem_Ico, biUnion_and', iUnion_subset_iff]\n      intro l i hi hl h'i\n      apply subset_biUnion_of_mem\n      change i + 1 \u2264 (4 * n + 12) * 2 ^ n\n      suffices i < (4 * n + 12) * 2 ^ n by omega\n      exact h'i.trans_le (mul_le_mul' (by omega) le_rfl)\n    \u00b7 simp only [\ud835\udd18\u2084, iUnion_subset_iff]\n      intro i hi\n      let l := i / 2 ^ n\n      have : iteratedMaximalSubfamily (\ud835\udd18\u2083 k n j) i \u2286 \u22c3 i \u2208 Ico (l * 2 ^ n) ((l + 1) * 2 ^ n),\n          iteratedMaximalSubfamily (X := X) (\ud835\udd18\u2083 k n j) i := by\n        apply subset_biUnion_of_mem\n        refine \u27e8Nat.div_mul_le_self _ _, ?_\u27e9\n        rw [\u2190 Nat.div_lt_iff_lt_mul (Nat.two_pow_pos n)]\n        exact lt_add_one _\n      apply this.trans\n      apply subset_biUnion_of_mem (u := fun l \u21a6\n        \u22c3 i \u2208 Ico (l * 2 ^ n) ((l + 1) * 2 ^ n), iteratedMaximalSubfamily (\ud835\udd18\u2083 k n j) i)\n      simp only [mem_Iio, l]\n      rwa [Nat.div_lt_iff_lt_mul (Nat.two_pow_pos n)]\n  rw [this, eq_comm]\n  apply eq_biUnion_iteratedMaximalSubfamily\n  intro x\n  apply forest_stacking x hkn\n\nlemma C6_forest' (hkn : k \u2264 n) :\n    \u212d\u2086 (X := X) k n j = \u22c3 l \u2208 Iio (4 * n + 12), \u22c3 u \u2208 \ud835\udd18\u2084 k n j l, \ud835\udd17\u2082 k n j u := by\n  rw [C6_forest, \u2190 iUnion_\ud835\udd18\u2084 hkn]\n  simp\n\nlemma pairwiseDisjoint_\ud835\udd18\u2084 : univ.PairwiseDisjoint (\ud835\udd18\u2084 (X := X) k n j) := by\n  intro l hl m hm hml\n  apply disjoint_iff_forall_ne.2 (fun x hx y hy \u21a6 ?_)\n  simp only [\ud835\udd18\u2084, mem_Ico, mem_iUnion, exists_prop] at hx hy\n  rcases hx with \u27e8a, \u27e8ha, h'a\u27e9, xa\u27e9\n  rcases hy with \u27e8b, \u27e8hb, h'b\u27e9, yb\u27e9\n  have h : a \u2260 b := by\n    rcases lt_or_gt_of_ne hml with h | h\n    \u00b7 exact (h'a.trans_le (le_trans (mul_le_mul' h le_rfl) hb)).ne\n    \u00b7 exact (h'b.trans_le (le_trans (mul_le_mul' h le_rfl) ha)).ne'\n  have := pairwiseDisjoint_iteratedMaximalSubfamily (\ud835\udd18\u2083 (X := X) k n j) (mem_univ a) (mem_univ b) h\n  exact disjoint_iff_forall_ne.1 this xa yb\n\nlemma stackSize_\ud835\udd18\u2084_le (x : X) : stackSize (\ud835\udd18\u2084 (X := X) k n j l) x \u2264 2 ^ n := calc\n  stackSize (\ud835\udd18\u2084 (X := X) k n j l) x\n  _ = \u2211 i \u2208 Finset.Ico (l * 2 ^ n) ((l + 1) * 2 ^ n),\n        stackSize (iteratedMaximalSubfamily (\ud835\udd18\u2083 k n j) i) x := by\n    simp only [stackSize, \ud835\udd18\u2084]\n    rw [\u2190 Finset.sum_biUnion]; swap\n    \u00b7 intro a ha b hb hab\n      apply Finset.disjoint_coe.1\n      apply disjoint_iff_forall_ne.2 (fun p hp q hq \u21a6 ?_)\n      simp only [Finset.coe_filter, Finset.mem_univ, true_and, setOf_mem_eq] at hp hq\n      have := pairwiseDisjoint_iteratedMaximalSubfamily (\ud835\udd18\u2083 (X := X) k n j)\n        (mem_univ a) (mem_univ b) hab\n      exact disjoint_iff_forall_ne.1 this hp hq\n    congr\n    ext p\n    simp\n  _ \u2264 \u2211 i \u2208 Finset.Ico (l * 2 ^ n) ((l + 1) * 2 ^ n), 1 := by\n    gcongr with i hi\n    apply stackSize_le_one_of_pairwiseDisjoint\n    apply pairwiseDisjoint_iteratedMaximalSubfamily_image\n  _ = 2 ^ n := by simp [add_mul]\n\nopen TileStructure\nvariable (k n j l) in\n/-- The forest based on `\ud835\udd18\u2084 k n j l`. -/\ndef forest : Forest X n where\n  \ud835\udd18 := \ud835\udd18\u2084 k n j l\n  \ud835\udd17 := \ud835\udd17\u2082 k n j\n  nonempty' {u} hu := by\n    have m : u \u2208 \ud835\udd18\u2082 k n j := (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 (\ud835\udd18\u2084_subset_\ud835\udd18\u2083 hu))\n    have : \u212d\u2086 k n j \u2229 \ud835\udd17\u2081 k n j u \u2286 \ud835\udd17\u2082 k n j u := by\n      apply inter_subset_inter_right\n      have : \ud835\udd17\u2081 k n j u \u2286 \u22c3 (_ : URel k n j u u), \ud835\udd17\u2081 k n j u := by\n        have : URel k n j u u := (equivalenceOn_urel (X := X)).refl _ m\n        simp [this]\n      apply this.trans\n      apply subset_biUnion_of_mem (u := fun u' \u21a6 \u22c3 (_ : URel k n j u u'), \ud835\udd17\u2081 k n j u') m\n    apply Nonempty.mono this\n    rw [inter_comm]\n    simp only [\ud835\udd18\u2082, not_disjoint_iff_nonempty_inter, mem_setOf_eq] at m\n    exact m.2\n  ordConnected' {u} hu := forest_convex\n  \ud835\udcd8_ne_\ud835\udcd8' {u} hu p hp := by\n    have := hp.2\n    simp only [mem_iUnion, exists_prop, exists_and_left] at this\n    rcases this with \u27e8u', hu', u'rel, hu'I\u27e9\n    rw [URel.eq (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 (\ud835\udd18\u2084_subset_\ud835\udd18\u2083 hu)) hu' u'rel]\n    exact (\ud835\udcd8_lt_of_mem_\ud835\udd17\u2081 hu'I).ne\n  smul_four_le' {u} hu := forest_geometry <| \ud835\udd18\u2084_subset_\ud835\udd18\u2083 hu\n  stackSize_le' {x} := stackSize_\ud835\udd18\u2084_le x\n  dens\u2081_\ud835\udd17_le' {u} hu := dens1_le <| \ud835\udd17\u2082_subset_\u212d\u2086.trans \u212d\u2086_subset_\u212d\n  lt_dist' hu hu' huu' p hp := forest_separation (\ud835\udd18\u2084_subset_\ud835\udd18\u2083 hu) (\ud835\udd18\u2084_subset_\ud835\udd18\u2083 hu') huu' hp\n  ball_subset' hu p hp := forest_inner (\ud835\udd18\u2084_subset_\ud835\udd18\u2083 hu) hp\n\n/-- From the fact that the `\u212d\u2085 k n j` are disjoint, one can rewrite the whole Carleson sum over\n`\ud835\udd13\u2081` (the union of the `\u212d\u2085 k n j`) as a sum of Carleson sums over the `\u212d\u2085 k n j`. -/\nlemma carlesonSum_\ud835\udd13\u2081_eq_sum {f : X \u2192 \u2102} {x : X} :\n    carlesonSum \ud835\udd13\u2081 f x = \u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3, carlesonSum (\u212d\u2085 k n j) f x := by\n  simp only [Finset.sum_sigma']\n  rw [sum_carlesonSum_of_pairwiseDisjoint]; swap\n  \u00b7 rintro \u27e8n, k, j\u27e9 - \u27e8n', k', j'\u27e9 - h\n    simp only [ne_eq, Sigma.mk.inj_iff, heq_eq_eq] at h\n    simp only [Function.onFun, Finset.disjoint_filter, Finset.mem_univ, forall_const]\n    have W := pairwiseDisjoint_\u212d\u2085 (X := X) (mem_univ \u27e8k, n, j\u27e9) (mem_univ \u27e8k', n', j'\u27e9)\n      (by simp [-not_and]; tauto)\n    simpa [Function.onFun, disjoint_left] using W\n  congr\n  ext p\n  simp only [\ud835\udd13\u2081, mem_iUnion, exists_prop, Finset.mem_sigma, Finset.mem_Iic, Sigma.exists]\n  constructor\n  \u00b7 rintro \u27e8n, k, hk, j, hj, hp\u27e9\n    refine \u27e8n, k, j, \u27e8?_, hk, hj\u27e9, hp\u27e9\n    have : (\u212d (X := X) k n).Nonempty := \u27e8p, \u212d\u2085_subset_\u212d hp\u27e9\n    exact le_max\u212d_of_nonempty this\n  \u00b7 rintro \u27e8n, k, j, \u27e8hn, hk, hj\u27e9, hp\u27e9\n    exact \u27e8n, k, hk, j, hj, hp\u27e9\n\n/-- The Carleson sum over `\u212d\u2085` and `\u212d\u2086` coincide, for points in `G \\ G'`. -/\nlemma carlesonSum_\u212d\u2085_eq_\u212d\u2086 {f : X \u2192 \u2102} {x : X} (hx : x \u2208 G \\ G') {k n j : \u2115} :\n    carlesonSum (\u212d\u2085 k n j) f x = carlesonSum (\u212d\u2086 k n j) f x := by\n  simp only [carlesonSum]\n  symm\n  apply Finset.sum_subset\n  \u00b7 intro p hp\n    simp only [mem_iUnion, exists_prop, Finset.mem_filter, Finset.mem_univ, true_and] at hp \u22a2\n    exact \u212d\u2086_subset_\u212d\u2085 hp\n  \u00b7 intro p hp h'p\n    simp only [mem_iUnion, exists_prop, Finset.mem_filter,\n      Finset.mem_univ, true_and, not_exists, not_and] at hp h'p\n    have : x \u2209 \ud835\udcd8 p := by\n      simp only [\u212d\u2086, mem_setOf_eq, not_and, Decidable.not_not] at h'p\n      intro h'x\n      exact hx.2 (h'p hp h'x)\n    have : x \u2209 E p := by simp at this; simp [E, this]\n    simp [carlesonOn, this]\n\n/-- The Carleson sum over `\u212d\u2086` can be decomposed as a sum over `4 n + 12` forests\nbased on `\ud835\udd18\u2084 k n j l`. -/\nlemma carlesonSum_\u212d\u2086_eq_sum {f : X \u2192 \u2102} {x : X} {k n j : \u2115} (hkn : k \u2264 n) :\n    carlesonSum (\u212d\u2086 k n j) f x =\n      \u2211 l < 4 * n + 12, carlesonSum (\u22c3 u \u2208 \ud835\udd18\u2084 k n j l, \ud835\udd17\u2082 k n j u) f x := by\n  rw [sum_carlesonSum_of_pairwiseDisjoint]; swap\n  \u00b7 intro a ha b hb hab\n    simp only [Function.onFun, disjoint_iff_forall_ne, mem_iUnion, exists_prop, ne_eq,\n      forall_exists_index, and_imp]\n    intro q p hp hq q' p' hp' hq'\n    have := pairwiseDisjoint_\ud835\udd18\u2084 (X := X) (k := k) (n := n) (j := j) (mem_univ a) (mem_univ b) hab\n    have : p \u2260 p' := disjoint_iff_forall_ne.1 this hp hp'\n    have := forest_disjoint (\ud835\udd18\u2084_subset_\ud835\udd18\u2083 hp) (\ud835\udd18\u2084_subset_\ud835\udd18\u2083 hp') this\n    exact disjoint_iff_forall_ne.1 this hq hq'\n  congr\n  ext p\n  simp [C6_forest' hkn]\n\n/-- For each forest, the integral of the norm of the Carleson sum can be controlled thanks to\nthe forest theorem and to the density control coming from the fact we are away from `G\u2081`. -/\nlemma lintegral_carlesonSum_forest\n    {f : X \u2192 \u2102} (hf : Measurable f) (h2f : \u2200 x, \u2016f x\u2016 \u2264 F.indicator 1 x) :\n    \u222b\u207b x in G \\ G', \u2016carlesonSum (\u22c3 u \u2208 \ud835\udd18\u2084 k n j l, \ud835\udd17\u2082 k n j u) f x\u2016\u208a \u2264\n    C2_0_4 a q n * (2 ^ (2 * a + 5) * volume F / volume G) ^ (q\u207b\u00b9 - 2\u207b\u00b9) *\n    (volume F) ^ (1/2 : \u211d) * (volume G) ^ (1/2 : \u211d) := by\n  let \ud835\udd09 := forest (X := X) k n j l\n  have : \u222b\u207b x in G \\ G', \u2016carlesonSum (\u22c3 u \u2208 \ud835\udd18\u2084 k n j l, \ud835\udd17\u2082 k n j u) f x\u2016\u208a =\n      \u222b\u207b x in G \\ G', \u2016\u2211 u \u2208 { p | p \u2208 \ud835\udd09 }, carlesonSum (\ud835\udd09 u) f x\u2016\u208a := by\n    congr with x\n    congr\n    rw [sum_carlesonSum_of_pairwiseDisjoint]; swap\n    \u00b7 intro a ha b hb hab\n      simp only [Function.onFun, disjoint_iff_forall_ne]\n      intro x hx y hy\n      simp only [forest, Forest.mem_mk, Finset.coe_filter, Finset.mem_univ, true_and, setOf_mem_eq,\n        \ud835\udd09] at ha hb hx hy\n      have := forest_disjoint (X := X) (\ud835\udd18\u2084_subset_\ud835\udd18\u2083 ha) (\ud835\udd18\u2084_subset_\ud835\udd18\u2083 hb) hab\n      exact disjoint_iff_forall_ne.1 this hx hy\n    congr with p\n    simp only [mem_iUnion, exists_prop, Finset.mem_filter,\n      Finset.mem_univ, true_and, forest, Finset.mem_biUnion, \ud835\udd09]\n    exact Iff.rfl\n  rw [this]\n  have W := forest_operator_le_volume \ud835\udd09 hf h2f (A := G \\ G') (measurableSet_G.diff measurable_G')\n    (isBounded_G.subset diff_subset)\n  apply W.trans\n  gcongr\n  \u00b7 simp only [sub_nonneg, ge_iff_le, inv_le_inv\u2080 zero_lt_two (q_pos X)]\n    exact (q_mem_Ioc (X := X)).2\n  \u00b7 rw [dens\u2082_eq_biSup_dens\u2082]\n    simp only [mem_iUnion, exists_prop, iSup_exists, iSup_le_iff, and_imp]\n    intro p q hq hp\n    replace hp : p \u2208 \u212d\u2086 k n j := \ud835\udd17\u2082_subset_\u212d\u2086 hp\n    have : \u00ac (\ud835\udcd8 p : Set X) \u2286 G\u2081 := by\n      have W := hp.2\n      contrapose! W\n      exact W.trans (subset_union_left.trans subset_union_left)\n    contrapose! this\n    have : p \u2208 highDensityTiles := by simp [highDensityTiles, this]\n    apply subset_biUnion_of_mem this\n  \u00b7 exact diff_subset\n\n/-- For each forest, the integral of the norm of the Carleson sum can be controlled thanks to\nthe forest theorem and to the density control coming from the fact we are away from `G\u2081`. Second\nversion, with the volume of `F`. -/\nlemma lintegral_carlesonSum_forest'\n    {f : X \u2192 \u2102} (hf : Measurable f) (h2f : \u2200 x, \u2016f x\u2016 \u2264 F.indicator 1 x) :\n    \u222b\u207b x in G \\ G', \u2016carlesonSum (\u22c3 u \u2208 \ud835\udd18\u2084 k n j l, \ud835\udd17\u2082 k n j u) f x\u2016\u208a \u2264\n    C2_0_4 a q n * 2 ^ (a + 5/2 : \u211d) * (volume G) ^ (1 - q\u207b\u00b9) * (volume F) ^ (q\u207b\u00b9) := by\n  apply (lintegral_carlesonSum_forest hf h2f).trans\n  simp only [mul_assoc]\n  apply mul_le_mul_left'\n  simp only [div_eq_mul_inv, one_mul, ENNReal.mul_rpow_of_nonneg _ _ (inv_q_sub_half_nonneg X),\n    \u2190 ENNReal.rpow_natCast, \u2190 ENNReal.rpow_mul]\n  calc\n  2 ^ ((2 * a + 5 : \u2115) * (q\u207b\u00b9 - 2\u207b\u00b9)) * volume F ^ (q\u207b\u00b9 - 2\u207b\u00b9) * (volume G)\u207b\u00b9 ^ (q\u207b\u00b9 - 2\u207b\u00b9) *\n    (volume F ^ (2\u207b\u00b9 : \u211d) * volume G ^ (2\u207b\u00b9 : \u211d))\n  _ \u2264 2 ^ (a + 5/2 : \u211d) * volume F ^ (q\u207b\u00b9 - 2\u207b\u00b9) * (volume G)\u207b\u00b9 ^ (q\u207b\u00b9 - 2\u207b\u00b9) *\n    ((volume F) ^ (2\u207b\u00b9 : \u211d) * volume G ^ (2\u207b\u00b9 : \u211d)) := by\n    gcongr\n    \u00b7 exact one_le_two\n    have : 1 \u2264 q := (one_lt_q X).le\n    have : (2 * a + 5 : \u2115) * (q\u207b\u00b9 - 2\u207b\u00b9) \u2264 (2 * a + 5 : \u2115) * (1\u207b\u00b9 - 2\u207b\u00b9) := by gcongr\n    apply this.trans_eq\n    norm_num\n    simp [add_mul, div_eq_mul_inv]\n    ring\n  _ = 2 ^ (a + 5/2 : \u211d) * (volume G ^ (1 - q\u207b\u00b9) * volume F ^ q\u207b\u00b9) := by\n    have IF : (volume F) ^ (q\u207b\u00b9) = (volume F) ^ ((q \u207b\u00b9 - 2\u207b\u00b9) + 2\u207b\u00b9) := by congr; abel\n    have IG : (volume G) ^ (1 - q\u207b\u00b9) = (volume G) ^ (2\u207b\u00b9 - (q\u207b\u00b9 - 2\u207b\u00b9)) := by\n      congr 1\n      simp only [sub_sub_eq_add_sub, sub_left_inj]\n      norm_num\n    rw [IF, IG, ENNReal.rpow_sub _ _ ProofData.volume_G_pos.ne' volume_G_ne_top,\n      ENNReal.rpow_add_of_nonneg (x := volume F) _ _ (inv_q_sub_half_nonneg X) (by norm_num),\n      ENNReal.div_eq_inv_mul, ENNReal.inv_rpow]\n    ring\n\n/-- Putting all the above decompositions together, one obtains a control of the integral of the\nfull Carleson sum over `\ud835\udd13\u2081`, as a sum over all the forests. -/\nlemma forest_union_aux {f : X \u2192 \u2102} (hf : \u2200 x, \u2016f x\u2016 \u2264 F.indicator 1 x) (h'f : Measurable f) :\n    \u222b\u207b x in G \\ G', \u2016carlesonSum \ud835\udd13\u2081 f x\u2016\u208a \u2264 C2_0_4_base a * 2 ^ (a + 5/2 : \u211d) *\n         (volume G) ^ (1 - q\u207b\u00b9) * (volume F) ^ (q\u207b\u00b9) *\n        \u2211 n \u2264 max\u212d X, \u2211 _k \u2264 n, \u2211 _j \u2264 2 * n + 3, \u2211 _l < 4 * n + 12,\n          (2 : \u211d\u22650\u221e) ^ (- (q - 1) / q * n : \u211d) := calc\n  \u222b\u207b x in G \\ G', \u2016carlesonSum \ud835\udd13\u2081 f x\u2016\u208a\n  _ \u2264 \u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3, \u222b\u207b x in G \\ G', \u2016carlesonSum (\u212d\u2085 k n j) f x\u2016\u208a := by\n    simp only [Finset.sum_sigma']\n    rw [\u2190 lintegral_finset_sum']; swap\n    \u00b7 exact fun b hb \u21a6 h'f.aestronglyMeasurable.carlesonSum.restrict.enorm\n    apply lintegral_mono (fun x \u21a6 ?_)\n    simp only [Finset.sum_sigma', carlesonSum_\ud835\udd13\u2081_eq_sum]\n    exact (ENNReal.coe_le_coe.2 (nnnorm_sum_le _ _)).trans_eq (by simp)\n  _ = \u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3, \u222b\u207b x in G \\ G', \u2016carlesonSum (\u212d\u2086 k n j) f x\u2016\u208a := by\n    congr with n\n    congr with k\n    congr with j\n    apply setLIntegral_congr_fun (measurableSet_G.diff measurable_G')\n    exact Filter.Eventually.of_forall (fun x hx \u21a6 by rw [carlesonSum_\u212d\u2085_eq_\u212d\u2086 hx])\n  _ \u2264 \u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3,\n        \u2211 l < 4 * n + 12, \u222b\u207b x in G \\ G', \u2016carlesonSum (\u22c3 u \u2208 \ud835\udd18\u2084 k n j l, \ud835\udd17\u2082 k n j u) f x\u2016\u208a := by\n    gcongr with n hn k hk j hj\n    rw [\u2190 lintegral_finset_sum']; swap\n    \u00b7 exact fun b hb \u21a6 h'f.aestronglyMeasurable.carlesonSum.restrict.enorm\n    apply lintegral_mono (fun x \u21a6 ?_)\n    simp only [Finset.mem_Iic] at hk\n    rw [carlesonSum_\u212d\u2086_eq_sum hk]\n    exact (ENNReal.coe_le_coe.2 (nnnorm_sum_le _ _)).trans_eq (by simp)\n  _ \u2264 \u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3,\n        \u2211 l < 4 * n + 12, C2_0_4 a q n * 2 ^ (a + 5/2 : \u211d) *\n          (volume G) ^ (1 - q\u207b\u00b9) * (volume F) ^ (q\u207b\u00b9) := by\n    gcongr with n hn k hk j hj l hl\n    apply lintegral_carlesonSum_forest' h'f hf\n  _ = C2_0_4_base a * 2 ^ (a + 5/2 : \u211d) * (volume G) ^ (1 - q\u207b\u00b9) * (volume F) ^ (q\u207b\u00b9) *\n        \u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3, \u2211 l < 4 * n + 12,\n          (2 : \u211d\u22650\u221e) ^ (- (q - 1) / q * n : \u211d) := by\n    have A n : (C2_0_4 a q n : \u211d\u22650\u221e) = (2 : \u211d\u22650\u221e) ^ (- (q - 1) / q * n : \u211d) * C2_0_4_base a := by\n      simp only [C2_0_4, neg_sub, mul_comm, ENNReal.coe_mul,\n        ENNReal.coe_rpow_of_ne_zero two_ne_zero]\n      rfl\n    simp only [A, \u2190 Finset.sum_mul]\n    ring\n\n/- It remains to bound the sum above, by a sum/integral comparison over `\u211d` and then a cast from\n`\u211d` to `\u211d\u22650\u221e`. We do that in the next two lemmas. -/\n\nopen scoped Nat\nopen Real\n\nlemma forest_union_sum_aux1 (M : \u2115) (q : \u211d) (hq : 1 < q) (h'q : q \u2264 2) :\n    \u2211 n \u2264 M, \u2211 _k \u2264 n, \u2211 _j \u2264 2 * n + 3, \u2211 _l < 4 * n + 12,\n      (2 : \u211d) ^ (- ((q - 1) / q * n)) \u2264 13009 / (q - 1) ^ 4 := by\n  have A (x : \u211d) : (x + 1) * (2 * x + 3 + 1) * (4 * x + 12)\n      = 8 * x ^ 3 + 48 * x ^ 2 + 88 * x + 48:= by ring\n  simp only [Finset.sum_const, Nat.card_Iio, nsmul_eq_mul, Nat.cast_add, Nat.cast_mul,\n    Nat.cast_ofNat, Nat.card_Iic, Nat.cast_one, \u2190 mul_assoc, A, ge_iff_le]\n  simp only [add_mul, Finset.sum_add_distrib, mul_assoc, \u2190 Finset.mul_sum]\n  have : 0 \u2264 q - 1 := by linarith\n  have : q - 1 \u2264 1 := by linarith\n  have : 0.6931471803 \u2264 Real.log 2 := Real.log_two_gt_d9.le\n  let c := (q - 1) / q\n  have hc : 0 < c := div_pos (by linarith) (by linarith)\n  calc\n  8 * \u2211 i \u2208 Finset.Iic M, i ^ 3 * (2 : \u211d) ^ (-(c * i))\n    + 48 * \u2211 i \u2208 Finset.Iic M, i ^ 2 * (2 : \u211d) ^ (-(c * i))\n    + 88 * \u2211 i \u2208 Finset.Iic M, i * (2 : \u211d) ^ (-(c * i))\n    + 48 * \u2211 i \u2208 Finset.Iic M, (2 : \u211d) ^ (-(c * i))\n  _ = 8 * \u2211 i \u2208 Finset.Iic M, i ^ 3 * (2 : \u211d) ^ (-(c * i))\n      + 48 * \u2211 i \u2208 Finset.Iic M, i ^ 2 * (2 : \u211d) ^ (-(c * i))\n      + 88 * \u2211 i \u2208 Finset.Iic M, i ^ 1  * (2 : \u211d) ^ (-(c * i))\n      + 48 * \u2211 i \u2208 Finset.Iic M, i ^ 0 * (2 : \u211d) ^ (-(c * i)) := by simp\n  _ \u2264 8 * (2 ^ c * 3 ! / (Real.log 2 * c) ^ (3 + 1))\n      + 48 * (2 ^ c * 2 ! / (Real.log 2 * c) ^ (2 + 1))\n      + 88 * (2 ^ c * 1 ! / (Real.log 2 * c) ^ (1 + 1))\n      + 48 * (2 ^ c * 0! / (Real.log 2 * c) ^ (0 + 1)) := by\n    gcongr <;> exact sum_Iic_pow_mul_two_pow_neg_le hc\n  _ = (2 ^ c * (48 * q ^ 4 / (Real.log 2) ^ 4 + 96 * q^3 * (q - 1) / (Real.log 2) ^ 3\n      + 88 * q ^ 2 * (q - 1) ^ 2 / (Real.log 2) ^ 2\n      + 48 * q * (q - 1) ^ 3/ (Real.log 2))) / (q - 1) ^ 4 := by\n    simp only [Nat.factorial, Nat.succ_eq_add_one, Nat.reduceAdd, zero_add, mul_one, Nat.reduceMul,\n      Nat.cast_ofNat, mul_pow, div_pow, Nat.cast_one, pow_one, c]\n    have : q - 1 \u2260 0 := by linarith\n    field_simp only\n    ring\n  _ \u2264 (2 ^ (1 : \u211d) * (48 * 2 ^ 4 / (Real.log 2) ^ 4 + 96 * 2 ^ 3 * 1 / (Real.log 2) ^ 3\n      + 88 * 2 ^ 2 * 1 ^ 2 / (Real.log 2) ^ 2 + 48 * 2 * 1 ^ 3 / (Real.log 2))) / (q - 1) ^ 4 := by\n    gcongr\n    \u00b7 exact one_le_two\n    \u00b7 rw [div_le_one (by linarith)]\n      linarith\n  _ \u2264 (2 ^ (1 : \u211d) * (48 * 2 ^ 4 / 0.6931471803 ^ 4 + 96 * 2 ^ 3 * 1 / 0.6931471803 ^ 3\n      + 88 * 2 ^ 2 * 1 ^ 2 / 0.6931471803 ^ 2 + 48 * 2 * 1 ^ 3 / 0.6931471803)) / (q - 1) ^ 4 := by\n    gcongr\n  _ \u2264 13009 / (q - 1) ^ 4 := by\n    gcongr\n    norm_num\n\nlemma forest_union_sum_aux2 (M : \u2115) (q : \u211d) (hq : 1 < q) (h'q : q \u2264 2) :\n    (\u2211 n \u2264 M, \u2211 _k \u2264 n, \u2211 _j \u2264 2 * n + 3, \u2211 _l < 4 * n + 12,\n      (2 : \u211d\u22650\u221e) ^ (- ((q - 1) / q * n))) \u2264 13009 / (ENNReal.ofReal (q - 1)) ^ 4 := by\n  have : (2 : \u211d\u22650\u221e) = ENNReal.ofReal (2 : \u211d) := by simp\n  simp_rw [this, ENNReal.ofReal_rpow_of_pos zero_lt_two]\n  simp only [Finset.sum_const, Nat.card_Iio, nsmul_eq_mul, Nat.cast_add, Nat.cast_mul,\n    Nat.cast_ofNat, Nat.card_Iic, Nat.cast_one, ge_iff_le]\n  calc\n  \u2211 x \u2208 Finset.Iic M, (\u2191x + 1) * ((2 * \u2191x + 3 + 1) * ((4 * \u2191x + 12)\n      * ENNReal.ofReal (2 ^ (-((q - 1) / q * \u2191x)))))\n  _ = \u2211 x \u2208 Finset.Iic M, ENNReal.ofReal\n      ((\u2191x + 1) * ((2 * \u2191x + 3 + 1) * ((4 * \u2191x + 12) * 2 ^ (-((q - 1) / q * \u2191x))))) := by\n    congr with i\n    rw [ENNReal.ofReal_mul (by positivity), ENNReal.ofReal_mul (by positivity),\n      ENNReal.ofReal_mul (by positivity)]\n    congr <;> norm_cast\n  _ = ENNReal.ofReal (\u2211 x \u2208 Finset.Iic M,\n      (\u2191x + 1) * ((2 * \u2191x + 3 + 1) * ((4 * \u2191x + 12) * 2 ^ (-((q - 1) / q * \u2191x))))) := by\n    rw [ENNReal.ofReal_sum_of_nonneg]\n    intro i hi\n    positivity\n  _ = ENNReal.ofReal (\u2211 n \u2264 M, \u2211 _k \u2264 n, \u2211 _j \u2264 2 * n + 3, \u2211 _l < 4 * n + 12,\n      (2 : \u211d) ^ (- ((q - 1) / q * n))) := by simp\n  _ \u2264 ENNReal.ofReal (13009 / (q - 1) ^ 4) := by\n    apply ENNReal.ofReal_le_ofReal\n    exact forest_union_sum_aux1 M q hq h'q\n  _ = 13009 / (ENNReal.ofReal (q - 1)) ^ 4 := by\n    rw [ENNReal.ofReal_div_of_pos]; swap\n    \u00b7 have : 0 < q - 1 := by linarith\n      positivity\n    congr\n    \u00b7 norm_cast\n    \u00b7 rw [ENNReal.ofReal_pow]\n      linarith\n\n/-- An optimized constant for the forest union theorem. The constant from the blueprint,\ndefined as `C5_1_2` below, is slightly worse. -/\ndef C5_1_2_optimized (a : \u211d) (q : \u211d\u22650) : \u211d\u22650 :=\n  C2_0_4_base a * 2 ^ (a + 5/2 : \u211d) * 13009 / (q - 1) ^ 4\n\n/-- Version of the forest union result with a better constant. -/\nlemma forest_union_optimized {f : X \u2192 \u2102} (hf : \u2200 x, \u2016f x\u2016 \u2264 F.indicator 1 x) (h'f : Measurable f) :\n    \u222b\u207b x in G \\ G', \u2016carlesonSum \ud835\udd13\u2081 f x\u2016\u208a \u2264\n    C5_1_2_optimized a nnq * (volume G) ^ (1 - q\u207b\u00b9) * (volume F) ^ (q\u207b\u00b9) := by\n  apply (forest_union_aux hf h'f).trans\n  calc\n  C2_0_4_base a * 2 ^ (a + 5 / 2 : \u211d) * volume G ^ (1 - q\u207b\u00b9) * volume F ^ q\u207b\u00b9 *\n    \u2211 n \u2208 Finset.Iic (max\u212d X),\n      \u2211 _k \u2208 Finset.Iic n, \u2211 _j \u2208 Finset.Iic (2 * n + 3), \u2211 _l \u2208 Finset.Iio (4 * n + 12),\n        2 ^ (-(q - 1) / q * \u2191n)\n  _ \u2264 C2_0_4_base a * 2 ^ (a + 5 / 2 : \u211d) * volume G ^ (1 - q\u207b\u00b9) * volume F ^ q\u207b\u00b9 *\n      (13009 / (ENNReal.ofReal (q - 1)) ^ 4) := by\n    gcongr\n    have A n : (2 : \u211d\u22650\u221e) ^ (-(q - 1) / q * n) = 2 ^ (- ((q - 1) / q * n)) := by\n      congr; ring\n    simp_rw [A]\n    exact forest_union_sum_aux2 (max\u212d X) q (one_lt_q X) (q_le_two X)\n  _ = C5_1_2_optimized a nnq * (volume G) ^ (1 - q\u207b\u00b9) * (volume F) ^ (q\u207b\u00b9) := by\n    have : ENNReal.ofReal (q - 1) = (nnq - 1 : \u211d\u22650) := rfl\n    rw [this]\n    simp only [ENNReal.div_eq_inv_mul, C5_1_2_optimized, div_eq_inv_mul _ ((nnq - 1) ^ 4),\n      ENNReal.coe_sub, ENNReal.coe_one, ENNReal.coe_mul, ENNReal.coe_ofNat]\n    rw [ENNReal.coe_inv, ENNReal.coe_rpow_of_ne_zero two_ne_zero]; swap\n    \u00b7 have : 0 < nnq - 1 := tsub_pos_of_lt (one_lt_nnq X)\n      apply ne_of_gt\n      positivity\n    simp only [ENNReal.coe_inv, ENNReal.coe_rpow_of_ne_zero two_ne_zero,\n      ENNReal.coe_pow, ENNReal.coe_sub, ENNReal.coe_one, ENNReal.coe_ofNat]\n    ring\n\n", "theoremStatement": "lemma C5_1_2_optimized_le' {a : \u2115} {q : \u211d\u22650} (ha : 4 \u2264 a) :\n    C5_1_2_optimized a q \u2264 C2_0_4_base a * 2 ^ (a ^ 3) / (q - 1) ^ 4 ", "theoremName": "C5_1_2_optimized_le'", "fileCreated": {"commit": "310e13d16e51600777fc841833f4bce112b5f73a", "date": "2024-09-24"}, "theoremCreated": {"commit": "88d85ba29f717ee3bb9fbd37379a6fb77b57265f", "date": "2025-01-06"}, "file": "carleson/Carleson/Discrete/ForestUnion.lean", "module": "Carleson.Discrete.ForestUnion", "jsonFile": "Carleson.Discrete.ForestUnion.jsonl", "positionMetadata": {"lineInFile": 973, "tokenPositionInFile": 47393, "theoremPositionInFile": 51}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 286}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  have : C5_1_2_optimized a q = C2_0_4_base a * (2 ^ (a + 5/2 : \u211d) * 13009) / (q - 1) ^ 4 := by\n    simp [C5_1_2_optimized, mul_assoc]\n  rw [this]\n  gcongr\n  simp only [\u2190 NNReal.coe_le_coe, NNReal.coe_mul, coe_rpow, NNReal.coe_ofNat]\n  calc\n  (2 : \u211d) ^ (a + 5 / 2 : \u211d) * 13009\n  _ \u2264 2 ^ (a + 3 : \u211d) * 2 ^ 14 := by gcongr <;> norm_num\n  _ = 2 ^ (a + 17) := by\n    have : (a + 3 : \u211d) = (a + 3 : \u2115) := by norm_cast\n    rw [this, Real.rpow_natCast, \u2190 pow_add]\n  _ \u2264 2 ^ (a ^ 3) := by\n    apply pow_le_pow_right\u2080 one_le_two\n    have : (4 : \u2124) \u2264 a := mod_cast ha\n    zify\n    calc (a : \u2124) + 17\n    _ \u2264 a + 4 * (4 * 4 - 1) := by gcongr; norm_num\n    _ \u2264 a + a * (a * a - 1) := by gcongr\n    _ = a ^ 3 := by ring", "proofType": "tactic", "proofLengthLines": 19, "proofLengthTokens": 710}}
{"srcContext": "/-\nCopyright (c) 2024 James Sundstrom. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: James Sundstrom\n-/\nimport Mathlib.MeasureTheory.Constructions.BorelSpace.Metric\n\n/-!\n# Annulus\n\nIn this file we define an annulus in a pseudometric space `X` to be a set consisting of all `y`\nsuch that `dist x y` lies in an interval between `r` and `R`. An annulus is defined for each type\nof interval (`Ioo`, `Ioc`, etc.) with a parallel naming scheme, except that we do not define annuli\nfor `Iio` and `Ico`, as they would be balls.\n\nWe also define `EAnnulus` similarly using `edist` instead of `dist`.\n\n## Tags\n\nannulus, eannulus\n-/\n\nopen Set Metric ENNReal\n\nvariable {X : Type*} [PseudoMetricSpace X]\n\nnamespace Set\n\nnamespace Annulus\n\ndef oo (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d) := {y | dist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d) := {y | dist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d) := {y | dist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d) := {y | dist x y \u2208 Ici r}\n\nlemma oo_eq {x : X} {r R : \u211d} : oo x r R = ball x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oo, dist_comm, and_comm]\n\nlemma oc_eq {x : X} {r R : \u211d} : oc x r R = closedBall x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oc, dist_comm, and_comm]\n\nlemma co_eq {x : X} {r R : \u211d} : co x r R = ball x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [co, dist_comm, and_comm]\n\nlemma cc_eq {x : X} {r R : \u211d} : cc x r R = closedBall x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [cc, dist_comm, and_comm]\n\nlemma oi_eq {x : X} {r : \u211d} : oi x r = (closedBall x r)\u1d9c := by\n  ext; simp [oi, dist_comm]\n\nlemma ci_eq {x : X} {r : \u211d} : ci x r = (ball x r)\u1d9c := by\n  ext; simp [ci, dist_comm]\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : co x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma co_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : co x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\nlemma cc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : cc x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma cc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : cc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\n@[simp]\nlemma oc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    oc x r r' \u222a oo x r' R = oo x r R := by\n  ext; simp_rw [oc, oo, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioo_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    oc x r r' \u222a oc x r' R = oc x r R := by\n  ext; simp_rw [oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_co {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a co x r' R = oo x r R := by\n  ext; simp_rw [oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ico_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a cc x r' R = oc x r R := by\n  ext; simp_rw [oo, cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Icc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    cc x r r' \u222a oo x r' R = co x r R := by\n  ext; simp_rw [cc, oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioo_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    cc x r r' \u222a oc x r' R = cc x r R := by\n  ext; simp_rw [cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_co {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a co x r' R = co x r R := by\n  ext; simp_rw [co, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ico_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a cc x r' R = cc x r R := by\n  ext; simp_rw [co, cc, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Icc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : oc x r R \u222a oi x R = oi x r := by\n  ext; simp_rw [oc, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioi_eq_Ioi h]\n\n@[simp]\nlemma oo_union_ci {x : X} {r R : \u211d} (h : r < R) :\n    oo x r R \u222a ci x R = oi x r := by\n  ext; simp_rw [oo, ci, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ici_eq_Ioi h]\n\n@[simp]\nlemma cc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : cc x r R \u222a oi x R = ci x r := by\n  ext; simp_rw [cc, oi, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioi_eq_Ici h]\n\n@[simp]\nlemma co_union_ci {x : X} {r R : \u211d} (h : r \u2264 R) : co x r R \u222a ci x R = ci x r := by\n  ext; simp_rw [co, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ici_eq_Ici h]\n\n\nvariable [MeasurableSpace X] [OpensMeasurableSpace X]\n\n@[measurability]\nlemma measurableSet_oo {x : X} {r R : \u211d} : MeasurableSet (oo x r R) := by\n  rw [oo_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oc {x : X} {r R : \u211d} : MeasurableSet (oc x r R) := by\n rw [oc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_co {x : X} {r R : \u211d} : MeasurableSet (co x r R) := by\n  rw [co_eq]; measurability\n\n@[measurability]\nlemma measurableSet_cc {x : X} {r R : \u211d} : MeasurableSet (cc x r R) := by\n rw [cc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oi {x : X} {r : \u211d} : MeasurableSet (oi x r) := by\n  rw [oi_eq]; measurability\n\n@[measurability]\nlemma measurableSet_ci {x : X} {r : \u211d} : MeasurableSet (ci x r) := by\n  rw [ci_eq]; measurability\n\nend Annulus\n\nnamespace EAnnulus\n\ndef oo (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ici r}\n\n\nlemma oo_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oo x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oo x r R := by\n  simp_rw [oo, Annulus.oo, edist_dist, mem_Ioo, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma oc_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [oc, Annulus.oc, edist_dist, mem_Ioc, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  \u00b7 have R_le_r := (lt_of_lt_of_le (lt_of_not_ge hR) hr).le\n    rw [Annulus.oc_eq_empty R_le_r]\n    refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n    exact not_le_of_gt (lt_of_le_of_lt (ENNReal.ofReal_le_ofReal R_le_r) hy.1) hy.2\n\nlemma co_eq_annulus {x : X} {r R : \u211d} :\n    co x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.co x r R := by\n  simp_rw [co, Annulus.co, edist_dist, mem_Ico, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma cc_eq_annulus {x : X} {r R : \u211d} (h : r > 0 \u2228 R \u2265 0) :\n    cc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.cc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [cc, Annulus.cc, edist_dist, mem_Icc, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  have r0 := h.resolve_right hR\n  have R_lt_r := (lt_of_not_ge hR).trans r0\n  rw [Annulus.cc_eq_empty R_lt_r]\n  refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n  exact not_le_of_gt ((ENNReal.ofReal_lt_ofReal_iff r0).mpr R_lt_r) (hy.1.trans hy.2)\n\nlemma oi_eq_annulus {x : X} {r : \u211d} (hr : r \u2265 0) : oi x (ENNReal.ofReal r) = Annulus.oi x r := by\n  simp_rw [oi, Annulus.oi, edist_dist, mem_Ioi, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr]\n\nlemma ci_eq_annulus {x : X} {r : \u211d} : ci x (ENNReal.ofReal r) = Annulus.ci x r := by\n  simp_rw [ci, Annulus.ci, edist_dist, mem_Ici, ENNReal.ofReal_le_ofReal_iff dist_nonneg]\n\n\nlemma oo_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oo x r R = ball x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oo, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma oc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oc x r R = closedBall x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oc, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma co_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    co x r R = ball x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [co, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma cc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    cc x r R = closedBall x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [cc, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma oi_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : oi x r = (closedBall x r.toReal)\u1d9c := by\n  ext; simp [oi, edist_dist, dist_comm, lt_ofReal_iff_toReal_lt hr.ne]\n\nlemma ci_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : ci x r = (ball x r.toReal)\u1d9c := by\n  ext; simp [ci, edist_dist, dist_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg]\n\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n@[simp]\nlemma cc_top_eq_empty {x : X} {R : \u211d\u22650\u221e} : cc x \u22a4 R = \u2205 :=\n  eq_empty_of_forall_not_mem (fun y hy \u21a6 (edist_ne_top x y) (top_le_iff.mp hy.1))\n\n@[simp]\nlemma oi_eq_empty {x : X} : oi x \u22a4 = \u2205 := by simp [oi, edist_dist]\n\n@[simp]\nlemma ci_eq_empty {x : X} : ci x \u22a4 = \u2205 := by simp [ci, edist_dist]\n\n\nlemma oo_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) :\n    oo x r \u22a4 = (closedBall x r.toReal)\u1d9c := by\n  ext; simpa [oo, edist_dist, dist_comm] using lt_ofReal_iff_toReal_lt hr.ne\n\nlemma oc_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) :\n    oc x r \u22a4 = (closedBall x r.toReal)\u1d9c := by\n  ext; simpa [oc, edist_dist, dist_comm] using lt_ofReal_iff_toReal_lt hr.ne\n\nlemma co_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : co x r \u22a4 = (ball x r.toReal)\u1d9c := by\n  ext; simpa [co, edist_dist, dist_comm] using le_ofReal_iff_toReal_le hr.ne dist_nonneg\n\nlemma cc_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : cc x r \u22a4 = (ball x r.toReal)\u1d9c := by\n  ext; simpa [cc, edist_dist, dist_comm] using le_ofReal_iff_toReal_le hr.ne dist_nonneg\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) : co x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma co_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : co x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\nlemma cc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) : cc x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma cc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : cc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\n@[simp]\nlemma oc_union_oo {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    oc x r r' \u222a oo x r' R = oo x r R := by\n  ext; simp_rw [oc, oo, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioo_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oc {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    oc x r r' \u222a oc x r' R = oc x r R := by\n  ext; simp_rw [oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_co {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a co x r' R = oo x r R := by\n  ext; simp_rw [oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ico_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_cc {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a cc x r' R = oc x r R := by\n  ext; simp_rw [oo, cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Icc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oo {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    cc x r r' \u222a oo x r' R = co x r R := by\n  ext; simp_rw [cc, oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioo_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oc {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    cc x r r' \u222a oc x r' R = cc x r R := by\n  ext; simp_rw [cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_co {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a co x r' R = co x r R := by\n  ext; simp_rw [co, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ico_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_cc {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a cc x r' R = cc x r R := by\n  ext; simp_rw [co, cc, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Icc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oi {x : X} {r R : \u211d\u22650\u221e} (h : r \u2264 R) : oc x r R \u222a oi x R = oi x r := by\n  ext; simp_rw [oc, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioi_eq_Ioi h]\n\n@[simp]\nlemma oo_union_ci {x : X} {r R : \u211d\u22650\u221e} (h : r < R) :\n    oo x r R \u222a ci x R = oi x r := by\n  ext; simp_rw [oo, ci, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ici_eq_Ioi h]\n\n@[simp]\nlemma cc_union_oi {x : X} {r R : \u211d\u22650\u221e} (h : r \u2264 R) : cc x r R \u222a oi x R = ci x r := by\n  ext; simp_rw [cc, oi, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioi_eq_Ici h]\n\n", "theoremStatement": "@[simp]\nlemma co_union_ci {x : X} {r R : \u211d\u22650\u221e} (h : r \u2264 R) : co x r R \u222a ci x R = ci x r ", "theoremName": "Set.EAnnulus.co_union_ci", "fileCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "theoremCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "file": "carleson/Carleson/ToMathlib/Annulus.lean", "module": "Carleson.ToMathlib.Annulus", "jsonFile": "Carleson.ToMathlib.Annulus.jsonl", "positionMetadata": {"lineInFile": 509, "tokenPositionInFile": 20281, "theoremPositionInFile": 122}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 45}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  ext; simp_rw [co, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ici_eq_Ici h]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 91}}
{"srcContext": "import Carleson.Forest\nimport Carleson.ToMathlib.HardyLittlewood\nimport Carleson.ToMathlib.BoundedCompactSupport\nimport Carleson.ToMathlib.Misc\nimport Carleson.Psi\n\nopen ShortVariables TileStructure\nvariable {X : Type*} {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102} {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X}\n  [MetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] [TileStructure Q D \u03ba S o]\n  {n j j' : \u2115} {t : Forest X n} {u u\u2081 u\u2082 p : \ud835\udd13 X} {x x' : X} {\ud835\udd16 : Set (\ud835\udd13 X)}\n  {f f\u2081 f\u2082 g g\u2081 g\u2082 : X \u2192 \u2102} {I J J' L : Grid X}\nvariable {E' : Type*} [NormedAddCommGroup E'] [NormedSpace \u211d E']\n\nnoncomputable section\n\nopen Set MeasureTheory Metric Function Complex Bornology TileStructure Classical Filter\nopen scoped NNReal ENNReal ComplexConjugate\n\nnamespace TileStructure.Forest\n\n/-! ## Section 7.1 and Lemma 7.1.3 -/\n\nvariable (t) in\n/-- The definition `\u03c3(u, x)` given in Section 7.1.\nWe may assume `u \u2208 t` whenever proving things about this definition. -/\ndef \u03c3 (u : \ud835\udd13 X) (x : X) : Finset \u2124 := .image \ud835\udd30 { p | p \u2208 t u \u2227 x \u2208 E p }\n\nvariable (t) in\nprivate lemma exists_p_of_mem_\u03c3 (u : \ud835\udd13 X) (x : X) {s : \u2124} (hs : s \u2208 t.\u03c3 u x) :\n    \u2203 p \u2208 t.\ud835\udd17 u, x \u2208 E p \u2227 \ud835\udd30 p = s := by\n  have \u27e8p, hp\u27e9 := Finset.mem_image.mp hs\n  simp only [mem_\ud835\udd17, Finset.mem_filter] at hp\n  use p, hp.1.2.1, hp.1.2.2, hp.2\n\n/- \\overline{\u03c3} from the blueprint. -/\nvariable (t) in\ndef \u03c3Max (u : \ud835\udd13 X) (x : X) (h\u03c3 : (t.\u03c3 u x).Nonempty) : \u2124 :=\n  t.\u03c3 u x |>.max' h\u03c3\n\n/- \\underline{\u03c3} from the blueprint. -/\nvariable (t) in\ndef \u03c3Min (u : \ud835\udd13 X) (x : X) (h\u03c3 : (t.\u03c3 u x).Nonempty) : \u2124 :=\n  t.\u03c3 u x |>.min' h\u03c3\n\nvariable (t) in\nprivate lemma \u03c3Max_mem_\u03c3 (u : \ud835\udd13 X) (x : X) (h\u03c3 : (t.\u03c3 u x).Nonempty) : \u03c3Max t u x h\u03c3 \u2208 t.\u03c3 u x :=\n  (t.\u03c3 u x).max'_mem h\u03c3\n\n/-- The definition of `\ud835\udcd9\u2080(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcd9\u2080 (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {J : Grid X | s J = -S \u2228 \u2200 p \u2208 \ud835\udd16, \u00ac(\ud835\udcd8 p : Set X) \u2286 ball (c J) (100 * D ^ (s J + 1))}\n\n/-- The definition of `\ud835\udcd9(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcd9 (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {x | Maximal (\u00b7 \u2208 \ud835\udcd9\u2080 \ud835\udd16) x}\n\nlemma \ud835\udcd9_subset_\ud835\udcd9\u2080 {\ud835\udd16 : Set (\ud835\udd13 X)} : \ud835\udcd9 \ud835\udd16 \u2286 \ud835\udcd9\u2080 \ud835\udd16 := sep_subset ..\n\nlemma pairwiseDisjoint_\ud835\udcd9 : (\ud835\udcd9 \ud835\udd16).PairwiseDisjoint (fun I \u21a6 (I : Set X)) := fun I mI J mJ hn \u21a6 by\n  have : IsAntichain (\u00b7 \u2264 \u00b7) (\ud835\udcd9 \ud835\udd16) := setOf_maximal_antichain _\n  exact (le_or_ge_or_disjoint.resolve_left (this mI mJ hn)).resolve_left (this mJ mI hn.symm)\n\n/-- The definition of `\ud835\udcdb\u2080(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcdb\u2080 (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {L : Grid X | s L = -S \u2228 (\u2203 p \u2208 \ud835\udd16, L \u2264 \ud835\udcd8 p) \u2227 \u2200 p \u2208 \ud835\udd16, \u00ac\ud835\udcd8 p \u2264 L}\n\n/-- The definition of `\ud835\udcdb(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcdb (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {x | Maximal (\u00b7 \u2208 \ud835\udcdb\u2080 \ud835\udd16) x}\n\nlemma \ud835\udcdb_subset_\ud835\udcdb\u2080 {\ud835\udd16 : Set (\ud835\udd13 X)} : \ud835\udcdb \ud835\udd16 \u2286 \ud835\udcdb\u2080 \ud835\udd16 := sep_subset ..\n\nprivate lemma s_le_s_of_mem_\ud835\udcdb {\ud835\udd16 : Set (\ud835\udd13 X)} {L : Grid X} (hL : L \u2208 \ud835\udcdb \ud835\udd16)\n    {p : \ud835\udd13 X} (hp : p \u2208 \ud835\udd16) (hpL : \u00ac Disjoint (\ud835\udcd8 p : Set X) (L : Set X)) : s L \u2264 s (\ud835\udcd8 p) := by\n  simp only [\ud835\udcdb, \ud835\udcdb\u2080, Grid.le_def, not_and, not_le, and_imp] at hL\n  rcases hL.1 with h | h\n  \u00b7 exact h \u25b8 (range_s_subset \u27e8\ud835\udcd8 p, rfl\u27e9).1\n  \u00b7 by_contra!\n    exact lt_asymm this <| h.2 p hp <| (GridStructure.fundamental_dyadic' this.le).resolve_right hpL\n\n", "theoremStatement": "private lemma subset_of_mem_\ud835\udcdb {\ud835\udd16 : Set (\ud835\udd13 X)} {L : Grid X} (hL : L \u2208 \ud835\udcdb \ud835\udd16) {p : \ud835\udd13 X}\n    (hp : p \u2208 \ud835\udd16) (hpL : \u00ac Disjoint (\ud835\udcd8 p : Set X) (L : Set X)) : (L : Set X) \u2286 (\ud835\udcd8 p : Set X) ", "theoremName": "TileStructure.Forest.subset_of_mem_\ud835\udcdb", "fileCreated": {"commit": "5e49c3692f6d7344434caa7eea5f412f0ee35863", "date": "2024-09-27"}, "theoremCreated": {"commit": "3298f748e9eb26a242da5ee38cb50dc55e604935", "date": "2025-01-08"}, "file": "carleson/Carleson/ForestOperator/PointwiseEstimate.lean", "module": "Carleson.ForestOperator.PointwiseEstimate", "jsonFile": "Carleson.ForestOperator.PointwiseEstimate.jsonl", "positionMetadata": {"lineInFile": 81, "tokenPositionInFile": 3073, "theoremPositionInFile": 13}, "dependencyMetadata": {"inFilePremises": null, "numInFilePremises": null, "repositoryPremises": null, "numRepositoryPremises": null, "numPremises": null}, "proofMetadata": {"hasProof": true, "proof": ":=\n  GridStructure.fundamental_dyadic' (s_le_s_of_mem_\ud835\udcdb hL hp hpL) |>.resolve_right fun h \u21a6 hpL h.symm", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 102}}
{"srcContext": "import Mathlib.MeasureTheory.Integral.MeanInequalities\nimport Mathlib.MeasureTheory.Integral.Layercake\nimport Mathlib.MeasureTheory.Integral.Lebesgue\nimport Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar\nimport Mathlib.Analysis.SpecialFunctions.Pow.Integral\nimport Carleson.ToMathlib.ENorm\nimport Carleson.ToMathlib.Misc\n\nnoncomputable section\n\nopen NNReal ENNReal NormedSpace MeasureTheory Set Filter Topology Function\n\nsection move\n\n\nvariable {\u03b1 \ud835\udd5c E : Type*} {m : MeasurableSpace \u03b1}\n  {\u03bc : Measure \u03b1} [NontriviallyNormedField \ud835\udd5c]\n  [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]\n  {p : \u211d\u22650\u221e}\n\n-- todo: move/rename/and perhaps reformulate in terms of \u2016.\u2016\u2091\nlemma ENNNorm_absolute_homogeneous {c : \ud835\udd5c} (z : E) : ofNNReal \u2016c \u2022 z\u2016\u208a = \u2191\u2016c\u2016\u208a * \u2191\u2016z\u2016\u208a :=\n  (toReal_eq_toReal_iff' coe_ne_top coe_ne_top).mp (norm_smul c z)\n\nlemma ENNNorm_add_le (y z : E) : ofNNReal \u2016y + z\u2016\u208a \u2264 \u2191\u2016y\u2016\u208a + \u2191\u2016z\u2016\u208a :=\n  (toReal_le_toReal coe_ne_top coe_ne_top).mp (nnnorm_add_le ..)\n\nlemma measure_mono_ae' {A B : Set \u03b1} (h : \u03bc (B \\ A) = 0) :\n    \u03bc B \u2264 \u03bc A := by\n  apply measure_mono_ae\n  change \u03bc {x | \u00ac B x \u2264 A x} = 0\n  simp only [le_Prop_eq, Classical.not_imp]\n  exact h\n\n\nlemma eLpNormEssSup_toReal_le {f : \u03b1 \u2192 \u211d\u22650\u221e} :\n    eLpNormEssSup (ENNReal.toReal \u2218 f) \u03bc \u2264 eLpNormEssSup f \u03bc := by\n  simp_rw [eLpNormEssSup, enorm_eq_self]\n  apply essSup_mono_ae\n  apply Eventually.of_forall\n  simp [implies_true]\n\nlemma eLpNormEssSup_toReal_eq {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : \u2200\u1d50 x \u2202\u03bc, f x \u2260 \u221e) :\n    eLpNormEssSup (ENNReal.toReal \u2218 f) \u03bc = eLpNormEssSup f \u03bc := by\n  simp_rw [eLpNormEssSup, enorm_eq_self]\n  apply essSup_congr_ae\n  filter_upwards [hf] with x hx\n  simp [hx]\n\nlemma eLpNorm'_toReal_le {f : \u03b1 \u2192 \u211d\u22650\u221e} {p : \u211d} (hp : 0 \u2264 p) :\n    eLpNorm' (ENNReal.toReal \u2218 f) p \u03bc \u2264 eLpNorm' f p \u03bc := by\n  simp_rw [eLpNorm', enorm_eq_self]\n  gcongr\n  simp\n\nlemma eLpNorm'_toReal_eq {f : \u03b1 \u2192 \u211d\u22650\u221e} {p : \u211d} (hf : \u2200\u1d50 x \u2202\u03bc, f x \u2260 \u221e) :\n    eLpNorm' (ENNReal.toReal \u2218 f) p \u03bc = eLpNorm' f p \u03bc := by\n  simp_rw [eLpNorm', enorm_eq_self]\n  congr 1\n  apply lintegral_congr_ae\n  filter_upwards [hf] with x hx\n  simp [hx]\n\nlemma eLpNorm_toReal_le {f : \u03b1 \u2192 \u211d\u22650\u221e} :\n    eLpNorm (ENNReal.toReal \u2218 f) p \u03bc \u2264 eLpNorm f p \u03bc := by\n  simp_rw [eLpNorm]\n  split_ifs\n  \u00b7 rfl\n  \u00b7 exact eLpNormEssSup_toReal_le\n  \u00b7 exact eLpNorm'_toReal_le toReal_nonneg\n\nlemma eLpNorm_toReal_eq {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : \u2200\u1d50 x \u2202\u03bc, f x \u2260 \u221e) :\n    eLpNorm (ENNReal.toReal \u2218 f) p \u03bc = eLpNorm f p \u03bc := by\n  simp_rw [eLpNorm]\n  split_ifs\n  \u00b7 rfl\n  \u00b7 exact eLpNormEssSup_toReal_eq hf\n  \u00b7 exact eLpNorm'_toReal_eq hf\n\nend move\n\nnamespace MeasureTheory\n\nvariable {\u03b1 \u03b1' \u03b5 \u03b5\u2081 \u03b5\u2082 \u03b5\u2083 \ud835\udd5c E E\u2081 E\u2082 E\u2083 : Type*} {m : MeasurableSpace \u03b1} {m : MeasurableSpace \u03b1'}\n  {p p' q : \u211d\u22650\u221e} {c : \u211d\u22650}\n  {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b1'} [NontriviallyNormedField \ud835\udd5c]\n  [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]\n  [NormedAddCommGroup E\u2081] [NormedSpace \ud835\udd5c E\u2081]\n  [NormedAddCommGroup E\u2082] [NormedSpace \ud835\udd5c E\u2082]\n  [NormedAddCommGroup E\u2083] [NormedSpace \ud835\udd5c E\u2083]\n  (L : E\u2081 \u2192L[\ud835\udd5c] E\u2082 \u2192L[\ud835\udd5c] E\u2083)\n  {t s x y : \u211d\u22650\u221e}\n  {T : (\u03b1 \u2192 \u03b5\u2081) \u2192 (\u03b1' \u2192 \u03b5\u2082)}\n\nsection ENorm\n\nvariable [ENorm \u03b5] {f g g\u2081 g\u2082 : \u03b1 \u2192 \u03b5}\n\n/- Proofs for this file can be found in\nFolland, Real Analysis. Modern Techniques and Their Applications, section 6.3. -/\n\n/-! # The distribution function `d_f` -/\n\n/-- The distribution function of a function `f`.\nNote that unlike the notes, we also define this for `t = \u221e`.\nNote: we also want to use this for functions with codomain `\u211d\u22650\u221e`, but for those we just write\n`\u03bc { x | t < f x }` -/\ndef distribution (f : \u03b1 \u2192 \u03b5) (t : \u211d\u22650\u221e) (\u03bc : Measure \u03b1) : \u211d\u22650\u221e :=\n  \u03bc { x | t < \u2016f x\u2016\u2091 }\n\n@[gcongr]\nlemma distribution_mono_right (h : t \u2264 s) : distribution f s \u03bc \u2264 distribution f t \u03bc :=\n  measure_mono fun _ a \u21a6 lt_of_le_of_lt h a\n\nlemma distribution_mono_right' : (Antitone (fun t \u21a6 distribution f t \u03bc)) :=\n  fun _ _ h \u21a6 distribution_mono_right h\n\n@[measurability, fun_prop]\nlemma distribution_measurable\u2080 : Measurable (fun t \u21a6 distribution f t \u03bc) :=\n  Antitone.measurable (distribution_mono_right' (f := f) (\u03bc := \u03bc))\n\n@[measurability, fun_prop]\nlemma distribution_measurable {g : \u03b1' \u2192 \u211d\u22650\u221e} (hg : Measurable g) :\n    Measurable (fun y : \u03b1' \u21a6 distribution f (g y) \u03bc) := by\n  fun_prop\n\nlemma distribution_toReal_le {f : \u03b1 \u2192 \u211d\u22650\u221e} :\n    distribution (ENNReal.toReal \u2218 f) t \u03bc \u2264 distribution f t \u03bc := by\n  simp_rw [distribution]\n  apply measure_mono\n  simp_rw [comp_apply, enorm_eq_self, setOf_subset_setOf]\n  intro x hx\n  exact hx.trans_le enorm_toReal_le\n\nlemma distribution_toReal_eq {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : \u2200\u1d50 x \u2202\u03bc, f x \u2260 \u221e) :\n    distribution (ENNReal.toReal \u2218 f) t \u03bc = distribution f t \u03bc := by\n  refine measure_congr (.set_eq ?_)\n  filter_upwards [hf] with x hx\n  simp [hx]\n\nlemma distribution_add_le_of_enorm {A : \u211d\u22650\u221e}\n    (h : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016\u2091 \u2264 A * (\u2016g\u2081 x\u2016\u2091 + \u2016g\u2082 x\u2016\u2091)) :\n    distribution f (A * (t + s)) \u03bc \u2264 distribution g\u2081 t \u03bc + distribution g\u2082 s \u03bc := by\n  unfold distribution\n  have h\u2081 : \u03bc ({x | A * (t + s) < \u2016f x\u2016\u2091} \\\n      ({x | t < \u2016g\u2081 x\u2016\u2091} \u222a {x | s < \u2016g\u2082 x\u2016\u2091})) = 0 := by\n    apply measure_mono_null ?_ h\n    intro x\n    simp only [mem_diff, mem_setOf_eq, mem_union, not_or, not_lt, mem_compl_iff, not_le, and_imp]\n    intro h\u2081 h\u2082 h\u2083\n    refine lt_of_le_of_lt ?_ h\u2081\n    gcongr\n  calc\n    \u03bc {x | A * (t + s) < \u2016f x\u2016\u2091}\n      \u2264 \u03bc ({x | t < \u2016g\u2081 x\u2016\u2091} \u222a {x | s < \u2016g\u2082 x\u2016\u2091}) := measure_mono_ae' h\u2081\n    _ \u2264 \u03bc {x | t < \u2016g\u2081 x\u2016\u2091} + \u03bc {x | s < \u2016g\u2082 x\u2016\u2091} := measure_union_le _ _\n\nlemma approx_above_superset (t\u2080 : \u211d\u22650\u221e) :\n    \u22c3 n, (fun n : \u2115 \u21a6 {x | t\u2080 + (\u2191n)\u207b\u00b9 < \u2016f x\u2016\u2091}) n = {x | t\u2080 < \u2016f x\u2016\u2091} := by\n  ext y\n  constructor <;> intro h\n  \u00b7 obtain \u27e8n, wn\u27e9 := exists_exists_eq_and.mp h\n    calc\n      t\u2080 \u2264 t\u2080 + (\u2191n)\u207b\u00b9 := le_self_add\n      _  < \u2016f y\u2016\u2091      := wn\n  \u00b7 have h\u2081 : Iio (\u2016f y\u2016\u2091 - t\u2080) \u2208 \ud835\udcdd 0 := Iio_mem_nhds (tsub_pos_of_lt h)\n    have h\u2082 := ENNReal.tendsto_inv_nat_nhds_zero h\u2081\n    simp only [mem_map, mem_atTop_sets, mem_preimage, mem_Iio] at h\u2082\n    rcases h\u2082 with \u27e8n, wn\u27e9\n    simp only [mem_iUnion, mem_setOf_eq]\n    use n\n    exact lt_tsub_iff_left.mp (wn n (Nat.le_refl n))\n\nlemma tendsto_measure_iUnion_distribution (t\u2080 : \u211d\u22650\u221e) :\n    Filter.Tendsto (\u21d1\u03bc \u2218 (fun n : \u2115 \u21a6 {x | t\u2080 + (\u2191n)\u207b\u00b9 < \u2016f x\u2016\u2091}))\n      Filter.atTop (nhds (\u03bc ({x | t\u2080 < \u2016f x\u2016\u2091}))) := by\n  rw [\u2190 approx_above_superset]\n  apply tendsto_measure_iUnion_atTop\n  intro a b h x h\u2081\n  calc\n    _ \u2264 t\u2080 + (\u2191a)\u207b\u00b9 := by gcongr\n    _ < _ := h\u2081\n\nlemma select_neighborhood_distribution (t\u2080 : \u211d\u22650\u221e) (l : \u211d\u22650\u221e)\n    (hu : l < distribution f t\u2080 \u03bc) :\n    \u2203 n : \u2115, l < distribution f (t\u2080 + (\u2191n)\u207b\u00b9) \u03bc := by\n  have h\u2081 : Ioi l \u2208 (\ud835\udcdd (distribution f t\u2080 \u03bc)) := Ioi_mem_nhds hu\n  have h\u2082 := (tendsto_measure_iUnion_distribution t\u2080) h\u2081\n  simp only [mem_map, mem_atTop_sets, mem_preimage, comp_apply, mem_Ioi] at h\u2082\n  rcases h\u2082 with \u27e8n, wn\u27e9\n  use n; exact wn n (Nat.le_refl n)\n\nlemma continuousWithinAt_distribution (t\u2080 : \u211d\u22650\u221e) :\n    ContinuousWithinAt (distribution f \u00b7 \u03bc) (Ioi t\u2080) t\u2080 := by\n  rcases (eq_top_or_lt_top t\u2080) with t\u2080top | t\u2080nottop\n  \u00b7 rw [t\u2080top]\n    apply continuousWithinAt_of_not_mem_closure\n    simp\n  \u00b7 unfold ContinuousWithinAt\n    rcases (eq_top_or_lt_top (distribution f t\u2080 \u03bc)) with db_top | db_not_top\n    -- Case: distribution f t\u2080 \u03bc = \u22a4\n    \u00b7 simp only\n      rw [db_top, ENNReal.tendsto_nhds_top_iff_nnreal]\n      intro b\n      have h\u2080 : \u2203 n : \u2115, \u2191b < distribution f (t\u2080 + (\u2191n)\u207b\u00b9) \u03bc :=\n        select_neighborhood_distribution _ _ (db_top \u25b8 coe_lt_top)\n      rcases h\u2080 with \u27e8n, wn\u27e9\n      refine eventually_mem_set.mpr (mem_inf_iff_superset.mpr \u27e8Iio (t\u2080 + (\u2191n)\u207b\u00b9), ?_, ?_\u27e9)\n      \u00b7 exact Iio_mem_nhds (lt_add_right t\u2080nottop.ne_top\n          (ENNReal.inv_ne_zero.mpr (ENNReal.natCast_ne_top n)))\n      \u00b7 exact \u27e8Ioi t\u2080, by simp, fun z h\u2081 \u21a6 wn.trans_le (distribution_mono_right (le_of_lt h\u2081.1))\u27e9\n    -- Case: distribution f t\u2080 \u03bc < \u22a4\n    \u00b7 refine (ENNReal.tendsto_nhds db_not_top.ne_top).mpr fun \u03b5 \u03b5_gt_0 \u21a6\n        eventually_mem_set.mpr (mem_inf_iff_superset.mpr ?_)\n      rcases eq_zero_or_pos (distribution f t\u2080 \u03bc) with db_zero | db_not_zero\n      -- Case: distribution f t\u2080 \u03bc = 0\n      \u00b7 use Ico 0 (t\u2080 + 1)\n        constructor\n        \u00b7 refine IsOpen.mem_nhds isOpen_Ico_zero ?_\n          simp only [mem_Ico, zero_le, lt_add_right t\u2080nottop.ne_top one_ne_zero, and_self]\n        \u00b7 use Ioi t\u2080\n          refine \u27e8by simp, fun z hz \u21a6 ?_\u27e9\n          rw [db_zero]\n          simp only [ge_iff_le, zero_le, tsub_eq_zero_of_le, zero_add]\n          have h\u2082 : distribution f z \u03bc \u2264 distribution f t\u2080 \u03bc :=\n            distribution_mono_right (le_of_lt hz.2)\n          rw [db_zero] at h\u2082\n          change Icc 0 \u03b5 (distribution f z \u03bc)\n          rw [nonpos_iff_eq_zero.mp h\u2082]\n          exact \u27e8zero_le 0, zero_le \u03b5\u27e9\n      -- Case: 0 < distribution f t\u2080 \u03bc\n      \u00b7 obtain \u27e8n, wn\u27e9 :=\n          select_neighborhood_distribution t\u2080 _ (ENNReal.sub_lt_self db_not_top.ne_top\n              (ne_of_lt db_not_zero).symm (ne_of_lt \u03b5_gt_0).symm)\n        use Iio (t\u2080 + (\u2191n)\u207b\u00b9)\n        constructor\n        \u00b7 exact Iio_mem_nhds (lt_add_right t\u2080nottop.ne_top\n            (ENNReal.inv_ne_zero.mpr (ENNReal.natCast_ne_top n)))\n        \u00b7 use Ioi t\u2080\n          refine \u27e8by simp, fun z h \u21a6 \u27e8?_, ?_\u27e9\u27e9\n          \u00b7 calc\n              distribution f t\u2080 \u03bc - \u03b5\n                \u2264 distribution f (t\u2080 + (\u2191n)\u207b\u00b9) \u03bc := le_of_lt wn\n              _ \u2264 distribution f z \u03bc             := distribution_mono_right (le_of_lt h.1)\n          \u00b7 calc\n              distribution f z \u03bc\n                \u2264 distribution f t\u2080 \u03bc := distribution_mono_right (le_of_lt h.2)\n              _ \u2264 distribution f t\u2080 \u03bc + \u03b5 := le_self_add\n\n/- The lemmas below are almost already in Mathlib, see\n`MeasureTheory.lintegral_rpow_eq_lintegral_meas_lt_mul`. -/\n\n-- /-- The layer-cake theorem, or Cavalieri's principle for functions into `\u211d\u22650\u221e` -/\n-- lemma lintegral_norm_pow_eq_measure_lt {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : AEMeasurable f \u03bc)\n--     {p : \u211d} (hp : 1 \u2264 p) :\n--     \u222b\u207b x, (f x) ^ p \u2202\u03bc =\n--     \u222b\u207b t in Ioi (0 : \u211d), .ofReal (p * t ^ (p - 1)) * \u03bc { x | ENNReal.ofReal t < f x } := by\n--   sorry\n\n/-- The weak L^p norm of a function, for `p < \u221e` -/\ndef wnorm' (f : \u03b1 \u2192 \u03b5) (p : \u211d) (\u03bc : Measure \u03b1) : \u211d\u22650\u221e :=\n  \u2a06 t : \u211d\u22650, t * distribution f t \u03bc ^ (p : \u211d)\u207b\u00b9\n\nlemma wnorm'_zero (f : \u03b1 \u2192 \u03b5) (\u03bc : Measure \u03b1) : wnorm' f 0 \u03bc = \u221e := by\n  simp only [wnorm', GroupWithZero.inv_zero, ENNReal.rpow_zero, mul_one, iSup_eq_top]\n  refine fun b hb \u21a6 \u27e8b.toNNReal + 1, ?_\u27e9\n  rw [coe_add, ENNReal.coe_one, coe_toNNReal hb.ne_top]\n  exact lt_add_right hb.ne_top one_ne_zero\n\nlemma wnorm'_toReal_le {f : \u03b1 \u2192 \u211d\u22650\u221e} {p : \u211d} (hp : 0 \u2264 p) :\n    wnorm' (ENNReal.toReal \u2218 f) p \u03bc \u2264 wnorm' f p \u03bc := by\n  refine iSup_mono fun x \u21a6 ?_\n  gcongr\n  exact distribution_toReal_le\n\nlemma wnorm'_toReal_eq {f : \u03b1 \u2192 \u211d\u22650\u221e} {p : \u211d} (hf : \u2200\u1d50 x \u2202\u03bc, f x \u2260 \u221e) :\n    wnorm' (ENNReal.toReal \u2218 f) p \u03bc = wnorm' f p \u03bc := by\n  simp_rw [wnorm', distribution_toReal_eq hf]\n\n/-- The weak L^p norm of a function. -/\ndef wnorm (f : \u03b1 \u2192 \u03b5) (p : \u211d\u22650\u221e) (\u03bc : Measure \u03b1) : \u211d\u22650\u221e :=\n  if p = \u221e then eLpNormEssSup f \u03bc else wnorm' f (ENNReal.toReal p) \u03bc\n\nlemma wnorm_zero : wnorm f 0 \u03bc = \u221e := by\n  simp [wnorm, wnorm'_zero]\n\n@[simp]\nlemma wnorm_top : wnorm f \u22a4 \u03bc = eLpNormEssSup f \u03bc := by simp [wnorm]\n\nlemma wnorm_coe {p : \u211d\u22650} : wnorm f p \u03bc = wnorm' f p \u03bc := by simp [wnorm]\n\nlemma wnorm_ofReal {p : \u211d} (hp : 0 \u2264 p) : wnorm f (.ofReal p) \u03bc = wnorm' f p \u03bc := by\n  simp [wnorm, hp]\n\nlemma wnorm_toReal_le {f : \u03b1 \u2192 \u211d\u22650\u221e} {p : \u211d\u22650\u221e} :\n    wnorm (ENNReal.toReal \u2218 f) p \u03bc \u2264 wnorm f p \u03bc := by\n  induction p\n  \u00b7 simp [eLpNormEssSup_toReal_le]\n  exact wnorm'_toReal_le toReal_nonneg\n\nlemma wnorm_toReal_eq {f : \u03b1 \u2192 \u211d\u22650\u221e} {p : \u211d\u22650\u221e} (hf : \u2200\u1d50 x \u2202\u03bc, f x \u2260 \u221e) :\n    wnorm (ENNReal.toReal \u2218 f) p \u03bc = wnorm f p \u03bc := by\n  simp_rw [wnorm, eLpNormEssSup_toReal_eq hf, wnorm'_toReal_eq hf]\n\nend ENorm\n\nsection ContinuousENorm\n\nvariable [ContinuousENorm \u03b5] [ContinuousENorm \u03b5\u2081] [ContinuousENorm \u03b5\u2082] [ContinuousENorm \u03b5\u2083]\n    {f : \u03b1 \u2192 \u03b5} {f\u2081 : \u03b1 \u2192 \u03b5\u2081}\n\nlemma wnorm'_le_eLpNorm' (hf : AEStronglyMeasurable f \u03bc) {p : \u211d} (hp : 1 \u2264 p) :\n    wnorm' f p \u03bc \u2264 eLpNorm' f p \u03bc := by\n  refine iSup_le (fun t \u21a6 ?_)\n  simp_rw [distribution, eLpNorm']\n  have p0 : 0 < p := lt_of_lt_of_le one_pos hp\n  have p0' : 0 \u2264 1 / p := (div_pos one_pos p0).le\n  have set_eq : {x | ofNNReal t < \u2016f x\u2016\u2091} = {x | ofNNReal t ^ p < \u2016f x\u2016\u2091 ^ p} := by\n    simp [ENNReal.rpow_lt_rpow_iff p0]\n  have : ofNNReal t = (ofNNReal t ^ p) ^ (1 / p) := by simp [p0.ne.symm]\n  nth_rewrite 1 [inv_eq_one_div p, this, \u2190 mul_rpow_of_nonneg _ _ p0', set_eq]\n  refine rpow_le_rpow ?_ p0'\n  refine le_trans ?_ <| mul_meas_ge_le_lintegral\u2080 (hf.enorm'.pow_const p) (ofNNReal t ^ p)\n  gcongr\n  exact setOf_subset_setOf.mpr (fun _ h \u21a6 h.le)\n\nlemma wnorm_le_eLpNorm (hf : AEStronglyMeasurable f \u03bc) {p : \u211d\u22650\u221e} (hp : 1 \u2264 p) :\n    wnorm f p \u03bc \u2264 eLpNorm f p \u03bc := by\n  by_cases h : p = \u22a4\n  \u00b7 simp [h, wnorm, eLpNorm]\n  \u00b7 have p0 : p \u2260 0 := (lt_of_lt_of_le one_pos hp).ne.symm\n    simpa [h, wnorm, eLpNorm, p0] using wnorm'_le_eLpNorm' hf (toReal_mono h hp)\n\n/-- A function is in weak-L^p if it is (strongly a.e.)-measurable and has finite weak L^p norm. -/\ndef MemW\u2112p (f : \u03b1 \u2192 \u03b5) (p : \u211d\u22650\u221e) (\u03bc : Measure \u03b1) : Prop :=\n  AEStronglyMeasurable f \u03bc \u2227 wnorm f p \u03bc < \u221e\n\nlemma Mem\u2112p.memW\u2112p (hp : 1 \u2264 p) (hf : Mem\u2112p f p \u03bc) : MemW\u2112p f p \u03bc :=\n  \u27e8hf.1, wnorm_le_eLpNorm hf.1 hp |>.trans_lt hf.2\u27e9\n\nlemma MemW\u2112p_zero : \u00ac MemW\u2112p f 0 \u03bc := by\n  simp [MemW\u2112p, wnorm_zero]\n\nlemma MemW\u2112p.aeStronglyMeasurable (hf : MemW\u2112p f p \u03bc) : AEStronglyMeasurable f \u03bc :=\n  hf.1\n\nlemma MemW\u2112p.wnorm_lt_top (hf : MemW\u2112p f p \u03bc) : wnorm f p \u03bc < \u22a4 :=\n  hf.2\n\nlemma MemW\u2112p.ennreal_toReal {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : MemW\u2112p f p \u03bc) :\n    MemW\u2112p (ENNReal.toReal \u2218 f) p \u03bc :=\n  \u27e8hf.aeStronglyMeasurable.ennreal_toReal, wnorm_toReal_le.trans_lt hf.2\u27e9\n\n/-- If a function `f` is `MemW\u2112p`, then its norm is almost everywhere finite.-/\ntheorem MemW\u2112p.ae_ne_top {f : \u03b1 \u2192 \u03b5} {p : \u211d\u22650\u221e} {\u03bc : Measure \u03b1}\n    (hf : MemW\u2112p f p \u03bc) : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016\u2091 \u2260 \u221e := by\n  by_cases hp_inf : p = \u221e\n  \u00b7 rw [hp_inf] at hf\n    simp_rw [\u2190 lt_top_iff_ne_top]\n    exact ae_lt_of_essSup_lt hf.2\n  by_cases hp_zero : p = 0\n  \u00b7 exact (MemW\u2112p_zero <| hp_zero \u25b8 hf).elim\n  set A := {x | \u2016f x\u2016\u2091 = \u221e} with hA\n  unfold MemW\u2112p wnorm wnorm' at hf\n  simp only [hp_inf] at hf\n  rw [Filter.eventually_iff, mem_ae_iff]\n  simp only [ne_eq, compl_def, mem_setOf_eq, Decidable.not_not, \u2190 hA]\n  have hp_toReal_zero := toReal_ne_zero.mpr \u27e8hp_zero, hp_inf\u27e9\n  have h1 (t : \u211d\u22650) : \u03bc A \u2264 distribution f t \u03bc := by\n    refine \u03bc.mono ?_\n    simp_all only [setOf_subset_setOf, coe_lt_top, implies_true, A]\n  set C := \u2a06 t : \u211d\u22650, t * distribution f t \u03bc ^ p.toReal\u207b\u00b9\n  by_cases hC_zero : C = 0\n  \u00b7 simp only [ENNReal.iSup_eq_zero, mul_eq_zero, ENNReal.rpow_eq_zero_iff, inv_neg'', C] at hC_zero\n    specialize hC_zero 1\n    simp only [one_ne_zero, ENNReal.coe_one, toReal_nonneg.not_lt, and_false, or_false,\n      false_or] at hC_zero\n    exact measure_mono_null (setOf_subset_setOf.mpr fun x hx => hx \u25b8 one_lt_top) hC_zero.1\n  by_contra h\n  have h2 : C < \u221e := by aesop\n  have h3 (t : \u211d\u22650) : distribution f t \u03bc \u2264 (C / t) ^ p.toReal := by\n    rw [\u2190 rpow_inv_rpow hp_toReal_zero (distribution ..)]\n    refine rpow_le_rpow ?_ toReal_nonneg\n    rw [ENNReal.le_div_iff_mul_le (Or.inr hC_zero) (Or.inl coe_ne_top), mul_comm]\n    exact le_iSup_iff.mpr fun _ a \u21a6 a t\n  have h4 (t : \u211d\u22650) : \u03bc A \u2264 (C / t) ^ p.toReal := (h1 t).trans (h3 t)\n  have h5 : \u03bc A \u2264 \u03bc A / 2 := by\n    convert h4 (C * (2 / \u03bc A) ^ p.toReal\u207b\u00b9).toNNReal\n    rw [coe_toNNReal ?_]\n    swap\n    \u00b7 refine mul_ne_top h2.ne_top (rpow_ne_top_of_nonneg (inv_nonneg.mpr toReal_nonneg) ?_)\n      simp [div_eq_top, h]\n    nth_rw 1 [\u2190 mul_one C]\n    rw [ENNReal.mul_div_mul_left _ _ hC_zero h2.ne_top, div_rpow_of_nonneg _ _ toReal_nonneg,\n      ENNReal.rpow_inv_rpow hp_toReal_zero, ENNReal.one_rpow, one_div,\n        ENNReal.inv_div (Or.inr ofNat_ne_top) (Or.inr (NeZero.ne' 2).symm)]\n  have h6 : \u03bc A = 0 := by\n    convert (fun hh \u21a6 ENNReal.half_lt_self hh (ne_top_of_le_ne_top (rpow_ne_top_of_nonneg\n      toReal_nonneg ((div_one C).symm \u25b8 h2.ne_top)) (h4 1))).mt h5.not_lt\n    tauto\n  exact h h6\n\n/- Todo: define `MeasureTheory.WLp` as a subgroup, similar to `MeasureTheory.Lp` -/\n\n/-- An operator has weak type `(p, q)` if it is bounded as a map from L^p to weak-L^q.\n`HasWeakType T p p' \u03bc \u03bd c` means that `T` has weak type (p, p') w.r.t. measures `\u03bc`, `\u03bd`\nand constant `c`.  -/\ndef HasWeakType (T : (\u03b1 \u2192 \u03b5\u2081) \u2192 (\u03b1' \u2192 \u03b5\u2082)) (p p' : \u211d\u22650\u221e) (\u03bc : Measure \u03b1) (\u03bd : Measure \u03b1')\n    (c : \u211d\u22650) : Prop :=\n  \u2200 f : \u03b1 \u2192 \u03b5\u2081, Mem\u2112p f p \u03bc \u2192 AEStronglyMeasurable (T f) \u03bd \u2227 wnorm (T f) p' \u03bd \u2264 c * eLpNorm f p \u03bc\n\n/-- A weaker version of `HasWeakType`. -/\ndef HasBoundedWeakType {\u03b1 \u03b1' : Type*} [Zero \u03b5\u2081]\n    {_x : MeasurableSpace \u03b1} {_x' : MeasurableSpace \u03b1'} (T : (\u03b1 \u2192 \u03b5\u2081) \u2192 (\u03b1' \u2192 \u03b5\u2082))\n    (p p' : \u211d\u22650\u221e) (\u03bc : Measure \u03b1) (\u03bd : Measure \u03b1') (c : \u211d\u22650) : Prop :=\n  \u2200 f : \u03b1 \u2192 \u03b5\u2081, Mem\u2112p f p \u03bc \u2192 eLpNorm f \u221e \u03bc < \u221e \u2192 \u03bc (support f) < \u221e \u2192\n  AEStronglyMeasurable (T f) \u03bd \u2227 wnorm (T f) p' \u03bd \u2264 c * eLpNorm f p \u03bc\n\n/-- An operator has strong type (p, q) if it is bounded as an operator on `L^p \u2192 L^q`.\n`HasStrongType T p p' \u03bc \u03bd c` means that `T` has strong type (p, p') w.r.t. measures `\u03bc`, `\u03bd`\nand constant `c`.  -/\ndef HasStrongType {\u03b1 \u03b1' : Type*}\n    {_x : MeasurableSpace \u03b1} {_x' : MeasurableSpace \u03b1'} (T : (\u03b1 \u2192 \u03b5\u2081) \u2192 (\u03b1' \u2192 \u03b5\u2082))\n    (p p' : \u211d\u22650\u221e) (\u03bc : Measure \u03b1) (\u03bd : Measure \u03b1') (c : \u211d\u22650) : Prop :=\n  \u2200 f : \u03b1 \u2192 \u03b5\u2081, Mem\u2112p f p \u03bc \u2192 AEStronglyMeasurable (T f) \u03bd \u2227 eLpNorm (T f) p' \u03bd \u2264 c * eLpNorm f p \u03bc\n\n/-- A weaker version of `HasStrongType`. This is the same as `HasStrongType` if `T` is continuous\nw.r.t. the L^2 norm, but weaker in general. -/\ndef HasBoundedStrongType {\u03b1 \u03b1' : Type*} [Zero \u03b5\u2081]\n    {_x : MeasurableSpace \u03b1} {_x' : MeasurableSpace \u03b1'} (T : (\u03b1 \u2192 \u03b5\u2081) \u2192 (\u03b1' \u2192 \u03b5\u2082))\n    (p p' : \u211d\u22650\u221e) (\u03bc : Measure \u03b1) (\u03bd : Measure \u03b1') (c : \u211d\u22650) : Prop :=\n  \u2200 f : \u03b1 \u2192 \u03b5\u2081, Mem\u2112p f p \u03bc \u2192 eLpNorm f \u221e \u03bc < \u221e \u2192 \u03bc (support f) < \u221e \u2192\n  AEStronglyMeasurable (T f) \u03bd \u2227 eLpNorm (T f) p' \u03bd \u2264 c * eLpNorm f p \u03bc\n\n\n/-! ### Lemmas about `HasWeakType` -/\n\nlemma HasWeakType.memW\u2112p (h : HasWeakType T p p' \u03bc \u03bd c) (hf\u2081 : Mem\u2112p f\u2081 p \u03bc) :\n    MemW\u2112p (T f\u2081) p' \u03bd :=\n  \u27e8(h f\u2081 hf\u2081).1, h f\u2081 hf\u2081 |>.2.trans_lt <| mul_lt_top coe_lt_top hf\u2081.2\u27e9\n\nlemma HasWeakType.toReal {T : (\u03b1 \u2192 \u03b5\u2081) \u2192 (\u03b1' \u2192 \u211d\u22650\u221e)} (h : HasWeakType T p p' \u03bc \u03bd c) :\n    HasWeakType (T \u00b7 \u00b7 |>.toReal) p p' \u03bc \u03bd c :=\n  fun f hf \u21a6 \u27e8(h f hf).1.ennreal_toReal, wnorm_toReal_le.trans (h f hf).2 \u27e9\n\n-- unused, probably delete\nopen Classical in\n", "theoremStatement": "lemma toReal_ofReal_preimage' {s : Set \u211d\u22650\u221e} : ENNReal.toReal \u207b\u00b9' (ENNReal.ofReal \u207b\u00b9' s) =\n    if \u221e \u2208 s \u2194 0 \u2208 s then s else if 0 \u2208 s then s \u222a {\u221e} else s \\ {\u221e} ", "theoremName": "MeasureTheory.toReal_ofReal_preimage'", "fileCreated": {"commit": "1a36cbeaee9466fb56c9aca49ef373f9f9cc7ab7", "date": "2025-01-23"}, "theoremCreated": {"commit": "451f4568375c1be265a0beb82adb601f9a3ee74d", "date": "2025-01-20"}, "file": "carleson/Carleson/ToMathlib/WeakType.lean", "module": "Carleson.ToMathlib.WeakType", "jsonFile": "Carleson.ToMathlib.WeakType.jsonl", "positionMetadata": {"lineInFile": 448, "tokenPositionInFile": 18120, "theoremPositionInFile": 47}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 70}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  split_ifs <;> ext (_|_) <;> simp_all", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 44}}
{"srcContext": "import Mathlib.Analysis.Convex.PartitionOfUnity\nimport Mathlib.Analysis.Calculus.ContDiff.Basic\nimport Mathlib.MeasureTheory.Integral.Average\nimport Mathlib.MeasureTheory.Integral.Bochner\nimport Mathlib.MeasureTheory.Measure.Haar.OfBasis\nimport Mathlib.Topology.MetricSpace.Holder\nimport Mathlib.Data.Set.Card\nimport Mathlib.Data.Real.ENatENNReal\nimport Carleson.ToMathlib.MeasureReal\n\n/-\n* This file can import all ToMathlib files.\n* If adding more than a few results, please put them in a more appropriate file in ToMathlib.\n-/\n\nopen Function Set\nopen scoped ENNReal\n\nsection ENNReal\n\nlemma tsum_one_eq' {\u03b1 : Type*} (s : Set \u03b1) : \u2211' (_:s), (1 : \u211d\u22650\u221e) = s.encard := by\n  if hfin : s.Finite then\n    have hfin' : Finite s := hfin\n    rw [tsum_def]\n    simp only [ENNReal.summable, \u2193reduceDIte]\n    have hsup: support (fun (_ : s) \u21a6 (1 : \u211d\u22650\u221e)) = Set.univ := by\n      ext i\n      simp only [mem_support, ne_eq, one_ne_zero, not_false_eq_true, mem_univ]\n    have hsupfin: (Set.univ : Set s).Finite := finite_univ\n    rw [\u2190 hsup] at hsupfin\n    rw [if_pos hsupfin]\n    rw [hfin.encard_eq_coe_toFinset_card]\n    simp only [ENat.toENNReal_coe]\n    rw [Finset.card_eq_sum_ones]\n    rw [finsum_eq_sum (fun (_ : s) \u21a6 (1 :\u211d\u22650\u221e)) hsupfin]\n    simp only [Finset.sum_const, nsmul_eq_mul, mul_one, smul_eq_mul, Nat.cast_inj]\n    apply Finset.card_bij (fun a _ => a.val)\n    \u00b7 intro a\n      simp only [Finite.mem_toFinset, mem_support, ne_eq, one_ne_zero, not_false_eq_true,\n        Subtype.coe_prop, imp_self]\n    \u00b7 intro a _ a' _ heq\n      ext\n      exact heq\n    \u00b7 intro a ha\n      use \u27e8a,by\n        simp only [Finite.mem_toFinset] at ha\n        exact ha\u27e9\n      simp only [Finite.mem_toFinset, mem_support, ne_eq, one_ne_zero, not_false_eq_true,\n        exists_const]\n  else\n  have : Infinite s := infinite_coe_iff.mpr hfin\n  rw [ENNReal.tsum_const_eq_top_of_ne_zero (by norm_num)]\n  rw [Set.encard_eq_top_iff.mpr hfin]\n  simp only [ENat.toENNReal_top]\n\nlemma ENNReal.tsum_const_eq' {\u03b1 : Type*} (s : Set \u03b1) (c : \u211d\u22650\u221e) :\n    \u2211' (_:s), (c : \u211d\u22650\u221e) = s.encard * c := by\n  nth_rw 1 [\u2190 one_mul c]\n  rw [ENNReal.tsum_mul_right,tsum_one_eq']\n\n/-! ## `ENNReal` manipulation lemmas -/\n\nlemma ENNReal.sum_geometric_two_pow_toNNReal {k : \u2115} (hk : k > 0) :\n    \u2211' (n : \u2115), (2 : \u211d\u22650\u221e) ^ (-k * n : \u2124) = (1 / (1 - 1 / 2 ^ k) : \u211d).toNNReal := by\n  conv_lhs =>\n    enter [1, n]\n    rw [\u2190 rpow_intCast, show (-k * n : \u2124) = (-k * n : \u211d) by simp, rpow_mul, rpow_natCast]\n  rw [tsum_geometric, show (2 : \u211d\u22650\u221e) = (2 : \u211d).toNNReal by simp,\n    \u2190 coe_rpow_of_ne_zero (by simp), \u2190 Real.toNNReal_rpow_of_nonneg zero_le_two,\n    \u2190 coe_one, \u2190 Real.toNNReal_one, \u2190 coe_sub, NNReal.sub_def,\n    Real.toNNReal_one, NNReal.coe_one, Real.coe_toNNReal', max_eq_left (by positivity),\n    Real.rpow_neg zero_le_two, Real.rpow_natCast, one_div]\n  have : ((1 : \u211d) - (2 ^ k)\u207b\u00b9).toNNReal \u2260 0 := by\n    rw [ne_eq, Real.toNNReal_eq_zero, tsub_le_iff_right, zero_add, not_le, inv_lt_one_iff\u2080]\n    right; exact one_lt_pow\u2080 (M\u2080 := \u211d) _root_.one_lt_two hk.ne'\n  rw [\u2190 coe_inv this, coe_inj, Real.toNNReal_inv, one_div]\n\nlemma ENNReal.sum_geometric_two_pow_neg_one : \u2211' (n : \u2115), (2 : \u211d\u22650\u221e) ^ (-n : \u2124) = 2 := by\n  conv_lhs => enter [1, n]; rw [\u2190 one_mul (n : \u2124), \u2190 neg_mul, \u2190 Nat.cast_one]\n  rw [ENNReal.sum_geometric_two_pow_toNNReal zero_lt_one]; norm_num\n\nlemma ENNReal.sum_geometric_two_pow_neg_two :\n    \u2211' (n : \u2115), (2 : \u211d\u22650\u221e) ^ (-2 * n : \u2124) = ((4 : \u211d) / 3).toNNReal := by\n  conv_lhs => enter [1, n, 2]; rw [\u2190 Nat.cast_two]\n  rw [ENNReal.sum_geometric_two_pow_toNNReal zero_lt_two]; norm_num\n\nlemma tsum_geometric_ite_eq_tsum_geometric {k c : \u2115} :\n    (\u2211' (n : \u2115), if k \u2264 n then (2 : \u211d\u22650\u221e) ^ (-c * (n - k) : \u2124) else 0) =\n    \u2211' (n : \u2115), 2 ^ (-c * n : \u2124) := by\n  convert (Injective.tsum_eq (f := fun n \u21a6 if k \u2264 n then (2 : \u211d\u22650\u221e) ^ (-c * (n - k) : \u2124) else 0)\n    (add_left_injective k) (fun n mn \u21a6 _)).symm\n  \u00b7 simp\n  \u00b7 rw [mem_support, ne_eq, ite_eq_right_iff, Classical.not_imp] at mn\n    use n - k, Nat.sub_add_cancel mn.1\n\nlemma ENNReal.toReal_zpow (x : \u211d\u22650\u221e) (z : \u2124) : x.toReal ^ z = (x ^ z).toReal := by\n  rw [\u2190 rpow_intCast, \u2190 toReal_rpow, Real.rpow_intCast]\n\nend ENNReal\n\nsection Indicator\nattribute [gcongr] Set.indicator_le_indicator mulIndicator_le_mulIndicator_of_subset\nend Indicator\n\n\nnamespace MeasureTheory\n\n/-! ## Partitioning an interval -/\n\n\nlemma lintegral_Ioc_partition {a b : \u2115} {c : \u211d} {f : \u211d \u2192 \u211d\u22650\u221e} (hc : 0 \u2264 c) :\n    \u222b\u207b t in Ioc (a * c) (b * c), f t =\n    \u2211 l \u2208 Finset.Ico a b, \u222b\u207b t in Ioc (l * c) ((l + 1 : \u2115) * c), f t := by\n  rcases lt_or_le b a with h | h\n  \u00b7 rw [Finset.Ico_eq_empty (by omega), Ioc_eq_empty (by rw [not_lt]; gcongr),\n      setLIntegral_empty, Finset.sum_empty]\n  induction b, h using Nat.le_induction with\n  | base =>\n    rw [Finset.Ico_self, Ioc_self, setLIntegral_empty, Finset.sum_empty]\n  | succ b h ih =>\n    have li : a * c \u2264 b * c := by gcongr\n    rw [\u2190 Ioc_union_Ioc_eq_Ioc li (by gcongr; omega),\n      lintegral_union measurableSet_Ioc Ioc_disjoint_Ioc_same,\n      Nat.Ico_succ_right_eq_insert_Ico h, Finset.sum_insert Finset.right_not_mem_Ico,\n      add_comm (lintegral ..), ih]\n\n/-! ## Averaging -/\n\n-- Named for consistency with `lintegral_add_left'`\n-- Maybe add laverage/laverage theorems for all the other lintegral_add statements?\nlemma laverage_add_left {\u03b1 : Type*} {m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}\n    {f g : \u03b1 \u2192 ENNReal} (hf : AEMeasurable f \u03bc) :\n    \u2a0d\u207b x, (f x + g x) \u2202\u03bc = \u2a0d\u207b x, f x \u2202\u03bc + \u2a0d\u207b x, g x \u2202\u03bc := by\n  simp_rw [laverage_eq, ENNReal.div_add_div_same, lintegral_add_left' hf]\n\n-- Named for consistency with `lintegral_mono'`\nlemma laverage_mono {\u03b1 : Type*} {m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}\n    {f g : \u03b1 \u2192 ENNReal} (h : \u2200 x, f x \u2264 g x) :\n    \u2a0d\u207b x, f x \u2202\u03bc \u2264 \u2a0d\u207b x, g x \u2202\u03bc := by\n  simp_rw [laverage_eq]\n  exact ENNReal.div_le_div_right (lintegral_mono h) (\u03bc univ)\n\nlemma laverage_const_mul {\u03b1 : Type*} {m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}\n    {f : \u03b1 \u2192 ENNReal} {c : ENNReal} (hc : c \u2260 \u22a4) :\n    c * \u2a0d\u207b x, f x \u2202\u03bc = \u2a0d\u207b x, c * f x \u2202\u03bc := by\n  simp_rw [laverage_eq, \u2190 mul_div_assoc c, lintegral_const_mul' c f hc]\n\n-- The following two lemmas are unused\n\n-- Named for consistency with `lintegral_add_left'`\n-- Maybe add laverage/setLaverage theorems for all the other lintegral_add statements?\nlemma setLaverage_add_left' {\u03b1 : Type*} {m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}\n    {s : Set \u03b1} {f g : \u03b1 \u2192 ENNReal} (hf : AEMeasurable f \u03bc) :\n    \u2a0d\u207b x in s, (f x + g x) \u2202\u03bc = \u2a0d\u207b x in s, f x \u2202\u03bc + \u2a0d\u207b x in s, g x \u2202\u03bc := by\n  simp_rw [setLaverage_eq, ENNReal.div_add_div_same, lintegral_add_left' hf.restrict]\n\n-- Named for consistency with `setLintegral_mono'`\nlemma setLaverage_mono' {\u03b1 : Type*} {m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}\n    {s : Set \u03b1} (hs : MeasurableSet s) {f g : \u03b1 \u2192 ENNReal} (h : \u2200 x \u2208 s, f x \u2264 g x) :\n    \u2a0d\u207b x in s, f x \u2202\u03bc \u2264 \u2a0d\u207b x in s, g x \u2202\u03bc := by\n  simp_rw [setLaverage_eq]\n  exact ENNReal.div_le_div_right (setLIntegral_mono' hs h) (\u03bc s)\n\nend MeasureTheory\n\nnamespace MeasureTheory\nvariable {\u03b1 : Type*} {m : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} {s : Set \u03b1}\n  {F : Type*} [NormedAddCommGroup F]\n\nattribute [fun_prop] Continuous.comp_aestronglyMeasurable\n  AEStronglyMeasurable.mul AEStronglyMeasurable.prod_mk\nattribute [gcongr] Measure.AbsolutelyContinuous.prod -- todo: also add one-sided versions for gcongr\n\n\ntheorem AEStronglyMeasurable.ennreal_toReal {u : \u03b1 \u2192 \u211d\u22650\u221e} (hu : AEStronglyMeasurable u \u03bc) :\n    AEStronglyMeasurable (fun x \u21a6 (u x).toReal) \u03bc := by\n  refine aestronglyMeasurable_iff_aemeasurable.mpr ?_\n  exact ENNReal.measurable_toReal.comp_aemeasurable hu.aemeasurable\n\nlemma laverage_mono_ae {f g : \u03b1 \u2192 \u211d\u22650\u221e} (h : \u2200\u1d50 a \u2202\u03bc, f a \u2264 g a) :\n    \u2a0d\u207b a, f a \u2202\u03bc \u2264 \u2a0d\u207b a, g a \u2202\u03bc := by\n  exact lintegral_mono_ae <| h.filter_mono <| Measure.ae_mono' Measure.smul_absolutelyContinuous\n\n@[gcongr]\nlemma setLAverage_mono_ae {f g : \u03b1 \u2192 \u211d\u22650\u221e} (h : \u2200\u1d50 a \u2202\u03bc, f a \u2264 g a) :\n    \u2a0d\u207b a in s, f a \u2202\u03bc \u2264 \u2a0d\u207b a in s, g a \u2202\u03bc := by\n  refine laverage_mono_ae <| h.filter_mono <| ae_mono Measure.restrict_le_self\n\nlemma setLaverage_const_le {c : \u211d\u22650\u221e} : \u2a0d\u207b _x in s, c \u2202\u03bc \u2264 c := by\n  simp_rw [setLaverage_eq, lintegral_const, Measure.restrict_apply MeasurableSet.univ,\n    univ_inter, div_eq_mul_inv, mul_assoc]\n  conv_rhs => rw [\u2190 mul_one c]\n  gcongr\n  exact ENNReal.mul_inv_le_one (\u03bc s)\n\ntheorem eLpNormEssSup_lt_top_of_ae_ennnorm_bound {f : \u03b1 \u2192 F} {C : \u211d\u22650\u221e}\n    (hfC : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016\u208a \u2264 C) : eLpNormEssSup f \u03bc \u2264 C := essSup_le_of_ae_le C hfC\n\n@[simp]\nlemma ENNReal.nnorm_toReal {x : \u211d\u22650\u221e} : \u2016x.toReal\u2016\u208a = x.toNNReal := by\n  ext; simp [ENNReal.toReal]\n\ntheorem restrict_absolutelyContinuous : \u03bc.restrict s \u226a \u03bc :=\n  fun s hs \u21a6 Measure.restrict_le_self s |>.trans hs.le |>.antisymm <| zero_le _\n\nend MeasureTheory\n\nsection\n\nopen MeasureTheory Bornology\nvariable {E X : Type*} {p : \u211d\u22650\u221e} [NormedAddCommGroup E] [TopologicalSpace X] [MeasurableSpace X]\n  {\u03bc : Measure X} [IsFiniteMeasureOnCompacts \u03bc] {f : X \u2192 E}\n\n---- now obsolete -> `BoundedCompactSupport.mem\u2112p`\n-- lemma _root_.HasCompactSupport.mem\u2112p_of_isBounded (hf : HasCompactSupport f)\n--     (h2f : IsBounded (range f))\n--     (h3f : AEStronglyMeasurable f \u03bc) {p : \u211d\u22650\u221e} : Mem\u2112p f p \u03bc := by\n--   obtain \u27e8C, hC\u27e9 := h2f.exists_norm_le\n--   simp only [mem_range, forall_exists_index, forall_apply_eq_imp_iff] at hC\n--   exact hf.mem\u2112p_of_bound h3f C <| .of_forall hC\n\nend\n\n/-! ## `EquivalenceOn` -/\n\n/-- An equivalence relation on the set `s`. -/\nstructure EquivalenceOn {\u03b1 : Type*} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : Set \u03b1) : Prop where\n  /-- An equivalence relation is reflexive: `x ~ x` -/\n  refl  : \u2200 x \u2208 s, r x x\n  /-- An equivalence relation is symmetric: `x ~ y` implies `y ~ x` -/\n  symm  : \u2200 {x y}, x \u2208 s \u2192 y \u2208 s \u2192 r x y \u2192 r y x\n  /-- An equivalence relation is transitive: `x ~ y` and `y ~ z` implies `x ~ z` -/\n  trans : \u2200 {x y z}, x \u2208 s \u2192 y \u2208 s \u2192 z \u2208 s \u2192 r x y \u2192 r y z \u2192 r x z\n\n\nnamespace EquivalenceOn\n\nvariable {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : Set \u03b1} {hr : EquivalenceOn r s} {x y : \u03b1}\n\nvariable (hr) in\n/-- The setoid defined from an equivalence relation on a set. -/\nprotected def setoid : Setoid s where\n  r x y := r x y\n  iseqv := {\n    refl := fun x \u21a6 hr.refl x x.2\n    symm := fun {x y} \u21a6 hr.symm x.2 y.2\n    trans := fun {x y z} \u21a6 hr.trans x.2 y.2 z.2\n  }\n\ninclude hr in\nlemma exists_rep (x : \u03b1) : \u2203 y, x \u2208 s \u2192 y \u2208 s \u2227 r x y :=\n  \u27e8x, fun hx \u21a6 \u27e8hx, hr.refl x hx\u27e9\u27e9\n\nopen Classical in\nvariable (hr) in\n/-- An arbitrary representative of `x` w.r.t. the equivalence relation `r`. -/\nprotected noncomputable def out (x : \u03b1) : \u03b1 :=\n  if hx : x \u2208 s then (Quotient.out (s := hr.setoid) \u27e6\u27e8x, hx\u27e9\u27e7 : s) else x\n\nlemma out_mem (hx : x \u2208 s) : hr.out x \u2208 s := by\n  rw [EquivalenceOn.out, dif_pos hx]\n  apply Subtype.prop\n\n@[simp]\nlemma out_mem_iff : hr.out x \u2208 s \u2194 x \u2208 s := by\n  refine \u27e8fun h \u21a6 ?_, out_mem\u27e9\n  by_contra hx\n  rw [EquivalenceOn.out, dif_neg hx] at h\n  exact hx h\n\nlemma out_rel (hx : x \u2208 s) : r (hr.out x) x := by\n  rw [EquivalenceOn.out, dif_pos hx]\n  exact @Quotient.mk_out _ (hr.setoid) \u27e8x, hx\u27e9\n\nlemma rel_out (hx : x \u2208 s) : r x (hr.out x) := hr.symm (out_mem hx) hx (out_rel hx)\n\nlemma out_inj (hx : x \u2208 s) (hy : y \u2208 s) (h : r x y) : hr.out x = hr.out y := by\n  simp_rw [EquivalenceOn.out, dif_pos hx, dif_pos hy]\n  congr 1\n  simp_rw [Quotient.out_inj, Quotient.eq]\n  exact h\n\nlemma out_inj' (hx : x \u2208 s) (hy : y \u2208 s) (h : r (hr.out x) (hr.out y)) : hr.out x = hr.out y := by\n  apply out_inj hx hy\n  refine hr.trans hx ?_ hy (rel_out hx) <| hr.trans ?_ ?_ hy h <| out_rel hy\n  all_goals simpa\n\nvariable (hr) in\n/-- The set of representatives of an equivalence relation on a set. -/\ndef reprs : Set \u03b1 := hr.out '' s\n\nlemma out_mem_reprs (hx : x \u2208 s) : hr.out x \u2208 hr.reprs := \u27e8x, hx, rfl\u27e9\n\nlemma reprs_subset : hr.reprs \u2286 s := by\n  rintro _ \u27e8x, hx, rfl\u27e9\n  exact out_mem hx\n\nlemma reprs_inj (hx : x \u2208 hr.reprs) (hy : y \u2208 hr.reprs) (h : r x y) : x = y := by\n  obtain \u27e8x, hx, rfl\u27e9 := hx\n  obtain \u27e8y, hy, rfl\u27e9 := hy\n  exact out_inj' hx hy h\n\nend EquivalenceOn\n\nnamespace Set.Finite\n\nlemma biSup_eq {\u03b1 : Type*} {\u03b9 : Type*} [CompleteLinearOrder \u03b1] {s : Set \u03b9}\n    (hs : s.Finite) (hs' : s.Nonempty) (f : \u03b9 \u2192 \u03b1) :\n    \u2203 i \u2208 s, \u2a06 j \u2208 s, f j = f i := by\n  simpa [sSup_image, eq_comm] using hs'.image f |>.csSup_mem (hs.image f)\n\nend Set.Finite\n\nlemma Real.self_lt_two_rpow (x : \u211d) : x < 2 ^ x := by\n  rcases lt_or_le x 0 with h | h\n  \u00b7 exact h.trans (rpow_pos_of_pos zero_lt_two x)\n  \u00b7 calc\n      _ < (\u230ax\u230b\u208a.succ : \u211d) := Nat.lt_succ_floor x\n      _ \u2264 2 ^ (\u230ax\u230b\u208a : \u211d) := by exact_mod_cast Nat.lt_pow_self one_lt_two\n      _ \u2264 _ := rpow_le_rpow_of_exponent_le one_le_two (Nat.floor_le h)\n\nnamespace Set\n\nopen ComplexConjugate\n\nlemma indicator_eq_indicator_one_mul {\u03b9 M:Type*} [MulZeroOneClass M]\n    (s : Set \u03b9) (f : \u03b9 \u2192 M) (x : \u03b9) : s.indicator f x = s.indicator 1 x * f x := by\n  simp only [indicator]; split_ifs <;> simp\n\nlemma conj_indicator {\u03b1 \ud835\udd5c : Type*} [RCLike \ud835\udd5c] {f : \u03b1 \u2192 \ud835\udd5c} (s : Set \u03b1) (x : \u03b1):\n    conj (s.indicator f x) = s.indicator (conj f) x := by\n  simp only [indicator]; split_ifs <;> simp\n\nend Set\n\nsection Norm\n\nopen Complex\n\n-- for mathlib?\nlemma norm_indicator_one_le {\u03b1 E}\n    [SeminormedAddCommGroup E] [One E] [NormOneClass E] {s : Set \u03b1} (x : \u03b1) :\n    \u2016s.indicator (1 : \u03b1 \u2192 E) x\u2016 \u2264 1 :=\n  Trans.trans (norm_indicator_le_norm_self 1 x) norm_one\n\nlemma norm_exp_I_mul_ofReal (x : \u211d) : \u2016exp (.I * x)\u2016 = 1 := by\n  rw [mul_comm, Complex.norm_exp_ofReal_mul_I]\n\nlemma norm_exp_I_mul_sub_ofReal (x y: \u211d) : \u2016exp (.I * (x - y))\u2016 = 1 := by\n  rw [mul_comm, \u2190 ofReal_sub, Complex.norm_exp_ofReal_mul_I]\n\nend Norm\n\nnamespace MeasureTheory\n\nopen Metric Bornology\nvariable {\ud835\udd5c: Type*}\nvariable [RCLike \ud835\udd5c]\n\nvariable {X \u03b1: Type*}\n\nnamespace HasCompactSupport\n\nvariable [Zero \u03b1] {f : X \u2192 \u03b1}\n\nvariable [PseudoMetricSpace X] [ProperSpace X]\n\ntheorem of_support_subset_closedBall {x : X}\n    {r : \u211d} (hf : support f \u2286 closedBall x r) :\n    HasCompactSupport f :=\n  HasCompactSupport.of_support_subset_isCompact (isCompact_closedBall ..) hf\n\ntheorem of_support_subset_isBounded {s : Set X}\n    (hs : IsBounded s) (hf : support f \u2286 s) :\n    HasCompactSupport f :=\n  IsCompact.closure_of_subset hs.isCompact_closure <| Trans.trans hf subset_closure\n\nend HasCompactSupport\n\nnamespace Integrable\n\nvariable [MeasureSpace X]\n\n-- must be in mathlib but can't find it\ntheorem indicator_const {c : \u211d} {s: Set X}\n    (hs: MeasurableSet s) (h2s : volume s < \u22a4) : Integrable (s.indicator (fun _ \u21a6 c)) :=\n  (integrable_indicator_iff hs).mpr <| integrableOn_const.mpr <| Or.inr h2s\n\nend Integrable\n\n-- Currently unused.\n-- The assumption `int_f` can likely be removed, as otherwise the integral is zero.\nopen Classical in\n", "theoremStatement": "theorem setIntegral_biUnion_le_sum_setIntegral {X : Type*} {\u03b9 : Type*} [MeasurableSpace X]\n    {f : X \u2192 \u211d} (s : Finset \u03b9) {S : \u03b9 \u2192 Set X} {\u03bc : Measure X}\n    (f_ae_nonneg : \u2200\u1d50 (x : X) \u2202\u03bc.restrict (\u22c3 i \u2208 s, S i), 0 \u2264 f x)\n    (int_f : IntegrableOn f (\u22c3 i \u2208 s, S i) \u03bc) :\n    \u222b x in (\u22c3 i \u2208 s, S i), f x \u2202\u03bc \u2264 \u2211 i \u2208 s, \u222b x in S i, f x \u2202\u03bc ", "theoremName": "MeasureTheory.setIntegral_biUnion_le_sum_setIntegral", "fileCreated": {"commit": "f75995f44d3cb33c8f91a124bbc1149e570a24c5", "date": "2023-12-11"}, "theoremCreated": {"commit": "3298f748e9eb26a242da5ee38cb50dc55e604935", "date": "2025-01-08"}, "file": "carleson/Carleson/ToMathlib/Misc.lean", "module": "Carleson.ToMathlib.Misc", "jsonFile": "Carleson.ToMathlib.Misc.jsonl", "positionMetadata": {"lineInFile": 394, "tokenPositionInFile": 14487, "theoremPositionInFile": 42}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 167}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  have res_res : \u2200 i \u2208 s, (\u03bc.restrict (\u22c3 i \u2208 s, S i)).restrict (S i) = \u03bc.restrict (S i) :=\n    fun i hi \u21a6 by rw [Measure.restrict_restrict_of_subset]; exact (subset_biUnion_of_mem hi)\n  -- Show that it suffices to prove the result in the case where the integrand is measurable\n  set g := AEMeasurable.mk f int_f.aemeasurable with hg\n  have g_ae_nonneg : \u2200\u1d50 (x : X) \u2202\u03bc.restrict (\u22c3 i \u2208 s, S i), 0 \u2264 g x := by\n    apply f_ae_nonneg.congr \u2218 int_f.aemeasurable.ae_eq_mk.mp\n    exact Filter.Eventually.of_forall (fun _ h \u21a6 by rw [h])\n  have int_g : \u2200 i \u2208 s, Integrable g (\u03bc.restrict (S i)) := by\n    intro i hi\n    have := (int_f.congr int_f.aemeasurable.ae_eq_mk).restrict (s := S i)\n    rwa [res_res i hi] at this\n  have : \u2211 i \u2208 s, \u222b (x : X) in S i, f x \u2202\u03bc = \u2211 i \u2208 s, \u222b (x : X) in S i, g x \u2202\u03bc := by\n    refine Finset.sum_congr rfl (fun i hi \u21a6 integral_congr_ae ?_)\n    convert int_f.aemeasurable.ae_eq_mk.restrict (s := S i) using 2\n    rw [Measure.restrict_restrict_of_subset]\n    exact (subset_biUnion_of_mem hi)\n  rw [this, integral_congr_ae int_f.aemeasurable.ae_eq_mk]\n  -- Now prove the result for the measurable integrand `g`\n  have meas : MeasurableSet {x | 0 \u2264 g x} :=\n    have : {x | 0 \u2264 g x} = g \u207b\u00b9' (Ici 0) := by simp [preimage, mem_Ici]\n    this \u25b8 (AEMeasurable.measurable_mk int_f.aemeasurable) measurableSet_Ici\n  rw [\u2190 integral_finset_sum_measure int_g]\n  set \u03bc\u2080 : \u03b9 \u2192 Measure X := fun i \u21a6 ite (i \u2208 s) (\u03bc.restrict (S i)) 0\n  refine integral_mono_measure ?_ ?_ (integrable_finset_sum_measure.mpr int_g)\n  \u00b7 refine Measure.le_iff.mpr (fun T hT \u21a6 ?_)\n    simp_rw [\u03bc.restrict_apply hT, Measure.coe_finset_sum, s.sum_apply, inter_iUnion]\n    apply le_trans <| measure_biUnion_finset_le s (T \u2229 S \u00b7)\n    exact s.sum_le_sum (fun _ _ \u21a6 ge_of_eq (\u03bc.restrict_apply hT))\n  \u00b7 have : \u2211 i \u2208 s, \u03bc.restrict (S i) = Measure.sum \u03bc\u2080 := by\n      ext T hT\n      simp only [Measure.sum_apply (hs := hT), Measure.coe_finset_sum, s.sum_apply, \u03bc\u2080]\n      rw [tsum_eq_sum (s := s) (fun b hb \u21a6 by simp [hb])]\n      exact Finset.sum_congr rfl (fun i hi \u21a6 by simp [hi, res_res])\n    rw [Filter.EventuallyLE, this, Measure.ae_sum_iff' (by exact meas)]\n    intro i\n    by_cases hi : i \u2208 s\n    \u00b7 simp only [Pi.zero_apply, hi, reduceIte, \u03bc\u2080, \u2190 res_res i hi, ae_restrict_iff meas, \u2190 hg]\n      exact g_ae_nonneg.mono (fun _ h _ \u21a6 h)\n    \u00b7 simp [hi, \u03bc\u2080]", "proofType": "tactic", "proofLengthLines": 39, "proofLengthTokens": 2333}}
{"srcContext": "/-\nCopyright (c) 2024 James Sundstrom. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: James Sundstrom\n-/\nimport Mathlib.MeasureTheory.Constructions.BorelSpace.Metric\n\n/-!\n# Annulus\n\nIn this file we define an annulus in a pseudometric space `X` to be a set consisting of all `y`\nsuch that `dist x y` lies in an interval between `r` and `R`. An annulus is defined for each type\nof interval (`Ioo`, `Ioc`, etc.) with a parallel naming scheme, except that we do not define annuli\nfor `Iio` and `Ico`, as they would be balls.\n\nWe also define `EAnnulus` similarly using `edist` instead of `dist`.\n\n## Tags\n\nannulus, eannulus\n-/\n\nopen Set Metric ENNReal\n\nvariable {X : Type*} [PseudoMetricSpace X]\n\nnamespace Set\n\nnamespace Annulus\n\ndef oo (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d) := {y | dist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d) := {y | dist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d) := {y | dist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d) := {y | dist x y \u2208 Ici r}\n\nlemma oo_eq {x : X} {r R : \u211d} : oo x r R = ball x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oo, dist_comm, and_comm]\n\nlemma oc_eq {x : X} {r R : \u211d} : oc x r R = closedBall x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oc, dist_comm, and_comm]\n\nlemma co_eq {x : X} {r R : \u211d} : co x r R = ball x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [co, dist_comm, and_comm]\n\nlemma cc_eq {x : X} {r R : \u211d} : cc x r R = closedBall x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [cc, dist_comm, and_comm]\n\nlemma oi_eq {x : X} {r : \u211d} : oi x r = (closedBall x r)\u1d9c := by\n  ext; simp [oi, dist_comm]\n\nlemma ci_eq {x : X} {r : \u211d} : ci x r = (ball x r)\u1d9c := by\n  ext; simp [ci, dist_comm]\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : co x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma co_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : co x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\nlemma cc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : cc x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma cc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : cc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\n@[simp]\nlemma oc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    oc x r r' \u222a oo x r' R = oo x r R := by\n  ext; simp_rw [oc, oo, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioo_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    oc x r r' \u222a oc x r' R = oc x r R := by\n  ext; simp_rw [oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_co {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a co x r' R = oo x r R := by\n  ext; simp_rw [oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ico_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a cc x r' R = oc x r R := by\n  ext; simp_rw [oo, cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Icc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    cc x r r' \u222a oo x r' R = co x r R := by\n  ext; simp_rw [cc, oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioo_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    cc x r r' \u222a oc x r' R = cc x r R := by\n  ext; simp_rw [cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_co {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a co x r' R = co x r R := by\n  ext; simp_rw [co, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ico_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a cc x r' R = cc x r R := by\n  ext; simp_rw [co, cc, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Icc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : oc x r R \u222a oi x R = oi x r := by\n  ext; simp_rw [oc, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioi_eq_Ioi h]\n\n@[simp]\nlemma oo_union_ci {x : X} {r R : \u211d} (h : r < R) :\n    oo x r R \u222a ci x R = oi x r := by\n  ext; simp_rw [oo, ci, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ici_eq_Ioi h]\n\n@[simp]\nlemma cc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : cc x r R \u222a oi x R = ci x r := by\n  ext; simp_rw [cc, oi, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioi_eq_Ici h]\n\n@[simp]\nlemma co_union_ci {x : X} {r R : \u211d} (h : r \u2264 R) : co x r R \u222a ci x R = ci x r := by\n  ext; simp_rw [co, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ici_eq_Ici h]\n\n\nvariable [MeasurableSpace X] [OpensMeasurableSpace X]\n\n@[measurability]\nlemma measurableSet_oo {x : X} {r R : \u211d} : MeasurableSet (oo x r R) := by\n  rw [oo_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oc {x : X} {r R : \u211d} : MeasurableSet (oc x r R) := by\n rw [oc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_co {x : X} {r R : \u211d} : MeasurableSet (co x r R) := by\n  rw [co_eq]; measurability\n\n@[measurability]\nlemma measurableSet_cc {x : X} {r R : \u211d} : MeasurableSet (cc x r R) := by\n rw [cc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oi {x : X} {r : \u211d} : MeasurableSet (oi x r) := by\n  rw [oi_eq]; measurability\n\n@[measurability]\nlemma measurableSet_ci {x : X} {r : \u211d} : MeasurableSet (ci x r) := by\n  rw [ci_eq]; measurability\n\nend Annulus\n\nnamespace EAnnulus\n\ndef oo (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ici r}\n\n\nlemma oo_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oo x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oo x r R := by\n  simp_rw [oo, Annulus.oo, edist_dist, mem_Ioo, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma oc_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [oc, Annulus.oc, edist_dist, mem_Ioc, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  \u00b7 have R_le_r := (lt_of_lt_of_le (lt_of_not_ge hR) hr).le\n    rw [Annulus.oc_eq_empty R_le_r]\n    refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n    exact not_le_of_gt (lt_of_le_of_lt (ENNReal.ofReal_le_ofReal R_le_r) hy.1) hy.2\n\nlemma co_eq_annulus {x : X} {r R : \u211d} :\n    co x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.co x r R := by\n  simp_rw [co, Annulus.co, edist_dist, mem_Ico, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma cc_eq_annulus {x : X} {r R : \u211d} (h : r > 0 \u2228 R \u2265 0) :\n    cc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.cc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [cc, Annulus.cc, edist_dist, mem_Icc, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  have r0 := h.resolve_right hR\n  have R_lt_r := (lt_of_not_ge hR).trans r0\n  rw [Annulus.cc_eq_empty R_lt_r]\n  refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n  exact not_le_of_gt ((ENNReal.ofReal_lt_ofReal_iff r0).mpr R_lt_r) (hy.1.trans hy.2)\n\nlemma oi_eq_annulus {x : X} {r : \u211d} (hr : r \u2265 0) : oi x (ENNReal.ofReal r) = Annulus.oi x r := by\n  simp_rw [oi, Annulus.oi, edist_dist, mem_Ioi, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr]\n\nlemma ci_eq_annulus {x : X} {r : \u211d} : ci x (ENNReal.ofReal r) = Annulus.ci x r := by\n  simp_rw [ci, Annulus.ci, edist_dist, mem_Ici, ENNReal.ofReal_le_ofReal_iff dist_nonneg]\n\n\nlemma oo_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oo x r R = ball x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oo, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma oc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oc x r R = closedBall x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oc, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma co_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    co x r R = ball x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [co, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma cc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    cc x r R = closedBall x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [cc, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma oi_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : oi x r = (closedBall x r.toReal)\u1d9c := by\n  ext; simp [oi, edist_dist, dist_comm, lt_ofReal_iff_toReal_lt hr.ne]\n\nlemma ci_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : ci x r = (ball x r.toReal)\u1d9c := by\n  ext; simp [ci, edist_dist, dist_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg]\n\n\n", "theoremStatement": "@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : oo x r R = \u2205 ", "theoremName": "Set.EAnnulus.oo_eq_empty", "fileCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "theoremCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "file": "carleson/Carleson/ToMathlib/Annulus.lean", "module": "Carleson.ToMathlib.Annulus", "jsonFile": "Carleson.ToMathlib.Annulus.jsonl", "positionMetadata": {"lineInFile": 326, "tokenPositionInFile": 12773, "theoremPositionInFile": 76}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 1, "numPremises": 32}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp [oo, Ioo_eq_empty_of_le h]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 39}}
{"srcContext": "import Carleson.Forest\nimport Carleson.ToMathlib.HardyLittlewood\nimport Carleson.ToMathlib.BoundedCompactSupport\nimport Carleson.ToMathlib.Misc\nimport Carleson.Psi\n\nopen ShortVariables TileStructure\nvariable {X : Type*} {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102} {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X}\n  [MetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] [TileStructure Q D \u03ba S o]\n  {n j j' : \u2115} {t : Forest X n} {u u\u2081 u\u2082 p : \ud835\udd13 X} {x x' : X} {\ud835\udd16 : Set (\ud835\udd13 X)}\n  {f f\u2081 f\u2082 g g\u2081 g\u2082 : X \u2192 \u2102} {I J J' L : Grid X}\nvariable {E' : Type*} [NormedAddCommGroup E'] [NormedSpace \u211d E']\n\nnoncomputable section\n\nopen Set MeasureTheory Metric Function Complex Bornology TileStructure Classical Filter\nopen scoped NNReal ENNReal ComplexConjugate\n\nnamespace TileStructure.Forest\n\n/-! ## Section 7.1 and Lemma 7.1.3 -/\n\nvariable (t) in\n/-- The definition `\u03c3(u, x)` given in Section 7.1.\nWe may assume `u \u2208 t` whenever proving things about this definition. -/\ndef \u03c3 (u : \ud835\udd13 X) (x : X) : Finset \u2124 := .image \ud835\udd30 { p | p \u2208 t u \u2227 x \u2208 E p }\n\nvariable (t) in\nprivate lemma exists_p_of_mem_\u03c3 (u : \ud835\udd13 X) (x : X) {s : \u2124} (hs : s \u2208 t.\u03c3 u x) :\n    \u2203 p \u2208 t.\ud835\udd17 u, x \u2208 E p \u2227 \ud835\udd30 p = s := by\n  have \u27e8p, hp\u27e9 := Finset.mem_image.mp hs\n  simp only [mem_\ud835\udd17, Finset.mem_filter] at hp\n  use p, hp.1.2.1, hp.1.2.2, hp.2\n\n/- \\overline{\u03c3} from the blueprint. -/\nvariable (t) in\ndef \u03c3Max (u : \ud835\udd13 X) (x : X) (h\u03c3 : (t.\u03c3 u x).Nonempty) : \u2124 :=\n  t.\u03c3 u x |>.max' h\u03c3\n\n/- \\underline{\u03c3} from the blueprint. -/\nvariable (t) in\ndef \u03c3Min (u : \ud835\udd13 X) (x : X) (h\u03c3 : (t.\u03c3 u x).Nonempty) : \u2124 :=\n  t.\u03c3 u x |>.min' h\u03c3\n\nvariable (t) in\nprivate lemma \u03c3Max_mem_\u03c3 (u : \ud835\udd13 X) (x : X) (h\u03c3 : (t.\u03c3 u x).Nonempty) : \u03c3Max t u x h\u03c3 \u2208 t.\u03c3 u x :=\n  (t.\u03c3 u x).max'_mem h\u03c3\n\n/-- The definition of `\ud835\udcd9\u2080(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcd9\u2080 (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {J : Grid X | s J = -S \u2228 \u2200 p \u2208 \ud835\udd16, \u00ac(\ud835\udcd8 p : Set X) \u2286 ball (c J) (100 * D ^ (s J + 1))}\n\n/-- The definition of `\ud835\udcd9(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcd9 (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {x | Maximal (\u00b7 \u2208 \ud835\udcd9\u2080 \ud835\udd16) x}\n\nlemma \ud835\udcd9_subset_\ud835\udcd9\u2080 {\ud835\udd16 : Set (\ud835\udd13 X)} : \ud835\udcd9 \ud835\udd16 \u2286 \ud835\udcd9\u2080 \ud835\udd16 := sep_subset ..\n\nlemma pairwiseDisjoint_\ud835\udcd9 : (\ud835\udcd9 \ud835\udd16).PairwiseDisjoint (fun I \u21a6 (I : Set X)) := fun I mI J mJ hn \u21a6 by\n  have : IsAntichain (\u00b7 \u2264 \u00b7) (\ud835\udcd9 \ud835\udd16) := setOf_maximal_antichain _\n  exact (le_or_ge_or_disjoint.resolve_left (this mI mJ hn)).resolve_left (this mJ mI hn.symm)\n\n/-- The definition of `\ud835\udcdb\u2080(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcdb\u2080 (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {L : Grid X | s L = -S \u2228 (\u2203 p \u2208 \ud835\udd16, L \u2264 \ud835\udcd8 p) \u2227 \u2200 p \u2208 \ud835\udd16, \u00ac\ud835\udcd8 p \u2264 L}\n\n/-- The definition of `\ud835\udcdb(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcdb (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {x | Maximal (\u00b7 \u2208 \ud835\udcdb\u2080 \ud835\udd16) x}\n\nlemma \ud835\udcdb_subset_\ud835\udcdb\u2080 {\ud835\udd16 : Set (\ud835\udd13 X)} : \ud835\udcdb \ud835\udd16 \u2286 \ud835\udcdb\u2080 \ud835\udd16 := sep_subset ..\n\nprivate lemma s_le_s_of_mem_\ud835\udcdb {\ud835\udd16 : Set (\ud835\udd13 X)} {L : Grid X} (hL : L \u2208 \ud835\udcdb \ud835\udd16)\n    {p : \ud835\udd13 X} (hp : p \u2208 \ud835\udd16) (hpL : \u00ac Disjoint (\ud835\udcd8 p : Set X) (L : Set X)) : s L \u2264 s (\ud835\udcd8 p) := by\n  simp only [\ud835\udcdb, \ud835\udcdb\u2080, Grid.le_def, not_and, not_le, and_imp] at hL\n  rcases hL.1 with h | h\n  \u00b7 exact h \u25b8 (range_s_subset \u27e8\ud835\udcd8 p, rfl\u27e9).1\n  \u00b7 by_contra!\n    exact lt_asymm this <| h.2 p hp <| (GridStructure.fundamental_dyadic' this.le).resolve_right hpL\n\nprivate lemma subset_of_mem_\ud835\udcdb {\ud835\udd16 : Set (\ud835\udd13 X)} {L : Grid X} (hL : L \u2208 \ud835\udcdb \ud835\udd16) {p : \ud835\udd13 X}\n    (hp : p \u2208 \ud835\udd16) (hpL : \u00ac Disjoint (\ud835\udcd8 p : Set X) (L : Set X)) : (L : Set X) \u2286 (\ud835\udcd8 p : Set X) :=\n  GridStructure.fundamental_dyadic' (s_le_s_of_mem_\ud835\udcdb hL hp hpL) |>.resolve_right fun h \u21a6 hpL h.symm\n\n/-- The projection operator `P_\ud835\udcd2 f(x)`, given above Lemma 7.1.3.\nIn lemmas the `c` will be pairwise disjoint on `C`. -/\ndef approxOnCube (C : Set (Grid X)) (f : X \u2192 E') (x : X) : E' :=\n  \u2211 J \u2208 { p | p \u2208 C }, (J : Set X).indicator (fun _ \u21a6 \u2a0d y in J, f y) x\n\nlemma stronglyMeasurable_approxOnCube (C : Set (Grid X)) (f : X \u2192 E') :\n    StronglyMeasurable (approxOnCube (X := X) (K := K) C f) :=\n  Finset.stronglyMeasurable_sum _ (fun _ _ \u21a6 stronglyMeasurable_const.indicator coeGrid_measurable)\n\nlemma integrable_approxOnCube (C : Set (Grid X)) {f : X \u2192 E'} : Integrable (approxOnCube C f) := by\n  refine integrable_finset_sum _ (fun i hi \u21a6 ?_)\n  constructor\n  \u00b7 exact (aestronglyMeasurable_indicator_iff coeGrid_measurable).mpr aestronglyMeasurable_const\n  \u00b7 simp_rw [hasFiniteIntegral_iff_enorm, enorm_indicator_eq_indicator_enorm]\n    apply lt_of_le_of_lt <| lintegral_indicator_const_le (i : Set X) _\n    exact ENNReal.mul_lt_top ENNReal.coe_lt_top volume_coeGrid_lt_top\n\nlemma approxOnCube_nonneg {C : Set (Grid X)} {f : X \u2192 \u211d} (hf : \u2200 (y : X), f y \u2265 0) {x : X} :\n    approxOnCube C f x \u2265 0 :=\n  Finset.sum_nonneg' (fun _ \u21a6 Set.indicator_nonneg (fun _ _ \u21a6 integral_nonneg hf) _)\n\nlemma approxOnCube_apply {C : Set (Grid X)} (hC : C.PairwiseDisjoint (fun I \u21a6 (I : Set X)))\n    (f : X \u2192 E') {x : X} {J : Grid X} (hJ : J \u2208 C) (xJ : x \u2208 J) :\n    (approxOnCube C f) x = \u2a0d y in J, f y := by\n  rw [approxOnCube, \u2190 Finset.sum_filter_not_add_sum_filter _ (J = \u00b7)]\n  have eq0 : \u2211 i \u2208 Finset.filter (\u00ac J = \u00b7) (Finset.univ.filter (\u00b7 \u2208 C)),\n      (i : Set X).indicator (fun _ \u21a6 \u2a0d y in i, f y) x = 0 := by\n    suffices \u2200 i \u2208 (Finset.univ.filter (\u00b7 \u2208 C)).filter (\u00ac J = \u00b7),\n      (i : Set X).indicator (fun _ \u21a6 \u2a0d y in i, f y) x = 0 by simp [Finset.sum_congr rfl this]\n    intro i hi\n    simp only [Finset.mem_filter, Finset.mem_univ, true_and] at hi\n    apply indicator_of_not_mem <|\n      Set.disjoint_left.mp ((hC.eq_or_disjoint hJ hi.1).resolve_left hi.2) xJ\n  have eq_ave : \u2211 i \u2208 (Finset.univ.filter (\u00b7 \u2208 C)).filter (J = \u00b7),\n      (i : Set X).indicator (fun _ \u21a6 \u2a0d y in i, f y) x = \u2a0d y in J, f y := by\n    suffices (Finset.univ.filter (\u00b7 \u2208 C)).filter (J = \u00b7) = {J} by simp [this, xJ, \u2190 Grid.mem_def]\n    exact subset_antisymm (fun _ h \u21a6 Finset.mem_singleton.mpr (Finset.mem_filter.mp h).2.symm)\n      (fun _ h \u21a6 by simp [Finset.mem_singleton.mp h, hJ])\n  rw [eq0, eq_ave, zero_add]\n\nlemma boundedCompactSupport_approxOnCube {\ud835\udd5c : Type*} [RCLike \ud835\udd5c] {C : Set (Grid X)} {f : X \u2192 \ud835\udd5c} :\n    BoundedCompactSupport (approxOnCube C f) :=\n  BoundedCompactSupport.finset_sum fun J hJ \u21a6\n    BoundedCompactSupport.indicator_of_isBounded_range (by simp) stronglyMeasurable_const\n    ((isBounded_iff_subset_ball (c J)).mpr \u27e84 * D ^ s J, Grid_subset_ball\u27e9) coeGrid_measurable\n\n-- Used in the proof of Lemma 7.1.6\nlemma integral_eq_lintegral_approxOnCube {C : Set (Grid X)}\n    (hC : C.PairwiseDisjoint fun I \u21a6 (I : Set X)) {J : Grid X} (hJ : J \u2208 C) {f : X \u2192 \u2102}\n    (hf : BoundedCompactSupport f) : ENNReal.ofReal (\u222b y in J, \u2016f y\u2016) =\n    \u222b\u207b (y : X) in J, \u2016approxOnCube C (fun x \u21a6 (\u2016f x\u2016 : \u2102)) y\u2016\u208a := by\n  have nonneg : 0 \u2264\u1da0[ae (volume.restrict J)] fun y \u21a6 \u2016f y\u2016 := Filter.Eventually.of_forall (by simp)\n  have vol_J_ne_zero := (volume_coeGrid_pos (X := X) (i := J) (defaultD_pos' a)).ne.symm\n  have eq : \u222b\u207b (y : X) in J, \u2016approxOnCube C (fun x \u21a6 (\u2016f x\u2016 : \u2102)) y\u2016\u208a =\n      \u222b\u207b y in (J : Set X), ENNReal.ofReal (\u2a0d z in J, \u2016f z\u2016) := by\n    refine setLIntegral_congr_fun coeGrid_measurable (Filter.Eventually.of_forall fun y hy \u21a6 ?_)\n    rw [approxOnCube_apply hC _ hJ hy, ENNReal.ofReal]\n    \u00b7 apply congrArg\n      have : \u2016\u2a0d y in J, (\u2016f y\u2016 : \u2102)\u2016\u208a = \u2016\u2a0d y in J, \u2016f y\u2016\u2016\u208a := by\n        convert congrArg (\u2016\u00b7\u2016\u208a) <| integral_ofReal (f := (\u2016f \u00b7\u2016)) using 1\n        simp [average]\n      exact this \u25b8 (Real.toNNReal_eq_nnnorm_of_nonneg <| integral_nonneg (fun y \u21a6 by simp)).symm\n  rw [ofReal_integral_eq_lintegral_ofReal hf.integrable.norm.restrict nonneg,\n    eq, lintegral_const, average_eq, smul_eq_mul, ENNReal.ofReal_mul, ENNReal.ofReal_inv_of_pos,\n    ENNReal.ofReal_toReal, ofReal_integral_eq_lintegral_ofReal hf.norm.integrable nonneg, mul_comm,\n    \u2190 mul_assoc, Measure.restrict_apply MeasurableSet.univ, univ_inter,\n    ENNReal.mul_inv_cancel vol_J_ne_zero volume_coeGrid_lt_top.ne, one_mul]\n  \u00b7 simp [volume_coeGrid_lt_top.ne]\n  \u00b7 simpa using ENNReal.toReal_pos vol_J_ne_zero volume_coeGrid_lt_top.ne\n  \u00b7 exact inv_nonneg.mpr ENNReal.toReal_nonneg\n\nlemma approxOnCube_ofReal (C : Set (Grid X)) (f : X \u2192 \u211d) (x : X) :\n    approxOnCube C (Complex.ofReal <| f \u00b7) x = Complex.ofReal (approxOnCube C f x) := by\n  simp_rw [approxOnCube, ofReal_sum]\n  refine Finset.sum_congr rfl (fun J _ \u21a6 ?_)\n  by_cases hx : x \u2208 (J : Set X)\n  \u00b7 simpa only [indicator_of_mem hx] using integral_ofReal\n  \u00b7 simp only [indicator_of_not_mem hx, ofReal_zero]\n\nlemma norm_approxOnCube_le_approxOnCube_norm {C : Set (Grid X)} {f : X \u2192 E'} {x : X} :\n    \u2016approxOnCube C f x\u2016 \u2264 approxOnCube C (\u2016f \u00b7\u2016) x := by\n  refine (norm_sum_le _ _).trans <| Finset.sum_le_sum (fun J hJ \u21a6 ?_)\n  rw [norm_indicator_eq_indicator_norm]\n  gcongr\n  apply norm_integral_le_integral_norm\n\n/-- The definition `I_i(x)`, given above Lemma 7.1.3.\nThe cube of scale `s` that contains `x`. There is at most 1 such cube, if it exists. -/\ndef cubeOf (i : \u2124) (x : X) : Grid X :=\n  Classical.epsilon (fun I \u21a6 x \u2208 I \u2227 s I = i)\n\nlemma cubeOf_spec {i : \u2124} (hi : i \u2208 Icc (-S : \u2124) S) (I : Grid X) {x : X} (hx : x \u2208 I) :\n    x \u2208 cubeOf i x \u2227 s (cubeOf i x) = i := by\n  apply epsilon_spec (p := fun I \u21a6 x \u2208 I \u2227 s I = i)\n  by_cases hiS : i = S\n  \u00b7 use topCube, subset_topCube hx, hiS \u25b8 s_topCube\n  simpa [and_comm] using Set.mem_iUnion\u2082.mp <| Grid_subset_biUnion i\n    \u27e8hi.1, s_topCube (X := X) \u25b8 lt_of_le_of_ne hi.2 hiS\u27e9 (subset_topCube hx)\n\n/-- The definition `T_\ud835\udcdd^\u03b8 f(x)`, given in (7.1.3).\nFor convenience, the suprema are written a bit differently than in the blueprint\n(avoiding `cubeOf`), but this should be equivalent.\nThis is `0` if `x` doesn't lie in a cube. -/\ndef nontangentialMaximalFunction (\u03b8 : \u0398 X) (f : X \u2192 \u2102) (x : X) : \u211d\u22650\u221e :=\n  \u2a06 (I : Grid X) (_ : x \u2208 I) (x' \u2208 I) (s\u2082 \u2208 Icc (s I) S)\n  (_ : ENNReal.ofReal (D ^ (s\u2082 - 1)) \u2264 upperRadius Q \u03b8 x'),\n  \u2016\u2211 i \u2208 Icc (s I) s\u2082, \u222b y, Ks i x' y * f y\u2016\u208a\n\nprotected theorem MeasureTheory.Measurable.nontangentialMaximalFunction {\u03b8 : \u0398 X} {f : X \u2192 \u2102} :\n    Measurable (nontangentialMaximalFunction \u03b8 f) := by\n  refine Measurable.iSup (fun I \u21a6 ?_)\n  let c := \u2a06 x' \u2208 I, \u2a06 s\u2082 \u2208 Icc (s I) S, \u2a06 (_ : ENNReal.ofReal (D ^ (s\u2082 - 1)) \u2264 upperRadius Q \u03b8 x'),\n    (\u2016\u2211 i \u2208 (Icc (s I) s\u2082), \u222b (y : X), Ks i x' y * f y\u2016\u208a : ENNReal)\n  have : (fun x \u21a6 \u2a06 (_ : x \u2208 I), c) = fun x \u21a6 ite (x \u2208 I) c 0 := by\n    ext x; by_cases hx : x \u2208 I <;> simp [hx]\n  convert (measurable_const.ite coeGrid_measurable measurable_const) using 1\n\n-- Set used in definition of `boundaryOperator`\nvariable (t) (u) in private def \ud835\udcd9' (x : X) (i : \u2124) : Finset (Grid X) :=\n  { J | J \u2208 \ud835\udcd9 (t u) \u2227 (J : Set X) \u2286 ball x (16 * D ^ i) \u2227 s J \u2264 i }\n\nprivate lemma mem_\ud835\udcd9_of_mem_\ud835\udcd9' {x : X} {i : \u2124} {J : Grid X} : J \u2208 \ud835\udcd9' t u x i \u2192 J \u2208 \ud835\udcd9 (t u) := by\n  intro hJ\n  simp only [\ud835\udcd9', Finset.mem_filter] at hJ\n  exact hJ.2.1\n\nvariable (t) in\n/-- The operator `S_{1,\ud835\udd32} f(x)`, given in (7.1.4). -/\ndef boundaryOperator (u : \ud835\udd13 X) (f : X \u2192 \u2102) (x : X) : \u211d\u22650\u221e :=\n  \u2211 I : Grid X, (I : Set X).indicator (x := x) fun _ \u21a6 \u2211 J \u2208 \ud835\udcd9' t u (c I) (s I),\n  D ^ ((s J - s I) / (a : \u211d)) / volume (ball (c I) (16 * D ^ (s I))) * \u222b\u207b y in (J : Set X), \u2016f y\u2016\u208a\n\nprotected theorem MeasureTheory.Measurable.boundaryOperator {u : \ud835\udd13 X} {f : X \u2192 \u2102} :\n    Measurable (t.boundaryOperator u f) := by\n  refine Finset.measurable_sum _ (fun I _ \u21a6 ?_)\n  exact (Finset.measurable_sum _ (fun J _ \u21a6 measurable_const)).indicator coeGrid_measurable\n\n-- Currently unused; uncomment if needed.\n/- lemma boundaryOperator_lt_top (hf : BoundedCompactSupport f) : t.boundaryOperator u f x < \u22a4 := by\n  refine ENNReal.sum_lt_top.mpr (fun I _ \u21a6 ?_)\n  by_cases hx : x \u2208 (I : Set X)\n  \u00b7 rw [indicator_of_mem hx]\n    refine ENNReal.sum_lt_top.mpr (fun J hJ \u21a6 ENNReal.mul_lt_top ?_ hf.integrable.integrableOn.2)\n    apply ENNReal.div_lt_top (by simp)\n    exact ne_of_gt <| measure_ball_pos volume _ <| mul_pos (by norm_num) (defaultD_pow_pos a (s I))\n  \u00b7 simp [hx] -/\n\n/-- The indexing set for the collection of balls \ud835\udcd1, defined above Lemma 7.1.3. -/\ndef \ud835\udcd1 : Set (\u2115 \u00d7 Grid X) := Icc 0 (S + 5) \u00d7\u02e2 univ\n\n/-- The center function for the collection of balls \ud835\udcd1. -/\ndef c\ud835\udcd1 (z : \u2115 \u00d7 Grid X) : X := c z.2\n\n/-- The radius function for the collection of balls \ud835\udcd1. -/\ndef r\ud835\udcd1 (z : \u2115 \u00d7 Grid X) : \u211d := 2 ^ z.1 * D ^ s z.2\n\nlemma \ud835\udcd1_finite : (\ud835\udcd1 (X := X)).Finite :=\n  finite_Icc .. |>.prod finite_univ\n\n/-- Lemma 7.1.1, freely translated. -/\nlemma convex_scales (hu : u \u2208 t) : OrdConnected (t.\u03c3 u x : Set \u2124) := by\n  rw [ordConnected_def]; intro i mi j mj k mk\n  simp_rw [Finset.mem_coe, \u03c3, Finset.mem_image, Finset.mem_filter, Finset.mem_univ,\n    true_and] at mi mj \u22a2\n  obtain \u27e8p, \u27e8mp, xp, Qxp, sxp\u27e9, sp\u27e9 := mi\n  obtain \u27e8p'', \u27e8mp'', xp'', Qxp'', sxp''\u27e9, sp''\u27e9 := mj\n  have ilj : i \u2264 j := nonempty_Icc.mp \u27e8k, mk\u27e9\n  rw [\u2190 sp, \u2190 sp''] at ilj mk\n  obtain \u27e8K, sK, lK, Kl\u27e9 := Grid.exists_sandwiched (le_of_mem_of_mem ilj xp xp'') k mk\n  have := range_subset_iff.mp (biUnion_\u03a9 (i := K)) x\n  simp_rw [mem_preimage, mem_singleton_iff, mem_iUnion, exists_prop] at this\n  obtain \u27e8(p' : \ud835\udd13 X), (\ud835\udcd8p' : \ud835\udcd8 p' = K), Qxp'\u27e9 := this\n  rw [\u2190 \ud835\udcd8p'] at lK Kl sK; refine \u27e8p', ?_, sK\u27e9\n  have l\u2081 : p \u2264 p' := \u27e8lK,\n    (relative_fundamental_dyadic lK).resolve_left (not_disjoint_iff.mpr \u27e8_, Qxp, Qxp'\u27e9)\u27e9\n  have l\u2082 : p' \u2264 p'' := \u27e8Kl,\n    (relative_fundamental_dyadic Kl).resolve_left (not_disjoint_iff.mpr \u27e8_, Qxp', Qxp''\u27e9)\u27e9\n  refine \u27e8(t.ordConnected hu).out mp mp'' \u27e8l\u2081, l\u2082\u27e9, \u27e8(Grid.le_def.mp lK).1 xp, Qxp', ?_\u27e9\u27e9\n  exact Icc_subset_Icc sxp.1 sxp''.2 \u27e8(Grid.le_def.mp lK).2, (Grid.le_def.mp Kl).2\u27e9\n\n/-- Part of Lemma 7.1.2 -/\n@[simp]\nlemma biUnion_\ud835\udcd9 : \u22c3 J \u2208 \ud835\udcd9 \ud835\udd16, J = \u22c3 I : Grid X, (I : Set X) := by\n  refine subset_antisymm (iUnion\u2082_subset_iUnion ..) fun x mx \u21a6 ?_\n  simp_rw [mem_iUnion] at mx \u22a2; obtain \u27e8I, mI\u27e9 := mx\n  obtain \u27e8J, sJ, mJ\u27e9 :=\n    Grid.exists_containing_subcube _ \u27e8le_rfl, scale_mem_Icc.1\u27e9 mI\n  have : J \u2208 (\ud835\udcd9\u2080 \ud835\udd16).toFinset := by rw [mem_toFinset]; left; exact sJ\n  obtain \u27e8M, lM, maxM\u27e9 := (\ud835\udcd9\u2080 \ud835\udd16).toFinset.exists_le_maximal this\n  simp_rw [mem_toFinset] at maxM\n  use M, maxM, (Grid.le_def.mp lM).1 mJ\n\n/-- Part of Lemma 7.1.2 -/\n@[simp]\nlemma biUnion_\ud835\udcdb : \u22c3 J \u2208 \ud835\udcdb \ud835\udd16, J = \u22c3 I : Grid X, (I : Set X) := by\n  refine subset_antisymm (iUnion\u2082_subset_iUnion ..) fun x mx \u21a6 ?_\n  simp_rw [mem_iUnion] at mx \u22a2; obtain \u27e8I, mI\u27e9 := mx\n  obtain \u27e8J, sJ, mJ\u27e9 :=\n    Grid.exists_containing_subcube _ \u27e8le_rfl, scale_mem_Icc.1\u27e9 mI\n  have : J \u2208 (\ud835\udcdb\u2080 \ud835\udd16).toFinset := by rw [mem_toFinset]; left; exact sJ\n  obtain \u27e8M, lM, maxM\u27e9 := (\ud835\udcdb\u2080 \ud835\udd16).toFinset.exists_le_maximal this\n  simp_rw [mem_toFinset] at maxM\n  use M, maxM, (Grid.le_def.mp lM).1 mJ\n\n/-- Part of Lemma 7.1.2 -/\nlemma pairwiseDisjoint_\ud835\udcdb : (\ud835\udcdb \ud835\udd16).PairwiseDisjoint (fun I \u21a6 (I : Set X)) := fun I mI J mJ hn \u21a6 by\n  have : IsAntichain (\u00b7 \u2264 \u00b7) (\ud835\udcdb \ud835\udd16) := setOf_maximal_antichain _\n  exact (le_or_ge_or_disjoint.resolve_left (this mI mJ hn)).resolve_left (this mJ mI hn.symm)\n\n/-- The constant used in `first_tree_pointwise`.\nHas value `10 * 2 ^ (104 * a ^ 3)` in the blueprint. -/\n-- Todo: define this recursively in terms of previous constants\nirreducible_def C7_1_4 (a : \u2115) : \u211d\u22650 := 10 * 2 ^ (104 * (a : \u211d) ^ 3)\n\n-- Used in the proof of `exp_sub_one_le`, which is used to prove Lemma 7.1.4\nprivate lemma exp_Lipschitz : LipschitzWith 1 (fun (t : \u211d) \u21a6 exp (.I * t)) := by\n  have mul_I : Differentiable \u211d fun (t : \u211d) \u21a6 I * t := Complex.ofRealCLM.differentiable.const_mul I\n  refine lipschitzWith_of_nnnorm_deriv_le mul_I.cexp (fun x \u21a6 ?_)\n  have : (fun (t : \u211d) \u21a6 cexp (I * t)) = cexp \u2218 (fun (t : \u211d) \u21a6 I * t) := rfl\n  rw [this, deriv_comp x differentiableAt_exp (mul_I x), Complex.deriv_exp, deriv_const_mul_field']\n  simp_rw [show deriv ofReal x = 1 from ofRealCLM.hasDerivAt.deriv, mul_one]\n  rw [nnnorm_mul, nnnorm_I, mul_one, \u2190 norm_toNNReal, mul_comm, Complex.norm_exp_ofReal_mul_I]\n  exact Real.toNNReal_one.le\n\n-- Used in the proof of Lemma 7.1.4\n", "theoremStatement": "private lemma exp_sub_one_le (t : \u211d) : \u2016exp (.I * t) - 1\u2016 \u2264 \u2016t\u2016 ", "theoremName": "TileStructure.Forest.exp_sub_one_le", "fileCreated": {"commit": "5e49c3692f6d7344434caa7eea5f412f0ee35863", "date": "2024-09-27"}, "theoremCreated": {"commit": "3298f748e9eb26a242da5ee38cb50dc55e604935", "date": "2025-01-08"}, "file": "carleson/Carleson/ForestOperator/PointwiseEstimate.lean", "module": "Carleson.ForestOperator.PointwiseEstimate", "jsonFile": "Carleson.ForestOperator.PointwiseEstimate.jsonl", "positionMetadata": {"lineInFile": 310, "tokenPositionInFile": 15428, "theoremPositionInFile": 41}, "dependencyMetadata": {"inFilePremises": null, "numInFilePremises": null, "repositoryPremises": null, "numRepositoryPremises": null, "numPremises": null}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simpa [enorm_eq_nnnorm] using exp_Lipschitz t 0", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 55}}
{"srcContext": "/-\nCopyright (c) 2024 James Sundstrom. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: James Sundstrom\n-/\nimport Mathlib.MeasureTheory.Constructions.BorelSpace.Metric\n\n/-!\n# Annulus\n\nIn this file we define an annulus in a pseudometric space `X` to be a set consisting of all `y`\nsuch that `dist x y` lies in an interval between `r` and `R`. An annulus is defined for each type\nof interval (`Ioo`, `Ioc`, etc.) with a parallel naming scheme, except that we do not define annuli\nfor `Iio` and `Ico`, as they would be balls.\n\nWe also define `EAnnulus` similarly using `edist` instead of `dist`.\n\n## Tags\n\nannulus, eannulus\n-/\n\nopen Set Metric ENNReal\n\nvariable {X : Type*} [PseudoMetricSpace X]\n\nnamespace Set\n\nnamespace Annulus\n\ndef oo (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d) := {y | dist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d) := {y | dist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d) := {y | dist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d) := {y | dist x y \u2208 Ici r}\n\nlemma oo_eq {x : X} {r R : \u211d} : oo x r R = ball x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oo, dist_comm, and_comm]\n\nlemma oc_eq {x : X} {r R : \u211d} : oc x r R = closedBall x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oc, dist_comm, and_comm]\n\nlemma co_eq {x : X} {r R : \u211d} : co x r R = ball x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [co, dist_comm, and_comm]\n\nlemma cc_eq {x : X} {r R : \u211d} : cc x r R = closedBall x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [cc, dist_comm, and_comm]\n\nlemma oi_eq {x : X} {r : \u211d} : oi x r = (closedBall x r)\u1d9c := by\n  ext; simp [oi, dist_comm]\n\nlemma ci_eq {x : X} {r : \u211d} : ci x r = (ball x r)\u1d9c := by\n  ext; simp [ci, dist_comm]\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\n", "theoremStatement": "lemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 ", "theoremName": "Set.Annulus.co_subset_co", "fileCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "theoremCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "file": "carleson/Carleson/ToMathlib/Annulus.lean", "module": "Carleson.ToMathlib.Annulus", "jsonFile": "Carleson.ToMathlib.Annulus.jsonl", "positionMetadata": {"lineInFile": 125, "tokenPositionInFile": 4392, "theoremPositionInFile": 30}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 1, "numPremises": 20}, "proofMetadata": {"hasProof": true, "proof": ":=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 61}}
{"srcContext": "/-\nCopyright (c) 2024 James Sundstrom. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: James Sundstrom\n-/\nimport Mathlib.MeasureTheory.Constructions.BorelSpace.Metric\n\n/-!\n# Annulus\n\nIn this file we define an annulus in a pseudometric space `X` to be a set consisting of all `y`\nsuch that `dist x y` lies in an interval between `r` and `R`. An annulus is defined for each type\nof interval (`Ioo`, `Ioc`, etc.) with a parallel naming scheme, except that we do not define annuli\nfor `Iio` and `Ico`, as they would be balls.\n\nWe also define `EAnnulus` similarly using `edist` instead of `dist`.\n\n## Tags\n\nannulus, eannulus\n-/\n\nopen Set Metric ENNReal\n\nvariable {X : Type*} [PseudoMetricSpace X]\n\nnamespace Set\n\nnamespace Annulus\n\ndef oo (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d) := {y | dist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d) := {y | dist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d) := {y | dist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d) := {y | dist x y \u2208 Ici r}\n\nlemma oo_eq {x : X} {r R : \u211d} : oo x r R = ball x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oo, dist_comm, and_comm]\n\nlemma oc_eq {x : X} {r R : \u211d} : oc x r R = closedBall x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oc, dist_comm, and_comm]\n\nlemma co_eq {x : X} {r R : \u211d} : co x r R = ball x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [co, dist_comm, and_comm]\n\nlemma cc_eq {x : X} {r R : \u211d} : cc x r R = closedBall x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [cc, dist_comm, and_comm]\n\nlemma oi_eq {x : X} {r : \u211d} : oi x r = (closedBall x r)\u1d9c := by\n  ext; simp [oi, dist_comm]\n\nlemma ci_eq {x : X} {r : \u211d} : ci x r = (ball x r)\u1d9c := by\n  ext; simp [ci, dist_comm]\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : co x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma co_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : co x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\nlemma cc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : cc x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma cc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : cc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\n@[simp]\nlemma oc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    oc x r r' \u222a oo x r' R = oo x r R := by\n  ext; simp_rw [oc, oo, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioo_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    oc x r r' \u222a oc x r' R = oc x r R := by\n  ext; simp_rw [oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_co {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a co x r' R = oo x r R := by\n  ext; simp_rw [oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ico_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a cc x r' R = oc x r R := by\n  ext; simp_rw [oo, cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Icc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    cc x r r' \u222a oo x r' R = co x r R := by\n  ext; simp_rw [cc, oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioo_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    cc x r r' \u222a oc x r' R = cc x r R := by\n  ext; simp_rw [cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_co {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a co x r' R = co x r R := by\n  ext; simp_rw [co, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ico_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a cc x r' R = cc x r R := by\n  ext; simp_rw [co, cc, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Icc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : oc x r R \u222a oi x R = oi x r := by\n  ext; simp_rw [oc, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioi_eq_Ioi h]\n\n@[simp]\nlemma oo_union_ci {x : X} {r R : \u211d} (h : r < R) :\n    oo x r R \u222a ci x R = oi x r := by\n  ext; simp_rw [oo, ci, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ici_eq_Ioi h]\n\n@[simp]\nlemma cc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : cc x r R \u222a oi x R = ci x r := by\n  ext; simp_rw [cc, oi, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioi_eq_Ici h]\n\n@[simp]\nlemma co_union_ci {x : X} {r R : \u211d} (h : r \u2264 R) : co x r R \u222a ci x R = ci x r := by\n  ext; simp_rw [co, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ici_eq_Ici h]\n\n\nvariable [MeasurableSpace X] [OpensMeasurableSpace X]\n\n@[measurability]\nlemma measurableSet_oo {x : X} {r R : \u211d} : MeasurableSet (oo x r R) := by\n  rw [oo_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oc {x : X} {r R : \u211d} : MeasurableSet (oc x r R) := by\n rw [oc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_co {x : X} {r R : \u211d} : MeasurableSet (co x r R) := by\n  rw [co_eq]; measurability\n\n@[measurability]\nlemma measurableSet_cc {x : X} {r R : \u211d} : MeasurableSet (cc x r R) := by\n rw [cc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oi {x : X} {r : \u211d} : MeasurableSet (oi x r) := by\n  rw [oi_eq]; measurability\n\n@[measurability]\nlemma measurableSet_ci {x : X} {r : \u211d} : MeasurableSet (ci x r) := by\n  rw [ci_eq]; measurability\n\nend Annulus\n\nnamespace EAnnulus\n\ndef oo (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ici r}\n\n\nlemma oo_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oo x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oo x r R := by\n  simp_rw [oo, Annulus.oo, edist_dist, mem_Ioo, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma oc_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [oc, Annulus.oc, edist_dist, mem_Ioc, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  \u00b7 have R_le_r := (lt_of_lt_of_le (lt_of_not_ge hR) hr).le\n    rw [Annulus.oc_eq_empty R_le_r]\n    refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n    exact not_le_of_gt (lt_of_le_of_lt (ENNReal.ofReal_le_ofReal R_le_r) hy.1) hy.2\n\nlemma co_eq_annulus {x : X} {r R : \u211d} :\n    co x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.co x r R := by\n  simp_rw [co, Annulus.co, edist_dist, mem_Ico, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma cc_eq_annulus {x : X} {r R : \u211d} (h : r > 0 \u2228 R \u2265 0) :\n    cc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.cc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [cc, Annulus.cc, edist_dist, mem_Icc, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  have r0 := h.resolve_right hR\n  have R_lt_r := (lt_of_not_ge hR).trans r0\n  rw [Annulus.cc_eq_empty R_lt_r]\n  refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n  exact not_le_of_gt ((ENNReal.ofReal_lt_ofReal_iff r0).mpr R_lt_r) (hy.1.trans hy.2)\n\nlemma oi_eq_annulus {x : X} {r : \u211d} (hr : r \u2265 0) : oi x (ENNReal.ofReal r) = Annulus.oi x r := by\n  simp_rw [oi, Annulus.oi, edist_dist, mem_Ioi, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr]\n\nlemma ci_eq_annulus {x : X} {r : \u211d} : ci x (ENNReal.ofReal r) = Annulus.ci x r := by\n  simp_rw [ci, Annulus.ci, edist_dist, mem_Ici, ENNReal.ofReal_le_ofReal_iff dist_nonneg]\n\n\nlemma oo_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oo x r R = ball x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oo, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma oc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oc x r R = closedBall x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oc, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma co_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    co x r R = ball x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [co, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma cc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    cc x r R = closedBall x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [cc, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma oi_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : oi x r = (closedBall x r.toReal)\u1d9c := by\n  ext; simp [oi, edist_dist, dist_comm, lt_ofReal_iff_toReal_lt hr.ne]\n\nlemma ci_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : ci x r = (ball x r.toReal)\u1d9c := by\n  ext; simp [ci, edist_dist, dist_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg]\n\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n@[simp]\nlemma cc_top_eq_empty {x : X} {R : \u211d\u22650\u221e} : cc x \u22a4 R = \u2205 :=\n  eq_empty_of_forall_not_mem (fun y hy \u21a6 (edist_ne_top x y) (top_le_iff.mp hy.1))\n\n@[simp]\nlemma oi_eq_empty {x : X} : oi x \u22a4 = \u2205 := by simp [oi, edist_dist]\n\n@[simp]\nlemma ci_eq_empty {x : X} : ci x \u22a4 = \u2205 := by simp [ci, edist_dist]\n\n\nlemma oo_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) :\n    oo x r \u22a4 = (closedBall x r.toReal)\u1d9c := by\n  ext; simpa [oo, edist_dist, dist_comm] using lt_ofReal_iff_toReal_lt hr.ne\n\nlemma oc_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) :\n    oc x r \u22a4 = (closedBall x r.toReal)\u1d9c := by\n  ext; simpa [oc, edist_dist, dist_comm] using lt_ofReal_iff_toReal_lt hr.ne\n\nlemma co_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : co x r \u22a4 = (ball x r.toReal)\u1d9c := by\n  ext; simpa [co, edist_dist, dist_comm] using le_ofReal_iff_toReal_le hr.ne dist_nonneg\n\nlemma cc_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : cc x r \u22a4 = (ball x r.toReal)\u1d9c := by\n  ext; simpa [cc, edist_dist, dist_comm] using le_ofReal_iff_toReal_le hr.ne dist_nonneg\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) : co x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma co_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : co x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\nlemma cc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) : cc x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma cc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : cc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\n", "theoremStatement": "@[simp]\nlemma oc_union_oo {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    oc x r r' \u222a oo x r' R = oo x r R ", "theoremName": "Set.EAnnulus.oc_union_oo", "fileCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "theoremCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "file": "carleson/Carleson/ToMathlib/Annulus.lean", "module": "Carleson.ToMathlib.Annulus", "jsonFile": "Carleson.ToMathlib.Annulus.jsonl", "positionMetadata": {"lineInFile": 456, "tokenPositionInFile": 18014, "theoremPositionInFile": 111}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 47}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  ext; simp_rw [oc, oo, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioo_eq_Ioo h\u2081 h\u2082]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 95}}
{"srcContext": "import Carleson.ToMathlib.WeakType\nimport Mathlib.Analysis.SpecialFunctions.ImproperIntegrals\n\n/-! This file contains a proof of the Marcinkiewisz real interpolation theorem.\n    The proof roughly follows Folland, Real Analysis. Modern Techniques and Their Applications,\n    section 6.4, theorem 6.28, but a different truncation is used, and some estimates instead\n    follow the technique as e.g. described in [Duoandikoetxea, Fourier Analysis, 2000].\n\n    The file consists of the following sections:\n    - Convenience results for working with (interpolated) exponents\n    - Results about the particular choice of exponent\n    - Interface for using cutoff functions\n    - Results about the particular choice of scale\n    - Some tools for measure theory computations\n    - Results about truncations of a function\n    - Measurability properties of truncations\n    - Truncations and Lp spaces\n    - Some results about the integrals of truncations\n    - Minkowski's integral inequality\n    - Apply Minkowski's integral inequality to truncations\n    - Weaktype estimates applied to truncations\n    - Definitions\n    - Proof of the real interpolation theorem\n-/\n\nnoncomputable section\n\nopen ENNReal Real Set MeasureTheory\n\n-- Note (F): can we make `t : \u211d\u22650\u221e` for a large part of the proof?\nvariable {p\u2080 q\u2080 p\u2081 q\u2081 p q : \u211d\u22650\u221e} {t : \u211d}\n\n/-! ## Convenience results for working with (interpolated) exponents\n-/\nnamespace ComputationsInterpolatedExponents\n\n-- unused\nlemma ofReal_mem_Ioo_0_1 (h : t \u2208 Ioo 0 1) : ENNReal.ofReal t \u2208 Ioo 0 1 :=\n  \u27e8ofReal_pos.mpr h.1, ofReal_lt_one.mpr h.2\u27e9\n\nlemma ENNReal_preservation_positivity\u2080 (ht : t \u2208 Ioo 0 1) (hpq : p \u2260 \u22a4 \u2228 q \u2260 \u22a4) :\n    0 < (1 - ENNReal.ofReal t) * p\u207b\u00b9 + ENNReal.ofReal t * q\u207b\u00b9 := by\n  have t_mem : ENNReal.ofReal t \u2208 Ioo 0 1 :=\n    \u27e8ofReal_pos.mpr ht.1, ENNReal.ofReal_one \u25b8 (ofReal_lt_ofReal_iff zero_lt_one).mpr ht.2\u27e9\n  obtain dir|dir := hpq\n  \u00b7 exact Left.add_pos_of_pos_of_nonneg (mul_pos ((tsub_pos_of_lt t_mem.2).ne')\n      (ENNReal.inv_ne_zero.mpr dir)) (zero_le _)\n  \u00b7 exact Right.add_pos_of_nonneg_of_pos (zero_le _)\n      (mul_pos ((ofReal_pos.mpr ht.1).ne') (ENNReal.inv_ne_zero.mpr dir))\n\nlemma ENNReal_preservation_positivity (ht : t \u2208 Ioo 0 1) (hpq : p \u2260 q) :\n    0 < (1 - ENNReal.ofReal t) * p\u207b\u00b9 + ENNReal.ofReal t * q\u207b\u00b9 := by\n  apply ENNReal_preservation_positivity\u2080 ht\n  cases (lt_or_gt_of_ne hpq) <;> exact Ne.ne_or_ne \u22a4 hpq\n\nlemma ENNReal_preservation_positivity' (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) : p > 0 := by\n  rw [\u2190 inv_inv p, hp]\n  simp [ENNReal.mul_eq_top, sub_eq_zero, hp\u2080.ne', hp\u2081.ne']\n\nlemma interp_exp_ne_top (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (ht : t \u2208 Ioo 0 1)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) : p \u2260 \u22a4 :=\n  ENNReal.inv_ne_zero.mp <| hp \u25b8 (ENNReal_preservation_positivity ht hp\u2080p\u2081).ne'\n\nlemma interp_exp_ne_top' (hp\u2080p\u2081 : p\u2080 \u2260 \u22a4 \u2228 p\u2081 \u2260 \u22a4) (ht : t \u2208 Ioo 0 1)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) : p \u2260 \u22a4 :=\n  ENNReal.inv_ne_zero.mp (hp \u25b8 (ENNReal_preservation_positivity\u2080 ht hp\u2080p\u2081).ne')\n\nlemma interp_exp_eq (hp\u2080p\u2081 : p\u2080 = p\u2081)\n    (ht : t \u2208 Ioo 0 1)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    p\u2080 = p := by\n  rw [\u2190 inv_inv (a := p), hp, \u2190 hp\u2080p\u2081, \u2190 add_mul,\n    tsub_add_cancel_of_le <| ofReal_lt_one.mpr ht.2 |>.le, one_mul, inv_inv]\n\nlemma interp_exp_lt_top (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (ht : t \u2208 Ioo 0 1)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) : p < \u22a4 :=\n  Ne.lt_top <| interp_exp_ne_top hp\u2080p\u2081 ht hp\n\nlemma interp_exp_lt_top' (hp\u2080p\u2081 : p\u2080 \u2260 \u22a4 \u2228 p\u2081 \u2260 \u22a4)\n    (ht : t \u2208 Ioo 0 1)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) : p < \u22a4 :=\n  Ne.lt_top <| interp_exp_ne_top' hp\u2080p\u2081 ht hp\n\nlemma interp_exp_between (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 < p\u2081) (ht : t \u2208 Ioo 0 1)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) : p \u2208 Ioo p\u2080 p\u2081 := by\n  refine \u27e8?_, ?_\u27e9 <;> apply ENNReal.inv_lt_inv.mp\n  \u00b7 rw [hp]\n    have : p\u2080\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2080\u207b\u00b9 := by\n      rw [\u2190 add_mul, tsub_add_eq_max, max_eq_left_of_lt, one_mul]\n      exact ofReal_lt_one.mpr ht.2\n    nth_rw 2 [this]\n    gcongr\n    \u00b7 exact mul_ne_top (sub_ne_top top_ne_one.symm) (inv_ne_top.mpr hp\u2080.ne')\n    \u00b7 exact (ofReal_pos.mpr ht.1).ne'\n    \u00b7 exact coe_ne_top\n  \u00b7 rw [hp]\n    have : p\u2081\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2081\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9 := by\n      rw [\u2190 add_mul, tsub_add_eq_max, max_eq_left_of_lt, one_mul]\n      exact ofReal_lt_one.mpr ht.2\n    nth_rw 1 [this]\n    gcongr\n    \u00b7 exact mul_ne_top coe_ne_top (inv_ne_top.mpr hp\u2081.ne')\n    \u00b7 exact (tsub_pos_iff_lt.mpr (ofReal_lt_one.mpr ht.2)).ne'\n    \u00b7 exact coe_ne_top\n\nlemma one_le_interp_exp_aux (hp\u2080 : 1 \u2264 p\u2080) (hp\u2081 : 1 \u2264 p\u2081) (hp\u2080p\u2081 : p\u2080 < p\u2081) (ht : t \u2208 Ioo 0 1)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) : 1 \u2264 p :=\n  hp\u2080.trans_lt\n    (interp_exp_between (zero_lt_one.trans_le hp\u2080) (zero_lt_one.trans_le hp\u2081) hp\u2080p\u2081 ht hp).1 |>.le\n\nlemma switch_exponents (ht : t \u2208 Ioo 0 1)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    p\u207b\u00b9 = (1 - ENNReal.ofReal (1 - t)) * p\u2081\u207b\u00b9 + ENNReal.ofReal (1 - t) * p\u2080\u207b\u00b9 := by\n  rw [add_comm, \u2190 ofReal_one, \u2190 ofReal_sub, _root_.sub_sub_cancel, ofReal_sub _ ht.1.le, ofReal_one]\n  \u00b7 exact hp\n  \u00b7 exact (Ioo.one_sub_mem ht).1.le\n\nlemma one_le_toReal {a : \u211d\u22650\u221e} (ha\u2081 : 1 \u2264 a) (ha\u2082 : a < \u22a4) : 1 \u2264 a.toReal :=\n  toReal_mono ha\u2082.ne_top ha\u2081\n\nlemma one_le_interp (hp\u2080 : 1 \u2264 p\u2080) (hp\u2081 : 1 \u2264 p\u2081)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (ht : t \u2208 Ioo 0 1)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) : 1 \u2264 p := by\n  rcases (lt_or_gt_of_ne hp\u2080p\u2081) with p\u2080lt_p\u2081 | p\u2081lt_p\u2080\n  \u00b7 exact one_le_interp_exp_aux hp\u2080 hp\u2081 p\u2080lt_p\u2081 ht hp\n  \u00b7 exact one_le_interp_exp_aux hp\u2081 hp\u2080 p\u2081lt_p\u2080 (Ioo.one_sub_mem ht) (switch_exponents ht hp)\n\nlemma one_le_interp_toReal (hp\u2080 : 1 \u2264 p\u2080) (hp\u2081 : 1 \u2264 p\u2081)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (ht : t \u2208 Ioo 0 1)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) : 1 \u2264 p.toReal :=\n  one_le_toReal (one_le_interp hp\u2080 hp\u2081 hp\u2080p\u2081 ht hp) (Ne.lt_top (interp_exp_ne_top hp\u2080p\u2081 ht hp))\n\nlemma coe_rpow_ne_top {a : \u211d} {q : \u211d} (hq : q \u2265 0): ENNReal.ofReal a ^ q \u2260 \u22a4 :=\n  rpow_ne_top_of_nonneg hq coe_ne_top\n\n-- Note this lemma can directly be applied to elements of `\u211d\u22650` as well\nlemma coe_rpow_ne_top' {a : \u211d} {q : \u211d} (hq : 0 < q): ENNReal.ofReal a ^ q \u2260 \u22a4 :=\n  coe_rpow_ne_top hq.le\n\nlemma coe_pow_pos {a : \u211d} {q : \u211d} (ha : a > 0) : ENNReal.ofReal a ^ q > 0 :=\n  ENNReal.rpow_pos (ofReal_pos.mpr ha) coe_ne_top\n\nlemma rpow_ne_top' {a : \u211d\u22650\u221e} {q : \u211d} (ha : a \u2260 0) (ha' : a \u2260 \u22a4)  : a ^ q \u2260 \u22a4 := by\n  intro h\n  rcases ENNReal.rpow_eq_top_iff.mp h with \u27e8a_zero, _\u27e9 | \u27e8a_top, _\u27e9\n  \u00b7 exact (ha a_zero).elim\n  \u00b7 exact (ha' a_top).elim\n\nlemma exp_toReal_pos' {q : \u211d\u22650\u221e} (hq : q \u2265 1) (hq' : q < \u22a4) : q.toReal > 0 :=\n  toReal_pos (lt_of_lt_of_le zero_lt_one hq).ne' hq'.ne_top\n\nlemma ne_top_of_Ico {p q r : \u211d\u22650\u221e} (hq : q \u2208 Ico p r) : q \u2260 \u22a4 := hq.2.ne_top\n\nlemma lt_top_of_Ico {p q r : \u211d\u22650\u221e} (hq : q \u2208 Ico p r) : q < \u22a4 := (ne_top_of_Ico hq).lt_top\n\nlemma ne_top_of_Ioo {p q r : \u211d\u22650\u221e} (hq : q \u2208 Ioo p r) : q \u2260 \u22a4 := hq.2.ne_top\n\nlemma lt_top_of_Ioo {p q r : \u211d\u22650\u221e} (hq : q \u2208 Ioo p r) : q < \u22a4 := (ne_top_of_Ioo hq).lt_top\n\nlemma ne_top_of_Ioc {p q r : \u211d\u22650\u221e} (hq : q \u2208 Ioc p r) (hr : r < \u22a4) : q \u2260 \u22a4 :=\n  hq.2.trans_lt hr |>.ne_top\n\nlemma pos_of_rb_Ioc {p q r : \u211d\u22650\u221e} (hr : q \u2208 Ioc p r) : 0 < r :=\n  zero_le p |>.trans_lt hr.1 |>.trans_le hr.2\n\nlemma exp_toReal_ne_zero {q : \u211d\u22650\u221e} (hq : q \u2265 1) (hq' : q < \u22a4) : q.toReal \u2260 0 :=\n  (exp_toReal_pos' hq hq').ne'\n\n-- TODO: remove the top one?\nlemma exp_toReal_ne_zero' {q : \u211d\u22650\u221e} (hq : q > 0) (hq' : q \u2260 \u22a4) : q.toReal \u2260 0 :=\n  (toReal_pos hq.ne' hq').ne'\n\nlemma exp_toReal_ne_zero_of_Ico {q p : \u211d\u22650\u221e} (hq : q \u2208 Ico 1 p) : q.toReal \u2260 0 :=\n  exp_toReal_ne_zero hq.1 (lt_top_of_Ico hq)\n\nlemma pos_of_Ioo {p q r : \u211d\u22650\u221e} (hq : q \u2208 Ioo p r) : q > 0 := pos_of_gt hq.1\n\nlemma ne_zero_of_Ioo {p q r : \u211d\u22650\u221e} (hq : q \u2208 Ioo p r) : q \u2260 0 := (pos_of_gt hq.1).ne'\n\nlemma pos_of_Icc_1 {p q : \u211d\u22650\u221e} (hp : p \u2208 Icc 1 q) : p > 0 := lt_of_lt_of_le zero_lt_one hp.1\n\nlemma pos_of_ge_1 {p : \u211d\u22650\u221e} (hp : 1 \u2264 p) : p > 0 := lt_of_lt_of_le zero_lt_one hp\n\nlemma pos_rb_of_Icc_1_inh {p q : \u211d\u22650\u221e} (hp : p \u2208 Icc 1 q) : q > 0 :=\n  lt_of_lt_of_le zero_lt_one (le_trans hp.1 hp.2)\n\nlemma toReal_pos_of_Ioo {q p r : \u211d\u22650\u221e} (hp : p \u2208 Ioo q r) : p.toReal > 0 :=\n  toReal_pos (ne_zero_of_lt hp.1) hp.2.ne_top\n\nlemma toReal_ne_zero_of_Ioo {q p r : \u211d\u22650\u221e} (hp : p \u2208 Ioo q r) : p.toReal \u2260 0 :=\n  toReal_ne_zero.mpr \u27e8ne_zero_of_lt hp.1, hp.2.ne_top\u27e9\n\n-- TODO: check which ones are actually used\nlemma eq_of_rpow_eq (a b: \u211d\u22650\u221e) (c : \u211d) (hc : c \u2260 0) (h : a ^ c = b ^ c) : a = b := by\n  rw [\u2190 ENNReal.rpow_rpow_inv hc a, \u2190 ENNReal.rpow_rpow_inv hc b]\n  exact congrFun (congrArg HPow.hPow h) c\u207b\u00b9\n\nlemma le_of_rpow_le {a b: \u211d\u22650\u221e} {c : \u211d} (hc : c > 0) (h : a ^ c \u2264 b ^ c) : a \u2264 b := by\n  rw [\u2190 ENNReal.rpow_rpow_inv hc.ne' a, \u2190 ENNReal.rpow_rpow_inv hc.ne' b]\n  exact (ENNReal.rpow_le_rpow_iff (inv_pos_of_pos hc)).mpr h\n\n-- TODO : decide if this is wanted\n-- local instance : Coe \u211d \u211d\u22650\u221e where\n--   coe x := ENNReal.ofReal x\n\nlemma coe_inv_exponent (hp\u2080 : p\u2080 > 0) : ENNReal.ofReal (p\u2080\u207b\u00b9.toReal) = p\u2080\u207b\u00b9 :=\n  ofReal_toReal_eq_iff.mpr (inv_ne_top.mpr hp\u2080.ne')\n\nlemma inv_of_interpolated_pos' (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (ht : t \u2208 Ioo 0 1)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) : 0 < p\u207b\u00b9 :=\n  ENNReal.inv_pos.mpr (interp_exp_ne_top hp\u2080p\u2081 ht hp)\n\n-- TODO: remove, this is redundant, but for now mirror the development for reals...\nlemma interpolated_pos' (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9): 0 < p :=\n  ENNReal_preservation_positivity' hp\u2080 hp\u2081 hp\n\nlemma exp_toReal_pos (hp\u2080 : p\u2080 > 0) (hp\u2080' : p\u2080 \u2260 \u22a4) : 0 < p\u2080.toReal :=\n  toReal_pos hp\u2080.ne' hp\u2080'\n\nlemma interp_exp_in_Ioo_zero_top (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 \u22a4 \u2228 p\u2081 \u2260 \u22a4)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) : p \u2208 Ioo 0 \u22a4 :=\n  \u27e8interpolated_pos' hp\u2080 hp\u2081 hp, interp_exp_lt_top' hp\u2080p\u2081 ht hp\u27e9\n\nlemma inv_toReal_pos_of_ne_top (hp\u2080 : p\u2080 > 0) (hp' : p\u2080 \u2260 \u22a4) : p\u2080\u207b\u00b9.toReal > 0 :=\n  toReal_inv _ \u25b8 inv_pos_of_pos (exp_toReal_pos hp\u2080 hp')\n\nlemma inv_toReal_ne_zero_of_ne_top (hp\u2080 : p\u2080 > 0) (hp' : p\u2080 \u2260 \u22a4) : p\u2080\u207b\u00b9.toReal \u2260 0 :=\n  (inv_toReal_pos_of_ne_top hp\u2080 hp').ne'\n\nlemma interp_exp_toReal_pos (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    : 0 < p.toReal :=\n  toReal_pos (interpolated_pos' hp\u2080 hp\u2081 hp).ne' (interp_exp_ne_top hp\u2080p\u2081 ht hp)\n\nlemma interp_exp_toReal_pos' (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hp\u2080p\u2081 : p\u2080 \u2260 \u22a4 \u2228 p\u2081 \u2260 \u22a4) : 0 < p.toReal :=\n  toReal_pos (interpolated_pos' hp\u2080 hp\u2081 hp).ne' (interp_exp_ne_top' hp\u2080p\u2081 ht hp)\n\nlemma interp_exp_inv_pos (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0)\n    (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    0 < p\u207b\u00b9.toReal :=\n  toReal_inv _ \u25b8 inv_pos_of_pos (interp_exp_toReal_pos ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp)\n\nlemma interp_exp_inv_ne_zero (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0)\n    (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) : p\u207b\u00b9.toReal \u2260 0 :=\n  (interp_exp_inv_pos ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp).ne'\n\nlemma preservation_interpolation (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0)\n    (hp\u2081 : p\u2081 > 0) (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    p\u207b\u00b9.toReal = (1 - t) * (p\u2080\u207b\u00b9).toReal + t * (p\u2081\u207b\u00b9).toReal := by\n  rw [\u2190 one_toReal, \u2190 toReal_ofReal ht.1.le, \u2190 ENNReal.toReal_sub_of_le]\n  \u00b7 rw [\u2190 toReal_mul, \u2190 toReal_mul, \u2190 toReal_add]\n    \u00b7 exact congrArg ENNReal.toReal hp\n    \u00b7 exact mul_ne_top (sub_ne_top (top_ne_one.symm)) (inv_ne_top.mpr hp\u2080.ne')\n    \u00b7 exact mul_ne_top coe_ne_top (inv_ne_top.mpr hp\u2081.ne')\n  \u00b7 exact ofReal_le_one.mpr ht.2.le\n  \u00b7 exact top_ne_one.symm\n\nlemma preservation_positivity_inv_toReal (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) :\n    0 < (1 - t) * (p\u2080\u207b\u00b9).toReal + t * (p\u2081\u207b\u00b9).toReal := by\n  rcases (eq_or_ne p\u2080 \u22a4) with p\u2080eq_top | p\u2080ne_top\n  \u00b7 rw [p\u2080eq_top]\n    simp only [inv_top, zero_toReal, mul_zero, zero_add]\n    apply mul_pos ht.1\n    rw [toReal_inv]\n    refine inv_pos_of_pos (exp_toReal_pos hp\u2081 ?_)\n    rw [p\u2080eq_top] at hp\u2080p\u2081\n    exact hp\u2080p\u2081.symm\n  \u00b7 exact add_pos_of_pos_of_nonneg (mul_pos (Ioo.one_sub_mem ht).1 (toReal_inv _ \u25b8 inv_pos_of_pos\n      (exp_toReal_pos hp\u2080 p\u2080ne_top))) (mul_nonneg ht.1.le toReal_nonneg)\n\nlemma ne_inv_toReal_exponents (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) :\n    (p\u2080\u207b\u00b9.toReal \u2260 p\u2081\u207b\u00b9.toReal) := by\n  refine fun h \u21a6 hp\u2080p\u2081 ?_\n  rw [\u2190 inv_inv p\u2080, \u2190 inv_inv p\u2081]\n  apply congrArg Inv.inv\n  rw [\u2190 ofReal_toReal_eq_iff.mpr (inv_ne_top.mpr hp\u2080.ne'),\n    \u2190 ofReal_toReal_eq_iff.mpr (inv_ne_top.mpr hp\u2081.ne')]\n  exact congrArg ENNReal.ofReal h\n\nlemma ne_inv_toReal_exp_interp_exp (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0)\n  (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    (p\u2080\u207b\u00b9.toReal \u2260 p\u207b\u00b9.toReal) := by\n  rw [preservation_interpolation ht hp\u2080 hp\u2081 hp,\n    \u2190 sub_ne_zero, _root_.sub_mul, one_mul, add_comm_sub, sub_add_eq_sub_sub, sub_self, zero_sub,\n    neg_sub, \u2190 _root_.mul_sub]\n  exact mul_ne_zero ht.1.ne' (sub_ne_zero_of_ne (ne_inv_toReal_exponents hp\u2080 hp\u2081 hp\u2080p\u2081))\n\nlemma ne_sub_toReal_exp (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) :\n    p\u2081\u207b\u00b9.toReal - p\u2080\u207b\u00b9.toReal \u2260 0 :=\n  sub_ne_zero_of_ne (ne_inv_toReal_exponents hp\u2080 hp\u2081 hp\u2080p\u2081).symm\n\nlemma ne_toReal_exp_interp_exp (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    p\u2080.toReal \u2260 p.toReal := by\n  refine fun h \u21a6 ne_inv_toReal_exp_interp_exp ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp ?_\n  repeat rw [toReal_inv _]\n  exact congrArg Inv.inv h\n\nlemma ne_toReal_exp_interp_exp\u2081 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    p.toReal \u2260 p\u2081.toReal :=\n  (ne_toReal_exp_interp_exp (Ioo.one_sub_mem ht) hp\u2081 hp\u2080 (Ne.symm hp\u2080p\u2081)\n    (switch_exponents ht hp)).symm\n\nlemma ofReal_inv_interp_sub_exp_pos\u2081 (ht : t \u2208 Ioo 0 1) (hq\u2080 : q\u2080 > 0) (hq\u2081 : q\u2081 > 0)\n    (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) :\n    ENNReal.ofReal |q.toReal - q\u2081.toReal|\u207b\u00b9 > 0 :=\n  ofReal_pos.mpr (inv_pos_of_pos (abs_sub_pos.mpr (ne_toReal_exp_interp_exp\u2081 ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq)))\n\nlemma ofReal_inv_interp_sub_exp_pos\u2080 (ht : t \u2208 Ioo 0 1) (hq\u2080 : q\u2080 > 0) (hq\u2081 : q\u2081 > 0)\n    (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081) (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) :\n    ENNReal.ofReal |q.toReal - q\u2080.toReal|\u207b\u00b9 > 0 :=\n  ofReal_pos.mpr (inv_pos_of_pos (abs_sub_pos.mpr (Ne.symm\n    (ne_toReal_exp_interp_exp ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq))))\n\nlemma exp_lt_iff (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    p < p\u2080 \u2194 p\u2081 < p\u2080 := by\n  rcases lt_or_gt_of_ne hp\u2080p\u2081 with p\u2080lt_p\u2081 | p\u2081lt_p\u2080\n  \u00b7 exact \u27e8fun h \u21a6 (not_le_of_gt h (le_of_lt (interp_exp_between hp\u2080 hp\u2081 p\u2080lt_p\u2081 ht hp).1)).elim,\n      fun h \u21a6 (not_le_of_gt h p\u2080lt_p\u2081.le).elim\u27e9\n  \u00b7 exact \u27e8fun _ \u21a6 p\u2081lt_p\u2080,\n      fun _ \u21a6 (interp_exp_between hp\u2081 hp\u2080 p\u2081lt_p\u2080 (Ioo.one_sub_mem ht) (switch_exponents ht hp)).2\u27e9\n\nlemma exp_gt_iff (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    p\u2080 < p \u2194 p\u2080 < p\u2081 := by\n  rcases lt_or_gt_of_ne hp\u2080p\u2081 with p\u2080lt_p\u2081 | p\u2081lt_p\u2080\n  \u00b7 exact \u27e8fun _ \u21a6 p\u2080lt_p\u2081, fun _ \u21a6 (interp_exp_between hp\u2080 hp\u2081 p\u2080lt_p\u2081 ht hp).1\u27e9\n  \u00b7 exact \u27e8fun h \u21a6 (not_le_of_gt h (interp_exp_between hp\u2081 hp\u2080 p\u2081lt_p\u2080\n      (Ioo.one_sub_mem ht) (switch_exponents ht hp)).2.le).elim,\n      fun h \u21a6 (not_le_of_gt h p\u2081lt_p\u2080.le).elim\u27e9\n\nlemma exp_lt_exp_gt_iff (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    p < p\u2080 \u2194 p\u2081 < p := by\n  rw [exp_lt_iff ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp, \u2190 exp_gt_iff (Ioo.one_sub_mem ht) hp\u2081 hp\u2080 (Ne.symm hp\u2080p\u2081)\n    (switch_exponents ht hp)]\n\nlemma exp_gt_exp_lt_iff (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    p\u2080 < p \u2194 p < p\u2081 := by\n  rw [exp_gt_iff ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp, \u2190 exp_lt_iff (Ioo.one_sub_mem ht) hp\u2081 hp\u2080 (Ne.symm hp\u2080p\u2081)\n    (switch_exponents ht hp)]\n\nlemma exp_lt_iff\u2081 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    p < p\u2081 \u2194 p\u2080 < p\u2081 := by\n  rw [\u2190 exp_gt_exp_lt_iff ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp]\n  exact exp_gt_iff ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp\n\nlemma exp_gt_iff\u2081 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    p\u2081 < p \u2194 p\u2081 < p\u2080 := by\n  rw [\u2190 exp_lt_exp_gt_iff ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp]\n  exact exp_lt_iff ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp\n\nend ComputationsInterpolatedExponents\n\nend\n\nnoncomputable section\n\n/-! ## Results about the particular choice of exponent\n\n    The proof of the real interpolation theorem will estimate\n    `distribution (trunc f A(t)) t` and `distribution (trunc_compl f A(t)) t` for a\n    function `A`. The function `A` can be given a closed-form expression that works for\n    _all_ cases in the real interpolation theorem, because of the computation rules available\n    for elements in `\u211d\u22650\u221e` that avoid the need for a limiting procedure, e.g. `\u22a4\u207b\u00b9 = 0`.\n\n    The function `A` will be of the form `A(t) = (t / d) ^ \u03c3` for particular choices of `d` and\n    `\u03c3`. This section contatins results about the exponents `\u03c3`.\n-/\nnamespace ComputationsChoiceExponent\n\nopen ENNReal Real Set ComputationsInterpolatedExponents\n\nvariable {p\u2080 q\u2080 p\u2081 q\u2081 p q : \u211d\u22650\u221e} {t : \u211d}\n\ndef \u03b6 := (((1 - t) * (p\u2080\u207b\u00b9).toReal + t * (p\u2081\u207b\u00b9).toReal) * ((q\u2081\u207b\u00b9).toReal - (q\u2080\u207b\u00b9).toReal)) /\n        (((1 - t) * (q\u2080\u207b\u00b9).toReal + t * (q\u2081\u207b\u00b9).toReal) * ((p\u2081\u207b\u00b9).toReal - (p\u2080\u207b\u00b9).toReal))\n\nlemma \u03b6_equality\u2081 (ht : t \u2208 Ioo 0 1) :\n    @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t =\n    (((1 - t) * p\u2080\u207b\u00b9.toReal + t * p\u2081\u207b\u00b9.toReal) *\n    ((1 - t) * q\u2080\u207b\u00b9.toReal + t * q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal)) /\n    (((1 - t) * q\u2080\u207b\u00b9.toReal + t * q\u2081\u207b\u00b9.toReal) *\n    ((1 - t) * p\u2080\u207b\u00b9.toReal + t * p\u2081\u207b\u00b9.toReal - p\u2080\u207b\u00b9.toReal)) := by\n  unfold \u03b6\n  rw [\u2190 mul_div_mul_right _ _ ht.1.ne', mul_assoc _ _ t, mul_assoc _ _ t]\n  congr <;> ring\n\nlemma \u03b6_equality\u2082 (ht : t \u2208 Ioo 0 1) :\n    @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t =\n    (((1 - t) * p\u2080\u207b\u00b9.toReal + t * p\u2081\u207b\u00b9.toReal) *\n    ((1 - t) * q\u2080\u207b\u00b9.toReal + t * q\u2081\u207b\u00b9.toReal - q\u2081\u207b\u00b9.toReal)) /\n    (((1 - t) * q\u2080\u207b\u00b9.toReal + t * q\u2081\u207b\u00b9.toReal) *\n    ((1 - t) * p\u2080\u207b\u00b9.toReal + t * p\u2081\u207b\u00b9.toReal - p\u2081\u207b\u00b9.toReal)) := by\n  unfold \u03b6\n  have : - (1 - t) < 0 := neg_neg_iff_pos.mpr (sub_pos.mpr ht.2)\n  rw [\u2190 mul_div_mul_right _ _ this.ne, mul_assoc _ _ (-(1 - t)), mul_assoc _ _ (-(1 - t))]\n  congr <;> ring\n\nlemma \u03b6_symm :\n    @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t = @\u03b6 p\u2081 q\u2081 p\u2080 q\u2080 (1 - t) := by\n  unfold \u03b6\n  rw [\u2190 mul_div_mul_right (c := - 1), mul_assoc _ _ (-1), mul_assoc _ _ (-1)]; on_goal 2 => positivity\n  simp only [mul_neg, mul_one, neg_sub, _root_.sub_sub_cancel]\n  nth_rewrite 1 [add_comm]; nth_rw 2 [add_comm]\n\nset_option linter.style.multiGoal false in\nset_option linter.flexible false in\nlemma \u03b6_equality\u2083 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2080' : p\u2080 \u2260 \u22a4)\n    (hq\u2080' : q\u2080 \u2260 \u22a4) :\n    @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t = (p\u2080.toReal * (q\u2080.toReal - q.toReal))  / (q\u2080.toReal * (p\u2080.toReal - p.toReal))\n    := by\n  rw [\u03b6_equality\u2081 ht, \u2190 preservation_interpolation, \u2190 preservation_interpolation]\n  have q_pos : 0 < q := interpolated_pos' hq\u2080 hq\u2081 hq\n  have p_pos : 0 < p := interpolated_pos' hp\u2080 hp\u2081 hp\n  have hne : p.toReal * q.toReal * p\u2080.toReal * q\u2080.toReal > 0 :=\n    mul_pos (mul_pos (mul_pos (interp_exp_toReal_pos ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp)\n    (interp_exp_toReal_pos ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq)) (exp_toReal_pos hp\u2080 hp\u2080'))\n    (exp_toReal_pos hq\u2080 hq\u2080')\n  rw [\u2190 mul_div_mul_right _ _ hne.ne']\n  have eq\u2081 : p\u207b\u00b9.toReal * (q\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) *\n      (p.toReal * q.toReal * p\u2080.toReal * q\u2080.toReal) =\n      p\u2080.toReal * (p\u207b\u00b9.toReal * p.toReal) * ((q\u207b\u00b9.toReal * q.toReal) * q\u2080.toReal -\n      (q\u2080\u207b\u00b9.toReal * q\u2080.toReal) * q.toReal) := by ring\n  have eq\u2082 : q\u207b\u00b9.toReal * (p\u207b\u00b9.toReal - p\u2080\u207b\u00b9.toReal) *\n      (p.toReal * q.toReal * p\u2080.toReal * q\u2080.toReal) =\n      q\u2080.toReal * (q\u207b\u00b9.toReal * q.toReal) * ((p\u207b\u00b9.toReal * p.toReal) * p\u2080.toReal -\n      (p\u2080\u207b\u00b9.toReal * p\u2080.toReal) * p.toReal) := by ring\n  rw [eq\u2081, eq\u2082, \u2190 @toReal_mul q\u207b\u00b9 q, \u2190 @toReal_mul p\u207b\u00b9 p, \u2190 @toReal_mul p\u2080\u207b\u00b9 p\u2080,\n      \u2190 @toReal_mul q\u2080\u207b\u00b9 q\u2080]\n  all_goals try assumption\n  -- TODO: why can below goals not be discharged?\n  repeat rw [ENNReal.inv_mul_cancel] <;> try positivity\n  all_goals simp <;> try assumption\n  \u00b7 apply interp_exp_ne_top hq\u2080q\u2081 ht hq\n  \u00b7 apply interp_exp_ne_top hp\u2080p\u2081 ht hp\n\nlemma one_sub_coe_one_sub (ht : t \u2208 Ioo 0 1) :\n    (1 - ENNReal.ofReal (1 - t)) = ENNReal.ofReal t := by\n  have := ht.2\n  rw [\u2190 ofReal_one, \u2190 ENNReal.ofReal_sub] <;> congr\n  \u00b7 linarith\n  \u00b7 linarith\n\nlemma coe_one_sub (ht : t \u2208 Ioo 0 1) :\n    ENNReal.ofReal (1 - t) = 1 - ENNReal.ofReal t := by\n  rw [\u2190 ofReal_one, \u2190 ENNReal.ofReal_sub]; exact ht.1.le\n\nlemma \u03b6_equality\u2084 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2081' : p\u2081 \u2260 \u22a4)\n    (hq\u2081' : q\u2081 \u2260 \u22a4) :\n    @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t =\n    (p\u2081.toReal * (q\u2081.toReal - q.toReal)) / (q\u2081.toReal * (p\u2081.toReal - p.toReal)) := by\n  rw [\u03b6_symm]\n  have one_sub_mem : 1 - t \u2208 Ioo 0 1 := Ioo.one_sub_mem ht\n  rw [\u03b6_equality\u2083 one_sub_mem] <;> try assumption\n  \u00b7 exact hp\u2080p\u2081.symm\n  \u00b7 exact hq\u2080q\u2081.symm\n  \u00b7 rw [hp, one_sub_coe_one_sub ht, coe_one_sub ht]; ring\n  \u00b7 rw [hq, one_sub_coe_one_sub ht, coe_one_sub ht]; ring\n\nlemma \u03b6_equality\u2085 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2080' : p\u2080 \u2260 \u22a4)\n    (hq\u2080' : q\u2080 \u2260 \u22a4) :\n    p\u2080.toReal + (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t)\u207b\u00b9 * (q.toReal - q\u2080.toReal) * (p\u2080.toReal / q\u2080.toReal) = p.toReal\n    := by\n  rw [\u03b6_equality\u2083 ht] <;> try assumption\n  simp only [inv_div]\n  rw [div_eq_mul_inv, div_eq_mul_inv, mul_inv]\n  calc\n  _ = p\u2080.toReal - (q\u2080.toReal\u207b\u00b9 * q\u2080.toReal) * (p\u2080.toReal - p.toReal) * (p\u2080.toReal\u207b\u00b9 * p\u2080.toReal) *\n      ((q\u2080.toReal - q.toReal)\u207b\u00b9 * (q\u2080.toReal - q.toReal)) := by ring\n  _ = _ := by\n    rw [inv_mul_cancel\u2080, inv_mul_cancel\u2080, inv_mul_cancel\u2080]\n    \u00b7 simp only [one_mul, mul_one, _root_.sub_sub_cancel]\n    \u00b7 exact sub_ne_zero_of_ne (ne_toReal_exp_interp_exp ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq)\n    \u00b7 exact (exp_toReal_pos hp\u2080 hp\u2080').ne'\n    \u00b7 exact (exp_toReal_pos hq\u2080 hq\u2080').ne'\n\nlemma \u03b6_equality\u2086 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2081' : p\u2081 \u2260 \u22a4)\n    (hq\u2081' : q\u2081 \u2260 \u22a4) :\n    p\u2081.toReal + (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t)\u207b\u00b9 * (q.toReal - q\u2081.toReal) * (p\u2081.toReal / q\u2081.toReal) = p.toReal\n    := by\n  rw [\u03b6_symm]\n  exact \u03b6_equality\u2085 (Ioo.one_sub_mem ht) hp\u2081 hq\u2081 hp\u2080 hq\u2080 hp\u2080p\u2081.symm hq\u2080q\u2081.symm\n    (switch_exponents ht hp) (switch_exponents ht hq) hp\u2081' hq\u2081'\n\nlemma \u03b6_equality\u2087 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2080' : p\u2080 \u2260 \u22a4)\n    (hq\u2080' : q\u2080 = \u22a4) :\n    @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t = p\u2080.toReal / (p\u2080.toReal - p.toReal) := by\n  rw [\u03b6_equality\u2081 ht, \u2190 preservation_interpolation ht hp\u2080 hp\u2081 hp,\n    \u2190 preservation_interpolation ht hq\u2080 hq\u2081 hq, hq\u2080']\n  simp only [inv_top, zero_toReal, sub_zero, mul_zero, zero_add]\n  have obs : p\u2080.toReal * p.toReal * q.toReal > 0 :=\n    mul_pos (mul_pos (toReal_pos hp\u2080.ne' hp\u2080') (interp_exp_toReal_pos ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp))\n    (interp_exp_toReal_pos ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq)\n  rw [\u2190 mul_div_mul_right _ _ obs.ne']\n  congr\n  \u00b7 calc\n    _ = (p.toReal\u207b\u00b9 * p.toReal) * (q.toReal\u207b\u00b9 * q.toReal) * p\u2080.toReal := by\n      rw [toReal_inv, toReal_inv]\n      ring\n    _ = _ := by\n      rw [inv_mul_cancel\u2080, inv_mul_cancel\u2080, one_mul, one_mul]\n      \u00b7 exact (interp_exp_toReal_pos ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq).ne'\n      \u00b7 exact (interp_exp_toReal_pos ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp).ne'\n  \u00b7 calc\n    _ = (q.toReal\u207b\u00b9 * q.toReal) * (p.toReal\u207b\u00b9 * p.toReal * p\u2080.toReal - p\u2080.toReal\u207b\u00b9 *\n        p\u2080.toReal * p.toReal) := by\n      rw [toReal_inv, toReal_inv, toReal_inv]\n      ring\n    _ = _ := by\n      repeat rw [inv_mul_cancel\u2080, one_mul]\n      \u00b7 exact (toReal_pos hp\u2080.ne' hp\u2080').ne'\n      \u00b7 exact (interp_exp_toReal_pos ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp).ne'\n      \u00b7 exact (interp_exp_toReal_pos ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq).ne'\n\nlemma \u03b6_equality\u2088 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2081' : p\u2081 \u2260 \u22a4)\n    (hq\u2081' : q\u2081 = \u22a4) :\n    @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t = p\u2081.toReal / (p\u2081.toReal - p.toReal) :=\n  \u03b6_symm \u25b8 \u03b6_equality\u2087 (Ioo.one_sub_mem ht) hp\u2081 hq\u2081 hp\u2080 hq\u2080 (Ne.symm hp\u2080p\u2081) (Ne.symm hq\u2080q\u2081)\n    (switch_exponents ht hp) (switch_exponents ht hq) hp\u2081' hq\u2081'\n\nlemma \u03b6_eq_top_top (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0)\n    (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2081' : p\u2081 = \u22a4)\n    (hq\u2081' : q\u2081 = \u22a4) :\n    @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t = 1 := by\n  rw [\u03b6_equality\u2082 ht, \u2190 preservation_interpolation ht hp\u2080 hp\u2081 hp,\n    \u2190 preservation_interpolation ht hq\u2080 hq\u2081 hq, hp\u2081', hq\u2081']\n  simp only [inv_top, zero_toReal, sub_zero]\n  rw [mul_comm, div_eq_mul_inv, mul_inv_cancel\u2080]\n  exact (mul_pos (interp_exp_inv_pos ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq)\n    (interp_exp_inv_pos ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp)).ne'\n\nlemma \u03b6_pos_iff_aux (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2080' : p\u2080 \u2260 \u22a4) (hq\u2080' : q\u2080 \u2260 \u22a4) :\n    ( 0 < p\u2080.toReal * (q\u2080.toReal - q.toReal) / (q\u2080.toReal * (p\u2080.toReal - p.toReal))) \u2194\n    ((q.toReal < q\u2080.toReal) \u2227 (p.toReal < p\u2080.toReal)) \u2228\n    ((q\u2080.toReal < q.toReal) \u2227 (p\u2080.toReal < p.toReal)) := by\n  rw [_root_.div_pos_iff, \u2190 Left.neg_pos_iff, \u2190 Left.neg_pos_iff, neg_mul_eq_mul_neg,\n      neg_mul_eq_mul_neg]\n  rw [mul_pos_iff_of_pos_left, mul_pos_iff_of_pos_left,\n      mul_pos_iff_of_pos_left, mul_pos_iff_of_pos_left, neg_sub, neg_sub]\n  \u00b7 simp only [sub_pos, sub_neg]\n  \u00b7 exact exp_toReal_pos hq\u2080 hq\u2080'\n  \u00b7 exact exp_toReal_pos hp\u2080 hp\u2080'\n  \u00b7 exact exp_toReal_pos hq\u2080 hq\u2080'\n  \u00b7 exact exp_toReal_pos hp\u2080 hp\u2080'\n\nlemma preservation_inequality (ht : t \u2208 Ioo 0 1) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) (hp\u2080' : p\u2080 \u2260 \u22a4) :\n    p.toReal < p\u2080.toReal \u2194 p < p\u2080 :=\n  toReal_lt_toReal (interp_exp_ne_top hp\u2080p\u2081 ht hp) hp\u2080'\n\nlemma preservation_inequality' (ht : t \u2208 Ioo 0 1)(hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) (hp\u2080' : p\u2080 \u2260 \u22a4) :\n    p\u2080.toReal < p.toReal \u2194 p\u2080 < p :=\n  toReal_lt_toReal hp\u2080' (interp_exp_ne_top hp\u2080p\u2081 ht hp)\n\nlemma preservation_inequality_of_lt\u2080 (ht : t \u2208 Ioo 0 1) (hq\u2080 : q\u2080 > 0) (hq\u2081 : q\u2081 > 0)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hq\u2080q\u2081 : q\u2080 < q\u2081) :\n    q\u2080.toReal < q.toReal :=\n  (toReal_lt_toReal hq\u2080q\u2081.ne_top (interp_exp_ne_top hq\u2080q\u2081.ne ht hq)).mpr\n    ((exp_gt_iff ht hq\u2080 hq\u2081 hq\u2080q\u2081.ne hq).mpr hq\u2080q\u2081)\n\nlemma preservation_inequality_of_lt\u2081 (ht : t \u2208 Ioo 0 1) (hq\u2080 : q\u2080 > 0) (hq\u2081 : q\u2081 > 0)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hq\u2080q\u2081 : q\u2080 < q\u2081)\n    (hq\u2081' : q\u2081 \u2260 \u22a4):\n    q.toReal < q\u2081.toReal :=\n  (toReal_lt_toReal (interp_exp_ne_top hq\u2080q\u2081.ne ht hq) hq\u2081').mpr\n    ((exp_lt_iff\u2081 ht hq\u2080 hq\u2081 hq\u2080q\u2081.ne hq).mpr hq\u2080q\u2081)\n\nlemma \u03b6_pos_toReal_iff\u2080 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hq\u2081 : q\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2080' : p\u2080 \u2260 \u22a4)\n    (hq\u2080' : q\u2080 \u2260 \u22a4) : (0 < @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) \u2194\n    ((q.toReal < q\u2080.toReal) \u2227 (p.toReal < p\u2080.toReal)) \u2228\n    ((q\u2080.toReal < q.toReal) \u2227 (p\u2080.toReal < p.toReal)) := by\n  rw [\u03b6_equality\u2083 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081 hq\u2080q\u2081 hp hq hp\u2080' hq\u2080']\n  exact \u03b6_pos_iff_aux hp\u2080 hq\u2080 hp\u2080' hq\u2080'\n\nlemma \u03b6_pos_toReal_iff\u2081 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hq\u2081 : q\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2081' : p\u2081 \u2260 \u22a4)\n    (hq\u2081' : q\u2081 \u2260 \u22a4) :\n    (0 < @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) \u2194\n    ((q.toReal < q\u2081.toReal) \u2227 (p.toReal < p\u2081.toReal)) \u2228\n    ((q\u2081.toReal < q.toReal) \u2227 (p\u2081.toReal < p.toReal)) := by\n  rw [\u03b6_equality\u2084 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081 hq\u2080q\u2081 hp hq hp\u2081' hq\u2081']\n  exact \u03b6_pos_iff_aux hp\u2081 hq\u2081 hp\u2081' hq\u2081'\n\nlemma \u03b6_pos_iff_aux\u2080 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0)\n    (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081) :\n    (0 < @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) \u2194\n    q\u2080\u207b\u00b9.toReal < q\u2081\u207b\u00b9.toReal \u2227 p\u2080\u207b\u00b9.toReal < p\u2081\u207b\u00b9.toReal \u2228\n    q\u2081\u207b\u00b9.toReal < q\u2080\u207b\u00b9.toReal \u2227 p\u2081\u207b\u00b9.toReal < p\u2080\u207b\u00b9.toReal := by\n  unfold \u03b6\n  rw [_root_.div_pos_iff, \u2190 Left.neg_pos_iff, \u2190 Left.neg_pos_iff, neg_mul_eq_mul_neg,\n      neg_mul_eq_mul_neg, mul_pos_iff_of_pos_left, mul_pos_iff_of_pos_left,\n      mul_pos_iff_of_pos_left, mul_pos_iff_of_pos_left, neg_sub, neg_sub]\n  \u00b7 simp only [sub_pos, sub_neg]\n  \u00b7 exact preservation_positivity_inv_toReal ht hq\u2080 hq\u2081 hq\u2080q\u2081\n  \u00b7 exact preservation_positivity_inv_toReal ht hp\u2080 hp\u2081 hp\u2080p\u2081\n  \u00b7 exact preservation_positivity_inv_toReal ht hq\u2080 hq\u2081 hq\u2080q\u2081\n  \u00b7 exact preservation_positivity_inv_toReal ht hp\u2080 hp\u2081 hp\u2080p\u2081\n\nlemma inv_toReal_iff (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0) :\n    p\u2080\u207b\u00b9.toReal < p\u2081\u207b\u00b9.toReal \u2194 p\u2081 < p\u2080 :=\n  Iff.trans (toReal_lt_toReal (ne_of_lt (inv_lt_top.mpr hp\u2080))\n    (ne_of_lt (inv_lt_top.mpr hp\u2081))) ENNReal.inv_lt_inv\n\nlemma \u03b6_pos_iff (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081) :\n    (0 < @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) \u2194\n    ((q\u2081 < q\u2080) \u2227 (p\u2081 < p\u2080)) \u2228 ((q\u2080 < q\u2081) \u2227 (p\u2080 < p\u2081)) := by\n  rw [\u03b6_pos_iff_aux\u2080 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081 hq\u2080q\u2081,\n    inv_toReal_iff hq\u2080 hq\u2081, inv_toReal_iff hp\u2080 hp\u2081,\n    inv_toReal_iff hq\u2081 hq\u2080, inv_toReal_iff hp\u2081 hp\u2080]\n\nlemma \u03b6_pos_iff' (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0)\n    (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) :\n    (0 < @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) \u2194\n    ((q < q\u2080) \u2227 (p < p\u2080)) \u2228 ((q\u2080 < q) \u2227 (p\u2080 < p)) := by\n  rw [\u03b6_pos_iff ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081 hq\u2080q\u2081,\n    \u2190 exp_lt_iff ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp, \u2190 exp_lt_iff ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq,\n    \u2190 exp_gt_iff ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp, \u2190 exp_gt_iff ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq]\n\nlemma \u03b6_pos_iff_of_lt\u2080 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0)\n    (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2080p\u2081' : p\u2080 < p\u2081)  :\n    (0 < @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) \u2194\n    (q\u2080 < q) := by\n  rw [\u03b6_pos_iff' ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081'.ne hq\u2080q\u2081 hp hq]\n  rw [\u2190 exp_gt_iff (p := p) ht hp\u2080 hp\u2081 hp\u2080p\u2081'.ne hp] at hp\u2080p\u2081'\n  have : \u00ac (p < p\u2080) := not_lt_of_gt hp\u2080p\u2081'\n  tauto\n\nlemma \u03b6_pos_iff_of_lt\u2081 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0)\n  (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2080p\u2081' : p\u2080 < p\u2081) :\n    (0 < @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) \u2194\n    (q < q\u2081) := by\n  rw [\u2190 exp_gt_exp_lt_iff ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq]\n  exact \u03b6_pos_iff_of_lt\u2080 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hq\u2080q\u2081 hp hq hp\u2080p\u2081'\n\nlemma \u03b6_neg_iff_aux\u2080 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081) :\n    (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) < 0 \u2194\n    q\u2080\u207b\u00b9.toReal < q\u2081\u207b\u00b9.toReal \u2227 p\u2081\u207b\u00b9.toReal < p\u2080\u207b\u00b9.toReal \u2228\n    q\u2081\u207b\u00b9.toReal < q\u2080\u207b\u00b9.toReal \u2227 p\u2080\u207b\u00b9.toReal < p\u2081\u207b\u00b9.toReal := by\n  unfold \u03b6\n  rw [div_neg_iff, \u2190 Left.neg_pos_iff, \u2190 Left.neg_pos_iff, neg_mul_eq_mul_neg, neg_mul_eq_mul_neg]\n  rw [mul_pos_iff_of_pos_left, mul_pos_iff_of_pos_left,\n      mul_pos_iff_of_pos_left, mul_pos_iff_of_pos_left, neg_sub, neg_sub]\n  \u00b7 simp only [sub_pos, sub_neg]\n  \u00b7 exact preservation_positivity_inv_toReal ht hq\u2080 hq\u2081 hq\u2080q\u2081\n  \u00b7 exact preservation_positivity_inv_toReal ht hp\u2080 hp\u2081 hp\u2080p\u2081\n  \u00b7 exact preservation_positivity_inv_toReal ht hq\u2080 hq\u2081 hq\u2080q\u2081\n  \u00b7 exact preservation_positivity_inv_toReal ht hp\u2080 hp\u2081 hp\u2080p\u2081\n\nlemma \u03b6_neg_iff (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081) :\n    (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) < 0 \u2194\n    q\u2081 < q\u2080 \u2227 p\u2080 < p\u2081 \u2228 q\u2080 < q\u2081 \u2227 p\u2081 < p\u2080 := by\n  rw [\u03b6_neg_iff_aux\u2080 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081 hq\u2080q\u2081, inv_toReal_iff hq\u2080 hq\u2081, inv_toReal_iff hp\u2080 hp\u2081,\n    inv_toReal_iff hq\u2081 hq\u2080, inv_toReal_iff hp\u2081 hp\u2080]\n\nlemma \u03b6_neg_iff' (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) :\n    (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) < 0 \u2194\n    ((q < q\u2080) \u2227 (p\u2080 < p)) \u2228 ((q\u2080 < q) \u2227 (p < p\u2080)) := by\n  rw [\u03b6_neg_iff ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081 hq\u2080q\u2081, \u2190 exp_lt_iff ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp,\n    \u2190 exp_lt_iff ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq, \u2190 exp_gt_iff ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp,\n    \u2190 exp_gt_iff ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq]\n\nlemma \u03b6_neg_iff_of_lt\u2080 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2080p\u2081' : p\u2080 < p\u2081) :\n    (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) < 0 \u2194 q < q\u2080 := by\n  rw [\u03b6_neg_iff' ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081'.ne hq\u2080q\u2081 hp hq]\n  rw [\u2190 exp_gt_iff (p := p) ht hp\u2080 hp\u2081 hp\u2080p\u2081'.ne hp] at hp\u2080p\u2081'\n  have : \u00ac (p < p\u2080) := not_lt_of_gt hp\u2080p\u2081'\n  tauto\n\nlemma \u03b6_neg_iff_of_lt\u2081 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2080p\u2081' : p\u2080 < p\u2081) :\n    (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) < 0 \u2194 q\u2081 < q := by\n  rw [\u2190 exp_lt_exp_gt_iff ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq]\n  exact \u03b6_neg_iff_of_lt\u2080 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hq\u2080q\u2081 hp hq hp\u2080p\u2081'\n\nlemma \u03b6_neg_iff_aux (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2080' : p\u2080 \u2260 \u22a4)\n    (hq\u2080' : q\u2080 \u2260 \u22a4) :\n    (p\u2080.toReal * (q\u2080.toReal - q.toReal) / (q\u2080.toReal * (p\u2080.toReal - p.toReal)) < 0) \u2194\n    ((q.toReal < q\u2080.toReal) \u2227 (p\u2080.toReal < p.toReal)) \u2228\n    ((q\u2080.toReal < q.toReal) \u2227 (p.toReal < p\u2080.toReal)) := by\n  rw [div_neg_iff, \u2190 Left.neg_pos_iff, \u2190 Left.neg_pos_iff, neg_mul_eq_mul_neg, neg_mul_eq_mul_neg,\n    mul_pos_iff_of_pos_left, mul_pos_iff_of_pos_left,\n    mul_pos_iff_of_pos_left, mul_pos_iff_of_pos_left, neg_sub, neg_sub]\n  \u00b7 simp only [sub_pos, sub_neg]\n  \u00b7 exact exp_toReal_pos hq\u2080 hq\u2080'\n  \u00b7 exact exp_toReal_pos hp\u2080 hp\u2080'\n  \u00b7 exact exp_toReal_pos hq\u2080 hq\u2080'\n  \u00b7 exact exp_toReal_pos hp\u2080 hp\u2080'\n\nlemma \u03b6_neg_toReal_iff\u2080 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hq\u2081 : q\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2080' : p\u2080 \u2260 \u22a4)\n    (hq\u2080' : q\u2080 \u2260 \u22a4) :\n    (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t < 0) \u2194\n    ((q.toReal < q\u2080.toReal) \u2227 (p\u2080.toReal < p.toReal)) \u2228\n    ((q\u2080.toReal < q.toReal) \u2227 (p.toReal < p\u2080.toReal)) := by\n  rw [\u03b6_equality\u2083 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081 hq\u2080q\u2081 hp hq hp\u2080' hq\u2080']\n  exact \u03b6_neg_iff_aux hp\u2080 hq\u2080 hp\u2080' hq\u2080'\n\nlemma \u03b6_neg_toReal_iff\u2081 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hq\u2081 : q\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2081' : p\u2081 \u2260 \u22a4)\n    (hq\u2081' : q\u2081 \u2260 \u22a4) :\n    (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t < 0) \u2194\n    ((q.toReal < q\u2081.toReal) \u2227 (p\u2081.toReal < p.toReal)) \u2228 ((q\u2081.toReal < q.toReal) \u2227\n    (p.toReal < p\u2081.toReal)) := by\n  rw [\u03b6_equality\u2084 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081 hq\u2080q\u2081 hp hq hp\u2081' hq\u2081']\n  exact \u03b6_neg_iff_aux hp\u2081 hq\u2081 hp\u2081' hq\u2081'\n\nlemma \u03b6_neg_iff\u2080 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2080' : p\u2080 \u2260 \u22a4)\n    (hq\u2080' : q\u2080 \u2260 \u22a4) : (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t < 0) \u2194\n    ((q < q\u2080) \u2227 (p\u2080 < p)) \u2228 ((q\u2080 < q) \u2227 (p < p\u2080)) := by\n  rw [\u03b6_neg_toReal_iff\u2080 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081 hq\u2080q\u2081 hp hq hp\u2080' hq\u2080',\n    preservation_inequality ht hq\u2080q\u2081 hq hq\u2080', preservation_inequality ht hp\u2080p\u2081 hp hp\u2080',\n    preservation_inequality' ht hq\u2080q\u2081 hq hq\u2080', preservation_inequality' ht hp\u2080p\u2081 hp hp\u2080']\n\nlemma \u03b6_ne_zero (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081) :\n    (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t \u2260 0) := by\n  refine div_ne_zero ?_ ?_\n  \u00b7 apply mul_ne_zero (preservation_positivity_inv_toReal ht hp\u2080 hp\u2081 hp\u2080p\u2081).ne'\n    refine sub_ne_zero_of_ne (Ne.symm fun h \u21a6 hq\u2080q\u2081 ?_)\n    rw [\u2190 inv_inv q\u2080, \u2190 inv_inv q\u2081, \u2190 coe_inv_exponent hq\u2080, \u2190 coe_inv_exponent hq\u2081]\n    exact congrArg Inv.inv (congrArg ENNReal.ofReal h)\n  \u00b7 apply mul_ne_zero (preservation_positivity_inv_toReal ht hq\u2080 hq\u2081 hq\u2080q\u2081).ne'\n    refine sub_ne_zero_of_ne (Ne.symm fun h \u21a6 hp\u2080p\u2081 ?_)\n    rw [\u2190 inv_inv p\u2080, \u2190 inv_inv p\u2081, \u2190 coe_inv_exponent hp\u2080, \u2190 coe_inv_exponent hp\u2081]\n    exact congrArg Inv.inv (congrArg ENNReal.ofReal h)\n\nlemma \u03b6_le_zero_iff_of_lt\u2080 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2080p\u2081' : p\u2080 < p\u2081) :\n    (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t \u2264 0) \u2194 q < q\u2080 := by\n  constructor <;> intro h\n  \u00b7 rcases (Decidable.lt_or_eq_of_le h) with \u03b6_lt_0 | \u03b6_eq_0\n    \u00b7 exact (\u03b6_neg_iff_of_lt\u2080 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hq\u2080q\u2081 hp hq hp\u2080p\u2081').mp \u03b6_lt_0\n    \u00b7 exact False.elim <| (\u03b6_ne_zero ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081'.ne hq\u2080q\u2081) \u03b6_eq_0\n  \u00b7 exact ((\u03b6_neg_iff_of_lt\u2080 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hq\u2080q\u2081 hp hq hp\u2080p\u2081').mpr h).le\n\nlemma \u03b6_le_zero_iff_of_lt\u2081 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2080p\u2081' : p\u2080 < p\u2081) :\n    (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) \u2264 0 \u2194 q\u2081 < q := by\n  rw [\u2190 exp_lt_exp_gt_iff ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq]\n  exact \u03b6_le_zero_iff_of_lt\u2080 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hq\u2080q\u2081 hp hq hp\u2080p\u2081'\n\nlemma eq_exponents\u2080 (ht : t \u2208 Ioo 0 1) (hq\u2080 : q\u2080 > 0) (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hq\u2080' : q\u2080 \u2260 \u22a4) :\n    (q\u2080.toReal + q\u2081\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) *\n    (q.toReal - q\u2080.toReal)) = (1 - t) * q.toReal := by\n  rw [mul_comm_div, \u2190 mul_div_assoc, add_div']\n  \u00b7 have : q\u2080.toReal * (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) + q\u2081\u207b\u00b9.toReal * (q.toReal - q\u2080.toReal) =\n        q.toReal * ((1 - t) * (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal)) := by\n      calc\n      _ = q\u2080.toReal * q\u2081\u207b\u00b9.toReal - q\u2080.toReal * q\u2080\u207b\u00b9.toReal +\n          q\u2081\u207b\u00b9.toReal * q.toReal - q\u2081\u207b\u00b9.toReal *  q\u2080.toReal := by\n        ring\n      _ = q\u2081\u207b\u00b9.toReal * q.toReal - q\u207b\u00b9.toReal * q.toReal := by\n        rw [toReal_inv, toReal_inv, toReal_inv, mul_inv_cancel\u2080, inv_mul_cancel\u2080]\n        \u00b7 ring\n        \u00b7 exact (interp_exp_toReal_pos ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq).ne'\n        \u00b7 exact (toReal_pos hq\u2080.ne' hq\u2080').ne'\n      _ = q.toReal * (q\u2081\u207b\u00b9.toReal - q\u207b\u00b9.toReal) := by ring\n      _ = _ := by\n        rw [preservation_interpolation ht hq\u2080 hq\u2081 hq]\n        congr\n        ring\n    rw [this, mul_div_assoc, mul_div_cancel_right\u2080]\n    \u00b7 ring\n    exact ne_sub_toReal_exp hq\u2080 hq\u2081 hq\u2080q\u2081\n  \u00b7 exact ne_sub_toReal_exp hq\u2080 hq\u2081 hq\u2080q\u2081\n\nlemma eq_exponents\u2082 (ht : t \u2208 Ioo 0 1) (hq\u2080 : q\u2080 > 0) (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hq\u2080' : q\u2080 \u2260 \u22a4) :\n    (q\u2080.toReal / p\u2080.toReal + p\u2080\u207b\u00b9.toReal * q\u2081\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) *\n    (q.toReal - q\u2080.toReal)) = (1 - t) * p\u2080\u207b\u00b9.toReal * q.toReal := by\n  rw [div_eq_inv_mul, mul_div_assoc, mul_assoc, toReal_inv, \u2190 mul_add, mul_comm_div,\n    \u2190 mul_div_assoc, add_div']\n  \u00b7 have : q\u2080.toReal * (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) + q\u2081\u207b\u00b9.toReal * (q.toReal - q\u2080.toReal) =\n        q.toReal * ((1 - t) * (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal)) := by\n      calc\n      _ = q\u2080.toReal * q\u2081\u207b\u00b9.toReal - q\u2080.toReal * q\u2080\u207b\u00b9.toReal +\n          q\u2081\u207b\u00b9.toReal * q.toReal - q\u2081\u207b\u00b9.toReal *  q\u2080.toReal := by\n        ring\n      _ = q\u2081\u207b\u00b9.toReal * q.toReal - q\u207b\u00b9.toReal * q.toReal := by\n        rw [toReal_inv, toReal_inv, toReal_inv, mul_inv_cancel\u2080, inv_mul_cancel\u2080]\n        \u00b7 ring\n        \u00b7 exact (interp_exp_toReal_pos ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq).ne'\n        \u00b7 exact (toReal_pos hq\u2080.ne' hq\u2080').ne'\n      _ = q.toReal * (q\u2081\u207b\u00b9.toReal - q\u207b\u00b9.toReal) := by ring\n      _ = _ := by\n        rw [preservation_interpolation ht hq\u2080 hq\u2081 hq]\n        congr\n        ring\n    rw [this, mul_div_assoc, mul_div_cancel_right\u2080]\n    \u00b7 ring\n    \u00b7 exact ne_sub_toReal_exp hq\u2080 hq\u2081 hq\u2080q\u2081\n  \u00b7 exact ne_sub_toReal_exp hq\u2080 hq\u2081 hq\u2080q\u2081\n\nlemma eq_exponents\u2081 (ht : t \u2208 Ioo 0 1) (hq\u2080 : q\u2080 > 0) (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hq\u2080' : q\u2080 \u2260 \u22a4) :\n    (q\u2080\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal)) * (q.toReal - q\u2080.toReal) = - t * q.toReal := by\n  rw [mul_comm_div, \u2190 mul_div_assoc]\n  have : q\u2080\u207b\u00b9.toReal * (q.toReal - q\u2080.toReal) = - t * q.toReal * (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) := by\n    calc\n    _ = (q\u2080\u207b\u00b9.toReal * q.toReal - q\u2080\u207b\u00b9.toReal * q\u2080.toReal) := by ring\n    _ = (q\u2080\u207b\u00b9.toReal * q.toReal - 1) := by\n      rw [toReal_inv, inv_mul_cancel\u2080]\n      exact (exp_toReal_pos hq\u2080 hq\u2080').ne'\n    _ = (q\u2080\u207b\u00b9.toReal * q.toReal - q\u207b\u00b9.toReal * q.toReal) := by\n      rw [toReal_inv, toReal_inv, inv_mul_cancel\u2080]\n      exact (interp_exp_toReal_pos ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq).ne'\n    _ = q.toReal * (q\u2080\u207b\u00b9.toReal - q\u207b\u00b9.toReal) := by ring\n    _ = _ := by\n      rw [preservation_interpolation ht hq\u2080 hq\u2081 hq]\n      ring\n  rw [this, mul_div_cancel_right\u2080]\n  exact ne_sub_toReal_exp hq\u2080 hq\u2081 hq\u2080q\u2081\n\n-- TODO: simplify these proofs with statements above\nlemma eq_exponents\u2083 (ht : t \u2208 Ioo 0 1) (hq\u2080 : q\u2080 > 0) (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hq\u2080' : q\u2080 \u2260 \u22a4) :\n    (p\u2081\u207b\u00b9.toReal * q\u2080\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal)) * (q.toReal - q\u2080.toReal) =\n    - t * p\u2081\u207b\u00b9.toReal * q.toReal := by\n  rw [mul_comm_div, \u2190 mul_div_assoc]\n  have : (p\u2081\u207b\u00b9.toReal * q\u2080\u207b\u00b9.toReal) * (q.toReal - q\u2080.toReal) =\n      - t * p\u2081\u207b\u00b9.toReal * q.toReal * (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) := by\n    calc\n    _ = p\u2081\u207b\u00b9.toReal * (q\u2080\u207b\u00b9.toReal * q.toReal - q\u2080\u207b\u00b9.toReal * q\u2080.toReal) := by ring\n    _ = p\u2081\u207b\u00b9.toReal * (q\u2080\u207b\u00b9.toReal * q.toReal - 1) := by\n      rw [toReal_inv, toReal_inv, inv_mul_cancel\u2080]\n      apply (exp_toReal_pos hq\u2080 hq\u2080').ne'\n    _ = p\u2081\u207b\u00b9.toReal * (q\u2080\u207b\u00b9.toReal * q.toReal - q\u207b\u00b9.toReal * q.toReal) := by\n      rw [toReal_inv, toReal_inv, toReal_inv, inv_mul_cancel\u2080]\n      exact (interp_exp_toReal_pos ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq).ne'\n    _ = p\u2081\u207b\u00b9.toReal * q.toReal * (q\u2080\u207b\u00b9.toReal - q\u207b\u00b9.toReal) := by ring\n    _ = _ := by\n      rw [preservation_interpolation ht hq\u2080 hq\u2081 hq]\n      ring\n  rw [this, mul_div_cancel_right\u2080]\n  exact ne_sub_toReal_exp hq\u2080 hq\u2081 hq\u2080q\u2081\n\nlemma eq_exponents\u2084  :\n    (q\u2080\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal)) =\n    - (q\u2080\u207b\u00b9.toReal / (q\u2080\u207b\u00b9.toReal - q\u2081\u207b\u00b9.toReal)) := calc\n  _ = - (q\u2080\u207b\u00b9.toReal * (-(q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal)\u207b\u00b9)) := by\n    rw [div_eq_mul_inv]; ring\n  _ = _ := by congr; rw [neg_inv, neg_sub]\n\nlemma eq_exponents\u2085 (ht : t \u2208 Ioo 0 1) (hq\u2080 : q\u2080 > 0) (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hq\u2081' : q\u2081 \u2260 \u22a4):\n    (q\u2081.toReal + -(q\u2080\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) * (q.toReal - q\u2081.toReal)))\n    = t * q.toReal := by\n  rw [eq_exponents\u2084, neg_mul, neg_neg, eq_exponents\u2080 (Ioo.one_sub_mem ht) hq\u2081 hq\u2080 (Ne.symm hq\u2080q\u2081)\n    (switch_exponents ht hq) hq\u2081']\n  ring\n\nlemma eq_exponents\u2086 (ht : t \u2208 Ioo 0 1) (hq\u2080 : q\u2080 > 0) (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hq\u2081' : q\u2081 \u2260 \u22a4) :\n    q\u2081\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) * (q.toReal - q\u2081.toReal) = (1 - t) * q.toReal := by\n  rw [\u2190 neg_neg (a := q\u2081\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal)), \u2190 eq_exponents\u2084, neg_mul,\n    eq_exponents\u2081 (Ioo.one_sub_mem ht) hq\u2081 hq\u2080 (Ne.symm hq\u2080q\u2081) (switch_exponents ht hq) hq\u2081']\n  ring\n\nlemma eq_exponents\u2087 (ht : t \u2208 Ioo 0 1) (hq\u2080 : q\u2080 > 0) (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hq\u2081' : q\u2081 \u2260 \u22a4) :\n    q\u2081.toReal / p\u2081.toReal + -(p\u2081\u207b\u00b9.toReal * q\u2080\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) *\n    (q.toReal - q\u2081.toReal)) =\n    t * p\u2081\u207b\u00b9.toReal * q.toReal := by\n  rw [div_eq_mul_inv, toReal_inv]\n  calc\n  _ = p\u2081.toReal\u207b\u00b9 * (q\u2081.toReal + - (q\u2080\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) *\n      (q.toReal - q\u2081.toReal))) := by ring\n  _ = _ := by\n    rw [eq_exponents\u2085 (ht := ht)] <;> try assumption\n    ring\n\nlemma eq_exponents\u2088 (ht : t \u2208 Ioo 0 1) (hq\u2080 : q\u2080 > 0) (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hq\u2081' : q\u2081 \u2260 \u22a4) :\n    p\u2080\u207b\u00b9.toReal * q\u2081\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) * (q.toReal - q\u2081.toReal) =\n    (1 - t) * p\u2080\u207b\u00b9.toReal * q.toReal := calc\n  _ = p\u2080\u207b\u00b9.toReal * (q\u2081\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) * (q.toReal - q\u2081.toReal)) := by ring\n  _ = _ := by\n    rw [eq_exponents\u2086] <;> try assumption\n    ring\n\nend ComputationsChoiceExponent\n\nend\n\n/-! ## Interface for using cutoff functions\n-/\nnoncomputable section\n\nopen Real Set\n\n/-- A ScaledPowerFunction is meant to represent a function of the form `t \u21a6 (t / d)^\u03c3`,\n    where `d` is strictly positive and either `\u03c3 > 0` or `\u03c3 < 0`. -/\nstructure ScaledPowerFunction where\n  \u03c3 : \u211d\n  d : \u211d\n  hd : d > 0\n  h\u03c3 : (\u03c3 > 0) \u2228 (\u03c3 < 0)\n\n/-- A ToneCouple is an couple of two monotone functions that are practically inverses of each\n    other. It is used in the proof of the real interpolation theorem.\n\n    Note: originally it seemed useful to make the possible choice of this function general\n    in the proof of the real inteprolation theorem. However, in the end really only one\n    function works for all the different cases. This infrastructure, however, could potentially\n    still be useful, if one would like to try to improve the constant. -/\nstructure ToneCouple where\n  ton : \u211d \u2192 \u211d\n  inv : \u211d \u2192 \u211d\n  mon : Bool\n  ton_is_ton : if mon then StrictMonoOn ton (Ioi 0) else StrictAntiOn ton (Ioi 0)\n  ran_ton : \u2200 t \u2208 Ioi (0 : \u211d), ton t \u2208 Ioi 0\n  ran_inv : \u2200 t \u2208 Ioi (0 : \u211d), inv t \u2208 Ioi 0\n  inv_pf : if mon\n      then \u2200 s \u2208 Ioi (0 : \u211d), \u2200 t \u2208 Ioi (0 : \u211d), (ton s < t \u2194 s < inv t) \u2227 (t < ton s \u2194 inv t < s)\n      else \u2200 s \u2208 Ioi (0 : \u211d), \u2200 t \u2208 Ioi (0 : \u211d), (ton s < t \u2194 inv t < s) \u2227 (t < ton s \u2194 s < inv t)\n\n/-- A scaled power function gives rise to a ToneCouple. -/\ndef spf_to_tc (spf : ScaledPowerFunction) : ToneCouple where\n  ton := fun s : \u211d \u21a6 (s / spf.d) ^ spf.\u03c3\n  inv := fun t : \u211d \u21a6 spf.d * t ^ spf.\u03c3\u207b\u00b9\n  mon := if spf.\u03c3 > 0 then true else false\n  ran_ton := fun t ht \u21a6 rpow_pos_of_pos (div_pos ht spf.hd) _\n  ran_inv := fun t ht \u21a6 mul_pos spf.hd (rpow_pos_of_pos ht spf.\u03c3\u207b\u00b9)\n  ton_is_ton := by\n    split <;> rename_i sgn_\u03c3\n    \u00b7 simp only [\u2193reduceIte]\n      intro s (hs : s > 0) t (ht : t > 0) hst\n      refine (rpow_lt_rpow_iff ?_ ?_ sgn_\u03c3).mpr ?_\n      \u00b7 exact (div_pos hs spf.hd).le\n      \u00b7 exact (div_pos ht spf.hd).le\n      \u00b7 exact div_lt_div_of_pos_right hst spf.hd\n    \u00b7 simp only [Bool.false_eq_true, \u2193reduceIte]\n      intro s (hs : s > 0) t (ht : t > 0) hst\n      rcases spf.h\u03c3 with \u03c3_pos | \u03c3_neg\n      \u00b7 exact (sgn_\u03c3 \u03c3_pos).elim\n      \u00b7 simp only\n        exact (Real.rpow_lt_rpow_iff_of_neg (div_pos ht spf.hd)\n          (div_pos hs spf.hd) \u03c3_neg).mpr (div_lt_div_of_pos_right hst spf.hd)\n  inv_pf := by\n    split <;> rename_i sgn_\u03c3\n    \u00b7 simp only [\u2193reduceIte, mem_Ioi]\n      refine fun s hs t ht => \u27e8?_, ?_\u27e9\n      \u00b7 rw [\u2190 Real.lt_rpow_inv_iff_of_pos (div_nonneg hs.le spf.hd.le) ht.le sgn_\u03c3,\n        \u2190 _root_.mul_lt_mul_left spf.hd, mul_div_cancel\u2080 _ spf.hd.ne']\n      \u00b7 rw [\u2190 Real.rpow_inv_lt_iff_of_pos ht.le (div_nonneg hs.le spf.hd.le)\n          sgn_\u03c3, \u2190 _root_.mul_lt_mul_left spf.hd, mul_div_cancel\u2080 _ spf.hd.ne']\n    \u00b7 simp only [\u2193reduceIte, mem_Ioi]\n      intro s hs t ht\n      rcases spf.h\u03c3 with \u03c3_pos | \u03c3_neg\n      \u00b7 contradiction\n      \u00b7 constructor\n        \u00b7 rw [\u2190 Real.rpow_inv_lt_iff_of_neg ht (div_pos hs spf.hd) \u03c3_neg,\n            \u2190 _root_.mul_lt_mul_left spf.hd, mul_div_cancel\u2080 _ spf.hd.ne']\n        \u00b7 rw [\u2190 Real.lt_rpow_inv_iff_of_neg (div_pos hs spf.hd) ht \u03c3_neg,\n            \u2190 _root_.mul_lt_mul_left spf.hd, mul_div_cancel\u2080 _ spf.hd.ne']\n\nend\n\nnoncomputable section\n\nopen NNReal ENNReal MeasureTheory Set ComputationsInterpolatedExponents\n    ComputationsChoiceExponent\n\nvariable {\u03b1 \u03b1' E E\u2081 E\u2082 E\u2083 : Type*} {m : MeasurableSpace \u03b1} {m' : MeasurableSpace \u03b1'}\n  {p p' q p\u2080 q\u2080 p\u2081 q\u2081: \u211d\u22650\u221e}\n  {C\u2080 C\u2081 : \u211d\u22650} {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b1'}\n  {a : \u211d}-- truncation parameter\n  [NormedAddCommGroup E]\n  [NormedAddCommGroup E\u2081]\n  [NormedAddCommGroup E\u2082]\n  [NormedAddCommGroup E\u2083]\n  [MeasurableSpace E] [BorelSpace E]\n  [MeasurableSpace E\u2083] [BorelSpace E\u2083]\n  {f : \u03b1 \u2192 E\u2081} {t : \u211d}\n\n/-! ## Results about the particular choice of scale\n\n    The proof of the real interpolation theorem will estimate\n    `distribution (trunc f A(t)) t` and `distribution (trunc_compl f A(t)) t` for a\n    function `A`. The function `A` can be given a closed-form expression that works for\n    _all_ cases in the real interpolation theorem, because of the computation rules available\n    for elements in `\u211d\u22650\u221e` that avoid the need for a limiting procedure, e.g. `\u22a4\u207b\u00b9 = 0`.\n\n    The function `A` will be of the form `A(t) = (t / d) ^ \u03c3` for particular choices of `d` and\n    `\u03c3`. This section contatins results about the scale `d`.\n-/\nnamespace ChoiceScale\n\ndef d := ENNReal.toReal\n    (C\u2080 ^ (q\u2081\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal)) * (eLpNorm f p \u03bc ^ p.toReal) ^\n      (p\u2080\u207b\u00b9.toReal * q\u2081\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal)) /\n    (C\u2081 ^ (q\u2080\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal)) * (eLpNorm f p \u03bc ^ p.toReal) ^\n      (p\u2081\u207b\u00b9.toReal * q\u2080\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal))))\n\nlemma d_pos_aux\u2080 (hF : eLpNorm f p \u03bc \u2208 Ioo 0 \u22a4) :\n    0 < eLpNorm f p \u03bc ^ p.toReal :=\n  ENNReal.rpow_pos (pos_of_Ioo hF) (ne_top_of_Ioo hF)\n\nlemma d_ne_top_aux\u2080 {b : \u211d} {F : \u211d\u22650\u221e} (hF : F \u2208 Ioo 0 \u22a4) : F ^ b \u2260 \u22a4 :=\n  rpow_ne_top' (ne_zero_of_Ioo hF) (ne_top_of_Ioo hF)\n\nlemma d_ne_zero_aux\u2080 {b : \u211d} (hF : eLpNorm f p \u03bc \u2208 Ioo 0 \u22a4) :\n    (eLpNorm f p \u03bc ^ p.toReal) ^ b \u2260 0 :=\n  (ENNReal.rpow_pos (d_pos_aux\u2080 hF) (d_ne_top_aux\u2080 hF)).ne'\n\nlemma d_ne_zero_aux\u2081 {C : \u211d\u22650} {c : \u211d} (hC : C > 0) :\n    (ENNReal.ofNNReal C) ^ c \u2260 0 :=\n  (ENNReal.rpow_pos (ENNReal.coe_pos.mpr hC) coe_ne_top).ne'\n\nlemma d_ne_zero_aux\u2082 {C : \u211d\u22650} {b c : \u211d} (hC : C > 0)\n    (hF : eLpNorm f p \u03bc \u2208 Ioo 0 \u22a4) :\n    C ^ c * (eLpNorm f p \u03bc ^ p.toReal) ^ b \u2260 0 :=\n  (ENNReal.mul_pos (d_ne_zero_aux\u2081 hC) (d_ne_zero_aux\u2080 hF)).ne'\n\nlemma d_ne_top_aux\u2081 {C : \u211d\u22650} {c : \u211d} (hC : C > 0) :\n    (ENNReal.ofNNReal C) ^ c \u2260 \u22a4 :=\n  rpow_ne_top' (ENNReal.coe_pos.mpr hC).ne' coe_ne_top\n\nlemma d_ne_top_aux\u2082 {b : \u211d} (hF : eLpNorm f p \u03bc \u2208 Ioo 0 \u22a4) :\n    (eLpNorm f p \u03bc ^ p.toReal) ^ b \u2260 \u22a4 :=\n  rpow_ne_top' (d_pos_aux\u2080 hF).ne' (d_ne_top_aux\u2080 hF)\n\nlemma d_ne_top_aux\u2083 {C : \u211d\u22650} {b c : \u211d} (hC : C > 0)\n    (hF : eLpNorm f p \u03bc \u2208 Ioo 0 \u22a4) :\n    C ^ c * (eLpNorm f p \u03bc ^ p.toReal) ^ b \u2260 \u22a4 :=\n  mul_ne_top (d_ne_top_aux\u2081 hC) (d_ne_top_aux\u2082 hF)\n\nlemma d_ne_zero_aux\u2083 {b\u2080 c\u2080 b\u2081 c\u2081 : \u211d} (hC\u2080 : C\u2080 > 0) (hC\u2081 : C\u2081 > 0) (hF : eLpNorm f p \u03bc \u2208 Ioo 0 \u22a4) :\n    (C\u2080 ^ c\u2080 * (eLpNorm f p \u03bc ^ p.toReal) ^ b\u2080) /\n    (C\u2081 ^ c\u2081 * (eLpNorm f p \u03bc ^ p.toReal) ^ b\u2081) \u2260 0 := by\n  refine ENNReal.div_ne_zero.mpr \u27e8?_, ?_\u27e9\n  \u00b7 apply d_ne_zero_aux\u2082 <;> try assumption\n  \u00b7 apply d_ne_top_aux\u2083 <;> try assumption\n\nlemma d_ne_top_aux\u2084 {b\u2080 c\u2080 b\u2081 c\u2081 : \u211d} (hC\u2080 : C\u2080 > 0) (hC\u2081 : C\u2081 > 0) (hF : eLpNorm f p \u03bc \u2208 Ioo 0 \u22a4) :\n    (C\u2080 ^ c\u2080 * (eLpNorm f p \u03bc ^ p.toReal) ^ b\u2080) /\n    (C\u2081 ^ c\u2081 * (eLpNorm f p \u03bc ^ p.toReal) ^ b\u2081) \u2260 \u22a4 := by\n  refine (div_lt_top ?_ ?_).ne\n  \u00b7 apply d_ne_top_aux\u2083 <;> assumption\n  \u00b7 apply d_ne_zero_aux\u2082 <;> assumption\n\n-- If the `p`-norm of `f` is positive and finite, then `d` is positive\nlemma d_pos (hC\u2080 : C\u2080 > 0) (hC\u2081 : C\u2081 > 0) (hF : eLpNorm f p \u03bc \u2208 Ioo 0 \u22a4) :\n  @d \u03b1 E\u2081 m p p\u2080 q\u2080 p\u2081 q\u2081 C\u2080 C\u2081 \u03bc _ f > 0 :=\ntoReal_pos (d_ne_zero_aux\u2083 hC\u2080 hC\u2081 hF) (d_ne_top_aux\u2084 hC\u2080 hC\u2081 hF)\n\nlemma d_eq_top\u2080 (hp\u2080 : p\u2080 > 0) (hq\u2081 : q\u2081 > 0) (hp\u2080' : p\u2080 \u2260 \u22a4) (hq\u2080' : q\u2080 = \u22a4) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081):\n    @d \u03b1 E\u2081 m p p\u2080 q\u2080 p\u2081 q\u2081 C\u2080 C\u2081 \u03bc _ f =\n    (\u2191C\u2080 ^ p\u2080.toReal * eLpNorm f p \u03bc ^ p.toReal).toReal ^ p\u2080.toReal\u207b\u00b9 := by\n  unfold d\n  rw [hq\u2080']\n  simp only [inv_top, zero_toReal, sub_zero, zero_div, ENNReal.rpow_zero, mul_zero, mul_one,\n    div_one]\n  rw [mul_div_cancel_right\u2080]\n  \u00b7 rw [div_eq_mul_inv, mul_inv_cancel\u2080, ENNReal.rpow_one]\n    \u00b7 rw [toReal_rpow, ENNReal.mul_rpow_of_nonneg]\n      \u00b7 rw [ENNReal.rpow_rpow_inv, toReal_inv]\n        exact (exp_toReal_pos hp\u2080 hp\u2080').ne'\n      \u00b7 positivity\n    \u00b7 exact (inv_toReal_pos_of_ne_top hq\u2081 ((hq\u2080' \u25b8 hq\u2080q\u2081).symm)).ne'\n  \u00b7 exact (inv_toReal_pos_of_ne_top hq\u2081 ((hq\u2080' \u25b8 hq\u2080q\u2081).symm)).ne'\n\nlemma d_eq_top\u2081 (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hp\u2081' : p\u2081 \u2260 \u22a4) (hq\u2081' : q\u2081 = \u22a4)\n    (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081) (hC\u2081 : C\u2081 > 0) :\n    @d \u03b1 E\u2081 m p p\u2080 q\u2080 p\u2081 q\u2081 C\u2080 C\u2081 \u03bc _ f =\n    (\u2191C\u2081 ^ p\u2081.toReal * eLpNorm f p \u03bc ^ p.toReal).toReal ^ p\u2081.toReal\u207b\u00b9 := by\n  unfold d\n  rw [hq\u2081']\n  simp only [inv_top, zero_toReal, zero_sub, zero_div, ENNReal.rpow_zero, mul_zero, mul_one,\n    one_div]\n  rw [div_neg, div_neg]\n  rw [mul_div_cancel_right\u2080]\n  \u00b7 rw [div_eq_mul_inv, mul_inv_cancel\u2080, ENNReal.rpow_neg_one]\n    \u00b7 rw [toReal_rpow, ENNReal.mul_rpow_of_nonneg]\n      \u00b7 rw [ENNReal.rpow_rpow_inv, \u2190 toReal_inv, ENNReal.mul_inv, inv_inv]\n        \u00b7 rw [\u2190 ENNReal.rpow_neg_one, \u2190 ENNReal.rpow_mul, toReal_inv, mul_neg, mul_one, neg_neg,\n            toReal_mul, coe_toReal]\n        \u00b7 left; exact ENNReal.inv_ne_zero.mpr coe_ne_top\n        \u00b7 left; exact inv_ne_top.mpr <| (ENNReal.coe_pos.mpr hC\u2081).ne'\n        \u00b7 exact (exp_toReal_pos hp\u2081 hp\u2081').ne'\n      \u00b7 positivity\n    \u00b7 exact (inv_toReal_pos_of_ne_top hq\u2080 (hq\u2081' \u25b8 hq\u2080q\u2081)).ne'\n  \u00b7 exact (inv_toReal_pos_of_ne_top hq\u2080 (hq\u2081' \u25b8 hq\u2080q\u2081)).ne'\n\nlemma d_eq_top_of_eq (hC\u2081 : C\u2081 > 0) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hq\u2080' : q\u2080 \u2260 \u22a4)\n(hp\u2080': p\u2080 \u2260 \u22a4) (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 = p\u2081) (hpp\u2080: p = p\u2080) (hq\u2081' : q\u2081 = \u22a4) :\n    @d \u03b1 E\u2081 m p p\u2080 q\u2080 p\u2081 q\u2081 C\u2080 C\u2081 \u03bc _ f = (C\u2081 * eLpNorm f p \u03bc).toReal := by\n  rw [d_eq_top\u2081, \u2190 hp\u2080p\u2081, hpp\u2080] <;> try assumption\n  on_goal 1 => rw [toReal_rpow, ENNReal.mul_rpow_of_nonneg, ENNReal.rpow_rpow_inv, ENNReal.rpow_rpow_inv]\n  \u00b7 exact exp_toReal_ne_zero' hp\u2080 hp\u2080'\n  \u00b7 exact exp_toReal_ne_zero' hp\u2080 hp\u2080'\n  \u00b7 positivity\n  \u00b7 exact hp\u2080p\u2081 \u25b8 hp\u2080'\n  \u00b7 exact hq\u2081' \u25b8 hq\u2080'\n\nlemma d_eq_top_top (hq\u2080 : q\u2080 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081) (hp\u2081' : p\u2081 = \u22a4) (hq\u2081' : q\u2081 = \u22a4) :\n    @d \u03b1 E\u2081 m p p\u2080 q\u2080 p\u2081 q\u2081 C\u2080 C\u2081 \u03bc _ f = C\u2081 := by\n  unfold d\n  rw [hp\u2081', hq\u2081']\n  simp only [inv_top, zero_toReal, zero_sub, zero_div, ENNReal.rpow_zero, mul_zero, mul_one,\n    zero_mul, one_div]\n  rw [div_neg, div_eq_mul_inv, mul_inv_cancel\u2080]\n  \u00b7 rw [ENNReal.rpow_neg, ENNReal.rpow_one, inv_inv, coe_toReal]\n  \u00b7 exact (toReal_pos (ENNReal.inv_ne_zero.mpr (hq\u2081' \u25b8 hq\u2080q\u2081)) (ENNReal.inv_ne_top.mpr hq\u2080.ne')).ne'\n\n/-- The particular choice of scaled power function that works in the proof of the\n    real interpolation theorem. -/\ndef spf_ch (ht : t \u2208 Ioo 0 1) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081) (hp\u2080 : 0 < p\u2080) (hq\u2080 : 0 < q\u2080)\n    (hp\u2081 : 0 < p\u2081) (hq\u2081 : 0 < q\u2081) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hC\u2080 : C\u2080 > 0) (hC\u2081 : C\u2081 > 0)\n    (hF : eLpNorm f p \u03bc \u2208 Ioo 0 \u22a4) :\n    ScaledPowerFunction where\n  \u03c3 := @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t\n  d := @d _ E\u2081 _ p p\u2080 q\u2080 p\u2081 q\u2081 C\u2080 C\u2081 \u03bc _ f\n  h\u03c3 := lt_or_gt_of_ne <| Ne.symm <| (\u03b6_ne_zero ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081 hq\u2080q\u2081)\n  hd := d_pos hC\u2080 hC\u2081 hF\n\nend ChoiceScale\n\nend\n\nnoncomputable section\n\nopen NNReal ENNReal MeasureTheory Set\n\nvariable {\u03b1 \u03b1' E E\u2081 E\u2082 E\u2083 : Type*} {m : MeasurableSpace \u03b1} {m' : MeasurableSpace \u03b1'}\n  {p p' q p\u2080 q\u2080 p\u2081 q\u2081: \u211d\u22650\u221e} {c : \u211d\u22650}\n  {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b1'}\n  {f : \u03b1 \u2192 E\u2081} {t : \u211d}\n\n/-! ## Some tools for measure theory computations\n    A collection of small lemmas to help with integral manipulations.\n-/\nnamespace MeasureTheory\n\n-- TODO: change lhs and rhs?\n-- TODO: rewrite the condition in filter form?\nlemma lintegral_double_restrict_set {A B: Set \u03b1} {f : \u03b1 \u2192 \u211d\u22650\u221e} (hA : MeasurableSet A)\n  (hB : MeasurableSet B) (hf : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, x \u2208 A \\ B \u2192 f x \u2264 0) :\n    \u222b\u207b x in A, f x \u2202\u03bc = \u222b\u207b x in A \u2229 B, f x \u2202\u03bc := by\n  have h\u2080 := setLIntegral_mono_ae' (MeasurableSet.diff hA hB) hf; rw [lintegral_zero] at h\u2080\n  rw [\u2190 lintegral_inter_add_diff (hB := hB), nonpos_iff_eq_zero.mp h\u2080, add_zero]\n\nlemma measure_preserving_shift {a : \u211d} :\n    MeasurePreserving (fun x \u21a6 a + x) volume volume :=\n  measurePreserving_add_left volume a\n\nlemma measureable_embedding_shift {a : \u211d} : MeasurableEmbedding (fun x \u21a6 a + x) :=\n  measurableEmbedding_addLeft a\n\nlemma measure_preserving_scaling {a : \u211d} (ha : a \u2260 0) :\n    MeasurePreserving (fun x \u21a6 a * x) volume ((ENNReal.ofReal |a\u207b\u00b9|) \u2022 volume) :=\n  { measurable := measurable_const_mul a, map_eq := Real.map_volume_mul_left ha }\n\nlemma lintegral_shift (f : \u211d \u2192 ENNReal) {a : \u211d} :\n    \u222b\u207b x : \u211d, (f (x + a)) = \u222b\u207b x : \u211d, f x :=\n  lintegral_add_right_eq_self f a\n\nlemma lintegral_shift' (f : \u211d \u2192 ENNReal) {a : \u211d} {s : Set \u211d}:\n    \u222b\u207b (x : \u211d) in (fun z : \u211d \u21a6 z + a)\u207b\u00b9' s, f (x + a) = \u222b\u207b (x : \u211d) in s, f x := by\n  rw [(measurePreserving_add_right volume a).setLIntegral_comp_preimage_emb\n    (measurableEmbedding_addRight a)]\n\nlemma lintegral_add_right_Ioi (f : \u211d \u2192 ENNReal) {a b : \u211d} :\n    \u222b\u207b (x : \u211d) in Ioi (b - a), f (x + a) = \u222b\u207b (x : \u211d) in Ioi b, f x := by\n  nth_rewrite 2 [\u2190 lintegral_shift' (a := a)]\n  simp\n\nlemma lintegral_scale_constant (f: \u211d \u2192 ENNReal) {a : \u211d} (h : a \u2260 0):\n    \u222b\u207b x : \u211d, f (a*x) = ENNReal.ofReal |a\u207b\u00b9| * \u222b\u207b x, f x := by\n  rw [\u2190 @lintegral_smul_measure, MeasurePreserving.lintegral_comp_emb]\n  \u00b7 exact measure_preserving_scaling h\n  \u00b7 exact measurableEmbedding_mulLeft\u2080 h\n\nlemma lintegral_scale_constant_preimage (f: \u211d \u2192 ENNReal) {a : \u211d} (h : a \u2260 0)\n    {s : Set \u211d}:\n    \u222b\u207b x : \u211d in (fun z : \u211d \u21a6 a * z)\u207b\u00b9' s, f (a*x) = ENNReal.ofReal |a\u207b\u00b9| * \u222b\u207b x : \u211d in s, f x\n    := by\n  rw [\u2190 lintegral_smul_measure,\n    (measure_preserving_scaling h).setLIntegral_comp_preimage_emb (measurableEmbedding_mulLeft\u2080 h),\n    Measure.restrict_smul]\n\nlemma lintegral_scale_constant_halfspace (f: \u211d \u2192 ENNReal) {a : \u211d} (h : 0 < a) :\n    \u222b\u207b x : \u211d in Ioi 0, f (a*x) = ENNReal.ofReal |a\u207b\u00b9| * \u222b\u207b x : \u211d in Ioi 0, f x := by\n  rw [\u2190 lintegral_scale_constant_preimage f h.ne']\n  have h\u2080 : (fun z \u21a6 a * z) \u207b\u00b9' Ioi 0 = Ioi 0 := by\n    ext x\n    simp [mul_pos_iff_of_pos_left h]\n  rw [h\u2080]\n\nlemma lintegral_scale_constant_halfspace' {f: \u211d \u2192 ENNReal} {a : \u211d} (h : 0 < a) :\n    ENNReal.ofReal |a| * \u222b\u207b x : \u211d in Ioi 0, f (a*x) = \u222b\u207b x : \u211d in Ioi 0, f x := by\n  rw [lintegral_scale_constant_halfspace f h, \u2190 mul_assoc, \u2190 ofReal_mul (abs_nonneg a),\n    abs_inv, mul_inv_cancel\u2080 (abs_ne_zero.mpr h.ne')]\n  simp\n\nlemma lintegral_scale_constant' {f: \u211d \u2192 ENNReal} {a : \u211d} (h : a \u2260 0):\n    ENNReal.ofReal |a| * \u222b\u207b x : \u211d, f (a*x) = \u222b\u207b x, f x := by\n  rw [lintegral_scale_constant f h, \u2190 mul_assoc, \u2190 ofReal_mul (abs_nonneg a), abs_inv,\n      mul_inv_cancel\u2080 (abs_ne_zero.mpr h)]\n  simp\n\n-- local convenience function\nlemma lintegral_rw_aux {g : \u211d \u2192 \u211d\u22650\u221e} {f\u2081 f\u2082 : \u211d \u2192 \u211d\u22650\u221e} {A : Set \u211d}\n    (heq : f\u2081 =\u1da0[ae (volume.restrict A)] f\u2082) :\n    \u222b\u207b s in A, g s * f\u2081 s = \u222b\u207b s in A, g s * f\u2082 s :=\n  (lintegral_rw\u2082 (Filter.EventuallyEq.refl (ae (volume.restrict A)) g) heq HMul.hMul)\n\nlemma power_aux {p q : \u211d} :\n    (fun s \u21a6 ENNReal.ofReal s ^ (p + q)) =\u1da0[ae (volume.restrict (Ioi (0 : \u211d)))]\n    (fun s \u21a6 ENNReal.ofReal s ^ p * ENNReal.ofReal s ^ q ) := by\n  filter_upwards [self_mem_ae_restrict measurableSet_Ioi] with s (hs : s > 0)\n  rw [ofReal_rpow_of_pos hs, ofReal_rpow_of_pos hs, ofReal_rpow_of_pos hs,\n    \u2190 ofReal_mul (by positivity), \u2190 Real.rpow_add hs]\n\nlemma power_aux_2 {p q : \u211d} :\n    (fun s \u21a6 ENNReal.ofReal (s ^ (p + q))) =\u1da0[ae (volume.restrict (Ioi (0 : \u211d)))]\n    (fun s \u21a6 ENNReal.ofReal (s ^ p) * ENNReal.ofReal (s ^ q) ) := by\n  filter_upwards [self_mem_ae_restrict measurableSet_Ioi] with s (hs : s > 0)\n  rw [\u2190 ofReal_mul (by positivity), \u2190 Real.rpow_add hs]\n\nlemma ofReal_rpow_of_pos_aux {p : \u211d} :\n    (fun s \u21a6 ENNReal.ofReal s ^ p) =\u1da0[ae (volume.restrict (Ioi (0 : \u211d)))]\n    (fun s \u21a6 ENNReal.ofReal (s ^ p)) := by\n  filter_upwards [self_mem_ae_restrict measurableSet_Ioi]\n    with s (hs : s > 0) using ofReal_rpow_of_pos hs\n\nlemma extract_constant_double_integral_rpow {f : \u211d \u2192 \u211d \u2192 \u211d\u22650\u221e} {q : \u211d} (hq : q \u2265 0) {a : \u211d\u22650\u221e}\n    (ha : a \u2260 \u22a4):\n    \u222b\u207b (s : \u211d) in Ioi 0, (\u222b\u207b (t : \u211d) in Ioi 0, a * f s t) ^ q =\n    a ^ q * \u222b\u207b (s : \u211d) in Ioi 0, (\u222b\u207b (t : \u211d) in Ioi 0, f s t) ^ q := by\n  simp_rw [\u2190 lintegral_const_mul' _ _ (rpow_ne_top_of_nonneg hq ha),\n    \u2190 ENNReal.mul_rpow_of_nonneg _ _ hq, lintegral_const_mul' a _ ha]\n\nlemma ofReal_rpow_rpow_aux {p : \u211d} :\n    (fun s \u21a6 ENNReal.ofReal s ^ p) =\u1da0[ae (volume.restrict (Ioi (0 : \u211d)))]\n    (fun s \u21a6 ENNReal.ofReal (s ^ p)) := by\n  filter_upwards [self_mem_ae_restrict measurableSet_Ioi]\n    with s (hs : s > 0) using ofReal_rpow_of_pos hs\n\nlemma lintegral_rpow_of_gt {\u03b2 \u03b3 : \u211d} (h\u03b2 : \u03b2 > 0) (h\u03b3 : \u03b3 > -1) :\n    \u222b\u207b s : \u211d in Ioo 0 \u03b2, ENNReal.ofReal (s ^ \u03b3) =\n    ENNReal.ofReal (\u03b2 ^ (\u03b3 + 1) / (\u03b3 + 1)) := by\n  have h\u03b32 : \u03b3 + 1 > 0 := by linarith\n  rw [setLIntegral_congr Ioo_ae_eq_Ioc, \u2190 ofReal_integral_eq_lintegral_ofReal]\n  \u00b7 rw [\u2190 intervalIntegral.integral_of_le h\u03b2.le, integral_rpow]\n    \u00b7 rw [Real.zero_rpow h\u03b32.ne', sub_zero]\n    \u00b7 exact Or.inl h\u03b3\n  \u00b7 apply (@intervalIntegral.intervalIntegrable_rpow' 0 \u03b2 \u03b3 ?_).1\n    linarith\n  \u00b7 filter_upwards [self_mem_ae_restrict measurableSet_Ioc]\n      with s hs using Real.rpow_nonneg hs.1.le \u03b3\n\nend MeasureTheory\n\nend\n\nnoncomputable section\n\nopen NNReal ENNReal MeasureTheory Set ComputationsInterpolatedExponents\n\nvariable {\u03b1 \u03b1' E E\u2081 E\u2082 E\u2083 : Type*} {m : MeasurableSpace \u03b1} {m' : MeasurableSpace \u03b1'}\n  {p p' q p\u2080 q\u2080 p\u2081 q\u2081: \u211d\u22650\u221e} {c : \u211d\u22650} {a : \u211d}\n  {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b1'}\n  {f : \u03b1 \u2192 E\u2081} {t : \u211d}\n\n/-! ## Results about truncations of a function\n-/\nnamespace MeasureTheory\n\n/-- The `t`-truncation of a function `f`. -/\ndef trunc [NormedAddCommGroup E\u2081] (f : \u03b1 \u2192 E\u2081) (t : \u211d) (x : \u03b1) : E\u2081 := if \u2016f x\u2016 \u2264 t then f x else 0\n\n/-- The complement of a `t`-truncation of a function `f`. -/\ndef trunc_compl [NormedAddCommGroup E\u2081] (f : \u03b1 \u2192 E\u2081) (t : \u211d) : \u03b1 \u2192 E\u2081 := f - trunc f t\n\nlemma trunc_compl_eq [NormedAddCommGroup E\u2081] {a : \u211d} {f : \u03b1 \u2192 E\u2081} :\n    f - trunc f a = fun x \u21a6 if a < \u2016f x\u2016 then f x else 0 := by\n  ext x\n  simp_rw [Pi.sub_apply, trunc, \u2190 not_lt, ite_not, apply_ite (f x - \u00b7), sub_zero, sub_self]\n\n/-- A function to deal with truncations and complement of truncations in one go. -/\ndef trnc [NormedAddCommGroup E\u2081] (j : Bool) (f : \u03b1 \u2192 E\u2081) (t : \u211d)  : \u03b1 \u2192 E\u2081 :=\n  match j with\n  | false => f - trunc f t\n  | true => trunc f t\n\n/-- A function is the complement if its truncation and the complement of the truncation. -/\nlemma trunc_buildup [NormedAddCommGroup E\u2081] : f = trunc f t + trunc_compl f t := by\n  ext x; simp [trunc, trunc_compl]\n\n/-- If the truncation parameter is non-positive, the truncation vanishes. -/\nlemma trunc_of_nonpos {f : \u03b1 \u2192 E\u2081} {a : \u211d} [NormedAddCommGroup E\u2081] (ha : a \u2264 0) :\n    trunc f a = 0 := by\n  unfold trunc\n  ext x\n  split_ifs\n  \u00b7 dsimp only [Pi.zero_apply]\n    apply norm_eq_zero.mp\n    \u00b7 have : \u2016f x\u2016 \u2265 0 := norm_nonneg _\n      linarith []\n  \u00b7 rfl\n\n/-- If the truncation parameter is non-positive, the complement of the truncation is the\n    function itself. -/\nlemma trunc_compl_of_nonpos {f : \u03b1 \u2192 E\u2081} {a : \u211d} [NormedAddCommGroup E\u2081] (ha : a \u2264 0) :\n    trunc_compl f a = f := by\n  unfold trunc_compl\n  rw [trunc_compl_eq]\n  ext x\n  dsimp only [Pi.zero_apply]\n  split_ifs\n  \u00b7 rfl\n  \u00b7 apply (norm_eq_zero.mp ?_).symm\n    have : \u2016f x\u2016 \u2265 0 := norm_nonneg _\n    linarith\n\n/-! ## Measurability properties of truncations -/\n\n-- @[measurability, fun_prop]\n-- lemma _root_.Measurable.trunc [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081]\n--     (hf : Measurable f) : Measurable (trunc f t) := by\n--   refine hf.ite (measurableSet_le ?_ ?_) measurable_const <;> fun_prop\n\n-- @[measurability, fun_prop]\n-- lemma _root_.Measurable.trunc_compl [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081]\n--     (hf : Measurable f) :\n--     Measurable (f - trunc f t) := by\n--   rw [trunc_compl_eq]\n--   apply Measurable.ite ?_ hf measurable_const\n--   exact measurableSet_lt measurable_const hf.norm\n\n@[measurability]\nprotected lemma StronglyMeasurable.trunc [NormedAddCommGroup E\u2081]\n    (hf : StronglyMeasurable f) : StronglyMeasurable (trunc f t) :=\n  StronglyMeasurable.ite (measurableSet_le hf.norm stronglyMeasurable_const) hf\n    stronglyMeasurable_const\n\n@[measurability]\nprotected lemma StronglyMeasurable.trunc_compl [NormedAddCommGroup E\u2081]\n    (hf : StronglyMeasurable f) : StronglyMeasurable (f - trunc f t) := by\n  rw [trunc_compl_eq]\n  exact hf.ite (measurableSet_lt stronglyMeasurable_const hf.norm) stronglyMeasurable_const\n\n-- @[measurability, fun_prop]\n-- lemma aemeasurable_trunc [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081]\n--     (hf : AEMeasurable f \u03bc) :\n--     AEMeasurable (trunc f t) \u03bc := by\n--   rcases hf with \u27e8g, \u27e8wg1, wg2\u27e9\u27e9\n--   exists (trunc g t)\n--   constructor\n--   \u00b7 apply wg1.indicator (s := {x | \u2016g x\u2016 \u2264 t}) (measurableSet_le wg1.norm measurable_const)\n--   apply measure_mono_null ?_ wg2\n--   intro x\n--   contrapose\n--   simp only [mem_compl_iff, mem_setOf_eq, not_not]\n--   intro h\u2082\n--   unfold trunc\n--   rewrite [h\u2082]\n--   rfl\n\n-- @[measurability, fun_prop]\n-- lemma aeMeasurable_trunc_compl [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081]\n--     (hf : AEMeasurable f \u03bc) :\n--     AEMeasurable (trunc_compl f t) \u03bc := by\n--   rcases hf with \u27e8g, \u27e8wg1, wg2\u27e9\u27e9\n--   exists (trunc_compl g t)\n--   constructor\n--   \u00b7 unfold trunc_compl\n--     rw [trunc_compl_eq]\n--     exact wg1.indicator (s := {x | t < \u2016g x\u2016}) (measurableSet_lt measurable_const wg1.norm)\n--   \u00b7 apply measure_mono_null ?_ wg2\n--     intro x\n--     contrapose\n--     simp only [mem_compl_iff, mem_setOf_eq, not_not]\n--     intro f_eq_g; unfold trunc_compl; unfold trunc; dsimp only [Pi.sub_apply]; rw [f_eq_g]\n\n@[measurability]\nlemma aestronglyMeasurable_trunc [NormedAddCommGroup E\u2081]\n    (hf : AEStronglyMeasurable f \u03bc) :\n    AEStronglyMeasurable (trunc f t) \u03bc := by\n  rcases hf with \u27e8g, \u27e8wg1, wg2\u27e9\u27e9\n  exists (trunc g t)\n  constructor\n  \u00b7 exact wg1.indicator (s := {x | \u2016g x\u2016 \u2264 t}) (wg1.norm.measurableSet_le stronglyMeasurable_const)\n  \u00b7 refine measure_mono_null (fun x \u21a6 ?_) wg2\n    contrapose\n    simp only [mem_compl_iff, mem_setOf_eq, not_not]\n    intro h\u2082\n    unfold trunc\n    rw [h\u2082]\n\n@[measurability]\nlemma aestronglyMeasurable_trunc_compl [NormedAddCommGroup E\u2081]\n    (hf : AEStronglyMeasurable f \u03bc) :\n    AEStronglyMeasurable (f - trunc f t) \u03bc := by\n  rcases hf with \u27e8g, \u27e8wg1, wg2\u27e9\u27e9\n  exists (g - trunc g t)\n  constructor\n  \u00b7 rw [trunc_compl_eq]\n    exact wg1.indicator (s := {x | t < \u2016g x\u2016}) (stronglyMeasurable_const.measurableSet_lt wg1.norm)\n  \u00b7 apply measure_mono_null ?_ wg2\n    intro x\n    contrapose\n    simp only [mem_compl_iff, mem_setOf_eq, not_not]\n    intro h\u2082\n    rw [trunc_compl_eq, trunc_compl_eq]\n    simp only\n    rw [h\u2082]\n\n@[measurability]\nlemma aestronglyMeasurable_trnc {j : Bool} [NormedAddCommGroup E\u2081]\n    (hf : AEStronglyMeasurable f \u03bc) :\n    AEStronglyMeasurable (trnc j f t) \u03bc := by\n  rcases j\n  \u00b7 exact aestronglyMeasurable_trunc_compl hf\n  \u00b7 exact aestronglyMeasurable_trunc hf\n\nlemma trunc_le {f : \u03b1 \u2192 E\u2081} {a : \u211d} [NormedAddCommGroup E\u2081] (x : \u03b1) :\n    \u2016trunc f a x\u2016 \u2264 max 0 a := by\n  unfold trunc\n  split_ifs with h\n  \u00b7 rcases (lt_or_le a 0) with a_lt_0 | _\n    \u00b7 exact Trans.trans (Trans.trans h a_lt_0.le) (le_max_left 0 a)\n    \u00b7 exact Trans.trans h (le_max_right 0 a)\n  \u00b7 simp\n\n/-- A small lemma that is helpful for rewriting -/\nlemma coe_coe_eq_ofReal (a : \u211d) : ofNNReal a.toNNReal = ENNReal.ofReal a := by rfl\n\nlemma trunc_eLpNormEssSup_le {f : \u03b1 \u2192 E\u2081} {a : \u211d} [NormedAddCommGroup E\u2081] :\n    eLpNormEssSup (trunc f a) \u03bc \u2264 ENNReal.ofReal (max 0 a) := by\n  refine essSup_le_of_ae_le _ (ae_of_all _ fun x \u21a6 ?_)\n  simp only [enorm_eq_nnnorm, \u2190 norm_toNNReal, coe_coe_eq_ofReal]\n  exact ofReal_le_ofReal (trunc_le x)\n\nlemma trunc_mono {f : \u03b1 \u2192 E\u2081} {a b : \u211d} [NormedAddCommGroup E\u2081]\n    (hab : a \u2264 b) {x : \u03b1} : \u2016trunc f a x\u2016 \u2264 \u2016trunc f b x\u2016 := by\n  unfold trunc\n  split_ifs\n  \u00b7 rfl\n  \u00b7 linarith\n  \u00b7 rw [norm_zero]; exact norm_nonneg _\n  \u00b7 exact le_refl _\n\n/-- The norm of the truncation is monotone in the truncation parameter -/\nlemma norm_trunc_mono {f : \u03b1 \u2192 E\u2081} [NormedAddCommGroup E\u2081] :\n    Monotone fun s \u21a6 eLpNorm (trunc f s) p \u03bc :=\n  fun _a _b hab \u21a6 eLpNorm_mono fun _x \u21a6 trunc_mono hab\n\nlemma trunc_buildup_norm {f : \u03b1 \u2192 E\u2081} {a : \u211d} {x : \u03b1} [NormedAddCommGroup E\u2081] :\n    \u2016trunc f a x\u2016 + \u2016(f - trunc f a) x\u2016 = \u2016f x\u2016 := by\n  simp only [trunc, Pi.sub_apply]; split_ifs with h <;> simp\n\nlemma trunc_le_func {f : \u03b1 \u2192 E\u2081} {a : \u211d} {x : \u03b1} [NormedAddCommGroup E\u2081] :\n    \u2016trunc f a x\u2016 \u2264 \u2016f x\u2016 := by\n  unfold trunc; split_ifs <;> simp\n\nlemma trunc_compl_le_func {f : \u03b1 \u2192 E\u2081} {a : \u211d} {x : \u03b1} [NormedAddCommGroup E\u2081] :\n    \u2016(f - trunc f a) x\u2016 \u2264 \u2016f x\u2016 := by\n  rw [trunc_compl_eq]; dsimp only; split_ifs <;> simp\n\nlemma trunc_compl_anti {f : \u03b1 \u2192 E\u2081} {a b : \u211d} {x : \u03b1} [NormedAddCommGroup E\u2081] (hab : a \u2264 b) :\n    \u2016(f - trunc f b) x\u2016 \u2264 \u2016(f - trunc f a) x\u2016 := by\n  have obs : \u2016trunc f a x\u2016 + \u2016(f - trunc f a) x\u2016 = \u2016trunc f b x\u2016 + \u2016(f - trunc f b) x\u2016 := by\n    rw [trunc_buildup_norm, trunc_buildup_norm]\n  have : \u2016trunc f a x\u2016 \u2264 \u2016trunc f b x\u2016 := trunc_mono hab\n  linarith\n\n/-- The norm of the complement of the truncation is antitone in the truncation parameter -/\nlemma norm_trunc_compl_anti {f : \u03b1 \u2192 E\u2081} [NormedAddCommGroup E\u2081] :\n    Antitone (fun s \u21a6 eLpNorm (f - trunc f s) p \u03bc) :=\n  fun _a _b hab \u21a6 eLpNorm_mono (fun _ \u21a6 trunc_compl_anti hab)\n\n/-- The norm of the truncation is meaurable in the truncation parameter -/\n@[measurability, fun_prop]\nlemma norm_trunc_measurable [NormedAddCommGroup E\u2081] :\n    Measurable (fun s \u21a6 eLpNorm (trunc f s) p \u03bc) :=\n  norm_trunc_mono.measurable\n\n/-- The norm of the complement of the truncation is measurable in the truncation parameter -/\n@[measurability, fun_prop]\nlemma norm_trunc_compl_measurable [NormedAddCommGroup E\u2081] :\n    Measurable (fun s \u21a6 eLpNorm (f - trunc f s) p \u03bc) :=\n  norm_trunc_compl_anti.measurable\n\nlemma trnc_le_func {j : Bool} {f : \u03b1 \u2192 E\u2081} {a : \u211d} {x : \u03b1} [NormedAddCommGroup E\u2081] :\n    \u2016trnc j f a x\u2016 \u2264 \u2016f x\u2016 := by\n  unfold trnc trunc\n  rcases j\n  \u00b7 dsimp only [Pi.sub_apply]\n    split_ifs <;> simp\n  \u00b7 dsimp only\n    split_ifs <;> simp\n\n-- /-- ## Distribution functions of truncations -/\n\n-- /-- The `t`-truncation of `f : \u03b1 \u2192\u2098[\u03bc] E`. -/\n-- def AEEqFun.trunc (f : \u03b1 \u2192\u2098[\u03bc] E) (t : \u211d) : \u03b1 \u2192\u2098[\u03bc] E :=\n--   AEEqFun.mk (trunc f t) (aestronglyMeasurable_trunc f.aestronglyMeasurable)\n\n-- /-- A set of measurable functions is closed under truncation. -/\n-- class IsClosedUnderTruncation (U : Set (\u03b1 \u2192\u2098[\u03bc] E)) : Prop where\n--   trunc_mem {f : \u03b1 \u2192\u2098[\u03bc] E} (hf : f \u2208 U) (t : \u211d) : f.trunc t \u2208 U\n\n/-! ## Truncations and L-p spaces -/\n\nlemma power_estimate {a b t \u03b3 : \u211d} (h\u03b3 : \u03b3 > 0) (ht\u03b3 : \u03b3 \u2264 t) (hab : a \u2264 b) :\n    (t / \u03b3) ^ a \u2264 (t / \u03b3) ^ b := by\n  gcongr\n  exact (one_le_div h\u03b3).mpr ht\u03b3\n\nlemma power_estimate' {a b t \u03b3 : \u211d} (ht : t > 0) (ht\u03b3 : t \u2264 \u03b3) (hab: a \u2264 b) :\n    (t / \u03b3) ^ b \u2264 (t / \u03b3) ^ a := by\n  have \u03b3_pos : \u03b3 > 0 := lt_of_lt_of_le ht ht\u03b3\n  exact Real.rpow_le_rpow_of_exponent_ge (div_pos ht (\u03b3_pos)) (div_le_one_of_le\u2080 ht\u03b3 \u03b3_pos.le) hab\n\nlemma rpow_le_rpow_of_exponent_le_base_le {a b t \u03b3 : \u211d} (ht : t > 0) (ht\u03b3 : t \u2264 \u03b3) (hab : a \u2264 b) :\n    ENNReal.ofReal (t ^ b) \u2264 ENNReal.ofReal (t ^ a) * ENNReal.ofReal (\u03b3 ^ (b - a)) := by\n  rw [mul_comm]\n  have \u03b3_pos : 0 < \u03b3 := lt_of_lt_of_le ht ht\u03b3\n  rw [Real.rpow_sub \u03b3_pos]\n  refine (ENNReal.mul_le_mul_left (a := ENNReal.ofReal (\u03b3 ^ (-b) )) ?_ coe_ne_top).mp ?_\n  \u00b7 exact (ofReal_pos.mpr (Real.rpow_pos_of_pos \u03b3_pos (-b))).ne'\n  \u00b7 rw [\u2190 ofReal_mul, \u2190 mul_assoc, \u2190 ofReal_mul, \u2190 mul_div_assoc, \u2190 Real.rpow_add, neg_add_cancel,\n        Real.rpow_zero, \u2190 ofReal_mul, mul_comm] <;> try positivity\n    nth_rw 2 [mul_comm]\n    rw [\u2190 neg_one_mul, Real.rpow_mul, Real.rpow_neg_one, \u2190 Real.mul_rpow] <;> try positivity\n    rw [one_div]\n    nth_rw 2 [\u2190 Real.rpow_neg_one]\n    rw [\u2190 Real.rpow_mul (by positivity)]\n    nth_rw 3 [mul_comm]\n    rw [Real.rpow_mul, Real.rpow_neg_one, \u2190 Real.mul_rpow, \u2190 div_eq_mul_inv] <;> try positivity\n    exact ofReal_le_ofReal (power_estimate' ht ht\u03b3 hab)\n\n-- TODO: there is a lot of overlap between above proof and below\nlemma rpow_le_rpow_of_exponent_le_base_ge {a b t \u03b3 : \u211d} (h\u03b3 : \u03b3 > 0) (ht\u03b3 : \u03b3 \u2264 t) (hab : a \u2264 b) :\n    ENNReal.ofReal (t ^ a) \u2264 ENNReal.ofReal (t ^ b) * ENNReal.ofReal (\u03b3 ^ (a - b)) := by\n  rw [mul_comm]\n  have t_pos : 0 < t := gt_of_ge_of_gt ht\u03b3 h\u03b3\n  rw [Real.rpow_sub h\u03b3]\n  refine (ENNReal.mul_le_mul_left (a := ENNReal.ofReal (\u03b3 ^ (-a) )) ?_ coe_ne_top).mp ?_\n  \u00b7 exact (ofReal_pos.mpr (Real.rpow_pos_of_pos h\u03b3 (-a))).ne'\n  \u00b7 rw [\u2190 ofReal_mul, \u2190 mul_assoc, \u2190 ofReal_mul, \u2190 mul_div_assoc, \u2190 Real.rpow_add, neg_add_cancel,\n        Real.rpow_zero, \u2190 ofReal_mul, mul_comm] <;> try positivity\n    nth_rw 2 [mul_comm]\n    rw [\u2190 neg_one_mul, Real.rpow_mul, Real.rpow_neg_one, \u2190 Real.mul_rpow] <;> try positivity\n    rw [one_div]\n    nth_rw 2 [\u2190 Real.rpow_neg_one]\n    rw [\u2190 Real.rpow_mul (by positivity)]\n    nth_rw 3 [mul_comm]\n    rw [Real.rpow_mul, Real.rpow_neg_one, \u2190 Real.mul_rpow, \u2190 div_eq_mul_inv] <;> try positivity\n    exact ofReal_le_ofReal (Real.rpow_le_rpow_of_exponent_le ((one_le_div h\u03b3).mpr ht\u03b3) hab)\n\nlemma trunc_preserves_Lp {p : \u211d\u22650\u221e} {a : \u211d} [NormedAddCommGroup E\u2081]\n    (hf : Mem\u2112p f p \u03bc) :\n    Mem\u2112p (trunc f a) p \u03bc := by\n  refine \u27e8aestronglyMeasurable_trunc hf.1, lt_of_le_of_lt (eLpNorm_mono_ae (ae_of_all _ ?_)) hf.2\u27e9\n  intro x\n  unfold trunc\n  split_ifs with is_fx_le_a <;> simp\n\n-- lemma snorm_trunc_compl_le {p : \u211d\u22650\u221e} {a : \u211d} [NormedAddCommGroup E\u2081] :\n--     eLpNorm (f - trunc f a) p \u03bc \u2264 eLpNorm f p \u03bc :=\n--   eLpNorm_mono (fun _ \u21a6 trunc_compl_le_func)\n\nlemma trunc_compl_preserves_Lp {p : \u211d\u22650\u221e} {a : \u211d} [NormedAddCommGroup E\u2081] (hf : Mem\u2112p f p \u03bc) :\n    Mem\u2112p (f - trunc f a) p \u03bc :=\n  Mem\u2112p.sub hf (trunc_preserves_Lp hf)\n\nlemma estimate_eLpNorm_trunc_compl {p q : \u211d\u22650\u221e} [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081]\n    [BorelSpace E\u2081] (hp : p \u2260 \u22a4) (hpq : q \u2208 Ioo 0 p) (hf : AEMeasurable f \u03bc) (ha : a > 0) :\n    eLpNorm ((f - trunc f a)) q \u03bc ^ q.toReal \u2264\n    ENNReal.ofReal (a ^ (q.toReal - p.toReal)) *\n    eLpNorm f p \u03bc ^ p.toReal := by\n  unfold eLpNorm eLpNorm'\n  have q_ne_top: q \u2260 \u22a4 := hpq.2.ne_top\n  have p_ne_zero : p \u2260 0 := (lt_trans hpq.1 hpq.2).ne'\n  have q_ne_zero : q \u2260 0 := hpq.1.ne'\n  have q_toReal_pos : q.toReal > 0 := exp_toReal_pos hpq.1 q_ne_top\n  split_ifs\n  \u00b7 contradiction\n  \u00b7 calc\n    _ = \u222b\u207b x : \u03b1 in {x | a < \u2016f x\u2016}, \u2016(f - trunc f a) x\u2016\u2091 ^ q.toReal \u2202\u03bc := by\n      rw [one_div, ENNReal.rpow_inv_rpow]\n      \u00b7 apply (setLIntegral_eq_of_support_subset _).symm\n        unfold Function.support\n        intro x\n        rw [trunc_compl_eq]\n        dsimp only [Pi.sub_apply, mem_setOf_eq]\n        split_ifs with is_a_lt_fx\n        \u00b7 exact fun _ => is_a_lt_fx\n        \u00b7 contrapose; intro _; simpa [enorm_eq_nnnorm]\n      \u00b7 exact exp_toReal_ne_zero' hpq.1 q_ne_top\n    _ \u2264 \u222b\u207b x : \u03b1 in {x | a < \u2016f x\u2016}, \u2016f x\u2016\u2091 ^ q.toReal \u2202\u03bc := by\n      apply lintegral_mono_ae\n      apply ae_of_all\n      intro x\n      gcongr\n      rw [enorm_eq_nnnorm, \u2190 norm_toNNReal, enorm_eq_nnnorm, \u2190 norm_toNNReal]\n      simp only [Pi.sub_apply, ENNReal.coe_le_coe, norm_nonneg, Real.toNNReal_le_toNNReal_iff]\n      apply trnc_le_func (j := \u22a5)\n    _ \u2264 ENNReal.ofReal (a ^ (q.toReal - p.toReal)) * \u222b\u207b x : \u03b1 in {x | a < \u2016f x\u2016},\n        \u2016f x\u2016\u2091 ^ p.toReal \u2202\u03bc := by\n      rw [\u2190 lintegral_const_mul']; swap; \u00b7 exact coe_ne_top\n      simp only [enorm_eq_nnnorm]\n      apply setLIntegral_mono_ae (AEMeasurable.restrict (by fun_prop))\n      \u00b7 apply ae_of_all\n        intro x (hx : a < \u2016f x\u2016)\n        rw [mul_comm]\n        rw [\u2190 enorm_eq_nnnorm, \u2190 ofReal_norm_eq_enorm (f x), ENNReal.ofReal_rpow_of_nonneg,\n          ENNReal.ofReal_rpow_of_nonneg]\n          <;> try positivity\n        exact rpow_le_rpow_of_exponent_le_base_ge ha hx.le (toReal_mono hp hpq.2.le)\n    _ \u2264 ENNReal.ofReal (a ^ (q.toReal - p.toReal)) * \u222b\u207b x : \u03b1,\n        \u2191\u2016f x\u2016\u208a ^ p.toReal \u2202\u03bc := by\n      gcongr\n      exact setLIntegral_le_lintegral _ _\n    _ = _ := by\n      rw [one_div, ENNReal.rpow_inv_rpow]\n      \u00b7 simp only [enorm_eq_nnnorm]\n      \u00b7 exact exp_toReal_ne_zero' (lt_trans hpq.1 hpq.2) hp\n\nlemma estimate_eLpNorm_trunc {p q : \u211d\u22650\u221e}\n    [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081]\n    (hq : q \u2260 \u22a4)\n    (hpq : p \u2208 Ioo 0 q) (hf : AEMeasurable f \u03bc) :\n    eLpNorm (trunc f a) q \u03bc ^ q.toReal \u2264\n    ENNReal.ofReal (a ^ (q.toReal - p.toReal)) * eLpNorm f p \u03bc ^ p.toReal := by\n  unfold eLpNorm eLpNorm'\n  have p_ne_top : p \u2260 \u22a4 := hpq.2.ne_top\n  have : p \u2260 0 := hpq.1.ne'\n  have : q \u2260 0 := (lt_trans hpq.1 hpq.2).ne'\n  split_ifs\n  \u00b7 contradiction\n  \u00b7 calc\n    _ = \u222b\u207b (x : \u03b1) in {x | 0 < \u2016f x\u2016 \u2227 \u2016f x\u2016 \u2264 a}, \u2191\u2016trunc f a x\u2016\u208a ^ q.toReal \u2202\u03bc := by\n      rw [one_div, ENNReal.rpow_inv_rpow]\n      \u00b7 apply Eq.symm\n        apply setLIntegral_eq_of_support_subset\n        unfold Function.support\n        intro x\n        dsimp only [Pi.sub_apply, mem_setOf_eq]\n        unfold trunc\n        split_ifs with is_fx_le_a\n        \u00b7 intro fx_rpow_ne_zero\n          refine \u27e8?_, is_fx_le_a\u27e9\n          contrapose! fx_rpow_ne_zero\n          rw [norm_le_zero_iff.mp fx_rpow_ne_zero]\n          simpa using toReal_pos this hq\n        \u00b7 contrapose; intro _; simpa using toReal_pos this hq\n      \u00b7 exact exp_toReal_ne_zero' (lt_trans hpq.1 hpq.2) hq\n    _ \u2264 \u222b\u207b (x : \u03b1) in {x | 0 < \u2016f x\u2016 \u2227 \u2016f x\u2016 \u2264 a}, \u2016f x\u2016\u208a ^ q.toReal \u2202 \u03bc := by\n      apply lintegral_mono_ae\n      apply ae_of_all\n      intro x\n      gcongr\n      rw [\u2190 norm_toNNReal, \u2190 norm_toNNReal]\n      exact Real.toNNReal_mono (trnc_le_func (j := \u22a4))\n    _ \u2264 ENNReal.ofReal (a ^ (q.toReal - p.toReal)) *\n        \u222b\u207b (x : \u03b1) in {x | 0 < \u2016f x\u2016 \u2227 \u2016f x\u2016 \u2264 a}, \u2016f x\u2016\u208a ^ p.toReal \u2202 \u03bc := by\n      rw [\u2190 lintegral_const_mul']\n      \u00b7 apply setLIntegral_mono_ae (AEMeasurable.restrict (by fun_prop))\n        \u00b7 apply ae_of_all\n          intro x hx\n          rw [mul_comm]\n          rw [\u2190 enorm_eq_nnnorm, \u2190 ofReal_norm_eq_enorm (f x), ENNReal.ofReal_rpow_of_nonneg,\n            ENNReal.ofReal_rpow_of_nonneg] <;> try positivity\n          apply rpow_le_rpow_of_exponent_le_base_le hx.1 hx.2\n          exact toReal_mono hq hpq.2.le\n      \u00b7 exact coe_ne_top\n    _ \u2264 _ := by\n      gcongr\n      rw [one_div, ENNReal.rpow_inv_rpow]\n      \u00b7 exact setLIntegral_le_lintegral _ _\n      \u00b7 exact exp_toReal_ne_zero' hpq.1 p_ne_top\n\n/-- If `f` is in `Lp`, the truncation is element of `Lq` for `q > p`. -/\nlemma trunc_Lp_Lq_higher [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081]\n    (hpq : p \u2208 Ioo 0 q) (hf : Mem\u2112p f p \u03bc) :\n    Mem\u2112p (trnc \u22a4 f a) q \u03bc := by\n  refine \u27e8aestronglyMeasurable_trnc hf.1, ?_\u27e9\n  rcases (eq_or_ne q \u22a4) with q_eq_top | q_ne_top\n  \u00b7 rw [q_eq_top, eLpNorm_exponent_top]\n    exact Trans.trans trunc_eLpNormEssSup_le coe_lt_top\n  \u00b7 rw [\u2190 rpow_lt_top_iff_of_pos (toReal_pos (lt_trans hpq.1 hpq.2).ne' q_ne_top)]\n    apply lt_of_le_of_lt (estimate_eLpNorm_trunc q_ne_top hpq hf.1.aemeasurable)\n    apply mul_lt_top coe_lt_top\n    refine (rpow_lt_top_iff_of_pos ?_).mpr hf.2\n    exact toReal_pos hpq.1.ne' hpq.2.ne_top\n\n/-- If `f` is in `Lp`, the complement of the truncation is in `Lq` for `q < p`. -/\nlemma trunc_compl_Lp_Lq_lower [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081]\n    (hp : p \u2260 \u22a4)\n    (hpq : q \u2208 Ioo 0 p) (ha : a > 0) (hf : Mem\u2112p f p \u03bc) :\n    Mem\u2112p (trnc \u22a5 f a) q \u03bc := by\n  refine \u27e8aestronglyMeasurable_trnc hf.1, ?_\u27e9\n  have : q.toReal > 0 := toReal_pos hpq.left.ne' hpq.right.ne_top\n  refine (rpow_lt_top_iff_of_pos this).mp ?_\n  refine lt_of_le_of_lt\n    (estimate_eLpNorm_trunc_compl hp hpq hf.1.aemeasurable ha) ?_\n  apply mul_lt_top coe_lt_top\n  refine (rpow_lt_top_iff_of_pos ?_).mpr hf.2\n  exact toReal_pos (lt_trans hpq.left hpq.right).ne' hp\n\nend MeasureTheory\n\nend\n\nnoncomputable section\n\nopen NNReal ENNReal MeasureTheory Set\n\nvariable {\u03b1 \u03b1' E E\u2081 E\u2082 E\u2083 : Type*} {m : MeasurableSpace \u03b1} {m' : MeasurableSpace \u03b1'}\n  {p p' q p\u2080 q\u2080 p\u2081 q\u2081: \u211d\u22650\u221e}\n  {C\u2080 C\u2081 : \u211d\u22650} {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b1'}\n  {a : \u211d}-- truncation parameter\n  [NormedAddCommGroup E]\n  [NormedAddCommGroup E\u2081]\n  [NormedAddCommGroup E\u2082]\n  [MeasurableSpace E] [BorelSpace E]\n  {f : \u03b1 \u2192 E\u2081} {t : \u211d}\n\n/-! ## Some results about the integrals of truncations\n\n-/\nnamespace MeasureTheory\n\ndef res (j : Bool) (\u03b2 : \u211d) : Set \u211d :=\n  if j then Ioo (0 : \u211d) \u03b2 else Ioi \u03b2\n\nlemma measurableSet_res {j : Bool} {\u03b2 : \u211d} : MeasurableSet (res j \u03b2) := by\n  unfold res\n  split\n  \u00b7 exact measurableSet_Ioo\n  \u00b7 exact measurableSet_Ioi\n\nlemma res_subset_Ioi {j : Bool} {\u03b2 : \u211d} (h\u03b2 : \u03b2 > 0) : res j \u03b2 \u2286 Ioi 0 := by\n  unfold res\n  split\n  \u00b7 exact Ioo_subset_Ioi_self\n  \u00b7 simp only [Ioi, setOf_subset_setOf]\n    intro s hs\n    linarith\n\ninstance decidableMemRes {j : Bool} {\u03b2 : \u211d} : Decidable (t \u2208 res j \u03b2) := by\n  exact Classical.propDecidable (t \u2208 res j \u03b2)\n\ndef res' (j : Bool) (\u03b2 : \u211d) : Set \u211d :=\n  if j then Ioc (0 : \u211d) \u03b2 else Ici \u03b2\n\nlemma res'comp (j : Bool) (\u03b2 : \u211d) (h\u03b2 : \u03b2 > 0) :\n    Ioi (0 : \u211d) \\ res' j \u03b2 = res (\u00acj) \u03b2 := by\n  unfold res' res\n  split_ifs with h\u2080 h\u2081 h\u2082\n  \u00b7 rw [h\u2080] at h\u2081; simp at h\u2081\n  \u00b7 ext x\n    simp only [mem_diff, mem_Ioi, mem_Ioc, not_and, not_le]\n    constructor\n    \u00b7 tauto\n    \u00b7 intro h\n      exact \u27e8lt_trans h\u03b2 h, fun _ \u21a6 h\u27e9\n  \u00b7 ext x\n    simp only [Ioi_diff_Ici, mem_Ioo]\n  \u00b7 have : j = false := eq_false_of_ne_true h\u2080\n    rw [this] at h\u2082\n    simp at h\u2082\n\nlemma measurableSet_res' {j : Bool} {\u03b2 : \u211d} : MeasurableSet (res' j \u03b2) := by\n  unfold res'\n  measurability\n\nlemma res'subset_Ioi {j : Bool} {\u03b2 : \u211d} (h\u03b2 : \u03b2 > 0) : res' j \u03b2 \u2286 Ioi 0 := by\n  unfold res'\n  split\n  \u00b7 exact Ioc_subset_Ioi_self\n  \u00b7 exact Ici_subset_Ioi.mpr h\u03b2\n\nlemma lintegral_trunc_mul\u2080 {g : \u211d \u2192 \u211d\u22650\u221e} {j : Bool} {x : \u03b1} {tc : ToneCouple} {p : \u211d} (hp : p > 0)\n    (hfx : \u2016f x\u2016\u208a > 0) :\n    \u222b\u207b s : \u211d in Ioi 0, (g s) * \u2016trnc j f (tc.ton s) x\u2016\u208a ^ p =\n    \u222b\u207b s : \u211d in res' (xor j tc.mon) (tc.inv \u2016f x\u2016), (g s) * \u2016trnc j f (tc.ton s) x\u2016\u208a ^ p := by\n  rw [lintegral_double_restrict_set (B := res' (xor j tc.mon) (tc.inv \u2016f x\u2016))\n      measurableSet_Ioi measurableSet_res']\n  \u00b7 have : Ioi 0 \u2229 res' (xor j tc.mon) (tc.inv \u2016f x\u2016) = res' (xor j tc.mon) (tc.inv \u2016f x\u2016) := by\n      refine inter_eq_self_of_subset_right (res'subset_Ioi (tc.ran_inv (\u2016f x\u2016) hfx))\n    rw [this]\n  \u00b7 apply ae_of_all\n    rw [res'comp]\n    \u00b7 intro s\n      unfold res trnc trunc\n      have mon_pf := tc.inv_pf\n      split_ifs at mon_pf with mon\n      \u00b7 rw [mon]\n        rcases j\n        \u00b7 simp only [Bool.bne_true, Bool.not_false, not_true_eq_false, decide_false,\n          Bool.false_eq_true, \u2193reduceIte, Pi.sub_apply]\n          intro (hs : s > tc.inv \u2016f x\u2016)\n          split_ifs with h\n          \u00b7 simp [hp]\n          \u00b7 have := (mon_pf s (lt_trans (tc.ran_inv \u2016f x\u2016 hfx) hs) (\u2016f x\u2016) hfx).2.mpr hs\n            contrapose! h; linarith\n        \u00b7 simp only [bne_self_eq_false, Bool.false_eq_true, not_false_eq_true, decide_true]\n          intro hs\n          split_ifs with h\n          \u00b7 have := (mon_pf s hs.1 (\u2016f x\u2016) hfx).1.mpr hs.2\n            linarith\n          \u00b7 simp [hp]\n      \u00b7 rw [Bool.not_eq_true] at mon\n        rw [mon]\n        rcases j\n        \u00b7 simp only [bne_self_eq_false, Bool.false_eq_true, not_false_eq_true, decide_true,\n          \u2193reduceIte, Pi.sub_apply]\n          intro hs\n          split_ifs with h\n          \u00b7 simp [hp]\n          \u00b7 have := (mon_pf s hs.1 (\u2016f x\u2016) hfx).2.mpr hs.2\n            linarith\n        \u00b7 simp only [Bool.bne_false, not_true_eq_false, decide_false, Bool.false_eq_true, \u2193reduceIte]\n          intro (hs : tc.inv \u2016f x\u2016 < s)\n          have := (mon_pf s (lt_trans (tc.ran_inv \u2016f x\u2016 hfx) hs) (\u2016f x\u2016) hfx).1.mpr hs\n          split_ifs with h\n          \u00b7 linarith\n          \u00b7 simp [hp]\n    \u00b7 exact tc.ran_inv \u2016f x\u2016 hfx\n\nlemma lintegral_trunc_mul\u2081 {g : \u211d \u2192 \u211d\u22650\u221e} {j : Bool} {x : \u03b1} {p : \u211d} {tc : ToneCouple} :\n    \u222b\u207b s : \u211d in res' (xor j tc.mon) (tc.inv \u2016f x\u2016), (g s) * \u2016trnc j f (tc.ton s) x\u2016\u208a ^ p =\n    \u222b\u207b s : \u211d in res (xor j tc.mon) (tc.inv \u2016f x\u2016), (g s) * \u2016trnc j f (tc.ton s) x\u2016\u208a ^ p := by\n  apply setLIntegral_congr\n  unfold res res'\n  split_ifs\n  \u00b7 exact Ioo_ae_eq_Ioc.symm\n  \u00b7 exact Ioi_ae_eq_Ici.symm\n\nlemma lintegral_trunc_mul\u2082 {g : \u211d \u2192 \u211d\u22650\u221e} {j : Bool} {x : \u03b1} {p : \u211d} {tc : ToneCouple}\n    (hfx : \u2016f x\u2016 > 0) :\n    \u222b\u207b s : \u211d in res (xor j tc.mon) (tc.inv \u2016f x\u2016), (g s) * \u2016trnc j f (tc.ton s) x\u2016\u208a ^ p =\n    \u222b\u207b s : \u211d in res (xor j tc.mon) (tc.inv \u2016f x\u2016), (g s) * \u2016f x\u2016\u208a ^ p := by\n  apply setLIntegral_congr_fun measurableSet_res\n  \u00b7 apply ae_of_all\n    unfold res trnc trunc\n    have mon_pf := tc.inv_pf\n    split_ifs at mon_pf with mon\n    \u00b7 rw [mon]\n      rcases j\n      \u00b7 simp only [Bool.bne_true, Bool.not_false, \u2193reduceIte, Pi.sub_apply]\n        intro s hs\n        split_ifs with h\n        \u00b7 have := (mon_pf s hs.1 (\u2016f x\u2016) hfx).1.mpr hs.2\n          contrapose! h; linarith\n        \u00b7 simp\n      \u00b7 simp only [bne_self_eq_false, Bool.false_eq_true, \u2193reduceIte]\n        intro s (hs : s > tc.inv \u2016f x\u2016)\n        split_ifs with h\n        \u00b7 rfl\n        \u00b7 have := (mon_pf s (lt_trans (tc.ran_inv \u2016f x\u2016 hfx) hs) (\u2016f x\u2016) hfx).2.mpr hs\n          contrapose! h; linarith\n    \u00b7 rw [Bool.not_eq_true] at mon\n      rw [mon]\n      rcases j\n      \u00b7 simp only [bne_self_eq_false, Bool.false_eq_true, \u2193reduceIte, Pi.sub_apply]\n        intro s (hs : tc.inv \u2016f x\u2016 < s)\n        have := (mon_pf s (lt_trans (tc.ran_inv \u2016f x\u2016 hfx) hs) (\u2016f x\u2016) hfx).1.mpr hs\n        split_ifs with h\n        \u00b7 linarith\n        \u00b7 simp\n      \u00b7 simp only [Bool.bne_false, \u2193reduceIte]\n        intro s hs\n        have := (mon_pf s hs.1 (\u2016f x\u2016) hfx).2.mpr hs.2\n        split_ifs with h\n        \u00b7 rfl\n        \u00b7 linarith\n\nlemma lintegral_trunc_mul {g : \u211d \u2192 \u211d\u22650\u221e} {j : Bool} {x : \u03b1} {tc : ToneCouple} {p : \u211d}\n    (hp : p > 0) (hfx : \u2016f x\u2016\u208a > 0) :\n    \u222b\u207b s : \u211d in Ioi 0, (g s) * \u2016trnc j f (tc.ton s) x\u2016\u208a ^ p =\n    (\u222b\u207b s : \u211d in res (xor j tc.mon) (tc.inv \u2016f x\u2016), (g s)) * \u2016f x\u2016\u208a ^ p := by\n  rw [lintegral_trunc_mul\u2080 hp hfx, lintegral_trunc_mul\u2081, lintegral_trunc_mul\u2082 hfx,\n    lintegral_mul_const']\n  exact ((rpow_lt_top_iff_of_pos hp).mpr coe_lt_top).ne\n\n\n/-! Extract expressions for the lower Lebesgue integral of power functions -/\n\nlemma lintegral_rpow_of_gt_abs {\u03b2 \u03b3 : \u211d} (h\u03b2 : \u03b2 > 0) (h\u03b3 : \u03b3 > -1) :\n    \u222b\u207b s : \u211d in Ioo 0 \u03b2, ENNReal.ofReal (s ^ \u03b3) =\n    ENNReal.ofReal (\u03b2 ^ (\u03b3 + 1) / |\u03b3 + 1|) := by\n  have h\u03b32 : \u03b3 + 1 > 0 := by linarith\n  rw [abs_of_nonneg h\u03b32.le]\n  exact lintegral_rpow_of_gt h\u03b2 h\u03b3\n\n-- TODO: treat symmetrically to Ioo case?\nlemma lintegral_Ioi_rpow_of_lt_abs {\u03b2 \u03c3 : \u211d} (h\u03b2 : \u03b2 > 0) (h\u03c3 : \u03c3 < -1):\n    \u222b\u207b s : \u211d in Ioi \u03b2, ENNReal.ofReal (s ^ \u03c3) =\n    ENNReal.ofReal (\u03b2 ^ (\u03c3 + 1) / |\u03c3 + 1|) := by\n  have h\u03c32 : \u03c3 + 1 < 0 := by linarith\n  rw [abs_of_neg h\u03c32, \u2190 ofReal_integral_eq_lintegral_ofReal]\n  \u00b7 rw [integral_Ioi_rpow_of_lt h\u03c3 h\u03b2, div_neg, neg_div]\n  \u00b7 apply integrableOn_Ioi_rpow_of_lt h\u03c3 h\u03b2\n  \u00b7 filter_upwards [self_mem_ae_restrict measurableSet_Ioi]\n    exact fun s hs \u21a6 Real.rpow_nonneg (lt_trans h\u03b2 hs).le \u03c3\n\nlemma lintegral_rpow_abs {j : Bool} {tc : ToneCouple} {\u03b3 : \u211d} {t : \u211d}\n    (h\u03b3 : if xor j tc.mon then \u03b3 > -1 else \u03b3 < -1 ) (ht : t > 0) :\n  \u222b\u207b s : \u211d in res (xor j tc.mon) (tc.inv t), ENNReal.ofReal s ^ \u03b3 =\n    ENNReal.ofReal ((tc.inv t) ^ (\u03b3 + 1) / |\u03b3 + 1|) := by\n  rw [\u2190 lintegral_congr_ae (Filter.mp_mem (self_mem_ae_restrict measurableSet_res)\n      (Filter.univ_mem'\n      (fun s hs \u21a6 (ofReal_rpow_of_pos (res_subset_Ioi (tc.ran_inv t ht) hs)).symm)))]\n  unfold res\n  split at h\u03b3 <;> rename_i xor_split\n  \u00b7 rw [xor_split]\n    simp only [\u2193reduceIte]\n    rw [lintegral_rpow_of_gt_abs (tc.ran_inv t ht) h\u03b3]\n  \u00b7 rw [eq_false_of_ne_true xor_split]\n    simp only [Bool.false_eq_true, \u2193reduceIte]\n    rw [lintegral_Ioi_rpow_of_lt_abs (tc.ran_inv t ht) h\u03b3]\n\nlemma value_lintegral_res\u2080 {j : Bool} {\u03b2 \u03b3 : \u211d} {tc : ToneCouple} (h\u03b2 : \u03b2 > 0)\n    (h\u03b3 : if xor j tc.mon then \u03b3 > -1 else \u03b3 < -1 ) :\n    \u222b\u207b s : \u211d in res (xor j tc.mon) \u03b2, ENNReal.ofReal (s ^ \u03b3) =\n    ENNReal.ofReal (\u03b2 ^ (\u03b3 + 1) / |\u03b3 + 1|) := by\n  unfold res\n  split_ifs at h\u03b3 with h\n  \u00b7 rw [h]\n    simp only [\u2193reduceIte]\n    rw [lintegral_rpow_of_gt_abs h\u03b2 h\u03b3]\n  \u00b7 have : xor j tc.mon = false := by\n      contrapose! h; exact eq_true_of_ne_false h\n    rw [this]\n    simp only [Bool.false_eq_true, \u2193reduceIte]\n    rw [lintegral_Ioi_rpow_of_lt_abs h\u03b2 h\u03b3]\n\nlemma value_lintegral_res\u2081 {t \u03b3 p': \u211d} {spf : ScaledPowerFunction} (ht : t > 0) :\n    ENNReal.ofReal (((spf_to_tc spf).inv t) ^ (\u03b3 + 1) / |\u03b3 + 1| ) * ENNReal.ofReal (t ^ p') =\n    ENNReal.ofReal (spf.d ^ (\u03b3 + 1) * t ^ (spf.\u03c3\u207b\u00b9 * (\u03b3 + 1) + p') / |\u03b3 + 1|) := by\n  have := spf.hd\n  unfold spf_to_tc\n  dsimp only\n  rw [\u2190 ENNReal.ofReal_mul, \u2190 mul_div_right_comm, Real.mul_rpow, mul_assoc, \u2190 Real.rpow_mul,\n      \u2190 Real.rpow_add] <;> positivity\n\nend MeasureTheory\n\nend\n\nnoncomputable section\n\nopen NNReal ENNReal MeasureTheory Set ComputationsInterpolatedExponents\n    ComputationsChoiceExponent\n\nvariable {\u03b1 \u03b1' \u03b5 E E\u2081 E\u2082 E\u2083 : Type*} {m : MeasurableSpace \u03b1} {m' : MeasurableSpace \u03b1'}\n  {p p' q p\u2080 q\u2080 p\u2081 q\u2081: \u211d\u22650\u221e}\n  {C\u2080 C\u2081 : \u211d\u22650} {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b1'}\n  {a : \u211d}\n  {f : \u03b1 \u2192 E\u2081} {t : \u211d}\n\n/-! ## Minkowski's integral inequality -/\nnamespace MeasureTheory\n\nlemma rpow_add_of_pos (a : \u211d\u22650\u221e) (c d : \u211d) (hc : c > 0) (hd : d > 0):\n    a ^ (c + d) = a ^ c * a ^ d := by\n  have hcd : c + d  > 0 := by linarith\n  rcases (eq_or_ne a 0) with a_eq_zero | a_ne_zero\n  \u00b7 rw [a_eq_zero, zero_rpow_of_pos hcd, zero_rpow_of_pos hc, zero_rpow_of_pos hd, mul_zero]\n  \u00b7 rcases (eq_or_ne a \u22a4) with a_eq_top | a_ne_top\n    \u00b7 rw [a_eq_top, top_rpow_of_pos hcd, top_rpow_of_pos hc, top_rpow_of_pos hd, top_mul_top]\n    \u00b7 rw [ENNReal.rpow_add c d a_ne_zero a_ne_top]\n\nlemma eq_of_le_of_le (a b : \u211d\u22650\u221e) (hab : a \u2264 b) (hab': b \u2264 a) : a = b := by\n  rcases (eq_or_ne a b) with a_eq_b | a_ne_b\n  \u00b7 exact a_eq_b\n  \u00b7 rcases lt_or_gt_of_ne a_ne_b with a_lt_b | b_lt_a\n    \u00b7 contrapose! a_lt_b; exact hab'\n    \u00b7 contrapose! b_lt_a; exact hab\n\ndef trunc_cut (f : \u03b1 \u2192 \u211d\u22650\u221e) (\u03bc : Measure \u03b1) [SigmaFinite \u03bc] :=\n  fun n : \u2115 \u21a6 indicator (spanningSets \u03bc n) (fun x \u21a6 min (f x) n)\n\nlemma trunc_cut_mono {\u03bc : Measure \u03b1} [SigmaFinite \u03bc] {f : \u03b1 \u2192 \u211d\u22650\u221e} :\n    \u2200 x : \u03b1, Monotone (fun n \u21a6 trunc_cut f \u03bc n x) := by\n  intro x m n hmn; simp only [trunc_cut, indicator]\n  split_ifs with is_fx_le_m is_fx_le_n\n  \u00b7 refine min_le_min_left (f x) (Nat.cast_le.mpr hmn)\n  \u00b7 contrapose! is_fx_le_n\n    apply monotone_spanningSets _ hmn is_fx_le_m\n  \u00b7 exact zero_le _\n  \u00b7 exact zero_le _\n\nlemma trunc_cut_mono\u2080 {\u03bc : Measure \u03b1} [SigmaFinite \u03bc] {f : \u03b1 \u2192 \u211d\u22650\u221e} :\n    Monotone (trunc_cut f \u03bc) := by\n  intro m n hmn x; apply trunc_cut_mono\n  exact hmn\n\nlemma trunc_cut_sup {\u03bc : Measure \u03b1} [SigmaFinite \u03bc] {f : \u03b1 \u2192 \u211d\u22650\u221e} :\n    \u2200 x : \u03b1, \u2a06 n : \u2115, trunc_cut f \u03bc n x = f x := by\n  intro x; refine iSup_eq_of_forall_le_of_forall_lt_exists_gt ?h\u2081 ?h\u2082\n  \u00b7 intro n; unfold trunc_cut indicator\n    split_ifs\n    \u00b7 exact min_le_left (f x) \u2191n\n    \u00b7 exact zero_le _\n  \u00b7 intro w hw\n    unfold trunc_cut\n    have : \u2203 m : \u2115, x \u2208 spanningSets \u03bc m := by\n      have obs := iUnion_spanningSets \u03bc\n      refine mem_iUnion.mp ?_\n      rw [obs]\n      exact trivial\n    rcases this with \u27e8m, wm\u27e9\n    rcases ENNReal.exists_nat_gt hw.ne_top with \u27e8n, wn\u27e9\n    use (m + n)\n    simp only [indicator]\n    split_ifs with is_x_in_Ampn\n    \u00b7 refine lt_min hw ?_\n      calc\n      w < n := wn\n      _ \u2264 m + n := le_add_self\n      _ = _ := (Nat.cast_add m n).symm\n    \u00b7 contrapose! is_x_in_Ampn\n      exact monotone_spanningSets _ (Nat.le_add_right m n) wm\n\nset_option linter.flexible false in\n/-- Characterization of `\u222b\u207b x : \u03b1, f x ^ p \u2202\u03bc` by a duality argument. -/\nlemma representationLp {\u03bc : Measure \u03b1} [SigmaFinite \u03bc] {f : \u03b1 \u2192 \u211d\u22650\u221e}\n    (hf : AEMeasurable f \u03bc) {p q : \u211d} (hp : p > 1) (hq : q \u2265 1)\n    (hpq : p\u207b\u00b9 + q\u207b\u00b9 = 1) :\n    (\u222b\u207b x : \u03b1, (f x) ^ p \u2202\u03bc) ^ (1 / p) =\n    \u2a06 g \u2208 {g' : \u03b1 \u2192 \u211d\u22650\u221e | AEMeasurable g' \u03bc \u2227 \u222b\u207b x : \u03b1, (g' x) ^ q \u2202\u03bc \u2264 1},\n    \u222b\u207b x : \u03b1, (f x) * g x \u2202\u03bc := by\n  let A := spanningSets \u03bc\n  let g := trunc_cut f \u03bc\n  have hpq' : p.IsConjExponent q := Real.IsConjExponent.mk hp hpq\n  have f_mul : \u2200 n : \u2115, (g n) ^ p \u2264 f * (g n) ^ (p - 1) := by\n    intro n x\n    simp only [g, Pi.pow_apply, Pi.mul_apply, trunc_cut, indicator]\n    split_ifs\n    \u00b7 refine le_trans (b := (min (f x) \u2191n) * min (f x) \u2191n ^ (p - 1)) ?_ ?_\n      \u00b7 nth_rewrite 1 [\u2190 add_sub_cancel 1 p]\n        rw [rpow_add_of_pos, ENNReal.rpow_one] <;> try linarith\n      \u00b7 exact mul_le_mul_right' (min_le_left (f x) \u2191n) (min (f x) \u2191n ^ (p - 1))\n    \u00b7 rw [ENNReal.zero_rpow_of_pos] <;> positivity\n  have g_lim : \u2200 x : \u03b1, Filter.Tendsto (fun n \u21a6 g n x) Filter.atTop (nhds (f x)) := by\n    intro x\n    apply tendsto_atTop_isLUB (trunc_cut_mono _)\n    exact isLUB_iff_sSup_eq.mpr (trunc_cut_sup _)\n  have g_sup' : (fun x \u21a6 \u2a06 n : \u2115, (g n x) ^ p) = fun x \u21a6 (f x) ^ p := by\n    ext x\n    apply iSup_eq_of_tendsto\n    \u00b7 intro m n hmn\n      dsimp only\n      gcongr\n      exact trunc_cut_mono _ hmn\n    \u00b7 exact (g_lim x).ennrpow_const p\n  have g_meas (n : \u2115): AEMeasurable (g n) \u03bc := by\n    exact AEMeasurable.indicator (by fun_prop) (measurableSet_spanningSets \u03bc n)\n  have g_fin (n : \u2115): \u222b\u207b (z : \u03b1), g n z ^ p \u2202\u03bc < \u22a4 := by\n    calc\n    _ = \u222b\u207b (z : \u03b1) in A n, g n z ^ p \u2202\u03bc := by\n      unfold g trunc_cut\n      rw [\u2190 lintegral_indicator]; swap; exact measurableSet_spanningSets \u03bc n\n      congr 1\n      ext x\n      dsimp only [indicator]\n      split_ifs\n      \u00b7 rfl\n      \u00b7 simp only [ENNReal.rpow_eq_zero_iff, true_and, zero_ne_top, false_and, or_false]; positivity\n    _ \u2264 \u222b\u207b (_x : \u03b1) in A n, n ^ p \u2202\u03bc := by\n      apply setLIntegral_mono measurable_const\n      \u00b7 intro x hx\n        gcongr\n        unfold g trunc_cut indicator\n        split_ifs\n        \u00b7 exact min_le_right (f x) \u2191n\n        \u00b7 contradiction\n    _ = n ^ p * \u03bc (A n) := setLIntegral_const (A n) (\u2191n ^ p)\n    _ < \u22a4 := mul_lt_top (rpow_lt_top_of_nonneg (by linarith) coe_ne_top)\n              (measure_spanningSets_lt_top \u03bc n)\n  have obs : \u2200 n : \u2115, \u222b\u207b x : \u03b1, (f x) * ((g n x) ^ (p - 1) /\n      (\u222b\u207b y : \u03b1, ((g n y) ^ (p - 1)) ^ q \u2202\u03bc) ^ q\u207b\u00b9) \u2202\u03bc \u2265\n      (\u222b\u207b x : \u03b1, (g n x) ^ p \u2202\u03bc) ^ p\u207b\u00b9 := by\n    intro n\n    rcases eq_or_ne (\u222b\u207b x : \u03b1, (g n x) ^ p \u2202\u03bc) 0  with int_eq_zero | int_ne_zero\n    \u00b7 rw [int_eq_zero, ENNReal.zero_rpow_of_pos]\n      \u00b7 exact zero_le _\n      \u00b7 refine inv_pos_of_pos (by positivity)\n    \u00b7 calc\n      _ = (\u222b\u207b x : \u03b1, (f x) * (g n x) ^ (p - 1) \u2202\u03bc) * (\n          (\u222b\u207b y : \u03b1, ((g n y) ^ (p - 1)) ^ q \u2202\u03bc) ^ q\u207b\u00b9)\u207b\u00b9 := by\n        simp_rw [div_eq_mul_inv, \u2190 mul_assoc]\n        rw [lintegral_mul_const'' _ (by fun_prop)]\n      _ \u2265 (\u222b\u207b x : \u03b1, (g n x) ^ (p) \u2202\u03bc) * ((\u222b\u207b y : \u03b1, ((g n y) ^ (p - 1)) ^ q \u2202\u03bc) ^ q\u207b\u00b9)\u207b\u00b9 := by\n        gcongr\n        apply f_mul\n      _ = (\u222b\u207b x : \u03b1, (g n x) ^ (p) \u2202\u03bc) * ((\u222b\u207b y : \u03b1, (g n y) ^ p \u2202\u03bc) ^ q\u207b\u00b9)\u207b\u00b9 := by\n        congr\n        ext x\n        rw [\u2190 ENNReal.rpow_mul]\n        congr\n        refine Real.IsConjExponent.sub_one_mul_conj ?_\n        exact Real.IsConjExponent.mk hp hpq\n      _ = (\u222b\u207b x : \u03b1, (g n x) ^ p \u2202\u03bc) ^ p\u207b\u00b9 := by\n        rw [\u2190 ENNReal.rpow_neg]\n        nth_rw 1 [\u2190 ENNReal.rpow_one (x := (\u222b\u207b x : \u03b1, (g n x) ^ (p) \u2202\u03bc))]\n        rw [\u2190 ENNReal.rpow_add _ _ int_ne_zero (g_fin n).ne]\n        congr\n        exact add_neg_eq_of_eq_add hpq.symm\n  have int_fg : \u222b\u207b (x : \u03b1), f x ^ p \u2202\u03bc = \u2a06 n : \u2115, \u222b\u207b x : \u03b1, g n x ^ p \u2202\u03bc := by\n    rw [\u2190 g_sup']\n    apply lintegral_iSup' (fun n \u21a6 by fun_prop) (ae_of_all _ fun x m n hmn \u21a6 ?_)\n    dsimp only\n    gcongr\n    exact trunc_cut_mono _ hmn\n  have sup_rpow : (\u2a06 n : \u2115, \u222b\u207b x : \u03b1, g n x ^ p \u2202\u03bc) ^ (1 / p) =\n      \u2a06 n : \u2115, (\u222b\u207b x : \u03b1, g n x ^ p \u2202\u03bc) ^ (1 / p) := by\n    apply Monotone.map_iSup_of_continuousAt (f := fun (x : \u211d\u22650\u221e) \u21a6 x ^ (1 / p))\n    \u00b7 fun_prop\n    \u00b7 apply ENNReal.monotone_rpow_of_nonneg (by positivity)\n    \u00b7 simp; positivity\n  let h := fun n : \u2115 \u21a6 (fun x \u21a6 g n x ^ (p - 1) / (\u222b\u207b y : \u03b1, ((g n y) ^ (p - 1)) ^ q \u2202\u03bc) ^ q\u207b\u00b9)\n  have comp_sup : (\u2a06 n : \u2115, \u222b\u207b (x : \u03b1), f x * h n x \u2202\u03bc) \u2264\n      \u2a06 g \u2208 {g' : \u03b1 \u2192 \u211d\u22650\u221e | AEMeasurable g' \u03bc \u2227 \u222b\u207b (z : \u03b1), (g' z) ^ q \u2202\u03bc \u2264 1},\n      \u222b\u207b (x : \u03b1), f x * g x \u2202\u03bc := by\n    nth_rw 1 [\u2190 iSup_range (f := fun n : \u2115 \u21a6 h n) (g := fun r \u21a6 \u222b\u207b x : \u03b1, f x * r x \u2202\u03bc)]\n    apply iSup_le_iSup_of_subset fun r exists_n \u21a6 ?_\n    rcases exists_n with \u27e8n, wn\u27e9\n    simp_rw [\u2190 wn]\n    unfold h\n    refine \u27e8by fun_prop, ?_\u27e9\n    simp_rw [div_eq_mul_inv]\n    calc\n    _ = \u222b\u207b (z : \u03b1), ((g n z ^ (p - 1)) ^ q) *\n        ((\u222b\u207b (y : \u03b1), (g n y ^ (p - 1)) ^ q \u2202\u03bc) ^ q\u207b\u00b9)\u207b\u00b9 ^ q \u2202\u03bc := by\n      congr 1\n      ext z\n      rw [ENNReal.mul_rpow_of_nonneg]\n      linarith\n    _ = (\u222b\u207b (z : \u03b1), ((g n z ^ (p - 1)) ^ q) \u2202\u03bc) *\n        ((\u222b\u207b (y : \u03b1), (g n y ^ (p - 1)) ^ q \u2202\u03bc) ^ q\u207b\u00b9)\u207b\u00b9 ^ q := by\n      rw [lintegral_mul_const'' _ (by fun_prop)]\n    _ \u2264 _ := by\n      rcases eq_or_ne (\u222b\u207b x : \u03b1, ((g n x) ^ (p - 1)) ^ q \u2202\u03bc) 0 with int_eq_zero | int_ne_zero\n      \u00b7 rw [int_eq_zero]\n        simp\n      \u00b7 rw [ENNReal.inv_rpow, ENNReal.rpow_inv_rpow]\n        apply le_of_eq\n        refine ENNReal.mul_inv_cancel int_ne_zero ?inr.a.ht\n        \u00b7 apply ne_of_lt\n          calc\n          _ = \u222b\u207b (z : \u03b1), g n z ^ p \u2202\u03bc := by\n            congr 1\n            ext z\n            rw [\u2190 ENNReal.rpow_mul]\n            congr\n            exact Real.IsConjExponent.sub_one_mul_conj hpq'\n          _ < \u22a4 := g_fin n\n        \u00b7 linarith\n  apply eq_of_le_of_le\n  \u00b7 rw [int_fg, sup_rpow]\n    calc\n    _ \u2264 \u2a06 n : \u2115, \u222b\u207b x : \u03b1, (f x) * ((g n x) ^ (p - 1) /\n        (\u222b\u207b y : \u03b1, ((g n y) ^ (p - 1)) ^ q \u2202\u03bc) ^ q\u207b\u00b9) \u2202\u03bc := by\n      gcongr\n      rw [one_div]\n      apply obs\n    _ \u2264 _ := comp_sup\n  \u00b7 refine iSup_le fun r \u21a6 iSup_le fun hr \u21a6 ?_\n    calc\n    _ \u2264 (\u222b\u207b x : \u03b1, f x ^ p \u2202\u03bc) ^ (1 / p) * (\u222b\u207b x : \u03b1, r x ^ q \u2202\u03bc) ^ (1 / q) :=\n      ENNReal.lintegral_mul_le_Lp_mul_Lq _ hpq' hf hr.1\n    _ \u2264 (\u222b\u207b x : \u03b1, f x ^ p \u2202\u03bc) ^ (1 / p) * (1) ^ (1 / q) := by\n      gcongr\n      exact hr.2\n    _ = _ := by simp\n\nlemma aemeasurability_prod\u2081 {\u03b1 : Type u_1} {\u03b2 : Type u_3}\n    [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]\n    {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b2} [SFinite \u03bd]\n    \u2983f : \u03b1 \u00d7 \u03b2 \u2192 ENNReal\u2984\n    (hf : AEMeasurable f (\u03bc.prod \u03bd)) :\n    \u2200\u1d50 x : \u03b1 \u2202\u03bc, AEMeasurable (f \u2218 (Prod.mk x)) \u03bd := by\n  rcases hf with \u27e8g, hg\u27e9\n  filter_upwards [Measure.ae_ae_of_ae_prod hg.2] with x h\n  exact \u27e8g \u2218 Prod.mk x, hg.1.comp (measurable_prod_mk_left), h\u27e9\n\nlemma aemeasurability_prod\u2082 {\u03b1 : Type u_1} {\u03b2 : Type u_3}\n    [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]\n    {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b2} [SFinite \u03bd]\n    [SFinite \u03bc] \u2983f : \u03b1 \u00d7 \u03b2 \u2192 ENNReal\u2984\n    (hf : AEMeasurable f (\u03bc.prod \u03bd)) :\n    \u2200\u1d50 y : \u03b2 \u2202\u03bd, AEMeasurable (f \u2218 (fun x \u21a6 Prod.mk x y)) \u03bc := by\n  have : AEMeasurable (f \u2218 Prod.swap) (\u03bd.prod \u03bc) := by\n    refine AEMeasurable.comp_measurable ?_ measurable_swap\n    rw [Measure.prod_swap]\n    assumption\n  exact aemeasurability_prod\u2081 this\n\nlemma aemeasurability_integral_component {\u03b1 : Type u_1} {\u03b2 : Type u_3}\n    [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]\n    {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b2} [SFinite \u03bd]\n    \u2983f : \u03b1 \u00d7 \u03b2 \u2192 ENNReal\u2984\n    (hf : AEMeasurable f (\u03bc.prod \u03bd)) :\n    AEMeasurable (fun x \u21a6 \u222b\u207b (y : \u03b2), f (x, y) \u2202\u03bd) \u03bc := by\n  rcases hf with \u27e8g, hg\u27e9\n  refine \u27e8fun x \u21a6 \u222b\u207b y : \u03b2, g (x, y) \u2202\u03bd, Measurable.lintegral_prod_right hg.1, ?_\u27e9\n  filter_upwards [Measure.ae_ae_of_ae_prod hg.2] with x h using lintegral_congr_ae h\n\n/-- Minkowsi's integral inequality -/\n-- TODO: the condition on `\u03bc` can probably be weakened to `SFinite \u03bc`, by using a limit\n-- argument\nlemma lintegral_lintegral_pow_swap {\u03b1 : Type u_1} {\u03b2 : Type u_3} {p : \u211d} (hp : 1 \u2264 p)\n    [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]\n    {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b2} [SFinite \u03bd]\n    [SigmaFinite \u03bc] \u2983f : \u03b1 \u2192 \u03b2 \u2192 ENNReal\u2984\n    (hf : AEMeasurable (Function.uncurry f) (\u03bc.prod \u03bd)) :\n    (\u222b\u207b (x : \u03b1), (\u222b\u207b (y : \u03b2), f x y \u2202\u03bd) ^ p \u2202\u03bc) ^ p\u207b\u00b9 \u2264\n    \u222b\u207b (y : \u03b2), (\u222b\u207b (x : \u03b1), (f x y) ^ p \u2202\u03bc) ^ p\u207b\u00b9 \u2202\u03bd := by\n  rcases Decidable.lt_or_eq_of_le hp with one_lt_p | one_eq_p\n  \u00b7 let q := Real.conjExponent p\n    have hpq' : p.IsConjExponent q := Real.IsConjExponent.conjExponent one_lt_p\n    have one_lt_q : 1 < q := (Real.IsConjExponent.symm hpq').one_lt\n    have ineq : \u2200 g \u2208 {g' : \u03b1 \u2192 \u211d\u22650\u221e | AEMeasurable g' \u03bc \u2227 \u222b\u207b (z : \u03b1), (g' z) ^ q \u2202\u03bc \u2264 1},\n        \u222b\u207b x : \u03b1, (\u222b\u207b y : \u03b2, f x y \u2202\u03bd) * g x \u2202\u03bc \u2264\n        \u222b\u207b (y : \u03b2), (\u222b\u207b (x : \u03b1), f x y ^ p \u2202\u03bc) ^ p\u207b\u00b9 \u2202\u03bd := by\n      intro g \u27e8hg1, hg2\u27e9\n      have ae_meas\u2081 : \u2200\u1d50 x : \u03b1 \u2202\u03bc, AEMeasurable (f x) \u03bd :=\n        aemeasurability_prod\u2081 (f := Function.uncurry f) hf\n      calc\n      _ = \u222b\u207b x : \u03b1, (\u222b\u207b y : \u03b2, f x y * g x \u2202\u03bd) \u2202\u03bc := by\n        apply lintegral_congr_ae\n        filter_upwards [ae_meas\u2081] with a ha using (lintegral_mul_const'' _ ha).symm\n      _ = \u222b\u207b y : \u03b2, (\u222b\u207b x : \u03b1, f x y * g x \u2202\u03bc) \u2202\u03bd := lintegral_lintegral_swap (hf.mul hg1.fst)\n      _ \u2264 \u222b\u207b (y : \u03b2), (\u222b\u207b (x : \u03b1), f x y ^ p \u2202\u03bc) ^ p\u207b\u00b9 \u2202\u03bd := by\n        apply lintegral_mono_ae\n        filter_upwards [aemeasurability_prod\u2082 hf] with y hy\n        calc\n        _ \u2264 (\u222b\u207b (x : \u03b1), f x y ^ p \u2202\u03bc) ^ (1 / p) * (\u222b\u207b (x : \u03b1), g x ^ q \u2202\u03bc) ^ (1 / q) :=\n          ENNReal.lintegral_mul_le_Lp_mul_Lq \u03bc hpq' hy hg1\n        _ \u2264 (\u222b\u207b (x : \u03b1), f x y ^ p \u2202\u03bc) ^ (1 / p) * 1 ^ (1 / q) := by\n          gcongr\n        _ = (\u222b\u207b (x : \u03b1), f x y ^ p \u2202\u03bc) ^ p\u207b\u00b9 := by\n          simp [one_div]\n    nth_rw 1 [\u2190 one_div]\n    rw [representationLp (hp := one_lt_p) (hq := one_lt_q.le) (hpq := hpq'.inv_add_inv_conj)]\n    \u00b7 exact (iSup_le fun g \u21a6 iSup_le fun hg \u21a6 ineq g hg)\n    \u00b7 exact (aemeasurability_integral_component hf)\n  \u00b7 rw [\u2190 one_eq_p]\n    simp only [ENNReal.rpow_one, inv_one]\n    exact (lintegral_lintegral_swap hf).le\n\nlemma lintegral_lintegral_pow_swap_rpow {\u03b1 : Type u_1} {\u03b2 : Type u_3} {p : \u211d} (hp : p \u2265 1)\n    [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]\n    {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b2} [SFinite \u03bd]\n    [SigmaFinite \u03bc] \u2983f : \u03b1 \u2192 \u03b2 \u2192 ENNReal\u2984\n    (hf : AEMeasurable (Function.uncurry f) (\u03bc.prod \u03bd)) :\n    (\u222b\u207b (x : \u03b1), (\u222b\u207b (y : \u03b2), f x y \u2202\u03bd) ^ p \u2202\u03bc) \u2264\n    (\u222b\u207b (y : \u03b2), (\u222b\u207b (x : \u03b1), (f x y) ^ p \u2202\u03bc) ^ p\u207b\u00b9 \u2202\u03bd) ^ p := by\n  have p_pos : p > 0 := lt_of_lt_of_le zero_lt_one hp\n  refine le_of_rpow_le (inv_pos_of_pos p_pos) ?_\n  rw [ENNReal.rpow_rpow_inv p_pos.ne']\n  exact lintegral_lintegral_pow_swap hp hf\n\n/-! ## Apply Minkowski's integral inequality to truncations\n-/\n\n@[measurability, fun_prop]\ntheorem ton_aeMeasurable (tc : ToneCouple) : AEMeasurable tc.ton (volume.restrict (Ioi 0)) := by\n  -- ton is either increasing or decreasing\n  have mono_or_anti := tc.ton_is_ton\n  split_ifs at mono_or_anti\n  \u00b7 exact aemeasurable_restrict_of_monotoneOn measurableSet_Ioi mono_or_anti.monotoneOn\n  \u00b7 exact aemeasurable_restrict_of_antitoneOn measurableSet_Ioi mono_or_anti.antitoneOn\n\n@[measurability]\nlemma indicator_ton_measurable {g : \u03b1 \u2192 E\u2081} [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081]\n    [BorelSpace E\u2081] [SigmaFinite \u03bc] (hg : AEMeasurable g \u03bc) (tc : ToneCouple) :\n    NullMeasurableSet {(s, x) : \u211d \u00d7 \u03b1 | \u2016g x\u2016\u208a \u2264 tc.ton s }\n        ((volume.restrict (Ioi 0)).prod \u03bc) :=\n  nullMeasurableSet_le hg.snd.norm (ton_aeMeasurable tc).fst\n\n@[measurability]\nlemma indicator_ton_measurable_lt {g : \u03b1 \u2192 E\u2081} [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081]\n    [BorelSpace E\u2081] [SigmaFinite \u03bc] (hg : AEMeasurable g \u03bc) (tc : ToneCouple) :\n    NullMeasurableSet {(s, x) : \u211d \u00d7 \u03b1 | tc.ton s < \u2016g x\u2016\u208a }\n        ((volume.restrict (Ioi 0)).prod \u03bc) :=\n  nullMeasurableSet_lt (ton_aeMeasurable tc).fst hg.snd.norm\n\n@[measurability]\nlemma truncation_ton_measurable {f : \u03b1 \u2192 E\u2081}\n    [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081]\n    [SigmaFinite (\u03bc.restrict (Function.support f))] -- TODO: TypeClass or implicit variable?\n    (hf : AEMeasurable f \u03bc) (tc : ToneCouple) :\n    AEMeasurable (fun a : \u211d \u00d7 \u03b1 \u21a6 (trunc f (tc.ton a.1)) a.2)\n    ((volume.restrict (Ioi 0)).prod (\u03bc.restrict (Function.support f) )) := by\n  let A := {(s, x) : \u211d \u00d7 \u03b1 | \u2016f x\u2016\u208a \u2264 tc.ton s}\n  have : (fun z : \u211d \u00d7 \u03b1 \u21a6 (trunc f (tc.ton z.1)) z.2) =\n      Set.indicator A (fun z : \u211d \u00d7 \u03b1 \u21a6 f z.2) := by\n    ext z; simp [trunc, indicator, A]\n  rw [this]\n  exact (aemeasurable_indicator_iff\u2080 (indicator_ton_measurable hf.restrict _)).mpr\n    hf.restrict.snd.restrict\n\n@[measurability]\nlemma truncation_compl_ton_measurable {f : \u03b1 \u2192 E\u2081}\n    [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081]\n    [SigmaFinite (\u03bc.restrict (Function.support f))] -- TODO: TypeClass or implicit variable?\n    (hf : AEMeasurable f \u03bc) (tc : ToneCouple) :\n    AEMeasurable (fun a : \u211d \u00d7 \u03b1 \u21a6 ((f - trunc f (tc.ton a.1))) a.2)\n    ((volume.restrict (Ioi 0)).prod (\u03bc.restrict (Function.support f) )) := by\n  let A := {(s, x) : \u211d \u00d7 \u03b1 | tc.ton s < \u2016f x\u2016\u208a}\n  have : (fun z : \u211d \u00d7 \u03b1 \u21a6 (f - trunc f (tc.ton z.1)) z.2) = Set.indicator A (fun z : \u211d \u00d7 \u03b1 \u21a6 f z.2) := by\n    ext z; rw [trunc_compl_eq]; simp [A, indicator]\n  rw [this]\n  refine (aemeasurable_indicator_iff\u2080 (indicator_ton_measurable_lt hf.restrict _)).mpr\n    hf.restrict.snd.restrict\n\nlemma restrict_to_support {a : \u211d} {p : \u211d} (hp : p > 0) [NormedAddCommGroup E\u2081] (f : \u03b1 \u2192 E\u2081) :\n    \u222b\u207b x : \u03b1 in Function.support f, \u2016trunc f a x\u2016\u208a ^ p \u2202 \u03bc = \u222b\u207b x : \u03b1, \u2016trunc f a x\u2016\u208a ^ p \u2202\u03bc := by\n  apply setLIntegral_eq_of_support_subset\n  unfold Function.support trunc\n  rw [setOf_subset_setOf]\n  intro x\n  contrapose!\n  intro f_zero\n  simp_rw [f_zero]; simp [hp]\n\nlemma restrict_to_support_trunc_compl {a : \u211d} {p : \u211d} [NormedAddCommGroup E\u2081] (hp : p > 0)\n    (f : \u03b1 \u2192 E\u2081) :\n    \u222b\u207b x : \u03b1 in Function.support f, \u2016(f - trunc f a) x\u2016\u208a ^ p \u2202\u03bc =\n    \u222b\u207b x : \u03b1, \u2016(f - trunc f a) x\u2016\u208a ^ p \u2202\u03bc := by\n  apply setLIntegral_eq_of_support_subset\n  unfold Function.support trunc\n  rw [setOf_subset_setOf]\n  intro x\n  contrapose!\n  intro f_zero\n  rw [Pi.sub_apply, f_zero]\n  simp [hp]\n\nlemma restrict_to_support_trnc {a : \u211d} {p : \u211d} {j : Bool} [NormedAddCommGroup E\u2081] (hp : p > 0)\n    (f : \u03b1 \u2192 E\u2081) :\n    \u222b\u207b x : \u03b1 in Function.support f, \u2016trnc j f a x\u2016\u208a ^ p \u2202\u03bc =\n    \u222b\u207b x : \u03b1, \u2016trnc j f a x\u2016\u208a ^ p \u2202\u03bc := by\n  apply setLIntegral_eq_of_support_subset\n  unfold Function.support trnc trunc\n  rw [setOf_subset_setOf]\n  intro x\n  contrapose!\n  intro f_zero\n  rcases j\n  \u00b7 dsimp only [Pi.sub_apply]; simp_rw [f_zero]; simp [hp]\n  \u00b7 simp_rw [f_zero]; simp [hp]\n\n@[fun_prop]\ntheorem aeMeasurable_trunc_restrict\n    [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081] {j : Bool}\n    {h\u03bc : SigmaFinite (\u03bc.restrict (Function.support f))} (hf : AEMeasurable f \u03bc) (tc : ToneCouple) :\n    AEMeasurable (fun a \u21a6 trnc j f (tc.ton a.1) a.2)\n      ((volume.restrict (Ioi 0)).prod (\u03bc.restrict (Function.support f))) := by\n  rcases j\n  \u00b7 exact truncation_compl_ton_measurable hf _\n  \u00b7 exact truncation_ton_measurable hf _\n\nlemma lintegral_lintegral_pow_swap_trunc_compl {q q\u2080 p\u2080 : \u211d} [MeasurableSpace E\u2081]\n    [NormedAddCommGroup E\u2081]\n    [BorelSpace E\u2081] {j : Bool} {h\u03bc : SigmaFinite (\u03bc.restrict (Function.support f))}\n    (hp\u2080 : p\u2080 > 0) (hp\u2080q\u2080 : p\u2080 \u2264 q\u2080)\n    (hf : AEMeasurable f \u03bc) (tc : ToneCouple) :\n    \u222b\u207b (s : \u211d) in Ioi 0,\n        (\u222b\u207b (a : \u03b1) in Function.support f, ENNReal.ofReal (s ^ (q - q\u2080 - 1)) ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9 *\n        \u2191\u2016trnc j f (tc.ton s) a\u2016\u208a ^ p\u2080 \u2202\u03bc) ^ (p\u2080\u207b\u00b9 * q\u2080) \u2264\n    (\u222b\u207b a : \u03b1 in Function.support f,\n      (\u222b\u207b (s : \u211d) in Ioi 0,\n        (ENNReal.ofReal (s ^ (q - q\u2080 - 1)) ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9 *\n        \u2191\u2016trnc j f (tc.ton s) a\u2016\u208a  ^ p\u2080) ^ (p\u2080\u207b\u00b9 * q\u2080)) ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9 \u2202\u03bc) ^ (p\u2080\u207b\u00b9 * q\u2080) := by\n  apply lintegral_lintegral_pow_swap_rpow\n  \u00b7 apply le_of_mul_le_mul_left _ hp\u2080\n    field_simp [hp\u2080q\u2080]\n  \u00b7 unfold Function.uncurry\n    simp only [Pi.sub_apply]\n    fun_prop\n\nlemma lintegral_congr_support {f : \u03b1 \u2192 E\u2081} {g h: \u03b1 \u2192 ENNReal}\n    [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081]\n    (hf : AEMeasurable f \u03bc) (hgh : \u2200 x \u2208 Function.support f, g x = h x) :\n    \u222b\u207b x : \u03b1 in Function.support f, g x \u2202\u03bc = \u222b\u207b x : \u03b1 in Function.support f, h x \u2202\u03bc := by\n  refine lintegral_congr_ae (ae_iff.mpr ?_)\n  rw [Measure.restrict_apply\u2080']\n  \u00b7 refine measure_mono_null (fun x h\u2080 \u21a6 ?_) measure_empty\n    have : g x = h x := hgh _ (mem_of_mem_inter_right h\u2080)\n    have : x \u2208 {a | \u00acg a = h a} := mem_of_mem_diff h\u2080\n    change \u00ac (g x = h x) at this\n    contradiction\n  \u00b7 have : (Function.support f) = (Function.support (fun x \u21a6 \u2016f x\u2016)) := by\n      unfold Function.support\n      ext x\n      simp only [ne_eq, mem_setOf_eq, norm_eq_zero]\n    rw [this]\n    exact (aestronglyMeasurable_iff_aemeasurable.mpr hf.norm).nullMeasurableSet_support\n\n/-- One of the key estimates for the real interpolation theorem, not yet using\n    the particular choice of exponent and scale in the `ScaledPowerFunction`. -/\nlemma estimate_trnc {p\u2080 q\u2080 q : \u211d} {spf : ScaledPowerFunction} {j : Bool}\n    [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081]\n    (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2080q\u2080 : p\u2080 \u2264 q\u2080)\n    (hf : AEMeasurable f \u03bc) (hf\u2082 : SigmaFinite (\u03bc.restrict (Function.support f)))\n    (hpowers : if xor j (spf_to_tc spf).mon = true then q\u2080 < q else q < q\u2080) :\n    \u222b\u207b s : \u211d in Ioi 0,\n    eLpNorm (trnc j f ((spf_to_tc spf).ton s)) (ENNReal.ofReal p\u2080) \u03bc ^ q\u2080 *\n    ENNReal.ofReal (s ^ (q - q\u2080 - 1)) \u2264\n    ENNReal.ofReal (spf.d ^ (q - q\u2080)) * ENNReal.ofReal |q - q\u2080|\u207b\u00b9 *\n    (\u222b\u207b (a : \u03b1) in Function.support f,\n    ENNReal.ofReal (\u2016f a\u2016 ^ (p\u2080 + spf.\u03c3\u207b\u00b9 * (q - q\u2080) * (p\u2080 / q\u2080))) \u2202\u03bc) ^\n    (p\u2080\u207b\u00b9 * q\u2080) := by\n  have := spf.hd\n  unfold eLpNorm eLpNorm'\n  set tc := spf_to_tc spf\n  split_ifs with is_p\u2080pos is_p\u2080top\n  \u00b7 have : p\u2080 \u2264 0 := ofReal_eq_zero.mp is_p\u2080pos\n    contrapose! this; exact hp\u2080\n  \u00b7 contrapose! is_p\u2080top; exact coe_ne_top\n  \u00b7 rw [toReal_ofReal hp\u2080.le]\n    calc\n    _ = \u222b\u207b s : \u211d in Ioi 0, ENNReal.ofReal (s ^ (q - q\u2080 - 1)) *\n    ((\u222b\u207b (a : \u03b1), \u2191\u2016trnc j f ((spf_to_tc spf).ton s) a\u2016\u208a ^ p\u2080 \u2202\u03bc) ^ (1 / p\u2080)) ^ q\u2080  := by\n      simp only [enorm_eq_nnnorm]\n      congr 1\n      ext x\n      rw [mul_comm]\n    _ = \u222b\u207b (s : \u211d) in Ioi 0,\n        (ENNReal.ofReal (s ^ (q - q\u2080 - 1)) ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9) ^ (p\u2080\u207b\u00b9 * q\u2080) *\n        (\u222b\u207b (a : \u03b1) in Function.support f, \u2191\u2016trnc j f (tc.ton s) a\u2016\u208a ^ p\u2080 \u2202\u03bc) ^ (p\u2080\u207b\u00b9 * q\u2080)\n        := by\n      apply setLIntegral_congr_fun measurableSet_Ioi\n      filter_upwards with s _\n      rw [ENNReal.rpow_inv_rpow]\n      \u00b7 rw [one_div, \u2190 ENNReal.rpow_mul, restrict_to_support_trnc hp\u2080]\n      \u00b7 positivity\n    _ = \u222b\u207b (s : \u211d) in Ioi 0,\n        (\u222b\u207b (a : \u03b1) in Function.support f,\n        ENNReal.ofReal (s ^ (q - q\u2080 - 1)) ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9 *\n        \u2191\u2016trnc j f (tc.ton s) a\u2016\u208a ^ p\u2080 \u2202\u03bc) ^ (p\u2080\u207b\u00b9 * q\u2080)\n        := by\n      apply setLIntegral_congr_fun measurableSet_Ioi\n      filter_upwards with s _\n      rw [lintegral_const_mul', ENNReal.mul_rpow_of_nonneg]\n      \u00b7 positivity\n      \u00b7 exact (ENNReal.rpow_lt_top_of_nonneg (by positivity) coe_ne_top).ne\n    _ \u2264 (\u222b\u207b a : \u03b1 in Function.support f,\n        (\u222b\u207b (s : \u211d) in Ioi 0,\n        (ENNReal.ofReal (s ^ (q - q\u2080 - 1)) ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9 *\n        \u2191\u2016trnc j f (tc.ton s) a\u2016\u208a  ^ p\u2080) ^ (p\u2080\u207b\u00b9 * q\u2080)) ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9 \u2202\u03bc) ^ (p\u2080\u207b\u00b9 * q\u2080) := by\n      -- This is a consequence of Minkowski's integral inequality\n      apply lintegral_lintegral_pow_swap_trunc_compl hp\u2080 hp\u2080q\u2080 hf tc; assumption\n    _ = (\u222b\u207b a : \u03b1 in Function.support f,\n        (\u222b\u207b (s : \u211d) in Ioi 0,\n        (ENNReal.ofReal (s ^ (q - q\u2080 - 1)) *\n        \u2191\u2016trnc j f (tc.ton s) a\u2016\u208a ^ q\u2080)) ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9 \u2202\u03bc) ^ (p\u2080\u207b\u00b9 * q\u2080) := by\n      congr 1\n      apply lintegral_congr_support hf\n      intro x _\n      congr 1\n      apply setLIntegral_congr_fun measurableSet_Ioi\n      filter_upwards with s _\n      rw [ENNReal.mul_rpow_of_nonneg, ENNReal.rpow_inv_rpow, \u2190 ENNReal.rpow_mul] <;> try positivity\n      congr\n      field_simp\n    _ = (\u222b\u207b a : \u03b1 in Function.support f,\n        ((\u222b\u207b (s : \u211d) in res (xor j tc.mon) (tc.inv \u2016f a\u2016),\n        (ENNReal.ofReal (s ^ (q - q\u2080 - 1))))*\n        \u2191\u2016f a\u2016\u208a ^ q\u2080) ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9 \u2202\u03bc) ^ (p\u2080\u207b\u00b9 * q\u2080) := by\n      congr 1\n      apply lintegral_congr_support hf\n      intro x hfx\n      congr 1\n      apply lintegral_trunc_mul hq\u2080 (nnnorm_pos.mpr hfx)\n    _ = (\u222b\u207b a : \u03b1 in Function.support f,\n        ((ENNReal.ofReal (tc.inv \u2016f a\u2016 ^ (q - q\u2080 - 1 + 1) / |q - q\u2080 - 1 + 1|)) *\n        ENNReal.ofReal (\u2016f a\u2016 ^ q\u2080)) ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9 \u2202\u03bc) ^ (p\u2080\u207b\u00b9 * q\u2080) := by\n      congr 1\n      apply lintegral_congr_support hf\n      intro x hfx\n      congr 2\n      \u00b7 apply value_lintegral_res\u2080\n        \u00b7 apply tc.ran_inv\n          exact norm_pos_iff.mpr hfx\n        \u00b7 split_ifs with h\n          \u00b7 simp only [h, \u2193reduceIte] at hpowers; linarith\n          \u00b7 simp only [h, Bool.false_eq_true, \u2193reduceIte] at hpowers; linarith\n      \u00b7 rw [\u2190 ofReal_rpow_of_nonneg] <;> try positivity\n        congr\n        exact norm_toNNReal.symm\n    _ = (\u222b\u207b a : \u03b1 in Function.support f,\n        ((ENNReal.ofReal\n        (spf.d ^ (q - q\u2080 - 1 + 1) * \u2016f a\u2016 ^ (spf.\u03c3\u207b\u00b9 * (q - q\u2080 - 1 + 1) + q\u2080) /\n      |q - q\u2080 - 1 + 1|))) ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9 \u2202\u03bc) ^ (p\u2080\u207b\u00b9 * q\u2080) := by\n      congr 1\n      apply lintegral_congr_support hf\n      intro x hfx\n      congr 1\n      apply value_lintegral_res\u2081\n      exact norm_pos_iff.mpr hfx\n    _ = (\u222b\u207b a : \u03b1 in Function.support f,\n        ((ENNReal.ofReal (spf.d ^ (q - q\u2080)) ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9 *\n        ENNReal.ofReal (\u2016f a\u2016 ^ ((spf.\u03c3\u207b\u00b9 * (q - q\u2080) + q\u2080) * (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9)) *\n    ENNReal.ofReal |q - q\u2080|\u207b\u00b9 ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9))  \u2202\u03bc) ^ (p\u2080\u207b\u00b9 * q\u2080) := by\n      congr 1\n      apply lintegral_congr_support hf\n      intro x _\n      rw [div_eq_mul_inv, ENNReal.ofReal_mul, sub_add_cancel, ENNReal.ofReal_mul,\n          ENNReal.mul_rpow_of_nonneg, ENNReal.mul_rpow_of_nonneg] <;> try positivity\n      nth_rw 2 [ENNReal.ofReal_rpow_of_nonneg] <;> try positivity\n      rw [\u2190 Real.rpow_mul] ; try positivity\n    _ = ENNReal.ofReal (spf.d ^ (q - q\u2080)) *\n        (\u222b\u207b (a : \u03b1) in Function.support f,\n        ENNReal.ofReal (\u2016f a\u2016 ^ ((spf.\u03c3\u207b\u00b9 * (q - q\u2080) + q\u2080) * (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9)) \u2202\u03bc) ^\n        (p\u2080\u207b\u00b9 * q\u2080) *\n        ENNReal.ofReal |q - q\u2080|\u207b\u00b9 := by\n      rw [lintegral_mul_const', lintegral_const_mul', ENNReal.mul_rpow_of_nonneg,\n          ENNReal.mul_rpow_of_nonneg, ENNReal.rpow_inv_rpow, ENNReal.rpow_inv_rpow] <;>\n          try positivity\n      \u00b7 exact rpow_ne_top_of_nonneg (by positivity) coe_ne_top\n      \u00b7 exact rpow_ne_top_of_nonneg (by positivity) coe_ne_top\n    _ = ENNReal.ofReal (spf.d ^ (q - q\u2080)) *\n        (\u222b\u207b (a : \u03b1) in Function.support f,\n        ENNReal.ofReal (\u2016f a\u2016 ^ (p\u2080 + spf.\u03c3\u207b\u00b9 * (q - q\u2080) * (p\u2080 / q\u2080))) \u2202\u03bc) ^\n        (p\u2080\u207b\u00b9 * q\u2080) *\n        ENNReal.ofReal |q - q\u2080|\u207b\u00b9 := by\n      congr\n      ext x\n      congr\n      ring_nf\n      rw [inv_inv]\n      field_simp\n    _ = _ := by ring\n\ndef sel (j : Bool) (p\u2080 p\u2081 : \u211d\u22650\u221e) := match j with | true => p\u2081 | false => p\u2080\n\n/-- One of the key estimates for the real interpolation theorem, now using\n    the particular choice of exponent, but not yet using the\n    particular choice of scale in the `ScaledPowerFunction`. -/\nlemma estimate_trnc\u2081 {spf : ScaledPowerFunction} {j : Bool}\n    [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081] (ht : t \u2208 Ioo 0 1)\n    (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0) (hpq : sel j p\u2080 p\u2081 \u2264 sel j q\u2080 q\u2081)\n    (hp' : sel j p\u2080 p\u2081 \u2260 \u22a4) (hq' : sel j q\u2080 q\u2081 \u2260 \u22a4)  (hp\u2080p\u2081 : p\u2080 < p\u2081)\n    (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081) (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9)\n    (hf : AEMeasurable f \u03bc) (hf\u2082 : SigmaFinite (\u03bc.restrict (Function.support f)))\n    (hspf : spf.\u03c3 = @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) :\n    \u222b\u207b s : \u211d in Ioi 0,\n    eLpNorm (trnc j f ((spf_to_tc spf).ton s)) (sel j p\u2080 p\u2081) \u03bc ^ (sel j q\u2080 q\u2081).toReal *\n    ENNReal.ofReal (s ^ (q.toReal - (sel j q\u2080 q\u2081).toReal - 1)) \u2264\n    ENNReal.ofReal (spf.d ^ (q.toReal - (sel j q\u2080 q\u2081).toReal)) *\n    ENNReal.ofReal |q.toReal - (sel j q\u2080 q\u2081).toReal|\u207b\u00b9 *\n    ((eLpNorm f p \u03bc) ^ p.toReal) ^ ((sel j p\u2080 p\u2081).toReal \u207b\u00b9 * (sel j q\u2080 q\u2081).toReal) := by\n  have p_toReal_pos : p.toReal > 0 :=\n    interp_exp_toReal_pos' ht hp\u2080 hp\u2081 hp (Or.inl hp\u2080p\u2081.ne_top)\n  calc\n  _ \u2264 ENNReal.ofReal (spf.d ^ (q.toReal - (sel j q\u2080 q\u2081).toReal)) *\n      ENNReal.ofReal |q.toReal - (sel j q\u2080 q\u2081).toReal|\u207b\u00b9 *\n      (\u222b\u207b (a : \u03b1) in Function.support f,\n      ENNReal.ofReal (\u2016f a\u2016 ^ ((sel j p\u2080 p\u2081).toReal + spf.\u03c3\u207b\u00b9 * (q.toReal - (sel j q\u2080 q\u2081).toReal) *\n      ((sel j p\u2080 p\u2081).toReal / (sel j q\u2080 q\u2081).toReal))) \u2202\u03bc) ^\n      ((sel j p\u2080 p\u2081).toReal \u207b\u00b9 * (sel j q\u2080 q\u2081).toReal) := by\n    have coe_p' : ENNReal.ofReal (sel j p\u2080 p\u2081).toReal = (sel j p\u2080 p\u2081) := ofReal_toReal_eq_iff.mpr hp'\n    nth_rw 1 [\u2190 coe_p']\n    apply estimate_trnc\n    \u00b7 apply toReal_pos\n      \u00b7 cases j\n        \u00b7 exact hp\u2080.ne'\n        \u00b7 exact hp\u2081.ne'\n      \u00b7 exact hp'\n    \u00b7 apply toReal_pos\n      \u00b7 cases j\n        \u00b7 exact hq\u2080.ne'\n        \u00b7 exact hq\u2081.ne'\n      \u00b7 exact hq'\n    \u00b7 exact toReal_mono hq' hpq\n    \u00b7 exact hf\n    \u00b7 exact hf\u2082\n    \u00b7 unfold spf_to_tc\n      cases j\n      \u00b7 unfold sel\n        dsimp only\n        rw [hspf]\n        simp only [Bool.if_false_right, Bool.and_true, Bool.false_bne, decide_eq_true_eq]\n        split_ifs with is_\u03b6_pos\n        \u00b7 apply toReal_strict_mono\n          \u00b7 exact interp_exp_ne_top hq\u2080q\u2081 ht hq\n          \u00b7 exact (\u03b6_pos_iff_of_lt\u2080 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hq\u2080q\u2081 hp hq hp\u2080p\u2081).mp is_\u03b6_pos\n        \u00b7 apply toReal_strict_mono hq'\n          exact (\u03b6_le_zero_iff_of_lt\u2080 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hq\u2080q\u2081 hp hq hp\u2080p\u2081).mp\n            (le_of_not_lt is_\u03b6_pos)\n      \u00b7 unfold sel\n        dsimp only\n        rw [hspf]\n        simp only [Bool.if_false_right, Bool.and_true, Bool.true_bne, Bool.not_eq_true',\n            decide_eq_false_iff_not]\n        split_ifs with is_\u03b6_pos\n        \u00b7 apply toReal_strict_mono hq'\n          exact (\u03b6_pos_iff_of_lt\u2081 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hq\u2080q\u2081 hp hq hp\u2080p\u2081).mp is_\u03b6_pos\n        \u00b7 apply toReal_strict_mono\n          \u00b7 exact interp_exp_ne_top hq\u2080q\u2081 ht hq\n          \u00b7 exact (\u03b6_le_zero_iff_of_lt\u2081 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hq\u2080q\u2081 hp hq hp\u2080p\u2081).mp\n                (le_of_not_lt is_\u03b6_pos)\n  _ = ENNReal.ofReal (spf.d ^ (q.toReal - (sel j q\u2080 q\u2081).toReal)) *\n        ENNReal.ofReal |q.toReal - (sel j q\u2080 q\u2081).toReal|\u207b\u00b9 *\n        (\u222b\u207b (a : \u03b1) in Function.support f,\n        ENNReal.ofReal (\u2016f a\u2016 ^ p.toReal) \u2202\u03bc) ^\n        ((sel j p\u2080 p\u2081).toReal \u207b\u00b9 * (sel j q\u2080 q\u2081).toReal) := by\n    congr\n    ext x\n    congr\n    rcases j\n    \u00b7 dsimp only [sel]\n      rw [hspf]\n      apply \u03b6_equality\u2085 (hp\u2080p\u2081 := hp\u2080p\u2081.ne) <;> assumption\n    \u00b7 dsimp only [sel]\n      rw [hspf]\n      apply \u03b6_equality\u2086 (hp\u2080p\u2081 := hp\u2080p\u2081.ne) <;> assumption\n  _ \u2264 ENNReal.ofReal (spf.d ^ (q.toReal - (sel j q\u2080 q\u2081).toReal)) *\n      ENNReal.ofReal |q.toReal - (sel j q\u2080 q\u2081).toReal|\u207b\u00b9 *\n      (\u222b\u207b (a : \u03b1),\n      ENNReal.ofReal (\u2016f a\u2016 ^ p.toReal) \u2202\u03bc) ^\n      ((sel j p\u2080 p\u2081).toReal \u207b\u00b9 * (sel j q\u2080 q\u2081).toReal) := by\n    gcongr\n    exact setLIntegral_le_lintegral _ _\n  _ = ENNReal.ofReal (spf.d ^ (q.toReal - (sel j q\u2080 q\u2081).toReal)) *\n      ENNReal.ofReal |q.toReal - (sel j q\u2080 q\u2081).toReal|\u207b\u00b9 *\n      (((\u222b\u207b (a : \u03b1), \u2016f a\u2016\u208a ^ p.toReal \u2202\u03bc) ^ p.toReal\u207b\u00b9 ) ^ p.toReal) ^\n      ((sel j p\u2080 p\u2081).toReal \u207b\u00b9 * (sel j q\u2080 q\u2081).toReal) := by\n    congr\n    rw [ENNReal.rpow_inv_rpow] <;> try positivity\n    congr\n    ext x\n    rw [\u2190 ofReal_rpow_of_nonneg] <;> try positivity\n    congr\n    exact ofReal_norm_eq_enorm (f x)\n  _ = ENNReal.ofReal (spf.d ^ (q.toReal - (sel j q\u2080 q\u2081).toReal)) *\n      ENNReal.ofReal |q.toReal - (sel j q\u2080 q\u2081).toReal|\u207b\u00b9 *\n      ((eLpNorm f p \u03bc) ^ p.toReal) ^\n      ((sel j p\u2080 p\u2081).toReal \u207b\u00b9 * (sel j q\u2080 q\u2081).toReal) := by\n    congr\n    rw [\u2190 one_div]\n    refine (eLpNorm_eq_lintegral_rpow_enorm ?_ ?_).symm\n    \u00b7 exact (interpolated_pos' hp\u2080 hp\u2081 hp).ne'\n    \u00b7 exact interp_exp_ne_top hp\u2080p\u2081.ne ht hp\n\n-- TODO: move this to Weaktype.lean?\nlemma wnorm_eq_zero_iff {f : \u03b1 \u2192 E\u2081} {p : \u211d\u22650\u221e} [NormedAddCommGroup E\u2081] (hp : p \u2260 0) :\n    wnorm f p \u03bc = 0 \u2194 f =\u1d50[\u03bc] 0 := by\n  unfold wnorm\n  split_ifs with h\u2080\n  \u00b7 exact eLpNormEssSup_eq_zero_iff\n  \u00b7 refine Iff.trans \u27e8?_, ?_\u27e9 eLpNormEssSup_eq_zero_iff <;> intro h\n    \u00b7 have iSup_wnorm := iSup_eq_zero.mp h\n      by_contra h\u2081\n      have : eLpNormEssSup f \u03bc > 0 := pos_iff_ne_zero.mpr h\u2081\n      unfold eLpNormEssSup at this\n      rw [essSup_eq_sInf] at this\n      let b := (min (sInf {a : \u211d\u22650\u221e | \u03bc {x | a < \u2191\u2016f x\u2016\u208a} = 0}) 1) / 2\n      have b_lt_inf : b < min (sInf {a : \u211d\u22650\u221e | \u03bc {x | a < \u2191\u2016f x\u2016\u208a} = 0}) 1 :=\n        ENNReal.half_lt_self (lt_min this zero_lt_one).ne'\n          (lt_of_le_of_lt (min_le_right _ 1) one_lt_top).ne\n      have meas_ne_zero : \u03bc {x | b < \u2191\u2016f x\u2016\u208a} \u2260 0 := by\n        intro h\n        have obs : sInf {a | \u03bc {x | a < \u2191\u2016f x\u2016\u208a} = 0} \u2264 b := csInf_le' h\n        contrapose! obs\n        calc\n        _ < _ := b_lt_inf\n        _ \u2264 _ := min_le_left ..\n      have b_ne_0 : b \u2260 0 := (ENNReal.half_pos (lt_min this zero_lt_one).ne').ne'\n      have p_toReal_inv_pos : p.toReal\u207b\u00b9 > 0 := inv_pos_of_pos (toReal_pos hp h\u2080)\n      have coe_b : ENNReal.ofNNReal b.toNNReal = b := coe_toNNReal b_lt_inf.ne_top\n      have : distribution f b \u03bc = 0 := by\n        refine (rpow_eq_zero_iff_of_pos p_toReal_inv_pos).mp ?_\n        refine eq_zero_of_ne_zero_of_mul_left_eq_zero b_ne_0 ?_\n        rw [\u2190 coe_b]\n        exact iSup_wnorm b.toNNReal\n      exact meas_ne_zero this\n    \u00b7 refine iSup_eq_zero.mpr fun t \u21a6 mul_eq_zero.mpr\n        (Or.inr ((rpow_eq_zero_iff_of_pos (inv_pos_of_pos (toReal_pos hp h\u2080))).mpr (nonpos_iff_eq_zero.mp ?_)))\n      calc\n        _ \u2264 distribution f 0 \u03bc := by gcongr; exact zero_le _\n        _ = distribution f (eLpNormEssSup f \u03bc) \u03bc := by congr; exact h.symm\n        _ = 0 := distribution_snormEssSup\n\n\n/-! ## Weaktype estimates applied to truncations -/\n\nvariable [NormedAddCommGroup E\u2081] [NormedAddCommGroup E\u2082]\n\nlemma eLpNorm_trnc_est {f : \u03b1 \u2192 E\u2081} {j : Bool} {a : \u211d} :\n    eLpNorm (trnc j f a) p \u03bc \u2264 eLpNorm f p \u03bc := eLpNorm_mono fun _x \u21a6 trnc_le_func\n\nvariable [ContinuousENorm \u03b5] {T : (\u03b1 \u2192 E\u2081) \u2192 (\u03b1' \u2192 \u03b5)} in\n-- TODO: remove the subindex 0 here\nlemma weaktype_estimate {C\u2080 : \u211d\u22650} {p : \u211d\u22650\u221e} {q : \u211d\u22650\u221e} {f : \u03b1 \u2192 E\u2081}\n      (hq : 0 < q) (hq' : q < \u22a4) (hf : Mem\u2112p f p \u03bc)\n    (h\u2080T : HasWeakType T p q \u03bc \u03bd C\u2080) {t : \u211d} (ht : t > 0) :\n    distribution (T f) (ENNReal.ofReal t) \u03bd \u2264 C\u2080 ^ q.toReal *\n        eLpNorm f p \u03bc ^ q.toReal * ENNReal.ofReal (t ^ (-q.toReal)) := by\n  have wt_est := (h\u2080T f hf).2 -- the weaktype estimate\n  have q_pos : q.toReal > 0 := toReal_pos hq.ne' hq'.ne_top\n  have tq_pos : ENNReal.ofReal t ^ q.toReal > 0 := coe_pow_pos ht\n  have tq_ne_top : (ENNReal.ofReal t) ^ q.toReal \u2260 \u22a4 := coe_rpow_ne_top' q_pos\n  -- have hq\u2081 : q.toReal = q := by exact toReal_ofReal q_nonneg\n  simp only [wnorm, wnorm', hq'.ne_top, \u2193reduceIte, iSup_le_iff] at wt_est\n  have wt_est_t := wt_est t.toNNReal -- this is the weaktype estimate applied to t\n  rw [\u2190 ENNReal.mul_le_mul_right (c := (ENNReal.ofReal t) ^ q.toReal) _ tq_ne_top,\n      ofReal_rpow_of_pos, mul_assoc _ _ (ENNReal.ofReal (t ^ q.toReal)), \u2190 ofReal_mul',\n      \u2190 Real.rpow_add, neg_add_cancel, Real.rpow_zero, ofReal_one, mul_one, mul_comm,\n      \u2190 ENNReal.mul_rpow_of_nonneg] <;> try positivity\n  refine (ENNReal.rpow_inv_le_iff q_pos).mp ?_\n  rw [ENNReal.mul_rpow_of_nonneg, ENNReal.ofReal_rpow_of_pos,\n      Real.rpow_rpow_inv] <;> try positivity\n  rwa [\u2190 coe_coe_eq_ofReal]\n\nvariable [ContinuousENorm \u03b5] {T : (\u03b1 \u2192 E\u2081) \u2192 (\u03b1' \u2192 \u03b5)} in\nlemma weaktype_estimate_top {C : \u211d\u22650} {p : \u211d\u22650\u221e} {q : \u211d\u22650\u221e}\n    (hq' : q = \u22a4) {f : \u03b1 \u2192 E\u2081} (hf : Mem\u2112p f p \u03bc)\n    (hT : HasWeakType T p q \u03bc \u03bd C) {t : \u211d} (ht : C * eLpNorm f p \u03bc \u2264 ENNReal.ofReal t) :\n    distribution (T f) (ENNReal.ofReal t) \u03bd = 0 := by\n  have wt_est := (hT f hf).2\n  unfold wnorm at wt_est\n  split_ifs at wt_est\n  apply nonpos_iff_eq_zero.mp\n  calc\n  _ \u2264 distribution (T f) (eLpNormEssSup (T f) \u03bd) \u03bd := distribution_mono_right (le_trans wt_est ht)\n  _ = _ := meas_essSup_lt -- meas_eLpNormEssSup_lt\n\n-- for the remaining lemmas we use too much measure theory that is just for normed spaces\n-- try to generalize to ENorm-classes after Mathlib refactor\nvariable {T : (\u03b1 \u2192 E\u2081) \u2192 (\u03b1' \u2192 E\u2082)}\n\n/-- If `T` has weaktype `p\u2080`-`p\u2081`, `f` is `AEStronglyMeasurable` and the `p`-norm of `f`\n    vanishes, then the `q`-norm of `T f` vanishes.\n    -/\nlemma weaktype_aux\u2080 {p\u2080 q\u2080 p q : \u211d\u22650\u221e}\n    (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp : p > 0) (hq : q > 0)\n    {C\u2080 : \u211d\u22650}\n    (h\u2080T : HasWeakType T p\u2080 q\u2080 \u03bc \u03bd C\u2080) (hf : AEStronglyMeasurable f \u03bc)\n    (hF : eLpNorm f p \u03bc = 0) :\n    eLpNorm (T f) q \u03bd = 0 := by\n  have f_ae_0 : f =\u1d50[\u03bc] 0 := (eLpNorm_eq_zero_iff hf hp.ne').mp hF\n  have hf\u2082 : eLpNorm f p\u2080 \u03bc = 0 := (eLpNorm_eq_zero_iff hf hp\u2080.ne').mpr f_ae_0\n  have hf\u2081 : Mem\u2112p f p\u2080 \u03bc := \u27e8hf, by rw [hf\u2082]; exact zero_lt_top\u27e9\n  have := (h\u2080T f hf\u2081).2\n  rw [hf\u2082, mul_zero] at this\n  have wnorm_0 : wnorm (T f) q\u2080 \u03bd = 0 := nonpos_iff_eq_zero.mp this\n  have : (T f) =\u1d50[\u03bd] 0 := (wnorm_eq_zero_iff hq\u2080.ne').mp wnorm_0\n  exact (eLpNorm_eq_zero_iff (h\u2080T _ hf\u2081).1 hq.ne').mpr this\n\nvariable [MeasurableSpace E\u2081] [BorelSpace E\u2081]\n\nlemma weaktype_estimate_trunc_compl {C\u2080 : \u211d\u22650} {p p\u2080: \u211d\u22650\u221e} {f : \u03b1 \u2192 E\u2081}\n    (hp\u2080 : 0 < p\u2080) {q\u2080 : \u211d\u22650\u221e} (hp : p \u2260 \u22a4) (hq\u2080 : 0 < q\u2080) (hq\u2080' : q\u2080 < \u22a4)\n    (hp\u2080p : p\u2080 < p) (hf : Mem\u2112p f p \u03bc)\n    (h\u2080T : HasWeakType T p\u2080 q\u2080 \u03bc \u03bd C\u2080) {t : \u211d} (ht : t > 0) {a : \u211d} (ha : a > 0) :\n    distribution (T (f - trunc f a)) (ENNReal.ofReal t) \u03bd \u2264 C\u2080 ^ q\u2080.toReal *\n        eLpNorm (f - trunc f a) p\u2080 \u03bc ^ q\u2080.toReal * (ENNReal.ofReal (t ^ (-q\u2080.toReal))) := by\n  apply weaktype_estimate hq\u2080 hq\u2080' ?_ h\u2080T ht\n  exact trunc_compl_Lp_Lq_lower hp \u27e8hp\u2080, hp\u2080p\u27e9 ha hf\n\nlemma weaktype_estimate_trunc {C\u2081 : \u211d\u22650} {p p\u2081 q\u2081: \u211d\u22650\u221e} {f : \u03b1 \u2192 E\u2081}\n    (hp : 0 < p)\n    (hq\u2081 : 0 < q\u2081) (hq\u2081' : q\u2081 < \u22a4) (hp\u2081p : p < p\u2081)\n    (hf : Mem\u2112p f p \u03bc)\n    (h\u2081T : HasWeakType T p\u2081 q\u2081 \u03bc \u03bd C\u2081) {t : \u211d} (ht : t > 0) {a : \u211d} :\n    distribution (T (trunc f a)) (ENNReal.ofReal t) \u03bd \u2264 C\u2081 ^ q\u2081.toReal *\n      eLpNorm (trunc f a) p\u2081 \u03bc ^ q\u2081.toReal * ENNReal.ofReal (t ^ (-q\u2081.toReal)) :=\n  weaktype_estimate hq\u2081 hq\u2081' (trunc_Lp_Lq_higher (p := p) \u27e8hp, hp\u2081p\u27e9 hf) h\u2081T ht\n\nlemma weaktype_estimate_trunc_top_top {a : \u211d} {C\u2081 : \u211d\u22650}\n    (hC\u2081 : C\u2081 > 0) {p p\u2081 q\u2081 : \u211d\u22650\u221e} (hp : 0 < p)\n    (hp\u2081 : p\u2081 = \u22a4) (hq\u2081 : q\u2081 = \u22a4) (hp\u2081p : p < p\u2081) {f : \u03b1 \u2192 E\u2081} (hf : Mem\u2112p f p \u03bc)\n    (h\u2081T : HasWeakType T p\u2081 q\u2081 \u03bc \u03bd C\u2081) {t : \u211d} (ht : t > 0) (ha : a = t / C\u2081) :\n    distribution (T (trunc f a)) (ENNReal.ofReal t) \u03bd = 0 := by\n  rw [ha]\n  have obs : Mem\u2112p (trunc f (t / C\u2081)) p\u2081 \u03bc := trunc_Lp_Lq_higher \u27e8hp, hp\u2081p\u27e9 hf\n  have wt_est := (h\u2081T (trunc f (t / C\u2081)) obs).2\n  simp only [wnorm, eLpNorm, hq\u2081, \u2193reduceIte, hp\u2081, top_ne_zero] at wt_est\n  apply nonpos_iff_eq_zero.mp\n  have ineq : eLpNormEssSup (T (trunc f (t / C\u2081))) \u03bd \u2264 ENNReal.ofReal t := calc\n    _ \u2264 C\u2081 * eLpNormEssSup (trunc f (t / C\u2081)) \u03bc := wt_est\n    _ \u2264 C\u2081 * ENNReal.ofReal (max 0 (t / C\u2081)) := by\n      gcongr\n      exact trunc_eLpNormEssSup_le\n    _ \u2264 _ := by\n      let C := C\u2081.toReal\n      have coe_C : C.toNNReal = C\u2081 := Real.toNNReal_coe\n      rw [\u2190 coe_C, coe_coe_eq_ofReal, \u2190 ENNReal.ofReal_mul, max_eq_right, congrArg toReal coe_C,\n        mul_div_cancel\u2080]\n      \u00b7 exact Ne.symm (ne_of_lt hC\u2081)\n      \u00b7 positivity\n      \u00b7 positivity\n  calc\n  _ \u2264 distribution (T (trunc f (t / C\u2081))) (eLpNormEssSup (T (trunc f (t / C\u2081))) \u03bd) \u03bd :=\n      distribution_mono_right ineq\n  _ = 0 := distribution_snormEssSup\n\nlemma weaktype_estimate_trunc_compl_top {C\u2080 : \u211d\u22650} (hC\u2080 : C\u2080 > 0) {p p\u2080 q\u2080 : \u211d\u22650\u221e}\n    (hp\u2080 : 0 < p\u2080) (hq\u2080 : q\u2080 = \u22a4) (hp\u2080p : p\u2080 < p) (hp : p \u2260 \u22a4) {f : \u03b1 \u2192 E\u2081} (hf : Mem\u2112p f p \u03bc)\n    (h\u2080T : HasWeakType T p\u2080 q\u2080 \u03bc \u03bd C\u2080) {t : \u211d} (ht : t > 0) {a : \u211d} {d : \u211d} -- (hd : d > 0)\n    (ha : a = (t / d) ^ (p\u2080.toReal / (p\u2080.toReal - p.toReal)))\n    (hdeq : d = ((ENNReal.ofNNReal C\u2080) ^ p\u2080.toReal *\n        eLpNorm f p \u03bc ^ p.toReal).toReal ^ p\u2080.toReal\u207b\u00b9) :\n    distribution (T (f - trunc f a)) (ENNReal.ofReal t) \u03bd = 0 := by\n  rcases (eq_zero_or_pos (eLpNormEssSup f \u03bc)) with snorm_zero | snorm_pos\n  \u00b7 have : eLpNorm (trnc \u22a5 f a) \u22a4 \u03bc = 0 := by\n      apply nonpos_iff_eq_zero.mp\n      rw [\u2190 snorm_zero]\n      exact eLpNorm_trnc_est (p := \u22a4)\n    have obs : eLpNorm (T (trnc \u22a5 f a)) \u22a4 \u03bd = 0 :=\n      weaktype_aux\u2080 hp\u2080 (hq\u2080 \u25b8 zero_lt_top) zero_lt_top zero_lt_top h\u2080T\n        (aestronglyMeasurable_trunc_compl hf.1) this\n    exact nonpos_iff_eq_zero.mp (Trans.trans (distribution_mono_right (Trans.trans obs\n      (zero_le (ENNReal.ofReal t)))) meas_eLpNormEssSup_lt)\n  \u00b7 have p_pos : p > 0 := lt_trans hp\u2080 hp\u2080p\n    have snorm_p_pos : eLpNorm f p \u03bc \u2260 0 := fun snorm_0 \u21a6 snorm_pos.ne' <|\n      eLpNormEssSup_eq_zero_iff.mpr <| (eLpNorm_eq_zero_iff hf.1 p_pos.ne').mp snorm_0\n    have term_pos : (ENNReal.ofNNReal C\u2080) ^ p\u2080.toReal * eLpNorm f p \u03bc ^ p.toReal > 0 := by\n      apply ENNReal.mul_pos <;> exact (rpow_pos_of_nonneg (by positivity) (by positivity)).ne'\n    have term_ne_top : (ENNReal.ofNNReal C\u2080) ^ p\u2080.toReal * eLpNorm f p \u03bc ^ p.toReal \u2260 \u22a4\n        := mul_ne_top (rpow_ne_top' (ENNReal.coe_ne_zero.mpr hC\u2080.ne') coe_ne_top)\n          (rpow_ne_top' snorm_p_pos (Mem\u2112p.eLpNorm_ne_top hf))\n    have d_pos : d > 0 := hdeq \u25b8 Real.rpow_pos_of_pos (zero_toReal \u25b8\n      toReal_strict_mono term_ne_top term_pos) _\n    have a_pos : a > 0 := by rw [ha]; positivity\n    have obs : Mem\u2112p (f - trunc f a) p\u2080 \u03bc := trunc_compl_Lp_Lq_lower hp \u27e8hp\u2080, hp\u2080p\u27e9 a_pos hf\n    have wt_est := (h\u2080T (f - trunc f a) obs).2\n    unfold wnorm at wt_est\n    split_ifs at wt_est\n    have snorm_est : eLpNormEssSup (T (f - trunc f a)) \u03bd \u2264 ENNReal.ofReal t := by\n      apply le_of_rpow_le (exp_toReal_pos hp\u2080 hp\u2080p.ne_top)\n      calc\n      _ \u2264 (\u2191C\u2080 * eLpNorm (f - trunc f a) p\u2080 \u03bc) ^ p\u2080.toReal := by gcongr\n      _ \u2264 (\u2191C\u2080) ^ p\u2080.toReal * (ENNReal.ofReal (a ^ (p\u2080.toReal - p.toReal)) *\n          eLpNorm f p \u03bc ^ p.toReal) := by\n        rw [ENNReal.mul_rpow_of_nonneg _ _ toReal_nonneg]\n        gcongr\n        exact estimate_eLpNorm_trunc_compl hp \u27e8hp\u2080, hp\u2080p\u27e9 hf.1.aemeasurable a_pos\n      _ = (\u2191C\u2080) ^ p\u2080.toReal * eLpNorm f p \u03bc ^ p.toReal *\n          (ENNReal.ofReal (d ^ p\u2080.toReal))\u207b\u00b9 * ENNReal.ofReal (t ^ p\u2080.toReal) := by\n        rw [ha, \u2190 Real.rpow_mul, div_mul_cancel\u2080]\n        \u00b7 rw [Real.div_rpow] <;> try positivity\n          rw [ENNReal.ofReal_div_of_pos] <;> try positivity\n          rw [div_eq_mul_inv]\n          ring\n        \u00b7 exact (sub_neg.mpr (toReal_strict_mono hp hp\u2080p)).ne\n        \u00b7 positivity\n      _ = _ := by\n        rw [ofReal_rpow_of_pos ht]\n        nth_rw 3 [\u2190 one_mul (ENNReal.ofReal _)]\n        rw [hdeq]\n        rw [Real.rpow_inv_rpow] <;> try positivity\n        rw [ofReal_toReal term_ne_top, ENNReal.mul_inv_cancel (by positivity) term_ne_top]\n        exact toReal_ne_zero.mpr \u27e8hp\u2080.ne', hp\u2080p.ne_top\u27e9\n    apply nonpos_iff_eq_zero.mp\n    calc\n    _ \u2264 distribution (T (f - trunc f a)) (eLpNormEssSup (T (f - trunc f a)) \u03bd) \u03bd :=\n      distribution_mono_right snorm_est\n    _ = _ := meas_eLpNormEssSup_lt\n\nlemma weaktype_estimate_trunc_top {C\u2081 : \u211d\u22650} (hC\u2081 : C\u2081 > 0) {p p\u2081 q\u2081 : \u211d\u22650\u221e}\n    (hp : 0 < p)\n    (hp\u2081 : p\u2081 < \u22a4) (hq\u2081 : q\u2081 = \u22a4) (hp\u2081p : p < p\u2081) {f : \u03b1 \u2192 E\u2081} (hf : Mem\u2112p f p \u03bc)\n    (h\u2081T : HasWeakType T p\u2081 q\u2081 \u03bc \u03bd C\u2081) {t : \u211d} (ht : t > 0) {a : \u211d} {d : \u211d} -- (hd : d > 0)\n    (ha : a = (t / d) ^ (p\u2081.toReal / (p\u2081.toReal - p.toReal)))\n    (hdeq : d = ((ENNReal.ofNNReal C\u2081) ^ p\u2081.toReal *\n        eLpNorm f p \u03bc ^ p.toReal).toReal ^ p\u2081.toReal\u207b\u00b9) :\n    distribution (T (trunc f a)) (ENNReal.ofReal t) \u03bd = 0 := by\n  have obs : Mem\u2112p (trunc f a) p\u2081 \u03bc := trunc_Lp_Lq_higher \u27e8hp, hp\u2081p\u27e9 hf\n  have wt_est := (h\u2081T (trunc f a) obs).2\n  unfold wnorm at wt_est\n  split_ifs at wt_est\n  have : p\u2081.toReal \u2260 0 := exp_toReal_ne_zero' (lt_trans hp hp\u2081p) hp\u2081.ne_top\n  have : eLpNormEssSup (T (trunc f a)) \u03bd ^ p\u2081.toReal \u2264 (\u2191C\u2081 * eLpNorm (trunc f a) p\u2081 \u03bc) ^ p\u2081.toReal\n      := by gcongr\n  have snorm_est : eLpNormEssSup (T (trunc f a)) \u03bd \u2264 ENNReal.ofReal t := by\n    apply le_of_rpow_le (exp_toReal_pos (lt_trans hp hp\u2081p) hp\u2081.ne_top)\n    refine le_trans this ?_\n    rcases (eq_zero_or_pos (eLpNormEssSup f \u03bc)) with snorm_zero | snorm_pos\n    \u00b7 gcongr\n      calc\n      _ \u2264 (ENNReal.ofNNReal C\u2081) * eLpNorm f p\u2081 \u03bc := by\n        gcongr\n        apply eLpNorm_mono (fun x \u21a6 trunc_le_func)\n      _ \u2264 _ := by\n        have : eLpNorm f p\u2081 \u03bc = 0 := Trans.trans (eLpNorm_congr_ae\n            (eLpNormEssSup_eq_zero_iff.mp snorm_zero)) eLpNorm_zero\n        simp only [this, mul_zero, zero_le]\n    \u00b7 have snorm_p_pos : eLpNorm f p \u03bc \u2260 0 := by\n        intro snorm_0\n        apply Ne.symm (ne_of_lt snorm_pos)\n        apply eLpNormEssSup_eq_zero_iff.mpr\n        exact (eLpNorm_eq_zero_iff hf.1 hp.ne').mp snorm_0\n      have term_pos : (ENNReal.ofNNReal C\u2081) ^ p\u2081.toReal * eLpNorm f p \u03bc ^ p.toReal > 0 := by\n        apply ENNReal.mul_pos <;> exact (rpow_pos_of_nonneg (by positivity) (by positivity)).ne'\n      have term_ne_top : (ENNReal.ofNNReal C\u2081) ^ p\u2081.toReal * eLpNorm f p \u03bc ^ p.toReal \u2260 \u22a4 :=\n        mul_ne_top (rpow_ne_top' (ENNReal.coe_ne_zero.mpr hC\u2081.ne') coe_ne_top)\n          (rpow_ne_top' snorm_p_pos (Mem\u2112p.eLpNorm_ne_top hf))\n      have d_pos : d > 0 := hdeq \u25b8 Real.rpow_pos_of_pos (zero_toReal \u25b8\n        toReal_strict_mono term_ne_top term_pos) _\n      calc\n      _ \u2264 \u2191C\u2081 ^ p\u2081.toReal * ((ENNReal.ofReal (a ^ (p\u2081.toReal - p.toReal))) * eLpNorm f p \u03bc ^ p.toReal) := by\n        rw [ENNReal.mul_rpow_of_nonneg]\n        gcongr\n        \u00b7 exact estimate_eLpNorm_trunc hp\u2081.ne_top \u27e8hp, hp\u2081p\u27e9 hf.1.aemeasurable\n        \u00b7 exact toReal_nonneg\n      _ = \u2191C\u2081 ^ p\u2081.toReal * eLpNorm f p \u03bc ^ p.toReal * (ENNReal.ofReal (d ^ p\u2081.toReal))\u207b\u00b9 *\n          ENNReal.ofReal (t ^ p\u2081.toReal) := by\n        rw [ha, \u2190 Real.rpow_mul, div_mul_cancel\u2080]\n        \u00b7 rw [Real.div_rpow] <;> try positivity\n          rw [ENNReal.ofReal_div_of_pos] <;> try positivity\n          rw [div_eq_mul_inv]\n          ring\n        \u00b7 exact (sub_pos.mpr (toReal_strict_mono hp\u2081.ne_top hp\u2081p)).ne'\n        \u00b7 positivity\n      _ = _ := by\n        rw [ofReal_rpow_of_pos ht]\n        nth_rw 3 [\u2190 one_mul (ENNReal.ofReal _)]\n        rw [hdeq]\n        rw [Real.rpow_inv_rpow] <;> try positivity\n        rw [ofReal_toReal term_ne_top, ENNReal.mul_inv_cancel (by positivity) term_ne_top]\n  apply nonpos_iff_eq_zero.mp\n  calc\n  _ \u2264 distribution (T (trunc f a)) (eLpNormEssSup (T (trunc f a)) \u03bd) \u03bd := by gcongr\n  _ = _ := meas_eLpNormEssSup_lt\n\nend MeasureTheory\n\nend\n\nnoncomputable section\n\nopen NNReal ENNReal MeasureTheory Set Pointwise\n\nvariable {\u03b1 \u03b1' \u03b5 E E\u2081 E\u2082 E\u2083 : Type*} {m : MeasurableSpace \u03b1} {m' : MeasurableSpace \u03b1'}\n  {p p' q p\u2080 q\u2080 p\u2081 q\u2081: \u211d\u22650\u221e}\n  {C\u2080 C\u2081 : \u211d\u22650} {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b1'}\n  {a : \u211d}-- truncation parameter\n  [NormedAddCommGroup E] [NormedAddCommGroup E\u2081] [NormedAddCommGroup E\u2082] [NormedAddCommGroup E\u2083]\n  [MeasurableSpace E] [BorelSpace E]\n  [MeasurableSpace E\u2083] [BorelSpace E\u2083]\n  {f : \u03b1 \u2192 E\u2081} {t : \u211d}\n  {T : (\u03b1 \u2192 E\u2081) \u2192 (\u03b1' \u2192 E\u2082)}\nnamespace MeasureTheory\n\n-- /-- # The real interpolation theorem\n\n-- ## Definitions-/\n\ndef Subadditive [ENorm \u03b5] (T : (\u03b1 \u2192 E\u2081) \u2192 \u03b1' \u2192 \u03b5) : Prop :=\n  \u2203 A \u2260 \u22a4, \u2200 (f g : \u03b1 \u2192 E\u2081) (x : \u03b1'), \u2016T (f + g) x\u2016\u2091 \u2264 A * (\u2016T f x\u2016\u2091 + \u2016T g x\u2016\u2091)\n\ndef Subadditive_trunc [ENorm \u03b5] (T : (\u03b1 \u2192 E\u2081) \u2192 \u03b1' \u2192 \u03b5) (A : \u211d\u22650\u221e) (f : \u03b1 \u2192 E\u2081) (\u03bd : Measure \u03b1') :\n    Prop :=\n  \u2200 a : \u211d, a > 0 \u2192 \u2200\u1d50 y \u2202\u03bd,\n  \u2016T (trunc f a + trunc_compl f a) y\u2016\u2091 \u2264 A * (\u2016T (trunc f a) y\u2016\u2091 + \u2016T (trunc_compl f a) y\u2016\u2091)\n\n/-- The operator is subadditive on functions satisfying `P` with constant `A`\n(this is almost vacuous if `A = \u22a4`). -/\ndef AESubadditiveOn [ENorm \u03b5] (T : (\u03b1 \u2192 E\u2081) \u2192 \u03b1' \u2192 \u03b5) (P : (\u03b1 \u2192 E\u2081) \u2192 Prop) (A : \u211d\u22650\u221e)\n    (\u03bd : Measure \u03b1') : Prop :=\n  \u2200 (f g : \u03b1 \u2192 E\u2081), P f \u2192 P g \u2192 \u2200\u1d50 x \u2202\u03bd, \u2016T (f + g) x\u2016\u2091 \u2264 A * (\u2016T f x\u2016\u2091 + \u2016T g x\u2016\u2091)\n\nnamespace AESubadditiveOn\n\nvariable [ENormedAddMonoid \u03b5] {\u03bd : Measure \u03b1'}\n\nlemma antitone {T : (\u03b1 \u2192 E\u2081) \u2192 \u03b1' \u2192 \u03b5} {P P' : (\u03b1 \u2192 E\u2081) \u2192 Prop}\n    (h : \u2200 {u : \u03b1 \u2192 E\u2081}, P u \u2192 P' u) {A : \u211d\u22650\u221e} (sa : AESubadditiveOn T P' A \u03bd) :\n    AESubadditiveOn T P A \u03bd :=\n  fun f g hf hg \u21a6 sa f g (h hf) (h hg)\n\n", "theoremStatement": "lemma zero {P : (\u03b1 \u2192 E\u2081) \u2192 Prop} (hP : \u2200 {f g : \u03b1 \u2192 E\u2081}, P f \u2192 P g \u2192 P (f + g))\n    (A : \u211d\u22650\u221e) (h : \u2200 u, P u \u2192 T u =\u1d50[\u03bd] 0) : AESubadditiveOn T P A \u03bd ", "theoremName": "MeasureTheory.AESubadditiveOn.zero", "fileCreated": {"commit": "1a36cbeaee9466fb56c9aca49ef373f9f9cc7ab7", "date": "2025-01-23"}, "theoremCreated": {"commit": "b069d5bb71885f498386762866228ac78bf5409e", "date": "2025-01-13"}, "file": "carleson/Carleson/ToMathlib/RealInterpolation.lean", "module": "Carleson.ToMathlib.RealInterpolation", "jsonFile": "Carleson.ToMathlib.RealInterpolation.jsonl", "positionMetadata": {"lineInFile": 3049, "tokenPositionInFile": 136042, "theoremPositionInFile": 237}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 9, "numPremises": 76}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  intro f g hf hg\n  filter_upwards [h f hf, h g hg, h (f + g) (hP hf hg)] with x hx1 hx2 hx3\n  simp [hx1, hx2, hx3]", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 121}}
{"srcContext": "/-\nCopyright (c) 2024 Joris Roos. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joris Roos, S\u00e9bastien Gou\u00ebzel\n-/\n\nimport Mathlib.Analysis.Convex.PartitionOfUnity\nimport Mathlib.Analysis.Calculus.ContDiff.Basic\nimport Mathlib.MeasureTheory.Integral.Average\nimport Mathlib.MeasureTheory.Integral.Bochner\nimport Mathlib.MeasureTheory.Integral.Prod\nimport Mathlib.MeasureTheory.Measure.Haar.OfBasis\nimport Mathlib.Topology.MetricSpace.Holder\nimport Mathlib.Data.Set.Card\nimport Mathlib.Data.Real.ENatENNReal\nimport Carleson.ToMathlib.Misc\n\n/-!\n\nEXPERIMENTAL\n\n# Bounded compactly supported functions\n\nThe purpose of this file is to provide helper lemmas to streamline proofs that\nfunctions are (essentially) bounded, compactly supported and measurable.\n\nMost functions we need to deal with are of this class.\nThis can be a useful way to streamline proofs of `L^p` membership,\nin particular integrability.\n\nTodo: make `Mathlib.Tactic.FunProp` work for this\n\nThis can be expanded as needed\n\n-/\n\nset_option linter.unusedSectionVars false -- remove for mathlib\n\nnamespace MeasureTheory\n\nopen Bornology Function Set HasCompactSupport\nopen scoped ENNReal\n\nsection\n\n-- This setting should be enough for this project, but\n-- for mathlib should generalize to vector-valued, and use `MeasurableSpace X`, `Measure \u03bc`\nvariable {X \ud835\udd5c} [MeasurableSpace X] [RCLike \ud835\udd5c] {f : X \u2192 \ud835\udd5c} {\u03bc : Measure X}\nvariable [TopologicalSpace X]\n-- variable [T2Space X] -- for mathlib should remove this\n-- variable [IsFiniteMeasureOnCompacts \u03bc]\n-- variable [SigmaFinite (volume : Measure X)]\n\n/-- Bounded compactly supported measurable functions -/\n-- There are various alternative definitions one could use here\n-- After all it does seem to be better to use `IsBounded (range f)`\n-- Todo: Refactor accordingly\nstructure BoundedCompactSupport (f : X \u2192 \ud835\udd5c) : Prop where\n  isBounded : IsBounded (range f)\n  stronglyMeasurable : StronglyMeasurable f\n  hasCompactSupport : HasCompactSupport f\n\nlemma isBounded_range_iff_forall_norm_le {\u03b1 \u03b2} [SeminormedAddCommGroup \u03b1] {f : \u03b2 \u2192 \u03b1} :\n    IsBounded (range f) \u2194 \u2203 C, \u2200 x, \u2016f x\u2016 \u2264 C := by convert isBounded_iff_forall_norm_le; simp\n\nomit [TopologicalSpace X] in\nlemma _root_.Bornology.IsBounded.eLpNorm_top_lt_top (hf : IsBounded (range f)) :\n    eLpNorm f \u22a4 \u03bc < \u22a4 := by\n  obtain \u27e8C, hC\u27e9 := isBounded_range_iff_forall_norm_le.mp hf\n  apply eLpNormEssSup_lt_top_of_ae_bound (C := C)\n  exact ae_of_all \u03bc hC\n\nomit [TopologicalSpace X] in\n-- maybe in mathlib, but couldn't find it\ntheorem ae_le_of_eLpNorm_top_lt_top (hf : eLpNorm f \u22a4 \u03bc < \u22a4) :\n    \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016 \u2264 ENNReal.toReal (eLpNorm f \u22a4 \u03bc) := by\n  have := coe_nnnorm_ae_le_eLpNormEssSup f \u03bc\n  filter_upwards [this] with x hx\n  have : ENNReal.ofReal \u2016f x\u2016\u208a \u2260 \u22a4 := ENNReal.ofReal_ne_top\n  convert (ENNReal.toReal_le_toReal this ?_).mpr ?_\n  \u00b7 simp\n  \u00b7 exact hf.ne_top\n  \u00b7 exact trans ENNReal.ofReal_coe_nnreal hx\n\nnamespace BoundedCompactSupport\n\nprotected theorem zero : BoundedCompactSupport (fun (_ : X) \u21a6 (0 : \ud835\udd5c)) where\n  isBounded := isBounded_range_iff_forall_norm_le.2 \u27e80, by simp\u27e9\n  stronglyMeasurable := stronglyMeasurable_const\n  hasCompactSupport := HasCompactSupport.zero\n\ntheorem indicator_of_isBounded_range {X : Type*} [MetricSpace X] [ProperSpace X]\n    [MeasurableSpace X] [BorelSpace X] {f : X \u2192 \ud835\udd5c} (hf : IsBounded (range f))\n    (h'f : StronglyMeasurable f) {s : Set X} (h's : IsBounded s) (hs : MeasurableSet s) :\n    BoundedCompactSupport (s.indicator f) where\n  stronglyMeasurable := h'f.indicator hs\n  isBounded := by\n    rcases isBounded_range_iff_forall_norm_le.1 hf with \u27e8C, hC\u27e9\n    apply isBounded_range_iff_forall_norm_le.2 \u27e8C, fun x \u21a6 ?_\u27e9\n    simp only [indicator]\n    split_ifs\n    \u00b7 exact hC x\n    \u00b7 simp only [norm_zero]\n      apply (norm_nonneg _).trans (hC x)\n  hasCompactSupport := by\n    apply HasCompactSupport.intro (K := closure s)\n    \u00b7 apply Metric.isCompact_of_isClosed_isBounded isClosed_closure h's.closure\n    \u00b7 intro x hx\n      have : x \u2209 s := by\n        contrapose! hx; exact subset_closure hx\n      simp [this]\n\nvariable {f : X \u2192 \ud835\udd5c}\nvariable {g : X \u2192 \ud835\udd5c}\n\nvariable (hf : BoundedCompactSupport f)\nvariable (hg : BoundedCompactSupport g)\n\nsection Includehf\n\ninclude hf\n\ntheorem aestronglyMeasurable : AEStronglyMeasurable f \u03bc :=\n  hf.stronglyMeasurable.aestronglyMeasurable\n\ntheorem mem\u2112p_top : Mem\u2112p f \u22a4 \u03bc :=\n  \u27e8hf.aestronglyMeasurable, hf.isBounded.eLpNorm_top_lt_top\u27e9\n\ntheorem ae_le : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016 \u2264 ENNReal.toReal (eLpNorm f \u22a4 \u03bc) :=\n  ae_le_of_eLpNorm_top_lt_top hf.mem\u2112p_top.2\n\n/-- Bounded compactly supported functions are in all `L\u1d56` spaces. -/\ntheorem mem\u2112p [IsFiniteMeasureOnCompacts \u03bc] (p : ENNReal) : Mem\u2112p f p \u03bc :=\n  hf.hasCompactSupport.mem\u2112p_of_bound hf.aestronglyMeasurable _ hf.ae_le\n\n/-- Bounded compactly supported functions are integrable. -/\ntheorem integrable [IsFiniteMeasureOnCompacts \u03bc] : Integrable f \u03bc :=\n  mem\u2112p_one_iff_integrable.mp <| mem\u2112p hf 1\n\ntheorem mul_bdd_right (hg : IsBounded (range g)) (h2g : StronglyMeasurable g) :\n    BoundedCompactSupport (f * g) where\n  isBounded := by\n    rcases isBounded_range_iff_forall_norm_le.1 hf.isBounded with \u27e8C, hC\u27e9\n    rcases isBounded_range_iff_forall_norm_le.1 hg with \u27e8D, hD\u27e9\n    apply isBounded_range_iff_forall_norm_le.2 \u27e8C * D, fun x \u21a6 ?_\u27e9\n    simp only [Pi.mul_apply, norm_mul]\n    gcongr\n    \u00b7 apply (norm_nonneg _).trans (hC x)\n    \u00b7 exact hC x\n    \u00b7 exact hD x\n  stronglyMeasurable := hf.stronglyMeasurable.mul h2g\n  hasCompactSupport := hf.hasCompactSupport.mul_right\n\ntheorem mul_bdd_left (hg : IsBounded (range g)) (h2g : StronglyMeasurable g) :\n    BoundedCompactSupport (g * f) := by\n  rw [mul_comm]; exact mul_bdd_right hf hg h2g\n\n-- doesn't use compact support but is convenient to have here\ntheorem integrable_mul (hg : Integrable g \u03bc) : Integrable (f * g) \u03bc :=\n  Integrable.bdd_mul' hg hf.aestronglyMeasurable hf.ae_le\n\ntheorem conj : BoundedCompactSupport (star f) where\n  isBounded := by simpa [star, isBounded_range_iff_forall_norm_le] using hf.isBounded\n  stronglyMeasurable := RCLike.continuous_conj.comp_stronglyMeasurable hf.stronglyMeasurable\n  hasCompactSupport := by -- mathlib should have a lemma `HasCompactSupport.conj`?\n    simp only [star, RCLike.star_def]\n    apply (hasCompactSupport_comp_left (by simp)).2 hf.hasCompactSupport\n\ntheorem norm : BoundedCompactSupport (\u2016f \u00b7\u2016) where\n  isBounded := by simpa [isBounded_range_iff_forall_norm_le] using hf.isBounded\n  stronglyMeasurable := hf.stronglyMeasurable.norm\n  hasCompactSupport := hf.hasCompactSupport.norm\n\ntheorem const_mul (c : \ud835\udd5c) : BoundedCompactSupport (fun x \u21a6 c * (f x)) where\n  isBounded := by\n    rcases isBounded_range_iff_forall_norm_le.1 hf.isBounded with \u27e8C, hC\u27e9\n    apply isBounded_range_iff_forall_norm_le.2 \u27e8\u2016c\u2016 * C, fun x \u21a6 ?_\u27e9\n    simp only [norm_mul]\n    gcongr\n    exact hC x\n  stronglyMeasurable := hf.stronglyMeasurable.const_mul _\n  hasCompactSupport := by\n    suffices support (fun x \u21a6 c * (f x)) \u2286 support f from\n      hf.hasCompactSupport.mono this\n    exact support_mul_subset_right ..\n\ntheorem mul_const (c : \ud835\udd5c) : BoundedCompactSupport (fun x \u21a6 (f x) * c) := by\n  simp_rw [mul_comm]; exact hf.const_mul _\n\nend Includehf\n\nsection Includehfhg\n\ninclude hf hg\n\ntheorem mul : BoundedCompactSupport (f * g) := mul_bdd_right hf hg.isBounded hg.stronglyMeasurable\n\nprotected theorem add : BoundedCompactSupport (f + g) where\n  isBounded := by\n    rcases isBounded_range_iff_forall_norm_le.1 hf.isBounded with \u27e8C, hC\u27e9\n    rcases isBounded_range_iff_forall_norm_le.1 hg.isBounded with \u27e8D, hD\u27e9\n    apply isBounded_range_iff_forall_norm_le.2 \u27e8C + D, fun x \u21a6 ?_\u27e9\n    apply (norm_add_le _ _).trans\n    gcongr\n    exacts [hC x, hD x]\n  stronglyMeasurable := hf.stronglyMeasurable.add hg.stronglyMeasurable\n  hasCompactSupport := hf.hasCompactSupport.add hg.hasCompactSupport\n\nprotected theorem sub : BoundedCompactSupport (f - g) := by\n  rw [sub_eq_add_neg, neg_eq_neg_one_mul]\n  exact hf.add (hg.const_mul (-1))\n\nend Includehfhg\n\n/-- If `\u2016f\u2016` is bounded by `g` and `g` is bounded compactly supported, then so is `f`. -/\ntheorem mono {g : X \u2192 \u211d} (hg : BoundedCompactSupport g) (hf : StronglyMeasurable f)\n    (hfg : \u2200 x, \u2016f x\u2016 \u2264 g x) : BoundedCompactSupport f where\n  isBounded := by\n    rcases isBounded_range_iff_forall_norm_le.1 hg.isBounded with \u27e8C, hC\u27e9\n    refine isBounded_range_iff_forall_norm_le.2 \u27e8C, fun x \u21a6 ?_\u27e9\n    exact (hfg x).trans ((le_abs_self _).trans (hC x))\n  hasCompactSupport := by\n    refine hg.hasCompactSupport.mono ?_\n    by_contra h\n    simp only [support_subset_iff, ne_eq, mem_support, not_forall, Classical.not_imp,\n      Decidable.not_not] at h\n    obtain \u27e8x, hfx, hgx\u27e9 := h\n    specialize hfg x\n    rw [hgx] at hfg\n    exact hfx <| norm_le_zero_iff.mp hfg\n  stronglyMeasurable := hf\n\ntheorem of_norm_le_const_mul {g : X \u2192 \u211d} {M : \u211d} (hg : BoundedCompactSupport g)\n    (hf : StronglyMeasurable f)\n    (hfg : \u2200 x, \u2016f x\u2016 \u2264 M * g x) : BoundedCompactSupport f :=\n  BoundedCompactSupport.mono (hg.const_mul M) hf hfg\n\nsection Sum\n\nvariable {\u03b9 : Type*} {s : Finset \u03b9} {F : \u03b9 \u2192 X \u2192 \ud835\udd5c}\n\n/-- A finite sum of bounded compactly supported functions is bounded compactly supported. -/\ntheorem finset_sum\n    (hF : \u2200 i \u2208 s, BoundedCompactSupport (F i)) :\n    BoundedCompactSupport (fun x \u21a6 \u2211 i \u2208 s, F i x) := by\n  classical\n  induction s using Finset.induction with\n  | empty => simp [BoundedCompactSupport.zero]\n  | @insert j s hjs IH =>\n    simp_rw [Finset.sum_insert hjs]\n    apply BoundedCompactSupport.add\n    \u00b7 exact hF _ (Finset.mem_insert_self j s)\n    \u00b7 exact IH (fun i hi \u21a6 hF _ (Finset.mem_insert_of_mem hi))\n\nend Sum\n\nsection Prod\n\nvariable {Y: Type*} [MeasureSpace Y] {g : Y \u2192 \ud835\udd5c}\nvariable [TopologicalSpace Y] [IsFiniteMeasureOnCompacts (volume : Measure Y)]\nvariable [SigmaFinite (volume : Measure Y)] [R1Space (X \u00d7 Y)]\n\n/-- An elementary tensor of bounded compactly supported functions is\n  bounded compactly supported. -/\ntheorem prod_mul (hf : BoundedCompactSupport f) (hg : BoundedCompactSupport g) :\n    BoundedCompactSupport (uncurry fun x y \u21a6 (f x) * (g y)) where\n  isBounded := by\n    rcases isBounded_range_iff_forall_norm_le.1 hf.isBounded with \u27e8C\u2081, hC\u2081\u27e9\n    rcases isBounded_range_iff_forall_norm_le.1 hg.isBounded with \u27e8C\u2082, hC\u2082\u27e9\n    apply isBounded_range_iff_forall_norm_le.2 \u27e8C\u2081 * C\u2082, fun x \u21a6 ?_\u27e9\n    simp only [uncurry, norm_mul]\n    gcongr\n    \u00b7 apply (norm_nonneg _).trans (hC\u2081 x.1)\n    \u00b7 exact hC\u2081 x.1\n    \u00b7 exact hC\u2082 x.2\n  stronglyMeasurable := .mul (.fst hf.stronglyMeasurable) (.snd hg.stronglyMeasurable)\n  hasCompactSupport := by\n    apply HasCompactSupport.intro <| IsCompact.prod hf.hasCompactSupport hg.hasCompactSupport\n    intro \u27e8x,y\u27e9 hxy\n    simp only [uncurry_apply_pair, mul_eq_zero]\n    simp only [mem_prod, not_and] at hxy\n    by_cases hx : x \u2208 tsupport f\n    \u00b7 right; exact image_eq_zero_of_nmem_tsupport (hxy hx)\n    \u00b7 left; exact image_eq_zero_of_nmem_tsupport hx\n\nvariable {F : X \u00d7 Y \u2192 \ud835\udd5c}\n\n-- -- prove when needed\n-- theorem swap (hF : BoundedCompactSupport F) : BoundedCompactSupport (F \u2218 Prod.swap) where\n--   isBounded := sorry\n--   stronglyMeasurable := sorry\n--   hasCompactSupport := sorry\n\nend Prod\n\nend BoundedCompactSupport\n\nend\n\nnamespace BoundedCompactSupport\n\n\nsection Metric\n\nvariable {X Y \ud835\udd5c: Type*} [RCLike \ud835\udd5c]\nvariable [MeasureSpace X] {f : X \u2192 \ud835\udd5c} [PseudoMetricSpace X] [SigmaFinite (volume : Measure X)]\nvariable [MeasureSpace Y] {g : Y \u2192 \ud835\udd5c} [PseudoMetricSpace Y] [SigmaFinite (volume : Measure Y)]\n\nvariable (hf : BoundedCompactSupport f) (hg : BoundedCompactSupport g)\n\nsection Prod\n\nvariable {F : X \u00d7 Y \u2192 \ud835\udd5c}\n\n-- ---- adapt and prove below when needed\n-- theorem prod_left (hF : BoundedCompactSupport F) :\n--     \u2200 y, BoundedCompactSupport (fun x \u21a6 F (x, y)) := fun y \u21a6 {\n--   isBounded := by\n--     rcases isBounded_range_iff_forall_norm_le.1 hF.isBounded with \u27e8C, hC\u27e9\n--     apply isBounded_range_iff_forall_norm_le.2 \u27e8C, fun x \u21a6 ?_\u27e9\n--     exact hC (x, y)\n--   stronglyMeasurable := hF.stronglyMeasurable.comp_measurable measurable_prod_mk_right\n--   hasCompactSupport := sorry\n--   -- by\n--   --   apply HasCompactSupport.intro\n--   --   sorry\n-- }\n\n\n-- theorem prod_right_ae (hF : BoundedCompactSupport F) :\n--     \u2200\u1d50 x, BoundedCompactSupport (fun y \u21a6 F (x, y)) := hF.swap.prod_left_ae\n\n-- theorem integral_prod_left (hF : BoundedCompactSupport F) :\n--     BoundedCompactSupport (fun x \u21a6 \u222b y, F (x, y)) := sorry\n-- --   have := hF.integrable.integrable_prod_left\n\n-- theorem integral_prod_right (hF : BoundedCompactSupport F) :\n--     BoundedCompactSupport (fun y \u21a6 \u222b x, F (x, y)) := hF.swap.integral_prod_left\n\nend Prod\n\nsection\ninclude hf\n\n", "theoremStatement": "theorem isBoundedSupport' : IsBounded (tsupport f) ", "theoremName": "MeasureTheory.BoundedCompactSupport.isBoundedSupport'", "fileCreated": {"commit": "ec175b9008144d009269ce427b9ad43dbd70d0a5", "date": "2024-12-09"}, "theoremCreated": {"commit": "ec175b9008144d009269ce427b9ad43dbd70d0a5", "date": "2024-12-09"}, "file": "carleson/Carleson/ToMathlib/BoundedCompactSupport.lean", "module": "Carleson.ToMathlib.BoundedCompactSupport", "jsonFile": "Carleson.ToMathlib.BoundedCompactSupport.jsonl", "positionMetadata": {"lineInFile": 345, "tokenPositionInFile": 12554, "theoremPositionInFile": 15}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 25}, "proofMetadata": {"hasProof": true, "proof": ":=\n  hf.hasCompactSupport.isBounded", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 35}}
{"srcContext": "import Carleson.Defs\nimport Mathlib.Algebra.Lie.OfAssociative\nimport Mathlib.Topology.EMetricSpace.Paracompact\n\nopen MeasureTheory Measure NNReal Metric Set TopologicalSpace Function DoublingMeasure Bornology\nopen scoped ENNReal\nnoncomputable section\n\n/-! The function `\u03c8` -/\n\nsection D\nvariable {D : \u2115} {x : \u211d} {s : \u2124} (hD : 1 < (D : \u211d))\n\nopen Real\n\nsection -- We record here some trivial inequalities that are used repeatedly below.\nprivate lemma fourD0' (hD : 1 \u2264 D) : 0 < (4 * D : \u211d) := by positivity\nprivate lemma four_x0 {x : \u211d} (hx : 0 < x) : 0 < 4 * x := mul_pos four_pos hx\ninclude hD\nprivate lemma D0 : 0 < (D : \u211d) := one_pos.trans hD\nprivate lemma D2 : 2 \u2264 (D : \u211d) := by exact_mod_cast hD\nprivate lemma twoD0 : 0 < (2 * D : \u211d) := by linarith\nprivate lemma fourD0 : 0 < (4 * D : \u211d) := by linarith\nprivate lemma D_pow0 (r : \u211d) : 0 < (D : \u211d) ^ r := by positivity\nprivate lemma D_pow0' (r : \u2124) : 0 < (D : \u211d) ^ r := by positivity\nprivate lemma cDx0 {c x : \u211d} (hc : c > 0) (hx : 0 < x) : c * D * x > 0 := by positivity\nend\n\ndef \u03c8 (D : \u2115) (x : \u211d) : \u211d :=\n  max 0 <| min 1 <| min (4 * D * x - 1) (2 - 4 * x)\n\nset_option hygiene false\nscoped[ShortVariables] notation \"\u03c8\" => \u03c8 (defaultD a)\n\nlemma zero_le_\u03c8 (D : \u2115) (x : \u211d) : 0 \u2264 \u03c8 D x :=\n  le_max_left 0 _\n\nlemma \u03c8_le_one (D : \u2115) (x : \u211d) : \u03c8 D x \u2264 1 :=\n  max_le (one_pos.le) (min_le_left 1 _)\n\nlemma abs_\u03c8_le_one (D : \u2115) (x : \u211d) : |\u03c8 D x| \u2264 1 :=\n  abs_le.2 \u27e8by linarith [zero_le_\u03c8 D x], \u03c8_le_one D x\u27e9\n\n---------------------------------------------\n/- `\u03c8_formula\u2080` through `\u03c8_formula\u2084` establish the piecewise formula for `\u03c8`. -/\n\nlemma \u03c8_formula\u2080 {x : \u211d} (hx : x \u2264 1 / (4 * D : \u211d)) : \u03c8 D x = 0 := by\n  by_cases hD : D = 0\n  \u00b7 simp [\u03c8, hD]\n  \u00b7 exact max_eq_left <| (min_le_right 1 _).trans <| (min_le_left _ _).trans <|\n      tsub_nonpos.2 <| (le_div_iff\u2080' (mul_pos four_pos\n      (by exact_mod_cast Nat.zero_lt_of_ne_zero hD))).1 hx\n\ninclude hD in\nlemma \u03c8_formula\u2081 {x : \u211d} (hx : 1 / (4 * D) \u2264 x \u2227 x \u2264 1 / (2 * D)) :\n    \u03c8 D x = 4 * D * x - 1 := by\n  have : x \u2265 0 := le_trans (one_div_nonneg.2 (fourD0 hD).le) hx.1\n  have hx1 := (div_le_iff\u2080' (fourD0 hD)).1 hx.1\n  have hx2 := (le_div_iff\u2080' (twoD0 hD)).1 hx.2\n  have ineq\u2080 : 4 * D * x - 1 \u2264 2 - 4 * x := by\n    suffices (2 * D + 2 * D + 4) * x \u2264 3 by linarith\n    exact le_trans (by gcongr; linarith [D2 hD]) (by linarith: (2 * D + 2 * D + 2 * D) * x \u2264 3)\n  have ineq\u2081 : 4 * D * x - 1 \u2264 1 := by linarith\n  have ineq\u2082 : 0 \u2264 4 * D * x - 1 := by linarith\n  rw [\u03c8, min_eq_left ineq\u2080, min_eq_right ineq\u2081, max_eq_right ineq\u2082]\n\ninclude hD in\nlemma \u03c8_formula\u2082 {x : \u211d} (hx : 1 / (2 * D) \u2264 x \u2227 x \u2264 1 / 4) : \u03c8 D x = 1 := by\n  unfold \u03c8\n  suffices min 1 (min (4 * D * x - 1) (2 - 4 * x)) = 1 from this.symm \u25b8 max_eq_right_of_lt one_pos\n  have := (div_le_iff\u2080' (twoD0 hD)).1 hx.1\n  exact min_eq_left (le_min (by linarith) (by linarith))\n\ninclude hD in\nlemma \u03c8_formula\u2083 {x : \u211d} (hx : 1 / 4 \u2264 x \u2227 x \u2264 1 / 2) : \u03c8 D x = 2 - 4 * x := by\n  have ineq\u2080 : 2 - 4 * x \u2264 4 * D * x - 1 := by nlinarith [D2 hD]\n  have ineq\u2081 : 2 - 4 * x \u2264 1 := by linarith\n  have ineq\u2082 : 2 - 4 * x \u2265 0 := by linarith\n  rw [\u03c8, min_eq_right ineq\u2080, min_eq_right ineq\u2081, max_eq_right ineq\u2082]\n\nlemma \u03c8_formula\u2084 {x : \u211d} (hx : x \u2265 1 / 2) : \u03c8 D x = 0 :=\n  max_eq_left <| (min_le_right _ _).trans <| (min_le_right _ _).trans (by linarith)\n---------------------------------------------\n\nlemma psi_zero : \u03c8 D 0 = 0 := \u03c8_formula\u2080 (by positivity)\n\nlemma continuous_\u03c8 : Continuous (\u03c8 D) := by\n  unfold \u03c8; fun_prop\n\ninclude hD in\nlemma support_\u03c8 : support (\u03c8 D) = Ioo (4 * D : \u211d)\u207b\u00b9 2\u207b\u00b9 := by\n  ext x\n  by_cases hx\u2080 : x \u2264 1 / (4 * D)\n  \u00b7 suffices x \u2264 (D : \u211d)\u207b\u00b9 * 4\u207b\u00b9 by simp [\u03c8_formula\u2080 hx\u2080, this]\n    rwa [one_div, mul_inv_rev] at hx\u2080\n  push_neg at hx\u2080\n  have hx\u2080_inv : (D : \u211d)\u207b\u00b9 * 4\u207b\u00b9 < x := by convert hx\u2080 using 1; simp\n  have ne\u2080 : 4 * D * x - 1 \u2260 0 := ne_of_gt (by rwa [sub_pos, \u2190 div_lt_iff\u2080' (fourD0 hD)])\n  by_cases hx\u2081 : x \u2264 1 / (2 * D)\n  \u00b7 suffices (D : \u211d)\u207b\u00b9 * 4\u207b\u00b9 < x \u2227 x < 2\u207b\u00b9 by simpa [ne\u2080, \u03c8_formula\u2081 hD \u27e8hx\u2080.le, hx\u2081\u27e9]\n    exact \u27e8hx\u2080_inv, lt_of_le_of_lt hx\u2081 (by simp [_root_.inv_lt_one_iff\u2080, hD])\u27e9\n  push_neg at hx\u2081\n  by_cases hx\u2082 : x \u2264 1 / 4\n  \u00b7 simpa [\u03c8_formula\u2082 hD \u27e8hx\u2081.le, hx\u2082\u27e9, hx\u2080_inv] using lt_of_le_of_lt hx\u2082 (by norm_num)\n  push_neg at hx\u2082\n  by_cases hx\u2083 : x < 1 / 2\n  \u00b7 have : \u00ac 2 - 4 * x = 0 := by linarith\n    simpa [\u03c8_formula\u2083 hD \u27e8hx\u2082.le, hx\u2083.le\u27e9, hx\u2080, hx\u2083, \u2190 one_div]\n  \u00b7 rw [mem_support, \u03c8_formula\u2084 (not_lt.1 hx\u2083), ne_self_iff_false, false_iff, mem_Ioo, not_and,\n      inv_eq_one_div 2]\n    exact fun _ \u21a6 hx\u2083\n\nlemma lipschitzWith_\u03c8 (hD : 1 \u2264 D) : LipschitzWith (4 * D) (\u03c8 D) := by\n  have max_eq_4D : max 0 (4 * D : \u211d\u22650) = 4 * D := max_eq_right (fourD0' hD).le\n  have max_eq_4D' : max (4 * D) 4 = 4 * D := by apply max_eq_left; linarith\n  suffices LipschitzWith (4 * D) (fun (x : \u211d) \u21a6 min 1 <| min (4 * D * x - 1) (2 - 4 * x)) from\n    max_eq_4D \u25b8 (LipschitzWith.const 0).max this\n  suffices LipschitzWith (4 * D) (fun (x : \u211d) \u21a6 min (4 * D * x - 1) (2 - 4 * x)) from\n    max_eq_4D \u25b8 (LipschitzWith.const 1).min this\n  have lw1 : LipschitzWith (4 * D) (fun (x : \u211d) \u21a6 4 * D * x - 1) := by\n    refine LipschitzWith.of_le_add_mul (4 * D) (fun x y \u21a6 ?_)\n    suffices 4 * D * (x - y) \u2264 4 * D * dist x y by norm_cast at this \u22a2; linarith\n    exact (mul_le_mul_left (fourD0' hD)).2 <| sub_le_dist x y\n  have lw2 : LipschitzWith 4 (fun (x : \u211d) \u21a6 2 - 4 * x) := by\n    refine LipschitzWith.of_le_add_mul 4 (fun x y \u21a6 ?_)\n    suffices 4 * (y - x) \u2264 4 * dist x y by norm_cast at this \u22a2; linarith\n    gcongr\n    exact dist_comm x y \u25b8 sub_le_dist y x\n  have := lw1.min lw2\n  norm_cast at this \u22a2\n  convert max_eq_4D' \u25b8 this\n\n-- Alternate version of `lipschitzWith_\u03c8` that avoids using `ENNReal`.\nlemma lipschitzWith_\u03c8' (hD : 1 \u2264 D) (a b : \u211d) : \u2016\u03c8 D a - \u03c8 D b\u2016 \u2264 4 * D * dist a b := by\n  have lipschitz := lipschitzWith_\u03c8 hD a b\n  rw [edist_dist, edist_dist, dist_eq_norm_sub] at lipschitz\n  norm_cast at lipschitz\n  rw [\u2190 ENNReal.ofReal_natCast, \u2190 ENNReal.ofReal_mul (by exact_mod_cast (fourD0' hD).le),\n    \u2190 ENNReal.toReal_le_toReal ENNReal.ofReal_ne_top ENNReal.ofReal_ne_top] at lipschitz\n  repeat rw [ENNReal.toReal_ofReal (by positivity)] at lipschitz\n  norm_cast\n\n/- the one or two numbers `s` where `\u03c8 (D ^ (-s) * x)` is possibly nonzero -/\nvariable (D) in def nonzeroS (x : \u211d) : Finset \u2124 :=\n  Finset.Icc \u230a(1 + logb D (2 * x))\u230b \u2308logb D (4 * x)\u2309\n\n---------------------------------------------\n\nsection include_hD\n\n/- The goal of the next several lemmas is to prove `sum_\u03c8`, which says that\n`\u2211 s \u2208 nonzeroS D x, \u03c8 D (D ^ (-s) * x) = 1`.\n\nThe first four lemmas prove some properties of the endpoints of `nonzeroS D x`, and in particular\nshow that `nonzeroS D x` has either 1 or 2 elements. The next two lemmas prove `sum_\u03c8` in the\n1-element and 2-element cases, respectively, and then `sum_\u03c8` follows immediately.\n-/\n\ninclude hD\n\nprivate lemma le_div_ceil_mul (hx : 0 < x) : 1 / (4 * D) \u2264 D ^ (-\u2308logb D (4 * x)\u2309) * x := by\n  rw [\u2190 div_le_iff\u2080 hx, div_div, \u2190 rpow_logb (D0 hD) (ne_of_gt hD) (cDx0 hD four_pos hx),\n    \u2190 inv_eq_one_div, (by norm_cast : (D : \u211d) ^ (-\u2308logb D (4 * x)\u2309) = D ^ (-\u2308logb D (4 * x)\u2309 : \u211d)),\n    \u2190 rpow_neg (D0 hD).le, rpow_le_rpow_left_iff hD, neg_le_neg_iff]\n  apply le_of_le_of_eq <| calc\n    (\u2308logb D (4 * x)\u2309 : \u211d) \u2264 \u230alogb D (4 * x)\u230b + 1 := by exact_mod_cast Int.ceil_le_floor_add_one _\n    _                     \u2264 logb D (4 * x) + 1   := by gcongr; exact Int.floor_le (logb D (4 * x))\n  rw [\u2190 logb_self_eq_one hD, \u2190 logb_mul (mul_pos four_pos hx).ne.symm (ne_of_gt (D0 hD)),\n    mul_assoc, mul_assoc, mul_comm _ x]\n\nprivate lemma one_add_logb (hx : x > 0) : 1 + logb D (2 * x) = logb D (2 * D * x) := by\n  rw [\u2190 logb_self_eq_one hD, \u2190 logb_mul (D0 hD).ne.symm (mul_pos two_pos hx).ne.symm,\n    \u2190 mul_assoc, mul_comm (D : \u211d) 2]\n\n-- If `D ^ (-\u2308logb D (4 * x)\u2309) \u2265 1 / (2 * D * x)`, then the endpoints of `nonzeroS x` are equal.\nprivate lemma eq_endpoints (hx : 0 < x) (h : D ^ (-\u2308logb D (4 * x)\u2309) \u2265 1 / (2 * D * x)) :\n    \u230a(1 + logb D (2 * x))\u230b = \u2308logb D (4 * x)\u2309 := by\n  rw [Int.floor_eq_iff, one_add_logb hD hx]\n  constructor\n  \u00b7 rw [\u2190 rpow_le_rpow_left_iff hD, \u2190 inv_le_inv\u2080 (D_pow0 hD _) (D_pow0 hD _),\n      rpow_logb (D0 hD) (ne_of_gt hD) (cDx0 hD two_pos hx),\n      \u2190 rpow_neg (D0 hD).le, inv_eq_one_div]\n    exact_mod_cast h.le\n  \u00b7 have : logb D (2 * D * x) < logb D (4 * D * x) := by\n      refine (strictMonoOn_logb hD) ?_ ?_ (by linarith [(cDx0 hD two_pos hx)]) <;>\n        exact mem_Ioi.2 (cDx0 hD (by norm_num) hx)\n    apply lt_of_lt_of_le this\n    rw [mul_comm, \u2190 mul_assoc, mul_comm x 4, logb_mul (mul_pos four_pos hx).ne.symm (D0 hD).ne.symm,\n      logb_self_eq_one hD, add_le_add_iff_right, mul_comm]\n    exact Int.le_ceil _\n\n-- If `D ^ (-\u2308logb D (4 * x)\u2309) < 1 / (2 * D * x)`, then the endpoints of `nonzeroS x` differ by 1.\nprivate lemma endpoint_sub_one (hx : 0 < x) (h : D ^ (-\u2308logb D (4 * x)\u2309) < 1 / (2 * D * x)) :\n    \u230a1 + logb D (2 * x)\u230b = \u2308logb D (4 * x)\u2309 - 1 := by\n  rw [one_add_logb hD hx]\n  apply le_antisymm\n  \u00b7 rw [\u2190 inv_eq_one_div, zpow_neg, inv_lt_inv\u2080 (D_pow0' hD _) (cDx0 hD two_pos hx)] at h\n    rw [Int.floor_le_sub_one_iff, \u2190 rpow_lt_rpow_left_iff hD,\n      rpow_logb (D0 hD) (ne_of_gt hD) (cDx0 hD two_pos hx)]\n    exact_mod_cast h\n  \u00b7 apply sub_le_iff_le_add.2 \u2218 Int.ceil_le.2\n    suffices logb D (4 * x) \u2264 logb D (2 * D * x) by\n      exact_mod_cast (lt_of_le_of_lt this (Int.lt_floor_add_one _)).le\n    have : 4 * x \u2264 2 * D * x := (mul_le_mul_right hx).2 (by linarith [D2 hD])\n    refine (strictMonoOn_logb hD).monotoneOn ?_ ?_ this <;> exact mem_Ioi.2 (by positivity)\n\n-- Special case of `sum_\u03c8`, for the case where `nonzeroS D x` has one element.\nprivate lemma sum_\u03c8\u2081 (hx : 0 < x) (h : D ^ (-\u2308logb D (4 * x)\u2309) \u2265 1 / (2 * D * x)) :\n    \u2211 s \u2208 nonzeroS D x, \u03c8 D (D ^ (-s) * x) = 1 := by\n  rw [nonzeroS, eq_endpoints hD hx h, Finset.Icc_self, Finset.sum_singleton]\n  refine \u03c8_formula\u2082 hD \u27e8le_of_eq_of_le (by field_simp) ((mul_le_mul_right hx).2 h), ?_\u27e9\n  calc\n    D ^ (-\u2308logb D (4 * x)\u2309) * x\n      = D ^ (-\u2308logb D (4 * x)\u2309 : \u211d) * x := by norm_cast\n    _ \u2264 D ^ (-logb D (4 * x)) * x      := by\n      gcongr\n      \u00b7 exact hD.le\n      \u00b7 exact Int.le_ceil (logb D (4 * x))\n    _ = 1 / (4 * x) * x                := by\n      rw [rpow_neg (D0 hD).le, inv_eq_one_div, rpow_logb (D0 hD) hD.ne.symm (by linarith)]\n    _ = 1 / 4                          := by field_simp; exact mul_comm x 4\n\n-- Special case of `sum_\u03c8`, for the case where `nonzeroS D x` has two elements.\nprivate lemma sum_\u03c8\u2082 (hx : 0 < x)\n    (h : D ^ (-\u2308logb D (4 * x)\u2309) < 1 / (2 * D * x)) :\n    \u2211 s \u2208 nonzeroS D x, \u03c8 D (D ^ (-s) * x) = 1 := by\n  -- Replace `nonzeroS D x` with `{s\u2080 - 1, s\u2080}`, where `s\u2080 := \u2308logb D (4 * x)\u2309`\n  have endpts := endpoint_sub_one hD hx h\n  have ne : \u2308logb D (4 * x)\u2309 - 1 \u2260 \u2308logb D (4 * x)\u2309 := pred_ne_self _\n  have : nonzeroS D x = {\u2308logb D (4 * x)\u2309 - 1, \u2308logb D (4 * x)\u2309} := by\n    rw [nonzeroS, \u2190 endpts]\n    have Icc_of_eq_add_one {a b : \u2124} (h : a + 1 = b) : Finset.Icc a b = {a, b} := by\n      subst h; exact Int.Icc_eq_pair a\n    exact Icc_of_eq_add_one (add_eq_of_eq_sub endpts)\n  set s\u2080 := \u2308logb D (4 * x)\u2309\n  rw [this, Finset.sum_insert ((Finset.not_mem_singleton).2 ne), Finset.sum_singleton]\n  -- Now calculate the sum\n  have Ds\u2080x_lt := (mul_lt_mul_right hx).2 h\n  rw [\u2190 div_div, div_mul_cancel\u2080 _ (ne_of_gt hx)] at Ds\u2080x_lt\n  have hs\u2080 := And.intro (le_div_ceil_mul hD hx) Ds\u2080x_lt.le\n  suffices 1 / 4 \u2264 D ^ (-(s\u2080 - 1)) * x \u2227 D ^ (-(s\u2080 - 1)) * x \u2264 1 / 2 by\n    rw [\u03c8_formula\u2081 hD hs\u2080, \u03c8_formula\u2083 hD this]\n    suffices (D : \u211d) ^ (1 - s\u2080) = D * D ^ (-s\u2080) by rw [neg_sub, this]; ring\n    rw [zpow_sub\u2080 (ne_of_gt (D0 hD)), zpow_neg, zpow_one, div_eq_mul_inv]\n  rw [neg_sub, sub_eq_add_neg, zpow_add\u2080 (ne_of_gt (D0 hD)), zpow_one, mul_assoc]\n  constructor\n  \u00b7 rw [\u2190 div_le_iff\u2080' (D0 hD), div_div]; exact hs\u2080.1\n  \u00b7 rw [\u2190 le_div_iff\u2080' (D0 hD), div_div]; exact hs\u2080.2\n\n-- See `finsum_\u03c8` for the version that doesn't explicitly restrict to the support.\nlemma sum_\u03c8 (hx : 0 < x) : \u2211 s \u2208 nonzeroS D x, \u03c8 D (D ^ (-s) * x) = 1 := by\n  by_cases h : D ^ (-\u2308logb D (4 * x)\u2309) \u2265 1 / (2 * D * x)\n  \u00b7 exact sum_\u03c8\u2081 hD hx h\n  \u00b7 exact sum_\u03c8\u2082 hD hx (lt_of_not_ge h)\n\n--------------------------------------------------\n/- Now we prove that `nonzeroS D x` is the support of `s \u21a6 \u03c8 D (D ^ (-s) * x)`. This converts\n`sum_\u03c8` into `finsum_\u03c8`, which states that `\u2211\u1da0 s : \u2124, \u03c8 D (D ^ (-s) * x) = 1`. -/\n\nlemma mem_nonzeroS_iff {i : \u2124} {x : \u211d} (hx : 0 < x) :\n    i \u2208 nonzeroS D x \u2194 (D ^ (-i) * x) \u2208 Ioo (4 * D : \u211d)\u207b\u00b9 2\u207b\u00b9 := by\n  rw [mem_Ioo, nonzeroS, Finset.mem_Icc, Int.floor_le_iff, Int.le_ceil_iff, mul_inv_rev,\n    add_comm _ 1, Real.add_lt_add_iff_left, \u2190 lt_div_iff\u2080 hx, mul_comm (D : \u211d)\u207b\u00b9,\n    \u2190 div_lt_div_iff\u2080 hx (inv_pos.2 (D0 hD)), div_inv_eq_mul, \u2190 zpow_add_one\u2080 ((D0 hD).ne.symm),\n    zpow_neg, \u2190 Real.rpow_intCast, \u2190 Real.rpow_intCast, lt_logb_iff_rpow_lt hD (four_x0 hx),\n    logb_lt_iff_lt_rpow hD (mul_pos two_pos hx), \u2190 sub_eq_neg_add, \u2190 neg_sub i 1, \u2190 inv_mul',\n    \u2190 inv_mul', inv_lt_inv\u2080 (D_pow0 hD _) (mul_pos two_pos hx), Int.cast_neg, Int.cast_sub,\n    Int.cast_one, rpow_neg (D0 hD).le, inv_lt_inv\u2080 (four_x0 hx) (D_pow0 hD _), and_comm]\n\nlemma psi_ne_zero_iff {x : \u211d} (hx : 0 < x) :\n    \u03c8 D (D ^ (-s) * x) \u2260 0 \u2194 s \u2208 nonzeroS D x := by\n  rw [\u2190 mem_support, support_\u03c8 (by exact_mod_cast hD), mem_nonzeroS_iff hD hx]\n\nlemma psi_eq_zero_iff {x : \u211d} (hx : 0 < x) : \u03c8 D (D ^ (-s) * x) = 0 \u2194 s \u2209 nonzeroS D x := by\n  rw [\u2190 iff_not_comm, \u2190 psi_ne_zero_iff hD hx]\n\nlemma support_\u03c8S (hx : 0 < x) : support (fun (s : \u2124) \u21a6 \u03c8 D (D ^ (-s) * x)) = nonzeroS D x := by\n  ext; rw [mem_support]; exact psi_ne_zero_iff hD hx\n\nlemma support_\u03c8S_subset_Icc {b c : \u2124} {x : \u211d}\n    (h : x \u2208 Icc ((D : \u211d) ^ (b - 1) / 2) (D ^ c / 4)) :\n    support (fun (s : \u2124) \u21a6 \u03c8 D (D ^ (-s) * x)) \u2286 Icc b c := by\n  intro i hi\n  have hx : x > 0 := lt_of_lt_of_le (by positivity) h.1\n  simp only [support_\u03c8S hD hx, nonzeroS, Finset.coe_Icc, mem_Icc] at hi\n  simp only [toFinset_Icc, Finset.coe_Icc, mem_Icc]\n  refine \u27e8le_trans ?_ hi.1, le_trans hi.2 ?_\u27e9\n  \u00b7 rw [\u2190 Nat.cast_one, Int.floor_nat_add, Nat.cast_one, \u2190 sub_le_iff_le_add', Int.le_floor,\n      Real.le_logb_iff_rpow_le hD (mul_pos two_pos hx), mul_comm]\n    exact_mod_cast (div_le_iff\u2080 two_pos).mp h.1\n  \u00b7 rw [Int.ceil_le, Real.logb_le_iff_le_rpow hD (mul_pos four_pos hx), mul_comm]\n    exact_mod_cast (le_div_iff\u2080 four_pos).mp h.2\n\nlemma finsum_\u03c8 (hx : 0 < x) : \u2211\u1da0 s : \u2124, \u03c8 D (D ^ (-s) * x) = 1 := by\n  refine Eq.trans ?_ (sum_\u03c8 hD hx)\n  apply Eq.trans <| finsum_eq_sum _ <| support_\u03c8S hD hx \u25b8 Finset.finite_toSet (nonzeroS D x)\n  congr\n  ext\n  rw [Finite.mem_toFinset, support_\u03c8S hD hx, Finset.mem_coe]\n\nlemma sum_\u03c8_le (S : Finset \u2124) (hx : 0 < x) : \u2211 s \u2208 S, \u03c8 D (D ^ (-s) * x) \u2264 1 := calc\n  _ = \u2211 s \u2208 S \u2229 (nonzeroS D x), \u03c8 D (D ^ (-s) * x) := by\n    refine (Finset.sum_subset Finset.inter_subset_left (fun s sS hs \u21a6 ?_)).symm\n    exact (psi_eq_zero_iff hD hx).mpr (fun h \u21a6 hs <| Finset.mem_inter.mpr \u27e8sS, h\u27e9)\n  _ \u2264 \u2211 s \u2208 nonzeroS D x, \u03c8 D (D ^ (-s) * x) :=\n    Finset.sum_le_sum_of_subset_of_nonneg Finset.inter_subset_right (fun _ _ _ \u21a6 zero_le_\u03c8 ..)\n  _ = 1 := sum_\u03c8 hD hx\n\nend include_hD\n\nend D\n\n\nopen Complex\n\nopen scoped ShortVariables\nvariable (X : Type*) {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102} {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X}\n  [PseudoMetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G]\nvariable {s : \u2124} {x y : X}\n\nsection -- Again, we start by recording some trivial inequalities that will be needed repeatedly.\ninclude q K \u03c3\u2081 \u03c3\u2082 F G\nprivate lemma a0' : a > 0 := by linarith [four_le_a X]\nprivate lemma a0 : (a : \u211d) > 0 := by exact_mod_cast (a0' X)\nprivate lemma D1 : (D : \u211d) > 1 := by norm_cast; norm_num; exact (a0' X).ne.symm\nprivate lemma D0' : (D : \u211d) > 0 := one_pos.trans (D1 X)\nprivate lemma D0'' : D > 0 := by exact_mod_cast (D0' X)\nprivate lemma Ds0 (s : \u2124) : (D : \u211d) ^ s > 0 := have := D0' X; by positivity\nend\n\nvariable {X}\n\n/-- K_s in the blueprint -/\n@[nolint unusedArguments]\ndef Ks [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] (s : \u2124) (x y : X) : \u2102 :=\n  K x y * \u03c8 (D ^ (-s) * dist x y)\n\nlemma Ks_def (s : \u2124) (x y : X) : Ks s x y = K x y * \u03c8 (D ^ (-s) * dist x y) := rfl\n\nlemma sum_Ks {t : Finset \u2124} (hs : nonzeroS D (dist x y) \u2286 t) (hD : 1 < (D : \u211d)) (h : 0 < dist x y) :\n    \u2211 i \u2208 t, Ks i x y = K x y := by\n  simp_rw [Ks, \u2190 Finset.mul_sum]\n  norm_cast\n  suffices \u2211 i \u2208 t, \u03c8 (D ^ (-i) * dist x y) = 1 by rw [this, ofReal_one, mul_one]\n  rw [\u2190 Finset.sum_subset hs, sum_\u03c8 hD h]\n  intros\n  rwa [psi_eq_zero_iff hD h]\n\n-- maybe this version is also useful?\n-- lemma sum_Ks' {t : Finset \u2124}\n--     (hs : \u2200 i : \u2124, (D ^ i * dist x y) \u2208 Ioo (4 * D)\u207b\u00b9 2\u207b\u00b9 \u2192 i \u2208 t)\n--     (hD : 1 < D) (h : x \u2260 y) : \u2211 i \u2208 t, Ks i x y = K x y := by\n--   sorry\n\nlemma dist_mem_Ioo_of_Ks_ne_zero {s : \u2124} {x y : X} (h : Ks s x y \u2260 0) :\n    dist x y \u2208 Ioo ((D ^ (s - 1) : \u211d) / 4) (D ^ s / 2) := by\n  simp only [Ks, Nat.cast_pow, Nat.cast_ofNat, zpow_neg, ne_eq, mul_eq_zero, ofReal_eq_zero] at h\n  have dist_mem_Ioo := support_\u03c8 (D1 X) \u25b8 mem_support.2 (not_or.1 h).2\n  rwa [mem_Ioo, \u2190 div_eq_inv_mul, lt_div_iff\u2080 (D_pow0' (D1 X) s),\n    div_lt_iff\u2080 (D_pow0' (D1 X) s), mul_inv, mul_assoc, inv_mul_eq_div (4 : \u211d), \u2190 zpow_neg_one,\n    \u2190 zpow_add\u2080 (D0' X).ne.symm, neg_add_eq_sub, \u2190 div_eq_inv_mul] at dist_mem_Ioo\n\nlemma dist_mem_Icc_of_Ks_ne_zero {s : \u2124} {x y : X} (h : Ks s x y \u2260 0) :\n    dist x y \u2208 Icc ((D ^ (s - 1) : \u211d) / 4) (D ^ s / 2) :=\n  Ioo_subset_Icc_self (dist_mem_Ioo_of_Ks_ne_zero h)\n\n/-- The constant appearing in part 2 of Lemma 2.1.3. -/\ndef C2_1_3 (a : \u211d\u22650) : \u211d\u22650 := 2 ^ (102 * (a : \u211d) ^ 3)\n/-- The constant appearing in part 3 of Lemma 2.1.3. -/\ndef D2_1_3 (a : \u211d\u22650) : \u211d\u22650 := 2 ^ (150 * (a : \u211d) ^ 3)\n\n--1.0.14.\nlemma kernel_bound {s : \u2124} {x y : X} :\n    \u2016Ks s x y\u2016\u208a \u2264 2 ^ a ^ 3 / volume.nnreal (ball x (dist x y)) := by\n  change \u2016K x y * \u03c8 (D ^ (-s) * dist x y)\u2016 \u2264 2 ^ a ^ 3 / volume.real (ball x (dist x y))\n  apply le_trans <| calc\n    \u2016K x y * \u03c8 (D ^ (-s) * dist x y)\u2016\n      = \u2016K x y\u2016 * \u2016(\u03c8 (D ^ (-s) * dist x y) : \u2102)\u2016 := norm_mul ..\n    _ \u2264 \u2016K x y\u2016 * 1               := by gcongr; rw [norm_eq_abs, abs_ofReal]; exact abs_\u03c8_le_one D _\n    _ \u2264 \u2016K x y\u2016                   := by rw [mul_one]\n  convert norm_K_le_vol_inv (K := K) x y\n  unfold C_K\n  norm_cast\n\nvariable (s)\n\n/-- Apply `volume_ball_two_le_same` `n` times. -/\nlemma DoublingMeasure.volume_ball_two_le_same_repeat (x : X) (r : \u211d) (n : \u2115) :\n    volume.real (ball x (2 ^ n * r)) \u2264 (defaultA a) ^ n * volume.real (ball x r) := by\n  induction' n with d ih; \u00b7 simp\n  rw [add_comm, pow_add, pow_one, mul_assoc]\n  apply (measure_real_ball_two_le_same x _).trans\n  have A_cast: (defaultA a : \u211d\u22650).toReal = (defaultA a : \u211d) := rfl\n  rwa [A_cast, pow_add, mul_assoc, pow_one, mul_le_mul_left (by positivity)]\n\n-- Special case of `DoublingMeasure.volume_ball_two_le_same_repeat` used to prove `div_vol_le`\nprivate lemma DoublingMeasure.volume_ball_two_le_same_repeat' (x : X) (n : \u2115) :\n    volume.real (ball x (2 ^ n * D ^ s)) \u2264\n    (defaultA a) ^ (2 + n + 100 * a ^ 2) * volume.real (ball x (D ^ (s - 1) / 4)) := by\n  convert volume_ball_two_le_same_repeat x (D ^ (s - 1) / 4) (2 + n + 100 * a ^ 2) using 3\n  rw [defaultD, zpow_sub\u2080 (by positivity), pow_add, pow_add]\n  field_simp\n  ring\n\nlemma Metric.measure_ball_pos_nnreal (x : X) (r : \u211d) (hr : r > 0) : volume.nnreal (ball x r) > 0 :=\n  ENNReal.toNNReal_pos (ne_of_gt (measure_ball_pos volume x hr)) (measure_ball_ne_top x _)\n\nlemma Metric.measure_ball_pos_real (x : X) (r : \u211d) (hr : r > 0) : volume.real (ball x r) > 0 :=\n  measure_ball_pos_nnreal x r hr\n\ninclude a q K \u03c3\u2081 \u03c3\u2082 F G in\nlemma K_eq_K_of_dist_eq_zero {x y y' : X} (hyy' : dist y y' = 0) :\n    K x y = K x y' := by\n  suffices \u2016K x y - K x y'\u2016 = 0 by rwa [norm_eq_abs, AbsoluteValue.map_sub_eq_zero_iff] at this\n  suffices \u2016K x y - K x y'\u2016 \u2264 0 from le_antisymm this (norm_nonneg (K x y - K x y'))\n  convert norm_K_sub_le (K := K) (x := x) (y := y) (y' := y')\n    (by simp only [hyy', mul_zero, dist_nonneg])\n  suffices (0 : \u211d) ^ (a : \u211d)\u207b\u00b9 = 0 by simp [hyy', this]\n  simp [inv_ne_zero (show (a : \u211d) \u2260 0 by norm_cast; linarith [four_le_a X])]\n\ninclude a q K \u03c3\u2081 \u03c3\u2082 F G in\nlemma K_eq_zero_of_dist_eq_zero {x y : X} (hxy : dist x y = 0) :\n    K x y = 0 :=\n  norm_le_zero_iff.1 (by simpa [hxy, Real.vol] using norm_K_le_vol_inv x y)\n\nvariable {s}\n\nprivate lemma div_vol_le {x y : X} {c : \u211d} (hc : c > 0) (hxy : dist x y \u2265 D ^ (s - 1) / 4)\n    (n : \u2115) : c / volume.real (ball x (dist x y)) \u2264\n    (2 ^ ((2 + n) * a + 100 * a ^ 3)) * c / volume.real (ball x (2 ^ n * D ^ s)) := by\n  have h : 0 \u2260 dist x y := (lt_of_lt_of_le (div_pos (defaultD_pow_pos a (s - 1)) four_pos) hxy).ne\n  have v0\u2081 := measure_ball_pos_nnreal x (dist x y) <| lt_of_le_of_ne dist_nonneg h\n  have v0\u2082 := measure_ball_pos_nnreal x (D ^ (s - 1) / 4) (by have := D0' X; positivity)\n  have v0\u2083 := measure_ball_pos_real x _ (mul_pos (pow_pos two_pos n) (defaultD_pow_pos a s))\n  have ball_subset := ball_subset_ball (x := x) hxy\n  apply le_trans <| (div_le_div_iff_of_pos_left hc v0\u2081 v0\u2082).2 <|\n    ENNReal.toNNReal_mono (measure_ball_ne_top x _) (OuterMeasureClass.measure_mono _ ball_subset)\n  dsimp only\n  rw [measureNNReal_val, div_le_div_iff\u2080 (by exact_mod_cast v0\u2082) v0\u2083]\n  apply le_of_le_of_eq <| (mul_le_mul_left hc).2 <|\n    DoublingMeasure.volume_ball_two_le_same_repeat' s x n\n  simp_rw [defaultA, \u2190 mul_assoc, mul_comm c]\n  rw_mod_cast [\u2190 pow_mul]\n  congr\n  ring\n\n-- Useful special case of `div_vol_le`\nprivate lemma div_vol_le\u2080 {x y : X} {c : \u211d} (hc : c > 0) (hK : Ks s x y \u2260 0) :\n    c / volume.real (ball x (dist x y)) \u2264\n    (2 ^ (2 * a + 100 * a ^ 3)) * c / volume.real (ball x (D ^ s)) := by\n  simpa using div_vol_le hc (mem_Icc.1 (dist_mem_Icc_of_Ks_ne_zero hK)).1 0\n\nlemma norm_K_le {s : \u2124} {x y : X} (n : \u2115) (hxy : dist x y \u2265 D ^ (s - 1) / 4) :\n    \u2016K x y\u2016 \u2264 2 ^ ((2 + n) * (a : \u211d) + 101 * a ^ 3) / volume.real (ball x (2 ^ n * D ^ s)) := by\n  by_cases h : dist x y = 0\n  \u00b7 rw [K_eq_zero_of_dist_eq_zero h, norm_zero]; positivity\n  apply (norm_K_le_vol_inv x y).trans\n  unfold C_K\n  apply le_trans (div_vol_le (by positivity) hxy n)\n  apply div_le_div_of_nonneg_right _ measureReal_nonneg\n  exact_mod_cast le_of_eq (by ring)\n\n", "theoremStatement": "lemma ennnorm_K_le {s : \u2124} {x y : X} (n : \u2115) (hxy : dist x y \u2265 D ^ (s - 1) / 4) :\n    \u2016K x y\u2016\u2091 \u2264 2 ^ ((2 + n) * (a : \u211d) + 101 * a ^ 3) / volume (ball x (2 ^ n * D ^ s)) ", "theoremName": "ennnorm_K_le", "fileCreated": {"commit": "743fbe4ea5741cd92c855e66055ba156f232beff", "date": "2024-06-16"}, "theoremCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "file": "carleson/Carleson/Psi.lean", "module": "Carleson.Psi", "jsonFile": "Carleson.Psi.jsonl", "positionMetadata": {"lineInFile": 463, "tokenPositionInFile": 21954, "theoremPositionInFile": 62}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 16, "numPremises": 153}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [\u2190 ENNReal.ofReal_ofNat 2, ENNReal.ofReal_rpow_of_pos two_pos]\n  rw [\u2190 ENNReal.ofReal_toReal (measure_ball_ne_top _ _)]\n  rw [\u2190 ENNReal.ofReal_div_of_pos, \u2190 Measure.real, \u2190 ofReal_norm]; swap\n  \u00b7 apply ENNReal.toReal_pos\n    \u00b7 refine (measure_ball_pos volume x ?_).ne.symm\n      exact mul_pos (pow_pos two_pos n) (defaultD_pow_pos a s)\n    \u00b7 apply measure_ball_ne_top x (2 ^ n * D ^ s)\n  rw [ENNReal.ofReal_le_ofReal_iff (by positivity)]\n  exact norm_K_le n hxy", "proofType": "tactic", "proofLengthLines": 9, "proofLengthTokens": 472}}
{"srcContext": "/-\nCopyright (c) 2024 James Sundstrom. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: James Sundstrom\n-/\nimport Mathlib.MeasureTheory.Constructions.BorelSpace.Metric\n\n/-!\n# Annulus\n\nIn this file we define an annulus in a pseudometric space `X` to be a set consisting of all `y`\nsuch that `dist x y` lies in an interval between `r` and `R`. An annulus is defined for each type\nof interval (`Ioo`, `Ioc`, etc.) with a parallel naming scheme, except that we do not define annuli\nfor `Iio` and `Ico`, as they would be balls.\n\nWe also define `EAnnulus` similarly using `edist` instead of `dist`.\n\n## Tags\n\nannulus, eannulus\n-/\n\nopen Set Metric ENNReal\n\nvariable {X : Type*} [PseudoMetricSpace X]\n\nnamespace Set\n\nnamespace Annulus\n\ndef oo (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d) := {y | dist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d) := {y | dist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d) := {y | dist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d) := {y | dist x y \u2208 Ici r}\n\nlemma oo_eq {x : X} {r R : \u211d} : oo x r R = ball x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oo, dist_comm, and_comm]\n\nlemma oc_eq {x : X} {r R : \u211d} : oc x r R = closedBall x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oc, dist_comm, and_comm]\n\nlemma co_eq {x : X} {r R : \u211d} : co x r R = ball x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [co, dist_comm, and_comm]\n\nlemma cc_eq {x : X} {r R : \u211d} : cc x r R = closedBall x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [cc, dist_comm, and_comm]\n\nlemma oi_eq {x : X} {r : \u211d} : oi x r = (closedBall x r)\u1d9c := by\n  ext; simp [oi, dist_comm]\n\nlemma ci_eq {x : X} {r : \u211d} : ci x r = (ball x r)\u1d9c := by\n  ext; simp [ci, dist_comm]\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : co x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma co_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : co x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\nlemma cc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : cc x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma cc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : cc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\n@[simp]\nlemma oc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    oc x r r' \u222a oo x r' R = oo x r R := by\n  ext; simp_rw [oc, oo, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioo_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    oc x r r' \u222a oc x r' R = oc x r R := by\n  ext; simp_rw [oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_co {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a co x r' R = oo x r R := by\n  ext; simp_rw [oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ico_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a cc x r' R = oc x r R := by\n  ext; simp_rw [oo, cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Icc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    cc x r r' \u222a oo x r' R = co x r R := by\n  ext; simp_rw [cc, oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioo_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    cc x r r' \u222a oc x r' R = cc x r R := by\n  ext; simp_rw [cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_co {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a co x r' R = co x r R := by\n  ext; simp_rw [co, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ico_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a cc x r' R = cc x r R := by\n  ext; simp_rw [co, cc, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Icc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : oc x r R \u222a oi x R = oi x r := by\n  ext; simp_rw [oc, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioi_eq_Ioi h]\n\n@[simp]\nlemma oo_union_ci {x : X} {r R : \u211d} (h : r < R) :\n    oo x r R \u222a ci x R = oi x r := by\n  ext; simp_rw [oo, ci, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ici_eq_Ioi h]\n\n@[simp]\nlemma cc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : cc x r R \u222a oi x R = ci x r := by\n  ext; simp_rw [cc, oi, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioi_eq_Ici h]\n\n@[simp]\nlemma co_union_ci {x : X} {r R : \u211d} (h : r \u2264 R) : co x r R \u222a ci x R = ci x r := by\n  ext; simp_rw [co, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ici_eq_Ici h]\n\n\nvariable [MeasurableSpace X] [OpensMeasurableSpace X]\n\n@[measurability]\nlemma measurableSet_oo {x : X} {r R : \u211d} : MeasurableSet (oo x r R) := by\n  rw [oo_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oc {x : X} {r R : \u211d} : MeasurableSet (oc x r R) := by\n rw [oc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_co {x : X} {r R : \u211d} : MeasurableSet (co x r R) := by\n  rw [co_eq]; measurability\n\n@[measurability]\nlemma measurableSet_cc {x : X} {r R : \u211d} : MeasurableSet (cc x r R) := by\n rw [cc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oi {x : X} {r : \u211d} : MeasurableSet (oi x r) := by\n  rw [oi_eq]; measurability\n\n@[measurability]\nlemma measurableSet_ci {x : X} {r : \u211d} : MeasurableSet (ci x r) := by\n  rw [ci_eq]; measurability\n\nend Annulus\n\nnamespace EAnnulus\n\ndef oo (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ici r}\n\n\nlemma oo_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oo x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oo x r R := by\n  simp_rw [oo, Annulus.oo, edist_dist, mem_Ioo, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma oc_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [oc, Annulus.oc, edist_dist, mem_Ioc, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  \u00b7 have R_le_r := (lt_of_lt_of_le (lt_of_not_ge hR) hr).le\n    rw [Annulus.oc_eq_empty R_le_r]\n    refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n    exact not_le_of_gt (lt_of_le_of_lt (ENNReal.ofReal_le_ofReal R_le_r) hy.1) hy.2\n\nlemma co_eq_annulus {x : X} {r R : \u211d} :\n    co x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.co x r R := by\n  simp_rw [co, Annulus.co, edist_dist, mem_Ico, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma cc_eq_annulus {x : X} {r R : \u211d} (h : r > 0 \u2228 R \u2265 0) :\n    cc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.cc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [cc, Annulus.cc, edist_dist, mem_Icc, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  have r0 := h.resolve_right hR\n  have R_lt_r := (lt_of_not_ge hR).trans r0\n  rw [Annulus.cc_eq_empty R_lt_r]\n  refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n  exact not_le_of_gt ((ENNReal.ofReal_lt_ofReal_iff r0).mpr R_lt_r) (hy.1.trans hy.2)\n\nlemma oi_eq_annulus {x : X} {r : \u211d} (hr : r \u2265 0) : oi x (ENNReal.ofReal r) = Annulus.oi x r := by\n  simp_rw [oi, Annulus.oi, edist_dist, mem_Ioi, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr]\n\nlemma ci_eq_annulus {x : X} {r : \u211d} : ci x (ENNReal.ofReal r) = Annulus.ci x r := by\n  simp_rw [ci, Annulus.ci, edist_dist, mem_Ici, ENNReal.ofReal_le_ofReal_iff dist_nonneg]\n\n\nlemma oo_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oo x r R = ball x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oo, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma oc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oc x r R = closedBall x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oc, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma co_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    co x r R = ball x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [co, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma cc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    cc x r R = closedBall x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [cc, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma oi_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : oi x r = (closedBall x r.toReal)\u1d9c := by\n  ext; simp [oi, edist_dist, dist_comm, lt_ofReal_iff_toReal_lt hr.ne]\n\nlemma ci_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : ci x r = (ball x r.toReal)\u1d9c := by\n  ext; simp [ci, edist_dist, dist_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg]\n\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n@[simp]\nlemma cc_top_eq_empty {x : X} {R : \u211d\u22650\u221e} : cc x \u22a4 R = \u2205 :=\n  eq_empty_of_forall_not_mem (fun y hy \u21a6 (edist_ne_top x y) (top_le_iff.mp hy.1))\n\n@[simp]\nlemma oi_eq_empty {x : X} : oi x \u22a4 = \u2205 := by simp [oi, edist_dist]\n\n@[simp]\nlemma ci_eq_empty {x : X} : ci x \u22a4 = \u2205 := by simp [ci, edist_dist]\n\n\nlemma oo_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) :\n    oo x r \u22a4 = (closedBall x r.toReal)\u1d9c := by\n  ext; simpa [oo, edist_dist, dist_comm] using lt_ofReal_iff_toReal_lt hr.ne\n\nlemma oc_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) :\n    oc x r \u22a4 = (closedBall x r.toReal)\u1d9c := by\n  ext; simpa [oc, edist_dist, dist_comm] using lt_ofReal_iff_toReal_lt hr.ne\n\nlemma co_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : co x r \u22a4 = (ball x r.toReal)\u1d9c := by\n  ext; simpa [co, edist_dist, dist_comm] using le_ofReal_iff_toReal_le hr.ne dist_nonneg\n\nlemma cc_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : cc x r \u22a4 = (ball x r.toReal)\u1d9c := by\n  ext; simpa [cc, edist_dist, dist_comm] using le_ofReal_iff_toReal_le hr.ne dist_nonneg\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\n", "theoremStatement": "lemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 ", "theoremName": "Set.EAnnulus.oc_subset_co", "fileCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "theoremCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "file": "carleson/Carleson/ToMathlib/Annulus.lean", "module": "Carleson.ToMathlib.Annulus", "jsonFile": "Carleson.ToMathlib.Annulus.jsonl", "positionMetadata": {"lineInFile": 398, "tokenPositionInFile": 15546, "theoremPositionInFile": 95}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 27}, "proofMetadata": {"hasProof": true, "proof": ":=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 64}}
{"srcContext": "import Carleson.Forest\nimport Carleson.ToMathlib.HardyLittlewood\nimport Carleson.ToMathlib.BoundedCompactSupport\nimport Carleson.ToMathlib.Misc\nimport Carleson.Psi\n\nopen ShortVariables TileStructure\nvariable {X : Type*} {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102} {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X}\n  [MetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] [TileStructure Q D \u03ba S o]\n  {n j j' : \u2115} {t : Forest X n} {u u\u2081 u\u2082 p : \ud835\udd13 X} {x x' : X} {\ud835\udd16 : Set (\ud835\udd13 X)}\n  {f f\u2081 f\u2082 g g\u2081 g\u2082 : X \u2192 \u2102} {I J J' L : Grid X}\nvariable {E' : Type*} [NormedAddCommGroup E'] [NormedSpace \u211d E']\n\nnoncomputable section\n\nopen Set MeasureTheory Metric Function Complex Bornology TileStructure Classical Filter\nopen scoped NNReal ENNReal ComplexConjugate\n\nnamespace TileStructure.Forest\n\n/-! ## Section 7.1 and Lemma 7.1.3 -/\n\nvariable (t) in\n/-- The definition `\u03c3(u, x)` given in Section 7.1.\nWe may assume `u \u2208 t` whenever proving things about this definition. -/\ndef \u03c3 (u : \ud835\udd13 X) (x : X) : Finset \u2124 := .image \ud835\udd30 { p | p \u2208 t u \u2227 x \u2208 E p }\n\nvariable (t) in\nprivate lemma exists_p_of_mem_\u03c3 (u : \ud835\udd13 X) (x : X) {s : \u2124} (hs : s \u2208 t.\u03c3 u x) :\n    \u2203 p \u2208 t.\ud835\udd17 u, x \u2208 E p \u2227 \ud835\udd30 p = s := by\n  have \u27e8p, hp\u27e9 := Finset.mem_image.mp hs\n  simp only [mem_\ud835\udd17, Finset.mem_filter] at hp\n  use p, hp.1.2.1, hp.1.2.2, hp.2\n\n/- \\overline{\u03c3} from the blueprint. -/\nvariable (t) in\ndef \u03c3Max (u : \ud835\udd13 X) (x : X) (h\u03c3 : (t.\u03c3 u x).Nonempty) : \u2124 :=\n  t.\u03c3 u x |>.max' h\u03c3\n\n/- \\underline{\u03c3} from the blueprint. -/\nvariable (t) in\ndef \u03c3Min (u : \ud835\udd13 X) (x : X) (h\u03c3 : (t.\u03c3 u x).Nonempty) : \u2124 :=\n  t.\u03c3 u x |>.min' h\u03c3\n\nvariable (t) in\nprivate lemma \u03c3Max_mem_\u03c3 (u : \ud835\udd13 X) (x : X) (h\u03c3 : (t.\u03c3 u x).Nonempty) : \u03c3Max t u x h\u03c3 \u2208 t.\u03c3 u x :=\n  (t.\u03c3 u x).max'_mem h\u03c3\n\n/-- The definition of `\ud835\udcd9\u2080(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcd9\u2080 (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {J : Grid X | s J = -S \u2228 \u2200 p \u2208 \ud835\udd16, \u00ac(\ud835\udcd8 p : Set X) \u2286 ball (c J) (100 * D ^ (s J + 1))}\n\n/-- The definition of `\ud835\udcd9(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcd9 (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {x | Maximal (\u00b7 \u2208 \ud835\udcd9\u2080 \ud835\udd16) x}\n\nlemma \ud835\udcd9_subset_\ud835\udcd9\u2080 {\ud835\udd16 : Set (\ud835\udd13 X)} : \ud835\udcd9 \ud835\udd16 \u2286 \ud835\udcd9\u2080 \ud835\udd16 := sep_subset ..\n\nlemma pairwiseDisjoint_\ud835\udcd9 : (\ud835\udcd9 \ud835\udd16).PairwiseDisjoint (fun I \u21a6 (I : Set X)) := fun I mI J mJ hn \u21a6 by\n  have : IsAntichain (\u00b7 \u2264 \u00b7) (\ud835\udcd9 \ud835\udd16) := setOf_maximal_antichain _\n  exact (le_or_ge_or_disjoint.resolve_left (this mI mJ hn)).resolve_left (this mJ mI hn.symm)\n\n/-- The definition of `\ud835\udcdb\u2080(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcdb\u2080 (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {L : Grid X | s L = -S \u2228 (\u2203 p \u2208 \ud835\udd16, L \u2264 \ud835\udcd8 p) \u2227 \u2200 p \u2208 \ud835\udd16, \u00ac\ud835\udcd8 p \u2264 L}\n\n/-- The definition of `\ud835\udcdb(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcdb (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {x | Maximal (\u00b7 \u2208 \ud835\udcdb\u2080 \ud835\udd16) x}\n\nlemma \ud835\udcdb_subset_\ud835\udcdb\u2080 {\ud835\udd16 : Set (\ud835\udd13 X)} : \ud835\udcdb \ud835\udd16 \u2286 \ud835\udcdb\u2080 \ud835\udd16 := sep_subset ..\n\nprivate lemma s_le_s_of_mem_\ud835\udcdb {\ud835\udd16 : Set (\ud835\udd13 X)} {L : Grid X} (hL : L \u2208 \ud835\udcdb \ud835\udd16)\n    {p : \ud835\udd13 X} (hp : p \u2208 \ud835\udd16) (hpL : \u00ac Disjoint (\ud835\udcd8 p : Set X) (L : Set X)) : s L \u2264 s (\ud835\udcd8 p) := by\n  simp only [\ud835\udcdb, \ud835\udcdb\u2080, Grid.le_def, not_and, not_le, and_imp] at hL\n  rcases hL.1 with h | h\n  \u00b7 exact h \u25b8 (range_s_subset \u27e8\ud835\udcd8 p, rfl\u27e9).1\n  \u00b7 by_contra!\n    exact lt_asymm this <| h.2 p hp <| (GridStructure.fundamental_dyadic' this.le).resolve_right hpL\n\nprivate lemma subset_of_mem_\ud835\udcdb {\ud835\udd16 : Set (\ud835\udd13 X)} {L : Grid X} (hL : L \u2208 \ud835\udcdb \ud835\udd16) {p : \ud835\udd13 X}\n    (hp : p \u2208 \ud835\udd16) (hpL : \u00ac Disjoint (\ud835\udcd8 p : Set X) (L : Set X)) : (L : Set X) \u2286 (\ud835\udcd8 p : Set X) :=\n  GridStructure.fundamental_dyadic' (s_le_s_of_mem_\ud835\udcdb hL hp hpL) |>.resolve_right fun h \u21a6 hpL h.symm\n\n/-- The projection operator `P_\ud835\udcd2 f(x)`, given above Lemma 7.1.3.\nIn lemmas the `c` will be pairwise disjoint on `C`. -/\ndef approxOnCube (C : Set (Grid X)) (f : X \u2192 E') (x : X) : E' :=\n  \u2211 J \u2208 { p | p \u2208 C }, (J : Set X).indicator (fun _ \u21a6 \u2a0d y in J, f y) x\n\nlemma stronglyMeasurable_approxOnCube (C : Set (Grid X)) (f : X \u2192 E') :\n    StronglyMeasurable (approxOnCube (X := X) (K := K) C f) :=\n  Finset.stronglyMeasurable_sum _ (fun _ _ \u21a6 stronglyMeasurable_const.indicator coeGrid_measurable)\n\nlemma integrable_approxOnCube (C : Set (Grid X)) {f : X \u2192 E'} : Integrable (approxOnCube C f) := by\n  refine integrable_finset_sum _ (fun i hi \u21a6 ?_)\n  constructor\n  \u00b7 exact (aestronglyMeasurable_indicator_iff coeGrid_measurable).mpr aestronglyMeasurable_const\n  \u00b7 simp_rw [hasFiniteIntegral_iff_enorm, enorm_indicator_eq_indicator_enorm]\n    apply lt_of_le_of_lt <| lintegral_indicator_const_le (i : Set X) _\n    exact ENNReal.mul_lt_top ENNReal.coe_lt_top volume_coeGrid_lt_top\n\nlemma approxOnCube_nonneg {C : Set (Grid X)} {f : X \u2192 \u211d} (hf : \u2200 (y : X), f y \u2265 0) {x : X} :\n    approxOnCube C f x \u2265 0 :=\n  Finset.sum_nonneg' (fun _ \u21a6 Set.indicator_nonneg (fun _ _ \u21a6 integral_nonneg hf) _)\n\nlemma approxOnCube_apply {C : Set (Grid X)} (hC : C.PairwiseDisjoint (fun I \u21a6 (I : Set X)))\n    (f : X \u2192 E') {x : X} {J : Grid X} (hJ : J \u2208 C) (xJ : x \u2208 J) :\n    (approxOnCube C f) x = \u2a0d y in J, f y := by\n  rw [approxOnCube, \u2190 Finset.sum_filter_not_add_sum_filter _ (J = \u00b7)]\n  have eq0 : \u2211 i \u2208 Finset.filter (\u00ac J = \u00b7) (Finset.univ.filter (\u00b7 \u2208 C)),\n      (i : Set X).indicator (fun _ \u21a6 \u2a0d y in i, f y) x = 0 := by\n    suffices \u2200 i \u2208 (Finset.univ.filter (\u00b7 \u2208 C)).filter (\u00ac J = \u00b7),\n      (i : Set X).indicator (fun _ \u21a6 \u2a0d y in i, f y) x = 0 by simp [Finset.sum_congr rfl this]\n    intro i hi\n    simp only [Finset.mem_filter, Finset.mem_univ, true_and] at hi\n    apply indicator_of_not_mem <|\n      Set.disjoint_left.mp ((hC.eq_or_disjoint hJ hi.1).resolve_left hi.2) xJ\n  have eq_ave : \u2211 i \u2208 (Finset.univ.filter (\u00b7 \u2208 C)).filter (J = \u00b7),\n      (i : Set X).indicator (fun _ \u21a6 \u2a0d y in i, f y) x = \u2a0d y in J, f y := by\n    suffices (Finset.univ.filter (\u00b7 \u2208 C)).filter (J = \u00b7) = {J} by simp [this, xJ, \u2190 Grid.mem_def]\n    exact subset_antisymm (fun _ h \u21a6 Finset.mem_singleton.mpr (Finset.mem_filter.mp h).2.symm)\n      (fun _ h \u21a6 by simp [Finset.mem_singleton.mp h, hJ])\n  rw [eq0, eq_ave, zero_add]\n\nlemma boundedCompactSupport_approxOnCube {\ud835\udd5c : Type*} [RCLike \ud835\udd5c] {C : Set (Grid X)} {f : X \u2192 \ud835\udd5c} :\n    BoundedCompactSupport (approxOnCube C f) :=\n  BoundedCompactSupport.finset_sum fun J hJ \u21a6\n    BoundedCompactSupport.indicator_of_isBounded_range (by simp) stronglyMeasurable_const\n    ((isBounded_iff_subset_ball (c J)).mpr \u27e84 * D ^ s J, Grid_subset_ball\u27e9) coeGrid_measurable\n\n-- Used in the proof of Lemma 7.1.6\nlemma integral_eq_lintegral_approxOnCube {C : Set (Grid X)}\n    (hC : C.PairwiseDisjoint fun I \u21a6 (I : Set X)) {J : Grid X} (hJ : J \u2208 C) {f : X \u2192 \u2102}\n    (hf : BoundedCompactSupport f) : ENNReal.ofReal (\u222b y in J, \u2016f y\u2016) =\n    \u222b\u207b (y : X) in J, \u2016approxOnCube C (fun x \u21a6 (\u2016f x\u2016 : \u2102)) y\u2016\u208a := by\n  have nonneg : 0 \u2264\u1da0[ae (volume.restrict J)] fun y \u21a6 \u2016f y\u2016 := Filter.Eventually.of_forall (by simp)\n  have vol_J_ne_zero := (volume_coeGrid_pos (X := X) (i := J) (defaultD_pos' a)).ne.symm\n  have eq : \u222b\u207b (y : X) in J, \u2016approxOnCube C (fun x \u21a6 (\u2016f x\u2016 : \u2102)) y\u2016\u208a =\n      \u222b\u207b y in (J : Set X), ENNReal.ofReal (\u2a0d z in J, \u2016f z\u2016) := by\n    refine setLIntegral_congr_fun coeGrid_measurable (Filter.Eventually.of_forall fun y hy \u21a6 ?_)\n    rw [approxOnCube_apply hC _ hJ hy, ENNReal.ofReal]\n    \u00b7 apply congrArg\n      have : \u2016\u2a0d y in J, (\u2016f y\u2016 : \u2102)\u2016\u208a = \u2016\u2a0d y in J, \u2016f y\u2016\u2016\u208a := by\n        convert congrArg (\u2016\u00b7\u2016\u208a) <| integral_ofReal (f := (\u2016f \u00b7\u2016)) using 1\n        simp [average]\n      exact this \u25b8 (Real.toNNReal_eq_nnnorm_of_nonneg <| integral_nonneg (fun y \u21a6 by simp)).symm\n  rw [ofReal_integral_eq_lintegral_ofReal hf.integrable.norm.restrict nonneg,\n    eq, lintegral_const, average_eq, smul_eq_mul, ENNReal.ofReal_mul, ENNReal.ofReal_inv_of_pos,\n    ENNReal.ofReal_toReal, ofReal_integral_eq_lintegral_ofReal hf.norm.integrable nonneg, mul_comm,\n    \u2190 mul_assoc, Measure.restrict_apply MeasurableSet.univ, univ_inter,\n    ENNReal.mul_inv_cancel vol_J_ne_zero volume_coeGrid_lt_top.ne, one_mul]\n  \u00b7 simp [volume_coeGrid_lt_top.ne]\n  \u00b7 simpa using ENNReal.toReal_pos vol_J_ne_zero volume_coeGrid_lt_top.ne\n  \u00b7 exact inv_nonneg.mpr ENNReal.toReal_nonneg\n\nlemma approxOnCube_ofReal (C : Set (Grid X)) (f : X \u2192 \u211d) (x : X) :\n    approxOnCube C (Complex.ofReal <| f \u00b7) x = Complex.ofReal (approxOnCube C f x) := by\n  simp_rw [approxOnCube, ofReal_sum]\n  refine Finset.sum_congr rfl (fun J _ \u21a6 ?_)\n  by_cases hx : x \u2208 (J : Set X)\n  \u00b7 simpa only [indicator_of_mem hx] using integral_ofReal\n  \u00b7 simp only [indicator_of_not_mem hx, ofReal_zero]\n\nlemma norm_approxOnCube_le_approxOnCube_norm {C : Set (Grid X)} {f : X \u2192 E'} {x : X} :\n    \u2016approxOnCube C f x\u2016 \u2264 approxOnCube C (\u2016f \u00b7\u2016) x := by\n  refine (norm_sum_le _ _).trans <| Finset.sum_le_sum (fun J hJ \u21a6 ?_)\n  rw [norm_indicator_eq_indicator_norm]\n  gcongr\n  apply norm_integral_le_integral_norm\n\n/-- The definition `I_i(x)`, given above Lemma 7.1.3.\nThe cube of scale `s` that contains `x`. There is at most 1 such cube, if it exists. -/\ndef cubeOf (i : \u2124) (x : X) : Grid X :=\n  Classical.epsilon (fun I \u21a6 x \u2208 I \u2227 s I = i)\n\nlemma cubeOf_spec {i : \u2124} (hi : i \u2208 Icc (-S : \u2124) S) (I : Grid X) {x : X} (hx : x \u2208 I) :\n    x \u2208 cubeOf i x \u2227 s (cubeOf i x) = i := by\n  apply epsilon_spec (p := fun I \u21a6 x \u2208 I \u2227 s I = i)\n  by_cases hiS : i = S\n  \u00b7 use topCube, subset_topCube hx, hiS \u25b8 s_topCube\n  simpa [and_comm] using Set.mem_iUnion\u2082.mp <| Grid_subset_biUnion i\n    \u27e8hi.1, s_topCube (X := X) \u25b8 lt_of_le_of_ne hi.2 hiS\u27e9 (subset_topCube hx)\n\n/-- The definition `T_\ud835\udcdd^\u03b8 f(x)`, given in (7.1.3).\nFor convenience, the suprema are written a bit differently than in the blueprint\n(avoiding `cubeOf`), but this should be equivalent.\nThis is `0` if `x` doesn't lie in a cube. -/\ndef nontangentialMaximalFunction (\u03b8 : \u0398 X) (f : X \u2192 \u2102) (x : X) : \u211d\u22650\u221e :=\n  \u2a06 (I : Grid X) (_ : x \u2208 I) (x' \u2208 I) (s\u2082 \u2208 Icc (s I) S)\n  (_ : ENNReal.ofReal (D ^ (s\u2082 - 1)) \u2264 upperRadius Q \u03b8 x'),\n  \u2016\u2211 i \u2208 Icc (s I) s\u2082, \u222b y, Ks i x' y * f y\u2016\u208a\n\nprotected theorem MeasureTheory.Measurable.nontangentialMaximalFunction {\u03b8 : \u0398 X} {f : X \u2192 \u2102} :\n    Measurable (nontangentialMaximalFunction \u03b8 f) := by\n  refine Measurable.iSup (fun I \u21a6 ?_)\n  let c := \u2a06 x' \u2208 I, \u2a06 s\u2082 \u2208 Icc (s I) S, \u2a06 (_ : ENNReal.ofReal (D ^ (s\u2082 - 1)) \u2264 upperRadius Q \u03b8 x'),\n    (\u2016\u2211 i \u2208 (Icc (s I) s\u2082), \u222b (y : X), Ks i x' y * f y\u2016\u208a : ENNReal)\n  have : (fun x \u21a6 \u2a06 (_ : x \u2208 I), c) = fun x \u21a6 ite (x \u2208 I) c 0 := by\n    ext x; by_cases hx : x \u2208 I <;> simp [hx]\n  convert (measurable_const.ite coeGrid_measurable measurable_const) using 1\n\n-- Set used in definition of `boundaryOperator`\nvariable (t) (u) in private def \ud835\udcd9' (x : X) (i : \u2124) : Finset (Grid X) :=\n  { J | J \u2208 \ud835\udcd9 (t u) \u2227 (J : Set X) \u2286 ball x (16 * D ^ i) \u2227 s J \u2264 i }\n\nprivate lemma mem_\ud835\udcd9_of_mem_\ud835\udcd9' {x : X} {i : \u2124} {J : Grid X} : J \u2208 \ud835\udcd9' t u x i \u2192 J \u2208 \ud835\udcd9 (t u) := by\n  intro hJ\n  simp only [\ud835\udcd9', Finset.mem_filter] at hJ\n  exact hJ.2.1\n\nvariable (t) in\n/-- The operator `S_{1,\ud835\udd32} f(x)`, given in (7.1.4). -/\ndef boundaryOperator (u : \ud835\udd13 X) (f : X \u2192 \u2102) (x : X) : \u211d\u22650\u221e :=\n  \u2211 I : Grid X, (I : Set X).indicator (x := x) fun _ \u21a6 \u2211 J \u2208 \ud835\udcd9' t u (c I) (s I),\n  D ^ ((s J - s I) / (a : \u211d)) / volume (ball (c I) (16 * D ^ (s I))) * \u222b\u207b y in (J : Set X), \u2016f y\u2016\u208a\n\nprotected theorem MeasureTheory.Measurable.boundaryOperator {u : \ud835\udd13 X} {f : X \u2192 \u2102} :\n    Measurable (t.boundaryOperator u f) := by\n  refine Finset.measurable_sum _ (fun I _ \u21a6 ?_)\n  exact (Finset.measurable_sum _ (fun J _ \u21a6 measurable_const)).indicator coeGrid_measurable\n\n-- Currently unused; uncomment if needed.\n/- lemma boundaryOperator_lt_top (hf : BoundedCompactSupport f) : t.boundaryOperator u f x < \u22a4 := by\n  refine ENNReal.sum_lt_top.mpr (fun I _ \u21a6 ?_)\n  by_cases hx : x \u2208 (I : Set X)\n  \u00b7 rw [indicator_of_mem hx]\n    refine ENNReal.sum_lt_top.mpr (fun J hJ \u21a6 ENNReal.mul_lt_top ?_ hf.integrable.integrableOn.2)\n    apply ENNReal.div_lt_top (by simp)\n    exact ne_of_gt <| measure_ball_pos volume _ <| mul_pos (by norm_num) (defaultD_pow_pos a (s I))\n  \u00b7 simp [hx] -/\n\n/-- The indexing set for the collection of balls \ud835\udcd1, defined above Lemma 7.1.3. -/\ndef \ud835\udcd1 : Set (\u2115 \u00d7 Grid X) := Icc 0 (S + 5) \u00d7\u02e2 univ\n\n/-- The center function for the collection of balls \ud835\udcd1. -/\ndef c\ud835\udcd1 (z : \u2115 \u00d7 Grid X) : X := c z.2\n\n/-- The radius function for the collection of balls \ud835\udcd1. -/\ndef r\ud835\udcd1 (z : \u2115 \u00d7 Grid X) : \u211d := 2 ^ z.1 * D ^ s z.2\n\nlemma \ud835\udcd1_finite : (\ud835\udcd1 (X := X)).Finite :=\n  finite_Icc .. |>.prod finite_univ\n\n/-- Lemma 7.1.1, freely translated. -/\nlemma convex_scales (hu : u \u2208 t) : OrdConnected (t.\u03c3 u x : Set \u2124) := by\n  rw [ordConnected_def]; intro i mi j mj k mk\n  simp_rw [Finset.mem_coe, \u03c3, Finset.mem_image, Finset.mem_filter, Finset.mem_univ,\n    true_and] at mi mj \u22a2\n  obtain \u27e8p, \u27e8mp, xp, Qxp, sxp\u27e9, sp\u27e9 := mi\n  obtain \u27e8p'', \u27e8mp'', xp'', Qxp'', sxp''\u27e9, sp''\u27e9 := mj\n  have ilj : i \u2264 j := nonempty_Icc.mp \u27e8k, mk\u27e9\n  rw [\u2190 sp, \u2190 sp''] at ilj mk\n  obtain \u27e8K, sK, lK, Kl\u27e9 := Grid.exists_sandwiched (le_of_mem_of_mem ilj xp xp'') k mk\n  have := range_subset_iff.mp (biUnion_\u03a9 (i := K)) x\n  simp_rw [mem_preimage, mem_singleton_iff, mem_iUnion, exists_prop] at this\n  obtain \u27e8(p' : \ud835\udd13 X), (\ud835\udcd8p' : \ud835\udcd8 p' = K), Qxp'\u27e9 := this\n  rw [\u2190 \ud835\udcd8p'] at lK Kl sK; refine \u27e8p', ?_, sK\u27e9\n  have l\u2081 : p \u2264 p' := \u27e8lK,\n    (relative_fundamental_dyadic lK).resolve_left (not_disjoint_iff.mpr \u27e8_, Qxp, Qxp'\u27e9)\u27e9\n  have l\u2082 : p' \u2264 p'' := \u27e8Kl,\n    (relative_fundamental_dyadic Kl).resolve_left (not_disjoint_iff.mpr \u27e8_, Qxp', Qxp''\u27e9)\u27e9\n  refine \u27e8(t.ordConnected hu).out mp mp'' \u27e8l\u2081, l\u2082\u27e9, \u27e8(Grid.le_def.mp lK).1 xp, Qxp', ?_\u27e9\u27e9\n  exact Icc_subset_Icc sxp.1 sxp''.2 \u27e8(Grid.le_def.mp lK).2, (Grid.le_def.mp Kl).2\u27e9\n\n/-- Part of Lemma 7.1.2 -/\n@[simp]\nlemma biUnion_\ud835\udcd9 : \u22c3 J \u2208 \ud835\udcd9 \ud835\udd16, J = \u22c3 I : Grid X, (I : Set X) := by\n  refine subset_antisymm (iUnion\u2082_subset_iUnion ..) fun x mx \u21a6 ?_\n  simp_rw [mem_iUnion] at mx \u22a2; obtain \u27e8I, mI\u27e9 := mx\n  obtain \u27e8J, sJ, mJ\u27e9 :=\n    Grid.exists_containing_subcube _ \u27e8le_rfl, scale_mem_Icc.1\u27e9 mI\n  have : J \u2208 (\ud835\udcd9\u2080 \ud835\udd16).toFinset := by rw [mem_toFinset]; left; exact sJ\n  obtain \u27e8M, lM, maxM\u27e9 := (\ud835\udcd9\u2080 \ud835\udd16).toFinset.exists_le_maximal this\n  simp_rw [mem_toFinset] at maxM\n  use M, maxM, (Grid.le_def.mp lM).1 mJ\n\n/-- Part of Lemma 7.1.2 -/\n@[simp]\nlemma biUnion_\ud835\udcdb : \u22c3 J \u2208 \ud835\udcdb \ud835\udd16, J = \u22c3 I : Grid X, (I : Set X) := by\n  refine subset_antisymm (iUnion\u2082_subset_iUnion ..) fun x mx \u21a6 ?_\n  simp_rw [mem_iUnion] at mx \u22a2; obtain \u27e8I, mI\u27e9 := mx\n  obtain \u27e8J, sJ, mJ\u27e9 :=\n    Grid.exists_containing_subcube _ \u27e8le_rfl, scale_mem_Icc.1\u27e9 mI\n  have : J \u2208 (\ud835\udcdb\u2080 \ud835\udd16).toFinset := by rw [mem_toFinset]; left; exact sJ\n  obtain \u27e8M, lM, maxM\u27e9 := (\ud835\udcdb\u2080 \ud835\udd16).toFinset.exists_le_maximal this\n  simp_rw [mem_toFinset] at maxM\n  use M, maxM, (Grid.le_def.mp lM).1 mJ\n\n/-- Part of Lemma 7.1.2 -/\nlemma pairwiseDisjoint_\ud835\udcdb : (\ud835\udcdb \ud835\udd16).PairwiseDisjoint (fun I \u21a6 (I : Set X)) := fun I mI J mJ hn \u21a6 by\n  have : IsAntichain (\u00b7 \u2264 \u00b7) (\ud835\udcdb \ud835\udd16) := setOf_maximal_antichain _\n  exact (le_or_ge_or_disjoint.resolve_left (this mI mJ hn)).resolve_left (this mJ mI hn.symm)\n\n/-- The constant used in `first_tree_pointwise`.\nHas value `10 * 2 ^ (104 * a ^ 3)` in the blueprint. -/\n-- Todo: define this recursively in terms of previous constants\nirreducible_def C7_1_4 (a : \u2115) : \u211d\u22650 := 10 * 2 ^ (104 * (a : \u211d) ^ 3)\n\n-- Used in the proof of `exp_sub_one_le`, which is used to prove Lemma 7.1.4\nprivate lemma exp_Lipschitz : LipschitzWith 1 (fun (t : \u211d) \u21a6 exp (.I * t)) := by\n  have mul_I : Differentiable \u211d fun (t : \u211d) \u21a6 I * t := Complex.ofRealCLM.differentiable.const_mul I\n  refine lipschitzWith_of_nnnorm_deriv_le mul_I.cexp (fun x \u21a6 ?_)\n  have : (fun (t : \u211d) \u21a6 cexp (I * t)) = cexp \u2218 (fun (t : \u211d) \u21a6 I * t) := rfl\n  rw [this, deriv_comp x differentiableAt_exp (mul_I x), Complex.deriv_exp, deriv_const_mul_field']\n  simp_rw [show deriv ofReal x = 1 from ofRealCLM.hasDerivAt.deriv, mul_one]\n  rw [nnnorm_mul, nnnorm_I, mul_one, \u2190 norm_toNNReal, mul_comm, Complex.norm_exp_ofReal_mul_I]\n  exact Real.toNNReal_one.le\n\n-- Used in the proof of Lemma 7.1.4\nprivate lemma exp_sub_one_le (t : \u211d) : \u2016exp (.I * t) - 1\u2016 \u2264 \u2016t\u2016 := by\n  simpa [enorm_eq_nnnorm] using exp_Lipschitz t 0\n\n-- Used in the proofs of Lemmas 7.1.4 and 7.1.5\nprivate lemma dist_lt_5 (hu : u \u2208 t) (mp : p \u2208 t.\ud835\udd17 u) (Qxp : Q x \u2208 \u03a9 p) :\n    dist_(p) (\ud835\udcac u) (Q x) < 5 := calc\n  _ \u2264 dist_(p) (\ud835\udcac u) (\ud835\udcac p) + dist_(p) (Q x) (\ud835\udcac p) := dist_triangle_right ..\n  _ < 4 + 1 :=\n    add_lt_add ((t.smul_four_le hu mp).2 (by convert mem_ball_self zero_lt_one)) (subset_cball Qxp)\n  _ = 5 := by norm_num\n\n-- The bound in the third display in the proof of Lemma 7.1.4\nprivate lemma L7_1_4_bound (hu : u \u2208 t) {s : \u2124} (hs : s \u2208 t.\u03c3 u x) {y : X} (hKxy : Ks s x y \u2260 0) :\n    \u2016exp (.I * (-\ud835\udcac u y + Q x y + \ud835\udcac u x - Q x x)) - 1\u2016 \u2264\n    5 * 2 ^ (4 * a) * 2 ^ (s - \u03c3Max t u x \u27e8s, hs\u27e9) :=\n  have \u27e8p\u209b, pu, xp\u209b, hp\u209b\u27e9 := t.exists_p_of_mem_\u03c3 u x hs\n  have \u27e8p', p'u, xp', hp'\u27e9 := t.exists_p_of_mem_\u03c3 u x (t.\u03c3Max_mem_\u03c3 u x \u27e8s, hs\u27e9)\n  have hr : (D : \u211d) ^ s / 2 > 0 := by rw [defaultD]; positivity\n  have s_le : GridStructure.s (\ud835\udcd8 p\u209b) \u2264 GridStructure.s (\ud835\udcd8 p') := by convert (\u03c3 t u x).le_max' s hs\n  have exp_bound :\n      \u2016exp (.I * (- \ud835\udcac u y + Q x y + \ud835\udcac u x - Q x x)) - 1\u2016 \u2264 \u2016\ud835\udcac u y - Q x y - \ud835\udcac u x + Q x x\u2016 := by\n    convert exp_sub_one_le (- \ud835\udcac u y + Q x y + \ud835\udcac u x - Q x x) using 1\n    \u00b7 simp\n    \u00b7 rw [\u2190 norm_neg]; ring_nf\n  have : dist_(p\u209b) (\ud835\udcac u) (Q x) \u2264 2 ^ (s - \u03c3Max t u x \u27e8s, hs\u27e9) * dist_(p') (\ud835\udcac u) (Q x) := by\n    have p\u209b_le_p' : \ud835\udcd8 p\u209b \u2264 \ud835\udcd8 p' := le_of_mem_of_mem s_le xp\u209b.1 xp'.1\n    have sub_ge_0 : t.\u03c3Max u x \u27e8s, hs\u27e9 - s \u2265 0 := by unfold \u03c3Max; linarith [(\u03c3 t u x).le_max' s hs]\n    have : GridStructure.s (\ud835\udcd8 p\u209b) + (\u03c3Max t u x \u27e8s, hs\u27e9 - s) = GridStructure.s (\ud835\udcd8 p') := by\n      simp_rw [\u2190 hp', \u2190 hp\u209b, \ud835\udd30, _root_.s]; ring\n    apply le_trans <| Grid.dist_strictMono_iterate' sub_ge_0 p\u209b_le_p' this\n    gcongr\n    calc  C2_1_2 a ^ (t.\u03c3Max u x \u27e8s, hs\u27e9 - s)\n      _ \u2264 C2_1_2 a ^ (t.\u03c3Max u x \u27e8s, hs\u27e9 - s : \u211d)                     := by norm_cast\n      _ \u2264 (1 / 2 : \u211d) ^ (t.\u03c3Max u x \u27e8s, hs\u27e9 - s : \u211d)                  :=\n        Real.rpow_le_rpow (by rw [C2_1_2]; positivity)\n          ((C2_1_2_le_inv_512 X).trans (by norm_num)) (by norm_cast)\n      _ = 2 ^ (s - \u03c3Max t u x \u27e8s, hs\u27e9)                                := by simp [\u2190 Int.cast_sub]\n  calc \u2016exp (.I * (-\ud835\udcac u y + Q x y + \ud835\udcac u x - Q x x)) - 1\u2016\n    _ \u2264 dist_{x, D ^ s / 2} (\ud835\udcac u) (Q x) :=\n      exp_bound.trans <| oscillation_le_cdist x _ (\ud835\udcac u) (Q x)\n        (mem_ball_comm.mp (mem_Ioo.mp (dist_mem_Ioo_of_Ks_ne_zero hKxy)).2) (mem_ball_self hr)\n    _ \u2264 _ := cdist_mono <| ball_subset_ball (show (D : \u211d) ^ s / 2 \u2264 4 * D ^ s by linarith)\n    _ \u2264 defaultA a * dist_{\ud835\udd20 p\u209b, 2 * D ^ s} (\ud835\udcac u) (Q x) := by\n      have two_mul_two : 2 * (2 * (D : \u211d) ^ s) = 4 * D ^ s := by ring\n      have x_in_ball : dist (\ud835\udd20 p\u209b) x < 2 * (2 * D ^ s) := by\n        rw [two_mul_two, \u2190 hp\u209b]\n        exact mem_ball'.mp <| Grid_subset_ball xp\u209b.1\n      refine le_of_eq_of_le ?_ (cdist_le x_in_ball)\n      rw [two_mul_two]\n    _ \u2264 defaultA a * (defaultA a ^ 3 * dist_(p\u209b) (\ud835\udcac u) (Q x)) := by\n      gcongr\n      convert cdist_le_iterate (div_pos (defaultD_pow_pos a s) four_pos) _ _ _ using 2\n      \u00b7 rw [show 2 ^ 3 * ((D : \u211d) ^ s / 4) = 2 * D ^ s by ring]\n      \u00b7 rw [hp\u209b]\n    _ = (defaultA a) ^ 4 * dist_(p\u209b) (\ud835\udcac u) (Q x) := by ring\n    _ \u2264 (2 ^ a) ^ 4 * (2 ^ (s - t.\u03c3Max u x _) * dist_(p') (\ud835\udcac u) (Q x)) := by norm_cast; gcongr\n    _ \u2264 (2 ^ a) ^ 4 * (2 ^ (s - t.\u03c3Max u x _) * 5) := by gcongr; exact (dist_lt_5 hu p'u xp'.2.1).le\n    _ = 5 * 2 ^ (4 * a) * 2 ^ (s - \u03c3Max t u x \u27e8s, hs\u27e9) := by ring\n\n-- The bound used implicitly in the fourth displayed inequality in the proof of Lemma 7.1.4\nvariable (f) in\nprivate lemma L7_1_4_integrand_bound (hu : u \u2208 t) {s : \u2124} (hs : s \u2208 t.\u03c3 u x) (y : X) :\n    \u2016(exp (.I * (- \ud835\udcac u y + Q x y + \ud835\udcac u x - Q x x)) - 1) * Ks s x y * f y\u2016 \u2264\n    5 * 2^(s - \u03c3Max t u x \u27e8s, hs\u27e9) * (2^(103 * a ^ 3) / volume.real (ball x (D ^ s))) * \u2016f y\u2016 := by\n  by_cases hKxy : Ks s x y = 0\n  \u00b7 rw [hKxy, mul_zero, zero_mul, norm_zero]; positivity\n  \u00b7 rw [norm_mul, norm_mul]\n    refine mul_le_mul_of_nonneg_right ?_ (norm_nonneg (f y))\n    apply mul_le_mul (L7_1_4_bound hu hs hKxy) norm_Ks_le (norm_nonneg _) (by positivity) |>.trans\n    rw [mul_assoc 5, mul_comm (2 ^ (4 * a)), \u2190 mul_assoc, mul_assoc, mul_div, C2_1_3]\n    gcongr\n    norm_cast\n    rw_mod_cast [\u2190 pow_add]\n    refine Nat.pow_le_pow_of_le_right two_pos <| Nat.add_le_of_le_sub ?_ ?_\n    \u00b7 exact Nat.mul_le_mul_right _ (by norm_num)\n    \u00b7 rw [\u2190 Nat.sub_mul, (show a ^ 3 = a ^ 2 * a from rfl)]; nlinarith [four_le_a X]\n\n-- The geometric sum used to prove `L7_1_4_sum`\nprivate lemma sum_pow_two_le (a b : \u2124) : \u2211 s \u2208 Finset.Icc a b, (2 : \u211d\u22650) ^ s \u2264 2 ^ (b + 1) := by\n  by_cases h : b < a\n  \u00b7 simp [Finset.Icc_eq_empty_of_lt h]\n  obtain \u27e8k, rfl\u27e9 : \u2203 (k : \u2115), b = a + k := \u27e8(b - a).toNat, by simp [not_lt.mp h]\u27e9\n  suffices \u2211 s \u2208 Finset.Icc a (a + k), (2 : \u211d\u22650) ^ s = 2 ^ a * \u2211 n \u2208 Finset.range (k + 1), 2 ^ n by\n    rw [this, add_assoc, zpow_add' (Or.inl two_ne_zero), mul_le_mul_left (zpow_pos two_pos a),\n      geom_sum_of_one_lt one_lt_two (k + 1), NNReal.sub_def (r := 2)]\n    norm_num\n    exact le_self_add\n  rw [Finset.mul_sum]\n  apply Finset.sum_bij (fun n hn \u21a6 (n - a).toNat)\n  \u00b7 intro n hn\n    rw [Finset.mem_Icc] at hn\n    rw [Finset.mem_range, Int.toNat_lt (Int.sub_nonneg.mpr hn.1), Nat.cast_add, Nat.cast_one]\n    linarith\n  \u00b7 intro n hn m hm hnm\n    rw [Finset.mem_Icc] at hn hm\n    simpa [Int.sub_nonneg.mpr hn.1, Int.sub_nonneg.mpr hm.1] using congrArg Int.ofNat hnm\n  \u00b7 exact fun n hn \u21a6 by use a + n, by simp [Nat.le_of_lt_succ (Finset.mem_range.mp hn)], by simp\n  \u00b7 intro n hn\n    rw [\u2190 zpow_natCast, Int.ofNat_toNat, \u2190 zpow_add' (Or.inl two_ne_zero),\n      sup_eq_left.mpr <| Int.sub_nonneg_of_le (Finset.mem_Icc.mp hn).1, add_sub_cancel]\n\n-- The sum used in the proof of Lemma 7.1.4\nprivate lemma L7_1_4_sum (h\u03c3 : (t.\u03c3 u x).Nonempty) :\n    \u2211 s \u2208 t.\u03c3 u x, (2 : \u211d\u22650) ^ (s - t.\u03c3Max u x h\u03c3) \u2264 2 := by\n  have {s : \u2124} : (2 : \u211d\u22650) ^ (s - t.\u03c3Max u x h\u03c3) = 2 ^ s * 2 ^ (- t.\u03c3Max u x h\u03c3) := by\n    rw [\u2190 zpow_add' (Or.inl two_ne_zero), Int.sub_eq_add_neg]\n  simp_rw [this, \u2190 Finset.sum_mul]\n  suffices \u2211 s \u2208 t.\u03c3 u x, (2 : \u211d\u22650) ^ s \u2264 2 ^ (t.\u03c3Max u x h\u03c3 + 1) from calc\n    _ \u2264 (2 : \u211d\u22650) ^ (t.\u03c3Max u x h\u03c3 + 1) * 2 ^ (-t.\u03c3Max u x h\u03c3) := by gcongr\n    _ = 2 := by rw [zpow_add' (Or.inl two_ne_zero)]; field_simp\n  refine le_trans (Finset.sum_le_sum_of_subset ?_) (sum_pow_two_le (t.\u03c3Min u x h\u03c3) (t.\u03c3Max u x h\u03c3))\n  exact fun s hs \u21a6 Finset.mem_Icc.mpr <| \u27e8(t.\u03c3 u x).min'_le s hs, (t.\u03c3 u x).le_max' s hs\u27e9\n\n-- Inequality used twice in the proof of Lemma 7.1.4\nprivate lemma L7_1_4_dist_le {p : \ud835\udd13 X} (xp : x \u2208 E p) {J : Grid X}\n    (hJ : ((J : Set X) \u2229 ball x (D ^ \ud835\udd30 p / 2)).Nonempty) :\n    dist (c J) (\ud835\udd20 p) \u2264 4 * D ^ (s J) + 4.5 * D ^ (\ud835\udd30 p) := by\n  have \u27e8z, hz\u27e9 := hJ\n  calc dist (c J) (\ud835\udd20 p)\n    _ \u2264 dist (c J) z + dist z x + dist x (\ud835\udd20 p)           := dist_triangle4 (c J) z x (\ud835\udd20 p)\n    _ \u2264 4 * D ^ (s J) + 0.5 * D ^ (\ud835\udd30 p) + 4 * D ^ (\ud835\udd30 p)  := by\n      apply add_le_add_three\n      \u00b7 exact (mem_ball'.mp <| Grid_subset_ball hz.1).le\n      \u00b7 convert (mem_ball.mp hz.2).le using 1\n        exact (eq_div_iff two_ne_zero).mpr (by linarith)\n      \u00b7 exact (mem_ball.mp <| Grid_subset_ball xp.1).le\n    _ \u2264 4 * D ^ (s J) + 4.5 * D ^ (\ud835\udd30 p)                  := by linarith [defaultD_pow_pos a (\ud835\udd30 p)]\n\n-- Inequality needed for the proof of `L7_1_4_integral_le_integral`\nprivate lemma s_le_s {p : \ud835\udd13 X} (pu : p \u2208 t.\ud835\udd17 u) (xp : x \u2208 E p)\n    {J : Grid X} (hJ : J \u2208 \ud835\udcd9 (t.\ud835\udd17 u) \u2227 ((J : Set X) \u2229 ball x (D ^ \ud835\udd30 p / 2)).Nonempty) :\n    s J \u2264 \ud835\udd30 p := by\n  have \u27e8z, hz\u27e9 := hJ.2\n  by_cases h : s J \u2264 \ud835\udd30 p \u2228 s J = -S\n  \u00b7 exact h.elim id (\u00b7 \u25b8 (range_s_subset \u27e8\ud835\udcd8 p, rfl\u27e9).1)\n  push_neg at h\n  apply False.elim \u2218 hJ.1.1.resolve_left h.2 p pu \u2218 le_trans Grid_subset_ball \u2218 ball_subset_ball'\n  have : (D : \u211d) ^ \ud835\udd30 p \u2264 D ^ s J := (zpow_le_zpow_iff_right\u2080 (one_lt_D (X := X))).mpr h.1.le\n  calc 4 * (D : \u211d) ^ GridStructure.s (\ud835\udcd8 p) + dist (GridStructure.c (\ud835\udcd8 p)) (c J)\n    _ \u2264 4 * (D : \u211d) ^ (s J) + (4 * D ^ (s J) + 4.5 * D ^ (s J)) := by\n      gcongr 4 * ?_ + ?_\n      \u00b7 exact this\n      \u00b7 exact dist_comm (c (\ud835\udcd8 p)) (c J) \u25b8 L7_1_4_dist_le xp hJ.2 |>.trans (by gcongr)\n    _ \u2264 100 * D ^ (s J + 1) := by\n      rw [zpow_add' (Or.inl (defaultD_pos a).ne.symm), zpow_one]\n      nlinarith [one_le_D (a := a), defaultD_pow_pos a (s J)]\n\nprivate lemma ball_covered_by_\ud835\udcd9 (hu : u \u2208 t) {p : \ud835\udd13 X} (pu : p \u2208 t u) (xp : x \u2208 E p) :\n    ball x (D ^ \ud835\udd30 p / 2) \u2286 \u22c3 J \u2208 \ud835\udcd9 (t.\ud835\udd17 u), (J : Set X) :=\n  calc ball x (D ^ \ud835\udd30 p / 2)\n    _ \u2286 ball x (4 * D ^ \ud835\udd30 p)          := ball_subset_ball <| by linarith [defaultD_pow_pos a (\ud835\udd30 p)]\n    _ \u2286 (\ud835\udcd8 u : Set X)                 := ball_subset_of_mem_\ud835\udcd8 hu pu xp.1\n    _ \u2286 \u22c3 (I : Grid X), (I : Set X)   := le_iSup _ _\n    _ = \u22c3 J \u2208 \ud835\udcd9 (t.\ud835\udd17 u), (J : Set X) := biUnion_\ud835\udcd9.symm\n\nprivate lemma Grid_subset_ball' {J : Grid X} {p : \ud835\udd13 X} (pu : p \u2208 t.\ud835\udd17 u) {x : X} (xp : x \u2208 E p)\n  (hJ : J \u2208 \ud835\udcd9 (t.\ud835\udd17 u) \u2227 (\u2191J \u2229 ball x (\u2191D ^ \ud835\udd30 p / 2)).Nonempty) :\n  (J : Set X) \u2286 ball (\ud835\udd20 p) (16 * \u2191D ^ \ud835\udd30 p) := by\n  have \u27e8z, hz\u27e9 := hJ.2\n  refine Grid_subset_ball.trans (ball_subset_ball' ?_)\n  change _ * _ ^ (s J) + dist (c J) _ \u2264 _\n  have := (zpow_le_zpow_iff_right\u2080 (one_lt_D (X := X))).mpr <| s_le_s pu xp hJ\n  linarith [L7_1_4_dist_le xp hJ.2, defaultD_pow_pos a (\ud835\udd30 p)]\n\n-- The integral bound needed for the proof of Lemma 7.1.4\nprivate lemma L7_1_4_integral_le_integral (hu : u \u2208 t) (hf : BoundedCompactSupport f) {p : \ud835\udd13 X}\n    (pu : p \u2208 t.\ud835\udd17 u) (xp : x \u2208 E p) : \u222b y in ball x ((D : \u211d) ^ (\ud835\udd30 p) / 2), \u2016f y\u2016 \u2264\n    \u222b y in ball (\ud835\udd20 p) (16 * (D : \u211d) ^ (\ud835\udd30 p)), \u2016approxOnCube (\ud835\udcd9 (t u)) (\u2016f \u00b7\u2016) y\u2016 := by\n  let Js := Set.toFinset { J \u2208 \ud835\udcd9 (t u) | ((J : Set X) \u2229 ball x (D ^ (\ud835\udd30 p) / 2)).Nonempty }\n  have mem_Js {J : Grid X} : J \u2208 Js \u2194 J \u2208 \ud835\udcd9 (t.\ud835\udd17 u) \u2227 (\u2191J \u2229 ball x (D ^ \ud835\udd30 p / 2)).Nonempty := by\n    simp [Js]\n  have Js_disj : (Js : Set (Grid X)).Pairwise (Disjoint on fun J \u21a6 (J : Set X)) :=\n    fun i\u2081 hi\u2081 i\u2082 hi\u2082 h \u21a6 pairwiseDisjoint_\ud835\udcd9 (mem_Js.mp hi\u2081).1 (mem_Js.mp hi\u2082).1 h\n  calc \u222b y in ball x (D ^ (\ud835\udd30 p) / 2), \u2016f y\u2016\n    _ \u2264 \u222b y in (\u22c3 J \u2208 Js, (J : Set X)), \u2016f y\u2016 := by\n      apply setIntegral_mono_set hf.integrable.norm.integrableOn (Eventually.of_forall (by simp))\n      have h := ball_covered_by_\ud835\udcd9 hu pu xp\n      refine ((subset_inter_iff.mpr \u27e8h, subset_refl _\u27e9).trans (fun y hy \u21a6 ?_)).eventuallyLE\n      have \u27e8J, hJ, yJ\u27e9 := Set.mem_iUnion\u2082.mp hy.1\n      exact \u27e8J, \u27e8\u27e8J, by simp [mem_Js.mpr \u27e8hJ, \u27e8y, mem_inter yJ hy.2\u27e9\u27e9]\u27e9, yJ\u27e9\u27e9\n    _ = \u2211 J \u2208 Js, \u222b y in J, \u2016f y\u2016 := by\n      apply integral_finset_biUnion Js (fun _ _ \u21a6 coeGrid_measurable) Js_disj\n      exact fun i hi \u21a6 hf.norm.integrable.integrableOn\n    _ = \u2211 J \u2208 Js, \u222b y in J, (approxOnCube (\ud835\udcd9 (t u)) (\u2016f \u00b7\u2016)) y := by\n      refine Finset.sum_congr rfl (fun J hJ \u21a6 ?_)\n      have eq : EqOn (approxOnCube (\ud835\udcd9 (t u)) (\u2016f \u00b7\u2016)) (fun _ \u21a6 \u2a0d y in J, \u2016f y\u2016) J :=\n        fun y hy \u21a6 approxOnCube_apply pairwiseDisjoint_\ud835\udcd9 (\u2016f \u00b7\u2016) (mem_Js.mp hJ).1 hy\n      rw [setIntegral_congr_fun coeGrid_measurable eq, setIntegral_const, average]\n      simp [\u2190 mul_assoc, CommGroupWithZero.mul_inv_cancel (volume (J : Set X)).toReal <|\n        ENNReal.toReal_ne_zero.mpr \u27e8(volume_coeGrid_pos _).ne.symm, volume_coeGrid_lt_top.ne\u27e9]\n    _ = \u222b y in (\u22c3 J \u2208 Js, (J : Set X)), (approxOnCube (\ud835\udcd9 (t u)) (\u2016f \u00b7\u2016)) y := by\n      refine integral_finset_biUnion Js (fun _ _ \u21a6 coeGrid_measurable) Js_disj ?_ |>.symm\n      exact fun i hi \u21a6 And.intro (stronglyMeasurable_approxOnCube _ _).aestronglyMeasurable\n        (integrable_approxOnCube (\ud835\udcd9 (t u))).restrict.hasFiniteIntegral\n    _ = \u222b y in (\u22c3 J \u2208 Js, (J : Set X)), \u2016(approxOnCube (\ud835\udcd9 (t u)) (\u2016f \u00b7\u2016)) y\u2016 :=\n      setIntegral_congr_fun (Js.measurableSet_biUnion fun _ _ \u21a6 coeGrid_measurable) <| fun y _ \u21a6\n        (Real.norm_of_nonneg <| approxOnCube_nonneg (fun _ \u21a6 norm_nonneg _)).symm\n    _ \u2264 \u222b y in ball (\ud835\udd20 p) (16 * (D : \u211d) ^ (\ud835\udd30 p)), \u2016approxOnCube (\ud835\udcd9 (t u)) (\u2016f \u00b7\u2016) y\u2016 := by\n      apply setIntegral_mono_set (integrable_approxOnCube _).norm.integrableOn <|\n        Eventually.of_forall (fun _ \u21a6 norm_nonneg _)\n      refine (iUnion\u2082_subset_iff.mpr (fun J hJ \u21a6 ?_)).eventuallyLE\n      exact Grid_subset_ball' pu xp (mem_Js.mp hJ)\n\n-- An average over `ball (\ud835\udd20 p) (16 * D ^ \ud835\udd30 p)` is bounded by `MB`; needed for Lemma 7.1.4\nprivate lemma L7_1_4_laverage_le_MB (hL : L \u2208 \ud835\udcdb (t u)) (hx : x \u2208 L) (hx' : x' \u2208 L) (g : X \u2192 \u211d)\n    {p : \ud835\udd13 X} (pu : p \u2208 t.\ud835\udd17 u) (xp : x \u2208 E p) :\n    (\u222b\u207b y in ball (\ud835\udd20 p) (16 * D ^ \ud835\udd30 p), \u2016g y\u2016\u208a) / volume (ball (\ud835\udd20 p) (16 * D ^ \ud835\udd30 p)) \u2264\n    MB volume \ud835\udcd1 c\ud835\udcd1 r\ud835\udcd1 g x' := by\n  have mem_\ud835\udcd1 : \u27e84, \ud835\udcd8 p\u27e9 \u2208 \ud835\udcd1 := by simp [\ud835\udcd1]\n  convert le_biSup (hi := mem_\ud835\udcd1) <| fun i \u21a6 ((ball (c\ud835\udcd1 i) (r\ud835\udcd1 i)).indicator (x := x') <|\n    fun _ \u21a6 \u2a0d\u207b y in ball (c\ud835\udcd1 i) (r\ud835\udcd1 i), \u2016g y\u2016\u208a \u2202volume)\n  \u00b7 have x'_in_ball : x' \u2208 ball (c\ud835\udcd1 (4, \ud835\udcd8 p)) (r\ud835\udcd1 (4, \ud835\udcd8 p)) := by\n      simp only [c\ud835\udcd1, r\ud835\udcd1, _root_.s]\n      have : x' \u2208 \ud835\udcd8 p := subset_of_mem_\ud835\udcdb hL pu (not_disjoint_iff.mpr \u27e8x, xp.1, hx\u27e9) hx'\n      refine Metric.ball_subset_ball ?_ <| Grid_subset_ball this\n      linarith [defaultD_pow_pos a (GridStructure.s (\ud835\udcd8 p))]\n    have hc\ud835\udcd1 : \ud835\udd20 p = c\ud835\udcd1 (4, \ud835\udcd8 p) := by simp [c\ud835\udcd1, \ud835\udd20]\n    have hr\ud835\udcd1 : 16 * D ^ \ud835\udd30 p = r\ud835\udcd1 (4, \ud835\udcd8 p) := by rw [r\ud835\udcd1, \ud835\udd30]; norm_num\n    simp [-defaultD, laverage, x'_in_ball, ENNReal.div_eq_inv_mul, hc\ud835\udcd1, hr\ud835\udcd1]\n  \u00b7 simp only [MB, maximalFunction, ENNReal.rpow_one, inv_one]\n\n/-- Lemma 7.1.4 -/\nlemma first_tree_pointwise (hu : u \u2208 t) (hL : L \u2208 \ud835\udcdb (t u)) (hx : x \u2208 L) (hx' : x' \u2208 L)\n    (hf : BoundedCompactSupport f) :\n    \u2016\u2211 i \u2208 t.\u03c3 u x, \u222b y, (exp (.I * (- \ud835\udcac u y + Q x y + \ud835\udcac u x - Q x x)) - 1) * Ks i x y * f y \u2016\u208a \u2264\n    C7_1_4 a * MB volume \ud835\udcd1 c\ud835\udcd1 r\ud835\udcd1 (approxOnCube (\ud835\udcd9 (t u)) (\u2016f \u00b7\u2016)) x' := by\n  set g := approxOnCube (\ud835\udcd9 (t u)) (\u2016f \u00b7\u2016)\n  let q (y : X) := -\ud835\udcac u y + Q x y + \ud835\udcac u x - Q x x\n  by_cases h\u03c3 : (t.\u03c3 u x).Nonempty; swap\n  \u00b7 simp [Finset.not_nonempty_iff_eq_empty.mp h\u03c3]\n  by_cases hMB : MB volume \ud835\udcd1 c\ud835\udcd1 r\ud835\udcd1 g x' = \u221e -- `MB` is finite, but we don't need to prove that.\n  \u00b7 exact hMB \u25b8 le_of_le_of_eq (OrderTop.le_top _) (by simp [C7_1_4])\n  rw [\u2190 ENNReal.coe_toNNReal hMB]\n  norm_cast\n  have : \u2200 s \u2208 t.\u03c3 u x, \u2016\u222b (y : X), (cexp (I * (q y)) - 1) * Ks s x y * f y\u2016\u208a \u2264\n      (\u222b (y : X), \u2016(cexp (I * (q y)) - 1) * Ks s x y * f y\u2016).toNNReal :=\n    fun s hs \u21a6 by apply le_trans (norm_integral_le_integral_norm _) (by simp)\n  refine (nnnorm_sum_le _ _).trans <| ((t.\u03c3 u x).sum_le_sum this).trans ?_\n  suffices \u2200 s \u2208 t.\u03c3 u x, (\u222b (y : X), \u2016(cexp (I * (q y)) - 1) * Ks s x y * f y\u2016).toNNReal \u2264\n      (5 * 2 ^ (104 * a ^ 3) * (MB volume \ud835\udcd1 c\ud835\udcd1 r\ud835\udcd1 g x').toNNReal) * 2 ^ (s - t.\u03c3Max u x h\u03c3) by\n    apply le_trans ((t.\u03c3 u x).sum_le_sum this)\n    rw [\u2190 Finset.mul_sum]\n    apply le_trans <| mul_le_mul_left' (L7_1_4_sum h\u03c3) _\n    rw [mul_comm _ 2, \u2190 mul_assoc, \u2190 mul_assoc, C7_1_4]\n    gcongr\n    \u00b7 norm_num\n    \u00b7 exact_mod_cast pow_le_pow_right\u2080 one_le_two (le_refl _)\n  intro s hs\n  have eq1 : \u222b (y : X), \u2016(cexp (I * (q y)) - 1) * Ks s x y * f y\u2016 =\n      \u222b y in ball x (D ^ s / 2), \u2016(cexp (I * (q y)) - 1) * Ks s x y * f y\u2016 := by\n    rw [\u2190 integral_indicator measurableSet_ball]\n    refine integral_congr_ae (EventuallyEq.of_eq (Set.indicator_eq_self.mpr fun y hy \u21a6 ?_)).symm\n    exact mem_ball_comm.mp (mem_Ioo.mp (dist_mem_Ioo_of_Ks_ne_zero fun h \u21a6 by simp [h] at hy)).2\n  have eq2 : (\u222b y in ball x (D ^ s / 2), \u2016(cexp (I * (q y)) - 1) * Ks s x y * f y\u2016).toNNReal \u2264\n      5 * 2 ^ (s - \u03c3Max t u x \u27e8s, hs\u27e9) * (2 ^ (103 * a ^ 3) / volume.real (ball x (D ^ s))) *\n      (\u222b y in ball x (D ^ s / 2), \u2016f y\u2016).toNNReal := by\n    rw [Real.coe_toNNReal _ <| setIntegral_nonneg measurableSet_ball (fun _ _ \u21a6 norm_nonneg _)]\n    convert le_trans (integral_mono_of_nonneg (Eventually.of_forall ?_)\n      (hf.integrable.norm.const_mul _).restrict\n      (Eventually.of_forall <| L7_1_4_integrand_bound f hu hs)) ?_\n    \u00b7 norm_cast\n    \u00b7 simp only [Pi.zero_apply, norm_nonneg, implies_true]\n    \u00b7 exact isFiniteMeasureOnCompacts_of_isLocallyFiniteMeasure\n    \u00b7 rw [integral_mul_left]; gcongr; simp\n  apply le_of_eq_of_le (congrArg Real.toNNReal eq1) \u2218 eq2.trans\n  simp only [Real.coe_toNNReal', NNReal.val_eq_coe, NNReal.coe_mul, NNReal.coe_ofNat,\n    NNReal.coe_pow, NNReal.coe_zpow]\n  simp_rw [sup_of_le_left <| setIntegral_nonneg measurableSet_ball (fun _ _ \u21a6 norm_nonneg _)]\n  have : 5 * 2 ^ (s - t.\u03c3Max u x h\u03c3) * (2 ^ (103 * a ^ 3) / volume.real (ball x (D ^ s))) *\n      (\u222b y in ball x (D ^ s / 2), \u2016f y\u2016) = 5 * (2 ^ (103 * a ^ 3) *\n      ((\u222b y in ball x (D ^ s / 2), \u2016f y\u2016) / volume.real (ball x (D ^ s)))) *\n      2 ^ (s - t.\u03c3Max u x h\u03c3) := by ring\n  rw [this, mul_le_mul_right (zpow_pos two_pos _), mul_assoc, mul_le_mul_left (by norm_num)]\n  rw [Nat.succ_mul 103, pow_add, mul_assoc, mul_le_mul_left (pow_pos two_pos _)]\n  have \u27e8p\u209b, p\u209bu, xp\u209b, hp\u209b\u27e9 := t.exists_p_of_mem_\u03c3 u x hs\n  have ball_subset : ball (\ud835\udd20 p\u209b) (16 * D ^ s) \u2286 ball x ((2 ^ 5) * D ^ s) :=\n    ball_subset_ball' <| calc 16 * (D : \u211d) ^ s + dist (\ud835\udd20 p\u209b) x\n      _ \u2264 16 * D ^ s + 4 * D ^ _ := add_le_add_left (mem_ball'.mp (Grid_subset_ball xp\u209b.1)).le _\n      _ = 16 * D ^ s + 4 * D ^ s := by nth_rewrite 3 [\u2190 hp\u209b]; rfl\n      _ \u2264 (2 ^ 5) * D ^ s        := by linarith [defaultD_pow_pos a s]\n  calc (\u222b y in ball x (D ^ s / 2), \u2016f y\u2016) / volume.real (ball x (D ^ s))\n  _ \u2264 2 ^ (5 * a) * ((\u222b y in ball x (D^s / 2), \u2016f y\u2016) / volume.real (ball (\ud835\udd20 p\u209b) (16 * D^s))) := by\n    rw [mul_comm (2 ^ (5 * a)), div_mul]\n    apply div_le_div\u2080 (setIntegral_nonneg measurableSet_ball (fun _ _ \u21a6 norm_nonneg _)) (le_refl _)\n    \u00b7 exact div_pos (hb := pow_pos two_pos (5 * a)) <|\n        measure_ball_pos_real (\ud835\udd20 p\u209b) (16 * D ^ s) (mul_pos (by norm_num) <| defaultD_pow_pos a s)\n    \u00b7 apply (div_le_iff\u2080' (pow_pos two_pos (5 * a))).mpr\n      apply le_trans <| ENNReal.toReal_mono (measure_ball_ne_top x _) <|\n        OuterMeasureClass.measure_mono volume ball_subset\n      apply le_of_le_of_eq <| measure_real_ball_two_le_same_iterate x (D ^ s) 5\n      simp [mul_comm 5 a, pow_mul]\n  _ \u2264 2 ^ (a ^ 3) * (MB volume \ud835\udcd1 c\ud835\udcd1 r\ud835\udcd1 g x').toNNReal := by\n    gcongr ?_ * ?_\n    \u00b7 apply pow_right_mono\u2080 one_le_two\n      rw [pow_succ a 2, mul_le_mul_right (a_pos X)]\n      nlinarith [four_le_a X]\n    \u00b7 refine le_trans ?_ <| ENNReal.toReal_mono hMB <| L7_1_4_laverage_le_MB hL hx hx' g p\u209bu xp\u209b\n      rw [hp\u209b, ENNReal.toReal_div]\n      refine div_le_div_of_nonneg_right ?_ measureReal_nonneg\n      simp_rw [\u2190 enorm_eq_nnnorm]\n      rw [\u2190 integral_norm_eq_lintegral_enorm]\n      \u00b7 exact hp\u209b \u25b8 L7_1_4_integral_le_integral hu hf p\u209bu xp\u209b\n      \u00b7 exact (stronglyMeasurable_approxOnCube (\ud835\udcd9 (t u)) (\u2016f \u00b7\u2016)).aestronglyMeasurable.restrict\n\n/-- Lemma 7.1.5 -/\nlemma second_tree_pointwise (hu : u \u2208 t) (hL : L \u2208 \ud835\udcdb (t u)) (hx : x \u2208 L) (hx' : x' \u2208 L) :\n    \u2016\u2211 i \u2208 t.\u03c3 u x, \u222b y, Ks i x y * approxOnCube (\ud835\udcd9 (t u)) f y\u2016\u208a \u2264\n    nontangentialMaximalFunction (\ud835\udcac u) (approxOnCube (\ud835\udcd9 (t u)) f) x' := by\n  rcases (t.\u03c3 u x).eq_empty_or_nonempty with hne | hne; \u00b7 simp [hne]\n  let s\u2081 := Finset.min' (t.\u03c3 u x) hne\n  have ms\u2081 : s\u2081 \u2208 t.\u03c3 u x := Finset.min'_mem ..\n  simp_rw [\u03c3, Finset.mem_image, Finset.mem_filter, Finset.mem_univ, true_and] at ms\u2081\n  obtain \u27e8p, \u27e8mp, xp, _, _\u27e9, sp\u27e9 := ms\u2081\n  have Lle : L \u2264 \ud835\udcd8 p := by\n    rcases \ud835\udcdb_subset_\ud835\udcdb\u2080 hL with hL | hL\n    \u00b7 exact le_of_mem_of_mem (hL.symm \u25b8 scale_mem_Icc.1) hx xp\n    \u00b7 exact (le_or_ge_of_mem_of_mem xp hx).resolve_left (hL.2 p mp)\n  let s\u2082 := Finset.max' (t.\u03c3 u x) hne\n  have ms\u2082 : s\u2082 \u2208 t.\u03c3 u x := Finset.max'_mem ..\n  simp_rw [\u03c3, Finset.mem_image, Finset.mem_filter, Finset.mem_univ, true_and] at ms\u2082\n  obtain \u27e8p', \u27e8mp', xp', Qxp', _\u27e9, sp'\u27e9 := ms\u2082\n  have s_ineq : \ud835\udd30 p \u2264 \ud835\udd30 p' := by\n    rw [sp, sp']; exact (t.\u03c3 u x).min'_le s\u2082 (Finset.max'_mem ..)\n  have pinc : \ud835\udcd8 p \u2264 \ud835\udcd8 p' := le_of_mem_of_mem s_ineq xp xp'\n  have d5 : dist_(p') (\ud835\udcac u) (Q x) < 5 := dist_lt_5 hu mp' Qxp'\n  have d5' : dist_{x, D ^ s\u2082} (\ud835\udcac u) (Q x) < 5 * defaultA a ^ 5 := by\n    have i1 : dist x (\ud835\udd20 p) < 4 * D ^ \ud835\udd30 p' :=\n      (mem_ball.mp (Grid_subset_ball xp)).trans_le <|\n        mul_le_mul_of_nonneg_left (zpow_le_zpow_right\u2080 one_le_D s_ineq) zero_le_four\n    have i2 : dist (\ud835\udd20 p') (\ud835\udd20 p) < 4 * D ^ \ud835\udd30 p' :=\n      mem_ball'.mp (ball_subset_Grid.trans (Grid.le_def.mp pinc).1 |>.trans Grid_subset_ball <|\n        mem_ball_self (by unfold defaultD; positivity))\n    calc\n      _ \u2264 dist_{\ud835\udd20 p, 8 * D ^ \ud835\udd30 p'} (\ud835\udcac u) (Q x) := by\n        refine cdist_mono (ball_subset_ball' ?_); rw [\u2190 sp']\n        calc\n          _ \u2264 (D : \u211d) ^ \ud835\udd30 p' + 4 * D ^ \ud835\udd30 p' := add_le_add_left i1.le _\n          _ = 5 * D ^ \ud835\udd30 p' := by ring\n          _ \u2264 _ := by gcongr; norm_num\n      _ \u2264 defaultA a * dist_{\ud835\udd20 p', 4 * D ^ \ud835\udd30 p'} (\ud835\udcac u) (Q x) := by\n        convert cdist_le (x\u2082 := \ud835\udd20 p) _ using 1\n        \u00b7 exact dist_congr rfl (by ring)\n        \u00b7 apply i2.trans_le; nth_rw 1 [\u2190 one_mul (4 * _)]; gcongr; exact one_le_two\n      _ \u2264 defaultA a ^ 5 * dist_(p') (\ud835\udcac u) (Q x) := by\n        rw [pow_succ', mul_assoc]; gcongr\n        convert cdist_le_iterate _ (\ud835\udcac u) (Q x) 4 using 1\n        \u00b7 exact dist_congr rfl (by ring)\n        \u00b7 unfold defaultD; positivity\n      _ < _ := by rw [mul_comm]; gcongr\n  have d1 : dist_{x, D ^ (s\u2082 - 1)} (\ud835\udcac u) (Q x) < 1 := by\n    calc\n      _ \u2264 dist_{x, D ^ s\u2082} (\ud835\udcac u) (Q x) * 2 ^ (-100 * a : \u2124) := by\n        rw [neg_mul, zpow_neg, le_mul_inv_iff\u2080 (by positivity), mul_comm]\n        convert le_cdist_iterate _ (\ud835\udcac u) (Q x) (100 * a) using 1\n        \u00b7 apply dist_congr rfl\n          rw [Nat.cast_npow, \u2190 pow_mul, show a * (100 * a) = 100 * a ^ 2 by ring, \u2190 Nat.cast_npow]\n          change _ = (D : \u211d) * _\n          rw [\u2190 zpow_one_add\u2080 (defaultD_pos _).ne', add_sub_cancel]\n        \u00b7 unfold defaultD; positivity\n      _ < 5 * defaultA a ^ 5 * 2 ^ (-100 * a : \u2124) := by gcongr\n      _ = 5 * (2 : \u211d) ^ (-95 * a : \u2124) := by\n        rw [Nat.cast_npow, \u2190 pow_mul, \u2190 zpow_natCast, show (2 : \u2115) = (2 : \u211d) by rfl, mul_assoc,\n          \u2190 zpow_add\u2080 two_ne_zero]; congr; omega\n      _ \u2264 5 * 2 ^ (-3 : \u2124) := by\n        gcongr\n        \u00b7 exact one_le_two\n        \u00b7 linarith [four_le_a X]\n      _ < _ := by norm_num\n  have x'p : x' \u2208 \ud835\udcd8 p := (Grid.le_def.mp Lle).1 hx'\n  refine le_iSup\u2082_of_le (\ud835\udcd8 p) x'p <| le_iSup\u2082_of_le x xp <|\n    le_iSup\u2082_of_le (\ud835\udd30 p') \u27e8s_ineq, scale_mem_Icc.2\u27e9 <| le_iSup_of_le ?_ ?_\n  \u00b7 have : ((D : \u211d\u22650\u221e) ^ (\ud835\udd30 p' - 1)).toReal = D ^ (s\u2082 - 1) := by\n      rw [sp', \u2190 ENNReal.toReal_zpow]; simp\n    apply le_upperRadius; convert d1\n  \u00b7 convert le_rfl; change (Icc (\ud835\udd30 p) _).toFinset = _; rw [sp, sp']\n    apply subset_antisymm\n    \u00b7 rw [\u2190 Finset.toFinset_coe (t.\u03c3 u x), toFinset_subset_toFinset]\n      exact (convex_scales hu).out (Finset.min'_mem ..) (Finset.max'_mem ..)\n    \u00b7 intro z mz; rw [toFinset_Icc, Finset.mem_Icc]\n      exact \u27e8Finset.min'_le _ _ mz, Finset.le_max' _ _ mz\u27e9\n\n/-- The constant used in `third_tree_pointwise`.\nHas value `2 ^ (151 * a ^ 3)` in the blueprint. -/\n-- Todo: define this recursively in terms of previous constants\nirreducible_def C7_1_6 (a : \u2115) : \u211d\u22650 := 2 ^ (151 * (a : \u211d) ^ 3)\n\n-- Used in the proof of Lemmas 7.1.3 and 7.1.6 to translate between `\u2211 p` into `\u2211 s`\nprivate lemma p_sum_eq_s_sum {\u03b1 : Type*} [AddCommMonoid \u03b1] (I : \u2124 \u2192 X \u2192 \u03b1) :\n    \u2211 p \u2208 Finset.univ.filter (\u00b7 \u2208 t.\ud835\udd17 u), (E p).indicator (I (\ud835\udd30 p)) x =\n    \u2211 s \u2208 t.\u03c3 u x, I s x := by\n  -- Restrict to a sum over those `p` such that `x \u2208 E p`.\n  let \ud835\udd17' := Finset.univ.filter (fun p \u21a6 p \u2208 t.\ud835\udd17 u \u2227 x \u2208 E p)\n  have : \u2211 p \u2208 \ud835\udd17', (E p).indicator (I (\ud835\udd30 p)) x =\n      \u2211 p \u2208 Finset.univ.filter (\u00b7 \u2208 t.\ud835\udd17 u), (E p).indicator (I (\ud835\udd30 p)) x := by\n    apply Finset.sum_subset (fun p hp \u21a6 by simp [(Finset.mem_filter.mp hp).2.1])\n    intro p p\ud835\udd17 p\ud835\udd17'\n    simp only [Finset.mem_filter, Finset.mem_univ, true_and, not_and, \ud835\udd17'] at p\ud835\udd17 p\ud835\udd17'\n    exact indicator_of_not_mem (p\ud835\udd17' p\ud835\udd17) (I (\ud835\udd30 p))\n  rw [\u2190 this]\n  -- Now the relevant values of `p` and `s` are in bijection.\n  apply Finset.sum_bij (fun p _ \u21a6 \ud835\udd30 p)\n  \u00b7 intro p hp\n    simp only [\u03c3, Finset.mem_image]\n    exact \u27e8p, by simpa [\ud835\udd17'] using hp\u27e9\n  \u00b7 intro p hp p' hp' hpp'\n    simp only [E, Grid.mem_def, sep_and, Finset.mem_filter, \ud835\udd17'] at hp hp'\n    by_contra h\n    exact Nonempty.not_disjoint \u27e8Q x, \u27e8hp.2.2.1.2, hp'.2.2.1.2\u27e9\u27e9 <| disjoint_\u03a9 h <|\n      (eq_or_disjoint hpp').resolve_right <| Nonempty.not_disjoint \u27e8x, \u27e8hp.2.2.1.1, hp'.2.2.1.1\u27e9\u27e9\n  \u00b7 intro s hs\n    simpa [\ud835\udd17', \u03c3] using hs\n  \u00b7 intro p hp\n    simp only [Finset.mem_filter, \ud835\udd17'] at hp\n    exact indicator_of_mem hp.2.2 (I (\ud835\udd30 p))\n\n-- Equation 7.1.10 from the blueprint\nprivate lemma L7_1_6_integral_eq {J : Grid X} (hJ : J \u2208 \ud835\udcd9 (t.\ud835\udd17 u)) {i : \u2124}\n    (hf : BoundedCompactSupport f) : \u222b y in J, Ks i x y * (f y - approxOnCube (\ud835\udcd9 (t u)) f y) =\n    \u222b y in J, (\u2a0d z in J, (Ks i x y - Ks i x z)) * f y := by\n  -- Preliminary trivialities\n  have i1 : IntegrableOn (fun y \u21a6 Ks i x y * f y) (J : Set X) := by\n    simp_rw [mul_comm]\n    exact (hf.integrable_mul (integrable_Ks_x (one_lt_D (X := X)))).restrict\n  have i2 : IntegrableOn (fun y \u21a6 Ks i x y * \u2a0d z in J, f z) (J : Set X) :=\n    ((integrable_Ks_x (one_lt_D (X := X))).mul_const _).integrableOn\n  have eq1 : \u2200 y \u2208 (J : Set X), Ks i x y * (f y - approxOnCube (\ud835\udcd9 (t.\ud835\udd17 u)) f y) =\n      Ks i x y * (f y - \u2a0d z in J, f z) :=\n    fun y hy \u21a6 by rw [approxOnCube_apply pairwiseDisjoint_\ud835\udcd9 _ hJ hy]\n  have eq2 : \u2200 y \u2208 (J : Set X), \u2a0d z in (J : Set X), Ks i x y \u2022 f y - Ks i x z \u2022 f y =\n      (\u2a0d z in (J : Set X), Ks i x y \u2022 f y) - \u2a0d z in (J : Set X), Ks i x z \u2022 f y :=\n    fun y hy \u21a6 integral_sub (integrableOn_const.mpr (Or.inr volume_coeGrid_lt_top)).to_average\n      ((integrable_Ks_x (one_lt_D (X := X))).smul_const _).restrict.to_average\n  have \u03bcJ_neq_0 : NeZero (volume.restrict (J : Set X)) :=\n    NeZero.mk fun h \u21a6 (volume_coeGrid_pos (defaultD_pos' a) (i := J)).ne <|\n      by simpa [h] using Measure.restrict_apply_self volume (J : Set X)\n  have \u03bcJ_finite := Restrict.isFiniteMeasure volume (hs := \u27e8volume_coeGrid_lt_top (i := J)\u27e9)\n  -- Split both sides into two separate integrals\n  rw [setIntegral_congr_fun coeGrid_measurable eq1]\n  simp_rw [mul_sub, integral_sub i1 i2, \u2190 smul_eq_mul, \u2190 average_smul_const, sub_smul]\n  rw [setIntegral_congr_fun coeGrid_measurable eq2, integral_sub]\n  \u00b7 congr 1 -- Check that corresponding integrals are equal\n    \u00b7 exact setIntegral_congr_fun coeGrid_measurable (fun y hy \u21a6 (average_const _ _).symm)\n    \u00b7 simp_rw [average_smul_const, integral_smul_const, integral_smul, average_eq]\n      rw [smul_comm, smul_assoc]\n  -- Check integrability to justify the last use of `integral_sub`\n  \u00b7 simpa [average_const]\n  \u00b7 simp_rw [average_smul_const]\n    change Integrable ((\u2a0d z in (J : Set X), Ks i x z) \u2022 f) (volume.restrict J)\n    exact hf.integrable.restrict.smul _\n\n-- Integral norm bound used implicitly in the third display of the proof of Lemma 7.1.6.\n", "theoremStatement": "private lemma L7_1_6_integral_le {J : Grid X} (hJ : J \u2208 \ud835\udcd9 (t.\ud835\udd17 u)) {i : \u2124}\n    (hf : BoundedCompactSupport f) : \u2016\u222b y in J, Ks i x y * (f y - approxOnCube (\ud835\udcd9 (t u)) f y)\u2016\u208a \u2264\n    Real.toNNReal ((D2_1_3 a) / (volume.real (ball x (D ^ i))) * 2 ^ (3 / (a : \u211d)) *\n    (D ^ ((s J - i) / (a : \u211d)) * \u222b y in J, \u2016f y\u2016)) ", "theoremName": "TileStructure.Forest.L7_1_6_integral_le", "fileCreated": {"commit": "5e49c3692f6d7344434caa7eea5f412f0ee35863", "date": "2024-09-27"}, "theoremCreated": {"commit": "2457452cfac134a22b7c5ed56b8812e776a34801", "date": "2025-01-14"}, "file": "carleson/Carleson/ForestOperator/PointwiseEstimate.lean", "module": "Carleson.ForestOperator.PointwiseEstimate", "jsonFile": "Carleson.ForestOperator.PointwiseEstimate.jsonl", "positionMetadata": {"lineInFile": 761, "tokenPositionInFile": 41651, "theoremPositionInFile": 58}, "dependencyMetadata": {"inFilePremises": null, "numInFilePremises": null, "repositoryPremises": null, "numRepositoryPremises": null, "numPremises": null}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [\u2190 norm_toNNReal]\n  apply Real.toNNReal_mono\n  let g (y : X) := \u2016(\u2a0d z in J, Ks i x y - Ks i x z) * f y\u2016\n  let h : X \u2192 \u211d := ((D2_1_3 a) / (volume.real (ball x (D ^ i))) * 2 ^ (3 / (a : \u211d)) *\n    (D : \u211d) ^ ((s J - i : \u211d) / a)) \u2022 (\u2016f \u00b7\u2016)\n  simp_rw [L7_1_6_integral_eq hJ hf]\n  apply le_trans <| norm_integral_le_integral_norm _\n  refine le_of_le_of_eq (integral_mono_of_nonneg (f := g) (g := h)\n    (Eventually.of_forall (fun y \u21a6 norm_nonneg _)) (hf.integrable.norm.restrict.smul _) ?_)\n    (by simp_rw [h, Pi.smul_apply, integral_smul, smul_eq_mul, mul_assoc])\n  simp_rw [Filter.EventuallyLE, Filter.Eventually, mem_ae_iff]\n  suffices {y | g y \u2264 h y}\u1d9c \u2229 (J : Set X) = \u2205 by simp [this, coeGrid_measurable]\n  ext y\n  rw [mem_inter_iff, mem_compl_iff, mem_setOf_eq, mem_empty_iff_false, iff_false]\n  suffices \u2200 y \u2208 J, g y \u2264 h y from fun hy \u21a6 hy.1 (this y hy.2)\n  intro y hy\n  simp_rw [g, h, norm_mul, Pi.smul_apply, smul_eq_mul]\n  refine mul_le_mul_of_nonneg_right ?_ (norm_nonneg (f y))\n  have \u27e8z\u2080, z\u2080J, hz\u2080\u27e9 : \u2203 z\u2080 \u2208 (J : Set X),\n      \u2a0d z in J, \u2016Ks i x y - Ks i x z\u2016 \u2264 \u2016Ks i x y - Ks i x z\u2080\u2016 := by\n    apply exists_setAverage_le (volume_coeGrid_pos (defaultD_pos' a)).ne.symm\n    \u00b7 exact volume_coeGrid_lt_top.ne\n    \u00b7 refine (Integrable.sub ?_ ?_).norm\n      \u00b7 exact integrable_const_iff.mpr (by simp [volume_coeGrid_lt_top, isFiniteMeasure_iff])\n      \u00b7 exact (integrable_Ks_x (one_lt_D (X := X))).restrict\n  calc \u2016\u2a0d z in J, Ks i x y - Ks i x z\u2016\n  _ \u2264 \u2a0d z in J, \u2016Ks i x y - Ks i x z\u2016  := norm_integral_le_integral_norm _\n  _ \u2264 \u2016Ks i x y - Ks i x z\u2080\u2016           := hz\u2080\n  _ \u2264 (D2_1_3 a) / volume.real (ball x (D ^ i)) * (dist y z\u2080 / D ^ i) ^ (a : \u211d)\u207b\u00b9 :=\n    norm_Ks_sub_Ks_le i x y z\u2080\n  _ \u2264 (D2_1_3 a) / volume.real (ball x (D ^ i)) * 2 ^ (3 / a : \u211d) * D ^ ((s J - i) / a : \u211d) := by\n    rw [mul_assoc]\n    gcongr\n    calc (dist y z\u2080 / D ^ i) ^ (a : \u211d)\u207b\u00b9\n    _ \u2264 (8 * D ^ (s J : \u211d) / D ^ (i : \u211d)) ^ (a : \u211d)\u207b\u00b9 := by\n      norm_cast\n      gcongr\n      calc dist y z\u2080\n        _ \u2264 dist y (c J) + dist z\u2080 (c J) := dist_triangle_right y z\u2080 (c J)\n        _ \u2264 4 * D ^ (s J) + 4 * D ^ (s J) :=\n          add_le_add (mem_ball.mp (Grid_subset_ball hy)).le (mem_ball.mp (Grid_subset_ball z\u2080J)).le\n        _ = 8 * D ^ (s J) := by ring\n    _ = 2 ^ (3 / a : \u211d) * (D : \u211d) ^ (((s J) - i) / a : \u211d) := by\n      rw [\u2190 mul_div, Real.mul_rpow (by norm_num) (by positivity)]\n      rw [\u2190 Real.rpow_sub (defaultD_pos a), \u2190 Real.rpow_mul (defaultD_pos a).le, \u2190 div_eq_mul_inv]\n      rw [div_eq_mul_inv 3, Real.rpow_mul two_pos.le]\n      norm_num", "proofType": "tactic", "proofLengthLines": 47, "proofLengthTokens": 2527}}
{"srcContext": "import Carleson.ToMathlib.DoublingMeasure\nimport Carleson.ToMathlib.RealInterpolation\nimport Mathlib.MeasureTheory.Covering.Vitali\n\nopen MeasureTheory Metric Bornology Set TopologicalSpace Vitali Filter ENNReal Pointwise\nopen scoped NNReal\nnoncomputable section\n\n/-! This should roughly contain the contents of chapter 9. -/\n\nsection Prelude\n\nvariable {X : Type*} [PseudoMetricSpace X] [SeparableSpace X]\n\nvariable (X) in\n/-- Lemma 9.0.2 -/\nlemma covering_separable_space :\n    \u2203 C : Set X, C.Countable \u2227 \u2200 r > 0, \u22c3 c \u2208 C, ball c r = univ := by\n  simp_rw [\u2190 Metric.dense_iff_iUnion_ball, exists_countable_dense]\n\nlemma countable_globalMaximalFunction :\n    (covering_separable_space X).choose \u00d7\u02e2 (univ : Set \u2124) |>.Countable :=\n  (covering_separable_space X).choose_spec.1.prod countable_univ\n\nlemma exists_ball_subset_ball_two (c : X) {r : \u211d} (hr : 0 < r) :\n    \u2203 c' \u2208 (covering_separable_space X).choose,\n      \u2203 m : \u2124, ball c r \u2286 ball c' (2 ^ m) \u2227 2 ^ m \u2264 2 * r \u2227 ball c' (2 ^ m) \u2286 ball c (4 * r) := by\n  obtain \u27e8_, hCr\u27e9 := (covering_separable_space X).choose_spec\n  let m := \u230aReal.logb 2 r\u230b\n  have hm : 2 ^ m \u2264 r := by\n    calc _ \u2264 (2 : \u211d) ^ (Real.logb 2 r) := by\n          convert Real.monotone_rpow_of_base_ge_one one_le_two (Int.floor_le _)\n          exact (Real.rpow_intCast 2 m).symm\n      _ = _ := Real.rpow_logb zero_lt_two (OfNat.one_ne_ofNat 2).symm hr\n  have hm' : r < 2 ^ (m + 1) := by\n    calc _ = (2 : \u211d) ^ Real.logb 2 r := (Real.rpow_logb zero_lt_two (OfNat.one_ne_ofNat 2).symm hr).symm\n      _ < _ := by\n        rw [\u2190 Real.rpow_intCast 2 (m + 1)]\n        refine Real.strictMono_rpow_of_base_gt_one one_lt_two ?_\n        simp [m]\n  let a := ((2 : \u211d) ^ (m + 1) - r) / 2\n  have h_univ := hCr a (by simp [a, hm'])\n  obtain \u27e8c', hc', hcc'\u27e9 := mem_iUnion\u2082.mp <| h_univ \u25b8 Set.mem_univ c\n  refine \u27e8c', hc', m + 1, ball_subset_ball_of_le ?_, ?_, ?_\u27e9\n  \u00b7 calc\n      _ \u2264 a + r := by gcongr; exact (dist_comm c c' \u25b8 mem_ball.mp hcc').le\n      _ \u2264 _ := by simp only [a, sub_div]; linarith\n  \u00b7 rw [\u2190 Real.rpow_intCast 2 (m + 1)]\n    push_cast\n    rw [Real.rpow_add_one two_ne_zero m, mul_comm]\n    gcongr\n    exact_mod_cast hm\n  \u00b7 refine ball_subset_ball_of_le ?_\n    calc\n      _ \u2264 a + 2 ^ (m + 1) := by gcongr; exact (mem_ball.mp hcc').le\n      _ \u2264 2 ^ (m + 1) + 2 ^ (m + 1) := by\n        gcongr\n        simp only [a]\n        linarith\n      _ \u2264 2 * r + 2 * r := by\n        rw [\u2190 Real.rpow_intCast 2 (m + 1)]\n        push_cast\n        rw [Real.rpow_add_one two_ne_zero m, mul_comm]\n        gcongr <;> simp [hm]\n      _ = 4 * r := by ring\n\nend Prelude\n\nvariable {X E : Type*} {A : \u211d\u22650} [MetricSpace X] [MeasurableSpace X]\n  {\u03bc : Measure X} [\u03bc.IsDoubling A] [NormedAddCommGroup E]\n  {f : X \u2192 E} {x : X} {\u03b9 : Type*} {\ud835\udcd1 : Set \u03b9} {c : \u03b9 \u2192 X} {r : \u03b9 \u2192 \u211d}\n  -- feel free to assume `A \u2265 16` or similar\n\n/-- The Hardy-Littlewood maximal function w.r.t. a collection of balls \ud835\udcd1.\nM_{\ud835\udcd1, p} in the blueprint. -/\ndef maximalFunction (\u03bc : Measure X) (\ud835\udcd1 : Set \u03b9) (c : \u03b9 \u2192 X) (r : \u03b9 \u2192 \u211d)\n    (p : \u211d) (u : X \u2192 E) (x : X) : \u211d\u22650\u221e :=\n  (\u2a06 i \u2208 \ud835\udcd1, (ball (c i) (r i)).indicator (x := x)\n    fun _ \u21a6 \u2a0d\u207b y in ball (c i) (r i), \u2016u y\u2016\u208a ^ p \u2202\u03bc) ^ p\u207b\u00b9\n\n/-- The Hardy-Littlewood maximal function w.r.t. a collection of balls \ud835\udcd1 with exponent 1.\nM_\ud835\udcd1 in the blueprint. -/\nabbrev MB (\u03bc : Measure X) (\ud835\udcd1 : Set \u03b9) (c : \u03b9 \u2192 X) (r : \u03b9 \u2192 \u211d) (u : X \u2192 E) (x : X) : \u211d\u22650\u221e :=\n  maximalFunction \u03bc \ud835\udcd1 c r 1 u x\n\nlemma maximalFunction_eq_MB\n    {\u03bc : Measure X} {\ud835\udcd1 : Set \u03b9} {c : \u03b9 \u2192 X} {r : \u03b9 \u2192 \u211d} {p : \u211d} {u : X \u2192 E} {x : X} (hp : 0 \u2264 p) :\n    maximalFunction \u03bc \ud835\udcd1 c r p u x = (MB \u03bc \ud835\udcd1 c r (\u2016u \u00b7\u2016 ^ p) x) ^ p\u207b\u00b9 := by\n  unfold MB maximalFunction; rw [\u2190 ENNReal.rpow_mul, inv_one, one_mul]; congr! 8\n  rw [ENNReal.rpow_one, \u2190 ENNReal.coe_rpow_of_nonneg _ hp, ENNReal.coe_inj,\n    Real.nnnorm_rpow_of_nonneg (by simp), nnnorm_norm]\n\n-- We will replace the criterion `P` used in `MeasureTheory.AESublinearOn.maximalFunction` with the\n-- weaker criterion `LocallyIntegrable` that is closed under addition and scalar multiplication.\n\n-- The average that appears in the definition of `MB`\nvariable (\u03bc c r) in\nprivate def T (i : \u03b9) (u : X \u2192 E) := \u2a0d\u207b (y : X) in ball (c i) (r i), \u2016u y\u2016\u208a \u2202\u03bc\n\n-- move\nlemma MeasureTheory.LocallyIntegrable.integrableOn_of_isBounded [ProperSpace X]\n    {f : X \u2192 E} (hf : LocallyIntegrable f \u03bc) {s : Set X}\n    (hs : IsBounded s) : IntegrableOn f s \u03bc :=\n  hf.integrableOn_isCompact hs.isCompact_closure |>.mono_set subset_closure\n\n-- move\nlemma MeasureTheory.LocallyIntegrable.integrableOn_ball [ProperSpace X]\n    {f : X \u2192 E} (hf : LocallyIntegrable f \u03bc) {x : X} {r : \u211d} : IntegrableOn f (ball x r) \u03bc :=\n  hf.integrableOn_of_isBounded isBounded_ball\n\n-- move\nlemma MeasureTheory.LocallyIntegrable.laverage_ball_lt_top [ProperSpace X]\n    {f : X \u2192 E} (hf : LocallyIntegrable f \u03bc)\n    {x\u2080 : X} {r : \u211d} :\n    \u2a0d\u207b x in ball x\u2080 r, \u2016f x\u2016\u208a \u2202\u03bc < \u22a4 :=\n  laverage_lt_top hf.integrableOn_ball.2.ne\n\nprivate lemma T.add_le [MeasurableSpace E] [BorelSpace E] [BorelSpace X] [ProperSpace X]\n    (i : \u03b9) {f g : X \u2192 E} (hf : LocallyIntegrable f \u03bc) :\n    \u2016T \u03bc c r i (f + g)\u2016\u2091 \u2264 \u2016T \u03bc c r i f\u2016\u2091 + \u2016T \u03bc c r i g\u2016\u2091 := by\n  simp only [T, Pi.add_apply, enorm_eq_self, \u2190 enorm_eq_nnnorm]\n  rw [\u2190 laverage_add_left hf.integrableOn_ball.aemeasurable.enorm]\n  exact laverage_mono (fun x \u21a6 ENNNorm_add_le (f x) (g x))\n\n-- move\nlemma NNReal.smul_ennreal_eq_mul (x : \u211d\u22650) (y : \u211d\u22650\u221e) : x \u2022 y = x * y := rfl\n\nprivate lemma T.smul [NormedSpace \u211d E] (i : \u03b9) : \u2200 {f : X \u2192 E} {d : \u211d\u22650}, LocallyIntegrable f \u03bc \u2192\n    T \u03bc c r i (d \u2022 f) = d \u2022 T \u03bc c r i f := by\n  intro f d _\n  simp_rw [T, Pi.smul_apply, NNReal.smul_def, NNReal.smul_ennreal_eq_mul,\n    laverage_const_mul ENNReal.coe_ne_top]\n  simp [nnnorm_smul]\n\n-- todo: move\n-- slightly more general than the Mathlib version\n-- the extra conclusion says that if there is a nonnegative radius, then we can choose `r b` to be\n-- larger than `r a` (up to a constant)\ntheorem exists_disjoint_subfamily_covering_enlargement_closedBall' {\u03b1} [MetricSpace \u03b1] (t : Set \u03b9)\n    (x : \u03b9 \u2192 \u03b1) (r : \u03b9 \u2192 \u211d) (R : \u211d) (hr : \u2200 a \u2208 t, r a \u2264 R) (\u03c4 : \u211d) (h\u03c4 : 3 < \u03c4) :\n    \u2203 u \u2286 t,\n      (u.PairwiseDisjoint fun a => closedBall (x a) (r a)) \u2227\n        \u2200 a \u2208 t, \u2203 b \u2208 u, closedBall (x a) (r a) \u2286 closedBall (x b) (\u03c4 * r b) \u2227\n        (\u2200 u \u2208 t, 0 \u2264 r u \u2192 r a \u2264 (\u03c4 - 1) / 2 * r b) := by\n  rcases eq_empty_or_nonempty t with (rfl | _)\n  \u00b7 exact \u27e8\u2205, Subset.refl _, pairwiseDisjoint_empty, by simp\u27e9\n  by_cases ht : \u2200 a \u2208 t, r a < 0\n  \u00b7 refine \u27e8t, .rfl, fun a ha b _ _ \u21a6 by\n      simp only [Function.onFun, closedBall_eq_empty.2 (ht a ha), empty_disjoint],\n      fun a ha => \u27e8a, ha, by simp only [closedBall_eq_empty.2 (ht a ha), empty_subset],\n      fun u hut hu \u21a6 (ht u hut).not_le hu |>.elim\u27e9\u27e9\n  push_neg at ht\n  let t' := { a \u2208 t | 0 \u2264 r a }\n  have h2\u03c4 : 1 < (\u03c4 - 1) / 2 := by linarith\n  rcases exists_disjoint_subfamily_covering_enlargement (fun a => closedBall (x a) (r a)) t' r\n      ((\u03c4 - 1) / 2) h2\u03c4 (fun a ha => ha.2) R (fun a ha => hr a ha.1) fun a ha =>\n      \u27e8x a, mem_closedBall_self ha.2\u27e9 with\n    \u27e8u, ut', u_disj, hu\u27e9\n  have A : \u2200 a \u2208 t', \u2203 b \u2208 u, closedBall (x a) (r a) \u2286 closedBall (x b) (\u03c4 * r b) \u2227\n    \u2200 u \u2208 t, 0 \u2264 r u \u2192 r a \u2264 (\u03c4 - 1) / 2 * r b := by\n    intro a ha\n    rcases hu a ha with \u27e8b, bu, hb, rb\u27e9\n    refine \u27e8b, bu, ?_\u27e9\n    have : dist (x a) (x b) \u2264 r a + r b := dist_le_add_of_nonempty_closedBall_inter_closedBall hb\n    exact \u27e8closedBall_subset_closedBall' <| by linarith, fun _ _ _ \u21a6 rb\u27e9\n  refine \u27e8u, ut'.trans fun a ha => ha.1, u_disj, fun a ha => ?_\u27e9\n  rcases le_or_lt 0 (r a) with (h'a | h'a)\n  \u00b7 exact A a \u27e8ha, h'a\u27e9\n  \u00b7 rcases ht with \u27e8b, rb\u27e9\n    rcases A b \u27e8rb.1, rb.2\u27e9 with \u27e8c, cu, _, hc\u27e9\n    refine \u27e8c, cu, by simp only [closedBall_eq_empty.2 h'a, empty_subset], fun _ _ _ \u21a6 ?_\u27e9\n    have : 0 \u2264 r c := nonneg_of_mul_nonneg_right (rb.2.trans <| hc b rb.1 rb.2) (by positivity)\n    exact h'a.le.trans <| by positivity\n\n-- move to Vitali\ntheorem Vitali.exists_disjoint_subfamily_covering_enlargement_ball {\u03b1} [MetricSpace \u03b1] (t : Set \u03b9)\n    (x : \u03b9 \u2192 \u03b1) (r : \u03b9 \u2192 \u211d) (R : \u211d) (hr : \u2200 a \u2208 t, r a \u2264 R) (\u03c4 : \u211d) (h\u03c4 : 3 < \u03c4) :\n    \u2203 u \u2286 t,\n      (u.PairwiseDisjoint fun a => ball (x a) (r a)) \u2227\n        \u2200 a \u2208 t, \u2203 b \u2208 u, ball (x a) (r a) \u2286 ball (x b) (\u03c4 * r b) := by\n  obtain \u27e8\u03c3, h\u03c3, h\u03c3\u03c4\u27e9 := exists_between h\u03c4\n  obtain \u27e8u, hut, hux, hu\u27e9 :=\n    exists_disjoint_subfamily_covering_enlargement_closedBall' t x r R hr \u03c3 h\u03c3\n  refine \u27e8u, hut, fun i hi j hj hij \u21a6 ?_, fun a ha => ?_\u27e9\n  \u00b7 exact (hux hi hj hij).mono ball_subset_closedBall ball_subset_closedBall\n  obtain \u27e8b, hbu, hb\u27e9 := hu a ha\n  refine \u27e8b, hbu, ?_\u27e9\n  obtain h2a|h2a := le_or_lt (r a) 0\n  \u00b7 simp_rw [ball_eq_empty.mpr h2a, empty_subset]\n  refine ball_subset_closedBall.trans hb.1 |>.trans <| closedBall_subset_ball ?_\n  gcongr\n  apply pos_of_mul_pos_right <| h2a.trans_le <| hb.2 a ha h2a.le\n  linarith\n\n-- move next to Finset.exists_le\nlemma Finset.exists_image_le {\u03b1 \u03b2} [Nonempty \u03b2] [Preorder \u03b2] [IsDirected \u03b2 (\u00b7 \u2264 \u00b7)]\n    (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) : \u2203 b : \u03b2, \u2200 a \u2208 s, f a \u2264 b := by\n  classical\n  simpa using s.image f |>.exists_le\n\n-- move\nlemma Set.Finite.exists_image_le {\u03b1 \u03b2} [Nonempty \u03b2] [Preorder \u03b2] [IsDirected \u03b2 (\u00b7 \u2264 \u00b7)]\n    {s : Set \u03b1} (hs : s.Finite) (f : \u03b1 \u2192 \u03b2) : \u2203 b : \u03b2, \u2200 a \u2208 s, f a \u2264 b := by\n  simpa using hs.toFinset.exists_image_le f\n\ntheorem Set.Countable.measure_biUnion_le_lintegral [OpensMeasurableSpace X] (h\ud835\udcd1 : \ud835\udcd1.Countable)\n    (l : \u211d\u22650\u221e) (u : X \u2192 \u211d\u22650\u221e) (R : \u211d) (hR : \u2200 a \u2208 \ud835\udcd1, r a \u2264 R)\n    (h2u : \u2200 i \u2208 \ud835\udcd1, l * \u03bc (ball (c i) (r i)) \u2264 \u222b\u207b x in ball (c i) (r i), u x \u2202\u03bc) :\n    l * \u03bc (\u22c3 i \u2208 \ud835\udcd1, ball (c i) (r i)) \u2264 A ^ 2 * \u222b\u207b x, u x \u2202\u03bc  := by\n  obtain \u27e8B, hB\ud835\udcd1, hB, h2B\u27e9 := Vitali.exists_disjoint_subfamily_covering_enlargement_ball\n    \ud835\udcd1 c r R hR (2 ^ 2) (by norm_num)\n  have : Countable B := h\ud835\udcd1.mono hB\ud835\udcd1\n  have disj := fun i j hij \u21a6\n    hB (Subtype.coe_prop i) (Subtype.coe_prop j) (Subtype.coe_ne_coe.mpr hij)\n  calc\n    l * \u03bc (\u22c3 i \u2208 \ud835\udcd1, ball (c i) (r i)) \u2264 l * \u03bc (\u22c3 i \u2208 B, ball (c i) (2 ^ 2 * r i)) := by\n          refine mul_left_mono (\u03bc.mono fun x hx \u21a6 ?_)\n          simp only [mem_iUnion, mem_ball, exists_prop] at hx\n          rcases hx with \u27e8i, i\ud835\udcd1, hi\u27e9\n          obtain \u27e8b, bB, hb\u27e9 := h2B i i\ud835\udcd1\n          refine mem_iUnion\u2082.mpr \u27e8b, bB, hb <| mem_ball.mpr hi\u27e9\n    _ \u2264 l * \u2211' i : B, \u03bc (ball (c i) (2 ^ 2 * r i)) :=\n          mul_left_mono <| measure_biUnion_le \u03bc (h\ud835\udcd1.mono hB\ud835\udcd1) fun i \u21a6 ball (c i) (2 ^ 2 * r i)\n    _ \u2264 l * \u2211' i : B, A ^ 2 * \u03bc (ball (c i) (r i)) := by\n          refine mul_left_mono <| ENNReal.tsum_le_tsum (fun i \u21a6 ?_)\n          rw [sq, sq, mul_assoc, mul_assoc]\n          apply (measure_ball_two_le_same (c i) (2 * r i)).trans\n          exact mul_left_mono (measure_ball_two_le_same (c i) (r i))\n    _ = A ^ 2 * \u2211' i : B, l * \u03bc (ball (c i) (r i)) := by\n          rw [ENNReal.tsum_mul_left, ENNReal.tsum_mul_left, \u2190 mul_assoc, \u2190 mul_assoc, mul_comm l]\n    _ \u2264 A ^ 2 * \u2211' i : B, \u222b\u207b x in ball (c i) (r i), u x \u2202\u03bc := by\n          gcongr; exact h2u _ (hB\ud835\udcd1 (Subtype.coe_prop _))\n    _ = A ^ 2 * \u222b\u207b x in \u22c3 i \u2208 B, ball (c i) (r i), u x \u2202\u03bc := by\n          congr; simpa using (lintegral_iUnion (fun i \u21a6 measurableSet_ball) disj u).symm\n    _ \u2264 A ^ 2 * \u222b\u207b x, u x \u2202\u03bc := by\n          gcongr; exact setLIntegral_le_lintegral (\u22c3 i \u2208 B, ball (c i) (r i)) u\n\nprotected theorem Finset.measure_biUnion_le_lintegral [OpensMeasurableSpace X] (\ud835\udcd1 : Finset \u03b9)\n    (l : \u211d\u22650\u221e) (u : X \u2192 \u211d\u22650\u221e)\n    (h2u : \u2200 i \u2208 \ud835\udcd1, l * \u03bc (ball (c i) (r i)) \u2264 \u222b\u207b x in ball (c i) (r i), u x \u2202\u03bc) :\n    l * \u03bc (\u22c3 i \u2208 \ud835\udcd1, ball (c i) (r i)) \u2264 A ^ 2 * \u222b\u207b x, u x \u2202\u03bc  :=\n  let \u27e8c, hc\u27e9 := \ud835\udcd1.exists_image_le r\n  \ud835\udcd1.countable_toSet.measure_biUnion_le_lintegral l u c hc h2u\n\nprotected theorem MeasureTheory.AEStronglyMeasurable.maximalFunction [BorelSpace X] {p : \u211d}\n    {u : X \u2192 E} (h\ud835\udcd1 : \ud835\udcd1.Countable) : AEStronglyMeasurable (maximalFunction \u03bc \ud835\udcd1 c r p u) \u03bc :=\n  (AEMeasurable.biSup \ud835\udcd1 h\ud835\udcd1 fun _ _ \u21a6 aemeasurable_const.indicator measurableSet_ball).pow\n    aemeasurable_const |>.aestronglyMeasurable\n\ntheorem MeasureTheory.AEStronglyMeasurable.maximalFunction_toReal [BorelSpace X]\n    {p : \u211d} {u : X \u2192 E} (h\ud835\udcd1 : \ud835\udcd1.Countable) :\n    AEStronglyMeasurable (fun x \u21a6 maximalFunction \u03bc \ud835\udcd1 c r p u x |>.toReal) \u03bc :=\n  AEStronglyMeasurable.maximalFunction h\ud835\udcd1 |>.ennreal_toReal\n\ntheorem MB_le_eLpNormEssSup {u : X \u2192 E} {x : X} : MB \u03bc \ud835\udcd1 c r u x \u2264 eLpNormEssSup u \u03bc :=\n  calc MB \u03bc \ud835\udcd1 c r u x \u2264\n    \u2a06 i \u2208 \ud835\udcd1, (ball (c i) (r i)).indicator (x := x)\n        fun _x \u21a6 \u2a0d\u207b _y in ball (c i) (r i), eLpNormEssSup u \u03bc \u2202\u03bc := by\n        simp_rw [MB, maximalFunction, inv_one, ENNReal.rpow_one]\n        gcongr\n        exact coe_nnnorm_ae_le_eLpNormEssSup u \u03bc\n    _ \u2264 \u2a06 i \u2208 \ud835\udcd1, (ball (c i) (r i)).indicator (x := x) fun _x \u21a6 eLpNormEssSup u \u03bc := by\n      gcongr; apply setLaverage_const_le\n    _ \u2264 \u2a06 i \u2208 \ud835\udcd1, eLpNormEssSup u \u03bc := by gcongr; apply indicator_le_self\n    _ \u2264 eLpNormEssSup u \u03bc := by\n      simp_rw [iSup_le_iff, le_refl, implies_true]\n\nprotected theorem HasStrongType.MB_top [BorelSpace X] (h\ud835\udcd1 : \ud835\udcd1.Countable) :\n    HasStrongType (fun (u : X \u2192 E) (x : X) \u21a6 MB \u03bc \ud835\udcd1 c r u x |>.toReal) \u22a4 \u22a4 \u03bc \u03bc 1 := by\n  intro f _\n  use AEStronglyMeasurable.maximalFunction_toReal h\ud835\udcd1\n  simp only [ENNReal.coe_one, one_mul, eLpNorm_exponent_top]\n  refine essSup_le_of_ae_le _ (Eventually.of_forall fun x \u21a6 ?_)\n  simp_rw [enorm_eq_nnnorm, ENNReal.nnorm_toReal]\n  exact ENNReal.coe_toNNReal_le_self |>.trans MB_le_eLpNormEssSup\n\n/- The proof is roughly between (9.0.12)-(9.0.22). -/\nprotected theorem HasWeakType.MB_one [BorelSpace X] (h\ud835\udcd1 : \ud835\udcd1.Countable)\n    {R : \u211d} (hR : \u2200 i \u2208 \ud835\udcd1, r i \u2264 R) :\n    HasWeakType (MB (E := E) \u03bc \ud835\udcd1 c r) 1 1 \u03bc \u03bc (A ^ 2) := by\n  intro f _\n  use AEStronglyMeasurable.maximalFunction h\ud835\udcd1\n  let B\u2097 (\u2113 : \u211d\u22650\u221e) := { i \u2208 \ud835\udcd1 | \u222b\u207b y in (ball (c i) (r i)), \u2016f y\u2016\u208a \u2202\u03bc \u2265 \u2113 * \u03bc (ball (c i) (r i)) }\n  simp only [wnorm, one_ne_top, wnorm', one_toReal, inv_one, ENNReal.rpow_one, reduceIte,\n    ENNReal.coe_pow, eLpNorm, one_ne_zero, eLpNorm', ne_eq, not_false_eq_true, div_self,\n    iSup_le_iff]\n  intro t\n  by_cases ht : t = 0\n  \u00b7 simp [ht]\n  have hB\u2097 : (B\u2097 t).Countable := h\ud835\udcd1.mono (fun i hi \u21a6 mem_of_mem_inter_left hi)\n  refine le_trans ?_ (hB\u2097.measure_biUnion_le_lintegral (c := c) (r := r) (l := t)\n    (u := fun x \u21a6 \u2016f x\u2016\u208a) (R := R) ?_ ?_)\n  \u00b7 refine mul_left_mono <| \u03bc.mono (fun x hx \u21a6 mem_iUnion\u2082.mpr ?_)\n    -- We need a ball in `B\u2097 t` containing `x`. Since `MB \u03bc \ud835\udcd1 c r f x` is large, such a ball exists\n    simp only [mem_setOf_eq] at hx\n    -- replace hx := lt_of_lt_of_le hx coe_toNNReal_le_self\n    simp only [MB, maximalFunction, ENNReal.rpow_one, inv_one] at hx\n    obtain \u27e8i, ht\u27e9 := lt_iSup_iff.mp hx\n    replace hx : x \u2208 ball (c i) (r i) :=\n      by_contradiction <| fun h \u21a6 not_lt_of_ge (zero_le t) (ENNReal.coe_lt_coe.mp <| by simp [h] at ht)\n    refine \u27e8i, ?_, hx\u27e9\n    -- It remains only to confirm that the chosen ball is actually in `B\u2097 t`\n    simp only [ge_iff_le, mem_setOf_eq, B\u2097]\n    have hi : i \u2208 \ud835\udcd1 :=\n      by_contradiction <| fun h \u21a6 not_lt_of_ge (zero_le t) (ENNReal.coe_lt_coe.mp <| by simp [h] at ht)\n    exact \u27e8hi, mul_le_of_le_div <| le_of_lt (by simpa [setLaverage_eq, hi, hx] using ht)\u27e9\n  \u00b7 exact fun i hi \u21a6 hR i (mem_of_mem_inter_left hi)\n  \u00b7 exact fun i hi \u21a6 hi.2.trans (setLIntegral_mono' measurableSet_ball fun x _ \u21a6 by simp)\n\nprotected theorem HasWeakType.MB_one_toReal [BorelSpace X] (h\ud835\udcd1 : \ud835\udcd1.Countable)\n    {R : \u211d} (hR : \u2200 i \u2208 \ud835\udcd1, r i \u2264 R) :\n    HasWeakType (fun (u : X \u2192 E) (x : X) \u21a6 MB \u03bc \ud835\udcd1 c r u x |>.toReal) 1 1 \u03bc \u03bc (A ^ 2) :=\n  HasWeakType.MB_one h\ud835\udcd1 hR |>.toReal\n\ninclude A in\n", "theoremStatement": "theorem MB_ae_ne_top [BorelSpace X] (h\ud835\udcd1 : \ud835\udcd1.Countable)\n    {R : \u211d} (hR : \u2200 i \u2208 \ud835\udcd1, r i \u2264 R)\n    {u : X \u2192 E} (hu : Mem\u2112p u 1 \u03bc) : \u2200\u1d50 x : X \u2202\u03bc, MB \u03bc \ud835\udcd1 c r u x \u2260 \u221e ", "theoremName": "MB_ae_ne_top", "fileCreated": {"commit": "1a36cbeaee9466fb56c9aca49ef373f9f9cc7ab7", "date": "2025-01-23"}, "theoremCreated": {"commit": "b069d5bb71885f498386762866228ac78bf5409e", "date": "2025-01-13"}, "file": "carleson/Carleson/ToMathlib/HardyLittlewood.lean", "module": "Carleson.ToMathlib.HardyLittlewood", "jsonFile": "Carleson.ToMathlib.HardyLittlewood.jsonl", "positionMetadata": {"lineInFile": 316, "tokenPositionInFile": 15306, "theoremPositionInFile": 25}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 12, "numPremises": 52}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simpa only [enorm_eq_self] using HasWeakType.MB_one h\ud835\udcd1 hR |>.memW\u2112p hu |>.ae_ne_top", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 91}}
{"srcContext": "/-\nCopyright (c) 2024 James Sundstrom. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: James Sundstrom\n-/\nimport Mathlib.MeasureTheory.Constructions.BorelSpace.Metric\n\n/-!\n# Annulus\n\nIn this file we define an annulus in a pseudometric space `X` to be a set consisting of all `y`\nsuch that `dist x y` lies in an interval between `r` and `R`. An annulus is defined for each type\nof interval (`Ioo`, `Ioc`, etc.) with a parallel naming scheme, except that we do not define annuli\nfor `Iio` and `Ico`, as they would be balls.\n\nWe also define `EAnnulus` similarly using `edist` instead of `dist`.\n\n## Tags\n\nannulus, eannulus\n-/\n\nopen Set Metric ENNReal\n\nvariable {X : Type*} [PseudoMetricSpace X]\n\nnamespace Set\n\nnamespace Annulus\n\ndef oo (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d) := {y | dist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d) := {y | dist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d) := {y | dist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d) := {y | dist x y \u2208 Ici r}\n\nlemma oo_eq {x : X} {r R : \u211d} : oo x r R = ball x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oo, dist_comm, and_comm]\n\nlemma oc_eq {x : X} {r R : \u211d} : oc x r R = closedBall x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oc, dist_comm, and_comm]\n\nlemma co_eq {x : X} {r R : \u211d} : co x r R = ball x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [co, dist_comm, and_comm]\n\nlemma cc_eq {x : X} {r R : \u211d} : cc x r R = closedBall x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [cc, dist_comm, and_comm]\n\nlemma oi_eq {x : X} {r : \u211d} : oi x r = (closedBall x r)\u1d9c := by\n  ext; simp [oi, dist_comm]\n\nlemma ci_eq {x : X} {r : \u211d} : ci x r = (ball x r)\u1d9c := by\n  ext; simp [ci, dist_comm]\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : co x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma co_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : co x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\n", "theoremStatement": "lemma cc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 ", "theoremName": "Set.Annulus.cc_subset_oo", "fileCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "theoremCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "file": "carleson/Carleson/ToMathlib/Annulus.lean", "module": "Carleson.ToMathlib.Annulus", "jsonFile": "Carleson.ToMathlib.Annulus.jsonl", "positionMetadata": {"lineInFile": 139, "tokenPositionInFile": 4963, "theoremPositionInFile": 34}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 21}, "proofMetadata": {"hasProof": true, "proof": ":=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 70}}
{"srcContext": "/-\nCopyright (c) 2024 James Sundstrom. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: James Sundstrom\n-/\nimport Mathlib.MeasureTheory.Constructions.BorelSpace.Metric\n\n/-!\n# Annulus\n\nIn this file we define an annulus in a pseudometric space `X` to be a set consisting of all `y`\nsuch that `dist x y` lies in an interval between `r` and `R`. An annulus is defined for each type\nof interval (`Ioo`, `Ioc`, etc.) with a parallel naming scheme, except that we do not define annuli\nfor `Iio` and `Ico`, as they would be balls.\n\nWe also define `EAnnulus` similarly using `edist` instead of `dist`.\n\n## Tags\n\nannulus, eannulus\n-/\n\nopen Set Metric ENNReal\n\nvariable {X : Type*} [PseudoMetricSpace X]\n\nnamespace Set\n\nnamespace Annulus\n\ndef oo (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d) := {y | dist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d) := {y | dist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d) := {y | dist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d) := {y | dist x y \u2208 Ici r}\n\nlemma oo_eq {x : X} {r R : \u211d} : oo x r R = ball x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oo, dist_comm, and_comm]\n\nlemma oc_eq {x : X} {r R : \u211d} : oc x r R = closedBall x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oc, dist_comm, and_comm]\n\nlemma co_eq {x : X} {r R : \u211d} : co x r R = ball x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [co, dist_comm, and_comm]\n\nlemma cc_eq {x : X} {r R : \u211d} : cc x r R = closedBall x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [cc, dist_comm, and_comm]\n\nlemma oi_eq {x : X} {r : \u211d} : oi x r = (closedBall x r)\u1d9c := by\n  ext; simp [oi, dist_comm]\n\nlemma ci_eq {x : X} {r : \u211d} : ci x r = (ball x r)\u1d9c := by\n  ext; simp [ci, dist_comm]\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : co x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma co_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : co x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\nlemma cc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : cc x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma cc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : cc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\n@[simp]\nlemma oc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    oc x r r' \u222a oo x r' R = oo x r R := by\n  ext; simp_rw [oc, oo, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioo_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    oc x r r' \u222a oc x r' R = oc x r R := by\n  ext; simp_rw [oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_co {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a co x r' R = oo x r R := by\n  ext; simp_rw [oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ico_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a cc x r' R = oc x r R := by\n  ext; simp_rw [oo, cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Icc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    cc x r r' \u222a oo x r' R = co x r R := by\n  ext; simp_rw [cc, oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioo_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    cc x r r' \u222a oc x r' R = cc x r R := by\n  ext; simp_rw [cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_co {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a co x r' R = co x r R := by\n  ext; simp_rw [co, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ico_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a cc x r' R = cc x r R := by\n  ext; simp_rw [co, cc, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Icc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : oc x r R \u222a oi x R = oi x r := by\n  ext; simp_rw [oc, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioi_eq_Ioi h]\n\n@[simp]\nlemma oo_union_ci {x : X} {r R : \u211d} (h : r < R) :\n    oo x r R \u222a ci x R = oi x r := by\n  ext; simp_rw [oo, ci, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ici_eq_Ioi h]\n\n@[simp]\nlemma cc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : cc x r R \u222a oi x R = ci x r := by\n  ext; simp_rw [cc, oi, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioi_eq_Ici h]\n\n@[simp]\nlemma co_union_ci {x : X} {r R : \u211d} (h : r \u2264 R) : co x r R \u222a ci x R = ci x r := by\n  ext; simp_rw [co, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ici_eq_Ici h]\n\n\nvariable [MeasurableSpace X] [OpensMeasurableSpace X]\n\n@[measurability]\nlemma measurableSet_oo {x : X} {r R : \u211d} : MeasurableSet (oo x r R) := by\n  rw [oo_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oc {x : X} {r R : \u211d} : MeasurableSet (oc x r R) := by\n rw [oc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_co {x : X} {r R : \u211d} : MeasurableSet (co x r R) := by\n  rw [co_eq]; measurability\n\n@[measurability]\nlemma measurableSet_cc {x : X} {r R : \u211d} : MeasurableSet (cc x r R) := by\n rw [cc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oi {x : X} {r : \u211d} : MeasurableSet (oi x r) := by\n  rw [oi_eq]; measurability\n\n@[measurability]\nlemma measurableSet_ci {x : X} {r : \u211d} : MeasurableSet (ci x r) := by\n  rw [ci_eq]; measurability\n\nend Annulus\n\nnamespace EAnnulus\n\ndef oo (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ici r}\n\n\nlemma oo_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oo x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oo x r R := by\n  simp_rw [oo, Annulus.oo, edist_dist, mem_Ioo, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma oc_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [oc, Annulus.oc, edist_dist, mem_Ioc, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  \u00b7 have R_le_r := (lt_of_lt_of_le (lt_of_not_ge hR) hr).le\n    rw [Annulus.oc_eq_empty R_le_r]\n    refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n    exact not_le_of_gt (lt_of_le_of_lt (ENNReal.ofReal_le_ofReal R_le_r) hy.1) hy.2\n\nlemma co_eq_annulus {x : X} {r R : \u211d} :\n    co x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.co x r R := by\n  simp_rw [co, Annulus.co, edist_dist, mem_Ico, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma cc_eq_annulus {x : X} {r R : \u211d} (h : r > 0 \u2228 R \u2265 0) :\n    cc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.cc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [cc, Annulus.cc, edist_dist, mem_Icc, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  have r0 := h.resolve_right hR\n  have R_lt_r := (lt_of_not_ge hR).trans r0\n  rw [Annulus.cc_eq_empty R_lt_r]\n  refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n  exact not_le_of_gt ((ENNReal.ofReal_lt_ofReal_iff r0).mpr R_lt_r) (hy.1.trans hy.2)\n\nlemma oi_eq_annulus {x : X} {r : \u211d} (hr : r \u2265 0) : oi x (ENNReal.ofReal r) = Annulus.oi x r := by\n  simp_rw [oi, Annulus.oi, edist_dist, mem_Ioi, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr]\n\nlemma ci_eq_annulus {x : X} {r : \u211d} : ci x (ENNReal.ofReal r) = Annulus.ci x r := by\n  simp_rw [ci, Annulus.ci, edist_dist, mem_Ici, ENNReal.ofReal_le_ofReal_iff dist_nonneg]\n\n\nlemma oo_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oo x r R = ball x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oo, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma oc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oc x r R = closedBall x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oc, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma co_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    co x r R = ball x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [co, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma cc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    cc x r R = closedBall x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [cc, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma oi_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : oi x r = (closedBall x r.toReal)\u1d9c := by\n  ext; simp [oi, edist_dist, dist_comm, lt_ofReal_iff_toReal_lt hr.ne]\n\nlemma ci_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : ci x r = (ball x r.toReal)\u1d9c := by\n  ext; simp [ci, edist_dist, dist_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg]\n\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n@[simp]\nlemma cc_top_eq_empty {x : X} {R : \u211d\u22650\u221e} : cc x \u22a4 R = \u2205 :=\n  eq_empty_of_forall_not_mem (fun y hy \u21a6 (edist_ne_top x y) (top_le_iff.mp hy.1))\n\n@[simp]\nlemma oi_eq_empty {x : X} : oi x \u22a4 = \u2205 := by simp [oi, edist_dist]\n\n@[simp]\nlemma ci_eq_empty {x : X} : ci x \u22a4 = \u2205 := by simp [ci, edist_dist]\n\n\nlemma oo_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) :\n    oo x r \u22a4 = (closedBall x r.toReal)\u1d9c := by\n  ext; simpa [oo, edist_dist, dist_comm] using lt_ofReal_iff_toReal_lt hr.ne\n\nlemma oc_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) :\n    oc x r \u22a4 = (closedBall x r.toReal)\u1d9c := by\n  ext; simpa [oc, edist_dist, dist_comm] using lt_ofReal_iff_toReal_lt hr.ne\n\nlemma co_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : co x r \u22a4 = (ball x r.toReal)\u1d9c := by\n  ext; simpa [co, edist_dist, dist_comm] using le_ofReal_iff_toReal_le hr.ne dist_nonneg\n\nlemma cc_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : cc x r \u22a4 = (ball x r.toReal)\u1d9c := by\n  ext; simpa [cc, edist_dist, dist_comm] using le_ofReal_iff_toReal_le hr.ne dist_nonneg\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) : co x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma co_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : co x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\nlemma cc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) : cc x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma cc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : cc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\n@[simp]\nlemma oc_union_oo {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    oc x r r' \u222a oo x r' R = oo x r R := by\n  ext; simp_rw [oc, oo, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioo_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oc {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    oc x r r' \u222a oc x r' R = oc x r R := by\n  ext; simp_rw [oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_co {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a co x r' R = oo x r R := by\n  ext; simp_rw [oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ico_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_cc {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a cc x r' R = oc x r R := by\n  ext; simp_rw [oo, cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Icc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oo {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    cc x r r' \u222a oo x r' R = co x r R := by\n  ext; simp_rw [cc, oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioo_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oc {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    cc x r r' \u222a oc x r' R = cc x r R := by\n  ext; simp_rw [cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_co {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a co x r' R = co x r R := by\n  ext; simp_rw [co, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ico_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_cc {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a cc x r' R = cc x r R := by\n  ext; simp_rw [co, cc, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Icc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oi {x : X} {r R : \u211d\u22650\u221e} (h : r \u2264 R) : oc x r R \u222a oi x R = oi x r := by\n  ext; simp_rw [oc, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioi_eq_Ioi h]\n\n@[simp]\nlemma oo_union_ci {x : X} {r R : \u211d\u22650\u221e} (h : r < R) :\n    oo x r R \u222a ci x R = oi x r := by\n  ext; simp_rw [oo, ci, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ici_eq_Ioi h]\n\n@[simp]\nlemma cc_union_oi {x : X} {r R : \u211d\u22650\u221e} (h : r \u2264 R) : cc x r R \u222a oi x R = ci x r := by\n  ext; simp_rw [cc, oi, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioi_eq_Ici h]\n\n@[simp]\nlemma co_union_ci {x : X} {r R : \u211d\u22650\u221e} (h : r \u2264 R) : co x r R \u222a ci x R = ci x r := by\n  ext; simp_rw [co, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ici_eq_Ici h]\n\n\nvariable [MeasurableSpace X] [OpensMeasurableSpace X]\n\n@[measurability]\n lemma measurableSet_oo {x : X} {r R : \u211d\u22650\u221e} : MeasurableSet (oo x r R) := by\n  by_cases hr : r = \u22a4\n  \u00b7 simp [hr]\n  replace hr : r < \u22a4 := Ne.lt_top hr\n  by_cases hR : R = \u22a4\n  \u00b7 simp [hR, oo_eq_of_top hr, measurableSet_closedBall]\n  rw [oo_eq_of_lt_top hr (Ne.lt_top hR)]\n  measurability\n\n@[measurability]\nlemma measurableSet_oc {x : X} {r R : \u211d\u22650\u221e} : MeasurableSet (oc x r R) := by\n  by_cases hr : r = \u22a4\n  \u00b7 simp [hr]\n  replace hr : r < \u22a4 := Ne.lt_top hr\n  by_cases hR : R = \u22a4\n  \u00b7 simp [hR, oc_eq_of_top hr, measurableSet_closedBall]\n  rw [oc_eq_of_lt_top hr (Ne.lt_top hR)]\n  measurability\n\n", "theoremStatement": "@[measurability]\nlemma measurableSet_co {x : X} {r R : \u211d\u22650\u221e} : MeasurableSet (co x r R) ", "theoremName": "Set.EAnnulus.measurableSet_co", "fileCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "theoremCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "file": "carleson/Carleson/ToMathlib/Annulus.lean", "module": "Carleson.ToMathlib.Annulus", "jsonFile": "Carleson.ToMathlib.Annulus.jsonl", "positionMetadata": {"lineInFile": 536, "tokenPositionInFile": 21127, "theoremPositionInFile": 125}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 4, "numPremises": 61}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  by_cases hr : r = \u22a4\n  \u00b7 simp [hr]\n  replace hr : r < \u22a4 := Ne.lt_top hr\n  by_cases hR : R = \u22a4\n  \u00b7 simp [hR, co_eq_of_top hr, measurableSet_ball]\n  rw [co_eq_of_lt_top hr (Ne.lt_top hR)]\n  measurability", "proofType": "tactic", "proofLengthLines": 7, "proofLengthTokens": 208}}
{"srcContext": "/-\nCopyright (c) 2024 James Sundstrom. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: James Sundstrom\n-/\nimport Mathlib.MeasureTheory.Constructions.BorelSpace.Metric\n\n/-!\n# Annulus\n\nIn this file we define an annulus in a pseudometric space `X` to be a set consisting of all `y`\nsuch that `dist x y` lies in an interval between `r` and `R`. An annulus is defined for each type\nof interval (`Ioo`, `Ioc`, etc.) with a parallel naming scheme, except that we do not define annuli\nfor `Iio` and `Ico`, as they would be balls.\n\nWe also define `EAnnulus` similarly using `edist` instead of `dist`.\n\n## Tags\n\nannulus, eannulus\n-/\n\nopen Set Metric ENNReal\n\nvariable {X : Type*} [PseudoMetricSpace X]\n\nnamespace Set\n\nnamespace Annulus\n\ndef oo (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d) := {y | dist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d) := {y | dist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d) := {y | dist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d) := {y | dist x y \u2208 Ici r}\n\n", "theoremStatement": "lemma oo_eq {x : X} {r R : \u211d} : oo x r R = ball x R \u2229 (closedBall x r)\u1d9c ", "theoremName": "Set.Annulus.oo_eq", "fileCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "theoremCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "file": "carleson/Carleson/ToMathlib/Annulus.lean", "module": "Carleson.ToMathlib.Annulus", "jsonFile": "Carleson.ToMathlib.Annulus.jsonl", "positionMetadata": {"lineInFile": 38, "tokenPositionInFile": 1088, "theoremPositionInFile": 6}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 1, "numPremises": 49}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  ext; simp [oo, dist_comm, and_comm]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 43}}
{"srcContext": "/-\nCopyright (c) 2024 Joris Roos. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joris Roos, S\u00e9bastien Gou\u00ebzel\n-/\n\nimport Mathlib.Analysis.Convex.PartitionOfUnity\nimport Mathlib.Analysis.Calculus.ContDiff.Basic\nimport Mathlib.MeasureTheory.Integral.Average\nimport Mathlib.MeasureTheory.Integral.Bochner\nimport Mathlib.MeasureTheory.Integral.Prod\nimport Mathlib.MeasureTheory.Measure.Haar.OfBasis\nimport Mathlib.Topology.MetricSpace.Holder\nimport Mathlib.Data.Set.Card\nimport Mathlib.Data.Real.ENatENNReal\nimport Carleson.ToMathlib.Misc\n\n/-!\n\nEXPERIMENTAL\n\n# Bounded compactly supported functions\n\nThe purpose of this file is to provide helper lemmas to streamline proofs that\nfunctions are (essentially) bounded, compactly supported and measurable.\n\nMost functions we need to deal with are of this class.\nThis can be a useful way to streamline proofs of `L^p` membership,\nin particular integrability.\n\nTodo: make `Mathlib.Tactic.FunProp` work for this\n\nThis can be expanded as needed\n\n-/\n\nset_option linter.unusedSectionVars false -- remove for mathlib\n\nnamespace MeasureTheory\n\nopen Bornology Function Set HasCompactSupport\nopen scoped ENNReal\n\nsection\n\n-- This setting should be enough for this project, but\n-- for mathlib should generalize to vector-valued, and use `MeasurableSpace X`, `Measure \u03bc`\nvariable {X \ud835\udd5c} [MeasurableSpace X] [RCLike \ud835\udd5c] {f : X \u2192 \ud835\udd5c} {\u03bc : Measure X}\nvariable [TopologicalSpace X]\n-- variable [T2Space X] -- for mathlib should remove this\n-- variable [IsFiniteMeasureOnCompacts \u03bc]\n-- variable [SigmaFinite (volume : Measure X)]\n\n/-- Bounded compactly supported measurable functions -/\n-- There are various alternative definitions one could use here\n-- After all it does seem to be better to use `IsBounded (range f)`\n-- Todo: Refactor accordingly\nstructure BoundedCompactSupport (f : X \u2192 \ud835\udd5c) : Prop where\n  isBounded : IsBounded (range f)\n  stronglyMeasurable : StronglyMeasurable f\n  hasCompactSupport : HasCompactSupport f\n\n", "theoremStatement": "lemma isBounded_range_iff_forall_norm_le {\u03b1 \u03b2} [SeminormedAddCommGroup \u03b1] {f : \u03b2 \u2192 \u03b1} :\n    IsBounded (range f) \u2194 \u2203 C, \u2200 x, \u2016f x\u2016 \u2264 C ", "theoremName": "MeasureTheory.isBounded_range_iff_forall_norm_le", "fileCreated": {"commit": "ec175b9008144d009269ce427b9ad43dbd70d0a5", "date": "2024-12-09"}, "theoremCreated": {"commit": "ec175b9008144d009269ce427b9ad43dbd70d0a5", "date": "2024-12-09"}, "file": "carleson/Carleson/ToMathlib/BoundedCompactSupport.lean", "module": "Carleson.ToMathlib.BoundedCompactSupport", "jsonFile": "Carleson.ToMathlib.BoundedCompactSupport.jsonl", "positionMetadata": {"lineInFile": 63, "tokenPositionInFile": 2001, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 41}, "proofMetadata": {"hasProof": true, "proof": ":= by convert isBounded_iff_forall_norm_le; simp", "proofType": "tactic", "proofLengthLines": 0, "proofLengthTokens": 48}}
{"srcContext": "import Mathlib.MeasureTheory.Integral.MeanInequalities\nimport Mathlib.MeasureTheory.Integral.Layercake\nimport Mathlib.MeasureTheory.Integral.Lebesgue\nimport Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar\nimport Mathlib.Analysis.SpecialFunctions.Pow.Integral\nimport Carleson.ToMathlib.ENorm\nimport Carleson.ToMathlib.Misc\n\nnoncomputable section\n\nopen NNReal ENNReal NormedSpace MeasureTheory Set Filter Topology Function\n\nsection move\n\n\nvariable {\u03b1 \ud835\udd5c E : Type*} {m : MeasurableSpace \u03b1}\n  {\u03bc : Measure \u03b1} [NontriviallyNormedField \ud835\udd5c]\n  [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]\n  {p : \u211d\u22650\u221e}\n\n-- todo: move/rename/and perhaps reformulate in terms of \u2016.\u2016\u2091\nlemma ENNNorm_absolute_homogeneous {c : \ud835\udd5c} (z : E) : ofNNReal \u2016c \u2022 z\u2016\u208a = \u2191\u2016c\u2016\u208a * \u2191\u2016z\u2016\u208a :=\n  (toReal_eq_toReal_iff' coe_ne_top coe_ne_top).mp (norm_smul c z)\n\nlemma ENNNorm_add_le (y z : E) : ofNNReal \u2016y + z\u2016\u208a \u2264 \u2191\u2016y\u2016\u208a + \u2191\u2016z\u2016\u208a :=\n  (toReal_le_toReal coe_ne_top coe_ne_top).mp (nnnorm_add_le ..)\n\nlemma measure_mono_ae' {A B : Set \u03b1} (h : \u03bc (B \\ A) = 0) :\n    \u03bc B \u2264 \u03bc A := by\n  apply measure_mono_ae\n  change \u03bc {x | \u00ac B x \u2264 A x} = 0\n  simp only [le_Prop_eq, Classical.not_imp]\n  exact h\n\n\nlemma eLpNormEssSup_toReal_le {f : \u03b1 \u2192 \u211d\u22650\u221e} :\n    eLpNormEssSup (ENNReal.toReal \u2218 f) \u03bc \u2264 eLpNormEssSup f \u03bc := by\n  simp_rw [eLpNormEssSup, enorm_eq_self]\n  apply essSup_mono_ae\n  apply Eventually.of_forall\n  simp [implies_true]\n\nlemma eLpNormEssSup_toReal_eq {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : \u2200\u1d50 x \u2202\u03bc, f x \u2260 \u221e) :\n    eLpNormEssSup (ENNReal.toReal \u2218 f) \u03bc = eLpNormEssSup f \u03bc := by\n  simp_rw [eLpNormEssSup, enorm_eq_self]\n  apply essSup_congr_ae\n  filter_upwards [hf] with x hx\n  simp [hx]\n\nlemma eLpNorm'_toReal_le {f : \u03b1 \u2192 \u211d\u22650\u221e} {p : \u211d} (hp : 0 \u2264 p) :\n    eLpNorm' (ENNReal.toReal \u2218 f) p \u03bc \u2264 eLpNorm' f p \u03bc := by\n  simp_rw [eLpNorm', enorm_eq_self]\n  gcongr\n  simp\n\nlemma eLpNorm'_toReal_eq {f : \u03b1 \u2192 \u211d\u22650\u221e} {p : \u211d} (hf : \u2200\u1d50 x \u2202\u03bc, f x \u2260 \u221e) :\n    eLpNorm' (ENNReal.toReal \u2218 f) p \u03bc = eLpNorm' f p \u03bc := by\n  simp_rw [eLpNorm', enorm_eq_self]\n  congr 1\n  apply lintegral_congr_ae\n  filter_upwards [hf] with x hx\n  simp [hx]\n\nlemma eLpNorm_toReal_le {f : \u03b1 \u2192 \u211d\u22650\u221e} :\n    eLpNorm (ENNReal.toReal \u2218 f) p \u03bc \u2264 eLpNorm f p \u03bc := by\n  simp_rw [eLpNorm]\n  split_ifs\n  \u00b7 rfl\n  \u00b7 exact eLpNormEssSup_toReal_le\n  \u00b7 exact eLpNorm'_toReal_le toReal_nonneg\n\nlemma eLpNorm_toReal_eq {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : \u2200\u1d50 x \u2202\u03bc, f x \u2260 \u221e) :\n    eLpNorm (ENNReal.toReal \u2218 f) p \u03bc = eLpNorm f p \u03bc := by\n  simp_rw [eLpNorm]\n  split_ifs\n  \u00b7 rfl\n  \u00b7 exact eLpNormEssSup_toReal_eq hf\n  \u00b7 exact eLpNorm'_toReal_eq hf\n\nend move\n\nnamespace MeasureTheory\n\nvariable {\u03b1 \u03b1' \u03b5 \u03b5\u2081 \u03b5\u2082 \u03b5\u2083 \ud835\udd5c E E\u2081 E\u2082 E\u2083 : Type*} {m : MeasurableSpace \u03b1} {m : MeasurableSpace \u03b1'}\n  {p p' q : \u211d\u22650\u221e} {c : \u211d\u22650}\n  {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b1'} [NontriviallyNormedField \ud835\udd5c]\n  [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]\n  [NormedAddCommGroup E\u2081] [NormedSpace \ud835\udd5c E\u2081]\n  [NormedAddCommGroup E\u2082] [NormedSpace \ud835\udd5c E\u2082]\n  [NormedAddCommGroup E\u2083] [NormedSpace \ud835\udd5c E\u2083]\n  (L : E\u2081 \u2192L[\ud835\udd5c] E\u2082 \u2192L[\ud835\udd5c] E\u2083)\n  {t s x y : \u211d\u22650\u221e}\n  {T : (\u03b1 \u2192 \u03b5\u2081) \u2192 (\u03b1' \u2192 \u03b5\u2082)}\n\nsection ENorm\n\nvariable [ENorm \u03b5] {f g g\u2081 g\u2082 : \u03b1 \u2192 \u03b5}\n\n/- Proofs for this file can be found in\nFolland, Real Analysis. Modern Techniques and Their Applications, section 6.3. -/\n\n/-! # The distribution function `d_f` -/\n\n/-- The distribution function of a function `f`.\nNote that unlike the notes, we also define this for `t = \u221e`.\nNote: we also want to use this for functions with codomain `\u211d\u22650\u221e`, but for those we just write\n`\u03bc { x | t < f x }` -/\ndef distribution (f : \u03b1 \u2192 \u03b5) (t : \u211d\u22650\u221e) (\u03bc : Measure \u03b1) : \u211d\u22650\u221e :=\n  \u03bc { x | t < \u2016f x\u2016\u2091 }\n\n@[gcongr]\nlemma distribution_mono_right (h : t \u2264 s) : distribution f s \u03bc \u2264 distribution f t \u03bc :=\n  measure_mono fun _ a \u21a6 lt_of_le_of_lt h a\n\nlemma distribution_mono_right' : (Antitone (fun t \u21a6 distribution f t \u03bc)) :=\n  fun _ _ h \u21a6 distribution_mono_right h\n\n@[measurability, fun_prop]\nlemma distribution_measurable\u2080 : Measurable (fun t \u21a6 distribution f t \u03bc) :=\n  Antitone.measurable (distribution_mono_right' (f := f) (\u03bc := \u03bc))\n\n@[measurability, fun_prop]\nlemma distribution_measurable {g : \u03b1' \u2192 \u211d\u22650\u221e} (hg : Measurable g) :\n    Measurable (fun y : \u03b1' \u21a6 distribution f (g y) \u03bc) := by\n  fun_prop\n\nlemma distribution_toReal_le {f : \u03b1 \u2192 \u211d\u22650\u221e} :\n    distribution (ENNReal.toReal \u2218 f) t \u03bc \u2264 distribution f t \u03bc := by\n  simp_rw [distribution]\n  apply measure_mono\n  simp_rw [comp_apply, enorm_eq_self, setOf_subset_setOf]\n  intro x hx\n  exact hx.trans_le enorm_toReal_le\n\n", "theoremStatement": "lemma distribution_toReal_eq {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : \u2200\u1d50 x \u2202\u03bc, f x \u2260 \u221e) :\n    distribution (ENNReal.toReal \u2218 f) t \u03bc = distribution f t \u03bc ", "theoremName": "MeasureTheory.distribution_toReal_eq", "fileCreated": {"commit": "1a36cbeaee9466fb56c9aca49ef373f9f9cc7ab7", "date": "2025-01-23"}, "theoremCreated": {"commit": "451f4568375c1be265a0beb82adb601f9a3ee74d", "date": "2025-01-20"}, "file": "carleson/Carleson/ToMathlib/WeakType.lean", "module": "Carleson.ToMathlib.WeakType", "jsonFile": "Carleson.ToMathlib.WeakType.jsonl", "positionMetadata": {"lineInFile": 135, "tokenPositionInFile": 4377, "theoremPositionInFile": 15}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 4, "numPremises": 55}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  refine measure_congr (.set_eq ?_)\n  filter_upwards [hf] with x hx\n  simp [hx]", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 85}}
{"srcContext": "import Carleson.Forest\nimport Carleson.ToMathlib.HardyLittlewood\nimport Carleson.ToMathlib.BoundedCompactSupport\nimport Carleson.ToMathlib.Misc\nimport Carleson.Psi\n\nopen ShortVariables TileStructure\nvariable {X : Type*} {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102} {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X}\n  [MetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] [TileStructure Q D \u03ba S o]\n  {n j j' : \u2115} {t : Forest X n} {u u\u2081 u\u2082 p : \ud835\udd13 X} {x x' : X} {\ud835\udd16 : Set (\ud835\udd13 X)}\n  {f f\u2081 f\u2082 g g\u2081 g\u2082 : X \u2192 \u2102} {I J J' L : Grid X}\nvariable {E' : Type*} [NormedAddCommGroup E'] [NormedSpace \u211d E']\n\nnoncomputable section\n\nopen Set MeasureTheory Metric Function Complex Bornology TileStructure Classical Filter\nopen scoped NNReal ENNReal ComplexConjugate\n\nnamespace TileStructure.Forest\n\n/-! ## Section 7.1 and Lemma 7.1.3 -/\n\nvariable (t) in\n/-- The definition `\u03c3(u, x)` given in Section 7.1.\nWe may assume `u \u2208 t` whenever proving things about this definition. -/\ndef \u03c3 (u : \ud835\udd13 X) (x : X) : Finset \u2124 := .image \ud835\udd30 { p | p \u2208 t u \u2227 x \u2208 E p }\n\nvariable (t) in\n", "theoremStatement": "private lemma exists_p_of_mem_\u03c3 (u : \ud835\udd13 X) (x : X) {s : \u2124} (hs : s \u2208 t.\u03c3 u x) :\n    \u2203 p \u2208 t.\ud835\udd17 u, x \u2208 E p \u2227 \ud835\udd30 p = s ", "theoremName": "TileStructure.Forest.exists_p_of_mem_\u03c3", "fileCreated": {"commit": "5e49c3692f6d7344434caa7eea5f412f0ee35863", "date": "2024-09-27"}, "theoremCreated": {"commit": "3298f748e9eb26a242da5ee38cb50dc55e604935", "date": "2025-01-08"}, "file": "carleson/Carleson/ForestOperator/PointwiseEstimate.lean", "module": "Carleson.ForestOperator.PointwiseEstimate", "jsonFile": "Carleson.ForestOperator.PointwiseEstimate.jsonl", "positionMetadata": {"lineInFile": 29, "tokenPositionInFile": 1001, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": null, "numInFilePremises": null, "repositoryPremises": null, "numRepositoryPremises": null, "numPremises": null}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  have \u27e8p, hp\u27e9 := Finset.mem_image.mp hs\n  simp only [mem_\ud835\udd17, Finset.mem_filter] at hp\n  use p, hp.1.2.1, hp.1.2.2, hp.2", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 125}}
{"srcContext": "import Carleson.Discrete.Defs\nimport Mathlib.Combinatorics.Enumerative.DoubleCounting\nimport Carleson.Antichain.AntichainOperator\nimport Carleson.Discrete.SumEstimates\n\nopen MeasureTheory Measure NNReal Metric Complex Set\nopen scoped ENNReal\nopen Classical -- We use quite some `Finset.filter`\nnoncomputable section\n\nopen scoped ShortVariables\nvariable {X : Type*} {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102} {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X}\n  [MetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] [TileStructure Q D \u03ba S o]\n\nvariable {k n j l : \u2115} {p p' u u' : \ud835\udd13 X} {x : X}\n\n/-! ## Section 5.5 and Lemma 5.1.3 -/\n\n/-- The set \ud835\udd13_{G\\G'} in the blueprint -/\ndef \ud835\udd13pos : Set (\ud835\udd13 X) := { p : \ud835\udd13 X | 0 < volume (\ud835\udcd8 p \u2229 G \u2229 G'\u1d9c) }\n\nlemma exists_mem_aux\ud835\udcd2 {i : Grid X} (hi : 0 < volume (G \u2229 i)) : \u2203 k, i \u2208 aux\ud835\udcd2 (k + 1) := by\n  have vlt : volume (i : Set X) < \u22a4 := volume_coeGrid_lt_top\n  have one_le_quot : 1 \u2264 volume (i : Set X) / volume (G \u2229 i) := by\n    rw [ENNReal.le_div_iff_mul_le (Or.inl hi.ne') (Or.inr vlt.ne), one_mul]\n    exact measure_mono inter_subset_right\n  have quot_ne_top : volume (i : Set X) / volume (G \u2229 i) \u2260 \u22a4 := by\n    rw [Ne, ENNReal.div_eq_top, not_or, not_and_or, not_and_or]\n    exact \u27e8Or.inr hi.ne', Or.inl vlt.ne\u27e9\n  have ornz : 0 < (volume (i : Set X) / volume (G \u2229 i)).toReal :=\n    ENNReal.toReal_pos (zero_lt_one.trans_le one_le_quot).ne' quot_ne_top\n  let k : \u211d := Real.logb 2 (volume (i : Set X) / volume (G \u2229 i)).toReal\n  use \u230ak\u230b\u208a, i, le_rfl\n  nth_rw 1 [\u2190 ENNReal.mul_lt_mul_left (show 2 ^ (\u230ak\u230b\u208a + 1) \u2260 0 by simp) (by simp), \u2190 mul_assoc,\n    \u2190 ENNReal.rpow_natCast, \u2190 ENNReal.rpow_intCast, \u2190 ENNReal.rpow_add _ _ (by simp) (by simp)]\n  rw [Int.cast_neg, Int.cast_natCast, add_neg_cancel, ENNReal.rpow_zero, one_mul,\n    \u2190 ENNReal.div_lt_iff (Or.inl hi.ne') (Or.inr vlt.ne), \u2190 ENNReal.ofReal_toReal quot_ne_top,\n    \u2190 @ENNReal.ofReal_toReal (2 ^ (\u230ak\u230b\u208a + 1)) (by simp), ENNReal.ofReal_lt_ofReal_iff (by simp),\n    ENNReal.toReal_pow, ENNReal.toReal_ofNat, \u2190 Real.rpow_natCast,\n    \u2190 Real.logb_lt_iff_lt_rpow one_lt_two ornz]\n  exact Nat.lt_succ_floor k\n\nlemma exists_k_of_mem_\ud835\udd13pos (h : p \u2208 \ud835\udd13pos (X := X)) : \u2203 k, p \u2208 TilesAt k := by\n  let C : Set \u2115 := {k | \ud835\udcd8 p \u2208 aux\ud835\udcd2 k}\n  have Cn : C.Nonempty := by\n    rw [\ud835\udd13pos, mem_setOf] at h\n    have vpos : 0 < volume (G \u2229 \ud835\udcd8 p) := by\n      rw [inter_comm]; exact h.trans_le (measure_mono inter_subset_left)\n    obtain \u27e8k, hk\u27e9 := exists_mem_aux\ud835\udcd2 vpos; exact \u27e8_, hk\u27e9\n  let s : \u2115 := WellFounded.min wellFounded_lt _ Cn\n  have s_mem : s \u2208 C := WellFounded.min_mem ..\n  have s_min : \u2200 t \u2208 C, s \u2264 t := fun t mt \u21a6 WellFounded.min_le _ mt _\n  have s_pos : 0 < s := by\n    by_contra! h; rw [nonpos_iff_eq_zero] at h\n    simp_rw [h, C, aux\ud835\udcd2, mem_setOf] at s_mem; apply absurd s_mem; push_neg; intro _ _\n    rw [Int.neg_ofNat_zero, zpow_zero, one_mul]; exact measure_mono inter_subset_right\n  use s - 1; rw [TilesAt, mem_preimage, \ud835\udcd2, mem_diff, Nat.sub_add_cancel s_pos]\n  have : \u2200 t < s, t \u2209 C := fun t mt \u21a6 by contrapose! mt; exact s_min t mt\n  exact \u27e8s_mem, this (s - 1) (Nat.sub_one_lt_of_lt s_pos)\u27e9\n\nlemma dens'_le_of_mem_\ud835\udd13pos (h : p \u2208 \ud835\udd13pos (X := X)) : dens' k {p} \u2264 2 ^ (-k : \u2124) := by\n  simp_rw [dens', mem_singleton_iff, iSup_iSup_eq_left, iSup_le_iff]; intro l hl p' mp' sl\n  have vpos : 0 < volume (\ud835\udcd8 p' : Set X) := by\n    refine lt_of_lt_of_le ?_ (measure_mono sl.1.1)\n    rw [\ud835\udd13pos, mem_setOf, inter_assoc] at h; exact h.trans_le (measure_mono inter_subset_left)\n  rw [ENNReal.div_le_iff vpos.ne' volume_coeGrid_lt_top.ne]\n  calc\n    _ \u2264 volume (E\u2082 l p') := by\n      nth_rw 2 [\u2190 one_mul (volume _)]; apply mul_le_mul_right'\n      rw [show 1 = (l : \u211d\u22650\u221e) ^ (0 : \u2124) by simp]; apply ENNReal.zpow_le_of_le\n      \u00b7 rw [ENNReal.one_le_coe_iff]; exact one_le_two.trans hl\n      \u00b7 linarith [four_le_a X]\n    _ \u2264 _ := by\n      have E : E\u2082 l p' \u2286 \ud835\udcd8 p' \u2229 G := inter_subset_left\n      rw [TilesAt, mem_preimage, \ud835\udcd2, mem_diff] at mp'; replace mp' := mp'.2\n      rw [aux\ud835\udcd2, mem_setOf] at mp'; push_neg at mp'; specialize mp' (\ud835\udcd8 p') le_rfl\n      rw [inter_comm] at E; exact (measure_mono E).trans mp'\n\nlemma exists_E\u2082_volume_pos_of_mem_\ud835\udd13pos (h : p \u2208 \ud835\udd13pos (X := X)) : \u2203 r : \u2115, 0 < volume (E\u2082 r p) := by\n  apply exists_measure_pos_of_not_measure_iUnion_null\n  change volume (\u22c3 n : \u2115, \ud835\udcd8 p \u2229 G \u2229 Q \u207b\u00b9' ball_(p) (\ud835\udcac p) n) \u2260 0\n  rw [\u2190 inter_iUnion]\n  suffices \u22c3 i : \u2115, Q \u207b\u00b9' ball_(p) (\ud835\udcac p) i = univ by\n    rw [this, inter_univ, \u2190 pos_iff_ne_zero]\n    rw [\ud835\udd13pos, mem_setOf] at h; exact h.trans_le (measure_mono inter_subset_left)\n  simp_rw [iUnion_eq_univ_iff, mem_preimage, mem_ball]\n  exact fun x \u21a6 exists_nat_gt (dist_(p) (Q x) (\ud835\udcac p))\n\nlemma dens'_pos_of_mem_\ud835\udd13pos (h : p \u2208 \ud835\udd13pos (X := X)) (hp : p \u2208 TilesAt k) : 0 < dens' k {p} := by\n  simp_rw [dens', mem_singleton_iff, iSup_iSup_eq_left, lt_iSup_iff]\n  obtain \u27e8l, hl\u27e9 := exists_E\u2082_volume_pos_of_mem_\ud835\udd13pos h\n  use max 2 l, le_max_left .., p, hp, le_rfl\n  simp_rw [ENNReal.div_pos_iff, ne_eq, mul_eq_zero, not_or, \u2190 ne_eq, \u2190 pos_iff_ne_zero]\n  refine \u27e8\u27e8ENNReal.zpow_pos (by simp) (by simp) _, ?_\u27e9, volume_coeGrid_lt_top.ne\u27e9\n  refine hl.trans_le <| measure_mono <| inter_subset_inter_right _ <| preimage_mono ?_\n  change ball_(p) (\ud835\udcac p) _ \u2286 ball_(p) (\ud835\udcac p) _\n  exact ball_subset_ball (by simp)\n\nlemma exists_k_n_of_mem_\ud835\udd13pos (h : p \u2208 \ud835\udd13pos (X := X)) : \u2203 k n, p \u2208 \u212d k n \u2227 k \u2264 n := by\n  obtain \u27e8k, mp\u27e9 := exists_k_of_mem_\ud835\udd13pos h; use k\n  have dens'_pos : 0 < dens' k {p} := dens'_pos_of_mem_\ud835\udd13pos h mp\n  have dens'_le : dens' k {p} \u2264 2 ^ (-k : \u2124) := dens'_le_of_mem_\ud835\udd13pos h\n  have dens'_lt_top : dens' k {p} < \u22a4 :=\n    dens'_le.trans_lt (ENNReal.zpow_lt_top (by simp) (by simp) _)\n  have dens'_toReal_pos : 0 < (dens' k {p}).toReal :=\n    ENNReal.toReal_pos dens'_pos.ne' dens'_lt_top.ne\n  -- 2 ^ (4 * a - n) < dens' k {p} \u2264 2 ^ (4 * a - n + 1)\n  -- 4 * a - n < log_2 dens' k {p} \u2264 4 * a - n + 1\n  -- -n < log_2 dens' k {p} - 4 * a \u2264 -n + 1\n  -- n - 1 \u2264 4 * a - log_2 dens' k {p} < n\n  -- n \u2264 4 * a - log_2 dens' k {p} + 1 < n + 1\n  -- n = 4 * a + \u230a-log_2 dens' k {p}\u230b + 1\n  let v : \u211d := -Real.logb 2 (dens' k {p}).toReal\n  have klv : k \u2264 v := by\n    rw [le_neg, Real.logb_le_iff_le_rpow one_lt_two dens'_toReal_pos,\n      show (2 : \u211d) = (2 : \u211d\u22650\u221e).toReal by rfl, ENNReal.toReal_rpow,\n      ENNReal.toReal_le_toReal dens'_lt_top.ne (by simp)]\n    exact_mod_cast dens'_le\n  have klq : k \u2264 \u230av\u230b\u208a := Nat.le_floor klv\n  let n : \u2115 := 4 * a + \u230av\u230b\u208a + 1; use n; refine \u27e8\u27e8mp, ?_\u27e9, by omega\u27e9\n  rw [show 4 * (a : \u2124) - (4 * a + \u230av\u230b\u208a + 1 : \u2115) = (-\u230av\u230b\u208a - 1 : \u2124) by omega, sub_add_cancel, mem_Ioc,\n    \u2190 ENNReal.ofReal_toReal dens'_lt_top.ne, \u2190 ENNReal.rpow_intCast, \u2190 ENNReal.rpow_intCast,\n    show (2 : \u211d\u22650\u221e) = ENNReal.ofReal (2 : \u211d) by norm_cast,\n    ENNReal.ofReal_rpow_of_pos zero_lt_two, ENNReal.ofReal_rpow_of_pos zero_lt_two,\n    ENNReal.ofReal_lt_ofReal_iff dens'_toReal_pos, ENNReal.ofReal_le_ofReal_iff (by positivity),\n    \u2190 Real.logb_le_iff_le_rpow one_lt_two dens'_toReal_pos,\n    \u2190 Real.lt_logb_iff_rpow_lt one_lt_two dens'_toReal_pos,\n    Int.cast_sub, Int.cast_neg, Int.cast_natCast, Int.cast_one, neg_sub_left, neg_lt, le_neg]\n  constructor\n  \u00b7 rw [add_comm]; exact_mod_cast Nat.lt_succ_floor _\n  \u00b7 exact Nat.floor_le ((Nat.cast_nonneg' k).trans klv)\n\nprivate lemma two_mul_n_add_six_lt : 2 * n + 6 < 2 ^ (n + 3) := by\n  induction n with\n  | zero => norm_num\n  | succ n ih =>\n    calc\n      _ = 2 * n + 6 + 2 := by ring\n      _ < 2 ^ (n + 3) + 2 := by gcongr\n      _ < 2 ^ (n + 3) + 2 ^ (n + 3) := by omega\n      _ = _ := by ring\n\nlemma exists_j_of_mem_\ud835\udd13pos_\u212d (h : p \u2208 \ud835\udd13pos (X := X)) (mp : p \u2208 \u212d k n) (hkn : k \u2264 n) :\n    p \u2208 \ud835\udd0f\u2080 k n \u2228 \u2203 j \u2264 2 * n + 3, p \u2208 \u212d\u2081 k n j := by\n  rw [\ud835\udd13pos, mem_setOf, inter_comm _ G'\u1d9c, \u2190 inter_assoc] at h\n  replace h : 0 < volume (G'\u1d9c \u2229 (\ud835\udcd8 p : Set X)) := h.trans_le (measure_mono inter_subset_left)\n  rw [inter_comm, G', compl_union, compl_union, inter_comm G\u2081\u1d9c, \u2190 inter_assoc, \u2190 inter_assoc] at h\n  replace h : 0 < volume ((\ud835\udcd8 p : Set X) \u2229 G\u2082\u1d9c) :=\n    h.trans_le (measure_mono (inter_subset_left.trans inter_subset_left))\n  obtain \u27e8x, mx, nx\u27e9 := nonempty_of_measure_ne_zero h.ne'\n  simp_rw [G\u2082, mem_compl_iff, mem_iUnion] at nx; push_neg at nx; specialize nx n k hkn\n  let B : \u2115 := Finset.card { q | q \u2208 \ud835\udd05 k n p }\n  have Blt : B < 2 ^ (2 * n + 4) := by\n    calc\n      _ \u2264 Finset.card { m | m \u2208 \ud835\udd10 k n \u2227 x \u2208 \ud835\udcd8 m } :=\n        Finset.card_le_card (Finset.monotone_filter_right _ (Pi.le_def.mpr fun m \u27e8m\u2081, m\u2082\u27e9 \u21a6\n          \u27e8m\u2081, m\u2082.1.1 mx\u27e9))\n      _ = stackSize (\ud835\udd10 k n) x := by\n        simp_rw [stackSize, indicator_apply, Pi.one_apply, Finset.sum_boole, Nat.cast_id,\n          Finset.filter_filter]; rfl\n      _ \u2264 (2 * n + 6) * 2 ^ (n + 1) := by rwa [setA, mem_setOf, not_lt] at nx\n      _ < _ := by\n        rw [show 2 * n + 4 = (n + 3) + (n + 1) by omega, pow_add _ (n + 3)]\n        exact mul_lt_mul_of_pos_right two_mul_n_add_six_lt (by positivity)\n  rcases B.eq_zero_or_pos with Bz | Bpos\n  \u00b7 simp_rw [B, filter_mem_univ_eq_toFinset, Finset.card_eq_zero, toFinset_eq_empty] at Bz\n    exact Or.inl \u27e8mp, Bz\u27e9\n  \u00b7 right; use Nat.log 2 B; rw [Nat.lt_pow_iff_log_lt one_lt_two Bpos.ne'] at Blt\n    refine \u27e8by omega, (?_ : _ \u2227 _ \u2264 B), (?_ : \u00ac(_ \u2227 _ \u2264 B))\u27e9\n    \u00b7 exact \u27e8mp, Nat.pow_log_le_self 2 Bpos.ne'\u27e9\n    \u00b7 rw [not_and, not_le]; exact fun _ \u21a6 Nat.lt_pow_succ_log_self one_lt_two _\n\nlemma exists_k_n_j_of_mem_\ud835\udd13pos (h : p \u2208 \ud835\udd13pos (X := X)) :\n    \u2203 k n, k \u2264 n \u2227 (p \u2208 \ud835\udd0f\u2080 k n \u2228 \u2203 j \u2264 2 * n + 3, p \u2208 \u212d\u2081 k n j) := by\n  obtain \u27e8k, n, mp, hkn\u27e9 := exists_k_n_of_mem_\ud835\udd13pos h\n  exact \u27e8k, n, hkn, exists_j_of_mem_\ud835\udd13pos_\u212d h mp hkn\u27e9\n\n/-- The union occurring in the statement of Lemma 5.5.1 containing \ud835\udd0f\u2080 -/\ndef \u211c\u2080 : Set (\ud835\udd13 X) := \ud835\udd13pos \u2229 \u22c3 (n : \u2115) (k \u2264 n), \ud835\udd0f\u2080 k n\n\n/-- The union occurring in the statement of Lemma 5.5.1 containing \ud835\udd0f\u2081 -/\ndef \u211c\u2081 : Set (\ud835\udd13 X) := \ud835\udd13pos \u2229 \u22c3 (n : \u2115) (k \u2264 n) (j \u2264 2 * n + 3) (l \u2264 Z * (n + 1)), \ud835\udd0f\u2081 k n j l\n\n/-- The union occurring in the statement of Lemma 5.5.1 containing \ud835\udd0f\u2082 -/\ndef \u211c\u2082 : Set (\ud835\udd13 X) := \ud835\udd13pos \u2229 \u22c3 (n : \u2115) (k \u2264 n) (j \u2264 2 * n + 3), \ud835\udd0f\u2082 k n j\n\n/-- The union occurring in the statement of Lemma 5.5.1 containing \ud835\udd0f\u2083 -/\ndef \u211c\u2083 : Set (\ud835\udd13 X) := \ud835\udd13pos \u2229 \u22c3 (n : \u2115) (k \u2264 n) (j \u2264 2 * n + 3) (l \u2264 Z * (n + 1)), \ud835\udd0f\u2083 k n j l\n\n/-- Lemma allowing to peel `\u22c3 (n : \u2115) (k \u2264 n)` from unions in the proof of Lemma 5.5.1. -/\nlemma mem_iUnion_iff_mem_of_mem_\u212d {f : \u2115 \u2192 \u2115 \u2192 Set (\ud835\udd13 X)} (hp : p \u2208 \u212d k n \u2227 k \u2264 n)\n    (hf : \u2200 k n, f k n \u2286 \u212d k n) : p \u2208 \u22c3 (n : \u2115) (k \u2264 n), f k n \u2194 p \u2208 f k n := by\n  simp_rw [mem_iUnion]; constructor <;> intro h\n  \u00b7 obtain \u27e8n', k', _, mp\u27e9 := h\n    have e := pairwiseDisjoint_\u212d (X := X).elim (mem_univ (k, n)) (mem_univ (k', n'))\n      (not_disjoint_iff.mpr \u27e8p, hp.1, hf k' n' mp\u27e9)\n    rw [Prod.mk.inj_iff] at e\n    exact e.1 \u25b8 e.2 \u25b8 mp\n  \u00b7 use n, k, hp.2\n\n/-- Lemma allowing to peel `\u22c3 (j \u2264 2 * n + 3)` from unions in the proof of Lemma 5.5.1. -/\nlemma mem_iUnion_iff_mem_of_mem_\u212d\u2081 {f : \u2115 \u2192 Set (\ud835\udd13 X)} (hp : p \u2208 \u212d\u2081 k n j \u2227 j \u2264 2 * n + 3)\n    (hf : \u2200 j, f j \u2286 \u212d\u2081 k n j) : p \u2208 \u22c3 (j \u2264 2 * n + 3), f j \u2194 p \u2208 f j := by\n  simp_rw [mem_iUnion]; constructor <;> intro h\n  \u00b7 obtain \u27e8j', _, mp\u27e9 := h\n    have e := pairwiseDisjoint_\u212d\u2081 (X := X).elim (mem_univ j) (mem_univ j')\n      (not_disjoint_iff.mpr \u27e8p, hp.1, hf j' mp\u27e9)\n    exact e \u25b8 mp\n  \u00b7 use j, hp.2\n\nlemma nmem_\u212d\u2085_iff_mem_\ud835\udd0f\u2083 (hkn : k \u2264 n) (hj : j \u2264 2 * n + 3)\n    (h : p \u2208 \ud835\udd13pos) (mc2 : p \u2208 \u212d\u2082 k n j) (ml2 : p \u2209 \ud835\udd0f\u2082 k n j) :\n    p \u2209 \u212d\u2085 k n j \u2194 p \u2208 \u22c3 l, \u22c3 (_ : l \u2264 Z * (n + 1)), \ud835\udd0f\u2083 k n j l := by\n  have mc3 : p \u2208 \u212d\u2083 k n j := \u27e8mc2, ml2\u27e9\n  by_cases mc4 : p \u2209 \u212d\u2084 k n j\n  all_goals\n    have mc4' := mc4\n    simp_rw [\u212d\u2084, layersBelow, mem_diff, not_and, mc3, true_implies, not_not_mem] at mc4'\n  \u00b7 change p \u2208 \u22c3 (l \u2264 Z * (n + 1)), \ud835\udd0f\u2083 k n j l at mc4'\n    simp_rw [mc4', iff_true]; contrapose! mc4\n    exact \u212d\u2085_subset_\u212d\u2084 mc4\n  change p \u2209 \u22c3 (l \u2264 Z * (n + 1)), \ud835\udd0f\u2083 k n j l at mc4'\n  simp_rw [mc4', iff_false, \u212d\u2085]; rw [not_not_mem] at mc4 \u22a2; simp_rw [mem_diff, mc4, true_and]\n  have nG\u2083 : \u00ac(\ud835\udcd8 p : Set X) \u2286 G\u2083 := by\n    suffices \u00ac(\ud835\udcd8 p : Set X) \u2286 G' by contrapose! this; exact subset_union_of_subset_right this _\n    by_contra hv\n    rw [\ud835\udd13pos, mem_setOf, inter_comm _ G'\u1d9c, \u2190 inter_assoc, \u2190 diff_eq_compl_inter,\n      diff_eq_empty.mpr hv] at h\n    simp at h\n  contrapose! nG\u2083\n  exact le_iSup\u2082_of_le n k <| le_iSup\u2082_of_le hkn j <|\n    le_iSup\u2082_of_le hj p <| le_iSup_of_le nG\u2083 Subset.rfl\n\n\n/-- Lemma 5.5.1.\n\nWe will not use the lemma in this form, as to decompose the Carleson sum it is also crucial that\nthe union is disjoint. This is easier to formalize by decomposing into successive terms, taking\nadvantage of disjointess at each step, instead of doing everything in one go. Still, we keep this\nlemma as it corresponds to the blueprint, and the key steps of its proof will also be the key steps\nwhen doing the successive decompositions.\n -/\nlemma antichain_decomposition : \ud835\udd13pos (X := X) \u2229 \ud835\udd13\u2081\u1d9c = \u211c\u2080 \u222a \u211c\u2081 \u222a \u211c\u2082 \u222a \u211c\u2083 := by\n  unfold \u211c\u2080 \u211c\u2081 \u211c\u2082 \u211c\u2083 \ud835\udd13\u2081; simp_rw [\u2190 inter_union_distrib_left]; ext p\n  simp_rw [mem_inter_iff, and_congr_right_iff, mem_compl_iff, mem_union]; intro h\n  obtain \u27e8k, n, hkn, split\u27e9 := exists_k_n_j_of_mem_\ud835\udd13pos h\n  have pc : p \u2208 \u212d k n := by\n    rcases split with ml0 | \u27e8_, _, mc1\u27e9\n    \u00b7 exact \ud835\udd0f\u2080_subset_\u212d ml0\n    \u00b7 exact \u212d\u2081_subset_\u212d mc1\n  iterate 5 rw [mem_iUnion_iff_mem_of_mem_\u212d \u27e8pc, hkn\u27e9]\n  pick_goal 5; \u00b7 exact fun _ _ \u21a6 \ud835\udd0f\u2080_subset_\u212d\n  pick_goal 4; \u00b7 exact fun _ _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 \ud835\udd0f\u2081_subset_\u212d\n  pick_goal 3; \u00b7 exact fun _ _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 \ud835\udd0f\u2082_subset_\u212d\n  pick_goal 2; \u00b7 exact fun _ _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 \ud835\udd0f\u2083_subset_\u212d\n  pick_goal -1; \u00b7 exact fun _ _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 \u212d\u2085_subset_\u212d\n  by_cases ml0 : p \u2208 \ud835\udd0f\u2080 k n\n  \u00b7 simp_rw [ml0, true_or, iff_true, mem_iUnion\u2082]; push_neg; intros\n    exact fun a \u21a6 disjoint_left.mp \ud835\udd0f\u2080_disjoint_\u212d\u2081 ml0 (\u212d\u2085_subset_\u212d\u2081 a)\n  simp_rw [ml0, false_or] at split \u22a2\n  obtain \u27e8j, hj, mc1\u27e9 := split\n  iterate 4 rw [mem_iUnion_iff_mem_of_mem_\u212d\u2081 \u27e8mc1, hj\u27e9]\n  pick_goal 4; \u00b7 exact fun _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 \ud835\udd0f\u2081_subset_\u212d\u2081\n  pick_goal 3; \u00b7 exact fun _ \u21a6 \ud835\udd0f\u2082_subset_\u212d\u2081\n  pick_goal 2; \u00b7 exact fun _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 \ud835\udd0f\u2083_subset_\u212d\u2081\n  pick_goal -1; \u00b7 exact fun _ \u21a6 \u212d\u2085_subset_\u212d\u2081\n  by_cases mc2 : p \u2209 \u212d\u2082 k n j\n  all_goals\n    have mc2' := mc2\n    simp_rw [\u212d\u2082, layersAbove, mem_diff, not_and, mc1, true_implies, not_not_mem] at mc2'\n  \u00b7 change p \u2208 \u22c3 (l \u2264 Z * (n + 1)), \ud835\udd0f\u2081 k n j l at mc2'\n    simp_rw [mc2', true_or, iff_true]; contrapose! mc2\n    exact \u212d\u2085_subset_\u212d\u2084.trans \u212d\u2084_subset_\u212d\u2083 |>.trans \u212d\u2083_subset_\u212d\u2082 mc2\n  change p \u2209 \u22c3 (l \u2264 Z * (n + 1)), \ud835\udd0f\u2081 k n j l at mc2'; simp_rw [mc2', false_or]\n  rw [not_not_mem] at mc2; by_cases ml2 : p \u2208 \ud835\udd0f\u2082 k n j\n  \u00b7 simp_rw [ml2, true_or, iff_true]\n    exact fun a \u21a6 disjoint_left.mp \ud835\udd0f\u2082_disjoint_\u212d\u2083 ml2 (\u212d\u2085_subset_\u212d\u2084.trans \u212d\u2084_subset_\u212d\u2083 a)\n  simp_rw [ml2, false_or]\n  exact nmem_\u212d\u2085_iff_mem_\ud835\udd0f\u2083 hkn hj h mc2 ml2\n\n/-- The subset `\ud835\udd0f\u2080(k, n, l)` of `\ud835\udd0f\u2080(k, n)`, given in Lemma 5.5.3.\n  We use the name `\ud835\udd0f\u2080'` in Lean. -/\ndef \ud835\udd0f\u2080' (k n l : \u2115) : Set (\ud835\udd13 X) := (\ud835\udd0f\u2080 k n).minLayer l\n\n/-- Logarithmic inequality used in the proof of Lemma 5.5.2. -/\nlemma ceil_log2_le_floor_four_add_log2 {l : \u211d} (hl : 2 \u2264 l) :\n    \u2308Real.logb 2 ((l + 6 / 5) / 5\u207b\u00b9)\u2309\u208a \u2264 \u230a4 + Real.logb 2 l\u230b\u208a := by\n  have : 2 \u2264 Real.logb 2 (l + 6 / 5) + Real.logb 2 5 :=\n    calc\n      _ \u2265 Real.logb 2 (2 ^ (0 : \u211d)) + Real.logb 2 (2 ^ (2 : \u211d)) :=\n        add_le_add\n          (Real.logb_le_logb_of_le one_lt_two (by positivity) (by linarith))\n          (Real.logb_le_logb_of_le one_lt_two (by positivity) (by norm_num))\n      _ \u2265 _ := by simp_rw [Real.logb_rpow zero_lt_two one_lt_two.ne']; norm_num\n  rw [div_inv_eq_mul, Real.logb_mul (by positivity) (by positivity), Nat.le_floor_iff']\n  \u00b7 calc\n      _ \u2264 1 + Real.logb 2 (l + 6 / 5) + Real.logb 2 5 := by\n        rw [add_rotate]; exact (Nat.ceil_lt_add_one (zero_le_two.trans this)).le\n      _ \u2264 1 + Real.logb 2 (8 / 5 * l) + Real.logb 2 5 := by\n        gcongr\n        \u00b7 exact one_lt_two\n        \u00b7 linarith\n      _ = _ := by\n        rw [add_assoc, \u2190 Real.logb_mul (by positivity) (by positivity), \u2190 mul_rotate,\n          show (5 : \u211d) * (8 / 5) = 2 ^ 3 by norm_num,\n          Real.logb_mul (by positivity) (by positivity), \u2190 Real.rpow_natCast,\n          Real.logb_rpow zero_lt_two one_lt_two.ne', \u2190 add_assoc]\n        norm_num\n  \u00b7 exact (zero_lt_one.trans_le (Nat.one_le_ceil_iff.mpr (zero_lt_two.trans_le this))).ne'\n\n/-- The set `\ud835\udd12` in the proof of Lemma 5.5.2. -/\ndef \ud835\udd12 (p' : \ud835\udd13 X) (l : \u211d\u22650) : Finset (\ud835\udd13 X) :=\n  {p'' | \ud835\udcd8 p'' = \ud835\udcd8 p' \u2227 \u00acDisjoint (ball_(p') (\ud835\udcac p') l) (\u03a9 p'')}\n\nlemma card_\ud835\udd12 (p' : \ud835\udd13 X) {l : \u211d\u22650} (hl : 2 \u2264 l) : (\ud835\udd12 p' l).card \u2264 \u230a2 ^ (4 * a) * l ^ a\u230b\u208a := by\n  have djO : (\ud835\udd12 p' l).toSet.PairwiseDisjoint fun p'' \u21a6 ball_(p') (\ud835\udcac p'') 5\u207b\u00b9 :=\n    fun p\u2081 mp\u2081 p\u2082 mp\u2082 hn \u21a6 by\n      simp_rw [\ud835\udd12, Finset.coe_filter, mem_setOf, Finset.mem_univ, true_and] at mp\u2081 mp\u2082\n      change Disjoint (ball_{\ud835\udcd8 p'} (\ud835\udcac p\u2081) 5\u207b\u00b9) (ball_{\ud835\udcd8 p'} (\ud835\udcac p\u2082) 5\u207b\u00b9)\n      conv => enter [1]; rw [\u2190 mp\u2081.1]\n      conv => enter [2]; rw [\u2190 mp\u2082.1]\n      exact cball_disjoint hn (mp\u2081.1.trans mp\u2082.1.symm)\n  have tO : \u2200 p'' \u2208 \ud835\udd12 p' l,\n      ball_(p') (\ud835\udcac p'') 5\u207b\u00b9 \u2286 ball_(p') (\ud835\udcac p') (l + 6 / 5) := fun p'' mp'' \u21a6 by\n    apply ball_subset_ball'\n    simp_rw [\ud835\udd12, Finset.mem_filter, Finset.mem_univ, true_and] at mp''\n    obtain \u27e8x, mx\u2081, mx\u2082\u27e9 := not_disjoint_iff.mp mp''.2\n    replace mx\u2082 := _root_.subset_cball mx\u2082\n    rw [@mem_ball] at mx\u2081 mx\u2082\n    calc\n      _ \u2264 5\u207b\u00b9 + (dist_{\ud835\udcd8 p'} x (\ud835\udcac p'') + dist_{\ud835\udcd8 p'} x (\ud835\udcac p')) :=\n        add_le_add_left (dist_triangle_left ..) _\n      _ \u2264 5\u207b\u00b9 + (1 + l) := by gcongr; rw [\u2190 mp''.1]; exact mx\u2082.le\n      _ = _ := by rw [inv_eq_one_div, \u2190 add_assoc, add_comm _ l.toReal]; norm_num\n  have vO : CoveredByBalls (ball_(p') (\ud835\udcac p') (l + 6 / 5)) \u230a2 ^ (4 * a) * l ^ a\u230b\u208a 5\u207b\u00b9 := by\n    apply (ballsCoverBalls_iterate (show 0 < l.toReal + 6 / 5 by positivity)\n      (show 0 < 5\u207b\u00b9 by positivity) (\ud835\udcac p')).mono_nat\n    calc\n      _ \u2264 (defaultA a) ^ \u230a4 + Real.logb 2 l\u230b\u208a :=\n        pow_le_pow_right\u2080 Nat.one_le_two_pow (ceil_log2_le_floor_four_add_log2 hl)\n      _ \u2264 \u230a(defaultA a : \u211d) ^ (4 + Real.logb 2 l)\u230b\u208a := by\n        apply Nat.le_floor; rw [Nat.cast_npow, \u2190 Real.rpow_natCast]\n        refine Real.rpow_le_rpow_of_exponent_le (by exact_mod_cast Nat.one_le_two_pow)\n          (Nat.floor_le ?_)\n        calc\n          _ \u2265 4 + Real.logb 2 2 :=\n            add_le_add_left (Real.logb_le_logb_of_le one_lt_two zero_lt_two hl) _\n          _ \u2265 _ := by rw [Real.logb_self_eq_one one_lt_two]; norm_num\n      _ = _ := by\n        rw [Nat.cast_pow, Nat.cast_ofNat, \u2190 Real.rpow_natCast, \u2190 Real.rpow_mul zero_le_two,\n          mul_comm, add_mul, Real.rpow_add zero_lt_two, show (4 : \u211d) * a = (4 * a : \u2115) by simp,\n          Real.rpow_natCast, Real.rpow_mul zero_le_two, Real.rpow_natCast,\n          Real.rpow_logb zero_lt_two one_lt_two.ne']\n        congr 1; exact zero_lt_two.trans_le hl\n  obtain \u27e8(T : Finset (\u0398 X)), cT, uT\u27e9 := vO\n  refine (Finset.card_le_card_of_forall_subsingleton (fun p'' t \u21a6 \ud835\udcac p'' \u2208 ball_(p') t 5\u207b\u00b9)\n      (fun p'' mp'' \u21a6 ?_) (fun t _ o\u2081 mo\u2081 o\u2082 mo\u2082 \u21a6 ?_)).trans cT\n  \u00b7 have := (tO _ mp'').trans uT (mem_ball_self (by positivity))\n    rwa [mem_iUnion\u2082, bex_def] at this\n  \u00b7 simp_rw [mem_setOf_eq] at mo\u2081 mo\u2082; rw [@mem_ball_comm] at mo\u2081 mo\u2082\n    exact djO.elim mo\u2081.1 mo\u2082.1 (not_disjoint_iff.mpr \u27e8t, mo\u2081.2, mo\u2082.2\u27e9)\n\nsection\n\nvariable {p' : \ud835\udd13 X} {l : \u211d\u22650} (hl : 2 \u2264 l)\n  (qp' : 2 ^ (4 * a - n : \u2124) < l ^ (-a : \u2124) * volume (E\u2082 l p') / volume (\ud835\udcd8 p' : Set X))\ninclude hl qp'\n\nlemma lt_quotient_rearrange :\n    (2 ^ (4 * a) * l ^ a : \u211d\u22650) * 2 ^ (-n : \u2124) < volume (E\u2082 l p') / volume (\ud835\udcd8 p' : Set X) := by\n  rw [mul_div_assoc] at qp'; convert ENNReal.div_lt_of_lt_mul' qp' using 1\n  rw [ENNReal.div_eq_inv_mul,\n    \u2190 ENNReal.zpow_neg (by exact_mod_cast (zero_lt_two.trans_le hl).ne') ENNReal.coe_ne_top,\n    neg_neg, ENNReal.coe_mul, mul_rotate, mul_assoc, ENNReal.coe_pow, zpow_natCast]\n  congr 1\n  rw [ENNReal.coe_pow, ENNReal.coe_ofNat, \u2190 zpow_natCast,\n    \u2190 ENNReal.zpow_add two_ne_zero ENNReal.ofNat_ne_top]\n  congr 1; omega\n\nlemma l_upper_bound : l < 2 ^ n := by\n  have ql1 : volume (E\u2082 l p') / volume (\ud835\udcd8 p' : Set X) \u2264 1 := by\n    apply ENNReal.div_le_of_le_mul; rw [one_mul]; exact measure_mono (E\u2082_subset ..)\n  replace qp' := (lt_quotient_rearrange hl qp').trans_le ql1\n  rw [\u2190 ENNReal.mul_lt_mul_right (c := 2 ^ (n : \u2124)) (by simp) (by simp), one_mul, mul_assoc,\n    \u2190 ENNReal.zpow_add two_ne_zero ENNReal.ofNat_ne_top, neg_add_cancel, zpow_zero, mul_one,\n    show (2 ^ (n : \u2124) : \u211d\u22650\u221e) = (2 ^ (n : \u2124) : \u211d\u22650) by simp, ENNReal.coe_lt_coe,\n    zpow_natCast] at qp'\n  calc\n    _ \u2264 l ^ a := le_self_pow\u2080 (one_le_two.trans hl) (by linarith [four_le_a X])\n    _ \u2264 2 ^ (4 * a) * l ^ a := by\n      nth_rw 1 [\u2190 one_mul (l ^ a)]; gcongr; exact_mod_cast Nat.one_le_two_pow\n    _ < _ := qp'\n\nlemma exists_\ud835\udd12_with_le_quotient :\n    \u2203 b \u2208 \ud835\udd12 p' l, 2 ^ (-n : \u2124) < volume (E\u2081 b) / volume (\ud835\udcd8 b : Set X) := by\n  have cO : (\ud835\udd12 p' l).card \u2264 \u230a2 ^ (4 * a) * l ^ a\u230b\u208a := card_\ud835\udd12 _ hl\n  have ltq : (2 ^ (4 * a) * l ^ a : \u211d\u22650) * 2 ^ (-n : \u2124) <\n      \u2211 p'' \u2208 \ud835\udd12 p' l, volume (E\u2081 p'') / volume (\ud835\udcd8 p'' : Set X) :=\n    calc\n      _ < volume (E\u2082 l p') / volume (\ud835\udcd8 p' : Set X) := lt_quotient_rearrange hl qp'\n      _ \u2264 volume (\u22c3 p'' \u2208 \ud835\udd12 p' l, E\u2081 p'') / volume (\ud835\udcd8 p' : Set X) := by\n        gcongr; simp_rw [E\u2081, E\u2082, smul, toTileLike, TileLike.toSet]; intro x mx\n        have rsub := biUnion_\u03a9 (i := \ud835\udcd8 p'); rw [range_subset_iff] at rsub; specialize rsub x\n        simp_rw [mem_iUnion\u2082, mem_preimage, mem_singleton_iff, exists_prop] at rsub\n        obtain \u27e8(ps : \ud835\udd13 X), (ips : \ud835\udcd8 ps = \ud835\udcd8 p'), mps\u27e9 := rsub; rw [\u2190 mem_preimage] at mps\n        rw [mem_iUnion\u2082]; refine \u27e8ps, ?_, ?_\u27e9\n        \u00b7 simp_rw [\ud835\udd12, Finset.mem_filter, Finset.mem_univ, ips, true_and, not_disjoint_iff]\n          use Q x, mem_preimage.mp mx.2, mem_preimage.mp mps\n        \u00b7 exact \u27e8\u27e8ips.symm \u25b8 mx.1.1, mx.1.2\u27e9, mps\u27e9\n      _ \u2264 (\u2211 p'' \u2208 \ud835\udd12 p' l, volume (E\u2081 p'')) / volume (\ud835\udcd8 p' : Set X) :=\n        ENNReal.div_le_div_right (measure_biUnion_finset_le _ _) _\n      _ = \u2211 p'' \u2208 \ud835\udd12 p' l, volume (E\u2081 p'') / volume (\ud835\udcd8 p' : Set X) := by\n        simp_rw [ENNReal.div_eq_inv_mul, Finset.mul_sum]\n      _ = _ := by\n        refine Finset.sum_congr rfl fun p'' mp'' \u21a6 ?_\n        rw [\ud835\udd12, Finset.mem_filter] at mp''; rw [mp''.2.1]\n  by_contra! h\n  have : \u2211 p'' \u2208 \ud835\udd12 p' l, volume (E\u2081 p'') / volume (\ud835\udcd8 p'' : Set X) \u2264\n      (2 ^ (4 * a) * l ^ a : \u211d\u22650) * 2 ^ (-n : \u2124) :=\n    calc\n      _ \u2264 \u2211 _ \u2208 \ud835\udd12 p' l, (2 : \u211d\u22650\u221e) ^ (-n : \u2124) := by\n        refine Finset.sum_le_sum h\n      _ = (\ud835\udd12 p' l).card * (2 : \u211d\u22650\u221e) ^ (-n : \u2124) := by rw [Finset.sum_const, nsmul_eq_mul]\n      _ \u2264 _ := by\n        refine mul_le_mul_right' ?_ _\n        rw [show ((\ud835\udd12 p' l).card : \u211d\u22650\u221e) = ((\ud835\udd12 p' l).card : \u211d\u22650) by simp, ENNReal.coe_le_coe]\n        rw [\u2190 Nat.cast_le (\u03b1 := \u211d\u22650)] at cO\n        exact cO.trans (Nat.floor_le (by positivity))\n  exact (ltq.trans_le this).false\n\nend\n\n/-- Main part of Lemma 5.5.2. -/\nlemma iUnion_L0' : \u22c3 (l < n), \ud835\udd0f\u2080' (X := X) k n l = \ud835\udd0f\u2080 k n := by\n  refine iUnion_lt_minLayer_iff_bounded_series.mpr fun p \u21a6 ?_\n  suffices \u00ac\u2203 s : LTSeries (\ud835\udd0f\u2080 (X := X) k n), s.length = n by\n    rcases lt_or_le p.length n with c | c\n    \u00b7 exact c\n    \u00b7 exact absurd \u27e8p.take \u27e8n, by omega\u27e9, by rw [RelSeries.take_length]\u27e9 this\n  by_contra h; obtain \u27e8s, hs\u27e9 := h; let sl := s.last; have dsl := sl.2.1.2.1\n  simp_rw [dens', lt_iSup_iff, mem_singleton_iff, exists_prop, exists_eq_left] at dsl\n  obtain \u27e8l, hl, p', mp', sp', qp'\u27e9 := dsl\n  obtain \u27e8b, mb, qb\u27e9 := exists_\ud835\udd12_with_le_quotient hl qp'\n  have \ud835\udcd8p'b : \ud835\udcd8 p' = \ud835\udcd8 b := by rw [\ud835\udd12, Finset.mem_filter] at mb; exact mb.2.1.symm\n  replace qb := ENNReal.mul_lt_of_lt_div qb\n  have mba : b \u2208 (aux\ud835\udd10 k n).toFinset := by\n    simp_rw [mem_toFinset, aux\ud835\udd10, mem_setOf, qb, and_true]; rw [TilesAt, mem_preimage] at mp' \u22a2\n    exact \ud835\udcd8p'b \u25b8 mp'\n  obtain \u27e8m, lm, maxm\u27e9 := (aux\ud835\udd10 k n).toFinset.exists_le_maximal mba\n  replace maxm : m \u2208 \ud835\udd10 k n := by simpa only [mem_toFinset] using maxm\n  -- We will now show a contradiction. As a member of `\ud835\udd0f\u2080 k n` the _first_ element `s\u2080` of the\n  -- `LTSeries s` satisfies `\ud835\udd05 k n s\u2080 = \u2205`. But we will show that `m \u2208 \ud835\udd05 k n s\u2080`,\n  -- i.e. `smul 100 s\u2080 \u2264 smul 1 m`.\n  let s\u2080 := s.head; apply absurd s\u2080.2.2; rw [\u2190 ne_eq, \u2190 nonempty_iff_ne_empty]; use m, maxm\n  constructor\n  \u00b7 have l1 : \ud835\udcd8 s\u2080.1 \u2264 \ud835\udcd8 sl.1 := s.head_le_last.1\n    have l2 : \ud835\udcd8 sl.1 \u2264 \ud835\udcd8 b := \ud835\udcd8p'b \u25b8 sp'.1\n    have l3 : \ud835\udcd8 b \u2264 \ud835\udcd8 m := lm.1\n    exact (l1.trans l2).trans l3\n  change ball_(m) (\ud835\udcac m) 1 \u2286 ball_(s\u2080.1) (\ud835\udcac s\u2080.1) 100; intro (\u03b8 : \u0398 X) m\u03b8; rw [@mem_ball] at m\u03b8 \u22a2\n  have aux : dist_(sl.1) (\ud835\udcac sl.1) \u03b8 < 2 * l + 3 :=\n    calc\n      _ \u2264 dist_(sl.1) (\ud835\udcac sl.1) (\ud835\udcac p') + dist_(sl.1) (\ud835\udcac p') \u03b8 := dist_triangle ..\n      _ < l + dist_(sl.1) (\ud835\udcac p') \u03b8 := by\n        apply add_lt_add_right\n        have : \ud835\udcac p' \u2208 ball_(p') (\ud835\udcac p') l := by convert mem_ball_self (zero_lt_two.trans_le hl)\n        exact mem_ball'.mp (sp'.2 this)\n      _ \u2264 l + dist_(p') (\ud835\udcac p') \u03b8 := add_le_add_left (Grid.dist_mono sp'.1) _\n      _ \u2264 l + dist_(p') (\ud835\udcac p') (\ud835\udcac b) + dist_(p') (\ud835\udcac b) \u03b8 := by\n        rw [add_assoc]; apply add_le_add_left; exact dist_triangle ..\n      _ \u2264 l + (l + 1) + dist_(b) (\ud835\udcac b) \u03b8 := by\n        gcongr\n        \u00b7 rw [\ud835\udd12, Finset.mem_filter] at mb\n          obtain \u27e8(x : \u0398 X), x\u2081, x\u2082\u27e9 := not_disjoint_iff.mp mb.2.2\n          replace x\u2082 := _root_.subset_cball x\u2082\n          rw [@mem_ball] at x\u2081 x\u2082\n          calc\n            _ \u2264 dist_(p') x (\ud835\udcac p') + dist_(p') x (\ud835\udcac b) := dist_triangle_left ..\n            _ \u2264 _ := by\n              apply add_le_add x\u2081.le\n              change dist_{\ud835\udcd8 p'} x (\ud835\udcac b) \u2264 1; rw [\ud835\udcd8p'b]; exact x\u2082.le\n        \u00b7 change dist_{\ud835\udcd8 p'} (\ud835\udcac b) \u03b8 \u2264 dist_{\ud835\udcd8 b} (\ud835\udcac b) \u03b8; rw [\ud835\udcd8p'b]\n      _ \u2264 l + (l + 1) + (dist_(b) (\ud835\udcac m) (\ud835\udcac b) + dist_(b) (\ud835\udcac m) \u03b8) :=\n        add_le_add_left (dist_triangle_left ..) _\n      _ \u2264 l + (l + 1) + (1 + dist_(m) (\ud835\udcac m) \u03b8) := by\n        gcongr\n        \u00b7 exact (dist_\ud835\udcac_lt_one_of_le lm).le\n        \u00b7 exact Grid.dist_mono lm.1\n      _ < l + (l + 1) + (1 + 1) := by gcongr; exact mem_ball'.mp m\u03b8\n      _ = _ := by ring\n  calc\n    _ \u2264 dist_(s\u2080.1) (\ud835\udcac sl.1) \u03b8 + dist_(s\u2080.1) (\ud835\udcac sl.1) (\ud835\udcac s\u2080.1) := dist_triangle_left ..\n    _ < 1 + dist_(s\u2080.1) (\ud835\udcac sl.1) \u03b8 := by\n      rw [add_comm]; exact add_lt_add_right (dist_\ud835\udcac_lt_one_of_le s.head_le_last) _\n    _ \u2264 1 + C2_1_2 a ^ n * dist_(sl.1) (\ud835\udcac sl.1) \u03b8 := add_le_add_left (dist_LTSeries hs) _\n    _ < 1 + C2_1_2 a ^ n * (2 * l + 3) := by gcongr; rw [C2_1_2]; positivity\n    _ \u2264 1 + (1 / 512) ^ n * (2 * 2 ^ n + 3) := by\n      gcongr\n      \u00b7 rw [C2_1_2]; positivity\n      \u00b7 exact C2_1_2_le_inv_512 X\n      \u00b7 exact_mod_cast (l_upper_bound hl qp').le\n    _ = 1 + 2 * (2 / 512) ^ n + (1 / 512) ^ n * 3 := by\n      simp [div_pow]; ring\n    _ \u2264 1 + 2 * (2 / 512) ^ 0 + (1 / 512) ^ 0 * 3 := by\n      gcongr 1 + 2 * ?_ + ?_ * 3 <;>\n        exact pow_le_pow_of_le_one (by norm_num) (by norm_num) (by omega)\n    _ < _ := by norm_num\n\n/-- Part of Lemma 5.5.2 -/\nlemma pairwiseDisjoint_L0' : univ.PairwiseDisjoint (\ud835\udd0f\u2080' (X := X) k n) := pairwiseDisjoint_minLayer\n\n/-- Part of Lemma 5.5.2 -/\nlemma antichain_L0' : IsAntichain (\u00b7 \u2264 \u00b7) (\ud835\udd0f\u2080' (X := X) k n l) := isAntichain_minLayer\n\nsection L2Antichain\n\n/-- Type synonym of `\u212d\u2081` to apply the `Preorder` of the proof of Lemma 5.5.3 on. -/\nprivate def \u212d\u2081' (k n j : \u2115) : Type _ := \u212d\u2081 (X := X) k n j\n\nprivate instance : Fintype (\u212d\u2081' (X := X) k n j) := inferInstanceAs (Fintype (\u212d\u2081 k n j))\n\nprivate instance : Preorder (\u212d\u2081' (X := X) k n j) where\n  le x y := smul 200 x.1 \u2264 smul 200 y.1\n  le_refl := by simp\n  le_trans _ _ _ xy yz := by\n    change smul _ _ \u2264 smul _ _ at xy yz \u22a2\n    exact xy.trans yz\n\n/-- Lemma 5.5.3 -/\nlemma antichain_L2 : IsAntichain (\u00b7 \u2264 \u00b7) (\ud835\udd0f\u2082 (X := X) k n j) := by\n  by_contra h; rw [isAntichain_iff_forall_not_lt] at h; push_neg at h\n  obtain \u27e8p', mp', p, mp, l\u27e9 := h\n  have p200 : smul 2 p' \u2264 smul 200 p := by\n    calc\n      _ \u2264 smul (11 / 10 + C2_1_2 a * 200) p' := by\n        apply smul_mono_left\n        calc\n          _ \u2264 11 / 10 + 1 / 512 * (200 : \u211d) := by gcongr; exact C2_1_2_le_inv_512 X\n          _ \u2264 _ := by norm_num\n      _ \u2264 _ := by\n        refine smul_C2_1_2 _ (by norm_num) ?_ (wiggle_order_11_10 l.le (C5_3_3_le (X := X)))\n        exact (\ud835\udcd8_strictMono l).ne\n  have cp : p \u2208 \u212d\u2081 k n j := (\ud835\udd0f\u2082_subset_\u212d\u2082.trans \u212d\u2082_subset_\u212d\u2081) mp\n  let C : Finset (LTSeries (\u212d\u2081' k n j)) := { s | s.head = \u27e8p, cp\u27e9 }\n  have Cn : C.Nonempty := by\n    use RelSeries.singleton _ \u27e8p, cp\u27e9\n    simp_rw [C, Finset.mem_filter, Finset.mem_univ, true_and]; rfl\n  obtain \u27e8z, mz, maxz\u27e9 := C.exists_max_image (\u00b7.length) Cn\n  simp_rw [C, Finset.mem_filter, Finset.mem_univ, true_and] at mz\n  by_cases mu : z.last.1 \u2208 \ud835\udd18\u2081 k n j\n  \u00b7 have px : z.head \u2264 z.last := z.monotone (Fin.zero_le _)\n    rw [mz] at px\n    apply absurd mp'; rw [\ud835\udd0f\u2082, mem_setOf, not_and_or, not_not]; right; use z.last.1, mu\n    have : \ud835\udcd8 p' < \ud835\udcd8 p := \ud835\udcd8_strictMono l\n    exact \u27e8(this.trans_le px.1).ne, (p200.trans px).trans (smul_mono_left (by norm_num))\u27e9\n  \u00b7 simp_rw [\ud835\udd18\u2081, mem_setOf, not_and, z.last.2, true_implies, not_forall, exists_prop] at mu\n    obtain \u27e8q, mq, lq, ndjq\u27e9 := mu; rw [not_disjoint_iff] at ndjq; obtain \u27e8\u03d1, m\u03d1\u2081, m\u03d1\u2082\u27e9 := ndjq\n    have cpos : 0 < C2_1_2 a := by rw [C2_1_2]; positivity\n    have s200 : smul 200 z.last.1 \u2264 smul 200 q := by\n      refine \u27e8lq.le, (?_ : ball_(q) (\ud835\udcac q) 200 \u2286 ball_(z.last.1) (\ud835\udcac z.last.1) 200)\u27e9\n      intro (r : \u0398 X) mr\n      rw [@mem_ball] at mr m\u03d1\u2081 m\u03d1\u2082 \u22a2\n      calc\n        _ \u2264 dist_(z.last.1) r (\ud835\udcac q) + dist_(z.last.1) (\ud835\udcac q) \u03d1 + dist_(z.last.1) \u03d1 (\ud835\udcac z.last.1) :=\n          dist_triangle4 ..\n        _ \u2264 C2_1_2 a * dist_(q) r (\ud835\udcac q) + C2_1_2 a * dist_(q) (\ud835\udcac q) \u03d1 + 100 := by\n          gcongr <;> exact Grid.dist_strictMono lq\n        _ \u2264 C2_1_2 a * (200 + 100) + 100 := by rw [mul_add]; gcongr; rw [dist_comm]; exact m\u03d1\u2082.le\n        _ \u2264 (1 / 512) * 300 + 100 := by\n          rw [show (200 : \u211d) + 100 = 300 by norm_num]; gcongr\n          exact C2_1_2_le_inv_512 X\n        _ < _ := by norm_num\n    have : z.last < \u27e8q, mq\u27e9 := by\n      refine \u27e8s200, (?_ : \u00ac(smul 200 q \u2264 smul 200 z.last.1))\u27e9\n      rw [TileLike.le_def, not_and_or]; exact Or.inl (not_le_of_gt lq)\n    apply absurd maxz; push_neg; use z.snoc \u27e8q, mq\u27e9 this, by simp [C, mz], by simp\n\nend L2Antichain\n\n/-- Part of Lemma 5.5.4 -/\nlemma antichain_L1 : IsAntichain (\u00b7 \u2264 \u00b7) (\ud835\udd0f\u2081 (X := X) k n j l) := isAntichain_minLayer\n\n/-- Part of Lemma 5.5.4 -/\nlemma antichain_L3 : IsAntichain (\u00b7 \u2264 \u00b7) (\ud835\udd0f\u2083 (X := X) k n j l) := isAntichain_maxLayer\n\n/- Our goal is now to estimate `\u222b\u207b x in G \\ G', \u2016carlesonSum \ud835\udd13\u2081\u1d9c f x\u2016\u208a` by decomposing `\ud835\udd13\u2081\u1d9c` as a\nunion of disjoint antichains. For this, we proceed step by step, isolating some antichains and\nsome sets that remain to be decomposed. After 4 steps, we will get a sum of integrals corresponding\nto the (disjoint) decomposition in Lemma 5.5.1.\n-/\n\n/-- The Carleson sum over `\ud835\udd13\u2081\u1d9c` and `\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c` coincide at ae every point of `G \\ G'`. -/\nlemma carlesonSum_\ud835\udd13\u2081_compl_eq_\ud835\udd13pos_inter (f : X \u2192 \u2102) :\n    \u2200\u1d50 x, x \u2208 G \\ G' \u2192 carlesonSum \ud835\udd13\u2081\u1d9c f x = carlesonSum (\ud835\udd13pos (X := X) \u2229 \ud835\udd13\u2081\u1d9c) f x := by\n  have A p (hp : p \u2208 (\ud835\udd13pos (X := X))\u1d9c) : \u2200\u1d50 x, x \u2208 G \\ G' \u2192 x \u2209 \ud835\udcd8 p := by\n    simp only [\ud835\udd13pos, mem_compl_iff, mem_setOf_eq, not_lt, nonpos_iff_eq_zero] at hp\n    filter_upwards [measure_zero_iff_ae_nmem.mp hp] with x hx h'x (h''x : x \u2208 (\ud835\udcd8 p : Set X))\n    simp [h''x, h'x.1, h'x.2] at hx\n  rw [\u2190 ae_ball_iff (to_countable \ud835\udd13pos\u1d9c)] at A\n  filter_upwards [A] with x hx h'x\n  simp only [carlesonSum]\n  symm\n  apply Finset.sum_subset\n  \u00b7 intro p hp\n    simp only [Finset.mem_filter, Finset.mem_univ, true_and] at hp \u22a2\n    exact hp.2\n  \u00b7 intro p hp h'p\n    simp only [Finset.mem_filter, Finset.mem_univ, true_and] at hp h'p\n    simp only [mem_inter_iff, hp, and_true] at h'p\n    have : x \u2209 \ud835\udcd8 p := hx _ h'p h'x\n    have : x \u2209 E p := by simp at this; simp [E, this]\n    simp [carlesonOn, this]\n\n/-- The Carleson sum over `\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c` can be decomposed as a sum over the intersections of this\nset with various `\u212d k n`. -/\nlemma carlesonSum_\ud835\udd13pos_eq_sum {f : X \u2192 \u2102} {x : X} :\n    carlesonSum (\ud835\udd13pos (X := X) \u2229 \ud835\udd13\u2081\u1d9c) f x =\n      \u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, carlesonSum (\ud835\udd13pos (X := X) \u2229 \ud835\udd13\u2081\u1d9c \u2229 \u212d k n) f x := by\n  simp only [Finset.sum_sigma']\n  rw [sum_carlesonSum_of_pairwiseDisjoint]; swap\n  \u00b7 rintro \u27e8n, k\u27e9 - \u27e8n', k'\u27e9 - h\n    simp only [ne_eq, Sigma.mk.inj_iff, heq_eq_eq] at h\n    simp only [Function.onFun, disjoint_iff_forall_ne]\n    have W := pairwiseDisjoint_\u212d (X := X) (mem_univ \u27e8k, n\u27e9) (mem_univ \u27e8k', n'\u27e9)\n      (by simp [-not_and]; tauto)\n    intro x hx y hy\n    exact (disjoint_iff_forall_ne.1 W) hx.2 hy.2\n  congr\n  ext p\n  simp only [mem_inter_iff, mem_compl_iff, Finset.mem_sigma,\n    Finset.mem_Iic, mem_iUnion, exists_and_left, exists_prop, Sigma.exists, iff_self_and, and_imp]\n  intro hp h'p\n  rcases exists_k_n_of_mem_\ud835\udd13pos hp with \u27e8k, n, h'p, hkn\u27e9\n  exact \u27e8n, k, \u27e8le_max\u212d_of_nonempty \u27e8p, h'p\u27e9 , hkn\u27e9, h'p\u27e9\n\n/-- In each set `\u212d k n`, the Carleson sum can be decomposed as a sum over `\ud835\udd0f\u2080 k n` and over\nvarious `\u212d\u2081 k n j`. -/\nlemma carlesonSum_\ud835\udd13pos_inter_\u212d_eq_add_sum {f : X \u2192 \u2102} {x : X} (hkn : k \u2264 n) :\n    carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \u212d k n) f x =\n      carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2080 k n) f x\n      + \u2211 j \u2264 2 * n + 3, carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \u212d\u2081 k n j) f x := by\n  conv_lhs => rw [\u2190 carlesonSum_inter_add_inter_compl _ (\ud835\udd0f\u2080 k n)]\n  rw [sum_carlesonSum_of_pairwiseDisjoint]; swap\n  \u00b7 apply PairwiseDisjoint.subset _ (subset_univ _)\n    apply (pairwiseDisjoint_\u212d\u2081 (k := k) (n := n)).mono\n    intro j\n    exact inter_subset_right\n  congr 2\n  \u00b7 ext p\n    simp only [mem_inter_iff, mem_compl_iff, and_congr_left_iff, and_iff_left_iff_imp, and_imp]\n    intro hp\n    simp [\ud835\udd0f\u2080_subset_\u212d hp]\n  \u00b7 apply Subset.antisymm\n    \u00b7 rintro p \u27e8\u27e8hp, Hp\u27e9, h'p\u27e9\n      rcases exists_j_of_mem_\ud835\udd13pos_\u212d hp.1 Hp hkn with H\n      simp only [mem_compl_iff] at h'p\n      simp only [h'p, false_or] at H\n      simp only [Finset.mem_Iic, mem_iUnion, mem_inter_iff, hp, true_and, exists_prop]\n      exact H\n    \u00b7 intro p hp\n      simp only [Finset.mem_Iic, mem_iUnion, mem_compl_iff, exists_and_left, exists_prop] at hp\n      rcases hp with \u27e8i, hi, h'i, h''i\u27e9\n      exact \u27e8\u27e8h'i, \u212d\u2081_subset_\u212d h''i\u27e9, disjoint_left.1 \ud835\udd0f\u2080_disjoint_\u212d\u2081.symm h''i\u27e9\n\nlemma carlesonSum_\ud835\udd13pos_inter_\ud835\udd0f\u2080_eq_sum {f : X \u2192 \u2102} {x : X} :\n    carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2080 k n) f x =\n      \u2211 l < n, carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2080' k n l) f x := by\n  rw [sum_carlesonSum_of_pairwiseDisjoint]; swap\n  \u00b7 apply PairwiseDisjoint.subset _ (subset_univ _)\n    apply (pairwiseDisjoint_L0' (k := k) (n := n)).mono\n    intro j\n    exact inter_subset_right\n  congr\n  rw [\u2190 iUnion_L0']\n  ext p\n  simp\n\n/-- In each set `\u212d\u2081 k n j`, the Carleson sum can be decomposed as a sum over `\u212d\u2082 k n j` and over\nvarious `\ud835\udd0f\u2081 k n j l`. -/\nlemma carlesonSum_\ud835\udd13pos_inter_\u212d\u2081_eq_add_sum {f : X \u2192 \u2102} {x : X} :\n    carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \u212d\u2081 k n j) f x =\n      carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \u212d\u2082 k n j) f x\n      + \u2211 l \u2264 Z * (n + 1), carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2081 k n j l) f x := by\n  conv_lhs => rw [\u2190 carlesonSum_inter_add_inter_compl _ (\u212d\u2082 k n j)]\n  rw [sum_carlesonSum_of_pairwiseDisjoint]; swap\n  \u00b7 apply PairwiseDisjoint.subset _ (subset_univ _)\n    have : univ.PairwiseDisjoint fun l \u21a6 \ud835\udd0f\u2081 (X := X) k n j l := pairwiseDisjoint_minLayer\n    apply this.mono\n    intro j\n    exact inter_subset_right\n  congr 2\n  \u00b7 ext p\n    simp only [mem_inter_iff, mem_compl_iff, and_congr_left_iff, and_iff_left_iff_imp, and_imp]\n    intro hp\n    simp [\u212d\u2082_subset_\u212d\u2081 hp]\n  \u00b7 ext p\n    simp only [\u212d\u2082, layersAbove, mem_inter_iff,\n      mem_compl_iff, mem_diff, mem_iUnion, exists_prop, not_exists, not_and, not_forall,\n      Classical.not_imp, Decidable.not_not, Finset.mem_Iic, \ud835\udd0f\u2081, exists_and_left]\n    refine \u27e8fun h \u21a6 ?_, fun h \u21a6 ?_\u27e9\n    \u00b7 simpa [h.1.1] using h.2 h.1.2\n    \u00b7 rcases h with \u27e8i, hi, h'i\u27e9\n      simp only [h'i.1, not_false_eq_true, and_self, minLayer_subset h'i.2, forall_const, true_and]\n      exact \u27e8i, hi, h'i.2\u27e9\n\n/-- In each set `\u212d\u2082 k n j`, the Carleson sum can be decomposed as a sum over `\ud835\udd0f\u2082 k n j` and over\nvarious `\ud835\udd0f\u2083 k n j l`. -/\nlemma carlesonSum_\ud835\udd13pos_inter_\u212d\u2082_eq_add_sum {f : X \u2192 \u2102} {x : X} (hkn : k \u2264 n) (hj : j \u2264 2 * n + 3) :\n    carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \u212d\u2082 k n j) f x =\n      carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2082 k n j) f x\n      + \u2211 l \u2264 Z * (n + 1), carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2083 k n j l) f x := by\n  conv_lhs => rw [\u2190 carlesonSum_inter_add_inter_compl _ (\ud835\udd0f\u2082 k n j)]\n  rw [sum_carlesonSum_of_pairwiseDisjoint]; swap\n  \u00b7 apply PairwiseDisjoint.subset _ (subset_univ _)\n    have : univ.PairwiseDisjoint fun l \u21a6 \ud835\udd0f\u2083 (X := X) k n j l := pairwiseDisjoint_minLayer\n    apply this.mono\n    intro j\n    exact inter_subset_right\n  congr 2\n  \u00b7 ext p\n    simp only [mem_inter_iff, mem_compl_iff, and_congr_left_iff, and_iff_left_iff_imp, and_imp]\n    intro hp\n    simp [\ud835\udd0f\u2082_subset_\u212d\u2082 hp]\n  \u00b7 ext p\n    simp only [mem_inter_iff, mem_compl_iff,\n      Finset.mem_Iic, mem_iUnion, exists_and_left, exists_prop]\n    refine \u27e8fun h \u21a6 ?_, fun h \u21a6 ?_\u27e9\n    \u00b7 refine \u27e8h.1.1, ?_\u27e9\n      simp only [\ud835\udd13\u2081, mem_iUnion, exists_prop, not_exists, not_and] at h\n      have : p \u2209 \u212d\u2085 k n j := h.1.1.2 n k hkn j hj\n      simpa using (nmem_\u212d\u2085_iff_mem_\ud835\udd0f\u2083 (X := X) hkn hj h.1.1.1 h.1.2 h.2).1 this\n    \u00b7 rcases h.2 with \u27e8l, lZ, hl\u27e9\n      exact \u27e8\u27e8h.1, \u212d\u2083_subset_\u212d\u2082 (maxLayer_subset hl)\u27e9,\n        disjoint_right.1 \ud835\udd0f\u2082_disjoint_\u212d\u2083 (maxLayer_subset hl)\u27e9\n\n/-- Putting together all the previous decomposition lemmas, one gets an estimate of the integral\nof `\u2016carlesonSum \ud835\udd13\u2081\u1d9c f x\u2016\u208a` by a sum of integrals of the same form over various subsets of `\ud835\udd13`,\nwhich are all antichains by design. -/\nlemma lintegral_carlesonSum_\ud835\udd13\u2081_compl_le_sum_lintegral {f : X \u2192 \u2102} (h'f : Measurable f) :\n    \u222b\u207b x in G \\ G', \u2016carlesonSum \ud835\udd13\u2081\u1d9c f x\u2016\u208a \u2264\n        (\u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 l < n,\n          \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2080' k n l) f x\u2016\u208a)\n      + (\u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3, \u2211 l \u2264 Z * (n + 1),\n          \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2081 k n j l) f x\u2016\u208a)\n      + (\u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3,\n          \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2082 k n j) f x\u2016\u208a)\n      + (\u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3, \u2211 l \u2264 Z * (n + 1),\n          \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2083 k n j l) f x\u2016\u208a) := calc\n  \u222b\u207b x in G \\ G', \u2016carlesonSum \ud835\udd13\u2081\u1d9c f x\u2016\u208a\n  _ = \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c) f x\u2016\u208a := by\n    apply lintegral_congr_ae\n    apply (ae_restrict_iff' (measurableSet_G.diff measurable_G')).2\n    filter_upwards [carlesonSum_\ud835\udd13\u2081_compl_eq_\ud835\udd13pos_inter f] with x hx h'x\n    simp [hx h'x]\n  _ \u2264 \u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \u212d k n) f x\u2016\u208a := by\n    simp only [Finset.sum_sigma']\n    rw [\u2190 lintegral_finset_sum']; swap\n    \u00b7 exact fun b hb \u21a6 h'f.aestronglyMeasurable.carlesonSum.restrict.enorm\n    apply lintegral_mono (fun x \u21a6 ?_)\n    simp only [Finset.sum_sigma', carlesonSum_\ud835\udd13pos_eq_sum]\n    exact (ENNReal.coe_le_coe.2 (nnnorm_sum_le _ _)).trans_eq (by simp)\n  _ \u2264 \u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, ((\u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2080 k n) f x\u2016\u208a)\n      + \u2211 j \u2264 2 * n + 3, \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \u212d\u2081 k n j) f x\u2016\u208a) := by\n    gcongr with n hn k hkn\n    simp only [Finset.mem_Iic] at hkn\n    rw [\u2190 lintegral_finset_sum']; swap\n    \u00b7 exact fun b hb \u21a6 h'f.aestronglyMeasurable.carlesonSum.restrict.enorm\n    rw [\u2190 lintegral_add_left']; swap\n    \u00b7 exact h'f.aestronglyMeasurable.carlesonSum.restrict.enorm\n    apply lintegral_mono (fun x \u21a6 ?_)\n    rw [carlesonSum_\ud835\udd13pos_inter_\u212d_eq_add_sum hkn]\n    norm_cast\n    apply ENNReal.coe_le_coe.2\n    apply (nnnorm_add_le _ _).trans\n    gcongr\n    apply nnnorm_sum_le\n  _ = (\u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2080 k n) f x\u2016\u208a)\n      + \u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3,\n        \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \u212d\u2081 k n j) f x\u2016\u208a := by\n    simp only [Finset.sum_add_distrib]\n  _ \u2264 (\u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 l < n, \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2080' k n l) f x\u2016\u208a)\n      + \u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3,\n        \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \u212d\u2081 k n j) f x\u2016\u208a := by\n    gcongr with n hn k hk\n    rw [\u2190 lintegral_finset_sum']; swap\n    \u00b7 exact fun b hb \u21a6 h'f.aestronglyMeasurable.carlesonSum.restrict.enorm\n    apply lintegral_mono (fun x \u21a6 ?_)\n    rw [carlesonSum_\ud835\udd13pos_inter_\ud835\udd0f\u2080_eq_sum]\n    norm_cast\n    apply ENNReal.coe_le_coe.2\n    apply nnnorm_sum_le\n  _ \u2264 (\u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 l < n, \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2080' k n l) f x\u2016\u208a)\n      + \u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3,\n      ((\u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \u212d\u2082 k n j) f x\u2016\u208a)\n        + \u2211 l \u2264 Z * (n + 1), \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2081 k n j l) f x\u2016\u208a) := by\n    gcongr with n hn k hk j hj\n    rw [\u2190 lintegral_finset_sum']; swap\n    \u00b7 exact fun b hb \u21a6 h'f.aestronglyMeasurable.carlesonSum.restrict.enorm\n    rw [\u2190 lintegral_add_left']; swap\n    \u00b7 exact h'f.aestronglyMeasurable.carlesonSum.restrict.enorm\n    apply lintegral_mono (fun x \u21a6 ?_)\n    rw [carlesonSum_\ud835\udd13pos_inter_\u212d\u2081_eq_add_sum]\n    norm_cast\n    apply ENNReal.coe_le_coe.2\n    apply (nnnorm_add_le _ _).trans\n    gcongr\n    apply nnnorm_sum_le\n  _ = (\u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 l < n, \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2080' k n l) f x\u2016\u208a)\n      + (\u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3, \u2211 l \u2264 Z * (n + 1),\n          \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2081 k n j l) f x\u2016\u208a)\n      + \u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3,\n          \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \u212d\u2082 k n j) f x\u2016\u208a := by\n    simp only [Finset.sum_add_distrib]\n    abel\n  _ \u2264 (\u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 l < n, \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2080' k n l) f x\u2016\u208a)\n      + (\u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3, \u2211 l \u2264 Z * (n + 1),\n          \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2081 k n j l) f x\u2016\u208a)\n      + \u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3,\n        ((\u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2082 k n j) f x\u2016\u208a)\n          + \u2211 l \u2264 Z * (n + 1), \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2083 k n j l) f x\u2016\u208a) := by\n    gcongr with n hn k hkn j hj\n    simp only [Finset.mem_Iic] at hkn hj\n    rw [\u2190 lintegral_finset_sum']; swap\n    \u00b7 exact fun b hb \u21a6 h'f.aestronglyMeasurable.carlesonSum.restrict.enorm\n    rw [\u2190 lintegral_add_left']; swap\n    \u00b7 exact h'f.aestronglyMeasurable.carlesonSum.restrict.enorm\n    apply lintegral_mono (fun x \u21a6 ?_)\n    rw [carlesonSum_\ud835\udd13pos_inter_\u212d\u2082_eq_add_sum hkn hj]\n    norm_cast\n    apply ENNReal.coe_le_coe.2\n    apply (nnnorm_add_le _ _).trans\n    gcongr\n    apply nnnorm_sum_le\n  _ = (\u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 l < n, \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2080' k n l) f x\u2016\u208a)\n      + (\u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3, \u2211 l \u2264 Z * (n + 1),\n          \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2081 k n j l) f x\u2016\u208a)\n      + (\u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3,\n          \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2082 k n j) f x\u2016\u208a)\n      + \u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3, \u2211 l \u2264 Z * (n + 1),\n          \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2083 k n j l) f x\u2016\u208a := by\n    simp only [Finset.sum_add_distrib]\n    abel\n\n/-- Custom version of the antichain operator theorem, in the specific form we need to handle\nthe various terms in the previous statement. -/\nlemma lintegral_nnnorm_carlesonSum_le_of_isAntichain_subset_\u212d\n    {f : X \u2192 \u2102} {\ud835\udd04 : Set (\ud835\udd13 X)} (hf : \u2200 x, \u2016f x\u2016 \u2264 F.indicator 1 x) (h'f : Measurable f)\n    (hA : IsAntichain (\u00b7 \u2264 \u00b7) \ud835\udd04) (h'A : \ud835\udd04 \u2286 \u212d k n) :\n    \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd04) f x\u2016\u208a\n    \u2264 C_2_0_3 a nnq * 2 ^ (a + 3) * volume G ^ (1 - q\u207b\u00b9) * volume F ^ (q\u207b\u00b9)\n      * 2 ^ (- ((q - 1) / (8 * a ^ 4) * n)) := by\n  have I : 0 \u2264 q - 1 := by linarith [one_lt_q X]\n  have J : 0 \u2264 q\u207b\u00b9 - 2\u207b\u00b9 := inv_q_sub_half_nonneg X\n  apply (antichain_operator_le_volume h'f hf diff_subset\n    (hA.subset inter_subset_right)).trans\n  simp only [mul_assoc]\n  apply mul_le_mul_left'\n  have : dens\u2081 (\ud835\udd13pos (X := X) \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd04) \u2264 2 ^ (4 * a - n + 1 : \u211d) :=\n    dens1_le (inter_subset_right.trans h'A)\n  have : dens\u2082 (\ud835\udd13pos (X := X) \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd04) \u2264 2 ^ (2 * a + 5) * volume F / volume G := by\n    rw [dens\u2082_eq_biSup_dens\u2082]\n    simp only [mem_iUnion, exists_prop, iSup_exists, iSup_le_iff, and_imp]\n    intro p hp\n    have : \u00ac (\ud835\udcd8 p : Set X) \u2286 G\u2081 := by\n      have W := hp.1.1\n      contrapose! W\n      have : \u2191(\ud835\udcd8 p) \u2229 G \u2229 G'\u1d9c = \u2205 := by\n        simp only [G', compl_union]\n        apply eq_empty_of_subset_empty\n        intro x hx\n        exact (hx.2.1.1 (W hx.1.1)).elim\n      simp only [\ud835\udd13pos, mem_setOf_eq, this, measure_empty, lt_self_iff_false, not_false_eq_true]\n    contrapose! this\n    have : p \u2208 highDensityTiles := by simp [highDensityTiles, this]\n    apply subset_biUnion_of_mem this\n  calc\n  dens\u2081 (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd04) ^ ((q - 1) / (8 * \u2191a ^ 4)) *\n    (dens\u2082 (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd04) ^ (q\u207b\u00b9 - 2\u207b\u00b9) * (volume F ^ (1 / 2 : \u211d) * volume G ^ (1 / 2 : \u211d)))\n  _ \u2264 (2 ^ (4 * a - n + 1 : \u211d)) ^ ((q - 1) / (8 * \u2191a ^ 4)) *\n    ((2 ^ (2 * a + 5) * volume F / volume G) ^ (q\u207b\u00b9 - 2\u207b\u00b9)\n      * ((volume F ^ (1 / 2 : \u211d) * volume G ^ (1 / 2 : \u211d)))) := by gcongr\n  _ = (2 ^ ((4 * a + 1) * (q - 1) / (8 * \u2191a ^ 4)) * 2 ^ (- ((q - 1) / (8 * \u2191a ^ 4) * n))) *\n    ((2 ^ ((2 * a + 5) * (q\u207b\u00b9 - 2\u207b\u00b9)) * volume F ^ (q\u207b\u00b9 - 2\u207b\u00b9) / volume G ^ (q\u207b\u00b9 - 2\u207b\u00b9))\n      * ((volume F ^ (1 / 2 : \u211d) * volume G ^ (1 / 2 : \u211d)))) := by\n    rw [ENNReal.div_rpow_of_nonneg _ _ J, ENNReal.mul_rpow_of_nonneg _ _ J,\n      \u2190 ENNReal.rpow_natCast, \u2190 ENNReal.rpow_mul, \u2190 ENNReal.rpow_mul,\n      \u2190 ENNReal.rpow_add _ _ (NeZero.ne 2) ENNReal.ofNat_ne_top]\n    congr\n    \u00b7 ring\n    \u00b7 simp\n  _ = 2 ^ ((4 * a + 1) * (q - 1) / (8 * \u2191a ^ 4)) * 2 ^ ((2 * a + 5) * (q\u207b\u00b9 - 2\u207b\u00b9)) *\n      (volume G ^ (1 - q\u207b\u00b9) * (volume F ^ q\u207b\u00b9 * 2 ^ (- ((q - 1) / (8 * \u2191a ^ 4) * n)))) := by\n    have IF : (volume F) ^ (q\u207b\u00b9) = (volume F) ^ ((q \u207b\u00b9 - 2\u207b\u00b9) + 2\u207b\u00b9) := by congr; abel\n    have IG : (volume G) ^ (1 - q\u207b\u00b9) = (volume G) ^ (2\u207b\u00b9 - (q\u207b\u00b9 - 2\u207b\u00b9)) := by\n      congr 1\n      simp only [sub_sub_eq_add_sub, sub_left_inj]\n      norm_num\n    rw [IF, IG, ENNReal.rpow_sub (2\u207b\u00b9) _ ProofData.volume_G_pos.ne' volume_G_ne_top,\n      ENNReal.rpow_add_of_nonneg (x := volume F) _ _ (inv_q_sub_half_nonneg X) (by norm_num),\n      ENNReal.div_eq_inv_mul, ENNReal.div_eq_inv_mul]\n    ring_nf\n  _ \u2264 2 ^ ((2 : \u211d)\u207b\u00b9 + (a + 5/2)) *\n      (volume G ^ (1 - q\u207b\u00b9) * (volume F ^ q\u207b\u00b9 * 2 ^ (- ((q - 1) / (8 * \u2191a ^ 4) * n)))) := by\n    rw [\u2190 ENNReal.rpow_add _ _ (NeZero.ne 2) ENNReal.ofNat_ne_top]\n    have : (4 : \u211d) \u2264 a := mod_cast (four_le_a X)\n    gcongr\n    \u00b7 exact one_le_two\n    \u00b7 calc\n      (4 * a + 1) * (q - 1) / (8 * a ^ 4 : \u211d)\n      _ \u2264 (4 * a + a) * (2 - 1) / (8 * a ^ 4) := by\n         gcongr\n         \u00b7 norm_cast\n           linarith [four_le_a X]\n         \u00b7 exact q_le_two X\n      _ = 5 / (8 * a ^ 3) := by field_simp; ring\n      _ \u2264 5 / (8 * (4 : \u211d) ^ 3) := by gcongr\n      _ \u2264 2\u207b\u00b9 := by norm_num\n    \u00b7 calc\n      (2 * \u2191a + 5) * (q\u207b\u00b9 - 2\u207b\u00b9)\n      _ \u2264 (2 * \u2191a + 5) * (1\u207b\u00b9 - 2\u207b\u00b9) := by gcongr; exact (one_lt_q X).le\n      _ = a + 5/2 := by ring\n  _ = 2 ^ (a + 3) *\n      (volume G ^ (1 - q\u207b\u00b9) * (volume F ^ q\u207b\u00b9 * 2 ^ (- ((q - 1) / (8 * \u2191a ^ 4) * n)))) := by\n    congr 1\n    rw [\u2190 ENNReal.rpow_natCast]\n    congr\n    simp\n    ring\n\nopen scoped Nat\n\nomit [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] [TileStructure Q D \u03ba S o] in\n", "theoremStatement": "lemma lintegral_carlesonSum_\ud835\udd13\u2081_compl_le_sum_aux1 [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] {N : \u2115} :\n    \u2211 x \u2264 N,\n      (((12 + 8 * Z) * x ^ 0 + (19 + 20 * Z) * x ^ 1 + (7 + 16 * Z) * x ^ 2 + (4 * Z) * x ^ 3) *\n        (2 : \u211d) ^ (-((q - 1) / (8 * \u2191a ^ 4) * x : \u211d))) \u2264 2 ^ (28 * a + 20) / (q - 1) ^ 4 ", "theoremName": "lintegral_carlesonSum_\ud835\udd13\u2081_compl_le_sum_aux1", "fileCreated": {"commit": "310e13d16e51600777fc841833f4bce112b5f73a", "date": "2024-09-24"}, "theoremCreated": {"commit": "77d4285c51ebe49f9035715383dfd7aef6aecf25", "date": "2025-01-09"}, "file": "carleson/Carleson/Discrete/ForestComplement.lean", "module": "Carleson.Discrete.ForestComplement", "jsonFile": "Carleson.Discrete.ForestComplement.jsonl", "positionMetadata": {"lineInFile": 933, "tokenPositionInFile": 46475, "theoremPositionInFile": 40}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 8, "numPremises": 514}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp only [add_mul _ _ ((2 : \u211d) ^ (_ : \u211d)), Finset.sum_add_distrib]\n  simp only [mul_assoc, \u2190 Finset.mul_sum]\n  simp only [\u2190 mul_assoc]\n  have : 0 < q - 1 := by linarith [one_lt_q X]\n  have : 0 < a := a_pos X\n  have : q \u2264 2 := q_le_two X\n  have : (4 : \u211d) \u2264 a := mod_cast (four_le_a X)\n  have P : 0 < (q - 1) / (8 * \u2191a ^ 4) := by positivity\n  have : 0.6931471803 \u2264 Real.log 2 := Real.log_two_gt_d9.le\n  have : (1 : \u211d) \u2264 Z / 2 ^ 48 := by\n    rw [one_le_div (by positivity)]\n    simp only [defaultZ, Nat.cast_pow, Nat.cast_ofNat]\n    gcongr\n    \u00b7 exact one_le_two\n    \u00b7 linarith [four_le_a X]\n  calc\n  (12 + 8 * \u2191Z) * \u2211 i \u2264 N, \u2191i ^ 0 * (2 : \u211d) ^ (-((q - 1) / (8 * a ^ 4) * i)) +\n      (19 + 20 * \u2191Z) * \u2211 i \u2264 N, \u2191i ^ 1 * 2 ^ (-((q - 1) / (8 * a ^ 4) * i)) +\n      (7 + 16 * \u2191Z) * \u2211 i \u2264 N, \u2191i ^ 2 * 2 ^ (-((q - 1) / (8 * a ^ 4) * i)) +\n      (4 * \u2191Z) * \u2211 i \u2264 N, \u2191i ^ 3 * 2 ^ (-((q - 1) / (8 * a ^ 4) * i))\n  _ \u2264 (12 + 8 * \u2191Z) * ((2 : \u211d) ^ ((q - 1) / (8 * a ^ 4)) *\n        0 ! / (Real.log 2 * ((q - 1) / (8 * a ^ 4))) ^ (0 + 1)) +\n      (19 + 20 * \u2191Z) * ((2 : \u211d) ^ ((q - 1) / (8 * a ^ 4)) *\n        1 ! / (Real.log 2 * ((q - 1) / (8 * a ^ 4))) ^ (1 + 1)) +\n      (7 + 16 * \u2191Z) * ((2 : \u211d) ^ ((q - 1) / (8 * a ^ 4)) *\n        2 ! / (Real.log 2 * ((q - 1) / (8 * a ^ 4))) ^ (2 + 1)) +\n      (4 * \u2191Z) * ((2 : \u211d) ^ ((q - 1) / (8 * a ^ 4)) *\n        3 ! / (Real.log 2 * ((q - 1) / (8 * a ^ 4))) ^ (3 + 1)) := by\n    gcongr <;> apply sum_Iic_pow_mul_two_pow_neg_le P\n  _ = (2 : \u211d) ^ ((q - 1) / (8 * a ^ 4)) *\n      ( (12 + 8 * \u2191Z) / (Real.log 2 * ((q - 1) / (8 * a ^ 4)))\n      + (19 + 20 * \u2191Z)  / (Real.log 2 * ((q - 1) / (8 * a ^ 4))) ^ 2\n      + (14 + 32 * \u2191Z) / (Real.log 2 * ((q - 1) / (8 * a ^ 4))) ^ 3\n      + (24 * \u2191Z) /  (Real.log 2 * ((q - 1) / (8 * a ^ 4))) ^ 4) := by\n    simp only [Nat.cast_pow, Nat.cast_ofNat, Nat.factorial, Nat.cast_one, mul_one,\n      zero_add, pow_one, Nat.succ_eq_add_one, Nat.reduceAdd, Nat.reduceMul]\n    ring\n  _ \u2264 (2 : \u211d) ^ (1 : \u211d) *\n      ( (12 + 8 * \u2191Z) / (Real.log 2 * ((q - 1) / (8 * a ^ 4)))\n      + (19 + 20 * \u2191Z)  / (Real.log 2 * ((q - 1) / (8 * a ^ 4))) ^ 2\n      + (14 + 32 * \u2191Z) / (Real.log 2 * ((q - 1) / (8 * a ^ 4))) ^ 3\n      + (24 * \u2191Z) /  (Real.log 2 * ((q - 1) / (8 * a ^ 4))) ^ 4) := by\n    gcongr\n    \u00b7 exact one_le_two\n    \u00b7 apply div_le_one_of_le\u2080 _ (by positivity)\n      have : 8 * (4 : \u211d) ^ 4 \u2264 8 * a ^ 4 := by gcongr\n      linarith\n  _ = (24 + 16 * \u2191Z) / (Real.log 2 * ((q - 1) / (8 * a ^ 4)))\n      + (38 + 40 * \u2191Z)  / (Real.log 2 * ((q - 1) / (8 * a ^ 4))) ^ 2\n      + (28 + 64 * \u2191Z) / (Real.log 2 * ((q - 1) / (8 * a ^ 4))) ^ 3\n      + (48 * \u2191Z) /  (Real.log 2 * ((q - 1) / (8 * a ^ 4))) ^ 4 := by\n    simp only [Real.rpow_one, Nat.cast_pow, Nat.cast_ofNat]\n    ring\n  _ = ((8 * a ^ 4) / (q - 1)) ^ 4 *\n     (((q - 1) / (8 * a ^ 4)) ^ 3 * (24 * 1 + 16 * \u2191Z) / Real.log 2\n      + ((q - 1) / (8 * a ^ 4)) ^ 2 * (38 * 1 + 40 * \u2191Z)  / (Real.log 2) ^ 2\n      + ((q - 1) / (8 * a ^ 4)) * (28 * 1 + 64 * \u2191Z) / (Real.log 2) ^ 3\n      + (48 * \u2191Z) /  (Real.log 2) ^ 4) := by\n    field_simp only\n    ring\n  _ \u2264 ((8 * a ^ 4) / (q - 1)) ^ 4 *\n     (((2 - 1) / (8 * 4 ^ 4)) ^ 3 * (24 * (Z / 2 ^ 48) + 16 * \u2191Z) / 0.6931471803\n      + ((2 - 1) / (8 * 4 ^ 4)) ^ 2 * (38 * (Z / 2 ^ 48) + 40 * \u2191Z)  / 0.6931471803 ^ 2\n      + ((2 - 1) / (8 * 4 ^ 4)) * (28 * (Z / 2 ^ 48) + 64 * \u2191Z) / 0.6931471803 ^ 3\n      + (48 * \u2191Z) / 0.6931471803 ^ 4) := by gcongr\n  _ = a ^ 16 / (q - 1) ^ 4 * Z * (8 ^ 4 *\n      (((2 - 1) / (8 * 4 ^ 4)) ^ 3 * (24 * (1 / 2 ^ 48) + 16) / 0.6931471803\n      + ((2 - 1) / (8 * 4 ^ 4)) ^ 2 * (38 * (1 / 2 ^ 48) + 40)  / 0.6931471803 ^ 2\n      + ((2 - 1) / (8 * 4 ^ 4)) * (28 * (1 / 2 ^ 48) + 64) / 0.6931471803 ^ 3\n      + 48 / 0.6931471803 ^ 4)) := by\n    rw [div_pow]; ring\n  _ \u2264 a ^ 16 / (q - 1) ^ 4 * Z * 2 ^ 20 := by gcongr; norm_num\n  _ \u2264 (2 ^ a) ^ 16 / (q - 1) ^ 4 * Z * 2 ^ 20 := by\n    gcongr\n    exact_mod_cast (Nat.lt_pow_self one_lt_two).le\n  _ = (2 ^ (16 * a) * 2 ^ (12 * a) * 2 ^ 20) / (q - 1) ^ 4 := by\n    simp [\u2190 pow_mul, mul_comm a]\n    ring\n  _ = 2 ^ (28 * a + 20) / (q - 1) ^ 4 := by\n    simp only [\u2190 pow_add]\n    congr\n    omega", "proofType": "tactic", "proofLengthLines": 82, "proofLengthTokens": 4110}}
{"srcContext": "/-\nCopyright (c) 2024 James Sundstrom. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: James Sundstrom\n-/\nimport Mathlib.MeasureTheory.Constructions.BorelSpace.Metric\n\n/-!\n# Annulus\n\nIn this file we define an annulus in a pseudometric space `X` to be a set consisting of all `y`\nsuch that `dist x y` lies in an interval between `r` and `R`. An annulus is defined for each type\nof interval (`Ioo`, `Ioc`, etc.) with a parallel naming scheme, except that we do not define annuli\nfor `Iio` and `Ico`, as they would be balls.\n\nWe also define `EAnnulus` similarly using `edist` instead of `dist`.\n\n## Tags\n\nannulus, eannulus\n-/\n\nopen Set Metric ENNReal\n\nvariable {X : Type*} [PseudoMetricSpace X]\n\nnamespace Set\n\nnamespace Annulus\n\ndef oo (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d) := {y | dist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d) := {y | dist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d) := {y | dist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d) := {y | dist x y \u2208 Ici r}\n\nlemma oo_eq {x : X} {r R : \u211d} : oo x r R = ball x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oo, dist_comm, and_comm]\n\n", "theoremStatement": "lemma oc_eq {x : X} {r R : \u211d} : oc x r R = closedBall x R \u2229 (closedBall x r)\u1d9c ", "theoremName": "Set.Annulus.oc_eq", "fileCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "theoremCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "file": "carleson/Carleson/ToMathlib/Annulus.lean", "module": "Carleson.ToMathlib.Annulus", "jsonFile": "Carleson.ToMathlib.Annulus.jsonl", "positionMetadata": {"lineInFile": 41, "tokenPositionInFile": 1205, "theoremPositionInFile": 7}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 1, "numPremises": 46}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  ext; simp [oc, dist_comm, and_comm]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 43}}
{"srcContext": "import Mathlib.MeasureTheory.Integral.MeanInequalities\nimport Mathlib.MeasureTheory.Integral.Layercake\nimport Mathlib.MeasureTheory.Integral.Lebesgue\nimport Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar\nimport Mathlib.Analysis.SpecialFunctions.Pow.Integral\nimport Carleson.ToMathlib.ENorm\nimport Carleson.ToMathlib.Misc\n\nnoncomputable section\n\nopen NNReal ENNReal NormedSpace MeasureTheory Set Filter Topology Function\n\nsection move\n\n\nvariable {\u03b1 \ud835\udd5c E : Type*} {m : MeasurableSpace \u03b1}\n  {\u03bc : Measure \u03b1} [NontriviallyNormedField \ud835\udd5c]\n  [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]\n  {p : \u211d\u22650\u221e}\n\n-- todo: move/rename/and perhaps reformulate in terms of \u2016.\u2016\u2091\nlemma ENNNorm_absolute_homogeneous {c : \ud835\udd5c} (z : E) : ofNNReal \u2016c \u2022 z\u2016\u208a = \u2191\u2016c\u2016\u208a * \u2191\u2016z\u2016\u208a :=\n  (toReal_eq_toReal_iff' coe_ne_top coe_ne_top).mp (norm_smul c z)\n\nlemma ENNNorm_add_le (y z : E) : ofNNReal \u2016y + z\u2016\u208a \u2264 \u2191\u2016y\u2016\u208a + \u2191\u2016z\u2016\u208a :=\n  (toReal_le_toReal coe_ne_top coe_ne_top).mp (nnnorm_add_le ..)\n\nlemma measure_mono_ae' {A B : Set \u03b1} (h : \u03bc (B \\ A) = 0) :\n    \u03bc B \u2264 \u03bc A := by\n  apply measure_mono_ae\n  change \u03bc {x | \u00ac B x \u2264 A x} = 0\n  simp only [le_Prop_eq, Classical.not_imp]\n  exact h\n\n\nlemma eLpNormEssSup_toReal_le {f : \u03b1 \u2192 \u211d\u22650\u221e} :\n    eLpNormEssSup (ENNReal.toReal \u2218 f) \u03bc \u2264 eLpNormEssSup f \u03bc := by\n  simp_rw [eLpNormEssSup, enorm_eq_self]\n  apply essSup_mono_ae\n  apply Eventually.of_forall\n  simp [implies_true]\n\nlemma eLpNormEssSup_toReal_eq {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : \u2200\u1d50 x \u2202\u03bc, f x \u2260 \u221e) :\n    eLpNormEssSup (ENNReal.toReal \u2218 f) \u03bc = eLpNormEssSup f \u03bc := by\n  simp_rw [eLpNormEssSup, enorm_eq_self]\n  apply essSup_congr_ae\n  filter_upwards [hf] with x hx\n  simp [hx]\n\nlemma eLpNorm'_toReal_le {f : \u03b1 \u2192 \u211d\u22650\u221e} {p : \u211d} (hp : 0 \u2264 p) :\n    eLpNorm' (ENNReal.toReal \u2218 f) p \u03bc \u2264 eLpNorm' f p \u03bc := by\n  simp_rw [eLpNorm', enorm_eq_self]\n  gcongr\n  simp\n\nlemma eLpNorm'_toReal_eq {f : \u03b1 \u2192 \u211d\u22650\u221e} {p : \u211d} (hf : \u2200\u1d50 x \u2202\u03bc, f x \u2260 \u221e) :\n    eLpNorm' (ENNReal.toReal \u2218 f) p \u03bc = eLpNorm' f p \u03bc := by\n  simp_rw [eLpNorm', enorm_eq_self]\n  congr 1\n  apply lintegral_congr_ae\n  filter_upwards [hf] with x hx\n  simp [hx]\n\nlemma eLpNorm_toReal_le {f : \u03b1 \u2192 \u211d\u22650\u221e} :\n    eLpNorm (ENNReal.toReal \u2218 f) p \u03bc \u2264 eLpNorm f p \u03bc := by\n  simp_rw [eLpNorm]\n  split_ifs\n  \u00b7 rfl\n  \u00b7 exact eLpNormEssSup_toReal_le\n  \u00b7 exact eLpNorm'_toReal_le toReal_nonneg\n\nlemma eLpNorm_toReal_eq {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : \u2200\u1d50 x \u2202\u03bc, f x \u2260 \u221e) :\n    eLpNorm (ENNReal.toReal \u2218 f) p \u03bc = eLpNorm f p \u03bc := by\n  simp_rw [eLpNorm]\n  split_ifs\n  \u00b7 rfl\n  \u00b7 exact eLpNormEssSup_toReal_eq hf\n  \u00b7 exact eLpNorm'_toReal_eq hf\n\nend move\n\nnamespace MeasureTheory\n\nvariable {\u03b1 \u03b1' \u03b5 \u03b5\u2081 \u03b5\u2082 \u03b5\u2083 \ud835\udd5c E E\u2081 E\u2082 E\u2083 : Type*} {m : MeasurableSpace \u03b1} {m : MeasurableSpace \u03b1'}\n  {p p' q : \u211d\u22650\u221e} {c : \u211d\u22650}\n  {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b1'} [NontriviallyNormedField \ud835\udd5c]\n  [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]\n  [NormedAddCommGroup E\u2081] [NormedSpace \ud835\udd5c E\u2081]\n  [NormedAddCommGroup E\u2082] [NormedSpace \ud835\udd5c E\u2082]\n  [NormedAddCommGroup E\u2083] [NormedSpace \ud835\udd5c E\u2083]\n  (L : E\u2081 \u2192L[\ud835\udd5c] E\u2082 \u2192L[\ud835\udd5c] E\u2083)\n  {t s x y : \u211d\u22650\u221e}\n  {T : (\u03b1 \u2192 \u03b5\u2081) \u2192 (\u03b1' \u2192 \u03b5\u2082)}\n\nsection ENorm\n\nvariable [ENorm \u03b5] {f g g\u2081 g\u2082 : \u03b1 \u2192 \u03b5}\n\n/- Proofs for this file can be found in\nFolland, Real Analysis. Modern Techniques and Their Applications, section 6.3. -/\n\n/-! # The distribution function `d_f` -/\n\n/-- The distribution function of a function `f`.\nNote that unlike the notes, we also define this for `t = \u221e`.\nNote: we also want to use this for functions with codomain `\u211d\u22650\u221e`, but for those we just write\n`\u03bc { x | t < f x }` -/\ndef distribution (f : \u03b1 \u2192 \u03b5) (t : \u211d\u22650\u221e) (\u03bc : Measure \u03b1) : \u211d\u22650\u221e :=\n  \u03bc { x | t < \u2016f x\u2016\u2091 }\n\n@[gcongr]\nlemma distribution_mono_right (h : t \u2264 s) : distribution f s \u03bc \u2264 distribution f t \u03bc :=\n  measure_mono fun _ a \u21a6 lt_of_le_of_lt h a\n\nlemma distribution_mono_right' : (Antitone (fun t \u21a6 distribution f t \u03bc)) :=\n  fun _ _ h \u21a6 distribution_mono_right h\n\n@[measurability, fun_prop]\nlemma distribution_measurable\u2080 : Measurable (fun t \u21a6 distribution f t \u03bc) :=\n  Antitone.measurable (distribution_mono_right' (f := f) (\u03bc := \u03bc))\n\n@[measurability, fun_prop]\nlemma distribution_measurable {g : \u03b1' \u2192 \u211d\u22650\u221e} (hg : Measurable g) :\n    Measurable (fun y : \u03b1' \u21a6 distribution f (g y) \u03bc) := by\n  fun_prop\n\nlemma distribution_toReal_le {f : \u03b1 \u2192 \u211d\u22650\u221e} :\n    distribution (ENNReal.toReal \u2218 f) t \u03bc \u2264 distribution f t \u03bc := by\n  simp_rw [distribution]\n  apply measure_mono\n  simp_rw [comp_apply, enorm_eq_self, setOf_subset_setOf]\n  intro x hx\n  exact hx.trans_le enorm_toReal_le\n\nlemma distribution_toReal_eq {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : \u2200\u1d50 x \u2202\u03bc, f x \u2260 \u221e) :\n    distribution (ENNReal.toReal \u2218 f) t \u03bc = distribution f t \u03bc := by\n  refine measure_congr (.set_eq ?_)\n  filter_upwards [hf] with x hx\n  simp [hx]\n\nlemma distribution_add_le_of_enorm {A : \u211d\u22650\u221e}\n    (h : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016\u2091 \u2264 A * (\u2016g\u2081 x\u2016\u2091 + \u2016g\u2082 x\u2016\u2091)) :\n    distribution f (A * (t + s)) \u03bc \u2264 distribution g\u2081 t \u03bc + distribution g\u2082 s \u03bc := by\n  unfold distribution\n  have h\u2081 : \u03bc ({x | A * (t + s) < \u2016f x\u2016\u2091} \\\n      ({x | t < \u2016g\u2081 x\u2016\u2091} \u222a {x | s < \u2016g\u2082 x\u2016\u2091})) = 0 := by\n    apply measure_mono_null ?_ h\n    intro x\n    simp only [mem_diff, mem_setOf_eq, mem_union, not_or, not_lt, mem_compl_iff, not_le, and_imp]\n    intro h\u2081 h\u2082 h\u2083\n    refine lt_of_le_of_lt ?_ h\u2081\n    gcongr\n  calc\n    \u03bc {x | A * (t + s) < \u2016f x\u2016\u2091}\n      \u2264 \u03bc ({x | t < \u2016g\u2081 x\u2016\u2091} \u222a {x | s < \u2016g\u2082 x\u2016\u2091}) := measure_mono_ae' h\u2081\n    _ \u2264 \u03bc {x | t < \u2016g\u2081 x\u2016\u2091} + \u03bc {x | s < \u2016g\u2082 x\u2016\u2091} := measure_union_le _ _\n\nlemma approx_above_superset (t\u2080 : \u211d\u22650\u221e) :\n    \u22c3 n, (fun n : \u2115 \u21a6 {x | t\u2080 + (\u2191n)\u207b\u00b9 < \u2016f x\u2016\u2091}) n = {x | t\u2080 < \u2016f x\u2016\u2091} := by\n  ext y\n  constructor <;> intro h\n  \u00b7 obtain \u27e8n, wn\u27e9 := exists_exists_eq_and.mp h\n    calc\n      t\u2080 \u2264 t\u2080 + (\u2191n)\u207b\u00b9 := le_self_add\n      _  < \u2016f y\u2016\u2091      := wn\n  \u00b7 have h\u2081 : Iio (\u2016f y\u2016\u2091 - t\u2080) \u2208 \ud835\udcdd 0 := Iio_mem_nhds (tsub_pos_of_lt h)\n    have h\u2082 := ENNReal.tendsto_inv_nat_nhds_zero h\u2081\n    simp only [mem_map, mem_atTop_sets, mem_preimage, mem_Iio] at h\u2082\n    rcases h\u2082 with \u27e8n, wn\u27e9\n    simp only [mem_iUnion, mem_setOf_eq]\n    use n\n    exact lt_tsub_iff_left.mp (wn n (Nat.le_refl n))\n\nlemma tendsto_measure_iUnion_distribution (t\u2080 : \u211d\u22650\u221e) :\n    Filter.Tendsto (\u21d1\u03bc \u2218 (fun n : \u2115 \u21a6 {x | t\u2080 + (\u2191n)\u207b\u00b9 < \u2016f x\u2016\u2091}))\n      Filter.atTop (nhds (\u03bc ({x | t\u2080 < \u2016f x\u2016\u2091}))) := by\n  rw [\u2190 approx_above_superset]\n  apply tendsto_measure_iUnion_atTop\n  intro a b h x h\u2081\n  calc\n    _ \u2264 t\u2080 + (\u2191a)\u207b\u00b9 := by gcongr\n    _ < _ := h\u2081\n\nlemma select_neighborhood_distribution (t\u2080 : \u211d\u22650\u221e) (l : \u211d\u22650\u221e)\n    (hu : l < distribution f t\u2080 \u03bc) :\n    \u2203 n : \u2115, l < distribution f (t\u2080 + (\u2191n)\u207b\u00b9) \u03bc := by\n  have h\u2081 : Ioi l \u2208 (\ud835\udcdd (distribution f t\u2080 \u03bc)) := Ioi_mem_nhds hu\n  have h\u2082 := (tendsto_measure_iUnion_distribution t\u2080) h\u2081\n  simp only [mem_map, mem_atTop_sets, mem_preimage, comp_apply, mem_Ioi] at h\u2082\n  rcases h\u2082 with \u27e8n, wn\u27e9\n  use n; exact wn n (Nat.le_refl n)\n\nlemma continuousWithinAt_distribution (t\u2080 : \u211d\u22650\u221e) :\n    ContinuousWithinAt (distribution f \u00b7 \u03bc) (Ioi t\u2080) t\u2080 := by\n  rcases (eq_top_or_lt_top t\u2080) with t\u2080top | t\u2080nottop\n  \u00b7 rw [t\u2080top]\n    apply continuousWithinAt_of_not_mem_closure\n    simp\n  \u00b7 unfold ContinuousWithinAt\n    rcases (eq_top_or_lt_top (distribution f t\u2080 \u03bc)) with db_top | db_not_top\n    -- Case: distribution f t\u2080 \u03bc = \u22a4\n    \u00b7 simp only\n      rw [db_top, ENNReal.tendsto_nhds_top_iff_nnreal]\n      intro b\n      have h\u2080 : \u2203 n : \u2115, \u2191b < distribution f (t\u2080 + (\u2191n)\u207b\u00b9) \u03bc :=\n        select_neighborhood_distribution _ _ (db_top \u25b8 coe_lt_top)\n      rcases h\u2080 with \u27e8n, wn\u27e9\n      refine eventually_mem_set.mpr (mem_inf_iff_superset.mpr \u27e8Iio (t\u2080 + (\u2191n)\u207b\u00b9), ?_, ?_\u27e9)\n      \u00b7 exact Iio_mem_nhds (lt_add_right t\u2080nottop.ne_top\n          (ENNReal.inv_ne_zero.mpr (ENNReal.natCast_ne_top n)))\n      \u00b7 exact \u27e8Ioi t\u2080, by simp, fun z h\u2081 \u21a6 wn.trans_le (distribution_mono_right (le_of_lt h\u2081.1))\u27e9\n    -- Case: distribution f t\u2080 \u03bc < \u22a4\n    \u00b7 refine (ENNReal.tendsto_nhds db_not_top.ne_top).mpr fun \u03b5 \u03b5_gt_0 \u21a6\n        eventually_mem_set.mpr (mem_inf_iff_superset.mpr ?_)\n      rcases eq_zero_or_pos (distribution f t\u2080 \u03bc) with db_zero | db_not_zero\n      -- Case: distribution f t\u2080 \u03bc = 0\n      \u00b7 use Ico 0 (t\u2080 + 1)\n        constructor\n        \u00b7 refine IsOpen.mem_nhds isOpen_Ico_zero ?_\n          simp only [mem_Ico, zero_le, lt_add_right t\u2080nottop.ne_top one_ne_zero, and_self]\n        \u00b7 use Ioi t\u2080\n          refine \u27e8by simp, fun z hz \u21a6 ?_\u27e9\n          rw [db_zero]\n          simp only [ge_iff_le, zero_le, tsub_eq_zero_of_le, zero_add]\n          have h\u2082 : distribution f z \u03bc \u2264 distribution f t\u2080 \u03bc :=\n            distribution_mono_right (le_of_lt hz.2)\n          rw [db_zero] at h\u2082\n          change Icc 0 \u03b5 (distribution f z \u03bc)\n          rw [nonpos_iff_eq_zero.mp h\u2082]\n          exact \u27e8zero_le 0, zero_le \u03b5\u27e9\n      -- Case: 0 < distribution f t\u2080 \u03bc\n      \u00b7 obtain \u27e8n, wn\u27e9 :=\n          select_neighborhood_distribution t\u2080 _ (ENNReal.sub_lt_self db_not_top.ne_top\n              (ne_of_lt db_not_zero).symm (ne_of_lt \u03b5_gt_0).symm)\n        use Iio (t\u2080 + (\u2191n)\u207b\u00b9)\n        constructor\n        \u00b7 exact Iio_mem_nhds (lt_add_right t\u2080nottop.ne_top\n            (ENNReal.inv_ne_zero.mpr (ENNReal.natCast_ne_top n)))\n        \u00b7 use Ioi t\u2080\n          refine \u27e8by simp, fun z h \u21a6 \u27e8?_, ?_\u27e9\u27e9\n          \u00b7 calc\n              distribution f t\u2080 \u03bc - \u03b5\n                \u2264 distribution f (t\u2080 + (\u2191n)\u207b\u00b9) \u03bc := le_of_lt wn\n              _ \u2264 distribution f z \u03bc             := distribution_mono_right (le_of_lt h.1)\n          \u00b7 calc\n              distribution f z \u03bc\n                \u2264 distribution f t\u2080 \u03bc := distribution_mono_right (le_of_lt h.2)\n              _ \u2264 distribution f t\u2080 \u03bc + \u03b5 := le_self_add\n\n/- The lemmas below are almost already in Mathlib, see\n`MeasureTheory.lintegral_rpow_eq_lintegral_meas_lt_mul`. -/\n\n-- /-- The layer-cake theorem, or Cavalieri's principle for functions into `\u211d\u22650\u221e` -/\n-- lemma lintegral_norm_pow_eq_measure_lt {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : AEMeasurable f \u03bc)\n--     {p : \u211d} (hp : 1 \u2264 p) :\n--     \u222b\u207b x, (f x) ^ p \u2202\u03bc =\n--     \u222b\u207b t in Ioi (0 : \u211d), .ofReal (p * t ^ (p - 1)) * \u03bc { x | ENNReal.ofReal t < f x } := by\n--   sorry\n\n/-- The weak L^p norm of a function, for `p < \u221e` -/\ndef wnorm' (f : \u03b1 \u2192 \u03b5) (p : \u211d) (\u03bc : Measure \u03b1) : \u211d\u22650\u221e :=\n  \u2a06 t : \u211d\u22650, t * distribution f t \u03bc ^ (p : \u211d)\u207b\u00b9\n\nlemma wnorm'_zero (f : \u03b1 \u2192 \u03b5) (\u03bc : Measure \u03b1) : wnorm' f 0 \u03bc = \u221e := by\n  simp only [wnorm', GroupWithZero.inv_zero, ENNReal.rpow_zero, mul_one, iSup_eq_top]\n  refine fun b hb \u21a6 \u27e8b.toNNReal + 1, ?_\u27e9\n  rw [coe_add, ENNReal.coe_one, coe_toNNReal hb.ne_top]\n  exact lt_add_right hb.ne_top one_ne_zero\n\nlemma wnorm'_toReal_le {f : \u03b1 \u2192 \u211d\u22650\u221e} {p : \u211d} (hp : 0 \u2264 p) :\n    wnorm' (ENNReal.toReal \u2218 f) p \u03bc \u2264 wnorm' f p \u03bc := by\n  refine iSup_mono fun x \u21a6 ?_\n  gcongr\n  exact distribution_toReal_le\n\nlemma wnorm'_toReal_eq {f : \u03b1 \u2192 \u211d\u22650\u221e} {p : \u211d} (hf : \u2200\u1d50 x \u2202\u03bc, f x \u2260 \u221e) :\n    wnorm' (ENNReal.toReal \u2218 f) p \u03bc = wnorm' f p \u03bc := by\n  simp_rw [wnorm', distribution_toReal_eq hf]\n\n/-- The weak L^p norm of a function. -/\ndef wnorm (f : \u03b1 \u2192 \u03b5) (p : \u211d\u22650\u221e) (\u03bc : Measure \u03b1) : \u211d\u22650\u221e :=\n  if p = \u221e then eLpNormEssSup f \u03bc else wnorm' f (ENNReal.toReal p) \u03bc\n\nlemma wnorm_zero : wnorm f 0 \u03bc = \u221e := by\n  simp [wnorm, wnorm'_zero]\n\n@[simp]\nlemma wnorm_top : wnorm f \u22a4 \u03bc = eLpNormEssSup f \u03bc := by simp [wnorm]\n\nlemma wnorm_coe {p : \u211d\u22650} : wnorm f p \u03bc = wnorm' f p \u03bc := by simp [wnorm]\n\nlemma wnorm_ofReal {p : \u211d} (hp : 0 \u2264 p) : wnorm f (.ofReal p) \u03bc = wnorm' f p \u03bc := by\n  simp [wnorm, hp]\n\nlemma wnorm_toReal_le {f : \u03b1 \u2192 \u211d\u22650\u221e} {p : \u211d\u22650\u221e} :\n    wnorm (ENNReal.toReal \u2218 f) p \u03bc \u2264 wnorm f p \u03bc := by\n  induction p\n  \u00b7 simp [eLpNormEssSup_toReal_le]\n  exact wnorm'_toReal_le toReal_nonneg\n\nlemma wnorm_toReal_eq {f : \u03b1 \u2192 \u211d\u22650\u221e} {p : \u211d\u22650\u221e} (hf : \u2200\u1d50 x \u2202\u03bc, f x \u2260 \u221e) :\n    wnorm (ENNReal.toReal \u2218 f) p \u03bc = wnorm f p \u03bc := by\n  simp_rw [wnorm, eLpNormEssSup_toReal_eq hf, wnorm'_toReal_eq hf]\n\nend ENorm\n\nsection ContinuousENorm\n\nvariable [ContinuousENorm \u03b5] [ContinuousENorm \u03b5\u2081] [ContinuousENorm \u03b5\u2082] [ContinuousENorm \u03b5\u2083]\n    {f : \u03b1 \u2192 \u03b5} {f\u2081 : \u03b1 \u2192 \u03b5\u2081}\n\nlemma wnorm'_le_eLpNorm' (hf : AEStronglyMeasurable f \u03bc) {p : \u211d} (hp : 1 \u2264 p) :\n    wnorm' f p \u03bc \u2264 eLpNorm' f p \u03bc := by\n  refine iSup_le (fun t \u21a6 ?_)\n  simp_rw [distribution, eLpNorm']\n  have p0 : 0 < p := lt_of_lt_of_le one_pos hp\n  have p0' : 0 \u2264 1 / p := (div_pos one_pos p0).le\n  have set_eq : {x | ofNNReal t < \u2016f x\u2016\u2091} = {x | ofNNReal t ^ p < \u2016f x\u2016\u2091 ^ p} := by\n    simp [ENNReal.rpow_lt_rpow_iff p0]\n  have : ofNNReal t = (ofNNReal t ^ p) ^ (1 / p) := by simp [p0.ne.symm]\n  nth_rewrite 1 [inv_eq_one_div p, this, \u2190 mul_rpow_of_nonneg _ _ p0', set_eq]\n  refine rpow_le_rpow ?_ p0'\n  refine le_trans ?_ <| mul_meas_ge_le_lintegral\u2080 (hf.enorm'.pow_const p) (ofNNReal t ^ p)\n  gcongr\n  exact setOf_subset_setOf.mpr (fun _ h \u21a6 h.le)\n\nlemma wnorm_le_eLpNorm (hf : AEStronglyMeasurable f \u03bc) {p : \u211d\u22650\u221e} (hp : 1 \u2264 p) :\n    wnorm f p \u03bc \u2264 eLpNorm f p \u03bc := by\n  by_cases h : p = \u22a4\n  \u00b7 simp [h, wnorm, eLpNorm]\n  \u00b7 have p0 : p \u2260 0 := (lt_of_lt_of_le one_pos hp).ne.symm\n    simpa [h, wnorm, eLpNorm, p0] using wnorm'_le_eLpNorm' hf (toReal_mono h hp)\n\n/-- A function is in weak-L^p if it is (strongly a.e.)-measurable and has finite weak L^p norm. -/\ndef MemW\u2112p (f : \u03b1 \u2192 \u03b5) (p : \u211d\u22650\u221e) (\u03bc : Measure \u03b1) : Prop :=\n  AEStronglyMeasurable f \u03bc \u2227 wnorm f p \u03bc < \u221e\n\nlemma Mem\u2112p.memW\u2112p (hp : 1 \u2264 p) (hf : Mem\u2112p f p \u03bc) : MemW\u2112p f p \u03bc :=\n  \u27e8hf.1, wnorm_le_eLpNorm hf.1 hp |>.trans_lt hf.2\u27e9\n\nlemma MemW\u2112p_zero : \u00ac MemW\u2112p f 0 \u03bc := by\n  simp [MemW\u2112p, wnorm_zero]\n\nlemma MemW\u2112p.aeStronglyMeasurable (hf : MemW\u2112p f p \u03bc) : AEStronglyMeasurable f \u03bc :=\n  hf.1\n\nlemma MemW\u2112p.wnorm_lt_top (hf : MemW\u2112p f p \u03bc) : wnorm f p \u03bc < \u22a4 :=\n  hf.2\n\nlemma MemW\u2112p.ennreal_toReal {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : MemW\u2112p f p \u03bc) :\n    MemW\u2112p (ENNReal.toReal \u2218 f) p \u03bc :=\n  \u27e8hf.aeStronglyMeasurable.ennreal_toReal, wnorm_toReal_le.trans_lt hf.2\u27e9\n\n/-- If a function `f` is `MemW\u2112p`, then its norm is almost everywhere finite.-/\ntheorem MemW\u2112p.ae_ne_top {f : \u03b1 \u2192 \u03b5} {p : \u211d\u22650\u221e} {\u03bc : Measure \u03b1}\n    (hf : MemW\u2112p f p \u03bc) : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016\u2091 \u2260 \u221e := by\n  by_cases hp_inf : p = \u221e\n  \u00b7 rw [hp_inf] at hf\n    simp_rw [\u2190 lt_top_iff_ne_top]\n    exact ae_lt_of_essSup_lt hf.2\n  by_cases hp_zero : p = 0\n  \u00b7 exact (MemW\u2112p_zero <| hp_zero \u25b8 hf).elim\n  set A := {x | \u2016f x\u2016\u2091 = \u221e} with hA\n  unfold MemW\u2112p wnorm wnorm' at hf\n  simp only [hp_inf] at hf\n  rw [Filter.eventually_iff, mem_ae_iff]\n  simp only [ne_eq, compl_def, mem_setOf_eq, Decidable.not_not, \u2190 hA]\n  have hp_toReal_zero := toReal_ne_zero.mpr \u27e8hp_zero, hp_inf\u27e9\n  have h1 (t : \u211d\u22650) : \u03bc A \u2264 distribution f t \u03bc := by\n    refine \u03bc.mono ?_\n    simp_all only [setOf_subset_setOf, coe_lt_top, implies_true, A]\n  set C := \u2a06 t : \u211d\u22650, t * distribution f t \u03bc ^ p.toReal\u207b\u00b9\n  by_cases hC_zero : C = 0\n  \u00b7 simp only [ENNReal.iSup_eq_zero, mul_eq_zero, ENNReal.rpow_eq_zero_iff, inv_neg'', C] at hC_zero\n    specialize hC_zero 1\n    simp only [one_ne_zero, ENNReal.coe_one, toReal_nonneg.not_lt, and_false, or_false,\n      false_or] at hC_zero\n    exact measure_mono_null (setOf_subset_setOf.mpr fun x hx => hx \u25b8 one_lt_top) hC_zero.1\n  by_contra h\n  have h2 : C < \u221e := by aesop\n  have h3 (t : \u211d\u22650) : distribution f t \u03bc \u2264 (C / t) ^ p.toReal := by\n    rw [\u2190 rpow_inv_rpow hp_toReal_zero (distribution ..)]\n    refine rpow_le_rpow ?_ toReal_nonneg\n    rw [ENNReal.le_div_iff_mul_le (Or.inr hC_zero) (Or.inl coe_ne_top), mul_comm]\n    exact le_iSup_iff.mpr fun _ a \u21a6 a t\n  have h4 (t : \u211d\u22650) : \u03bc A \u2264 (C / t) ^ p.toReal := (h1 t).trans (h3 t)\n  have h5 : \u03bc A \u2264 \u03bc A / 2 := by\n    convert h4 (C * (2 / \u03bc A) ^ p.toReal\u207b\u00b9).toNNReal\n    rw [coe_toNNReal ?_]\n    swap\n    \u00b7 refine mul_ne_top h2.ne_top (rpow_ne_top_of_nonneg (inv_nonneg.mpr toReal_nonneg) ?_)\n      simp [div_eq_top, h]\n    nth_rw 1 [\u2190 mul_one C]\n    rw [ENNReal.mul_div_mul_left _ _ hC_zero h2.ne_top, div_rpow_of_nonneg _ _ toReal_nonneg,\n      ENNReal.rpow_inv_rpow hp_toReal_zero, ENNReal.one_rpow, one_div,\n        ENNReal.inv_div (Or.inr ofNat_ne_top) (Or.inr (NeZero.ne' 2).symm)]\n  have h6 : \u03bc A = 0 := by\n    convert (fun hh \u21a6 ENNReal.half_lt_self hh (ne_top_of_le_ne_top (rpow_ne_top_of_nonneg\n      toReal_nonneg ((div_one C).symm \u25b8 h2.ne_top)) (h4 1))).mt h5.not_lt\n    tauto\n  exact h h6\n\n/- Todo: define `MeasureTheory.WLp` as a subgroup, similar to `MeasureTheory.Lp` -/\n\n/-- An operator has weak type `(p, q)` if it is bounded as a map from L^p to weak-L^q.\n`HasWeakType T p p' \u03bc \u03bd c` means that `T` has weak type (p, p') w.r.t. measures `\u03bc`, `\u03bd`\nand constant `c`.  -/\ndef HasWeakType (T : (\u03b1 \u2192 \u03b5\u2081) \u2192 (\u03b1' \u2192 \u03b5\u2082)) (p p' : \u211d\u22650\u221e) (\u03bc : Measure \u03b1) (\u03bd : Measure \u03b1')\n    (c : \u211d\u22650) : Prop :=\n  \u2200 f : \u03b1 \u2192 \u03b5\u2081, Mem\u2112p f p \u03bc \u2192 AEStronglyMeasurable (T f) \u03bd \u2227 wnorm (T f) p' \u03bd \u2264 c * eLpNorm f p \u03bc\n\n/-- A weaker version of `HasWeakType`. -/\ndef HasBoundedWeakType {\u03b1 \u03b1' : Type*} [Zero \u03b5\u2081]\n    {_x : MeasurableSpace \u03b1} {_x' : MeasurableSpace \u03b1'} (T : (\u03b1 \u2192 \u03b5\u2081) \u2192 (\u03b1' \u2192 \u03b5\u2082))\n    (p p' : \u211d\u22650\u221e) (\u03bc : Measure \u03b1) (\u03bd : Measure \u03b1') (c : \u211d\u22650) : Prop :=\n  \u2200 f : \u03b1 \u2192 \u03b5\u2081, Mem\u2112p f p \u03bc \u2192 eLpNorm f \u221e \u03bc < \u221e \u2192 \u03bc (support f) < \u221e \u2192\n  AEStronglyMeasurable (T f) \u03bd \u2227 wnorm (T f) p' \u03bd \u2264 c * eLpNorm f p \u03bc\n\n/-- An operator has strong type (p, q) if it is bounded as an operator on `L^p \u2192 L^q`.\n`HasStrongType T p p' \u03bc \u03bd c` means that `T` has strong type (p, p') w.r.t. measures `\u03bc`, `\u03bd`\nand constant `c`.  -/\ndef HasStrongType {\u03b1 \u03b1' : Type*}\n    {_x : MeasurableSpace \u03b1} {_x' : MeasurableSpace \u03b1'} (T : (\u03b1 \u2192 \u03b5\u2081) \u2192 (\u03b1' \u2192 \u03b5\u2082))\n    (p p' : \u211d\u22650\u221e) (\u03bc : Measure \u03b1) (\u03bd : Measure \u03b1') (c : \u211d\u22650) : Prop :=\n  \u2200 f : \u03b1 \u2192 \u03b5\u2081, Mem\u2112p f p \u03bc \u2192 AEStronglyMeasurable (T f) \u03bd \u2227 eLpNorm (T f) p' \u03bd \u2264 c * eLpNorm f p \u03bc\n\n/-- A weaker version of `HasStrongType`. This is the same as `HasStrongType` if `T` is continuous\nw.r.t. the L^2 norm, but weaker in general. -/\ndef HasBoundedStrongType {\u03b1 \u03b1' : Type*} [Zero \u03b5\u2081]\n    {_x : MeasurableSpace \u03b1} {_x' : MeasurableSpace \u03b1'} (T : (\u03b1 \u2192 \u03b5\u2081) \u2192 (\u03b1' \u2192 \u03b5\u2082))\n    (p p' : \u211d\u22650\u221e) (\u03bc : Measure \u03b1) (\u03bd : Measure \u03b1') (c : \u211d\u22650) : Prop :=\n  \u2200 f : \u03b1 \u2192 \u03b5\u2081, Mem\u2112p f p \u03bc \u2192 eLpNorm f \u221e \u03bc < \u221e \u2192 \u03bc (support f) < \u221e \u2192\n  AEStronglyMeasurable (T f) \u03bd \u2227 eLpNorm (T f) p' \u03bd \u2264 c * eLpNorm f p \u03bc\n\n\n/-! ### Lemmas about `HasWeakType` -/\n\n", "theoremStatement": "lemma HasWeakType.memW\u2112p (h : HasWeakType T p p' \u03bc \u03bd c) (hf\u2081 : Mem\u2112p f\u2081 p \u03bc) :\n    MemW\u2112p (T f\u2081) p' \u03bd ", "theoremName": "MeasureTheory.HasWeakType.memW\u2112p", "fileCreated": {"commit": "1a36cbeaee9466fb56c9aca49ef373f9f9cc7ab7", "date": "2025-01-23"}, "theoremCreated": {"commit": "b069d5bb71885f498386762866228ac78bf5409e", "date": "2025-01-13"}, "file": "carleson/Carleson/ToMathlib/WeakType.lean", "module": "Carleson.ToMathlib.WeakType", "jsonFile": "Carleson.ToMathlib.WeakType.jsonl", "positionMetadata": {"lineInFile": 438, "tokenPositionInFile": 17685, "theoremPositionInFile": 45}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 6, "numPremises": 41}, "proofMetadata": {"hasProof": true, "proof": ":=\n  \u27e8(h f\u2081 hf\u2081).1, h f\u2081 hf\u2081 |>.2.trans_lt <| mul_lt_top coe_lt_top hf\u2081.2\u27e9", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 74}}
{"srcContext": "import Carleson.ToMathlib.DoublingMeasure\nimport Carleson.ToMathlib.WeakType\nimport Mathlib.Algebra.Order.Group.Int\nimport Mathlib.Analysis.CStarAlgebra.Classes\nimport Mathlib.Data.Int.Star\n\nopen MeasureTheory Measure NNReal Metric Complex Set TopologicalSpace Bornology Function\nopen scoped ENNReal\nnoncomputable section\n\n-- todo: rename and protect `Real.RCLike`\n\n/-! Miscellaneous definitions.\nThese are mostly the definitions used to state the metric Carleson theorem.\nWe should move them to separate files once we start proving things about them. -/\n\nsection DoublingMeasure\nuniverse u\n\nvariable {\ud835\udd5c X : Type*} {A : \u2115} [_root_.RCLike \ud835\udd5c] [PseudoMetricSpace X]\n\nsection localOscillation\n\n/-- The local oscillation of two functions w.r.t. a set `E`. This is `d_E` in the blueprint. -/\ndef localOscillation (E : Set X) (f g : C(X, \ud835\udd5c)) : \u211d\u22650\u221e :=\n  \u2a06 z \u2208 E \u00d7\u02e2 E, ENNReal.ofReal \u2016f z.1 - g z.1 - f z.2 + g z.2\u2016\n\n-- example (E : Set X) (hE : IsBounded E) (f : C(X, \u211d)) :\n--     BddAbove (range fun z : E \u21a6 f z) := by\n--   have : IsCompact (closure E) := IsBounded.isCompact_closure hE\n--   sorry\n\n-- lemma bddAbove_localOscillation (E : Set X) [Fact (IsBounded E)] (f g : C(X, \ud835\udd5c)) :\n--     BddAbove ((fun z : X \u00d7 X \u21a6 \u2016f z.1 - g z.1 - f z.2 + g z.2\u2016) '' E \u00d7\u02e2 E) := sorry\n\nvariable {E : Set X} {f g : C(X, \ud835\udd5c)}\n\n--old\n/-- A ball w.r.t. the distance `localOscillation` -/\ndef localOscillationBall (E : Set X) (f : C(X, \ud835\udd5c)) (r : \u211d) :\n    Set C(X, \ud835\udd5c) :=\n  { g : C(X, \ud835\udd5c) | localOscillation E f g < ENNReal.ofReal r }\n\nend localOscillation\n\nlemma fact_isCompact_ball (x : X) (r : \u211d) : Fact (IsBounded (ball x r)) :=\n  \u27e8isBounded_ball\u27e9\nattribute [local instance] fact_isCompact_ball\n\n/-- A class stating that continuous functions have distances associated to every ball.\nWe use a separate type to conveniently index these functions. -/\nclass FunctionDistances (\ud835\udd5c : outParam Type*) (X : Type u)\n    [NormedField \ud835\udd5c] [TopologicalSpace X] where\n  \u0398 : Type u\n  coe\u0398 : \u0398 \u2192 C(X, \ud835\udd5c)\n  coe\u0398_injective {f g : \u0398} (h : \u2200 x, coe\u0398 f x = coe\u0398 g x) : f = g\n  metric : \u2200 (_x : X) (_r : \u211d), PseudoMetricSpace \u0398\n\nexport FunctionDistances (\u0398 coe\u0398)\n\nsection FunctionDistances\nvariable [FunctionDistances \ud835\udd5c X]\n\ninstance : Coe (\u0398 X) C(X, \ud835\udd5c) := \u27e8FunctionDistances.coe\u0398\u27e9\ninstance : FunLike (\u0398 X) X \ud835\udd5c where\n  coe := fun f \u21a6 (f : C(X, \ud835\udd5c))\n  coe_injective' _ _ hfg := FunctionDistances.coe\u0398_injective fun x \u21a6 congrFun hfg x\ninstance : ContinuousMapClass (\u0398 X) X \ud835\udd5c := \u27e8fun f \u21a6 (f : C(X, \ud835\udd5c)).2\u27e9\n\nset_option linter.unusedVariables false in\n@[nolint unusedArguments]\ndef WithFunctionDistance (x : X) (r : \u211d) := \u0398 X\n\nvariable {x : X} {r : \u211d}\n\ndef toWithFunctionDistance [FunctionDistances \ud835\udd5c X] : \u0398 X \u2243 WithFunctionDistance x r :=\n  .refl _\n\n-- instance : FunLike (WithFunctionDistance \u0398 x r) X \ud835\udd5c := ContinuousMap.funLike\n-- instance : ContinuousMapClass (WithFunctionDistance \u0398 x r) X \ud835\udd5c :=\n--   ContinuousMap.toContinuousMapClass\n\ninstance [d : FunctionDistances \ud835\udd5c X] : PseudoMetricSpace (WithFunctionDistance x r) :=\n  d.metric x r\n\nend FunctionDistances\n\nnotation3 \"dist_{\" x \" ,\" r \"}\" => @dist (WithFunctionDistance x r) _\nnotation3 \"nndist_{\" x \" ,\" r \"}\" => @nndist (WithFunctionDistance x r) _\nnotation3 \"ball_{\" x \" ,\" r \"}\" => @ball (WithFunctionDistance x r) _ in\n\n/-- A set `\u0398` of (continuous) functions is compatible. `A` will usually be `2 ^ a`. -/\nclass CompatibleFunctions (\ud835\udd5c : outParam Type*) (X : Type u) (A : outParam \u2115)\n  [RCLike \ud835\udd5c] [PseudoMetricSpace X] extends FunctionDistances \ud835\udd5c X where\n  eq_zero : \u2203 o : X, \u2200 f : \u0398, f o = 0\n  /-- The distance is bounded below by the local oscillation. (1.0.7) -/\n  localOscillation_le_cdist {x : X} {r : \u211d} {f g : \u0398} :\n    localOscillation (ball x r) (coe\u0398 f) (coe\u0398 g) \u2264 ENNReal.ofReal (dist_{x, r} f g)\n  /-- The distance is monotone in the ball. (1.0.9) -/\n  cdist_mono {x\u2081 x\u2082 : X} {r\u2081 r\u2082 : \u211d} {f g : \u0398}\n    (h : ball x\u2081 r\u2081 \u2286 ball x\u2082 r\u2082) : dist_{x\u2081, r\u2081} f g \u2264 dist_{x\u2082, r\u2082} f g\n  /-- The distance of a ball with large radius is bounded above. (1.0.8) -/\n  cdist_le {x\u2081 x\u2082 : X} {r : \u211d} {f g : \u0398} (h : dist x\u2081 x\u2082 < 2 * r) :\n    dist_{x\u2082, 2 * r} f g \u2264 A * dist_{x\u2081, r} f g\n  /-- The distance of a ball with large radius is bounded below. (1.0.10) -/\n  le_cdist {x\u2081 x\u2082 : X} {r : \u211d} {f g : \u0398} (h1 : ball x\u2081 r \u2286 ball x\u2082 (A * r)) :\n    /-(h2 : A * r \u2264 Metric.diam (univ : Set X))-/\n    2 * dist_{x\u2081, r} f g \u2264 dist_{x\u2082, A * r} f g\n  /-- The distance of a ball with large radius is bounded below. (1.0.11) -/\n  ballsCoverBalls {x : X} {r R : \u211d} :\n    BallsCoverBalls (X := WithFunctionDistance x r) (2 * R) R A\n\ninstance nonempty_Space [CompatibleFunctions \ud835\udd5c X A] : Nonempty X := by\n  obtain \u27e8x,_\u27e9 := \u2039CompatibleFunctions \ud835\udd5c X A\u203a.eq_zero\n  use x\n\ninstance inhabited_Space [CompatibleFunctions \ud835\udd5c X A] : Inhabited X :=\n  \u27e8nonempty_Space.some\u27e9\n\nlemma le_localOscillation [CompatibleFunctions \ud835\udd5c X A] (x : X) (r : \u211d) (f g : \u0398 X) {y z : X}\n    (hy : y \u2208 ball x r) (hz : z \u2208 ball x r) : \u2016coe\u0398 f y - coe\u0398 g y - coe\u0398 f z + coe\u0398 g z\u2016 \u2264\n    ENNReal.toReal (localOscillation (ball x r) (coe\u0398 f) (coe\u0398 g)) := by\n  rw [(ENNReal.toReal_ofReal (norm_nonneg _)).symm]\n  let f (z) := \u2a06 (_ : z \u2208 ball x r \u00d7\u02e2 ball x r), ENNReal.ofReal \u2016f z.1 - g z.1 - f z.2 + g z.2\u2016\n  apply ENNReal.toReal_mono\n  \u00b7 exact lt_of_le_of_lt CompatibleFunctions.localOscillation_le_cdist ENNReal.ofReal_lt_top |>.ne\n  \u00b7 exact le_of_eq_of_le (Eq.symm (iSup_pos \u27e8hy, hz\u27e9)) (le_iSup f \u27e8y, z\u27e9)\n\nlemma oscillation_le_cdist [CompatibleFunctions \ud835\udd5c X A] (x : X) (r : \u211d) (f g : \u0398 X) {y z : X}\n    (hy : y \u2208 ball x r) (hz : z \u2208 ball x r) :\n    \u2016coe\u0398 f y - coe\u0398 g y - coe\u0398 f z + coe\u0398 g z\u2016 \u2264 dist_{x, r} f g := by\n  apply le_trans <| le_localOscillation x r f g hy hz\n  rw [\u2190 ENNReal.toReal_ofReal dist_nonneg]\n  exact ENNReal.toReal_mono ENNReal.ofReal_ne_top CompatibleFunctions.localOscillation_le_cdist\n\nexport CompatibleFunctions (localOscillation_le_cdist cdist_mono cdist_le le_cdist)\n\nlemma dist_congr [FunctionDistances \ud835\udd5c X] {x\u2081 x\u2082 : X} {r\u2081 r\u2082 : \u211d} {f g : \u0398 X}\n    (e\u2081 : x\u2081 = x\u2082) (e\u2082 : r\u2081 = r\u2082) : dist_{x\u2081, r\u2081} f g = dist_{x\u2082, r\u2082} f g := by congr\n\nvariable (X) in\n/-- The point `o` in the blueprint -/\ndef cancelPt [CompatibleFunctions \ud835\udd5c X A] : X :=\n  CompatibleFunctions.eq_zero (\ud835\udd5c := \ud835\udd5c) |>.choose\nlemma cancelPt_eq_zero [CompatibleFunctions \ud835\udd5c X A] {f : \u0398 X} : f (cancelPt X) = 0 :=\n  CompatibleFunctions.eq_zero (\ud835\udd5c := \ud835\udd5c) |>.choose_spec f\n\n-- not sure if needed\n-- lemma CompatibleFunctions.IsSeparable [CompatibleFunctions \ud835\udd5c X A] :\n--   IsSeparable (range (coe\u0398 (X := X))) :=\n--   sorry\n\nset_option linter.unusedVariables false in\n/-- The inhomogeneous Lipschitz norm on a ball. -/\ndef iLipNorm {\ud835\udd5c} [NormedField \ud835\udd5c] (\u03d5 : X \u2192 \ud835\udd5c) (x\u2080 : X) (R : \u211d) : \u211d :=\n  (\u2a06 x \u2208 ball x\u2080 R, \u2016\u03d5 x\u2016) + R * \u2a06 (x : X) (y : X) (h : x \u2260 y), \u2016\u03d5 x - \u03d5 y\u2016 / dist x y\n\nlemma iLipNorm_nonneg {\ud835\udd5c} [NormedField \ud835\udd5c] {\u03d5 : X \u2192 \ud835\udd5c} {x\u2080 : X} {R : \u211d} (hR : 0 \u2264 R) :\n    0 \u2264 iLipNorm \u03d5 x\u2080 R :=\n  add_nonneg (Real.iSup_nonneg fun _ \u21a6 Real.iSup_nonneg fun _ \u21a6 norm_nonneg _)\n    (mul_nonneg hR (Real.iSup_nonneg fun _ \u21a6 Real.iSup_nonneg fun _ \u21a6 Real.iSup_nonneg\n    fun _ \u21a6 div_nonneg (norm_nonneg _) dist_nonneg))\n\nvariable [DoublingMeasure X A]\n\nvariable (X) in\n/-- \u0398 is \u03c4-cancellative. `\u03c4` will usually be `1 / a` -/\nclass IsCancellative (\u03c4 : \u211d) [CompatibleFunctions \u211d X A] : Prop where\n  norm_integral_exp_le {x : X} {r : \u211d} {\u03d5 : X \u2192 \u2102} {K : \u211d\u22650} (h1 : LipschitzWith K \u03d5)\n    (h2 : tsupport \u03d5 \u2286 ball x r) {f g : \u0398 X} :\n    \u2016\u222b x in ball x r, exp (I * (f x - g x)) * \u03d5 x\u2016 \u2264\n    A * volume.real (ball x r) * iLipNorm \u03d5 x r * (1 + dist_{x, r} f g) ^ (- \u03c4)\n\nexport IsCancellative (norm_integral_exp_le)\n\n/-- The \"volume function\" `V`. Note that we will need to assume\n`IsFiniteMeasureOnCompacts` and `ProperSpace` to actually know that this volume is finite. -/\ndef Real.vol {X : Type*} [PseudoMetricSpace X] [MeasureSpace X] (x y : X) : \u211d :=\n  volume.real (ball x (dist x y))\n\n-- /-- In Mathlib we only have the operator norm for continuous linear maps,\n-- and `T_*` is not linear.\n-- Here is the norm for an arbitrary map `T` between normed spaces\n-- (the infimum is defined to be 0 if the operator is not bounded). -/\n-- def operatorNorm {E F : Type*} [NormedAddCommGroup E] [NormedAddCommGroup F] (T : E \u2192 F) : \u211d :=\n--   sInf { c | 0 \u2264 c \u2227 \u2200 x, \u2016T x\u2016 \u2264 c * \u2016x\u2016 }\n\n/-- The Calderon Zygmund operator `T_r` in chapter Two-sided Metric Space Carleson -/\ndef CZOperator (K : X \u2192 X \u2192 \u2102) (r : \u211d) (f : X \u2192 \u2102) (x : X) : \u2102 :=\n  \u222b y in (ball x r)\u1d9c, K x y * f y\n\n/-- `R_Q(\u03b8, x)` defined in (1.0.20). -/\ndef upperRadius [FunctionDistances \u211d X] (Q : X \u2192 \u0398 X) (\u03b8 : \u0398 X) (x : X) : \u211d\u22650\u221e :=\n  \u2a06 (r : \u211d) (_ : dist_{x, r} \u03b8 (Q x) < 1), ENNReal.ofReal r\n\nlemma le_upperRadius [FunctionDistances \u211d X] {Q : X \u2192 \u0398 X} {\u03b8 : \u0398 X} {x : X} {r : \u211d}\n    (hr : dist_{x, r} \u03b8 (Q x) < 1) : ENNReal.ofReal r \u2264 upperRadius Q \u03b8 x := by\n  apply le_iSup\u2082 (f := fun r _ \u21a6 ENNReal.ofReal r) r hr\n\n/-- The linearized maximally truncated nontangential Calderon Zygmund operator `T_Q^\u03b8` -/\ndef linearizedNontangentialOperator [FunctionDistances \u211d X] (Q : X \u2192 \u0398 X) (\u03b8 : \u0398 X)\n    (K : X \u2192 X \u2192 \u2102) (f : X \u2192 \u2102) (x : X) : \u211d\u22650\u221e :=\n  \u2a06 (R\u2081 : \u211d) (x' : X) (_ : dist x x' \u2264 R\u2081),\n  \u2016\u222b y in {y | ENNReal.ofReal (dist x' y) \u2208 Ioo (ENNReal.ofReal R\u2081) (upperRadius Q \u03b8 x')},\n    K x' y * f y\u2016\u208a\n\n/-- The maximally truncated nontangential Calderon Zygmund operator `T_*` -/\ndef nontangentialOperator (K : X \u2192 X \u2192 \u2102) (f : X \u2192 \u2102) (x : X) : \u211d\u22650\u221e :=\n  \u2a06 (R\u2081 : \u211d) (R\u2082 : \u211d) (_ : R\u2081 < R\u2082) (x' : X) (_ : dist x x' < R\u2081),\n  \u2016\u222b y in {y | dist x' y \u2208 Ioo R\u2081 R\u2082}, K x' y * f y\u2016\u208a\n\n/-- The linearized generalized Carleson operator `T_Q`, taking values in `\u211d\u22650\u221e`.\nUse `ENNReal.toReal` to get the corresponding real number. -/\ndef linearizedCarlesonOperator [FunctionDistances \u211d X] (Q : X \u2192 \u0398 X) (K : X \u2192 X \u2192 \u2102)\n    (f : X \u2192 \u2102) (x : X) : \u211d\u22650\u221e :=\n  \u2a06 (R\u2081 : \u211d) (R\u2082 : \u211d) (_ : 0 < R\u2081) (_ : R\u2081 < R\u2082),\n  \u2016\u222b y in {y | dist x y \u2208 Ioo R\u2081 R\u2082}, K x y * f y * exp (I * Q x y)\u2016\u208a\n\n/-- The generalized Carleson operator `T`, taking values in `\u211d\u22650\u221e`.\nUse `ENNReal.toReal` to get the corresponding real number. -/\ndef carlesonOperator [FunctionDistances \u211d X] (K : X \u2192 X \u2192 \u2102) (f : X \u2192 \u2102) (x : X) : \u211d\u22650\u221e :=\n  \u2a06 (\u03b8 : \u0398 X), linearizedCarlesonOperator (fun _ \u21a6 \u03b8) K f x\n\n\nend DoublingMeasure\n\n/-- This is usually the value of the argument `A` in `DoublingMeasure`\nand `CompatibleFunctions` -/\n@[simp] abbrev defaultA (a : \u2115) : \u2115 := 2 ^ a\n@[simp] def defaultD (a : \u2115) : \u2115 := 2 ^ (100 * a ^ 2)\n@[simp] def default\u03ba (a : \u2115) : \u211d := 2 ^ (-10 * (a : \u211d))\n@[simp] def defaultZ (a : \u2115) : \u2115 := 2 ^ (12 * a)\n@[simp] def default\u03c4 (a : \u2115) : \u211d := a\u207b\u00b9\n\nlemma defaultD_pos (a : \u2115) : 0 < (defaultD a : \u211d) := by rw [defaultD]; positivity\n\nlemma defaultD_pos' (a : \u2115) : 0 < defaultD a := by exact_mod_cast defaultD_pos a\n\nlemma defaultD_pow_pos (a : \u2115) (z : \u2124) : 0 < (defaultD a : \u211d) ^ z :=\n  zpow_pos (defaultD_pos _) _\n\nlemma mul_defaultD_pow_pos (a : \u2115) {r : \u211d} (hr : 0 < r) (z : \u2124) : 0 < r * (defaultD a : \u211d) ^ z :=\n  mul_pos hr (defaultD_pow_pos a z)\n\nsection Kernel\n\nvariable {X : Type*} {a : \u2115} {K : X \u2192 X \u2192 \u2102} [PseudoMetricSpace X] [MeasureSpace X]\nopen Real (vol)\nopen Function\n\n/-- The constant used twice in the definition of the Calderon-Zygmund kernel. -/\n@[simp] def C_K (a : \u211d) : \u211d := 2 ^ a ^ 3\n\nlemma C_K_pos (a : \u211d) : 0 < C_K a := by unfold C_K; positivity\n\n/-- `K` is a one-sided Calderon-Zygmund kernel\nIn the formalization `K x y` is defined everywhere, even for `x = y`. The assumptions on `K` show\nthat `K x x = 0`. -/\nclass IsOneSidedKernel (a : outParam \u2115) (K : X \u2192 X \u2192 \u2102) : Prop where\n  measurable_K : Measurable (uncurry K)\n  norm_K_le_vol_inv (x y : X) : \u2016K x y\u2016 \u2264 C_K a / vol x y\n  norm_K_sub_le {x y y' : X} (h : 2 * dist y y' \u2264 dist x y) :\n    \u2016K x y - K x y'\u2016 \u2264 (dist y y' / dist x y) ^ (a : \u211d)\u207b\u00b9 * (C_K a / vol x y)\n\nexport IsOneSidedKernel (measurable_K norm_K_le_vol_inv norm_K_sub_le)\n\nlemma MeasureTheory.stronglyMeasurable_K [IsOneSidedKernel a K] :\n    StronglyMeasurable (uncurry K) :=\n  measurable_K.stronglyMeasurable\n\nlemma MeasureTheory.aestronglyMeasurable_K [IsOneSidedKernel a K] :\n    AEStronglyMeasurable (uncurry K) :=\n  measurable_K.aestronglyMeasurable\n\nlemma measurable_K_left [IsOneSidedKernel a K] (y : X) : Measurable (K \u00b7 y) :=\n  measurable_K.of_uncurry_right\n\nlemma measurable_K_right [IsOneSidedKernel a K] (x : X) : Measurable (K x) :=\n  measurable_K.of_uncurry_left\n\nlemma integrableOn_K_Icc [IsOpenPosMeasure (volume : Measure X)] [ProperSpace X]\n    [Regular (volume : Measure X)] [IsOneSidedKernel a K] {x : X} {r R : \u211d} (hr : r > 0) :\n    IntegrableOn (K x) {y | dist x y \u2208 Icc r R} volume := by\n  use Measurable.aestronglyMeasurable (measurable_K_right x)\n  rw [hasFiniteIntegral_def]\n  calc \u222b\u207b (y : X) in {y | dist x y \u2208 Icc r R}, \u2016K x y\u2016\u2091\n    _ \u2264 \u222b\u207b (y : X) in {y | dist x y \u2208 Icc r R},\n          ENNReal.ofReal (C_K a / volume.real (ball x r)) := by\n      refine setLIntegral_mono measurable_const (fun y hy \u21a6 ?_)\n      rw [\u2190 ofReal_norm]\n      refine ENNReal.ofReal_le_ofReal <| (norm_K_le_vol_inv x y).trans ?_\n      gcongr\n      \u00b7 exact (C_K_pos a).le\n      \u00b7 rw [measureReal_def]\n        apply ENNReal.toReal_pos (ne_of_gt <| measure_ball_pos volume x hr)\n        exact measure_ball_ne_top x r\n      \u00b7 exact measureReal_mono (ball_subset_ball hy.1)\n    _ < _ := by\n      rw [lintegral_const]\n      apply ENNReal.mul_lt_top ENNReal.ofReal_lt_top\n      rw [Measure.restrict_apply MeasurableSet.univ, univ_inter]\n      refine (Ne.lt_top fun h \u21a6 ?_)\n      have : {y | dist x y \u2208 Icc r R} \u2286 closedBall x R := by\n        intro y \u27e8_, hy\u27e9\n        exact mem_closedBall_comm.mp hy\n      exact measure_closedBall_lt_top.ne (measure_mono_top this h)\n\n/-- `K` is a two-sided Calderon-Zygmund kernel\nIn the formalization `K x y` is defined everywhere, even for `x = y`. The assumptions on `K` show\nthat `K x x = 0`. -/\nclass IsTwoSidedKernel (a : outParam \u2115) (K : X \u2192 X \u2192 \u2102) extends IsOneSidedKernel a K where\n  norm_K_sub_le' {x x' y : X} (h : 2 * dist x x' \u2264 dist x y) :\n    \u2016K x y - K x' y\u2016 \u2264 (dist x x' / dist x y) ^ (a : \u211d)\u207b\u00b9 * (C_K a / vol x y)\n\nexport IsTwoSidedKernel (norm_K_sub_le')\n\n-- maybe show: `K` is a 2-sided kernel iff `K` and `fun x y \u21a6 K y x` are one-sided kernels.\n\nend Kernel\n\n-- to show: K is locally bounded and hence integrable outside the diagonal\n\n\n/- A constant used on the boundedness of `T_*`. We generally assume\n`HasBoundedStrongType (nontangentialOperator K) volume volume 2 2 (C_Ts a)`\nthroughout this formalization. -/\ndef C_Ts (a : \u211d) : \u211d\u22650 := 2 ^ a ^ 3\n\n/-- Data common through most of chapters 2-9. -/\nclass PreProofData {X : Type*} (a : outParam \u2115) (q : outParam \u211d) (K : outParam (X \u2192 X \u2192 \u2102))\n  (\u03c3\u2081 \u03c3\u2082 : outParam (X \u2192 \u2124)) (F G : outParam (Set X)) [PseudoMetricSpace X] where\n  d : DoublingMeasure X (defaultA a)\n  four_le_a : 4 \u2264 a\n  cf : CompatibleFunctions \u211d X (defaultA a)\n  c : IsCancellative X (default\u03c4 a)\n  hcz : IsOneSidedKernel a K\n  hasBoundedStrongType_Tstar :\n    HasBoundedStrongType (nontangentialOperator K \u00b7 \u00b7) 2 2 volume volume (C_Ts a)\n  measurableSet_F : MeasurableSet F\n  measurableSet_G : MeasurableSet G\n  measurable_\u03c3\u2081 : Measurable \u03c3\u2081\n  measurable_\u03c3\u2082 : Measurable \u03c3\u2082\n  finite_range_\u03c3\u2081 : Finite (range \u03c3\u2081)\n  finite_range_\u03c3\u2082 : Finite (range \u03c3\u2082)\n  \u03c3\u2081_le_\u03c3\u2082 : \u03c3\u2081 \u2264 \u03c3\u2082\n  Q : SimpleFunc X (\u0398 X)\n  q_mem_Ioc : q \u2208 Ioc 1 2\n\nexport PreProofData (four_le_a hasBoundedStrongType_Tstar measurableSet_F measurableSet_G\n  measurable_\u03c3\u2081 measurable_\u03c3\u2082 finite_range_\u03c3\u2081 finite_range_\u03c3\u2082 \u03c3\u2081_le_\u03c3\u2082 Q q_mem_Ioc)\nattribute [instance] PreProofData.d PreProofData.cf PreProofData.c PreProofData.hcz\n\nsection ProofData\n\nvariable {X : Type*} {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102} {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X}\n  [PseudoMetricSpace X] [PreProofData a q K \u03c3\u2081 \u03c3\u2082 F G]\n\nsection Iterate\n\nlemma le_cdist_iterate {x : X} {r : \u211d} (hr : 0 \u2264 r) (f g : \u0398 X) (k : \u2115) :\n    2 ^ k * dist_{x, r} f g \u2264 dist_{x, (defaultA a) ^ k * r} f g := by\n  induction k with\n  | zero => rw [pow_zero, one_mul]; congr! <;> simp\n  | succ k ih =>\n    trans 2 * dist_{x, (defaultA a) ^ k * r} f g\n    \u00b7 rw [pow_succ', mul_assoc]\n      exact (mul_le_mul_left zero_lt_two).mpr ih\n    \u00b7 convert le_cdist (ball_subset_ball _) using 1\n      \u00b7 exact dist_congr rfl (by rw [\u2190 mul_assoc, pow_succ'])\n      \u00b7 nth_rw 1 [\u2190 one_mul ((defaultA a) ^ k * r)]; gcongr\n        rw [\u2190 Nat.cast_one, Nat.cast_le]; exact Nat.one_le_two_pow\n\nlemma cdist_le_iterate {x : X} {r : \u211d} (hr : 0 < r) (f g : \u0398 X) (k : \u2115) :\n    dist_{x, 2 ^ k * r} f g \u2264 (defaultA a) ^ k * dist_{x, r} f g := by\n  induction k with\n  | zero => simp_rw [pow_zero, one_mul]; congr! <;> simp\n  | succ k ih =>\n    trans defaultA a * dist_{x, 2 ^ k * r} f g\n    \u00b7 convert cdist_le _ using 1\n      \u00b7 exact dist_congr rfl (by ring)\n      \u00b7 rw [dist_self]; positivity\n    \u00b7 replace ih := (mul_le_mul_left (show 0 < (defaultA a : \u211d) by positivity)).mpr ih\n      rwa [\u2190 mul_assoc, \u2190 pow_succ'] at ih\n\nlemma ballsCoverBalls_iterate_nat {x : X} {d r : \u211d} {n : \u2115} :\n    BallsCoverBalls (WithFunctionDistance x d) (2 ^ n * r) r (defaultA a ^ n) := by\n  have double := fun s \u21a6 PreProofData.cf.ballsCoverBalls (x := x) (r := d) (R := s)\n  apply BallsCoverBalls.pow_mul double\n\nlemma ballsCoverBalls_iterate {x : X} {d R r : \u211d} (hR : 0 < R) (hr : 0 < r) :\n    BallsCoverBalls (WithFunctionDistance x d) R r (defaultA a ^ \u2308Real.logb 2 (R / r)\u2309\u208a) := by\n  apply ballsCoverBalls_iterate_nat.mono\n  calc\n    _ = R / r * r := by rw [div_mul_cancel\u2080 R hr.ne']\n    _ = 2 ^ Real.logb 2 (R / r) * r := by\n      rw [Real.rpow_logb zero_lt_two one_lt_two.ne' (by positivity)]\n    _ \u2264 _ := by\n      gcongr\n      rw [\u2190 Real.rpow_natCast]\n      exact Real.rpow_le_rpow_of_exponent_le one_le_two (Nat.le_ceil _)\n\nend Iterate\n\n@[fun_prop]\nlemma measurable_Q\u2082 : Measurable fun p : X \u00d7 X \u21a6 Q p.1 p.2 := fun s meass \u21a6 by\n  have : (fun p : X \u00d7 X \u21a6 (Q p.1) p.2) \u207b\u00b9' s = \u22c3 \u03b8 \u2208 Q.range, (Q \u207b\u00b9' {\u03b8}) \u00d7\u02e2 (\u03b8 \u207b\u00b9' s) := by\n    ext \u27e8x, y\u27e9\n    simp only [mem_preimage, SimpleFunc.mem_range, mem_range, iUnion_exists, iUnion_iUnion_eq',\n      mem_iUnion, mem_prod, mem_singleton_iff]\n    constructor <;> intro h\n    \u00b7 use x\n    \u00b7 obtain \u27e8j, hj\u27e9 := h; exact congr($(hj.1) y).symm \u25b8 hj.2\n  rw [this]\n  exact Q.range.measurableSet_biUnion fun \u03b8 _ \u21a6\n    (Q.measurableSet_fiber \u03b8).prod (meass.preimage (map_continuous \u03b8).measurable)\n\nlemma stronglyMeasurable_Q\u2082 : StronglyMeasurable fun p : X \u00d7 X \u21a6 Q p.1 p.2 :=\n  measurable_Q\u2082.stronglyMeasurable\n\n@[fun_prop]\nlemma aestronglyMeasurable_Q\u2082 : AEStronglyMeasurable fun p : X \u00d7 X \u21a6 Q p.1 p.2 :=\n  measurable_Q\u2082.aestronglyMeasurable\n\n@[fun_prop]\nlemma measurable_Q\u2081 (x : X) : Measurable (Q x) :=\n  let Q' : X \u2192 X \u2192 \u211d := fun x' y \u21a6 Q x' y\n  have : (fun y \u21a6 Q' x y) = Q x := rfl\n  this \u25b8 measurable_Q\u2082.of_uncurry_left\n\ninclude a q K \u03c3\u2081 \u03c3\u2082 F G\n\nvariable (X) in\nlemma S_spec : \u2203 n : \u2115, \u2200 x, -n \u2264 \u03c3\u2081 x \u2227 \u03c3\u2082 x \u2264 n := by\n  have h1 : (range \u03c3\u2081).Finite := finite_range_\u03c3\u2081\n  have h2 : (range \u03c3\u2082).Finite := finite_range_\u03c3\u2082\n  have h1' := bddBelow_def.mp h1.bddBelow\n  have h2' := bddAbove_def.mp h2.bddAbove\n  refine \u27e8(max (-h1'.choose) h2'.choose).toNat, fun x \u21a6 ?_\u27e9\n  simp only [Int.ofNat_toNat, \u2190 min_neg_neg, neg_neg, min_le_iff, le_max_iff]\n  exact \u27e8Or.inl (Or.inl (h1'.choose_spec _ (mem_range_self x))),\n    Or.inl (Or.inr (h2'.choose_spec _ (mem_range_self x)))\u27e9\n\nsection DBounds\n\nvariable (X)\n\n-- used in 4.1.7 (`small_boundary`)\nlemma twentyfive_le_realD : (25 : \u211d) \u2264 defaultD a := by\n  simp only [defaultD, Nat.ofNat_le_cast]\n  have : 4 \u2264 a := four_le_a X\n  calc\n    (25 : \u2115)\n      \u2264 32 := Nat.le_of_ble_eq_true rfl\n    _ = 2 ^ (5) := by rfl\n    _ \u2264 2 ^ (100 * 4 ^ 2) := Nat.le_of_ble_eq_true (by norm_num)\n    _ \u2264 2 ^ (100 * a ^ 2) := Nat.pow_le_pow_right (by norm_num)\n      (mul_le_mul_of_nonneg_left (Nat.pow_le_pow_of_le_left this 2) (by norm_num))\n\n-- used in 4.1.3 (`I3_prop_3_1`)\nlemma eight_le_realD : (8 : \u211d) \u2264 defaultD a := by\n  linarith [twentyfive_le_realD X]\n\n-- used in 4.1.6 (`transitive_boundary`)\nlemma five_le_realD : (5 : \u211d) \u2264 defaultD a := by\n  linarith [twentyfive_le_realD X]\n\n-- used in various places in `Carleson.TileExistence`\nlemma four_le_realD : (4 : \u211d) \u2264 defaultD a := by\n  linarith [twentyfive_le_realD X]\n\nlemma one_le_realD : (1 : \u211d) \u2264 defaultD a := by\n  linarith [twentyfive_le_realD X]\n\nopen Classical in\ndef defaultS : \u2115 := Nat.find (S_spec X)\n\nend DBounds\n\nlemma range_\u03c3\u2081_subset : range \u03c3\u2081 \u2286 Icc (- defaultS X) (defaultS X) := by\n  classical\n  rw [range_subset_iff]\n  exact fun x \u21a6 \u27e8(Nat.find_spec (S_spec X) x).1, (\u03c3\u2081_le_\u03c3\u2082 x).trans (Nat.find_spec (S_spec X) x).2\u27e9\n\nlemma range_\u03c3\u2082_subset : range \u03c3\u2082 \u2286 Icc (- defaultS X) (defaultS X) := by\n  classical\n  rw [range_subset_iff]\n  exact fun x \u21a6 \u27e8(Nat.find_spec (S_spec X) x).1.trans (\u03c3\u2081_le_\u03c3\u2082 x), (Nat.find_spec (S_spec X) x).2\u27e9\n\nlemma Icc_\u03c3_subset_Icc_S {x : X} : Icc (\u03c3\u2081 x) (\u03c3\u2082 x) \u2286 Icc (- defaultS X) (defaultS X) :=\n  fun _ h \u21a6 \u27e8(range_\u03c3\u2081_subset \u27e8x, rfl\u27e9).1.trans h.1, h.2.trans (range_\u03c3\u2082_subset \u27e8x, rfl\u27e9).2\u27e9\n\nlemma neg_S_mem_or_S_mem [Nonempty X] :\n    (- defaultS X : \u2124) \u2208 range \u03c3\u2081 \u2228 (defaultS X : \u2124) \u2208 range \u03c3\u2082 := by\n  by_cases h\u2080 : defaultS X = 0\n  \u00b7 right\n    simp only [h\u2080, CharP.cast_eq_zero, mem_range]\n    have : range \u03c3\u2082 \u2286 Icc (- defaultS X) (defaultS X) := range_\u03c3\u2082_subset\n    simp only [h\u2080, CharP.cast_eq_zero, neg_zero, Icc_self, subset_singleton_iff, mem_range,\n      forall_exists_index, forall_apply_eq_imp_iff] at this\n    let x : X := Classical.choice inferInstance\n    exact \u27e8x, this x\u27e9\n  by_contra! h\n  let n := (defaultS X) - 1\n  have h1 (x : X) : -n \u2264 \u03c3\u2081 x := by\n    rw [Int.natCast_sub (Nat.one_le_iff_ne_zero.mpr h\u2080), neg_sub, sub_eq_add_neg, add_comm]\n    exact lt_iff_le_and_ne.mpr \u27e8(range_\u03c3\u2081_subset (mem_range_self x)).1,\n      fun h' \u21a6 h.1 <| mem_range.mpr \u27e8x, h'.symm\u27e9\u27e9\n  have h2 (x : X) : \u03c3\u2082 x \u2264 n :=\n    Int.natCast_sub (Nat.one_le_iff_ne_zero.mpr h\u2080) \u25b8 le_sub_right_of_add_le (lt_iff_le_and_ne.mpr\n      \u27e8(range_\u03c3\u2082_subset (mem_range_self x)).2, fun h' \u21a6 h.2 <| mem_range.mpr \u27e8x, h'\u27e9\u27e9)\n  have hn : n < defaultS X := by\n    simp only [tsub_lt_self_iff, zero_lt_one, and_true, n]\n    exact Nat.zero_lt_of_ne_zero h\u2080\n  classical\n  exact Nat.find_min (S_spec X) hn fun x \u21a6 \u27e8h1 x, h2 x\u27e9\n\nvariable (X)\n\nlemma a_pos : 0 < a := by linarith [four_le_a X]\nlemma cast_a_pos : 0 < (a : \u211d) := by norm_cast; exact a_pos X\nlemma \u03c4_pos : 0 < default\u03c4 a := inv_pos.mpr (cast_a_pos X)\nlemma \u03c4_nonneg : 0 \u2264 default\u03c4 a := (\u03c4_pos X).le\n\n/-- `\u03c4` as an element of `\u211d\u22650`. -/\ndef nn\u03c4 : \u211d\u22650 := \u27e8default\u03c4 a, \u03c4_nonneg X\u27e9\n\nlemma one_lt_q : 1 < q := (q_mem_Ioc X).1\nlemma q_le_two : q \u2264 2 := (q_mem_Ioc X).2\nlemma q_pos : 0 < q := zero_lt_one.trans (one_lt_q X)\nlemma q_nonneg : 0 \u2264 q := (q_pos X).le\n", "theoremStatement": "lemma inv_q_sub_half_nonneg : 0 \u2264 q\u207b\u00b9 - 2\u207b\u00b9 ", "theoremName": "inv_q_sub_half_nonneg", "fileCreated": {"commit": "238b977db22d5b1107a09468e95b78facfd58fd1", "date": "2023-10-20"}, "theoremCreated": {"commit": "88d85ba29f717ee3bb9fbd37379a6fb77b57265f", "date": "2025-01-06"}, "file": "carleson/Carleson/Defs.lean", "module": "Carleson.Defs", "jsonFile": "Carleson.Defs.jsonl", "positionMetadata": {"lineInFile": 531, "tokenPositionInFile": 22390, "theoremPositionInFile": 68}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 3, "numPremises": 77}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp [inv_le_inv\u2080 zero_lt_two (q_pos X), q_le_two X]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 60}}
{"srcContext": "/-\nCopyright (c) 2024 James Sundstrom. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: James Sundstrom\n-/\nimport Mathlib.MeasureTheory.Constructions.BorelSpace.Metric\n\n/-!\n# Annulus\n\nIn this file we define an annulus in a pseudometric space `X` to be a set consisting of all `y`\nsuch that `dist x y` lies in an interval between `r` and `R`. An annulus is defined for each type\nof interval (`Ioo`, `Ioc`, etc.) with a parallel naming scheme, except that we do not define annuli\nfor `Iio` and `Ico`, as they would be balls.\n\nWe also define `EAnnulus` similarly using `edist` instead of `dist`.\n\n## Tags\n\nannulus, eannulus\n-/\n\nopen Set Metric ENNReal\n\nvariable {X : Type*} [PseudoMetricSpace X]\n\nnamespace Set\n\nnamespace Annulus\n\ndef oo (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d) := {y | dist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d) := {y | dist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d) := {y | dist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d) := {y | dist x y \u2208 Ici r}\n\nlemma oo_eq {x : X} {r R : \u211d} : oo x r R = ball x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oo, dist_comm, and_comm]\n\nlemma oc_eq {x : X} {r R : \u211d} : oc x r R = closedBall x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oc, dist_comm, and_comm]\n\nlemma co_eq {x : X} {r R : \u211d} : co x r R = ball x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [co, dist_comm, and_comm]\n\nlemma cc_eq {x : X} {r R : \u211d} : cc x r R = closedBall x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [cc, dist_comm, and_comm]\n\nlemma oi_eq {x : X} {r : \u211d} : oi x r = (closedBall x r)\u1d9c := by\n  ext; simp [oi, dist_comm]\n\nlemma ci_eq {x : X} {r : \u211d} : ci x r = (ball x r)\u1d9c := by\n  ext; simp [ci, dist_comm]\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : co x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma co_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : co x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\nlemma cc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : cc x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma cc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : cc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\n@[simp]\nlemma oc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    oc x r r' \u222a oo x r' R = oo x r R := by\n  ext; simp_rw [oc, oo, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioo_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    oc x r r' \u222a oc x r' R = oc x r R := by\n  ext; simp_rw [oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_co {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a co x r' R = oo x r R := by\n  ext; simp_rw [oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ico_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a cc x r' R = oc x r R := by\n  ext; simp_rw [oo, cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Icc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    cc x r r' \u222a oo x r' R = co x r R := by\n  ext; simp_rw [cc, oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioo_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    cc x r r' \u222a oc x r' R = cc x r R := by\n  ext; simp_rw [cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_co {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a co x r' R = co x r R := by\n  ext; simp_rw [co, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ico_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a cc x r' R = cc x r R := by\n  ext; simp_rw [co, cc, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Icc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : oc x r R \u222a oi x R = oi x r := by\n  ext; simp_rw [oc, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioi_eq_Ioi h]\n\n@[simp]\nlemma oo_union_ci {x : X} {r R : \u211d} (h : r < R) :\n    oo x r R \u222a ci x R = oi x r := by\n  ext; simp_rw [oo, ci, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ici_eq_Ioi h]\n\n@[simp]\nlemma cc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : cc x r R \u222a oi x R = ci x r := by\n  ext; simp_rw [cc, oi, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioi_eq_Ici h]\n\n@[simp]\nlemma co_union_ci {x : X} {r R : \u211d} (h : r \u2264 R) : co x r R \u222a ci x R = ci x r := by\n  ext; simp_rw [co, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ici_eq_Ici h]\n\n\nvariable [MeasurableSpace X] [OpensMeasurableSpace X]\n\n@[measurability]\nlemma measurableSet_oo {x : X} {r R : \u211d} : MeasurableSet (oo x r R) := by\n  rw [oo_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oc {x : X} {r R : \u211d} : MeasurableSet (oc x r R) := by\n rw [oc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_co {x : X} {r R : \u211d} : MeasurableSet (co x r R) := by\n  rw [co_eq]; measurability\n\n@[measurability]\nlemma measurableSet_cc {x : X} {r R : \u211d} : MeasurableSet (cc x r R) := by\n rw [cc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oi {x : X} {r : \u211d} : MeasurableSet (oi x r) := by\n  rw [oi_eq]; measurability\n\n@[measurability]\nlemma measurableSet_ci {x : X} {r : \u211d} : MeasurableSet (ci x r) := by\n  rw [ci_eq]; measurability\n\nend Annulus\n\nnamespace EAnnulus\n\ndef oo (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ici r}\n\n\nlemma oo_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oo x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oo x r R := by\n  simp_rw [oo, Annulus.oo, edist_dist, mem_Ioo, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma oc_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [oc, Annulus.oc, edist_dist, mem_Ioc, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  \u00b7 have R_le_r := (lt_of_lt_of_le (lt_of_not_ge hR) hr).le\n    rw [Annulus.oc_eq_empty R_le_r]\n    refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n    exact not_le_of_gt (lt_of_le_of_lt (ENNReal.ofReal_le_ofReal R_le_r) hy.1) hy.2\n\nlemma co_eq_annulus {x : X} {r R : \u211d} :\n    co x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.co x r R := by\n  simp_rw [co, Annulus.co, edist_dist, mem_Ico, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma cc_eq_annulus {x : X} {r R : \u211d} (h : r > 0 \u2228 R \u2265 0) :\n    cc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.cc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [cc, Annulus.cc, edist_dist, mem_Icc, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  have r0 := h.resolve_right hR\n  have R_lt_r := (lt_of_not_ge hR).trans r0\n  rw [Annulus.cc_eq_empty R_lt_r]\n  refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n  exact not_le_of_gt ((ENNReal.ofReal_lt_ofReal_iff r0).mpr R_lt_r) (hy.1.trans hy.2)\n\nlemma oi_eq_annulus {x : X} {r : \u211d} (hr : r \u2265 0) : oi x (ENNReal.ofReal r) = Annulus.oi x r := by\n  simp_rw [oi, Annulus.oi, edist_dist, mem_Ioi, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr]\n\nlemma ci_eq_annulus {x : X} {r : \u211d} : ci x (ENNReal.ofReal r) = Annulus.ci x r := by\n  simp_rw [ci, Annulus.ci, edist_dist, mem_Ici, ENNReal.ofReal_le_ofReal_iff dist_nonneg]\n\n\nlemma oo_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oo x r R = ball x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oo, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma oc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oc x r R = closedBall x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oc, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma co_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    co x r R = ball x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [co, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma cc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    cc x r R = closedBall x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [cc, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma oi_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : oi x r = (closedBall x r.toReal)\u1d9c := by\n  ext; simp [oi, edist_dist, dist_comm, lt_ofReal_iff_toReal_lt hr.ne]\n\nlemma ci_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : ci x r = (ball x r.toReal)\u1d9c := by\n  ext; simp [ci, edist_dist, dist_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg]\n\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n@[simp]\nlemma cc_top_eq_empty {x : X} {R : \u211d\u22650\u221e} : cc x \u22a4 R = \u2205 :=\n  eq_empty_of_forall_not_mem (fun y hy \u21a6 (edist_ne_top x y) (top_le_iff.mp hy.1))\n\n@[simp]\nlemma oi_eq_empty {x : X} : oi x \u22a4 = \u2205 := by simp [oi, edist_dist]\n\n@[simp]\nlemma ci_eq_empty {x : X} : ci x \u22a4 = \u2205 := by simp [ci, edist_dist]\n\n\nlemma oo_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) :\n    oo x r \u22a4 = (closedBall x r.toReal)\u1d9c := by\n  ext; simpa [oo, edist_dist, dist_comm] using lt_ofReal_iff_toReal_lt hr.ne\n\nlemma oc_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) :\n    oc x r \u22a4 = (closedBall x r.toReal)\u1d9c := by\n  ext; simpa [oc, edist_dist, dist_comm] using lt_ofReal_iff_toReal_lt hr.ne\n\nlemma co_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : co x r \u22a4 = (ball x r.toReal)\u1d9c := by\n  ext; simpa [co, edist_dist, dist_comm] using le_ofReal_iff_toReal_le hr.ne dist_nonneg\n\nlemma cc_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : cc x r \u22a4 = (ball x r.toReal)\u1d9c := by\n  ext; simpa [cc, edist_dist, dist_comm] using le_ofReal_iff_toReal_le hr.ne dist_nonneg\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) : co x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma co_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : co x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\nlemma cc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) : cc x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma cc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : cc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\n@[simp]\nlemma oc_union_oo {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    oc x r r' \u222a oo x r' R = oo x r R := by\n  ext; simp_rw [oc, oo, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioo_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oc {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    oc x r r' \u222a oc x r' R = oc x r R := by\n  ext; simp_rw [oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_co {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a co x r' R = oo x r R := by\n  ext; simp_rw [oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ico_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_cc {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a cc x r' R = oc x r R := by\n  ext; simp_rw [oo, cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Icc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oo {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    cc x r r' \u222a oo x r' R = co x r R := by\n  ext; simp_rw [cc, oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioo_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oc {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    cc x r r' \u222a oc x r' R = cc x r R := by\n  ext; simp_rw [cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_co {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a co x r' R = co x r R := by\n  ext; simp_rw [co, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ico_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_cc {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a cc x r' R = cc x r R := by\n  ext; simp_rw [co, cc, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Icc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oi {x : X} {r R : \u211d\u22650\u221e} (h : r \u2264 R) : oc x r R \u222a oi x R = oi x r := by\n  ext; simp_rw [oc, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioi_eq_Ioi h]\n\n@[simp]\nlemma oo_union_ci {x : X} {r R : \u211d\u22650\u221e} (h : r < R) :\n    oo x r R \u222a ci x R = oi x r := by\n  ext; simp_rw [oo, ci, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ici_eq_Ioi h]\n\n@[simp]\nlemma cc_union_oi {x : X} {r R : \u211d\u22650\u221e} (h : r \u2264 R) : cc x r R \u222a oi x R = ci x r := by\n  ext; simp_rw [cc, oi, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioi_eq_Ici h]\n\n@[simp]\nlemma co_union_ci {x : X} {r R : \u211d\u22650\u221e} (h : r \u2264 R) : co x r R \u222a ci x R = ci x r := by\n  ext; simp_rw [co, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ici_eq_Ici h]\n\n\nvariable [MeasurableSpace X] [OpensMeasurableSpace X]\n\n@[measurability]\n lemma measurableSet_oo {x : X} {r R : \u211d\u22650\u221e} : MeasurableSet (oo x r R) := by\n  by_cases hr : r = \u22a4\n  \u00b7 simp [hr]\n  replace hr : r < \u22a4 := Ne.lt_top hr\n  by_cases hR : R = \u22a4\n  \u00b7 simp [hR, oo_eq_of_top hr, measurableSet_closedBall]\n  rw [oo_eq_of_lt_top hr (Ne.lt_top hR)]\n  measurability\n\n@[measurability]\nlemma measurableSet_oc {x : X} {r R : \u211d\u22650\u221e} : MeasurableSet (oc x r R) := by\n  by_cases hr : r = \u22a4\n  \u00b7 simp [hr]\n  replace hr : r < \u22a4 := Ne.lt_top hr\n  by_cases hR : R = \u22a4\n  \u00b7 simp [hR, oc_eq_of_top hr, measurableSet_closedBall]\n  rw [oc_eq_of_lt_top hr (Ne.lt_top hR)]\n  measurability\n\n@[measurability]\nlemma measurableSet_co {x : X} {r R : \u211d\u22650\u221e} : MeasurableSet (co x r R) := by\n  by_cases hr : r = \u22a4\n  \u00b7 simp [hr]\n  replace hr : r < \u22a4 := Ne.lt_top hr\n  by_cases hR : R = \u22a4\n  \u00b7 simp [hR, co_eq_of_top hr, measurableSet_ball]\n  rw [co_eq_of_lt_top hr (Ne.lt_top hR)]\n  measurability\n\n@[measurability]\nlemma measurableSet_cc {x : X} {r R : \u211d\u22650\u221e} : MeasurableSet (cc x r R) := by\n  by_cases hr : r = \u22a4\n  \u00b7 simp [hr]\n  replace hr : r < \u22a4 := Ne.lt_top hr\n  by_cases hR : R = \u22a4\n  \u00b7 simp [hR, cc_eq_of_top hr, measurableSet_ball]\n  rw [cc_eq_of_lt_top hr (Ne.lt_top hR)]\n  measurability\n\n@[measurability]\nlemma measurableSet_oi {x : X} {r : \u211d\u22650\u221e} : MeasurableSet (oi x r) := by\n  by_cases hr : r = \u22a4\n  \u00b7 simp [hr]\n  \u00b7 rw [oi_eq_of_lt_top (Ne.lt_top hr)]; measurability\n\n", "theoremStatement": "@[measurability]\nlemma measurableSet_ci {x : X} {r : \u211d\u22650\u221e} : MeasurableSet (ci x r) ", "theoremName": "Set.EAnnulus.measurableSet_ci", "fileCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "theoremCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "file": "carleson/Carleson/ToMathlib/Annulus.lean", "module": "Carleson.ToMathlib.Annulus", "jsonFile": "Carleson.ToMathlib.Annulus.jsonl", "positionMetadata": {"lineInFile": 562, "tokenPositionInFile": 21905, "theoremPositionInFile": 128}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 3, "numPremises": 44}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  by_cases hr : r = \u22a4\n  \u00b7 simp [hr]\n  \u00b7 rw [ci_eq_of_lt_top (Ne.lt_top hr)]; measurability", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 96}}
{"srcContext": "import Carleson.Defs\nimport Mathlib.Algebra.Lie.OfAssociative\nimport Mathlib.Topology.EMetricSpace.Paracompact\n\nopen MeasureTheory Measure NNReal Metric Set TopologicalSpace Function DoublingMeasure Bornology\nopen scoped ENNReal\nnoncomputable section\n\n/-! The function `\u03c8` -/\n\nsection D\nvariable {D : \u2115} {x : \u211d} {s : \u2124} (hD : 1 < (D : \u211d))\n\nopen Real\n\nsection -- We record here some trivial inequalities that are used repeatedly below.\nprivate lemma fourD0' (hD : 1 \u2264 D) : 0 < (4 * D : \u211d) := by positivity\nprivate lemma four_x0 {x : \u211d} (hx : 0 < x) : 0 < 4 * x := mul_pos four_pos hx\ninclude hD\nprivate lemma D0 : 0 < (D : \u211d) := one_pos.trans hD\nprivate lemma D2 : 2 \u2264 (D : \u211d) := by exact_mod_cast hD\nprivate lemma twoD0 : 0 < (2 * D : \u211d) := by linarith\nprivate lemma fourD0 : 0 < (4 * D : \u211d) := by linarith\nprivate lemma D_pow0 (r : \u211d) : 0 < (D : \u211d) ^ r := by positivity\nprivate lemma D_pow0' (r : \u2124) : 0 < (D : \u211d) ^ r := by positivity\nprivate lemma cDx0 {c x : \u211d} (hc : c > 0) (hx : 0 < x) : c * D * x > 0 := by positivity\nend\n\ndef \u03c8 (D : \u2115) (x : \u211d) : \u211d :=\n  max 0 <| min 1 <| min (4 * D * x - 1) (2 - 4 * x)\n\nset_option hygiene false\nscoped[ShortVariables] notation \"\u03c8\" => \u03c8 (defaultD a)\n\nlemma zero_le_\u03c8 (D : \u2115) (x : \u211d) : 0 \u2264 \u03c8 D x :=\n  le_max_left 0 _\n\nlemma \u03c8_le_one (D : \u2115) (x : \u211d) : \u03c8 D x \u2264 1 :=\n  max_le (one_pos.le) (min_le_left 1 _)\n\nlemma abs_\u03c8_le_one (D : \u2115) (x : \u211d) : |\u03c8 D x| \u2264 1 :=\n  abs_le.2 \u27e8by linarith [zero_le_\u03c8 D x], \u03c8_le_one D x\u27e9\n\n---------------------------------------------\n/- `\u03c8_formula\u2080` through `\u03c8_formula\u2084` establish the piecewise formula for `\u03c8`. -/\n\nlemma \u03c8_formula\u2080 {x : \u211d} (hx : x \u2264 1 / (4 * D : \u211d)) : \u03c8 D x = 0 := by\n  by_cases hD : D = 0\n  \u00b7 simp [\u03c8, hD]\n  \u00b7 exact max_eq_left <| (min_le_right 1 _).trans <| (min_le_left _ _).trans <|\n      tsub_nonpos.2 <| (le_div_iff\u2080' (mul_pos four_pos\n      (by exact_mod_cast Nat.zero_lt_of_ne_zero hD))).1 hx\n\ninclude hD in\nlemma \u03c8_formula\u2081 {x : \u211d} (hx : 1 / (4 * D) \u2264 x \u2227 x \u2264 1 / (2 * D)) :\n    \u03c8 D x = 4 * D * x - 1 := by\n  have : x \u2265 0 := le_trans (one_div_nonneg.2 (fourD0 hD).le) hx.1\n  have hx1 := (div_le_iff\u2080' (fourD0 hD)).1 hx.1\n  have hx2 := (le_div_iff\u2080' (twoD0 hD)).1 hx.2\n  have ineq\u2080 : 4 * D * x - 1 \u2264 2 - 4 * x := by\n    suffices (2 * D + 2 * D + 4) * x \u2264 3 by linarith\n    exact le_trans (by gcongr; linarith [D2 hD]) (by linarith: (2 * D + 2 * D + 2 * D) * x \u2264 3)\n  have ineq\u2081 : 4 * D * x - 1 \u2264 1 := by linarith\n  have ineq\u2082 : 0 \u2264 4 * D * x - 1 := by linarith\n  rw [\u03c8, min_eq_left ineq\u2080, min_eq_right ineq\u2081, max_eq_right ineq\u2082]\n\ninclude hD in\nlemma \u03c8_formula\u2082 {x : \u211d} (hx : 1 / (2 * D) \u2264 x \u2227 x \u2264 1 / 4) : \u03c8 D x = 1 := by\n  unfold \u03c8\n  suffices min 1 (min (4 * D * x - 1) (2 - 4 * x)) = 1 from this.symm \u25b8 max_eq_right_of_lt one_pos\n  have := (div_le_iff\u2080' (twoD0 hD)).1 hx.1\n  exact min_eq_left (le_min (by linarith) (by linarith))\n\ninclude hD in\nlemma \u03c8_formula\u2083 {x : \u211d} (hx : 1 / 4 \u2264 x \u2227 x \u2264 1 / 2) : \u03c8 D x = 2 - 4 * x := by\n  have ineq\u2080 : 2 - 4 * x \u2264 4 * D * x - 1 := by nlinarith [D2 hD]\n  have ineq\u2081 : 2 - 4 * x \u2264 1 := by linarith\n  have ineq\u2082 : 2 - 4 * x \u2265 0 := by linarith\n  rw [\u03c8, min_eq_right ineq\u2080, min_eq_right ineq\u2081, max_eq_right ineq\u2082]\n\nlemma \u03c8_formula\u2084 {x : \u211d} (hx : x \u2265 1 / 2) : \u03c8 D x = 0 :=\n  max_eq_left <| (min_le_right _ _).trans <| (min_le_right _ _).trans (by linarith)\n---------------------------------------------\n\nlemma psi_zero : \u03c8 D 0 = 0 := \u03c8_formula\u2080 (by positivity)\n\nlemma continuous_\u03c8 : Continuous (\u03c8 D) := by\n  unfold \u03c8; fun_prop\n\ninclude hD in\nlemma support_\u03c8 : support (\u03c8 D) = Ioo (4 * D : \u211d)\u207b\u00b9 2\u207b\u00b9 := by\n  ext x\n  by_cases hx\u2080 : x \u2264 1 / (4 * D)\n  \u00b7 suffices x \u2264 (D : \u211d)\u207b\u00b9 * 4\u207b\u00b9 by simp [\u03c8_formula\u2080 hx\u2080, this]\n    rwa [one_div, mul_inv_rev] at hx\u2080\n  push_neg at hx\u2080\n  have hx\u2080_inv : (D : \u211d)\u207b\u00b9 * 4\u207b\u00b9 < x := by convert hx\u2080 using 1; simp\n  have ne\u2080 : 4 * D * x - 1 \u2260 0 := ne_of_gt (by rwa [sub_pos, \u2190 div_lt_iff\u2080' (fourD0 hD)])\n  by_cases hx\u2081 : x \u2264 1 / (2 * D)\n  \u00b7 suffices (D : \u211d)\u207b\u00b9 * 4\u207b\u00b9 < x \u2227 x < 2\u207b\u00b9 by simpa [ne\u2080, \u03c8_formula\u2081 hD \u27e8hx\u2080.le, hx\u2081\u27e9]\n    exact \u27e8hx\u2080_inv, lt_of_le_of_lt hx\u2081 (by simp [_root_.inv_lt_one_iff\u2080, hD])\u27e9\n  push_neg at hx\u2081\n  by_cases hx\u2082 : x \u2264 1 / 4\n  \u00b7 simpa [\u03c8_formula\u2082 hD \u27e8hx\u2081.le, hx\u2082\u27e9, hx\u2080_inv] using lt_of_le_of_lt hx\u2082 (by norm_num)\n  push_neg at hx\u2082\n  by_cases hx\u2083 : x < 1 / 2\n  \u00b7 have : \u00ac 2 - 4 * x = 0 := by linarith\n    simpa [\u03c8_formula\u2083 hD \u27e8hx\u2082.le, hx\u2083.le\u27e9, hx\u2080, hx\u2083, \u2190 one_div]\n  \u00b7 rw [mem_support, \u03c8_formula\u2084 (not_lt.1 hx\u2083), ne_self_iff_false, false_iff, mem_Ioo, not_and,\n      inv_eq_one_div 2]\n    exact fun _ \u21a6 hx\u2083\n\nlemma lipschitzWith_\u03c8 (hD : 1 \u2264 D) : LipschitzWith (4 * D) (\u03c8 D) := by\n  have max_eq_4D : max 0 (4 * D : \u211d\u22650) = 4 * D := max_eq_right (fourD0' hD).le\n  have max_eq_4D' : max (4 * D) 4 = 4 * D := by apply max_eq_left; linarith\n  suffices LipschitzWith (4 * D) (fun (x : \u211d) \u21a6 min 1 <| min (4 * D * x - 1) (2 - 4 * x)) from\n    max_eq_4D \u25b8 (LipschitzWith.const 0).max this\n  suffices LipschitzWith (4 * D) (fun (x : \u211d) \u21a6 min (4 * D * x - 1) (2 - 4 * x)) from\n    max_eq_4D \u25b8 (LipschitzWith.const 1).min this\n  have lw1 : LipschitzWith (4 * D) (fun (x : \u211d) \u21a6 4 * D * x - 1) := by\n    refine LipschitzWith.of_le_add_mul (4 * D) (fun x y \u21a6 ?_)\n    suffices 4 * D * (x - y) \u2264 4 * D * dist x y by norm_cast at this \u22a2; linarith\n    exact (mul_le_mul_left (fourD0' hD)).2 <| sub_le_dist x y\n  have lw2 : LipschitzWith 4 (fun (x : \u211d) \u21a6 2 - 4 * x) := by\n    refine LipschitzWith.of_le_add_mul 4 (fun x y \u21a6 ?_)\n    suffices 4 * (y - x) \u2264 4 * dist x y by norm_cast at this \u22a2; linarith\n    gcongr\n    exact dist_comm x y \u25b8 sub_le_dist y x\n  have := lw1.min lw2\n  norm_cast at this \u22a2\n  convert max_eq_4D' \u25b8 this\n\n-- Alternate version of `lipschitzWith_\u03c8` that avoids using `ENNReal`.\nlemma lipschitzWith_\u03c8' (hD : 1 \u2264 D) (a b : \u211d) : \u2016\u03c8 D a - \u03c8 D b\u2016 \u2264 4 * D * dist a b := by\n  have lipschitz := lipschitzWith_\u03c8 hD a b\n  rw [edist_dist, edist_dist, dist_eq_norm_sub] at lipschitz\n  norm_cast at lipschitz\n  rw [\u2190 ENNReal.ofReal_natCast, \u2190 ENNReal.ofReal_mul (by exact_mod_cast (fourD0' hD).le),\n    \u2190 ENNReal.toReal_le_toReal ENNReal.ofReal_ne_top ENNReal.ofReal_ne_top] at lipschitz\n  repeat rw [ENNReal.toReal_ofReal (by positivity)] at lipschitz\n  norm_cast\n\n/- the one or two numbers `s` where `\u03c8 (D ^ (-s) * x)` is possibly nonzero -/\nvariable (D) in def nonzeroS (x : \u211d) : Finset \u2124 :=\n  Finset.Icc \u230a(1 + logb D (2 * x))\u230b \u2308logb D (4 * x)\u2309\n\n---------------------------------------------\n\nsection include_hD\n\n/- The goal of the next several lemmas is to prove `sum_\u03c8`, which says that\n`\u2211 s \u2208 nonzeroS D x, \u03c8 D (D ^ (-s) * x) = 1`.\n\nThe first four lemmas prove some properties of the endpoints of `nonzeroS D x`, and in particular\nshow that `nonzeroS D x` has either 1 or 2 elements. The next two lemmas prove `sum_\u03c8` in the\n1-element and 2-element cases, respectively, and then `sum_\u03c8` follows immediately.\n-/\n\ninclude hD\n\nprivate lemma le_div_ceil_mul (hx : 0 < x) : 1 / (4 * D) \u2264 D ^ (-\u2308logb D (4 * x)\u2309) * x := by\n  rw [\u2190 div_le_iff\u2080 hx, div_div, \u2190 rpow_logb (D0 hD) (ne_of_gt hD) (cDx0 hD four_pos hx),\n    \u2190 inv_eq_one_div, (by norm_cast : (D : \u211d) ^ (-\u2308logb D (4 * x)\u2309) = D ^ (-\u2308logb D (4 * x)\u2309 : \u211d)),\n    \u2190 rpow_neg (D0 hD).le, rpow_le_rpow_left_iff hD, neg_le_neg_iff]\n  apply le_of_le_of_eq <| calc\n    (\u2308logb D (4 * x)\u2309 : \u211d) \u2264 \u230alogb D (4 * x)\u230b + 1 := by exact_mod_cast Int.ceil_le_floor_add_one _\n    _                     \u2264 logb D (4 * x) + 1   := by gcongr; exact Int.floor_le (logb D (4 * x))\n  rw [\u2190 logb_self_eq_one hD, \u2190 logb_mul (mul_pos four_pos hx).ne.symm (ne_of_gt (D0 hD)),\n    mul_assoc, mul_assoc, mul_comm _ x]\n\nprivate lemma one_add_logb (hx : x > 0) : 1 + logb D (2 * x) = logb D (2 * D * x) := by\n  rw [\u2190 logb_self_eq_one hD, \u2190 logb_mul (D0 hD).ne.symm (mul_pos two_pos hx).ne.symm,\n    \u2190 mul_assoc, mul_comm (D : \u211d) 2]\n\n-- If `D ^ (-\u2308logb D (4 * x)\u2309) \u2265 1 / (2 * D * x)`, then the endpoints of `nonzeroS x` are equal.\nprivate lemma eq_endpoints (hx : 0 < x) (h : D ^ (-\u2308logb D (4 * x)\u2309) \u2265 1 / (2 * D * x)) :\n    \u230a(1 + logb D (2 * x))\u230b = \u2308logb D (4 * x)\u2309 := by\n  rw [Int.floor_eq_iff, one_add_logb hD hx]\n  constructor\n  \u00b7 rw [\u2190 rpow_le_rpow_left_iff hD, \u2190 inv_le_inv\u2080 (D_pow0 hD _) (D_pow0 hD _),\n      rpow_logb (D0 hD) (ne_of_gt hD) (cDx0 hD two_pos hx),\n      \u2190 rpow_neg (D0 hD).le, inv_eq_one_div]\n    exact_mod_cast h.le\n  \u00b7 have : logb D (2 * D * x) < logb D (4 * D * x) := by\n      refine (strictMonoOn_logb hD) ?_ ?_ (by linarith [(cDx0 hD two_pos hx)]) <;>\n        exact mem_Ioi.2 (cDx0 hD (by norm_num) hx)\n    apply lt_of_lt_of_le this\n    rw [mul_comm, \u2190 mul_assoc, mul_comm x 4, logb_mul (mul_pos four_pos hx).ne.symm (D0 hD).ne.symm,\n      logb_self_eq_one hD, add_le_add_iff_right, mul_comm]\n    exact Int.le_ceil _\n\n-- If `D ^ (-\u2308logb D (4 * x)\u2309) < 1 / (2 * D * x)`, then the endpoints of `nonzeroS x` differ by 1.\nprivate lemma endpoint_sub_one (hx : 0 < x) (h : D ^ (-\u2308logb D (4 * x)\u2309) < 1 / (2 * D * x)) :\n    \u230a1 + logb D (2 * x)\u230b = \u2308logb D (4 * x)\u2309 - 1 := by\n  rw [one_add_logb hD hx]\n  apply le_antisymm\n  \u00b7 rw [\u2190 inv_eq_one_div, zpow_neg, inv_lt_inv\u2080 (D_pow0' hD _) (cDx0 hD two_pos hx)] at h\n    rw [Int.floor_le_sub_one_iff, \u2190 rpow_lt_rpow_left_iff hD,\n      rpow_logb (D0 hD) (ne_of_gt hD) (cDx0 hD two_pos hx)]\n    exact_mod_cast h\n  \u00b7 apply sub_le_iff_le_add.2 \u2218 Int.ceil_le.2\n    suffices logb D (4 * x) \u2264 logb D (2 * D * x) by\n      exact_mod_cast (lt_of_le_of_lt this (Int.lt_floor_add_one _)).le\n    have : 4 * x \u2264 2 * D * x := (mul_le_mul_right hx).2 (by linarith [D2 hD])\n    refine (strictMonoOn_logb hD).monotoneOn ?_ ?_ this <;> exact mem_Ioi.2 (by positivity)\n\n-- Special case of `sum_\u03c8`, for the case where `nonzeroS D x` has one element.\nprivate lemma sum_\u03c8\u2081 (hx : 0 < x) (h : D ^ (-\u2308logb D (4 * x)\u2309) \u2265 1 / (2 * D * x)) :\n    \u2211 s \u2208 nonzeroS D x, \u03c8 D (D ^ (-s) * x) = 1 := by\n  rw [nonzeroS, eq_endpoints hD hx h, Finset.Icc_self, Finset.sum_singleton]\n  refine \u03c8_formula\u2082 hD \u27e8le_of_eq_of_le (by field_simp) ((mul_le_mul_right hx).2 h), ?_\u27e9\n  calc\n    D ^ (-\u2308logb D (4 * x)\u2309) * x\n      = D ^ (-\u2308logb D (4 * x)\u2309 : \u211d) * x := by norm_cast\n    _ \u2264 D ^ (-logb D (4 * x)) * x      := by\n      gcongr\n      \u00b7 exact hD.le\n      \u00b7 exact Int.le_ceil (logb D (4 * x))\n    _ = 1 / (4 * x) * x                := by\n      rw [rpow_neg (D0 hD).le, inv_eq_one_div, rpow_logb (D0 hD) hD.ne.symm (by linarith)]\n    _ = 1 / 4                          := by field_simp; exact mul_comm x 4\n\n-- Special case of `sum_\u03c8`, for the case where `nonzeroS D x` has two elements.\nprivate lemma sum_\u03c8\u2082 (hx : 0 < x)\n    (h : D ^ (-\u2308logb D (4 * x)\u2309) < 1 / (2 * D * x)) :\n    \u2211 s \u2208 nonzeroS D x, \u03c8 D (D ^ (-s) * x) = 1 := by\n  -- Replace `nonzeroS D x` with `{s\u2080 - 1, s\u2080}`, where `s\u2080 := \u2308logb D (4 * x)\u2309`\n  have endpts := endpoint_sub_one hD hx h\n  have ne : \u2308logb D (4 * x)\u2309 - 1 \u2260 \u2308logb D (4 * x)\u2309 := pred_ne_self _\n  have : nonzeroS D x = {\u2308logb D (4 * x)\u2309 - 1, \u2308logb D (4 * x)\u2309} := by\n    rw [nonzeroS, \u2190 endpts]\n    have Icc_of_eq_add_one {a b : \u2124} (h : a + 1 = b) : Finset.Icc a b = {a, b} := by\n      subst h; exact Int.Icc_eq_pair a\n    exact Icc_of_eq_add_one (add_eq_of_eq_sub endpts)\n  set s\u2080 := \u2308logb D (4 * x)\u2309\n  rw [this, Finset.sum_insert ((Finset.not_mem_singleton).2 ne), Finset.sum_singleton]\n  -- Now calculate the sum\n  have Ds\u2080x_lt := (mul_lt_mul_right hx).2 h\n  rw [\u2190 div_div, div_mul_cancel\u2080 _ (ne_of_gt hx)] at Ds\u2080x_lt\n  have hs\u2080 := And.intro (le_div_ceil_mul hD hx) Ds\u2080x_lt.le\n  suffices 1 / 4 \u2264 D ^ (-(s\u2080 - 1)) * x \u2227 D ^ (-(s\u2080 - 1)) * x \u2264 1 / 2 by\n    rw [\u03c8_formula\u2081 hD hs\u2080, \u03c8_formula\u2083 hD this]\n    suffices (D : \u211d) ^ (1 - s\u2080) = D * D ^ (-s\u2080) by rw [neg_sub, this]; ring\n    rw [zpow_sub\u2080 (ne_of_gt (D0 hD)), zpow_neg, zpow_one, div_eq_mul_inv]\n  rw [neg_sub, sub_eq_add_neg, zpow_add\u2080 (ne_of_gt (D0 hD)), zpow_one, mul_assoc]\n  constructor\n  \u00b7 rw [\u2190 div_le_iff\u2080' (D0 hD), div_div]; exact hs\u2080.1\n  \u00b7 rw [\u2190 le_div_iff\u2080' (D0 hD), div_div]; exact hs\u2080.2\n\n-- See `finsum_\u03c8` for the version that doesn't explicitly restrict to the support.\nlemma sum_\u03c8 (hx : 0 < x) : \u2211 s \u2208 nonzeroS D x, \u03c8 D (D ^ (-s) * x) = 1 := by\n  by_cases h : D ^ (-\u2308logb D (4 * x)\u2309) \u2265 1 / (2 * D * x)\n  \u00b7 exact sum_\u03c8\u2081 hD hx h\n  \u00b7 exact sum_\u03c8\u2082 hD hx (lt_of_not_ge h)\n\n--------------------------------------------------\n/- Now we prove that `nonzeroS D x` is the support of `s \u21a6 \u03c8 D (D ^ (-s) * x)`. This converts\n`sum_\u03c8` into `finsum_\u03c8`, which states that `\u2211\u1da0 s : \u2124, \u03c8 D (D ^ (-s) * x) = 1`. -/\n\nlemma mem_nonzeroS_iff {i : \u2124} {x : \u211d} (hx : 0 < x) :\n    i \u2208 nonzeroS D x \u2194 (D ^ (-i) * x) \u2208 Ioo (4 * D : \u211d)\u207b\u00b9 2\u207b\u00b9 := by\n  rw [mem_Ioo, nonzeroS, Finset.mem_Icc, Int.floor_le_iff, Int.le_ceil_iff, mul_inv_rev,\n    add_comm _ 1, Real.add_lt_add_iff_left, \u2190 lt_div_iff\u2080 hx, mul_comm (D : \u211d)\u207b\u00b9,\n    \u2190 div_lt_div_iff\u2080 hx (inv_pos.2 (D0 hD)), div_inv_eq_mul, \u2190 zpow_add_one\u2080 ((D0 hD).ne.symm),\n    zpow_neg, \u2190 Real.rpow_intCast, \u2190 Real.rpow_intCast, lt_logb_iff_rpow_lt hD (four_x0 hx),\n    logb_lt_iff_lt_rpow hD (mul_pos two_pos hx), \u2190 sub_eq_neg_add, \u2190 neg_sub i 1, \u2190 inv_mul',\n    \u2190 inv_mul', inv_lt_inv\u2080 (D_pow0 hD _) (mul_pos two_pos hx), Int.cast_neg, Int.cast_sub,\n    Int.cast_one, rpow_neg (D0 hD).le, inv_lt_inv\u2080 (four_x0 hx) (D_pow0 hD _), and_comm]\n\nlemma psi_ne_zero_iff {x : \u211d} (hx : 0 < x) :\n    \u03c8 D (D ^ (-s) * x) \u2260 0 \u2194 s \u2208 nonzeroS D x := by\n  rw [\u2190 mem_support, support_\u03c8 (by exact_mod_cast hD), mem_nonzeroS_iff hD hx]\n\nlemma psi_eq_zero_iff {x : \u211d} (hx : 0 < x) : \u03c8 D (D ^ (-s) * x) = 0 \u2194 s \u2209 nonzeroS D x := by\n  rw [\u2190 iff_not_comm, \u2190 psi_ne_zero_iff hD hx]\n\nlemma support_\u03c8S (hx : 0 < x) : support (fun (s : \u2124) \u21a6 \u03c8 D (D ^ (-s) * x)) = nonzeroS D x := by\n  ext; rw [mem_support]; exact psi_ne_zero_iff hD hx\n\n", "theoremStatement": "lemma support_\u03c8S_subset_Icc {b c : \u2124} {x : \u211d}\n    (h : x \u2208 Icc ((D : \u211d) ^ (b - 1) / 2) (D ^ c / 4)) :\n    support (fun (s : \u2124) \u21a6 \u03c8 D (D ^ (-s) * x)) \u2286 Icc b c ", "theoremName": "support_\u03c8S_subset_Icc", "fileCreated": {"commit": "743fbe4ea5741cd92c855e66055ba156f232beff", "date": "2024-06-16"}, "theoremCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "file": "carleson/Carleson/Psi.lean", "module": "Carleson.Psi", "jsonFile": "Carleson.Psi.jsonl", "positionMetadata": {"lineInFile": 280, "tokenPositionInFile": 13500, "theoremPositionInFile": 36}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 3, "numPremises": 177}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  intro i hi\n  have hx : x > 0 := lt_of_lt_of_le (by positivity) h.1\n  simp only [support_\u03c8S hD hx, nonzeroS, Finset.coe_Icc, mem_Icc] at hi\n  simp only [toFinset_Icc, Finset.coe_Icc, mem_Icc]\n  refine \u27e8le_trans ?_ hi.1, le_trans hi.2 ?_\u27e9\n  \u00b7 rw [\u2190 Nat.cast_one, Int.floor_nat_add, Nat.cast_one, \u2190 sub_le_iff_le_add', Int.le_floor,\n      Real.le_logb_iff_rpow_le hD (mul_pos two_pos hx), mul_comm]\n    exact_mod_cast (div_le_iff\u2080 two_pos).mp h.1\n  \u00b7 rw [Int.ceil_le, Real.logb_le_iff_le_rpow hD (mul_pos four_pos hx), mul_comm]\n    exact_mod_cast (le_div_iff\u2080 four_pos).mp h.2", "proofType": "tactic", "proofLengthLines": 10, "proofLengthTokens": 582}}
{"srcContext": "/-\nCopyright (c) 2024 James Sundstrom. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: James Sundstrom\n-/\nimport Mathlib.MeasureTheory.Constructions.BorelSpace.Metric\n\n/-!\n# Annulus\n\nIn this file we define an annulus in a pseudometric space `X` to be a set consisting of all `y`\nsuch that `dist x y` lies in an interval between `r` and `R`. An annulus is defined for each type\nof interval (`Ioo`, `Ioc`, etc.) with a parallel naming scheme, except that we do not define annuli\nfor `Iio` and `Ico`, as they would be balls.\n\nWe also define `EAnnulus` similarly using `edist` instead of `dist`.\n\n## Tags\n\nannulus, eannulus\n-/\n\nopen Set Metric ENNReal\n\nvariable {X : Type*} [PseudoMetricSpace X]\n\nnamespace Set\n\nnamespace Annulus\n\ndef oo (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d) := {y | dist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d) := {y | dist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d) := {y | dist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d) := {y | dist x y \u2208 Ici r}\n\nlemma oo_eq {x : X} {r R : \u211d} : oo x r R = ball x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oo, dist_comm, and_comm]\n\nlemma oc_eq {x : X} {r R : \u211d} : oc x r R = closedBall x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oc, dist_comm, and_comm]\n\nlemma co_eq {x : X} {r R : \u211d} : co x r R = ball x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [co, dist_comm, and_comm]\n\nlemma cc_eq {x : X} {r R : \u211d} : cc x r R = closedBall x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [cc, dist_comm, and_comm]\n\nlemma oi_eq {x : X} {r : \u211d} : oi x r = (closedBall x r)\u1d9c := by\n  ext; simp [oi, dist_comm]\n\nlemma ci_eq {x : X} {r : \u211d} : ci x r = (ball x r)\u1d9c := by\n  ext; simp [ci, dist_comm]\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : co x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma co_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : co x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\nlemma cc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : cc x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma cc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : cc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\n@[simp]\nlemma oc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    oc x r r' \u222a oo x r' R = oo x r R := by\n  ext; simp_rw [oc, oo, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioo_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    oc x r r' \u222a oc x r' R = oc x r R := by\n  ext; simp_rw [oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_co {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a co x r' R = oo x r R := by\n  ext; simp_rw [oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ico_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a cc x r' R = oc x r R := by\n  ext; simp_rw [oo, cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Icc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    cc x r r' \u222a oo x r' R = co x r R := by\n  ext; simp_rw [cc, oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioo_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    cc x r r' \u222a oc x r' R = cc x r R := by\n  ext; simp_rw [cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_co {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a co x r' R = co x r R := by\n  ext; simp_rw [co, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ico_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a cc x r' R = cc x r R := by\n  ext; simp_rw [co, cc, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Icc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : oc x r R \u222a oi x R = oi x r := by\n  ext; simp_rw [oc, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioi_eq_Ioi h]\n\n@[simp]\nlemma oo_union_ci {x : X} {r R : \u211d} (h : r < R) :\n    oo x r R \u222a ci x R = oi x r := by\n  ext; simp_rw [oo, ci, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ici_eq_Ioi h]\n\n@[simp]\nlemma cc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : cc x r R \u222a oi x R = ci x r := by\n  ext; simp_rw [cc, oi, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioi_eq_Ici h]\n\n@[simp]\nlemma co_union_ci {x : X} {r R : \u211d} (h : r \u2264 R) : co x r R \u222a ci x R = ci x r := by\n  ext; simp_rw [co, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ici_eq_Ici h]\n\n\nvariable [MeasurableSpace X] [OpensMeasurableSpace X]\n\n@[measurability]\nlemma measurableSet_oo {x : X} {r R : \u211d} : MeasurableSet (oo x r R) := by\n  rw [oo_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oc {x : X} {r R : \u211d} : MeasurableSet (oc x r R) := by\n rw [oc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_co {x : X} {r R : \u211d} : MeasurableSet (co x r R) := by\n  rw [co_eq]; measurability\n\n@[measurability]\nlemma measurableSet_cc {x : X} {r R : \u211d} : MeasurableSet (cc x r R) := by\n rw [cc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oi {x : X} {r : \u211d} : MeasurableSet (oi x r) := by\n  rw [oi_eq]; measurability\n\n@[measurability]\nlemma measurableSet_ci {x : X} {r : \u211d} : MeasurableSet (ci x r) := by\n  rw [ci_eq]; measurability\n\nend Annulus\n\nnamespace EAnnulus\n\ndef oo (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ici r}\n\n\nlemma oo_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oo x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oo x r R := by\n  simp_rw [oo, Annulus.oo, edist_dist, mem_Ioo, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma oc_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [oc, Annulus.oc, edist_dist, mem_Ioc, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  \u00b7 have R_le_r := (lt_of_lt_of_le (lt_of_not_ge hR) hr).le\n    rw [Annulus.oc_eq_empty R_le_r]\n    refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n    exact not_le_of_gt (lt_of_le_of_lt (ENNReal.ofReal_le_ofReal R_le_r) hy.1) hy.2\n\nlemma co_eq_annulus {x : X} {r R : \u211d} :\n    co x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.co x r R := by\n  simp_rw [co, Annulus.co, edist_dist, mem_Ico, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma cc_eq_annulus {x : X} {r R : \u211d} (h : r > 0 \u2228 R \u2265 0) :\n    cc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.cc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [cc, Annulus.cc, edist_dist, mem_Icc, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  have r0 := h.resolve_right hR\n  have R_lt_r := (lt_of_not_ge hR).trans r0\n  rw [Annulus.cc_eq_empty R_lt_r]\n  refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n  exact not_le_of_gt ((ENNReal.ofReal_lt_ofReal_iff r0).mpr R_lt_r) (hy.1.trans hy.2)\n\nlemma oi_eq_annulus {x : X} {r : \u211d} (hr : r \u2265 0) : oi x (ENNReal.ofReal r) = Annulus.oi x r := by\n  simp_rw [oi, Annulus.oi, edist_dist, mem_Ioi, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr]\n\n", "theoremStatement": "lemma ci_eq_annulus {x : X} {r : \u211d} : ci x (ENNReal.ofReal r) = Annulus.ci x r ", "theoremName": "Set.EAnnulus.ci_eq_annulus", "fileCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "theoremCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "file": "carleson/Carleson/ToMathlib/Annulus.lean", "module": "Carleson.ToMathlib.Annulus", "jsonFile": "Carleson.ToMathlib.Annulus.jsonl", "positionMetadata": {"lineInFile": 291, "tokenPositionInFile": 11193, "theoremPositionInFile": 69}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 47}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp_rw [ci, Annulus.ci, edist_dist, mem_Ici, ENNReal.ofReal_le_ofReal_iff dist_nonneg]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 95}}
{"srcContext": "import Carleson.Discrete.Defs\nimport Mathlib.Combinatorics.Enumerative.DoubleCounting\nimport Carleson.Antichain.AntichainOperator\nimport Carleson.Discrete.SumEstimates\n\nopen MeasureTheory Measure NNReal Metric Complex Set\nopen scoped ENNReal\nopen Classical -- We use quite some `Finset.filter`\nnoncomputable section\n\nopen scoped ShortVariables\nvariable {X : Type*} {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102} {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X}\n  [MetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] [TileStructure Q D \u03ba S o]\n\nvariable {k n j l : \u2115} {p p' u u' : \ud835\udd13 X} {x : X}\n\n/-! ## Section 5.5 and Lemma 5.1.3 -/\n\n/-- The set \ud835\udd13_{G\\G'} in the blueprint -/\ndef \ud835\udd13pos : Set (\ud835\udd13 X) := { p : \ud835\udd13 X | 0 < volume (\ud835\udcd8 p \u2229 G \u2229 G'\u1d9c) }\n\nlemma exists_mem_aux\ud835\udcd2 {i : Grid X} (hi : 0 < volume (G \u2229 i)) : \u2203 k, i \u2208 aux\ud835\udcd2 (k + 1) := by\n  have vlt : volume (i : Set X) < \u22a4 := volume_coeGrid_lt_top\n  have one_le_quot : 1 \u2264 volume (i : Set X) / volume (G \u2229 i) := by\n    rw [ENNReal.le_div_iff_mul_le (Or.inl hi.ne') (Or.inr vlt.ne), one_mul]\n    exact measure_mono inter_subset_right\n  have quot_ne_top : volume (i : Set X) / volume (G \u2229 i) \u2260 \u22a4 := by\n    rw [Ne, ENNReal.div_eq_top, not_or, not_and_or, not_and_or]\n    exact \u27e8Or.inr hi.ne', Or.inl vlt.ne\u27e9\n  have ornz : 0 < (volume (i : Set X) / volume (G \u2229 i)).toReal :=\n    ENNReal.toReal_pos (zero_lt_one.trans_le one_le_quot).ne' quot_ne_top\n  let k : \u211d := Real.logb 2 (volume (i : Set X) / volume (G \u2229 i)).toReal\n  use \u230ak\u230b\u208a, i, le_rfl\n  nth_rw 1 [\u2190 ENNReal.mul_lt_mul_left (show 2 ^ (\u230ak\u230b\u208a + 1) \u2260 0 by simp) (by simp), \u2190 mul_assoc,\n    \u2190 ENNReal.rpow_natCast, \u2190 ENNReal.rpow_intCast, \u2190 ENNReal.rpow_add _ _ (by simp) (by simp)]\n  rw [Int.cast_neg, Int.cast_natCast, add_neg_cancel, ENNReal.rpow_zero, one_mul,\n    \u2190 ENNReal.div_lt_iff (Or.inl hi.ne') (Or.inr vlt.ne), \u2190 ENNReal.ofReal_toReal quot_ne_top,\n    \u2190 @ENNReal.ofReal_toReal (2 ^ (\u230ak\u230b\u208a + 1)) (by simp), ENNReal.ofReal_lt_ofReal_iff (by simp),\n    ENNReal.toReal_pow, ENNReal.toReal_ofNat, \u2190 Real.rpow_natCast,\n    \u2190 Real.logb_lt_iff_lt_rpow one_lt_two ornz]\n  exact Nat.lt_succ_floor k\n\nlemma exists_k_of_mem_\ud835\udd13pos (h : p \u2208 \ud835\udd13pos (X := X)) : \u2203 k, p \u2208 TilesAt k := by\n  let C : Set \u2115 := {k | \ud835\udcd8 p \u2208 aux\ud835\udcd2 k}\n  have Cn : C.Nonempty := by\n    rw [\ud835\udd13pos, mem_setOf] at h\n    have vpos : 0 < volume (G \u2229 \ud835\udcd8 p) := by\n      rw [inter_comm]; exact h.trans_le (measure_mono inter_subset_left)\n    obtain \u27e8k, hk\u27e9 := exists_mem_aux\ud835\udcd2 vpos; exact \u27e8_, hk\u27e9\n  let s : \u2115 := WellFounded.min wellFounded_lt _ Cn\n  have s_mem : s \u2208 C := WellFounded.min_mem ..\n  have s_min : \u2200 t \u2208 C, s \u2264 t := fun t mt \u21a6 WellFounded.min_le _ mt _\n  have s_pos : 0 < s := by\n    by_contra! h; rw [nonpos_iff_eq_zero] at h\n    simp_rw [h, C, aux\ud835\udcd2, mem_setOf] at s_mem; apply absurd s_mem; push_neg; intro _ _\n    rw [Int.neg_ofNat_zero, zpow_zero, one_mul]; exact measure_mono inter_subset_right\n  use s - 1; rw [TilesAt, mem_preimage, \ud835\udcd2, mem_diff, Nat.sub_add_cancel s_pos]\n  have : \u2200 t < s, t \u2209 C := fun t mt \u21a6 by contrapose! mt; exact s_min t mt\n  exact \u27e8s_mem, this (s - 1) (Nat.sub_one_lt_of_lt s_pos)\u27e9\n\nlemma dens'_le_of_mem_\ud835\udd13pos (h : p \u2208 \ud835\udd13pos (X := X)) : dens' k {p} \u2264 2 ^ (-k : \u2124) := by\n  simp_rw [dens', mem_singleton_iff, iSup_iSup_eq_left, iSup_le_iff]; intro l hl p' mp' sl\n  have vpos : 0 < volume (\ud835\udcd8 p' : Set X) := by\n    refine lt_of_lt_of_le ?_ (measure_mono sl.1.1)\n    rw [\ud835\udd13pos, mem_setOf, inter_assoc] at h; exact h.trans_le (measure_mono inter_subset_left)\n  rw [ENNReal.div_le_iff vpos.ne' volume_coeGrid_lt_top.ne]\n  calc\n    _ \u2264 volume (E\u2082 l p') := by\n      nth_rw 2 [\u2190 one_mul (volume _)]; apply mul_le_mul_right'\n      rw [show 1 = (l : \u211d\u22650\u221e) ^ (0 : \u2124) by simp]; apply ENNReal.zpow_le_of_le\n      \u00b7 rw [ENNReal.one_le_coe_iff]; exact one_le_two.trans hl\n      \u00b7 linarith [four_le_a X]\n    _ \u2264 _ := by\n      have E : E\u2082 l p' \u2286 \ud835\udcd8 p' \u2229 G := inter_subset_left\n      rw [TilesAt, mem_preimage, \ud835\udcd2, mem_diff] at mp'; replace mp' := mp'.2\n      rw [aux\ud835\udcd2, mem_setOf] at mp'; push_neg at mp'; specialize mp' (\ud835\udcd8 p') le_rfl\n      rw [inter_comm] at E; exact (measure_mono E).trans mp'\n\nlemma exists_E\u2082_volume_pos_of_mem_\ud835\udd13pos (h : p \u2208 \ud835\udd13pos (X := X)) : \u2203 r : \u2115, 0 < volume (E\u2082 r p) := by\n  apply exists_measure_pos_of_not_measure_iUnion_null\n  change volume (\u22c3 n : \u2115, \ud835\udcd8 p \u2229 G \u2229 Q \u207b\u00b9' ball_(p) (\ud835\udcac p) n) \u2260 0\n  rw [\u2190 inter_iUnion]\n  suffices \u22c3 i : \u2115, Q \u207b\u00b9' ball_(p) (\ud835\udcac p) i = univ by\n    rw [this, inter_univ, \u2190 pos_iff_ne_zero]\n    rw [\ud835\udd13pos, mem_setOf] at h; exact h.trans_le (measure_mono inter_subset_left)\n  simp_rw [iUnion_eq_univ_iff, mem_preimage, mem_ball]\n  exact fun x \u21a6 exists_nat_gt (dist_(p) (Q x) (\ud835\udcac p))\n\nlemma dens'_pos_of_mem_\ud835\udd13pos (h : p \u2208 \ud835\udd13pos (X := X)) (hp : p \u2208 TilesAt k) : 0 < dens' k {p} := by\n  simp_rw [dens', mem_singleton_iff, iSup_iSup_eq_left, lt_iSup_iff]\n  obtain \u27e8l, hl\u27e9 := exists_E\u2082_volume_pos_of_mem_\ud835\udd13pos h\n  use max 2 l, le_max_left .., p, hp, le_rfl\n  simp_rw [ENNReal.div_pos_iff, ne_eq, mul_eq_zero, not_or, \u2190 ne_eq, \u2190 pos_iff_ne_zero]\n  refine \u27e8\u27e8ENNReal.zpow_pos (by simp) (by simp) _, ?_\u27e9, volume_coeGrid_lt_top.ne\u27e9\n  refine hl.trans_le <| measure_mono <| inter_subset_inter_right _ <| preimage_mono ?_\n  change ball_(p) (\ud835\udcac p) _ \u2286 ball_(p) (\ud835\udcac p) _\n  exact ball_subset_ball (by simp)\n\nlemma exists_k_n_of_mem_\ud835\udd13pos (h : p \u2208 \ud835\udd13pos (X := X)) : \u2203 k n, p \u2208 \u212d k n \u2227 k \u2264 n := by\n  obtain \u27e8k, mp\u27e9 := exists_k_of_mem_\ud835\udd13pos h; use k\n  have dens'_pos : 0 < dens' k {p} := dens'_pos_of_mem_\ud835\udd13pos h mp\n  have dens'_le : dens' k {p} \u2264 2 ^ (-k : \u2124) := dens'_le_of_mem_\ud835\udd13pos h\n  have dens'_lt_top : dens' k {p} < \u22a4 :=\n    dens'_le.trans_lt (ENNReal.zpow_lt_top (by simp) (by simp) _)\n  have dens'_toReal_pos : 0 < (dens' k {p}).toReal :=\n    ENNReal.toReal_pos dens'_pos.ne' dens'_lt_top.ne\n  -- 2 ^ (4 * a - n) < dens' k {p} \u2264 2 ^ (4 * a - n + 1)\n  -- 4 * a - n < log_2 dens' k {p} \u2264 4 * a - n + 1\n  -- -n < log_2 dens' k {p} - 4 * a \u2264 -n + 1\n  -- n - 1 \u2264 4 * a - log_2 dens' k {p} < n\n  -- n \u2264 4 * a - log_2 dens' k {p} + 1 < n + 1\n  -- n = 4 * a + \u230a-log_2 dens' k {p}\u230b + 1\n  let v : \u211d := -Real.logb 2 (dens' k {p}).toReal\n  have klv : k \u2264 v := by\n    rw [le_neg, Real.logb_le_iff_le_rpow one_lt_two dens'_toReal_pos,\n      show (2 : \u211d) = (2 : \u211d\u22650\u221e).toReal by rfl, ENNReal.toReal_rpow,\n      ENNReal.toReal_le_toReal dens'_lt_top.ne (by simp)]\n    exact_mod_cast dens'_le\n  have klq : k \u2264 \u230av\u230b\u208a := Nat.le_floor klv\n  let n : \u2115 := 4 * a + \u230av\u230b\u208a + 1; use n; refine \u27e8\u27e8mp, ?_\u27e9, by omega\u27e9\n  rw [show 4 * (a : \u2124) - (4 * a + \u230av\u230b\u208a + 1 : \u2115) = (-\u230av\u230b\u208a - 1 : \u2124) by omega, sub_add_cancel, mem_Ioc,\n    \u2190 ENNReal.ofReal_toReal dens'_lt_top.ne, \u2190 ENNReal.rpow_intCast, \u2190 ENNReal.rpow_intCast,\n    show (2 : \u211d\u22650\u221e) = ENNReal.ofReal (2 : \u211d) by norm_cast,\n    ENNReal.ofReal_rpow_of_pos zero_lt_two, ENNReal.ofReal_rpow_of_pos zero_lt_two,\n    ENNReal.ofReal_lt_ofReal_iff dens'_toReal_pos, ENNReal.ofReal_le_ofReal_iff (by positivity),\n    \u2190 Real.logb_le_iff_le_rpow one_lt_two dens'_toReal_pos,\n    \u2190 Real.lt_logb_iff_rpow_lt one_lt_two dens'_toReal_pos,\n    Int.cast_sub, Int.cast_neg, Int.cast_natCast, Int.cast_one, neg_sub_left, neg_lt, le_neg]\n  constructor\n  \u00b7 rw [add_comm]; exact_mod_cast Nat.lt_succ_floor _\n  \u00b7 exact Nat.floor_le ((Nat.cast_nonneg' k).trans klv)\n\nprivate lemma two_mul_n_add_six_lt : 2 * n + 6 < 2 ^ (n + 3) := by\n  induction n with\n  | zero => norm_num\n  | succ n ih =>\n    calc\n      _ = 2 * n + 6 + 2 := by ring\n      _ < 2 ^ (n + 3) + 2 := by gcongr\n      _ < 2 ^ (n + 3) + 2 ^ (n + 3) := by omega\n      _ = _ := by ring\n\nlemma exists_j_of_mem_\ud835\udd13pos_\u212d (h : p \u2208 \ud835\udd13pos (X := X)) (mp : p \u2208 \u212d k n) (hkn : k \u2264 n) :\n    p \u2208 \ud835\udd0f\u2080 k n \u2228 \u2203 j \u2264 2 * n + 3, p \u2208 \u212d\u2081 k n j := by\n  rw [\ud835\udd13pos, mem_setOf, inter_comm _ G'\u1d9c, \u2190 inter_assoc] at h\n  replace h : 0 < volume (G'\u1d9c \u2229 (\ud835\udcd8 p : Set X)) := h.trans_le (measure_mono inter_subset_left)\n  rw [inter_comm, G', compl_union, compl_union, inter_comm G\u2081\u1d9c, \u2190 inter_assoc, \u2190 inter_assoc] at h\n  replace h : 0 < volume ((\ud835\udcd8 p : Set X) \u2229 G\u2082\u1d9c) :=\n    h.trans_le (measure_mono (inter_subset_left.trans inter_subset_left))\n  obtain \u27e8x, mx, nx\u27e9 := nonempty_of_measure_ne_zero h.ne'\n  simp_rw [G\u2082, mem_compl_iff, mem_iUnion] at nx; push_neg at nx; specialize nx n k hkn\n  let B : \u2115 := Finset.card { q | q \u2208 \ud835\udd05 k n p }\n  have Blt : B < 2 ^ (2 * n + 4) := by\n    calc\n      _ \u2264 Finset.card { m | m \u2208 \ud835\udd10 k n \u2227 x \u2208 \ud835\udcd8 m } :=\n        Finset.card_le_card (Finset.monotone_filter_right _ (Pi.le_def.mpr fun m \u27e8m\u2081, m\u2082\u27e9 \u21a6\n          \u27e8m\u2081, m\u2082.1.1 mx\u27e9))\n      _ = stackSize (\ud835\udd10 k n) x := by\n        simp_rw [stackSize, indicator_apply, Pi.one_apply, Finset.sum_boole, Nat.cast_id,\n          Finset.filter_filter]; rfl\n      _ \u2264 (2 * n + 6) * 2 ^ (n + 1) := by rwa [setA, mem_setOf, not_lt] at nx\n      _ < _ := by\n        rw [show 2 * n + 4 = (n + 3) + (n + 1) by omega, pow_add _ (n + 3)]\n        exact mul_lt_mul_of_pos_right two_mul_n_add_six_lt (by positivity)\n  rcases B.eq_zero_or_pos with Bz | Bpos\n  \u00b7 simp_rw [B, filter_mem_univ_eq_toFinset, Finset.card_eq_zero, toFinset_eq_empty] at Bz\n    exact Or.inl \u27e8mp, Bz\u27e9\n  \u00b7 right; use Nat.log 2 B; rw [Nat.lt_pow_iff_log_lt one_lt_two Bpos.ne'] at Blt\n    refine \u27e8by omega, (?_ : _ \u2227 _ \u2264 B), (?_ : \u00ac(_ \u2227 _ \u2264 B))\u27e9\n    \u00b7 exact \u27e8mp, Nat.pow_log_le_self 2 Bpos.ne'\u27e9\n    \u00b7 rw [not_and, not_le]; exact fun _ \u21a6 Nat.lt_pow_succ_log_self one_lt_two _\n\nlemma exists_k_n_j_of_mem_\ud835\udd13pos (h : p \u2208 \ud835\udd13pos (X := X)) :\n    \u2203 k n, k \u2264 n \u2227 (p \u2208 \ud835\udd0f\u2080 k n \u2228 \u2203 j \u2264 2 * n + 3, p \u2208 \u212d\u2081 k n j) := by\n  obtain \u27e8k, n, mp, hkn\u27e9 := exists_k_n_of_mem_\ud835\udd13pos h\n  exact \u27e8k, n, hkn, exists_j_of_mem_\ud835\udd13pos_\u212d h mp hkn\u27e9\n\n/-- The union occurring in the statement of Lemma 5.5.1 containing \ud835\udd0f\u2080 -/\ndef \u211c\u2080 : Set (\ud835\udd13 X) := \ud835\udd13pos \u2229 \u22c3 (n : \u2115) (k \u2264 n), \ud835\udd0f\u2080 k n\n\n/-- The union occurring in the statement of Lemma 5.5.1 containing \ud835\udd0f\u2081 -/\ndef \u211c\u2081 : Set (\ud835\udd13 X) := \ud835\udd13pos \u2229 \u22c3 (n : \u2115) (k \u2264 n) (j \u2264 2 * n + 3) (l \u2264 Z * (n + 1)), \ud835\udd0f\u2081 k n j l\n\n/-- The union occurring in the statement of Lemma 5.5.1 containing \ud835\udd0f\u2082 -/\ndef \u211c\u2082 : Set (\ud835\udd13 X) := \ud835\udd13pos \u2229 \u22c3 (n : \u2115) (k \u2264 n) (j \u2264 2 * n + 3), \ud835\udd0f\u2082 k n j\n\n/-- The union occurring in the statement of Lemma 5.5.1 containing \ud835\udd0f\u2083 -/\ndef \u211c\u2083 : Set (\ud835\udd13 X) := \ud835\udd13pos \u2229 \u22c3 (n : \u2115) (k \u2264 n) (j \u2264 2 * n + 3) (l \u2264 Z * (n + 1)), \ud835\udd0f\u2083 k n j l\n\n/-- Lemma allowing to peel `\u22c3 (n : \u2115) (k \u2264 n)` from unions in the proof of Lemma 5.5.1. -/\nlemma mem_iUnion_iff_mem_of_mem_\u212d {f : \u2115 \u2192 \u2115 \u2192 Set (\ud835\udd13 X)} (hp : p \u2208 \u212d k n \u2227 k \u2264 n)\n    (hf : \u2200 k n, f k n \u2286 \u212d k n) : p \u2208 \u22c3 (n : \u2115) (k \u2264 n), f k n \u2194 p \u2208 f k n := by\n  simp_rw [mem_iUnion]; constructor <;> intro h\n  \u00b7 obtain \u27e8n', k', _, mp\u27e9 := h\n    have e := pairwiseDisjoint_\u212d (X := X).elim (mem_univ (k, n)) (mem_univ (k', n'))\n      (not_disjoint_iff.mpr \u27e8p, hp.1, hf k' n' mp\u27e9)\n    rw [Prod.mk.inj_iff] at e\n    exact e.1 \u25b8 e.2 \u25b8 mp\n  \u00b7 use n, k, hp.2\n\n/-- Lemma allowing to peel `\u22c3 (j \u2264 2 * n + 3)` from unions in the proof of Lemma 5.5.1. -/\nlemma mem_iUnion_iff_mem_of_mem_\u212d\u2081 {f : \u2115 \u2192 Set (\ud835\udd13 X)} (hp : p \u2208 \u212d\u2081 k n j \u2227 j \u2264 2 * n + 3)\n    (hf : \u2200 j, f j \u2286 \u212d\u2081 k n j) : p \u2208 \u22c3 (j \u2264 2 * n + 3), f j \u2194 p \u2208 f j := by\n  simp_rw [mem_iUnion]; constructor <;> intro h\n  \u00b7 obtain \u27e8j', _, mp\u27e9 := h\n    have e := pairwiseDisjoint_\u212d\u2081 (X := X).elim (mem_univ j) (mem_univ j')\n      (not_disjoint_iff.mpr \u27e8p, hp.1, hf j' mp\u27e9)\n    exact e \u25b8 mp\n  \u00b7 use j, hp.2\n\nlemma nmem_\u212d\u2085_iff_mem_\ud835\udd0f\u2083 (hkn : k \u2264 n) (hj : j \u2264 2 * n + 3)\n    (h : p \u2208 \ud835\udd13pos) (mc2 : p \u2208 \u212d\u2082 k n j) (ml2 : p \u2209 \ud835\udd0f\u2082 k n j) :\n    p \u2209 \u212d\u2085 k n j \u2194 p \u2208 \u22c3 l, \u22c3 (_ : l \u2264 Z * (n + 1)), \ud835\udd0f\u2083 k n j l := by\n  have mc3 : p \u2208 \u212d\u2083 k n j := \u27e8mc2, ml2\u27e9\n  by_cases mc4 : p \u2209 \u212d\u2084 k n j\n  all_goals\n    have mc4' := mc4\n    simp_rw [\u212d\u2084, layersBelow, mem_diff, not_and, mc3, true_implies, not_not_mem] at mc4'\n  \u00b7 change p \u2208 \u22c3 (l \u2264 Z * (n + 1)), \ud835\udd0f\u2083 k n j l at mc4'\n    simp_rw [mc4', iff_true]; contrapose! mc4\n    exact \u212d\u2085_subset_\u212d\u2084 mc4\n  change p \u2209 \u22c3 (l \u2264 Z * (n + 1)), \ud835\udd0f\u2083 k n j l at mc4'\n  simp_rw [mc4', iff_false, \u212d\u2085]; rw [not_not_mem] at mc4 \u22a2; simp_rw [mem_diff, mc4, true_and]\n  have nG\u2083 : \u00ac(\ud835\udcd8 p : Set X) \u2286 G\u2083 := by\n    suffices \u00ac(\ud835\udcd8 p : Set X) \u2286 G' by contrapose! this; exact subset_union_of_subset_right this _\n    by_contra hv\n    rw [\ud835\udd13pos, mem_setOf, inter_comm _ G'\u1d9c, \u2190 inter_assoc, \u2190 diff_eq_compl_inter,\n      diff_eq_empty.mpr hv] at h\n    simp at h\n  contrapose! nG\u2083\n  exact le_iSup\u2082_of_le n k <| le_iSup\u2082_of_le hkn j <|\n    le_iSup\u2082_of_le hj p <| le_iSup_of_le nG\u2083 Subset.rfl\n\n\n/-- Lemma 5.5.1.\n\nWe will not use the lemma in this form, as to decompose the Carleson sum it is also crucial that\nthe union is disjoint. This is easier to formalize by decomposing into successive terms, taking\nadvantage of disjointess at each step, instead of doing everything in one go. Still, we keep this\nlemma as it corresponds to the blueprint, and the key steps of its proof will also be the key steps\nwhen doing the successive decompositions.\n -/\nlemma antichain_decomposition : \ud835\udd13pos (X := X) \u2229 \ud835\udd13\u2081\u1d9c = \u211c\u2080 \u222a \u211c\u2081 \u222a \u211c\u2082 \u222a \u211c\u2083 := by\n  unfold \u211c\u2080 \u211c\u2081 \u211c\u2082 \u211c\u2083 \ud835\udd13\u2081; simp_rw [\u2190 inter_union_distrib_left]; ext p\n  simp_rw [mem_inter_iff, and_congr_right_iff, mem_compl_iff, mem_union]; intro h\n  obtain \u27e8k, n, hkn, split\u27e9 := exists_k_n_j_of_mem_\ud835\udd13pos h\n  have pc : p \u2208 \u212d k n := by\n    rcases split with ml0 | \u27e8_, _, mc1\u27e9\n    \u00b7 exact \ud835\udd0f\u2080_subset_\u212d ml0\n    \u00b7 exact \u212d\u2081_subset_\u212d mc1\n  iterate 5 rw [mem_iUnion_iff_mem_of_mem_\u212d \u27e8pc, hkn\u27e9]\n  pick_goal 5; \u00b7 exact fun _ _ \u21a6 \ud835\udd0f\u2080_subset_\u212d\n  pick_goal 4; \u00b7 exact fun _ _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 \ud835\udd0f\u2081_subset_\u212d\n  pick_goal 3; \u00b7 exact fun _ _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 \ud835\udd0f\u2082_subset_\u212d\n  pick_goal 2; \u00b7 exact fun _ _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 \ud835\udd0f\u2083_subset_\u212d\n  pick_goal -1; \u00b7 exact fun _ _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 \u212d\u2085_subset_\u212d\n  by_cases ml0 : p \u2208 \ud835\udd0f\u2080 k n\n  \u00b7 simp_rw [ml0, true_or, iff_true, mem_iUnion\u2082]; push_neg; intros\n    exact fun a \u21a6 disjoint_left.mp \ud835\udd0f\u2080_disjoint_\u212d\u2081 ml0 (\u212d\u2085_subset_\u212d\u2081 a)\n  simp_rw [ml0, false_or] at split \u22a2\n  obtain \u27e8j, hj, mc1\u27e9 := split\n  iterate 4 rw [mem_iUnion_iff_mem_of_mem_\u212d\u2081 \u27e8mc1, hj\u27e9]\n  pick_goal 4; \u00b7 exact fun _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 \ud835\udd0f\u2081_subset_\u212d\u2081\n  pick_goal 3; \u00b7 exact fun _ \u21a6 \ud835\udd0f\u2082_subset_\u212d\u2081\n  pick_goal 2; \u00b7 exact fun _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 \ud835\udd0f\u2083_subset_\u212d\u2081\n  pick_goal -1; \u00b7 exact fun _ \u21a6 \u212d\u2085_subset_\u212d\u2081\n  by_cases mc2 : p \u2209 \u212d\u2082 k n j\n  all_goals\n    have mc2' := mc2\n    simp_rw [\u212d\u2082, layersAbove, mem_diff, not_and, mc1, true_implies, not_not_mem] at mc2'\n  \u00b7 change p \u2208 \u22c3 (l \u2264 Z * (n + 1)), \ud835\udd0f\u2081 k n j l at mc2'\n    simp_rw [mc2', true_or, iff_true]; contrapose! mc2\n    exact \u212d\u2085_subset_\u212d\u2084.trans \u212d\u2084_subset_\u212d\u2083 |>.trans \u212d\u2083_subset_\u212d\u2082 mc2\n  change p \u2209 \u22c3 (l \u2264 Z * (n + 1)), \ud835\udd0f\u2081 k n j l at mc2'; simp_rw [mc2', false_or]\n  rw [not_not_mem] at mc2; by_cases ml2 : p \u2208 \ud835\udd0f\u2082 k n j\n  \u00b7 simp_rw [ml2, true_or, iff_true]\n    exact fun a \u21a6 disjoint_left.mp \ud835\udd0f\u2082_disjoint_\u212d\u2083 ml2 (\u212d\u2085_subset_\u212d\u2084.trans \u212d\u2084_subset_\u212d\u2083 a)\n  simp_rw [ml2, false_or]\n  exact nmem_\u212d\u2085_iff_mem_\ud835\udd0f\u2083 hkn hj h mc2 ml2\n\n/-- The subset `\ud835\udd0f\u2080(k, n, l)` of `\ud835\udd0f\u2080(k, n)`, given in Lemma 5.5.3.\n  We use the name `\ud835\udd0f\u2080'` in Lean. -/\ndef \ud835\udd0f\u2080' (k n l : \u2115) : Set (\ud835\udd13 X) := (\ud835\udd0f\u2080 k n).minLayer l\n\n/-- Logarithmic inequality used in the proof of Lemma 5.5.2. -/\nlemma ceil_log2_le_floor_four_add_log2 {l : \u211d} (hl : 2 \u2264 l) :\n    \u2308Real.logb 2 ((l + 6 / 5) / 5\u207b\u00b9)\u2309\u208a \u2264 \u230a4 + Real.logb 2 l\u230b\u208a := by\n  have : 2 \u2264 Real.logb 2 (l + 6 / 5) + Real.logb 2 5 :=\n    calc\n      _ \u2265 Real.logb 2 (2 ^ (0 : \u211d)) + Real.logb 2 (2 ^ (2 : \u211d)) :=\n        add_le_add\n          (Real.logb_le_logb_of_le one_lt_two (by positivity) (by linarith))\n          (Real.logb_le_logb_of_le one_lt_two (by positivity) (by norm_num))\n      _ \u2265 _ := by simp_rw [Real.logb_rpow zero_lt_two one_lt_two.ne']; norm_num\n  rw [div_inv_eq_mul, Real.logb_mul (by positivity) (by positivity), Nat.le_floor_iff']\n  \u00b7 calc\n      _ \u2264 1 + Real.logb 2 (l + 6 / 5) + Real.logb 2 5 := by\n        rw [add_rotate]; exact (Nat.ceil_lt_add_one (zero_le_two.trans this)).le\n      _ \u2264 1 + Real.logb 2 (8 / 5 * l) + Real.logb 2 5 := by\n        gcongr\n        \u00b7 exact one_lt_two\n        \u00b7 linarith\n      _ = _ := by\n        rw [add_assoc, \u2190 Real.logb_mul (by positivity) (by positivity), \u2190 mul_rotate,\n          show (5 : \u211d) * (8 / 5) = 2 ^ 3 by norm_num,\n          Real.logb_mul (by positivity) (by positivity), \u2190 Real.rpow_natCast,\n          Real.logb_rpow zero_lt_two one_lt_two.ne', \u2190 add_assoc]\n        norm_num\n  \u00b7 exact (zero_lt_one.trans_le (Nat.one_le_ceil_iff.mpr (zero_lt_two.trans_le this))).ne'\n\n/-- The set `\ud835\udd12` in the proof of Lemma 5.5.2. -/\ndef \ud835\udd12 (p' : \ud835\udd13 X) (l : \u211d\u22650) : Finset (\ud835\udd13 X) :=\n  {p'' | \ud835\udcd8 p'' = \ud835\udcd8 p' \u2227 \u00acDisjoint (ball_(p') (\ud835\udcac p') l) (\u03a9 p'')}\n\nlemma card_\ud835\udd12 (p' : \ud835\udd13 X) {l : \u211d\u22650} (hl : 2 \u2264 l) : (\ud835\udd12 p' l).card \u2264 \u230a2 ^ (4 * a) * l ^ a\u230b\u208a := by\n  have djO : (\ud835\udd12 p' l).toSet.PairwiseDisjoint fun p'' \u21a6 ball_(p') (\ud835\udcac p'') 5\u207b\u00b9 :=\n    fun p\u2081 mp\u2081 p\u2082 mp\u2082 hn \u21a6 by\n      simp_rw [\ud835\udd12, Finset.coe_filter, mem_setOf, Finset.mem_univ, true_and] at mp\u2081 mp\u2082\n      change Disjoint (ball_{\ud835\udcd8 p'} (\ud835\udcac p\u2081) 5\u207b\u00b9) (ball_{\ud835\udcd8 p'} (\ud835\udcac p\u2082) 5\u207b\u00b9)\n      conv => enter [1]; rw [\u2190 mp\u2081.1]\n      conv => enter [2]; rw [\u2190 mp\u2082.1]\n      exact cball_disjoint hn (mp\u2081.1.trans mp\u2082.1.symm)\n  have tO : \u2200 p'' \u2208 \ud835\udd12 p' l,\n      ball_(p') (\ud835\udcac p'') 5\u207b\u00b9 \u2286 ball_(p') (\ud835\udcac p') (l + 6 / 5) := fun p'' mp'' \u21a6 by\n    apply ball_subset_ball'\n    simp_rw [\ud835\udd12, Finset.mem_filter, Finset.mem_univ, true_and] at mp''\n    obtain \u27e8x, mx\u2081, mx\u2082\u27e9 := not_disjoint_iff.mp mp''.2\n    replace mx\u2082 := _root_.subset_cball mx\u2082\n    rw [@mem_ball] at mx\u2081 mx\u2082\n    calc\n      _ \u2264 5\u207b\u00b9 + (dist_{\ud835\udcd8 p'} x (\ud835\udcac p'') + dist_{\ud835\udcd8 p'} x (\ud835\udcac p')) :=\n        add_le_add_left (dist_triangle_left ..) _\n      _ \u2264 5\u207b\u00b9 + (1 + l) := by gcongr; rw [\u2190 mp''.1]; exact mx\u2082.le\n      _ = _ := by rw [inv_eq_one_div, \u2190 add_assoc, add_comm _ l.toReal]; norm_num\n  have vO : CoveredByBalls (ball_(p') (\ud835\udcac p') (l + 6 / 5)) \u230a2 ^ (4 * a) * l ^ a\u230b\u208a 5\u207b\u00b9 := by\n    apply (ballsCoverBalls_iterate (show 0 < l.toReal + 6 / 5 by positivity)\n      (show 0 < 5\u207b\u00b9 by positivity) (\ud835\udcac p')).mono_nat\n    calc\n      _ \u2264 (defaultA a) ^ \u230a4 + Real.logb 2 l\u230b\u208a :=\n        pow_le_pow_right\u2080 Nat.one_le_two_pow (ceil_log2_le_floor_four_add_log2 hl)\n      _ \u2264 \u230a(defaultA a : \u211d) ^ (4 + Real.logb 2 l)\u230b\u208a := by\n        apply Nat.le_floor; rw [Nat.cast_npow, \u2190 Real.rpow_natCast]\n        refine Real.rpow_le_rpow_of_exponent_le (by exact_mod_cast Nat.one_le_two_pow)\n          (Nat.floor_le ?_)\n        calc\n          _ \u2265 4 + Real.logb 2 2 :=\n            add_le_add_left (Real.logb_le_logb_of_le one_lt_two zero_lt_two hl) _\n          _ \u2265 _ := by rw [Real.logb_self_eq_one one_lt_two]; norm_num\n      _ = _ := by\n        rw [Nat.cast_pow, Nat.cast_ofNat, \u2190 Real.rpow_natCast, \u2190 Real.rpow_mul zero_le_two,\n          mul_comm, add_mul, Real.rpow_add zero_lt_two, show (4 : \u211d) * a = (4 * a : \u2115) by simp,\n          Real.rpow_natCast, Real.rpow_mul zero_le_two, Real.rpow_natCast,\n          Real.rpow_logb zero_lt_two one_lt_two.ne']\n        congr 1; exact zero_lt_two.trans_le hl\n  obtain \u27e8(T : Finset (\u0398 X)), cT, uT\u27e9 := vO\n  refine (Finset.card_le_card_of_forall_subsingleton (fun p'' t \u21a6 \ud835\udcac p'' \u2208 ball_(p') t 5\u207b\u00b9)\n      (fun p'' mp'' \u21a6 ?_) (fun t _ o\u2081 mo\u2081 o\u2082 mo\u2082 \u21a6 ?_)).trans cT\n  \u00b7 have := (tO _ mp'').trans uT (mem_ball_self (by positivity))\n    rwa [mem_iUnion\u2082, bex_def] at this\n  \u00b7 simp_rw [mem_setOf_eq] at mo\u2081 mo\u2082; rw [@mem_ball_comm] at mo\u2081 mo\u2082\n    exact djO.elim mo\u2081.1 mo\u2082.1 (not_disjoint_iff.mpr \u27e8t, mo\u2081.2, mo\u2082.2\u27e9)\n\nsection\n\nvariable {p' : \ud835\udd13 X} {l : \u211d\u22650} (hl : 2 \u2264 l)\n  (qp' : 2 ^ (4 * a - n : \u2124) < l ^ (-a : \u2124) * volume (E\u2082 l p') / volume (\ud835\udcd8 p' : Set X))\ninclude hl qp'\n\nlemma lt_quotient_rearrange :\n    (2 ^ (4 * a) * l ^ a : \u211d\u22650) * 2 ^ (-n : \u2124) < volume (E\u2082 l p') / volume (\ud835\udcd8 p' : Set X) := by\n  rw [mul_div_assoc] at qp'; convert ENNReal.div_lt_of_lt_mul' qp' using 1\n  rw [ENNReal.div_eq_inv_mul,\n    \u2190 ENNReal.zpow_neg (by exact_mod_cast (zero_lt_two.trans_le hl).ne') ENNReal.coe_ne_top,\n    neg_neg, ENNReal.coe_mul, mul_rotate, mul_assoc, ENNReal.coe_pow, zpow_natCast]\n  congr 1\n  rw [ENNReal.coe_pow, ENNReal.coe_ofNat, \u2190 zpow_natCast,\n    \u2190 ENNReal.zpow_add two_ne_zero ENNReal.ofNat_ne_top]\n  congr 1; omega\n\nlemma l_upper_bound : l < 2 ^ n := by\n  have ql1 : volume (E\u2082 l p') / volume (\ud835\udcd8 p' : Set X) \u2264 1 := by\n    apply ENNReal.div_le_of_le_mul; rw [one_mul]; exact measure_mono (E\u2082_subset ..)\n  replace qp' := (lt_quotient_rearrange hl qp').trans_le ql1\n  rw [\u2190 ENNReal.mul_lt_mul_right (c := 2 ^ (n : \u2124)) (by simp) (by simp), one_mul, mul_assoc,\n    \u2190 ENNReal.zpow_add two_ne_zero ENNReal.ofNat_ne_top, neg_add_cancel, zpow_zero, mul_one,\n    show (2 ^ (n : \u2124) : \u211d\u22650\u221e) = (2 ^ (n : \u2124) : \u211d\u22650) by simp, ENNReal.coe_lt_coe,\n    zpow_natCast] at qp'\n  calc\n    _ \u2264 l ^ a := le_self_pow\u2080 (one_le_two.trans hl) (by linarith [four_le_a X])\n    _ \u2264 2 ^ (4 * a) * l ^ a := by\n      nth_rw 1 [\u2190 one_mul (l ^ a)]; gcongr; exact_mod_cast Nat.one_le_two_pow\n    _ < _ := qp'\n\nlemma exists_\ud835\udd12_with_le_quotient :\n    \u2203 b \u2208 \ud835\udd12 p' l, 2 ^ (-n : \u2124) < volume (E\u2081 b) / volume (\ud835\udcd8 b : Set X) := by\n  have cO : (\ud835\udd12 p' l).card \u2264 \u230a2 ^ (4 * a) * l ^ a\u230b\u208a := card_\ud835\udd12 _ hl\n  have ltq : (2 ^ (4 * a) * l ^ a : \u211d\u22650) * 2 ^ (-n : \u2124) <\n      \u2211 p'' \u2208 \ud835\udd12 p' l, volume (E\u2081 p'') / volume (\ud835\udcd8 p'' : Set X) :=\n    calc\n      _ < volume (E\u2082 l p') / volume (\ud835\udcd8 p' : Set X) := lt_quotient_rearrange hl qp'\n      _ \u2264 volume (\u22c3 p'' \u2208 \ud835\udd12 p' l, E\u2081 p'') / volume (\ud835\udcd8 p' : Set X) := by\n        gcongr; simp_rw [E\u2081, E\u2082, smul, toTileLike, TileLike.toSet]; intro x mx\n        have rsub := biUnion_\u03a9 (i := \ud835\udcd8 p'); rw [range_subset_iff] at rsub; specialize rsub x\n        simp_rw [mem_iUnion\u2082, mem_preimage, mem_singleton_iff, exists_prop] at rsub\n        obtain \u27e8(ps : \ud835\udd13 X), (ips : \ud835\udcd8 ps = \ud835\udcd8 p'), mps\u27e9 := rsub; rw [\u2190 mem_preimage] at mps\n        rw [mem_iUnion\u2082]; refine \u27e8ps, ?_, ?_\u27e9\n        \u00b7 simp_rw [\ud835\udd12, Finset.mem_filter, Finset.mem_univ, ips, true_and, not_disjoint_iff]\n          use Q x, mem_preimage.mp mx.2, mem_preimage.mp mps\n        \u00b7 exact \u27e8\u27e8ips.symm \u25b8 mx.1.1, mx.1.2\u27e9, mps\u27e9\n      _ \u2264 (\u2211 p'' \u2208 \ud835\udd12 p' l, volume (E\u2081 p'')) / volume (\ud835\udcd8 p' : Set X) :=\n        ENNReal.div_le_div_right (measure_biUnion_finset_le _ _) _\n      _ = \u2211 p'' \u2208 \ud835\udd12 p' l, volume (E\u2081 p'') / volume (\ud835\udcd8 p' : Set X) := by\n        simp_rw [ENNReal.div_eq_inv_mul, Finset.mul_sum]\n      _ = _ := by\n        refine Finset.sum_congr rfl fun p'' mp'' \u21a6 ?_\n        rw [\ud835\udd12, Finset.mem_filter] at mp''; rw [mp''.2.1]\n  by_contra! h\n  have : \u2211 p'' \u2208 \ud835\udd12 p' l, volume (E\u2081 p'') / volume (\ud835\udcd8 p'' : Set X) \u2264\n      (2 ^ (4 * a) * l ^ a : \u211d\u22650) * 2 ^ (-n : \u2124) :=\n    calc\n      _ \u2264 \u2211 _ \u2208 \ud835\udd12 p' l, (2 : \u211d\u22650\u221e) ^ (-n : \u2124) := by\n        refine Finset.sum_le_sum h\n      _ = (\ud835\udd12 p' l).card * (2 : \u211d\u22650\u221e) ^ (-n : \u2124) := by rw [Finset.sum_const, nsmul_eq_mul]\n      _ \u2264 _ := by\n        refine mul_le_mul_right' ?_ _\n        rw [show ((\ud835\udd12 p' l).card : \u211d\u22650\u221e) = ((\ud835\udd12 p' l).card : \u211d\u22650) by simp, ENNReal.coe_le_coe]\n        rw [\u2190 Nat.cast_le (\u03b1 := \u211d\u22650)] at cO\n        exact cO.trans (Nat.floor_le (by positivity))\n  exact (ltq.trans_le this).false\n\nend\n\n/-- Main part of Lemma 5.5.2. -/\nlemma iUnion_L0' : \u22c3 (l < n), \ud835\udd0f\u2080' (X := X) k n l = \ud835\udd0f\u2080 k n := by\n  refine iUnion_lt_minLayer_iff_bounded_series.mpr fun p \u21a6 ?_\n  suffices \u00ac\u2203 s : LTSeries (\ud835\udd0f\u2080 (X := X) k n), s.length = n by\n    rcases lt_or_le p.length n with c | c\n    \u00b7 exact c\n    \u00b7 exact absurd \u27e8p.take \u27e8n, by omega\u27e9, by rw [RelSeries.take_length]\u27e9 this\n  by_contra h; obtain \u27e8s, hs\u27e9 := h; let sl := s.last; have dsl := sl.2.1.2.1\n  simp_rw [dens', lt_iSup_iff, mem_singleton_iff, exists_prop, exists_eq_left] at dsl\n  obtain \u27e8l, hl, p', mp', sp', qp'\u27e9 := dsl\n  obtain \u27e8b, mb, qb\u27e9 := exists_\ud835\udd12_with_le_quotient hl qp'\n  have \ud835\udcd8p'b : \ud835\udcd8 p' = \ud835\udcd8 b := by rw [\ud835\udd12, Finset.mem_filter] at mb; exact mb.2.1.symm\n  replace qb := ENNReal.mul_lt_of_lt_div qb\n  have mba : b \u2208 (aux\ud835\udd10 k n).toFinset := by\n    simp_rw [mem_toFinset, aux\ud835\udd10, mem_setOf, qb, and_true]; rw [TilesAt, mem_preimage] at mp' \u22a2\n    exact \ud835\udcd8p'b \u25b8 mp'\n  obtain \u27e8m, lm, maxm\u27e9 := (aux\ud835\udd10 k n).toFinset.exists_le_maximal mba\n  replace maxm : m \u2208 \ud835\udd10 k n := by simpa only [mem_toFinset] using maxm\n  -- We will now show a contradiction. As a member of `\ud835\udd0f\u2080 k n` the _first_ element `s\u2080` of the\n  -- `LTSeries s` satisfies `\ud835\udd05 k n s\u2080 = \u2205`. But we will show that `m \u2208 \ud835\udd05 k n s\u2080`,\n  -- i.e. `smul 100 s\u2080 \u2264 smul 1 m`.\n  let s\u2080 := s.head; apply absurd s\u2080.2.2; rw [\u2190 ne_eq, \u2190 nonempty_iff_ne_empty]; use m, maxm\n  constructor\n  \u00b7 have l1 : \ud835\udcd8 s\u2080.1 \u2264 \ud835\udcd8 sl.1 := s.head_le_last.1\n    have l2 : \ud835\udcd8 sl.1 \u2264 \ud835\udcd8 b := \ud835\udcd8p'b \u25b8 sp'.1\n    have l3 : \ud835\udcd8 b \u2264 \ud835\udcd8 m := lm.1\n    exact (l1.trans l2).trans l3\n  change ball_(m) (\ud835\udcac m) 1 \u2286 ball_(s\u2080.1) (\ud835\udcac s\u2080.1) 100; intro (\u03b8 : \u0398 X) m\u03b8; rw [@mem_ball] at m\u03b8 \u22a2\n  have aux : dist_(sl.1) (\ud835\udcac sl.1) \u03b8 < 2 * l + 3 :=\n    calc\n      _ \u2264 dist_(sl.1) (\ud835\udcac sl.1) (\ud835\udcac p') + dist_(sl.1) (\ud835\udcac p') \u03b8 := dist_triangle ..\n      _ < l + dist_(sl.1) (\ud835\udcac p') \u03b8 := by\n        apply add_lt_add_right\n        have : \ud835\udcac p' \u2208 ball_(p') (\ud835\udcac p') l := by convert mem_ball_self (zero_lt_two.trans_le hl)\n        exact mem_ball'.mp (sp'.2 this)\n      _ \u2264 l + dist_(p') (\ud835\udcac p') \u03b8 := add_le_add_left (Grid.dist_mono sp'.1) _\n      _ \u2264 l + dist_(p') (\ud835\udcac p') (\ud835\udcac b) + dist_(p') (\ud835\udcac b) \u03b8 := by\n        rw [add_assoc]; apply add_le_add_left; exact dist_triangle ..\n      _ \u2264 l + (l + 1) + dist_(b) (\ud835\udcac b) \u03b8 := by\n        gcongr\n        \u00b7 rw [\ud835\udd12, Finset.mem_filter] at mb\n          obtain \u27e8(x : \u0398 X), x\u2081, x\u2082\u27e9 := not_disjoint_iff.mp mb.2.2\n          replace x\u2082 := _root_.subset_cball x\u2082\n          rw [@mem_ball] at x\u2081 x\u2082\n          calc\n            _ \u2264 dist_(p') x (\ud835\udcac p') + dist_(p') x (\ud835\udcac b) := dist_triangle_left ..\n            _ \u2264 _ := by\n              apply add_le_add x\u2081.le\n              change dist_{\ud835\udcd8 p'} x (\ud835\udcac b) \u2264 1; rw [\ud835\udcd8p'b]; exact x\u2082.le\n        \u00b7 change dist_{\ud835\udcd8 p'} (\ud835\udcac b) \u03b8 \u2264 dist_{\ud835\udcd8 b} (\ud835\udcac b) \u03b8; rw [\ud835\udcd8p'b]\n      _ \u2264 l + (l + 1) + (dist_(b) (\ud835\udcac m) (\ud835\udcac b) + dist_(b) (\ud835\udcac m) \u03b8) :=\n        add_le_add_left (dist_triangle_left ..) _\n      _ \u2264 l + (l + 1) + (1 + dist_(m) (\ud835\udcac m) \u03b8) := by\n        gcongr\n        \u00b7 exact (dist_\ud835\udcac_lt_one_of_le lm).le\n        \u00b7 exact Grid.dist_mono lm.1\n      _ < l + (l + 1) + (1 + 1) := by gcongr; exact mem_ball'.mp m\u03b8\n      _ = _ := by ring\n  calc\n    _ \u2264 dist_(s\u2080.1) (\ud835\udcac sl.1) \u03b8 + dist_(s\u2080.1) (\ud835\udcac sl.1) (\ud835\udcac s\u2080.1) := dist_triangle_left ..\n    _ < 1 + dist_(s\u2080.1) (\ud835\udcac sl.1) \u03b8 := by\n      rw [add_comm]; exact add_lt_add_right (dist_\ud835\udcac_lt_one_of_le s.head_le_last) _\n    _ \u2264 1 + C2_1_2 a ^ n * dist_(sl.1) (\ud835\udcac sl.1) \u03b8 := add_le_add_left (dist_LTSeries hs) _\n    _ < 1 + C2_1_2 a ^ n * (2 * l + 3) := by gcongr; rw [C2_1_2]; positivity\n    _ \u2264 1 + (1 / 512) ^ n * (2 * 2 ^ n + 3) := by\n      gcongr\n      \u00b7 rw [C2_1_2]; positivity\n      \u00b7 exact C2_1_2_le_inv_512 X\n      \u00b7 exact_mod_cast (l_upper_bound hl qp').le\n    _ = 1 + 2 * (2 / 512) ^ n + (1 / 512) ^ n * 3 := by\n      simp [div_pow]; ring\n    _ \u2264 1 + 2 * (2 / 512) ^ 0 + (1 / 512) ^ 0 * 3 := by\n      gcongr 1 + 2 * ?_ + ?_ * 3 <;>\n        exact pow_le_pow_of_le_one (by norm_num) (by norm_num) (by omega)\n    _ < _ := by norm_num\n\n/-- Part of Lemma 5.5.2 -/\nlemma pairwiseDisjoint_L0' : univ.PairwiseDisjoint (\ud835\udd0f\u2080' (X := X) k n) := pairwiseDisjoint_minLayer\n\n/-- Part of Lemma 5.5.2 -/\nlemma antichain_L0' : IsAntichain (\u00b7 \u2264 \u00b7) (\ud835\udd0f\u2080' (X := X) k n l) := isAntichain_minLayer\n\nsection L2Antichain\n\n/-- Type synonym of `\u212d\u2081` to apply the `Preorder` of the proof of Lemma 5.5.3 on. -/\nprivate def \u212d\u2081' (k n j : \u2115) : Type _ := \u212d\u2081 (X := X) k n j\n\nprivate instance : Fintype (\u212d\u2081' (X := X) k n j) := inferInstanceAs (Fintype (\u212d\u2081 k n j))\n\nprivate instance : Preorder (\u212d\u2081' (X := X) k n j) where\n  le x y := smul 200 x.1 \u2264 smul 200 y.1\n  le_refl := by simp\n  le_trans _ _ _ xy yz := by\n    change smul _ _ \u2264 smul _ _ at xy yz \u22a2\n    exact xy.trans yz\n\n/-- Lemma 5.5.3 -/\nlemma antichain_L2 : IsAntichain (\u00b7 \u2264 \u00b7) (\ud835\udd0f\u2082 (X := X) k n j) := by\n  by_contra h; rw [isAntichain_iff_forall_not_lt] at h; push_neg at h\n  obtain \u27e8p', mp', p, mp, l\u27e9 := h\n  have p200 : smul 2 p' \u2264 smul 200 p := by\n    calc\n      _ \u2264 smul (11 / 10 + C2_1_2 a * 200) p' := by\n        apply smul_mono_left\n        calc\n          _ \u2264 11 / 10 + 1 / 512 * (200 : \u211d) := by gcongr; exact C2_1_2_le_inv_512 X\n          _ \u2264 _ := by norm_num\n      _ \u2264 _ := by\n        refine smul_C2_1_2 _ (by norm_num) ?_ (wiggle_order_11_10 l.le (C5_3_3_le (X := X)))\n        exact (\ud835\udcd8_strictMono l).ne\n  have cp : p \u2208 \u212d\u2081 k n j := (\ud835\udd0f\u2082_subset_\u212d\u2082.trans \u212d\u2082_subset_\u212d\u2081) mp\n  let C : Finset (LTSeries (\u212d\u2081' k n j)) := { s | s.head = \u27e8p, cp\u27e9 }\n  have Cn : C.Nonempty := by\n    use RelSeries.singleton _ \u27e8p, cp\u27e9\n    simp_rw [C, Finset.mem_filter, Finset.mem_univ, true_and]; rfl\n  obtain \u27e8z, mz, maxz\u27e9 := C.exists_max_image (\u00b7.length) Cn\n  simp_rw [C, Finset.mem_filter, Finset.mem_univ, true_and] at mz\n  by_cases mu : z.last.1 \u2208 \ud835\udd18\u2081 k n j\n  \u00b7 have px : z.head \u2264 z.last := z.monotone (Fin.zero_le _)\n    rw [mz] at px\n    apply absurd mp'; rw [\ud835\udd0f\u2082, mem_setOf, not_and_or, not_not]; right; use z.last.1, mu\n    have : \ud835\udcd8 p' < \ud835\udcd8 p := \ud835\udcd8_strictMono l\n    exact \u27e8(this.trans_le px.1).ne, (p200.trans px).trans (smul_mono_left (by norm_num))\u27e9\n  \u00b7 simp_rw [\ud835\udd18\u2081, mem_setOf, not_and, z.last.2, true_implies, not_forall, exists_prop] at mu\n    obtain \u27e8q, mq, lq, ndjq\u27e9 := mu; rw [not_disjoint_iff] at ndjq; obtain \u27e8\u03d1, m\u03d1\u2081, m\u03d1\u2082\u27e9 := ndjq\n    have cpos : 0 < C2_1_2 a := by rw [C2_1_2]; positivity\n    have s200 : smul 200 z.last.1 \u2264 smul 200 q := by\n      refine \u27e8lq.le, (?_ : ball_(q) (\ud835\udcac q) 200 \u2286 ball_(z.last.1) (\ud835\udcac z.last.1) 200)\u27e9\n      intro (r : \u0398 X) mr\n      rw [@mem_ball] at mr m\u03d1\u2081 m\u03d1\u2082 \u22a2\n      calc\n        _ \u2264 dist_(z.last.1) r (\ud835\udcac q) + dist_(z.last.1) (\ud835\udcac q) \u03d1 + dist_(z.last.1) \u03d1 (\ud835\udcac z.last.1) :=\n          dist_triangle4 ..\n        _ \u2264 C2_1_2 a * dist_(q) r (\ud835\udcac q) + C2_1_2 a * dist_(q) (\ud835\udcac q) \u03d1 + 100 := by\n          gcongr <;> exact Grid.dist_strictMono lq\n        _ \u2264 C2_1_2 a * (200 + 100) + 100 := by rw [mul_add]; gcongr; rw [dist_comm]; exact m\u03d1\u2082.le\n        _ \u2264 (1 / 512) * 300 + 100 := by\n          rw [show (200 : \u211d) + 100 = 300 by norm_num]; gcongr\n          exact C2_1_2_le_inv_512 X\n        _ < _ := by norm_num\n    have : z.last < \u27e8q, mq\u27e9 := by\n      refine \u27e8s200, (?_ : \u00ac(smul 200 q \u2264 smul 200 z.last.1))\u27e9\n      rw [TileLike.le_def, not_and_or]; exact Or.inl (not_le_of_gt lq)\n    apply absurd maxz; push_neg; use z.snoc \u27e8q, mq\u27e9 this, by simp [C, mz], by simp\n\nend L2Antichain\n\n/-- Part of Lemma 5.5.4 -/\nlemma antichain_L1 : IsAntichain (\u00b7 \u2264 \u00b7) (\ud835\udd0f\u2081 (X := X) k n j l) := isAntichain_minLayer\n\n/-- Part of Lemma 5.5.4 -/\nlemma antichain_L3 : IsAntichain (\u00b7 \u2264 \u00b7) (\ud835\udd0f\u2083 (X := X) k n j l) := isAntichain_maxLayer\n\n/- Our goal is now to estimate `\u222b\u207b x in G \\ G', \u2016carlesonSum \ud835\udd13\u2081\u1d9c f x\u2016\u208a` by decomposing `\ud835\udd13\u2081\u1d9c` as a\nunion of disjoint antichains. For this, we proceed step by step, isolating some antichains and\nsome sets that remain to be decomposed. After 4 steps, we will get a sum of integrals corresponding\nto the (disjoint) decomposition in Lemma 5.5.1.\n-/\n\n/-- The Carleson sum over `\ud835\udd13\u2081\u1d9c` and `\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c` coincide at ae every point of `G \\ G'`. -/\nlemma carlesonSum_\ud835\udd13\u2081_compl_eq_\ud835\udd13pos_inter (f : X \u2192 \u2102) :\n    \u2200\u1d50 x, x \u2208 G \\ G' \u2192 carlesonSum \ud835\udd13\u2081\u1d9c f x = carlesonSum (\ud835\udd13pos (X := X) \u2229 \ud835\udd13\u2081\u1d9c) f x := by\n  have A p (hp : p \u2208 (\ud835\udd13pos (X := X))\u1d9c) : \u2200\u1d50 x, x \u2208 G \\ G' \u2192 x \u2209 \ud835\udcd8 p := by\n    simp only [\ud835\udd13pos, mem_compl_iff, mem_setOf_eq, not_lt, nonpos_iff_eq_zero] at hp\n    filter_upwards [measure_zero_iff_ae_nmem.mp hp] with x hx h'x (h''x : x \u2208 (\ud835\udcd8 p : Set X))\n    simp [h''x, h'x.1, h'x.2] at hx\n  rw [\u2190 ae_ball_iff (to_countable \ud835\udd13pos\u1d9c)] at A\n  filter_upwards [A] with x hx h'x\n  simp only [carlesonSum]\n  symm\n  apply Finset.sum_subset\n  \u00b7 intro p hp\n    simp only [Finset.mem_filter, Finset.mem_univ, true_and] at hp \u22a2\n    exact hp.2\n  \u00b7 intro p hp h'p\n    simp only [Finset.mem_filter, Finset.mem_univ, true_and] at hp h'p\n    simp only [mem_inter_iff, hp, and_true] at h'p\n    have : x \u2209 \ud835\udcd8 p := hx _ h'p h'x\n    have : x \u2209 E p := by simp at this; simp [E, this]\n    simp [carlesonOn, this]\n\n/-- The Carleson sum over `\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c` can be decomposed as a sum over the intersections of this\nset with various `\u212d k n`. -/\nlemma carlesonSum_\ud835\udd13pos_eq_sum {f : X \u2192 \u2102} {x : X} :\n    carlesonSum (\ud835\udd13pos (X := X) \u2229 \ud835\udd13\u2081\u1d9c) f x =\n      \u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, carlesonSum (\ud835\udd13pos (X := X) \u2229 \ud835\udd13\u2081\u1d9c \u2229 \u212d k n) f x := by\n  simp only [Finset.sum_sigma']\n  rw [sum_carlesonSum_of_pairwiseDisjoint]; swap\n  \u00b7 rintro \u27e8n, k\u27e9 - \u27e8n', k'\u27e9 - h\n    simp only [ne_eq, Sigma.mk.inj_iff, heq_eq_eq] at h\n    simp only [Function.onFun, disjoint_iff_forall_ne]\n    have W := pairwiseDisjoint_\u212d (X := X) (mem_univ \u27e8k, n\u27e9) (mem_univ \u27e8k', n'\u27e9)\n      (by simp [-not_and]; tauto)\n    intro x hx y hy\n    exact (disjoint_iff_forall_ne.1 W) hx.2 hy.2\n  congr\n  ext p\n  simp only [mem_inter_iff, mem_compl_iff, Finset.mem_sigma,\n    Finset.mem_Iic, mem_iUnion, exists_and_left, exists_prop, Sigma.exists, iff_self_and, and_imp]\n  intro hp h'p\n  rcases exists_k_n_of_mem_\ud835\udd13pos hp with \u27e8k, n, h'p, hkn\u27e9\n  exact \u27e8n, k, \u27e8le_max\u212d_of_nonempty \u27e8p, h'p\u27e9 , hkn\u27e9, h'p\u27e9\n\n/-- In each set `\u212d k n`, the Carleson sum can be decomposed as a sum over `\ud835\udd0f\u2080 k n` and over\nvarious `\u212d\u2081 k n j`. -/\nlemma carlesonSum_\ud835\udd13pos_inter_\u212d_eq_add_sum {f : X \u2192 \u2102} {x : X} (hkn : k \u2264 n) :\n    carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \u212d k n) f x =\n      carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2080 k n) f x\n      + \u2211 j \u2264 2 * n + 3, carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \u212d\u2081 k n j) f x := by\n  conv_lhs => rw [\u2190 carlesonSum_inter_add_inter_compl _ (\ud835\udd0f\u2080 k n)]\n  rw [sum_carlesonSum_of_pairwiseDisjoint]; swap\n  \u00b7 apply PairwiseDisjoint.subset _ (subset_univ _)\n    apply (pairwiseDisjoint_\u212d\u2081 (k := k) (n := n)).mono\n    intro j\n    exact inter_subset_right\n  congr 2\n  \u00b7 ext p\n    simp only [mem_inter_iff, mem_compl_iff, and_congr_left_iff, and_iff_left_iff_imp, and_imp]\n    intro hp\n    simp [\ud835\udd0f\u2080_subset_\u212d hp]\n  \u00b7 apply Subset.antisymm\n    \u00b7 rintro p \u27e8\u27e8hp, Hp\u27e9, h'p\u27e9\n      rcases exists_j_of_mem_\ud835\udd13pos_\u212d hp.1 Hp hkn with H\n      simp only [mem_compl_iff] at h'p\n      simp only [h'p, false_or] at H\n      simp only [Finset.mem_Iic, mem_iUnion, mem_inter_iff, hp, true_and, exists_prop]\n      exact H\n    \u00b7 intro p hp\n      simp only [Finset.mem_Iic, mem_iUnion, mem_compl_iff, exists_and_left, exists_prop] at hp\n      rcases hp with \u27e8i, hi, h'i, h''i\u27e9\n      exact \u27e8\u27e8h'i, \u212d\u2081_subset_\u212d h''i\u27e9, disjoint_left.1 \ud835\udd0f\u2080_disjoint_\u212d\u2081.symm h''i\u27e9\n\nlemma carlesonSum_\ud835\udd13pos_inter_\ud835\udd0f\u2080_eq_sum {f : X \u2192 \u2102} {x : X} :\n    carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2080 k n) f x =\n      \u2211 l < n, carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2080' k n l) f x := by\n  rw [sum_carlesonSum_of_pairwiseDisjoint]; swap\n  \u00b7 apply PairwiseDisjoint.subset _ (subset_univ _)\n    apply (pairwiseDisjoint_L0' (k := k) (n := n)).mono\n    intro j\n    exact inter_subset_right\n  congr\n  rw [\u2190 iUnion_L0']\n  ext p\n  simp\n\n", "theoremStatement": "/-- In each set `\u212d\u2081 k n j`, the Carleson sum can be decomposed as a sum over `\u212d\u2082 k n j` and over\nvarious `\ud835\udd0f\u2081 k n j l`. -/\nlemma carlesonSum_\ud835\udd13pos_inter_\u212d\u2081_eq_add_sum {f : X \u2192 \u2102} {x : X} :\n    carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \u212d\u2081 k n j) f x =\n      carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \u212d\u2082 k n j) f x\n      + \u2211 l \u2264 Z * (n + 1), carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2081 k n j l) f x ", "theoremName": "carlesonSum_\ud835\udd13pos_inter_\u212d\u2081_eq_add_sum", "fileCreated": {"commit": "310e13d16e51600777fc841833f4bce112b5f73a", "date": "2024-09-24"}, "theoremCreated": {"commit": "77d4285c51ebe49f9035715383dfd7aef6aecf25", "date": "2025-01-09"}, "file": "carleson/Carleson/Discrete/ForestComplement.lean", "module": "Carleson.Discrete.ForestComplement", "jsonFile": "Carleson.Discrete.ForestComplement.jsonl", "positionMetadata": {"lineInFile": 678, "tokenPositionInFile": 34005, "theoremPositionInFile": 36}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 30, "numPremises": 164}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  conv_lhs => rw [\u2190 carlesonSum_inter_add_inter_compl _ (\u212d\u2082 k n j)]\n  rw [sum_carlesonSum_of_pairwiseDisjoint]; swap\n  \u00b7 apply PairwiseDisjoint.subset _ (subset_univ _)\n    have : univ.PairwiseDisjoint fun l \u21a6 \ud835\udd0f\u2081 (X := X) k n j l := pairwiseDisjoint_minLayer\n    apply this.mono\n    intro j\n    exact inter_subset_right\n  congr 2\n  \u00b7 ext p\n    simp only [mem_inter_iff, mem_compl_iff, and_congr_left_iff, and_iff_left_iff_imp, and_imp]\n    intro hp\n    simp [\u212d\u2082_subset_\u212d\u2081 hp]\n  \u00b7 ext p\n    simp only [\u212d\u2082, layersAbove, mem_inter_iff,\n      mem_compl_iff, mem_diff, mem_iUnion, exists_prop, not_exists, not_and, not_forall,\n      Classical.not_imp, Decidable.not_not, Finset.mem_Iic, \ud835\udd0f\u2081, exists_and_left]\n    refine \u27e8fun h \u21a6 ?_, fun h \u21a6 ?_\u27e9\n    \u00b7 simpa [h.1.1] using h.2 h.1.2\n    \u00b7 rcases h with \u27e8i, hi, h'i\u27e9\n      simp only [h'i.1, not_false_eq_true, and_self, minLayer_subset h'i.2, forall_const, true_and]\n      exact \u27e8i, hi, h'i.2\u27e9", "proofType": "tactic", "proofLengthLines": 21, "proofLengthTokens": 940}}
{"srcContext": "import Carleson.ToMathlib.WeakType\nimport Mathlib.Analysis.SpecialFunctions.ImproperIntegrals\n\n/-! This file contains a proof of the Marcinkiewisz real interpolation theorem.\n    The proof roughly follows Folland, Real Analysis. Modern Techniques and Their Applications,\n    section 6.4, theorem 6.28, but a different truncation is used, and some estimates instead\n    follow the technique as e.g. described in [Duoandikoetxea, Fourier Analysis, 2000].\n\n    The file consists of the following sections:\n    - Convenience results for working with (interpolated) exponents\n    - Results about the particular choice of exponent\n    - Interface for using cutoff functions\n    - Results about the particular choice of scale\n    - Some tools for measure theory computations\n    - Results about truncations of a function\n    - Measurability properties of truncations\n    - Truncations and Lp spaces\n    - Some results about the integrals of truncations\n    - Minkowski's integral inequality\n    - Apply Minkowski's integral inequality to truncations\n    - Weaktype estimates applied to truncations\n    - Definitions\n    - Proof of the real interpolation theorem\n-/\n\nnoncomputable section\n\nopen ENNReal Real Set MeasureTheory\n\n-- Note (F): can we make `t : \u211d\u22650\u221e` for a large part of the proof?\nvariable {p\u2080 q\u2080 p\u2081 q\u2081 p q : \u211d\u22650\u221e} {t : \u211d}\n\n/-! ## Convenience results for working with (interpolated) exponents\n-/\nnamespace ComputationsInterpolatedExponents\n\n-- unused\nlemma ofReal_mem_Ioo_0_1 (h : t \u2208 Ioo 0 1) : ENNReal.ofReal t \u2208 Ioo 0 1 :=\n  \u27e8ofReal_pos.mpr h.1, ofReal_lt_one.mpr h.2\u27e9\n\nlemma ENNReal_preservation_positivity\u2080 (ht : t \u2208 Ioo 0 1) (hpq : p \u2260 \u22a4 \u2228 q \u2260 \u22a4) :\n    0 < (1 - ENNReal.ofReal t) * p\u207b\u00b9 + ENNReal.ofReal t * q\u207b\u00b9 := by\n  have t_mem : ENNReal.ofReal t \u2208 Ioo 0 1 :=\n    \u27e8ofReal_pos.mpr ht.1, ENNReal.ofReal_one \u25b8 (ofReal_lt_ofReal_iff zero_lt_one).mpr ht.2\u27e9\n  obtain dir|dir := hpq\n  \u00b7 exact Left.add_pos_of_pos_of_nonneg (mul_pos ((tsub_pos_of_lt t_mem.2).ne')\n      (ENNReal.inv_ne_zero.mpr dir)) (zero_le _)\n  \u00b7 exact Right.add_pos_of_nonneg_of_pos (zero_le _)\n      (mul_pos ((ofReal_pos.mpr ht.1).ne') (ENNReal.inv_ne_zero.mpr dir))\n\nlemma ENNReal_preservation_positivity (ht : t \u2208 Ioo 0 1) (hpq : p \u2260 q) :\n    0 < (1 - ENNReal.ofReal t) * p\u207b\u00b9 + ENNReal.ofReal t * q\u207b\u00b9 := by\n  apply ENNReal_preservation_positivity\u2080 ht\n  cases (lt_or_gt_of_ne hpq) <;> exact Ne.ne_or_ne \u22a4 hpq\n\nlemma ENNReal_preservation_positivity' (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) : p > 0 := by\n  rw [\u2190 inv_inv p, hp]\n  simp [ENNReal.mul_eq_top, sub_eq_zero, hp\u2080.ne', hp\u2081.ne']\n\nlemma interp_exp_ne_top (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (ht : t \u2208 Ioo 0 1)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) : p \u2260 \u22a4 :=\n  ENNReal.inv_ne_zero.mp <| hp \u25b8 (ENNReal_preservation_positivity ht hp\u2080p\u2081).ne'\n\nlemma interp_exp_ne_top' (hp\u2080p\u2081 : p\u2080 \u2260 \u22a4 \u2228 p\u2081 \u2260 \u22a4) (ht : t \u2208 Ioo 0 1)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) : p \u2260 \u22a4 :=\n  ENNReal.inv_ne_zero.mp (hp \u25b8 (ENNReal_preservation_positivity\u2080 ht hp\u2080p\u2081).ne')\n\nlemma interp_exp_eq (hp\u2080p\u2081 : p\u2080 = p\u2081)\n    (ht : t \u2208 Ioo 0 1)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    p\u2080 = p := by\n  rw [\u2190 inv_inv (a := p), hp, \u2190 hp\u2080p\u2081, \u2190 add_mul,\n    tsub_add_cancel_of_le <| ofReal_lt_one.mpr ht.2 |>.le, one_mul, inv_inv]\n\nlemma interp_exp_lt_top (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (ht : t \u2208 Ioo 0 1)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) : p < \u22a4 :=\n  Ne.lt_top <| interp_exp_ne_top hp\u2080p\u2081 ht hp\n\nlemma interp_exp_lt_top' (hp\u2080p\u2081 : p\u2080 \u2260 \u22a4 \u2228 p\u2081 \u2260 \u22a4)\n    (ht : t \u2208 Ioo 0 1)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) : p < \u22a4 :=\n  Ne.lt_top <| interp_exp_ne_top' hp\u2080p\u2081 ht hp\n\nlemma interp_exp_between (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 < p\u2081) (ht : t \u2208 Ioo 0 1)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) : p \u2208 Ioo p\u2080 p\u2081 := by\n  refine \u27e8?_, ?_\u27e9 <;> apply ENNReal.inv_lt_inv.mp\n  \u00b7 rw [hp]\n    have : p\u2080\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2080\u207b\u00b9 := by\n      rw [\u2190 add_mul, tsub_add_eq_max, max_eq_left_of_lt, one_mul]\n      exact ofReal_lt_one.mpr ht.2\n    nth_rw 2 [this]\n    gcongr\n    \u00b7 exact mul_ne_top (sub_ne_top top_ne_one.symm) (inv_ne_top.mpr hp\u2080.ne')\n    \u00b7 exact (ofReal_pos.mpr ht.1).ne'\n    \u00b7 exact coe_ne_top\n  \u00b7 rw [hp]\n    have : p\u2081\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2081\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9 := by\n      rw [\u2190 add_mul, tsub_add_eq_max, max_eq_left_of_lt, one_mul]\n      exact ofReal_lt_one.mpr ht.2\n    nth_rw 1 [this]\n    gcongr\n    \u00b7 exact mul_ne_top coe_ne_top (inv_ne_top.mpr hp\u2081.ne')\n    \u00b7 exact (tsub_pos_iff_lt.mpr (ofReal_lt_one.mpr ht.2)).ne'\n    \u00b7 exact coe_ne_top\n\nlemma one_le_interp_exp_aux (hp\u2080 : 1 \u2264 p\u2080) (hp\u2081 : 1 \u2264 p\u2081) (hp\u2080p\u2081 : p\u2080 < p\u2081) (ht : t \u2208 Ioo 0 1)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) : 1 \u2264 p :=\n  hp\u2080.trans_lt\n    (interp_exp_between (zero_lt_one.trans_le hp\u2080) (zero_lt_one.trans_le hp\u2081) hp\u2080p\u2081 ht hp).1 |>.le\n\nlemma switch_exponents (ht : t \u2208 Ioo 0 1)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    p\u207b\u00b9 = (1 - ENNReal.ofReal (1 - t)) * p\u2081\u207b\u00b9 + ENNReal.ofReal (1 - t) * p\u2080\u207b\u00b9 := by\n  rw [add_comm, \u2190 ofReal_one, \u2190 ofReal_sub, _root_.sub_sub_cancel, ofReal_sub _ ht.1.le, ofReal_one]\n  \u00b7 exact hp\n  \u00b7 exact (Ioo.one_sub_mem ht).1.le\n\nlemma one_le_toReal {a : \u211d\u22650\u221e} (ha\u2081 : 1 \u2264 a) (ha\u2082 : a < \u22a4) : 1 \u2264 a.toReal :=\n  toReal_mono ha\u2082.ne_top ha\u2081\n\nlemma one_le_interp (hp\u2080 : 1 \u2264 p\u2080) (hp\u2081 : 1 \u2264 p\u2081)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (ht : t \u2208 Ioo 0 1)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) : 1 \u2264 p := by\n  rcases (lt_or_gt_of_ne hp\u2080p\u2081) with p\u2080lt_p\u2081 | p\u2081lt_p\u2080\n  \u00b7 exact one_le_interp_exp_aux hp\u2080 hp\u2081 p\u2080lt_p\u2081 ht hp\n  \u00b7 exact one_le_interp_exp_aux hp\u2081 hp\u2080 p\u2081lt_p\u2080 (Ioo.one_sub_mem ht) (switch_exponents ht hp)\n\nlemma one_le_interp_toReal (hp\u2080 : 1 \u2264 p\u2080) (hp\u2081 : 1 \u2264 p\u2081)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (ht : t \u2208 Ioo 0 1)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) : 1 \u2264 p.toReal :=\n  one_le_toReal (one_le_interp hp\u2080 hp\u2081 hp\u2080p\u2081 ht hp) (Ne.lt_top (interp_exp_ne_top hp\u2080p\u2081 ht hp))\n\nlemma coe_rpow_ne_top {a : \u211d} {q : \u211d} (hq : q \u2265 0): ENNReal.ofReal a ^ q \u2260 \u22a4 :=\n  rpow_ne_top_of_nonneg hq coe_ne_top\n\n-- Note this lemma can directly be applied to elements of `\u211d\u22650` as well\nlemma coe_rpow_ne_top' {a : \u211d} {q : \u211d} (hq : 0 < q): ENNReal.ofReal a ^ q \u2260 \u22a4 :=\n  coe_rpow_ne_top hq.le\n\nlemma coe_pow_pos {a : \u211d} {q : \u211d} (ha : a > 0) : ENNReal.ofReal a ^ q > 0 :=\n  ENNReal.rpow_pos (ofReal_pos.mpr ha) coe_ne_top\n\nlemma rpow_ne_top' {a : \u211d\u22650\u221e} {q : \u211d} (ha : a \u2260 0) (ha' : a \u2260 \u22a4)  : a ^ q \u2260 \u22a4 := by\n  intro h\n  rcases ENNReal.rpow_eq_top_iff.mp h with \u27e8a_zero, _\u27e9 | \u27e8a_top, _\u27e9\n  \u00b7 exact (ha a_zero).elim\n  \u00b7 exact (ha' a_top).elim\n\nlemma exp_toReal_pos' {q : \u211d\u22650\u221e} (hq : q \u2265 1) (hq' : q < \u22a4) : q.toReal > 0 :=\n  toReal_pos (lt_of_lt_of_le zero_lt_one hq).ne' hq'.ne_top\n\nlemma ne_top_of_Ico {p q r : \u211d\u22650\u221e} (hq : q \u2208 Ico p r) : q \u2260 \u22a4 := hq.2.ne_top\n\nlemma lt_top_of_Ico {p q r : \u211d\u22650\u221e} (hq : q \u2208 Ico p r) : q < \u22a4 := (ne_top_of_Ico hq).lt_top\n\nlemma ne_top_of_Ioo {p q r : \u211d\u22650\u221e} (hq : q \u2208 Ioo p r) : q \u2260 \u22a4 := hq.2.ne_top\n\nlemma lt_top_of_Ioo {p q r : \u211d\u22650\u221e} (hq : q \u2208 Ioo p r) : q < \u22a4 := (ne_top_of_Ioo hq).lt_top\n\nlemma ne_top_of_Ioc {p q r : \u211d\u22650\u221e} (hq : q \u2208 Ioc p r) (hr : r < \u22a4) : q \u2260 \u22a4 :=\n  hq.2.trans_lt hr |>.ne_top\n\nlemma pos_of_rb_Ioc {p q r : \u211d\u22650\u221e} (hr : q \u2208 Ioc p r) : 0 < r :=\n  zero_le p |>.trans_lt hr.1 |>.trans_le hr.2\n\nlemma exp_toReal_ne_zero {q : \u211d\u22650\u221e} (hq : q \u2265 1) (hq' : q < \u22a4) : q.toReal \u2260 0 :=\n  (exp_toReal_pos' hq hq').ne'\n\n-- TODO: remove the top one?\nlemma exp_toReal_ne_zero' {q : \u211d\u22650\u221e} (hq : q > 0) (hq' : q \u2260 \u22a4) : q.toReal \u2260 0 :=\n  (toReal_pos hq.ne' hq').ne'\n\nlemma exp_toReal_ne_zero_of_Ico {q p : \u211d\u22650\u221e} (hq : q \u2208 Ico 1 p) : q.toReal \u2260 0 :=\n  exp_toReal_ne_zero hq.1 (lt_top_of_Ico hq)\n\nlemma pos_of_Ioo {p q r : \u211d\u22650\u221e} (hq : q \u2208 Ioo p r) : q > 0 := pos_of_gt hq.1\n\nlemma ne_zero_of_Ioo {p q r : \u211d\u22650\u221e} (hq : q \u2208 Ioo p r) : q \u2260 0 := (pos_of_gt hq.1).ne'\n\nlemma pos_of_Icc_1 {p q : \u211d\u22650\u221e} (hp : p \u2208 Icc 1 q) : p > 0 := lt_of_lt_of_le zero_lt_one hp.1\n\nlemma pos_of_ge_1 {p : \u211d\u22650\u221e} (hp : 1 \u2264 p) : p > 0 := lt_of_lt_of_le zero_lt_one hp\n\nlemma pos_rb_of_Icc_1_inh {p q : \u211d\u22650\u221e} (hp : p \u2208 Icc 1 q) : q > 0 :=\n  lt_of_lt_of_le zero_lt_one (le_trans hp.1 hp.2)\n\nlemma toReal_pos_of_Ioo {q p r : \u211d\u22650\u221e} (hp : p \u2208 Ioo q r) : p.toReal > 0 :=\n  toReal_pos (ne_zero_of_lt hp.1) hp.2.ne_top\n\nlemma toReal_ne_zero_of_Ioo {q p r : \u211d\u22650\u221e} (hp : p \u2208 Ioo q r) : p.toReal \u2260 0 :=\n  toReal_ne_zero.mpr \u27e8ne_zero_of_lt hp.1, hp.2.ne_top\u27e9\n\n-- TODO: check which ones are actually used\nlemma eq_of_rpow_eq (a b: \u211d\u22650\u221e) (c : \u211d) (hc : c \u2260 0) (h : a ^ c = b ^ c) : a = b := by\n  rw [\u2190 ENNReal.rpow_rpow_inv hc a, \u2190 ENNReal.rpow_rpow_inv hc b]\n  exact congrFun (congrArg HPow.hPow h) c\u207b\u00b9\n\nlemma le_of_rpow_le {a b: \u211d\u22650\u221e} {c : \u211d} (hc : c > 0) (h : a ^ c \u2264 b ^ c) : a \u2264 b := by\n  rw [\u2190 ENNReal.rpow_rpow_inv hc.ne' a, \u2190 ENNReal.rpow_rpow_inv hc.ne' b]\n  exact (ENNReal.rpow_le_rpow_iff (inv_pos_of_pos hc)).mpr h\n\n-- TODO : decide if this is wanted\n-- local instance : Coe \u211d \u211d\u22650\u221e where\n--   coe x := ENNReal.ofReal x\n\nlemma coe_inv_exponent (hp\u2080 : p\u2080 > 0) : ENNReal.ofReal (p\u2080\u207b\u00b9.toReal) = p\u2080\u207b\u00b9 :=\n  ofReal_toReal_eq_iff.mpr (inv_ne_top.mpr hp\u2080.ne')\n\nlemma inv_of_interpolated_pos' (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (ht : t \u2208 Ioo 0 1)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) : 0 < p\u207b\u00b9 :=\n  ENNReal.inv_pos.mpr (interp_exp_ne_top hp\u2080p\u2081 ht hp)\n\n-- TODO: remove, this is redundant, but for now mirror the development for reals...\nlemma interpolated_pos' (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9): 0 < p :=\n  ENNReal_preservation_positivity' hp\u2080 hp\u2081 hp\n\nlemma exp_toReal_pos (hp\u2080 : p\u2080 > 0) (hp\u2080' : p\u2080 \u2260 \u22a4) : 0 < p\u2080.toReal :=\n  toReal_pos hp\u2080.ne' hp\u2080'\n\nlemma interp_exp_in_Ioo_zero_top (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 \u22a4 \u2228 p\u2081 \u2260 \u22a4)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) : p \u2208 Ioo 0 \u22a4 :=\n  \u27e8interpolated_pos' hp\u2080 hp\u2081 hp, interp_exp_lt_top' hp\u2080p\u2081 ht hp\u27e9\n\nlemma inv_toReal_pos_of_ne_top (hp\u2080 : p\u2080 > 0) (hp' : p\u2080 \u2260 \u22a4) : p\u2080\u207b\u00b9.toReal > 0 :=\n  toReal_inv _ \u25b8 inv_pos_of_pos (exp_toReal_pos hp\u2080 hp')\n\nlemma inv_toReal_ne_zero_of_ne_top (hp\u2080 : p\u2080 > 0) (hp' : p\u2080 \u2260 \u22a4) : p\u2080\u207b\u00b9.toReal \u2260 0 :=\n  (inv_toReal_pos_of_ne_top hp\u2080 hp').ne'\n\nlemma interp_exp_toReal_pos (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    : 0 < p.toReal :=\n  toReal_pos (interpolated_pos' hp\u2080 hp\u2081 hp).ne' (interp_exp_ne_top hp\u2080p\u2081 ht hp)\n\nlemma interp_exp_toReal_pos' (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hp\u2080p\u2081 : p\u2080 \u2260 \u22a4 \u2228 p\u2081 \u2260 \u22a4) : 0 < p.toReal :=\n  toReal_pos (interpolated_pos' hp\u2080 hp\u2081 hp).ne' (interp_exp_ne_top' hp\u2080p\u2081 ht hp)\n\nlemma interp_exp_inv_pos (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0)\n    (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    0 < p\u207b\u00b9.toReal :=\n  toReal_inv _ \u25b8 inv_pos_of_pos (interp_exp_toReal_pos ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp)\n\nlemma interp_exp_inv_ne_zero (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0)\n    (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) : p\u207b\u00b9.toReal \u2260 0 :=\n  (interp_exp_inv_pos ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp).ne'\n\nlemma preservation_interpolation (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0)\n    (hp\u2081 : p\u2081 > 0) (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    p\u207b\u00b9.toReal = (1 - t) * (p\u2080\u207b\u00b9).toReal + t * (p\u2081\u207b\u00b9).toReal := by\n  rw [\u2190 one_toReal, \u2190 toReal_ofReal ht.1.le, \u2190 ENNReal.toReal_sub_of_le]\n  \u00b7 rw [\u2190 toReal_mul, \u2190 toReal_mul, \u2190 toReal_add]\n    \u00b7 exact congrArg ENNReal.toReal hp\n    \u00b7 exact mul_ne_top (sub_ne_top (top_ne_one.symm)) (inv_ne_top.mpr hp\u2080.ne')\n    \u00b7 exact mul_ne_top coe_ne_top (inv_ne_top.mpr hp\u2081.ne')\n  \u00b7 exact ofReal_le_one.mpr ht.2.le\n  \u00b7 exact top_ne_one.symm\n\nlemma preservation_positivity_inv_toReal (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) :\n    0 < (1 - t) * (p\u2080\u207b\u00b9).toReal + t * (p\u2081\u207b\u00b9).toReal := by\n  rcases (eq_or_ne p\u2080 \u22a4) with p\u2080eq_top | p\u2080ne_top\n  \u00b7 rw [p\u2080eq_top]\n    simp only [inv_top, zero_toReal, mul_zero, zero_add]\n    apply mul_pos ht.1\n    rw [toReal_inv]\n    refine inv_pos_of_pos (exp_toReal_pos hp\u2081 ?_)\n    rw [p\u2080eq_top] at hp\u2080p\u2081\n    exact hp\u2080p\u2081.symm\n  \u00b7 exact add_pos_of_pos_of_nonneg (mul_pos (Ioo.one_sub_mem ht).1 (toReal_inv _ \u25b8 inv_pos_of_pos\n      (exp_toReal_pos hp\u2080 p\u2080ne_top))) (mul_nonneg ht.1.le toReal_nonneg)\n\nlemma ne_inv_toReal_exponents (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) :\n    (p\u2080\u207b\u00b9.toReal \u2260 p\u2081\u207b\u00b9.toReal) := by\n  refine fun h \u21a6 hp\u2080p\u2081 ?_\n  rw [\u2190 inv_inv p\u2080, \u2190 inv_inv p\u2081]\n  apply congrArg Inv.inv\n  rw [\u2190 ofReal_toReal_eq_iff.mpr (inv_ne_top.mpr hp\u2080.ne'),\n    \u2190 ofReal_toReal_eq_iff.mpr (inv_ne_top.mpr hp\u2081.ne')]\n  exact congrArg ENNReal.ofReal h\n\nlemma ne_inv_toReal_exp_interp_exp (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0)\n  (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    (p\u2080\u207b\u00b9.toReal \u2260 p\u207b\u00b9.toReal) := by\n  rw [preservation_interpolation ht hp\u2080 hp\u2081 hp,\n    \u2190 sub_ne_zero, _root_.sub_mul, one_mul, add_comm_sub, sub_add_eq_sub_sub, sub_self, zero_sub,\n    neg_sub, \u2190 _root_.mul_sub]\n  exact mul_ne_zero ht.1.ne' (sub_ne_zero_of_ne (ne_inv_toReal_exponents hp\u2080 hp\u2081 hp\u2080p\u2081))\n\nlemma ne_sub_toReal_exp (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) :\n    p\u2081\u207b\u00b9.toReal - p\u2080\u207b\u00b9.toReal \u2260 0 :=\n  sub_ne_zero_of_ne (ne_inv_toReal_exponents hp\u2080 hp\u2081 hp\u2080p\u2081).symm\n\nlemma ne_toReal_exp_interp_exp (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    p\u2080.toReal \u2260 p.toReal := by\n  refine fun h \u21a6 ne_inv_toReal_exp_interp_exp ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp ?_\n  repeat rw [toReal_inv _]\n  exact congrArg Inv.inv h\n\nlemma ne_toReal_exp_interp_exp\u2081 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    p.toReal \u2260 p\u2081.toReal :=\n  (ne_toReal_exp_interp_exp (Ioo.one_sub_mem ht) hp\u2081 hp\u2080 (Ne.symm hp\u2080p\u2081)\n    (switch_exponents ht hp)).symm\n\nlemma ofReal_inv_interp_sub_exp_pos\u2081 (ht : t \u2208 Ioo 0 1) (hq\u2080 : q\u2080 > 0) (hq\u2081 : q\u2081 > 0)\n    (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) :\n    ENNReal.ofReal |q.toReal - q\u2081.toReal|\u207b\u00b9 > 0 :=\n  ofReal_pos.mpr (inv_pos_of_pos (abs_sub_pos.mpr (ne_toReal_exp_interp_exp\u2081 ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq)))\n\nlemma ofReal_inv_interp_sub_exp_pos\u2080 (ht : t \u2208 Ioo 0 1) (hq\u2080 : q\u2080 > 0) (hq\u2081 : q\u2081 > 0)\n    (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081) (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) :\n    ENNReal.ofReal |q.toReal - q\u2080.toReal|\u207b\u00b9 > 0 :=\n  ofReal_pos.mpr (inv_pos_of_pos (abs_sub_pos.mpr (Ne.symm\n    (ne_toReal_exp_interp_exp ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq))))\n\nlemma exp_lt_iff (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    p < p\u2080 \u2194 p\u2081 < p\u2080 := by\n  rcases lt_or_gt_of_ne hp\u2080p\u2081 with p\u2080lt_p\u2081 | p\u2081lt_p\u2080\n  \u00b7 exact \u27e8fun h \u21a6 (not_le_of_gt h (le_of_lt (interp_exp_between hp\u2080 hp\u2081 p\u2080lt_p\u2081 ht hp).1)).elim,\n      fun h \u21a6 (not_le_of_gt h p\u2080lt_p\u2081.le).elim\u27e9\n  \u00b7 exact \u27e8fun _ \u21a6 p\u2081lt_p\u2080,\n      fun _ \u21a6 (interp_exp_between hp\u2081 hp\u2080 p\u2081lt_p\u2080 (Ioo.one_sub_mem ht) (switch_exponents ht hp)).2\u27e9\n\nlemma exp_gt_iff (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    p\u2080 < p \u2194 p\u2080 < p\u2081 := by\n  rcases lt_or_gt_of_ne hp\u2080p\u2081 with p\u2080lt_p\u2081 | p\u2081lt_p\u2080\n  \u00b7 exact \u27e8fun _ \u21a6 p\u2080lt_p\u2081, fun _ \u21a6 (interp_exp_between hp\u2080 hp\u2081 p\u2080lt_p\u2081 ht hp).1\u27e9\n  \u00b7 exact \u27e8fun h \u21a6 (not_le_of_gt h (interp_exp_between hp\u2081 hp\u2080 p\u2081lt_p\u2080\n      (Ioo.one_sub_mem ht) (switch_exponents ht hp)).2.le).elim,\n      fun h \u21a6 (not_le_of_gt h p\u2081lt_p\u2080.le).elim\u27e9\n\nlemma exp_lt_exp_gt_iff (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    p < p\u2080 \u2194 p\u2081 < p := by\n  rw [exp_lt_iff ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp, \u2190 exp_gt_iff (Ioo.one_sub_mem ht) hp\u2081 hp\u2080 (Ne.symm hp\u2080p\u2081)\n    (switch_exponents ht hp)]\n\nlemma exp_gt_exp_lt_iff (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    p\u2080 < p \u2194 p < p\u2081 := by\n  rw [exp_gt_iff ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp, \u2190 exp_lt_iff (Ioo.one_sub_mem ht) hp\u2081 hp\u2080 (Ne.symm hp\u2080p\u2081)\n    (switch_exponents ht hp)]\n\nlemma exp_lt_iff\u2081 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    p < p\u2081 \u2194 p\u2080 < p\u2081 := by\n  rw [\u2190 exp_gt_exp_lt_iff ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp]\n  exact exp_gt_iff ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp\n\nlemma exp_gt_iff\u2081 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    p\u2081 < p \u2194 p\u2081 < p\u2080 := by\n  rw [\u2190 exp_lt_exp_gt_iff ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp]\n  exact exp_lt_iff ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp\n\nend ComputationsInterpolatedExponents\n\nend\n\nnoncomputable section\n\n/-! ## Results about the particular choice of exponent\n\n    The proof of the real interpolation theorem will estimate\n    `distribution (trunc f A(t)) t` and `distribution (trunc_compl f A(t)) t` for a\n    function `A`. The function `A` can be given a closed-form expression that works for\n    _all_ cases in the real interpolation theorem, because of the computation rules available\n    for elements in `\u211d\u22650\u221e` that avoid the need for a limiting procedure, e.g. `\u22a4\u207b\u00b9 = 0`.\n\n    The function `A` will be of the form `A(t) = (t / d) ^ \u03c3` for particular choices of `d` and\n    `\u03c3`. This section contatins results about the exponents `\u03c3`.\n-/\nnamespace ComputationsChoiceExponent\n\nopen ENNReal Real Set ComputationsInterpolatedExponents\n\nvariable {p\u2080 q\u2080 p\u2081 q\u2081 p q : \u211d\u22650\u221e} {t : \u211d}\n\ndef \u03b6 := (((1 - t) * (p\u2080\u207b\u00b9).toReal + t * (p\u2081\u207b\u00b9).toReal) * ((q\u2081\u207b\u00b9).toReal - (q\u2080\u207b\u00b9).toReal)) /\n        (((1 - t) * (q\u2080\u207b\u00b9).toReal + t * (q\u2081\u207b\u00b9).toReal) * ((p\u2081\u207b\u00b9).toReal - (p\u2080\u207b\u00b9).toReal))\n\nlemma \u03b6_equality\u2081 (ht : t \u2208 Ioo 0 1) :\n    @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t =\n    (((1 - t) * p\u2080\u207b\u00b9.toReal + t * p\u2081\u207b\u00b9.toReal) *\n    ((1 - t) * q\u2080\u207b\u00b9.toReal + t * q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal)) /\n    (((1 - t) * q\u2080\u207b\u00b9.toReal + t * q\u2081\u207b\u00b9.toReal) *\n    ((1 - t) * p\u2080\u207b\u00b9.toReal + t * p\u2081\u207b\u00b9.toReal - p\u2080\u207b\u00b9.toReal)) := by\n  unfold \u03b6\n  rw [\u2190 mul_div_mul_right _ _ ht.1.ne', mul_assoc _ _ t, mul_assoc _ _ t]\n  congr <;> ring\n\nlemma \u03b6_equality\u2082 (ht : t \u2208 Ioo 0 1) :\n    @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t =\n    (((1 - t) * p\u2080\u207b\u00b9.toReal + t * p\u2081\u207b\u00b9.toReal) *\n    ((1 - t) * q\u2080\u207b\u00b9.toReal + t * q\u2081\u207b\u00b9.toReal - q\u2081\u207b\u00b9.toReal)) /\n    (((1 - t) * q\u2080\u207b\u00b9.toReal + t * q\u2081\u207b\u00b9.toReal) *\n    ((1 - t) * p\u2080\u207b\u00b9.toReal + t * p\u2081\u207b\u00b9.toReal - p\u2081\u207b\u00b9.toReal)) := by\n  unfold \u03b6\n  have : - (1 - t) < 0 := neg_neg_iff_pos.mpr (sub_pos.mpr ht.2)\n  rw [\u2190 mul_div_mul_right _ _ this.ne, mul_assoc _ _ (-(1 - t)), mul_assoc _ _ (-(1 - t))]\n  congr <;> ring\n\nlemma \u03b6_symm :\n    @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t = @\u03b6 p\u2081 q\u2081 p\u2080 q\u2080 (1 - t) := by\n  unfold \u03b6\n  rw [\u2190 mul_div_mul_right (c := - 1), mul_assoc _ _ (-1), mul_assoc _ _ (-1)]; on_goal 2 => positivity\n  simp only [mul_neg, mul_one, neg_sub, _root_.sub_sub_cancel]\n  nth_rewrite 1 [add_comm]; nth_rw 2 [add_comm]\n\nset_option linter.style.multiGoal false in\nset_option linter.flexible false in\nlemma \u03b6_equality\u2083 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2080' : p\u2080 \u2260 \u22a4)\n    (hq\u2080' : q\u2080 \u2260 \u22a4) :\n    @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t = (p\u2080.toReal * (q\u2080.toReal - q.toReal))  / (q\u2080.toReal * (p\u2080.toReal - p.toReal))\n    := by\n  rw [\u03b6_equality\u2081 ht, \u2190 preservation_interpolation, \u2190 preservation_interpolation]\n  have q_pos : 0 < q := interpolated_pos' hq\u2080 hq\u2081 hq\n  have p_pos : 0 < p := interpolated_pos' hp\u2080 hp\u2081 hp\n  have hne : p.toReal * q.toReal * p\u2080.toReal * q\u2080.toReal > 0 :=\n    mul_pos (mul_pos (mul_pos (interp_exp_toReal_pos ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp)\n    (interp_exp_toReal_pos ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq)) (exp_toReal_pos hp\u2080 hp\u2080'))\n    (exp_toReal_pos hq\u2080 hq\u2080')\n  rw [\u2190 mul_div_mul_right _ _ hne.ne']\n  have eq\u2081 : p\u207b\u00b9.toReal * (q\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) *\n      (p.toReal * q.toReal * p\u2080.toReal * q\u2080.toReal) =\n      p\u2080.toReal * (p\u207b\u00b9.toReal * p.toReal) * ((q\u207b\u00b9.toReal * q.toReal) * q\u2080.toReal -\n      (q\u2080\u207b\u00b9.toReal * q\u2080.toReal) * q.toReal) := by ring\n  have eq\u2082 : q\u207b\u00b9.toReal * (p\u207b\u00b9.toReal - p\u2080\u207b\u00b9.toReal) *\n      (p.toReal * q.toReal * p\u2080.toReal * q\u2080.toReal) =\n      q\u2080.toReal * (q\u207b\u00b9.toReal * q.toReal) * ((p\u207b\u00b9.toReal * p.toReal) * p\u2080.toReal -\n      (p\u2080\u207b\u00b9.toReal * p\u2080.toReal) * p.toReal) := by ring\n  rw [eq\u2081, eq\u2082, \u2190 @toReal_mul q\u207b\u00b9 q, \u2190 @toReal_mul p\u207b\u00b9 p, \u2190 @toReal_mul p\u2080\u207b\u00b9 p\u2080,\n      \u2190 @toReal_mul q\u2080\u207b\u00b9 q\u2080]\n  all_goals try assumption\n  -- TODO: why can below goals not be discharged?\n  repeat rw [ENNReal.inv_mul_cancel] <;> try positivity\n  all_goals simp <;> try assumption\n  \u00b7 apply interp_exp_ne_top hq\u2080q\u2081 ht hq\n  \u00b7 apply interp_exp_ne_top hp\u2080p\u2081 ht hp\n\nlemma one_sub_coe_one_sub (ht : t \u2208 Ioo 0 1) :\n    (1 - ENNReal.ofReal (1 - t)) = ENNReal.ofReal t := by\n  have := ht.2\n  rw [\u2190 ofReal_one, \u2190 ENNReal.ofReal_sub] <;> congr\n  \u00b7 linarith\n  \u00b7 linarith\n\nlemma coe_one_sub (ht : t \u2208 Ioo 0 1) :\n    ENNReal.ofReal (1 - t) = 1 - ENNReal.ofReal t := by\n  rw [\u2190 ofReal_one, \u2190 ENNReal.ofReal_sub]; exact ht.1.le\n\nlemma \u03b6_equality\u2084 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2081' : p\u2081 \u2260 \u22a4)\n    (hq\u2081' : q\u2081 \u2260 \u22a4) :\n    @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t =\n    (p\u2081.toReal * (q\u2081.toReal - q.toReal)) / (q\u2081.toReal * (p\u2081.toReal - p.toReal)) := by\n  rw [\u03b6_symm]\n  have one_sub_mem : 1 - t \u2208 Ioo 0 1 := Ioo.one_sub_mem ht\n  rw [\u03b6_equality\u2083 one_sub_mem] <;> try assumption\n  \u00b7 exact hp\u2080p\u2081.symm\n  \u00b7 exact hq\u2080q\u2081.symm\n  \u00b7 rw [hp, one_sub_coe_one_sub ht, coe_one_sub ht]; ring\n  \u00b7 rw [hq, one_sub_coe_one_sub ht, coe_one_sub ht]; ring\n\nlemma \u03b6_equality\u2085 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2080' : p\u2080 \u2260 \u22a4)\n    (hq\u2080' : q\u2080 \u2260 \u22a4) :\n    p\u2080.toReal + (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t)\u207b\u00b9 * (q.toReal - q\u2080.toReal) * (p\u2080.toReal / q\u2080.toReal) = p.toReal\n    := by\n  rw [\u03b6_equality\u2083 ht] <;> try assumption\n  simp only [inv_div]\n  rw [div_eq_mul_inv, div_eq_mul_inv, mul_inv]\n  calc\n  _ = p\u2080.toReal - (q\u2080.toReal\u207b\u00b9 * q\u2080.toReal) * (p\u2080.toReal - p.toReal) * (p\u2080.toReal\u207b\u00b9 * p\u2080.toReal) *\n      ((q\u2080.toReal - q.toReal)\u207b\u00b9 * (q\u2080.toReal - q.toReal)) := by ring\n  _ = _ := by\n    rw [inv_mul_cancel\u2080, inv_mul_cancel\u2080, inv_mul_cancel\u2080]\n    \u00b7 simp only [one_mul, mul_one, _root_.sub_sub_cancel]\n    \u00b7 exact sub_ne_zero_of_ne (ne_toReal_exp_interp_exp ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq)\n    \u00b7 exact (exp_toReal_pos hp\u2080 hp\u2080').ne'\n    \u00b7 exact (exp_toReal_pos hq\u2080 hq\u2080').ne'\n\nlemma \u03b6_equality\u2086 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2081' : p\u2081 \u2260 \u22a4)\n    (hq\u2081' : q\u2081 \u2260 \u22a4) :\n    p\u2081.toReal + (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t)\u207b\u00b9 * (q.toReal - q\u2081.toReal) * (p\u2081.toReal / q\u2081.toReal) = p.toReal\n    := by\n  rw [\u03b6_symm]\n  exact \u03b6_equality\u2085 (Ioo.one_sub_mem ht) hp\u2081 hq\u2081 hp\u2080 hq\u2080 hp\u2080p\u2081.symm hq\u2080q\u2081.symm\n    (switch_exponents ht hp) (switch_exponents ht hq) hp\u2081' hq\u2081'\n\nlemma \u03b6_equality\u2087 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2080' : p\u2080 \u2260 \u22a4)\n    (hq\u2080' : q\u2080 = \u22a4) :\n    @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t = p\u2080.toReal / (p\u2080.toReal - p.toReal) := by\n  rw [\u03b6_equality\u2081 ht, \u2190 preservation_interpolation ht hp\u2080 hp\u2081 hp,\n    \u2190 preservation_interpolation ht hq\u2080 hq\u2081 hq, hq\u2080']\n  simp only [inv_top, zero_toReal, sub_zero, mul_zero, zero_add]\n  have obs : p\u2080.toReal * p.toReal * q.toReal > 0 :=\n    mul_pos (mul_pos (toReal_pos hp\u2080.ne' hp\u2080') (interp_exp_toReal_pos ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp))\n    (interp_exp_toReal_pos ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq)\n  rw [\u2190 mul_div_mul_right _ _ obs.ne']\n  congr\n  \u00b7 calc\n    _ = (p.toReal\u207b\u00b9 * p.toReal) * (q.toReal\u207b\u00b9 * q.toReal) * p\u2080.toReal := by\n      rw [toReal_inv, toReal_inv]\n      ring\n    _ = _ := by\n      rw [inv_mul_cancel\u2080, inv_mul_cancel\u2080, one_mul, one_mul]\n      \u00b7 exact (interp_exp_toReal_pos ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq).ne'\n      \u00b7 exact (interp_exp_toReal_pos ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp).ne'\n  \u00b7 calc\n    _ = (q.toReal\u207b\u00b9 * q.toReal) * (p.toReal\u207b\u00b9 * p.toReal * p\u2080.toReal - p\u2080.toReal\u207b\u00b9 *\n        p\u2080.toReal * p.toReal) := by\n      rw [toReal_inv, toReal_inv, toReal_inv]\n      ring\n    _ = _ := by\n      repeat rw [inv_mul_cancel\u2080, one_mul]\n      \u00b7 exact (toReal_pos hp\u2080.ne' hp\u2080').ne'\n      \u00b7 exact (interp_exp_toReal_pos ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp).ne'\n      \u00b7 exact (interp_exp_toReal_pos ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq).ne'\n\nlemma \u03b6_equality\u2088 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2081' : p\u2081 \u2260 \u22a4)\n    (hq\u2081' : q\u2081 = \u22a4) :\n    @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t = p\u2081.toReal / (p\u2081.toReal - p.toReal) :=\n  \u03b6_symm \u25b8 \u03b6_equality\u2087 (Ioo.one_sub_mem ht) hp\u2081 hq\u2081 hp\u2080 hq\u2080 (Ne.symm hp\u2080p\u2081) (Ne.symm hq\u2080q\u2081)\n    (switch_exponents ht hp) (switch_exponents ht hq) hp\u2081' hq\u2081'\n\nlemma \u03b6_eq_top_top (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0)\n    (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2081' : p\u2081 = \u22a4)\n    (hq\u2081' : q\u2081 = \u22a4) :\n    @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t = 1 := by\n  rw [\u03b6_equality\u2082 ht, \u2190 preservation_interpolation ht hp\u2080 hp\u2081 hp,\n    \u2190 preservation_interpolation ht hq\u2080 hq\u2081 hq, hp\u2081', hq\u2081']\n  simp only [inv_top, zero_toReal, sub_zero]\n  rw [mul_comm, div_eq_mul_inv, mul_inv_cancel\u2080]\n  exact (mul_pos (interp_exp_inv_pos ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq)\n    (interp_exp_inv_pos ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp)).ne'\n\nlemma \u03b6_pos_iff_aux (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2080' : p\u2080 \u2260 \u22a4) (hq\u2080' : q\u2080 \u2260 \u22a4) :\n    ( 0 < p\u2080.toReal * (q\u2080.toReal - q.toReal) / (q\u2080.toReal * (p\u2080.toReal - p.toReal))) \u2194\n    ((q.toReal < q\u2080.toReal) \u2227 (p.toReal < p\u2080.toReal)) \u2228\n    ((q\u2080.toReal < q.toReal) \u2227 (p\u2080.toReal < p.toReal)) := by\n  rw [_root_.div_pos_iff, \u2190 Left.neg_pos_iff, \u2190 Left.neg_pos_iff, neg_mul_eq_mul_neg,\n      neg_mul_eq_mul_neg]\n  rw [mul_pos_iff_of_pos_left, mul_pos_iff_of_pos_left,\n      mul_pos_iff_of_pos_left, mul_pos_iff_of_pos_left, neg_sub, neg_sub]\n  \u00b7 simp only [sub_pos, sub_neg]\n  \u00b7 exact exp_toReal_pos hq\u2080 hq\u2080'\n  \u00b7 exact exp_toReal_pos hp\u2080 hp\u2080'\n  \u00b7 exact exp_toReal_pos hq\u2080 hq\u2080'\n  \u00b7 exact exp_toReal_pos hp\u2080 hp\u2080'\n\nlemma preservation_inequality (ht : t \u2208 Ioo 0 1) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) (hp\u2080' : p\u2080 \u2260 \u22a4) :\n    p.toReal < p\u2080.toReal \u2194 p < p\u2080 :=\n  toReal_lt_toReal (interp_exp_ne_top hp\u2080p\u2081 ht hp) hp\u2080'\n\nlemma preservation_inequality' (ht : t \u2208 Ioo 0 1)(hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) (hp\u2080' : p\u2080 \u2260 \u22a4) :\n    p\u2080.toReal < p.toReal \u2194 p\u2080 < p :=\n  toReal_lt_toReal hp\u2080' (interp_exp_ne_top hp\u2080p\u2081 ht hp)\n\nlemma preservation_inequality_of_lt\u2080 (ht : t \u2208 Ioo 0 1) (hq\u2080 : q\u2080 > 0) (hq\u2081 : q\u2081 > 0)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hq\u2080q\u2081 : q\u2080 < q\u2081) :\n    q\u2080.toReal < q.toReal :=\n  (toReal_lt_toReal hq\u2080q\u2081.ne_top (interp_exp_ne_top hq\u2080q\u2081.ne ht hq)).mpr\n    ((exp_gt_iff ht hq\u2080 hq\u2081 hq\u2080q\u2081.ne hq).mpr hq\u2080q\u2081)\n\nlemma preservation_inequality_of_lt\u2081 (ht : t \u2208 Ioo 0 1) (hq\u2080 : q\u2080 > 0) (hq\u2081 : q\u2081 > 0)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hq\u2080q\u2081 : q\u2080 < q\u2081)\n    (hq\u2081' : q\u2081 \u2260 \u22a4):\n    q.toReal < q\u2081.toReal :=\n  (toReal_lt_toReal (interp_exp_ne_top hq\u2080q\u2081.ne ht hq) hq\u2081').mpr\n    ((exp_lt_iff\u2081 ht hq\u2080 hq\u2081 hq\u2080q\u2081.ne hq).mpr hq\u2080q\u2081)\n\nlemma \u03b6_pos_toReal_iff\u2080 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hq\u2081 : q\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2080' : p\u2080 \u2260 \u22a4)\n    (hq\u2080' : q\u2080 \u2260 \u22a4) : (0 < @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) \u2194\n    ((q.toReal < q\u2080.toReal) \u2227 (p.toReal < p\u2080.toReal)) \u2228\n    ((q\u2080.toReal < q.toReal) \u2227 (p\u2080.toReal < p.toReal)) := by\n  rw [\u03b6_equality\u2083 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081 hq\u2080q\u2081 hp hq hp\u2080' hq\u2080']\n  exact \u03b6_pos_iff_aux hp\u2080 hq\u2080 hp\u2080' hq\u2080'\n\nlemma \u03b6_pos_toReal_iff\u2081 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hq\u2081 : q\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2081' : p\u2081 \u2260 \u22a4)\n    (hq\u2081' : q\u2081 \u2260 \u22a4) :\n    (0 < @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) \u2194\n    ((q.toReal < q\u2081.toReal) \u2227 (p.toReal < p\u2081.toReal)) \u2228\n    ((q\u2081.toReal < q.toReal) \u2227 (p\u2081.toReal < p.toReal)) := by\n  rw [\u03b6_equality\u2084 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081 hq\u2080q\u2081 hp hq hp\u2081' hq\u2081']\n  exact \u03b6_pos_iff_aux hp\u2081 hq\u2081 hp\u2081' hq\u2081'\n\nlemma \u03b6_pos_iff_aux\u2080 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0)\n    (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081) :\n    (0 < @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) \u2194\n    q\u2080\u207b\u00b9.toReal < q\u2081\u207b\u00b9.toReal \u2227 p\u2080\u207b\u00b9.toReal < p\u2081\u207b\u00b9.toReal \u2228\n    q\u2081\u207b\u00b9.toReal < q\u2080\u207b\u00b9.toReal \u2227 p\u2081\u207b\u00b9.toReal < p\u2080\u207b\u00b9.toReal := by\n  unfold \u03b6\n  rw [_root_.div_pos_iff, \u2190 Left.neg_pos_iff, \u2190 Left.neg_pos_iff, neg_mul_eq_mul_neg,\n      neg_mul_eq_mul_neg, mul_pos_iff_of_pos_left, mul_pos_iff_of_pos_left,\n      mul_pos_iff_of_pos_left, mul_pos_iff_of_pos_left, neg_sub, neg_sub]\n  \u00b7 simp only [sub_pos, sub_neg]\n  \u00b7 exact preservation_positivity_inv_toReal ht hq\u2080 hq\u2081 hq\u2080q\u2081\n  \u00b7 exact preservation_positivity_inv_toReal ht hp\u2080 hp\u2081 hp\u2080p\u2081\n  \u00b7 exact preservation_positivity_inv_toReal ht hq\u2080 hq\u2081 hq\u2080q\u2081\n  \u00b7 exact preservation_positivity_inv_toReal ht hp\u2080 hp\u2081 hp\u2080p\u2081\n\nlemma inv_toReal_iff (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0) :\n    p\u2080\u207b\u00b9.toReal < p\u2081\u207b\u00b9.toReal \u2194 p\u2081 < p\u2080 :=\n  Iff.trans (toReal_lt_toReal (ne_of_lt (inv_lt_top.mpr hp\u2080))\n    (ne_of_lt (inv_lt_top.mpr hp\u2081))) ENNReal.inv_lt_inv\n\nlemma \u03b6_pos_iff (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081) :\n    (0 < @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) \u2194\n    ((q\u2081 < q\u2080) \u2227 (p\u2081 < p\u2080)) \u2228 ((q\u2080 < q\u2081) \u2227 (p\u2080 < p\u2081)) := by\n  rw [\u03b6_pos_iff_aux\u2080 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081 hq\u2080q\u2081,\n    inv_toReal_iff hq\u2080 hq\u2081, inv_toReal_iff hp\u2080 hp\u2081,\n    inv_toReal_iff hq\u2081 hq\u2080, inv_toReal_iff hp\u2081 hp\u2080]\n\nlemma \u03b6_pos_iff' (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0)\n    (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) :\n    (0 < @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) \u2194\n    ((q < q\u2080) \u2227 (p < p\u2080)) \u2228 ((q\u2080 < q) \u2227 (p\u2080 < p)) := by\n  rw [\u03b6_pos_iff ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081 hq\u2080q\u2081,\n    \u2190 exp_lt_iff ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp, \u2190 exp_lt_iff ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq,\n    \u2190 exp_gt_iff ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp, \u2190 exp_gt_iff ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq]\n\nlemma \u03b6_pos_iff_of_lt\u2080 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0)\n    (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2080p\u2081' : p\u2080 < p\u2081)  :\n    (0 < @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) \u2194\n    (q\u2080 < q) := by\n  rw [\u03b6_pos_iff' ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081'.ne hq\u2080q\u2081 hp hq]\n  rw [\u2190 exp_gt_iff (p := p) ht hp\u2080 hp\u2081 hp\u2080p\u2081'.ne hp] at hp\u2080p\u2081'\n  have : \u00ac (p < p\u2080) := not_lt_of_gt hp\u2080p\u2081'\n  tauto\n\nlemma \u03b6_pos_iff_of_lt\u2081 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0)\n  (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2080p\u2081' : p\u2080 < p\u2081) :\n    (0 < @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) \u2194\n    (q < q\u2081) := by\n  rw [\u2190 exp_gt_exp_lt_iff ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq]\n  exact \u03b6_pos_iff_of_lt\u2080 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hq\u2080q\u2081 hp hq hp\u2080p\u2081'\n\nlemma \u03b6_neg_iff_aux\u2080 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081) :\n    (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) < 0 \u2194\n    q\u2080\u207b\u00b9.toReal < q\u2081\u207b\u00b9.toReal \u2227 p\u2081\u207b\u00b9.toReal < p\u2080\u207b\u00b9.toReal \u2228\n    q\u2081\u207b\u00b9.toReal < q\u2080\u207b\u00b9.toReal \u2227 p\u2080\u207b\u00b9.toReal < p\u2081\u207b\u00b9.toReal := by\n  unfold \u03b6\n  rw [div_neg_iff, \u2190 Left.neg_pos_iff, \u2190 Left.neg_pos_iff, neg_mul_eq_mul_neg, neg_mul_eq_mul_neg]\n  rw [mul_pos_iff_of_pos_left, mul_pos_iff_of_pos_left,\n      mul_pos_iff_of_pos_left, mul_pos_iff_of_pos_left, neg_sub, neg_sub]\n  \u00b7 simp only [sub_pos, sub_neg]\n  \u00b7 exact preservation_positivity_inv_toReal ht hq\u2080 hq\u2081 hq\u2080q\u2081\n  \u00b7 exact preservation_positivity_inv_toReal ht hp\u2080 hp\u2081 hp\u2080p\u2081\n  \u00b7 exact preservation_positivity_inv_toReal ht hq\u2080 hq\u2081 hq\u2080q\u2081\n  \u00b7 exact preservation_positivity_inv_toReal ht hp\u2080 hp\u2081 hp\u2080p\u2081\n\nlemma \u03b6_neg_iff (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081) :\n    (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) < 0 \u2194\n    q\u2081 < q\u2080 \u2227 p\u2080 < p\u2081 \u2228 q\u2080 < q\u2081 \u2227 p\u2081 < p\u2080 := by\n  rw [\u03b6_neg_iff_aux\u2080 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081 hq\u2080q\u2081, inv_toReal_iff hq\u2080 hq\u2081, inv_toReal_iff hp\u2080 hp\u2081,\n    inv_toReal_iff hq\u2081 hq\u2080, inv_toReal_iff hp\u2081 hp\u2080]\n\nlemma \u03b6_neg_iff' (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) :\n    (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) < 0 \u2194\n    ((q < q\u2080) \u2227 (p\u2080 < p)) \u2228 ((q\u2080 < q) \u2227 (p < p\u2080)) := by\n  rw [\u03b6_neg_iff ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081 hq\u2080q\u2081, \u2190 exp_lt_iff ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp,\n    \u2190 exp_lt_iff ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq, \u2190 exp_gt_iff ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp,\n    \u2190 exp_gt_iff ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq]\n\nlemma \u03b6_neg_iff_of_lt\u2080 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2080p\u2081' : p\u2080 < p\u2081) :\n    (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) < 0 \u2194 q < q\u2080 := by\n  rw [\u03b6_neg_iff' ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081'.ne hq\u2080q\u2081 hp hq]\n  rw [\u2190 exp_gt_iff (p := p) ht hp\u2080 hp\u2081 hp\u2080p\u2081'.ne hp] at hp\u2080p\u2081'\n  have : \u00ac (p < p\u2080) := not_lt_of_gt hp\u2080p\u2081'\n  tauto\n\nlemma \u03b6_neg_iff_of_lt\u2081 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2080p\u2081' : p\u2080 < p\u2081) :\n    (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) < 0 \u2194 q\u2081 < q := by\n  rw [\u2190 exp_lt_exp_gt_iff ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq]\n  exact \u03b6_neg_iff_of_lt\u2080 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hq\u2080q\u2081 hp hq hp\u2080p\u2081'\n\nlemma \u03b6_neg_iff_aux (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2080' : p\u2080 \u2260 \u22a4)\n    (hq\u2080' : q\u2080 \u2260 \u22a4) :\n    (p\u2080.toReal * (q\u2080.toReal - q.toReal) / (q\u2080.toReal * (p\u2080.toReal - p.toReal)) < 0) \u2194\n    ((q.toReal < q\u2080.toReal) \u2227 (p\u2080.toReal < p.toReal)) \u2228\n    ((q\u2080.toReal < q.toReal) \u2227 (p.toReal < p\u2080.toReal)) := by\n  rw [div_neg_iff, \u2190 Left.neg_pos_iff, \u2190 Left.neg_pos_iff, neg_mul_eq_mul_neg, neg_mul_eq_mul_neg,\n    mul_pos_iff_of_pos_left, mul_pos_iff_of_pos_left,\n    mul_pos_iff_of_pos_left, mul_pos_iff_of_pos_left, neg_sub, neg_sub]\n  \u00b7 simp only [sub_pos, sub_neg]\n  \u00b7 exact exp_toReal_pos hq\u2080 hq\u2080'\n  \u00b7 exact exp_toReal_pos hp\u2080 hp\u2080'\n  \u00b7 exact exp_toReal_pos hq\u2080 hq\u2080'\n  \u00b7 exact exp_toReal_pos hp\u2080 hp\u2080'\n\nlemma \u03b6_neg_toReal_iff\u2080 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hq\u2081 : q\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2080' : p\u2080 \u2260 \u22a4)\n    (hq\u2080' : q\u2080 \u2260 \u22a4) :\n    (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t < 0) \u2194\n    ((q.toReal < q\u2080.toReal) \u2227 (p\u2080.toReal < p.toReal)) \u2228\n    ((q\u2080.toReal < q.toReal) \u2227 (p.toReal < p\u2080.toReal)) := by\n  rw [\u03b6_equality\u2083 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081 hq\u2080q\u2081 hp hq hp\u2080' hq\u2080']\n  exact \u03b6_neg_iff_aux hp\u2080 hq\u2080 hp\u2080' hq\u2080'\n\nlemma \u03b6_neg_toReal_iff\u2081 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hq\u2081 : q\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2081' : p\u2081 \u2260 \u22a4)\n    (hq\u2081' : q\u2081 \u2260 \u22a4) :\n    (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t < 0) \u2194\n    ((q.toReal < q\u2081.toReal) \u2227 (p\u2081.toReal < p.toReal)) \u2228 ((q\u2081.toReal < q.toReal) \u2227\n    (p.toReal < p\u2081.toReal)) := by\n  rw [\u03b6_equality\u2084 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081 hq\u2080q\u2081 hp hq hp\u2081' hq\u2081']\n  exact \u03b6_neg_iff_aux hp\u2081 hq\u2081 hp\u2081' hq\u2081'\n\nlemma \u03b6_neg_iff\u2080 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2080' : p\u2080 \u2260 \u22a4)\n    (hq\u2080' : q\u2080 \u2260 \u22a4) : (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t < 0) \u2194\n    ((q < q\u2080) \u2227 (p\u2080 < p)) \u2228 ((q\u2080 < q) \u2227 (p < p\u2080)) := by\n  rw [\u03b6_neg_toReal_iff\u2080 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081 hq\u2080q\u2081 hp hq hp\u2080' hq\u2080',\n    preservation_inequality ht hq\u2080q\u2081 hq hq\u2080', preservation_inequality ht hp\u2080p\u2081 hp hp\u2080',\n    preservation_inequality' ht hq\u2080q\u2081 hq hq\u2080', preservation_inequality' ht hp\u2080p\u2081 hp hp\u2080']\n\nlemma \u03b6_ne_zero (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081) :\n    (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t \u2260 0) := by\n  refine div_ne_zero ?_ ?_\n  \u00b7 apply mul_ne_zero (preservation_positivity_inv_toReal ht hp\u2080 hp\u2081 hp\u2080p\u2081).ne'\n    refine sub_ne_zero_of_ne (Ne.symm fun h \u21a6 hq\u2080q\u2081 ?_)\n    rw [\u2190 inv_inv q\u2080, \u2190 inv_inv q\u2081, \u2190 coe_inv_exponent hq\u2080, \u2190 coe_inv_exponent hq\u2081]\n    exact congrArg Inv.inv (congrArg ENNReal.ofReal h)\n  \u00b7 apply mul_ne_zero (preservation_positivity_inv_toReal ht hq\u2080 hq\u2081 hq\u2080q\u2081).ne'\n    refine sub_ne_zero_of_ne (Ne.symm fun h \u21a6 hp\u2080p\u2081 ?_)\n    rw [\u2190 inv_inv p\u2080, \u2190 inv_inv p\u2081, \u2190 coe_inv_exponent hp\u2080, \u2190 coe_inv_exponent hp\u2081]\n    exact congrArg Inv.inv (congrArg ENNReal.ofReal h)\n\nlemma \u03b6_le_zero_iff_of_lt\u2080 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2080p\u2081' : p\u2080 < p\u2081) :\n    (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t \u2264 0) \u2194 q < q\u2080 := by\n  constructor <;> intro h\n  \u00b7 rcases (Decidable.lt_or_eq_of_le h) with \u03b6_lt_0 | \u03b6_eq_0\n    \u00b7 exact (\u03b6_neg_iff_of_lt\u2080 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hq\u2080q\u2081 hp hq hp\u2080p\u2081').mp \u03b6_lt_0\n    \u00b7 exact False.elim <| (\u03b6_ne_zero ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081'.ne hq\u2080q\u2081) \u03b6_eq_0\n  \u00b7 exact ((\u03b6_neg_iff_of_lt\u2080 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hq\u2080q\u2081 hp hq hp\u2080p\u2081').mpr h).le\n\nlemma \u03b6_le_zero_iff_of_lt\u2081 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2080p\u2081' : p\u2080 < p\u2081) :\n    (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) \u2264 0 \u2194 q\u2081 < q := by\n  rw [\u2190 exp_lt_exp_gt_iff ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq]\n  exact \u03b6_le_zero_iff_of_lt\u2080 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hq\u2080q\u2081 hp hq hp\u2080p\u2081'\n\nlemma eq_exponents\u2080 (ht : t \u2208 Ioo 0 1) (hq\u2080 : q\u2080 > 0) (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hq\u2080' : q\u2080 \u2260 \u22a4) :\n    (q\u2080.toReal + q\u2081\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) *\n    (q.toReal - q\u2080.toReal)) = (1 - t) * q.toReal := by\n  rw [mul_comm_div, \u2190 mul_div_assoc, add_div']\n  \u00b7 have : q\u2080.toReal * (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) + q\u2081\u207b\u00b9.toReal * (q.toReal - q\u2080.toReal) =\n        q.toReal * ((1 - t) * (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal)) := by\n      calc\n      _ = q\u2080.toReal * q\u2081\u207b\u00b9.toReal - q\u2080.toReal * q\u2080\u207b\u00b9.toReal +\n          q\u2081\u207b\u00b9.toReal * q.toReal - q\u2081\u207b\u00b9.toReal *  q\u2080.toReal := by\n        ring\n      _ = q\u2081\u207b\u00b9.toReal * q.toReal - q\u207b\u00b9.toReal * q.toReal := by\n        rw [toReal_inv, toReal_inv, toReal_inv, mul_inv_cancel\u2080, inv_mul_cancel\u2080]\n        \u00b7 ring\n        \u00b7 exact (interp_exp_toReal_pos ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq).ne'\n        \u00b7 exact (toReal_pos hq\u2080.ne' hq\u2080').ne'\n      _ = q.toReal * (q\u2081\u207b\u00b9.toReal - q\u207b\u00b9.toReal) := by ring\n      _ = _ := by\n        rw [preservation_interpolation ht hq\u2080 hq\u2081 hq]\n        congr\n        ring\n    rw [this, mul_div_assoc, mul_div_cancel_right\u2080]\n    \u00b7 ring\n    exact ne_sub_toReal_exp hq\u2080 hq\u2081 hq\u2080q\u2081\n  \u00b7 exact ne_sub_toReal_exp hq\u2080 hq\u2081 hq\u2080q\u2081\n\nlemma eq_exponents\u2082 (ht : t \u2208 Ioo 0 1) (hq\u2080 : q\u2080 > 0) (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hq\u2080' : q\u2080 \u2260 \u22a4) :\n    (q\u2080.toReal / p\u2080.toReal + p\u2080\u207b\u00b9.toReal * q\u2081\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) *\n    (q.toReal - q\u2080.toReal)) = (1 - t) * p\u2080\u207b\u00b9.toReal * q.toReal := by\n  rw [div_eq_inv_mul, mul_div_assoc, mul_assoc, toReal_inv, \u2190 mul_add, mul_comm_div,\n    \u2190 mul_div_assoc, add_div']\n  \u00b7 have : q\u2080.toReal * (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) + q\u2081\u207b\u00b9.toReal * (q.toReal - q\u2080.toReal) =\n        q.toReal * ((1 - t) * (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal)) := by\n      calc\n      _ = q\u2080.toReal * q\u2081\u207b\u00b9.toReal - q\u2080.toReal * q\u2080\u207b\u00b9.toReal +\n          q\u2081\u207b\u00b9.toReal * q.toReal - q\u2081\u207b\u00b9.toReal *  q\u2080.toReal := by\n        ring\n      _ = q\u2081\u207b\u00b9.toReal * q.toReal - q\u207b\u00b9.toReal * q.toReal := by\n        rw [toReal_inv, toReal_inv, toReal_inv, mul_inv_cancel\u2080, inv_mul_cancel\u2080]\n        \u00b7 ring\n        \u00b7 exact (interp_exp_toReal_pos ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq).ne'\n        \u00b7 exact (toReal_pos hq\u2080.ne' hq\u2080').ne'\n      _ = q.toReal * (q\u2081\u207b\u00b9.toReal - q\u207b\u00b9.toReal) := by ring\n      _ = _ := by\n        rw [preservation_interpolation ht hq\u2080 hq\u2081 hq]\n        congr\n        ring\n    rw [this, mul_div_assoc, mul_div_cancel_right\u2080]\n    \u00b7 ring\n    \u00b7 exact ne_sub_toReal_exp hq\u2080 hq\u2081 hq\u2080q\u2081\n  \u00b7 exact ne_sub_toReal_exp hq\u2080 hq\u2081 hq\u2080q\u2081\n\nlemma eq_exponents\u2081 (ht : t \u2208 Ioo 0 1) (hq\u2080 : q\u2080 > 0) (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hq\u2080' : q\u2080 \u2260 \u22a4) :\n    (q\u2080\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal)) * (q.toReal - q\u2080.toReal) = - t * q.toReal := by\n  rw [mul_comm_div, \u2190 mul_div_assoc]\n  have : q\u2080\u207b\u00b9.toReal * (q.toReal - q\u2080.toReal) = - t * q.toReal * (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) := by\n    calc\n    _ = (q\u2080\u207b\u00b9.toReal * q.toReal - q\u2080\u207b\u00b9.toReal * q\u2080.toReal) := by ring\n    _ = (q\u2080\u207b\u00b9.toReal * q.toReal - 1) := by\n      rw [toReal_inv, inv_mul_cancel\u2080]\n      exact (exp_toReal_pos hq\u2080 hq\u2080').ne'\n    _ = (q\u2080\u207b\u00b9.toReal * q.toReal - q\u207b\u00b9.toReal * q.toReal) := by\n      rw [toReal_inv, toReal_inv, inv_mul_cancel\u2080]\n      exact (interp_exp_toReal_pos ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq).ne'\n    _ = q.toReal * (q\u2080\u207b\u00b9.toReal - q\u207b\u00b9.toReal) := by ring\n    _ = _ := by\n      rw [preservation_interpolation ht hq\u2080 hq\u2081 hq]\n      ring\n  rw [this, mul_div_cancel_right\u2080]\n  exact ne_sub_toReal_exp hq\u2080 hq\u2081 hq\u2080q\u2081\n\n-- TODO: simplify these proofs with statements above\nlemma eq_exponents\u2083 (ht : t \u2208 Ioo 0 1) (hq\u2080 : q\u2080 > 0) (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hq\u2080' : q\u2080 \u2260 \u22a4) :\n    (p\u2081\u207b\u00b9.toReal * q\u2080\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal)) * (q.toReal - q\u2080.toReal) =\n    - t * p\u2081\u207b\u00b9.toReal * q.toReal := by\n  rw [mul_comm_div, \u2190 mul_div_assoc]\n  have : (p\u2081\u207b\u00b9.toReal * q\u2080\u207b\u00b9.toReal) * (q.toReal - q\u2080.toReal) =\n      - t * p\u2081\u207b\u00b9.toReal * q.toReal * (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) := by\n    calc\n    _ = p\u2081\u207b\u00b9.toReal * (q\u2080\u207b\u00b9.toReal * q.toReal - q\u2080\u207b\u00b9.toReal * q\u2080.toReal) := by ring\n    _ = p\u2081\u207b\u00b9.toReal * (q\u2080\u207b\u00b9.toReal * q.toReal - 1) := by\n      rw [toReal_inv, toReal_inv, inv_mul_cancel\u2080]\n      apply (exp_toReal_pos hq\u2080 hq\u2080').ne'\n    _ = p\u2081\u207b\u00b9.toReal * (q\u2080\u207b\u00b9.toReal * q.toReal - q\u207b\u00b9.toReal * q.toReal) := by\n      rw [toReal_inv, toReal_inv, toReal_inv, inv_mul_cancel\u2080]\n      exact (interp_exp_toReal_pos ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq).ne'\n    _ = p\u2081\u207b\u00b9.toReal * q.toReal * (q\u2080\u207b\u00b9.toReal - q\u207b\u00b9.toReal) := by ring\n    _ = _ := by\n      rw [preservation_interpolation ht hq\u2080 hq\u2081 hq]\n      ring\n  rw [this, mul_div_cancel_right\u2080]\n  exact ne_sub_toReal_exp hq\u2080 hq\u2081 hq\u2080q\u2081\n\nlemma eq_exponents\u2084  :\n    (q\u2080\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal)) =\n    - (q\u2080\u207b\u00b9.toReal / (q\u2080\u207b\u00b9.toReal - q\u2081\u207b\u00b9.toReal)) := calc\n  _ = - (q\u2080\u207b\u00b9.toReal * (-(q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal)\u207b\u00b9)) := by\n    rw [div_eq_mul_inv]; ring\n  _ = _ := by congr; rw [neg_inv, neg_sub]\n\nlemma eq_exponents\u2085 (ht : t \u2208 Ioo 0 1) (hq\u2080 : q\u2080 > 0) (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hq\u2081' : q\u2081 \u2260 \u22a4):\n    (q\u2081.toReal + -(q\u2080\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) * (q.toReal - q\u2081.toReal)))\n    = t * q.toReal := by\n  rw [eq_exponents\u2084, neg_mul, neg_neg, eq_exponents\u2080 (Ioo.one_sub_mem ht) hq\u2081 hq\u2080 (Ne.symm hq\u2080q\u2081)\n    (switch_exponents ht hq) hq\u2081']\n  ring\n\nlemma eq_exponents\u2086 (ht : t \u2208 Ioo 0 1) (hq\u2080 : q\u2080 > 0) (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hq\u2081' : q\u2081 \u2260 \u22a4) :\n    q\u2081\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) * (q.toReal - q\u2081.toReal) = (1 - t) * q.toReal := by\n  rw [\u2190 neg_neg (a := q\u2081\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal)), \u2190 eq_exponents\u2084, neg_mul,\n    eq_exponents\u2081 (Ioo.one_sub_mem ht) hq\u2081 hq\u2080 (Ne.symm hq\u2080q\u2081) (switch_exponents ht hq) hq\u2081']\n  ring\n\nlemma eq_exponents\u2087 (ht : t \u2208 Ioo 0 1) (hq\u2080 : q\u2080 > 0) (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hq\u2081' : q\u2081 \u2260 \u22a4) :\n    q\u2081.toReal / p\u2081.toReal + -(p\u2081\u207b\u00b9.toReal * q\u2080\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) *\n    (q.toReal - q\u2081.toReal)) =\n    t * p\u2081\u207b\u00b9.toReal * q.toReal := by\n  rw [div_eq_mul_inv, toReal_inv]\n  calc\n  _ = p\u2081.toReal\u207b\u00b9 * (q\u2081.toReal + - (q\u2080\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) *\n      (q.toReal - q\u2081.toReal))) := by ring\n  _ = _ := by\n    rw [eq_exponents\u2085 (ht := ht)] <;> try assumption\n    ring\n\nlemma eq_exponents\u2088 (ht : t \u2208 Ioo 0 1) (hq\u2080 : q\u2080 > 0) (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hq\u2081' : q\u2081 \u2260 \u22a4) :\n    p\u2080\u207b\u00b9.toReal * q\u2081\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) * (q.toReal - q\u2081.toReal) =\n    (1 - t) * p\u2080\u207b\u00b9.toReal * q.toReal := calc\n  _ = p\u2080\u207b\u00b9.toReal * (q\u2081\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) * (q.toReal - q\u2081.toReal)) := by ring\n  _ = _ := by\n    rw [eq_exponents\u2086] <;> try assumption\n    ring\n\nend ComputationsChoiceExponent\n\nend\n\n/-! ## Interface for using cutoff functions\n-/\nnoncomputable section\n\nopen Real Set\n\n/-- A ScaledPowerFunction is meant to represent a function of the form `t \u21a6 (t / d)^\u03c3`,\n    where `d` is strictly positive and either `\u03c3 > 0` or `\u03c3 < 0`. -/\nstructure ScaledPowerFunction where\n  \u03c3 : \u211d\n  d : \u211d\n  hd : d > 0\n  h\u03c3 : (\u03c3 > 0) \u2228 (\u03c3 < 0)\n\n/-- A ToneCouple is an couple of two monotone functions that are practically inverses of each\n    other. It is used in the proof of the real interpolation theorem.\n\n    Note: originally it seemed useful to make the possible choice of this function general\n    in the proof of the real inteprolation theorem. However, in the end really only one\n    function works for all the different cases. This infrastructure, however, could potentially\n    still be useful, if one would like to try to improve the constant. -/\nstructure ToneCouple where\n  ton : \u211d \u2192 \u211d\n  inv : \u211d \u2192 \u211d\n  mon : Bool\n  ton_is_ton : if mon then StrictMonoOn ton (Ioi 0) else StrictAntiOn ton (Ioi 0)\n  ran_ton : \u2200 t \u2208 Ioi (0 : \u211d), ton t \u2208 Ioi 0\n  ran_inv : \u2200 t \u2208 Ioi (0 : \u211d), inv t \u2208 Ioi 0\n  inv_pf : if mon\n      then \u2200 s \u2208 Ioi (0 : \u211d), \u2200 t \u2208 Ioi (0 : \u211d), (ton s < t \u2194 s < inv t) \u2227 (t < ton s \u2194 inv t < s)\n      else \u2200 s \u2208 Ioi (0 : \u211d), \u2200 t \u2208 Ioi (0 : \u211d), (ton s < t \u2194 inv t < s) \u2227 (t < ton s \u2194 s < inv t)\n\n/-- A scaled power function gives rise to a ToneCouple. -/\ndef spf_to_tc (spf : ScaledPowerFunction) : ToneCouple where\n  ton := fun s : \u211d \u21a6 (s / spf.d) ^ spf.\u03c3\n  inv := fun t : \u211d \u21a6 spf.d * t ^ spf.\u03c3\u207b\u00b9\n  mon := if spf.\u03c3 > 0 then true else false\n  ran_ton := fun t ht \u21a6 rpow_pos_of_pos (div_pos ht spf.hd) _\n  ran_inv := fun t ht \u21a6 mul_pos spf.hd (rpow_pos_of_pos ht spf.\u03c3\u207b\u00b9)\n  ton_is_ton := by\n    split <;> rename_i sgn_\u03c3\n    \u00b7 simp only [\u2193reduceIte]\n      intro s (hs : s > 0) t (ht : t > 0) hst\n      refine (rpow_lt_rpow_iff ?_ ?_ sgn_\u03c3).mpr ?_\n      \u00b7 exact (div_pos hs spf.hd).le\n      \u00b7 exact (div_pos ht spf.hd).le\n      \u00b7 exact div_lt_div_of_pos_right hst spf.hd\n    \u00b7 simp only [Bool.false_eq_true, \u2193reduceIte]\n      intro s (hs : s > 0) t (ht : t > 0) hst\n      rcases spf.h\u03c3 with \u03c3_pos | \u03c3_neg\n      \u00b7 exact (sgn_\u03c3 \u03c3_pos).elim\n      \u00b7 simp only\n        exact (Real.rpow_lt_rpow_iff_of_neg (div_pos ht spf.hd)\n          (div_pos hs spf.hd) \u03c3_neg).mpr (div_lt_div_of_pos_right hst spf.hd)\n  inv_pf := by\n    split <;> rename_i sgn_\u03c3\n    \u00b7 simp only [\u2193reduceIte, mem_Ioi]\n      refine fun s hs t ht => \u27e8?_, ?_\u27e9\n      \u00b7 rw [\u2190 Real.lt_rpow_inv_iff_of_pos (div_nonneg hs.le spf.hd.le) ht.le sgn_\u03c3,\n        \u2190 _root_.mul_lt_mul_left spf.hd, mul_div_cancel\u2080 _ spf.hd.ne']\n      \u00b7 rw [\u2190 Real.rpow_inv_lt_iff_of_pos ht.le (div_nonneg hs.le spf.hd.le)\n          sgn_\u03c3, \u2190 _root_.mul_lt_mul_left spf.hd, mul_div_cancel\u2080 _ spf.hd.ne']\n    \u00b7 simp only [\u2193reduceIte, mem_Ioi]\n      intro s hs t ht\n      rcases spf.h\u03c3 with \u03c3_pos | \u03c3_neg\n      \u00b7 contradiction\n      \u00b7 constructor\n        \u00b7 rw [\u2190 Real.rpow_inv_lt_iff_of_neg ht (div_pos hs spf.hd) \u03c3_neg,\n            \u2190 _root_.mul_lt_mul_left spf.hd, mul_div_cancel\u2080 _ spf.hd.ne']\n        \u00b7 rw [\u2190 Real.lt_rpow_inv_iff_of_neg (div_pos hs spf.hd) ht \u03c3_neg,\n            \u2190 _root_.mul_lt_mul_left spf.hd, mul_div_cancel\u2080 _ spf.hd.ne']\n\nend\n\nnoncomputable section\n\nopen NNReal ENNReal MeasureTheory Set ComputationsInterpolatedExponents\n    ComputationsChoiceExponent\n\nvariable {\u03b1 \u03b1' E E\u2081 E\u2082 E\u2083 : Type*} {m : MeasurableSpace \u03b1} {m' : MeasurableSpace \u03b1'}\n  {p p' q p\u2080 q\u2080 p\u2081 q\u2081: \u211d\u22650\u221e}\n  {C\u2080 C\u2081 : \u211d\u22650} {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b1'}\n  {a : \u211d}-- truncation parameter\n  [NormedAddCommGroup E]\n  [NormedAddCommGroup E\u2081]\n  [NormedAddCommGroup E\u2082]\n  [NormedAddCommGroup E\u2083]\n  [MeasurableSpace E] [BorelSpace E]\n  [MeasurableSpace E\u2083] [BorelSpace E\u2083]\n  {f : \u03b1 \u2192 E\u2081} {t : \u211d}\n\n/-! ## Results about the particular choice of scale\n\n    The proof of the real interpolation theorem will estimate\n    `distribution (trunc f A(t)) t` and `distribution (trunc_compl f A(t)) t` for a\n    function `A`. The function `A` can be given a closed-form expression that works for\n    _all_ cases in the real interpolation theorem, because of the computation rules available\n    for elements in `\u211d\u22650\u221e` that avoid the need for a limiting procedure, e.g. `\u22a4\u207b\u00b9 = 0`.\n\n    The function `A` will be of the form `A(t) = (t / d) ^ \u03c3` for particular choices of `d` and\n    `\u03c3`. This section contatins results about the scale `d`.\n-/\nnamespace ChoiceScale\n\ndef d := ENNReal.toReal\n    (C\u2080 ^ (q\u2081\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal)) * (eLpNorm f p \u03bc ^ p.toReal) ^\n      (p\u2080\u207b\u00b9.toReal * q\u2081\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal)) /\n    (C\u2081 ^ (q\u2080\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal)) * (eLpNorm f p \u03bc ^ p.toReal) ^\n      (p\u2081\u207b\u00b9.toReal * q\u2080\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal))))\n\nlemma d_pos_aux\u2080 (hF : eLpNorm f p \u03bc \u2208 Ioo 0 \u22a4) :\n    0 < eLpNorm f p \u03bc ^ p.toReal :=\n  ENNReal.rpow_pos (pos_of_Ioo hF) (ne_top_of_Ioo hF)\n\nlemma d_ne_top_aux\u2080 {b : \u211d} {F : \u211d\u22650\u221e} (hF : F \u2208 Ioo 0 \u22a4) : F ^ b \u2260 \u22a4 :=\n  rpow_ne_top' (ne_zero_of_Ioo hF) (ne_top_of_Ioo hF)\n\nlemma d_ne_zero_aux\u2080 {b : \u211d} (hF : eLpNorm f p \u03bc \u2208 Ioo 0 \u22a4) :\n    (eLpNorm f p \u03bc ^ p.toReal) ^ b \u2260 0 :=\n  (ENNReal.rpow_pos (d_pos_aux\u2080 hF) (d_ne_top_aux\u2080 hF)).ne'\n\nlemma d_ne_zero_aux\u2081 {C : \u211d\u22650} {c : \u211d} (hC : C > 0) :\n    (ENNReal.ofNNReal C) ^ c \u2260 0 :=\n  (ENNReal.rpow_pos (ENNReal.coe_pos.mpr hC) coe_ne_top).ne'\n\nlemma d_ne_zero_aux\u2082 {C : \u211d\u22650} {b c : \u211d} (hC : C > 0)\n    (hF : eLpNorm f p \u03bc \u2208 Ioo 0 \u22a4) :\n    C ^ c * (eLpNorm f p \u03bc ^ p.toReal) ^ b \u2260 0 :=\n  (ENNReal.mul_pos (d_ne_zero_aux\u2081 hC) (d_ne_zero_aux\u2080 hF)).ne'\n\nlemma d_ne_top_aux\u2081 {C : \u211d\u22650} {c : \u211d} (hC : C > 0) :\n    (ENNReal.ofNNReal C) ^ c \u2260 \u22a4 :=\n  rpow_ne_top' (ENNReal.coe_pos.mpr hC).ne' coe_ne_top\n\nlemma d_ne_top_aux\u2082 {b : \u211d} (hF : eLpNorm f p \u03bc \u2208 Ioo 0 \u22a4) :\n    (eLpNorm f p \u03bc ^ p.toReal) ^ b \u2260 \u22a4 :=\n  rpow_ne_top' (d_pos_aux\u2080 hF).ne' (d_ne_top_aux\u2080 hF)\n\nlemma d_ne_top_aux\u2083 {C : \u211d\u22650} {b c : \u211d} (hC : C > 0)\n    (hF : eLpNorm f p \u03bc \u2208 Ioo 0 \u22a4) :\n    C ^ c * (eLpNorm f p \u03bc ^ p.toReal) ^ b \u2260 \u22a4 :=\n  mul_ne_top (d_ne_top_aux\u2081 hC) (d_ne_top_aux\u2082 hF)\n\nlemma d_ne_zero_aux\u2083 {b\u2080 c\u2080 b\u2081 c\u2081 : \u211d} (hC\u2080 : C\u2080 > 0) (hC\u2081 : C\u2081 > 0) (hF : eLpNorm f p \u03bc \u2208 Ioo 0 \u22a4) :\n    (C\u2080 ^ c\u2080 * (eLpNorm f p \u03bc ^ p.toReal) ^ b\u2080) /\n    (C\u2081 ^ c\u2081 * (eLpNorm f p \u03bc ^ p.toReal) ^ b\u2081) \u2260 0 := by\n  refine ENNReal.div_ne_zero.mpr \u27e8?_, ?_\u27e9\n  \u00b7 apply d_ne_zero_aux\u2082 <;> try assumption\n  \u00b7 apply d_ne_top_aux\u2083 <;> try assumption\n\nlemma d_ne_top_aux\u2084 {b\u2080 c\u2080 b\u2081 c\u2081 : \u211d} (hC\u2080 : C\u2080 > 0) (hC\u2081 : C\u2081 > 0) (hF : eLpNorm f p \u03bc \u2208 Ioo 0 \u22a4) :\n    (C\u2080 ^ c\u2080 * (eLpNorm f p \u03bc ^ p.toReal) ^ b\u2080) /\n    (C\u2081 ^ c\u2081 * (eLpNorm f p \u03bc ^ p.toReal) ^ b\u2081) \u2260 \u22a4 := by\n  refine (div_lt_top ?_ ?_).ne\n  \u00b7 apply d_ne_top_aux\u2083 <;> assumption\n  \u00b7 apply d_ne_zero_aux\u2082 <;> assumption\n\n-- If the `p`-norm of `f` is positive and finite, then `d` is positive\nlemma d_pos (hC\u2080 : C\u2080 > 0) (hC\u2081 : C\u2081 > 0) (hF : eLpNorm f p \u03bc \u2208 Ioo 0 \u22a4) :\n  @d \u03b1 E\u2081 m p p\u2080 q\u2080 p\u2081 q\u2081 C\u2080 C\u2081 \u03bc _ f > 0 :=\ntoReal_pos (d_ne_zero_aux\u2083 hC\u2080 hC\u2081 hF) (d_ne_top_aux\u2084 hC\u2080 hC\u2081 hF)\n\nlemma d_eq_top\u2080 (hp\u2080 : p\u2080 > 0) (hq\u2081 : q\u2081 > 0) (hp\u2080' : p\u2080 \u2260 \u22a4) (hq\u2080' : q\u2080 = \u22a4) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081):\n    @d \u03b1 E\u2081 m p p\u2080 q\u2080 p\u2081 q\u2081 C\u2080 C\u2081 \u03bc _ f =\n    (\u2191C\u2080 ^ p\u2080.toReal * eLpNorm f p \u03bc ^ p.toReal).toReal ^ p\u2080.toReal\u207b\u00b9 := by\n  unfold d\n  rw [hq\u2080']\n  simp only [inv_top, zero_toReal, sub_zero, zero_div, ENNReal.rpow_zero, mul_zero, mul_one,\n    div_one]\n  rw [mul_div_cancel_right\u2080]\n  \u00b7 rw [div_eq_mul_inv, mul_inv_cancel\u2080, ENNReal.rpow_one]\n    \u00b7 rw [toReal_rpow, ENNReal.mul_rpow_of_nonneg]\n      \u00b7 rw [ENNReal.rpow_rpow_inv, toReal_inv]\n        exact (exp_toReal_pos hp\u2080 hp\u2080').ne'\n      \u00b7 positivity\n    \u00b7 exact (inv_toReal_pos_of_ne_top hq\u2081 ((hq\u2080' \u25b8 hq\u2080q\u2081).symm)).ne'\n  \u00b7 exact (inv_toReal_pos_of_ne_top hq\u2081 ((hq\u2080' \u25b8 hq\u2080q\u2081).symm)).ne'\n\nlemma d_eq_top\u2081 (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hp\u2081' : p\u2081 \u2260 \u22a4) (hq\u2081' : q\u2081 = \u22a4)\n    (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081) (hC\u2081 : C\u2081 > 0) :\n    @d \u03b1 E\u2081 m p p\u2080 q\u2080 p\u2081 q\u2081 C\u2080 C\u2081 \u03bc _ f =\n    (\u2191C\u2081 ^ p\u2081.toReal * eLpNorm f p \u03bc ^ p.toReal).toReal ^ p\u2081.toReal\u207b\u00b9 := by\n  unfold d\n  rw [hq\u2081']\n  simp only [inv_top, zero_toReal, zero_sub, zero_div, ENNReal.rpow_zero, mul_zero, mul_one,\n    one_div]\n  rw [div_neg, div_neg]\n  rw [mul_div_cancel_right\u2080]\n  \u00b7 rw [div_eq_mul_inv, mul_inv_cancel\u2080, ENNReal.rpow_neg_one]\n    \u00b7 rw [toReal_rpow, ENNReal.mul_rpow_of_nonneg]\n      \u00b7 rw [ENNReal.rpow_rpow_inv, \u2190 toReal_inv, ENNReal.mul_inv, inv_inv]\n        \u00b7 rw [\u2190 ENNReal.rpow_neg_one, \u2190 ENNReal.rpow_mul, toReal_inv, mul_neg, mul_one, neg_neg,\n            toReal_mul, coe_toReal]\n        \u00b7 left; exact ENNReal.inv_ne_zero.mpr coe_ne_top\n        \u00b7 left; exact inv_ne_top.mpr <| (ENNReal.coe_pos.mpr hC\u2081).ne'\n        \u00b7 exact (exp_toReal_pos hp\u2081 hp\u2081').ne'\n      \u00b7 positivity\n    \u00b7 exact (inv_toReal_pos_of_ne_top hq\u2080 (hq\u2081' \u25b8 hq\u2080q\u2081)).ne'\n  \u00b7 exact (inv_toReal_pos_of_ne_top hq\u2080 (hq\u2081' \u25b8 hq\u2080q\u2081)).ne'\n\nlemma d_eq_top_of_eq (hC\u2081 : C\u2081 > 0) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hq\u2080' : q\u2080 \u2260 \u22a4)\n(hp\u2080': p\u2080 \u2260 \u22a4) (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 = p\u2081) (hpp\u2080: p = p\u2080) (hq\u2081' : q\u2081 = \u22a4) :\n    @d \u03b1 E\u2081 m p p\u2080 q\u2080 p\u2081 q\u2081 C\u2080 C\u2081 \u03bc _ f = (C\u2081 * eLpNorm f p \u03bc).toReal := by\n  rw [d_eq_top\u2081, \u2190 hp\u2080p\u2081, hpp\u2080] <;> try assumption\n  on_goal 1 => rw [toReal_rpow, ENNReal.mul_rpow_of_nonneg, ENNReal.rpow_rpow_inv, ENNReal.rpow_rpow_inv]\n  \u00b7 exact exp_toReal_ne_zero' hp\u2080 hp\u2080'\n  \u00b7 exact exp_toReal_ne_zero' hp\u2080 hp\u2080'\n  \u00b7 positivity\n  \u00b7 exact hp\u2080p\u2081 \u25b8 hp\u2080'\n  \u00b7 exact hq\u2081' \u25b8 hq\u2080'\n\nlemma d_eq_top_top (hq\u2080 : q\u2080 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081) (hp\u2081' : p\u2081 = \u22a4) (hq\u2081' : q\u2081 = \u22a4) :\n    @d \u03b1 E\u2081 m p p\u2080 q\u2080 p\u2081 q\u2081 C\u2080 C\u2081 \u03bc _ f = C\u2081 := by\n  unfold d\n  rw [hp\u2081', hq\u2081']\n  simp only [inv_top, zero_toReal, zero_sub, zero_div, ENNReal.rpow_zero, mul_zero, mul_one,\n    zero_mul, one_div]\n  rw [div_neg, div_eq_mul_inv, mul_inv_cancel\u2080]\n  \u00b7 rw [ENNReal.rpow_neg, ENNReal.rpow_one, inv_inv, coe_toReal]\n  \u00b7 exact (toReal_pos (ENNReal.inv_ne_zero.mpr (hq\u2081' \u25b8 hq\u2080q\u2081)) (ENNReal.inv_ne_top.mpr hq\u2080.ne')).ne'\n\n/-- The particular choice of scaled power function that works in the proof of the\n    real interpolation theorem. -/\ndef spf_ch (ht : t \u2208 Ioo 0 1) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081) (hp\u2080 : 0 < p\u2080) (hq\u2080 : 0 < q\u2080)\n    (hp\u2081 : 0 < p\u2081) (hq\u2081 : 0 < q\u2081) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hC\u2080 : C\u2080 > 0) (hC\u2081 : C\u2081 > 0)\n    (hF : eLpNorm f p \u03bc \u2208 Ioo 0 \u22a4) :\n    ScaledPowerFunction where\n  \u03c3 := @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t\n  d := @d _ E\u2081 _ p p\u2080 q\u2080 p\u2081 q\u2081 C\u2080 C\u2081 \u03bc _ f\n  h\u03c3 := lt_or_gt_of_ne <| Ne.symm <| (\u03b6_ne_zero ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081 hq\u2080q\u2081)\n  hd := d_pos hC\u2080 hC\u2081 hF\n\nend ChoiceScale\n\nend\n\nnoncomputable section\n\nopen NNReal ENNReal MeasureTheory Set\n\nvariable {\u03b1 \u03b1' E E\u2081 E\u2082 E\u2083 : Type*} {m : MeasurableSpace \u03b1} {m' : MeasurableSpace \u03b1'}\n  {p p' q p\u2080 q\u2080 p\u2081 q\u2081: \u211d\u22650\u221e} {c : \u211d\u22650}\n  {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b1'}\n  {f : \u03b1 \u2192 E\u2081} {t : \u211d}\n\n/-! ## Some tools for measure theory computations\n    A collection of small lemmas to help with integral manipulations.\n-/\nnamespace MeasureTheory\n\n-- TODO: change lhs and rhs?\n-- TODO: rewrite the condition in filter form?\nlemma lintegral_double_restrict_set {A B: Set \u03b1} {f : \u03b1 \u2192 \u211d\u22650\u221e} (hA : MeasurableSet A)\n  (hB : MeasurableSet B) (hf : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, x \u2208 A \\ B \u2192 f x \u2264 0) :\n    \u222b\u207b x in A, f x \u2202\u03bc = \u222b\u207b x in A \u2229 B, f x \u2202\u03bc := by\n  have h\u2080 := setLIntegral_mono_ae' (MeasurableSet.diff hA hB) hf; rw [lintegral_zero] at h\u2080\n  rw [\u2190 lintegral_inter_add_diff (hB := hB), nonpos_iff_eq_zero.mp h\u2080, add_zero]\n\nlemma measure_preserving_shift {a : \u211d} :\n    MeasurePreserving (fun x \u21a6 a + x) volume volume :=\n  measurePreserving_add_left volume a\n\nlemma measureable_embedding_shift {a : \u211d} : MeasurableEmbedding (fun x \u21a6 a + x) :=\n  measurableEmbedding_addLeft a\n\nlemma measure_preserving_scaling {a : \u211d} (ha : a \u2260 0) :\n    MeasurePreserving (fun x \u21a6 a * x) volume ((ENNReal.ofReal |a\u207b\u00b9|) \u2022 volume) :=\n  { measurable := measurable_const_mul a, map_eq := Real.map_volume_mul_left ha }\n\nlemma lintegral_shift (f : \u211d \u2192 ENNReal) {a : \u211d} :\n    \u222b\u207b x : \u211d, (f (x + a)) = \u222b\u207b x : \u211d, f x :=\n  lintegral_add_right_eq_self f a\n\nlemma lintegral_shift' (f : \u211d \u2192 ENNReal) {a : \u211d} {s : Set \u211d}:\n    \u222b\u207b (x : \u211d) in (fun z : \u211d \u21a6 z + a)\u207b\u00b9' s, f (x + a) = \u222b\u207b (x : \u211d) in s, f x := by\n  rw [(measurePreserving_add_right volume a).setLIntegral_comp_preimage_emb\n    (measurableEmbedding_addRight a)]\n\nlemma lintegral_add_right_Ioi (f : \u211d \u2192 ENNReal) {a b : \u211d} :\n    \u222b\u207b (x : \u211d) in Ioi (b - a), f (x + a) = \u222b\u207b (x : \u211d) in Ioi b, f x := by\n  nth_rewrite 2 [\u2190 lintegral_shift' (a := a)]\n  simp\n\nlemma lintegral_scale_constant (f: \u211d \u2192 ENNReal) {a : \u211d} (h : a \u2260 0):\n    \u222b\u207b x : \u211d, f (a*x) = ENNReal.ofReal |a\u207b\u00b9| * \u222b\u207b x, f x := by\n  rw [\u2190 @lintegral_smul_measure, MeasurePreserving.lintegral_comp_emb]\n  \u00b7 exact measure_preserving_scaling h\n  \u00b7 exact measurableEmbedding_mulLeft\u2080 h\n\nlemma lintegral_scale_constant_preimage (f: \u211d \u2192 ENNReal) {a : \u211d} (h : a \u2260 0)\n    {s : Set \u211d}:\n    \u222b\u207b x : \u211d in (fun z : \u211d \u21a6 a * z)\u207b\u00b9' s, f (a*x) = ENNReal.ofReal |a\u207b\u00b9| * \u222b\u207b x : \u211d in s, f x\n    := by\n  rw [\u2190 lintegral_smul_measure,\n    (measure_preserving_scaling h).setLIntegral_comp_preimage_emb (measurableEmbedding_mulLeft\u2080 h),\n    Measure.restrict_smul]\n\nlemma lintegral_scale_constant_halfspace (f: \u211d \u2192 ENNReal) {a : \u211d} (h : 0 < a) :\n    \u222b\u207b x : \u211d in Ioi 0, f (a*x) = ENNReal.ofReal |a\u207b\u00b9| * \u222b\u207b x : \u211d in Ioi 0, f x := by\n  rw [\u2190 lintegral_scale_constant_preimage f h.ne']\n  have h\u2080 : (fun z \u21a6 a * z) \u207b\u00b9' Ioi 0 = Ioi 0 := by\n    ext x\n    simp [mul_pos_iff_of_pos_left h]\n  rw [h\u2080]\n\nlemma lintegral_scale_constant_halfspace' {f: \u211d \u2192 ENNReal} {a : \u211d} (h : 0 < a) :\n    ENNReal.ofReal |a| * \u222b\u207b x : \u211d in Ioi 0, f (a*x) = \u222b\u207b x : \u211d in Ioi 0, f x := by\n  rw [lintegral_scale_constant_halfspace f h, \u2190 mul_assoc, \u2190 ofReal_mul (abs_nonneg a),\n    abs_inv, mul_inv_cancel\u2080 (abs_ne_zero.mpr h.ne')]\n  simp\n\nlemma lintegral_scale_constant' {f: \u211d \u2192 ENNReal} {a : \u211d} (h : a \u2260 0):\n    ENNReal.ofReal |a| * \u222b\u207b x : \u211d, f (a*x) = \u222b\u207b x, f x := by\n  rw [lintegral_scale_constant f h, \u2190 mul_assoc, \u2190 ofReal_mul (abs_nonneg a), abs_inv,\n      mul_inv_cancel\u2080 (abs_ne_zero.mpr h)]\n  simp\n\n-- local convenience function\nlemma lintegral_rw_aux {g : \u211d \u2192 \u211d\u22650\u221e} {f\u2081 f\u2082 : \u211d \u2192 \u211d\u22650\u221e} {A : Set \u211d}\n    (heq : f\u2081 =\u1da0[ae (volume.restrict A)] f\u2082) :\n    \u222b\u207b s in A, g s * f\u2081 s = \u222b\u207b s in A, g s * f\u2082 s :=\n  (lintegral_rw\u2082 (Filter.EventuallyEq.refl (ae (volume.restrict A)) g) heq HMul.hMul)\n\nlemma power_aux {p q : \u211d} :\n    (fun s \u21a6 ENNReal.ofReal s ^ (p + q)) =\u1da0[ae (volume.restrict (Ioi (0 : \u211d)))]\n    (fun s \u21a6 ENNReal.ofReal s ^ p * ENNReal.ofReal s ^ q ) := by\n  filter_upwards [self_mem_ae_restrict measurableSet_Ioi] with s (hs : s > 0)\n  rw [ofReal_rpow_of_pos hs, ofReal_rpow_of_pos hs, ofReal_rpow_of_pos hs,\n    \u2190 ofReal_mul (by positivity), \u2190 Real.rpow_add hs]\n\nlemma power_aux_2 {p q : \u211d} :\n    (fun s \u21a6 ENNReal.ofReal (s ^ (p + q))) =\u1da0[ae (volume.restrict (Ioi (0 : \u211d)))]\n    (fun s \u21a6 ENNReal.ofReal (s ^ p) * ENNReal.ofReal (s ^ q) ) := by\n  filter_upwards [self_mem_ae_restrict measurableSet_Ioi] with s (hs : s > 0)\n  rw [\u2190 ofReal_mul (by positivity), \u2190 Real.rpow_add hs]\n\nlemma ofReal_rpow_of_pos_aux {p : \u211d} :\n    (fun s \u21a6 ENNReal.ofReal s ^ p) =\u1da0[ae (volume.restrict (Ioi (0 : \u211d)))]\n    (fun s \u21a6 ENNReal.ofReal (s ^ p)) := by\n  filter_upwards [self_mem_ae_restrict measurableSet_Ioi]\n    with s (hs : s > 0) using ofReal_rpow_of_pos hs\n\nlemma extract_constant_double_integral_rpow {f : \u211d \u2192 \u211d \u2192 \u211d\u22650\u221e} {q : \u211d} (hq : q \u2265 0) {a : \u211d\u22650\u221e}\n    (ha : a \u2260 \u22a4):\n    \u222b\u207b (s : \u211d) in Ioi 0, (\u222b\u207b (t : \u211d) in Ioi 0, a * f s t) ^ q =\n    a ^ q * \u222b\u207b (s : \u211d) in Ioi 0, (\u222b\u207b (t : \u211d) in Ioi 0, f s t) ^ q := by\n  simp_rw [\u2190 lintegral_const_mul' _ _ (rpow_ne_top_of_nonneg hq ha),\n    \u2190 ENNReal.mul_rpow_of_nonneg _ _ hq, lintegral_const_mul' a _ ha]\n\nlemma ofReal_rpow_rpow_aux {p : \u211d} :\n    (fun s \u21a6 ENNReal.ofReal s ^ p) =\u1da0[ae (volume.restrict (Ioi (0 : \u211d)))]\n    (fun s \u21a6 ENNReal.ofReal (s ^ p)) := by\n  filter_upwards [self_mem_ae_restrict measurableSet_Ioi]\n    with s (hs : s > 0) using ofReal_rpow_of_pos hs\n\nlemma lintegral_rpow_of_gt {\u03b2 \u03b3 : \u211d} (h\u03b2 : \u03b2 > 0) (h\u03b3 : \u03b3 > -1) :\n    \u222b\u207b s : \u211d in Ioo 0 \u03b2, ENNReal.ofReal (s ^ \u03b3) =\n    ENNReal.ofReal (\u03b2 ^ (\u03b3 + 1) / (\u03b3 + 1)) := by\n  have h\u03b32 : \u03b3 + 1 > 0 := by linarith\n  rw [setLIntegral_congr Ioo_ae_eq_Ioc, \u2190 ofReal_integral_eq_lintegral_ofReal]\n  \u00b7 rw [\u2190 intervalIntegral.integral_of_le h\u03b2.le, integral_rpow]\n    \u00b7 rw [Real.zero_rpow h\u03b32.ne', sub_zero]\n    \u00b7 exact Or.inl h\u03b3\n  \u00b7 apply (@intervalIntegral.intervalIntegrable_rpow' 0 \u03b2 \u03b3 ?_).1\n    linarith\n  \u00b7 filter_upwards [self_mem_ae_restrict measurableSet_Ioc]\n      with s hs using Real.rpow_nonneg hs.1.le \u03b3\n\nend MeasureTheory\n\nend\n\nnoncomputable section\n\nopen NNReal ENNReal MeasureTheory Set ComputationsInterpolatedExponents\n\nvariable {\u03b1 \u03b1' E E\u2081 E\u2082 E\u2083 : Type*} {m : MeasurableSpace \u03b1} {m' : MeasurableSpace \u03b1'}\n  {p p' q p\u2080 q\u2080 p\u2081 q\u2081: \u211d\u22650\u221e} {c : \u211d\u22650} {a : \u211d}\n  {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b1'}\n  {f : \u03b1 \u2192 E\u2081} {t : \u211d}\n\n/-! ## Results about truncations of a function\n-/\nnamespace MeasureTheory\n\n/-- The `t`-truncation of a function `f`. -/\ndef trunc [NormedAddCommGroup E\u2081] (f : \u03b1 \u2192 E\u2081) (t : \u211d) (x : \u03b1) : E\u2081 := if \u2016f x\u2016 \u2264 t then f x else 0\n\n/-- The complement of a `t`-truncation of a function `f`. -/\ndef trunc_compl [NormedAddCommGroup E\u2081] (f : \u03b1 \u2192 E\u2081) (t : \u211d) : \u03b1 \u2192 E\u2081 := f - trunc f t\n\nlemma trunc_compl_eq [NormedAddCommGroup E\u2081] {a : \u211d} {f : \u03b1 \u2192 E\u2081} :\n    f - trunc f a = fun x \u21a6 if a < \u2016f x\u2016 then f x else 0 := by\n  ext x\n  simp_rw [Pi.sub_apply, trunc, \u2190 not_lt, ite_not, apply_ite (f x - \u00b7), sub_zero, sub_self]\n\n/-- A function to deal with truncations and complement of truncations in one go. -/\ndef trnc [NormedAddCommGroup E\u2081] (j : Bool) (f : \u03b1 \u2192 E\u2081) (t : \u211d)  : \u03b1 \u2192 E\u2081 :=\n  match j with\n  | false => f - trunc f t\n  | true => trunc f t\n\n/-- A function is the complement if its truncation and the complement of the truncation. -/\nlemma trunc_buildup [NormedAddCommGroup E\u2081] : f = trunc f t + trunc_compl f t := by\n  ext x; simp [trunc, trunc_compl]\n\n/-- If the truncation parameter is non-positive, the truncation vanishes. -/\nlemma trunc_of_nonpos {f : \u03b1 \u2192 E\u2081} {a : \u211d} [NormedAddCommGroup E\u2081] (ha : a \u2264 0) :\n    trunc f a = 0 := by\n  unfold trunc\n  ext x\n  split_ifs\n  \u00b7 dsimp only [Pi.zero_apply]\n    apply norm_eq_zero.mp\n    \u00b7 have : \u2016f x\u2016 \u2265 0 := norm_nonneg _\n      linarith []\n  \u00b7 rfl\n\n/-- If the truncation parameter is non-positive, the complement of the truncation is the\n    function itself. -/\nlemma trunc_compl_of_nonpos {f : \u03b1 \u2192 E\u2081} {a : \u211d} [NormedAddCommGroup E\u2081] (ha : a \u2264 0) :\n    trunc_compl f a = f := by\n  unfold trunc_compl\n  rw [trunc_compl_eq]\n  ext x\n  dsimp only [Pi.zero_apply]\n  split_ifs\n  \u00b7 rfl\n  \u00b7 apply (norm_eq_zero.mp ?_).symm\n    have : \u2016f x\u2016 \u2265 0 := norm_nonneg _\n    linarith\n\n/-! ## Measurability properties of truncations -/\n\n-- @[measurability, fun_prop]\n-- lemma _root_.Measurable.trunc [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081]\n--     (hf : Measurable f) : Measurable (trunc f t) := by\n--   refine hf.ite (measurableSet_le ?_ ?_) measurable_const <;> fun_prop\n\n-- @[measurability, fun_prop]\n-- lemma _root_.Measurable.trunc_compl [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081]\n--     (hf : Measurable f) :\n--     Measurable (f - trunc f t) := by\n--   rw [trunc_compl_eq]\n--   apply Measurable.ite ?_ hf measurable_const\n--   exact measurableSet_lt measurable_const hf.norm\n\n@[measurability]\nprotected lemma StronglyMeasurable.trunc [NormedAddCommGroup E\u2081]\n    (hf : StronglyMeasurable f) : StronglyMeasurable (trunc f t) :=\n  StronglyMeasurable.ite (measurableSet_le hf.norm stronglyMeasurable_const) hf\n    stronglyMeasurable_const\n\n@[measurability]\nprotected lemma StronglyMeasurable.trunc_compl [NormedAddCommGroup E\u2081]\n    (hf : StronglyMeasurable f) : StronglyMeasurable (f - trunc f t) := by\n  rw [trunc_compl_eq]\n  exact hf.ite (measurableSet_lt stronglyMeasurable_const hf.norm) stronglyMeasurable_const\n\n-- @[measurability, fun_prop]\n-- lemma aemeasurable_trunc [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081]\n--     (hf : AEMeasurable f \u03bc) :\n--     AEMeasurable (trunc f t) \u03bc := by\n--   rcases hf with \u27e8g, \u27e8wg1, wg2\u27e9\u27e9\n--   exists (trunc g t)\n--   constructor\n--   \u00b7 apply wg1.indicator (s := {x | \u2016g x\u2016 \u2264 t}) (measurableSet_le wg1.norm measurable_const)\n--   apply measure_mono_null ?_ wg2\n--   intro x\n--   contrapose\n--   simp only [mem_compl_iff, mem_setOf_eq, not_not]\n--   intro h\u2082\n--   unfold trunc\n--   rewrite [h\u2082]\n--   rfl\n\n-- @[measurability, fun_prop]\n-- lemma aeMeasurable_trunc_compl [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081]\n--     (hf : AEMeasurable f \u03bc) :\n--     AEMeasurable (trunc_compl f t) \u03bc := by\n--   rcases hf with \u27e8g, \u27e8wg1, wg2\u27e9\u27e9\n--   exists (trunc_compl g t)\n--   constructor\n--   \u00b7 unfold trunc_compl\n--     rw [trunc_compl_eq]\n--     exact wg1.indicator (s := {x | t < \u2016g x\u2016}) (measurableSet_lt measurable_const wg1.norm)\n--   \u00b7 apply measure_mono_null ?_ wg2\n--     intro x\n--     contrapose\n--     simp only [mem_compl_iff, mem_setOf_eq, not_not]\n--     intro f_eq_g; unfold trunc_compl; unfold trunc; dsimp only [Pi.sub_apply]; rw [f_eq_g]\n\n@[measurability]\nlemma aestronglyMeasurable_trunc [NormedAddCommGroup E\u2081]\n    (hf : AEStronglyMeasurable f \u03bc) :\n    AEStronglyMeasurable (trunc f t) \u03bc := by\n  rcases hf with \u27e8g, \u27e8wg1, wg2\u27e9\u27e9\n  exists (trunc g t)\n  constructor\n  \u00b7 exact wg1.indicator (s := {x | \u2016g x\u2016 \u2264 t}) (wg1.norm.measurableSet_le stronglyMeasurable_const)\n  \u00b7 refine measure_mono_null (fun x \u21a6 ?_) wg2\n    contrapose\n    simp only [mem_compl_iff, mem_setOf_eq, not_not]\n    intro h\u2082\n    unfold trunc\n    rw [h\u2082]\n\n@[measurability]\nlemma aestronglyMeasurable_trunc_compl [NormedAddCommGroup E\u2081]\n    (hf : AEStronglyMeasurable f \u03bc) :\n    AEStronglyMeasurable (f - trunc f t) \u03bc := by\n  rcases hf with \u27e8g, \u27e8wg1, wg2\u27e9\u27e9\n  exists (g - trunc g t)\n  constructor\n  \u00b7 rw [trunc_compl_eq]\n    exact wg1.indicator (s := {x | t < \u2016g x\u2016}) (stronglyMeasurable_const.measurableSet_lt wg1.norm)\n  \u00b7 apply measure_mono_null ?_ wg2\n    intro x\n    contrapose\n    simp only [mem_compl_iff, mem_setOf_eq, not_not]\n    intro h\u2082\n    rw [trunc_compl_eq, trunc_compl_eq]\n    simp only\n    rw [h\u2082]\n\n@[measurability]\nlemma aestronglyMeasurable_trnc {j : Bool} [NormedAddCommGroup E\u2081]\n    (hf : AEStronglyMeasurable f \u03bc) :\n    AEStronglyMeasurable (trnc j f t) \u03bc := by\n  rcases j\n  \u00b7 exact aestronglyMeasurable_trunc_compl hf\n  \u00b7 exact aestronglyMeasurable_trunc hf\n\nlemma trunc_le {f : \u03b1 \u2192 E\u2081} {a : \u211d} [NormedAddCommGroup E\u2081] (x : \u03b1) :\n    \u2016trunc f a x\u2016 \u2264 max 0 a := by\n  unfold trunc\n  split_ifs with h\n  \u00b7 rcases (lt_or_le a 0) with a_lt_0 | _\n    \u00b7 exact Trans.trans (Trans.trans h a_lt_0.le) (le_max_left 0 a)\n    \u00b7 exact Trans.trans h (le_max_right 0 a)\n  \u00b7 simp\n\n/-- A small lemma that is helpful for rewriting -/\nlemma coe_coe_eq_ofReal (a : \u211d) : ofNNReal a.toNNReal = ENNReal.ofReal a := by rfl\n\nlemma trunc_eLpNormEssSup_le {f : \u03b1 \u2192 E\u2081} {a : \u211d} [NormedAddCommGroup E\u2081] :\n    eLpNormEssSup (trunc f a) \u03bc \u2264 ENNReal.ofReal (max 0 a) := by\n  refine essSup_le_of_ae_le _ (ae_of_all _ fun x \u21a6 ?_)\n  simp only [enorm_eq_nnnorm, \u2190 norm_toNNReal, coe_coe_eq_ofReal]\n  exact ofReal_le_ofReal (trunc_le x)\n\nlemma trunc_mono {f : \u03b1 \u2192 E\u2081} {a b : \u211d} [NormedAddCommGroup E\u2081]\n    (hab : a \u2264 b) {x : \u03b1} : \u2016trunc f a x\u2016 \u2264 \u2016trunc f b x\u2016 := by\n  unfold trunc\n  split_ifs\n  \u00b7 rfl\n  \u00b7 linarith\n  \u00b7 rw [norm_zero]; exact norm_nonneg _\n  \u00b7 exact le_refl _\n\n/-- The norm of the truncation is monotone in the truncation parameter -/\nlemma norm_trunc_mono {f : \u03b1 \u2192 E\u2081} [NormedAddCommGroup E\u2081] :\n    Monotone fun s \u21a6 eLpNorm (trunc f s) p \u03bc :=\n  fun _a _b hab \u21a6 eLpNorm_mono fun _x \u21a6 trunc_mono hab\n\nlemma trunc_buildup_norm {f : \u03b1 \u2192 E\u2081} {a : \u211d} {x : \u03b1} [NormedAddCommGroup E\u2081] :\n    \u2016trunc f a x\u2016 + \u2016(f - trunc f a) x\u2016 = \u2016f x\u2016 := by\n  simp only [trunc, Pi.sub_apply]; split_ifs with h <;> simp\n\nlemma trunc_le_func {f : \u03b1 \u2192 E\u2081} {a : \u211d} {x : \u03b1} [NormedAddCommGroup E\u2081] :\n    \u2016trunc f a x\u2016 \u2264 \u2016f x\u2016 := by\n  unfold trunc; split_ifs <;> simp\n\nlemma trunc_compl_le_func {f : \u03b1 \u2192 E\u2081} {a : \u211d} {x : \u03b1} [NormedAddCommGroup E\u2081] :\n    \u2016(f - trunc f a) x\u2016 \u2264 \u2016f x\u2016 := by\n  rw [trunc_compl_eq]; dsimp only; split_ifs <;> simp\n\nlemma trunc_compl_anti {f : \u03b1 \u2192 E\u2081} {a b : \u211d} {x : \u03b1} [NormedAddCommGroup E\u2081] (hab : a \u2264 b) :\n    \u2016(f - trunc f b) x\u2016 \u2264 \u2016(f - trunc f a) x\u2016 := by\n  have obs : \u2016trunc f a x\u2016 + \u2016(f - trunc f a) x\u2016 = \u2016trunc f b x\u2016 + \u2016(f - trunc f b) x\u2016 := by\n    rw [trunc_buildup_norm, trunc_buildup_norm]\n  have : \u2016trunc f a x\u2016 \u2264 \u2016trunc f b x\u2016 := trunc_mono hab\n  linarith\n\n/-- The norm of the complement of the truncation is antitone in the truncation parameter -/\nlemma norm_trunc_compl_anti {f : \u03b1 \u2192 E\u2081} [NormedAddCommGroup E\u2081] :\n    Antitone (fun s \u21a6 eLpNorm (f - trunc f s) p \u03bc) :=\n  fun _a _b hab \u21a6 eLpNorm_mono (fun _ \u21a6 trunc_compl_anti hab)\n\n/-- The norm of the truncation is meaurable in the truncation parameter -/\n@[measurability, fun_prop]\nlemma norm_trunc_measurable [NormedAddCommGroup E\u2081] :\n    Measurable (fun s \u21a6 eLpNorm (trunc f s) p \u03bc) :=\n  norm_trunc_mono.measurable\n\n/-- The norm of the complement of the truncation is measurable in the truncation parameter -/\n@[measurability, fun_prop]\nlemma norm_trunc_compl_measurable [NormedAddCommGroup E\u2081] :\n    Measurable (fun s \u21a6 eLpNorm (f - trunc f s) p \u03bc) :=\n  norm_trunc_compl_anti.measurable\n\nlemma trnc_le_func {j : Bool} {f : \u03b1 \u2192 E\u2081} {a : \u211d} {x : \u03b1} [NormedAddCommGroup E\u2081] :\n    \u2016trnc j f a x\u2016 \u2264 \u2016f x\u2016 := by\n  unfold trnc trunc\n  rcases j\n  \u00b7 dsimp only [Pi.sub_apply]\n    split_ifs <;> simp\n  \u00b7 dsimp only\n    split_ifs <;> simp\n\n-- /-- ## Distribution functions of truncations -/\n\n-- /-- The `t`-truncation of `f : \u03b1 \u2192\u2098[\u03bc] E`. -/\n-- def AEEqFun.trunc (f : \u03b1 \u2192\u2098[\u03bc] E) (t : \u211d) : \u03b1 \u2192\u2098[\u03bc] E :=\n--   AEEqFun.mk (trunc f t) (aestronglyMeasurable_trunc f.aestronglyMeasurable)\n\n-- /-- A set of measurable functions is closed under truncation. -/\n-- class IsClosedUnderTruncation (U : Set (\u03b1 \u2192\u2098[\u03bc] E)) : Prop where\n--   trunc_mem {f : \u03b1 \u2192\u2098[\u03bc] E} (hf : f \u2208 U) (t : \u211d) : f.trunc t \u2208 U\n\n/-! ## Truncations and L-p spaces -/\n\nlemma power_estimate {a b t \u03b3 : \u211d} (h\u03b3 : \u03b3 > 0) (ht\u03b3 : \u03b3 \u2264 t) (hab : a \u2264 b) :\n    (t / \u03b3) ^ a \u2264 (t / \u03b3) ^ b := by\n  gcongr\n  exact (one_le_div h\u03b3).mpr ht\u03b3\n\nlemma power_estimate' {a b t \u03b3 : \u211d} (ht : t > 0) (ht\u03b3 : t \u2264 \u03b3) (hab: a \u2264 b) :\n    (t / \u03b3) ^ b \u2264 (t / \u03b3) ^ a := by\n  have \u03b3_pos : \u03b3 > 0 := lt_of_lt_of_le ht ht\u03b3\n  exact Real.rpow_le_rpow_of_exponent_ge (div_pos ht (\u03b3_pos)) (div_le_one_of_le\u2080 ht\u03b3 \u03b3_pos.le) hab\n\nlemma rpow_le_rpow_of_exponent_le_base_le {a b t \u03b3 : \u211d} (ht : t > 0) (ht\u03b3 : t \u2264 \u03b3) (hab : a \u2264 b) :\n    ENNReal.ofReal (t ^ b) \u2264 ENNReal.ofReal (t ^ a) * ENNReal.ofReal (\u03b3 ^ (b - a)) := by\n  rw [mul_comm]\n  have \u03b3_pos : 0 < \u03b3 := lt_of_lt_of_le ht ht\u03b3\n  rw [Real.rpow_sub \u03b3_pos]\n  refine (ENNReal.mul_le_mul_left (a := ENNReal.ofReal (\u03b3 ^ (-b) )) ?_ coe_ne_top).mp ?_\n  \u00b7 exact (ofReal_pos.mpr (Real.rpow_pos_of_pos \u03b3_pos (-b))).ne'\n  \u00b7 rw [\u2190 ofReal_mul, \u2190 mul_assoc, \u2190 ofReal_mul, \u2190 mul_div_assoc, \u2190 Real.rpow_add, neg_add_cancel,\n        Real.rpow_zero, \u2190 ofReal_mul, mul_comm] <;> try positivity\n    nth_rw 2 [mul_comm]\n    rw [\u2190 neg_one_mul, Real.rpow_mul, Real.rpow_neg_one, \u2190 Real.mul_rpow] <;> try positivity\n    rw [one_div]\n    nth_rw 2 [\u2190 Real.rpow_neg_one]\n    rw [\u2190 Real.rpow_mul (by positivity)]\n    nth_rw 3 [mul_comm]\n    rw [Real.rpow_mul, Real.rpow_neg_one, \u2190 Real.mul_rpow, \u2190 div_eq_mul_inv] <;> try positivity\n    exact ofReal_le_ofReal (power_estimate' ht ht\u03b3 hab)\n\n-- TODO: there is a lot of overlap between above proof and below\nlemma rpow_le_rpow_of_exponent_le_base_ge {a b t \u03b3 : \u211d} (h\u03b3 : \u03b3 > 0) (ht\u03b3 : \u03b3 \u2264 t) (hab : a \u2264 b) :\n    ENNReal.ofReal (t ^ a) \u2264 ENNReal.ofReal (t ^ b) * ENNReal.ofReal (\u03b3 ^ (a - b)) := by\n  rw [mul_comm]\n  have t_pos : 0 < t := gt_of_ge_of_gt ht\u03b3 h\u03b3\n  rw [Real.rpow_sub h\u03b3]\n  refine (ENNReal.mul_le_mul_left (a := ENNReal.ofReal (\u03b3 ^ (-a) )) ?_ coe_ne_top).mp ?_\n  \u00b7 exact (ofReal_pos.mpr (Real.rpow_pos_of_pos h\u03b3 (-a))).ne'\n  \u00b7 rw [\u2190 ofReal_mul, \u2190 mul_assoc, \u2190 ofReal_mul, \u2190 mul_div_assoc, \u2190 Real.rpow_add, neg_add_cancel,\n        Real.rpow_zero, \u2190 ofReal_mul, mul_comm] <;> try positivity\n    nth_rw 2 [mul_comm]\n    rw [\u2190 neg_one_mul, Real.rpow_mul, Real.rpow_neg_one, \u2190 Real.mul_rpow] <;> try positivity\n    rw [one_div]\n    nth_rw 2 [\u2190 Real.rpow_neg_one]\n    rw [\u2190 Real.rpow_mul (by positivity)]\n    nth_rw 3 [mul_comm]\n    rw [Real.rpow_mul, Real.rpow_neg_one, \u2190 Real.mul_rpow, \u2190 div_eq_mul_inv] <;> try positivity\n    exact ofReal_le_ofReal (Real.rpow_le_rpow_of_exponent_le ((one_le_div h\u03b3).mpr ht\u03b3) hab)\n\nlemma trunc_preserves_Lp {p : \u211d\u22650\u221e} {a : \u211d} [NormedAddCommGroup E\u2081]\n    (hf : Mem\u2112p f p \u03bc) :\n    Mem\u2112p (trunc f a) p \u03bc := by\n  refine \u27e8aestronglyMeasurable_trunc hf.1, lt_of_le_of_lt (eLpNorm_mono_ae (ae_of_all _ ?_)) hf.2\u27e9\n  intro x\n  unfold trunc\n  split_ifs with is_fx_le_a <;> simp\n\n-- lemma snorm_trunc_compl_le {p : \u211d\u22650\u221e} {a : \u211d} [NormedAddCommGroup E\u2081] :\n--     eLpNorm (f - trunc f a) p \u03bc \u2264 eLpNorm f p \u03bc :=\n--   eLpNorm_mono (fun _ \u21a6 trunc_compl_le_func)\n\nlemma trunc_compl_preserves_Lp {p : \u211d\u22650\u221e} {a : \u211d} [NormedAddCommGroup E\u2081] (hf : Mem\u2112p f p \u03bc) :\n    Mem\u2112p (f - trunc f a) p \u03bc :=\n  Mem\u2112p.sub hf (trunc_preserves_Lp hf)\n\nlemma estimate_eLpNorm_trunc_compl {p q : \u211d\u22650\u221e} [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081]\n    [BorelSpace E\u2081] (hp : p \u2260 \u22a4) (hpq : q \u2208 Ioo 0 p) (hf : AEMeasurable f \u03bc) (ha : a > 0) :\n    eLpNorm ((f - trunc f a)) q \u03bc ^ q.toReal \u2264\n    ENNReal.ofReal (a ^ (q.toReal - p.toReal)) *\n    eLpNorm f p \u03bc ^ p.toReal := by\n  unfold eLpNorm eLpNorm'\n  have q_ne_top: q \u2260 \u22a4 := hpq.2.ne_top\n  have p_ne_zero : p \u2260 0 := (lt_trans hpq.1 hpq.2).ne'\n  have q_ne_zero : q \u2260 0 := hpq.1.ne'\n  have q_toReal_pos : q.toReal > 0 := exp_toReal_pos hpq.1 q_ne_top\n  split_ifs\n  \u00b7 contradiction\n  \u00b7 calc\n    _ = \u222b\u207b x : \u03b1 in {x | a < \u2016f x\u2016}, \u2016(f - trunc f a) x\u2016\u2091 ^ q.toReal \u2202\u03bc := by\n      rw [one_div, ENNReal.rpow_inv_rpow]\n      \u00b7 apply (setLIntegral_eq_of_support_subset _).symm\n        unfold Function.support\n        intro x\n        rw [trunc_compl_eq]\n        dsimp only [Pi.sub_apply, mem_setOf_eq]\n        split_ifs with is_a_lt_fx\n        \u00b7 exact fun _ => is_a_lt_fx\n        \u00b7 contrapose; intro _; simpa [enorm_eq_nnnorm]\n      \u00b7 exact exp_toReal_ne_zero' hpq.1 q_ne_top\n    _ \u2264 \u222b\u207b x : \u03b1 in {x | a < \u2016f x\u2016}, \u2016f x\u2016\u2091 ^ q.toReal \u2202\u03bc := by\n      apply lintegral_mono_ae\n      apply ae_of_all\n      intro x\n      gcongr\n      rw [enorm_eq_nnnorm, \u2190 norm_toNNReal, enorm_eq_nnnorm, \u2190 norm_toNNReal]\n      simp only [Pi.sub_apply, ENNReal.coe_le_coe, norm_nonneg, Real.toNNReal_le_toNNReal_iff]\n      apply trnc_le_func (j := \u22a5)\n    _ \u2264 ENNReal.ofReal (a ^ (q.toReal - p.toReal)) * \u222b\u207b x : \u03b1 in {x | a < \u2016f x\u2016},\n        \u2016f x\u2016\u2091 ^ p.toReal \u2202\u03bc := by\n      rw [\u2190 lintegral_const_mul']; swap; \u00b7 exact coe_ne_top\n      simp only [enorm_eq_nnnorm]\n      apply setLIntegral_mono_ae (AEMeasurable.restrict (by fun_prop))\n      \u00b7 apply ae_of_all\n        intro x (hx : a < \u2016f x\u2016)\n        rw [mul_comm]\n        rw [\u2190 enorm_eq_nnnorm, \u2190 ofReal_norm_eq_enorm (f x), ENNReal.ofReal_rpow_of_nonneg,\n          ENNReal.ofReal_rpow_of_nonneg]\n          <;> try positivity\n        exact rpow_le_rpow_of_exponent_le_base_ge ha hx.le (toReal_mono hp hpq.2.le)\n    _ \u2264 ENNReal.ofReal (a ^ (q.toReal - p.toReal)) * \u222b\u207b x : \u03b1,\n        \u2191\u2016f x\u2016\u208a ^ p.toReal \u2202\u03bc := by\n      gcongr\n      exact setLIntegral_le_lintegral _ _\n    _ = _ := by\n      rw [one_div, ENNReal.rpow_inv_rpow]\n      \u00b7 simp only [enorm_eq_nnnorm]\n      \u00b7 exact exp_toReal_ne_zero' (lt_trans hpq.1 hpq.2) hp\n\nlemma estimate_eLpNorm_trunc {p q : \u211d\u22650\u221e}\n    [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081]\n    (hq : q \u2260 \u22a4)\n    (hpq : p \u2208 Ioo 0 q) (hf : AEMeasurable f \u03bc) :\n    eLpNorm (trunc f a) q \u03bc ^ q.toReal \u2264\n    ENNReal.ofReal (a ^ (q.toReal - p.toReal)) * eLpNorm f p \u03bc ^ p.toReal := by\n  unfold eLpNorm eLpNorm'\n  have p_ne_top : p \u2260 \u22a4 := hpq.2.ne_top\n  have : p \u2260 0 := hpq.1.ne'\n  have : q \u2260 0 := (lt_trans hpq.1 hpq.2).ne'\n  split_ifs\n  \u00b7 contradiction\n  \u00b7 calc\n    _ = \u222b\u207b (x : \u03b1) in {x | 0 < \u2016f x\u2016 \u2227 \u2016f x\u2016 \u2264 a}, \u2191\u2016trunc f a x\u2016\u208a ^ q.toReal \u2202\u03bc := by\n      rw [one_div, ENNReal.rpow_inv_rpow]\n      \u00b7 apply Eq.symm\n        apply setLIntegral_eq_of_support_subset\n        unfold Function.support\n        intro x\n        dsimp only [Pi.sub_apply, mem_setOf_eq]\n        unfold trunc\n        split_ifs with is_fx_le_a\n        \u00b7 intro fx_rpow_ne_zero\n          refine \u27e8?_, is_fx_le_a\u27e9\n          contrapose! fx_rpow_ne_zero\n          rw [norm_le_zero_iff.mp fx_rpow_ne_zero]\n          simpa using toReal_pos this hq\n        \u00b7 contrapose; intro _; simpa using toReal_pos this hq\n      \u00b7 exact exp_toReal_ne_zero' (lt_trans hpq.1 hpq.2) hq\n    _ \u2264 \u222b\u207b (x : \u03b1) in {x | 0 < \u2016f x\u2016 \u2227 \u2016f x\u2016 \u2264 a}, \u2016f x\u2016\u208a ^ q.toReal \u2202 \u03bc := by\n      apply lintegral_mono_ae\n      apply ae_of_all\n      intro x\n      gcongr\n      rw [\u2190 norm_toNNReal, \u2190 norm_toNNReal]\n      exact Real.toNNReal_mono (trnc_le_func (j := \u22a4))\n    _ \u2264 ENNReal.ofReal (a ^ (q.toReal - p.toReal)) *\n        \u222b\u207b (x : \u03b1) in {x | 0 < \u2016f x\u2016 \u2227 \u2016f x\u2016 \u2264 a}, \u2016f x\u2016\u208a ^ p.toReal \u2202 \u03bc := by\n      rw [\u2190 lintegral_const_mul']\n      \u00b7 apply setLIntegral_mono_ae (AEMeasurable.restrict (by fun_prop))\n        \u00b7 apply ae_of_all\n          intro x hx\n          rw [mul_comm]\n          rw [\u2190 enorm_eq_nnnorm, \u2190 ofReal_norm_eq_enorm (f x), ENNReal.ofReal_rpow_of_nonneg,\n            ENNReal.ofReal_rpow_of_nonneg] <;> try positivity\n          apply rpow_le_rpow_of_exponent_le_base_le hx.1 hx.2\n          exact toReal_mono hq hpq.2.le\n      \u00b7 exact coe_ne_top\n    _ \u2264 _ := by\n      gcongr\n      rw [one_div, ENNReal.rpow_inv_rpow]\n      \u00b7 exact setLIntegral_le_lintegral _ _\n      \u00b7 exact exp_toReal_ne_zero' hpq.1 p_ne_top\n\n/-- If `f` is in `Lp`, the truncation is element of `Lq` for `q > p`. -/\nlemma trunc_Lp_Lq_higher [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081]\n    (hpq : p \u2208 Ioo 0 q) (hf : Mem\u2112p f p \u03bc) :\n    Mem\u2112p (trnc \u22a4 f a) q \u03bc := by\n  refine \u27e8aestronglyMeasurable_trnc hf.1, ?_\u27e9\n  rcases (eq_or_ne q \u22a4) with q_eq_top | q_ne_top\n  \u00b7 rw [q_eq_top, eLpNorm_exponent_top]\n    exact Trans.trans trunc_eLpNormEssSup_le coe_lt_top\n  \u00b7 rw [\u2190 rpow_lt_top_iff_of_pos (toReal_pos (lt_trans hpq.1 hpq.2).ne' q_ne_top)]\n    apply lt_of_le_of_lt (estimate_eLpNorm_trunc q_ne_top hpq hf.1.aemeasurable)\n    apply mul_lt_top coe_lt_top\n    refine (rpow_lt_top_iff_of_pos ?_).mpr hf.2\n    exact toReal_pos hpq.1.ne' hpq.2.ne_top\n\n/-- If `f` is in `Lp`, the complement of the truncation is in `Lq` for `q < p`. -/\nlemma trunc_compl_Lp_Lq_lower [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081]\n    (hp : p \u2260 \u22a4)\n    (hpq : q \u2208 Ioo 0 p) (ha : a > 0) (hf : Mem\u2112p f p \u03bc) :\n    Mem\u2112p (trnc \u22a5 f a) q \u03bc := by\n  refine \u27e8aestronglyMeasurable_trnc hf.1, ?_\u27e9\n  have : q.toReal > 0 := toReal_pos hpq.left.ne' hpq.right.ne_top\n  refine (rpow_lt_top_iff_of_pos this).mp ?_\n  refine lt_of_le_of_lt\n    (estimate_eLpNorm_trunc_compl hp hpq hf.1.aemeasurable ha) ?_\n  apply mul_lt_top coe_lt_top\n  refine (rpow_lt_top_iff_of_pos ?_).mpr hf.2\n  exact toReal_pos (lt_trans hpq.left hpq.right).ne' hp\n\nend MeasureTheory\n\nend\n\nnoncomputable section\n\nopen NNReal ENNReal MeasureTheory Set\n\nvariable {\u03b1 \u03b1' E E\u2081 E\u2082 E\u2083 : Type*} {m : MeasurableSpace \u03b1} {m' : MeasurableSpace \u03b1'}\n  {p p' q p\u2080 q\u2080 p\u2081 q\u2081: \u211d\u22650\u221e}\n  {C\u2080 C\u2081 : \u211d\u22650} {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b1'}\n  {a : \u211d}-- truncation parameter\n  [NormedAddCommGroup E]\n  [NormedAddCommGroup E\u2081]\n  [NormedAddCommGroup E\u2082]\n  [MeasurableSpace E] [BorelSpace E]\n  {f : \u03b1 \u2192 E\u2081} {t : \u211d}\n\n/-! ## Some results about the integrals of truncations\n\n-/\nnamespace MeasureTheory\n\ndef res (j : Bool) (\u03b2 : \u211d) : Set \u211d :=\n  if j then Ioo (0 : \u211d) \u03b2 else Ioi \u03b2\n\nlemma measurableSet_res {j : Bool} {\u03b2 : \u211d} : MeasurableSet (res j \u03b2) := by\n  unfold res\n  split\n  \u00b7 exact measurableSet_Ioo\n  \u00b7 exact measurableSet_Ioi\n\nlemma res_subset_Ioi {j : Bool} {\u03b2 : \u211d} (h\u03b2 : \u03b2 > 0) : res j \u03b2 \u2286 Ioi 0 := by\n  unfold res\n  split\n  \u00b7 exact Ioo_subset_Ioi_self\n  \u00b7 simp only [Ioi, setOf_subset_setOf]\n    intro s hs\n    linarith\n\ninstance decidableMemRes {j : Bool} {\u03b2 : \u211d} : Decidable (t \u2208 res j \u03b2) := by\n  exact Classical.propDecidable (t \u2208 res j \u03b2)\n\ndef res' (j : Bool) (\u03b2 : \u211d) : Set \u211d :=\n  if j then Ioc (0 : \u211d) \u03b2 else Ici \u03b2\n\nlemma res'comp (j : Bool) (\u03b2 : \u211d) (h\u03b2 : \u03b2 > 0) :\n    Ioi (0 : \u211d) \\ res' j \u03b2 = res (\u00acj) \u03b2 := by\n  unfold res' res\n  split_ifs with h\u2080 h\u2081 h\u2082\n  \u00b7 rw [h\u2080] at h\u2081; simp at h\u2081\n  \u00b7 ext x\n    simp only [mem_diff, mem_Ioi, mem_Ioc, not_and, not_le]\n    constructor\n    \u00b7 tauto\n    \u00b7 intro h\n      exact \u27e8lt_trans h\u03b2 h, fun _ \u21a6 h\u27e9\n  \u00b7 ext x\n    simp only [Ioi_diff_Ici, mem_Ioo]\n  \u00b7 have : j = false := eq_false_of_ne_true h\u2080\n    rw [this] at h\u2082\n    simp at h\u2082\n\nlemma measurableSet_res' {j : Bool} {\u03b2 : \u211d} : MeasurableSet (res' j \u03b2) := by\n  unfold res'\n  measurability\n\nlemma res'subset_Ioi {j : Bool} {\u03b2 : \u211d} (h\u03b2 : \u03b2 > 0) : res' j \u03b2 \u2286 Ioi 0 := by\n  unfold res'\n  split\n  \u00b7 exact Ioc_subset_Ioi_self\n  \u00b7 exact Ici_subset_Ioi.mpr h\u03b2\n\nlemma lintegral_trunc_mul\u2080 {g : \u211d \u2192 \u211d\u22650\u221e} {j : Bool} {x : \u03b1} {tc : ToneCouple} {p : \u211d} (hp : p > 0)\n    (hfx : \u2016f x\u2016\u208a > 0) :\n    \u222b\u207b s : \u211d in Ioi 0, (g s) * \u2016trnc j f (tc.ton s) x\u2016\u208a ^ p =\n    \u222b\u207b s : \u211d in res' (xor j tc.mon) (tc.inv \u2016f x\u2016), (g s) * \u2016trnc j f (tc.ton s) x\u2016\u208a ^ p := by\n  rw [lintegral_double_restrict_set (B := res' (xor j tc.mon) (tc.inv \u2016f x\u2016))\n      measurableSet_Ioi measurableSet_res']\n  \u00b7 have : Ioi 0 \u2229 res' (xor j tc.mon) (tc.inv \u2016f x\u2016) = res' (xor j tc.mon) (tc.inv \u2016f x\u2016) := by\n      refine inter_eq_self_of_subset_right (res'subset_Ioi (tc.ran_inv (\u2016f x\u2016) hfx))\n    rw [this]\n  \u00b7 apply ae_of_all\n    rw [res'comp]\n    \u00b7 intro s\n      unfold res trnc trunc\n      have mon_pf := tc.inv_pf\n      split_ifs at mon_pf with mon\n      \u00b7 rw [mon]\n        rcases j\n        \u00b7 simp only [Bool.bne_true, Bool.not_false, not_true_eq_false, decide_false,\n          Bool.false_eq_true, \u2193reduceIte, Pi.sub_apply]\n          intro (hs : s > tc.inv \u2016f x\u2016)\n          split_ifs with h\n          \u00b7 simp [hp]\n          \u00b7 have := (mon_pf s (lt_trans (tc.ran_inv \u2016f x\u2016 hfx) hs) (\u2016f x\u2016) hfx).2.mpr hs\n            contrapose! h; linarith\n        \u00b7 simp only [bne_self_eq_false, Bool.false_eq_true, not_false_eq_true, decide_true]\n          intro hs\n          split_ifs with h\n          \u00b7 have := (mon_pf s hs.1 (\u2016f x\u2016) hfx).1.mpr hs.2\n            linarith\n          \u00b7 simp [hp]\n      \u00b7 rw [Bool.not_eq_true] at mon\n        rw [mon]\n        rcases j\n        \u00b7 simp only [bne_self_eq_false, Bool.false_eq_true, not_false_eq_true, decide_true,\n          \u2193reduceIte, Pi.sub_apply]\n          intro hs\n          split_ifs with h\n          \u00b7 simp [hp]\n          \u00b7 have := (mon_pf s hs.1 (\u2016f x\u2016) hfx).2.mpr hs.2\n            linarith\n        \u00b7 simp only [Bool.bne_false, not_true_eq_false, decide_false, Bool.false_eq_true, \u2193reduceIte]\n          intro (hs : tc.inv \u2016f x\u2016 < s)\n          have := (mon_pf s (lt_trans (tc.ran_inv \u2016f x\u2016 hfx) hs) (\u2016f x\u2016) hfx).1.mpr hs\n          split_ifs with h\n          \u00b7 linarith\n          \u00b7 simp [hp]\n    \u00b7 exact tc.ran_inv \u2016f x\u2016 hfx\n\nlemma lintegral_trunc_mul\u2081 {g : \u211d \u2192 \u211d\u22650\u221e} {j : Bool} {x : \u03b1} {p : \u211d} {tc : ToneCouple} :\n    \u222b\u207b s : \u211d in res' (xor j tc.mon) (tc.inv \u2016f x\u2016), (g s) * \u2016trnc j f (tc.ton s) x\u2016\u208a ^ p =\n    \u222b\u207b s : \u211d in res (xor j tc.mon) (tc.inv \u2016f x\u2016), (g s) * \u2016trnc j f (tc.ton s) x\u2016\u208a ^ p := by\n  apply setLIntegral_congr\n  unfold res res'\n  split_ifs\n  \u00b7 exact Ioo_ae_eq_Ioc.symm\n  \u00b7 exact Ioi_ae_eq_Ici.symm\n\nlemma lintegral_trunc_mul\u2082 {g : \u211d \u2192 \u211d\u22650\u221e} {j : Bool} {x : \u03b1} {p : \u211d} {tc : ToneCouple}\n    (hfx : \u2016f x\u2016 > 0) :\n    \u222b\u207b s : \u211d in res (xor j tc.mon) (tc.inv \u2016f x\u2016), (g s) * \u2016trnc j f (tc.ton s) x\u2016\u208a ^ p =\n    \u222b\u207b s : \u211d in res (xor j tc.mon) (tc.inv \u2016f x\u2016), (g s) * \u2016f x\u2016\u208a ^ p := by\n  apply setLIntegral_congr_fun measurableSet_res\n  \u00b7 apply ae_of_all\n    unfold res trnc trunc\n    have mon_pf := tc.inv_pf\n    split_ifs at mon_pf with mon\n    \u00b7 rw [mon]\n      rcases j\n      \u00b7 simp only [Bool.bne_true, Bool.not_false, \u2193reduceIte, Pi.sub_apply]\n        intro s hs\n        split_ifs with h\n        \u00b7 have := (mon_pf s hs.1 (\u2016f x\u2016) hfx).1.mpr hs.2\n          contrapose! h; linarith\n        \u00b7 simp\n      \u00b7 simp only [bne_self_eq_false, Bool.false_eq_true, \u2193reduceIte]\n        intro s (hs : s > tc.inv \u2016f x\u2016)\n        split_ifs with h\n        \u00b7 rfl\n        \u00b7 have := (mon_pf s (lt_trans (tc.ran_inv \u2016f x\u2016 hfx) hs) (\u2016f x\u2016) hfx).2.mpr hs\n          contrapose! h; linarith\n    \u00b7 rw [Bool.not_eq_true] at mon\n      rw [mon]\n      rcases j\n      \u00b7 simp only [bne_self_eq_false, Bool.false_eq_true, \u2193reduceIte, Pi.sub_apply]\n        intro s (hs : tc.inv \u2016f x\u2016 < s)\n        have := (mon_pf s (lt_trans (tc.ran_inv \u2016f x\u2016 hfx) hs) (\u2016f x\u2016) hfx).1.mpr hs\n        split_ifs with h\n        \u00b7 linarith\n        \u00b7 simp\n      \u00b7 simp only [Bool.bne_false, \u2193reduceIte]\n        intro s hs\n        have := (mon_pf s hs.1 (\u2016f x\u2016) hfx).2.mpr hs.2\n        split_ifs with h\n        \u00b7 rfl\n        \u00b7 linarith\n\nlemma lintegral_trunc_mul {g : \u211d \u2192 \u211d\u22650\u221e} {j : Bool} {x : \u03b1} {tc : ToneCouple} {p : \u211d}\n    (hp : p > 0) (hfx : \u2016f x\u2016\u208a > 0) :\n    \u222b\u207b s : \u211d in Ioi 0, (g s) * \u2016trnc j f (tc.ton s) x\u2016\u208a ^ p =\n    (\u222b\u207b s : \u211d in res (xor j tc.mon) (tc.inv \u2016f x\u2016), (g s)) * \u2016f x\u2016\u208a ^ p := by\n  rw [lintegral_trunc_mul\u2080 hp hfx, lintegral_trunc_mul\u2081, lintegral_trunc_mul\u2082 hfx,\n    lintegral_mul_const']\n  exact ((rpow_lt_top_iff_of_pos hp).mpr coe_lt_top).ne\n\n\n/-! Extract expressions for the lower Lebesgue integral of power functions -/\n\nlemma lintegral_rpow_of_gt_abs {\u03b2 \u03b3 : \u211d} (h\u03b2 : \u03b2 > 0) (h\u03b3 : \u03b3 > -1) :\n    \u222b\u207b s : \u211d in Ioo 0 \u03b2, ENNReal.ofReal (s ^ \u03b3) =\n    ENNReal.ofReal (\u03b2 ^ (\u03b3 + 1) / |\u03b3 + 1|) := by\n  have h\u03b32 : \u03b3 + 1 > 0 := by linarith\n  rw [abs_of_nonneg h\u03b32.le]\n  exact lintegral_rpow_of_gt h\u03b2 h\u03b3\n\n-- TODO: treat symmetrically to Ioo case?\nlemma lintegral_Ioi_rpow_of_lt_abs {\u03b2 \u03c3 : \u211d} (h\u03b2 : \u03b2 > 0) (h\u03c3 : \u03c3 < -1):\n    \u222b\u207b s : \u211d in Ioi \u03b2, ENNReal.ofReal (s ^ \u03c3) =\n    ENNReal.ofReal (\u03b2 ^ (\u03c3 + 1) / |\u03c3 + 1|) := by\n  have h\u03c32 : \u03c3 + 1 < 0 := by linarith\n  rw [abs_of_neg h\u03c32, \u2190 ofReal_integral_eq_lintegral_ofReal]\n  \u00b7 rw [integral_Ioi_rpow_of_lt h\u03c3 h\u03b2, div_neg, neg_div]\n  \u00b7 apply integrableOn_Ioi_rpow_of_lt h\u03c3 h\u03b2\n  \u00b7 filter_upwards [self_mem_ae_restrict measurableSet_Ioi]\n    exact fun s hs \u21a6 Real.rpow_nonneg (lt_trans h\u03b2 hs).le \u03c3\n\nlemma lintegral_rpow_abs {j : Bool} {tc : ToneCouple} {\u03b3 : \u211d} {t : \u211d}\n    (h\u03b3 : if xor j tc.mon then \u03b3 > -1 else \u03b3 < -1 ) (ht : t > 0) :\n  \u222b\u207b s : \u211d in res (xor j tc.mon) (tc.inv t), ENNReal.ofReal s ^ \u03b3 =\n    ENNReal.ofReal ((tc.inv t) ^ (\u03b3 + 1) / |\u03b3 + 1|) := by\n  rw [\u2190 lintegral_congr_ae (Filter.mp_mem (self_mem_ae_restrict measurableSet_res)\n      (Filter.univ_mem'\n      (fun s hs \u21a6 (ofReal_rpow_of_pos (res_subset_Ioi (tc.ran_inv t ht) hs)).symm)))]\n  unfold res\n  split at h\u03b3 <;> rename_i xor_split\n  \u00b7 rw [xor_split]\n    simp only [\u2193reduceIte]\n    rw [lintegral_rpow_of_gt_abs (tc.ran_inv t ht) h\u03b3]\n  \u00b7 rw [eq_false_of_ne_true xor_split]\n    simp only [Bool.false_eq_true, \u2193reduceIte]\n    rw [lintegral_Ioi_rpow_of_lt_abs (tc.ran_inv t ht) h\u03b3]\n\nlemma value_lintegral_res\u2080 {j : Bool} {\u03b2 \u03b3 : \u211d} {tc : ToneCouple} (h\u03b2 : \u03b2 > 0)\n    (h\u03b3 : if xor j tc.mon then \u03b3 > -1 else \u03b3 < -1 ) :\n    \u222b\u207b s : \u211d in res (xor j tc.mon) \u03b2, ENNReal.ofReal (s ^ \u03b3) =\n    ENNReal.ofReal (\u03b2 ^ (\u03b3 + 1) / |\u03b3 + 1|) := by\n  unfold res\n  split_ifs at h\u03b3 with h\n  \u00b7 rw [h]\n    simp only [\u2193reduceIte]\n    rw [lintegral_rpow_of_gt_abs h\u03b2 h\u03b3]\n  \u00b7 have : xor j tc.mon = false := by\n      contrapose! h; exact eq_true_of_ne_false h\n    rw [this]\n    simp only [Bool.false_eq_true, \u2193reduceIte]\n    rw [lintegral_Ioi_rpow_of_lt_abs h\u03b2 h\u03b3]\n\nlemma value_lintegral_res\u2081 {t \u03b3 p': \u211d} {spf : ScaledPowerFunction} (ht : t > 0) :\n    ENNReal.ofReal (((spf_to_tc spf).inv t) ^ (\u03b3 + 1) / |\u03b3 + 1| ) * ENNReal.ofReal (t ^ p') =\n    ENNReal.ofReal (spf.d ^ (\u03b3 + 1) * t ^ (spf.\u03c3\u207b\u00b9 * (\u03b3 + 1) + p') / |\u03b3 + 1|) := by\n  have := spf.hd\n  unfold spf_to_tc\n  dsimp only\n  rw [\u2190 ENNReal.ofReal_mul, \u2190 mul_div_right_comm, Real.mul_rpow, mul_assoc, \u2190 Real.rpow_mul,\n      \u2190 Real.rpow_add] <;> positivity\n\nend MeasureTheory\n\nend\n\nnoncomputable section\n\nopen NNReal ENNReal MeasureTheory Set ComputationsInterpolatedExponents\n    ComputationsChoiceExponent\n\nvariable {\u03b1 \u03b1' \u03b5 E E\u2081 E\u2082 E\u2083 : Type*} {m : MeasurableSpace \u03b1} {m' : MeasurableSpace \u03b1'}\n  {p p' q p\u2080 q\u2080 p\u2081 q\u2081: \u211d\u22650\u221e}\n  {C\u2080 C\u2081 : \u211d\u22650} {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b1'}\n  {a : \u211d}\n  {f : \u03b1 \u2192 E\u2081} {t : \u211d}\n\n/-! ## Minkowski's integral inequality -/\nnamespace MeasureTheory\n\nlemma rpow_add_of_pos (a : \u211d\u22650\u221e) (c d : \u211d) (hc : c > 0) (hd : d > 0):\n    a ^ (c + d) = a ^ c * a ^ d := by\n  have hcd : c + d  > 0 := by linarith\n  rcases (eq_or_ne a 0) with a_eq_zero | a_ne_zero\n  \u00b7 rw [a_eq_zero, zero_rpow_of_pos hcd, zero_rpow_of_pos hc, zero_rpow_of_pos hd, mul_zero]\n  \u00b7 rcases (eq_or_ne a \u22a4) with a_eq_top | a_ne_top\n    \u00b7 rw [a_eq_top, top_rpow_of_pos hcd, top_rpow_of_pos hc, top_rpow_of_pos hd, top_mul_top]\n    \u00b7 rw [ENNReal.rpow_add c d a_ne_zero a_ne_top]\n\nlemma eq_of_le_of_le (a b : \u211d\u22650\u221e) (hab : a \u2264 b) (hab': b \u2264 a) : a = b := by\n  rcases (eq_or_ne a b) with a_eq_b | a_ne_b\n  \u00b7 exact a_eq_b\n  \u00b7 rcases lt_or_gt_of_ne a_ne_b with a_lt_b | b_lt_a\n    \u00b7 contrapose! a_lt_b; exact hab'\n    \u00b7 contrapose! b_lt_a; exact hab\n\ndef trunc_cut (f : \u03b1 \u2192 \u211d\u22650\u221e) (\u03bc : Measure \u03b1) [SigmaFinite \u03bc] :=\n  fun n : \u2115 \u21a6 indicator (spanningSets \u03bc n) (fun x \u21a6 min (f x) n)\n\nlemma trunc_cut_mono {\u03bc : Measure \u03b1} [SigmaFinite \u03bc] {f : \u03b1 \u2192 \u211d\u22650\u221e} :\n    \u2200 x : \u03b1, Monotone (fun n \u21a6 trunc_cut f \u03bc n x) := by\n  intro x m n hmn; simp only [trunc_cut, indicator]\n  split_ifs with is_fx_le_m is_fx_le_n\n  \u00b7 refine min_le_min_left (f x) (Nat.cast_le.mpr hmn)\n  \u00b7 contrapose! is_fx_le_n\n    apply monotone_spanningSets _ hmn is_fx_le_m\n  \u00b7 exact zero_le _\n  \u00b7 exact zero_le _\n\nlemma trunc_cut_mono\u2080 {\u03bc : Measure \u03b1} [SigmaFinite \u03bc] {f : \u03b1 \u2192 \u211d\u22650\u221e} :\n    Monotone (trunc_cut f \u03bc) := by\n  intro m n hmn x; apply trunc_cut_mono\n  exact hmn\n\nlemma trunc_cut_sup {\u03bc : Measure \u03b1} [SigmaFinite \u03bc] {f : \u03b1 \u2192 \u211d\u22650\u221e} :\n    \u2200 x : \u03b1, \u2a06 n : \u2115, trunc_cut f \u03bc n x = f x := by\n  intro x; refine iSup_eq_of_forall_le_of_forall_lt_exists_gt ?h\u2081 ?h\u2082\n  \u00b7 intro n; unfold trunc_cut indicator\n    split_ifs\n    \u00b7 exact min_le_left (f x) \u2191n\n    \u00b7 exact zero_le _\n  \u00b7 intro w hw\n    unfold trunc_cut\n    have : \u2203 m : \u2115, x \u2208 spanningSets \u03bc m := by\n      have obs := iUnion_spanningSets \u03bc\n      refine mem_iUnion.mp ?_\n      rw [obs]\n      exact trivial\n    rcases this with \u27e8m, wm\u27e9\n    rcases ENNReal.exists_nat_gt hw.ne_top with \u27e8n, wn\u27e9\n    use (m + n)\n    simp only [indicator]\n    split_ifs with is_x_in_Ampn\n    \u00b7 refine lt_min hw ?_\n      calc\n      w < n := wn\n      _ \u2264 m + n := le_add_self\n      _ = _ := (Nat.cast_add m n).symm\n    \u00b7 contrapose! is_x_in_Ampn\n      exact monotone_spanningSets _ (Nat.le_add_right m n) wm\n\nset_option linter.flexible false in\n/-- Characterization of `\u222b\u207b x : \u03b1, f x ^ p \u2202\u03bc` by a duality argument. -/\nlemma representationLp {\u03bc : Measure \u03b1} [SigmaFinite \u03bc] {f : \u03b1 \u2192 \u211d\u22650\u221e}\n    (hf : AEMeasurable f \u03bc) {p q : \u211d} (hp : p > 1) (hq : q \u2265 1)\n    (hpq : p\u207b\u00b9 + q\u207b\u00b9 = 1) :\n    (\u222b\u207b x : \u03b1, (f x) ^ p \u2202\u03bc) ^ (1 / p) =\n    \u2a06 g \u2208 {g' : \u03b1 \u2192 \u211d\u22650\u221e | AEMeasurable g' \u03bc \u2227 \u222b\u207b x : \u03b1, (g' x) ^ q \u2202\u03bc \u2264 1},\n    \u222b\u207b x : \u03b1, (f x) * g x \u2202\u03bc := by\n  let A := spanningSets \u03bc\n  let g := trunc_cut f \u03bc\n  have hpq' : p.IsConjExponent q := Real.IsConjExponent.mk hp hpq\n  have f_mul : \u2200 n : \u2115, (g n) ^ p \u2264 f * (g n) ^ (p - 1) := by\n    intro n x\n    simp only [g, Pi.pow_apply, Pi.mul_apply, trunc_cut, indicator]\n    split_ifs\n    \u00b7 refine le_trans (b := (min (f x) \u2191n) * min (f x) \u2191n ^ (p - 1)) ?_ ?_\n      \u00b7 nth_rewrite 1 [\u2190 add_sub_cancel 1 p]\n        rw [rpow_add_of_pos, ENNReal.rpow_one] <;> try linarith\n      \u00b7 exact mul_le_mul_right' (min_le_left (f x) \u2191n) (min (f x) \u2191n ^ (p - 1))\n    \u00b7 rw [ENNReal.zero_rpow_of_pos] <;> positivity\n  have g_lim : \u2200 x : \u03b1, Filter.Tendsto (fun n \u21a6 g n x) Filter.atTop (nhds (f x)) := by\n    intro x\n    apply tendsto_atTop_isLUB (trunc_cut_mono _)\n    exact isLUB_iff_sSup_eq.mpr (trunc_cut_sup _)\n  have g_sup' : (fun x \u21a6 \u2a06 n : \u2115, (g n x) ^ p) = fun x \u21a6 (f x) ^ p := by\n    ext x\n    apply iSup_eq_of_tendsto\n    \u00b7 intro m n hmn\n      dsimp only\n      gcongr\n      exact trunc_cut_mono _ hmn\n    \u00b7 exact (g_lim x).ennrpow_const p\n  have g_meas (n : \u2115): AEMeasurable (g n) \u03bc := by\n    exact AEMeasurable.indicator (by fun_prop) (measurableSet_spanningSets \u03bc n)\n  have g_fin (n : \u2115): \u222b\u207b (z : \u03b1), g n z ^ p \u2202\u03bc < \u22a4 := by\n    calc\n    _ = \u222b\u207b (z : \u03b1) in A n, g n z ^ p \u2202\u03bc := by\n      unfold g trunc_cut\n      rw [\u2190 lintegral_indicator]; swap; exact measurableSet_spanningSets \u03bc n\n      congr 1\n      ext x\n      dsimp only [indicator]\n      split_ifs\n      \u00b7 rfl\n      \u00b7 simp only [ENNReal.rpow_eq_zero_iff, true_and, zero_ne_top, false_and, or_false]; positivity\n    _ \u2264 \u222b\u207b (_x : \u03b1) in A n, n ^ p \u2202\u03bc := by\n      apply setLIntegral_mono measurable_const\n      \u00b7 intro x hx\n        gcongr\n        unfold g trunc_cut indicator\n        split_ifs\n        \u00b7 exact min_le_right (f x) \u2191n\n        \u00b7 contradiction\n    _ = n ^ p * \u03bc (A n) := setLIntegral_const (A n) (\u2191n ^ p)\n    _ < \u22a4 := mul_lt_top (rpow_lt_top_of_nonneg (by linarith) coe_ne_top)\n              (measure_spanningSets_lt_top \u03bc n)\n  have obs : \u2200 n : \u2115, \u222b\u207b x : \u03b1, (f x) * ((g n x) ^ (p - 1) /\n      (\u222b\u207b y : \u03b1, ((g n y) ^ (p - 1)) ^ q \u2202\u03bc) ^ q\u207b\u00b9) \u2202\u03bc \u2265\n      (\u222b\u207b x : \u03b1, (g n x) ^ p \u2202\u03bc) ^ p\u207b\u00b9 := by\n    intro n\n    rcases eq_or_ne (\u222b\u207b x : \u03b1, (g n x) ^ p \u2202\u03bc) 0  with int_eq_zero | int_ne_zero\n    \u00b7 rw [int_eq_zero, ENNReal.zero_rpow_of_pos]\n      \u00b7 exact zero_le _\n      \u00b7 refine inv_pos_of_pos (by positivity)\n    \u00b7 calc\n      _ = (\u222b\u207b x : \u03b1, (f x) * (g n x) ^ (p - 1) \u2202\u03bc) * (\n          (\u222b\u207b y : \u03b1, ((g n y) ^ (p - 1)) ^ q \u2202\u03bc) ^ q\u207b\u00b9)\u207b\u00b9 := by\n        simp_rw [div_eq_mul_inv, \u2190 mul_assoc]\n        rw [lintegral_mul_const'' _ (by fun_prop)]\n      _ \u2265 (\u222b\u207b x : \u03b1, (g n x) ^ (p) \u2202\u03bc) * ((\u222b\u207b y : \u03b1, ((g n y) ^ (p - 1)) ^ q \u2202\u03bc) ^ q\u207b\u00b9)\u207b\u00b9 := by\n        gcongr\n        apply f_mul\n      _ = (\u222b\u207b x : \u03b1, (g n x) ^ (p) \u2202\u03bc) * ((\u222b\u207b y : \u03b1, (g n y) ^ p \u2202\u03bc) ^ q\u207b\u00b9)\u207b\u00b9 := by\n        congr\n        ext x\n        rw [\u2190 ENNReal.rpow_mul]\n        congr\n        refine Real.IsConjExponent.sub_one_mul_conj ?_\n        exact Real.IsConjExponent.mk hp hpq\n      _ = (\u222b\u207b x : \u03b1, (g n x) ^ p \u2202\u03bc) ^ p\u207b\u00b9 := by\n        rw [\u2190 ENNReal.rpow_neg]\n        nth_rw 1 [\u2190 ENNReal.rpow_one (x := (\u222b\u207b x : \u03b1, (g n x) ^ (p) \u2202\u03bc))]\n        rw [\u2190 ENNReal.rpow_add _ _ int_ne_zero (g_fin n).ne]\n        congr\n        exact add_neg_eq_of_eq_add hpq.symm\n  have int_fg : \u222b\u207b (x : \u03b1), f x ^ p \u2202\u03bc = \u2a06 n : \u2115, \u222b\u207b x : \u03b1, g n x ^ p \u2202\u03bc := by\n    rw [\u2190 g_sup']\n    apply lintegral_iSup' (fun n \u21a6 by fun_prop) (ae_of_all _ fun x m n hmn \u21a6 ?_)\n    dsimp only\n    gcongr\n    exact trunc_cut_mono _ hmn\n  have sup_rpow : (\u2a06 n : \u2115, \u222b\u207b x : \u03b1, g n x ^ p \u2202\u03bc) ^ (1 / p) =\n      \u2a06 n : \u2115, (\u222b\u207b x : \u03b1, g n x ^ p \u2202\u03bc) ^ (1 / p) := by\n    apply Monotone.map_iSup_of_continuousAt (f := fun (x : \u211d\u22650\u221e) \u21a6 x ^ (1 / p))\n    \u00b7 fun_prop\n    \u00b7 apply ENNReal.monotone_rpow_of_nonneg (by positivity)\n    \u00b7 simp; positivity\n  let h := fun n : \u2115 \u21a6 (fun x \u21a6 g n x ^ (p - 1) / (\u222b\u207b y : \u03b1, ((g n y) ^ (p - 1)) ^ q \u2202\u03bc) ^ q\u207b\u00b9)\n  have comp_sup : (\u2a06 n : \u2115, \u222b\u207b (x : \u03b1), f x * h n x \u2202\u03bc) \u2264\n      \u2a06 g \u2208 {g' : \u03b1 \u2192 \u211d\u22650\u221e | AEMeasurable g' \u03bc \u2227 \u222b\u207b (z : \u03b1), (g' z) ^ q \u2202\u03bc \u2264 1},\n      \u222b\u207b (x : \u03b1), f x * g x \u2202\u03bc := by\n    nth_rw 1 [\u2190 iSup_range (f := fun n : \u2115 \u21a6 h n) (g := fun r \u21a6 \u222b\u207b x : \u03b1, f x * r x \u2202\u03bc)]\n    apply iSup_le_iSup_of_subset fun r exists_n \u21a6 ?_\n    rcases exists_n with \u27e8n, wn\u27e9\n    simp_rw [\u2190 wn]\n    unfold h\n    refine \u27e8by fun_prop, ?_\u27e9\n    simp_rw [div_eq_mul_inv]\n    calc\n    _ = \u222b\u207b (z : \u03b1), ((g n z ^ (p - 1)) ^ q) *\n        ((\u222b\u207b (y : \u03b1), (g n y ^ (p - 1)) ^ q \u2202\u03bc) ^ q\u207b\u00b9)\u207b\u00b9 ^ q \u2202\u03bc := by\n      congr 1\n      ext z\n      rw [ENNReal.mul_rpow_of_nonneg]\n      linarith\n    _ = (\u222b\u207b (z : \u03b1), ((g n z ^ (p - 1)) ^ q) \u2202\u03bc) *\n        ((\u222b\u207b (y : \u03b1), (g n y ^ (p - 1)) ^ q \u2202\u03bc) ^ q\u207b\u00b9)\u207b\u00b9 ^ q := by\n      rw [lintegral_mul_const'' _ (by fun_prop)]\n    _ \u2264 _ := by\n      rcases eq_or_ne (\u222b\u207b x : \u03b1, ((g n x) ^ (p - 1)) ^ q \u2202\u03bc) 0 with int_eq_zero | int_ne_zero\n      \u00b7 rw [int_eq_zero]\n        simp\n      \u00b7 rw [ENNReal.inv_rpow, ENNReal.rpow_inv_rpow]\n        apply le_of_eq\n        refine ENNReal.mul_inv_cancel int_ne_zero ?inr.a.ht\n        \u00b7 apply ne_of_lt\n          calc\n          _ = \u222b\u207b (z : \u03b1), g n z ^ p \u2202\u03bc := by\n            congr 1\n            ext z\n            rw [\u2190 ENNReal.rpow_mul]\n            congr\n            exact Real.IsConjExponent.sub_one_mul_conj hpq'\n          _ < \u22a4 := g_fin n\n        \u00b7 linarith\n  apply eq_of_le_of_le\n  \u00b7 rw [int_fg, sup_rpow]\n    calc\n    _ \u2264 \u2a06 n : \u2115, \u222b\u207b x : \u03b1, (f x) * ((g n x) ^ (p - 1) /\n        (\u222b\u207b y : \u03b1, ((g n y) ^ (p - 1)) ^ q \u2202\u03bc) ^ q\u207b\u00b9) \u2202\u03bc := by\n      gcongr\n      rw [one_div]\n      apply obs\n    _ \u2264 _ := comp_sup\n  \u00b7 refine iSup_le fun r \u21a6 iSup_le fun hr \u21a6 ?_\n    calc\n    _ \u2264 (\u222b\u207b x : \u03b1, f x ^ p \u2202\u03bc) ^ (1 / p) * (\u222b\u207b x : \u03b1, r x ^ q \u2202\u03bc) ^ (1 / q) :=\n      ENNReal.lintegral_mul_le_Lp_mul_Lq _ hpq' hf hr.1\n    _ \u2264 (\u222b\u207b x : \u03b1, f x ^ p \u2202\u03bc) ^ (1 / p) * (1) ^ (1 / q) := by\n      gcongr\n      exact hr.2\n    _ = _ := by simp\n\nlemma aemeasurability_prod\u2081 {\u03b1 : Type u_1} {\u03b2 : Type u_3}\n    [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]\n    {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b2} [SFinite \u03bd]\n    \u2983f : \u03b1 \u00d7 \u03b2 \u2192 ENNReal\u2984\n    (hf : AEMeasurable f (\u03bc.prod \u03bd)) :\n    \u2200\u1d50 x : \u03b1 \u2202\u03bc, AEMeasurable (f \u2218 (Prod.mk x)) \u03bd := by\n  rcases hf with \u27e8g, hg\u27e9\n  filter_upwards [Measure.ae_ae_of_ae_prod hg.2] with x h\n  exact \u27e8g \u2218 Prod.mk x, hg.1.comp (measurable_prod_mk_left), h\u27e9\n\nlemma aemeasurability_prod\u2082 {\u03b1 : Type u_1} {\u03b2 : Type u_3}\n    [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]\n    {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b2} [SFinite \u03bd]\n    [SFinite \u03bc] \u2983f : \u03b1 \u00d7 \u03b2 \u2192 ENNReal\u2984\n    (hf : AEMeasurable f (\u03bc.prod \u03bd)) :\n    \u2200\u1d50 y : \u03b2 \u2202\u03bd, AEMeasurable (f \u2218 (fun x \u21a6 Prod.mk x y)) \u03bc := by\n  have : AEMeasurable (f \u2218 Prod.swap) (\u03bd.prod \u03bc) := by\n    refine AEMeasurable.comp_measurable ?_ measurable_swap\n    rw [Measure.prod_swap]\n    assumption\n  exact aemeasurability_prod\u2081 this\n\nlemma aemeasurability_integral_component {\u03b1 : Type u_1} {\u03b2 : Type u_3}\n    [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]\n    {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b2} [SFinite \u03bd]\n    \u2983f : \u03b1 \u00d7 \u03b2 \u2192 ENNReal\u2984\n    (hf : AEMeasurable f (\u03bc.prod \u03bd)) :\n    AEMeasurable (fun x \u21a6 \u222b\u207b (y : \u03b2), f (x, y) \u2202\u03bd) \u03bc := by\n  rcases hf with \u27e8g, hg\u27e9\n  refine \u27e8fun x \u21a6 \u222b\u207b y : \u03b2, g (x, y) \u2202\u03bd, Measurable.lintegral_prod_right hg.1, ?_\u27e9\n  filter_upwards [Measure.ae_ae_of_ae_prod hg.2] with x h using lintegral_congr_ae h\n\n/-- Minkowsi's integral inequality -/\n-- TODO: the condition on `\u03bc` can probably be weakened to `SFinite \u03bc`, by using a limit\n-- argument\nlemma lintegral_lintegral_pow_swap {\u03b1 : Type u_1} {\u03b2 : Type u_3} {p : \u211d} (hp : 1 \u2264 p)\n    [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]\n    {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b2} [SFinite \u03bd]\n    [SigmaFinite \u03bc] \u2983f : \u03b1 \u2192 \u03b2 \u2192 ENNReal\u2984\n    (hf : AEMeasurable (Function.uncurry f) (\u03bc.prod \u03bd)) :\n    (\u222b\u207b (x : \u03b1), (\u222b\u207b (y : \u03b2), f x y \u2202\u03bd) ^ p \u2202\u03bc) ^ p\u207b\u00b9 \u2264\n    \u222b\u207b (y : \u03b2), (\u222b\u207b (x : \u03b1), (f x y) ^ p \u2202\u03bc) ^ p\u207b\u00b9 \u2202\u03bd := by\n  rcases Decidable.lt_or_eq_of_le hp with one_lt_p | one_eq_p\n  \u00b7 let q := Real.conjExponent p\n    have hpq' : p.IsConjExponent q := Real.IsConjExponent.conjExponent one_lt_p\n    have one_lt_q : 1 < q := (Real.IsConjExponent.symm hpq').one_lt\n    have ineq : \u2200 g \u2208 {g' : \u03b1 \u2192 \u211d\u22650\u221e | AEMeasurable g' \u03bc \u2227 \u222b\u207b (z : \u03b1), (g' z) ^ q \u2202\u03bc \u2264 1},\n        \u222b\u207b x : \u03b1, (\u222b\u207b y : \u03b2, f x y \u2202\u03bd) * g x \u2202\u03bc \u2264\n        \u222b\u207b (y : \u03b2), (\u222b\u207b (x : \u03b1), f x y ^ p \u2202\u03bc) ^ p\u207b\u00b9 \u2202\u03bd := by\n      intro g \u27e8hg1, hg2\u27e9\n      have ae_meas\u2081 : \u2200\u1d50 x : \u03b1 \u2202\u03bc, AEMeasurable (f x) \u03bd :=\n        aemeasurability_prod\u2081 (f := Function.uncurry f) hf\n      calc\n      _ = \u222b\u207b x : \u03b1, (\u222b\u207b y : \u03b2, f x y * g x \u2202\u03bd) \u2202\u03bc := by\n        apply lintegral_congr_ae\n        filter_upwards [ae_meas\u2081] with a ha using (lintegral_mul_const'' _ ha).symm\n      _ = \u222b\u207b y : \u03b2, (\u222b\u207b x : \u03b1, f x y * g x \u2202\u03bc) \u2202\u03bd := lintegral_lintegral_swap (hf.mul hg1.fst)\n      _ \u2264 \u222b\u207b (y : \u03b2), (\u222b\u207b (x : \u03b1), f x y ^ p \u2202\u03bc) ^ p\u207b\u00b9 \u2202\u03bd := by\n        apply lintegral_mono_ae\n        filter_upwards [aemeasurability_prod\u2082 hf] with y hy\n        calc\n        _ \u2264 (\u222b\u207b (x : \u03b1), f x y ^ p \u2202\u03bc) ^ (1 / p) * (\u222b\u207b (x : \u03b1), g x ^ q \u2202\u03bc) ^ (1 / q) :=\n          ENNReal.lintegral_mul_le_Lp_mul_Lq \u03bc hpq' hy hg1\n        _ \u2264 (\u222b\u207b (x : \u03b1), f x y ^ p \u2202\u03bc) ^ (1 / p) * 1 ^ (1 / q) := by\n          gcongr\n        _ = (\u222b\u207b (x : \u03b1), f x y ^ p \u2202\u03bc) ^ p\u207b\u00b9 := by\n          simp [one_div]\n    nth_rw 1 [\u2190 one_div]\n    rw [representationLp (hp := one_lt_p) (hq := one_lt_q.le) (hpq := hpq'.inv_add_inv_conj)]\n    \u00b7 exact (iSup_le fun g \u21a6 iSup_le fun hg \u21a6 ineq g hg)\n    \u00b7 exact (aemeasurability_integral_component hf)\n  \u00b7 rw [\u2190 one_eq_p]\n    simp only [ENNReal.rpow_one, inv_one]\n    exact (lintegral_lintegral_swap hf).le\n\nlemma lintegral_lintegral_pow_swap_rpow {\u03b1 : Type u_1} {\u03b2 : Type u_3} {p : \u211d} (hp : p \u2265 1)\n    [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]\n    {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b2} [SFinite \u03bd]\n    [SigmaFinite \u03bc] \u2983f : \u03b1 \u2192 \u03b2 \u2192 ENNReal\u2984\n    (hf : AEMeasurable (Function.uncurry f) (\u03bc.prod \u03bd)) :\n    (\u222b\u207b (x : \u03b1), (\u222b\u207b (y : \u03b2), f x y \u2202\u03bd) ^ p \u2202\u03bc) \u2264\n    (\u222b\u207b (y : \u03b2), (\u222b\u207b (x : \u03b1), (f x y) ^ p \u2202\u03bc) ^ p\u207b\u00b9 \u2202\u03bd) ^ p := by\n  have p_pos : p > 0 := lt_of_lt_of_le zero_lt_one hp\n  refine le_of_rpow_le (inv_pos_of_pos p_pos) ?_\n  rw [ENNReal.rpow_rpow_inv p_pos.ne']\n  exact lintegral_lintegral_pow_swap hp hf\n\n/-! ## Apply Minkowski's integral inequality to truncations\n-/\n\n@[measurability, fun_prop]\ntheorem ton_aeMeasurable (tc : ToneCouple) : AEMeasurable tc.ton (volume.restrict (Ioi 0)) := by\n  -- ton is either increasing or decreasing\n  have mono_or_anti := tc.ton_is_ton\n  split_ifs at mono_or_anti\n  \u00b7 exact aemeasurable_restrict_of_monotoneOn measurableSet_Ioi mono_or_anti.monotoneOn\n  \u00b7 exact aemeasurable_restrict_of_antitoneOn measurableSet_Ioi mono_or_anti.antitoneOn\n\n@[measurability]\nlemma indicator_ton_measurable {g : \u03b1 \u2192 E\u2081} [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081]\n    [BorelSpace E\u2081] [SigmaFinite \u03bc] (hg : AEMeasurable g \u03bc) (tc : ToneCouple) :\n    NullMeasurableSet {(s, x) : \u211d \u00d7 \u03b1 | \u2016g x\u2016\u208a \u2264 tc.ton s }\n        ((volume.restrict (Ioi 0)).prod \u03bc) :=\n  nullMeasurableSet_le hg.snd.norm (ton_aeMeasurable tc).fst\n\n@[measurability]\nlemma indicator_ton_measurable_lt {g : \u03b1 \u2192 E\u2081} [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081]\n    [BorelSpace E\u2081] [SigmaFinite \u03bc] (hg : AEMeasurable g \u03bc) (tc : ToneCouple) :\n    NullMeasurableSet {(s, x) : \u211d \u00d7 \u03b1 | tc.ton s < \u2016g x\u2016\u208a }\n        ((volume.restrict (Ioi 0)).prod \u03bc) :=\n  nullMeasurableSet_lt (ton_aeMeasurable tc).fst hg.snd.norm\n\n@[measurability]\nlemma truncation_ton_measurable {f : \u03b1 \u2192 E\u2081}\n    [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081]\n    [SigmaFinite (\u03bc.restrict (Function.support f))] -- TODO: TypeClass or implicit variable?\n    (hf : AEMeasurable f \u03bc) (tc : ToneCouple) :\n    AEMeasurable (fun a : \u211d \u00d7 \u03b1 \u21a6 (trunc f (tc.ton a.1)) a.2)\n    ((volume.restrict (Ioi 0)).prod (\u03bc.restrict (Function.support f) )) := by\n  let A := {(s, x) : \u211d \u00d7 \u03b1 | \u2016f x\u2016\u208a \u2264 tc.ton s}\n  have : (fun z : \u211d \u00d7 \u03b1 \u21a6 (trunc f (tc.ton z.1)) z.2) =\n      Set.indicator A (fun z : \u211d \u00d7 \u03b1 \u21a6 f z.2) := by\n    ext z; simp [trunc, indicator, A]\n  rw [this]\n  exact (aemeasurable_indicator_iff\u2080 (indicator_ton_measurable hf.restrict _)).mpr\n    hf.restrict.snd.restrict\n\n@[measurability]\nlemma truncation_compl_ton_measurable {f : \u03b1 \u2192 E\u2081}\n    [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081]\n    [SigmaFinite (\u03bc.restrict (Function.support f))] -- TODO: TypeClass or implicit variable?\n    (hf : AEMeasurable f \u03bc) (tc : ToneCouple) :\n    AEMeasurable (fun a : \u211d \u00d7 \u03b1 \u21a6 ((f - trunc f (tc.ton a.1))) a.2)\n    ((volume.restrict (Ioi 0)).prod (\u03bc.restrict (Function.support f) )) := by\n  let A := {(s, x) : \u211d \u00d7 \u03b1 | tc.ton s < \u2016f x\u2016\u208a}\n  have : (fun z : \u211d \u00d7 \u03b1 \u21a6 (f - trunc f (tc.ton z.1)) z.2) = Set.indicator A (fun z : \u211d \u00d7 \u03b1 \u21a6 f z.2) := by\n    ext z; rw [trunc_compl_eq]; simp [A, indicator]\n  rw [this]\n  refine (aemeasurable_indicator_iff\u2080 (indicator_ton_measurable_lt hf.restrict _)).mpr\n    hf.restrict.snd.restrict\n\nlemma restrict_to_support {a : \u211d} {p : \u211d} (hp : p > 0) [NormedAddCommGroup E\u2081] (f : \u03b1 \u2192 E\u2081) :\n    \u222b\u207b x : \u03b1 in Function.support f, \u2016trunc f a x\u2016\u208a ^ p \u2202 \u03bc = \u222b\u207b x : \u03b1, \u2016trunc f a x\u2016\u208a ^ p \u2202\u03bc := by\n  apply setLIntegral_eq_of_support_subset\n  unfold Function.support trunc\n  rw [setOf_subset_setOf]\n  intro x\n  contrapose!\n  intro f_zero\n  simp_rw [f_zero]; simp [hp]\n\nlemma restrict_to_support_trunc_compl {a : \u211d} {p : \u211d} [NormedAddCommGroup E\u2081] (hp : p > 0)\n    (f : \u03b1 \u2192 E\u2081) :\n    \u222b\u207b x : \u03b1 in Function.support f, \u2016(f - trunc f a) x\u2016\u208a ^ p \u2202\u03bc =\n    \u222b\u207b x : \u03b1, \u2016(f - trunc f a) x\u2016\u208a ^ p \u2202\u03bc := by\n  apply setLIntegral_eq_of_support_subset\n  unfold Function.support trunc\n  rw [setOf_subset_setOf]\n  intro x\n  contrapose!\n  intro f_zero\n  rw [Pi.sub_apply, f_zero]\n  simp [hp]\n\nlemma restrict_to_support_trnc {a : \u211d} {p : \u211d} {j : Bool} [NormedAddCommGroup E\u2081] (hp : p > 0)\n    (f : \u03b1 \u2192 E\u2081) :\n    \u222b\u207b x : \u03b1 in Function.support f, \u2016trnc j f a x\u2016\u208a ^ p \u2202\u03bc =\n    \u222b\u207b x : \u03b1, \u2016trnc j f a x\u2016\u208a ^ p \u2202\u03bc := by\n  apply setLIntegral_eq_of_support_subset\n  unfold Function.support trnc trunc\n  rw [setOf_subset_setOf]\n  intro x\n  contrapose!\n  intro f_zero\n  rcases j\n  \u00b7 dsimp only [Pi.sub_apply]; simp_rw [f_zero]; simp [hp]\n  \u00b7 simp_rw [f_zero]; simp [hp]\n\n@[fun_prop]\ntheorem aeMeasurable_trunc_restrict\n    [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081] {j : Bool}\n    {h\u03bc : SigmaFinite (\u03bc.restrict (Function.support f))} (hf : AEMeasurable f \u03bc) (tc : ToneCouple) :\n    AEMeasurable (fun a \u21a6 trnc j f (tc.ton a.1) a.2)\n      ((volume.restrict (Ioi 0)).prod (\u03bc.restrict (Function.support f))) := by\n  rcases j\n  \u00b7 exact truncation_compl_ton_measurable hf _\n  \u00b7 exact truncation_ton_measurable hf _\n\nlemma lintegral_lintegral_pow_swap_trunc_compl {q q\u2080 p\u2080 : \u211d} [MeasurableSpace E\u2081]\n    [NormedAddCommGroup E\u2081]\n    [BorelSpace E\u2081] {j : Bool} {h\u03bc : SigmaFinite (\u03bc.restrict (Function.support f))}\n    (hp\u2080 : p\u2080 > 0) (hp\u2080q\u2080 : p\u2080 \u2264 q\u2080)\n    (hf : AEMeasurable f \u03bc) (tc : ToneCouple) :\n    \u222b\u207b (s : \u211d) in Ioi 0,\n        (\u222b\u207b (a : \u03b1) in Function.support f, ENNReal.ofReal (s ^ (q - q\u2080 - 1)) ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9 *\n        \u2191\u2016trnc j f (tc.ton s) a\u2016\u208a ^ p\u2080 \u2202\u03bc) ^ (p\u2080\u207b\u00b9 * q\u2080) \u2264\n    (\u222b\u207b a : \u03b1 in Function.support f,\n      (\u222b\u207b (s : \u211d) in Ioi 0,\n        (ENNReal.ofReal (s ^ (q - q\u2080 - 1)) ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9 *\n        \u2191\u2016trnc j f (tc.ton s) a\u2016\u208a  ^ p\u2080) ^ (p\u2080\u207b\u00b9 * q\u2080)) ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9 \u2202\u03bc) ^ (p\u2080\u207b\u00b9 * q\u2080) := by\n  apply lintegral_lintegral_pow_swap_rpow\n  \u00b7 apply le_of_mul_le_mul_left _ hp\u2080\n    field_simp [hp\u2080q\u2080]\n  \u00b7 unfold Function.uncurry\n    simp only [Pi.sub_apply]\n    fun_prop\n\nlemma lintegral_congr_support {f : \u03b1 \u2192 E\u2081} {g h: \u03b1 \u2192 ENNReal}\n    [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081]\n    (hf : AEMeasurable f \u03bc) (hgh : \u2200 x \u2208 Function.support f, g x = h x) :\n    \u222b\u207b x : \u03b1 in Function.support f, g x \u2202\u03bc = \u222b\u207b x : \u03b1 in Function.support f, h x \u2202\u03bc := by\n  refine lintegral_congr_ae (ae_iff.mpr ?_)\n  rw [Measure.restrict_apply\u2080']\n  \u00b7 refine measure_mono_null (fun x h\u2080 \u21a6 ?_) measure_empty\n    have : g x = h x := hgh _ (mem_of_mem_inter_right h\u2080)\n    have : x \u2208 {a | \u00acg a = h a} := mem_of_mem_diff h\u2080\n    change \u00ac (g x = h x) at this\n    contradiction\n  \u00b7 have : (Function.support f) = (Function.support (fun x \u21a6 \u2016f x\u2016)) := by\n      unfold Function.support\n      ext x\n      simp only [ne_eq, mem_setOf_eq, norm_eq_zero]\n    rw [this]\n    exact (aestronglyMeasurable_iff_aemeasurable.mpr hf.norm).nullMeasurableSet_support\n\n/-- One of the key estimates for the real interpolation theorem, not yet using\n    the particular choice of exponent and scale in the `ScaledPowerFunction`. -/\nlemma estimate_trnc {p\u2080 q\u2080 q : \u211d} {spf : ScaledPowerFunction} {j : Bool}\n    [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081]\n    (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2080q\u2080 : p\u2080 \u2264 q\u2080)\n    (hf : AEMeasurable f \u03bc) (hf\u2082 : SigmaFinite (\u03bc.restrict (Function.support f)))\n    (hpowers : if xor j (spf_to_tc spf).mon = true then q\u2080 < q else q < q\u2080) :\n    \u222b\u207b s : \u211d in Ioi 0,\n    eLpNorm (trnc j f ((spf_to_tc spf).ton s)) (ENNReal.ofReal p\u2080) \u03bc ^ q\u2080 *\n    ENNReal.ofReal (s ^ (q - q\u2080 - 1)) \u2264\n    ENNReal.ofReal (spf.d ^ (q - q\u2080)) * ENNReal.ofReal |q - q\u2080|\u207b\u00b9 *\n    (\u222b\u207b (a : \u03b1) in Function.support f,\n    ENNReal.ofReal (\u2016f a\u2016 ^ (p\u2080 + spf.\u03c3\u207b\u00b9 * (q - q\u2080) * (p\u2080 / q\u2080))) \u2202\u03bc) ^\n    (p\u2080\u207b\u00b9 * q\u2080) := by\n  have := spf.hd\n  unfold eLpNorm eLpNorm'\n  set tc := spf_to_tc spf\n  split_ifs with is_p\u2080pos is_p\u2080top\n  \u00b7 have : p\u2080 \u2264 0 := ofReal_eq_zero.mp is_p\u2080pos\n    contrapose! this; exact hp\u2080\n  \u00b7 contrapose! is_p\u2080top; exact coe_ne_top\n  \u00b7 rw [toReal_ofReal hp\u2080.le]\n    calc\n    _ = \u222b\u207b s : \u211d in Ioi 0, ENNReal.ofReal (s ^ (q - q\u2080 - 1)) *\n    ((\u222b\u207b (a : \u03b1), \u2191\u2016trnc j f ((spf_to_tc spf).ton s) a\u2016\u208a ^ p\u2080 \u2202\u03bc) ^ (1 / p\u2080)) ^ q\u2080  := by\n      simp only [enorm_eq_nnnorm]\n      congr 1\n      ext x\n      rw [mul_comm]\n    _ = \u222b\u207b (s : \u211d) in Ioi 0,\n        (ENNReal.ofReal (s ^ (q - q\u2080 - 1)) ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9) ^ (p\u2080\u207b\u00b9 * q\u2080) *\n        (\u222b\u207b (a : \u03b1) in Function.support f, \u2191\u2016trnc j f (tc.ton s) a\u2016\u208a ^ p\u2080 \u2202\u03bc) ^ (p\u2080\u207b\u00b9 * q\u2080)\n        := by\n      apply setLIntegral_congr_fun measurableSet_Ioi\n      filter_upwards with s _\n      rw [ENNReal.rpow_inv_rpow]\n      \u00b7 rw [one_div, \u2190 ENNReal.rpow_mul, restrict_to_support_trnc hp\u2080]\n      \u00b7 positivity\n    _ = \u222b\u207b (s : \u211d) in Ioi 0,\n        (\u222b\u207b (a : \u03b1) in Function.support f,\n        ENNReal.ofReal (s ^ (q - q\u2080 - 1)) ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9 *\n        \u2191\u2016trnc j f (tc.ton s) a\u2016\u208a ^ p\u2080 \u2202\u03bc) ^ (p\u2080\u207b\u00b9 * q\u2080)\n        := by\n      apply setLIntegral_congr_fun measurableSet_Ioi\n      filter_upwards with s _\n      rw [lintegral_const_mul', ENNReal.mul_rpow_of_nonneg]\n      \u00b7 positivity\n      \u00b7 exact (ENNReal.rpow_lt_top_of_nonneg (by positivity) coe_ne_top).ne\n    _ \u2264 (\u222b\u207b a : \u03b1 in Function.support f,\n        (\u222b\u207b (s : \u211d) in Ioi 0,\n        (ENNReal.ofReal (s ^ (q - q\u2080 - 1)) ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9 *\n        \u2191\u2016trnc j f (tc.ton s) a\u2016\u208a  ^ p\u2080) ^ (p\u2080\u207b\u00b9 * q\u2080)) ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9 \u2202\u03bc) ^ (p\u2080\u207b\u00b9 * q\u2080) := by\n      -- This is a consequence of Minkowski's integral inequality\n      apply lintegral_lintegral_pow_swap_trunc_compl hp\u2080 hp\u2080q\u2080 hf tc; assumption\n    _ = (\u222b\u207b a : \u03b1 in Function.support f,\n        (\u222b\u207b (s : \u211d) in Ioi 0,\n        (ENNReal.ofReal (s ^ (q - q\u2080 - 1)) *\n        \u2191\u2016trnc j f (tc.ton s) a\u2016\u208a ^ q\u2080)) ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9 \u2202\u03bc) ^ (p\u2080\u207b\u00b9 * q\u2080) := by\n      congr 1\n      apply lintegral_congr_support hf\n      intro x _\n      congr 1\n      apply setLIntegral_congr_fun measurableSet_Ioi\n      filter_upwards with s _\n      rw [ENNReal.mul_rpow_of_nonneg, ENNReal.rpow_inv_rpow, \u2190 ENNReal.rpow_mul] <;> try positivity\n      congr\n      field_simp\n    _ = (\u222b\u207b a : \u03b1 in Function.support f,\n        ((\u222b\u207b (s : \u211d) in res (xor j tc.mon) (tc.inv \u2016f a\u2016),\n        (ENNReal.ofReal (s ^ (q - q\u2080 - 1))))*\n        \u2191\u2016f a\u2016\u208a ^ q\u2080) ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9 \u2202\u03bc) ^ (p\u2080\u207b\u00b9 * q\u2080) := by\n      congr 1\n      apply lintegral_congr_support hf\n      intro x hfx\n      congr 1\n      apply lintegral_trunc_mul hq\u2080 (nnnorm_pos.mpr hfx)\n    _ = (\u222b\u207b a : \u03b1 in Function.support f,\n        ((ENNReal.ofReal (tc.inv \u2016f a\u2016 ^ (q - q\u2080 - 1 + 1) / |q - q\u2080 - 1 + 1|)) *\n        ENNReal.ofReal (\u2016f a\u2016 ^ q\u2080)) ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9 \u2202\u03bc) ^ (p\u2080\u207b\u00b9 * q\u2080) := by\n      congr 1\n      apply lintegral_congr_support hf\n      intro x hfx\n      congr 2\n      \u00b7 apply value_lintegral_res\u2080\n        \u00b7 apply tc.ran_inv\n          exact norm_pos_iff.mpr hfx\n        \u00b7 split_ifs with h\n          \u00b7 simp only [h, \u2193reduceIte] at hpowers; linarith\n          \u00b7 simp only [h, Bool.false_eq_true, \u2193reduceIte] at hpowers; linarith\n      \u00b7 rw [\u2190 ofReal_rpow_of_nonneg] <;> try positivity\n        congr\n        exact norm_toNNReal.symm\n    _ = (\u222b\u207b a : \u03b1 in Function.support f,\n        ((ENNReal.ofReal\n        (spf.d ^ (q - q\u2080 - 1 + 1) * \u2016f a\u2016 ^ (spf.\u03c3\u207b\u00b9 * (q - q\u2080 - 1 + 1) + q\u2080) /\n      |q - q\u2080 - 1 + 1|))) ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9 \u2202\u03bc) ^ (p\u2080\u207b\u00b9 * q\u2080) := by\n      congr 1\n      apply lintegral_congr_support hf\n      intro x hfx\n      congr 1\n      apply value_lintegral_res\u2081\n      exact norm_pos_iff.mpr hfx\n    _ = (\u222b\u207b a : \u03b1 in Function.support f,\n        ((ENNReal.ofReal (spf.d ^ (q - q\u2080)) ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9 *\n        ENNReal.ofReal (\u2016f a\u2016 ^ ((spf.\u03c3\u207b\u00b9 * (q - q\u2080) + q\u2080) * (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9)) *\n    ENNReal.ofReal |q - q\u2080|\u207b\u00b9 ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9))  \u2202\u03bc) ^ (p\u2080\u207b\u00b9 * q\u2080) := by\n      congr 1\n      apply lintegral_congr_support hf\n      intro x _\n      rw [div_eq_mul_inv, ENNReal.ofReal_mul, sub_add_cancel, ENNReal.ofReal_mul,\n          ENNReal.mul_rpow_of_nonneg, ENNReal.mul_rpow_of_nonneg] <;> try positivity\n      nth_rw 2 [ENNReal.ofReal_rpow_of_nonneg] <;> try positivity\n      rw [\u2190 Real.rpow_mul] ; try positivity\n    _ = ENNReal.ofReal (spf.d ^ (q - q\u2080)) *\n        (\u222b\u207b (a : \u03b1) in Function.support f,\n        ENNReal.ofReal (\u2016f a\u2016 ^ ((spf.\u03c3\u207b\u00b9 * (q - q\u2080) + q\u2080) * (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9)) \u2202\u03bc) ^\n        (p\u2080\u207b\u00b9 * q\u2080) *\n        ENNReal.ofReal |q - q\u2080|\u207b\u00b9 := by\n      rw [lintegral_mul_const', lintegral_const_mul', ENNReal.mul_rpow_of_nonneg,\n          ENNReal.mul_rpow_of_nonneg, ENNReal.rpow_inv_rpow, ENNReal.rpow_inv_rpow] <;>\n          try positivity\n      \u00b7 exact rpow_ne_top_of_nonneg (by positivity) coe_ne_top\n      \u00b7 exact rpow_ne_top_of_nonneg (by positivity) coe_ne_top\n    _ = ENNReal.ofReal (spf.d ^ (q - q\u2080)) *\n        (\u222b\u207b (a : \u03b1) in Function.support f,\n        ENNReal.ofReal (\u2016f a\u2016 ^ (p\u2080 + spf.\u03c3\u207b\u00b9 * (q - q\u2080) * (p\u2080 / q\u2080))) \u2202\u03bc) ^\n        (p\u2080\u207b\u00b9 * q\u2080) *\n        ENNReal.ofReal |q - q\u2080|\u207b\u00b9 := by\n      congr\n      ext x\n      congr\n      ring_nf\n      rw [inv_inv]\n      field_simp\n    _ = _ := by ring\n\ndef sel (j : Bool) (p\u2080 p\u2081 : \u211d\u22650\u221e) := match j with | true => p\u2081 | false => p\u2080\n\n/-- One of the key estimates for the real interpolation theorem, now using\n    the particular choice of exponent, but not yet using the\n    particular choice of scale in the `ScaledPowerFunction`. -/\nlemma estimate_trnc\u2081 {spf : ScaledPowerFunction} {j : Bool}\n    [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081] (ht : t \u2208 Ioo 0 1)\n    (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0) (hpq : sel j p\u2080 p\u2081 \u2264 sel j q\u2080 q\u2081)\n    (hp' : sel j p\u2080 p\u2081 \u2260 \u22a4) (hq' : sel j q\u2080 q\u2081 \u2260 \u22a4)  (hp\u2080p\u2081 : p\u2080 < p\u2081)\n    (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081) (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9)\n    (hf : AEMeasurable f \u03bc) (hf\u2082 : SigmaFinite (\u03bc.restrict (Function.support f)))\n    (hspf : spf.\u03c3 = @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) :\n    \u222b\u207b s : \u211d in Ioi 0,\n    eLpNorm (trnc j f ((spf_to_tc spf).ton s)) (sel j p\u2080 p\u2081) \u03bc ^ (sel j q\u2080 q\u2081).toReal *\n    ENNReal.ofReal (s ^ (q.toReal - (sel j q\u2080 q\u2081).toReal - 1)) \u2264\n    ENNReal.ofReal (spf.d ^ (q.toReal - (sel j q\u2080 q\u2081).toReal)) *\n    ENNReal.ofReal |q.toReal - (sel j q\u2080 q\u2081).toReal|\u207b\u00b9 *\n    ((eLpNorm f p \u03bc) ^ p.toReal) ^ ((sel j p\u2080 p\u2081).toReal \u207b\u00b9 * (sel j q\u2080 q\u2081).toReal) := by\n  have p_toReal_pos : p.toReal > 0 :=\n    interp_exp_toReal_pos' ht hp\u2080 hp\u2081 hp (Or.inl hp\u2080p\u2081.ne_top)\n  calc\n  _ \u2264 ENNReal.ofReal (spf.d ^ (q.toReal - (sel j q\u2080 q\u2081).toReal)) *\n      ENNReal.ofReal |q.toReal - (sel j q\u2080 q\u2081).toReal|\u207b\u00b9 *\n      (\u222b\u207b (a : \u03b1) in Function.support f,\n      ENNReal.ofReal (\u2016f a\u2016 ^ ((sel j p\u2080 p\u2081).toReal + spf.\u03c3\u207b\u00b9 * (q.toReal - (sel j q\u2080 q\u2081).toReal) *\n      ((sel j p\u2080 p\u2081).toReal / (sel j q\u2080 q\u2081).toReal))) \u2202\u03bc) ^\n      ((sel j p\u2080 p\u2081).toReal \u207b\u00b9 * (sel j q\u2080 q\u2081).toReal) := by\n    have coe_p' : ENNReal.ofReal (sel j p\u2080 p\u2081).toReal = (sel j p\u2080 p\u2081) := ofReal_toReal_eq_iff.mpr hp'\n    nth_rw 1 [\u2190 coe_p']\n    apply estimate_trnc\n    \u00b7 apply toReal_pos\n      \u00b7 cases j\n        \u00b7 exact hp\u2080.ne'\n        \u00b7 exact hp\u2081.ne'\n      \u00b7 exact hp'\n    \u00b7 apply toReal_pos\n      \u00b7 cases j\n        \u00b7 exact hq\u2080.ne'\n        \u00b7 exact hq\u2081.ne'\n      \u00b7 exact hq'\n    \u00b7 exact toReal_mono hq' hpq\n    \u00b7 exact hf\n    \u00b7 exact hf\u2082\n    \u00b7 unfold spf_to_tc\n      cases j\n      \u00b7 unfold sel\n        dsimp only\n        rw [hspf]\n        simp only [Bool.if_false_right, Bool.and_true, Bool.false_bne, decide_eq_true_eq]\n        split_ifs with is_\u03b6_pos\n        \u00b7 apply toReal_strict_mono\n          \u00b7 exact interp_exp_ne_top hq\u2080q\u2081 ht hq\n          \u00b7 exact (\u03b6_pos_iff_of_lt\u2080 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hq\u2080q\u2081 hp hq hp\u2080p\u2081).mp is_\u03b6_pos\n        \u00b7 apply toReal_strict_mono hq'\n          exact (\u03b6_le_zero_iff_of_lt\u2080 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hq\u2080q\u2081 hp hq hp\u2080p\u2081).mp\n            (le_of_not_lt is_\u03b6_pos)\n      \u00b7 unfold sel\n        dsimp only\n        rw [hspf]\n        simp only [Bool.if_false_right, Bool.and_true, Bool.true_bne, Bool.not_eq_true',\n            decide_eq_false_iff_not]\n        split_ifs with is_\u03b6_pos\n        \u00b7 apply toReal_strict_mono hq'\n          exact (\u03b6_pos_iff_of_lt\u2081 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hq\u2080q\u2081 hp hq hp\u2080p\u2081).mp is_\u03b6_pos\n        \u00b7 apply toReal_strict_mono\n          \u00b7 exact interp_exp_ne_top hq\u2080q\u2081 ht hq\n          \u00b7 exact (\u03b6_le_zero_iff_of_lt\u2081 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hq\u2080q\u2081 hp hq hp\u2080p\u2081).mp\n                (le_of_not_lt is_\u03b6_pos)\n  _ = ENNReal.ofReal (spf.d ^ (q.toReal - (sel j q\u2080 q\u2081).toReal)) *\n        ENNReal.ofReal |q.toReal - (sel j q\u2080 q\u2081).toReal|\u207b\u00b9 *\n        (\u222b\u207b (a : \u03b1) in Function.support f,\n        ENNReal.ofReal (\u2016f a\u2016 ^ p.toReal) \u2202\u03bc) ^\n        ((sel j p\u2080 p\u2081).toReal \u207b\u00b9 * (sel j q\u2080 q\u2081).toReal) := by\n    congr\n    ext x\n    congr\n    rcases j\n    \u00b7 dsimp only [sel]\n      rw [hspf]\n      apply \u03b6_equality\u2085 (hp\u2080p\u2081 := hp\u2080p\u2081.ne) <;> assumption\n    \u00b7 dsimp only [sel]\n      rw [hspf]\n      apply \u03b6_equality\u2086 (hp\u2080p\u2081 := hp\u2080p\u2081.ne) <;> assumption\n  _ \u2264 ENNReal.ofReal (spf.d ^ (q.toReal - (sel j q\u2080 q\u2081).toReal)) *\n      ENNReal.ofReal |q.toReal - (sel j q\u2080 q\u2081).toReal|\u207b\u00b9 *\n      (\u222b\u207b (a : \u03b1),\n      ENNReal.ofReal (\u2016f a\u2016 ^ p.toReal) \u2202\u03bc) ^\n      ((sel j p\u2080 p\u2081).toReal \u207b\u00b9 * (sel j q\u2080 q\u2081).toReal) := by\n    gcongr\n    exact setLIntegral_le_lintegral _ _\n  _ = ENNReal.ofReal (spf.d ^ (q.toReal - (sel j q\u2080 q\u2081).toReal)) *\n      ENNReal.ofReal |q.toReal - (sel j q\u2080 q\u2081).toReal|\u207b\u00b9 *\n      (((\u222b\u207b (a : \u03b1), \u2016f a\u2016\u208a ^ p.toReal \u2202\u03bc) ^ p.toReal\u207b\u00b9 ) ^ p.toReal) ^\n      ((sel j p\u2080 p\u2081).toReal \u207b\u00b9 * (sel j q\u2080 q\u2081).toReal) := by\n    congr\n    rw [ENNReal.rpow_inv_rpow] <;> try positivity\n    congr\n    ext x\n    rw [\u2190 ofReal_rpow_of_nonneg] <;> try positivity\n    congr\n    exact ofReal_norm_eq_enorm (f x)\n  _ = ENNReal.ofReal (spf.d ^ (q.toReal - (sel j q\u2080 q\u2081).toReal)) *\n      ENNReal.ofReal |q.toReal - (sel j q\u2080 q\u2081).toReal|\u207b\u00b9 *\n      ((eLpNorm f p \u03bc) ^ p.toReal) ^\n      ((sel j p\u2080 p\u2081).toReal \u207b\u00b9 * (sel j q\u2080 q\u2081).toReal) := by\n    congr\n    rw [\u2190 one_div]\n    refine (eLpNorm_eq_lintegral_rpow_enorm ?_ ?_).symm\n    \u00b7 exact (interpolated_pos' hp\u2080 hp\u2081 hp).ne'\n    \u00b7 exact interp_exp_ne_top hp\u2080p\u2081.ne ht hp\n\n-- TODO: move this to Weaktype.lean?\nlemma wnorm_eq_zero_iff {f : \u03b1 \u2192 E\u2081} {p : \u211d\u22650\u221e} [NormedAddCommGroup E\u2081] (hp : p \u2260 0) :\n    wnorm f p \u03bc = 0 \u2194 f =\u1d50[\u03bc] 0 := by\n  unfold wnorm\n  split_ifs with h\u2080\n  \u00b7 exact eLpNormEssSup_eq_zero_iff\n  \u00b7 refine Iff.trans \u27e8?_, ?_\u27e9 eLpNormEssSup_eq_zero_iff <;> intro h\n    \u00b7 have iSup_wnorm := iSup_eq_zero.mp h\n      by_contra h\u2081\n      have : eLpNormEssSup f \u03bc > 0 := pos_iff_ne_zero.mpr h\u2081\n      unfold eLpNormEssSup at this\n      rw [essSup_eq_sInf] at this\n      let b := (min (sInf {a : \u211d\u22650\u221e | \u03bc {x | a < \u2191\u2016f x\u2016\u208a} = 0}) 1) / 2\n      have b_lt_inf : b < min (sInf {a : \u211d\u22650\u221e | \u03bc {x | a < \u2191\u2016f x\u2016\u208a} = 0}) 1 :=\n        ENNReal.half_lt_self (lt_min this zero_lt_one).ne'\n          (lt_of_le_of_lt (min_le_right _ 1) one_lt_top).ne\n      have meas_ne_zero : \u03bc {x | b < \u2191\u2016f x\u2016\u208a} \u2260 0 := by\n        intro h\n        have obs : sInf {a | \u03bc {x | a < \u2191\u2016f x\u2016\u208a} = 0} \u2264 b := csInf_le' h\n        contrapose! obs\n        calc\n        _ < _ := b_lt_inf\n        _ \u2264 _ := min_le_left ..\n      have b_ne_0 : b \u2260 0 := (ENNReal.half_pos (lt_min this zero_lt_one).ne').ne'\n      have p_toReal_inv_pos : p.toReal\u207b\u00b9 > 0 := inv_pos_of_pos (toReal_pos hp h\u2080)\n      have coe_b : ENNReal.ofNNReal b.toNNReal = b := coe_toNNReal b_lt_inf.ne_top\n      have : distribution f b \u03bc = 0 := by\n        refine (rpow_eq_zero_iff_of_pos p_toReal_inv_pos).mp ?_\n        refine eq_zero_of_ne_zero_of_mul_left_eq_zero b_ne_0 ?_\n        rw [\u2190 coe_b]\n        exact iSup_wnorm b.toNNReal\n      exact meas_ne_zero this\n    \u00b7 refine iSup_eq_zero.mpr fun t \u21a6 mul_eq_zero.mpr\n        (Or.inr ((rpow_eq_zero_iff_of_pos (inv_pos_of_pos (toReal_pos hp h\u2080))).mpr (nonpos_iff_eq_zero.mp ?_)))\n      calc\n        _ \u2264 distribution f 0 \u03bc := by gcongr; exact zero_le _\n        _ = distribution f (eLpNormEssSup f \u03bc) \u03bc := by congr; exact h.symm\n        _ = 0 := distribution_snormEssSup\n\n\n/-! ## Weaktype estimates applied to truncations -/\n\nvariable [NormedAddCommGroup E\u2081] [NormedAddCommGroup E\u2082]\n\nlemma eLpNorm_trnc_est {f : \u03b1 \u2192 E\u2081} {j : Bool} {a : \u211d} :\n    eLpNorm (trnc j f a) p \u03bc \u2264 eLpNorm f p \u03bc := eLpNorm_mono fun _x \u21a6 trnc_le_func\n\nvariable [ContinuousENorm \u03b5] {T : (\u03b1 \u2192 E\u2081) \u2192 (\u03b1' \u2192 \u03b5)} in\n-- TODO: remove the subindex 0 here\nlemma weaktype_estimate {C\u2080 : \u211d\u22650} {p : \u211d\u22650\u221e} {q : \u211d\u22650\u221e} {f : \u03b1 \u2192 E\u2081}\n      (hq : 0 < q) (hq' : q < \u22a4) (hf : Mem\u2112p f p \u03bc)\n    (h\u2080T : HasWeakType T p q \u03bc \u03bd C\u2080) {t : \u211d} (ht : t > 0) :\n    distribution (T f) (ENNReal.ofReal t) \u03bd \u2264 C\u2080 ^ q.toReal *\n        eLpNorm f p \u03bc ^ q.toReal * ENNReal.ofReal (t ^ (-q.toReal)) := by\n  have wt_est := (h\u2080T f hf).2 -- the weaktype estimate\n  have q_pos : q.toReal > 0 := toReal_pos hq.ne' hq'.ne_top\n  have tq_pos : ENNReal.ofReal t ^ q.toReal > 0 := coe_pow_pos ht\n  have tq_ne_top : (ENNReal.ofReal t) ^ q.toReal \u2260 \u22a4 := coe_rpow_ne_top' q_pos\n  -- have hq\u2081 : q.toReal = q := by exact toReal_ofReal q_nonneg\n  simp only [wnorm, wnorm', hq'.ne_top, \u2193reduceIte, iSup_le_iff] at wt_est\n  have wt_est_t := wt_est t.toNNReal -- this is the weaktype estimate applied to t\n  rw [\u2190 ENNReal.mul_le_mul_right (c := (ENNReal.ofReal t) ^ q.toReal) _ tq_ne_top,\n      ofReal_rpow_of_pos, mul_assoc _ _ (ENNReal.ofReal (t ^ q.toReal)), \u2190 ofReal_mul',\n      \u2190 Real.rpow_add, neg_add_cancel, Real.rpow_zero, ofReal_one, mul_one, mul_comm,\n      \u2190 ENNReal.mul_rpow_of_nonneg] <;> try positivity\n  refine (ENNReal.rpow_inv_le_iff q_pos).mp ?_\n  rw [ENNReal.mul_rpow_of_nonneg, ENNReal.ofReal_rpow_of_pos,\n      Real.rpow_rpow_inv] <;> try positivity\n  rwa [\u2190 coe_coe_eq_ofReal]\n\nvariable [ContinuousENorm \u03b5] {T : (\u03b1 \u2192 E\u2081) \u2192 (\u03b1' \u2192 \u03b5)} in\nlemma weaktype_estimate_top {C : \u211d\u22650} {p : \u211d\u22650\u221e} {q : \u211d\u22650\u221e}\n    (hq' : q = \u22a4) {f : \u03b1 \u2192 E\u2081} (hf : Mem\u2112p f p \u03bc)\n    (hT : HasWeakType T p q \u03bc \u03bd C) {t : \u211d} (ht : C * eLpNorm f p \u03bc \u2264 ENNReal.ofReal t) :\n    distribution (T f) (ENNReal.ofReal t) \u03bd = 0 := by\n  have wt_est := (hT f hf).2\n  unfold wnorm at wt_est\n  split_ifs at wt_est\n  apply nonpos_iff_eq_zero.mp\n  calc\n  _ \u2264 distribution (T f) (eLpNormEssSup (T f) \u03bd) \u03bd := distribution_mono_right (le_trans wt_est ht)\n  _ = _ := meas_essSup_lt -- meas_eLpNormEssSup_lt\n\n-- for the remaining lemmas we use too much measure theory that is just for normed spaces\n-- try to generalize to ENorm-classes after Mathlib refactor\nvariable {T : (\u03b1 \u2192 E\u2081) \u2192 (\u03b1' \u2192 E\u2082)}\n\n/-- If `T` has weaktype `p\u2080`-`p\u2081`, `f` is `AEStronglyMeasurable` and the `p`-norm of `f`\n    vanishes, then the `q`-norm of `T f` vanishes.\n    -/\nlemma weaktype_aux\u2080 {p\u2080 q\u2080 p q : \u211d\u22650\u221e}\n    (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp : p > 0) (hq : q > 0)\n    {C\u2080 : \u211d\u22650}\n    (h\u2080T : HasWeakType T p\u2080 q\u2080 \u03bc \u03bd C\u2080) (hf : AEStronglyMeasurable f \u03bc)\n    (hF : eLpNorm f p \u03bc = 0) :\n    eLpNorm (T f) q \u03bd = 0 := by\n  have f_ae_0 : f =\u1d50[\u03bc] 0 := (eLpNorm_eq_zero_iff hf hp.ne').mp hF\n  have hf\u2082 : eLpNorm f p\u2080 \u03bc = 0 := (eLpNorm_eq_zero_iff hf hp\u2080.ne').mpr f_ae_0\n  have hf\u2081 : Mem\u2112p f p\u2080 \u03bc := \u27e8hf, by rw [hf\u2082]; exact zero_lt_top\u27e9\n  have := (h\u2080T f hf\u2081).2\n  rw [hf\u2082, mul_zero] at this\n  have wnorm_0 : wnorm (T f) q\u2080 \u03bd = 0 := nonpos_iff_eq_zero.mp this\n  have : (T f) =\u1d50[\u03bd] 0 := (wnorm_eq_zero_iff hq\u2080.ne').mp wnorm_0\n  exact (eLpNorm_eq_zero_iff (h\u2080T _ hf\u2081).1 hq.ne').mpr this\n\nvariable [MeasurableSpace E\u2081] [BorelSpace E\u2081]\n\nlemma weaktype_estimate_trunc_compl {C\u2080 : \u211d\u22650} {p p\u2080: \u211d\u22650\u221e} {f : \u03b1 \u2192 E\u2081}\n    (hp\u2080 : 0 < p\u2080) {q\u2080 : \u211d\u22650\u221e} (hp : p \u2260 \u22a4) (hq\u2080 : 0 < q\u2080) (hq\u2080' : q\u2080 < \u22a4)\n    (hp\u2080p : p\u2080 < p) (hf : Mem\u2112p f p \u03bc)\n    (h\u2080T : HasWeakType T p\u2080 q\u2080 \u03bc \u03bd C\u2080) {t : \u211d} (ht : t > 0) {a : \u211d} (ha : a > 0) :\n    distribution (T (f - trunc f a)) (ENNReal.ofReal t) \u03bd \u2264 C\u2080 ^ q\u2080.toReal *\n        eLpNorm (f - trunc f a) p\u2080 \u03bc ^ q\u2080.toReal * (ENNReal.ofReal (t ^ (-q\u2080.toReal))) := by\n  apply weaktype_estimate hq\u2080 hq\u2080' ?_ h\u2080T ht\n  exact trunc_compl_Lp_Lq_lower hp \u27e8hp\u2080, hp\u2080p\u27e9 ha hf\n\nlemma weaktype_estimate_trunc {C\u2081 : \u211d\u22650} {p p\u2081 q\u2081: \u211d\u22650\u221e} {f : \u03b1 \u2192 E\u2081}\n    (hp : 0 < p)\n    (hq\u2081 : 0 < q\u2081) (hq\u2081' : q\u2081 < \u22a4) (hp\u2081p : p < p\u2081)\n    (hf : Mem\u2112p f p \u03bc)\n    (h\u2081T : HasWeakType T p\u2081 q\u2081 \u03bc \u03bd C\u2081) {t : \u211d} (ht : t > 0) {a : \u211d} :\n    distribution (T (trunc f a)) (ENNReal.ofReal t) \u03bd \u2264 C\u2081 ^ q\u2081.toReal *\n      eLpNorm (trunc f a) p\u2081 \u03bc ^ q\u2081.toReal * ENNReal.ofReal (t ^ (-q\u2081.toReal)) :=\n  weaktype_estimate hq\u2081 hq\u2081' (trunc_Lp_Lq_higher (p := p) \u27e8hp, hp\u2081p\u27e9 hf) h\u2081T ht\n\nlemma weaktype_estimate_trunc_top_top {a : \u211d} {C\u2081 : \u211d\u22650}\n    (hC\u2081 : C\u2081 > 0) {p p\u2081 q\u2081 : \u211d\u22650\u221e} (hp : 0 < p)\n    (hp\u2081 : p\u2081 = \u22a4) (hq\u2081 : q\u2081 = \u22a4) (hp\u2081p : p < p\u2081) {f : \u03b1 \u2192 E\u2081} (hf : Mem\u2112p f p \u03bc)\n    (h\u2081T : HasWeakType T p\u2081 q\u2081 \u03bc \u03bd C\u2081) {t : \u211d} (ht : t > 0) (ha : a = t / C\u2081) :\n    distribution (T (trunc f a)) (ENNReal.ofReal t) \u03bd = 0 := by\n  rw [ha]\n  have obs : Mem\u2112p (trunc f (t / C\u2081)) p\u2081 \u03bc := trunc_Lp_Lq_higher \u27e8hp, hp\u2081p\u27e9 hf\n  have wt_est := (h\u2081T (trunc f (t / C\u2081)) obs).2\n  simp only [wnorm, eLpNorm, hq\u2081, \u2193reduceIte, hp\u2081, top_ne_zero] at wt_est\n  apply nonpos_iff_eq_zero.mp\n  have ineq : eLpNormEssSup (T (trunc f (t / C\u2081))) \u03bd \u2264 ENNReal.ofReal t := calc\n    _ \u2264 C\u2081 * eLpNormEssSup (trunc f (t / C\u2081)) \u03bc := wt_est\n    _ \u2264 C\u2081 * ENNReal.ofReal (max 0 (t / C\u2081)) := by\n      gcongr\n      exact trunc_eLpNormEssSup_le\n    _ \u2264 _ := by\n      let C := C\u2081.toReal\n      have coe_C : C.toNNReal = C\u2081 := Real.toNNReal_coe\n      rw [\u2190 coe_C, coe_coe_eq_ofReal, \u2190 ENNReal.ofReal_mul, max_eq_right, congrArg toReal coe_C,\n        mul_div_cancel\u2080]\n      \u00b7 exact Ne.symm (ne_of_lt hC\u2081)\n      \u00b7 positivity\n      \u00b7 positivity\n  calc\n  _ \u2264 distribution (T (trunc f (t / C\u2081))) (eLpNormEssSup (T (trunc f (t / C\u2081))) \u03bd) \u03bd :=\n      distribution_mono_right ineq\n  _ = 0 := distribution_snormEssSup\n\nlemma weaktype_estimate_trunc_compl_top {C\u2080 : \u211d\u22650} (hC\u2080 : C\u2080 > 0) {p p\u2080 q\u2080 : \u211d\u22650\u221e}\n    (hp\u2080 : 0 < p\u2080) (hq\u2080 : q\u2080 = \u22a4) (hp\u2080p : p\u2080 < p) (hp : p \u2260 \u22a4) {f : \u03b1 \u2192 E\u2081} (hf : Mem\u2112p f p \u03bc)\n    (h\u2080T : HasWeakType T p\u2080 q\u2080 \u03bc \u03bd C\u2080) {t : \u211d} (ht : t > 0) {a : \u211d} {d : \u211d} -- (hd : d > 0)\n    (ha : a = (t / d) ^ (p\u2080.toReal / (p\u2080.toReal - p.toReal)))\n    (hdeq : d = ((ENNReal.ofNNReal C\u2080) ^ p\u2080.toReal *\n        eLpNorm f p \u03bc ^ p.toReal).toReal ^ p\u2080.toReal\u207b\u00b9) :\n    distribution (T (f - trunc f a)) (ENNReal.ofReal t) \u03bd = 0 := by\n  rcases (eq_zero_or_pos (eLpNormEssSup f \u03bc)) with snorm_zero | snorm_pos\n  \u00b7 have : eLpNorm (trnc \u22a5 f a) \u22a4 \u03bc = 0 := by\n      apply nonpos_iff_eq_zero.mp\n      rw [\u2190 snorm_zero]\n      exact eLpNorm_trnc_est (p := \u22a4)\n    have obs : eLpNorm (T (trnc \u22a5 f a)) \u22a4 \u03bd = 0 :=\n      weaktype_aux\u2080 hp\u2080 (hq\u2080 \u25b8 zero_lt_top) zero_lt_top zero_lt_top h\u2080T\n        (aestronglyMeasurable_trunc_compl hf.1) this\n    exact nonpos_iff_eq_zero.mp (Trans.trans (distribution_mono_right (Trans.trans obs\n      (zero_le (ENNReal.ofReal t)))) meas_eLpNormEssSup_lt)\n  \u00b7 have p_pos : p > 0 := lt_trans hp\u2080 hp\u2080p\n    have snorm_p_pos : eLpNorm f p \u03bc \u2260 0 := fun snorm_0 \u21a6 snorm_pos.ne' <|\n      eLpNormEssSup_eq_zero_iff.mpr <| (eLpNorm_eq_zero_iff hf.1 p_pos.ne').mp snorm_0\n    have term_pos : (ENNReal.ofNNReal C\u2080) ^ p\u2080.toReal * eLpNorm f p \u03bc ^ p.toReal > 0 := by\n      apply ENNReal.mul_pos <;> exact (rpow_pos_of_nonneg (by positivity) (by positivity)).ne'\n    have term_ne_top : (ENNReal.ofNNReal C\u2080) ^ p\u2080.toReal * eLpNorm f p \u03bc ^ p.toReal \u2260 \u22a4\n        := mul_ne_top (rpow_ne_top' (ENNReal.coe_ne_zero.mpr hC\u2080.ne') coe_ne_top)\n          (rpow_ne_top' snorm_p_pos (Mem\u2112p.eLpNorm_ne_top hf))\n    have d_pos : d > 0 := hdeq \u25b8 Real.rpow_pos_of_pos (zero_toReal \u25b8\n      toReal_strict_mono term_ne_top term_pos) _\n    have a_pos : a > 0 := by rw [ha]; positivity\n    have obs : Mem\u2112p (f - trunc f a) p\u2080 \u03bc := trunc_compl_Lp_Lq_lower hp \u27e8hp\u2080, hp\u2080p\u27e9 a_pos hf\n    have wt_est := (h\u2080T (f - trunc f a) obs).2\n    unfold wnorm at wt_est\n    split_ifs at wt_est\n    have snorm_est : eLpNormEssSup (T (f - trunc f a)) \u03bd \u2264 ENNReal.ofReal t := by\n      apply le_of_rpow_le (exp_toReal_pos hp\u2080 hp\u2080p.ne_top)\n      calc\n      _ \u2264 (\u2191C\u2080 * eLpNorm (f - trunc f a) p\u2080 \u03bc) ^ p\u2080.toReal := by gcongr\n      _ \u2264 (\u2191C\u2080) ^ p\u2080.toReal * (ENNReal.ofReal (a ^ (p\u2080.toReal - p.toReal)) *\n          eLpNorm f p \u03bc ^ p.toReal) := by\n        rw [ENNReal.mul_rpow_of_nonneg _ _ toReal_nonneg]\n        gcongr\n        exact estimate_eLpNorm_trunc_compl hp \u27e8hp\u2080, hp\u2080p\u27e9 hf.1.aemeasurable a_pos\n      _ = (\u2191C\u2080) ^ p\u2080.toReal * eLpNorm f p \u03bc ^ p.toReal *\n          (ENNReal.ofReal (d ^ p\u2080.toReal))\u207b\u00b9 * ENNReal.ofReal (t ^ p\u2080.toReal) := by\n        rw [ha, \u2190 Real.rpow_mul, div_mul_cancel\u2080]\n        \u00b7 rw [Real.div_rpow] <;> try positivity\n          rw [ENNReal.ofReal_div_of_pos] <;> try positivity\n          rw [div_eq_mul_inv]\n          ring\n        \u00b7 exact (sub_neg.mpr (toReal_strict_mono hp hp\u2080p)).ne\n        \u00b7 positivity\n      _ = _ := by\n        rw [ofReal_rpow_of_pos ht]\n        nth_rw 3 [\u2190 one_mul (ENNReal.ofReal _)]\n        rw [hdeq]\n        rw [Real.rpow_inv_rpow] <;> try positivity\n        rw [ofReal_toReal term_ne_top, ENNReal.mul_inv_cancel (by positivity) term_ne_top]\n        exact toReal_ne_zero.mpr \u27e8hp\u2080.ne', hp\u2080p.ne_top\u27e9\n    apply nonpos_iff_eq_zero.mp\n    calc\n    _ \u2264 distribution (T (f - trunc f a)) (eLpNormEssSup (T (f - trunc f a)) \u03bd) \u03bd :=\n      distribution_mono_right snorm_est\n    _ = _ := meas_eLpNormEssSup_lt\n\nlemma weaktype_estimate_trunc_top {C\u2081 : \u211d\u22650} (hC\u2081 : C\u2081 > 0) {p p\u2081 q\u2081 : \u211d\u22650\u221e}\n    (hp : 0 < p)\n    (hp\u2081 : p\u2081 < \u22a4) (hq\u2081 : q\u2081 = \u22a4) (hp\u2081p : p < p\u2081) {f : \u03b1 \u2192 E\u2081} (hf : Mem\u2112p f p \u03bc)\n    (h\u2081T : HasWeakType T p\u2081 q\u2081 \u03bc \u03bd C\u2081) {t : \u211d} (ht : t > 0) {a : \u211d} {d : \u211d} -- (hd : d > 0)\n    (ha : a = (t / d) ^ (p\u2081.toReal / (p\u2081.toReal - p.toReal)))\n    (hdeq : d = ((ENNReal.ofNNReal C\u2081) ^ p\u2081.toReal *\n        eLpNorm f p \u03bc ^ p.toReal).toReal ^ p\u2081.toReal\u207b\u00b9) :\n    distribution (T (trunc f a)) (ENNReal.ofReal t) \u03bd = 0 := by\n  have obs : Mem\u2112p (trunc f a) p\u2081 \u03bc := trunc_Lp_Lq_higher \u27e8hp, hp\u2081p\u27e9 hf\n  have wt_est := (h\u2081T (trunc f a) obs).2\n  unfold wnorm at wt_est\n  split_ifs at wt_est\n  have : p\u2081.toReal \u2260 0 := exp_toReal_ne_zero' (lt_trans hp hp\u2081p) hp\u2081.ne_top\n  have : eLpNormEssSup (T (trunc f a)) \u03bd ^ p\u2081.toReal \u2264 (\u2191C\u2081 * eLpNorm (trunc f a) p\u2081 \u03bc) ^ p\u2081.toReal\n      := by gcongr\n  have snorm_est : eLpNormEssSup (T (trunc f a)) \u03bd \u2264 ENNReal.ofReal t := by\n    apply le_of_rpow_le (exp_toReal_pos (lt_trans hp hp\u2081p) hp\u2081.ne_top)\n    refine le_trans this ?_\n    rcases (eq_zero_or_pos (eLpNormEssSup f \u03bc)) with snorm_zero | snorm_pos\n    \u00b7 gcongr\n      calc\n      _ \u2264 (ENNReal.ofNNReal C\u2081) * eLpNorm f p\u2081 \u03bc := by\n        gcongr\n        apply eLpNorm_mono (fun x \u21a6 trunc_le_func)\n      _ \u2264 _ := by\n        have : eLpNorm f p\u2081 \u03bc = 0 := Trans.trans (eLpNorm_congr_ae\n            (eLpNormEssSup_eq_zero_iff.mp snorm_zero)) eLpNorm_zero\n        simp only [this, mul_zero, zero_le]\n    \u00b7 have snorm_p_pos : eLpNorm f p \u03bc \u2260 0 := by\n        intro snorm_0\n        apply Ne.symm (ne_of_lt snorm_pos)\n        apply eLpNormEssSup_eq_zero_iff.mpr\n        exact (eLpNorm_eq_zero_iff hf.1 hp.ne').mp snorm_0\n      have term_pos : (ENNReal.ofNNReal C\u2081) ^ p\u2081.toReal * eLpNorm f p \u03bc ^ p.toReal > 0 := by\n        apply ENNReal.mul_pos <;> exact (rpow_pos_of_nonneg (by positivity) (by positivity)).ne'\n      have term_ne_top : (ENNReal.ofNNReal C\u2081) ^ p\u2081.toReal * eLpNorm f p \u03bc ^ p.toReal \u2260 \u22a4 :=\n        mul_ne_top (rpow_ne_top' (ENNReal.coe_ne_zero.mpr hC\u2081.ne') coe_ne_top)\n          (rpow_ne_top' snorm_p_pos (Mem\u2112p.eLpNorm_ne_top hf))\n      have d_pos : d > 0 := hdeq \u25b8 Real.rpow_pos_of_pos (zero_toReal \u25b8\n        toReal_strict_mono term_ne_top term_pos) _\n      calc\n      _ \u2264 \u2191C\u2081 ^ p\u2081.toReal * ((ENNReal.ofReal (a ^ (p\u2081.toReal - p.toReal))) * eLpNorm f p \u03bc ^ p.toReal) := by\n        rw [ENNReal.mul_rpow_of_nonneg]\n        gcongr\n        \u00b7 exact estimate_eLpNorm_trunc hp\u2081.ne_top \u27e8hp, hp\u2081p\u27e9 hf.1.aemeasurable\n        \u00b7 exact toReal_nonneg\n      _ = \u2191C\u2081 ^ p\u2081.toReal * eLpNorm f p \u03bc ^ p.toReal * (ENNReal.ofReal (d ^ p\u2081.toReal))\u207b\u00b9 *\n          ENNReal.ofReal (t ^ p\u2081.toReal) := by\n        rw [ha, \u2190 Real.rpow_mul, div_mul_cancel\u2080]\n        \u00b7 rw [Real.div_rpow] <;> try positivity\n          rw [ENNReal.ofReal_div_of_pos] <;> try positivity\n          rw [div_eq_mul_inv]\n          ring\n        \u00b7 exact (sub_pos.mpr (toReal_strict_mono hp\u2081.ne_top hp\u2081p)).ne'\n        \u00b7 positivity\n      _ = _ := by\n        rw [ofReal_rpow_of_pos ht]\n        nth_rw 3 [\u2190 one_mul (ENNReal.ofReal _)]\n        rw [hdeq]\n        rw [Real.rpow_inv_rpow] <;> try positivity\n        rw [ofReal_toReal term_ne_top, ENNReal.mul_inv_cancel (by positivity) term_ne_top]\n  apply nonpos_iff_eq_zero.mp\n  calc\n  _ \u2264 distribution (T (trunc f a)) (eLpNormEssSup (T (trunc f a)) \u03bd) \u03bd := by gcongr\n  _ = _ := meas_eLpNormEssSup_lt\n\nend MeasureTheory\n\nend\n\nnoncomputable section\n\nopen NNReal ENNReal MeasureTheory Set Pointwise\n\nvariable {\u03b1 \u03b1' \u03b5 E E\u2081 E\u2082 E\u2083 : Type*} {m : MeasurableSpace \u03b1} {m' : MeasurableSpace \u03b1'}\n  {p p' q p\u2080 q\u2080 p\u2081 q\u2081: \u211d\u22650\u221e}\n  {C\u2080 C\u2081 : \u211d\u22650} {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b1'}\n  {a : \u211d}-- truncation parameter\n  [NormedAddCommGroup E] [NormedAddCommGroup E\u2081] [NormedAddCommGroup E\u2082] [NormedAddCommGroup E\u2083]\n  [MeasurableSpace E] [BorelSpace E]\n  [MeasurableSpace E\u2083] [BorelSpace E\u2083]\n  {f : \u03b1 \u2192 E\u2081} {t : \u211d}\n  {T : (\u03b1 \u2192 E\u2081) \u2192 (\u03b1' \u2192 E\u2082)}\nnamespace MeasureTheory\n\n-- /-- # The real interpolation theorem\n\n-- ## Definitions-/\n\ndef Subadditive [ENorm \u03b5] (T : (\u03b1 \u2192 E\u2081) \u2192 \u03b1' \u2192 \u03b5) : Prop :=\n  \u2203 A \u2260 \u22a4, \u2200 (f g : \u03b1 \u2192 E\u2081) (x : \u03b1'), \u2016T (f + g) x\u2016\u2091 \u2264 A * (\u2016T f x\u2016\u2091 + \u2016T g x\u2016\u2091)\n\ndef Subadditive_trunc [ENorm \u03b5] (T : (\u03b1 \u2192 E\u2081) \u2192 \u03b1' \u2192 \u03b5) (A : \u211d\u22650\u221e) (f : \u03b1 \u2192 E\u2081) (\u03bd : Measure \u03b1') :\n    Prop :=\n  \u2200 a : \u211d, a > 0 \u2192 \u2200\u1d50 y \u2202\u03bd,\n  \u2016T (trunc f a + trunc_compl f a) y\u2016\u2091 \u2264 A * (\u2016T (trunc f a) y\u2016\u2091 + \u2016T (trunc_compl f a) y\u2016\u2091)\n\n/-- The operator is subadditive on functions satisfying `P` with constant `A`\n(this is almost vacuous if `A = \u22a4`). -/\ndef AESubadditiveOn [ENorm \u03b5] (T : (\u03b1 \u2192 E\u2081) \u2192 \u03b1' \u2192 \u03b5) (P : (\u03b1 \u2192 E\u2081) \u2192 Prop) (A : \u211d\u22650\u221e)\n    (\u03bd : Measure \u03b1') : Prop :=\n  \u2200 (f g : \u03b1 \u2192 E\u2081), P f \u2192 P g \u2192 \u2200\u1d50 x \u2202\u03bd, \u2016T (f + g) x\u2016\u2091 \u2264 A * (\u2016T f x\u2016\u2091 + \u2016T g x\u2016\u2091)\n\nnamespace AESubadditiveOn\n\nvariable [ENormedAddMonoid \u03b5] {\u03bd : Measure \u03b1'}\n\nlemma antitone {T : (\u03b1 \u2192 E\u2081) \u2192 \u03b1' \u2192 \u03b5} {P P' : (\u03b1 \u2192 E\u2081) \u2192 Prop}\n    (h : \u2200 {u : \u03b1 \u2192 E\u2081}, P u \u2192 P' u) {A : \u211d\u22650\u221e} (sa : AESubadditiveOn T P' A \u03bd) :\n    AESubadditiveOn T P A \u03bd :=\n  fun f g hf hg \u21a6 sa f g (h hf) (h hg)\n\nlemma zero {P : (\u03b1 \u2192 E\u2081) \u2192 Prop} (hP : \u2200 {f g : \u03b1 \u2192 E\u2081}, P f \u2192 P g \u2192 P (f + g))\n    (A : \u211d\u22650\u221e) (h : \u2200 u, P u \u2192 T u =\u1d50[\u03bd] 0) : AESubadditiveOn T P A \u03bd := by\n  intro f g hf hg\n  filter_upwards [h f hf, h g hg, h (f + g) (hP hf hg)] with x hx1 hx2 hx3\n  simp [hx1, hx2, hx3]\n\nlemma forall_le {\u03b9 : Type*} {\ud835\udcd1 : Set \u03b9} (h\ud835\udcd1 : \ud835\udcd1.Countable) {T : \u03b9 \u2192 (\u03b1 \u2192 E\u2081) \u2192 \u03b1' \u2192 \u03b5}\n    {P : (\u03b1 \u2192 E\u2081) \u2192 Prop} {A : \u211d\u22650\u221e}\n    (h : \u2200 i \u2208 \ud835\udcd1, AESubadditiveOn (T i) P A \u03bd)\n    {f g : \u03b1 \u2192 E\u2081} (hf : P f) (hg : P g) :\n    \u2200\u1d50 x \u2202\u03bd, \u2200 i \u2208 \ud835\udcd1, \u2016T i (f + g) x\u2016\u2091 \u2264 A * (\u2016T i f x\u2016\u2091 + \u2016T i g x\u2016\u2091) :=\n  eventually_countable_ball h\ud835\udcd1 |>.mpr fun i hi \u21a6 h i hi f g hf hg\n\nlemma biSup {\u03b9 : Type*} {\ud835\udcd1 : Set \u03b9} (h\ud835\udcd1 : \ud835\udcd1.Countable) {T : \u03b9 \u2192 (\u03b1 \u2192 E\u2081) \u2192 \u03b1' \u2192 \u211d\u22650\u221e}\n    {P : (\u03b1 \u2192 E\u2081) \u2192 Prop} (hT : \u2200 (u : \u03b1 \u2192 E\u2081), P u \u2192 \u2200\u1d50 x \u2202\u03bd, \u2a06 i \u2208 \ud835\udcd1, T i u x \u2260 \u221e)\n    (hP : \u2200 {f g : \u03b1 \u2192 E\u2081}, P f \u2192 P g \u2192 P (f + g))\n    {A : \u211d\u22650\u221e} (h : \u2200 i \u2208 \ud835\udcd1, AESubadditiveOn (T i) P A \u03bd) :\n    AESubadditiveOn (fun u x \u21a6 \u2a06 i \u2208 \ud835\udcd1, T i u x) P A \u03bd := by\n  have hT' : \u2200 i \u2208 \ud835\udcd1, \u2200 (u : \u03b1 \u2192 E\u2081), P u \u2192 \u2200\u1d50 x \u2202\u03bd, T i u x \u2260 \u221e := by\n    intro i hi f hf\n    filter_upwards [hT f hf] with x hx\n    rw [ne_eq, eq_top_iff] at hx \u22a2\n    exact fun h \u21a6 hx <| h.trans (le_biSup (fun i \u21a6 T i f x) hi)\n  -- rcases lt_or_le A 0 with A0 | A0\n  -- \u00b7 refine AESubadditiveOn.zero hP A (fun f hf \u21a6 ?_)\n  --   have h (i : \u03b9) (hi : i \u2208 \ud835\udcd1) := (h i hi).neg _ A0\n  --   simp_rw [Set.forall_in_swap, imp.swap, \u2190 imp_forall_iff] at h hT'\n  --   filter_upwards [(ae_ball_iff h\ud835\udcd1).mpr (h f hf), (ae_ball_iff h\ud835\udcd1).mpr (hT' f hf)] with x hx hx'\n  --   simp only [Pi.zero_apply, toReal_eq_zero_iff, ENNReal.iSup_eq_zero]\n  --   refine Or.inl fun i hi \u21a6 ?_\n  --   have := (ENNReal.toReal_eq_zero_iff _).mp (hx i hi)\n  --   tauto\n  intro f g hf hg\n  simp_rw [AESubadditiveOn, Set.forall_in_swap, imp.swap, \u2190 imp_forall_iff] at h hT'\n  specialize h f hf g hg\n  simp_rw [enorm_eq_self] at h \u22a2\n  filter_upwards [hT f hf, hT g hg, (ae_ball_iff h\ud835\udcd1).mpr h, (ae_ball_iff h\ud835\udcd1).mpr (hT' f hf),\n    (ae_ball_iff h\ud835\udcd1).mpr (hT' g hg), (ae_ball_iff h\ud835\udcd1).mpr (hT' (f + g) (hP hf hg))] with x hTfx hTgx hx hT'fx hT'gx hT'fgx\n  simp_rw [iSup_le_iff]\n  intro i hi\n  specialize hx i hi\n  apply hx.trans\n  gcongr <;> apply le_biSup _ hi\n\nlemma indicator {T : (\u03b1 \u2192 E\u2081) \u2192 \u03b1' \u2192 \u03b5} {P : (\u03b1 \u2192 E\u2081) \u2192 Prop} {A : \u211d\u22650\u221e}\n    (sa : AESubadditiveOn T P A \u03bd) (S : Set \u03b1') :\n    AESubadditiveOn (fun u x \u21a6 (S.indicator (fun y \u21a6 T u y) x)) P A \u03bd := by\n  intro f g hf hg\n  filter_upwards [sa f g hf hg] with x hx\n  by_cases h : x \u2208 S <;> simp [hx, h]\n\n-- If `T` is constant in the second argument (but not necessarily the first) and satisfies\n-- a subadditivity criterion, then `AESubadditiveOn T P 1`\nlemma const (T : (\u03b1 \u2192 E\u2081) \u2192 \u03b5) (P : (\u03b1 \u2192 E\u2081) \u2192 Prop)\n    (h_add : \u2200 {f g}, P f \u2192 P g \u2192 \u2016T (f + g)\u2016\u2091 \u2264 \u2016T f\u2016\u2091 + \u2016T g\u2016\u2091) :\n    AESubadditiveOn (fun u (_ : \u03b1') \u21a6 T u) P 1 \u03bd :=\n  fun f g hf hg \u21a6 ae_of_all _ fun _ \u21a6 (by simpa using h_add hf hg)\n\nend AESubadditiveOn\n\nvariable [NormedSpace \u211d E\u2081] [NormedSpace \u211d E\u2082] [ENormedSpace \u03b5]\n\n/-- The operator is sublinear on functions satisfying `P` with constant `A`. -/\ndef AESublinearOn (T : (\u03b1 \u2192 E\u2081) \u2192 \u03b1' \u2192 \u03b5) (P : (\u03b1 \u2192 E\u2081) \u2192 Prop) (A : \u211d\u22650\u221e) (\u03bd : Measure \u03b1') :\n    Prop :=\n  AESubadditiveOn T P A \u03bd \u2227 \u2200 (f : \u03b1 \u2192 E\u2081) (c : \u211d\u22650), P f \u2192 T (c \u2022 f) =\u1d50[\u03bd] c \u2022 T f\n\nnamespace AESublinearOn\n\nvariable {\u03bd : Measure \u03b1'}\n\nlemma antitone {T : (\u03b1 \u2192 E\u2081) \u2192 \u03b1' \u2192 \u03b5} {P P' : (\u03b1 \u2192 E\u2081) \u2192 Prop}\n    (h : \u2200 {u : \u03b1 \u2192 E\u2081}, P u \u2192 P' u) {A : \u211d\u22650\u221e} (sl : AESublinearOn T P' A \u03bd) :\n    AESublinearOn T P A \u03bd :=\n  \u27e8sl.1.antitone (fun hu \u21a6 h hu), fun u c hu \u21a6 sl.2 u c (h hu)\u27e9\n\nlemma biSup {\u03b9 : Type*} {\ud835\udcd1 : Set \u03b9} (h\ud835\udcd1 : \ud835\udcd1.Countable) {T : \u03b9 \u2192 (\u03b1 \u2192 E\u2081) \u2192 \u03b1' \u2192 \u211d\u22650\u221e}\n    {P : (\u03b1 \u2192 E\u2081) \u2192 Prop} (hT : \u2200 (u : \u03b1 \u2192 E\u2081), P u \u2192 \u2200\u1d50 x \u2202\u03bd, \u2a06 i \u2208 \ud835\udcd1, T i u x \u2260 \u221e)\n    (h_add : \u2200 {f g : \u03b1 \u2192 E\u2081}, P f \u2192 P g \u2192 P (f + g))\n    (h_smul : \u2200 {f : \u03b1 \u2192 E\u2081} {c : \u211d\u22650}, P f \u2192 P (c \u2022 f))\n    {A : \u211d\u22650\u221e} (h : \u2200 i \u2208 \ud835\udcd1, AESublinearOn (T i) P A \u03bd) :\n    AESublinearOn (fun u x \u21a6 \u2a06 i \u2208 \ud835\udcd1, T i u x) P A \u03bd := by\n  have hT' : \u2200 i \u2208 \ud835\udcd1, \u2200 (u : \u03b1 \u2192 E\u2081), P u \u2192 \u2200\u1d50 x \u2202\u03bd, T i u x \u2260 \u221e := by\n    intro i hi f hf\n    filter_upwards [hT f hf] with x hx\n    rw [ne_eq, eq_top_iff] at hx \u22a2\n    exact fun h \u21a6 hx <| h.trans (le_biSup (fun i \u21a6 T i f x) hi)\n  refine \u27e8AESubadditiveOn.biSup h\ud835\udcd1 hT h_add (fun i hi \u21a6 (h i hi).1), fun f c hf \u21a6 ?_\u27e9\n  simp_rw [Set.forall_in_swap, imp.swap, \u2190 imp_forall_iff] at hT'\n  filter_upwards [(ae_ball_iff h\ud835\udcd1).mpr (fun i hi \u21a6 (h i hi).2 f c hf),\n    (ae_ball_iff h\ud835\udcd1).mpr (hT' f hf), (ae_ball_iff h\ud835\udcd1).mpr (hT' (c \u2022 f) (h_smul hf))] with x hx hT'fx hT'cfx\n  simp_rw [Pi.smul_apply, ENNReal.smul_iSup]\n  refine biSup_congr (fun i hi \u21a6 ?_)\n  specialize hx i hi\n  simpa only [Pi.smul_apply, smul_eq_mul] using hx\n\n", "theoremStatement": "lemma biSup2 {\u03b9 : Type*} {\ud835\udcd1 : Set \u03b9} (h\ud835\udcd1 : \ud835\udcd1.Countable) {T : \u03b9 \u2192 (\u03b1 \u2192 E\u2081) \u2192 \u03b1' \u2192 \u211d\u22650\u221e}\n    {P : (\u03b1 \u2192 E\u2081) \u2192 Prop} {Q : (\u03b1 \u2192 E\u2081) \u2192 Prop}\n    (hPT : \u2200 (u : \u03b1 \u2192 E\u2081), P u \u2192 \u2200\u1d50 x \u2202\u03bd, \u2a06 i \u2208 \ud835\udcd1, T i u x \u2260 \u221e)\n    (hQT : \u2200 (u : \u03b1 \u2192 E\u2081), Q u \u2192 \u2200\u1d50 x \u2202\u03bd, \u2a06 i \u2208 \ud835\udcd1, T i u x \u2260 \u221e)\n    (P0 : P 0)\n    (Q0 : Q 0)\n    (haP : \u2200 {f g : \u03b1 \u2192 E\u2081}, P f \u2192 P g \u2192 P (f + g))\n    (haQ : \u2200 {f g : \u03b1 \u2192 E\u2081}, Q f \u2192 Q g \u2192 Q (f + g))\n    (hsP : \u2200 {f : \u03b1 \u2192 E\u2081} {c : \u211d\u22650}, P f \u2192 P (c \u2022 f))\n    (hsQ : \u2200 {f : \u03b1 \u2192 E\u2081} {c : \u211d\u22650}, Q f \u2192 Q (c \u2022 f))\n    {A : \u211d\u22650} -- todo, here and elsewhere: probably better to have {A : \u211d\u22650\u221e} (hA : A \u2260 \u22a4)\n    (hAP : \u2200 i \u2208 \ud835\udcd1,\n      AESublinearOn (T i) (fun g \u21a6 g \u2208 {f | P f} + {f | Q f}) A \u03bd) :\n    AESublinearOn (fun u x \u21a6 \u2a06 i \u2208 \ud835\udcd1, T i u x) (fun f \u21a6 P f \u2228 Q f) A \u03bd ", "theoremName": "MeasureTheory.AESublinearOn.biSup2", "fileCreated": {"commit": "1a36cbeaee9466fb56c9aca49ef373f9f9cc7ab7", "date": "2025-01-23"}, "theoremCreated": {"commit": "b069d5bb71885f498386762866228ac78bf5409e", "date": "2025-01-13"}, "file": "carleson/Carleson/ToMathlib/RealInterpolation.lean", "module": "Carleson.ToMathlib.RealInterpolation", "jsonFile": "Carleson.ToMathlib.RealInterpolation.jsonl", "positionMetadata": {"lineInFile": 3145, "tokenPositionInFile": 140684, "theoremPositionInFile": 245}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 5, "repositoryPremises": true, "numRepositoryPremises": 16, "numPremises": 233}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  set R := fun g \u21a6 g \u2208 {f | P f} + {f | Q f}\n  have hPR : \u2200 {f}, P f \u2192 R f := fun hu \u21a6 \u27e8_, hu, 0, Q0, by simp\u27e9\n  have hQR : \u2200 {f}, Q f \u2192 R f := fun hu \u21a6 \u27e80, P0, _, hu, by simp\u27e9\n  apply AESublinearOn.antitone (P' := R) (fun hu \u21a6 hu.elim hPR hQR)\n  refine AESublinearOn.biSup (P := R) h\ud835\udcd1 ?_ ?_ ?_ hAP\n  \u00b7 rintro _ \u27e8f, hf, g, hg, rfl\u27e9\n    filter_upwards [hPT f hf, hQT g hg,\n      AESubadditiveOn.forall_le h\ud835\udcd1 (fun i hi \u21a6 hAP i hi |>.1) (hPR hf) (hQR hg)] with x hfx hgx hTx\n    simp_rw [\u2190 lt_top_iff_ne_top] at hfx hgx \u22a2\n    simp_rw [enorm_eq_self] at hTx\n    calc\n      _ \u2264 \u2a06 i \u2208 \ud835\udcd1, A * (T i f x + T i g x) := by gcongr; exact hTx _ \u2039_\u203a\n      _ \u2264 A * ((\u2a06 i \u2208 \ud835\udcd1, T i f x) + (\u2a06 i \u2208 \ud835\udcd1, T i g x)) := by\n          simp_rw [\u2190 ENNReal.mul_iSup]\n          gcongr\n          -- todo: make lemma\n          simp_rw [iSup_le_iff]\n          intro i hi\n          gcongr <;> apply le_biSup _ hi\n      _ < \u22a4 := mul_lt_top coe_lt_top <| add_lt_top.mpr \u27e8hfx, hgx\u27e9\n  \u00b7 rintro _ _ \u27e8f\u2081, hf\u2081, g\u2081, hg\u2081, rfl\u27e9 \u27e8f\u2082, hf\u2082, g\u2082, hg\u2082, rfl\u27e9\n    exact \u27e8f\u2081 + f\u2082, haP hf\u2081 hf\u2082, g\u2081 + g\u2082, haQ hg\u2081 hg\u2082, by abel_nf\u27e9\n  \u00b7 rintro _ c \u27e8f, hf, g, hg, rfl\u27e9\n    exact \u27e8c \u2022 f, hsP hf, c \u2022 g, hsQ hg, by module\u27e9", "proofType": "tactic", "proofLengthLines": 24, "proofLengthTokens": 1166}}
{"srcContext": "import Carleson.ToMathlib.DoublingMeasure\nimport Carleson.ToMathlib.WeakType\nimport Mathlib.Algebra.Order.Group.Int\nimport Mathlib.Analysis.CStarAlgebra.Classes\nimport Mathlib.Data.Int.Star\n\nopen MeasureTheory Measure NNReal Metric Complex Set TopologicalSpace Bornology Function\nopen scoped ENNReal\nnoncomputable section\n\n-- todo: rename and protect `Real.RCLike`\n\n/-! Miscellaneous definitions.\nThese are mostly the definitions used to state the metric Carleson theorem.\nWe should move them to separate files once we start proving things about them. -/\n\nsection DoublingMeasure\nuniverse u\n\nvariable {\ud835\udd5c X : Type*} {A : \u2115} [_root_.RCLike \ud835\udd5c] [PseudoMetricSpace X]\n\nsection localOscillation\n\n/-- The local oscillation of two functions w.r.t. a set `E`. This is `d_E` in the blueprint. -/\ndef localOscillation (E : Set X) (f g : C(X, \ud835\udd5c)) : \u211d\u22650\u221e :=\n  \u2a06 z \u2208 E \u00d7\u02e2 E, ENNReal.ofReal \u2016f z.1 - g z.1 - f z.2 + g z.2\u2016\n\n-- example (E : Set X) (hE : IsBounded E) (f : C(X, \u211d)) :\n--     BddAbove (range fun z : E \u21a6 f z) := by\n--   have : IsCompact (closure E) := IsBounded.isCompact_closure hE\n--   sorry\n\n-- lemma bddAbove_localOscillation (E : Set X) [Fact (IsBounded E)] (f g : C(X, \ud835\udd5c)) :\n--     BddAbove ((fun z : X \u00d7 X \u21a6 \u2016f z.1 - g z.1 - f z.2 + g z.2\u2016) '' E \u00d7\u02e2 E) := sorry\n\nvariable {E : Set X} {f g : C(X, \ud835\udd5c)}\n\n--old\n/-- A ball w.r.t. the distance `localOscillation` -/\ndef localOscillationBall (E : Set X) (f : C(X, \ud835\udd5c)) (r : \u211d) :\n    Set C(X, \ud835\udd5c) :=\n  { g : C(X, \ud835\udd5c) | localOscillation E f g < ENNReal.ofReal r }\n\nend localOscillation\n\nlemma fact_isCompact_ball (x : X) (r : \u211d) : Fact (IsBounded (ball x r)) :=\n  \u27e8isBounded_ball\u27e9\nattribute [local instance] fact_isCompact_ball\n\n/-- A class stating that continuous functions have distances associated to every ball.\nWe use a separate type to conveniently index these functions. -/\nclass FunctionDistances (\ud835\udd5c : outParam Type*) (X : Type u)\n    [NormedField \ud835\udd5c] [TopologicalSpace X] where\n  \u0398 : Type u\n  coe\u0398 : \u0398 \u2192 C(X, \ud835\udd5c)\n  coe\u0398_injective {f g : \u0398} (h : \u2200 x, coe\u0398 f x = coe\u0398 g x) : f = g\n  metric : \u2200 (_x : X) (_r : \u211d), PseudoMetricSpace \u0398\n\nexport FunctionDistances (\u0398 coe\u0398)\n\nsection FunctionDistances\nvariable [FunctionDistances \ud835\udd5c X]\n\ninstance : Coe (\u0398 X) C(X, \ud835\udd5c) := \u27e8FunctionDistances.coe\u0398\u27e9\ninstance : FunLike (\u0398 X) X \ud835\udd5c where\n  coe := fun f \u21a6 (f : C(X, \ud835\udd5c))\n  coe_injective' _ _ hfg := FunctionDistances.coe\u0398_injective fun x \u21a6 congrFun hfg x\ninstance : ContinuousMapClass (\u0398 X) X \ud835\udd5c := \u27e8fun f \u21a6 (f : C(X, \ud835\udd5c)).2\u27e9\n\nset_option linter.unusedVariables false in\n@[nolint unusedArguments]\ndef WithFunctionDistance (x : X) (r : \u211d) := \u0398 X\n\nvariable {x : X} {r : \u211d}\n\ndef toWithFunctionDistance [FunctionDistances \ud835\udd5c X] : \u0398 X \u2243 WithFunctionDistance x r :=\n  .refl _\n\n-- instance : FunLike (WithFunctionDistance \u0398 x r) X \ud835\udd5c := ContinuousMap.funLike\n-- instance : ContinuousMapClass (WithFunctionDistance \u0398 x r) X \ud835\udd5c :=\n--   ContinuousMap.toContinuousMapClass\n\ninstance [d : FunctionDistances \ud835\udd5c X] : PseudoMetricSpace (WithFunctionDistance x r) :=\n  d.metric x r\n\nend FunctionDistances\n\nnotation3 \"dist_{\" x \" ,\" r \"}\" => @dist (WithFunctionDistance x r) _\nnotation3 \"nndist_{\" x \" ,\" r \"}\" => @nndist (WithFunctionDistance x r) _\nnotation3 \"ball_{\" x \" ,\" r \"}\" => @ball (WithFunctionDistance x r) _ in\n\n/-- A set `\u0398` of (continuous) functions is compatible. `A` will usually be `2 ^ a`. -/\nclass CompatibleFunctions (\ud835\udd5c : outParam Type*) (X : Type u) (A : outParam \u2115)\n  [RCLike \ud835\udd5c] [PseudoMetricSpace X] extends FunctionDistances \ud835\udd5c X where\n  eq_zero : \u2203 o : X, \u2200 f : \u0398, f o = 0\n  /-- The distance is bounded below by the local oscillation. (1.0.7) -/\n  localOscillation_le_cdist {x : X} {r : \u211d} {f g : \u0398} :\n    localOscillation (ball x r) (coe\u0398 f) (coe\u0398 g) \u2264 ENNReal.ofReal (dist_{x, r} f g)\n  /-- The distance is monotone in the ball. (1.0.9) -/\n  cdist_mono {x\u2081 x\u2082 : X} {r\u2081 r\u2082 : \u211d} {f g : \u0398}\n    (h : ball x\u2081 r\u2081 \u2286 ball x\u2082 r\u2082) : dist_{x\u2081, r\u2081} f g \u2264 dist_{x\u2082, r\u2082} f g\n  /-- The distance of a ball with large radius is bounded above. (1.0.8) -/\n  cdist_le {x\u2081 x\u2082 : X} {r : \u211d} {f g : \u0398} (h : dist x\u2081 x\u2082 < 2 * r) :\n    dist_{x\u2082, 2 * r} f g \u2264 A * dist_{x\u2081, r} f g\n  /-- The distance of a ball with large radius is bounded below. (1.0.10) -/\n  le_cdist {x\u2081 x\u2082 : X} {r : \u211d} {f g : \u0398} (h1 : ball x\u2081 r \u2286 ball x\u2082 (A * r)) :\n    /-(h2 : A * r \u2264 Metric.diam (univ : Set X))-/\n    2 * dist_{x\u2081, r} f g \u2264 dist_{x\u2082, A * r} f g\n  /-- The distance of a ball with large radius is bounded below. (1.0.11) -/\n  ballsCoverBalls {x : X} {r R : \u211d} :\n    BallsCoverBalls (X := WithFunctionDistance x r) (2 * R) R A\n\ninstance nonempty_Space [CompatibleFunctions \ud835\udd5c X A] : Nonempty X := by\n  obtain \u27e8x,_\u27e9 := \u2039CompatibleFunctions \ud835\udd5c X A\u203a.eq_zero\n  use x\n\ninstance inhabited_Space [CompatibleFunctions \ud835\udd5c X A] : Inhabited X :=\n  \u27e8nonempty_Space.some\u27e9\n\nlemma le_localOscillation [CompatibleFunctions \ud835\udd5c X A] (x : X) (r : \u211d) (f g : \u0398 X) {y z : X}\n    (hy : y \u2208 ball x r) (hz : z \u2208 ball x r) : \u2016coe\u0398 f y - coe\u0398 g y - coe\u0398 f z + coe\u0398 g z\u2016 \u2264\n    ENNReal.toReal (localOscillation (ball x r) (coe\u0398 f) (coe\u0398 g)) := by\n  rw [(ENNReal.toReal_ofReal (norm_nonneg _)).symm]\n  let f (z) := \u2a06 (_ : z \u2208 ball x r \u00d7\u02e2 ball x r), ENNReal.ofReal \u2016f z.1 - g z.1 - f z.2 + g z.2\u2016\n  apply ENNReal.toReal_mono\n  \u00b7 exact lt_of_le_of_lt CompatibleFunctions.localOscillation_le_cdist ENNReal.ofReal_lt_top |>.ne\n  \u00b7 exact le_of_eq_of_le (Eq.symm (iSup_pos \u27e8hy, hz\u27e9)) (le_iSup f \u27e8y, z\u27e9)\n\nlemma oscillation_le_cdist [CompatibleFunctions \ud835\udd5c X A] (x : X) (r : \u211d) (f g : \u0398 X) {y z : X}\n    (hy : y \u2208 ball x r) (hz : z \u2208 ball x r) :\n    \u2016coe\u0398 f y - coe\u0398 g y - coe\u0398 f z + coe\u0398 g z\u2016 \u2264 dist_{x, r} f g := by\n  apply le_trans <| le_localOscillation x r f g hy hz\n  rw [\u2190 ENNReal.toReal_ofReal dist_nonneg]\n  exact ENNReal.toReal_mono ENNReal.ofReal_ne_top CompatibleFunctions.localOscillation_le_cdist\n\nexport CompatibleFunctions (localOscillation_le_cdist cdist_mono cdist_le le_cdist)\n\nlemma dist_congr [FunctionDistances \ud835\udd5c X] {x\u2081 x\u2082 : X} {r\u2081 r\u2082 : \u211d} {f g : \u0398 X}\n    (e\u2081 : x\u2081 = x\u2082) (e\u2082 : r\u2081 = r\u2082) : dist_{x\u2081, r\u2081} f g = dist_{x\u2082, r\u2082} f g := by congr\n\nvariable (X) in\n/-- The point `o` in the blueprint -/\ndef cancelPt [CompatibleFunctions \ud835\udd5c X A] : X :=\n  CompatibleFunctions.eq_zero (\ud835\udd5c := \ud835\udd5c) |>.choose\nlemma cancelPt_eq_zero [CompatibleFunctions \ud835\udd5c X A] {f : \u0398 X} : f (cancelPt X) = 0 :=\n  CompatibleFunctions.eq_zero (\ud835\udd5c := \ud835\udd5c) |>.choose_spec f\n\n-- not sure if needed\n-- lemma CompatibleFunctions.IsSeparable [CompatibleFunctions \ud835\udd5c X A] :\n--   IsSeparable (range (coe\u0398 (X := X))) :=\n--   sorry\n\nset_option linter.unusedVariables false in\n/-- The inhomogeneous Lipschitz norm on a ball. -/\ndef iLipNorm {\ud835\udd5c} [NormedField \ud835\udd5c] (\u03d5 : X \u2192 \ud835\udd5c) (x\u2080 : X) (R : \u211d) : \u211d :=\n  (\u2a06 x \u2208 ball x\u2080 R, \u2016\u03d5 x\u2016) + R * \u2a06 (x : X) (y : X) (h : x \u2260 y), \u2016\u03d5 x - \u03d5 y\u2016 / dist x y\n\nlemma iLipNorm_nonneg {\ud835\udd5c} [NormedField \ud835\udd5c] {\u03d5 : X \u2192 \ud835\udd5c} {x\u2080 : X} {R : \u211d} (hR : 0 \u2264 R) :\n    0 \u2264 iLipNorm \u03d5 x\u2080 R :=\n  add_nonneg (Real.iSup_nonneg fun _ \u21a6 Real.iSup_nonneg fun _ \u21a6 norm_nonneg _)\n    (mul_nonneg hR (Real.iSup_nonneg fun _ \u21a6 Real.iSup_nonneg fun _ \u21a6 Real.iSup_nonneg\n    fun _ \u21a6 div_nonneg (norm_nonneg _) dist_nonneg))\n\nvariable [DoublingMeasure X A]\n\nvariable (X) in\n/-- \u0398 is \u03c4-cancellative. `\u03c4` will usually be `1 / a` -/\nclass IsCancellative (\u03c4 : \u211d) [CompatibleFunctions \u211d X A] : Prop where\n  norm_integral_exp_le {x : X} {r : \u211d} {\u03d5 : X \u2192 \u2102} {K : \u211d\u22650} (h1 : LipschitzWith K \u03d5)\n    (h2 : tsupport \u03d5 \u2286 ball x r) {f g : \u0398 X} :\n    \u2016\u222b x in ball x r, exp (I * (f x - g x)) * \u03d5 x\u2016 \u2264\n    A * volume.real (ball x r) * iLipNorm \u03d5 x r * (1 + dist_{x, r} f g) ^ (- \u03c4)\n\nexport IsCancellative (norm_integral_exp_le)\n\n/-- The \"volume function\" `V`. Note that we will need to assume\n`IsFiniteMeasureOnCompacts` and `ProperSpace` to actually know that this volume is finite. -/\ndef Real.vol {X : Type*} [PseudoMetricSpace X] [MeasureSpace X] (x y : X) : \u211d :=\n  volume.real (ball x (dist x y))\n\n-- /-- In Mathlib we only have the operator norm for continuous linear maps,\n-- and `T_*` is not linear.\n-- Here is the norm for an arbitrary map `T` between normed spaces\n-- (the infimum is defined to be 0 if the operator is not bounded). -/\n-- def operatorNorm {E F : Type*} [NormedAddCommGroup E] [NormedAddCommGroup F] (T : E \u2192 F) : \u211d :=\n--   sInf { c | 0 \u2264 c \u2227 \u2200 x, \u2016T x\u2016 \u2264 c * \u2016x\u2016 }\n\n/-- The Calderon Zygmund operator `T_r` in chapter Two-sided Metric Space Carleson -/\ndef CZOperator (K : X \u2192 X \u2192 \u2102) (r : \u211d) (f : X \u2192 \u2102) (x : X) : \u2102 :=\n  \u222b y in (ball x r)\u1d9c, K x y * f y\n\n/-- `R_Q(\u03b8, x)` defined in (1.0.20). -/\ndef upperRadius [FunctionDistances \u211d X] (Q : X \u2192 \u0398 X) (\u03b8 : \u0398 X) (x : X) : \u211d\u22650\u221e :=\n  \u2a06 (r : \u211d) (_ : dist_{x, r} \u03b8 (Q x) < 1), ENNReal.ofReal r\n\nlemma le_upperRadius [FunctionDistances \u211d X] {Q : X \u2192 \u0398 X} {\u03b8 : \u0398 X} {x : X} {r : \u211d}\n    (hr : dist_{x, r} \u03b8 (Q x) < 1) : ENNReal.ofReal r \u2264 upperRadius Q \u03b8 x := by\n  apply le_iSup\u2082 (f := fun r _ \u21a6 ENNReal.ofReal r) r hr\n\n/-- The linearized maximally truncated nontangential Calderon Zygmund operator `T_Q^\u03b8` -/\ndef linearizedNontangentialOperator [FunctionDistances \u211d X] (Q : X \u2192 \u0398 X) (\u03b8 : \u0398 X)\n    (K : X \u2192 X \u2192 \u2102) (f : X \u2192 \u2102) (x : X) : \u211d\u22650\u221e :=\n  \u2a06 (R\u2081 : \u211d) (x' : X) (_ : dist x x' \u2264 R\u2081),\n  \u2016\u222b y in {y | ENNReal.ofReal (dist x' y) \u2208 Ioo (ENNReal.ofReal R\u2081) (upperRadius Q \u03b8 x')},\n    K x' y * f y\u2016\u208a\n\n/-- The maximally truncated nontangential Calderon Zygmund operator `T_*` -/\ndef nontangentialOperator (K : X \u2192 X \u2192 \u2102) (f : X \u2192 \u2102) (x : X) : \u211d\u22650\u221e :=\n  \u2a06 (R\u2081 : \u211d) (R\u2082 : \u211d) (_ : R\u2081 < R\u2082) (x' : X) (_ : dist x x' < R\u2081),\n  \u2016\u222b y in {y | dist x' y \u2208 Ioo R\u2081 R\u2082}, K x' y * f y\u2016\u208a\n\n/-- The linearized generalized Carleson operator `T_Q`, taking values in `\u211d\u22650\u221e`.\nUse `ENNReal.toReal` to get the corresponding real number. -/\ndef linearizedCarlesonOperator [FunctionDistances \u211d X] (Q : X \u2192 \u0398 X) (K : X \u2192 X \u2192 \u2102)\n    (f : X \u2192 \u2102) (x : X) : \u211d\u22650\u221e :=\n  \u2a06 (R\u2081 : \u211d) (R\u2082 : \u211d) (_ : 0 < R\u2081) (_ : R\u2081 < R\u2082),\n  \u2016\u222b y in {y | dist x y \u2208 Ioo R\u2081 R\u2082}, K x y * f y * exp (I * Q x y)\u2016\u208a\n\n/-- The generalized Carleson operator `T`, taking values in `\u211d\u22650\u221e`.\nUse `ENNReal.toReal` to get the corresponding real number. -/\ndef carlesonOperator [FunctionDistances \u211d X] (K : X \u2192 X \u2192 \u2102) (f : X \u2192 \u2102) (x : X) : \u211d\u22650\u221e :=\n  \u2a06 (\u03b8 : \u0398 X), linearizedCarlesonOperator (fun _ \u21a6 \u03b8) K f x\n\n\nend DoublingMeasure\n\n/-- This is usually the value of the argument `A` in `DoublingMeasure`\nand `CompatibleFunctions` -/\n@[simp] abbrev defaultA (a : \u2115) : \u2115 := 2 ^ a\n@[simp] def defaultD (a : \u2115) : \u2115 := 2 ^ (100 * a ^ 2)\n@[simp] def default\u03ba (a : \u2115) : \u211d := 2 ^ (-10 * (a : \u211d))\n@[simp] def defaultZ (a : \u2115) : \u2115 := 2 ^ (12 * a)\n@[simp] def default\u03c4 (a : \u2115) : \u211d := a\u207b\u00b9\n\nlemma defaultD_pos (a : \u2115) : 0 < (defaultD a : \u211d) := by rw [defaultD]; positivity\n\nlemma defaultD_pos' (a : \u2115) : 0 < defaultD a := by exact_mod_cast defaultD_pos a\n\nlemma defaultD_pow_pos (a : \u2115) (z : \u2124) : 0 < (defaultD a : \u211d) ^ z :=\n  zpow_pos (defaultD_pos _) _\n\nlemma mul_defaultD_pow_pos (a : \u2115) {r : \u211d} (hr : 0 < r) (z : \u2124) : 0 < r * (defaultD a : \u211d) ^ z :=\n  mul_pos hr (defaultD_pow_pos a z)\n\nsection Kernel\n\nvariable {X : Type*} {a : \u2115} {K : X \u2192 X \u2192 \u2102} [PseudoMetricSpace X] [MeasureSpace X]\nopen Real (vol)\nopen Function\n\n/-- The constant used twice in the definition of the Calderon-Zygmund kernel. -/\n@[simp] def C_K (a : \u211d) : \u211d := 2 ^ a ^ 3\n\nlemma C_K_pos (a : \u211d) : 0 < C_K a := by unfold C_K; positivity\n\n/-- `K` is a one-sided Calderon-Zygmund kernel\nIn the formalization `K x y` is defined everywhere, even for `x = y`. The assumptions on `K` show\nthat `K x x = 0`. -/\nclass IsOneSidedKernel (a : outParam \u2115) (K : X \u2192 X \u2192 \u2102) : Prop where\n  measurable_K : Measurable (uncurry K)\n  norm_K_le_vol_inv (x y : X) : \u2016K x y\u2016 \u2264 C_K a / vol x y\n  norm_K_sub_le {x y y' : X} (h : 2 * dist y y' \u2264 dist x y) :\n    \u2016K x y - K x y'\u2016 \u2264 (dist y y' / dist x y) ^ (a : \u211d)\u207b\u00b9 * (C_K a / vol x y)\n\nexport IsOneSidedKernel (measurable_K norm_K_le_vol_inv norm_K_sub_le)\n\nlemma MeasureTheory.stronglyMeasurable_K [IsOneSidedKernel a K] :\n    StronglyMeasurable (uncurry K) :=\n  measurable_K.stronglyMeasurable\n\nlemma MeasureTheory.aestronglyMeasurable_K [IsOneSidedKernel a K] :\n    AEStronglyMeasurable (uncurry K) :=\n  measurable_K.aestronglyMeasurable\n\nlemma measurable_K_left [IsOneSidedKernel a K] (y : X) : Measurable (K \u00b7 y) :=\n  measurable_K.of_uncurry_right\n\nlemma measurable_K_right [IsOneSidedKernel a K] (x : X) : Measurable (K x) :=\n  measurable_K.of_uncurry_left\n\nlemma integrableOn_K_Icc [IsOpenPosMeasure (volume : Measure X)] [ProperSpace X]\n    [Regular (volume : Measure X)] [IsOneSidedKernel a K] {x : X} {r R : \u211d} (hr : r > 0) :\n    IntegrableOn (K x) {y | dist x y \u2208 Icc r R} volume := by\n  use Measurable.aestronglyMeasurable (measurable_K_right x)\n  rw [hasFiniteIntegral_def]\n  calc \u222b\u207b (y : X) in {y | dist x y \u2208 Icc r R}, \u2016K x y\u2016\u2091\n    _ \u2264 \u222b\u207b (y : X) in {y | dist x y \u2208 Icc r R},\n          ENNReal.ofReal (C_K a / volume.real (ball x r)) := by\n      refine setLIntegral_mono measurable_const (fun y hy \u21a6 ?_)\n      rw [\u2190 ofReal_norm]\n      refine ENNReal.ofReal_le_ofReal <| (norm_K_le_vol_inv x y).trans ?_\n      gcongr\n      \u00b7 exact (C_K_pos a).le\n      \u00b7 rw [measureReal_def]\n        apply ENNReal.toReal_pos (ne_of_gt <| measure_ball_pos volume x hr)\n        exact measure_ball_ne_top x r\n      \u00b7 exact measureReal_mono (ball_subset_ball hy.1)\n    _ < _ := by\n      rw [lintegral_const]\n      apply ENNReal.mul_lt_top ENNReal.ofReal_lt_top\n      rw [Measure.restrict_apply MeasurableSet.univ, univ_inter]\n      refine (Ne.lt_top fun h \u21a6 ?_)\n      have : {y | dist x y \u2208 Icc r R} \u2286 closedBall x R := by\n        intro y \u27e8_, hy\u27e9\n        exact mem_closedBall_comm.mp hy\n      exact measure_closedBall_lt_top.ne (measure_mono_top this h)\n\n/-- `K` is a two-sided Calderon-Zygmund kernel\nIn the formalization `K x y` is defined everywhere, even for `x = y`. The assumptions on `K` show\nthat `K x x = 0`. -/\nclass IsTwoSidedKernel (a : outParam \u2115) (K : X \u2192 X \u2192 \u2102) extends IsOneSidedKernel a K where\n  norm_K_sub_le' {x x' y : X} (h : 2 * dist x x' \u2264 dist x y) :\n    \u2016K x y - K x' y\u2016 \u2264 (dist x x' / dist x y) ^ (a : \u211d)\u207b\u00b9 * (C_K a / vol x y)\n\nexport IsTwoSidedKernel (norm_K_sub_le')\n\n-- maybe show: `K` is a 2-sided kernel iff `K` and `fun x y \u21a6 K y x` are one-sided kernels.\n\nend Kernel\n\n-- to show: K is locally bounded and hence integrable outside the diagonal\n\n\n/- A constant used on the boundedness of `T_*`. We generally assume\n`HasBoundedStrongType (nontangentialOperator K) volume volume 2 2 (C_Ts a)`\nthroughout this formalization. -/\ndef C_Ts (a : \u211d) : \u211d\u22650 := 2 ^ a ^ 3\n\n/-- Data common through most of chapters 2-9. -/\nclass PreProofData {X : Type*} (a : outParam \u2115) (q : outParam \u211d) (K : outParam (X \u2192 X \u2192 \u2102))\n  (\u03c3\u2081 \u03c3\u2082 : outParam (X \u2192 \u2124)) (F G : outParam (Set X)) [PseudoMetricSpace X] where\n  d : DoublingMeasure X (defaultA a)\n  four_le_a : 4 \u2264 a\n  cf : CompatibleFunctions \u211d X (defaultA a)\n  c : IsCancellative X (default\u03c4 a)\n  hcz : IsOneSidedKernel a K\n  hasBoundedStrongType_Tstar :\n    HasBoundedStrongType (nontangentialOperator K \u00b7 \u00b7) 2 2 volume volume (C_Ts a)\n  measurableSet_F : MeasurableSet F\n  measurableSet_G : MeasurableSet G\n  measurable_\u03c3\u2081 : Measurable \u03c3\u2081\n  measurable_\u03c3\u2082 : Measurable \u03c3\u2082\n  finite_range_\u03c3\u2081 : Finite (range \u03c3\u2081)\n  finite_range_\u03c3\u2082 : Finite (range \u03c3\u2082)\n  \u03c3\u2081_le_\u03c3\u2082 : \u03c3\u2081 \u2264 \u03c3\u2082\n  Q : SimpleFunc X (\u0398 X)\n  q_mem_Ioc : q \u2208 Ioc 1 2\n\nexport PreProofData (four_le_a hasBoundedStrongType_Tstar measurableSet_F measurableSet_G\n  measurable_\u03c3\u2081 measurable_\u03c3\u2082 finite_range_\u03c3\u2081 finite_range_\u03c3\u2082 \u03c3\u2081_le_\u03c3\u2082 Q q_mem_Ioc)\nattribute [instance] PreProofData.d PreProofData.cf PreProofData.c PreProofData.hcz\n\nsection ProofData\n\nvariable {X : Type*} {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102} {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X}\n  [PseudoMetricSpace X] [PreProofData a q K \u03c3\u2081 \u03c3\u2082 F G]\n\nsection Iterate\n\nlemma le_cdist_iterate {x : X} {r : \u211d} (hr : 0 \u2264 r) (f g : \u0398 X) (k : \u2115) :\n    2 ^ k * dist_{x, r} f g \u2264 dist_{x, (defaultA a) ^ k * r} f g := by\n  induction k with\n  | zero => rw [pow_zero, one_mul]; congr! <;> simp\n  | succ k ih =>\n    trans 2 * dist_{x, (defaultA a) ^ k * r} f g\n    \u00b7 rw [pow_succ', mul_assoc]\n      exact (mul_le_mul_left zero_lt_two).mpr ih\n    \u00b7 convert le_cdist (ball_subset_ball _) using 1\n      \u00b7 exact dist_congr rfl (by rw [\u2190 mul_assoc, pow_succ'])\n      \u00b7 nth_rw 1 [\u2190 one_mul ((defaultA a) ^ k * r)]; gcongr\n        rw [\u2190 Nat.cast_one, Nat.cast_le]; exact Nat.one_le_two_pow\n\nlemma cdist_le_iterate {x : X} {r : \u211d} (hr : 0 < r) (f g : \u0398 X) (k : \u2115) :\n    dist_{x, 2 ^ k * r} f g \u2264 (defaultA a) ^ k * dist_{x, r} f g := by\n  induction k with\n  | zero => simp_rw [pow_zero, one_mul]; congr! <;> simp\n  | succ k ih =>\n    trans defaultA a * dist_{x, 2 ^ k * r} f g\n    \u00b7 convert cdist_le _ using 1\n      \u00b7 exact dist_congr rfl (by ring)\n      \u00b7 rw [dist_self]; positivity\n    \u00b7 replace ih := (mul_le_mul_left (show 0 < (defaultA a : \u211d) by positivity)).mpr ih\n      rwa [\u2190 mul_assoc, \u2190 pow_succ'] at ih\n\nlemma ballsCoverBalls_iterate_nat {x : X} {d r : \u211d} {n : \u2115} :\n    BallsCoverBalls (WithFunctionDistance x d) (2 ^ n * r) r (defaultA a ^ n) := by\n  have double := fun s \u21a6 PreProofData.cf.ballsCoverBalls (x := x) (r := d) (R := s)\n  apply BallsCoverBalls.pow_mul double\n\nlemma ballsCoverBalls_iterate {x : X} {d R r : \u211d} (hR : 0 < R) (hr : 0 < r) :\n    BallsCoverBalls (WithFunctionDistance x d) R r (defaultA a ^ \u2308Real.logb 2 (R / r)\u2309\u208a) := by\n  apply ballsCoverBalls_iterate_nat.mono\n  calc\n    _ = R / r * r := by rw [div_mul_cancel\u2080 R hr.ne']\n    _ = 2 ^ Real.logb 2 (R / r) * r := by\n      rw [Real.rpow_logb zero_lt_two one_lt_two.ne' (by positivity)]\n    _ \u2264 _ := by\n      gcongr\n      rw [\u2190 Real.rpow_natCast]\n      exact Real.rpow_le_rpow_of_exponent_le one_le_two (Nat.le_ceil _)\n\nend Iterate\n\n@[fun_prop]\nlemma measurable_Q\u2082 : Measurable fun p : X \u00d7 X \u21a6 Q p.1 p.2 := fun s meass \u21a6 by\n  have : (fun p : X \u00d7 X \u21a6 (Q p.1) p.2) \u207b\u00b9' s = \u22c3 \u03b8 \u2208 Q.range, (Q \u207b\u00b9' {\u03b8}) \u00d7\u02e2 (\u03b8 \u207b\u00b9' s) := by\n    ext \u27e8x, y\u27e9\n    simp only [mem_preimage, SimpleFunc.mem_range, mem_range, iUnion_exists, iUnion_iUnion_eq',\n      mem_iUnion, mem_prod, mem_singleton_iff]\n    constructor <;> intro h\n    \u00b7 use x\n    \u00b7 obtain \u27e8j, hj\u27e9 := h; exact congr($(hj.1) y).symm \u25b8 hj.2\n  rw [this]\n  exact Q.range.measurableSet_biUnion fun \u03b8 _ \u21a6\n    (Q.measurableSet_fiber \u03b8).prod (meass.preimage (map_continuous \u03b8).measurable)\n\nlemma stronglyMeasurable_Q\u2082 : StronglyMeasurable fun p : X \u00d7 X \u21a6 Q p.1 p.2 :=\n  measurable_Q\u2082.stronglyMeasurable\n\n@[fun_prop]\nlemma aestronglyMeasurable_Q\u2082 : AEStronglyMeasurable fun p : X \u00d7 X \u21a6 Q p.1 p.2 :=\n  measurable_Q\u2082.aestronglyMeasurable\n\n@[fun_prop]\nlemma measurable_Q\u2081 (x : X) : Measurable (Q x) :=\n  let Q' : X \u2192 X \u2192 \u211d := fun x' y \u21a6 Q x' y\n  have : (fun y \u21a6 Q' x y) = Q x := rfl\n  this \u25b8 measurable_Q\u2082.of_uncurry_left\n\ninclude a q K \u03c3\u2081 \u03c3\u2082 F G\n\nvariable (X) in\nlemma S_spec : \u2203 n : \u2115, \u2200 x, -n \u2264 \u03c3\u2081 x \u2227 \u03c3\u2082 x \u2264 n := by\n  have h1 : (range \u03c3\u2081).Finite := finite_range_\u03c3\u2081\n  have h2 : (range \u03c3\u2082).Finite := finite_range_\u03c3\u2082\n  have h1' := bddBelow_def.mp h1.bddBelow\n  have h2' := bddAbove_def.mp h2.bddAbove\n  refine \u27e8(max (-h1'.choose) h2'.choose).toNat, fun x \u21a6 ?_\u27e9\n  simp only [Int.ofNat_toNat, \u2190 min_neg_neg, neg_neg, min_le_iff, le_max_iff]\n  exact \u27e8Or.inl (Or.inl (h1'.choose_spec _ (mem_range_self x))),\n    Or.inl (Or.inr (h2'.choose_spec _ (mem_range_self x)))\u27e9\n\nsection DBounds\n\nvariable (X)\n\n-- used in 4.1.7 (`small_boundary`)\nlemma twentyfive_le_realD : (25 : \u211d) \u2264 defaultD a := by\n  simp only [defaultD, Nat.ofNat_le_cast]\n  have : 4 \u2264 a := four_le_a X\n  calc\n    (25 : \u2115)\n      \u2264 32 := Nat.le_of_ble_eq_true rfl\n    _ = 2 ^ (5) := by rfl\n    _ \u2264 2 ^ (100 * 4 ^ 2) := Nat.le_of_ble_eq_true (by norm_num)\n    _ \u2264 2 ^ (100 * a ^ 2) := Nat.pow_le_pow_right (by norm_num)\n      (mul_le_mul_of_nonneg_left (Nat.pow_le_pow_of_le_left this 2) (by norm_num))\n\n-- used in 4.1.3 (`I3_prop_3_1`)\nlemma eight_le_realD : (8 : \u211d) \u2264 defaultD a := by\n  linarith [twentyfive_le_realD X]\n\n-- used in 4.1.6 (`transitive_boundary`)\nlemma five_le_realD : (5 : \u211d) \u2264 defaultD a := by\n  linarith [twentyfive_le_realD X]\n\n-- used in various places in `Carleson.TileExistence`\nlemma four_le_realD : (4 : \u211d) \u2264 defaultD a := by\n  linarith [twentyfive_le_realD X]\n\nlemma one_le_realD : (1 : \u211d) \u2264 defaultD a := by\n  linarith [twentyfive_le_realD X]\n\nopen Classical in\ndef defaultS : \u2115 := Nat.find (S_spec X)\n\nend DBounds\n\nlemma range_\u03c3\u2081_subset : range \u03c3\u2081 \u2286 Icc (- defaultS X) (defaultS X) := by\n  classical\n  rw [range_subset_iff]\n  exact fun x \u21a6 \u27e8(Nat.find_spec (S_spec X) x).1, (\u03c3\u2081_le_\u03c3\u2082 x).trans (Nat.find_spec (S_spec X) x).2\u27e9\n\nlemma range_\u03c3\u2082_subset : range \u03c3\u2082 \u2286 Icc (- defaultS X) (defaultS X) := by\n  classical\n  rw [range_subset_iff]\n  exact fun x \u21a6 \u27e8(Nat.find_spec (S_spec X) x).1.trans (\u03c3\u2081_le_\u03c3\u2082 x), (Nat.find_spec (S_spec X) x).2\u27e9\n\nlemma Icc_\u03c3_subset_Icc_S {x : X} : Icc (\u03c3\u2081 x) (\u03c3\u2082 x) \u2286 Icc (- defaultS X) (defaultS X) :=\n  fun _ h \u21a6 \u27e8(range_\u03c3\u2081_subset \u27e8x, rfl\u27e9).1.trans h.1, h.2.trans (range_\u03c3\u2082_subset \u27e8x, rfl\u27e9).2\u27e9\n\nlemma neg_S_mem_or_S_mem [Nonempty X] :\n    (- defaultS X : \u2124) \u2208 range \u03c3\u2081 \u2228 (defaultS X : \u2124) \u2208 range \u03c3\u2082 := by\n  by_cases h\u2080 : defaultS X = 0\n  \u00b7 right\n    simp only [h\u2080, CharP.cast_eq_zero, mem_range]\n    have : range \u03c3\u2082 \u2286 Icc (- defaultS X) (defaultS X) := range_\u03c3\u2082_subset\n    simp only [h\u2080, CharP.cast_eq_zero, neg_zero, Icc_self, subset_singleton_iff, mem_range,\n      forall_exists_index, forall_apply_eq_imp_iff] at this\n    let x : X := Classical.choice inferInstance\n    exact \u27e8x, this x\u27e9\n  by_contra! h\n  let n := (defaultS X) - 1\n  have h1 (x : X) : -n \u2264 \u03c3\u2081 x := by\n    rw [Int.natCast_sub (Nat.one_le_iff_ne_zero.mpr h\u2080), neg_sub, sub_eq_add_neg, add_comm]\n    exact lt_iff_le_and_ne.mpr \u27e8(range_\u03c3\u2081_subset (mem_range_self x)).1,\n      fun h' \u21a6 h.1 <| mem_range.mpr \u27e8x, h'.symm\u27e9\u27e9\n  have h2 (x : X) : \u03c3\u2082 x \u2264 n :=\n    Int.natCast_sub (Nat.one_le_iff_ne_zero.mpr h\u2080) \u25b8 le_sub_right_of_add_le (lt_iff_le_and_ne.mpr\n      \u27e8(range_\u03c3\u2082_subset (mem_range_self x)).2, fun h' \u21a6 h.2 <| mem_range.mpr \u27e8x, h'\u27e9\u27e9)\n  have hn : n < defaultS X := by\n    simp only [tsub_lt_self_iff, zero_lt_one, and_true, n]\n    exact Nat.zero_lt_of_ne_zero h\u2080\n  classical\n  exact Nat.find_min (S_spec X) hn fun x \u21a6 \u27e8h1 x, h2 x\u27e9\n\nvariable (X)\n\nlemma a_pos : 0 < a := by linarith [four_le_a X]\nlemma cast_a_pos : 0 < (a : \u211d) := by norm_cast; exact a_pos X\nlemma \u03c4_pos : 0 < default\u03c4 a := inv_pos.mpr (cast_a_pos X)\nlemma \u03c4_nonneg : 0 \u2264 default\u03c4 a := (\u03c4_pos X).le\n\n/-- `\u03c4` as an element of `\u211d\u22650`. -/\ndef nn\u03c4 : \u211d\u22650 := \u27e8default\u03c4 a, \u03c4_nonneg X\u27e9\n\nlemma one_lt_q : 1 < q := (q_mem_Ioc X).1\nlemma q_le_two : q \u2264 2 := (q_mem_Ioc X).2\nlemma q_pos : 0 < q := zero_lt_one.trans (one_lt_q X)\nlemma q_nonneg : 0 \u2264 q := (q_pos X).le\nlemma inv_q_sub_half_nonneg : 0 \u2264 q\u207b\u00b9 - 2\u207b\u00b9 := by\n  simp [inv_le_inv\u2080 zero_lt_two (q_pos X), q_le_two X]\n\n/-- `q` as an element of `\u211d\u22650`. -/\ndef nnq : \u211d\u22650 := \u27e8q, q_nonneg X\u27e9\n\nlemma one_lt_nnq : 1 < nnq X := one_lt_q X\nlemma nnq_le_two : nnq X \u2264 2 := q_le_two X\nlemma nnq_pos : 0 < nnq X := q_pos X\nlemma nnq_mem_Ioc : nnq X \u2208 Ioc 1 2 :=\n  \u27e8NNReal.coe_lt_coe.mp (q_mem_Ioc X).1, NNReal.coe_le_coe.mp (q_mem_Ioc X).2\u27e9\n\nend ProofData\n\nclass ProofData {X : Type*} (a : outParam \u2115) (q : outParam \u211d) (K : outParam (X \u2192 X \u2192 \u2102))\n    (\u03c3\u2081 \u03c3\u2082 : outParam (X \u2192 \u2124)) (F G : outParam (Set X)) [PseudoMetricSpace X]\n    extends PreProofData a q K \u03c3\u2081 \u03c3\u2082 F G where\n  F_subset : F \u2286 ball (cancelPt X) (defaultD a ^ defaultS X / 4)\n  G_subset : G \u2286 ball (cancelPt X) (defaultD a ^ defaultS X / 4)\n  /- The next two conditions are not in the blueprint, but will be useful in various steps.\n  It is easy to prove finitary_carleson (or metric_carleson) separately when either of these\n  fails. -/\n  volume_F_pos : 0 < volume F\n  volume_G_pos : 0 < volume G\n\nnamespace ShortVariables\n-- open this section to get shorter 1-letter names for a bunch of variables\n\nset_option hygiene false\nscoped notation \"D\" => defaultD a\nscoped notation \"\u03ba\" => default\u03ba a\nscoped notation \"Z\" => defaultZ a\nscoped notation \"\u03c4\" => default\u03c4 a\nscoped notation \"o\" => cancelPt X\nscoped notation \"S\" => defaultS X\nscoped notation \"nn\u03c4\" => nn\u03c4 X\nscoped notation \"nnq\" => nnq X\n\nend ShortVariables\n\nopen scoped ShortVariables\nvariable {X : Type*} {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102} {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X}\n\nlemma one_lt_D [PseudoMetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] : 1 < (D : \u211d) := by\n  exact_mod_cast one_lt_pow\u2080 Nat.one_lt_two (by nlinarith [four_le_a X])\n\nlemma one_le_D : 1 \u2264 (D : \u211d) := by\n  rw [\u2190 Nat.cast_one, Nat.cast_le, defaultD, \u2190 pow_zero 2]\n  exact pow_le_pow_right' one_le_two (by positivity)\n\nlemma D_nonneg : 0 \u2264 (D : \u211d) := zero_le_one.trans one_le_D\n\nlemma \u03ba_nonneg : 0 \u2264 \u03ba := by\n  rw [default\u03ba]\n  exact Real.rpow_nonneg (by norm_num) _\n\n/-- Used in `third_exception` (Lemma 5.2.10). -/\nlemma two_le_\u03baZ [PseudoMetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] : 2 \u2264 \u03ba * Z := by\n  rw [default\u03ba, defaultZ, Nat.cast_pow, show ((2 : \u2115) : \u211d) = 2 by rfl,\n    show (2 : \u211d) ^ (12 * a) = 2 ^ (12 * a : \u211d) by norm_cast, \u2190 Real.rpow_add zero_lt_two,\n    show (-10 * a + 12 * a : \u211d) = 2 * a by ring]\n  norm_cast; change 2 ^ 1 \u2264 _\n  exact Nat.pow_le_pow_of_le one_lt_two (by linarith [four_le_a X])\n\n/-- Used in `third_exception` (Lemma 5.2.10). -/\nlemma D\u03baZ_le_two_rpow_100 [PseudoMetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] :\n    (D : \u211d\u22650\u221e) ^ (-\u03ba * Z) \u2264 2 ^ (-100 : \u211d) := by\n  rw [defaultD, Nat.cast_pow, \u2190 ENNReal.rpow_natCast, \u2190 ENNReal.rpow_mul,\n    show ((2 : \u2115) : \u211d\u22650\u221e) = 2 by rfl]\n  apply ENNReal.rpow_le_rpow_of_exponent_le one_le_two\n  rw [default\u03ba, defaultZ, Nat.cast_pow, show ((2 : \u2115) : \u211d) = 2 by rfl, neg_mul,\n    show (2 : \u211d) ^ (12 * a) = 2 ^ (12 * a : \u211d) by norm_cast, mul_neg,\n    \u2190 Real.rpow_add zero_lt_two, show (-10 * a + 12 * a : \u211d) = 2 * a by ring,\n    neg_le_neg_iff]\n  norm_cast\n  calc\n    _ \u2264 100 * a ^ 2 := by nlinarith [four_le_a X]\n    _ \u2264 _ := by\n      nth_rw 1 [\u2190 mul_one (a ^ 2), \u2190 mul_assoc]\n      gcongr; exact Nat.one_le_two_pow\n\nlemma four_le_Z [PseudoMetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] : 4 \u2264 Z := by\n  rw [defaultZ, show 4 = 2 ^ 2 by rfl]\n  exact Nat.pow_le_pow_right zero_lt_two (by linarith [four_le_a X])\n\nvariable (a) in\n/-- `D` as an element of `\u211d\u22650`. -/\ndef nnD : \u211d\u22650 := \u27e8D, by simp [D_nonneg]\u27e9\n\nnamespace ShortVariables\n\nset_option hygiene false\nscoped notation \"nnD\" => nnD a\n\nend ShortVariables\n\nvariable [PseudoMetricSpace X] [h : ProofData a q K \u03c3\u2081 \u03c3\u2082 F G]\n\nlemma volume_F_lt_top : volume F < \u22a4 :=\n  lt_of_le_of_lt (measure_mono ProofData.F_subset) measure_ball_lt_top\n\nlemma volume_F_ne_top : volume F \u2260 \u22a4 := volume_F_lt_top.ne\n\n", "theoremStatement": "lemma volume_G_lt_top : volume G < \u22a4 ", "theoremName": "volume_G_lt_top", "fileCreated": {"commit": "238b977db22d5b1107a09468e95b78facfd58fd1", "date": "2023-10-20"}, "theoremCreated": {"commit": "88d85ba29f717ee3bb9fbd37379a6fb77b57265f", "date": "2025-01-06"}, "file": "carleson/Carleson/Defs.lean", "module": "Carleson.Defs", "jsonFile": "Carleson.Defs.jsonl", "positionMetadata": {"lineInFile": 634, "tokenPositionInFile": 26230, "theoremPositionInFile": 93}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 9, "repositoryPremises": true, "numRepositoryPremises": 12, "numPremises": 63}, "proofMetadata": {"hasProof": true, "proof": ":=\n  lt_of_le_of_lt (measure_mono ProofData.G_subset) measure_ball_lt_top", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 73}}
{"srcContext": "import Carleson.Forest\nimport Carleson.ToMathlib.HardyLittlewood\nimport Carleson.ToMathlib.BoundedCompactSupport\nimport Carleson.ToMathlib.Misc\nimport Carleson.Psi\n\nopen ShortVariables TileStructure\nvariable {X : Type*} {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102} {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X}\n  [MetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] [TileStructure Q D \u03ba S o]\n  {n j j' : \u2115} {t : Forest X n} {u u\u2081 u\u2082 p : \ud835\udd13 X} {x x' : X} {\ud835\udd16 : Set (\ud835\udd13 X)}\n  {f f\u2081 f\u2082 g g\u2081 g\u2082 : X \u2192 \u2102} {I J J' L : Grid X}\nvariable {E' : Type*} [NormedAddCommGroup E'] [NormedSpace \u211d E']\n\nnoncomputable section\n\nopen Set MeasureTheory Metric Function Complex Bornology TileStructure Classical Filter\nopen scoped NNReal ENNReal ComplexConjugate\n\nnamespace TileStructure.Forest\n\n/-! ## Section 7.1 and Lemma 7.1.3 -/\n\nvariable (t) in\n/-- The definition `\u03c3(u, x)` given in Section 7.1.\nWe may assume `u \u2208 t` whenever proving things about this definition. -/\ndef \u03c3 (u : \ud835\udd13 X) (x : X) : Finset \u2124 := .image \ud835\udd30 { p | p \u2208 t u \u2227 x \u2208 E p }\n\nvariable (t) in\nprivate lemma exists_p_of_mem_\u03c3 (u : \ud835\udd13 X) (x : X) {s : \u2124} (hs : s \u2208 t.\u03c3 u x) :\n    \u2203 p \u2208 t.\ud835\udd17 u, x \u2208 E p \u2227 \ud835\udd30 p = s := by\n  have \u27e8p, hp\u27e9 := Finset.mem_image.mp hs\n  simp only [mem_\ud835\udd17, Finset.mem_filter] at hp\n  use p, hp.1.2.1, hp.1.2.2, hp.2\n\n/- \\overline{\u03c3} from the blueprint. -/\nvariable (t) in\ndef \u03c3Max (u : \ud835\udd13 X) (x : X) (h\u03c3 : (t.\u03c3 u x).Nonempty) : \u2124 :=\n  t.\u03c3 u x |>.max' h\u03c3\n\n/- \\underline{\u03c3} from the blueprint. -/\nvariable (t) in\ndef \u03c3Min (u : \ud835\udd13 X) (x : X) (h\u03c3 : (t.\u03c3 u x).Nonempty) : \u2124 :=\n  t.\u03c3 u x |>.min' h\u03c3\n\nvariable (t) in\nprivate lemma \u03c3Max_mem_\u03c3 (u : \ud835\udd13 X) (x : X) (h\u03c3 : (t.\u03c3 u x).Nonempty) : \u03c3Max t u x h\u03c3 \u2208 t.\u03c3 u x :=\n  (t.\u03c3 u x).max'_mem h\u03c3\n\n/-- The definition of `\ud835\udcd9\u2080(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcd9\u2080 (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {J : Grid X | s J = -S \u2228 \u2200 p \u2208 \ud835\udd16, \u00ac(\ud835\udcd8 p : Set X) \u2286 ball (c J) (100 * D ^ (s J + 1))}\n\n/-- The definition of `\ud835\udcd9(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcd9 (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {x | Maximal (\u00b7 \u2208 \ud835\udcd9\u2080 \ud835\udd16) x}\n\nlemma \ud835\udcd9_subset_\ud835\udcd9\u2080 {\ud835\udd16 : Set (\ud835\udd13 X)} : \ud835\udcd9 \ud835\udd16 \u2286 \ud835\udcd9\u2080 \ud835\udd16 := sep_subset ..\n\nlemma pairwiseDisjoint_\ud835\udcd9 : (\ud835\udcd9 \ud835\udd16).PairwiseDisjoint (fun I \u21a6 (I : Set X)) := fun I mI J mJ hn \u21a6 by\n  have : IsAntichain (\u00b7 \u2264 \u00b7) (\ud835\udcd9 \ud835\udd16) := setOf_maximal_antichain _\n  exact (le_or_ge_or_disjoint.resolve_left (this mI mJ hn)).resolve_left (this mJ mI hn.symm)\n\n/-- The definition of `\ud835\udcdb\u2080(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcdb\u2080 (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {L : Grid X | s L = -S \u2228 (\u2203 p \u2208 \ud835\udd16, L \u2264 \ud835\udcd8 p) \u2227 \u2200 p \u2208 \ud835\udd16, \u00ac\ud835\udcd8 p \u2264 L}\n\n/-- The definition of `\ud835\udcdb(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcdb (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {x | Maximal (\u00b7 \u2208 \ud835\udcdb\u2080 \ud835\udd16) x}\n\nlemma \ud835\udcdb_subset_\ud835\udcdb\u2080 {\ud835\udd16 : Set (\ud835\udd13 X)} : \ud835\udcdb \ud835\udd16 \u2286 \ud835\udcdb\u2080 \ud835\udd16 := sep_subset ..\n\nprivate lemma s_le_s_of_mem_\ud835\udcdb {\ud835\udd16 : Set (\ud835\udd13 X)} {L : Grid X} (hL : L \u2208 \ud835\udcdb \ud835\udd16)\n    {p : \ud835\udd13 X} (hp : p \u2208 \ud835\udd16) (hpL : \u00ac Disjoint (\ud835\udcd8 p : Set X) (L : Set X)) : s L \u2264 s (\ud835\udcd8 p) := by\n  simp only [\ud835\udcdb, \ud835\udcdb\u2080, Grid.le_def, not_and, not_le, and_imp] at hL\n  rcases hL.1 with h | h\n  \u00b7 exact h \u25b8 (range_s_subset \u27e8\ud835\udcd8 p, rfl\u27e9).1\n  \u00b7 by_contra!\n    exact lt_asymm this <| h.2 p hp <| (GridStructure.fundamental_dyadic' this.le).resolve_right hpL\n\nprivate lemma subset_of_mem_\ud835\udcdb {\ud835\udd16 : Set (\ud835\udd13 X)} {L : Grid X} (hL : L \u2208 \ud835\udcdb \ud835\udd16) {p : \ud835\udd13 X}\n    (hp : p \u2208 \ud835\udd16) (hpL : \u00ac Disjoint (\ud835\udcd8 p : Set X) (L : Set X)) : (L : Set X) \u2286 (\ud835\udcd8 p : Set X) :=\n  GridStructure.fundamental_dyadic' (s_le_s_of_mem_\ud835\udcdb hL hp hpL) |>.resolve_right fun h \u21a6 hpL h.symm\n\n/-- The projection operator `P_\ud835\udcd2 f(x)`, given above Lemma 7.1.3.\nIn lemmas the `c` will be pairwise disjoint on `C`. -/\ndef approxOnCube (C : Set (Grid X)) (f : X \u2192 E') (x : X) : E' :=\n  \u2211 J \u2208 { p | p \u2208 C }, (J : Set X).indicator (fun _ \u21a6 \u2a0d y in J, f y) x\n\nlemma stronglyMeasurable_approxOnCube (C : Set (Grid X)) (f : X \u2192 E') :\n    StronglyMeasurable (approxOnCube (X := X) (K := K) C f) :=\n  Finset.stronglyMeasurable_sum _ (fun _ _ \u21a6 stronglyMeasurable_const.indicator coeGrid_measurable)\n\nlemma integrable_approxOnCube (C : Set (Grid X)) {f : X \u2192 E'} : Integrable (approxOnCube C f) := by\n  refine integrable_finset_sum _ (fun i hi \u21a6 ?_)\n  constructor\n  \u00b7 exact (aestronglyMeasurable_indicator_iff coeGrid_measurable).mpr aestronglyMeasurable_const\n  \u00b7 simp_rw [hasFiniteIntegral_iff_enorm, enorm_indicator_eq_indicator_enorm]\n    apply lt_of_le_of_lt <| lintegral_indicator_const_le (i : Set X) _\n    exact ENNReal.mul_lt_top ENNReal.coe_lt_top volume_coeGrid_lt_top\n\nlemma approxOnCube_nonneg {C : Set (Grid X)} {f : X \u2192 \u211d} (hf : \u2200 (y : X), f y \u2265 0) {x : X} :\n    approxOnCube C f x \u2265 0 :=\n  Finset.sum_nonneg' (fun _ \u21a6 Set.indicator_nonneg (fun _ _ \u21a6 integral_nonneg hf) _)\n\nlemma approxOnCube_apply {C : Set (Grid X)} (hC : C.PairwiseDisjoint (fun I \u21a6 (I : Set X)))\n    (f : X \u2192 E') {x : X} {J : Grid X} (hJ : J \u2208 C) (xJ : x \u2208 J) :\n    (approxOnCube C f) x = \u2a0d y in J, f y := by\n  rw [approxOnCube, \u2190 Finset.sum_filter_not_add_sum_filter _ (J = \u00b7)]\n  have eq0 : \u2211 i \u2208 Finset.filter (\u00ac J = \u00b7) (Finset.univ.filter (\u00b7 \u2208 C)),\n      (i : Set X).indicator (fun _ \u21a6 \u2a0d y in i, f y) x = 0 := by\n    suffices \u2200 i \u2208 (Finset.univ.filter (\u00b7 \u2208 C)).filter (\u00ac J = \u00b7),\n      (i : Set X).indicator (fun _ \u21a6 \u2a0d y in i, f y) x = 0 by simp [Finset.sum_congr rfl this]\n    intro i hi\n    simp only [Finset.mem_filter, Finset.mem_univ, true_and] at hi\n    apply indicator_of_not_mem <|\n      Set.disjoint_left.mp ((hC.eq_or_disjoint hJ hi.1).resolve_left hi.2) xJ\n  have eq_ave : \u2211 i \u2208 (Finset.univ.filter (\u00b7 \u2208 C)).filter (J = \u00b7),\n      (i : Set X).indicator (fun _ \u21a6 \u2a0d y in i, f y) x = \u2a0d y in J, f y := by\n    suffices (Finset.univ.filter (\u00b7 \u2208 C)).filter (J = \u00b7) = {J} by simp [this, xJ, \u2190 Grid.mem_def]\n    exact subset_antisymm (fun _ h \u21a6 Finset.mem_singleton.mpr (Finset.mem_filter.mp h).2.symm)\n      (fun _ h \u21a6 by simp [Finset.mem_singleton.mp h, hJ])\n  rw [eq0, eq_ave, zero_add]\n\nlemma boundedCompactSupport_approxOnCube {\ud835\udd5c : Type*} [RCLike \ud835\udd5c] {C : Set (Grid X)} {f : X \u2192 \ud835\udd5c} :\n    BoundedCompactSupport (approxOnCube C f) :=\n  BoundedCompactSupport.finset_sum fun J hJ \u21a6\n    BoundedCompactSupport.indicator_of_isBounded_range (by simp) stronglyMeasurable_const\n    ((isBounded_iff_subset_ball (c J)).mpr \u27e84 * D ^ s J, Grid_subset_ball\u27e9) coeGrid_measurable\n\n-- Used in the proof of Lemma 7.1.6\nlemma integral_eq_lintegral_approxOnCube {C : Set (Grid X)}\n    (hC : C.PairwiseDisjoint fun I \u21a6 (I : Set X)) {J : Grid X} (hJ : J \u2208 C) {f : X \u2192 \u2102}\n    (hf : BoundedCompactSupport f) : ENNReal.ofReal (\u222b y in J, \u2016f y\u2016) =\n    \u222b\u207b (y : X) in J, \u2016approxOnCube C (fun x \u21a6 (\u2016f x\u2016 : \u2102)) y\u2016\u208a := by\n  have nonneg : 0 \u2264\u1da0[ae (volume.restrict J)] fun y \u21a6 \u2016f y\u2016 := Filter.Eventually.of_forall (by simp)\n  have vol_J_ne_zero := (volume_coeGrid_pos (X := X) (i := J) (defaultD_pos' a)).ne.symm\n  have eq : \u222b\u207b (y : X) in J, \u2016approxOnCube C (fun x \u21a6 (\u2016f x\u2016 : \u2102)) y\u2016\u208a =\n      \u222b\u207b y in (J : Set X), ENNReal.ofReal (\u2a0d z in J, \u2016f z\u2016) := by\n    refine setLIntegral_congr_fun coeGrid_measurable (Filter.Eventually.of_forall fun y hy \u21a6 ?_)\n    rw [approxOnCube_apply hC _ hJ hy, ENNReal.ofReal]\n    \u00b7 apply congrArg\n      have : \u2016\u2a0d y in J, (\u2016f y\u2016 : \u2102)\u2016\u208a = \u2016\u2a0d y in J, \u2016f y\u2016\u2016\u208a := by\n        convert congrArg (\u2016\u00b7\u2016\u208a) <| integral_ofReal (f := (\u2016f \u00b7\u2016)) using 1\n        simp [average]\n      exact this \u25b8 (Real.toNNReal_eq_nnnorm_of_nonneg <| integral_nonneg (fun y \u21a6 by simp)).symm\n  rw [ofReal_integral_eq_lintegral_ofReal hf.integrable.norm.restrict nonneg,\n    eq, lintegral_const, average_eq, smul_eq_mul, ENNReal.ofReal_mul, ENNReal.ofReal_inv_of_pos,\n    ENNReal.ofReal_toReal, ofReal_integral_eq_lintegral_ofReal hf.norm.integrable nonneg, mul_comm,\n    \u2190 mul_assoc, Measure.restrict_apply MeasurableSet.univ, univ_inter,\n    ENNReal.mul_inv_cancel vol_J_ne_zero volume_coeGrid_lt_top.ne, one_mul]\n  \u00b7 simp [volume_coeGrid_lt_top.ne]\n  \u00b7 simpa using ENNReal.toReal_pos vol_J_ne_zero volume_coeGrid_lt_top.ne\n  \u00b7 exact inv_nonneg.mpr ENNReal.toReal_nonneg\n\nlemma approxOnCube_ofReal (C : Set (Grid X)) (f : X \u2192 \u211d) (x : X) :\n    approxOnCube C (Complex.ofReal <| f \u00b7) x = Complex.ofReal (approxOnCube C f x) := by\n  simp_rw [approxOnCube, ofReal_sum]\n  refine Finset.sum_congr rfl (fun J _ \u21a6 ?_)\n  by_cases hx : x \u2208 (J : Set X)\n  \u00b7 simpa only [indicator_of_mem hx] using integral_ofReal\n  \u00b7 simp only [indicator_of_not_mem hx, ofReal_zero]\n\nlemma norm_approxOnCube_le_approxOnCube_norm {C : Set (Grid X)} {f : X \u2192 E'} {x : X} :\n    \u2016approxOnCube C f x\u2016 \u2264 approxOnCube C (\u2016f \u00b7\u2016) x := by\n  refine (norm_sum_le _ _).trans <| Finset.sum_le_sum (fun J hJ \u21a6 ?_)\n  rw [norm_indicator_eq_indicator_norm]\n  gcongr\n  apply norm_integral_le_integral_norm\n\n/-- The definition `I_i(x)`, given above Lemma 7.1.3.\nThe cube of scale `s` that contains `x`. There is at most 1 such cube, if it exists. -/\ndef cubeOf (i : \u2124) (x : X) : Grid X :=\n  Classical.epsilon (fun I \u21a6 x \u2208 I \u2227 s I = i)\n\nlemma cubeOf_spec {i : \u2124} (hi : i \u2208 Icc (-S : \u2124) S) (I : Grid X) {x : X} (hx : x \u2208 I) :\n    x \u2208 cubeOf i x \u2227 s (cubeOf i x) = i := by\n  apply epsilon_spec (p := fun I \u21a6 x \u2208 I \u2227 s I = i)\n  by_cases hiS : i = S\n  \u00b7 use topCube, subset_topCube hx, hiS \u25b8 s_topCube\n  simpa [and_comm] using Set.mem_iUnion\u2082.mp <| Grid_subset_biUnion i\n    \u27e8hi.1, s_topCube (X := X) \u25b8 lt_of_le_of_ne hi.2 hiS\u27e9 (subset_topCube hx)\n\n/-- The definition `T_\ud835\udcdd^\u03b8 f(x)`, given in (7.1.3).\nFor convenience, the suprema are written a bit differently than in the blueprint\n(avoiding `cubeOf`), but this should be equivalent.\nThis is `0` if `x` doesn't lie in a cube. -/\ndef nontangentialMaximalFunction (\u03b8 : \u0398 X) (f : X \u2192 \u2102) (x : X) : \u211d\u22650\u221e :=\n  \u2a06 (I : Grid X) (_ : x \u2208 I) (x' \u2208 I) (s\u2082 \u2208 Icc (s I) S)\n  (_ : ENNReal.ofReal (D ^ (s\u2082 - 1)) \u2264 upperRadius Q \u03b8 x'),\n  \u2016\u2211 i \u2208 Icc (s I) s\u2082, \u222b y, Ks i x' y * f y\u2016\u208a\n\nprotected theorem MeasureTheory.Measurable.nontangentialMaximalFunction {\u03b8 : \u0398 X} {f : X \u2192 \u2102} :\n    Measurable (nontangentialMaximalFunction \u03b8 f) := by\n  refine Measurable.iSup (fun I \u21a6 ?_)\n  let c := \u2a06 x' \u2208 I, \u2a06 s\u2082 \u2208 Icc (s I) S, \u2a06 (_ : ENNReal.ofReal (D ^ (s\u2082 - 1)) \u2264 upperRadius Q \u03b8 x'),\n    (\u2016\u2211 i \u2208 (Icc (s I) s\u2082), \u222b (y : X), Ks i x' y * f y\u2016\u208a : ENNReal)\n  have : (fun x \u21a6 \u2a06 (_ : x \u2208 I), c) = fun x \u21a6 ite (x \u2208 I) c 0 := by\n    ext x; by_cases hx : x \u2208 I <;> simp [hx]\n  convert (measurable_const.ite coeGrid_measurable measurable_const) using 1\n\n-- Set used in definition of `boundaryOperator`\nvariable (t) (u) in private def \ud835\udcd9' (x : X) (i : \u2124) : Finset (Grid X) :=\n  { J | J \u2208 \ud835\udcd9 (t u) \u2227 (J : Set X) \u2286 ball x (16 * D ^ i) \u2227 s J \u2264 i }\n\nprivate lemma mem_\ud835\udcd9_of_mem_\ud835\udcd9' {x : X} {i : \u2124} {J : Grid X} : J \u2208 \ud835\udcd9' t u x i \u2192 J \u2208 \ud835\udcd9 (t u) := by\n  intro hJ\n  simp only [\ud835\udcd9', Finset.mem_filter] at hJ\n  exact hJ.2.1\n\nvariable (t) in\n/-- The operator `S_{1,\ud835\udd32} f(x)`, given in (7.1.4). -/\ndef boundaryOperator (u : \ud835\udd13 X) (f : X \u2192 \u2102) (x : X) : \u211d\u22650\u221e :=\n  \u2211 I : Grid X, (I : Set X).indicator (x := x) fun _ \u21a6 \u2211 J \u2208 \ud835\udcd9' t u (c I) (s I),\n  D ^ ((s J - s I) / (a : \u211d)) / volume (ball (c I) (16 * D ^ (s I))) * \u222b\u207b y in (J : Set X), \u2016f y\u2016\u208a\n\nprotected theorem MeasureTheory.Measurable.boundaryOperator {u : \ud835\udd13 X} {f : X \u2192 \u2102} :\n    Measurable (t.boundaryOperator u f) := by\n  refine Finset.measurable_sum _ (fun I _ \u21a6 ?_)\n  exact (Finset.measurable_sum _ (fun J _ \u21a6 measurable_const)).indicator coeGrid_measurable\n\n-- Currently unused; uncomment if needed.\n/- lemma boundaryOperator_lt_top (hf : BoundedCompactSupport f) : t.boundaryOperator u f x < \u22a4 := by\n  refine ENNReal.sum_lt_top.mpr (fun I _ \u21a6 ?_)\n  by_cases hx : x \u2208 (I : Set X)\n  \u00b7 rw [indicator_of_mem hx]\n    refine ENNReal.sum_lt_top.mpr (fun J hJ \u21a6 ENNReal.mul_lt_top ?_ hf.integrable.integrableOn.2)\n    apply ENNReal.div_lt_top (by simp)\n    exact ne_of_gt <| measure_ball_pos volume _ <| mul_pos (by norm_num) (defaultD_pow_pos a (s I))\n  \u00b7 simp [hx] -/\n\n/-- The indexing set for the collection of balls \ud835\udcd1, defined above Lemma 7.1.3. -/\ndef \ud835\udcd1 : Set (\u2115 \u00d7 Grid X) := Icc 0 (S + 5) \u00d7\u02e2 univ\n\n/-- The center function for the collection of balls \ud835\udcd1. -/\ndef c\ud835\udcd1 (z : \u2115 \u00d7 Grid X) : X := c z.2\n\n/-- The radius function for the collection of balls \ud835\udcd1. -/\ndef r\ud835\udcd1 (z : \u2115 \u00d7 Grid X) : \u211d := 2 ^ z.1 * D ^ s z.2\n\nlemma \ud835\udcd1_finite : (\ud835\udcd1 (X := X)).Finite :=\n  finite_Icc .. |>.prod finite_univ\n\n/-- Lemma 7.1.1, freely translated. -/\nlemma convex_scales (hu : u \u2208 t) : OrdConnected (t.\u03c3 u x : Set \u2124) := by\n  rw [ordConnected_def]; intro i mi j mj k mk\n  simp_rw [Finset.mem_coe, \u03c3, Finset.mem_image, Finset.mem_filter, Finset.mem_univ,\n    true_and] at mi mj \u22a2\n  obtain \u27e8p, \u27e8mp, xp, Qxp, sxp\u27e9, sp\u27e9 := mi\n  obtain \u27e8p'', \u27e8mp'', xp'', Qxp'', sxp''\u27e9, sp''\u27e9 := mj\n  have ilj : i \u2264 j := nonempty_Icc.mp \u27e8k, mk\u27e9\n  rw [\u2190 sp, \u2190 sp''] at ilj mk\n  obtain \u27e8K, sK, lK, Kl\u27e9 := Grid.exists_sandwiched (le_of_mem_of_mem ilj xp xp'') k mk\n  have := range_subset_iff.mp (biUnion_\u03a9 (i := K)) x\n  simp_rw [mem_preimage, mem_singleton_iff, mem_iUnion, exists_prop] at this\n  obtain \u27e8(p' : \ud835\udd13 X), (\ud835\udcd8p' : \ud835\udcd8 p' = K), Qxp'\u27e9 := this\n  rw [\u2190 \ud835\udcd8p'] at lK Kl sK; refine \u27e8p', ?_, sK\u27e9\n  have l\u2081 : p \u2264 p' := \u27e8lK,\n    (relative_fundamental_dyadic lK).resolve_left (not_disjoint_iff.mpr \u27e8_, Qxp, Qxp'\u27e9)\u27e9\n  have l\u2082 : p' \u2264 p'' := \u27e8Kl,\n    (relative_fundamental_dyadic Kl).resolve_left (not_disjoint_iff.mpr \u27e8_, Qxp', Qxp''\u27e9)\u27e9\n  refine \u27e8(t.ordConnected hu).out mp mp'' \u27e8l\u2081, l\u2082\u27e9, \u27e8(Grid.le_def.mp lK).1 xp, Qxp', ?_\u27e9\u27e9\n  exact Icc_subset_Icc sxp.1 sxp''.2 \u27e8(Grid.le_def.mp lK).2, (Grid.le_def.mp Kl).2\u27e9\n\n/-- Part of Lemma 7.1.2 -/\n@[simp]\nlemma biUnion_\ud835\udcd9 : \u22c3 J \u2208 \ud835\udcd9 \ud835\udd16, J = \u22c3 I : Grid X, (I : Set X) := by\n  refine subset_antisymm (iUnion\u2082_subset_iUnion ..) fun x mx \u21a6 ?_\n  simp_rw [mem_iUnion] at mx \u22a2; obtain \u27e8I, mI\u27e9 := mx\n  obtain \u27e8J, sJ, mJ\u27e9 :=\n    Grid.exists_containing_subcube _ \u27e8le_rfl, scale_mem_Icc.1\u27e9 mI\n  have : J \u2208 (\ud835\udcd9\u2080 \ud835\udd16).toFinset := by rw [mem_toFinset]; left; exact sJ\n  obtain \u27e8M, lM, maxM\u27e9 := (\ud835\udcd9\u2080 \ud835\udd16).toFinset.exists_le_maximal this\n  simp_rw [mem_toFinset] at maxM\n  use M, maxM, (Grid.le_def.mp lM).1 mJ\n\n/-- Part of Lemma 7.1.2 -/\n@[simp]\nlemma biUnion_\ud835\udcdb : \u22c3 J \u2208 \ud835\udcdb \ud835\udd16, J = \u22c3 I : Grid X, (I : Set X) := by\n  refine subset_antisymm (iUnion\u2082_subset_iUnion ..) fun x mx \u21a6 ?_\n  simp_rw [mem_iUnion] at mx \u22a2; obtain \u27e8I, mI\u27e9 := mx\n  obtain \u27e8J, sJ, mJ\u27e9 :=\n    Grid.exists_containing_subcube _ \u27e8le_rfl, scale_mem_Icc.1\u27e9 mI\n  have : J \u2208 (\ud835\udcdb\u2080 \ud835\udd16).toFinset := by rw [mem_toFinset]; left; exact sJ\n  obtain \u27e8M, lM, maxM\u27e9 := (\ud835\udcdb\u2080 \ud835\udd16).toFinset.exists_le_maximal this\n  simp_rw [mem_toFinset] at maxM\n  use M, maxM, (Grid.le_def.mp lM).1 mJ\n\n/-- Part of Lemma 7.1.2 -/\nlemma pairwiseDisjoint_\ud835\udcdb : (\ud835\udcdb \ud835\udd16).PairwiseDisjoint (fun I \u21a6 (I : Set X)) := fun I mI J mJ hn \u21a6 by\n  have : IsAntichain (\u00b7 \u2264 \u00b7) (\ud835\udcdb \ud835\udd16) := setOf_maximal_antichain _\n  exact (le_or_ge_or_disjoint.resolve_left (this mI mJ hn)).resolve_left (this mJ mI hn.symm)\n\n/-- The constant used in `first_tree_pointwise`.\nHas value `10 * 2 ^ (104 * a ^ 3)` in the blueprint. -/\n-- Todo: define this recursively in terms of previous constants\nirreducible_def C7_1_4 (a : \u2115) : \u211d\u22650 := 10 * 2 ^ (104 * (a : \u211d) ^ 3)\n\n-- Used in the proof of `exp_sub_one_le`, which is used to prove Lemma 7.1.4\nprivate lemma exp_Lipschitz : LipschitzWith 1 (fun (t : \u211d) \u21a6 exp (.I * t)) := by\n  have mul_I : Differentiable \u211d fun (t : \u211d) \u21a6 I * t := Complex.ofRealCLM.differentiable.const_mul I\n  refine lipschitzWith_of_nnnorm_deriv_le mul_I.cexp (fun x \u21a6 ?_)\n  have : (fun (t : \u211d) \u21a6 cexp (I * t)) = cexp \u2218 (fun (t : \u211d) \u21a6 I * t) := rfl\n  rw [this, deriv_comp x differentiableAt_exp (mul_I x), Complex.deriv_exp, deriv_const_mul_field']\n  simp_rw [show deriv ofReal x = 1 from ofRealCLM.hasDerivAt.deriv, mul_one]\n  rw [nnnorm_mul, nnnorm_I, mul_one, \u2190 norm_toNNReal, mul_comm, Complex.norm_exp_ofReal_mul_I]\n  exact Real.toNNReal_one.le\n\n-- Used in the proof of Lemma 7.1.4\nprivate lemma exp_sub_one_le (t : \u211d) : \u2016exp (.I * t) - 1\u2016 \u2264 \u2016t\u2016 := by\n  simpa [enorm_eq_nnnorm] using exp_Lipschitz t 0\n\n-- Used in the proofs of Lemmas 7.1.4 and 7.1.5\nprivate lemma dist_lt_5 (hu : u \u2208 t) (mp : p \u2208 t.\ud835\udd17 u) (Qxp : Q x \u2208 \u03a9 p) :\n    dist_(p) (\ud835\udcac u) (Q x) < 5 := calc\n  _ \u2264 dist_(p) (\ud835\udcac u) (\ud835\udcac p) + dist_(p) (Q x) (\ud835\udcac p) := dist_triangle_right ..\n  _ < 4 + 1 :=\n    add_lt_add ((t.smul_four_le hu mp).2 (by convert mem_ball_self zero_lt_one)) (subset_cball Qxp)\n  _ = 5 := by norm_num\n\n-- The bound in the third display in the proof of Lemma 7.1.4\nprivate lemma L7_1_4_bound (hu : u \u2208 t) {s : \u2124} (hs : s \u2208 t.\u03c3 u x) {y : X} (hKxy : Ks s x y \u2260 0) :\n    \u2016exp (.I * (-\ud835\udcac u y + Q x y + \ud835\udcac u x - Q x x)) - 1\u2016 \u2264\n    5 * 2 ^ (4 * a) * 2 ^ (s - \u03c3Max t u x \u27e8s, hs\u27e9) :=\n  have \u27e8p\u209b, pu, xp\u209b, hp\u209b\u27e9 := t.exists_p_of_mem_\u03c3 u x hs\n  have \u27e8p', p'u, xp', hp'\u27e9 := t.exists_p_of_mem_\u03c3 u x (t.\u03c3Max_mem_\u03c3 u x \u27e8s, hs\u27e9)\n  have hr : (D : \u211d) ^ s / 2 > 0 := by rw [defaultD]; positivity\n  have s_le : GridStructure.s (\ud835\udcd8 p\u209b) \u2264 GridStructure.s (\ud835\udcd8 p') := by convert (\u03c3 t u x).le_max' s hs\n  have exp_bound :\n      \u2016exp (.I * (- \ud835\udcac u y + Q x y + \ud835\udcac u x - Q x x)) - 1\u2016 \u2264 \u2016\ud835\udcac u y - Q x y - \ud835\udcac u x + Q x x\u2016 := by\n    convert exp_sub_one_le (- \ud835\udcac u y + Q x y + \ud835\udcac u x - Q x x) using 1\n    \u00b7 simp\n    \u00b7 rw [\u2190 norm_neg]; ring_nf\n  have : dist_(p\u209b) (\ud835\udcac u) (Q x) \u2264 2 ^ (s - \u03c3Max t u x \u27e8s, hs\u27e9) * dist_(p') (\ud835\udcac u) (Q x) := by\n    have p\u209b_le_p' : \ud835\udcd8 p\u209b \u2264 \ud835\udcd8 p' := le_of_mem_of_mem s_le xp\u209b.1 xp'.1\n    have sub_ge_0 : t.\u03c3Max u x \u27e8s, hs\u27e9 - s \u2265 0 := by unfold \u03c3Max; linarith [(\u03c3 t u x).le_max' s hs]\n    have : GridStructure.s (\ud835\udcd8 p\u209b) + (\u03c3Max t u x \u27e8s, hs\u27e9 - s) = GridStructure.s (\ud835\udcd8 p') := by\n      simp_rw [\u2190 hp', \u2190 hp\u209b, \ud835\udd30, _root_.s]; ring\n    apply le_trans <| Grid.dist_strictMono_iterate' sub_ge_0 p\u209b_le_p' this\n    gcongr\n    calc  C2_1_2 a ^ (t.\u03c3Max u x \u27e8s, hs\u27e9 - s)\n      _ \u2264 C2_1_2 a ^ (t.\u03c3Max u x \u27e8s, hs\u27e9 - s : \u211d)                     := by norm_cast\n      _ \u2264 (1 / 2 : \u211d) ^ (t.\u03c3Max u x \u27e8s, hs\u27e9 - s : \u211d)                  :=\n        Real.rpow_le_rpow (by rw [C2_1_2]; positivity)\n          ((C2_1_2_le_inv_512 X).trans (by norm_num)) (by norm_cast)\n      _ = 2 ^ (s - \u03c3Max t u x \u27e8s, hs\u27e9)                                := by simp [\u2190 Int.cast_sub]\n  calc \u2016exp (.I * (-\ud835\udcac u y + Q x y + \ud835\udcac u x - Q x x)) - 1\u2016\n    _ \u2264 dist_{x, D ^ s / 2} (\ud835\udcac u) (Q x) :=\n      exp_bound.trans <| oscillation_le_cdist x _ (\ud835\udcac u) (Q x)\n        (mem_ball_comm.mp (mem_Ioo.mp (dist_mem_Ioo_of_Ks_ne_zero hKxy)).2) (mem_ball_self hr)\n    _ \u2264 _ := cdist_mono <| ball_subset_ball (show (D : \u211d) ^ s / 2 \u2264 4 * D ^ s by linarith)\n    _ \u2264 defaultA a * dist_{\ud835\udd20 p\u209b, 2 * D ^ s} (\ud835\udcac u) (Q x) := by\n      have two_mul_two : 2 * (2 * (D : \u211d) ^ s) = 4 * D ^ s := by ring\n      have x_in_ball : dist (\ud835\udd20 p\u209b) x < 2 * (2 * D ^ s) := by\n        rw [two_mul_two, \u2190 hp\u209b]\n        exact mem_ball'.mp <| Grid_subset_ball xp\u209b.1\n      refine le_of_eq_of_le ?_ (cdist_le x_in_ball)\n      rw [two_mul_two]\n    _ \u2264 defaultA a * (defaultA a ^ 3 * dist_(p\u209b) (\ud835\udcac u) (Q x)) := by\n      gcongr\n      convert cdist_le_iterate (div_pos (defaultD_pow_pos a s) four_pos) _ _ _ using 2\n      \u00b7 rw [show 2 ^ 3 * ((D : \u211d) ^ s / 4) = 2 * D ^ s by ring]\n      \u00b7 rw [hp\u209b]\n    _ = (defaultA a) ^ 4 * dist_(p\u209b) (\ud835\udcac u) (Q x) := by ring\n    _ \u2264 (2 ^ a) ^ 4 * (2 ^ (s - t.\u03c3Max u x _) * dist_(p') (\ud835\udcac u) (Q x)) := by norm_cast; gcongr\n    _ \u2264 (2 ^ a) ^ 4 * (2 ^ (s - t.\u03c3Max u x _) * 5) := by gcongr; exact (dist_lt_5 hu p'u xp'.2.1).le\n    _ = 5 * 2 ^ (4 * a) * 2 ^ (s - \u03c3Max t u x \u27e8s, hs\u27e9) := by ring\n\n-- The bound used implicitly in the fourth displayed inequality in the proof of Lemma 7.1.4\nvariable (f) in\nprivate lemma L7_1_4_integrand_bound (hu : u \u2208 t) {s : \u2124} (hs : s \u2208 t.\u03c3 u x) (y : X) :\n    \u2016(exp (.I * (- \ud835\udcac u y + Q x y + \ud835\udcac u x - Q x x)) - 1) * Ks s x y * f y\u2016 \u2264\n    5 * 2^(s - \u03c3Max t u x \u27e8s, hs\u27e9) * (2^(103 * a ^ 3) / volume.real (ball x (D ^ s))) * \u2016f y\u2016 := by\n  by_cases hKxy : Ks s x y = 0\n  \u00b7 rw [hKxy, mul_zero, zero_mul, norm_zero]; positivity\n  \u00b7 rw [norm_mul, norm_mul]\n    refine mul_le_mul_of_nonneg_right ?_ (norm_nonneg (f y))\n    apply mul_le_mul (L7_1_4_bound hu hs hKxy) norm_Ks_le (norm_nonneg _) (by positivity) |>.trans\n    rw [mul_assoc 5, mul_comm (2 ^ (4 * a)), \u2190 mul_assoc, mul_assoc, mul_div, C2_1_3]\n    gcongr\n    norm_cast\n    rw_mod_cast [\u2190 pow_add]\n    refine Nat.pow_le_pow_of_le_right two_pos <| Nat.add_le_of_le_sub ?_ ?_\n    \u00b7 exact Nat.mul_le_mul_right _ (by norm_num)\n    \u00b7 rw [\u2190 Nat.sub_mul, (show a ^ 3 = a ^ 2 * a from rfl)]; nlinarith [four_le_a X]\n\n-- The geometric sum used to prove `L7_1_4_sum`\nprivate lemma sum_pow_two_le (a b : \u2124) : \u2211 s \u2208 Finset.Icc a b, (2 : \u211d\u22650) ^ s \u2264 2 ^ (b + 1) := by\n  by_cases h : b < a\n  \u00b7 simp [Finset.Icc_eq_empty_of_lt h]\n  obtain \u27e8k, rfl\u27e9 : \u2203 (k : \u2115), b = a + k := \u27e8(b - a).toNat, by simp [not_lt.mp h]\u27e9\n  suffices \u2211 s \u2208 Finset.Icc a (a + k), (2 : \u211d\u22650) ^ s = 2 ^ a * \u2211 n \u2208 Finset.range (k + 1), 2 ^ n by\n    rw [this, add_assoc, zpow_add' (Or.inl two_ne_zero), mul_le_mul_left (zpow_pos two_pos a),\n      geom_sum_of_one_lt one_lt_two (k + 1), NNReal.sub_def (r := 2)]\n    norm_num\n    exact le_self_add\n  rw [Finset.mul_sum]\n  apply Finset.sum_bij (fun n hn \u21a6 (n - a).toNat)\n  \u00b7 intro n hn\n    rw [Finset.mem_Icc] at hn\n    rw [Finset.mem_range, Int.toNat_lt (Int.sub_nonneg.mpr hn.1), Nat.cast_add, Nat.cast_one]\n    linarith\n  \u00b7 intro n hn m hm hnm\n    rw [Finset.mem_Icc] at hn hm\n    simpa [Int.sub_nonneg.mpr hn.1, Int.sub_nonneg.mpr hm.1] using congrArg Int.ofNat hnm\n  \u00b7 exact fun n hn \u21a6 by use a + n, by simp [Nat.le_of_lt_succ (Finset.mem_range.mp hn)], by simp\n  \u00b7 intro n hn\n    rw [\u2190 zpow_natCast, Int.ofNat_toNat, \u2190 zpow_add' (Or.inl two_ne_zero),\n      sup_eq_left.mpr <| Int.sub_nonneg_of_le (Finset.mem_Icc.mp hn).1, add_sub_cancel]\n\n-- The sum used in the proof of Lemma 7.1.4\nprivate lemma L7_1_4_sum (h\u03c3 : (t.\u03c3 u x).Nonempty) :\n    \u2211 s \u2208 t.\u03c3 u x, (2 : \u211d\u22650) ^ (s - t.\u03c3Max u x h\u03c3) \u2264 2 := by\n  have {s : \u2124} : (2 : \u211d\u22650) ^ (s - t.\u03c3Max u x h\u03c3) = 2 ^ s * 2 ^ (- t.\u03c3Max u x h\u03c3) := by\n    rw [\u2190 zpow_add' (Or.inl two_ne_zero), Int.sub_eq_add_neg]\n  simp_rw [this, \u2190 Finset.sum_mul]\n  suffices \u2211 s \u2208 t.\u03c3 u x, (2 : \u211d\u22650) ^ s \u2264 2 ^ (t.\u03c3Max u x h\u03c3 + 1) from calc\n    _ \u2264 (2 : \u211d\u22650) ^ (t.\u03c3Max u x h\u03c3 + 1) * 2 ^ (-t.\u03c3Max u x h\u03c3) := by gcongr\n    _ = 2 := by rw [zpow_add' (Or.inl two_ne_zero)]; field_simp\n  refine le_trans (Finset.sum_le_sum_of_subset ?_) (sum_pow_two_le (t.\u03c3Min u x h\u03c3) (t.\u03c3Max u x h\u03c3))\n  exact fun s hs \u21a6 Finset.mem_Icc.mpr <| \u27e8(t.\u03c3 u x).min'_le s hs, (t.\u03c3 u x).le_max' s hs\u27e9\n\n-- Inequality used twice in the proof of Lemma 7.1.4\nprivate lemma L7_1_4_dist_le {p : \ud835\udd13 X} (xp : x \u2208 E p) {J : Grid X}\n    (hJ : ((J : Set X) \u2229 ball x (D ^ \ud835\udd30 p / 2)).Nonempty) :\n    dist (c J) (\ud835\udd20 p) \u2264 4 * D ^ (s J) + 4.5 * D ^ (\ud835\udd30 p) := by\n  have \u27e8z, hz\u27e9 := hJ\n  calc dist (c J) (\ud835\udd20 p)\n    _ \u2264 dist (c J) z + dist z x + dist x (\ud835\udd20 p)           := dist_triangle4 (c J) z x (\ud835\udd20 p)\n    _ \u2264 4 * D ^ (s J) + 0.5 * D ^ (\ud835\udd30 p) + 4 * D ^ (\ud835\udd30 p)  := by\n      apply add_le_add_three\n      \u00b7 exact (mem_ball'.mp <| Grid_subset_ball hz.1).le\n      \u00b7 convert (mem_ball.mp hz.2).le using 1\n        exact (eq_div_iff two_ne_zero).mpr (by linarith)\n      \u00b7 exact (mem_ball.mp <| Grid_subset_ball xp.1).le\n    _ \u2264 4 * D ^ (s J) + 4.5 * D ^ (\ud835\udd30 p)                  := by linarith [defaultD_pow_pos a (\ud835\udd30 p)]\n\n-- Inequality needed for the proof of `L7_1_4_integral_le_integral`\nprivate lemma s_le_s {p : \ud835\udd13 X} (pu : p \u2208 t.\ud835\udd17 u) (xp : x \u2208 E p)\n    {J : Grid X} (hJ : J \u2208 \ud835\udcd9 (t.\ud835\udd17 u) \u2227 ((J : Set X) \u2229 ball x (D ^ \ud835\udd30 p / 2)).Nonempty) :\n    s J \u2264 \ud835\udd30 p := by\n  have \u27e8z, hz\u27e9 := hJ.2\n  by_cases h : s J \u2264 \ud835\udd30 p \u2228 s J = -S\n  \u00b7 exact h.elim id (\u00b7 \u25b8 (range_s_subset \u27e8\ud835\udcd8 p, rfl\u27e9).1)\n  push_neg at h\n  apply False.elim \u2218 hJ.1.1.resolve_left h.2 p pu \u2218 le_trans Grid_subset_ball \u2218 ball_subset_ball'\n  have : (D : \u211d) ^ \ud835\udd30 p \u2264 D ^ s J := (zpow_le_zpow_iff_right\u2080 (one_lt_D (X := X))).mpr h.1.le\n  calc 4 * (D : \u211d) ^ GridStructure.s (\ud835\udcd8 p) + dist (GridStructure.c (\ud835\udcd8 p)) (c J)\n    _ \u2264 4 * (D : \u211d) ^ (s J) + (4 * D ^ (s J) + 4.5 * D ^ (s J)) := by\n      gcongr 4 * ?_ + ?_\n      \u00b7 exact this\n      \u00b7 exact dist_comm (c (\ud835\udcd8 p)) (c J) \u25b8 L7_1_4_dist_le xp hJ.2 |>.trans (by gcongr)\n    _ \u2264 100 * D ^ (s J + 1) := by\n      rw [zpow_add' (Or.inl (defaultD_pos a).ne.symm), zpow_one]\n      nlinarith [one_le_D (a := a), defaultD_pow_pos a (s J)]\n\n", "theoremStatement": "private lemma ball_covered_by_\ud835\udcd9 (hu : u \u2208 t) {p : \ud835\udd13 X} (pu : p \u2208 t u) (xp : x \u2208 E p) :\n    ball x (D ^ \ud835\udd30 p / 2) \u2286 \u22c3 J \u2208 \ud835\udcd9 (t.\ud835\udd17 u), (J : Set X) ", "theoremName": "TileStructure.Forest.ball_covered_by_\ud835\udcd9", "fileCreated": {"commit": "5e49c3692f6d7344434caa7eea5f412f0ee35863", "date": "2024-09-27"}, "theoremCreated": {"commit": "2457452cfac134a22b7c5ed56b8812e776a34801", "date": "2025-01-14"}, "file": "carleson/Carleson/ForestOperator/PointwiseEstimate.lean", "module": "Carleson.ForestOperator.PointwiseEstimate", "jsonFile": "Carleson.ForestOperator.PointwiseEstimate.jsonl", "positionMetadata": {"lineInFile": 457, "tokenPositionInFile": 23676, "theoremPositionInFile": 49}, "dependencyMetadata": {"inFilePremises": null, "numInFilePremises": null, "repositoryPremises": null, "numRepositoryPremises": null, "numPremises": null}, "proofMetadata": {"hasProof": true, "proof": ":=\n  calc ball x (D ^ \ud835\udd30 p / 2)\n    _ \u2286 ball x (4 * D ^ \ud835\udd30 p)          := ball_subset_ball <| by linarith [defaultD_pow_pos a (\ud835\udd30 p)]\n    _ \u2286 (\ud835\udcd8 u : Set X)                 := ball_subset_of_mem_\ud835\udcd8 hu pu xp.1\n    _ \u2286 \u22c3 (I : Grid X), (I : Set X)   := le_iSup _ _\n    _ = \u22c3 J \u2208 \ud835\udcd9 (t.\ud835\udd17 u), (J : Set X) := biUnion_\ud835\udcd9.symm", "proofType": "term", "proofLengthLines": 5, "proofLengthTokens": 311}}
{"srcContext": "/-\nCopyright (c) 2024 James Sundstrom. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: James Sundstrom\n-/\nimport Mathlib.MeasureTheory.Constructions.BorelSpace.Metric\n\n/-!\n# Annulus\n\nIn this file we define an annulus in a pseudometric space `X` to be a set consisting of all `y`\nsuch that `dist x y` lies in an interval between `r` and `R`. An annulus is defined for each type\nof interval (`Ioo`, `Ioc`, etc.) with a parallel naming scheme, except that we do not define annuli\nfor `Iio` and `Ico`, as they would be balls.\n\nWe also define `EAnnulus` similarly using `edist` instead of `dist`.\n\n## Tags\n\nannulus, eannulus\n-/\n\nopen Set Metric ENNReal\n\nvariable {X : Type*} [PseudoMetricSpace X]\n\nnamespace Set\n\nnamespace Annulus\n\ndef oo (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d) := {y | dist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d) := {y | dist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d) := {y | dist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d) := {y | dist x y \u2208 Ici r}\n\nlemma oo_eq {x : X} {r R : \u211d} : oo x r R = ball x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oo, dist_comm, and_comm]\n\nlemma oc_eq {x : X} {r R : \u211d} : oc x r R = closedBall x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oc, dist_comm, and_comm]\n\nlemma co_eq {x : X} {r R : \u211d} : co x r R = ball x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [co, dist_comm, and_comm]\n\nlemma cc_eq {x : X} {r R : \u211d} : cc x r R = closedBall x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [cc, dist_comm, and_comm]\n\nlemma oi_eq {x : X} {r : \u211d} : oi x r = (closedBall x r)\u1d9c := by\n  ext; simp [oi, dist_comm]\n\nlemma ci_eq {x : X} {r : \u211d} : ci x r = (ball x r)\u1d9c := by\n  ext; simp [ci, dist_comm]\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : co x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma co_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : co x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\nlemma cc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : cc x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma cc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : cc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\n@[simp]\nlemma oc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    oc x r r' \u222a oo x r' R = oo x r R := by\n  ext; simp_rw [oc, oo, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioo_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    oc x r r' \u222a oc x r' R = oc x r R := by\n  ext; simp_rw [oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_co {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a co x r' R = oo x r R := by\n  ext; simp_rw [oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ico_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a cc x r' R = oc x r R := by\n  ext; simp_rw [oo, cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Icc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    cc x r r' \u222a oo x r' R = co x r R := by\n  ext; simp_rw [cc, oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioo_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    cc x r r' \u222a oc x r' R = cc x r R := by\n  ext; simp_rw [cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_co {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a co x r' R = co x r R := by\n  ext; simp_rw [co, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ico_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a cc x r' R = cc x r R := by\n  ext; simp_rw [co, cc, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Icc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : oc x r R \u222a oi x R = oi x r := by\n  ext; simp_rw [oc, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioi_eq_Ioi h]\n\n@[simp]\nlemma oo_union_ci {x : X} {r R : \u211d} (h : r < R) :\n    oo x r R \u222a ci x R = oi x r := by\n  ext; simp_rw [oo, ci, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ici_eq_Ioi h]\n\n@[simp]\nlemma cc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : cc x r R \u222a oi x R = ci x r := by\n  ext; simp_rw [cc, oi, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioi_eq_Ici h]\n\n@[simp]\nlemma co_union_ci {x : X} {r R : \u211d} (h : r \u2264 R) : co x r R \u222a ci x R = ci x r := by\n  ext; simp_rw [co, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ici_eq_Ici h]\n\n\nvariable [MeasurableSpace X] [OpensMeasurableSpace X]\n\n@[measurability]\nlemma measurableSet_oo {x : X} {r R : \u211d} : MeasurableSet (oo x r R) := by\n  rw [oo_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oc {x : X} {r R : \u211d} : MeasurableSet (oc x r R) := by\n rw [oc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_co {x : X} {r R : \u211d} : MeasurableSet (co x r R) := by\n  rw [co_eq]; measurability\n\n@[measurability]\nlemma measurableSet_cc {x : X} {r R : \u211d} : MeasurableSet (cc x r R) := by\n rw [cc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oi {x : X} {r : \u211d} : MeasurableSet (oi x r) := by\n  rw [oi_eq]; measurability\n\n@[measurability]\nlemma measurableSet_ci {x : X} {r : \u211d} : MeasurableSet (ci x r) := by\n  rw [ci_eq]; measurability\n\nend Annulus\n\nnamespace EAnnulus\n\ndef oo (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ici r}\n\n\nlemma oo_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oo x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oo x r R := by\n  simp_rw [oo, Annulus.oo, edist_dist, mem_Ioo, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma oc_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [oc, Annulus.oc, edist_dist, mem_Ioc, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  \u00b7 have R_le_r := (lt_of_lt_of_le (lt_of_not_ge hR) hr).le\n    rw [Annulus.oc_eq_empty R_le_r]\n    refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n    exact not_le_of_gt (lt_of_le_of_lt (ENNReal.ofReal_le_ofReal R_le_r) hy.1) hy.2\n\nlemma co_eq_annulus {x : X} {r R : \u211d} :\n    co x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.co x r R := by\n  simp_rw [co, Annulus.co, edist_dist, mem_Ico, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma cc_eq_annulus {x : X} {r R : \u211d} (h : r > 0 \u2228 R \u2265 0) :\n    cc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.cc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [cc, Annulus.cc, edist_dist, mem_Icc, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  have r0 := h.resolve_right hR\n  have R_lt_r := (lt_of_not_ge hR).trans r0\n  rw [Annulus.cc_eq_empty R_lt_r]\n  refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n  exact not_le_of_gt ((ENNReal.ofReal_lt_ofReal_iff r0).mpr R_lt_r) (hy.1.trans hy.2)\n\nlemma oi_eq_annulus {x : X} {r : \u211d} (hr : r \u2265 0) : oi x (ENNReal.ofReal r) = Annulus.oi x r := by\n  simp_rw [oi, Annulus.oi, edist_dist, mem_Ioi, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr]\n\nlemma ci_eq_annulus {x : X} {r : \u211d} : ci x (ENNReal.ofReal r) = Annulus.ci x r := by\n  simp_rw [ci, Annulus.ci, edist_dist, mem_Ici, ENNReal.ofReal_le_ofReal_iff dist_nonneg]\n\n\nlemma oo_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oo x r R = ball x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oo, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma oc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oc x r R = closedBall x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oc, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma co_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    co x r R = ball x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [co, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma cc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    cc x r R = closedBall x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [cc, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma oi_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : oi x r = (closedBall x r.toReal)\u1d9c := by\n  ext; simp [oi, edist_dist, dist_comm, lt_ofReal_iff_toReal_lt hr.ne]\n\nlemma ci_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : ci x r = (ball x r.toReal)\u1d9c := by\n  ext; simp [ci, edist_dist, dist_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg]\n\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n@[simp]\nlemma cc_top_eq_empty {x : X} {R : \u211d\u22650\u221e} : cc x \u22a4 R = \u2205 :=\n  eq_empty_of_forall_not_mem (fun y hy \u21a6 (edist_ne_top x y) (top_le_iff.mp hy.1))\n\n@[simp]\nlemma oi_eq_empty {x : X} : oi x \u22a4 = \u2205 := by simp [oi, edist_dist]\n\n@[simp]\nlemma ci_eq_empty {x : X} : ci x \u22a4 = \u2205 := by simp [ci, edist_dist]\n\n\nlemma oo_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) :\n    oo x r \u22a4 = (closedBall x r.toReal)\u1d9c := by\n  ext; simpa [oo, edist_dist, dist_comm] using lt_ofReal_iff_toReal_lt hr.ne\n\nlemma oc_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) :\n    oc x r \u22a4 = (closedBall x r.toReal)\u1d9c := by\n  ext; simpa [oc, edist_dist, dist_comm] using lt_ofReal_iff_toReal_lt hr.ne\n\nlemma co_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : co x r \u22a4 = (ball x r.toReal)\u1d9c := by\n  ext; simpa [co, edist_dist, dist_comm] using le_ofReal_iff_toReal_le hr.ne dist_nonneg\n\nlemma cc_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : cc x r \u22a4 = (ball x r.toReal)\u1d9c := by\n  ext; simpa [cc, edist_dist, dist_comm] using le_ofReal_iff_toReal_le hr.ne dist_nonneg\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\n", "theoremStatement": "lemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 ", "theoremName": "Set.EAnnulus.co_subset_oc", "fileCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "theoremCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "file": "carleson/Carleson/ToMathlib/Annulus.lean", "module": "Carleson.ToMathlib.Annulus", "jsonFile": "Carleson.ToMathlib.Annulus.jsonl", "positionMetadata": {"lineInFile": 416, "tokenPositionInFile": 16326, "theoremPositionInFile": 100}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 27}, "proofMetadata": {"hasProof": true, "proof": ":=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 64}}
{"srcContext": "import Carleson.ForestOperator.PointwiseEstimate\nimport Carleson.ToMathlib.Misc\nimport Carleson.ToMathlib.ENorm\nimport Carleson.ToMathlib.Annulus\n\nnoncomputable section\n\nopen Set MeasureTheory Metric Function Complex Bornology TileStructure Classical Filter\nopen scoped NNReal ENNReal ComplexConjugate\n\nopen ShortVariables\nvariable {X : Type*} {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102} {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X}\n  [MetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] {f : X \u2192 \u2102}\n\nlemma integrableOn_K_mul_f (x' : X) (hf : BoundedCompactSupport f) (r : \u211d\u22650\u221e) (hr : 0 < r) :\n    IntegrableOn (fun y \u21a6 K x' y * f y) (EAnnulus.ci x' r) := by\n  by_cases supp_f : (support f).Nonempty; swap\n  \u00b7 simp [Function.support_eq_empty_iff.mp <| Set.not_nonempty_iff_eq_empty.mp supp_f]\n  by_cases r_top : r = \u22a4\n  \u00b7 simp [r_top]\n  have \u27e8x'', hx''\u27e9 := supp_f\n  have \u27e8C, hC\u27e9 := Metric.isBounded_iff.mp hf.isBoundedSupport\n  have : support (fun y \u21a6 f y * K x' y) \u2286 closedBall x' (dist x' x'' + C) := by\n    intro y hy\n    have : y \u2208 support f := by contrapose! hy; simp [hy]\n    exact mem_closedBall'.mp <| (dist_triangle x' x'' y).trans <| add_le_add_left (hC hx'' this) _\n  simp_rw [mul_comm (K x' _), IntegrableOn, \u2190 integrableOn_iff_integrable_of_support_subset this]\n  apply hf.integrable_mul\n  rw [Measure.restrict_restrict measurableSet_closedBall, inter_comm, \u2190 IntegrableOn]\n  convert integrableOn_K_Icc (K := K) (R := dist x' x'' + C) (r.toReal_pos hr.ne.symm r_top) using 1\n  ext y\n  simp [edist_dist, dist_comm y, EAnnulus.ci, ENNReal.le_ofReal_iff_toReal_le r_top dist_nonneg]\n\n\n-- Truncated version of `K` used in proof of `nontangential_pointwise_bound`\nprivate def K' (b : \u2124) (c : \u2124) (x y : X) := \u2211 i \u2208 (Icc b c).toFinset, Ks i x y\n\nnamespace K'\n\nprivate lemma eq_K (b : \u2124) (c : \u2124) (x y : X)\n    (h : dist x y \u2208 Icc ((D : \u211d) ^ (b - 1) / 2) (D ^ c / 4)) : K' b c x y = K x y := by\n  have hxy : dist x y > 0 := lt_of_lt_of_le (div_pos (defaultD_pow_pos a (b - 1)) two_pos) h.1\n  simp_rw [K', Ks, \u2190 Finset.mul_sum, \u2190 Complex.ofReal_sum]\n  rw [\u2190 finsum_eq_sum_of_support_subset, finsum_\u03c8 (one_lt_D (X := X)) hxy, ofReal_one, mul_one]\n  rw [toFinset_Icc, Finset.coe_Icc]\n  exact support_\u03c8S_subset_Icc (one_lt_D (X := X)) h\n\nprivate lemma integrableOn_mul_f (x' : X) (hf : BoundedCompactSupport f) (r : \u211d\u22650\u221e) (hr : 0 < r)\n    (s\u2081 s\u2082 : \u2124) : IntegrableOn (fun y \u21a6 K' s\u2081 s\u2082 x' y * f y) (EAnnulus.ci x' r) := by\n  simp_rw [K', Ks, mul_comm (K x' _) (\u03c8 _), \u2190 Finset.sum_mul, mul_assoc]\n  apply Integrable.bdd_mul (integrableOn_K_mul_f x' hf r hr)\n  \u00b7 refine (Finset.aestronglyMeasurable_sum _ (fun i hi \u21a6 ?_)).restrict\n    apply continuous_ofReal.comp_aestronglyMeasurable \u2218 continuous_\u03c8.comp_aestronglyMeasurable\n    exact (continuous_const.dist continuous_id').aestronglyMeasurable.const_mul _\n  \u00b7 refine \u27e8(s\u2082 + 1 - s\u2081).toNat, fun _ \u21a6 le_trans (norm_sum_le ..) ?_\u27e9\n    simp_rw [norm_eq_abs, abs_ofReal]\n    exact le_of_le_of_eq (Finset.sum_le_sum fun _ _ \u21a6 abs_\u03c8_le_one _ _) (by simp)\n\nprivate lemma support_subset (b : \u2124) (c : \u2124) (x : X) :\n    support (K' b c x) \u2286 Annulus.cc x (D ^ (b - 1) / 4) (D ^ c / 2) := by\n  refine subset_trans ?_ (Annulus.oo_subset_cc (le_refl _) (le_refl _))\n  intro y hy\n  rw [mem_support] at hy\n  simp only [Annulus.oo, mem_Ioo, mem_setOf_eq]\n  contrapose! hy\n  refine Finset.sum_eq_zero (fun s hs \u21a6 ?_)\n  rw [toFinset_Icc] at hs\n  suffices ((D : \u211d) ^ s)\u207b\u00b9 * dist x y \u2209 support \u03c8 by simp [Ks, nmem_support.mp this, -defaultD]\n  rw [support_\u03c8 (one_lt_D (X := X)), mem_Ioo, not_and_or]\n  by_cases h : (D : \u211d) ^ (b - 1) / 4 < dist x y\n  \u00b7 exact Or.inr <| not_lt_of_ge <| calc\n      _ \u2265 ((D : \u211d) ^ c)\u207b\u00b9 * (D ^ c / 2) := by\n        gcongr\n        \u00b7 exact defaultD_pow_pos a s\n        \u00b7 exact one_le_D\n        \u00b7 exact (Finset.mem_Icc.mp hs).2\n        \u00b7 exact hy h\n      _ = 2\u207b\u00b9 := by field_simp\n  \u00b7 push_neg at h\n    exact Or.inl <| not_lt_of_ge <| calc\n      ((D : \u211d) ^ s)\u207b\u00b9 * dist x y \u2264 ((D : \u211d) ^ b)\u207b\u00b9 * (D ^ (b - 1) / 4) := by\n                                 refine mul_le_mul ?_ h dist_nonneg ?_\n                                 \u00b7 apply inv_anti\u2080 (defaultD_pow_pos a b)\n                                   exact zpow_right_mono\u2080 one_le_D (Finset.mem_Icc.mp hs).1\n                                 \u00b7 exact inv_nonneg.mpr (defaultD_pow_pos a b).le\n      _                          = (4 * (D : \u211d))\u207b\u00b9 := by\n                                 rw [zpow_sub\u2080 (defaultD_pos a).ne.symm]; field_simp; apply mul_comm\n\nprivate lemma enorm_le_enorm_K (a : \u2124) (b : \u2124) (x y : X) : \u2016K' a b x y\u2016\u2091 \u2264 \u2016K x y\u2016\u2091 := by\n  unfold K' Ks\n  by_cases hxy : 0 = dist x y\n  \u00b7 simp [\u2190 hxy, psi_zero]\n  rw [\u2190 mul_one \u2016K x y\u2016\u2091, \u2190 Finset.mul_sum, enorm_mul]\n  apply mul_le_mul_left'\n  rw [enorm_eq_nnnorm]\n  norm_cast\n  apply le_trans <| nnnorm_sum_le _ _\n  simp_rw [\u2190 norm_toNNReal, Real.norm_eq_abs, \u2190 Real.toNNReal_sum_of_nonneg fun _ _ \u21a6 abs_nonneg _,\n    Real.toNNReal_le_one, abs_eq_self.mpr <| zero_le_\u03c8 _ _]\n  exact sum_\u03c8_le (one_lt_D (X := X)) _ <| lt_of_le_of_ne dist_nonneg hxy\n\nend K'\n\n-- Bound needed for proof of `nontangential_pointwise_bound`, splitting the annulus between radii\n-- `r\u2081` and `r\u2084` into annuli between `r\u2081` and `r\u2082`, between `r\u2082` and `r\u2083`, and between `r\u2083` and\n-- `r\u2084`. Note that we assume only `r\u2081 \u2264 r\u2082` and `r\u2083 \u2264 r\u2084`.\nprivate lemma annulus_integral_bound (x : X) (g : X \u2192 \u2102) {r\u2081 r\u2082 r\u2083 r\u2084 : \u211d} (h\u2081\u2082 : r\u2081 \u2264 r\u2082)\n    (h\u2083\u2084 : r\u2083 \u2264 r\u2084) (hg : IntegrableOn g (Annulus.cc x r\u2081 r\u2084)) :\n    \u2016\u222b y in Annulus.cc x r\u2081 r\u2084, g y\u2016\u2091 \u2264 \u2016\u222b y in Annulus.oo x r\u2082 r\u2083, g y\u2016\u2091 +\n    ((\u222b\u207b y in Annulus.cc x r\u2081 r\u2082, \u2016g y\u2016\u2091) + \u222b\u207b y in Annulus.cc x r\u2083 r\u2084, \u2016g y\u2016\u2091) := calc\n  _ = \u2016(\u222b y in Annulus.cc x r\u2081 r\u2084 \u2229 Annulus.oo x r\u2082 r\u2083, g y) +\n        \u222b y in Annulus.cc x r\u2081 r\u2084 \u2229 (Annulus.oo x r\u2082 r\u2083)\u1d9c, g y\u2016\u2091 := by\n    apply congrArg (\u2016\u00b7\u2016\u2091)\n    rw [\u2190 setIntegral_union (Set.disjoint_left.mpr (fun _ h\u2081 h\u2082 \u21a6 h\u2082.2 h\u2081.2)) (by measurability),\n        inter_union_compl] <;>\n      exact hg.mono_set inter_subset_left\n  _ \u2264 \u2016\u222b y in Annulus.cc x r\u2081 r\u2084 \u2229 Annulus.oo x r\u2082 r\u2083, g y\u2016\u2091 +\n        \u2016\u222b y in Annulus.cc x r\u2081 r\u2084 \u2229 (Annulus.oo x r\u2082 r\u2083)\u1d9c, g y\u2016\u2091 := by apply ENormedAddMonoid.enorm_add_le\n  _ \u2264 _ := by\n    gcongr\n    \u00b7 rw [inter_eq_self_of_subset_right <| Annulus.oo_subset_cc h\u2081\u2082 h\u2083\u2084]\n    \u00b7 calc\n        _ \u2264 _ := enorm_integral_le_lintegral_enorm _\n        _ \u2264 \u222b\u207b y in Annulus.cc x r\u2081 r\u2082 \u222a Annulus.cc x r\u2083 r\u2084, \u2016g y\u2016\u2091 := by\n          refine lintegral_mono_set (fun y \u21a6 ?_)\n          simp only [Annulus.oo, Annulus.cc, edist_dist, mem_Ioo, mem_Icc, mem_inter_iff,\n            mem_setOf_eq, mem_compl_iff, not_and, not_le, mem_union, and_imp]\n          intro hr\u2081 hr\u2084 hr\u2082\u2083\n          by_cases hr\u2082 : r\u2082 < dist x y\n          \u00b7 exact Or.inr \u27e8le_of_not_gt (hr\u2082\u2083 hr\u2082), hr\u2084\u27e9\n          \u00b7 exact Or.inl \u27e8hr\u2081, le_of_not_gt hr\u2082\u27e9\n        _ \u2264 _ := lintegral_union_le _ _ _\n\nlemma CMB_defaultA_two_eq {a : \u2115} : CMB (defaultA a) 2 = 2 ^ (a + (3 / 2 : \u211d)) := by\n  suffices (2 : \u211d\u22650) * 2 ^ (2 : \u211d)\u207b\u00b9 * (ENNReal.ofReal |2 - 1|\u207b\u00b9).toNNReal ^ (2 : \u211d)\u207b\u00b9 *\n      ((2 ^ a) ^ (2 : \u211d)) ^ (2 : \u211d)\u207b\u00b9 = 2 ^ (a + 3 / (2 : \u211d)) by\n    simpa [CMB, C_realInterpolation, C_realInterpolation_ENNReal]\n  rw [\u2190 NNReal.rpow_mul, show (3 / 2 : \u211d) = 1 + (1 / 2 : \u211d) by norm_num]\n  repeat rw [NNReal.rpow_add two_ne_zero]\n  norm_num\n  ring\n\nopen ShortVariables TileStructure\nvariable {X : Type*} {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102} {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X}\n  [MetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] [TileStructure Q D \u03ba S o]\n  {n j j' : \u2115} {t : Forest X n} {u u\u2081 u\u2082 p : \ud835\udd13 X} {x x' : X} {\ud835\udd16 : Set (\ud835\udd13 X)}\n  {f f\u2081 f\u2082 g g\u2081 g\u2082 : X \u2192 \u2102} {I J J' L : Grid X}\nvariable {E' : Type*} [NormedAddCommGroup E'] [NormedSpace \u211d E']\n\nnamespace TileStructure.Forest\n\nlemma eLpNorm_MB_le {\ud835\udd5c : Type*} [RCLike \ud835\udd5c] {f : X \u2192 \ud835\udd5c} (hf : BoundedCompactSupport f) :\n    eLpNorm (MB volume \ud835\udcd1 c\ud835\udcd1 r\ud835\udcd1 f \u00b7) 2 volume \u2264 CMB (defaultA a : \u211d\u22650) 2 * eLpNorm f 2 volume :=\n  hasStrongType_MB_finite \ud835\udcd1_finite one_lt_two f (hf.mem\u2112p 2) |>.2\n\n/-! ## Section 7.2 and Lemma 7.2.1 -/\n\n/-- The constant used in `nontangential_operator_bound`.\nPreviously had value `2 ^ (103 * a ^ 3)` in the blueprint. -/\n-- Todo: define this recursively in terms of previous constants\nirreducible_def C7_2_2 (a : \u2115) : \u211d\u22650 := 2 ^ (102 * (a : \u211d) ^ 3)\n\n-- Bound for (7.2.3) in the proof of `nontangential_pointwise_bound`\nomit [TileStructure Q D \u03ba S o] in\nprivate lemma nontangential_integral_bound\u2081 {x x' : X} {r : \u211d} (R : \u211d) (hr : dist x x' < r) :\n    \u2016\u222b y in Annulus.oo x' r R, K x' y * f y\u2016\u2091 \u2264 nontangentialOperator K f x := by\n  by_cases r_lt_R : r < R; swap\n  \u00b7 simp [-defaultD, Annulus.oo_eq_empty (le_of_not_gt r_lt_R)]\n  refine le_trans ?_ <| le_iSup _ r\n  refine le_trans ?_ <| le_iSup _ R\n  rw [iSup_pos r_lt_R]\n  refine le_of_eq_of_le ?_ <| le_iSup _ x'\n  rw [iSup_pos hr, Annulus.oo, enorm_eq_nnnorm]\n\n-- Bound for (7.2.4) and (7.2.5) in the proof of `nontangential_pointwise_bound`\nprivate lemma nontangential_integral_bound\u2082 (hf : BoundedCompactSupport f) {x x' : X}\n    {I : Grid X} (hx : x \u2208 I) (hx' : x' \u2208 I) {R : \u211d} (h : R \u2264 8 * D ^ (s I)) :\n    \u222b\u207b y in Annulus.cc x' ((D : \u211d) ^ (s I - 1) / 4) R, \u2016K x' y * f y\u2016\u2091 \u2264\n    2 ^ (7 * (a : \u211d) + 101 * a ^ 3) * MB volume \ud835\udcd1 c\ud835\udcd1 r\ud835\udcd1 f x := by\n  apply (lintegral_mono_set (Annulus.cc_subset_cc (le_refl _) h)).trans\n  have ineq : \u2200 y \u2208 Annulus.cc x' ((D : \u211d) ^ (s I - 1) / 4) (8 * D ^ (s I)), \u2016K x' y * f y\u2016\u2091 \u2264\n      2 ^ (7 * (a : \u211d) + 101 * a ^ 3) / volume (ball (c I) (16 * D ^ (s I))) * \u2016f y\u2016\u2091 := by\n    intro y hy\n    rw [Annulus.cc] at hy\n    rw [enorm_mul]\n    refine mul_le_mul_right' ((ennnorm_K_le 5 hy.1).trans ?_) \u2016f y\u2016\u2091\n    gcongr\n    \u00b7 norm_num\n    \u00b7 norm_num\n    \u00b7 suffices dist (c I) x' < 16 * D ^ (s I) from ball_subset_ball' (by linarith)\n      rw [\u2190 mem_ball', s]\n      refine ball_subset_ball ?_ (Grid_subset_ball hx')\n      linarith [defaultD_pow_pos a (GridStructure.s I)]\n  apply le_trans <| setLIntegral_mono (hf.stronglyMeasurable.measurable.enorm.const_mul _) ineq\n  simp_rw [ENNReal.mul_comm_div, div_eq_mul_inv]\n  have := hf.stronglyMeasurable.measurable.enorm\n  rw [lintegral_const_mul _ (this.mul_const _), lintegral_mul_const _ this, \u2190 div_eq_mul_inv]\n  apply mul_left_mono\n  calc\n    _ \u2264 (\u222b\u207b y in ball (c I) (16 * D ^ s I), \u2016f y\u2016\u2091) / volume (ball (c I) (16 * D ^ s I)) := by\n      gcongr\n      refine lintegral_mono' (Measure.le_iff.mpr (fun T hT \u21a6  ?_)) (le_refl _)\n      rw [Measure.restrict_apply hT, Measure.restrict_apply hT]\n      refine measure_mono (inter_subset_inter_right T (fun y \u21a6 ?_))\n      simp only [Annulus.cc, mem_Icc, mem_setOf_eq, mem_ball, and_imp, dist_comm x']\n      intro _ h\n      calc dist y (c I)\n        _ \u2264 dist y x' + dist x' (c I) := dist_triangle y x' (c I)\n        _ \u2264 8 * (D : \u211d) ^ s I + 4 * (D : \u211d) ^ s I :=\n          add_le_add h (mem_ball.mp (Grid_subset_ball hx')).le\n        _ < 16 * (D : \u211d) ^ s I := by linarith [defaultD_pow_pos a (s I)]\n    _ = \u2a0d\u207b y in ball (c I) (16 * D ^ s I), \u2016f y\u2016\u2091 \u2202volume := by rw [setLaverage_eq]\n    _ \u2264 MB volume \ud835\udcd1 c\ud835\udcd1 r\ud835\udcd1 f x := by\n      rw [MB, maximalFunction, inv_one, ENNReal.rpow_one]\n      have : \u27e84, I\u27e9 \u2208 \ud835\udcd1 := by simp [\ud835\udcd1]\n      refine le_of_eq_of_le ?_ (le_biSup _ this)\n      have : x \u2208 ball (c I) (2 ^ 4 * (D : \u211d) ^ s I) := by\n        refine (ball_subset_ball ?_) (Grid_subset_ball hx)\n        unfold s\n        linarith [defaultD_pow_pos a (GridStructure.s I)]\n      simp_rw [c\ud835\udcd1, r\ud835\udcd1, ENNReal.rpow_one, indicator_of_mem this, enorm_eq_nnnorm]\n      norm_num\n\n-- Pointwise bound needed for Lemma 7.2.2\n", "theoremStatement": "private lemma nontangential_pointwise_bound (hf : BoundedCompactSupport f) (\u03b8 : \u0398 X) (x : X) :\n    nontangentialMaximalFunction \u03b8 f x \u2264 nontangentialOperator K f x +\n      2 ^ (1 + 7 * (a : \u211d) + 101 * a ^ 3) * MB volume \ud835\udcd1 c\ud835\udcd1 r\ud835\udcd1 f x ", "theoremName": "TileStructure.Forest.nontangential_pointwise_bound", "fileCreated": {"commit": "5e49c3692f6d7344434caa7eea5f412f0ee35863", "date": "2024-09-27"}, "theoremCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "file": "carleson/Carleson/ForestOperator/L2Estimate.lean", "module": "Carleson.ForestOperator.L2Estimate", "jsonFile": "Carleson.ForestOperator.L2Estimate.jsonl", "positionMetadata": {"lineInFile": 225, "tokenPositionInFile": 11307, "theoremPositionInFile": 12}, "dependencyMetadata": {"inFilePremises": null, "numInFilePremises": null, "repositoryPremises": null, "numRepositoryPremises": null, "numPremises": null}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  refine iSup\u2082_le fun I hI \u21a6 iSup\u2082_le fun x' hx' \u21a6 iSup\u2082_le fun s\u2082 hs\u2082 \u21a6 iSup_le fun _ \u21a6 ?_\n  rw [\u2190 enorm_eq_nnnorm, \u2190 integral_finset_sum]; swap\n  \u00b7 intro i hi\n    simp_rw [mul_comm]\n    exact hf.integrable_mul (integrable_Ks_x <| one_lt_D (X := X))\n  simp_rw [\u2190 Finset.sum_mul]\n  have ineq {n : \u2115} (hn : n > 0) : (D : \u211d) ^ (s I - 1) / n < 8 * D ^ s I := by\n    rw [zpow_sub\u2080 (defaultD_pos a).ne.symm, div_div, zpow_one]\n    calc (D : \u211d) ^ s I / ((D : \u211d) * n)\n      _ \u2264 D ^ s I / 1 := by gcongr; exact_mod_cast (mul_pos (defaultD_pos' a) hn)\n      _ < 8 * D ^ s I := by linarith [defaultD_pow_pos a (s I)]\n  calc\n    _ = \u2016\u222b y in Annulus.cc x' (D ^ (s I - 1) / 4) (D ^ s\u2082 / 2), K' (s I) s\u2082 x' y * f y\u2016\u2091 := by\n      rw [\u2190 integral_indicator Annulus.measurableSet_cc]\n      congr\n      ext y\n      by_cases hy : y \u2208 Annulus.cc x' (D ^ (s I - 1) / 4) (D ^ s\u2082 / 2)\n      \u00b7 simp only [K', hy, indicator_of_mem]\n      \u00b7 have K'_eq_zero := nmem_support.mp <| not_mem_subset (K'.support_subset (s I) s\u2082 x') hy\n        rw [\u2190 K', K'_eq_zero, zero_mul, indicator_of_not_mem hy]\n    _ \u2264 \u2016\u222b y in Annulus.oo x' (8 * D ^ (s I)) (D ^ (s\u2082 - 1) / 4), K' (s I) s\u2082 x' y * f y\u2016\u2091 +\n          ((\u222b\u207b y in Annulus.cc x' (D ^ (s I - 1) / 4) (8 * D ^ (s I)), \u2016K' (s I) s\u2082 x' y * f y\u2016\u2091) +\n          \u222b\u207b y in Annulus.cc x' (D ^ (s\u2082 - 1) / 4) (D ^ s\u2082 / 2), \u2016K' (s I) s\u2082 x' y * f y\u2016\u2091) := by\n      apply annulus_integral_bound\n      \u00b7 exact (ineq four_pos).le\n      \u00b7 gcongr\n        \u00b7 exact one_lt_D (X := X) |>.le\n        \u00b7 exact sub_one_lt s\u2082 |>.le\n        \u00b7 norm_num\n      \u00b7 refine K'.integrableOn_mul_f x' hf (ENNReal.ofReal (D ^ (s I - 1) / 4)) ?_ (s I) s\u2082\n          |>.mono_set ?_\n        \u00b7 exact ENNReal.ofReal_pos.mpr <| div_pos (defaultD_pow_pos a (s I - 1)) four_pos\n        \u00b7 rw [EAnnulus.ci_eq_annulus]\n          exact Annulus.cc_subset_ci (le_refl _)\n    _ \u2264 \u2016\u222b y in Annulus.oo x' (8 * D ^ (s I)) (D ^ (s\u2082 - 1) / 4), K x' y * f y\u2016\u2091 +\n          ((\u222b\u207b y in Annulus.cc x' (D ^ (s I - 1) / 4) (8 * D ^ (s I)), \u2016K x' y * f y\u2016\u2091) +\n          \u222b\u207b y in Annulus.cc x' (D ^ (s\u2082 - 1) / 4) (D ^ s\u2082 / 2), \u2016K x' y * f y\u2016\u2091) := by\n      have norm_K'_f_le : \u2200 (y : X), \u2016K' (s I) s\u2082 x' y * f y\u2016\u2091 \u2264 \u2016K x' y * f y\u2016\u2091 := by\n        simp_rw [enorm_mul]\n        exact fun y \u21a6 mul_le_mul_of_nonneg_right (K'.enorm_le_enorm_K _ _ _ _) (zero_le _)\n      gcongr\n      \u00b7 refine (congrArg (\u2016\u00b7\u2016\u2091) <| setIntegral_congr_fun Annulus.measurableSet_oo fun y hy \u21a6 ?_).le\n        apply mul_eq_mul_right_iff.mpr \u2218 Or.inl \u2218 K'.eq_K (s I) s\u2082 x' y\n        simp only [Annulus.oo, mem_Ioo, mem_setOf_eq] at hy\n        have i1 := hy.1\n        have i2 := hy.2.le\n        refine mem_Icc.mpr \u27e8(lt_trans (ineq two_pos) i1).le, i2.trans ?_\u27e9\n        rw [zpow_sub\u2080 (defaultD_pos a).ne.symm, div_div, zpow_one]\n        have : (D : \u211d) * 4 > 0 := mul_pos (defaultD_pos a) four_pos\n        apply (div_le_div_iff_of_pos_left (defaultD_pow_pos a s\u2082) this four_pos).mpr\n        norm_cast\n        linarith [defaultD_pos' a]\n      \u00b7 exact norm_K'_f_le _\n      \u00b7 exact norm_K'_f_le _\n    _ \u2264 nontangentialOperator K f x + (2 ^ (7 * (a : \u211d) + 101 * a ^ 3) * MB volume \ud835\udcd1 c\ud835\udcd1 r\ud835\udcd1 f x +\n          2 ^ (7 * (a : \u211d) + 101 * a ^ 3) * MB volume \ud835\udcd1 c\ud835\udcd1 r\ud835\udcd1 f x) := by\n      gcongr\n      \u00b7 apply nontangential_integral_bound\u2081 (D ^ (s\u2082 - 1) / 4)\n        apply lt_of_le_of_lt (dist_triangle x (c I) x')\n        replace hI := mem_ball.mp (Grid_subset_ball hI)\n        replace hx' := mem_ball'.mp (Grid_subset_ball hx')\n        apply lt_of_lt_of_eq (add_lt_add hI hx')\n        unfold s\n        ring\n      \u00b7 exact nontangential_integral_bound\u2082 hf hI hx' (le_refl _)\n      \u00b7 let I\u2082 := cubeOf s\u2082 x\n        have hs\u2082' : s\u2082 \u2208 Icc (-(S : \u2124)) (S : \u2124) :=\n          Icc_subset_Icc (Set.range_subset_iff.mp range_s_subset I |>.1) (le_refl (S : \u2124)) hs\u2082\n        have \u27e8xI\u2082, hI\u2082\u27e9 := cubeOf_spec hs\u2082' I hI\n        rw [\u2190 hI\u2082]\n        have : s I \u2264 s I\u2082 := by rw [hI\u2082]; exact hs\u2082.1\n        have := (fundamental_dyadic this).resolve_right (Set.not_disjoint_iff.mpr \u27e8x, \u27e8hI, xI\u2082\u27e9\u27e9)\n        apply nontangential_integral_bound\u2082 hf xI\u2082 (this hx')\n        linarith [defaultD_pow_pos a (s (cubeOf s\u2082 x))]\n    _ = _ := by\n      rw [\u2190 two_mul, \u2190 mul_assoc, add_assoc, ENNReal.rpow_add 1 _ two_ne_zero ENNReal.ofNat_ne_top,\n        ENNReal.rpow_one]", "proofType": "tactic", "proofLengthLines": 77, "proofLengthTokens": 4221}}
{"srcContext": "import Carleson.Discrete.Defs\nimport Mathlib.Combinatorics.Enumerative.DoubleCounting\nimport Carleson.Antichain.AntichainOperator\nimport Carleson.Discrete.SumEstimates\n\nopen MeasureTheory Measure NNReal Metric Complex Set\nopen scoped ENNReal\nopen Classical -- We use quite some `Finset.filter`\nnoncomputable section\n\nopen scoped ShortVariables\nvariable {X : Type*} {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102} {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X}\n  [MetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] [TileStructure Q D \u03ba S o]\n\nvariable {k n j l : \u2115} {p p' u u' : \ud835\udd13 X} {x : X}\n\n/-! ## Section 5.5 and Lemma 5.1.3 -/\n\n/-- The set \ud835\udd13_{G\\G'} in the blueprint -/\ndef \ud835\udd13pos : Set (\ud835\udd13 X) := { p : \ud835\udd13 X | 0 < volume (\ud835\udcd8 p \u2229 G \u2229 G'\u1d9c) }\n\nlemma exists_mem_aux\ud835\udcd2 {i : Grid X} (hi : 0 < volume (G \u2229 i)) : \u2203 k, i \u2208 aux\ud835\udcd2 (k + 1) := by\n  have vlt : volume (i : Set X) < \u22a4 := volume_coeGrid_lt_top\n  have one_le_quot : 1 \u2264 volume (i : Set X) / volume (G \u2229 i) := by\n    rw [ENNReal.le_div_iff_mul_le (Or.inl hi.ne') (Or.inr vlt.ne), one_mul]\n    exact measure_mono inter_subset_right\n  have quot_ne_top : volume (i : Set X) / volume (G \u2229 i) \u2260 \u22a4 := by\n    rw [Ne, ENNReal.div_eq_top, not_or, not_and_or, not_and_or]\n    exact \u27e8Or.inr hi.ne', Or.inl vlt.ne\u27e9\n  have ornz : 0 < (volume (i : Set X) / volume (G \u2229 i)).toReal :=\n    ENNReal.toReal_pos (zero_lt_one.trans_le one_le_quot).ne' quot_ne_top\n  let k : \u211d := Real.logb 2 (volume (i : Set X) / volume (G \u2229 i)).toReal\n  use \u230ak\u230b\u208a, i, le_rfl\n  nth_rw 1 [\u2190 ENNReal.mul_lt_mul_left (show 2 ^ (\u230ak\u230b\u208a + 1) \u2260 0 by simp) (by simp), \u2190 mul_assoc,\n    \u2190 ENNReal.rpow_natCast, \u2190 ENNReal.rpow_intCast, \u2190 ENNReal.rpow_add _ _ (by simp) (by simp)]\n  rw [Int.cast_neg, Int.cast_natCast, add_neg_cancel, ENNReal.rpow_zero, one_mul,\n    \u2190 ENNReal.div_lt_iff (Or.inl hi.ne') (Or.inr vlt.ne), \u2190 ENNReal.ofReal_toReal quot_ne_top,\n    \u2190 @ENNReal.ofReal_toReal (2 ^ (\u230ak\u230b\u208a + 1)) (by simp), ENNReal.ofReal_lt_ofReal_iff (by simp),\n    ENNReal.toReal_pow, ENNReal.toReal_ofNat, \u2190 Real.rpow_natCast,\n    \u2190 Real.logb_lt_iff_lt_rpow one_lt_two ornz]\n  exact Nat.lt_succ_floor k\n\nlemma exists_k_of_mem_\ud835\udd13pos (h : p \u2208 \ud835\udd13pos (X := X)) : \u2203 k, p \u2208 TilesAt k := by\n  let C : Set \u2115 := {k | \ud835\udcd8 p \u2208 aux\ud835\udcd2 k}\n  have Cn : C.Nonempty := by\n    rw [\ud835\udd13pos, mem_setOf] at h\n    have vpos : 0 < volume (G \u2229 \ud835\udcd8 p) := by\n      rw [inter_comm]; exact h.trans_le (measure_mono inter_subset_left)\n    obtain \u27e8k, hk\u27e9 := exists_mem_aux\ud835\udcd2 vpos; exact \u27e8_, hk\u27e9\n  let s : \u2115 := WellFounded.min wellFounded_lt _ Cn\n  have s_mem : s \u2208 C := WellFounded.min_mem ..\n  have s_min : \u2200 t \u2208 C, s \u2264 t := fun t mt \u21a6 WellFounded.min_le _ mt _\n  have s_pos : 0 < s := by\n    by_contra! h; rw [nonpos_iff_eq_zero] at h\n    simp_rw [h, C, aux\ud835\udcd2, mem_setOf] at s_mem; apply absurd s_mem; push_neg; intro _ _\n    rw [Int.neg_ofNat_zero, zpow_zero, one_mul]; exact measure_mono inter_subset_right\n  use s - 1; rw [TilesAt, mem_preimage, \ud835\udcd2, mem_diff, Nat.sub_add_cancel s_pos]\n  have : \u2200 t < s, t \u2209 C := fun t mt \u21a6 by contrapose! mt; exact s_min t mt\n  exact \u27e8s_mem, this (s - 1) (Nat.sub_one_lt_of_lt s_pos)\u27e9\n\nlemma dens'_le_of_mem_\ud835\udd13pos (h : p \u2208 \ud835\udd13pos (X := X)) : dens' k {p} \u2264 2 ^ (-k : \u2124) := by\n  simp_rw [dens', mem_singleton_iff, iSup_iSup_eq_left, iSup_le_iff]; intro l hl p' mp' sl\n  have vpos : 0 < volume (\ud835\udcd8 p' : Set X) := by\n    refine lt_of_lt_of_le ?_ (measure_mono sl.1.1)\n    rw [\ud835\udd13pos, mem_setOf, inter_assoc] at h; exact h.trans_le (measure_mono inter_subset_left)\n  rw [ENNReal.div_le_iff vpos.ne' volume_coeGrid_lt_top.ne]\n  calc\n    _ \u2264 volume (E\u2082 l p') := by\n      nth_rw 2 [\u2190 one_mul (volume _)]; apply mul_le_mul_right'\n      rw [show 1 = (l : \u211d\u22650\u221e) ^ (0 : \u2124) by simp]; apply ENNReal.zpow_le_of_le\n      \u00b7 rw [ENNReal.one_le_coe_iff]; exact one_le_two.trans hl\n      \u00b7 linarith [four_le_a X]\n    _ \u2264 _ := by\n      have E : E\u2082 l p' \u2286 \ud835\udcd8 p' \u2229 G := inter_subset_left\n      rw [TilesAt, mem_preimage, \ud835\udcd2, mem_diff] at mp'; replace mp' := mp'.2\n      rw [aux\ud835\udcd2, mem_setOf] at mp'; push_neg at mp'; specialize mp' (\ud835\udcd8 p') le_rfl\n      rw [inter_comm] at E; exact (measure_mono E).trans mp'\n\nlemma exists_E\u2082_volume_pos_of_mem_\ud835\udd13pos (h : p \u2208 \ud835\udd13pos (X := X)) : \u2203 r : \u2115, 0 < volume (E\u2082 r p) := by\n  apply exists_measure_pos_of_not_measure_iUnion_null\n  change volume (\u22c3 n : \u2115, \ud835\udcd8 p \u2229 G \u2229 Q \u207b\u00b9' ball_(p) (\ud835\udcac p) n) \u2260 0\n  rw [\u2190 inter_iUnion]\n  suffices \u22c3 i : \u2115, Q \u207b\u00b9' ball_(p) (\ud835\udcac p) i = univ by\n    rw [this, inter_univ, \u2190 pos_iff_ne_zero]\n    rw [\ud835\udd13pos, mem_setOf] at h; exact h.trans_le (measure_mono inter_subset_left)\n  simp_rw [iUnion_eq_univ_iff, mem_preimage, mem_ball]\n  exact fun x \u21a6 exists_nat_gt (dist_(p) (Q x) (\ud835\udcac p))\n\nlemma dens'_pos_of_mem_\ud835\udd13pos (h : p \u2208 \ud835\udd13pos (X := X)) (hp : p \u2208 TilesAt k) : 0 < dens' k {p} := by\n  simp_rw [dens', mem_singleton_iff, iSup_iSup_eq_left, lt_iSup_iff]\n  obtain \u27e8l, hl\u27e9 := exists_E\u2082_volume_pos_of_mem_\ud835\udd13pos h\n  use max 2 l, le_max_left .., p, hp, le_rfl\n  simp_rw [ENNReal.div_pos_iff, ne_eq, mul_eq_zero, not_or, \u2190 ne_eq, \u2190 pos_iff_ne_zero]\n  refine \u27e8\u27e8ENNReal.zpow_pos (by simp) (by simp) _, ?_\u27e9, volume_coeGrid_lt_top.ne\u27e9\n  refine hl.trans_le <| measure_mono <| inter_subset_inter_right _ <| preimage_mono ?_\n  change ball_(p) (\ud835\udcac p) _ \u2286 ball_(p) (\ud835\udcac p) _\n  exact ball_subset_ball (by simp)\n\nlemma exists_k_n_of_mem_\ud835\udd13pos (h : p \u2208 \ud835\udd13pos (X := X)) : \u2203 k n, p \u2208 \u212d k n \u2227 k \u2264 n := by\n  obtain \u27e8k, mp\u27e9 := exists_k_of_mem_\ud835\udd13pos h; use k\n  have dens'_pos : 0 < dens' k {p} := dens'_pos_of_mem_\ud835\udd13pos h mp\n  have dens'_le : dens' k {p} \u2264 2 ^ (-k : \u2124) := dens'_le_of_mem_\ud835\udd13pos h\n  have dens'_lt_top : dens' k {p} < \u22a4 :=\n    dens'_le.trans_lt (ENNReal.zpow_lt_top (by simp) (by simp) _)\n  have dens'_toReal_pos : 0 < (dens' k {p}).toReal :=\n    ENNReal.toReal_pos dens'_pos.ne' dens'_lt_top.ne\n  -- 2 ^ (4 * a - n) < dens' k {p} \u2264 2 ^ (4 * a - n + 1)\n  -- 4 * a - n < log_2 dens' k {p} \u2264 4 * a - n + 1\n  -- -n < log_2 dens' k {p} - 4 * a \u2264 -n + 1\n  -- n - 1 \u2264 4 * a - log_2 dens' k {p} < n\n  -- n \u2264 4 * a - log_2 dens' k {p} + 1 < n + 1\n  -- n = 4 * a + \u230a-log_2 dens' k {p}\u230b + 1\n  let v : \u211d := -Real.logb 2 (dens' k {p}).toReal\n  have klv : k \u2264 v := by\n    rw [le_neg, Real.logb_le_iff_le_rpow one_lt_two dens'_toReal_pos,\n      show (2 : \u211d) = (2 : \u211d\u22650\u221e).toReal by rfl, ENNReal.toReal_rpow,\n      ENNReal.toReal_le_toReal dens'_lt_top.ne (by simp)]\n    exact_mod_cast dens'_le\n  have klq : k \u2264 \u230av\u230b\u208a := Nat.le_floor klv\n  let n : \u2115 := 4 * a + \u230av\u230b\u208a + 1; use n; refine \u27e8\u27e8mp, ?_\u27e9, by omega\u27e9\n  rw [show 4 * (a : \u2124) - (4 * a + \u230av\u230b\u208a + 1 : \u2115) = (-\u230av\u230b\u208a - 1 : \u2124) by omega, sub_add_cancel, mem_Ioc,\n    \u2190 ENNReal.ofReal_toReal dens'_lt_top.ne, \u2190 ENNReal.rpow_intCast, \u2190 ENNReal.rpow_intCast,\n    show (2 : \u211d\u22650\u221e) = ENNReal.ofReal (2 : \u211d) by norm_cast,\n    ENNReal.ofReal_rpow_of_pos zero_lt_two, ENNReal.ofReal_rpow_of_pos zero_lt_two,\n    ENNReal.ofReal_lt_ofReal_iff dens'_toReal_pos, ENNReal.ofReal_le_ofReal_iff (by positivity),\n    \u2190 Real.logb_le_iff_le_rpow one_lt_two dens'_toReal_pos,\n    \u2190 Real.lt_logb_iff_rpow_lt one_lt_two dens'_toReal_pos,\n    Int.cast_sub, Int.cast_neg, Int.cast_natCast, Int.cast_one, neg_sub_left, neg_lt, le_neg]\n  constructor\n  \u00b7 rw [add_comm]; exact_mod_cast Nat.lt_succ_floor _\n  \u00b7 exact Nat.floor_le ((Nat.cast_nonneg' k).trans klv)\n\nprivate lemma two_mul_n_add_six_lt : 2 * n + 6 < 2 ^ (n + 3) := by\n  induction n with\n  | zero => norm_num\n  | succ n ih =>\n    calc\n      _ = 2 * n + 6 + 2 := by ring\n      _ < 2 ^ (n + 3) + 2 := by gcongr\n      _ < 2 ^ (n + 3) + 2 ^ (n + 3) := by omega\n      _ = _ := by ring\n\nlemma exists_j_of_mem_\ud835\udd13pos_\u212d (h : p \u2208 \ud835\udd13pos (X := X)) (mp : p \u2208 \u212d k n) (hkn : k \u2264 n) :\n    p \u2208 \ud835\udd0f\u2080 k n \u2228 \u2203 j \u2264 2 * n + 3, p \u2208 \u212d\u2081 k n j := by\n  rw [\ud835\udd13pos, mem_setOf, inter_comm _ G'\u1d9c, \u2190 inter_assoc] at h\n  replace h : 0 < volume (G'\u1d9c \u2229 (\ud835\udcd8 p : Set X)) := h.trans_le (measure_mono inter_subset_left)\n  rw [inter_comm, G', compl_union, compl_union, inter_comm G\u2081\u1d9c, \u2190 inter_assoc, \u2190 inter_assoc] at h\n  replace h : 0 < volume ((\ud835\udcd8 p : Set X) \u2229 G\u2082\u1d9c) :=\n    h.trans_le (measure_mono (inter_subset_left.trans inter_subset_left))\n  obtain \u27e8x, mx, nx\u27e9 := nonempty_of_measure_ne_zero h.ne'\n  simp_rw [G\u2082, mem_compl_iff, mem_iUnion] at nx; push_neg at nx; specialize nx n k hkn\n  let B : \u2115 := Finset.card { q | q \u2208 \ud835\udd05 k n p }\n  have Blt : B < 2 ^ (2 * n + 4) := by\n    calc\n      _ \u2264 Finset.card { m | m \u2208 \ud835\udd10 k n \u2227 x \u2208 \ud835\udcd8 m } :=\n        Finset.card_le_card (Finset.monotone_filter_right _ (Pi.le_def.mpr fun m \u27e8m\u2081, m\u2082\u27e9 \u21a6\n          \u27e8m\u2081, m\u2082.1.1 mx\u27e9))\n      _ = stackSize (\ud835\udd10 k n) x := by\n        simp_rw [stackSize, indicator_apply, Pi.one_apply, Finset.sum_boole, Nat.cast_id,\n          Finset.filter_filter]; rfl\n      _ \u2264 (2 * n + 6) * 2 ^ (n + 1) := by rwa [setA, mem_setOf, not_lt] at nx\n      _ < _ := by\n        rw [show 2 * n + 4 = (n + 3) + (n + 1) by omega, pow_add _ (n + 3)]\n        exact mul_lt_mul_of_pos_right two_mul_n_add_six_lt (by positivity)\n  rcases B.eq_zero_or_pos with Bz | Bpos\n  \u00b7 simp_rw [B, filter_mem_univ_eq_toFinset, Finset.card_eq_zero, toFinset_eq_empty] at Bz\n    exact Or.inl \u27e8mp, Bz\u27e9\n  \u00b7 right; use Nat.log 2 B; rw [Nat.lt_pow_iff_log_lt one_lt_two Bpos.ne'] at Blt\n    refine \u27e8by omega, (?_ : _ \u2227 _ \u2264 B), (?_ : \u00ac(_ \u2227 _ \u2264 B))\u27e9\n    \u00b7 exact \u27e8mp, Nat.pow_log_le_self 2 Bpos.ne'\u27e9\n    \u00b7 rw [not_and, not_le]; exact fun _ \u21a6 Nat.lt_pow_succ_log_self one_lt_two _\n\nlemma exists_k_n_j_of_mem_\ud835\udd13pos (h : p \u2208 \ud835\udd13pos (X := X)) :\n    \u2203 k n, k \u2264 n \u2227 (p \u2208 \ud835\udd0f\u2080 k n \u2228 \u2203 j \u2264 2 * n + 3, p \u2208 \u212d\u2081 k n j) := by\n  obtain \u27e8k, n, mp, hkn\u27e9 := exists_k_n_of_mem_\ud835\udd13pos h\n  exact \u27e8k, n, hkn, exists_j_of_mem_\ud835\udd13pos_\u212d h mp hkn\u27e9\n\n/-- The union occurring in the statement of Lemma 5.5.1 containing \ud835\udd0f\u2080 -/\ndef \u211c\u2080 : Set (\ud835\udd13 X) := \ud835\udd13pos \u2229 \u22c3 (n : \u2115) (k \u2264 n), \ud835\udd0f\u2080 k n\n\n/-- The union occurring in the statement of Lemma 5.5.1 containing \ud835\udd0f\u2081 -/\ndef \u211c\u2081 : Set (\ud835\udd13 X) := \ud835\udd13pos \u2229 \u22c3 (n : \u2115) (k \u2264 n) (j \u2264 2 * n + 3) (l \u2264 Z * (n + 1)), \ud835\udd0f\u2081 k n j l\n\n/-- The union occurring in the statement of Lemma 5.5.1 containing \ud835\udd0f\u2082 -/\ndef \u211c\u2082 : Set (\ud835\udd13 X) := \ud835\udd13pos \u2229 \u22c3 (n : \u2115) (k \u2264 n) (j \u2264 2 * n + 3), \ud835\udd0f\u2082 k n j\n\n/-- The union occurring in the statement of Lemma 5.5.1 containing \ud835\udd0f\u2083 -/\ndef \u211c\u2083 : Set (\ud835\udd13 X) := \ud835\udd13pos \u2229 \u22c3 (n : \u2115) (k \u2264 n) (j \u2264 2 * n + 3) (l \u2264 Z * (n + 1)), \ud835\udd0f\u2083 k n j l\n\n/-- Lemma allowing to peel `\u22c3 (n : \u2115) (k \u2264 n)` from unions in the proof of Lemma 5.5.1. -/\nlemma mem_iUnion_iff_mem_of_mem_\u212d {f : \u2115 \u2192 \u2115 \u2192 Set (\ud835\udd13 X)} (hp : p \u2208 \u212d k n \u2227 k \u2264 n)\n    (hf : \u2200 k n, f k n \u2286 \u212d k n) : p \u2208 \u22c3 (n : \u2115) (k \u2264 n), f k n \u2194 p \u2208 f k n := by\n  simp_rw [mem_iUnion]; constructor <;> intro h\n  \u00b7 obtain \u27e8n', k', _, mp\u27e9 := h\n    have e := pairwiseDisjoint_\u212d (X := X).elim (mem_univ (k, n)) (mem_univ (k', n'))\n      (not_disjoint_iff.mpr \u27e8p, hp.1, hf k' n' mp\u27e9)\n    rw [Prod.mk.inj_iff] at e\n    exact e.1 \u25b8 e.2 \u25b8 mp\n  \u00b7 use n, k, hp.2\n\n/-- Lemma allowing to peel `\u22c3 (j \u2264 2 * n + 3)` from unions in the proof of Lemma 5.5.1. -/\nlemma mem_iUnion_iff_mem_of_mem_\u212d\u2081 {f : \u2115 \u2192 Set (\ud835\udd13 X)} (hp : p \u2208 \u212d\u2081 k n j \u2227 j \u2264 2 * n + 3)\n    (hf : \u2200 j, f j \u2286 \u212d\u2081 k n j) : p \u2208 \u22c3 (j \u2264 2 * n + 3), f j \u2194 p \u2208 f j := by\n  simp_rw [mem_iUnion]; constructor <;> intro h\n  \u00b7 obtain \u27e8j', _, mp\u27e9 := h\n    have e := pairwiseDisjoint_\u212d\u2081 (X := X).elim (mem_univ j) (mem_univ j')\n      (not_disjoint_iff.mpr \u27e8p, hp.1, hf j' mp\u27e9)\n    exact e \u25b8 mp\n  \u00b7 use j, hp.2\n\nlemma nmem_\u212d\u2085_iff_mem_\ud835\udd0f\u2083 (hkn : k \u2264 n) (hj : j \u2264 2 * n + 3)\n    (h : p \u2208 \ud835\udd13pos) (mc2 : p \u2208 \u212d\u2082 k n j) (ml2 : p \u2209 \ud835\udd0f\u2082 k n j) :\n    p \u2209 \u212d\u2085 k n j \u2194 p \u2208 \u22c3 l, \u22c3 (_ : l \u2264 Z * (n + 1)), \ud835\udd0f\u2083 k n j l := by\n  have mc3 : p \u2208 \u212d\u2083 k n j := \u27e8mc2, ml2\u27e9\n  by_cases mc4 : p \u2209 \u212d\u2084 k n j\n  all_goals\n    have mc4' := mc4\n    simp_rw [\u212d\u2084, layersBelow, mem_diff, not_and, mc3, true_implies, not_not_mem] at mc4'\n  \u00b7 change p \u2208 \u22c3 (l \u2264 Z * (n + 1)), \ud835\udd0f\u2083 k n j l at mc4'\n    simp_rw [mc4', iff_true]; contrapose! mc4\n    exact \u212d\u2085_subset_\u212d\u2084 mc4\n  change p \u2209 \u22c3 (l \u2264 Z * (n + 1)), \ud835\udd0f\u2083 k n j l at mc4'\n  simp_rw [mc4', iff_false, \u212d\u2085]; rw [not_not_mem] at mc4 \u22a2; simp_rw [mem_diff, mc4, true_and]\n  have nG\u2083 : \u00ac(\ud835\udcd8 p : Set X) \u2286 G\u2083 := by\n    suffices \u00ac(\ud835\udcd8 p : Set X) \u2286 G' by contrapose! this; exact subset_union_of_subset_right this _\n    by_contra hv\n    rw [\ud835\udd13pos, mem_setOf, inter_comm _ G'\u1d9c, \u2190 inter_assoc, \u2190 diff_eq_compl_inter,\n      diff_eq_empty.mpr hv] at h\n    simp at h\n  contrapose! nG\u2083\n  exact le_iSup\u2082_of_le n k <| le_iSup\u2082_of_le hkn j <|\n    le_iSup\u2082_of_le hj p <| le_iSup_of_le nG\u2083 Subset.rfl\n\n\n/-- Lemma 5.5.1.\n\nWe will not use the lemma in this form, as to decompose the Carleson sum it is also crucial that\nthe union is disjoint. This is easier to formalize by decomposing into successive terms, taking\nadvantage of disjointess at each step, instead of doing everything in one go. Still, we keep this\nlemma as it corresponds to the blueprint, and the key steps of its proof will also be the key steps\nwhen doing the successive decompositions.\n -/\nlemma antichain_decomposition : \ud835\udd13pos (X := X) \u2229 \ud835\udd13\u2081\u1d9c = \u211c\u2080 \u222a \u211c\u2081 \u222a \u211c\u2082 \u222a \u211c\u2083 := by\n  unfold \u211c\u2080 \u211c\u2081 \u211c\u2082 \u211c\u2083 \ud835\udd13\u2081; simp_rw [\u2190 inter_union_distrib_left]; ext p\n  simp_rw [mem_inter_iff, and_congr_right_iff, mem_compl_iff, mem_union]; intro h\n  obtain \u27e8k, n, hkn, split\u27e9 := exists_k_n_j_of_mem_\ud835\udd13pos h\n  have pc : p \u2208 \u212d k n := by\n    rcases split with ml0 | \u27e8_, _, mc1\u27e9\n    \u00b7 exact \ud835\udd0f\u2080_subset_\u212d ml0\n    \u00b7 exact \u212d\u2081_subset_\u212d mc1\n  iterate 5 rw [mem_iUnion_iff_mem_of_mem_\u212d \u27e8pc, hkn\u27e9]\n  pick_goal 5; \u00b7 exact fun _ _ \u21a6 \ud835\udd0f\u2080_subset_\u212d\n  pick_goal 4; \u00b7 exact fun _ _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 \ud835\udd0f\u2081_subset_\u212d\n  pick_goal 3; \u00b7 exact fun _ _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 \ud835\udd0f\u2082_subset_\u212d\n  pick_goal 2; \u00b7 exact fun _ _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 \ud835\udd0f\u2083_subset_\u212d\n  pick_goal -1; \u00b7 exact fun _ _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 \u212d\u2085_subset_\u212d\n  by_cases ml0 : p \u2208 \ud835\udd0f\u2080 k n\n  \u00b7 simp_rw [ml0, true_or, iff_true, mem_iUnion\u2082]; push_neg; intros\n    exact fun a \u21a6 disjoint_left.mp \ud835\udd0f\u2080_disjoint_\u212d\u2081 ml0 (\u212d\u2085_subset_\u212d\u2081 a)\n  simp_rw [ml0, false_or] at split \u22a2\n  obtain \u27e8j, hj, mc1\u27e9 := split\n  iterate 4 rw [mem_iUnion_iff_mem_of_mem_\u212d\u2081 \u27e8mc1, hj\u27e9]\n  pick_goal 4; \u00b7 exact fun _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 \ud835\udd0f\u2081_subset_\u212d\u2081\n  pick_goal 3; \u00b7 exact fun _ \u21a6 \ud835\udd0f\u2082_subset_\u212d\u2081\n  pick_goal 2; \u00b7 exact fun _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 \ud835\udd0f\u2083_subset_\u212d\u2081\n  pick_goal -1; \u00b7 exact fun _ \u21a6 \u212d\u2085_subset_\u212d\u2081\n  by_cases mc2 : p \u2209 \u212d\u2082 k n j\n  all_goals\n    have mc2' := mc2\n    simp_rw [\u212d\u2082, layersAbove, mem_diff, not_and, mc1, true_implies, not_not_mem] at mc2'\n  \u00b7 change p \u2208 \u22c3 (l \u2264 Z * (n + 1)), \ud835\udd0f\u2081 k n j l at mc2'\n    simp_rw [mc2', true_or, iff_true]; contrapose! mc2\n    exact \u212d\u2085_subset_\u212d\u2084.trans \u212d\u2084_subset_\u212d\u2083 |>.trans \u212d\u2083_subset_\u212d\u2082 mc2\n  change p \u2209 \u22c3 (l \u2264 Z * (n + 1)), \ud835\udd0f\u2081 k n j l at mc2'; simp_rw [mc2', false_or]\n  rw [not_not_mem] at mc2; by_cases ml2 : p \u2208 \ud835\udd0f\u2082 k n j\n  \u00b7 simp_rw [ml2, true_or, iff_true]\n    exact fun a \u21a6 disjoint_left.mp \ud835\udd0f\u2082_disjoint_\u212d\u2083 ml2 (\u212d\u2085_subset_\u212d\u2084.trans \u212d\u2084_subset_\u212d\u2083 a)\n  simp_rw [ml2, false_or]\n  exact nmem_\u212d\u2085_iff_mem_\ud835\udd0f\u2083 hkn hj h mc2 ml2\n\n/-- The subset `\ud835\udd0f\u2080(k, n, l)` of `\ud835\udd0f\u2080(k, n)`, given in Lemma 5.5.3.\n  We use the name `\ud835\udd0f\u2080'` in Lean. -/\ndef \ud835\udd0f\u2080' (k n l : \u2115) : Set (\ud835\udd13 X) := (\ud835\udd0f\u2080 k n).minLayer l\n\n/-- Logarithmic inequality used in the proof of Lemma 5.5.2. -/\nlemma ceil_log2_le_floor_four_add_log2 {l : \u211d} (hl : 2 \u2264 l) :\n    \u2308Real.logb 2 ((l + 6 / 5) / 5\u207b\u00b9)\u2309\u208a \u2264 \u230a4 + Real.logb 2 l\u230b\u208a := by\n  have : 2 \u2264 Real.logb 2 (l + 6 / 5) + Real.logb 2 5 :=\n    calc\n      _ \u2265 Real.logb 2 (2 ^ (0 : \u211d)) + Real.logb 2 (2 ^ (2 : \u211d)) :=\n        add_le_add\n          (Real.logb_le_logb_of_le one_lt_two (by positivity) (by linarith))\n          (Real.logb_le_logb_of_le one_lt_two (by positivity) (by norm_num))\n      _ \u2265 _ := by simp_rw [Real.logb_rpow zero_lt_two one_lt_two.ne']; norm_num\n  rw [div_inv_eq_mul, Real.logb_mul (by positivity) (by positivity), Nat.le_floor_iff']\n  \u00b7 calc\n      _ \u2264 1 + Real.logb 2 (l + 6 / 5) + Real.logb 2 5 := by\n        rw [add_rotate]; exact (Nat.ceil_lt_add_one (zero_le_two.trans this)).le\n      _ \u2264 1 + Real.logb 2 (8 / 5 * l) + Real.logb 2 5 := by\n        gcongr\n        \u00b7 exact one_lt_two\n        \u00b7 linarith\n      _ = _ := by\n        rw [add_assoc, \u2190 Real.logb_mul (by positivity) (by positivity), \u2190 mul_rotate,\n          show (5 : \u211d) * (8 / 5) = 2 ^ 3 by norm_num,\n          Real.logb_mul (by positivity) (by positivity), \u2190 Real.rpow_natCast,\n          Real.logb_rpow zero_lt_two one_lt_two.ne', \u2190 add_assoc]\n        norm_num\n  \u00b7 exact (zero_lt_one.trans_le (Nat.one_le_ceil_iff.mpr (zero_lt_two.trans_le this))).ne'\n\n/-- The set `\ud835\udd12` in the proof of Lemma 5.5.2. -/\ndef \ud835\udd12 (p' : \ud835\udd13 X) (l : \u211d\u22650) : Finset (\ud835\udd13 X) :=\n  {p'' | \ud835\udcd8 p'' = \ud835\udcd8 p' \u2227 \u00acDisjoint (ball_(p') (\ud835\udcac p') l) (\u03a9 p'')}\n\nlemma card_\ud835\udd12 (p' : \ud835\udd13 X) {l : \u211d\u22650} (hl : 2 \u2264 l) : (\ud835\udd12 p' l).card \u2264 \u230a2 ^ (4 * a) * l ^ a\u230b\u208a := by\n  have djO : (\ud835\udd12 p' l).toSet.PairwiseDisjoint fun p'' \u21a6 ball_(p') (\ud835\udcac p'') 5\u207b\u00b9 :=\n    fun p\u2081 mp\u2081 p\u2082 mp\u2082 hn \u21a6 by\n      simp_rw [\ud835\udd12, Finset.coe_filter, mem_setOf, Finset.mem_univ, true_and] at mp\u2081 mp\u2082\n      change Disjoint (ball_{\ud835\udcd8 p'} (\ud835\udcac p\u2081) 5\u207b\u00b9) (ball_{\ud835\udcd8 p'} (\ud835\udcac p\u2082) 5\u207b\u00b9)\n      conv => enter [1]; rw [\u2190 mp\u2081.1]\n      conv => enter [2]; rw [\u2190 mp\u2082.1]\n      exact cball_disjoint hn (mp\u2081.1.trans mp\u2082.1.symm)\n  have tO : \u2200 p'' \u2208 \ud835\udd12 p' l,\n      ball_(p') (\ud835\udcac p'') 5\u207b\u00b9 \u2286 ball_(p') (\ud835\udcac p') (l + 6 / 5) := fun p'' mp'' \u21a6 by\n    apply ball_subset_ball'\n    simp_rw [\ud835\udd12, Finset.mem_filter, Finset.mem_univ, true_and] at mp''\n    obtain \u27e8x, mx\u2081, mx\u2082\u27e9 := not_disjoint_iff.mp mp''.2\n    replace mx\u2082 := _root_.subset_cball mx\u2082\n    rw [@mem_ball] at mx\u2081 mx\u2082\n    calc\n      _ \u2264 5\u207b\u00b9 + (dist_{\ud835\udcd8 p'} x (\ud835\udcac p'') + dist_{\ud835\udcd8 p'} x (\ud835\udcac p')) :=\n        add_le_add_left (dist_triangle_left ..) _\n      _ \u2264 5\u207b\u00b9 + (1 + l) := by gcongr; rw [\u2190 mp''.1]; exact mx\u2082.le\n      _ = _ := by rw [inv_eq_one_div, \u2190 add_assoc, add_comm _ l.toReal]; norm_num\n  have vO : CoveredByBalls (ball_(p') (\ud835\udcac p') (l + 6 / 5)) \u230a2 ^ (4 * a) * l ^ a\u230b\u208a 5\u207b\u00b9 := by\n    apply (ballsCoverBalls_iterate (show 0 < l.toReal + 6 / 5 by positivity)\n      (show 0 < 5\u207b\u00b9 by positivity) (\ud835\udcac p')).mono_nat\n    calc\n      _ \u2264 (defaultA a) ^ \u230a4 + Real.logb 2 l\u230b\u208a :=\n        pow_le_pow_right\u2080 Nat.one_le_two_pow (ceil_log2_le_floor_four_add_log2 hl)\n      _ \u2264 \u230a(defaultA a : \u211d) ^ (4 + Real.logb 2 l)\u230b\u208a := by\n        apply Nat.le_floor; rw [Nat.cast_npow, \u2190 Real.rpow_natCast]\n        refine Real.rpow_le_rpow_of_exponent_le (by exact_mod_cast Nat.one_le_two_pow)\n          (Nat.floor_le ?_)\n        calc\n          _ \u2265 4 + Real.logb 2 2 :=\n            add_le_add_left (Real.logb_le_logb_of_le one_lt_two zero_lt_two hl) _\n          _ \u2265 _ := by rw [Real.logb_self_eq_one one_lt_two]; norm_num\n      _ = _ := by\n        rw [Nat.cast_pow, Nat.cast_ofNat, \u2190 Real.rpow_natCast, \u2190 Real.rpow_mul zero_le_two,\n          mul_comm, add_mul, Real.rpow_add zero_lt_two, show (4 : \u211d) * a = (4 * a : \u2115) by simp,\n          Real.rpow_natCast, Real.rpow_mul zero_le_two, Real.rpow_natCast,\n          Real.rpow_logb zero_lt_two one_lt_two.ne']\n        congr 1; exact zero_lt_two.trans_le hl\n  obtain \u27e8(T : Finset (\u0398 X)), cT, uT\u27e9 := vO\n  refine (Finset.card_le_card_of_forall_subsingleton (fun p'' t \u21a6 \ud835\udcac p'' \u2208 ball_(p') t 5\u207b\u00b9)\n      (fun p'' mp'' \u21a6 ?_) (fun t _ o\u2081 mo\u2081 o\u2082 mo\u2082 \u21a6 ?_)).trans cT\n  \u00b7 have := (tO _ mp'').trans uT (mem_ball_self (by positivity))\n    rwa [mem_iUnion\u2082, bex_def] at this\n  \u00b7 simp_rw [mem_setOf_eq] at mo\u2081 mo\u2082; rw [@mem_ball_comm] at mo\u2081 mo\u2082\n    exact djO.elim mo\u2081.1 mo\u2082.1 (not_disjoint_iff.mpr \u27e8t, mo\u2081.2, mo\u2082.2\u27e9)\n\nsection\n\nvariable {p' : \ud835\udd13 X} {l : \u211d\u22650} (hl : 2 \u2264 l)\n  (qp' : 2 ^ (4 * a - n : \u2124) < l ^ (-a : \u2124) * volume (E\u2082 l p') / volume (\ud835\udcd8 p' : Set X))\ninclude hl qp'\n\nlemma lt_quotient_rearrange :\n    (2 ^ (4 * a) * l ^ a : \u211d\u22650) * 2 ^ (-n : \u2124) < volume (E\u2082 l p') / volume (\ud835\udcd8 p' : Set X) := by\n  rw [mul_div_assoc] at qp'; convert ENNReal.div_lt_of_lt_mul' qp' using 1\n  rw [ENNReal.div_eq_inv_mul,\n    \u2190 ENNReal.zpow_neg (by exact_mod_cast (zero_lt_two.trans_le hl).ne') ENNReal.coe_ne_top,\n    neg_neg, ENNReal.coe_mul, mul_rotate, mul_assoc, ENNReal.coe_pow, zpow_natCast]\n  congr 1\n  rw [ENNReal.coe_pow, ENNReal.coe_ofNat, \u2190 zpow_natCast,\n    \u2190 ENNReal.zpow_add two_ne_zero ENNReal.ofNat_ne_top]\n  congr 1; omega\n\nlemma l_upper_bound : l < 2 ^ n := by\n  have ql1 : volume (E\u2082 l p') / volume (\ud835\udcd8 p' : Set X) \u2264 1 := by\n    apply ENNReal.div_le_of_le_mul; rw [one_mul]; exact measure_mono (E\u2082_subset ..)\n  replace qp' := (lt_quotient_rearrange hl qp').trans_le ql1\n  rw [\u2190 ENNReal.mul_lt_mul_right (c := 2 ^ (n : \u2124)) (by simp) (by simp), one_mul, mul_assoc,\n    \u2190 ENNReal.zpow_add two_ne_zero ENNReal.ofNat_ne_top, neg_add_cancel, zpow_zero, mul_one,\n    show (2 ^ (n : \u2124) : \u211d\u22650\u221e) = (2 ^ (n : \u2124) : \u211d\u22650) by simp, ENNReal.coe_lt_coe,\n    zpow_natCast] at qp'\n  calc\n    _ \u2264 l ^ a := le_self_pow\u2080 (one_le_two.trans hl) (by linarith [four_le_a X])\n    _ \u2264 2 ^ (4 * a) * l ^ a := by\n      nth_rw 1 [\u2190 one_mul (l ^ a)]; gcongr; exact_mod_cast Nat.one_le_two_pow\n    _ < _ := qp'\n\nlemma exists_\ud835\udd12_with_le_quotient :\n    \u2203 b \u2208 \ud835\udd12 p' l, 2 ^ (-n : \u2124) < volume (E\u2081 b) / volume (\ud835\udcd8 b : Set X) := by\n  have cO : (\ud835\udd12 p' l).card \u2264 \u230a2 ^ (4 * a) * l ^ a\u230b\u208a := card_\ud835\udd12 _ hl\n  have ltq : (2 ^ (4 * a) * l ^ a : \u211d\u22650) * 2 ^ (-n : \u2124) <\n      \u2211 p'' \u2208 \ud835\udd12 p' l, volume (E\u2081 p'') / volume (\ud835\udcd8 p'' : Set X) :=\n    calc\n      _ < volume (E\u2082 l p') / volume (\ud835\udcd8 p' : Set X) := lt_quotient_rearrange hl qp'\n      _ \u2264 volume (\u22c3 p'' \u2208 \ud835\udd12 p' l, E\u2081 p'') / volume (\ud835\udcd8 p' : Set X) := by\n        gcongr; simp_rw [E\u2081, E\u2082, smul, toTileLike, TileLike.toSet]; intro x mx\n        have rsub := biUnion_\u03a9 (i := \ud835\udcd8 p'); rw [range_subset_iff] at rsub; specialize rsub x\n        simp_rw [mem_iUnion\u2082, mem_preimage, mem_singleton_iff, exists_prop] at rsub\n        obtain \u27e8(ps : \ud835\udd13 X), (ips : \ud835\udcd8 ps = \ud835\udcd8 p'), mps\u27e9 := rsub; rw [\u2190 mem_preimage] at mps\n        rw [mem_iUnion\u2082]; refine \u27e8ps, ?_, ?_\u27e9\n        \u00b7 simp_rw [\ud835\udd12, Finset.mem_filter, Finset.mem_univ, ips, true_and, not_disjoint_iff]\n          use Q x, mem_preimage.mp mx.2, mem_preimage.mp mps\n        \u00b7 exact \u27e8\u27e8ips.symm \u25b8 mx.1.1, mx.1.2\u27e9, mps\u27e9\n      _ \u2264 (\u2211 p'' \u2208 \ud835\udd12 p' l, volume (E\u2081 p'')) / volume (\ud835\udcd8 p' : Set X) :=\n        ENNReal.div_le_div_right (measure_biUnion_finset_le _ _) _\n      _ = \u2211 p'' \u2208 \ud835\udd12 p' l, volume (E\u2081 p'') / volume (\ud835\udcd8 p' : Set X) := by\n        simp_rw [ENNReal.div_eq_inv_mul, Finset.mul_sum]\n      _ = _ := by\n        refine Finset.sum_congr rfl fun p'' mp'' \u21a6 ?_\n        rw [\ud835\udd12, Finset.mem_filter] at mp''; rw [mp''.2.1]\n  by_contra! h\n  have : \u2211 p'' \u2208 \ud835\udd12 p' l, volume (E\u2081 p'') / volume (\ud835\udcd8 p'' : Set X) \u2264\n      (2 ^ (4 * a) * l ^ a : \u211d\u22650) * 2 ^ (-n : \u2124) :=\n    calc\n      _ \u2264 \u2211 _ \u2208 \ud835\udd12 p' l, (2 : \u211d\u22650\u221e) ^ (-n : \u2124) := by\n        refine Finset.sum_le_sum h\n      _ = (\ud835\udd12 p' l).card * (2 : \u211d\u22650\u221e) ^ (-n : \u2124) := by rw [Finset.sum_const, nsmul_eq_mul]\n      _ \u2264 _ := by\n        refine mul_le_mul_right' ?_ _\n        rw [show ((\ud835\udd12 p' l).card : \u211d\u22650\u221e) = ((\ud835\udd12 p' l).card : \u211d\u22650) by simp, ENNReal.coe_le_coe]\n        rw [\u2190 Nat.cast_le (\u03b1 := \u211d\u22650)] at cO\n        exact cO.trans (Nat.floor_le (by positivity))\n  exact (ltq.trans_le this).false\n\nend\n\n/-- Main part of Lemma 5.5.2. -/\nlemma iUnion_L0' : \u22c3 (l < n), \ud835\udd0f\u2080' (X := X) k n l = \ud835\udd0f\u2080 k n := by\n  refine iUnion_lt_minLayer_iff_bounded_series.mpr fun p \u21a6 ?_\n  suffices \u00ac\u2203 s : LTSeries (\ud835\udd0f\u2080 (X := X) k n), s.length = n by\n    rcases lt_or_le p.length n with c | c\n    \u00b7 exact c\n    \u00b7 exact absurd \u27e8p.take \u27e8n, by omega\u27e9, by rw [RelSeries.take_length]\u27e9 this\n  by_contra h; obtain \u27e8s, hs\u27e9 := h; let sl := s.last; have dsl := sl.2.1.2.1\n  simp_rw [dens', lt_iSup_iff, mem_singleton_iff, exists_prop, exists_eq_left] at dsl\n  obtain \u27e8l, hl, p', mp', sp', qp'\u27e9 := dsl\n  obtain \u27e8b, mb, qb\u27e9 := exists_\ud835\udd12_with_le_quotient hl qp'\n  have \ud835\udcd8p'b : \ud835\udcd8 p' = \ud835\udcd8 b := by rw [\ud835\udd12, Finset.mem_filter] at mb; exact mb.2.1.symm\n  replace qb := ENNReal.mul_lt_of_lt_div qb\n  have mba : b \u2208 (aux\ud835\udd10 k n).toFinset := by\n    simp_rw [mem_toFinset, aux\ud835\udd10, mem_setOf, qb, and_true]; rw [TilesAt, mem_preimage] at mp' \u22a2\n    exact \ud835\udcd8p'b \u25b8 mp'\n  obtain \u27e8m, lm, maxm\u27e9 := (aux\ud835\udd10 k n).toFinset.exists_le_maximal mba\n  replace maxm : m \u2208 \ud835\udd10 k n := by simpa only [mem_toFinset] using maxm\n  -- We will now show a contradiction. As a member of `\ud835\udd0f\u2080 k n` the _first_ element `s\u2080` of the\n  -- `LTSeries s` satisfies `\ud835\udd05 k n s\u2080 = \u2205`. But we will show that `m \u2208 \ud835\udd05 k n s\u2080`,\n  -- i.e. `smul 100 s\u2080 \u2264 smul 1 m`.\n  let s\u2080 := s.head; apply absurd s\u2080.2.2; rw [\u2190 ne_eq, \u2190 nonempty_iff_ne_empty]; use m, maxm\n  constructor\n  \u00b7 have l1 : \ud835\udcd8 s\u2080.1 \u2264 \ud835\udcd8 sl.1 := s.head_le_last.1\n    have l2 : \ud835\udcd8 sl.1 \u2264 \ud835\udcd8 b := \ud835\udcd8p'b \u25b8 sp'.1\n    have l3 : \ud835\udcd8 b \u2264 \ud835\udcd8 m := lm.1\n    exact (l1.trans l2).trans l3\n  change ball_(m) (\ud835\udcac m) 1 \u2286 ball_(s\u2080.1) (\ud835\udcac s\u2080.1) 100; intro (\u03b8 : \u0398 X) m\u03b8; rw [@mem_ball] at m\u03b8 \u22a2\n  have aux : dist_(sl.1) (\ud835\udcac sl.1) \u03b8 < 2 * l + 3 :=\n    calc\n      _ \u2264 dist_(sl.1) (\ud835\udcac sl.1) (\ud835\udcac p') + dist_(sl.1) (\ud835\udcac p') \u03b8 := dist_triangle ..\n      _ < l + dist_(sl.1) (\ud835\udcac p') \u03b8 := by\n        apply add_lt_add_right\n        have : \ud835\udcac p' \u2208 ball_(p') (\ud835\udcac p') l := by convert mem_ball_self (zero_lt_two.trans_le hl)\n        exact mem_ball'.mp (sp'.2 this)\n      _ \u2264 l + dist_(p') (\ud835\udcac p') \u03b8 := add_le_add_left (Grid.dist_mono sp'.1) _\n      _ \u2264 l + dist_(p') (\ud835\udcac p') (\ud835\udcac b) + dist_(p') (\ud835\udcac b) \u03b8 := by\n        rw [add_assoc]; apply add_le_add_left; exact dist_triangle ..\n      _ \u2264 l + (l + 1) + dist_(b) (\ud835\udcac b) \u03b8 := by\n        gcongr\n        \u00b7 rw [\ud835\udd12, Finset.mem_filter] at mb\n          obtain \u27e8(x : \u0398 X), x\u2081, x\u2082\u27e9 := not_disjoint_iff.mp mb.2.2\n          replace x\u2082 := _root_.subset_cball x\u2082\n          rw [@mem_ball] at x\u2081 x\u2082\n          calc\n            _ \u2264 dist_(p') x (\ud835\udcac p') + dist_(p') x (\ud835\udcac b) := dist_triangle_left ..\n            _ \u2264 _ := by\n              apply add_le_add x\u2081.le\n              change dist_{\ud835\udcd8 p'} x (\ud835\udcac b) \u2264 1; rw [\ud835\udcd8p'b]; exact x\u2082.le\n        \u00b7 change dist_{\ud835\udcd8 p'} (\ud835\udcac b) \u03b8 \u2264 dist_{\ud835\udcd8 b} (\ud835\udcac b) \u03b8; rw [\ud835\udcd8p'b]\n      _ \u2264 l + (l + 1) + (dist_(b) (\ud835\udcac m) (\ud835\udcac b) + dist_(b) (\ud835\udcac m) \u03b8) :=\n        add_le_add_left (dist_triangle_left ..) _\n      _ \u2264 l + (l + 1) + (1 + dist_(m) (\ud835\udcac m) \u03b8) := by\n        gcongr\n        \u00b7 exact (dist_\ud835\udcac_lt_one_of_le lm).le\n        \u00b7 exact Grid.dist_mono lm.1\n      _ < l + (l + 1) + (1 + 1) := by gcongr; exact mem_ball'.mp m\u03b8\n      _ = _ := by ring\n  calc\n    _ \u2264 dist_(s\u2080.1) (\ud835\udcac sl.1) \u03b8 + dist_(s\u2080.1) (\ud835\udcac sl.1) (\ud835\udcac s\u2080.1) := dist_triangle_left ..\n    _ < 1 + dist_(s\u2080.1) (\ud835\udcac sl.1) \u03b8 := by\n      rw [add_comm]; exact add_lt_add_right (dist_\ud835\udcac_lt_one_of_le s.head_le_last) _\n    _ \u2264 1 + C2_1_2 a ^ n * dist_(sl.1) (\ud835\udcac sl.1) \u03b8 := add_le_add_left (dist_LTSeries hs) _\n    _ < 1 + C2_1_2 a ^ n * (2 * l + 3) := by gcongr; rw [C2_1_2]; positivity\n    _ \u2264 1 + (1 / 512) ^ n * (2 * 2 ^ n + 3) := by\n      gcongr\n      \u00b7 rw [C2_1_2]; positivity\n      \u00b7 exact C2_1_2_le_inv_512 X\n      \u00b7 exact_mod_cast (l_upper_bound hl qp').le\n    _ = 1 + 2 * (2 / 512) ^ n + (1 / 512) ^ n * 3 := by\n      simp [div_pow]; ring\n    _ \u2264 1 + 2 * (2 / 512) ^ 0 + (1 / 512) ^ 0 * 3 := by\n      gcongr 1 + 2 * ?_ + ?_ * 3 <;>\n        exact pow_le_pow_of_le_one (by norm_num) (by norm_num) (by omega)\n    _ < _ := by norm_num\n\n/-- Part of Lemma 5.5.2 -/\nlemma pairwiseDisjoint_L0' : univ.PairwiseDisjoint (\ud835\udd0f\u2080' (X := X) k n) := pairwiseDisjoint_minLayer\n\n/-- Part of Lemma 5.5.2 -/\nlemma antichain_L0' : IsAntichain (\u00b7 \u2264 \u00b7) (\ud835\udd0f\u2080' (X := X) k n l) := isAntichain_minLayer\n\nsection L2Antichain\n\n/-- Type synonym of `\u212d\u2081` to apply the `Preorder` of the proof of Lemma 5.5.3 on. -/\nprivate def \u212d\u2081' (k n j : \u2115) : Type _ := \u212d\u2081 (X := X) k n j\n\nprivate instance : Fintype (\u212d\u2081' (X := X) k n j) := inferInstanceAs (Fintype (\u212d\u2081 k n j))\n\nprivate instance : Preorder (\u212d\u2081' (X := X) k n j) where\n  le x y := smul 200 x.1 \u2264 smul 200 y.1\n  le_refl := by simp\n  le_trans _ _ _ xy yz := by\n    change smul _ _ \u2264 smul _ _ at xy yz \u22a2\n    exact xy.trans yz\n\n/-- Lemma 5.5.3 -/\nlemma antichain_L2 : IsAntichain (\u00b7 \u2264 \u00b7) (\ud835\udd0f\u2082 (X := X) k n j) := by\n  by_contra h; rw [isAntichain_iff_forall_not_lt] at h; push_neg at h\n  obtain \u27e8p', mp', p, mp, l\u27e9 := h\n  have p200 : smul 2 p' \u2264 smul 200 p := by\n    calc\n      _ \u2264 smul (11 / 10 + C2_1_2 a * 200) p' := by\n        apply smul_mono_left\n        calc\n          _ \u2264 11 / 10 + 1 / 512 * (200 : \u211d) := by gcongr; exact C2_1_2_le_inv_512 X\n          _ \u2264 _ := by norm_num\n      _ \u2264 _ := by\n        refine smul_C2_1_2 _ (by norm_num) ?_ (wiggle_order_11_10 l.le (C5_3_3_le (X := X)))\n        exact (\ud835\udcd8_strictMono l).ne\n  have cp : p \u2208 \u212d\u2081 k n j := (\ud835\udd0f\u2082_subset_\u212d\u2082.trans \u212d\u2082_subset_\u212d\u2081) mp\n  let C : Finset (LTSeries (\u212d\u2081' k n j)) := { s | s.head = \u27e8p, cp\u27e9 }\n  have Cn : C.Nonempty := by\n    use RelSeries.singleton _ \u27e8p, cp\u27e9\n    simp_rw [C, Finset.mem_filter, Finset.mem_univ, true_and]; rfl\n  obtain \u27e8z, mz, maxz\u27e9 := C.exists_max_image (\u00b7.length) Cn\n  simp_rw [C, Finset.mem_filter, Finset.mem_univ, true_and] at mz\n  by_cases mu : z.last.1 \u2208 \ud835\udd18\u2081 k n j\n  \u00b7 have px : z.head \u2264 z.last := z.monotone (Fin.zero_le _)\n    rw [mz] at px\n    apply absurd mp'; rw [\ud835\udd0f\u2082, mem_setOf, not_and_or, not_not]; right; use z.last.1, mu\n    have : \ud835\udcd8 p' < \ud835\udcd8 p := \ud835\udcd8_strictMono l\n    exact \u27e8(this.trans_le px.1).ne, (p200.trans px).trans (smul_mono_left (by norm_num))\u27e9\n  \u00b7 simp_rw [\ud835\udd18\u2081, mem_setOf, not_and, z.last.2, true_implies, not_forall, exists_prop] at mu\n    obtain \u27e8q, mq, lq, ndjq\u27e9 := mu; rw [not_disjoint_iff] at ndjq; obtain \u27e8\u03d1, m\u03d1\u2081, m\u03d1\u2082\u27e9 := ndjq\n    have cpos : 0 < C2_1_2 a := by rw [C2_1_2]; positivity\n    have s200 : smul 200 z.last.1 \u2264 smul 200 q := by\n      refine \u27e8lq.le, (?_ : ball_(q) (\ud835\udcac q) 200 \u2286 ball_(z.last.1) (\ud835\udcac z.last.1) 200)\u27e9\n      intro (r : \u0398 X) mr\n      rw [@mem_ball] at mr m\u03d1\u2081 m\u03d1\u2082 \u22a2\n      calc\n        _ \u2264 dist_(z.last.1) r (\ud835\udcac q) + dist_(z.last.1) (\ud835\udcac q) \u03d1 + dist_(z.last.1) \u03d1 (\ud835\udcac z.last.1) :=\n          dist_triangle4 ..\n        _ \u2264 C2_1_2 a * dist_(q) r (\ud835\udcac q) + C2_1_2 a * dist_(q) (\ud835\udcac q) \u03d1 + 100 := by\n          gcongr <;> exact Grid.dist_strictMono lq\n        _ \u2264 C2_1_2 a * (200 + 100) + 100 := by rw [mul_add]; gcongr; rw [dist_comm]; exact m\u03d1\u2082.le\n        _ \u2264 (1 / 512) * 300 + 100 := by\n          rw [show (200 : \u211d) + 100 = 300 by norm_num]; gcongr\n          exact C2_1_2_le_inv_512 X\n        _ < _ := by norm_num\n    have : z.last < \u27e8q, mq\u27e9 := by\n      refine \u27e8s200, (?_ : \u00ac(smul 200 q \u2264 smul 200 z.last.1))\u27e9\n      rw [TileLike.le_def, not_and_or]; exact Or.inl (not_le_of_gt lq)\n    apply absurd maxz; push_neg; use z.snoc \u27e8q, mq\u27e9 this, by simp [C, mz], by simp\n\nend L2Antichain\n\n/-- Part of Lemma 5.5.4 -/\nlemma antichain_L1 : IsAntichain (\u00b7 \u2264 \u00b7) (\ud835\udd0f\u2081 (X := X) k n j l) := isAntichain_minLayer\n\n/-- Part of Lemma 5.5.4 -/\nlemma antichain_L3 : IsAntichain (\u00b7 \u2264 \u00b7) (\ud835\udd0f\u2083 (X := X) k n j l) := isAntichain_maxLayer\n\n/- Our goal is now to estimate `\u222b\u207b x in G \\ G', \u2016carlesonSum \ud835\udd13\u2081\u1d9c f x\u2016\u208a` by decomposing `\ud835\udd13\u2081\u1d9c` as a\nunion of disjoint antichains. For this, we proceed step by step, isolating some antichains and\nsome sets that remain to be decomposed. After 4 steps, we will get a sum of integrals corresponding\nto the (disjoint) decomposition in Lemma 5.5.1.\n-/\n\n/-- The Carleson sum over `\ud835\udd13\u2081\u1d9c` and `\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c` coincide at ae every point of `G \\ G'`. -/\nlemma carlesonSum_\ud835\udd13\u2081_compl_eq_\ud835\udd13pos_inter (f : X \u2192 \u2102) :\n    \u2200\u1d50 x, x \u2208 G \\ G' \u2192 carlesonSum \ud835\udd13\u2081\u1d9c f x = carlesonSum (\ud835\udd13pos (X := X) \u2229 \ud835\udd13\u2081\u1d9c) f x := by\n  have A p (hp : p \u2208 (\ud835\udd13pos (X := X))\u1d9c) : \u2200\u1d50 x, x \u2208 G \\ G' \u2192 x \u2209 \ud835\udcd8 p := by\n    simp only [\ud835\udd13pos, mem_compl_iff, mem_setOf_eq, not_lt, nonpos_iff_eq_zero] at hp\n    filter_upwards [measure_zero_iff_ae_nmem.mp hp] with x hx h'x (h''x : x \u2208 (\ud835\udcd8 p : Set X))\n    simp [h''x, h'x.1, h'x.2] at hx\n  rw [\u2190 ae_ball_iff (to_countable \ud835\udd13pos\u1d9c)] at A\n  filter_upwards [A] with x hx h'x\n  simp only [carlesonSum]\n  symm\n  apply Finset.sum_subset\n  \u00b7 intro p hp\n    simp only [Finset.mem_filter, Finset.mem_univ, true_and] at hp \u22a2\n    exact hp.2\n  \u00b7 intro p hp h'p\n    simp only [Finset.mem_filter, Finset.mem_univ, true_and] at hp h'p\n    simp only [mem_inter_iff, hp, and_true] at h'p\n    have : x \u2209 \ud835\udcd8 p := hx _ h'p h'x\n    have : x \u2209 E p := by simp at this; simp [E, this]\n    simp [carlesonOn, this]\n\n/-- The Carleson sum over `\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c` can be decomposed as a sum over the intersections of this\nset with various `\u212d k n`. -/\nlemma carlesonSum_\ud835\udd13pos_eq_sum {f : X \u2192 \u2102} {x : X} :\n    carlesonSum (\ud835\udd13pos (X := X) \u2229 \ud835\udd13\u2081\u1d9c) f x =\n      \u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, carlesonSum (\ud835\udd13pos (X := X) \u2229 \ud835\udd13\u2081\u1d9c \u2229 \u212d k n) f x := by\n  simp only [Finset.sum_sigma']\n  rw [sum_carlesonSum_of_pairwiseDisjoint]; swap\n  \u00b7 rintro \u27e8n, k\u27e9 - \u27e8n', k'\u27e9 - h\n    simp only [ne_eq, Sigma.mk.inj_iff, heq_eq_eq] at h\n    simp only [Function.onFun, disjoint_iff_forall_ne]\n    have W := pairwiseDisjoint_\u212d (X := X) (mem_univ \u27e8k, n\u27e9) (mem_univ \u27e8k', n'\u27e9)\n      (by simp [-not_and]; tauto)\n    intro x hx y hy\n    exact (disjoint_iff_forall_ne.1 W) hx.2 hy.2\n  congr\n  ext p\n  simp only [mem_inter_iff, mem_compl_iff, Finset.mem_sigma,\n    Finset.mem_Iic, mem_iUnion, exists_and_left, exists_prop, Sigma.exists, iff_self_and, and_imp]\n  intro hp h'p\n  rcases exists_k_n_of_mem_\ud835\udd13pos hp with \u27e8k, n, h'p, hkn\u27e9\n  exact \u27e8n, k, \u27e8le_max\u212d_of_nonempty \u27e8p, h'p\u27e9 , hkn\u27e9, h'p\u27e9\n\n", "theoremStatement": "/-- In each set `\u212d k n`, the Carleson sum can be decomposed as a sum over `\ud835\udd0f\u2080 k n` and over\nvarious `\u212d\u2081 k n j`. -/\nlemma carlesonSum_\ud835\udd13pos_inter_\u212d_eq_add_sum {f : X \u2192 \u2102} {x : X} (hkn : k \u2264 n) :\n    carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \u212d k n) f x =\n      carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2080 k n) f x\n      + \u2211 j \u2264 2 * n + 3, carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \u212d\u2081 k n j) f x ", "theoremName": "carlesonSum_\ud835\udd13pos_inter_\u212d_eq_add_sum", "fileCreated": {"commit": "310e13d16e51600777fc841833f4bce112b5f73a", "date": "2024-09-24"}, "theoremCreated": {"commit": "77d4285c51ebe49f9035715383dfd7aef6aecf25", "date": "2025-01-09"}, "file": "carleson/Carleson/Discrete/ForestComplement.lean", "module": "Carleson.Discrete.ForestComplement", "jsonFile": "Carleson.Discrete.ForestComplement.jsonl", "positionMetadata": {"lineInFile": 636, "tokenPositionInFile": 32304, "theoremPositionInFile": 34}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 29, "numPremises": 158}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  conv_lhs => rw [\u2190 carlesonSum_inter_add_inter_compl _ (\ud835\udd0f\u2080 k n)]\n  rw [sum_carlesonSum_of_pairwiseDisjoint]; swap\n  \u00b7 apply PairwiseDisjoint.subset _ (subset_univ _)\n    apply (pairwiseDisjoint_\u212d\u2081 (k := k) (n := n)).mono\n    intro j\n    exact inter_subset_right\n  congr 2\n  \u00b7 ext p\n    simp only [mem_inter_iff, mem_compl_iff, and_congr_left_iff, and_iff_left_iff_imp, and_imp]\n    intro hp\n    simp [\ud835\udd0f\u2080_subset_\u212d hp]\n  \u00b7 apply Subset.antisymm\n    \u00b7 rintro p \u27e8\u27e8hp, Hp\u27e9, h'p\u27e9\n      rcases exists_j_of_mem_\ud835\udd13pos_\u212d hp.1 Hp hkn with H\n      simp only [mem_compl_iff] at h'p\n      simp only [h'p, false_or] at H\n      simp only [Finset.mem_Iic, mem_iUnion, mem_inter_iff, hp, true_and, exists_prop]\n      exact H\n    \u00b7 intro p hp\n      simp only [Finset.mem_Iic, mem_iUnion, mem_compl_iff, exists_and_left, exists_prop] at hp\n      rcases hp with \u27e8i, hi, h'i, h''i\u27e9\n      exact \u27e8\u27e8h'i, \u212d\u2081_subset_\u212d h''i\u27e9, disjoint_left.1 \ud835\udd0f\u2080_disjoint_\u212d\u2081.symm h''i\u27e9", "proofType": "tactic", "proofLengthLines": 22, "proofLengthTokens": 945}}
{"srcContext": "import Carleson.Defs\n\nopen Set MeasureTheory Metric Function Complex Bornology\nopen scoped NNReal ENNReal ComplexConjugate\nnoncomputable section\n\nsection Generic\nuniverse u\nvariable {\ud835\udd5c : Type*} [_root_.RCLike \ud835\udd5c]\n\nvariable (X) in\n/-- A grid structure on `X`.\nI expect we prefer `coeGrid : Grid \u2192 Set X` over `Grid : Set (Set X)`\nNote: the `s` in this paper is `-s` of Christ's paper.\n-/\nclass GridStructure {A : outParam \u211d\u22650} [PseudoMetricSpace X] [DoublingMeasure X A]\n    (D : outParam \u2115) (\u03ba : outParam \u211d) (S : outParam \u2115) (o : outParam X) where\n  /-- indexing set for a grid structure -/\n  protected Grid : Type u\n  fintype_Grid : Fintype Grid\n  /-- The collection of dyadic cubes -/\n  coeGrid : Grid \u2192 Set X\n  /-- scale functions -/\n  s : Grid \u2192 \u2124\n  /-- Center functions -/\n  c : Grid \u2192 X\n  inj : Injective (fun i \u21a6 (coeGrid i, s i))\n  range_s_subset : range s \u2286 Icc (-S) S\n  topCube : Grid\n  s_topCube : s topCube = S\n  c_topCube : c topCube = o\n  subset_topCube {i} : coeGrid i \u2286 coeGrid topCube\n  Grid_subset_biUnion {i} : \u2200 k \u2208 Ico (-S : \u2124) (s i), coeGrid i \u2286 \u22c3 j \u2208 s \u207b\u00b9' {k}, coeGrid j\n  fundamental_dyadic' {i j} : s i \u2264 s j \u2192 coeGrid i \u2286 coeGrid j \u2228 Disjoint (coeGrid i) (coeGrid j)\n  ball_subset_Grid {i} : ball (c i) (D ^ s i / 4) \u2286 coeGrid i --2.0.10\n  Grid_subset_ball {i} : coeGrid i \u2286 ball (c i) (4 * D ^ s i) --2.0.10\n  small_boundary {i} {t : \u211d\u22650} (ht : D ^ (- S - s i) \u2264 t) :\n    volume.real { x \u2208 coeGrid i | EMetric.infEdist x (coeGrid i)\u1d9c \u2264 t * (D ^ (s i):\u211d\u22650\u221e)} \u2264 2 * t ^ \u03ba * volume.real (coeGrid i)\n  coeGrid_measurable {i} : MeasurableSet (coeGrid i)\n\nexport GridStructure (range_s_subset Grid_subset_biUnion ball_subset_Grid Grid_subset_ball small_boundary\n  topCube s_topCube c_topCube subset_topCube coeGrid_measurable) -- should `X` be explicit in topCube?\n\nattribute [coe] GridStructure.coeGrid\n\nvariable {X : Type u} {A : \u211d\u22650} [PseudoMetricSpace X] [DoublingMeasure X A]\nvariable {D : \u2115} {\u03ba : \u211d} {S : \u2115} {o : X}\nvariable [GridStructure X D \u03ba S o]\n\nvariable (X) in\n/-- The indexing type of the grid structure. Elements are called (dyadic) cubes.\nNote that this type has instances for both `\u2264` and `\u2286`, but they do *not* coincide. -/\nabbrev Grid : Type u := GridStructure.Grid X\n\ndef s : Grid X \u2192 \u2124 := GridStructure.s\ndef c : Grid X \u2192 X := GridStructure.c\n\nvariable {i j : Grid X}\n\ninstance : Inhabited (Grid X) := \u27e8topCube\u27e9\ninstance : Fintype (Grid X) := GridStructure.fintype_Grid\ninstance : Coe (Grid X) (Set X) := \u27e8GridStructure.coeGrid\u27e9\ninstance : Membership X (Grid X) := \u27e8fun i x \u21a6 x \u2208 (i : Set X)\u27e9\ninstance : PartialOrder (Grid X) := PartialOrder.lift _ GridStructure.inj\n/- These should probably not/only rarely be used. I comment them out for now,\nso that we don't accidentally use it. We can put it back if useful after all. -/\n-- instance : HasSubset (Grid X) := \u27e8fun i j \u21a6 (i : Set X) \u2286 (j : Set X)\u27e9\n-- instance : HasSSubset (Grid X) := \u27e8fun i j \u21a6 (i : Set X) \u2282 (j : Set X)\u27e9\n-- @[simp] lemma Grid.subset_def : i \u2286 j \u2194 (i : Set X) \u2286 (j : Set X) := .rfl\n-- @[simp] lemma Grid.ssubset_def : i \u2282 j \u2194 (i : Set X) \u2282 (j : Set X) := .rfl\n\n/- not sure whether these should be simp lemmas, but that might be required if we want to\n  conveniently rewrite/simp with Set-lemmas -/\n@[simp] lemma Grid.mem_def {x : X} : x \u2208 i \u2194 x \u2208 (i : Set X) := .rfl\n@[simp] lemma Grid.le_def : i \u2264 j \u2194 (i : Set X) \u2286 (j : Set X) \u2227 s i \u2264 s j := .rfl\n\nlemma fundamental_dyadic :\n    s i \u2264 s j \u2192 (i : Set X) \u2286 (j : Set X) \u2228 Disjoint (i : Set X) (j : Set X) :=\n  GridStructure.fundamental_dyadic'\n\nlemma le_or_disjoint (h : s i \u2264 s j) : i \u2264 j \u2228 Disjoint (i : Set X) (j : Set X) :=\n  fundamental_dyadic h |>.imp (\u27e8\u00b7, h\u27e9) id\n\nlemma le_or_ge_or_disjoint : i \u2264 j \u2228 j \u2264 i \u2228 Disjoint (i : Set X) (j : Set X) := by\n  rcases le_or_lt (s i) (s j) with h | h\n  \u00b7 have := le_or_disjoint h; tauto\n  \u00b7 have := le_or_disjoint h.le; tauto\n\nlemma le_or_ge_of_mem_of_mem {c : X} (mi : c \u2208 i) (mj : c \u2208 j) : i \u2264 j \u2228 j \u2264 i :=\n  (or_assoc.mpr le_or_ge_or_disjoint).resolve_right (not_disjoint_iff.mpr \u27e8c, mi, mj\u27e9)\n\nlemma le_of_mem_of_mem (h : s i \u2264 s j) {c : X} (mi : c \u2208 i) (mj : c \u2208 j) : i \u2264 j :=\n  \u27e8(fundamental_dyadic h).resolve_right (not_disjoint_iff.mpr \u27e8c, mi, mj\u27e9), h\u27e9\n\nlemma eq_or_disjoint (hs : s i = s j) : i = j \u2228 Disjoint (i : Set X) (j : Set X) :=\n  Or.elim (le_or_disjoint hs.le) (fun ij \u21a6 Or.elim (le_or_disjoint hs.ge)\n     (fun ji \u21a6 Or.inl (le_antisymm ij ji)) (fun h \u21a6 Or.inr h.symm)) (fun h \u21a6 Or.inr h)\n\nlemma subset_of_nmem_Iic_of_not_disjoint (i : Grid X) (j : Grid X)\n    (h : i \u2209 Iic j)\n    (notDisjoint : \u00ac Disjoint (i : Set X) j) :\n    (j : Set X) \u2286 i := by\n  rw [Iic, Set.nmem_setOf_iff, Grid.le_def, not_and_or] at h\n  have h_le_cases := le_or_ge_or_disjoint (i := i) (j := j)\n  rcases h_le_cases with i_le | j_le | disjoint\n  \u00b7 exact (h.neg_resolve_left i_le.1 i_le.2).elim\n  \u00b7 rw [disjoint_comm] at notDisjoint\n    exact (GridStructure.fundamental_dyadic' j_le.2).resolve_right notDisjoint\n  \u00b7 exact (notDisjoint disjoint).elim\n\nlemma scale_mem_Icc : s i \u2208 Icc (-S : \u2124) S := mem_Icc.mp (range_s_subset \u27e8i, rfl\u27e9)\n\nlemma volume_coeGrid_pos (hD : 0 < D) : 0 < volume (i : Set X) := by\n  have hD : 0 < (D : \u211d) ^ GridStructure.s i / 4 := by\n    simp only [Nat.ofNat_pos, div_pos_iff_of_pos_right]\n    exact zpow_pos (Nat.cast_pos'.mpr hD) _\n  exact measure_pos_of_superset ball_subset_Grid (ne_of_gt (measure_ball_pos _ _ hD))\n\n@[aesop (rule_sets := [finiteness]) safe apply]\nlemma volume_coeGrid_lt_top : volume (i : Set X) < \u22a4 :=\n  measure_lt_top_of_subset Grid_subset_ball (measure_ball_ne_top _ _)\n\nnamespace Grid\n\nprotected lemma inj : Injective (fun i : Grid X \u21a6 ((i : Set X), s i)) := GridStructure.inj\n\nlemma le_topCube : i \u2264 topCube :=\n  \u27e8subset_topCube, scale_mem_Icc.2.trans_eq s_topCube.symm\u27e9\n\nlemma isTop_topCube : IsTop (topCube : Grid X) := fun _ \u21a6 le_topCube\n\nlemma isMax_iff : IsMax i \u2194 i = topCube := isTop_topCube.isMax_iff\n\n/-- The set `I \u21a6 I\u1d52` in the blueprint. -/\ndef int (i : Grid X) : Set X := ball (c i) (D ^ s i / 4)\n\npostfix:max \"\u1d52\" => Grid.int\n\n/-- An auxiliary measure used in the well-foundedness of `\u03a9` in Lemma `tile_structure`. -/\ndef opSize (i : Grid X) : \u2115 := (S - s i).toNat\n\nlemma int_subset : i.int \u2286 i := ball_subset_Grid\n\nend Grid\nend Generic\n\nnamespace Grid\n\nopen scoped ShortVariables\nvariable {X : Type*} [PseudoMetricSpace X] {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102}\n  {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X} [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G]\n\nnotation \"dist_{\" I \"}\" => @dist (WithFunctionDistance (c I) (D ^ s I / 4)) _\nnotation \"nndist_{\" I \"}\" => @nndist (WithFunctionDistance (c I) (D ^ s I / 4)) _\nnotation \"ball_{\" I \"}\" => @ball (WithFunctionDistance (c I) (D ^ s I / 4)) _\n\nsection GridManipulation\n\nvariable [GridStructure X D \u03ba S o]\n\nlemma c_mem_Grid {i : Grid X} : c i \u2208 (i : Set X) := by\n  obtain \u27e8hD\u27e9 := NeZero.of_pos <| zero_lt_one.trans_le one_le_D\n  exact mem_of_mem_of_subset (Metric.mem_ball_self (by positivity)) ball_subset_Grid\n\nlemma nonempty (i : Grid X) : (i : Set X).Nonempty := \u27e8c i, c_mem_Grid\u27e9\n\nlemma le_dyadic {i j k : Grid X} (h : s i \u2264 s j) (li : k \u2264 i) (lj : k \u2264 j) : i \u2264 j := by\n  obtain \u27e8c, mc\u27e9 := k.nonempty\n  exact le_of_mem_of_mem h (mem_of_mem_of_subset mc li.1) (mem_of_mem_of_subset mc lj.1)\n\n@[simp] lemma lt_def {i j : Grid X} : i < j \u2194 (i : Set X) \u2286 (j : Set X) \u2227 s i < s j := by\n  constructor <;> intro h\n  \u00b7 obtain \u27e8a\u2081, a\u2082\u27e9 := h.le\n    refine \u27e8a\u2081, lt_of_le_of_ne a\u2082 ?_\u27e9\n    by_contra a\u2083\n    have l : i < i := h.trans_le (le_dyadic a\u2083.ge h.le le_rfl)\n    rwa [lt_self_iff_false] at l\n  \u00b7 apply lt_of_le_of_ne (le_def.mpr \u27e8h.1, h.2.le\u27e9)\n    by_contra a; rw [a, lt_self_iff_false] at h; exact h.2\n\nlemma isMin_iff {i : Grid X} : IsMin i \u2194 s i = - S := by\n  refine \u27e8fun h \u21a6 ?_, fun h \u21a6 ?_\u27e9\n  \u00b7 apply le_antisymm ?_ scale_mem_Icc.1\n    contrapose! h\n    have : -(S : \u2124) \u2208 Ico (-(S : \u2124)) (s i) := by simp [h]\n    have := Grid_subset_biUnion (i := i) (-S) this c_mem_Grid\n    simp only [defaultA, defaultD.eq_1, default\u03ba.eq_1, mem_preimage, mem_singleton_iff, mem_iUnion,\n      exists_prop] at this\n    rcases this with \u27e8j, (hj : s j = -(S : \u2124)), h'j\u27e9\n    have sji : s j < s i := by simpa [hj] using h\n    have : (j : Set X) \u2286 i := by\n      rcases fundamental_dyadic sji.le with hji | h_disj\n      \u00b7 exact hji\n      \u00b7 exact (disjoint_right.1 h_disj c_mem_Grid h'j).elim\n    have : j < i := by simp [this, sji]\n    exact this.not_isMin\n  \u00b7 intro j hj\n    have : s i \u2264 s j := by rw [h]; exact (scale_mem_Icc (i := j)).1\n    rcases le_or_disjoint this with h' | h_disj\n    \u00b7 exact h'\n    \u00b7 exact False.elim (disjoint_right.1 h_disj c_mem_Grid (hj.1 c_mem_Grid))\n\n/-- There exists a unique successor of each non-maximal cube. -/\nlemma exists_unique_succ (i : Grid X) (h : \u00acIsMax i) :\n    \u2203! j \u2208 Finset.univ, i < j \u2227 \u2200 j', i < j' \u2192 j \u2264 j' := by\n  simp_rw [Finset.mem_univ, true_and]\n  classical let incs : Finset (Grid X) := { j | i < j }\n  have ine : incs.Nonempty := by\n    use topCube; simp only [incs, Finset.mem_filter, Finset.mem_univ, true_and]\n    exact lt_of_le_of_ne le_topCube (isMax_iff.not.mp h)\n  obtain \u27e8j, mj, hj\u27e9 := incs.exists_minimal ine\n  simp only [gt_iff_lt, Finset.mem_filter, Finset.mem_univ, true_and, incs] at mj hj\n  replace hj : \u2200 (x : Grid X), i < x \u2192 j \u2264 x := fun x mx \u21a6 by\n    rcases lt_or_le (s x) (s j) with c | c\n    \u00b7 exact (eq_of_le_of_not_lt (le_dyadic c.le mx.le mj.le) (hj x mx)).symm.le\n    \u00b7 exact le_dyadic c mj.le mx.le\n  use j, \u27e8mj, hj\u27e9, fun k \u27e8hk\u2081, hk\u2082\u27e9 \u21a6 le_antisymm (hk\u2082 j mj) (hj k hk\u2081)\n\nopen Classical in\n/-- If `i` is not a maximal element, this is the (unique) minimal element greater than i.\nThis is not a `SuccOrder` since an element can be the successor of multiple other elements. -/\ndef succ (i : Grid X) : Grid X := if h : IsMax i then i else Finset.choose (hp := exists_unique_succ i h)\n\nvariable {i j : Grid X}\n\nlemma succ_spec (h : \u00acIsMax i) : i < i.succ \u2227 \u2200 j, i < j \u2192 i.succ \u2264 j := by\n  simp only [succ, h, dite_false]\n  classical exact Finset.choose_spec (hp := exists_unique_succ i h).2\n\nlemma succ_unique (h : \u00acIsMax i) : i < j \u2192 (\u2200 j', i < j' \u2192 j \u2264 j') \u2192 i.succ = j := fun k\u2081 k\u2082 \u21a6\n  ((exists_unique_succ i h).unique \u27e8by simp, k\u2081, k\u2082\u27e9 \u27e8by simp, succ_spec h\u27e9).symm\n\nlemma le_succ : i \u2264 i.succ := by\n  by_cases h : IsMax i\n  \u00b7 simp [h, succ]\n  \u00b7 exact (succ_spec h).1.le\n\nlemma max_of_le_succ : i.succ \u2264 i \u2192 IsMax i := fun h \u21a6 by\n  contrapose! h; by_contra! k; have l := (succ_spec h).1.trans_le k\n  rwa [lt_self_iff_false] at l\n\nlemma not_isMax_of_scale_lt {j W : Grid X} (h : s j < s W) : \u00acIsMax j := by\n  rw [Grid.isMax_iff]\n  intro top\n  rw [top, show s topCube = \u2191S by exact s_topCube (X := X)] at h\n  linarith [(scale_mem_Icc (i := W)).2]\n\nlemma succ_le_of_lt (h : i < j) : i.succ \u2264 j := by\n  by_cases k : IsMax i\n  \u00b7 simp only [k, succ, dite_true]; exact h.le\n  \u00b7 exact (succ_spec k).2 j h\n\nlemma exists_containing_subcube (l : \u2124) (h : l \u2208 Icc (-S : \u2124) (s i)) {x : X} (mx : x \u2208 i) :\n    \u2203 j, s j = l \u2227 x \u2208 j := by\n  obtain \u27e8lb, ub\u27e9 := h\n  rcases ub.eq_or_lt with ub | ub\n  \u00b7 exact \u27e8i, ub.symm, mx\u27e9\n  \u00b7 simpa [mem_iUnion\u2082, mem_preimage, mem_singleton_iff, exists_prop] using\n      Grid_subset_biUnion l \u27e8lb, ub\u27e9 mx\n\nlemma exists_supercube (l : \u2124) (h : l \u2208 Icc (s i) S) : \u2203 j, s j = l \u2227 i \u2264 j := by\n  obtain \u27e8lb, ub\u27e9 := h\n  rcases ub.eq_or_lt with ub | ub; \u00b7 exact \u27e8topCube, by simpa [ub] using s_topCube, le_topCube\u27e9\n  obtain \u27e8x, hx\u27e9 := i.nonempty\n  have bound_i : -S \u2264 s i \u2227 s i \u2264 S := scale_mem_Icc\n  have ts := Grid_subset_biUnion (X := X) (i := topCube) l\n    (by rw [s_topCube, mem_Ico]; omega)\n  have := mem_of_mem_of_subset hx ((le_topCube (i := i)).1.trans ts)\n  simp_rw [mem_preimage, mem_singleton_iff, mem_iUnion, exists_prop] at this\n  obtain \u27e8j, (sj : s j = l), mj\u27e9 := this; use j, sj\n  exact le_of_mem_of_mem (by omega) hx mj\n\nlemma exists_sandwiched (h : i \u2264 j) (l : \u2124) (hl : l \u2208 Icc (s i) (s j)) :\n    \u2203 k, s k = l \u2227 i \u2264 k \u2227 k \u2264 j := by\n  have bound_q : -S \u2264 s j \u2227 s j \u2264 S := scale_mem_Icc\n  rw [mem_Icc] at hl\n  obtain \u27e8K, sK, lbK\u27e9 := exists_supercube l (by change s i \u2264 _ \u2227 _; omega)\n  use K, sK, lbK\n  exact le_dyadic (by omega) lbK h\n\n", "theoremStatement": "lemma scale_succ (h : \u00acIsMax i) : s i.succ = s i + 1 ", "theoremName": "Grid.scale_succ", "fileCreated": {"commit": "743fbe4ea5741cd92c855e66055ba156f232beff", "date": "2024-06-16"}, "theoremCreated": {"commit": "2226ad3d2e5a9c3cac47927348d7fda68f652501", "date": "2025-01-20"}, "file": "carleson/Carleson/GridStructure.lean", "module": "Carleson.GridStructure", "jsonFile": "Carleson.GridStructure.jsonl", "positionMetadata": {"lineInFile": 281, "tokenPositionInFile": 11991, "theoremPositionInFile": 42}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 12, "repositoryPremises": true, "numRepositoryPremises": 21, "numPremises": 143}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  obtain \u27e8h\u2081, h\u2082\u27e9 := succ_spec h\n  rw [lt_def] at h\u2081; apply le_antisymm _ (by omega)\n  by_contra! h\u2080\n  obtain \u27e8z, hz\u2081, hz\u2082, hz\u2083\u27e9 :=\n    exists_sandwiched (le_succ (i := i)) (s i + 1) (by rw [mem_Icc]; omega)\n  have l := (lt_def.mpr \u27e8hz\u2083.1, hz\u2081.symm \u25b8 h\u2080\u27e9).trans_le (h\u2082 z (lt_def.mpr \u27e8hz\u2082.1, by omega\u27e9))\n  rwa [lt_self_iff_false] at l", "proofType": "tactic", "proofLengthLines": 7, "proofLengthTokens": 339}}
{"srcContext": "/-\nCopyright (c) 2024 Joris Roos. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joris Roos, S\u00e9bastien Gou\u00ebzel\n-/\n\nimport Mathlib.Analysis.Convex.PartitionOfUnity\nimport Mathlib.Analysis.Calculus.ContDiff.Basic\nimport Mathlib.MeasureTheory.Integral.Average\nimport Mathlib.MeasureTheory.Integral.Bochner\nimport Mathlib.MeasureTheory.Integral.Prod\nimport Mathlib.MeasureTheory.Measure.Haar.OfBasis\nimport Mathlib.Topology.MetricSpace.Holder\nimport Mathlib.Data.Set.Card\nimport Mathlib.Data.Real.ENatENNReal\nimport Carleson.ToMathlib.Misc\n\n/-!\n\nEXPERIMENTAL\n\n# Bounded compactly supported functions\n\nThe purpose of this file is to provide helper lemmas to streamline proofs that\nfunctions are (essentially) bounded, compactly supported and measurable.\n\nMost functions we need to deal with are of this class.\nThis can be a useful way to streamline proofs of `L^p` membership,\nin particular integrability.\n\nTodo: make `Mathlib.Tactic.FunProp` work for this\n\nThis can be expanded as needed\n\n-/\n\nset_option linter.unusedSectionVars false -- remove for mathlib\n\nnamespace MeasureTheory\n\nopen Bornology Function Set HasCompactSupport\nopen scoped ENNReal\n\nsection\n\n-- This setting should be enough for this project, but\n-- for mathlib should generalize to vector-valued, and use `MeasurableSpace X`, `Measure \u03bc`\nvariable {X \ud835\udd5c} [MeasurableSpace X] [RCLike \ud835\udd5c] {f : X \u2192 \ud835\udd5c} {\u03bc : Measure X}\nvariable [TopologicalSpace X]\n-- variable [T2Space X] -- for mathlib should remove this\n-- variable [IsFiniteMeasureOnCompacts \u03bc]\n-- variable [SigmaFinite (volume : Measure X)]\n\n/-- Bounded compactly supported measurable functions -/\n-- There are various alternative definitions one could use here\n-- After all it does seem to be better to use `IsBounded (range f)`\n-- Todo: Refactor accordingly\nstructure BoundedCompactSupport (f : X \u2192 \ud835\udd5c) : Prop where\n  isBounded : IsBounded (range f)\n  stronglyMeasurable : StronglyMeasurable f\n  hasCompactSupport : HasCompactSupport f\n\nlemma isBounded_range_iff_forall_norm_le {\u03b1 \u03b2} [SeminormedAddCommGroup \u03b1] {f : \u03b2 \u2192 \u03b1} :\n    IsBounded (range f) \u2194 \u2203 C, \u2200 x, \u2016f x\u2016 \u2264 C := by convert isBounded_iff_forall_norm_le; simp\n\nomit [TopologicalSpace X] in\nlemma _root_.Bornology.IsBounded.eLpNorm_top_lt_top (hf : IsBounded (range f)) :\n    eLpNorm f \u22a4 \u03bc < \u22a4 := by\n  obtain \u27e8C, hC\u27e9 := isBounded_range_iff_forall_norm_le.mp hf\n  apply eLpNormEssSup_lt_top_of_ae_bound (C := C)\n  exact ae_of_all \u03bc hC\n\nomit [TopologicalSpace X] in\n-- maybe in mathlib, but couldn't find it\ntheorem ae_le_of_eLpNorm_top_lt_top (hf : eLpNorm f \u22a4 \u03bc < \u22a4) :\n    \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016 \u2264 ENNReal.toReal (eLpNorm f \u22a4 \u03bc) := by\n  have := coe_nnnorm_ae_le_eLpNormEssSup f \u03bc\n  filter_upwards [this] with x hx\n  have : ENNReal.ofReal \u2016f x\u2016\u208a \u2260 \u22a4 := ENNReal.ofReal_ne_top\n  convert (ENNReal.toReal_le_toReal this ?_).mpr ?_\n  \u00b7 simp\n  \u00b7 exact hf.ne_top\n  \u00b7 exact trans ENNReal.ofReal_coe_nnreal hx\n\nnamespace BoundedCompactSupport\n\nprotected theorem zero : BoundedCompactSupport (fun (_ : X) \u21a6 (0 : \ud835\udd5c)) where\n  isBounded := isBounded_range_iff_forall_norm_le.2 \u27e80, by simp\u27e9\n  stronglyMeasurable := stronglyMeasurable_const\n  hasCompactSupport := HasCompactSupport.zero\n\ntheorem indicator_of_isBounded_range {X : Type*} [MetricSpace X] [ProperSpace X]\n    [MeasurableSpace X] [BorelSpace X] {f : X \u2192 \ud835\udd5c} (hf : IsBounded (range f))\n    (h'f : StronglyMeasurable f) {s : Set X} (h's : IsBounded s) (hs : MeasurableSet s) :\n    BoundedCompactSupport (s.indicator f) where\n  stronglyMeasurable := h'f.indicator hs\n  isBounded := by\n    rcases isBounded_range_iff_forall_norm_le.1 hf with \u27e8C, hC\u27e9\n    apply isBounded_range_iff_forall_norm_le.2 \u27e8C, fun x \u21a6 ?_\u27e9\n    simp only [indicator]\n    split_ifs\n    \u00b7 exact hC x\n    \u00b7 simp only [norm_zero]\n      apply (norm_nonneg _).trans (hC x)\n  hasCompactSupport := by\n    apply HasCompactSupport.intro (K := closure s)\n    \u00b7 apply Metric.isCompact_of_isClosed_isBounded isClosed_closure h's.closure\n    \u00b7 intro x hx\n      have : x \u2209 s := by\n        contrapose! hx; exact subset_closure hx\n      simp [this]\n\nvariable {f : X \u2192 \ud835\udd5c}\nvariable {g : X \u2192 \ud835\udd5c}\n\nvariable (hf : BoundedCompactSupport f)\nvariable (hg : BoundedCompactSupport g)\n\nsection Includehf\n\ninclude hf\n\ntheorem aestronglyMeasurable : AEStronglyMeasurable f \u03bc :=\n  hf.stronglyMeasurable.aestronglyMeasurable\n\ntheorem mem\u2112p_top : Mem\u2112p f \u22a4 \u03bc :=\n  \u27e8hf.aestronglyMeasurable, hf.isBounded.eLpNorm_top_lt_top\u27e9\n\ntheorem ae_le : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016 \u2264 ENNReal.toReal (eLpNorm f \u22a4 \u03bc) :=\n  ae_le_of_eLpNorm_top_lt_top hf.mem\u2112p_top.2\n\n/-- Bounded compactly supported functions are in all `L\u1d56` spaces. -/\ntheorem mem\u2112p [IsFiniteMeasureOnCompacts \u03bc] (p : ENNReal) : Mem\u2112p f p \u03bc :=\n  hf.hasCompactSupport.mem\u2112p_of_bound hf.aestronglyMeasurable _ hf.ae_le\n\n/-- Bounded compactly supported functions are integrable. -/\ntheorem integrable [IsFiniteMeasureOnCompacts \u03bc] : Integrable f \u03bc :=\n  mem\u2112p_one_iff_integrable.mp <| mem\u2112p hf 1\n\ntheorem mul_bdd_right (hg : IsBounded (range g)) (h2g : StronglyMeasurable g) :\n    BoundedCompactSupport (f * g) where\n  isBounded := by\n    rcases isBounded_range_iff_forall_norm_le.1 hf.isBounded with \u27e8C, hC\u27e9\n    rcases isBounded_range_iff_forall_norm_le.1 hg with \u27e8D, hD\u27e9\n    apply isBounded_range_iff_forall_norm_le.2 \u27e8C * D, fun x \u21a6 ?_\u27e9\n    simp only [Pi.mul_apply, norm_mul]\n    gcongr\n    \u00b7 apply (norm_nonneg _).trans (hC x)\n    \u00b7 exact hC x\n    \u00b7 exact hD x\n  stronglyMeasurable := hf.stronglyMeasurable.mul h2g\n  hasCompactSupport := hf.hasCompactSupport.mul_right\n\ntheorem mul_bdd_left (hg : IsBounded (range g)) (h2g : StronglyMeasurable g) :\n    BoundedCompactSupport (g * f) := by\n  rw [mul_comm]; exact mul_bdd_right hf hg h2g\n\n-- doesn't use compact support but is convenient to have here\ntheorem integrable_mul (hg : Integrable g \u03bc) : Integrable (f * g) \u03bc :=\n  Integrable.bdd_mul' hg hf.aestronglyMeasurable hf.ae_le\n\ntheorem conj : BoundedCompactSupport (star f) where\n  isBounded := by simpa [star, isBounded_range_iff_forall_norm_le] using hf.isBounded\n  stronglyMeasurable := RCLike.continuous_conj.comp_stronglyMeasurable hf.stronglyMeasurable\n  hasCompactSupport := by -- mathlib should have a lemma `HasCompactSupport.conj`?\n    simp only [star, RCLike.star_def]\n    apply (hasCompactSupport_comp_left (by simp)).2 hf.hasCompactSupport\n\ntheorem norm : BoundedCompactSupport (\u2016f \u00b7\u2016) where\n  isBounded := by simpa [isBounded_range_iff_forall_norm_le] using hf.isBounded\n  stronglyMeasurable := hf.stronglyMeasurable.norm\n  hasCompactSupport := hf.hasCompactSupport.norm\n\ntheorem const_mul (c : \ud835\udd5c) : BoundedCompactSupport (fun x \u21a6 c * (f x)) where\n  isBounded := by\n    rcases isBounded_range_iff_forall_norm_le.1 hf.isBounded with \u27e8C, hC\u27e9\n    apply isBounded_range_iff_forall_norm_le.2 \u27e8\u2016c\u2016 * C, fun x \u21a6 ?_\u27e9\n    simp only [norm_mul]\n    gcongr\n    exact hC x\n  stronglyMeasurable := hf.stronglyMeasurable.const_mul _\n  hasCompactSupport := by\n    suffices support (fun x \u21a6 c * (f x)) \u2286 support f from\n      hf.hasCompactSupport.mono this\n    exact support_mul_subset_right ..\n\ntheorem mul_const (c : \ud835\udd5c) : BoundedCompactSupport (fun x \u21a6 (f x) * c) := by\n  simp_rw [mul_comm]; exact hf.const_mul _\n\nend Includehf\n\nsection Includehfhg\n\ninclude hf hg\n\ntheorem mul : BoundedCompactSupport (f * g) := mul_bdd_right hf hg.isBounded hg.stronglyMeasurable\n\nprotected theorem add : BoundedCompactSupport (f + g) where\n  isBounded := by\n    rcases isBounded_range_iff_forall_norm_le.1 hf.isBounded with \u27e8C, hC\u27e9\n    rcases isBounded_range_iff_forall_norm_le.1 hg.isBounded with \u27e8D, hD\u27e9\n    apply isBounded_range_iff_forall_norm_le.2 \u27e8C + D, fun x \u21a6 ?_\u27e9\n    apply (norm_add_le _ _).trans\n    gcongr\n    exacts [hC x, hD x]\n  stronglyMeasurable := hf.stronglyMeasurable.add hg.stronglyMeasurable\n  hasCompactSupport := hf.hasCompactSupport.add hg.hasCompactSupport\n\nprotected theorem sub : BoundedCompactSupport (f - g) := by\n  rw [sub_eq_add_neg, neg_eq_neg_one_mul]\n  exact hf.add (hg.const_mul (-1))\n\nend Includehfhg\n\n/-- If `\u2016f\u2016` is bounded by `g` and `g` is bounded compactly supported, then so is `f`. -/\ntheorem mono {g : X \u2192 \u211d} (hg : BoundedCompactSupport g) (hf : StronglyMeasurable f)\n    (hfg : \u2200 x, \u2016f x\u2016 \u2264 g x) : BoundedCompactSupport f where\n  isBounded := by\n    rcases isBounded_range_iff_forall_norm_le.1 hg.isBounded with \u27e8C, hC\u27e9\n    refine isBounded_range_iff_forall_norm_le.2 \u27e8C, fun x \u21a6 ?_\u27e9\n    exact (hfg x).trans ((le_abs_self _).trans (hC x))\n  hasCompactSupport := by\n    refine hg.hasCompactSupport.mono ?_\n    by_contra h\n    simp only [support_subset_iff, ne_eq, mem_support, not_forall, Classical.not_imp,\n      Decidable.not_not] at h\n    obtain \u27e8x, hfx, hgx\u27e9 := h\n    specialize hfg x\n    rw [hgx] at hfg\n    exact hfx <| norm_le_zero_iff.mp hfg\n  stronglyMeasurable := hf\n\ntheorem of_norm_le_const_mul {g : X \u2192 \u211d} {M : \u211d} (hg : BoundedCompactSupport g)\n    (hf : StronglyMeasurable f)\n    (hfg : \u2200 x, \u2016f x\u2016 \u2264 M * g x) : BoundedCompactSupport f :=\n  BoundedCompactSupport.mono (hg.const_mul M) hf hfg\n\nsection Sum\n\nvariable {\u03b9 : Type*} {s : Finset \u03b9} {F : \u03b9 \u2192 X \u2192 \ud835\udd5c}\n\n", "theoremStatement": "/-- A finite sum of bounded compactly supported functions is bounded compactly supported. -/\ntheorem finset_sum\n    (hF : \u2200 i \u2208 s, BoundedCompactSupport (F i)) :\n    BoundedCompactSupport (fun x \u21a6 \u2211 i \u2208 s, F i x) ", "theoremName": "MeasureTheory.BoundedCompactSupport.finset_sum", "fileCreated": {"commit": "ec175b9008144d009269ce427b9ad43dbd70d0a5", "date": "2024-12-09"}, "theoremCreated": {"commit": "ec175b9008144d009269ce427b9ad43dbd70d0a5", "date": "2024-12-09"}, "file": "carleson/Carleson/ToMathlib/BoundedCompactSupport.lean", "module": "Carleson.ToMathlib.BoundedCompactSupport", "jsonFile": "Carleson.ToMathlib.BoundedCompactSupport.jsonl", "positionMetadata": {"lineInFile": 242, "tokenPositionInFile": 9033, "theoremPositionInFile": 14}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 3, "numPremises": 48}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  classical\n  induction s using Finset.induction with\n  | empty => simp [BoundedCompactSupport.zero]\n  | @insert j s hjs IH =>\n    simp_rw [Finset.sum_insert hjs]\n    apply BoundedCompactSupport.add\n    \u00b7 exact hF _ (Finset.mem_insert_self j s)\n    \u00b7 exact IH (fun i hi \u21a6 hF _ (Finset.mem_insert_of_mem hi))", "proofType": "tactic", "proofLengthLines": 8, "proofLengthTokens": 313}}
{"srcContext": "import Carleson.Discrete.Defs\nimport Carleson.ForestOperator.Forests\nimport Carleson.Discrete.SumEstimates\n\nopen MeasureTheory Measure NNReal Metric Complex Set\nopen scoped ENNReal\nopen Classical -- We use quite some `Finset.filter`\nnoncomputable section\n\nopen scoped ShortVariables\nvariable {X : Type*} {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102} {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X}\n  [MetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] [TileStructure Q D \u03ba S o]\n\nvariable {k n j l : \u2115} {p p' u u' : \ud835\udd13 X} {x : X}\n\n/-! ## Section 5.3 -/\n\n/-! Note: the lemmas 5.3.1-5.3.3 are in `TileStructure`. -/\n\n/-- Lemma 5.3.4 -/\nlemma ordConnected_tilesAt : OrdConnected (TilesAt k : Set (\ud835\udd13 X)) := by\n  rw [ordConnected_def]; intro p mp p'' mp'' p' mp'\n  simp_rw [TilesAt, mem_preimage, \ud835\udcd2, mem_diff, aux\ud835\udcd2, mem_setOf] at mp mp'' \u22a2\n  constructor\n  \u00b7 obtain \u27e8J, hJ, _\u27e9 := mp''.1\n    use J, mp'.2.1.trans hJ\n  \u00b7 push_neg at mp \u22a2\n    exact fun J hJ \u21a6 mp.2 J (mp'.1.1.trans hJ)\n\n/-- Lemma 5.3.5 -/\nlemma ordConnected_C : OrdConnected (\u212d k n : Set (\ud835\udd13 X)) := by\n  rw [ordConnected_def]; intro p mp p'' mp'' p' mp'\n  rw [\u212d, mem_setOf] at mp mp'' \u22a2\n  have z := mem_of_mem_of_subset mp' (ordConnected_tilesAt.out mp.1 mp''.1)\n  refine \u27e8z, ?_\u27e9\n  have hk : \u2200 q' \u2208 TilesAt (X := X) k, \u2200 q \u2264 q', dens' k {q'} \u2264 dens' k {q} := fun q' _ q hq \u21a6 by\n    simp_rw [dens', mem_singleton_iff, iSup_iSup_eq_left]; gcongr with l hl a _\n    exact iSup_const_mono fun h \u21a6\n      wiggle_order_11_10 hq (C5_3_3_le (X := X).trans (by norm_num) |>.trans hl) |>.trans h\n  exact \u27e8mp''.2.1.trans_le (hk _ mp''.1 _ mp'.2), (hk _ z _ mp'.1).trans mp.2.2\u27e9\n\n/-- Lemma 5.3.6 -/\nlemma ordConnected_C1 : OrdConnected (\u212d\u2081 k n j : Set (\ud835\udd13 X)) := by\n  rw [ordConnected_def]; intro p mp p'' mp'' p' mp'\n  have mp'\u2081 : p' \u2208 \u212d (X := X) k n := mem_of_mem_of_subset mp'\n    (ordConnected_C.out (mem_of_mem_of_subset mp \u212d\u2081_subset_\u212d)\n      (mem_of_mem_of_subset mp'' \u212d\u2081_subset_\u212d))\n  simp_rw [\u212d\u2081, mem_diff, pre\u212d\u2081, mem_setOf, not_and, not_le] at mp mp'' \u22a2\n  simp_rw [mp.1.1, true_and, true_implies] at mp\n  simp_rw [mp'\u2081, true_and, true_implies]\n  simp_rw [mp''.1.1, true_and, true_implies] at mp''\n  constructor\n  \u00b7 refine mp''.1.trans (Finset.card_le_card fun b mb \u21a6 ?_)\n    simp_rw [Finset.mem_filter, Finset.mem_univ, true_and, \ud835\udd05, mem_setOf] at mb \u22a2\n    have h100 := wiggle_order_11_10 (n := 100) mp'.2 (C5_3_3_le (X := X).trans (by norm_num))\n    exact \u27e8mb.1, h100.trans mb.2\u27e9\n  \u00b7 refine (Finset.card_le_card fun b mb \u21a6 ?_).trans_lt mp.2\n    simp_rw [Finset.mem_filter, Finset.mem_univ, true_and, \ud835\udd05, mem_setOf] at mb \u22a2\n    have h100 := wiggle_order_11_10 (n := 100) mp'.1 (C5_3_3_le (X := X).trans (by norm_num))\n    exact \u27e8mb.1, h100.trans mb.2\u27e9\n\n/-- Lemma 5.3.7 -/\nlemma ordConnected_C2 : OrdConnected (\u212d\u2082 k n j : Set (\ud835\udd13 X)) := by\n  rw [ordConnected_def]; intro p mp p'' mp'' p' mp'\n  have mp\u2081 := mem_of_mem_of_subset mp \u212d\u2082_subset_\u212d\u2081\n  have mp'\u2081 : p' \u2208 \u212d\u2081 (X := X) k n j := mem_of_mem_of_subset mp'\n    (ordConnected_C1.out mp\u2081 (mem_of_mem_of_subset mp'' \u212d\u2082_subset_\u212d\u2081))\n  by_cases e : p = p'; \u00b7 rwa [e] at mp\n  simp_rw [\u212d\u2082, layersAbove, mem_diff, mp'\u2081, true_and]\n  by_contra h; rw [mem_iUnion\u2082] at h; obtain \u27e8l', bl', p'm\u27e9 := h\n  rw [minLayer, mem_setOf, minimal_iff] at p'm\n  have pnm : p \u2209 \u22c3 l'', \u22c3 (_ : l'' < l'), \ud835\udd0f\u2081 k n j l'' := by\n    replace mp := mp.2; contrapose! mp\n    exact mem_of_mem_of_subset mp\n      (iUnion_mono'' fun i \u21a6 iUnion_subset_iUnion_const fun hi \u21a6 (hi.trans_le bl').le)\n  exact absurd (p'm.2 \u27e8mp.1, pnm\u27e9 mp'.1).symm e\n\n/-- Lemma 5.3.8 -/\nlemma ordConnected_C3 : OrdConnected (\u212d\u2083 k n j : Set (\ud835\udd13 X)) := by\n  rw [ordConnected_def]; intro p mp p'' mp'' p' mp'\n  have mp\u2081 := mem_of_mem_of_subset mp \u212d\u2083_subset_\u212d\u2082\n  have mp''\u2081 := mem_of_mem_of_subset mp'' \u212d\u2083_subset_\u212d\u2082\n  have mp'\u2081 : p' \u2208 \u212d\u2082 (X := X) k n j := mem_of_mem_of_subset mp' (ordConnected_C2.out mp\u2081 mp''\u2081)\n  rw [\u212d\u2083_def] at mp'' \u22a2\n  obtain \u27e8-, u, mu, \ud835\udcd8nu, su\u27e9 := mp''; refine \u27e8mp'\u2081, \u27e8u, mu, ?_\u27e9\u27e9\n  exact \u27e8(mp'.2.1.trans_lt (lt_of_le_of_ne su.1 \ud835\udcd8nu)).ne,\n    (wiggle_order_11_10 mp'.2 (C5_3_3_le (X := X).trans (by norm_num))).trans su\u27e9\n\n/-- Lemma 5.3.9 -/\nlemma ordConnected_C4 : OrdConnected (\u212d\u2084 k n j : Set (\ud835\udd13 X)) := by\n  rw [ordConnected_def]; intro p mp p'' mp'' p' mp'\n  have mp''\u2081 := mem_of_mem_of_subset mp'' \u212d\u2084_subset_\u212d\u2083\n  have mp'\u2081 : p' \u2208 \u212d\u2083 (X := X) k n j := mem_of_mem_of_subset mp'\n    (ordConnected_C3.out (mem_of_mem_of_subset mp \u212d\u2084_subset_\u212d\u2083) mp''\u2081)\n  by_cases e : p' = p''; \u00b7 rwa [\u2190 e] at mp''\n  simp_rw [\u212d\u2084, layersBelow, mem_diff, mp'\u2081, true_and]\n  by_contra h; simp_rw [mem_iUnion] at h; obtain \u27e8l', hl', p'm\u27e9 := h\n  rw [maxLayer_def, mem_setOf, maximal_iff] at p'm\n  simp_rw [mem_diff] at p'm\n  have p''nm : p'' \u2209 \u22c3 l'', \u22c3 (_ : l'' < l'), \ud835\udd0f\u2083 k n j l'' := by\n    replace mp'' := mp''.2; contrapose! mp''\n    refine mem_of_mem_of_subset mp'' <| iUnion\u2082_mono' fun i hi \u21a6 \u27e8i, hi.le.trans hl', subset_rfl\u27e9\n  exact absurd (p'm.2 \u27e8mp''\u2081, p''nm\u27e9 mp'.2) e\n\n/-- Lemma 5.3.10 -/\nlemma ordConnected_C5 : OrdConnected (\u212d\u2085 k n j : Set (\ud835\udd13 X)) := by\n  rw [ordConnected_def]; intro p mp p'' mp'' p' mp'\n  have mp\u2081 := mem_of_mem_of_subset mp \u212d\u2085_subset_\u212d\u2084\n  have mp'\u2081 : p' \u2208 \u212d\u2084 (X := X) k n j := mem_of_mem_of_subset mp'\n    (ordConnected_C4.out mp\u2081 (mem_of_mem_of_subset mp'' \u212d\u2085_subset_\u212d\u2084))\n  simp_rw [\u212d\u2085, mem_diff, mp\u2081, mp'\u2081, true_and, \ud835\udd0f\u2084, mem_setOf,\n    mp\u2081, mp'\u2081, true_and] at mp \u22a2\n  contrapose! mp; obtain \u27e8u, mu, s\ud835\udcd8u\u27e9 := mp; use u, mu, mp'.1.1.1.trans s\ud835\udcd8u\n\n/-! ## Section 5.4 and Lemma 5.1.2 -/\n\n/-- The subset `\u212d\u2086(k, n, j)` of `\u212d\u2085(k, n, j)`, given above (5.4.1). -/\ndef \u212d\u2086 (k n j : \u2115) : Set (\ud835\udd13 X) :=\n  { p \u2208 \u212d\u2085 k n j | \u00ac (\ud835\udcd8 p : Set X) \u2286 G' }\n\nlemma \u212d\u2086_subset_\u212d\u2085 : \u212d\u2086 (X := X) k n j \u2286 \u212d\u2085 k n j := sep_subset ..\nlemma \u212d\u2086_subset_\u212d : \u212d\u2086 (X := X) k n j \u2286 \u212d k n := \u212d\u2086_subset_\u212d\u2085.trans \u212d\u2085_subset_\u212d\n\n/-- The subset `\ud835\udd17\u2081(u)` of `\u212d\u2081(k, n, j)`, given in (5.4.1).\nIn lemmas, we will assume `u \u2208 \ud835\udd18\u2081 k n l` -/\ndef \ud835\udd17\u2081 (k n j : \u2115) (u : \ud835\udd13 X) : Set (\ud835\udd13 X) :=\n  { p \u2208 \u212d\u2081 k n j | \ud835\udcd8 p \u2260 \ud835\udcd8 u \u2227 smul 2 p \u2264 smul 1 u }\n\nlemma \ud835\udcd8_lt_of_mem_\ud835\udd17\u2081 (h : p \u2208 \ud835\udd17\u2081 k n j p') : \ud835\udcd8 p < \ud835\udcd8 p' := by\n  rw [\ud835\udd17\u2081, mem_setOf] at h; exact lt_of_le_of_ne h.2.2.1 h.2.1\n\n/-- The subset `\ud835\udd18\u2082(k, n, j)` of `\ud835\udd18\u2081(k, n, j)`, given in (5.4.2). -/\ndef \ud835\udd18\u2082 (k n j : \u2115) : Set (\ud835\udd13 X) :=\n  { u \u2208 \ud835\udd18\u2081 k n j | \u00ac Disjoint (\ud835\udd17\u2081 k n j u) (\u212d\u2086 k n j) }\n\nlemma \ud835\udd18\u2082_subset_\ud835\udd18\u2081 : \ud835\udd18\u2082 k n j \u2286 \ud835\udd18\u2081 (X := X) k n j := fun _ mu \u21a6 mu.1\n\n/-- The relation `\u223c` defined below (5.4.2). It is an equivalence relation on `\ud835\udd18\u2082 k n j`. -/\ndef URel (k n j : \u2115) (u u' : \ud835\udd13 X) : Prop :=\n  u = u' \u2228 \u2203 p \u2208 \ud835\udd17\u2081 k n j u, smul 10 p \u2264 smul 1 u'\n\nnonrec lemma URel.rfl : URel k n j u u := Or.inl rfl\n\n/-- Lemma 5.4.1, part 2. -/\nlemma URel.not_disjoint (hu : u \u2208 \ud835\udd18\u2082 k n j) (hu' : u' \u2208 \ud835\udd18\u2082 k n j) (huu' : URel k n j u u') :\n    \u00acDisjoint (ball_(u) (\ud835\udcac u) 100) (ball_(u') (\ud835\udcac u') 100) := by\n  by_cases e : u = u'; \u00b7 rw [e]; simp\n  simp_rw [URel, e, false_or, \ud835\udd17\u2081, mem_setOf] at huu'; obtain \u27e8p, \u27e8mp, np, sl\u2081\u27e9, sl\u2082\u27e9 := huu'\n  by_cases e' : \ud835\udcd8 p = \ud835\udcd8 u'\n  \u00b7 refine not_disjoint_iff.mpr \u27e8\ud835\udcac u, mem_ball_self (by positivity), ?_\u27e9\n    rw [@mem_ball]\n    have i1 : ball_{\ud835\udcd8 u} (\ud835\udcac u) 1 \u2286 ball_{\ud835\udcd8 p} (\ud835\udcac p) 2 := sl\u2081.2\n    have i2 : ball_{\ud835\udcd8 u'} (\ud835\udcac u') 1 \u2286 ball_{\ud835\udcd8 p} (\ud835\udcac p) 10 := sl\u2082.2\n    replace i1 : \ud835\udcac u \u2208 ball_{\ud835\udcd8 p} (\ud835\udcac p) 2 := i1 (mem_ball_self zero_lt_one)\n    replace i2 : \ud835\udcac u' \u2208 ball_{\ud835\udcd8 p} (\ud835\udcac p) 10 := i2 (mem_ball_self zero_lt_one)\n    rw [e', @mem_ball] at i1 i2\n    calc\n      _ \u2264 dist_{\ud835\udcd8 u'} (\ud835\udcac u) (\ud835\udcac p) + dist_{\ud835\udcd8 u'} (\ud835\udcac u') (\ud835\udcac p) := dist_triangle_right ..\n      _ < 2 + 10 := add_lt_add i1 i2\n      _ < 100 := by norm_num\n  have plu : smul 100 p \u2264 smul 100 u := wiggle_order_100 (smul_mono sl\u2081 le_rfl (by norm_num)) np\n  have plu' : smul 100 p \u2264 smul 100 u' := wiggle_order_100 sl\u2082 e'\n  by_contra h\n  have \ud835\udd05dj : Disjoint (\ud835\udd05 k n u) (\ud835\udd05 k n u') := by\n    simp_rw [\ud835\udd05, disjoint_left, mem_setOf, not_and]; intro q \u27e8_, sl\u27e9 _\n    simp_rw [TileLike.le_def, smul_fst, smul_snd, not_and_or] at sl \u22a2; right\n    have := disjoint_left.mp (h.mono_left sl.2) (mem_ball_self zero_lt_one)\n    rw [not_subset]; use \ud835\udcac q, mem_ball_self zero_lt_one\n  have usp : \ud835\udd05 k n u \u2286 \ud835\udd05 k n p := fun q mq \u21a6 by\n    rw [\ud835\udd05, mem_setOf] at mq \u22a2; exact \u27e8mq.1, plu.trans mq.2\u27e9\n  have u'sp : \ud835\udd05 k n u' \u2286 \ud835\udd05 k n p := fun q mq \u21a6 by\n    rw [\ud835\udd05, mem_setOf] at mq \u22a2; exact \u27e8mq.1, plu'.trans mq.2\u27e9\n  rw [\ud835\udd18\u2082, mem_setOf, \ud835\udd18\u2081, mem_setOf] at hu hu'\n  apply absurd (card_\ud835\udd05_of_mem_\u212d\u2081 mp).2; rw [not_lt]\n  calc\n    _ = 2 ^ j + 2 ^ j := Nat.two_pow_succ j\n    _ \u2264 (\ud835\udd05 k n u).toFinset.card + (\ud835\udd05 k n u').toFinset.card :=\n      add_le_add (card_\ud835\udd05_of_mem_\u212d\u2081 hu.1.1).1 (card_\ud835\udd05_of_mem_\u212d\u2081 hu'.1.1).1\n    _ = (\ud835\udd05 k n u \u222a \ud835\udd05 k n u').toFinset.card := by\n      rw [toFinset_union]; refine (Finset.card_union_of_disjoint ?_).symm\n      simpa using \ud835\udd05dj\n    _ \u2264 _ := by\n      apply Finset.card_le_card\n      simp_rw [toFinset_union, subset_toFinset, Finset.coe_union, coe_toFinset, union_subset_iff]\n      exact \u27e8usp, u'sp\u27e9\n\n/-- Lemma 5.4.1, part 1. -/\nlemma URel.eq (hu : u \u2208 \ud835\udd18\u2082 k n j) (hu' : u' \u2208 \ud835\udd18\u2082 k n j) (huu' : URel k n j u u') : \ud835\udcd8 u = \ud835\udcd8 u' := by\n  by_cases e : u = u'; \u00b7 rw [e]\n  have ndj := not_disjoint hu hu' huu'\n  have n\u2081 := (hu.1.2 _ hu'.1.1).mt ndj\n  rw [disjoint_comm] at ndj\n  have n\u2082 := (hu'.1.2 _ hu.1.1).mt ndj\n  simp_rw [URel, e, false_or, \ud835\udd17\u2081, mem_setOf] at huu'; obtain \u27e8p, \u27e8_, _, sl\u2081\u27e9, sl\u2082\u27e9 := huu'\n  rcases le_or_lt (\ud835\udd30 u) (\ud835\udd30 u') with h | h\n  \u00b7 exact eq_of_le_of_not_lt (Grid.le_dyadic h sl\u2081.1 sl\u2082.1) n\u2081\n  \u00b7 exact (eq_of_le_of_not_lt (Grid.le_dyadic h.le sl\u2082.1 sl\u2081.1) n\u2082).symm\n\n/-- Helper for 5.4.2 that is also used in 5.4.9. -/\nlemma urel_of_not_disjoint {x y : \ud835\udd13 X} (my : y \u2208 \ud835\udd18\u2082 k n j) (xye : \ud835\udcd8 x = \ud835\udcd8 y)\n    (nd : \u00acDisjoint (ball_(x) (\ud835\udcac x) 100) (ball_(y) (\ud835\udcac y) 100)) : URel k n j y x := by\n  rw [not_disjoint_iff] at nd\n  obtain \u27e8(\u03d1 : \u0398 X), (\u03d1x : \u03d1 \u2208 ball_{\ud835\udcd8 x} (\ud835\udcac x) 100), (\u03d1y : \u03d1 \u2208 ball_{\ud835\udcd8 y} (\ud835\udcac y) 100)\u27e9 := nd\n  rw [\ud835\udd18\u2082, mem_setOf, not_disjoint_iff] at my; obtain \u27e8p, hp, _\u27e9 := my.2\n  suffices w : ball_(x) (\ud835\udcac x) 1 \u2286 ball_(y) (\ud835\udcac y) 500 by\n    right; use p, hp; obtain \u27e8_, np, sl\u27e9 := hp\n    have hpy : smul 10 p \u2264 smul 500 y :=\n      (smul_mono_left (by norm_num)).trans (wiggle_order_500 sl np)\n    exact \u27e8(xye \u25b8 sl.1 : \ud835\udcd8 p \u2264 \ud835\udcd8 x), hpy.2.trans w\u27e9\n  intro (q : \u0398 X) (mq : q \u2208 ball_{\ud835\udcd8 x} (\ud835\udcac x) 1)\n  rw [@mem_ball] at mq \u22a2\n  calc\n    _ \u2264 dist_(y) q \u03d1 + dist_(y) \u03d1 (\ud835\udcac y) := dist_triangle ..\n    _ \u2264 dist_(y) q (\ud835\udcac x) + dist_(y) \u03d1 (\ud835\udcac x) + dist_(y) \u03d1 (\ud835\udcac y) := by\n      gcongr; apply dist_triangle_right\n    _ < 1 + 100 + 100 := by\n      gcongr\n      \u00b7 rwa [xye] at mq\n      \u00b7 rwa [@mem_ball, xye] at \u03d1x\n      \u00b7 rwa [@mem_ball] at \u03d1y\n    _ < _ := by norm_num\n\n/-- Lemma 5.4.2. -/\nlemma equivalenceOn_urel : EquivalenceOn (URel (X := X) k n j) (\ud835\udd18\u2082 k n j) where\n  refl _ _ := .rfl\n  trans {x y z} mx my mz xy yz := by\n    by_cases xny : x = y; \u00b7 rwa [xny]\n    have xye := URel.eq mx my xy\n    have hxy := URel.not_disjoint mx my xy\n    rw [not_disjoint_iff] at hxy\n    obtain \u27e8(\u03d1 : \u0398 X), (\u03d1x : \u03d1 \u2208 ball_{\ud835\udcd8 x} (\ud835\udcac x) 100), (\u03d1y : \u03d1 \u2208 ball_{\ud835\udcd8 y} (\ud835\udcac y) 100)\u27e9 := hxy\n    have yze := URel.eq my mz yz\n    have hyz := URel.not_disjoint my mz yz\n    rw [not_disjoint_iff] at hyz\n    obtain \u27e8(\u03b8 : \u0398 X), (\u03b8y : \u03b8 \u2208 ball_{\ud835\udcd8 y} (\ud835\udcac y) 100), (\u03b8z : \u03b8 \u2208 ball_{\ud835\udcd8 z} (\ud835\udcac z) 100)\u27e9 := hyz\n    simp_rw [URel, xny, false_or] at xy; obtain \u27e8p, mp, sp\u27e9 := xy\n    suffices ball_(z) (\ud835\udcac z) 1 \u2286 ball_(x) (\ud835\udcac x) 500 by\n      right; use p, mp; obtain \u27e8_, np, sl\u27e9 := mp\n      have w : ball_(x) (\ud835\udcac x) 500 \u2286 ball_(p) (\ud835\udcac p) 4 := (wiggle_order_500 sl np).2\n      exact \u27e8(yze \u25b8 xye \u25b8 sl.1 : \ud835\udcd8 p \u2264 \ud835\udcd8 z), (this.trans w).trans (ball_subset_ball (by norm_num))\u27e9\n    intro (q : \u0398 X) (mq : q \u2208 ball_{\ud835\udcd8 z} (\ud835\udcac z) 1)\n    rw [@mem_ball] at mq \u22a2\n    calc\n      _ \u2264 dist_(x) q \u03d1 + dist_(x) \u03d1 (\ud835\udcac x) := dist_triangle ..\n      _ < dist_(x) q \u03d1 + 100 := by gcongr; rwa [@mem_ball] at \u03d1x\n      _ \u2264 dist_(x) q (\ud835\udcac y) + dist_(x) \u03d1 (\ud835\udcac y) + 100 := by gcongr; exact dist_triangle_right ..\n      _ < dist_(x) q (\ud835\udcac y) + 100 + 100 := by gcongr; rwa [@mem_ball, \u2190 xye] at \u03d1y\n      _ \u2264 dist_(x) q \u03b8 + dist_(x) \u03b8 (\ud835\udcac y) + 100 + 100 := by gcongr; exact dist_triangle ..\n      _ < dist_(x) q \u03b8 + 100 + 100 + 100 := by gcongr; rwa [@mem_ball, \u2190 xye] at \u03b8y\n      _ \u2264 dist_(x) q (\ud835\udcac z) + dist_(x) \u03b8 (\ud835\udcac z) + 100 + 100 + 100 := by\n        gcongr; exact dist_triangle_right ..\n      _ < 1 + 100 + 100 + 100 + 100 := by\n        gcongr\n        \u00b7 rwa [\u2190 yze, \u2190 xye] at mq\n        \u00b7 rwa [@mem_ball, \u2190 yze, \u2190 xye] at \u03b8z\n      _ < _ := by norm_num\n  symm {x y} mx my xy := urel_of_not_disjoint my (URel.eq mx my xy) (URel.not_disjoint mx my xy)\n\n/-- `\ud835\udd18\u2083(k, n, j) \u2286 \ud835\udd18\u2082 k n j` is an arbitary set of representatives of `URel` on `\ud835\udd18\u2082 k n j`,\ngiven above (5.4.5). -/\ndef \ud835\udd18\u2083 (k n j : \u2115) : Set (\ud835\udd13 X) :=\n  (equivalenceOn_urel (k := k) (n := n) (j := j)).reprs\n\nlemma \ud835\udd18\u2083_subset_\ud835\udd18\u2082 : \ud835\udd18\u2083 k n j \u2286 \ud835\udd18\u2082 (X := X) k n j := EquivalenceOn.reprs_subset\n\n/-- The subset `\ud835\udd17\u2082(u)` of `\u212d\u2086(k, n, j)`, given in (5.4.5).\nIn lemmas, we will assume `u \u2208 \ud835\udd18\u2083 k n l` -/\ndef \ud835\udd17\u2082 (k n j : \u2115) (u : \ud835\udd13 X) : Set (\ud835\udd13 X) :=\n  \u212d\u2086 k n j \u2229 \u22c3 (u' \u2208 \ud835\udd18\u2082 k n j) (_ : URel k n j u u'), \ud835\udd17\u2081 k n j u'\n\nlemma \ud835\udd17\u2082_subset_\u212d\u2086 : \ud835\udd17\u2082 k n j u \u2286 \u212d\u2086 k n j := inter_subset_left ..\n\n/-- Lemma 5.4.3 -/\nlemma C6_forest : \u212d\u2086 (X := X) k n j = \u22c3 u \u2208 \ud835\udd18\u2083 k n j, \ud835\udd17\u2082 k n j u := by\n  ext p; constructor <;> intro h\n  \u00b7 have hp : p \u2208 \u212d\u2083 k n j := (\u212d\u2086_subset_\u212d\u2085 |>.trans \u212d\u2085_subset_\u212d\u2084 |>.trans \u212d\u2084_subset_\u212d\u2083) h\n    rw [\u212d\u2083, mem_diff, \ud835\udd0f\u2082, mem_setOf] at hp\n    have mp := hp.1\n    simp_rw [hp.1, true_and, not_not] at hp\n    obtain \u27e8u, mu, np, sl\u27e9 := hp\n    have mp' : p \u2208 \ud835\udd17\u2081 k n j u := by\n      rw [\ud835\udd17\u2081, mem_setOf]; exact \u27e8\u212d\u2082_subset_\u212d\u2081 mp, np, sl\u27e9\n    have mu' : u \u2208 \ud835\udd18\u2082 k n j := by\n      rw [\ud835\udd18\u2082, mem_setOf]; exact \u27e8mu, not_disjoint_iff.mpr \u27e8_, mp', h\u27e9\u27e9\n    let rr := equivalenceOn_urel (X := X) (k := k) (n := n) (j := j)\n    rw [mem_iUnion\u2082]; use rr.out u, (rr.out_mem_reprs mu')\n    refine \u27e8h, ?_\u27e9; rw [mem_iUnion\u2082]; use u, mu'; rw [mem_iUnion]; use rr.out_rel mu'\n  \u00b7 rw [mem_iUnion\u2082] at h; obtain \u27e8_, _, mp, _\u27e9 := h; exact mp\n\n/-- This one could deserve a lemma in the blueprint, as it is needed to decompose the sum\nof Carleson operators over disjoint subfamilies. -/\nlemma forest_disjoint : (\ud835\udd18\u2083 k n j).PairwiseDisjoint (fun u \u21a6 \ud835\udd17\u2082 (X := X) k n j u) := by\n  intro u hu u' hu' huu'\n  simp only [Function.onFun]\n  apply disjoint_left.2 (fun p pu pu' \u21a6 huu' ?_)\n  simp only [\ud835\udd17\u2082, mem_inter_iff, mem_iUnion, exists_prop, exists_and_left] at pu pu'\n  rcases pu.2 with \u27e8v, v_mem, v_rel, pv\u27e9\n  rcases pu'.2 with \u27e8v', v'_mem, v'_rel, pv'\u27e9\n  have E : URel k n j v v' :=\n    Or.inr \u27e8p, pv, smul_mono pv'.2.2 le_rfl (by norm_num)\u27e9\n  have : URel k n j u v' :=\n    (equivalenceOn_urel (X := X)).trans (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 hu) v_mem v'_mem v_rel E\n  have : URel k n j u u' := by\n    apply (equivalenceOn_urel (X := X)).trans (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 hu) v'_mem (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 hu') this\n    exact (equivalenceOn_urel (X := X)).symm (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 hu') v'_mem v'_rel\n  exact (equivalenceOn_urel (X := X)).reprs_inj hu hu' this\n\n/-- Lemma 5.4.4, verifying (2.0.32) -/\nlemma forest_geometry (hu : u \u2208 \ud835\udd18\u2083 k n j) (hp : p \u2208 \ud835\udd17\u2082 k n j u) : smul 4 p \u2264 smul 1 u := by\n  rw [\ud835\udd17\u2082, mem_inter_iff, mem_iUnion\u2082] at hp\n  obtain \u27e8_, u', mu', w\u27e9 := hp; rw [mem_iUnion] at w; obtain \u27e8ru, mp'\u27e9 := w\n  rw [\ud835\udd17\u2081, mem_setOf] at mp'; obtain \u27e8_, np, sl\u27e9 := mp'\n  have xye := URel.eq (EquivalenceOn.reprs_subset hu) mu' ru\n  have huu' := URel.not_disjoint (EquivalenceOn.reprs_subset hu) mu' ru\n  rw [not_disjoint_iff] at huu'\n  obtain \u27e8(\u03d1 : \u0398 X), (\u03d1x : \u03d1 \u2208 ball_{\ud835\udcd8 u} (\ud835\udcac u) 100), (\u03d1y : \u03d1 \u2208 ball_{\ud835\udcd8 u'} (\ud835\udcac u') 100)\u27e9 := huu'\n  suffices ball_(u) (\ud835\udcac u) 1 \u2286 ball_(u') (\ud835\udcac u') 500 by\n    have w : smul 4 p \u2264 smul 500 u' := (wiggle_order_500 sl np)\n    exact \u27e8(xye \u25b8 sl.1 : \ud835\udcd8 p \u2264 \ud835\udcd8 u), w.2.trans this\u27e9\n  intro (q : \u0398 X) (mq : q \u2208 ball_{\ud835\udcd8 u} (\ud835\udcac u) 1)\n  rw [@mem_ball] at mq \u22a2\n  calc\n    _ \u2264 dist_(u') q \u03d1 + dist_(u') \u03d1 (\ud835\udcac u') := dist_triangle ..\n    _ \u2264 dist_(u') q (\ud835\udcac u) + dist_(u') \u03d1 (\ud835\udcac u) + dist_(u') \u03d1 (\ud835\udcac u') := by\n      gcongr; apply dist_triangle_right\n    _ < 1 + 100 + 100 := by\n      gcongr\n      \u00b7 rwa [xye] at mq\n      \u00b7 rwa [@mem_ball, xye] at \u03d1x\n      \u00b7 rwa [@mem_ball] at \u03d1y\n    _ < _ := by norm_num\n\n/-- Lemma 5.4.5, verifying (2.0.33) -/\nlemma forest_convex : OrdConnected (\ud835\udd17\u2082 k n j u) := by\n  rw [ordConnected_def]; intro p mp p'' mp'' p' mp'\n  have mp'\u2085 : p' \u2208 \u212d\u2085 (X := X) k n j :=\n    (ordConnected_C5.out ((\ud835\udd17\u2082_subset_\u212d\u2086.trans \u212d\u2086_subset_\u212d\u2085) mp)\n      ((\ud835\udd17\u2082_subset_\u212d\u2086.trans \u212d\u2086_subset_\u212d\u2085) mp'')) mp'\n  have mp'\u2086 : p' \u2208 \u212d\u2086 k n j := by\n    have hp := \ud835\udd17\u2082_subset_\u212d\u2086 mp; rw [\u212d\u2086, mem_setOf] at hp \u22a2\n    refine \u27e8mp'\u2085, ?_\u27e9; have hpG := hp.2; contrapose! hpG\n    exact mp'.1.1.1.trans hpG\n  simp_rw [\ud835\udd17\u2082, mem_inter_iff, mp'\u2086, true_and, mem_iUnion\u2082, mem_iUnion] at mp'' \u22a2\n  obtain \u27e8u', mu', ru, _, np'', sl\u27e9 := mp''.2\n  have pnu : \ud835\udcd8 p' < \ud835\udcd8 u' := (mp'.2.1).trans_lt (lt_of_le_of_ne sl.1 np'')\n  use u', mu', ru; rw [\ud835\udd17\u2081, mem_setOf]\n  use (\u212d\u2085_subset_\u212d\u2084 |>.trans \u212d\u2084_subset_\u212d\u2083 |>.trans \u212d\u2083_subset_\u212d\u2082 |>.trans \u212d\u2082_subset_\u212d\u2081) mp'\u2085, pnu.ne\n  exact (wiggle_order_11_10 mp'.2 (C5_3_3_le (X := X).trans (by norm_num))).trans sl\n\n/-- Lemma 5.4.6, verifying (2.0.36)\nNote: swapped `u` and `u'` to match (2.0.36) -/\nlemma forest_separation (hu : u \u2208 \ud835\udd18\u2083 k n j) (hu' : u' \u2208 \ud835\udd18\u2083 k n j) (huu' : u \u2260 u')\n    (hp : p \u2208 \ud835\udd17\u2082 k n j u') (h : \ud835\udcd8 p \u2264 \ud835\udcd8 u) : 2 ^ (Z * (n + 1)) < dist_(p) (\ud835\udcac p) (\ud835\udcac u) := by\n  simp_rw [\ud835\udd17\u2082, mem_inter_iff, mem_iUnion\u2082, mem_iUnion] at hp\n  obtain \u27e8mp\u2086, v, mv, rv, \u27e8-, np, sl\u27e9\u27e9 := hp\n  obtain \u27e8p', mp', lp', sp'\u27e9 := exists_scale_add_le_of_mem_layersAbove <|\n    (\u212d\u2086_subset_\u212d\u2085 |>.trans \u212d\u2085_subset_\u212d\u2084 |>.trans \u212d\u2084_subset_\u212d\u2083 |>.trans \u212d\u2083_subset_\u212d\u2082) mp\u2086\n  have np'u : \u00acURel k n j v u := by\n    by_contra h; apply absurd (Eq.symm _) huu'\n    replace h := equivalenceOn_urel.trans (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 hu') mv (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 hu) rv h\n    exact EquivalenceOn.reprs_inj hu' hu h\n  have vnu : v \u2260 u := by by_contra h; subst h; exact absurd URel.rfl np'u\n  simp_rw [URel, vnu, false_or, not_exists, not_and] at np'u\n  have mpt : p' \u2208 \ud835\udd17\u2081 k n j v := by\n    refine \u27e8minLayer_subset mp', ?_, ?_\u27e9\n    \u00b7 exact (lp'.1.trans_lt (lt_of_le_of_ne sl.1 np)).ne\n    \u00b7 exact (wiggle_order_11_10 lp' (C5_3_3_le (X := X).trans (by norm_num))).trans sl\n  specialize np'u p' mpt\n  have \ud835\udcd8p'u : \ud835\udcd8 p' \u2264 \ud835\udcd8 u := lp'.1.trans h\n  simp_rw [TileLike.le_def, smul_fst, smul_snd, \ud835\udcd8p'u, true_and,\n    not_subset_iff_exists_mem_not_mem] at np'u\n  obtain \u27e8(q : \u0398 X), mq, nq\u27e9 := np'u\n  simp_rw [mem_ball, not_lt] at mq nq\n  have d8 : 8 < dist_(p') (\ud835\udcac p) (\ud835\udcac u) :=\n    calc\n      _ = 10 - 1 - 1 := by norm_num\n      _ < 10 - 1 - dist_(u) q (\ud835\udcac u) := by gcongr\n      _ \u2264 10 - 1 - dist_(p') q (\ud835\udcac u) := tsub_le_tsub_left (Grid.dist_mono \ud835\udcd8p'u) _\n      _ \u2264 dist_(p') q (\ud835\udcac p') - 1 - dist_(p') q (\ud835\udcac u) := by gcongr\n      _ < dist_(p') q (\ud835\udcac p') - dist_(p') (\ud835\udcac p) (\ud835\udcac p') - dist_(p') q (\ud835\udcac u) := by\n        gcongr; rw [\u2190 @mem_ball]; exact subset_cball (lp'.2 \ud835\udcac_mem_\u03a9)\n      _ \u2264 _ := by\n        rw [sub_le_iff_le_add', sub_le_iff_le_add]\n        nth_rw 3 [dist_comm]; apply dist_triangle4\n  have Znpos : 0 < Z * (n + 1) := by rw [defaultZ]; positivity\n  let d : \u2115 := (\ud835\udd30 p - \ud835\udd30 p').toNat\n  have sd : \ud835\udd30 p' + d = \ud835\udd30 p := by simp_rw [d]; rw [Int.toNat_sub_of_le] <;> omega\n  have d1 : dist_(p') (\ud835\udcac p) (\ud835\udcac u) \u2264 C2_1_2 a ^ d * dist_(p) (\ud835\udcac p) (\ud835\udcac u) :=\n    Grid.dist_strictMono_iterate lp'.1 sd\n  have Cdpos : 0 < C2_1_2 a ^ d := by rw [C2_1_2]; positivity\n  have Cidpos : 0 < (C2_1_2 a)\u207b\u00b9 ^ d := by rw [C2_1_2]; positivity\n  calc\n    _ \u2264 (C2_1_2 a)\u207b\u00b9 ^ (Z * (n + 1)) := by\n      refine pow_le_pow_left\u2080 zero_le_two ?_ _\n      nth_rw 1 [C2_1_2, \u2190 Real.inv_rpow zero_le_two, \u2190 Real.rpow_neg_one,\n        \u2190 Real.rpow_mul zero_le_two, neg_one_mul, neg_mul, neg_neg, \u2190 Real.rpow_one 2]\n      apply Real.rpow_le_rpow_of_exponent_le one_le_two\n      norm_cast; linarith [four_le_a X]\n    _ \u2264 (C2_1_2 a)\u207b\u00b9 ^ d := by\n      refine pow_le_pow_right\u2080 ?_ (by omega)\n      simp_rw [one_le_inv_iff\u2080, C2_1_2_le_one (X := X), and_true, C2_1_2]; positivity\n    _ \u2264 (C2_1_2 a)\u207b\u00b9 ^ d * 8 := by nth_rw 1 [\u2190 mul_one (_ ^ d)]; gcongr; norm_num\n    _ < (C2_1_2 a)\u207b\u00b9 ^ d * dist_(p') (\ud835\udcac p) (\ud835\udcac u) := by gcongr\n    _ \u2264 _ := by\n      rwa [\u2190 mul_le_mul_iff_of_pos_left Cdpos, inv_pow, \u2190 mul_assoc, mul_inv_cancel\u2080 Cdpos.ne',\n        one_mul]\n\n/-- Lemma 5.4.7, verifying (2.0.37) -/\nlemma forest_inner (hu : u \u2208 \ud835\udd18\u2083 k n j) (hp : p \u2208 \ud835\udd17\u2082 k n j u) :\n    ball (\ud835\udd20 p) (8 * D ^ \ud835\udd30 p) \u2286 \ud835\udcd8 u := by\n  have p\u2084 := (\ud835\udd17\u2082_subset_\u212d\u2086.trans \u212d\u2086_subset_\u212d\u2085 |>.trans \u212d\u2085_subset_\u212d\u2084) hp\n  have p\u2081 := (\u212d\u2084_subset_\u212d\u2083.trans \u212d\u2083_subset_\u212d\u2082 |>.trans \u212d\u2082_subset_\u212d\u2081) p\u2084\n  obtain \u27e8q, mq, lq, sq\u27e9 := exists_le_add_scale_of_mem_layersBelow p\u2084\n  obtain \u27e8-, u'', mu'', nu'', sl\u27e9 := \u212d\u2083_def.mp (maxLayer_subset mq)\n  replace nu'' : \ud835\udcd8 q < \ud835\udcd8 u'' := lt_of_le_of_ne sl.1 nu''\n  have s2 : smul 2 p \u2264 smul 2 q := wiggle_order_11_10 lq (C5_3_3_le (X := X).trans (by norm_num))\n  have s2' : smul 2 p \u2264 smul 1 u'' := s2.trans sl\n  have s10 : smul 10 p \u2264 smul 1 u'' := smul_mono s2' le_rfl (by norm_num)\n  simp_rw [\ud835\udd17\u2082, mem_inter_iff, mem_iUnion\u2082, mem_iUnion] at hp\n  obtain \u27e8p\u2086, u', mu', ru', pu'\u27e9 := hp\n  have ur : URel k n j u' u'' := Or.inr \u27e8p, pu', s10\u27e9\n  have hu'' : u'' \u2208 \ud835\udd18\u2082 k n j := by\n    rw [\ud835\udd18\u2082, mem_setOf, not_disjoint_iff]\n    refine \u27e8mu'', \u27e8p, ?_, p\u2086\u27e9\u27e9\n    simpa [\ud835\udd17\u2081, p\u2081, s2'] using (lq.1.trans_lt nu'').ne\n  have ru'' : URel k n j u u'' := equivalenceOn_urel.trans (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 hu) mu' hu'' ru' ur\n  have qlu : \ud835\udcd8 q < \ud835\udcd8 u := URel.eq (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 hu) hu'' ru'' \u25b8 nu''\n  have squ : \ud835\udd30 q < \ud835\udd30 u := (Grid.lt_def.mp qlu).2\n  have spu : \ud835\udd30 p \u2264 \ud835\udd30 u - (Z * (n + 1) : \u2115) - 1 := by omega\n  have \u27e8I, sI, plI, Ilu\u27e9 : \u2203 I, s I = \ud835\udd30 u - (Z * (n + 1) : \u2115) - 1 \u2227 \ud835\udcd8 p \u2264 I \u2227 I \u2264 \ud835\udcd8 u := by\n    apply Grid.exists_sandwiched (lq.1.trans qlu.le) (\ud835\udd30 u - (Z * (n + 1) : \u2115) - 1)\n    refine \u27e8spu, ?_\u27e9\n    change _ \u2264 \ud835\udd30 u\n    omega\n  have bI : I \u2209 \ud835\udcdb n u := by\n    have p\u2085 := \u212d\u2086_subset_\u212d\u2085 p\u2086\n    rw [\u212d\u2085_def] at p\u2085; replace p\u2085 := p\u2085.2; contrapose! p\u2085\n    use u, (\ud835\udd18\u2083_subset_\ud835\udd18\u2082.trans \ud835\udd18\u2082_subset_\ud835\udd18\u2081) hu, plI.1.trans (subset_biUnion_of_mem p\u2085)\n  rw [\ud835\udcdb, mem_setOf, not_and] at bI; specialize bI Ilu\n  rw [not_and, not_not] at bI; specialize bI (by omega); rw [\u2190 sI] at spu\n  rcases spu.eq_or_lt with h | h\n  \u00b7 have hI : \ud835\udcd8 p = I := by\n      apply eq_of_le_of_not_lt plI; rw [Grid.lt_def, not_and_or, not_lt]; exact Or.inr h.symm.le\n    rwa [\u2190 hI] at bI\n  \u00b7 apply subset_trans (ball_subset_ball' _) bI\n    have ds : c (\ud835\udcd8 p) \u2208 ball (c I) (4 * D ^ s I) := (plI.1.trans Grid_subset_ball) Grid.c_mem_Grid\n    rw [mem_ball] at ds\n    calc\n      _ \u2264 4 * D * (D : \u211d) ^ \ud835\udd30 p + 4 * D ^ s I := by\n        gcongr\n        \u00b7 linarith [four_le_realD X]\n        \u00b7 exact ds.le\n      _ = 4 * D ^ (\ud835\udd30 p + 1) + 4 * D ^ s I := by\n        rw [mul_assoc]; congr; rw [mul_comm, \u2190 zpow_add_one\u2080 (defaultD_pos _).ne']\n      _ \u2264 4 * D ^ s I + 4 * D ^ s I := by\n        gcongr\n        \u00b7 exact one_le_D\n        \u00b7 omega\n      _ = _ := by ring\n\n/-- The multiplicity appearing in Lemma 5.4.8. -/\ndef C5_4_8 (n : \u2115) : \u2115 := (4 * n + 12) * 2 ^ n\n\nlemma exists_smul_le_of_\ud835\udd18\u2083 (u : \ud835\udd18\u2083 k n j) : \u2203 m : \ud835\udd10 (X := X) k n, smul 100 u.1 \u2264 smul 1 m.1 := by\n  obtain \u27e8u, mu\u27e9 := u\n  replace mu := (\ud835\udd18\u2083_subset_\ud835\udd18\u2082.trans \ud835\udd18\u2082_subset_\ud835\udd18\u2081 |>.trans \ud835\udd18\u2081_subset_\u212d\u2081) mu\n  rw [\u212d\u2081, mem_diff, pre\u212d\u2081, mem_setOf, filter_mem_univ_eq_toFinset] at mu\n  replace mu := (show 0 < 2 ^ j by positivity).trans_le mu.1.2\n  rw [Finset.card_pos] at mu; obtain \u27e8m, hm\u27e9 := mu\n  rw [mem_toFinset, \ud835\udd05] at hm; exact \u27e8\u27e8m, hm.1\u27e9, hm.2\u27e9\n\nvariable (k n j) in\n/-- The good choice of an element to get a contradiction in the proof of Lemma 5.4.8. -/\ndef mf (u : \ud835\udd18\u2083 (X := X) k n j) : \ud835\udd10 (X := X) k n := (exists_smul_le_of_\ud835\udd18\u2083 u).choose\n\nlemma mf_injOn : InjOn (mf k n j) {u | x \u2208 \ud835\udcd8 u.1} := fun u mu u' mu' e \u21a6 by\n  set m := mf k n j u\n  have iu : smul 100 u.1 \u2264 smul 1 m.1 := (exists_smul_le_of_\ud835\udd18\u2083 u).choose_spec\n  have iu' : smul 100 u'.1 \u2264 smul 1 m.1 := e \u25b8 (exists_smul_le_of_\ud835\udd18\u2083 u').choose_spec\n  have su : ball_{\ud835\udcd8 m.1} (\ud835\udcac m.1) 1 \u2286 ball_{\ud835\udcd8 u.1} (\ud835\udcac u.1) 100 := iu.2\n  have su' : ball_{\ud835\udcd8 m.1} (\ud835\udcac m.1) 1 \u2286 ball_{\ud835\udcd8 u'.1} (\ud835\udcac u'.1) 100 := iu'.2\n  have nd : \u00acDisjoint (ball_{\ud835\udcd8 u.1} (\ud835\udcac u.1) 100) (ball_{\ud835\udcd8 u'.1} (\ud835\udcac u'.1) 100) := by\n    rw [not_disjoint_iff]\n    use \ud835\udcac m.1, su (mem_ball_self zero_lt_one), su' (mem_ball_self zero_lt_one)\n  by_contra! h; rw [\u2190 Subtype.coe_ne_coe] at h; apply absurd _ nd\n  have nr : \u00acURel k n j u.1 u'.1 := by contrapose! h; exact EquivalenceOn.reprs_inj u.2 u'.2 h\n  have n\ud835\udcd8 : \ud835\udcd8 u.1 \u2260 \ud835\udcd8 u'.1 := by\n    contrapose! nr; rw [disjoint_comm] at nd\n    exact urel_of_not_disjoint (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 u.2) nr.symm nd\n  rcases le_or_lt (s (\ud835\udcd8 u.1)) (s (\ud835\udcd8 u'.1)) with hs | hs\n  \u00b7 have hu := lt_of_le_of_ne ((le_or_disjoint hs).resolve_right\n      (not_disjoint_iff.mpr \u27e8_, mu, mu'\u27e9)) n\ud835\udcd8\n    have u\u2081 := (\ud835\udd18\u2083_subset_\ud835\udd18\u2082.trans \ud835\udd18\u2082_subset_\ud835\udd18\u2081) u.2\n    exact u\u2081.2 u' ((\ud835\udd18\u2083_subset_\ud835\udd18\u2082.trans \ud835\udd18\u2082_subset_\ud835\udd18\u2081 |>.trans \ud835\udd18\u2081_subset_\u212d\u2081) u'.2) hu\n  \u00b7 have hu := lt_of_le_of_ne ((le_or_disjoint hs.le).resolve_right\n      (not_disjoint_iff.mpr \u27e8_, mu', mu\u27e9)) n\ud835\udcd8.symm\n    have u'\u2081 := (\ud835\udd18\u2083_subset_\ud835\udd18\u2082.trans \ud835\udd18\u2082_subset_\ud835\udd18\u2081) u'.2\n    exact (u'\u2081.2 u ((\ud835\udd18\u2083_subset_\ud835\udd18\u2082.trans \ud835\udd18\u2082_subset_\ud835\udd18\u2081 |>.trans \ud835\udd18\u2081_subset_\u212d\u2081) u.2) hu).symm\n\nlemma stackSize_\ud835\udd18\u2083_le_\ud835\udd10 (x : X) : stackSize (\ud835\udd18\u2083 k n j) x \u2264 stackSize (\ud835\udd10 k n) x := by\n  let mf' : \ud835\udd13 X \u2192 \ud835\udd13 X := fun u \u21a6 if mu : u \u2208 \ud835\udd18\u2083 k n j then mf k n j \u27e8u, mu\u27e9 else default\n  simp_rw [stackSize, indicator_apply, Pi.one_apply, Finset.sum_boole, Nat.cast_id]\n  refine Finset.card_le_card_of_injOn mf' (fun u mu \u21a6 ?_) (fun u mu u' mu' e \u21a6 ?_)\n  \u00b7 simp_rw [Finset.mem_filter, Finset.mem_univ, true_and] at mu \u22a2\n    simp_rw [mf', mu.1, dite_true]\n    have hu : \ud835\udcd8 u \u2264 \ud835\udcd8 (mf k n j \u27e8u, mu.1\u27e9) := (exists_smul_le_of_\ud835\udd18\u2083 \u27e8u, mu.1\u27e9).choose_spec.1\n    exact \u27e8(mf k n j \u27e8u, mu.1\u27e9).2, hu.1 mu.2\u27e9\n  \u00b7 simp_rw [Finset.coe_filter, mem_setOf, Finset.mem_filter, Finset.mem_univ, true_and] at mu mu'\n    simp_rw [mf', mu.1, mu'.1, dite_true, Subtype.val_inj] at e\n    simpa using mf_injOn mu.2 mu'.2 e\n\n/-- Lemma 5.4.8, used to verify that \ud835\udd18\u2084 satisfies 2.0.34. -/\nlemma forest_stacking (x : X) (hkn : k \u2264 n) : stackSize (\ud835\udd18\u2083 (X := X) k n j) x \u2264 C5_4_8 n := by\n  by_contra! h\n  let C : Finset (\ud835\udd13 X) := { u | u \u2208 \ud835\udd18\u2083 (X := X) k n j \u2227 x \u2208 \ud835\udcd8 u }\n  have Cc : C.card = stackSize (\ud835\udd18\u2083 k n j) x := by\n    simp_rw [stackSize, indicator_apply, Pi.one_apply, Finset.sum_boole, Nat.cast_id,\n      C, Grid.mem_def, Finset.filter_filter]\n  have Cn : C.Nonempty := by\n    by_contra! Ce; rw [Finset.not_nonempty_iff_eq_empty] at Ce\n    simp_rw [\u2190 Cc, Ce, Finset.card_empty, not_lt_zero'] at h\n  let C' : Finset (Grid X) := C.image \ud835\udcd8\n  have C'n : C'.Nonempty := by rwa [Finset.image_nonempty]\n  obtain \u27e8i, mi, li\u27e9 := C'.exists_minimal C'n\n  simp_rw [C', Finset.mem_image, C, Finset.mem_filter, Finset.mem_univ, true_and] at mi\n  obtain \u27e8u, \u27e8mu, mx\u27e9, uei\u27e9 := mi; subst uei\n  have uA : (\ud835\udcd8 u : Set X) \u2286 setA (2 * n + 6) k n := fun y my \u21a6\n    calc\n      _ = (4 * n + 12) * 2 ^ n := by ring\n      _ < stackSize (\ud835\udd18\u2083 k n j) x := h\n      _ \u2264 stackSize (\ud835\udd18\u2083 k n j) y := by\n        simp_rw [stackSize, indicator_apply, Pi.one_apply, Finset.sum_boole, Nat.cast_id]\n        apply Finset.card_le_card fun v mv \u21a6 ?_\n        simp_rw [Finset.mem_filter, Finset.mem_univ, true_and] at mv \u22a2\n        have mvC' : \ud835\udcd8 v \u2208 C' := by\n          simp_rw [C', Finset.mem_image]; use v\n          simp_rw [C, Finset.mem_filter, Finset.mem_univ, true_and, and_true]; exact mv\n        specialize li _ mvC'\n        have inc := (or_assoc.mpr (le_or_ge_or_disjoint (i := \ud835\udcd8 u) (j := \ud835\udcd8 v))).resolve_right\n          (not_disjoint_iff.mpr \u27e8_, mx, mv.2\u27e9)\n        simp_rw [le_iff_eq_or_lt] at inc\n        replace inc : \ud835\udcd8 u = \ud835\udcd8 v \u2228 \ud835\udcd8 u < \ud835\udcd8 v := by tauto\n        rw [\u2190 le_iff_eq_or_lt] at inc\n        exact \u27e8mv.1, inc.1 my\u27e9\n      _ \u2264 _ := stackSize_\ud835\udd18\u2083_le_\ud835\udd10 _\n  refine absurd (disjoint_left.mpr fun v mv \u21a6 ?_) (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 mu).2\n  rw [\ud835\udd17\u2081, mem_setOf] at mv; rw [\u212d\u2086, mem_setOf, not_and, not_not]\n  refine fun _ \u21a6 (mv.2.2.1).1.trans ?_\n  calc\n    _ \u2286 setA (2 * n + 6) k n := uA\n    _ \u2286 G\u2082 := subset_iUnion\u2082_of_subset n k (subset_iUnion_of_subset hkn subset_rfl)\n    _ \u2286 _ := subset_union_of_subset_left subset_union_right G\u2083\n\n/-- Define `\ud835\udd18\u2084 k n j l` as the union of `2 ^ n` disjoint subfamilies in `\ud835\udd18\u2083 k n j`, to make sure\nthe multiplicity is at most `2 ^ n` to get a forest. -/\ndef \ud835\udd18\u2084 (k n j l : \u2115) : Set (\ud835\udd13 X) :=\n  \u22c3 i \u2208 Ico (l * 2 ^ n) ((l + 1) * 2 ^ n), iteratedMaximalSubfamily (\ud835\udd18\u2083 k n j) i\n\nlemma \ud835\udd18\u2084_subset_\ud835\udd18\u2083 {k n j l} : \ud835\udd18\u2084 (X := X) k n j l \u2286 \ud835\udd18\u2083 k n j := by\n  simp [\ud835\udd18\u2084, iteratedMaximalSubfamily_subset]\n\n/-- The sets `(\ud835\udd18\u2084(k, n, j, l))_l` form a partition of `\ud835\udd18\u2083 k n j`. -/\nlemma iUnion_\ud835\udd18\u2084 (hkn : k \u2264 n) : \u22c3 l \u2208 Iio (4 * n + 12), \ud835\udd18\u2084 (X := X) k n j l = \ud835\udd18\u2083 k n j := by\n  have : \u22c3 l \u2208 Iio (4 * n + 12), \ud835\udd18\u2084 (X := X) k n j l =\n      \u22c3 i < (4 * n + 12) * 2 ^ n, iteratedMaximalSubfamily (\ud835\udd18\u2083 k n j) i := by\n    apply Subset.antisymm\n    \u00b7 simp only [mem_Iio, \ud835\udd18\u2084, mem_Ico, biUnion_and', iUnion_subset_iff]\n      intro l i hi hl h'i\n      apply subset_biUnion_of_mem\n      change i + 1 \u2264 (4 * n + 12) * 2 ^ n\n      suffices i < (4 * n + 12) * 2 ^ n by omega\n      exact h'i.trans_le (mul_le_mul' (by omega) le_rfl)\n    \u00b7 simp only [\ud835\udd18\u2084, iUnion_subset_iff]\n      intro i hi\n      let l := i / 2 ^ n\n      have : iteratedMaximalSubfamily (\ud835\udd18\u2083 k n j) i \u2286 \u22c3 i \u2208 Ico (l * 2 ^ n) ((l + 1) * 2 ^ n),\n          iteratedMaximalSubfamily (X := X) (\ud835\udd18\u2083 k n j) i := by\n        apply subset_biUnion_of_mem\n        refine \u27e8Nat.div_mul_le_self _ _, ?_\u27e9\n        rw [\u2190 Nat.div_lt_iff_lt_mul (Nat.two_pow_pos n)]\n        exact lt_add_one _\n      apply this.trans\n      apply subset_biUnion_of_mem (u := fun l \u21a6\n        \u22c3 i \u2208 Ico (l * 2 ^ n) ((l + 1) * 2 ^ n), iteratedMaximalSubfamily (\ud835\udd18\u2083 k n j) i)\n      simp only [mem_Iio, l]\n      rwa [Nat.div_lt_iff_lt_mul (Nat.two_pow_pos n)]\n  rw [this, eq_comm]\n  apply eq_biUnion_iteratedMaximalSubfamily\n  intro x\n  apply forest_stacking x hkn\n\nlemma C6_forest' (hkn : k \u2264 n) :\n    \u212d\u2086 (X := X) k n j = \u22c3 l \u2208 Iio (4 * n + 12), \u22c3 u \u2208 \ud835\udd18\u2084 k n j l, \ud835\udd17\u2082 k n j u := by\n  rw [C6_forest, \u2190 iUnion_\ud835\udd18\u2084 hkn]\n  simp\n\nlemma pairwiseDisjoint_\ud835\udd18\u2084 : univ.PairwiseDisjoint (\ud835\udd18\u2084 (X := X) k n j) := by\n  intro l hl m hm hml\n  apply disjoint_iff_forall_ne.2 (fun x hx y hy \u21a6 ?_)\n  simp only [\ud835\udd18\u2084, mem_Ico, mem_iUnion, exists_prop] at hx hy\n  rcases hx with \u27e8a, \u27e8ha, h'a\u27e9, xa\u27e9\n  rcases hy with \u27e8b, \u27e8hb, h'b\u27e9, yb\u27e9\n  have h : a \u2260 b := by\n    rcases lt_or_gt_of_ne hml with h | h\n    \u00b7 exact (h'a.trans_le (le_trans (mul_le_mul' h le_rfl) hb)).ne\n    \u00b7 exact (h'b.trans_le (le_trans (mul_le_mul' h le_rfl) ha)).ne'\n  have := pairwiseDisjoint_iteratedMaximalSubfamily (\ud835\udd18\u2083 (X := X) k n j) (mem_univ a) (mem_univ b) h\n  exact disjoint_iff_forall_ne.1 this xa yb\n\nlemma stackSize_\ud835\udd18\u2084_le (x : X) : stackSize (\ud835\udd18\u2084 (X := X) k n j l) x \u2264 2 ^ n := calc\n  stackSize (\ud835\udd18\u2084 (X := X) k n j l) x\n  _ = \u2211 i \u2208 Finset.Ico (l * 2 ^ n) ((l + 1) * 2 ^ n),\n        stackSize (iteratedMaximalSubfamily (\ud835\udd18\u2083 k n j) i) x := by\n    simp only [stackSize, \ud835\udd18\u2084]\n    rw [\u2190 Finset.sum_biUnion]; swap\n    \u00b7 intro a ha b hb hab\n      apply Finset.disjoint_coe.1\n      apply disjoint_iff_forall_ne.2 (fun p hp q hq \u21a6 ?_)\n      simp only [Finset.coe_filter, Finset.mem_univ, true_and, setOf_mem_eq] at hp hq\n      have := pairwiseDisjoint_iteratedMaximalSubfamily (\ud835\udd18\u2083 (X := X) k n j)\n        (mem_univ a) (mem_univ b) hab\n      exact disjoint_iff_forall_ne.1 this hp hq\n    congr\n    ext p\n    simp\n  _ \u2264 \u2211 i \u2208 Finset.Ico (l * 2 ^ n) ((l + 1) * 2 ^ n), 1 := by\n    gcongr with i hi\n    apply stackSize_le_one_of_pairwiseDisjoint\n    apply pairwiseDisjoint_iteratedMaximalSubfamily_image\n  _ = 2 ^ n := by simp [add_mul]\n\nopen TileStructure\nvariable (k n j l) in\n/-- The forest based on `\ud835\udd18\u2084 k n j l`. -/\ndef forest : Forest X n where\n  \ud835\udd18 := \ud835\udd18\u2084 k n j l\n  \ud835\udd17 := \ud835\udd17\u2082 k n j\n  nonempty' {u} hu := by\n    have m : u \u2208 \ud835\udd18\u2082 k n j := (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 (\ud835\udd18\u2084_subset_\ud835\udd18\u2083 hu))\n    have : \u212d\u2086 k n j \u2229 \ud835\udd17\u2081 k n j u \u2286 \ud835\udd17\u2082 k n j u := by\n      apply inter_subset_inter_right\n      have : \ud835\udd17\u2081 k n j u \u2286 \u22c3 (_ : URel k n j u u), \ud835\udd17\u2081 k n j u := by\n        have : URel k n j u u := (equivalenceOn_urel (X := X)).refl _ m\n        simp [this]\n      apply this.trans\n      apply subset_biUnion_of_mem (u := fun u' \u21a6 \u22c3 (_ : URel k n j u u'), \ud835\udd17\u2081 k n j u') m\n    apply Nonempty.mono this\n    rw [inter_comm]\n    simp only [\ud835\udd18\u2082, not_disjoint_iff_nonempty_inter, mem_setOf_eq] at m\n    exact m.2\n  ordConnected' {u} hu := forest_convex\n  \ud835\udcd8_ne_\ud835\udcd8' {u} hu p hp := by\n    have := hp.2\n    simp only [mem_iUnion, exists_prop, exists_and_left] at this\n    rcases this with \u27e8u', hu', u'rel, hu'I\u27e9\n    rw [URel.eq (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 (\ud835\udd18\u2084_subset_\ud835\udd18\u2083 hu)) hu' u'rel]\n    exact (\ud835\udcd8_lt_of_mem_\ud835\udd17\u2081 hu'I).ne\n  smul_four_le' {u} hu := forest_geometry <| \ud835\udd18\u2084_subset_\ud835\udd18\u2083 hu\n  stackSize_le' {x} := stackSize_\ud835\udd18\u2084_le x\n  dens\u2081_\ud835\udd17_le' {u} hu := dens1_le <| \ud835\udd17\u2082_subset_\u212d\u2086.trans \u212d\u2086_subset_\u212d\n  lt_dist' hu hu' huu' p hp := forest_separation (\ud835\udd18\u2084_subset_\ud835\udd18\u2083 hu) (\ud835\udd18\u2084_subset_\ud835\udd18\u2083 hu') huu' hp\n  ball_subset' hu p hp := forest_inner (\ud835\udd18\u2084_subset_\ud835\udd18\u2083 hu) hp\n\n/-- From the fact that the `\u212d\u2085 k n j` are disjoint, one can rewrite the whole Carleson sum over\n`\ud835\udd13\u2081` (the union of the `\u212d\u2085 k n j`) as a sum of Carleson sums over the `\u212d\u2085 k n j`. -/\nlemma carlesonSum_\ud835\udd13\u2081_eq_sum {f : X \u2192 \u2102} {x : X} :\n    carlesonSum \ud835\udd13\u2081 f x = \u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3, carlesonSum (\u212d\u2085 k n j) f x := by\n  simp only [Finset.sum_sigma']\n  rw [sum_carlesonSum_of_pairwiseDisjoint]; swap\n  \u00b7 rintro \u27e8n, k, j\u27e9 - \u27e8n', k', j'\u27e9 - h\n    simp only [ne_eq, Sigma.mk.inj_iff, heq_eq_eq] at h\n    simp only [Function.onFun, Finset.disjoint_filter, Finset.mem_univ, forall_const]\n    have W := pairwiseDisjoint_\u212d\u2085 (X := X) (mem_univ \u27e8k, n, j\u27e9) (mem_univ \u27e8k', n', j'\u27e9)\n      (by simp [-not_and]; tauto)\n    simpa [Function.onFun, disjoint_left] using W\n  congr\n  ext p\n  simp only [\ud835\udd13\u2081, mem_iUnion, exists_prop, Finset.mem_sigma, Finset.mem_Iic, Sigma.exists]\n  constructor\n  \u00b7 rintro \u27e8n, k, hk, j, hj, hp\u27e9\n    refine \u27e8n, k, j, \u27e8?_, hk, hj\u27e9, hp\u27e9\n    have : (\u212d (X := X) k n).Nonempty := \u27e8p, \u212d\u2085_subset_\u212d hp\u27e9\n    exact le_max\u212d_of_nonempty this\n  \u00b7 rintro \u27e8n, k, j, \u27e8hn, hk, hj\u27e9, hp\u27e9\n    exact \u27e8n, k, hk, j, hj, hp\u27e9\n\n/-- The Carleson sum over `\u212d\u2085` and `\u212d\u2086` coincide, for points in `G \\ G'`. -/\nlemma carlesonSum_\u212d\u2085_eq_\u212d\u2086 {f : X \u2192 \u2102} {x : X} (hx : x \u2208 G \\ G') {k n j : \u2115} :\n    carlesonSum (\u212d\u2085 k n j) f x = carlesonSum (\u212d\u2086 k n j) f x := by\n  simp only [carlesonSum]\n  symm\n  apply Finset.sum_subset\n  \u00b7 intro p hp\n    simp only [mem_iUnion, exists_prop, Finset.mem_filter, Finset.mem_univ, true_and] at hp \u22a2\n    exact \u212d\u2086_subset_\u212d\u2085 hp\n  \u00b7 intro p hp h'p\n    simp only [mem_iUnion, exists_prop, Finset.mem_filter,\n      Finset.mem_univ, true_and, not_exists, not_and] at hp h'p\n    have : x \u2209 \ud835\udcd8 p := by\n      simp only [\u212d\u2086, mem_setOf_eq, not_and, Decidable.not_not] at h'p\n      intro h'x\n      exact hx.2 (h'p hp h'x)\n    have : x \u2209 E p := by simp at this; simp [E, this]\n    simp [carlesonOn, this]\n\n/-- The Carleson sum over `\u212d\u2086` can be decomposed as a sum over `4 n + 12` forests\nbased on `\ud835\udd18\u2084 k n j l`. -/\nlemma carlesonSum_\u212d\u2086_eq_sum {f : X \u2192 \u2102} {x : X} {k n j : \u2115} (hkn : k \u2264 n) :\n    carlesonSum (\u212d\u2086 k n j) f x =\n      \u2211 l < 4 * n + 12, carlesonSum (\u22c3 u \u2208 \ud835\udd18\u2084 k n j l, \ud835\udd17\u2082 k n j u) f x := by\n  rw [sum_carlesonSum_of_pairwiseDisjoint]; swap\n  \u00b7 intro a ha b hb hab\n    simp only [Function.onFun, disjoint_iff_forall_ne, mem_iUnion, exists_prop, ne_eq,\n      forall_exists_index, and_imp]\n    intro q p hp hq q' p' hp' hq'\n    have := pairwiseDisjoint_\ud835\udd18\u2084 (X := X) (k := k) (n := n) (j := j) (mem_univ a) (mem_univ b) hab\n    have : p \u2260 p' := disjoint_iff_forall_ne.1 this hp hp'\n    have := forest_disjoint (\ud835\udd18\u2084_subset_\ud835\udd18\u2083 hp) (\ud835\udd18\u2084_subset_\ud835\udd18\u2083 hp') this\n    exact disjoint_iff_forall_ne.1 this hq hq'\n  congr\n  ext p\n  simp [C6_forest' hkn]\n\n/-- For each forest, the integral of the norm of the Carleson sum can be controlled thanks to\nthe forest theorem and to the density control coming from the fact we are away from `G\u2081`. -/\nlemma lintegral_carlesonSum_forest\n    {f : X \u2192 \u2102} (hf : Measurable f) (h2f : \u2200 x, \u2016f x\u2016 \u2264 F.indicator 1 x) :\n    \u222b\u207b x in G \\ G', \u2016carlesonSum (\u22c3 u \u2208 \ud835\udd18\u2084 k n j l, \ud835\udd17\u2082 k n j u) f x\u2016\u208a \u2264\n    C2_0_4 a q n * (2 ^ (2 * a + 5) * volume F / volume G) ^ (q\u207b\u00b9 - 2\u207b\u00b9) *\n    (volume F) ^ (1/2 : \u211d) * (volume G) ^ (1/2 : \u211d) := by\n  let \ud835\udd09 := forest (X := X) k n j l\n  have : \u222b\u207b x in G \\ G', \u2016carlesonSum (\u22c3 u \u2208 \ud835\udd18\u2084 k n j l, \ud835\udd17\u2082 k n j u) f x\u2016\u208a =\n      \u222b\u207b x in G \\ G', \u2016\u2211 u \u2208 { p | p \u2208 \ud835\udd09 }, carlesonSum (\ud835\udd09 u) f x\u2016\u208a := by\n    congr with x\n    congr\n    rw [sum_carlesonSum_of_pairwiseDisjoint]; swap\n    \u00b7 intro a ha b hb hab\n      simp only [Function.onFun, disjoint_iff_forall_ne]\n      intro x hx y hy\n      simp only [forest, Forest.mem_mk, Finset.coe_filter, Finset.mem_univ, true_and, setOf_mem_eq,\n        \ud835\udd09] at ha hb hx hy\n      have := forest_disjoint (X := X) (\ud835\udd18\u2084_subset_\ud835\udd18\u2083 ha) (\ud835\udd18\u2084_subset_\ud835\udd18\u2083 hb) hab\n      exact disjoint_iff_forall_ne.1 this hx hy\n    congr with p\n    simp only [mem_iUnion, exists_prop, Finset.mem_filter,\n      Finset.mem_univ, true_and, forest, Finset.mem_biUnion, \ud835\udd09]\n    exact Iff.rfl\n  rw [this]\n  have W := forest_operator_le_volume \ud835\udd09 hf h2f (A := G \\ G') (measurableSet_G.diff measurable_G')\n    (isBounded_G.subset diff_subset)\n  apply W.trans\n  gcongr\n  \u00b7 simp only [sub_nonneg, ge_iff_le, inv_le_inv\u2080 zero_lt_two (q_pos X)]\n    exact (q_mem_Ioc (X := X)).2\n  \u00b7 rw [dens\u2082_eq_biSup_dens\u2082]\n    simp only [mem_iUnion, exists_prop, iSup_exists, iSup_le_iff, and_imp]\n    intro p q hq hp\n    replace hp : p \u2208 \u212d\u2086 k n j := \ud835\udd17\u2082_subset_\u212d\u2086 hp\n    have : \u00ac (\ud835\udcd8 p : Set X) \u2286 G\u2081 := by\n      have W := hp.2\n      contrapose! W\n      exact W.trans (subset_union_left.trans subset_union_left)\n    contrapose! this\n    have : p \u2208 highDensityTiles := by simp [highDensityTiles, this]\n    apply subset_biUnion_of_mem this\n  \u00b7 exact diff_subset\n\n/-- For each forest, the integral of the norm of the Carleson sum can be controlled thanks to\nthe forest theorem and to the density control coming from the fact we are away from `G\u2081`. Second\nversion, with the volume of `F`. -/\nlemma lintegral_carlesonSum_forest'\n    {f : X \u2192 \u2102} (hf : Measurable f) (h2f : \u2200 x, \u2016f x\u2016 \u2264 F.indicator 1 x) :\n    \u222b\u207b x in G \\ G', \u2016carlesonSum (\u22c3 u \u2208 \ud835\udd18\u2084 k n j l, \ud835\udd17\u2082 k n j u) f x\u2016\u208a \u2264\n    C2_0_4 a q n * 2 ^ (a + 5/2 : \u211d) * (volume G) ^ (1 - q\u207b\u00b9) * (volume F) ^ (q\u207b\u00b9) := by\n  apply (lintegral_carlesonSum_forest hf h2f).trans\n  simp only [mul_assoc]\n  apply mul_le_mul_left'\n  simp only [div_eq_mul_inv, one_mul, ENNReal.mul_rpow_of_nonneg _ _ (inv_q_sub_half_nonneg X),\n    \u2190 ENNReal.rpow_natCast, \u2190 ENNReal.rpow_mul]\n  calc\n  2 ^ ((2 * a + 5 : \u2115) * (q\u207b\u00b9 - 2\u207b\u00b9)) * volume F ^ (q\u207b\u00b9 - 2\u207b\u00b9) * (volume G)\u207b\u00b9 ^ (q\u207b\u00b9 - 2\u207b\u00b9) *\n    (volume F ^ (2\u207b\u00b9 : \u211d) * volume G ^ (2\u207b\u00b9 : \u211d))\n  _ \u2264 2 ^ (a + 5/2 : \u211d) * volume F ^ (q\u207b\u00b9 - 2\u207b\u00b9) * (volume G)\u207b\u00b9 ^ (q\u207b\u00b9 - 2\u207b\u00b9) *\n    ((volume F) ^ (2\u207b\u00b9 : \u211d) * volume G ^ (2\u207b\u00b9 : \u211d)) := by\n    gcongr\n    \u00b7 exact one_le_two\n    have : 1 \u2264 q := (one_lt_q X).le\n    have : (2 * a + 5 : \u2115) * (q\u207b\u00b9 - 2\u207b\u00b9) \u2264 (2 * a + 5 : \u2115) * (1\u207b\u00b9 - 2\u207b\u00b9) := by gcongr\n    apply this.trans_eq\n    norm_num\n    simp [add_mul, div_eq_mul_inv]\n    ring\n  _ = 2 ^ (a + 5/2 : \u211d) * (volume G ^ (1 - q\u207b\u00b9) * volume F ^ q\u207b\u00b9) := by\n    have IF : (volume F) ^ (q\u207b\u00b9) = (volume F) ^ ((q \u207b\u00b9 - 2\u207b\u00b9) + 2\u207b\u00b9) := by congr; abel\n    have IG : (volume G) ^ (1 - q\u207b\u00b9) = (volume G) ^ (2\u207b\u00b9 - (q\u207b\u00b9 - 2\u207b\u00b9)) := by\n      congr 1\n      simp only [sub_sub_eq_add_sub, sub_left_inj]\n      norm_num\n    rw [IF, IG, ENNReal.rpow_sub _ _ ProofData.volume_G_pos.ne' volume_G_ne_top,\n      ENNReal.rpow_add_of_nonneg (x := volume F) _ _ (inv_q_sub_half_nonneg X) (by norm_num),\n      ENNReal.div_eq_inv_mul, ENNReal.inv_rpow]\n    ring\n\n/-- Putting all the above decompositions together, one obtains a control of the integral of the\nfull Carleson sum over `\ud835\udd13\u2081`, as a sum over all the forests. -/\nlemma forest_union_aux {f : X \u2192 \u2102} (hf : \u2200 x, \u2016f x\u2016 \u2264 F.indicator 1 x) (h'f : Measurable f) :\n    \u222b\u207b x in G \\ G', \u2016carlesonSum \ud835\udd13\u2081 f x\u2016\u208a \u2264 C2_0_4_base a * 2 ^ (a + 5/2 : \u211d) *\n         (volume G) ^ (1 - q\u207b\u00b9) * (volume F) ^ (q\u207b\u00b9) *\n        \u2211 n \u2264 max\u212d X, \u2211 _k \u2264 n, \u2211 _j \u2264 2 * n + 3, \u2211 _l < 4 * n + 12,\n          (2 : \u211d\u22650\u221e) ^ (- (q - 1) / q * n : \u211d) := calc\n  \u222b\u207b x in G \\ G', \u2016carlesonSum \ud835\udd13\u2081 f x\u2016\u208a\n  _ \u2264 \u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3, \u222b\u207b x in G \\ G', \u2016carlesonSum (\u212d\u2085 k n j) f x\u2016\u208a := by\n    simp only [Finset.sum_sigma']\n    rw [\u2190 lintegral_finset_sum']; swap\n    \u00b7 exact fun b hb \u21a6 h'f.aestronglyMeasurable.carlesonSum.restrict.enorm\n    apply lintegral_mono (fun x \u21a6 ?_)\n    simp only [Finset.sum_sigma', carlesonSum_\ud835\udd13\u2081_eq_sum]\n    exact (ENNReal.coe_le_coe.2 (nnnorm_sum_le _ _)).trans_eq (by simp)\n  _ = \u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3, \u222b\u207b x in G \\ G', \u2016carlesonSum (\u212d\u2086 k n j) f x\u2016\u208a := by\n    congr with n\n    congr with k\n    congr with j\n    apply setLIntegral_congr_fun (measurableSet_G.diff measurable_G')\n    exact Filter.Eventually.of_forall (fun x hx \u21a6 by rw [carlesonSum_\u212d\u2085_eq_\u212d\u2086 hx])\n  _ \u2264 \u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3,\n        \u2211 l < 4 * n + 12, \u222b\u207b x in G \\ G', \u2016carlesonSum (\u22c3 u \u2208 \ud835\udd18\u2084 k n j l, \ud835\udd17\u2082 k n j u) f x\u2016\u208a := by\n    gcongr with n hn k hk j hj\n    rw [\u2190 lintegral_finset_sum']; swap\n    \u00b7 exact fun b hb \u21a6 h'f.aestronglyMeasurable.carlesonSum.restrict.enorm\n    apply lintegral_mono (fun x \u21a6 ?_)\n    simp only [Finset.mem_Iic] at hk\n    rw [carlesonSum_\u212d\u2086_eq_sum hk]\n    exact (ENNReal.coe_le_coe.2 (nnnorm_sum_le _ _)).trans_eq (by simp)\n  _ \u2264 \u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3,\n        \u2211 l < 4 * n + 12, C2_0_4 a q n * 2 ^ (a + 5/2 : \u211d) *\n          (volume G) ^ (1 - q\u207b\u00b9) * (volume F) ^ (q\u207b\u00b9) := by\n    gcongr with n hn k hk j hj l hl\n    apply lintegral_carlesonSum_forest' h'f hf\n  _ = C2_0_4_base a * 2 ^ (a + 5/2 : \u211d) * (volume G) ^ (1 - q\u207b\u00b9) * (volume F) ^ (q\u207b\u00b9) *\n        \u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3, \u2211 l < 4 * n + 12,\n          (2 : \u211d\u22650\u221e) ^ (- (q - 1) / q * n : \u211d) := by\n    have A n : (C2_0_4 a q n : \u211d\u22650\u221e) = (2 : \u211d\u22650\u221e) ^ (- (q - 1) / q * n : \u211d) * C2_0_4_base a := by\n      simp only [C2_0_4, neg_sub, mul_comm, ENNReal.coe_mul,\n        ENNReal.coe_rpow_of_ne_zero two_ne_zero]\n      rfl\n    simp only [A, \u2190 Finset.sum_mul]\n    ring\n\n/- It remains to bound the sum above, by a sum/integral comparison over `\u211d` and then a cast from\n`\u211d` to `\u211d\u22650\u221e`. We do that in the next two lemmas. -/\n\nopen scoped Nat\nopen Real\n\n", "theoremStatement": "lemma forest_union_sum_aux1 (M : \u2115) (q : \u211d) (hq : 1 < q) (h'q : q \u2264 2) :\n    \u2211 n \u2264 M, \u2211 _k \u2264 n, \u2211 _j \u2264 2 * n + 3, \u2211 _l < 4 * n + 12,\n      (2 : \u211d) ^ (- ((q - 1) / q * n)) \u2264 13009 / (q - 1) ^ 4 ", "theoremName": "forest_union_sum_aux1", "fileCreated": {"commit": "310e13d16e51600777fc841833f4bce112b5f73a", "date": "2024-09-24"}, "theoremCreated": {"commit": "88d85ba29f717ee3bb9fbd37379a6fb77b57265f", "date": "2025-01-06"}, "file": "carleson/Carleson/Discrete/ForestUnion.lean", "module": "Carleson.Discrete.ForestUnion", "jsonFile": "Carleson.Discrete.ForestUnion.jsonl", "positionMetadata": {"lineInFile": 855, "tokenPositionInFile": 41538, "theoremPositionInFile": 47}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 1, "numPremises": 406}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  have A (x : \u211d) : (x + 1) * (2 * x + 3 + 1) * (4 * x + 12)\n      = 8 * x ^ 3 + 48 * x ^ 2 + 88 * x + 48:= by ring\n  simp only [Finset.sum_const, Nat.card_Iio, nsmul_eq_mul, Nat.cast_add, Nat.cast_mul,\n    Nat.cast_ofNat, Nat.card_Iic, Nat.cast_one, \u2190 mul_assoc, A, ge_iff_le]\n  simp only [add_mul, Finset.sum_add_distrib, mul_assoc, \u2190 Finset.mul_sum]\n  have : 0 \u2264 q - 1 := by linarith\n  have : q - 1 \u2264 1 := by linarith\n  have : 0.6931471803 \u2264 Real.log 2 := Real.log_two_gt_d9.le\n  let c := (q - 1) / q\n  have hc : 0 < c := div_pos (by linarith) (by linarith)\n  calc\n  8 * \u2211 i \u2208 Finset.Iic M, i ^ 3 * (2 : \u211d) ^ (-(c * i))\n    + 48 * \u2211 i \u2208 Finset.Iic M, i ^ 2 * (2 : \u211d) ^ (-(c * i))\n    + 88 * \u2211 i \u2208 Finset.Iic M, i * (2 : \u211d) ^ (-(c * i))\n    + 48 * \u2211 i \u2208 Finset.Iic M, (2 : \u211d) ^ (-(c * i))\n  _ = 8 * \u2211 i \u2208 Finset.Iic M, i ^ 3 * (2 : \u211d) ^ (-(c * i))\n      + 48 * \u2211 i \u2208 Finset.Iic M, i ^ 2 * (2 : \u211d) ^ (-(c * i))\n      + 88 * \u2211 i \u2208 Finset.Iic M, i ^ 1  * (2 : \u211d) ^ (-(c * i))\n      + 48 * \u2211 i \u2208 Finset.Iic M, i ^ 0 * (2 : \u211d) ^ (-(c * i)) := by simp\n  _ \u2264 8 * (2 ^ c * 3 ! / (Real.log 2 * c) ^ (3 + 1))\n      + 48 * (2 ^ c * 2 ! / (Real.log 2 * c) ^ (2 + 1))\n      + 88 * (2 ^ c * 1 ! / (Real.log 2 * c) ^ (1 + 1))\n      + 48 * (2 ^ c * 0! / (Real.log 2 * c) ^ (0 + 1)) := by\n    gcongr <;> exact sum_Iic_pow_mul_two_pow_neg_le hc\n  _ = (2 ^ c * (48 * q ^ 4 / (Real.log 2) ^ 4 + 96 * q^3 * (q - 1) / (Real.log 2) ^ 3\n      + 88 * q ^ 2 * (q - 1) ^ 2 / (Real.log 2) ^ 2\n      + 48 * q * (q - 1) ^ 3/ (Real.log 2))) / (q - 1) ^ 4 := by\n    simp only [Nat.factorial, Nat.succ_eq_add_one, Nat.reduceAdd, zero_add, mul_one, Nat.reduceMul,\n      Nat.cast_ofNat, mul_pow, div_pow, Nat.cast_one, pow_one, c]\n    have : q - 1 \u2260 0 := by linarith\n    field_simp only\n    ring\n  _ \u2264 (2 ^ (1 : \u211d) * (48 * 2 ^ 4 / (Real.log 2) ^ 4 + 96 * 2 ^ 3 * 1 / (Real.log 2) ^ 3\n      + 88 * 2 ^ 2 * 1 ^ 2 / (Real.log 2) ^ 2 + 48 * 2 * 1 ^ 3 / (Real.log 2))) / (q - 1) ^ 4 := by\n    gcongr\n    \u00b7 exact one_le_two\n    \u00b7 rw [div_le_one (by linarith)]\n      linarith\n  _ \u2264 (2 ^ (1 : \u211d) * (48 * 2 ^ 4 / 0.6931471803 ^ 4 + 96 * 2 ^ 3 * 1 / 0.6931471803 ^ 3\n      + 88 * 2 ^ 2 * 1 ^ 2 / 0.6931471803 ^ 2 + 48 * 2 * 1 ^ 3 / 0.6931471803)) / (q - 1) ^ 4 := by\n    gcongr\n  _ \u2264 13009 / (q - 1) ^ 4 := by\n    gcongr\n    norm_num", "proofType": "tactic", "proofLengthLines": 44, "proofLengthTokens": 2295}}
{"srcContext": "import Carleson.ForestOperator.LargeSeparation\nimport Carleson.ForestOperator.RemainingTiles\nimport Carleson.ToMathlib.MeasureTheory.Integral.SetIntegral\n\nopen ShortVariables TileStructure\nvariable {X : Type*} {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102} {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X}\n  [MetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] [TileStructure Q D \u03ba S o]\n  {n j j' : \u2115} {t : Forest X n} {u u\u2081 u\u2082 p : \ud835\udd13 X} {x x' : X} {\ud835\udd16 : Set (\ud835\udd13 X)}\n  {f f\u2081 f\u2082 g g\u2081 g\u2082 : X \u2192 \u2102} {I J J' L : Grid X}\nvariable {E' : Type*} [NormedAddCommGroup E'] [NormedSpace \u211d E']\n\nnoncomputable section\n\nopen Set MeasureTheory Metric Function Complex Bornology TileStructure Classical Filter\nopen scoped NNReal ENNReal ComplexConjugate\n\nnamespace TileStructure.Forest\n\n/-! ## Lemmas 7.4.4 -/\n\n/-- The constant used in `correlation_separated_trees`.\nHas value `2 ^ (550 * a ^ 3 - 3 * n)` in the blueprint. -/\n-- Todo: define this recursively in terms of previous constants\nirreducible_def C7_4_4 (a n : \u2115) : \u211d\u22650 := 2 ^ (550 * (a : \u211d) ^ 3 - 3 * n)\n\nlemma correlation_separated_trees_of_subset (hu\u2081 : u\u2081 \u2208 t) (hu\u2082 : u\u2082 \u2208 t) (hu : u\u2081 \u2260 u\u2082)\n    (h2u : \ud835\udcd8 u\u2081 \u2264 \ud835\udcd8 u\u2082)\n    (hf\u2081 : IsBounded (range f\u2081)) (h2f\u2081 : HasCompactSupport f\u2081)\n    (hf\u2082 : IsBounded (range f\u2082)) (h2f\u2082 : HasCompactSupport f\u2082) :\n    \u2016\u222b x, adjointCarlesonSum (t u\u2081) g\u2081 x * conj (adjointCarlesonSum (t u\u2082) g\u2082 x)\u2016\u208a \u2264\n    C7_4_4 a n *\n    eLpNorm\n      ((\ud835\udcd8 u\u2081 \u2229 \ud835\udcd8 u\u2082 : Set X).indicator (adjointBoundaryOperator t u\u2081 g\u2081) \u00b7 |>.toReal) 2 volume *\n    eLpNorm\n      ((\ud835\udcd8 u\u2081 \u2229 \ud835\udcd8 u\u2082 : Set X).indicator (adjointBoundaryOperator t u\u2082 g\u2082) \u00b7 |>.toReal) 2 volume := by\n  sorry\n\n/-- Lemma 7.4.4. -/\nlemma correlation_separated_trees (hu\u2081 : u\u2081 \u2208 t) (hu\u2082 : u\u2082 \u2208 t) (hu : u\u2081 \u2260 u\u2082)\n    (hf\u2081 : IsBounded (range f\u2081)) (h2f\u2081 : HasCompactSupport f\u2081)\n    (hf\u2082 : IsBounded (range f\u2082)) (h2f\u2082 : HasCompactSupport f\u2082) :\n    \u2016\u222b x, adjointCarlesonSum (t u\u2081) g\u2081 x * conj (adjointCarlesonSum (t u\u2082) g\u2082 x)\u2016\u208a \u2264\n    C7_4_4 a n *\n    eLpNorm\n      ((\ud835\udcd8 u\u2081 \u2229 \ud835\udcd8 u\u2082 : Set X).indicator (adjointBoundaryOperator t u\u2081 g\u2081) \u00b7 |>.toReal) 2 volume *\n    eLpNorm\n      ((\ud835\udcd8 u\u2081 \u2229 \ud835\udcd8 u\u2082 : Set X).indicator (adjointBoundaryOperator t u\u2082 g\u2082) \u00b7 |>.toReal) 2 volume := by\n  sorry\n\n\n/-! ## Section 7.7 -/\n\n/-- The row-decomposition of a tree, defined in the proof of Lemma 7.7.1.\nThe indexing is off-by-one compared to the blueprint. -/\ndef rowDecomp (t : Forest X n) (j : \u2115) : Row X n := sorry\n\n/-- Part of Lemma 7.7.1 -/\n@[simp]\nlemma biUnion_rowDecomp : \u22c3 j < 2 ^ n, t.rowDecomp j = (t : Set (\ud835\udd13 X)) := by\n  sorry\n\n/-- Part of Lemma 7.7.1 -/\nlemma pairwiseDisjoint_rowDecomp :\n    (Iio (2 ^ n)).PairwiseDisjoint (rowDecomp t \u00b7 : \u2115 \u2192 Set (\ud835\udd13 X)) := by\n  sorry\n\n@[simp] lemma rowDecomp_apply : t.rowDecomp j u = t u := by\n  sorry\n\n/-- The constant used in `row_bound`.\nHas value `2 ^ (156 * a ^ 3 - n / 2)` in the blueprint. -/\n-- Todo: define this recursively in terms of previous constants\nirreducible_def C7_7_2_1 (a n : \u2115) : \u211d\u22650 := 2 ^ (156 * (a : \u211d) ^ 3 - n / 2)\n\n/-- The constant used in `indicator_row_bound`.\nHas value `2 ^ (257 * a ^ 3 - n / 2)` in the blueprint. -/\n-- Todo: define this recursively in terms of previous constants\nirreducible_def C7_7_2_2 (a n : \u2115) : \u211d\u22650 := 2 ^ (257 * (a : \u211d) ^ 3 - n / 2)\n\n/-- Part of Lemma 7.7.2. -/\nlemma row_bound (hj : j < 2 ^ n) (hf : BoundedCompactSupport f) :\n    eLpNorm (\u2211 u \u2208 {p | p \u2208 rowDecomp t j}, adjointCarlesonSum (t u) f) 2 volume \u2264\n    C7_7_2_1 a n * eLpNorm f 2 volume := by\n  sorry\n\n/-- Part of Lemma 7.7.2. -/\nlemma indicator_row_bound (hj : j < 2 ^ n) (hf : BoundedCompactSupport f) :\n    eLpNorm (\u2211 u \u2208 {p | p \u2208 rowDecomp t j}, F.indicator <| adjointCarlesonSum (t u) f) 2 volume \u2264\n    C7_7_2_2 a n * dens\u2082 (\u22c3 u \u2208 t, t u) ^ (2 : \u211d)\u207b\u00b9 * eLpNorm f 2 volume := by\n  sorry\n\n/-- The constant used in `row_correlation`.\nHas value `2 ^ (862 * a ^ 3 - 3 * n)` in the blueprint. -/\n-- Todo: define this recursively in terms of previous constants\nirreducible_def C7_7_3 (a n : \u2115) : \u211d\u22650 := 2 ^ (862 * (a : \u211d) ^ 3 - 2 * n)\n\n/-- Lemma 7.7.3. -/\nlemma row_correlation (hjj' : j < j') (hj' : j' < 2 ^ n)\n    (hf\u2081 : IsBounded (range f\u2081)) (h2f\u2081 : HasCompactSupport f\u2081)\n    (hf\u2082 : IsBounded (range f\u2082)) (h2f\u2082 : HasCompactSupport f\u2082) :\n    \u2016\u222b x, (\u2211 u \u2208 {p | p \u2208 rowDecomp t j}, adjointCarlesonSum (t u) f\u2081 x) *\n    (\u2211 u \u2208 {p | p \u2208 rowDecomp t j'}, adjointCarlesonSum (t u) f\u2082 x)\u2016\u208a \u2264\n    C7_7_3 a n * eLpNorm f\u2081 2 volume * eLpNorm f\u2082 2 volume := by\n  sorry\n\nvariable (t) in\n/-- The definition of `E\u2c7c` defined above Lemma 7.7.4. -/\ndef rowSupport (j : \u2115) : Set X := \u22c3 (u \u2208 rowDecomp t j) (p \u2208 t u), E p\n\n/-- Lemma 7.7.4 -/\nlemma pairwiseDisjoint_rowSupport :\n    (Iio (2 ^ n)).PairwiseDisjoint (rowSupport t) := by\n  sorry\n\nend TileStructure.Forest\n\n/-! ## Proposition 2.0.4 -/\n\nirreducible_def C2_0_4_base (a : \u211d) : \u211d\u22650 := 2 ^ (432 * a ^ 3)\n\n/-- The constant used in `forest_operator`.\nHas value `2 ^ (432 * a ^ 3 - (q - 1) / q * n)` in the blueprint. -/\n-- Todo: define this recursively in terms of previous constants\nirreducible_def C2_0_4 (a q : \u211d) (n : \u2115) : \u211d\u22650 := C2_0_4_base a * 2 ^ (- (q - 1) / q * n)\n\ntheorem forest_operator {n : \u2115} (\ud835\udd09 : Forest X n) {f g : X \u2192 \u2102}\n    (hf : Measurable f) (h2f : \u2200 x, \u2016f x\u2016 \u2264 F.indicator 1 x) (hg : Measurable g)\n    (h2g : IsBounded (support g)) :\n    \u2016\u222b x, conj (g x) * \u2211 u \u2208 { p | p \u2208 \ud835\udd09 }, carlesonSum (\ud835\udd09 u) f x\u2016\u208a \u2264\n    C2_0_4 a q n * (dens\u2082 (\u22c3 u \u2208 \ud835\udd09, \ud835\udd09 u)) ^ (q\u207b\u00b9 - 2\u207b\u00b9) *\n    eLpNorm f 2 volume * eLpNorm g 2 volume := by\n  sorry\n\n", "theoremStatement": "/-- Version of the forest operator theorem, but controlling the integral of the norm instead of\nthe integral of the function multiplied by another function. -/\ntheorem forest_operator' {n : \u2115} (\ud835\udd09 : Forest X n) {f : X \u2192 \u2102} {A : Set X}\n    (hf : Measurable f) (h2f : \u2200 x, \u2016f x\u2016 \u2264 F.indicator 1 x) (hA : MeasurableSet A)\n    (h'A : IsBounded A) :\n    \u222b\u207b x in A, \u2016\u2211 u \u2208 { p | p \u2208 \ud835\udd09 }, carlesonSum (\ud835\udd09 u) f x\u2016\u208a \u2264\n    C2_0_4 a q n * (dens\u2082 (\u22c3 u \u2208 \ud835\udd09, \ud835\udd09 u)) ^ (q\u207b\u00b9 - 2\u207b\u00b9) *\n    eLpNorm f 2 volume * (volume A) ^ (1/2 : \u211d) ", "theoremName": "forest_operator'", "fileCreated": {"commit": "5e49c3692f6d7344434caa7eea5f412f0ee35863", "date": "2024-09-27"}, "theoremCreated": {"commit": "88d85ba29f717ee3bb9fbd37379a6fb77b57265f", "date": "2025-01-06"}, "file": "carleson/Carleson/ForestOperator/Forests.lean", "module": "Carleson.ForestOperator.Forests", "jsonFile": "Carleson.ForestOperator.Forests.jsonl", "positionMetadata": {"lineInFile": 134, "tokenPositionInFile": 5376, "theoremPositionInFile": 18}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 44, "numPremises": 430}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  /- This follows from the other version by taking for the test function `g` the argument of\n  the sum to be controlled. -/\n  rw [\u2190 ennnorm_integral_starRingEnd_mul_eq_lintegral_ennnorm]; swap\n  \u00b7 apply BoundedCompactSupport.integrable\n    apply BoundedCompactSupport.finset_sum (fun i hi \u21a6 ?_)\n    apply BoundedCompactSupport.carlesonSum\n    have : BoundedCompactSupport (F.indicator 1 : X \u2192 \u211d) := by\n      apply BoundedCompactSupport.indicator_of_isBounded_range _ stronglyMeasurable_one _\n        measurableSet_F\n      \u00b7 exact isBounded_range_iff_forall_norm_le.2 \u27e81, fun x \u21a6 by simp\u27e9\n      \u00b7 exact isBounded_F\n    apply BoundedCompactSupport.mono this hf.stronglyMeasurable h2f\n  rw [\u2190 integral_indicator hA]\n  simp_rw [indicator_mul_left, \u2190 comp_def,\n    Set.indicator_comp_of_zero (g := starRingEnd \u2102) (by simp)]\n  apply (forest_operator \ud835\udd09 hf h2f ?_ ?_).trans; rotate_left\n  \u00b7 apply Measurable.indicator _ hA\n    fun_prop\n  \u00b7 apply h'A.subset support_indicator_subset\n  gcongr\n  \u00b7 have := (q_mem_Ioc (X := X)).2\n    simp only [sub_nonneg, ge_iff_le, inv_le_inv\u2080 zero_lt_two (q_pos X)]\n    exact (q_mem_Ioc (X := X)).2\n  \u00b7 exact le_rfl\n  calc\n  _ \u2264 eLpNorm (A.indicator (fun x \u21a6 1) : X \u2192 \u211d) 2 volume := by\n    apply eLpNorm_mono (fun x \u21a6 ?_)\n    simp only [indicator, norm_eq_abs, coe_algebraMap, Pi.one_apply, Real.norm_eq_abs]\n    split_ifs\n    \u00b7 have A (x : \u211d) : x / x \u2264 1 := by\n        rcases eq_or_ne x 0 with rfl | hx\n        \u00b7 simp\n        \u00b7 simp [hx]\n      simpa using A _\n    \u00b7 simp\n  _ \u2264 _ := by\n    rw [eLpNorm_indicator_const]\n    \u00b7 simp\n    \u00b7 exact hA\n    \u00b7 norm_num\n    \u00b7 norm_num", "proofType": "tactic", "proofLengthLines": 41, "proofLengthTokens": 1605}}
{"srcContext": "import Carleson.Forest\nimport Carleson.ToMathlib.HardyLittlewood\nimport Carleson.ToMathlib.BoundedCompactSupport\nimport Carleson.ToMathlib.Misc\nimport Carleson.Psi\n\nopen ShortVariables TileStructure\nvariable {X : Type*} {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102} {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X}\n  [MetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] [TileStructure Q D \u03ba S o]\n  {n j j' : \u2115} {t : Forest X n} {u u\u2081 u\u2082 p : \ud835\udd13 X} {x x' : X} {\ud835\udd16 : Set (\ud835\udd13 X)}\n  {f f\u2081 f\u2082 g g\u2081 g\u2082 : X \u2192 \u2102} {I J J' L : Grid X}\nvariable {E' : Type*} [NormedAddCommGroup E'] [NormedSpace \u211d E']\n\nnoncomputable section\n\nopen Set MeasureTheory Metric Function Complex Bornology TileStructure Classical Filter\nopen scoped NNReal ENNReal ComplexConjugate\n\nnamespace TileStructure.Forest\n\n/-! ## Section 7.1 and Lemma 7.1.3 -/\n\nvariable (t) in\n/-- The definition `\u03c3(u, x)` given in Section 7.1.\nWe may assume `u \u2208 t` whenever proving things about this definition. -/\ndef \u03c3 (u : \ud835\udd13 X) (x : X) : Finset \u2124 := .image \ud835\udd30 { p | p \u2208 t u \u2227 x \u2208 E p }\n\nvariable (t) in\nprivate lemma exists_p_of_mem_\u03c3 (u : \ud835\udd13 X) (x : X) {s : \u2124} (hs : s \u2208 t.\u03c3 u x) :\n    \u2203 p \u2208 t.\ud835\udd17 u, x \u2208 E p \u2227 \ud835\udd30 p = s := by\n  have \u27e8p, hp\u27e9 := Finset.mem_image.mp hs\n  simp only [mem_\ud835\udd17, Finset.mem_filter] at hp\n  use p, hp.1.2.1, hp.1.2.2, hp.2\n\n/- \\overline{\u03c3} from the blueprint. -/\nvariable (t) in\ndef \u03c3Max (u : \ud835\udd13 X) (x : X) (h\u03c3 : (t.\u03c3 u x).Nonempty) : \u2124 :=\n  t.\u03c3 u x |>.max' h\u03c3\n\n/- \\underline{\u03c3} from the blueprint. -/\nvariable (t) in\ndef \u03c3Min (u : \ud835\udd13 X) (x : X) (h\u03c3 : (t.\u03c3 u x).Nonempty) : \u2124 :=\n  t.\u03c3 u x |>.min' h\u03c3\n\nvariable (t) in\nprivate lemma \u03c3Max_mem_\u03c3 (u : \ud835\udd13 X) (x : X) (h\u03c3 : (t.\u03c3 u x).Nonempty) : \u03c3Max t u x h\u03c3 \u2208 t.\u03c3 u x :=\n  (t.\u03c3 u x).max'_mem h\u03c3\n\n/-- The definition of `\ud835\udcd9\u2080(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcd9\u2080 (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {J : Grid X | s J = -S \u2228 \u2200 p \u2208 \ud835\udd16, \u00ac(\ud835\udcd8 p : Set X) \u2286 ball (c J) (100 * D ^ (s J + 1))}\n\n/-- The definition of `\ud835\udcd9(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcd9 (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {x | Maximal (\u00b7 \u2208 \ud835\udcd9\u2080 \ud835\udd16) x}\n\nlemma \ud835\udcd9_subset_\ud835\udcd9\u2080 {\ud835\udd16 : Set (\ud835\udd13 X)} : \ud835\udcd9 \ud835\udd16 \u2286 \ud835\udcd9\u2080 \ud835\udd16 := sep_subset ..\n\nlemma pairwiseDisjoint_\ud835\udcd9 : (\ud835\udcd9 \ud835\udd16).PairwiseDisjoint (fun I \u21a6 (I : Set X)) := fun I mI J mJ hn \u21a6 by\n  have : IsAntichain (\u00b7 \u2264 \u00b7) (\ud835\udcd9 \ud835\udd16) := setOf_maximal_antichain _\n  exact (le_or_ge_or_disjoint.resolve_left (this mI mJ hn)).resolve_left (this mJ mI hn.symm)\n\n/-- The definition of `\ud835\udcdb\u2080(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcdb\u2080 (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {L : Grid X | s L = -S \u2228 (\u2203 p \u2208 \ud835\udd16, L \u2264 \ud835\udcd8 p) \u2227 \u2200 p \u2208 \ud835\udd16, \u00ac\ud835\udcd8 p \u2264 L}\n\n/-- The definition of `\ud835\udcdb(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcdb (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {x | Maximal (\u00b7 \u2208 \ud835\udcdb\u2080 \ud835\udd16) x}\n\nlemma \ud835\udcdb_subset_\ud835\udcdb\u2080 {\ud835\udd16 : Set (\ud835\udd13 X)} : \ud835\udcdb \ud835\udd16 \u2286 \ud835\udcdb\u2080 \ud835\udd16 := sep_subset ..\n\nprivate lemma s_le_s_of_mem_\ud835\udcdb {\ud835\udd16 : Set (\ud835\udd13 X)} {L : Grid X} (hL : L \u2208 \ud835\udcdb \ud835\udd16)\n    {p : \ud835\udd13 X} (hp : p \u2208 \ud835\udd16) (hpL : \u00ac Disjoint (\ud835\udcd8 p : Set X) (L : Set X)) : s L \u2264 s (\ud835\udcd8 p) := by\n  simp only [\ud835\udcdb, \ud835\udcdb\u2080, Grid.le_def, not_and, not_le, and_imp] at hL\n  rcases hL.1 with h | h\n  \u00b7 exact h \u25b8 (range_s_subset \u27e8\ud835\udcd8 p, rfl\u27e9).1\n  \u00b7 by_contra!\n    exact lt_asymm this <| h.2 p hp <| (GridStructure.fundamental_dyadic' this.le).resolve_right hpL\n\nprivate lemma subset_of_mem_\ud835\udcdb {\ud835\udd16 : Set (\ud835\udd13 X)} {L : Grid X} (hL : L \u2208 \ud835\udcdb \ud835\udd16) {p : \ud835\udd13 X}\n    (hp : p \u2208 \ud835\udd16) (hpL : \u00ac Disjoint (\ud835\udcd8 p : Set X) (L : Set X)) : (L : Set X) \u2286 (\ud835\udcd8 p : Set X) :=\n  GridStructure.fundamental_dyadic' (s_le_s_of_mem_\ud835\udcdb hL hp hpL) |>.resolve_right fun h \u21a6 hpL h.symm\n\n/-- The projection operator `P_\ud835\udcd2 f(x)`, given above Lemma 7.1.3.\nIn lemmas the `c` will be pairwise disjoint on `C`. -/\ndef approxOnCube (C : Set (Grid X)) (f : X \u2192 E') (x : X) : E' :=\n  \u2211 J \u2208 { p | p \u2208 C }, (J : Set X).indicator (fun _ \u21a6 \u2a0d y in J, f y) x\n\nlemma stronglyMeasurable_approxOnCube (C : Set (Grid X)) (f : X \u2192 E') :\n    StronglyMeasurable (approxOnCube (X := X) (K := K) C f) :=\n  Finset.stronglyMeasurable_sum _ (fun _ _ \u21a6 stronglyMeasurable_const.indicator coeGrid_measurable)\n\nlemma integrable_approxOnCube (C : Set (Grid X)) {f : X \u2192 E'} : Integrable (approxOnCube C f) := by\n  refine integrable_finset_sum _ (fun i hi \u21a6 ?_)\n  constructor\n  \u00b7 exact (aestronglyMeasurable_indicator_iff coeGrid_measurable).mpr aestronglyMeasurable_const\n  \u00b7 simp_rw [hasFiniteIntegral_iff_enorm, enorm_indicator_eq_indicator_enorm]\n    apply lt_of_le_of_lt <| lintegral_indicator_const_le (i : Set X) _\n    exact ENNReal.mul_lt_top ENNReal.coe_lt_top volume_coeGrid_lt_top\n\nlemma approxOnCube_nonneg {C : Set (Grid X)} {f : X \u2192 \u211d} (hf : \u2200 (y : X), f y \u2265 0) {x : X} :\n    approxOnCube C f x \u2265 0 :=\n  Finset.sum_nonneg' (fun _ \u21a6 Set.indicator_nonneg (fun _ _ \u21a6 integral_nonneg hf) _)\n\nlemma approxOnCube_apply {C : Set (Grid X)} (hC : C.PairwiseDisjoint (fun I \u21a6 (I : Set X)))\n    (f : X \u2192 E') {x : X} {J : Grid X} (hJ : J \u2208 C) (xJ : x \u2208 J) :\n    (approxOnCube C f) x = \u2a0d y in J, f y := by\n  rw [approxOnCube, \u2190 Finset.sum_filter_not_add_sum_filter _ (J = \u00b7)]\n  have eq0 : \u2211 i \u2208 Finset.filter (\u00ac J = \u00b7) (Finset.univ.filter (\u00b7 \u2208 C)),\n      (i : Set X).indicator (fun _ \u21a6 \u2a0d y in i, f y) x = 0 := by\n    suffices \u2200 i \u2208 (Finset.univ.filter (\u00b7 \u2208 C)).filter (\u00ac J = \u00b7),\n      (i : Set X).indicator (fun _ \u21a6 \u2a0d y in i, f y) x = 0 by simp [Finset.sum_congr rfl this]\n    intro i hi\n    simp only [Finset.mem_filter, Finset.mem_univ, true_and] at hi\n    apply indicator_of_not_mem <|\n      Set.disjoint_left.mp ((hC.eq_or_disjoint hJ hi.1).resolve_left hi.2) xJ\n  have eq_ave : \u2211 i \u2208 (Finset.univ.filter (\u00b7 \u2208 C)).filter (J = \u00b7),\n      (i : Set X).indicator (fun _ \u21a6 \u2a0d y in i, f y) x = \u2a0d y in J, f y := by\n    suffices (Finset.univ.filter (\u00b7 \u2208 C)).filter (J = \u00b7) = {J} by simp [this, xJ, \u2190 Grid.mem_def]\n    exact subset_antisymm (fun _ h \u21a6 Finset.mem_singleton.mpr (Finset.mem_filter.mp h).2.symm)\n      (fun _ h \u21a6 by simp [Finset.mem_singleton.mp h, hJ])\n  rw [eq0, eq_ave, zero_add]\n\nlemma boundedCompactSupport_approxOnCube {\ud835\udd5c : Type*} [RCLike \ud835\udd5c] {C : Set (Grid X)} {f : X \u2192 \ud835\udd5c} :\n    BoundedCompactSupport (approxOnCube C f) :=\n  BoundedCompactSupport.finset_sum fun J hJ \u21a6\n    BoundedCompactSupport.indicator_of_isBounded_range (by simp) stronglyMeasurable_const\n    ((isBounded_iff_subset_ball (c J)).mpr \u27e84 * D ^ s J, Grid_subset_ball\u27e9) coeGrid_measurable\n\n-- Used in the proof of Lemma 7.1.6\nlemma integral_eq_lintegral_approxOnCube {C : Set (Grid X)}\n    (hC : C.PairwiseDisjoint fun I \u21a6 (I : Set X)) {J : Grid X} (hJ : J \u2208 C) {f : X \u2192 \u2102}\n    (hf : BoundedCompactSupport f) : ENNReal.ofReal (\u222b y in J, \u2016f y\u2016) =\n    \u222b\u207b (y : X) in J, \u2016approxOnCube C (fun x \u21a6 (\u2016f x\u2016 : \u2102)) y\u2016\u208a := by\n  have nonneg : 0 \u2264\u1da0[ae (volume.restrict J)] fun y \u21a6 \u2016f y\u2016 := Filter.Eventually.of_forall (by simp)\n  have vol_J_ne_zero := (volume_coeGrid_pos (X := X) (i := J) (defaultD_pos' a)).ne.symm\n  have eq : \u222b\u207b (y : X) in J, \u2016approxOnCube C (fun x \u21a6 (\u2016f x\u2016 : \u2102)) y\u2016\u208a =\n      \u222b\u207b y in (J : Set X), ENNReal.ofReal (\u2a0d z in J, \u2016f z\u2016) := by\n    refine setLIntegral_congr_fun coeGrid_measurable (Filter.Eventually.of_forall fun y hy \u21a6 ?_)\n    rw [approxOnCube_apply hC _ hJ hy, ENNReal.ofReal]\n    \u00b7 apply congrArg\n      have : \u2016\u2a0d y in J, (\u2016f y\u2016 : \u2102)\u2016\u208a = \u2016\u2a0d y in J, \u2016f y\u2016\u2016\u208a := by\n        convert congrArg (\u2016\u00b7\u2016\u208a) <| integral_ofReal (f := (\u2016f \u00b7\u2016)) using 1\n        simp [average]\n      exact this \u25b8 (Real.toNNReal_eq_nnnorm_of_nonneg <| integral_nonneg (fun y \u21a6 by simp)).symm\n  rw [ofReal_integral_eq_lintegral_ofReal hf.integrable.norm.restrict nonneg,\n    eq, lintegral_const, average_eq, smul_eq_mul, ENNReal.ofReal_mul, ENNReal.ofReal_inv_of_pos,\n    ENNReal.ofReal_toReal, ofReal_integral_eq_lintegral_ofReal hf.norm.integrable nonneg, mul_comm,\n    \u2190 mul_assoc, Measure.restrict_apply MeasurableSet.univ, univ_inter,\n    ENNReal.mul_inv_cancel vol_J_ne_zero volume_coeGrid_lt_top.ne, one_mul]\n  \u00b7 simp [volume_coeGrid_lt_top.ne]\n  \u00b7 simpa using ENNReal.toReal_pos vol_J_ne_zero volume_coeGrid_lt_top.ne\n  \u00b7 exact inv_nonneg.mpr ENNReal.toReal_nonneg\n\nlemma approxOnCube_ofReal (C : Set (Grid X)) (f : X \u2192 \u211d) (x : X) :\n    approxOnCube C (Complex.ofReal <| f \u00b7) x = Complex.ofReal (approxOnCube C f x) := by\n  simp_rw [approxOnCube, ofReal_sum]\n  refine Finset.sum_congr rfl (fun J _ \u21a6 ?_)\n  by_cases hx : x \u2208 (J : Set X)\n  \u00b7 simpa only [indicator_of_mem hx] using integral_ofReal\n  \u00b7 simp only [indicator_of_not_mem hx, ofReal_zero]\n\n", "theoremStatement": "lemma norm_approxOnCube_le_approxOnCube_norm {C : Set (Grid X)} {f : X \u2192 E'} {x : X} :\n    \u2016approxOnCube C f x\u2016 \u2264 approxOnCube C (\u2016f \u00b7\u2016) x ", "theoremName": "TileStructure.Forest.norm_approxOnCube_le_approxOnCube_norm", "fileCreated": {"commit": "5e49c3692f6d7344434caa7eea5f412f0ee35863", "date": "2024-09-27"}, "theoremCreated": {"commit": "0138d636eed1475ea5e848ef6cf4b141636056cc", "date": "2025-01-20"}, "file": "carleson/Carleson/ForestOperator/PointwiseEstimate.lean", "module": "Carleson.ForestOperator.PointwiseEstimate", "jsonFile": "Carleson.ForestOperator.PointwiseEstimate.jsonl", "positionMetadata": {"lineInFile": 164, "tokenPositionInFile": 8151, "theoremPositionInFile": 22}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 19, "numPremises": 100}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  refine (norm_sum_le _ _).trans <| Finset.sum_le_sum (fun J hJ \u21a6 ?_)\n  rw [norm_indicator_eq_indicator_norm]\n  gcongr\n  apply norm_integral_le_integral_norm", "proofType": "tactic", "proofLengthLines": 4, "proofLengthTokens": 163}}
{"srcContext": "import Mathlib.MeasureTheory.Integral.MeanInequalities\nimport Mathlib.MeasureTheory.Integral.Layercake\nimport Mathlib.MeasureTheory.Integral.Lebesgue\nimport Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar\nimport Mathlib.Analysis.SpecialFunctions.Pow.Integral\nimport Carleson.ToMathlib.ENorm\nimport Carleson.ToMathlib.Misc\n\nnoncomputable section\n\nopen NNReal ENNReal NormedSpace MeasureTheory Set Filter Topology Function\n\nsection move\n\n\nvariable {\u03b1 \ud835\udd5c E : Type*} {m : MeasurableSpace \u03b1}\n  {\u03bc : Measure \u03b1} [NontriviallyNormedField \ud835\udd5c]\n  [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]\n  {p : \u211d\u22650\u221e}\n\n-- todo: move/rename/and perhaps reformulate in terms of \u2016.\u2016\u2091\nlemma ENNNorm_absolute_homogeneous {c : \ud835\udd5c} (z : E) : ofNNReal \u2016c \u2022 z\u2016\u208a = \u2191\u2016c\u2016\u208a * \u2191\u2016z\u2016\u208a :=\n  (toReal_eq_toReal_iff' coe_ne_top coe_ne_top).mp (norm_smul c z)\n\nlemma ENNNorm_add_le (y z : E) : ofNNReal \u2016y + z\u2016\u208a \u2264 \u2191\u2016y\u2016\u208a + \u2191\u2016z\u2016\u208a :=\n  (toReal_le_toReal coe_ne_top coe_ne_top).mp (nnnorm_add_le ..)\n\nlemma measure_mono_ae' {A B : Set \u03b1} (h : \u03bc (B \\ A) = 0) :\n    \u03bc B \u2264 \u03bc A := by\n  apply measure_mono_ae\n  change \u03bc {x | \u00ac B x \u2264 A x} = 0\n  simp only [le_Prop_eq, Classical.not_imp]\n  exact h\n\n\nlemma eLpNormEssSup_toReal_le {f : \u03b1 \u2192 \u211d\u22650\u221e} :\n    eLpNormEssSup (ENNReal.toReal \u2218 f) \u03bc \u2264 eLpNormEssSup f \u03bc := by\n  simp_rw [eLpNormEssSup, enorm_eq_self]\n  apply essSup_mono_ae\n  apply Eventually.of_forall\n  simp [implies_true]\n\nlemma eLpNormEssSup_toReal_eq {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : \u2200\u1d50 x \u2202\u03bc, f x \u2260 \u221e) :\n    eLpNormEssSup (ENNReal.toReal \u2218 f) \u03bc = eLpNormEssSup f \u03bc := by\n  simp_rw [eLpNormEssSup, enorm_eq_self]\n  apply essSup_congr_ae\n  filter_upwards [hf] with x hx\n  simp [hx]\n\nlemma eLpNorm'_toReal_le {f : \u03b1 \u2192 \u211d\u22650\u221e} {p : \u211d} (hp : 0 \u2264 p) :\n    eLpNorm' (ENNReal.toReal \u2218 f) p \u03bc \u2264 eLpNorm' f p \u03bc := by\n  simp_rw [eLpNorm', enorm_eq_self]\n  gcongr\n  simp\n\nlemma eLpNorm'_toReal_eq {f : \u03b1 \u2192 \u211d\u22650\u221e} {p : \u211d} (hf : \u2200\u1d50 x \u2202\u03bc, f x \u2260 \u221e) :\n    eLpNorm' (ENNReal.toReal \u2218 f) p \u03bc = eLpNorm' f p \u03bc := by\n  simp_rw [eLpNorm', enorm_eq_self]\n  congr 1\n  apply lintegral_congr_ae\n  filter_upwards [hf] with x hx\n  simp [hx]\n\nlemma eLpNorm_toReal_le {f : \u03b1 \u2192 \u211d\u22650\u221e} :\n    eLpNorm (ENNReal.toReal \u2218 f) p \u03bc \u2264 eLpNorm f p \u03bc := by\n  simp_rw [eLpNorm]\n  split_ifs\n  \u00b7 rfl\n  \u00b7 exact eLpNormEssSup_toReal_le\n  \u00b7 exact eLpNorm'_toReal_le toReal_nonneg\n\nlemma eLpNorm_toReal_eq {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : \u2200\u1d50 x \u2202\u03bc, f x \u2260 \u221e) :\n    eLpNorm (ENNReal.toReal \u2218 f) p \u03bc = eLpNorm f p \u03bc := by\n  simp_rw [eLpNorm]\n  split_ifs\n  \u00b7 rfl\n  \u00b7 exact eLpNormEssSup_toReal_eq hf\n  \u00b7 exact eLpNorm'_toReal_eq hf\n\nend move\n\nnamespace MeasureTheory\n\nvariable {\u03b1 \u03b1' \u03b5 \u03b5\u2081 \u03b5\u2082 \u03b5\u2083 \ud835\udd5c E E\u2081 E\u2082 E\u2083 : Type*} {m : MeasurableSpace \u03b1} {m : MeasurableSpace \u03b1'}\n  {p p' q : \u211d\u22650\u221e} {c : \u211d\u22650}\n  {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b1'} [NontriviallyNormedField \ud835\udd5c]\n  [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]\n  [NormedAddCommGroup E\u2081] [NormedSpace \ud835\udd5c E\u2081]\n  [NormedAddCommGroup E\u2082] [NormedSpace \ud835\udd5c E\u2082]\n  [NormedAddCommGroup E\u2083] [NormedSpace \ud835\udd5c E\u2083]\n  (L : E\u2081 \u2192L[\ud835\udd5c] E\u2082 \u2192L[\ud835\udd5c] E\u2083)\n  {t s x y : \u211d\u22650\u221e}\n  {T : (\u03b1 \u2192 \u03b5\u2081) \u2192 (\u03b1' \u2192 \u03b5\u2082)}\n\nsection ENorm\n\nvariable [ENorm \u03b5] {f g g\u2081 g\u2082 : \u03b1 \u2192 \u03b5}\n\n/- Proofs for this file can be found in\nFolland, Real Analysis. Modern Techniques and Their Applications, section 6.3. -/\n\n/-! # The distribution function `d_f` -/\n\n/-- The distribution function of a function `f`.\nNote that unlike the notes, we also define this for `t = \u221e`.\nNote: we also want to use this for functions with codomain `\u211d\u22650\u221e`, but for those we just write\n`\u03bc { x | t < f x }` -/\ndef distribution (f : \u03b1 \u2192 \u03b5) (t : \u211d\u22650\u221e) (\u03bc : Measure \u03b1) : \u211d\u22650\u221e :=\n  \u03bc { x | t < \u2016f x\u2016\u2091 }\n\n@[gcongr]\nlemma distribution_mono_right (h : t \u2264 s) : distribution f s \u03bc \u2264 distribution f t \u03bc :=\n  measure_mono fun _ a \u21a6 lt_of_le_of_lt h a\n\nlemma distribution_mono_right' : (Antitone (fun t \u21a6 distribution f t \u03bc)) :=\n  fun _ _ h \u21a6 distribution_mono_right h\n\n@[measurability, fun_prop]\nlemma distribution_measurable\u2080 : Measurable (fun t \u21a6 distribution f t \u03bc) :=\n  Antitone.measurable (distribution_mono_right' (f := f) (\u03bc := \u03bc))\n\n@[measurability, fun_prop]\nlemma distribution_measurable {g : \u03b1' \u2192 \u211d\u22650\u221e} (hg : Measurable g) :\n    Measurable (fun y : \u03b1' \u21a6 distribution f (g y) \u03bc) := by\n  fun_prop\n\nlemma distribution_toReal_le {f : \u03b1 \u2192 \u211d\u22650\u221e} :\n    distribution (ENNReal.toReal \u2218 f) t \u03bc \u2264 distribution f t \u03bc := by\n  simp_rw [distribution]\n  apply measure_mono\n  simp_rw [comp_apply, enorm_eq_self, setOf_subset_setOf]\n  intro x hx\n  exact hx.trans_le enorm_toReal_le\n\nlemma distribution_toReal_eq {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : \u2200\u1d50 x \u2202\u03bc, f x \u2260 \u221e) :\n    distribution (ENNReal.toReal \u2218 f) t \u03bc = distribution f t \u03bc := by\n  refine measure_congr (.set_eq ?_)\n  filter_upwards [hf] with x hx\n  simp [hx]\n\n", "theoremStatement": "lemma distribution_add_le_of_enorm {A : \u211d\u22650\u221e}\n    (h : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016\u2091 \u2264 A * (\u2016g\u2081 x\u2016\u2091 + \u2016g\u2082 x\u2016\u2091)) :\n    distribution f (A * (t + s)) \u03bc \u2264 distribution g\u2081 t \u03bc + distribution g\u2082 s \u03bc ", "theoremName": "MeasureTheory.distribution_add_le_of_enorm", "fileCreated": {"commit": "1a36cbeaee9466fb56c9aca49ef373f9f9cc7ab7", "date": "2025-01-23"}, "theoremCreated": {"commit": "b069d5bb71885f498386762866228ac78bf5409e", "date": "2025-01-13"}, "file": "carleson/Carleson/ToMathlib/WeakType.lean", "module": "Carleson.ToMathlib.WeakType", "jsonFile": "Carleson.ToMathlib.WeakType.jsonl", "positionMetadata": {"lineInFile": 141, "tokenPositionInFile": 4597, "theoremPositionInFile": 16}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 5, "numPremises": 87}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  unfold distribution\n  have h\u2081 : \u03bc ({x | A * (t + s) < \u2016f x\u2016\u2091} \\\n      ({x | t < \u2016g\u2081 x\u2016\u2091} \u222a {x | s < \u2016g\u2082 x\u2016\u2091})) = 0 := by\n    apply measure_mono_null ?_ h\n    intro x\n    simp only [mem_diff, mem_setOf_eq, mem_union, not_or, not_lt, mem_compl_iff, not_le, and_imp]\n    intro h\u2081 h\u2082 h\u2083\n    refine lt_of_le_of_lt ?_ h\u2081\n    gcongr\n  calc\n    \u03bc {x | A * (t + s) < \u2016f x\u2016\u2091}\n      \u2264 \u03bc ({x | t < \u2016g\u2081 x\u2016\u2091} \u222a {x | s < \u2016g\u2082 x\u2016\u2091}) := measure_mono_ae' h\u2081\n    _ \u2264 \u03bc {x | t < \u2016g\u2081 x\u2016\u2091} + \u03bc {x | s < \u2016g\u2082 x\u2016\u2091} := measure_union_le _ _", "proofType": "tactic", "proofLengthLines": 13, "proofLengthTokens": 520}}
{"srcContext": "/-\nCopyright (c) 2024 James Sundstrom. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: James Sundstrom\n-/\nimport Mathlib.MeasureTheory.Constructions.BorelSpace.Metric\n\n/-!\n# Annulus\n\nIn this file we define an annulus in a pseudometric space `X` to be a set consisting of all `y`\nsuch that `dist x y` lies in an interval between `r` and `R`. An annulus is defined for each type\nof interval (`Ioo`, `Ioc`, etc.) with a parallel naming scheme, except that we do not define annuli\nfor `Iio` and `Ico`, as they would be balls.\n\nWe also define `EAnnulus` similarly using `edist` instead of `dist`.\n\n## Tags\n\nannulus, eannulus\n-/\n\nopen Set Metric ENNReal\n\nvariable {X : Type*} [PseudoMetricSpace X]\n\nnamespace Set\n\nnamespace Annulus\n\ndef oo (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d) := {y | dist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d) := {y | dist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d) := {y | dist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d) := {y | dist x y \u2208 Ici r}\n\nlemma oo_eq {x : X} {r R : \u211d} : oo x r R = ball x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oo, dist_comm, and_comm]\n\nlemma oc_eq {x : X} {r R : \u211d} : oc x r R = closedBall x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oc, dist_comm, and_comm]\n\nlemma co_eq {x : X} {r R : \u211d} : co x r R = ball x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [co, dist_comm, and_comm]\n\nlemma cc_eq {x : X} {r R : \u211d} : cc x r R = closedBall x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [cc, dist_comm, and_comm]\n\nlemma oi_eq {x : X} {r : \u211d} : oi x r = (closedBall x r)\u1d9c := by\n  ext; simp [oi, dist_comm]\n\nlemma ci_eq {x : X} {r : \u211d} : ci x r = (ball x r)\u1d9c := by\n  ext; simp [ci, dist_comm]\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : co x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma co_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : co x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\nlemma cc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : cc x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma cc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : cc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\n@[simp]\nlemma oc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    oc x r r' \u222a oo x r' R = oo x r R := by\n  ext; simp_rw [oc, oo, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioo_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    oc x r r' \u222a oc x r' R = oc x r R := by\n  ext; simp_rw [oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_co {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a co x r' R = oo x r R := by\n  ext; simp_rw [oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ico_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a cc x r' R = oc x r R := by\n  ext; simp_rw [oo, cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Icc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    cc x r r' \u222a oo x r' R = co x r R := by\n  ext; simp_rw [cc, oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioo_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    cc x r r' \u222a oc x r' R = cc x r R := by\n  ext; simp_rw [cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_co {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a co x r' R = co x r R := by\n  ext; simp_rw [co, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ico_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a cc x r' R = cc x r R := by\n  ext; simp_rw [co, cc, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Icc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : oc x r R \u222a oi x R = oi x r := by\n  ext; simp_rw [oc, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioi_eq_Ioi h]\n\n@[simp]\nlemma oo_union_ci {x : X} {r R : \u211d} (h : r < R) :\n    oo x r R \u222a ci x R = oi x r := by\n  ext; simp_rw [oo, ci, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ici_eq_Ioi h]\n\n@[simp]\nlemma cc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : cc x r R \u222a oi x R = ci x r := by\n  ext; simp_rw [cc, oi, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioi_eq_Ici h]\n\n@[simp]\nlemma co_union_ci {x : X} {r R : \u211d} (h : r \u2264 R) : co x r R \u222a ci x R = ci x r := by\n  ext; simp_rw [co, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ici_eq_Ici h]\n\n\nvariable [MeasurableSpace X] [OpensMeasurableSpace X]\n\n@[measurability]\nlemma measurableSet_oo {x : X} {r R : \u211d} : MeasurableSet (oo x r R) := by\n  rw [oo_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oc {x : X} {r R : \u211d} : MeasurableSet (oc x r R) := by\n rw [oc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_co {x : X} {r R : \u211d} : MeasurableSet (co x r R) := by\n  rw [co_eq]; measurability\n\n@[measurability]\nlemma measurableSet_cc {x : X} {r R : \u211d} : MeasurableSet (cc x r R) := by\n rw [cc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oi {x : X} {r : \u211d} : MeasurableSet (oi x r) := by\n  rw [oi_eq]; measurability\n\n@[measurability]\nlemma measurableSet_ci {x : X} {r : \u211d} : MeasurableSet (ci x r) := by\n  rw [ci_eq]; measurability\n\nend Annulus\n\nnamespace EAnnulus\n\ndef oo (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ici r}\n\n\nlemma oo_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oo x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oo x r R := by\n  simp_rw [oo, Annulus.oo, edist_dist, mem_Ioo, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma oc_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [oc, Annulus.oc, edist_dist, mem_Ioc, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  \u00b7 have R_le_r := (lt_of_lt_of_le (lt_of_not_ge hR) hr).le\n    rw [Annulus.oc_eq_empty R_le_r]\n    refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n    exact not_le_of_gt (lt_of_le_of_lt (ENNReal.ofReal_le_ofReal R_le_r) hy.1) hy.2\n\nlemma co_eq_annulus {x : X} {r R : \u211d} :\n    co x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.co x r R := by\n  simp_rw [co, Annulus.co, edist_dist, mem_Ico, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma cc_eq_annulus {x : X} {r R : \u211d} (h : r > 0 \u2228 R \u2265 0) :\n    cc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.cc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [cc, Annulus.cc, edist_dist, mem_Icc, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  have r0 := h.resolve_right hR\n  have R_lt_r := (lt_of_not_ge hR).trans r0\n  rw [Annulus.cc_eq_empty R_lt_r]\n  refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n  exact not_le_of_gt ((ENNReal.ofReal_lt_ofReal_iff r0).mpr R_lt_r) (hy.1.trans hy.2)\n\nlemma oi_eq_annulus {x : X} {r : \u211d} (hr : r \u2265 0) : oi x (ENNReal.ofReal r) = Annulus.oi x r := by\n  simp_rw [oi, Annulus.oi, edist_dist, mem_Ioi, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr]\n\nlemma ci_eq_annulus {x : X} {r : \u211d} : ci x (ENNReal.ofReal r) = Annulus.ci x r := by\n  simp_rw [ci, Annulus.ci, edist_dist, mem_Ici, ENNReal.ofReal_le_ofReal_iff dist_nonneg]\n\n\nlemma oo_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oo x r R = ball x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oo, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma oc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oc x r R = closedBall x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oc, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma co_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    co x r R = ball x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [co, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma cc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    cc x r R = closedBall x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [cc, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma oi_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : oi x r = (closedBall x r.toReal)\u1d9c := by\n  ext; simp [oi, edist_dist, dist_comm, lt_ofReal_iff_toReal_lt hr.ne]\n\nlemma ci_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : ci x r = (ball x r.toReal)\u1d9c := by\n  ext; simp [ci, edist_dist, dist_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg]\n\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n@[simp]\nlemma cc_top_eq_empty {x : X} {R : \u211d\u22650\u221e} : cc x \u22a4 R = \u2205 :=\n  eq_empty_of_forall_not_mem (fun y hy \u21a6 (edist_ne_top x y) (top_le_iff.mp hy.1))\n\n@[simp]\nlemma oi_eq_empty {x : X} : oi x \u22a4 = \u2205 := by simp [oi, edist_dist]\n\n@[simp]\nlemma ci_eq_empty {x : X} : ci x \u22a4 = \u2205 := by simp [ci, edist_dist]\n\n\nlemma oo_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) :\n    oo x r \u22a4 = (closedBall x r.toReal)\u1d9c := by\n  ext; simpa [oo, edist_dist, dist_comm] using lt_ofReal_iff_toReal_lt hr.ne\n\nlemma oc_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) :\n    oc x r \u22a4 = (closedBall x r.toReal)\u1d9c := by\n  ext; simpa [oc, edist_dist, dist_comm] using lt_ofReal_iff_toReal_lt hr.ne\n\nlemma co_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : co x r \u22a4 = (ball x r.toReal)\u1d9c := by\n  ext; simpa [co, edist_dist, dist_comm] using le_ofReal_iff_toReal_le hr.ne dist_nonneg\n\nlemma cc_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : cc x r \u22a4 = (ball x r.toReal)\u1d9c := by\n  ext; simpa [cc, edist_dist, dist_comm] using le_ofReal_iff_toReal_le hr.ne dist_nonneg\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\n", "theoremStatement": "lemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 ", "theoremName": "Set.EAnnulus.oo_subset_oi", "fileCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "theoremCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "file": "carleson/Carleson/ToMathlib/Annulus.lean", "module": "Carleson.ToMathlib.Annulus", "jsonFile": "Carleson.ToMathlib.Annulus.jsonl", "positionMetadata": {"lineInFile": 384, "tokenPositionInFile": 14945, "theoremPositionInFile": 91}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 24}, "proofMetadata": {"hasProof": true, "proof": ":=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 43}}
{"srcContext": "import Mathlib.MeasureTheory.Integral.MeanInequalities\nimport Mathlib.MeasureTheory.Integral.Layercake\nimport Mathlib.MeasureTheory.Integral.Lebesgue\nimport Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar\nimport Mathlib.Analysis.SpecialFunctions.Pow.Integral\nimport Carleson.ToMathlib.ENorm\nimport Carleson.ToMathlib.Misc\n\nnoncomputable section\n\nopen NNReal ENNReal NormedSpace MeasureTheory Set Filter Topology Function\n\nsection move\n\n\nvariable {\u03b1 \ud835\udd5c E : Type*} {m : MeasurableSpace \u03b1}\n  {\u03bc : Measure \u03b1} [NontriviallyNormedField \ud835\udd5c]\n  [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]\n  {p : \u211d\u22650\u221e}\n\n-- todo: move/rename/and perhaps reformulate in terms of \u2016.\u2016\u2091\nlemma ENNNorm_absolute_homogeneous {c : \ud835\udd5c} (z : E) : ofNNReal \u2016c \u2022 z\u2016\u208a = \u2191\u2016c\u2016\u208a * \u2191\u2016z\u2016\u208a :=\n  (toReal_eq_toReal_iff' coe_ne_top coe_ne_top).mp (norm_smul c z)\n\nlemma ENNNorm_add_le (y z : E) : ofNNReal \u2016y + z\u2016\u208a \u2264 \u2191\u2016y\u2016\u208a + \u2191\u2016z\u2016\u208a :=\n  (toReal_le_toReal coe_ne_top coe_ne_top).mp (nnnorm_add_le ..)\n\nlemma measure_mono_ae' {A B : Set \u03b1} (h : \u03bc (B \\ A) = 0) :\n    \u03bc B \u2264 \u03bc A := by\n  apply measure_mono_ae\n  change \u03bc {x | \u00ac B x \u2264 A x} = 0\n  simp only [le_Prop_eq, Classical.not_imp]\n  exact h\n\n\nlemma eLpNormEssSup_toReal_le {f : \u03b1 \u2192 \u211d\u22650\u221e} :\n    eLpNormEssSup (ENNReal.toReal \u2218 f) \u03bc \u2264 eLpNormEssSup f \u03bc := by\n  simp_rw [eLpNormEssSup, enorm_eq_self]\n  apply essSup_mono_ae\n  apply Eventually.of_forall\n  simp [implies_true]\n\nlemma eLpNormEssSup_toReal_eq {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : \u2200\u1d50 x \u2202\u03bc, f x \u2260 \u221e) :\n    eLpNormEssSup (ENNReal.toReal \u2218 f) \u03bc = eLpNormEssSup f \u03bc := by\n  simp_rw [eLpNormEssSup, enorm_eq_self]\n  apply essSup_congr_ae\n  filter_upwards [hf] with x hx\n  simp [hx]\n\nlemma eLpNorm'_toReal_le {f : \u03b1 \u2192 \u211d\u22650\u221e} {p : \u211d} (hp : 0 \u2264 p) :\n    eLpNorm' (ENNReal.toReal \u2218 f) p \u03bc \u2264 eLpNorm' f p \u03bc := by\n  simp_rw [eLpNorm', enorm_eq_self]\n  gcongr\n  simp\n\nlemma eLpNorm'_toReal_eq {f : \u03b1 \u2192 \u211d\u22650\u221e} {p : \u211d} (hf : \u2200\u1d50 x \u2202\u03bc, f x \u2260 \u221e) :\n    eLpNorm' (ENNReal.toReal \u2218 f) p \u03bc = eLpNorm' f p \u03bc := by\n  simp_rw [eLpNorm', enorm_eq_self]\n  congr 1\n  apply lintegral_congr_ae\n  filter_upwards [hf] with x hx\n  simp [hx]\n\n", "theoremStatement": "lemma eLpNorm_toReal_le {f : \u03b1 \u2192 \u211d\u22650\u221e} :\n    eLpNorm (ENNReal.toReal \u2218 f) p \u03bc \u2264 eLpNorm f p \u03bc ", "theoremName": "eLpNorm_toReal_le", "fileCreated": {"commit": "1a36cbeaee9466fb56c9aca49ef373f9f9cc7ab7", "date": "2025-01-23"}, "theoremCreated": {"commit": "451f4568375c1be265a0beb82adb601f9a3ee74d", "date": "2025-01-20"}, "file": "carleson/Carleson/ToMathlib/WeakType.lean", "module": "Carleson.ToMathlib.WeakType", "jsonFile": "Carleson.ToMathlib.WeakType.jsonl", "positionMetadata": {"lineInFile": 64, "tokenPositionInFile": 2043, "theoremPositionInFile": 7}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 4, "numPremises": 52}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp_rw [eLpNorm]\n  split_ifs\n  \u00b7 rfl\n  \u00b7 exact eLpNormEssSup_toReal_le\n  \u00b7 exact eLpNorm'_toReal_le toReal_nonneg", "proofType": "tactic", "proofLengthLines": 5, "proofLengthTokens": 122}}
{"srcContext": "import Carleson.ForestOperator.PointwiseEstimate\nimport Carleson.ToMathlib.Misc\nimport Carleson.ToMathlib.ENorm\nimport Carleson.ToMathlib.Annulus\n\nnoncomputable section\n\nopen Set MeasureTheory Metric Function Complex Bornology TileStructure Classical Filter\nopen scoped NNReal ENNReal ComplexConjugate\n\nopen ShortVariables\nvariable {X : Type*} {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102} {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X}\n  [MetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] {f : X \u2192 \u2102}\n\nlemma integrableOn_K_mul_f (x' : X) (hf : BoundedCompactSupport f) (r : \u211d\u22650\u221e) (hr : 0 < r) :\n    IntegrableOn (fun y \u21a6 K x' y * f y) (EAnnulus.ci x' r) := by\n  by_cases supp_f : (support f).Nonempty; swap\n  \u00b7 simp [Function.support_eq_empty_iff.mp <| Set.not_nonempty_iff_eq_empty.mp supp_f]\n  by_cases r_top : r = \u22a4\n  \u00b7 simp [r_top]\n  have \u27e8x'', hx''\u27e9 := supp_f\n  have \u27e8C, hC\u27e9 := Metric.isBounded_iff.mp hf.isBoundedSupport\n  have : support (fun y \u21a6 f y * K x' y) \u2286 closedBall x' (dist x' x'' + C) := by\n    intro y hy\n    have : y \u2208 support f := by contrapose! hy; simp [hy]\n    exact mem_closedBall'.mp <| (dist_triangle x' x'' y).trans <| add_le_add_left (hC hx'' this) _\n  simp_rw [mul_comm (K x' _), IntegrableOn, \u2190 integrableOn_iff_integrable_of_support_subset this]\n  apply hf.integrable_mul\n  rw [Measure.restrict_restrict measurableSet_closedBall, inter_comm, \u2190 IntegrableOn]\n  convert integrableOn_K_Icc (K := K) (R := dist x' x'' + C) (r.toReal_pos hr.ne.symm r_top) using 1\n  ext y\n  simp [edist_dist, dist_comm y, EAnnulus.ci, ENNReal.le_ofReal_iff_toReal_le r_top dist_nonneg]\n\n\n-- Truncated version of `K` used in proof of `nontangential_pointwise_bound`\nprivate def K' (b : \u2124) (c : \u2124) (x y : X) := \u2211 i \u2208 (Icc b c).toFinset, Ks i x y\n\nnamespace K'\n\nprivate lemma eq_K (b : \u2124) (c : \u2124) (x y : X)\n    (h : dist x y \u2208 Icc ((D : \u211d) ^ (b - 1) / 2) (D ^ c / 4)) : K' b c x y = K x y := by\n  have hxy : dist x y > 0 := lt_of_lt_of_le (div_pos (defaultD_pow_pos a (b - 1)) two_pos) h.1\n  simp_rw [K', Ks, \u2190 Finset.mul_sum, \u2190 Complex.ofReal_sum]\n  rw [\u2190 finsum_eq_sum_of_support_subset, finsum_\u03c8 (one_lt_D (X := X)) hxy, ofReal_one, mul_one]\n  rw [toFinset_Icc, Finset.coe_Icc]\n  exact support_\u03c8S_subset_Icc (one_lt_D (X := X)) h\n\nprivate lemma integrableOn_mul_f (x' : X) (hf : BoundedCompactSupport f) (r : \u211d\u22650\u221e) (hr : 0 < r)\n    (s\u2081 s\u2082 : \u2124) : IntegrableOn (fun y \u21a6 K' s\u2081 s\u2082 x' y * f y) (EAnnulus.ci x' r) := by\n  simp_rw [K', Ks, mul_comm (K x' _) (\u03c8 _), \u2190 Finset.sum_mul, mul_assoc]\n  apply Integrable.bdd_mul (integrableOn_K_mul_f x' hf r hr)\n  \u00b7 refine (Finset.aestronglyMeasurable_sum _ (fun i hi \u21a6 ?_)).restrict\n    apply continuous_ofReal.comp_aestronglyMeasurable \u2218 continuous_\u03c8.comp_aestronglyMeasurable\n    exact (continuous_const.dist continuous_id').aestronglyMeasurable.const_mul _\n  \u00b7 refine \u27e8(s\u2082 + 1 - s\u2081).toNat, fun _ \u21a6 le_trans (norm_sum_le ..) ?_\u27e9\n    simp_rw [norm_eq_abs, abs_ofReal]\n    exact le_of_le_of_eq (Finset.sum_le_sum fun _ _ \u21a6 abs_\u03c8_le_one _ _) (by simp)\n\nprivate lemma support_subset (b : \u2124) (c : \u2124) (x : X) :\n    support (K' b c x) \u2286 Annulus.cc x (D ^ (b - 1) / 4) (D ^ c / 2) := by\n  refine subset_trans ?_ (Annulus.oo_subset_cc (le_refl _) (le_refl _))\n  intro y hy\n  rw [mem_support] at hy\n  simp only [Annulus.oo, mem_Ioo, mem_setOf_eq]\n  contrapose! hy\n  refine Finset.sum_eq_zero (fun s hs \u21a6 ?_)\n  rw [toFinset_Icc] at hs\n  suffices ((D : \u211d) ^ s)\u207b\u00b9 * dist x y \u2209 support \u03c8 by simp [Ks, nmem_support.mp this, -defaultD]\n  rw [support_\u03c8 (one_lt_D (X := X)), mem_Ioo, not_and_or]\n  by_cases h : (D : \u211d) ^ (b - 1) / 4 < dist x y\n  \u00b7 exact Or.inr <| not_lt_of_ge <| calc\n      _ \u2265 ((D : \u211d) ^ c)\u207b\u00b9 * (D ^ c / 2) := by\n        gcongr\n        \u00b7 exact defaultD_pow_pos a s\n        \u00b7 exact one_le_D\n        \u00b7 exact (Finset.mem_Icc.mp hs).2\n        \u00b7 exact hy h\n      _ = 2\u207b\u00b9 := by field_simp\n  \u00b7 push_neg at h\n    exact Or.inl <| not_lt_of_ge <| calc\n      ((D : \u211d) ^ s)\u207b\u00b9 * dist x y \u2264 ((D : \u211d) ^ b)\u207b\u00b9 * (D ^ (b - 1) / 4) := by\n                                 refine mul_le_mul ?_ h dist_nonneg ?_\n                                 \u00b7 apply inv_anti\u2080 (defaultD_pow_pos a b)\n                                   exact zpow_right_mono\u2080 one_le_D (Finset.mem_Icc.mp hs).1\n                                 \u00b7 exact inv_nonneg.mpr (defaultD_pow_pos a b).le\n      _                          = (4 * (D : \u211d))\u207b\u00b9 := by\n                                 rw [zpow_sub\u2080 (defaultD_pos a).ne.symm]; field_simp; apply mul_comm\n\nprivate lemma enorm_le_enorm_K (a : \u2124) (b : \u2124) (x y : X) : \u2016K' a b x y\u2016\u2091 \u2264 \u2016K x y\u2016\u2091 := by\n  unfold K' Ks\n  by_cases hxy : 0 = dist x y\n  \u00b7 simp [\u2190 hxy, psi_zero]\n  rw [\u2190 mul_one \u2016K x y\u2016\u2091, \u2190 Finset.mul_sum, enorm_mul]\n  apply mul_le_mul_left'\n  rw [enorm_eq_nnnorm]\n  norm_cast\n  apply le_trans <| nnnorm_sum_le _ _\n  simp_rw [\u2190 norm_toNNReal, Real.norm_eq_abs, \u2190 Real.toNNReal_sum_of_nonneg fun _ _ \u21a6 abs_nonneg _,\n    Real.toNNReal_le_one, abs_eq_self.mpr <| zero_le_\u03c8 _ _]\n  exact sum_\u03c8_le (one_lt_D (X := X)) _ <| lt_of_le_of_ne dist_nonneg hxy\n\nend K'\n\n-- Bound needed for proof of `nontangential_pointwise_bound`, splitting the annulus between radii\n-- `r\u2081` and `r\u2084` into annuli between `r\u2081` and `r\u2082`, between `r\u2082` and `r\u2083`, and between `r\u2083` and\n-- `r\u2084`. Note that we assume only `r\u2081 \u2264 r\u2082` and `r\u2083 \u2264 r\u2084`.\nprivate lemma annulus_integral_bound (x : X) (g : X \u2192 \u2102) {r\u2081 r\u2082 r\u2083 r\u2084 : \u211d} (h\u2081\u2082 : r\u2081 \u2264 r\u2082)\n    (h\u2083\u2084 : r\u2083 \u2264 r\u2084) (hg : IntegrableOn g (Annulus.cc x r\u2081 r\u2084)) :\n    \u2016\u222b y in Annulus.cc x r\u2081 r\u2084, g y\u2016\u2091 \u2264 \u2016\u222b y in Annulus.oo x r\u2082 r\u2083, g y\u2016\u2091 +\n    ((\u222b\u207b y in Annulus.cc x r\u2081 r\u2082, \u2016g y\u2016\u2091) + \u222b\u207b y in Annulus.cc x r\u2083 r\u2084, \u2016g y\u2016\u2091) := calc\n  _ = \u2016(\u222b y in Annulus.cc x r\u2081 r\u2084 \u2229 Annulus.oo x r\u2082 r\u2083, g y) +\n        \u222b y in Annulus.cc x r\u2081 r\u2084 \u2229 (Annulus.oo x r\u2082 r\u2083)\u1d9c, g y\u2016\u2091 := by\n    apply congrArg (\u2016\u00b7\u2016\u2091)\n    rw [\u2190 setIntegral_union (Set.disjoint_left.mpr (fun _ h\u2081 h\u2082 \u21a6 h\u2082.2 h\u2081.2)) (by measurability),\n        inter_union_compl] <;>\n      exact hg.mono_set inter_subset_left\n  _ \u2264 \u2016\u222b y in Annulus.cc x r\u2081 r\u2084 \u2229 Annulus.oo x r\u2082 r\u2083, g y\u2016\u2091 +\n        \u2016\u222b y in Annulus.cc x r\u2081 r\u2084 \u2229 (Annulus.oo x r\u2082 r\u2083)\u1d9c, g y\u2016\u2091 := by apply ENormedAddMonoid.enorm_add_le\n  _ \u2264 _ := by\n    gcongr\n    \u00b7 rw [inter_eq_self_of_subset_right <| Annulus.oo_subset_cc h\u2081\u2082 h\u2083\u2084]\n    \u00b7 calc\n        _ \u2264 _ := enorm_integral_le_lintegral_enorm _\n        _ \u2264 \u222b\u207b y in Annulus.cc x r\u2081 r\u2082 \u222a Annulus.cc x r\u2083 r\u2084, \u2016g y\u2016\u2091 := by\n          refine lintegral_mono_set (fun y \u21a6 ?_)\n          simp only [Annulus.oo, Annulus.cc, edist_dist, mem_Ioo, mem_Icc, mem_inter_iff,\n            mem_setOf_eq, mem_compl_iff, not_and, not_le, mem_union, and_imp]\n          intro hr\u2081 hr\u2084 hr\u2082\u2083\n          by_cases hr\u2082 : r\u2082 < dist x y\n          \u00b7 exact Or.inr \u27e8le_of_not_gt (hr\u2082\u2083 hr\u2082), hr\u2084\u27e9\n          \u00b7 exact Or.inl \u27e8hr\u2081, le_of_not_gt hr\u2082\u27e9\n        _ \u2264 _ := lintegral_union_le _ _ _\n\nlemma CMB_defaultA_two_eq {a : \u2115} : CMB (defaultA a) 2 = 2 ^ (a + (3 / 2 : \u211d)) := by\n  suffices (2 : \u211d\u22650) * 2 ^ (2 : \u211d)\u207b\u00b9 * (ENNReal.ofReal |2 - 1|\u207b\u00b9).toNNReal ^ (2 : \u211d)\u207b\u00b9 *\n      ((2 ^ a) ^ (2 : \u211d)) ^ (2 : \u211d)\u207b\u00b9 = 2 ^ (a + 3 / (2 : \u211d)) by\n    simpa [CMB, C_realInterpolation, C_realInterpolation_ENNReal]\n  rw [\u2190 NNReal.rpow_mul, show (3 / 2 : \u211d) = 1 + (1 / 2 : \u211d) by norm_num]\n  repeat rw [NNReal.rpow_add two_ne_zero]\n  norm_num\n  ring\n\nopen ShortVariables TileStructure\nvariable {X : Type*} {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102} {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X}\n  [MetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] [TileStructure Q D \u03ba S o]\n  {n j j' : \u2115} {t : Forest X n} {u u\u2081 u\u2082 p : \ud835\udd13 X} {x x' : X} {\ud835\udd16 : Set (\ud835\udd13 X)}\n  {f f\u2081 f\u2082 g g\u2081 g\u2082 : X \u2192 \u2102} {I J J' L : Grid X}\nvariable {E' : Type*} [NormedAddCommGroup E'] [NormedSpace \u211d E']\n\nnamespace TileStructure.Forest\n\nlemma eLpNorm_MB_le {\ud835\udd5c : Type*} [RCLike \ud835\udd5c] {f : X \u2192 \ud835\udd5c} (hf : BoundedCompactSupport f) :\n    eLpNorm (MB volume \ud835\udcd1 c\ud835\udcd1 r\ud835\udcd1 f \u00b7) 2 volume \u2264 CMB (defaultA a : \u211d\u22650) 2 * eLpNorm f 2 volume :=\n  hasStrongType_MB_finite \ud835\udcd1_finite one_lt_two f (hf.mem\u2112p 2) |>.2\n\n/-! ## Section 7.2 and Lemma 7.2.1 -/\n\n/-- The constant used in `nontangential_operator_bound`.\nPreviously had value `2 ^ (103 * a ^ 3)` in the blueprint. -/\n-- Todo: define this recursively in terms of previous constants\nirreducible_def C7_2_2 (a : \u2115) : \u211d\u22650 := 2 ^ (102 * (a : \u211d) ^ 3)\n\n-- Bound for (7.2.3) in the proof of `nontangential_pointwise_bound`\nomit [TileStructure Q D \u03ba S o] in\nprivate lemma nontangential_integral_bound\u2081 {x x' : X} {r : \u211d} (R : \u211d) (hr : dist x x' < r) :\n    \u2016\u222b y in Annulus.oo x' r R, K x' y * f y\u2016\u2091 \u2264 nontangentialOperator K f x := by\n  by_cases r_lt_R : r < R; swap\n  \u00b7 simp [-defaultD, Annulus.oo_eq_empty (le_of_not_gt r_lt_R)]\n  refine le_trans ?_ <| le_iSup _ r\n  refine le_trans ?_ <| le_iSup _ R\n  rw [iSup_pos r_lt_R]\n  refine le_of_eq_of_le ?_ <| le_iSup _ x'\n  rw [iSup_pos hr, Annulus.oo, enorm_eq_nnnorm]\n\n-- Bound for (7.2.4) and (7.2.5) in the proof of `nontangential_pointwise_bound`\nprivate lemma nontangential_integral_bound\u2082 (hf : BoundedCompactSupport f) {x x' : X}\n    {I : Grid X} (hx : x \u2208 I) (hx' : x' \u2208 I) {R : \u211d} (h : R \u2264 8 * D ^ (s I)) :\n    \u222b\u207b y in Annulus.cc x' ((D : \u211d) ^ (s I - 1) / 4) R, \u2016K x' y * f y\u2016\u2091 \u2264\n    2 ^ (7 * (a : \u211d) + 101 * a ^ 3) * MB volume \ud835\udcd1 c\ud835\udcd1 r\ud835\udcd1 f x := by\n  apply (lintegral_mono_set (Annulus.cc_subset_cc (le_refl _) h)).trans\n  have ineq : \u2200 y \u2208 Annulus.cc x' ((D : \u211d) ^ (s I - 1) / 4) (8 * D ^ (s I)), \u2016K x' y * f y\u2016\u2091 \u2264\n      2 ^ (7 * (a : \u211d) + 101 * a ^ 3) / volume (ball (c I) (16 * D ^ (s I))) * \u2016f y\u2016\u2091 := by\n    intro y hy\n    rw [Annulus.cc] at hy\n    rw [enorm_mul]\n    refine mul_le_mul_right' ((ennnorm_K_le 5 hy.1).trans ?_) \u2016f y\u2016\u2091\n    gcongr\n    \u00b7 norm_num\n    \u00b7 norm_num\n    \u00b7 suffices dist (c I) x' < 16 * D ^ (s I) from ball_subset_ball' (by linarith)\n      rw [\u2190 mem_ball', s]\n      refine ball_subset_ball ?_ (Grid_subset_ball hx')\n      linarith [defaultD_pow_pos a (GridStructure.s I)]\n  apply le_trans <| setLIntegral_mono (hf.stronglyMeasurable.measurable.enorm.const_mul _) ineq\n  simp_rw [ENNReal.mul_comm_div, div_eq_mul_inv]\n  have := hf.stronglyMeasurable.measurable.enorm\n  rw [lintegral_const_mul _ (this.mul_const _), lintegral_mul_const _ this, \u2190 div_eq_mul_inv]\n  apply mul_left_mono\n  calc\n    _ \u2264 (\u222b\u207b y in ball (c I) (16 * D ^ s I), \u2016f y\u2016\u2091) / volume (ball (c I) (16 * D ^ s I)) := by\n      gcongr\n      refine lintegral_mono' (Measure.le_iff.mpr (fun T hT \u21a6  ?_)) (le_refl _)\n      rw [Measure.restrict_apply hT, Measure.restrict_apply hT]\n      refine measure_mono (inter_subset_inter_right T (fun y \u21a6 ?_))\n      simp only [Annulus.cc, mem_Icc, mem_setOf_eq, mem_ball, and_imp, dist_comm x']\n      intro _ h\n      calc dist y (c I)\n        _ \u2264 dist y x' + dist x' (c I) := dist_triangle y x' (c I)\n        _ \u2264 8 * (D : \u211d) ^ s I + 4 * (D : \u211d) ^ s I :=\n          add_le_add h (mem_ball.mp (Grid_subset_ball hx')).le\n        _ < 16 * (D : \u211d) ^ s I := by linarith [defaultD_pow_pos a (s I)]\n    _ = \u2a0d\u207b y in ball (c I) (16 * D ^ s I), \u2016f y\u2016\u2091 \u2202volume := by rw [setLaverage_eq]\n    _ \u2264 MB volume \ud835\udcd1 c\ud835\udcd1 r\ud835\udcd1 f x := by\n      rw [MB, maximalFunction, inv_one, ENNReal.rpow_one]\n      have : \u27e84, I\u27e9 \u2208 \ud835\udcd1 := by simp [\ud835\udcd1]\n      refine le_of_eq_of_le ?_ (le_biSup _ this)\n      have : x \u2208 ball (c I) (2 ^ 4 * (D : \u211d) ^ s I) := by\n        refine (ball_subset_ball ?_) (Grid_subset_ball hx)\n        unfold s\n        linarith [defaultD_pow_pos a (GridStructure.s I)]\n      simp_rw [c\ud835\udcd1, r\ud835\udcd1, ENNReal.rpow_one, indicator_of_mem this, enorm_eq_nnnorm]\n      norm_num\n\n-- Pointwise bound needed for Lemma 7.2.2\nprivate lemma nontangential_pointwise_bound (hf : BoundedCompactSupport f) (\u03b8 : \u0398 X) (x : X) :\n    nontangentialMaximalFunction \u03b8 f x \u2264 nontangentialOperator K f x +\n      2 ^ (1 + 7 * (a : \u211d) + 101 * a ^ 3) * MB volume \ud835\udcd1 c\ud835\udcd1 r\ud835\udcd1 f x := by\n  refine iSup\u2082_le fun I hI \u21a6 iSup\u2082_le fun x' hx' \u21a6 iSup\u2082_le fun s\u2082 hs\u2082 \u21a6 iSup_le fun _ \u21a6 ?_\n  rw [\u2190 enorm_eq_nnnorm, \u2190 integral_finset_sum]; swap\n  \u00b7 intro i hi\n    simp_rw [mul_comm]\n    exact hf.integrable_mul (integrable_Ks_x <| one_lt_D (X := X))\n  simp_rw [\u2190 Finset.sum_mul]\n  have ineq {n : \u2115} (hn : n > 0) : (D : \u211d) ^ (s I - 1) / n < 8 * D ^ s I := by\n    rw [zpow_sub\u2080 (defaultD_pos a).ne.symm, div_div, zpow_one]\n    calc (D : \u211d) ^ s I / ((D : \u211d) * n)\n      _ \u2264 D ^ s I / 1 := by gcongr; exact_mod_cast (mul_pos (defaultD_pos' a) hn)\n      _ < 8 * D ^ s I := by linarith [defaultD_pow_pos a (s I)]\n  calc\n    _ = \u2016\u222b y in Annulus.cc x' (D ^ (s I - 1) / 4) (D ^ s\u2082 / 2), K' (s I) s\u2082 x' y * f y\u2016\u2091 := by\n      rw [\u2190 integral_indicator Annulus.measurableSet_cc]\n      congr\n      ext y\n      by_cases hy : y \u2208 Annulus.cc x' (D ^ (s I - 1) / 4) (D ^ s\u2082 / 2)\n      \u00b7 simp only [K', hy, indicator_of_mem]\n      \u00b7 have K'_eq_zero := nmem_support.mp <| not_mem_subset (K'.support_subset (s I) s\u2082 x') hy\n        rw [\u2190 K', K'_eq_zero, zero_mul, indicator_of_not_mem hy]\n    _ \u2264 \u2016\u222b y in Annulus.oo x' (8 * D ^ (s I)) (D ^ (s\u2082 - 1) / 4), K' (s I) s\u2082 x' y * f y\u2016\u2091 +\n          ((\u222b\u207b y in Annulus.cc x' (D ^ (s I - 1) / 4) (8 * D ^ (s I)), \u2016K' (s I) s\u2082 x' y * f y\u2016\u2091) +\n          \u222b\u207b y in Annulus.cc x' (D ^ (s\u2082 - 1) / 4) (D ^ s\u2082 / 2), \u2016K' (s I) s\u2082 x' y * f y\u2016\u2091) := by\n      apply annulus_integral_bound\n      \u00b7 exact (ineq four_pos).le\n      \u00b7 gcongr\n        \u00b7 exact one_lt_D (X := X) |>.le\n        \u00b7 exact sub_one_lt s\u2082 |>.le\n        \u00b7 norm_num\n      \u00b7 refine K'.integrableOn_mul_f x' hf (ENNReal.ofReal (D ^ (s I - 1) / 4)) ?_ (s I) s\u2082\n          |>.mono_set ?_\n        \u00b7 exact ENNReal.ofReal_pos.mpr <| div_pos (defaultD_pow_pos a (s I - 1)) four_pos\n        \u00b7 rw [EAnnulus.ci_eq_annulus]\n          exact Annulus.cc_subset_ci (le_refl _)\n    _ \u2264 \u2016\u222b y in Annulus.oo x' (8 * D ^ (s I)) (D ^ (s\u2082 - 1) / 4), K x' y * f y\u2016\u2091 +\n          ((\u222b\u207b y in Annulus.cc x' (D ^ (s I - 1) / 4) (8 * D ^ (s I)), \u2016K x' y * f y\u2016\u2091) +\n          \u222b\u207b y in Annulus.cc x' (D ^ (s\u2082 - 1) / 4) (D ^ s\u2082 / 2), \u2016K x' y * f y\u2016\u2091) := by\n      have norm_K'_f_le : \u2200 (y : X), \u2016K' (s I) s\u2082 x' y * f y\u2016\u2091 \u2264 \u2016K x' y * f y\u2016\u2091 := by\n        simp_rw [enorm_mul]\n        exact fun y \u21a6 mul_le_mul_of_nonneg_right (K'.enorm_le_enorm_K _ _ _ _) (zero_le _)\n      gcongr\n      \u00b7 refine (congrArg (\u2016\u00b7\u2016\u2091) <| setIntegral_congr_fun Annulus.measurableSet_oo fun y hy \u21a6 ?_).le\n        apply mul_eq_mul_right_iff.mpr \u2218 Or.inl \u2218 K'.eq_K (s I) s\u2082 x' y\n        simp only [Annulus.oo, mem_Ioo, mem_setOf_eq] at hy\n        have i1 := hy.1\n        have i2 := hy.2.le\n        refine mem_Icc.mpr \u27e8(lt_trans (ineq two_pos) i1).le, i2.trans ?_\u27e9\n        rw [zpow_sub\u2080 (defaultD_pos a).ne.symm, div_div, zpow_one]\n        have : (D : \u211d) * 4 > 0 := mul_pos (defaultD_pos a) four_pos\n        apply (div_le_div_iff_of_pos_left (defaultD_pow_pos a s\u2082) this four_pos).mpr\n        norm_cast\n        linarith [defaultD_pos' a]\n      \u00b7 exact norm_K'_f_le _\n      \u00b7 exact norm_K'_f_le _\n    _ \u2264 nontangentialOperator K f x + (2 ^ (7 * (a : \u211d) + 101 * a ^ 3) * MB volume \ud835\udcd1 c\ud835\udcd1 r\ud835\udcd1 f x +\n          2 ^ (7 * (a : \u211d) + 101 * a ^ 3) * MB volume \ud835\udcd1 c\ud835\udcd1 r\ud835\udcd1 f x) := by\n      gcongr\n      \u00b7 apply nontangential_integral_bound\u2081 (D ^ (s\u2082 - 1) / 4)\n        apply lt_of_le_of_lt (dist_triangle x (c I) x')\n        replace hI := mem_ball.mp (Grid_subset_ball hI)\n        replace hx' := mem_ball'.mp (Grid_subset_ball hx')\n        apply lt_of_lt_of_eq (add_lt_add hI hx')\n        unfold s\n        ring\n      \u00b7 exact nontangential_integral_bound\u2082 hf hI hx' (le_refl _)\n      \u00b7 let I\u2082 := cubeOf s\u2082 x\n        have hs\u2082' : s\u2082 \u2208 Icc (-(S : \u2124)) (S : \u2124) :=\n          Icc_subset_Icc (Set.range_subset_iff.mp range_s_subset I |>.1) (le_refl (S : \u2124)) hs\u2082\n        have \u27e8xI\u2082, hI\u2082\u27e9 := cubeOf_spec hs\u2082' I hI\n        rw [\u2190 hI\u2082]\n        have : s I \u2264 s I\u2082 := by rw [hI\u2082]; exact hs\u2082.1\n        have := (fundamental_dyadic this).resolve_right (Set.not_disjoint_iff.mpr \u27e8x, \u27e8hI, xI\u2082\u27e9\u27e9)\n        apply nontangential_integral_bound\u2082 hf xI\u2082 (this hx')\n        linarith [defaultD_pow_pos a (s (cubeOf s\u2082 x))]\n    _ = _ := by\n      rw [\u2190 two_mul, \u2190 mul_assoc, add_assoc, ENNReal.rpow_add 1 _ two_ne_zero ENNReal.ofNat_ne_top,\n        ENNReal.rpow_one]\n\n/-- Lemma 7.2.2. -/\nlemma nontangential_operator_bound\n    (hf : BoundedCompactSupport f)\n    (\u03b8 : \u0398 X) :\n    eLpNorm (nontangentialMaximalFunction \u03b8 f \u00b7) 2 volume \u2264 (C7_2_2 a) * eLpNorm f 2 volume := by\n  have ha : 4 \u2264 (a : \u211d) := by exact_mod_cast four_le_a X\n  have aemeas_MB : AEMeasurable (MB volume \ud835\udcd1 c\ud835\udcd1 r\ud835\udcd1 f \u00b7) :=\n    (AEStronglyMeasurable.maximalFunction (to_countable \ud835\udcd1)).aemeasurable\n  have \u27e8hT\u2081, hT\u2082\u27e9 := hasBoundedStrongType_Tstar f (hf.mem\u2112p 2) hf.mem\u2112p_top.eLpNorm_lt_top\n    hf.isBoundedSupport.measure_lt_top\n  calc eLpNorm (nontangentialMaximalFunction \u03b8 f) 2 volume\n    _ \u2264 eLpNorm (fun x \u21a6 nontangentialOperator K f x +\n          2 ^ (1 + 7 * (a : \u211d) + 101 * a ^ 3) * MB volume \ud835\udcd1 c\ud835\udcd1 r\ud835\udcd1 f x) 2 volume := by\n      simp only [eLpNorm, OfNat.ofNat_ne_zero, reduceIte, ENNReal.ofNat_ne_top, eLpNorm']\n      gcongr\n      exact nontangential_pointwise_bound hf \u03b8 _\n    _ \u2264 eLpNorm (nontangentialOperator K f) 2 volume +\n          eLpNorm ((2 : \u211d\u22650\u221e) ^ (1 + 7 * (a : \u211d) + 101 * a ^ 3) *\n          MB volume \ud835\udcd1 c\ud835\udcd1 r\ud835\udcd1 f \u00b7) 2 volume := by\n      simpa [eLpNorm, eLpNorm'] using\n        ENNReal.lintegral_Lp_add_le hT\u2081.aemeasurable (aemeas_MB.const_mul _) one_le_two\n    _ = eLpNorm (nontangentialOperator K f) 2 volume +\n          2 ^ (1 + 7 * (a : \u211d) + 101 * a ^ 3) * eLpNorm (MB volume \ud835\udcd1 c\ud835\udcd1 r\ud835\udcd1 f \u00b7) 2 volume := by\n      congr\n      simp only [eLpNorm, eLpNorm', OfNat.ofNat_ne_zero, reduceIte, ENNReal.ofNat_ne_top]\n      convert ENNReal.lintegral_Lp_smul aemeas_MB two_pos ((2 : \u211d\u22650) ^ (1 + 7 * a + 101 * a ^ 3))\n      \u00b7 congr; norm_cast\n      \u00b7 ext; rw [ENNReal.smul_def]; norm_cast\n    _ \u2264 (C_Ts a + 2 ^ (1 + 7 * a + 101 * a ^ 3 : \u211d) * CMB (defaultA a) 2) * eLpNorm f 2 volume := by\n      rw [add_mul, mul_assoc]; gcongr; exact eLpNorm_MB_le hf\n    _ \u2264 ((2 ^ a ^ 3) + 2 ^ (1 + 7 * a + 101 * a ^ 3) * (2 ^ (2 * a))) * eLpNorm f 2 volume := by\n      rw [C_Ts, CMB_defaultA_two_eq]\n      gcongr <;> norm_cast\n      simp only [Nat.cast_pow, Nat.cast_ofNat, \u2190 NNReal.rpow_natCast]\n      apply NNReal.rpow_le_rpow_of_exponent_le one_le_two\n      rw [Nat.cast_mul]\n      linarith\n    _ \u2264 (C7_2_2 a) * eLpNorm f 2 volume := by\n      rw [\u2190 ENNReal.rpow_natCast, Nat.cast_pow]\n      exact mul_right_mono <| calc 2 ^ (a : \u211d) ^ 3 + 2 ^ (1 + 7 * a + 101 * a ^ 3) * 2 ^ (2 * a)\n        _ \u2264 (2 : \u211d\u22650\u221e) ^ ((101.6 : \u211d) * a ^ 3) + (2 : \u211d\u22650\u221e) ^ ((101.6 : \u211d) * a ^ 3) := by\n          gcongr\n          \u00b7 exact one_le_two\n          \u00b7 linarith [pow_pos (cast_a_pos X) 3]\n          \u00b7 simp_rw [\u2190 pow_add, \u2190 ENNReal.rpow_natCast, Nat.cast_add, Nat.cast_mul, Nat.cast_pow]\n            apply ENNReal.rpow_le_rpow_of_exponent_le one_le_two\n            linarith [show 4 ^ 2 * (a : \u211d) \u2264 a ^ 2 * a by gcongr]\n        _ = (2 : \u211d\u22650\u221e) ^ (101.6 * (a : \u211d) ^ 3 + 1) := by\n          rw [\u2190 mul_two, ENNReal.rpow_add _ _ two_ne_zero ENNReal.ofNat_ne_top, ENNReal.rpow_one]\n        _ \u2264 C7_2_2 a := by\n          have := ENNReal.coe_rpow_def 2 (102 * a ^ 3)\n          simp only [ENNReal.coe_ofNat, OfNat.ofNat_ne_zero, false_and, reduceIte] at this\n          rw [C7_2_2, \u2190 this]\n          apply ENNReal.rpow_le_rpow_of_exponent_le one_le_two\n          linarith [show 0.4 * 4 ^ 3 \u2264 (0.4 : \u211d) * a ^ 3 by gcongr]\n\n/-- The set of cubes in Lemma 7.2.4. -/\ndef kissing (I : Grid X) : Finset (Grid X) :=\n  {J | s J = s I \u2227 \u00acDisjoint (ball (c I) (16 * D ^ s I)) (ball (c J) (16 * D ^ s J))}\n\nlemma subset_of_kissing (h : J \u2208 kissing I) :\n    ball (c J) (D ^ s J / 4) \u2286 ball (c I) (33 * D ^ s I) := by\n  simp_rw [kissing, Finset.mem_filter, Finset.mem_univ, true_and] at h\n  obtain \u27e8x, xI, xJ\u27e9 := not_disjoint_iff.mp h.2\n  apply ball_subset_ball'\n  calc\n    _ \u2264 D ^ s J / 4 + dist (c J) x + dist x (c I) := by\n      rw [add_assoc]; exact add_le_add_left (dist_triangle ..) _\n    _ \u2264 D ^ s J / 4 + 16 * D ^ s J + 16 * D ^ s I := by\n      gcongr\n      \u00b7 exact (mem_ball'.mp xJ).le\n      \u00b7 exact (mem_ball.mp xI).le\n    _ \u2264 _ := by\n      rw [h.1, div_eq_mul_inv, mul_comm _ 4\u207b\u00b9, \u2190 distrib_three_right]\n      gcongr\n      norm_num\n\nlemma volume_le_of_kissing (h : J \u2208 kissing I) :\n    volume (ball (c I) (33 * D ^ s I)) \u2264 2 ^ (9 * a) * volume (ball (c J) (D ^ s J / 4)) := by\n  simp_rw [kissing, Finset.mem_filter, Finset.mem_univ, true_and] at h\n  obtain \u27e8x, xI, xJ\u27e9 := not_disjoint_iff.mp h.2\n  have : ball (c I) (33 * D ^ s I) \u2286 ball (c J) (128 * D ^ s J) := by\n    apply ball_subset_ball'\n    calc\n      _ \u2264 33 * D ^ s I + dist (c I) x + dist x (c J) := by\n        rw [add_assoc]; exact add_le_add_left (dist_triangle ..) _\n      _ \u2264 33 * D ^ s I + 16 * D ^ s I + 16 * D ^ s J := by\n        gcongr\n        \u00b7 exact (mem_ball'.mp xI).le\n        \u00b7 exact (mem_ball.mp xJ).le\n      _ \u2264 _ := by\n        rw [h.1, \u2190 distrib_three_right]\n        gcongr; norm_num\n  have double := measure_ball_le_pow_two' (\u03bc := volume) (x := c J) (r := D ^ s J / 4) (n := 9)\n  have A9 : (defaultA a : \u211d\u22650) ^ 9 = (2 : \u211d\u22650\u221e) ^ (9 * a) := by\n    simp only [defaultA]; norm_cast; ring\n  rw [show (2 : \u211d) ^ 9 * (D ^ s J / 4) = 128 * D ^ s J by ring, A9] at double\n  exact (measure_mono this).trans double\n\nlemma pairwiseDisjoint_of_kissing :\n    (kissing I).toSet.PairwiseDisjoint fun i \u21a6 ball (c i) (D ^ s i / 4) := fun j mj k mk hn \u21a6 by\n  apply disjoint_of_subset ball_subset_Grid ball_subset_Grid\n  simp_rw [Finset.mem_coe, kissing, Finset.mem_filter] at mj mk\n  exact (eq_or_disjoint (mj.2.1.trans mk.2.1.symm)).resolve_left hn\n\n/-- Lemma 7.2.4. -/\nlemma boundary_overlap (I : Grid X) : (kissing I).card \u2264 2 ^ (9 * a) := by\n  have key : (kissing I).card * volume (ball (c I) (33 * D ^ s I)) \u2264\n      2 ^ (9 * a) * volume (ball (c I) (33 * D ^ s I)) := by\n    calc\n      _ = \u2211 _ \u2208 kissing I, volume (ball (c I) (33 * D ^ s I)) := by\n        rw [Finset.sum_const, nsmul_eq_mul]\n      _ \u2264 \u2211 J \u2208 kissing I, 2 ^ (9 * a) * volume (ball (c J) (D ^ s J / 4)) :=\n        Finset.sum_le_sum fun _ \u21a6 volume_le_of_kissing\n      _ = 2 ^ (9 * a) * volume (\u22c3 J \u2208 kissing I, ball (c J) (D ^ s J / 4)) := by\n        rw [\u2190 Finset.mul_sum]; congr\n        exact (measure_biUnion_finset pairwiseDisjoint_of_kissing fun _ _ \u21a6 measurableSet_ball).symm\n      _ \u2264 _ := by gcongr; exact iUnion\u2082_subset fun _ \u21a6 subset_of_kissing\n  have vn0 : volume (ball (c I) (33 * D ^ s I)) \u2260 0 := by\n    refine (measure_ball_pos volume _ ?_).ne'; simp only [defaultD]; positivity\n  rw [ENNReal.mul_le_mul_right vn0 (measure_ball_ne_top _ _)] at key; norm_cast at key\n\nirreducible_def C7_2_3 (a : \u2115) : \u211d\u22650 := 2 ^ (12 * (a : \u211d))\n\n/-- Lemma 7.2.3. -/\nlemma boundary_operator_bound\n    (hf : BoundedCompactSupport f) (hu : u \u2208 t) :\n    eLpNorm (boundaryOperator t u f) 2 volume \u2264 (C7_2_3 a) * eLpNorm f 2 volume := by\n  sorry\n\n/-- The constant used in `tree_projection_estimate`.\nOriginally had value `2 ^ (104 * a ^ 3)` in the blueprint, but that seems to be a mistake. -/\n-- Todo: define this recursively in terms of previous constants\nirreducible_def C7_2_1 (a : \u2115) : \u211d\u22650 := 2 ^ (152 * (a : \u211d) ^ 3)\n\n-- Auxiliary function used in the proof of Lemma 7.2.1\nprivate def eI\ud835\udcacu_mul (u : \ud835\udd13 X) (f : X \u2192 \u2102) : X \u2192 \u2102 := fun y \u21a6 exp (.I * \ud835\udcac u y) * f y\n\n", "theoremStatement": "private lemma boundedCompactSupport_eI\ud835\udcacu_mul (u : \ud835\udd13 X) {f : X \u2192 \u2102} (hf : BoundedCompactSupport f) :\n    BoundedCompactSupport (eI\ud835\udcacu_mul u f) ", "theoremName": "TileStructure.Forest.boundedCompactSupport_eI\ud835\udcacu_mul", "fileCreated": {"commit": "5e49c3692f6d7344434caa7eea5f412f0ee35863", "date": "2024-09-27"}, "theoremCreated": {"commit": "0138d636eed1475ea5e848ef6cf4b141636056cc", "date": "2025-01-20"}, "file": "carleson/Carleson/ForestOperator/L2Estimate.lean", "module": "Carleson.ForestOperator.L2Estimate", "jsonFile": "Carleson.ForestOperator.L2Estimate.jsonl", "positionMetadata": {"lineInFile": 444, "tokenPositionInFile": 22789, "theoremPositionInFile": 23}, "dependencyMetadata": {"inFilePremises": null, "numInFilePremises": null, "repositoryPremises": null, "numRepositoryPremises": null, "numPremises": null}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  apply hf.mul_bdd_left\n  \u00b7 refine isBounded_iff_forall_norm_le.mpr \u27e81, fun _ h \u21a6 ?_\u27e9\n    obtain \u27e8_, rfl\u27e9 := mem_range.mp h\n    rw [mul_comm, norm_exp_ofReal_mul_I]\n  \u00b7 apply measurable_exp.stronglyMeasurable.comp_measurable\n    exact (measurable_ofReal.comp' (map_continuous (\ud835\udcac u)).measurable).const_mul I", "proofType": "tactic", "proofLengthLines": 6, "proofLengthTokens": 312}}
