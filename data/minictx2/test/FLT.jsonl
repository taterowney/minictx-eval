{"srcContext": "import Mathlib.Topology.Algebra.UniformRing\nimport FLT.Mathlib.Algebra.Algebra.Hom\n\n/-!\n# Completion of topological rings\n-/\n\nnamespace UniformSpace.Completion\n\nvariable {\u03b1 : Type*} [Ring \u03b1] [UniformSpace \u03b1] [TopologicalRing \u03b1] [UniformAddGroup \u03b1]\n  {\u03b2 : Type*} [UniformSpace \u03b2] [Ring \u03b2] [UniformAddGroup \u03b2] [TopologicalRing \u03b2]\n  (f : \u03b1 \u2192+* \u03b2) (hf : Continuous f)\n\n", "theoremStatement": "theorem mapRingHom_apply {x : UniformSpace.Completion \u03b1} :\n    UniformSpace.Completion.mapRingHom f hf x = UniformSpace.Completion.map f x ", "theoremName": "UniformSpace.Completion.mapRingHom_apply", "fileCreated": {"commit": "f463c53242f2ad3f5bdbee5b2078741ebf425207", "date": "2025-01-31"}, "theoremCreated": {"commit": "127241373eb7d4afd5ff86dc0e5082497c364f08", "date": "2025-02-05"}, "file": "FLT/FLT/Mathlib/Topology/Algebra/UniformRing.lean", "module": "FLT.Mathlib.Topology.Algebra.UniformRing", "jsonFile": "FLT.Mathlib.Topology.Algebra.UniformRing.jsonl", "positionMetadata": {"lineInFile": 14, "tokenPositionInFile": 365, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 21}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "import Mathlib.LinearAlgebra.Determinant\n\nnamespace LinearMap\nvariable {R : Type*} [CommRing R]\n\n", "theoremStatement": "@[simp] lemma det_mul (a : R) : (mul R R a).det = a ", "theoremName": "LinearMap.det_mul", "fileCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "theoremCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "file": "FLT/FLT/Mathlib/LinearAlgebra/Determinant.lean", "module": "FLT.Mathlib.LinearAlgebra.Determinant", "jsonFile": "FLT.Mathlib.LinearAlgebra.Determinant.jsonl", "positionMetadata": {"lineInFile": 6, "tokenPositionInFile": 97, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 118}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  classical\n  rw [det_eq_det_toMatrix_of_finset (s := {1}) \u27e8(Finsupp.LinearEquiv.finsuppUnique R R _).symm\u27e9,\n    Matrix.det_unique]\n  change a * _ = a\n  simp", "proofType": "tactic", "proofLengthLines": 5, "proofLengthTokens": 163}}
{"srcContext": "import Mathlib -- because there are sorries in this file\nimport FLT.Mathlib.Algebra.Order.Hom.Monoid\nimport FLT.Mathlib.Algebra.Algebra.Hom\nimport FLT.Mathlib.Algebra.Algebra.Pi\nimport FLT.Mathlib.Algebra.Algebra.Bilinear\nimport FLT.Mathlib.Topology.Algebra.UniformRing\n\n\n/-!\n\n# Base change of adele rings.\n\nIf `A` is a Dedekind domain with field of fractions `K`, if `L/K` is a finite separable\nextension and if `B` is the integral closure of `A` in `L`, then `B` is also a Dedekind\ndomain. Hence the rings of finite adeles `\ud835\udd38_K^\u221e` and `\ud835\udd38_L^\u221e` (defined using `A` and `B`)\nare defined. In this file we define the natural `K`-algebra map `\ud835\udd38_K^\u221e \u2192 \ud835\udd38_L^\u221e` and\nthe natural `L`-algebra map `\ud835\udd38_K^\u221e \u2297[K] L \u2192 \ud835\udd38_L^\u221e`, and show that the latter map\nis an isomorphism.\n\n## Main definition\n\n* `FiniteAdeleRing.baseChangeEquiv : L \u2297[K] FiniteAdeleRing A K \u2243\u2090[L] FiniteAdeleRing B L`\n\n-/\n\nopen scoped Multiplicative\n\n-- The general set-up.\n\nvariable (A K L B : Type*) [CommRing A] [CommRing B] [Algebra A B] [Field K] [Field L]\n    [Algebra A K] [IsFractionRing A K] [Algebra B L] [IsDedekindDomain A]\n    [Algebra K L] [Algebra A L] [IsScalarTower A B L] [IsScalarTower A K L]\n    [IsIntegralClosure B A L] [FiniteDimensional K L]\n\nvariable [Algebra.IsSeparable K L]\n\nexample : Function.Injective (algebraMap B L) := IsIntegralClosure.algebraMap_injective' A\n\nexample : IsDomain B := by\n  have foo : Function.Injective (algebraMap B L) := IsIntegralClosure.algebraMap_injective' A\n  have bar : IsDomain L := inferInstance\n  exact Function.Injective.isDomain _ foo -- exact? failed\nvariable [IsDomain B]\n\nexample : Algebra.IsIntegral A B := IsIntegralClosure.isIntegral_algebra A L\nvariable [Algebra.IsIntegral A B]\n\nexample : Module.Finite A B :=\n  have := IsIntegralClosure.isNoetherian A K L B\n  Module.IsNoetherian.finite A B\nvariable [Module.Finite A B]\n\nexample : IsDedekindDomain B := IsIntegralClosure.isDedekindDomain A K L B\nvariable [IsDedekindDomain B]\n\nexample : IsFractionRing B L := IsIntegralClosure.isFractionRing_of_finite_extension A K L B\nvariable [IsFractionRing B L]\n\n-- We start by filling in some holes in the API for finite extensions of Dedekind domains.\nnamespace IsDedekindDomain\n\nnamespace HeightOneSpectrum\n\n-- first need a way to pull back valuations on B to A\nvariable {B L} in\ndef comap (w : HeightOneSpectrum B) : HeightOneSpectrum A where\n  asIdeal := w.asIdeal.comap (algebraMap A B)\n  isPrime := Ideal.comap_isPrime (algebraMap A B) w.asIdeal\n  ne_bot := mt Ideal.eq_bot_of_comap_eq_bot w.ne_bot\n\nomit [Module.Finite A B] in\nlemma mk_count_factors_map\n    (hAB : Function.Injective (algebraMap A B))\n    (w : HeightOneSpectrum B) (I : Ideal A) [DecidableEq (Associates (Ideal A))]\n  [DecidableEq (Associates (Ideal B))] [\u2200 p : Associates (Ideal A), Decidable (Irreducible p)]\n  [\u2200 p : Associates (Ideal B), Decidable (Irreducible p)] :\n    (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) I)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk I).factors := by\n  classical\n  induction I using UniqueFactorizationMonoid.induction_on_prime with\n  | h\u2081 =>\n    rw [Associates.mk_zero, Ideal.zero_eq_bot, Ideal.map_bot, \u2190 Ideal.zero_eq_bot,\n      Associates.mk_zero]\n    simp [Associates.count, Associates.factors_zero, w.associates_irreducible,\n      associates_irreducible (comap A w), Associates.bcount]\n  | h\u2082 I hI =>\n    obtain rfl : I = \u22a4 := by simpa using hI\n    simp only [Submodule.zero_eq_bot, ne_eq, top_ne_bot, not_false_eq_true, Ideal.map_top]\n    simp only [\u2190 Ideal.one_eq_top, Associates.mk_one, Associates.factors_one]\n    rw [Associates.count_zero (associates_irreducible _),\n      Associates.count_zero (associates_irreducible _), mul_zero]\n  | h\u2083 I p hI hp IH =>\n    simp only [Ideal.map_mul, \u2190 Associates.mk_mul_mk]\n    have hp_bot : p \u2260 \u22a5 := hp.ne_zero\n    have hp_bot' := (Ideal.map_eq_bot_iff_of_injective hAB).not.mpr hp_bot\n    have hI_bot := (Ideal.map_eq_bot_iff_of_injective hAB).not.mpr hI\n    rw [Associates.count_mul (Associates.mk_ne_zero.mpr hp_bot) (Associates.mk_ne_zero.mpr hI)\n      (associates_irreducible _), Associates.count_mul (Associates.mk_ne_zero.mpr hp_bot')\n      (Associates.mk_ne_zero.mpr hI_bot) (associates_irreducible _)]\n    simp only [IH, mul_add]\n    congr 1\n    by_cases hw : (w.comap A).asIdeal = p\n    \u00b7 have : Irreducible (Associates.mk p) := Associates.irreducible_mk.mpr hp.irreducible\n      rw [hw, Associates.factors_self this, Associates.count_some this]\n      simp only [UniqueFactorizationMonoid.factors_eq_normalizedFactors, Multiset.nodup_singleton,\n        Multiset.mem_singleton, Multiset.count_eq_one_of_mem, mul_one]\n      rw [count_associates_factors_eq hp_bot' w.2 w.3,\n        Ideal.IsDedekindDomain.ramificationIdx_eq_normalizedFactors_count hp_bot' w.2 w.3]\n    \u00b7 have : (Associates.mk (comap A w).asIdeal).count (Associates.mk p).factors = 0 :=\n        Associates.count_eq_zero_of_ne (associates_irreducible _)\n          (Associates.irreducible_mk.mpr hp.irreducible)\n          (by rwa [ne_eq, Associates.mk_eq_mk_iff_associated, associated_iff_eq])\n      rw [this, mul_zero, eq_comm]\n      by_contra H\n      rw [eq_comm, \u2190 ne_eq, Associates.count_ne_zero_iff_dvd hp_bot' (irreducible w),\n        Ideal.dvd_iff_le, Ideal.map_le_iff_le_comap] at H\n      apply hw (((Ideal.isPrime_of_prime hp).isMaximal hp_bot).eq_of_le (comap A w).2.ne_top H).symm\n\nomit [Module.Finite A B] in\nlemma intValuation_comap (hAB : Function.Injective (algebraMap A B))\n    (w : HeightOneSpectrum B) (x : A) :\n    (comap A w).intValuation x ^\n    (Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal) =\n    w.intValuation (algebraMap A B x) := by\n  classical\n  have h_ne_zero : Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal \u2260 0 :=\n    Ideal.IsDedekindDomain.ramificationIdx_ne_zero\n      ((Ideal.map_eq_bot_iff_of_injective hAB).not.mpr (comap A w).3) w.2 Ideal.map_comap_le\n  by_cases hx : x = 0\n  \u00b7 simpa [hx]\n  simp only [intValuation, Valuation.coe_mk, MonoidWithZeroHom.coe_mk, ZeroHom.coe_mk]\n  show (ite _ _ _) ^ _ = ite _ _ _\n  by_cases hx : x = 0\n  \u00b7 subst hx; simp [h_ne_zero]\n  rw [map_eq_zero_iff _ hAB, if_neg hx, if_neg hx, \u2190 Set.image_singleton, \u2190 Ideal.map_span,\n    mk_count_factors_map _ _ hAB, mul_comm]\n  simp\n\n-- Need to know how the valuation `w` and its pullback are related on elements of `K`.\nomit [IsIntegralClosure B A L] [FiniteDimensional K L] [Algebra.IsSeparable K L]\n    [Module.Finite A B] in\nlemma valuation_comap (w : HeightOneSpectrum B) (x : K) :\n    (comap A w).valuation x ^\n    (Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal) =\n    w.valuation (algebraMap K L x) := by\n  obtain \u27e8x, y, hy, rfl\u27e9 := IsFractionRing.div_surjective (A := A) x\n  simp [valuation, \u2190 IsScalarTower.algebraMap_apply A K L, IsScalarTower.algebraMap_apply A B L,\n    \u2190 intValuation_comap A B (algebraMap_injective_of_field_isFractionRing A B K L), div_pow]\n\nomit [IsIntegralClosure B A L] [FiniteDimensional K L] [Algebra.IsSeparable K L]\n    [Module.Finite A B] in\n", "theoremStatement": "lemma _root_.IsDedekindDomain.HeightOneSpectrum.adicValued.continuous_algebraMap\n    (v : HeightOneSpectrum A) (w : HeightOneSpectrum B) (hvw : v = comap A w) :\n    letI : UniformSpace K := v.adicValued.toUniformSpace;\n    letI : UniformSpace L := w.adicValued.toUniformSpace;\n    Continuous (algebraMap K L) ", "theoremName": "IsDedekindDomain.HeightOneSpectrum.adicValued.continuous_algebraMap", "fileCreated": {"commit": "17ea847a3d0172f39eea0bc008cd70a2755df629", "date": "2024-11-01"}, "theoremCreated": {"commit": "f463c53242f2ad3f5bdbee5b2078741ebf425207", "date": "2025-01-31"}, "file": "FLT/FLT/DedekindDomain/FiniteAdeleRing/BaseChange.lean", "module": "FLT.DedekindDomain.FiniteAdeleRing.BaseChange", "jsonFile": "FLT.DedekindDomain.FiniteAdeleRing.BaseChange.jsonl", "positionMetadata": {"lineInFile": 153, "tokenPositionInFile": 7135, "theoremPositionInFile": 3}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 3, "numPremises": 287}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  letI : UniformSpace K := v.adicValued.toUniformSpace;\n  letI : UniformSpace L := w.adicValued.toUniformSpace;\n  subst hvw\n  refine continuous_of_continuousAt_zero (algebraMap K L) ?hf\n  delta ContinuousAt\n  simp only [map_zero]\n  rw [(@Valued.hasBasis_nhds_zero K _ _ _ (comap A w).adicValued).tendsto_iff\n    (@Valued.hasBasis_nhds_zero L _ _ _ w.adicValued)]\n  simp only [HeightOneSpectrum.adicValued_apply, Set.mem_setOf_eq, true_and, true_implies]\n  rw [WithZero.unitsWithZeroEquiv.forall_congr_left, Multiplicative.forall]\n  intro a\n  rw [WithZero.unitsWithZeroEquiv.exists_congr_left, Multiplicative.exists]\n  let m := Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal\n  let e : \u2124 \u2243 \u2124\u2098\u2080\u02e3 := Multiplicative.ofAdd.trans OrderMonoidIso.unitsWithZero.symm.toEquiv\n  have e_apply (a : \u2124) : e a = OrderMonoidIso.unitsWithZero.symm (Multiplicative.ofAdd a) := rfl\n  have hm : m \u2260 0 := by\n    refine Ideal.IsDedekindDomain.ramificationIdx_ne_zero ?_ w.2 Ideal.map_comap_le\n    exact (Ideal.map_eq_bot_iff_of_injective\n      (algebraMap_injective_of_field_isFractionRing A B K L)).not.mpr (comap A w).3\n  refine \u27e8a / m, fun x hx \u21a6 ?_\u27e9\n  simp_rw [\u2190 valuation_comap A]\n  calc\n    (comap A w).valuation x ^ m < e (a / \u2191m) ^ m := by gcongr; exacts [zero_le', hx]\n  _ = e (m \u2022 (a / \u2191m)) := by\n    dsimp [e]\n    norm_cast\n    rw [map_pow]\n  _ \u2264 e a := by\n    simp only [nsmul_eq_mul, e_apply, Units.val_le_val, OrderIsoClass.map_le_map_iff]\n    rw [mul_comm]\n    exact Int.mul_le_of_le_ediv (by positivity) le_rfl", "proofType": "tactic", "proofLengthLines": 31, "proofLengthTokens": 1531}}
{"srcContext": "import Mathlib.Algebra.Algebra.Hom\n\nsection semialghom\n\n/-- Let `\u03c6 : R \u2192+* S` be a ring homomorphism, let `A` be an `R`-algebra and let `B` be\nan `S`-algebra. Then `SemialgHom \u03c6 A B` or `A \u2192\u209b\u2090[\u03c6] B` is the ring homomorphisms `\u03c8 : A \u2192+* B`\nmaking lying above `\u03c6` (i.e. such that `\u03c8 (r \u2022 a) = \u03c6 r \u2022 \u03c8 a`).\n-/\nstructure SemialgHom {R S : Type*} [CommSemiring R] [CommSemiring S] (\u03c6 : R \u2192+* S)\n    (A B : Type*)  [Semiring A] [Semiring B] [Algebra R A] [Algebra S B]\n    extends A \u2192\u209b\u2097[\u03c6] B, RingHom A B\n\n@[inherit_doc SemialgHom]\ninfixr:25 \" \u2192\u209b\u2090 \" => SemialgHom _\n\n@[inherit_doc]\nnotation:25 A \" \u2192\u209b\u2090[\" \u03c6:25 \"] \" B:0 => SemialgHom \u03c6 A B\n\nvariable {R S : Type*} [CommSemiring R] [CommSemiring S] (\u03c6 : R \u2192+* S)\n    (A B : Type*)  [Semiring A] [Semiring B] [Algebra R A] [Algebra S B]\n\ninstance instFunLike : FunLike (A \u2192\u209b\u2090[\u03c6] B) A B where\n  coe f := f.toFun\n  coe_injective' f g h := by\n    cases f\n    cases g\n    congr\n    exact DFunLike.coe_injective' h\n\nvariable {\u03c6} {A} {B} in\n", "theoremStatement": "lemma SemialgHom.map_smul (\u03c8 : A \u2192\u209b\u2090[\u03c6] B) (m : R) (x : A) : \u03c8 (m \u2022 x) = \u03c6 m \u2022 \u03c8 x ", "theoremName": "SemialgHom.map_smul", "fileCreated": {"commit": "f463c53242f2ad3f5bdbee5b2078741ebf425207", "date": "2025-01-31"}, "theoremCreated": {"commit": "f463c53242f2ad3f5bdbee5b2078741ebf425207", "date": "2025-01-31"}, "file": "FLT/FLT/Mathlib/Algebra/Algebra/Hom.lean", "module": "FLT.Mathlib.Algebra.Algebra.Hom", "jsonFile": "FLT.Mathlib.Algebra.Algebra.Hom.jsonl", "positionMetadata": {"lineInFile": 31, "tokenPositionInFile": 975, "theoremPositionInFile": 2}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 3, "numPremises": 19}, "proofMetadata": {"hasProof": true, "proof": ":=\n  LinearMap.map_smul' \u03c8.toLinearMap m x", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 42}}
{"srcContext": "import Mathlib.Algebra.CharZero.Infinite\nimport Mathlib.NumberTheory.Padics.PadicIntegers\nimport FLT.Mathlib.GroupTheory.Index\n\n/-!\n# TODO\n\n* Rename `Coe.ringHom` to `coeRingHom`\n* Protect `PadicInt.norm_mul`, `PadicInt.norm_units`, `PadicInt.norm_pow`\n-/\n\nopen Function Topology Subgroup\nopen scoped NNReal nonZeroDivisors Pointwise\n\nvariable {p : \u2115} [Fact p.Prime]\n\nnamespace PadicInt\nvariable {x : \u2124_[p]}\n\nattribute [simp] coe_eq_zero\n\n@[simp, norm_cast] lemma coe_coeRingHom : \u21d1(Coe.ringHom (p := p)) = (\u2191) := rfl\n\nlemma coe_injective : Injective ((\u2191) : \u2124_[p] \u2192 \u211a_[p]) := Subtype.val_injective\n\n@[simp] lemma coe_inj {x y : \u2124_[p]} : (x : \u211a_[p]) = (y : \u211a_[p]) \u2194 x = y := coe_injective.eq_iff\n\ninstance : Infinite \u2124_[p] := CharZero.infinite _\n\n@[simp]\nprotected lemma nnnorm_mul (x y : \u2124_[p]) : \u2016x * y\u2016\u208a = \u2016x\u2016\u208a * \u2016y\u2016\u208a := by simp [nnnorm, NNReal]\n\n@[simp]\nprotected lemma nnnorm_pow (x : \u2124_[p]) (n : \u2115) : \u2016x ^ n\u2016\u208a = \u2016x\u2016\u208a ^ n := by simp [nnnorm, NNReal]\n\n@[simp] lemma nnnorm_p : \u2016(p : \u2124_[p])\u2016\u208a = (p : \u211d\u22650)\u207b\u00b9 := by simp [nnnorm]; rfl\n\n@[simp] protected lemma nnnorm_units (u : \u2124_[p]\u02e3) : \u2016(u : \u2124_[p])\u2016\u208a = 1 := by simp [nnnorm, NNReal]\n\nlemma exists_unit_mul_p_pow_eq (hx : x \u2260 0) : \u2203 (u : \u2124_[p]\u02e3) (n : \u2115), (u : \u2124_[p]) * p ^ n = x :=\n  \u27e8_, _, (unitCoeff_spec hx).symm\u27e9\n\nlemma isOpenEmbedding_coe : IsOpenEmbedding ((\u2191) : \u2124_[p] \u2192 \u211a_[p]) := by\n  refine (?_ : IsOpen {y : \u211a_[p] | \u2016y\u2016 \u2264 1}).isOpenEmbedding_subtypeVal\n  simpa only [Metric.closedBall, dist_eq_norm_sub, sub_zero] using\n    IsUltrametricDist.isOpen_closedBall (0 : \u211a_[p]) one_ne_zero\n\n@[simp] lemma image_coe_smul_set (x : \u2124_[p]) (s : Set \u2124_[p]) :\n    ((\u2191) '' (x \u2022 s) : Set \u211a_[p]) = x \u2022 (\u2191) '' s := Set.image_comm fun _ \u21a6 rfl\n\n-- Ya\u00ebl: Do we really want this as a coercion?\nnoncomputable instance : Coe \u2124_[p]\u02e3 \u211a_[p]\u02e3 where coe := Units.map Coe.ringHom.toMonoidHom\n\n/-- For a `\u2124_[p]`-submodule `s` of `\u211a_[p]`, `x \u2022 s` has index `\u2016x\u2016\u207b\u00b9` in `s`.\n\nNote that `s` is of the form `y\u2124_[p]` for some `y : \u211a_[p]`, but this is syntactically less\ngeneral. -/\nlemma smul_submodule_relindex (x : \u2124_[p]) (s : Submodule \u2124_[p] \u211a_[p]) :\n    (x \u2022 s.toAddSubgroup).relindex s.toAddSubgroup = \u2016x\u2016\u208a\u207b\u00b9 :=\n  -- https://github.com/ImperialCollegeLondon/FLT/issues/279\n  -- Note: You might need to prove `smul_submoduleSpan_finiteRelIndex_submoduleSpan` first\n  sorry\n\n/-- For a `\u2124_[p]`-submodule `s` of `\u211a_[p]`, `x \u2022 s` has finite index if `x \u2260 0`.\n\nNote that `s` is the form `y\u2124_[p]` for some `y : \u211a_[p]`, but this is syntactically less\ngeneral. -/\nlemma smul_submodule_finiteRelIndex (hx : x \u2260 0) (s : Submodule \u2124_[p] \u211a_[p]) :\n    (x \u2022 s.toAddSubgroup).FiniteRelIndex s.toAddSubgroup where\n  relIndex_ne_zero := by simpa [\u2190 Nat.cast_ne_zero (R := \u211d\u22650), smul_submodule_relindex]\n\n-- Ya\u00ebl: Do we really want this as a coercion?\nnoncomputable instance : Coe \u2124_[p]\u2070 \u211a_[p]\u02e3 where\n  coe x := .mk0 x.1 <| map_ne_zero_of_mem_nonZeroDivisors (M := \u2124_[p]) Coe.ringHom coe_injective x.2\n\n", "theoremStatement": "/-- Non-zero p-adic integers generate non-zero p-adic numbers as a group. -/\nlemma closure_nonZeroDivisors_padicInt :\n    Subgroup.closure (Set.range ((\u2191) : \u2124_[p]\u2070 \u2192 \u211a_[p]\u02e3)) = \u22a4 ", "theoremName": "PadicInt.closure_nonZeroDivisors_padicInt", "fileCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "theoremCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "file": "FLT/FLT/Mathlib/NumberTheory/Padics/PadicIntegers.lean", "module": "FLT.Mathlib.NumberTheory.Padics.PadicIntegers", "jsonFile": "FLT.Mathlib.NumberTheory.Padics.PadicIntegers.jsonl", "positionMetadata": {"lineInFile": 76, "tokenPositionInFile": 2913, "theoremPositionInFile": 11}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 117}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  set H := Subgroup.closure (Set.range ((\u2191) : \u2124_[p]\u2070 \u2192 \u211a_[p]\u02e3))\n  rw [eq_top_iff']\n  intro x\n  obtain \u27e8y, z, hz, hyzx\u27e9 := IsFractionRing.div_surjective (A := \u2124_[p]) x.val\n  have hy : y \u2208 \u2124_[p]\u2070 := by simp; rintro rfl; simp [eq_comm] at hyzx\n  convert div_mem (H := H) (subset_closure <| Set.mem_range_self \u27e8y, hy\u27e9)\n    (subset_closure <| Set.mem_range_self \u27e8z, hz\u27e9) using 1\n  ext\n  simpa using hyzx.symm", "proofType": "tactic", "proofLengthLines": 9, "proofLengthTokens": 409}}
{"srcContext": "/-\nCopyright (c) 2024 Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras\n-/\nimport FLT.Mathlib.MeasureTheory.Group.Action\nimport FLT.HaarMeasure.DistribHaarChar.Basic\nimport FLT.HaarMeasure.MeasurableSpacePadics\n\n/-!\n# The distributive Haar characters of the p-adics\n\nThis file computes `distribHaarChar` in the case of the actions of `\u2124_[p]\u02e3` on `\u2124_[p]` and of\n`\u211a_[p]\u02e3` on `\u211a_[p]`.\n\nThis lets us know what `volume (x \u2022 s)` is in terms of `\u2016x\u2016` and `volume s`, when `x` is a\np-adic/p-adic integer and `s` is a set of p-adics/p-adic integers.\n\n## Main declarations\n\n* `distribHaarChar_padic`: `distribHaarChar \u211a_[p]` is the usual p-adic norm on `\u211a_[p]\u02e3`.\n* `distribHaarChar_padicInt`: `distribHaarChar \u2124_[p]` is constantly `1` on `\u2124_[p]\u02e3`.\n* `Padic.volume_padic_smul`: `volume (x \u2022 s) = \u2016x\u2016\u208a * volume s` for all `x : \u211a_[p]` and\n  `s : Set \u211a_[p]`.\n* `PadicInt.volume_padicInt_smul`: `volume (x \u2022 s) = \u2016x\u2016\u208a * volume s` for all `x : \u2124_[p]` and\n  `s : Set \u2124_[p]`.\n-/\n\nopen Padic MeasureTheory Measure Metric Set\nopen scoped Pointwise ENNReal NNReal nonZeroDivisors\n\nvariable {p : \u2115} [Fact p.Prime]\n\n", "theoremStatement": "private lemma distribHaarChar_padic_padicInt (x : \u2124_[p]\u2070) :\n    distribHaarChar \u211a_[p] (x : \u211a_[p]\u02e3) = \u2016(x : \u211a_[p])\u2016\u208a ", "theoremName": "distribHaarChar_padic_padicInt", "fileCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "theoremCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "file": "FLT/FLT/HaarMeasure/DistribHaarChar/Padic.lean", "module": "FLT.HaarMeasure.DistribHaarChar.Padic", "jsonFile": "FLT.HaarMeasure.DistribHaarChar.Padic.jsonl", "positionMetadata": {"lineInFile": 34, "tokenPositionInFile": 1216, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": null, "numInFilePremises": null, "repositoryPremises": null, "numRepositoryPremises": null, "numPremises": null}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  -- Let `K` be the copy of `\u2124_[p]` inside `\u211a_[p]` and `H` be `xK`.\n  let K : AddSubgroup \u211a_[p] := (1 : Submodule \u2124_[p] \u211a_[p]).toAddSubgroup\n  let H := (x : \u211a_[p]) \u2022 K\n  -- We compute that `volume H = \u2016x\u2016\u208a * volume K`.\n  refine distribHaarChar_eq_of_measure_smul_eq_mul (s := K) (\u03bc := volume) (G := \u211a_[p]\u02e3)\n    (by simp [K, Padic.submodule_one_eq_closedBall, closedBall, Padic.volume_closedBall_one])\n    (by simp [K, Padic.submodule_one_eq_closedBall, closedBall, Padic.volume_closedBall_one]) ?_\n  change volume (H : Set \u211a_[p]) = \u2016(x : \u211a_[p])\u2016\u208a * volume (K : Set \u211a_[p])\n  -- This is true because `H` is a `\u2016x\u2016\u208a\u207b\u00b9`-index subgroup of `K`.\n  have hHK : H \u2264 K := by\n    simpa [H, K, -Submodule.smul_le_self_of_tower]\n      using (1 : Submodule \u2124_[p] \u211a_[p]).smul_le_self_of_tower (x : \u2124_[p])\n  have : H.FiniteRelIndex K :=\n    PadicInt.smul_submodule_finiteRelIndex (p := p) (mem_nonZeroDivisors_iff_ne_zero.1 x.2) 1\n  have H_relindex_Z : (H.relindex K : \u211d\u22650\u221e) = \u2016(x : \u211a_[p])\u2016\u208a\u207b\u00b9 :=\n    congr(ENNReal.ofNNReal $(PadicInt.smul_submodule_relindex (p := p) x 1))\n  rw [\u2190 index_mul_addHaar_addSubgroup_eq_addHaar_addSubgroup hHK, H_relindex_Z, ENNReal.coe_inv,\n    ENNReal.mul_inv_cancel_left]\n  \u00b7 simp\n  \u00b7 simp\n  \u00b7 simp\n  \u00b7 simpa [H, K, Padic.submodule_one_eq_closedBall]\n      using measurableSet_closedBall.const_smul (x : \u211a_[p]\u02e3)\n  \u00b7 simpa [K, Padic.submodule_one_eq_closedBall] using measurableSet_closedBall", "proofType": "tactic", "proofLengthLines": 24, "proofLengthTokens": 1412}}
{"srcContext": "import Mathlib.Algebra.CharZero.Infinite\nimport Mathlib.NumberTheory.Padics.PadicIntegers\nimport FLT.Mathlib.GroupTheory.Index\n\n/-!\n# TODO\n\n* Rename `Coe.ringHom` to `coeRingHom`\n* Protect `PadicInt.norm_mul`, `PadicInt.norm_units`, `PadicInt.norm_pow`\n-/\n\nopen Function Topology Subgroup\nopen scoped NNReal nonZeroDivisors Pointwise\n\nvariable {p : \u2115} [Fact p.Prime]\n\nnamespace PadicInt\nvariable {x : \u2124_[p]}\n\nattribute [simp] coe_eq_zero\n\n@[simp, norm_cast] lemma coe_coeRingHom : \u21d1(Coe.ringHom (p := p)) = (\u2191) := rfl\n\nlemma coe_injective : Injective ((\u2191) : \u2124_[p] \u2192 \u211a_[p]) := Subtype.val_injective\n\n@[simp] lemma coe_inj {x y : \u2124_[p]} : (x : \u211a_[p]) = (y : \u211a_[p]) \u2194 x = y := coe_injective.eq_iff\n\ninstance : Infinite \u2124_[p] := CharZero.infinite _\n\n@[simp]\nprotected lemma nnnorm_mul (x y : \u2124_[p]) : \u2016x * y\u2016\u208a = \u2016x\u2016\u208a * \u2016y\u2016\u208a := by simp [nnnorm, NNReal]\n\n@[simp]\nprotected lemma nnnorm_pow (x : \u2124_[p]) (n : \u2115) : \u2016x ^ n\u2016\u208a = \u2016x\u2016\u208a ^ n := by simp [nnnorm, NNReal]\n\n@[simp] lemma nnnorm_p : \u2016(p : \u2124_[p])\u2016\u208a = (p : \u211d\u22650)\u207b\u00b9 := by simp [nnnorm]; rfl\n\n", "theoremStatement": "@[simp] protected lemma nnnorm_units (u : \u2124_[p]\u02e3) : \u2016(u : \u2124_[p])\u2016\u208a = 1 ", "theoremName": "PadicInt.nnnorm_units", "fileCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "theoremCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "file": "FLT/FLT/Mathlib/NumberTheory/Padics/PadicIntegers.lean", "module": "FLT.Mathlib.NumberTheory.Padics.PadicIntegers", "jsonFile": "FLT.Mathlib.NumberTheory.Padics.PadicIntegers.jsonl", "positionMetadata": {"lineInFile": 38, "tokenPositionInFile": 1035, "theoremPositionInFile": 6}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 47}, "proofMetadata": {"hasProof": true, "proof": ":= by simp [nnnorm, NNReal]", "proofType": "tactic", "proofLengthLines": 0, "proofLengthTokens": 27}}
{"srcContext": "import Mathlib.Topology.Algebra.UniformRing\nimport FLT.Mathlib.Algebra.Algebra.Hom\n\n/-!\n# Completion of topological rings\n-/\n\nnamespace UniformSpace.Completion\n\nvariable {\u03b1 : Type*} [Ring \u03b1] [UniformSpace \u03b1] [TopologicalRing \u03b1] [UniformAddGroup \u03b1]\n  {\u03b2 : Type*} [UniformSpace \u03b2] [Ring \u03b2] [UniformAddGroup \u03b2] [TopologicalRing \u03b2]\n  (f : \u03b1 \u2192+* \u03b2) (hf : Continuous f)\n\ntheorem mapRingHom_apply {x : UniformSpace.Completion \u03b1} :\n    UniformSpace.Completion.mapRingHom f hf x = UniformSpace.Completion.map f x := rfl\n\nvariable {f}\n\n", "theoremStatement": "theorem mapRingHom_coe (hf : UniformContinuous f) (a : \u03b1) :\n    mapRingHom f hf.continuous a = f a ", "theoremName": "UniformSpace.Completion.mapRingHom_coe", "fileCreated": {"commit": "f463c53242f2ad3f5bdbee5b2078741ebf425207", "date": "2025-01-31"}, "theoremCreated": {"commit": "127241373eb7d4afd5ff86dc0e5082497c364f08", "date": "2025-02-05"}, "file": "FLT/FLT/Mathlib/Topology/Algebra/UniformRing.lean", "module": "FLT.Mathlib.Topology.Algebra.UniformRing", "jsonFile": "FLT.Mathlib.Topology.Algebra.UniformRing.jsonl", "positionMetadata": {"lineInFile": 19, "tokenPositionInFile": 526, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 1, "numPremises": 28}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [mapRingHom_apply, map_coe hf]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 41}}
{"srcContext": "import Mathlib.LinearAlgebra.Span.Defs\n\nopen Pointwise\n\nvariable {R : Type*} [Semiring R]\n\nvariable {M : Type*} [AddCommMonoid M] [Module R M]\n\nvariable {p p' : Submodule R M}\n\nvariable {P : M \u2192 Prop}\n\nnamespace Submodule\n\n@[simp high]\nlemma forall_mem_sup : (\u2200 x \u2208 p \u2294 p', P x) \u2194 (\u2200 x\u2081 \u2208 p, \u2200 x\u2082 \u2208 p', P (x\u2081 + x\u2082)) := by\n  simp [mem_sup]\n  aesop\n\n@[simp high]\nlemma exists_mem_sup : (\u2203 x \u2208 p \u2294 p', P x) \u2194 (\u2203 x\u2081 \u2208 p, \u2203 x\u2082 \u2208 p', P (x\u2081 + x\u2082)) := by\n  simp [mem_sup]\n\n", "theoremStatement": "@[simp, norm_cast]\nlemma coe_sup' : \u2191(p \u2294 p') = (p : Set M) + (p' : Set M) ", "theoremName": "Submodule.coe_sup'", "fileCreated": {"commit": "14bd4f65b4f45e7747da8e4c0d90d02a58dec086", "date": "2024-12-21"}, "theoremCreated": {"commit": "14bd4f65b4f45e7747da8e4c0d90d02a58dec086", "date": "2024-12-21"}, "file": "FLT/FLT/Mathlib/LinearAlgebra/Span/Defs.lean", "module": "FLT.Mathlib.LinearAlgebra.Span.Defs", "jsonFile": "FLT.Mathlib.LinearAlgebra.Span.Defs.jsonl", "positionMetadata": {"lineInFile": 24, "tokenPositionInFile": 465, "theoremPositionInFile": 2}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 26}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp [coe_sup]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 22}}
{"srcContext": "import Mathlib.Analysis.Normed.Ring.WithAbs\nimport Mathlib.NumberTheory.NumberField.Basic\n\nnamespace WithAbs\n\nvariable {K : Type*} [Field K] {v : AbsoluteValue K \u211d}\n  {L : Type*} [Field L] [Algebra K L] {w : AbsoluteValue L \u211d}\n\ninstance : Algebra (WithAbs v) (WithAbs w) := \u2039Algebra K L\u203a\n\ninstance : Algebra K (WithAbs w) := \u2039Algebra K L\u203a\n\ninstance [NumberField K] : NumberField (WithAbs v) := \u2039NumberField K\u203a\n\ntheorem norm_eq_abs (x : WithAbs v) : \u2016x\u2016 = v x := rfl\n\n", "theoremStatement": "theorem uniformContinuous_algebraMap {v : AbsoluteValue K \u211d} {w : AbsoluteValue L \u211d}\n    (h : \u2200 x, w (algebraMap (WithAbs v) (WithAbs w) x) = v x) :\n    UniformContinuous (algebraMap (WithAbs v) (WithAbs w)) ", "theoremName": "WithAbs.uniformContinuous_algebraMap", "fileCreated": {"commit": "127de0cf1cfe4388059ffe6945fd866e45792a99", "date": "2025-02-02"}, "theoremCreated": {"commit": "127241373eb7d4afd5ff86dc0e5082497c364f08", "date": "2025-02-05"}, "file": "FLT/FLT/Mathlib/Analysis/Normed/Ring/WithAbs.lean", "module": "FLT.Mathlib.Analysis.Normed.Ring.WithAbs", "jsonFile": "FLT.Mathlib.Analysis.Normed.Ring.WithAbs.jsonl", "positionMetadata": {"lineInFile": 17, "tokenPositionInFile": 467, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 1, "numPremises": 30}, "proofMetadata": {"hasProof": true, "proof": ":=\n  isUniformInducing_of_comp h |>.uniformContinuous", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 53}}
{"srcContext": "/-\nCopyright (c) 2024 Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras\n-/\nimport FLT.Mathlib.MeasureTheory.Group.Action\nimport FLT.HaarMeasure.DistribHaarChar.Basic\nimport FLT.HaarMeasure.MeasurableSpacePadics\n\n/-!\n# The distributive Haar characters of the p-adics\n\nThis file computes `distribHaarChar` in the case of the actions of `\u2124_[p]\u02e3` on `\u2124_[p]` and of\n`\u211a_[p]\u02e3` on `\u211a_[p]`.\n\nThis lets us know what `volume (x \u2022 s)` is in terms of `\u2016x\u2016` and `volume s`, when `x` is a\np-adic/p-adic integer and `s` is a set of p-adics/p-adic integers.\n\n## Main declarations\n\n* `distribHaarChar_padic`: `distribHaarChar \u211a_[p]` is the usual p-adic norm on `\u211a_[p]\u02e3`.\n* `distribHaarChar_padicInt`: `distribHaarChar \u2124_[p]` is constantly `1` on `\u2124_[p]\u02e3`.\n* `Padic.volume_padic_smul`: `volume (x \u2022 s) = \u2016x\u2016\u208a * volume s` for all `x : \u211a_[p]` and\n  `s : Set \u211a_[p]`.\n* `PadicInt.volume_padicInt_smul`: `volume (x \u2022 s) = \u2016x\u2016\u208a * volume s` for all `x : \u2124_[p]` and\n  `s : Set \u2124_[p]`.\n-/\n\nopen Padic MeasureTheory Measure Metric Set\nopen scoped Pointwise ENNReal NNReal nonZeroDivisors\n\nvariable {p : \u2115} [Fact p.Prime]\n\nprivate lemma distribHaarChar_padic_padicInt (x : \u2124_[p]\u2070) :\n    distribHaarChar \u211a_[p] (x : \u211a_[p]\u02e3) = \u2016(x : \u211a_[p])\u2016\u208a := by\n  -- Let `K` be the copy of `\u2124_[p]` inside `\u211a_[p]` and `H` be `xK`.\n  let K : AddSubgroup \u211a_[p] := (1 : Submodule \u2124_[p] \u211a_[p]).toAddSubgroup\n  let H := (x : \u211a_[p]) \u2022 K\n  -- We compute that `volume H = \u2016x\u2016\u208a * volume K`.\n  refine distribHaarChar_eq_of_measure_smul_eq_mul (s := K) (\u03bc := volume) (G := \u211a_[p]\u02e3)\n    (by simp [K, Padic.submodule_one_eq_closedBall, closedBall, Padic.volume_closedBall_one])\n    (by simp [K, Padic.submodule_one_eq_closedBall, closedBall, Padic.volume_closedBall_one]) ?_\n  change volume (H : Set \u211a_[p]) = \u2016(x : \u211a_[p])\u2016\u208a * volume (K : Set \u211a_[p])\n  -- This is true because `H` is a `\u2016x\u2016\u208a\u207b\u00b9`-index subgroup of `K`.\n  have hHK : H \u2264 K := by\n    simpa [H, K, -Submodule.smul_le_self_of_tower]\n      using (1 : Submodule \u2124_[p] \u211a_[p]).smul_le_self_of_tower (x : \u2124_[p])\n  have : H.FiniteRelIndex K :=\n    PadicInt.smul_submodule_finiteRelIndex (p := p) (mem_nonZeroDivisors_iff_ne_zero.1 x.2) 1\n  have H_relindex_Z : (H.relindex K : \u211d\u22650\u221e) = \u2016(x : \u211a_[p])\u2016\u208a\u207b\u00b9 :=\n    congr(ENNReal.ofNNReal $(PadicInt.smul_submodule_relindex (p := p) x 1))\n  rw [\u2190 index_mul_addHaar_addSubgroup_eq_addHaar_addSubgroup hHK, H_relindex_Z, ENNReal.coe_inv,\n    ENNReal.mul_inv_cancel_left]\n  \u00b7 simp\n  \u00b7 simp\n  \u00b7 simp\n  \u00b7 simpa [H, K, Padic.submodule_one_eq_closedBall]\n      using measurableSet_closedBall.const_smul (x : \u211a_[p]\u02e3)\n  \u00b7 simpa [K, Padic.submodule_one_eq_closedBall] using measurableSet_closedBall\n\n/-- The distributive Haar character of the action of `\u211a_[p]\u02e3` on `\u211a_[p]` is the usual p-adic norm.\n\nThis means that `volume (x \u2022 s) = \u2016x\u2016 * volume s` for all `x : \u211a_[p]` and `s : Set \u211a_[p]`.\nSee `Padic.volume_padic_smul` -/\n@[simp]\nlemma distribHaarChar_padic (x : \u211a_[p]\u02e3) : distribHaarChar \u211a_[p] x = \u2016(x : \u211a_[p])\u2016\u208a := by\n  -- Write the RHS as the application of a monoid hom `g`.\n  let g : \u211a_[p]\u02e3 \u2192* \u211d\u22650 := {\n    toFun := fun x => \u2016(x : \u211a_[p])\u2016\u208a\n    map_one' := by simp\n    map_mul' := by simp\n  }\n  revert x\n  suffices distribHaarChar \u211a_[p] = g by simp [this, g]\n  -- By density of `\u2124_[p]\u2070` inside `\u211a_[p]\u02e3`, it's enough to check that `distribHaarChar \u211a_[p]` and\n  -- `g` agree on `\u2124_[p]\u2070`.\n  refine MonoidHom.eq_of_eqOn_dense (PadicInt.closure_nonZeroDivisors_padicInt (p := p)) ?_\n  -- But this is what we proved in `distribHaarChar_padic_padicInt`.\n  simp\n  ext x\n  simp [g]\n  rw [distribHaarChar_padic_padicInt]\n  rfl\n\n@[simp]\nlemma Padic.volume_padic_smul (x : \u211a_[p]) (s : Set \u211a_[p]) : volume (x \u2022 s) = \u2016x\u2016\u208a * volume s := by\n  obtain rfl | hx := eq_or_ne x 0\n  \u00b7 simp [(finite_zero.subset s.zero_smul_set_subset).measure_zero]\n  \u00b7 lift x to \u211a_[p]\u02e3 using hx.isUnit\n    rw [\u2190 distribHaarChar_padic, distribHaarChar_mul, Units.smul_def]\n\n@[simp] lemma Padic.volume_padicInt_smul (x : \u2124_[p]) (s : Set \u211a_[p]) :\n    volume (x \u2022 s) = \u2016x\u2016\u208a * volume s := by simpa [-volume_padic_smul] using volume_padic_smul x s\n\n@[simp] lemma PadicInt.volume_padicInt_smul (x : \u2124_[p]) (s : Set \u2124_[p]) :\n    volume (x \u2022 s) = \u2016x\u2016\u208a * volume s := by\n  simpa [-volume_padicInt_smul, \u2190 image_coe_smul_set] using Padic.volume_padicInt_smul x ((\u2191) '' s)\n\n", "theoremStatement": "/-- The distributive Haar character of the action of `\u2124_[p]\u02e3` on `\u2124_[p]` is the constant `1`.\n\nThis means that `volume (x \u2022 s) = \u2016x\u2016 * volume s` for all `x : \u2124_[p]` and `s : Set \u2124_[p]`.\nSee `PadicInt.volume_padicInt_smul` -/\n@[simp]\nlemma distribHaarChar_padicInt (x : \u2124_[p]\u02e3) : distribHaarChar \u2124_[p] x = 1 ", "theoremName": "distribHaarChar_padicInt", "fileCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "theoremCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "file": "FLT/FLT/HaarMeasure/DistribHaarChar/Padic.lean", "module": "FLT.HaarMeasure.DistribHaarChar.Padic", "jsonFile": "FLT.HaarMeasure.DistribHaarChar.Padic.jsonl", "positionMetadata": {"lineInFile": 99, "tokenPositionInFile": 4375, "theoremPositionInFile": 5}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 8, "numPremises": 137}, "proofMetadata": {"hasProof": true, "proof": ":=\n  -- We compute `distribHaarChar \u2124_[p]` by lifting everything to `\u211a_[p]`.\n  distribHaarChar_eq_of_measure_smul_eq_mul (s := univ) (\u03bc := volume) (by simp) (measure_ne_top _ _)\n    (by simp [PadicInt.volume_padicInt_smul])", "proofType": "term", "proofLengthLines": 3, "proofLengthTokens": 223}}
{"srcContext": "/-\nCopyright (c) 2024 Ya\u00ebl Dillies, David Loeffler. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Ya\u00ebl Dillies, David Loeffler\n-/\nimport Mathlib.MeasureTheory.Measure.Haar.Basic\nimport Mathlib.NumberTheory.Padics.ProperSpace\nimport FLT.Mathlib.NumberTheory.Padics.PadicIntegers\n\n/-!\n# Measurability and measures on the p-adics\n\nThis file endows `\u2124_[p]` and `\u211a_[p]` with their Borel sigma-algebra and their Haar measure that\nmakes `\u2124_[p]` (or the copy of `\u2124_[p]` inside `\u211a_[p]`) have norm `1`.\n-/\n\nopen MeasureTheory Measure TopologicalSpace Topology\n\nvariable {p : \u2115} [Fact p.Prime]\n\nnamespace Padic\n\ninstance instMeasurableSpace : MeasurableSpace \u211a_[p] := borel _\ninstance instBorelSpace : BorelSpace \u211a_[p] := \u27e8rfl\u27e9\n\n-- Should we more generally make a map from `CompactOpens` to `PositiveCompacts`?\nprivate def unitBall_positiveCompact : PositiveCompacts \u211a_[p] where\n  carrier := {y | \u2016y\u2016 \u2264 1}\n  isCompact' := by simpa only [Metric.closedBall, dist_zero_right] using\n    isCompact_closedBall (0 : \u211a_[p]) 1\n  interior_nonempty' := by\n    rw [IsOpen.interior_eq]\n    \u00b7 exact \u27e80, by simp\u27e9\n    \u00b7 simpa only [Metric.closedBall, dist_zero_right] using\n        IsUltrametricDist.isOpen_closedBall (0 : \u211a_[p]) one_ne_zero\n\nnoncomputable instance instMeasureSpace : MeasureSpace \u211a_[p] :=\n  \u27e8addHaarMeasure unitBall_positiveCompact\u27e9\n\ninstance instIsAddHaarMeasure : IsAddHaarMeasure (volume : Measure \u211a_[p]) :=\n  isAddHaarMeasure_addHaarMeasure _\n\nlemma volume_closedBall_one : volume {x : \u211a_[p] | \u2016x\u2016 \u2264 1} = 1 := addHaarMeasure_self\n\nend Padic\n\nnamespace PadicInt\n\ninstance instMeasurableSpace : MeasurableSpace \u2124_[p] := Subtype.instMeasurableSpace\ninstance instBorelSpace : BorelSpace \u2124_[p] := Subtype.borelSpace _\n\nlemma isMeasurableEmbedding_coe : MeasurableEmbedding ((\u2191) : \u2124_[p] \u2192 \u211a_[p]) := by\n  convert isOpenEmbedding_coe.measurableEmbedding\n  exact inferInstanceAs (BorelSpace \u2124_[p])\n\nnoncomputable instance instMeasureSpace : MeasureSpace \u2124_[p] := \u27e8addHaarMeasure \u22a4\u27e9\n\ninstance instIsAddHaarMeasure : IsAddHaarMeasure (volume : Measure \u2124_[p]) :=\n  isAddHaarMeasure_addHaarMeasure _\n\n", "theoremStatement": "@[simp] lemma volume_univ : volume (Set.univ : Set \u2124_[p]) = 1 ", "theoremName": "PadicInt.volume_univ", "fileCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "theoremCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "file": "FLT/FLT/HaarMeasure/MeasurableSpacePadics.lean", "module": "FLT.HaarMeasure.MeasurableSpacePadics", "jsonFile": "FLT.HaarMeasure.MeasurableSpacePadics.jsonl", "positionMetadata": {"lineInFile": 61, "tokenPositionInFile": 2135, "theoremPositionInFile": 2}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 3, "numPremises": 39}, "proofMetadata": {"hasProof": true, "proof": ":= addHaarMeasure_self", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 22}}
{"srcContext": "/-\nCopyright (c) 2024 Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras\n-/\nimport Mathlib.Analysis.Complex.ReImTopology\nimport Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar\nimport Mathlib.RingTheory.Complex\nimport Mathlib.RingTheory.Norm.Transitivity\nimport FLT.HaarMeasure.DistribHaarChar.Basic\nimport FLT.Mathlib.LinearAlgebra.Determinant\n\n/-!\n# The distributive Haar characters of `\u211d` and `\u2102`\n\nThis file computes `distribHaarChar` in the case of the actions of `\u211d\u02e3` on `\u211d` and of `\u2102\u02e3` on `\u2102`.\n\nThis lets us know what `volume (x \u2022 s)` is in terms of `\u2016x\u2016` and `volume s`, when `x` is a\nreal/complex number and `s` is a set of reals/complex numbers.\n\n## Main declarations\n\n* `distribHaarChar_real`: `distribHaarChar \u211d` is the usual norm on `\u211d`.\n* `distribHaarChar_complex`: `distribHaarChar \u2102` is the usual norm on `\u2102` squared.\n* `Real.volume_real_smul`: `volume (x \u2022 s) = \u2016x\u2016\u208a * volume s` for all `x : \u211d` and `s : Set \u211d`.\n* `Complex.volume_complex_smul`: `volume (z \u2022 s) = \u2016z\u2016\u208a ^ 2 * volume s` for all `z : \u2102` and\n  `s : Set \u2102`.\n-/\n\nopen Real Complex MeasureTheory Measure Set\nopen scoped Pointwise\n\nlemma Real.volume_real_smul (x : \u211d) (s : Set \u211d) : volume (x \u2022 s) = \u2016x\u2016\u208a * volume s := by\n  simp [\u2190 enorm_eq_ofReal_abs, enorm_eq_nnnorm]\n\n", "theoremStatement": "/-- The distributive Haar character of the action of `\u211d\u02e3` on `\u211d` is the usual norm.\n\nThis means that `volume (x \u2022 s) = \u2016x\u2016 * volume s` for all `x : \u211d` and `s : Set \u211d`.\nSee `Real.volume_real_smul`. -/\nlemma distribHaarChar_real (x : \u211d\u02e3) : distribHaarChar \u211d x = \u2016(x : \u211d)\u2016\u208a ", "theoremName": "distribHaarChar_real", "fileCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "theoremCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "file": "FLT/FLT/HaarMeasure/DistribHaarChar/RealComplex.lean", "module": "FLT.HaarMeasure.DistribHaarChar.RealComplex", "jsonFile": "FLT.HaarMeasure.DistribHaarChar.RealComplex.jsonl", "positionMetadata": {"lineInFile": 36, "tokenPositionInFile": 1363, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 3, "numPremises": 165}, "proofMetadata": {"hasProof": true, "proof": ":=\n  -- We compute that `volume (x \u2022 [0, 1]) = \u2016x\u2016\u208a * volume [0, 1]`.\n  distribHaarChar_eq_of_measure_smul_eq_mul (s := Icc 0 1) (\u03bc := volume)\n    (measure_pos_of_nonempty_interior _ <| by simp).ne' isCompact_Icc.measure_ne_top\n      (Real.volume_real_smul ..)", "proofType": "term", "proofLengthLines": 4, "proofLengthTokens": 260}}
{"srcContext": "/-\nCopyright (c) 2024 Andrew Yang, Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang, Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras\n-/\nimport FLT.HaarMeasure.DomMulActMeasure\n\n/-!\n# The distributive character of Haar measures\n\nGiven a group `G` acting on an measurable additive commutative group `A`, and an element `g : G`,\none can pull back the Haar measure `\u03bc` of `A` along the map `(g \u2022 \u00b7) : A \u2192 A` to get another Haar\nmeasure `\u03bc'` on `A`. By unicity of Haar measures, there exists some nonnegative real number `r` such\nthat `\u03bc' = r \u2022 \u03bc`. We can thus define a map `distribHaarChar : G \u2192 \u211d\u22650` sending `g` to its\nassociated real number `r`. Furthermore, this number doesn't depend on the Haar measure `\u03bc` we\nstarted with, and `distribHaarChar` is a group homomorphism.\n\n## See also\n\n[Zulip](https://leanprover.zulipchat.com/#narrow/channel/217875-Is-there-code-for-X.3F/topic/canonical.20norm.20coming.20from.20Haar.20measure/near/480050592)\n-/\n\nopen scoped NNReal Pointwise ENNReal\n\nnamespace MeasureTheory.Measure\n\nvariable {G A : Type*} [Group G] [AddCommGroup A] [DistribMulAction G A]\n  [MeasurableSpace A]\n  [MeasurableSpace G] -- not needed actually\n  [MeasurableSMul G A] -- only need `MeasurableConstSMul` but we don't have this class.\nvariable {\u03bc \u03bd : Measure A} {g : G}\n\nvariable [TopologicalSpace A] [BorelSpace A] [TopologicalAddGroup A] [LocallyCompactSpace A]\n  [ContinuousConstSMul G A] [\u03bc.IsAddHaarMeasure] [\u03bd.IsAddHaarMeasure]\n\nvariable (\u03bc A) in\n@[simps (config := .lemmasOnly)]\nnoncomputable def distribHaarChar : G \u2192* \u211d\u22650 where\n  toFun g := addHaarScalarFactor (DomMulAct.mk g \u2022 addHaar) (addHaar (G := A))\n  map_one' := by simp\n  map_mul' g g' := by\n    simp_rw [DomMulAct.mk_mul]\n    rw [addHaarScalarFactor_eq_mul _ (DomMulAct.mk g' \u2022 addHaar (G := A))]\n    congr 1\n    simp_rw [mul_smul]\n    rw [addHaarScalarFactor_domSMul]\n\nvariable (\u03bc) in\nlemma addHaarScalarFactor_smul_eq_distribHaarChar (g : G) :\n    addHaarScalarFactor (DomMulAct.mk g \u2022 \u03bc) \u03bc = distribHaarChar A g :=\n  addHaarScalarFactor_smul_congr' ..\n\nvariable (\u03bc) in\nlemma addHaarScalarFactor_smul_inv_eq_distribHaarChar (g : G) :\n    addHaarScalarFactor \u03bc ((DomMulAct.mk g)\u207b\u00b9 \u2022 \u03bc) = distribHaarChar A g := by\n  rw [\u2190 addHaarScalarFactor_domSMul _ _ (DomMulAct.mk g)]\n  simp_rw [\u2190 mul_smul, mul_inv_cancel, one_smul]\n  exact addHaarScalarFactor_smul_eq_distribHaarChar ..\n\nvariable (\u03bc) in\nlemma addHaarScalarFactor_smul_eq_distribHaarChar_inv (g : G) :\n    addHaarScalarFactor \u03bc (DomMulAct.mk g \u2022 \u03bc) = (distribHaarChar A g)\u207b\u00b9 := by\n  rw [\u2190 map_inv, \u2190 addHaarScalarFactor_smul_inv_eq_distribHaarChar \u03bc, DomMulAct.mk_inv, inv_inv]\n\n", "theoremStatement": "lemma distribHaarChar_pos : 0 < distribHaarChar A g ", "theoremName": "MeasureTheory.Measure.distribHaarChar_pos", "fileCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "theoremCreated": {"commit": "8786316e35a009e5d8fc0ffc56ad2ca5765dc8c7", "date": "2024-12-02"}, "file": "FLT/FLT/HaarMeasure/DistribHaarChar/Basic.lean", "module": "FLT.HaarMeasure.DistribHaarChar.Basic", "jsonFile": "FLT.HaarMeasure.DistribHaarChar.Basic.jsonl", "positionMetadata": {"lineInFile": 65, "tokenPositionInFile": 2705, "theoremPositionInFile": 3}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 1, "numPremises": 51}, "proofMetadata": {"hasProof": true, "proof": ":=\n  pos_iff_ne_zero.mpr ((Group.isUnit g).map (distribHaarChar A)).ne_zero", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 75}}
{"srcContext": "import Mathlib.GroupTheory.Complement\nimport Mathlib.MeasureTheory.Group.Action\nimport Mathlib.MeasureTheory.Group.Pointwise\nimport Mathlib.Topology.Algebra.InfiniteSum.ENNReal\nimport FLT.Mathlib.Algebra.Group.Subgroup.Defs\nimport FLT.Mathlib.GroupTheory.Index\n\n/-!\n# TODO\n\n* Make `\u03b1` implicit in `SMulInvariantMeasure`\n* Rename `SMulInvariantMeasure` to `Measure.IsSMulInvariant`\n-/\n\nopen Subgroup Set\nopen scoped Pointwise\n\nnamespace MeasureTheory\nvariable {G \u03b1 : Type*} [Group G] [MeasurableSpace G] [MeasurableSpace \u03b1]\n  {H K : Subgroup G}\n\n@[to_additive]\ninstance [MeasurableMul\u2082 G] : MeasurableMul\u2082 H where measurable_mul := by measurability\n\n@[to_additive]\ninstance [MeasurableInv G] : MeasurableInv H where measurable_inv := sorry\n\nvariable [MeasurableMul G]\n\n@[to_additive]\ninstance : MeasurableMul H where\n  measurable_mul_const c := by measurability\n  measurable_const_mul c := sorry -- https://github.com/ImperialCollegeLondon/FLT/issues/276\n\n@[to_additive]\ninstance (\u03bc : Measure G) [\u03bc.IsMulLeftInvariant] :\n    (\u03bc.comap Subtype.val : Measure H).IsMulLeftInvariant where\n  map_mul_left_eq_self g := sorry -- https://github.com/ImperialCollegeLondon/FLT/issues/276\n\n@[to_additive]\ninstance (\u03bc : Measure G) [\u03bc.IsMulRightInvariant] :\n    (\u03bc.comap Subtype.val : Measure H).IsMulRightInvariant where\n  map_mul_right_eq_self g := sorry -- https://github.com/ImperialCollegeLondon/FLT/issues/276\n\n@[to_additive index_mul_addHaar_addSubgroup]\nlemma index_mul_haar_subgroup [H.FiniteIndex] (hH : MeasurableSet (H : Set G)) (\u03bc : Measure G)\n    [\u03bc.IsMulLeftInvariant] : H.index * \u03bc H = \u03bc univ := by\n  obtain \u27e8s, hs, -\u27e9 := H.exists_isComplement_left 1\n  have hs' : Finite s := hs.finite_left_iff.mpr inferInstance\n  calc\n    H.index * \u03bc H = \u2211' a : s, \u03bc (a.val \u2022 H) := by\n      simp [measure_smul]\n      rw [\u2190 Set.Finite.cast_ncard_eq hs', \u2190 Nat.card_coe_set_eq, hs.card_left]\n      norm_cast\n    _ = \u03bc univ := by\n      rw [\u2190 measure_iUnion _ fun _ \u21a6 hH.const_smul _]\n      \u00b7 simp [hs.mul_eq]\n      \u00b7 exact fun a b hab \u21a6 hs.pairwiseDisjoint_smul a.2 b.2 (Subtype.val_injective.ne hab)\n\n", "theoremStatement": "@[to_additive index_mul_addHaar_addSubgroup_eq_addHaar_addSubgroup]\nlemma index_mul_haar_subgroup_eq_haar_subgroup [H.FiniteRelIndex K] (hHK : H \u2264 K)\n    (hH : MeasurableSet (H : Set G)) (hK : MeasurableSet (K : Set G)) (\u03bc : Measure G)\n    [\u03bc.IsMulLeftInvariant] : H.relindex K * \u03bc H = \u03bc K ", "theoremName": "MeasureTheory.index_mul_haar_subgroup_eq_haar_subgroup", "fileCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "theoremCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "file": "FLT/FLT/Mathlib/MeasureTheory/Group/Action.lean", "module": "FLT.Mathlib.MeasureTheory.Group.Action", "jsonFile": "FLT.Mathlib.MeasureTheory.Group.Action.jsonl", "positionMetadata": {"lineInFile": 60, "tokenPositionInFile": 2085, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 6, "numPremises": 83}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  have := index_mul_haar_subgroup (H := H.subgroupOf K) (measurable_subtype_coe hH)\n    (\u03bc.comap Subtype.val)\n  simp at this\n  rw [MeasurableEmbedding.comap_apply, MeasurableEmbedding.comap_apply] at this\n  simp at this\n  unfold subgroupOf at this\n  rwa [coe_comap, coe_subtype, Set.image_preimage_eq_of_subset (by simpa)] at this\n  exact .subtype_coe hK\n  exact .subtype_coe hK", "proofType": "tactic", "proofLengthLines": 9, "proofLengthTokens": 384}}
{"srcContext": "import Mathlib -- because there are sorries in this file\nimport FLT.Mathlib.Algebra.Order.Hom.Monoid\nimport FLT.Mathlib.Algebra.Algebra.Hom\nimport FLT.Mathlib.Algebra.Algebra.Pi\nimport FLT.Mathlib.Algebra.Algebra.Bilinear\nimport FLT.Mathlib.Topology.Algebra.UniformRing\n\n\n/-!\n\n# Base change of adele rings.\n\nIf `A` is a Dedekind domain with field of fractions `K`, if `L/K` is a finite separable\nextension and if `B` is the integral closure of `A` in `L`, then `B` is also a Dedekind\ndomain. Hence the rings of finite adeles `\ud835\udd38_K^\u221e` and `\ud835\udd38_L^\u221e` (defined using `A` and `B`)\nare defined. In this file we define the natural `K`-algebra map `\ud835\udd38_K^\u221e \u2192 \ud835\udd38_L^\u221e` and\nthe natural `L`-algebra map `\ud835\udd38_K^\u221e \u2297[K] L \u2192 \ud835\udd38_L^\u221e`, and show that the latter map\nis an isomorphism.\n\n## Main definition\n\n* `FiniteAdeleRing.baseChangeEquiv : L \u2297[K] FiniteAdeleRing A K \u2243\u2090[L] FiniteAdeleRing B L`\n\n-/\n\nopen scoped Multiplicative\n\n-- The general set-up.\n\nvariable (A K L B : Type*) [CommRing A] [CommRing B] [Algebra A B] [Field K] [Field L]\n    [Algebra A K] [IsFractionRing A K] [Algebra B L] [IsDedekindDomain A]\n    [Algebra K L] [Algebra A L] [IsScalarTower A B L] [IsScalarTower A K L]\n    [IsIntegralClosure B A L] [FiniteDimensional K L]\n\nvariable [Algebra.IsSeparable K L]\n\nexample : Function.Injective (algebraMap B L) := IsIntegralClosure.algebraMap_injective' A\n\nexample : IsDomain B := by\n  have foo : Function.Injective (algebraMap B L) := IsIntegralClosure.algebraMap_injective' A\n  have bar : IsDomain L := inferInstance\n  exact Function.Injective.isDomain _ foo -- exact? failed\nvariable [IsDomain B]\n\nexample : Algebra.IsIntegral A B := IsIntegralClosure.isIntegral_algebra A L\nvariable [Algebra.IsIntegral A B]\n\nexample : Module.Finite A B :=\n  have := IsIntegralClosure.isNoetherian A K L B\n  Module.IsNoetherian.finite A B\nvariable [Module.Finite A B]\n\nexample : IsDedekindDomain B := IsIntegralClosure.isDedekindDomain A K L B\nvariable [IsDedekindDomain B]\n\nexample : IsFractionRing B L := IsIntegralClosure.isFractionRing_of_finite_extension A K L B\nvariable [IsFractionRing B L]\n\n-- We start by filling in some holes in the API for finite extensions of Dedekind domains.\nnamespace IsDedekindDomain\n\nnamespace HeightOneSpectrum\n\n-- first need a way to pull back valuations on B to A\nvariable {B L} in\ndef comap (w : HeightOneSpectrum B) : HeightOneSpectrum A where\n  asIdeal := w.asIdeal.comap (algebraMap A B)\n  isPrime := Ideal.comap_isPrime (algebraMap A B) w.asIdeal\n  ne_bot := mt Ideal.eq_bot_of_comap_eq_bot w.ne_bot\n\nomit [Module.Finite A B] in\nlemma mk_count_factors_map\n    (hAB : Function.Injective (algebraMap A B))\n    (w : HeightOneSpectrum B) (I : Ideal A) [DecidableEq (Associates (Ideal A))]\n  [DecidableEq (Associates (Ideal B))] [\u2200 p : Associates (Ideal A), Decidable (Irreducible p)]\n  [\u2200 p : Associates (Ideal B), Decidable (Irreducible p)] :\n    (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) I)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk I).factors := by\n  classical\n  induction I using UniqueFactorizationMonoid.induction_on_prime with\n  | h\u2081 =>\n    rw [Associates.mk_zero, Ideal.zero_eq_bot, Ideal.map_bot, \u2190 Ideal.zero_eq_bot,\n      Associates.mk_zero]\n    simp [Associates.count, Associates.factors_zero, w.associates_irreducible,\n      associates_irreducible (comap A w), Associates.bcount]\n  | h\u2082 I hI =>\n    obtain rfl : I = \u22a4 := by simpa using hI\n    simp only [Submodule.zero_eq_bot, ne_eq, top_ne_bot, not_false_eq_true, Ideal.map_top]\n    simp only [\u2190 Ideal.one_eq_top, Associates.mk_one, Associates.factors_one]\n    rw [Associates.count_zero (associates_irreducible _),\n      Associates.count_zero (associates_irreducible _), mul_zero]\n  | h\u2083 I p hI hp IH =>\n    simp only [Ideal.map_mul, \u2190 Associates.mk_mul_mk]\n    have hp_bot : p \u2260 \u22a5 := hp.ne_zero\n    have hp_bot' := (Ideal.map_eq_bot_iff_of_injective hAB).not.mpr hp_bot\n    have hI_bot := (Ideal.map_eq_bot_iff_of_injective hAB).not.mpr hI\n    rw [Associates.count_mul (Associates.mk_ne_zero.mpr hp_bot) (Associates.mk_ne_zero.mpr hI)\n      (associates_irreducible _), Associates.count_mul (Associates.mk_ne_zero.mpr hp_bot')\n      (Associates.mk_ne_zero.mpr hI_bot) (associates_irreducible _)]\n    simp only [IH, mul_add]\n    congr 1\n    by_cases hw : (w.comap A).asIdeal = p\n    \u00b7 have : Irreducible (Associates.mk p) := Associates.irreducible_mk.mpr hp.irreducible\n      rw [hw, Associates.factors_self this, Associates.count_some this]\n      simp only [UniqueFactorizationMonoid.factors_eq_normalizedFactors, Multiset.nodup_singleton,\n        Multiset.mem_singleton, Multiset.count_eq_one_of_mem, mul_one]\n      rw [count_associates_factors_eq hp_bot' w.2 w.3,\n        Ideal.IsDedekindDomain.ramificationIdx_eq_normalizedFactors_count hp_bot' w.2 w.3]\n    \u00b7 have : (Associates.mk (comap A w).asIdeal).count (Associates.mk p).factors = 0 :=\n        Associates.count_eq_zero_of_ne (associates_irreducible _)\n          (Associates.irreducible_mk.mpr hp.irreducible)\n          (by rwa [ne_eq, Associates.mk_eq_mk_iff_associated, associated_iff_eq])\n      rw [this, mul_zero, eq_comm]\n      by_contra H\n      rw [eq_comm, \u2190 ne_eq, Associates.count_ne_zero_iff_dvd hp_bot' (irreducible w),\n        Ideal.dvd_iff_le, Ideal.map_le_iff_le_comap] at H\n      apply hw (((Ideal.isPrime_of_prime hp).isMaximal hp_bot).eq_of_le (comap A w).2.ne_top H).symm\n\nomit [Module.Finite A B] in\nlemma intValuation_comap (hAB : Function.Injective (algebraMap A B))\n    (w : HeightOneSpectrum B) (x : A) :\n    (comap A w).intValuation x ^\n    (Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal) =\n    w.intValuation (algebraMap A B x) := by\n  classical\n  have h_ne_zero : Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal \u2260 0 :=\n    Ideal.IsDedekindDomain.ramificationIdx_ne_zero\n      ((Ideal.map_eq_bot_iff_of_injective hAB).not.mpr (comap A w).3) w.2 Ideal.map_comap_le\n  by_cases hx : x = 0\n  \u00b7 simpa [hx]\n  simp only [intValuation, Valuation.coe_mk, MonoidWithZeroHom.coe_mk, ZeroHom.coe_mk]\n  show (ite _ _ _) ^ _ = ite _ _ _\n  by_cases hx : x = 0\n  \u00b7 subst hx; simp [h_ne_zero]\n  rw [map_eq_zero_iff _ hAB, if_neg hx, if_neg hx, \u2190 Set.image_singleton, \u2190 Ideal.map_span,\n    mk_count_factors_map _ _ hAB, mul_comm]\n  simp\n\n-- Need to know how the valuation `w` and its pullback are related on elements of `K`.\nomit [IsIntegralClosure B A L] [FiniteDimensional K L] [Algebra.IsSeparable K L]\n    [Module.Finite A B] in\nlemma valuation_comap (w : HeightOneSpectrum B) (x : K) :\n    (comap A w).valuation x ^\n    (Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal) =\n    w.valuation (algebraMap K L x) := by\n  obtain \u27e8x, y, hy, rfl\u27e9 := IsFractionRing.div_surjective (A := A) x\n  simp [valuation, \u2190 IsScalarTower.algebraMap_apply A K L, IsScalarTower.algebraMap_apply A B L,\n    \u2190 intValuation_comap A B (algebraMap_injective_of_field_isFractionRing A B K L), div_pow]\n\nomit [IsIntegralClosure B A L] [FiniteDimensional K L] [Algebra.IsSeparable K L]\n    [Module.Finite A B] in\nlemma _root_.IsDedekindDomain.HeightOneSpectrum.adicValued.continuous_algebraMap\n    (v : HeightOneSpectrum A) (w : HeightOneSpectrum B) (hvw : v = comap A w) :\n    letI : UniformSpace K := v.adicValued.toUniformSpace;\n    letI : UniformSpace L := w.adicValued.toUniformSpace;\n    Continuous (algebraMap K L) := by\n  letI : UniformSpace K := v.adicValued.toUniformSpace;\n  letI : UniformSpace L := w.adicValued.toUniformSpace;\n  subst hvw\n  refine continuous_of_continuousAt_zero (algebraMap K L) ?hf\n  delta ContinuousAt\n  simp only [map_zero]\n  rw [(@Valued.hasBasis_nhds_zero K _ _ _ (comap A w).adicValued).tendsto_iff\n    (@Valued.hasBasis_nhds_zero L _ _ _ w.adicValued)]\n  simp only [HeightOneSpectrum.adicValued_apply, Set.mem_setOf_eq, true_and, true_implies]\n  rw [WithZero.unitsWithZeroEquiv.forall_congr_left, Multiplicative.forall]\n  intro a\n  rw [WithZero.unitsWithZeroEquiv.exists_congr_left, Multiplicative.exists]\n  let m := Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal\n  let e : \u2124 \u2243 \u2124\u2098\u2080\u02e3 := Multiplicative.ofAdd.trans OrderMonoidIso.unitsWithZero.symm.toEquiv\n  have e_apply (a : \u2124) : e a = OrderMonoidIso.unitsWithZero.symm (Multiplicative.ofAdd a) := rfl\n  have hm : m \u2260 0 := by\n    refine Ideal.IsDedekindDomain.ramificationIdx_ne_zero ?_ w.2 Ideal.map_comap_le\n    exact (Ideal.map_eq_bot_iff_of_injective\n      (algebraMap_injective_of_field_isFractionRing A B K L)).not.mpr (comap A w).3\n  refine \u27e8a / m, fun x hx \u21a6 ?_\u27e9\n  simp_rw [\u2190 valuation_comap A]\n  calc\n    (comap A w).valuation x ^ m < e (a / \u2191m) ^ m := by gcongr; exacts [zero_le', hx]\n  _ = e (m \u2022 (a / \u2191m)) := by\n    dsimp [e]\n    norm_cast\n    rw [map_pow]\n  _ \u2264 e a := by\n    simp only [nsmul_eq_mul, e_apply, Units.val_le_val, OrderIsoClass.map_le_map_iff]\n    rw [mul_comm]\n    exact Int.mul_le_of_le_ediv (by positivity) le_rfl\n\nnoncomputable def adicCompletionComapSemialgHom (v : HeightOneSpectrum A) (w : HeightOneSpectrum B)\n    (hvw : v = comap A w) :\n    (HeightOneSpectrum.adicCompletion K v) \u2192\u209b\u2090[algebraMap K L]\n      (HeightOneSpectrum.adicCompletion L w) :=\n  letI : UniformSpace K := v.adicValued.toUniformSpace;\n  letI : UniformSpace L := w.adicValued.toUniformSpace;\n  UniformSpace.Completion.mapSemialgHom _ <|\n  IsDedekindDomain.HeightOneSpectrum.adicValued.continuous_algebraMap A K L B v w hvw\n\n-- Do we even need to prove that this map is continuous? It will follow from\n-- the fact that it's K_v-linear once we know L_w has the K_v-module topology,\n-- which is the next lemma.\n-- omit [IsIntegralClosure B A L] [FiniteDimensional K L] [Algebra.IsSeparable K L]\n--     [Module.Finite A B] in\n-- lemma adicCompletionComapSemialgHom_continuous\n--     (v : HeightOneSpectrum A) (w : HeightOneSpectrum B) (hvw : v = comap A w) :\n--     Continuous (adicCompletionComapSemialgHom A K L B v w hvw) := by\n--   convert UniformSpace.Completion.continuous_extension (\u03b2 := (adicCompletion L w))\n\n\nlemma adicCompletionComap_isModuleTopology\n    (v : HeightOneSpectrum A) (w : HeightOneSpectrum B) (hvw : v = comap A w) :\n    -- temporarily make L_w a K_v-algebra\n    let inst_alg : Algebra (HeightOneSpectrum.adicCompletion K v)\n      (HeightOneSpectrum.adicCompletion L w) := RingHom.toAlgebra <|\n        adicCompletionComapSemialgHom A K L B v w hvw\n    -- the claim that L_w has the module topology.\n    IsModuleTopology (HeightOneSpectrum.adicCompletion K v)\n      (HeightOneSpectrum.adicCompletion L w) := by\n  sorry -- FLT#326\n\nomit [IsIntegralClosure B A L] [FiniteDimensional K L] [Algebra.IsSeparable K L]\n    [Module.Finite A B] in\nlemma adicCompletionComapSemialgHom_coe\n    (v : HeightOneSpectrum A) (w : HeightOneSpectrum B) (hvw : v = comap A w) (x : K) :\n    adicCompletionComapSemialgHom A K L B v w hvw x = algebraMap K L x :=\n  (adicCompletionComapSemialgHom A K L B v w hvw).commutes x\n\nomit [IsIntegralClosure B A L] [FiniteDimensional K L] [Algebra.IsSeparable K L]\n    [Module.Finite A B] in\nopen WithZeroTopology in\nlemma v_adicCompletionComapSemialgHom\n  (v : HeightOneSpectrum A) (w : HeightOneSpectrum B) (hvw : v = comap A w) (x) :\n    Valued.v (adicCompletionComapSemialgHom A K L B v w hvw x) = Valued.v x ^\n      Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal := by\n  revert x\n  apply funext_iff.mp\n  symm\n  letI : UniformSpace K := v.adicValued.toUniformSpace\n  letI : UniformSpace L := w.adicValued.toUniformSpace\n  apply UniformSpace.Completion.ext\n  \u00b7 exact Valued.continuous_valuation.pow _\n  \u00b7 exact Valued.continuous_valuation.comp UniformSpace.Completion.continuous_extension\n  intro a\n  simp_rw [adicCompletionComapSemialgHom_coe, adicCompletion, Valued.valuedCompletion_apply,\n    adicValued_apply]\n  subst hvw\n  rw [\u2190 valuation_comap A K L B w a]\n\n/-- The canonical map `K_v \u2192 \u220f_{w|v} L_w` extending K \u2192 L. -/\nnoncomputable def adicCompletionComapSemialgHom' (v : HeightOneSpectrum A) :\n  (HeightOneSpectrum.adicCompletion K v) \u2192\u209b\u2090[algebraMap K L]\n    (\u2200 w : {w : HeightOneSpectrum B // v = comap A w}, HeightOneSpectrum.adicCompletion L w.1) :=\n  Pi.semialgHom _ _ fun i \u21a6 adicCompletionComapSemialgHom A K L B v i.1 i.2\n\nlemma prodAdicCompletionComap_isModuleTopology\n    (v : HeightOneSpectrum A) (w : HeightOneSpectrum B) (hvw : v = comap A w) :\n    -- temporarily make \u220f_w L_w a K_v-algebra\n    let inst_alg : Algebra (HeightOneSpectrum.adicCompletion K v)\n      (\u2200 w : {w : HeightOneSpectrum B // v = comap A w}, HeightOneSpectrum.adicCompletion L w.1) :=\n      RingHom.toAlgebra <|\n        Pi.ringHom (fun w : {w : HeightOneSpectrum B // v = comap A w} \u21a6 adicCompletionComapSemialgHom A K L B v w.1 w.2)\n    -- the claim that L_w has the module topology.\n    IsModuleTopology (HeightOneSpectrum.adicCompletion K v)\n      (\u2200 w : {w : HeightOneSpectrum B // v = comap A w}, HeightOneSpectrum.adicCompletion L w.1) := by\n  sorry -- FLT#327\n\nopen scoped TensorProduct -- \u2297 notation for tensor product\n\n/-- The canonical L-algebra map `L \u2297_K K_v \u2192 \u220f_{w|v} L_w`. -/\nnoncomputable def tensorAdicCompletionComapAlgHom (v : HeightOneSpectrum A) :\n    L \u2297[K] adicCompletion K v \u2192\u2090[L]\n      \u03a0 w : {w : HeightOneSpectrum B // v = comap A w}, adicCompletion L w.1 :=\n  SemialgHom.baseChange_of_algebraMap (adicCompletionComapSemialgHom' A K L B v)\n\nomit [IsIntegralClosure B A L] [FiniteDimensional K L] [Algebra.IsSeparable K L]\n    [Module.Finite A B] in\n", "theoremStatement": "lemma tensorAdicCompletionComapAlgHom_tmul_apply (v : HeightOneSpectrum A) (x y i) :\n  tensorAdicCompletionComapAlgHom A K L B v (x \u2297\u209c y) i =\n    x \u2022 adicCompletionComapSemialgHom A K L B v i.1 i.2 y ", "theoremName": "IsDedekindDomain.HeightOneSpectrum.tensorAdicCompletionComapAlgHom_tmul_apply", "fileCreated": {"commit": "17ea847a3d0172f39eea0bc008cd70a2755df629", "date": "2024-11-01"}, "theoremCreated": {"commit": "29510efcf26a734ba78b32808aac92e5370be601", "date": "2025-02-02"}, "file": "FLT/FLT/DedekindDomain/FiniteAdeleRing/BaseChange.lean", "module": "FLT.DedekindDomain.FiniteAdeleRing.BaseChange", "jsonFile": "FLT.DedekindDomain.FiniteAdeleRing.BaseChange.jsonl", "positionMetadata": {"lineInFile": 277, "tokenPositionInFile": 13467, "theoremPositionInFile": 11}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 5, "numPremises": 70}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [Algebra.smul_def]\n  rfl", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 35}}
{"srcContext": "import Mathlib.Analysis.Normed.Ring.WithAbs\nimport Mathlib.NumberTheory.NumberField.Basic\n\nnamespace WithAbs\n\nvariable {K : Type*} [Field K] {v : AbsoluteValue K \u211d}\n  {L : Type*} [Field L] [Algebra K L] {w : AbsoluteValue L \u211d}\n\ninstance : Algebra (WithAbs v) (WithAbs w) := \u2039Algebra K L\u203a\n\ninstance : Algebra K (WithAbs w) := \u2039Algebra K L\u203a\n\ninstance [NumberField K] : NumberField (WithAbs v) := \u2039NumberField K\u203a\n\n", "theoremStatement": "theorem norm_eq_abs (x : WithAbs v) : \u2016x\u2016 = v x ", "theoremName": "WithAbs.norm_eq_abs", "fileCreated": {"commit": "127de0cf1cfe4388059ffe6945fd866e45792a99", "date": "2025-02-02"}, "theoremCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "file": "FLT/FLT/Mathlib/Analysis/Normed/Ring/WithAbs.lean", "module": "FLT.Mathlib.Analysis.Normed.Ring.WithAbs", "jsonFile": "FLT.Mathlib.Analysis.Normed.Ring.WithAbs.jsonl", "positionMetadata": {"lineInFile": 15, "tokenPositionInFile": 411, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 15}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "import Mathlib.Algebra.Algebra.Pi\nimport FLT.Mathlib.Algebra.Algebra.Hom\n\ndef Pi.semialgHom  {I : Type*} {R S : Type*} (f : I \u2192 Type*) [CommSemiring R] [CommSemiring S]\n    (\u03c6 : R \u2192+* S) [s : (i : I) \u2192 Semiring (f i)] [(i : I) \u2192 Algebra S (f i)] {A : Type*}\n    [Semiring A]  [Algebra R A] (g : (i : I) \u2192 A \u2192\u209b\u2090[\u03c6] f i) :\n  A \u2192\u209b\u2090[\u03c6] (i : I) \u2192 f i where\n  __ := Pi.ringHom fun i \u21a6 (g i).toRingHom\n  map_smul' r a := by ext; simp\n\n", "theoremStatement": "@[simp]\ntheorem Pi.semialgHom_apply {I : Type*} {R S : Type*} (f : I \u2192 Type*) [CommSemiring R] [CommSemiring S]\n    (\u03c6 : R \u2192+* S) [s : (i : I) \u2192 Semiring (f i)] [(i : I) \u2192 Algebra S (f i)] {A : Type*}\n    [Semiring A] [Algebra R A] (g : (i : I) \u2192 A \u2192\u209b\u2090[\u03c6] f i) (a : A) (i : I) :\n  (Pi.semialgHom _ \u03c6 g) a i = g i a ", "theoremName": "Pi.semialgHom_apply", "fileCreated": {"commit": "f463c53242f2ad3f5bdbee5b2078741ebf425207", "date": "2025-01-31"}, "theoremCreated": {"commit": "127241373eb7d4afd5ff86dc0e5082497c364f08", "date": "2025-02-05"}, "file": "FLT/FLT/Mathlib/Algebra/Algebra/Pi.lean", "module": "FLT.Mathlib.Algebra.Algebra.Pi", "jsonFile": "FLT.Mathlib.Algebra.Algebra.Pi.jsonl", "positionMetadata": {"lineInFile": 11, "tokenPositionInFile": 428, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 3, "numPremises": 14}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "import Mathlib.GroupTheory.Index\n\n/-!\n# TODO\n\n* Rename `relindex` to `relIndex`\n* Rename `FiniteIndex.finiteIndex` to `FiniteIndex.index_ne_zero`\n-/\n\nopen Function\nopen scoped Pointwise\n\n-- This is cool notation. Should mathlib have it? And what should the `relindex` version be?\nscoped[GroupTheory] notation \"[\" G \":\" H \"]\" => @AddSubgroup.index G _ H\n\nnamespace Subgroup\nvariable {G G' : Type*} [Group G] [Group G'] {f : G \u2192* G'} {H K : Subgroup G}\n\nclass _root_.AddSubgroup.FiniteRelIndex {G : Type*} [AddGroup G] (H K : AddSubgroup G) : Prop where\n  protected relIndex_ne_zero : H.relindex K \u2260 0\n\n@[to_additive] class FiniteRelIndex (H K : Subgroup G) : Prop where\n  protected relIndex_ne_zero : H.relindex K \u2260 0\n\n@[to_additive]\nlemma relIndex_ne_zero [H.FiniteRelIndex K] : H.relindex K \u2260 0 := FiniteRelIndex.relIndex_ne_zero\n\n@[to_additive]\ninstance FiniteRelIndex.to_finiteIndex_subgroupOf [H.FiniteRelIndex K] :\n    (H.subgroupOf K).FiniteIndex where\n  finiteIndex := relIndex_ne_zero\n\n@[to_additive]\nlemma index_map_of_bijective (S : Subgroup G) (hf : Bijective f) : (S.map f).index = S.index :=\n  index_map_eq _ hf.2 (by rw [f.ker_eq_bot_iff.2 hf.1]; exact bot_le)\n\nend Subgroup\n\nnamespace AddSubgroup\nvariable {G A : Type*} [Group G] [AddGroup A] [DistribMulAction G A]\n\n-- TODO: Why does making this lemma simp make `NumberTheory.Padic.PadicIntegers` time out?\n", "theoremStatement": "lemma index_smul (a : G) (S : AddSubgroup A) : (a \u2022 S).index = S.index ", "theoremName": "AddSubgroup.index_smul", "fileCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "theoremCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "file": "FLT/FLT/Mathlib/GroupTheory/Index.lean", "module": "FLT.Mathlib.GroupTheory.Index", "jsonFile": "FLT.Mathlib.GroupTheory.Index.jsonl", "positionMetadata": {"lineInFile": 43, "tokenPositionInFile": 1373, "theoremPositionInFile": 3}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 1, "numPremises": 26}, "proofMetadata": {"hasProof": true, "proof": ":=\n  index_map_of_bijective _ (MulAction.bijective _)", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 53}}
{"srcContext": "import Mathlib -- because there are sorries in this file\nimport FLT.Mathlib.Algebra.Order.Hom.Monoid\nimport FLT.Mathlib.Algebra.Algebra.Hom\nimport FLT.Mathlib.Algebra.Algebra.Pi\nimport FLT.Mathlib.Algebra.Algebra.Bilinear\nimport FLT.Mathlib.Topology.Algebra.UniformRing\n\n\n/-!\n\n# Base change of adele rings.\n\nIf `A` is a Dedekind domain with field of fractions `K`, if `L/K` is a finite separable\nextension and if `B` is the integral closure of `A` in `L`, then `B` is also a Dedekind\ndomain. Hence the rings of finite adeles `\ud835\udd38_K^\u221e` and `\ud835\udd38_L^\u221e` (defined using `A` and `B`)\nare defined. In this file we define the natural `K`-algebra map `\ud835\udd38_K^\u221e \u2192 \ud835\udd38_L^\u221e` and\nthe natural `L`-algebra map `\ud835\udd38_K^\u221e \u2297[K] L \u2192 \ud835\udd38_L^\u221e`, and show that the latter map\nis an isomorphism.\n\n## Main definition\n\n* `FiniteAdeleRing.baseChangeEquiv : L \u2297[K] FiniteAdeleRing A K \u2243\u2090[L] FiniteAdeleRing B L`\n\n-/\n\nopen scoped Multiplicative\n\n-- The general set-up.\n\nvariable (A K L B : Type*) [CommRing A] [CommRing B] [Algebra A B] [Field K] [Field L]\n    [Algebra A K] [IsFractionRing A K] [Algebra B L] [IsDedekindDomain A]\n    [Algebra K L] [Algebra A L] [IsScalarTower A B L] [IsScalarTower A K L]\n    [IsIntegralClosure B A L] [FiniteDimensional K L]\n\nvariable [Algebra.IsSeparable K L]\n\nexample : Function.Injective (algebraMap B L) := IsIntegralClosure.algebraMap_injective' A\n\nexample : IsDomain B := by\n  have foo : Function.Injective (algebraMap B L) := IsIntegralClosure.algebraMap_injective' A\n  have bar : IsDomain L := inferInstance\n  exact Function.Injective.isDomain _ foo -- exact? failed\nvariable [IsDomain B]\n\nexample : Algebra.IsIntegral A B := IsIntegralClosure.isIntegral_algebra A L\nvariable [Algebra.IsIntegral A B]\n\nexample : Module.Finite A B :=\n  have := IsIntegralClosure.isNoetherian A K L B\n  Module.IsNoetherian.finite A B\nvariable [Module.Finite A B]\n\nexample : IsDedekindDomain B := IsIntegralClosure.isDedekindDomain A K L B\nvariable [IsDedekindDomain B]\n\nexample : IsFractionRing B L := IsIntegralClosure.isFractionRing_of_finite_extension A K L B\nvariable [IsFractionRing B L]\n\n-- We start by filling in some holes in the API for finite extensions of Dedekind domains.\nnamespace IsDedekindDomain\n\nnamespace HeightOneSpectrum\n\n-- first need a way to pull back valuations on B to A\nvariable {B L} in\ndef comap (w : HeightOneSpectrum B) : HeightOneSpectrum A where\n  asIdeal := w.asIdeal.comap (algebraMap A B)\n  isPrime := Ideal.comap_isPrime (algebraMap A B) w.asIdeal\n  ne_bot := mt Ideal.eq_bot_of_comap_eq_bot w.ne_bot\n\nomit [Module.Finite A B] in\nlemma mk_count_factors_map\n    (hAB : Function.Injective (algebraMap A B))\n    (w : HeightOneSpectrum B) (I : Ideal A) [DecidableEq (Associates (Ideal A))]\n  [DecidableEq (Associates (Ideal B))] [\u2200 p : Associates (Ideal A), Decidable (Irreducible p)]\n  [\u2200 p : Associates (Ideal B), Decidable (Irreducible p)] :\n    (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) I)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk I).factors := by\n  classical\n  induction I using UniqueFactorizationMonoid.induction_on_prime with\n  | h\u2081 =>\n    rw [Associates.mk_zero, Ideal.zero_eq_bot, Ideal.map_bot, \u2190 Ideal.zero_eq_bot,\n      Associates.mk_zero]\n    simp [Associates.count, Associates.factors_zero, w.associates_irreducible,\n      associates_irreducible (comap A w), Associates.bcount]\n  | h\u2082 I hI =>\n    obtain rfl : I = \u22a4 := by simpa using hI\n    simp only [Submodule.zero_eq_bot, ne_eq, top_ne_bot, not_false_eq_true, Ideal.map_top]\n    simp only [\u2190 Ideal.one_eq_top, Associates.mk_one, Associates.factors_one]\n    rw [Associates.count_zero (associates_irreducible _),\n      Associates.count_zero (associates_irreducible _), mul_zero]\n  | h\u2083 I p hI hp IH =>\n    simp only [Ideal.map_mul, \u2190 Associates.mk_mul_mk]\n    have hp_bot : p \u2260 \u22a5 := hp.ne_zero\n    have hp_bot' := (Ideal.map_eq_bot_iff_of_injective hAB).not.mpr hp_bot\n    have hI_bot := (Ideal.map_eq_bot_iff_of_injective hAB).not.mpr hI\n    rw [Associates.count_mul (Associates.mk_ne_zero.mpr hp_bot) (Associates.mk_ne_zero.mpr hI)\n      (associates_irreducible _), Associates.count_mul (Associates.mk_ne_zero.mpr hp_bot')\n      (Associates.mk_ne_zero.mpr hI_bot) (associates_irreducible _)]\n    simp only [IH, mul_add]\n    congr 1\n    by_cases hw : (w.comap A).asIdeal = p\n    \u00b7 have : Irreducible (Associates.mk p) := Associates.irreducible_mk.mpr hp.irreducible\n      rw [hw, Associates.factors_self this, Associates.count_some this]\n      simp only [UniqueFactorizationMonoid.factors_eq_normalizedFactors, Multiset.nodup_singleton,\n        Multiset.mem_singleton, Multiset.count_eq_one_of_mem, mul_one]\n      rw [count_associates_factors_eq hp_bot' w.2 w.3,\n        Ideal.IsDedekindDomain.ramificationIdx_eq_normalizedFactors_count hp_bot' w.2 w.3]\n    \u00b7 have : (Associates.mk (comap A w).asIdeal).count (Associates.mk p).factors = 0 :=\n        Associates.count_eq_zero_of_ne (associates_irreducible _)\n          (Associates.irreducible_mk.mpr hp.irreducible)\n          (by rwa [ne_eq, Associates.mk_eq_mk_iff_associated, associated_iff_eq])\n      rw [this, mul_zero, eq_comm]\n      by_contra H\n      rw [eq_comm, \u2190 ne_eq, Associates.count_ne_zero_iff_dvd hp_bot' (irreducible w),\n        Ideal.dvd_iff_le, Ideal.map_le_iff_le_comap] at H\n      apply hw (((Ideal.isPrime_of_prime hp).isMaximal hp_bot).eq_of_le (comap A w).2.ne_top H).symm\n\nomit [Module.Finite A B] in\nlemma intValuation_comap (hAB : Function.Injective (algebraMap A B))\n    (w : HeightOneSpectrum B) (x : A) :\n    (comap A w).intValuation x ^\n    (Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal) =\n    w.intValuation (algebraMap A B x) := by\n  classical\n  have h_ne_zero : Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal \u2260 0 :=\n    Ideal.IsDedekindDomain.ramificationIdx_ne_zero\n      ((Ideal.map_eq_bot_iff_of_injective hAB).not.mpr (comap A w).3) w.2 Ideal.map_comap_le\n  by_cases hx : x = 0\n  \u00b7 simpa [hx]\n  simp only [intValuation, Valuation.coe_mk, MonoidWithZeroHom.coe_mk, ZeroHom.coe_mk]\n  show (ite _ _ _) ^ _ = ite _ _ _\n  by_cases hx : x = 0\n  \u00b7 subst hx; simp [h_ne_zero]\n  rw [map_eq_zero_iff _ hAB, if_neg hx, if_neg hx, \u2190 Set.image_singleton, \u2190 Ideal.map_span,\n    mk_count_factors_map _ _ hAB, mul_comm]\n  simp\n\n-- Need to know how the valuation `w` and its pullback are related on elements of `K`.\nomit [IsIntegralClosure B A L] [FiniteDimensional K L] [Algebra.IsSeparable K L]\n    [Module.Finite A B] in\nlemma valuation_comap (w : HeightOneSpectrum B) (x : K) :\n    (comap A w).valuation x ^\n    (Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal) =\n    w.valuation (algebraMap K L x) := by\n  obtain \u27e8x, y, hy, rfl\u27e9 := IsFractionRing.div_surjective (A := A) x\n  simp [valuation, \u2190 IsScalarTower.algebraMap_apply A K L, IsScalarTower.algebraMap_apply A B L,\n    \u2190 intValuation_comap A B (algebraMap_injective_of_field_isFractionRing A B K L), div_pow]\n\nomit [IsIntegralClosure B A L] [FiniteDimensional K L] [Algebra.IsSeparable K L]\n    [Module.Finite A B] in\nlemma _root_.IsDedekindDomain.HeightOneSpectrum.adicValued.continuous_algebraMap\n    (v : HeightOneSpectrum A) (w : HeightOneSpectrum B) (hvw : v = comap A w) :\n    letI : UniformSpace K := v.adicValued.toUniformSpace;\n    letI : UniformSpace L := w.adicValued.toUniformSpace;\n    Continuous (algebraMap K L) := by\n  letI : UniformSpace K := v.adicValued.toUniformSpace;\n  letI : UniformSpace L := w.adicValued.toUniformSpace;\n  subst hvw\n  refine continuous_of_continuousAt_zero (algebraMap K L) ?hf\n  delta ContinuousAt\n  simp only [map_zero]\n  rw [(@Valued.hasBasis_nhds_zero K _ _ _ (comap A w).adicValued).tendsto_iff\n    (@Valued.hasBasis_nhds_zero L _ _ _ w.adicValued)]\n  simp only [HeightOneSpectrum.adicValued_apply, Set.mem_setOf_eq, true_and, true_implies]\n  rw [WithZero.unitsWithZeroEquiv.forall_congr_left, Multiplicative.forall]\n  intro a\n  rw [WithZero.unitsWithZeroEquiv.exists_congr_left, Multiplicative.exists]\n  let m := Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal\n  let e : \u2124 \u2243 \u2124\u2098\u2080\u02e3 := Multiplicative.ofAdd.trans OrderMonoidIso.unitsWithZero.symm.toEquiv\n  have e_apply (a : \u2124) : e a = OrderMonoidIso.unitsWithZero.symm (Multiplicative.ofAdd a) := rfl\n  have hm : m \u2260 0 := by\n    refine Ideal.IsDedekindDomain.ramificationIdx_ne_zero ?_ w.2 Ideal.map_comap_le\n    exact (Ideal.map_eq_bot_iff_of_injective\n      (algebraMap_injective_of_field_isFractionRing A B K L)).not.mpr (comap A w).3\n  refine \u27e8a / m, fun x hx \u21a6 ?_\u27e9\n  simp_rw [\u2190 valuation_comap A]\n  calc\n    (comap A w).valuation x ^ m < e (a / \u2191m) ^ m := by gcongr; exacts [zero_le', hx]\n  _ = e (m \u2022 (a / \u2191m)) := by\n    dsimp [e]\n    norm_cast\n    rw [map_pow]\n  _ \u2264 e a := by\n    simp only [nsmul_eq_mul, e_apply, Units.val_le_val, OrderIsoClass.map_le_map_iff]\n    rw [mul_comm]\n    exact Int.mul_le_of_le_ediv (by positivity) le_rfl\n\nnoncomputable def adicCompletionComapSemialgHom (v : HeightOneSpectrum A) (w : HeightOneSpectrum B)\n    (hvw : v = comap A w) :\n    (HeightOneSpectrum.adicCompletion K v) \u2192\u209b\u2090[algebraMap K L]\n      (HeightOneSpectrum.adicCompletion L w) :=\n  letI : UniformSpace K := v.adicValued.toUniformSpace;\n  letI : UniformSpace L := w.adicValued.toUniformSpace;\n  UniformSpace.Completion.mapSemialgHom _ <|\n  IsDedekindDomain.HeightOneSpectrum.adicValued.continuous_algebraMap A K L B v w hvw\n\n-- Do we even need to prove that this map is continuous? It will follow from\n-- the fact that it's K_v-linear once we know L_w has the K_v-module topology,\n-- which is the next lemma.\n-- omit [IsIntegralClosure B A L] [FiniteDimensional K L] [Algebra.IsSeparable K L]\n--     [Module.Finite A B] in\n-- lemma adicCompletionComapSemialgHom_continuous\n--     (v : HeightOneSpectrum A) (w : HeightOneSpectrum B) (hvw : v = comap A w) :\n--     Continuous (adicCompletionComapSemialgHom A K L B v w hvw) := by\n--   convert UniformSpace.Completion.continuous_extension (\u03b2 := (adicCompletion L w))\n\n\nlemma adicCompletionComap_isModuleTopology\n    (v : HeightOneSpectrum A) (w : HeightOneSpectrum B) (hvw : v = comap A w) :\n    -- temporarily make L_w a K_v-algebra\n    let inst_alg : Algebra (HeightOneSpectrum.adicCompletion K v)\n      (HeightOneSpectrum.adicCompletion L w) := RingHom.toAlgebra <|\n        adicCompletionComapSemialgHom A K L B v w hvw\n    -- the claim that L_w has the module topology.\n    IsModuleTopology (HeightOneSpectrum.adicCompletion K v)\n      (HeightOneSpectrum.adicCompletion L w) := by\n  sorry -- FLT#326\n\nomit [IsIntegralClosure B A L] [FiniteDimensional K L] [Algebra.IsSeparable K L]\n    [Module.Finite A B] in\n", "theoremStatement": "lemma adicCompletionComapSemialgHom_coe\n    (v : HeightOneSpectrum A) (w : HeightOneSpectrum B) (hvw : v = comap A w) (x : K) :\n    adicCompletionComapSemialgHom A K L B v w hvw x = algebraMap K L x ", "theoremName": "IsDedekindDomain.HeightOneSpectrum.adicCompletionComapSemialgHom_coe", "fileCreated": {"commit": "17ea847a3d0172f39eea0bc008cd70a2755df629", "date": "2024-11-01"}, "theoremCreated": {"commit": "f463c53242f2ad3f5bdbee5b2078741ebf425207", "date": "2025-01-31"}, "file": "FLT/FLT/DedekindDomain/FiniteAdeleRing/BaseChange.lean", "module": "FLT.DedekindDomain.FiniteAdeleRing.BaseChange", "jsonFile": "FLT.DedekindDomain.FiniteAdeleRing.BaseChange.jsonl", "positionMetadata": {"lineInFile": 223, "tokenPositionInFile": 10695, "theoremPositionInFile": 6}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 5, "numPremises": 46}, "proofMetadata": {"hasProof": true, "proof": ":=\n  (adicCompletionComapSemialgHom A K L B v w hvw).commutes x", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 63}}
{"srcContext": "/-\nCopyright (c) 2024 Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras\n-/\nimport Mathlib.Analysis.Complex.ReImTopology\nimport Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar\nimport Mathlib.RingTheory.Complex\nimport Mathlib.RingTheory.Norm.Transitivity\nimport FLT.HaarMeasure.DistribHaarChar.Basic\nimport FLT.Mathlib.LinearAlgebra.Determinant\n\n/-!\n# The distributive Haar characters of `\u211d` and `\u2102`\n\nThis file computes `distribHaarChar` in the case of the actions of `\u211d\u02e3` on `\u211d` and of `\u2102\u02e3` on `\u2102`.\n\nThis lets us know what `volume (x \u2022 s)` is in terms of `\u2016x\u2016` and `volume s`, when `x` is a\nreal/complex number and `s` is a set of reals/complex numbers.\n\n## Main declarations\n\n* `distribHaarChar_real`: `distribHaarChar \u211d` is the usual norm on `\u211d`.\n* `distribHaarChar_complex`: `distribHaarChar \u2102` is the usual norm on `\u2102` squared.\n* `Real.volume_real_smul`: `volume (x \u2022 s) = \u2016x\u2016\u208a * volume s` for all `x : \u211d` and `s : Set \u211d`.\n* `Complex.volume_complex_smul`: `volume (z \u2022 s) = \u2016z\u2016\u208a ^ 2 * volume s` for all `z : \u2102` and\n  `s : Set \u2102`.\n-/\n\nopen Real Complex MeasureTheory Measure Set\nopen scoped Pointwise\n\nlemma Real.volume_real_smul (x : \u211d) (s : Set \u211d) : volume (x \u2022 s) = \u2016x\u2016\u208a * volume s := by\n  simp [\u2190 enorm_eq_ofReal_abs, enorm_eq_nnnorm]\n\n/-- The distributive Haar character of the action of `\u211d\u02e3` on `\u211d` is the usual norm.\n\nThis means that `volume (x \u2022 s) = \u2016x\u2016 * volume s` for all `x : \u211d` and `s : Set \u211d`.\nSee `Real.volume_real_smul`. -/\nlemma distribHaarChar_real (x : \u211d\u02e3) : distribHaarChar \u211d x = \u2016(x : \u211d)\u2016\u208a :=\n  -- We compute that `volume (x \u2022 [0, 1]) = \u2016x\u2016\u208a * volume [0, 1]`.\n  distribHaarChar_eq_of_measure_smul_eq_mul (s := Icc 0 1) (\u03bc := volume)\n    (measure_pos_of_nonempty_interior _ <| by simp).ne' isCompact_Icc.measure_ne_top\n      (Real.volume_real_smul ..)\n\n/-- The distributive Haar character of the action of `\u2102\u02e3` on `\u2102` is the usual norm squared.\n\nThis means that `volume (z \u2022 s) = \u2016z\u2016 ^ 2 * volume s` for all `z : \u2102` and `s : Set \u2102`.\nSee `Complex.volume_complex_smul`. -/\nlemma distribHaarChar_complex (z : \u2102\u02e3) : distribHaarChar \u2102 z = \u2016(z : \u2102)\u2016\u208a ^ 2 := by\n  -- We compute that `volume (x \u2022 ([0, 1] \u00d7 [0, 1])) = \u2016x\u2016\u208a ^ 2 * volume ([0, 1] \u00d7 [0, 1])`.\n  refine distribHaarChar_eq_of_measure_smul_eq_mul (s := Icc 0 1 \u00d7\u2102 Icc 0 1) (\u03bc := volume)\n    (measure_pos_of_nonempty_interior _ <| by simp [interior_reProdIm]).ne'\n    (isCompact_Icc.reProdIm isCompact_Icc).measure_ne_top ?_\n  -- The determinant of left multiplication by `z\u207b\u00b9` as a `\u211d`-linear map is `\u2016z\u2016\u208a ^ (-2)`.\n  have key : ((LinearMap.mul \u2102 \u2102 z\u207b\u00b9).restrictScalars \u211d).det = \u2016z.val\u2016\u208a ^ (-2 : \u2124) := by\n    refine Complex.ofReal_injective ?_\n    rw [LinearMap.det_restrictScalars]\n    simp [Algebra.norm_complex_apply, normSq_eq_norm_sq, zpow_ofNat]\n  -- Massaging, we find the result.\n  convert addHaar_preimage_linearMap (E := \u2102) volume\n    (f := (LinearMap.mul \u2102 \u2102 z\u207b\u00b9).restrictScalars \u211d) _ _ using 2\n  \u00b7 simpa [LinearMap.mul, LinearMap.mk\u2082, LinearMap.mk\u2082', LinearMap.mk\u2082'\u209b\u2097, Units.smul_def, eq_comm]\n      using preimage_smul_inv z (Icc 0 1 \u00d7\u2102 Icc 0 1)\n  \u00b7 simp [key, ofReal_norm_eq_enorm, \u2190 Complex.norm_eq_abs, ENNReal.ofReal_pow, zpow_ofNat]; rfl\n  \u00b7 simp [key, zpow_ofNat]\n\n", "theoremStatement": "lemma Complex.volume_complex_smul (z : \u2102) (s : Set \u2102) : volume (z \u2022 s) = \u2016z\u2016\u208a ^ 2 * volume s ", "theoremName": "Complex.volume_complex_smul", "fileCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "theoremCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "file": "FLT/FLT/HaarMeasure/DistribHaarChar/RealComplex.lean", "module": "FLT.HaarMeasure.DistribHaarChar.RealComplex", "jsonFile": "FLT.HaarMeasure.DistribHaarChar.RealComplex.jsonl", "positionMetadata": {"lineInFile": 68, "tokenPositionInFile": 3278, "theoremPositionInFile": 3}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 3, "numPremises": 219}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  obtain rfl | hz := eq_or_ne z 0\n  \u00b7 simp [(finite_zero.subset s.zero_smul_set_subset).measure_zero]\n  \u00b7 lift z to \u2102\u02e3 using hz.isUnit\n    rw [\u2190 ENNReal.coe_pow, \u2190 distribHaarChar_complex, distribHaarChar_mul, Units.smul_def]", "proofType": "tactic", "proofLengthLines": 4, "proofLengthTokens": 231}}
{"srcContext": "/-\nCopyright (c) 2024 Andrew Yang, Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang, Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras\n-/\nimport FLT.HaarMeasure.DomMulActMeasure\n\n/-!\n# The distributive character of Haar measures\n\nGiven a group `G` acting on an measurable additive commutative group `A`, and an element `g : G`,\none can pull back the Haar measure `\u03bc` of `A` along the map `(g \u2022 \u00b7) : A \u2192 A` to get another Haar\nmeasure `\u03bc'` on `A`. By unicity of Haar measures, there exists some nonnegative real number `r` such\nthat `\u03bc' = r \u2022 \u03bc`. We can thus define a map `distribHaarChar : G \u2192 \u211d\u22650` sending `g` to its\nassociated real number `r`. Furthermore, this number doesn't depend on the Haar measure `\u03bc` we\nstarted with, and `distribHaarChar` is a group homomorphism.\n\n## See also\n\n[Zulip](https://leanprover.zulipchat.com/#narrow/channel/217875-Is-there-code-for-X.3F/topic/canonical.20norm.20coming.20from.20Haar.20measure/near/480050592)\n-/\n\nopen scoped NNReal Pointwise ENNReal\n\nnamespace MeasureTheory.Measure\n\nvariable {G A : Type*} [Group G] [AddCommGroup A] [DistribMulAction G A]\n  [MeasurableSpace A]\n  [MeasurableSpace G] -- not needed actually\n  [MeasurableSMul G A] -- only need `MeasurableConstSMul` but we don't have this class.\nvariable {\u03bc \u03bd : Measure A} {g : G}\n\nvariable [TopologicalSpace A] [BorelSpace A] [TopologicalAddGroup A] [LocallyCompactSpace A]\n  [ContinuousConstSMul G A] [\u03bc.IsAddHaarMeasure] [\u03bd.IsAddHaarMeasure]\n\nvariable (\u03bc A) in\n@[simps (config := .lemmasOnly)]\nnoncomputable def distribHaarChar : G \u2192* \u211d\u22650 where\n  toFun g := addHaarScalarFactor (DomMulAct.mk g \u2022 addHaar) (addHaar (G := A))\n  map_one' := by simp\n  map_mul' g g' := by\n    simp_rw [DomMulAct.mk_mul]\n    rw [addHaarScalarFactor_eq_mul _ (DomMulAct.mk g' \u2022 addHaar (G := A))]\n    congr 1\n    simp_rw [mul_smul]\n    rw [addHaarScalarFactor_domSMul]\n\nvariable (\u03bc) in\nlemma addHaarScalarFactor_smul_eq_distribHaarChar (g : G) :\n    addHaarScalarFactor (DomMulAct.mk g \u2022 \u03bc) \u03bc = distribHaarChar A g :=\n  addHaarScalarFactor_smul_congr' ..\n\nvariable (\u03bc) in\nlemma addHaarScalarFactor_smul_inv_eq_distribHaarChar (g : G) :\n    addHaarScalarFactor \u03bc ((DomMulAct.mk g)\u207b\u00b9 \u2022 \u03bc) = distribHaarChar A g := by\n  rw [\u2190 addHaarScalarFactor_domSMul _ _ (DomMulAct.mk g)]\n  simp_rw [\u2190 mul_smul, mul_inv_cancel, one_smul]\n  exact addHaarScalarFactor_smul_eq_distribHaarChar ..\n\nvariable (\u03bc) in\nlemma addHaarScalarFactor_smul_eq_distribHaarChar_inv (g : G) :\n    addHaarScalarFactor \u03bc (DomMulAct.mk g \u2022 \u03bc) = (distribHaarChar A g)\u207b\u00b9 := by\n  rw [\u2190 map_inv, \u2190 addHaarScalarFactor_smul_inv_eq_distribHaarChar \u03bc, DomMulAct.mk_inv, inv_inv]\n\nlemma distribHaarChar_pos : 0 < distribHaarChar A g :=\n  pos_iff_ne_zero.mpr ((Group.isUnit g).map (distribHaarChar A)).ne_zero\n\nvariable [Regular \u03bc] {s : Set A}\n\nvariable (\u03bc) in\nlemma distribHaarChar_mul (g : G) (s : Set A) : distribHaarChar A g * \u03bc s = \u03bc (g \u2022 s) := by\n  have : (DomMulAct.mk g \u2022 \u03bc) s = \u03bc (g \u2022 s) := by simp [domSMul_apply]\n  rw [eq_comm, \u2190 nnreal_smul_coe_apply, \u2190 addHaarScalarFactor_smul_eq_distribHaarChar \u03bc,\n    \u2190 this, \u2190 smul_apply, \u2190 isAddLeftInvariant_eq_smul_of_regular]\n\nlemma distribHaarChar_eq_div (hs\u2080 : \u03bc s \u2260 0) (hs : \u03bc s \u2260 \u221e) (g : G) :\n    distribHaarChar A g = \u03bc (g \u2022 s) / \u03bc s := by\n  rw [\u2190 distribHaarChar_mul, ENNReal.mul_div_cancel_right] <;> simp [*]\n\n", "theoremStatement": "lemma distribHaarChar_eq_of_measure_smul_eq_mul (hs\u2080 : \u03bc s \u2260 0) (hs : \u03bc s \u2260 \u221e) {r : \u211d\u22650}\n    (h\u03bcgs : \u03bc (g \u2022 s) = r * \u03bc s) : distribHaarChar A g = r ", "theoremName": "MeasureTheory.Measure.distribHaarChar_eq_of_measure_smul_eq_mul", "fileCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "theoremCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "file": "FLT/FLT/HaarMeasure/DistribHaarChar/Basic.lean", "module": "FLT.HaarMeasure.DistribHaarChar.Basic", "jsonFile": "FLT.HaarMeasure.DistribHaarChar.Basic.jsonl", "positionMetadata": {"lineInFile": 80, "tokenPositionInFile": 3395, "theoremPositionInFile": 6}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 73}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  refine ENNReal.coe_injective ?_\n  rw [distribHaarChar_eq_div hs\u2080 hs, h\u03bcgs, ENNReal.mul_div_cancel_right] <;> simp [*]", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 125}}
{"srcContext": "import Mathlib.Algebra.Algebra.Hom\n\nsection semialghom\n\n/-- Let `\u03c6 : R \u2192+* S` be a ring homomorphism, let `A` be an `R`-algebra and let `B` be\nan `S`-algebra. Then `SemialgHom \u03c6 A B` or `A \u2192\u209b\u2090[\u03c6] B` is the ring homomorphisms `\u03c8 : A \u2192+* B`\nmaking lying above `\u03c6` (i.e. such that `\u03c8 (r \u2022 a) = \u03c6 r \u2022 \u03c8 a`).\n-/\nstructure SemialgHom {R S : Type*} [CommSemiring R] [CommSemiring S] (\u03c6 : R \u2192+* S)\n    (A B : Type*)  [Semiring A] [Semiring B] [Algebra R A] [Algebra S B]\n    extends A \u2192\u209b\u2097[\u03c6] B, RingHom A B\n\n@[inherit_doc SemialgHom]\ninfixr:25 \" \u2192\u209b\u2090 \" => SemialgHom _\n\n@[inherit_doc]\nnotation:25 A \" \u2192\u209b\u2090[\" \u03c6:25 \"] \" B:0 => SemialgHom \u03c6 A B\n\nvariable {R S : Type*} [CommSemiring R] [CommSemiring S] (\u03c6 : R \u2192+* S)\n    (A B : Type*)  [Semiring A] [Semiring B] [Algebra R A] [Algebra S B]\n\ninstance instFunLike : FunLike (A \u2192\u209b\u2090[\u03c6] B) A B where\n  coe f := f.toFun\n  coe_injective' f g h := by\n    cases f\n    cases g\n    congr\n    exact DFunLike.coe_injective' h\n\nvariable {\u03c6} {A} {B} in\nlemma SemialgHom.map_smul (\u03c8 : A \u2192\u209b\u2090[\u03c6] B) (m : R) (x : A) : \u03c8 (m \u2022 x) = \u03c6 m \u2022 \u03c8 x :=\n  LinearMap.map_smul' \u03c8.toLinearMap m x\n\nend semialghom\n\nsection semialghomclass\n\nclass SemialgHomClass (F : Type*) {R S : outParam Type*}\n  [CommSemiring R] [CommSemiring S] (\u03c6 : outParam (R \u2192+* S)) (A B : outParam Type*)\n  [Semiring A] [Semiring B] [Algebra R A] [Algebra S B]\n  [FunLike F A B] extends SemilinearMapClass F \u03c6 A B, RingHomClass F A B\n\nvariable (F : Type*) {R S : Type*}\n  [CommSemiring R] [CommSemiring S] (\u03c6 : R \u2192+* S) (A B : outParam Type*)\n  [Semiring A] [Semiring B] [Algebra R A] [Algebra S B]\n  [FunLike F A B] [SemialgHomClass F \u03c6 A B]\n\ninstance SemialgHomClass.instSemialgHom : SemialgHomClass (A \u2192\u209b\u2090[\u03c6] B) \u03c6 A B where\n  map_add \u03c8 := \u03c8.map_add\n  map_smul\u209b\u2097 \u03c8 := \u03c8.map_smul\u209b\u2097\n  map_mul \u03c8 := \u03c8.map_mul\n  map_one \u03c8 := \u03c8.map_one\n  map_zero \u03c8 := \u03c8.map_zero\n\nend semialghomclass\n\nsection semialghom\n\nvariable {R S : Type*} [CommSemiring R] [CommSemiring S] {\u03c6 : R \u2192+* S}\n    {A B : Type*}  [Semiring A] [Semiring B] [Algebra R A] [Algebra S B]\n\n", "theoremStatement": "lemma SemialgHom.commutes (\u03c8 : A \u2192\u209b\u2090[\u03c6] B) (r : R) :\n    \u03c8 (algebraMap R A r) = algebraMap S B (\u03c6 r) ", "theoremName": "SemialgHom.commutes", "fileCreated": {"commit": "f463c53242f2ad3f5bdbee5b2078741ebf425207", "date": "2025-01-31"}, "theoremCreated": {"commit": "f463c53242f2ad3f5bdbee5b2078741ebf425207", "date": "2025-01-31"}, "file": "FLT/FLT/Mathlib/Algebra/Algebra/Hom.lean", "module": "FLT.Mathlib.Algebra.Algebra.Hom", "jsonFile": "FLT.Mathlib.Algebra.Algebra.Hom.jsonl", "positionMetadata": {"lineInFile": 62, "tokenPositionInFile": 2026, "theoremPositionInFile": 3}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 5, "repositoryPremises": true, "numRepositoryPremises": 5, "numPremises": 44}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  have := \u03c8.map_smul r 1\n  rw [Algebra.smul_def, mul_one, map_one] at this\n  rw [this, Algebra.smul_def, mul_one]", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 119}}
{"srcContext": "/-\nCopyright (c) 2024 Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras\n-/\nimport Mathlib.Analysis.Complex.ReImTopology\nimport Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar\nimport Mathlib.RingTheory.Complex\nimport Mathlib.RingTheory.Norm.Transitivity\nimport FLT.HaarMeasure.DistribHaarChar.Basic\nimport FLT.Mathlib.LinearAlgebra.Determinant\n\n/-!\n# The distributive Haar characters of `\u211d` and `\u2102`\n\nThis file computes `distribHaarChar` in the case of the actions of `\u211d\u02e3` on `\u211d` and of `\u2102\u02e3` on `\u2102`.\n\nThis lets us know what `volume (x \u2022 s)` is in terms of `\u2016x\u2016` and `volume s`, when `x` is a\nreal/complex number and `s` is a set of reals/complex numbers.\n\n## Main declarations\n\n* `distribHaarChar_real`: `distribHaarChar \u211d` is the usual norm on `\u211d`.\n* `distribHaarChar_complex`: `distribHaarChar \u2102` is the usual norm on `\u2102` squared.\n* `Real.volume_real_smul`: `volume (x \u2022 s) = \u2016x\u2016\u208a * volume s` for all `x : \u211d` and `s : Set \u211d`.\n* `Complex.volume_complex_smul`: `volume (z \u2022 s) = \u2016z\u2016\u208a ^ 2 * volume s` for all `z : \u2102` and\n  `s : Set \u2102`.\n-/\n\nopen Real Complex MeasureTheory Measure Set\nopen scoped Pointwise\n\nlemma Real.volume_real_smul (x : \u211d) (s : Set \u211d) : volume (x \u2022 s) = \u2016x\u2016\u208a * volume s := by\n  simp [\u2190 enorm_eq_ofReal_abs, enorm_eq_nnnorm]\n\n/-- The distributive Haar character of the action of `\u211d\u02e3` on `\u211d` is the usual norm.\n\nThis means that `volume (x \u2022 s) = \u2016x\u2016 * volume s` for all `x : \u211d` and `s : Set \u211d`.\nSee `Real.volume_real_smul`. -/\nlemma distribHaarChar_real (x : \u211d\u02e3) : distribHaarChar \u211d x = \u2016(x : \u211d)\u2016\u208a :=\n  -- We compute that `volume (x \u2022 [0, 1]) = \u2016x\u2016\u208a * volume [0, 1]`.\n  distribHaarChar_eq_of_measure_smul_eq_mul (s := Icc 0 1) (\u03bc := volume)\n    (measure_pos_of_nonempty_interior _ <| by simp).ne' isCompact_Icc.measure_ne_top\n      (Real.volume_real_smul ..)\n\n", "theoremStatement": "/-- The distributive Haar character of the action of `\u2102\u02e3` on `\u2102` is the usual norm squared.\n\nThis means that `volume (z \u2022 s) = \u2016z\u2016 ^ 2 * volume s` for all `z : \u2102` and `s : Set \u2102`.\nSee `Complex.volume_complex_smul`. -/\nlemma distribHaarChar_complex (z : \u2102\u02e3) : distribHaarChar \u2102 z = \u2016(z : \u2102)\u2016\u208a ^ 2 ", "theoremName": "distribHaarChar_complex", "fileCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "theoremCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "file": "FLT/FLT/HaarMeasure/DistribHaarChar/RealComplex.lean", "module": "FLT.HaarMeasure.DistribHaarChar.RealComplex", "jsonFile": "FLT.HaarMeasure.DistribHaarChar.RealComplex.jsonl", "positionMetadata": {"lineInFile": 46, "tokenPositionInFile": 1896, "theoremPositionInFile": 2}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 386}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  -- We compute that `volume (x \u2022 ([0, 1] \u00d7 [0, 1])) = \u2016x\u2016\u208a ^ 2 * volume ([0, 1] \u00d7 [0, 1])`.\n  refine distribHaarChar_eq_of_measure_smul_eq_mul (s := Icc 0 1 \u00d7\u2102 Icc 0 1) (\u03bc := volume)\n    (measure_pos_of_nonempty_interior _ <| by simp [interior_reProdIm]).ne'\n    (isCompact_Icc.reProdIm isCompact_Icc).measure_ne_top ?_\n  -- The determinant of left multiplication by `z\u207b\u00b9` as a `\u211d`-linear map is `\u2016z\u2016\u208a ^ (-2)`.\n  have key : ((LinearMap.mul \u2102 \u2102 z\u207b\u00b9).restrictScalars \u211d).det = \u2016z.val\u2016\u208a ^ (-2 : \u2124) := by\n    refine Complex.ofReal_injective ?_\n    rw [LinearMap.det_restrictScalars]\n    simp [Algebra.norm_complex_apply, normSq_eq_norm_sq, zpow_ofNat]\n  -- Massaging, we find the result.\n  convert addHaar_preimage_linearMap (E := \u2102) volume\n    (f := (LinearMap.mul \u2102 \u2102 z\u207b\u00b9).restrictScalars \u211d) _ _ using 2\n  \u00b7 simpa [LinearMap.mul, LinearMap.mk\u2082, LinearMap.mk\u2082', LinearMap.mk\u2082'\u209b\u2097, Units.smul_def, eq_comm]\n      using preimage_smul_inv z (Icc 0 1 \u00d7\u2102 Icc 0 1)\n  \u00b7 simp [key, ofReal_norm_eq_enorm, \u2190 Complex.norm_eq_abs, ENNReal.ofReal_pow, zpow_ofNat]; rfl\n  \u00b7 simp [key, zpow_ofNat]", "proofType": "tactic", "proofLengthLines": 16, "proofLengthTokens": 1084}}
{"srcContext": "import Mathlib -- because there are sorries in this file\nimport FLT.Mathlib.Algebra.Order.Hom.Monoid\nimport FLT.Mathlib.Algebra.Algebra.Hom\nimport FLT.Mathlib.Algebra.Algebra.Pi\nimport FLT.Mathlib.Algebra.Algebra.Bilinear\nimport FLT.Mathlib.Topology.Algebra.UniformRing\n\n\n/-!\n\n# Base change of adele rings.\n\nIf `A` is a Dedekind domain with field of fractions `K`, if `L/K` is a finite separable\nextension and if `B` is the integral closure of `A` in `L`, then `B` is also a Dedekind\ndomain. Hence the rings of finite adeles `\ud835\udd38_K^\u221e` and `\ud835\udd38_L^\u221e` (defined using `A` and `B`)\nare defined. In this file we define the natural `K`-algebra map `\ud835\udd38_K^\u221e \u2192 \ud835\udd38_L^\u221e` and\nthe natural `L`-algebra map `\ud835\udd38_K^\u221e \u2297[K] L \u2192 \ud835\udd38_L^\u221e`, and show that the latter map\nis an isomorphism.\n\n## Main definition\n\n* `FiniteAdeleRing.baseChangeEquiv : L \u2297[K] FiniteAdeleRing A K \u2243\u2090[L] FiniteAdeleRing B L`\n\n-/\n\nopen scoped Multiplicative\n\n-- The general set-up.\n\nvariable (A K L B : Type*) [CommRing A] [CommRing B] [Algebra A B] [Field K] [Field L]\n    [Algebra A K] [IsFractionRing A K] [Algebra B L] [IsDedekindDomain A]\n    [Algebra K L] [Algebra A L] [IsScalarTower A B L] [IsScalarTower A K L]\n    [IsIntegralClosure B A L] [FiniteDimensional K L]\n\nvariable [Algebra.IsSeparable K L]\n\nexample : Function.Injective (algebraMap B L) := IsIntegralClosure.algebraMap_injective' A\n\nexample : IsDomain B := by\n  have foo : Function.Injective (algebraMap B L) := IsIntegralClosure.algebraMap_injective' A\n  have bar : IsDomain L := inferInstance\n  exact Function.Injective.isDomain _ foo -- exact? failed\nvariable [IsDomain B]\n\nexample : Algebra.IsIntegral A B := IsIntegralClosure.isIntegral_algebra A L\nvariable [Algebra.IsIntegral A B]\n\nexample : Module.Finite A B :=\n  have := IsIntegralClosure.isNoetherian A K L B\n  Module.IsNoetherian.finite A B\nvariable [Module.Finite A B]\n\nexample : IsDedekindDomain B := IsIntegralClosure.isDedekindDomain A K L B\nvariable [IsDedekindDomain B]\n\nexample : IsFractionRing B L := IsIntegralClosure.isFractionRing_of_finite_extension A K L B\nvariable [IsFractionRing B L]\n\n-- We start by filling in some holes in the API for finite extensions of Dedekind domains.\nnamespace IsDedekindDomain\n\nnamespace HeightOneSpectrum\n\n-- first need a way to pull back valuations on B to A\nvariable {B L} in\ndef comap (w : HeightOneSpectrum B) : HeightOneSpectrum A where\n  asIdeal := w.asIdeal.comap (algebraMap A B)\n  isPrime := Ideal.comap_isPrime (algebraMap A B) w.asIdeal\n  ne_bot := mt Ideal.eq_bot_of_comap_eq_bot w.ne_bot\n\nomit [Module.Finite A B] in\nlemma mk_count_factors_map\n    (hAB : Function.Injective (algebraMap A B))\n    (w : HeightOneSpectrum B) (I : Ideal A) [DecidableEq (Associates (Ideal A))]\n  [DecidableEq (Associates (Ideal B))] [\u2200 p : Associates (Ideal A), Decidable (Irreducible p)]\n  [\u2200 p : Associates (Ideal B), Decidable (Irreducible p)] :\n    (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) I)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk I).factors := by\n  classical\n  induction I using UniqueFactorizationMonoid.induction_on_prime with\n  | h\u2081 =>\n    rw [Associates.mk_zero, Ideal.zero_eq_bot, Ideal.map_bot, \u2190 Ideal.zero_eq_bot,\n      Associates.mk_zero]\n    simp [Associates.count, Associates.factors_zero, w.associates_irreducible,\n      associates_irreducible (comap A w), Associates.bcount]\n  | h\u2082 I hI =>\n    obtain rfl : I = \u22a4 := by simpa using hI\n    simp only [Submodule.zero_eq_bot, ne_eq, top_ne_bot, not_false_eq_true, Ideal.map_top]\n    simp only [\u2190 Ideal.one_eq_top, Associates.mk_one, Associates.factors_one]\n    rw [Associates.count_zero (associates_irreducible _),\n      Associates.count_zero (associates_irreducible _), mul_zero]\n  | h\u2083 I p hI hp IH =>\n    simp only [Ideal.map_mul, \u2190 Associates.mk_mul_mk]\n    have hp_bot : p \u2260 \u22a5 := hp.ne_zero\n    have hp_bot' := (Ideal.map_eq_bot_iff_of_injective hAB).not.mpr hp_bot\n    have hI_bot := (Ideal.map_eq_bot_iff_of_injective hAB).not.mpr hI\n    rw [Associates.count_mul (Associates.mk_ne_zero.mpr hp_bot) (Associates.mk_ne_zero.mpr hI)\n      (associates_irreducible _), Associates.count_mul (Associates.mk_ne_zero.mpr hp_bot')\n      (Associates.mk_ne_zero.mpr hI_bot) (associates_irreducible _)]\n    simp only [IH, mul_add]\n    congr 1\n    by_cases hw : (w.comap A).asIdeal = p\n    \u00b7 have : Irreducible (Associates.mk p) := Associates.irreducible_mk.mpr hp.irreducible\n      rw [hw, Associates.factors_self this, Associates.count_some this]\n      simp only [UniqueFactorizationMonoid.factors_eq_normalizedFactors, Multiset.nodup_singleton,\n        Multiset.mem_singleton, Multiset.count_eq_one_of_mem, mul_one]\n      rw [count_associates_factors_eq hp_bot' w.2 w.3,\n        Ideal.IsDedekindDomain.ramificationIdx_eq_normalizedFactors_count hp_bot' w.2 w.3]\n    \u00b7 have : (Associates.mk (comap A w).asIdeal).count (Associates.mk p).factors = 0 :=\n        Associates.count_eq_zero_of_ne (associates_irreducible _)\n          (Associates.irreducible_mk.mpr hp.irreducible)\n          (by rwa [ne_eq, Associates.mk_eq_mk_iff_associated, associated_iff_eq])\n      rw [this, mul_zero, eq_comm]\n      by_contra H\n      rw [eq_comm, \u2190 ne_eq, Associates.count_ne_zero_iff_dvd hp_bot' (irreducible w),\n        Ideal.dvd_iff_le, Ideal.map_le_iff_le_comap] at H\n      apply hw (((Ideal.isPrime_of_prime hp).isMaximal hp_bot).eq_of_le (comap A w).2.ne_top H).symm\n\nomit [Module.Finite A B] in\nlemma intValuation_comap (hAB : Function.Injective (algebraMap A B))\n    (w : HeightOneSpectrum B) (x : A) :\n    (comap A w).intValuation x ^\n    (Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal) =\n    w.intValuation (algebraMap A B x) := by\n  classical\n  have h_ne_zero : Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal \u2260 0 :=\n    Ideal.IsDedekindDomain.ramificationIdx_ne_zero\n      ((Ideal.map_eq_bot_iff_of_injective hAB).not.mpr (comap A w).3) w.2 Ideal.map_comap_le\n  by_cases hx : x = 0\n  \u00b7 simpa [hx]\n  simp only [intValuation, Valuation.coe_mk, MonoidWithZeroHom.coe_mk, ZeroHom.coe_mk]\n  show (ite _ _ _) ^ _ = ite _ _ _\n  by_cases hx : x = 0\n  \u00b7 subst hx; simp [h_ne_zero]\n  rw [map_eq_zero_iff _ hAB, if_neg hx, if_neg hx, \u2190 Set.image_singleton, \u2190 Ideal.map_span,\n    mk_count_factors_map _ _ hAB, mul_comm]\n  simp\n\n-- Need to know how the valuation `w` and its pullback are related on elements of `K`.\nomit [IsIntegralClosure B A L] [FiniteDimensional K L] [Algebra.IsSeparable K L]\n    [Module.Finite A B] in\nlemma valuation_comap (w : HeightOneSpectrum B) (x : K) :\n    (comap A w).valuation x ^\n    (Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal) =\n    w.valuation (algebraMap K L x) := by\n  obtain \u27e8x, y, hy, rfl\u27e9 := IsFractionRing.div_surjective (A := A) x\n  simp [valuation, \u2190 IsScalarTower.algebraMap_apply A K L, IsScalarTower.algebraMap_apply A B L,\n    \u2190 intValuation_comap A B (algebraMap_injective_of_field_isFractionRing A B K L), div_pow]\n\nomit [IsIntegralClosure B A L] [FiniteDimensional K L] [Algebra.IsSeparable K L]\n    [Module.Finite A B] in\nlemma _root_.IsDedekindDomain.HeightOneSpectrum.adicValued.continuous_algebraMap\n    (v : HeightOneSpectrum A) (w : HeightOneSpectrum B) (hvw : v = comap A w) :\n    letI : UniformSpace K := v.adicValued.toUniformSpace;\n    letI : UniformSpace L := w.adicValued.toUniformSpace;\n    Continuous (algebraMap K L) := by\n  letI : UniformSpace K := v.adicValued.toUniformSpace;\n  letI : UniformSpace L := w.adicValued.toUniformSpace;\n  subst hvw\n  refine continuous_of_continuousAt_zero (algebraMap K L) ?hf\n  delta ContinuousAt\n  simp only [map_zero]\n  rw [(@Valued.hasBasis_nhds_zero K _ _ _ (comap A w).adicValued).tendsto_iff\n    (@Valued.hasBasis_nhds_zero L _ _ _ w.adicValued)]\n  simp only [HeightOneSpectrum.adicValued_apply, Set.mem_setOf_eq, true_and, true_implies]\n  rw [WithZero.unitsWithZeroEquiv.forall_congr_left, Multiplicative.forall]\n  intro a\n  rw [WithZero.unitsWithZeroEquiv.exists_congr_left, Multiplicative.exists]\n  let m := Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal\n  let e : \u2124 \u2243 \u2124\u2098\u2080\u02e3 := Multiplicative.ofAdd.trans OrderMonoidIso.unitsWithZero.symm.toEquiv\n  have e_apply (a : \u2124) : e a = OrderMonoidIso.unitsWithZero.symm (Multiplicative.ofAdd a) := rfl\n  have hm : m \u2260 0 := by\n    refine Ideal.IsDedekindDomain.ramificationIdx_ne_zero ?_ w.2 Ideal.map_comap_le\n    exact (Ideal.map_eq_bot_iff_of_injective\n      (algebraMap_injective_of_field_isFractionRing A B K L)).not.mpr (comap A w).3\n  refine \u27e8a / m, fun x hx \u21a6 ?_\u27e9\n  simp_rw [\u2190 valuation_comap A]\n  calc\n    (comap A w).valuation x ^ m < e (a / \u2191m) ^ m := by gcongr; exacts [zero_le', hx]\n  _ = e (m \u2022 (a / \u2191m)) := by\n    dsimp [e]\n    norm_cast\n    rw [map_pow]\n  _ \u2264 e a := by\n    simp only [nsmul_eq_mul, e_apply, Units.val_le_val, OrderIsoClass.map_le_map_iff]\n    rw [mul_comm]\n    exact Int.mul_le_of_le_ediv (by positivity) le_rfl\n\nnoncomputable def adicCompletionComapSemialgHom (v : HeightOneSpectrum A) (w : HeightOneSpectrum B)\n    (hvw : v = comap A w) :\n    (HeightOneSpectrum.adicCompletion K v) \u2192\u209b\u2090[algebraMap K L]\n      (HeightOneSpectrum.adicCompletion L w) :=\n  letI : UniformSpace K := v.adicValued.toUniformSpace;\n  letI : UniformSpace L := w.adicValued.toUniformSpace;\n  UniformSpace.Completion.mapSemialgHom _ <|\n  IsDedekindDomain.HeightOneSpectrum.adicValued.continuous_algebraMap A K L B v w hvw\n\n-- Do we even need to prove that this map is continuous? It will follow from\n-- the fact that it's K_v-linear once we know L_w has the K_v-module topology,\n-- which is the next lemma.\n-- omit [IsIntegralClosure B A L] [FiniteDimensional K L] [Algebra.IsSeparable K L]\n--     [Module.Finite A B] in\n-- lemma adicCompletionComapSemialgHom_continuous\n--     (v : HeightOneSpectrum A) (w : HeightOneSpectrum B) (hvw : v = comap A w) :\n--     Continuous (adicCompletionComapSemialgHom A K L B v w hvw) := by\n--   convert UniformSpace.Completion.continuous_extension (\u03b2 := (adicCompletion L w))\n\n\nlemma adicCompletionComap_isModuleTopology\n    (v : HeightOneSpectrum A) (w : HeightOneSpectrum B) (hvw : v = comap A w) :\n    -- temporarily make L_w a K_v-algebra\n    let inst_alg : Algebra (HeightOneSpectrum.adicCompletion K v)\n      (HeightOneSpectrum.adicCompletion L w) := RingHom.toAlgebra <|\n        adicCompletionComapSemialgHom A K L B v w hvw\n    -- the claim that L_w has the module topology.\n    IsModuleTopology (HeightOneSpectrum.adicCompletion K v)\n      (HeightOneSpectrum.adicCompletion L w) := by\n  sorry -- FLT#326\n\nomit [IsIntegralClosure B A L] [FiniteDimensional K L] [Algebra.IsSeparable K L]\n    [Module.Finite A B] in\nlemma adicCompletionComapSemialgHom_coe\n    (v : HeightOneSpectrum A) (w : HeightOneSpectrum B) (hvw : v = comap A w) (x : K) :\n    adicCompletionComapSemialgHom A K L B v w hvw x = algebraMap K L x :=\n  (adicCompletionComapSemialgHom A K L B v w hvw).commutes x\n\nomit [IsIntegralClosure B A L] [FiniteDimensional K L] [Algebra.IsSeparable K L]\n    [Module.Finite A B] in\nopen WithZeroTopology in\nlemma v_adicCompletionComapSemialgHom\n  (v : HeightOneSpectrum A) (w : HeightOneSpectrum B) (hvw : v = comap A w) (x) :\n    Valued.v (adicCompletionComapSemialgHom A K L B v w hvw x) = Valued.v x ^\n      Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal := by\n  revert x\n  apply funext_iff.mp\n  symm\n  letI : UniformSpace K := v.adicValued.toUniformSpace\n  letI : UniformSpace L := w.adicValued.toUniformSpace\n  apply UniformSpace.Completion.ext\n  \u00b7 exact Valued.continuous_valuation.pow _\n  \u00b7 exact Valued.continuous_valuation.comp UniformSpace.Completion.continuous_extension\n  intro a\n  simp_rw [adicCompletionComapSemialgHom_coe, adicCompletion, Valued.valuedCompletion_apply,\n    adicValued_apply]\n  subst hvw\n  rw [\u2190 valuation_comap A K L B w a]\n\n/-- The canonical map `K_v \u2192 \u220f_{w|v} L_w` extending K \u2192 L. -/\nnoncomputable def adicCompletionComapSemialgHom' (v : HeightOneSpectrum A) :\n  (HeightOneSpectrum.adicCompletion K v) \u2192\u209b\u2090[algebraMap K L]\n    (\u2200 w : {w : HeightOneSpectrum B // v = comap A w}, HeightOneSpectrum.adicCompletion L w.1) :=\n  Pi.semialgHom _ _ fun i \u21a6 adicCompletionComapSemialgHom A K L B v i.1 i.2\n\nlemma prodAdicCompletionComap_isModuleTopology\n    (v : HeightOneSpectrum A) (w : HeightOneSpectrum B) (hvw : v = comap A w) :\n    -- temporarily make \u220f_w L_w a K_v-algebra\n    let inst_alg : Algebra (HeightOneSpectrum.adicCompletion K v)\n      (\u2200 w : {w : HeightOneSpectrum B // v = comap A w}, HeightOneSpectrum.adicCompletion L w.1) :=\n      RingHom.toAlgebra <|\n        Pi.ringHom (fun w : {w : HeightOneSpectrum B // v = comap A w} \u21a6 adicCompletionComapSemialgHom A K L B v w.1 w.2)\n    -- the claim that L_w has the module topology.\n    IsModuleTopology (HeightOneSpectrum.adicCompletion K v)\n      (\u2200 w : {w : HeightOneSpectrum B // v = comap A w}, HeightOneSpectrum.adicCompletion L w.1) := by\n  sorry -- FLT#327\n\nopen scoped TensorProduct -- \u2297 notation for tensor product\n\n/-- The canonical L-algebra map `L \u2297_K K_v \u2192 \u220f_{w|v} L_w`. -/\nnoncomputable def tensorAdicCompletionComapAlgHom (v : HeightOneSpectrum A) :\n    L \u2297[K] adicCompletion K v \u2192\u2090[L]\n      \u03a0 w : {w : HeightOneSpectrum B // v = comap A w}, adicCompletion L w.1 :=\n  SemialgHom.baseChange_of_algebraMap (adicCompletionComapSemialgHom' A K L B v)\n\nomit [IsIntegralClosure B A L] [FiniteDimensional K L] [Algebra.IsSeparable K L]\n    [Module.Finite A B] in\nlemma tensorAdicCompletionComapAlgHom_tmul_apply (v : HeightOneSpectrum A) (x y i) :\n  tensorAdicCompletionComapAlgHom A K L B v (x \u2297\u209c y) i =\n    x \u2022 adicCompletionComapSemialgHom A K L B v i.1 i.2 y := by\n  rw [Algebra.smul_def]\n  rfl\n\ntheorem tensorAdicCompletionComapAlgHom_bijective (v : HeightOneSpectrum A) :\n    Function.Bijective (tensorAdicCompletionComapAlgHom A K L B v) := by\n  sorry -- issue FLT#231\n\nnoncomputable def adicCompletionComapAlgEquiv (v : HeightOneSpectrum A) :\n  (L \u2297[K] (HeightOneSpectrum.adicCompletion K v)) \u2243\u2090[L]\n    (\u2200 w : {w : HeightOneSpectrum B // v = comap A w}, HeightOneSpectrum.adicCompletion L w.1) :=\n  AlgEquiv.ofBijective (tensorAdicCompletionComapAlgHom A K L B v) <|\n    tensorAdicCompletionComapAlgHom_bijective A K L B v\n\nattribute [local instance] Algebra.TensorProduct.rightAlgebra in\nvariable (v : HeightOneSpectrum A) in\ninstance : TopologicalSpace (L \u2297[K] adicCompletion K v) := moduleTopology (adicCompletion K v) _\n\nattribute [local instance] Algebra.TensorProduct.rightAlgebra in\nvariable (v : HeightOneSpectrum A) in\ninstance : IsModuleTopology (adicCompletion K v) (L \u2297[K] adicCompletion K v) :=\n  \u27e8rfl\u27e9\n\nnoncomputable def adicCompletionComapContinuousAlgEquiv (v : HeightOneSpectrum A) :\n  (L \u2297[K] (HeightOneSpectrum.adicCompletion K v)) \u2243A[L]\n    (\u2200 w : {w : HeightOneSpectrum B // v = comap A w}, HeightOneSpectrum.adicCompletion L w.1)\n  where\n    toAlgEquiv := adicCompletionComapAlgEquiv A K L B v\n    continuous_toFun := sorry -- FLT#328\n    continuous_invFun := sorry -- FLT#328\n\nattribute [local instance 9999] SMulCommClass.of_commMonoid TensorProduct.isScalarTower_left IsScalarTower.right\n\ninstance (R K : Type*) [CommRing R] [IsDedekindDomain R] [Field K]\n    [Algebra R K] [IsFractionRing R K] (v : HeightOneSpectrum R) :\n    IsScalarTower R (adicCompletionIntegers K v) (adicCompletion K v) :=\n  \u27e8fun x y z \u21a6 by exact smul_mul_assoc x y.1 z\u27e9\n\nnoncomputable\ndef adicCompletionIntegersSubalgebra {R : Type*} (K : Type*) [CommRing R]\n    [IsDedekindDomain R] [Field K] [Algebra R K] [IsFractionRing R K] (v : HeightOneSpectrum R) :\n    Subalgebra R (HeightOneSpectrum.adicCompletion K v) where\n  __ := HeightOneSpectrum.adicCompletionIntegers K v\n  algebraMap_mem' r := coe_mem_adicCompletionIntegers v r\n\n/-- The canonical map `B \u2297[A] A_v \u2192 L \u2297[K] K_v` -/\nnoncomputable def tensorAdicCompletionIntegersTo (v : HeightOneSpectrum A) :\n    B \u2297[A] adicCompletionIntegers K v \u2192\u2090[B] L \u2297[K] adicCompletion K v :=\n  Algebra.TensorProduct.lift\n    ((Algebra.TensorProduct.includeLeft).comp (Algebra.ofId B L))\n    ((Algebra.TensorProduct.includeRight.restrictScalars A).comp (IsScalarTower.toAlgHom _ _ _))\n    (fun _ _ \u21a6 .all _ _)\n\nomit [IsIntegralClosure B A L] [FiniteDimensional K L] [Algebra.IsSeparable K L]\n    [Module.Finite A B] in\nset_option linter.deprecated false in -- `map_zero` and `map_add` time-outs\n", "theoremStatement": "theorem range_adicCompletionComapAlgIso_tensorAdicCompletionIntegersTo_le_pi\n    (v : HeightOneSpectrum A) :\n    AlgHom.range (((tensorAdicCompletionComapAlgHom A K L B v).restrictScalars B).comp\n      (tensorAdicCompletionIntegersTo A K L B v)) \u2264\n      Subalgebra.pi Set.univ (fun _ \u21a6 adicCompletionIntegersSubalgebra _ _) ", "theoremName": "IsDedekindDomain.HeightOneSpectrum.range_adicCompletionComapAlgIso_tensorAdicCompletionIntegersTo_le_pi", "fileCreated": {"commit": "17ea847a3d0172f39eea0bc008cd70a2755df629", "date": "2024-11-01"}, "theoremCreated": {"commit": "36d6cb44925dd2dd96740ad37ac59abcee4714cd", "date": "2024-12-02"}, "file": "FLT/FLT/DedekindDomain/FiniteAdeleRing/BaseChange.lean", "module": "FLT.DedekindDomain.FiniteAdeleRing.BaseChange", "jsonFile": "FLT.DedekindDomain.FiniteAdeleRing.BaseChange.jsonl", "positionMetadata": {"lineInFile": 335, "tokenPositionInFile": 16345, "theoremPositionInFile": 15}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 7, "repositoryPremises": true, "numRepositoryPremises": 9, "numPremises": 284}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rintro _ \u27e8x, rfl\u27e9 i -\n  simp only [Subalgebra.coe_toSubmodule, AlgEquiv.toAlgHom_eq_coe, AlgHom.toRingHom_eq_coe,\n    RingHom.coe_coe, AlgHom.coe_comp, AlgHom.coe_restrictScalars', AlgHom.coe_coe,\n    Function.comp_apply, SetLike.mem_coe]\n  induction' x with x y x y hx hy\n  \u00b7 simp [map_zero, Pi.zero_apply, zero_mem]\n  \u00b7 simp only [tensorAdicCompletionIntegersTo, Algebra.TensorProduct.lift_tmul, AlgHom.coe_comp,\n      Function.comp_apply, Algebra.ofId_apply, AlgHom.commutes,\n      Algebra.TensorProduct.algebraMap_apply, AlgHom.coe_restrictScalars',\n      IsScalarTower.coe_toAlgHom', ValuationSubring.algebraMap_apply,\n      Algebra.TensorProduct.includeRight_apply, Algebra.TensorProduct.tmul_mul_tmul, mul_one, one_mul,\n      tensorAdicCompletionComapAlgHom_tmul_apply, algebraMap_smul]\n    apply Subalgebra.smul_mem\n    show _ \u2264 (1 : \u2124\u2098\u2080)\n    rw [v_adicCompletionComapSemialgHom A K (L := L) (B := B) v i.1 i.2 y.1,\n      \u2190 one_pow (Ideal.ramificationIdx (algebraMap A B) (comap A i.1).asIdeal i.1.asIdeal),\n      pow_le_pow_iff_left\u2080]\n    \u00b7 exact y.2\n    \u00b7 exact zero_le'\n    \u00b7 exact zero_le'\n    \u00b7 exact Ideal.IsDedekindDomain.ramificationIdx_ne_zero  ((Ideal.map_eq_bot_iff_of_injective\n        (algebraMap_injective_of_field_isFractionRing A B K L)).not.mpr\n        (comap A i.1).3) i.1.2 Ideal.map_comap_le\n  \u00b7 simp [map_add, Pi.add_apply, add_mem hx hy]", "proofType": "tactic", "proofLengthLines": 24, "proofLengthTokens": 1375}}
{"srcContext": "import Mathlib.Algebra.CharZero.Infinite\nimport Mathlib.NumberTheory.Padics.PadicIntegers\nimport FLT.Mathlib.GroupTheory.Index\n\n/-!\n# TODO\n\n* Rename `Coe.ringHom` to `coeRingHom`\n* Protect `PadicInt.norm_mul`, `PadicInt.norm_units`, `PadicInt.norm_pow`\n-/\n\nopen Function Topology Subgroup\nopen scoped NNReal nonZeroDivisors Pointwise\n\nvariable {p : \u2115} [Fact p.Prime]\n\nnamespace PadicInt\nvariable {x : \u2124_[p]}\n\nattribute [simp] coe_eq_zero\n\n@[simp, norm_cast] lemma coe_coeRingHom : \u21d1(Coe.ringHom (p := p)) = (\u2191) := rfl\n\nlemma coe_injective : Injective ((\u2191) : \u2124_[p] \u2192 \u211a_[p]) := Subtype.val_injective\n\n@[simp] lemma coe_inj {x y : \u2124_[p]} : (x : \u211a_[p]) = (y : \u211a_[p]) \u2194 x = y := coe_injective.eq_iff\n\ninstance : Infinite \u2124_[p] := CharZero.infinite _\n\n@[simp]\nprotected lemma nnnorm_mul (x y : \u2124_[p]) : \u2016x * y\u2016\u208a = \u2016x\u2016\u208a * \u2016y\u2016\u208a := by simp [nnnorm, NNReal]\n\n@[simp]\nprotected lemma nnnorm_pow (x : \u2124_[p]) (n : \u2115) : \u2016x ^ n\u2016\u208a = \u2016x\u2016\u208a ^ n := by simp [nnnorm, NNReal]\n\n@[simp] lemma nnnorm_p : \u2016(p : \u2124_[p])\u2016\u208a = (p : \u211d\u22650)\u207b\u00b9 := by simp [nnnorm]; rfl\n\n@[simp] protected lemma nnnorm_units (u : \u2124_[p]\u02e3) : \u2016(u : \u2124_[p])\u2016\u208a = 1 := by simp [nnnorm, NNReal]\n\nlemma exists_unit_mul_p_pow_eq (hx : x \u2260 0) : \u2203 (u : \u2124_[p]\u02e3) (n : \u2115), (u : \u2124_[p]) * p ^ n = x :=\n  \u27e8_, _, (unitCoeff_spec hx).symm\u27e9\n\nlemma isOpenEmbedding_coe : IsOpenEmbedding ((\u2191) : \u2124_[p] \u2192 \u211a_[p]) := by\n  refine (?_ : IsOpen {y : \u211a_[p] | \u2016y\u2016 \u2264 1}).isOpenEmbedding_subtypeVal\n  simpa only [Metric.closedBall, dist_eq_norm_sub, sub_zero] using\n    IsUltrametricDist.isOpen_closedBall (0 : \u211a_[p]) one_ne_zero\n\n", "theoremStatement": "@[simp] lemma image_coe_smul_set (x : \u2124_[p]) (s : Set \u2124_[p]) :\n    ((\u2191) '' (x \u2022 s) : Set \u211a_[p]) = x \u2022 (\u2191) '' s ", "theoremName": "PadicInt.image_coe_smul_set", "fileCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "theoremCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "file": "FLT/FLT/Mathlib/NumberTheory/Padics/PadicIntegers.lean", "module": "FLT.Mathlib.NumberTheory.Padics.PadicIntegers", "jsonFile": "FLT.Mathlib.NumberTheory.Padics.PadicIntegers.jsonl", "positionMetadata": {"lineInFile": 48, "tokenPositionInFile": 1544, "theoremPositionInFile": 9}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 32}, "proofMetadata": {"hasProof": true, "proof": ":= Set.image_comm fun _ \u21a6 rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 29}}
{"srcContext": "import Mathlib.Topology.Constructions\nimport Mathlib.Topology.ContinuousOn\n\ntheorem TopologicalSpace.prod_mono {\u03b1 \u03b2 : Type*} {\u03c3\u2081 \u03c3\u2082 : TopologicalSpace \u03b1}\n    {\u03c4\u2081 \u03c4\u2082 : TopologicalSpace \u03b2} (h\u03c3 : \u03c3\u2081 \u2264 \u03c3\u2082) (h\u03c4 : \u03c4\u2081 \u2264 \u03c4\u2082) :\n    @instTopologicalSpaceProd \u03b1 \u03b2 \u03c3\u2081 \u03c4\u2081 \u2264 @instTopologicalSpaceProd \u03b1 \u03b2 \u03c3\u2082 \u03c4\u2082 :=\n  le_inf (inf_le_left.trans  <| induced_mono h\u03c3)\n         (inf_le_right.trans  <| induced_mono h\u03c4)\n\n", "theoremStatement": "theorem DenseRange.piMap {\u03b9 : Type*} {X Y : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (Y i)]\n    {f : (i : \u03b9) \u2192 (X i) \u2192 (Y i)} (hf : \u2200 i, DenseRange (f i)):\n    DenseRange (Pi.map f) ", "theoremName": "DenseRange.piMap", "fileCreated": {"commit": "0624e5a452d5645b8a3766b4169a48010d2a725f", "date": "2024-12-10"}, "theoremCreated": {"commit": "127de0cf1cfe4388059ffe6945fd866e45792a99", "date": "2025-02-02"}, "file": "FLT/FLT/Mathlib/Topology/Constructions.lean", "module": "FLT.Mathlib.Topology.Constructions", "jsonFile": "FLT.Mathlib.Topology.Constructions.jsonl", "positionMetadata": {"lineInFile": 10, "tokenPositionInFile": 400, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 18}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [DenseRange, Set.range_piMap]\n  exact dense_pi Set.univ (fun i _ => hf i)", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 84}}
{"srcContext": "import Mathlib.RepresentationTheory.Basic\nimport FLT.Mathlib.LinearAlgebra.Span.Defs\n\nopen Pointwise\n\nuniverse u\n\nvariable {A : Type*} [CommRing A]\n\nvariable {G : Type*} [Group G]\n\nvariable {W : Type*} [AddCommMonoid W] [Module A W]\n\nvariable {\u03c1 : Representation A G W}\n\nvariable (\u03c1) in\nstructure Subrepresentation where\n  toSubmodule : Submodule A W\n  apply_mem_toSubmodule (g : G) \u2983v : W\u2984 : v \u2208 toSubmodule \u2192 \u03c1 g v \u2208 toSubmodule\n\nnamespace Subrepresentation\n\nlemma toSubmodule_injective : Function.Injective (toSubmodule : Subrepresentation \u03c1 \u2192 Submodule A W) := by\n  rintro \u27e8_,_\u27e9\n  congr!\n\ninstance : SetLike (Subrepresentation \u03c1) W where\n  coe \u03c1' := \u03c1'.toSubmodule\n  coe_injective' := SetLike.coe_injective.comp toSubmodule_injective\n\ndef toRepresentation (\u03c1' : Subrepresentation \u03c1): Representation A G \u03c1'.toSubmodule where\n  toFun g := (\u03c1 g).restrict (\u03c1'.apply_mem_toSubmodule g)\n  map_one' := by ext; simp\n  map_mul' x y := by ext; simp\n\ninstance : Max (Subrepresentation \u03c1) where\n  max \u03c1\u2081 \u03c1\u2082 := .mk (\u03c1\u2081.toSubmodule \u2294 \u03c1\u2082.toSubmodule) <| by\n      simp only [Submodule.forall_mem_sup, map_add]\n      intro g x\u2081 hx\u2081 x\u2082 hx\u2082\n      exact Submodule.mem_sup.mpr\n        \u27e8\u03c1 g x\u2081, \u03c1\u2081.apply_mem_toSubmodule g hx\u2081, \u03c1 g x\u2082, \u03c1\u2082.apply_mem_toSubmodule g hx\u2082, rfl\u27e9\n\ninstance : Min (Subrepresentation \u03c1) where\n  min \u03c1\u2081 \u03c1\u2082 := .mk (\u03c1\u2081.toSubmodule \u2293 \u03c1\u2082.toSubmodule) <| by\n      simp only [Submodule.mem_inf, and_imp]\n      rintro g x hx\u2081 hx\u2082\n      exact \u27e8\u03c1\u2081.apply_mem_toSubmodule g hx\u2081, \u03c1\u2082.apply_mem_toSubmodule g hx\u2082\u27e9\n\n\n@[simp, norm_cast]\nlemma coe_sup (\u03c1\u2081 \u03c1\u2082 : Subrepresentation \u03c1) : \u2191(\u03c1\u2081 \u2294 \u03c1\u2082) = (\u03c1\u2081 : Set W) + (\u03c1\u2082 : Set W) :=\n  Submodule.coe_sup \u03c1\u2081.toSubmodule \u03c1\u2082.toSubmodule\n\n@[simp, norm_cast]\nlemma coe_inf (\u03c1\u2081 \u03c1\u2082 : Subrepresentation \u03c1) : \u2191(\u03c1\u2081 \u2293 \u03c1\u2082) = (\u03c1\u2081 \u2229 \u03c1\u2082 : Set W) := rfl\n\n@[simp]\nlemma toSubmodule_sup (\u03c1\u2081 \u03c1\u2082 : Subrepresentation \u03c1) :\n  (\u03c1\u2081 \u2294 \u03c1\u2082).toSubmodule = \u03c1\u2081.toSubmodule \u2294 \u03c1\u2082.toSubmodule := rfl\n\n", "theoremStatement": "@[simp]\nlemma toSubmodule_inf (\u03c1\u2081 \u03c1\u2082 : Subrepresentation \u03c1) :\n  (\u03c1\u2081 \u2293 \u03c1\u2082).toSubmodule = \u03c1\u2081.toSubmodule \u2293 \u03c1\u2082.toSubmodule ", "theoremName": "Subrepresentation.toSubmodule_inf", "fileCreated": {"commit": "14bd4f65b4f45e7747da8e4c0d90d02a58dec086", "date": "2024-12-21"}, "theoremCreated": {"commit": "14bd4f65b4f45e7747da8e4c0d90d02a58dec086", "date": "2024-12-21"}, "file": "FLT/FLT/Deformations/RepresentationTheory/Subrepresentation.lean", "module": "FLT.Deformations.RepresentationTheory.Subrepresentation", "jsonFile": "FLT.Deformations.RepresentationTheory.Subrepresentation.jsonl", "positionMetadata": {"lineInFile": 61, "tokenPositionInFile": 1898, "theoremPositionInFile": 4}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 3, "numPremises": 17}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "/-\nCopyright (c) 2024 Ya\u00ebl Dillies, David Loeffler. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Ya\u00ebl Dillies, David Loeffler\n-/\nimport Mathlib.MeasureTheory.Measure.Haar.Basic\nimport Mathlib.NumberTheory.Padics.ProperSpace\nimport FLT.Mathlib.NumberTheory.Padics.PadicIntegers\n\n/-!\n# Measurability and measures on the p-adics\n\nThis file endows `\u2124_[p]` and `\u211a_[p]` with their Borel sigma-algebra and their Haar measure that\nmakes `\u2124_[p]` (or the copy of `\u2124_[p]` inside `\u211a_[p]`) have norm `1`.\n-/\n\nopen MeasureTheory Measure TopologicalSpace Topology\n\nvariable {p : \u2115} [Fact p.Prime]\n\nnamespace Padic\n\ninstance instMeasurableSpace : MeasurableSpace \u211a_[p] := borel _\ninstance instBorelSpace : BorelSpace \u211a_[p] := \u27e8rfl\u27e9\n\n-- Should we more generally make a map from `CompactOpens` to `PositiveCompacts`?\nprivate def unitBall_positiveCompact : PositiveCompacts \u211a_[p] where\n  carrier := {y | \u2016y\u2016 \u2264 1}\n  isCompact' := by simpa only [Metric.closedBall, dist_zero_right] using\n    isCompact_closedBall (0 : \u211a_[p]) 1\n  interior_nonempty' := by\n    rw [IsOpen.interior_eq]\n    \u00b7 exact \u27e80, by simp\u27e9\n    \u00b7 simpa only [Metric.closedBall, dist_zero_right] using\n        IsUltrametricDist.isOpen_closedBall (0 : \u211a_[p]) one_ne_zero\n\nnoncomputable instance instMeasureSpace : MeasureSpace \u211a_[p] :=\n  \u27e8addHaarMeasure unitBall_positiveCompact\u27e9\n\ninstance instIsAddHaarMeasure : IsAddHaarMeasure (volume : Measure \u211a_[p]) :=\n  isAddHaarMeasure_addHaarMeasure _\n\nlemma volume_closedBall_one : volume {x : \u211a_[p] | \u2016x\u2016 \u2264 1} = 1 := addHaarMeasure_self\n\nend Padic\n\nnamespace PadicInt\n\ninstance instMeasurableSpace : MeasurableSpace \u2124_[p] := Subtype.instMeasurableSpace\ninstance instBorelSpace : BorelSpace \u2124_[p] := Subtype.borelSpace _\n\n", "theoremStatement": "lemma isMeasurableEmbedding_coe : MeasurableEmbedding ((\u2191) : \u2124_[p] \u2192 \u211a_[p]) ", "theoremName": "PadicInt.isMeasurableEmbedding_coe", "fileCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "theoremCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "file": "FLT/FLT/HaarMeasure/MeasurableSpacePadics.lean", "module": "FLT.HaarMeasure.MeasurableSpacePadics", "jsonFile": "FLT.HaarMeasure.MeasurableSpacePadics.jsonl", "positionMetadata": {"lineInFile": 52, "tokenPositionInFile": 1761, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 5, "numPremises": 36}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  convert isOpenEmbedding_coe.measurableEmbedding\n  exact inferInstanceAs (BorelSpace \u2124_[p])", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 98}}
{"srcContext": "import Mathlib.Algebra.CharZero.Infinite\nimport Mathlib.NumberTheory.Padics.PadicIntegers\nimport FLT.Mathlib.GroupTheory.Index\n\n/-!\n# TODO\n\n* Rename `Coe.ringHom` to `coeRingHom`\n* Protect `PadicInt.norm_mul`, `PadicInt.norm_units`, `PadicInt.norm_pow`\n-/\n\nopen Function Topology Subgroup\nopen scoped NNReal nonZeroDivisors Pointwise\n\nvariable {p : \u2115} [Fact p.Prime]\n\nnamespace PadicInt\nvariable {x : \u2124_[p]}\n\nattribute [simp] coe_eq_zero\n\n@[simp, norm_cast] lemma coe_coeRingHom : \u21d1(Coe.ringHom (p := p)) = (\u2191) := rfl\n\nlemma coe_injective : Injective ((\u2191) : \u2124_[p] \u2192 \u211a_[p]) := Subtype.val_injective\n\n@[simp] lemma coe_inj {x y : \u2124_[p]} : (x : \u211a_[p]) = (y : \u211a_[p]) \u2194 x = y := coe_injective.eq_iff\n\ninstance : Infinite \u2124_[p] := CharZero.infinite _\n\n@[simp]\nprotected lemma nnnorm_mul (x y : \u2124_[p]) : \u2016x * y\u2016\u208a = \u2016x\u2016\u208a * \u2016y\u2016\u208a := by simp [nnnorm, NNReal]\n\n@[simp]\nprotected lemma nnnorm_pow (x : \u2124_[p]) (n : \u2115) : \u2016x ^ n\u2016\u208a = \u2016x\u2016\u208a ^ n := by simp [nnnorm, NNReal]\n\n", "theoremStatement": "@[simp] lemma nnnorm_p : \u2016(p : \u2124_[p])\u2016\u208a = (p : \u211d\u22650)\u207b\u00b9 ", "theoremName": "PadicInt.nnnorm_p", "fileCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "theoremCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "file": "FLT/FLT/Mathlib/NumberTheory/Padics/PadicIntegers.lean", "module": "FLT.Mathlib.NumberTheory.Padics.PadicIntegers", "jsonFile": "FLT.Mathlib.NumberTheory.Padics.PadicIntegers.jsonl", "positionMetadata": {"lineInFile": 36, "tokenPositionInFile": 955, "theoremPositionInFile": 5}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 53}, "proofMetadata": {"hasProof": true, "proof": ":= by simp [nnnorm]; rfl", "proofType": "tactic", "proofLengthLines": 0, "proofLengthTokens": 24}}
{"srcContext": "import Mathlib.Algebra.Algebra.Hom\n\nsection semialghom\n\n/-- Let `\u03c6 : R \u2192+* S` be a ring homomorphism, let `A` be an `R`-algebra and let `B` be\nan `S`-algebra. Then `SemialgHom \u03c6 A B` or `A \u2192\u209b\u2090[\u03c6] B` is the ring homomorphisms `\u03c8 : A \u2192+* B`\nmaking lying above `\u03c6` (i.e. such that `\u03c8 (r \u2022 a) = \u03c6 r \u2022 \u03c8 a`).\n-/\nstructure SemialgHom {R S : Type*} [CommSemiring R] [CommSemiring S] (\u03c6 : R \u2192+* S)\n    (A B : Type*)  [Semiring A] [Semiring B] [Algebra R A] [Algebra S B]\n    extends A \u2192\u209b\u2097[\u03c6] B, RingHom A B\n\n@[inherit_doc SemialgHom]\ninfixr:25 \" \u2192\u209b\u2090 \" => SemialgHom _\n\n@[inherit_doc]\nnotation:25 A \" \u2192\u209b\u2090[\" \u03c6:25 \"] \" B:0 => SemialgHom \u03c6 A B\n\nvariable {R S : Type*} [CommSemiring R] [CommSemiring S] (\u03c6 : R \u2192+* S)\n    (A B : Type*)  [Semiring A] [Semiring B] [Algebra R A] [Algebra S B]\n\ninstance instFunLike : FunLike (A \u2192\u209b\u2090[\u03c6] B) A B where\n  coe f := f.toFun\n  coe_injective' f g h := by\n    cases f\n    cases g\n    congr\n    exact DFunLike.coe_injective' h\n\nvariable {\u03c6} {A} {B} in\nlemma SemialgHom.map_smul (\u03c8 : A \u2192\u209b\u2090[\u03c6] B) (m : R) (x : A) : \u03c8 (m \u2022 x) = \u03c6 m \u2022 \u03c8 x :=\n  LinearMap.map_smul' \u03c8.toLinearMap m x\n\nend semialghom\n\nsection semialghomclass\n\nclass SemialgHomClass (F : Type*) {R S : outParam Type*}\n  [CommSemiring R] [CommSemiring S] (\u03c6 : outParam (R \u2192+* S)) (A B : outParam Type*)\n  [Semiring A] [Semiring B] [Algebra R A] [Algebra S B]\n  [FunLike F A B] extends SemilinearMapClass F \u03c6 A B, RingHomClass F A B\n\nvariable (F : Type*) {R S : Type*}\n  [CommSemiring R] [CommSemiring S] (\u03c6 : R \u2192+* S) (A B : outParam Type*)\n  [Semiring A] [Semiring B] [Algebra R A] [Algebra S B]\n  [FunLike F A B] [SemialgHomClass F \u03c6 A B]\n\ninstance SemialgHomClass.instSemialgHom : SemialgHomClass (A \u2192\u209b\u2090[\u03c6] B) \u03c6 A B where\n  map_add \u03c8 := \u03c8.map_add\n  map_smul\u209b\u2097 \u03c8 := \u03c8.map_smul\u209b\u2097\n  map_mul \u03c8 := \u03c8.map_mul\n  map_one \u03c8 := \u03c8.map_one\n  map_zero \u03c8 := \u03c8.map_zero\n\nend semialghomclass\n\nsection semialghom\n\nvariable {R S : Type*} [CommSemiring R] [CommSemiring S] {\u03c6 : R \u2192+* S}\n    {A B : Type*}  [Semiring A] [Semiring B] [Algebra R A] [Algebra S B]\n\nlemma SemialgHom.commutes (\u03c8 : A \u2192\u209b\u2090[\u03c6] B) (r : R) :\n    \u03c8 (algebraMap R A r) = algebraMap S B (\u03c6 r) := by\n  have := \u03c8.map_smul r 1\n  rw [Algebra.smul_def, mul_one, map_one] at this\n  rw [this, Algebra.smul_def, mul_one]\n\n", "theoremStatement": "theorem SemialgHom.toLinearMap_eq_coe (f : A \u2192\u209b\u2090[\u03c6] B) : f.toLinearMap = f ", "theoremName": "SemialgHom.toLinearMap_eq_coe", "fileCreated": {"commit": "f463c53242f2ad3f5bdbee5b2078741ebf425207", "date": "2025-01-31"}, "theoremCreated": {"commit": "127241373eb7d4afd5ff86dc0e5082497c364f08", "date": "2025-02-05"}, "file": "FLT/FLT/Mathlib/Algebra/Algebra/Hom.lean", "module": "FLT.Mathlib.Algebra.Algebra.Hom", "jsonFile": "FLT.Mathlib.Algebra.Algebra.Hom.jsonl", "positionMetadata": {"lineInFile": 68, "tokenPositionInFile": 2248, "theoremPositionInFile": 4}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 5, "repositoryPremises": true, "numRepositoryPremises": 5, "numPremises": 18}, "proofMetadata": {"hasProof": true, "proof": ":=\n  rfl", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 8}}
{"srcContext": "/-\nCopyright (c) 2024 Andrew Yang, Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang, Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras\n-/\nimport Mathlib.MeasureTheory.Measure.Haar.Unique\n\nopen scoped NNReal Pointwise ENNReal\n\nnamespace MeasureTheory.Measure\n\nvariable {G A : Type*} [Group G] [AddCommGroup A] [DistribMulAction G A]\n  [MeasurableSpace A]\n  -- We only need `MeasurableConstSMul G A` but we don't have this class. So we erroneously must\n  -- assume `MeasurableSpace G` + `MeasurableSMul G A`\n  [MeasurableSpace G] [MeasurableSMul G A]\nvariable {\u03bc \u03bd : Measure A} {g : G}\n\n", "theoremStatement": "lemma domSMul_apply (\u03bc : Measure A) (g : G\u1d48\u1d50\u1d43) (s : Set A) :\n    (g \u2022 \u03bc) s = \u03bc ((DomMulAct.mk.symm g) \u2022 s) ", "theoremName": "MeasureTheory.Measure.domSMul_apply", "fileCreated": {"commit": "0624e5a452d5645b8a3766b4169a48010d2a725f", "date": "2024-12-10"}, "theoremCreated": {"commit": "2d142bb6c8fc86583ce6bb6bafe467552298e27e", "date": "2025-01-23"}, "file": "FLT/FLT/HaarMeasure/DomMulActMeasure.lean", "module": "FLT.HaarMeasure.DomMulActMeasure", "jsonFile": "FLT.HaarMeasure.DomMulActMeasure.jsonl", "positionMetadata": {"lineInFile": 19, "tokenPositionInFile": 671, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 56}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  refine ((MeasurableEquiv.smul ((DomMulAct.mk.symm g : G)\u207b\u00b9)).map_apply _).trans ?_\n  congr 1\n  exact Set.preimage_smul_inv (DomMulAct.mk.symm g) s", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 154}}
{"srcContext": "import Mathlib.Algebra.CharZero.Infinite\nimport Mathlib.NumberTheory.Padics.PadicIntegers\nimport FLT.Mathlib.GroupTheory.Index\n\n/-!\n# TODO\n\n* Rename `Coe.ringHom` to `coeRingHom`\n* Protect `PadicInt.norm_mul`, `PadicInt.norm_units`, `PadicInt.norm_pow`\n-/\n\nopen Function Topology Subgroup\nopen scoped NNReal nonZeroDivisors Pointwise\n\nvariable {p : \u2115} [Fact p.Prime]\n\nnamespace PadicInt\nvariable {x : \u2124_[p]}\n\nattribute [simp] coe_eq_zero\n\n@[simp, norm_cast] lemma coe_coeRingHom : \u21d1(Coe.ringHom (p := p)) = (\u2191) := rfl\n\nlemma coe_injective : Injective ((\u2191) : \u2124_[p] \u2192 \u211a_[p]) := Subtype.val_injective\n\n@[simp] lemma coe_inj {x y : \u2124_[p]} : (x : \u211a_[p]) = (y : \u211a_[p]) \u2194 x = y := coe_injective.eq_iff\n\ninstance : Infinite \u2124_[p] := CharZero.infinite _\n\n@[simp]\nprotected lemma nnnorm_mul (x y : \u2124_[p]) : \u2016x * y\u2016\u208a = \u2016x\u2016\u208a * \u2016y\u2016\u208a := by simp [nnnorm, NNReal]\n\n", "theoremStatement": "@[simp]\nprotected lemma nnnorm_pow (x : \u2124_[p]) (n : \u2115) : \u2016x ^ n\u2016\u208a = \u2016x\u2016\u208a ^ n ", "theoremName": "PadicInt.nnnorm_pow", "fileCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "theoremCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "file": "FLT/FLT/Mathlib/NumberTheory/Padics/PadicIntegers.lean", "module": "FLT.Mathlib.NumberTheory.Padics.PadicIntegers", "jsonFile": "FLT.Mathlib.NumberTheory.Padics.PadicIntegers.jsonl", "positionMetadata": {"lineInFile": 33, "tokenPositionInFile": 849, "theoremPositionInFile": 4}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 55}, "proofMetadata": {"hasProof": true, "proof": ":= by simp [nnnorm, NNReal]", "proofType": "tactic", "proofLengthLines": 0, "proofLengthTokens": 27}}
{"srcContext": "/-\nCopyright (c) 2024 Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras\n-/\nimport FLT.Mathlib.MeasureTheory.Group.Action\nimport FLT.HaarMeasure.DistribHaarChar.Basic\nimport FLT.HaarMeasure.MeasurableSpacePadics\n\n/-!\n# The distributive Haar characters of the p-adics\n\nThis file computes `distribHaarChar` in the case of the actions of `\u2124_[p]\u02e3` on `\u2124_[p]` and of\n`\u211a_[p]\u02e3` on `\u211a_[p]`.\n\nThis lets us know what `volume (x \u2022 s)` is in terms of `\u2016x\u2016` and `volume s`, when `x` is a\np-adic/p-adic integer and `s` is a set of p-adics/p-adic integers.\n\n## Main declarations\n\n* `distribHaarChar_padic`: `distribHaarChar \u211a_[p]` is the usual p-adic norm on `\u211a_[p]\u02e3`.\n* `distribHaarChar_padicInt`: `distribHaarChar \u2124_[p]` is constantly `1` on `\u2124_[p]\u02e3`.\n* `Padic.volume_padic_smul`: `volume (x \u2022 s) = \u2016x\u2016\u208a * volume s` for all `x : \u211a_[p]` and\n  `s : Set \u211a_[p]`.\n* `PadicInt.volume_padicInt_smul`: `volume (x \u2022 s) = \u2016x\u2016\u208a * volume s` for all `x : \u2124_[p]` and\n  `s : Set \u2124_[p]`.\n-/\n\nopen Padic MeasureTheory Measure Metric Set\nopen scoped Pointwise ENNReal NNReal nonZeroDivisors\n\nvariable {p : \u2115} [Fact p.Prime]\n\nprivate lemma distribHaarChar_padic_padicInt (x : \u2124_[p]\u2070) :\n    distribHaarChar \u211a_[p] (x : \u211a_[p]\u02e3) = \u2016(x : \u211a_[p])\u2016\u208a := by\n  -- Let `K` be the copy of `\u2124_[p]` inside `\u211a_[p]` and `H` be `xK`.\n  let K : AddSubgroup \u211a_[p] := (1 : Submodule \u2124_[p] \u211a_[p]).toAddSubgroup\n  let H := (x : \u211a_[p]) \u2022 K\n  -- We compute that `volume H = \u2016x\u2016\u208a * volume K`.\n  refine distribHaarChar_eq_of_measure_smul_eq_mul (s := K) (\u03bc := volume) (G := \u211a_[p]\u02e3)\n    (by simp [K, Padic.submodule_one_eq_closedBall, closedBall, Padic.volume_closedBall_one])\n    (by simp [K, Padic.submodule_one_eq_closedBall, closedBall, Padic.volume_closedBall_one]) ?_\n  change volume (H : Set \u211a_[p]) = \u2016(x : \u211a_[p])\u2016\u208a * volume (K : Set \u211a_[p])\n  -- This is true because `H` is a `\u2016x\u2016\u208a\u207b\u00b9`-index subgroup of `K`.\n  have hHK : H \u2264 K := by\n    simpa [H, K, -Submodule.smul_le_self_of_tower]\n      using (1 : Submodule \u2124_[p] \u211a_[p]).smul_le_self_of_tower (x : \u2124_[p])\n  have : H.FiniteRelIndex K :=\n    PadicInt.smul_submodule_finiteRelIndex (p := p) (mem_nonZeroDivisors_iff_ne_zero.1 x.2) 1\n  have H_relindex_Z : (H.relindex K : \u211d\u22650\u221e) = \u2016(x : \u211a_[p])\u2016\u208a\u207b\u00b9 :=\n    congr(ENNReal.ofNNReal $(PadicInt.smul_submodule_relindex (p := p) x 1))\n  rw [\u2190 index_mul_addHaar_addSubgroup_eq_addHaar_addSubgroup hHK, H_relindex_Z, ENNReal.coe_inv,\n    ENNReal.mul_inv_cancel_left]\n  \u00b7 simp\n  \u00b7 simp\n  \u00b7 simp\n  \u00b7 simpa [H, K, Padic.submodule_one_eq_closedBall]\n      using measurableSet_closedBall.const_smul (x : \u211a_[p]\u02e3)\n  \u00b7 simpa [K, Padic.submodule_one_eq_closedBall] using measurableSet_closedBall\n\n/-- The distributive Haar character of the action of `\u211a_[p]\u02e3` on `\u211a_[p]` is the usual p-adic norm.\n\nThis means that `volume (x \u2022 s) = \u2016x\u2016 * volume s` for all `x : \u211a_[p]` and `s : Set \u211a_[p]`.\nSee `Padic.volume_padic_smul` -/\n@[simp]\nlemma distribHaarChar_padic (x : \u211a_[p]\u02e3) : distribHaarChar \u211a_[p] x = \u2016(x : \u211a_[p])\u2016\u208a := by\n  -- Write the RHS as the application of a monoid hom `g`.\n  let g : \u211a_[p]\u02e3 \u2192* \u211d\u22650 := {\n    toFun := fun x => \u2016(x : \u211a_[p])\u2016\u208a\n    map_one' := by simp\n    map_mul' := by simp\n  }\n  revert x\n  suffices distribHaarChar \u211a_[p] = g by simp [this, g]\n  -- By density of `\u2124_[p]\u2070` inside `\u211a_[p]\u02e3`, it's enough to check that `distribHaarChar \u211a_[p]` and\n  -- `g` agree on `\u2124_[p]\u2070`.\n  refine MonoidHom.eq_of_eqOn_dense (PadicInt.closure_nonZeroDivisors_padicInt (p := p)) ?_\n  -- But this is what we proved in `distribHaarChar_padic_padicInt`.\n  simp\n  ext x\n  simp [g]\n  rw [distribHaarChar_padic_padicInt]\n  rfl\n\n", "theoremStatement": "@[simp]\nlemma Padic.volume_padic_smul (x : \u211a_[p]) (s : Set \u211a_[p]) : volume (x \u2022 s) = \u2016x\u2016\u208a * volume s ", "theoremName": "Padic.volume_padic_smul", "fileCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "theoremCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "file": "FLT/FLT/HaarMeasure/DistribHaarChar/Padic.lean", "module": "FLT.HaarMeasure.DistribHaarChar.Padic", "jsonFile": "FLT.HaarMeasure.DistribHaarChar.Padic.jsonl", "positionMetadata": {"lineInFile": 85, "tokenPositionInFile": 3670, "theoremPositionInFile": 2}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 7, "numPremises": 187}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  obtain rfl | hx := eq_or_ne x 0\n  \u00b7 simp [(finite_zero.subset s.zero_smul_set_subset).measure_zero]\n  \u00b7 lift x to \u211a_[p]\u02e3 using hx.isUnit\n    rw [\u2190 distribHaarChar_padic, distribHaarChar_mul, Units.smul_def]", "proofType": "tactic", "proofLengthLines": 4, "proofLengthTokens": 214}}
