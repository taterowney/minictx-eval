{"srcContext": "import ConNF.Model.Hailperin\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal ConNF.TSet\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\ntheorem ext (x y : TSet \u03b1) :\n    (\u2200 z : TSet \u03b2, z \u2208' x \u2194 z \u2208' y) \u2192 x = y :=\n  tSet_ext' h\u03b2 x y\n\ndef inter (x y : TSet \u03b1) : TSet \u03b1 :=\n  (TSet.exists_inter h\u03b2 x y).choose\n\nnotation:69 x:69 \" \u2293[\" h \"] \" y:69 => _root_.ConNF.inter h x y\nnotation:69 x:69 \" \u2293' \" y:69 => x \u2293[by assumption] y\n\n@[simp]\ntheorem mem_inter_iff (x y : TSet \u03b1) :\n    \u2200 z : TSet \u03b2, z \u2208' x \u2293' y \u2194 z \u2208' x \u2227 z \u2208' y :=\n  (TSet.exists_inter h\u03b2 x y).choose_spec\n\ndef compl (x : TSet \u03b1) : TSet \u03b1 :=\n  (TSet.exists_compl h\u03b2 x).choose\n\nnotation:1024 x:1024 \" \u1d9c[\" h \"]\" => _root_.ConNF.compl h x\nnotation:1024 x:1024 \" \u1d9c'\" => x\u1d9c[by assumption]\n\n@[simp]\ntheorem mem_compl_iff (x : TSet \u03b1) :\n    \u2200 z : TSet \u03b2, z \u2208' x\u1d9c' \u2194 \u00acz \u2208' x :=\n  (TSet.exists_compl h\u03b2 x).choose_spec\n\nnotation:1024 \"{\" x \"}[\" h \"]\" => _root_.ConNF.singleton h x\nnotation:1024 \"{\" x \"}'\" => {x}[by assumption]\n\n@[simp]\ntheorem mem_singleton_iff (x y : TSet \u03b2) :\n    y \u2208' {x}' \u2194 y = x :=\n  typedMem_singleton_iff' h\u03b2 x y\n\nnotation:1024 \"{\" x \", \" y \"}[\" h \"]\" => _root_.ConNF.TSet.up h x y\nnotation:1024 \"{\" x \", \" y \"}'\" => {x, y}[by assumption]\n\n@[simp]\ntheorem mem_up_iff (x y z : TSet \u03b2) :\n    z \u2208' {x, y}' \u2194 z = x \u2228 z = y :=\n  TSet.mem_up_iff h\u03b2 x y z\n\nnotation:1024 \"\u27e8\" x \", \" y \"\u27e9[\" h \", \" h' \"]\" => _root_.ConNF.TSet.op h h' x y\nnotation:1024 \"\u27e8\" x \", \" y \"\u27e9'\" => \u27e8x, y\u27e9[by assumption, by assumption]\n\ntheorem op_def (x y : TSet \u03b3) :\n    (\u27e8x, y\u27e9' : TSet \u03b1) = { {x}', {x, y}' }' :=\n  rfl\n\ndef singletonImage' (x : TSet \u03b2) : TSet \u03b1 :=\n  (TSet.exists_singletonImage h\u03b2 h\u03b3 h\u03b4 h\u03b5 x).choose\n\n", "theoremStatement": "@[simp]\ntheorem singletonImage'_spec (x : TSet \u03b2) :\n    \u2200 z w,\n    \u27e8 {z}', {w}' \u27e9' \u2208' singletonImage' h\u03b2 h\u03b3 h\u03b4 h\u03b5 x \u2194 \u27e8z, w\u27e9' \u2208' x ", "theoremName": "ConNF.singletonImage'_spec", "fileCreated": {"commit": "b12701769822aaf5451982e26d7b7d1c2f21b137", "date": "2024-04-11"}, "theoremCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "file": "ConNF/ConNF/Model/Result.lean", "module": "ConNF.Model.Result", "jsonFile": "ConNF.Model.Result.jsonl", "positionMetadata": {"lineInFile": 75, "tokenPositionInFile": 1903, "theoremPositionInFile": 19}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 13, "numPremises": 25}, "proofMetadata": {"hasProof": true, "proof": ":=\n  (TSet.exists_singletonImage h\u03b2 h\u03b3 h\u03b4 h\u03b5 x).choose_spec", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 59}}
{"srcContext": "import ConNF.Model.Result\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal ConNF.TSet\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\ndef union (x y : TSet \u03b1) : TSet \u03b1 :=\n  (x\u1d9c' \u2293' y\u1d9c')\u1d9c'\n\nnotation:68 x:68 \" \u2294[\" h \"] \" y:68 => _root_.ConNF.union h x y\nnotation:68 x:68 \" \u2294' \" y:68 => x \u2294[by assumption] y\n\n@[simp]\ntheorem mem_union_iff (x y : TSet \u03b1) :\n    \u2200 z : TSet \u03b2, z \u2208' x \u2294' y \u2194 z \u2208' x \u2228 z \u2208' y := by\n  rw [union]\n  intro z\n  rw [mem_compl_iff, mem_inter_iff, mem_compl_iff, mem_compl_iff, or_iff_not_and_not]\n\ndef higherIndex (\u03b1 : \u039b) : \u039b :=\n  (exists_gt \u03b1).choose\n\ntheorem lt_higherIndex {\u03b1 : \u039b} :\n    (\u03b1 : TypeIndex) < higherIndex \u03b1 :=\n  WithBot.coe_lt_coe.mpr (exists_gt \u03b1).choose_spec\n\ntheorem tSet_nonempty (h : \u2203 \u03b2 : \u039b, (\u03b2 : TypeIndex) < \u03b1) : Nonempty (TSet \u03b1) := by\n  obtain \u27e8\u03b1', h\u03b1\u27e9 := h\n  constructor\n  apply typeLower lt_higherIndex lt_higherIndex lt_higherIndex h\u03b1\n  apply cardinalOne lt_higherIndex lt_higherIndex\n\ndef empty : TSet \u03b1 :=\n  (tSet_nonempty \u27e8\u03b2, h\u03b2\u27e9).some \u2293' (tSet_nonempty \u27e8\u03b2, h\u03b2\u27e9).some\u1d9c'\n\n@[simp]\ntheorem mem_empty_iff :\n    \u2200 x : TSet \u03b2, \u00acx \u2208' empty h\u03b2 := by\n  intro x\n  rw [empty, mem_inter_iff, mem_compl_iff]\n  exact and_not_self\n\ndef univ : TSet \u03b1 :=\n  (empty h\u03b2)\u1d9c'\n\n@[simp]\ntheorem mem_univ_iff :\n    \u2200 x : TSet \u03b2, x \u2208' univ h\u03b2 := by\n  intro x\n  simp only [univ, mem_compl_iff, mem_empty_iff, not_false_eq_true]\n\n/-- The set of all ordered pairs. -/\ndef orderedPairs : TSet \u03b1 :=\n  vCross h\u03b2 h\u03b3 h\u03b4 (univ h\u03b4)\n\n@[simp]\ntheorem mem_orderedPairs_iff (x : TSet \u03b2) :\n    x \u2208' orderedPairs h\u03b2 h\u03b3 h\u03b4 \u2194 \u2203 a b, x = \u27e8a, b\u27e9' := by\n  simp only [orderedPairs, vCross_spec, mem_univ_iff, and_true]\n\ndef converse (x : TSet \u03b1) : TSet \u03b1 :=\n  converse' h\u03b2 h\u03b3 h\u03b4 x \u2293' orderedPairs h\u03b2 h\u03b3 h\u03b4\n\n@[simp]\ntheorem op_mem_converse_iff (x : TSet \u03b1) :\n    \u2200 a b, \u27e8a, b\u27e9' \u2208' converse h\u03b2 h\u03b3 h\u03b4 x \u2194 \u27e8b, a\u27e9' \u2208' x := by\n  intro a b\n  simp only [converse, mem_inter_iff, converse'_spec, mem_orderedPairs_iff, op_inj, exists_and_left,\n    exists_eq', and_true]\n\ndef cross (x y : TSet \u03b3) : TSet \u03b1 :=\n  converse h\u03b2 h\u03b3 h\u03b4 (vCross h\u03b2 h\u03b3 h\u03b4 x) \u2293' vCross h\u03b2 h\u03b3 h\u03b4 y\n\n@[simp]\ntheorem mem_cross_iff (x y : TSet \u03b3) :\n    \u2200 a, a \u2208' cross h\u03b2 h\u03b3 h\u03b4 x y \u2194 \u2203 b c, a = \u27e8b, c\u27e9' \u2227 b \u2208' x \u2227 c \u2208' y := by\n  intro a\n  rw [cross, mem_inter_iff, vCross_spec]\n  constructor\n  \u00b7 rintro \u27e8h\u2081, b, c, rfl, h\u2082\u27e9\n    simp only [op_mem_converse_iff, vCross_spec, op_inj] at h\u2081\n    obtain \u27e8b', c', \u27e8rfl, rfl\u27e9, h\u2081\u27e9 := h\u2081\n    exact \u27e8b, c, rfl, h\u2081, h\u2082\u27e9\n  \u00b7 rintro \u27e8b, c, rfl, h\u2081, h\u2082\u27e9\n    simp only [op_mem_converse_iff, vCross_spec, op_inj]\n    exact \u27e8\u27e8c, b, \u27e8rfl, rfl\u27e9, h\u2081\u27e9, \u27e8b, c, \u27e8rfl, rfl\u27e9, h\u2082\u27e9\u27e9\n\ndef singletonImage (x : TSet \u03b2) : TSet \u03b1 :=\n  singletonImage' h\u03b2 h\u03b3 h\u03b4 h\u03b5 x \u2293' (cross h\u03b2 h\u03b3 h\u03b4 (cardinalOne h\u03b4 h\u03b5) (cardinalOne h\u03b4 h\u03b5))\n\n@[simp]\ntheorem singletonImage_spec (x : TSet \u03b2) :\n    \u2200 z w,\n    \u27e8 {z}', {w}' \u27e9' \u2208' singletonImage h\u03b2 h\u03b3 h\u03b4 h\u03b5 x \u2194 \u27e8z, w\u27e9' \u2208' x := by\n  intro z w\n  rw [singletonImage, mem_inter_iff, singletonImage'_spec, and_iff_left_iff_imp]\n  intro hzw\n  rw [mem_cross_iff]\n  refine \u27e8{z}', {w}', rfl, ?_\u27e9\n  simp only [mem_cardinalOne_iff, singleton_inj, exists_eq', and_self]\n\ntheorem exists_of_mem_singletonImage {x : TSet \u03b2} {z w : TSet \u03b4}\n    (h : \u27e8z, w\u27e9' \u2208' singletonImage h\u03b2 h\u03b3 h\u03b4 h\u03b5 x) :\n    \u2203 a b, z = {a}' \u2227 w = {b}' := by\n  simp only [singletonImage, mem_inter_iff, mem_cross_iff, op_inj, mem_cardinalOne_iff] at h\n  obtain \u27e8-, _, _, \u27e8rfl, rfl\u27e9, \u27e8a, rfl\u27e9, \u27e8b, rfl\u27e9\u27e9 := h\n  exact \u27e8a, b, rfl, rfl\u27e9\n\n/-- Turn a model element encoding a relation into an actual relation. -/\ndef ExternalRel (r : TSet \u03b1) : Rel (TSet \u03b4) (TSet \u03b4) :=\n  \u03bb x y \u21a6 \u27e8x, y\u27e9' \u2208' r\n\n@[simp]\ntheorem externalRel_converse (r : TSet \u03b1) :\n    ExternalRel h\u03b2 h\u03b3 h\u03b4 (converse h\u03b2 h\u03b3 h\u03b4 r) = (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).inv := by\n  ext\n  simp only [ExternalRel, op_mem_converse_iff, Rel.inv_apply]\n\n/-- The codomain of a relation. -/\ndef codom (r : TSet \u03b1) : TSet \u03b3 :=\n  (typeLower lt_higherIndex h\u03b2 h\u03b3 h\u03b4 (singletonImage lt_higherIndex h\u03b2 h\u03b3 h\u03b4 r)\u1d9c[lt_higherIndex])\u1d9c'\n\n@[simp]\ntheorem mem_codom_iff (r : TSet \u03b1) (x : TSet \u03b4) :\n    x \u2208' codom h\u03b2 h\u03b3 h\u03b4 r \u2194 x \u2208 (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).codom := by\n  simp only [codom, mem_compl_iff, mem_typeLower_iff, not_forall, not_not]\n  constructor\n  \u00b7 rintro \u27e8y, hy\u27e9\n    obtain \u27e8a, b, rfl, hb\u27e9 := exists_of_mem_singletonImage lt_higherIndex h\u03b2 h\u03b3 h\u03b4 hy\n    rw [singleton_inj] at hb\n    subst hb\n    rw [singletonImage_spec] at hy\n    exact \u27e8a, hy\u27e9\n  \u00b7 rintro \u27e8a, ha\u27e9\n    use {a}'\n    rw [singletonImage_spec]\n    exact ha\n\n/-- The domain of a relation. -/\ndef dom (r : TSet \u03b1) : TSet \u03b3 :=\n  codom h\u03b2 h\u03b3 h\u03b4 (converse h\u03b2 h\u03b3 h\u03b4 r)\n\n@[simp]\ntheorem mem_dom_iff (r : TSet \u03b1) (x : TSet \u03b4) :\n    x \u2208' dom h\u03b2 h\u03b3 h\u03b4 r \u2194 x \u2208 (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).dom := by\n  rw [dom, mem_codom_iff, externalRel_converse, Rel.inv_codom]\n\n/-- The field of a relation. -/\ndef field (r : TSet \u03b1) : TSet \u03b3 :=\n  dom h\u03b2 h\u03b3 h\u03b4 r \u2294' codom h\u03b2 h\u03b3 h\u03b4 r\n\n@[simp]\ntheorem mem_field_iff (r : TSet \u03b1) (x : TSet \u03b4) :\n    x \u2208' field h\u03b2 h\u03b3 h\u03b4 r \u2194 x \u2208 (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).field := by\n  rw [field, mem_union_iff, mem_dom_iff, mem_codom_iff, Rel.field, Set.mem_union]\n\ndef subset : TSet \u03b1 :=\n  subset' h\u03b2 h\u03b3 h\u03b4 h\u03b5 \u2293' orderedPairs h\u03b2 h\u03b3 h\u03b4\n\n@[simp]\ntheorem subset_spec :\n    \u2200 a b, \u27e8a, b\u27e9' \u2208' subset h\u03b2 h\u03b3 h\u03b4 h\u03b5 \u2194 a \u2286[TSet \u03b5] b := by\n  intro a b\n  simp only [subset, mem_inter_iff, subset'_spec, mem_orderedPairs_iff, op_inj, exists_and_left,\n    exists_eq', and_true]\n\ndef membership : TSet \u03b1 :=\n  subset h\u03b2 h\u03b3 h\u03b4 h\u03b5 \u2293' cross h\u03b2 h\u03b3 h\u03b4 (cardinalOne h\u03b4 h\u03b5) (univ h\u03b4)\n\n@[simp]\ntheorem membership_spec :\n    \u2200 a b, \u27e8{a}', b\u27e9' \u2208' membership h\u03b2 h\u03b3 h\u03b4 h\u03b5 \u2194 a \u2208' b := by\n  intro a b\n  rw [membership, mem_inter_iff, subset_spec]\n  simp only [mem_cross_iff, op_inj, mem_cardinalOne_iff, mem_univ_iff, and_true, exists_and_right,\n    exists_and_left, exists_eq', exists_eq_left', singleton_inj]\n  constructor\n  \u00b7 intro h\n    exact h a ((typedMem_singleton_iff' h\u03b5 a a).mpr rfl)\n  \u00b7 intro h c hc\n    simp only [typedMem_singleton_iff'] at hc\n    cases hc\n    exact h\n\ndef powerset (x : TSet \u03b2) : TSet \u03b1 :=\n  dom lt_higherIndex lt_higherIndex h\u03b2\n    (subset lt_higherIndex lt_higherIndex h\u03b2 h\u03b3 \u2293[lt_higherIndex]\n      vCross lt_higherIndex lt_higherIndex h\u03b2 {x}')\n\n", "theoremStatement": "@[simp]\ntheorem mem_powerset_iff (x y : TSet \u03b2) :\n    x \u2208' powerset h\u03b2 h\u03b3 y \u2194 x \u2286[TSet \u03b3] y ", "theoremName": "ConNF.mem_powerset_iff", "fileCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "theoremCreated": {"commit": "1c08486feb882444888c228ce1501e92bb85e0e2", "date": "2025-01-07"}, "file": "ConNF/ConNF/External/Basic.lean", "module": "ConNF.External.Basic", "jsonFile": "ConNF.External.Basic.jsonl", "positionMetadata": {"lineInFile": 206, "tokenPositionInFile": 6350, "theoremPositionInFile": 33}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 8, "repositoryPremises": true, "numRepositoryPremises": 26, "numPremises": 74}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [powerset, mem_dom_iff]\n  constructor\n  \u00b7 rintro \u27e8z, h\u27e9\n    simp only [ExternalRel, mem_inter_iff, subset_spec, vCross_spec, op_inj,\n      typedMem_singleton_iff', exists_eq_right, exists_and_right, exists_eq', true_and] at h\n    cases h.2\n    exact h.1\n  \u00b7 intro h\n    refine \u27e8y, ?_\u27e9\n    simp only [ExternalRel, mem_inter_iff, subset_spec, h, vCross_spec, op_inj,\n      typedMem_singleton_iff', exists_eq_right, and_true, exists_eq', and_self]", "proofType": "tactic", "proofLengthLines": 11, "proofLengthTokens": 455}}
{"srcContext": "import ConNF.Model.TTT\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\nnamespace TSet\n\ntheorem exists_inter (x y : TSet \u03b1) :\n    \u2203 w : TSet \u03b1, \u2200 z : TSet \u03b2, z \u2208[h\u03b2] w \u2194 z \u2208[h\u03b2] x \u2227 z \u2208[h\u03b2] y := by\n  refine exists_of_symmetric {z | z \u2208[h\u03b2] x \u2227 z \u2208[h\u03b2] y} h\u03b2 ?_\n  obtain \u27e8S, hS\u27e9 := symmetric x h\u03b2\n  obtain \u27e8T, hT\u27e9 := symmetric y h\u03b2\n  use S + T\n  intro \u03c1 h\u03c1\n  specialize hS \u03c1 (smul_eq_of_le Support.le_add_right h\u03c1)\n  specialize hT \u03c1 (smul_eq_of_le Support.le_add_left h\u03c1)\n  simp [Set.ext_iff, Set.mem_smul_set_iff_inv_smul_mem] at hS hT \u22a2\n  aesop\n\ntheorem exists_compl (x : TSet \u03b1) :\n    \u2203 y : TSet \u03b1, \u2200 z : TSet \u03b2, z \u2208[h\u03b2] y \u2194 \u00acz \u2208[h\u03b2] x := by\n  refine exists_of_symmetric {z | \u00acz \u2208[h\u03b2] x} h\u03b2 ?_\n  obtain \u27e8S, hS\u27e9 := symmetric x h\u03b2\n  use S\n  intro \u03c1 h\u03c1\n  specialize hS \u03c1 h\u03c1\n  simp [Set.ext_iff, Set.mem_smul_set_iff_inv_smul_mem] at hS \u22a2\n  aesop\n\n", "theoremStatement": "theorem exists_up (x y : TSet \u03b2) :\n    \u2203 w : TSet \u03b1, \u2200 z : TSet \u03b2, z \u2208[h\u03b2] w \u2194 z = x \u2228 z = y ", "theoremName": "ConNF.TSet.exists_up", "fileCreated": {"commit": "f804f5c71cfaa98223fc227dd822801e8bf77004", "date": "2024-03-30"}, "theoremCreated": {"commit": "79d0b7460f1a514629674a45c428d31c1a50bb03", "date": "2024-12-01"}, "file": "ConNF/ConNF/Model/Hailperin.lean", "module": "ConNF.Model.Hailperin", "jsonFile": "ConNF.Model.Hailperin.jsonl", "positionMetadata": {"lineInFile": 47, "tokenPositionInFile": 1139, "theoremPositionInFile": 2}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 36, "numPremises": 92}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  refine exists_of_symmetric {x, y} h\u03b2 ?_\n  obtain \u27e8S, hS\u27e9 := exists_support x\n  obtain \u27e8T, hT\u27e9 := exists_support y\n  use (S + T) \u2197 h\u03b2\n  intro \u03c1 h\u03c1\n  rw [Support.smul_scoderiv, Support.scoderiv_inj, \u2190 allPermSderiv_forget'] at h\u03c1\n  specialize hS (\u03c1 \u2198 h\u03b2) (smul_eq_of_le Support.le_add_right h\u03c1)\n  specialize hT (\u03c1 \u2198 h\u03b2) (smul_eq_of_le Support.le_add_left h\u03c1)\n  simp only [Set.smul_set_def, Set.image, Set.mem_insert_iff, Set.mem_singleton_iff,\n    exists_eq_or_imp, hS, exists_eq_left, hT]\n  ext z\n  rw [Set.mem_insert_iff, Set.mem_singleton_iff, Set.mem_setOf_eq]\n  aesop", "proofType": "tactic", "proofLengthLines": 13, "proofLengthTokens": 578}}
{"srcContext": "import ConNF.Model.Result\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal ConNF.TSet\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\ndef union (x y : TSet \u03b1) : TSet \u03b1 :=\n  (x\u1d9c' \u2293' y\u1d9c')\u1d9c'\n\nnotation:68 x:68 \" \u2294[\" h \"] \" y:68 => _root_.ConNF.union h x y\nnotation:68 x:68 \" \u2294' \" y:68 => x \u2294[by assumption] y\n\n@[simp]\ntheorem mem_union_iff (x y : TSet \u03b1) :\n    \u2200 z : TSet \u03b2, z \u2208' x \u2294' y \u2194 z \u2208' x \u2228 z \u2208' y := by\n  rw [union]\n  intro z\n  rw [mem_compl_iff, mem_inter_iff, mem_compl_iff, mem_compl_iff, or_iff_not_and_not]\n\ndef higherIndex (\u03b1 : \u039b) : \u039b :=\n  (exists_gt \u03b1).choose\n\ntheorem lt_higherIndex {\u03b1 : \u039b} :\n    (\u03b1 : TypeIndex) < higherIndex \u03b1 :=\n  WithBot.coe_lt_coe.mpr (exists_gt \u03b1).choose_spec\n\ntheorem tSet_nonempty (h : \u2203 \u03b2 : \u039b, (\u03b2 : TypeIndex) < \u03b1) : Nonempty (TSet \u03b1) := by\n  obtain \u27e8\u03b1', h\u03b1\u27e9 := h\n  constructor\n  apply typeLower lt_higherIndex lt_higherIndex lt_higherIndex h\u03b1\n  apply cardinalOne lt_higherIndex lt_higherIndex\n\ndef empty : TSet \u03b1 :=\n  (tSet_nonempty \u27e8\u03b2, h\u03b2\u27e9).some \u2293' (tSet_nonempty \u27e8\u03b2, h\u03b2\u27e9).some\u1d9c'\n\n@[simp]\ntheorem mem_empty_iff :\n    \u2200 x : TSet \u03b2, \u00acx \u2208' empty h\u03b2 := by\n  intro x\n  rw [empty, mem_inter_iff, mem_compl_iff]\n  exact and_not_self\n\ndef univ : TSet \u03b1 :=\n  (empty h\u03b2)\u1d9c'\n\n@[simp]\ntheorem mem_univ_iff :\n    \u2200 x : TSet \u03b2, x \u2208' univ h\u03b2 := by\n  intro x\n  simp only [univ, mem_compl_iff, mem_empty_iff, not_false_eq_true]\n\n/-- The set of all ordered pairs. -/\ndef orderedPairs : TSet \u03b1 :=\n  vCross h\u03b2 h\u03b3 h\u03b4 (univ h\u03b4)\n\n@[simp]\ntheorem mem_orderedPairs_iff (x : TSet \u03b2) :\n    x \u2208' orderedPairs h\u03b2 h\u03b3 h\u03b4 \u2194 \u2203 a b, x = \u27e8a, b\u27e9' := by\n  simp only [orderedPairs, vCross_spec, mem_univ_iff, and_true]\n\ndef converse (x : TSet \u03b1) : TSet \u03b1 :=\n  converse' h\u03b2 h\u03b3 h\u03b4 x \u2293' orderedPairs h\u03b2 h\u03b3 h\u03b4\n\n@[simp]\ntheorem op_mem_converse_iff (x : TSet \u03b1) :\n    \u2200 a b, \u27e8a, b\u27e9' \u2208' converse h\u03b2 h\u03b3 h\u03b4 x \u2194 \u27e8b, a\u27e9' \u2208' x := by\n  intro a b\n  simp only [converse, mem_inter_iff, converse'_spec, mem_orderedPairs_iff, op_inj, exists_and_left,\n    exists_eq', and_true]\n\ndef cross (x y : TSet \u03b3) : TSet \u03b1 :=\n  converse h\u03b2 h\u03b3 h\u03b4 (vCross h\u03b2 h\u03b3 h\u03b4 x) \u2293' vCross h\u03b2 h\u03b3 h\u03b4 y\n\n@[simp]\ntheorem mem_cross_iff (x y : TSet \u03b3) :\n    \u2200 a, a \u2208' cross h\u03b2 h\u03b3 h\u03b4 x y \u2194 \u2203 b c, a = \u27e8b, c\u27e9' \u2227 b \u2208' x \u2227 c \u2208' y := by\n  intro a\n  rw [cross, mem_inter_iff, vCross_spec]\n  constructor\n  \u00b7 rintro \u27e8h\u2081, b, c, rfl, h\u2082\u27e9\n    simp only [op_mem_converse_iff, vCross_spec, op_inj] at h\u2081\n    obtain \u27e8b', c', \u27e8rfl, rfl\u27e9, h\u2081\u27e9 := h\u2081\n    exact \u27e8b, c, rfl, h\u2081, h\u2082\u27e9\n  \u00b7 rintro \u27e8b, c, rfl, h\u2081, h\u2082\u27e9\n    simp only [op_mem_converse_iff, vCross_spec, op_inj]\n    exact \u27e8\u27e8c, b, \u27e8rfl, rfl\u27e9, h\u2081\u27e9, \u27e8b, c, \u27e8rfl, rfl\u27e9, h\u2082\u27e9\u27e9\n\ndef singletonImage (x : TSet \u03b2) : TSet \u03b1 :=\n  singletonImage' h\u03b2 h\u03b3 h\u03b4 h\u03b5 x \u2293' (cross h\u03b2 h\u03b3 h\u03b4 (cardinalOne h\u03b4 h\u03b5) (cardinalOne h\u03b4 h\u03b5))\n\n@[simp]\ntheorem singletonImage_spec (x : TSet \u03b2) :\n    \u2200 z w,\n    \u27e8 {z}', {w}' \u27e9' \u2208' singletonImage h\u03b2 h\u03b3 h\u03b4 h\u03b5 x \u2194 \u27e8z, w\u27e9' \u2208' x := by\n  intro z w\n  rw [singletonImage, mem_inter_iff, singletonImage'_spec, and_iff_left_iff_imp]\n  intro hzw\n  rw [mem_cross_iff]\n  refine \u27e8{z}', {w}', rfl, ?_\u27e9\n  simp only [mem_cardinalOne_iff, singleton_inj, exists_eq', and_self]\n\ntheorem exists_of_mem_singletonImage {x : TSet \u03b2} {z w : TSet \u03b4}\n    (h : \u27e8z, w\u27e9' \u2208' singletonImage h\u03b2 h\u03b3 h\u03b4 h\u03b5 x) :\n    \u2203 a b, z = {a}' \u2227 w = {b}' := by\n  simp only [singletonImage, mem_inter_iff, mem_cross_iff, op_inj, mem_cardinalOne_iff] at h\n  obtain \u27e8-, _, _, \u27e8rfl, rfl\u27e9, \u27e8a, rfl\u27e9, \u27e8b, rfl\u27e9\u27e9 := h\n  exact \u27e8a, b, rfl, rfl\u27e9\n\n/-- Turn a model element encoding a relation into an actual relation. -/\ndef ExternalRel (r : TSet \u03b1) : Rel (TSet \u03b4) (TSet \u03b4) :=\n  \u03bb x y \u21a6 \u27e8x, y\u27e9' \u2208' r\n\n@[simp]\ntheorem externalRel_converse (r : TSet \u03b1) :\n    ExternalRel h\u03b2 h\u03b3 h\u03b4 (converse h\u03b2 h\u03b3 h\u03b4 r) = (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).inv := by\n  ext\n  simp only [ExternalRel, op_mem_converse_iff, Rel.inv_apply]\n\n/-- The codomain of a relation. -/\ndef codom (r : TSet \u03b1) : TSet \u03b3 :=\n  (typeLower lt_higherIndex h\u03b2 h\u03b3 h\u03b4 (singletonImage lt_higherIndex h\u03b2 h\u03b3 h\u03b4 r)\u1d9c[lt_higherIndex])\u1d9c'\n\n@[simp]\ntheorem mem_codom_iff (r : TSet \u03b1) (x : TSet \u03b4) :\n    x \u2208' codom h\u03b2 h\u03b3 h\u03b4 r \u2194 x \u2208 (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).codom := by\n  simp only [codom, mem_compl_iff, mem_typeLower_iff, not_forall, not_not]\n  constructor\n  \u00b7 rintro \u27e8y, hy\u27e9\n    obtain \u27e8a, b, rfl, hb\u27e9 := exists_of_mem_singletonImage lt_higherIndex h\u03b2 h\u03b3 h\u03b4 hy\n    rw [singleton_inj] at hb\n    subst hb\n    rw [singletonImage_spec] at hy\n    exact \u27e8a, hy\u27e9\n  \u00b7 rintro \u27e8a, ha\u27e9\n    use {a}'\n    rw [singletonImage_spec]\n    exact ha\n\n/-- The domain of a relation. -/\ndef dom (r : TSet \u03b1) : TSet \u03b3 :=\n  codom h\u03b2 h\u03b3 h\u03b4 (converse h\u03b2 h\u03b3 h\u03b4 r)\n\n@[simp]\ntheorem mem_dom_iff (r : TSet \u03b1) (x : TSet \u03b4) :\n    x \u2208' dom h\u03b2 h\u03b3 h\u03b4 r \u2194 x \u2208 (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).dom := by\n  rw [dom, mem_codom_iff, externalRel_converse, Rel.inv_codom]\n\n/-- The field of a relation. -/\ndef field (r : TSet \u03b1) : TSet \u03b3 :=\n  dom h\u03b2 h\u03b3 h\u03b4 r \u2294' codom h\u03b2 h\u03b3 h\u03b4 r\n\n@[simp]\ntheorem mem_field_iff (r : TSet \u03b1) (x : TSet \u03b4) :\n    x \u2208' field h\u03b2 h\u03b3 h\u03b4 r \u2194 x \u2208 (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).field := by\n  rw [field, mem_union_iff, mem_dom_iff, mem_codom_iff, Rel.field, Set.mem_union]\n\ndef subset : TSet \u03b1 :=\n  subset' h\u03b2 h\u03b3 h\u03b4 h\u03b5 \u2293' orderedPairs h\u03b2 h\u03b3 h\u03b4\n\n@[simp]\ntheorem subset_spec :\n    \u2200 a b, \u27e8a, b\u27e9' \u2208' subset h\u03b2 h\u03b3 h\u03b4 h\u03b5 \u2194 a \u2286[TSet \u03b5] b := by\n  intro a b\n  simp only [subset, mem_inter_iff, subset'_spec, mem_orderedPairs_iff, op_inj, exists_and_left,\n    exists_eq', and_true]\n\ndef membership : TSet \u03b1 :=\n  subset h\u03b2 h\u03b3 h\u03b4 h\u03b5 \u2293' cross h\u03b2 h\u03b3 h\u03b4 (cardinalOne h\u03b4 h\u03b5) (univ h\u03b4)\n\n@[simp]\ntheorem membership_spec :\n    \u2200 a b, \u27e8{a}', b\u27e9' \u2208' membership h\u03b2 h\u03b3 h\u03b4 h\u03b5 \u2194 a \u2208' b := by\n  intro a b\n  rw [membership, mem_inter_iff, subset_spec]\n  simp only [mem_cross_iff, op_inj, mem_cardinalOne_iff, mem_univ_iff, and_true, exists_and_right,\n    exists_and_left, exists_eq', exists_eq_left', singleton_inj]\n  constructor\n  \u00b7 intro h\n    exact h a ((typedMem_singleton_iff' h\u03b5 a a).mpr rfl)\n  \u00b7 intro h c hc\n    simp only [typedMem_singleton_iff'] at hc\n    cases hc\n    exact h\n\ndef powerset (x : TSet \u03b2) : TSet \u03b1 :=\n  dom lt_higherIndex lt_higherIndex h\u03b2\n    (subset lt_higherIndex lt_higherIndex h\u03b2 h\u03b3 \u2293[lt_higherIndex]\n      vCross lt_higherIndex lt_higherIndex h\u03b2 {x}')\n\n@[simp]\ntheorem mem_powerset_iff (x y : TSet \u03b2) :\n    x \u2208' powerset h\u03b2 h\u03b3 y \u2194 x \u2286[TSet \u03b3] y := by\n  rw [powerset, mem_dom_iff]\n  constructor\n  \u00b7 rintro \u27e8z, h\u27e9\n    simp only [ExternalRel, mem_inter_iff, subset_spec, vCross_spec, op_inj,\n      typedMem_singleton_iff', exists_eq_right, exists_and_right, exists_eq', true_and] at h\n    cases h.2\n    exact h.1\n  \u00b7 intro h\n    refine \u27e8y, ?_\u27e9\n    simp only [ExternalRel, mem_inter_iff, subset_spec, h, vCross_spec, op_inj,\n      typedMem_singleton_iff', exists_eq_right, and_true, exists_eq', and_self]\n\n/-- The set `\u03b9\u00b2''x = {{{a}} | a \u2208 x}`. -/\ndef doubleSingleton (x : TSet \u03b3) : TSet \u03b1 :=\n  cross h\u03b2 h\u03b3 h\u03b4 x x \u2293' cardinalOne h\u03b2 h\u03b3\n\n@[simp]\ntheorem mem_doubleSingleton_iff (x : TSet \u03b3) :\n    \u2200 y : TSet \u03b2, y \u2208' doubleSingleton h\u03b2 h\u03b3 h\u03b4 x \u2194\n    \u2203 z : TSet \u03b4, z \u2208' x \u2227 y = { {z}' }' := by\n  intro y\n  rw [doubleSingleton, mem_inter_iff, mem_cross_iff, mem_cardinalOne_iff]\n  constructor\n  \u00b7 rintro \u27e8\u27e8b, c, h\u2081, h\u2082, h\u2083\u27e9, \u27e8a, rfl\u27e9\u27e9\n    obtain \u27e8hbc, rfl\u27e9 := (op_eq_singleton_iff _ _ _ _ _).mp h\u2081.symm\n    exact \u27e8c, h\u2083, rfl\u27e9\n  \u00b7 rintro \u27e8z, h, rfl\u27e9\n    constructor\n    \u00b7 refine \u27e8z, z, ?_\u27e9\n      rw [eq_comm, op_eq_singleton_iff]\n      tauto\n    \u00b7 exact \u27e8_, rfl\u27e9\n\n/-- The union of a set of *singletons*: `\u03b9\u207b\u00b9''x = {a | {a} \u2208 x}`. -/\ndef singletonUnion (x : TSet \u03b1) : TSet \u03b2 :=\n  typeLower lt_higherIndex lt_higherIndex h\u03b2 h\u03b3\n    (vCross lt_higherIndex lt_higherIndex h\u03b2 x)\n\n@[simp]\ntheorem mem_singletonUnion_iff (x : TSet \u03b1) :\n    \u2200 y : TSet \u03b3, y \u2208' singletonUnion h\u03b2 h\u03b3 x \u2194 {y}' \u2208' x := by\n  intro y\n  simp only [singletonUnion, mem_typeLower_iff, vCross_spec, op_inj]\n  constructor\n  \u00b7 intro h\n    obtain \u27e8a, b, \u27e8rfl, rfl\u27e9, hy\u27e9 := h {y}'\n    exact hy\n  \u00b7 intro h b\n    exact \u27e8b, _, \u27e8rfl, rfl\u27e9, h\u27e9\n\n/--\nThe union of a set of sets.\n\n```\nsingletonUnion dom {\u27e8{a}, b\u27e9 | a \u2208 b} \u2229 (1 \u00d7 x) =\nsingletonUnion dom {\u27e8{a}, b\u27e9 | a \u2208 b \u2227 b \u2208 x} =\nsingletonUnion {{a} | a \u2208 b \u2227 b \u2208 x} =\n{a | a \u2208 b \u2227 b \u2208 x} =\n\u22c3 x\n```\n-/\ndef sUnion (x : TSet \u03b1) : TSet \u03b2 :=\n  singletonUnion h\u03b2 h\u03b3\n    (dom lt_higherIndex lt_higherIndex h\u03b2\n      (membership lt_higherIndex lt_higherIndex h\u03b2 h\u03b3 \u2293[lt_higherIndex]\n        cross lt_higherIndex lt_higherIndex h\u03b2 (cardinalOne h\u03b2 h\u03b3) x))\n\n@[simp]\ntheorem mem_sUnion_iff (x : TSet \u03b1) :\n    \u2200 y : TSet \u03b3, y \u2208' sUnion h\u03b2 h\u03b3 x \u2194 \u2203 t : TSet \u03b2, t \u2208' x \u2227 y \u2208' t := by\n  intro y\n  simp only [sUnion, mem_singletonUnion_iff, mem_dom_iff, Rel.dom, ExternalRel, mem_inter_iff,\n    mem_cross_iff, op_inj, mem_cardinalOne_iff, Set.mem_setOf_eq, membership_spec]\n  constructor\n  \u00b7 rintro \u27e8z, h\u2081, a, b, \u27e8rfl, rfl\u27e9, \u27e8c, h\u2082\u27e9, h\u2083\u27e9\n    rw [singleton_inj] at h\u2082\n    cases h\u2082\n    exact \u27e8z, h\u2083, h\u2081\u27e9\n  \u00b7 rintro \u27e8z, h\u2082, h\u2083\u27e9\n    exact \u27e8z, h\u2083, _, _, \u27e8rfl, rfl\u27e9, \u27e8y, rfl\u27e9, h\u2082\u27e9\n\n", "theoremStatement": "theorem exists_smallUnion (s : Set (TSet \u03b1)) (hs : Small s) :\n    \u2203 x : TSet \u03b1, \u2200 y : TSet \u03b2, y \u2208' x \u2194 \u2203 t \u2208 s, y \u2208' t ", "theoremName": "ConNF.exists_smallUnion", "fileCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "theoremCreated": {"commit": "6dd8406a01cc28b071bb26965294469664a1b592", "date": "2025-01-07"}, "file": "ConNF/ConNF/External/Basic.lean", "module": "ConNF.External.Basic", "jsonFile": "ConNF.External.Basic.jsonl", "positionMetadata": {"lineInFile": 290, "tokenPositionInFile": 9052, "theoremPositionInFile": 40}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 57, "numPremises": 114}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  apply exists_of_symmetric\n  have := exists_support (\u03b1 := \u03b1)\n  choose S hS using this\n  refine \u27e8\u27e8Enumeration.ofSet (\u22c3 t \u2208 s, (S t)\u1d2c) ?_, Enumeration.ofSet (\u22c3 t \u2208 s, (S t)\u1d3a) ?_\u27e9, ?_\u27e9\n  \u00b7 apply small_biUnion hs\n    intros\n    exact (S _)\u1d2c.coe_small\n  \u00b7 apply small_biUnion hs\n    intros\n    exact (S _)\u1d3a.coe_small\n  intro \u03c1 h\u03c1\n  suffices \u2200 t \u2208 s, \u03c1 \u2022 t = t by\n    ext y\n    rw [Set.mem_smul_set_iff_inv_smul_mem]\n    constructor\n    \u00b7 rintro \u27e8t, h\u2081, h\u2082\u27e9\n      refine \u27e8t, h\u2081, ?_\u27e9\n      rw [\u2190 this t h\u2081]\n      rwa [mem_smul_iff', allPerm_inv_sderiv']\n    \u00b7 rintro \u27e8t, h\u2081, h\u2082\u27e9\n      refine \u27e8t, h\u2081, ?_\u27e9\n      have := this t h\u2081\n      rw [smul_eq_iff_eq_inv_smul] at this\n      rwa [this, mem_smul_iff', inv_inv, smul_inv_smul]\n  intro t ht\n  apply (hS t).supports \u03c1\n  refine smul_eq_of_le ?_ h\u03c1\n  intro A\n  constructor\n  \u00b7 intro a ha\n    rw [\u2190 Support.derivBot_atoms, Support.mk_atoms, \u2190 Enumeration.mem_path_iff,\n      Enumeration.mem_ofSet_iff, Set.mem_iUnion]\n    use t\n    rw [Set.mem_iUnion]\n    use ht\n    exact ha\n  \u00b7 intro a ha\n    rw [\u2190 Support.derivBot_nearLitters, Support.mk_nearLitters, \u2190 Enumeration.mem_path_iff,\n      Enumeration.mem_ofSet_iff, Set.mem_iUnion]\n    use t\n    rw [Set.mem_iUnion]\n    use ht\n    exact ha", "proofType": "tactic", "proofLengthLines": 43, "proofLengthTokens": 1234}}
{"srcContext": "import ConNF.External.Basic\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal ConNF.TSet\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\n/-- A set in our model that is a well-order. Internal well-orders are exactly external well-orders,\nso we externalise the definition for convenience. -/\ndef InternalWellOrder (r : TSet \u03b1) : Prop :=\n  IsWellOrder (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).field\n    (InvImage (ExternalRel h\u03b2 h\u03b3 h\u03b4 r) Subtype.val)\n\ndef InternallyWellOrdered (x : TSet \u03b3) : Prop :=\n  {y : TSet \u03b4 | y \u2208' x}.Subsingleton \u2228 (\u2203 r, InternalWellOrder h\u03b2 h\u03b3 h\u03b4 r \u2227 x = field h\u03b2 h\u03b3 h\u03b4 r)\n\n@[simp]\ntheorem externalRel_smul (r : TSet \u03b1) (\u03c1 : AllPerm \u03b1) :\n    ExternalRel h\u03b2 h\u03b3 h\u03b4 (\u03c1 \u2022 r) =\n      InvImage (ExternalRel h\u03b2 h\u03b3 h\u03b4 r) ((\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4)\u207b\u00b9 \u2022 \u00b7) := by\n  ext a b\n  simp only [ExternalRel, mem_smul_iff', allPerm_inv_sderiv', smul_op, InvImage]\n\nomit [Params] in\n/-- Well-orders are rigid. -/\ntheorem apply_eq_of_isWellOrder {X : Type _} {r : Rel X X} {f : X \u2192 X}\n    (hr : IsWellOrder X r) (hf : Function.Bijective f) (hf' : \u2200 x y, r x y \u2194 r (f x) (f y)) :\n    \u2200 x, f x = x := by\n  let emb : r \u227ci r := \u27e8\u27e8\u27e8f, hf.injective\u27e9, \u03bb {a b} \u21a6 (hf' a b).symm\u27e9, ?_\u27e9\n  \u00b7 have : emb = InitialSeg.refl r := Subsingleton.elim _ _\n    intro x\n    exact congr_arg (\u03bb f \u21a6 f x) this\n  \u00b7 intro a b h\n    exact hf.surjective _\n\nomit [Params] in\ntheorem apply_eq_of_isWellOrder' {X : Type _} {r : Rel X X} {f : X \u2192 X}\n    (hr : IsWellOrder r.field (InvImage r Subtype.val)) (hf : Function.Bijective f)\n    (hf' : \u2200 x y, r x y \u2194 r (f x) (f y)) :\n    \u2200 x \u2208 r.field, f x = x := by\n  have : \u2200 x \u2208 r.field, f x \u2208 r.field := by\n    rintro x (\u27e8y, h\u27e9 | \u27e8y, h\u27e9)\n    \u00b7 exact Or.inl \u27e8f y, (hf' x y).mp h\u27e9\n    \u00b7 exact Or.inr \u27e8f y, (hf' y x).mp h\u27e9\n  have := apply_eq_of_isWellOrder (f := \u03bb x \u21a6 \u27e8f x.val, this x.val x.prop\u27e9) hr \u27e8?_, ?_\u27e9 ?_\n  \u00b7 intro x hx\n    exact congr_arg Subtype.val (this \u27e8x, hx\u27e9)\n  \u00b7 intro x y h\n    rw [Subtype.mk.injEq] at h\n    exact Subtype.val_injective (hf.injective h)\n  \u00b7 intro x\n    obtain \u27e8y, hy\u27e9 := hf.surjective x.val\n    refine \u27e8\u27e8y, ?_\u27e9, ?_\u27e9\n    \u00b7 obtain (\u27e8z, h\u27e9 | \u27e8z, h\u27e9) := x.prop <;>\n          rw [\u2190 hy] at h <;>\n          obtain \u27e8z, rfl\u27e9 := hf.surjective z\n      \u00b7 exact Or.inl \u27e8z, (hf' y z).mpr h\u27e9\n      \u00b7 exact Or.inr \u27e8z, (hf' z y).mpr h\u27e9\n    \u00b7 simp only [hy]\n  \u00b7 intros\n    apply hf'\n\ntheorem exists_common_support_of_internallyWellOrdered' {x : TSet \u03b4}\n    (h : InternallyWellOrdered h\u03b3 h\u03b4 h\u03b5 x) :\n    \u2203 S : Support \u03b2, \u2200 y, y \u2208' x \u2192 S.Supports { { {y}' }' }[h\u03b3] := by\n  obtain (h | \u27e8r, h, rfl\u27e9) := h\n  \u00b7 obtain (h | \u27e8y, hy\u27e9) := h.eq_empty_or_singleton\n    \u00b7 use \u27e8Enumeration.empty, Enumeration.empty\u27e9\n      intro y hy\n      rw [Set.eq_empty_iff_forall_not_mem] at h\n      cases h y hy\n    \u00b7 obtain \u27e8S, hS\u27e9 := TSet.exists_support y\n      use S \u2197 h\u03b5 \u2197 h\u03b4 \u2197 h\u03b3\n      intro z hz\n      rw [Set.eq_singleton_iff_unique_mem] at hy\n      cases hy.2 z hz\n      refine \u27e8?_, \u03bb h \u21a6 by cases h\u27e9\n      intro \u03c1 h\u03c1\n      simp only [Support.smul_scoderiv, \u2190 allPermSderiv_forget', Support.scoderiv_inj] at h\u03c1\n      simp only [smul_singleton, singleton_inj]\n      exact hS _ h\u03c1\n  obtain \u27e8S, hS\u27e9 := TSet.exists_support r\n  use S\n  intro a ha\n  refine \u27e8?_, \u03bb h \u21a6 by cases h\u27e9\n  intro \u03c1 h\u03c1\n  have := hS \u03c1 h\u03c1\n  simp only [smul_singleton, singleton_inj]\n  apply apply_eq_of_isWellOrder' (r := ExternalRel h\u03b3 h\u03b4 h\u03b5 r)\n  \u00b7 exact h\n  \u00b7 exact MulAction.bijective (\u03c1 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5)\n  \u00b7 intro x y\n    conv_rhs => rw [\u2190 this]\n    simp only [externalRel_smul, InvImage, inv_smul_smul]\n  \u00b7 rwa [mem_field_iff] at ha\n\ninclude h\u03b3 in\ntheorem Support.Supports.ofSingleton {S : Support \u03b1} {x : TSet \u03b2}\n    (h : S.Supports {x}') :\n    letI : Level := \u27e8\u03b1\u27e9\n    letI : LeLevel \u03b1 := \u27e8le_rfl\u27e9\n    (S.strong \u2198 h\u03b2).Supports x := by\n  refine \u27e8?_, \u03bb h \u21a6 by cases h\u27e9\n  intro \u03c1 h\u03c1\n  open scoped Pointwise in\n  have := sUnion_singleton_symmetric_aux h\u03b3 h\u03b2 {y | y \u2208' x} S ?_ \u03c1 h\u03c1\n  \u00b7 apply ConNF.ext h\u03b3\n    intro z\n    simp only [Set.ext_iff, Set.mem_setOf_eq, Set.mem_smul_set_iff_inv_smul_mem] at this\n    rw [mem_smul_iff', allPerm_inv_sderiv', this]\n  \u00b7 intro \u03c1 h\u03c1\n    ext z\n    simp only [Set.mem_smul_set_iff_inv_smul_mem, Set.mem_image, Set.mem_setOf_eq]\n    have := h.supports \u03c1 h\u03c1\n    simp only [smul_singleton, singleton_inj] at this\n    constructor\n    \u00b7 rintro \u27e8y, h\u2081, h\u2082\u27e9\n      rw [\u2190 smul_eq_iff_eq_inv_smul, smul_singleton] at h\u2082\n      refine \u27e8_, ?_, h\u2082\u27e9\n      rw [\u2190 this]\n      simp only [mem_smul_iff', allPerm_inv_sderiv', inv_smul_smul]\n      exact h\u2081\n    \u00b7 rintro \u27e8y, h, rfl\u27e9\n      refine \u27e8(\u03c1 \u2198 h\u03b2 \u2198 h\u03b3)\u207b\u00b9 \u2022 y, ?_, ?_\u27e9\n      \u00b7 rwa [\u2190 allPerm_inv_sderiv', \u2190 mem_smul_iff', this]\n      \u00b7 simp only [smul_singleton, allPerm_inv_sderiv']\n\ninclude h\u03b3 in\n", "theoremStatement": "theorem supports_of_supports_singletons {S : Support \u03b1} {s : Set (TSet \u03b2)}\n    (h : \u2200 x \u2208 s, S.Supports {x}') :\n    \u2203 S : Support \u03b2, \u2200 x \u2208 s, S.Supports x ", "theoremName": "ConNF.supports_of_supports_singletons", "fileCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "theoremCreated": {"commit": "1c08486feb882444888c228ce1501e92bb85e0e2", "date": "2025-01-07"}, "file": "ConNF/ConNF/External/WellOrder.lean", "module": "ConNF.External.WellOrder", "jsonFile": "ConNF.External.WellOrder.jsonl", "positionMetadata": {"lineInFile": 144, "tokenPositionInFile": 4867, "theoremPositionInFile": 7}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 20, "numPremises": 36}, "proofMetadata": {"hasProof": true, "proof": ":=\n  \u27e8_, \u03bb x hx \u21a6 (h x hx).ofSingleton h\u03b2 h\u03b3\u27e9", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 45}}
{"srcContext": "import ConNF.Base.TypeIndex\n\n/-!\n# Paths of type indices\n\nIn this file, we define the notion of a *path*, and the derivative and coderivative operations.\n\n## Main declarations\n\n* `ConNF.Path`: A path of type indices.\n* `ConNF.Path.recSderiv`, `ConNF.Path.recSderivLe`, `ConNF.Path.recSderivGlobal`:\n    Downwards induction principles for paths.\n* `ConNF.Path.recScoderiv`: An upwards induction principle for paths.\n-/\n\nuniverse u\n\nopen Cardinal WithBot\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 : TypeIndex}\n\n/-- A path of type indices starting at `\u03b1` and ending at `\u03b2` is a finite sequence of type indices\n`\u03b1 > ... > \u03b2`. -/\ninductive Path (\u03b1 : TypeIndex) : TypeIndex \u2192 Type u\n  | nil : Path \u03b1 \u03b1\n  | cons {\u03b2 \u03b3 : TypeIndex} : Path \u03b1 \u03b2 \u2192 \u03b3 < \u03b2 \u2192 Path \u03b1 \u03b3\n\n@[inherit_doc] infix:70 \" \u219d \"  => Path\n\ndef Path.single {\u03b1 \u03b2 : TypeIndex} (h : \u03b2 < \u03b1) : \u03b1 \u219d \u03b2 :=\n  .cons .nil h\n\n/-- Typeclass for the `\u2198` notation. -/\nclass SingleDerivative (X : Type _) (Y : outParam <| Type _)\n    (\u03b2 : outParam TypeIndex) (\u03b3 : TypeIndex) where\n  sderiv : X \u2192 \u03b3 < \u03b2 \u2192 Y\n\n/-- Typeclass for the `\u21d8` notation. -/\nclass Derivative (X : Type _) (Y : outParam <| Type _)\n    (\u03b2 : outParam TypeIndex) (\u03b3 : TypeIndex) extends SingleDerivative X Y \u03b2 \u03b3 where\n  deriv : X \u2192 \u03b2 \u219d \u03b3 \u2192 Y\n  sderiv x h := deriv x (.single h)\n  deriv_single : \u2200 x : X, \u2200 h : \u03b3 < \u03b2, deriv x (.single h) = sderiv x h := by intros; rfl\n\n/-- Typeclass for the `\u2198.` notation. -/\nclass BotSingleDerivative (X : Type _) (Y : outParam <| Type _) where\n  botSderiv : X \u2192 Y\n\n/-- Typeclass for the `\u21d8.` notation. -/\nclass BotDerivative (X : Type _) (Y : outParam <| Type _) (\u03b2 : outParam TypeIndex)\n    extends BotSingleDerivative X Y where\n  botDeriv : X \u2192 \u03b2 \u219d \u22a5 \u2192 Y\n  /-- We often need to do case analysis on `\u03b2` to show that it's a proper type index here.\n  This case check doesn't need to be done in most actual use cases of the notation. -/\n  botDeriv_single : \u2200 x : X, \u2200 h : \u22a5 < \u03b2, botDeriv x (.single h) = botSderiv x\n\n/-- Typeclass for the `\u2197` notation. -/\nclass SingleCoderivative (X : Type _) (Y : outParam <| Type _)\n    (\u03b2 : TypeIndex) (\u03b3 : outParam TypeIndex) where\n  scoderiv : X \u2192 \u03b3 < \u03b2 \u2192 Y\n\n/-- Typeclass for the `\u21d7` notation. -/\nclass Coderivative (X : Type _) (Y : outParam <| Type _)\n    (\u03b2 : TypeIndex) (\u03b3 : outParam TypeIndex) extends SingleCoderivative X Y \u03b2 \u03b3 where\n  coderiv : X \u2192 \u03b2 \u219d \u03b3 \u2192 Y\n  scoderiv x h := coderiv x (.single h)\n  coderiv_single : \u2200 x : X, \u2200 h : \u03b3 < \u03b2, coderiv x (.single h) = scoderiv x h := by intros; rfl\n\ninfixl:75 \" \u2198 \" => SingleDerivative.sderiv\ninfixl:75 \" \u21d8 \" => Derivative.deriv\npostfix:75 \" \u2198.\" => BotSingleDerivative.botSderiv\ninfixl:75 \" \u21d8. \" => BotDerivative.botDeriv\ninfixl:75 \" \u2197 \" => SingleCoderivative.scoderiv\ninfixl:75 \" \u21d7 \" => Coderivative.coderiv\n\n@[simp]\ntheorem deriv_single {X Y : Type _} [Derivative X Y \u03b2 \u03b3] (x : X) (h : \u03b3 < \u03b2) :\n    x \u21d8 .single h = x \u2198 h :=\n  Derivative.deriv_single x h\n\n@[simp]\ntheorem coderiv_single {X Y : Type _} [Coderivative X Y \u03b2 \u03b3] (x : X) (h : \u03b3 < \u03b2) :\n    x \u21d7 .single h = x \u2197 h :=\n  Coderivative.coderiv_single x h\n\n@[simp]\ntheorem botDeriv_single {X Y : Type _} [BotDerivative X Y \u03b2] (x : X) (h : \u22a5 < \u03b2) :\n    x \u21d8. .single h = x \u2198. :=\n  BotDerivative.botDeriv_single x h\n\n/-!\n## Downwards recursion along paths\n-/\n\ninstance : SingleDerivative (\u03b1 \u219d \u03b2) (\u03b1 \u219d \u03b3) \u03b2 \u03b3 where\n  sderiv := .cons\n\n/-- The downwards recursion principle for paths. -/\n@[elab_as_elim, induction_eliminator, cases_eliminator]\ndef Path.recSderiv {motive : \u2200 \u03b2, \u03b1 \u219d \u03b2 \u2192 Sort _}\n    (nil : motive \u03b1 .nil)\n    (sderiv : \u2200 \u03b2 \u03b3 (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2), motive \u03b2 A \u2192 motive \u03b3 (A \u2198 h)) :\n    {\u03b2 : TypeIndex} \u2192 (A : \u03b1 \u219d \u03b2) \u2192 motive \u03b2 A\n  | _, .nil => nil\n  | _, .cons A h => sderiv _ _ A h (recSderiv nil sderiv A)\n\n@[simp]\ntheorem Path.recSderiv_nil {motive : \u2200 \u03b2, \u03b1 \u219d \u03b2 \u2192 Sort _}\n    (nil : motive \u03b1 .nil)\n    (sderiv : \u2200 \u03b2 \u03b3 (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2), motive \u03b2 A \u2192 motive \u03b3 (A \u2198 h)) :\n    recSderiv (motive := motive) nil sderiv .nil = nil :=\n  rfl\n\n@[simp]\ntheorem Path.recSderiv_sderiv {motive : \u2200 \u03b2, \u03b1 \u219d \u03b2 \u2192 Sort _}\n    (nil : motive \u03b1 .nil)\n    (sderiv : \u2200 \u03b2 \u03b3 (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2), motive \u03b2 A \u2192 motive \u03b3 (A \u2198 h))\n    {\u03b2 \u03b3 : TypeIndex} (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2) :\n    recSderiv (motive := motive) nil sderiv (A \u2198 h) = sderiv \u03b2 \u03b3 A h (recSderiv nil sderiv A) :=\n  rfl\n\ntheorem Path.le (A : \u03b1 \u219d \u03b2) : \u03b2 \u2264 \u03b1 := by\n  induction A with\n  | nil => exact le_rfl\n  | sderiv \u03b2 \u03b3 _A h h' => exact h.le.trans h'\n\n/-- The downwards recursion principle for paths, specialised to the case where the motive at `\u03b2`\nonly depends on the fact that `\u03b2 \u2264 \u03b1`. -/\ndef Path.recSderivLe {motive : \u2200 \u03b2 \u2264 \u03b1, Sort _}\n    (nil : motive \u03b1 le_rfl)\n    (sderiv : \u2200 \u03b2 \u03b3, \u2200 (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2), motive \u03b2 A.le \u2192 motive \u03b3 (h.le.trans A.le)) :\n    {\u03b2 : TypeIndex} \u2192 (A : \u03b1 \u219d \u03b2) \u2192 motive \u03b2 A.le :=\n  Path.recSderiv (motive := \u03bb \u03b2 A \u21a6 motive \u03b2 A.le) nil sderiv\n\n@[simp]\ntheorem Path.recSderivLe_nil {motive : \u2200 \u03b2 \u2264 \u03b1, Sort _}\n    (nil : motive \u03b1 le_rfl)\n    (sderiv : \u2200 \u03b2 \u03b3 (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2), motive \u03b2 A.le \u2192 motive \u03b3 (h.le.trans A.le)) :\n    recSderivLe (motive := motive) nil sderiv .nil = nil :=\n  rfl\n\n@[simp]\ntheorem Path.recSderivLe_sderiv {motive : \u2200 \u03b2 \u2264 \u03b1, Sort _}\n    (nil : motive \u03b1 le_rfl)\n    (sderiv : \u2200 \u03b2 \u03b3 (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2), motive \u03b2 A.le \u2192 motive \u03b3 (h.le.trans A.le))\n    {\u03b2 \u03b3 : TypeIndex} (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2) :\n    recSderivLe (motive := motive) nil sderiv (A \u2198 h) = sderiv \u03b2 \u03b3 A h (recSderiv nil sderiv A) :=\n  rfl\n\n/-- The downwards recursion principle for paths, specialised to the case where the motive is not\ndependent on the relation of `\u03b2` to `\u03b1`. -/\n@[elab_as_elim]\ndef Path.recSderivGlobal {motive : TypeIndex \u2192 Sort _}\n    (nil : motive \u03b1)\n    (sderiv : \u2200 \u03b2 \u03b3, \u03b1 \u219d \u03b2 \u2192 \u03b3 < \u03b2 \u2192 motive \u03b2 \u2192 motive \u03b3) :\n    {\u03b2 : TypeIndex} \u2192 \u03b1 \u219d \u03b2 \u2192 motive \u03b2 :=\n  Path.recSderiv (motive := \u03bb \u03b2 _ \u21a6 motive \u03b2) nil sderiv\n\n@[simp]\ntheorem Path.recSderivGlobal_nil {motive : TypeIndex \u2192 Sort _}\n    (nil : motive \u03b1)\n    (sderiv : \u2200 \u03b2 \u03b3, \u03b1 \u219d \u03b2 \u2192 \u03b3 < \u03b2 \u2192 motive \u03b2 \u2192 motive \u03b3) :\n    recSderivGlobal (motive := motive) nil sderiv .nil = nil :=\n  rfl\n\n@[simp]\ntheorem Path.recSderivGlobal_sderiv {motive : TypeIndex \u2192 Sort _}\n    (nil : motive \u03b1)\n    (sderiv : \u2200 \u03b2 \u03b3, \u03b1 \u219d \u03b2 \u2192 \u03b3 < \u03b2 \u2192 motive \u03b2 \u2192 motive \u03b3)\n    {\u03b2 \u03b3 : TypeIndex} (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2) :\n    recSderivGlobal (motive := motive) nil sderiv (A \u2198 h) =\n      sderiv \u03b2 \u03b3 A h (recSderiv nil sderiv A) :=\n  rfl\n\n/-!\n## Derivatives of paths\n-/\n\ninstance : Derivative (\u03b1 \u219d \u03b2) (\u03b1 \u219d \u03b3) \u03b2 \u03b3 where\n  deriv A := Path.recSderivGlobal A (\u03bb _ _ _ h B \u21a6 B \u2198 h)\n\ninstance : BotDerivative (\u03b1 \u219d \u03b2) (\u03b1 \u219d \u22a5) \u03b2 where\n  botDeriv A B := A \u21d8 B\n  botSderiv A :=\n    match \u03b2 with\n      | \u22a5 => A\n      | (\u03b2 : \u039b) => A \u2198 bot_lt_coe \u03b2\n  botDeriv_single A h := by\n    cases \u03b2 using WithBot.recBotCoe with\n    | bot => cases lt_irrefl \u22a5 h\n    | coe => rfl\n\ninstance : Coderivative (\u03b2 \u219d \u03b3) (\u03b1 \u219d \u03b3) \u03b1 \u03b2 where\n  coderiv A B := B \u21d8 A\n\n@[simp]\ntheorem Path.deriv_nil (A : \u03b1 \u219d \u03b2) :\n    A \u21d8 .nil = A :=\n  rfl\n\n@[simp]\ntheorem Path.deriv_sderiv (A : \u03b1 \u219d \u03b2) (B : \u03b2 \u219d \u03b3) (h : \u03b4 < \u03b3) :\n    A \u21d8 (B \u2198 h) = A \u21d8 B \u2198 h :=\n  rfl\n\n@[simp]\ntheorem Path.nil_deriv (A : \u03b1 \u219d \u03b2) :\n    (.nil : \u03b1 \u219d \u03b1) \u21d8 A = A := by\n  induction A with\n  | nil => rfl\n  | sderiv \u03b3 \u03b4 A h ih => rw [deriv_sderiv, ih]\n\n@[simp]\ntheorem Path.deriv_sderivBot (A : \u03b1 \u219d \u03b2) (B : \u03b2 \u219d \u03b3) :\n    A \u21d8 (B \u2198.) = A \u21d8 B \u2198. := by\n  cases \u03b3 using WithBot.recBotCoe with\n  | bot => rfl\n  | coe => rfl\n\n@[simp]\ntheorem Path.botSderiv_bot_eq (A : \u03b1 \u219d \u22a5) :\n    A \u2198. = A :=\n  rfl\n\n@[simp]\ntheorem Path.botSderiv_coe_eq {\u03b2 : \u039b} (A : \u03b1 \u219d \u03b2) :\n    A \u2198 bot_lt_coe \u03b2 = A \u2198. :=\n  rfl\n\n@[simp]\ntheorem Path.deriv_assoc (A : \u03b1 \u219d \u03b2) (B : \u03b2 \u219d \u03b3) (C : \u03b3 \u219d \u03b4) :\n    A \u21d8 (B \u21d8 C) = A \u21d8 B \u21d8 C := by\n  induction C with\n  | nil => rfl\n  | sderiv \u03b5 \u03b6 C h ih => simp only [deriv_sderiv, ih]\n\n@[simp]\ntheorem Path.deriv_sderiv_assoc (A : \u03b1 \u219d \u03b2) (B : \u03b2 \u219d \u03b3) (h : \u03b4 < \u03b3) :\n    A \u21d8 (B \u2198 h) = A \u21d8 B \u2198 h :=\n  rfl\n\n@[simp]\ntheorem Path.deriv_scoderiv (A : \u03b1 \u219d \u03b2) (B : \u03b3 \u219d \u03b4) (h : \u03b3 < \u03b2) :\n    A \u21d8 (B \u2197 h) = A \u2198 h \u21d8 B := by\n  induction B with\n  | nil => rfl\n  | sderiv \u03b5 \u03b6 B h' ih =>\n    rw [deriv_sderiv, \u2190 ih]\n    rfl\n\n@[simp]\ntheorem Path.botDeriv_scoderiv (A : \u03b1 \u219d \u03b2) (B : \u03b3 \u219d \u22a5) (h : \u03b3 < \u03b2) :\n    A \u21d8. (B \u2197 h) = A \u2198 h \u21d8. B :=\n  deriv_scoderiv A B h\n\ntheorem Path.coderiv_eq_deriv (A : \u03b1 \u219d \u03b2) (B : \u03b2 \u219d \u03b3) :\n    B \u21d7 A = A \u21d8 B :=\n  rfl\n\ntheorem Path.coderiv_deriv (A : \u03b2 \u219d \u03b3) (h\u2081 : \u03b2 < \u03b1) (h\u2082 : \u03b4 < \u03b3) :\n    A \u2197 h\u2081 \u2198 h\u2082 = A \u2198 h\u2082 \u2197 h\u2081 :=\n  rfl\n\n", "theoremStatement": "theorem Path.coderiv_deriv' (A : \u03b2 \u219d \u03b3) (h : \u03b2 < \u03b1) (B : \u03b3 \u219d \u03b4) :\n    A \u2197 h \u21d8 B = A \u21d8 B \u2197 h ", "theoremName": "ConNF.Path.coderiv_deriv'", "fileCreated": {"commit": "8896e416a16c39e1fe487b5fc7c78bc20c4e182b", "date": "2024-12-03"}, "theoremCreated": {"commit": "ce890707e37ede74a2fcd66134d3f403335c5cc1", "date": "2024-11-30"}, "file": "ConNF/ConNF/Levels/Path.lean", "module": "ConNF.Levels.Path", "jsonFile": "ConNF.Levels.Path.jsonl", "positionMetadata": {"lineInFile": 266, "tokenPositionInFile": 8358, "theoremPositionInFile": 32}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 11, "repositoryPremises": true, "numRepositoryPremises": 16, "numPremises": 29}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  induction B with\n  | nil => rfl\n  | sderiv \u03b5 \u03b6 B h' ih =>\n    rw [deriv_sderiv, ih]\n    rfl", "proofType": "tactic", "proofLengthLines": 5, "proofLengthTokens": 99}}
{"srcContext": "import ConNF.Model.RaiseStrong\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nopen scoped Pointwise\n\nnamespace ConNF\n\nvariable [Params.{u}]\n\n/-- A redefinition of the derivative of allowable permutations that is invariant of level,\nbut still has nice definitional properties. -/\n@[default_instance 200]\ninstance {\u03b2 \u03b3 : TypeIndex} : Derivative (AllPerm \u03b2) (AllPerm \u03b3) \u03b2 \u03b3 where\n  deriv \u03c1 A :=\n    A.recSderiv\n    (motive := \u03bb (\u03b4 : TypeIndex) (A : \u03b2 \u219d \u03b4) \u21a6\n      letI : Level := \u27e8\u03b4.recBotCoe (Nonempty.some inferInstance) id\u27e9\n      letI : LeLevel \u03b4 := \u27e8\u03b4.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n        (show \u03b4.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n      AllPerm \u03b4)\n    \u03c1 (\u03bb \u03b4 \u03b5 A h \u03c1 \u21a6\n      letI : Level := \u27e8\u03b4.recBotCoe (Nonempty.some inferInstance) id\u27e9\n      letI : LeLevel \u03b4 := \u27e8\u03b4.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n        (show \u03b4.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n      letI : LeLevel \u03b5 := \u27e8h.le.trans LeLevel.elim\u27e9\n      PreCoherentData.allPermSderiv h \u03c1)\n\n@[simp]\ntheorem allPerm_deriv_nil' {\u03b2 : TypeIndex}\n    (\u03c1 : AllPerm \u03b2) :\n    \u03c1 \u21d8 (.nil : \u03b2 \u219d \u03b2) = \u03c1 :=\n  rfl\n\n@[simp]\ntheorem allPerm_deriv_sderiv' {\u03b2 \u03b3 \u03b4 : TypeIndex}\n    (\u03c1 : AllPerm \u03b2) (A : \u03b2 \u219d \u03b3) (h : \u03b4 < \u03b3) :\n    \u03c1 \u21d8 (A \u2198 h) = \u03c1 \u21d8 A \u2198 h :=\n  rfl\n\n@[simp]\ntheorem allPermSderiv_forget' {\u03b2 \u03b3 : TypeIndex} (h : \u03b3 < \u03b2) (\u03c1 : AllPerm \u03b2) :\n    (\u03c1 \u2198 h)\u1d41 = \u03c1\u1d41 \u2198 h :=\n  letI : Level := \u27e8\u03b2.recBotCoe (Nonempty.some inferInstance) id\u27e9\n  letI : LeLevel \u03b2 := \u27e8\u03b2.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n    (show \u03b2.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n  letI : LeLevel \u03b3 := \u27e8h.le.trans LeLevel.elim\u27e9\n  allPermSderiv_forget h \u03c1\n\n@[simp]\ntheorem allPerm_inv_sderiv' {\u03b2 \u03b3 : TypeIndex} (h : \u03b3 < \u03b2) (\u03c1 : AllPerm \u03b2) :\n    \u03c1\u207b\u00b9 \u2198 h = (\u03c1 \u2198 h)\u207b\u00b9 := by\n  apply allPermForget_injective\n  rw [allPermSderiv_forget', allPermForget_inv, Tree.inv_sderiv, allPermForget_inv,\n    allPermSderiv_forget']\n\ndef Symmetric {\u03b1 \u03b2 : \u039b} (s : Set (TSet \u03b2)) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) : Prop :=\n  \u2203 S : Support \u03b1, \u2200 \u03c1 : AllPerm \u03b1, \u03c1\u1d41 \u2022 S = S \u2192 \u03c1 \u2198 h\u03b2 \u2022 s = s\n\ndef newSetEquiv {\u03b1 : \u039b} :\n    letI : Level := \u27e8\u03b1\u27e9\n    @TSet _ \u03b1 newModelData.toPreModelData \u2243 TSet \u03b1 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castTSet (D\u2081 := newModelData) (D\u2082 := globalModelData) rfl\n    (by rw [globalModelData, motive_eq, constructMotive, globalLtData_eq])\n\n@[simp]\ntheorem newSetEquiv_forget {\u03b1 : \u039b}\n    (x : letI : Level := \u27e8\u03b1\u27e9; @TSet _ \u03b1 newModelData.toPreModelData) :\n    (newSetEquiv x)\u1d41 = x\u1d41 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castTSet_forget (D\u2081 := newModelData) (D\u2082 := globalModelData) _ x\n\ndef allPermEquiv {\u03b1 : \u039b} :\n    letI : Level := \u27e8\u03b1\u27e9\n    NewPerm \u2243 AllPerm \u03b1 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castAllPerm (D\u2081 := newModelData) (D\u2082 := globalModelData) rfl\n    (by rw [globalModelData, motive_eq, constructMotive, globalLtData_eq])\n\n@[simp]\ntheorem allPermEquiv_forget {\u03b1 : \u039b} (\u03c1 : letI : Level := \u27e8\u03b1\u27e9; NewPerm) :\n    (allPermEquiv \u03c1)\u1d41 = \u03c1\u1d41 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castAllPerm_forget (D\u2081 := newModelData) (D\u2082 := globalModelData) _ \u03c1\n\ntheorem allPermEquiv_sderiv {\u03b1 \u03b2 : \u039b}\n    (\u03c1 : letI : Level := \u27e8\u03b1\u27e9; NewPerm) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) :\n    letI : Level := \u27e8\u03b1\u27e9\n    letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n    allPermEquiv \u03c1 \u2198 h\u03b2 = \u03c1.sderiv \u03b2 := by\n  letI : Level := \u27e8\u03b1\u27e9\n  letI : LeLevel \u03b1 := \u27e8le_rfl\u27e9\n  letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n  apply allPermForget_injective\n  rw [allPermSderiv_forget, allPermEquiv_forget, NewPerm.forget_sderiv]\n\ntheorem TSet.exists_of_symmetric {\u03b1 \u03b2 : \u039b} (s : Set (TSet \u03b2)) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1)\n    (hs : Symmetric s h\u03b2) :\n    \u2203 x : TSet \u03b1, \u2200 y : TSet \u03b2, y \u2208[h\u03b2] x \u2194 y \u2208 s := by\n  letI : Level := \u27e8\u03b1\u27e9\n  letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n  suffices \u2203 x : (@TSet _ \u03b1 newModelData.toPreModelData), \u2200 y : TSet \u03b2, y\u1d41 \u2208[h\u03b2] x\u1d41 \u2194 y \u2208 s by\n    obtain \u27e8x, hx\u27e9 := this\n    use newSetEquiv x\n    intro y\n    rw [\u2190 hx, \u2190 TSet.forget_mem_forget, newSetEquiv_forget]\n  obtain rfl | hs' := s.eq_empty_or_nonempty\n  \u00b7 use none\n    intro y\n    simp only [Set.mem_empty_iff_false, iff_false]\n    exact not_mem_none y\n  \u00b7 use some (Code.toSet \u27e8\u03b2, s, hs'\u27e9 ?_)\n    \u00b7 intro y\n      erw [mem_some_iff]\n      exact Code.mem_toSet _\n    \u00b7 obtain \u27e8S, hS\u27e9 := hs\n      use S\n      intro \u03c1 h\u03c1S\n      have := hS (allPermEquiv \u03c1) ?_\n      \u00b7 simp only [NewPerm.smul_mk, Code.mk.injEq, heq_eq_eq, true_and]\n        rwa [allPermEquiv_sderiv] at this\n      \u00b7 rwa [allPermEquiv_forget]\n\ntheorem TSet.exists_support {\u03b1 : \u039b} (x : TSet \u03b1) :\n    \u2203 S : Support \u03b1, \u2200 \u03c1 : AllPerm \u03b1, \u03c1\u1d41 \u2022 S = S \u2192 \u03c1 \u2022 x = x := by\n  letI : Level := \u27e8\u03b1\u27e9\n  obtain \u27e8S, hS\u27e9 := NewSet.exists_support (newSetEquiv.symm x)\n  use S\n  intro \u03c1 h\u03c1\n  have := @Support.Supports.supports _ _ _ newPreModelData _ _ _ hS (allPermEquiv.symm \u03c1) ?_\n  \u00b7 apply tSetForget_injective\n    have := congr_arg (\u00b7\u1d41) this\n    simp only at this\n    erw [@smul_forget _ _ newModelData (allPermEquiv.symm \u03c1) (newSetEquiv.symm x),\n      \u2190 allPermEquiv_forget, \u2190 newSetEquiv_forget, Equiv.apply_symm_apply,\n      Equiv.apply_symm_apply] at this\n    rwa [smul_forget]\n  \u00b7 rwa [\u2190 allPermEquiv_forget, Equiv.apply_symm_apply]\n\ntheorem TSet.symmetric {\u03b1 \u03b2 : \u039b} (x : TSet \u03b1) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) :\n    Symmetric {y : TSet \u03b2 | y \u2208[h\u03b2] x} h\u03b2 := by\n  obtain \u27e8S, hS\u27e9 := exists_support x\n  use S\n  intro \u03c1 h\u03c1\n  conv_rhs => rw [\u2190 hS \u03c1 h\u03c1]\n  simp only [\u2190 forget_mem_forget, smul_forget, StrSet.mem_smul_iff]\n  ext y\n  rw [Set.mem_smul_set_iff_inv_smul_mem, Set.mem_setOf_eq, Set.mem_setOf_eq,\n    smul_forget, allPermForget_inv, allPermSderiv_forget']\n\ntheorem tSet_ext' {\u03b1 \u03b2 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (x y : TSet \u03b1)\n    (h : \u2200 z : TSet \u03b2, z \u2208[h\u03b2] x \u2194 z \u2208[h\u03b2] y) : x = y :=\n  letI : Level := \u27e8\u03b1\u27e9\n  letI : LeLevel \u03b1 := \u27e8le_rfl\u27e9\n  letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n  tSet_ext h\u03b2 x y h\n\n", "theoremStatement": "@[simp]\ntheorem TSet.mem_smul_iff' {\u03b1 \u03b2 : TypeIndex}\n    {x : TSet \u03b2} {y : TSet \u03b1} (h : \u03b2 < \u03b1) (\u03c1 : AllPerm \u03b1) :\n    x \u2208[h] \u03c1 \u2022 y \u2194 \u03c1\u207b\u00b9 \u2198 h \u2022 x \u2208[h] y ", "theoremName": "ConNF.TSet.mem_smul_iff'", "fileCreated": {"commit": "6fdc87c6b30b73931407a372f1430ecf0fef7601", "date": "2024-12-03"}, "theoremCreated": {"commit": "2e25ffbc94af48261308cea0d8c55205cc388ef0", "date": "2024-12-01"}, "file": "ConNF/ConNF/Model/TTT.lean", "module": "ConNF.Model.TTT", "jsonFile": "ConNF.Model.TTT.jsonl", "positionMetadata": {"lineInFile": 172, "tokenPositionInFile": 5829, "theoremPositionInFile": 14}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 25, "numPremises": 65}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  letI : Level := \u27e8\u03b1.recBotCoe (Nonempty.some inferInstance) id\u27e9\n  letI : LeLevel \u03b1 := \u27e8\u03b1.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n    (show \u03b1.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n  letI : LtLevel \u03b2 := \u27e8h.trans_le LeLevel.elim\u27e9\n  exact mem_smul_iff h \u03c1", "proofType": "tactic", "proofLengthLines": 5, "proofLengthTokens": 307}}
{"srcContext": "import ConNF.Model.RaiseStrong\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nopen scoped Pointwise\n\nnamespace ConNF\n\nvariable [Params.{u}]\n\n/-- A redefinition of the derivative of allowable permutations that is invariant of level,\nbut still has nice definitional properties. -/\n@[default_instance 200]\ninstance {\u03b2 \u03b3 : TypeIndex} : Derivative (AllPerm \u03b2) (AllPerm \u03b3) \u03b2 \u03b3 where\n  deriv \u03c1 A :=\n    A.recSderiv\n    (motive := \u03bb (\u03b4 : TypeIndex) (A : \u03b2 \u219d \u03b4) \u21a6\n      letI : Level := \u27e8\u03b4.recBotCoe (Nonempty.some inferInstance) id\u27e9\n      letI : LeLevel \u03b4 := \u27e8\u03b4.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n        (show \u03b4.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n      AllPerm \u03b4)\n    \u03c1 (\u03bb \u03b4 \u03b5 A h \u03c1 \u21a6\n      letI : Level := \u27e8\u03b4.recBotCoe (Nonempty.some inferInstance) id\u27e9\n      letI : LeLevel \u03b4 := \u27e8\u03b4.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n        (show \u03b4.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n      letI : LeLevel \u03b5 := \u27e8h.le.trans LeLevel.elim\u27e9\n      PreCoherentData.allPermSderiv h \u03c1)\n\n@[simp]\ntheorem allPerm_deriv_nil' {\u03b2 : TypeIndex}\n    (\u03c1 : AllPerm \u03b2) :\n    \u03c1 \u21d8 (.nil : \u03b2 \u219d \u03b2) = \u03c1 :=\n  rfl\n\n@[simp]\ntheorem allPerm_deriv_sderiv' {\u03b2 \u03b3 \u03b4 : TypeIndex}\n    (\u03c1 : AllPerm \u03b2) (A : \u03b2 \u219d \u03b3) (h : \u03b4 < \u03b3) :\n    \u03c1 \u21d8 (A \u2198 h) = \u03c1 \u21d8 A \u2198 h :=\n  rfl\n\n@[simp]\ntheorem allPermSderiv_forget' {\u03b2 \u03b3 : TypeIndex} (h : \u03b3 < \u03b2) (\u03c1 : AllPerm \u03b2) :\n    (\u03c1 \u2198 h)\u1d41 = \u03c1\u1d41 \u2198 h :=\n  letI : Level := \u27e8\u03b2.recBotCoe (Nonempty.some inferInstance) id\u27e9\n  letI : LeLevel \u03b2 := \u27e8\u03b2.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n    (show \u03b2.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n  letI : LeLevel \u03b3 := \u27e8h.le.trans LeLevel.elim\u27e9\n  allPermSderiv_forget h \u03c1\n\n@[simp]\ntheorem allPerm_inv_sderiv' {\u03b2 \u03b3 : TypeIndex} (h : \u03b3 < \u03b2) (\u03c1 : AllPerm \u03b2) :\n    \u03c1\u207b\u00b9 \u2198 h = (\u03c1 \u2198 h)\u207b\u00b9 := by\n  apply allPermForget_injective\n  rw [allPermSderiv_forget', allPermForget_inv, Tree.inv_sderiv, allPermForget_inv,\n    allPermSderiv_forget']\n\ndef Symmetric {\u03b1 \u03b2 : \u039b} (s : Set (TSet \u03b2)) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) : Prop :=\n  \u2203 S : Support \u03b1, \u2200 \u03c1 : AllPerm \u03b1, \u03c1\u1d41 \u2022 S = S \u2192 \u03c1 \u2198 h\u03b2 \u2022 s = s\n\ndef newSetEquiv {\u03b1 : \u039b} :\n    letI : Level := \u27e8\u03b1\u27e9\n    @TSet _ \u03b1 newModelData.toPreModelData \u2243 TSet \u03b1 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castTSet (D\u2081 := newModelData) (D\u2082 := globalModelData) rfl\n    (by rw [globalModelData, motive_eq, constructMotive, globalLtData_eq])\n\n@[simp]\ntheorem newSetEquiv_forget {\u03b1 : \u039b}\n    (x : letI : Level := \u27e8\u03b1\u27e9; @TSet _ \u03b1 newModelData.toPreModelData) :\n    (newSetEquiv x)\u1d41 = x\u1d41 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castTSet_forget (D\u2081 := newModelData) (D\u2082 := globalModelData) _ x\n\ndef allPermEquiv {\u03b1 : \u039b} :\n    letI : Level := \u27e8\u03b1\u27e9\n    NewPerm \u2243 AllPerm \u03b1 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castAllPerm (D\u2081 := newModelData) (D\u2082 := globalModelData) rfl\n    (by rw [globalModelData, motive_eq, constructMotive, globalLtData_eq])\n\n@[simp]\ntheorem allPermEquiv_forget {\u03b1 : \u039b} (\u03c1 : letI : Level := \u27e8\u03b1\u27e9; NewPerm) :\n    (allPermEquiv \u03c1)\u1d41 = \u03c1\u1d41 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castAllPerm_forget (D\u2081 := newModelData) (D\u2082 := globalModelData) _ \u03c1\n\ntheorem allPermEquiv_sderiv {\u03b1 \u03b2 : \u039b}\n    (\u03c1 : letI : Level := \u27e8\u03b1\u27e9; NewPerm) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) :\n    letI : Level := \u27e8\u03b1\u27e9\n    letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n    allPermEquiv \u03c1 \u2198 h\u03b2 = \u03c1.sderiv \u03b2 := by\n  letI : Level := \u27e8\u03b1\u27e9\n  letI : LeLevel \u03b1 := \u27e8le_rfl\u27e9\n  letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n  apply allPermForget_injective\n  rw [allPermSderiv_forget, allPermEquiv_forget, NewPerm.forget_sderiv]\n\n", "theoremStatement": "theorem TSet.exists_of_symmetric {\u03b1 \u03b2 : \u039b} (s : Set (TSet \u03b2)) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1)\n    (hs : Symmetric s h\u03b2) :\n    \u2203 x : TSet \u03b1, \u2200 y : TSet \u03b2, y \u2208[h\u03b2] x \u2194 y \u2208 s ", "theoremName": "ConNF.TSet.exists_of_symmetric", "fileCreated": {"commit": "6fdc87c6b30b73931407a372f1430ecf0fef7601", "date": "2024-12-03"}, "theoremCreated": {"commit": "b0bc9d69a413800c2ef0d0e3495ee0e71dc3fea7", "date": "2024-12-01"}, "file": "ConNF/ConNF/Model/TTT.lean", "module": "ConNF.Model.TTT", "jsonFile": "ConNF.Model.TTT.jsonl", "positionMetadata": {"lineInFile": 111, "tokenPositionInFile": 3565, "theoremPositionInFile": 10}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 7, "repositoryPremises": true, "numRepositoryPremises": 52, "numPremises": 110}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  letI : Level := \u27e8\u03b1\u27e9\n  letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n  suffices \u2203 x : (@TSet _ \u03b1 newModelData.toPreModelData), \u2200 y : TSet \u03b2, y\u1d41 \u2208[h\u03b2] x\u1d41 \u2194 y \u2208 s by\n    obtain \u27e8x, hx\u27e9 := this\n    use newSetEquiv x\n    intro y\n    rw [\u2190 hx, \u2190 TSet.forget_mem_forget, newSetEquiv_forget]\n  obtain rfl | hs' := s.eq_empty_or_nonempty\n  \u00b7 use none\n    intro y\n    simp only [Set.mem_empty_iff_false, iff_false]\n    exact not_mem_none y\n  \u00b7 use some (Code.toSet \u27e8\u03b2, s, hs'\u27e9 ?_)\n    \u00b7 intro y\n      erw [mem_some_iff]\n      exact Code.mem_toSet _\n    \u00b7 obtain \u27e8S, hS\u27e9 := hs\n      use S\n      intro \u03c1 h\u03c1S\n      have := hS (allPermEquiv \u03c1) ?_\n      \u00b7 simp only [NewPerm.smul_mk, Code.mk.injEq, heq_eq_eq, true_and]\n        rwa [allPermEquiv_sderiv] at this\n      \u00b7 rwa [allPermEquiv_forget]", "proofType": "tactic", "proofLengthLines": 23, "proofLengthTokens": 767}}
{"srcContext": "import ConNF.Model.Result\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal ConNF.TSet\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\ndef union (x y : TSet \u03b1) : TSet \u03b1 :=\n  (x\u1d9c' \u2293' y\u1d9c')\u1d9c'\n\nnotation:68 x:68 \" \u2294[\" h \"] \" y:68 => _root_.ConNF.union h x y\nnotation:68 x:68 \" \u2294' \" y:68 => x \u2294[by assumption] y\n\n@[simp]\ntheorem mem_union_iff (x y : TSet \u03b1) :\n    \u2200 z : TSet \u03b2, z \u2208' x \u2294' y \u2194 z \u2208' x \u2228 z \u2208' y := by\n  rw [union]\n  intro z\n  rw [mem_compl_iff, mem_inter_iff, mem_compl_iff, mem_compl_iff, or_iff_not_and_not]\n\ndef higherIndex (\u03b1 : \u039b) : \u039b :=\n  (exists_gt \u03b1).choose\n\ntheorem lt_higherIndex {\u03b1 : \u039b} :\n    (\u03b1 : TypeIndex) < higherIndex \u03b1 :=\n  WithBot.coe_lt_coe.mpr (exists_gt \u03b1).choose_spec\n\ntheorem tSet_nonempty (h : \u2203 \u03b2 : \u039b, (\u03b2 : TypeIndex) < \u03b1) : Nonempty (TSet \u03b1) := by\n  obtain \u27e8\u03b1', h\u03b1\u27e9 := h\n  constructor\n  apply typeLower lt_higherIndex lt_higherIndex lt_higherIndex h\u03b1\n  apply cardinalOne lt_higherIndex lt_higherIndex\n\ndef empty : TSet \u03b1 :=\n  (tSet_nonempty \u27e8\u03b2, h\u03b2\u27e9).some \u2293' (tSet_nonempty \u27e8\u03b2, h\u03b2\u27e9).some\u1d9c'\n\n@[simp]\ntheorem mem_empty_iff :\n    \u2200 x : TSet \u03b2, \u00acx \u2208' empty h\u03b2 := by\n  intro x\n  rw [empty, mem_inter_iff, mem_compl_iff]\n  exact and_not_self\n\ndef univ : TSet \u03b1 :=\n  (empty h\u03b2)\u1d9c'\n\n@[simp]\ntheorem mem_univ_iff :\n    \u2200 x : TSet \u03b2, x \u2208' univ h\u03b2 := by\n  intro x\n  simp only [univ, mem_compl_iff, mem_empty_iff, not_false_eq_true]\n\n/-- The set of all ordered pairs. -/\ndef orderedPairs : TSet \u03b1 :=\n  vCross h\u03b2 h\u03b3 h\u03b4 (univ h\u03b4)\n\n@[simp]\ntheorem mem_orderedPairs_iff (x : TSet \u03b2) :\n    x \u2208' orderedPairs h\u03b2 h\u03b3 h\u03b4 \u2194 \u2203 a b, x = \u27e8a, b\u27e9' := by\n  simp only [orderedPairs, vCross_spec, mem_univ_iff, and_true]\n\ndef converse (x : TSet \u03b1) : TSet \u03b1 :=\n  converse' h\u03b2 h\u03b3 h\u03b4 x \u2293' orderedPairs h\u03b2 h\u03b3 h\u03b4\n\n@[simp]\ntheorem op_mem_converse_iff (x : TSet \u03b1) :\n    \u2200 a b, \u27e8a, b\u27e9' \u2208' converse h\u03b2 h\u03b3 h\u03b4 x \u2194 \u27e8b, a\u27e9' \u2208' x := by\n  intro a b\n  simp only [converse, mem_inter_iff, converse'_spec, mem_orderedPairs_iff, op_inj, exists_and_left,\n    exists_eq', and_true]\n\ndef cross (x y : TSet \u03b3) : TSet \u03b1 :=\n  converse h\u03b2 h\u03b3 h\u03b4 (vCross h\u03b2 h\u03b3 h\u03b4 x) \u2293' vCross h\u03b2 h\u03b3 h\u03b4 y\n\n@[simp]\ntheorem mem_cross_iff (x y : TSet \u03b3) :\n    \u2200 a, a \u2208' cross h\u03b2 h\u03b3 h\u03b4 x y \u2194 \u2203 b c, a = \u27e8b, c\u27e9' \u2227 b \u2208' x \u2227 c \u2208' y := by\n  intro a\n  rw [cross, mem_inter_iff, vCross_spec]\n  constructor\n  \u00b7 rintro \u27e8h\u2081, b, c, rfl, h\u2082\u27e9\n    simp only [op_mem_converse_iff, vCross_spec, op_inj] at h\u2081\n    obtain \u27e8b', c', \u27e8rfl, rfl\u27e9, h\u2081\u27e9 := h\u2081\n    exact \u27e8b, c, rfl, h\u2081, h\u2082\u27e9\n  \u00b7 rintro \u27e8b, c, rfl, h\u2081, h\u2082\u27e9\n    simp only [op_mem_converse_iff, vCross_spec, op_inj]\n    exact \u27e8\u27e8c, b, \u27e8rfl, rfl\u27e9, h\u2081\u27e9, \u27e8b, c, \u27e8rfl, rfl\u27e9, h\u2082\u27e9\u27e9\n\ndef singletonImage (x : TSet \u03b2) : TSet \u03b1 :=\n  singletonImage' h\u03b2 h\u03b3 h\u03b4 h\u03b5 x \u2293' (cross h\u03b2 h\u03b3 h\u03b4 (cardinalOne h\u03b4 h\u03b5) (cardinalOne h\u03b4 h\u03b5))\n\n@[simp]\ntheorem singletonImage_spec (x : TSet \u03b2) :\n    \u2200 z w,\n    \u27e8 {z}', {w}' \u27e9' \u2208' singletonImage h\u03b2 h\u03b3 h\u03b4 h\u03b5 x \u2194 \u27e8z, w\u27e9' \u2208' x := by\n  intro z w\n  rw [singletonImage, mem_inter_iff, singletonImage'_spec, and_iff_left_iff_imp]\n  intro hzw\n  rw [mem_cross_iff]\n  refine \u27e8{z}', {w}', rfl, ?_\u27e9\n  simp only [mem_cardinalOne_iff, singleton_inj, exists_eq', and_self]\n\ntheorem exists_of_mem_singletonImage {x : TSet \u03b2} {z w : TSet \u03b4}\n    (h : \u27e8z, w\u27e9' \u2208' singletonImage h\u03b2 h\u03b3 h\u03b4 h\u03b5 x) :\n    \u2203 a b, z = {a}' \u2227 w = {b}' := by\n  simp only [singletonImage, mem_inter_iff, mem_cross_iff, op_inj, mem_cardinalOne_iff] at h\n  obtain \u27e8-, _, _, \u27e8rfl, rfl\u27e9, \u27e8a, rfl\u27e9, \u27e8b, rfl\u27e9\u27e9 := h\n  exact \u27e8a, b, rfl, rfl\u27e9\n\n/-- Turn a model element encoding a relation into an actual relation. -/\ndef ExternalRel (r : TSet \u03b1) : Rel (TSet \u03b4) (TSet \u03b4) :=\n  \u03bb x y \u21a6 \u27e8x, y\u27e9' \u2208' r\n\n@[simp]\ntheorem externalRel_converse (r : TSet \u03b1) :\n    ExternalRel h\u03b2 h\u03b3 h\u03b4 (converse h\u03b2 h\u03b3 h\u03b4 r) = (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).inv := by\n  ext\n  simp only [ExternalRel, op_mem_converse_iff, Rel.inv_apply]\n\n/-- The codomain of a relation. -/\ndef codom (r : TSet \u03b1) : TSet \u03b3 :=\n  (typeLower lt_higherIndex h\u03b2 h\u03b3 h\u03b4 (singletonImage lt_higherIndex h\u03b2 h\u03b3 h\u03b4 r)\u1d9c[lt_higherIndex])\u1d9c'\n\n@[simp]\ntheorem mem_codom_iff (r : TSet \u03b1) (x : TSet \u03b4) :\n    x \u2208' codom h\u03b2 h\u03b3 h\u03b4 r \u2194 x \u2208 (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).codom := by\n  simp only [codom, mem_compl_iff, mem_typeLower_iff, not_forall, not_not]\n  constructor\n  \u00b7 rintro \u27e8y, hy\u27e9\n    obtain \u27e8a, b, rfl, hb\u27e9 := exists_of_mem_singletonImage lt_higherIndex h\u03b2 h\u03b3 h\u03b4 hy\n    rw [singleton_inj] at hb\n    subst hb\n    rw [singletonImage_spec] at hy\n    exact \u27e8a, hy\u27e9\n  \u00b7 rintro \u27e8a, ha\u27e9\n    use {a}'\n    rw [singletonImage_spec]\n    exact ha\n\n/-- The domain of a relation. -/\ndef dom (r : TSet \u03b1) : TSet \u03b3 :=\n  codom h\u03b2 h\u03b3 h\u03b4 (converse h\u03b2 h\u03b3 h\u03b4 r)\n\n@[simp]\ntheorem mem_dom_iff (r : TSet \u03b1) (x : TSet \u03b4) :\n    x \u2208' dom h\u03b2 h\u03b3 h\u03b4 r \u2194 x \u2208 (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).dom := by\n  rw [dom, mem_codom_iff, externalRel_converse, Rel.inv_codom]\n\n/-- The field of a relation. -/\ndef field (r : TSet \u03b1) : TSet \u03b3 :=\n  dom h\u03b2 h\u03b3 h\u03b4 r \u2294' codom h\u03b2 h\u03b3 h\u03b4 r\n\n@[simp]\ntheorem mem_field_iff (r : TSet \u03b1) (x : TSet \u03b4) :\n    x \u2208' field h\u03b2 h\u03b3 h\u03b4 r \u2194 x \u2208 (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).field := by\n  rw [field, mem_union_iff, mem_dom_iff, mem_codom_iff, Rel.field, Set.mem_union]\n\ndef subset : TSet \u03b1 :=\n  subset' h\u03b2 h\u03b3 h\u03b4 h\u03b5 \u2293' orderedPairs h\u03b2 h\u03b3 h\u03b4\n\n@[simp]\ntheorem subset_spec :\n    \u2200 a b, \u27e8a, b\u27e9' \u2208' subset h\u03b2 h\u03b3 h\u03b4 h\u03b5 \u2194 a \u2286[TSet \u03b5] b := by\n  intro a b\n  simp only [subset, mem_inter_iff, subset'_spec, mem_orderedPairs_iff, op_inj, exists_and_left,\n    exists_eq', and_true]\n\ndef membership : TSet \u03b1 :=\n  subset h\u03b2 h\u03b3 h\u03b4 h\u03b5 \u2293' cross h\u03b2 h\u03b3 h\u03b4 (cardinalOne h\u03b4 h\u03b5) (univ h\u03b4)\n\n@[simp]\ntheorem membership_spec :\n    \u2200 a b, \u27e8{a}', b\u27e9' \u2208' membership h\u03b2 h\u03b3 h\u03b4 h\u03b5 \u2194 a \u2208' b := by\n  intro a b\n  rw [membership, mem_inter_iff, subset_spec]\n  simp only [mem_cross_iff, op_inj, mem_cardinalOne_iff, mem_univ_iff, and_true, exists_and_right,\n    exists_and_left, exists_eq', exists_eq_left', singleton_inj]\n  constructor\n  \u00b7 intro h\n    exact h a ((typedMem_singleton_iff' h\u03b5 a a).mpr rfl)\n  \u00b7 intro h c hc\n    simp only [typedMem_singleton_iff'] at hc\n    cases hc\n    exact h\n\ndef powerset (x : TSet \u03b2) : TSet \u03b1 :=\n  dom lt_higherIndex lt_higherIndex h\u03b2\n    (subset lt_higherIndex lt_higherIndex h\u03b2 h\u03b3 \u2293[lt_higherIndex]\n      vCross lt_higherIndex lt_higherIndex h\u03b2 {x}')\n\n@[simp]\ntheorem mem_powerset_iff (x y : TSet \u03b2) :\n    x \u2208' powerset h\u03b2 h\u03b3 y \u2194 x \u2286[TSet \u03b3] y := by\n  rw [powerset, mem_dom_iff]\n  constructor\n  \u00b7 rintro \u27e8z, h\u27e9\n    simp only [ExternalRel, mem_inter_iff, subset_spec, vCross_spec, op_inj,\n      typedMem_singleton_iff', exists_eq_right, exists_and_right, exists_eq', true_and] at h\n    cases h.2\n    exact h.1\n  \u00b7 intro h\n    refine \u27e8y, ?_\u27e9\n    simp only [ExternalRel, mem_inter_iff, subset_spec, h, vCross_spec, op_inj,\n      typedMem_singleton_iff', exists_eq_right, and_true, exists_eq', and_self]\n\n/-- The set `\u03b9\u00b2''x = {{{a}} | a \u2208 x}`. -/\ndef doubleSingleton (x : TSet \u03b3) : TSet \u03b1 :=\n  cross h\u03b2 h\u03b3 h\u03b4 x x \u2293' cardinalOne h\u03b2 h\u03b3\n\n@[simp]\ntheorem mem_doubleSingleton_iff (x : TSet \u03b3) :\n    \u2200 y : TSet \u03b2, y \u2208' doubleSingleton h\u03b2 h\u03b3 h\u03b4 x \u2194\n    \u2203 z : TSet \u03b4, z \u2208' x \u2227 y = { {z}' }' := by\n  intro y\n  rw [doubleSingleton, mem_inter_iff, mem_cross_iff, mem_cardinalOne_iff]\n  constructor\n  \u00b7 rintro \u27e8\u27e8b, c, h\u2081, h\u2082, h\u2083\u27e9, \u27e8a, rfl\u27e9\u27e9\n    obtain \u27e8hbc, rfl\u27e9 := (op_eq_singleton_iff _ _ _ _ _).mp h\u2081.symm\n    exact \u27e8c, h\u2083, rfl\u27e9\n  \u00b7 rintro \u27e8z, h, rfl\u27e9\n    constructor\n    \u00b7 refine \u27e8z, z, ?_\u27e9\n      rw [eq_comm, op_eq_singleton_iff]\n      tauto\n    \u00b7 exact \u27e8_, rfl\u27e9\n\n/-- The union of a set of *singletons*: `\u03b9\u207b\u00b9''x = {a | {a} \u2208 x}`. -/\ndef singletonUnion (x : TSet \u03b1) : TSet \u03b2 :=\n  typeLower lt_higherIndex lt_higherIndex h\u03b2 h\u03b3\n    (vCross lt_higherIndex lt_higherIndex h\u03b2 x)\n\n", "theoremStatement": "@[simp]\ntheorem mem_singletonUnion_iff (x : TSet \u03b1) :\n    \u2200 y : TSet \u03b3, y \u2208' singletonUnion h\u03b2 h\u03b3 x \u2194 {y}' \u2208' x ", "theoremName": "ConNF.mem_singletonUnion_iff", "fileCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "theoremCreated": {"commit": "6dd8406a01cc28b071bb26965294469664a1b592", "date": "2025-01-07"}, "file": "ConNF/ConNF/External/Basic.lean", "module": "ConNF.External.Basic", "jsonFile": "ConNF.External.Basic.jsonl", "positionMetadata": {"lineInFile": 247, "tokenPositionInFile": 7761, "theoremPositionInFile": 37}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 19, "numPremises": 48}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  intro y\n  simp only [singletonUnion, mem_typeLower_iff, vCross_spec, op_inj]\n  constructor\n  \u00b7 intro h\n    obtain \u27e8a, b, \u27e8rfl, rfl\u27e9, hy\u27e9 := h {y}'\n    exact hy\n  \u00b7 intro h b\n    exact \u27e8b, _, \u27e8rfl, rfl\u27e9, h\u27e9", "proofType": "tactic", "proofLengthLines": 8, "proofLengthTokens": 213}}
{"srcContext": "import ConNF.Model.TTT\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\nnamespace TSet\n\ntheorem exists_inter (x y : TSet \u03b1) :\n    \u2203 w : TSet \u03b1, \u2200 z : TSet \u03b2, z \u2208[h\u03b2] w \u2194 z \u2208[h\u03b2] x \u2227 z \u2208[h\u03b2] y := by\n  refine exists_of_symmetric {z | z \u2208[h\u03b2] x \u2227 z \u2208[h\u03b2] y} h\u03b2 ?_\n  obtain \u27e8S, hS\u27e9 := symmetric x h\u03b2\n  obtain \u27e8T, hT\u27e9 := symmetric y h\u03b2\n  use S + T\n  intro \u03c1 h\u03c1\n  specialize hS \u03c1 (smul_eq_of_le Support.le_add_right h\u03c1)\n  specialize hT \u03c1 (smul_eq_of_le Support.le_add_left h\u03c1)\n  simp [Set.ext_iff, Set.mem_smul_set_iff_inv_smul_mem] at hS hT \u22a2\n  aesop\n\ntheorem exists_compl (x : TSet \u03b1) :\n    \u2203 y : TSet \u03b1, \u2200 z : TSet \u03b2, z \u2208[h\u03b2] y \u2194 \u00acz \u2208[h\u03b2] x := by\n  refine exists_of_symmetric {z | \u00acz \u2208[h\u03b2] x} h\u03b2 ?_\n  obtain \u27e8S, hS\u27e9 := symmetric x h\u03b2\n  use S\n  intro \u03c1 h\u03c1\n  specialize hS \u03c1 h\u03c1\n  simp [Set.ext_iff, Set.mem_smul_set_iff_inv_smul_mem] at hS \u22a2\n  aesop\n\ntheorem exists_up (x y : TSet \u03b2) :\n    \u2203 w : TSet \u03b1, \u2200 z : TSet \u03b2, z \u2208[h\u03b2] w \u2194 z = x \u2228 z = y := by\n  refine exists_of_symmetric {x, y} h\u03b2 ?_\n  obtain \u27e8S, hS\u27e9 := exists_support x\n  obtain \u27e8T, hT\u27e9 := exists_support y\n  use (S + T) \u2197 h\u03b2\n  intro \u03c1 h\u03c1\n  rw [Support.smul_scoderiv, Support.scoderiv_inj, \u2190 allPermSderiv_forget'] at h\u03c1\n  specialize hS (\u03c1 \u2198 h\u03b2) (smul_eq_of_le Support.le_add_right h\u03c1)\n  specialize hT (\u03c1 \u2198 h\u03b2) (smul_eq_of_le Support.le_add_left h\u03c1)\n  simp only [Set.smul_set_def, Set.image, Set.mem_insert_iff, Set.mem_singleton_iff,\n    exists_eq_or_imp, hS, exists_eq_left, hT]\n  ext z\n  rw [Set.mem_insert_iff, Set.mem_singleton_iff, Set.mem_setOf_eq]\n  aesop\n\n/-- The unordered pair. -/\ndef up (x y : TSet \u03b2) : TSet \u03b1 :=\n  (exists_up h\u03b2 x y).choose\n\n@[simp]\ntheorem mem_up_iff (x y z : TSet \u03b2) :\n    z \u2208[h\u03b2] up h\u03b2 x y \u2194 z = x \u2228 z = y :=\n  (exists_up h\u03b2 x y).choose_spec z\n\n/-- The Kuratowski ordered pair. -/\ndef op (x y : TSet \u03b3) : TSet \u03b1 :=\n  up h\u03b2 (singleton h\u03b3 x) (up h\u03b3 x y)\n\ntheorem up_injective {x y z w : TSet \u03b2} (h : up h\u03b2 x y = up h\u03b2 z w) :\n    (x = z \u2227 y = w) \u2228 (x = w \u2227 y = z) := by\n  have h\u2081 := mem_up_iff h\u03b2 x y z\n  have h\u2082 := mem_up_iff h\u03b2 x y w\n  have h\u2083 := mem_up_iff h\u03b2 z w x\n  have h\u2084 := mem_up_iff h\u03b2 z w y\n  rw [h, mem_up_iff] at h\u2081 h\u2082\n  rw [\u2190 h, mem_up_iff] at h\u2083 h\u2084\n  aesop\n\n@[simp]\ntheorem up_inj (x y z w : TSet \u03b2) :\n    up h\u03b2 x y = up h\u03b2 z w \u2194 (x = z \u2227 y = w) \u2228 (x = w \u2227 y = z) := by\n  constructor\n  \u00b7 exact up_injective h\u03b2\n  \u00b7 rintro (\u27e8rfl, rfl\u27e9 | \u27e8rfl, rfl\u27e9)\n    \u00b7 rfl\n    \u00b7 apply tSet_ext' h\u03b2\n      aesop\n\n@[simp]\ntheorem up_self {x : TSet \u03b2} :\n    up h\u03b2 x x = singleton h\u03b2 x := by\n  apply tSet_ext' h\u03b2\n  aesop\n\n@[simp]\ntheorem up_eq_singleton_iff (x y z : TSet \u03b2) :\n    up h\u03b2 x y = singleton h\u03b2 z \u2194 x = z \u2227 y = z := by\n  constructor\n  \u00b7 intro h\n    have h\u2081 := typedMem_singleton_iff' h\u03b2 z x\n    have h\u2082 := typedMem_singleton_iff' h\u03b2 z y\n    rw [\u2190 h, mem_up_iff] at h\u2081 h\u2082\n    aesop\n  \u00b7 rintro \u27e8rfl, rfl\u27e9\n    rw [up_self]\n\n@[simp]\ntheorem singleton_eq_up_iff (x y z : TSet \u03b2) :\n    singleton h\u03b2 z = up h\u03b2 x y \u2194 x = z \u2227 y = z := by\n  rw [\u2190 up_eq_singleton_iff h\u03b2 x y z, eq_comm]\n\ntheorem op_injective {x y z w : TSet \u03b3} (h : op h\u03b2 h\u03b3 x y = op h\u03b2 h\u03b3 z w) :\n    x = z \u2227 y = w := by\n  rw [op, op] at h\n  simp only [up_inj, singleton_inj, singleton_eq_up_iff, up_eq_singleton_iff] at h\n  obtain (\u27e8rfl, \u27e8h, rfl\u27e9 | \u27e8rfl, rfl\u27e9\u27e9 | \u27e8\u27e8rfl, rfl\u27e9, \u27e8h, rfl\u27e9\u27e9) := h <;> simp only [and_self]\n\n@[simp]\ntheorem op_inj (x y z w : TSet \u03b3) :\n    op h\u03b2 h\u03b3 x y = op h\u03b2 h\u03b3 z w \u2194 x = z \u2227 y = w := by\n  constructor\n  \u00b7 exact op_injective h\u03b2 h\u03b3\n  \u00b7 rintro \u27e8rfl, rfl\u27e9\n    rfl\n\n@[simp]\ntheorem op_eq_singleton_iff (x y : TSet \u03b3) (z : TSet \u03b2) :\n    op h\u03b2 h\u03b3 x y = singleton h\u03b2 z \u2194 singleton h\u03b3 x = z \u2227 singleton h\u03b3 y = z := by\n  rw [op, up_eq_singleton_iff, and_congr_right_iff]\n  rintro rfl\n  simp only [up_eq_singleton_iff, true_and, singleton_inj]\n\n@[simp]\ntheorem smul_up (x y : TSet \u03b2) (\u03c1 : AllPerm \u03b1) :\n    \u03c1 \u2022 up h\u03b2 x y = up h\u03b2 (\u03c1 \u2198 h\u03b2 \u2022 x) (\u03c1 \u2198 h\u03b2 \u2022 y) := by\n  apply tSet_ext' h\u03b2\n  aesop\n\n@[simp]\ntheorem smul_op (x y : TSet \u03b3) (\u03c1 : AllPerm \u03b1) :\n    \u03c1 \u2022 op h\u03b2 h\u03b3 x y = op h\u03b2 h\u03b3 (\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2022 x) (\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2022 y) := by\n  apply tSet_ext' h\u03b2\n  simp only [op, smul_up, smul_singleton, mem_up_iff, implies_true]\n\n", "theoremStatement": "theorem exists_singletonImage (x : TSet \u03b2) :\n    \u2203 y : TSet \u03b1, \u2200 z w,\n    op h\u03b3 h\u03b4 (singleton h\u03b5 z) (singleton h\u03b5 w) \u2208[h\u03b2] y \u2194 op h\u03b4 h\u03b5 z w \u2208[h\u03b3] x ", "theoremName": "ConNF.TSet.exists_singletonImage", "fileCreated": {"commit": "f804f5c71cfaa98223fc227dd822801e8bf77004", "date": "2024-03-30"}, "theoremCreated": {"commit": "f7c233c7f7fd9d8b74595bbfa2bbbd49d538ef59", "date": "2024-12-02"}, "file": "ConNF/ConNF/Model/Hailperin.lean", "module": "ConNF.Model.Hailperin", "jsonFile": "ConNF.Model.Hailperin.jsonl", "positionMetadata": {"lineInFile": 152, "tokenPositionInFile": 4368, "theoremPositionInFile": 16}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 43, "numPremises": 104}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  have := exists_of_symmetric {u | \u2203 z w : TSet \u03b5, op h\u03b4 h\u03b5 z w \u2208[h\u03b3] x \u2227\n      u = op h\u03b3 h\u03b4 (singleton h\u03b5 z) (singleton h\u03b5 w)} h\u03b2 ?_\n  \u00b7 obtain \u27e8y, hy\u27e9 := this\n    use y\n    intro z w\n    rw [hy]\n    simp only [Set.mem_setOf_eq, op_inj, singleton_inj, exists_eq_right_right', exists_eq_right']\n  \u00b7 obtain \u27e8S, hS\u27e9 := exists_support x\n    use S \u2197 h\u03b2\n    intro \u03c1 h\u03c1\n    rw [Support.smul_scoderiv, Support.scoderiv_inj, \u2190 allPermSderiv_forget'] at h\u03c1\n    specialize hS (\u03c1 \u2198 h\u03b2) h\u03c1\n    ext z\n    constructor\n    \u00b7 rintro \u27e8_, \u27e8z, w, hab, rfl\u27e9, rfl\u27e9\n      refine \u27e8\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2022 z, \u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2022 w, ?_, ?_\u27e9\n      \u00b7 rwa [\u2190 hS, mem_smul_iff', smul_op, allPerm_inv_sderiv', allPerm_inv_sderiv',\n          allPerm_inv_sderiv', inv_smul_smul, inv_smul_smul]\n      \u00b7 simp only [smul_op, smul_singleton]\n    \u00b7 rintro \u27e8z, w, hab, rfl\u27e9\n      refine \u27e8\u03c1\u207b\u00b9 \u2198 h\u03b2 \u2022 op h\u03b3 h\u03b4 (singleton h\u03b5 z) (singleton h\u03b5 w), ?_, ?_\u27e9\n      \u00b7 simp only [allPerm_inv_sderiv', smul_op, smul_singleton, Set.mem_setOf_eq, op_inj,\n          singleton_inj, exists_eq_right_right', exists_eq_right']\n        rw [smul_eq_iff_eq_inv_smul] at hS\n        rw [hS]\n        simp only [mem_smul_iff', inv_inv, smul_op, smul_inv_smul]\n        exact hab\n      \u00b7 simp only [allPerm_inv_sderiv', smul_inv_smul]", "proofType": "tactic", "proofLengthLines": 28, "proofLengthTokens": 1279}}
{"srcContext": "import ConNF.Model.Result\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal ConNF.TSet\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\ndef union (x y : TSet \u03b1) : TSet \u03b1 :=\n  (x\u1d9c' \u2293' y\u1d9c')\u1d9c'\n\nnotation:68 x:68 \" \u2294[\" h \"] \" y:68 => _root_.ConNF.union h x y\nnotation:68 x:68 \" \u2294' \" y:68 => x \u2294[by assumption] y\n\n@[simp]\ntheorem mem_union_iff (x y : TSet \u03b1) :\n    \u2200 z : TSet \u03b2, z \u2208' x \u2294' y \u2194 z \u2208' x \u2228 z \u2208' y := by\n  rw [union]\n  intro z\n  rw [mem_compl_iff, mem_inter_iff, mem_compl_iff, mem_compl_iff, or_iff_not_and_not]\n\ndef higherIndex (\u03b1 : \u039b) : \u039b :=\n  (exists_gt \u03b1).choose\n\ntheorem lt_higherIndex {\u03b1 : \u039b} :\n    (\u03b1 : TypeIndex) < higherIndex \u03b1 :=\n  WithBot.coe_lt_coe.mpr (exists_gt \u03b1).choose_spec\n\n", "theoremStatement": "theorem tSet_nonempty (h : \u2203 \u03b2 : \u039b, (\u03b2 : TypeIndex) < \u03b1) : Nonempty (TSet \u03b1) ", "theoremName": "ConNF.tSet_nonempty", "fileCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "theoremCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "file": "ConNF/ConNF/External/Basic.lean", "module": "ConNF.External.Basic", "jsonFile": "ConNF.External.Basic.jsonl", "positionMetadata": {"lineInFile": 43, "tokenPositionInFile": 941, "theoremPositionInFile": 6}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 11, "numPremises": 25}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  obtain \u27e8\u03b1', h\u03b1\u27e9 := h\n  constructor\n  apply typeLower lt_higherIndex lt_higherIndex lt_higherIndex h\u03b1\n  apply cardinalOne lt_higherIndex lt_higherIndex", "proofType": "tactic", "proofLengthLines": 4, "proofLengthTokens": 158}}
{"srcContext": "import ConNF.Model.RaiseStrong\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nopen scoped Pointwise\n\nnamespace ConNF\n\nvariable [Params.{u}]\n\n/-- A redefinition of the derivative of allowable permutations that is invariant of level,\nbut still has nice definitional properties. -/\n@[default_instance 200]\ninstance {\u03b2 \u03b3 : TypeIndex} : Derivative (AllPerm \u03b2) (AllPerm \u03b3) \u03b2 \u03b3 where\n  deriv \u03c1 A :=\n    A.recSderiv\n    (motive := \u03bb (\u03b4 : TypeIndex) (A : \u03b2 \u219d \u03b4) \u21a6\n      letI : Level := \u27e8\u03b4.recBotCoe (Nonempty.some inferInstance) id\u27e9\n      letI : LeLevel \u03b4 := \u27e8\u03b4.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n        (show \u03b4.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n      AllPerm \u03b4)\n    \u03c1 (\u03bb \u03b4 \u03b5 A h \u03c1 \u21a6\n      letI : Level := \u27e8\u03b4.recBotCoe (Nonempty.some inferInstance) id\u27e9\n      letI : LeLevel \u03b4 := \u27e8\u03b4.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n        (show \u03b4.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n      letI : LeLevel \u03b5 := \u27e8h.le.trans LeLevel.elim\u27e9\n      PreCoherentData.allPermSderiv h \u03c1)\n\n@[simp]\ntheorem allPerm_deriv_nil' {\u03b2 : TypeIndex}\n    (\u03c1 : AllPerm \u03b2) :\n    \u03c1 \u21d8 (.nil : \u03b2 \u219d \u03b2) = \u03c1 :=\n  rfl\n\n@[simp]\ntheorem allPerm_deriv_sderiv' {\u03b2 \u03b3 \u03b4 : TypeIndex}\n    (\u03c1 : AllPerm \u03b2) (A : \u03b2 \u219d \u03b3) (h : \u03b4 < \u03b3) :\n    \u03c1 \u21d8 (A \u2198 h) = \u03c1 \u21d8 A \u2198 h :=\n  rfl\n\n@[simp]\ntheorem allPermSderiv_forget' {\u03b2 \u03b3 : TypeIndex} (h : \u03b3 < \u03b2) (\u03c1 : AllPerm \u03b2) :\n    (\u03c1 \u2198 h)\u1d41 = \u03c1\u1d41 \u2198 h :=\n  letI : Level := \u27e8\u03b2.recBotCoe (Nonempty.some inferInstance) id\u27e9\n  letI : LeLevel \u03b2 := \u27e8\u03b2.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n    (show \u03b2.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n  letI : LeLevel \u03b3 := \u27e8h.le.trans LeLevel.elim\u27e9\n  allPermSderiv_forget h \u03c1\n\n@[simp]\ntheorem allPerm_inv_sderiv' {\u03b2 \u03b3 : TypeIndex} (h : \u03b3 < \u03b2) (\u03c1 : AllPerm \u03b2) :\n    \u03c1\u207b\u00b9 \u2198 h = (\u03c1 \u2198 h)\u207b\u00b9 := by\n  apply allPermForget_injective\n  rw [allPermSderiv_forget', allPermForget_inv, Tree.inv_sderiv, allPermForget_inv,\n    allPermSderiv_forget']\n\ndef Symmetric {\u03b1 \u03b2 : \u039b} (s : Set (TSet \u03b2)) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) : Prop :=\n  \u2203 S : Support \u03b1, \u2200 \u03c1 : AllPerm \u03b1, \u03c1\u1d41 \u2022 S = S \u2192 \u03c1 \u2198 h\u03b2 \u2022 s = s\n\ndef newSetEquiv {\u03b1 : \u039b} :\n    letI : Level := \u27e8\u03b1\u27e9\n    @TSet _ \u03b1 newModelData.toPreModelData \u2243 TSet \u03b1 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castTSet (D\u2081 := newModelData) (D\u2082 := globalModelData) rfl\n    (by rw [globalModelData, motive_eq, constructMotive, globalLtData_eq])\n\n@[simp]\ntheorem newSetEquiv_forget {\u03b1 : \u039b}\n    (x : letI : Level := \u27e8\u03b1\u27e9; @TSet _ \u03b1 newModelData.toPreModelData) :\n    (newSetEquiv x)\u1d41 = x\u1d41 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castTSet_forget (D\u2081 := newModelData) (D\u2082 := globalModelData) _ x\n\ndef allPermEquiv {\u03b1 : \u039b} :\n    letI : Level := \u27e8\u03b1\u27e9\n    NewPerm \u2243 AllPerm \u03b1 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castAllPerm (D\u2081 := newModelData) (D\u2082 := globalModelData) rfl\n    (by rw [globalModelData, motive_eq, constructMotive, globalLtData_eq])\n\n@[simp]\ntheorem allPermEquiv_forget {\u03b1 : \u039b} (\u03c1 : letI : Level := \u27e8\u03b1\u27e9; NewPerm) :\n    (allPermEquiv \u03c1)\u1d41 = \u03c1\u1d41 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castAllPerm_forget (D\u2081 := newModelData) (D\u2082 := globalModelData) _ \u03c1\n\n", "theoremStatement": "theorem allPermEquiv_sderiv {\u03b1 \u03b2 : \u039b}\n    (\u03c1 : letI : Level := \u27e8\u03b1\u27e9; NewPerm) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) :\n    letI : Level := \u27e8\u03b1\u27e9\n    letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n    allPermEquiv \u03c1 \u2198 h\u03b2 = \u03c1.sderiv \u03b2 ", "theoremName": "ConNF.allPermEquiv_sderiv", "fileCreated": {"commit": "6fdc87c6b30b73931407a372f1430ecf0fef7601", "date": "2024-12-03"}, "theoremCreated": {"commit": "b0bc9d69a413800c2ef0d0e3495ee0e71dc3fea7", "date": "2024-12-01"}, "file": "ConNF/ConNF/Model/TTT.lean", "module": "ConNF.Model.TTT", "jsonFile": "ConNF.Model.TTT.jsonl", "positionMetadata": {"lineInFile": 100, "tokenPositionInFile": 3178, "theoremPositionInFile": 9}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 39, "numPremises": 58}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  letI : Level := \u27e8\u03b1\u27e9\n  letI : LeLevel \u03b1 := \u27e8le_rfl\u27e9\n  letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n  apply allPermForget_injective\n  rw [allPermSderiv_forget, allPermEquiv_forget, NewPerm.forget_sderiv]", "proofType": "tactic", "proofLengthLines": 5, "proofLengthTokens": 189}}
{"srcContext": "import ConNF.Model.Result\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal ConNF.TSet\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\ndef union (x y : TSet \u03b1) : TSet \u03b1 :=\n  (x\u1d9c' \u2293' y\u1d9c')\u1d9c'\n\nnotation:68 x:68 \" \u2294[\" h \"] \" y:68 => _root_.ConNF.union h x y\nnotation:68 x:68 \" \u2294' \" y:68 => x \u2294[by assumption] y\n\n@[simp]\ntheorem mem_union_iff (x y : TSet \u03b1) :\n    \u2200 z : TSet \u03b2, z \u2208' x \u2294' y \u2194 z \u2208' x \u2228 z \u2208' y := by\n  rw [union]\n  intro z\n  rw [mem_compl_iff, mem_inter_iff, mem_compl_iff, mem_compl_iff, or_iff_not_and_not]\n\ndef higherIndex (\u03b1 : \u039b) : \u039b :=\n  (exists_gt \u03b1).choose\n\ntheorem lt_higherIndex {\u03b1 : \u039b} :\n    (\u03b1 : TypeIndex) < higherIndex \u03b1 :=\n  WithBot.coe_lt_coe.mpr (exists_gt \u03b1).choose_spec\n\ntheorem tSet_nonempty (h : \u2203 \u03b2 : \u039b, (\u03b2 : TypeIndex) < \u03b1) : Nonempty (TSet \u03b1) := by\n  obtain \u27e8\u03b1', h\u03b1\u27e9 := h\n  constructor\n  apply typeLower lt_higherIndex lt_higherIndex lt_higherIndex h\u03b1\n  apply cardinalOne lt_higherIndex lt_higherIndex\n\ndef empty : TSet \u03b1 :=\n  (tSet_nonempty \u27e8\u03b2, h\u03b2\u27e9).some \u2293' (tSet_nonempty \u27e8\u03b2, h\u03b2\u27e9).some\u1d9c'\n\n@[simp]\ntheorem mem_empty_iff :\n    \u2200 x : TSet \u03b2, \u00acx \u2208' empty h\u03b2 := by\n  intro x\n  rw [empty, mem_inter_iff, mem_compl_iff]\n  exact and_not_self\n\ndef univ : TSet \u03b1 :=\n  (empty h\u03b2)\u1d9c'\n\n@[simp]\ntheorem mem_univ_iff :\n    \u2200 x : TSet \u03b2, x \u2208' univ h\u03b2 := by\n  intro x\n  simp only [univ, mem_compl_iff, mem_empty_iff, not_false_eq_true]\n\n/-- The set of all ordered pairs. -/\ndef orderedPairs : TSet \u03b1 :=\n  vCross h\u03b2 h\u03b3 h\u03b4 (univ h\u03b4)\n\n@[simp]\ntheorem mem_orderedPairs_iff (x : TSet \u03b2) :\n    x \u2208' orderedPairs h\u03b2 h\u03b3 h\u03b4 \u2194 \u2203 a b, x = \u27e8a, b\u27e9' := by\n  simp only [orderedPairs, vCross_spec, mem_univ_iff, and_true]\n\ndef converse (x : TSet \u03b1) : TSet \u03b1 :=\n  converse' h\u03b2 h\u03b3 h\u03b4 x \u2293' orderedPairs h\u03b2 h\u03b3 h\u03b4\n\n@[simp]\ntheorem op_mem_converse_iff (x : TSet \u03b1) :\n    \u2200 a b, \u27e8a, b\u27e9' \u2208' converse h\u03b2 h\u03b3 h\u03b4 x \u2194 \u27e8b, a\u27e9' \u2208' x := by\n  intro a b\n  simp only [converse, mem_inter_iff, converse'_spec, mem_orderedPairs_iff, op_inj, exists_and_left,\n    exists_eq', and_true]\n\ndef cross (x y : TSet \u03b3) : TSet \u03b1 :=\n  converse h\u03b2 h\u03b3 h\u03b4 (vCross h\u03b2 h\u03b3 h\u03b4 x) \u2293' vCross h\u03b2 h\u03b3 h\u03b4 y\n\n@[simp]\ntheorem mem_cross_iff (x y : TSet \u03b3) :\n    \u2200 a, a \u2208' cross h\u03b2 h\u03b3 h\u03b4 x y \u2194 \u2203 b c, a = \u27e8b, c\u27e9' \u2227 b \u2208' x \u2227 c \u2208' y := by\n  intro a\n  rw [cross, mem_inter_iff, vCross_spec]\n  constructor\n  \u00b7 rintro \u27e8h\u2081, b, c, rfl, h\u2082\u27e9\n    simp only [op_mem_converse_iff, vCross_spec, op_inj] at h\u2081\n    obtain \u27e8b', c', \u27e8rfl, rfl\u27e9, h\u2081\u27e9 := h\u2081\n    exact \u27e8b, c, rfl, h\u2081, h\u2082\u27e9\n  \u00b7 rintro \u27e8b, c, rfl, h\u2081, h\u2082\u27e9\n    simp only [op_mem_converse_iff, vCross_spec, op_inj]\n    exact \u27e8\u27e8c, b, \u27e8rfl, rfl\u27e9, h\u2081\u27e9, \u27e8b, c, \u27e8rfl, rfl\u27e9, h\u2082\u27e9\u27e9\n\ndef singletonImage (x : TSet \u03b2) : TSet \u03b1 :=\n  singletonImage' h\u03b2 h\u03b3 h\u03b4 h\u03b5 x \u2293' (cross h\u03b2 h\u03b3 h\u03b4 (cardinalOne h\u03b4 h\u03b5) (cardinalOne h\u03b4 h\u03b5))\n\n@[simp]\ntheorem singletonImage_spec (x : TSet \u03b2) :\n    \u2200 z w,\n    \u27e8 {z}', {w}' \u27e9' \u2208' singletonImage h\u03b2 h\u03b3 h\u03b4 h\u03b5 x \u2194 \u27e8z, w\u27e9' \u2208' x := by\n  intro z w\n  rw [singletonImage, mem_inter_iff, singletonImage'_spec, and_iff_left_iff_imp]\n  intro hzw\n  rw [mem_cross_iff]\n  refine \u27e8{z}', {w}', rfl, ?_\u27e9\n  simp only [mem_cardinalOne_iff, singleton_inj, exists_eq', and_self]\n\ntheorem exists_of_mem_singletonImage {x : TSet \u03b2} {z w : TSet \u03b4}\n    (h : \u27e8z, w\u27e9' \u2208' singletonImage h\u03b2 h\u03b3 h\u03b4 h\u03b5 x) :\n    \u2203 a b, z = {a}' \u2227 w = {b}' := by\n  simp only [singletonImage, mem_inter_iff, mem_cross_iff, op_inj, mem_cardinalOne_iff] at h\n  obtain \u27e8-, _, _, \u27e8rfl, rfl\u27e9, \u27e8a, rfl\u27e9, \u27e8b, rfl\u27e9\u27e9 := h\n  exact \u27e8a, b, rfl, rfl\u27e9\n\n/-- Turn a model element encoding a relation into an actual relation. -/\ndef ExternalRel (r : TSet \u03b1) : Rel (TSet \u03b4) (TSet \u03b4) :=\n  \u03bb x y \u21a6 \u27e8x, y\u27e9' \u2208' r\n\n", "theoremStatement": "@[simp]\ntheorem externalRel_converse (r : TSet \u03b1) :\n    ExternalRel h\u03b2 h\u03b3 h\u03b4 (converse h\u03b2 h\u03b3 h\u03b4 r) = (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).inv ", "theoremName": "ConNF.externalRel_converse", "fileCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "theoremCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "file": "ConNF/ConNF/External/Basic.lean", "module": "ConNF.External.Basic", "jsonFile": "ConNF.External.Basic.jsonl", "positionMetadata": {"lineInFile": 129, "tokenPositionInFile": 3793, "theoremPositionInFile": 21}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 14, "numPremises": 37}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  ext\n  simp only [ExternalRel, op_mem_converse_iff, Rel.inv_apply]", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 73}}
{"srcContext": "import ConNF.ModelData.PathEnumeration\n\n/-!\n# Supports\n\nIn this file, we define the notion of a support.\n\n## Main declarations\n\n* `ConNF.BaseSupport`: The type of supports of atoms.\n* `ConNF.Support`: The type of supports of objects of arbitrary type indices.\n-/\n\nuniverse u\n\nopen Cardinal\n\nnamespace ConNF\n\nvariable [Params.{u}]\n\n/-!\n## Base supports\n-/\n\nstructure BaseSupport where\n  atoms : Enumeration Atom\n  nearLitters : Enumeration NearLitter\n\nnamespace BaseSupport\n\ninstance : SuperA BaseSupport (Enumeration Atom) where\n  superA := atoms\n\ninstance : SuperN BaseSupport (Enumeration NearLitter) where\n  superN := nearLitters\n\n@[simp]\ntheorem mk_atoms {a : Enumeration Atom} {N : Enumeration NearLitter} :\n    (BaseSupport.mk a N)\u1d2c = a :=\n  rfl\n\n@[simp]\ntheorem mk_nearLitters {a : Enumeration Atom} {N : Enumeration NearLitter} :\n    (BaseSupport.mk a N)\u1d3a = N :=\n  rfl\n\ntheorem atoms_congr {S T : BaseSupport} (h : S = T) :\n    S\u1d2c = T\u1d2c :=\n  h \u25b8 rfl\n\ntheorem nearLitters_congr {S T : BaseSupport} (h : S = T) :\n    S\u1d3a = T\u1d3a :=\n  h \u25b8 rfl\n\n@[ext]\ntheorem ext {S T : BaseSupport} (h\u2081 : S\u1d2c = T\u1d2c) (h\u2082 : S\u1d3a = T\u1d3a) : S = T := by\n  obtain \u27e8SA, SN\u27e9 := S\n  obtain \u27e8TA, TN\u27e9 := T\n  cases h\u2081\n  cases h\u2082\n  rfl\n\ninstance : SMul BasePerm BaseSupport where\n  smul \u03c0 S := \u27e8\u03c0 \u2022 S\u1d2c, \u03c0 \u2022 S\u1d3a\u27e9\n\n@[simp]\ntheorem smul_atoms (\u03c0 : BasePerm) (S : BaseSupport) :\n    (\u03c0 \u2022 S)\u1d2c = \u03c0 \u2022 S\u1d2c :=\n  rfl\n\n@[simp]\ntheorem smul_nearLitters (\u03c0 : BasePerm) (S : BaseSupport) :\n    (\u03c0 \u2022 S)\u1d3a = \u03c0 \u2022 S\u1d3a :=\n  rfl\n\n@[simp]\ntheorem smul_atoms_eq_of_smul_eq {\u03c0 : BasePerm} {S : BaseSupport}\n    (h : \u03c0 \u2022 S = S) :\n    \u03c0 \u2022 S\u1d2c = S\u1d2c := by\n  rw [\u2190 smul_atoms, h]\n\n@[simp]\ntheorem smul_nearLitters_eq_of_smul_eq {\u03c0 : BasePerm} {S : BaseSupport}\n    (h : \u03c0 \u2022 S = S) :\n    \u03c0 \u2022 S\u1d3a = S\u1d3a := by\n  rw [\u2190 smul_nearLitters, h]\n\ninstance : MulAction BasePerm BaseSupport where\n  one_smul S := by\n    apply ext\n    \u00b7 rw [smul_atoms, one_smul]\n    \u00b7 rw [smul_nearLitters, one_smul]\n  mul_smul \u03c0\u2081 \u03c0\u2082 S := by\n    apply ext\n    \u00b7 rw [smul_atoms, smul_atoms, smul_atoms, mul_smul]\n    \u00b7 rw [smul_nearLitters, smul_nearLitters, smul_nearLitters, mul_smul]\n\ntheorem smul_eq_smul_iff (\u03c0\u2081 \u03c0\u2082 : BasePerm) (S : BaseSupport) :\n    \u03c0\u2081 \u2022 S = \u03c0\u2082 \u2022 S \u2194 (\u2200 a \u2208 S\u1d2c, \u03c0\u2081 \u2022 a = \u03c0\u2082 \u2022 a) \u2227 (\u2200 N \u2208 S\u1d3a, \u03c0\u2081 \u2022 N = \u03c0\u2082 \u2022 N) := by\n  constructor\n  \u00b7 intro h\n    constructor\n    \u00b7 rintro a \u27e8i, ha\u27e9\n      have := congr_arg (\u00b7\u1d2c.rel i (\u03c0\u2081 \u2022 a)) h\n      simp only [smul_atoms, Enumeration.smul_rel, inv_smul_smul, eq_iff_iff] at this\n      have := S\u1d2c.rel_coinjective.coinjective ha (this.mp ha)\n      rw [eq_inv_smul_iff] at this\n      rw [this]\n    \u00b7 rintro N \u27e8i, hN\u27e9\n      have := congr_arg (\u00b7\u1d3a.rel i (\u03c0\u2081 \u2022 N)) h\n      simp only [smul_nearLitters, Enumeration.smul_rel, inv_smul_smul, eq_iff_iff] at this\n      have := S\u1d3a.rel_coinjective.coinjective hN (this.mp hN)\n      rw [eq_inv_smul_iff] at this\n      rw [this]\n  \u00b7 intro h\n    ext : 2\n    \u00b7 rfl\n    \u00b7 ext i a : 3\n      rw [smul_atoms, smul_atoms, Enumeration.smul_rel, Enumeration.smul_rel]\n      constructor\n      \u00b7 intro ha\n        have := h.1 _ \u27e8i, ha\u27e9\n        rw [smul_inv_smul, \u2190 inv_smul_eq_iff] at this\n        rwa [this]\n      \u00b7 intro ha\n        have := h.1 _ \u27e8i, ha\u27e9\n        rw [smul_inv_smul, smul_eq_iff_eq_inv_smul] at this\n        rwa [\u2190 this]\n    \u00b7 rfl\n    \u00b7 ext i a : 3\n      rw [smul_nearLitters, smul_nearLitters, Enumeration.smul_rel, Enumeration.smul_rel]\n      constructor\n      \u00b7 intro hN\n        have := h.2 _ \u27e8i, hN\u27e9\n        rw [smul_inv_smul, \u2190 inv_smul_eq_iff] at this\n        rwa [this]\n      \u00b7 intro hN\n        have := h.2 _ \u27e8i, hN\u27e9\n        rw [smul_inv_smul, smul_eq_iff_eq_inv_smul] at this\n        rwa [\u2190 this]\n\ntheorem smul_eq_iff (\u03c0 : BasePerm) (S : BaseSupport) :\n    \u03c0 \u2022 S = S \u2194 (\u2200 a \u2208 S\u1d2c, \u03c0 \u2022 a = a) \u2227 (\u2200 N \u2208 S\u1d3a, \u03c0 \u2022 N = N) := by\n  have := smul_eq_smul_iff \u03c0 1 S\n  simp only [one_smul] at this\n  exact this\n\nnoncomputable instance : Add BaseSupport where\n  add S T := \u27e8S\u1d2c + T\u1d2c, S\u1d3a + T\u1d3a\u27e9\n\n@[simp]\ntheorem add_atoms (S T : BaseSupport) :\n    (S + T)\u1d2c = S\u1d2c + T\u1d2c :=\n  rfl\n\n@[simp]\ntheorem add_nearLitters (S T : BaseSupport) :\n    (S + T)\u1d3a = S\u1d3a + T\u1d3a :=\n  rfl\n\nend BaseSupport\n\ndef baseSupportEquiv : BaseSupport \u2243 Enumeration Atom \u00d7 Enumeration NearLitter where\n  toFun S := (S\u1d2c, S\u1d3a)\n  invFun S := \u27e8S.1, S.2\u27e9\n  left_inv _ := rfl\n  right_inv _ := rfl\n\ntheorem card_baseSupport : #BaseSupport = #\u03bc := by\n  rw [Cardinal.eq.mpr \u27e8baseSupportEquiv\u27e9, mk_prod, lift_id, lift_id,\n    card_enumeration_eq card_atom, card_enumeration_eq card_nearLitter, mul_eq_self aleph0_lt_\u03bc.le]\n\n/-!\n## Structural supports\n-/\n\nstructure Support (\u03b1 : TypeIndex) where\n  atoms : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)\n  nearLitters : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)\n\nnamespace Support\n\nvariable {\u03b1 \u03b2 : TypeIndex}\n\ninstance : SuperA (Support \u03b1) (Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) where\n  superA := atoms\n\ninstance : SuperN (Support \u03b1) (Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) where\n  superN := nearLitters\n\n@[simp]\ntheorem mk_atoms (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) (F : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) :\n    (\u27e8E, F\u27e9 : Support \u03b1)\u1d2c = E :=\n  rfl\n\n@[simp]\ntheorem mk_nearLitters (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) (F : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) :\n    (\u27e8E, F\u27e9 : Support \u03b1)\u1d3a = F :=\n  rfl\n\ninstance : Derivative (Support \u03b1) (Support \u03b2) \u03b1 \u03b2 where\n  deriv S A := \u27e8S\u1d2c \u21d8 A, S\u1d3a \u21d8 A\u27e9\n\ninstance : Coderivative (Support \u03b2) (Support \u03b1) \u03b1 \u03b2 where\n  coderiv S A := \u27e8S\u1d2c \u21d7 A, S\u1d3a \u21d7 A\u27e9\n\ninstance : BotDerivative (Support \u03b1) BaseSupport \u03b1 where\n  botDeriv S A := \u27e8S\u1d2c \u21d8. A, S\u1d3a \u21d8. A\u27e9\n  botSderiv S := \u27e8S\u1d2c \u2198., S\u1d3a \u2198.\u27e9\n  botDeriv_single S h := by dsimp only; rw [botDeriv_single, botDeriv_single]\n\n@[simp]\ntheorem deriv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u03b2) :\n    S\u1d2c \u21d8 A = (S \u21d8 A)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem deriv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u03b2) :\n    S\u1d3a \u21d8 A = (S \u21d8 A)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem sderiv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (h : \u03b2 < \u03b1) :\n    S\u1d2c \u2198 h = (S \u2198 h)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem sderiv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (h : \u03b2 < \u03b1) :\n    S\u1d3a \u2198 h = (S \u2198 h)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem coderiv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    S\u1d2c \u21d7 A = (S \u21d7 A)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem coderiv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    S\u1d3a \u21d7 A = (S \u21d7 A)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem scoderiv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (h : \u03b2 < \u03b1) :\n    S\u1d2c \u2197 h = (S \u2197 h)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem scoderiv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (h : \u03b2 < \u03b1) :\n    S\u1d3a \u2197 h = (S \u2197 h)\u1d3a :=\n  rfl\n\n", "theoremStatement": "@[simp]\ntheorem derivBot_atoms {\u03b1 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u22a5) :\n    S\u1d2c \u21d8. A = (S \u21d8. A)\u1d2c ", "theoremName": "ConNF.Support.derivBot_atoms", "fileCreated": {"commit": "39c33b4a743bea62dbcc549548b712ffd38ca65c", "date": "2024-12-05"}, "theoremCreated": {"commit": "d9f28df240ac4df047c3af0d236aed2e437e571f", "date": "2025-01-07"}, "file": "ConNF/ConNF/ModelData/Support.lean", "module": "ConNF.ModelData.Support", "jsonFile": "ConNF.ModelData.Support.jsonl", "positionMetadata": {"lineInFile": 253, "tokenPositionInFile": 6418, "theoremPositionInFile": 24}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 5, "repositoryPremises": true, "numRepositoryPremises": 14, "numPremises": 19}, "proofMetadata": {"hasProof": true, "proof": ":=\n  rfl", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 8}}
{"srcContext": "import ConNF.Model.Externalise\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b2 \u03b3 : \u039b} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n\nnamespace Support\n\ntheorem not_mem_scoderiv_botDeriv (S : Support \u03b3) (N : NearLitter) :\n    N \u2209 (S \u2197 h\u03b3 \u21d8. (Path.nil \u2198.))\u1d3a := by\n  rintro \u27e8i, \u27e8A, N'\u27e9, h\u2081, h\u2082\u27e9\n  simp only [Prod.mk.injEq] at h\u2082\n  cases A\n  case sderiv \u03b4 A h\u03b4 _ =>\n    simp only [Path.deriv_sderiv] at h\u2082\n    cases A\n    case nil => cases h\u2082.1\n    case sderiv \u03b6 A h\u03b6 _ =>\n      simp only [Path.deriv_sderiv] at h\u2082\n      cases h\u2082.1\n\nvariable [Level] [LtLevel \u03b2]\n\ntheorem not_mem_strong_botDeriv (S : Support \u03b3) (N : NearLitter) :\n    N \u2209 ((S \u2197 h\u03b3).strong \u21d8. (Path.nil \u2198.))\u1d3a := by\n  rintro h\n  rw [strong, close_nearLitters, preStrong_nearLitters, Enumeration.mem_add_iff] at h\n  obtain h | h := h\n  \u00b7 exact not_mem_scoderiv_botDeriv S N h\n  \u00b7 rw [mem_constrainsNearLitters_nearLitters] at h\n    obtain \u27e8B, N', hN', h\u27e9 := h\n    cases h using Relation.ReflTransGen.head_induction_on\n    case refl => exact not_mem_scoderiv_botDeriv S N hN'\n    case head x hx\u2081 hx\u2082 _ =>\n      obtain \u27e8\u27e8\u03b3, \u03b4, \u03b5, h\u03b4, h\u03b5, h\u03b4\u03b5, A\u27e9, t, B, hB, hN, ht\u27e9 := hx\u2082\n      simp only at hB\n      cases B\n      case nil =>\n        cases hB\n        obtain \u27e8C, N''\u27e9 := x\n        simp only at ht\n        cases ht.1\n        change _ \u2208 t.support\u1d3a at hN\n        rw [t.support_supports.2 rfl] at hN\n        obtain \u27e8i, hN\u27e9 := hN\n        cases hN\n      case sderiv \u03b4 B h\u03b4 _ _ =>\n        cases B\n        case nil => cases hB\n        case sderiv \u03b6 B h\u03b6 _ _ => cases hB\n\ntheorem raise_preStrong' (S : Support \u03b1) (hS : S.Strong) (T : Support \u03b3) (\u03c1 : AllPerm \u03b2)\n    (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2) :\n    (S + (\u03c1\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim).PreStrong := by\n  apply hS.toPreStrong.add\n  constructor\n  intro A N hN P t hA ht\n  obtain \u27e8A, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv hN\n  simp only [scoderiv_botDeriv_eq, add_derivBot, smul_derivBot,\n    BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters, interferenceSupport_nearLitters,\n    Enumeration.mem_add_iff, Enumeration.mem_smul, Enumeration.not_mem_empty, or_false] at hN\n  obtain \u27e8\u03b4, \u03b5, \u03b6, h\u03b5, h\u03b6, h\u03b5\u03b6, B\u27e9 := P\n  dsimp only at *\n  cases A\n  case sderiv \u03b6' A h\u03b6' _ =>\n    rw [\u2190 Path.coderiv_deriv] at hA\n    cases Path.sderiv_index_injective hA\n    apply Path.sderiv_left_inj.mp at hA\n    cases A\n    case nil =>\n      cases hA\n      cases not_mem_strong_botDeriv T _ hN\n    case sderiv \u03b9 A h\u03b9 _ _ =>\n      rw [\u2190 Path.coderiv_deriv] at hA\n      cases Path.sderiv_index_injective hA\n      cases hA\n      haveI : LtLevel \u03b4 := \u27e8A.le.trans_lt LtLevel.elim\u27e9\n      haveI : LtLevel \u03b5 := \u27e8h\u03b5.trans LtLevel.elim\u27e9\n      haveI : LtLevel \u03b6 := \u27e8h\u03b6.trans LtLevel.elim\u27e9\n      have := (T \u2197 h\u03b3).strong_strong.support_le hN \u27e8\u03b4, \u03b5, \u03b6, h\u03b5, h\u03b6, h\u03b5\u03b6, A\u27e9\n          (\u03c1\u207b\u00b9 \u21d8 A \u2198 h\u03b5 \u2022 t) rfl ?_\n      \u00b7 simp only [Tangle.smul_support, allPermSderiv_forget, allPermDeriv_forget,\n          allPermForget_inv, Tree.inv_deriv, Tree.inv_sderiv] at this\n        have := smul_le_smul this (\u03c1\u1d41 \u21d8 A \u2198 h\u03b5)\n        simp only [smul_inv_smul] at this\n        apply le_trans this\n        intro B\n        constructor\n        \u00b7 intro a ha\n          simp only [smul_derivBot, Tree.sderiv_apply, Tree.deriv_apply, Path.deriv_scoderiv,\n            deriv_derivBot, Enumeration.mem_smul] at ha\n          rw [deriv_derivBot, \u2190 Path.deriv_scoderiv, Path.coderiv_deriv', scoderiv_botDeriv_eq,]\n          simp only [Path.deriv_scoderiv, add_derivBot, smul_derivBot,\n            BaseSupport.add_atoms, BaseSupport.smul_atoms, Enumeration.mem_add_iff,\n            Enumeration.mem_smul]\n          exact Or.inl ha\n        \u00b7 intro N hN\n          simp only [smul_derivBot, Tree.sderiv_apply, Tree.deriv_apply, Path.deriv_scoderiv,\n            deriv_derivBot, Enumeration.mem_smul] at hN\n          rw [deriv_derivBot, \u2190 Path.deriv_scoderiv, Path.coderiv_deriv', scoderiv_botDeriv_eq,]\n          simp only [Path.deriv_scoderiv, add_derivBot, smul_derivBot,\n            BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters, Enumeration.mem_add_iff,\n            Enumeration.mem_smul]\n          exact Or.inl hN\n      \u00b7 rw [\u2190 smul_fuzz h\u03b5 h\u03b6 h\u03b5\u03b6, \u2190 ht]\n        simp only [Path.botSderiv_coe_eq, BasePerm.smul_nearLitter_litter, allPermDeriv_forget,\n          allPermForget_inv, Tree.inv_deriv, Tree.inv_sderiv, Tree.inv_sderivBot]\n        rfl\n\ntheorem raise_closed' (S : Support \u03b1) (hS : S.Strong) (T : Support \u03b3) (\u03c1 : AllPerm \u03b2)\n    (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n    (h\u03c1 : \u03c1\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim) :\n    (S + (\u03c1\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim).Closed := by\n  constructor\n  intro A\n  constructor\n  intro N\u2081 N\u2082 hN\u2081 hN\u2082 a ha\n  simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff,\n    BaseSupport.add_atoms] at hN\u2081 hN\u2082 \u22a2\n  obtain hN\u2081 | hN\u2081 := hN\u2081\n  \u00b7 obtain hN\u2082 | hN\u2082 := hN\u2082\n    \u00b7 exact Or.inl ((hS.closed A).interference_subset hN\u2081 hN\u2082 a ha)\n    \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv hN\u2082\n      simp only [smul_add, scoderiv_botDeriv_eq, add_derivBot, smul_derivBot,\n        BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters, Enumeration.mem_add_iff,\n        Enumeration.mem_smul, BaseSupport.add_atoms, BaseSupport.smul_atoms] at hN\u2081 hN\u2082 \u22a2\n      refine Or.inr (Or.inr ?_)\n      rw [mem_interferenceSupport_atoms]\n      refine \u27e8(\u03c1\u1d41 B)\u207b\u00b9 \u2022 N\u2081, ?_, (\u03c1\u1d41 B)\u207b\u00b9 \u2022 N\u2082, ?_, ?_\u27e9\n      \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n        rw [\u2190 Enumeration.mem_smul, \u2190 BaseSupport.smul_nearLitters, \u2190 smul_derivBot, h\u03c1]\n        exact Or.inl hN\u2081\n      \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n        simp only [interferenceSupport_nearLitters, Enumeration.not_mem_empty, or_false] at hN\u2082\n        exact Or.inr hN\u2082\n      \u00b7 rw [\u2190 BasePerm.smul_interference]\n        exact Set.smul_mem_smul_set ha\n  \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv hN\u2081\n    simp only [smul_add, scoderiv_botDeriv_eq, add_derivBot, smul_derivBot,\n      BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters, Enumeration.mem_add_iff,\n      Enumeration.mem_smul, BaseSupport.add_atoms, BaseSupport.smul_atoms] at hN\u2081 hN\u2082 \u22a2\n    refine Or.inr (Or.inr ?_)\n    rw [mem_interferenceSupport_atoms]\n    refine \u27e8(\u03c1\u1d41 B)\u207b\u00b9 \u2022 N\u2081, ?_, (\u03c1\u1d41 B)\u207b\u00b9 \u2022 N\u2082, ?_, ?_\u27e9\n    \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n      simp only [interferenceSupport_nearLitters, Enumeration.not_mem_empty, or_false] at hN\u2081\n      exact Or.inr hN\u2081\n    \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n      simp only [interferenceSupport_nearLitters, Enumeration.not_mem_empty, or_false] at hN\u2082\n      obtain hN\u2082 | hN\u2082 := hN\u2082\n      \u00b7 rw [\u2190 Enumeration.mem_smul, \u2190 BaseSupport.smul_nearLitters, \u2190 smul_derivBot, h\u03c1]\n        exact Or.inl hN\u2082\n      \u00b7 exact Or.inr hN\u2082\n    \u00b7 rw [\u2190 BasePerm.smul_interference]\n      exact Set.smul_mem_smul_set ha\n\ntheorem raise_strong' (S : Support \u03b1) (hS : S.Strong) (T : Support \u03b3) (\u03c1 : AllPerm \u03b2)\n    (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n    (h\u03c1 : \u03c1\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim) :\n    (S + (\u03c1\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim).Strong :=\n  \u27e8raise_preStrong' S hS T \u03c1 h\u03b3, raise_closed' S hS T \u03c1 h\u03b3 h\u03c1\u27e9\n\ntheorem convAtoms_injective_of_fixes {S : Support \u03b1} {T : Support \u03b3}\n    {\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n    (h\u03c1\u2081 : \u03c1\u2081\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (h\u03c1\u2082 : \u03c1\u2082\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (A : \u2191\u03b1 \u219d \u22a5) :\n    (convAtoms\n      (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong + (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197\n        LtLevel.elim)\n      (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong + (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197\n        LtLevel.elim) A).Injective := by\n  rw [Support.smul_eq_iff] at h\u03c1\u2081 h\u03c1\u2082\n  constructor\n  rintro a\u2081 a\u2082 a\u2083 \u27e8i, hi\u2081, hi\u2082\u27e9 \u27e8j, hj\u2081, hj\u2082\u27e9\n  simp only [add_derivBot, BaseSupport.add_atoms, Rel.inv_apply,\n    Enumeration.rel_add_iff] at hi\u2081 hi\u2082 hj\u2081 hj\u2082\n  obtain hi\u2081 | \u27e8i, rfl, hi\u2081\u27e9 := hi\u2081\n  \u00b7 obtain hi\u2082 | \u27e8i', rfl, _\u27e9 := hi\u2082\n    swap\n    \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hi\u2081\u27e9\n      simp only [add_lt_iff_neg_left] at this\n      cases (\u03ba_zero_le i').not_lt this\n    cases (Enumeration.rel_coinjective _).coinjective hi\u2081 hi\u2082\n    obtain hj\u2081 | \u27e8j, rfl, hj\u2081\u27e9 := hj\u2081\n    \u00b7 obtain hj\u2082 | \u27e8j', rfl, _\u27e9 := hj\u2082\n      \u00b7 exact (Enumeration.rel_coinjective _).coinjective hj\u2082 hj\u2081\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2081\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j').not_lt this\n    \u00b7 obtain hj\u2082 | hj\u2082 := hj\u2082\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2082\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j).not_lt this\n      \u00b7 simp only [add_right_inj, exists_eq_left] at hj\u2082\n        obtain \u27e8B, rfl\u27e9 := eq_of_atom_mem_scoderiv_botDeriv \u27e8j, hj\u2081\u27e9\n        simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_atoms,\n          BaseSupport.add_atoms, Enumeration.smul_rel, add_right_inj, exists_eq_left] at hj\u2081 hj\u2082\n        have := (Enumeration.rel_coinjective _).coinjective hj\u2081 hj\u2082\n        rw [\u2190 (h\u03c1\u2082 B).1 a\u2081 \u27e8_, hi\u2081\u27e9, inv_smul_smul, inv_smul_eq_iff, (h\u03c1\u2081 B).1 a\u2081 \u27e8_, hi\u2081\u27e9] at this\n        exact this.symm\n  \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_atom_mem_scoderiv_botDeriv \u27e8i, hi\u2081\u27e9\n    simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_atoms,\n      BaseSupport.add_atoms, Enumeration.smul_rel, add_right_inj, exists_eq_left] at hi\u2081 hi\u2082 hj\u2081 hj\u2082\n    obtain hi\u2082 | hi\u2082 := hi\u2082\n    \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hi\u2082\u27e9\n      simp only [add_lt_iff_neg_left] at this\n      cases (\u03ba_zero_le i).not_lt this\n    have hi := (Enumeration.rel_coinjective _).coinjective hi\u2081 hi\u2082\n    suffices hj : (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 a\u2082 = (\u03c1\u2082\u1d41 B)\u207b\u00b9 \u2022 a\u2083 by\n      rwa [\u2190 hj, smul_left_cancel_iff] at hi\n    obtain hj\u2081 | \u27e8j, rfl, hj\u2081\u27e9 := hj\u2081\n    \u00b7 obtain hj\u2082 | \u27e8j', rfl, _\u27e9 := hj\u2082\n      \u00b7 rw [\u2190 (h\u03c1\u2081 B).1 a\u2082 \u27e8_, hj\u2081\u27e9, \u2190 (h\u03c1\u2082 B).1 a\u2083 \u27e8_, hj\u2082\u27e9, inv_smul_smul, inv_smul_smul]\n        exact (Enumeration.rel_coinjective _).coinjective hj\u2081 hj\u2082\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2081\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j').not_lt this\n    \u00b7 obtain hj\u2082 | hj\u2082 := hj\u2082\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2082\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j).not_lt this\n      \u00b7 simp only [add_right_inj, exists_eq_left] at hj\u2082\n        exact (Enumeration.rel_coinjective _).coinjective hj\u2081 hj\u2082\n\ntheorem atomMemRel_le_of_fixes {S : Support \u03b1} {T : Support \u03b3}\n    {\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n    (h\u03c1\u2081 : \u03c1\u2081\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (h\u03c1\u2082 : \u03c1\u2082\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (A : \u2191\u03b1 \u219d \u22a5) :\n    atomMemRel (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A \u2264\n    atomMemRel (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A := by\n  rw [Support.smul_eq_iff] at h\u03c1\u2081 h\u03c1\u2082\n  rintro i j \u27e8N, hN, a, haN, ha\u27e9\n  simp only [add_derivBot, BaseSupport.add_atoms, Rel.inv_apply, Enumeration.rel_add_iff,\n    BaseSupport.add_nearLitters] at ha hN\n  obtain hN | \u27e8i, rfl, hi\u27e9 := hN\n  \u00b7 obtain ha | \u27e8j, rfl, hj\u27e9 := ha\n    \u00b7 exact \u27e8N, Or.inl hN, a, haN, Or.inl ha\u27e9\n    \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_atom_mem_scoderiv_botDeriv \u27e8j, hj\u27e9\n      simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_atoms,\n        BaseSupport.add_atoms, Enumeration.smul_rel] at hj hN\n      refine \u27e8N, Or.inl hN, \u03c1\u2082\u1d41 B \u2022 (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 a, ?_, ?_\u27e9\n      \u00b7 dsimp only\n        rw [\u2190 (h\u03c1\u2082 B).2 N \u27e8_, hN\u27e9, BasePerm.smul_nearLitter_atoms, Set.smul_mem_smul_set_iff]\n        have := (h\u03c1\u2081 B).2 N \u27e8_, hN\u27e9\n        rw [smul_eq_iff_eq_inv_smul] at this\n        rwa [this, BasePerm.smul_nearLitter_atoms, Set.smul_mem_smul_set_iff]\n      \u00b7 rw [Rel.inv_apply, add_derivBot, BaseSupport.add_atoms, Enumeration.rel_add_iff]\n        simp only [add_right_inj, scoderiv_botDeriv_eq, smul_derivBot, add_derivBot,\n          BaseSupport.smul_atoms, BaseSupport.add_atoms, Enumeration.smul_rel, inv_smul_smul,\n          exists_eq_left]\n        exact Or.inr hj\n  \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv \u27e8i, hi\u27e9\n    simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_atoms,\n      BaseSupport.add_atoms, Enumeration.smul_rel] at hi ha\n    obtain ha | \u27e8j, rfl, hj\u27e9 := ha\n    \u00b7 refine \u27e8\u03c1\u2082\u1d41 B \u2022 (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 N, ?_, a, ?_, Or.inl ha\u27e9\n      \u00b7 rw [add_derivBot, BaseSupport.add_nearLitters, Enumeration.rel_add_iff]\n        simp only [add_right_inj, scoderiv_botDeriv_eq, smul_derivBot, add_derivBot,\n          BaseSupport.smul_nearLitters, BaseSupport.add_nearLitters, Enumeration.smul_rel,\n          inv_smul_smul, exists_eq_left]\n        exact Or.inr hi\n      \u00b7 dsimp only\n        rw [\u2190 (h\u03c1\u2082 B).1 a \u27e8_, ha\u27e9, BasePerm.smul_nearLitter_atoms, Set.smul_mem_smul_set_iff]\n        have := (h\u03c1\u2081 B).1 a \u27e8_, ha\u27e9\n        rw [smul_eq_iff_eq_inv_smul] at this\n        rwa [this, BasePerm.smul_nearLitter_atoms, Set.smul_mem_smul_set_iff]\n    \u00b7 refine \u27e8\u03c1\u2082\u1d41 B \u2022 (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 N, ?_, \u03c1\u2082\u1d41 B \u2022 (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 a, ?_, ?_\u27e9\n      \u00b7 rw [add_derivBot, BaseSupport.add_nearLitters, Enumeration.rel_add_iff]\n        simp only [add_right_inj, scoderiv_botDeriv_eq, smul_derivBot, add_derivBot,\n          BaseSupport.smul_nearLitters, BaseSupport.add_nearLitters, Enumeration.smul_rel,\n          inv_smul_smul, exists_eq_left]\n        exact Or.inr hi\n      \u00b7 simp only [BasePerm.smul_nearLitter_atoms, Set.smul_mem_smul_set_iff]\n        exact haN\n      \u00b7 rw [Rel.inv_apply, add_derivBot, BaseSupport.add_atoms, Enumeration.rel_add_iff]\n        simp only [add_right_inj, scoderiv_botDeriv_eq, smul_derivBot, add_derivBot,\n          BaseSupport.smul_atoms, BaseSupport.add_atoms, Enumeration.smul_rel, inv_smul_smul,\n          exists_eq_left]\n        exact Or.inr hj\n\ntheorem convNearLitters_cases {S : Support \u03b1} {T : Support \u03b3}\n    {\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n    {A : \u03b1 \u219d \u22a5} {N\u2081 N\u2082 : NearLitter} :\n  convNearLitters\n    (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim)\n    (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A N\u2081 N\u2082 \u2192\n    N\u2081 = N\u2082 \u2227 N\u2081 \u2208 (S \u21d8. A)\u1d3a \u2228\n    \u2203 B : \u03b2 \u219d \u22a5, A = B \u2197 LtLevel.elim \u2227 (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 N\u2081 = (\u03c1\u2082\u1d41 B)\u207b\u00b9 \u2022 N\u2082 \u2227\n      (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 N\u2081 \u2208 (((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport) \u21d8. B)\u1d3a := by\n  rintro \u27e8i, hN\u2081, hN\u2082\u27e9\n  simp only [add_derivBot, BaseSupport.add_nearLitters, Rel.inv_apply,\n    Enumeration.rel_add_iff] at hN\u2081 hN\u2082\n  obtain hN\u2081 | \u27e8i, rfl, hN\u2081\u27e9 := hN\u2081\n  \u00b7 obtain hN\u2082 | \u27e8i, rfl, hN\u2082\u27e9 := hN\u2082\n    swap\n    \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hN\u2081\u27e9\n      simp only [add_lt_iff_neg_left] at this\n      cases (\u03ba_zero_le i).not_lt this\n    exact Or.inl \u27e8(Enumeration.rel_coinjective _).coinjective hN\u2081 hN\u2082, _, hN\u2081\u27e9\n  \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv \u27e8i, hN\u2081\u27e9\n    simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_nearLitters,\n      BaseSupport.add_nearLitters, Enumeration.smul_rel, add_right_inj, exists_eq_left] at hN\u2081 hN\u2082\n    obtain hN\u2082 | hN\u2082 := hN\u2082\n    \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hN\u2082\u27e9\n      simp only [add_lt_iff_neg_left] at this\n      cases (\u03ba_zero_le i).not_lt this\n    exact Or.inr \u27e8B, rfl, (Enumeration.rel_coinjective _).coinjective hN\u2081 hN\u2082, _, hN\u2081\u27e9\n\ntheorem inflexible_of_inflexible_of_fixes {S : Support \u03b1} {T : Support \u03b3}\n    {\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n    (h\u03c1\u2081 : \u03c1\u2081\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (h\u03c1\u2082 : \u03c1\u2082\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    {A : \u03b1 \u219d \u22a5} {N\u2081 N\u2082 : NearLitter} :\n    convNearLitters\n      (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim)\n      (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A N\u2081 N\u2082 \u2192\n      \u2200 (P : InflexiblePath \u2191\u03b1) (t : Tangle P.\u03b4), A = P.A \u2198 P.h\u03b5 \u2198. \u2192 N\u2081\u1d38 = fuzz P.h\u03b4\u03b5 t \u2192\n      \u2203 \u03c1 : AllPerm P.\u03b4, N\u2082\u1d38 = fuzz P.h\u03b4\u03b5 (\u03c1 \u2022 t) := by\n  rintro hN \u27e8\u03b3, \u03b4, \u03b5, h\u03b4, h\u03b5, h\u03b4\u03b5, A\u27e9 t hA ht\n  haveI : LeLevel \u03b3 := \u27e8A.le\u27e9\n  haveI : LtLevel \u03b4 := \u27e8h\u03b4.trans_le LeLevel.elim\u27e9\n  haveI : LtLevel \u03b5 := \u27e8h\u03b5.trans_le LeLevel.elim\u27e9\n  obtain \u27e8rfl, _\u27e9 | \u27e8B, rfl, hN'\u27e9 := convNearLitters_cases hN\n  \u00b7 use 1\n    rw [one_smul, ht]\n  \u00b7 clear hN\n    cases B\n    case sderiv \u03b5 B h\u03b5' _ =>\n      rw [\u2190 Path.coderiv_deriv] at hA\n      cases Path.sderiv_index_injective hA\n      apply Path.sderiv_path_injective at hA\n      cases B\n      case nil =>\n        simp only [Path.botSderiv_coe_eq, add_derivBot, BaseSupport.add_nearLitters,\n          interferenceSupport_nearLitters, Enumeration.add_empty] at hN'\n        cases not_mem_strong_botDeriv _ _ hN'.2\n      case sderiv \u03b6 B h\u03b6 _ _ =>\n        rw [\u2190 Path.coderiv_deriv] at hA\n        cases Path.sderiv_index_injective hA\n        apply Path.sderiv_path_injective at hA\n        dsimp only at hA h\u03b6 h\u03b5' B t\n        cases hA\n        use (\u03c1\u2082 * \u03c1\u2081\u207b\u00b9) \u21d8 B \u2198 h\u03b4\n        rw [inv_smul_eq_iff] at hN'\n        rw [\u2190 smul_fuzz h\u03b4 h\u03b5 h\u03b4\u03b5, \u2190 ht, hN'.1]\n        simp only [allPermDeriv_forget, allPermForget_mul, allPermForget_inv, Tree.mul_deriv,\n          Tree.inv_deriv, Tree.mul_sderiv, Tree.inv_sderiv, Tree.mul_sderivBot, Tree.inv_sderivBot,\n          Path.botSderiv_coe_eq, BasePerm.smul_nearLitter_litter, mul_smul]\n        erw [inv_smul_smul, smul_inv_smul]\n\ntheorem atoms_of_inflexible_of_fixes {S : Support \u03b1} (hS : S.Strong) {T : Support \u03b3}\n    {\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n    (h\u03c1\u2081 : \u03c1\u2081\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (h\u03c1\u2082 : \u03c1\u2082\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (A : \u03b1 \u219d \u22a5) (N\u2081 N\u2082 : NearLitter) (P : InflexiblePath \u2191\u03b1) (t : Tangle P.\u03b4) (\u03c1 : AllPerm P.\u03b4) :\n    A = P.A \u2198 P.h\u03b5 \u2198. \u2192 N\u2081\u1d38 = fuzz P.h\u03b4\u03b5 t \u2192 N\u2082\u1d38 = fuzz P.h\u03b4\u03b5 (\u03c1 \u2022 t) \u2192\n    convNearLitters\n      (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim)\n      (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A N\u2081 N\u2082 \u2192\n    \u2200 (B : P.\u03b4 \u219d \u22a5), \u2200 a \u2208 (t.support \u21d8. B)\u1d2c, \u2200 (i : \u03ba),\n      ((S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong + (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197\n        LtLevel.elim) \u21d8. (P.A \u2198 P.h\u03b4 \u21d8 B))\u1d2c.rel i a \u2192\n      ((S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong + (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197\n        LtLevel.elim) \u21d8. (P.A \u2198 P.h\u03b4 \u21d8 B))\u1d2c.rel i (\u03c1\u1d41 B \u2022 a) := by\n  rw [Support.smul_eq_iff] at h\u03c1\u2081 h\u03c1\u2082\n  obtain \u27e8\u03b3, \u03b4, \u03b5, h\u03b4, h\u03b5, h\u03b4\u03b5, B\u27e9 := P\n  haveI : LeLevel \u03b3 := \u27e8B.le\u27e9\n  haveI : LtLevel \u03b4 := \u27e8h\u03b4.trans_le LeLevel.elim\u27e9\n  haveI : LtLevel \u03b5 := \u27e8h\u03b5.trans_le LeLevel.elim\u27e9\n  dsimp only at t \u03c1 \u22a2\n  intro hA hN\u2081 hN\u2082 hN C a ha i hi\n  obtain \u27e8rfl, hN'\u27e9 | \u27e8A, rfl, hN\u2081', hN\u2082'\u27e9 := convNearLitters_cases hN\n  \u00b7 have haS := (hS.support_le hN' \u27e8\u03b3, \u03b4, \u03b5, h\u03b4, h\u03b5, h\u03b4\u03b5, _\u27e9 t hA hN\u2081 _).1 a ha\n    rw [hN\u2082] at hN\u2081\n    have h\u03c1t := congr_arg Tangle.support (fuzz_injective hN\u2081)\n    rw [Tangle.smul_support, Support.smul_eq_iff] at h\u03c1t\n    simp only [add_derivBot, BaseSupport.add_atoms, Enumeration.rel_add_iff] at hi \u22a2\n    rw [(h\u03c1t C).1 a ha]\n    obtain hi | \u27e8i, rfl, hi\u27e9 := hi\n    \u00b7 exact Or.inl hi\n    \u00b7 simp only [add_right_inj, exists_eq_left]\n      obtain \u27e8D, hD\u27e9 := eq_of_atom_mem_scoderiv_botDeriv \u27e8i, hi\u27e9\n      cases B using Path.recScoderiv\n      case nil =>\n        cases Path.scoderiv_index_injective hD\n        cases Path.scoderiv_left_inj.mp hD\n        simp only [hD, Path.coderiv_deriv, Path.coderiv_deriv', scoderiv_botDeriv_eq, smul_derivBot,\n          add_derivBot, BaseSupport.smul_atoms, BaseSupport.add_atoms, Enumeration.smul_rel] at hi \u22a2\n        rw [deriv_derivBot, hD] at haS\n        rw [\u2190 (h\u03c1\u2082 _).1 a haS, inv_smul_smul]\n        rw [\u2190 (h\u03c1\u2081 _).1 a haS, inv_smul_smul] at hi\n        exact Or.inr hi\n      case scoderiv \u03b6 B h\u03b6' _ =>\n        rw [Path.coderiv_deriv, Path.coderiv_deriv'] at hD\n        cases Path.scoderiv_index_injective hD\n        rw [Path.scoderiv_left_inj] at hD\n        cases hD\n        simp only [Path.coderiv_deriv, Path.coderiv_deriv', scoderiv_botDeriv_eq, smul_derivBot,\n          add_derivBot, BaseSupport.smul_atoms, BaseSupport.add_atoms, Enumeration.smul_rel] at hi \u22a2\n        rw [deriv_derivBot, Path.coderiv_deriv, Path.coderiv_deriv'] at haS\n        rw [\u2190 (h\u03c1\u2082 _).1 a haS, inv_smul_smul]\n        rw [\u2190 (h\u03c1\u2081 _).1 a haS, inv_smul_smul] at hi\n        exact Or.inr hi\n  \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, interferenceSupport_nearLitters,\n      Enumeration.add_empty] at hN\u2082'\n    cases A\n    case sderiv \u03b6 A h\u03b6' _ =>\n      rw [\u2190 Path.coderiv_deriv] at hA\n      cases Path.sderiv_index_injective hA\n      apply Path.sderiv_path_injective at hA\n      cases A\n      case nil =>\n        cases hA\n        cases not_mem_strong_botDeriv _ _ hN\u2082'\n      case sderiv \u03b6 A h\u03b6 _ _ =>\n        rw [\u2190 Path.coderiv_deriv] at hA\n        cases Path.sderiv_index_injective hA\n        apply Path.sderiv_path_injective at hA\n        cases hA\n        simp only [Path.coderiv_deriv, Path.coderiv_deriv', add_derivBot, scoderiv_botDeriv_eq,\n          smul_derivBot, BaseSupport.add_atoms, BaseSupport.smul_atoms] at hi \u22a2\n        have : N\u2082\u1d38 = (\u03c1\u2082 \u21d8 A)\u1d41 \u2198 h\u03b6 \u2198. \u2022 (\u03c1\u2081\u207b\u00b9 \u21d8 A)\u1d41 \u2198 h\u03b6 \u2198. \u2022 fuzz h\u03b4\u03b5 t := by\n          rw [inv_smul_eq_iff] at hN\u2081'\n          rw [hN\u2081', Path.botSderiv_coe_eq, BasePerm.smul_nearLitter_litter,\n            BasePerm.smul_nearLitter_litter, smul_smul, smul_eq_iff_eq_inv_smul,\n            mul_inv_rev, inv_inv, mul_smul, \u2190 Tree.inv_apply, \u2190 allPermForget_inv] at hN\u2081\n          rw [hN\u2081]\n          simp only [allPermForget_inv, Tree.inv_apply, allPermDeriv_forget, Tree.inv_deriv,\n            Tree.inv_sderiv, Tree.inv_sderivBot]\n          rfl\n        rw [smul_fuzz h\u03b4 h\u03b5 h\u03b4\u03b5, smul_fuzz h\u03b4 h\u03b5 h\u03b4\u03b5] at this\n        have := fuzz_injective (hN\u2082.symm.trans this)\n        rw [smul_smul] at this\n        rw [t.smul_atom_eq_of_mem_support this ha]\n        rw [Enumeration.rel_add_iff] at hi \u22a2\n        obtain hi | \u27e8i, rfl, hi\u27e9 := hi\n        \u00b7 left\n          simp only [allPermForget_mul, allPermSderiv_forget, allPermDeriv_forget,\n            allPermForget_inv, Tree.inv_deriv, Tree.inv_sderiv, Tree.mul_apply, Tree.sderiv_apply,\n            Tree.deriv_apply, Path.deriv_scoderiv, Tree.inv_apply, mul_smul]\n          rwa [\u2190 (h\u03c1\u2081 _).1 a \u27e8i, hi\u27e9, inv_smul_smul, (h\u03c1\u2082 _).1 a \u27e8i, hi\u27e9]\n        \u00b7 refine Or.inr \u27e8i, rfl, ?_\u27e9\n          simp only [allPermForget_mul, allPermSderiv_forget, allPermDeriv_forget,\n            allPermForget_inv, Tree.inv_deriv, Tree.inv_sderiv, Tree.mul_apply, Tree.sderiv_apply,\n            Tree.deriv_apply, Path.deriv_scoderiv, Tree.inv_apply, mul_smul, Enumeration.smul_rel,\n            inv_smul_smul]\n          exact hi\n\ntheorem nearLitters_of_inflexible_of_fixes {S : Support \u03b1} (hS : S.Strong) {T : Support \u03b3}\n    {\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n    (h\u03c1\u2081 : \u03c1\u2081\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (h\u03c1\u2082 : \u03c1\u2082\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (A : \u03b1 \u219d \u22a5) (N\u2081 N\u2082 : NearLitter) (P : InflexiblePath \u2191\u03b1) (t : Tangle P.\u03b4) (\u03c1 : AllPerm P.\u03b4) :\n    A = P.A \u2198 P.h\u03b5 \u2198. \u2192 N\u2081\u1d38 = fuzz P.h\u03b4\u03b5 t \u2192 N\u2082\u1d38 = fuzz P.h\u03b4\u03b5 (\u03c1 \u2022 t) \u2192\n    convNearLitters\n      (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim)\n      (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A N\u2081 N\u2082 \u2192\n    \u2200 (B : P.\u03b4 \u219d \u22a5), \u2200 N \u2208 (t.support \u21d8. B)\u1d3a, \u2200 (i : \u03ba),\n      ((S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong + (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197\n        LtLevel.elim) \u21d8. (P.A \u2198 P.h\u03b4 \u21d8 B))\u1d3a.rel i N \u2192\n      ((S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong + (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197\n        LtLevel.elim) \u21d8. (P.A \u2198 P.h\u03b4 \u21d8 B))\u1d3a.rel i (\u03c1\u1d41 B \u2022 N) := by\n  rw [Support.smul_eq_iff] at h\u03c1\u2081 h\u03c1\u2082\n  obtain \u27e8\u03b3, \u03b4, \u03b5, h\u03b4, h\u03b5, h\u03b4\u03b5, B\u27e9 := P\n  haveI : LeLevel \u03b3 := \u27e8B.le\u27e9\n  haveI : LtLevel \u03b4 := \u27e8h\u03b4.trans_le LeLevel.elim\u27e9\n  haveI : LtLevel \u03b5 := \u27e8h\u03b5.trans_le LeLevel.elim\u27e9\n  dsimp only at t \u03c1 \u22a2\n  intro hA hN\u2081 hN\u2082 hN C N\u2080 hN\u2080 i hi\n  obtain \u27e8rfl, hN'\u27e9 | \u27e8A, rfl, hN\u2081', hN\u2082'\u27e9 := convNearLitters_cases hN\n  \u00b7 have haS := (hS.support_le hN' \u27e8\u03b3, \u03b4, \u03b5, h\u03b4, h\u03b5, h\u03b4\u03b5, _\u27e9 t hA hN\u2081 _).2 N\u2080 hN\u2080\n    rw [hN\u2082] at hN\u2081\n    have h\u03c1t := congr_arg Tangle.support (fuzz_injective hN\u2081)\n    rw [Tangle.smul_support, Support.smul_eq_iff] at h\u03c1t\n    simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.rel_add_iff] at hi \u22a2\n    rw [(h\u03c1t C).2 N\u2080 hN\u2080]\n    obtain hi | \u27e8i, rfl, hi\u27e9 := hi\n    \u00b7 exact Or.inl hi\n    \u00b7 simp only [add_right_inj, exists_eq_left]\n      obtain \u27e8D, hD\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv \u27e8i, hi\u27e9\n      cases B using Path.recScoderiv\n      case nil =>\n        cases Path.scoderiv_index_injective hD\n        cases Path.scoderiv_left_inj.mp hD\n        simp only [hD, Path.coderiv_deriv, Path.coderiv_deriv', scoderiv_botDeriv_eq, smul_derivBot,\n          add_derivBot, BaseSupport.smul_nearLitters, BaseSupport.add_nearLitters, Enumeration.smul_rel] at hi \u22a2\n        rw [deriv_derivBot, hD] at haS\n        rw [\u2190 (h\u03c1\u2082 _).2 N\u2080 haS, inv_smul_smul]\n        rw [\u2190 (h\u03c1\u2081 _).2 N\u2080 haS, inv_smul_smul] at hi\n        exact Or.inr hi\n      case scoderiv \u03b6 B h\u03b6' _ =>\n        rw [Path.coderiv_deriv, Path.coderiv_deriv'] at hD\n        cases Path.scoderiv_index_injective hD\n        rw [Path.scoderiv_left_inj] at hD\n        cases hD\n        simp only [Path.coderiv_deriv, Path.coderiv_deriv', scoderiv_botDeriv_eq, smul_derivBot,\n          add_derivBot, BaseSupport.smul_nearLitters, BaseSupport.add_nearLitters, Enumeration.smul_rel] at hi \u22a2\n        rw [deriv_derivBot, Path.coderiv_deriv, Path.coderiv_deriv'] at haS\n        rw [\u2190 (h\u03c1\u2082 _).2 N\u2080 haS, inv_smul_smul]\n        rw [\u2190 (h\u03c1\u2081 _).2 N\u2080 haS, inv_smul_smul] at hi\n        exact Or.inr hi\n  \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, interferenceSupport_nearLitters,\n      Enumeration.add_empty] at hN\u2082'\n    cases A\n    case sderiv \u03b6 A h\u03b6' _ =>\n      rw [\u2190 Path.coderiv_deriv] at hA\n      cases Path.sderiv_index_injective hA\n      apply Path.sderiv_path_injective at hA\n      cases A\n      case nil =>\n        cases hA\n        cases not_mem_strong_botDeriv _ _ hN\u2082'\n      case sderiv \u03b6 A h\u03b6 _ _ =>\n        rw [\u2190 Path.coderiv_deriv] at hA\n        cases Path.sderiv_index_injective hA\n        apply Path.sderiv_path_injective at hA\n        cases hA\n        simp only [Path.coderiv_deriv, Path.coderiv_deriv', add_derivBot, scoderiv_botDeriv_eq,\n          smul_derivBot, BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters] at hi \u22a2\n        have : N\u2082\u1d38 = (\u03c1\u2082 \u21d8 A)\u1d41 \u2198 h\u03b6 \u2198. \u2022 (\u03c1\u2081\u207b\u00b9 \u21d8 A)\u1d41 \u2198 h\u03b6 \u2198. \u2022 fuzz h\u03b4\u03b5 t := by\n          rw [inv_smul_eq_iff] at hN\u2081'\n          rw [hN\u2081', Path.botSderiv_coe_eq, BasePerm.smul_nearLitter_litter,\n            BasePerm.smul_nearLitter_litter, smul_smul, smul_eq_iff_eq_inv_smul,\n            mul_inv_rev, inv_inv, mul_smul, \u2190 Tree.inv_apply, \u2190 allPermForget_inv] at hN\u2081\n          rw [hN\u2081]\n          simp only [allPermForget_inv, Tree.inv_apply, allPermDeriv_forget, Tree.inv_deriv,\n            Tree.inv_sderiv, Tree.inv_sderivBot]\n          rfl\n        rw [smul_fuzz h\u03b4 h\u03b5 h\u03b4\u03b5, smul_fuzz h\u03b4 h\u03b5 h\u03b4\u03b5] at this\n        have := fuzz_injective (hN\u2082.symm.trans this)\n        rw [smul_smul] at this\n        rw [t.smul_nearLitter_eq_of_mem_support this hN\u2080]\n        rw [Enumeration.rel_add_iff] at hi \u22a2\n        obtain hi | \u27e8i, rfl, hi\u27e9 := hi\n        \u00b7 left\n          simp only [allPermForget_mul, allPermSderiv_forget, allPermDeriv_forget,\n            allPermForget_inv, Tree.inv_deriv, Tree.inv_sderiv, Tree.mul_apply, Tree.sderiv_apply,\n            Tree.deriv_apply, Path.deriv_scoderiv, Tree.inv_apply, mul_smul]\n          rwa [\u2190 (h\u03c1\u2081 _).2 N\u2080 \u27e8i, hi\u27e9, inv_smul_smul, (h\u03c1\u2082 _).2 N\u2080 \u27e8i, hi\u27e9]\n        \u00b7 refine Or.inr \u27e8i, rfl, ?_\u27e9\n          simp only [allPermForget_mul, allPermSderiv_forget, allPermDeriv_forget,\n            allPermForget_inv, Tree.inv_deriv, Tree.inv_sderiv, Tree.mul_apply, Tree.sderiv_apply,\n            Tree.deriv_apply, Path.deriv_scoderiv, Tree.inv_apply, mul_smul, Enumeration.smul_rel,\n            inv_smul_smul]\n          exact hi\n\ntheorem litter_eq_of_flexible_of_fixes {S : Support \u03b1} {T : Support \u03b3}\n    {\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n    (h\u03c1\u2081 : \u03c1\u2081\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (h\u03c1\u2082 : \u03c1\u2082\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    {A : \u2191\u03b1 \u219d \u22a5} {N\u2081 N\u2082 N\u2083 N\u2084 : NearLitter} :\n    convNearLitters\n      (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim)\n      (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A N\u2081 N\u2082 \u2192\n    convNearLitters\n      (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim)\n      (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A N\u2083 N\u2084 \u2192\n      \u00acInflexible A N\u2081\u1d38 \u2192 \u00acInflexible A N\u2082\u1d38 \u2192 \u00acInflexible A N\u2083\u1d38 \u2192 \u00acInflexible A N\u2084\u1d38 \u2192\n      N\u2081\u1d38 = N\u2083\u1d38 \u2192 N\u2082\u1d38 = N\u2084\u1d38 := by\n  rw [Support.smul_eq_iff] at h\u03c1\u2081 h\u03c1\u2082\n  rintro \u27e8i, hi\u2081, hi\u2082\u27e9 \u27e8j, hj\u2081, hj\u2082\u27e9 hN\u2081 hN\u2082 hN\u2083 hN\u2084 hN\u2081\u2083\n  simp only [add_derivBot, BaseSupport.add_nearLitters, Rel.inv_apply,\n    Enumeration.rel_add_iff] at hi\u2081 hi\u2082 hj\u2081 hj\u2082\n  obtain hi\u2081 | \u27e8i, rfl, hi\u2081\u27e9 := hi\u2081\n  \u00b7 obtain hi\u2082 | \u27e8i, rfl, hi\u2082\u27e9 := hi\u2082\n    swap\n    \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hi\u2081\u27e9\n      simp only [add_lt_iff_neg_left] at this\n      cases (\u03ba_zero_le i).not_lt this\n    cases (Enumeration.rel_coinjective _).coinjective hi\u2081 hi\u2082\n    obtain hj\u2081 | \u27e8j, rfl, hj\u2081\u27e9 := hj\u2081\n    \u00b7 obtain hj\u2082 | \u27e8j, rfl, hj\u2082\u27e9 := hj\u2082\n      swap\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2081\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j).not_lt this\n      cases (Enumeration.rel_coinjective _).coinjective hj\u2081 hj\u2082\n      exact hN\u2081\u2083\n    \u00b7 simp only [add_right_inj, exists_eq_left] at hj\u2082\n      obtain hj\u2082 | hj\u2082 := hj\u2082\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2082\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j).not_lt this\n      obtain \u27e8A, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv \u27e8j, hj\u2081\u27e9\n      simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_nearLitters,\n        BaseSupport.add_nearLitters, Enumeration.smul_rel] at hj\u2081 hj\u2082\n      have := congr_arg (\u00b7\u1d38) ((Enumeration.rel_coinjective _).coinjective hj\u2081 hj\u2082)\n      simp only [BasePerm.smul_nearLitter_litter] at this\n      rw [\u2190 hN\u2081\u2083, \u2190 (h\u03c1\u2081 A).2 N\u2081 \u27e8i, hi\u2081\u27e9, BasePerm.smul_nearLitter_litter, inv_smul_smul] at this\n      have hN\u2081' := (h\u03c1\u2082 A).2 N\u2081 \u27e8i, hi\u2081\u27e9\n      rw [smul_eq_iff_eq_inv_smul] at hN\u2081'\n      rwa [hN\u2081', BasePerm.smul_nearLitter_litter, smul_left_cancel_iff] at this\n  \u00b7 obtain hi\u2082 | hi\u2082 := hi\u2082\n    \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hi\u2082\u27e9\n      simp only [add_lt_iff_neg_left] at this\n      cases (\u03ba_zero_le i).not_lt this\n    simp only [add_right_inj, exists_eq_left] at hi\u2082\n    obtain \u27e8A, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv \u27e8i, hi\u2081\u27e9\n    simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_nearLitters,\n      BaseSupport.add_nearLitters, Enumeration.smul_rel] at hi\u2081 hi\u2082 hj\u2081 hj\u2082\n    have hN\u2081\u2082 := congr_arg (\u00b7\u1d38) ((Enumeration.rel_coinjective _).coinjective hi\u2081 hi\u2082)\n    obtain hj\u2081 | \u27e8j, rfl, hj\u2081\u27e9 := hj\u2081\n    \u00b7 obtain hj\u2082 | \u27e8j, rfl, hj\u2082\u27e9 := hj\u2082\n      swap\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2081\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j).not_lt this\n      cases (Enumeration.rel_coinjective _).coinjective hj\u2081 hj\u2082\n      simp only [BasePerm.smul_nearLitter_litter] at hN\u2081\u2082\n      rw [hN\u2081\u2083, \u2190 (h\u03c1\u2081 A).2 N\u2083 \u27e8j, hj\u2081\u27e9, BasePerm.smul_nearLitter_litter, inv_smul_smul,\n        eq_inv_smul_iff, \u2190 BasePerm.smul_nearLitter_litter, (h\u03c1\u2082 A).2 N\u2083 \u27e8j, hj\u2081\u27e9] at hN\u2081\u2082\n      rw [hN\u2081\u2082]\n    \u00b7 simp only [add_right_inj, exists_eq_left] at hj\u2082\n      obtain hj\u2082 | hj\u2082 := hj\u2082\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2082\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j).not_lt this\n      have hN\u2083\u2084 := congr_arg (\u00b7\u1d38) ((Enumeration.rel_coinjective _).coinjective hj\u2081 hj\u2082)\n      simp only [BasePerm.smul_nearLitter_litter] at hN\u2081\u2082 hN\u2083\u2084\n      rw [hN\u2081\u2083] at hN\u2081\u2082\n      rwa [hN\u2081\u2082, smul_left_cancel_iff] at hN\u2083\u2084\n\n", "theoremStatement": "theorem sameSpecLe_of_fixes (S : Support \u03b1) (hS : S.Strong) (T : Support \u03b3) (\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2)\n    (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n    (h\u03c1\u2081 : \u03c1\u2081\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (h\u03c1\u2082 : \u03c1\u2082\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim) :\n    SameSpecLE\n    (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim)\n    (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) ", "theoremName": "ConNF.Support.sameSpecLe_of_fixes", "fileCreated": {"commit": "abf71bc79c407ceb462cc2edd2d994cda9cdef05", "date": "2024-04-04"}, "theoremCreated": {"commit": "6709914ae7f5cd3e2bb24b413e09aa844554d234", "date": "2024-11-30"}, "file": "ConNF/ConNF/Model/RaiseStrong.lean", "module": "ConNF.Model.RaiseStrong", "jsonFile": "ConNF.Model.RaiseStrong.jsonl", "positionMetadata": {"lineInFile": 658, "tokenPositionInFile": 32666, "theoremPositionInFile": 12}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 6, "repositoryPremises": true, "numRepositoryPremises": 71, "numPremises": 138}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  constructor\n  case atoms_bound_eq => intro; rfl\n  case nearLitters_bound_eq => intro; rfl\n  case atoms_dom_subset =>\n    simp only [add_derivBot, BaseSupport.add_atoms, Enumeration.add_rel_dom,\n      Set.union_subset_iff, Set.subset_union_left, true_and]\n    rintro A _ \u27e8i, \u27e8a, \u27e8A, a\u27e9, h\u2081, h\u2082\u27e9, rfl\u27e9\n    cases h\u2082\n    right\n    apply Set.mem_image_of_mem\n    refine \u27e8\u03c1\u2082\u1d41 A \u2022 (\u03c1\u2081\u1d41 A)\u207b\u00b9 \u2022 a, \u27e8A, \u03c1\u2082\u1d41 A \u2022 (\u03c1\u2081\u1d41 A)\u207b\u00b9 \u2022 a\u27e9, ?_, rfl\u27e9\n    rw [smul_atoms, Enumeration.smulPath_rel] at h\u2081 \u22a2\n    simp only [inv_smul_smul]\n    exact h\u2081\n  case nearLitters_dom_subset =>\n    simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.add_rel_dom,\n      Set.union_subset_iff, Set.subset_union_left, true_and]\n    rintro A _ \u27e8i, \u27e8N, \u27e8A, N\u27e9, h\u2081, h\u2082\u27e9, rfl\u27e9\n    cases h\u2082\n    right\n    apply Set.mem_image_of_mem\n    refine \u27e8\u03c1\u2082\u1d41 A \u2022 (\u03c1\u2081\u1d41 A)\u207b\u00b9 \u2022 N, \u27e8A, \u03c1\u2082\u1d41 A \u2022 (\u03c1\u2081\u1d41 A)\u207b\u00b9 \u2022 N\u27e9, ?_, rfl\u27e9\n    rw [smul_nearLitters, Enumeration.smulPath_rel] at h\u2081 \u22a2\n    simp only [inv_smul_smul]\n    exact h\u2081\n  case convAtoms_injective => exact convAtoms_injective_of_fixes h\u03c1\u2081 h\u03c1\u2082\n  case atomMemRel_le => exact atomMemRel_le_of_fixes h\u03c1\u2081 h\u03c1\u2082\n  case inflexible_of_inflexible => exact inflexible_of_inflexible_of_fixes h\u03c1\u2081 h\u03c1\u2082\n  case atoms_of_inflexible => exact atoms_of_inflexible_of_fixes hS h\u03c1\u2081 h\u03c1\u2082\n  case nearLitters_of_inflexible => exact nearLitters_of_inflexible_of_fixes hS h\u03c1\u2081 h\u03c1\u2082\n  case litter_eq_of_flexible => exact litter_eq_of_flexible_of_fixes h\u03c1\u2081 h\u03c1\u2082", "proofType": "tactic", "proofLengthLines": 31, "proofLengthTokens": 1439}}
{"srcContext": "import ConNF.Model.RaiseStrong\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nopen scoped Pointwise\n\nnamespace ConNF\n\nvariable [Params.{u}]\n\n/-- A redefinition of the derivative of allowable permutations that is invariant of level,\nbut still has nice definitional properties. -/\n@[default_instance 200]\ninstance {\u03b2 \u03b3 : TypeIndex} : Derivative (AllPerm \u03b2) (AllPerm \u03b3) \u03b2 \u03b3 where\n  deriv \u03c1 A :=\n    A.recSderiv\n    (motive := \u03bb (\u03b4 : TypeIndex) (A : \u03b2 \u219d \u03b4) \u21a6\n      letI : Level := \u27e8\u03b4.recBotCoe (Nonempty.some inferInstance) id\u27e9\n      letI : LeLevel \u03b4 := \u27e8\u03b4.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n        (show \u03b4.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n      AllPerm \u03b4)\n    \u03c1 (\u03bb \u03b4 \u03b5 A h \u03c1 \u21a6\n      letI : Level := \u27e8\u03b4.recBotCoe (Nonempty.some inferInstance) id\u27e9\n      letI : LeLevel \u03b4 := \u27e8\u03b4.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n        (show \u03b4.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n      letI : LeLevel \u03b5 := \u27e8h.le.trans LeLevel.elim\u27e9\n      PreCoherentData.allPermSderiv h \u03c1)\n\n@[simp]\ntheorem allPerm_deriv_nil' {\u03b2 : TypeIndex}\n    (\u03c1 : AllPerm \u03b2) :\n    \u03c1 \u21d8 (.nil : \u03b2 \u219d \u03b2) = \u03c1 :=\n  rfl\n\n@[simp]\ntheorem allPerm_deriv_sderiv' {\u03b2 \u03b3 \u03b4 : TypeIndex}\n    (\u03c1 : AllPerm \u03b2) (A : \u03b2 \u219d \u03b3) (h : \u03b4 < \u03b3) :\n    \u03c1 \u21d8 (A \u2198 h) = \u03c1 \u21d8 A \u2198 h :=\n  rfl\n\n@[simp]\ntheorem allPermSderiv_forget' {\u03b2 \u03b3 : TypeIndex} (h : \u03b3 < \u03b2) (\u03c1 : AllPerm \u03b2) :\n    (\u03c1 \u2198 h)\u1d41 = \u03c1\u1d41 \u2198 h :=\n  letI : Level := \u27e8\u03b2.recBotCoe (Nonempty.some inferInstance) id\u27e9\n  letI : LeLevel \u03b2 := \u27e8\u03b2.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n    (show \u03b2.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n  letI : LeLevel \u03b3 := \u27e8h.le.trans LeLevel.elim\u27e9\n  allPermSderiv_forget h \u03c1\n\n@[simp]\ntheorem allPerm_inv_sderiv' {\u03b2 \u03b3 : TypeIndex} (h : \u03b3 < \u03b2) (\u03c1 : AllPerm \u03b2) :\n    \u03c1\u207b\u00b9 \u2198 h = (\u03c1 \u2198 h)\u207b\u00b9 := by\n  apply allPermForget_injective\n  rw [allPermSderiv_forget', allPermForget_inv, Tree.inv_sderiv, allPermForget_inv,\n    allPermSderiv_forget']\n\ndef Symmetric {\u03b1 \u03b2 : \u039b} (s : Set (TSet \u03b2)) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) : Prop :=\n  \u2203 S : Support \u03b1, \u2200 \u03c1 : AllPerm \u03b1, \u03c1\u1d41 \u2022 S = S \u2192 \u03c1 \u2198 h\u03b2 \u2022 s = s\n\ndef newSetEquiv {\u03b1 : \u039b} :\n    letI : Level := \u27e8\u03b1\u27e9\n    @TSet _ \u03b1 newModelData.toPreModelData \u2243 TSet \u03b1 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castTSet (D\u2081 := newModelData) (D\u2082 := globalModelData) rfl\n    (by rw [globalModelData, motive_eq, constructMotive, globalLtData_eq])\n\n@[simp]\ntheorem newSetEquiv_forget {\u03b1 : \u039b}\n    (x : letI : Level := \u27e8\u03b1\u27e9; @TSet _ \u03b1 newModelData.toPreModelData) :\n    (newSetEquiv x)\u1d41 = x\u1d41 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castTSet_forget (D\u2081 := newModelData) (D\u2082 := globalModelData) _ x\n\ndef allPermEquiv {\u03b1 : \u039b} :\n    letI : Level := \u27e8\u03b1\u27e9\n    NewPerm \u2243 AllPerm \u03b1 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castAllPerm (D\u2081 := newModelData) (D\u2082 := globalModelData) rfl\n    (by rw [globalModelData, motive_eq, constructMotive, globalLtData_eq])\n\n@[simp]\ntheorem allPermEquiv_forget {\u03b1 : \u039b} (\u03c1 : letI : Level := \u27e8\u03b1\u27e9; NewPerm) :\n    (allPermEquiv \u03c1)\u1d41 = \u03c1\u1d41 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castAllPerm_forget (D\u2081 := newModelData) (D\u2082 := globalModelData) _ \u03c1\n\ntheorem allPermEquiv_sderiv {\u03b1 \u03b2 : \u039b}\n    (\u03c1 : letI : Level := \u27e8\u03b1\u27e9; NewPerm) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) :\n    letI : Level := \u27e8\u03b1\u27e9\n    letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n    allPermEquiv \u03c1 \u2198 h\u03b2 = \u03c1.sderiv \u03b2 := by\n  letI : Level := \u27e8\u03b1\u27e9\n  letI : LeLevel \u03b1 := \u27e8le_rfl\u27e9\n  letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n  apply allPermForget_injective\n  rw [allPermSderiv_forget, allPermEquiv_forget, NewPerm.forget_sderiv]\n\ntheorem TSet.exists_of_symmetric {\u03b1 \u03b2 : \u039b} (s : Set (TSet \u03b2)) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1)\n    (hs : Symmetric s h\u03b2) :\n    \u2203 x : TSet \u03b1, \u2200 y : TSet \u03b2, y \u2208[h\u03b2] x \u2194 y \u2208 s := by\n  letI : Level := \u27e8\u03b1\u27e9\n  letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n  suffices \u2203 x : (@TSet _ \u03b1 newModelData.toPreModelData), \u2200 y : TSet \u03b2, y\u1d41 \u2208[h\u03b2] x\u1d41 \u2194 y \u2208 s by\n    obtain \u27e8x, hx\u27e9 := this\n    use newSetEquiv x\n    intro y\n    rw [\u2190 hx, \u2190 TSet.forget_mem_forget, newSetEquiv_forget]\n  obtain rfl | hs' := s.eq_empty_or_nonempty\n  \u00b7 use none\n    intro y\n    simp only [Set.mem_empty_iff_false, iff_false]\n    exact not_mem_none y\n  \u00b7 use some (Code.toSet \u27e8\u03b2, s, hs'\u27e9 ?_)\n    \u00b7 intro y\n      erw [mem_some_iff]\n      exact Code.mem_toSet _\n    \u00b7 obtain \u27e8S, hS\u27e9 := hs\n      use S\n      intro \u03c1 h\u03c1S\n      have := hS (allPermEquiv \u03c1) ?_\n      \u00b7 simp only [NewPerm.smul_mk, Code.mk.injEq, heq_eq_eq, true_and]\n        rwa [allPermEquiv_sderiv] at this\n      \u00b7 rwa [allPermEquiv_forget]\n\ntheorem TSet.exists_support {\u03b1 : \u039b} (x : TSet \u03b1) :\n    \u2203 S : Support \u03b1, \u2200 \u03c1 : AllPerm \u03b1, \u03c1\u1d41 \u2022 S = S \u2192 \u03c1 \u2022 x = x := by\n  letI : Level := \u27e8\u03b1\u27e9\n  obtain \u27e8S, hS\u27e9 := NewSet.exists_support (newSetEquiv.symm x)\n  use S\n  intro \u03c1 h\u03c1\n  have := @Support.Supports.supports _ _ _ newPreModelData _ _ _ hS (allPermEquiv.symm \u03c1) ?_\n  \u00b7 apply tSetForget_injective\n    have := congr_arg (\u00b7\u1d41) this\n    simp only at this\n    erw [@smul_forget _ _ newModelData (allPermEquiv.symm \u03c1) (newSetEquiv.symm x),\n      \u2190 allPermEquiv_forget, \u2190 newSetEquiv_forget, Equiv.apply_symm_apply,\n      Equiv.apply_symm_apply] at this\n    rwa [smul_forget]\n  \u00b7 rwa [\u2190 allPermEquiv_forget, Equiv.apply_symm_apply]\n\ntheorem TSet.symmetric {\u03b1 \u03b2 : \u039b} (x : TSet \u03b1) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) :\n    Symmetric {y : TSet \u03b2 | y \u2208[h\u03b2] x} h\u03b2 := by\n  obtain \u27e8S, hS\u27e9 := exists_support x\n  use S\n  intro \u03c1 h\u03c1\n  conv_rhs => rw [\u2190 hS \u03c1 h\u03c1]\n  simp only [\u2190 forget_mem_forget, smul_forget, StrSet.mem_smul_iff]\n  ext y\n  rw [Set.mem_smul_set_iff_inv_smul_mem, Set.mem_setOf_eq, Set.mem_setOf_eq,\n    smul_forget, allPermForget_inv, allPermSderiv_forget']\n\n", "theoremStatement": "theorem tSet_ext' {\u03b1 \u03b2 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (x y : TSet \u03b1)\n    (h : \u2200 z : TSet \u03b2, z \u2208[h\u03b2] x \u2194 z \u2208[h\u03b2] y) : x = y ", "theoremName": "ConNF.tSet_ext'", "fileCreated": {"commit": "6fdc87c6b30b73931407a372f1430ecf0fef7601", "date": "2024-12-03"}, "theoremCreated": {"commit": "2e25ffbc94af48261308cea0d8c55205cc388ef0", "date": "2024-12-01"}, "file": "ConNF/ConNF/Model/TTT.lean", "module": "ConNF.Model.TTT", "jsonFile": "ConNF.Model.TTT.jsonl", "positionMetadata": {"lineInFile": 165, "tokenPositionInFile": 5601, "theoremPositionInFile": 13}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 16, "numPremises": 29}, "proofMetadata": {"hasProof": true, "proof": ":=\n  letI : Level := \u27e8\u03b1\u27e9\n  letI : LeLevel \u03b1 := \u27e8le_rfl\u27e9\n  letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n  tSet_ext h\u03b2 x y h", "proofType": "term", "proofLengthLines": 4, "proofLengthTokens": 102}}
{"srcContext": "import ConNF.Model.Externalise\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b2 \u03b3 : \u039b} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n\nnamespace Support\n\ntheorem not_mem_scoderiv_botDeriv (S : Support \u03b3) (N : NearLitter) :\n    N \u2209 (S \u2197 h\u03b3 \u21d8. (Path.nil \u2198.))\u1d3a := by\n  rintro \u27e8i, \u27e8A, N'\u27e9, h\u2081, h\u2082\u27e9\n  simp only [Prod.mk.injEq] at h\u2082\n  cases A\n  case sderiv \u03b4 A h\u03b4 _ =>\n    simp only [Path.deriv_sderiv] at h\u2082\n    cases A\n    case nil => cases h\u2082.1\n    case sderiv \u03b6 A h\u03b6 _ =>\n      simp only [Path.deriv_sderiv] at h\u2082\n      cases h\u2082.1\n\nvariable [Level] [LtLevel \u03b2]\n\ntheorem not_mem_strong_botDeriv (S : Support \u03b3) (N : NearLitter) :\n    N \u2209 ((S \u2197 h\u03b3).strong \u21d8. (Path.nil \u2198.))\u1d3a := by\n  rintro h\n  rw [strong, close_nearLitters, preStrong_nearLitters, Enumeration.mem_add_iff] at h\n  obtain h | h := h\n  \u00b7 exact not_mem_scoderiv_botDeriv S N h\n  \u00b7 rw [mem_constrainsNearLitters_nearLitters] at h\n    obtain \u27e8B, N', hN', h\u27e9 := h\n    cases h using Relation.ReflTransGen.head_induction_on\n    case refl => exact not_mem_scoderiv_botDeriv S N hN'\n    case head x hx\u2081 hx\u2082 _ =>\n      obtain \u27e8\u27e8\u03b3, \u03b4, \u03b5, h\u03b4, h\u03b5, h\u03b4\u03b5, A\u27e9, t, B, hB, hN, ht\u27e9 := hx\u2082\n      simp only at hB\n      cases B\n      case nil =>\n        cases hB\n        obtain \u27e8C, N''\u27e9 := x\n        simp only at ht\n        cases ht.1\n        change _ \u2208 t.support\u1d3a at hN\n        rw [t.support_supports.2 rfl] at hN\n        obtain \u27e8i, hN\u27e9 := hN\n        cases hN\n      case sderiv \u03b4 B h\u03b4 _ _ =>\n        cases B\n        case nil => cases hB\n        case sderiv \u03b6 B h\u03b6 _ _ => cases hB\n\n", "theoremStatement": "theorem raise_preStrong' (S : Support \u03b1) (hS : S.Strong) (T : Support \u03b3) (\u03c1 : AllPerm \u03b2)\n    (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2) :\n    (S + (\u03c1\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim).PreStrong ", "theoremName": "ConNF.Support.raise_preStrong'", "fileCreated": {"commit": "abf71bc79c407ceb462cc2edd2d994cda9cdef05", "date": "2024-04-04"}, "theoremCreated": {"commit": "6709914ae7f5cd3e2bb24b413e09aa844554d234", "date": "2024-11-30"}, "file": "ConNF/ConNF/Model/RaiseStrong.lean", "module": "ConNF.Model.RaiseStrong", "jsonFile": "ConNF.Model.RaiseStrong.jsonl", "positionMetadata": {"lineInFile": 67, "tokenPositionInFile": 1641, "theoremPositionInFile": 2}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 120, "numPremises": 187}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  apply hS.toPreStrong.add\n  constructor\n  intro A N hN P t hA ht\n  obtain \u27e8A, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv hN\n  simp only [scoderiv_botDeriv_eq, add_derivBot, smul_derivBot,\n    BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters, interferenceSupport_nearLitters,\n    Enumeration.mem_add_iff, Enumeration.mem_smul, Enumeration.not_mem_empty, or_false] at hN\n  obtain \u27e8\u03b4, \u03b5, \u03b6, h\u03b5, h\u03b6, h\u03b5\u03b6, B\u27e9 := P\n  dsimp only at *\n  cases A\n  case sderiv \u03b6' A h\u03b6' _ =>\n    rw [\u2190 Path.coderiv_deriv] at hA\n    cases Path.sderiv_index_injective hA\n    apply Path.sderiv_left_inj.mp at hA\n    cases A\n    case nil =>\n      cases hA\n      cases not_mem_strong_botDeriv T _ hN\n    case sderiv \u03b9 A h\u03b9 _ _ =>\n      rw [\u2190 Path.coderiv_deriv] at hA\n      cases Path.sderiv_index_injective hA\n      cases hA\n      haveI : LtLevel \u03b4 := \u27e8A.le.trans_lt LtLevel.elim\u27e9\n      haveI : LtLevel \u03b5 := \u27e8h\u03b5.trans LtLevel.elim\u27e9\n      haveI : LtLevel \u03b6 := \u27e8h\u03b6.trans LtLevel.elim\u27e9\n      have := (T \u2197 h\u03b3).strong_strong.support_le hN \u27e8\u03b4, \u03b5, \u03b6, h\u03b5, h\u03b6, h\u03b5\u03b6, A\u27e9\n          (\u03c1\u207b\u00b9 \u21d8 A \u2198 h\u03b5 \u2022 t) rfl ?_\n      \u00b7 simp only [Tangle.smul_support, allPermSderiv_forget, allPermDeriv_forget,\n          allPermForget_inv, Tree.inv_deriv, Tree.inv_sderiv] at this\n        have := smul_le_smul this (\u03c1\u1d41 \u21d8 A \u2198 h\u03b5)\n        simp only [smul_inv_smul] at this\n        apply le_trans this\n        intro B\n        constructor\n        \u00b7 intro a ha\n          simp only [smul_derivBot, Tree.sderiv_apply, Tree.deriv_apply, Path.deriv_scoderiv,\n            deriv_derivBot, Enumeration.mem_smul] at ha\n          rw [deriv_derivBot, \u2190 Path.deriv_scoderiv, Path.coderiv_deriv', scoderiv_botDeriv_eq,]\n          simp only [Path.deriv_scoderiv, add_derivBot, smul_derivBot,\n            BaseSupport.add_atoms, BaseSupport.smul_atoms, Enumeration.mem_add_iff,\n            Enumeration.mem_smul]\n          exact Or.inl ha\n        \u00b7 intro N hN\n          simp only [smul_derivBot, Tree.sderiv_apply, Tree.deriv_apply, Path.deriv_scoderiv,\n            deriv_derivBot, Enumeration.mem_smul] at hN\n          rw [deriv_derivBot, \u2190 Path.deriv_scoderiv, Path.coderiv_deriv', scoderiv_botDeriv_eq,]\n          simp only [Path.deriv_scoderiv, add_derivBot, smul_derivBot,\n            BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters, Enumeration.mem_add_iff,\n            Enumeration.mem_smul]\n          exact Or.inl hN\n      \u00b7 rw [\u2190 smul_fuzz h\u03b5 h\u03b6 h\u03b5\u03b6, \u2190 ht]\n        simp only [Path.botSderiv_coe_eq, BasePerm.smul_nearLitter_litter, allPermDeriv_forget,\n          allPermForget_inv, Tree.inv_deriv, Tree.inv_sderiv, Tree.inv_sderivBot]\n        rfl", "proofType": "tactic", "proofLengthLines": 54, "proofLengthTokens": 2600}}
{"srcContext": "import ConNF.Model.Result\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal ConNF.TSet\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\ndef union (x y : TSet \u03b1) : TSet \u03b1 :=\n  (x\u1d9c' \u2293' y\u1d9c')\u1d9c'\n\nnotation:68 x:68 \" \u2294[\" h \"] \" y:68 => _root_.ConNF.union h x y\nnotation:68 x:68 \" \u2294' \" y:68 => x \u2294[by assumption] y\n\n", "theoremStatement": "@[simp]\ntheorem mem_union_iff (x y : TSet \u03b1) :\n    \u2200 z : TSet \u03b2, z \u2208' x \u2294' y \u2194 z \u2208' x \u2228 z \u2208' y ", "theoremName": "ConNF.mem_union_iff", "fileCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "theoremCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "file": "ConNF/ConNF/External/Basic.lean", "module": "ConNF.External.Basic", "jsonFile": "ConNF.External.Basic.jsonl", "positionMetadata": {"lineInFile": 29, "tokenPositionInFile": 551, "theoremPositionInFile": 3}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 14, "numPremises": 36}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [union]\n  intro z\n  rw [mem_compl_iff, mem_inter_iff, mem_compl_iff, mem_compl_iff, or_iff_not_and_not]", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 114}}
{"srcContext": "import ConNF.Model.TTT\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\nnamespace TSet\n\ntheorem exists_inter (x y : TSet \u03b1) :\n    \u2203 w : TSet \u03b1, \u2200 z : TSet \u03b2, z \u2208[h\u03b2] w \u2194 z \u2208[h\u03b2] x \u2227 z \u2208[h\u03b2] y := by\n  refine exists_of_symmetric {z | z \u2208[h\u03b2] x \u2227 z \u2208[h\u03b2] y} h\u03b2 ?_\n  obtain \u27e8S, hS\u27e9 := symmetric x h\u03b2\n  obtain \u27e8T, hT\u27e9 := symmetric y h\u03b2\n  use S + T\n  intro \u03c1 h\u03c1\n  specialize hS \u03c1 (smul_eq_of_le Support.le_add_right h\u03c1)\n  specialize hT \u03c1 (smul_eq_of_le Support.le_add_left h\u03c1)\n  simp [Set.ext_iff, Set.mem_smul_set_iff_inv_smul_mem] at hS hT \u22a2\n  aesop\n\ntheorem exists_compl (x : TSet \u03b1) :\n    \u2203 y : TSet \u03b1, \u2200 z : TSet \u03b2, z \u2208[h\u03b2] y \u2194 \u00acz \u2208[h\u03b2] x := by\n  refine exists_of_symmetric {z | \u00acz \u2208[h\u03b2] x} h\u03b2 ?_\n  obtain \u27e8S, hS\u27e9 := symmetric x h\u03b2\n  use S\n  intro \u03c1 h\u03c1\n  specialize hS \u03c1 h\u03c1\n  simp [Set.ext_iff, Set.mem_smul_set_iff_inv_smul_mem] at hS \u22a2\n  aesop\n\ntheorem exists_up (x y : TSet \u03b2) :\n    \u2203 w : TSet \u03b1, \u2200 z : TSet \u03b2, z \u2208[h\u03b2] w \u2194 z = x \u2228 z = y := by\n  refine exists_of_symmetric {x, y} h\u03b2 ?_\n  obtain \u27e8S, hS\u27e9 := exists_support x\n  obtain \u27e8T, hT\u27e9 := exists_support y\n  use (S + T) \u2197 h\u03b2\n  intro \u03c1 h\u03c1\n  rw [Support.smul_scoderiv, Support.scoderiv_inj, \u2190 allPermSderiv_forget'] at h\u03c1\n  specialize hS (\u03c1 \u2198 h\u03b2) (smul_eq_of_le Support.le_add_right h\u03c1)\n  specialize hT (\u03c1 \u2198 h\u03b2) (smul_eq_of_le Support.le_add_left h\u03c1)\n  simp only [Set.smul_set_def, Set.image, Set.mem_insert_iff, Set.mem_singleton_iff,\n    exists_eq_or_imp, hS, exists_eq_left, hT]\n  ext z\n  rw [Set.mem_insert_iff, Set.mem_singleton_iff, Set.mem_setOf_eq]\n  aesop\n\n/-- The unordered pair. -/\ndef up (x y : TSet \u03b2) : TSet \u03b1 :=\n  (exists_up h\u03b2 x y).choose\n\n@[simp]\ntheorem mem_up_iff (x y z : TSet \u03b2) :\n    z \u2208[h\u03b2] up h\u03b2 x y \u2194 z = x \u2228 z = y :=\n  (exists_up h\u03b2 x y).choose_spec z\n\n/-- The Kuratowski ordered pair. -/\ndef op (x y : TSet \u03b3) : TSet \u03b1 :=\n  up h\u03b2 (singleton h\u03b3 x) (up h\u03b3 x y)\n\ntheorem up_injective {x y z w : TSet \u03b2} (h : up h\u03b2 x y = up h\u03b2 z w) :\n    (x = z \u2227 y = w) \u2228 (x = w \u2227 y = z) := by\n  have h\u2081 := mem_up_iff h\u03b2 x y z\n  have h\u2082 := mem_up_iff h\u03b2 x y w\n  have h\u2083 := mem_up_iff h\u03b2 z w x\n  have h\u2084 := mem_up_iff h\u03b2 z w y\n  rw [h, mem_up_iff] at h\u2081 h\u2082\n  rw [\u2190 h, mem_up_iff] at h\u2083 h\u2084\n  aesop\n\n@[simp]\ntheorem up_inj (x y z w : TSet \u03b2) :\n    up h\u03b2 x y = up h\u03b2 z w \u2194 (x = z \u2227 y = w) \u2228 (x = w \u2227 y = z) := by\n  constructor\n  \u00b7 exact up_injective h\u03b2\n  \u00b7 rintro (\u27e8rfl, rfl\u27e9 | \u27e8rfl, rfl\u27e9)\n    \u00b7 rfl\n    \u00b7 apply tSet_ext' h\u03b2\n      aesop\n\n@[simp]\ntheorem up_self {x : TSet \u03b2} :\n    up h\u03b2 x x = singleton h\u03b2 x := by\n  apply tSet_ext' h\u03b2\n  aesop\n\n@[simp]\ntheorem up_eq_singleton_iff (x y z : TSet \u03b2) :\n    up h\u03b2 x y = singleton h\u03b2 z \u2194 x = z \u2227 y = z := by\n  constructor\n  \u00b7 intro h\n    have h\u2081 := typedMem_singleton_iff' h\u03b2 z x\n    have h\u2082 := typedMem_singleton_iff' h\u03b2 z y\n    rw [\u2190 h, mem_up_iff] at h\u2081 h\u2082\n    aesop\n  \u00b7 rintro \u27e8rfl, rfl\u27e9\n    rw [up_self]\n\n@[simp]\ntheorem singleton_eq_up_iff (x y z : TSet \u03b2) :\n    singleton h\u03b2 z = up h\u03b2 x y \u2194 x = z \u2227 y = z := by\n  rw [\u2190 up_eq_singleton_iff h\u03b2 x y z, eq_comm]\n\ntheorem op_injective {x y z w : TSet \u03b3} (h : op h\u03b2 h\u03b3 x y = op h\u03b2 h\u03b3 z w) :\n    x = z \u2227 y = w := by\n  rw [op, op] at h\n  simp only [up_inj, singleton_inj, singleton_eq_up_iff, up_eq_singleton_iff] at h\n  obtain (\u27e8rfl, \u27e8h, rfl\u27e9 | \u27e8rfl, rfl\u27e9\u27e9 | \u27e8\u27e8rfl, rfl\u27e9, \u27e8h, rfl\u27e9\u27e9) := h <;> simp only [and_self]\n\n@[simp]\ntheorem op_inj (x y z w : TSet \u03b3) :\n    op h\u03b2 h\u03b3 x y = op h\u03b2 h\u03b3 z w \u2194 x = z \u2227 y = w := by\n  constructor\n  \u00b7 exact op_injective h\u03b2 h\u03b3\n  \u00b7 rintro \u27e8rfl, rfl\u27e9\n    rfl\n\n", "theoremStatement": "@[simp]\ntheorem op_eq_singleton_iff (x y : TSet \u03b3) (z : TSet \u03b2) :\n    op h\u03b2 h\u03b3 x y = singleton h\u03b2 z \u2194 singleton h\u03b3 x = z \u2227 singleton h\u03b3 y = z ", "theoremName": "ConNF.TSet.op_eq_singleton_iff", "fileCreated": {"commit": "f804f5c71cfaa98223fc227dd822801e8bf77004", "date": "2024-03-30"}, "theoremCreated": {"commit": "d317c6b36558ab466950845e35eddab954034963", "date": "2025-01-07"}, "file": "ConNF/ConNF/Model/Hailperin.lean", "module": "ConNF.Model.Hailperin", "jsonFile": "ConNF.Model.Hailperin.jsonl", "positionMetadata": {"lineInFile": 133, "tokenPositionInFile": 3729, "theoremPositionInFile": 13}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 12, "numPremises": 39}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [op, up_eq_singleton_iff, and_congr_right_iff]\n  rintro rfl\n  simp only [up_eq_singleton_iff, true_and, singleton_inj]", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 129}}
{"srcContext": "import ConNF.Model.TTT\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\nnamespace TSet\n\ntheorem exists_inter (x y : TSet \u03b1) :\n    \u2203 w : TSet \u03b1, \u2200 z : TSet \u03b2, z \u2208[h\u03b2] w \u2194 z \u2208[h\u03b2] x \u2227 z \u2208[h\u03b2] y := by\n  refine exists_of_symmetric {z | z \u2208[h\u03b2] x \u2227 z \u2208[h\u03b2] y} h\u03b2 ?_\n  obtain \u27e8S, hS\u27e9 := symmetric x h\u03b2\n  obtain \u27e8T, hT\u27e9 := symmetric y h\u03b2\n  use S + T\n  intro \u03c1 h\u03c1\n  specialize hS \u03c1 (smul_eq_of_le Support.le_add_right h\u03c1)\n  specialize hT \u03c1 (smul_eq_of_le Support.le_add_left h\u03c1)\n  simp [Set.ext_iff, Set.mem_smul_set_iff_inv_smul_mem] at hS hT \u22a2\n  aesop\n\n", "theoremStatement": "theorem exists_compl (x : TSet \u03b1) :\n    \u2203 y : TSet \u03b1, \u2200 z : TSet \u03b2, z \u2208[h\u03b2] y \u2194 \u00acz \u2208[h\u03b2] x ", "theoremName": "ConNF.TSet.exists_compl", "fileCreated": {"commit": "f804f5c71cfaa98223fc227dd822801e8bf77004", "date": "2024-03-30"}, "theoremCreated": {"commit": "f7c233c7f7fd9d8b74595bbfa2bbbd49d538ef59", "date": "2024-12-02"}, "file": "ConNF/ConNF/Model/Hailperin.lean", "module": "ConNF.Model.Hailperin", "jsonFile": "ConNF.Model.Hailperin.jsonl", "positionMetadata": {"lineInFile": 37, "tokenPositionInFile": 840, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 23, "numPremises": 68}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  refine exists_of_symmetric {z | \u00acz \u2208[h\u03b2] x} h\u03b2 ?_\n  obtain \u27e8S, hS\u27e9 := symmetric x h\u03b2\n  use S\n  intro \u03c1 h\u03c1\n  specialize hS \u03c1 h\u03c1\n  simp [Set.ext_iff, Set.mem_smul_set_iff_inv_smul_mem] at hS \u22a2\n  aesop", "proofType": "tactic", "proofLengthLines": 7, "proofLengthTokens": 206}}
{"srcContext": "import ConNF.Model.RunInduction\n\n/-!\n# Externalisation\n\nIn this file, we convert many of our *internal* results (i.e. inside the induction) to *external*\nones (i.e. defined using the global `TSet`/`AllPerm` definitions).\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal WithBot\n\nnamespace ConNF\n\nvariable [Params.{u}]\n\ninstance globalModelData : {\u03b1 : TypeIndex} \u2192 ModelData \u03b1\n  | (\u03b1 : \u039b) => (motive \u03b1).data\n  | \u22a5 => botModelData\n\ninstance globalPosition : {\u03b1 : TypeIndex} \u2192 Position (Tangle \u03b1)\n  | (\u03b1 : \u039b) => (motive \u03b1).pos\n  | \u22a5 => botPosition\n\ninstance globalTypedNearLitters {\u03b1 : \u039b} : TypedNearLitters \u03b1 :=\n  (motive \u03b1).typed\n\ninstance globalLtData [Level] : LtData where\n\ninstance globalLeData [Level] : LeData where\n\nomit [Params] in\ntheorem heq_funext {\u03b1 : Sort _} {\u03b2 \u03b3 : \u03b1 \u2192 Sort _} {f : (x : \u03b1) \u2192 \u03b2 x} {g : (x : \u03b1) \u2192 \u03b3 x}\n    (h : \u2200 x, HEq (f x) (g x)) : HEq f g := by\n  cases funext \u03bb x \u21a6 type_eq_of_heq (h x)\n  simp only [heq_eq_eq] at h \u22a2\n  exact funext h\n\ntheorem globalLtData_eq [Level] :\n    globalLtData = ltData (\u03bb \u03b2 _ \u21a6 motive \u03b2) := by\n  apply LtData.ext\n  \u00b7 ext \u03b2 h\u03b2\n    induction \u03b2 using recBotCoe\n    case bot => rfl\n    case coe \u03b2 => rfl\n  \u00b7 apply heq_funext\n    intro \u03b2\n    induction \u03b2 using recBotCoe\n    case bot => rfl\n    case coe \u03b2 => rfl\n  \u00b7 rfl\n\n", "theoremStatement": "theorem globalLeData_eq [Level] :\n    globalLeData = leData (\u03bb \u03b2 _ \u21a6 motive \u03b2) ", "theoremName": "ConNF.globalLeData_eq", "fileCreated": {"commit": "6fdc87c6b30b73931407a372f1430ecf0fef7601", "date": "2024-12-03"}, "theoremCreated": {"commit": "e409f3d0cd939e7218c3f39dcf3493c4b6e0b821", "date": "2024-11-29"}, "file": "ConNF/ConNF/Model/Externalise.lean", "module": "ConNF.Model.Externalise", "jsonFile": "ConNF.Model.Externalise.jsonl", "positionMetadata": {"lineInFile": 59, "tokenPositionInFile": 1339, "theoremPositionInFile": 2}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 38, "numPremises": 83}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  apply LeData.ext\n  \u00b7 ext \u03b2 h\u03b2\n    induction \u03b2 using recBotCoe\n    case bot => rfl\n    case coe \u03b2 =>\n      by_cases h : (\u03b2 : TypeIndex) = \u03b1\n      \u00b7 cases coe_injective h\n        rw [leData_data_eq]\n        unfold globalLeData globalModelData\n        dsimp only\n        rw [motive_eq]\n        rfl\n      \u00b7 rw [leData_data_lt _ (h\u03b2.elim.lt_of_ne h)]\n        rfl\n  \u00b7 apply heq_funext\n    intro \u03b2\n    apply heq_funext\n    intro h\u03b2\n    induction \u03b2 using recBotCoe\n    case bot => rfl\n    case coe \u03b2 =>\n      rw [leData]\n      simp only [coe_inj, id_eq, eq_mpr_eq_cast, recBotCoe_bot, recBotCoe_coe, LtLevel.elim.ne]\n      exact HEq.symm (cast_heq _ _)", "proofType": "tactic", "proofLengthLines": 24, "proofLengthTokens": 652}}
{"srcContext": "import ConNF.ModelData.PathEnumeration\n\n/-!\n# Supports\n\nIn this file, we define the notion of a support.\n\n## Main declarations\n\n* `ConNF.BaseSupport`: The type of supports of atoms.\n* `ConNF.Support`: The type of supports of objects of arbitrary type indices.\n-/\n\nuniverse u\n\nopen Cardinal\n\nnamespace ConNF\n\nvariable [Params.{u}]\n\n/-!\n## Base supports\n-/\n\nstructure BaseSupport where\n  atoms : Enumeration Atom\n  nearLitters : Enumeration NearLitter\n\nnamespace BaseSupport\n\ninstance : SuperA BaseSupport (Enumeration Atom) where\n  superA := atoms\n\ninstance : SuperN BaseSupport (Enumeration NearLitter) where\n  superN := nearLitters\n\n@[simp]\ntheorem mk_atoms {a : Enumeration Atom} {N : Enumeration NearLitter} :\n    (BaseSupport.mk a N)\u1d2c = a :=\n  rfl\n\n@[simp]\ntheorem mk_nearLitters {a : Enumeration Atom} {N : Enumeration NearLitter} :\n    (BaseSupport.mk a N)\u1d3a = N :=\n  rfl\n\ntheorem atoms_congr {S T : BaseSupport} (h : S = T) :\n    S\u1d2c = T\u1d2c :=\n  h \u25b8 rfl\n\ntheorem nearLitters_congr {S T : BaseSupport} (h : S = T) :\n    S\u1d3a = T\u1d3a :=\n  h \u25b8 rfl\n\n@[ext]\ntheorem ext {S T : BaseSupport} (h\u2081 : S\u1d2c = T\u1d2c) (h\u2082 : S\u1d3a = T\u1d3a) : S = T := by\n  obtain \u27e8SA, SN\u27e9 := S\n  obtain \u27e8TA, TN\u27e9 := T\n  cases h\u2081\n  cases h\u2082\n  rfl\n\ninstance : SMul BasePerm BaseSupport where\n  smul \u03c0 S := \u27e8\u03c0 \u2022 S\u1d2c, \u03c0 \u2022 S\u1d3a\u27e9\n\n@[simp]\ntheorem smul_atoms (\u03c0 : BasePerm) (S : BaseSupport) :\n    (\u03c0 \u2022 S)\u1d2c = \u03c0 \u2022 S\u1d2c :=\n  rfl\n\n@[simp]\ntheorem smul_nearLitters (\u03c0 : BasePerm) (S : BaseSupport) :\n    (\u03c0 \u2022 S)\u1d3a = \u03c0 \u2022 S\u1d3a :=\n  rfl\n\n@[simp]\ntheorem smul_atoms_eq_of_smul_eq {\u03c0 : BasePerm} {S : BaseSupport}\n    (h : \u03c0 \u2022 S = S) :\n    \u03c0 \u2022 S\u1d2c = S\u1d2c := by\n  rw [\u2190 smul_atoms, h]\n\n@[simp]\ntheorem smul_nearLitters_eq_of_smul_eq {\u03c0 : BasePerm} {S : BaseSupport}\n    (h : \u03c0 \u2022 S = S) :\n    \u03c0 \u2022 S\u1d3a = S\u1d3a := by\n  rw [\u2190 smul_nearLitters, h]\n\ninstance : MulAction BasePerm BaseSupport where\n  one_smul S := by\n    apply ext\n    \u00b7 rw [smul_atoms, one_smul]\n    \u00b7 rw [smul_nearLitters, one_smul]\n  mul_smul \u03c0\u2081 \u03c0\u2082 S := by\n    apply ext\n    \u00b7 rw [smul_atoms, smul_atoms, smul_atoms, mul_smul]\n    \u00b7 rw [smul_nearLitters, smul_nearLitters, smul_nearLitters, mul_smul]\n\ntheorem smul_eq_smul_iff (\u03c0\u2081 \u03c0\u2082 : BasePerm) (S : BaseSupport) :\n    \u03c0\u2081 \u2022 S = \u03c0\u2082 \u2022 S \u2194 (\u2200 a \u2208 S\u1d2c, \u03c0\u2081 \u2022 a = \u03c0\u2082 \u2022 a) \u2227 (\u2200 N \u2208 S\u1d3a, \u03c0\u2081 \u2022 N = \u03c0\u2082 \u2022 N) := by\n  constructor\n  \u00b7 intro h\n    constructor\n    \u00b7 rintro a \u27e8i, ha\u27e9\n      have := congr_arg (\u00b7\u1d2c.rel i (\u03c0\u2081 \u2022 a)) h\n      simp only [smul_atoms, Enumeration.smul_rel, inv_smul_smul, eq_iff_iff] at this\n      have := S\u1d2c.rel_coinjective.coinjective ha (this.mp ha)\n      rw [eq_inv_smul_iff] at this\n      rw [this]\n    \u00b7 rintro N \u27e8i, hN\u27e9\n      have := congr_arg (\u00b7\u1d3a.rel i (\u03c0\u2081 \u2022 N)) h\n      simp only [smul_nearLitters, Enumeration.smul_rel, inv_smul_smul, eq_iff_iff] at this\n      have := S\u1d3a.rel_coinjective.coinjective hN (this.mp hN)\n      rw [eq_inv_smul_iff] at this\n      rw [this]\n  \u00b7 intro h\n    ext : 2\n    \u00b7 rfl\n    \u00b7 ext i a : 3\n      rw [smul_atoms, smul_atoms, Enumeration.smul_rel, Enumeration.smul_rel]\n      constructor\n      \u00b7 intro ha\n        have := h.1 _ \u27e8i, ha\u27e9\n        rw [smul_inv_smul, \u2190 inv_smul_eq_iff] at this\n        rwa [this]\n      \u00b7 intro ha\n        have := h.1 _ \u27e8i, ha\u27e9\n        rw [smul_inv_smul, smul_eq_iff_eq_inv_smul] at this\n        rwa [\u2190 this]\n    \u00b7 rfl\n    \u00b7 ext i a : 3\n      rw [smul_nearLitters, smul_nearLitters, Enumeration.smul_rel, Enumeration.smul_rel]\n      constructor\n      \u00b7 intro hN\n        have := h.2 _ \u27e8i, hN\u27e9\n        rw [smul_inv_smul, \u2190 inv_smul_eq_iff] at this\n        rwa [this]\n      \u00b7 intro hN\n        have := h.2 _ \u27e8i, hN\u27e9\n        rw [smul_inv_smul, smul_eq_iff_eq_inv_smul] at this\n        rwa [\u2190 this]\n\ntheorem smul_eq_iff (\u03c0 : BasePerm) (S : BaseSupport) :\n    \u03c0 \u2022 S = S \u2194 (\u2200 a \u2208 S\u1d2c, \u03c0 \u2022 a = a) \u2227 (\u2200 N \u2208 S\u1d3a, \u03c0 \u2022 N = N) := by\n  have := smul_eq_smul_iff \u03c0 1 S\n  simp only [one_smul] at this\n  exact this\n\nnoncomputable instance : Add BaseSupport where\n  add S T := \u27e8S\u1d2c + T\u1d2c, S\u1d3a + T\u1d3a\u27e9\n\n@[simp]\ntheorem add_atoms (S T : BaseSupport) :\n    (S + T)\u1d2c = S\u1d2c + T\u1d2c :=\n  rfl\n\n@[simp]\ntheorem add_nearLitters (S T : BaseSupport) :\n    (S + T)\u1d3a = S\u1d3a + T\u1d3a :=\n  rfl\n\nend BaseSupport\n\ndef baseSupportEquiv : BaseSupport \u2243 Enumeration Atom \u00d7 Enumeration NearLitter where\n  toFun S := (S\u1d2c, S\u1d3a)\n  invFun S := \u27e8S.1, S.2\u27e9\n  left_inv _ := rfl\n  right_inv _ := rfl\n\ntheorem card_baseSupport : #BaseSupport = #\u03bc := by\n  rw [Cardinal.eq.mpr \u27e8baseSupportEquiv\u27e9, mk_prod, lift_id, lift_id,\n    card_enumeration_eq card_atom, card_enumeration_eq card_nearLitter, mul_eq_self aleph0_lt_\u03bc.le]\n\n/-!\n## Structural supports\n-/\n\nstructure Support (\u03b1 : TypeIndex) where\n  atoms : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)\n  nearLitters : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)\n\nnamespace Support\n\nvariable {\u03b1 \u03b2 : TypeIndex}\n\ninstance : SuperA (Support \u03b1) (Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) where\n  superA := atoms\n\ninstance : SuperN (Support \u03b1) (Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) where\n  superN := nearLitters\n\n@[simp]\ntheorem mk_atoms (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) (F : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) :\n    (\u27e8E, F\u27e9 : Support \u03b1)\u1d2c = E :=\n  rfl\n\n@[simp]\ntheorem mk_nearLitters (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) (F : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) :\n    (\u27e8E, F\u27e9 : Support \u03b1)\u1d3a = F :=\n  rfl\n\ninstance : Derivative (Support \u03b1) (Support \u03b2) \u03b1 \u03b2 where\n  deriv S A := \u27e8S\u1d2c \u21d8 A, S\u1d3a \u21d8 A\u27e9\n\ninstance : Coderivative (Support \u03b2) (Support \u03b1) \u03b1 \u03b2 where\n  coderiv S A := \u27e8S\u1d2c \u21d7 A, S\u1d3a \u21d7 A\u27e9\n\ninstance : BotDerivative (Support \u03b1) BaseSupport \u03b1 where\n  botDeriv S A := \u27e8S\u1d2c \u21d8. A, S\u1d3a \u21d8. A\u27e9\n  botSderiv S := \u27e8S\u1d2c \u2198., S\u1d3a \u2198.\u27e9\n  botDeriv_single S h := by dsimp only; rw [botDeriv_single, botDeriv_single]\n\n@[simp]\ntheorem deriv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u03b2) :\n    S\u1d2c \u21d8 A = (S \u21d8 A)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem deriv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u03b2) :\n    S\u1d3a \u21d8 A = (S \u21d8 A)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem sderiv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (h : \u03b2 < \u03b1) :\n    S\u1d2c \u2198 h = (S \u2198 h)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem sderiv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (h : \u03b2 < \u03b1) :\n    S\u1d3a \u2198 h = (S \u2198 h)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem coderiv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    S\u1d2c \u21d7 A = (S \u21d7 A)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem coderiv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    S\u1d3a \u21d7 A = (S \u21d7 A)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem scoderiv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (h : \u03b2 < \u03b1) :\n    S\u1d2c \u2197 h = (S \u2197 h)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem scoderiv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (h : \u03b2 < \u03b1) :\n    S\u1d3a \u2197 h = (S \u2197 h)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem derivBot_atoms {\u03b1 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u22a5) :\n    S\u1d2c \u21d8. A = (S \u21d8. A)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem derivBot_nearLitters {\u03b1 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u22a5) :\n    S\u1d3a \u21d8. A = (S \u21d8. A)\u1d3a :=\n  rfl\n\ntheorem ext' {S T : Support \u03b1} (h\u2081 : S\u1d2c = T\u1d2c) (h\u2082 : S\u1d3a = T\u1d3a) : S = T := by\n  obtain \u27e8SA, SN\u27e9 := S\n  obtain \u27e8TA, TN\u27e9 := T\n  cases h\u2081\n  cases h\u2082\n  rfl\n\n@[ext]\ntheorem ext {S T : Support \u03b1} (h : \u2200 A, S \u21d8. A = T \u21d8. A) : S = T := by\n  obtain \u27e8SA, SN\u27e9 := S\n  obtain \u27e8TA, TN\u27e9 := T\n  rw [mk.injEq]\n  constructor\n  \u00b7 apply Enumeration.ext_path\n    intro A\n    exact BaseSupport.atoms_congr (h A)\n  \u00b7 apply Enumeration.ext_path\n    intro A\n    exact BaseSupport.nearLitters_congr (h A)\n\n@[simp]\ntheorem deriv_derivBot {\u03b1 : TypeIndex} (S : Support \u03b1)\n    (A : \u03b1 \u219d \u03b2) (B : \u03b2 \u219d \u22a5) :\n    S \u21d8 A \u21d8. B = S \u21d8. (A \u21d8 B) :=\n  rfl\n\n@[simp]\ntheorem coderiv_deriv_eq {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    S \u21d7 A \u21d8 A = S :=\n  ext' (S\u1d2c.coderiv_deriv_eq A) (S\u1d3a.coderiv_deriv_eq A)\n\ntheorem eq_of_atom_mem_scoderiv_botDeriv {\u03b1 \u03b2 : TypeIndex} {S : Support \u03b2} {A : \u03b1 \u219d \u22a5}\n    {h : \u03b2 < \u03b1} {a : Atom} (ha : a \u2208 (S \u2197 h \u21d8. A)\u1d2c) :\n    \u2203 B : \u03b2 \u219d \u22a5, A = B \u2197 h :=\n  Enumeration.eq_of_mem_scoderiv_botDeriv ha\n\ntheorem eq_of_nearLitter_mem_scoderiv_botDeriv {\u03b1 \u03b2 : TypeIndex} {S : Support \u03b2} {A : \u03b1 \u219d \u22a5}\n    {h : \u03b2 < \u03b1} {N : NearLitter} (hN : N \u2208 (S \u2197 h \u21d8. A)\u1d3a) :\n    \u2203 B : \u03b2 \u219d \u22a5, A = B \u2197 h :=\n  Enumeration.eq_of_mem_scoderiv_botDeriv hN\n\n@[simp]\ntheorem scoderiv_botDeriv_eq {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (A : \u03b2 \u219d \u22a5) (h : \u03b2 < \u03b1) :\n    S \u2197 h \u21d8. (A \u2197 h) = S \u21d8. A :=\n  BaseSupport.ext (Enumeration.scoderiv_botDeriv_eq _ _ _) (Enumeration.scoderiv_botDeriv_eq _ _ _)\n\n", "theoremStatement": "@[simp]\ntheorem scoderiv_deriv_eq {\u03b1 \u03b2 \u03b3 : TypeIndex} (S : Support \u03b2) (A : \u03b2 \u219d \u03b3) (h : \u03b2 < \u03b1) :\n    S \u2197 h \u21d8 (A \u2197 h) = S \u21d8 A ", "theoremName": "ConNF.Support.scoderiv_deriv_eq", "fileCreated": {"commit": "39c33b4a743bea62dbcc549548b712ffd38ca65c", "date": "2024-12-05"}, "theoremCreated": {"commit": "ce890707e37ede74a2fcd66134d3f403335c5cc1", "date": "2024-11-30"}, "file": "ConNF/ConNF/ModelData/Support.lean", "module": "ConNF.ModelData.Support", "jsonFile": "ConNF.ModelData.Support.jsonl", "positionMetadata": {"lineInFile": 309, "tokenPositionInFile": 8091, "theoremPositionInFile": 33}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 7, "repositoryPremises": true, "numRepositoryPremises": 20, "numPremises": 38}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  apply ext\n  intro B\n  simp only [deriv_derivBot, \u2190 scoderiv_botDeriv_eq S (A \u21d8 B) h, Path.coderiv_deriv']", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 113}}
{"srcContext": "import ConNF.Base.TypeIndex\n\n/-!\n# Paths of type indices\n\nIn this file, we define the notion of a *path*, and the derivative and coderivative operations.\n\n## Main declarations\n\n* `ConNF.Path`: A path of type indices.\n* `ConNF.Path.recSderiv`, `ConNF.Path.recSderivLe`, `ConNF.Path.recSderivGlobal`:\n    Downwards induction principles for paths.\n* `ConNF.Path.recScoderiv`: An upwards induction principle for paths.\n-/\n\nuniverse u\n\nopen Cardinal WithBot\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 : TypeIndex}\n\n/-- A path of type indices starting at `\u03b1` and ending at `\u03b2` is a finite sequence of type indices\n`\u03b1 > ... > \u03b2`. -/\ninductive Path (\u03b1 : TypeIndex) : TypeIndex \u2192 Type u\n  | nil : Path \u03b1 \u03b1\n  | cons {\u03b2 \u03b3 : TypeIndex} : Path \u03b1 \u03b2 \u2192 \u03b3 < \u03b2 \u2192 Path \u03b1 \u03b3\n\n@[inherit_doc] infix:70 \" \u219d \"  => Path\n\ndef Path.single {\u03b1 \u03b2 : TypeIndex} (h : \u03b2 < \u03b1) : \u03b1 \u219d \u03b2 :=\n  .cons .nil h\n\n/-- Typeclass for the `\u2198` notation. -/\nclass SingleDerivative (X : Type _) (Y : outParam <| Type _)\n    (\u03b2 : outParam TypeIndex) (\u03b3 : TypeIndex) where\n  sderiv : X \u2192 \u03b3 < \u03b2 \u2192 Y\n\n/-- Typeclass for the `\u21d8` notation. -/\nclass Derivative (X : Type _) (Y : outParam <| Type _)\n    (\u03b2 : outParam TypeIndex) (\u03b3 : TypeIndex) extends SingleDerivative X Y \u03b2 \u03b3 where\n  deriv : X \u2192 \u03b2 \u219d \u03b3 \u2192 Y\n  sderiv x h := deriv x (.single h)\n  deriv_single : \u2200 x : X, \u2200 h : \u03b3 < \u03b2, deriv x (.single h) = sderiv x h := by intros; rfl\n\n/-- Typeclass for the `\u2198.` notation. -/\nclass BotSingleDerivative (X : Type _) (Y : outParam <| Type _) where\n  botSderiv : X \u2192 Y\n\n/-- Typeclass for the `\u21d8.` notation. -/\nclass BotDerivative (X : Type _) (Y : outParam <| Type _) (\u03b2 : outParam TypeIndex)\n    extends BotSingleDerivative X Y where\n  botDeriv : X \u2192 \u03b2 \u219d \u22a5 \u2192 Y\n  /-- We often need to do case analysis on `\u03b2` to show that it's a proper type index here.\n  This case check doesn't need to be done in most actual use cases of the notation. -/\n  botDeriv_single : \u2200 x : X, \u2200 h : \u22a5 < \u03b2, botDeriv x (.single h) = botSderiv x\n\n/-- Typeclass for the `\u2197` notation. -/\nclass SingleCoderivative (X : Type _) (Y : outParam <| Type _)\n    (\u03b2 : TypeIndex) (\u03b3 : outParam TypeIndex) where\n  scoderiv : X \u2192 \u03b3 < \u03b2 \u2192 Y\n\n/-- Typeclass for the `\u21d7` notation. -/\nclass Coderivative (X : Type _) (Y : outParam <| Type _)\n    (\u03b2 : TypeIndex) (\u03b3 : outParam TypeIndex) extends SingleCoderivative X Y \u03b2 \u03b3 where\n  coderiv : X \u2192 \u03b2 \u219d \u03b3 \u2192 Y\n  scoderiv x h := coderiv x (.single h)\n  coderiv_single : \u2200 x : X, \u2200 h : \u03b3 < \u03b2, coderiv x (.single h) = scoderiv x h := by intros; rfl\n\ninfixl:75 \" \u2198 \" => SingleDerivative.sderiv\ninfixl:75 \" \u21d8 \" => Derivative.deriv\npostfix:75 \" \u2198.\" => BotSingleDerivative.botSderiv\ninfixl:75 \" \u21d8. \" => BotDerivative.botDeriv\ninfixl:75 \" \u2197 \" => SingleCoderivative.scoderiv\ninfixl:75 \" \u21d7 \" => Coderivative.coderiv\n\n@[simp]\ntheorem deriv_single {X Y : Type _} [Derivative X Y \u03b2 \u03b3] (x : X) (h : \u03b3 < \u03b2) :\n    x \u21d8 .single h = x \u2198 h :=\n  Derivative.deriv_single x h\n\n@[simp]\ntheorem coderiv_single {X Y : Type _} [Coderivative X Y \u03b2 \u03b3] (x : X) (h : \u03b3 < \u03b2) :\n    x \u21d7 .single h = x \u2197 h :=\n  Coderivative.coderiv_single x h\n\n@[simp]\ntheorem botDeriv_single {X Y : Type _} [BotDerivative X Y \u03b2] (x : X) (h : \u22a5 < \u03b2) :\n    x \u21d8. .single h = x \u2198. :=\n  BotDerivative.botDeriv_single x h\n\n/-!\n## Downwards recursion along paths\n-/\n\ninstance : SingleDerivative (\u03b1 \u219d \u03b2) (\u03b1 \u219d \u03b3) \u03b2 \u03b3 where\n  sderiv := .cons\n\n/-- The downwards recursion principle for paths. -/\n@[elab_as_elim, induction_eliminator, cases_eliminator]\ndef Path.recSderiv {motive : \u2200 \u03b2, \u03b1 \u219d \u03b2 \u2192 Sort _}\n    (nil : motive \u03b1 .nil)\n    (sderiv : \u2200 \u03b2 \u03b3 (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2), motive \u03b2 A \u2192 motive \u03b3 (A \u2198 h)) :\n    {\u03b2 : TypeIndex} \u2192 (A : \u03b1 \u219d \u03b2) \u2192 motive \u03b2 A\n  | _, .nil => nil\n  | _, .cons A h => sderiv _ _ A h (recSderiv nil sderiv A)\n\n@[simp]\ntheorem Path.recSderiv_nil {motive : \u2200 \u03b2, \u03b1 \u219d \u03b2 \u2192 Sort _}\n    (nil : motive \u03b1 .nil)\n    (sderiv : \u2200 \u03b2 \u03b3 (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2), motive \u03b2 A \u2192 motive \u03b3 (A \u2198 h)) :\n    recSderiv (motive := motive) nil sderiv .nil = nil :=\n  rfl\n\n@[simp]\ntheorem Path.recSderiv_sderiv {motive : \u2200 \u03b2, \u03b1 \u219d \u03b2 \u2192 Sort _}\n    (nil : motive \u03b1 .nil)\n    (sderiv : \u2200 \u03b2 \u03b3 (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2), motive \u03b2 A \u2192 motive \u03b3 (A \u2198 h))\n    {\u03b2 \u03b3 : TypeIndex} (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2) :\n    recSderiv (motive := motive) nil sderiv (A \u2198 h) = sderiv \u03b2 \u03b3 A h (recSderiv nil sderiv A) :=\n  rfl\n\ntheorem Path.le (A : \u03b1 \u219d \u03b2) : \u03b2 \u2264 \u03b1 := by\n  induction A with\n  | nil => exact le_rfl\n  | sderiv \u03b2 \u03b3 _A h h' => exact h.le.trans h'\n\n/-- The downwards recursion principle for paths, specialised to the case where the motive at `\u03b2`\nonly depends on the fact that `\u03b2 \u2264 \u03b1`. -/\ndef Path.recSderivLe {motive : \u2200 \u03b2 \u2264 \u03b1, Sort _}\n    (nil : motive \u03b1 le_rfl)\n    (sderiv : \u2200 \u03b2 \u03b3, \u2200 (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2), motive \u03b2 A.le \u2192 motive \u03b3 (h.le.trans A.le)) :\n    {\u03b2 : TypeIndex} \u2192 (A : \u03b1 \u219d \u03b2) \u2192 motive \u03b2 A.le :=\n  Path.recSderiv (motive := \u03bb \u03b2 A \u21a6 motive \u03b2 A.le) nil sderiv\n\n@[simp]\ntheorem Path.recSderivLe_nil {motive : \u2200 \u03b2 \u2264 \u03b1, Sort _}\n    (nil : motive \u03b1 le_rfl)\n    (sderiv : \u2200 \u03b2 \u03b3 (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2), motive \u03b2 A.le \u2192 motive \u03b3 (h.le.trans A.le)) :\n    recSderivLe (motive := motive) nil sderiv .nil = nil :=\n  rfl\n\n@[simp]\ntheorem Path.recSderivLe_sderiv {motive : \u2200 \u03b2 \u2264 \u03b1, Sort _}\n    (nil : motive \u03b1 le_rfl)\n    (sderiv : \u2200 \u03b2 \u03b3 (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2), motive \u03b2 A.le \u2192 motive \u03b3 (h.le.trans A.le))\n    {\u03b2 \u03b3 : TypeIndex} (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2) :\n    recSderivLe (motive := motive) nil sderiv (A \u2198 h) = sderiv \u03b2 \u03b3 A h (recSderiv nil sderiv A) :=\n  rfl\n\n/-- The downwards recursion principle for paths, specialised to the case where the motive is not\ndependent on the relation of `\u03b2` to `\u03b1`. -/\n@[elab_as_elim]\ndef Path.recSderivGlobal {motive : TypeIndex \u2192 Sort _}\n    (nil : motive \u03b1)\n    (sderiv : \u2200 \u03b2 \u03b3, \u03b1 \u219d \u03b2 \u2192 \u03b3 < \u03b2 \u2192 motive \u03b2 \u2192 motive \u03b3) :\n    {\u03b2 : TypeIndex} \u2192 \u03b1 \u219d \u03b2 \u2192 motive \u03b2 :=\n  Path.recSderiv (motive := \u03bb \u03b2 _ \u21a6 motive \u03b2) nil sderiv\n\n@[simp]\ntheorem Path.recSderivGlobal_nil {motive : TypeIndex \u2192 Sort _}\n    (nil : motive \u03b1)\n    (sderiv : \u2200 \u03b2 \u03b3, \u03b1 \u219d \u03b2 \u2192 \u03b3 < \u03b2 \u2192 motive \u03b2 \u2192 motive \u03b3) :\n    recSderivGlobal (motive := motive) nil sderiv .nil = nil :=\n  rfl\n\n@[simp]\ntheorem Path.recSderivGlobal_sderiv {motive : TypeIndex \u2192 Sort _}\n    (nil : motive \u03b1)\n    (sderiv : \u2200 \u03b2 \u03b3, \u03b1 \u219d \u03b2 \u2192 \u03b3 < \u03b2 \u2192 motive \u03b2 \u2192 motive \u03b3)\n    {\u03b2 \u03b3 : TypeIndex} (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2) :\n    recSderivGlobal (motive := motive) nil sderiv (A \u2198 h) =\n      sderiv \u03b2 \u03b3 A h (recSderiv nil sderiv A) :=\n  rfl\n\n/-!\n## Derivatives of paths\n-/\n\ninstance : Derivative (\u03b1 \u219d \u03b2) (\u03b1 \u219d \u03b3) \u03b2 \u03b3 where\n  deriv A := Path.recSderivGlobal A (\u03bb _ _ _ h B \u21a6 B \u2198 h)\n\ninstance : BotDerivative (\u03b1 \u219d \u03b2) (\u03b1 \u219d \u22a5) \u03b2 where\n  botDeriv A B := A \u21d8 B\n  botSderiv A :=\n    match \u03b2 with\n      | \u22a5 => A\n      | (\u03b2 : \u039b) => A \u2198 bot_lt_coe \u03b2\n  botDeriv_single A h := by\n    cases \u03b2 using WithBot.recBotCoe with\n    | bot => cases lt_irrefl \u22a5 h\n    | coe => rfl\n\ninstance : Coderivative (\u03b2 \u219d \u03b3) (\u03b1 \u219d \u03b3) \u03b1 \u03b2 where\n  coderiv A B := B \u21d8 A\n\n@[simp]\ntheorem Path.deriv_nil (A : \u03b1 \u219d \u03b2) :\n    A \u21d8 .nil = A :=\n  rfl\n\n@[simp]\ntheorem Path.deriv_sderiv (A : \u03b1 \u219d \u03b2) (B : \u03b2 \u219d \u03b3) (h : \u03b4 < \u03b3) :\n    A \u21d8 (B \u2198 h) = A \u21d8 B \u2198 h :=\n  rfl\n\n@[simp]\ntheorem Path.nil_deriv (A : \u03b1 \u219d \u03b2) :\n    (.nil : \u03b1 \u219d \u03b1) \u21d8 A = A := by\n  induction A with\n  | nil => rfl\n  | sderiv \u03b3 \u03b4 A h ih => rw [deriv_sderiv, ih]\n\n@[simp]\ntheorem Path.deriv_sderivBot (A : \u03b1 \u219d \u03b2) (B : \u03b2 \u219d \u03b3) :\n    A \u21d8 (B \u2198.) = A \u21d8 B \u2198. := by\n  cases \u03b3 using WithBot.recBotCoe with\n  | bot => rfl\n  | coe => rfl\n\n@[simp]\ntheorem Path.botSderiv_bot_eq (A : \u03b1 \u219d \u22a5) :\n    A \u2198. = A :=\n  rfl\n\n@[simp]\ntheorem Path.botSderiv_coe_eq {\u03b2 : \u039b} (A : \u03b1 \u219d \u03b2) :\n    A \u2198 bot_lt_coe \u03b2 = A \u2198. :=\n  rfl\n\n@[simp]\ntheorem Path.deriv_assoc (A : \u03b1 \u219d \u03b2) (B : \u03b2 \u219d \u03b3) (C : \u03b3 \u219d \u03b4) :\n    A \u21d8 (B \u21d8 C) = A \u21d8 B \u21d8 C := by\n  induction C with\n  | nil => rfl\n  | sderiv \u03b5 \u03b6 C h ih => simp only [deriv_sderiv, ih]\n\n@[simp]\ntheorem Path.deriv_sderiv_assoc (A : \u03b1 \u219d \u03b2) (B : \u03b2 \u219d \u03b3) (h : \u03b4 < \u03b3) :\n    A \u21d8 (B \u2198 h) = A \u21d8 B \u2198 h :=\n  rfl\n\n@[simp]\ntheorem Path.deriv_scoderiv (A : \u03b1 \u219d \u03b2) (B : \u03b3 \u219d \u03b4) (h : \u03b3 < \u03b2) :\n    A \u21d8 (B \u2197 h) = A \u2198 h \u21d8 B := by\n  induction B with\n  | nil => rfl\n  | sderiv \u03b5 \u03b6 B h' ih =>\n    rw [deriv_sderiv, \u2190 ih]\n    rfl\n\n", "theoremStatement": "@[simp]\ntheorem Path.botDeriv_scoderiv (A : \u03b1 \u219d \u03b2) (B : \u03b3 \u219d \u22a5) (h : \u03b3 < \u03b2) :\n    A \u21d8. (B \u2197 h) = A \u2198 h \u21d8. B ", "theoremName": "ConNF.Path.botDeriv_scoderiv", "fileCreated": {"commit": "8896e416a16c39e1fe487b5fc7c78bc20c4e182b", "date": "2024-12-03"}, "theoremCreated": {"commit": "251ac752f844dfde539ac2bd3ff112305ad59139", "date": "2024-11-30"}, "file": "ConNF/ConNF/Levels/Path.lean", "module": "ConNF.Levels.Path", "jsonFile": "ConNF.Levels.Path.jsonl", "positionMetadata": {"lineInFile": 253, "tokenPositionInFile": 8033, "theoremPositionInFile": 29}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 9, "repositoryPremises": true, "numRepositoryPremises": 14, "numPremises": 25}, "proofMetadata": {"hasProof": true, "proof": ":=\n  deriv_scoderiv A B h", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 25}}
{"srcContext": "import ConNF.Model.RaiseStrong\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nopen scoped Pointwise\n\nnamespace ConNF\n\nvariable [Params.{u}]\n\n/-- A redefinition of the derivative of allowable permutations that is invariant of level,\nbut still has nice definitional properties. -/\n@[default_instance 200]\ninstance {\u03b2 \u03b3 : TypeIndex} : Derivative (AllPerm \u03b2) (AllPerm \u03b3) \u03b2 \u03b3 where\n  deriv \u03c1 A :=\n    A.recSderiv\n    (motive := \u03bb (\u03b4 : TypeIndex) (A : \u03b2 \u219d \u03b4) \u21a6\n      letI : Level := \u27e8\u03b4.recBotCoe (Nonempty.some inferInstance) id\u27e9\n      letI : LeLevel \u03b4 := \u27e8\u03b4.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n        (show \u03b4.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n      AllPerm \u03b4)\n    \u03c1 (\u03bb \u03b4 \u03b5 A h \u03c1 \u21a6\n      letI : Level := \u27e8\u03b4.recBotCoe (Nonempty.some inferInstance) id\u27e9\n      letI : LeLevel \u03b4 := \u27e8\u03b4.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n        (show \u03b4.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n      letI : LeLevel \u03b5 := \u27e8h.le.trans LeLevel.elim\u27e9\n      PreCoherentData.allPermSderiv h \u03c1)\n\n@[simp]\ntheorem allPerm_deriv_nil' {\u03b2 : TypeIndex}\n    (\u03c1 : AllPerm \u03b2) :\n    \u03c1 \u21d8 (.nil : \u03b2 \u219d \u03b2) = \u03c1 :=\n  rfl\n\n@[simp]\ntheorem allPerm_deriv_sderiv' {\u03b2 \u03b3 \u03b4 : TypeIndex}\n    (\u03c1 : AllPerm \u03b2) (A : \u03b2 \u219d \u03b3) (h : \u03b4 < \u03b3) :\n    \u03c1 \u21d8 (A \u2198 h) = \u03c1 \u21d8 A \u2198 h :=\n  rfl\n\n@[simp]\ntheorem allPermSderiv_forget' {\u03b2 \u03b3 : TypeIndex} (h : \u03b3 < \u03b2) (\u03c1 : AllPerm \u03b2) :\n    (\u03c1 \u2198 h)\u1d41 = \u03c1\u1d41 \u2198 h :=\n  letI : Level := \u27e8\u03b2.recBotCoe (Nonempty.some inferInstance) id\u27e9\n  letI : LeLevel \u03b2 := \u27e8\u03b2.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n    (show \u03b2.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n  letI : LeLevel \u03b3 := \u27e8h.le.trans LeLevel.elim\u27e9\n  allPermSderiv_forget h \u03c1\n\n@[simp]\ntheorem allPerm_inv_sderiv' {\u03b2 \u03b3 : TypeIndex} (h : \u03b3 < \u03b2) (\u03c1 : AllPerm \u03b2) :\n    \u03c1\u207b\u00b9 \u2198 h = (\u03c1 \u2198 h)\u207b\u00b9 := by\n  apply allPermForget_injective\n  rw [allPermSderiv_forget', allPermForget_inv, Tree.inv_sderiv, allPermForget_inv,\n    allPermSderiv_forget']\n\ndef Symmetric {\u03b1 \u03b2 : \u039b} (s : Set (TSet \u03b2)) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) : Prop :=\n  \u2203 S : Support \u03b1, \u2200 \u03c1 : AllPerm \u03b1, \u03c1\u1d41 \u2022 S = S \u2192 \u03c1 \u2198 h\u03b2 \u2022 s = s\n\ndef newSetEquiv {\u03b1 : \u039b} :\n    letI : Level := \u27e8\u03b1\u27e9\n    @TSet _ \u03b1 newModelData.toPreModelData \u2243 TSet \u03b1 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castTSet (D\u2081 := newModelData) (D\u2082 := globalModelData) rfl\n    (by rw [globalModelData, motive_eq, constructMotive, globalLtData_eq])\n\n@[simp]\ntheorem newSetEquiv_forget {\u03b1 : \u039b}\n    (x : letI : Level := \u27e8\u03b1\u27e9; @TSet _ \u03b1 newModelData.toPreModelData) :\n    (newSetEquiv x)\u1d41 = x\u1d41 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castTSet_forget (D\u2081 := newModelData) (D\u2082 := globalModelData) _ x\n\ndef allPermEquiv {\u03b1 : \u039b} :\n    letI : Level := \u27e8\u03b1\u27e9\n    NewPerm \u2243 AllPerm \u03b1 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castAllPerm (D\u2081 := newModelData) (D\u2082 := globalModelData) rfl\n    (by rw [globalModelData, motive_eq, constructMotive, globalLtData_eq])\n\n@[simp]\ntheorem allPermEquiv_forget {\u03b1 : \u039b} (\u03c1 : letI : Level := \u27e8\u03b1\u27e9; NewPerm) :\n    (allPermEquiv \u03c1)\u1d41 = \u03c1\u1d41 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castAllPerm_forget (D\u2081 := newModelData) (D\u2082 := globalModelData) _ \u03c1\n\ntheorem allPermEquiv_sderiv {\u03b1 \u03b2 : \u039b}\n    (\u03c1 : letI : Level := \u27e8\u03b1\u27e9; NewPerm) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) :\n    letI : Level := \u27e8\u03b1\u27e9\n    letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n    allPermEquiv \u03c1 \u2198 h\u03b2 = \u03c1.sderiv \u03b2 := by\n  letI : Level := \u27e8\u03b1\u27e9\n  letI : LeLevel \u03b1 := \u27e8le_rfl\u27e9\n  letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n  apply allPermForget_injective\n  rw [allPermSderiv_forget, allPermEquiv_forget, NewPerm.forget_sderiv]\n\ntheorem TSet.exists_of_symmetric {\u03b1 \u03b2 : \u039b} (s : Set (TSet \u03b2)) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1)\n    (hs : Symmetric s h\u03b2) :\n    \u2203 x : TSet \u03b1, \u2200 y : TSet \u03b2, y \u2208[h\u03b2] x \u2194 y \u2208 s := by\n  letI : Level := \u27e8\u03b1\u27e9\n  letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n  suffices \u2203 x : (@TSet _ \u03b1 newModelData.toPreModelData), \u2200 y : TSet \u03b2, y\u1d41 \u2208[h\u03b2] x\u1d41 \u2194 y \u2208 s by\n    obtain \u27e8x, hx\u27e9 := this\n    use newSetEquiv x\n    intro y\n    rw [\u2190 hx, \u2190 TSet.forget_mem_forget, newSetEquiv_forget]\n  obtain rfl | hs' := s.eq_empty_or_nonempty\n  \u00b7 use none\n    intro y\n    simp only [Set.mem_empty_iff_false, iff_false]\n    exact not_mem_none y\n  \u00b7 use some (Code.toSet \u27e8\u03b2, s, hs'\u27e9 ?_)\n    \u00b7 intro y\n      erw [mem_some_iff]\n      exact Code.mem_toSet _\n    \u00b7 obtain \u27e8S, hS\u27e9 := hs\n      use S\n      intro \u03c1 h\u03c1S\n      have := hS (allPermEquiv \u03c1) ?_\n      \u00b7 simp only [NewPerm.smul_mk, Code.mk.injEq, heq_eq_eq, true_and]\n        rwa [allPermEquiv_sderiv] at this\n      \u00b7 rwa [allPermEquiv_forget]\n\ntheorem TSet.exists_support {\u03b1 : \u039b} (x : TSet \u03b1) :\n    \u2203 S : Support \u03b1, \u2200 \u03c1 : AllPerm \u03b1, \u03c1\u1d41 \u2022 S = S \u2192 \u03c1 \u2022 x = x := by\n  letI : Level := \u27e8\u03b1\u27e9\n  obtain \u27e8S, hS\u27e9 := NewSet.exists_support (newSetEquiv.symm x)\n  use S\n  intro \u03c1 h\u03c1\n  have := @Support.Supports.supports _ _ _ newPreModelData _ _ _ hS (allPermEquiv.symm \u03c1) ?_\n  \u00b7 apply tSetForget_injective\n    have := congr_arg (\u00b7\u1d41) this\n    simp only at this\n    erw [@smul_forget _ _ newModelData (allPermEquiv.symm \u03c1) (newSetEquiv.symm x),\n      \u2190 allPermEquiv_forget, \u2190 newSetEquiv_forget, Equiv.apply_symm_apply,\n      Equiv.apply_symm_apply] at this\n    rwa [smul_forget]\n  \u00b7 rwa [\u2190 allPermEquiv_forget, Equiv.apply_symm_apply]\n\ntheorem TSet.symmetric {\u03b1 \u03b2 : \u039b} (x : TSet \u03b1) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) :\n    Symmetric {y : TSet \u03b2 | y \u2208[h\u03b2] x} h\u03b2 := by\n  obtain \u27e8S, hS\u27e9 := exists_support x\n  use S\n  intro \u03c1 h\u03c1\n  conv_rhs => rw [\u2190 hS \u03c1 h\u03c1]\n  simp only [\u2190 forget_mem_forget, smul_forget, StrSet.mem_smul_iff]\n  ext y\n  rw [Set.mem_smul_set_iff_inv_smul_mem, Set.mem_setOf_eq, Set.mem_setOf_eq,\n    smul_forget, allPermForget_inv, allPermSderiv_forget']\n\ntheorem tSet_ext' {\u03b1 \u03b2 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (x y : TSet \u03b1)\n    (h : \u2200 z : TSet \u03b2, z \u2208[h\u03b2] x \u2194 z \u2208[h\u03b2] y) : x = y :=\n  letI : Level := \u27e8\u03b1\u27e9\n  letI : LeLevel \u03b1 := \u27e8le_rfl\u27e9\n  letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n  tSet_ext h\u03b2 x y h\n\n@[simp]\ntheorem TSet.mem_smul_iff' {\u03b1 \u03b2 : TypeIndex}\n    {x : TSet \u03b2} {y : TSet \u03b1} (h : \u03b2 < \u03b1) (\u03c1 : AllPerm \u03b1) :\n    x \u2208[h] \u03c1 \u2022 y \u2194 \u03c1\u207b\u00b9 \u2198 h \u2022 x \u2208[h] y := by\n  letI : Level := \u27e8\u03b1.recBotCoe (Nonempty.some inferInstance) id\u27e9\n  letI : LeLevel \u03b1 := \u27e8\u03b1.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n    (show \u03b1.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n  letI : LtLevel \u03b2 := \u27e8h.trans_le LeLevel.elim\u27e9\n  exact mem_smul_iff h \u03c1  -- For some reason, using `exact` instead of term mode speeds this up!\n\ndef singleton {\u03b1 \u03b2 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (x : TSet \u03b2) : TSet \u03b1 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  letI : LeLevel \u03b1 := \u27e8le_rfl\u27e9\n  letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n  PreCoherentData.singleton h\u03b2 x\n\n@[simp]\ntheorem typedMem_singleton_iff' {\u03b1 \u03b2 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (x y : TSet \u03b2) :\n    y \u2208[h\u03b2] singleton h\u03b2 x \u2194 y = x :=\n  letI : Level := \u27e8\u03b1\u27e9\n  letI : LeLevel \u03b1 := \u27e8le_rfl\u27e9\n  letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n  typedMem_singleton_iff h\u03b2 x y\n\n@[simp]\ntheorem smul_singleton {\u03b1 \u03b2 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (x : TSet \u03b2) (\u03c1 : AllPerm \u03b1) :\n    \u03c1 \u2022 singleton h\u03b2 x = singleton h\u03b2 (\u03c1 \u2198 h\u03b2 \u2022 x) := by\n  apply tSet_ext' h\u03b2\n  intro z\n  rw [TSet.mem_smul_iff', allPerm_inv_sderiv', typedMem_singleton_iff', typedMem_singleton_iff',\n    inv_smul_eq_iff]\n\ntheorem singleton_injective {\u03b1 \u03b2 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) :\n    Function.Injective (singleton h\u03b2) := by\n  intro x y hxy\n  have := typedMem_singleton_iff' h\u03b2 x y\n  rw [hxy, typedMem_singleton_iff'] at this\n  exact (this.mp rfl).symm\n\n@[simp]\ntheorem singleton_inj {\u03b1 \u03b2 : \u039b} {h\u03b2 : (\u03b2 : TypeIndex) < \u03b1} {x y : TSet \u03b2} :\n    singleton h\u03b2 x = singleton h\u03b2 y \u2194 x = y :=\n  (singleton_injective h\u03b2).eq_iff\n\ntheorem sUnion_singleton_symmetric_aux' {\u03b1 \u03b2 \u03b3 : \u039b}\n    (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (s : Set (TSet \u03b3)) (S : Support \u03b1)\n    (hS : \u2200 \u03c1 : AllPerm \u03b1, \u03c1\u1d41 \u2022 S = S \u2192 \u03c1 \u2198 h\u03b2 \u2022 singleton h\u03b3 '' s = singleton h\u03b3 '' s) :\n    letI : Level := \u27e8\u03b1\u27e9\n    letI : LeLevel \u03b1 := \u27e8le_rfl\u27e9\n    \u2200 (\u03c1 : AllPerm \u03b2), \u03c1\u1d41 \u2022 S.strong \u2198 h\u03b2 = S.strong \u2198 h\u03b2 \u2192 \u03c1 \u2198 h\u03b3 \u2022 s \u2286 s := by\n  letI : Level := \u27e8\u03b1\u27e9\n  letI : LeLevel \u03b1 := \u27e8le_rfl\u27e9\n  letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n  rintro \u03c1 h\u03c1 _ \u27e8x, hx, rfl\u27e9\n  obtain \u27e8T, hT\u27e9 := exists_support x\n  obtain \u27e8\u03c1', h\u03c1'\u2081, h\u03c1'\u2082\u27e9 := Support.exists_allowable_of_fixes S.strong S.strong_strong T \u03c1 h\u03b3 h\u03c1\n  have h\u03c1's := hS \u03c1' (smul_eq_of_le (S.subsupport_strong.le) h\u03c1'\u2081)\n  have h\u03c1'x : \u03c1' \u2198 h\u03b2 \u2198 h\u03b3 \u2022 x = \u03c1 \u2198 h\u03b3 \u2022 x := by\n    apply hT.smul_eq_smul\n    simp only [allPermSderiv_forget', allPermSderiv_forget, WithBot.recBotCoe_coe, id_eq, h\u03c1'\u2082]\n  dsimp only\n  rw [\u2190 h\u03c1'x]\n  have := (Set.ext_iff.mp h\u03c1's (\u03c1' \u2198 h\u03b2 \u2022 singleton h\u03b3 x)).mp \u27e8_, Set.mem_image_of_mem _ hx, rfl\u27e9\n  rw [smul_singleton] at this\n  rwa [(singleton_injective h\u03b3).mem_set_image] at this\n\n", "theoremStatement": "theorem sUnion_singleton_symmetric_aux {\u03b1 \u03b2 \u03b3 : \u039b}\n    (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (s : Set (TSet \u03b3)) (S : Support \u03b1)\n    (hS : \u2200 \u03c1 : AllPerm \u03b1, \u03c1\u1d41 \u2022 S = S \u2192 \u03c1 \u2198 h\u03b2 \u2022 singleton h\u03b3 '' s = singleton h\u03b3 '' s) :\n    letI : Level := \u27e8\u03b1\u27e9\n    letI : LeLevel \u03b1 := \u27e8le_rfl\u27e9\n    \u2200 (\u03c1 : AllPerm \u03b2), \u03c1\u1d41 \u2022 S.strong \u2198 h\u03b2 = S.strong \u2198 h\u03b2 \u2192 \u03c1 \u2198 h\u03b3 \u2022 s = s ", "theoremName": "ConNF.sUnion_singleton_symmetric_aux", "fileCreated": {"commit": "6fdc87c6b30b73931407a372f1430ecf0fef7601", "date": "2024-12-03"}, "theoremCreated": {"commit": "2e25ffbc94af48261308cea0d8c55205cc388ef0", "date": "2024-12-01"}, "file": "ConNF/ConNF/Model/TTT.lean", "module": "ConNF.Model.TTT", "jsonFile": "ConNF.Model.TTT.jsonl", "positionMetadata": {"lineInFile": 238, "tokenPositionInFile": 8575, "theoremPositionInFile": 21}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 32, "numPremises": 74}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  intro \u03c1 h\u03c1\n  apply subset_antisymm\n  \u00b7 exact sUnion_singleton_symmetric_aux' h\u03b3 h\u03b2 s S hS \u03c1 h\u03c1\n  \u00b7 have := sUnion_singleton_symmetric_aux' h\u03b3 h\u03b2 s S hS \u03c1\u207b\u00b9 ?_\n    \u00b7 rwa [allPerm_inv_sderiv', Set.set_smul_subset_iff, inv_inv] at this\n    \u00b7 rw [allPermForget_inv, inv_smul_eq_iff, h\u03c1]", "proofType": "tactic", "proofLengthLines": 6, "proofLengthTokens": 290}}
{"srcContext": "import ConNF.ModelData.Enumeration\nimport ConNF.Levels.StrPerm\n\n/-!\n# Enumerations over paths\n\nIn this file, we provide extra features to `Enumeration`s that take values of the form `\u03b1 \u219d \u22a5 \u00d7 X`.\n\n## Main declarations\n\n* `ConNF.Enumeration.ext_path`: An extensionality principle for such `Enumeration`s.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nnamespace ConNF\n\nvariable [Params.{u}]\n\nnamespace Enumeration\n\n/-- A helper function for making relations with domain and codomain of the form `\u03b1 \u219d \u22a5 \u00d7 X`\nby defining it on each branch. -/\ndef relWithPath {X Y : Type u} {\u03b1 : TypeIndex} (f : \u03b1 \u219d \u22a5 \u2192 Rel X Y) :\n    Rel (\u03b1 \u219d \u22a5 \u00d7 X) (\u03b1 \u219d \u22a5 \u00d7 Y) :=\n  \u03bb x y \u21a6 x.1 = y.1 \u2227 f x.1 x.2 y.2\n\ntheorem relWithPath_coinjective {X Y : Type u} {\u03b1 : TypeIndex} {f : \u03b1 \u219d \u22a5 \u2192 Rel X Y}\n    (hf : \u2200 A, (f A).Coinjective) :\n    (relWithPath f).Coinjective := by\n  constructor\n  rintro \u27e8_, y\u2081\u27e9 \u27e8_, y\u2082\u27e9 \u27e8A, x\u27e9 \u27e8rfl, h\u2081\u27e9 \u27e8rfl, h\u2082\u27e9\n  cases (hf A).coinjective h\u2081 h\u2082\n  rfl\n\ninstance (X : Type u) (\u03b1 \u03b2 : TypeIndex) :\n    Derivative (Enumeration (\u03b1 \u219d \u22a5 \u00d7 X)) (Enumeration (\u03b2 \u219d \u22a5 \u00d7 X)) \u03b1 \u03b2 where\n  deriv E A := E.invImage (\u03bb x \u21a6 (x.1 \u21d7 A, x.2))\n    (\u03bb x y h \u21a6 Prod.ext (Path.deriv_right_injective\n      ((Prod.mk.injEq _ _ _ _).mp h).1) ((Prod.mk.injEq _ _ _ _).mp h).2)\n\ntheorem deriv_rel {X : Type _} {\u03b1 \u03b2 : TypeIndex} (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 X)) (A : \u03b1 \u219d \u03b2)\n    (i : \u03ba) (x : \u03b2 \u219d \u22a5 \u00d7 X) :\n    (E \u21d8 A).rel i x \u2194 E.rel i (x.1 \u21d7 A, x.2) :=\n  Iff.rfl\n\ninstance (X : Type u) (\u03b1 \u03b2 : TypeIndex) :\n    Coderivative (Enumeration (\u03b2 \u219d \u22a5 \u00d7 X)) (Enumeration (\u03b1 \u219d \u22a5 \u00d7 X)) \u03b1 \u03b2 where\n  coderiv E A := E.image (\u03bb x \u21a6 (x.1 \u21d7 A, x.2))\n\ntheorem coderiv_rel {X : Type _} {\u03b1 \u03b2 : TypeIndex} (E : Enumeration (\u03b2 \u219d \u22a5 \u00d7 X)) (A : \u03b1 \u219d \u03b2)\n    (i : \u03ba) (x : \u03b1 \u219d \u22a5 \u00d7 X) :\n    (E \u21d7 A).rel i x \u2194 \u2203 B, x.1 = A \u21d8 B \u2227 E.rel i (B, x.2) := by\n  constructor\n  \u00b7 rintro \u27e8x, h, rfl\u27e9\n    exact \u27e8_, rfl, h\u27e9\n  \u00b7 rintro \u27e8B, h\u2081, h\u2082\u27e9\n    refine \u27e8(B, x.2), h\u2082, ?_\u27e9\n    apply Prod.ext\n    \u00b7 dsimp only\n      exact h\u2081.symm\n    \u00b7 rfl\n\ntheorem scoderiv_rel {X : Type _} {\u03b1 \u03b2 : TypeIndex} (E : Enumeration (\u03b2 \u219d \u22a5 \u00d7 X)) (h : \u03b2 < \u03b1)\n    (i : \u03ba) (x : \u03b1 \u219d \u22a5 \u00d7 X) :\n    (E \u2197 h).rel i x \u2194 \u2203 B, x.1 = B \u2197 h \u2227 E.rel i (B, x.2) :=\n  coderiv_rel E (.single h) i x\n\n", "theoremStatement": "theorem eq_of_scoderiv_mem {X : Type _} {\u03b1 \u03b2 \u03b3 : TypeIndex} (E : Enumeration (\u03b2 \u219d \u22a5 \u00d7 X))\n    (h : \u03b2 < \u03b1) (h' : \u03b3 < \u03b1)\n    (i : \u03ba) (A : \u03b3 \u219d \u22a5) (x : X) (h : (E \u2197 h).rel i \u27e8A \u2197 h', x\u27e9) :\n    \u03b2 = \u03b3 ", "theoremName": "ConNF.Enumeration.eq_of_scoderiv_mem", "fileCreated": {"commit": "39c33b4a743bea62dbcc549548b712ffd38ca65c", "date": "2024-12-05"}, "theoremCreated": {"commit": "ce890707e37ede74a2fcd66134d3f403335c5cc1", "date": "2024-11-30"}, "file": "ConNF/ConNF/ModelData/PathEnumeration.lean", "module": "ConNF.ModelData.PathEnumeration", "jsonFile": "ConNF.ModelData.PathEnumeration.jsonl", "positionMetadata": {"lineInFile": 72, "tokenPositionInFile": 2190, "theoremPositionInFile": 5}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 15, "numPremises": 38}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [scoderiv_rel] at h\n  obtain \u27e8B, h\u2081, h\u2082\u27e9 := h\n  exact Path.scoderiv_index_injective h\u2081.symm", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 102}}
{"srcContext": "import ConNF.ModelData.PathEnumeration\n\n/-!\n# Supports\n\nIn this file, we define the notion of a support.\n\n## Main declarations\n\n* `ConNF.BaseSupport`: The type of supports of atoms.\n* `ConNF.Support`: The type of supports of objects of arbitrary type indices.\n-/\n\nuniverse u\n\nopen Cardinal\n\nnamespace ConNF\n\nvariable [Params.{u}]\n\n/-!\n## Base supports\n-/\n\nstructure BaseSupport where\n  atoms : Enumeration Atom\n  nearLitters : Enumeration NearLitter\n\nnamespace BaseSupport\n\ninstance : SuperA BaseSupport (Enumeration Atom) where\n  superA := atoms\n\ninstance : SuperN BaseSupport (Enumeration NearLitter) where\n  superN := nearLitters\n\n@[simp]\ntheorem mk_atoms {a : Enumeration Atom} {N : Enumeration NearLitter} :\n    (BaseSupport.mk a N)\u1d2c = a :=\n  rfl\n\n@[simp]\ntheorem mk_nearLitters {a : Enumeration Atom} {N : Enumeration NearLitter} :\n    (BaseSupport.mk a N)\u1d3a = N :=\n  rfl\n\ntheorem atoms_congr {S T : BaseSupport} (h : S = T) :\n    S\u1d2c = T\u1d2c :=\n  h \u25b8 rfl\n\ntheorem nearLitters_congr {S T : BaseSupport} (h : S = T) :\n    S\u1d3a = T\u1d3a :=\n  h \u25b8 rfl\n\n@[ext]\ntheorem ext {S T : BaseSupport} (h\u2081 : S\u1d2c = T\u1d2c) (h\u2082 : S\u1d3a = T\u1d3a) : S = T := by\n  obtain \u27e8SA, SN\u27e9 := S\n  obtain \u27e8TA, TN\u27e9 := T\n  cases h\u2081\n  cases h\u2082\n  rfl\n\ninstance : SMul BasePerm BaseSupport where\n  smul \u03c0 S := \u27e8\u03c0 \u2022 S\u1d2c, \u03c0 \u2022 S\u1d3a\u27e9\n\n@[simp]\ntheorem smul_atoms (\u03c0 : BasePerm) (S : BaseSupport) :\n    (\u03c0 \u2022 S)\u1d2c = \u03c0 \u2022 S\u1d2c :=\n  rfl\n\n@[simp]\ntheorem smul_nearLitters (\u03c0 : BasePerm) (S : BaseSupport) :\n    (\u03c0 \u2022 S)\u1d3a = \u03c0 \u2022 S\u1d3a :=\n  rfl\n\n@[simp]\ntheorem smul_atoms_eq_of_smul_eq {\u03c0 : BasePerm} {S : BaseSupport}\n    (h : \u03c0 \u2022 S = S) :\n    \u03c0 \u2022 S\u1d2c = S\u1d2c := by\n  rw [\u2190 smul_atoms, h]\n\n@[simp]\ntheorem smul_nearLitters_eq_of_smul_eq {\u03c0 : BasePerm} {S : BaseSupport}\n    (h : \u03c0 \u2022 S = S) :\n    \u03c0 \u2022 S\u1d3a = S\u1d3a := by\n  rw [\u2190 smul_nearLitters, h]\n\ninstance : MulAction BasePerm BaseSupport where\n  one_smul S := by\n    apply ext\n    \u00b7 rw [smul_atoms, one_smul]\n    \u00b7 rw [smul_nearLitters, one_smul]\n  mul_smul \u03c0\u2081 \u03c0\u2082 S := by\n    apply ext\n    \u00b7 rw [smul_atoms, smul_atoms, smul_atoms, mul_smul]\n    \u00b7 rw [smul_nearLitters, smul_nearLitters, smul_nearLitters, mul_smul]\n\ntheorem smul_eq_smul_iff (\u03c0\u2081 \u03c0\u2082 : BasePerm) (S : BaseSupport) :\n    \u03c0\u2081 \u2022 S = \u03c0\u2082 \u2022 S \u2194 (\u2200 a \u2208 S\u1d2c, \u03c0\u2081 \u2022 a = \u03c0\u2082 \u2022 a) \u2227 (\u2200 N \u2208 S\u1d3a, \u03c0\u2081 \u2022 N = \u03c0\u2082 \u2022 N) := by\n  constructor\n  \u00b7 intro h\n    constructor\n    \u00b7 rintro a \u27e8i, ha\u27e9\n      have := congr_arg (\u00b7\u1d2c.rel i (\u03c0\u2081 \u2022 a)) h\n      simp only [smul_atoms, Enumeration.smul_rel, inv_smul_smul, eq_iff_iff] at this\n      have := S\u1d2c.rel_coinjective.coinjective ha (this.mp ha)\n      rw [eq_inv_smul_iff] at this\n      rw [this]\n    \u00b7 rintro N \u27e8i, hN\u27e9\n      have := congr_arg (\u00b7\u1d3a.rel i (\u03c0\u2081 \u2022 N)) h\n      simp only [smul_nearLitters, Enumeration.smul_rel, inv_smul_smul, eq_iff_iff] at this\n      have := S\u1d3a.rel_coinjective.coinjective hN (this.mp hN)\n      rw [eq_inv_smul_iff] at this\n      rw [this]\n  \u00b7 intro h\n    ext : 2\n    \u00b7 rfl\n    \u00b7 ext i a : 3\n      rw [smul_atoms, smul_atoms, Enumeration.smul_rel, Enumeration.smul_rel]\n      constructor\n      \u00b7 intro ha\n        have := h.1 _ \u27e8i, ha\u27e9\n        rw [smul_inv_smul, \u2190 inv_smul_eq_iff] at this\n        rwa [this]\n      \u00b7 intro ha\n        have := h.1 _ \u27e8i, ha\u27e9\n        rw [smul_inv_smul, smul_eq_iff_eq_inv_smul] at this\n        rwa [\u2190 this]\n    \u00b7 rfl\n    \u00b7 ext i a : 3\n      rw [smul_nearLitters, smul_nearLitters, Enumeration.smul_rel, Enumeration.smul_rel]\n      constructor\n      \u00b7 intro hN\n        have := h.2 _ \u27e8i, hN\u27e9\n        rw [smul_inv_smul, \u2190 inv_smul_eq_iff] at this\n        rwa [this]\n      \u00b7 intro hN\n        have := h.2 _ \u27e8i, hN\u27e9\n        rw [smul_inv_smul, smul_eq_iff_eq_inv_smul] at this\n        rwa [\u2190 this]\n\ntheorem smul_eq_iff (\u03c0 : BasePerm) (S : BaseSupport) :\n    \u03c0 \u2022 S = S \u2194 (\u2200 a \u2208 S\u1d2c, \u03c0 \u2022 a = a) \u2227 (\u2200 N \u2208 S\u1d3a, \u03c0 \u2022 N = N) := by\n  have := smul_eq_smul_iff \u03c0 1 S\n  simp only [one_smul] at this\n  exact this\n\nnoncomputable instance : Add BaseSupport where\n  add S T := \u27e8S\u1d2c + T\u1d2c, S\u1d3a + T\u1d3a\u27e9\n\n@[simp]\ntheorem add_atoms (S T : BaseSupport) :\n    (S + T)\u1d2c = S\u1d2c + T\u1d2c :=\n  rfl\n\n@[simp]\ntheorem add_nearLitters (S T : BaseSupport) :\n    (S + T)\u1d3a = S\u1d3a + T\u1d3a :=\n  rfl\n\nend BaseSupport\n\ndef baseSupportEquiv : BaseSupport \u2243 Enumeration Atom \u00d7 Enumeration NearLitter where\n  toFun S := (S\u1d2c, S\u1d3a)\n  invFun S := \u27e8S.1, S.2\u27e9\n  left_inv _ := rfl\n  right_inv _ := rfl\n\ntheorem card_baseSupport : #BaseSupport = #\u03bc := by\n  rw [Cardinal.eq.mpr \u27e8baseSupportEquiv\u27e9, mk_prod, lift_id, lift_id,\n    card_enumeration_eq card_atom, card_enumeration_eq card_nearLitter, mul_eq_self aleph0_lt_\u03bc.le]\n\n/-!\n## Structural supports\n-/\n\nstructure Support (\u03b1 : TypeIndex) where\n  atoms : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)\n  nearLitters : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)\n\nnamespace Support\n\nvariable {\u03b1 \u03b2 : TypeIndex}\n\ninstance : SuperA (Support \u03b1) (Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) where\n  superA := atoms\n\ninstance : SuperN (Support \u03b1) (Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) where\n  superN := nearLitters\n\n@[simp]\ntheorem mk_atoms (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) (F : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) :\n    (\u27e8E, F\u27e9 : Support \u03b1)\u1d2c = E :=\n  rfl\n\n@[simp]\ntheorem mk_nearLitters (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) (F : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) :\n    (\u27e8E, F\u27e9 : Support \u03b1)\u1d3a = F :=\n  rfl\n\ninstance : Derivative (Support \u03b1) (Support \u03b2) \u03b1 \u03b2 where\n  deriv S A := \u27e8S\u1d2c \u21d8 A, S\u1d3a \u21d8 A\u27e9\n\ninstance : Coderivative (Support \u03b2) (Support \u03b1) \u03b1 \u03b2 where\n  coderiv S A := \u27e8S\u1d2c \u21d7 A, S\u1d3a \u21d7 A\u27e9\n\ninstance : BotDerivative (Support \u03b1) BaseSupport \u03b1 where\n  botDeriv S A := \u27e8S\u1d2c \u21d8. A, S\u1d3a \u21d8. A\u27e9\n  botSderiv S := \u27e8S\u1d2c \u2198., S\u1d3a \u2198.\u27e9\n  botDeriv_single S h := by dsimp only; rw [botDeriv_single, botDeriv_single]\n\n@[simp]\ntheorem deriv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u03b2) :\n    S\u1d2c \u21d8 A = (S \u21d8 A)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem deriv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u03b2) :\n    S\u1d3a \u21d8 A = (S \u21d8 A)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem sderiv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (h : \u03b2 < \u03b1) :\n    S\u1d2c \u2198 h = (S \u2198 h)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem sderiv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (h : \u03b2 < \u03b1) :\n    S\u1d3a \u2198 h = (S \u2198 h)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem coderiv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    S\u1d2c \u21d7 A = (S \u21d7 A)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem coderiv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    S\u1d3a \u21d7 A = (S \u21d7 A)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem scoderiv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (h : \u03b2 < \u03b1) :\n    S\u1d2c \u2197 h = (S \u2197 h)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem scoderiv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (h : \u03b2 < \u03b1) :\n    S\u1d3a \u2197 h = (S \u2197 h)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem derivBot_atoms {\u03b1 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u22a5) :\n    S\u1d2c \u21d8. A = (S \u21d8. A)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem derivBot_nearLitters {\u03b1 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u22a5) :\n    S\u1d3a \u21d8. A = (S \u21d8. A)\u1d3a :=\n  rfl\n\ntheorem ext' {S T : Support \u03b1} (h\u2081 : S\u1d2c = T\u1d2c) (h\u2082 : S\u1d3a = T\u1d3a) : S = T := by\n  obtain \u27e8SA, SN\u27e9 := S\n  obtain \u27e8TA, TN\u27e9 := T\n  cases h\u2081\n  cases h\u2082\n  rfl\n\n@[ext]\ntheorem ext {S T : Support \u03b1} (h : \u2200 A, S \u21d8. A = T \u21d8. A) : S = T := by\n  obtain \u27e8SA, SN\u27e9 := S\n  obtain \u27e8TA, TN\u27e9 := T\n  rw [mk.injEq]\n  constructor\n  \u00b7 apply Enumeration.ext_path\n    intro A\n    exact BaseSupport.atoms_congr (h A)\n  \u00b7 apply Enumeration.ext_path\n    intro A\n    exact BaseSupport.nearLitters_congr (h A)\n\n@[simp]\ntheorem deriv_derivBot {\u03b1 : TypeIndex} (S : Support \u03b1)\n    (A : \u03b1 \u219d \u03b2) (B : \u03b2 \u219d \u22a5) :\n    S \u21d8 A \u21d8. B = S \u21d8. (A \u21d8 B) :=\n  rfl\n\n@[simp]\ntheorem coderiv_deriv_eq {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    S \u21d7 A \u21d8 A = S :=\n  ext' (S\u1d2c.coderiv_deriv_eq A) (S\u1d3a.coderiv_deriv_eq A)\n\ntheorem eq_of_atom_mem_scoderiv_botDeriv {\u03b1 \u03b2 : TypeIndex} {S : Support \u03b2} {A : \u03b1 \u219d \u22a5}\n    {h : \u03b2 < \u03b1} {a : Atom} (ha : a \u2208 (S \u2197 h \u21d8. A)\u1d2c) :\n    \u2203 B : \u03b2 \u219d \u22a5, A = B \u2197 h :=\n  Enumeration.eq_of_mem_scoderiv_botDeriv ha\n\n", "theoremStatement": "theorem eq_of_nearLitter_mem_scoderiv_botDeriv {\u03b1 \u03b2 : TypeIndex} {S : Support \u03b2} {A : \u03b1 \u219d \u22a5}\n    {h : \u03b2 < \u03b1} {N : NearLitter} (hN : N \u2208 (S \u2197 h \u21d8. A)\u1d3a) :\n    \u2203 B : \u03b2 \u219d \u22a5, A = B \u2197 h ", "theoremName": "ConNF.Support.eq_of_nearLitter_mem_scoderiv_botDeriv", "fileCreated": {"commit": "39c33b4a743bea62dbcc549548b712ffd38ca65c", "date": "2024-12-05"}, "theoremCreated": {"commit": "6709914ae7f5cd3e2bb24b413e09aa844554d234", "date": "2024-11-30"}, "file": "ConNF/ConNF/ModelData/Support.lean", "module": "ConNF.ModelData.Support", "jsonFile": "ConNF.ModelData.Support.jsonl", "positionMetadata": {"lineInFile": 299, "tokenPositionInFile": 7631, "theoremPositionInFile": 31}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 6, "repositoryPremises": true, "numRepositoryPremises": 21, "numPremises": 35}, "proofMetadata": {"hasProof": true, "proof": ":=\n  Enumeration.eq_of_mem_scoderiv_botDeriv hN", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 47}}
{"srcContext": "import ConNF.Model.Externalise\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b2 \u03b3 : \u039b} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n\nnamespace Support\n\ntheorem not_mem_scoderiv_botDeriv (S : Support \u03b3) (N : NearLitter) :\n    N \u2209 (S \u2197 h\u03b3 \u21d8. (Path.nil \u2198.))\u1d3a := by\n  rintro \u27e8i, \u27e8A, N'\u27e9, h\u2081, h\u2082\u27e9\n  simp only [Prod.mk.injEq] at h\u2082\n  cases A\n  case sderiv \u03b4 A h\u03b4 _ =>\n    simp only [Path.deriv_sderiv] at h\u2082\n    cases A\n    case nil => cases h\u2082.1\n    case sderiv \u03b6 A h\u03b6 _ =>\n      simp only [Path.deriv_sderiv] at h\u2082\n      cases h\u2082.1\n\nvariable [Level] [LtLevel \u03b2]\n\ntheorem not_mem_strong_botDeriv (S : Support \u03b3) (N : NearLitter) :\n    N \u2209 ((S \u2197 h\u03b3).strong \u21d8. (Path.nil \u2198.))\u1d3a := by\n  rintro h\n  rw [strong, close_nearLitters, preStrong_nearLitters, Enumeration.mem_add_iff] at h\n  obtain h | h := h\n  \u00b7 exact not_mem_scoderiv_botDeriv S N h\n  \u00b7 rw [mem_constrainsNearLitters_nearLitters] at h\n    obtain \u27e8B, N', hN', h\u27e9 := h\n    cases h using Relation.ReflTransGen.head_induction_on\n    case refl => exact not_mem_scoderiv_botDeriv S N hN'\n    case head x hx\u2081 hx\u2082 _ =>\n      obtain \u27e8\u27e8\u03b3, \u03b4, \u03b5, h\u03b4, h\u03b5, h\u03b4\u03b5, A\u27e9, t, B, hB, hN, ht\u27e9 := hx\u2082\n      simp only at hB\n      cases B\n      case nil =>\n        cases hB\n        obtain \u27e8C, N''\u27e9 := x\n        simp only at ht\n        cases ht.1\n        change _ \u2208 t.support\u1d3a at hN\n        rw [t.support_supports.2 rfl] at hN\n        obtain \u27e8i, hN\u27e9 := hN\n        cases hN\n      case sderiv \u03b4 B h\u03b4 _ _ =>\n        cases B\n        case nil => cases hB\n        case sderiv \u03b6 B h\u03b6 _ _ => cases hB\n\ntheorem raise_preStrong' (S : Support \u03b1) (hS : S.Strong) (T : Support \u03b3) (\u03c1 : AllPerm \u03b2)\n    (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2) :\n    (S + (\u03c1\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim).PreStrong := by\n  apply hS.toPreStrong.add\n  constructor\n  intro A N hN P t hA ht\n  obtain \u27e8A, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv hN\n  simp only [scoderiv_botDeriv_eq, add_derivBot, smul_derivBot,\n    BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters, interferenceSupport_nearLitters,\n    Enumeration.mem_add_iff, Enumeration.mem_smul, Enumeration.not_mem_empty, or_false] at hN\n  obtain \u27e8\u03b4, \u03b5, \u03b6, h\u03b5, h\u03b6, h\u03b5\u03b6, B\u27e9 := P\n  dsimp only at *\n  cases A\n  case sderiv \u03b6' A h\u03b6' _ =>\n    rw [\u2190 Path.coderiv_deriv] at hA\n    cases Path.sderiv_index_injective hA\n    apply Path.sderiv_left_inj.mp at hA\n    cases A\n    case nil =>\n      cases hA\n      cases not_mem_strong_botDeriv T _ hN\n    case sderiv \u03b9 A h\u03b9 _ _ =>\n      rw [\u2190 Path.coderiv_deriv] at hA\n      cases Path.sderiv_index_injective hA\n      cases hA\n      haveI : LtLevel \u03b4 := \u27e8A.le.trans_lt LtLevel.elim\u27e9\n      haveI : LtLevel \u03b5 := \u27e8h\u03b5.trans LtLevel.elim\u27e9\n      haveI : LtLevel \u03b6 := \u27e8h\u03b6.trans LtLevel.elim\u27e9\n      have := (T \u2197 h\u03b3).strong_strong.support_le hN \u27e8\u03b4, \u03b5, \u03b6, h\u03b5, h\u03b6, h\u03b5\u03b6, A\u27e9\n          (\u03c1\u207b\u00b9 \u21d8 A \u2198 h\u03b5 \u2022 t) rfl ?_\n      \u00b7 simp only [Tangle.smul_support, allPermSderiv_forget, allPermDeriv_forget,\n          allPermForget_inv, Tree.inv_deriv, Tree.inv_sderiv] at this\n        have := smul_le_smul this (\u03c1\u1d41 \u21d8 A \u2198 h\u03b5)\n        simp only [smul_inv_smul] at this\n        apply le_trans this\n        intro B\n        constructor\n        \u00b7 intro a ha\n          simp only [smul_derivBot, Tree.sderiv_apply, Tree.deriv_apply, Path.deriv_scoderiv,\n            deriv_derivBot, Enumeration.mem_smul] at ha\n          rw [deriv_derivBot, \u2190 Path.deriv_scoderiv, Path.coderiv_deriv', scoderiv_botDeriv_eq,]\n          simp only [Path.deriv_scoderiv, add_derivBot, smul_derivBot,\n            BaseSupport.add_atoms, BaseSupport.smul_atoms, Enumeration.mem_add_iff,\n            Enumeration.mem_smul]\n          exact Or.inl ha\n        \u00b7 intro N hN\n          simp only [smul_derivBot, Tree.sderiv_apply, Tree.deriv_apply, Path.deriv_scoderiv,\n            deriv_derivBot, Enumeration.mem_smul] at hN\n          rw [deriv_derivBot, \u2190 Path.deriv_scoderiv, Path.coderiv_deriv', scoderiv_botDeriv_eq,]\n          simp only [Path.deriv_scoderiv, add_derivBot, smul_derivBot,\n            BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters, Enumeration.mem_add_iff,\n            Enumeration.mem_smul]\n          exact Or.inl hN\n      \u00b7 rw [\u2190 smul_fuzz h\u03b5 h\u03b6 h\u03b5\u03b6, \u2190 ht]\n        simp only [Path.botSderiv_coe_eq, BasePerm.smul_nearLitter_litter, allPermDeriv_forget,\n          allPermForget_inv, Tree.inv_deriv, Tree.inv_sderiv, Tree.inv_sderivBot]\n        rfl\n\n", "theoremStatement": "theorem raise_closed' (S : Support \u03b1) (hS : S.Strong) (T : Support \u03b3) (\u03c1 : AllPerm \u03b2)\n    (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n    (h\u03c1 : \u03c1\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim) :\n    (S + (\u03c1\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim).Closed ", "theoremName": "ConNF.Support.raise_closed'", "fileCreated": {"commit": "abf71bc79c407ceb462cc2edd2d994cda9cdef05", "date": "2024-04-04"}, "theoremCreated": {"commit": "6709914ae7f5cd3e2bb24b413e09aa844554d234", "date": "2024-11-30"}, "file": "ConNF/ConNF/Model/RaiseStrong.lean", "module": "ConNF.Model.RaiseStrong", "jsonFile": "ConNF.Model.RaiseStrong.jsonl", "positionMetadata": {"lineInFile": 126, "tokenPositionInFile": 4490, "theoremPositionInFile": 3}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 70, "numPremises": 123}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  constructor\n  intro A\n  constructor\n  intro N\u2081 N\u2082 hN\u2081 hN\u2082 a ha\n  simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff,\n    BaseSupport.add_atoms] at hN\u2081 hN\u2082 \u22a2\n  obtain hN\u2081 | hN\u2081 := hN\u2081\n  \u00b7 obtain hN\u2082 | hN\u2082 := hN\u2082\n    \u00b7 exact Or.inl ((hS.closed A).interference_subset hN\u2081 hN\u2082 a ha)\n    \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv hN\u2082\n      simp only [smul_add, scoderiv_botDeriv_eq, add_derivBot, smul_derivBot,\n        BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters, Enumeration.mem_add_iff,\n        Enumeration.mem_smul, BaseSupport.add_atoms, BaseSupport.smul_atoms] at hN\u2081 hN\u2082 \u22a2\n      refine Or.inr (Or.inr ?_)\n      rw [mem_interferenceSupport_atoms]\n      refine \u27e8(\u03c1\u1d41 B)\u207b\u00b9 \u2022 N\u2081, ?_, (\u03c1\u1d41 B)\u207b\u00b9 \u2022 N\u2082, ?_, ?_\u27e9\n      \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n        rw [\u2190 Enumeration.mem_smul, \u2190 BaseSupport.smul_nearLitters, \u2190 smul_derivBot, h\u03c1]\n        exact Or.inl hN\u2081\n      \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n        simp only [interferenceSupport_nearLitters, Enumeration.not_mem_empty, or_false] at hN\u2082\n        exact Or.inr hN\u2082\n      \u00b7 rw [\u2190 BasePerm.smul_interference]\n        exact Set.smul_mem_smul_set ha\n  \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv hN\u2081\n    simp only [smul_add, scoderiv_botDeriv_eq, add_derivBot, smul_derivBot,\n      BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters, Enumeration.mem_add_iff,\n      Enumeration.mem_smul, BaseSupport.add_atoms, BaseSupport.smul_atoms] at hN\u2081 hN\u2082 \u22a2\n    refine Or.inr (Or.inr ?_)\n    rw [mem_interferenceSupport_atoms]\n    refine \u27e8(\u03c1\u1d41 B)\u207b\u00b9 \u2022 N\u2081, ?_, (\u03c1\u1d41 B)\u207b\u00b9 \u2022 N\u2082, ?_, ?_\u27e9\n    \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n      simp only [interferenceSupport_nearLitters, Enumeration.not_mem_empty, or_false] at hN\u2081\n      exact Or.inr hN\u2081\n    \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n      simp only [interferenceSupport_nearLitters, Enumeration.not_mem_empty, or_false] at hN\u2082\n      obtain hN\u2082 | hN\u2082 := hN\u2082\n      \u00b7 rw [\u2190 Enumeration.mem_smul, \u2190 BaseSupport.smul_nearLitters, \u2190 smul_derivBot, h\u03c1]\n        exact Or.inl hN\u2082\n      \u00b7 exact Or.inr hN\u2082\n    \u00b7 rw [\u2190 BasePerm.smul_interference]\n      exact Set.smul_mem_smul_set ha", "proofType": "tactic", "proofLengthLines": 42, "proofLengthTokens": 2330}}
{"srcContext": "import ConNF.Model.Result\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal ConNF.TSet\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\ndef union (x y : TSet \u03b1) : TSet \u03b1 :=\n  (x\u1d9c' \u2293' y\u1d9c')\u1d9c'\n\nnotation:68 x:68 \" \u2294[\" h \"] \" y:68 => _root_.ConNF.union h x y\nnotation:68 x:68 \" \u2294' \" y:68 => x \u2294[by assumption] y\n\n@[simp]\ntheorem mem_union_iff (x y : TSet \u03b1) :\n    \u2200 z : TSet \u03b2, z \u2208' x \u2294' y \u2194 z \u2208' x \u2228 z \u2208' y := by\n  rw [union]\n  intro z\n  rw [mem_compl_iff, mem_inter_iff, mem_compl_iff, mem_compl_iff, or_iff_not_and_not]\n\ndef higherIndex (\u03b1 : \u039b) : \u039b :=\n  (exists_gt \u03b1).choose\n\ntheorem lt_higherIndex {\u03b1 : \u039b} :\n    (\u03b1 : TypeIndex) < higherIndex \u03b1 :=\n  WithBot.coe_lt_coe.mpr (exists_gt \u03b1).choose_spec\n\ntheorem tSet_nonempty (h : \u2203 \u03b2 : \u039b, (\u03b2 : TypeIndex) < \u03b1) : Nonempty (TSet \u03b1) := by\n  obtain \u27e8\u03b1', h\u03b1\u27e9 := h\n  constructor\n  apply typeLower lt_higherIndex lt_higherIndex lt_higherIndex h\u03b1\n  apply cardinalOne lt_higherIndex lt_higherIndex\n\ndef empty : TSet \u03b1 :=\n  (tSet_nonempty \u27e8\u03b2, h\u03b2\u27e9).some \u2293' (tSet_nonempty \u27e8\u03b2, h\u03b2\u27e9).some\u1d9c'\n\n@[simp]\ntheorem mem_empty_iff :\n    \u2200 x : TSet \u03b2, \u00acx \u2208' empty h\u03b2 := by\n  intro x\n  rw [empty, mem_inter_iff, mem_compl_iff]\n  exact and_not_self\n\ndef univ : TSet \u03b1 :=\n  (empty h\u03b2)\u1d9c'\n\n", "theoremStatement": "@[simp]\ntheorem mem_univ_iff :\n    \u2200 x : TSet \u03b2, x \u2208' univ h\u03b2 ", "theoremName": "ConNF.mem_univ_iff", "fileCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "theoremCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "file": "ConNF/ConNF/External/Basic.lean", "module": "ConNF.External.Basic", "jsonFile": "ConNF.External.Basic.jsonl", "positionMetadata": {"lineInFile": 62, "tokenPositionInFile": 1449, "theoremPositionInFile": 10}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 14, "numPremises": 34}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  intro x\n  simp only [univ, mem_compl_iff, mem_empty_iff, not_false_eq_true]", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 83}}
{"srcContext": "import ConNF.Model.TTT\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\nnamespace TSet\n\n", "theoremStatement": "theorem exists_inter (x y : TSet \u03b1) :\n    \u2203 w : TSet \u03b1, \u2200 z : TSet \u03b2, z \u2208[h\u03b2] w \u2194 z \u2208[h\u03b2] x \u2227 z \u2208[h\u03b2] y ", "theoremName": "ConNF.TSet.exists_inter", "fileCreated": {"commit": "f804f5c71cfaa98223fc227dd822801e8bf77004", "date": "2024-03-30"}, "theoremCreated": {"commit": "f7c233c7f7fd9d8b74595bbfa2bbbd49d538ef59", "date": "2024-12-02"}, "file": "ConNF/ConNF/Model/Hailperin.lean", "module": "ConNF.Model.Hailperin", "jsonFile": "ConNF.Model.Hailperin.jsonl", "positionMetadata": {"lineInFile": 25, "tokenPositionInFile": 381, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 27, "numPremises": 75}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  refine exists_of_symmetric {z | z \u2208[h\u03b2] x \u2227 z \u2208[h\u03b2] y} h\u03b2 ?_\n  obtain \u27e8S, hS\u27e9 := symmetric x h\u03b2\n  obtain \u27e8T, hT\u27e9 := symmetric y h\u03b2\n  use S + T\n  intro \u03c1 h\u03c1\n  specialize hS \u03c1 (smul_eq_of_le Support.le_add_right h\u03c1)\n  specialize hT \u03c1 (smul_eq_of_le Support.le_add_left h\u03c1)\n  simp [Set.ext_iff, Set.mem_smul_set_iff_inv_smul_mem] at hS hT \u22a2\n  aesop", "proofType": "tactic", "proofLengthLines": 9, "proofLengthTokens": 353}}
{"srcContext": "import ConNF.External.Basic\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal ConNF.TSet\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\n/-- A set in our model that is a well-order. Internal well-orders are exactly external well-orders,\nso we externalise the definition for convenience. -/\ndef InternalWellOrder (r : TSet \u03b1) : Prop :=\n  IsWellOrder (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).field\n    (InvImage (ExternalRel h\u03b2 h\u03b3 h\u03b4 r) Subtype.val)\n\ndef InternallyWellOrdered (x : TSet \u03b3) : Prop :=\n  {y : TSet \u03b4 | y \u2208' x}.Subsingleton \u2228 (\u2203 r, InternalWellOrder h\u03b2 h\u03b3 h\u03b4 r \u2227 x = field h\u03b2 h\u03b3 h\u03b4 r)\n\n@[simp]\ntheorem externalRel_smul (r : TSet \u03b1) (\u03c1 : AllPerm \u03b1) :\n    ExternalRel h\u03b2 h\u03b3 h\u03b4 (\u03c1 \u2022 r) =\n      InvImage (ExternalRel h\u03b2 h\u03b3 h\u03b4 r) ((\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4)\u207b\u00b9 \u2022 \u00b7) := by\n  ext a b\n  simp only [ExternalRel, mem_smul_iff', allPerm_inv_sderiv', smul_op, InvImage]\n\nomit [Params] in\n/-- Well-orders are rigid. -/\ntheorem apply_eq_of_isWellOrder {X : Type _} {r : Rel X X} {f : X \u2192 X}\n    (hr : IsWellOrder X r) (hf : Function.Bijective f) (hf' : \u2200 x y, r x y \u2194 r (f x) (f y)) :\n    \u2200 x, f x = x := by\n  let emb : r \u227ci r := \u27e8\u27e8\u27e8f, hf.injective\u27e9, \u03bb {a b} \u21a6 (hf' a b).symm\u27e9, ?_\u27e9\n  \u00b7 have : emb = InitialSeg.refl r := Subsingleton.elim _ _\n    intro x\n    exact congr_arg (\u03bb f \u21a6 f x) this\n  \u00b7 intro a b h\n    exact hf.surjective _\n\nomit [Params] in\ntheorem apply_eq_of_isWellOrder' {X : Type _} {r : Rel X X} {f : X \u2192 X}\n    (hr : IsWellOrder r.field (InvImage r Subtype.val)) (hf : Function.Bijective f)\n    (hf' : \u2200 x y, r x y \u2194 r (f x) (f y)) :\n    \u2200 x \u2208 r.field, f x = x := by\n  have : \u2200 x \u2208 r.field, f x \u2208 r.field := by\n    rintro x (\u27e8y, h\u27e9 | \u27e8y, h\u27e9)\n    \u00b7 exact Or.inl \u27e8f y, (hf' x y).mp h\u27e9\n    \u00b7 exact Or.inr \u27e8f y, (hf' y x).mp h\u27e9\n  have := apply_eq_of_isWellOrder (f := \u03bb x \u21a6 \u27e8f x.val, this x.val x.prop\u27e9) hr \u27e8?_, ?_\u27e9 ?_\n  \u00b7 intro x hx\n    exact congr_arg Subtype.val (this \u27e8x, hx\u27e9)\n  \u00b7 intro x y h\n    rw [Subtype.mk.injEq] at h\n    exact Subtype.val_injective (hf.injective h)\n  \u00b7 intro x\n    obtain \u27e8y, hy\u27e9 := hf.surjective x.val\n    refine \u27e8\u27e8y, ?_\u27e9, ?_\u27e9\n    \u00b7 obtain (\u27e8z, h\u27e9 | \u27e8z, h\u27e9) := x.prop <;>\n          rw [\u2190 hy] at h <;>\n          obtain \u27e8z, rfl\u27e9 := hf.surjective z\n      \u00b7 exact Or.inl \u27e8z, (hf' y z).mpr h\u27e9\n      \u00b7 exact Or.inr \u27e8z, (hf' z y).mpr h\u27e9\n    \u00b7 simp only [hy]\n  \u00b7 intros\n    apply hf'\n\ntheorem exists_common_support_of_internallyWellOrdered' {x : TSet \u03b4}\n    (h : InternallyWellOrdered h\u03b3 h\u03b4 h\u03b5 x) :\n    \u2203 S : Support \u03b2, \u2200 y, y \u2208' x \u2192 S.Supports { { {y}' }' }[h\u03b3] := by\n  obtain (h | \u27e8r, h, rfl\u27e9) := h\n  \u00b7 obtain (h | \u27e8y, hy\u27e9) := h.eq_empty_or_singleton\n    \u00b7 use \u27e8Enumeration.empty, Enumeration.empty\u27e9\n      intro y hy\n      rw [Set.eq_empty_iff_forall_not_mem] at h\n      cases h y hy\n    \u00b7 obtain \u27e8S, hS\u27e9 := TSet.exists_support y\n      use S \u2197 h\u03b5 \u2197 h\u03b4 \u2197 h\u03b3\n      intro z hz\n      rw [Set.eq_singleton_iff_unique_mem] at hy\n      cases hy.2 z hz\n      refine \u27e8?_, \u03bb h \u21a6 by cases h\u27e9\n      intro \u03c1 h\u03c1\n      simp only [Support.smul_scoderiv, \u2190 allPermSderiv_forget', Support.scoderiv_inj] at h\u03c1\n      simp only [smul_singleton, singleton_inj]\n      exact hS _ h\u03c1\n  obtain \u27e8S, hS\u27e9 := TSet.exists_support r\n  use S\n  intro a ha\n  refine \u27e8?_, \u03bb h \u21a6 by cases h\u27e9\n  intro \u03c1 h\u03c1\n  have := hS \u03c1 h\u03c1\n  simp only [smul_singleton, singleton_inj]\n  apply apply_eq_of_isWellOrder' (r := ExternalRel h\u03b3 h\u03b4 h\u03b5 r)\n  \u00b7 exact h\n  \u00b7 exact MulAction.bijective (\u03c1 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5)\n  \u00b7 intro x y\n    conv_rhs => rw [\u2190 this]\n    simp only [externalRel_smul, InvImage, inv_smul_smul]\n  \u00b7 rwa [mem_field_iff] at ha\n\ninclude h\u03b3 in\ntheorem Support.Supports.ofSingleton {S : Support \u03b1} {x : TSet \u03b2}\n    (h : S.Supports {x}') :\n    letI : Level := \u27e8\u03b1\u27e9\n    letI : LeLevel \u03b1 := \u27e8le_rfl\u27e9\n    (S.strong \u2198 h\u03b2).Supports x := by\n  refine \u27e8?_, \u03bb h \u21a6 by cases h\u27e9\n  intro \u03c1 h\u03c1\n  open scoped Pointwise in\n  have := sUnion_singleton_symmetric_aux h\u03b3 h\u03b2 {y | y \u2208' x} S ?_ \u03c1 h\u03c1\n  \u00b7 apply ConNF.ext h\u03b3\n    intro z\n    simp only [Set.ext_iff, Set.mem_setOf_eq, Set.mem_smul_set_iff_inv_smul_mem] at this\n    rw [mem_smul_iff', allPerm_inv_sderiv', this]\n  \u00b7 intro \u03c1 h\u03c1\n    ext z\n    simp only [Set.mem_smul_set_iff_inv_smul_mem, Set.mem_image, Set.mem_setOf_eq]\n    have := h.supports \u03c1 h\u03c1\n    simp only [smul_singleton, singleton_inj] at this\n    constructor\n    \u00b7 rintro \u27e8y, h\u2081, h\u2082\u27e9\n      rw [\u2190 smul_eq_iff_eq_inv_smul, smul_singleton] at h\u2082\n      refine \u27e8_, ?_, h\u2082\u27e9\n      rw [\u2190 this]\n      simp only [mem_smul_iff', allPerm_inv_sderiv', inv_smul_smul]\n      exact h\u2081\n    \u00b7 rintro \u27e8y, h, rfl\u27e9\n      refine \u27e8(\u03c1 \u2198 h\u03b2 \u2198 h\u03b3)\u207b\u00b9 \u2022 y, ?_, ?_\u27e9\n      \u00b7 rwa [\u2190 allPerm_inv_sderiv', \u2190 mem_smul_iff', this]\n      \u00b7 simp only [smul_singleton, allPerm_inv_sderiv']\n\ninclude h\u03b3 in\ntheorem supports_of_supports_singletons {S : Support \u03b1} {s : Set (TSet \u03b2)}\n    (h : \u2200 x \u2208 s, S.Supports {x}') :\n    \u2203 S : Support \u03b2, \u2200 x \u2208 s, S.Supports x :=\n  \u27e8_, \u03bb x hx \u21a6 (h x hx).ofSingleton h\u03b2 h\u03b3\u27e9\n\ntheorem exists_common_support_of_internallyWellOrdered {x : TSet \u03b4}\n    (h : InternallyWellOrdered h\u03b3 h\u03b4 h\u03b5 x) :\n    \u2203 S : Support \u03b4, \u2200 y, y \u2208' x \u2192 S.Supports {y}' := by\n  obtain \u27e8S, hS\u27e9 := exists_common_support_of_internallyWellOrdered' h\u03b3 h\u03b4 h\u03b5 h\n  have := supports_of_supports_singletons (S := S)\n      (s := singleton h\u03b4 '' (singleton h\u03b5 '' {y | y \u2208' x})) h\u03b3 h\u03b4 ?_\n  swap\n  \u00b7 simp only [Set.mem_image, Set.mem_setOf_eq, exists_exists_and_eq_and, forall_exists_index,\n      and_imp, forall_apply_eq_imp_iff\u2082]\n    exact hS\n  obtain \u27e8T, hT\u27e9 := this\n  have := supports_of_supports_singletons (S := T)\n      (s := singleton h\u03b5 '' {y | y \u2208' x}) h\u03b4 h\u03b5 ?_\n  swap\n  \u00b7 simp only [Set.mem_image, Set.mem_setOf_eq, forall_exists_index, and_imp,\n      forall_apply_eq_imp_iff\u2082] at hT \u22a2\n    exact hT\n  simp only [Set.mem_image, Set.mem_setOf_eq, forall_exists_index, and_imp,\n    forall_apply_eq_imp_iff\u2082] at this\n  exact this\n\ntheorem internallyWellOrdered_of_common_support_of_nontrivial {x : TSet \u03b3}\n    (hx : {y : TSet \u03b4 | y \u2208' x}.Nontrivial)\n    (S : Support \u03b4) (hS : \u2200 y : TSet \u03b4, y \u2208' x \u2192 S.Supports y) :\n    InternallyWellOrdered h\u03b2 h\u03b3 h\u03b4 x := by\n  have := exists_of_symmetric\n      {p : TSet \u03b2 | \u2203 a b : TSet \u03b4, p = \u27e8a, b\u27e9' \u2227 a \u2208' x \u2227 b \u2208' x \u2227 WellOrderingRel a b} h\u03b2 ?_\n  swap\n  \u00b7 use S \u2197 h\u03b4 \u2197 h\u03b3 \u2197 h\u03b2\n    intro \u03c1 h\u03c1\n    ext z\n    simp only [Support.smul_scoderiv, \u2190 allPermSderiv_forget', Support.scoderiv_inj] at h\u03c1\n    simp only [Set.mem_smul_set_iff_inv_smul_mem, Set.mem_setOf_eq]\n    constructor\n    \u00b7 rintro \u27e8a, b, h\u2081, h\u2082, h\u2083, h\u2084\u27e9\n      refine \u27e8a, b, ?_, h\u2082, h\u2083, h\u2084\u27e9\n      rw [inv_smul_eq_iff] at h\u2081\n      rw [h\u2081, smul_op, op_inj]\n      exact \u27e8(hS a h\u2082).supports _ h\u03c1, (hS b h\u2083).supports _ h\u03c1\u27e9\n    \u00b7 rintro \u27e8a, b, h\u2081, h\u2082, h\u2083, h\u2084\u27e9\n      refine \u27e8a, b, ?_, h\u2082, h\u2083, h\u2084\u27e9\n      rw [h\u2081, smul_op, op_inj]\n      simp only [allPerm_inv_sderiv', inv_smul_eq_iff]\n      rw [(hS a h\u2082).supports _ h\u03c1, (hS b h\u2083).supports _ h\u03c1]\n      exact \u27e8rfl, rfl\u27e9\n  obtain \u27e8r, hr\u27e9 := this\n  right\n  use r\n  have hr' : \u2200 a b, ExternalRel h\u03b2 h\u03b3 h\u03b4 r a b \u2194 a \u2208' x \u2227 b \u2208' x \u2227 WellOrderingRel a b := by\n    intro a b\n    rw [ExternalRel, hr]\n    simp only [Set.mem_setOf_eq, op_inj]\n    constructor\n    \u00b7 rintro \u27e8a, b, \u27e8rfl, rfl\u27e9, h\u27e9\n      exact h\n    \u00b7 intro h\n      exact \u27e8a, b, \u27e8rfl, rfl\u27e9, h\u27e9\n  have hrx : \u2200 a, a \u2208 (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).field \u2194 a \u2208' x := by\n    intro a\n    constructor\n    \u00b7 rintro (\u27e8b, h\u27e9 | \u27e8b, h\u27e9)\n      \u00b7 rw [hr'] at h\n        exact h.1\n      \u00b7 rw [hr'] at h\n        exact h.2.1\n    \u00b7 intro h\n      obtain \u27e8b, h\u2081, h\u2082\u27e9 := hx.exists_ne a\n      obtain (h\u2083 | h\u2083 | h\u2083) := WellOrderingRel.isWellOrder.trichotomous a b\n      \u00b7 refine Or.inl \u27e8b, ?_\u27e9\n        rw [hr']\n        exact \u27e8h, h\u2081, h\u2083\u27e9\n      \u00b7 cases h\u2082 h\u2083.symm\n      \u00b7 refine Or.inr \u27e8b, ?_\u27e9\n        rw [hr']\n        exact \u27e8h\u2081, h, h\u2083\u27e9\n  refine \u27e8?_, ?_\u27e9\n  swap\n  \u00b7 apply ext h\u03b4\n    intro z\n    rw [mem_field_iff, hrx]\n  refine @IsWellOrder.mk _ _ ?_ ?_ ?_\n  \u00b7 constructor\n    intro a b\n    obtain (h | h | h) := WellOrderingRel.isWellOrder.trichotomous a.val b.val\n    \u00b7 apply Or.inl\n      rw [InvImage, hr']\n      exact \u27e8(hrx a).mp a.prop, (hrx b).mp b.prop, h\u27e9\n    \u00b7 exact Or.inr (Or.inl (Subtype.val_injective h))\n    \u00b7 apply Or.inr \u2218 Or.inr\n      rw [InvImage, hr']\n      exact \u27e8(hrx b).mp b.prop, (hrx a).mp a.prop, h\u27e9\n  \u00b7 constructor\n    intro a b c h\u2081 h\u2082\n    rw [InvImage, hr'] at h\u2081 h\u2082 \u22a2\n    exact \u27e8h\u2081.1, h\u2082.2.1, WellOrderingRel.isWellOrder.trans _ _ _ h\u2081.2.2 h\u2082.2.2\u27e9\n  \u00b7 constructor\n    apply InvImage.wf\n    refine Subrelation.wf ?_ WellOrderingRel.isWellOrder.wf\n    intro a b h\n    rw [hr'] at h\n    exact h.2.2\n\ntheorem internallyWellOrdered_of_common_support {x : TSet \u03b3}\n    (S : Support \u03b4) (hS : \u2200 y : TSet \u03b4, y \u2208' x \u2192 S.Supports y) :\n    InternallyWellOrdered h\u03b2 h\u03b3 h\u03b4 x := by\n  obtain (hx | hx) := Set.subsingleton_or_nontrivial {y : TSet \u03b4 | y \u2208' x}\n  \u00b7 exact Or.inl hx\n  \u00b7 exact internallyWellOrdered_of_common_support_of_nontrivial h\u03b2 h\u03b3 h\u03b4 hx S hS\n\n", "theoremStatement": "theorem powerset_internallyWellOrdered {x : TSet \u03b4} (h : InternallyWellOrdered h\u03b3 h\u03b4 h\u03b5 x) :\n    InternallyWellOrdered h\u03b2 h\u03b3 h\u03b4 (powerset h\u03b4 h\u03b5 x) ", "theoremName": "ConNF.powerset_internallyWellOrdered", "fileCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "theoremCreated": {"commit": "1c08486feb882444888c228ce1501e92bb85e0e2", "date": "2025-01-07"}, "file": "ConNF/ConNF/External/WellOrder.lean", "module": "ConNF.External.WellOrder", "jsonFile": "ConNF.External.WellOrder.jsonl", "positionMetadata": {"lineInFile": 258, "tokenPositionInFile": 8986, "theoremPositionInFile": 11}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 43, "numPremises": 89}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  obtain \u27e8S, hS\u27e9 := exists_common_support_of_internallyWellOrdered h\u03b3 h\u03b4 h\u03b5 h\n  apply internallyWellOrdered_of_common_support h\u03b2 h\u03b3 h\u03b4 S\n  intro y hy\n  simp only [mem_powerset_iff] at hy\n  refine \u27e8?_, \u03bb h \u21a6 by cases h\u27e9\n  intro \u03c1 h\u03c1\n  apply ext h\u03b5\n  intro z\n  constructor\n  \u00b7 intro hz\n    simp only [mem_smul_iff', allPerm_inv_sderiv'] at hz\n    have := (hS _ (hy _ hz)).supports \u03c1 h\u03c1\n    simp only [smul_singleton, smul_inv_smul, singleton_inj] at this\n    rwa [this]\n  \u00b7 intro hz\n    have := (hS z (hy _ hz)).supports \u03c1 h\u03c1\n    simp only [smul_singleton, singleton_inj] at this\n    rw [\u2190 this]\n    simp only [mem_smul_iff', allPerm_inv_sderiv', inv_smul_smul]\n    exact hz", "proofType": "tactic", "proofLengthLines": 20, "proofLengthTokens": 678}}
{"srcContext": "import ConNF.Model.Result\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal ConNF.TSet\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\ndef union (x y : TSet \u03b1) : TSet \u03b1 :=\n  (x\u1d9c' \u2293' y\u1d9c')\u1d9c'\n\nnotation:68 x:68 \" \u2294[\" h \"] \" y:68 => _root_.ConNF.union h x y\nnotation:68 x:68 \" \u2294' \" y:68 => x \u2294[by assumption] y\n\n@[simp]\ntheorem mem_union_iff (x y : TSet \u03b1) :\n    \u2200 z : TSet \u03b2, z \u2208' x \u2294' y \u2194 z \u2208' x \u2228 z \u2208' y := by\n  rw [union]\n  intro z\n  rw [mem_compl_iff, mem_inter_iff, mem_compl_iff, mem_compl_iff, or_iff_not_and_not]\n\ndef higherIndex (\u03b1 : \u039b) : \u039b :=\n  (exists_gt \u03b1).choose\n\ntheorem lt_higherIndex {\u03b1 : \u039b} :\n    (\u03b1 : TypeIndex) < higherIndex \u03b1 :=\n  WithBot.coe_lt_coe.mpr (exists_gt \u03b1).choose_spec\n\ntheorem tSet_nonempty (h : \u2203 \u03b2 : \u039b, (\u03b2 : TypeIndex) < \u03b1) : Nonempty (TSet \u03b1) := by\n  obtain \u27e8\u03b1', h\u03b1\u27e9 := h\n  constructor\n  apply typeLower lt_higherIndex lt_higherIndex lt_higherIndex h\u03b1\n  apply cardinalOne lt_higherIndex lt_higherIndex\n\ndef empty : TSet \u03b1 :=\n  (tSet_nonempty \u27e8\u03b2, h\u03b2\u27e9).some \u2293' (tSet_nonempty \u27e8\u03b2, h\u03b2\u27e9).some\u1d9c'\n\n@[simp]\ntheorem mem_empty_iff :\n    \u2200 x : TSet \u03b2, \u00acx \u2208' empty h\u03b2 := by\n  intro x\n  rw [empty, mem_inter_iff, mem_compl_iff]\n  exact and_not_self\n\ndef univ : TSet \u03b1 :=\n  (empty h\u03b2)\u1d9c'\n\n@[simp]\ntheorem mem_univ_iff :\n    \u2200 x : TSet \u03b2, x \u2208' univ h\u03b2 := by\n  intro x\n  simp only [univ, mem_compl_iff, mem_empty_iff, not_false_eq_true]\n\n/-- The set of all ordered pairs. -/\ndef orderedPairs : TSet \u03b1 :=\n  vCross h\u03b2 h\u03b3 h\u03b4 (univ h\u03b4)\n\n@[simp]\ntheorem mem_orderedPairs_iff (x : TSet \u03b2) :\n    x \u2208' orderedPairs h\u03b2 h\u03b3 h\u03b4 \u2194 \u2203 a b, x = \u27e8a, b\u27e9' := by\n  simp only [orderedPairs, vCross_spec, mem_univ_iff, and_true]\n\ndef converse (x : TSet \u03b1) : TSet \u03b1 :=\n  converse' h\u03b2 h\u03b3 h\u03b4 x \u2293' orderedPairs h\u03b2 h\u03b3 h\u03b4\n\n@[simp]\ntheorem op_mem_converse_iff (x : TSet \u03b1) :\n    \u2200 a b, \u27e8a, b\u27e9' \u2208' converse h\u03b2 h\u03b3 h\u03b4 x \u2194 \u27e8b, a\u27e9' \u2208' x := by\n  intro a b\n  simp only [converse, mem_inter_iff, converse'_spec, mem_orderedPairs_iff, op_inj, exists_and_left,\n    exists_eq', and_true]\n\ndef cross (x y : TSet \u03b3) : TSet \u03b1 :=\n  converse h\u03b2 h\u03b3 h\u03b4 (vCross h\u03b2 h\u03b3 h\u03b4 x) \u2293' vCross h\u03b2 h\u03b3 h\u03b4 y\n\n", "theoremStatement": "@[simp]\ntheorem mem_cross_iff (x y : TSet \u03b3) :\n    \u2200 a, a \u2208' cross h\u03b2 h\u03b3 h\u03b4 x y \u2194 \u2203 b c, a = \u27e8b, c\u27e9' \u2227 b \u2208' x \u2227 c \u2208' y ", "theoremName": "ConNF.mem_cross_iff", "fileCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "theoremCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "file": "ConNF/ConNF/External/Basic.lean", "module": "ConNF.External.Basic", "jsonFile": "ConNF.External.Basic.jsonl", "positionMetadata": {"lineInFile": 90, "tokenPositionInFile": 2306, "theoremPositionInFile": 16}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 18, "numPremises": 49}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  intro a\n  rw [cross, mem_inter_iff, vCross_spec]\n  constructor\n  \u00b7 rintro \u27e8h\u2081, b, c, rfl, h\u2082\u27e9\n    simp only [op_mem_converse_iff, vCross_spec, op_inj] at h\u2081\n    obtain \u27e8b', c', \u27e8rfl, rfl\u27e9, h\u2081\u27e9 := h\u2081\n    exact \u27e8b, c, rfl, h\u2081, h\u2082\u27e9\n  \u00b7 rintro \u27e8b, c, rfl, h\u2081, h\u2082\u27e9\n    simp only [op_mem_converse_iff, vCross_spec, op_inj]\n    exact \u27e8\u27e8c, b, \u27e8rfl, rfl\u27e9, h\u2081\u27e9, \u27e8b, c, \u27e8rfl, rfl\u27e9, h\u2082\u27e9\u27e9", "proofType": "tactic", "proofLengthLines": 10, "proofLengthTokens": 383}}
{"srcContext": "import ConNF.Model.RaiseStrong\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nopen scoped Pointwise\n\nnamespace ConNF\n\nvariable [Params.{u}]\n\n/-- A redefinition of the derivative of allowable permutations that is invariant of level,\nbut still has nice definitional properties. -/\n@[default_instance 200]\ninstance {\u03b2 \u03b3 : TypeIndex} : Derivative (AllPerm \u03b2) (AllPerm \u03b3) \u03b2 \u03b3 where\n  deriv \u03c1 A :=\n    A.recSderiv\n    (motive := \u03bb (\u03b4 : TypeIndex) (A : \u03b2 \u219d \u03b4) \u21a6\n      letI : Level := \u27e8\u03b4.recBotCoe (Nonempty.some inferInstance) id\u27e9\n      letI : LeLevel \u03b4 := \u27e8\u03b4.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n        (show \u03b4.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n      AllPerm \u03b4)\n    \u03c1 (\u03bb \u03b4 \u03b5 A h \u03c1 \u21a6\n      letI : Level := \u27e8\u03b4.recBotCoe (Nonempty.some inferInstance) id\u27e9\n      letI : LeLevel \u03b4 := \u27e8\u03b4.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n        (show \u03b4.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n      letI : LeLevel \u03b5 := \u27e8h.le.trans LeLevel.elim\u27e9\n      PreCoherentData.allPermSderiv h \u03c1)\n\n@[simp]\ntheorem allPerm_deriv_nil' {\u03b2 : TypeIndex}\n    (\u03c1 : AllPerm \u03b2) :\n    \u03c1 \u21d8 (.nil : \u03b2 \u219d \u03b2) = \u03c1 :=\n  rfl\n\n@[simp]\ntheorem allPerm_deriv_sderiv' {\u03b2 \u03b3 \u03b4 : TypeIndex}\n    (\u03c1 : AllPerm \u03b2) (A : \u03b2 \u219d \u03b3) (h : \u03b4 < \u03b3) :\n    \u03c1 \u21d8 (A \u2198 h) = \u03c1 \u21d8 A \u2198 h :=\n  rfl\n\n@[simp]\ntheorem allPermSderiv_forget' {\u03b2 \u03b3 : TypeIndex} (h : \u03b3 < \u03b2) (\u03c1 : AllPerm \u03b2) :\n    (\u03c1 \u2198 h)\u1d41 = \u03c1\u1d41 \u2198 h :=\n  letI : Level := \u27e8\u03b2.recBotCoe (Nonempty.some inferInstance) id\u27e9\n  letI : LeLevel \u03b2 := \u27e8\u03b2.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n    (show \u03b2.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n  letI : LeLevel \u03b3 := \u27e8h.le.trans LeLevel.elim\u27e9\n  allPermSderiv_forget h \u03c1\n\n@[simp]\ntheorem allPerm_inv_sderiv' {\u03b2 \u03b3 : TypeIndex} (h : \u03b3 < \u03b2) (\u03c1 : AllPerm \u03b2) :\n    \u03c1\u207b\u00b9 \u2198 h = (\u03c1 \u2198 h)\u207b\u00b9 := by\n  apply allPermForget_injective\n  rw [allPermSderiv_forget', allPermForget_inv, Tree.inv_sderiv, allPermForget_inv,\n    allPermSderiv_forget']\n\ndef Symmetric {\u03b1 \u03b2 : \u039b} (s : Set (TSet \u03b2)) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) : Prop :=\n  \u2203 S : Support \u03b1, \u2200 \u03c1 : AllPerm \u03b1, \u03c1\u1d41 \u2022 S = S \u2192 \u03c1 \u2198 h\u03b2 \u2022 s = s\n\ndef newSetEquiv {\u03b1 : \u039b} :\n    letI : Level := \u27e8\u03b1\u27e9\n    @TSet _ \u03b1 newModelData.toPreModelData \u2243 TSet \u03b1 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castTSet (D\u2081 := newModelData) (D\u2082 := globalModelData) rfl\n    (by rw [globalModelData, motive_eq, constructMotive, globalLtData_eq])\n\n@[simp]\ntheorem newSetEquiv_forget {\u03b1 : \u039b}\n    (x : letI : Level := \u27e8\u03b1\u27e9; @TSet _ \u03b1 newModelData.toPreModelData) :\n    (newSetEquiv x)\u1d41 = x\u1d41 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castTSet_forget (D\u2081 := newModelData) (D\u2082 := globalModelData) _ x\n\ndef allPermEquiv {\u03b1 : \u039b} :\n    letI : Level := \u27e8\u03b1\u27e9\n    NewPerm \u2243 AllPerm \u03b1 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castAllPerm (D\u2081 := newModelData) (D\u2082 := globalModelData) rfl\n    (by rw [globalModelData, motive_eq, constructMotive, globalLtData_eq])\n\n", "theoremStatement": "@[simp]\ntheorem allPermEquiv_forget {\u03b1 : \u039b} (\u03c1 : letI : Level := \u27e8\u03b1\u27e9; NewPerm) :\n    (allPermEquiv \u03c1)\u1d41 = \u03c1\u1d41 ", "theoremName": "ConNF.allPermEquiv_forget", "fileCreated": {"commit": "6fdc87c6b30b73931407a372f1430ecf0fef7601", "date": "2024-12-03"}, "theoremCreated": {"commit": "75a59b81a56dda9d4494ecfa54a8354c680a0c7c", "date": "2024-12-01"}, "file": "ConNF/ConNF/Model/TTT.lean", "module": "ConNF.Model.TTT", "jsonFile": "ConNF.Model.TTT.jsonl", "positionMetadata": {"lineInFile": 94, "tokenPositionInFile": 2974, "theoremPositionInFile": 8}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 16, "numPremises": 22}, "proofMetadata": {"hasProof": true, "proof": ":=\n  letI : Level := \u27e8\u03b1\u27e9\n  castAllPerm_forget (D\u2081 := newModelData) (D\u2082 := globalModelData) _ \u03c1", "proofType": "term", "proofLengthLines": 2, "proofLengthTokens": 94}}
{"srcContext": "import ConNF.ModelData.PathEnumeration\n\n/-!\n# Supports\n\nIn this file, we define the notion of a support.\n\n## Main declarations\n\n* `ConNF.BaseSupport`: The type of supports of atoms.\n* `ConNF.Support`: The type of supports of objects of arbitrary type indices.\n-/\n\nuniverse u\n\nopen Cardinal\n\nnamespace ConNF\n\nvariable [Params.{u}]\n\n/-!\n## Base supports\n-/\n\nstructure BaseSupport where\n  atoms : Enumeration Atom\n  nearLitters : Enumeration NearLitter\n\nnamespace BaseSupport\n\ninstance : SuperA BaseSupport (Enumeration Atom) where\n  superA := atoms\n\ninstance : SuperN BaseSupport (Enumeration NearLitter) where\n  superN := nearLitters\n\n@[simp]\ntheorem mk_atoms {a : Enumeration Atom} {N : Enumeration NearLitter} :\n    (BaseSupport.mk a N)\u1d2c = a :=\n  rfl\n\n@[simp]\ntheorem mk_nearLitters {a : Enumeration Atom} {N : Enumeration NearLitter} :\n    (BaseSupport.mk a N)\u1d3a = N :=\n  rfl\n\ntheorem atoms_congr {S T : BaseSupport} (h : S = T) :\n    S\u1d2c = T\u1d2c :=\n  h \u25b8 rfl\n\ntheorem nearLitters_congr {S T : BaseSupport} (h : S = T) :\n    S\u1d3a = T\u1d3a :=\n  h \u25b8 rfl\n\n@[ext]\ntheorem ext {S T : BaseSupport} (h\u2081 : S\u1d2c = T\u1d2c) (h\u2082 : S\u1d3a = T\u1d3a) : S = T := by\n  obtain \u27e8SA, SN\u27e9 := S\n  obtain \u27e8TA, TN\u27e9 := T\n  cases h\u2081\n  cases h\u2082\n  rfl\n\ninstance : SMul BasePerm BaseSupport where\n  smul \u03c0 S := \u27e8\u03c0 \u2022 S\u1d2c, \u03c0 \u2022 S\u1d3a\u27e9\n\n@[simp]\ntheorem smul_atoms (\u03c0 : BasePerm) (S : BaseSupport) :\n    (\u03c0 \u2022 S)\u1d2c = \u03c0 \u2022 S\u1d2c :=\n  rfl\n\n@[simp]\ntheorem smul_nearLitters (\u03c0 : BasePerm) (S : BaseSupport) :\n    (\u03c0 \u2022 S)\u1d3a = \u03c0 \u2022 S\u1d3a :=\n  rfl\n\n@[simp]\ntheorem smul_atoms_eq_of_smul_eq {\u03c0 : BasePerm} {S : BaseSupport}\n    (h : \u03c0 \u2022 S = S) :\n    \u03c0 \u2022 S\u1d2c = S\u1d2c := by\n  rw [\u2190 smul_atoms, h]\n\n@[simp]\ntheorem smul_nearLitters_eq_of_smul_eq {\u03c0 : BasePerm} {S : BaseSupport}\n    (h : \u03c0 \u2022 S = S) :\n    \u03c0 \u2022 S\u1d3a = S\u1d3a := by\n  rw [\u2190 smul_nearLitters, h]\n\ninstance : MulAction BasePerm BaseSupport where\n  one_smul S := by\n    apply ext\n    \u00b7 rw [smul_atoms, one_smul]\n    \u00b7 rw [smul_nearLitters, one_smul]\n  mul_smul \u03c0\u2081 \u03c0\u2082 S := by\n    apply ext\n    \u00b7 rw [smul_atoms, smul_atoms, smul_atoms, mul_smul]\n    \u00b7 rw [smul_nearLitters, smul_nearLitters, smul_nearLitters, mul_smul]\n\ntheorem smul_eq_smul_iff (\u03c0\u2081 \u03c0\u2082 : BasePerm) (S : BaseSupport) :\n    \u03c0\u2081 \u2022 S = \u03c0\u2082 \u2022 S \u2194 (\u2200 a \u2208 S\u1d2c, \u03c0\u2081 \u2022 a = \u03c0\u2082 \u2022 a) \u2227 (\u2200 N \u2208 S\u1d3a, \u03c0\u2081 \u2022 N = \u03c0\u2082 \u2022 N) := by\n  constructor\n  \u00b7 intro h\n    constructor\n    \u00b7 rintro a \u27e8i, ha\u27e9\n      have := congr_arg (\u00b7\u1d2c.rel i (\u03c0\u2081 \u2022 a)) h\n      simp only [smul_atoms, Enumeration.smul_rel, inv_smul_smul, eq_iff_iff] at this\n      have := S\u1d2c.rel_coinjective.coinjective ha (this.mp ha)\n      rw [eq_inv_smul_iff] at this\n      rw [this]\n    \u00b7 rintro N \u27e8i, hN\u27e9\n      have := congr_arg (\u00b7\u1d3a.rel i (\u03c0\u2081 \u2022 N)) h\n      simp only [smul_nearLitters, Enumeration.smul_rel, inv_smul_smul, eq_iff_iff] at this\n      have := S\u1d3a.rel_coinjective.coinjective hN (this.mp hN)\n      rw [eq_inv_smul_iff] at this\n      rw [this]\n  \u00b7 intro h\n    ext : 2\n    \u00b7 rfl\n    \u00b7 ext i a : 3\n      rw [smul_atoms, smul_atoms, Enumeration.smul_rel, Enumeration.smul_rel]\n      constructor\n      \u00b7 intro ha\n        have := h.1 _ \u27e8i, ha\u27e9\n        rw [smul_inv_smul, \u2190 inv_smul_eq_iff] at this\n        rwa [this]\n      \u00b7 intro ha\n        have := h.1 _ \u27e8i, ha\u27e9\n        rw [smul_inv_smul, smul_eq_iff_eq_inv_smul] at this\n        rwa [\u2190 this]\n    \u00b7 rfl\n    \u00b7 ext i a : 3\n      rw [smul_nearLitters, smul_nearLitters, Enumeration.smul_rel, Enumeration.smul_rel]\n      constructor\n      \u00b7 intro hN\n        have := h.2 _ \u27e8i, hN\u27e9\n        rw [smul_inv_smul, \u2190 inv_smul_eq_iff] at this\n        rwa [this]\n      \u00b7 intro hN\n        have := h.2 _ \u27e8i, hN\u27e9\n        rw [smul_inv_smul, smul_eq_iff_eq_inv_smul] at this\n        rwa [\u2190 this]\n\ntheorem smul_eq_iff (\u03c0 : BasePerm) (S : BaseSupport) :\n    \u03c0 \u2022 S = S \u2194 (\u2200 a \u2208 S\u1d2c, \u03c0 \u2022 a = a) \u2227 (\u2200 N \u2208 S\u1d3a, \u03c0 \u2022 N = N) := by\n  have := smul_eq_smul_iff \u03c0 1 S\n  simp only [one_smul] at this\n  exact this\n\nnoncomputable instance : Add BaseSupport where\n  add S T := \u27e8S\u1d2c + T\u1d2c, S\u1d3a + T\u1d3a\u27e9\n\n@[simp]\ntheorem add_atoms (S T : BaseSupport) :\n    (S + T)\u1d2c = S\u1d2c + T\u1d2c :=\n  rfl\n\n@[simp]\ntheorem add_nearLitters (S T : BaseSupport) :\n    (S + T)\u1d3a = S\u1d3a + T\u1d3a :=\n  rfl\n\nend BaseSupport\n\ndef baseSupportEquiv : BaseSupport \u2243 Enumeration Atom \u00d7 Enumeration NearLitter where\n  toFun S := (S\u1d2c, S\u1d3a)\n  invFun S := \u27e8S.1, S.2\u27e9\n  left_inv _ := rfl\n  right_inv _ := rfl\n\ntheorem card_baseSupport : #BaseSupport = #\u03bc := by\n  rw [Cardinal.eq.mpr \u27e8baseSupportEquiv\u27e9, mk_prod, lift_id, lift_id,\n    card_enumeration_eq card_atom, card_enumeration_eq card_nearLitter, mul_eq_self aleph0_lt_\u03bc.le]\n\n/-!\n## Structural supports\n-/\n\nstructure Support (\u03b1 : TypeIndex) where\n  atoms : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)\n  nearLitters : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)\n\nnamespace Support\n\nvariable {\u03b1 \u03b2 : TypeIndex}\n\ninstance : SuperA (Support \u03b1) (Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) where\n  superA := atoms\n\ninstance : SuperN (Support \u03b1) (Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) where\n  superN := nearLitters\n\n@[simp]\ntheorem mk_atoms (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) (F : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) :\n    (\u27e8E, F\u27e9 : Support \u03b1)\u1d2c = E :=\n  rfl\n\n@[simp]\ntheorem mk_nearLitters (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) (F : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) :\n    (\u27e8E, F\u27e9 : Support \u03b1)\u1d3a = F :=\n  rfl\n\ninstance : Derivative (Support \u03b1) (Support \u03b2) \u03b1 \u03b2 where\n  deriv S A := \u27e8S\u1d2c \u21d8 A, S\u1d3a \u21d8 A\u27e9\n\ninstance : Coderivative (Support \u03b2) (Support \u03b1) \u03b1 \u03b2 where\n  coderiv S A := \u27e8S\u1d2c \u21d7 A, S\u1d3a \u21d7 A\u27e9\n\ninstance : BotDerivative (Support \u03b1) BaseSupport \u03b1 where\n  botDeriv S A := \u27e8S\u1d2c \u21d8. A, S\u1d3a \u21d8. A\u27e9\n  botSderiv S := \u27e8S\u1d2c \u2198., S\u1d3a \u2198.\u27e9\n  botDeriv_single S h := by dsimp only; rw [botDeriv_single, botDeriv_single]\n\n@[simp]\ntheorem deriv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u03b2) :\n    S\u1d2c \u21d8 A = (S \u21d8 A)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem deriv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u03b2) :\n    S\u1d3a \u21d8 A = (S \u21d8 A)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem sderiv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (h : \u03b2 < \u03b1) :\n    S\u1d2c \u2198 h = (S \u2198 h)\u1d2c :=\n  rfl\n\n", "theoremStatement": "@[simp]\ntheorem sderiv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (h : \u03b2 < \u03b1) :\n    S\u1d3a \u2198 h = (S \u2198 h)\u1d3a ", "theoremName": "ConNF.Support.sderiv_nearLitters", "fileCreated": {"commit": "39c33b4a743bea62dbcc549548b712ffd38ca65c", "date": "2024-12-05"}, "theoremCreated": {"commit": "ce890707e37ede74a2fcd66134d3f403335c5cc1", "date": "2024-11-30"}, "file": "ConNF/ConNF/ModelData/Support.lean", "module": "ConNF.ModelData.Support", "jsonFile": "ConNF.ModelData.Support.jsonl", "positionMetadata": {"lineInFile": 228, "tokenPositionInFile": 5849, "theoremPositionInFile": 19}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 15, "numPremises": 28}, "proofMetadata": {"hasProof": true, "proof": ":=\n  rfl", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 8}}
{"srcContext": "import ConNF.Background.ReflTransGen\nimport ConNF.FOA.Inflexible\n\n/-!\n# Strong supports\n\nIn this file, we define strong supports.\n\n## Main declarations\n\n* `ConNF.Support.Strong`: The property that a support is strong.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\nopen scoped symmDiff\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b2 : TypeIndex}\n\nstructure BaseSupport.Closed (S : BaseSupport) : Prop where\n  interference_subset {N\u2081 N\u2082 : NearLitter} :\n    N\u2081 \u2208 S\u1d3a \u2192 N\u2082 \u2208 S\u1d3a \u2192 \u2200 a \u2208 interference N\u2081 N\u2082, a \u2208 S\u1d2c\n\nnamespace Support\n\nvariable [Level] [CoherentData] [LeLevel \u03b2]\n\nstructure PreStrong (S : Support \u03b2) : Prop where\n  support_le {A : \u03b2 \u219d \u22a5} {N : NearLitter} (h : N \u2208 (S \u21d8. A)\u1d3a)\n    (P : InflexiblePath \u03b2) (t : Tangle P.\u03b4)\n    (hA : A = P.A \u2198 P.h\u03b5 \u2198.) (ht : N\u1d38 = fuzz P.h\u03b4\u03b5 t) :\n    t.support \u2264 S \u21d8 (P.A \u2198 P.h\u03b4)\n\nstructure Closed (S : Support \u03b2) : Prop where\n  closed : \u2200 A, (S \u21d8. A).Closed\n\nstructure Strong (S : Support \u03b2) extends S.PreStrong, S.Closed : Prop\n\ntheorem PreStrong.smul {S : Support \u03b2} (hS : S.PreStrong) (\u03c1 : AllPerm \u03b2) : (\u03c1\u1d41 \u2022 S).PreStrong := by\n  constructor\n  intro A N hN P t hA ht\n  rw [smul_derivBot, BaseSupport.smul_nearLitters, Enumeration.mem_smul] at hN\n  have := hS.support_le hN P (\u03c1\u207b\u00b9 \u21d8 P.A \u2198 P.h\u03b4 \u2022 t) hA ?_\n  \u00b7 convert smul_le_smul this (\u03c1\u1d41 \u21d8 P.A \u2198 P.h\u03b4) using 1\n    \u00b7 rw [Tangle.smul_support, smul_smul,\n        allPermSderiv_forget, allPermDeriv_forget, allPermForget_inv,\n        Tree.inv_deriv, Tree.inv_sderiv, mul_inv_cancel, one_smul]\n    \u00b7 ext B : 1\n      rw [smul_derivBot, Tree.sderiv_apply, Tree.deriv_apply, Path.deriv_scoderiv]\n      rfl\n  \u00b7 rw [\u2190 smul_fuzz P.h\u03b4 P.h\u03b5 P.h\u03b4\u03b5, allPermDeriv_forget, allPermForget_inv,\n      BasePerm.smul_nearLitter_litter, \u2190 Tree.inv_apply, hA, ht]\n    rfl\n\ntheorem Closed.smul {S : Support \u03b2} (hS : S.Closed) (\u03c1 : AllPerm \u03b2) : (\u03c1\u1d41 \u2022 S).Closed := by\n  constructor\n  intro A\n  constructor\n  intro N\u2081 N\u2082 h\u2081 h\u2082\n  simp only [smul_derivBot, BaseSupport.smul_nearLitters, BaseSupport.smul_atoms,\n    Enumeration.mem_smul] at h\u2081 h\u2082 \u22a2\n  intro a ha\n  apply (hS.closed A).interference_subset h\u2081 h\u2082\n  rwa [\u2190 BasePerm.smul_interference, Set.smul_mem_smul_set_iff]\n\ntheorem Strong.smul {S : Support \u03b2} (hS : S.Strong) (\u03c1 : AllPerm \u03b2) : (\u03c1\u1d41 \u2022 S).Strong :=\n  \u27e8hS.toPreStrong.smul \u03c1, hS.toClosed.smul \u03c1\u27e9\n\n", "theoremStatement": "theorem PreStrong.add {S T : Support \u03b2} (hS : S.PreStrong) (hT : T.PreStrong) :\n    (S + T).PreStrong ", "theoremName": "ConNF.Support.PreStrong.add", "fileCreated": {"commit": "8896e416a16c39e1fe487b5fc7c78bc20c4e182b", "date": "2024-12-03"}, "theoremCreated": {"commit": "251ac752f844dfde539ac2bd3ff112305ad59139", "date": "2024-11-30"}, "file": "ConNF/ConNF/Strong/Strong.lean", "module": "ConNF.Strong.Strong", "jsonFile": "ConNF.Strong.Strong.jsonl", "positionMetadata": {"lineInFile": 73, "tokenPositionInFile": 2281, "theoremPositionInFile": 3}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 56, "numPremises": 70}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  constructor\n  intro A N hN P t hA ht\n  simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff] at hN\n  obtain hN | hN := hN\n  \u00b7 intro B\n    simp only [deriv_derivBot, add_derivBot]\n    exact (hS.support_le hN P t hA ht B).trans (BaseSupport.le_add_right)\n  \u00b7 intro B\n    simp only [deriv_derivBot, add_derivBot]\n    exact (hT.support_le hN P t hA ht B).trans (BaseSupport.le_add_left)", "proofType": "tactic", "proofLengthLines": 10, "proofLengthTokens": 415}}
{"srcContext": "import ConNF.Model.TTT\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\nnamespace TSet\n\ntheorem exists_inter (x y : TSet \u03b1) :\n    \u2203 w : TSet \u03b1, \u2200 z : TSet \u03b2, z \u2208[h\u03b2] w \u2194 z \u2208[h\u03b2] x \u2227 z \u2208[h\u03b2] y := by\n  refine exists_of_symmetric {z | z \u2208[h\u03b2] x \u2227 z \u2208[h\u03b2] y} h\u03b2 ?_\n  obtain \u27e8S, hS\u27e9 := symmetric x h\u03b2\n  obtain \u27e8T, hT\u27e9 := symmetric y h\u03b2\n  use S + T\n  intro \u03c1 h\u03c1\n  specialize hS \u03c1 (smul_eq_of_le Support.le_add_right h\u03c1)\n  specialize hT \u03c1 (smul_eq_of_le Support.le_add_left h\u03c1)\n  simp [Set.ext_iff, Set.mem_smul_set_iff_inv_smul_mem] at hS hT \u22a2\n  aesop\n\ntheorem exists_compl (x : TSet \u03b1) :\n    \u2203 y : TSet \u03b1, \u2200 z : TSet \u03b2, z \u2208[h\u03b2] y \u2194 \u00acz \u2208[h\u03b2] x := by\n  refine exists_of_symmetric {z | \u00acz \u2208[h\u03b2] x} h\u03b2 ?_\n  obtain \u27e8S, hS\u27e9 := symmetric x h\u03b2\n  use S\n  intro \u03c1 h\u03c1\n  specialize hS \u03c1 h\u03c1\n  simp [Set.ext_iff, Set.mem_smul_set_iff_inv_smul_mem] at hS \u22a2\n  aesop\n\ntheorem exists_up (x y : TSet \u03b2) :\n    \u2203 w : TSet \u03b1, \u2200 z : TSet \u03b2, z \u2208[h\u03b2] w \u2194 z = x \u2228 z = y := by\n  refine exists_of_symmetric {x, y} h\u03b2 ?_\n  obtain \u27e8S, hS\u27e9 := exists_support x\n  obtain \u27e8T, hT\u27e9 := exists_support y\n  use (S + T) \u2197 h\u03b2\n  intro \u03c1 h\u03c1\n  rw [Support.smul_scoderiv, Support.scoderiv_inj, \u2190 allPermSderiv_forget'] at h\u03c1\n  specialize hS (\u03c1 \u2198 h\u03b2) (smul_eq_of_le Support.le_add_right h\u03c1)\n  specialize hT (\u03c1 \u2198 h\u03b2) (smul_eq_of_le Support.le_add_left h\u03c1)\n  simp only [Set.smul_set_def, Set.image, Set.mem_insert_iff, Set.mem_singleton_iff,\n    exists_eq_or_imp, hS, exists_eq_left, hT]\n  ext z\n  rw [Set.mem_insert_iff, Set.mem_singleton_iff, Set.mem_setOf_eq]\n  aesop\n\n/-- The unordered pair. -/\ndef up (x y : TSet \u03b2) : TSet \u03b1 :=\n  (exists_up h\u03b2 x y).choose\n\n@[simp]\ntheorem mem_up_iff (x y z : TSet \u03b2) :\n    z \u2208[h\u03b2] up h\u03b2 x y \u2194 z = x \u2228 z = y :=\n  (exists_up h\u03b2 x y).choose_spec z\n\n/-- The Kuratowski ordered pair. -/\ndef op (x y : TSet \u03b3) : TSet \u03b1 :=\n  up h\u03b2 (singleton h\u03b3 x) (up h\u03b3 x y)\n\ntheorem up_injective {x y z w : TSet \u03b2} (h : up h\u03b2 x y = up h\u03b2 z w) :\n    (x = z \u2227 y = w) \u2228 (x = w \u2227 y = z) := by\n  have h\u2081 := mem_up_iff h\u03b2 x y z\n  have h\u2082 := mem_up_iff h\u03b2 x y w\n  have h\u2083 := mem_up_iff h\u03b2 z w x\n  have h\u2084 := mem_up_iff h\u03b2 z w y\n  rw [h, mem_up_iff] at h\u2081 h\u2082\n  rw [\u2190 h, mem_up_iff] at h\u2083 h\u2084\n  aesop\n\n@[simp]\ntheorem up_inj (x y z w : TSet \u03b2) :\n    up h\u03b2 x y = up h\u03b2 z w \u2194 (x = z \u2227 y = w) \u2228 (x = w \u2227 y = z) := by\n  constructor\n  \u00b7 exact up_injective h\u03b2\n  \u00b7 rintro (\u27e8rfl, rfl\u27e9 | \u27e8rfl, rfl\u27e9)\n    \u00b7 rfl\n    \u00b7 apply tSet_ext' h\u03b2\n      aesop\n\n@[simp]\ntheorem up_self {x : TSet \u03b2} :\n    up h\u03b2 x x = singleton h\u03b2 x := by\n  apply tSet_ext' h\u03b2\n  aesop\n\n@[simp]\ntheorem up_eq_singleton_iff (x y z : TSet \u03b2) :\n    up h\u03b2 x y = singleton h\u03b2 z \u2194 x = z \u2227 y = z := by\n  constructor\n  \u00b7 intro h\n    have h\u2081 := typedMem_singleton_iff' h\u03b2 z x\n    have h\u2082 := typedMem_singleton_iff' h\u03b2 z y\n    rw [\u2190 h, mem_up_iff] at h\u2081 h\u2082\n    aesop\n  \u00b7 rintro \u27e8rfl, rfl\u27e9\n    rw [up_self]\n\n@[simp]\ntheorem singleton_eq_up_iff (x y z : TSet \u03b2) :\n    singleton h\u03b2 z = up h\u03b2 x y \u2194 x = z \u2227 y = z := by\n  rw [\u2190 up_eq_singleton_iff h\u03b2 x y z, eq_comm]\n\ntheorem op_injective {x y z w : TSet \u03b3} (h : op h\u03b2 h\u03b3 x y = op h\u03b2 h\u03b3 z w) :\n    x = z \u2227 y = w := by\n  rw [op, op] at h\n  simp only [up_inj, singleton_inj, singleton_eq_up_iff, up_eq_singleton_iff] at h\n  obtain (\u27e8rfl, \u27e8h, rfl\u27e9 | \u27e8rfl, rfl\u27e9\u27e9 | \u27e8\u27e8rfl, rfl\u27e9, \u27e8h, rfl\u27e9\u27e9) := h <;> simp only [and_self]\n\n@[simp]\ntheorem op_inj (x y z w : TSet \u03b3) :\n    op h\u03b2 h\u03b3 x y = op h\u03b2 h\u03b3 z w \u2194 x = z \u2227 y = w := by\n  constructor\n  \u00b7 exact op_injective h\u03b2 h\u03b3\n  \u00b7 rintro \u27e8rfl, rfl\u27e9\n    rfl\n\n@[simp]\ntheorem op_eq_singleton_iff (x y : TSet \u03b3) (z : TSet \u03b2) :\n    op h\u03b2 h\u03b3 x y = singleton h\u03b2 z \u2194 singleton h\u03b3 x = z \u2227 singleton h\u03b3 y = z := by\n  rw [op, up_eq_singleton_iff, and_congr_right_iff]\n  rintro rfl\n  simp only [up_eq_singleton_iff, true_and, singleton_inj]\n\n@[simp]\ntheorem smul_up (x y : TSet \u03b2) (\u03c1 : AllPerm \u03b1) :\n    \u03c1 \u2022 up h\u03b2 x y = up h\u03b2 (\u03c1 \u2198 h\u03b2 \u2022 x) (\u03c1 \u2198 h\u03b2 \u2022 y) := by\n  apply tSet_ext' h\u03b2\n  aesop\n\n@[simp]\ntheorem smul_op (x y : TSet \u03b3) (\u03c1 : AllPerm \u03b1) :\n    \u03c1 \u2022 op h\u03b2 h\u03b3 x y = op h\u03b2 h\u03b3 (\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2022 x) (\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2022 y) := by\n  apply tSet_ext' h\u03b2\n  simp only [op, smul_up, smul_singleton, mem_up_iff, implies_true]\n\ntheorem exists_singletonImage (x : TSet \u03b2) :\n    \u2203 y : TSet \u03b1, \u2200 z w,\n    op h\u03b3 h\u03b4 (singleton h\u03b5 z) (singleton h\u03b5 w) \u2208[h\u03b2] y \u2194 op h\u03b4 h\u03b5 z w \u2208[h\u03b3] x := by\n  have := exists_of_symmetric {u | \u2203 z w : TSet \u03b5, op h\u03b4 h\u03b5 z w \u2208[h\u03b3] x \u2227\n      u = op h\u03b3 h\u03b4 (singleton h\u03b5 z) (singleton h\u03b5 w)} h\u03b2 ?_\n  \u00b7 obtain \u27e8y, hy\u27e9 := this\n    use y\n    intro z w\n    rw [hy]\n    simp only [Set.mem_setOf_eq, op_inj, singleton_inj, exists_eq_right_right', exists_eq_right']\n  \u00b7 obtain \u27e8S, hS\u27e9 := exists_support x\n    use S \u2197 h\u03b2\n    intro \u03c1 h\u03c1\n    rw [Support.smul_scoderiv, Support.scoderiv_inj, \u2190 allPermSderiv_forget'] at h\u03c1\n    specialize hS (\u03c1 \u2198 h\u03b2) h\u03c1\n    ext z\n    constructor\n    \u00b7 rintro \u27e8_, \u27e8z, w, hab, rfl\u27e9, rfl\u27e9\n      refine \u27e8\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2022 z, \u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2022 w, ?_, ?_\u27e9\n      \u00b7 rwa [\u2190 hS, mem_smul_iff', smul_op, allPerm_inv_sderiv', allPerm_inv_sderiv',\n          allPerm_inv_sderiv', inv_smul_smul, inv_smul_smul]\n      \u00b7 simp only [smul_op, smul_singleton]\n    \u00b7 rintro \u27e8z, w, hab, rfl\u27e9\n      refine \u27e8\u03c1\u207b\u00b9 \u2198 h\u03b2 \u2022 op h\u03b3 h\u03b4 (singleton h\u03b5 z) (singleton h\u03b5 w), ?_, ?_\u27e9\n      \u00b7 simp only [allPerm_inv_sderiv', smul_op, smul_singleton, Set.mem_setOf_eq, op_inj,\n          singleton_inj, exists_eq_right_right', exists_eq_right']\n        rw [smul_eq_iff_eq_inv_smul] at hS\n        rw [hS]\n        simp only [mem_smul_iff', inv_inv, smul_op, smul_inv_smul]\n        exact hab\n      \u00b7 simp only [allPerm_inv_sderiv', smul_inv_smul]\n\ntheorem exists_insertion2 (x : TSet \u03b3) :\n    \u2203 y : TSet \u03b1, \u2200 a b c, op h\u03b3 h\u03b4 (singleton h\u03b5 (singleton h\u03b6 a)) (op h\u03b5 h\u03b6 b c) \u2208[h\u03b2] y \u2194\n    op h\u03b5 h\u03b6 a c \u2208[h\u03b4] x := by\n  have := exists_of_symmetric {u | \u2203 a b c : TSet \u03b6, op h\u03b5 h\u03b6 a c \u2208[h\u03b4] x \u2227\n      u = op h\u03b3 h\u03b4 (singleton h\u03b5 (singleton h\u03b6 a)) (op h\u03b5 h\u03b6 b c)} h\u03b2 ?_\n  \u00b7 obtain \u27e8y, hy\u27e9 := this\n    use y\n    intro a b c\n    rw [hy]\n    constructor\n    \u00b7 rintro \u27e8a', b', c', h\u2081, h\u2082\u27e9\n      simp only [op_inj, singleton_inj] at h\u2082\n      obtain \u27e8rfl, rfl, rfl\u27e9 := h\u2082\n      exact h\u2081\n    \u00b7 intro h\n      exact \u27e8a, b, c, h, rfl\u27e9\n  \u00b7 obtain \u27e8S, hS\u27e9 := exists_support x\n    use S \u2197 h\u03b3 \u2197 h\u03b2\n    intro \u03c1 h\u03c1\n    simp only [Support.smul_scoderiv, Support.scoderiv_inj, \u2190 allPermSderiv_forget'] at h\u03c1\n    specialize hS (\u03c1 \u2198 h\u03b2 \u2198 h\u03b3) h\u03c1\n    ext z\n    constructor\n    \u00b7 rintro \u27e8_, \u27e8a, b, c, hx, rfl\u27e9, rfl\u27e9\n      refine \u27e8\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 a, \u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 b,\n        \u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 c, ?_, ?_\u27e9\n      \u00b7 rw [\u2190 hS]\n        simp only [mem_smul_iff', allPerm_inv_sderiv', smul_op, inv_smul_smul]\n        exact hx\n      \u00b7 simp only [smul_op, smul_singleton]\n    \u00b7 rintro \u27e8a, b, c, hx, rfl\u27e9\n      rw [Set.mem_smul_set_iff_inv_smul_mem]\n      refine \u27e8\u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 a, \u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 b,\n        \u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 c, ?_, ?_\u27e9\n      \u00b7 rw [smul_eq_iff_eq_inv_smul] at hS\n        rw [hS, mem_smul_iff']\n        simp only [inv_inv, allPerm_inv_sderiv', smul_op, smul_inv_smul]\n        exact hx\n      \u00b7 simp only [smul_op, allPerm_inv_sderiv', smul_singleton]\n\ntheorem exists_insertion3 (x : TSet \u03b3) :\n    \u2203 y : TSet \u03b1, \u2200 a b c, op h\u03b3 h\u03b4 (singleton h\u03b5 (singleton h\u03b6 a)) (op h\u03b5 h\u03b6 b c) \u2208[h\u03b2] y \u2194\n    op h\u03b5 h\u03b6 a b \u2208[h\u03b4] x := by\n  have := exists_of_symmetric {u | \u2203 a b c : TSet \u03b6, op h\u03b5 h\u03b6 a b \u2208[h\u03b4] x \u2227\n      u = op h\u03b3 h\u03b4 (singleton h\u03b5 (singleton h\u03b6 a)) (op h\u03b5 h\u03b6 b c)} h\u03b2 ?_\n  \u00b7 obtain \u27e8y, hy\u27e9 := this\n    use y\n    intro a b c\n    rw [hy]\n    constructor\n    \u00b7 rintro \u27e8a', b', c', h\u2081, h\u2082\u27e9\n      simp only [op_inj, singleton_inj] at h\u2082\n      obtain \u27e8rfl, rfl, rfl\u27e9 := h\u2082\n      exact h\u2081\n    \u00b7 intro h\n      exact \u27e8a, b, c, h, rfl\u27e9\n  \u00b7 obtain \u27e8S, hS\u27e9 := exists_support x\n    use S \u2197 h\u03b3 \u2197 h\u03b2\n    intro \u03c1 h\u03c1\n    simp only [Support.smul_scoderiv, Support.scoderiv_inj, \u2190 allPermSderiv_forget'] at h\u03c1\n    specialize hS (\u03c1 \u2198 h\u03b2 \u2198 h\u03b3) h\u03c1\n    ext z\n    constructor\n    \u00b7 rintro \u27e8_, \u27e8a, b, c, hx, rfl\u27e9, rfl\u27e9\n      refine \u27e8\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 a, \u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 b,\n        \u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 c, ?_, ?_\u27e9\n      \u00b7 rw [\u2190 hS]\n        simp only [mem_smul_iff', allPerm_inv_sderiv', smul_op, inv_smul_smul]\n        exact hx\n      \u00b7 simp only [smul_op, smul_singleton]\n    \u00b7 rintro \u27e8a, b, c, hx, rfl\u27e9\n      rw [Set.mem_smul_set_iff_inv_smul_mem]\n      refine \u27e8\u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 a, \u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 b,\n        \u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 c, ?_, ?_\u27e9\n      \u00b7 rw [smul_eq_iff_eq_inv_smul] at hS\n        rw [hS, mem_smul_iff']\n        simp only [inv_inv, allPerm_inv_sderiv', smul_op, smul_inv_smul]\n        exact hx\n      \u00b7 simp only [smul_op, allPerm_inv_sderiv', smul_singleton]\n\n", "theoremStatement": "theorem exists_cross (x : TSet \u03b3) :\n    \u2203 y : TSet \u03b1, \u2200 a, a \u2208[h\u03b2] y \u2194 \u2203 b c, a = op h\u03b3 h\u03b4 b c \u2227 c \u2208[h\u03b4] x ", "theoremName": "ConNF.TSet.exists_cross", "fileCreated": {"commit": "f804f5c71cfaa98223fc227dd822801e8bf77004", "date": "2024-03-30"}, "theoremCreated": {"commit": "f7c233c7f7fd9d8b74595bbfa2bbbd49d538ef59", "date": "2024-12-02"}, "file": "ConNF/ConNF/Model/Hailperin.lean", "module": "ConNF.Model.Hailperin", "jsonFile": "ConNF.Model.Hailperin.jsonl", "positionMetadata": {"lineInFile": 264, "tokenPositionInFile": 8917, "theoremPositionInFile": 19}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 40, "numPremises": 98}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  have := exists_of_symmetric {a | \u2203 b c, a = op h\u03b3 h\u03b4 b c \u2227 c \u2208[h\u03b4] x} h\u03b2 ?_\n  \u00b7 obtain \u27e8y, hy\u27e9 := this\n    use y\n    intro a\n    rw [hy]\n    rfl\n  \u00b7 obtain \u27e8S, hS\u27e9 := exists_support x\n    use S \u2197 h\u03b3 \u2197 h\u03b2\n    intro \u03c1 h\u03c1\n    simp only [Support.smul_scoderiv, Support.scoderiv_inj, \u2190 allPermSderiv_forget'] at h\u03c1\n    specialize hS (\u03c1 \u2198 h\u03b2 \u2198 h\u03b3) h\u03c1\n    ext z\n    constructor\n    \u00b7 rintro \u27e8_, \u27e8a, b, rfl, hab\u27e9, rfl\u27e9\n      refine \u27e8\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2022 a, \u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2022 b, ?_, ?_\u27e9\n      \u00b7 simp only [smul_op]\n      \u00b7 rw [\u2190 hS]\n        simp only [mem_smul_iff', allPerm_inv_sderiv', inv_smul_smul]\n        exact hab\n    \u00b7 rintro \u27e8a, b, rfl, hab\u27e9\n      rw [Set.mem_smul_set_iff_inv_smul_mem]\n      refine \u27e8\u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2022 a, \u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2022 b, ?_, ?_\u27e9\n      \u00b7 simp only [smul_op, allPerm_inv_sderiv']\n      \u00b7 rw [smul_eq_iff_eq_inv_smul] at hS\n        rw [hS]\n        simp only [allPerm_inv_sderiv', mem_smul_iff', inv_inv, smul_inv_smul]\n        exact hab", "proofType": "tactic", "proofLengthLines": 27, "proofLengthTokens": 968}}
{"srcContext": "import ConNF.Model.RaiseStrong\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nopen scoped Pointwise\n\nnamespace ConNF\n\nvariable [Params.{u}]\n\n/-- A redefinition of the derivative of allowable permutations that is invariant of level,\nbut still has nice definitional properties. -/\n@[default_instance 200]\ninstance {\u03b2 \u03b3 : TypeIndex} : Derivative (AllPerm \u03b2) (AllPerm \u03b3) \u03b2 \u03b3 where\n  deriv \u03c1 A :=\n    A.recSderiv\n    (motive := \u03bb (\u03b4 : TypeIndex) (A : \u03b2 \u219d \u03b4) \u21a6\n      letI : Level := \u27e8\u03b4.recBotCoe (Nonempty.some inferInstance) id\u27e9\n      letI : LeLevel \u03b4 := \u27e8\u03b4.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n        (show \u03b4.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n      AllPerm \u03b4)\n    \u03c1 (\u03bb \u03b4 \u03b5 A h \u03c1 \u21a6\n      letI : Level := \u27e8\u03b4.recBotCoe (Nonempty.some inferInstance) id\u27e9\n      letI : LeLevel \u03b4 := \u27e8\u03b4.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n        (show \u03b4.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n      letI : LeLevel \u03b5 := \u27e8h.le.trans LeLevel.elim\u27e9\n      PreCoherentData.allPermSderiv h \u03c1)\n\n", "theoremStatement": "@[simp]\ntheorem allPerm_deriv_nil' {\u03b2 : TypeIndex}\n    (\u03c1 : AllPerm \u03b2) :\n    \u03c1 \u21d8 (.nil : \u03b2 \u219d \u03b2) = \u03c1 ", "theoremName": "ConNF.allPerm_deriv_nil'", "fileCreated": {"commit": "6fdc87c6b30b73931407a372f1430ecf0fef7601", "date": "2024-12-03"}, "theoremCreated": {"commit": "75a59b81a56dda9d4494ecfa54a8354c680a0c7c", "date": "2024-12-01"}, "file": "ConNF/ConNF/Model/TTT.lean", "module": "ConNF.Model.TTT", "jsonFile": "ConNF.Model.TTT.jsonl", "positionMetadata": {"lineInFile": 42, "tokenPositionInFile": 1169, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 8, "numPremises": 10}, "proofMetadata": {"hasProof": true, "proof": ":=\n  rfl", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 8}}
{"srcContext": "import ConNF.Model.Result\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal ConNF.TSet\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\ndef union (x y : TSet \u03b1) : TSet \u03b1 :=\n  (x\u1d9c' \u2293' y\u1d9c')\u1d9c'\n\nnotation:68 x:68 \" \u2294[\" h \"] \" y:68 => _root_.ConNF.union h x y\nnotation:68 x:68 \" \u2294' \" y:68 => x \u2294[by assumption] y\n\n@[simp]\ntheorem mem_union_iff (x y : TSet \u03b1) :\n    \u2200 z : TSet \u03b2, z \u2208' x \u2294' y \u2194 z \u2208' x \u2228 z \u2208' y := by\n  rw [union]\n  intro z\n  rw [mem_compl_iff, mem_inter_iff, mem_compl_iff, mem_compl_iff, or_iff_not_and_not]\n\ndef higherIndex (\u03b1 : \u039b) : \u039b :=\n  (exists_gt \u03b1).choose\n\ntheorem lt_higherIndex {\u03b1 : \u039b} :\n    (\u03b1 : TypeIndex) < higherIndex \u03b1 :=\n  WithBot.coe_lt_coe.mpr (exists_gt \u03b1).choose_spec\n\ntheorem tSet_nonempty (h : \u2203 \u03b2 : \u039b, (\u03b2 : TypeIndex) < \u03b1) : Nonempty (TSet \u03b1) := by\n  obtain \u27e8\u03b1', h\u03b1\u27e9 := h\n  constructor\n  apply typeLower lt_higherIndex lt_higherIndex lt_higherIndex h\u03b1\n  apply cardinalOne lt_higherIndex lt_higherIndex\n\ndef empty : TSet \u03b1 :=\n  (tSet_nonempty \u27e8\u03b2, h\u03b2\u27e9).some \u2293' (tSet_nonempty \u27e8\u03b2, h\u03b2\u27e9).some\u1d9c'\n\n@[simp]\ntheorem mem_empty_iff :\n    \u2200 x : TSet \u03b2, \u00acx \u2208' empty h\u03b2 := by\n  intro x\n  rw [empty, mem_inter_iff, mem_compl_iff]\n  exact and_not_self\n\ndef univ : TSet \u03b1 :=\n  (empty h\u03b2)\u1d9c'\n\n@[simp]\ntheorem mem_univ_iff :\n    \u2200 x : TSet \u03b2, x \u2208' univ h\u03b2 := by\n  intro x\n  simp only [univ, mem_compl_iff, mem_empty_iff, not_false_eq_true]\n\n/-- The set of all ordered pairs. -/\ndef orderedPairs : TSet \u03b1 :=\n  vCross h\u03b2 h\u03b3 h\u03b4 (univ h\u03b4)\n\n", "theoremStatement": "@[simp]\ntheorem mem_orderedPairs_iff (x : TSet \u03b2) :\n    x \u2208' orderedPairs h\u03b2 h\u03b3 h\u03b4 \u2194 \u2203 a b, x = \u27e8a, b\u27e9' ", "theoremName": "ConNF.mem_orderedPairs_iff", "fileCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "theoremCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "file": "ConNF/ConNF/External/Basic.lean", "module": "ConNF.External.Basic", "jsonFile": "ConNF.External.Basic.jsonl", "positionMetadata": {"lineInFile": 72, "tokenPositionInFile": 1691, "theoremPositionInFile": 12}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 15, "numPremises": 38}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp only [orderedPairs, vCross_spec, mem_univ_iff, and_true]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 69}}
{"srcContext": "import ConNF.ModelData.PathEnumeration\n\n/-!\n# Supports\n\nIn this file, we define the notion of a support.\n\n## Main declarations\n\n* `ConNF.BaseSupport`: The type of supports of atoms.\n* `ConNF.Support`: The type of supports of objects of arbitrary type indices.\n-/\n\nuniverse u\n\nopen Cardinal\n\nnamespace ConNF\n\nvariable [Params.{u}]\n\n/-!\n## Base supports\n-/\n\nstructure BaseSupport where\n  atoms : Enumeration Atom\n  nearLitters : Enumeration NearLitter\n\nnamespace BaseSupport\n\ninstance : SuperA BaseSupport (Enumeration Atom) where\n  superA := atoms\n\ninstance : SuperN BaseSupport (Enumeration NearLitter) where\n  superN := nearLitters\n\n@[simp]\ntheorem mk_atoms {a : Enumeration Atom} {N : Enumeration NearLitter} :\n    (BaseSupport.mk a N)\u1d2c = a :=\n  rfl\n\n@[simp]\ntheorem mk_nearLitters {a : Enumeration Atom} {N : Enumeration NearLitter} :\n    (BaseSupport.mk a N)\u1d3a = N :=\n  rfl\n\ntheorem atoms_congr {S T : BaseSupport} (h : S = T) :\n    S\u1d2c = T\u1d2c :=\n  h \u25b8 rfl\n\ntheorem nearLitters_congr {S T : BaseSupport} (h : S = T) :\n    S\u1d3a = T\u1d3a :=\n  h \u25b8 rfl\n\n@[ext]\ntheorem ext {S T : BaseSupport} (h\u2081 : S\u1d2c = T\u1d2c) (h\u2082 : S\u1d3a = T\u1d3a) : S = T := by\n  obtain \u27e8SA, SN\u27e9 := S\n  obtain \u27e8TA, TN\u27e9 := T\n  cases h\u2081\n  cases h\u2082\n  rfl\n\ninstance : SMul BasePerm BaseSupport where\n  smul \u03c0 S := \u27e8\u03c0 \u2022 S\u1d2c, \u03c0 \u2022 S\u1d3a\u27e9\n\n@[simp]\ntheorem smul_atoms (\u03c0 : BasePerm) (S : BaseSupport) :\n    (\u03c0 \u2022 S)\u1d2c = \u03c0 \u2022 S\u1d2c :=\n  rfl\n\n@[simp]\ntheorem smul_nearLitters (\u03c0 : BasePerm) (S : BaseSupport) :\n    (\u03c0 \u2022 S)\u1d3a = \u03c0 \u2022 S\u1d3a :=\n  rfl\n\n@[simp]\ntheorem smul_atoms_eq_of_smul_eq {\u03c0 : BasePerm} {S : BaseSupport}\n    (h : \u03c0 \u2022 S = S) :\n    \u03c0 \u2022 S\u1d2c = S\u1d2c := by\n  rw [\u2190 smul_atoms, h]\n\n@[simp]\ntheorem smul_nearLitters_eq_of_smul_eq {\u03c0 : BasePerm} {S : BaseSupport}\n    (h : \u03c0 \u2022 S = S) :\n    \u03c0 \u2022 S\u1d3a = S\u1d3a := by\n  rw [\u2190 smul_nearLitters, h]\n\ninstance : MulAction BasePerm BaseSupport where\n  one_smul S := by\n    apply ext\n    \u00b7 rw [smul_atoms, one_smul]\n    \u00b7 rw [smul_nearLitters, one_smul]\n  mul_smul \u03c0\u2081 \u03c0\u2082 S := by\n    apply ext\n    \u00b7 rw [smul_atoms, smul_atoms, smul_atoms, mul_smul]\n    \u00b7 rw [smul_nearLitters, smul_nearLitters, smul_nearLitters, mul_smul]\n\ntheorem smul_eq_smul_iff (\u03c0\u2081 \u03c0\u2082 : BasePerm) (S : BaseSupport) :\n    \u03c0\u2081 \u2022 S = \u03c0\u2082 \u2022 S \u2194 (\u2200 a \u2208 S\u1d2c, \u03c0\u2081 \u2022 a = \u03c0\u2082 \u2022 a) \u2227 (\u2200 N \u2208 S\u1d3a, \u03c0\u2081 \u2022 N = \u03c0\u2082 \u2022 N) := by\n  constructor\n  \u00b7 intro h\n    constructor\n    \u00b7 rintro a \u27e8i, ha\u27e9\n      have := congr_arg (\u00b7\u1d2c.rel i (\u03c0\u2081 \u2022 a)) h\n      simp only [smul_atoms, Enumeration.smul_rel, inv_smul_smul, eq_iff_iff] at this\n      have := S\u1d2c.rel_coinjective.coinjective ha (this.mp ha)\n      rw [eq_inv_smul_iff] at this\n      rw [this]\n    \u00b7 rintro N \u27e8i, hN\u27e9\n      have := congr_arg (\u00b7\u1d3a.rel i (\u03c0\u2081 \u2022 N)) h\n      simp only [smul_nearLitters, Enumeration.smul_rel, inv_smul_smul, eq_iff_iff] at this\n      have := S\u1d3a.rel_coinjective.coinjective hN (this.mp hN)\n      rw [eq_inv_smul_iff] at this\n      rw [this]\n  \u00b7 intro h\n    ext : 2\n    \u00b7 rfl\n    \u00b7 ext i a : 3\n      rw [smul_atoms, smul_atoms, Enumeration.smul_rel, Enumeration.smul_rel]\n      constructor\n      \u00b7 intro ha\n        have := h.1 _ \u27e8i, ha\u27e9\n        rw [smul_inv_smul, \u2190 inv_smul_eq_iff] at this\n        rwa [this]\n      \u00b7 intro ha\n        have := h.1 _ \u27e8i, ha\u27e9\n        rw [smul_inv_smul, smul_eq_iff_eq_inv_smul] at this\n        rwa [\u2190 this]\n    \u00b7 rfl\n    \u00b7 ext i a : 3\n      rw [smul_nearLitters, smul_nearLitters, Enumeration.smul_rel, Enumeration.smul_rel]\n      constructor\n      \u00b7 intro hN\n        have := h.2 _ \u27e8i, hN\u27e9\n        rw [smul_inv_smul, \u2190 inv_smul_eq_iff] at this\n        rwa [this]\n      \u00b7 intro hN\n        have := h.2 _ \u27e8i, hN\u27e9\n        rw [smul_inv_smul, smul_eq_iff_eq_inv_smul] at this\n        rwa [\u2190 this]\n\ntheorem smul_eq_iff (\u03c0 : BasePerm) (S : BaseSupport) :\n    \u03c0 \u2022 S = S \u2194 (\u2200 a \u2208 S\u1d2c, \u03c0 \u2022 a = a) \u2227 (\u2200 N \u2208 S\u1d3a, \u03c0 \u2022 N = N) := by\n  have := smul_eq_smul_iff \u03c0 1 S\n  simp only [one_smul] at this\n  exact this\n\nnoncomputable instance : Add BaseSupport where\n  add S T := \u27e8S\u1d2c + T\u1d2c, S\u1d3a + T\u1d3a\u27e9\n\n@[simp]\ntheorem add_atoms (S T : BaseSupport) :\n    (S + T)\u1d2c = S\u1d2c + T\u1d2c :=\n  rfl\n\n@[simp]\ntheorem add_nearLitters (S T : BaseSupport) :\n    (S + T)\u1d3a = S\u1d3a + T\u1d3a :=\n  rfl\n\nend BaseSupport\n\ndef baseSupportEquiv : BaseSupport \u2243 Enumeration Atom \u00d7 Enumeration NearLitter where\n  toFun S := (S\u1d2c, S\u1d3a)\n  invFun S := \u27e8S.1, S.2\u27e9\n  left_inv _ := rfl\n  right_inv _ := rfl\n\ntheorem card_baseSupport : #BaseSupport = #\u03bc := by\n  rw [Cardinal.eq.mpr \u27e8baseSupportEquiv\u27e9, mk_prod, lift_id, lift_id,\n    card_enumeration_eq card_atom, card_enumeration_eq card_nearLitter, mul_eq_self aleph0_lt_\u03bc.le]\n\n/-!\n## Structural supports\n-/\n\nstructure Support (\u03b1 : TypeIndex) where\n  atoms : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)\n  nearLitters : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)\n\nnamespace Support\n\nvariable {\u03b1 \u03b2 : TypeIndex}\n\ninstance : SuperA (Support \u03b1) (Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) where\n  superA := atoms\n\ninstance : SuperN (Support \u03b1) (Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) where\n  superN := nearLitters\n\n@[simp]\ntheorem mk_atoms (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) (F : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) :\n    (\u27e8E, F\u27e9 : Support \u03b1)\u1d2c = E :=\n  rfl\n\n@[simp]\ntheorem mk_nearLitters (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) (F : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) :\n    (\u27e8E, F\u27e9 : Support \u03b1)\u1d3a = F :=\n  rfl\n\ninstance : Derivative (Support \u03b1) (Support \u03b2) \u03b1 \u03b2 where\n  deriv S A := \u27e8S\u1d2c \u21d8 A, S\u1d3a \u21d8 A\u27e9\n\ninstance : Coderivative (Support \u03b2) (Support \u03b1) \u03b1 \u03b2 where\n  coderiv S A := \u27e8S\u1d2c \u21d7 A, S\u1d3a \u21d7 A\u27e9\n\ninstance : BotDerivative (Support \u03b1) BaseSupport \u03b1 where\n  botDeriv S A := \u27e8S\u1d2c \u21d8. A, S\u1d3a \u21d8. A\u27e9\n  botSderiv S := \u27e8S\u1d2c \u2198., S\u1d3a \u2198.\u27e9\n  botDeriv_single S h := by dsimp only; rw [botDeriv_single, botDeriv_single]\n\n@[simp]\ntheorem deriv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u03b2) :\n    S\u1d2c \u21d8 A = (S \u21d8 A)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem deriv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u03b2) :\n    S\u1d3a \u21d8 A = (S \u21d8 A)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem sderiv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (h : \u03b2 < \u03b1) :\n    S\u1d2c \u2198 h = (S \u2198 h)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem sderiv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (h : \u03b2 < \u03b1) :\n    S\u1d3a \u2198 h = (S \u2198 h)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem coderiv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    S\u1d2c \u21d7 A = (S \u21d7 A)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem coderiv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    S\u1d3a \u21d7 A = (S \u21d7 A)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem scoderiv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (h : \u03b2 < \u03b1) :\n    S\u1d2c \u2197 h = (S \u2197 h)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem scoderiv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (h : \u03b2 < \u03b1) :\n    S\u1d3a \u2197 h = (S \u2197 h)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem derivBot_atoms {\u03b1 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u22a5) :\n    S\u1d2c \u21d8. A = (S \u21d8. A)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem derivBot_nearLitters {\u03b1 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u22a5) :\n    S\u1d3a \u21d8. A = (S \u21d8. A)\u1d3a :=\n  rfl\n\ntheorem ext' {S T : Support \u03b1} (h\u2081 : S\u1d2c = T\u1d2c) (h\u2082 : S\u1d3a = T\u1d3a) : S = T := by\n  obtain \u27e8SA, SN\u27e9 := S\n  obtain \u27e8TA, TN\u27e9 := T\n  cases h\u2081\n  cases h\u2082\n  rfl\n\n@[ext]\ntheorem ext {S T : Support \u03b1} (h : \u2200 A, S \u21d8. A = T \u21d8. A) : S = T := by\n  obtain \u27e8SA, SN\u27e9 := S\n  obtain \u27e8TA, TN\u27e9 := T\n  rw [mk.injEq]\n  constructor\n  \u00b7 apply Enumeration.ext_path\n    intro A\n    exact BaseSupport.atoms_congr (h A)\n  \u00b7 apply Enumeration.ext_path\n    intro A\n    exact BaseSupport.nearLitters_congr (h A)\n\n@[simp]\ntheorem deriv_derivBot {\u03b1 : TypeIndex} (S : Support \u03b1)\n    (A : \u03b1 \u219d \u03b2) (B : \u03b2 \u219d \u22a5) :\n    S \u21d8 A \u21d8. B = S \u21d8. (A \u21d8 B) :=\n  rfl\n\n@[simp]\ntheorem coderiv_deriv_eq {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    S \u21d7 A \u21d8 A = S :=\n  ext' (S\u1d2c.coderiv_deriv_eq A) (S\u1d3a.coderiv_deriv_eq A)\n\ntheorem eq_of_atom_mem_scoderiv_botDeriv {\u03b1 \u03b2 : TypeIndex} {S : Support \u03b2} {A : \u03b1 \u219d \u22a5}\n    {h : \u03b2 < \u03b1} {a : Atom} (ha : a \u2208 (S \u2197 h \u21d8. A)\u1d2c) :\n    \u2203 B : \u03b2 \u219d \u22a5, A = B \u2197 h :=\n  Enumeration.eq_of_mem_scoderiv_botDeriv ha\n\ntheorem eq_of_nearLitter_mem_scoderiv_botDeriv {\u03b1 \u03b2 : TypeIndex} {S : Support \u03b2} {A : \u03b1 \u219d \u22a5}\n    {h : \u03b2 < \u03b1} {N : NearLitter} (hN : N \u2208 (S \u2197 h \u21d8. A)\u1d3a) :\n    \u2203 B : \u03b2 \u219d \u22a5, A = B \u2197 h :=\n  Enumeration.eq_of_mem_scoderiv_botDeriv hN\n\n", "theoremStatement": "@[simp]\ntheorem scoderiv_botDeriv_eq {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (A : \u03b2 \u219d \u22a5) (h : \u03b2 < \u03b1) :\n    S \u2197 h \u21d8. (A \u2197 h) = S \u21d8. A ", "theoremName": "ConNF.Support.scoderiv_botDeriv_eq", "fileCreated": {"commit": "39c33b4a743bea62dbcc549548b712ffd38ca65c", "date": "2024-12-05"}, "theoremCreated": {"commit": "ce890707e37ede74a2fcd66134d3f403335c5cc1", "date": "2024-11-30"}, "file": "ConNF/ConNF/ModelData/Support.lean", "module": "ConNF.ModelData.Support", "jsonFile": "ConNF.ModelData.Support.jsonl", "positionMetadata": {"lineInFile": 304, "tokenPositionInFile": 7860, "theoremPositionInFile": 32}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 7, "repositoryPremises": true, "numRepositoryPremises": 23, "numPremises": 35}, "proofMetadata": {"hasProof": true, "proof": ":=\n  BaseSupport.ext (Enumeration.scoderiv_botDeriv_eq _ _ _) (Enumeration.scoderiv_botDeriv_eq _ _ _)", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 102}}
{"srcContext": "import ConNF.Model.Externalise\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b2 \u03b3 : \u039b} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n\nnamespace Support\n\ntheorem not_mem_scoderiv_botDeriv (S : Support \u03b3) (N : NearLitter) :\n    N \u2209 (S \u2197 h\u03b3 \u21d8. (Path.nil \u2198.))\u1d3a := by\n  rintro \u27e8i, \u27e8A, N'\u27e9, h\u2081, h\u2082\u27e9\n  simp only [Prod.mk.injEq] at h\u2082\n  cases A\n  case sderiv \u03b4 A h\u03b4 _ =>\n    simp only [Path.deriv_sderiv] at h\u2082\n    cases A\n    case nil => cases h\u2082.1\n    case sderiv \u03b6 A h\u03b6 _ =>\n      simp only [Path.deriv_sderiv] at h\u2082\n      cases h\u2082.1\n\nvariable [Level] [LtLevel \u03b2]\n\ntheorem not_mem_strong_botDeriv (S : Support \u03b3) (N : NearLitter) :\n    N \u2209 ((S \u2197 h\u03b3).strong \u21d8. (Path.nil \u2198.))\u1d3a := by\n  rintro h\n  rw [strong, close_nearLitters, preStrong_nearLitters, Enumeration.mem_add_iff] at h\n  obtain h | h := h\n  \u00b7 exact not_mem_scoderiv_botDeriv S N h\n  \u00b7 rw [mem_constrainsNearLitters_nearLitters] at h\n    obtain \u27e8B, N', hN', h\u27e9 := h\n    cases h using Relation.ReflTransGen.head_induction_on\n    case refl => exact not_mem_scoderiv_botDeriv S N hN'\n    case head x hx\u2081 hx\u2082 _ =>\n      obtain \u27e8\u27e8\u03b3, \u03b4, \u03b5, h\u03b4, h\u03b5, h\u03b4\u03b5, A\u27e9, t, B, hB, hN, ht\u27e9 := hx\u2082\n      simp only at hB\n      cases B\n      case nil =>\n        cases hB\n        obtain \u27e8C, N''\u27e9 := x\n        simp only at ht\n        cases ht.1\n        change _ \u2208 t.support\u1d3a at hN\n        rw [t.support_supports.2 rfl] at hN\n        obtain \u27e8i, hN\u27e9 := hN\n        cases hN\n      case sderiv \u03b4 B h\u03b4 _ _ =>\n        cases B\n        case nil => cases hB\n        case sderiv \u03b6 B h\u03b6 _ _ => cases hB\n\ntheorem raise_preStrong' (S : Support \u03b1) (hS : S.Strong) (T : Support \u03b3) (\u03c1 : AllPerm \u03b2)\n    (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2) :\n    (S + (\u03c1\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim).PreStrong := by\n  apply hS.toPreStrong.add\n  constructor\n  intro A N hN P t hA ht\n  obtain \u27e8A, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv hN\n  simp only [scoderiv_botDeriv_eq, add_derivBot, smul_derivBot,\n    BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters, interferenceSupport_nearLitters,\n    Enumeration.mem_add_iff, Enumeration.mem_smul, Enumeration.not_mem_empty, or_false] at hN\n  obtain \u27e8\u03b4, \u03b5, \u03b6, h\u03b5, h\u03b6, h\u03b5\u03b6, B\u27e9 := P\n  dsimp only at *\n  cases A\n  case sderiv \u03b6' A h\u03b6' _ =>\n    rw [\u2190 Path.coderiv_deriv] at hA\n    cases Path.sderiv_index_injective hA\n    apply Path.sderiv_left_inj.mp at hA\n    cases A\n    case nil =>\n      cases hA\n      cases not_mem_strong_botDeriv T _ hN\n    case sderiv \u03b9 A h\u03b9 _ _ =>\n      rw [\u2190 Path.coderiv_deriv] at hA\n      cases Path.sderiv_index_injective hA\n      cases hA\n      haveI : LtLevel \u03b4 := \u27e8A.le.trans_lt LtLevel.elim\u27e9\n      haveI : LtLevel \u03b5 := \u27e8h\u03b5.trans LtLevel.elim\u27e9\n      haveI : LtLevel \u03b6 := \u27e8h\u03b6.trans LtLevel.elim\u27e9\n      have := (T \u2197 h\u03b3).strong_strong.support_le hN \u27e8\u03b4, \u03b5, \u03b6, h\u03b5, h\u03b6, h\u03b5\u03b6, A\u27e9\n          (\u03c1\u207b\u00b9 \u21d8 A \u2198 h\u03b5 \u2022 t) rfl ?_\n      \u00b7 simp only [Tangle.smul_support, allPermSderiv_forget, allPermDeriv_forget,\n          allPermForget_inv, Tree.inv_deriv, Tree.inv_sderiv] at this\n        have := smul_le_smul this (\u03c1\u1d41 \u21d8 A \u2198 h\u03b5)\n        simp only [smul_inv_smul] at this\n        apply le_trans this\n        intro B\n        constructor\n        \u00b7 intro a ha\n          simp only [smul_derivBot, Tree.sderiv_apply, Tree.deriv_apply, Path.deriv_scoderiv,\n            deriv_derivBot, Enumeration.mem_smul] at ha\n          rw [deriv_derivBot, \u2190 Path.deriv_scoderiv, Path.coderiv_deriv', scoderiv_botDeriv_eq,]\n          simp only [Path.deriv_scoderiv, add_derivBot, smul_derivBot,\n            BaseSupport.add_atoms, BaseSupport.smul_atoms, Enumeration.mem_add_iff,\n            Enumeration.mem_smul]\n          exact Or.inl ha\n        \u00b7 intro N hN\n          simp only [smul_derivBot, Tree.sderiv_apply, Tree.deriv_apply, Path.deriv_scoderiv,\n            deriv_derivBot, Enumeration.mem_smul] at hN\n          rw [deriv_derivBot, \u2190 Path.deriv_scoderiv, Path.coderiv_deriv', scoderiv_botDeriv_eq,]\n          simp only [Path.deriv_scoderiv, add_derivBot, smul_derivBot,\n            BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters, Enumeration.mem_add_iff,\n            Enumeration.mem_smul]\n          exact Or.inl hN\n      \u00b7 rw [\u2190 smul_fuzz h\u03b5 h\u03b6 h\u03b5\u03b6, \u2190 ht]\n        simp only [Path.botSderiv_coe_eq, BasePerm.smul_nearLitter_litter, allPermDeriv_forget,\n          allPermForget_inv, Tree.inv_deriv, Tree.inv_sderiv, Tree.inv_sderivBot]\n        rfl\n\ntheorem raise_closed' (S : Support \u03b1) (hS : S.Strong) (T : Support \u03b3) (\u03c1 : AllPerm \u03b2)\n    (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n    (h\u03c1 : \u03c1\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim) :\n    (S + (\u03c1\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim).Closed := by\n  constructor\n  intro A\n  constructor\n  intro N\u2081 N\u2082 hN\u2081 hN\u2082 a ha\n  simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff,\n    BaseSupport.add_atoms] at hN\u2081 hN\u2082 \u22a2\n  obtain hN\u2081 | hN\u2081 := hN\u2081\n  \u00b7 obtain hN\u2082 | hN\u2082 := hN\u2082\n    \u00b7 exact Or.inl ((hS.closed A).interference_subset hN\u2081 hN\u2082 a ha)\n    \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv hN\u2082\n      simp only [smul_add, scoderiv_botDeriv_eq, add_derivBot, smul_derivBot,\n        BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters, Enumeration.mem_add_iff,\n        Enumeration.mem_smul, BaseSupport.add_atoms, BaseSupport.smul_atoms] at hN\u2081 hN\u2082 \u22a2\n      refine Or.inr (Or.inr ?_)\n      rw [mem_interferenceSupport_atoms]\n      refine \u27e8(\u03c1\u1d41 B)\u207b\u00b9 \u2022 N\u2081, ?_, (\u03c1\u1d41 B)\u207b\u00b9 \u2022 N\u2082, ?_, ?_\u27e9\n      \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n        rw [\u2190 Enumeration.mem_smul, \u2190 BaseSupport.smul_nearLitters, \u2190 smul_derivBot, h\u03c1]\n        exact Or.inl hN\u2081\n      \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n        simp only [interferenceSupport_nearLitters, Enumeration.not_mem_empty, or_false] at hN\u2082\n        exact Or.inr hN\u2082\n      \u00b7 rw [\u2190 BasePerm.smul_interference]\n        exact Set.smul_mem_smul_set ha\n  \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv hN\u2081\n    simp only [smul_add, scoderiv_botDeriv_eq, add_derivBot, smul_derivBot,\n      BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters, Enumeration.mem_add_iff,\n      Enumeration.mem_smul, BaseSupport.add_atoms, BaseSupport.smul_atoms] at hN\u2081 hN\u2082 \u22a2\n    refine Or.inr (Or.inr ?_)\n    rw [mem_interferenceSupport_atoms]\n    refine \u27e8(\u03c1\u1d41 B)\u207b\u00b9 \u2022 N\u2081, ?_, (\u03c1\u1d41 B)\u207b\u00b9 \u2022 N\u2082, ?_, ?_\u27e9\n    \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n      simp only [interferenceSupport_nearLitters, Enumeration.not_mem_empty, or_false] at hN\u2081\n      exact Or.inr hN\u2081\n    \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n      simp only [interferenceSupport_nearLitters, Enumeration.not_mem_empty, or_false] at hN\u2082\n      obtain hN\u2082 | hN\u2082 := hN\u2082\n      \u00b7 rw [\u2190 Enumeration.mem_smul, \u2190 BaseSupport.smul_nearLitters, \u2190 smul_derivBot, h\u03c1]\n        exact Or.inl hN\u2082\n      \u00b7 exact Or.inr hN\u2082\n    \u00b7 rw [\u2190 BasePerm.smul_interference]\n      exact Set.smul_mem_smul_set ha\n\ntheorem raise_strong' (S : Support \u03b1) (hS : S.Strong) (T : Support \u03b3) (\u03c1 : AllPerm \u03b2)\n    (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n    (h\u03c1 : \u03c1\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim) :\n    (S + (\u03c1\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim).Strong :=\n  \u27e8raise_preStrong' S hS T \u03c1 h\u03b3, raise_closed' S hS T \u03c1 h\u03b3 h\u03c1\u27e9\n\ntheorem convAtoms_injective_of_fixes {S : Support \u03b1} {T : Support \u03b3}\n    {\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n    (h\u03c1\u2081 : \u03c1\u2081\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (h\u03c1\u2082 : \u03c1\u2082\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (A : \u2191\u03b1 \u219d \u22a5) :\n    (convAtoms\n      (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong + (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197\n        LtLevel.elim)\n      (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong + (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197\n        LtLevel.elim) A).Injective := by\n  rw [Support.smul_eq_iff] at h\u03c1\u2081 h\u03c1\u2082\n  constructor\n  rintro a\u2081 a\u2082 a\u2083 \u27e8i, hi\u2081, hi\u2082\u27e9 \u27e8j, hj\u2081, hj\u2082\u27e9\n  simp only [add_derivBot, BaseSupport.add_atoms, Rel.inv_apply,\n    Enumeration.rel_add_iff] at hi\u2081 hi\u2082 hj\u2081 hj\u2082\n  obtain hi\u2081 | \u27e8i, rfl, hi\u2081\u27e9 := hi\u2081\n  \u00b7 obtain hi\u2082 | \u27e8i', rfl, _\u27e9 := hi\u2082\n    swap\n    \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hi\u2081\u27e9\n      simp only [add_lt_iff_neg_left] at this\n      cases (\u03ba_zero_le i').not_lt this\n    cases (Enumeration.rel_coinjective _).coinjective hi\u2081 hi\u2082\n    obtain hj\u2081 | \u27e8j, rfl, hj\u2081\u27e9 := hj\u2081\n    \u00b7 obtain hj\u2082 | \u27e8j', rfl, _\u27e9 := hj\u2082\n      \u00b7 exact (Enumeration.rel_coinjective _).coinjective hj\u2082 hj\u2081\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2081\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j').not_lt this\n    \u00b7 obtain hj\u2082 | hj\u2082 := hj\u2082\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2082\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j).not_lt this\n      \u00b7 simp only [add_right_inj, exists_eq_left] at hj\u2082\n        obtain \u27e8B, rfl\u27e9 := eq_of_atom_mem_scoderiv_botDeriv \u27e8j, hj\u2081\u27e9\n        simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_atoms,\n          BaseSupport.add_atoms, Enumeration.smul_rel, add_right_inj, exists_eq_left] at hj\u2081 hj\u2082\n        have := (Enumeration.rel_coinjective _).coinjective hj\u2081 hj\u2082\n        rw [\u2190 (h\u03c1\u2082 B).1 a\u2081 \u27e8_, hi\u2081\u27e9, inv_smul_smul, inv_smul_eq_iff, (h\u03c1\u2081 B).1 a\u2081 \u27e8_, hi\u2081\u27e9] at this\n        exact this.symm\n  \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_atom_mem_scoderiv_botDeriv \u27e8i, hi\u2081\u27e9\n    simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_atoms,\n      BaseSupport.add_atoms, Enumeration.smul_rel, add_right_inj, exists_eq_left] at hi\u2081 hi\u2082 hj\u2081 hj\u2082\n    obtain hi\u2082 | hi\u2082 := hi\u2082\n    \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hi\u2082\u27e9\n      simp only [add_lt_iff_neg_left] at this\n      cases (\u03ba_zero_le i).not_lt this\n    have hi := (Enumeration.rel_coinjective _).coinjective hi\u2081 hi\u2082\n    suffices hj : (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 a\u2082 = (\u03c1\u2082\u1d41 B)\u207b\u00b9 \u2022 a\u2083 by\n      rwa [\u2190 hj, smul_left_cancel_iff] at hi\n    obtain hj\u2081 | \u27e8j, rfl, hj\u2081\u27e9 := hj\u2081\n    \u00b7 obtain hj\u2082 | \u27e8j', rfl, _\u27e9 := hj\u2082\n      \u00b7 rw [\u2190 (h\u03c1\u2081 B).1 a\u2082 \u27e8_, hj\u2081\u27e9, \u2190 (h\u03c1\u2082 B).1 a\u2083 \u27e8_, hj\u2082\u27e9, inv_smul_smul, inv_smul_smul]\n        exact (Enumeration.rel_coinjective _).coinjective hj\u2081 hj\u2082\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2081\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j').not_lt this\n    \u00b7 obtain hj\u2082 | hj\u2082 := hj\u2082\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2082\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j).not_lt this\n      \u00b7 simp only [add_right_inj, exists_eq_left] at hj\u2082\n        exact (Enumeration.rel_coinjective _).coinjective hj\u2081 hj\u2082\n\ntheorem atomMemRel_le_of_fixes {S : Support \u03b1} {T : Support \u03b3}\n    {\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n    (h\u03c1\u2081 : \u03c1\u2081\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (h\u03c1\u2082 : \u03c1\u2082\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (A : \u2191\u03b1 \u219d \u22a5) :\n    atomMemRel (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A \u2264\n    atomMemRel (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A := by\n  rw [Support.smul_eq_iff] at h\u03c1\u2081 h\u03c1\u2082\n  rintro i j \u27e8N, hN, a, haN, ha\u27e9\n  simp only [add_derivBot, BaseSupport.add_atoms, Rel.inv_apply, Enumeration.rel_add_iff,\n    BaseSupport.add_nearLitters] at ha hN\n  obtain hN | \u27e8i, rfl, hi\u27e9 := hN\n  \u00b7 obtain ha | \u27e8j, rfl, hj\u27e9 := ha\n    \u00b7 exact \u27e8N, Or.inl hN, a, haN, Or.inl ha\u27e9\n    \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_atom_mem_scoderiv_botDeriv \u27e8j, hj\u27e9\n      simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_atoms,\n        BaseSupport.add_atoms, Enumeration.smul_rel] at hj hN\n      refine \u27e8N, Or.inl hN, \u03c1\u2082\u1d41 B \u2022 (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 a, ?_, ?_\u27e9\n      \u00b7 dsimp only\n        rw [\u2190 (h\u03c1\u2082 B).2 N \u27e8_, hN\u27e9, BasePerm.smul_nearLitter_atoms, Set.smul_mem_smul_set_iff]\n        have := (h\u03c1\u2081 B).2 N \u27e8_, hN\u27e9\n        rw [smul_eq_iff_eq_inv_smul] at this\n        rwa [this, BasePerm.smul_nearLitter_atoms, Set.smul_mem_smul_set_iff]\n      \u00b7 rw [Rel.inv_apply, add_derivBot, BaseSupport.add_atoms, Enumeration.rel_add_iff]\n        simp only [add_right_inj, scoderiv_botDeriv_eq, smul_derivBot, add_derivBot,\n          BaseSupport.smul_atoms, BaseSupport.add_atoms, Enumeration.smul_rel, inv_smul_smul,\n          exists_eq_left]\n        exact Or.inr hj\n  \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv \u27e8i, hi\u27e9\n    simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_atoms,\n      BaseSupport.add_atoms, Enumeration.smul_rel] at hi ha\n    obtain ha | \u27e8j, rfl, hj\u27e9 := ha\n    \u00b7 refine \u27e8\u03c1\u2082\u1d41 B \u2022 (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 N, ?_, a, ?_, Or.inl ha\u27e9\n      \u00b7 rw [add_derivBot, BaseSupport.add_nearLitters, Enumeration.rel_add_iff]\n        simp only [add_right_inj, scoderiv_botDeriv_eq, smul_derivBot, add_derivBot,\n          BaseSupport.smul_nearLitters, BaseSupport.add_nearLitters, Enumeration.smul_rel,\n          inv_smul_smul, exists_eq_left]\n        exact Or.inr hi\n      \u00b7 dsimp only\n        rw [\u2190 (h\u03c1\u2082 B).1 a \u27e8_, ha\u27e9, BasePerm.smul_nearLitter_atoms, Set.smul_mem_smul_set_iff]\n        have := (h\u03c1\u2081 B).1 a \u27e8_, ha\u27e9\n        rw [smul_eq_iff_eq_inv_smul] at this\n        rwa [this, BasePerm.smul_nearLitter_atoms, Set.smul_mem_smul_set_iff]\n    \u00b7 refine \u27e8\u03c1\u2082\u1d41 B \u2022 (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 N, ?_, \u03c1\u2082\u1d41 B \u2022 (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 a, ?_, ?_\u27e9\n      \u00b7 rw [add_derivBot, BaseSupport.add_nearLitters, Enumeration.rel_add_iff]\n        simp only [add_right_inj, scoderiv_botDeriv_eq, smul_derivBot, add_derivBot,\n          BaseSupport.smul_nearLitters, BaseSupport.add_nearLitters, Enumeration.smul_rel,\n          inv_smul_smul, exists_eq_left]\n        exact Or.inr hi\n      \u00b7 simp only [BasePerm.smul_nearLitter_atoms, Set.smul_mem_smul_set_iff]\n        exact haN\n      \u00b7 rw [Rel.inv_apply, add_derivBot, BaseSupport.add_atoms, Enumeration.rel_add_iff]\n        simp only [add_right_inj, scoderiv_botDeriv_eq, smul_derivBot, add_derivBot,\n          BaseSupport.smul_atoms, BaseSupport.add_atoms, Enumeration.smul_rel, inv_smul_smul,\n          exists_eq_left]\n        exact Or.inr hj\n\ntheorem convNearLitters_cases {S : Support \u03b1} {T : Support \u03b3}\n    {\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n    {A : \u03b1 \u219d \u22a5} {N\u2081 N\u2082 : NearLitter} :\n  convNearLitters\n    (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim)\n    (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A N\u2081 N\u2082 \u2192\n    N\u2081 = N\u2082 \u2227 N\u2081 \u2208 (S \u21d8. A)\u1d3a \u2228\n    \u2203 B : \u03b2 \u219d \u22a5, A = B \u2197 LtLevel.elim \u2227 (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 N\u2081 = (\u03c1\u2082\u1d41 B)\u207b\u00b9 \u2022 N\u2082 \u2227\n      (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 N\u2081 \u2208 (((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport) \u21d8. B)\u1d3a := by\n  rintro \u27e8i, hN\u2081, hN\u2082\u27e9\n  simp only [add_derivBot, BaseSupport.add_nearLitters, Rel.inv_apply,\n    Enumeration.rel_add_iff] at hN\u2081 hN\u2082\n  obtain hN\u2081 | \u27e8i, rfl, hN\u2081\u27e9 := hN\u2081\n  \u00b7 obtain hN\u2082 | \u27e8i, rfl, hN\u2082\u27e9 := hN\u2082\n    swap\n    \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hN\u2081\u27e9\n      simp only [add_lt_iff_neg_left] at this\n      cases (\u03ba_zero_le i).not_lt this\n    exact Or.inl \u27e8(Enumeration.rel_coinjective _).coinjective hN\u2081 hN\u2082, _, hN\u2081\u27e9\n  \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv \u27e8i, hN\u2081\u27e9\n    simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_nearLitters,\n      BaseSupport.add_nearLitters, Enumeration.smul_rel, add_right_inj, exists_eq_left] at hN\u2081 hN\u2082\n    obtain hN\u2082 | hN\u2082 := hN\u2082\n    \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hN\u2082\u27e9\n      simp only [add_lt_iff_neg_left] at this\n      cases (\u03ba_zero_le i).not_lt this\n    exact Or.inr \u27e8B, rfl, (Enumeration.rel_coinjective _).coinjective hN\u2081 hN\u2082, _, hN\u2081\u27e9\n\ntheorem inflexible_of_inflexible_of_fixes {S : Support \u03b1} {T : Support \u03b3}\n    {\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n    (h\u03c1\u2081 : \u03c1\u2081\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (h\u03c1\u2082 : \u03c1\u2082\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    {A : \u03b1 \u219d \u22a5} {N\u2081 N\u2082 : NearLitter} :\n    convNearLitters\n      (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim)\n      (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A N\u2081 N\u2082 \u2192\n      \u2200 (P : InflexiblePath \u2191\u03b1) (t : Tangle P.\u03b4), A = P.A \u2198 P.h\u03b5 \u2198. \u2192 N\u2081\u1d38 = fuzz P.h\u03b4\u03b5 t \u2192\n      \u2203 \u03c1 : AllPerm P.\u03b4, N\u2082\u1d38 = fuzz P.h\u03b4\u03b5 (\u03c1 \u2022 t) := by\n  rintro hN \u27e8\u03b3, \u03b4, \u03b5, h\u03b4, h\u03b5, h\u03b4\u03b5, A\u27e9 t hA ht\n  haveI : LeLevel \u03b3 := \u27e8A.le\u27e9\n  haveI : LtLevel \u03b4 := \u27e8h\u03b4.trans_le LeLevel.elim\u27e9\n  haveI : LtLevel \u03b5 := \u27e8h\u03b5.trans_le LeLevel.elim\u27e9\n  obtain \u27e8rfl, _\u27e9 | \u27e8B, rfl, hN'\u27e9 := convNearLitters_cases hN\n  \u00b7 use 1\n    rw [one_smul, ht]\n  \u00b7 clear hN\n    cases B\n    case sderiv \u03b5 B h\u03b5' _ =>\n      rw [\u2190 Path.coderiv_deriv] at hA\n      cases Path.sderiv_index_injective hA\n      apply Path.sderiv_path_injective at hA\n      cases B\n      case nil =>\n        simp only [Path.botSderiv_coe_eq, add_derivBot, BaseSupport.add_nearLitters,\n          interferenceSupport_nearLitters, Enumeration.add_empty] at hN'\n        cases not_mem_strong_botDeriv _ _ hN'.2\n      case sderiv \u03b6 B h\u03b6 _ _ =>\n        rw [\u2190 Path.coderiv_deriv] at hA\n        cases Path.sderiv_index_injective hA\n        apply Path.sderiv_path_injective at hA\n        dsimp only at hA h\u03b6 h\u03b5' B t\n        cases hA\n        use (\u03c1\u2082 * \u03c1\u2081\u207b\u00b9) \u21d8 B \u2198 h\u03b4\n        rw [inv_smul_eq_iff] at hN'\n        rw [\u2190 smul_fuzz h\u03b4 h\u03b5 h\u03b4\u03b5, \u2190 ht, hN'.1]\n        simp only [allPermDeriv_forget, allPermForget_mul, allPermForget_inv, Tree.mul_deriv,\n          Tree.inv_deriv, Tree.mul_sderiv, Tree.inv_sderiv, Tree.mul_sderivBot, Tree.inv_sderivBot,\n          Path.botSderiv_coe_eq, BasePerm.smul_nearLitter_litter, mul_smul]\n        erw [inv_smul_smul, smul_inv_smul]\n\ntheorem atoms_of_inflexible_of_fixes {S : Support \u03b1} (hS : S.Strong) {T : Support \u03b3}\n    {\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n    (h\u03c1\u2081 : \u03c1\u2081\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (h\u03c1\u2082 : \u03c1\u2082\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (A : \u03b1 \u219d \u22a5) (N\u2081 N\u2082 : NearLitter) (P : InflexiblePath \u2191\u03b1) (t : Tangle P.\u03b4) (\u03c1 : AllPerm P.\u03b4) :\n    A = P.A \u2198 P.h\u03b5 \u2198. \u2192 N\u2081\u1d38 = fuzz P.h\u03b4\u03b5 t \u2192 N\u2082\u1d38 = fuzz P.h\u03b4\u03b5 (\u03c1 \u2022 t) \u2192\n    convNearLitters\n      (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim)\n      (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A N\u2081 N\u2082 \u2192\n    \u2200 (B : P.\u03b4 \u219d \u22a5), \u2200 a \u2208 (t.support \u21d8. B)\u1d2c, \u2200 (i : \u03ba),\n      ((S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong + (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197\n        LtLevel.elim) \u21d8. (P.A \u2198 P.h\u03b4 \u21d8 B))\u1d2c.rel i a \u2192\n      ((S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong + (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197\n        LtLevel.elim) \u21d8. (P.A \u2198 P.h\u03b4 \u21d8 B))\u1d2c.rel i (\u03c1\u1d41 B \u2022 a) := by\n  rw [Support.smul_eq_iff] at h\u03c1\u2081 h\u03c1\u2082\n  obtain \u27e8\u03b3, \u03b4, \u03b5, h\u03b4, h\u03b5, h\u03b4\u03b5, B\u27e9 := P\n  haveI : LeLevel \u03b3 := \u27e8B.le\u27e9\n  haveI : LtLevel \u03b4 := \u27e8h\u03b4.trans_le LeLevel.elim\u27e9\n  haveI : LtLevel \u03b5 := \u27e8h\u03b5.trans_le LeLevel.elim\u27e9\n  dsimp only at t \u03c1 \u22a2\n  intro hA hN\u2081 hN\u2082 hN C a ha i hi\n  obtain \u27e8rfl, hN'\u27e9 | \u27e8A, rfl, hN\u2081', hN\u2082'\u27e9 := convNearLitters_cases hN\n  \u00b7 have haS := (hS.support_le hN' \u27e8\u03b3, \u03b4, \u03b5, h\u03b4, h\u03b5, h\u03b4\u03b5, _\u27e9 t hA hN\u2081 _).1 a ha\n    rw [hN\u2082] at hN\u2081\n    have h\u03c1t := congr_arg Tangle.support (fuzz_injective hN\u2081)\n    rw [Tangle.smul_support, Support.smul_eq_iff] at h\u03c1t\n    simp only [add_derivBot, BaseSupport.add_atoms, Enumeration.rel_add_iff] at hi \u22a2\n    rw [(h\u03c1t C).1 a ha]\n    obtain hi | \u27e8i, rfl, hi\u27e9 := hi\n    \u00b7 exact Or.inl hi\n    \u00b7 simp only [add_right_inj, exists_eq_left]\n      obtain \u27e8D, hD\u27e9 := eq_of_atom_mem_scoderiv_botDeriv \u27e8i, hi\u27e9\n      cases B using Path.recScoderiv\n      case nil =>\n        cases Path.scoderiv_index_injective hD\n        cases Path.scoderiv_left_inj.mp hD\n        simp only [hD, Path.coderiv_deriv, Path.coderiv_deriv', scoderiv_botDeriv_eq, smul_derivBot,\n          add_derivBot, BaseSupport.smul_atoms, BaseSupport.add_atoms, Enumeration.smul_rel] at hi \u22a2\n        rw [deriv_derivBot, hD] at haS\n        rw [\u2190 (h\u03c1\u2082 _).1 a haS, inv_smul_smul]\n        rw [\u2190 (h\u03c1\u2081 _).1 a haS, inv_smul_smul] at hi\n        exact Or.inr hi\n      case scoderiv \u03b6 B h\u03b6' _ =>\n        rw [Path.coderiv_deriv, Path.coderiv_deriv'] at hD\n        cases Path.scoderiv_index_injective hD\n        rw [Path.scoderiv_left_inj] at hD\n        cases hD\n        simp only [Path.coderiv_deriv, Path.coderiv_deriv', scoderiv_botDeriv_eq, smul_derivBot,\n          add_derivBot, BaseSupport.smul_atoms, BaseSupport.add_atoms, Enumeration.smul_rel] at hi \u22a2\n        rw [deriv_derivBot, Path.coderiv_deriv, Path.coderiv_deriv'] at haS\n        rw [\u2190 (h\u03c1\u2082 _).1 a haS, inv_smul_smul]\n        rw [\u2190 (h\u03c1\u2081 _).1 a haS, inv_smul_smul] at hi\n        exact Or.inr hi\n  \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, interferenceSupport_nearLitters,\n      Enumeration.add_empty] at hN\u2082'\n    cases A\n    case sderiv \u03b6 A h\u03b6' _ =>\n      rw [\u2190 Path.coderiv_deriv] at hA\n      cases Path.sderiv_index_injective hA\n      apply Path.sderiv_path_injective at hA\n      cases A\n      case nil =>\n        cases hA\n        cases not_mem_strong_botDeriv _ _ hN\u2082'\n      case sderiv \u03b6 A h\u03b6 _ _ =>\n        rw [\u2190 Path.coderiv_deriv] at hA\n        cases Path.sderiv_index_injective hA\n        apply Path.sderiv_path_injective at hA\n        cases hA\n        simp only [Path.coderiv_deriv, Path.coderiv_deriv', add_derivBot, scoderiv_botDeriv_eq,\n          smul_derivBot, BaseSupport.add_atoms, BaseSupport.smul_atoms] at hi \u22a2\n        have : N\u2082\u1d38 = (\u03c1\u2082 \u21d8 A)\u1d41 \u2198 h\u03b6 \u2198. \u2022 (\u03c1\u2081\u207b\u00b9 \u21d8 A)\u1d41 \u2198 h\u03b6 \u2198. \u2022 fuzz h\u03b4\u03b5 t := by\n          rw [inv_smul_eq_iff] at hN\u2081'\n          rw [hN\u2081', Path.botSderiv_coe_eq, BasePerm.smul_nearLitter_litter,\n            BasePerm.smul_nearLitter_litter, smul_smul, smul_eq_iff_eq_inv_smul,\n            mul_inv_rev, inv_inv, mul_smul, \u2190 Tree.inv_apply, \u2190 allPermForget_inv] at hN\u2081\n          rw [hN\u2081]\n          simp only [allPermForget_inv, Tree.inv_apply, allPermDeriv_forget, Tree.inv_deriv,\n            Tree.inv_sderiv, Tree.inv_sderivBot]\n          rfl\n        rw [smul_fuzz h\u03b4 h\u03b5 h\u03b4\u03b5, smul_fuzz h\u03b4 h\u03b5 h\u03b4\u03b5] at this\n        have := fuzz_injective (hN\u2082.symm.trans this)\n        rw [smul_smul] at this\n        rw [t.smul_atom_eq_of_mem_support this ha]\n        rw [Enumeration.rel_add_iff] at hi \u22a2\n        obtain hi | \u27e8i, rfl, hi\u27e9 := hi\n        \u00b7 left\n          simp only [allPermForget_mul, allPermSderiv_forget, allPermDeriv_forget,\n            allPermForget_inv, Tree.inv_deriv, Tree.inv_sderiv, Tree.mul_apply, Tree.sderiv_apply,\n            Tree.deriv_apply, Path.deriv_scoderiv, Tree.inv_apply, mul_smul]\n          rwa [\u2190 (h\u03c1\u2081 _).1 a \u27e8i, hi\u27e9, inv_smul_smul, (h\u03c1\u2082 _).1 a \u27e8i, hi\u27e9]\n        \u00b7 refine Or.inr \u27e8i, rfl, ?_\u27e9\n          simp only [allPermForget_mul, allPermSderiv_forget, allPermDeriv_forget,\n            allPermForget_inv, Tree.inv_deriv, Tree.inv_sderiv, Tree.mul_apply, Tree.sderiv_apply,\n            Tree.deriv_apply, Path.deriv_scoderiv, Tree.inv_apply, mul_smul, Enumeration.smul_rel,\n            inv_smul_smul]\n          exact hi\n\ntheorem nearLitters_of_inflexible_of_fixes {S : Support \u03b1} (hS : S.Strong) {T : Support \u03b3}\n    {\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n    (h\u03c1\u2081 : \u03c1\u2081\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (h\u03c1\u2082 : \u03c1\u2082\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (A : \u03b1 \u219d \u22a5) (N\u2081 N\u2082 : NearLitter) (P : InflexiblePath \u2191\u03b1) (t : Tangle P.\u03b4) (\u03c1 : AllPerm P.\u03b4) :\n    A = P.A \u2198 P.h\u03b5 \u2198. \u2192 N\u2081\u1d38 = fuzz P.h\u03b4\u03b5 t \u2192 N\u2082\u1d38 = fuzz P.h\u03b4\u03b5 (\u03c1 \u2022 t) \u2192\n    convNearLitters\n      (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim)\n      (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A N\u2081 N\u2082 \u2192\n    \u2200 (B : P.\u03b4 \u219d \u22a5), \u2200 N \u2208 (t.support \u21d8. B)\u1d3a, \u2200 (i : \u03ba),\n      ((S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong + (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197\n        LtLevel.elim) \u21d8. (P.A \u2198 P.h\u03b4 \u21d8 B))\u1d3a.rel i N \u2192\n      ((S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong + (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197\n        LtLevel.elim) \u21d8. (P.A \u2198 P.h\u03b4 \u21d8 B))\u1d3a.rel i (\u03c1\u1d41 B \u2022 N) := by\n  rw [Support.smul_eq_iff] at h\u03c1\u2081 h\u03c1\u2082\n  obtain \u27e8\u03b3, \u03b4, \u03b5, h\u03b4, h\u03b5, h\u03b4\u03b5, B\u27e9 := P\n  haveI : LeLevel \u03b3 := \u27e8B.le\u27e9\n  haveI : LtLevel \u03b4 := \u27e8h\u03b4.trans_le LeLevel.elim\u27e9\n  haveI : LtLevel \u03b5 := \u27e8h\u03b5.trans_le LeLevel.elim\u27e9\n  dsimp only at t \u03c1 \u22a2\n  intro hA hN\u2081 hN\u2082 hN C N\u2080 hN\u2080 i hi\n  obtain \u27e8rfl, hN'\u27e9 | \u27e8A, rfl, hN\u2081', hN\u2082'\u27e9 := convNearLitters_cases hN\n  \u00b7 have haS := (hS.support_le hN' \u27e8\u03b3, \u03b4, \u03b5, h\u03b4, h\u03b5, h\u03b4\u03b5, _\u27e9 t hA hN\u2081 _).2 N\u2080 hN\u2080\n    rw [hN\u2082] at hN\u2081\n    have h\u03c1t := congr_arg Tangle.support (fuzz_injective hN\u2081)\n    rw [Tangle.smul_support, Support.smul_eq_iff] at h\u03c1t\n    simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.rel_add_iff] at hi \u22a2\n    rw [(h\u03c1t C).2 N\u2080 hN\u2080]\n    obtain hi | \u27e8i, rfl, hi\u27e9 := hi\n    \u00b7 exact Or.inl hi\n    \u00b7 simp only [add_right_inj, exists_eq_left]\n      obtain \u27e8D, hD\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv \u27e8i, hi\u27e9\n      cases B using Path.recScoderiv\n      case nil =>\n        cases Path.scoderiv_index_injective hD\n        cases Path.scoderiv_left_inj.mp hD\n        simp only [hD, Path.coderiv_deriv, Path.coderiv_deriv', scoderiv_botDeriv_eq, smul_derivBot,\n          add_derivBot, BaseSupport.smul_nearLitters, BaseSupport.add_nearLitters, Enumeration.smul_rel] at hi \u22a2\n        rw [deriv_derivBot, hD] at haS\n        rw [\u2190 (h\u03c1\u2082 _).2 N\u2080 haS, inv_smul_smul]\n        rw [\u2190 (h\u03c1\u2081 _).2 N\u2080 haS, inv_smul_smul] at hi\n        exact Or.inr hi\n      case scoderiv \u03b6 B h\u03b6' _ =>\n        rw [Path.coderiv_deriv, Path.coderiv_deriv'] at hD\n        cases Path.scoderiv_index_injective hD\n        rw [Path.scoderiv_left_inj] at hD\n        cases hD\n        simp only [Path.coderiv_deriv, Path.coderiv_deriv', scoderiv_botDeriv_eq, smul_derivBot,\n          add_derivBot, BaseSupport.smul_nearLitters, BaseSupport.add_nearLitters, Enumeration.smul_rel] at hi \u22a2\n        rw [deriv_derivBot, Path.coderiv_deriv, Path.coderiv_deriv'] at haS\n        rw [\u2190 (h\u03c1\u2082 _).2 N\u2080 haS, inv_smul_smul]\n        rw [\u2190 (h\u03c1\u2081 _).2 N\u2080 haS, inv_smul_smul] at hi\n        exact Or.inr hi\n  \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, interferenceSupport_nearLitters,\n      Enumeration.add_empty] at hN\u2082'\n    cases A\n    case sderiv \u03b6 A h\u03b6' _ =>\n      rw [\u2190 Path.coderiv_deriv] at hA\n      cases Path.sderiv_index_injective hA\n      apply Path.sderiv_path_injective at hA\n      cases A\n      case nil =>\n        cases hA\n        cases not_mem_strong_botDeriv _ _ hN\u2082'\n      case sderiv \u03b6 A h\u03b6 _ _ =>\n        rw [\u2190 Path.coderiv_deriv] at hA\n        cases Path.sderiv_index_injective hA\n        apply Path.sderiv_path_injective at hA\n        cases hA\n        simp only [Path.coderiv_deriv, Path.coderiv_deriv', add_derivBot, scoderiv_botDeriv_eq,\n          smul_derivBot, BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters] at hi \u22a2\n        have : N\u2082\u1d38 = (\u03c1\u2082 \u21d8 A)\u1d41 \u2198 h\u03b6 \u2198. \u2022 (\u03c1\u2081\u207b\u00b9 \u21d8 A)\u1d41 \u2198 h\u03b6 \u2198. \u2022 fuzz h\u03b4\u03b5 t := by\n          rw [inv_smul_eq_iff] at hN\u2081'\n          rw [hN\u2081', Path.botSderiv_coe_eq, BasePerm.smul_nearLitter_litter,\n            BasePerm.smul_nearLitter_litter, smul_smul, smul_eq_iff_eq_inv_smul,\n            mul_inv_rev, inv_inv, mul_smul, \u2190 Tree.inv_apply, \u2190 allPermForget_inv] at hN\u2081\n          rw [hN\u2081]\n          simp only [allPermForget_inv, Tree.inv_apply, allPermDeriv_forget, Tree.inv_deriv,\n            Tree.inv_sderiv, Tree.inv_sderivBot]\n          rfl\n        rw [smul_fuzz h\u03b4 h\u03b5 h\u03b4\u03b5, smul_fuzz h\u03b4 h\u03b5 h\u03b4\u03b5] at this\n        have := fuzz_injective (hN\u2082.symm.trans this)\n        rw [smul_smul] at this\n        rw [t.smul_nearLitter_eq_of_mem_support this hN\u2080]\n        rw [Enumeration.rel_add_iff] at hi \u22a2\n        obtain hi | \u27e8i, rfl, hi\u27e9 := hi\n        \u00b7 left\n          simp only [allPermForget_mul, allPermSderiv_forget, allPermDeriv_forget,\n            allPermForget_inv, Tree.inv_deriv, Tree.inv_sderiv, Tree.mul_apply, Tree.sderiv_apply,\n            Tree.deriv_apply, Path.deriv_scoderiv, Tree.inv_apply, mul_smul]\n          rwa [\u2190 (h\u03c1\u2081 _).2 N\u2080 \u27e8i, hi\u27e9, inv_smul_smul, (h\u03c1\u2082 _).2 N\u2080 \u27e8i, hi\u27e9]\n        \u00b7 refine Or.inr \u27e8i, rfl, ?_\u27e9\n          simp only [allPermForget_mul, allPermSderiv_forget, allPermDeriv_forget,\n            allPermForget_inv, Tree.inv_deriv, Tree.inv_sderiv, Tree.mul_apply, Tree.sderiv_apply,\n            Tree.deriv_apply, Path.deriv_scoderiv, Tree.inv_apply, mul_smul, Enumeration.smul_rel,\n            inv_smul_smul]\n          exact hi\n\n", "theoremStatement": "theorem litter_eq_of_flexible_of_fixes {S : Support \u03b1} {T : Support \u03b3}\n    {\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n    (h\u03c1\u2081 : \u03c1\u2081\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (h\u03c1\u2082 : \u03c1\u2082\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    {A : \u2191\u03b1 \u219d \u22a5} {N\u2081 N\u2082 N\u2083 N\u2084 : NearLitter} :\n    convNearLitters\n      (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim)\n      (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A N\u2081 N\u2082 \u2192\n    convNearLitters\n      (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim)\n      (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A N\u2083 N\u2084 \u2192\n      \u00acInflexible A N\u2081\u1d38 \u2192 \u00acInflexible A N\u2082\u1d38 \u2192 \u00acInflexible A N\u2083\u1d38 \u2192 \u00acInflexible A N\u2084\u1d38 \u2192\n      N\u2081\u1d38 = N\u2083\u1d38 \u2192 N\u2082\u1d38 = N\u2084\u1d38 ", "theoremName": "ConNF.Support.litter_eq_of_flexible_of_fixes", "fileCreated": {"commit": "abf71bc79c407ceb462cc2edd2d994cda9cdef05", "date": "2024-04-04"}, "theoremCreated": {"commit": "8ed7ee5d263d414ae7b28845288c8c99f6c5423b", "date": "2024-12-01"}, "file": "ConNF/ConNF/Model/RaiseStrong.lean", "module": "ConNF.Model.RaiseStrong", "jsonFile": "ConNF.Model.RaiseStrong.jsonl", "positionMetadata": {"lineInFile": 578, "tokenPositionInFile": 28501, "theoremPositionInFile": 11}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 76, "numPremises": 155}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [Support.smul_eq_iff] at h\u03c1\u2081 h\u03c1\u2082\n  rintro \u27e8i, hi\u2081, hi\u2082\u27e9 \u27e8j, hj\u2081, hj\u2082\u27e9 hN\u2081 hN\u2082 hN\u2083 hN\u2084 hN\u2081\u2083\n  simp only [add_derivBot, BaseSupport.add_nearLitters, Rel.inv_apply,\n    Enumeration.rel_add_iff] at hi\u2081 hi\u2082 hj\u2081 hj\u2082\n  obtain hi\u2081 | \u27e8i, rfl, hi\u2081\u27e9 := hi\u2081\n  \u00b7 obtain hi\u2082 | \u27e8i, rfl, hi\u2082\u27e9 := hi\u2082\n    swap\n    \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hi\u2081\u27e9\n      simp only [add_lt_iff_neg_left] at this\n      cases (\u03ba_zero_le i).not_lt this\n    cases (Enumeration.rel_coinjective _).coinjective hi\u2081 hi\u2082\n    obtain hj\u2081 | \u27e8j, rfl, hj\u2081\u27e9 := hj\u2081\n    \u00b7 obtain hj\u2082 | \u27e8j, rfl, hj\u2082\u27e9 := hj\u2082\n      swap\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2081\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j).not_lt this\n      cases (Enumeration.rel_coinjective _).coinjective hj\u2081 hj\u2082\n      exact hN\u2081\u2083\n    \u00b7 simp only [add_right_inj, exists_eq_left] at hj\u2082\n      obtain hj\u2082 | hj\u2082 := hj\u2082\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2082\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j).not_lt this\n      obtain \u27e8A, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv \u27e8j, hj\u2081\u27e9\n      simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_nearLitters,\n        BaseSupport.add_nearLitters, Enumeration.smul_rel] at hj\u2081 hj\u2082\n      have := congr_arg (\u00b7\u1d38) ((Enumeration.rel_coinjective _).coinjective hj\u2081 hj\u2082)\n      simp only [BasePerm.smul_nearLitter_litter] at this\n      rw [\u2190 hN\u2081\u2083, \u2190 (h\u03c1\u2081 A).2 N\u2081 \u27e8i, hi\u2081\u27e9, BasePerm.smul_nearLitter_litter, inv_smul_smul] at this\n      have hN\u2081' := (h\u03c1\u2082 A).2 N\u2081 \u27e8i, hi\u2081\u27e9\n      rw [smul_eq_iff_eq_inv_smul] at hN\u2081'\n      rwa [hN\u2081', BasePerm.smul_nearLitter_litter, smul_left_cancel_iff] at this\n  \u00b7 obtain hi\u2082 | hi\u2082 := hi\u2082\n    \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hi\u2082\u27e9\n      simp only [add_lt_iff_neg_left] at this\n      cases (\u03ba_zero_le i).not_lt this\n    simp only [add_right_inj, exists_eq_left] at hi\u2082\n    obtain \u27e8A, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv \u27e8i, hi\u2081\u27e9\n    simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_nearLitters,\n      BaseSupport.add_nearLitters, Enumeration.smul_rel] at hi\u2081 hi\u2082 hj\u2081 hj\u2082\n    have hN\u2081\u2082 := congr_arg (\u00b7\u1d38) ((Enumeration.rel_coinjective _).coinjective hi\u2081 hi\u2082)\n    obtain hj\u2081 | \u27e8j, rfl, hj\u2081\u27e9 := hj\u2081\n    \u00b7 obtain hj\u2082 | \u27e8j, rfl, hj\u2082\u27e9 := hj\u2082\n      swap\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2081\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j).not_lt this\n      cases (Enumeration.rel_coinjective _).coinjective hj\u2081 hj\u2082\n      simp only [BasePerm.smul_nearLitter_litter] at hN\u2081\u2082\n      rw [hN\u2081\u2083, \u2190 (h\u03c1\u2081 A).2 N\u2083 \u27e8j, hj\u2081\u27e9, BasePerm.smul_nearLitter_litter, inv_smul_smul,\n        eq_inv_smul_iff, \u2190 BasePerm.smul_nearLitter_litter, (h\u03c1\u2082 A).2 N\u2083 \u27e8j, hj\u2081\u27e9] at hN\u2081\u2082\n      rw [hN\u2081\u2082]\n    \u00b7 simp only [add_right_inj, exists_eq_left] at hj\u2082\n      obtain hj\u2082 | hj\u2082 := hj\u2082\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2082\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j).not_lt this\n      have hN\u2083\u2084 := congr_arg (\u00b7\u1d38) ((Enumeration.rel_coinjective _).coinjective hj\u2081 hj\u2082)\n      simp only [BasePerm.smul_nearLitter_litter] at hN\u2081\u2082 hN\u2083\u2084\n      rw [hN\u2081\u2083] at hN\u2081\u2082\n      rwa [hN\u2081\u2082, smul_left_cancel_iff] at hN\u2083\u2084", "proofType": "tactic", "proofLengthLines": 62, "proofLengthTokens": 3205}}
{"srcContext": "import ConNF.ModelData.PathEnumeration\n\n/-!\n# Supports\n\nIn this file, we define the notion of a support.\n\n## Main declarations\n\n* `ConNF.BaseSupport`: The type of supports of atoms.\n* `ConNF.Support`: The type of supports of objects of arbitrary type indices.\n-/\n\nuniverse u\n\nopen Cardinal\n\nnamespace ConNF\n\nvariable [Params.{u}]\n\n/-!\n## Base supports\n-/\n\nstructure BaseSupport where\n  atoms : Enumeration Atom\n  nearLitters : Enumeration NearLitter\n\nnamespace BaseSupport\n\ninstance : SuperA BaseSupport (Enumeration Atom) where\n  superA := atoms\n\ninstance : SuperN BaseSupport (Enumeration NearLitter) where\n  superN := nearLitters\n\n@[simp]\ntheorem mk_atoms {a : Enumeration Atom} {N : Enumeration NearLitter} :\n    (BaseSupport.mk a N)\u1d2c = a :=\n  rfl\n\n@[simp]\ntheorem mk_nearLitters {a : Enumeration Atom} {N : Enumeration NearLitter} :\n    (BaseSupport.mk a N)\u1d3a = N :=\n  rfl\n\ntheorem atoms_congr {S T : BaseSupport} (h : S = T) :\n    S\u1d2c = T\u1d2c :=\n  h \u25b8 rfl\n\ntheorem nearLitters_congr {S T : BaseSupport} (h : S = T) :\n    S\u1d3a = T\u1d3a :=\n  h \u25b8 rfl\n\n@[ext]\ntheorem ext {S T : BaseSupport} (h\u2081 : S\u1d2c = T\u1d2c) (h\u2082 : S\u1d3a = T\u1d3a) : S = T := by\n  obtain \u27e8SA, SN\u27e9 := S\n  obtain \u27e8TA, TN\u27e9 := T\n  cases h\u2081\n  cases h\u2082\n  rfl\n\ninstance : SMul BasePerm BaseSupport where\n  smul \u03c0 S := \u27e8\u03c0 \u2022 S\u1d2c, \u03c0 \u2022 S\u1d3a\u27e9\n\n@[simp]\ntheorem smul_atoms (\u03c0 : BasePerm) (S : BaseSupport) :\n    (\u03c0 \u2022 S)\u1d2c = \u03c0 \u2022 S\u1d2c :=\n  rfl\n\n@[simp]\ntheorem smul_nearLitters (\u03c0 : BasePerm) (S : BaseSupport) :\n    (\u03c0 \u2022 S)\u1d3a = \u03c0 \u2022 S\u1d3a :=\n  rfl\n\n@[simp]\ntheorem smul_atoms_eq_of_smul_eq {\u03c0 : BasePerm} {S : BaseSupport}\n    (h : \u03c0 \u2022 S = S) :\n    \u03c0 \u2022 S\u1d2c = S\u1d2c := by\n  rw [\u2190 smul_atoms, h]\n\n@[simp]\ntheorem smul_nearLitters_eq_of_smul_eq {\u03c0 : BasePerm} {S : BaseSupport}\n    (h : \u03c0 \u2022 S = S) :\n    \u03c0 \u2022 S\u1d3a = S\u1d3a := by\n  rw [\u2190 smul_nearLitters, h]\n\ninstance : MulAction BasePerm BaseSupport where\n  one_smul S := by\n    apply ext\n    \u00b7 rw [smul_atoms, one_smul]\n    \u00b7 rw [smul_nearLitters, one_smul]\n  mul_smul \u03c0\u2081 \u03c0\u2082 S := by\n    apply ext\n    \u00b7 rw [smul_atoms, smul_atoms, smul_atoms, mul_smul]\n    \u00b7 rw [smul_nearLitters, smul_nearLitters, smul_nearLitters, mul_smul]\n\ntheorem smul_eq_smul_iff (\u03c0\u2081 \u03c0\u2082 : BasePerm) (S : BaseSupport) :\n    \u03c0\u2081 \u2022 S = \u03c0\u2082 \u2022 S \u2194 (\u2200 a \u2208 S\u1d2c, \u03c0\u2081 \u2022 a = \u03c0\u2082 \u2022 a) \u2227 (\u2200 N \u2208 S\u1d3a, \u03c0\u2081 \u2022 N = \u03c0\u2082 \u2022 N) := by\n  constructor\n  \u00b7 intro h\n    constructor\n    \u00b7 rintro a \u27e8i, ha\u27e9\n      have := congr_arg (\u00b7\u1d2c.rel i (\u03c0\u2081 \u2022 a)) h\n      simp only [smul_atoms, Enumeration.smul_rel, inv_smul_smul, eq_iff_iff] at this\n      have := S\u1d2c.rel_coinjective.coinjective ha (this.mp ha)\n      rw [eq_inv_smul_iff] at this\n      rw [this]\n    \u00b7 rintro N \u27e8i, hN\u27e9\n      have := congr_arg (\u00b7\u1d3a.rel i (\u03c0\u2081 \u2022 N)) h\n      simp only [smul_nearLitters, Enumeration.smul_rel, inv_smul_smul, eq_iff_iff] at this\n      have := S\u1d3a.rel_coinjective.coinjective hN (this.mp hN)\n      rw [eq_inv_smul_iff] at this\n      rw [this]\n  \u00b7 intro h\n    ext : 2\n    \u00b7 rfl\n    \u00b7 ext i a : 3\n      rw [smul_atoms, smul_atoms, Enumeration.smul_rel, Enumeration.smul_rel]\n      constructor\n      \u00b7 intro ha\n        have := h.1 _ \u27e8i, ha\u27e9\n        rw [smul_inv_smul, \u2190 inv_smul_eq_iff] at this\n        rwa [this]\n      \u00b7 intro ha\n        have := h.1 _ \u27e8i, ha\u27e9\n        rw [smul_inv_smul, smul_eq_iff_eq_inv_smul] at this\n        rwa [\u2190 this]\n    \u00b7 rfl\n    \u00b7 ext i a : 3\n      rw [smul_nearLitters, smul_nearLitters, Enumeration.smul_rel, Enumeration.smul_rel]\n      constructor\n      \u00b7 intro hN\n        have := h.2 _ \u27e8i, hN\u27e9\n        rw [smul_inv_smul, \u2190 inv_smul_eq_iff] at this\n        rwa [this]\n      \u00b7 intro hN\n        have := h.2 _ \u27e8i, hN\u27e9\n        rw [smul_inv_smul, smul_eq_iff_eq_inv_smul] at this\n        rwa [\u2190 this]\n\ntheorem smul_eq_iff (\u03c0 : BasePerm) (S : BaseSupport) :\n    \u03c0 \u2022 S = S \u2194 (\u2200 a \u2208 S\u1d2c, \u03c0 \u2022 a = a) \u2227 (\u2200 N \u2208 S\u1d3a, \u03c0 \u2022 N = N) := by\n  have := smul_eq_smul_iff \u03c0 1 S\n  simp only [one_smul] at this\n  exact this\n\nnoncomputable instance : Add BaseSupport where\n  add S T := \u27e8S\u1d2c + T\u1d2c, S\u1d3a + T\u1d3a\u27e9\n\n@[simp]\ntheorem add_atoms (S T : BaseSupport) :\n    (S + T)\u1d2c = S\u1d2c + T\u1d2c :=\n  rfl\n\n@[simp]\ntheorem add_nearLitters (S T : BaseSupport) :\n    (S + T)\u1d3a = S\u1d3a + T\u1d3a :=\n  rfl\n\nend BaseSupport\n\ndef baseSupportEquiv : BaseSupport \u2243 Enumeration Atom \u00d7 Enumeration NearLitter where\n  toFun S := (S\u1d2c, S\u1d3a)\n  invFun S := \u27e8S.1, S.2\u27e9\n  left_inv _ := rfl\n  right_inv _ := rfl\n\ntheorem card_baseSupport : #BaseSupport = #\u03bc := by\n  rw [Cardinal.eq.mpr \u27e8baseSupportEquiv\u27e9, mk_prod, lift_id, lift_id,\n    card_enumeration_eq card_atom, card_enumeration_eq card_nearLitter, mul_eq_self aleph0_lt_\u03bc.le]\n\n/-!\n## Structural supports\n-/\n\nstructure Support (\u03b1 : TypeIndex) where\n  atoms : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)\n  nearLitters : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)\n\nnamespace Support\n\nvariable {\u03b1 \u03b2 : TypeIndex}\n\ninstance : SuperA (Support \u03b1) (Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) where\n  superA := atoms\n\ninstance : SuperN (Support \u03b1) (Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) where\n  superN := nearLitters\n\n@[simp]\ntheorem mk_atoms (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) (F : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) :\n    (\u27e8E, F\u27e9 : Support \u03b1)\u1d2c = E :=\n  rfl\n\n@[simp]\ntheorem mk_nearLitters (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) (F : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) :\n    (\u27e8E, F\u27e9 : Support \u03b1)\u1d3a = F :=\n  rfl\n\ninstance : Derivative (Support \u03b1) (Support \u03b2) \u03b1 \u03b2 where\n  deriv S A := \u27e8S\u1d2c \u21d8 A, S\u1d3a \u21d8 A\u27e9\n\ninstance : Coderivative (Support \u03b2) (Support \u03b1) \u03b1 \u03b2 where\n  coderiv S A := \u27e8S\u1d2c \u21d7 A, S\u1d3a \u21d7 A\u27e9\n\ninstance : BotDerivative (Support \u03b1) BaseSupport \u03b1 where\n  botDeriv S A := \u27e8S\u1d2c \u21d8. A, S\u1d3a \u21d8. A\u27e9\n  botSderiv S := \u27e8S\u1d2c \u2198., S\u1d3a \u2198.\u27e9\n  botDeriv_single S h := by dsimp only; rw [botDeriv_single, botDeriv_single]\n\n@[simp]\ntheorem deriv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u03b2) :\n    S\u1d2c \u21d8 A = (S \u21d8 A)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem deriv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u03b2) :\n    S\u1d3a \u21d8 A = (S \u21d8 A)\u1d3a :=\n  rfl\n\n", "theoremStatement": "@[simp]\ntheorem sderiv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (h : \u03b2 < \u03b1) :\n    S\u1d2c \u2198 h = (S \u2198 h)\u1d2c ", "theoremName": "ConNF.Support.sderiv_atoms", "fileCreated": {"commit": "39c33b4a743bea62dbcc549548b712ffd38ca65c", "date": "2024-12-05"}, "theoremCreated": {"commit": "ce890707e37ede74a2fcd66134d3f403335c5cc1", "date": "2024-11-30"}, "file": "ConNF/ConNF/ModelData/Support.lean", "module": "ConNF.ModelData.Support", "jsonFile": "ConNF.ModelData.Support.jsonl", "positionMetadata": {"lineInFile": 223, "tokenPositionInFile": 5740, "theoremPositionInFile": 18}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 15, "numPremises": 28}, "proofMetadata": {"hasProof": true, "proof": ":=\n  rfl", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 8}}
{"srcContext": "import ConNF.Model.TTT\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\nnamespace TSet\n\ntheorem exists_inter (x y : TSet \u03b1) :\n    \u2203 w : TSet \u03b1, \u2200 z : TSet \u03b2, z \u2208[h\u03b2] w \u2194 z \u2208[h\u03b2] x \u2227 z \u2208[h\u03b2] y := by\n  refine exists_of_symmetric {z | z \u2208[h\u03b2] x \u2227 z \u2208[h\u03b2] y} h\u03b2 ?_\n  obtain \u27e8S, hS\u27e9 := symmetric x h\u03b2\n  obtain \u27e8T, hT\u27e9 := symmetric y h\u03b2\n  use S + T\n  intro \u03c1 h\u03c1\n  specialize hS \u03c1 (smul_eq_of_le Support.le_add_right h\u03c1)\n  specialize hT \u03c1 (smul_eq_of_le Support.le_add_left h\u03c1)\n  simp [Set.ext_iff, Set.mem_smul_set_iff_inv_smul_mem] at hS hT \u22a2\n  aesop\n\ntheorem exists_compl (x : TSet \u03b1) :\n    \u2203 y : TSet \u03b1, \u2200 z : TSet \u03b2, z \u2208[h\u03b2] y \u2194 \u00acz \u2208[h\u03b2] x := by\n  refine exists_of_symmetric {z | \u00acz \u2208[h\u03b2] x} h\u03b2 ?_\n  obtain \u27e8S, hS\u27e9 := symmetric x h\u03b2\n  use S\n  intro \u03c1 h\u03c1\n  specialize hS \u03c1 h\u03c1\n  simp [Set.ext_iff, Set.mem_smul_set_iff_inv_smul_mem] at hS \u22a2\n  aesop\n\ntheorem exists_up (x y : TSet \u03b2) :\n    \u2203 w : TSet \u03b1, \u2200 z : TSet \u03b2, z \u2208[h\u03b2] w \u2194 z = x \u2228 z = y := by\n  refine exists_of_symmetric {x, y} h\u03b2 ?_\n  obtain \u27e8S, hS\u27e9 := exists_support x\n  obtain \u27e8T, hT\u27e9 := exists_support y\n  use (S + T) \u2197 h\u03b2\n  intro \u03c1 h\u03c1\n  rw [Support.smul_scoderiv, Support.scoderiv_inj, \u2190 allPermSderiv_forget'] at h\u03c1\n  specialize hS (\u03c1 \u2198 h\u03b2) (smul_eq_of_le Support.le_add_right h\u03c1)\n  specialize hT (\u03c1 \u2198 h\u03b2) (smul_eq_of_le Support.le_add_left h\u03c1)\n  simp only [Set.smul_set_def, Set.image, Set.mem_insert_iff, Set.mem_singleton_iff,\n    exists_eq_or_imp, hS, exists_eq_left, hT]\n  ext z\n  rw [Set.mem_insert_iff, Set.mem_singleton_iff, Set.mem_setOf_eq]\n  aesop\n\n/-- The unordered pair. -/\ndef up (x y : TSet \u03b2) : TSet \u03b1 :=\n  (exists_up h\u03b2 x y).choose\n\n@[simp]\ntheorem mem_up_iff (x y z : TSet \u03b2) :\n    z \u2208[h\u03b2] up h\u03b2 x y \u2194 z = x \u2228 z = y :=\n  (exists_up h\u03b2 x y).choose_spec z\n\n/-- The Kuratowski ordered pair. -/\ndef op (x y : TSet \u03b3) : TSet \u03b1 :=\n  up h\u03b2 (singleton h\u03b3 x) (up h\u03b3 x y)\n\ntheorem up_injective {x y z w : TSet \u03b2} (h : up h\u03b2 x y = up h\u03b2 z w) :\n    (x = z \u2227 y = w) \u2228 (x = w \u2227 y = z) := by\n  have h\u2081 := mem_up_iff h\u03b2 x y z\n  have h\u2082 := mem_up_iff h\u03b2 x y w\n  have h\u2083 := mem_up_iff h\u03b2 z w x\n  have h\u2084 := mem_up_iff h\u03b2 z w y\n  rw [h, mem_up_iff] at h\u2081 h\u2082\n  rw [\u2190 h, mem_up_iff] at h\u2083 h\u2084\n  aesop\n\n@[simp]\ntheorem up_inj (x y z w : TSet \u03b2) :\n    up h\u03b2 x y = up h\u03b2 z w \u2194 (x = z \u2227 y = w) \u2228 (x = w \u2227 y = z) := by\n  constructor\n  \u00b7 exact up_injective h\u03b2\n  \u00b7 rintro (\u27e8rfl, rfl\u27e9 | \u27e8rfl, rfl\u27e9)\n    \u00b7 rfl\n    \u00b7 apply tSet_ext' h\u03b2\n      aesop\n\n@[simp]\ntheorem up_self {x : TSet \u03b2} :\n    up h\u03b2 x x = singleton h\u03b2 x := by\n  apply tSet_ext' h\u03b2\n  aesop\n\n@[simp]\ntheorem up_eq_singleton_iff (x y z : TSet \u03b2) :\n    up h\u03b2 x y = singleton h\u03b2 z \u2194 x = z \u2227 y = z := by\n  constructor\n  \u00b7 intro h\n    have h\u2081 := typedMem_singleton_iff' h\u03b2 z x\n    have h\u2082 := typedMem_singleton_iff' h\u03b2 z y\n    rw [\u2190 h, mem_up_iff] at h\u2081 h\u2082\n    aesop\n  \u00b7 rintro \u27e8rfl, rfl\u27e9\n    rw [up_self]\n\n@[simp]\ntheorem singleton_eq_up_iff (x y z : TSet \u03b2) :\n    singleton h\u03b2 z = up h\u03b2 x y \u2194 x = z \u2227 y = z := by\n  rw [\u2190 up_eq_singleton_iff h\u03b2 x y z, eq_comm]\n\ntheorem op_injective {x y z w : TSet \u03b3} (h : op h\u03b2 h\u03b3 x y = op h\u03b2 h\u03b3 z w) :\n    x = z \u2227 y = w := by\n  rw [op, op] at h\n  simp only [up_inj, singleton_inj, singleton_eq_up_iff, up_eq_singleton_iff] at h\n  obtain (\u27e8rfl, \u27e8h, rfl\u27e9 | \u27e8rfl, rfl\u27e9\u27e9 | \u27e8\u27e8rfl, rfl\u27e9, \u27e8h, rfl\u27e9\u27e9) := h <;> simp only [and_self]\n\n@[simp]\ntheorem op_inj (x y z w : TSet \u03b3) :\n    op h\u03b2 h\u03b3 x y = op h\u03b2 h\u03b3 z w \u2194 x = z \u2227 y = w := by\n  constructor\n  \u00b7 exact op_injective h\u03b2 h\u03b3\n  \u00b7 rintro \u27e8rfl, rfl\u27e9\n    rfl\n\n@[simp]\ntheorem op_eq_singleton_iff (x y : TSet \u03b3) (z : TSet \u03b2) :\n    op h\u03b2 h\u03b3 x y = singleton h\u03b2 z \u2194 singleton h\u03b3 x = z \u2227 singleton h\u03b3 y = z := by\n  rw [op, up_eq_singleton_iff, and_congr_right_iff]\n  rintro rfl\n  simp only [up_eq_singleton_iff, true_and, singleton_inj]\n\n@[simp]\ntheorem smul_up (x y : TSet \u03b2) (\u03c1 : AllPerm \u03b1) :\n    \u03c1 \u2022 up h\u03b2 x y = up h\u03b2 (\u03c1 \u2198 h\u03b2 \u2022 x) (\u03c1 \u2198 h\u03b2 \u2022 y) := by\n  apply tSet_ext' h\u03b2\n  aesop\n\n@[simp]\ntheorem smul_op (x y : TSet \u03b3) (\u03c1 : AllPerm \u03b1) :\n    \u03c1 \u2022 op h\u03b2 h\u03b3 x y = op h\u03b2 h\u03b3 (\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2022 x) (\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2022 y) := by\n  apply tSet_ext' h\u03b2\n  simp only [op, smul_up, smul_singleton, mem_up_iff, implies_true]\n\ntheorem exists_singletonImage (x : TSet \u03b2) :\n    \u2203 y : TSet \u03b1, \u2200 z w,\n    op h\u03b3 h\u03b4 (singleton h\u03b5 z) (singleton h\u03b5 w) \u2208[h\u03b2] y \u2194 op h\u03b4 h\u03b5 z w \u2208[h\u03b3] x := by\n  have := exists_of_symmetric {u | \u2203 z w : TSet \u03b5, op h\u03b4 h\u03b5 z w \u2208[h\u03b3] x \u2227\n      u = op h\u03b3 h\u03b4 (singleton h\u03b5 z) (singleton h\u03b5 w)} h\u03b2 ?_\n  \u00b7 obtain \u27e8y, hy\u27e9 := this\n    use y\n    intro z w\n    rw [hy]\n    simp only [Set.mem_setOf_eq, op_inj, singleton_inj, exists_eq_right_right', exists_eq_right']\n  \u00b7 obtain \u27e8S, hS\u27e9 := exists_support x\n    use S \u2197 h\u03b2\n    intro \u03c1 h\u03c1\n    rw [Support.smul_scoderiv, Support.scoderiv_inj, \u2190 allPermSderiv_forget'] at h\u03c1\n    specialize hS (\u03c1 \u2198 h\u03b2) h\u03c1\n    ext z\n    constructor\n    \u00b7 rintro \u27e8_, \u27e8z, w, hab, rfl\u27e9, rfl\u27e9\n      refine \u27e8\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2022 z, \u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2022 w, ?_, ?_\u27e9\n      \u00b7 rwa [\u2190 hS, mem_smul_iff', smul_op, allPerm_inv_sderiv', allPerm_inv_sderiv',\n          allPerm_inv_sderiv', inv_smul_smul, inv_smul_smul]\n      \u00b7 simp only [smul_op, smul_singleton]\n    \u00b7 rintro \u27e8z, w, hab, rfl\u27e9\n      refine \u27e8\u03c1\u207b\u00b9 \u2198 h\u03b2 \u2022 op h\u03b3 h\u03b4 (singleton h\u03b5 z) (singleton h\u03b5 w), ?_, ?_\u27e9\n      \u00b7 simp only [allPerm_inv_sderiv', smul_op, smul_singleton, Set.mem_setOf_eq, op_inj,\n          singleton_inj, exists_eq_right_right', exists_eq_right']\n        rw [smul_eq_iff_eq_inv_smul] at hS\n        rw [hS]\n        simp only [mem_smul_iff', inv_inv, smul_op, smul_inv_smul]\n        exact hab\n      \u00b7 simp only [allPerm_inv_sderiv', smul_inv_smul]\n\ntheorem exists_insertion2 (x : TSet \u03b3) :\n    \u2203 y : TSet \u03b1, \u2200 a b c, op h\u03b3 h\u03b4 (singleton h\u03b5 (singleton h\u03b6 a)) (op h\u03b5 h\u03b6 b c) \u2208[h\u03b2] y \u2194\n    op h\u03b5 h\u03b6 a c \u2208[h\u03b4] x := by\n  have := exists_of_symmetric {u | \u2203 a b c : TSet \u03b6, op h\u03b5 h\u03b6 a c \u2208[h\u03b4] x \u2227\n      u = op h\u03b3 h\u03b4 (singleton h\u03b5 (singleton h\u03b6 a)) (op h\u03b5 h\u03b6 b c)} h\u03b2 ?_\n  \u00b7 obtain \u27e8y, hy\u27e9 := this\n    use y\n    intro a b c\n    rw [hy]\n    constructor\n    \u00b7 rintro \u27e8a', b', c', h\u2081, h\u2082\u27e9\n      simp only [op_inj, singleton_inj] at h\u2082\n      obtain \u27e8rfl, rfl, rfl\u27e9 := h\u2082\n      exact h\u2081\n    \u00b7 intro h\n      exact \u27e8a, b, c, h, rfl\u27e9\n  \u00b7 obtain \u27e8S, hS\u27e9 := exists_support x\n    use S \u2197 h\u03b3 \u2197 h\u03b2\n    intro \u03c1 h\u03c1\n    simp only [Support.smul_scoderiv, Support.scoderiv_inj, \u2190 allPermSderiv_forget'] at h\u03c1\n    specialize hS (\u03c1 \u2198 h\u03b2 \u2198 h\u03b3) h\u03c1\n    ext z\n    constructor\n    \u00b7 rintro \u27e8_, \u27e8a, b, c, hx, rfl\u27e9, rfl\u27e9\n      refine \u27e8\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 a, \u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 b,\n        \u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 c, ?_, ?_\u27e9\n      \u00b7 rw [\u2190 hS]\n        simp only [mem_smul_iff', allPerm_inv_sderiv', smul_op, inv_smul_smul]\n        exact hx\n      \u00b7 simp only [smul_op, smul_singleton]\n    \u00b7 rintro \u27e8a, b, c, hx, rfl\u27e9\n      rw [Set.mem_smul_set_iff_inv_smul_mem]\n      refine \u27e8\u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 a, \u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 b,\n        \u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 c, ?_, ?_\u27e9\n      \u00b7 rw [smul_eq_iff_eq_inv_smul] at hS\n        rw [hS, mem_smul_iff']\n        simp only [inv_inv, allPerm_inv_sderiv', smul_op, smul_inv_smul]\n        exact hx\n      \u00b7 simp only [smul_op, allPerm_inv_sderiv', smul_singleton]\n\ntheorem exists_insertion3 (x : TSet \u03b3) :\n    \u2203 y : TSet \u03b1, \u2200 a b c, op h\u03b3 h\u03b4 (singleton h\u03b5 (singleton h\u03b6 a)) (op h\u03b5 h\u03b6 b c) \u2208[h\u03b2] y \u2194\n    op h\u03b5 h\u03b6 a b \u2208[h\u03b4] x := by\n  have := exists_of_symmetric {u | \u2203 a b c : TSet \u03b6, op h\u03b5 h\u03b6 a b \u2208[h\u03b4] x \u2227\n      u = op h\u03b3 h\u03b4 (singleton h\u03b5 (singleton h\u03b6 a)) (op h\u03b5 h\u03b6 b c)} h\u03b2 ?_\n  \u00b7 obtain \u27e8y, hy\u27e9 := this\n    use y\n    intro a b c\n    rw [hy]\n    constructor\n    \u00b7 rintro \u27e8a', b', c', h\u2081, h\u2082\u27e9\n      simp only [op_inj, singleton_inj] at h\u2082\n      obtain \u27e8rfl, rfl, rfl\u27e9 := h\u2082\n      exact h\u2081\n    \u00b7 intro h\n      exact \u27e8a, b, c, h, rfl\u27e9\n  \u00b7 obtain \u27e8S, hS\u27e9 := exists_support x\n    use S \u2197 h\u03b3 \u2197 h\u03b2\n    intro \u03c1 h\u03c1\n    simp only [Support.smul_scoderiv, Support.scoderiv_inj, \u2190 allPermSderiv_forget'] at h\u03c1\n    specialize hS (\u03c1 \u2198 h\u03b2 \u2198 h\u03b3) h\u03c1\n    ext z\n    constructor\n    \u00b7 rintro \u27e8_, \u27e8a, b, c, hx, rfl\u27e9, rfl\u27e9\n      refine \u27e8\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 a, \u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 b,\n        \u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 c, ?_, ?_\u27e9\n      \u00b7 rw [\u2190 hS]\n        simp only [mem_smul_iff', allPerm_inv_sderiv', smul_op, inv_smul_smul]\n        exact hx\n      \u00b7 simp only [smul_op, smul_singleton]\n    \u00b7 rintro \u27e8a, b, c, hx, rfl\u27e9\n      rw [Set.mem_smul_set_iff_inv_smul_mem]\n      refine \u27e8\u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 a, \u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 b,\n        \u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 c, ?_, ?_\u27e9\n      \u00b7 rw [smul_eq_iff_eq_inv_smul] at hS\n        rw [hS, mem_smul_iff']\n        simp only [inv_inv, allPerm_inv_sderiv', smul_op, smul_inv_smul]\n        exact hx\n      \u00b7 simp only [smul_op, allPerm_inv_sderiv', smul_singleton]\n\ntheorem exists_cross (x : TSet \u03b3) :\n    \u2203 y : TSet \u03b1, \u2200 a, a \u2208[h\u03b2] y \u2194 \u2203 b c, a = op h\u03b3 h\u03b4 b c \u2227 c \u2208[h\u03b4] x := by\n  have := exists_of_symmetric {a | \u2203 b c, a = op h\u03b3 h\u03b4 b c \u2227 c \u2208[h\u03b4] x} h\u03b2 ?_\n  \u00b7 obtain \u27e8y, hy\u27e9 := this\n    use y\n    intro a\n    rw [hy]\n    rfl\n  \u00b7 obtain \u27e8S, hS\u27e9 := exists_support x\n    use S \u2197 h\u03b3 \u2197 h\u03b2\n    intro \u03c1 h\u03c1\n    simp only [Support.smul_scoderiv, Support.scoderiv_inj, \u2190 allPermSderiv_forget'] at h\u03c1\n    specialize hS (\u03c1 \u2198 h\u03b2 \u2198 h\u03b3) h\u03c1\n    ext z\n    constructor\n    \u00b7 rintro \u27e8_, \u27e8a, b, rfl, hab\u27e9, rfl\u27e9\n      refine \u27e8\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2022 a, \u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2022 b, ?_, ?_\u27e9\n      \u00b7 simp only [smul_op]\n      \u00b7 rw [\u2190 hS]\n        simp only [mem_smul_iff', allPerm_inv_sderiv', inv_smul_smul]\n        exact hab\n    \u00b7 rintro \u27e8a, b, rfl, hab\u27e9\n      rw [Set.mem_smul_set_iff_inv_smul_mem]\n      refine \u27e8\u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2022 a, \u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2022 b, ?_, ?_\u27e9\n      \u00b7 simp only [smul_op, allPerm_inv_sderiv']\n      \u00b7 rw [smul_eq_iff_eq_inv_smul] at hS\n        rw [hS]\n        simp only [allPerm_inv_sderiv', mem_smul_iff', inv_inv, smul_inv_smul]\n        exact hab\n\n", "theoremStatement": "theorem exists_typeLower (x : TSet \u03b1) :\n    \u2203 y : TSet \u03b4, \u2200 a, a \u2208[h\u03b5] y \u2194 \u2200 b, op h\u03b3 h\u03b4 b (singleton h\u03b5 a) \u2208[h\u03b2] x ", "theoremName": "ConNF.TSet.exists_typeLower", "fileCreated": {"commit": "f804f5c71cfaa98223fc227dd822801e8bf77004", "date": "2024-03-30"}, "theoremCreated": {"commit": "f7c233c7f7fd9d8b74595bbfa2bbbd49d538ef59", "date": "2024-12-02"}, "file": "ConNF/ConNF/Model/Hailperin.lean", "module": "ConNF.Model.Hailperin", "jsonFile": "ConNF.Model.Hailperin.jsonl", "positionMetadata": {"lineInFile": 294, "tokenPositionInFile": 9994, "theoremPositionInFile": 20}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 34, "numPremises": 93}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  have := exists_of_symmetric {a | \u2200 b, op h\u03b3 h\u03b4 b (singleton h\u03b5 a) \u2208[h\u03b2] x} h\u03b5 ?_\n  \u00b7 obtain \u27e8y, hy\u27e9 := this\n    use y\n    intro a\n    rw [hy]\n    rfl\n  \u00b7 apply sUnion_singleton_symmetric h\u03b5 h\u03b4\n    apply sUnion_singleton_symmetric h\u03b4 h\u03b3\n    apply sUnion_singleton_symmetric h\u03b3 h\u03b2\n    obtain \u27e8S, hS\u27e9 := exists_support x\n    use S\n    intro \u03c1 h\u03c1\n    specialize hS \u03c1 h\u03c1\n    ext z\n    constructor\n    \u00b7 rintro \u27e8_, \u27e8_, \u27e8a, \u27e8b, hb, rfl\u27e9, rfl\u27e9, rfl\u27e9, rfl\u27e9\n      simp only [smul_singleton, Set.mem_image, Set.mem_setOf_eq, exists_exists_and_eq_and,\n        singleton_inj, exists_eq_right]\n      intro c\n      have := hb (\u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2022 c)\n      rw [smul_eq_iff_eq_inv_smul] at hS\n      rw [hS] at this\n      simp only [allPerm_inv_sderiv', mem_smul_iff', inv_inv, smul_op, smul_inv_smul,\n        smul_singleton] at this\n      exact this\n    \u00b7 rintro \u27e8_, \u27e8a, \u27e8b, hb, rfl\u27e9, rfl\u27e9, rfl\u27e9\n      rw [Set.mem_smul_set_iff_inv_smul_mem]\n      simp only [smul_singleton, allPerm_inv_sderiv', Set.mem_image, Set.mem_setOf_eq,\n        exists_exists_and_eq_and, singleton_inj, exists_eq_right]\n      intro c\n      have := hb (\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2022 c)\n      rw [\u2190 hS] at this\n      simp only [mem_smul_iff', allPerm_inv_sderiv', smul_op, inv_smul_smul, smul_singleton] at this\n      exact this", "proofType": "tactic", "proofLengthLines": 34, "proofLengthTokens": 1281}}
{"srcContext": "import ConNF.Model.RaiseStrong\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nopen scoped Pointwise\n\nnamespace ConNF\n\nvariable [Params.{u}]\n\n/-- A redefinition of the derivative of allowable permutations that is invariant of level,\nbut still has nice definitional properties. -/\n@[default_instance 200]\ninstance {\u03b2 \u03b3 : TypeIndex} : Derivative (AllPerm \u03b2) (AllPerm \u03b3) \u03b2 \u03b3 where\n  deriv \u03c1 A :=\n    A.recSderiv\n    (motive := \u03bb (\u03b4 : TypeIndex) (A : \u03b2 \u219d \u03b4) \u21a6\n      letI : Level := \u27e8\u03b4.recBotCoe (Nonempty.some inferInstance) id\u27e9\n      letI : LeLevel \u03b4 := \u27e8\u03b4.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n        (show \u03b4.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n      AllPerm \u03b4)\n    \u03c1 (\u03bb \u03b4 \u03b5 A h \u03c1 \u21a6\n      letI : Level := \u27e8\u03b4.recBotCoe (Nonempty.some inferInstance) id\u27e9\n      letI : LeLevel \u03b4 := \u27e8\u03b4.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n        (show \u03b4.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n      letI : LeLevel \u03b5 := \u27e8h.le.trans LeLevel.elim\u27e9\n      PreCoherentData.allPermSderiv h \u03c1)\n\n@[simp]\ntheorem allPerm_deriv_nil' {\u03b2 : TypeIndex}\n    (\u03c1 : AllPerm \u03b2) :\n    \u03c1 \u21d8 (.nil : \u03b2 \u219d \u03b2) = \u03c1 :=\n  rfl\n\n", "theoremStatement": "@[simp]\ntheorem allPerm_deriv_sderiv' {\u03b2 \u03b3 \u03b4 : TypeIndex}\n    (\u03c1 : AllPerm \u03b2) (A : \u03b2 \u219d \u03b3) (h : \u03b4 < \u03b3) :\n    \u03c1 \u21d8 (A \u2198 h) = \u03c1 \u21d8 A \u2198 h ", "theoremName": "ConNF.allPerm_deriv_sderiv'", "fileCreated": {"commit": "6fdc87c6b30b73931407a372f1430ecf0fef7601", "date": "2024-12-03"}, "theoremCreated": {"commit": "75a59b81a56dda9d4494ecfa54a8354c680a0c7c", "date": "2024-12-01"}, "file": "ConNF/ConNF/Model/TTT.lean", "module": "ConNF.Model.TTT", "jsonFile": "ConNF.Model.TTT.jsonl", "positionMetadata": {"lineInFile": 48, "tokenPositionInFile": 1279, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 14, "numPremises": 24}, "proofMetadata": {"hasProof": true, "proof": ":=\n  rfl", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 8}}
{"srcContext": "import ConNF.Model.RaiseStrong\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nopen scoped Pointwise\n\nnamespace ConNF\n\nvariable [Params.{u}]\n\n/-- A redefinition of the derivative of allowable permutations that is invariant of level,\nbut still has nice definitional properties. -/\n@[default_instance 200]\ninstance {\u03b2 \u03b3 : TypeIndex} : Derivative (AllPerm \u03b2) (AllPerm \u03b3) \u03b2 \u03b3 where\n  deriv \u03c1 A :=\n    A.recSderiv\n    (motive := \u03bb (\u03b4 : TypeIndex) (A : \u03b2 \u219d \u03b4) \u21a6\n      letI : Level := \u27e8\u03b4.recBotCoe (Nonempty.some inferInstance) id\u27e9\n      letI : LeLevel \u03b4 := \u27e8\u03b4.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n        (show \u03b4.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n      AllPerm \u03b4)\n    \u03c1 (\u03bb \u03b4 \u03b5 A h \u03c1 \u21a6\n      letI : Level := \u27e8\u03b4.recBotCoe (Nonempty.some inferInstance) id\u27e9\n      letI : LeLevel \u03b4 := \u27e8\u03b4.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n        (show \u03b4.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n      letI : LeLevel \u03b5 := \u27e8h.le.trans LeLevel.elim\u27e9\n      PreCoherentData.allPermSderiv h \u03c1)\n\n@[simp]\ntheorem allPerm_deriv_nil' {\u03b2 : TypeIndex}\n    (\u03c1 : AllPerm \u03b2) :\n    \u03c1 \u21d8 (.nil : \u03b2 \u219d \u03b2) = \u03c1 :=\n  rfl\n\n@[simp]\ntheorem allPerm_deriv_sderiv' {\u03b2 \u03b3 \u03b4 : TypeIndex}\n    (\u03c1 : AllPerm \u03b2) (A : \u03b2 \u219d \u03b3) (h : \u03b4 < \u03b3) :\n    \u03c1 \u21d8 (A \u2198 h) = \u03c1 \u21d8 A \u2198 h :=\n  rfl\n\n@[simp]\ntheorem allPermSderiv_forget' {\u03b2 \u03b3 : TypeIndex} (h : \u03b3 < \u03b2) (\u03c1 : AllPerm \u03b2) :\n    (\u03c1 \u2198 h)\u1d41 = \u03c1\u1d41 \u2198 h :=\n  letI : Level := \u27e8\u03b2.recBotCoe (Nonempty.some inferInstance) id\u27e9\n  letI : LeLevel \u03b2 := \u27e8\u03b2.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n    (show \u03b2.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n  letI : LeLevel \u03b3 := \u27e8h.le.trans LeLevel.elim\u27e9\n  allPermSderiv_forget h \u03c1\n\n@[simp]\ntheorem allPerm_inv_sderiv' {\u03b2 \u03b3 : TypeIndex} (h : \u03b3 < \u03b2) (\u03c1 : AllPerm \u03b2) :\n    \u03c1\u207b\u00b9 \u2198 h = (\u03c1 \u2198 h)\u207b\u00b9 := by\n  apply allPermForget_injective\n  rw [allPermSderiv_forget', allPermForget_inv, Tree.inv_sderiv, allPermForget_inv,\n    allPermSderiv_forget']\n\ndef Symmetric {\u03b1 \u03b2 : \u039b} (s : Set (TSet \u03b2)) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) : Prop :=\n  \u2203 S : Support \u03b1, \u2200 \u03c1 : AllPerm \u03b1, \u03c1\u1d41 \u2022 S = S \u2192 \u03c1 \u2198 h\u03b2 \u2022 s = s\n\ndef newSetEquiv {\u03b1 : \u039b} :\n    letI : Level := \u27e8\u03b1\u27e9\n    @TSet _ \u03b1 newModelData.toPreModelData \u2243 TSet \u03b1 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castTSet (D\u2081 := newModelData) (D\u2082 := globalModelData) rfl\n    (by rw [globalModelData, motive_eq, constructMotive, globalLtData_eq])\n\n@[simp]\ntheorem newSetEquiv_forget {\u03b1 : \u039b}\n    (x : letI : Level := \u27e8\u03b1\u27e9; @TSet _ \u03b1 newModelData.toPreModelData) :\n    (newSetEquiv x)\u1d41 = x\u1d41 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castTSet_forget (D\u2081 := newModelData) (D\u2082 := globalModelData) _ x\n\ndef allPermEquiv {\u03b1 : \u039b} :\n    letI : Level := \u27e8\u03b1\u27e9\n    NewPerm \u2243 AllPerm \u03b1 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castAllPerm (D\u2081 := newModelData) (D\u2082 := globalModelData) rfl\n    (by rw [globalModelData, motive_eq, constructMotive, globalLtData_eq])\n\n@[simp]\ntheorem allPermEquiv_forget {\u03b1 : \u039b} (\u03c1 : letI : Level := \u27e8\u03b1\u27e9; NewPerm) :\n    (allPermEquiv \u03c1)\u1d41 = \u03c1\u1d41 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castAllPerm_forget (D\u2081 := newModelData) (D\u2082 := globalModelData) _ \u03c1\n\ntheorem allPermEquiv_sderiv {\u03b1 \u03b2 : \u039b}\n    (\u03c1 : letI : Level := \u27e8\u03b1\u27e9; NewPerm) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) :\n    letI : Level := \u27e8\u03b1\u27e9\n    letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n    allPermEquiv \u03c1 \u2198 h\u03b2 = \u03c1.sderiv \u03b2 := by\n  letI : Level := \u27e8\u03b1\u27e9\n  letI : LeLevel \u03b1 := \u27e8le_rfl\u27e9\n  letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n  apply allPermForget_injective\n  rw [allPermSderiv_forget, allPermEquiv_forget, NewPerm.forget_sderiv]\n\ntheorem TSet.exists_of_symmetric {\u03b1 \u03b2 : \u039b} (s : Set (TSet \u03b2)) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1)\n    (hs : Symmetric s h\u03b2) :\n    \u2203 x : TSet \u03b1, \u2200 y : TSet \u03b2, y \u2208[h\u03b2] x \u2194 y \u2208 s := by\n  letI : Level := \u27e8\u03b1\u27e9\n  letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n  suffices \u2203 x : (@TSet _ \u03b1 newModelData.toPreModelData), \u2200 y : TSet \u03b2, y\u1d41 \u2208[h\u03b2] x\u1d41 \u2194 y \u2208 s by\n    obtain \u27e8x, hx\u27e9 := this\n    use newSetEquiv x\n    intro y\n    rw [\u2190 hx, \u2190 TSet.forget_mem_forget, newSetEquiv_forget]\n  obtain rfl | hs' := s.eq_empty_or_nonempty\n  \u00b7 use none\n    intro y\n    simp only [Set.mem_empty_iff_false, iff_false]\n    exact not_mem_none y\n  \u00b7 use some (Code.toSet \u27e8\u03b2, s, hs'\u27e9 ?_)\n    \u00b7 intro y\n      erw [mem_some_iff]\n      exact Code.mem_toSet _\n    \u00b7 obtain \u27e8S, hS\u27e9 := hs\n      use S\n      intro \u03c1 h\u03c1S\n      have := hS (allPermEquiv \u03c1) ?_\n      \u00b7 simp only [NewPerm.smul_mk, Code.mk.injEq, heq_eq_eq, true_and]\n        rwa [allPermEquiv_sderiv] at this\n      \u00b7 rwa [allPermEquiv_forget]\n\ntheorem TSet.exists_support {\u03b1 : \u039b} (x : TSet \u03b1) :\n    \u2203 S : Support \u03b1, \u2200 \u03c1 : AllPerm \u03b1, \u03c1\u1d41 \u2022 S = S \u2192 \u03c1 \u2022 x = x := by\n  letI : Level := \u27e8\u03b1\u27e9\n  obtain \u27e8S, hS\u27e9 := NewSet.exists_support (newSetEquiv.symm x)\n  use S\n  intro \u03c1 h\u03c1\n  have := @Support.Supports.supports _ _ _ newPreModelData _ _ _ hS (allPermEquiv.symm \u03c1) ?_\n  \u00b7 apply tSetForget_injective\n    have := congr_arg (\u00b7\u1d41) this\n    simp only at this\n    erw [@smul_forget _ _ newModelData (allPermEquiv.symm \u03c1) (newSetEquiv.symm x),\n      \u2190 allPermEquiv_forget, \u2190 newSetEquiv_forget, Equiv.apply_symm_apply,\n      Equiv.apply_symm_apply] at this\n    rwa [smul_forget]\n  \u00b7 rwa [\u2190 allPermEquiv_forget, Equiv.apply_symm_apply]\n\ntheorem TSet.symmetric {\u03b1 \u03b2 : \u039b} (x : TSet \u03b1) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) :\n    Symmetric {y : TSet \u03b2 | y \u2208[h\u03b2] x} h\u03b2 := by\n  obtain \u27e8S, hS\u27e9 := exists_support x\n  use S\n  intro \u03c1 h\u03c1\n  conv_rhs => rw [\u2190 hS \u03c1 h\u03c1]\n  simp only [\u2190 forget_mem_forget, smul_forget, StrSet.mem_smul_iff]\n  ext y\n  rw [Set.mem_smul_set_iff_inv_smul_mem, Set.mem_setOf_eq, Set.mem_setOf_eq,\n    smul_forget, allPermForget_inv, allPermSderiv_forget']\n\ntheorem tSet_ext' {\u03b1 \u03b2 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (x y : TSet \u03b1)\n    (h : \u2200 z : TSet \u03b2, z \u2208[h\u03b2] x \u2194 z \u2208[h\u03b2] y) : x = y :=\n  letI : Level := \u27e8\u03b1\u27e9\n  letI : LeLevel \u03b1 := \u27e8le_rfl\u27e9\n  letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n  tSet_ext h\u03b2 x y h\n\n@[simp]\ntheorem TSet.mem_smul_iff' {\u03b1 \u03b2 : TypeIndex}\n    {x : TSet \u03b2} {y : TSet \u03b1} (h : \u03b2 < \u03b1) (\u03c1 : AllPerm \u03b1) :\n    x \u2208[h] \u03c1 \u2022 y \u2194 \u03c1\u207b\u00b9 \u2198 h \u2022 x \u2208[h] y := by\n  letI : Level := \u27e8\u03b1.recBotCoe (Nonempty.some inferInstance) id\u27e9\n  letI : LeLevel \u03b1 := \u27e8\u03b1.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n    (show \u03b1.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n  letI : LtLevel \u03b2 := \u27e8h.trans_le LeLevel.elim\u27e9\n  exact mem_smul_iff h \u03c1  -- For some reason, using `exact` instead of term mode speeds this up!\n\ndef singleton {\u03b1 \u03b2 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (x : TSet \u03b2) : TSet \u03b1 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  letI : LeLevel \u03b1 := \u27e8le_rfl\u27e9\n  letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n  PreCoherentData.singleton h\u03b2 x\n\n", "theoremStatement": "@[simp]\ntheorem typedMem_singleton_iff' {\u03b1 \u03b2 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (x y : TSet \u03b2) :\n    y \u2208[h\u03b2] singleton h\u03b2 x \u2194 y = x ", "theoremName": "ConNF.typedMem_singleton_iff'", "fileCreated": {"commit": "6fdc87c6b30b73931407a372f1430ecf0fef7601", "date": "2024-12-03"}, "theoremCreated": {"commit": "2e25ffbc94af48261308cea0d8c55205cc388ef0", "date": "2024-12-01"}, "file": "ConNF/ConNF/Model/TTT.lean", "module": "ConNF.Model.TTT", "jsonFile": "ConNF.Model.TTT.jsonl", "positionMetadata": {"lineInFile": 188, "tokenPositionInFile": 6551, "theoremPositionInFile": 16}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 17, "numPremises": 30}, "proofMetadata": {"hasProof": true, "proof": ":=\n  letI : Level := \u27e8\u03b1\u27e9\n  letI : LeLevel \u03b1 := \u27e8le_rfl\u27e9\n  letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n  typedMem_singleton_iff h\u03b2 x y", "proofType": "term", "proofLengthLines": 4, "proofLengthTokens": 114}}
{"srcContext": "import ConNF.Model.Hailperin\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal ConNF.TSet\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\ntheorem ext (x y : TSet \u03b1) :\n    (\u2200 z : TSet \u03b2, z \u2208' x \u2194 z \u2208' y) \u2192 x = y :=\n  tSet_ext' h\u03b2 x y\n\ndef inter (x y : TSet \u03b1) : TSet \u03b1 :=\n  (TSet.exists_inter h\u03b2 x y).choose\n\nnotation:69 x:69 \" \u2293[\" h \"] \" y:69 => _root_.ConNF.inter h x y\nnotation:69 x:69 \" \u2293' \" y:69 => x \u2293[by assumption] y\n\n@[simp]\ntheorem mem_inter_iff (x y : TSet \u03b1) :\n    \u2200 z : TSet \u03b2, z \u2208' x \u2293' y \u2194 z \u2208' x \u2227 z \u2208' y :=\n  (TSet.exists_inter h\u03b2 x y).choose_spec\n\ndef compl (x : TSet \u03b1) : TSet \u03b1 :=\n  (TSet.exists_compl h\u03b2 x).choose\n\nnotation:1024 x:1024 \" \u1d9c[\" h \"]\" => _root_.ConNF.compl h x\nnotation:1024 x:1024 \" \u1d9c'\" => x\u1d9c[by assumption]\n\n@[simp]\ntheorem mem_compl_iff (x : TSet \u03b1) :\n    \u2200 z : TSet \u03b2, z \u2208' x\u1d9c' \u2194 \u00acz \u2208' x :=\n  (TSet.exists_compl h\u03b2 x).choose_spec\n\nnotation:1024 \"{\" x \"}[\" h \"]\" => _root_.ConNF.singleton h x\nnotation:1024 \"{\" x \"}'\" => {x}[by assumption]\n\n@[simp]\ntheorem mem_singleton_iff (x y : TSet \u03b2) :\n    y \u2208' {x}' \u2194 y = x :=\n  typedMem_singleton_iff' h\u03b2 x y\n\nnotation:1024 \"{\" x \", \" y \"}[\" h \"]\" => _root_.ConNF.TSet.up h x y\nnotation:1024 \"{\" x \", \" y \"}'\" => {x, y}[by assumption]\n\n@[simp]\ntheorem mem_up_iff (x y z : TSet \u03b2) :\n    z \u2208' {x, y}' \u2194 z = x \u2228 z = y :=\n  TSet.mem_up_iff h\u03b2 x y z\n\nnotation:1024 \"\u27e8\" x \", \" y \"\u27e9[\" h \", \" h' \"]\" => _root_.ConNF.TSet.op h h' x y\nnotation:1024 \"\u27e8\" x \", \" y \"\u27e9'\" => \u27e8x, y\u27e9[by assumption, by assumption]\n\ntheorem op_def (x y : TSet \u03b3) :\n    (\u27e8x, y\u27e9' : TSet \u03b1) = { {x}', {x, y}' }' :=\n  rfl\n\ndef singletonImage' (x : TSet \u03b2) : TSet \u03b1 :=\n  (TSet.exists_singletonImage h\u03b2 h\u03b3 h\u03b4 h\u03b5 x).choose\n\n@[simp]\ntheorem singletonImage'_spec (x : TSet \u03b2) :\n    \u2200 z w,\n    \u27e8 {z}', {w}' \u27e9' \u2208' singletonImage' h\u03b2 h\u03b3 h\u03b4 h\u03b5 x \u2194 \u27e8z, w\u27e9' \u2208' x :=\n  (TSet.exists_singletonImage h\u03b2 h\u03b3 h\u03b4 h\u03b5 x).choose_spec\n\ndef insertion2' (x : TSet \u03b3) : TSet \u03b1 :=\n  (TSet.exists_insertion2 h\u03b2 h\u03b3 h\u03b4 h\u03b5 h\u03b6 x).choose\n\n@[simp]\ntheorem insertion2'_spec (x : TSet \u03b3) :\n    \u2200 a b c, \u27e8 { {a}' }', \u27e8b, c\u27e9' \u27e9' \u2208' insertion2' h\u03b2 h\u03b3 h\u03b4 h\u03b5 h\u03b6 x \u2194\n    \u27e8a, c\u27e9' \u2208' x :=\n  (TSet.exists_insertion2 h\u03b2 h\u03b3 h\u03b4 h\u03b5 h\u03b6 x).choose_spec\n\ndef insertion3' (x : TSet \u03b3) : TSet \u03b1 :=\n  (TSet.exists_insertion3 h\u03b2 h\u03b3 h\u03b4 h\u03b5 h\u03b6 x).choose\n\n", "theoremStatement": "theorem insertion3'_spec (x : TSet \u03b3) :\n    \u2200 a b c, \u27e8 { {a}' }', \u27e8b, c\u27e9' \u27e9' \u2208' insertion3' h\u03b2 h\u03b3 h\u03b4 h\u03b5 h\u03b6 x \u2194\n    \u27e8a, b\u27e9' \u2208' x ", "theoremName": "ConNF.insertion3'_spec", "fileCreated": {"commit": "b12701769822aaf5451982e26d7b7d1c2f21b137", "date": "2024-04-11"}, "theoremCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "file": "ConNF/ConNF/Model/Result.lean", "module": "ConNF.Model.Result", "jsonFile": "ConNF.Model.Result.jsonl", "positionMetadata": {"lineInFile": 93, "tokenPositionInFile": 2477, "theoremPositionInFile": 23}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 13, "numPremises": 25}, "proofMetadata": {"hasProof": true, "proof": ":=\n  (TSet.exists_insertion3 h\u03b2 h\u03b3 h\u03b4 h\u03b5 h\u03b6 x).choose_spec", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 58}}
{"srcContext": "import ConNF.External.Basic\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal ConNF.TSet\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\n/-- A set in our model that is a well-order. Internal well-orders are exactly external well-orders,\nso we externalise the definition for convenience. -/\ndef InternalWellOrder (r : TSet \u03b1) : Prop :=\n  IsWellOrder (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).field\n    (InvImage (ExternalRel h\u03b2 h\u03b3 h\u03b4 r) Subtype.val)\n\ndef InternallyWellOrdered (x : TSet \u03b3) : Prop :=\n  {y : TSet \u03b4 | y \u2208' x}.Subsingleton \u2228 (\u2203 r, InternalWellOrder h\u03b2 h\u03b3 h\u03b4 r \u2227 x = field h\u03b2 h\u03b3 h\u03b4 r)\n\n@[simp]\ntheorem externalRel_smul (r : TSet \u03b1) (\u03c1 : AllPerm \u03b1) :\n    ExternalRel h\u03b2 h\u03b3 h\u03b4 (\u03c1 \u2022 r) =\n      InvImage (ExternalRel h\u03b2 h\u03b3 h\u03b4 r) ((\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4)\u207b\u00b9 \u2022 \u00b7) := by\n  ext a b\n  simp only [ExternalRel, mem_smul_iff', allPerm_inv_sderiv', smul_op, InvImage]\n\nomit [Params] in\n/-- Well-orders are rigid. -/\ntheorem apply_eq_of_isWellOrder {X : Type _} {r : Rel X X} {f : X \u2192 X}\n    (hr : IsWellOrder X r) (hf : Function.Bijective f) (hf' : \u2200 x y, r x y \u2194 r (f x) (f y)) :\n    \u2200 x, f x = x := by\n  let emb : r \u227ci r := \u27e8\u27e8\u27e8f, hf.injective\u27e9, \u03bb {a b} \u21a6 (hf' a b).symm\u27e9, ?_\u27e9\n  \u00b7 have : emb = InitialSeg.refl r := Subsingleton.elim _ _\n    intro x\n    exact congr_arg (\u03bb f \u21a6 f x) this\n  \u00b7 intro a b h\n    exact hf.surjective _\n\nomit [Params] in\ntheorem apply_eq_of_isWellOrder' {X : Type _} {r : Rel X X} {f : X \u2192 X}\n    (hr : IsWellOrder r.field (InvImage r Subtype.val)) (hf : Function.Bijective f)\n    (hf' : \u2200 x y, r x y \u2194 r (f x) (f y)) :\n    \u2200 x \u2208 r.field, f x = x := by\n  have : \u2200 x \u2208 r.field, f x \u2208 r.field := by\n    rintro x (\u27e8y, h\u27e9 | \u27e8y, h\u27e9)\n    \u00b7 exact Or.inl \u27e8f y, (hf' x y).mp h\u27e9\n    \u00b7 exact Or.inr \u27e8f y, (hf' y x).mp h\u27e9\n  have := apply_eq_of_isWellOrder (f := \u03bb x \u21a6 \u27e8f x.val, this x.val x.prop\u27e9) hr \u27e8?_, ?_\u27e9 ?_\n  \u00b7 intro x hx\n    exact congr_arg Subtype.val (this \u27e8x, hx\u27e9)\n  \u00b7 intro x y h\n    rw [Subtype.mk.injEq] at h\n    exact Subtype.val_injective (hf.injective h)\n  \u00b7 intro x\n    obtain \u27e8y, hy\u27e9 := hf.surjective x.val\n    refine \u27e8\u27e8y, ?_\u27e9, ?_\u27e9\n    \u00b7 obtain (\u27e8z, h\u27e9 | \u27e8z, h\u27e9) := x.prop <;>\n          rw [\u2190 hy] at h <;>\n          obtain \u27e8z, rfl\u27e9 := hf.surjective z\n      \u00b7 exact Or.inl \u27e8z, (hf' y z).mpr h\u27e9\n      \u00b7 exact Or.inr \u27e8z, (hf' z y).mpr h\u27e9\n    \u00b7 simp only [hy]\n  \u00b7 intros\n    apply hf'\n\ntheorem exists_common_support_of_internallyWellOrdered' {x : TSet \u03b4}\n    (h : InternallyWellOrdered h\u03b3 h\u03b4 h\u03b5 x) :\n    \u2203 S : Support \u03b2, \u2200 y, y \u2208' x \u2192 S.Supports { { {y}' }' }[h\u03b3] := by\n  obtain (h | \u27e8r, h, rfl\u27e9) := h\n  \u00b7 obtain (h | \u27e8y, hy\u27e9) := h.eq_empty_or_singleton\n    \u00b7 use \u27e8Enumeration.empty, Enumeration.empty\u27e9\n      intro y hy\n      rw [Set.eq_empty_iff_forall_not_mem] at h\n      cases h y hy\n    \u00b7 obtain \u27e8S, hS\u27e9 := TSet.exists_support y\n      use S \u2197 h\u03b5 \u2197 h\u03b4 \u2197 h\u03b3\n      intro z hz\n      rw [Set.eq_singleton_iff_unique_mem] at hy\n      cases hy.2 z hz\n      refine \u27e8?_, \u03bb h \u21a6 by cases h\u27e9\n      intro \u03c1 h\u03c1\n      simp only [Support.smul_scoderiv, \u2190 allPermSderiv_forget', Support.scoderiv_inj] at h\u03c1\n      simp only [smul_singleton, singleton_inj]\n      exact hS _ h\u03c1\n  obtain \u27e8S, hS\u27e9 := TSet.exists_support r\n  use S\n  intro a ha\n  refine \u27e8?_, \u03bb h \u21a6 by cases h\u27e9\n  intro \u03c1 h\u03c1\n  have := hS \u03c1 h\u03c1\n  simp only [smul_singleton, singleton_inj]\n  apply apply_eq_of_isWellOrder' (r := ExternalRel h\u03b3 h\u03b4 h\u03b5 r)\n  \u00b7 exact h\n  \u00b7 exact MulAction.bijective (\u03c1 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5)\n  \u00b7 intro x y\n    conv_rhs => rw [\u2190 this]\n    simp only [externalRel_smul, InvImage, inv_smul_smul]\n  \u00b7 rwa [mem_field_iff] at ha\n\ninclude h\u03b3 in\ntheorem Support.Supports.ofSingleton {S : Support \u03b1} {x : TSet \u03b2}\n    (h : S.Supports {x}') :\n    letI : Level := \u27e8\u03b1\u27e9\n    letI : LeLevel \u03b1 := \u27e8le_rfl\u27e9\n    (S.strong \u2198 h\u03b2).Supports x := by\n  refine \u27e8?_, \u03bb h \u21a6 by cases h\u27e9\n  intro \u03c1 h\u03c1\n  open scoped Pointwise in\n  have := sUnion_singleton_symmetric_aux h\u03b3 h\u03b2 {y | y \u2208' x} S ?_ \u03c1 h\u03c1\n  \u00b7 apply ConNF.ext h\u03b3\n    intro z\n    simp only [Set.ext_iff, Set.mem_setOf_eq, Set.mem_smul_set_iff_inv_smul_mem] at this\n    rw [mem_smul_iff', allPerm_inv_sderiv', this]\n  \u00b7 intro \u03c1 h\u03c1\n    ext z\n    simp only [Set.mem_smul_set_iff_inv_smul_mem, Set.mem_image, Set.mem_setOf_eq]\n    have := h.supports \u03c1 h\u03c1\n    simp only [smul_singleton, singleton_inj] at this\n    constructor\n    \u00b7 rintro \u27e8y, h\u2081, h\u2082\u27e9\n      rw [\u2190 smul_eq_iff_eq_inv_smul, smul_singleton] at h\u2082\n      refine \u27e8_, ?_, h\u2082\u27e9\n      rw [\u2190 this]\n      simp only [mem_smul_iff', allPerm_inv_sderiv', inv_smul_smul]\n      exact h\u2081\n    \u00b7 rintro \u27e8y, h, rfl\u27e9\n      refine \u27e8(\u03c1 \u2198 h\u03b2 \u2198 h\u03b3)\u207b\u00b9 \u2022 y, ?_, ?_\u27e9\n      \u00b7 rwa [\u2190 allPerm_inv_sderiv', \u2190 mem_smul_iff', this]\n      \u00b7 simp only [smul_singleton, allPerm_inv_sderiv']\n\ninclude h\u03b3 in\ntheorem supports_of_supports_singletons {S : Support \u03b1} {s : Set (TSet \u03b2)}\n    (h : \u2200 x \u2208 s, S.Supports {x}') :\n    \u2203 S : Support \u03b2, \u2200 x \u2208 s, S.Supports x :=\n  \u27e8_, \u03bb x hx \u21a6 (h x hx).ofSingleton h\u03b2 h\u03b3\u27e9\n\ntheorem exists_common_support_of_internallyWellOrdered {x : TSet \u03b4}\n    (h : InternallyWellOrdered h\u03b3 h\u03b4 h\u03b5 x) :\n    \u2203 S : Support \u03b4, \u2200 y, y \u2208' x \u2192 S.Supports {y}' := by\n  obtain \u27e8S, hS\u27e9 := exists_common_support_of_internallyWellOrdered' h\u03b3 h\u03b4 h\u03b5 h\n  have := supports_of_supports_singletons (S := S)\n      (s := singleton h\u03b4 '' (singleton h\u03b5 '' {y | y \u2208' x})) h\u03b3 h\u03b4 ?_\n  swap\n  \u00b7 simp only [Set.mem_image, Set.mem_setOf_eq, exists_exists_and_eq_and, forall_exists_index,\n      and_imp, forall_apply_eq_imp_iff\u2082]\n    exact hS\n  obtain \u27e8T, hT\u27e9 := this\n  have := supports_of_supports_singletons (S := T)\n      (s := singleton h\u03b5 '' {y | y \u2208' x}) h\u03b4 h\u03b5 ?_\n  swap\n  \u00b7 simp only [Set.mem_image, Set.mem_setOf_eq, forall_exists_index, and_imp,\n      forall_apply_eq_imp_iff\u2082] at hT \u22a2\n    exact hT\n  simp only [Set.mem_image, Set.mem_setOf_eq, forall_exists_index, and_imp,\n    forall_apply_eq_imp_iff\u2082] at this\n  exact this\n\n", "theoremStatement": "theorem internallyWellOrdered_of_common_support_of_nontrivial {x : TSet \u03b3}\n    (hx : {y : TSet \u03b4 | y \u2208' x}.Nontrivial)\n    (S : Support \u03b4) (hS : \u2200 y : TSet \u03b4, y \u2208' x \u2192 S.Supports y) :\n    InternallyWellOrdered h\u03b2 h\u03b3 h\u03b4 x ", "theoremName": "ConNF.internallyWellOrdered_of_common_support_of_nontrivial", "fileCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "theoremCreated": {"commit": "1c08486feb882444888c228ce1501e92bb85e0e2", "date": "2025-01-07"}, "file": "ConNF/ConNF/External/WellOrder.lean", "module": "ConNF.External.WellOrder", "jsonFile": "ConNF.External.WellOrder.jsonl", "positionMetadata": {"lineInFile": 170, "tokenPositionInFile": 5987, "theoremPositionInFile": 9}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 46, "numPremises": 139}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  have := exists_of_symmetric\n      {p : TSet \u03b2 | \u2203 a b : TSet \u03b4, p = \u27e8a, b\u27e9' \u2227 a \u2208' x \u2227 b \u2208' x \u2227 WellOrderingRel a b} h\u03b2 ?_\n  swap\n  \u00b7 use S \u2197 h\u03b4 \u2197 h\u03b3 \u2197 h\u03b2\n    intro \u03c1 h\u03c1\n    ext z\n    simp only [Support.smul_scoderiv, \u2190 allPermSderiv_forget', Support.scoderiv_inj] at h\u03c1\n    simp only [Set.mem_smul_set_iff_inv_smul_mem, Set.mem_setOf_eq]\n    constructor\n    \u00b7 rintro \u27e8a, b, h\u2081, h\u2082, h\u2083, h\u2084\u27e9\n      refine \u27e8a, b, ?_, h\u2082, h\u2083, h\u2084\u27e9\n      rw [inv_smul_eq_iff] at h\u2081\n      rw [h\u2081, smul_op, op_inj]\n      exact \u27e8(hS a h\u2082).supports _ h\u03c1, (hS b h\u2083).supports _ h\u03c1\u27e9\n    \u00b7 rintro \u27e8a, b, h\u2081, h\u2082, h\u2083, h\u2084\u27e9\n      refine \u27e8a, b, ?_, h\u2082, h\u2083, h\u2084\u27e9\n      rw [h\u2081, smul_op, op_inj]\n      simp only [allPerm_inv_sderiv', inv_smul_eq_iff]\n      rw [(hS a h\u2082).supports _ h\u03c1, (hS b h\u2083).supports _ h\u03c1]\n      exact \u27e8rfl, rfl\u27e9\n  obtain \u27e8r, hr\u27e9 := this\n  right\n  use r\n  have hr' : \u2200 a b, ExternalRel h\u03b2 h\u03b3 h\u03b4 r a b \u2194 a \u2208' x \u2227 b \u2208' x \u2227 WellOrderingRel a b := by\n    intro a b\n    rw [ExternalRel, hr]\n    simp only [Set.mem_setOf_eq, op_inj]\n    constructor\n    \u00b7 rintro \u27e8a, b, \u27e8rfl, rfl\u27e9, h\u27e9\n      exact h\n    \u00b7 intro h\n      exact \u27e8a, b, \u27e8rfl, rfl\u27e9, h\u27e9\n  have hrx : \u2200 a, a \u2208 (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).field \u2194 a \u2208' x := by\n    intro a\n    constructor\n    \u00b7 rintro (\u27e8b, h\u27e9 | \u27e8b, h\u27e9)\n      \u00b7 rw [hr'] at h\n        exact h.1\n      \u00b7 rw [hr'] at h\n        exact h.2.1\n    \u00b7 intro h\n      obtain \u27e8b, h\u2081, h\u2082\u27e9 := hx.exists_ne a\n      obtain (h\u2083 | h\u2083 | h\u2083) := WellOrderingRel.isWellOrder.trichotomous a b\n      \u00b7 refine Or.inl \u27e8b, ?_\u27e9\n        rw [hr']\n        exact \u27e8h, h\u2081, h\u2083\u27e9\n      \u00b7 cases h\u2082 h\u2083.symm\n      \u00b7 refine Or.inr \u27e8b, ?_\u27e9\n        rw [hr']\n        exact \u27e8h\u2081, h, h\u2083\u27e9\n  refine \u27e8?_, ?_\u27e9\n  swap\n  \u00b7 apply ext h\u03b4\n    intro z\n    rw [mem_field_iff, hrx]\n  refine @IsWellOrder.mk _ _ ?_ ?_ ?_\n  \u00b7 constructor\n    intro a b\n    obtain (h | h | h) := WellOrderingRel.isWellOrder.trichotomous a.val b.val\n    \u00b7 apply Or.inl\n      rw [InvImage, hr']\n      exact \u27e8(hrx a).mp a.prop, (hrx b).mp b.prop, h\u27e9\n    \u00b7 exact Or.inr (Or.inl (Subtype.val_injective h))\n    \u00b7 apply Or.inr \u2218 Or.inr\n      rw [InvImage, hr']\n      exact \u27e8(hrx b).mp b.prop, (hrx a).mp a.prop, h\u27e9\n  \u00b7 constructor\n    intro a b c h\u2081 h\u2082\n    rw [InvImage, hr'] at h\u2081 h\u2082 \u22a2\n    exact \u27e8h\u2081.1, h\u2082.2.1, WellOrderingRel.isWellOrder.trans _ _ _ h\u2081.2.2 h\u2082.2.2\u27e9\n  \u00b7 constructor\n    apply InvImage.wf\n    refine Subrelation.wf ?_ WellOrderingRel.isWellOrder.wf\n    intro a b h\n    rw [hr'] at h\n    exact h.2.2", "proofType": "tactic", "proofLengthLines": 76, "proofLengthTokens": 2430}}
{"srcContext": "import ConNF.ModelData.PathEnumeration\n\n/-!\n# Supports\n\nIn this file, we define the notion of a support.\n\n## Main declarations\n\n* `ConNF.BaseSupport`: The type of supports of atoms.\n* `ConNF.Support`: The type of supports of objects of arbitrary type indices.\n-/\n\nuniverse u\n\nopen Cardinal\n\nnamespace ConNF\n\nvariable [Params.{u}]\n\n/-!\n## Base supports\n-/\n\nstructure BaseSupport where\n  atoms : Enumeration Atom\n  nearLitters : Enumeration NearLitter\n\nnamespace BaseSupport\n\ninstance : SuperA BaseSupport (Enumeration Atom) where\n  superA := atoms\n\ninstance : SuperN BaseSupport (Enumeration NearLitter) where\n  superN := nearLitters\n\n@[simp]\ntheorem mk_atoms {a : Enumeration Atom} {N : Enumeration NearLitter} :\n    (BaseSupport.mk a N)\u1d2c = a :=\n  rfl\n\n@[simp]\ntheorem mk_nearLitters {a : Enumeration Atom} {N : Enumeration NearLitter} :\n    (BaseSupport.mk a N)\u1d3a = N :=\n  rfl\n\ntheorem atoms_congr {S T : BaseSupport} (h : S = T) :\n    S\u1d2c = T\u1d2c :=\n  h \u25b8 rfl\n\ntheorem nearLitters_congr {S T : BaseSupport} (h : S = T) :\n    S\u1d3a = T\u1d3a :=\n  h \u25b8 rfl\n\n@[ext]\ntheorem ext {S T : BaseSupport} (h\u2081 : S\u1d2c = T\u1d2c) (h\u2082 : S\u1d3a = T\u1d3a) : S = T := by\n  obtain \u27e8SA, SN\u27e9 := S\n  obtain \u27e8TA, TN\u27e9 := T\n  cases h\u2081\n  cases h\u2082\n  rfl\n\ninstance : SMul BasePerm BaseSupport where\n  smul \u03c0 S := \u27e8\u03c0 \u2022 S\u1d2c, \u03c0 \u2022 S\u1d3a\u27e9\n\n@[simp]\ntheorem smul_atoms (\u03c0 : BasePerm) (S : BaseSupport) :\n    (\u03c0 \u2022 S)\u1d2c = \u03c0 \u2022 S\u1d2c :=\n  rfl\n\n@[simp]\ntheorem smul_nearLitters (\u03c0 : BasePerm) (S : BaseSupport) :\n    (\u03c0 \u2022 S)\u1d3a = \u03c0 \u2022 S\u1d3a :=\n  rfl\n\n@[simp]\ntheorem smul_atoms_eq_of_smul_eq {\u03c0 : BasePerm} {S : BaseSupport}\n    (h : \u03c0 \u2022 S = S) :\n    \u03c0 \u2022 S\u1d2c = S\u1d2c := by\n  rw [\u2190 smul_atoms, h]\n\n@[simp]\ntheorem smul_nearLitters_eq_of_smul_eq {\u03c0 : BasePerm} {S : BaseSupport}\n    (h : \u03c0 \u2022 S = S) :\n    \u03c0 \u2022 S\u1d3a = S\u1d3a := by\n  rw [\u2190 smul_nearLitters, h]\n\ninstance : MulAction BasePerm BaseSupport where\n  one_smul S := by\n    apply ext\n    \u00b7 rw [smul_atoms, one_smul]\n    \u00b7 rw [smul_nearLitters, one_smul]\n  mul_smul \u03c0\u2081 \u03c0\u2082 S := by\n    apply ext\n    \u00b7 rw [smul_atoms, smul_atoms, smul_atoms, mul_smul]\n    \u00b7 rw [smul_nearLitters, smul_nearLitters, smul_nearLitters, mul_smul]\n\ntheorem smul_eq_smul_iff (\u03c0\u2081 \u03c0\u2082 : BasePerm) (S : BaseSupport) :\n    \u03c0\u2081 \u2022 S = \u03c0\u2082 \u2022 S \u2194 (\u2200 a \u2208 S\u1d2c, \u03c0\u2081 \u2022 a = \u03c0\u2082 \u2022 a) \u2227 (\u2200 N \u2208 S\u1d3a, \u03c0\u2081 \u2022 N = \u03c0\u2082 \u2022 N) := by\n  constructor\n  \u00b7 intro h\n    constructor\n    \u00b7 rintro a \u27e8i, ha\u27e9\n      have := congr_arg (\u00b7\u1d2c.rel i (\u03c0\u2081 \u2022 a)) h\n      simp only [smul_atoms, Enumeration.smul_rel, inv_smul_smul, eq_iff_iff] at this\n      have := S\u1d2c.rel_coinjective.coinjective ha (this.mp ha)\n      rw [eq_inv_smul_iff] at this\n      rw [this]\n    \u00b7 rintro N \u27e8i, hN\u27e9\n      have := congr_arg (\u00b7\u1d3a.rel i (\u03c0\u2081 \u2022 N)) h\n      simp only [smul_nearLitters, Enumeration.smul_rel, inv_smul_smul, eq_iff_iff] at this\n      have := S\u1d3a.rel_coinjective.coinjective hN (this.mp hN)\n      rw [eq_inv_smul_iff] at this\n      rw [this]\n  \u00b7 intro h\n    ext : 2\n    \u00b7 rfl\n    \u00b7 ext i a : 3\n      rw [smul_atoms, smul_atoms, Enumeration.smul_rel, Enumeration.smul_rel]\n      constructor\n      \u00b7 intro ha\n        have := h.1 _ \u27e8i, ha\u27e9\n        rw [smul_inv_smul, \u2190 inv_smul_eq_iff] at this\n        rwa [this]\n      \u00b7 intro ha\n        have := h.1 _ \u27e8i, ha\u27e9\n        rw [smul_inv_smul, smul_eq_iff_eq_inv_smul] at this\n        rwa [\u2190 this]\n    \u00b7 rfl\n    \u00b7 ext i a : 3\n      rw [smul_nearLitters, smul_nearLitters, Enumeration.smul_rel, Enumeration.smul_rel]\n      constructor\n      \u00b7 intro hN\n        have := h.2 _ \u27e8i, hN\u27e9\n        rw [smul_inv_smul, \u2190 inv_smul_eq_iff] at this\n        rwa [this]\n      \u00b7 intro hN\n        have := h.2 _ \u27e8i, hN\u27e9\n        rw [smul_inv_smul, smul_eq_iff_eq_inv_smul] at this\n        rwa [\u2190 this]\n\ntheorem smul_eq_iff (\u03c0 : BasePerm) (S : BaseSupport) :\n    \u03c0 \u2022 S = S \u2194 (\u2200 a \u2208 S\u1d2c, \u03c0 \u2022 a = a) \u2227 (\u2200 N \u2208 S\u1d3a, \u03c0 \u2022 N = N) := by\n  have := smul_eq_smul_iff \u03c0 1 S\n  simp only [one_smul] at this\n  exact this\n\nnoncomputable instance : Add BaseSupport where\n  add S T := \u27e8S\u1d2c + T\u1d2c, S\u1d3a + T\u1d3a\u27e9\n\n@[simp]\ntheorem add_atoms (S T : BaseSupport) :\n    (S + T)\u1d2c = S\u1d2c + T\u1d2c :=\n  rfl\n\n@[simp]\ntheorem add_nearLitters (S T : BaseSupport) :\n    (S + T)\u1d3a = S\u1d3a + T\u1d3a :=\n  rfl\n\nend BaseSupport\n\ndef baseSupportEquiv : BaseSupport \u2243 Enumeration Atom \u00d7 Enumeration NearLitter where\n  toFun S := (S\u1d2c, S\u1d3a)\n  invFun S := \u27e8S.1, S.2\u27e9\n  left_inv _ := rfl\n  right_inv _ := rfl\n\ntheorem card_baseSupport : #BaseSupport = #\u03bc := by\n  rw [Cardinal.eq.mpr \u27e8baseSupportEquiv\u27e9, mk_prod, lift_id, lift_id,\n    card_enumeration_eq card_atom, card_enumeration_eq card_nearLitter, mul_eq_self aleph0_lt_\u03bc.le]\n\n/-!\n## Structural supports\n-/\n\nstructure Support (\u03b1 : TypeIndex) where\n  atoms : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)\n  nearLitters : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)\n\nnamespace Support\n\nvariable {\u03b1 \u03b2 : TypeIndex}\n\ninstance : SuperA (Support \u03b1) (Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) where\n  superA := atoms\n\ninstance : SuperN (Support \u03b1) (Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) where\n  superN := nearLitters\n\n@[simp]\ntheorem mk_atoms (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) (F : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) :\n    (\u27e8E, F\u27e9 : Support \u03b1)\u1d2c = E :=\n  rfl\n\n@[simp]\ntheorem mk_nearLitters (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) (F : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) :\n    (\u27e8E, F\u27e9 : Support \u03b1)\u1d3a = F :=\n  rfl\n\ninstance : Derivative (Support \u03b1) (Support \u03b2) \u03b1 \u03b2 where\n  deriv S A := \u27e8S\u1d2c \u21d8 A, S\u1d3a \u21d8 A\u27e9\n\ninstance : Coderivative (Support \u03b2) (Support \u03b1) \u03b1 \u03b2 where\n  coderiv S A := \u27e8S\u1d2c \u21d7 A, S\u1d3a \u21d7 A\u27e9\n\ninstance : BotDerivative (Support \u03b1) BaseSupport \u03b1 where\n  botDeriv S A := \u27e8S\u1d2c \u21d8. A, S\u1d3a \u21d8. A\u27e9\n  botSderiv S := \u27e8S\u1d2c \u2198., S\u1d3a \u2198.\u27e9\n  botDeriv_single S h := by dsimp only; rw [botDeriv_single, botDeriv_single]\n\n@[simp]\ntheorem deriv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u03b2) :\n    S\u1d2c \u21d8 A = (S \u21d8 A)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem deriv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u03b2) :\n    S\u1d3a \u21d8 A = (S \u21d8 A)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem sderiv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (h : \u03b2 < \u03b1) :\n    S\u1d2c \u2198 h = (S \u2198 h)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem sderiv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (h : \u03b2 < \u03b1) :\n    S\u1d3a \u2198 h = (S \u2198 h)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem coderiv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    S\u1d2c \u21d7 A = (S \u21d7 A)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem coderiv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    S\u1d3a \u21d7 A = (S \u21d7 A)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem scoderiv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (h : \u03b2 < \u03b1) :\n    S\u1d2c \u2197 h = (S \u2197 h)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem scoderiv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (h : \u03b2 < \u03b1) :\n    S\u1d3a \u2197 h = (S \u2197 h)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem derivBot_atoms {\u03b1 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u22a5) :\n    S\u1d2c \u21d8. A = (S \u21d8. A)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem derivBot_nearLitters {\u03b1 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u22a5) :\n    S\u1d3a \u21d8. A = (S \u21d8. A)\u1d3a :=\n  rfl\n\ntheorem ext' {S T : Support \u03b1} (h\u2081 : S\u1d2c = T\u1d2c) (h\u2082 : S\u1d3a = T\u1d3a) : S = T := by\n  obtain \u27e8SA, SN\u27e9 := S\n  obtain \u27e8TA, TN\u27e9 := T\n  cases h\u2081\n  cases h\u2082\n  rfl\n\n@[ext]\ntheorem ext {S T : Support \u03b1} (h : \u2200 A, S \u21d8. A = T \u21d8. A) : S = T := by\n  obtain \u27e8SA, SN\u27e9 := S\n  obtain \u27e8TA, TN\u27e9 := T\n  rw [mk.injEq]\n  constructor\n  \u00b7 apply Enumeration.ext_path\n    intro A\n    exact BaseSupport.atoms_congr (h A)\n  \u00b7 apply Enumeration.ext_path\n    intro A\n    exact BaseSupport.nearLitters_congr (h A)\n\n@[simp]\ntheorem deriv_derivBot {\u03b1 : TypeIndex} (S : Support \u03b1)\n    (A : \u03b1 \u219d \u03b2) (B : \u03b2 \u219d \u22a5) :\n    S \u21d8 A \u21d8. B = S \u21d8. (A \u21d8 B) :=\n  rfl\n\n@[simp]\ntheorem coderiv_deriv_eq {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    S \u21d7 A \u21d8 A = S :=\n  ext' (S\u1d2c.coderiv_deriv_eq A) (S\u1d3a.coderiv_deriv_eq A)\n\n", "theoremStatement": "theorem eq_of_atom_mem_scoderiv_botDeriv {\u03b1 \u03b2 : TypeIndex} {S : Support \u03b2} {A : \u03b1 \u219d \u22a5}\n    {h : \u03b2 < \u03b1} {a : Atom} (ha : a \u2208 (S \u2197 h \u21d8. A)\u1d2c) :\n    \u2203 B : \u03b2 \u219d \u22a5, A = B \u2197 h ", "theoremName": "ConNF.Support.eq_of_atom_mem_scoderiv_botDeriv", "fileCreated": {"commit": "39c33b4a743bea62dbcc549548b712ffd38ca65c", "date": "2024-12-05"}, "theoremCreated": {"commit": "6709914ae7f5cd3e2bb24b413e09aa844554d234", "date": "2024-11-30"}, "file": "ConNF/ConNF/ModelData/Support.lean", "module": "ConNF.ModelData.Support", "jsonFile": "ConNF.ModelData.Support.jsonl", "positionMetadata": {"lineInFile": 294, "tokenPositionInFile": 7414, "theoremPositionInFile": 30}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 6, "repositoryPremises": true, "numRepositoryPremises": 21, "numPremises": 35}, "proofMetadata": {"hasProof": true, "proof": ":=\n  Enumeration.eq_of_mem_scoderiv_botDeriv ha", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 47}}
{"srcContext": "import ConNF.External.Basic\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal ConNF.TSet\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\n/-- A set in our model that is a well-order. Internal well-orders are exactly external well-orders,\nso we externalise the definition for convenience. -/\ndef InternalWellOrder (r : TSet \u03b1) : Prop :=\n  IsWellOrder (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).field\n    (InvImage (ExternalRel h\u03b2 h\u03b3 h\u03b4 r) Subtype.val)\n\ndef InternallyWellOrdered (x : TSet \u03b3) : Prop :=\n  {y : TSet \u03b4 | y \u2208' x}.Subsingleton \u2228 (\u2203 r, InternalWellOrder h\u03b2 h\u03b3 h\u03b4 r \u2227 x = field h\u03b2 h\u03b3 h\u03b4 r)\n\n@[simp]\ntheorem externalRel_smul (r : TSet \u03b1) (\u03c1 : AllPerm \u03b1) :\n    ExternalRel h\u03b2 h\u03b3 h\u03b4 (\u03c1 \u2022 r) =\n      InvImage (ExternalRel h\u03b2 h\u03b3 h\u03b4 r) ((\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4)\u207b\u00b9 \u2022 \u00b7) := by\n  ext a b\n  simp only [ExternalRel, mem_smul_iff', allPerm_inv_sderiv', smul_op, InvImage]\n\nomit [Params] in\n", "theoremStatement": "/-- Well-orders are rigid. -/\ntheorem apply_eq_of_isWellOrder {X : Type _} {r : Rel X X} {f : X \u2192 X}\n    (hr : IsWellOrder X r) (hf : Function.Bijective f) (hf' : \u2200 x y, r x y \u2194 r (f x) (f y)) :\n    \u2200 x, f x = x ", "theoremName": "ConNF.apply_eq_of_isWellOrder", "fileCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "theoremCreated": {"commit": "1c08486feb882444888c228ce1501e92bb85e0e2", "date": "2025-01-07"}, "file": "ConNF/ConNF/External/WellOrder.lean", "module": "ConNF.External.WellOrder", "jsonFile": "ConNF.External.WellOrder.jsonl", "positionMetadata": {"lineInFile": 40, "tokenPositionInFile": 1106, "theoremPositionInFile": 3}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 21}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  let emb : r \u227ci r := \u27e8\u27e8\u27e8f, hf.injective\u27e9, \u03bb {a b} \u21a6 (hf' a b).symm\u27e9, ?_\u27e9\n  \u00b7 have : emb = InitialSeg.refl r := Subsingleton.elim _ _\n    intro x\n    exact congr_arg (\u03bb f \u21a6 f x) this\n  \u00b7 intro a b h\n    exact hf.surjective _", "proofType": "tactic", "proofLengthLines": 6, "proofLengthTokens": 230}}
{"srcContext": "import ConNF.Model.RunInduction\n\n/-!\n# Externalisation\n\nIn this file, we convert many of our *internal* results (i.e. inside the induction) to *external*\nones (i.e. defined using the global `TSet`/`AllPerm` definitions).\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal WithBot\n\nnamespace ConNF\n\nvariable [Params.{u}]\n\ninstance globalModelData : {\u03b1 : TypeIndex} \u2192 ModelData \u03b1\n  | (\u03b1 : \u039b) => (motive \u03b1).data\n  | \u22a5 => botModelData\n\ninstance globalPosition : {\u03b1 : TypeIndex} \u2192 Position (Tangle \u03b1)\n  | (\u03b1 : \u039b) => (motive \u03b1).pos\n  | \u22a5 => botPosition\n\ninstance globalTypedNearLitters {\u03b1 : \u039b} : TypedNearLitters \u03b1 :=\n  (motive \u03b1).typed\n\ninstance globalLtData [Level] : LtData where\n\ninstance globalLeData [Level] : LeData where\n\nomit [Params] in\ntheorem heq_funext {\u03b1 : Sort _} {\u03b2 \u03b3 : \u03b1 \u2192 Sort _} {f : (x : \u03b1) \u2192 \u03b2 x} {g : (x : \u03b1) \u2192 \u03b3 x}\n    (h : \u2200 x, HEq (f x) (g x)) : HEq f g := by\n  cases funext \u03bb x \u21a6 type_eq_of_heq (h x)\n  simp only [heq_eq_eq] at h \u22a2\n  exact funext h\n\n", "theoremStatement": "theorem globalLtData_eq [Level] :\n    globalLtData = ltData (\u03bb \u03b2 _ \u21a6 motive \u03b2) ", "theoremName": "ConNF.globalLtData_eq", "fileCreated": {"commit": "6fdc87c6b30b73931407a372f1430ecf0fef7601", "date": "2024-12-03"}, "theoremCreated": {"commit": "75a59b81a56dda9d4494ecfa54a8354c680a0c7c", "date": "2024-12-01"}, "file": "ConNF/ConNF/Model/Externalise.lean", "module": "ConNF.Model.Externalise", "jsonFile": "ConNF.Model.Externalise.jsonl", "positionMetadata": {"lineInFile": 45, "tokenPositionInFile": 1032, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 21, "numPremises": 39}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  apply LtData.ext\n  \u00b7 ext \u03b2 h\u03b2\n    induction \u03b2 using recBotCoe\n    case bot => rfl\n    case coe \u03b2 => rfl\n  \u00b7 apply heq_funext\n    intro \u03b2\n    induction \u03b2 using recBotCoe\n    case bot => rfl\n    case coe \u03b2 => rfl\n  \u00b7 rfl", "proofType": "tactic", "proofLengthLines": 11, "proofLengthTokens": 226}}
{"srcContext": "import ConNF.Model.TTT\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\nnamespace TSet\n\ntheorem exists_inter (x y : TSet \u03b1) :\n    \u2203 w : TSet \u03b1, \u2200 z : TSet \u03b2, z \u2208[h\u03b2] w \u2194 z \u2208[h\u03b2] x \u2227 z \u2208[h\u03b2] y := by\n  refine exists_of_symmetric {z | z \u2208[h\u03b2] x \u2227 z \u2208[h\u03b2] y} h\u03b2 ?_\n  obtain \u27e8S, hS\u27e9 := symmetric x h\u03b2\n  obtain \u27e8T, hT\u27e9 := symmetric y h\u03b2\n  use S + T\n  intro \u03c1 h\u03c1\n  specialize hS \u03c1 (smul_eq_of_le Support.le_add_right h\u03c1)\n  specialize hT \u03c1 (smul_eq_of_le Support.le_add_left h\u03c1)\n  simp [Set.ext_iff, Set.mem_smul_set_iff_inv_smul_mem] at hS hT \u22a2\n  aesop\n\ntheorem exists_compl (x : TSet \u03b1) :\n    \u2203 y : TSet \u03b1, \u2200 z : TSet \u03b2, z \u2208[h\u03b2] y \u2194 \u00acz \u2208[h\u03b2] x := by\n  refine exists_of_symmetric {z | \u00acz \u2208[h\u03b2] x} h\u03b2 ?_\n  obtain \u27e8S, hS\u27e9 := symmetric x h\u03b2\n  use S\n  intro \u03c1 h\u03c1\n  specialize hS \u03c1 h\u03c1\n  simp [Set.ext_iff, Set.mem_smul_set_iff_inv_smul_mem] at hS \u22a2\n  aesop\n\ntheorem exists_up (x y : TSet \u03b2) :\n    \u2203 w : TSet \u03b1, \u2200 z : TSet \u03b2, z \u2208[h\u03b2] w \u2194 z = x \u2228 z = y := by\n  refine exists_of_symmetric {x, y} h\u03b2 ?_\n  obtain \u27e8S, hS\u27e9 := exists_support x\n  obtain \u27e8T, hT\u27e9 := exists_support y\n  use (S + T) \u2197 h\u03b2\n  intro \u03c1 h\u03c1\n  rw [Support.smul_scoderiv, Support.scoderiv_inj, \u2190 allPermSderiv_forget'] at h\u03c1\n  specialize hS (\u03c1 \u2198 h\u03b2) (smul_eq_of_le Support.le_add_right h\u03c1)\n  specialize hT (\u03c1 \u2198 h\u03b2) (smul_eq_of_le Support.le_add_left h\u03c1)\n  simp only [Set.smul_set_def, Set.image, Set.mem_insert_iff, Set.mem_singleton_iff,\n    exists_eq_or_imp, hS, exists_eq_left, hT]\n  ext z\n  rw [Set.mem_insert_iff, Set.mem_singleton_iff, Set.mem_setOf_eq]\n  aesop\n\n/-- The unordered pair. -/\ndef up (x y : TSet \u03b2) : TSet \u03b1 :=\n  (exists_up h\u03b2 x y).choose\n\n@[simp]\ntheorem mem_up_iff (x y z : TSet \u03b2) :\n    z \u2208[h\u03b2] up h\u03b2 x y \u2194 z = x \u2228 z = y :=\n  (exists_up h\u03b2 x y).choose_spec z\n\n/-- The Kuratowski ordered pair. -/\ndef op (x y : TSet \u03b3) : TSet \u03b1 :=\n  up h\u03b2 (singleton h\u03b3 x) (up h\u03b3 x y)\n\ntheorem up_injective {x y z w : TSet \u03b2} (h : up h\u03b2 x y = up h\u03b2 z w) :\n    (x = z \u2227 y = w) \u2228 (x = w \u2227 y = z) := by\n  have h\u2081 := mem_up_iff h\u03b2 x y z\n  have h\u2082 := mem_up_iff h\u03b2 x y w\n  have h\u2083 := mem_up_iff h\u03b2 z w x\n  have h\u2084 := mem_up_iff h\u03b2 z w y\n  rw [h, mem_up_iff] at h\u2081 h\u2082\n  rw [\u2190 h, mem_up_iff] at h\u2083 h\u2084\n  aesop\n\n@[simp]\ntheorem up_inj (x y z w : TSet \u03b2) :\n    up h\u03b2 x y = up h\u03b2 z w \u2194 (x = z \u2227 y = w) \u2228 (x = w \u2227 y = z) := by\n  constructor\n  \u00b7 exact up_injective h\u03b2\n  \u00b7 rintro (\u27e8rfl, rfl\u27e9 | \u27e8rfl, rfl\u27e9)\n    \u00b7 rfl\n    \u00b7 apply tSet_ext' h\u03b2\n      aesop\n\n@[simp]\ntheorem up_self {x : TSet \u03b2} :\n    up h\u03b2 x x = singleton h\u03b2 x := by\n  apply tSet_ext' h\u03b2\n  aesop\n\n@[simp]\ntheorem up_eq_singleton_iff (x y z : TSet \u03b2) :\n    up h\u03b2 x y = singleton h\u03b2 z \u2194 x = z \u2227 y = z := by\n  constructor\n  \u00b7 intro h\n    have h\u2081 := typedMem_singleton_iff' h\u03b2 z x\n    have h\u2082 := typedMem_singleton_iff' h\u03b2 z y\n    rw [\u2190 h, mem_up_iff] at h\u2081 h\u2082\n    aesop\n  \u00b7 rintro \u27e8rfl, rfl\u27e9\n    rw [up_self]\n\n@[simp]\ntheorem singleton_eq_up_iff (x y z : TSet \u03b2) :\n    singleton h\u03b2 z = up h\u03b2 x y \u2194 x = z \u2227 y = z := by\n  rw [\u2190 up_eq_singleton_iff h\u03b2 x y z, eq_comm]\n\ntheorem op_injective {x y z w : TSet \u03b3} (h : op h\u03b2 h\u03b3 x y = op h\u03b2 h\u03b3 z w) :\n    x = z \u2227 y = w := by\n  rw [op, op] at h\n  simp only [up_inj, singleton_inj, singleton_eq_up_iff, up_eq_singleton_iff] at h\n  obtain (\u27e8rfl, \u27e8h, rfl\u27e9 | \u27e8rfl, rfl\u27e9\u27e9 | \u27e8\u27e8rfl, rfl\u27e9, \u27e8h, rfl\u27e9\u27e9) := h <;> simp only [and_self]\n\n@[simp]\ntheorem op_inj (x y z w : TSet \u03b3) :\n    op h\u03b2 h\u03b3 x y = op h\u03b2 h\u03b3 z w \u2194 x = z \u2227 y = w := by\n  constructor\n  \u00b7 exact op_injective h\u03b2 h\u03b3\n  \u00b7 rintro \u27e8rfl, rfl\u27e9\n    rfl\n\n@[simp]\ntheorem op_eq_singleton_iff (x y : TSet \u03b3) (z : TSet \u03b2) :\n    op h\u03b2 h\u03b3 x y = singleton h\u03b2 z \u2194 singleton h\u03b3 x = z \u2227 singleton h\u03b3 y = z := by\n  rw [op, up_eq_singleton_iff, and_congr_right_iff]\n  rintro rfl\n  simp only [up_eq_singleton_iff, true_and, singleton_inj]\n\n@[simp]\ntheorem smul_up (x y : TSet \u03b2) (\u03c1 : AllPerm \u03b1) :\n    \u03c1 \u2022 up h\u03b2 x y = up h\u03b2 (\u03c1 \u2198 h\u03b2 \u2022 x) (\u03c1 \u2198 h\u03b2 \u2022 y) := by\n  apply tSet_ext' h\u03b2\n  aesop\n\n@[simp]\ntheorem smul_op (x y : TSet \u03b3) (\u03c1 : AllPerm \u03b1) :\n    \u03c1 \u2022 op h\u03b2 h\u03b3 x y = op h\u03b2 h\u03b3 (\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2022 x) (\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2022 y) := by\n  apply tSet_ext' h\u03b2\n  simp only [op, smul_up, smul_singleton, mem_up_iff, implies_true]\n\ntheorem exists_singletonImage (x : TSet \u03b2) :\n    \u2203 y : TSet \u03b1, \u2200 z w,\n    op h\u03b3 h\u03b4 (singleton h\u03b5 z) (singleton h\u03b5 w) \u2208[h\u03b2] y \u2194 op h\u03b4 h\u03b5 z w \u2208[h\u03b3] x := by\n  have := exists_of_symmetric {u | \u2203 z w : TSet \u03b5, op h\u03b4 h\u03b5 z w \u2208[h\u03b3] x \u2227\n      u = op h\u03b3 h\u03b4 (singleton h\u03b5 z) (singleton h\u03b5 w)} h\u03b2 ?_\n  \u00b7 obtain \u27e8y, hy\u27e9 := this\n    use y\n    intro z w\n    rw [hy]\n    simp only [Set.mem_setOf_eq, op_inj, singleton_inj, exists_eq_right_right', exists_eq_right']\n  \u00b7 obtain \u27e8S, hS\u27e9 := exists_support x\n    use S \u2197 h\u03b2\n    intro \u03c1 h\u03c1\n    rw [Support.smul_scoderiv, Support.scoderiv_inj, \u2190 allPermSderiv_forget'] at h\u03c1\n    specialize hS (\u03c1 \u2198 h\u03b2) h\u03c1\n    ext z\n    constructor\n    \u00b7 rintro \u27e8_, \u27e8z, w, hab, rfl\u27e9, rfl\u27e9\n      refine \u27e8\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2022 z, \u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2022 w, ?_, ?_\u27e9\n      \u00b7 rwa [\u2190 hS, mem_smul_iff', smul_op, allPerm_inv_sderiv', allPerm_inv_sderiv',\n          allPerm_inv_sderiv', inv_smul_smul, inv_smul_smul]\n      \u00b7 simp only [smul_op, smul_singleton]\n    \u00b7 rintro \u27e8z, w, hab, rfl\u27e9\n      refine \u27e8\u03c1\u207b\u00b9 \u2198 h\u03b2 \u2022 op h\u03b3 h\u03b4 (singleton h\u03b5 z) (singleton h\u03b5 w), ?_, ?_\u27e9\n      \u00b7 simp only [allPerm_inv_sderiv', smul_op, smul_singleton, Set.mem_setOf_eq, op_inj,\n          singleton_inj, exists_eq_right_right', exists_eq_right']\n        rw [smul_eq_iff_eq_inv_smul] at hS\n        rw [hS]\n        simp only [mem_smul_iff', inv_inv, smul_op, smul_inv_smul]\n        exact hab\n      \u00b7 simp only [allPerm_inv_sderiv', smul_inv_smul]\n\ntheorem exists_insertion2 (x : TSet \u03b3) :\n    \u2203 y : TSet \u03b1, \u2200 a b c, op h\u03b3 h\u03b4 (singleton h\u03b5 (singleton h\u03b6 a)) (op h\u03b5 h\u03b6 b c) \u2208[h\u03b2] y \u2194\n    op h\u03b5 h\u03b6 a c \u2208[h\u03b4] x := by\n  have := exists_of_symmetric {u | \u2203 a b c : TSet \u03b6, op h\u03b5 h\u03b6 a c \u2208[h\u03b4] x \u2227\n      u = op h\u03b3 h\u03b4 (singleton h\u03b5 (singleton h\u03b6 a)) (op h\u03b5 h\u03b6 b c)} h\u03b2 ?_\n  \u00b7 obtain \u27e8y, hy\u27e9 := this\n    use y\n    intro a b c\n    rw [hy]\n    constructor\n    \u00b7 rintro \u27e8a', b', c', h\u2081, h\u2082\u27e9\n      simp only [op_inj, singleton_inj] at h\u2082\n      obtain \u27e8rfl, rfl, rfl\u27e9 := h\u2082\n      exact h\u2081\n    \u00b7 intro h\n      exact \u27e8a, b, c, h, rfl\u27e9\n  \u00b7 obtain \u27e8S, hS\u27e9 := exists_support x\n    use S \u2197 h\u03b3 \u2197 h\u03b2\n    intro \u03c1 h\u03c1\n    simp only [Support.smul_scoderiv, Support.scoderiv_inj, \u2190 allPermSderiv_forget'] at h\u03c1\n    specialize hS (\u03c1 \u2198 h\u03b2 \u2198 h\u03b3) h\u03c1\n    ext z\n    constructor\n    \u00b7 rintro \u27e8_, \u27e8a, b, c, hx, rfl\u27e9, rfl\u27e9\n      refine \u27e8\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 a, \u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 b,\n        \u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 c, ?_, ?_\u27e9\n      \u00b7 rw [\u2190 hS]\n        simp only [mem_smul_iff', allPerm_inv_sderiv', smul_op, inv_smul_smul]\n        exact hx\n      \u00b7 simp only [smul_op, smul_singleton]\n    \u00b7 rintro \u27e8a, b, c, hx, rfl\u27e9\n      rw [Set.mem_smul_set_iff_inv_smul_mem]\n      refine \u27e8\u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 a, \u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 b,\n        \u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 c, ?_, ?_\u27e9\n      \u00b7 rw [smul_eq_iff_eq_inv_smul] at hS\n        rw [hS, mem_smul_iff']\n        simp only [inv_inv, allPerm_inv_sderiv', smul_op, smul_inv_smul]\n        exact hx\n      \u00b7 simp only [smul_op, allPerm_inv_sderiv', smul_singleton]\n\ntheorem exists_insertion3 (x : TSet \u03b3) :\n    \u2203 y : TSet \u03b1, \u2200 a b c, op h\u03b3 h\u03b4 (singleton h\u03b5 (singleton h\u03b6 a)) (op h\u03b5 h\u03b6 b c) \u2208[h\u03b2] y \u2194\n    op h\u03b5 h\u03b6 a b \u2208[h\u03b4] x := by\n  have := exists_of_symmetric {u | \u2203 a b c : TSet \u03b6, op h\u03b5 h\u03b6 a b \u2208[h\u03b4] x \u2227\n      u = op h\u03b3 h\u03b4 (singleton h\u03b5 (singleton h\u03b6 a)) (op h\u03b5 h\u03b6 b c)} h\u03b2 ?_\n  \u00b7 obtain \u27e8y, hy\u27e9 := this\n    use y\n    intro a b c\n    rw [hy]\n    constructor\n    \u00b7 rintro \u27e8a', b', c', h\u2081, h\u2082\u27e9\n      simp only [op_inj, singleton_inj] at h\u2082\n      obtain \u27e8rfl, rfl, rfl\u27e9 := h\u2082\n      exact h\u2081\n    \u00b7 intro h\n      exact \u27e8a, b, c, h, rfl\u27e9\n  \u00b7 obtain \u27e8S, hS\u27e9 := exists_support x\n    use S \u2197 h\u03b3 \u2197 h\u03b2\n    intro \u03c1 h\u03c1\n    simp only [Support.smul_scoderiv, Support.scoderiv_inj, \u2190 allPermSderiv_forget'] at h\u03c1\n    specialize hS (\u03c1 \u2198 h\u03b2 \u2198 h\u03b3) h\u03c1\n    ext z\n    constructor\n    \u00b7 rintro \u27e8_, \u27e8a, b, c, hx, rfl\u27e9, rfl\u27e9\n      refine \u27e8\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 a, \u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 b,\n        \u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 c, ?_, ?_\u27e9\n      \u00b7 rw [\u2190 hS]\n        simp only [mem_smul_iff', allPerm_inv_sderiv', smul_op, inv_smul_smul]\n        exact hx\n      \u00b7 simp only [smul_op, smul_singleton]\n    \u00b7 rintro \u27e8a, b, c, hx, rfl\u27e9\n      rw [Set.mem_smul_set_iff_inv_smul_mem]\n      refine \u27e8\u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 a, \u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 b,\n        \u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 c, ?_, ?_\u27e9\n      \u00b7 rw [smul_eq_iff_eq_inv_smul] at hS\n        rw [hS, mem_smul_iff']\n        simp only [inv_inv, allPerm_inv_sderiv', smul_op, smul_inv_smul]\n        exact hx\n      \u00b7 simp only [smul_op, allPerm_inv_sderiv', smul_singleton]\n\ntheorem exists_cross (x : TSet \u03b3) :\n    \u2203 y : TSet \u03b1, \u2200 a, a \u2208[h\u03b2] y \u2194 \u2203 b c, a = op h\u03b3 h\u03b4 b c \u2227 c \u2208[h\u03b4] x := by\n  have := exists_of_symmetric {a | \u2203 b c, a = op h\u03b3 h\u03b4 b c \u2227 c \u2208[h\u03b4] x} h\u03b2 ?_\n  \u00b7 obtain \u27e8y, hy\u27e9 := this\n    use y\n    intro a\n    rw [hy]\n    rfl\n  \u00b7 obtain \u27e8S, hS\u27e9 := exists_support x\n    use S \u2197 h\u03b3 \u2197 h\u03b2\n    intro \u03c1 h\u03c1\n    simp only [Support.smul_scoderiv, Support.scoderiv_inj, \u2190 allPermSderiv_forget'] at h\u03c1\n    specialize hS (\u03c1 \u2198 h\u03b2 \u2198 h\u03b3) h\u03c1\n    ext z\n    constructor\n    \u00b7 rintro \u27e8_, \u27e8a, b, rfl, hab\u27e9, rfl\u27e9\n      refine \u27e8\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2022 a, \u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2022 b, ?_, ?_\u27e9\n      \u00b7 simp only [smul_op]\n      \u00b7 rw [\u2190 hS]\n        simp only [mem_smul_iff', allPerm_inv_sderiv', inv_smul_smul]\n        exact hab\n    \u00b7 rintro \u27e8a, b, rfl, hab\u27e9\n      rw [Set.mem_smul_set_iff_inv_smul_mem]\n      refine \u27e8\u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2022 a, \u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2022 b, ?_, ?_\u27e9\n      \u00b7 simp only [smul_op, allPerm_inv_sderiv']\n      \u00b7 rw [smul_eq_iff_eq_inv_smul] at hS\n        rw [hS]\n        simp only [allPerm_inv_sderiv', mem_smul_iff', inv_inv, smul_inv_smul]\n        exact hab\n\ntheorem exists_typeLower (x : TSet \u03b1) :\n    \u2203 y : TSet \u03b4, \u2200 a, a \u2208[h\u03b5] y \u2194 \u2200 b, op h\u03b3 h\u03b4 b (singleton h\u03b5 a) \u2208[h\u03b2] x := by\n  have := exists_of_symmetric {a | \u2200 b, op h\u03b3 h\u03b4 b (singleton h\u03b5 a) \u2208[h\u03b2] x} h\u03b5 ?_\n  \u00b7 obtain \u27e8y, hy\u27e9 := this\n    use y\n    intro a\n    rw [hy]\n    rfl\n  \u00b7 apply sUnion_singleton_symmetric h\u03b5 h\u03b4\n    apply sUnion_singleton_symmetric h\u03b4 h\u03b3\n    apply sUnion_singleton_symmetric h\u03b3 h\u03b2\n    obtain \u27e8S, hS\u27e9 := exists_support x\n    use S\n    intro \u03c1 h\u03c1\n    specialize hS \u03c1 h\u03c1\n    ext z\n    constructor\n    \u00b7 rintro \u27e8_, \u27e8_, \u27e8a, \u27e8b, hb, rfl\u27e9, rfl\u27e9, rfl\u27e9, rfl\u27e9\n      simp only [smul_singleton, Set.mem_image, Set.mem_setOf_eq, exists_exists_and_eq_and,\n        singleton_inj, exists_eq_right]\n      intro c\n      have := hb (\u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2022 c)\n      rw [smul_eq_iff_eq_inv_smul] at hS\n      rw [hS] at this\n      simp only [allPerm_inv_sderiv', mem_smul_iff', inv_inv, smul_op, smul_inv_smul,\n        smul_singleton] at this\n      exact this\n    \u00b7 rintro \u27e8_, \u27e8a, \u27e8b, hb, rfl\u27e9, rfl\u27e9, rfl\u27e9\n      rw [Set.mem_smul_set_iff_inv_smul_mem]\n      simp only [smul_singleton, allPerm_inv_sderiv', Set.mem_image, Set.mem_setOf_eq,\n        exists_exists_and_eq_and, singleton_inj, exists_eq_right]\n      intro c\n      have := hb (\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2022 c)\n      rw [\u2190 hS] at this\n      simp only [mem_smul_iff', allPerm_inv_sderiv', smul_op, inv_smul_smul, smul_singleton] at this\n      exact this\n\ntheorem exists_converse (x : TSet \u03b1) :\n    \u2203 y : TSet \u03b1, \u2200 a b, op h\u03b3 h\u03b4 a b \u2208[h\u03b2] y \u2194 op h\u03b3 h\u03b4 b a \u2208[h\u03b2] x := by\n  have := exists_of_symmetric {a | \u2203 b c, a = op h\u03b3 h\u03b4 b c \u2227 op h\u03b3 h\u03b4 c b \u2208[h\u03b2] x} h\u03b2 ?_\n  \u00b7 obtain \u27e8y, hy\u27e9 := this\n    use y\n    intro a b\n    rw [hy]\n    simp only [Set.mem_setOf_eq, op_inj]\n    constructor\n    \u00b7 rintro \u27e8a', b', \u27e8rfl, rfl\u27e9, h\u27e9\n      exact h\n    \u00b7 intro h\n      exact \u27e8a, b, \u27e8rfl, rfl\u27e9, h\u27e9\n  \u00b7 obtain \u27e8S, hS\u27e9 := exists_support x\n    use S\n    intro \u03c1 h\u03c1\n    specialize hS \u03c1 h\u03c1\n    ext z\n    constructor\n    \u00b7 rintro \u27e8_, \u27e8a, b, rfl, hab\u27e9, rfl\u27e9\n      refine \u27e8\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2022 a, \u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2022 b, ?_, ?_\u27e9\n      \u00b7 simp only [smul_op]\n      \u00b7 rw [\u2190 hS]\n        simp only [mem_smul_iff', allPerm_inv_sderiv', smul_op, inv_smul_smul]\n        exact hab\n    \u00b7 rintro \u27e8a, b, rfl, hab\u27e9\n      rw [Set.mem_smul_set_iff_inv_smul_mem]\n      refine \u27e8\u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2022 a, \u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2022 b, ?_, ?_\u27e9\n      \u00b7 simp only [smul_op, allPerm_inv_sderiv']\n      \u00b7 rw [smul_eq_iff_eq_inv_smul] at hS\n        rw [hS]\n        simp only [allPerm_inv_sderiv', mem_smul_iff', inv_inv, smul_op, smul_inv_smul]\n        exact hab\n\ntheorem exists_cardinalOne :\n    \u2203 x : TSet \u03b1, \u2200 a : TSet \u03b2, a \u2208[h\u03b2] x \u2194 \u2203 b, a = singleton h\u03b3 b := by\n  have := exists_of_symmetric {a | \u2203 b, a = singleton h\u03b3 b} h\u03b2 ?_\n  \u00b7 obtain \u27e8y, hy\u27e9 := this\n    use y\n    intro a\n    rw [hy]\n    rfl\n  \u00b7 use \u27e8.empty, .empty\u27e9\n    intro \u03c1 h\u03c1\n    ext z\n    constructor\n    \u00b7 rintro \u27e8z, \u27e8a, ha\u27e9, rfl\u27e9\n      refine \u27e8\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2022 a, ?_\u27e9\n      simp only [ha, smul_singleton]\n    \u00b7 rintro \u27e8a, ha\u27e9\n      rw [Set.mem_smul_set_iff_inv_smul_mem]\n      refine \u27e8\u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2022 a, ?_\u27e9\n      simp only [ha, smul_singleton, allPerm_inv_sderiv']\n\n", "theoremStatement": "theorem exists_subset :\n    \u2203 x : TSet \u03b1, \u2200 a b, op h\u03b3 h\u03b4 a b \u2208[h\u03b2] x \u2194 \u2200 c : TSet \u03b5, c \u2208[h\u03b5] a \u2192 c \u2208[h\u03b5] b ", "theoremName": "ConNF.TSet.exists_subset", "fileCreated": {"commit": "f804f5c71cfaa98223fc227dd822801e8bf77004", "date": "2024-03-30"}, "theoremCreated": {"commit": "f7c233c7f7fd9d8b74595bbfa2bbbd49d538ef59", "date": "2024-12-02"}, "file": "ConNF/ConNF/Model/Hailperin.lean", "module": "ConNF.Model.Hailperin", "jsonFile": "ConNF.Model.Hailperin.jsonl", "positionMetadata": {"lineInFile": 385, "tokenPositionInFile": 13106, "theoremPositionInFile": 23}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 34, "numPremises": 94}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  have := exists_of_symmetric {a | \u2203 b c, a = op h\u03b3 h\u03b4 b c \u2227\n      \u2200 d : TSet \u03b5, d \u2208[h\u03b5] b \u2192 d \u2208[h\u03b5] c} h\u03b2 ?_\n  \u00b7 obtain \u27e8y, hy\u27e9 := this\n    use y\n    intro a b\n    rw [hy]\n    simp only [Set.mem_setOf_eq, op_inj]\n    constructor\n    \u00b7 rintro \u27e8a', b', \u27e8rfl, rfl\u27e9, h\u27e9\n      exact h\n    \u00b7 intro h\n      exact \u27e8a, b, \u27e8rfl, rfl\u27e9, h\u27e9\n  \u00b7 use \u27e8.empty, .empty\u27e9\n    intro \u03c1 h\u03c1\n    ext z\n    constructor\n    \u00b7 rintro \u27e8_, \u27e8a, b, rfl, hab\u27e9, rfl\u27e9\n      refine \u27e8\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2022 a, \u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2022 b, ?_\u27e9\n      simp only [smul_op, mem_smul_iff', allPerm_inv_sderiv', true_and]\n      intro d\n      exact hab _\n    \u00b7 rintro \u27e8a, b, rfl, hab\u27e9\n      rw [Set.mem_smul_set_iff_inv_smul_mem]\n      refine \u27e8\u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2022 a, \u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2022 b, ?_\u27e9\n      simp only [smul_op, allPerm_inv_sderiv', mem_smul_iff', inv_inv, true_and]\n      intro d\n      exact hab _", "proofType": "tactic", "proofLengthLines": 27, "proofLengthTokens": 860}}
{"srcContext": "import ConNF.External.Basic\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal ConNF.TSet\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\n/-- A set in our model that is a well-order. Internal well-orders are exactly external well-orders,\nso we externalise the definition for convenience. -/\ndef InternalWellOrder (r : TSet \u03b1) : Prop :=\n  IsWellOrder (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).field\n    (InvImage (ExternalRel h\u03b2 h\u03b3 h\u03b4 r) Subtype.val)\n\ndef InternallyWellOrdered (x : TSet \u03b3) : Prop :=\n  {y : TSet \u03b4 | y \u2208' x}.Subsingleton \u2228 (\u2203 r, InternalWellOrder h\u03b2 h\u03b3 h\u03b4 r \u2227 x = field h\u03b2 h\u03b3 h\u03b4 r)\n\n", "theoremStatement": "@[simp]\ntheorem externalRel_smul (r : TSet \u03b1) (\u03c1 : AllPerm \u03b1) :\n    ExternalRel h\u03b2 h\u03b3 h\u03b4 (\u03c1 \u2022 r) =\n      InvImage (ExternalRel h\u03b2 h\u03b3 h\u03b4 r) ((\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4)\u207b\u00b9 \u2022 \u00b7) ", "theoremName": "ConNF.externalRel_smul", "fileCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "theoremCreated": {"commit": "1c08486feb882444888c228ce1501e92bb85e0e2", "date": "2025-01-07"}, "file": "ConNF/ConNF/External/WellOrder.lean", "module": "ConNF.External.WellOrder", "jsonFile": "ConNF.External.WellOrder.jsonl", "positionMetadata": {"lineInFile": 32, "tokenPositionInFile": 825, "theoremPositionInFile": 2}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 23, "numPremises": 59}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  ext a b\n  simp only [ExternalRel, mem_smul_iff', allPerm_inv_sderiv', smul_op, InvImage]", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 96}}
