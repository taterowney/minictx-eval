{"srcContext": "import Foundation.IntFO.Basic.Rew\n\nnamespace LO.FirstOrder\n\nabbrev Sequent\u1d62 (L : Language) := List (SyntacticFormula\u1d62 L)\n\nopen Semiformula\u1d62\n\nvariable {L : Language} {T : Theory L}\n\nstructure Hilbert\u1d62 (L : Language) where\n  axiomSet : Set (SyntacticFormula\u1d62 L)\n  rewrite_closed {\u03c6 : SyntacticFormula\u1d62 L} : \u03c6 \u2208 axiomSet \u2192 \u2200 f : \u2115 \u2192 SyntacticTerm L, Rew.rewrite f \u25b9 \u03c6 \u2208 axiomSet\n\ninstance : SetLike (Hilbert\u1d62 L) (SyntacticFormula\u1d62 L) where\n  coe := Hilbert\u1d62.axiomSet\n  coe_injective' := by rintro \u27e8T, _\u27e9 \u27e8U, _\u27e9; simp\n\nnamespace Hilbert\u1d62\n\ndef Minimal : Hilbert\u1d62 L := \u27e8\u2205, by simp\u27e9\n\nnotation \"\ud835\udc0c\ud835\udc22\ud835\udc27\u00b9\" => Minimal\n\ndef Intuitionistic : Hilbert\u1d62 L := \u27e8{\u22a5 \u279d \u03c6 | \u03c6}, by rintro _ \u27e8\u03c6, rfl\u27e9 f; exact \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\u27e9\n\nnotation \"\ud835\udc08\ud835\udc27\ud835\udc2d\u00b9\" => Intuitionistic\n\ndef Classical : Hilbert\u1d62 L := \u27e8{\u22a5 \u279d \u03c6 | \u03c6} \u222a {\u03c6 \u22ce \u223c\u03c6 | \u03c6}, by\n  rintro _ (\u27e8\u03c6, rfl\u27e9 | \u27e8\u03c6, rfl\u27e9) f\n  \u00b7 exact Or.inl \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\n  \u00b7 exact Or.inr \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\u27e9\n\nnotation \"\ud835\udc02\ud835\udc25\u00b9\" => Classical\n\nlemma minimal_le (\u039b : Hilbert\u1d62 L) : (Minimal : Hilbert\u1d62 L) \u2264 \u039b := by rintro _ \u27e8\u27e9\n\nlemma intuitionistic_le_classical : (Intuitionistic : Hilbert\u1d62 L) \u2264 Classical := by rintro _ \u27e8\u03c6, rfl\u27e9; exact .inl \u27e8\u03c6, rfl\u27e9\n\nend Hilbert\u1d62\n\ninductive HilbertProof\u1d62 (\u039b : Hilbert\u1d62 L) : SyntacticFormula\u1d62 L \u2192 Type _\n  | eaxm {\u03c6}     : \u03c6 \u2208 \u039b \u2192 HilbertProof\u1d62 \u039b \u03c6\n  | mdp {\u03c6 \u03c8}    : HilbertProof\u1d62 \u039b (\u03c6 \u279d \u03c8) \u2192 HilbertProof\u1d62 \u039b \u03c6 \u2192 HilbertProof\u1d62 \u039b \u03c8\n  | gen {\u03c6}      : HilbertProof\u1d62 \u039b (Rewriting.free \u03c6) \u2192 HilbertProof\u1d62 \u039b (\u2200' \u03c6)\n  | verum        : HilbertProof\u1d62 \u039b \u22a4\n  | imply\u2081 \u03c6 \u03c8   : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c8 \u279d \u03c6\n  | imply\u2082 \u03c6 \u03c8 \u03c7 : HilbertProof\u1d62 \u039b <| (\u03c6 \u279d \u03c8 \u279d \u03c7) \u279d (\u03c6 \u279d \u03c8) \u279d \u03c6 \u279d \u03c7\n  | and\u2081 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u22cf \u03c8 \u279d \u03c6\n  | and\u2082 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u22cf \u03c8 \u279d \u03c8\n  | and\u2083 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c8 \u279d \u03c6 \u22cf \u03c8\n  | or\u2081 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c6 \u22ce \u03c8\n  | or\u2082 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u03c8 \u279d \u03c6 \u22ce \u03c8\n  | or\u2083 \u03c6 \u03c8 \u03c7    : HilbertProof\u1d62 \u039b <| (\u03c6 \u279d \u03c7) \u279d (\u03c8 \u279d \u03c7) \u279d (\u03c6 \u22ce \u03c8 \u279d \u03c7)\n  | all\u2081 \u03c6 t     : HilbertProof\u1d62 \u039b <| \u2200' \u03c6 \u279d \u03c6/[t]\n  | all\u2082 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u2200' (\u03c6/[] \u279d \u03c8) \u279d \u03c6 \u279d \u2200' \u03c8\n  | ex\u2081 t \u03c6      : HilbertProof\u1d62 \u039b <| \u03c6/[t] \u279d \u2203' \u03c6\n  | ex\u2082 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u2200' (\u03c6 \u279d \u03c8/[]) \u279d \u2203' \u03c6 \u279d \u03c8\n\ninstance : System (SyntacticFormula\u1d62 L) (Hilbert\u1d62 L) := \u27e8HilbertProof\u1d62\u27e9\n\nnamespace HilbertProof\u1d62\n\nopen System.FiniteContext Rewriting LawfulSyntacticRewriting\n\nvariable (\u039b : Hilbert\u1d62 L)\n\ninstance : System.ModusPonens \u039b := \u27e8mdp\u27e9\n\ninstance : System.HasAxiomAndInst \u039b := \u27e8and\u2083\u27e9\n\ninstance : System.HasAxiomImply\u2081 \u039b := \u27e8imply\u2081\u27e9\n\ninstance : System.HasAxiomImply\u2082 \u039b := \u27e8imply\u2082\u27e9\n\ninstance : System.Minimal \u039b where\n  mdp := mdp\n  verum := verum\n  imply\u2081 := imply\u2081\n  imply\u2082 := imply\u2082\n  and\u2081 := and\u2081\n  and\u2082 := and\u2082\n  and\u2083 := and\u2083\n  or\u2081 := or\u2081\n  or\u2082 := or\u2082\n  or\u2083 := or\u2083\n  neg_equiv _ := System.iffId _\n\nvariable {\u039b}\n\nprotected def cast {\u03c6 \u03c8} (b : \u039b \u22a2 \u03c6) (e : \u03c6 = \u03c8) : \u039b \u22a2 \u03c8 := e \u25b8 b\n\ndef depth {\u03c6} : \u039b \u22a2 \u03c6 \u2192 \u2115\n  | mdp b d => max (depth b) (depth d) + 1\n  | gen b   => depth b + 1\n  | _       => 0\n\nscoped notation \"\u2016\" d \"\u2016\" => depth d\n\n@[simp] lemma depth_eaxm (h : \u03c6 \u2208 \u039b) : \u2016eaxm h\u2016 = 0 := rfl\n@[simp] lemma depth_mdp (b : \u039b \u22a2 \u03c6 \u279d \u03c8) (d : \u039b \u22a2 \u03c6) : \u2016mdp b d\u2016 = max \u2016b\u2016 \u2016d\u2016 + 1 := rfl\n@[simp] lemma depth_gen (b : \u039b \u22a2 Rewriting.free \u03c6) : \u2016gen b\u2016 = \u2016b\u2016 + 1 := rfl\n@[simp] lemma depth_verum : \u2016(verum : \u039b \u22a2 \u22a4)\u2016 = 0 := rfl\n@[simp] lemma depth_imply\u2081 (\u03c6 \u03c8) : \u2016imply\u2081 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_imply\u2082 (\u03c6 \u03c8 \u03c7) : \u2016imply\u2082 (\u039b := \u039b) \u03c6 \u03c8 \u03c7\u2016 = 0 := rfl\n@[simp] lemma depth_and\u2081 (\u03c6 \u03c8) : \u2016and\u2081 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_and\u2082 (\u03c6 \u03c8) : \u2016and\u2082 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_and\u2083 (\u03c6 \u03c8) : \u2016and\u2083 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_or\u2081 (\u03c6 \u03c8) : \u2016or\u2081 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_or\u2082 (\u03c6 \u03c8) : \u2016or\u2082 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_or\u2083 (\u03c6 \u03c8 \u03c7) : \u2016or\u2083 (\u039b := \u039b) \u03c6 \u03c8 \u03c7\u2016 = 0 := rfl\n", "theoremStatement": "@[simp] lemma depth_all\u2081 (\u03c6 t) : \u2016all\u2081 (\u039b := \u039b) \u03c6 t\u2016 = 0 ", "theoremName": "LO.FirstOrder.HilbertProof\u1d62.depth_all\u2081", "fileCreated": {"commit": "7d9e3859942c3a17a697b129e7fb3869eca0066e", "date": "2024-11-09"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/IntFO/Basic/Deduction.lean", "module": "Foundation.IntFO.Basic.Deduction", "jsonFile": "Foundation.IntFO.Basic.Deduction.jsonl", "positionMetadata": {"lineInFile": 112, "tokenPositionInFile": 3794, "theoremPositionInFile": 23}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 16, "numPremises": 26}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "import Foundation.Modal.Kripke.Geach.Systems\n\nnamespace LO.Modal.Hilbert\n\nopen System\nopen Modal.Kripke\nopen Formula\nopen Formula.Kripke\n\n", "theoremStatement": "lemma K4_weakerThan_K45 : (Hilbert.K4 \u03b1) \u2264\u209b (Hilbert.K45 \u03b1) ", "theoremName": "LO.Modal.Hilbert.K4_weakerThan_K45", "fileCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "theoremCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "file": "foundation/Foundation/Modal/Hilbert/WeakerThan/K4_K45.lean", "module": "Foundation.Modal.Hilbert.WeakerThan.K4_K45", "jsonFile": "Foundation.Modal.Hilbert.WeakerThan.K4_K45.jsonl", "positionMetadata": {"lineInFile": 10, "tokenPositionInFile": 138, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 19, "numPremises": 43}, "proofMetadata": {"hasProof": true, "proof": ":= normal_weakerThan_of_subset $ by intro; aesop;", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 49}}
{"srcContext": "import Foundation.IntFO.Basic.Rew\n\nnamespace LO.FirstOrder\n\nabbrev Sequent\u1d62 (L : Language) := List (SyntacticFormula\u1d62 L)\n\nopen Semiformula\u1d62\n\nvariable {L : Language} {T : Theory L}\n\nstructure Hilbert\u1d62 (L : Language) where\n  axiomSet : Set (SyntacticFormula\u1d62 L)\n  rewrite_closed {\u03c6 : SyntacticFormula\u1d62 L} : \u03c6 \u2208 axiomSet \u2192 \u2200 f : \u2115 \u2192 SyntacticTerm L, Rew.rewrite f \u25b9 \u03c6 \u2208 axiomSet\n\ninstance : SetLike (Hilbert\u1d62 L) (SyntacticFormula\u1d62 L) where\n  coe := Hilbert\u1d62.axiomSet\n  coe_injective' := by rintro \u27e8T, _\u27e9 \u27e8U, _\u27e9; simp\n\nnamespace Hilbert\u1d62\n\ndef Minimal : Hilbert\u1d62 L := \u27e8\u2205, by simp\u27e9\n\nnotation \"\ud835\udc0c\ud835\udc22\ud835\udc27\u00b9\" => Minimal\n\ndef Intuitionistic : Hilbert\u1d62 L := \u27e8{\u22a5 \u279d \u03c6 | \u03c6}, by rintro _ \u27e8\u03c6, rfl\u27e9 f; exact \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\u27e9\n\nnotation \"\ud835\udc08\ud835\udc27\ud835\udc2d\u00b9\" => Intuitionistic\n\ndef Classical : Hilbert\u1d62 L := \u27e8{\u22a5 \u279d \u03c6 | \u03c6} \u222a {\u03c6 \u22ce \u223c\u03c6 | \u03c6}, by\n  rintro _ (\u27e8\u03c6, rfl\u27e9 | \u27e8\u03c6, rfl\u27e9) f\n  \u00b7 exact Or.inl \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\n  \u00b7 exact Or.inr \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\u27e9\n\nnotation \"\ud835\udc02\ud835\udc25\u00b9\" => Classical\n\nlemma minimal_le (\u039b : Hilbert\u1d62 L) : (Minimal : Hilbert\u1d62 L) \u2264 \u039b := by rintro _ \u27e8\u27e9\n\nlemma intuitionistic_le_classical : (Intuitionistic : Hilbert\u1d62 L) \u2264 Classical := by rintro _ \u27e8\u03c6, rfl\u27e9; exact .inl \u27e8\u03c6, rfl\u27e9\n\nend Hilbert\u1d62\n\ninductive HilbertProof\u1d62 (\u039b : Hilbert\u1d62 L) : SyntacticFormula\u1d62 L \u2192 Type _\n  | eaxm {\u03c6}     : \u03c6 \u2208 \u039b \u2192 HilbertProof\u1d62 \u039b \u03c6\n  | mdp {\u03c6 \u03c8}    : HilbertProof\u1d62 \u039b (\u03c6 \u279d \u03c8) \u2192 HilbertProof\u1d62 \u039b \u03c6 \u2192 HilbertProof\u1d62 \u039b \u03c8\n  | gen {\u03c6}      : HilbertProof\u1d62 \u039b (Rewriting.free \u03c6) \u2192 HilbertProof\u1d62 \u039b (\u2200' \u03c6)\n  | verum        : HilbertProof\u1d62 \u039b \u22a4\n  | imply\u2081 \u03c6 \u03c8   : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c8 \u279d \u03c6\n  | imply\u2082 \u03c6 \u03c8 \u03c7 : HilbertProof\u1d62 \u039b <| (\u03c6 \u279d \u03c8 \u279d \u03c7) \u279d (\u03c6 \u279d \u03c8) \u279d \u03c6 \u279d \u03c7\n  | and\u2081 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u22cf \u03c8 \u279d \u03c6\n  | and\u2082 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u22cf \u03c8 \u279d \u03c8\n  | and\u2083 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c8 \u279d \u03c6 \u22cf \u03c8\n  | or\u2081 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c6 \u22ce \u03c8\n  | or\u2082 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u03c8 \u279d \u03c6 \u22ce \u03c8\n  | or\u2083 \u03c6 \u03c8 \u03c7    : HilbertProof\u1d62 \u039b <| (\u03c6 \u279d \u03c7) \u279d (\u03c8 \u279d \u03c7) \u279d (\u03c6 \u22ce \u03c8 \u279d \u03c7)\n  | all\u2081 \u03c6 t     : HilbertProof\u1d62 \u039b <| \u2200' \u03c6 \u279d \u03c6/[t]\n  | all\u2082 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u2200' (\u03c6/[] \u279d \u03c8) \u279d \u03c6 \u279d \u2200' \u03c8\n  | ex\u2081 t \u03c6      : HilbertProof\u1d62 \u039b <| \u03c6/[t] \u279d \u2203' \u03c6\n  | ex\u2082 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u2200' (\u03c6 \u279d \u03c8/[]) \u279d \u2203' \u03c6 \u279d \u03c8\n\ninstance : System (SyntacticFormula\u1d62 L) (Hilbert\u1d62 L) := \u27e8HilbertProof\u1d62\u27e9\n\nnamespace HilbertProof\u1d62\n\nopen System.FiniteContext Rewriting LawfulSyntacticRewriting\n\nvariable (\u039b : Hilbert\u1d62 L)\n\ninstance : System.ModusPonens \u039b := \u27e8mdp\u27e9\n\ninstance : System.HasAxiomAndInst \u039b := \u27e8and\u2083\u27e9\n\ninstance : System.HasAxiomImply\u2081 \u039b := \u27e8imply\u2081\u27e9\n\ninstance : System.HasAxiomImply\u2082 \u039b := \u27e8imply\u2082\u27e9\n\ninstance : System.Minimal \u039b where\n  mdp := mdp\n  verum := verum\n  imply\u2081 := imply\u2081\n  imply\u2082 := imply\u2082\n  and\u2081 := and\u2081\n  and\u2082 := and\u2082\n  and\u2083 := and\u2083\n  or\u2081 := or\u2081\n  or\u2082 := or\u2082\n  or\u2083 := or\u2083\n  neg_equiv _ := System.iffId _\n\nvariable {\u039b}\n\nprotected def cast {\u03c6 \u03c8} (b : \u039b \u22a2 \u03c6) (e : \u03c6 = \u03c8) : \u039b \u22a2 \u03c8 := e \u25b8 b\n\ndef depth {\u03c6} : \u039b \u22a2 \u03c6 \u2192 \u2115\n  | mdp b d => max (depth b) (depth d) + 1\n  | gen b   => depth b + 1\n  | _       => 0\n\nscoped notation \"\u2016\" d \"\u2016\" => depth d\n\n@[simp] lemma depth_eaxm (h : \u03c6 \u2208 \u039b) : \u2016eaxm h\u2016 = 0 := rfl\n@[simp] lemma depth_mdp (b : \u039b \u22a2 \u03c6 \u279d \u03c8) (d : \u039b \u22a2 \u03c6) : \u2016mdp b d\u2016 = max \u2016b\u2016 \u2016d\u2016 + 1 := rfl\n@[simp] lemma depth_gen (b : \u039b \u22a2 Rewriting.free \u03c6) : \u2016gen b\u2016 = \u2016b\u2016 + 1 := rfl\n@[simp] lemma depth_verum : \u2016(verum : \u039b \u22a2 \u22a4)\u2016 = 0 := rfl\n@[simp] lemma depth_imply\u2081 (\u03c6 \u03c8) : \u2016imply\u2081 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_imply\u2082 (\u03c6 \u03c8 \u03c7) : \u2016imply\u2082 (\u039b := \u039b) \u03c6 \u03c8 \u03c7\u2016 = 0 := rfl\n@[simp] lemma depth_and\u2081 (\u03c6 \u03c8) : \u2016and\u2081 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_and\u2082 (\u03c6 \u03c8) : \u2016and\u2082 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_and\u2083 (\u03c6 \u03c8) : \u2016and\u2083 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_or\u2081 (\u03c6 \u03c8) : \u2016or\u2081 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_or\u2082 (\u03c6 \u03c8) : \u2016or\u2082 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_or\u2083 (\u03c6 \u03c8 \u03c7) : \u2016or\u2083 (\u039b := \u039b) \u03c6 \u03c8 \u03c7\u2016 = 0 := rfl\n@[simp] lemma depth_all\u2081 (\u03c6 t) : \u2016all\u2081 (\u039b := \u039b) \u03c6 t\u2016 = 0 := rfl\n@[simp] lemma depth_all\u2082 (\u03c6 \u03c8) : \u2016all\u2082 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_ex\u2081 (t \u03c6) : \u2016ex\u2081 (\u039b := \u039b) t \u03c6\u2016 = 0 := rfl\n@[simp] lemma depth_ex\u2082 (\u03c6 \u03c8) : \u2016ex\u2082 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n\n", "theoremStatement": "@[simp] lemma depth_cast (b : \u039b \u22a2 \u03c6) (e : \u03c6 = \u03c8) : \u2016HilbertProof\u1d62.cast b e\u2016 = \u2016b\u2016 ", "theoremName": "LO.FirstOrder.HilbertProof\u1d62.depth_cast", "fileCreated": {"commit": "7d9e3859942c3a17a697b129e7fb3869eca0066e", "date": "2024-11-09"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/IntFO/Basic/Deduction.lean", "module": "Foundation.IntFO.Basic.Deduction", "jsonFile": "Foundation.IntFO.Basic.Deduction.jsonl", "positionMetadata": {"lineInFile": 117, "tokenPositionInFile": 4047, "theoremPositionInFile": 27}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 7, "numPremises": 16}, "proofMetadata": {"hasProof": true, "proof": ":= by rcases e; rfl", "proofType": "tactic", "proofLengthLines": 0, "proofLengthTokens": 19}}
{"srcContext": "import Foundation.Modal.Hilbert.Maximal.Unprovability\nimport Foundation.Modal.Kripke.GL.MDP\n\nnamespace LO.Modal\n\nopen System\nopen IntProp\n\nvariable [DecidableEq \u03b1]\n\ndef independency (\u03c6 : Formula \u03b1) := \u223c\u25a1\u03c6 \u22cf \u223c\u25a1(\u223c\u03c6)\n\ndef higherIndependency (\u03c6 : Formula \u03b1) : \u2115 \u2192 Formula \u03b1\n  | 0 => \u03c6\n  | n + 1 => independency (higherIndependency \u03c6 n)\n\nnamespace Hilbert.GL\n\nvariable {\u03c6 : Formula \u2115}\n\nlemma unprovable_notbox : (Hilbert.GL _) \u22ac \u223c\u25a1\u03c6 := by\n  by_contra hC;\n  have : (Hilbert.GL _) \u22a2! \u223c\u25a1\u03c6 \u279d \u223c\u25a1\u22a5 := contra\u2080'! (imply_box_distribute'! efq!)\n  have : Hilbert.GL _ \u22a2! \u223c\u25a1\u22a5 := this \u2a00 hC;\n  have : Hilbert.Cl \u2115 \u22a2! (\u22a5 \u279d \u22a5) \u279d \u22a5 := by simpa using provable_CL_verTranslated this;\n  simpa using Hilbert.Cl.classical_sound this;\n\nlemma unprovable_independency : (Hilbert.GL _) \u22ac independency \u03c6 := by\n  by_contra hC;\n  exact unprovable_notbox $ and\u2081'! hC;\n\nlemma unprovable_not_independency_of_consistency : (Hilbert.GL \u2115) \u22ac \u223c(independency (\u223c\u25a1\u22a5)) := by\n  by_contra hC;\n  rcases modal_disjunctive (dne_or! $ demorgan\u2084'! hC) with (h | h);\n  . exact unprovable_notbox h;\n  . exact Consistent.not_bot (inferInstance) $ unnec! $ dne'! h\n\ntheorem undecidable_independency_of_consistency : Undecidable (Hilbert.GL \u2115) (independency (\u223c\u25a1\u22a5)) := by\n  constructor;\n  . exact unprovable_independency;\n  . exact unprovable_not_independency_of_consistency;\n\nvariable {n : \u2115}\n\nlemma unprovable_higherIndependency_of_consistency : (Hilbert.GL \u2115) \u22ac higherIndependency (\u223c\u25a1\u22a5) n := by\n  induction n with\n  | zero => exact unprovable_notbox;\n  | succ n ih => exact unprovable_independency;\n\n", "theoremStatement": "lemma unprovable_not_higherIndependency_of_consistency : (Hilbert.GL \u2115) \u22ac \u223c(higherIndependency (\u223c\u25a1\u22a5) n) ", "theoremName": "LO.Modal.Hilbert.GL.unprovable_not_higherIndependency_of_consistency", "fileCreated": {"commit": "830d76e560f33054a2eb2051cf1fa73997706985", "date": "2025-01-01"}, "theoremCreated": {"commit": "830d76e560f33054a2eb2051cf1fa73997706985", "date": "2025-01-01"}, "file": "foundation/Foundation/Modal/Hilbert/GL_Independency.lean", "module": "Foundation.Modal.Hilbert.GL_Independency", "jsonFile": "Foundation.Modal.Hilbert.GL_Independency.jsonl", "positionMetadata": {"lineInFile": 50, "tokenPositionInFile": 1545, "theoremPositionInFile": 6}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 34, "numPremises": 47}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  by_contra hC;\n  induction n with\n  | zero =>\n    exact Consistent.not_bot (inferInstance) $ unnec! $ dne'! hC;\n  | succ n ih =>\n    rcases modal_disjunctive (dne_or! $ demorgan\u2084'! hC) with (h | h);\n    . exact unprovable_higherIndependency_of_consistency h;\n    . exact ih h;", "proofType": "tactic", "proofLengthLines": 8, "proofLengthTokens": 283}}
{"srcContext": "import Foundation.Modal.Kripke.Geach.Systems\n\nnamespace LO.Modal.Hilbert\n\nopen System\nopen Modal.Kripke\nopen Formula\nopen Formula.Kripke\n\nlemma KB_weakerThan_KDB : (Hilbert.KB \u03b1) \u2264\u209b (Hilbert.KDB \u03b1) := normal_weakerThan_of_subset $ by intro; aesop;\n\n", "theoremStatement": "theorem KB_strictlyWeakerThan_KDB : (Hilbert.KB \u2115) <\u209b (Hilbert.KDB \u2115) ", "theoremName": "LO.Modal.Hilbert.KB_strictlyWeakerThan_KDB", "fileCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "theoremCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "file": "foundation/Foundation/Modal/Hilbert/WeakerThan/KB_KDB.lean", "module": "Foundation.Modal.Hilbert.WeakerThan.KB_KDB", "jsonFile": "Foundation.Modal.Hilbert.WeakerThan.KB_KDB.jsonl", "positionMetadata": {"lineInFile": 12, "tokenPositionInFile": 249, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 61, "numPremises": 125}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  constructor;\n  . exact KB_weakerThan_KDB;\n  . apply weakerThan_iff.not.mpr;\n    push_neg;\n    use (\u25a1(atom 0) \u279d \u25c7(atom 0));\n    constructor;\n    . exact Deduction.maxm! (by simp);\n    . apply KB.Kripke.sound.not_provable_of_countermodel;\n      suffices \u2203 F : Frame, Symmetric F.Rel \u2227 \u2203 V : Valuation F, \u2203 w : F.World, \u00ac(Satisfies \u27e8F, V\u27e9 w _)  by\n        simpa [ValidOnModel, ValidOnFrame, Satisfies];\n      let F : Frame := \u27e8Fin 1, \u03bb x y => False\u27e9;\n      use F;\n      constructor;\n      . simp [Symmetric];\n      . use (\u03bb w _ => w = 0), 0;\n        simp [Semantics.Realize, Satisfies];", "proofType": "tactic", "proofLengthLines": 16, "proofLengthTokens": 591}}
{"srcContext": "import Foundation.Modal.Kripke.Geach.Systems\n\nnamespace LO.Modal.Hilbert\n\nopen System\nopen Modal.Kripke\nopen Formula\nopen Formula.Kripke\n\nlemma KB5_weakerThan_S5 : (Hilbert.KB5 \u2115) \u2264\u209b (Hilbert.S5 \u2115) := by\n  apply Kripke.weakerThan_of_subset_FrameClass SymmetricEuclideanFrameClass ReflexiveEuclideanFrameClass;\n  rintro F \u27e8h_refl, h_eucl\u27e9;\n  refine \u27e8symm_of_refl_eucl h_refl h_eucl, h_eucl\u27e9;\n\n", "theoremStatement": "theorem KB5_strictlyWeakerThan_S5 : (Hilbert.KB5 \u2115) <\u209b (Hilbert.S5 \u2115) ", "theoremName": "LO.Modal.Hilbert.KB5_strictlyWeakerThan_S5", "fileCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "theoremCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "file": "foundation/Foundation/Modal/Hilbert/WeakerThan/KB5_S5.lean", "module": "Foundation.Modal.Hilbert.WeakerThan.KB5_S5", "jsonFile": "Foundation.Modal.Hilbert.WeakerThan.KB5_S5.jsonl", "positionMetadata": {"lineInFile": 15, "tokenPositionInFile": 392, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 60, "numPremises": 121}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  constructor;\n  . exact KB5_weakerThan_S5;\n  . apply weakerThan_iff.not.mpr;\n    push_neg;\n    use (\u25a1(atom 0) \u279d (atom 0));\n    constructor;\n    . exact Deduction.maxm! $ by simp;\n    . apply KB5.Kripke.sound.not_provable_of_countermodel;\n      suffices \u2203 F : Frame,  Symmetric F.Rel \u2227 Euclidean F.Rel \u2227 \u2203 V : Valuation F, \u2203 w : F.World, \u00ac(Kripke.Satisfies \u27e8F, V\u27e9 w _) by\n        simp [ValidOnModel, ValidOnFrame, Satisfies];\n        tauto;\n      use \u27e8Fin 1, \u03bb x y => False\u27e9;\n      refine \u27e8?_, ?_, ?_\u27e9;\n      . simp [Symmetric];\n      . simp [Euclidean];\n      . use (\u03bb w _ => False), 0;\n        simp [Satisfies, Semantics.Realize];", "proofType": "tactic", "proofLengthLines": 17, "proofLengthTokens": 638}}
{"srcContext": "import Mathlib.Data.Vector.Basic\nimport Mathlib.Data.Fin.Basic\nimport Mathlib.Data.Fin.VecNotation\nimport Mathlib.Data.Fintype.Basic\nimport Mathlib.Data.Finset.Basic\nimport Mathlib.Data.Finset.Preimage\nimport Mathlib.Data.Finset.Sort\nimport Mathlib.Order.Filter.Ultrafilter.Defs\nimport Mathlib.Logic.Encodable.Basic\nimport Mathlib.Computability.Primrec\nimport Mathlib.Computability.Partrec\nimport Mathlib.Data.Finset.Sort\nimport Mathlib.Data.List.GetD\nimport Mathlib.Data.Set.Finite.Range\n\nnamespace Nat\nvariable {\u03b1 : \u2115 \u2192 Sort u}\n\ndef cases (hzero : \u03b1 0) (hsucc : \u2200 n, \u03b1 (n + 1)) : \u2200 n, \u03b1 n\n  | 0     => hzero\n  | n + 1 => hsucc n\n\ninfixr:70 \" :>\u2099 \" => cases\n\n@[simp] lemma cases_zero (hzero : \u03b1 0) (hsucc : \u2200 n, \u03b1 (n + 1)) :\n    (hzero :>\u2099 hsucc) 0 = hzero := rfl\n\n@[simp] lemma cases_succ (hzero : \u03b1 0) (hsucc : \u2200 n, \u03b1 (n + 1)) (n : \u2115) :\n    (hzero :>\u2099 hsucc) (n + 1) = hsucc n := rfl\n\n@[simp] lemma ne_step_max (n m : \u2115) : n \u2260 max n m + 1 :=\n  ne_of_lt $ Nat.lt_succ_of_le $ by simp\n\n@[simp] lemma ne_step_max' (n m : \u2115) : n \u2260 max m n + 1 :=\n  ne_of_lt $ Nat.lt_succ_of_le $ by simp\n\nlemma rec_eq {\u03b1 : Sort*} (a : \u03b1) (f\u2081 f\u2082 : \u2115 \u2192 \u03b1 \u2192 \u03b1) (n : \u2115) (H : \u2200 m < n, \u2200 a, f\u2081 m a = f\u2082 m a) :\n    (n.rec a f\u2081 : \u03b1) = n.rec a f\u2082 := by\n  induction' n with n ih <;> simp\n  \u00b7 have : (n.rec a f\u2081 : \u03b1) = n.rec a f\u2082 := ih (fun m hm a =>  H m (Nat.lt.step hm) a)\n    simpa [this] using H n (Nat.lt.base n) (n.rec a f\u2082)\n\nlemma least_number (P : \u2115 \u2192 Prop) (hP : \u2203 x, P x) : \u2203 x, P x \u2227 \u2200 z < x, \u00acP z := by\n  rcases hP with \u27e8n, hn\u27e9\n  induction' n using Nat.strongRec with n ih\n  by_cases H : \u2203 m < n, P m\n  \u00b7 rcases H with \u27e8m, hm, hPm\u27e9\n    exact ih m hm hPm\n  \u00b7 exact \u27e8n, hn, by simpa using H\u27e9\n\ndef toFin (n : \u2115) : \u2115 \u2192 Option (Fin n) := fun x => if hx : x < n then some \u27e8x, hx\u27e9 else none\n\nend Nat\n\nlemma eq_finZeroElim {\u03b1 : Sort u} (x : Fin 0 \u2192 \u03b1) : x = finZeroElim := funext (by rintro \u27e8_, _\u27e9; contradiction)\n\nnamespace Matrix\nopen Fin\nsection\nvariable {n : \u2115} {\u03b1 : Type u}\n\ninfixr:70 \" :> \" => vecCons\n\n@[simp] lemma vecCons_zero :\n    (a :> s) 0 = a := by simp\n\n@[simp] lemma vecCons_succ (i : Fin n) :\n    (a :> s) (Fin.succ i) = s i := by simp\n\n@[simp] lemma vecCons_last (a : C) (s : Fin (n + 1) \u2192 C) :\n    (a :> s) (Fin.last (n + 1)) = s (Fin.last n) := vecCons_succ (Fin.last n)\n\ndef vecConsLast {n : \u2115} (t : Fin n \u2192 \u03b1) (h : \u03b1) : Fin n.succ \u2192 \u03b1 :=\n  Fin.lastCases h t\n\n@[simp] lemma cons_app_one {n : \u2115} (a : \u03b1) (s : Fin n.succ \u2192 \u03b1) : (a :> s) 1 = s 0 := rfl\n\n@[simp] lemma cons_app_two {n : \u2115} (a : \u03b1) (s : Fin n.succ.succ \u2192 \u03b1) : (a :> s) 2 = s 1 := rfl\n\n@[simp] lemma cons_app_three {n : \u2115} (a : \u03b1) (s : Fin n.succ.succ.succ \u2192 \u03b1) : (a :> s) 3 = s 2 := rfl\n\nsection delab\nopen Lean PrettyPrinter Delaborator SubExpr\n\n@[app_unexpander Matrix.vecEmpty]\ndef unexpandVecEmpty : Unexpander\n  | `($(_)) => `(![])\n\n@[app_unexpander Matrix.vecCons]\ndef unexpandVecCons : Unexpander\n  | `($(_) $a ![])      => `(![$a])\n  | `($(_) $a ![$as,*]) => `(![$a, $as,*])\n  | _                   => throw ()\n\n#check ![1, 2]\n\nend delab\n\ninfixl:70 \" <: \" => vecConsLast\n\n@[simp] lemma rightConcat_last :\n    (s <: a) (last n) = a := by simp [vecConsLast]\n\n@[simp] lemma rightConcat_castSucc (i : Fin n) :\n    (s <: a) (Fin.castSucc i) = s i := by simp [vecConsLast]\n\n@[simp] lemma rightConcat_zero (a : \u03b1) (s : Fin n.succ \u2192 \u03b1) :\n    (s <: a) 0 = s 0 := rightConcat_castSucc 0\n\n@[simp] lemma zero_succ_eq_id {n} : (0 : Fin (n + 1)) :> succ = id :=\n  funext $ Fin.cases (by simp) (by simp)\n\n@[simp] lemma zero_cons_succ_eq_self (f : Fin (n + 1) \u2192 \u03b1) : (f 0 :> (f \u00b7.succ) : Fin (n + 1) \u2192 \u03b1) = f := by\n    funext x; cases x using Fin.cases <;> simp\n\nlemma eq_vecCons (s : Fin (n + 1) \u2192 C) : s = s 0 :> s \u2218 Fin.succ :=\n   funext $ Fin.cases (by simp) (by simp)\n\n@[simp] lemma vecCons_ext (a\u2081 a\u2082 : \u03b1) (s\u2081 s\u2082 : Fin n \u2192 \u03b1) :\n    a\u2081 :> s\u2081 = a\u2082 :> s\u2082 \u2194 a\u2081 = a\u2082 \u2227 s\u2081 = s\u2082 :=\n  \u27e8by intros h\n      constructor\n      \u00b7 exact congrFun h 0\n      \u00b7 exact funext (fun i => by simpa using congrFun h (Fin.castSucc i + 1)),\n   by intros h; simp [h]\u27e9\n\nlemma vecCons_assoc (a b : \u03b1) (s : Fin n \u2192 \u03b1) :\n    a :> (s <: b) = (a :> s) <: b := by\n  funext x; cases' x using Fin.cases with x <;> simp; cases x using Fin.lastCases <;> simp [Fin.succ_castSucc]\n\ndef decVec {\u03b1 : Type _} : {n : \u2115} \u2192 (v w : Fin n \u2192 \u03b1) \u2192 (\u2200 i, Decidable (v i = w i)) \u2192 Decidable (v = w)\n  | 0,     _, _, _ => by simpa [Matrix.empty_eq] using isTrue trivial\n  | n + 1, v, w, d => by\n      rw [eq_vecCons v, eq_vecCons w, vecCons_ext]\n      haveI : Decidable (v \u2218 Fin.succ = w \u2218 Fin.succ) := decVec _ _ (by intros i; simpa using d _)\n      refine instDecidableAnd\n\nlemma comp_vecCons (f : \u03b1 \u2192 \u03b2) (a : \u03b1) (s : Fin n \u2192 \u03b1) : (fun x => f $ (a :> s) x) = f a :> f \u2218 s :=\nfunext (fun i => cases (by simp) (by simp) i)\n\nlemma comp_vecCons' (f : \u03b1 \u2192 \u03b2) (a : \u03b1) (s : Fin n \u2192 \u03b1) : (fun x => f $ (a :> s) x) = f a :> fun i => f (s i) :=\n  comp_vecCons f a s\n\nlemma comp_vecCons'' (f : \u03b1 \u2192 \u03b2) (a : \u03b1) (s : Fin n \u2192 \u03b1) : f \u2218 (a :> s) = f a :> f \u2218 s :=\n  comp_vecCons f a s\n\n@[simp] lemma comp\u2080 : f \u2218 (![] : Fin 0 \u2192 \u03b1) = ![] := by simp [Matrix.empty_eq]\n\n@[simp] lemma comp\u2081 (a : \u03b1) : f \u2218 ![a] = ![f a] := by simp [comp_vecCons'']\n\n@[simp] lemma comp\u2082 (a\u2081 a\u2082 : \u03b1) : f \u2218 ![a\u2081, a\u2082] = ![f a\u2081, f a\u2082] := by simp [comp_vecCons'']\n\n@[simp] lemma comp\u2083 (a\u2081 a\u2082 a\u2083 : \u03b1) : f \u2218 ![a\u2081, a\u2082, a\u2083] = ![f a\u2081, f a\u2082, f a\u2083] := by simp [comp_vecCons'']\n\nlemma comp_vecConsLast (f : \u03b1 \u2192 \u03b2) (a : \u03b1) (s : Fin n \u2192 \u03b1) : (fun x => f $ (s <: a) x) = f \u2218 s <: f a :=\nfunext (fun i => lastCases (by simp) (by simp) i)\n\n@[simp] lemma vecHead_comp (f : \u03b1 \u2192 \u03b2) (v : Fin (n + 1) \u2192 \u03b1) : vecHead (f \u2218 v) = f (vecHead v) :=\n  by simp [vecHead]\n\n@[simp] lemma vecTail_comp (f : \u03b1 \u2192 \u03b2) (v : Fin (n + 1) \u2192 \u03b1) : vecTail (f \u2218 v) = f \u2218 (vecTail v) := by\n  simp [vecTail, Function.comp_assoc]\n\nlemma vecConsLast_vecEmpty {s : Fin 0 \u2192 \u03b1} (a : \u03b1) : s <: a = ![a] :=\n  funext (fun x => by\n    have : 0 = Fin.last 0 := by rfl\n    cases' x using Fin.cases with i\n    \u00b7 rw [this, rightConcat_last, cons_val_fin_one]\n    have := i.isLt; contradiction )\n\nlemma constant_eq_singleton {a : \u03b1} : (fun _ => a) = ![a] := by funext x; simp\n\nlemma constant_eq_singleton' {v : Fin 1 \u2192 \u03b1} : v = ![v 0] := by funext x; simp [Fin.eq_zero]\n\nlemma constant_eq_vec\u2082 {a : \u03b1} : (fun _ => a) = ![a, a] := by\n  funext x; cases x using Fin.cases <;> simp [Fin.eq_zero]\n\nlemma fun_eq_vec\u2082 {v : Fin 2 \u2192 \u03b1} : v = ![v 0, v 1] := by\n  funext x; cases x using Fin.cases <;> simp [Fin.eq_zero]\n\nlemma injective_vecCons {f : Fin n \u2192 \u03b1} (h : Function.Injective f) {a} (ha : \u2200 i, a \u2260 f i) : Function.Injective (a :> f) := by\n  have : \u2200 i, f i \u2260 a := fun i => (ha i).symm\n  intro i j; cases i using Fin.cases <;> cases j using Fin.cases\n  \u00b7 simp\n  \u00b7 simp [*]\n  \u00b7 simp [*]\n  \u00b7 simpa using @h _ _\n\nend\n\nvariable {\u03b1 : Type _}\n\ndef toList : {n : \u2115} \u2192 (Fin n \u2192 \u03b1) \u2192 List \u03b1\n  | 0,     _ => []\n  | _ + 1, v => v 0 :: toList (v \u2218 Fin.succ)\n\n@[simp] lemma toList_zero (v : Fin 0 \u2192 \u03b1) : toList v = [] := rfl\n\n@[simp] lemma toList_succ (v : Fin (n + 1) \u2192 \u03b1) : toList v = v 0 :: toList (v \u2218 Fin.succ) := rfl\n\n@[simp] lemma toList_length (v : Fin n \u2192 \u03b1) : (toList v).length = n :=\n  by induction n <;> simp [*]\n\n@[simp] lemma mem_toList_iff {v : Fin n \u2192 \u03b1} {a} : a \u2208 toList v \u2194 \u2203 i, v i = a := by\n  induction n\n  \u00b7 simp [*]\n  \u00b7 suffices (a = v 0 \u2228 \u2203 i : Fin _, v i.succ = a) \u2194 \u2203 i, v i = a by simp [*]\n    constructor\n    \u00b7 rintro (rfl | \u27e8i, rfl\u27e9) <;> simp\n    \u00b7 rintro \u27e8i, rfl\u27e9; cases i using Fin.cases <;> simp\n\nvariable {m : Type u \u2192 Type v} [Monad m] {\u03b1 : Type w} {\u03b2 : Type u}\n\ndef getM : {n : \u2115} \u2192 {\u03b2 : Fin n \u2192 Type u} \u2192 ((i : Fin n) \u2192 m (\u03b2 i)) \u2192 m ((i : Fin n) \u2192 \u03b2 i)\n  | 0,     _, _ => pure finZeroElim\n  | _ + 1, _, f => Fin.cases <$> f 0 <*> getM (f \u00b7.succ)\n\nlemma getM_pure [LawfulMonad m] {n} {\u03b2 : Fin n \u2192 Type u} (v : (i : Fin n) \u2192 \u03b2 i) :\n    getM (fun i => (pure (v i) : m (\u03b2 i))) = pure v := by\n  induction' n with n ih\n  \u00b7 unfold getM; congr; funext x; exact x.elim0\n  \u00b7 simp only [getM, map_pure, ih, seq_pure]\n    exact congr_arg _ (funext <| Fin.cases rfl fun i \u21a6 rfl)\n\n@[simp] lemma getM_some {n} {\u03b2 : Fin n \u2192 Type u} (v : (i : Fin n) \u2192 \u03b2 i) :\n    getM (fun i => (some (v i) : Option (\u03b2 i))) = some v := getM_pure v\n\ndef appendr {n m} (v : Fin n \u2192 \u03b1) (w : Fin m \u2192 \u03b1) : Fin (m + n) \u2192 \u03b1 := Matrix.vecAppend (add_comm m n) v w\n\n@[simp] lemma appendr_nil {m} (w : Fin m \u2192 \u03b1) : appendr ![] w = w := by funext i; simp [appendr]\n\n@[simp] lemma appendr_cons {m n} (x : \u03b1) (v : Fin n \u2192 \u03b1) (w : Fin m \u2192 \u03b1) : appendr (x :> v) w = x :> appendr v w := by funext i; simp [appendr]\n\nsection vecToNat\n\ndef vecToNat : {n : \u2115} \u2192 (Fin n \u2192 \u2115) \u2192 \u2115\n  | 0,     _ => 0\n  | _ + 1, v => Nat.pair (v 0) (vecToNat $ v \u2218 Fin.succ) + 1\n\nopen Encodable\n\n@[simp] lemma vecToNat_empty (v : Fin 0 \u2192 \u2115) : vecToNat v = 0 := by rfl\n\n@[simp] lemma encode_succ {n} (x : \u2115) (v : Fin n \u2192 \u2115) : vecToNat (x :> v) = Nat.pair x (vecToNat v) + 1 := by\n  simp [vecToNat, Function.comp_def]\n\nend vecToNat\n\nend Matrix\n\nnamespace DMatrix\n\ndef vecEmpty : Fin 0 \u2192 \u03b1 :=\n  Fin.elim0\n\nvariable {n} {\u03b1 : Fin (n + 1) \u2192 Type*}\n\ndef vecCons (h : \u03b1 0) (t : (i : Fin n) \u2192 \u03b1 i.succ) : (i : Fin n.succ) \u2192 \u03b1 i :=\n  Fin.cons h t\n\ninfixr:70 \" ::> \" => vecCons\n\n@[simp] lemma vecCons_zero (h : \u03b1 0) (t : (i : Fin n) \u2192 \u03b1 i.succ) : (h ::> t) 0 = h := rfl\n\n@[simp] lemma vecCons_succ (h : \u03b1 0) (t : (i : Fin n) \u2192 \u03b1 i.succ) (i : Fin n) : (h ::> t) i.succ = t i := rfl\n\nlemma eq_vecCons (s : (i : Fin (n + 1)) \u2192 \u03b1 i) : s = s 0 ::> fun i => s i.succ :=\n   funext $ Fin.cases (by simp) (by simp)\n\n@[simp] lemma vecCons_ext (a\u2081 a\u2082 : \u03b1 0) (s\u2081 s\u2082 : (i : Fin n) \u2192 \u03b1 i.succ) :\n    a\u2081 ::> s\u2081 = a\u2082 ::> s\u2082 \u2194 a\u2081 = a\u2082 \u2227 s\u2081 = s\u2082 :=\n  \u27e8by intros h\n      constructor\n      \u00b7 exact congrFun h 0\n      \u00b7 exact funext (fun i => by simpa using congrFun h i.succ),\n   by intros h; simp [h]\u27e9\n\ndef decVec {n : \u2115} {\u03b1 : Fin n \u2192 Type _}\n  (v w : (i : Fin n) \u2192 \u03b1 i) (h : \u2200 i, Decidable (v i = w i)) : Decidable (v = w) := by\n    induction' n with n ih\n    \u00b7 exact isTrue (by funext x; exact finZeroElim (\u03b1 := fun x => v x = w x) x)\n    \u00b7 rw [eq_vecCons v, eq_vecCons w, vecCons_ext]\n      haveI := ih (fun i => v i.succ) (fun i => w i.succ) (fun i => h i.succ)\n      refine instDecidableAnd\n\nend DMatrix\n\nnamespace Option\n\nlemma pure_eq_some (a : \u03b1) : pure a = some a := rfl\n\n@[simp] lemma toList_eq_iff {o : Option \u03b1} {a} :\n    o.toList = [a] \u2194 o = some a := by rcases o <;> simp\n\nend Option\n\ndef Nat.natToVec : \u2115 \u2192 (n : \u2115) \u2192 Option (Fin n \u2192 \u2115)\n  | 0,     0     => some Matrix.vecEmpty\n  | e + 1, n + 1 => Nat.natToVec e.unpair.2 n |>.map (e.unpair.1 :> \u00b7)\n  | _,     _     => none\n\nnamespace Nat\nopen Matrix\nvariable {n : \u2115}\n\n@[simp] lemma natToVec_vecToNat (v : Fin n \u2192 \u2115) : (vecToNat v).natToVec n = some v := by\n  induction n\n  \u00b7 simp [*, Nat.natToVec, vecToNat, Matrix.empty_eq]\n  \u00b7 suffices v 0 :> v \u2218 Fin.succ = v by simp [*, Nat.natToVec, vecToNat]\n    exact funext (fun i \u21a6 i.cases (by simp [Matrix.empty_eq]) (by simp [Matrix.empty_eq]))\n\nlemma lt_of_eq_natToVec {e : \u2115} {v : Fin n \u2192 \u2115} (h : e.natToVec n = some v) (i : Fin n) : v i < e := by\n  induction' n with n ih generalizing e\n  \u00b7 exact i.elim0\n  \u00b7 cases' e with e\n    \u00b7 simp [natToVec] at h\n    \u00b7 simp only [natToVec, Option.map_eq_some'] at h\n      rcases h with \u27e8v, hnv, rfl\u27e9\n      cases' i using Fin.cases with i\n      \u00b7 simp [lt_succ, unpair_left_le]\n      \u00b7 simp only [cons_val_succ]\n        exact lt_trans (ih hnv i) (lt_succ.mpr <| unpair_right_le e)\n\nlemma one_le_of_bodd {n : \u2115} (h : n.bodd = true) : 1 \u2264 n :=\nby induction n <;> simp [\u2190Nat.add_one] at h \u22a2\n\nlemma pair_le_pair_of_le {a\u2081 a\u2082 b\u2081 b\u2082 : \u2115} (ha : a\u2081 \u2264 a\u2082) (hb : b\u2081 \u2264 b\u2082) : a\u2081.pair b\u2081 \u2264 a\u2082.pair b\u2082 := by\n  rcases lt_or_eq_of_le ha with (ha | rfl) <;> rcases lt_or_eq_of_le hb with (hb | rfl)\n  { exact le_of_lt (lt_trans (Nat.pair_lt_pair_left b\u2081 ha) (Nat.pair_lt_pair_right a\u2082 hb)) }\n  { exact le_of_lt (Nat.pair_lt_pair_left b\u2081 ha) }\n  { exact le_of_lt (Nat.pair_lt_pair_right a\u2081 hb) }\n  { rfl }\n\nend Nat\n\nnamespace Fin\n\nlemma pos_of_coe_ne_zero {i : Fin (n + 1)} (h : (i : \u2115) \u2260 0) :\n    0 < i := Nat.pos_of_ne_zero h\n\n@[simp] lemma one_pos'' : (0 : Fin (n + 2)) < 1 := pos_of_coe_ne_zero (Nat.succ_ne_zero 0)\n\n@[simp] lemma two_pos : (0 : Fin (n + 3)) < 2 := pos_of_coe_ne_zero (Nat.succ_ne_zero 1)\n\n@[simp] lemma three_pos : (0 : Fin (n + 4)) < 3 := pos_of_coe_ne_zero (Nat.succ_ne_zero 2)\n\n@[simp] lemma four_pos : (0 : Fin (n + 5)) < 4 := pos_of_coe_ne_zero (Nat.succ_ne_zero 3)\n\n@[simp] lemma five_pos : (0 : Fin (n + 6)) < 5 := pos_of_coe_ne_zero (Nat.succ_ne_zero 4)\n\nend Fin\n\nnamespace Fintype\nvariable {\u03b9 : Type _} [Fintype \u03b9]\n\nsection\n\nvariable {\u03b1 : Type _} [SemilatticeSup \u03b1] [OrderBot \u03b1]\n\ndef sup (f : \u03b9 \u2192 \u03b1) : \u03b1 := (Finset.univ : Finset \u03b9).sup f\n\n@[simp] lemma elem_le_sup (f : \u03b9 \u2192 \u03b1) (i : \u03b9) : f i \u2264 sup f := Finset.le_sup (by simp)\n\nlemma le_sup {a : \u03b1} {f : \u03b9 \u2192 \u03b1} (i : \u03b9) (le : a \u2264 f i) : a \u2264 sup f := le_trans le (elem_le_sup _ _)\n\n@[simp] lemma sup_le_iff {f : \u03b9 \u2192 \u03b1} {a : \u03b1} :\n    sup f \u2264 a \u2194 (\u2200 i, f i \u2264 a) := by simp [sup]\n\n@[simp] lemma finsup_eq_0_of_empty [IsEmpty \u03b9] (f : \u03b9 \u2192 \u03b1) : sup f = \u22a5 := by simp [sup]\n\nend\n\ndef decideEqPi {\u03b2 : \u03b9 \u2192 Type*} (a b : (i : \u03b9) \u2192 \u03b2 i) (_ : (i : \u03b9) \u2192 Decidable (a i = b i)) : Decidable (a = b) :=\n  decidable_of_iff (\u2200 i, a i = b i) funext_iff.symm\n\nend Fintype\n\nnamespace String\n\ndef vecToStr : \u2200 {n}, (Fin n \u2192 String) \u2192 String\n  | 0,     _ => \"\"\n  | n + 1, s => if n = 0 then s 0 else s 0 ++ \", \" ++ @vecToStr n (fun i => s (Fin.succ i))\n\n#eval vecToStr ![\"a\", \"b\", \"c\", \"d\"]\n\nend String\n\nnamespace Empty\n\nlemma eq_elim {\u03b1 : Sort u} (f : Empty \u2192 \u03b1) : f = elim := funext (by rintro \u27e8\u27e9)\n\nend Empty\n\nnamespace IsEmpty\nvariable {o : Sort u} (h : IsEmpty o)\n\nlemma eq_elim {\u03b1 : Sort*} (f : o \u2192 \u03b1) : f = h.elim' := funext h.elim\n\nend IsEmpty\n\nnamespace Function\n\nvariable  {\u03b1 : Type u} {\u03b2 : Type v}\n\ndef funEqOn (\u03c6 : \u03b1 \u2192 Prop) (f g : \u03b1 \u2192 \u03b2) : Prop := \u2200 a, \u03c6 a \u2192 f a = g a\n\nlemma funEqOn.of_subset {\u03c6 \u03c8 : \u03b1 \u2192 Prop} {f g : \u03b1 \u2192 \u03b2} (e : funEqOn \u03c6 f g) (h : \u2200 a, \u03c8 a \u2192 \u03c6 a) : funEqOn \u03c8 f g :=\n  by intro a ha; exact e a (h a ha)\n\nend Function\n\nnamespace Quotient\nopen Matrix\nvariable {\u03b1 : Type u} [s : Setoid \u03b1] {\u03b2 : Sort v}\n\n@[elab_as_elim]\nlemma inductionOnVec {\u03c6 : (Fin n \u2192 Quotient s) \u2192 Prop} (v : Fin n \u2192 Quotient s)\n  (h : \u2200 v : Fin n \u2192 \u03b1, \u03c6 (fun i => Quotient.mk s (v i))) : \u03c6 v :=\n  Quotient.induction_on_pi v h\n\ndef liftVec : \u2200 {n} (f : (Fin n \u2192 \u03b1) \u2192 \u03b2),\n  (\u2200 v\u2081 v\u2082 : Fin n \u2192 \u03b1, (\u2200 n, v\u2081 n \u2248 v\u2082 n) \u2192 f v\u2081 = f v\u2082) \u2192 (Fin n \u2192 Quotient s) \u2192 \u03b2\n| 0,     f, _, _ => f ![]\n| n + 1, f, h, v =>\n  let ih : \u03b1 \u2192 (Fin n \u2192 Quotient s) \u2192 \u03b2 :=\n    fun a v => liftVec (n := n) (fun v => f (a :> v))\n      (fun v\u2081 v\u2082 hv => h (a :> v\u2081) (a :> v\u2082) (Fin.cases (by simpa using refl a) hv)) v\n  Quot.liftOn (vecHead v) (ih \u00b7 (vecTail v))\n    (fun a b hab => by\n      have : \u2200 v, f (a :> v) = f (b :> v) := fun v \u21a6 h _ _ (Fin.cases hab (by simpa using fun x \u21a6 refl _))\n      simp [this, ih])\n\n@[simp] lemma liftVec_zero (f : (Fin 0 \u2192 \u03b1) \u2192 \u03b2) (h) (v : Fin 0 \u2192 Quotient s) : liftVec f h v = f ![] := rfl\n\nlemma liftVec_mk {n} (f : (Fin n \u2192 \u03b1) \u2192 \u03b2) (h) (v : Fin n \u2192 \u03b1) :\n    liftVec f h (Quotient.mk s \u2218 v) = f v := by\n  induction' n with n ih <;> simp [liftVec, empty_eq, Quotient.liftOn_mk]\n  simpa using ih (fun v' => f (vecHead v :> v'))\n    (fun v\u2081 v\u2082 hv => h (vecHead v :> v\u2081) (vecHead v :> v\u2082) (Fin.cases (refl _) hv)) (vecTail v)\n\n@[simp] lemma liftVec_mk\u2081 (f : (Fin 1 \u2192 \u03b1) \u2192 \u03b2) (h) (a : \u03b1) :\n    liftVec f h ![Quotient.mk s a] = f ![a] := liftVec_mk f h ![a]\n\n@[simp] lemma liftVec_mk\u2082 (f : (Fin 2 \u2192 \u03b1) \u2192 \u03b2) (h) (a\u2081 a\u2082 : \u03b1) :\n    liftVec f h ![Quotient.mk s a\u2081, Quotient.mk s a\u2082] = f ![a\u2081, a\u2082] := liftVec_mk f h ![a\u2081, a\u2082]\n\nend Quotient\n\nnamespace List\n\nvariable {\u03b1 : Type u} {\u03b2: Type v}\n\nlemma getI_map_range [Inhabited \u03b1] (f : \u2115 \u2192 \u03b1) (h : i < n) : ((List.range n).map f).getI i = f i := by\n  simpa [h] using List.getI_eq_getElem ((List.range n).map f) (n := i) (by simpa using h)\n\ndef subsetSet (l : List \u03b1) (s : Set \u03b1) [DecidablePred s] : Bool :=\n  l.foldr (fun a ih => s a && ih) true\n\ndef upper : List \u2115 \u2192 \u2115\n  | []      => 0\n  | n :: ns => max (n + 1) ns.upper\n\n@[simp] lemma upper_nil : upper [] = 0 := rfl\n\n@[simp] lemma upper_cons (n : \u2115) (ns : List \u2115) : upper (n :: ns) = max (n + 1) ns.upper := rfl\n\nlemma lt_upper (l : List \u2115) {n} (h : n \u2208 l) : n < l.upper := by\n  induction' l with n ns ih\n  case nil => simp at h\n  case cons m =>\n    suffices m < n + 1 \u2228 m < ns.upper by simpa\n    rcases show m = n \u2228 m \u2208 ns by simpa using h with (rfl | h)\n    \u00b7 exact Or.inl (Nat.lt_succ_self _)\n    \u00b7 exact Or.inr (ih h)\n\nsection finset\n\nvariable [DecidableEq \u03b1] [DecidableEq \u03b2]\n\nlemma toFinset_map {f : \u03b1 \u2192 \u03b2} (l : List \u03b1) : (l.map f).toFinset = Finset.image f l.toFinset := by\n  induction l <;> simp [*]\n\nlemma toFinset_mono {l l' : List \u03b1} (h : l \u2286 l') : l.toFinset \u2286 l'.toFinset := by\n  intro a; simp only [mem_toFinset]; intro ha; exact h ha\n\nend finset\n\nsection sup\n\nvariable [SemilatticeSup \u03b1] [OrderBot \u03b1]\n\ndef sup : List \u03b1 \u2192 \u03b1\n  |      [] => \u22a5\n  | a :: as => a \u2294 as.sup\n\n@[simp] lemma sup_nil : ([] : List \u03b1).sup = \u22a5 := rfl\n\n@[simp] lemma sup_cons (a : \u03b1) (as : List \u03b1) : (a :: as).sup = a \u2294 as.sup := rfl\n\nlemma le_sup {a} {l : List \u03b1} : a \u2208 l \u2192 a \u2264 l.sup := by\n  induction' l with a l ih\n  \u00b7 simp\n  case cons _ b =>\n    intro h\n    rcases show b = a \u2228 b \u2208 l by simpa using h with (rfl | h)\n    \u00b7 simp\n    \u00b7 exact le_sup_of_le_right (ih h)\n\nlemma sup_ofFn (f : Fin n \u2192 \u03b1) : (ofFn f).sup = Finset.sup Finset.univ f := by\n  induction' n with n ih\n  \u00b7 simp\n  \u00b7 have h\u2081 : (Finset.univ : Finset (Fin (n + 1))) = insert 0 ((Finset.univ : Finset (Fin n)).image Fin.succ) := by\n      ext i; simp\n    have h\u2082 : Finset.sup Finset.univ (fun i \u21a6 f (Fin.succ i)) = Finset.sup {0}\u1d9c f := by\n      simpa [Function.comp] using Eq.symm <| Finset.sup_image (Finset.univ : Finset (Fin n)) Fin.succ f\n    calc\n      (ofFn f).sup = (f 0 \u2294 Finset.univ.sup fun i : Fin _ \u21a6 f i.succ) := by simp [ih]\n      _            = f 0 \u2294 Finset.sup {0}\u1d9c f                          := by rw [h\u2082]\n      _            = Finset.univ.sup f                                := by rw [h\u2081, Finset.sup_insert]; simp\n\nend sup\n\nlemma ofFn_get_eq_map_cast {n} (g : \u03b1 \u2192 \u03b2) (as : List \u03b1) {h} :\n    ofFn (fun i => g (as.get (i.cast h)) : Fin n \u2192 \u03b2) = as.map g := by\n  ext i b; simp\n  by_cases hi : i < n\n  \u00b7 simp [hi, List.ofFnNthVal, List.getElem?_eq_getElem (h \u25b8 hi)]\n  \u00b7 simp [hi, List.ofFnNthVal, List.getElem?_eq_none (le_of_not_lt $ h \u25b8 hi)]\n\nvariable {m : Type _ \u2192 Type _} {\u03b1 : Type _} {\u03b2 : Type _} [Monad m]\n\nlemma append_subset_append {l\u2081 l\u2082 l : List \u03b1} (h : l\u2081 \u2286 l\u2082) : l\u2081 ++ l \u2286 l\u2082 ++ l :=\n  List.append_subset.mpr \u27e8List.subset_append_of_subset_left _ h, subset_append_right l\u2082 l\u27e9\n\nlemma subset_of_eq {l\u2081 l\u2082 : List \u03b1} (e : l\u2081 = l\u2082) : l\u2081 \u2286 l\u2082 := by simp [e]\n\nsection remove\n\ndef remove [DecidableEq \u03b1] (a : \u03b1) : List \u03b1 \u2192 List \u03b1 := List.filter (\u00b7 \u2260 a)\n\nvariable [DecidableEq \u03b1]\n\n@[simp]\nlemma remove_nil (a : \u03b1) : [].remove a = [] := by simp [List.remove]\n\n@[simp]\nlemma eq_remove_cons {l : List \u03b1} : (\u03c8 :: l).remove \u03c8 = l.remove \u03c8 := by induction l <;> simp_all [List.remove];\n\n@[simp]\nlemma remove_singleton_of_ne {\u03c6 \u03c8 : \u03b1} (h : \u03c6 \u2260 \u03c8) : [\u03c6].remove \u03c8 = [\u03c6] := by simp_all [List.remove, Ne.symm];\n\nlemma mem_remove_iff {l : List \u03b1} : b \u2208 l.remove a \u2194 b \u2208 l \u2227 b \u2260 a := by\n  simp [List.remove, List.of_mem_filter]\n\nlemma mem_of_mem_remove {a b : \u03b1} {l : List \u03b1} (h : b \u2208 l.remove a) : b \u2208 l := by\n  rw [mem_remove_iff] at h; exact h.1\n\n@[simp] lemma remove_cons_self (l : List \u03b1) (a) :\n  (a :: l).remove a = l.remove a := by simp [remove]\n\nlemma remove_cons_of_ne (l : List \u03b1) {a b} (ne : a \u2260 b) :\n  (a :: l).remove b = a :: l.remove b := by simp_all [remove];\n\nlemma remove_subset (a) (l : List \u03b1) :\n    l.remove a \u2286 l := by\n  simp only [subset_def, mem_remove_iff, ne_eq, and_imp]\n  intros; simp [*]\n\nlemma remove_subset_remove (a) {l\u2081 l\u2082 : List \u03b1} (h : l\u2081 \u2286 l\u2082) :\n    l\u2081.remove a \u2286 l\u2082.remove a := by\n  simp only [subset_def, mem_remove_iff, ne_eq, and_imp]\n  intros\n  simpa [*] using h (by assumption)\n\nlemma remove_cons_subset_cons_remove (a b) (l : List \u03b1) :\n    (a :: l).remove b \u2286 a :: l.remove b := by\n  intro x\n  simp only [mem_remove_iff, mem_cons, ne_eq, and_imp]\n  rintro (rfl | hx) nex <;> simp [*]\n\nlemma remove_map_substet_map_remove [DecidableEq \u03b2] (f : \u03b1 \u2192 \u03b2) (l : List \u03b1) (a) :\n    (l.map f).remove (f a) \u2286 (l.remove a).map f := by\n  simp only [subset_def, mem_remove_iff, mem_map, ne_eq, and_imp, forall_exists_index,\n    forall_apply_eq_imp_iff\u2082]\n  intro b hb neb;\n  exact \u27e8b, \u27e8hb, by rintro rfl; exact neb rfl\u27e9, rfl\u27e9\n\nend remove\n\n@[elab_as_elim]\nlemma induction_with_singleton\n  {motive : List F \u2192 Prop}\n  (hnil : motive [])\n  (hsingle : \u2200 a, motive [a])\n  (hcons : \u2200 a as, as \u2260 [] \u2192 motive as \u2192 motive (a :: as)) : \u2200 as, motive as := by\n  intro as;\n  induction as with\n  | nil => exact hnil;\n  | cons a as ih => cases as with\n    | nil => exact hsingle a;\n    | cons b bs => exact hcons a (b :: bs) (by simp) ih;\n\n\n\nend List\n\nnamespace List.Vector\n\nvariable {\u03b1 : Type*}\n\nlemma get_mk_eq_get {n} (l : List \u03b1) (h : l.length = n) (i : Fin n) : List.Vector.get (\u27e8l, h\u27e9 : List.Vector \u03b1 n) i = l.get (i.cast h.symm) := rfl\n\n", "theoremStatement": "lemma get_one {\u03b1 : Type*} {n} (v : Vector \u03b1 (n + 2)) : v.get 1 = v.tail.head ", "theoremName": "List.Vector.get_one", "fileCreated": {"commit": "33e08c2b47f966f772df9af60cbdbc5688295bbf", "date": "2024-10-15"}, "theoremCreated": {"commit": "882430c05764b123332207cb6a2aa0f856c69063", "date": "2024-12-23"}, "file": "foundation/Foundation/Vorspiel/Vorspiel.lean", "module": "Foundation.Vorspiel.Vorspiel", "jsonFile": "Foundation.Vorspiel.Vorspiel.jsonl", "positionMetadata": {"lineInFile": 613, "tokenPositionInFile": 21000, "theoremPositionInFile": 116}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 26}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [\u2190Vector.get_zero, Vector.get_tail_succ]; rfl", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 56}}
{"srcContext": "import Foundation.IntFO.Basic.Rew\n\nnamespace LO.FirstOrder\n\nabbrev Sequent\u1d62 (L : Language) := List (SyntacticFormula\u1d62 L)\n\nopen Semiformula\u1d62\n\nvariable {L : Language} {T : Theory L}\n\nstructure Hilbert\u1d62 (L : Language) where\n  axiomSet : Set (SyntacticFormula\u1d62 L)\n  rewrite_closed {\u03c6 : SyntacticFormula\u1d62 L} : \u03c6 \u2208 axiomSet \u2192 \u2200 f : \u2115 \u2192 SyntacticTerm L, Rew.rewrite f \u25b9 \u03c6 \u2208 axiomSet\n\ninstance : SetLike (Hilbert\u1d62 L) (SyntacticFormula\u1d62 L) where\n  coe := Hilbert\u1d62.axiomSet\n  coe_injective' := by rintro \u27e8T, _\u27e9 \u27e8U, _\u27e9; simp\n\nnamespace Hilbert\u1d62\n\ndef Minimal : Hilbert\u1d62 L := \u27e8\u2205, by simp\u27e9\n\nnotation \"\ud835\udc0c\ud835\udc22\ud835\udc27\u00b9\" => Minimal\n\ndef Intuitionistic : Hilbert\u1d62 L := \u27e8{\u22a5 \u279d \u03c6 | \u03c6}, by rintro _ \u27e8\u03c6, rfl\u27e9 f; exact \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\u27e9\n\nnotation \"\ud835\udc08\ud835\udc27\ud835\udc2d\u00b9\" => Intuitionistic\n\ndef Classical : Hilbert\u1d62 L := \u27e8{\u22a5 \u279d \u03c6 | \u03c6} \u222a {\u03c6 \u22ce \u223c\u03c6 | \u03c6}, by\n  rintro _ (\u27e8\u03c6, rfl\u27e9 | \u27e8\u03c6, rfl\u27e9) f\n  \u00b7 exact Or.inl \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\n  \u00b7 exact Or.inr \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\u27e9\n\nnotation \"\ud835\udc02\ud835\udc25\u00b9\" => Classical\n\nlemma minimal_le (\u039b : Hilbert\u1d62 L) : (Minimal : Hilbert\u1d62 L) \u2264 \u039b := by rintro _ \u27e8\u27e9\n\nlemma intuitionistic_le_classical : (Intuitionistic : Hilbert\u1d62 L) \u2264 Classical := by rintro _ \u27e8\u03c6, rfl\u27e9; exact .inl \u27e8\u03c6, rfl\u27e9\n\nend Hilbert\u1d62\n\ninductive HilbertProof\u1d62 (\u039b : Hilbert\u1d62 L) : SyntacticFormula\u1d62 L \u2192 Type _\n  | eaxm {\u03c6}     : \u03c6 \u2208 \u039b \u2192 HilbertProof\u1d62 \u039b \u03c6\n  | mdp {\u03c6 \u03c8}    : HilbertProof\u1d62 \u039b (\u03c6 \u279d \u03c8) \u2192 HilbertProof\u1d62 \u039b \u03c6 \u2192 HilbertProof\u1d62 \u039b \u03c8\n  | gen {\u03c6}      : HilbertProof\u1d62 \u039b (Rewriting.free \u03c6) \u2192 HilbertProof\u1d62 \u039b (\u2200' \u03c6)\n  | verum        : HilbertProof\u1d62 \u039b \u22a4\n  | imply\u2081 \u03c6 \u03c8   : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c8 \u279d \u03c6\n  | imply\u2082 \u03c6 \u03c8 \u03c7 : HilbertProof\u1d62 \u039b <| (\u03c6 \u279d \u03c8 \u279d \u03c7) \u279d (\u03c6 \u279d \u03c8) \u279d \u03c6 \u279d \u03c7\n  | and\u2081 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u22cf \u03c8 \u279d \u03c6\n  | and\u2082 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u22cf \u03c8 \u279d \u03c8\n  | and\u2083 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c8 \u279d \u03c6 \u22cf \u03c8\n  | or\u2081 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c6 \u22ce \u03c8\n  | or\u2082 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u03c8 \u279d \u03c6 \u22ce \u03c8\n  | or\u2083 \u03c6 \u03c8 \u03c7    : HilbertProof\u1d62 \u039b <| (\u03c6 \u279d \u03c7) \u279d (\u03c8 \u279d \u03c7) \u279d (\u03c6 \u22ce \u03c8 \u279d \u03c7)\n  | all\u2081 \u03c6 t     : HilbertProof\u1d62 \u039b <| \u2200' \u03c6 \u279d \u03c6/[t]\n  | all\u2082 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u2200' (\u03c6/[] \u279d \u03c8) \u279d \u03c6 \u279d \u2200' \u03c8\n  | ex\u2081 t \u03c6      : HilbertProof\u1d62 \u039b <| \u03c6/[t] \u279d \u2203' \u03c6\n  | ex\u2082 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u2200' (\u03c6 \u279d \u03c8/[]) \u279d \u2203' \u03c6 \u279d \u03c8\n\ninstance : System (SyntacticFormula\u1d62 L) (Hilbert\u1d62 L) := \u27e8HilbertProof\u1d62\u27e9\n\nnamespace HilbertProof\u1d62\n\nopen System.FiniteContext Rewriting LawfulSyntacticRewriting\n\nvariable (\u039b : Hilbert\u1d62 L)\n\ninstance : System.ModusPonens \u039b := \u27e8mdp\u27e9\n\ninstance : System.HasAxiomAndInst \u039b := \u27e8and\u2083\u27e9\n\ninstance : System.HasAxiomImply\u2081 \u039b := \u27e8imply\u2081\u27e9\n\ninstance : System.HasAxiomImply\u2082 \u039b := \u27e8imply\u2082\u27e9\n\ninstance : System.Minimal \u039b where\n  mdp := mdp\n  verum := verum\n  imply\u2081 := imply\u2081\n  imply\u2082 := imply\u2082\n  and\u2081 := and\u2081\n  and\u2082 := and\u2082\n  and\u2083 := and\u2083\n  or\u2081 := or\u2081\n  or\u2082 := or\u2082\n  or\u2083 := or\u2083\n  neg_equiv _ := System.iffId _\n\nvariable {\u039b}\n\nprotected def cast {\u03c6 \u03c8} (b : \u039b \u22a2 \u03c6) (e : \u03c6 = \u03c8) : \u039b \u22a2 \u03c8 := e \u25b8 b\n\ndef depth {\u03c6} : \u039b \u22a2 \u03c6 \u2192 \u2115\n  | mdp b d => max (depth b) (depth d) + 1\n  | gen b   => depth b + 1\n  | _       => 0\n\nscoped notation \"\u2016\" d \"\u2016\" => depth d\n\n@[simp] lemma depth_eaxm (h : \u03c6 \u2208 \u039b) : \u2016eaxm h\u2016 = 0 := rfl\n@[simp] lemma depth_mdp (b : \u039b \u22a2 \u03c6 \u279d \u03c8) (d : \u039b \u22a2 \u03c6) : \u2016mdp b d\u2016 = max \u2016b\u2016 \u2016d\u2016 + 1 := rfl\n@[simp] lemma depth_gen (b : \u039b \u22a2 Rewriting.free \u03c6) : \u2016gen b\u2016 = \u2016b\u2016 + 1 := rfl\n@[simp] lemma depth_verum : \u2016(verum : \u039b \u22a2 \u22a4)\u2016 = 0 := rfl\n@[simp] lemma depth_imply\u2081 (\u03c6 \u03c8) : \u2016imply\u2081 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_imply\u2082 (\u03c6 \u03c8 \u03c7) : \u2016imply\u2082 (\u039b := \u039b) \u03c6 \u03c8 \u03c7\u2016 = 0 := rfl\n@[simp] lemma depth_and\u2081 (\u03c6 \u03c8) : \u2016and\u2081 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_and\u2082 (\u03c6 \u03c8) : \u2016and\u2082 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_and\u2083 (\u03c6 \u03c8) : \u2016and\u2083 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_or\u2081 (\u03c6 \u03c8) : \u2016or\u2081 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_or\u2082 (\u03c6 \u03c8) : \u2016or\u2082 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_or\u2083 (\u03c6 \u03c8 \u03c7) : \u2016or\u2083 (\u039b := \u039b) \u03c6 \u03c8 \u03c7\u2016 = 0 := rfl\n@[simp] lemma depth_all\u2081 (\u03c6 t) : \u2016all\u2081 (\u039b := \u039b) \u03c6 t\u2016 = 0 := rfl\n@[simp] lemma depth_all\u2082 (\u03c6 \u03c8) : \u2016all\u2082 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n", "theoremStatement": "@[simp] lemma depth_ex\u2081 (t \u03c6) : \u2016ex\u2081 (\u039b := \u039b) t \u03c6\u2016 = 0 ", "theoremName": "LO.FirstOrder.HilbertProof\u1d62.depth_ex\u2081", "fileCreated": {"commit": "7d9e3859942c3a17a697b129e7fb3869eca0066e", "date": "2024-11-09"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/IntFO/Basic/Deduction.lean", "module": "Foundation.IntFO.Basic.Deduction", "jsonFile": "Foundation.IntFO.Basic.Deduction.jsonl", "positionMetadata": {"lineInFile": 114, "tokenPositionInFile": 3922, "theoremPositionInFile": 25}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 16, "numPremises": 24}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "import Foundation.IntFO.Basic.Rew\n\nnamespace LO.FirstOrder\n\nabbrev Sequent\u1d62 (L : Language) := List (SyntacticFormula\u1d62 L)\n\nopen Semiformula\u1d62\n\nvariable {L : Language} {T : Theory L}\n\nstructure Hilbert\u1d62 (L : Language) where\n  axiomSet : Set (SyntacticFormula\u1d62 L)\n  rewrite_closed {\u03c6 : SyntacticFormula\u1d62 L} : \u03c6 \u2208 axiomSet \u2192 \u2200 f : \u2115 \u2192 SyntacticTerm L, Rew.rewrite f \u25b9 \u03c6 \u2208 axiomSet\n\ninstance : SetLike (Hilbert\u1d62 L) (SyntacticFormula\u1d62 L) where\n  coe := Hilbert\u1d62.axiomSet\n  coe_injective' := by rintro \u27e8T, _\u27e9 \u27e8U, _\u27e9; simp\n\nnamespace Hilbert\u1d62\n\ndef Minimal : Hilbert\u1d62 L := \u27e8\u2205, by simp\u27e9\n\nnotation \"\ud835\udc0c\ud835\udc22\ud835\udc27\u00b9\" => Minimal\n\ndef Intuitionistic : Hilbert\u1d62 L := \u27e8{\u22a5 \u279d \u03c6 | \u03c6}, by rintro _ \u27e8\u03c6, rfl\u27e9 f; exact \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\u27e9\n\nnotation \"\ud835\udc08\ud835\udc27\ud835\udc2d\u00b9\" => Intuitionistic\n\ndef Classical : Hilbert\u1d62 L := \u27e8{\u22a5 \u279d \u03c6 | \u03c6} \u222a {\u03c6 \u22ce \u223c\u03c6 | \u03c6}, by\n  rintro _ (\u27e8\u03c6, rfl\u27e9 | \u27e8\u03c6, rfl\u27e9) f\n  \u00b7 exact Or.inl \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\n  \u00b7 exact Or.inr \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\u27e9\n\nnotation \"\ud835\udc02\ud835\udc25\u00b9\" => Classical\n\nlemma minimal_le (\u039b : Hilbert\u1d62 L) : (Minimal : Hilbert\u1d62 L) \u2264 \u039b := by rintro _ \u27e8\u27e9\n\nlemma intuitionistic_le_classical : (Intuitionistic : Hilbert\u1d62 L) \u2264 Classical := by rintro _ \u27e8\u03c6, rfl\u27e9; exact .inl \u27e8\u03c6, rfl\u27e9\n\nend Hilbert\u1d62\n\ninductive HilbertProof\u1d62 (\u039b : Hilbert\u1d62 L) : SyntacticFormula\u1d62 L \u2192 Type _\n  | eaxm {\u03c6}     : \u03c6 \u2208 \u039b \u2192 HilbertProof\u1d62 \u039b \u03c6\n  | mdp {\u03c6 \u03c8}    : HilbertProof\u1d62 \u039b (\u03c6 \u279d \u03c8) \u2192 HilbertProof\u1d62 \u039b \u03c6 \u2192 HilbertProof\u1d62 \u039b \u03c8\n  | gen {\u03c6}      : HilbertProof\u1d62 \u039b (Rewriting.free \u03c6) \u2192 HilbertProof\u1d62 \u039b (\u2200' \u03c6)\n  | verum        : HilbertProof\u1d62 \u039b \u22a4\n  | imply\u2081 \u03c6 \u03c8   : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c8 \u279d \u03c6\n  | imply\u2082 \u03c6 \u03c8 \u03c7 : HilbertProof\u1d62 \u039b <| (\u03c6 \u279d \u03c8 \u279d \u03c7) \u279d (\u03c6 \u279d \u03c8) \u279d \u03c6 \u279d \u03c7\n  | and\u2081 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u22cf \u03c8 \u279d \u03c6\n  | and\u2082 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u22cf \u03c8 \u279d \u03c8\n  | and\u2083 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c8 \u279d \u03c6 \u22cf \u03c8\n  | or\u2081 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c6 \u22ce \u03c8\n  | or\u2082 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u03c8 \u279d \u03c6 \u22ce \u03c8\n  | or\u2083 \u03c6 \u03c8 \u03c7    : HilbertProof\u1d62 \u039b <| (\u03c6 \u279d \u03c7) \u279d (\u03c8 \u279d \u03c7) \u279d (\u03c6 \u22ce \u03c8 \u279d \u03c7)\n  | all\u2081 \u03c6 t     : HilbertProof\u1d62 \u039b <| \u2200' \u03c6 \u279d \u03c6/[t]\n  | all\u2082 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u2200' (\u03c6/[] \u279d \u03c8) \u279d \u03c6 \u279d \u2200' \u03c8\n  | ex\u2081 t \u03c6      : HilbertProof\u1d62 \u039b <| \u03c6/[t] \u279d \u2203' \u03c6\n  | ex\u2082 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u2200' (\u03c6 \u279d \u03c8/[]) \u279d \u2203' \u03c6 \u279d \u03c8\n\ninstance : System (SyntacticFormula\u1d62 L) (Hilbert\u1d62 L) := \u27e8HilbertProof\u1d62\u27e9\n\nnamespace HilbertProof\u1d62\n\nopen System.FiniteContext Rewriting LawfulSyntacticRewriting\n\nvariable (\u039b : Hilbert\u1d62 L)\n\ninstance : System.ModusPonens \u039b := \u27e8mdp\u27e9\n\ninstance : System.HasAxiomAndInst \u039b := \u27e8and\u2083\u27e9\n\ninstance : System.HasAxiomImply\u2081 \u039b := \u27e8imply\u2081\u27e9\n\ninstance : System.HasAxiomImply\u2082 \u039b := \u27e8imply\u2082\u27e9\n\ninstance : System.Minimal \u039b where\n  mdp := mdp\n  verum := verum\n  imply\u2081 := imply\u2081\n  imply\u2082 := imply\u2082\n  and\u2081 := and\u2081\n  and\u2082 := and\u2082\n  and\u2083 := and\u2083\n  or\u2081 := or\u2081\n  or\u2082 := or\u2082\n  or\u2083 := or\u2083\n  neg_equiv _ := System.iffId _\n\nvariable {\u039b}\n\nprotected def cast {\u03c6 \u03c8} (b : \u039b \u22a2 \u03c6) (e : \u03c6 = \u03c8) : \u039b \u22a2 \u03c8 := e \u25b8 b\n\ndef depth {\u03c6} : \u039b \u22a2 \u03c6 \u2192 \u2115\n  | mdp b d => max (depth b) (depth d) + 1\n  | gen b   => depth b + 1\n  | _       => 0\n\nscoped notation \"\u2016\" d \"\u2016\" => depth d\n\n@[simp] lemma depth_eaxm (h : \u03c6 \u2208 \u039b) : \u2016eaxm h\u2016 = 0 := rfl\n", "theoremStatement": "@[simp] lemma depth_mdp (b : \u039b \u22a2 \u03c6 \u279d \u03c8) (d : \u039b \u22a2 \u03c6) : \u2016mdp b d\u2016 = max \u2016b\u2016 \u2016d\u2016 + 1 ", "theoremName": "LO.FirstOrder.HilbertProof\u1d62.depth_mdp", "fileCreated": {"commit": "7d9e3859942c3a17a697b129e7fb3869eca0066e", "date": "2024-11-09"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/IntFO/Basic/Deduction.lean", "module": "Foundation.IntFO.Basic.Deduction", "jsonFile": "Foundation.IntFO.Basic.Deduction.jsonl", "positionMetadata": {"lineInFile": 101, "tokenPositionInFile": 3048, "theoremPositionInFile": 12}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 9, "numPremises": 19}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "import Foundation.IntProp.Formula\nimport Foundation.Modal.Formula\n\nnamespace LO.IntProp\n\ndef Formula.toModalFormula : Formula \u03b1 \u2192 Modal.Formula \u03b1\n  | .atom a => Modal.Formula.atom a\n  | \u22a4 => \u22a4\n  | \u22a5 => \u22a5\n  | \u223c\u03c6 => \u223c(toModalFormula \u03c6)\n  | \u03c6 \u279d \u03c8 => (toModalFormula \u03c6) \u279d (toModalFormula \u03c8)\n  | \u03c6 \u22cf \u03c8 => (toModalFormula \u03c6) \u22cf (toModalFormula \u03c8)\n  | \u03c6 \u22ce \u03c8 => (toModalFormula \u03c6) \u22ce (toModalFormula \u03c8)\npostfix:75 \"\u1d39\" => Formula.toModalFormula\n\nnamespace Formula.toModalFormula\n\n@[simp] lemma def_top : (\u22a4 : Formula \u03b1)\u1d39 = \u22a4 := by rfl\n\n@[simp] lemma def_bot : (\u22a5 : Formula \u03b1)\u1d39 = \u22a5 := by rfl\n\n@[simp] lemma def_atom (a : \u03b1) : (atom a)\u1d39 = .atom a := by rfl\n\n@[simp] lemma def_not (\u03c6 : Formula \u03b1) : (\u223c\u03c6)\u1d39 = \u223c(\u03c6\u1d39) := by rfl\n\n@[simp] lemma def_imp (\u03c6 \u03c8 : Formula \u03b1) : (\u03c6 \u279d \u03c8)\u1d39 = (\u03c6\u1d39) \u279d (\u03c8\u1d39) := by rfl\n\n@[simp] lemma def_and (\u03c6 \u03c8 : Formula \u03b1) : (\u03c6 \u22cf \u03c8)\u1d39 = (\u03c6\u1d39) \u22cf (\u03c8\u1d39) := by rfl\n\n", "theoremStatement": "@[simp] lemma def_or (\u03c6 \u03c8 : Formula \u03b1) : (\u03c6 \u22ce \u03c8)\u1d39 = (\u03c6\u1d39) \u22ce (\u03c8\u1d39) ", "theoremName": "LO.IntProp.Formula.toModalFormula.def_or", "fileCreated": {"commit": "a1bfd1fa480026f05e476050030c0b2d17983bb0", "date": "2024-11-28"}, "theoremCreated": {"commit": "54324e6e009f0d0a288897312d3feb1c0165ad19", "date": "2025-01-24"}, "file": "foundation/Foundation/Modal/IntProp.lean", "module": "Foundation.Modal.IntProp", "jsonFile": "Foundation.Modal.IntProp.jsonl", "positionMetadata": {"lineInFile": 30, "tokenPositionInFile": 862, "theoremPositionInFile": 7}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 8, "numPremises": 10}, "proofMetadata": {"hasProof": true, "proof": ":= by rfl", "proofType": "tactic", "proofLengthLines": 0, "proofLengthTokens": 9}}
{"srcContext": "import Foundation.IntFO.Basic.Rew\n\nnamespace LO.FirstOrder\n\nabbrev Sequent\u1d62 (L : Language) := List (SyntacticFormula\u1d62 L)\n\nopen Semiformula\u1d62\n\nvariable {L : Language} {T : Theory L}\n\nstructure Hilbert\u1d62 (L : Language) where\n  axiomSet : Set (SyntacticFormula\u1d62 L)\n  rewrite_closed {\u03c6 : SyntacticFormula\u1d62 L} : \u03c6 \u2208 axiomSet \u2192 \u2200 f : \u2115 \u2192 SyntacticTerm L, Rew.rewrite f \u25b9 \u03c6 \u2208 axiomSet\n\ninstance : SetLike (Hilbert\u1d62 L) (SyntacticFormula\u1d62 L) where\n  coe := Hilbert\u1d62.axiomSet\n  coe_injective' := by rintro \u27e8T, _\u27e9 \u27e8U, _\u27e9; simp\n\nnamespace Hilbert\u1d62\n\ndef Minimal : Hilbert\u1d62 L := \u27e8\u2205, by simp\u27e9\n\nnotation \"\ud835\udc0c\ud835\udc22\ud835\udc27\u00b9\" => Minimal\n\ndef Intuitionistic : Hilbert\u1d62 L := \u27e8{\u22a5 \u279d \u03c6 | \u03c6}, by rintro _ \u27e8\u03c6, rfl\u27e9 f; exact \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\u27e9\n\nnotation \"\ud835\udc08\ud835\udc27\ud835\udc2d\u00b9\" => Intuitionistic\n\ndef Classical : Hilbert\u1d62 L := \u27e8{\u22a5 \u279d \u03c6 | \u03c6} \u222a {\u03c6 \u22ce \u223c\u03c6 | \u03c6}, by\n  rintro _ (\u27e8\u03c6, rfl\u27e9 | \u27e8\u03c6, rfl\u27e9) f\n  \u00b7 exact Or.inl \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\n  \u00b7 exact Or.inr \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\u27e9\n\nnotation \"\ud835\udc02\ud835\udc25\u00b9\" => Classical\n\nlemma minimal_le (\u039b : Hilbert\u1d62 L) : (Minimal : Hilbert\u1d62 L) \u2264 \u039b := by rintro _ \u27e8\u27e9\n\nlemma intuitionistic_le_classical : (Intuitionistic : Hilbert\u1d62 L) \u2264 Classical := by rintro _ \u27e8\u03c6, rfl\u27e9; exact .inl \u27e8\u03c6, rfl\u27e9\n\nend Hilbert\u1d62\n\ninductive HilbertProof\u1d62 (\u039b : Hilbert\u1d62 L) : SyntacticFormula\u1d62 L \u2192 Type _\n  | eaxm {\u03c6}     : \u03c6 \u2208 \u039b \u2192 HilbertProof\u1d62 \u039b \u03c6\n  | mdp {\u03c6 \u03c8}    : HilbertProof\u1d62 \u039b (\u03c6 \u279d \u03c8) \u2192 HilbertProof\u1d62 \u039b \u03c6 \u2192 HilbertProof\u1d62 \u039b \u03c8\n  | gen {\u03c6}      : HilbertProof\u1d62 \u039b (Rewriting.free \u03c6) \u2192 HilbertProof\u1d62 \u039b (\u2200' \u03c6)\n  | verum        : HilbertProof\u1d62 \u039b \u22a4\n  | imply\u2081 \u03c6 \u03c8   : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c8 \u279d \u03c6\n  | imply\u2082 \u03c6 \u03c8 \u03c7 : HilbertProof\u1d62 \u039b <| (\u03c6 \u279d \u03c8 \u279d \u03c7) \u279d (\u03c6 \u279d \u03c8) \u279d \u03c6 \u279d \u03c7\n  | and\u2081 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u22cf \u03c8 \u279d \u03c6\n  | and\u2082 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u22cf \u03c8 \u279d \u03c8\n  | and\u2083 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c8 \u279d \u03c6 \u22cf \u03c8\n  | or\u2081 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c6 \u22ce \u03c8\n  | or\u2082 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u03c8 \u279d \u03c6 \u22ce \u03c8\n  | or\u2083 \u03c6 \u03c8 \u03c7    : HilbertProof\u1d62 \u039b <| (\u03c6 \u279d \u03c7) \u279d (\u03c8 \u279d \u03c7) \u279d (\u03c6 \u22ce \u03c8 \u279d \u03c7)\n  | all\u2081 \u03c6 t     : HilbertProof\u1d62 \u039b <| \u2200' \u03c6 \u279d \u03c6/[t]\n  | all\u2082 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u2200' (\u03c6/[] \u279d \u03c8) \u279d \u03c6 \u279d \u2200' \u03c8\n  | ex\u2081 t \u03c6      : HilbertProof\u1d62 \u039b <| \u03c6/[t] \u279d \u2203' \u03c6\n  | ex\u2082 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u2200' (\u03c6 \u279d \u03c8/[]) \u279d \u2203' \u03c6 \u279d \u03c8\n\ninstance : System (SyntacticFormula\u1d62 L) (Hilbert\u1d62 L) := \u27e8HilbertProof\u1d62\u27e9\n\nnamespace HilbertProof\u1d62\n\nopen System.FiniteContext Rewriting LawfulSyntacticRewriting\n\nvariable (\u039b : Hilbert\u1d62 L)\n\ninstance : System.ModusPonens \u039b := \u27e8mdp\u27e9\n\ninstance : System.HasAxiomAndInst \u039b := \u27e8and\u2083\u27e9\n\ninstance : System.HasAxiomImply\u2081 \u039b := \u27e8imply\u2081\u27e9\n\ninstance : System.HasAxiomImply\u2082 \u039b := \u27e8imply\u2082\u27e9\n\ninstance : System.Minimal \u039b where\n  mdp := mdp\n  verum := verum\n  imply\u2081 := imply\u2081\n  imply\u2082 := imply\u2082\n  and\u2081 := and\u2081\n  and\u2082 := and\u2082\n  and\u2083 := and\u2083\n  or\u2081 := or\u2081\n  or\u2082 := or\u2082\n  or\u2083 := or\u2083\n  neg_equiv _ := System.iffId _\n\nvariable {\u039b}\n\nprotected def cast {\u03c6 \u03c8} (b : \u039b \u22a2 \u03c6) (e : \u03c6 = \u03c8) : \u039b \u22a2 \u03c8 := e \u25b8 b\n\ndef depth {\u03c6} : \u039b \u22a2 \u03c6 \u2192 \u2115\n  | mdp b d => max (depth b) (depth d) + 1\n  | gen b   => depth b + 1\n  | _       => 0\n\nscoped notation \"\u2016\" d \"\u2016\" => depth d\n\n@[simp] lemma depth_eaxm (h : \u03c6 \u2208 \u039b) : \u2016eaxm h\u2016 = 0 := rfl\n@[simp] lemma depth_mdp (b : \u039b \u22a2 \u03c6 \u279d \u03c8) (d : \u039b \u22a2 \u03c6) : \u2016mdp b d\u2016 = max \u2016b\u2016 \u2016d\u2016 + 1 := rfl\n@[simp] lemma depth_gen (b : \u039b \u22a2 Rewriting.free \u03c6) : \u2016gen b\u2016 = \u2016b\u2016 + 1 := rfl\n@[simp] lemma depth_verum : \u2016(verum : \u039b \u22a2 \u22a4)\u2016 = 0 := rfl\n@[simp] lemma depth_imply\u2081 (\u03c6 \u03c8) : \u2016imply\u2081 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_imply\u2082 (\u03c6 \u03c8 \u03c7) : \u2016imply\u2082 (\u039b := \u039b) \u03c6 \u03c8 \u03c7\u2016 = 0 := rfl\n@[simp] lemma depth_and\u2081 (\u03c6 \u03c8) : \u2016and\u2081 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_and\u2082 (\u03c6 \u03c8) : \u2016and\u2082 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n", "theoremStatement": "@[simp] lemma depth_and\u2083 (\u03c6 \u03c8) : \u2016and\u2083 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 ", "theoremName": "LO.FirstOrder.HilbertProof\u1d62.depth_and\u2083", "fileCreated": {"commit": "7d9e3859942c3a17a697b129e7fb3869eca0066e", "date": "2024-11-09"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/IntFO/Basic/Deduction.lean", "module": "Foundation.IntFO.Basic.Deduction", "jsonFile": "Foundation.IntFO.Basic.Deduction.jsonl", "positionMetadata": {"lineInFile": 108, "tokenPositionInFile": 3540, "theoremPositionInFile": 19}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 10, "numPremises": 15}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "import Foundation.Modal.Kripke.Geach.Systems\n\nnamespace LO.Modal.Hilbert\n\nopen System\nopen Modal.Kripke\nopen Formula\nopen Formula.Kripke\n\nlemma K5_weakerThan_KD5 : (Hilbert.K5 \u03b1) \u2264\u209b (Hilbert.KD5 \u03b1) := normal_weakerThan_of_subset $ by intro; aesop;\n\n", "theoremStatement": "theorem K5_strictlyWeakerThan_KD5 : (Hilbert.K5 \u2115) <\u209b (Hilbert.KD5 \u2115) ", "theoremName": "LO.Modal.Hilbert.K5_strictlyWeakerThan_KD5", "fileCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "theoremCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "file": "foundation/Foundation/Modal/Hilbert/WeakerThan/K5_KD5.lean", "module": "Foundation.Modal.Hilbert.WeakerThan.K5_KD5", "jsonFile": "Foundation.Modal.Hilbert.WeakerThan.K5_KD5.jsonl", "positionMetadata": {"lineInFile": 12, "tokenPositionInFile": 249, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 62, "numPremises": 124}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  constructor;\n  . exact K5_weakerThan_KD5;\n  . apply weakerThan_iff.not.mpr;\n    push_neg;\n    use (\u25a1(atom 0) \u279d \u25c7(atom 0));\n    constructor;\n    . exact Deduction.maxm! $ by simp;\n    . apply K5.Kripke.sound.not_provable_of_countermodel;\n      suffices \u2203 F : Frame, Euclidean F.Rel \u2227 \u2203 V : Valuation F, \u2203 w : F.World, \u00ac(Kripke.Satisfies \u27e8F, V\u27e9 w _) by\n        simp [ValidOnModel, ValidOnFrame, Satisfies];\n        tauto;\n      let F : Frame := \u27e8Fin 1, \u03bb x y => False\u27e9;\n      use F;\n      constructor;\n      . simp [Euclidean];\n      . use (\u03bb w _ => w = 0), 0;\n        simp [Semantics.Realize, Satisfies];", "proofType": "tactic", "proofLengthLines": 17, "proofLengthTokens": 611}}
{"srcContext": "import Foundation.Modal.Kripke.Geach.Systems\n\nnamespace LO.Modal.Hilbert\n\nopen System\nopen Modal.Kripke\nopen Formula\nopen Formula.Kripke\n\n", "theoremStatement": "lemma KD_weakerThan_KDB : (Hilbert.KD \u03b1) \u2264\u209b (Hilbert.KDB \u03b1) ", "theoremName": "LO.Modal.Hilbert.KD_weakerThan_KDB", "fileCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "theoremCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "file": "foundation/Foundation/Modal/Hilbert/WeakerThan/KD_KDB.lean", "module": "Foundation.Modal.Hilbert.WeakerThan.KD_KDB", "jsonFile": "Foundation.Modal.Hilbert.WeakerThan.KD_KDB.jsonl", "positionMetadata": {"lineInFile": 10, "tokenPositionInFile": 138, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 19, "numPremises": 43}, "proofMetadata": {"hasProof": true, "proof": ":= normal_weakerThan_of_subset $ by intro; aesop;", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 49}}
{"srcContext": "import Foundation.Modal.Kripke.Geach.Systems\n\nnamespace LO.Modal.Hilbert\n\nopen System\nopen Modal.Kripke\nopen Formula\nopen Formula.Kripke\n\n", "theoremStatement": "lemma KB5_weakerThan_S5 : (Hilbert.KB5 \u2115) \u2264\u209b (Hilbert.S5 \u2115) ", "theoremName": "LO.Modal.Hilbert.KB5_weakerThan_S5", "fileCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "theoremCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "file": "foundation/Foundation/Modal/Hilbert/WeakerThan/KB5_S5.lean", "module": "Foundation.Modal.Hilbert.WeakerThan.KB5_S5", "jsonFile": "Foundation.Modal.Hilbert.WeakerThan.KB5_S5.jsonl", "positionMetadata": {"lineInFile": 10, "tokenPositionInFile": 138, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 22, "numPremises": 32}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  apply Kripke.weakerThan_of_subset_FrameClass SymmetricEuclideanFrameClass ReflexiveEuclideanFrameClass;\n  rintro F \u27e8h_refl, h_eucl\u27e9;\n  refine \u27e8symm_of_refl_eucl h_refl h_eucl, h_eucl\u27e9;", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 192}}
{"srcContext": "import Foundation.Logic.Predicate.Term\nimport Foundation.Logic.Predicate.Quantifier\n\n/-!\n# Rewriting System\n\nterm/formula morphisms such as Rewritings, substitutions, and embeddings are handled by the structure `LO.FirstOrder.Rew`.\n- `LO.FirstOrder.Rew.rewrite f` is a Rewriting of the free variables occurring in the term by `f : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n`.\n- `LO.FirstOrder.Rew.substs v` is a substitution of the bounded variables occurring in the term by `v : Fin n \u2192 Semiterm L \u03be n'`.\n- `LO.FirstOrder.Rew.bShift` is a transformation of the bounded variables occurring in the term by `#x \u21a6 #(Fin.succ x)`.\n- `LO.FirstOrder.Rew.shift` is a transformation of the free variables occurring in the term by `&x \u21a6 &(x + 1)`.\n- `LO.FirstOrder.Rew.emb` is a embedding of the term with no free variables.\n\nRewritings `LO.FirstOrder.Rew` is naturally converted to formula Rewritings by `LO.FirstOrder.Rew.hom`.\n\n-/\n\nnamespace LO\n\nnamespace FirstOrder\n\nstructure Rew (L : Language) (\u03be\u2081 : Type*) (n\u2081 : \u2115) (\u03be\u2082 : Type*) (n\u2082 : \u2115) where\n  toFun : Semiterm L \u03be\u2081 n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082\n  func' : \u2200 {k} (f : L.Func k) (v : Fin k \u2192 Semiterm L \u03be\u2081 n\u2081), toFun (Semiterm.func f v) = Semiterm.func f (fun i => toFun (v i))\n\nabbrev SyntacticRew (L : Language) (n\u2081 n\u2082 : \u2115) := Rew L \u2115 n\u2081 \u2115 n\u2082\n\nnamespace Rew\n\nopen Semiterm\nvariable {L L' L\u2081 L\u2082 L\u2083 : Language} {\u03be \u03be' \u03be\u2081 \u03be\u2082 \u03be\u2083 : Type*} {n n\u2081 n\u2082 n\u2083 : \u2115}\nvariable (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082)\n\ninstance : FunLike (Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) (Semiterm L \u03be\u2081 n\u2081) (Semiterm L \u03be\u2082 n\u2082) where\n  coe := fun f => f.toFun\n  coe_injective' := fun f g h => by rcases f; rcases g; simpa using h\n\ninstance : CoeFun (Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) (fun _ => Semiterm L \u03be\u2081 n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) := DFunLike.hasCoeToFun\n\nprotected lemma func {k} (f : L.Func k) (v : Fin k \u2192 Semiterm L \u03be\u2081 n\u2081) :\n    \u03c9 (func f v) = func f (fun i => \u03c9 (v i)) := \u03c9.func' f v\n\nlemma func'' {k} (f : L.Func k) (v : Fin k \u2192 Semiterm L \u03be\u2081 n\u2081) :\n    \u03c9 (func f v) = func f (\u03c9 \u2218 v) := \u03c9.func' f v\n\n@[simp] lemma func0 (f : L.Func 0) (v : Fin 0 \u2192 Semiterm L \u03be\u2081 n\u2081) :\n    \u03c9 (func f v) = func f ![] := by simp[Rew.func, Matrix.empty_eq]\n\n@[simp] lemma func1 (f : L.Func 1) (t : Semiterm L \u03be\u2081 n\u2081) :\n    \u03c9 (func f ![t]) = func f ![\u03c9 t] := by simp[Matrix.constant_eq_singleton, Rew.func]\n\n@[simp] lemma func2 (f : L.Func 2) (t\u2081 t\u2082 : Semiterm L \u03be\u2081 n\u2081) :\n    \u03c9 (func f ![t\u2081, t\u2082]) = func f ![\u03c9 t\u2081, \u03c9 t\u2082] := by\n  simp only [Rew.func, func.injEq, heq_eq_eq, true_and]\n  funext i\n  induction i using Fin.induction <;> simp\n\n@[simp] lemma func3 (f : L.Func 3) (t\u2081 t\u2082 t\u2083 : Semiterm L \u03be\u2081 n\u2081) :\n    \u03c9 (func f ![t\u2081, t\u2082, t\u2083]) = func f ![\u03c9 t\u2081, \u03c9 t\u2082, \u03c9 t\u2083] := by\n  simp only [Rew.func, func.injEq, heq_eq_eq, true_and]\n  funext i; induction' i using Fin.induction with i\n  \u00b7 simp\n  \u00b7 induction' i using Fin.induction with i <;> simp\n\n@[ext] lemma ext (\u03c9\u2081 \u03c9\u2082 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) (hb : \u2200 x, \u03c9\u2081 #x = \u03c9\u2082 #x) (hf : \u2200 x, \u03c9\u2081 &x = \u03c9\u2082 &x) : \u03c9\u2081 = \u03c9\u2082 := by\n  apply DFunLike.ext \u03c9\u2081 \u03c9\u2082; intro t\n  induction t <;> simp[*, \u03c9\u2081.func, \u03c9\u2082.func]\n\nlemma ext' {\u03c9\u2081 \u03c9\u2082 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082} (h : \u03c9\u2081 = \u03c9\u2082) (t) : \u03c9\u2081 t = \u03c9\u2082 t := by simp[h]\n\nprotected def id : Rew L \u03be n \u03be n where\n  toFun := id\n  func' := fun _ _ => rfl\n\n@[simp] lemma id_app (t : Semiterm L \u03be n) : Rew.id t = t := rfl\n\nprotected def comp (\u03c9\u2082 : Rew L \u03be\u2082 n\u2082 \u03be\u2083 n\u2083) (\u03c9\u2081 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) : Rew L \u03be\u2081 n\u2081 \u03be\u2083 n\u2083 where\n  toFun := fun t => \u03c9\u2082 (\u03c9\u2081 t)\n  func' := fun f v => by simp[func'']; rfl\n\nlemma comp_app (\u03c9\u2082 : Rew L \u03be\u2082 n\u2082 \u03be\u2083 n\u2083) (\u03c9\u2081 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) (t : Semiterm L \u03be\u2081 n\u2081) :\n    (\u03c9\u2082.comp \u03c9\u2081) t = \u03c9\u2082 (\u03c9\u2081 t) := rfl\n\n@[simp] lemma id_comp (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) : Rew.id.comp \u03c9 = \u03c9 := by ext <;> simp[comp_app]\n\n@[simp] lemma comp_id (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) : \u03c9.comp Rew.id = \u03c9 := by ext <;> simp[comp_app]\n\ndef bindAux (b : Fin n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) (e : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) : Semiterm L \u03be\u2081 n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082\n  | (#x)       => b x\n  | (&x)       => e x\n  | (func f v) => func f (fun i => bindAux b e (v i))\n\ndef bind (b : Fin n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) (e : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082 where\n  toFun := bindAux b e\n  func' := fun _ _ => rfl\n\ndef rewrite (f : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n) : Rew L \u03be\u2081 n \u03be\u2082 n := bind Semiterm.bvar f\n\ndef rewriteMap (e : \u03be\u2081 \u2192 \u03be\u2082) : Rew L \u03be\u2081 n \u03be\u2082 n := rewrite (fun m => &(e m))\n\ndef map (b : Fin n\u2081 \u2192 Fin n\u2082) (e : \u03be\u2081 \u2192 \u03be\u2082) : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082 :=\n  bind (fun n => #(b n)) (fun m => &(e m))\n\ndef substs {n'} (v : Fin n \u2192 Semiterm L \u03be n') : Rew L \u03be n \u03be n' :=\n  bind v fvar\n\ndef emb {o : Type v\u2081} [h : IsEmpty o] {\u03be : Type v\u2082} {n} : Rew L o n \u03be n := map id h.elim\n\nabbrev embs {o : Type v\u2081} [IsEmpty o] {n} : Rew L o n \u2115 n := emb\n\ndef empty {o : Type v\u2081} [h : IsEmpty o] {\u03be : Type v\u2082} {n} : Rew L o 0 \u03be n := map Fin.elim0 h.elim\n\ndef bShift : Rew L \u03be n \u03be (n + 1) :=\n  map Fin.succ id\n\ndef bShiftAdd (m : \u2115) : Rew L \u03be n \u03be (n + m) :=\n  map (Fin.addNat \u00b7 m) id\n\ndef cast {n n' : \u2115} (h : n = n') : Rew L \u03be n \u03be n' :=\n  map (Fin.cast h) id\n\ndef castLE {n n' : \u2115} (h : n \u2264 n') : Rew L \u03be n \u03be n' :=\n  map (Fin.castLE h) id\n\ndef toS : Rew L (Fin n) 0 Empty n := Rew.bind ![] (#\u00b7)\n\ndef toF : Rew L Empty n (Fin n) 0 := Rew.bind (&\u00b7) Empty.elim\n\ndef embSubsts (v : Fin k \u2192 Semiterm L \u03be n) : Rew L Empty k \u03be n := Rew.bind v Empty.elim\n\nprotected def q (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) : Rew L \u03be\u2081 (n\u2081 + 1) \u03be\u2082 (n\u2082 + 1) :=\n  bind (#0 :> bShift \u2218 \u03c9 \u2218 bvar) (bShift \u2218 \u03c9 \u2218 fvar)\n\nlemma eq_id_of_eq {\u03c9 : Rew L \u03be n \u03be n} (hb : \u2200 x, \u03c9 #x = #x) (he : \u2200 x, \u03c9 &x = &x) (t) : \u03c9 t = t := by\n  have : \u03c9 = Rew.id := by ext <;> simp[*]\n  simp[this]\n\ndef qpow (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) : (k : \u2115) \u2192 Rew L \u03be\u2081 (n\u2081 + k) \u03be\u2082 (n\u2082 + k)\n  | 0     => \u03c9\n  | k + 1 => (\u03c9.qpow k).q\n\n@[simp] lemma qpow_zero (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) : qpow \u03c9 0 = \u03c9 := rfl\n\n@[simp] lemma qpow_succ (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) (k : \u2115) : qpow \u03c9 (k + 1) = (\u03c9.qpow k).q := rfl\n\nsection bind\n\nvariable (b : Fin n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) (e : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082)\n\n@[simp] lemma bind_fvar (m : \u03be\u2081) : bind b e (&m : Semiterm L \u03be\u2081 n\u2081) = e m := rfl\n\n@[simp] lemma bind_bvar (n : Fin n\u2081) : bind b e (#n : Semiterm L \u03be\u2081 n\u2081) = b n := rfl\n\nlemma eq_bind (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) : \u03c9 = bind (\u03c9 \u2218 bvar) (\u03c9 \u2218 fvar) := by\n  ext t; induction t ;simp [Rew.func'']; simp [*]\n\n@[simp] lemma bind_eq_id_of_zero (f : Fin 0 \u2192 Semiterm L \u03be\u2082 0) : bind f fvar = Rew.id := by\n  ext x <;> simp only [bind_bvar, bind_fvar, id_app]; exact Fin.elim0 x\n\nend bind\n\nsection map\n\nvariable (b : Fin n\u2081 \u2192 Fin n\u2082) (e : \u03be\u2081 \u2192 \u03be\u2082)\n\n@[simp] lemma map_fvar (m : \u03be\u2081) : map b e (&m : Semiterm L \u03be\u2081 n\u2081) = &(e m) := rfl\n\n@[simp] lemma map_bvar (n : Fin n\u2081) : map b e (#n : Semiterm L \u03be\u2081 n\u2081) = #(b n) := rfl\n\n@[simp] lemma map_id : map (L := L) (id : Fin n \u2192 Fin n) (id : \u03be \u2192 \u03be) = Rew.id := by ext <;> simp\n\nlemma map_inj {b : Fin n\u2081 \u2192 Fin n\u2082} {e : \u03be\u2081 \u2192 \u03be\u2082} (hb : Function.Injective b) (he : Function.Injective e) :\n    Function.Injective $ map (L := L) b e\n  | #x,                    #y                    => by simpa using @hb _ _\n  | #x,                    &y                    => by simp\n  | #x,                    func f w              => by simp [Rew.func]\n  | &x,                    #y                    => by simp\n  | &x,                    &y                    => by simpa using @he _ _\n  | &x,                    func f w              => by simp [Rew.func]\n  | func f v,              #y                    => by simp [Rew.func]\n  | func f v,              &y                    => by simp [Rew.func]\n  | func (arity := k) f v, func (arity := l) g w => fun h \u21a6 by\n    have : k = l := by simp [Rew.func] at h; simp_all\n    rcases this\n    have : f = g := by simp [Rew.func] at h; simp_all\n    rcases this\n    have : v = w := by\n      have : (fun i \u21a6 (map b e) (v i)) = (fun i \u21a6 (map b e) (w i)) := by simpa [Rew.func] using h\n      funext i; exact map_inj hb he (congrFun this i)\n    simp_all\n\nend map\n\nsection rewrite\n\nvariable (f : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n)\n\n@[simp] lemma rewrite_fvar (x : \u03be\u2081) : rewrite f &x = f x := rfl\n\n@[simp] lemma rewrite_bvar (x : Fin n) : rewrite e (#x : Semiterm L \u03be\u2081 n) = #x := rfl\n\nlemma rewrite_comp_rewrite (v : \u03be\u2082 \u2192 Semiterm L \u03be\u2083 n) (w : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n) :\n    (rewrite v).comp (rewrite w) = rewrite (rewrite v \u2218 w) :=\n  by ext <;> simp[comp_app]\n\n@[simp] lemma rewrite_eq_id : (rewrite Semiterm.fvar : Rew L \u03be n \u03be n) = Rew.id := by ext <;> simp\n\nend rewrite\n\nsection rewriteMap\n\nvariable (e : \u03be\u2081 \u2192 \u03be\u2082)\n\n@[simp] lemma rewriteMap_fvar (x : \u03be\u2081) : rewriteMap e (&x : Semiterm L \u03be\u2081 n) = &(e x) := rfl\n\n@[simp] lemma rewriteMap_bvar (x : Fin n) : rewriteMap e (#x : Semiterm L \u03be\u2081 n) = #x := rfl\n\n@[simp] lemma rewriteMap_id : rewriteMap (L := L) (n := n) (id : \u03be \u2192 \u03be) = Rew.id := by ext <;> simp\n\nlemma eq_rewriteMap_of_funEqOn_fv [DecidableEq \u03be\u2081] (t : Semiterm L \u03be\u2081 n\u2081) (f g : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) (h : Function.funEqOn t.FVar? f g) :\n    Rew.rewriteMap f t = Rew.rewriteMap g t := by\n  induction t\n  case bvar => simp\n  case fvar x => simpa using h x (by simp)\n  case func f v ih =>\n    simp only [Rew.func, func.injEq, heq_eq_eq, true_and]\n    funext i\n    exact ih i (fun x hx \u21a6 h x (by simpa [Semiterm.fvar?_func] using \u27e8i, hx\u27e9))\n\nend rewriteMap\n\nsection emb\n\nvariable {o : Type v\u2082} [IsEmpty o]\n\n@[simp] lemma emb_bvar (x : Fin n) : emb (\u03be := \u03be) (#x : Semiterm L o n) = #x := rfl\n\n@[simp] lemma emb_eq_id : (emb : Rew L o n o n) = Rew.id := by\n  ext x <;> simp only [emb_bvar, id_app]; exact isEmptyElim x\n\nlemma eq_empty [h : IsEmpty \u03be\u2081] (\u03c9 : Rew L \u03be\u2081 0 \u03be\u2082 n) :\n  \u03c9 = empty := by ext x; { exact x.elim0 }; { exact h.elim' x }\n\nend emb\n\nsection bShift\n\n@[simp] lemma bShift_bvar (x : Fin n) : bShift (#x : Semiterm L \u03be n) = #(Fin.succ x) := rfl\n\n@[simp] lemma bShift_fvar (x : \u03be) : bShift (&x : Semiterm L \u03be n) = &x := rfl\n\n@[simp] lemma bShift_ne_zero (t : Semiterm L \u03be n) : bShift t \u2260 #0 := by\n  cases t <;> simp[Rew.func, Fin.succ_ne_zero]\n\n@[simp] lemma bShift_positive (t : Semiterm L \u03be n) : (bShift t).Positive := by\n  induction t <;> simp [Rew.func, *]\n\nlemma positive_iff {t : Semiterm L \u03be (n + 1)} : t.Positive \u2194 \u2203 t', t = bShift t' :=\n  \u27e8by induction t <;> simp\n      case bvar x =>\n        intro hx; exact \u27e8#(x.pred (Fin.pos_iff_ne_zero.mp hx)), by simp\u27e9\n      case fvar x => exact \u27e8&x, by simp\u27e9\n      case func k f v ih =>\n        intro h\n        have : \u2200 i, \u2203 t', v i = bShift t' := fun i => ih i (h i)\n        choose w hw using this\n        exact \u27e8func f w, by simp [Rew.func]; funext i; exact hw i\u27e9,\n   by rintro \u27e8t', rfl\u27e9; simp\u27e9\n\n@[simp] lemma leftConcat_bShift_comp_bvar :\n    (#0 :> bShift \u2218 bvar : Fin (n + 1) \u2192 Semiterm L \u03be (n + 1)) = bvar :=\n  funext (Fin.cases (by simp) (by simp))\n\n@[simp] lemma bShift_comp_fvar :\n    (bShift \u2218 fvar : \u03be \u2192 Semiterm L \u03be (n + 1)) = fvar :=\n  funext (by simp)\n\nend bShift\n\nsection bShiftAdd\n\n@[simp] lemma bShiftAdd_bvar (m) (x : Fin n) : bShiftAdd m (#x : Semiterm L \u03be n) = #(Fin.addNat x m) := rfl\n\n@[simp] lemma bShiftAdd_fvar (m) (x : \u03be) : bShiftAdd m (&x : Semiterm L \u03be n) = &x := rfl\n\nend bShiftAdd\n\nsection substs\n\nvariable {n'} (w : Fin n \u2192 Semiterm L \u03be n')\n\n@[simp] lemma substs_bvar (x : Fin n) : substs w #x = w x :=\n  by simp[substs]\n\n@[simp] lemma substs_fvar (x : \u03be) : substs w &x = &x :=\n  by simp[substs]\n\n@[simp] lemma substs_zero (w : Fin 0 \u2192 Term L \u03be) : substs w = Rew.id :=\n  by ext x <;> simp; { exact Fin.elim0 x }\n\nlemma substs_comp_substs (v : Fin l \u2192 Semiterm L \u03be k) (w : Fin k \u2192 Semiterm L \u03be n) :\n    (substs w).comp (substs v) = substs (substs w \u2218 v) :=\n  by ext <;> simp[comp_app]\n\n@[simp] lemma substs_eq_id : (substs Semiterm.bvar : Rew L \u03be n \u03be n) = Rew.id := by ext <;> simp\n\nend substs\n\nsection cast\n\nvariable {n'} (h : n = n')\n\n@[simp] lemma cast_bvar (x : Fin n) : cast h (#x : Semiterm L \u03be n) = #(Fin.cast h x) := rfl\n\n@[simp] lemma cast_fvar (x : \u03be) : cast h (&x : Semiterm L \u03be n) = &x := rfl\n\n@[simp] lemma cast_eq_id {h} : (cast h : Rew L \u03be n \u03be n) = Rew.id := by ext <;> simp\n\nend cast\n\nsection castLE\n\n@[simp] lemma castLe_bvar {n'} (h : n \u2264 n') (x : Fin n) : castLE h (#x : Semiterm L \u03be n) = #(Fin.castLE h x) := rfl\n\n@[simp] lemma castLe_fvar {n'} (h : n \u2264 n') (x : \u03be) : castLE h (&x : Semiterm L \u03be n) = &x := rfl\n\n@[simp] lemma castLe_eq_id {h} : (castLE h : Rew L \u03be n \u03be n) = Rew.id := by ext <;> simp\n\nend castLE\n\nsection toS\n\n@[simp] lemma toS_fvar {n} (x : Fin n) : toS (&x : Term L (Fin n)) = #x := rfl\n\nend toS\n\nsection embSubsts\n\nvariable {k} (w : Fin k \u2192 Semiterm L \u03be n)\n\n@[simp] lemma embSubsts_bvar (x : Fin k) : embSubsts w #x = w x :=\n  by simp[embSubsts]\n\n@[simp] lemma embSubsts_zero (w : Fin 0 \u2192 Term L \u03be) : embSubsts w = Rew.emb := by\n  ext x <;> try simp\n  \u00b7 exact Fin.elim0 x\n  \u00b7 exact Empty.elim x\n\nlemma substs_comp_embSubsts (v : Fin l \u2192 Semiterm L \u03be k) (w : Fin k \u2192 Semiterm L \u03be n) :\n    (substs w).comp (embSubsts v) = embSubsts (substs w \u2218 v) := by\n  ext x <;> simp[comp_app]\n  exact Empty.elim x\n\n@[simp] lemma embSubsts_eq_id : (embSubsts Semiterm.bvar : Rew L Empty n \u03be n) = Rew.emb := by\n  ext x <;> try simp\n  \u00b7 exact Empty.elim x\n\nend embSubsts\n\nsection \u03c8\n\nvariable (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082)\n\n@[simp] lemma q_bvar_zero : \u03c9.q #0 = #0 := by simp[Rew.q]\n\n@[simp] lemma q_bvar_succ (i : Fin n\u2081) : \u03c9.q #(i.succ) = bShift (\u03c9 #i) := by simp[Rew.q]\n\n@[simp] lemma q_fvar (x : \u03be\u2081) : \u03c9.q &x = bShift (\u03c9 &x) := by simp[Rew.q]\n\n@[simp] lemma q_comp_bShift : \u03c9.q.comp bShift = bShift.comp \u03c9 := by\n  ext x <;> simp[comp_app]\n\n@[simp] lemma q_comp_bShift_app (t : Semiterm L \u03be\u2081 n\u2081) : \u03c9.q (bShift t) = bShift (\u03c9 t) := by\n  have := ext' (\u03c9.q_comp_bShift) t; simpa only [comp_app] using this\n\n@[simp] lemma q_id : (Rew.id : Rew L \u03be n \u03be n).q = Rew.id := by ext x; { cases x using Fin.cases <;> simp }; { simp }\n\n@[simp] lemma q_eq_zero_iff : \u03c9.q t = #0 \u2194 t = #0 := by\n  cases t <;> simp [Rew.func]\n  case bvar i =>\n    cases i using Fin.cases <;> simp [Fin.succ_ne_zero]\n\n@[simp] lemma q_positive_iff : (\u03c9.q t).Positive \u2194 t.Positive := by\n  induction t <;> simp [Rew.func, *]\n  case bvar x =>\n    cases x using Fin.cases <;> simp\n\n@[simp] lemma qpow_id {k} : (Rew.id : Rew L \u03be n \u03be n).qpow k = Rew.id := by induction k <;> simp[*]\n\nlemma q_comp (\u03c9\u2082 : Rew L \u03be\u2082 n\u2082 \u03be\u2083 n\u2083) (\u03c9\u2081 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) :\n    (Rew.comp \u03c9\u2082 \u03c9\u2081).q = \u03c9\u2082.q.comp \u03c9\u2081.q := by ext x; { cases x using Fin.cases <;> simp[comp_app] }; { simp[comp_app] }\n\nlemma qpow_comp (k) (\u03c9\u2082 : Rew L \u03be\u2082 n\u2082 \u03be\u2083 n\u2083) (\u03c9\u2081 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) :\n    (Rew.comp \u03c9\u2082 \u03c9\u2081).qpow k = (\u03c9\u2082.qpow k).comp (\u03c9\u2081.qpow k) := by induction k <;> simp[*, q_comp]\n\nlemma q_bind (b : Fin n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) (e : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) :\n    (bind b e).q = bind (#0 :> bShift \u2218 b) (bShift \u2218 e) := by ext x; { cases x using Fin.cases <;> simp }; { simp }\n\nlemma q_map (b : Fin n\u2081 \u2192 Fin n\u2082) (e : \u03be\u2081 \u2192 \u03be\u2082) :\n    (map (L := L) b e).q = map (0 :> Fin.succ \u2218 b) e := by ext x; { cases x using Fin.cases <;> simp }; { simp }\n\nlemma q_rewrite (f : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n) :\n    (rewrite f).q = rewrite (bShift \u2218 f) := by ext x; { cases x using Fin.cases <;> simp[rewriteMap] }; { simp }\n\n@[simp] lemma q_rewriteMap (e : \u03be\u2081 \u2192 \u03be\u2082) :\n    (rewriteMap (L := L) (n := n) e).q = rewriteMap e := by ext x; { cases x using Fin.cases <;> simp[rewriteMap] }; { simp }\n\n@[simp] lemma q_emb {o : Type v\u2081} [e : IsEmpty o] {n} :\n    (emb (L := L) (o := o) (\u03be := \u03be\u2082) (n := n)).q = emb := by ext x; { cases x using Fin.cases <;> simp }; { exact e.elim x }\n\n@[simp] lemma qpow_emb {o : Type v\u2081} [e : IsEmpty o] {n k} :\n    (emb (L := L) (o := o) (\u03be := \u03be\u2082) (n := n)).qpow k = emb := by induction k <;> simp[*]\n\n@[simp] lemma q_cast {n n'} (h : n = n') :\n    (cast h : Rew L \u03be n \u03be n').q = cast (congrFun (congrArg HAdd.hAdd h) 1) := by\n  ext x <;> simp; cases x using Fin.cases <;> simp\n\n@[simp] lemma q_castLE {n n'} (h : n \u2264 n') :\n    (castLE h : Rew L \u03be n \u03be n').q = castLE (Nat.add_le_add_right h 1) := by\n  ext x <;> simp; cases x using Fin.cases <;> simp\n\nlemma q_toS :\n    (toS : Rew L (Fin n) 0 Empty n).q = bind ![#0] (#\u00b7.succ) := by\n  ext x <;> simp; cases x using Fin.cases <;> try simp\n  \u00b7 exact Fin.elim0 (by assumption)\n\n@[simp] lemma qpow_castLE {n n'} (h : n \u2264 n') :\n    (castLE h : Rew L \u03be n \u03be n').qpow k = castLE (Nat.add_le_add_right h k) := by\n  induction k <;> simp[*]\n\nlemma q_substs (w : Fin n \u2192 Semiterm L \u03be n') :\n    (substs w).q = substs (#0 :> bShift \u2218 w) := by ext x; { cases x using Fin.cases <;> simp }; { simp }\n\nlemma q_embSubsts (w : Fin k \u2192 Semiterm L \u03be n) :\n    (embSubsts w).q = embSubsts (#0 :> bShift \u2218 w) := by ext x; { cases x using Fin.cases <;> simp }; { simp; exact Empty.elim x }\n\nend \u03c8\n\nsection Syntactic\n\n/-\n  #0 #1 ... #(n - 1) &0 &1 ...\n   \u2193shift\n  #0 #1 ... #(n - 1) &1 &2 &3 ...\n-/\n\ndef shift : SyntacticRew L n n := map id Nat.succ\n\n/-\n  #0 #1 ... #(n - 1) #n &0 &1 ...\n   \u2193free           \u2191fix\n  #0 #1 ... #(n - 1) &0 &1 &2 ...\n -/\n\ndef free : SyntacticRew L (n + 1) n := bind (bvar <: &0) (fun m => &(Nat.succ m))\n\ndef fix : SyntacticRew L n (n + 1) := bind (fun x => #(Fin.castSucc x)) (#(Fin.last n) :>\u2099 fvar)\n\nabbrev rewrite1 (t : SyntacticSemiterm L n) : SyntacticRew L n n := bind Semiterm.bvar (t :>\u2099 fvar)\n\nsection shift\n\n@[simp] lemma shift_bvar (x : Fin n) : shift (#x : SyntacticSemiterm L n) = #x := rfl\n\n@[simp] lemma shift_fvar (x : \u2115) : shift (&x : SyntacticSemiterm L n) = &(x + 1) := rfl\n\nlemma shift_func {k} (f : L.Func k) (v : Fin k \u2192 SyntacticSemiterm L n) :\n    shift (func f v) = func f (fun i => shift (v i)) := rfl\n\nlemma shift_Injective : Function.Injective (@shift L n) :=\n  Function.LeftInverse.injective (g := map id Nat.pred)\n    (by intros \u03c6; simp[\u2190comp_app]; apply eq_id_of_eq <;> simp[comp_app])\n\nend shift\n\nsection free\n\n@[simp] lemma free_bvar_castSucc (x : Fin n) : free (#(Fin.castSucc x) : SyntacticSemiterm L (n + 1)) = #x := by simp[free]\n\n@[simp] lemma free_bvar_castSucc_zero : free (#0 : SyntacticSemiterm L (n + 1 + 1)) = #0 := free_bvar_castSucc 0\n\n@[simp] lemma free_bvar_last : free (#(Fin.last n) : SyntacticSemiterm L (n + 1)) = &0 := by simp[free]\n\n@[simp] lemma free_bvar_last_zero : free (#0 : SyntacticSemiterm L 1) = &0 := free_bvar_last\n\n@[simp] lemma free_fvar (x : \u2115) : free (&x : SyntacticSemiterm L (n + 1)) = &(x + 1) := by simp[free]\n\nend free\n\nsection fix\n\n@[simp] lemma fix_bvar (x : Fin n) : fix (#x : SyntacticSemiterm L n) = #(Fin.castSucc x) := by simp[fix]\n\n@[simp] lemma fix_fvar_zero : fix (&0 : SyntacticSemiterm L n) = #(Fin.last n) := by simp[fix]\n\n@[simp] lemma fix_fvar_succ (x : \u2115) : fix (&(x + 1) : SyntacticSemiterm L n) = &x := by simp[fix]\n\nend fix\n\n@[simp] lemma free_comp_fix : (free (L := L) (n := n)).comp fix = Rew.id := by\n  ext x <;> simp[comp_app]; { cases x <;> simp }\n\n@[simp] lemma fix_comp_free : (fix (L := L) (n := n)).comp free = Rew.id := by\n  ext x <;> simp[comp_app]; { cases x using Fin.lastCases <;> simp }\n\n@[simp] lemma bShift_free_eq_shift : (free (L := L) (n := 0)).comp bShift = shift := by\n  ext x <;> simp[comp_app]; { exact Fin.elim0 x }\n\nlemma bShift_comp_substs (v : Fin n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) :\n  bShift.comp (substs v) = substs (bShift \u2218 v) := by ext x <;> simp[comp_app]\n\nlemma shift_comp_substs (v : Fin n\u2081 \u2192 SyntacticSemiterm L n\u2082) :\n  shift.comp (substs v) = (substs (shift \u2218 v)).comp shift := by ext x <;> simp[comp_app]\n\nlemma shift_comp_substs1 (t : SyntacticSemiterm L n\u2082) :\n  shift.comp (substs ![t]) = (substs ![shift t]).comp shift := by ext x <;> simp[comp_app]\n\n@[simp] lemma rewrite_comp_emb {o : Type v\u2081} [e : IsEmpty o] (f : \u03be\u2082 \u2192 Semiterm L \u03be\u2083 n) :\n  (rewrite f).comp emb = (emb : Rew L o n \u03be\u2083 n) := by ext x <;> simp[comp_app]; { exact IsEmpty.elim e x }\n\n@[simp] lemma shift_comp_emb {o : Type v\u2081} [e : IsEmpty o] :\n  shift.comp emb = (emb : Rew L o n \u2115 n) := by ext x <;> simp[comp_app]; { exact IsEmpty.elim e x }\n\nlemma rewrite_comp_free_eq_substs (t : SyntacticTerm L) :\n    (rewrite (t :>\u2099 Semiterm.fvar)).comp free = substs ![t] := by ext x <;> simp[comp_app, Fin.eq_zero]\n\nlemma rewrite_comp_shift_eq_id (t : SyntacticTerm L) :\n    (rewrite (t :>\u2099 Semiterm.fvar)).comp shift = Rew.id := by ext x <;> simp[comp_app]\n\n@[simp] lemma substs_mbar_zero_comp_shift_eq_free :\n    (substs (L := L) ![&0]).comp shift = free := by ext x <;> simp[comp_app, Fin.eq_zero]\n\n@[simp] lemma substs_comp_bShift_eq_id (v : Fin 1 \u2192 Semiterm L \u03be 0) :\n    (substs (L := L) v).comp bShift = Rew.id := by ext x <;> simp[comp_app]; exact Fin.elim0 x\n\nlemma free_comp_substs_eq_substs_comp_shift {n'} (w : Fin n' \u2192 SyntacticSemiterm Lf (n + 1)) :\n    free.comp (substs w) = (substs (free \u2218 w)).comp shift :=\n  by ext x <;> simp[comp_app]\n\n@[simp] lemma rewriteMap_comp_rewriteMap (f : \u03be\u2081 \u2192 \u03be\u2082) (g : \u03be\u2082 \u2192 \u03be\u2083) :\n  (rewriteMap (L := L) (n := n) g).comp (rewriteMap f) = rewriteMap (g \u2218 f) := by ext x <;> simp [comp_app]\n\n@[simp] lemma fix_free_app (t : SyntacticSemiterm L (n + 1)) : fix (free t) = t := by simp[\u2190comp_app]\n\n@[simp] lemma free_fix_app (t : SyntacticSemiterm L n) : free (fix t) = t := by simp[\u2190comp_app]\n\n@[simp] lemma free_bShift_app (t : SyntacticSemiterm L 0) : free (bShift t) = shift t := by simp[\u2190comp_app]\n\n@[simp] lemma substs_bShift_app (v : Fin 1 \u2192 Semiterm L \u03be 0) : substs v (bShift t) = t := by simp[\u2190comp_app]\n\nlemma rewrite_comp_fix_eq_substs (t) :\n    ((rewrite (t :>\u2099 (&\u00b7))).comp free : SyntacticRew L 1 0) = substs ![t] := by\n  ext x <;> simp[comp_app, Fin.eq_zero]\n\nlemma bShift_eq_rewrite :\n    (Rew.bShift : SyntacticRew L 0 1) = Rew.substs ![] := by\n  ext x\n  \u00b7 exact x.elim0\n  \u00b7 simp\n\nsection \u03c8\n\nvariable (\u03c9 : SyntacticRew L n\u2081 n\u2082)\n\n@[simp] lemma q_shift : (shift (L := L) (n := n)).q = shift := by ext x; { cases x using Fin.cases <;> simp }; { simp }\n\n@[simp] lemma q_free : (free (L := L) (n := n)).q = free := by\n  ext x; { cases' x using Fin.cases with x <;> simp; { cases x using Fin.lastCases <;> simp[Fin.succ_castSucc] } }; { simp }\n\n@[simp] lemma q_fix : (fix (L := L) (n := n)).q = fix := by\n  ext x; { cases x using Fin.cases <;> simp[Fin.succ_castSucc] }; { cases x <;> simp }\n\n--@[simp] lemma qpow_fix (k : \u2115) : (fix (L := L) (n := n)).qpow k = fix := by\n\nend \u03c8\n\ndef fixitr (n : \u2115) : (m : \u2115) \u2192 SyntacticRew L n (n + m)\n  | 0     => Rew.id\n  | m + 1 => Rew.fix.comp (fixitr n m)\n\n@[simp] lemma fixitr_zero :\n    fixitr (L := L) n 0 = Rew.id := by simp [fixitr]\n\nlemma fixitr_succ (m) :\n    fixitr (L := L) n (m + 1) = Rew.fix.comp (fixitr n m) := by\n  simp [fixitr]\n\n@[simp] lemma fixitr_bvar (n m) (x : Fin n) : fixitr n m (#x : SyntacticSemiterm L n) = #(x.castAdd m) := by\n  induction m <;> simp [*, comp_app, fixitr_succ]\n  case succ m ih =>\n    simpa [ih] using comp_app fix (fixitr (L := L) n m) #x\n\nlemma fixitr_fvar (n m) (x : \u2115) :\n    fixitr n m (&x : SyntacticSemiterm L n) = if h : x < m then #(Fin.natAdd n \u27e8x, h\u27e9) else &(x - m) := by\n  induction m <;> simp [*, comp_app]\n  case succ m ih =>\n    suffices fix (fixitr n m &x) = if h : x < m + 1 then #\u27e8n + x, _\u27e9 else &(x - (m + 1)) from Eq.trans (comp_app _ _ _) this\n    simp [ih]\n    by_cases hx : x < m\n    \u00b7 simp [hx, Nat.lt_add_right 1 hx]\n    by_cases hx2 : x < m + 1\n    \u00b7 have : x = m := Nat.le_antisymm (by { simpa [Nat.lt_succ] using hx2 }) (by simpa using hx)\n      simp [this, hx, hx2]; ext; simp\n    \u00b7 simp [hx, hx2]\n      have : x - m = x - (m + 1) + 1 := by omega\n      simp [this]\n\nend Syntactic\n\n", "theoremStatement": "lemma substs_bv (t : Semiterm L \u03be n) (v : Fin n \u2192 Semiterm L \u03be m) :\n    (Rew.substs v t).bv = t.bv.biUnion (fun i \u21a6 (v i).bv) ", "theoremName": "LO.FirstOrder.Rew.substs_bv", "fileCreated": {"commit": "f9b24e7d45330d9c809d246bb25b3aeccf722ef3", "date": "2024-11-06"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/Logic/Predicate/Rew.lean", "module": "Foundation.Logic.Predicate.Rew", "jsonFile": "Foundation.Logic.Predicate.Rew.jsonl", "positionMetadata": {"lineInFile": 610, "tokenPositionInFile": 22900, "theoremPositionInFile": 140}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 6, "repositoryPremises": true, "numRepositoryPremises": 13, "numPremises": 36}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  induction t <;> simp [Rew.func, Semiterm.bv_func, Finset.biUnion_biUnion, *]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 84}}
{"srcContext": "import Foundation.IntProp.Hilbert.Basic\nimport Foundation.Vorspiel.Order\nimport Foundation.Logic.LindenbaumAlgebra\n\nnamespace LO.IntProp\n\nvariable {\u03b1 : Type u}\n\nnamespace Formula\n\ndef hVal {\u210d : Type*} [HeytingAlgebra \u210d] (v : \u03b1 \u2192 \u210d) : Formula \u03b1 \u2192 \u210d\n  | atom a => v a\n  | \u22a4      => \u22a4\n  | \u22a5      => \u22a5\n  | \u03c6 \u22cf \u03c8  => \u03c6.hVal v \u2293 \u03c8.hVal v\n  | \u03c6 \u22ce \u03c8  => \u03c6.hVal v \u2294 \u03c8.hVal v\n  | \u03c6 \u279d \u03c8  => \u03c6.hVal v \u21e8 \u03c8.hVal v\n  | \u223c\u03c6     => (\u03c6.hVal v)\u1d9c\n\nvariable {\u210d : Type*} [HeytingAlgebra \u210d] (v : \u03b1 \u2192 \u210d)\n\n@[simp] lemma hVal_atom (a : \u03b1) : (atom a).hVal v = v a := rfl\n\n@[simp] lemma hVal_verum : (\u22a4 : Formula \u03b1).hVal v = \u22a4 := rfl\n\n@[simp] lemma hVal_falsum : (\u22a5 : Formula \u03b1).hVal v = \u22a5 := rfl\n\n@[simp] lemma hVal_and (\u03c6 \u03c8 : Formula \u03b1) : (\u03c6 \u22cf \u03c8).hVal v = \u03c6.hVal v \u2293 \u03c8.hVal v := rfl\n\n@[simp] lemma hVal_or (\u03c6 \u03c8 : Formula \u03b1) : (\u03c6 \u22ce \u03c8).hVal v = \u03c6.hVal v \u2294 \u03c8.hVal v := rfl\n\n@[simp] lemma hVal_imp (\u03c6 \u03c8 : Formula \u03b1) : (\u03c6 \u279d \u03c8).hVal v = \u03c6.hVal v \u21e8 \u03c8.hVal v := rfl\n\n", "theoremStatement": "@[simp] lemma hVal_neg (\u03c6 : Formula \u03b1) : (\u223c\u03c6).hVal v = (\u03c6.hVal v)\u1d9c ", "theoremName": "LO.IntProp.Formula.hVal_neg", "fileCreated": {"commit": "33e08c2b47f966f772df9af60cbdbc5688295bbf", "date": "2024-10-15"}, "theoremCreated": {"commit": "8fbf6d7eb036d44a00dc9c0acb249190741920a3", "date": "2025-01-02"}, "file": "foundation/Foundation/IntProp/Heyting/Semantics.lean", "module": "Foundation.IntProp.Heyting.Semantics", "jsonFile": "Foundation.IntProp.Heyting.Semantics.jsonl", "positionMetadata": {"lineInFile": 34, "tokenPositionInFile": 932, "theoremPositionInFile": 6}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 5, "numPremises": 10}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "import Foundation.Vorspiel.BinaryRelations\nimport Foundation.Modal.Kripke.Completeness\nimport Foundation.Modal.Hilbert.Geach\n\n\nnamespace LO.Modal\n\nnamespace Kripke\n\nabbrev GeachConfluentFrameClass (t : GeachConfluent.Taple) : FrameClass := { F | (GeachConfluent t) F.Rel }\n\ninstance GeachConfluentFrameClass.nonempty : (GeachConfluentFrameClass t).Nonempty := by\n  use reflexivePointFrame.toFrame;\n  intros x _ _ _; use x;\n  constructor <;> { apply Rel.iterate.true_any; tauto; }\n\n\nabbrev MultiGeachConfluentFrameClass (ts : List GeachConfluent.Taple) : FrameClass := { F | (MultiGeachConfluent ts) F.Rel }\n\nnamespace MultiGeachConfluentFrameClass\n\n@[simp] lemma def_nil : MultiGeachConfluentFrameClass [] = AllFrameClass := by rfl;\n\nlemma def_one (t : GeachConfluent.Taple) : MultiGeachConfluentFrameClass [t] = GeachConfluentFrameClass t := by rfl;\n\nlemma def_cons {t : GeachConfluent.Taple} {ts : List GeachConfluent.Taple} (ts_nil : ts \u2260 [])\n  : MultiGeachConfluentFrameClass (t :: ts) = GeachConfluentFrameClass t \u2229 MultiGeachConfluentFrameClass ts := by\n  apply Set.eq_of_subset_of_subset;\n  . rintro F hF;\n    apply MultiGeachConfluent.iff_cons ts_nil |>.mp;\n    exact hF;\n  . rintro F \u27e8hF\u2081, hF\u2082\u27e9;\n    apply MultiGeachConfluent.iff_cons ts_nil |>.mpr;\n    constructor;\n    . apply hF\u2081;\n    . apply hF\u2082;\n\n@[simp]\ninstance nonempty : (MultiGeachConfluentFrameClass ts).Nonempty := by\n  use \u27e8PUnit,  \u03bb _ _ => True\u27e9;\n  induction ts using List.induction_with_singleton with\n  | hnil => simp only [def_nil, Set.mem_univ];\n  | hsingle t =>\n    simp [GeachConfluentFrameClass];\n    intros x _ _ _; use x;\n    constructor <;> { apply Rel.iterate.true_any; tauto; }\n  | hcons t ts ts_nil ih =>\n    simp [MultiGeachConfluentFrameClass.def_cons ts_nil];\n    constructor;\n    . intro x _ _ _; use x;\n      constructor <;> { apply Rel.iterate.true_any; tauto; }\n    . exact ih;\n\nend MultiGeachConfluentFrameClass\n\n\nabbrev FrameClass.IsGeach (C : FrameClass) (ts : List GeachConfluent.Taple) := C = MultiGeachConfluentFrameClass ts\n\n\nsection\n\n/-- Frame class of `Hilbert.KT` -/\nabbrev ReflexiveFrameClass : FrameClass := { F | Reflexive F.Rel }\nlemma ReflexiveFrameClass.is_geach : ReflexiveFrameClass.IsGeach [\u27e80, 0, 1, 0\u27e9] := by\n  simp only [FrameClass.IsGeach, ReflexiveFrameClass, GeachConfluent.reflexive_def,\n    MultiGeachConfluentFrameClass.def_one, GeachConfluentFrameClass];\n\n/-- Frame class of `Hilbert.KD` -/\nabbrev SerialFrameClass : FrameClass := { F | Serial F.Rel }\nlemma SerialFrameClass.is_geach : SerialFrameClass.IsGeach [\u27e80, 0, 1, 1\u27e9] := by\n  simp only [FrameClass.IsGeach, SerialFrameClass, GeachConfluent.serial_def,\n    MultiGeachConfluentFrameClass.def_one, GeachConfluentFrameClass];\n\n/-- Frame class of `Hilbert.KB` -/\nabbrev SymmetricFrameClass : FrameClass := { F | Symmetric F.Rel }\nlemma SymmetricFrameClass.is_geach : SymmetricFrameClass.IsGeach [\u27e80, 1, 0, 1\u27e9] := by\n  simp only [FrameClass.IsGeach, SymmetricFrameClass, GeachConfluent.symmetric_def,\n    MultiGeachConfluentFrameClass.def_one, GeachConfluentFrameClass];\n\n/-- Frame class of `Hilbert.K4` -/\nabbrev TransitiveFrameClass : FrameClass := { F | Transitive F.Rel }\nlemma TransitiveFrameClass.is_geach : TransitiveFrameClass.IsGeach ([\u27e80, 2, 1, 0\u27e9]) := by\n  simp only [FrameClass.IsGeach, TransitiveFrameClass, GeachConfluent.transitive_def,\n    MultiGeachConfluentFrameClass.def_one, GeachConfluentFrameClass];\n\n/-- Frame class of `Hilbert.K5` -/\nabbrev EuclideanFrameClass : FrameClass := { F | Euclidean F.Rel }\nlemma EuclideanFrameClass.is_geach : EuclideanFrameClass.IsGeach ([\u27e81, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, EuclideanFrameClass, GeachConfluent.euclidean_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.S5` -/\nabbrev ReflexiveEuclideanFrameClass : FrameClass := { F | Reflexive F.Rel \u2227 Euclidean F.Rel }\nlemma ReflexiveEuclideanFrameClass.is_geach : ReflexiveEuclideanFrameClass.IsGeach ([\u27e80, 0, 1, 0\u27e9, \u27e81, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, ReflexiveEuclideanFrameClass, GeachConfluent.reflexive_def,\n    GeachConfluent.euclidean_def, MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.KTB` -/\nabbrev ReflexiveSymmetricFrameClass : FrameClass := { F | Reflexive F \u2227 Symmetric F }\nlemma ReflexiveSymmetricFrameClass.is_geach : ReflexiveSymmetricFrameClass.IsGeach ([\u27e80, 0, 1, 0\u27e9, \u27e80, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, ReflexiveSymmetricFrameClass, GeachConfluent.reflexive_def,\n    GeachConfluent.symmetric_def, MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.S4` -/\nabbrev ReflexiveTransitiveFrameClass : FrameClass := { F | Reflexive F \u2227 Transitive F }\nlemma ReflexiveTransitiveFrameClass.is_geach : ReflexiveTransitiveFrameClass.IsGeach ([\u27e80, 0, 1, 0\u27e9, \u27e80, 2, 1, 0\u27e9]) := by\n  simp only [FrameClass.IsGeach, ReflexiveTransitiveFrameClass, GeachConfluent.reflexive_def,\n    GeachConfluent.transitive_def, MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.S4Dot2` -/\nabbrev ReflexiveTransitiveConfluentFrameClass : FrameClass := { F | Reflexive F \u2227 Transitive F \u2227 Confluent F }\nlemma ReflexiveTransitiveConfluentFrameClass.is_geach : ReflexiveTransitiveConfluentFrameClass.IsGeach ([\u27e80, 0, 1, 0\u27e9, \u27e80, 2, 1, 0\u27e9, \u27e81, 1, 1, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, ReflexiveTransitiveConfluentFrameClass,\n    GeachConfluent.reflexive_def, GeachConfluent.transitive_def, GeachConfluent.confluent_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.KT4B` -/\nabbrev ReflexiveTransitiveSymmetricFrameClass : FrameClass := { F | Reflexive F \u2227 Transitive F \u2227 Symmetric F }\nlemma ReflexiveTransitiveSymmetricFrameClass.is_geach : ReflexiveTransitiveSymmetricFrameClass.IsGeach ([\u27e80, 0, 1, 0\u27e9, \u27e80, 2, 1, 0\u27e9, \u27e80, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, ReflexiveTransitiveSymmetricFrameClass,\n    GeachConfluent.reflexive_def, GeachConfluent.transitive_def, GeachConfluent.symmetric_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.KD45` -/\nabbrev SerialTransitiveEuclideanFrameClass : FrameClass := { F | Serial F \u2227 Transitive F \u2227 Euclidean F }\nlemma SerialTransitiveEuclideanFrameClass.is_geach : SerialTransitiveEuclideanFrameClass.IsGeach ([\u27e80, 0, 1, 1\u27e9, \u27e80, 2, 1, 0\u27e9, \u27e81, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, SerialTransitiveEuclideanFrameClass,\n    GeachConfluent.serial_def, GeachConfluent.transitive_def, GeachConfluent.euclidean_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.K45` -/\nabbrev TransitiveEuclideanFrameClass : FrameClass := { F | Transitive F \u2227 Euclidean F }\n", "theoremStatement": "lemma TransitiveEuclideanFrameClass.is_geach : TransitiveEuclideanFrameClass.IsGeach ([\u27e80, 2, 1, 0\u27e9, \u27e81, 1, 0, 1\u27e9]) ", "theoremName": "LO.Modal.Kripke.TransitiveEuclideanFrameClass.is_geach", "fileCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "theoremCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "file": "foundation/Foundation/Modal/Kripke/Geach/Basic.lean", "module": "Foundation.Modal.Kripke.Geach.Basic", "jsonFile": "Foundation.Modal.Kripke.Geach.Basic.jsonl", "positionMetadata": {"lineInFile": 133, "tokenPositionInFile": 6702, "theoremPositionInFile": 29}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 12, "numPremises": 30}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp only [FrameClass.IsGeach, TransitiveEuclideanFrameClass,\n    GeachConfluent.transitive_def, GeachConfluent.euclidean_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 191}}
{"srcContext": "import Foundation.Modal.Formula\n\nnamespace LO.Modal\n\nvariable {\u03b1 : Type u}\n\ninductive NNFormula (\u03b1 : Type u) : Type u where\n  | atom   : \u03b1 \u2192 NNFormula \u03b1\n  | natom  : \u03b1 \u2192 NNFormula \u03b1\n  | falsum : NNFormula \u03b1\n  | verum  : NNFormula \u03b1\n  | or     : NNFormula \u03b1 \u2192 NNFormula \u03b1 \u2192 NNFormula \u03b1\n  | and    : NNFormula \u03b1 \u2192 NNFormula \u03b1 \u2192 NNFormula \u03b1\n  | box    : NNFormula \u03b1 \u2192 NNFormula \u03b1\n  | dia    : NNFormula \u03b1 \u2192 NNFormula \u03b1\n  deriving DecidableEq\n\nnamespace NNFormula\n\nvariable {\u03c6 \u03c8 \u03c7 : NNFormula \u03b1}\n\ndef neg : NNFormula \u03b1 \u2192 NNFormula \u03b1\n  | atom a  => natom a\n  | natom a => atom a\n  | falsum  => verum\n  | verum   => falsum\n  | or \u03c6 \u03c8  => and (neg \u03c6) (neg \u03c8)\n  | and \u03c6 \u03c8 => or (neg \u03c6) (neg \u03c8)\n  | box \u03c6   => dia (neg \u03c6)\n  | dia \u03c6   => box (neg \u03c6)\n\ndef imp (\u03c6 \u03c8 : NNFormula \u03b1) : NNFormula \u03b1 := or (neg \u03c6) \u03c8\n\ninstance : BasicModalLogicalConnective (NNFormula \u03b1) where\n  tilde := neg\n  arrow := imp\n  wedge := and\n  vee := or\n  top := verum\n  bot := falsum\n  box := box\n  dia := dia\n\nlemma or_eq : or \u03c6 \u03c8 = \u03c6 \u22ce \u03c8 := rfl\n\nlemma and_eq : and \u03c6 \u03c8 = \u03c6 \u22cf \u03c8 := rfl\n\nlemma imp_eq : imp \u03c6 \u03c8 = \u03c6 \u279d \u03c8 := rfl\n\nlemma box_eq : box \u03c6 = \u25a1\u03c6 := rfl\n\nlemma dia_eq : dia \u03c6 = \u25c7\u03c6 := rfl\n\n@[simp] lemma imp_eq' : \u03c6 \u279d \u03c8 = \u223c\u03c6 \u22ce \u03c8 := rfl\n\n@[simp] lemma iff_eq : \u03c6 \u2b64 \u03c8 = (\u03c6 \u279d \u03c8) \u22cf (\u03c8 \u279d \u03c6) := rfl\n\nlemma falsum_eq : (falsum : NNFormula \u03b1) = \u22a5 := rfl\n\nlemma verum_eq : (verum : NNFormula \u03b1) = \u22a4 := rfl\n\n@[simp] lemma and_inj (\u03c6\u2081 \u03c8\u2081 \u03c6\u2082 \u03c8\u2082 : Formula \u03b1) : \u03c6\u2081 \u22cf \u03c6\u2082 = \u03c8\u2081 \u22cf \u03c8\u2082 \u2194 \u03c6\u2081 = \u03c8\u2081 \u2227 \u03c6\u2082 = \u03c8\u2082 := by simp[Wedge.wedge]\n\n@[simp] lemma or_inj (\u03c6\u2081 \u03c8\u2081 \u03c6\u2082 \u03c8\u2082 : Formula \u03b1) : \u03c6\u2081 \u22ce \u03c6\u2082 = \u03c8\u2081 \u22ce \u03c8\u2082 \u2194 \u03c6\u2081 = \u03c8\u2081 \u2227 \u03c6\u2082 = \u03c8\u2082 := by simp[Vee.vee]\n\n@[simp] lemma imp_inj (\u03c6\u2081 \u03c8\u2081 \u03c6\u2082 \u03c8\u2082 : Formula \u03b1) : \u03c6\u2081 \u279d \u03c6\u2082 = \u03c8\u2081 \u279d \u03c8\u2082 \u2194 \u03c6\u2081 = \u03c8\u2081 \u2227 \u03c6\u2082 = \u03c8\u2082 := by simp[Arrow.arrow]\n\n@[simp] lemma neg_inj (\u03c6 \u03c8 : Formula \u03b1) : \u223c\u03c6 = \u223c\u03c8 \u2194 \u03c6 = \u03c8 := by simp [NegAbbrev.neg];\n\nlemma neg_eq : neg \u03c6 = \u223c\u03c6 := rfl\n\n@[simp] lemma neg_atom (a : \u03b1) : \u223catom a = natom a := by rfl\n\n@[simp] lemma neg_natom (a : \u03b1) : \u223cnatom a = atom a := by rfl\n\nlemma negneg : \u223c\u223c\u03c6 = \u03c6 := by\n  induction \u03c6 with\n  | and \u03c6 \u03c8 ih\u03c6 ih\u03c8 =>\n    simp only [\u2190neg_eq, neg, and.injEq];\n    exact \u27e8ih\u03c6, ih\u03c8\u27e9;\n  | or \u03c6 \u03c8 ih\u03c6 ih\u03c8 =>\n    simp only [\u2190neg_eq, neg, or.injEq];\n    exact \u27e8ih\u03c6, ih\u03c8\u27e9;\n  | box \u03c6 ih\u03c6 =>\n    simp only [\u2190neg_eq, neg, box.injEq];\n    exact ih\u03c6;\n  | dia \u03c6 ih\u03c6 =>\n    simp only [\u2190neg_eq, neg, dia.injEq];\n    exact ih\u03c6;\n  | _ => tauto;\n\ninstance : ModalDeMorgan (NNFormula \u03b1) where\n  verum := by tauto;\n  falsum := by tauto;\n  and := by tauto;\n  or := by tauto;\n  box := by tauto;\n  dia := by tauto;\n  neg := \u03bb _ => negneg\n  imply := by tauto;\n\nsection toString\n\nvariable [ToString \u03b1]\ndef toStr : NNFormula \u03b1 \u2192 String\n  | atom a  => s!\"+{a}\"\n  | natom a => s!\"-{a}\"\n  | falsum  => \"\u22a5\"\n  | verum   => \"\u22a4\"\n  | or \u03c6 \u03c8  => s!\"({\u03c6.toStr} \u2228 {\u03c8.toStr})\"\n  | and \u03c6 \u03c8 => s!\"({\u03c6.toStr} \u2227 {\u03c8.toStr})\"\n  | box \u03c6   => s!\"\u25a1{\u03c6.toStr}\"\n  | dia \u03c6   => s!\"\u25c7{\u03c6.toStr}\"\ninstance : Repr (NNFormula \u03b1) := \u27e8fun t _ => toStr t\u27e9\n\nend toString\n\n\nsection toFormula\n\ndef toFormula : NNFormula \u03b1 \u2192 Formula \u03b1\n  | atom a  => Formula.atom a\n  | natom a => \u223cFormula.atom a\n  | \u22a5       => \u22a5\n  | \u22a4       => \u22a4\n  | \u03c6 \u22ce \u03c8   => \u03c6.toFormula \u22ce \u03c8.toFormula\n  | \u03c6 \u22cf \u03c8   => \u03c6.toFormula \u22cf \u03c8.toFormula\n  | \u25a1\u03c6      => \u25a1(\u03c6.toFormula)\n  | \u25c7\u03c6      => \u25c7(\u03c6.toFormula)\ninstance : Coe (NNFormula \u03b1) (Formula \u03b1) := \u27e8toFormula\u27e9\n\n@[simp] lemma toFormula_atom (a : \u03b1) : toFormula  (.atom a) = Formula.atom a := rfl\n\n@[simp] lemma toFormula_natom (a : \u03b1) : toFormula (.natom a) = \u223cFormula.atom a := rfl\n\n@[simp] lemma toFormula_falsum : toFormula \u22a5 = (\u22a5 : Formula \u03b1) := rfl\n\n@[simp] lemma toFormula_verum : toFormula \u22a4 = (\u22a4 : Formula \u03b1) := rfl\n\nend toFormula\n\n\nsection\n\n@[elab_as_elim]\ndef cases'\n  {C : NNFormula \u03b1 \u2192 Sort v}\n  (hAtom   : \u2200 a, C (atom a))\n  (hNatom  : \u2200 a, C (natom a))\n  (hFalsum : C \u22a5)\n  (hVerum  : C \u22a4)\n  (hOr     : \u2200 \u03c6 \u03c8, C (\u03c6 \u22ce \u03c8))\n  (hAnd    : \u2200 \u03c6 \u03c8, C (\u03c6 \u22cf \u03c8))\n  (hBox    : \u2200 \u03c6, C (\u25a1\u03c6))\n  (hDia    : \u2200 \u03c6, C (\u25c7\u03c6))\n  : \u2200 \u03c6, C \u03c6\n  | atom a  => hAtom a\n  | natom a => hNatom a\n  | \u22a5  => hFalsum\n  | \u22a4   => hVerum\n  | \u03c6 \u22ce \u03c8 => hOr \u03c6 \u03c8\n  | \u03c6 \u22cf \u03c8 => hAnd \u03c6 \u03c8\n  | \u25a1\u03c6 => hBox \u03c6\n  | \u25c7\u03c6 => hDia \u03c6\n\n@[elab_as_elim]\ndef rec'\n  {C : NNFormula \u03b1 \u2192 Sort v}\n  (hAtom   : \u2200 a, C (atom a))\n  (hNatom  : \u2200 a, C (natom a))\n  (hFalsum : C \u22a5)\n  (hVerum  : C \u22a4)\n  (hOr     : \u2200 \u03c6 \u03c8, C \u03c6 \u2192 C \u03c8 \u2192 C (\u03c6 \u22ce \u03c8))\n  (hAnd    : \u2200 \u03c6 \u03c8, C \u03c6 \u2192 C \u03c8 \u2192 C (\u03c6 \u22cf \u03c8))\n  (hBox    : \u2200 \u03c6, C \u03c6 \u2192 C (\u25a1\u03c6))\n  (hDia    : \u2200 \u03c6, C \u03c6 \u2192 C (\u25c7\u03c6))\n  : \u2200 \u03c6, C \u03c6\n  | atom a  => hAtom a\n  | natom a => hNatom a\n  | falsum  => hFalsum\n  | verum   => hVerum\n  | or \u03c6 \u03c8 => hOr \u03c6 \u03c8 (rec' hAtom hNatom hFalsum hVerum hOr hAnd hBox hDia \u03c6) (rec' hAtom hNatom hFalsum hVerum hOr hAnd hBox hDia \u03c8)\n  | and \u03c6 \u03c8 => hAnd \u03c6 \u03c8 (rec' hAtom hNatom hFalsum hVerum hOr hAnd hBox hDia \u03c6) (rec' hAtom hNatom hFalsum hVerum hOr hAnd hBox hDia \u03c8)\n  | box \u03c6 => hBox \u03c6 (rec' hAtom hNatom hFalsum hVerum hOr hAnd hBox hDia \u03c6)\n  | dia \u03c6 => hDia \u03c6 (rec' hAtom hNatom hFalsum hVerum hOr hAnd hBox hDia \u03c6)\n\nend\n\n\nsection Decidable\n\nend Decidable\n\n\nsection Encodable\n\nopen Encodable\n\nvariable [Encodable \u03b1]\n\ndef toNat : NNFormula \u03b1 \u2192 Nat\n  | \u22a5       => (Nat.pair 0 0) + 1\n  | \u22a4       => (Nat.pair 1 0) + 1\n  | atom a  => (Nat.pair 2 <| encode a) + 1\n  | natom a => (Nat.pair 3 <| encode a) + 1\n  | \u03c6 \u22ce \u03c8   => (Nat.pair 4 <| Nat.pair \u03c6.toNat \u03c8.toNat) + 1\n  | \u03c6 \u22cf \u03c8   => (Nat.pair 5 <| Nat.pair \u03c6.toNat \u03c8.toNat) + 1\n  | \u25a1\u03c6      => (Nat.pair 6 <| \u03c6.toNat) + 1\n  | \u25c7\u03c6      => (Nat.pair 7 <| \u03c6.toNat) + 1\n\ndef ofNat : Nat \u2192 Option (NNFormula \u03b1)\n  | 0 => none\n  | e + 1 =>\n    let idx := e.unpair.1\n    let c := e.unpair.2\n    match idx with\n    | 0 => some \u22a5\n    | 1 => some \u22a4\n    | 2 => (decode c).map NNFormula.atom\n    | 3 => (decode c).map NNFormula.natom\n    | 4 =>\n      have : c.unpair.1 < e + 1 := Nat.lt_succ.mpr $ le_trans (Nat.unpair_left_le _) $ Nat.unpair_right_le _\n      have : c.unpair.2 < e + 1 := Nat.lt_succ.mpr $ le_trans (Nat.unpair_right_le _) $ Nat.unpair_right_le _\n      do\n        let \u03c6 \u2190 ofNat c.unpair.1\n        let \u03c8 \u2190 ofNat c.unpair.2\n        return \u03c6 \u22ce \u03c8\n    | 5 =>\n      have : c.unpair.1 < e + 1 := Nat.lt_succ.mpr $ le_trans (Nat.unpair_left_le _) $ Nat.unpair_right_le _\n      have : c.unpair.2 < e + 1 := Nat.lt_succ.mpr $ le_trans (Nat.unpair_right_le _) $ Nat.unpair_right_le _\n      do\n        let \u03c6 \u2190 ofNat c.unpair.1\n        let \u03c8 \u2190 ofNat c.unpair.2\n        return \u03c6 \u22cf \u03c8\n    | 6 =>\n      have : c < e + 1 := Nat.lt_succ.mpr $ Nat.unpair_right_le _\n      do\n        let \u03c6 \u2190 ofNat c;\n        return \u25a1\u03c6\n    | 7 =>\n      have : c < e + 1 := Nat.lt_succ.mpr $ Nat.unpair_right_le _\n      do\n        let \u03c6 \u2190 ofNat c;\n        return \u25c7\u03c6\n    | _ => none\n\ninstance : Encodable (NNFormula \u03b1) where\n  encode := toNat\n  decode := ofNat\n  encodek := by\n    intro \u03c6;\n    induction \u03c6 using rec' <;> simp [toNat, ofNat, encodek, *]\n\nend Encodable\n\n\nend NNFormula\n\n\nnamespace Formula\n\ndef toNNFormula : Formula \u03b1 \u2192 NNFormula \u03b1\n  | atom a  => NNFormula.atom a\n  | \u22a5       => NNFormula.falsum\n  | \u03c6 \u279d \u03c8   => \u03c6.toNNFormula.neg \u22ce \u03c8.toNNFormula\n  | \u25a1\u03c6      => \u25a1\u03c6.toNNFormula\ninstance : Coe (Formula \u03b1) (NNFormula \u03b1) := \u27e8toNNFormula\u27e9\n\n", "theoremStatement": "@[simp] lemma toNNFormula_atom (a : \u03b1) : toNNFormula (atom a) = .atom a ", "theoremName": "LO.Modal.Formula.toNNFormula_atom", "fileCreated": {"commit": "1f10809ea0f0e98679f13cd2f7f5b706b01878a8", "date": "2024-11-20"}, "theoremCreated": {"commit": "54324e6e009f0d0a288897312d3feb1c0165ad19", "date": "2025-01-24"}, "file": "foundation/Foundation/Modal/NNFormula.lean", "module": "Foundation.Modal.NNFormula", "jsonFile": "Foundation.Modal.NNFormula.jsonl", "positionMetadata": {"lineInFile": 269, "tokenPositionInFile": 7009, "theoremPositionInFile": 22}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 4, "numPremises": 6}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "import Foundation.IntFO.Translation\n\n/-!\n#Algebraic Proofs of Cut Elimination\n\nMain reference: Jeremy Avigad, Algebraic proofs of cut elimination, The Journal of Logic and Algebraic Programming, Volume 49, Issues 1\u20132, 2001, Pages 15-30\n -/\n\nnamespace LO.FirstOrder\n\nvariable {L : Language.{u}}\n\nnamespace Derivation\n\ninductive IsCutFree : {\u0393 : Sequent L} \u2192 \u22a2\u1d40 \u0393 \u2192 Prop\n| axL (\u0393) {k} (r : L.Rel k) (v)                 : IsCutFree (axL \u0393 r v)\n| verum (\u0393)                                     : IsCutFree (verum \u0393)\n| or {\u0393 \u03c6 \u03c8} {d : \u22a2\u1d40 \u03c6 :: \u03c8 :: \u0393}               : IsCutFree d \u2192 IsCutFree d.or\n| and {\u0393 \u03c6 \u03c8} {d\u03c6 : \u22a2\u1d40 \u03c6 :: \u0393} {d\u03c8 : \u22a2\u1d40 \u03c8 :: \u0393} : IsCutFree d\u03c6 \u2192 IsCutFree d\u03c8 \u2192 IsCutFree (d\u03c6.and d\u03c8)\n| all {\u0393 \u03c6} {d : \u22a2\u1d40 Rewriting.free \u03c6 :: \u0393\u207a}     : IsCutFree d \u2192 IsCutFree d.all\n| ex {\u0393 \u03c6} (t) {d : \u22a2\u1d40 \u03c6/[t] :: \u0393}              : IsCutFree d \u2192 IsCutFree d.ex\n| wk {\u0394 \u0393} {d : \u22a2\u1d40 \u0394} (ss : \u0394 \u2286 \u0393)              : IsCutFree d \u2192 IsCutFree (d.wk ss)\n\nattribute [simp] IsCutFree.axL IsCutFree.verum\n\nvariable {\u0393 \u0394 : Sequent L}\n\n@[simp] lemma isCutFree_or_iff {d : \u22a2\u1d40 \u03c6 :: \u03c8 :: \u0393} :\n    IsCutFree d.or \u2194 IsCutFree d := \u27e8by rintro \u27e8\u27e9; assumption, .or\u27e9\n\n@[simp] lemma isCutFree_and_iff {d\u03c6 : \u22a2\u1d40 \u03c6 :: \u0393} {d\u03c8 : \u22a2\u1d40 \u03c8 :: \u0393} :\n    IsCutFree (d\u03c6.and d\u03c8) \u2194 IsCutFree d\u03c6 \u2227 IsCutFree d\u03c8 :=\n  \u27e8by rintro \u27e8\u27e9; constructor <;> assumption, by intro \u27e8h\u03c6, h\u03c8\u27e9; exact h\u03c6.and h\u03c8\u27e9\n\n@[simp] lemma isCutFree_all_iff {d : \u22a2\u1d40 Rewriting.free \u03c6 :: \u0393\u207a} :\n    IsCutFree d.all \u2194 IsCutFree d := \u27e8by rintro \u27e8\u27e9; assumption, .all\u27e9\n\n@[simp] lemma isCutFree_ex_iff {d : \u22a2\u1d40 \u03c6/[t] :: \u0393} :\n    IsCutFree d.ex \u2194 IsCutFree d := \u27e8by rintro \u27e8\u27e9; assumption, .ex t\u27e9\n\n", "theoremStatement": "@[simp] lemma isCutFree_wk_iff {d : \u22a2\u1d40 \u0394} {ss : \u0394 \u2286 \u0393} :\n    IsCutFree (d.wk ss) \u2194 IsCutFree d ", "theoremName": "LO.FirstOrder.Derivation.isCutFree_wk_iff", "fileCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/FirstOrder/Hauptsatz.lean", "module": "Foundation.FirstOrder.Hauptsatz", "jsonFile": "Foundation.FirstOrder.Hauptsatz.jsonl", "positionMetadata": {"lineInFile": 41, "tokenPositionInFile": 1605, "theoremPositionInFile": 4}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 8, "repositoryPremises": true, "numRepositoryPremises": 42, "numPremises": 70}, "proofMetadata": {"hasProof": true, "proof": ":= \u27e8by rintro \u27e8\u27e9; assumption, .wk _\u27e9", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 36}}
{"srcContext": "import Foundation.Modal.Kripke.Geach.Systems\n\nnamespace LO.Modal.Hilbert\n\nopen System\nopen Modal.Kripke\nopen Formula\nopen Formula.Kripke\n\n", "theoremStatement": "lemma KB_weakerThan_KDB : (Hilbert.KB \u03b1) \u2264\u209b (Hilbert.KDB \u03b1) ", "theoremName": "LO.Modal.Hilbert.KB_weakerThan_KDB", "fileCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "theoremCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "file": "foundation/Foundation/Modal/Hilbert/WeakerThan/KB_KDB.lean", "module": "Foundation.Modal.Hilbert.WeakerThan.KB_KDB", "jsonFile": "Foundation.Modal.Hilbert.WeakerThan.KB_KDB.jsonl", "positionMetadata": {"lineInFile": 10, "tokenPositionInFile": 138, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 19, "numPremises": 43}, "proofMetadata": {"hasProof": true, "proof": ":= normal_weakerThan_of_subset $ by intro; aesop;", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 49}}
{"srcContext": "import Foundation.Modal.Kripke.Geach.Systems\n\nnamespace LO.Modal.Hilbert\n\nopen System\nopen Modal.Kripke\nopen Formula\nopen Formula.Kripke\n\n", "theoremStatement": "lemma K4_weakerThan_KD4 : (Hilbert.K4 \u03b1) \u2264\u209b (Hilbert.KD4 \u03b1) ", "theoremName": "LO.Modal.Hilbert.K4_weakerThan_KD4", "fileCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "theoremCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "file": "foundation/Foundation/Modal/Hilbert/WeakerThan/K4_KD4.lean", "module": "Foundation.Modal.Hilbert.WeakerThan.K4_KD4", "jsonFile": "Foundation.Modal.Hilbert.WeakerThan.K4_KD4.jsonl", "positionMetadata": {"lineInFile": 10, "tokenPositionInFile": 138, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 19, "numPremises": 43}, "proofMetadata": {"hasProof": true, "proof": ":= normal_weakerThan_of_subset $ by intro; aesop;", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 49}}
{"srcContext": "import Foundation.IntFO.Translation\n\n/-!\n#Algebraic Proofs of Cut Elimination\n\nMain reference: Jeremy Avigad, Algebraic proofs of cut elimination, The Journal of Logic and Algebraic Programming, Volume 49, Issues 1\u20132, 2001, Pages 15-30\n -/\n\nnamespace LO.FirstOrder\n\nvariable {L : Language.{u}}\n\nnamespace Derivation\n\ninductive IsCutFree : {\u0393 : Sequent L} \u2192 \u22a2\u1d40 \u0393 \u2192 Prop\n| axL (\u0393) {k} (r : L.Rel k) (v)                 : IsCutFree (axL \u0393 r v)\n| verum (\u0393)                                     : IsCutFree (verum \u0393)\n| or {\u0393 \u03c6 \u03c8} {d : \u22a2\u1d40 \u03c6 :: \u03c8 :: \u0393}               : IsCutFree d \u2192 IsCutFree d.or\n| and {\u0393 \u03c6 \u03c8} {d\u03c6 : \u22a2\u1d40 \u03c6 :: \u0393} {d\u03c8 : \u22a2\u1d40 \u03c8 :: \u0393} : IsCutFree d\u03c6 \u2192 IsCutFree d\u03c8 \u2192 IsCutFree (d\u03c6.and d\u03c8)\n| all {\u0393 \u03c6} {d : \u22a2\u1d40 Rewriting.free \u03c6 :: \u0393\u207a}     : IsCutFree d \u2192 IsCutFree d.all\n| ex {\u0393 \u03c6} (t) {d : \u22a2\u1d40 \u03c6/[t] :: \u0393}              : IsCutFree d \u2192 IsCutFree d.ex\n| wk {\u0394 \u0393} {d : \u22a2\u1d40 \u0394} (ss : \u0394 \u2286 \u0393)              : IsCutFree d \u2192 IsCutFree (d.wk ss)\n\nattribute [simp] IsCutFree.axL IsCutFree.verum\n\nvariable {\u0393 \u0394 : Sequent L}\n\n@[simp] lemma isCutFree_or_iff {d : \u22a2\u1d40 \u03c6 :: \u03c8 :: \u0393} :\n    IsCutFree d.or \u2194 IsCutFree d := \u27e8by rintro \u27e8\u27e9; assumption, .or\u27e9\n\n@[simp] lemma isCutFree_and_iff {d\u03c6 : \u22a2\u1d40 \u03c6 :: \u0393} {d\u03c8 : \u22a2\u1d40 \u03c8 :: \u0393} :\n    IsCutFree (d\u03c6.and d\u03c8) \u2194 IsCutFree d\u03c6 \u2227 IsCutFree d\u03c8 :=\n  \u27e8by rintro \u27e8\u27e9; constructor <;> assumption, by intro \u27e8h\u03c6, h\u03c8\u27e9; exact h\u03c6.and h\u03c8\u27e9\n\n", "theoremStatement": "@[simp] lemma isCutFree_all_iff {d : \u22a2\u1d40 Rewriting.free \u03c6 :: \u0393\u207a} :\n    IsCutFree d.all \u2194 IsCutFree d ", "theoremName": "LO.FirstOrder.Derivation.isCutFree_all_iff", "fileCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/FirstOrder/Hauptsatz.lean", "module": "Foundation.FirstOrder.Hauptsatz", "jsonFile": "Foundation.FirstOrder.Hauptsatz.jsonl", "positionMetadata": {"lineInFile": 35, "tokenPositionInFile": 1344, "theoremPositionInFile": 2}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 8, "repositoryPremises": true, "numRepositoryPremises": 48, "numPremises": 77}, "proofMetadata": {"hasProof": true, "proof": ":= \u27e8by rintro \u27e8\u27e9; assumption, .all\u27e9", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 35}}
{"srcContext": "import Foundation.Logic.Predicate.Term\nimport Foundation.Logic.Predicate.Quantifier\n\n/-!\n# Rewriting System\n\nterm/formula morphisms such as Rewritings, substitutions, and embeddings are handled by the structure `LO.FirstOrder.Rew`.\n- `LO.FirstOrder.Rew.rewrite f` is a Rewriting of the free variables occurring in the term by `f : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n`.\n- `LO.FirstOrder.Rew.substs v` is a substitution of the bounded variables occurring in the term by `v : Fin n \u2192 Semiterm L \u03be n'`.\n- `LO.FirstOrder.Rew.bShift` is a transformation of the bounded variables occurring in the term by `#x \u21a6 #(Fin.succ x)`.\n- `LO.FirstOrder.Rew.shift` is a transformation of the free variables occurring in the term by `&x \u21a6 &(x + 1)`.\n- `LO.FirstOrder.Rew.emb` is a embedding of the term with no free variables.\n\nRewritings `LO.FirstOrder.Rew` is naturally converted to formula Rewritings by `LO.FirstOrder.Rew.hom`.\n\n-/\n\nnamespace LO\n\nnamespace FirstOrder\n\nstructure Rew (L : Language) (\u03be\u2081 : Type*) (n\u2081 : \u2115) (\u03be\u2082 : Type*) (n\u2082 : \u2115) where\n  toFun : Semiterm L \u03be\u2081 n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082\n  func' : \u2200 {k} (f : L.Func k) (v : Fin k \u2192 Semiterm L \u03be\u2081 n\u2081), toFun (Semiterm.func f v) = Semiterm.func f (fun i => toFun (v i))\n\nabbrev SyntacticRew (L : Language) (n\u2081 n\u2082 : \u2115) := Rew L \u2115 n\u2081 \u2115 n\u2082\n\nnamespace Rew\n\nopen Semiterm\nvariable {L L' L\u2081 L\u2082 L\u2083 : Language} {\u03be \u03be' \u03be\u2081 \u03be\u2082 \u03be\u2083 : Type*} {n n\u2081 n\u2082 n\u2083 : \u2115}\nvariable (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082)\n\ninstance : FunLike (Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) (Semiterm L \u03be\u2081 n\u2081) (Semiterm L \u03be\u2082 n\u2082) where\n  coe := fun f => f.toFun\n  coe_injective' := fun f g h => by rcases f; rcases g; simpa using h\n\ninstance : CoeFun (Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) (fun _ => Semiterm L \u03be\u2081 n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) := DFunLike.hasCoeToFun\n\nprotected lemma func {k} (f : L.Func k) (v : Fin k \u2192 Semiterm L \u03be\u2081 n\u2081) :\n    \u03c9 (func f v) = func f (fun i => \u03c9 (v i)) := \u03c9.func' f v\n\nlemma func'' {k} (f : L.Func k) (v : Fin k \u2192 Semiterm L \u03be\u2081 n\u2081) :\n    \u03c9 (func f v) = func f (\u03c9 \u2218 v) := \u03c9.func' f v\n\n@[simp] lemma func0 (f : L.Func 0) (v : Fin 0 \u2192 Semiterm L \u03be\u2081 n\u2081) :\n    \u03c9 (func f v) = func f ![] := by simp[Rew.func, Matrix.empty_eq]\n\n@[simp] lemma func1 (f : L.Func 1) (t : Semiterm L \u03be\u2081 n\u2081) :\n    \u03c9 (func f ![t]) = func f ![\u03c9 t] := by simp[Matrix.constant_eq_singleton, Rew.func]\n\n@[simp] lemma func2 (f : L.Func 2) (t\u2081 t\u2082 : Semiterm L \u03be\u2081 n\u2081) :\n    \u03c9 (func f ![t\u2081, t\u2082]) = func f ![\u03c9 t\u2081, \u03c9 t\u2082] := by\n  simp only [Rew.func, func.injEq, heq_eq_eq, true_and]\n  funext i\n  induction i using Fin.induction <;> simp\n\n@[simp] lemma func3 (f : L.Func 3) (t\u2081 t\u2082 t\u2083 : Semiterm L \u03be\u2081 n\u2081) :\n    \u03c9 (func f ![t\u2081, t\u2082, t\u2083]) = func f ![\u03c9 t\u2081, \u03c9 t\u2082, \u03c9 t\u2083] := by\n  simp only [Rew.func, func.injEq, heq_eq_eq, true_and]\n  funext i; induction' i using Fin.induction with i\n  \u00b7 simp\n  \u00b7 induction' i using Fin.induction with i <;> simp\n\n@[ext] lemma ext (\u03c9\u2081 \u03c9\u2082 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) (hb : \u2200 x, \u03c9\u2081 #x = \u03c9\u2082 #x) (hf : \u2200 x, \u03c9\u2081 &x = \u03c9\u2082 &x) : \u03c9\u2081 = \u03c9\u2082 := by\n  apply DFunLike.ext \u03c9\u2081 \u03c9\u2082; intro t\n  induction t <;> simp[*, \u03c9\u2081.func, \u03c9\u2082.func]\n\nlemma ext' {\u03c9\u2081 \u03c9\u2082 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082} (h : \u03c9\u2081 = \u03c9\u2082) (t) : \u03c9\u2081 t = \u03c9\u2082 t := by simp[h]\n\nprotected def id : Rew L \u03be n \u03be n where\n  toFun := id\n  func' := fun _ _ => rfl\n\n@[simp] lemma id_app (t : Semiterm L \u03be n) : Rew.id t = t := rfl\n\nprotected def comp (\u03c9\u2082 : Rew L \u03be\u2082 n\u2082 \u03be\u2083 n\u2083) (\u03c9\u2081 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) : Rew L \u03be\u2081 n\u2081 \u03be\u2083 n\u2083 where\n  toFun := fun t => \u03c9\u2082 (\u03c9\u2081 t)\n  func' := fun f v => by simp[func'']; rfl\n\nlemma comp_app (\u03c9\u2082 : Rew L \u03be\u2082 n\u2082 \u03be\u2083 n\u2083) (\u03c9\u2081 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) (t : Semiterm L \u03be\u2081 n\u2081) :\n    (\u03c9\u2082.comp \u03c9\u2081) t = \u03c9\u2082 (\u03c9\u2081 t) := rfl\n\n@[simp] lemma id_comp (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) : Rew.id.comp \u03c9 = \u03c9 := by ext <;> simp[comp_app]\n\n@[simp] lemma comp_id (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) : \u03c9.comp Rew.id = \u03c9 := by ext <;> simp[comp_app]\n\ndef bindAux (b : Fin n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) (e : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) : Semiterm L \u03be\u2081 n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082\n  | (#x)       => b x\n  | (&x)       => e x\n  | (func f v) => func f (fun i => bindAux b e (v i))\n\ndef bind (b : Fin n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) (e : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082 where\n  toFun := bindAux b e\n  func' := fun _ _ => rfl\n\ndef rewrite (f : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n) : Rew L \u03be\u2081 n \u03be\u2082 n := bind Semiterm.bvar f\n\ndef rewriteMap (e : \u03be\u2081 \u2192 \u03be\u2082) : Rew L \u03be\u2081 n \u03be\u2082 n := rewrite (fun m => &(e m))\n\ndef map (b : Fin n\u2081 \u2192 Fin n\u2082) (e : \u03be\u2081 \u2192 \u03be\u2082) : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082 :=\n  bind (fun n => #(b n)) (fun m => &(e m))\n\ndef substs {n'} (v : Fin n \u2192 Semiterm L \u03be n') : Rew L \u03be n \u03be n' :=\n  bind v fvar\n\ndef emb {o : Type v\u2081} [h : IsEmpty o] {\u03be : Type v\u2082} {n} : Rew L o n \u03be n := map id h.elim\n\nabbrev embs {o : Type v\u2081} [IsEmpty o] {n} : Rew L o n \u2115 n := emb\n\ndef empty {o : Type v\u2081} [h : IsEmpty o] {\u03be : Type v\u2082} {n} : Rew L o 0 \u03be n := map Fin.elim0 h.elim\n\ndef bShift : Rew L \u03be n \u03be (n + 1) :=\n  map Fin.succ id\n\ndef bShiftAdd (m : \u2115) : Rew L \u03be n \u03be (n + m) :=\n  map (Fin.addNat \u00b7 m) id\n\ndef cast {n n' : \u2115} (h : n = n') : Rew L \u03be n \u03be n' :=\n  map (Fin.cast h) id\n\ndef castLE {n n' : \u2115} (h : n \u2264 n') : Rew L \u03be n \u03be n' :=\n  map (Fin.castLE h) id\n\ndef toS : Rew L (Fin n) 0 Empty n := Rew.bind ![] (#\u00b7)\n\ndef toF : Rew L Empty n (Fin n) 0 := Rew.bind (&\u00b7) Empty.elim\n\ndef embSubsts (v : Fin k \u2192 Semiterm L \u03be n) : Rew L Empty k \u03be n := Rew.bind v Empty.elim\n\nprotected def q (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) : Rew L \u03be\u2081 (n\u2081 + 1) \u03be\u2082 (n\u2082 + 1) :=\n  bind (#0 :> bShift \u2218 \u03c9 \u2218 bvar) (bShift \u2218 \u03c9 \u2218 fvar)\n\nlemma eq_id_of_eq {\u03c9 : Rew L \u03be n \u03be n} (hb : \u2200 x, \u03c9 #x = #x) (he : \u2200 x, \u03c9 &x = &x) (t) : \u03c9 t = t := by\n  have : \u03c9 = Rew.id := by ext <;> simp[*]\n  simp[this]\n\ndef qpow (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) : (k : \u2115) \u2192 Rew L \u03be\u2081 (n\u2081 + k) \u03be\u2082 (n\u2082 + k)\n  | 0     => \u03c9\n  | k + 1 => (\u03c9.qpow k).q\n\n@[simp] lemma qpow_zero (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) : qpow \u03c9 0 = \u03c9 := rfl\n\n@[simp] lemma qpow_succ (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) (k : \u2115) : qpow \u03c9 (k + 1) = (\u03c9.qpow k).q := rfl\n\nsection bind\n\nvariable (b : Fin n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) (e : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082)\n\n@[simp] lemma bind_fvar (m : \u03be\u2081) : bind b e (&m : Semiterm L \u03be\u2081 n\u2081) = e m := rfl\n\n@[simp] lemma bind_bvar (n : Fin n\u2081) : bind b e (#n : Semiterm L \u03be\u2081 n\u2081) = b n := rfl\n\nlemma eq_bind (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) : \u03c9 = bind (\u03c9 \u2218 bvar) (\u03c9 \u2218 fvar) := by\n  ext t; induction t ;simp [Rew.func'']; simp [*]\n\n@[simp] lemma bind_eq_id_of_zero (f : Fin 0 \u2192 Semiterm L \u03be\u2082 0) : bind f fvar = Rew.id := by\n  ext x <;> simp only [bind_bvar, bind_fvar, id_app]; exact Fin.elim0 x\n\nend bind\n\nsection map\n\nvariable (b : Fin n\u2081 \u2192 Fin n\u2082) (e : \u03be\u2081 \u2192 \u03be\u2082)\n\n@[simp] lemma map_fvar (m : \u03be\u2081) : map b e (&m : Semiterm L \u03be\u2081 n\u2081) = &(e m) := rfl\n\n@[simp] lemma map_bvar (n : Fin n\u2081) : map b e (#n : Semiterm L \u03be\u2081 n\u2081) = #(b n) := rfl\n\n@[simp] lemma map_id : map (L := L) (id : Fin n \u2192 Fin n) (id : \u03be \u2192 \u03be) = Rew.id := by ext <;> simp\n\nlemma map_inj {b : Fin n\u2081 \u2192 Fin n\u2082} {e : \u03be\u2081 \u2192 \u03be\u2082} (hb : Function.Injective b) (he : Function.Injective e) :\n    Function.Injective $ map (L := L) b e\n  | #x,                    #y                    => by simpa using @hb _ _\n  | #x,                    &y                    => by simp\n  | #x,                    func f w              => by simp [Rew.func]\n  | &x,                    #y                    => by simp\n  | &x,                    &y                    => by simpa using @he _ _\n  | &x,                    func f w              => by simp [Rew.func]\n  | func f v,              #y                    => by simp [Rew.func]\n  | func f v,              &y                    => by simp [Rew.func]\n  | func (arity := k) f v, func (arity := l) g w => fun h \u21a6 by\n    have : k = l := by simp [Rew.func] at h; simp_all\n    rcases this\n    have : f = g := by simp [Rew.func] at h; simp_all\n    rcases this\n    have : v = w := by\n      have : (fun i \u21a6 (map b e) (v i)) = (fun i \u21a6 (map b e) (w i)) := by simpa [Rew.func] using h\n      funext i; exact map_inj hb he (congrFun this i)\n    simp_all\n\nend map\n\nsection rewrite\n\nvariable (f : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n)\n\n@[simp] lemma rewrite_fvar (x : \u03be\u2081) : rewrite f &x = f x := rfl\n\n@[simp] lemma rewrite_bvar (x : Fin n) : rewrite e (#x : Semiterm L \u03be\u2081 n) = #x := rfl\n\nlemma rewrite_comp_rewrite (v : \u03be\u2082 \u2192 Semiterm L \u03be\u2083 n) (w : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n) :\n    (rewrite v).comp (rewrite w) = rewrite (rewrite v \u2218 w) :=\n  by ext <;> simp[comp_app]\n\n@[simp] lemma rewrite_eq_id : (rewrite Semiterm.fvar : Rew L \u03be n \u03be n) = Rew.id := by ext <;> simp\n\nend rewrite\n\nsection rewriteMap\n\nvariable (e : \u03be\u2081 \u2192 \u03be\u2082)\n\n@[simp] lemma rewriteMap_fvar (x : \u03be\u2081) : rewriteMap e (&x : Semiterm L \u03be\u2081 n) = &(e x) := rfl\n\n@[simp] lemma rewriteMap_bvar (x : Fin n) : rewriteMap e (#x : Semiterm L \u03be\u2081 n) = #x := rfl\n\n@[simp] lemma rewriteMap_id : rewriteMap (L := L) (n := n) (id : \u03be \u2192 \u03be) = Rew.id := by ext <;> simp\n\nlemma eq_rewriteMap_of_funEqOn_fv [DecidableEq \u03be\u2081] (t : Semiterm L \u03be\u2081 n\u2081) (f g : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) (h : Function.funEqOn t.FVar? f g) :\n    Rew.rewriteMap f t = Rew.rewriteMap g t := by\n  induction t\n  case bvar => simp\n  case fvar x => simpa using h x (by simp)\n  case func f v ih =>\n    simp only [Rew.func, func.injEq, heq_eq_eq, true_and]\n    funext i\n    exact ih i (fun x hx \u21a6 h x (by simpa [Semiterm.fvar?_func] using \u27e8i, hx\u27e9))\n\nend rewriteMap\n\nsection emb\n\nvariable {o : Type v\u2082} [IsEmpty o]\n\n@[simp] lemma emb_bvar (x : Fin n) : emb (\u03be := \u03be) (#x : Semiterm L o n) = #x := rfl\n\n@[simp] lemma emb_eq_id : (emb : Rew L o n o n) = Rew.id := by\n  ext x <;> simp only [emb_bvar, id_app]; exact isEmptyElim x\n\nlemma eq_empty [h : IsEmpty \u03be\u2081] (\u03c9 : Rew L \u03be\u2081 0 \u03be\u2082 n) :\n  \u03c9 = empty := by ext x; { exact x.elim0 }; { exact h.elim' x }\n\nend emb\n\nsection bShift\n\n@[simp] lemma bShift_bvar (x : Fin n) : bShift (#x : Semiterm L \u03be n) = #(Fin.succ x) := rfl\n\n@[simp] lemma bShift_fvar (x : \u03be) : bShift (&x : Semiterm L \u03be n) = &x := rfl\n\n@[simp] lemma bShift_ne_zero (t : Semiterm L \u03be n) : bShift t \u2260 #0 := by\n  cases t <;> simp[Rew.func, Fin.succ_ne_zero]\n\n@[simp] lemma bShift_positive (t : Semiterm L \u03be n) : (bShift t).Positive := by\n  induction t <;> simp [Rew.func, *]\n\nlemma positive_iff {t : Semiterm L \u03be (n + 1)} : t.Positive \u2194 \u2203 t', t = bShift t' :=\n  \u27e8by induction t <;> simp\n      case bvar x =>\n        intro hx; exact \u27e8#(x.pred (Fin.pos_iff_ne_zero.mp hx)), by simp\u27e9\n      case fvar x => exact \u27e8&x, by simp\u27e9\n      case func k f v ih =>\n        intro h\n        have : \u2200 i, \u2203 t', v i = bShift t' := fun i => ih i (h i)\n        choose w hw using this\n        exact \u27e8func f w, by simp [Rew.func]; funext i; exact hw i\u27e9,\n   by rintro \u27e8t', rfl\u27e9; simp\u27e9\n\n@[simp] lemma leftConcat_bShift_comp_bvar :\n    (#0 :> bShift \u2218 bvar : Fin (n + 1) \u2192 Semiterm L \u03be (n + 1)) = bvar :=\n  funext (Fin.cases (by simp) (by simp))\n\n@[simp] lemma bShift_comp_fvar :\n    (bShift \u2218 fvar : \u03be \u2192 Semiterm L \u03be (n + 1)) = fvar :=\n  funext (by simp)\n\nend bShift\n\nsection bShiftAdd\n\n@[simp] lemma bShiftAdd_bvar (m) (x : Fin n) : bShiftAdd m (#x : Semiterm L \u03be n) = #(Fin.addNat x m) := rfl\n\n@[simp] lemma bShiftAdd_fvar (m) (x : \u03be) : bShiftAdd m (&x : Semiterm L \u03be n) = &x := rfl\n\nend bShiftAdd\n\nsection substs\n\nvariable {n'} (w : Fin n \u2192 Semiterm L \u03be n')\n\n@[simp] lemma substs_bvar (x : Fin n) : substs w #x = w x :=\n  by simp[substs]\n\n@[simp] lemma substs_fvar (x : \u03be) : substs w &x = &x :=\n  by simp[substs]\n\n@[simp] lemma substs_zero (w : Fin 0 \u2192 Term L \u03be) : substs w = Rew.id :=\n  by ext x <;> simp; { exact Fin.elim0 x }\n\nlemma substs_comp_substs (v : Fin l \u2192 Semiterm L \u03be k) (w : Fin k \u2192 Semiterm L \u03be n) :\n    (substs w).comp (substs v) = substs (substs w \u2218 v) :=\n  by ext <;> simp[comp_app]\n\n@[simp] lemma substs_eq_id : (substs Semiterm.bvar : Rew L \u03be n \u03be n) = Rew.id := by ext <;> simp\n\nend substs\n\nsection cast\n\nvariable {n'} (h : n = n')\n\n@[simp] lemma cast_bvar (x : Fin n) : cast h (#x : Semiterm L \u03be n) = #(Fin.cast h x) := rfl\n\n@[simp] lemma cast_fvar (x : \u03be) : cast h (&x : Semiterm L \u03be n) = &x := rfl\n\n@[simp] lemma cast_eq_id {h} : (cast h : Rew L \u03be n \u03be n) = Rew.id := by ext <;> simp\n\nend cast\n\nsection castLE\n\n@[simp] lemma castLe_bvar {n'} (h : n \u2264 n') (x : Fin n) : castLE h (#x : Semiterm L \u03be n) = #(Fin.castLE h x) := rfl\n\n@[simp] lemma castLe_fvar {n'} (h : n \u2264 n') (x : \u03be) : castLE h (&x : Semiterm L \u03be n) = &x := rfl\n\n@[simp] lemma castLe_eq_id {h} : (castLE h : Rew L \u03be n \u03be n) = Rew.id := by ext <;> simp\n\nend castLE\n\nsection toS\n\n@[simp] lemma toS_fvar {n} (x : Fin n) : toS (&x : Term L (Fin n)) = #x := rfl\n\nend toS\n\nsection embSubsts\n\nvariable {k} (w : Fin k \u2192 Semiterm L \u03be n)\n\n@[simp] lemma embSubsts_bvar (x : Fin k) : embSubsts w #x = w x :=\n  by simp[embSubsts]\n\n@[simp] lemma embSubsts_zero (w : Fin 0 \u2192 Term L \u03be) : embSubsts w = Rew.emb := by\n  ext x <;> try simp\n  \u00b7 exact Fin.elim0 x\n  \u00b7 exact Empty.elim x\n\nlemma substs_comp_embSubsts (v : Fin l \u2192 Semiterm L \u03be k) (w : Fin k \u2192 Semiterm L \u03be n) :\n    (substs w).comp (embSubsts v) = embSubsts (substs w \u2218 v) := by\n  ext x <;> simp[comp_app]\n  exact Empty.elim x\n\n@[simp] lemma embSubsts_eq_id : (embSubsts Semiterm.bvar : Rew L Empty n \u03be n) = Rew.emb := by\n  ext x <;> try simp\n  \u00b7 exact Empty.elim x\n\nend embSubsts\n\nsection \u03c8\n\nvariable (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082)\n\n@[simp] lemma q_bvar_zero : \u03c9.q #0 = #0 := by simp[Rew.q]\n\n@[simp] lemma q_bvar_succ (i : Fin n\u2081) : \u03c9.q #(i.succ) = bShift (\u03c9 #i) := by simp[Rew.q]\n\n@[simp] lemma q_fvar (x : \u03be\u2081) : \u03c9.q &x = bShift (\u03c9 &x) := by simp[Rew.q]\n\n@[simp] lemma q_comp_bShift : \u03c9.q.comp bShift = bShift.comp \u03c9 := by\n  ext x <;> simp[comp_app]\n\n@[simp] lemma q_comp_bShift_app (t : Semiterm L \u03be\u2081 n\u2081) : \u03c9.q (bShift t) = bShift (\u03c9 t) := by\n  have := ext' (\u03c9.q_comp_bShift) t; simpa only [comp_app] using this\n\n@[simp] lemma q_id : (Rew.id : Rew L \u03be n \u03be n).q = Rew.id := by ext x; { cases x using Fin.cases <;> simp }; { simp }\n\n@[simp] lemma q_eq_zero_iff : \u03c9.q t = #0 \u2194 t = #0 := by\n  cases t <;> simp [Rew.func]\n  case bvar i =>\n    cases i using Fin.cases <;> simp [Fin.succ_ne_zero]\n\n@[simp] lemma q_positive_iff : (\u03c9.q t).Positive \u2194 t.Positive := by\n  induction t <;> simp [Rew.func, *]\n  case bvar x =>\n    cases x using Fin.cases <;> simp\n\n@[simp] lemma qpow_id {k} : (Rew.id : Rew L \u03be n \u03be n).qpow k = Rew.id := by induction k <;> simp[*]\n\nlemma q_comp (\u03c9\u2082 : Rew L \u03be\u2082 n\u2082 \u03be\u2083 n\u2083) (\u03c9\u2081 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) :\n    (Rew.comp \u03c9\u2082 \u03c9\u2081).q = \u03c9\u2082.q.comp \u03c9\u2081.q := by ext x; { cases x using Fin.cases <;> simp[comp_app] }; { simp[comp_app] }\n\nlemma qpow_comp (k) (\u03c9\u2082 : Rew L \u03be\u2082 n\u2082 \u03be\u2083 n\u2083) (\u03c9\u2081 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) :\n    (Rew.comp \u03c9\u2082 \u03c9\u2081).qpow k = (\u03c9\u2082.qpow k).comp (\u03c9\u2081.qpow k) := by induction k <;> simp[*, q_comp]\n\nlemma q_bind (b : Fin n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) (e : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) :\n    (bind b e).q = bind (#0 :> bShift \u2218 b) (bShift \u2218 e) := by ext x; { cases x using Fin.cases <;> simp }; { simp }\n\nlemma q_map (b : Fin n\u2081 \u2192 Fin n\u2082) (e : \u03be\u2081 \u2192 \u03be\u2082) :\n    (map (L := L) b e).q = map (0 :> Fin.succ \u2218 b) e := by ext x; { cases x using Fin.cases <;> simp }; { simp }\n\nlemma q_rewrite (f : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n) :\n    (rewrite f).q = rewrite (bShift \u2218 f) := by ext x; { cases x using Fin.cases <;> simp[rewriteMap] }; { simp }\n\n@[simp] lemma q_rewriteMap (e : \u03be\u2081 \u2192 \u03be\u2082) :\n    (rewriteMap (L := L) (n := n) e).q = rewriteMap e := by ext x; { cases x using Fin.cases <;> simp[rewriteMap] }; { simp }\n\n@[simp] lemma q_emb {o : Type v\u2081} [e : IsEmpty o] {n} :\n    (emb (L := L) (o := o) (\u03be := \u03be\u2082) (n := n)).q = emb := by ext x; { cases x using Fin.cases <;> simp }; { exact e.elim x }\n\n@[simp] lemma qpow_emb {o : Type v\u2081} [e : IsEmpty o] {n k} :\n    (emb (L := L) (o := o) (\u03be := \u03be\u2082) (n := n)).qpow k = emb := by induction k <;> simp[*]\n\n@[simp] lemma q_cast {n n'} (h : n = n') :\n    (cast h : Rew L \u03be n \u03be n').q = cast (congrFun (congrArg HAdd.hAdd h) 1) := by\n  ext x <;> simp; cases x using Fin.cases <;> simp\n\n@[simp] lemma q_castLE {n n'} (h : n \u2264 n') :\n    (castLE h : Rew L \u03be n \u03be n').q = castLE (Nat.add_le_add_right h 1) := by\n  ext x <;> simp; cases x using Fin.cases <;> simp\n\nlemma q_toS :\n    (toS : Rew L (Fin n) 0 Empty n).q = bind ![#0] (#\u00b7.succ) := by\n  ext x <;> simp; cases x using Fin.cases <;> try simp\n  \u00b7 exact Fin.elim0 (by assumption)\n\n@[simp] lemma qpow_castLE {n n'} (h : n \u2264 n') :\n    (castLE h : Rew L \u03be n \u03be n').qpow k = castLE (Nat.add_le_add_right h k) := by\n  induction k <;> simp[*]\n\nlemma q_substs (w : Fin n \u2192 Semiterm L \u03be n') :\n    (substs w).q = substs (#0 :> bShift \u2218 w) := by ext x; { cases x using Fin.cases <;> simp }; { simp }\n\nlemma q_embSubsts (w : Fin k \u2192 Semiterm L \u03be n) :\n    (embSubsts w).q = embSubsts (#0 :> bShift \u2218 w) := by ext x; { cases x using Fin.cases <;> simp }; { simp; exact Empty.elim x }\n\nend \u03c8\n\nsection Syntactic\n\n/-\n  #0 #1 ... #(n - 1) &0 &1 ...\n   \u2193shift\n  #0 #1 ... #(n - 1) &1 &2 &3 ...\n-/\n\ndef shift : SyntacticRew L n n := map id Nat.succ\n\n/-\n  #0 #1 ... #(n - 1) #n &0 &1 ...\n   \u2193free           \u2191fix\n  #0 #1 ... #(n - 1) &0 &1 &2 ...\n -/\n\ndef free : SyntacticRew L (n + 1) n := bind (bvar <: &0) (fun m => &(Nat.succ m))\n\ndef fix : SyntacticRew L n (n + 1) := bind (fun x => #(Fin.castSucc x)) (#(Fin.last n) :>\u2099 fvar)\n\nabbrev rewrite1 (t : SyntacticSemiterm L n) : SyntacticRew L n n := bind Semiterm.bvar (t :>\u2099 fvar)\n\nsection shift\n\n@[simp] lemma shift_bvar (x : Fin n) : shift (#x : SyntacticSemiterm L n) = #x := rfl\n\n@[simp] lemma shift_fvar (x : \u2115) : shift (&x : SyntacticSemiterm L n) = &(x + 1) := rfl\n\nlemma shift_func {k} (f : L.Func k) (v : Fin k \u2192 SyntacticSemiterm L n) :\n    shift (func f v) = func f (fun i => shift (v i)) := rfl\n\nlemma shift_Injective : Function.Injective (@shift L n) :=\n  Function.LeftInverse.injective (g := map id Nat.pred)\n    (by intros \u03c6; simp[\u2190comp_app]; apply eq_id_of_eq <;> simp[comp_app])\n\nend shift\n\nsection free\n\n@[simp] lemma free_bvar_castSucc (x : Fin n) : free (#(Fin.castSucc x) : SyntacticSemiterm L (n + 1)) = #x := by simp[free]\n\n@[simp] lemma free_bvar_castSucc_zero : free (#0 : SyntacticSemiterm L (n + 1 + 1)) = #0 := free_bvar_castSucc 0\n\n@[simp] lemma free_bvar_last : free (#(Fin.last n) : SyntacticSemiterm L (n + 1)) = &0 := by simp[free]\n\n@[simp] lemma free_bvar_last_zero : free (#0 : SyntacticSemiterm L 1) = &0 := free_bvar_last\n\n@[simp] lemma free_fvar (x : \u2115) : free (&x : SyntacticSemiterm L (n + 1)) = &(x + 1) := by simp[free]\n\nend free\n\nsection fix\n\n@[simp] lemma fix_bvar (x : Fin n) : fix (#x : SyntacticSemiterm L n) = #(Fin.castSucc x) := by simp[fix]\n\n@[simp] lemma fix_fvar_zero : fix (&0 : SyntacticSemiterm L n) = #(Fin.last n) := by simp[fix]\n\n@[simp] lemma fix_fvar_succ (x : \u2115) : fix (&(x + 1) : SyntacticSemiterm L n) = &x := by simp[fix]\n\nend fix\n\n@[simp] lemma free_comp_fix : (free (L := L) (n := n)).comp fix = Rew.id := by\n  ext x <;> simp[comp_app]; { cases x <;> simp }\n\n@[simp] lemma fix_comp_free : (fix (L := L) (n := n)).comp free = Rew.id := by\n  ext x <;> simp[comp_app]; { cases x using Fin.lastCases <;> simp }\n\n@[simp] lemma bShift_free_eq_shift : (free (L := L) (n := 0)).comp bShift = shift := by\n  ext x <;> simp[comp_app]; { exact Fin.elim0 x }\n\nlemma bShift_comp_substs (v : Fin n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) :\n  bShift.comp (substs v) = substs (bShift \u2218 v) := by ext x <;> simp[comp_app]\n\nlemma shift_comp_substs (v : Fin n\u2081 \u2192 SyntacticSemiterm L n\u2082) :\n  shift.comp (substs v) = (substs (shift \u2218 v)).comp shift := by ext x <;> simp[comp_app]\n\nlemma shift_comp_substs1 (t : SyntacticSemiterm L n\u2082) :\n  shift.comp (substs ![t]) = (substs ![shift t]).comp shift := by ext x <;> simp[comp_app]\n\n@[simp] lemma rewrite_comp_emb {o : Type v\u2081} [e : IsEmpty o] (f : \u03be\u2082 \u2192 Semiterm L \u03be\u2083 n) :\n  (rewrite f).comp emb = (emb : Rew L o n \u03be\u2083 n) := by ext x <;> simp[comp_app]; { exact IsEmpty.elim e x }\n\n@[simp] lemma shift_comp_emb {o : Type v\u2081} [e : IsEmpty o] :\n  shift.comp emb = (emb : Rew L o n \u2115 n) := by ext x <;> simp[comp_app]; { exact IsEmpty.elim e x }\n\nlemma rewrite_comp_free_eq_substs (t : SyntacticTerm L) :\n    (rewrite (t :>\u2099 Semiterm.fvar)).comp free = substs ![t] := by ext x <;> simp[comp_app, Fin.eq_zero]\n\nlemma rewrite_comp_shift_eq_id (t : SyntacticTerm L) :\n    (rewrite (t :>\u2099 Semiterm.fvar)).comp shift = Rew.id := by ext x <;> simp[comp_app]\n\n@[simp] lemma substs_mbar_zero_comp_shift_eq_free :\n    (substs (L := L) ![&0]).comp shift = free := by ext x <;> simp[comp_app, Fin.eq_zero]\n\n@[simp] lemma substs_comp_bShift_eq_id (v : Fin 1 \u2192 Semiterm L \u03be 0) :\n    (substs (L := L) v).comp bShift = Rew.id := by ext x <;> simp[comp_app]; exact Fin.elim0 x\n\nlemma free_comp_substs_eq_substs_comp_shift {n'} (w : Fin n' \u2192 SyntacticSemiterm Lf (n + 1)) :\n    free.comp (substs w) = (substs (free \u2218 w)).comp shift :=\n  by ext x <;> simp[comp_app]\n\n@[simp] lemma rewriteMap_comp_rewriteMap (f : \u03be\u2081 \u2192 \u03be\u2082) (g : \u03be\u2082 \u2192 \u03be\u2083) :\n  (rewriteMap (L := L) (n := n) g).comp (rewriteMap f) = rewriteMap (g \u2218 f) := by ext x <;> simp [comp_app]\n\n@[simp] lemma fix_free_app (t : SyntacticSemiterm L (n + 1)) : fix (free t) = t := by simp[\u2190comp_app]\n\n@[simp] lemma free_fix_app (t : SyntacticSemiterm L n) : free (fix t) = t := by simp[\u2190comp_app]\n\n@[simp] lemma free_bShift_app (t : SyntacticSemiterm L 0) : free (bShift t) = shift t := by simp[\u2190comp_app]\n\n@[simp] lemma substs_bShift_app (v : Fin 1 \u2192 Semiterm L \u03be 0) : substs v (bShift t) = t := by simp[\u2190comp_app]\n\nlemma rewrite_comp_fix_eq_substs (t) :\n    ((rewrite (t :>\u2099 (&\u00b7))).comp free : SyntacticRew L 1 0) = substs ![t] := by\n  ext x <;> simp[comp_app, Fin.eq_zero]\n\nlemma bShift_eq_rewrite :\n    (Rew.bShift : SyntacticRew L 0 1) = Rew.substs ![] := by\n  ext x\n  \u00b7 exact x.elim0\n  \u00b7 simp\n\nsection \u03c8\n\nvariable (\u03c9 : SyntacticRew L n\u2081 n\u2082)\n\n@[simp] lemma q_shift : (shift (L := L) (n := n)).q = shift := by ext x; { cases x using Fin.cases <;> simp }; { simp }\n\n@[simp] lemma q_free : (free (L := L) (n := n)).q = free := by\n  ext x; { cases' x using Fin.cases with x <;> simp; { cases x using Fin.lastCases <;> simp[Fin.succ_castSucc] } }; { simp }\n\n@[simp] lemma q_fix : (fix (L := L) (n := n)).q = fix := by\n  ext x; { cases x using Fin.cases <;> simp[Fin.succ_castSucc] }; { cases x <;> simp }\n\n--@[simp] lemma qpow_fix (k : \u2115) : (fix (L := L) (n := n)).qpow k = fix := by\n\nend \u03c8\n\ndef fixitr (n : \u2115) : (m : \u2115) \u2192 SyntacticRew L n (n + m)\n  | 0     => Rew.id\n  | m + 1 => Rew.fix.comp (fixitr n m)\n\n@[simp] lemma fixitr_zero :\n    fixitr (L := L) n 0 = Rew.id := by simp [fixitr]\n\nlemma fixitr_succ (m) :\n    fixitr (L := L) n (m + 1) = Rew.fix.comp (fixitr n m) := by\n  simp [fixitr]\n\n@[simp] lemma fixitr_bvar (n m) (x : Fin n) : fixitr n m (#x : SyntacticSemiterm L n) = #(x.castAdd m) := by\n  induction m <;> simp [*, comp_app, fixitr_succ]\n  case succ m ih =>\n    simpa [ih] using comp_app fix (fixitr (L := L) n m) #x\n\nlemma fixitr_fvar (n m) (x : \u2115) :\n    fixitr n m (&x : SyntacticSemiterm L n) = if h : x < m then #(Fin.natAdd n \u27e8x, h\u27e9) else &(x - m) := by\n  induction m <;> simp [*, comp_app]\n  case succ m ih =>\n    suffices fix (fixitr n m &x) = if h : x < m + 1 then #\u27e8n + x, _\u27e9 else &(x - (m + 1)) from Eq.trans (comp_app _ _ _) this\n    simp [ih]\n    by_cases hx : x < m\n    \u00b7 simp [hx, Nat.lt_add_right 1 hx]\n    by_cases hx2 : x < m + 1\n    \u00b7 have : x = m := Nat.le_antisymm (by { simpa [Nat.lt_succ] using hx2 }) (by simpa using hx)\n      simp [this, hx, hx2]; ext; simp\n    \u00b7 simp [hx, hx2]\n      have : x - m = x - (m + 1) + 1 := by omega\n      simp [this]\n\nend Syntactic\n\nlemma substs_bv (t : Semiterm L \u03be n) (v : Fin n \u2192 Semiterm L \u03be m) :\n    (Rew.substs v t).bv = t.bv.biUnion (fun i \u21a6 (v i).bv) := by\n  induction t <;> simp [Rew.func, Semiterm.bv_func, Finset.biUnion_biUnion, *]\n\n@[simp] lemma substs_positive (t : Semiterm L \u03be n) (v : Fin n \u2192 Semiterm L \u03be (m + 1)) :\n    (Rew.substs v t).Positive \u2194 \u2200 i \u2208 t.bv, (v i).Positive := by\n  simp [Semiterm.Positive, substs_bv]\n  exact \u27e8fun H i hi x hx \u21a6 H x i hi hx, fun H x i hi hx \u21a6 H i hi x hx\u27e9\n\nlemma embSubsts_bv (t : Semiterm L Empty n) (v : Fin n \u2192 Semiterm L \u03be m) :\n    (Rew.embSubsts v t).bv = t.bv.biUnion (fun i \u21a6 (v i).bv) := by\n  induction t <;> simp [Rew.func, Semiterm.bv_func, Finset.biUnion_biUnion, *]\n  \u00b7 contradiction\n\n@[simp] lemma embSubsts_positive (t : Semiterm L Empty n) (v : Fin n \u2192 Semiterm L \u03be (m + 1)) :\n    (Rew.embSubsts v t).Positive \u2194 \u2200 i \u2208 t.bv, (v i).Positive := by\n  simp [Semiterm.Positive, embSubsts_bv]\n  exact \u27e8fun H i hi x hx \u21a6 H x i hi hx, fun H x i hi hx \u21a6 H i hi x hx\u27e9\n\n@[simp] lemma bshift_positive (t : Semiterm L \u03be n) : Positive (Rew.bShift t) := by\n  induction t <;> simp\n\nlemma emb_comp_bShift_comm {o : Type v\u2081} [IsEmpty o] :\n    Rew.bShift.comp (Rew.emb : Rew L o n \u03be n) = Rew.emb.comp Rew.bShift := by\n  ext x; simp [comp_app]\n  exact IsEmpty.elim (by assumption) x\n\nlemma emb_bShift_term {o : Type v\u2081} [IsEmpty o] (t : Semiterm L o n) :\n    Rew.bShift (Rew.emb t : Semiterm L \u03be n) = Rew.emb (Rew.bShift t) := by\n  simp [\u2190comp_app, emb_comp_bShift_comm]\n\nend Rew\n\n/-!\n### Rewriting system of terms\n\n-/\nnamespace Semiterm\n\nvariable {L L' L\u2081 L\u2082 L\u2083 : Language} {\u03be \u03be' \u03be\u2081 \u03be\u2082 \u03be\u2083 : Type*} {n n\u2081 n\u2082 n\u2083 : \u2115}\n\ninstance : Coe (Semiterm L Empty n) (SyntacticSemiterm L n) := \u27e8Rew.emb\u27e9\n\n@[simp] lemma freeVariables_emb {\u03bf : Type*} [IsEmpty \u03bf] [DecidableEq \u03be] {t : Semiterm L \u03bf n} :\n    (Rew.emb t : Semiterm L \u03be n).freeVariables = \u2205 := by\n  induction t\n  case bvar => simp\n  case fvar x => exact IsEmpty.elim inferInstance x\n  case func k f v ih =>\n    ext x; simp [Rew.func, freeVariables_func, ih]\n\nlemma rew_eq_of_funEqOn [DecidableEq \u03be\u2081] (\u03c9\u2081 \u03c9\u2082 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) (t : Semiterm L \u03be\u2081 n\u2081)\n  (hb : \u2200 x, \u03c9\u2081 #x = \u03c9\u2082 #x)\n  (he : Function.funEqOn t.FVar? (\u03c9\u2081 \u2218 Semiterm.fvar) (\u03c9\u2082 \u2218 Semiterm.fvar)) :\n    \u03c9\u2081 t = \u03c9\u2082 t := by\n  induction t <;> try simp[Rew.func, hb]\n  case fvar => simpa [FVar?, Function.funEqOn] using he\n  case func k f v ih =>\n    funext i\n    exact ih i (he.of_subset $ by simp[FVar?]; intro x hx; exact \u27e8i, hx\u27e9)\n\nsection lMap\n\nvariable (\u03a6 : L\u2081 \u2192\u1d65 L\u2082)\nopen Rew\n\nlemma lMap_bind (b : Fin n\u2081 \u2192 Semiterm L\u2081 \u03be\u2082 n\u2082) (e : \u03be\u2081 \u2192 Semiterm L\u2081 \u03be\u2082 n\u2082) (t) :\n    lMap \u03a6 (bind b e t) = bind (lMap \u03a6 \u2218 b) (lMap \u03a6 \u2218 e) (t.lMap \u03a6) :=\n  by induction t <;> simp[*, lMap_func, Rew.func]\n\nlemma lMap_map (b : Fin n\u2081 \u2192 Fin n\u2082) (e : \u03be\u2081 \u2192 \u03be\u2082) (t) :\n    (map b e t).lMap \u03a6 = map b e (t.lMap \u03a6) := by\n  simp [map, lMap_bind, Function.comp_def]\n\nlemma lMap_bShift (t : Semiterm L\u2081 \u03be\u2081 n) : (bShift t).lMap \u03a6 = bShift (t.lMap \u03a6) :=\n  by simp[bShift, lMap_map]\n\nlemma lMap_shift (t : SyntacticSemiterm L\u2081 n) : (shift t).lMap \u03a6 = shift (t.lMap \u03a6) :=\n  by simp[shift, lMap_map]\n\nlemma lMap_free (t : SyntacticSemiterm L\u2081 (n + 1)) : (free t).lMap \u03a6 = free (t.lMap \u03a6) :=\n  by simp[free, lMap_bind]; congr; exact funext $ Fin.lastCases (by simp) (by simp)\n\nlemma lMap_fix (t : SyntacticSemiterm L\u2081 n) : (fix t).lMap \u03a6 = fix (t.lMap \u03a6) :=\n  by simp[fix, lMap_bind]; congr; funext x; cases x <;> simp\n\nend lMap\n\nlemma fvar?_rew [DecidableEq \u03be\u2081] [DecidableEq \u03be\u2082]\n    {\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082}\n    {t : Semiterm L \u03be\u2081 n\u2081} {x} :\n    (\u03c9 t).FVar? x \u2192 (\u2203 i : Fin n\u2081, (\u03c9 #i).FVar? x) \u2228 (\u2203 z : \u03be\u2081, t.FVar? z \u2227 (\u03c9 &z).FVar? x) := by\n  induction t\n  case bvar z =>\n    intro h; left; exact \u27e8z, h\u27e9\n  case fvar z =>\n    intro h; right; exact \u27e8z, by simp [h]\u27e9\n  case func k F v ih =>\n    simp only [Rew.func, fvar?_func, forall_exists_index]\n    intro i hx\n    rcases ih i hx with (h | \u27e8z, hi, hz\u27e9)\n    \u00b7 left; exact h\n    \u00b7 right; exact \u27e8z, \u27e8i, hi\u27e9, hz\u27e9\n\n@[simp] lemma fvar?_bShift [DecidableEq \u03be] {t : Semiterm L \u03be n} {x} :\n    (Rew.bShift t).FVar? x \u2194 t.FVar? x := by\n  induction t <;> simp [Rew.func, *]\n\ndef toEmpty [DecidableEq \u03be] {n : \u2115} : (t : Semiterm L \u03be n) \u2192 t.freeVariables = \u2205 \u2192 Semiterm L Empty n\n  | #x,        _ => #x\n  | &x,        h => by simp at h\n  | func f v, h =>\n    have : \u2200 i, (v i).freeVariables = \u2205 := by\n      intro i; ext x\n      have := by simpa using Eq.to_iff (congrFun (congrArg Membership.mem h) x)\n      simpa using this i\n    func f fun i \u21a6 toEmpty (v i) (this i)\n\n@[simp] lemma emb_toEmpty [DecidableEq \u03be] (t : Semiterm L \u03be n) (ht : t.freeVariables = \u2205) : Rew.emb (t.toEmpty ht) = t := by\n  induction t <;> try simp [toEmpty, Rew.func, *]\n  case fvar => simp at ht\n\nend Semiterm\n\n/-!\n### Rewriting system of formulae\n\n-/\n\nclass FreeVar (\u03be : outParam Type*) (F : \u2115 \u2192 Type*) where\n\nclass Rewriting (L : outParam Language) (\u03be : outParam Type*) (F : \u2115 \u2192 Type*) (\u03b6 : Type*) (G : outParam (\u2115 \u2192 Type*))\n    [LCWQ F] [LCWQ G] where\n  app {n\u2081 n\u2082} : Rew L \u03be n\u2081 \u03b6 n\u2082 \u2192 F n\u2081 \u2192\u02e1\u1d9c G n\u2082\n  app_all (\u03c9\u2081\u2082 : Rew L \u03be n\u2081 \u03b6 n\u2082) (\u03c6) : app \u03c9\u2081\u2082 (\u2200' \u03c6) = \u2200' (app \u03c9\u2081\u2082.q \u03c6)\n  app_ex (\u03c9\u2081\u2082 : Rew L \u03be n\u2081 \u03b6 n\u2082) (\u03c6) : app \u03c9\u2081\u2082 (\u2203' \u03c6) = \u2203' (app \u03c9\u2081\u2082.q \u03c6)\n\nabbrev SyntacticRewriting (L : outParam Language) (F : \u2115 \u2192 Type*) (G : outParam (\u2115 \u2192 Type*)) [LCWQ F] [LCWQ G] :=\n  Rewriting L \u2115 F \u2115 G\n\nnamespace Rewriting\n\nvariable [LCWQ F] [LCWQ G] [Rewriting L \u03be F \u03b6 G]\n\nattribute [simp] app_all app_ex\n\ninfixr:73 \" \u25b9 \" => app\n\nlemma smul_ext' {\u03c9\u2081 \u03c9\u2082 : Rew L \u03be n\u2081 \u03b6 n\u2082} (h : \u03c9\u2081 = \u03c9\u2082) {\u03c6 : F n\u2081} : \u03c9\u2081 \u25b9 \u03c6 = \u03c9\u2082 \u25b9 \u03c6 := by rw [h]\n\n@[simp] lemma smul_ball (\u03c9 : Rew L \u03be n\u2081 \u03b6 n\u2082) (\u03c6 \u03c8 : F (n\u2081 + 1)) : \u03c9 \u25b9 (\u2200[\u03c6] \u03c8) = \u2200[\u03c9.q \u25b9 \u03c6] (\u03c9.q \u25b9 \u03c8) := by simp [ball]\n\n@[simp] lemma smul_bex (\u03c9 : Rew L \u03be n\u2081 \u03b6 n\u2082) (\u03c6 \u03c8 : F (n\u2081 + 1)) : \u03c9 \u25b9 (\u2203[\u03c6] \u03c8) = \u2203[\u03c9.q \u25b9 \u03c6] (\u03c9.q \u25b9 \u03c8) := by simp [bex]\n\nabbrev substitute [Rewriting L \u03be F \u03be F] (\u03c6 : F n\u2081) (w : Fin n\u2081 \u2192 Semiterm L \u03be n\u2082) : F n\u2082 := Rew.substs w \u25b9 \u03c6\n\ninfix:90 \" \u21dc \" => LO.FirstOrder.Rewriting.substitute\n\nabbrev shift [Rewriting L \u2115 F \u2115 F] (\u03c6 : F n) : F n := @Rew.shift L n \u25b9 \u03c6\n\nabbrev free [Rewriting L \u2115 F \u2115 F] (\u03c6 : F (n + 1)) : F n := @Rew.free L n \u25b9 \u03c6\n\nabbrev fix [Rewriting L \u2115 F \u2115 F] (\u03c6 : F n) : F (n + 1) := @Rew.fix L n \u25b9 \u03c6\n\ndef shifts [Rewriting L \u2115 F \u2115 F] (\u0393 : List (F n)) : List (F n) := \u0393.map Rewriting.shift\n\nscoped[LO.FirstOrder] postfix:max \"\u207a\" => FirstOrder.Rewriting.shifts\n\n@[coe] abbrev embedding {\u03bf \u03be} [IsEmpty \u03bf] {O F : \u2115 \u2192 Type*} [LCWQ O] [LCWQ F] [Rewriting L \u03bf O \u03be F] (\u03c6 : O n) : F n := @Rew.emb L \u03bf _ \u03be n \u25b9 \u03c6\n\nend Rewriting\n\nsection Notation\n\nopen Lean PrettyPrinter Delaborator\n\nsyntax (name := substituteNotation) term:max \"/[\" term,* \"]\" : term\n\nmacro_rules (kind := substituteNotation)\n  | `($\u03c6:term /[$terms:term,*]) => `($\u03c6 \u21dc ![$terms,*])\n\n@[app_unexpander Rewriting.substitute]\ndef _root_.unexpsnderSubstitute : Unexpander\n  | `($_ $\u03c6:term ![$ts:term,*]) => `($\u03c6 /[ $ts,* ])\n  | _                           => throw ()\n\nend Notation\n\nclass ReflectiveRewriting (L : outParam Language) (\u03be : outParam Type*) (F : \u2115 \u2192 Type*)\n    [LCWQ F] [Rewriting L \u03be F \u03be F] where\n  id_app (\u03c6 : F n) : @Rew.id L \u03be n \u25b9 \u03c6 = \u03c6\n\nclass TransitiveRewriting (L : outParam Language)\n    (\u03be\u2081 : outParam Type*) (F\u2081 : \u2115 \u2192 Type*) (\u03be\u2082 : Type*) (F\u2082 : outParam (\u2115 \u2192 Type*)) (\u03be\u2083 : Type*) (F\u2083 : outParam (\u2115 \u2192 Type*))\n    [LCWQ F\u2081] [LCWQ F\u2082] [LCWQ F\u2083]\n    [Rewriting L \u03be\u2081 F\u2081 \u03be\u2082 F\u2082] [Rewriting L \u03be\u2082 F\u2082 \u03be\u2083 F\u2083] [Rewriting L \u03be\u2081 F\u2081 \u03be\u2083 F\u2083] where\n  comp_app (\u03c9\u2081\u2082 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) (\u03c9\u2082\u2083 : Rew L \u03be\u2082 n\u2082 \u03be\u2083 n\u2083) (\u03c6 : F\u2081 n\u2081) : (\u03c9\u2082\u2083.comp \u03c9\u2081\u2082) \u25b9 \u03c6 = \u03c9\u2082\u2083 \u25b9 \u03c9\u2081\u2082 \u25b9 \u03c6\n\nclass InjMapRewriting (L : outParam Language) (\u03be : outParam Type*) (F : \u2115 \u2192 Type*) (\u03b6 : Type*) (G : outParam (\u2115 \u2192 Type*))\n    [LCWQ F] [LCWQ G] [Rewriting L \u03be F \u03b6 G] where\n  smul_map_injective {b : Fin n\u2081 \u2192 Fin n\u2082} {f : \u03be \u2192 \u03b6} :\n    (hb : Function.Injective b) \u2192 (hf : Function.Injective f) \u2192 Function.Injective fun \u03c6 : F n\u2081 \u21a6 Rew.map (L := L) b f \u25b9 \u03c6\n\nclass LawfulSyntacticRewriting (L : outParam Language) (S : \u2115 \u2192 Type*) [LCWQ S] [SyntacticRewriting L S S] extends\n  ReflectiveRewriting L \u2115 S, TransitiveRewriting L \u2115 S \u2115 S \u2115 S, InjMapRewriting L \u2115 S \u2115 S\n\nattribute [simp] ReflectiveRewriting.id_app\n\nnamespace LawfulSyntacticRewriting\n\nvariable {S : \u2115 \u2192 Type*} [LCWQ S] [SyntacticRewriting L S S]\n\nopen Rewriting ReflectiveRewriting TransitiveRewriting InjMapRewriting\n\nlemma fix_allClosure (\u03c6 : S n) :\n    \u2200' fix (\u2200* \u03c6) = \u2200* fix \u03c6 := by\n  induction n\n  case zero => simp [univClosure_succ]\n  case succ n ih => simp [univClosure_succ, ih]\n\n@[simp] lemma shifts_cons (\u03c6 : S n) (\u0393 : List (S n)) :\n    (\u03c6 :: \u0393)\u207a = Rewriting.shift \u03c6 :: \u0393\u207a := by simp [shifts]\n\n@[simp] lemma shifts_nil : ([] : List (S n))\u207a = [] := by rfl\n\nlemma shifts_union (\u0393 \u0394 : List (S n)) :\n    (\u0393 ++ \u0394)\u207a = \u0393\u207a ++ \u0394\u207a := by simp [shifts]\n\nlemma shifts_neg (\u0393 : List (S n)) :\n    (\u0393.map (\u223c\u00b7))\u207a = (\u0393\u207a).map (\u223c\u00b7) := by simp [shifts]\n\nlemma shift_conj\u2082 (\u0393 : List (S n)) : shift (\u22c0\u0393) = \u22c0\u0393\u207a := by\n  induction \u0393 using List.induction_with_singleton\n  case hnil => simp\n  case hsingle => simp\n  case hcons \u03c6 \u0393 h\u0393 ih =>\n    have : \u0393\u207a \u2260 [] := by intro H; have : \u0393 = [] := List.map_eq_nil_iff.mp H; contradiction\n    simp [h\u0393, this, ih]\n\nvariable [LawfulSyntacticRewriting L S]\n\nlemma shift_injective : Function.Injective fun \u03c6 : S n \u21a6 shift \u03c6 :=\n  smul_map_injective Function.injective_id Nat.succ_injective\n\n@[simp] lemma fix_free (\u03c6 : S (n + 1)) :\n    fix (free \u03c6) = \u03c6 := by simp [\u2190comp_app]\n\n@[simp] lemma free_fix (\u03c6 : S n) :\n    free (fix \u03c6) = \u03c6 := by simp [\u2190comp_app]\n\n@[simp] lemma substitute_empty (\u03c6 : S 0) (v : Fin 0 \u2192 Semiterm L \u2115  0) : (\u03c6 \u21dc v) = \u03c6 := by simp [substitute]\n\n/-- `hom_substs_mbar_zero_comp_shift_eq_free` -/\n@[simp] lemma app_substs_fbar_zero_comp_shift_eq_free (\u03c6 : S 1) :\n    (shift \u03c6)/[&0] = free \u03c6 := by simp [\u2190 comp_app, Rew.substs_mbar_zero_comp_shift_eq_free]\n\nlemma free_rewrite_eq (f : \u2115 \u2192 SyntacticTerm L) (\u03c6 : S 1) :\n    free ((Rew.rewrite fun x \u21a6 Rew.bShift (f x)) \u25b9 \u03c6) =\n    Rew.rewrite (&0 :>\u2099 fun x \u21a6 Rew.shift (f x)) \u25b9 free \u03c6 := by\n  simpa [\u2190 comp_app] using smul_ext' <| by ext x <;> simp [Rew.comp_app, Fin.eq_zero]\n\nlemma shift_rewrite_eq (f : \u2115 \u2192 SyntacticTerm L) (\u03c6 : S 0) :\n    shift (Rew.rewrite f \u25b9 \u03c6) = (Rew.rewrite (&0 :>\u2099 fun x \u21a6 Rew.shift (f x))) \u25b9 shift \u03c6 := by\n  simpa [\u2190comp_app] using smul_ext' <| by ext x <;> simp [Rew.comp_app]\n\nlemma rewrite_subst_eq (f : \u2115 \u2192 SyntacticTerm L) (t) (\u03c6 : S 1) :\n    Rew.rewrite f \u25b9 \u03c6/[t] = (Rew.rewrite (Rew.bShift \u2218 f) \u25b9 \u03c6)/[Rew.rewrite f t] := by\n  simpa [\u2190comp_app] using smul_ext' <| by ext x <;> simp[Rew.comp_app]\n\n@[simp] lemma free_substs_nil (\u03c6 : S 0) : free (Rewriting.substitute (\u03be := \u2115) \u03c6 ![]) = shift \u03c6 := by\n  simpa [\u2190comp_app] using smul_ext' <| by\n    ext x <;> simp only [Rew.comp_app, Rew.substs_fvar, Rew.free_fvar, Rew.shift_fvar]; { exact Fin.elim0 x }\n\n", "theoremStatement": "lemma rewrite_substs_nil (f : \u2115 \u2192 SyntacticTerm L) (\u03c6 : S 0) :\n    Rew.rewrite (Rew.bShift \u2218 f) \u25b9 (Rewriting.substitute (\u03be := \u2115) \u03c6 ![]) =\n    Rewriting.substitute (\u03be := \u2115) (Rew.rewrite f \u25b9 \u03c6) ![] ", "theoremName": "LO.FirstOrder.LawfulSyntacticRewriting.rewrite_substs_nil", "fileCreated": {"commit": "f9b24e7d45330d9c809d246bb25b3aeccf722ef3", "date": "2024-11-06"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/Logic/Predicate/Rew.lean", "module": "Foundation.Logic.Predicate.Rew", "jsonFile": "Foundation.Logic.Predicate.Rew.jsonl", "positionMetadata": {"lineInFile": 883, "tokenPositionInFile": 33574, "theoremPositionInFile": 187}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 18, "repositoryPremises": true, "numRepositoryPremises": 27, "numPremises": 49}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simpa [\u2190comp_app] using smul_ext' <| by\n    ext x\n    \u00b7 exact x.elim0\n    \u00b7 simp [Rew.comp_app, Rew.bShift_eq_rewrite]", "proofType": "tactic", "proofLengthLines": 4, "proofLengthTokens": 126}}
{"srcContext": "import Foundation.IntFO.Basic.Rew\n\nnamespace LO.FirstOrder\n\nabbrev Sequent\u1d62 (L : Language) := List (SyntacticFormula\u1d62 L)\n\nopen Semiformula\u1d62\n\nvariable {L : Language} {T : Theory L}\n\nstructure Hilbert\u1d62 (L : Language) where\n  axiomSet : Set (SyntacticFormula\u1d62 L)\n  rewrite_closed {\u03c6 : SyntacticFormula\u1d62 L} : \u03c6 \u2208 axiomSet \u2192 \u2200 f : \u2115 \u2192 SyntacticTerm L, Rew.rewrite f \u25b9 \u03c6 \u2208 axiomSet\n\ninstance : SetLike (Hilbert\u1d62 L) (SyntacticFormula\u1d62 L) where\n  coe := Hilbert\u1d62.axiomSet\n  coe_injective' := by rintro \u27e8T, _\u27e9 \u27e8U, _\u27e9; simp\n\nnamespace Hilbert\u1d62\n\ndef Minimal : Hilbert\u1d62 L := \u27e8\u2205, by simp\u27e9\n\nnotation \"\ud835\udc0c\ud835\udc22\ud835\udc27\u00b9\" => Minimal\n\ndef Intuitionistic : Hilbert\u1d62 L := \u27e8{\u22a5 \u279d \u03c6 | \u03c6}, by rintro _ \u27e8\u03c6, rfl\u27e9 f; exact \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\u27e9\n\nnotation \"\ud835\udc08\ud835\udc27\ud835\udc2d\u00b9\" => Intuitionistic\n\ndef Classical : Hilbert\u1d62 L := \u27e8{\u22a5 \u279d \u03c6 | \u03c6} \u222a {\u03c6 \u22ce \u223c\u03c6 | \u03c6}, by\n  rintro _ (\u27e8\u03c6, rfl\u27e9 | \u27e8\u03c6, rfl\u27e9) f\n  \u00b7 exact Or.inl \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\n  \u00b7 exact Or.inr \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\u27e9\n\nnotation \"\ud835\udc02\ud835\udc25\u00b9\" => Classical\n\nlemma minimal_le (\u039b : Hilbert\u1d62 L) : (Minimal : Hilbert\u1d62 L) \u2264 \u039b := by rintro _ \u27e8\u27e9\n\nlemma intuitionistic_le_classical : (Intuitionistic : Hilbert\u1d62 L) \u2264 Classical := by rintro _ \u27e8\u03c6, rfl\u27e9; exact .inl \u27e8\u03c6, rfl\u27e9\n\nend Hilbert\u1d62\n\ninductive HilbertProof\u1d62 (\u039b : Hilbert\u1d62 L) : SyntacticFormula\u1d62 L \u2192 Type _\n  | eaxm {\u03c6}     : \u03c6 \u2208 \u039b \u2192 HilbertProof\u1d62 \u039b \u03c6\n  | mdp {\u03c6 \u03c8}    : HilbertProof\u1d62 \u039b (\u03c6 \u279d \u03c8) \u2192 HilbertProof\u1d62 \u039b \u03c6 \u2192 HilbertProof\u1d62 \u039b \u03c8\n  | gen {\u03c6}      : HilbertProof\u1d62 \u039b (Rewriting.free \u03c6) \u2192 HilbertProof\u1d62 \u039b (\u2200' \u03c6)\n  | verum        : HilbertProof\u1d62 \u039b \u22a4\n  | imply\u2081 \u03c6 \u03c8   : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c8 \u279d \u03c6\n  | imply\u2082 \u03c6 \u03c8 \u03c7 : HilbertProof\u1d62 \u039b <| (\u03c6 \u279d \u03c8 \u279d \u03c7) \u279d (\u03c6 \u279d \u03c8) \u279d \u03c6 \u279d \u03c7\n  | and\u2081 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u22cf \u03c8 \u279d \u03c6\n  | and\u2082 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u22cf \u03c8 \u279d \u03c8\n  | and\u2083 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c8 \u279d \u03c6 \u22cf \u03c8\n  | or\u2081 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c6 \u22ce \u03c8\n  | or\u2082 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u03c8 \u279d \u03c6 \u22ce \u03c8\n  | or\u2083 \u03c6 \u03c8 \u03c7    : HilbertProof\u1d62 \u039b <| (\u03c6 \u279d \u03c7) \u279d (\u03c8 \u279d \u03c7) \u279d (\u03c6 \u22ce \u03c8 \u279d \u03c7)\n  | all\u2081 \u03c6 t     : HilbertProof\u1d62 \u039b <| \u2200' \u03c6 \u279d \u03c6/[t]\n  | all\u2082 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u2200' (\u03c6/[] \u279d \u03c8) \u279d \u03c6 \u279d \u2200' \u03c8\n  | ex\u2081 t \u03c6      : HilbertProof\u1d62 \u039b <| \u03c6/[t] \u279d \u2203' \u03c6\n  | ex\u2082 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u2200' (\u03c6 \u279d \u03c8/[]) \u279d \u2203' \u03c6 \u279d \u03c8\n\ninstance : System (SyntacticFormula\u1d62 L) (Hilbert\u1d62 L) := \u27e8HilbertProof\u1d62\u27e9\n\nnamespace HilbertProof\u1d62\n\nopen System.FiniteContext Rewriting LawfulSyntacticRewriting\n\nvariable (\u039b : Hilbert\u1d62 L)\n\ninstance : System.ModusPonens \u039b := \u27e8mdp\u27e9\n\ninstance : System.HasAxiomAndInst \u039b := \u27e8and\u2083\u27e9\n\ninstance : System.HasAxiomImply\u2081 \u039b := \u27e8imply\u2081\u27e9\n\ninstance : System.HasAxiomImply\u2082 \u039b := \u27e8imply\u2082\u27e9\n\ninstance : System.Minimal \u039b where\n  mdp := mdp\n  verum := verum\n  imply\u2081 := imply\u2081\n  imply\u2082 := imply\u2082\n  and\u2081 := and\u2081\n  and\u2082 := and\u2082\n  and\u2083 := and\u2083\n  or\u2081 := or\u2081\n  or\u2082 := or\u2082\n  or\u2083 := or\u2083\n  neg_equiv _ := System.iffId _\n\nvariable {\u039b}\n\nprotected def cast {\u03c6 \u03c8} (b : \u039b \u22a2 \u03c6) (e : \u03c6 = \u03c8) : \u039b \u22a2 \u03c8 := e \u25b8 b\n\ndef depth {\u03c6} : \u039b \u22a2 \u03c6 \u2192 \u2115\n  | mdp b d => max (depth b) (depth d) + 1\n  | gen b   => depth b + 1\n  | _       => 0\n\nscoped notation \"\u2016\" d \"\u2016\" => depth d\n\n@[simp] lemma depth_eaxm (h : \u03c6 \u2208 \u039b) : \u2016eaxm h\u2016 = 0 := rfl\n@[simp] lemma depth_mdp (b : \u039b \u22a2 \u03c6 \u279d \u03c8) (d : \u039b \u22a2 \u03c6) : \u2016mdp b d\u2016 = max \u2016b\u2016 \u2016d\u2016 + 1 := rfl\n", "theoremStatement": "@[simp] lemma depth_gen (b : \u039b \u22a2 Rewriting.free \u03c6) : \u2016gen b\u2016 = \u2016b\u2016 + 1 ", "theoremName": "LO.FirstOrder.HilbertProof\u1d62.depth_gen", "fileCreated": {"commit": "7d9e3859942c3a17a697b129e7fb3869eca0066e", "date": "2024-11-09"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/IntFO/Basic/Deduction.lean", "module": "Foundation.IntFO.Basic.Deduction", "jsonFile": "Foundation.IntFO.Basic.Deduction.jsonl", "positionMetadata": {"lineInFile": 102, "tokenPositionInFile": 3137, "theoremPositionInFile": 13}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 14, "numPremises": 22}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "import Foundation.IntFO.Translation\n\n/-!\n#Algebraic Proofs of Cut Elimination\n\nMain reference: Jeremy Avigad, Algebraic proofs of cut elimination, The Journal of Logic and Algebraic Programming, Volume 49, Issues 1\u20132, 2001, Pages 15-30\n -/\n\nnamespace LO.FirstOrder\n\nvariable {L : Language.{u}}\n\nnamespace Derivation\n\ninductive IsCutFree : {\u0393 : Sequent L} \u2192 \u22a2\u1d40 \u0393 \u2192 Prop\n| axL (\u0393) {k} (r : L.Rel k) (v)                 : IsCutFree (axL \u0393 r v)\n| verum (\u0393)                                     : IsCutFree (verum \u0393)\n| or {\u0393 \u03c6 \u03c8} {d : \u22a2\u1d40 \u03c6 :: \u03c8 :: \u0393}               : IsCutFree d \u2192 IsCutFree d.or\n| and {\u0393 \u03c6 \u03c8} {d\u03c6 : \u22a2\u1d40 \u03c6 :: \u0393} {d\u03c8 : \u22a2\u1d40 \u03c8 :: \u0393} : IsCutFree d\u03c6 \u2192 IsCutFree d\u03c8 \u2192 IsCutFree (d\u03c6.and d\u03c8)\n| all {\u0393 \u03c6} {d : \u22a2\u1d40 Rewriting.free \u03c6 :: \u0393\u207a}     : IsCutFree d \u2192 IsCutFree d.all\n| ex {\u0393 \u03c6} (t) {d : \u22a2\u1d40 \u03c6/[t] :: \u0393}              : IsCutFree d \u2192 IsCutFree d.ex\n| wk {\u0394 \u0393} {d : \u22a2\u1d40 \u0394} (ss : \u0394 \u2286 \u0393)              : IsCutFree d \u2192 IsCutFree (d.wk ss)\n\nattribute [simp] IsCutFree.axL IsCutFree.verum\n\nvariable {\u0393 \u0394 : Sequent L}\n\n@[simp] lemma isCutFree_or_iff {d : \u22a2\u1d40 \u03c6 :: \u03c8 :: \u0393} :\n    IsCutFree d.or \u2194 IsCutFree d := \u27e8by rintro \u27e8\u27e9; assumption, .or\u27e9\n\n@[simp] lemma isCutFree_and_iff {d\u03c6 : \u22a2\u1d40 \u03c6 :: \u0393} {d\u03c8 : \u22a2\u1d40 \u03c8 :: \u0393} :\n    IsCutFree (d\u03c6.and d\u03c8) \u2194 IsCutFree d\u03c6 \u2227 IsCutFree d\u03c8 :=\n  \u27e8by rintro \u27e8\u27e9; constructor <;> assumption, by intro \u27e8h\u03c6, h\u03c8\u27e9; exact h\u03c6.and h\u03c8\u27e9\n\n@[simp] lemma isCutFree_all_iff {d : \u22a2\u1d40 Rewriting.free \u03c6 :: \u0393\u207a} :\n    IsCutFree d.all \u2194 IsCutFree d := \u27e8by rintro \u27e8\u27e9; assumption, .all\u27e9\n\n@[simp] lemma isCutFree_ex_iff {d : \u22a2\u1d40 \u03c6/[t] :: \u0393} :\n    IsCutFree d.ex \u2194 IsCutFree d := \u27e8by rintro \u27e8\u27e9; assumption, .ex t\u27e9\n\n@[simp] lemma isCutFree_wk_iff {d : \u22a2\u1d40 \u0394} {ss : \u0394 \u2286 \u0393} :\n    IsCutFree (d.wk ss) \u2194 IsCutFree d := \u27e8by rintro \u27e8\u27e9; assumption, .wk _\u27e9\n\n@[simp] lemma IsCutFree.cast {d : \u22a2\u1d40 \u0393} {e : \u0393 = \u0394} :\n    IsCutFree (.cast d e) \u2194 IsCutFree d := by rcases e; rfl\n\n@[simp] lemma IsCutFree.not_cut (dp : \u22a2\u1d40 \u03c6 :: \u0393) (dn : \u22a2\u1d40 \u223c\u03c6 :: \u0393) : \u00acIsCutFree (dp.cut dn) := by rintro \u27e8\u27e9\n\n@[simp] lemma isCutFree_rewrite_iff_isCutFree {f : \u2115 \u2192 SyntacticTerm L} {d : \u22a2\u1d40 \u0393} :\n    IsCutFree (rewrite d f) \u2194 IsCutFree d := by\n  induction d generalizing f <;> simp [rewrite, *]\n  case root => contradiction\n\n@[simp] lemma isCutFree_map_iff_isCutFree {f : \u2115 \u2192 \u2115} {d : \u22a2\u1d40 \u0393} :\n    IsCutFree (Derivation.map d f) \u2194 IsCutFree d := isCutFree_rewrite_iff_isCutFree\n\n@[simp] lemma IsCutFree.genelalizeByNewver_isCutFree {\u03c6 : SyntacticSemiformula L 1} (hp : \u00ac\u03c6.FVar? m) (h\u0394 : \u2200 \u03c8 \u2208 \u0394, \u00ac\u03c8.FVar? m)\n    (d : \u22a2\u1d40 \u03c6/[&m] :: \u0394) : IsCutFree (genelalizeByNewver hp h\u0394 d) \u2194 IsCutFree d := by simp [genelalizeByNewver]\n\nend Derivation\n\ninductive PositiveDerivationFrom (\u039e : Sequent L) : Sequent L \u2192 Type _\n| verum (\u0393)    : PositiveDerivationFrom \u039e (\u22a4 :: \u0393)\n| or {\u0393 \u03c6 \u03c8}   : PositiveDerivationFrom \u039e (\u03c6 :: \u03c8 :: \u0393) \u2192 PositiveDerivationFrom \u039e (\u03c6 \u22ce \u03c8 :: \u0393)\n| ex {\u0393 \u03c6} (t) : PositiveDerivationFrom \u039e (\u03c6/[t] :: \u0393) \u2192 PositiveDerivationFrom \u039e ((\u2203' \u03c6) :: \u0393)\n| wk {\u0393 \u0394}     : PositiveDerivationFrom \u039e \u0394 \u2192 \u0394 \u2286 \u0393 \u2192 PositiveDerivationFrom \u039e \u0393\n| protected id : PositiveDerivationFrom \u039e \u039e\n\ninfix:45 \" \u27f6\u207a \" => PositiveDerivationFrom\n\nnamespace PositiveDerivationFrom\n\nvariable {\u039e \u0393 \u0394 : Sequent L}\n\ndef ofSubset (ss : \u039e \u2286 \u0393) : \u039e \u27f6\u207a \u0393 := wk .id ss\n\ndef trans {\u039e \u0393 \u0394 : Sequent L} : \u039e \u27f6\u207a \u0393 \u2192 \u0393 \u27f6\u207a \u0394 \u2192 \u039e \u27f6\u207a \u0394\n  | _, verum \u0393 => verum \u0393\n  | b, or d    => or (b.trans d)\n  | b, ex t d  => ex t (b.trans d)\n  | b, wk d h  => wk (b.trans d) h\n  | b, .id     => b\n\ndef cons {\u039e \u0393 : Sequent L} (\u03c6) : \u039e \u27f6\u207a \u0393 \u2192 \u03c6 :: \u039e \u27f6\u207a \u03c6 :: \u0393\n  | verum \u0393         => wk (verum \u0393) (List.subset_cons_self _ _)\n  | @or _ _ \u0393 \u03c8 \u03c7 d =>\n    have : \u03c6 :: \u039e \u27f6\u207a \u03c8 :: \u03c7 :: \u03c6 :: \u0393 := wk (cons \u03c6 d) (by simp; tauto)\n    wk (or this) (by simp)\n  | @ex _ \u039e \u0393 \u03c8 t d =>\n    have : \u03c6 :: \u039e \u27f6\u207a \u03c8/[t] :: \u03c6 :: \u0393 := wk (cons \u03c6 d) (by simp)\n    wk this.ex (by simp)\n  | wk d h          => wk (d.cons \u03c6) (by simp [h])\n  | .id             => .id\n\ndef append {\u039e \u0393 : Sequent L} : (\u0394 : Sequent L) \u2192 \u039e \u27f6\u207a \u0393 \u2192 \u0394 ++ \u039e \u27f6\u207a \u0394 ++ \u0393\n  | [],     d => d\n  | \u03c6 :: \u0394, d => (d.append \u0394).cons \u03c6\n\ndef add {\u0393 \u0394 \u039e \u0398 : Sequent L} : \u0393 \u27f6\u207a \u0394 \u2192 \u039e \u27f6\u207a \u0398 \u2192 \u0393 ++ \u039e \u27f6\u207a \u0394 ++ \u0398\n  | verum \u0394, d => verum _\n  | or d,    b => or (d.add b)\n  | ex t d,  b => ex t (d.add b)\n  | wk d h,  b => wk (d.add b) (by simp [h])\n  | .id,     b => b.append \u0393\n\ndef graft {\u039e \u0393 : Sequent L} (b : \u22a2\u1d40 \u039e) : \u039e \u27f6\u207a \u0393 \u2192 \u22a2\u1d40 \u0393\n  | verum \u0393 => .verum \u0393\n  | or d    => .or (d.graft b)\n  | ex t d  => .ex t (d.graft b)\n  | wk d h  => .wk (d.graft b) h\n  | .id     => b\n\n", "theoremStatement": "lemma graft_isCutFree_of_isCutFree {b : \u22a2\u1d40 \u039e} {d : \u039e \u27f6\u207a \u0393} (hb : Derivation.IsCutFree b) : Derivation.IsCutFree (d.graft b) ", "theoremName": "LO.FirstOrder.PositiveDerivationFrom.graft_isCutFree_of_isCutFree", "fileCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/FirstOrder/Hauptsatz.lean", "module": "Foundation.FirstOrder.Hauptsatz", "jsonFile": "Foundation.FirstOrder.Hauptsatz.jsonl", "positionMetadata": {"lineInFile": 113, "tokenPositionInFile": 4382, "theoremPositionInFile": 12}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 7, "repositoryPremises": true, "numRepositoryPremises": 28, "numPremises": 48}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  induction d <;> simp [graft, *]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 39}}
{"srcContext": "import Foundation.Modal.Formula\n\nnamespace LO.Modal\n\nvariable {\u03b1 : Type u}\n\ninductive NNFormula (\u03b1 : Type u) : Type u where\n  | atom   : \u03b1 \u2192 NNFormula \u03b1\n  | natom  : \u03b1 \u2192 NNFormula \u03b1\n  | falsum : NNFormula \u03b1\n  | verum  : NNFormula \u03b1\n  | or     : NNFormula \u03b1 \u2192 NNFormula \u03b1 \u2192 NNFormula \u03b1\n  | and    : NNFormula \u03b1 \u2192 NNFormula \u03b1 \u2192 NNFormula \u03b1\n  | box    : NNFormula \u03b1 \u2192 NNFormula \u03b1\n  | dia    : NNFormula \u03b1 \u2192 NNFormula \u03b1\n  deriving DecidableEq\n\nnamespace NNFormula\n\nvariable {\u03c6 \u03c8 \u03c7 : NNFormula \u03b1}\n\ndef neg : NNFormula \u03b1 \u2192 NNFormula \u03b1\n  | atom a  => natom a\n  | natom a => atom a\n  | falsum  => verum\n  | verum   => falsum\n  | or \u03c6 \u03c8  => and (neg \u03c6) (neg \u03c8)\n  | and \u03c6 \u03c8 => or (neg \u03c6) (neg \u03c8)\n  | box \u03c6   => dia (neg \u03c6)\n  | dia \u03c6   => box (neg \u03c6)\n\ndef imp (\u03c6 \u03c8 : NNFormula \u03b1) : NNFormula \u03b1 := or (neg \u03c6) \u03c8\n\ninstance : BasicModalLogicalConnective (NNFormula \u03b1) where\n  tilde := neg\n  arrow := imp\n  wedge := and\n  vee := or\n  top := verum\n  bot := falsum\n  box := box\n  dia := dia\n\nlemma or_eq : or \u03c6 \u03c8 = \u03c6 \u22ce \u03c8 := rfl\n\nlemma and_eq : and \u03c6 \u03c8 = \u03c6 \u22cf \u03c8 := rfl\n\nlemma imp_eq : imp \u03c6 \u03c8 = \u03c6 \u279d \u03c8 := rfl\n\nlemma box_eq : box \u03c6 = \u25a1\u03c6 := rfl\n\nlemma dia_eq : dia \u03c6 = \u25c7\u03c6 := rfl\n\n@[simp] lemma imp_eq' : \u03c6 \u279d \u03c8 = \u223c\u03c6 \u22ce \u03c8 := rfl\n\n@[simp] lemma iff_eq : \u03c6 \u2b64 \u03c8 = (\u03c6 \u279d \u03c8) \u22cf (\u03c8 \u279d \u03c6) := rfl\n\nlemma falsum_eq : (falsum : NNFormula \u03b1) = \u22a5 := rfl\n\nlemma verum_eq : (verum : NNFormula \u03b1) = \u22a4 := rfl\n\n@[simp] lemma and_inj (\u03c6\u2081 \u03c8\u2081 \u03c6\u2082 \u03c8\u2082 : Formula \u03b1) : \u03c6\u2081 \u22cf \u03c6\u2082 = \u03c8\u2081 \u22cf \u03c8\u2082 \u2194 \u03c6\u2081 = \u03c8\u2081 \u2227 \u03c6\u2082 = \u03c8\u2082 := by simp[Wedge.wedge]\n\n@[simp] lemma or_inj (\u03c6\u2081 \u03c8\u2081 \u03c6\u2082 \u03c8\u2082 : Formula \u03b1) : \u03c6\u2081 \u22ce \u03c6\u2082 = \u03c8\u2081 \u22ce \u03c8\u2082 \u2194 \u03c6\u2081 = \u03c8\u2081 \u2227 \u03c6\u2082 = \u03c8\u2082 := by simp[Vee.vee]\n\n@[simp] lemma imp_inj (\u03c6\u2081 \u03c8\u2081 \u03c6\u2082 \u03c8\u2082 : Formula \u03b1) : \u03c6\u2081 \u279d \u03c6\u2082 = \u03c8\u2081 \u279d \u03c8\u2082 \u2194 \u03c6\u2081 = \u03c8\u2081 \u2227 \u03c6\u2082 = \u03c8\u2082 := by simp[Arrow.arrow]\n\n@[simp] lemma neg_inj (\u03c6 \u03c8 : Formula \u03b1) : \u223c\u03c6 = \u223c\u03c8 \u2194 \u03c6 = \u03c8 := by simp [NegAbbrev.neg];\n\nlemma neg_eq : neg \u03c6 = \u223c\u03c6 := rfl\n\n@[simp] lemma neg_atom (a : \u03b1) : \u223catom a = natom a := by rfl\n\n@[simp] lemma neg_natom (a : \u03b1) : \u223cnatom a = atom a := by rfl\n\nlemma negneg : \u223c\u223c\u03c6 = \u03c6 := by\n  induction \u03c6 with\n  | and \u03c6 \u03c8 ih\u03c6 ih\u03c8 =>\n    simp only [\u2190neg_eq, neg, and.injEq];\n    exact \u27e8ih\u03c6, ih\u03c8\u27e9;\n  | or \u03c6 \u03c8 ih\u03c6 ih\u03c8 =>\n    simp only [\u2190neg_eq, neg, or.injEq];\n    exact \u27e8ih\u03c6, ih\u03c8\u27e9;\n  | box \u03c6 ih\u03c6 =>\n    simp only [\u2190neg_eq, neg, box.injEq];\n    exact ih\u03c6;\n  | dia \u03c6 ih\u03c6 =>\n    simp only [\u2190neg_eq, neg, dia.injEq];\n    exact ih\u03c6;\n  | _ => tauto;\n\ninstance : ModalDeMorgan (NNFormula \u03b1) where\n  verum := by tauto;\n  falsum := by tauto;\n  and := by tauto;\n  or := by tauto;\n  box := by tauto;\n  dia := by tauto;\n  neg := \u03bb _ => negneg\n  imply := by tauto;\n\nsection toString\n\nvariable [ToString \u03b1]\ndef toStr : NNFormula \u03b1 \u2192 String\n  | atom a  => s!\"+{a}\"\n  | natom a => s!\"-{a}\"\n  | falsum  => \"\u22a5\"\n  | verum   => \"\u22a4\"\n  | or \u03c6 \u03c8  => s!\"({\u03c6.toStr} \u2228 {\u03c8.toStr})\"\n  | and \u03c6 \u03c8 => s!\"({\u03c6.toStr} \u2227 {\u03c8.toStr})\"\n  | box \u03c6   => s!\"\u25a1{\u03c6.toStr}\"\n  | dia \u03c6   => s!\"\u25c7{\u03c6.toStr}\"\ninstance : Repr (NNFormula \u03b1) := \u27e8fun t _ => toStr t\u27e9\n\nend toString\n\n\nsection toFormula\n\ndef toFormula : NNFormula \u03b1 \u2192 Formula \u03b1\n  | atom a  => Formula.atom a\n  | natom a => \u223cFormula.atom a\n  | \u22a5       => \u22a5\n  | \u22a4       => \u22a4\n  | \u03c6 \u22ce \u03c8   => \u03c6.toFormula \u22ce \u03c8.toFormula\n  | \u03c6 \u22cf \u03c8   => \u03c6.toFormula \u22cf \u03c8.toFormula\n  | \u25a1\u03c6      => \u25a1(\u03c6.toFormula)\n  | \u25c7\u03c6      => \u25c7(\u03c6.toFormula)\ninstance : Coe (NNFormula \u03b1) (Formula \u03b1) := \u27e8toFormula\u27e9\n\n@[simp] lemma toFormula_atom (a : \u03b1) : toFormula  (.atom a) = Formula.atom a := rfl\n\n", "theoremStatement": "@[simp] lemma toFormula_natom (a : \u03b1) : toFormula (.natom a) = \u223cFormula.atom a ", "theoremName": "LO.Modal.NNFormula.toFormula_natom", "fileCreated": {"commit": "1f10809ea0f0e98679f13cd2f7f5b706b01878a8", "date": "2024-11-20"}, "theoremCreated": {"commit": "54324e6e009f0d0a288897312d3feb1c0165ad19", "date": "2025-01-24"}, "file": "foundation/Foundation/Modal/NNFormula.lean", "module": "Foundation.Modal.NNFormula", "jsonFile": "Foundation.Modal.NNFormula.jsonl", "positionMetadata": {"lineInFile": 134, "tokenPositionInFile": 3347, "theoremPositionInFile": 19}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 8, "numPremises": 10}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "import Foundation.IntFO.Basic.Rew\n\nnamespace LO.FirstOrder\n\nabbrev Sequent\u1d62 (L : Language) := List (SyntacticFormula\u1d62 L)\n\nopen Semiformula\u1d62\n\nvariable {L : Language} {T : Theory L}\n\nstructure Hilbert\u1d62 (L : Language) where\n  axiomSet : Set (SyntacticFormula\u1d62 L)\n  rewrite_closed {\u03c6 : SyntacticFormula\u1d62 L} : \u03c6 \u2208 axiomSet \u2192 \u2200 f : \u2115 \u2192 SyntacticTerm L, Rew.rewrite f \u25b9 \u03c6 \u2208 axiomSet\n\ninstance : SetLike (Hilbert\u1d62 L) (SyntacticFormula\u1d62 L) where\n  coe := Hilbert\u1d62.axiomSet\n  coe_injective' := by rintro \u27e8T, _\u27e9 \u27e8U, _\u27e9; simp\n\nnamespace Hilbert\u1d62\n\ndef Minimal : Hilbert\u1d62 L := \u27e8\u2205, by simp\u27e9\n\nnotation \"\ud835\udc0c\ud835\udc22\ud835\udc27\u00b9\" => Minimal\n\ndef Intuitionistic : Hilbert\u1d62 L := \u27e8{\u22a5 \u279d \u03c6 | \u03c6}, by rintro _ \u27e8\u03c6, rfl\u27e9 f; exact \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\u27e9\n\nnotation \"\ud835\udc08\ud835\udc27\ud835\udc2d\u00b9\" => Intuitionistic\n\ndef Classical : Hilbert\u1d62 L := \u27e8{\u22a5 \u279d \u03c6 | \u03c6} \u222a {\u03c6 \u22ce \u223c\u03c6 | \u03c6}, by\n  rintro _ (\u27e8\u03c6, rfl\u27e9 | \u27e8\u03c6, rfl\u27e9) f\n  \u00b7 exact Or.inl \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\n  \u00b7 exact Or.inr \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\u27e9\n\nnotation \"\ud835\udc02\ud835\udc25\u00b9\" => Classical\n\nlemma minimal_le (\u039b : Hilbert\u1d62 L) : (Minimal : Hilbert\u1d62 L) \u2264 \u039b := by rintro _ \u27e8\u27e9\n\nlemma intuitionistic_le_classical : (Intuitionistic : Hilbert\u1d62 L) \u2264 Classical := by rintro _ \u27e8\u03c6, rfl\u27e9; exact .inl \u27e8\u03c6, rfl\u27e9\n\nend Hilbert\u1d62\n\ninductive HilbertProof\u1d62 (\u039b : Hilbert\u1d62 L) : SyntacticFormula\u1d62 L \u2192 Type _\n  | eaxm {\u03c6}     : \u03c6 \u2208 \u039b \u2192 HilbertProof\u1d62 \u039b \u03c6\n  | mdp {\u03c6 \u03c8}    : HilbertProof\u1d62 \u039b (\u03c6 \u279d \u03c8) \u2192 HilbertProof\u1d62 \u039b \u03c6 \u2192 HilbertProof\u1d62 \u039b \u03c8\n  | gen {\u03c6}      : HilbertProof\u1d62 \u039b (Rewriting.free \u03c6) \u2192 HilbertProof\u1d62 \u039b (\u2200' \u03c6)\n  | verum        : HilbertProof\u1d62 \u039b \u22a4\n  | imply\u2081 \u03c6 \u03c8   : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c8 \u279d \u03c6\n  | imply\u2082 \u03c6 \u03c8 \u03c7 : HilbertProof\u1d62 \u039b <| (\u03c6 \u279d \u03c8 \u279d \u03c7) \u279d (\u03c6 \u279d \u03c8) \u279d \u03c6 \u279d \u03c7\n  | and\u2081 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u22cf \u03c8 \u279d \u03c6\n  | and\u2082 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u22cf \u03c8 \u279d \u03c8\n  | and\u2083 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c8 \u279d \u03c6 \u22cf \u03c8\n  | or\u2081 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c6 \u22ce \u03c8\n  | or\u2082 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u03c8 \u279d \u03c6 \u22ce \u03c8\n  | or\u2083 \u03c6 \u03c8 \u03c7    : HilbertProof\u1d62 \u039b <| (\u03c6 \u279d \u03c7) \u279d (\u03c8 \u279d \u03c7) \u279d (\u03c6 \u22ce \u03c8 \u279d \u03c7)\n  | all\u2081 \u03c6 t     : HilbertProof\u1d62 \u039b <| \u2200' \u03c6 \u279d \u03c6/[t]\n  | all\u2082 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u2200' (\u03c6/[] \u279d \u03c8) \u279d \u03c6 \u279d \u2200' \u03c8\n  | ex\u2081 t \u03c6      : HilbertProof\u1d62 \u039b <| \u03c6/[t] \u279d \u2203' \u03c6\n  | ex\u2082 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u2200' (\u03c6 \u279d \u03c8/[]) \u279d \u2203' \u03c6 \u279d \u03c8\n\ninstance : System (SyntacticFormula\u1d62 L) (Hilbert\u1d62 L) := \u27e8HilbertProof\u1d62\u27e9\n\nnamespace HilbertProof\u1d62\n\nopen System.FiniteContext Rewriting LawfulSyntacticRewriting\n\nvariable (\u039b : Hilbert\u1d62 L)\n\ninstance : System.ModusPonens \u039b := \u27e8mdp\u27e9\n\ninstance : System.HasAxiomAndInst \u039b := \u27e8and\u2083\u27e9\n\ninstance : System.HasAxiomImply\u2081 \u039b := \u27e8imply\u2081\u27e9\n\ninstance : System.HasAxiomImply\u2082 \u039b := \u27e8imply\u2082\u27e9\n\ninstance : System.Minimal \u039b where\n  mdp := mdp\n  verum := verum\n  imply\u2081 := imply\u2081\n  imply\u2082 := imply\u2082\n  and\u2081 := and\u2081\n  and\u2082 := and\u2082\n  and\u2083 := and\u2083\n  or\u2081 := or\u2081\n  or\u2082 := or\u2082\n  or\u2083 := or\u2083\n  neg_equiv _ := System.iffId _\n\nvariable {\u039b}\n\nprotected def cast {\u03c6 \u03c8} (b : \u039b \u22a2 \u03c6) (e : \u03c6 = \u03c8) : \u039b \u22a2 \u03c8 := e \u25b8 b\n\ndef depth {\u03c6} : \u039b \u22a2 \u03c6 \u2192 \u2115\n  | mdp b d => max (depth b) (depth d) + 1\n  | gen b   => depth b + 1\n  | _       => 0\n\nscoped notation \"\u2016\" d \"\u2016\" => depth d\n\n@[simp] lemma depth_eaxm (h : \u03c6 \u2208 \u039b) : \u2016eaxm h\u2016 = 0 := rfl\n@[simp] lemma depth_mdp (b : \u039b \u22a2 \u03c6 \u279d \u03c8) (d : \u039b \u22a2 \u03c6) : \u2016mdp b d\u2016 = max \u2016b\u2016 \u2016d\u2016 + 1 := rfl\n@[simp] lemma depth_gen (b : \u039b \u22a2 Rewriting.free \u03c6) : \u2016gen b\u2016 = \u2016b\u2016 + 1 := rfl\n@[simp] lemma depth_verum : \u2016(verum : \u039b \u22a2 \u22a4)\u2016 = 0 := rfl\n@[simp] lemma depth_imply\u2081 (\u03c6 \u03c8) : \u2016imply\u2081 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n", "theoremStatement": "@[simp] lemma depth_imply\u2082 (\u03c6 \u03c8 \u03c7) : \u2016imply\u2082 (\u039b := \u039b) \u03c6 \u03c8 \u03c7\u2016 = 0 ", "theoremName": "LO.FirstOrder.HilbertProof\u1d62.depth_imply\u2082", "fileCreated": {"commit": "7d9e3859942c3a17a697b129e7fb3869eca0066e", "date": "2024-11-09"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/IntFO/Basic/Deduction.lean", "module": "Foundation.IntFO.Basic.Deduction", "jsonFile": "Foundation.IntFO.Basic.Deduction.jsonl", "positionMetadata": {"lineInFile": 105, "tokenPositionInFile": 3340, "theoremPositionInFile": 16}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 7, "numPremises": 12}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "import Foundation.IntProp.Formula\nimport Foundation.Modal.Formula\n\nnamespace LO.IntProp\n\ndef Formula.toModalFormula : Formula \u03b1 \u2192 Modal.Formula \u03b1\n  | .atom a => Modal.Formula.atom a\n  | \u22a4 => \u22a4\n  | \u22a5 => \u22a5\n  | \u223c\u03c6 => \u223c(toModalFormula \u03c6)\n  | \u03c6 \u279d \u03c8 => (toModalFormula \u03c6) \u279d (toModalFormula \u03c8)\n  | \u03c6 \u22cf \u03c8 => (toModalFormula \u03c6) \u22cf (toModalFormula \u03c8)\n  | \u03c6 \u22ce \u03c8 => (toModalFormula \u03c6) \u22ce (toModalFormula \u03c8)\npostfix:75 \"\u1d39\" => Formula.toModalFormula\n\nnamespace Formula.toModalFormula\n\n@[simp] lemma def_top : (\u22a4 : Formula \u03b1)\u1d39 = \u22a4 := by rfl\n\n@[simp] lemma def_bot : (\u22a5 : Formula \u03b1)\u1d39 = \u22a5 := by rfl\n\n@[simp] lemma def_atom (a : \u03b1) : (atom a)\u1d39 = .atom a := by rfl\n\n@[simp] lemma def_not (\u03c6 : Formula \u03b1) : (\u223c\u03c6)\u1d39 = \u223c(\u03c6\u1d39) := by rfl\n\n@[simp] lemma def_imp (\u03c6 \u03c8 : Formula \u03b1) : (\u03c6 \u279d \u03c8)\u1d39 = (\u03c6\u1d39) \u279d (\u03c8\u1d39) := by rfl\n\n", "theoremStatement": "@[simp] lemma def_and (\u03c6 \u03c8 : Formula \u03b1) : (\u03c6 \u22cf \u03c8)\u1d39 = (\u03c6\u1d39) \u22cf (\u03c8\u1d39) ", "theoremName": "LO.IntProp.Formula.toModalFormula.def_and", "fileCreated": {"commit": "a1bfd1fa480026f05e476050030c0b2d17983bb0", "date": "2024-11-28"}, "theoremCreated": {"commit": "54324e6e009f0d0a288897312d3feb1c0165ad19", "date": "2025-01-24"}, "file": "foundation/Foundation/Modal/IntProp.lean", "module": "Foundation.Modal.IntProp", "jsonFile": "Foundation.Modal.IntProp.jsonl", "positionMetadata": {"lineInFile": 28, "tokenPositionInFile": 786, "theoremPositionInFile": 6}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 8, "numPremises": 10}, "proofMetadata": {"hasProof": true, "proof": ":= by rfl", "proofType": "tactic", "proofLengthLines": 0, "proofLengthTokens": 9}}
{"srcContext": "import Foundation.Modal.Kripke.Geach.Systems\n\nnamespace LO.Modal.Hilbert\n\nopen System\nopen Modal.Kripke\nopen Formula\nopen Formula.Kripke\n\n", "theoremStatement": "lemma KD5_weakerThan_KD45 : (Hilbert.KD5 \u03b1) \u2264\u209b (Hilbert.KD45 \u03b1) ", "theoremName": "LO.Modal.Hilbert.KD5_weakerThan_KD45", "fileCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "theoremCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "file": "foundation/Foundation/Modal/Hilbert/WeakerThan/KD5_KD45.lean", "module": "Foundation.Modal.Hilbert.WeakerThan.KD5_KD45", "jsonFile": "Foundation.Modal.Hilbert.WeakerThan.KD5_KD45.jsonl", "positionMetadata": {"lineInFile": 10, "tokenPositionInFile": 138, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 20, "numPremises": 44}, "proofMetadata": {"hasProof": true, "proof": ":= normal_weakerThan_of_subset $ by intro; aesop;", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 49}}
{"srcContext": "import Foundation.IntFO.Translation\n\n/-!\n#Algebraic Proofs of Cut Elimination\n\nMain reference: Jeremy Avigad, Algebraic proofs of cut elimination, The Journal of Logic and Algebraic Programming, Volume 49, Issues 1\u20132, 2001, Pages 15-30\n -/\n\nnamespace LO.FirstOrder\n\nvariable {L : Language.{u}}\n\nnamespace Derivation\n\ninductive IsCutFree : {\u0393 : Sequent L} \u2192 \u22a2\u1d40 \u0393 \u2192 Prop\n| axL (\u0393) {k} (r : L.Rel k) (v)                 : IsCutFree (axL \u0393 r v)\n| verum (\u0393)                                     : IsCutFree (verum \u0393)\n| or {\u0393 \u03c6 \u03c8} {d : \u22a2\u1d40 \u03c6 :: \u03c8 :: \u0393}               : IsCutFree d \u2192 IsCutFree d.or\n| and {\u0393 \u03c6 \u03c8} {d\u03c6 : \u22a2\u1d40 \u03c6 :: \u0393} {d\u03c8 : \u22a2\u1d40 \u03c8 :: \u0393} : IsCutFree d\u03c6 \u2192 IsCutFree d\u03c8 \u2192 IsCutFree (d\u03c6.and d\u03c8)\n| all {\u0393 \u03c6} {d : \u22a2\u1d40 Rewriting.free \u03c6 :: \u0393\u207a}     : IsCutFree d \u2192 IsCutFree d.all\n| ex {\u0393 \u03c6} (t) {d : \u22a2\u1d40 \u03c6/[t] :: \u0393}              : IsCutFree d \u2192 IsCutFree d.ex\n| wk {\u0394 \u0393} {d : \u22a2\u1d40 \u0394} (ss : \u0394 \u2286 \u0393)              : IsCutFree d \u2192 IsCutFree (d.wk ss)\n\nattribute [simp] IsCutFree.axL IsCutFree.verum\n\nvariable {\u0393 \u0394 : Sequent L}\n\n@[simp] lemma isCutFree_or_iff {d : \u22a2\u1d40 \u03c6 :: \u03c8 :: \u0393} :\n    IsCutFree d.or \u2194 IsCutFree d := \u27e8by rintro \u27e8\u27e9; assumption, .or\u27e9\n\n@[simp] lemma isCutFree_and_iff {d\u03c6 : \u22a2\u1d40 \u03c6 :: \u0393} {d\u03c8 : \u22a2\u1d40 \u03c8 :: \u0393} :\n    IsCutFree (d\u03c6.and d\u03c8) \u2194 IsCutFree d\u03c6 \u2227 IsCutFree d\u03c8 :=\n  \u27e8by rintro \u27e8\u27e9; constructor <;> assumption, by intro \u27e8h\u03c6, h\u03c8\u27e9; exact h\u03c6.and h\u03c8\u27e9\n\n@[simp] lemma isCutFree_all_iff {d : \u22a2\u1d40 Rewriting.free \u03c6 :: \u0393\u207a} :\n    IsCutFree d.all \u2194 IsCutFree d := \u27e8by rintro \u27e8\u27e9; assumption, .all\u27e9\n\n", "theoremStatement": "@[simp] lemma isCutFree_ex_iff {d : \u22a2\u1d40 \u03c6/[t] :: \u0393} :\n    IsCutFree d.ex \u2194 IsCutFree d ", "theoremName": "LO.FirstOrder.Derivation.isCutFree_ex_iff", "fileCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/FirstOrder/Hauptsatz.lean", "module": "Foundation.FirstOrder.Hauptsatz", "jsonFile": "Foundation.FirstOrder.Hauptsatz.jsonl", "positionMetadata": {"lineInFile": 38, "tokenPositionInFile": 1481, "theoremPositionInFile": 3}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 8, "repositoryPremises": true, "numRepositoryPremises": 48, "numPremises": 77}, "proofMetadata": {"hasProof": true, "proof": ":= \u27e8by rintro \u27e8\u27e9; assumption, .ex t\u27e9", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 36}}
{"srcContext": "import Foundation.Vorspiel.BinaryRelations\nimport Foundation.Modal.Kripke.Completeness\nimport Foundation.Modal.Hilbert.Geach\n\n\nnamespace LO.Modal\n\nnamespace Kripke\n\nabbrev GeachConfluentFrameClass (t : GeachConfluent.Taple) : FrameClass := { F | (GeachConfluent t) F.Rel }\n\ninstance GeachConfluentFrameClass.nonempty : (GeachConfluentFrameClass t).Nonempty := by\n  use reflexivePointFrame.toFrame;\n  intros x _ _ _; use x;\n  constructor <;> { apply Rel.iterate.true_any; tauto; }\n\n\nabbrev MultiGeachConfluentFrameClass (ts : List GeachConfluent.Taple) : FrameClass := { F | (MultiGeachConfluent ts) F.Rel }\n\nnamespace MultiGeachConfluentFrameClass\n\n@[simp] lemma def_nil : MultiGeachConfluentFrameClass [] = AllFrameClass := by rfl;\n\nlemma def_one (t : GeachConfluent.Taple) : MultiGeachConfluentFrameClass [t] = GeachConfluentFrameClass t := by rfl;\n\nlemma def_cons {t : GeachConfluent.Taple} {ts : List GeachConfluent.Taple} (ts_nil : ts \u2260 [])\n  : MultiGeachConfluentFrameClass (t :: ts) = GeachConfluentFrameClass t \u2229 MultiGeachConfluentFrameClass ts := by\n  apply Set.eq_of_subset_of_subset;\n  . rintro F hF;\n    apply MultiGeachConfluent.iff_cons ts_nil |>.mp;\n    exact hF;\n  . rintro F \u27e8hF\u2081, hF\u2082\u27e9;\n    apply MultiGeachConfluent.iff_cons ts_nil |>.mpr;\n    constructor;\n    . apply hF\u2081;\n    . apply hF\u2082;\n\n@[simp]\ninstance nonempty : (MultiGeachConfluentFrameClass ts).Nonempty := by\n  use \u27e8PUnit,  \u03bb _ _ => True\u27e9;\n  induction ts using List.induction_with_singleton with\n  | hnil => simp only [def_nil, Set.mem_univ];\n  | hsingle t =>\n    simp [GeachConfluentFrameClass];\n    intros x _ _ _; use x;\n    constructor <;> { apply Rel.iterate.true_any; tauto; }\n  | hcons t ts ts_nil ih =>\n    simp [MultiGeachConfluentFrameClass.def_cons ts_nil];\n    constructor;\n    . intro x _ _ _; use x;\n      constructor <;> { apply Rel.iterate.true_any; tauto; }\n    . exact ih;\n\nend MultiGeachConfluentFrameClass\n\n\nabbrev FrameClass.IsGeach (C : FrameClass) (ts : List GeachConfluent.Taple) := C = MultiGeachConfluentFrameClass ts\n\n\nsection\n\n/-- Frame class of `Hilbert.KT` -/\nabbrev ReflexiveFrameClass : FrameClass := { F | Reflexive F.Rel }\nlemma ReflexiveFrameClass.is_geach : ReflexiveFrameClass.IsGeach [\u27e80, 0, 1, 0\u27e9] := by\n  simp only [FrameClass.IsGeach, ReflexiveFrameClass, GeachConfluent.reflexive_def,\n    MultiGeachConfluentFrameClass.def_one, GeachConfluentFrameClass];\n\n/-- Frame class of `Hilbert.KD` -/\nabbrev SerialFrameClass : FrameClass := { F | Serial F.Rel }\nlemma SerialFrameClass.is_geach : SerialFrameClass.IsGeach [\u27e80, 0, 1, 1\u27e9] := by\n  simp only [FrameClass.IsGeach, SerialFrameClass, GeachConfluent.serial_def,\n    MultiGeachConfluentFrameClass.def_one, GeachConfluentFrameClass];\n\n/-- Frame class of `Hilbert.KB` -/\nabbrev SymmetricFrameClass : FrameClass := { F | Symmetric F.Rel }\nlemma SymmetricFrameClass.is_geach : SymmetricFrameClass.IsGeach [\u27e80, 1, 0, 1\u27e9] := by\n  simp only [FrameClass.IsGeach, SymmetricFrameClass, GeachConfluent.symmetric_def,\n    MultiGeachConfluentFrameClass.def_one, GeachConfluentFrameClass];\n\n/-- Frame class of `Hilbert.K4` -/\nabbrev TransitiveFrameClass : FrameClass := { F | Transitive F.Rel }\nlemma TransitiveFrameClass.is_geach : TransitiveFrameClass.IsGeach ([\u27e80, 2, 1, 0\u27e9]) := by\n  simp only [FrameClass.IsGeach, TransitiveFrameClass, GeachConfluent.transitive_def,\n    MultiGeachConfluentFrameClass.def_one, GeachConfluentFrameClass];\n\n/-- Frame class of `Hilbert.K5` -/\nabbrev EuclideanFrameClass : FrameClass := { F | Euclidean F.Rel }\nlemma EuclideanFrameClass.is_geach : EuclideanFrameClass.IsGeach ([\u27e81, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, EuclideanFrameClass, GeachConfluent.euclidean_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.S5` -/\nabbrev ReflexiveEuclideanFrameClass : FrameClass := { F | Reflexive F.Rel \u2227 Euclidean F.Rel }\nlemma ReflexiveEuclideanFrameClass.is_geach : ReflexiveEuclideanFrameClass.IsGeach ([\u27e80, 0, 1, 0\u27e9, \u27e81, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, ReflexiveEuclideanFrameClass, GeachConfluent.reflexive_def,\n    GeachConfluent.euclidean_def, MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.KTB` -/\nabbrev ReflexiveSymmetricFrameClass : FrameClass := { F | Reflexive F \u2227 Symmetric F }\nlemma ReflexiveSymmetricFrameClass.is_geach : ReflexiveSymmetricFrameClass.IsGeach ([\u27e80, 0, 1, 0\u27e9, \u27e80, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, ReflexiveSymmetricFrameClass, GeachConfluent.reflexive_def,\n    GeachConfluent.symmetric_def, MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.S4` -/\nabbrev ReflexiveTransitiveFrameClass : FrameClass := { F | Reflexive F \u2227 Transitive F }\nlemma ReflexiveTransitiveFrameClass.is_geach : ReflexiveTransitiveFrameClass.IsGeach ([\u27e80, 0, 1, 0\u27e9, \u27e80, 2, 1, 0\u27e9]) := by\n  simp only [FrameClass.IsGeach, ReflexiveTransitiveFrameClass, GeachConfluent.reflexive_def,\n    GeachConfluent.transitive_def, MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.S4Dot2` -/\nabbrev ReflexiveTransitiveConfluentFrameClass : FrameClass := { F | Reflexive F \u2227 Transitive F \u2227 Confluent F }\nlemma ReflexiveTransitiveConfluentFrameClass.is_geach : ReflexiveTransitiveConfluentFrameClass.IsGeach ([\u27e80, 0, 1, 0\u27e9, \u27e80, 2, 1, 0\u27e9, \u27e81, 1, 1, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, ReflexiveTransitiveConfluentFrameClass,\n    GeachConfluent.reflexive_def, GeachConfluent.transitive_def, GeachConfluent.confluent_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.KT4B` -/\nabbrev ReflexiveTransitiveSymmetricFrameClass : FrameClass := { F | Reflexive F \u2227 Transitive F \u2227 Symmetric F }\nlemma ReflexiveTransitiveSymmetricFrameClass.is_geach : ReflexiveTransitiveSymmetricFrameClass.IsGeach ([\u27e80, 0, 1, 0\u27e9, \u27e80, 2, 1, 0\u27e9, \u27e80, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, ReflexiveTransitiveSymmetricFrameClass,\n    GeachConfluent.reflexive_def, GeachConfluent.transitive_def, GeachConfluent.symmetric_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.KD45` -/\nabbrev SerialTransitiveEuclideanFrameClass : FrameClass := { F | Serial F \u2227 Transitive F \u2227 Euclidean F }\nlemma SerialTransitiveEuclideanFrameClass.is_geach : SerialTransitiveEuclideanFrameClass.IsGeach ([\u27e80, 0, 1, 1\u27e9, \u27e80, 2, 1, 0\u27e9, \u27e81, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, SerialTransitiveEuclideanFrameClass,\n    GeachConfluent.serial_def, GeachConfluent.transitive_def, GeachConfluent.euclidean_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.K45` -/\nabbrev TransitiveEuclideanFrameClass : FrameClass := { F | Transitive F \u2227 Euclidean F }\nlemma TransitiveEuclideanFrameClass.is_geach : TransitiveEuclideanFrameClass.IsGeach ([\u27e80, 2, 1, 0\u27e9, \u27e81, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, TransitiveEuclideanFrameClass,\n    GeachConfluent.transitive_def, GeachConfluent.euclidean_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.KB4` -/\nabbrev SymmetricTransitiveFrameClass : FrameClass := { F | Symmetric F \u2227 Transitive F }\nlemma SymmetricTransitiveFrameClass.is_geach : SymmetricTransitiveFrameClass.IsGeach ([\u27e80, 1, 0, 1\u27e9, \u27e80, 2, 1, 0\u27e9]) := by\n  simp only [FrameClass.IsGeach, SymmetricTransitiveFrameClass,\n    GeachConfluent.symmetric_def, GeachConfluent.transitive_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.KB5` -/\nabbrev SymmetricEuclideanFrameClass : FrameClass := { F | Symmetric F \u2227 Euclidean F }\nlemma SymmetricEuclideanFrameClass.is_geach : SymmetricEuclideanFrameClass.IsGeach ([\u27e80, 1, 0, 1\u27e9, \u27e81, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, SymmetricEuclideanFrameClass,\n    GeachConfluent.symmetric_def, GeachConfluent.euclidean_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.KDB` -/\nabbrev SerialSymmetricFrameClass : FrameClass := { F | Serial F \u2227 Symmetric F }\nlemma SerialSymmetricFrameClass.is_geach : SerialSymmetricFrameClass.IsGeach ([\u27e80, 0, 1, 1\u27e9, \u27e80, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, SerialSymmetricFrameClass,\n    GeachConfluent.serial_def, GeachConfluent.symmetric_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.KD4` -/\nabbrev SerialTransitiveFrameClass : FrameClass := { F | Serial F \u2227 Transitive F }\n", "theoremStatement": "lemma SerialTransitiveFrameClass.is_geach : SerialTransitiveFrameClass.IsGeach ([\u27e80, 0, 1, 1\u27e9, \u27e80, 2, 1, 0\u27e9]) ", "theoremName": "LO.Modal.Kripke.SerialTransitiveFrameClass.is_geach", "fileCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "theoremCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "file": "foundation/Foundation/Modal/Kripke/Geach/Basic.lean", "module": "Foundation.Modal.Kripke.Geach.Basic", "jsonFile": "Foundation.Modal.Kripke.Geach.Basic.jsonl", "positionMetadata": {"lineInFile": 161, "tokenPositionInFile": 8398, "theoremPositionInFile": 37}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 12, "numPremises": 30}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp only [FrameClass.IsGeach, SerialTransitiveFrameClass,\n    GeachConfluent.serial_def, GeachConfluent.transitive_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent]", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 184}}
{"srcContext": "import Foundation.IntFO.Basic.Rew\n\nnamespace LO.FirstOrder\n\nabbrev Sequent\u1d62 (L : Language) := List (SyntacticFormula\u1d62 L)\n\nopen Semiformula\u1d62\n\nvariable {L : Language} {T : Theory L}\n\nstructure Hilbert\u1d62 (L : Language) where\n  axiomSet : Set (SyntacticFormula\u1d62 L)\n  rewrite_closed {\u03c6 : SyntacticFormula\u1d62 L} : \u03c6 \u2208 axiomSet \u2192 \u2200 f : \u2115 \u2192 SyntacticTerm L, Rew.rewrite f \u25b9 \u03c6 \u2208 axiomSet\n\ninstance : SetLike (Hilbert\u1d62 L) (SyntacticFormula\u1d62 L) where\n  coe := Hilbert\u1d62.axiomSet\n  coe_injective' := by rintro \u27e8T, _\u27e9 \u27e8U, _\u27e9; simp\n\nnamespace Hilbert\u1d62\n\ndef Minimal : Hilbert\u1d62 L := \u27e8\u2205, by simp\u27e9\n\nnotation \"\ud835\udc0c\ud835\udc22\ud835\udc27\u00b9\" => Minimal\n\ndef Intuitionistic : Hilbert\u1d62 L := \u27e8{\u22a5 \u279d \u03c6 | \u03c6}, by rintro _ \u27e8\u03c6, rfl\u27e9 f; exact \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\u27e9\n\nnotation \"\ud835\udc08\ud835\udc27\ud835\udc2d\u00b9\" => Intuitionistic\n\ndef Classical : Hilbert\u1d62 L := \u27e8{\u22a5 \u279d \u03c6 | \u03c6} \u222a {\u03c6 \u22ce \u223c\u03c6 | \u03c6}, by\n  rintro _ (\u27e8\u03c6, rfl\u27e9 | \u27e8\u03c6, rfl\u27e9) f\n  \u00b7 exact Or.inl \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\n  \u00b7 exact Or.inr \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\u27e9\n\nnotation \"\ud835\udc02\ud835\udc25\u00b9\" => Classical\n\nlemma minimal_le (\u039b : Hilbert\u1d62 L) : (Minimal : Hilbert\u1d62 L) \u2264 \u039b := by rintro _ \u27e8\u27e9\n\nlemma intuitionistic_le_classical : (Intuitionistic : Hilbert\u1d62 L) \u2264 Classical := by rintro _ \u27e8\u03c6, rfl\u27e9; exact .inl \u27e8\u03c6, rfl\u27e9\n\nend Hilbert\u1d62\n\ninductive HilbertProof\u1d62 (\u039b : Hilbert\u1d62 L) : SyntacticFormula\u1d62 L \u2192 Type _\n  | eaxm {\u03c6}     : \u03c6 \u2208 \u039b \u2192 HilbertProof\u1d62 \u039b \u03c6\n  | mdp {\u03c6 \u03c8}    : HilbertProof\u1d62 \u039b (\u03c6 \u279d \u03c8) \u2192 HilbertProof\u1d62 \u039b \u03c6 \u2192 HilbertProof\u1d62 \u039b \u03c8\n  | gen {\u03c6}      : HilbertProof\u1d62 \u039b (Rewriting.free \u03c6) \u2192 HilbertProof\u1d62 \u039b (\u2200' \u03c6)\n  | verum        : HilbertProof\u1d62 \u039b \u22a4\n  | imply\u2081 \u03c6 \u03c8   : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c8 \u279d \u03c6\n  | imply\u2082 \u03c6 \u03c8 \u03c7 : HilbertProof\u1d62 \u039b <| (\u03c6 \u279d \u03c8 \u279d \u03c7) \u279d (\u03c6 \u279d \u03c8) \u279d \u03c6 \u279d \u03c7\n  | and\u2081 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u22cf \u03c8 \u279d \u03c6\n  | and\u2082 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u22cf \u03c8 \u279d \u03c8\n  | and\u2083 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c8 \u279d \u03c6 \u22cf \u03c8\n  | or\u2081 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c6 \u22ce \u03c8\n  | or\u2082 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u03c8 \u279d \u03c6 \u22ce \u03c8\n  | or\u2083 \u03c6 \u03c8 \u03c7    : HilbertProof\u1d62 \u039b <| (\u03c6 \u279d \u03c7) \u279d (\u03c8 \u279d \u03c7) \u279d (\u03c6 \u22ce \u03c8 \u279d \u03c7)\n  | all\u2081 \u03c6 t     : HilbertProof\u1d62 \u039b <| \u2200' \u03c6 \u279d \u03c6/[t]\n  | all\u2082 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u2200' (\u03c6/[] \u279d \u03c8) \u279d \u03c6 \u279d \u2200' \u03c8\n  | ex\u2081 t \u03c6      : HilbertProof\u1d62 \u039b <| \u03c6/[t] \u279d \u2203' \u03c6\n  | ex\u2082 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u2200' (\u03c6 \u279d \u03c8/[]) \u279d \u2203' \u03c6 \u279d \u03c8\n\ninstance : System (SyntacticFormula\u1d62 L) (Hilbert\u1d62 L) := \u27e8HilbertProof\u1d62\u27e9\n\nnamespace HilbertProof\u1d62\n\nopen System.FiniteContext Rewriting LawfulSyntacticRewriting\n\nvariable (\u039b : Hilbert\u1d62 L)\n\ninstance : System.ModusPonens \u039b := \u27e8mdp\u27e9\n\ninstance : System.HasAxiomAndInst \u039b := \u27e8and\u2083\u27e9\n\ninstance : System.HasAxiomImply\u2081 \u039b := \u27e8imply\u2081\u27e9\n\ninstance : System.HasAxiomImply\u2082 \u039b := \u27e8imply\u2082\u27e9\n\ninstance : System.Minimal \u039b where\n  mdp := mdp\n  verum := verum\n  imply\u2081 := imply\u2081\n  imply\u2082 := imply\u2082\n  and\u2081 := and\u2081\n  and\u2082 := and\u2082\n  and\u2083 := and\u2083\n  or\u2081 := or\u2081\n  or\u2082 := or\u2082\n  or\u2083 := or\u2083\n  neg_equiv _ := System.iffId _\n\nvariable {\u039b}\n\nprotected def cast {\u03c6 \u03c8} (b : \u039b \u22a2 \u03c6) (e : \u03c6 = \u03c8) : \u039b \u22a2 \u03c8 := e \u25b8 b\n\ndef depth {\u03c6} : \u039b \u22a2 \u03c6 \u2192 \u2115\n  | mdp b d => max (depth b) (depth d) + 1\n  | gen b   => depth b + 1\n  | _       => 0\n\nscoped notation \"\u2016\" d \"\u2016\" => depth d\n\n@[simp] lemma depth_eaxm (h : \u03c6 \u2208 \u039b) : \u2016eaxm h\u2016 = 0 := rfl\n@[simp] lemma depth_mdp (b : \u039b \u22a2 \u03c6 \u279d \u03c8) (d : \u039b \u22a2 \u03c6) : \u2016mdp b d\u2016 = max \u2016b\u2016 \u2016d\u2016 + 1 := rfl\n@[simp] lemma depth_gen (b : \u039b \u22a2 Rewriting.free \u03c6) : \u2016gen b\u2016 = \u2016b\u2016 + 1 := rfl\n@[simp] lemma depth_verum : \u2016(verum : \u039b \u22a2 \u22a4)\u2016 = 0 := rfl\n@[simp] lemma depth_imply\u2081 (\u03c6 \u03c8) : \u2016imply\u2081 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_imply\u2082 (\u03c6 \u03c8 \u03c7) : \u2016imply\u2082 (\u039b := \u039b) \u03c6 \u03c8 \u03c7\u2016 = 0 := rfl\n@[simp] lemma depth_and\u2081 (\u03c6 \u03c8) : \u2016and\u2081 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_and\u2082 (\u03c6 \u03c8) : \u2016and\u2082 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_and\u2083 (\u03c6 \u03c8) : \u2016and\u2083 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_or\u2081 (\u03c6 \u03c8) : \u2016or\u2081 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_or\u2082 (\u03c6 \u03c8) : \u2016or\u2082 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_or\u2083 (\u03c6 \u03c8 \u03c7) : \u2016or\u2083 (\u039b := \u039b) \u03c6 \u03c8 \u03c7\u2016 = 0 := rfl\n@[simp] lemma depth_all\u2081 (\u03c6 t) : \u2016all\u2081 (\u039b := \u039b) \u03c6 t\u2016 = 0 := rfl\n@[simp] lemma depth_all\u2082 (\u03c6 \u03c8) : \u2016all\u2082 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_ex\u2081 (t \u03c6) : \u2016ex\u2081 (\u039b := \u039b) t \u03c6\u2016 = 0 := rfl\n@[simp] lemma depth_ex\u2082 (\u03c6 \u03c8) : \u2016ex\u2082 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n\n@[simp] lemma depth_cast (b : \u039b \u22a2 \u03c6) (e : \u03c6 = \u03c8) : \u2016HilbertProof\u1d62.cast b e\u2016 = \u2016b\u2016 := by rcases e; rfl\n\n@[simp] lemma depth_mdp' (b : \u039b \u22a2 \u03c6 \u279d \u03c8) (d : \u039b \u22a2 \u03c6) : \u2016b \u2a00 d\u2016 = max \u2016b\u2016 \u2016d\u2016 + 1 := rfl\n\ndef specialize {\u03c6} (b : \u039b \u22a2 \u2200' \u03c6) (t) : \u039b \u22a2 \u03c6/[t] := all\u2081 \u03c6 t \u2a00 b\n\ndef implyAll {\u03c6 \u03c8} (b : \u039b \u22a2 shift \u03c6 \u279d free \u03c8) : \u039b \u22a2 \u03c6 \u279d \u2200' \u03c8 :=\n  have : \u039b \u22a2 \u2200' (\u03c6/[] \u279d \u03c8) := gen <| by simpa using b\n  all\u2082 \u03c6 \u03c8 \u2a00 this\n\ndef genOverFiniteContext {\u0393 \u03c6} (b : \u0393\u207a \u22a2[\u039b] free \u03c6) : \u0393 \u22a2[\u039b] \u2200' \u03c6 :=\n  ofDef <| implyAll <| by simpa [shift_conj\u2082] using toDef b\n\ndef specializeOverContext {\u0393 \u03c6} (b : \u0393 \u22a2[\u039b] \u2200' \u03c6) (t) : \u0393 \u22a2[\u039b] \u03c6/[t] :=\n  ofDef <| System.impTrans'' (toDef b) (all\u2081 \u03c6 t)\n\ndef allImplyAllOfAllImply (\u03c6 \u03c8) : \u039b \u22a2 \u2200' (\u03c6 \u279d \u03c8) \u279d \u2200' \u03c6 \u279d \u2200' \u03c8 := by\n  apply deduct'\n  apply deduct\n  apply genOverFiniteContext\n  have b\u2081 : [\u2200' shift \u03c6, \u2200' (shift \u03c6 \u279d shift \u03c8)] \u22a2[\u039b] free \u03c6 \u279d free \u03c8 :=\n    System.cast (by simp) (specializeOverContext (nthAxm 1) &0)\n  have b\u2082 : [\u2200' shift \u03c6, \u2200' (shift \u03c6 \u279d shift \u03c8)] \u22a2[\u039b] free \u03c6 :=\n    System.cast (by simp) (specializeOverContext (nthAxm 0) &0)\n  have : [\u2200' \u03c6, \u2200' (\u03c6 \u279d \u03c8)]\u207a \u22a2[\u039b] free \u03c8 := cast (by simp) (b\u2081 \u2a00 b\u2082)\n  exact this\n\ndef allIffAllOfIff {\u03c6 \u03c8} (b : \u039b \u22a2 free \u03c6 \u2b64 free \u03c8) : \u039b \u22a2 \u2200' \u03c6 \u2b64 \u2200' \u03c8 := System.andIntro\n  (allImplyAllOfAllImply \u03c6 \u03c8 \u2a00 gen (System.cast (by simp) (System.andLeft b)))\n  (allImplyAllOfAllImply \u03c8 \u03c6 \u2a00 gen (System.cast (by simp) (System.andRight b)))\n\nset_option diagnostics true in\nset_option profiler true in\ndef dneOfNegative [L.DecidableEq] : {\u03c6 : SyntacticFormula\u1d62 L} \u2192 \u03c6.IsNegative \u2192 \u039b \u22a2 \u223c\u223c\u03c6 \u279d \u03c6\n  | \u22a5,     _ => System.falsumDNE\n  | \u03c6 \u22cf \u03c8, h =>\n    have ih\u03c6 : \u039b \u22a2 \u223c\u223c\u03c6 \u279d \u03c6 := dneOfNegative (by simp [by simpa using h])\n    have ih\u03c8 : \u039b \u22a2 \u223c\u223c\u03c8 \u279d \u03c8 := dneOfNegative (by simp [by simpa using h])\n    have : \u039b \u22a2 \u223c\u03c6 \u279d \u223c(\u03c6 \u22cf \u03c8) := System.contra\u2080' System.and\u2081\n    have d\u03c6 : [\u223c\u223c(\u03c6 \u22cf \u03c8)] \u22a2[\u039b] \u03c6 := of ih\u03c6 \u2a00 (deduct <| byAxm\u2081 \u2a00 (of this \u2a00 byAxm\u2080))\n    have : \u039b \u22a2 \u223c\u03c8 \u279d \u223c(\u03c6 \u22cf \u03c8) := System.contra\u2080' System.and\u2082\n    have d\u03c8 : [\u223c\u223c(\u03c6 \u22cf \u03c8)] \u22a2[\u039b] \u03c8 := of ih\u03c8 \u2a00 (deduct <| byAxm\u2081 \u2a00 (of this \u2a00 byAxm\u2080))\n    deduct' (System.andIntro d\u03c6 d\u03c8)\n  | \u03c6 \u279d \u03c8, h =>\n    let ih\u03c8 : \u039b \u22a2 \u223c\u223c\u03c8 \u279d \u03c8 := dneOfNegative (by simp [by simpa using h])\n    have : [\u223c\u03c8, \u03c6, \u223c\u223c(\u03c6 \u279d \u03c8)] \u22a2[\u039b] \u223c(\u03c6 \u279d \u03c8) := deduct <| byAxm\u2081 \u2a00 (byAxm\u2080 \u2a00 byAxm\u2082)\n    have : [\u223c\u03c8, \u03c6, \u223c\u223c(\u03c6 \u279d \u03c8)] \u22a2[\u039b] \u22a5 := byAxm\u2082 \u2a00 this\n    have : [\u03c6, \u223c\u223c(\u03c6 \u279d \u03c8)] \u22a2[\u039b] \u03c8 := (of ih\u03c8) \u2a00 (deduct this)\n    deduct' (deduct this)\n  | \u2200' \u03c6,  h =>\n    have ih\u03c6 : \u039b \u22a2 \u223c\u223c(free \u03c6) \u279d free \u03c6 := dneOfNegative (by simp [by simpa using h])\n    have : [\u2200' shift \u03c6, \u223c(free \u03c6), \u223c\u223c(\u2200' shift \u03c6)] \u22a2[\u039b] \u22a5 :=\n      have : [\u2200' shift \u03c6, \u223c(free \u03c6), \u223c\u223c(\u2200' shift \u03c6)] \u22a2[\u039b] \u2200' shift \u03c6 := byAxm\u2080\n      byAxm\u2081 \u2a00 System.cast (by simp) (specializeOverContext this &0)\n    have : [\u223c\u223c(\u2200' shift \u03c6)] \u22a2[\u039b] free \u03c6 := of ih\u03c6 \u2a00 deduct (byAxm\u2081 \u2a00 deduct this)\n    implyAll (System.cast (by simp) (deduct' this))\n  termination_by \u03c6 _ => \u03c6.complexity\n\ndef ofDNOfNegative [L.DecidableEq] {\u03c6 : SyntacticFormula\u1d62 L} {\u0393} (b : \u0393 \u22a2[\u039b] \u223c\u223c\u03c6) (h : \u03c6.IsNegative) : \u0393 \u22a2[\u039b] \u03c6 :=\n  System.impTrans'' (toDef b) (dneOfNegative h)\n\ndef dnOfNegative [L.DecidableEq] {\u03c6 : SyntacticFormula\u1d62 L} (h : \u03c6.IsNegative) : \u039b \u22a2 \u223c\u223c\u03c6 \u2b64 \u03c6 :=\n  System.andIntro (dneOfNegative h) System.dni\n\ndef efqOfNegative : {\u03c6 : SyntacticFormula\u1d62 L} \u2192 \u03c6.IsNegative \u2192 \u039b \u22a2 \u22a5 \u279d \u03c6\n  | \u22a5,     _ => System.impId \u22a5\n  | \u03c6 \u22cf \u03c8, h =>\n    have ih\u03c6 : \u039b \u22a2 \u22a5 \u279d \u03c6 := efqOfNegative (by simp [by simpa using h])\n    have ih\u03c8 : \u039b \u22a2 \u22a5 \u279d \u03c8 := efqOfNegative (by simp [by simpa using h])\n    System.implyAnd ih\u03c6 ih\u03c8\n  | \u03c6 \u279d \u03c8, h =>\n    have ih\u03c8 : \u039b \u22a2 \u22a5 \u279d \u03c8 := efqOfNegative (by simp [by simpa using h])\n    System.impTrans'' ih\u03c8 System.imply\u2081\n  | \u2200' \u03c6,  h =>\n    have ih\u03c6 : \u039b \u22a2 \u22a5 \u279d free \u03c6 := efqOfNegative (by simp [by simpa using h])\n    implyAll <| System.cast (by simp) ih\u03c6\n  termination_by \u03c6 _ => \u03c6.complexity\n\ndef iffnegOfNegIff [L.DecidableEq] {\u03c6 \u03c8 : SyntacticFormula\u1d62 L} (h : \u03c6.IsNegative) (b : \u039b \u22a2 \u223c\u03c6 \u2b64 \u03c8) : \u039b \u22a2 \u03c6 \u2b64 \u223c\u03c8 :=\n  System.iffTrans'' (System.iffComm' <| dnOfNegative h) (System.negReplaceIff' b)\n\ndef rewrite (f : \u2115 \u2192 SyntacticTerm L) : \u039b \u22a2 \u03c6 \u2192 \u039b \u22a2 Rew.rewrite f \u25b9 \u03c6\n  | mdp b d        => rewrite f b \u2a00 rewrite f d\n  | gen (\u03c6 := \u03c6) b =>\n    let d : \u039b \u22a2 free ((Rew.rewrite f).q \u25b9 \u03c6) :=\n      HilbertProof\u1d62.cast (rewrite (&0 :>\u2099 fun x \u21a6 Rew.shift (f x)) b)\n        (by simp [Rew.q_rewrite, Function.comp_def, free_rewrite_eq])\n    gen d\n  | eaxm h         => eaxm (\u039b.rewrite_closed h f)\n  | verum          => verum\n  | imply\u2081 _ _     => imply\u2081 _ _\n  | imply\u2082 _ _ _   => imply\u2082 _ _ _\n  | and\u2081 _ _       => and\u2081 _ _\n  | and\u2082 _ _       => and\u2082 _ _\n  | and\u2083 _ _       => and\u2083 _ _\n  | or\u2081 _ _        => or\u2081 _ _\n  | or\u2082 _ _        => or\u2082 _ _\n  | or\u2083 _ _ _      => or\u2083 _ _ _\n  | all\u2081 \u03c6 t       => HilbertProof\u1d62.cast\n    (all\u2081 (Rew.rewrite (\u21d1Rew.bShift \u2218 f) \u25b9 \u03c6) (Rew.rewrite f t))\n    (by simp [Rew.q_rewrite, rewrite_subst_eq])\n  | all\u2082 \u03c6 \u03c8       => HilbertProof\u1d62.cast\n    (all\u2082 (Rew.rewrite f \u25b9 \u03c6) (Rew.rewrite (\u21d1Rew.bShift \u2218 f) \u25b9 \u03c8))\n    (by simp [Rew.q_rewrite, rewrite_substs_nil])\n  | ex\u2081 t \u03c6        => HilbertProof\u1d62.cast\n    (ex\u2081 (Rew.rewrite f t) (Rew.rewrite (\u21d1Rew.bShift \u2218 f) \u25b9 \u03c6))\n    (by simp [Rew.q_rewrite, rewrite_subst_eq])\n  | ex\u2082 \u03c6 \u03c8        => HilbertProof\u1d62.cast\n    (ex\u2082 (Rew.rewrite (\u21d1Rew.bShift \u2218 f) \u25b9 \u03c6) (Rew.rewrite f \u25b9 \u03c8))\n    (by simp [Rew.q_rewrite, rewrite_substs_nil])\n\n", "theoremStatement": "@[simp] lemma depth_rewrite (f : \u2115 \u2192 SyntacticTerm L) (b : \u039b \u22a2 \u03c6) : \u2016rewrite f b\u2016 = \u2016b\u2016 ", "theoremName": "LO.FirstOrder.HilbertProof\u1d62.depth_rewrite", "fileCreated": {"commit": "7d9e3859942c3a17a697b129e7fb3869eca0066e", "date": "2024-11-09"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/IntFO/Basic/Deduction.lean", "module": "Foundation.IntFO.Basic.Deduction", "jsonFile": "Foundation.IntFO.Basic.Deduction.jsonl", "positionMetadata": {"lineInFile": 228, "tokenPositionInFile": 9273, "theoremPositionInFile": 38}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 12, "repositoryPremises": true, "numRepositoryPremises": 44, "numPremises": 72}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  induction b generalizing f <;> simp [rewrite, *]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 56}}
{"srcContext": "import Foundation.IntFO.Basic.Rew\n\nnamespace LO.FirstOrder\n\nabbrev Sequent\u1d62 (L : Language) := List (SyntacticFormula\u1d62 L)\n\nopen Semiformula\u1d62\n\nvariable {L : Language} {T : Theory L}\n\nstructure Hilbert\u1d62 (L : Language) where\n  axiomSet : Set (SyntacticFormula\u1d62 L)\n  rewrite_closed {\u03c6 : SyntacticFormula\u1d62 L} : \u03c6 \u2208 axiomSet \u2192 \u2200 f : \u2115 \u2192 SyntacticTerm L, Rew.rewrite f \u25b9 \u03c6 \u2208 axiomSet\n\ninstance : SetLike (Hilbert\u1d62 L) (SyntacticFormula\u1d62 L) where\n  coe := Hilbert\u1d62.axiomSet\n  coe_injective' := by rintro \u27e8T, _\u27e9 \u27e8U, _\u27e9; simp\n\nnamespace Hilbert\u1d62\n\ndef Minimal : Hilbert\u1d62 L := \u27e8\u2205, by simp\u27e9\n\nnotation \"\ud835\udc0c\ud835\udc22\ud835\udc27\u00b9\" => Minimal\n\ndef Intuitionistic : Hilbert\u1d62 L := \u27e8{\u22a5 \u279d \u03c6 | \u03c6}, by rintro _ \u27e8\u03c6, rfl\u27e9 f; exact \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\u27e9\n\nnotation \"\ud835\udc08\ud835\udc27\ud835\udc2d\u00b9\" => Intuitionistic\n\ndef Classical : Hilbert\u1d62 L := \u27e8{\u22a5 \u279d \u03c6 | \u03c6} \u222a {\u03c6 \u22ce \u223c\u03c6 | \u03c6}, by\n  rintro _ (\u27e8\u03c6, rfl\u27e9 | \u27e8\u03c6, rfl\u27e9) f\n  \u00b7 exact Or.inl \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\n  \u00b7 exact Or.inr \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\u27e9\n\nnotation \"\ud835\udc02\ud835\udc25\u00b9\" => Classical\n\nlemma minimal_le (\u039b : Hilbert\u1d62 L) : (Minimal : Hilbert\u1d62 L) \u2264 \u039b := by rintro _ \u27e8\u27e9\n\nlemma intuitionistic_le_classical : (Intuitionistic : Hilbert\u1d62 L) \u2264 Classical := by rintro _ \u27e8\u03c6, rfl\u27e9; exact .inl \u27e8\u03c6, rfl\u27e9\n\nend Hilbert\u1d62\n\ninductive HilbertProof\u1d62 (\u039b : Hilbert\u1d62 L) : SyntacticFormula\u1d62 L \u2192 Type _\n  | eaxm {\u03c6}     : \u03c6 \u2208 \u039b \u2192 HilbertProof\u1d62 \u039b \u03c6\n  | mdp {\u03c6 \u03c8}    : HilbertProof\u1d62 \u039b (\u03c6 \u279d \u03c8) \u2192 HilbertProof\u1d62 \u039b \u03c6 \u2192 HilbertProof\u1d62 \u039b \u03c8\n  | gen {\u03c6}      : HilbertProof\u1d62 \u039b (Rewriting.free \u03c6) \u2192 HilbertProof\u1d62 \u039b (\u2200' \u03c6)\n  | verum        : HilbertProof\u1d62 \u039b \u22a4\n  | imply\u2081 \u03c6 \u03c8   : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c8 \u279d \u03c6\n  | imply\u2082 \u03c6 \u03c8 \u03c7 : HilbertProof\u1d62 \u039b <| (\u03c6 \u279d \u03c8 \u279d \u03c7) \u279d (\u03c6 \u279d \u03c8) \u279d \u03c6 \u279d \u03c7\n  | and\u2081 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u22cf \u03c8 \u279d \u03c6\n  | and\u2082 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u22cf \u03c8 \u279d \u03c8\n  | and\u2083 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c8 \u279d \u03c6 \u22cf \u03c8\n  | or\u2081 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c6 \u22ce \u03c8\n  | or\u2082 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u03c8 \u279d \u03c6 \u22ce \u03c8\n  | or\u2083 \u03c6 \u03c8 \u03c7    : HilbertProof\u1d62 \u039b <| (\u03c6 \u279d \u03c7) \u279d (\u03c8 \u279d \u03c7) \u279d (\u03c6 \u22ce \u03c8 \u279d \u03c7)\n  | all\u2081 \u03c6 t     : HilbertProof\u1d62 \u039b <| \u2200' \u03c6 \u279d \u03c6/[t]\n  | all\u2082 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u2200' (\u03c6/[] \u279d \u03c8) \u279d \u03c6 \u279d \u2200' \u03c8\n  | ex\u2081 t \u03c6      : HilbertProof\u1d62 \u039b <| \u03c6/[t] \u279d \u2203' \u03c6\n  | ex\u2082 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u2200' (\u03c6 \u279d \u03c8/[]) \u279d \u2203' \u03c6 \u279d \u03c8\n\ninstance : System (SyntacticFormula\u1d62 L) (Hilbert\u1d62 L) := \u27e8HilbertProof\u1d62\u27e9\n\nnamespace HilbertProof\u1d62\n\nopen System.FiniteContext Rewriting LawfulSyntacticRewriting\n\nvariable (\u039b : Hilbert\u1d62 L)\n\ninstance : System.ModusPonens \u039b := \u27e8mdp\u27e9\n\ninstance : System.HasAxiomAndInst \u039b := \u27e8and\u2083\u27e9\n\ninstance : System.HasAxiomImply\u2081 \u039b := \u27e8imply\u2081\u27e9\n\ninstance : System.HasAxiomImply\u2082 \u039b := \u27e8imply\u2082\u27e9\n\ninstance : System.Minimal \u039b where\n  mdp := mdp\n  verum := verum\n  imply\u2081 := imply\u2081\n  imply\u2082 := imply\u2082\n  and\u2081 := and\u2081\n  and\u2082 := and\u2082\n  and\u2083 := and\u2083\n  or\u2081 := or\u2081\n  or\u2082 := or\u2082\n  or\u2083 := or\u2083\n  neg_equiv _ := System.iffId _\n\nvariable {\u039b}\n\nprotected def cast {\u03c6 \u03c8} (b : \u039b \u22a2 \u03c6) (e : \u03c6 = \u03c8) : \u039b \u22a2 \u03c8 := e \u25b8 b\n\ndef depth {\u03c6} : \u039b \u22a2 \u03c6 \u2192 \u2115\n  | mdp b d => max (depth b) (depth d) + 1\n  | gen b   => depth b + 1\n  | _       => 0\n\nscoped notation \"\u2016\" d \"\u2016\" => depth d\n\n@[simp] lemma depth_eaxm (h : \u03c6 \u2208 \u039b) : \u2016eaxm h\u2016 = 0 := rfl\n@[simp] lemma depth_mdp (b : \u039b \u22a2 \u03c6 \u279d \u03c8) (d : \u039b \u22a2 \u03c6) : \u2016mdp b d\u2016 = max \u2016b\u2016 \u2016d\u2016 + 1 := rfl\n@[simp] lemma depth_gen (b : \u039b \u22a2 Rewriting.free \u03c6) : \u2016gen b\u2016 = \u2016b\u2016 + 1 := rfl\n", "theoremStatement": "@[simp] lemma depth_verum : \u2016(verum : \u039b \u22a2 \u22a4)\u2016 = 0 ", "theoremName": "LO.FirstOrder.HilbertProof\u1d62.depth_verum", "fileCreated": {"commit": "7d9e3859942c3a17a697b129e7fb3869eca0066e", "date": "2024-11-09"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/IntFO/Basic/Deduction.lean", "module": "Foundation.IntFO.Basic.Deduction", "jsonFile": "Foundation.IntFO.Basic.Deduction.jsonl", "positionMetadata": {"lineInFile": 103, "tokenPositionInFile": 3215, "theoremPositionInFile": 14}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 7, "numPremises": 13}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "import Foundation.Modal.Kripke.Geach.Systems\n\nnamespace LO.Modal.Hilbert\n\nopen System\nopen Modal.Kripke\nopen Formula\nopen Formula.Kripke\n\nlemma K45_weakerThan_KB4 : (Hilbert.K45 \u2115) \u2264\u209b (Hilbert.KB4 \u2115) := by\n  apply Kripke.weakerThan_of_subset_FrameClass TransitiveEuclideanFrameClass SymmetricTransitiveFrameClass;\n  rintro F \u27e8h_symm, h_trans\u27e9;\n  refine \u27e8h_trans, (eucl_of_symm_trans h_symm h_trans)\u27e9;\n\n", "theoremStatement": "theorem K45_strictlyWeakerThan_KB4 : (Hilbert.K45 \u2115) <\u209b (Hilbert.KB4 \u2115) ", "theoremName": "LO.Modal.Hilbert.K45_strictlyWeakerThan_KB4", "fileCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "theoremCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "file": "foundation/Foundation/Modal/Hilbert/WeakerThan/K45_KB4.lean", "module": "Foundation.Modal.Hilbert.WeakerThan.K45_KB4", "jsonFile": "Foundation.Modal.Hilbert.WeakerThan.K45_KB4.jsonl", "positionMetadata": {"lineInFile": 15, "tokenPositionInFile": 402, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 63, "numPremises": 145}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  constructor;\n  . exact K45_weakerThan_KB4;\n  . apply weakerThan_iff.not.mpr;\n    push_neg;\n    use ((atom 0) \u279d \u25a1\u25c7(atom 0));\n    constructor;\n    . exact Deduction.maxm! $ by simp;\n    . apply K45.Kripke.sound.not_provable_of_countermodel;\n      suffices \u2203 F : Frame,  Transitive F.Rel \u2227 Euclidean F.Rel \u2227 \u2203 V : Valuation F, \u2203 w : F.World, \u00ac(Kripke.Satisfies \u27e8F, V\u27e9 w _) by\n        simp [ValidOnModel, ValidOnFrame, Satisfies];\n        tauto;\n      use \u27e8Fin 2, \u03bb x y => y = 1\u27e9;\n      refine \u27e8?_, ?_, ?_\u27e9;\n      . simp [Transitive];\n      . simp [Euclidean];\n      . use (\u03bb w _ => w = 0), 0;\n        simp [Satisfies, Semantics.Realize];", "proofType": "tactic", "proofLengthLines": 17, "proofLengthTokens": 642}}
{"srcContext": "import Foundation.Vorspiel.BinaryRelations\nimport Foundation.Modal.Kripke.Completeness\nimport Foundation.Modal.Hilbert.Geach\n\n\nnamespace LO.Modal\n\nnamespace Kripke\n\nabbrev GeachConfluentFrameClass (t : GeachConfluent.Taple) : FrameClass := { F | (GeachConfluent t) F.Rel }\n\ninstance GeachConfluentFrameClass.nonempty : (GeachConfluentFrameClass t).Nonempty := by\n  use reflexivePointFrame.toFrame;\n  intros x _ _ _; use x;\n  constructor <;> { apply Rel.iterate.true_any; tauto; }\n\n\nabbrev MultiGeachConfluentFrameClass (ts : List GeachConfluent.Taple) : FrameClass := { F | (MultiGeachConfluent ts) F.Rel }\n\nnamespace MultiGeachConfluentFrameClass\n\n@[simp] lemma def_nil : MultiGeachConfluentFrameClass [] = AllFrameClass := by rfl;\n\nlemma def_one (t : GeachConfluent.Taple) : MultiGeachConfluentFrameClass [t] = GeachConfluentFrameClass t := by rfl;\n\nlemma def_cons {t : GeachConfluent.Taple} {ts : List GeachConfluent.Taple} (ts_nil : ts \u2260 [])\n  : MultiGeachConfluentFrameClass (t :: ts) = GeachConfluentFrameClass t \u2229 MultiGeachConfluentFrameClass ts := by\n  apply Set.eq_of_subset_of_subset;\n  . rintro F hF;\n    apply MultiGeachConfluent.iff_cons ts_nil |>.mp;\n    exact hF;\n  . rintro F \u27e8hF\u2081, hF\u2082\u27e9;\n    apply MultiGeachConfluent.iff_cons ts_nil |>.mpr;\n    constructor;\n    . apply hF\u2081;\n    . apply hF\u2082;\n\n@[simp]\ninstance nonempty : (MultiGeachConfluentFrameClass ts).Nonempty := by\n  use \u27e8PUnit,  \u03bb _ _ => True\u27e9;\n  induction ts using List.induction_with_singleton with\n  | hnil => simp only [def_nil, Set.mem_univ];\n  | hsingle t =>\n    simp [GeachConfluentFrameClass];\n    intros x _ _ _; use x;\n    constructor <;> { apply Rel.iterate.true_any; tauto; }\n  | hcons t ts ts_nil ih =>\n    simp [MultiGeachConfluentFrameClass.def_cons ts_nil];\n    constructor;\n    . intro x _ _ _; use x;\n      constructor <;> { apply Rel.iterate.true_any; tauto; }\n    . exact ih;\n\nend MultiGeachConfluentFrameClass\n\n\nabbrev FrameClass.IsGeach (C : FrameClass) (ts : List GeachConfluent.Taple) := C = MultiGeachConfluentFrameClass ts\n\n\nsection\n\n/-- Frame class of `Hilbert.KT` -/\nabbrev ReflexiveFrameClass : FrameClass := { F | Reflexive F.Rel }\nlemma ReflexiveFrameClass.is_geach : ReflexiveFrameClass.IsGeach [\u27e80, 0, 1, 0\u27e9] := by\n  simp only [FrameClass.IsGeach, ReflexiveFrameClass, GeachConfluent.reflexive_def,\n    MultiGeachConfluentFrameClass.def_one, GeachConfluentFrameClass];\n\n/-- Frame class of `Hilbert.KD` -/\nabbrev SerialFrameClass : FrameClass := { F | Serial F.Rel }\nlemma SerialFrameClass.is_geach : SerialFrameClass.IsGeach [\u27e80, 0, 1, 1\u27e9] := by\n  simp only [FrameClass.IsGeach, SerialFrameClass, GeachConfluent.serial_def,\n    MultiGeachConfluentFrameClass.def_one, GeachConfluentFrameClass];\n\n/-- Frame class of `Hilbert.KB` -/\nabbrev SymmetricFrameClass : FrameClass := { F | Symmetric F.Rel }\nlemma SymmetricFrameClass.is_geach : SymmetricFrameClass.IsGeach [\u27e80, 1, 0, 1\u27e9] := by\n  simp only [FrameClass.IsGeach, SymmetricFrameClass, GeachConfluent.symmetric_def,\n    MultiGeachConfluentFrameClass.def_one, GeachConfluentFrameClass];\n\n/-- Frame class of `Hilbert.K4` -/\nabbrev TransitiveFrameClass : FrameClass := { F | Transitive F.Rel }\nlemma TransitiveFrameClass.is_geach : TransitiveFrameClass.IsGeach ([\u27e80, 2, 1, 0\u27e9]) := by\n  simp only [FrameClass.IsGeach, TransitiveFrameClass, GeachConfluent.transitive_def,\n    MultiGeachConfluentFrameClass.def_one, GeachConfluentFrameClass];\n\n/-- Frame class of `Hilbert.K5` -/\nabbrev EuclideanFrameClass : FrameClass := { F | Euclidean F.Rel }\nlemma EuclideanFrameClass.is_geach : EuclideanFrameClass.IsGeach ([\u27e81, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, EuclideanFrameClass, GeachConfluent.euclidean_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.S5` -/\nabbrev ReflexiveEuclideanFrameClass : FrameClass := { F | Reflexive F.Rel \u2227 Euclidean F.Rel }\nlemma ReflexiveEuclideanFrameClass.is_geach : ReflexiveEuclideanFrameClass.IsGeach ([\u27e80, 0, 1, 0\u27e9, \u27e81, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, ReflexiveEuclideanFrameClass, GeachConfluent.reflexive_def,\n    GeachConfluent.euclidean_def, MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.KTB` -/\nabbrev ReflexiveSymmetricFrameClass : FrameClass := { F | Reflexive F \u2227 Symmetric F }\nlemma ReflexiveSymmetricFrameClass.is_geach : ReflexiveSymmetricFrameClass.IsGeach ([\u27e80, 0, 1, 0\u27e9, \u27e80, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, ReflexiveSymmetricFrameClass, GeachConfluent.reflexive_def,\n    GeachConfluent.symmetric_def, MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.S4` -/\nabbrev ReflexiveTransitiveFrameClass : FrameClass := { F | Reflexive F \u2227 Transitive F }\nlemma ReflexiveTransitiveFrameClass.is_geach : ReflexiveTransitiveFrameClass.IsGeach ([\u27e80, 0, 1, 0\u27e9, \u27e80, 2, 1, 0\u27e9]) := by\n  simp only [FrameClass.IsGeach, ReflexiveTransitiveFrameClass, GeachConfluent.reflexive_def,\n    GeachConfluent.transitive_def, MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.S4Dot2` -/\nabbrev ReflexiveTransitiveConfluentFrameClass : FrameClass := { F | Reflexive F \u2227 Transitive F \u2227 Confluent F }\nlemma ReflexiveTransitiveConfluentFrameClass.is_geach : ReflexiveTransitiveConfluentFrameClass.IsGeach ([\u27e80, 0, 1, 0\u27e9, \u27e80, 2, 1, 0\u27e9, \u27e81, 1, 1, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, ReflexiveTransitiveConfluentFrameClass,\n    GeachConfluent.reflexive_def, GeachConfluent.transitive_def, GeachConfluent.confluent_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.KT4B` -/\nabbrev ReflexiveTransitiveSymmetricFrameClass : FrameClass := { F | Reflexive F \u2227 Transitive F \u2227 Symmetric F }\nlemma ReflexiveTransitiveSymmetricFrameClass.is_geach : ReflexiveTransitiveSymmetricFrameClass.IsGeach ([\u27e80, 0, 1, 0\u27e9, \u27e80, 2, 1, 0\u27e9, \u27e80, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, ReflexiveTransitiveSymmetricFrameClass,\n    GeachConfluent.reflexive_def, GeachConfluent.transitive_def, GeachConfluent.symmetric_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.KD45` -/\nabbrev SerialTransitiveEuclideanFrameClass : FrameClass := { F | Serial F \u2227 Transitive F \u2227 Euclidean F }\nlemma SerialTransitiveEuclideanFrameClass.is_geach : SerialTransitiveEuclideanFrameClass.IsGeach ([\u27e80, 0, 1, 1\u27e9, \u27e80, 2, 1, 0\u27e9, \u27e81, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, SerialTransitiveEuclideanFrameClass,\n    GeachConfluent.serial_def, GeachConfluent.transitive_def, GeachConfluent.euclidean_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.K45` -/\nabbrev TransitiveEuclideanFrameClass : FrameClass := { F | Transitive F \u2227 Euclidean F }\nlemma TransitiveEuclideanFrameClass.is_geach : TransitiveEuclideanFrameClass.IsGeach ([\u27e80, 2, 1, 0\u27e9, \u27e81, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, TransitiveEuclideanFrameClass,\n    GeachConfluent.transitive_def, GeachConfluent.euclidean_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.KB4` -/\nabbrev SymmetricTransitiveFrameClass : FrameClass := { F | Symmetric F \u2227 Transitive F }\nlemma SymmetricTransitiveFrameClass.is_geach : SymmetricTransitiveFrameClass.IsGeach ([\u27e80, 1, 0, 1\u27e9, \u27e80, 2, 1, 0\u27e9]) := by\n  simp only [FrameClass.IsGeach, SymmetricTransitiveFrameClass,\n    GeachConfluent.symmetric_def, GeachConfluent.transitive_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.KB5` -/\nabbrev SymmetricEuclideanFrameClass : FrameClass := { F | Symmetric F \u2227 Euclidean F }\nlemma SymmetricEuclideanFrameClass.is_geach : SymmetricEuclideanFrameClass.IsGeach ([\u27e80, 1, 0, 1\u27e9, \u27e81, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, SymmetricEuclideanFrameClass,\n    GeachConfluent.symmetric_def, GeachConfluent.euclidean_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.KDB` -/\nabbrev SerialSymmetricFrameClass : FrameClass := { F | Serial F \u2227 Symmetric F }\nlemma SerialSymmetricFrameClass.is_geach : SerialSymmetricFrameClass.IsGeach ([\u27e80, 0, 1, 1\u27e9, \u27e80, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, SerialSymmetricFrameClass,\n    GeachConfluent.serial_def, GeachConfluent.symmetric_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.KD4` -/\nabbrev SerialTransitiveFrameClass : FrameClass := { F | Serial F \u2227 Transitive F }\nlemma SerialTransitiveFrameClass.is_geach : SerialTransitiveFrameClass.IsGeach ([\u27e80, 0, 1, 1\u27e9, \u27e80, 2, 1, 0\u27e9]) := by\n  simp only [FrameClass.IsGeach, SerialTransitiveFrameClass,\n    GeachConfluent.serial_def, GeachConfluent.transitive_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent]\n\n/-- Frame class of `Hilbert.KD5` -/\nabbrev SerialEuclideanFrameClass : FrameClass := { F | Serial F \u2227 Euclidean F }\n", "theoremStatement": "lemma SerialEuclideanFrameClass.is_geach : SerialEuclideanFrameClass.IsGeach ([\u27e80, 0, 1, 1\u27e9, \u27e81, 1, 0, 1\u27e9]) ", "theoremName": "LO.Modal.Kripke.SerialEuclideanFrameClass.is_geach", "fileCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "theoremCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "file": "foundation/Foundation/Modal/Kripke/Geach/Basic.lean", "module": "Foundation.Modal.Kripke.Geach.Basic", "jsonFile": "Foundation.Modal.Kripke.Geach.Basic.jsonl", "positionMetadata": {"lineInFile": 168, "tokenPositionInFile": 8810, "theoremPositionInFile": 39}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 13, "numPremises": 30}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp only [FrameClass.IsGeach, SerialEuclideanFrameClass,\n    GeachConfluent.serial_def, GeachConfluent.euclidean_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 183}}
{"srcContext": "import Foundation.IntProp.Formula\nimport Foundation.Modal.Formula\n\nnamespace LO.IntProp\n\ndef Formula.toModalFormula : Formula \u03b1 \u2192 Modal.Formula \u03b1\n  | .atom a => Modal.Formula.atom a\n  | \u22a4 => \u22a4\n  | \u22a5 => \u22a5\n  | \u223c\u03c6 => \u223c(toModalFormula \u03c6)\n  | \u03c6 \u279d \u03c8 => (toModalFormula \u03c6) \u279d (toModalFormula \u03c8)\n  | \u03c6 \u22cf \u03c8 => (toModalFormula \u03c6) \u22cf (toModalFormula \u03c8)\n  | \u03c6 \u22ce \u03c8 => (toModalFormula \u03c6) \u22ce (toModalFormula \u03c8)\npostfix:75 \"\u1d39\" => Formula.toModalFormula\n\nnamespace Formula.toModalFormula\n\n", "theoremStatement": "@[simp] lemma def_top : (\u22a4 : Formula \u03b1)\u1d39 = \u22a4 ", "theoremName": "LO.IntProp.Formula.toModalFormula.def_top", "fileCreated": {"commit": "a1bfd1fa480026f05e476050030c0b2d17983bb0", "date": "2024-11-28"}, "theoremCreated": {"commit": "54324e6e009f0d0a288897312d3feb1c0165ad19", "date": "2025-01-24"}, "file": "foundation/Foundation/Modal/IntProp.lean", "module": "Foundation.Modal.IntProp", "jsonFile": "Foundation.Modal.IntProp.jsonl", "positionMetadata": {"lineInFile": 18, "tokenPositionInFile": 469, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 7, "numPremises": 10}, "proofMetadata": {"hasProof": true, "proof": ":= by rfl", "proofType": "tactic", "proofLengthLines": 0, "proofLengthTokens": 9}}
{"srcContext": "import Foundation.Modal.Kripke.Geach.Systems\n\nnamespace LO\n\nnamespace Modal\n\nnamespace Kripke\n\nopen System\nopen Kripke\nopen Formula (atom)\nopen Formula.Kripke\nopen Relation (IrreflGen)\n\nabbrev ReflexiveTransitiveWeaklyConverseWellFoundedFrameClass : FrameClass := { F | Reflexive F.Rel \u2227 Transitive F.Rel \u2227 WeaklyConverseWellFounded F.Rel }\nabbrev ReflexiveTransitiveAntiSymmetricFiniteFrameClass : FiniteFrameClass := { F | Reflexive F.Rel \u2227 Transitive F.Rel \u2227 AntiSymmetric F.Rel }\n\nvariable {F : Kripke.Frame}\n\nlemma Grz_of_WCWF : (Reflexive F.Rel \u2227 Transitive F.Rel \u2227 WeaklyConverseWellFounded F.Rel) \u2192 F \u22a7* \ud835\uddda\ud835\uddff\ud835\ude07 := by\n  rintro \u27e8hRefl, hTrans, hWCWF\u27e9;\n  simp [Axioms.Grz];\n  intro \u03c6 V;\n\n  let X := { x | Satisfies \u27e8F, V\u27e9 x (\u25a1(\u25a1(\u03c6 \u279d \u25a1\u03c6) \u279d \u03c6)) \u2227 \u00ac(Satisfies \u27e8F, V\u27e9 x \u03c6) };\n  let Y := { x | Satisfies \u27e8F, V\u27e9 x (\u25a1(\u25a1(\u03c6 \u279d \u25a1\u03c6) \u279d \u03c6)) \u2227 \u00ac(Satisfies \u27e8F, V\u27e9 x (\u25a1\u03c6)) \u2227 (Satisfies \u27e8F, V\u27e9 x \u03c6) };\n  have : (X \u2229 Y) = \u2205 := by aesop;\n\n  suffices \u2200 x \u2208 X \u222a Y, \u2203 y \u2208 X \u222a Y, (IrreflGen F.Rel) x y by\n    have : (X \u222a Y) = \u2205 := by\n      by_contra hC;\n      replace hC := Set.nonempty_iff_ne_empty.mpr hC;\n      obtain \u27e8z, z_sub, hz\u27e9 := hWCWF.has_min (X \u222a Y) hC;\n      obtain \u27e8x, x_sub, hx\u27e9 := this z z_sub;\n      exact hz x x_sub hx;\n    have : X = \u2205 := by aesop;\n    -- TODO: need more refactor\n    have := Set.not_nonempty_iff_eq_empty.mpr this;\n    have := Set.nonempty_def.not.mp this; push_neg at this;\n    simp [X] at this;\n    exact this;\n\n  intro w hw;\n  rcases hw with (\u27e8hw\u2081, hw\u2082\u27e9 | \u27e8hw\u2081, hw\u2082, hw\u2083\u27e9);\n  . have := hw\u2081 _ (by apply hRefl);\n    have := not_imp_not.mpr this hw\u2082;\n    simp [Satisfies] at this;\n    obtain \u27e8x, Rwx, hx, hbx\u27e9 := this;\n    use x;\n    constructor;\n    . right;\n      refine \u27e8?_, (by simp [Satisfies, hbx]), (by assumption)\u27e9;\n      intro y Rxy hy;\n      exact hw\u2081 _ (hTrans Rwx Rxy) hy;\n    . constructor;\n      . aesop;\n      . exact Rwx;\n  . simp [Satisfies] at hw\u2082;\n    obtain \u27e8x, Rwx, hx\u27e9 := hw\u2082;\n    use x;\n    constructor;\n    . left;\n      refine \u27e8?_, (by assumption)\u27e9;\n      intro y Rxy hy;\n      exact hw\u2081 _ (hTrans Rwx Rxy) hy;\n    . constructor;\n      . aesop;\n      . exact Rwx;\n\n\nlemma valid_on_frame_T_and_Four_of_Grz (h : F \u22a7* \ud835\uddda\ud835\uddff\ud835\ude07) : F \u22a7* ({\u25a1\u03c6 \u279d (\u03c6 \u22cf (\u25a1\u03c6 \u279d \u25a1\u25a1\u03c6)) | (\u03c6 : Formula \u2115)}) := by\n  simp_all [ValidOnFrame, ValidOnModel, Axioms.T, Axioms.Grz];\n  intro \u03c6 V x;\n  let \u03c8 := \u03c6 \u22cf (\u25a1\u03c6 \u279d \u25a1\u25a1\u03c6);\n  have h\u2081 : Satisfies \u27e8F, V\u27e9 x (\u25a1\u03c6 \u279d \u25a1(\u25a1(\u03c8 \u279d \u25a1\u03c8) \u279d \u03c8)) := Hilbert.K.Kripke.sound.sound lemma_Grz\u2081! (by simp) V x;\n  have h\u2082 : Satisfies \u27e8F, V\u27e9 x (\u25a1(\u25a1(\u03c8 \u279d \u25a1\u03c8) \u279d \u03c8) \u279d \u03c8)  := h \u03c8 V x;\n  exact \u03bb f => h\u2082 (h\u2081 f);\n\nlemma valid_on_frame_T_of_Grz (h : F \u22a7* \ud835\uddda\ud835\uddff\ud835\ude07) : F \u22a7* \ud835\udde7 := by\n  have := valid_on_frame_T_and_Four_of_Grz h;\n  simp_all [ValidOnFrame, ValidOnModel, Axioms.T, Axioms.Grz];\n  intro \u03c6 V x hx;\n  exact Satisfies.and_def.mp (this \u03c6 V x hx) |>.1\n\nlemma valid_on_frame_Four_of_Grz (h : F \u22a7* \ud835\uddda\ud835\uddff\ud835\ude07) : F \u22a7* \ud835\udff0 := by\n  have := valid_on_frame_T_and_Four_of_Grz h;\n  simp_all [ValidOnFrame, ValidOnModel, Axioms.T, Axioms.Grz];\n  intro \u03c6 V x hx;\n  exact (Satisfies.and_def.mp (this \u03c6 V x hx) |>.2) hx;\n\nlemma refl_of_Grz (h : F \u22a7* \ud835\uddda\ud835\uddff\ud835\ude07) : Reflexive F := by\n  apply ReflexiveFrameClass.isDefinedBy F |>.mpr;\n  apply valid_on_frame_T_of_Grz h;\n\nlemma trans_of_Grz (h : F \u22a7* \ud835\uddda\ud835\uddff\ud835\ude07) : Transitive F := by\n  apply TransitiveFrameClass.isDefinedBy F |>.mpr;\n  apply valid_on_frame_Four_of_Grz h;\n\nlemma WCWF_of_Grz (h : F \u22a7* \ud835\uddda\ud835\uddff\ud835\ude07) : WCWF F := by\n  have F_trans : Transitive F := trans_of_Grz h;\n  have F_refl : Reflexive F := refl_of_Grz h;\n\n  revert h;\n  contrapose;\n  intro hWCWF;\n\n  replace hWCWF := ConverseWellFounded.iff_has_max.not.mp hWCWF;\n  push_neg at hWCWF;\n  obtain \u27e8f, hf\u27e9 := dependent_choice hWCWF; clear hWCWF;\n  simp [IrreflGen] at hf;\n\n  simp [Semantics.Realize, ValidOnFrame, ValidOnModel];\n  use (atom default);\n  . by_cases H : \u2200 j\u2081 j\u2082, (j\u2081 < j\u2082 \u2192 f j\u2082 \u2260 f j\u2081)\n    . use (\u03bb v _ => \u2200 i, v \u2260 f (2 * i)), (f 0);\n      apply Classical.not_imp.mpr\n      constructor;\n      . suffices Satisfies \u27e8F, _\u27e9 (f 0) (\u25a1(\u223c(atom default) \u279d \u223c(\u25a1(atom default \u279d \u25a1atom default)))) by\n          intro x hx;\n          exact not_imp_not.mp $ this _ hx;\n        simp [Satisfies];\n        rintro v h0v j rfl;\n        use f (2 * j + 1);\n        refine \u27e8?_, ?_, f ((2 * j) + 2), ?_, ?_\u27e9;\n        . apply hf _ |>.2;\n        . intro i;\n          rcases (lt_trichotomy i j) with (hij | rfl | hij);\n          . apply H; omega;\n          . apply H; omega;\n          . apply @H _ _ ?_ |>.symm; omega;\n        . apply hf _ |>.2;\n        . use (j + 1); rfl;\n      . simp [Satisfies];\n        use 0;\n    . push_neg at H;\n      obtain \u27e8j, k, ljk, ejk\u27e9 := H;\n      let V : Valuation F := (\u03bb v _ => v \u2260 f j);\n      use V, (f j);\n      apply Classical.not_imp.mpr;\n      constructor;\n      . have : Satisfies \u27e8F, V\u27e9 (f (j + 1)) (\u223c((atom default) \u279d \u25a1(atom default))) := by\n          simp_all [Satisfies, V];\n          constructor;\n          . exact Ne.symm $ (hf j).1;\n          . rw [\u2190ejk];\n            have H : \u2200 {x y : \u2115}, x < y \u2192 F.Rel (f x) (f y) := by\n              intro x y hxy;\n              induction hxy with\n              | refl => exact (hf x).2;\n              | step _ ih => exact F_trans ih (hf _).2;\n            by_cases h : j + 1 = k;\n            . subst_vars\n              apply F_refl;\n            . have : j + 1 < k := by omega;\n              exact H this;\n        have : Satisfies \u27e8F, V\u27e9 (f j) (\u25a1(\u223c(atom default) \u279d \u223c\u25a1((atom default) \u279d \u25a1atom default))) := by\n          simp_all [Satisfies, V];\n          rintro x hx rfl;\n          use f (j + 1);\n          refine \u27e8(hf j).2, Ne.symm $ (hf j).1, this.2\u27e9;\n        intro x hx;\n        contrapose;\n        exact this _ hx;\n      . simp [Satisfies, V];\n\nlemma ReflexiveTransitiveWeaklyConverseWellFoundedFrameClass.is_defined_by_Grz : ReflexiveTransitiveWeaklyConverseWellFoundedFrameClass.DefinedBy \ud835\uddda\ud835\uddff\ud835\ude07 := by\n  intro F;\n  constructor;\n  . rintro \u27e8hRefl, hTrans, hWCWF\u27e9;\n    apply Grz_of_WCWF;\n    exact \u27e8hRefl, hTrans, hWCWF\u27e9;\n  . rintro h;\n    refine \u27e8refl_of_Grz h, trans_of_Grz h, WCWF_of_Grz h\u27e9;\n\n", "theoremStatement": "lemma ReflexiveTransitiveAntiSymmetricFiniteFrameClass.is_defined_by_Grz : ReflexiveTransitiveAntiSymmetricFiniteFrameClass.DefinedBy \ud835\uddda\ud835\uddff\ud835\ude07 ", "theoremName": "LO.Modal.Kripke.ReflexiveTransitiveAntiSymmetricFiniteFrameClass.is_defined_by_Grz", "fileCreated": {"commit": "33e08c2b47f966f772df9af60cbdbc5688295bbf", "date": "2024-10-15"}, "theoremCreated": {"commit": "0325e10aefcc4025554b4c188d268cd3d830ba21", "date": "2025-01-02"}, "file": "foundation/Foundation/Modal/Kripke/Grz/Definability.lean", "module": "Foundation.Modal.Kripke.Grz.Definability", "jsonFile": "Foundation.Modal.Kripke.Grz.Definability.jsonl", "positionMetadata": {"lineInFile": 175, "tokenPositionInFile": 5945, "theoremPositionInFile": 10}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 5, "repositoryPremises": true, "numRepositoryPremises": 21, "numPremises": 31}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  intro F;\n  constructor;\n  . rintro \u27e8hRefl, hTrans, hAntisymm\u27e9;\n    apply Grz_of_WCWF;\n    refine \u27e8hRefl, hTrans, ?_\u27e9;\n    apply WCWF_of_finite_trans_antisymm;\n    . exact F.world_finite;\n    . assumption;\n    . assumption;\n  . rintro h;\n    refine \u27e8refl_of_Grz h, trans_of_Grz h, antisymm_of_WCWF $ WCWF_of_Grz h\u27e9;", "proofType": "tactic", "proofLengthLines": 11, "proofLengthTokens": 322}}
{"srcContext": "import Foundation.Modal.Kripke.Geach.Systems\n\nnamespace LO.Modal.Hilbert\n\nopen System\nopen Modal.Kripke\nopen Formula\nopen Formula.Kripke\n\nlemma K4_weakerThan_K45 : (Hilbert.K4 \u03b1) \u2264\u209b (Hilbert.K45 \u03b1) := normal_weakerThan_of_subset $ by intro; aesop;\n\n", "theoremStatement": "theorem K4_strictlyWeakerThan_K45 : (Hilbert.K4 \u2115) <\u209b (Hilbert.K45 \u2115) ", "theoremName": "LO.Modal.Hilbert.K4_strictlyWeakerThan_K45", "fileCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "theoremCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "file": "foundation/Foundation/Modal/Hilbert/WeakerThan/K4_K45.lean", "module": "Foundation.Modal.Hilbert.WeakerThan.K4_K45", "jsonFile": "Foundation.Modal.Hilbert.WeakerThan.K4_K45.jsonl", "positionMetadata": {"lineInFile": 12, "tokenPositionInFile": 249, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 62, "numPremises": 185}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  constructor;\n  . exact K4_weakerThan_K45;\n  . apply weakerThan_iff.not.mpr;\n    push_neg;\n    use (\u25c7(atom 0) \u279d \u25a1\u25c7(atom 0));\n    constructor;\n    . exact Deduction.maxm! $ by simp;\n    . apply K4.Kripke.sound.not_provable_of_countermodel;\n      suffices \u2203 F : Frame, Transitive F.Rel \u2227 \u2203 V : Valuation F, \u2203 w : F.World, \u00ac(Kripke.Satisfies \u27e8F, V\u27e9 w _) by\n        simp [ValidOnModel, ValidOnFrame, Satisfies];\n        tauto;\n      let F : Frame := \u27e8Fin 2, \u03bb x y => x < y\u27e9;\n      use F;\n      constructor;\n      . simp [Transitive];\n        omega;\n      . use (\u03bb w _ => w = 1), 0;\n        suffices (0 : F.World) \u227a 1 \u2227 \u2203 x : F.World, (0 : F.World) \u227a x \u2227 \u00acx \u227a 1 by\n          simpa [Semantics.Realize, Satisfies];\n        constructor;\n        . omega;\n        . use 1; omega;", "proofType": "tactic", "proofLengthLines": 22, "proofLengthTokens": 776}}
{"srcContext": "import Foundation.Modal.NNFormula\nimport Foundation.Modal.Kripke.Basic\n\nnamespace LO.Modal\n\nopen System\n\nvariable {\u03c6 \u03c8 : NNFormula \u2115}\n\nnamespace NNFormula.Kripke\n\ndef Satisfies (M : Kripke.Model) (x : M.World) : NNFormula \u2115 \u2192 Prop\n  | atom a  =>  M x a\n  | natom a => \u00acM x a\n  | \u22a4       => True\n  | \u22a5       => False\n  | \u03c6 \u22ce \u03c8   => Satisfies M x \u03c6 \u2228 Satisfies M x \u03c8\n  | \u03c6 \u22cf \u03c8   => Satisfies M x \u03c6 \u2227 Satisfies M x \u03c8\n  | \u25a1\u03c6      => \u2200 y, x \u227a y \u2192 Satisfies M y \u03c6\n  | \u25c7\u03c6      => \u2203 y, x \u227a y \u2227 (Satisfies M y \u03c6)\n\nnamespace Satisfies\n\nvariable {M : Kripke.Model} {x : M.World}\n\nprotected instance semantics : Semantics (NNFormula \u2115) (M.World) := \u27e8\u03bb x \u21a6 Satisfies M x\u27e9\n\nprotected lemma iff_models : x \u22a7 \u03c6 \u2194 Satisfies M x \u03c6 := iff_of_eq rfl\n\n@[simp]\nprotected lemma atom_def (a : \u2115) : x \u22a7 (atom a) \u2194 M x a := by simp [Satisfies.iff_models, Satisfies];\n\n", "theoremStatement": "@[simp]\nprotected lemma natom_def (a : \u2115) : x \u22a7 (natom a) \u2194 \u00acM x a ", "theoremName": "LO.Modal.NNFormula.Kripke.Satisfies.natom_def", "fileCreated": {"commit": "1f10809ea0f0e98679f13cd2f7f5b706b01878a8", "date": "2024-11-20"}, "theoremCreated": {"commit": "54324e6e009f0d0a288897312d3feb1c0165ad19", "date": "2025-01-24"}, "file": "foundation/Foundation/Modal/Kripke/NNFormula.lean", "module": "Foundation.Modal.Kripke.NNFormula", "jsonFile": "Foundation.Modal.Kripke.NNFormula.jsonl", "positionMetadata": {"lineInFile": 33, "tokenPositionInFile": 842, "theoremPositionInFile": 2}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 10, "numPremises": 20}, "proofMetadata": {"hasProof": true, "proof": ":= by simp [Satisfies.iff_models, Satisfies];", "proofType": "tactic", "proofLengthLines": 0, "proofLengthTokens": 45}}
{"srcContext": "import Foundation.Modal.Hilbert.Maximal.Unprovability\nimport Foundation.Modal.Kripke.GL.MDP\n\nnamespace LO.Modal\n\nopen System\nopen IntProp\n\nvariable [DecidableEq \u03b1]\n\ndef independency (\u03c6 : Formula \u03b1) := \u223c\u25a1\u03c6 \u22cf \u223c\u25a1(\u223c\u03c6)\n\ndef higherIndependency (\u03c6 : Formula \u03b1) : \u2115 \u2192 Formula \u03b1\n  | 0 => \u03c6\n  | n + 1 => independency (higherIndependency \u03c6 n)\n\nnamespace Hilbert.GL\n\nvariable {\u03c6 : Formula \u2115}\n\nlemma unprovable_notbox : (Hilbert.GL _) \u22ac \u223c\u25a1\u03c6 := by\n  by_contra hC;\n  have : (Hilbert.GL _) \u22a2! \u223c\u25a1\u03c6 \u279d \u223c\u25a1\u22a5 := contra\u2080'! (imply_box_distribute'! efq!)\n  have : Hilbert.GL _ \u22a2! \u223c\u25a1\u22a5 := this \u2a00 hC;\n  have : Hilbert.Cl \u2115 \u22a2! (\u22a5 \u279d \u22a5) \u279d \u22a5 := by simpa using provable_CL_verTranslated this;\n  simpa using Hilbert.Cl.classical_sound this;\n\n", "theoremStatement": "lemma unprovable_independency : (Hilbert.GL _) \u22ac independency \u03c6 ", "theoremName": "LO.Modal.Hilbert.GL.unprovable_independency", "fileCreated": {"commit": "830d76e560f33054a2eb2051cf1fa73997706985", "date": "2025-01-01"}, "theoremCreated": {"commit": "830d76e560f33054a2eb2051cf1fa73997706985", "date": "2025-01-01"}, "file": "foundation/Foundation/Modal/Hilbert/GL_Independency.lean", "module": "Foundation.Modal.Hilbert.GL_Independency", "jsonFile": "Foundation.Modal.Hilbert.GL_Independency.jsonl", "positionMetadata": {"lineInFile": 28, "tokenPositionInFile": 708, "theoremPositionInFile": 2}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 19, "numPremises": 20}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  by_contra hC;\n  exact unprovable_notbox $ and\u2081'! hC;", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 60}}
{"srcContext": "import Foundation.IntFO.Basic\n\nnamespace LO.FirstOrder\n\nnamespace Sequent\n\ninstance : Tilde (List (Semiformula L \u03be n)) := \u27e8fun \u0393 \u21a6 \u0393.map (\u223c\u00b7)\u27e9\n\n@[simp] lemma neg_def (\u0393 : List (Semiformula L \u03be n)) : \u223c\u0393 = \u0393.map (\u223c\u00b7) := rfl\n\n@[simp] lemma neg_nil : \u223c([] : List (Semiformula L \u03be n)) = [] := rfl\n\n@[simp] lemma neg_cons (\u0393 : List (Semiformula L \u03be n)) (\u03c6) : \u223c(\u03c6 :: \u0393) = \u223c\u03c6 :: \u223c\u0393 := rfl\n\n", "theoremStatement": "@[simp] lemma neg_neg_eq (\u0393 : List (Semiformula L \u03be n)) : \u223c\u223c\u0393 = \u0393 ", "theoremName": "LO.FirstOrder.Sequent.neg_neg_eq", "fileCreated": {"commit": "7d9e3859942c3a17a697b129e7fb3869eca0066e", "date": "2024-11-09"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/IntFO/Translation.lean", "module": "Foundation.IntFO.Translation", "jsonFile": "Foundation.IntFO.Translation.jsonl", "positionMetadata": {"lineInFile": 15, "tokenPositionInFile": 382, "theoremPositionInFile": 3}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 8, "numPremises": 23}, "proofMetadata": {"hasProof": true, "proof": ":= by simp [Function.comp_def]", "proofType": "tactic", "proofLengthLines": 0, "proofLengthTokens": 30}}
{"srcContext": "import Foundation.IntFO.Basic.Rew\n\nnamespace LO.FirstOrder\n\nabbrev Sequent\u1d62 (L : Language) := List (SyntacticFormula\u1d62 L)\n\nopen Semiformula\u1d62\n\nvariable {L : Language} {T : Theory L}\n\nstructure Hilbert\u1d62 (L : Language) where\n  axiomSet : Set (SyntacticFormula\u1d62 L)\n  rewrite_closed {\u03c6 : SyntacticFormula\u1d62 L} : \u03c6 \u2208 axiomSet \u2192 \u2200 f : \u2115 \u2192 SyntacticTerm L, Rew.rewrite f \u25b9 \u03c6 \u2208 axiomSet\n\ninstance : SetLike (Hilbert\u1d62 L) (SyntacticFormula\u1d62 L) where\n  coe := Hilbert\u1d62.axiomSet\n  coe_injective' := by rintro \u27e8T, _\u27e9 \u27e8U, _\u27e9; simp\n\nnamespace Hilbert\u1d62\n\ndef Minimal : Hilbert\u1d62 L := \u27e8\u2205, by simp\u27e9\n\nnotation \"\ud835\udc0c\ud835\udc22\ud835\udc27\u00b9\" => Minimal\n\ndef Intuitionistic : Hilbert\u1d62 L := \u27e8{\u22a5 \u279d \u03c6 | \u03c6}, by rintro _ \u27e8\u03c6, rfl\u27e9 f; exact \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\u27e9\n\nnotation \"\ud835\udc08\ud835\udc27\ud835\udc2d\u00b9\" => Intuitionistic\n\ndef Classical : Hilbert\u1d62 L := \u27e8{\u22a5 \u279d \u03c6 | \u03c6} \u222a {\u03c6 \u22ce \u223c\u03c6 | \u03c6}, by\n  rintro _ (\u27e8\u03c6, rfl\u27e9 | \u27e8\u03c6, rfl\u27e9) f\n  \u00b7 exact Or.inl \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\n  \u00b7 exact Or.inr \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\u27e9\n\nnotation \"\ud835\udc02\ud835\udc25\u00b9\" => Classical\n\nlemma minimal_le (\u039b : Hilbert\u1d62 L) : (Minimal : Hilbert\u1d62 L) \u2264 \u039b := by rintro _ \u27e8\u27e9\n\nlemma intuitionistic_le_classical : (Intuitionistic : Hilbert\u1d62 L) \u2264 Classical := by rintro _ \u27e8\u03c6, rfl\u27e9; exact .inl \u27e8\u03c6, rfl\u27e9\n\nend Hilbert\u1d62\n\ninductive HilbertProof\u1d62 (\u039b : Hilbert\u1d62 L) : SyntacticFormula\u1d62 L \u2192 Type _\n  | eaxm {\u03c6}     : \u03c6 \u2208 \u039b \u2192 HilbertProof\u1d62 \u039b \u03c6\n  | mdp {\u03c6 \u03c8}    : HilbertProof\u1d62 \u039b (\u03c6 \u279d \u03c8) \u2192 HilbertProof\u1d62 \u039b \u03c6 \u2192 HilbertProof\u1d62 \u039b \u03c8\n  | gen {\u03c6}      : HilbertProof\u1d62 \u039b (Rewriting.free \u03c6) \u2192 HilbertProof\u1d62 \u039b (\u2200' \u03c6)\n  | verum        : HilbertProof\u1d62 \u039b \u22a4\n  | imply\u2081 \u03c6 \u03c8   : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c8 \u279d \u03c6\n  | imply\u2082 \u03c6 \u03c8 \u03c7 : HilbertProof\u1d62 \u039b <| (\u03c6 \u279d \u03c8 \u279d \u03c7) \u279d (\u03c6 \u279d \u03c8) \u279d \u03c6 \u279d \u03c7\n  | and\u2081 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u22cf \u03c8 \u279d \u03c6\n  | and\u2082 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u22cf \u03c8 \u279d \u03c8\n  | and\u2083 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c8 \u279d \u03c6 \u22cf \u03c8\n  | or\u2081 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c6 \u22ce \u03c8\n  | or\u2082 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u03c8 \u279d \u03c6 \u22ce \u03c8\n  | or\u2083 \u03c6 \u03c8 \u03c7    : HilbertProof\u1d62 \u039b <| (\u03c6 \u279d \u03c7) \u279d (\u03c8 \u279d \u03c7) \u279d (\u03c6 \u22ce \u03c8 \u279d \u03c7)\n  | all\u2081 \u03c6 t     : HilbertProof\u1d62 \u039b <| \u2200' \u03c6 \u279d \u03c6/[t]\n  | all\u2082 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u2200' (\u03c6/[] \u279d \u03c8) \u279d \u03c6 \u279d \u2200' \u03c8\n  | ex\u2081 t \u03c6      : HilbertProof\u1d62 \u039b <| \u03c6/[t] \u279d \u2203' \u03c6\n  | ex\u2082 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u2200' (\u03c6 \u279d \u03c8/[]) \u279d \u2203' \u03c6 \u279d \u03c8\n\ninstance : System (SyntacticFormula\u1d62 L) (Hilbert\u1d62 L) := \u27e8HilbertProof\u1d62\u27e9\n\nnamespace HilbertProof\u1d62\n\nopen System.FiniteContext Rewriting LawfulSyntacticRewriting\n\nvariable (\u039b : Hilbert\u1d62 L)\n\ninstance : System.ModusPonens \u039b := \u27e8mdp\u27e9\n\ninstance : System.HasAxiomAndInst \u039b := \u27e8and\u2083\u27e9\n\ninstance : System.HasAxiomImply\u2081 \u039b := \u27e8imply\u2081\u27e9\n\ninstance : System.HasAxiomImply\u2082 \u039b := \u27e8imply\u2082\u27e9\n\ninstance : System.Minimal \u039b where\n  mdp := mdp\n  verum := verum\n  imply\u2081 := imply\u2081\n  imply\u2082 := imply\u2082\n  and\u2081 := and\u2081\n  and\u2082 := and\u2082\n  and\u2083 := and\u2083\n  or\u2081 := or\u2081\n  or\u2082 := or\u2082\n  or\u2083 := or\u2083\n  neg_equiv _ := System.iffId _\n\nvariable {\u039b}\n\nprotected def cast {\u03c6 \u03c8} (b : \u039b \u22a2 \u03c6) (e : \u03c6 = \u03c8) : \u039b \u22a2 \u03c8 := e \u25b8 b\n\ndef depth {\u03c6} : \u039b \u22a2 \u03c6 \u2192 \u2115\n  | mdp b d => max (depth b) (depth d) + 1\n  | gen b   => depth b + 1\n  | _       => 0\n\nscoped notation \"\u2016\" d \"\u2016\" => depth d\n\n@[simp] lemma depth_eaxm (h : \u03c6 \u2208 \u039b) : \u2016eaxm h\u2016 = 0 := rfl\n@[simp] lemma depth_mdp (b : \u039b \u22a2 \u03c6 \u279d \u03c8) (d : \u039b \u22a2 \u03c6) : \u2016mdp b d\u2016 = max \u2016b\u2016 \u2016d\u2016 + 1 := rfl\n@[simp] lemma depth_gen (b : \u039b \u22a2 Rewriting.free \u03c6) : \u2016gen b\u2016 = \u2016b\u2016 + 1 := rfl\n@[simp] lemma depth_verum : \u2016(verum : \u039b \u22a2 \u22a4)\u2016 = 0 := rfl\n@[simp] lemma depth_imply\u2081 (\u03c6 \u03c8) : \u2016imply\u2081 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_imply\u2082 (\u03c6 \u03c8 \u03c7) : \u2016imply\u2082 (\u039b := \u039b) \u03c6 \u03c8 \u03c7\u2016 = 0 := rfl\n@[simp] lemma depth_and\u2081 (\u03c6 \u03c8) : \u2016and\u2081 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_and\u2082 (\u03c6 \u03c8) : \u2016and\u2082 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_and\u2083 (\u03c6 \u03c8) : \u2016and\u2083 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n", "theoremStatement": "@[simp] lemma depth_or\u2081 (\u03c6 \u03c8) : \u2016or\u2081 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 ", "theoremName": "LO.FirstOrder.HilbertProof\u1d62.depth_or\u2081", "fileCreated": {"commit": "7d9e3859942c3a17a697b129e7fb3869eca0066e", "date": "2024-11-09"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/IntFO/Basic/Deduction.lean", "module": "Foundation.IntFO.Basic.Deduction", "jsonFile": "Foundation.IntFO.Basic.Deduction.jsonl", "positionMetadata": {"lineInFile": 109, "tokenPositionInFile": 3604, "theoremPositionInFile": 20}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 10, "numPremises": 15}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "import Foundation.IntFO.Basic\n\nnamespace LO.FirstOrder\n\nnamespace Sequent\n\ninstance : Tilde (List (Semiformula L \u03be n)) := \u27e8fun \u0393 \u21a6 \u0393.map (\u223c\u00b7)\u27e9\n\n@[simp] lemma neg_def (\u0393 : List (Semiformula L \u03be n)) : \u223c\u0393 = \u0393.map (\u223c\u00b7) := rfl\n\n@[simp] lemma neg_nil : \u223c([] : List (Semiformula L \u03be n)) = [] := rfl\n\n@[simp] lemma neg_cons (\u0393 : List (Semiformula L \u03be n)) (\u03c6) : \u223c(\u03c6 :: \u0393) = \u223c\u03c6 :: \u223c\u0393 := rfl\n\n@[simp] lemma neg_neg_eq (\u0393 : List (Semiformula L \u03be n)) : \u223c\u223c\u0393 = \u0393 := by simp [Function.comp_def]\n\nend Sequent\n\nnamespace Semiformula\n\ndef doubleNegation {n} : Semiformula L \u03be n \u2192 Semiformula\u1d62 L \u03be n\n  | rel r v  => \u223c\u223c(.rel r v)\n  | nrel r v => \u223c(.rel r v)\n  | \u22a4        => \u223c\u22a5\n  | \u22a5        => \u22a5\n  | \u03c6 \u22cf \u03c8    => \u03c6.doubleNegation \u22cf \u03c8.doubleNegation\n  | \u03c6 \u22ce \u03c8    => \u223c(\u223c\u03c6.doubleNegation \u22cf \u223c\u03c8.doubleNegation)\n  | \u2200' \u03c6     => \u2200' \u03c6.doubleNegation\n  | \u2203' \u03c6     => \u223c(\u2200' \u223c\u03c6.doubleNegation)\n\nscoped[LO.FirstOrder] postfix:max \"\u1d3a\" => Semiformula.doubleNegation\n\n@[simp] lemma doubleNegation_rel {k} (r : L.Rel k) (v : Fin k \u2192 Semiterm L \u03be n) : (rel r v)\u1d3a = \u223c\u223c(.rel r v) := rfl\n\n@[simp] lemma doubleNegation_nrel {k} (r : L.Rel k) (v : Fin k \u2192 Semiterm L \u03be n) : (nrel r v)\u1d3a = \u223c(.rel r v) := rfl\n\n@[simp] lemma doubleNegation_verum : (\u22a4 : Semiformula L \u03be n)\u1d3a = \u223c\u22a5 := rfl\n\n@[simp] lemma doubleNegation_falsum : (\u22a5 : Semiformula L \u03be n)\u1d3a = \u22a5 := rfl\n\n@[simp] lemma doubleNegation_and (\u03c6 \u03c8 : Semiformula L \u03be n) : (\u03c6 \u22cf \u03c8)\u1d3a = \u03c6\u1d3a \u22cf \u03c8\u1d3a := rfl\n\n@[simp] lemma doubleNegation_or (\u03c6 \u03c8 : Semiformula L \u03be n) : (\u03c6 \u22ce \u03c8)\u1d3a = \u223c(\u223c\u03c6\u1d3a \u22cf \u223c\u03c8\u1d3a) := rfl\n\n@[simp] lemma doubleNegation_all (\u03c6 : Semiformula L \u03be (n + 1)) : (\u2200' \u03c6)\u1d3a = \u2200' \u03c6\u1d3a := rfl\n\n@[simp] lemma doubleNegation_ex (\u03c6 : Semiformula L \u03be (n + 1)) : (\u2203' \u03c6)\u1d3a = \u223c(\u2200' \u223c\u03c6\u1d3a) := rfl\n\n@[simp] lemma doubleNegation_isNegative (\u03c6 : Semiformula L \u03be n) : \u03c6\u1d3a.IsNegative := by\n  induction \u03c6 using rec' <;> simp [*]\n\nlemma rew_doubleNegation (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) (\u03c6 : Semiformula L \u03be\u2081 n\u2081) : \u03c9 \u25b9 \u03c6\u1d3a = (\u03c9 \u25b9 \u03c6)\u1d3a := by\n  induction \u03c6 using rec' generalizing n\u2082 <;> simp [rew_rel, rew_nrel, Semiformula\u1d62.rew_rel, *]\n\n", "theoremStatement": "lemma substitute_doubleNegation (\u03c6 : Semiformula L \u03be n\u2081) (v : Fin n\u2081 \u2192 Semiterm L \u03be n\u2082) : \u03c6\u1d3a \u21dc v = (\u03c6 \u21dc v)\u1d3a ", "theoremName": "LO.FirstOrder.Semiformula.substitute_doubleNegation", "fileCreated": {"commit": "7d9e3859942c3a17a697b129e7fb3869eca0066e", "date": "2024-11-09"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/IntFO/Translation.lean", "module": "Foundation.IntFO.Translation", "jsonFile": "Foundation.IntFO.Translation.jsonl", "positionMetadata": {"lineInFile": 55, "tokenPositionInFile": 1995, "theoremPositionInFile": 15}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 15, "numPremises": 18}, "proofMetadata": {"hasProof": true, "proof": ":= rew_doubleNegation _ _", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 25}}
{"srcContext": "import Foundation.Modal.Kripke.Geach.Systems\n\nnamespace LO.Modal.Hilbert\n\nopen System\nopen Modal.Kripke\nopen Formula\nopen Formula.Kripke\n\n", "theoremStatement": "lemma K45_weakerThan_KB4 : (Hilbert.K45 \u2115) \u2264\u209b (Hilbert.KB4 \u2115) ", "theoremName": "LO.Modal.Hilbert.K45_weakerThan_KB4", "fileCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "theoremCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "file": "foundation/Foundation/Modal/Hilbert/WeakerThan/K45_KB4.lean", "module": "Foundation.Modal.Hilbert.WeakerThan.K45_KB4", "jsonFile": "Foundation.Modal.Hilbert.WeakerThan.K45_KB4.jsonl", "positionMetadata": {"lineInFile": 10, "tokenPositionInFile": 138, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 22, "numPremises": 32}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  apply Kripke.weakerThan_of_subset_FrameClass TransitiveEuclideanFrameClass SymmetricTransitiveFrameClass;\n  rintro F \u27e8h_symm, h_trans\u27e9;\n  refine \u27e8h_trans, (eucl_of_symm_trans h_symm h_trans)\u27e9;", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 200}}
{"srcContext": "import Foundation.Modal.Kripke.Geach.Systems\n\nnamespace LO.Modal.Hilbert\n\nopen System\nopen Modal.Kripke\nopen Formula\nopen Formula.Kripke\n\nlemma KD5_weakerThan_KD45 : (Hilbert.KD5 \u03b1) \u2264\u209b (Hilbert.KD45 \u03b1) := normal_weakerThan_of_subset $ by intro; aesop;\n\n", "theoremStatement": "theorem KD5_strictlyWeakerThan_KD45 : (Hilbert.KD5 \u2115) <\u209b (Hilbert.KD45 \u2115) ", "theoremName": "LO.Modal.Hilbert.KD5_strictlyWeakerThan_KD45", "fileCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "theoremCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "file": "foundation/Foundation/Modal/Hilbert/WeakerThan/KD5_KD45.lean", "module": "Foundation.Modal.Hilbert.WeakerThan.KD5_KD45", "jsonFile": "Foundation.Modal.Hilbert.WeakerThan.KD5_KD45.jsonl", "positionMetadata": {"lineInFile": 12, "tokenPositionInFile": 253, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 61, "numPremises": 159}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  constructor;\n  . exact KD5_weakerThan_KD45;\n  . apply weakerThan_iff.not.mpr;\n    push_neg;\n    use (\u25a1(atom 0) \u279d \u25a1\u25a1(atom 0));\n    constructor;\n    . exact Deduction.maxm! $ by simp;\n    . apply KD5.Kripke.sound.not_provable_of_countermodel;\n      suffices \u2203 F : Frame, Serial F.Rel \u2227 Euclidean F.Rel \u2227 \u2203 V : Valuation F, \u2203 w : F.World, \u00ac(Kripke.Satisfies \u27e8F, V\u27e9 w _) by\n        simp [ValidOnModel, ValidOnFrame, Satisfies];\n        tauto;\n      let F : Frame := \u27e8\n        Fin 3,\n        \u03bb x y =>\n          match x, y with\n          | 0, 1 => True\n          | 1, 1 => True\n          | 1, 2 => True\n          | 2, 1 => True\n          | 2, 2 => True\n          | _, _ => False\n      \u27e9;\n      use F;\n      refine \u27e8?_, ?_, ?_\u27e9;\n      . intro x;\n        match x with\n        | 0 => use 1; tauto;\n        | 1 => use 2; tauto;\n        | 2 => use 1; tauto;\n      . unfold Euclidean; aesop;\n      . use (\u03bb w _ => w = 1), 0;\n        suffices (\u2200 (y : F.World), (0 : F.World) \u227a y \u2192 y = 1) \u2227 \u2203 x, (0 : F.World) \u227a x \u2227 \u2203 y, x \u227a y \u2227 y \u2260 1 by\n          simpa [Semantics.Realize, Satisfies];\n        constructor;\n        . intro y;\n          match y with\n          | 0 => tauto;\n          | 1 => tauto;\n          | 2 => tauto;\n        . use 1;\n          constructor;\n          . tauto;\n          . use 2;\n            constructor;\n            . tauto;\n            . aesop;", "proofType": "tactic", "proofLengthLines": 46, "proofLengthTokens": 1359}}
{"srcContext": "import Foundation.IntFO.Basic.Rew\n\nnamespace LO.FirstOrder\n\nabbrev Sequent\u1d62 (L : Language) := List (SyntacticFormula\u1d62 L)\n\nopen Semiformula\u1d62\n\nvariable {L : Language} {T : Theory L}\n\nstructure Hilbert\u1d62 (L : Language) where\n  axiomSet : Set (SyntacticFormula\u1d62 L)\n  rewrite_closed {\u03c6 : SyntacticFormula\u1d62 L} : \u03c6 \u2208 axiomSet \u2192 \u2200 f : \u2115 \u2192 SyntacticTerm L, Rew.rewrite f \u25b9 \u03c6 \u2208 axiomSet\n\ninstance : SetLike (Hilbert\u1d62 L) (SyntacticFormula\u1d62 L) where\n  coe := Hilbert\u1d62.axiomSet\n  coe_injective' := by rintro \u27e8T, _\u27e9 \u27e8U, _\u27e9; simp\n\nnamespace Hilbert\u1d62\n\ndef Minimal : Hilbert\u1d62 L := \u27e8\u2205, by simp\u27e9\n\nnotation \"\ud835\udc0c\ud835\udc22\ud835\udc27\u00b9\" => Minimal\n\ndef Intuitionistic : Hilbert\u1d62 L := \u27e8{\u22a5 \u279d \u03c6 | \u03c6}, by rintro _ \u27e8\u03c6, rfl\u27e9 f; exact \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\u27e9\n\nnotation \"\ud835\udc08\ud835\udc27\ud835\udc2d\u00b9\" => Intuitionistic\n\ndef Classical : Hilbert\u1d62 L := \u27e8{\u22a5 \u279d \u03c6 | \u03c6} \u222a {\u03c6 \u22ce \u223c\u03c6 | \u03c6}, by\n  rintro _ (\u27e8\u03c6, rfl\u27e9 | \u27e8\u03c6, rfl\u27e9) f\n  \u00b7 exact Or.inl \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\n  \u00b7 exact Or.inr \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\u27e9\n\nnotation \"\ud835\udc02\ud835\udc25\u00b9\" => Classical\n\nlemma minimal_le (\u039b : Hilbert\u1d62 L) : (Minimal : Hilbert\u1d62 L) \u2264 \u039b := by rintro _ \u27e8\u27e9\n\nlemma intuitionistic_le_classical : (Intuitionistic : Hilbert\u1d62 L) \u2264 Classical := by rintro _ \u27e8\u03c6, rfl\u27e9; exact .inl \u27e8\u03c6, rfl\u27e9\n\nend Hilbert\u1d62\n\ninductive HilbertProof\u1d62 (\u039b : Hilbert\u1d62 L) : SyntacticFormula\u1d62 L \u2192 Type _\n  | eaxm {\u03c6}     : \u03c6 \u2208 \u039b \u2192 HilbertProof\u1d62 \u039b \u03c6\n  | mdp {\u03c6 \u03c8}    : HilbertProof\u1d62 \u039b (\u03c6 \u279d \u03c8) \u2192 HilbertProof\u1d62 \u039b \u03c6 \u2192 HilbertProof\u1d62 \u039b \u03c8\n  | gen {\u03c6}      : HilbertProof\u1d62 \u039b (Rewriting.free \u03c6) \u2192 HilbertProof\u1d62 \u039b (\u2200' \u03c6)\n  | verum        : HilbertProof\u1d62 \u039b \u22a4\n  | imply\u2081 \u03c6 \u03c8   : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c8 \u279d \u03c6\n  | imply\u2082 \u03c6 \u03c8 \u03c7 : HilbertProof\u1d62 \u039b <| (\u03c6 \u279d \u03c8 \u279d \u03c7) \u279d (\u03c6 \u279d \u03c8) \u279d \u03c6 \u279d \u03c7\n  | and\u2081 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u22cf \u03c8 \u279d \u03c6\n  | and\u2082 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u22cf \u03c8 \u279d \u03c8\n  | and\u2083 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c8 \u279d \u03c6 \u22cf \u03c8\n  | or\u2081 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c6 \u22ce \u03c8\n  | or\u2082 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u03c8 \u279d \u03c6 \u22ce \u03c8\n  | or\u2083 \u03c6 \u03c8 \u03c7    : HilbertProof\u1d62 \u039b <| (\u03c6 \u279d \u03c7) \u279d (\u03c8 \u279d \u03c7) \u279d (\u03c6 \u22ce \u03c8 \u279d \u03c7)\n  | all\u2081 \u03c6 t     : HilbertProof\u1d62 \u039b <| \u2200' \u03c6 \u279d \u03c6/[t]\n  | all\u2082 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u2200' (\u03c6/[] \u279d \u03c8) \u279d \u03c6 \u279d \u2200' \u03c8\n  | ex\u2081 t \u03c6      : HilbertProof\u1d62 \u039b <| \u03c6/[t] \u279d \u2203' \u03c6\n  | ex\u2082 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u2200' (\u03c6 \u279d \u03c8/[]) \u279d \u2203' \u03c6 \u279d \u03c8\n\ninstance : System (SyntacticFormula\u1d62 L) (Hilbert\u1d62 L) := \u27e8HilbertProof\u1d62\u27e9\n\nnamespace HilbertProof\u1d62\n\nopen System.FiniteContext Rewriting LawfulSyntacticRewriting\n\nvariable (\u039b : Hilbert\u1d62 L)\n\ninstance : System.ModusPonens \u039b := \u27e8mdp\u27e9\n\ninstance : System.HasAxiomAndInst \u039b := \u27e8and\u2083\u27e9\n\ninstance : System.HasAxiomImply\u2081 \u039b := \u27e8imply\u2081\u27e9\n\ninstance : System.HasAxiomImply\u2082 \u039b := \u27e8imply\u2082\u27e9\n\ninstance : System.Minimal \u039b where\n  mdp := mdp\n  verum := verum\n  imply\u2081 := imply\u2081\n  imply\u2082 := imply\u2082\n  and\u2081 := and\u2081\n  and\u2082 := and\u2082\n  and\u2083 := and\u2083\n  or\u2081 := or\u2081\n  or\u2082 := or\u2082\n  or\u2083 := or\u2083\n  neg_equiv _ := System.iffId _\n\nvariable {\u039b}\n\nprotected def cast {\u03c6 \u03c8} (b : \u039b \u22a2 \u03c6) (e : \u03c6 = \u03c8) : \u039b \u22a2 \u03c8 := e \u25b8 b\n\ndef depth {\u03c6} : \u039b \u22a2 \u03c6 \u2192 \u2115\n  | mdp b d => max (depth b) (depth d) + 1\n  | gen b   => depth b + 1\n  | _       => 0\n\nscoped notation \"\u2016\" d \"\u2016\" => depth d\n\n@[simp] lemma depth_eaxm (h : \u03c6 \u2208 \u039b) : \u2016eaxm h\u2016 = 0 := rfl\n@[simp] lemma depth_mdp (b : \u039b \u22a2 \u03c6 \u279d \u03c8) (d : \u039b \u22a2 \u03c6) : \u2016mdp b d\u2016 = max \u2016b\u2016 \u2016d\u2016 + 1 := rfl\n@[simp] lemma depth_gen (b : \u039b \u22a2 Rewriting.free \u03c6) : \u2016gen b\u2016 = \u2016b\u2016 + 1 := rfl\n@[simp] lemma depth_verum : \u2016(verum : \u039b \u22a2 \u22a4)\u2016 = 0 := rfl\n@[simp] lemma depth_imply\u2081 (\u03c6 \u03c8) : \u2016imply\u2081 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_imply\u2082 (\u03c6 \u03c8 \u03c7) : \u2016imply\u2082 (\u039b := \u039b) \u03c6 \u03c8 \u03c7\u2016 = 0 := rfl\n@[simp] lemma depth_and\u2081 (\u03c6 \u03c8) : \u2016and\u2081 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_and\u2082 (\u03c6 \u03c8) : \u2016and\u2082 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_and\u2083 (\u03c6 \u03c8) : \u2016and\u2083 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_or\u2081 (\u03c6 \u03c8) : \u2016or\u2081 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_or\u2082 (\u03c6 \u03c8) : \u2016or\u2082 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_or\u2083 (\u03c6 \u03c8 \u03c7) : \u2016or\u2083 (\u039b := \u039b) \u03c6 \u03c8 \u03c7\u2016 = 0 := rfl\n@[simp] lemma depth_all\u2081 (\u03c6 t) : \u2016all\u2081 (\u039b := \u039b) \u03c6 t\u2016 = 0 := rfl\n@[simp] lemma depth_all\u2082 (\u03c6 \u03c8) : \u2016all\u2082 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_ex\u2081 (t \u03c6) : \u2016ex\u2081 (\u039b := \u039b) t \u03c6\u2016 = 0 := rfl\n", "theoremStatement": "@[simp] lemma depth_ex\u2082 (\u03c6 \u03c8) : \u2016ex\u2082 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 ", "theoremName": "LO.FirstOrder.HilbertProof\u1d62.depth_ex\u2082", "fileCreated": {"commit": "7d9e3859942c3a17a697b129e7fb3869eca0066e", "date": "2024-11-09"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/IntFO/Basic/Deduction.lean", "module": "Foundation.IntFO.Basic.Deduction", "jsonFile": "Foundation.IntFO.Basic.Deduction.jsonl", "positionMetadata": {"lineInFile": 115, "tokenPositionInFile": 3984, "theoremPositionInFile": 26}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 18, "numPremises": 27}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "import Foundation.IntFO.Basic.Rew\n\nnamespace LO.FirstOrder\n\nabbrev Sequent\u1d62 (L : Language) := List (SyntacticFormula\u1d62 L)\n\nopen Semiformula\u1d62\n\nvariable {L : Language} {T : Theory L}\n\nstructure Hilbert\u1d62 (L : Language) where\n  axiomSet : Set (SyntacticFormula\u1d62 L)\n  rewrite_closed {\u03c6 : SyntacticFormula\u1d62 L} : \u03c6 \u2208 axiomSet \u2192 \u2200 f : \u2115 \u2192 SyntacticTerm L, Rew.rewrite f \u25b9 \u03c6 \u2208 axiomSet\n\ninstance : SetLike (Hilbert\u1d62 L) (SyntacticFormula\u1d62 L) where\n  coe := Hilbert\u1d62.axiomSet\n  coe_injective' := by rintro \u27e8T, _\u27e9 \u27e8U, _\u27e9; simp\n\nnamespace Hilbert\u1d62\n\ndef Minimal : Hilbert\u1d62 L := \u27e8\u2205, by simp\u27e9\n\nnotation \"\ud835\udc0c\ud835\udc22\ud835\udc27\u00b9\" => Minimal\n\ndef Intuitionistic : Hilbert\u1d62 L := \u27e8{\u22a5 \u279d \u03c6 | \u03c6}, by rintro _ \u27e8\u03c6, rfl\u27e9 f; exact \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\u27e9\n\nnotation \"\ud835\udc08\ud835\udc27\ud835\udc2d\u00b9\" => Intuitionistic\n\ndef Classical : Hilbert\u1d62 L := \u27e8{\u22a5 \u279d \u03c6 | \u03c6} \u222a {\u03c6 \u22ce \u223c\u03c6 | \u03c6}, by\n  rintro _ (\u27e8\u03c6, rfl\u27e9 | \u27e8\u03c6, rfl\u27e9) f\n  \u00b7 exact Or.inl \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\n  \u00b7 exact Or.inr \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\u27e9\n\nnotation \"\ud835\udc02\ud835\udc25\u00b9\" => Classical\n\nlemma minimal_le (\u039b : Hilbert\u1d62 L) : (Minimal : Hilbert\u1d62 L) \u2264 \u039b := by rintro _ \u27e8\u27e9\n\nlemma intuitionistic_le_classical : (Intuitionistic : Hilbert\u1d62 L) \u2264 Classical := by rintro _ \u27e8\u03c6, rfl\u27e9; exact .inl \u27e8\u03c6, rfl\u27e9\n\nend Hilbert\u1d62\n\ninductive HilbertProof\u1d62 (\u039b : Hilbert\u1d62 L) : SyntacticFormula\u1d62 L \u2192 Type _\n  | eaxm {\u03c6}     : \u03c6 \u2208 \u039b \u2192 HilbertProof\u1d62 \u039b \u03c6\n  | mdp {\u03c6 \u03c8}    : HilbertProof\u1d62 \u039b (\u03c6 \u279d \u03c8) \u2192 HilbertProof\u1d62 \u039b \u03c6 \u2192 HilbertProof\u1d62 \u039b \u03c8\n  | gen {\u03c6}      : HilbertProof\u1d62 \u039b (Rewriting.free \u03c6) \u2192 HilbertProof\u1d62 \u039b (\u2200' \u03c6)\n  | verum        : HilbertProof\u1d62 \u039b \u22a4\n  | imply\u2081 \u03c6 \u03c8   : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c8 \u279d \u03c6\n  | imply\u2082 \u03c6 \u03c8 \u03c7 : HilbertProof\u1d62 \u039b <| (\u03c6 \u279d \u03c8 \u279d \u03c7) \u279d (\u03c6 \u279d \u03c8) \u279d \u03c6 \u279d \u03c7\n  | and\u2081 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u22cf \u03c8 \u279d \u03c6\n  | and\u2082 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u22cf \u03c8 \u279d \u03c8\n  | and\u2083 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c8 \u279d \u03c6 \u22cf \u03c8\n  | or\u2081 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c6 \u22ce \u03c8\n  | or\u2082 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u03c8 \u279d \u03c6 \u22ce \u03c8\n  | or\u2083 \u03c6 \u03c8 \u03c7    : HilbertProof\u1d62 \u039b <| (\u03c6 \u279d \u03c7) \u279d (\u03c8 \u279d \u03c7) \u279d (\u03c6 \u22ce \u03c8 \u279d \u03c7)\n  | all\u2081 \u03c6 t     : HilbertProof\u1d62 \u039b <| \u2200' \u03c6 \u279d \u03c6/[t]\n  | all\u2082 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u2200' (\u03c6/[] \u279d \u03c8) \u279d \u03c6 \u279d \u2200' \u03c8\n  | ex\u2081 t \u03c6      : HilbertProof\u1d62 \u039b <| \u03c6/[t] \u279d \u2203' \u03c6\n  | ex\u2082 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u2200' (\u03c6 \u279d \u03c8/[]) \u279d \u2203' \u03c6 \u279d \u03c8\n\ninstance : System (SyntacticFormula\u1d62 L) (Hilbert\u1d62 L) := \u27e8HilbertProof\u1d62\u27e9\n\nnamespace HilbertProof\u1d62\n\nopen System.FiniteContext Rewriting LawfulSyntacticRewriting\n\nvariable (\u039b : Hilbert\u1d62 L)\n\ninstance : System.ModusPonens \u039b := \u27e8mdp\u27e9\n\ninstance : System.HasAxiomAndInst \u039b := \u27e8and\u2083\u27e9\n\ninstance : System.HasAxiomImply\u2081 \u039b := \u27e8imply\u2081\u27e9\n\ninstance : System.HasAxiomImply\u2082 \u039b := \u27e8imply\u2082\u27e9\n\ninstance : System.Minimal \u039b where\n  mdp := mdp\n  verum := verum\n  imply\u2081 := imply\u2081\n  imply\u2082 := imply\u2082\n  and\u2081 := and\u2081\n  and\u2082 := and\u2082\n  and\u2083 := and\u2083\n  or\u2081 := or\u2081\n  or\u2082 := or\u2082\n  or\u2083 := or\u2083\n  neg_equiv _ := System.iffId _\n\nvariable {\u039b}\n\nprotected def cast {\u03c6 \u03c8} (b : \u039b \u22a2 \u03c6) (e : \u03c6 = \u03c8) : \u039b \u22a2 \u03c8 := e \u25b8 b\n\ndef depth {\u03c6} : \u039b \u22a2 \u03c6 \u2192 \u2115\n  | mdp b d => max (depth b) (depth d) + 1\n  | gen b   => depth b + 1\n  | _       => 0\n\nscoped notation \"\u2016\" d \"\u2016\" => depth d\n\n@[simp] lemma depth_eaxm (h : \u03c6 \u2208 \u039b) : \u2016eaxm h\u2016 = 0 := rfl\n@[simp] lemma depth_mdp (b : \u039b \u22a2 \u03c6 \u279d \u03c8) (d : \u039b \u22a2 \u03c6) : \u2016mdp b d\u2016 = max \u2016b\u2016 \u2016d\u2016 + 1 := rfl\n@[simp] lemma depth_gen (b : \u039b \u22a2 Rewriting.free \u03c6) : \u2016gen b\u2016 = \u2016b\u2016 + 1 := rfl\n@[simp] lemma depth_verum : \u2016(verum : \u039b \u22a2 \u22a4)\u2016 = 0 := rfl\n@[simp] lemma depth_imply\u2081 (\u03c6 \u03c8) : \u2016imply\u2081 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_imply\u2082 (\u03c6 \u03c8 \u03c7) : \u2016imply\u2082 (\u039b := \u039b) \u03c6 \u03c8 \u03c7\u2016 = 0 := rfl\n@[simp] lemma depth_and\u2081 (\u03c6 \u03c8) : \u2016and\u2081 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_and\u2082 (\u03c6 \u03c8) : \u2016and\u2082 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_and\u2083 (\u03c6 \u03c8) : \u2016and\u2083 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_or\u2081 (\u03c6 \u03c8) : \u2016or\u2081 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_or\u2082 (\u03c6 \u03c8) : \u2016or\u2082 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_or\u2083 (\u03c6 \u03c8 \u03c7) : \u2016or\u2083 (\u039b := \u039b) \u03c6 \u03c8 \u03c7\u2016 = 0 := rfl\n@[simp] lemma depth_all\u2081 (\u03c6 t) : \u2016all\u2081 (\u039b := \u039b) \u03c6 t\u2016 = 0 := rfl\n", "theoremStatement": "@[simp] lemma depth_all\u2082 (\u03c6 \u03c8) : \u2016all\u2082 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 ", "theoremName": "LO.FirstOrder.HilbertProof\u1d62.depth_all\u2082", "fileCreated": {"commit": "7d9e3859942c3a17a697b129e7fb3869eca0066e", "date": "2024-11-09"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/IntFO/Basic/Deduction.lean", "module": "Foundation.IntFO.Basic.Deduction", "jsonFile": "Foundation.IntFO.Basic.Deduction.jsonl", "positionMetadata": {"lineInFile": 113, "tokenPositionInFile": 3858, "theoremPositionInFile": 24}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 16, "numPremises": 25}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "import Foundation.IntFO.Translation\n\n/-!\n#Algebraic Proofs of Cut Elimination\n\nMain reference: Jeremy Avigad, Algebraic proofs of cut elimination, The Journal of Logic and Algebraic Programming, Volume 49, Issues 1\u20132, 2001, Pages 15-30\n -/\n\nnamespace LO.FirstOrder\n\nvariable {L : Language.{u}}\n\nnamespace Derivation\n\ninductive IsCutFree : {\u0393 : Sequent L} \u2192 \u22a2\u1d40 \u0393 \u2192 Prop\n| axL (\u0393) {k} (r : L.Rel k) (v)                 : IsCutFree (axL \u0393 r v)\n| verum (\u0393)                                     : IsCutFree (verum \u0393)\n| or {\u0393 \u03c6 \u03c8} {d : \u22a2\u1d40 \u03c6 :: \u03c8 :: \u0393}               : IsCutFree d \u2192 IsCutFree d.or\n| and {\u0393 \u03c6 \u03c8} {d\u03c6 : \u22a2\u1d40 \u03c6 :: \u0393} {d\u03c8 : \u22a2\u1d40 \u03c8 :: \u0393} : IsCutFree d\u03c6 \u2192 IsCutFree d\u03c8 \u2192 IsCutFree (d\u03c6.and d\u03c8)\n| all {\u0393 \u03c6} {d : \u22a2\u1d40 Rewriting.free \u03c6 :: \u0393\u207a}     : IsCutFree d \u2192 IsCutFree d.all\n| ex {\u0393 \u03c6} (t) {d : \u22a2\u1d40 \u03c6/[t] :: \u0393}              : IsCutFree d \u2192 IsCutFree d.ex\n| wk {\u0394 \u0393} {d : \u22a2\u1d40 \u0394} (ss : \u0394 \u2286 \u0393)              : IsCutFree d \u2192 IsCutFree (d.wk ss)\n\nattribute [simp] IsCutFree.axL IsCutFree.verum\n\nvariable {\u0393 \u0394 : Sequent L}\n\n@[simp] lemma isCutFree_or_iff {d : \u22a2\u1d40 \u03c6 :: \u03c8 :: \u0393} :\n    IsCutFree d.or \u2194 IsCutFree d := \u27e8by rintro \u27e8\u27e9; assumption, .or\u27e9\n\n", "theoremStatement": "@[simp] lemma isCutFree_and_iff {d\u03c6 : \u22a2\u1d40 \u03c6 :: \u0393} {d\u03c8 : \u22a2\u1d40 \u03c8 :: \u0393} :\n    IsCutFree (d\u03c6.and d\u03c8) \u2194 IsCutFree d\u03c6 \u2227 IsCutFree d\u03c8 ", "theoremName": "LO.FirstOrder.Derivation.isCutFree_and_iff", "fileCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/FirstOrder/Hauptsatz.lean", "module": "Foundation.FirstOrder.Hauptsatz", "jsonFile": "Foundation.FirstOrder.Hauptsatz.jsonl", "positionMetadata": {"lineInFile": 31, "tokenPositionInFile": 1135, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 8, "repositoryPremises": true, "numRepositoryPremises": 48, "numPremises": 80}, "proofMetadata": {"hasProof": true, "proof": ":=\n  \u27e8by rintro \u27e8\u27e9; constructor <;> assumption, by intro \u27e8h\u03c6, h\u03c8\u27e9; exact h\u03c6.and h\u03c8\u27e9", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 83}}
{"srcContext": "import Foundation.Logic.System\nimport Foundation.Logic.HilbertStyle.Context\n\nnamespace LO.System\n\nvariable {F : Type*} [LogicalConnective F] [DecidableEq F]\n         {S : Type*} [System F S]\n         {\ud835\udce2 : S} [System.Minimal \ud835\udce2]\n         {\u03c6 \u03c8 \u03c7 : F}\n         {\u0393 \u0394 : List F}\n\nopen NegationEquiv\nopen FiniteContext\nopen List\n\ndef mdp_in : \ud835\udce2 \u22a2 \u03c6 \u22cf (\u03c6 \u279d \u03c8) \u279d \u03c8 := by\n  apply deduct';\n  have hp  : [\u03c6, \u03c6 \u279d \u03c8] \u22a2[\ud835\udce2] \u03c6 := FiniteContext.byAxm;\n  have hpq : [\u03c6, \u03c6 \u279d \u03c8] \u22a2[\ud835\udce2] \u03c6 \u279d \u03c8 := FiniteContext.byAxm;\n  exact hpq \u2a00 hp;\nlemma mdp_in! : \ud835\udce2 \u22a2! \u03c6 \u22cf (\u03c6 \u279d \u03c8) \u279d \u03c8 := \u27e8mdp_in\u27e9\n\ndef bot_of_mem_either (h\u2081 : \u03c6 \u2208 \u0393) (h\u2082 : \u223c\u03c6 \u2208 \u0393) : \u0393 \u22a2[\ud835\udce2] \u22a5 := by\n  have hp : \u0393 \u22a2[\ud835\udce2] \u03c6 := FiniteContext.byAxm h\u2081;\n  have hnp : \u0393 \u22a2[\ud835\udce2] \u03c6 \u279d \u22a5 := neg_equiv'.mp $ FiniteContext.byAxm h\u2082;\n  exact hnp \u2a00 hp\n\n@[simp] lemma bot_of_mem_either! (h\u2081 : \u03c6 \u2208 \u0393) (h\u2082 : \u223c\u03c6 \u2208 \u0393) : \u0393 \u22a2[\ud835\udce2]! \u22a5 := \u27e8bot_of_mem_either h\u2081 h\u2082\u27e9\n\n\ndef efq_of_mem_either [HasAxiomEFQ \ud835\udce2] (h\u2081 : \u03c6 \u2208 \u0393) (h\u2082 : \u223c\u03c6 \u2208 \u0393) : \u0393 \u22a2[\ud835\udce2] \u03c8 := efq' $ bot_of_mem_either h\u2081 h\u2082\n@[simp] lemma efq_of_mem_either! [HasAxiomEFQ \ud835\udce2] (h\u2081 : \u03c6 \u2208 \u0393) (h\u2082 : \u223c\u03c6 \u2208 \u0393) : \u0393 \u22a2[\ud835\udce2]! \u03c8 := \u27e8efq_of_mem_either h\u2081 h\u2082\u27e9\n\ndef efq_imply_not\u2081 [HasAxiomEFQ \ud835\udce2] : \ud835\udce2 \u22a2 \u223c\u03c6 \u279d \u03c6 \u279d \u03c8 := by\n  apply deduct';\n  apply deduct;\n  apply efq_of_mem_either (\u03c6 := \u03c6) (by simp) (by simp);\n@[simp] lemma efq_imply_not\u2081! [HasAxiomEFQ \ud835\udce2] : \ud835\udce2 \u22a2! \u223c\u03c6 \u279d \u03c6 \u279d \u03c8 := \u27e8efq_imply_not\u2081\u27e9\n\ndef efq_imply_not\u2082 [HasAxiomEFQ \ud835\udce2] : \ud835\udce2 \u22a2 \u03c6 \u279d \u223c\u03c6 \u279d \u03c8 := by\n  apply deduct';\n  apply deduct;\n  apply efq_of_mem_either (\u03c6 := \u03c6) (by simp) (by simp);\n@[simp] lemma efq_imply_not\u2082! [HasAxiomEFQ \ud835\udce2] : \ud835\udce2 \u22a2! \u03c6 \u279d \u223c\u03c6 \u279d \u03c8 := \u27e8efq_imply_not\u2082\u27e9\n\nlemma efq_of_neg! [HasAxiomEFQ \ud835\udce2] (h : \ud835\udce2 \u22a2! \u223c\u03c6) : \ud835\udce2 \u22a2! \u03c6 \u279d \u03c8 := by\n  apply provable_iff_provable.mpr;\n  apply deduct_iff.mpr;\n  have dnp : [\u03c6] \u22a2[\ud835\udce2]! \u03c6 \u279d \u22a5 := of'! $ neg_equiv'!.mp h;\n  exact efq'! (dnp \u2a00 FiniteContext.id!);\n\nlemma efq_of_neg\u2082! [HasAxiomEFQ \ud835\udce2] (h : \ud835\udce2 \u22a2! \u03c6) : \ud835\udce2 \u22a2! \u223c\u03c6 \u279d \u03c8 := efq_imply_not\u2082! \u2a00 h\n\ndef neg_mdp (hnp : \ud835\udce2 \u22a2 \u223c\u03c6) (hn : \ud835\udce2 \u22a2 \u03c6) : \ud835\udce2 \u22a2 \u22a5 := (neg_equiv'.mp hnp) \u2a00 hn\n-- infixl:90 \"\u2a00\" => neg_mdp\n\nomit [DecidableEq F] in lemma neg_mdp! (hnp : \ud835\udce2 \u22a2! \u223c\u03c6) (hn : \ud835\udce2 \u22a2! \u03c6) : \ud835\udce2 \u22a2! \u22a5 := \u27e8neg_mdp hnp.some hn.some\u27e9\n-- infixl:90 \"\u2a00\" => neg_mdp!\n\ndef dneOr [HasAxiomDNE \ud835\udce2] (d : \ud835\udce2 \u22a2 \u223c\u223c\u03c6 \u22ce \u223c\u223c\u03c8) : \ud835\udce2 \u22a2 \u03c6 \u22ce \u03c8 := or\u2083''' (impTrans'' dne or\u2081) (impTrans'' dne or\u2082) d\nomit [DecidableEq F] in ", "theoremStatement": "lemma dne_or! [HasAxiomDNE \ud835\udce2] (d : \ud835\udce2 \u22a2! \u223c\u223c\u03c6 \u22ce \u223c\u223c\u03c8) : \ud835\udce2 \u22a2! \u03c6 \u22ce \u03c8 ", "theoremName": "LO.System.dne_or!", "fileCreated": {"commit": "33e08c2b47f966f772df9af60cbdbc5688295bbf", "date": "2024-10-15"}, "theoremCreated": {"commit": "830d76e560f33054a2eb2051cf1fa73997706985", "date": "2025-01-01"}, "file": "foundation/Foundation/Logic/HilbertStyle/Supplemental.lean", "module": "Foundation.Logic.HilbertStyle.Supplemental", "jsonFile": "Foundation.Logic.HilbertStyle.Supplemental.jsonl", "positionMetadata": {"lineInFile": 61, "tokenPositionInFile": 2246, "theoremPositionInFile": 15}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 11, "numPremises": 13}, "proofMetadata": {"hasProof": true, "proof": ":= \u27e8dneOr d.some\u27e9", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 17}}
{"srcContext": "import Foundation.Modal.Hilbert.Maximal.Unprovability\nimport Foundation.Modal.Kripke.GL.MDP\n\nnamespace LO.Modal\n\nopen System\nopen IntProp\n\nvariable [DecidableEq \u03b1]\n\ndef independency (\u03c6 : Formula \u03b1) := \u223c\u25a1\u03c6 \u22cf \u223c\u25a1(\u223c\u03c6)\n\ndef higherIndependency (\u03c6 : Formula \u03b1) : \u2115 \u2192 Formula \u03b1\n  | 0 => \u03c6\n  | n + 1 => independency (higherIndependency \u03c6 n)\n\nnamespace Hilbert.GL\n\nvariable {\u03c6 : Formula \u2115}\n\n", "theoremStatement": "lemma unprovable_notbox : (Hilbert.GL _) \u22ac \u223c\u25a1\u03c6 ", "theoremName": "LO.Modal.Hilbert.GL.unprovable_notbox", "fileCreated": {"commit": "830d76e560f33054a2eb2051cf1fa73997706985", "date": "2025-01-01"}, "theoremCreated": {"commit": "830d76e560f33054a2eb2051cf1fa73997706985", "date": "2025-01-01"}, "file": "foundation/Foundation/Modal/Hilbert/GL_Independency.lean", "module": "Foundation.Modal.Hilbert.GL_Independency", "jsonFile": "Foundation.Modal.Hilbert.GL_Independency.jsonl", "positionMetadata": {"lineInFile": 21, "tokenPositionInFile": 381, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 48, "numPremises": 71}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  by_contra hC;\n  have : (Hilbert.GL _) \u22a2! \u223c\u25a1\u03c6 \u279d \u223c\u25a1\u22a5 := contra\u2080'! (imply_box_distribute'! efq!)\n  have : Hilbert.GL _ \u22a2! \u223c\u25a1\u22a5 := this \u2a00 hC;\n  have : Hilbert.Cl \u2115 \u22a2! (\u22a5 \u279d \u22a5) \u279d \u22a5 := by simpa using provable_CL_verTranslated this;\n  simpa using Hilbert.Cl.classical_sound this;", "proofType": "tactic", "proofLengthLines": 5, "proofLengthTokens": 278}}
