{"srcContext": "import Foundation.IntFO.Translation\n\n/-!\n#Algebraic Proofs of Cut Elimination\n\nMain reference: Jeremy Avigad, Algebraic proofs of cut elimination, The Journal of Logic and Algebraic Programming, Volume 49, Issues 1\u20132, 2001, Pages 15-30\n -/\n\nnamespace LO.FirstOrder\n\nvariable {L : Language.{u}}\n\nnamespace Derivation\n\ninductive IsCutFree : {\u0393 : Sequent L} \u2192 \u22a2\u1d40 \u0393 \u2192 Prop\n| axL (\u0393) {k} (r : L.Rel k) (v)                 : IsCutFree (axL \u0393 r v)\n| verum (\u0393)                                     : IsCutFree (verum \u0393)\n| or {\u0393 \u03c6 \u03c8} {d : \u22a2\u1d40 \u03c6 :: \u03c8 :: \u0393}               : IsCutFree d \u2192 IsCutFree d.or\n| and {\u0393 \u03c6 \u03c8} {d\u03c6 : \u22a2\u1d40 \u03c6 :: \u0393} {d\u03c8 : \u22a2\u1d40 \u03c8 :: \u0393} : IsCutFree d\u03c6 \u2192 IsCutFree d\u03c8 \u2192 IsCutFree (d\u03c6.and d\u03c8)\n| all {\u0393 \u03c6} {d : \u22a2\u1d40 Rewriting.free \u03c6 :: \u0393\u207a}     : IsCutFree d \u2192 IsCutFree d.all\n| ex {\u0393 \u03c6} (t) {d : \u22a2\u1d40 \u03c6/[t] :: \u0393}              : IsCutFree d \u2192 IsCutFree d.ex\n| wk {\u0394 \u0393} {d : \u22a2\u1d40 \u0394} (ss : \u0394 \u2286 \u0393)              : IsCutFree d \u2192 IsCutFree (d.wk ss)\n\nattribute [simp] IsCutFree.axL IsCutFree.verum\n\nvariable {\u0393 \u0394 : Sequent L}\n\n@[simp] lemma isCutFree_or_iff {d : \u22a2\u1d40 \u03c6 :: \u03c8 :: \u0393} :\n    IsCutFree d.or \u2194 IsCutFree d := \u27e8by rintro \u27e8\u27e9; assumption, .or\u27e9\n\n@[simp] lemma isCutFree_and_iff {d\u03c6 : \u22a2\u1d40 \u03c6 :: \u0393} {d\u03c8 : \u22a2\u1d40 \u03c8 :: \u0393} :\n    IsCutFree (d\u03c6.and d\u03c8) \u2194 IsCutFree d\u03c6 \u2227 IsCutFree d\u03c8 :=\n  \u27e8by rintro \u27e8\u27e9; constructor <;> assumption, by intro \u27e8h\u03c6, h\u03c8\u27e9; exact h\u03c6.and h\u03c8\u27e9\n\n@[simp] lemma isCutFree_all_iff {d : \u22a2\u1d40 Rewriting.free \u03c6 :: \u0393\u207a} :\n    IsCutFree d.all \u2194 IsCutFree d := \u27e8by rintro \u27e8\u27e9; assumption, .all\u27e9\n\n@[simp] lemma isCutFree_ex_iff {d : \u22a2\u1d40 \u03c6/[t] :: \u0393} :\n    IsCutFree d.ex \u2194 IsCutFree d := \u27e8by rintro \u27e8\u27e9; assumption, .ex t\u27e9\n\n@[simp] lemma isCutFree_wk_iff {d : \u22a2\u1d40 \u0394} {ss : \u0394 \u2286 \u0393} :\n    IsCutFree (d.wk ss) \u2194 IsCutFree d := \u27e8by rintro \u27e8\u27e9; assumption, .wk _\u27e9\n\n@[simp] lemma IsCutFree.cast {d : \u22a2\u1d40 \u0393} {e : \u0393 = \u0394} :\n    IsCutFree (.cast d e) \u2194 IsCutFree d := by rcases e; rfl\n\n@[simp] lemma IsCutFree.not_cut (dp : \u22a2\u1d40 \u03c6 :: \u0393) (dn : \u22a2\u1d40 \u223c\u03c6 :: \u0393) : \u00acIsCutFree (dp.cut dn) := by rintro \u27e8\u27e9\n\n@[simp] lemma isCutFree_rewrite_iff_isCutFree {f : \u2115 \u2192 SyntacticTerm L} {d : \u22a2\u1d40 \u0393} :\n    IsCutFree (rewrite d f) \u2194 IsCutFree d := by\n  induction d generalizing f <;> simp [rewrite, *]\n  case root => contradiction\n\n@[simp] lemma isCutFree_map_iff_isCutFree {f : \u2115 \u2192 \u2115} {d : \u22a2\u1d40 \u0393} :\n    IsCutFree (Derivation.map d f) \u2194 IsCutFree d := isCutFree_rewrite_iff_isCutFree\n\n", "theoremStatement": "@[simp] lemma IsCutFree.genelalizeByNewver_isCutFree {\u03c6 : SyntacticSemiformula L 1} (hp : \u00ac\u03c6.FVar? m) (h\u0394 : \u2200 \u03c8 \u2208 \u0394, \u00ac\u03c8.FVar? m)\n    (d : \u22a2\u1d40 \u03c6/[&m] :: \u0394) : IsCutFree (genelalizeByNewver hp h\u0394 d) \u2194 IsCutFree d ", "theoremName": "LO.FirstOrder.Derivation.IsCutFree.genelalizeByNewver_isCutFree", "fileCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/FirstOrder/Hauptsatz.lean", "module": "Foundation.FirstOrder.Hauptsatz", "jsonFile": "Foundation.FirstOrder.Hauptsatz.jsonl", "positionMetadata": {"lineInFile": 57, "tokenPositionInFile": 2328, "theoremPositionInFile": 9}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 31, "numPremises": 58}, "proofMetadata": {"hasProof": true, "proof": ":= by simp [genelalizeByNewver]", "proofType": "tactic", "proofLengthLines": 0, "proofLengthTokens": 31}}
{"srcContext": "import Foundation.Modal.Kripke.Geach.Systems\n\nnamespace LO.Modal.Hilbert\n\nopen System\nopen Modal.Kripke\nopen Formula\nopen Formula.Kripke\n\nlemma KDB_weakerThan_KTB : (Hilbert.KDB \u2115) \u2264\u209b (Hilbert.KTB \u2115) := by\n  apply Kripke.weakerThan_of_subset_FrameClass SerialSymmetricFrameClass ReflexiveSymmetricFrameClass;\n  rintro F \u27e8F_refl, F_symm\u27e9;\n  refine \u27e8serial_of_refl F_refl, F_symm\u27e9;\n\n", "theoremStatement": "theorem KDB_strictlyWeakerThan_KTB : (Hilbert.KDB \u2115) <\u209b (Hilbert.KTB \u2115) ", "theoremName": "LO.Modal.Hilbert.KDB_strictlyWeakerThan_KTB", "fileCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "theoremCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "file": "foundation/Foundation/Modal/Hilbert/WeakerThan/KDB_KTB.lean", "module": "Foundation.Modal.Hilbert.WeakerThan.KDB_KTB", "jsonFile": "Foundation.Modal.Hilbert.WeakerThan.KDB_KTB.jsonl", "positionMetadata": {"lineInFile": 15, "tokenPositionInFile": 381, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 60, "numPremises": 203}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  constructor;\n  . exact KDB_weakerThan_KTB;\n  . apply weakerThan_iff.not.mpr;\n    push_neg;\n    use (\u25a1(atom 0) \u279d (atom 0));\n    constructor;\n    . exact Deduction.maxm! (by simp);\n    . apply KDB.Kripke.sound.not_provable_of_countermodel;\n      suffices \u2203 F : Frame, Serial F.Rel \u2227 Symmetric F.Rel \u2227 \u2203 V : Valuation F, \u2203 w : F.World, \u00ac(Satisfies \u27e8F, V\u27e9 w _)  by\n        simp [ValidOnModel, ValidOnFrame, Satisfies];\n        tauto;\n      use \u27e8Fin 2, \u03bb x y => x \u2260 y\u27e9;\n      refine \u27e8?_, ?_, ?_\u27e9;\n      . intro x;\n        match x with\n        | 0 => use 1; simp;\n        | 1 => use 0; simp;\n      . unfold Symmetric;\n        tauto;\n      . use (\u03bb x _ => x = 1), 0;\n        simp [Semantics.Realize, Satisfies];\n        omega;", "proofType": "tactic", "proofLengthLines": 22, "proofLengthTokens": 727}}
{"srcContext": "import Foundation.Modal.Kripke.Geach.Systems\n\nnamespace LO.Modal.Hilbert\n\nopen System\nopen Modal.Kripke\nopen Formula\nopen Formula.Kripke\n\nlemma KTB_weakerThan_S5 : (Hilbert.KTB \u2115) \u2264\u209b (Hilbert.S5 \u2115) := by\n  apply Kripke.weakerThan_of_subset_FrameClass ReflexiveSymmetricFrameClass ReflexiveEuclideanFrameClass;\n  rintro F \u27e8F_refl, F_eucl\u27e9;\n  refine \u27e8F_refl, symm_of_refl_eucl F_refl F_eucl\u27e9;\n\n", "theoremStatement": "theorem KTB_strictlyWeakerThan_S5 : (Hilbert.KTB \u2115) <\u209b (Hilbert.S5 \u2115) ", "theoremName": "LO.Modal.Hilbert.KTB_strictlyWeakerThan_S5", "fileCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "theoremCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "file": "foundation/Foundation/Modal/Hilbert/WeakerThan/KTB_S5.lean", "module": "Foundation.Modal.Hilbert.WeakerThan.KTB_S5", "jsonFile": "Foundation.Modal.Hilbert.WeakerThan.KTB_S5.jsonl", "positionMetadata": {"lineInFile": 15, "tokenPositionInFile": 392, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 61, "numPremises": 144}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  constructor;\n  . exact KTB_weakerThan_S5;\n  . apply weakerThan_iff.not.mpr;\n    push_neg;\n    use (\u25c7(atom 0) \u279d \u25a1\u25c7(atom 0));\n    constructor;\n    . exact Deduction.maxm! (by simp);\n    . apply KTB.Kripke.sound.not_provable_of_countermodel;\n      suffices \u2203 F : Frame, Reflexive F.Rel \u2227 Symmetric F.Rel \u2227 \u2203 V : Valuation F, \u2203 w : F.World, \u00ac(Satisfies \u27e8F, V\u27e9 w _) by\n        simp [ValidOnModel, ValidOnFrame, Satisfies];\n        tauto;\n      let F : Frame := \u27e8\n        Fin 3,\n        \u03bb x y =>\n          match x, y with\n          | 1, 2 => False\n          | 2, 1 => False\n          | _, _ => True\n      \u27e9;\n      use F;\n      refine \u27e8?_, ?_, ?_\u27e9;\n      . unfold Reflexive;\n        aesop;\n      . unfold Symmetric;\n        aesop;\n      . use (\u03bb w _ => w = 1), 0;\n        suffices (0 : F.World) \u227a 1 \u2227 \u2203 x, (0 : F.World) \u227a x \u2227 \u00acx \u227a 1 by\n          simpa [Semantics.Realize, Satisfies];\n        constructor;\n        . tauto;\n        . use 2;\n          tauto;", "proofType": "tactic", "proofLengthLines": 32, "proofLengthTokens": 956}}
{"srcContext": "import Foundation.Logic.Predicate.Term\nimport Foundation.Logic.Predicate.Quantifier\n\n/-!\n# Rewriting System\n\nterm/formula morphisms such as Rewritings, substitutions, and embeddings are handled by the structure `LO.FirstOrder.Rew`.\n- `LO.FirstOrder.Rew.rewrite f` is a Rewriting of the free variables occurring in the term by `f : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n`.\n- `LO.FirstOrder.Rew.substs v` is a substitution of the bounded variables occurring in the term by `v : Fin n \u2192 Semiterm L \u03be n'`.\n- `LO.FirstOrder.Rew.bShift` is a transformation of the bounded variables occurring in the term by `#x \u21a6 #(Fin.succ x)`.\n- `LO.FirstOrder.Rew.shift` is a transformation of the free variables occurring in the term by `&x \u21a6 &(x + 1)`.\n- `LO.FirstOrder.Rew.emb` is a embedding of the term with no free variables.\n\nRewritings `LO.FirstOrder.Rew` is naturally converted to formula Rewritings by `LO.FirstOrder.Rew.hom`.\n\n-/\n\nnamespace LO\n\nnamespace FirstOrder\n\nstructure Rew (L : Language) (\u03be\u2081 : Type*) (n\u2081 : \u2115) (\u03be\u2082 : Type*) (n\u2082 : \u2115) where\n  toFun : Semiterm L \u03be\u2081 n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082\n  func' : \u2200 {k} (f : L.Func k) (v : Fin k \u2192 Semiterm L \u03be\u2081 n\u2081), toFun (Semiterm.func f v) = Semiterm.func f (fun i => toFun (v i))\n\nabbrev SyntacticRew (L : Language) (n\u2081 n\u2082 : \u2115) := Rew L \u2115 n\u2081 \u2115 n\u2082\n\nnamespace Rew\n\nopen Semiterm\nvariable {L L' L\u2081 L\u2082 L\u2083 : Language} {\u03be \u03be' \u03be\u2081 \u03be\u2082 \u03be\u2083 : Type*} {n n\u2081 n\u2082 n\u2083 : \u2115}\nvariable (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082)\n\ninstance : FunLike (Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) (Semiterm L \u03be\u2081 n\u2081) (Semiterm L \u03be\u2082 n\u2082) where\n  coe := fun f => f.toFun\n  coe_injective' := fun f g h => by rcases f; rcases g; simpa using h\n\ninstance : CoeFun (Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) (fun _ => Semiterm L \u03be\u2081 n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) := DFunLike.hasCoeToFun\n\nprotected lemma func {k} (f : L.Func k) (v : Fin k \u2192 Semiterm L \u03be\u2081 n\u2081) :\n    \u03c9 (func f v) = func f (fun i => \u03c9 (v i)) := \u03c9.func' f v\n\nlemma func'' {k} (f : L.Func k) (v : Fin k \u2192 Semiterm L \u03be\u2081 n\u2081) :\n    \u03c9 (func f v) = func f (\u03c9 \u2218 v) := \u03c9.func' f v\n\n@[simp] lemma func0 (f : L.Func 0) (v : Fin 0 \u2192 Semiterm L \u03be\u2081 n\u2081) :\n    \u03c9 (func f v) = func f ![] := by simp[Rew.func, Matrix.empty_eq]\n\n@[simp] lemma func1 (f : L.Func 1) (t : Semiterm L \u03be\u2081 n\u2081) :\n    \u03c9 (func f ![t]) = func f ![\u03c9 t] := by simp[Matrix.constant_eq_singleton, Rew.func]\n\n@[simp] lemma func2 (f : L.Func 2) (t\u2081 t\u2082 : Semiterm L \u03be\u2081 n\u2081) :\n    \u03c9 (func f ![t\u2081, t\u2082]) = func f ![\u03c9 t\u2081, \u03c9 t\u2082] := by\n  simp only [Rew.func, func.injEq, heq_eq_eq, true_and]\n  funext i\n  induction i using Fin.induction <;> simp\n\n@[simp] lemma func3 (f : L.Func 3) (t\u2081 t\u2082 t\u2083 : Semiterm L \u03be\u2081 n\u2081) :\n    \u03c9 (func f ![t\u2081, t\u2082, t\u2083]) = func f ![\u03c9 t\u2081, \u03c9 t\u2082, \u03c9 t\u2083] := by\n  simp only [Rew.func, func.injEq, heq_eq_eq, true_and]\n  funext i; induction' i using Fin.induction with i\n  \u00b7 simp\n  \u00b7 induction' i using Fin.induction with i <;> simp\n\n@[ext] lemma ext (\u03c9\u2081 \u03c9\u2082 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) (hb : \u2200 x, \u03c9\u2081 #x = \u03c9\u2082 #x) (hf : \u2200 x, \u03c9\u2081 &x = \u03c9\u2082 &x) : \u03c9\u2081 = \u03c9\u2082 := by\n  apply DFunLike.ext \u03c9\u2081 \u03c9\u2082; intro t\n  induction t <;> simp[*, \u03c9\u2081.func, \u03c9\u2082.func]\n\nlemma ext' {\u03c9\u2081 \u03c9\u2082 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082} (h : \u03c9\u2081 = \u03c9\u2082) (t) : \u03c9\u2081 t = \u03c9\u2082 t := by simp[h]\n\nprotected def id : Rew L \u03be n \u03be n where\n  toFun := id\n  func' := fun _ _ => rfl\n\n@[simp] lemma id_app (t : Semiterm L \u03be n) : Rew.id t = t := rfl\n\nprotected def comp (\u03c9\u2082 : Rew L \u03be\u2082 n\u2082 \u03be\u2083 n\u2083) (\u03c9\u2081 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) : Rew L \u03be\u2081 n\u2081 \u03be\u2083 n\u2083 where\n  toFun := fun t => \u03c9\u2082 (\u03c9\u2081 t)\n  func' := fun f v => by simp[func'']; rfl\n\nlemma comp_app (\u03c9\u2082 : Rew L \u03be\u2082 n\u2082 \u03be\u2083 n\u2083) (\u03c9\u2081 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) (t : Semiterm L \u03be\u2081 n\u2081) :\n    (\u03c9\u2082.comp \u03c9\u2081) t = \u03c9\u2082 (\u03c9\u2081 t) := rfl\n\n@[simp] lemma id_comp (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) : Rew.id.comp \u03c9 = \u03c9 := by ext <;> simp[comp_app]\n\n@[simp] lemma comp_id (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) : \u03c9.comp Rew.id = \u03c9 := by ext <;> simp[comp_app]\n\ndef bindAux (b : Fin n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) (e : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) : Semiterm L \u03be\u2081 n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082\n  | (#x)       => b x\n  | (&x)       => e x\n  | (func f v) => func f (fun i => bindAux b e (v i))\n\ndef bind (b : Fin n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) (e : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082 where\n  toFun := bindAux b e\n  func' := fun _ _ => rfl\n\ndef rewrite (f : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n) : Rew L \u03be\u2081 n \u03be\u2082 n := bind Semiterm.bvar f\n\ndef rewriteMap (e : \u03be\u2081 \u2192 \u03be\u2082) : Rew L \u03be\u2081 n \u03be\u2082 n := rewrite (fun m => &(e m))\n\ndef map (b : Fin n\u2081 \u2192 Fin n\u2082) (e : \u03be\u2081 \u2192 \u03be\u2082) : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082 :=\n  bind (fun n => #(b n)) (fun m => &(e m))\n\ndef substs {n'} (v : Fin n \u2192 Semiterm L \u03be n') : Rew L \u03be n \u03be n' :=\n  bind v fvar\n\ndef emb {o : Type v\u2081} [h : IsEmpty o] {\u03be : Type v\u2082} {n} : Rew L o n \u03be n := map id h.elim\n\nabbrev embs {o : Type v\u2081} [IsEmpty o] {n} : Rew L o n \u2115 n := emb\n\ndef empty {o : Type v\u2081} [h : IsEmpty o] {\u03be : Type v\u2082} {n} : Rew L o 0 \u03be n := map Fin.elim0 h.elim\n\ndef bShift : Rew L \u03be n \u03be (n + 1) :=\n  map Fin.succ id\n\ndef bShiftAdd (m : \u2115) : Rew L \u03be n \u03be (n + m) :=\n  map (Fin.addNat \u00b7 m) id\n\ndef cast {n n' : \u2115} (h : n = n') : Rew L \u03be n \u03be n' :=\n  map (Fin.cast h) id\n\ndef castLE {n n' : \u2115} (h : n \u2264 n') : Rew L \u03be n \u03be n' :=\n  map (Fin.castLE h) id\n\ndef toS : Rew L (Fin n) 0 Empty n := Rew.bind ![] (#\u00b7)\n\ndef toF : Rew L Empty n (Fin n) 0 := Rew.bind (&\u00b7) Empty.elim\n\ndef embSubsts (v : Fin k \u2192 Semiterm L \u03be n) : Rew L Empty k \u03be n := Rew.bind v Empty.elim\n\nprotected def q (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) : Rew L \u03be\u2081 (n\u2081 + 1) \u03be\u2082 (n\u2082 + 1) :=\n  bind (#0 :> bShift \u2218 \u03c9 \u2218 bvar) (bShift \u2218 \u03c9 \u2218 fvar)\n\nlemma eq_id_of_eq {\u03c9 : Rew L \u03be n \u03be n} (hb : \u2200 x, \u03c9 #x = #x) (he : \u2200 x, \u03c9 &x = &x) (t) : \u03c9 t = t := by\n  have : \u03c9 = Rew.id := by ext <;> simp[*]\n  simp[this]\n\ndef qpow (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) : (k : \u2115) \u2192 Rew L \u03be\u2081 (n\u2081 + k) \u03be\u2082 (n\u2082 + k)\n  | 0     => \u03c9\n  | k + 1 => (\u03c9.qpow k).q\n\n@[simp] lemma qpow_zero (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) : qpow \u03c9 0 = \u03c9 := rfl\n\n@[simp] lemma qpow_succ (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) (k : \u2115) : qpow \u03c9 (k + 1) = (\u03c9.qpow k).q := rfl\n\nsection bind\n\nvariable (b : Fin n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) (e : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082)\n\n@[simp] lemma bind_fvar (m : \u03be\u2081) : bind b e (&m : Semiterm L \u03be\u2081 n\u2081) = e m := rfl\n\n@[simp] lemma bind_bvar (n : Fin n\u2081) : bind b e (#n : Semiterm L \u03be\u2081 n\u2081) = b n := rfl\n\nlemma eq_bind (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) : \u03c9 = bind (\u03c9 \u2218 bvar) (\u03c9 \u2218 fvar) := by\n  ext t; induction t ;simp [Rew.func'']; simp [*]\n\n@[simp] lemma bind_eq_id_of_zero (f : Fin 0 \u2192 Semiterm L \u03be\u2082 0) : bind f fvar = Rew.id := by\n  ext x <;> simp only [bind_bvar, bind_fvar, id_app]; exact Fin.elim0 x\n\nend bind\n\nsection map\n\nvariable (b : Fin n\u2081 \u2192 Fin n\u2082) (e : \u03be\u2081 \u2192 \u03be\u2082)\n\n@[simp] lemma map_fvar (m : \u03be\u2081) : map b e (&m : Semiterm L \u03be\u2081 n\u2081) = &(e m) := rfl\n\n@[simp] lemma map_bvar (n : Fin n\u2081) : map b e (#n : Semiterm L \u03be\u2081 n\u2081) = #(b n) := rfl\n\n@[simp] lemma map_id : map (L := L) (id : Fin n \u2192 Fin n) (id : \u03be \u2192 \u03be) = Rew.id := by ext <;> simp\n\nlemma map_inj {b : Fin n\u2081 \u2192 Fin n\u2082} {e : \u03be\u2081 \u2192 \u03be\u2082} (hb : Function.Injective b) (he : Function.Injective e) :\n    Function.Injective $ map (L := L) b e\n  | #x,                    #y                    => by simpa using @hb _ _\n  | #x,                    &y                    => by simp\n  | #x,                    func f w              => by simp [Rew.func]\n  | &x,                    #y                    => by simp\n  | &x,                    &y                    => by simpa using @he _ _\n  | &x,                    func f w              => by simp [Rew.func]\n  | func f v,              #y                    => by simp [Rew.func]\n  | func f v,              &y                    => by simp [Rew.func]\n  | func (arity := k) f v, func (arity := l) g w => fun h \u21a6 by\n    have : k = l := by simp [Rew.func] at h; simp_all\n    rcases this\n    have : f = g := by simp [Rew.func] at h; simp_all\n    rcases this\n    have : v = w := by\n      have : (fun i \u21a6 (map b e) (v i)) = (fun i \u21a6 (map b e) (w i)) := by simpa [Rew.func] using h\n      funext i; exact map_inj hb he (congrFun this i)\n    simp_all\n\nend map\n\nsection rewrite\n\nvariable (f : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n)\n\n@[simp] lemma rewrite_fvar (x : \u03be\u2081) : rewrite f &x = f x := rfl\n\n@[simp] lemma rewrite_bvar (x : Fin n) : rewrite e (#x : Semiterm L \u03be\u2081 n) = #x := rfl\n\nlemma rewrite_comp_rewrite (v : \u03be\u2082 \u2192 Semiterm L \u03be\u2083 n) (w : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n) :\n    (rewrite v).comp (rewrite w) = rewrite (rewrite v \u2218 w) :=\n  by ext <;> simp[comp_app]\n\n@[simp] lemma rewrite_eq_id : (rewrite Semiterm.fvar : Rew L \u03be n \u03be n) = Rew.id := by ext <;> simp\n\nend rewrite\n\nsection rewriteMap\n\nvariable (e : \u03be\u2081 \u2192 \u03be\u2082)\n\n@[simp] lemma rewriteMap_fvar (x : \u03be\u2081) : rewriteMap e (&x : Semiterm L \u03be\u2081 n) = &(e x) := rfl\n\n@[simp] lemma rewriteMap_bvar (x : Fin n) : rewriteMap e (#x : Semiterm L \u03be\u2081 n) = #x := rfl\n\n@[simp] lemma rewriteMap_id : rewriteMap (L := L) (n := n) (id : \u03be \u2192 \u03be) = Rew.id := by ext <;> simp\n\nlemma eq_rewriteMap_of_funEqOn_fv [DecidableEq \u03be\u2081] (t : Semiterm L \u03be\u2081 n\u2081) (f g : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) (h : Function.funEqOn t.FVar? f g) :\n    Rew.rewriteMap f t = Rew.rewriteMap g t := by\n  induction t\n  case bvar => simp\n  case fvar x => simpa using h x (by simp)\n  case func f v ih =>\n    simp only [Rew.func, func.injEq, heq_eq_eq, true_and]\n    funext i\n    exact ih i (fun x hx \u21a6 h x (by simpa [Semiterm.fvar?_func] using \u27e8i, hx\u27e9))\n\nend rewriteMap\n\nsection emb\n\nvariable {o : Type v\u2082} [IsEmpty o]\n\n@[simp] lemma emb_bvar (x : Fin n) : emb (\u03be := \u03be) (#x : Semiterm L o n) = #x := rfl\n\n@[simp] lemma emb_eq_id : (emb : Rew L o n o n) = Rew.id := by\n  ext x <;> simp only [emb_bvar, id_app]; exact isEmptyElim x\n\nlemma eq_empty [h : IsEmpty \u03be\u2081] (\u03c9 : Rew L \u03be\u2081 0 \u03be\u2082 n) :\n  \u03c9 = empty := by ext x; { exact x.elim0 }; { exact h.elim' x }\n\nend emb\n\nsection bShift\n\n@[simp] lemma bShift_bvar (x : Fin n) : bShift (#x : Semiterm L \u03be n) = #(Fin.succ x) := rfl\n\n@[simp] lemma bShift_fvar (x : \u03be) : bShift (&x : Semiterm L \u03be n) = &x := rfl\n\n@[simp] lemma bShift_ne_zero (t : Semiterm L \u03be n) : bShift t \u2260 #0 := by\n  cases t <;> simp[Rew.func, Fin.succ_ne_zero]\n\n@[simp] lemma bShift_positive (t : Semiterm L \u03be n) : (bShift t).Positive := by\n  induction t <;> simp [Rew.func, *]\n\nlemma positive_iff {t : Semiterm L \u03be (n + 1)} : t.Positive \u2194 \u2203 t', t = bShift t' :=\n  \u27e8by induction t <;> simp\n      case bvar x =>\n        intro hx; exact \u27e8#(x.pred (Fin.pos_iff_ne_zero.mp hx)), by simp\u27e9\n      case fvar x => exact \u27e8&x, by simp\u27e9\n      case func k f v ih =>\n        intro h\n        have : \u2200 i, \u2203 t', v i = bShift t' := fun i => ih i (h i)\n        choose w hw using this\n        exact \u27e8func f w, by simp [Rew.func]; funext i; exact hw i\u27e9,\n   by rintro \u27e8t', rfl\u27e9; simp\u27e9\n\n@[simp] lemma leftConcat_bShift_comp_bvar :\n    (#0 :> bShift \u2218 bvar : Fin (n + 1) \u2192 Semiterm L \u03be (n + 1)) = bvar :=\n  funext (Fin.cases (by simp) (by simp))\n\n@[simp] lemma bShift_comp_fvar :\n    (bShift \u2218 fvar : \u03be \u2192 Semiterm L \u03be (n + 1)) = fvar :=\n  funext (by simp)\n\nend bShift\n\nsection bShiftAdd\n\n@[simp] lemma bShiftAdd_bvar (m) (x : Fin n) : bShiftAdd m (#x : Semiterm L \u03be n) = #(Fin.addNat x m) := rfl\n\n@[simp] lemma bShiftAdd_fvar (m) (x : \u03be) : bShiftAdd m (&x : Semiterm L \u03be n) = &x := rfl\n\nend bShiftAdd\n\nsection substs\n\nvariable {n'} (w : Fin n \u2192 Semiterm L \u03be n')\n\n", "theoremStatement": "@[simp] lemma substs_bvar (x : Fin n) : substs w #x = w x ", "theoremName": "LO.FirstOrder.Rew.substs_bvar", "fileCreated": {"commit": "f9b24e7d45330d9c809d246bb25b3aeccf722ef3", "date": "2024-11-06"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/Logic/Predicate/Rew.lean", "module": "Foundation.Logic.Predicate.Rew", "jsonFile": "Foundation.Logic.Predicate.Rew.jsonl", "positionMetadata": {"lineInFile": 292, "tokenPositionInFile": 10840, "theoremPositionInFile": 58}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 6, "numPremises": 12}, "proofMetadata": {"hasProof": true, "proof": ":=\n  by simp[substs]", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 20}}
{"srcContext": "import Foundation.IntFO.Translation\n\n/-!\n#Algebraic Proofs of Cut Elimination\n\nMain reference: Jeremy Avigad, Algebraic proofs of cut elimination, The Journal of Logic and Algebraic Programming, Volume 49, Issues 1\u20132, 2001, Pages 15-30\n -/\n\nnamespace LO.FirstOrder\n\nvariable {L : Language.{u}}\n\nnamespace Derivation\n\ninductive IsCutFree : {\u0393 : Sequent L} \u2192 \u22a2\u1d40 \u0393 \u2192 Prop\n| axL (\u0393) {k} (r : L.Rel k) (v)                 : IsCutFree (axL \u0393 r v)\n| verum (\u0393)                                     : IsCutFree (verum \u0393)\n| or {\u0393 \u03c6 \u03c8} {d : \u22a2\u1d40 \u03c6 :: \u03c8 :: \u0393}               : IsCutFree d \u2192 IsCutFree d.or\n| and {\u0393 \u03c6 \u03c8} {d\u03c6 : \u22a2\u1d40 \u03c6 :: \u0393} {d\u03c8 : \u22a2\u1d40 \u03c8 :: \u0393} : IsCutFree d\u03c6 \u2192 IsCutFree d\u03c8 \u2192 IsCutFree (d\u03c6.and d\u03c8)\n| all {\u0393 \u03c6} {d : \u22a2\u1d40 Rewriting.free \u03c6 :: \u0393\u207a}     : IsCutFree d \u2192 IsCutFree d.all\n| ex {\u0393 \u03c6} (t) {d : \u22a2\u1d40 \u03c6/[t] :: \u0393}              : IsCutFree d \u2192 IsCutFree d.ex\n| wk {\u0394 \u0393} {d : \u22a2\u1d40 \u0394} (ss : \u0394 \u2286 \u0393)              : IsCutFree d \u2192 IsCutFree (d.wk ss)\n\nattribute [simp] IsCutFree.axL IsCutFree.verum\n\nvariable {\u0393 \u0394 : Sequent L}\n\n@[simp] lemma isCutFree_or_iff {d : \u22a2\u1d40 \u03c6 :: \u03c8 :: \u0393} :\n    IsCutFree d.or \u2194 IsCutFree d := \u27e8by rintro \u27e8\u27e9; assumption, .or\u27e9\n\n@[simp] lemma isCutFree_and_iff {d\u03c6 : \u22a2\u1d40 \u03c6 :: \u0393} {d\u03c8 : \u22a2\u1d40 \u03c8 :: \u0393} :\n    IsCutFree (d\u03c6.and d\u03c8) \u2194 IsCutFree d\u03c6 \u2227 IsCutFree d\u03c8 :=\n  \u27e8by rintro \u27e8\u27e9; constructor <;> assumption, by intro \u27e8h\u03c6, h\u03c8\u27e9; exact h\u03c6.and h\u03c8\u27e9\n\n@[simp] lemma isCutFree_all_iff {d : \u22a2\u1d40 Rewriting.free \u03c6 :: \u0393\u207a} :\n    IsCutFree d.all \u2194 IsCutFree d := \u27e8by rintro \u27e8\u27e9; assumption, .all\u27e9\n\n@[simp] lemma isCutFree_ex_iff {d : \u22a2\u1d40 \u03c6/[t] :: \u0393} :\n    IsCutFree d.ex \u2194 IsCutFree d := \u27e8by rintro \u27e8\u27e9; assumption, .ex t\u27e9\n\n@[simp] lemma isCutFree_wk_iff {d : \u22a2\u1d40 \u0394} {ss : \u0394 \u2286 \u0393} :\n    IsCutFree (d.wk ss) \u2194 IsCutFree d := \u27e8by rintro \u27e8\u27e9; assumption, .wk _\u27e9\n\n@[simp] lemma IsCutFree.cast {d : \u22a2\u1d40 \u0393} {e : \u0393 = \u0394} :\n    IsCutFree (.cast d e) \u2194 IsCutFree d := by rcases e; rfl\n\n@[simp] lemma IsCutFree.not_cut (dp : \u22a2\u1d40 \u03c6 :: \u0393) (dn : \u22a2\u1d40 \u223c\u03c6 :: \u0393) : \u00acIsCutFree (dp.cut dn) := by rintro \u27e8\u27e9\n\n", "theoremStatement": "@[simp] lemma isCutFree_rewrite_iff_isCutFree {f : \u2115 \u2192 SyntacticTerm L} {d : \u22a2\u1d40 \u0393} :\n    IsCutFree (rewrite d f) \u2194 IsCutFree d ", "theoremName": "LO.FirstOrder.Derivation.isCutFree_rewrite_iff_isCutFree", "fileCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/FirstOrder/Hauptsatz.lean", "module": "Foundation.FirstOrder.Hauptsatz", "jsonFile": "Foundation.FirstOrder.Hauptsatz.jsonl", "positionMetadata": {"lineInFile": 49, "tokenPositionInFile": 1962, "theoremPositionInFile": 7}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 10, "repositoryPremises": true, "numRepositoryPremises": 64, "numPremises": 114}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  induction d generalizing f <;> simp [rewrite, *]\n  case root => contradiction", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 85}}
{"srcContext": "import Foundation.Modal.Kripke.Geach.Systems\n\nnamespace LO.Modal.Hilbert\n\nopen System\nopen Modal.Kripke\nopen Formula\nopen Formula.Kripke\n\n", "theoremStatement": "lemma KTB_weakerThan_S5 : (Hilbert.KTB \u2115) \u2264\u209b (Hilbert.S5 \u2115) ", "theoremName": "LO.Modal.Hilbert.KTB_weakerThan_S5", "fileCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "theoremCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "file": "foundation/Foundation/Modal/Hilbert/WeakerThan/KTB_S5.lean", "module": "Foundation.Modal.Hilbert.WeakerThan.KTB_S5", "jsonFile": "Foundation.Modal.Hilbert.WeakerThan.KTB_S5.jsonl", "positionMetadata": {"lineInFile": 10, "tokenPositionInFile": 138, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 22, "numPremises": 32}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  apply Kripke.weakerThan_of_subset_FrameClass ReflexiveSymmetricFrameClass ReflexiveEuclideanFrameClass;\n  rintro F \u27e8F_refl, F_eucl\u27e9;\n  refine \u27e8F_refl, symm_of_refl_eucl F_refl F_eucl\u27e9;", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 192}}
{"srcContext": "import Foundation.IntProp.Formula\nimport Foundation.Modal.Formula\n\nnamespace LO.IntProp\n\ndef Formula.toModalFormula : Formula \u03b1 \u2192 Modal.Formula \u03b1\n  | .atom a => Modal.Formula.atom a\n  | \u22a4 => \u22a4\n  | \u22a5 => \u22a5\n  | \u223c\u03c6 => \u223c(toModalFormula \u03c6)\n  | \u03c6 \u279d \u03c8 => (toModalFormula \u03c6) \u279d (toModalFormula \u03c8)\n  | \u03c6 \u22cf \u03c8 => (toModalFormula \u03c6) \u22cf (toModalFormula \u03c8)\n  | \u03c6 \u22ce \u03c8 => (toModalFormula \u03c6) \u22ce (toModalFormula \u03c8)\npostfix:75 \"\u1d39\" => Formula.toModalFormula\n\nnamespace Formula.toModalFormula\n\n@[simp] lemma def_top : (\u22a4 : Formula \u03b1)\u1d39 = \u22a4 := by rfl\n\n@[simp] lemma def_bot : (\u22a5 : Formula \u03b1)\u1d39 = \u22a5 := by rfl\n\n", "theoremStatement": "@[simp] lemma def_atom (a : \u03b1) : (atom a)\u1d39 = .atom a ", "theoremName": "LO.IntProp.Formula.toModalFormula.def_atom", "fileCreated": {"commit": "a1bfd1fa480026f05e476050030c0b2d17983bb0", "date": "2024-11-28"}, "theoremCreated": {"commit": "54324e6e009f0d0a288897312d3feb1c0165ad19", "date": "2025-01-24"}, "file": "foundation/Foundation/Modal/IntProp.lean", "module": "Foundation.Modal.IntProp", "jsonFile": "Foundation.Modal.IntProp.jsonl", "positionMetadata": {"lineInFile": 22, "tokenPositionInFile": 581, "theoremPositionInFile": 3}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 4, "numPremises": 6}, "proofMetadata": {"hasProof": true, "proof": ":= by rfl", "proofType": "tactic", "proofLengthLines": 0, "proofLengthTokens": 9}}
{"srcContext": "import Foundation.Modal.Hilbert.Maximal.Unprovability\nimport Foundation.Modal.Kripke.GL.MDP\n\nnamespace LO.Modal\n\nopen System\nopen IntProp\n\nvariable [DecidableEq \u03b1]\n\ndef independency (\u03c6 : Formula \u03b1) := \u223c\u25a1\u03c6 \u22cf \u223c\u25a1(\u223c\u03c6)\n\ndef higherIndependency (\u03c6 : Formula \u03b1) : \u2115 \u2192 Formula \u03b1\n  | 0 => \u03c6\n  | n + 1 => independency (higherIndependency \u03c6 n)\n\nnamespace Hilbert.GL\n\nvariable {\u03c6 : Formula \u2115}\n\nlemma unprovable_notbox : (Hilbert.GL _) \u22ac \u223c\u25a1\u03c6 := by\n  by_contra hC;\n  have : (Hilbert.GL _) \u22a2! \u223c\u25a1\u03c6 \u279d \u223c\u25a1\u22a5 := contra\u2080'! (imply_box_distribute'! efq!)\n  have : Hilbert.GL _ \u22a2! \u223c\u25a1\u22a5 := this \u2a00 hC;\n  have : Hilbert.Cl \u2115 \u22a2! (\u22a5 \u279d \u22a5) \u279d \u22a5 := by simpa using provable_CL_verTranslated this;\n  simpa using Hilbert.Cl.classical_sound this;\n\nlemma unprovable_independency : (Hilbert.GL _) \u22ac independency \u03c6 := by\n  by_contra hC;\n  exact unprovable_notbox $ and\u2081'! hC;\n\nlemma unprovable_not_independency_of_consistency : (Hilbert.GL \u2115) \u22ac \u223c(independency (\u223c\u25a1\u22a5)) := by\n  by_contra hC;\n  rcases modal_disjunctive (dne_or! $ demorgan\u2084'! hC) with (h | h);\n  . exact unprovable_notbox h;\n  . exact Consistent.not_bot (inferInstance) $ unnec! $ dne'! h\n\ntheorem undecidable_independency_of_consistency : Undecidable (Hilbert.GL \u2115) (independency (\u223c\u25a1\u22a5)) := by\n  constructor;\n  . exact unprovable_independency;\n  . exact unprovable_not_independency_of_consistency;\n\nvariable {n : \u2115}\n\n", "theoremStatement": "lemma unprovable_higherIndependency_of_consistency : (Hilbert.GL \u2115) \u22ac higherIndependency (\u223c\u25a1\u22a5) n ", "theoremName": "LO.Modal.Hilbert.GL.unprovable_higherIndependency_of_consistency", "fileCreated": {"commit": "830d76e560f33054a2eb2051cf1fa73997706985", "date": "2025-01-01"}, "theoremCreated": {"commit": "830d76e560f33054a2eb2051cf1fa73997706985", "date": "2025-01-01"}, "file": "foundation/Foundation/Modal/Hilbert/GL_Independency.lean", "module": "Foundation.Modal.Hilbert.GL_Independency", "jsonFile": "Foundation.Modal.Hilbert.GL_Independency.jsonl", "positionMetadata": {"lineInFile": 45, "tokenPositionInFile": 1337, "theoremPositionInFile": 5}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 15, "numPremises": 18}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  induction n with\n  | zero => exact unprovable_notbox;\n  | succ n ih => exact unprovable_independency;", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 109}}
{"srcContext": "import Foundation.Modal.Kripke.Geach.Systems\n\nnamespace LO.Modal.Hilbert\n\nopen System\nopen Modal.Kripke\nopen Formula\nopen Formula.Kripke\n\n", "theoremStatement": "lemma K5_weakerThan_KD5 : (Hilbert.K5 \u03b1) \u2264\u209b (Hilbert.KD5 \u03b1) ", "theoremName": "LO.Modal.Hilbert.K5_weakerThan_KD5", "fileCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "theoremCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "file": "foundation/Foundation/Modal/Hilbert/WeakerThan/K5_KD5.lean", "module": "Foundation.Modal.Hilbert.WeakerThan.K5_KD5", "jsonFile": "Foundation.Modal.Hilbert.WeakerThan.K5_KD5.jsonl", "positionMetadata": {"lineInFile": 10, "tokenPositionInFile": 138, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 19, "numPremises": 43}, "proofMetadata": {"hasProof": true, "proof": ":= normal_weakerThan_of_subset $ by intro; aesop;", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 49}}
{"srcContext": "import Foundation.Vorspiel.BinaryRelations\nimport Foundation.Modal.Kripke.Completeness\nimport Foundation.Modal.Hilbert.Geach\n\n\nnamespace LO.Modal\n\nnamespace Kripke\n\nabbrev GeachConfluentFrameClass (t : GeachConfluent.Taple) : FrameClass := { F | (GeachConfluent t) F.Rel }\n\ninstance GeachConfluentFrameClass.nonempty : (GeachConfluentFrameClass t).Nonempty := by\n  use reflexivePointFrame.toFrame;\n  intros x _ _ _; use x;\n  constructor <;> { apply Rel.iterate.true_any; tauto; }\n\n\nabbrev MultiGeachConfluentFrameClass (ts : List GeachConfluent.Taple) : FrameClass := { F | (MultiGeachConfluent ts) F.Rel }\n\nnamespace MultiGeachConfluentFrameClass\n\n@[simp] lemma def_nil : MultiGeachConfluentFrameClass [] = AllFrameClass := by rfl;\n\nlemma def_one (t : GeachConfluent.Taple) : MultiGeachConfluentFrameClass [t] = GeachConfluentFrameClass t := by rfl;\n\nlemma def_cons {t : GeachConfluent.Taple} {ts : List GeachConfluent.Taple} (ts_nil : ts \u2260 [])\n  : MultiGeachConfluentFrameClass (t :: ts) = GeachConfluentFrameClass t \u2229 MultiGeachConfluentFrameClass ts := by\n  apply Set.eq_of_subset_of_subset;\n  . rintro F hF;\n    apply MultiGeachConfluent.iff_cons ts_nil |>.mp;\n    exact hF;\n  . rintro F \u27e8hF\u2081, hF\u2082\u27e9;\n    apply MultiGeachConfluent.iff_cons ts_nil |>.mpr;\n    constructor;\n    . apply hF\u2081;\n    . apply hF\u2082;\n\n@[simp]\ninstance nonempty : (MultiGeachConfluentFrameClass ts).Nonempty := by\n  use \u27e8PUnit,  \u03bb _ _ => True\u27e9;\n  induction ts using List.induction_with_singleton with\n  | hnil => simp only [def_nil, Set.mem_univ];\n  | hsingle t =>\n    simp [GeachConfluentFrameClass];\n    intros x _ _ _; use x;\n    constructor <;> { apply Rel.iterate.true_any; tauto; }\n  | hcons t ts ts_nil ih =>\n    simp [MultiGeachConfluentFrameClass.def_cons ts_nil];\n    constructor;\n    . intro x _ _ _; use x;\n      constructor <;> { apply Rel.iterate.true_any; tauto; }\n    . exact ih;\n\nend MultiGeachConfluentFrameClass\n\n\nabbrev FrameClass.IsGeach (C : FrameClass) (ts : List GeachConfluent.Taple) := C = MultiGeachConfluentFrameClass ts\n\n\nsection\n\n/-- Frame class of `Hilbert.KT` -/\nabbrev ReflexiveFrameClass : FrameClass := { F | Reflexive F.Rel }\nlemma ReflexiveFrameClass.is_geach : ReflexiveFrameClass.IsGeach [\u27e80, 0, 1, 0\u27e9] := by\n  simp only [FrameClass.IsGeach, ReflexiveFrameClass, GeachConfluent.reflexive_def,\n    MultiGeachConfluentFrameClass.def_one, GeachConfluentFrameClass];\n\n/-- Frame class of `Hilbert.KD` -/\nabbrev SerialFrameClass : FrameClass := { F | Serial F.Rel }\nlemma SerialFrameClass.is_geach : SerialFrameClass.IsGeach [\u27e80, 0, 1, 1\u27e9] := by\n  simp only [FrameClass.IsGeach, SerialFrameClass, GeachConfluent.serial_def,\n    MultiGeachConfluentFrameClass.def_one, GeachConfluentFrameClass];\n\n/-- Frame class of `Hilbert.KB` -/\nabbrev SymmetricFrameClass : FrameClass := { F | Symmetric F.Rel }\nlemma SymmetricFrameClass.is_geach : SymmetricFrameClass.IsGeach [\u27e80, 1, 0, 1\u27e9] := by\n  simp only [FrameClass.IsGeach, SymmetricFrameClass, GeachConfluent.symmetric_def,\n    MultiGeachConfluentFrameClass.def_one, GeachConfluentFrameClass];\n\n/-- Frame class of `Hilbert.K4` -/\nabbrev TransitiveFrameClass : FrameClass := { F | Transitive F.Rel }\nlemma TransitiveFrameClass.is_geach : TransitiveFrameClass.IsGeach ([\u27e80, 2, 1, 0\u27e9]) := by\n  simp only [FrameClass.IsGeach, TransitiveFrameClass, GeachConfluent.transitive_def,\n    MultiGeachConfluentFrameClass.def_one, GeachConfluentFrameClass];\n\n/-- Frame class of `Hilbert.K5` -/\nabbrev EuclideanFrameClass : FrameClass := { F | Euclidean F.Rel }\nlemma EuclideanFrameClass.is_geach : EuclideanFrameClass.IsGeach ([\u27e81, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, EuclideanFrameClass, GeachConfluent.euclidean_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.S5` -/\nabbrev ReflexiveEuclideanFrameClass : FrameClass := { F | Reflexive F.Rel \u2227 Euclidean F.Rel }\nlemma ReflexiveEuclideanFrameClass.is_geach : ReflexiveEuclideanFrameClass.IsGeach ([\u27e80, 0, 1, 0\u27e9, \u27e81, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, ReflexiveEuclideanFrameClass, GeachConfluent.reflexive_def,\n    GeachConfluent.euclidean_def, MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.KTB` -/\nabbrev ReflexiveSymmetricFrameClass : FrameClass := { F | Reflexive F \u2227 Symmetric F }\nlemma ReflexiveSymmetricFrameClass.is_geach : ReflexiveSymmetricFrameClass.IsGeach ([\u27e80, 0, 1, 0\u27e9, \u27e80, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, ReflexiveSymmetricFrameClass, GeachConfluent.reflexive_def,\n    GeachConfluent.symmetric_def, MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.S4` -/\nabbrev ReflexiveTransitiveFrameClass : FrameClass := { F | Reflexive F \u2227 Transitive F }\nlemma ReflexiveTransitiveFrameClass.is_geach : ReflexiveTransitiveFrameClass.IsGeach ([\u27e80, 0, 1, 0\u27e9, \u27e80, 2, 1, 0\u27e9]) := by\n  simp only [FrameClass.IsGeach, ReflexiveTransitiveFrameClass, GeachConfluent.reflexive_def,\n    GeachConfluent.transitive_def, MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.S4Dot2` -/\nabbrev ReflexiveTransitiveConfluentFrameClass : FrameClass := { F | Reflexive F \u2227 Transitive F \u2227 Confluent F }\nlemma ReflexiveTransitiveConfluentFrameClass.is_geach : ReflexiveTransitiveConfluentFrameClass.IsGeach ([\u27e80, 0, 1, 0\u27e9, \u27e80, 2, 1, 0\u27e9, \u27e81, 1, 1, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, ReflexiveTransitiveConfluentFrameClass,\n    GeachConfluent.reflexive_def, GeachConfluent.transitive_def, GeachConfluent.confluent_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.KT4B` -/\nabbrev ReflexiveTransitiveSymmetricFrameClass : FrameClass := { F | Reflexive F \u2227 Transitive F \u2227 Symmetric F }\nlemma ReflexiveTransitiveSymmetricFrameClass.is_geach : ReflexiveTransitiveSymmetricFrameClass.IsGeach ([\u27e80, 0, 1, 0\u27e9, \u27e80, 2, 1, 0\u27e9, \u27e80, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, ReflexiveTransitiveSymmetricFrameClass,\n    GeachConfluent.reflexive_def, GeachConfluent.transitive_def, GeachConfluent.symmetric_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.KD45` -/\nabbrev SerialTransitiveEuclideanFrameClass : FrameClass := { F | Serial F \u2227 Transitive F \u2227 Euclidean F }\n", "theoremStatement": "lemma SerialTransitiveEuclideanFrameClass.is_geach : SerialTransitiveEuclideanFrameClass.IsGeach ([\u27e80, 0, 1, 1\u27e9, \u27e80, 2, 1, 0\u27e9, \u27e81, 1, 0, 1\u27e9]) ", "theoremName": "LO.Modal.Kripke.SerialTransitiveEuclideanFrameClass.is_geach", "fileCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "theoremCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "file": "foundation/Foundation/Modal/Kripke/Geach/Basic.lean", "module": "Foundation.Modal.Kripke.Geach.Basic", "jsonFile": "Foundation.Modal.Kripke.Geach.Basic.jsonl", "positionMetadata": {"lineInFile": 126, "tokenPositionInFile": 6210, "theoremPositionInFile": 27}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 14, "numPremises": 32}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp only [FrameClass.IsGeach, SerialTransitiveEuclideanFrameClass,\n    GeachConfluent.serial_def, GeachConfluent.transitive_def, GeachConfluent.euclidean_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 224}}
{"srcContext": "import Foundation.Logic.Predicate.Term\nimport Foundation.Logic.Predicate.Quantifier\n\n/-!\n# Rewriting System\n\nterm/formula morphisms such as Rewritings, substitutions, and embeddings are handled by the structure `LO.FirstOrder.Rew`.\n- `LO.FirstOrder.Rew.rewrite f` is a Rewriting of the free variables occurring in the term by `f : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n`.\n- `LO.FirstOrder.Rew.substs v` is a substitution of the bounded variables occurring in the term by `v : Fin n \u2192 Semiterm L \u03be n'`.\n- `LO.FirstOrder.Rew.bShift` is a transformation of the bounded variables occurring in the term by `#x \u21a6 #(Fin.succ x)`.\n- `LO.FirstOrder.Rew.shift` is a transformation of the free variables occurring in the term by `&x \u21a6 &(x + 1)`.\n- `LO.FirstOrder.Rew.emb` is a embedding of the term with no free variables.\n\nRewritings `LO.FirstOrder.Rew` is naturally converted to formula Rewritings by `LO.FirstOrder.Rew.hom`.\n\n-/\n\nnamespace LO\n\nnamespace FirstOrder\n\nstructure Rew (L : Language) (\u03be\u2081 : Type*) (n\u2081 : \u2115) (\u03be\u2082 : Type*) (n\u2082 : \u2115) where\n  toFun : Semiterm L \u03be\u2081 n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082\n  func' : \u2200 {k} (f : L.Func k) (v : Fin k \u2192 Semiterm L \u03be\u2081 n\u2081), toFun (Semiterm.func f v) = Semiterm.func f (fun i => toFun (v i))\n\nabbrev SyntacticRew (L : Language) (n\u2081 n\u2082 : \u2115) := Rew L \u2115 n\u2081 \u2115 n\u2082\n\nnamespace Rew\n\nopen Semiterm\nvariable {L L' L\u2081 L\u2082 L\u2083 : Language} {\u03be \u03be' \u03be\u2081 \u03be\u2082 \u03be\u2083 : Type*} {n n\u2081 n\u2082 n\u2083 : \u2115}\nvariable (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082)\n\ninstance : FunLike (Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) (Semiterm L \u03be\u2081 n\u2081) (Semiterm L \u03be\u2082 n\u2082) where\n  coe := fun f => f.toFun\n  coe_injective' := fun f g h => by rcases f; rcases g; simpa using h\n\ninstance : CoeFun (Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) (fun _ => Semiterm L \u03be\u2081 n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) := DFunLike.hasCoeToFun\n\nprotected lemma func {k} (f : L.Func k) (v : Fin k \u2192 Semiterm L \u03be\u2081 n\u2081) :\n    \u03c9 (func f v) = func f (fun i => \u03c9 (v i)) := \u03c9.func' f v\n\nlemma func'' {k} (f : L.Func k) (v : Fin k \u2192 Semiterm L \u03be\u2081 n\u2081) :\n    \u03c9 (func f v) = func f (\u03c9 \u2218 v) := \u03c9.func' f v\n\n@[simp] lemma func0 (f : L.Func 0) (v : Fin 0 \u2192 Semiterm L \u03be\u2081 n\u2081) :\n    \u03c9 (func f v) = func f ![] := by simp[Rew.func, Matrix.empty_eq]\n\n@[simp] lemma func1 (f : L.Func 1) (t : Semiterm L \u03be\u2081 n\u2081) :\n    \u03c9 (func f ![t]) = func f ![\u03c9 t] := by simp[Matrix.constant_eq_singleton, Rew.func]\n\n@[simp] lemma func2 (f : L.Func 2) (t\u2081 t\u2082 : Semiterm L \u03be\u2081 n\u2081) :\n    \u03c9 (func f ![t\u2081, t\u2082]) = func f ![\u03c9 t\u2081, \u03c9 t\u2082] := by\n  simp only [Rew.func, func.injEq, heq_eq_eq, true_and]\n  funext i\n  induction i using Fin.induction <;> simp\n\n@[simp] lemma func3 (f : L.Func 3) (t\u2081 t\u2082 t\u2083 : Semiterm L \u03be\u2081 n\u2081) :\n    \u03c9 (func f ![t\u2081, t\u2082, t\u2083]) = func f ![\u03c9 t\u2081, \u03c9 t\u2082, \u03c9 t\u2083] := by\n  simp only [Rew.func, func.injEq, heq_eq_eq, true_and]\n  funext i; induction' i using Fin.induction with i\n  \u00b7 simp\n  \u00b7 induction' i using Fin.induction with i <;> simp\n\n@[ext] lemma ext (\u03c9\u2081 \u03c9\u2082 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) (hb : \u2200 x, \u03c9\u2081 #x = \u03c9\u2082 #x) (hf : \u2200 x, \u03c9\u2081 &x = \u03c9\u2082 &x) : \u03c9\u2081 = \u03c9\u2082 := by\n  apply DFunLike.ext \u03c9\u2081 \u03c9\u2082; intro t\n  induction t <;> simp[*, \u03c9\u2081.func, \u03c9\u2082.func]\n\nlemma ext' {\u03c9\u2081 \u03c9\u2082 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082} (h : \u03c9\u2081 = \u03c9\u2082) (t) : \u03c9\u2081 t = \u03c9\u2082 t := by simp[h]\n\nprotected def id : Rew L \u03be n \u03be n where\n  toFun := id\n  func' := fun _ _ => rfl\n\n", "theoremStatement": "@[simp] lemma id_app (t : Semiterm L \u03be n) : Rew.id t = t ", "theoremName": "LO.FirstOrder.Rew.id_app", "fileCreated": {"commit": "f9b24e7d45330d9c809d246bb25b3aeccf722ef3", "date": "2024-11-06"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/Logic/Predicate/Rew.lean", "module": "Foundation.Logic.Predicate.Rew", "jsonFile": "Foundation.Logic.Predicate.Rew.jsonl", "positionMetadata": {"lineInFile": 75, "tokenPositionInFile": 3118, "theoremPositionInFile": 9}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 5, "numPremises": 9}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "import Foundation.Modal.Kripke.Geach.Systems\n\nnamespace LO.Modal.Hilbert\n\nopen System\nopen Modal.Kripke\nopen Formula\nopen Formula.Kripke\n\nlemma KD45_weakerThan_S5 : (Hilbert.KD45 \u2115) \u2264\u209b (Hilbert.S5 \u2115) :=  by\n  apply Kripke.weakerThan_of_subset_FrameClass SerialTransitiveEuclideanFrameClass ReflexiveEuclideanFrameClass;\n  rintro F \u27e8F_refl, F_eucl\u27e9;\n  refine \u27e8serial_of_refl F_refl, trans_of_refl_eucl F_refl F_eucl, F_eucl\u27e9;\n\n", "theoremStatement": "theorem KD45_strictlyWeakerThan_S5 : (Hilbert.KD45 \u2115) <\u209b (Hilbert.S5 \u2115) ", "theoremName": "LO.Modal.Hilbert.KD45_strictlyWeakerThan_S5", "fileCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "theoremCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "file": "foundation/Foundation/Modal/Hilbert/WeakerThan/KD45_S5.lean", "module": "Foundation.Modal.Hilbert.WeakerThan.KD45_S5", "jsonFile": "Foundation.Modal.Hilbert.WeakerThan.KD45_S5.jsonl", "positionMetadata": {"lineInFile": 15, "tokenPositionInFile": 426, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 60, "numPremises": 178}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  constructor;\n  . exact KD45_weakerThan_S5;\n  . apply weakerThan_iff.not.mpr;\n    push_neg;\n    use (\u25a1(atom 0) \u279d (atom 0));\n    constructor;\n    . exact Deduction.maxm! $ by simp;\n    . apply KD45.Kripke.sound.not_provable_of_countermodel;\n      suffices \u2203 F : Frame, Serial F.Rel \u2227 Transitive F.Rel \u2227 Euclidean F.Rel \u2227 \u2203 V : Valuation F, \u2203 w : F.World, \u00ac(Kripke.Satisfies \u27e8F, V\u27e9 w _) by\n        simp [ValidOnModel, ValidOnFrame, Satisfies];\n        tauto;\n      let F : Frame := \u27e8Fin 2, \u03bb x y => y = 1\u27e9;\n      use F;\n      refine \u27e8?_, ?_, ?_, ?_\u27e9;\n      . unfold Serial;\n        aesop;\n      . unfold Transitive;\n        omega;\n      . unfold Euclidean;\n        aesop;\n      . use (\u03bb w _ => w = 1), 0;\n        suffices (\u2200 y, (0 : F.World) \u227a y \u2192 y = 1) \u2227 \u00ac(0 : F.World) = 1 by\n          simpa [Semantics.Realize, Satisfies];\n        constructor;\n        . aesop;\n        . trivial;", "proofType": "tactic", "proofLengthLines": 26, "proofLengthTokens": 888}}
{"srcContext": "import Foundation.IntFO.Translation\n\n/-!\n#Algebraic Proofs of Cut Elimination\n\nMain reference: Jeremy Avigad, Algebraic proofs of cut elimination, The Journal of Logic and Algebraic Programming, Volume 49, Issues 1\u20132, 2001, Pages 15-30\n -/\n\nnamespace LO.FirstOrder\n\nvariable {L : Language.{u}}\n\nnamespace Derivation\n\ninductive IsCutFree : {\u0393 : Sequent L} \u2192 \u22a2\u1d40 \u0393 \u2192 Prop\n| axL (\u0393) {k} (r : L.Rel k) (v)                 : IsCutFree (axL \u0393 r v)\n| verum (\u0393)                                     : IsCutFree (verum \u0393)\n| or {\u0393 \u03c6 \u03c8} {d : \u22a2\u1d40 \u03c6 :: \u03c8 :: \u0393}               : IsCutFree d \u2192 IsCutFree d.or\n| and {\u0393 \u03c6 \u03c8} {d\u03c6 : \u22a2\u1d40 \u03c6 :: \u0393} {d\u03c8 : \u22a2\u1d40 \u03c8 :: \u0393} : IsCutFree d\u03c6 \u2192 IsCutFree d\u03c8 \u2192 IsCutFree (d\u03c6.and d\u03c8)\n| all {\u0393 \u03c6} {d : \u22a2\u1d40 Rewriting.free \u03c6 :: \u0393\u207a}     : IsCutFree d \u2192 IsCutFree d.all\n| ex {\u0393 \u03c6} (t) {d : \u22a2\u1d40 \u03c6/[t] :: \u0393}              : IsCutFree d \u2192 IsCutFree d.ex\n| wk {\u0394 \u0393} {d : \u22a2\u1d40 \u0394} (ss : \u0394 \u2286 \u0393)              : IsCutFree d \u2192 IsCutFree (d.wk ss)\n\nattribute [simp] IsCutFree.axL IsCutFree.verum\n\nvariable {\u0393 \u0394 : Sequent L}\n\n@[simp] lemma isCutFree_or_iff {d : \u22a2\u1d40 \u03c6 :: \u03c8 :: \u0393} :\n    IsCutFree d.or \u2194 IsCutFree d := \u27e8by rintro \u27e8\u27e9; assumption, .or\u27e9\n\n@[simp] lemma isCutFree_and_iff {d\u03c6 : \u22a2\u1d40 \u03c6 :: \u0393} {d\u03c8 : \u22a2\u1d40 \u03c8 :: \u0393} :\n    IsCutFree (d\u03c6.and d\u03c8) \u2194 IsCutFree d\u03c6 \u2227 IsCutFree d\u03c8 :=\n  \u27e8by rintro \u27e8\u27e9; constructor <;> assumption, by intro \u27e8h\u03c6, h\u03c8\u27e9; exact h\u03c6.and h\u03c8\u27e9\n\n@[simp] lemma isCutFree_all_iff {d : \u22a2\u1d40 Rewriting.free \u03c6 :: \u0393\u207a} :\n    IsCutFree d.all \u2194 IsCutFree d := \u27e8by rintro \u27e8\u27e9; assumption, .all\u27e9\n\n@[simp] lemma isCutFree_ex_iff {d : \u22a2\u1d40 \u03c6/[t] :: \u0393} :\n    IsCutFree d.ex \u2194 IsCutFree d := \u27e8by rintro \u27e8\u27e9; assumption, .ex t\u27e9\n\n@[simp] lemma isCutFree_wk_iff {d : \u22a2\u1d40 \u0394} {ss : \u0394 \u2286 \u0393} :\n    IsCutFree (d.wk ss) \u2194 IsCutFree d := \u27e8by rintro \u27e8\u27e9; assumption, .wk _\u27e9\n\n@[simp] lemma IsCutFree.cast {d : \u22a2\u1d40 \u0393} {e : \u0393 = \u0394} :\n    IsCutFree (.cast d e) \u2194 IsCutFree d := by rcases e; rfl\n\n", "theoremStatement": "@[simp] lemma IsCutFree.not_cut (dp : \u22a2\u1d40 \u03c6 :: \u0393) (dn : \u22a2\u1d40 \u223c\u03c6 :: \u0393) : \u00acIsCutFree (dp.cut dn) ", "theoremName": "LO.FirstOrder.Derivation.IsCutFree.not_cut", "fileCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/FirstOrder/Hauptsatz.lean", "module": "Foundation.FirstOrder.Hauptsatz", "jsonFile": "Foundation.FirstOrder.Hauptsatz.jsonl", "positionMetadata": {"lineInFile": 47, "tokenPositionInFile": 1853, "theoremPositionInFile": 6}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 8, "repositoryPremises": true, "numRepositoryPremises": 45, "numPremises": 73}, "proofMetadata": {"hasProof": true, "proof": ":= by rintro \u27e8\u27e9", "proofType": "tactic", "proofLengthLines": 0, "proofLengthTokens": 15}}
{"srcContext": "import Foundation.Modal.Kripke.Geach.Systems\n\nnamespace LO.Modal.Hilbert\n\nopen System\nopen Modal.Kripke\nopen Formula (atom)\nopen Formula.Kripke\n\n", "theoremStatement": "lemma KT_weakerThan_KTB : (Hilbert.KT \u03b1) \u2264\u209b (Hilbert.KTB \u03b1) ", "theoremName": "LO.Modal.Hilbert.KT_weakerThan_KTB", "fileCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "theoremCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "file": "foundation/Foundation/Modal/Hilbert/WeakerThan/KT_KTB.lean", "module": "Foundation.Modal.Hilbert.WeakerThan.KT_KTB", "jsonFile": "Foundation.Modal.Hilbert.WeakerThan.KT_KTB.jsonl", "positionMetadata": {"lineInFile": 10, "tokenPositionInFile": 145, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 19, "numPremises": 43}, "proofMetadata": {"hasProof": true, "proof": ":= normal_weakerThan_of_subset $ by intro; aesop;", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 49}}
{"srcContext": "import Foundation.Modal.Kripke.Geach.Systems\n\nnamespace LO.Modal.Hilbert\n\nopen System\nopen Modal.Kripke\nopen Formula\nopen Formula.Kripke\n\nlemma KD_weakerThan_KDB : (Hilbert.KD \u03b1) \u2264\u209b (Hilbert.KDB \u03b1) := normal_weakerThan_of_subset $ by intro; aesop;\n\n", "theoremStatement": "theorem KD_strictlyWeakerThan_KDB : (Hilbert.KD \u2115) <\u209b (Hilbert.KDB \u2115) ", "theoremName": "LO.Modal.Hilbert.KD_strictlyWeakerThan_KDB", "fileCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "theoremCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "file": "foundation/Foundation/Modal/Hilbert/WeakerThan/KD_KDB.lean", "module": "Foundation.Modal.Hilbert.WeakerThan.KD_KDB", "jsonFile": "Foundation.Modal.Hilbert.WeakerThan.KD_KDB.jsonl", "positionMetadata": {"lineInFile": 12, "tokenPositionInFile": 249, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 62, "numPremises": 185}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  constructor;\n  . exact KD_weakerThan_KDB;\n  . apply weakerThan_iff.not.mpr;\n    push_neg;\n    use ((atom 0) \u279d \u25a1\u25c7(atom 0));\n    constructor;\n    . exact Deduction.maxm! (by simp);\n    . apply KD.Kripke.sound.not_provable_of_countermodel;\n      suffices \u2203 F : Frame, Serial F.Rel \u2227 \u2203 V : Valuation F, \u2203 w : F.World, \u00ac(Satisfies \u27e8F, V\u27e9 w _)  by\n        simpa [ValidOnModel, ValidOnFrame, Satisfies];\n      let F : Frame := \u27e8Fin 2, \u03bb x y => x \u2264 y\u27e9;\n      use F;\n      constructor;\n      . intro x;\n        match x with\n        | 0 => use 1; omega;\n        | 1 => use 1;\n      . use (\u03bb w _ => w = 0), 0;\n        suffices \u2203 x, (0 : F.World) \u227a x \u2227 \u00acx \u227a 0 by\n          simpa [Semantics.Realize, Satisfies];\n        use 1;\n        omega;", "proofType": "tactic", "proofLengthLines": 22, "proofLengthTokens": 736}}
{"srcContext": "import Foundation.Modal.Kripke.Geach.Systems\n\nnamespace LO.Modal.Hilbert\n\nopen System\nopen Modal.Kripke\nopen Formula\nopen Formula.Kripke\n\nlemma K5_weakerThan_K45 : (Hilbert.K5 \u03b1) \u2264\u209b (Hilbert.K45 \u03b1) := normal_weakerThan_of_subset $ by intro; aesop;\n\n", "theoremStatement": "theorem K5_strictlyWeakerThan_K45 : (Hilbert.K5 \u2115) <\u209b (Hilbert.K45 \u2115) ", "theoremName": "LO.Modal.Hilbert.K5_strictlyWeakerThan_K45", "fileCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "theoremCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "file": "foundation/Foundation/Modal/Hilbert/WeakerThan/K5_K45.lean", "module": "Foundation.Modal.Hilbert.WeakerThan.K5_K45", "jsonFile": "Foundation.Modal.Hilbert.WeakerThan.K5_K45.jsonl", "positionMetadata": {"lineInFile": 12, "tokenPositionInFile": 249, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 60, "numPremises": 158}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  constructor;\n  . exact K5_weakerThan_K45;\n  . apply weakerThan_iff.not.mpr;\n    push_neg;\n    use (\u25a1(atom 0) \u279d \u25a1\u25a1(atom 0));\n    constructor;\n    . exact Deduction.maxm! $ by simp;\n    . apply K5.Kripke.sound.not_provable_of_countermodel;\n      suffices \u2203 F : Frame, Euclidean F.Rel \u2227 \u2203 V : Valuation F, \u2203 w : F.World, \u00ac(Kripke.Satisfies \u27e8F, V\u27e9 w _) by\n        simp [ValidOnModel, ValidOnFrame, Satisfies];\n        tauto;\n      let F : Frame := \u27e8\n          Fin 3,\n          \u03bb x y =>\n            match x, y with\n            | 0, 1 => True\n            | 1, 1 => True\n            | 1, 2 => True\n            | 2, 1 => True\n            | 2, 2 => True\n            | _, _ => False\n        \u27e9;\n      use F;\n      constructor;\n      . unfold Euclidean; aesop;\n      . use (\u03bb w _ => w = 1), 0;\n        suffices (\u2200 (y : F.World), (0 : F.World) \u227a y \u2192 y = 1) \u2227 \u2203 x, (0 : F.World) \u227a x \u2227 \u2203 z, x \u227a z \u2227 \u00acz = 1 by simpa [Semantics.Realize, Satisfies];\n        constructor;\n        . intro y R0y;\n          match y with\n          | 0 => tauto;\n          | 1 => tauto;\n          | 2 => tauto;\n        . use 1;\n          constructor;\n          . tauto;\n          . use 2;\n            constructor;\n            . tauto;\n            . trivial;", "proofType": "tactic", "proofLengthLines": 40, "proofLengthTokens": 1225}}
{"srcContext": "import Foundation.IntFO.Basic.Rew\n\nnamespace LO.FirstOrder\n\nabbrev Sequent\u1d62 (L : Language) := List (SyntacticFormula\u1d62 L)\n\nopen Semiformula\u1d62\n\nvariable {L : Language} {T : Theory L}\n\nstructure Hilbert\u1d62 (L : Language) where\n  axiomSet : Set (SyntacticFormula\u1d62 L)\n  rewrite_closed {\u03c6 : SyntacticFormula\u1d62 L} : \u03c6 \u2208 axiomSet \u2192 \u2200 f : \u2115 \u2192 SyntacticTerm L, Rew.rewrite f \u25b9 \u03c6 \u2208 axiomSet\n\ninstance : SetLike (Hilbert\u1d62 L) (SyntacticFormula\u1d62 L) where\n  coe := Hilbert\u1d62.axiomSet\n  coe_injective' := by rintro \u27e8T, _\u27e9 \u27e8U, _\u27e9; simp\n\nnamespace Hilbert\u1d62\n\ndef Minimal : Hilbert\u1d62 L := \u27e8\u2205, by simp\u27e9\n\nnotation \"\ud835\udc0c\ud835\udc22\ud835\udc27\u00b9\" => Minimal\n\ndef Intuitionistic : Hilbert\u1d62 L := \u27e8{\u22a5 \u279d \u03c6 | \u03c6}, by rintro _ \u27e8\u03c6, rfl\u27e9 f; exact \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\u27e9\n\nnotation \"\ud835\udc08\ud835\udc27\ud835\udc2d\u00b9\" => Intuitionistic\n\ndef Classical : Hilbert\u1d62 L := \u27e8{\u22a5 \u279d \u03c6 | \u03c6} \u222a {\u03c6 \u22ce \u223c\u03c6 | \u03c6}, by\n  rintro _ (\u27e8\u03c6, rfl\u27e9 | \u27e8\u03c6, rfl\u27e9) f\n  \u00b7 exact Or.inl \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\n  \u00b7 exact Or.inr \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\u27e9\n\nnotation \"\ud835\udc02\ud835\udc25\u00b9\" => Classical\n\nlemma minimal_le (\u039b : Hilbert\u1d62 L) : (Minimal : Hilbert\u1d62 L) \u2264 \u039b := by rintro _ \u27e8\u27e9\n\nlemma intuitionistic_le_classical : (Intuitionistic : Hilbert\u1d62 L) \u2264 Classical := by rintro _ \u27e8\u03c6, rfl\u27e9; exact .inl \u27e8\u03c6, rfl\u27e9\n\nend Hilbert\u1d62\n\ninductive HilbertProof\u1d62 (\u039b : Hilbert\u1d62 L) : SyntacticFormula\u1d62 L \u2192 Type _\n  | eaxm {\u03c6}     : \u03c6 \u2208 \u039b \u2192 HilbertProof\u1d62 \u039b \u03c6\n  | mdp {\u03c6 \u03c8}    : HilbertProof\u1d62 \u039b (\u03c6 \u279d \u03c8) \u2192 HilbertProof\u1d62 \u039b \u03c6 \u2192 HilbertProof\u1d62 \u039b \u03c8\n  | gen {\u03c6}      : HilbertProof\u1d62 \u039b (Rewriting.free \u03c6) \u2192 HilbertProof\u1d62 \u039b (\u2200' \u03c6)\n  | verum        : HilbertProof\u1d62 \u039b \u22a4\n  | imply\u2081 \u03c6 \u03c8   : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c8 \u279d \u03c6\n  | imply\u2082 \u03c6 \u03c8 \u03c7 : HilbertProof\u1d62 \u039b <| (\u03c6 \u279d \u03c8 \u279d \u03c7) \u279d (\u03c6 \u279d \u03c8) \u279d \u03c6 \u279d \u03c7\n  | and\u2081 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u22cf \u03c8 \u279d \u03c6\n  | and\u2082 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u22cf \u03c8 \u279d \u03c8\n  | and\u2083 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c8 \u279d \u03c6 \u22cf \u03c8\n  | or\u2081 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c6 \u22ce \u03c8\n  | or\u2082 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u03c8 \u279d \u03c6 \u22ce \u03c8\n  | or\u2083 \u03c6 \u03c8 \u03c7    : HilbertProof\u1d62 \u039b <| (\u03c6 \u279d \u03c7) \u279d (\u03c8 \u279d \u03c7) \u279d (\u03c6 \u22ce \u03c8 \u279d \u03c7)\n  | all\u2081 \u03c6 t     : HilbertProof\u1d62 \u039b <| \u2200' \u03c6 \u279d \u03c6/[t]\n  | all\u2082 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u2200' (\u03c6/[] \u279d \u03c8) \u279d \u03c6 \u279d \u2200' \u03c8\n  | ex\u2081 t \u03c6      : HilbertProof\u1d62 \u039b <| \u03c6/[t] \u279d \u2203' \u03c6\n  | ex\u2082 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u2200' (\u03c6 \u279d \u03c8/[]) \u279d \u2203' \u03c6 \u279d \u03c8\n\ninstance : System (SyntacticFormula\u1d62 L) (Hilbert\u1d62 L) := \u27e8HilbertProof\u1d62\u27e9\n\nnamespace HilbertProof\u1d62\n\nopen System.FiniteContext Rewriting LawfulSyntacticRewriting\n\nvariable (\u039b : Hilbert\u1d62 L)\n\ninstance : System.ModusPonens \u039b := \u27e8mdp\u27e9\n\ninstance : System.HasAxiomAndInst \u039b := \u27e8and\u2083\u27e9\n\ninstance : System.HasAxiomImply\u2081 \u039b := \u27e8imply\u2081\u27e9\n\ninstance : System.HasAxiomImply\u2082 \u039b := \u27e8imply\u2082\u27e9\n\ninstance : System.Minimal \u039b where\n  mdp := mdp\n  verum := verum\n  imply\u2081 := imply\u2081\n  imply\u2082 := imply\u2082\n  and\u2081 := and\u2081\n  and\u2082 := and\u2082\n  and\u2083 := and\u2083\n  or\u2081 := or\u2081\n  or\u2082 := or\u2082\n  or\u2083 := or\u2083\n  neg_equiv _ := System.iffId _\n\nvariable {\u039b}\n\nprotected def cast {\u03c6 \u03c8} (b : \u039b \u22a2 \u03c6) (e : \u03c6 = \u03c8) : \u039b \u22a2 \u03c8 := e \u25b8 b\n\ndef depth {\u03c6} : \u039b \u22a2 \u03c6 \u2192 \u2115\n  | mdp b d => max (depth b) (depth d) + 1\n  | gen b   => depth b + 1\n  | _       => 0\n\nscoped notation \"\u2016\" d \"\u2016\" => depth d\n\n", "theoremStatement": "@[simp] lemma depth_eaxm (h : \u03c6 \u2208 \u039b) : \u2016eaxm h\u2016 = 0 ", "theoremName": "LO.FirstOrder.HilbertProof\u1d62.depth_eaxm", "fileCreated": {"commit": "7d9e3859942c3a17a697b129e7fb3869eca0066e", "date": "2024-11-09"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/IntFO/Basic/Deduction.lean", "module": "Foundation.IntFO.Basic.Deduction", "jsonFile": "Foundation.IntFO.Basic.Deduction.jsonl", "positionMetadata": {"lineInFile": 100, "tokenPositionInFile": 2989, "theoremPositionInFile": 11}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 6, "numPremises": 13}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "import Foundation.IntFO.Basic.Rew\n\nnamespace LO.FirstOrder\n\nabbrev Sequent\u1d62 (L : Language) := List (SyntacticFormula\u1d62 L)\n\nopen Semiformula\u1d62\n\nvariable {L : Language} {T : Theory L}\n\nstructure Hilbert\u1d62 (L : Language) where\n  axiomSet : Set (SyntacticFormula\u1d62 L)\n  rewrite_closed {\u03c6 : SyntacticFormula\u1d62 L} : \u03c6 \u2208 axiomSet \u2192 \u2200 f : \u2115 \u2192 SyntacticTerm L, Rew.rewrite f \u25b9 \u03c6 \u2208 axiomSet\n\ninstance : SetLike (Hilbert\u1d62 L) (SyntacticFormula\u1d62 L) where\n  coe := Hilbert\u1d62.axiomSet\n  coe_injective' := by rintro \u27e8T, _\u27e9 \u27e8U, _\u27e9; simp\n\nnamespace Hilbert\u1d62\n\ndef Minimal : Hilbert\u1d62 L := \u27e8\u2205, by simp\u27e9\n\nnotation \"\ud835\udc0c\ud835\udc22\ud835\udc27\u00b9\" => Minimal\n\ndef Intuitionistic : Hilbert\u1d62 L := \u27e8{\u22a5 \u279d \u03c6 | \u03c6}, by rintro _ \u27e8\u03c6, rfl\u27e9 f; exact \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\u27e9\n\nnotation \"\ud835\udc08\ud835\udc27\ud835\udc2d\u00b9\" => Intuitionistic\n\ndef Classical : Hilbert\u1d62 L := \u27e8{\u22a5 \u279d \u03c6 | \u03c6} \u222a {\u03c6 \u22ce \u223c\u03c6 | \u03c6}, by\n  rintro _ (\u27e8\u03c6, rfl\u27e9 | \u27e8\u03c6, rfl\u27e9) f\n  \u00b7 exact Or.inl \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\n  \u00b7 exact Or.inr \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\u27e9\n\nnotation \"\ud835\udc02\ud835\udc25\u00b9\" => Classical\n\nlemma minimal_le (\u039b : Hilbert\u1d62 L) : (Minimal : Hilbert\u1d62 L) \u2264 \u039b := by rintro _ \u27e8\u27e9\n\nlemma intuitionistic_le_classical : (Intuitionistic : Hilbert\u1d62 L) \u2264 Classical := by rintro _ \u27e8\u03c6, rfl\u27e9; exact .inl \u27e8\u03c6, rfl\u27e9\n\nend Hilbert\u1d62\n\ninductive HilbertProof\u1d62 (\u039b : Hilbert\u1d62 L) : SyntacticFormula\u1d62 L \u2192 Type _\n  | eaxm {\u03c6}     : \u03c6 \u2208 \u039b \u2192 HilbertProof\u1d62 \u039b \u03c6\n  | mdp {\u03c6 \u03c8}    : HilbertProof\u1d62 \u039b (\u03c6 \u279d \u03c8) \u2192 HilbertProof\u1d62 \u039b \u03c6 \u2192 HilbertProof\u1d62 \u039b \u03c8\n  | gen {\u03c6}      : HilbertProof\u1d62 \u039b (Rewriting.free \u03c6) \u2192 HilbertProof\u1d62 \u039b (\u2200' \u03c6)\n  | verum        : HilbertProof\u1d62 \u039b \u22a4\n  | imply\u2081 \u03c6 \u03c8   : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c8 \u279d \u03c6\n  | imply\u2082 \u03c6 \u03c8 \u03c7 : HilbertProof\u1d62 \u039b <| (\u03c6 \u279d \u03c8 \u279d \u03c7) \u279d (\u03c6 \u279d \u03c8) \u279d \u03c6 \u279d \u03c7\n  | and\u2081 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u22cf \u03c8 \u279d \u03c6\n  | and\u2082 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u22cf \u03c8 \u279d \u03c8\n  | and\u2083 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c8 \u279d \u03c6 \u22cf \u03c8\n  | or\u2081 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c6 \u22ce \u03c8\n  | or\u2082 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u03c8 \u279d \u03c6 \u22ce \u03c8\n  | or\u2083 \u03c6 \u03c8 \u03c7    : HilbertProof\u1d62 \u039b <| (\u03c6 \u279d \u03c7) \u279d (\u03c8 \u279d \u03c7) \u279d (\u03c6 \u22ce \u03c8 \u279d \u03c7)\n  | all\u2081 \u03c6 t     : HilbertProof\u1d62 \u039b <| \u2200' \u03c6 \u279d \u03c6/[t]\n  | all\u2082 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u2200' (\u03c6/[] \u279d \u03c8) \u279d \u03c6 \u279d \u2200' \u03c8\n  | ex\u2081 t \u03c6      : HilbertProof\u1d62 \u039b <| \u03c6/[t] \u279d \u2203' \u03c6\n  | ex\u2082 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u2200' (\u03c6 \u279d \u03c8/[]) \u279d \u2203' \u03c6 \u279d \u03c8\n\ninstance : System (SyntacticFormula\u1d62 L) (Hilbert\u1d62 L) := \u27e8HilbertProof\u1d62\u27e9\n\nnamespace HilbertProof\u1d62\n\nopen System.FiniteContext Rewriting LawfulSyntacticRewriting\n\nvariable (\u039b : Hilbert\u1d62 L)\n\ninstance : System.ModusPonens \u039b := \u27e8mdp\u27e9\n\ninstance : System.HasAxiomAndInst \u039b := \u27e8and\u2083\u27e9\n\ninstance : System.HasAxiomImply\u2081 \u039b := \u27e8imply\u2081\u27e9\n\ninstance : System.HasAxiomImply\u2082 \u039b := \u27e8imply\u2082\u27e9\n\ninstance : System.Minimal \u039b where\n  mdp := mdp\n  verum := verum\n  imply\u2081 := imply\u2081\n  imply\u2082 := imply\u2082\n  and\u2081 := and\u2081\n  and\u2082 := and\u2082\n  and\u2083 := and\u2083\n  or\u2081 := or\u2081\n  or\u2082 := or\u2082\n  or\u2083 := or\u2083\n  neg_equiv _ := System.iffId _\n\nvariable {\u039b}\n\nprotected def cast {\u03c6 \u03c8} (b : \u039b \u22a2 \u03c6) (e : \u03c6 = \u03c8) : \u039b \u22a2 \u03c8 := e \u25b8 b\n\ndef depth {\u03c6} : \u039b \u22a2 \u03c6 \u2192 \u2115\n  | mdp b d => max (depth b) (depth d) + 1\n  | gen b   => depth b + 1\n  | _       => 0\n\nscoped notation \"\u2016\" d \"\u2016\" => depth d\n\n@[simp] lemma depth_eaxm (h : \u03c6 \u2208 \u039b) : \u2016eaxm h\u2016 = 0 := rfl\n@[simp] lemma depth_mdp (b : \u039b \u22a2 \u03c6 \u279d \u03c8) (d : \u039b \u22a2 \u03c6) : \u2016mdp b d\u2016 = max \u2016b\u2016 \u2016d\u2016 + 1 := rfl\n@[simp] lemma depth_gen (b : \u039b \u22a2 Rewriting.free \u03c6) : \u2016gen b\u2016 = \u2016b\u2016 + 1 := rfl\n@[simp] lemma depth_verum : \u2016(verum : \u039b \u22a2 \u22a4)\u2016 = 0 := rfl\n@[simp] lemma depth_imply\u2081 (\u03c6 \u03c8) : \u2016imply\u2081 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_imply\u2082 (\u03c6 \u03c8 \u03c7) : \u2016imply\u2082 (\u039b := \u039b) \u03c6 \u03c8 \u03c7\u2016 = 0 := rfl\n@[simp] lemma depth_and\u2081 (\u03c6 \u03c8) : \u2016and\u2081 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_and\u2082 (\u03c6 \u03c8) : \u2016and\u2082 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_and\u2083 (\u03c6 \u03c8) : \u2016and\u2083 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_or\u2081 (\u03c6 \u03c8) : \u2016or\u2081 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n", "theoremStatement": "@[simp] lemma depth_or\u2082 (\u03c6 \u03c8) : \u2016or\u2082 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 ", "theoremName": "LO.FirstOrder.HilbertProof\u1d62.depth_or\u2082", "fileCreated": {"commit": "7d9e3859942c3a17a697b129e7fb3869eca0066e", "date": "2024-11-09"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/IntFO/Basic/Deduction.lean", "module": "Foundation.IntFO.Basic.Deduction", "jsonFile": "Foundation.IntFO.Basic.Deduction.jsonl", "positionMetadata": {"lineInFile": 110, "tokenPositionInFile": 3666, "theoremPositionInFile": 21}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 10, "numPremises": 15}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "import Foundation.IntFO.Translation\n\n/-!\n#Algebraic Proofs of Cut Elimination\n\nMain reference: Jeremy Avigad, Algebraic proofs of cut elimination, The Journal of Logic and Algebraic Programming, Volume 49, Issues 1\u20132, 2001, Pages 15-30\n -/\n\nnamespace LO.FirstOrder\n\nvariable {L : Language.{u}}\n\nnamespace Derivation\n\ninductive IsCutFree : {\u0393 : Sequent L} \u2192 \u22a2\u1d40 \u0393 \u2192 Prop\n| axL (\u0393) {k} (r : L.Rel k) (v)                 : IsCutFree (axL \u0393 r v)\n| verum (\u0393)                                     : IsCutFree (verum \u0393)\n| or {\u0393 \u03c6 \u03c8} {d : \u22a2\u1d40 \u03c6 :: \u03c8 :: \u0393}               : IsCutFree d \u2192 IsCutFree d.or\n| and {\u0393 \u03c6 \u03c8} {d\u03c6 : \u22a2\u1d40 \u03c6 :: \u0393} {d\u03c8 : \u22a2\u1d40 \u03c8 :: \u0393} : IsCutFree d\u03c6 \u2192 IsCutFree d\u03c8 \u2192 IsCutFree (d\u03c6.and d\u03c8)\n| all {\u0393 \u03c6} {d : \u22a2\u1d40 Rewriting.free \u03c6 :: \u0393\u207a}     : IsCutFree d \u2192 IsCutFree d.all\n| ex {\u0393 \u03c6} (t) {d : \u22a2\u1d40 \u03c6/[t] :: \u0393}              : IsCutFree d \u2192 IsCutFree d.ex\n| wk {\u0394 \u0393} {d : \u22a2\u1d40 \u0394} (ss : \u0394 \u2286 \u0393)              : IsCutFree d \u2192 IsCutFree (d.wk ss)\n\nattribute [simp] IsCutFree.axL IsCutFree.verum\n\nvariable {\u0393 \u0394 : Sequent L}\n\n@[simp] lemma isCutFree_or_iff {d : \u22a2\u1d40 \u03c6 :: \u03c8 :: \u0393} :\n    IsCutFree d.or \u2194 IsCutFree d := \u27e8by rintro \u27e8\u27e9; assumption, .or\u27e9\n\n@[simp] lemma isCutFree_and_iff {d\u03c6 : \u22a2\u1d40 \u03c6 :: \u0393} {d\u03c8 : \u22a2\u1d40 \u03c8 :: \u0393} :\n    IsCutFree (d\u03c6.and d\u03c8) \u2194 IsCutFree d\u03c6 \u2227 IsCutFree d\u03c8 :=\n  \u27e8by rintro \u27e8\u27e9; constructor <;> assumption, by intro \u27e8h\u03c6, h\u03c8\u27e9; exact h\u03c6.and h\u03c8\u27e9\n\n@[simp] lemma isCutFree_all_iff {d : \u22a2\u1d40 Rewriting.free \u03c6 :: \u0393\u207a} :\n    IsCutFree d.all \u2194 IsCutFree d := \u27e8by rintro \u27e8\u27e9; assumption, .all\u27e9\n\n@[simp] lemma isCutFree_ex_iff {d : \u22a2\u1d40 \u03c6/[t] :: \u0393} :\n    IsCutFree d.ex \u2194 IsCutFree d := \u27e8by rintro \u27e8\u27e9; assumption, .ex t\u27e9\n\n@[simp] lemma isCutFree_wk_iff {d : \u22a2\u1d40 \u0394} {ss : \u0394 \u2286 \u0393} :\n    IsCutFree (d.wk ss) \u2194 IsCutFree d := \u27e8by rintro \u27e8\u27e9; assumption, .wk _\u27e9\n\n@[simp] lemma IsCutFree.cast {d : \u22a2\u1d40 \u0393} {e : \u0393 = \u0394} :\n    IsCutFree (.cast d e) \u2194 IsCutFree d := by rcases e; rfl\n\n@[simp] lemma IsCutFree.not_cut (dp : \u22a2\u1d40 \u03c6 :: \u0393) (dn : \u22a2\u1d40 \u223c\u03c6 :: \u0393) : \u00acIsCutFree (dp.cut dn) := by rintro \u27e8\u27e9\n\n@[simp] lemma isCutFree_rewrite_iff_isCutFree {f : \u2115 \u2192 SyntacticTerm L} {d : \u22a2\u1d40 \u0393} :\n    IsCutFree (rewrite d f) \u2194 IsCutFree d := by\n  induction d generalizing f <;> simp [rewrite, *]\n  case root => contradiction\n\n", "theoremStatement": "@[simp] lemma isCutFree_map_iff_isCutFree {f : \u2115 \u2192 \u2115} {d : \u22a2\u1d40 \u0393} :\n    IsCutFree (Derivation.map d f) \u2194 IsCutFree d ", "theoremName": "LO.FirstOrder.Derivation.isCutFree_map_iff_isCutFree", "fileCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/FirstOrder/Hauptsatz.lean", "module": "Foundation.FirstOrder.Hauptsatz", "jsonFile": "Foundation.FirstOrder.Hauptsatz.jsonl", "positionMetadata": {"lineInFile": 54, "tokenPositionInFile": 2176, "theoremPositionInFile": 8}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 19, "numPremises": 27}, "proofMetadata": {"hasProof": true, "proof": ":= isCutFree_rewrite_iff_isCutFree", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 34}}
{"srcContext": "import Foundation.Modal.Kripke.Geach.Systems\n\nnamespace LO.Modal.Hilbert\n\nopen System\nopen Modal.Kripke\nopen Formula\nopen Formula.Kripke\n\n", "theoremStatement": "lemma K5_weakerThan_K45 : (Hilbert.K5 \u03b1) \u2264\u209b (Hilbert.K45 \u03b1) ", "theoremName": "LO.Modal.Hilbert.K5_weakerThan_K45", "fileCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "theoremCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "file": "foundation/Foundation/Modal/Hilbert/WeakerThan/K5_K45.lean", "module": "Foundation.Modal.Hilbert.WeakerThan.K5_K45", "jsonFile": "Foundation.Modal.Hilbert.WeakerThan.K5_K45.jsonl", "positionMetadata": {"lineInFile": 10, "tokenPositionInFile": 138, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 19, "numPremises": 43}, "proofMetadata": {"hasProof": true, "proof": ":= normal_weakerThan_of_subset $ by intro; aesop;", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 49}}
{"srcContext": "import Foundation.Modal.Hilbert.Maximal.Unprovability\nimport Foundation.Modal.Kripke.GL.MDP\n\nnamespace LO.Modal\n\nopen System\nopen IntProp\n\nvariable [DecidableEq \u03b1]\n\ndef independency (\u03c6 : Formula \u03b1) := \u223c\u25a1\u03c6 \u22cf \u223c\u25a1(\u223c\u03c6)\n\ndef higherIndependency (\u03c6 : Formula \u03b1) : \u2115 \u2192 Formula \u03b1\n  | 0 => \u03c6\n  | n + 1 => independency (higherIndependency \u03c6 n)\n\nnamespace Hilbert.GL\n\nvariable {\u03c6 : Formula \u2115}\n\nlemma unprovable_notbox : (Hilbert.GL _) \u22ac \u223c\u25a1\u03c6 := by\n  by_contra hC;\n  have : (Hilbert.GL _) \u22a2! \u223c\u25a1\u03c6 \u279d \u223c\u25a1\u22a5 := contra\u2080'! (imply_box_distribute'! efq!)\n  have : Hilbert.GL _ \u22a2! \u223c\u25a1\u22a5 := this \u2a00 hC;\n  have : Hilbert.Cl \u2115 \u22a2! (\u22a5 \u279d \u22a5) \u279d \u22a5 := by simpa using provable_CL_verTranslated this;\n  simpa using Hilbert.Cl.classical_sound this;\n\nlemma unprovable_independency : (Hilbert.GL _) \u22ac independency \u03c6 := by\n  by_contra hC;\n  exact unprovable_notbox $ and\u2081'! hC;\n\nlemma unprovable_not_independency_of_consistency : (Hilbert.GL \u2115) \u22ac \u223c(independency (\u223c\u25a1\u22a5)) := by\n  by_contra hC;\n  rcases modal_disjunctive (dne_or! $ demorgan\u2084'! hC) with (h | h);\n  . exact unprovable_notbox h;\n  . exact Consistent.not_bot (inferInstance) $ unnec! $ dne'! h\n\ntheorem undecidable_independency_of_consistency : Undecidable (Hilbert.GL \u2115) (independency (\u223c\u25a1\u22a5)) := by\n  constructor;\n  . exact unprovable_independency;\n  . exact unprovable_not_independency_of_consistency;\n\nvariable {n : \u2115}\n\nlemma unprovable_higherIndependency_of_consistency : (Hilbert.GL \u2115) \u22ac higherIndependency (\u223c\u25a1\u22a5) n := by\n  induction n with\n  | zero => exact unprovable_notbox;\n  | succ n ih => exact unprovable_independency;\n\nlemma unprovable_not_higherIndependency_of_consistency : (Hilbert.GL \u2115) \u22ac \u223c(higherIndependency (\u223c\u25a1\u22a5) n) := by\n  by_contra hC;\n  induction n with\n  | zero =>\n    exact Consistent.not_bot (inferInstance) $ unnec! $ dne'! hC;\n  | succ n ih =>\n    rcases modal_disjunctive (dne_or! $ demorgan\u2084'! hC) with (h | h);\n    . exact unprovable_higherIndependency_of_consistency h;\n    . exact ih h;\n\n", "theoremStatement": "theorem undecidable_higherIndependency_of_consistency : Undecidable (Hilbert.GL \u2115) (higherIndependency (\u223c\u25a1\u22a5) n) ", "theoremName": "LO.Modal.Hilbert.GL.undecidable_higherIndependency_of_consistency", "fileCreated": {"commit": "830d76e560f33054a2eb2051cf1fa73997706985", "date": "2025-01-01"}, "theoremCreated": {"commit": "830d76e560f33054a2eb2051cf1fa73997706985", "date": "2025-01-01"}, "file": "foundation/Foundation/Modal/Hilbert/GL_Independency.lean", "module": "Foundation.Modal.Hilbert.GL_Independency", "jsonFile": "Foundation.Modal.Hilbert.GL_Independency.jsonl", "positionMetadata": {"lineInFile": 60, "tokenPositionInFile": 1934, "theoremPositionInFile": 7}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 16, "numPremises": 19}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  constructor;\n  . exact unprovable_higherIndependency_of_consistency;\n  . exact unprovable_not_higherIndependency_of_consistency;", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 136}}
{"srcContext": "import Foundation.Logic.Predicate.Term\nimport Foundation.Logic.Predicate.Quantifier\n\n/-!\n# Rewriting System\n\nterm/formula morphisms such as Rewritings, substitutions, and embeddings are handled by the structure `LO.FirstOrder.Rew`.\n- `LO.FirstOrder.Rew.rewrite f` is a Rewriting of the free variables occurring in the term by `f : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n`.\n- `LO.FirstOrder.Rew.substs v` is a substitution of the bounded variables occurring in the term by `v : Fin n \u2192 Semiterm L \u03be n'`.\n- `LO.FirstOrder.Rew.bShift` is a transformation of the bounded variables occurring in the term by `#x \u21a6 #(Fin.succ x)`.\n- `LO.FirstOrder.Rew.shift` is a transformation of the free variables occurring in the term by `&x \u21a6 &(x + 1)`.\n- `LO.FirstOrder.Rew.emb` is a embedding of the term with no free variables.\n\nRewritings `LO.FirstOrder.Rew` is naturally converted to formula Rewritings by `LO.FirstOrder.Rew.hom`.\n\n-/\n\nnamespace LO\n\nnamespace FirstOrder\n\nstructure Rew (L : Language) (\u03be\u2081 : Type*) (n\u2081 : \u2115) (\u03be\u2082 : Type*) (n\u2082 : \u2115) where\n  toFun : Semiterm L \u03be\u2081 n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082\n  func' : \u2200 {k} (f : L.Func k) (v : Fin k \u2192 Semiterm L \u03be\u2081 n\u2081), toFun (Semiterm.func f v) = Semiterm.func f (fun i => toFun (v i))\n\nabbrev SyntacticRew (L : Language) (n\u2081 n\u2082 : \u2115) := Rew L \u2115 n\u2081 \u2115 n\u2082\n\nnamespace Rew\n\nopen Semiterm\nvariable {L L' L\u2081 L\u2082 L\u2083 : Language} {\u03be \u03be' \u03be\u2081 \u03be\u2082 \u03be\u2083 : Type*} {n n\u2081 n\u2082 n\u2083 : \u2115}\nvariable (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082)\n\ninstance : FunLike (Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) (Semiterm L \u03be\u2081 n\u2081) (Semiterm L \u03be\u2082 n\u2082) where\n  coe := fun f => f.toFun\n  coe_injective' := fun f g h => by rcases f; rcases g; simpa using h\n\ninstance : CoeFun (Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) (fun _ => Semiterm L \u03be\u2081 n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) := DFunLike.hasCoeToFun\n\nprotected lemma func {k} (f : L.Func k) (v : Fin k \u2192 Semiterm L \u03be\u2081 n\u2081) :\n    \u03c9 (func f v) = func f (fun i => \u03c9 (v i)) := \u03c9.func' f v\n\nlemma func'' {k} (f : L.Func k) (v : Fin k \u2192 Semiterm L \u03be\u2081 n\u2081) :\n    \u03c9 (func f v) = func f (\u03c9 \u2218 v) := \u03c9.func' f v\n\n@[simp] lemma func0 (f : L.Func 0) (v : Fin 0 \u2192 Semiterm L \u03be\u2081 n\u2081) :\n    \u03c9 (func f v) = func f ![] := by simp[Rew.func, Matrix.empty_eq]\n\n@[simp] lemma func1 (f : L.Func 1) (t : Semiterm L \u03be\u2081 n\u2081) :\n    \u03c9 (func f ![t]) = func f ![\u03c9 t] := by simp[Matrix.constant_eq_singleton, Rew.func]\n\n@[simp] lemma func2 (f : L.Func 2) (t\u2081 t\u2082 : Semiterm L \u03be\u2081 n\u2081) :\n    \u03c9 (func f ![t\u2081, t\u2082]) = func f ![\u03c9 t\u2081, \u03c9 t\u2082] := by\n  simp only [Rew.func, func.injEq, heq_eq_eq, true_and]\n  funext i\n  induction i using Fin.induction <;> simp\n\n@[simp] lemma func3 (f : L.Func 3) (t\u2081 t\u2082 t\u2083 : Semiterm L \u03be\u2081 n\u2081) :\n    \u03c9 (func f ![t\u2081, t\u2082, t\u2083]) = func f ![\u03c9 t\u2081, \u03c9 t\u2082, \u03c9 t\u2083] := by\n  simp only [Rew.func, func.injEq, heq_eq_eq, true_and]\n  funext i; induction' i using Fin.induction with i\n  \u00b7 simp\n  \u00b7 induction' i using Fin.induction with i <;> simp\n\n@[ext] lemma ext (\u03c9\u2081 \u03c9\u2082 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) (hb : \u2200 x, \u03c9\u2081 #x = \u03c9\u2082 #x) (hf : \u2200 x, \u03c9\u2081 &x = \u03c9\u2082 &x) : \u03c9\u2081 = \u03c9\u2082 := by\n  apply DFunLike.ext \u03c9\u2081 \u03c9\u2082; intro t\n  induction t <;> simp[*, \u03c9\u2081.func, \u03c9\u2082.func]\n\nlemma ext' {\u03c9\u2081 \u03c9\u2082 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082} (h : \u03c9\u2081 = \u03c9\u2082) (t) : \u03c9\u2081 t = \u03c9\u2082 t := by simp[h]\n\nprotected def id : Rew L \u03be n \u03be n where\n  toFun := id\n  func' := fun _ _ => rfl\n\n@[simp] lemma id_app (t : Semiterm L \u03be n) : Rew.id t = t := rfl\n\nprotected def comp (\u03c9\u2082 : Rew L \u03be\u2082 n\u2082 \u03be\u2083 n\u2083) (\u03c9\u2081 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) : Rew L \u03be\u2081 n\u2081 \u03be\u2083 n\u2083 where\n  toFun := fun t => \u03c9\u2082 (\u03c9\u2081 t)\n  func' := fun f v => by simp[func'']; rfl\n\nlemma comp_app (\u03c9\u2082 : Rew L \u03be\u2082 n\u2082 \u03be\u2083 n\u2083) (\u03c9\u2081 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) (t : Semiterm L \u03be\u2081 n\u2081) :\n    (\u03c9\u2082.comp \u03c9\u2081) t = \u03c9\u2082 (\u03c9\u2081 t) := rfl\n\n@[simp] lemma id_comp (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) : Rew.id.comp \u03c9 = \u03c9 := by ext <;> simp[comp_app]\n\n@[simp] lemma comp_id (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) : \u03c9.comp Rew.id = \u03c9 := by ext <;> simp[comp_app]\n\ndef bindAux (b : Fin n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) (e : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) : Semiterm L \u03be\u2081 n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082\n  | (#x)       => b x\n  | (&x)       => e x\n  | (func f v) => func f (fun i => bindAux b e (v i))\n\ndef bind (b : Fin n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) (e : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082 where\n  toFun := bindAux b e\n  func' := fun _ _ => rfl\n\ndef rewrite (f : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n) : Rew L \u03be\u2081 n \u03be\u2082 n := bind Semiterm.bvar f\n\ndef rewriteMap (e : \u03be\u2081 \u2192 \u03be\u2082) : Rew L \u03be\u2081 n \u03be\u2082 n := rewrite (fun m => &(e m))\n\ndef map (b : Fin n\u2081 \u2192 Fin n\u2082) (e : \u03be\u2081 \u2192 \u03be\u2082) : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082 :=\n  bind (fun n => #(b n)) (fun m => &(e m))\n\ndef substs {n'} (v : Fin n \u2192 Semiterm L \u03be n') : Rew L \u03be n \u03be n' :=\n  bind v fvar\n\ndef emb {o : Type v\u2081} [h : IsEmpty o] {\u03be : Type v\u2082} {n} : Rew L o n \u03be n := map id h.elim\n\nabbrev embs {o : Type v\u2081} [IsEmpty o] {n} : Rew L o n \u2115 n := emb\n\ndef empty {o : Type v\u2081} [h : IsEmpty o] {\u03be : Type v\u2082} {n} : Rew L o 0 \u03be n := map Fin.elim0 h.elim\n\ndef bShift : Rew L \u03be n \u03be (n + 1) :=\n  map Fin.succ id\n\ndef bShiftAdd (m : \u2115) : Rew L \u03be n \u03be (n + m) :=\n  map (Fin.addNat \u00b7 m) id\n\ndef cast {n n' : \u2115} (h : n = n') : Rew L \u03be n \u03be n' :=\n  map (Fin.cast h) id\n\ndef castLE {n n' : \u2115} (h : n \u2264 n') : Rew L \u03be n \u03be n' :=\n  map (Fin.castLE h) id\n\ndef toS : Rew L (Fin n) 0 Empty n := Rew.bind ![] (#\u00b7)\n\ndef toF : Rew L Empty n (Fin n) 0 := Rew.bind (&\u00b7) Empty.elim\n\ndef embSubsts (v : Fin k \u2192 Semiterm L \u03be n) : Rew L Empty k \u03be n := Rew.bind v Empty.elim\n\nprotected def q (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) : Rew L \u03be\u2081 (n\u2081 + 1) \u03be\u2082 (n\u2082 + 1) :=\n  bind (#0 :> bShift \u2218 \u03c9 \u2218 bvar) (bShift \u2218 \u03c9 \u2218 fvar)\n\nlemma eq_id_of_eq {\u03c9 : Rew L \u03be n \u03be n} (hb : \u2200 x, \u03c9 #x = #x) (he : \u2200 x, \u03c9 &x = &x) (t) : \u03c9 t = t := by\n  have : \u03c9 = Rew.id := by ext <;> simp[*]\n  simp[this]\n\ndef qpow (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) : (k : \u2115) \u2192 Rew L \u03be\u2081 (n\u2081 + k) \u03be\u2082 (n\u2082 + k)\n  | 0     => \u03c9\n  | k + 1 => (\u03c9.qpow k).q\n\n@[simp] lemma qpow_zero (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) : qpow \u03c9 0 = \u03c9 := rfl\n\n@[simp] lemma qpow_succ (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) (k : \u2115) : qpow \u03c9 (k + 1) = (\u03c9.qpow k).q := rfl\n\nsection bind\n\nvariable (b : Fin n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) (e : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082)\n\n@[simp] lemma bind_fvar (m : \u03be\u2081) : bind b e (&m : Semiterm L \u03be\u2081 n\u2081) = e m := rfl\n\n@[simp] lemma bind_bvar (n : Fin n\u2081) : bind b e (#n : Semiterm L \u03be\u2081 n\u2081) = b n := rfl\n\nlemma eq_bind (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) : \u03c9 = bind (\u03c9 \u2218 bvar) (\u03c9 \u2218 fvar) := by\n  ext t; induction t ;simp [Rew.func'']; simp [*]\n\n@[simp] lemma bind_eq_id_of_zero (f : Fin 0 \u2192 Semiterm L \u03be\u2082 0) : bind f fvar = Rew.id := by\n  ext x <;> simp only [bind_bvar, bind_fvar, id_app]; exact Fin.elim0 x\n\nend bind\n\nsection map\n\nvariable (b : Fin n\u2081 \u2192 Fin n\u2082) (e : \u03be\u2081 \u2192 \u03be\u2082)\n\n@[simp] lemma map_fvar (m : \u03be\u2081) : map b e (&m : Semiterm L \u03be\u2081 n\u2081) = &(e m) := rfl\n\n@[simp] lemma map_bvar (n : Fin n\u2081) : map b e (#n : Semiterm L \u03be\u2081 n\u2081) = #(b n) := rfl\n\n@[simp] lemma map_id : map (L := L) (id : Fin n \u2192 Fin n) (id : \u03be \u2192 \u03be) = Rew.id := by ext <;> simp\n\nlemma map_inj {b : Fin n\u2081 \u2192 Fin n\u2082} {e : \u03be\u2081 \u2192 \u03be\u2082} (hb : Function.Injective b) (he : Function.Injective e) :\n    Function.Injective $ map (L := L) b e\n  | #x,                    #y                    => by simpa using @hb _ _\n  | #x,                    &y                    => by simp\n  | #x,                    func f w              => by simp [Rew.func]\n  | &x,                    #y                    => by simp\n  | &x,                    &y                    => by simpa using @he _ _\n  | &x,                    func f w              => by simp [Rew.func]\n  | func f v,              #y                    => by simp [Rew.func]\n  | func f v,              &y                    => by simp [Rew.func]\n  | func (arity := k) f v, func (arity := l) g w => fun h \u21a6 by\n    have : k = l := by simp [Rew.func] at h; simp_all\n    rcases this\n    have : f = g := by simp [Rew.func] at h; simp_all\n    rcases this\n    have : v = w := by\n      have : (fun i \u21a6 (map b e) (v i)) = (fun i \u21a6 (map b e) (w i)) := by simpa [Rew.func] using h\n      funext i; exact map_inj hb he (congrFun this i)\n    simp_all\n\nend map\n\nsection rewrite\n\nvariable (f : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n)\n\n@[simp] lemma rewrite_fvar (x : \u03be\u2081) : rewrite f &x = f x := rfl\n\n@[simp] lemma rewrite_bvar (x : Fin n) : rewrite e (#x : Semiterm L \u03be\u2081 n) = #x := rfl\n\nlemma rewrite_comp_rewrite (v : \u03be\u2082 \u2192 Semiterm L \u03be\u2083 n) (w : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n) :\n    (rewrite v).comp (rewrite w) = rewrite (rewrite v \u2218 w) :=\n  by ext <;> simp[comp_app]\n\n@[simp] lemma rewrite_eq_id : (rewrite Semiterm.fvar : Rew L \u03be n \u03be n) = Rew.id := by ext <;> simp\n\nend rewrite\n\nsection rewriteMap\n\nvariable (e : \u03be\u2081 \u2192 \u03be\u2082)\n\n@[simp] lemma rewriteMap_fvar (x : \u03be\u2081) : rewriteMap e (&x : Semiterm L \u03be\u2081 n) = &(e x) := rfl\n\n@[simp] lemma rewriteMap_bvar (x : Fin n) : rewriteMap e (#x : Semiterm L \u03be\u2081 n) = #x := rfl\n\n@[simp] lemma rewriteMap_id : rewriteMap (L := L) (n := n) (id : \u03be \u2192 \u03be) = Rew.id := by ext <;> simp\n\nlemma eq_rewriteMap_of_funEqOn_fv [DecidableEq \u03be\u2081] (t : Semiterm L \u03be\u2081 n\u2081) (f g : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) (h : Function.funEqOn t.FVar? f g) :\n    Rew.rewriteMap f t = Rew.rewriteMap g t := by\n  induction t\n  case bvar => simp\n  case fvar x => simpa using h x (by simp)\n  case func f v ih =>\n    simp only [Rew.func, func.injEq, heq_eq_eq, true_and]\n    funext i\n    exact ih i (fun x hx \u21a6 h x (by simpa [Semiterm.fvar?_func] using \u27e8i, hx\u27e9))\n\nend rewriteMap\n\nsection emb\n\nvariable {o : Type v\u2082} [IsEmpty o]\n\n@[simp] lemma emb_bvar (x : Fin n) : emb (\u03be := \u03be) (#x : Semiterm L o n) = #x := rfl\n\n@[simp] lemma emb_eq_id : (emb : Rew L o n o n) = Rew.id := by\n  ext x <;> simp only [emb_bvar, id_app]; exact isEmptyElim x\n\nlemma eq_empty [h : IsEmpty \u03be\u2081] (\u03c9 : Rew L \u03be\u2081 0 \u03be\u2082 n) :\n  \u03c9 = empty := by ext x; { exact x.elim0 }; { exact h.elim' x }\n\nend emb\n\nsection bShift\n\n@[simp] lemma bShift_bvar (x : Fin n) : bShift (#x : Semiterm L \u03be n) = #(Fin.succ x) := rfl\n\n@[simp] lemma bShift_fvar (x : \u03be) : bShift (&x : Semiterm L \u03be n) = &x := rfl\n\n@[simp] lemma bShift_ne_zero (t : Semiterm L \u03be n) : bShift t \u2260 #0 := by\n  cases t <;> simp[Rew.func, Fin.succ_ne_zero]\n\n@[simp] lemma bShift_positive (t : Semiterm L \u03be n) : (bShift t).Positive := by\n  induction t <;> simp [Rew.func, *]\n\nlemma positive_iff {t : Semiterm L \u03be (n + 1)} : t.Positive \u2194 \u2203 t', t = bShift t' :=\n  \u27e8by induction t <;> simp\n      case bvar x =>\n        intro hx; exact \u27e8#(x.pred (Fin.pos_iff_ne_zero.mp hx)), by simp\u27e9\n      case fvar x => exact \u27e8&x, by simp\u27e9\n      case func k f v ih =>\n        intro h\n        have : \u2200 i, \u2203 t', v i = bShift t' := fun i => ih i (h i)\n        choose w hw using this\n        exact \u27e8func f w, by simp [Rew.func]; funext i; exact hw i\u27e9,\n   by rintro \u27e8t', rfl\u27e9; simp\u27e9\n\n@[simp] lemma leftConcat_bShift_comp_bvar :\n    (#0 :> bShift \u2218 bvar : Fin (n + 1) \u2192 Semiterm L \u03be (n + 1)) = bvar :=\n  funext (Fin.cases (by simp) (by simp))\n\n@[simp] lemma bShift_comp_fvar :\n    (bShift \u2218 fvar : \u03be \u2192 Semiterm L \u03be (n + 1)) = fvar :=\n  funext (by simp)\n\nend bShift\n\nsection bShiftAdd\n\n@[simp] lemma bShiftAdd_bvar (m) (x : Fin n) : bShiftAdd m (#x : Semiterm L \u03be n) = #(Fin.addNat x m) := rfl\n\n@[simp] lemma bShiftAdd_fvar (m) (x : \u03be) : bShiftAdd m (&x : Semiterm L \u03be n) = &x := rfl\n\nend bShiftAdd\n\nsection substs\n\nvariable {n'} (w : Fin n \u2192 Semiterm L \u03be n')\n\n@[simp] lemma substs_bvar (x : Fin n) : substs w #x = w x :=\n  by simp[substs]\n\n@[simp] lemma substs_fvar (x : \u03be) : substs w &x = &x :=\n  by simp[substs]\n\n@[simp] lemma substs_zero (w : Fin 0 \u2192 Term L \u03be) : substs w = Rew.id :=\n  by ext x <;> simp; { exact Fin.elim0 x }\n\nlemma substs_comp_substs (v : Fin l \u2192 Semiterm L \u03be k) (w : Fin k \u2192 Semiterm L \u03be n) :\n    (substs w).comp (substs v) = substs (substs w \u2218 v) :=\n  by ext <;> simp[comp_app]\n\n@[simp] lemma substs_eq_id : (substs Semiterm.bvar : Rew L \u03be n \u03be n) = Rew.id := by ext <;> simp\n\nend substs\n\nsection cast\n\nvariable {n'} (h : n = n')\n\n@[simp] lemma cast_bvar (x : Fin n) : cast h (#x : Semiterm L \u03be n) = #(Fin.cast h x) := rfl\n\n@[simp] lemma cast_fvar (x : \u03be) : cast h (&x : Semiterm L \u03be n) = &x := rfl\n\n@[simp] lemma cast_eq_id {h} : (cast h : Rew L \u03be n \u03be n) = Rew.id := by ext <;> simp\n\nend cast\n\nsection castLE\n\n@[simp] lemma castLe_bvar {n'} (h : n \u2264 n') (x : Fin n) : castLE h (#x : Semiterm L \u03be n) = #(Fin.castLE h x) := rfl\n\n@[simp] lemma castLe_fvar {n'} (h : n \u2264 n') (x : \u03be) : castLE h (&x : Semiterm L \u03be n) = &x := rfl\n\n@[simp] lemma castLe_eq_id {h} : (castLE h : Rew L \u03be n \u03be n) = Rew.id := by ext <;> simp\n\nend castLE\n\nsection toS\n\n@[simp] lemma toS_fvar {n} (x : Fin n) : toS (&x : Term L (Fin n)) = #x := rfl\n\nend toS\n\nsection embSubsts\n\nvariable {k} (w : Fin k \u2192 Semiterm L \u03be n)\n\n@[simp] lemma embSubsts_bvar (x : Fin k) : embSubsts w #x = w x :=\n  by simp[embSubsts]\n\n@[simp] lemma embSubsts_zero (w : Fin 0 \u2192 Term L \u03be) : embSubsts w = Rew.emb := by\n  ext x <;> try simp\n  \u00b7 exact Fin.elim0 x\n  \u00b7 exact Empty.elim x\n\nlemma substs_comp_embSubsts (v : Fin l \u2192 Semiterm L \u03be k) (w : Fin k \u2192 Semiterm L \u03be n) :\n    (substs w).comp (embSubsts v) = embSubsts (substs w \u2218 v) := by\n  ext x <;> simp[comp_app]\n  exact Empty.elim x\n\n@[simp] lemma embSubsts_eq_id : (embSubsts Semiterm.bvar : Rew L Empty n \u03be n) = Rew.emb := by\n  ext x <;> try simp\n  \u00b7 exact Empty.elim x\n\nend embSubsts\n\nsection \u03c8\n\nvariable (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082)\n\n@[simp] lemma q_bvar_zero : \u03c9.q #0 = #0 := by simp[Rew.q]\n\n@[simp] lemma q_bvar_succ (i : Fin n\u2081) : \u03c9.q #(i.succ) = bShift (\u03c9 #i) := by simp[Rew.q]\n\n@[simp] lemma q_fvar (x : \u03be\u2081) : \u03c9.q &x = bShift (\u03c9 &x) := by simp[Rew.q]\n\n@[simp] lemma q_comp_bShift : \u03c9.q.comp bShift = bShift.comp \u03c9 := by\n  ext x <;> simp[comp_app]\n\n@[simp] lemma q_comp_bShift_app (t : Semiterm L \u03be\u2081 n\u2081) : \u03c9.q (bShift t) = bShift (\u03c9 t) := by\n  have := ext' (\u03c9.q_comp_bShift) t; simpa only [comp_app] using this\n\n@[simp] lemma q_id : (Rew.id : Rew L \u03be n \u03be n).q = Rew.id := by ext x; { cases x using Fin.cases <;> simp }; { simp }\n\n@[simp] lemma q_eq_zero_iff : \u03c9.q t = #0 \u2194 t = #0 := by\n  cases t <;> simp [Rew.func]\n  case bvar i =>\n    cases i using Fin.cases <;> simp [Fin.succ_ne_zero]\n\n@[simp] lemma q_positive_iff : (\u03c9.q t).Positive \u2194 t.Positive := by\n  induction t <;> simp [Rew.func, *]\n  case bvar x =>\n    cases x using Fin.cases <;> simp\n\n@[simp] lemma qpow_id {k} : (Rew.id : Rew L \u03be n \u03be n).qpow k = Rew.id := by induction k <;> simp[*]\n\nlemma q_comp (\u03c9\u2082 : Rew L \u03be\u2082 n\u2082 \u03be\u2083 n\u2083) (\u03c9\u2081 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) :\n    (Rew.comp \u03c9\u2082 \u03c9\u2081).q = \u03c9\u2082.q.comp \u03c9\u2081.q := by ext x; { cases x using Fin.cases <;> simp[comp_app] }; { simp[comp_app] }\n\nlemma qpow_comp (k) (\u03c9\u2082 : Rew L \u03be\u2082 n\u2082 \u03be\u2083 n\u2083) (\u03c9\u2081 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) :\n    (Rew.comp \u03c9\u2082 \u03c9\u2081).qpow k = (\u03c9\u2082.qpow k).comp (\u03c9\u2081.qpow k) := by induction k <;> simp[*, q_comp]\n\nlemma q_bind (b : Fin n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) (e : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) :\n    (bind b e).q = bind (#0 :> bShift \u2218 b) (bShift \u2218 e) := by ext x; { cases x using Fin.cases <;> simp }; { simp }\n\nlemma q_map (b : Fin n\u2081 \u2192 Fin n\u2082) (e : \u03be\u2081 \u2192 \u03be\u2082) :\n    (map (L := L) b e).q = map (0 :> Fin.succ \u2218 b) e := by ext x; { cases x using Fin.cases <;> simp }; { simp }\n\nlemma q_rewrite (f : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n) :\n    (rewrite f).q = rewrite (bShift \u2218 f) := by ext x; { cases x using Fin.cases <;> simp[rewriteMap] }; { simp }\n\n@[simp] lemma q_rewriteMap (e : \u03be\u2081 \u2192 \u03be\u2082) :\n    (rewriteMap (L := L) (n := n) e).q = rewriteMap e := by ext x; { cases x using Fin.cases <;> simp[rewriteMap] }; { simp }\n\n@[simp] lemma q_emb {o : Type v\u2081} [e : IsEmpty o] {n} :\n    (emb (L := L) (o := o) (\u03be := \u03be\u2082) (n := n)).q = emb := by ext x; { cases x using Fin.cases <;> simp }; { exact e.elim x }\n\n@[simp] lemma qpow_emb {o : Type v\u2081} [e : IsEmpty o] {n k} :\n    (emb (L := L) (o := o) (\u03be := \u03be\u2082) (n := n)).qpow k = emb := by induction k <;> simp[*]\n\n@[simp] lemma q_cast {n n'} (h : n = n') :\n    (cast h : Rew L \u03be n \u03be n').q = cast (congrFun (congrArg HAdd.hAdd h) 1) := by\n  ext x <;> simp; cases x using Fin.cases <;> simp\n\n@[simp] lemma q_castLE {n n'} (h : n \u2264 n') :\n    (castLE h : Rew L \u03be n \u03be n').q = castLE (Nat.add_le_add_right h 1) := by\n  ext x <;> simp; cases x using Fin.cases <;> simp\n\nlemma q_toS :\n    (toS : Rew L (Fin n) 0 Empty n).q = bind ![#0] (#\u00b7.succ) := by\n  ext x <;> simp; cases x using Fin.cases <;> try simp\n  \u00b7 exact Fin.elim0 (by assumption)\n\n@[simp] lemma qpow_castLE {n n'} (h : n \u2264 n') :\n    (castLE h : Rew L \u03be n \u03be n').qpow k = castLE (Nat.add_le_add_right h k) := by\n  induction k <;> simp[*]\n\nlemma q_substs (w : Fin n \u2192 Semiterm L \u03be n') :\n    (substs w).q = substs (#0 :> bShift \u2218 w) := by ext x; { cases x using Fin.cases <;> simp }; { simp }\n\nlemma q_embSubsts (w : Fin k \u2192 Semiterm L \u03be n) :\n    (embSubsts w).q = embSubsts (#0 :> bShift \u2218 w) := by ext x; { cases x using Fin.cases <;> simp }; { simp; exact Empty.elim x }\n\nend \u03c8\n\nsection Syntactic\n\n/-\n  #0 #1 ... #(n - 1) &0 &1 ...\n   \u2193shift\n  #0 #1 ... #(n - 1) &1 &2 &3 ...\n-/\n\ndef shift : SyntacticRew L n n := map id Nat.succ\n\n/-\n  #0 #1 ... #(n - 1) #n &0 &1 ...\n   \u2193free           \u2191fix\n  #0 #1 ... #(n - 1) &0 &1 &2 ...\n -/\n\ndef free : SyntacticRew L (n + 1) n := bind (bvar <: &0) (fun m => &(Nat.succ m))\n\ndef fix : SyntacticRew L n (n + 1) := bind (fun x => #(Fin.castSucc x)) (#(Fin.last n) :>\u2099 fvar)\n\nabbrev rewrite1 (t : SyntacticSemiterm L n) : SyntacticRew L n n := bind Semiterm.bvar (t :>\u2099 fvar)\n\nsection shift\n\n@[simp] lemma shift_bvar (x : Fin n) : shift (#x : SyntacticSemiterm L n) = #x := rfl\n\n@[simp] lemma shift_fvar (x : \u2115) : shift (&x : SyntacticSemiterm L n) = &(x + 1) := rfl\n\nlemma shift_func {k} (f : L.Func k) (v : Fin k \u2192 SyntacticSemiterm L n) :\n    shift (func f v) = func f (fun i => shift (v i)) := rfl\n\nlemma shift_Injective : Function.Injective (@shift L n) :=\n  Function.LeftInverse.injective (g := map id Nat.pred)\n    (by intros \u03c6; simp[\u2190comp_app]; apply eq_id_of_eq <;> simp[comp_app])\n\nend shift\n\nsection free\n\n@[simp] lemma free_bvar_castSucc (x : Fin n) : free (#(Fin.castSucc x) : SyntacticSemiterm L (n + 1)) = #x := by simp[free]\n\n@[simp] lemma free_bvar_castSucc_zero : free (#0 : SyntacticSemiterm L (n + 1 + 1)) = #0 := free_bvar_castSucc 0\n\n@[simp] lemma free_bvar_last : free (#(Fin.last n) : SyntacticSemiterm L (n + 1)) = &0 := by simp[free]\n\n@[simp] lemma free_bvar_last_zero : free (#0 : SyntacticSemiterm L 1) = &0 := free_bvar_last\n\n@[simp] lemma free_fvar (x : \u2115) : free (&x : SyntacticSemiterm L (n + 1)) = &(x + 1) := by simp[free]\n\nend free\n\nsection fix\n\n@[simp] lemma fix_bvar (x : Fin n) : fix (#x : SyntacticSemiterm L n) = #(Fin.castSucc x) := by simp[fix]\n\n@[simp] lemma fix_fvar_zero : fix (&0 : SyntacticSemiterm L n) = #(Fin.last n) := by simp[fix]\n\n@[simp] lemma fix_fvar_succ (x : \u2115) : fix (&(x + 1) : SyntacticSemiterm L n) = &x := by simp[fix]\n\nend fix\n\n@[simp] lemma free_comp_fix : (free (L := L) (n := n)).comp fix = Rew.id := by\n  ext x <;> simp[comp_app]; { cases x <;> simp }\n\n@[simp] lemma fix_comp_free : (fix (L := L) (n := n)).comp free = Rew.id := by\n  ext x <;> simp[comp_app]; { cases x using Fin.lastCases <;> simp }\n\n@[simp] lemma bShift_free_eq_shift : (free (L := L) (n := 0)).comp bShift = shift := by\n  ext x <;> simp[comp_app]; { exact Fin.elim0 x }\n\nlemma bShift_comp_substs (v : Fin n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) :\n  bShift.comp (substs v) = substs (bShift \u2218 v) := by ext x <;> simp[comp_app]\n\nlemma shift_comp_substs (v : Fin n\u2081 \u2192 SyntacticSemiterm L n\u2082) :\n  shift.comp (substs v) = (substs (shift \u2218 v)).comp shift := by ext x <;> simp[comp_app]\n\nlemma shift_comp_substs1 (t : SyntacticSemiterm L n\u2082) :\n  shift.comp (substs ![t]) = (substs ![shift t]).comp shift := by ext x <;> simp[comp_app]\n\n@[simp] lemma rewrite_comp_emb {o : Type v\u2081} [e : IsEmpty o] (f : \u03be\u2082 \u2192 Semiterm L \u03be\u2083 n) :\n  (rewrite f).comp emb = (emb : Rew L o n \u03be\u2083 n) := by ext x <;> simp[comp_app]; { exact IsEmpty.elim e x }\n\n@[simp] lemma shift_comp_emb {o : Type v\u2081} [e : IsEmpty o] :\n  shift.comp emb = (emb : Rew L o n \u2115 n) := by ext x <;> simp[comp_app]; { exact IsEmpty.elim e x }\n\nlemma rewrite_comp_free_eq_substs (t : SyntacticTerm L) :\n    (rewrite (t :>\u2099 Semiterm.fvar)).comp free = substs ![t] := by ext x <;> simp[comp_app, Fin.eq_zero]\n\nlemma rewrite_comp_shift_eq_id (t : SyntacticTerm L) :\n    (rewrite (t :>\u2099 Semiterm.fvar)).comp shift = Rew.id := by ext x <;> simp[comp_app]\n\n@[simp] lemma substs_mbar_zero_comp_shift_eq_free :\n    (substs (L := L) ![&0]).comp shift = free := by ext x <;> simp[comp_app, Fin.eq_zero]\n\n@[simp] lemma substs_comp_bShift_eq_id (v : Fin 1 \u2192 Semiterm L \u03be 0) :\n    (substs (L := L) v).comp bShift = Rew.id := by ext x <;> simp[comp_app]; exact Fin.elim0 x\n\nlemma free_comp_substs_eq_substs_comp_shift {n'} (w : Fin n' \u2192 SyntacticSemiterm Lf (n + 1)) :\n    free.comp (substs w) = (substs (free \u2218 w)).comp shift :=\n  by ext x <;> simp[comp_app]\n\n@[simp] lemma rewriteMap_comp_rewriteMap (f : \u03be\u2081 \u2192 \u03be\u2082) (g : \u03be\u2082 \u2192 \u03be\u2083) :\n  (rewriteMap (L := L) (n := n) g).comp (rewriteMap f) = rewriteMap (g \u2218 f) := by ext x <;> simp [comp_app]\n\n@[simp] lemma fix_free_app (t : SyntacticSemiterm L (n + 1)) : fix (free t) = t := by simp[\u2190comp_app]\n\n@[simp] lemma free_fix_app (t : SyntacticSemiterm L n) : free (fix t) = t := by simp[\u2190comp_app]\n\n@[simp] lemma free_bShift_app (t : SyntacticSemiterm L 0) : free (bShift t) = shift t := by simp[\u2190comp_app]\n\n@[simp] lemma substs_bShift_app (v : Fin 1 \u2192 Semiterm L \u03be 0) : substs v (bShift t) = t := by simp[\u2190comp_app]\n\nlemma rewrite_comp_fix_eq_substs (t) :\n    ((rewrite (t :>\u2099 (&\u00b7))).comp free : SyntacticRew L 1 0) = substs ![t] := by\n  ext x <;> simp[comp_app, Fin.eq_zero]\n\nlemma bShift_eq_rewrite :\n    (Rew.bShift : SyntacticRew L 0 1) = Rew.substs ![] := by\n  ext x\n  \u00b7 exact x.elim0\n  \u00b7 simp\n\nsection \u03c8\n\nvariable (\u03c9 : SyntacticRew L n\u2081 n\u2082)\n\n@[simp] lemma q_shift : (shift (L := L) (n := n)).q = shift := by ext x; { cases x using Fin.cases <;> simp }; { simp }\n\n@[simp] lemma q_free : (free (L := L) (n := n)).q = free := by\n  ext x; { cases' x using Fin.cases with x <;> simp; { cases x using Fin.lastCases <;> simp[Fin.succ_castSucc] } }; { simp }\n\n@[simp] lemma q_fix : (fix (L := L) (n := n)).q = fix := by\n  ext x; { cases x using Fin.cases <;> simp[Fin.succ_castSucc] }; { cases x <;> simp }\n\n--@[simp] lemma qpow_fix (k : \u2115) : (fix (L := L) (n := n)).qpow k = fix := by\n\nend \u03c8\n\ndef fixitr (n : \u2115) : (m : \u2115) \u2192 SyntacticRew L n (n + m)\n  | 0     => Rew.id\n  | m + 1 => Rew.fix.comp (fixitr n m)\n\n@[simp] lemma fixitr_zero :\n    fixitr (L := L) n 0 = Rew.id := by simp [fixitr]\n\nlemma fixitr_succ (m) :\n    fixitr (L := L) n (m + 1) = Rew.fix.comp (fixitr n m) := by\n  simp [fixitr]\n\n@[simp] lemma fixitr_bvar (n m) (x : Fin n) : fixitr n m (#x : SyntacticSemiterm L n) = #(x.castAdd m) := by\n  induction m <;> simp [*, comp_app, fixitr_succ]\n  case succ m ih =>\n    simpa [ih] using comp_app fix (fixitr (L := L) n m) #x\n\nlemma fixitr_fvar (n m) (x : \u2115) :\n    fixitr n m (&x : SyntacticSemiterm L n) = if h : x < m then #(Fin.natAdd n \u27e8x, h\u27e9) else &(x - m) := by\n  induction m <;> simp [*, comp_app]\n  case succ m ih =>\n    suffices fix (fixitr n m &x) = if h : x < m + 1 then #\u27e8n + x, _\u27e9 else &(x - (m + 1)) from Eq.trans (comp_app _ _ _) this\n    simp [ih]\n    by_cases hx : x < m\n    \u00b7 simp [hx, Nat.lt_add_right 1 hx]\n    by_cases hx2 : x < m + 1\n    \u00b7 have : x = m := Nat.le_antisymm (by { simpa [Nat.lt_succ] using hx2 }) (by simpa using hx)\n      simp [this, hx, hx2]; ext; simp\n    \u00b7 simp [hx, hx2]\n      have : x - m = x - (m + 1) + 1 := by omega\n      simp [this]\n\nend Syntactic\n\nlemma substs_bv (t : Semiterm L \u03be n) (v : Fin n \u2192 Semiterm L \u03be m) :\n    (Rew.substs v t).bv = t.bv.biUnion (fun i \u21a6 (v i).bv) := by\n  induction t <;> simp [Rew.func, Semiterm.bv_func, Finset.biUnion_biUnion, *]\n\n@[simp] lemma substs_positive (t : Semiterm L \u03be n) (v : Fin n \u2192 Semiterm L \u03be (m + 1)) :\n    (Rew.substs v t).Positive \u2194 \u2200 i \u2208 t.bv, (v i).Positive := by\n  simp [Semiterm.Positive, substs_bv]\n  exact \u27e8fun H i hi x hx \u21a6 H x i hi hx, fun H x i hi hx \u21a6 H i hi x hx\u27e9\n\nlemma embSubsts_bv (t : Semiterm L Empty n) (v : Fin n \u2192 Semiterm L \u03be m) :\n    (Rew.embSubsts v t).bv = t.bv.biUnion (fun i \u21a6 (v i).bv) := by\n  induction t <;> simp [Rew.func, Semiterm.bv_func, Finset.biUnion_biUnion, *]\n  \u00b7 contradiction\n\n@[simp] lemma embSubsts_positive (t : Semiterm L Empty n) (v : Fin n \u2192 Semiterm L \u03be (m + 1)) :\n    (Rew.embSubsts v t).Positive \u2194 \u2200 i \u2208 t.bv, (v i).Positive := by\n  simp [Semiterm.Positive, embSubsts_bv]\n  exact \u27e8fun H i hi x hx \u21a6 H x i hi hx, fun H x i hi hx \u21a6 H i hi x hx\u27e9\n\n@[simp] lemma bshift_positive (t : Semiterm L \u03be n) : Positive (Rew.bShift t) := by\n  induction t <;> simp\n\nlemma emb_comp_bShift_comm {o : Type v\u2081} [IsEmpty o] :\n    Rew.bShift.comp (Rew.emb : Rew L o n \u03be n) = Rew.emb.comp Rew.bShift := by\n  ext x; simp [comp_app]\n  exact IsEmpty.elim (by assumption) x\n\nlemma emb_bShift_term {o : Type v\u2081} [IsEmpty o] (t : Semiterm L o n) :\n    Rew.bShift (Rew.emb t : Semiterm L \u03be n) = Rew.emb (Rew.bShift t) := by\n  simp [\u2190comp_app, emb_comp_bShift_comm]\n\nend Rew\n\n/-!\n### Rewriting system of terms\n\n-/\nnamespace Semiterm\n\nvariable {L L' L\u2081 L\u2082 L\u2083 : Language} {\u03be \u03be' \u03be\u2081 \u03be\u2082 \u03be\u2083 : Type*} {n n\u2081 n\u2082 n\u2083 : \u2115}\n\ninstance : Coe (Semiterm L Empty n) (SyntacticSemiterm L n) := \u27e8Rew.emb\u27e9\n\n@[simp] lemma freeVariables_emb {\u03bf : Type*} [IsEmpty \u03bf] [DecidableEq \u03be] {t : Semiterm L \u03bf n} :\n    (Rew.emb t : Semiterm L \u03be n).freeVariables = \u2205 := by\n  induction t\n  case bvar => simp\n  case fvar x => exact IsEmpty.elim inferInstance x\n  case func k f v ih =>\n    ext x; simp [Rew.func, freeVariables_func, ih]\n\nlemma rew_eq_of_funEqOn [DecidableEq \u03be\u2081] (\u03c9\u2081 \u03c9\u2082 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) (t : Semiterm L \u03be\u2081 n\u2081)\n  (hb : \u2200 x, \u03c9\u2081 #x = \u03c9\u2082 #x)\n  (he : Function.funEqOn t.FVar? (\u03c9\u2081 \u2218 Semiterm.fvar) (\u03c9\u2082 \u2218 Semiterm.fvar)) :\n    \u03c9\u2081 t = \u03c9\u2082 t := by\n  induction t <;> try simp[Rew.func, hb]\n  case fvar => simpa [FVar?, Function.funEqOn] using he\n  case func k f v ih =>\n    funext i\n    exact ih i (he.of_subset $ by simp[FVar?]; intro x hx; exact \u27e8i, hx\u27e9)\n\nsection lMap\n\nvariable (\u03a6 : L\u2081 \u2192\u1d65 L\u2082)\nopen Rew\n\nlemma lMap_bind (b : Fin n\u2081 \u2192 Semiterm L\u2081 \u03be\u2082 n\u2082) (e : \u03be\u2081 \u2192 Semiterm L\u2081 \u03be\u2082 n\u2082) (t) :\n    lMap \u03a6 (bind b e t) = bind (lMap \u03a6 \u2218 b) (lMap \u03a6 \u2218 e) (t.lMap \u03a6) :=\n  by induction t <;> simp[*, lMap_func, Rew.func]\n\nlemma lMap_map (b : Fin n\u2081 \u2192 Fin n\u2082) (e : \u03be\u2081 \u2192 \u03be\u2082) (t) :\n    (map b e t).lMap \u03a6 = map b e (t.lMap \u03a6) := by\n  simp [map, lMap_bind, Function.comp_def]\n\nlemma lMap_bShift (t : Semiterm L\u2081 \u03be\u2081 n) : (bShift t).lMap \u03a6 = bShift (t.lMap \u03a6) :=\n  by simp[bShift, lMap_map]\n\nlemma lMap_shift (t : SyntacticSemiterm L\u2081 n) : (shift t).lMap \u03a6 = shift (t.lMap \u03a6) :=\n  by simp[shift, lMap_map]\n\nlemma lMap_free (t : SyntacticSemiterm L\u2081 (n + 1)) : (free t).lMap \u03a6 = free (t.lMap \u03a6) :=\n  by simp[free, lMap_bind]; congr; exact funext $ Fin.lastCases (by simp) (by simp)\n\nlemma lMap_fix (t : SyntacticSemiterm L\u2081 n) : (fix t).lMap \u03a6 = fix (t.lMap \u03a6) :=\n  by simp[fix, lMap_bind]; congr; funext x; cases x <;> simp\n\nend lMap\n\nlemma fvar?_rew [DecidableEq \u03be\u2081] [DecidableEq \u03be\u2082]\n    {\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082}\n    {t : Semiterm L \u03be\u2081 n\u2081} {x} :\n    (\u03c9 t).FVar? x \u2192 (\u2203 i : Fin n\u2081, (\u03c9 #i).FVar? x) \u2228 (\u2203 z : \u03be\u2081, t.FVar? z \u2227 (\u03c9 &z).FVar? x) := by\n  induction t\n  case bvar z =>\n    intro h; left; exact \u27e8z, h\u27e9\n  case fvar z =>\n    intro h; right; exact \u27e8z, by simp [h]\u27e9\n  case func k F v ih =>\n    simp only [Rew.func, fvar?_func, forall_exists_index]\n    intro i hx\n    rcases ih i hx with (h | \u27e8z, hi, hz\u27e9)\n    \u00b7 left; exact h\n    \u00b7 right; exact \u27e8z, \u27e8i, hi\u27e9, hz\u27e9\n\n@[simp] lemma fvar?_bShift [DecidableEq \u03be] {t : Semiterm L \u03be n} {x} :\n    (Rew.bShift t).FVar? x \u2194 t.FVar? x := by\n  induction t <;> simp [Rew.func, *]\n\ndef toEmpty [DecidableEq \u03be] {n : \u2115} : (t : Semiterm L \u03be n) \u2192 t.freeVariables = \u2205 \u2192 Semiterm L Empty n\n  | #x,        _ => #x\n  | &x,        h => by simp at h\n  | func f v, h =>\n    have : \u2200 i, (v i).freeVariables = \u2205 := by\n      intro i; ext x\n      have := by simpa using Eq.to_iff (congrFun (congrArg Membership.mem h) x)\n      simpa using this i\n    func f fun i \u21a6 toEmpty (v i) (this i)\n\n@[simp] lemma emb_toEmpty [DecidableEq \u03be] (t : Semiterm L \u03be n) (ht : t.freeVariables = \u2205) : Rew.emb (t.toEmpty ht) = t := by\n  induction t <;> try simp [toEmpty, Rew.func, *]\n  case fvar => simp at ht\n\nend Semiterm\n\n/-!\n### Rewriting system of formulae\n\n-/\n\nclass FreeVar (\u03be : outParam Type*) (F : \u2115 \u2192 Type*) where\n\nclass Rewriting (L : outParam Language) (\u03be : outParam Type*) (F : \u2115 \u2192 Type*) (\u03b6 : Type*) (G : outParam (\u2115 \u2192 Type*))\n    [LCWQ F] [LCWQ G] where\n  app {n\u2081 n\u2082} : Rew L \u03be n\u2081 \u03b6 n\u2082 \u2192 F n\u2081 \u2192\u02e1\u1d9c G n\u2082\n  app_all (\u03c9\u2081\u2082 : Rew L \u03be n\u2081 \u03b6 n\u2082) (\u03c6) : app \u03c9\u2081\u2082 (\u2200' \u03c6) = \u2200' (app \u03c9\u2081\u2082.q \u03c6)\n  app_ex (\u03c9\u2081\u2082 : Rew L \u03be n\u2081 \u03b6 n\u2082) (\u03c6) : app \u03c9\u2081\u2082 (\u2203' \u03c6) = \u2203' (app \u03c9\u2081\u2082.q \u03c6)\n\nabbrev SyntacticRewriting (L : outParam Language) (F : \u2115 \u2192 Type*) (G : outParam (\u2115 \u2192 Type*)) [LCWQ F] [LCWQ G] :=\n  Rewriting L \u2115 F \u2115 G\n\nnamespace Rewriting\n\nvariable [LCWQ F] [LCWQ G] [Rewriting L \u03be F \u03b6 G]\n\nattribute [simp] app_all app_ex\n\ninfixr:73 \" \u25b9 \" => app\n\nlemma smul_ext' {\u03c9\u2081 \u03c9\u2082 : Rew L \u03be n\u2081 \u03b6 n\u2082} (h : \u03c9\u2081 = \u03c9\u2082) {\u03c6 : F n\u2081} : \u03c9\u2081 \u25b9 \u03c6 = \u03c9\u2082 \u25b9 \u03c6 := by rw [h]\n\n@[simp] lemma smul_ball (\u03c9 : Rew L \u03be n\u2081 \u03b6 n\u2082) (\u03c6 \u03c8 : F (n\u2081 + 1)) : \u03c9 \u25b9 (\u2200[\u03c6] \u03c8) = \u2200[\u03c9.q \u25b9 \u03c6] (\u03c9.q \u25b9 \u03c8) := by simp [ball]\n\n@[simp] lemma smul_bex (\u03c9 : Rew L \u03be n\u2081 \u03b6 n\u2082) (\u03c6 \u03c8 : F (n\u2081 + 1)) : \u03c9 \u25b9 (\u2203[\u03c6] \u03c8) = \u2203[\u03c9.q \u25b9 \u03c6] (\u03c9.q \u25b9 \u03c8) := by simp [bex]\n\nabbrev substitute [Rewriting L \u03be F \u03be F] (\u03c6 : F n\u2081) (w : Fin n\u2081 \u2192 Semiterm L \u03be n\u2082) : F n\u2082 := Rew.substs w \u25b9 \u03c6\n\ninfix:90 \" \u21dc \" => LO.FirstOrder.Rewriting.substitute\n\nabbrev shift [Rewriting L \u2115 F \u2115 F] (\u03c6 : F n) : F n := @Rew.shift L n \u25b9 \u03c6\n\nabbrev free [Rewriting L \u2115 F \u2115 F] (\u03c6 : F (n + 1)) : F n := @Rew.free L n \u25b9 \u03c6\n\nabbrev fix [Rewriting L \u2115 F \u2115 F] (\u03c6 : F n) : F (n + 1) := @Rew.fix L n \u25b9 \u03c6\n\ndef shifts [Rewriting L \u2115 F \u2115 F] (\u0393 : List (F n)) : List (F n) := \u0393.map Rewriting.shift\n\nscoped[LO.FirstOrder] postfix:max \"\u207a\" => FirstOrder.Rewriting.shifts\n\n@[coe] abbrev embedding {\u03bf \u03be} [IsEmpty \u03bf] {O F : \u2115 \u2192 Type*} [LCWQ O] [LCWQ F] [Rewriting L \u03bf O \u03be F] (\u03c6 : O n) : F n := @Rew.emb L \u03bf _ \u03be n \u25b9 \u03c6\n\nend Rewriting\n\nsection Notation\n\nopen Lean PrettyPrinter Delaborator\n\nsyntax (name := substituteNotation) term:max \"/[\" term,* \"]\" : term\n\nmacro_rules (kind := substituteNotation)\n  | `($\u03c6:term /[$terms:term,*]) => `($\u03c6 \u21dc ![$terms,*])\n\n@[app_unexpander Rewriting.substitute]\ndef _root_.unexpsnderSubstitute : Unexpander\n  | `($_ $\u03c6:term ![$ts:term,*]) => `($\u03c6 /[ $ts,* ])\n  | _                           => throw ()\n\nend Notation\n\nclass ReflectiveRewriting (L : outParam Language) (\u03be : outParam Type*) (F : \u2115 \u2192 Type*)\n    [LCWQ F] [Rewriting L \u03be F \u03be F] where\n  id_app (\u03c6 : F n) : @Rew.id L \u03be n \u25b9 \u03c6 = \u03c6\n\nclass TransitiveRewriting (L : outParam Language)\n    (\u03be\u2081 : outParam Type*) (F\u2081 : \u2115 \u2192 Type*) (\u03be\u2082 : Type*) (F\u2082 : outParam (\u2115 \u2192 Type*)) (\u03be\u2083 : Type*) (F\u2083 : outParam (\u2115 \u2192 Type*))\n    [LCWQ F\u2081] [LCWQ F\u2082] [LCWQ F\u2083]\n    [Rewriting L \u03be\u2081 F\u2081 \u03be\u2082 F\u2082] [Rewriting L \u03be\u2082 F\u2082 \u03be\u2083 F\u2083] [Rewriting L \u03be\u2081 F\u2081 \u03be\u2083 F\u2083] where\n  comp_app (\u03c9\u2081\u2082 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) (\u03c9\u2082\u2083 : Rew L \u03be\u2082 n\u2082 \u03be\u2083 n\u2083) (\u03c6 : F\u2081 n\u2081) : (\u03c9\u2082\u2083.comp \u03c9\u2081\u2082) \u25b9 \u03c6 = \u03c9\u2082\u2083 \u25b9 \u03c9\u2081\u2082 \u25b9 \u03c6\n\nclass InjMapRewriting (L : outParam Language) (\u03be : outParam Type*) (F : \u2115 \u2192 Type*) (\u03b6 : Type*) (G : outParam (\u2115 \u2192 Type*))\n    [LCWQ F] [LCWQ G] [Rewriting L \u03be F \u03b6 G] where\n  smul_map_injective {b : Fin n\u2081 \u2192 Fin n\u2082} {f : \u03be \u2192 \u03b6} :\n    (hb : Function.Injective b) \u2192 (hf : Function.Injective f) \u2192 Function.Injective fun \u03c6 : F n\u2081 \u21a6 Rew.map (L := L) b f \u25b9 \u03c6\n\nclass LawfulSyntacticRewriting (L : outParam Language) (S : \u2115 \u2192 Type*) [LCWQ S] [SyntacticRewriting L S S] extends\n  ReflectiveRewriting L \u2115 S, TransitiveRewriting L \u2115 S \u2115 S \u2115 S, InjMapRewriting L \u2115 S \u2115 S\n\nattribute [simp] ReflectiveRewriting.id_app\n\nnamespace LawfulSyntacticRewriting\n\nvariable {S : \u2115 \u2192 Type*} [LCWQ S] [SyntacticRewriting L S S]\n\nopen Rewriting ReflectiveRewriting TransitiveRewriting InjMapRewriting\n\nlemma fix_allClosure (\u03c6 : S n) :\n    \u2200' fix (\u2200* \u03c6) = \u2200* fix \u03c6 := by\n  induction n\n  case zero => simp [univClosure_succ]\n  case succ n ih => simp [univClosure_succ, ih]\n\n@[simp] lemma shifts_cons (\u03c6 : S n) (\u0393 : List (S n)) :\n    (\u03c6 :: \u0393)\u207a = Rewriting.shift \u03c6 :: \u0393\u207a := by simp [shifts]\n\n@[simp] lemma shifts_nil : ([] : List (S n))\u207a = [] := by rfl\n\nlemma shifts_union (\u0393 \u0394 : List (S n)) :\n    (\u0393 ++ \u0394)\u207a = \u0393\u207a ++ \u0394\u207a := by simp [shifts]\n\nlemma shifts_neg (\u0393 : List (S n)) :\n    (\u0393.map (\u223c\u00b7))\u207a = (\u0393\u207a).map (\u223c\u00b7) := by simp [shifts]\n\nlemma shift_conj\u2082 (\u0393 : List (S n)) : shift (\u22c0\u0393) = \u22c0\u0393\u207a := by\n  induction \u0393 using List.induction_with_singleton\n  case hnil => simp\n  case hsingle => simp\n  case hcons \u03c6 \u0393 h\u0393 ih =>\n    have : \u0393\u207a \u2260 [] := by intro H; have : \u0393 = [] := List.map_eq_nil_iff.mp H; contradiction\n    simp [h\u0393, this, ih]\n\nvariable [LawfulSyntacticRewriting L S]\n\nlemma shift_injective : Function.Injective fun \u03c6 : S n \u21a6 shift \u03c6 :=\n  smul_map_injective Function.injective_id Nat.succ_injective\n\n@[simp] lemma fix_free (\u03c6 : S (n + 1)) :\n    fix (free \u03c6) = \u03c6 := by simp [\u2190comp_app]\n\n@[simp] lemma free_fix (\u03c6 : S n) :\n    free (fix \u03c6) = \u03c6 := by simp [\u2190comp_app]\n\n@[simp] lemma substitute_empty (\u03c6 : S 0) (v : Fin 0 \u2192 Semiterm L \u2115  0) : (\u03c6 \u21dc v) = \u03c6 := by simp [substitute]\n\n/-- `hom_substs_mbar_zero_comp_shift_eq_free` -/\n@[simp] lemma app_substs_fbar_zero_comp_shift_eq_free (\u03c6 : S 1) :\n    (shift \u03c6)/[&0] = free \u03c6 := by simp [\u2190 comp_app, Rew.substs_mbar_zero_comp_shift_eq_free]\n\nlemma free_rewrite_eq (f : \u2115 \u2192 SyntacticTerm L) (\u03c6 : S 1) :\n    free ((Rew.rewrite fun x \u21a6 Rew.bShift (f x)) \u25b9 \u03c6) =\n    Rew.rewrite (&0 :>\u2099 fun x \u21a6 Rew.shift (f x)) \u25b9 free \u03c6 := by\n  simpa [\u2190 comp_app] using smul_ext' <| by ext x <;> simp [Rew.comp_app, Fin.eq_zero]\n\nlemma shift_rewrite_eq (f : \u2115 \u2192 SyntacticTerm L) (\u03c6 : S 0) :\n    shift (Rew.rewrite f \u25b9 \u03c6) = (Rew.rewrite (&0 :>\u2099 fun x \u21a6 Rew.shift (f x))) \u25b9 shift \u03c6 := by\n  simpa [\u2190comp_app] using smul_ext' <| by ext x <;> simp [Rew.comp_app]\n\nlemma rewrite_subst_eq (f : \u2115 \u2192 SyntacticTerm L) (t) (\u03c6 : S 1) :\n    Rew.rewrite f \u25b9 \u03c6/[t] = (Rew.rewrite (Rew.bShift \u2218 f) \u25b9 \u03c6)/[Rew.rewrite f t] := by\n  simpa [\u2190comp_app] using smul_ext' <| by ext x <;> simp[Rew.comp_app]\n\n@[simp] lemma free_substs_nil (\u03c6 : S 0) : free (Rewriting.substitute (\u03be := \u2115) \u03c6 ![]) = shift \u03c6 := by\n  simpa [\u2190comp_app] using smul_ext' <| by\n    ext x <;> simp only [Rew.comp_app, Rew.substs_fvar, Rew.free_fvar, Rew.shift_fvar]; { exact Fin.elim0 x }\n\nlemma rewrite_substs_nil (f : \u2115 \u2192 SyntacticTerm L) (\u03c6 : S 0) :\n    Rew.rewrite (Rew.bShift \u2218 f) \u25b9 (Rewriting.substitute (\u03be := \u2115) \u03c6 ![]) =\n    Rewriting.substitute (\u03be := \u2115) (Rew.rewrite f \u25b9 \u03c6) ![] := by\n  simpa [\u2190comp_app] using smul_ext' <| by\n    ext x\n    \u00b7 exact x.elim0\n    \u00b7 simp [Rew.comp_app, Rew.bShift_eq_rewrite]\n\n", "theoremStatement": "@[simp] lemma cast_substs_eq (t : SyntacticTerm L) (\u03c6 : S 0) :\n    (Rewriting.substitute (\u03be := \u2115) \u03c6 ![])/[t] = \u03c6 ", "theoremName": "LO.FirstOrder.LawfulSyntacticRewriting.cast_substs_eq", "fileCreated": {"commit": "f9b24e7d45330d9c809d246bb25b3aeccf722ef3", "date": "2024-11-06"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/Logic/Predicate/Rew.lean", "module": "Foundation.Logic.Predicate.Rew", "jsonFile": "Foundation.Logic.Predicate.Rew.jsonl", "positionMetadata": {"lineInFile": 891, "tokenPositionInFile": 33898, "theoremPositionInFile": 188}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 19, "repositoryPremises": true, "numRepositoryPremises": 28, "numPremises": 49}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  suffices (Rewriting.substitute (\u03be := \u2115) \u03c6 ![])/[t] = Rew.id \u25b9 \u03c6 by rwa [ReflectiveRewriting.id_app] at this\n  simpa [\u2190comp_app, -id_app] using smul_ext' <| by\n    ext x <;> simp only [Rew.comp_app, Rew.substs_bvar, Rew.substs_fvar, Rew.id_app]\n    exact x.elim0", "proofType": "tactic", "proofLengthLines": 4, "proofLengthTokens": 269}}
{"srcContext": "import Foundation.IntFO.Translation\n\n/-!\n#Algebraic Proofs of Cut Elimination\n\nMain reference: Jeremy Avigad, Algebraic proofs of cut elimination, The Journal of Logic and Algebraic Programming, Volume 49, Issues 1\u20132, 2001, Pages 15-30\n -/\n\nnamespace LO.FirstOrder\n\nvariable {L : Language.{u}}\n\nnamespace Derivation\n\ninductive IsCutFree : {\u0393 : Sequent L} \u2192 \u22a2\u1d40 \u0393 \u2192 Prop\n| axL (\u0393) {k} (r : L.Rel k) (v)                 : IsCutFree (axL \u0393 r v)\n| verum (\u0393)                                     : IsCutFree (verum \u0393)\n| or {\u0393 \u03c6 \u03c8} {d : \u22a2\u1d40 \u03c6 :: \u03c8 :: \u0393}               : IsCutFree d \u2192 IsCutFree d.or\n| and {\u0393 \u03c6 \u03c8} {d\u03c6 : \u22a2\u1d40 \u03c6 :: \u0393} {d\u03c8 : \u22a2\u1d40 \u03c8 :: \u0393} : IsCutFree d\u03c6 \u2192 IsCutFree d\u03c8 \u2192 IsCutFree (d\u03c6.and d\u03c8)\n| all {\u0393 \u03c6} {d : \u22a2\u1d40 Rewriting.free \u03c6 :: \u0393\u207a}     : IsCutFree d \u2192 IsCutFree d.all\n| ex {\u0393 \u03c6} (t) {d : \u22a2\u1d40 \u03c6/[t] :: \u0393}              : IsCutFree d \u2192 IsCutFree d.ex\n| wk {\u0394 \u0393} {d : \u22a2\u1d40 \u0394} (ss : \u0394 \u2286 \u0393)              : IsCutFree d \u2192 IsCutFree (d.wk ss)\n\nattribute [simp] IsCutFree.axL IsCutFree.verum\n\nvariable {\u0393 \u0394 : Sequent L}\n\n@[simp] lemma isCutFree_or_iff {d : \u22a2\u1d40 \u03c6 :: \u03c8 :: \u0393} :\n    IsCutFree d.or \u2194 IsCutFree d := \u27e8by rintro \u27e8\u27e9; assumption, .or\u27e9\n\n@[simp] lemma isCutFree_and_iff {d\u03c6 : \u22a2\u1d40 \u03c6 :: \u0393} {d\u03c8 : \u22a2\u1d40 \u03c8 :: \u0393} :\n    IsCutFree (d\u03c6.and d\u03c8) \u2194 IsCutFree d\u03c6 \u2227 IsCutFree d\u03c8 :=\n  \u27e8by rintro \u27e8\u27e9; constructor <;> assumption, by intro \u27e8h\u03c6, h\u03c8\u27e9; exact h\u03c6.and h\u03c8\u27e9\n\n@[simp] lemma isCutFree_all_iff {d : \u22a2\u1d40 Rewriting.free \u03c6 :: \u0393\u207a} :\n    IsCutFree d.all \u2194 IsCutFree d := \u27e8by rintro \u27e8\u27e9; assumption, .all\u27e9\n\n@[simp] lemma isCutFree_ex_iff {d : \u22a2\u1d40 \u03c6/[t] :: \u0393} :\n    IsCutFree d.ex \u2194 IsCutFree d := \u27e8by rintro \u27e8\u27e9; assumption, .ex t\u27e9\n\n@[simp] lemma isCutFree_wk_iff {d : \u22a2\u1d40 \u0394} {ss : \u0394 \u2286 \u0393} :\n    IsCutFree (d.wk ss) \u2194 IsCutFree d := \u27e8by rintro \u27e8\u27e9; assumption, .wk _\u27e9\n\n@[simp] lemma IsCutFree.cast {d : \u22a2\u1d40 \u0393} {e : \u0393 = \u0394} :\n    IsCutFree (.cast d e) \u2194 IsCutFree d := by rcases e; rfl\n\n@[simp] lemma IsCutFree.not_cut (dp : \u22a2\u1d40 \u03c6 :: \u0393) (dn : \u22a2\u1d40 \u223c\u03c6 :: \u0393) : \u00acIsCutFree (dp.cut dn) := by rintro \u27e8\u27e9\n\n@[simp] lemma isCutFree_rewrite_iff_isCutFree {f : \u2115 \u2192 SyntacticTerm L} {d : \u22a2\u1d40 \u0393} :\n    IsCutFree (rewrite d f) \u2194 IsCutFree d := by\n  induction d generalizing f <;> simp [rewrite, *]\n  case root => contradiction\n\n@[simp] lemma isCutFree_map_iff_isCutFree {f : \u2115 \u2192 \u2115} {d : \u22a2\u1d40 \u0393} :\n    IsCutFree (Derivation.map d f) \u2194 IsCutFree d := isCutFree_rewrite_iff_isCutFree\n\n@[simp] lemma IsCutFree.genelalizeByNewver_isCutFree {\u03c6 : SyntacticSemiformula L 1} (hp : \u00ac\u03c6.FVar? m) (h\u0394 : \u2200 \u03c8 \u2208 \u0394, \u00ac\u03c8.FVar? m)\n    (d : \u22a2\u1d40 \u03c6/[&m] :: \u0394) : IsCutFree (genelalizeByNewver hp h\u0394 d) \u2194 IsCutFree d := by simp [genelalizeByNewver]\n\nend Derivation\n\ninductive PositiveDerivationFrom (\u039e : Sequent L) : Sequent L \u2192 Type _\n| verum (\u0393)    : PositiveDerivationFrom \u039e (\u22a4 :: \u0393)\n| or {\u0393 \u03c6 \u03c8}   : PositiveDerivationFrom \u039e (\u03c6 :: \u03c8 :: \u0393) \u2192 PositiveDerivationFrom \u039e (\u03c6 \u22ce \u03c8 :: \u0393)\n| ex {\u0393 \u03c6} (t) : PositiveDerivationFrom \u039e (\u03c6/[t] :: \u0393) \u2192 PositiveDerivationFrom \u039e ((\u2203' \u03c6) :: \u0393)\n| wk {\u0393 \u0394}     : PositiveDerivationFrom \u039e \u0394 \u2192 \u0394 \u2286 \u0393 \u2192 PositiveDerivationFrom \u039e \u0393\n| protected id : PositiveDerivationFrom \u039e \u039e\n\ninfix:45 \" \u27f6\u207a \" => PositiveDerivationFrom\n\nnamespace PositiveDerivationFrom\n\nvariable {\u039e \u0393 \u0394 : Sequent L}\n\ndef ofSubset (ss : \u039e \u2286 \u0393) : \u039e \u27f6\u207a \u0393 := wk .id ss\n\ndef trans {\u039e \u0393 \u0394 : Sequent L} : \u039e \u27f6\u207a \u0393 \u2192 \u0393 \u27f6\u207a \u0394 \u2192 \u039e \u27f6\u207a \u0394\n  | _, verum \u0393 => verum \u0393\n  | b, or d    => or (b.trans d)\n  | b, ex t d  => ex t (b.trans d)\n  | b, wk d h  => wk (b.trans d) h\n  | b, .id     => b\n\ndef cons {\u039e \u0393 : Sequent L} (\u03c6) : \u039e \u27f6\u207a \u0393 \u2192 \u03c6 :: \u039e \u27f6\u207a \u03c6 :: \u0393\n  | verum \u0393         => wk (verum \u0393) (List.subset_cons_self _ _)\n  | @or _ _ \u0393 \u03c8 \u03c7 d =>\n    have : \u03c6 :: \u039e \u27f6\u207a \u03c8 :: \u03c7 :: \u03c6 :: \u0393 := wk (cons \u03c6 d) (by simp; tauto)\n    wk (or this) (by simp)\n  | @ex _ \u039e \u0393 \u03c8 t d =>\n    have : \u03c6 :: \u039e \u27f6\u207a \u03c8/[t] :: \u03c6 :: \u0393 := wk (cons \u03c6 d) (by simp)\n    wk this.ex (by simp)\n  | wk d h          => wk (d.cons \u03c6) (by simp [h])\n  | .id             => .id\n\ndef append {\u039e \u0393 : Sequent L} : (\u0394 : Sequent L) \u2192 \u039e \u27f6\u207a \u0393 \u2192 \u0394 ++ \u039e \u27f6\u207a \u0394 ++ \u0393\n  | [],     d => d\n  | \u03c6 :: \u0394, d => (d.append \u0394).cons \u03c6\n\ndef add {\u0393 \u0394 \u039e \u0398 : Sequent L} : \u0393 \u27f6\u207a \u0394 \u2192 \u039e \u27f6\u207a \u0398 \u2192 \u0393 ++ \u039e \u27f6\u207a \u0394 ++ \u0398\n  | verum \u0394, d => verum _\n  | or d,    b => or (d.add b)\n  | ex t d,  b => ex t (d.add b)\n  | wk d h,  b => wk (d.add b) (by simp [h])\n  | .id,     b => b.append \u0393\n\ndef graft {\u039e \u0393 : Sequent L} (b : \u22a2\u1d40 \u039e) : \u039e \u27f6\u207a \u0393 \u2192 \u22a2\u1d40 \u0393\n  | verum \u0393 => .verum \u0393\n  | or d    => .or (d.graft b)\n  | ex t d  => .ex t (d.graft b)\n  | wk d h  => .wk (d.graft b) h\n  | .id     => b\n\nlemma graft_isCutFree_of_isCutFree {b : \u22a2\u1d40 \u039e} {d : \u039e \u27f6\u207a \u0393} (hb : Derivation.IsCutFree b) : Derivation.IsCutFree (d.graft b) := by\n  induction d <;> simp [graft, *]\n\nend PositiveDerivationFrom\n\nnamespace Hauptsatz\n\nopen Semiformula\u1d62\n\nlocal notation \"\u2119\" => Sequent L\n\nstructure StrongerThan (q p : \u2119) where\n  val : \u223cp \u27f6\u207a \u223cq\n\nscoped infix:60 \" \u227c \" => StrongerThan\n\nscoped instance : Min \u2119 := \u27e8fun p q \u21a6 p ++ q\u27e9\n\nlemma inf_def (p q : \u2119) : p \u2293 q = p ++ q := rfl\n\n", "theoremStatement": "@[simp] lemma neg_inf_p_eq (p q : \u2119) : \u223c(p \u2293 q) = \u223cp \u2293 \u223cq ", "theoremName": "LO.FirstOrder.Hauptsatz.neg_inf_p_eq", "fileCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/FirstOrder/Hauptsatz.lean", "module": "Foundation.FirstOrder.Hauptsatz", "jsonFile": "Foundation.FirstOrder.Hauptsatz.jsonl", "positionMetadata": {"lineInFile": 133, "tokenPositionInFile": 4840, "theoremPositionInFile": 15}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 8, "numPremises": 14}, "proofMetadata": {"hasProof": true, "proof": ":= List.map_append _ _ _", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 24}}
{"srcContext": "import Foundation.IntFO.Basic.Rew\n\nnamespace LO.FirstOrder\n\nabbrev Sequent\u1d62 (L : Language) := List (SyntacticFormula\u1d62 L)\n\nopen Semiformula\u1d62\n\nvariable {L : Language} {T : Theory L}\n\nstructure Hilbert\u1d62 (L : Language) where\n  axiomSet : Set (SyntacticFormula\u1d62 L)\n  rewrite_closed {\u03c6 : SyntacticFormula\u1d62 L} : \u03c6 \u2208 axiomSet \u2192 \u2200 f : \u2115 \u2192 SyntacticTerm L, Rew.rewrite f \u25b9 \u03c6 \u2208 axiomSet\n\ninstance : SetLike (Hilbert\u1d62 L) (SyntacticFormula\u1d62 L) where\n  coe := Hilbert\u1d62.axiomSet\n  coe_injective' := by rintro \u27e8T, _\u27e9 \u27e8U, _\u27e9; simp\n\nnamespace Hilbert\u1d62\n\ndef Minimal : Hilbert\u1d62 L := \u27e8\u2205, by simp\u27e9\n\nnotation \"\ud835\udc0c\ud835\udc22\ud835\udc27\u00b9\" => Minimal\n\ndef Intuitionistic : Hilbert\u1d62 L := \u27e8{\u22a5 \u279d \u03c6 | \u03c6}, by rintro _ \u27e8\u03c6, rfl\u27e9 f; exact \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\u27e9\n\nnotation \"\ud835\udc08\ud835\udc27\ud835\udc2d\u00b9\" => Intuitionistic\n\ndef Classical : Hilbert\u1d62 L := \u27e8{\u22a5 \u279d \u03c6 | \u03c6} \u222a {\u03c6 \u22ce \u223c\u03c6 | \u03c6}, by\n  rintro _ (\u27e8\u03c6, rfl\u27e9 | \u27e8\u03c6, rfl\u27e9) f\n  \u00b7 exact Or.inl \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\n  \u00b7 exact Or.inr \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\u27e9\n\nnotation \"\ud835\udc02\ud835\udc25\u00b9\" => Classical\n\nlemma minimal_le (\u039b : Hilbert\u1d62 L) : (Minimal : Hilbert\u1d62 L) \u2264 \u039b := by rintro _ \u27e8\u27e9\n\nlemma intuitionistic_le_classical : (Intuitionistic : Hilbert\u1d62 L) \u2264 Classical := by rintro _ \u27e8\u03c6, rfl\u27e9; exact .inl \u27e8\u03c6, rfl\u27e9\n\nend Hilbert\u1d62\n\ninductive HilbertProof\u1d62 (\u039b : Hilbert\u1d62 L) : SyntacticFormula\u1d62 L \u2192 Type _\n  | eaxm {\u03c6}     : \u03c6 \u2208 \u039b \u2192 HilbertProof\u1d62 \u039b \u03c6\n  | mdp {\u03c6 \u03c8}    : HilbertProof\u1d62 \u039b (\u03c6 \u279d \u03c8) \u2192 HilbertProof\u1d62 \u039b \u03c6 \u2192 HilbertProof\u1d62 \u039b \u03c8\n  | gen {\u03c6}      : HilbertProof\u1d62 \u039b (Rewriting.free \u03c6) \u2192 HilbertProof\u1d62 \u039b (\u2200' \u03c6)\n  | verum        : HilbertProof\u1d62 \u039b \u22a4\n  | imply\u2081 \u03c6 \u03c8   : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c8 \u279d \u03c6\n  | imply\u2082 \u03c6 \u03c8 \u03c7 : HilbertProof\u1d62 \u039b <| (\u03c6 \u279d \u03c8 \u279d \u03c7) \u279d (\u03c6 \u279d \u03c8) \u279d \u03c6 \u279d \u03c7\n  | and\u2081 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u22cf \u03c8 \u279d \u03c6\n  | and\u2082 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u22cf \u03c8 \u279d \u03c8\n  | and\u2083 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c8 \u279d \u03c6 \u22cf \u03c8\n  | or\u2081 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c6 \u22ce \u03c8\n  | or\u2082 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u03c8 \u279d \u03c6 \u22ce \u03c8\n  | or\u2083 \u03c6 \u03c8 \u03c7    : HilbertProof\u1d62 \u039b <| (\u03c6 \u279d \u03c7) \u279d (\u03c8 \u279d \u03c7) \u279d (\u03c6 \u22ce \u03c8 \u279d \u03c7)\n  | all\u2081 \u03c6 t     : HilbertProof\u1d62 \u039b <| \u2200' \u03c6 \u279d \u03c6/[t]\n  | all\u2082 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u2200' (\u03c6/[] \u279d \u03c8) \u279d \u03c6 \u279d \u2200' \u03c8\n  | ex\u2081 t \u03c6      : HilbertProof\u1d62 \u039b <| \u03c6/[t] \u279d \u2203' \u03c6\n  | ex\u2082 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u2200' (\u03c6 \u279d \u03c8/[]) \u279d \u2203' \u03c6 \u279d \u03c8\n\ninstance : System (SyntacticFormula\u1d62 L) (Hilbert\u1d62 L) := \u27e8HilbertProof\u1d62\u27e9\n\nnamespace HilbertProof\u1d62\n\nopen System.FiniteContext Rewriting LawfulSyntacticRewriting\n\nvariable (\u039b : Hilbert\u1d62 L)\n\ninstance : System.ModusPonens \u039b := \u27e8mdp\u27e9\n\ninstance : System.HasAxiomAndInst \u039b := \u27e8and\u2083\u27e9\n\ninstance : System.HasAxiomImply\u2081 \u039b := \u27e8imply\u2081\u27e9\n\ninstance : System.HasAxiomImply\u2082 \u039b := \u27e8imply\u2082\u27e9\n\ninstance : System.Minimal \u039b where\n  mdp := mdp\n  verum := verum\n  imply\u2081 := imply\u2081\n  imply\u2082 := imply\u2082\n  and\u2081 := and\u2081\n  and\u2082 := and\u2082\n  and\u2083 := and\u2083\n  or\u2081 := or\u2081\n  or\u2082 := or\u2082\n  or\u2083 := or\u2083\n  neg_equiv _ := System.iffId _\n\nvariable {\u039b}\n\nprotected def cast {\u03c6 \u03c8} (b : \u039b \u22a2 \u03c6) (e : \u03c6 = \u03c8) : \u039b \u22a2 \u03c8 := e \u25b8 b\n\ndef depth {\u03c6} : \u039b \u22a2 \u03c6 \u2192 \u2115\n  | mdp b d => max (depth b) (depth d) + 1\n  | gen b   => depth b + 1\n  | _       => 0\n\nscoped notation \"\u2016\" d \"\u2016\" => depth d\n\n@[simp] lemma depth_eaxm (h : \u03c6 \u2208 \u039b) : \u2016eaxm h\u2016 = 0 := rfl\n@[simp] lemma depth_mdp (b : \u039b \u22a2 \u03c6 \u279d \u03c8) (d : \u039b \u22a2 \u03c6) : \u2016mdp b d\u2016 = max \u2016b\u2016 \u2016d\u2016 + 1 := rfl\n@[simp] lemma depth_gen (b : \u039b \u22a2 Rewriting.free \u03c6) : \u2016gen b\u2016 = \u2016b\u2016 + 1 := rfl\n@[simp] lemma depth_verum : \u2016(verum : \u039b \u22a2 \u22a4)\u2016 = 0 := rfl\n@[simp] lemma depth_imply\u2081 (\u03c6 \u03c8) : \u2016imply\u2081 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_imply\u2082 (\u03c6 \u03c8 \u03c7) : \u2016imply\u2082 (\u039b := \u039b) \u03c6 \u03c8 \u03c7\u2016 = 0 := rfl\n@[simp] lemma depth_and\u2081 (\u03c6 \u03c8) : \u2016and\u2081 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_and\u2082 (\u03c6 \u03c8) : \u2016and\u2082 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_and\u2083 (\u03c6 \u03c8) : \u2016and\u2083 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_or\u2081 (\u03c6 \u03c8) : \u2016or\u2081 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_or\u2082 (\u03c6 \u03c8) : \u2016or\u2082 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_or\u2083 (\u03c6 \u03c8 \u03c7) : \u2016or\u2083 (\u039b := \u039b) \u03c6 \u03c8 \u03c7\u2016 = 0 := rfl\n@[simp] lemma depth_all\u2081 (\u03c6 t) : \u2016all\u2081 (\u039b := \u039b) \u03c6 t\u2016 = 0 := rfl\n@[simp] lemma depth_all\u2082 (\u03c6 \u03c8) : \u2016all\u2082 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_ex\u2081 (t \u03c6) : \u2016ex\u2081 (\u039b := \u039b) t \u03c6\u2016 = 0 := rfl\n@[simp] lemma depth_ex\u2082 (\u03c6 \u03c8) : \u2016ex\u2082 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n\n@[simp] lemma depth_cast (b : \u039b \u22a2 \u03c6) (e : \u03c6 = \u03c8) : \u2016HilbertProof\u1d62.cast b e\u2016 = \u2016b\u2016 := by rcases e; rfl\n\n", "theoremStatement": "@[simp] lemma depth_mdp' (b : \u039b \u22a2 \u03c6 \u279d \u03c8) (d : \u039b \u22a2 \u03c6) : \u2016b \u2a00 d\u2016 = max \u2016b\u2016 \u2016d\u2016 + 1 ", "theoremName": "LO.FirstOrder.HilbertProof\u1d62.depth_mdp'", "fileCreated": {"commit": "7d9e3859942c3a17a697b129e7fb3869eca0066e", "date": "2024-11-09"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/IntFO/Basic/Deduction.lean", "module": "Foundation.IntFO.Basic.Deduction", "jsonFile": "Foundation.IntFO.Basic.Deduction.jsonl", "positionMetadata": {"lineInFile": 119, "tokenPositionInFile": 4150, "theoremPositionInFile": 28}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 11, "numPremises": 21}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "import Foundation.IntProp.Kripke.Basic\n\nnamespace LO.IntProp\n\n\nnamespace Kripke\n\nabbrev ClassicalValuation := \u2115 \u2192 Prop\n\nend Kripke\n\n\nnamespace Formula.Kripke\n\nopen IntProp.Kripke\n\nabbrev ClassicalSatisfies (V : ClassicalValuation) (\u03c6 : Formula \u2115) : Prop := Satisfies (\u27e8Kripke.pointFrame, \u27e8\u03bb _ => V, by tauto\u27e9\u27e9) () \u03c6\n\nnamespace ClassicalSatisfies\n\ninstance : Semantics (Formula \u2115) (ClassicalValuation) := \u27e8ClassicalSatisfies\u27e9\n\nvariable {V : ClassicalValuation} {a : \u2115}\n\n@[simp] lemma atom_def : V \u22a7 atom a \u2194 V a := by simp only [Semantics.Realize, Satisfies]\n\ninstance : Semantics.Tarski (ClassicalValuation) where\n  realize_top := by simp [Semantics.Realize, ClassicalSatisfies, Satisfies];\n  realize_bot := by simp [Semantics.Realize, ClassicalSatisfies, Satisfies];\n  realize_or  := by simp [Semantics.Realize, ClassicalSatisfies, Satisfies];\n  realize_and := by simp [Semantics.Realize, ClassicalSatisfies, Satisfies];\n  realize_imp := by simp [Semantics.Realize, Satisfies]; tauto;\n  realize_not := by simp [Semantics.Realize, Satisfies]; tauto;\n\nend ClassicalSatisfies\n\nend Formula.Kripke\n\n\nopen IntProp.Kripke\nopen Formula.Kripke (ClassicalSatisfies)\n\nnamespace Hilbert.Cl\n\n", "theoremStatement": "lemma classical_sound : (Hilbert.Cl \u2115) \u22a2! \u03c6 \u2192 (\u2200 V : ClassicalValuation, V \u22a7 \u03c6) ", "theoremName": "LO.IntProp.Hilbert.Cl.classical_sound", "fileCreated": {"commit": "b8e39aed3dd850a60a248755815bf358cbab9461", "date": "2024-11-10"}, "theoremCreated": {"commit": "830d76e560f33054a2eb2051cf1fa73997706985", "date": "2025-01-01"}, "file": "foundation/Foundation/IntProp/Kripke/Classical.lean", "module": "Foundation.IntProp.Kripke.Classical", "jsonFile": "Foundation.IntProp.Kripke.Classical.jsonl", "positionMetadata": {"lineInFile": 45, "tokenPositionInFile": 1180, "theoremPositionInFile": 3}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 17, "numPremises": 30}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  intro h V;\n  apply Hilbert.Cl.Kripke.sound.sound h Kripke.pointFrame;\n  simp [Euclidean];", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 97}}
{"srcContext": "import Foundation.Modal.Hilbert.Maximal.Unprovability\nimport Foundation.Modal.Kripke.GL.MDP\n\nnamespace LO.Modal\n\nopen System\nopen IntProp\n\nvariable [DecidableEq \u03b1]\n\ndef independency (\u03c6 : Formula \u03b1) := \u223c\u25a1\u03c6 \u22cf \u223c\u25a1(\u223c\u03c6)\n\ndef higherIndependency (\u03c6 : Formula \u03b1) : \u2115 \u2192 Formula \u03b1\n  | 0 => \u03c6\n  | n + 1 => independency (higherIndependency \u03c6 n)\n\nnamespace Hilbert.GL\n\nvariable {\u03c6 : Formula \u2115}\n\nlemma unprovable_notbox : (Hilbert.GL _) \u22ac \u223c\u25a1\u03c6 := by\n  by_contra hC;\n  have : (Hilbert.GL _) \u22a2! \u223c\u25a1\u03c6 \u279d \u223c\u25a1\u22a5 := contra\u2080'! (imply_box_distribute'! efq!)\n  have : Hilbert.GL _ \u22a2! \u223c\u25a1\u22a5 := this \u2a00 hC;\n  have : Hilbert.Cl \u2115 \u22a2! (\u22a5 \u279d \u22a5) \u279d \u22a5 := by simpa using provable_CL_verTranslated this;\n  simpa using Hilbert.Cl.classical_sound this;\n\nlemma unprovable_independency : (Hilbert.GL _) \u22ac independency \u03c6 := by\n  by_contra hC;\n  exact unprovable_notbox $ and\u2081'! hC;\n\nlemma unprovable_not_independency_of_consistency : (Hilbert.GL \u2115) \u22ac \u223c(independency (\u223c\u25a1\u22a5)) := by\n  by_contra hC;\n  rcases modal_disjunctive (dne_or! $ demorgan\u2084'! hC) with (h | h);\n  . exact unprovable_notbox h;\n  . exact Consistent.not_bot (inferInstance) $ unnec! $ dne'! h\n\n", "theoremStatement": "theorem undecidable_independency_of_consistency : Undecidable (Hilbert.GL \u2115) (independency (\u223c\u25a1\u22a5)) ", "theoremName": "LO.Modal.Hilbert.GL.undecidable_independency_of_consistency", "fileCreated": {"commit": "830d76e560f33054a2eb2051cf1fa73997706985", "date": "2025-01-01"}, "theoremCreated": {"commit": "830d76e560f33054a2eb2051cf1fa73997706985", "date": "2025-01-01"}, "file": "foundation/Foundation/Modal/Hilbert/GL_Independency.lean", "module": "Foundation.Modal.Hilbert.GL_Independency", "jsonFile": "Foundation.Modal.Hilbert.GL_Independency.jsonl", "positionMetadata": {"lineInFile": 38, "tokenPositionInFile": 1110, "theoremPositionInFile": 4}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 16, "numPremises": 19}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  constructor;\n  . exact unprovable_independency;\n  . exact unprovable_not_independency_of_consistency;", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 109}}
{"srcContext": "import Foundation.Modal.Kripke.Geach.Systems\n\nnamespace LO.Modal.Hilbert\n\nopen System\nopen Modal.Kripke\nopen Formula\nopen Formula.Kripke\n\n", "theoremStatement": "lemma KDB_weakerThan_KTB : (Hilbert.KDB \u2115) \u2264\u209b (Hilbert.KTB \u2115) ", "theoremName": "LO.Modal.Hilbert.KDB_weakerThan_KTB", "fileCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "theoremCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "file": "foundation/Foundation/Modal/Hilbert/WeakerThan/KDB_KTB.lean", "module": "Foundation.Modal.Hilbert.WeakerThan.KDB_KTB", "jsonFile": "Foundation.Modal.Hilbert.WeakerThan.KDB_KTB.jsonl", "positionMetadata": {"lineInFile": 10, "tokenPositionInFile": 138, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 22, "numPremises": 32}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  apply Kripke.weakerThan_of_subset_FrameClass SerialSymmetricFrameClass ReflexiveSymmetricFrameClass;\n  rintro F \u27e8F_refl, F_symm\u27e9;\n  refine \u27e8serial_of_refl F_refl, F_symm\u27e9;", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 179}}
{"srcContext": "import Foundation.Modal.Formula\n\nnamespace LO.Modal\n\nvariable {\u03b1 : Type u}\n\ninductive NNFormula (\u03b1 : Type u) : Type u where\n  | atom   : \u03b1 \u2192 NNFormula \u03b1\n  | natom  : \u03b1 \u2192 NNFormula \u03b1\n  | falsum : NNFormula \u03b1\n  | verum  : NNFormula \u03b1\n  | or     : NNFormula \u03b1 \u2192 NNFormula \u03b1 \u2192 NNFormula \u03b1\n  | and    : NNFormula \u03b1 \u2192 NNFormula \u03b1 \u2192 NNFormula \u03b1\n  | box    : NNFormula \u03b1 \u2192 NNFormula \u03b1\n  | dia    : NNFormula \u03b1 \u2192 NNFormula \u03b1\n  deriving DecidableEq\n\nnamespace NNFormula\n\nvariable {\u03c6 \u03c8 \u03c7 : NNFormula \u03b1}\n\ndef neg : NNFormula \u03b1 \u2192 NNFormula \u03b1\n  | atom a  => natom a\n  | natom a => atom a\n  | falsum  => verum\n  | verum   => falsum\n  | or \u03c6 \u03c8  => and (neg \u03c6) (neg \u03c8)\n  | and \u03c6 \u03c8 => or (neg \u03c6) (neg \u03c8)\n  | box \u03c6   => dia (neg \u03c6)\n  | dia \u03c6   => box (neg \u03c6)\n\ndef imp (\u03c6 \u03c8 : NNFormula \u03b1) : NNFormula \u03b1 := or (neg \u03c6) \u03c8\n\ninstance : BasicModalLogicalConnective (NNFormula \u03b1) where\n  tilde := neg\n  arrow := imp\n  wedge := and\n  vee := or\n  top := verum\n  bot := falsum\n  box := box\n  dia := dia\n\nlemma or_eq : or \u03c6 \u03c8 = \u03c6 \u22ce \u03c8 := rfl\n\nlemma and_eq : and \u03c6 \u03c8 = \u03c6 \u22cf \u03c8 := rfl\n\nlemma imp_eq : imp \u03c6 \u03c8 = \u03c6 \u279d \u03c8 := rfl\n\nlemma box_eq : box \u03c6 = \u25a1\u03c6 := rfl\n\nlemma dia_eq : dia \u03c6 = \u25c7\u03c6 := rfl\n\n@[simp] lemma imp_eq' : \u03c6 \u279d \u03c8 = \u223c\u03c6 \u22ce \u03c8 := rfl\n\n@[simp] lemma iff_eq : \u03c6 \u2b64 \u03c8 = (\u03c6 \u279d \u03c8) \u22cf (\u03c8 \u279d \u03c6) := rfl\n\nlemma falsum_eq : (falsum : NNFormula \u03b1) = \u22a5 := rfl\n\nlemma verum_eq : (verum : NNFormula \u03b1) = \u22a4 := rfl\n\n@[simp] lemma and_inj (\u03c6\u2081 \u03c8\u2081 \u03c6\u2082 \u03c8\u2082 : Formula \u03b1) : \u03c6\u2081 \u22cf \u03c6\u2082 = \u03c8\u2081 \u22cf \u03c8\u2082 \u2194 \u03c6\u2081 = \u03c8\u2081 \u2227 \u03c6\u2082 = \u03c8\u2082 := by simp[Wedge.wedge]\n\n@[simp] lemma or_inj (\u03c6\u2081 \u03c8\u2081 \u03c6\u2082 \u03c8\u2082 : Formula \u03b1) : \u03c6\u2081 \u22ce \u03c6\u2082 = \u03c8\u2081 \u22ce \u03c8\u2082 \u2194 \u03c6\u2081 = \u03c8\u2081 \u2227 \u03c6\u2082 = \u03c8\u2082 := by simp[Vee.vee]\n\n@[simp] lemma imp_inj (\u03c6\u2081 \u03c8\u2081 \u03c6\u2082 \u03c8\u2082 : Formula \u03b1) : \u03c6\u2081 \u279d \u03c6\u2082 = \u03c8\u2081 \u279d \u03c8\u2082 \u2194 \u03c6\u2081 = \u03c8\u2081 \u2227 \u03c6\u2082 = \u03c8\u2082 := by simp[Arrow.arrow]\n\n@[simp] lemma neg_inj (\u03c6 \u03c8 : Formula \u03b1) : \u223c\u03c6 = \u223c\u03c8 \u2194 \u03c6 = \u03c8 := by simp [NegAbbrev.neg];\n\nlemma neg_eq : neg \u03c6 = \u223c\u03c6 := rfl\n\n@[simp] lemma neg_atom (a : \u03b1) : \u223catom a = natom a := by rfl\n\n@[simp] lemma neg_natom (a : \u03b1) : \u223cnatom a = atom a := by rfl\n\nlemma negneg : \u223c\u223c\u03c6 = \u03c6 := by\n  induction \u03c6 with\n  | and \u03c6 \u03c8 ih\u03c6 ih\u03c8 =>\n    simp only [\u2190neg_eq, neg, and.injEq];\n    exact \u27e8ih\u03c6, ih\u03c8\u27e9;\n  | or \u03c6 \u03c8 ih\u03c6 ih\u03c8 =>\n    simp only [\u2190neg_eq, neg, or.injEq];\n    exact \u27e8ih\u03c6, ih\u03c8\u27e9;\n  | box \u03c6 ih\u03c6 =>\n    simp only [\u2190neg_eq, neg, box.injEq];\n    exact ih\u03c6;\n  | dia \u03c6 ih\u03c6 =>\n    simp only [\u2190neg_eq, neg, dia.injEq];\n    exact ih\u03c6;\n  | _ => tauto;\n\ninstance : ModalDeMorgan (NNFormula \u03b1) where\n  verum := by tauto;\n  falsum := by tauto;\n  and := by tauto;\n  or := by tauto;\n  box := by tauto;\n  dia := by tauto;\n  neg := \u03bb _ => negneg\n  imply := by tauto;\n\nsection toString\n\nvariable [ToString \u03b1]\ndef toStr : NNFormula \u03b1 \u2192 String\n  | atom a  => s!\"+{a}\"\n  | natom a => s!\"-{a}\"\n  | falsum  => \"\u22a5\"\n  | verum   => \"\u22a4\"\n  | or \u03c6 \u03c8  => s!\"({\u03c6.toStr} \u2228 {\u03c8.toStr})\"\n  | and \u03c6 \u03c8 => s!\"({\u03c6.toStr} \u2227 {\u03c8.toStr})\"\n  | box \u03c6   => s!\"\u25a1{\u03c6.toStr}\"\n  | dia \u03c6   => s!\"\u25c7{\u03c6.toStr}\"\ninstance : Repr (NNFormula \u03b1) := \u27e8fun t _ => toStr t\u27e9\n\nend toString\n\n\nsection toFormula\n\ndef toFormula : NNFormula \u03b1 \u2192 Formula \u03b1\n  | atom a  => Formula.atom a\n  | natom a => \u223cFormula.atom a\n  | \u22a5       => \u22a5\n  | \u22a4       => \u22a4\n  | \u03c6 \u22ce \u03c8   => \u03c6.toFormula \u22ce \u03c8.toFormula\n  | \u03c6 \u22cf \u03c8   => \u03c6.toFormula \u22cf \u03c8.toFormula\n  | \u25a1\u03c6      => \u25a1(\u03c6.toFormula)\n  | \u25c7\u03c6      => \u25c7(\u03c6.toFormula)\ninstance : Coe (NNFormula \u03b1) (Formula \u03b1) := \u27e8toFormula\u27e9\n\n@[simp] lemma toFormula_atom (a : \u03b1) : toFormula  (.atom a) = Formula.atom a := rfl\n\n@[simp] lemma toFormula_natom (a : \u03b1) : toFormula (.natom a) = \u223cFormula.atom a := rfl\n\n", "theoremStatement": "@[simp] lemma toFormula_falsum : toFormula \u22a5 = (\u22a5 : Formula \u03b1) ", "theoremName": "LO.Modal.NNFormula.toFormula_falsum", "fileCreated": {"commit": "1f10809ea0f0e98679f13cd2f7f5b706b01878a8", "date": "2024-11-20"}, "theoremCreated": {"commit": "54324e6e009f0d0a288897312d3feb1c0165ad19", "date": "2025-01-24"}, "file": "foundation/Foundation/Modal/NNFormula.lean", "module": "Foundation.Modal.NNFormula", "jsonFile": "Foundation.Modal.NNFormula.jsonl", "positionMetadata": {"lineInFile": 136, "tokenPositionInFile": 3434, "theoremPositionInFile": 20}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 7, "numPremises": 10}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "import Foundation.Modal.Kripke.Geach.Systems\n\nnamespace LO.Modal.Hilbert\n\nopen System\nopen Modal.Kripke\nopen Formula\nopen Formula.Kripke\n\nlemma K4_weakerThan_KD4 : (Hilbert.K4 \u03b1) \u2264\u209b (Hilbert.KD4 \u03b1) := normal_weakerThan_of_subset $ by intro; aesop;\n\n", "theoremStatement": "theorem K4_strictlyWeakerThan_KD4 : (Hilbert.K4 \u2115) <\u209b (Hilbert.KD4 \u2115) ", "theoremName": "LO.Modal.Hilbert.K4_strictlyWeakerThan_KD4", "fileCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "theoremCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "file": "foundation/Foundation/Modal/Hilbert/WeakerThan/K4_KD4.lean", "module": "Foundation.Modal.Hilbert.WeakerThan.K4_KD4", "jsonFile": "Foundation.Modal.Hilbert.WeakerThan.K4_KD4.jsonl", "positionMetadata": {"lineInFile": 12, "tokenPositionInFile": 249, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 62, "numPremises": 128}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  constructor;\n  . exact K4_weakerThan_KD4;\n  . apply weakerThan_iff.not.mpr;\n    push_neg;\n    use (\u25a1(atom 0) \u279d \u25c7(atom 0));\n    constructor;\n    . exact Deduction.maxm! $ by simp;\n    . apply K4.Kripke.sound.not_provable_of_countermodel;\n      suffices \u2203 F : Frame, Transitive F.Rel \u2227 \u2203 V : Valuation F, \u2203 w : F.World, \u00ac(Kripke.Satisfies \u27e8F, V\u27e9 w _) by\n        simp [ValidOnModel, ValidOnFrame, Satisfies];\n        tauto;\n      let F : Frame := \u27e8Fin 1, \u03bb x y => False\u27e9;\n      use F;\n      constructor;\n      . simp [Transitive];\n      . use (\u03bb w _ => w = 0), 0;\n        simp [Semantics.Realize, Satisfies];", "proofType": "tactic", "proofLengthLines": 17, "proofLengthTokens": 613}}
{"srcContext": "import Foundation.IntProp.Formula\nimport Foundation.Modal.Formula\n\nnamespace LO.IntProp\n\ndef Formula.toModalFormula : Formula \u03b1 \u2192 Modal.Formula \u03b1\n  | .atom a => Modal.Formula.atom a\n  | \u22a4 => \u22a4\n  | \u22a5 => \u22a5\n  | \u223c\u03c6 => \u223c(toModalFormula \u03c6)\n  | \u03c6 \u279d \u03c8 => (toModalFormula \u03c6) \u279d (toModalFormula \u03c8)\n  | \u03c6 \u22cf \u03c8 => (toModalFormula \u03c6) \u22cf (toModalFormula \u03c8)\n  | \u03c6 \u22ce \u03c8 => (toModalFormula \u03c6) \u22ce (toModalFormula \u03c8)\npostfix:75 \"\u1d39\" => Formula.toModalFormula\n\nnamespace Formula.toModalFormula\n\n@[simp] lemma def_top : (\u22a4 : Formula \u03b1)\u1d39 = \u22a4 := by rfl\n\n", "theoremStatement": "@[simp] lemma def_bot : (\u22a5 : Formula \u03b1)\u1d39 = \u22a5 ", "theoremName": "LO.IntProp.Formula.toModalFormula.def_bot", "fileCreated": {"commit": "a1bfd1fa480026f05e476050030c0b2d17983bb0", "date": "2024-11-28"}, "theoremCreated": {"commit": "54324e6e009f0d0a288897312d3feb1c0165ad19", "date": "2025-01-24"}, "file": "foundation/Foundation/Modal/IntProp.lean", "module": "Foundation.Modal.IntProp", "jsonFile": "Foundation.Modal.IntProp.jsonl", "positionMetadata": {"lineInFile": 20, "tokenPositionInFile": 525, "theoremPositionInFile": 2}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 7, "numPremises": 10}, "proofMetadata": {"hasProof": true, "proof": ":= by rfl", "proofType": "tactic", "proofLengthLines": 0, "proofLengthTokens": 9}}
{"srcContext": "import Foundation.Modal.Kripke.Geach.Systems\n\nnamespace LO.Modal.Hilbert\n\nopen System\nopen Modal.Kripke\nopen Formula\nopen Formula.Kripke\n\n", "theoremStatement": "lemma KD45_weakerThan_S5 : (Hilbert.KD45 \u2115) \u2264\u209b (Hilbert.S5 \u2115) ", "theoremName": "LO.Modal.Hilbert.KD45_weakerThan_S5", "fileCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "theoremCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "file": "foundation/Foundation/Modal/Hilbert/WeakerThan/KD45_S5.lean", "module": "Foundation.Modal.Hilbert.WeakerThan.KD45_S5", "jsonFile": "Foundation.Modal.Hilbert.WeakerThan.KD45_S5.jsonl", "positionMetadata": {"lineInFile": 10, "tokenPositionInFile": 138, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 25, "numPremises": 36}, "proofMetadata": {"hasProof": true, "proof": ":=  by\n  apply Kripke.weakerThan_of_subset_FrameClass SerialTransitiveEuclideanFrameClass ReflexiveEuclideanFrameClass;\n  rintro F \u27e8F_refl, F_eucl\u27e9;\n  refine \u27e8serial_of_refl F_refl, trans_of_refl_eucl F_refl F_eucl, F_eucl\u27e9;", "proofType": "term", "proofLengthLines": 3, "proofLengthTokens": 224}}
{"srcContext": "import Foundation.Modal.Kripke.Geach.Systems\n\nnamespace LO.Modal.Hilbert\n\nopen System\nopen Modal.Kripke\nopen Formula\nopen Formula.Kripke\n\nlemma KD4_weakerThan_KD45 : (Hilbert.KD4 \u03b1) \u2264\u209b (Hilbert.KD45 \u03b1) := normal_weakerThan_of_subset $ by intro; aesop;\n\n", "theoremStatement": "theorem KD4_strictlyWeakerThan_KD45 : (Hilbert.KD4 \u2115) <\u209b (Hilbert.KD45 \u2115) ", "theoremName": "LO.Modal.Hilbert.KD4_strictlyWeakerThan_KD45", "fileCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "theoremCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "file": "foundation/Foundation/Modal/Hilbert/WeakerThan/KD4_KD45.lean", "module": "Foundation.Modal.Hilbert.WeakerThan.KD4_KD45", "jsonFile": "Foundation.Modal.Hilbert.WeakerThan.KD4_KD45.jsonl", "positionMetadata": {"lineInFile": 12, "tokenPositionInFile": 253, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 63, "numPremises": 205}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  constructor;\n  . exact KD4_weakerThan_KD45;\n  . apply weakerThan_iff.not.mpr;\n    push_neg;\n    use (\u25c7(atom 0) \u279d \u25a1\u25c7(atom 0));\n    constructor;\n    . exact Deduction.maxm! $ by simp;\n    . apply KD4.Kripke.sound.not_provable_of_countermodel;\n      suffices \u2203 F : Frame, Serial F.Rel \u2227 Transitive F.Rel \u2227 \u2203 V : Valuation F, \u2203 w : F.World, \u00ac(Kripke.Satisfies \u27e8F, V\u27e9 w _) by\n        simp [ValidOnModel, ValidOnFrame, Satisfies];\n        tauto;\n      let F : Frame := \u27e8Fin 2, \u03bb x y => x = y \u2228 x < y\u27e9;\n      use F;\n      refine \u27e8?_, ?_, ?_\u27e9;\n      . unfold Serial;\n        aesop;\n      . unfold Transitive;\n        omega;\n      . use (\u03bb w _ => w = 0), 0;\n        suffices (0 : F.World) \u227a 0 \u2227 \u2203 x : F.World, (0 : F.World) \u227a x \u2227 \u00acx \u227a 0 by\n          simpa [Semantics.Realize, Satisfies];\n        constructor;\n        . tauto;\n        . use 1; omega;", "proofType": "tactic", "proofLengthLines": 24, "proofLengthTokens": 848}}
{"srcContext": "import Foundation.IntFO.Translation\n\n/-!\n#Algebraic Proofs of Cut Elimination\n\nMain reference: Jeremy Avigad, Algebraic proofs of cut elimination, The Journal of Logic and Algebraic Programming, Volume 49, Issues 1\u20132, 2001, Pages 15-30\n -/\n\nnamespace LO.FirstOrder\n\nvariable {L : Language.{u}}\n\nnamespace Derivation\n\ninductive IsCutFree : {\u0393 : Sequent L} \u2192 \u22a2\u1d40 \u0393 \u2192 Prop\n| axL (\u0393) {k} (r : L.Rel k) (v)                 : IsCutFree (axL \u0393 r v)\n| verum (\u0393)                                     : IsCutFree (verum \u0393)\n| or {\u0393 \u03c6 \u03c8} {d : \u22a2\u1d40 \u03c6 :: \u03c8 :: \u0393}               : IsCutFree d \u2192 IsCutFree d.or\n| and {\u0393 \u03c6 \u03c8} {d\u03c6 : \u22a2\u1d40 \u03c6 :: \u0393} {d\u03c8 : \u22a2\u1d40 \u03c8 :: \u0393} : IsCutFree d\u03c6 \u2192 IsCutFree d\u03c8 \u2192 IsCutFree (d\u03c6.and d\u03c8)\n| all {\u0393 \u03c6} {d : \u22a2\u1d40 Rewriting.free \u03c6 :: \u0393\u207a}     : IsCutFree d \u2192 IsCutFree d.all\n| ex {\u0393 \u03c6} (t) {d : \u22a2\u1d40 \u03c6/[t] :: \u0393}              : IsCutFree d \u2192 IsCutFree d.ex\n| wk {\u0394 \u0393} {d : \u22a2\u1d40 \u0394} (ss : \u0394 \u2286 \u0393)              : IsCutFree d \u2192 IsCutFree (d.wk ss)\n\nattribute [simp] IsCutFree.axL IsCutFree.verum\n\nvariable {\u0393 \u0394 : Sequent L}\n\n@[simp] lemma isCutFree_or_iff {d : \u22a2\u1d40 \u03c6 :: \u03c8 :: \u0393} :\n    IsCutFree d.or \u2194 IsCutFree d := \u27e8by rintro \u27e8\u27e9; assumption, .or\u27e9\n\n@[simp] lemma isCutFree_and_iff {d\u03c6 : \u22a2\u1d40 \u03c6 :: \u0393} {d\u03c8 : \u22a2\u1d40 \u03c8 :: \u0393} :\n    IsCutFree (d\u03c6.and d\u03c8) \u2194 IsCutFree d\u03c6 \u2227 IsCutFree d\u03c8 :=\n  \u27e8by rintro \u27e8\u27e9; constructor <;> assumption, by intro \u27e8h\u03c6, h\u03c8\u27e9; exact h\u03c6.and h\u03c8\u27e9\n\n@[simp] lemma isCutFree_all_iff {d : \u22a2\u1d40 Rewriting.free \u03c6 :: \u0393\u207a} :\n    IsCutFree d.all \u2194 IsCutFree d := \u27e8by rintro \u27e8\u27e9; assumption, .all\u27e9\n\n@[simp] lemma isCutFree_ex_iff {d : \u22a2\u1d40 \u03c6/[t] :: \u0393} :\n    IsCutFree d.ex \u2194 IsCutFree d := \u27e8by rintro \u27e8\u27e9; assumption, .ex t\u27e9\n\n@[simp] lemma isCutFree_wk_iff {d : \u22a2\u1d40 \u0394} {ss : \u0394 \u2286 \u0393} :\n    IsCutFree (d.wk ss) \u2194 IsCutFree d := \u27e8by rintro \u27e8\u27e9; assumption, .wk _\u27e9\n\n", "theoremStatement": "@[simp] lemma IsCutFree.cast {d : \u22a2\u1d40 \u0393} {e : \u0393 = \u0394} :\n    IsCutFree (.cast d e) \u2194 IsCutFree d ", "theoremName": "LO.FirstOrder.Derivation.IsCutFree.cast", "fileCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/FirstOrder/Hauptsatz.lean", "module": "Foundation.FirstOrder.Hauptsatz", "jsonFile": "Foundation.FirstOrder.Hauptsatz.jsonl", "positionMetadata": {"lineInFile": 44, "tokenPositionInFile": 1738, "theoremPositionInFile": 5}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 7, "numPremises": 19}, "proofMetadata": {"hasProof": true, "proof": ":= by rcases e; rfl", "proofType": "tactic", "proofLengthLines": 0, "proofLengthTokens": 19}}
{"srcContext": "import Foundation.Modal.Kripke.Geach.Systems\n\nnamespace LO.Modal.Hilbert\n\nopen System\nopen Modal.Kripke\nopen Formula\nopen Formula.Kripke\n\nlemma KT_weakerThan_S4 : (Hilbert.KT \u03b1) \u2264\u209b (Hilbert.S4 \u03b1) := normal_weakerThan_of_subset $ by intro; aesop;\n\n", "theoremStatement": "theorem KT_strictlyWeakerThan_S4 : (Hilbert.KT \u2115) <\u209b (Hilbert.S4 \u2115) ", "theoremName": "LO.Modal.Hilbert.KT_strictlyWeakerThan_S4", "fileCreated": {"commit": "a1bfd1fa480026f05e476050030c0b2d17983bb0", "date": "2024-11-28"}, "theoremCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "file": "foundation/Foundation/Modal/Hilbert/WeakerThan/KT_S4.lean", "module": "Foundation.Modal.Hilbert.WeakerThan.KT_S4", "jsonFile": "Foundation.Modal.Hilbert.WeakerThan.KT_S4.jsonl", "positionMetadata": {"lineInFile": 12, "tokenPositionInFile": 247, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 58, "numPremises": 134}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  constructor;\n  . exact KT_weakerThan_S4;\n  . apply weakerThan_iff.not.mpr;\n    push_neg;\n    use (\u25a1(atom 0) \u279d \u25a1\u25a1(atom 0));\n    constructor;\n    . exact Deduction.maxm! (by simp);\n    . apply KT.Kripke.sound.not_provable_of_countermodel;\n      suffices \u2203 F : Frame, Reflexive F.Rel \u2227 \u2203 V : Valuation F, \u2203 w : F.World, \u00ac(Satisfies \u27e8F, V\u27e9 w _)  by\n        simpa [ValidOnModel, ValidOnFrame, Satisfies];\n      let F : Frame := \u27e8\n        Fin 3,\n        \u03bb x y =>\n          match x, y with\n          | 0, 0 => True\n          | 0, 1 => True\n          | 1, 1 => True\n          | 1, 2 => True\n          | 2, 2 => True\n          | _, _ => False\n      \u27e9;\n      use F;\n      constructor;\n      . intro x;\n        match x with\n        | 0 => tauto;\n        | 1 => tauto;\n        | 2 => tauto;\n      . use (\u03bb w _ => w = 0 \u2228 w = 1), 0;\n        suffices (\u2200 (y : F.World), (0 : F.World) \u227a y \u2192 y = 0 \u2228 y = 1) \u2227 \u2203 x, (0 : F.World) \u227a x \u2227 \u2203 y, x \u227a y \u2227 y \u2260 0 \u2227 y \u2260 1 by\n          simpa [Semantics.Realize, Satisfies];\n        constructor;\n        . intro y hy;\n          match y with\n          | 0 => tauto;\n          | 1 => tauto;\n          | 2 => tauto;\n        . use 1;\n          constructor;\n          . tauto;\n          . use 2;\n            constructor;\n            . tauto;\n            . aesop", "proofType": "tactic", "proofLengthLines": 44, "proofLengthTokens": 1284}}
{"srcContext": "import Foundation.Vorspiel.BinaryRelations\nimport Foundation.Modal.Kripke.Completeness\nimport Foundation.Modal.Hilbert.Geach\n\n\nnamespace LO.Modal\n\nnamespace Kripke\n\nabbrev GeachConfluentFrameClass (t : GeachConfluent.Taple) : FrameClass := { F | (GeachConfluent t) F.Rel }\n\ninstance GeachConfluentFrameClass.nonempty : (GeachConfluentFrameClass t).Nonempty := by\n  use reflexivePointFrame.toFrame;\n  intros x _ _ _; use x;\n  constructor <;> { apply Rel.iterate.true_any; tauto; }\n\n\nabbrev MultiGeachConfluentFrameClass (ts : List GeachConfluent.Taple) : FrameClass := { F | (MultiGeachConfluent ts) F.Rel }\n\nnamespace MultiGeachConfluentFrameClass\n\n@[simp] lemma def_nil : MultiGeachConfluentFrameClass [] = AllFrameClass := by rfl;\n\nlemma def_one (t : GeachConfluent.Taple) : MultiGeachConfluentFrameClass [t] = GeachConfluentFrameClass t := by rfl;\n\nlemma def_cons {t : GeachConfluent.Taple} {ts : List GeachConfluent.Taple} (ts_nil : ts \u2260 [])\n  : MultiGeachConfluentFrameClass (t :: ts) = GeachConfluentFrameClass t \u2229 MultiGeachConfluentFrameClass ts := by\n  apply Set.eq_of_subset_of_subset;\n  . rintro F hF;\n    apply MultiGeachConfluent.iff_cons ts_nil |>.mp;\n    exact hF;\n  . rintro F \u27e8hF\u2081, hF\u2082\u27e9;\n    apply MultiGeachConfluent.iff_cons ts_nil |>.mpr;\n    constructor;\n    . apply hF\u2081;\n    . apply hF\u2082;\n\n@[simp]\ninstance nonempty : (MultiGeachConfluentFrameClass ts).Nonempty := by\n  use \u27e8PUnit,  \u03bb _ _ => True\u27e9;\n  induction ts using List.induction_with_singleton with\n  | hnil => simp only [def_nil, Set.mem_univ];\n  | hsingle t =>\n    simp [GeachConfluentFrameClass];\n    intros x _ _ _; use x;\n    constructor <;> { apply Rel.iterate.true_any; tauto; }\n  | hcons t ts ts_nil ih =>\n    simp [MultiGeachConfluentFrameClass.def_cons ts_nil];\n    constructor;\n    . intro x _ _ _; use x;\n      constructor <;> { apply Rel.iterate.true_any; tauto; }\n    . exact ih;\n\nend MultiGeachConfluentFrameClass\n\n\nabbrev FrameClass.IsGeach (C : FrameClass) (ts : List GeachConfluent.Taple) := C = MultiGeachConfluentFrameClass ts\n\n\nsection\n\n/-- Frame class of `Hilbert.KT` -/\nabbrev ReflexiveFrameClass : FrameClass := { F | Reflexive F.Rel }\nlemma ReflexiveFrameClass.is_geach : ReflexiveFrameClass.IsGeach [\u27e80, 0, 1, 0\u27e9] := by\n  simp only [FrameClass.IsGeach, ReflexiveFrameClass, GeachConfluent.reflexive_def,\n    MultiGeachConfluentFrameClass.def_one, GeachConfluentFrameClass];\n\n/-- Frame class of `Hilbert.KD` -/\nabbrev SerialFrameClass : FrameClass := { F | Serial F.Rel }\nlemma SerialFrameClass.is_geach : SerialFrameClass.IsGeach [\u27e80, 0, 1, 1\u27e9] := by\n  simp only [FrameClass.IsGeach, SerialFrameClass, GeachConfluent.serial_def,\n    MultiGeachConfluentFrameClass.def_one, GeachConfluentFrameClass];\n\n/-- Frame class of `Hilbert.KB` -/\nabbrev SymmetricFrameClass : FrameClass := { F | Symmetric F.Rel }\nlemma SymmetricFrameClass.is_geach : SymmetricFrameClass.IsGeach [\u27e80, 1, 0, 1\u27e9] := by\n  simp only [FrameClass.IsGeach, SymmetricFrameClass, GeachConfluent.symmetric_def,\n    MultiGeachConfluentFrameClass.def_one, GeachConfluentFrameClass];\n\n/-- Frame class of `Hilbert.K4` -/\nabbrev TransitiveFrameClass : FrameClass := { F | Transitive F.Rel }\nlemma TransitiveFrameClass.is_geach : TransitiveFrameClass.IsGeach ([\u27e80, 2, 1, 0\u27e9]) := by\n  simp only [FrameClass.IsGeach, TransitiveFrameClass, GeachConfluent.transitive_def,\n    MultiGeachConfluentFrameClass.def_one, GeachConfluentFrameClass];\n\n/-- Frame class of `Hilbert.K5` -/\nabbrev EuclideanFrameClass : FrameClass := { F | Euclidean F.Rel }\nlemma EuclideanFrameClass.is_geach : EuclideanFrameClass.IsGeach ([\u27e81, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, EuclideanFrameClass, GeachConfluent.euclidean_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.S5` -/\nabbrev ReflexiveEuclideanFrameClass : FrameClass := { F | Reflexive F.Rel \u2227 Euclidean F.Rel }\nlemma ReflexiveEuclideanFrameClass.is_geach : ReflexiveEuclideanFrameClass.IsGeach ([\u27e80, 0, 1, 0\u27e9, \u27e81, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, ReflexiveEuclideanFrameClass, GeachConfluent.reflexive_def,\n    GeachConfluent.euclidean_def, MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.KTB` -/\nabbrev ReflexiveSymmetricFrameClass : FrameClass := { F | Reflexive F \u2227 Symmetric F }\nlemma ReflexiveSymmetricFrameClass.is_geach : ReflexiveSymmetricFrameClass.IsGeach ([\u27e80, 0, 1, 0\u27e9, \u27e80, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, ReflexiveSymmetricFrameClass, GeachConfluent.reflexive_def,\n    GeachConfluent.symmetric_def, MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.S4` -/\nabbrev ReflexiveTransitiveFrameClass : FrameClass := { F | Reflexive F \u2227 Transitive F }\nlemma ReflexiveTransitiveFrameClass.is_geach : ReflexiveTransitiveFrameClass.IsGeach ([\u27e80, 0, 1, 0\u27e9, \u27e80, 2, 1, 0\u27e9]) := by\n  simp only [FrameClass.IsGeach, ReflexiveTransitiveFrameClass, GeachConfluent.reflexive_def,\n    GeachConfluent.transitive_def, MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.S4Dot2` -/\nabbrev ReflexiveTransitiveConfluentFrameClass : FrameClass := { F | Reflexive F \u2227 Transitive F \u2227 Confluent F }\nlemma ReflexiveTransitiveConfluentFrameClass.is_geach : ReflexiveTransitiveConfluentFrameClass.IsGeach ([\u27e80, 0, 1, 0\u27e9, \u27e80, 2, 1, 0\u27e9, \u27e81, 1, 1, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, ReflexiveTransitiveConfluentFrameClass,\n    GeachConfluent.reflexive_def, GeachConfluent.transitive_def, GeachConfluent.confluent_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.KT4B` -/\nabbrev ReflexiveTransitiveSymmetricFrameClass : FrameClass := { F | Reflexive F \u2227 Transitive F \u2227 Symmetric F }\nlemma ReflexiveTransitiveSymmetricFrameClass.is_geach : ReflexiveTransitiveSymmetricFrameClass.IsGeach ([\u27e80, 0, 1, 0\u27e9, \u27e80, 2, 1, 0\u27e9, \u27e80, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, ReflexiveTransitiveSymmetricFrameClass,\n    GeachConfluent.reflexive_def, GeachConfluent.transitive_def, GeachConfluent.symmetric_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.KD45` -/\nabbrev SerialTransitiveEuclideanFrameClass : FrameClass := { F | Serial F \u2227 Transitive F \u2227 Euclidean F }\nlemma SerialTransitiveEuclideanFrameClass.is_geach : SerialTransitiveEuclideanFrameClass.IsGeach ([\u27e80, 0, 1, 1\u27e9, \u27e80, 2, 1, 0\u27e9, \u27e81, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, SerialTransitiveEuclideanFrameClass,\n    GeachConfluent.serial_def, GeachConfluent.transitive_def, GeachConfluent.euclidean_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.K45` -/\nabbrev TransitiveEuclideanFrameClass : FrameClass := { F | Transitive F \u2227 Euclidean F }\nlemma TransitiveEuclideanFrameClass.is_geach : TransitiveEuclideanFrameClass.IsGeach ([\u27e80, 2, 1, 0\u27e9, \u27e81, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, TransitiveEuclideanFrameClass,\n    GeachConfluent.transitive_def, GeachConfluent.euclidean_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.KB4` -/\nabbrev SymmetricTransitiveFrameClass : FrameClass := { F | Symmetric F \u2227 Transitive F }\nlemma SymmetricTransitiveFrameClass.is_geach : SymmetricTransitiveFrameClass.IsGeach ([\u27e80, 1, 0, 1\u27e9, \u27e80, 2, 1, 0\u27e9]) := by\n  simp only [FrameClass.IsGeach, SymmetricTransitiveFrameClass,\n    GeachConfluent.symmetric_def, GeachConfluent.transitive_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.KB5` -/\nabbrev SymmetricEuclideanFrameClass : FrameClass := { F | Symmetric F \u2227 Euclidean F }\nlemma SymmetricEuclideanFrameClass.is_geach : SymmetricEuclideanFrameClass.IsGeach ([\u27e80, 1, 0, 1\u27e9, \u27e81, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, SymmetricEuclideanFrameClass,\n    GeachConfluent.symmetric_def, GeachConfluent.euclidean_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.KDB` -/\nabbrev SerialSymmetricFrameClass : FrameClass := { F | Serial F \u2227 Symmetric F }\n", "theoremStatement": "lemma SerialSymmetricFrameClass.is_geach : SerialSymmetricFrameClass.IsGeach ([\u27e80, 0, 1, 1\u27e9, \u27e80, 1, 0, 1\u27e9]) ", "theoremName": "LO.Modal.Kripke.SerialSymmetricFrameClass.is_geach", "fileCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "theoremCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "file": "foundation/Foundation/Modal/Kripke/Geach/Basic.lean", "module": "Foundation.Modal.Kripke.Geach.Basic", "jsonFile": "Foundation.Modal.Kripke.Geach.Basic.jsonl", "positionMetadata": {"lineInFile": 154, "tokenPositionInFile": 7987, "theoremPositionInFile": 35}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 12, "numPremises": 30}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp only [FrameClass.IsGeach, SerialSymmetricFrameClass,\n    GeachConfluent.serial_def, GeachConfluent.symmetric_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 183}}
{"srcContext": "import Foundation.Modal.Hilbert.Maximal.Unprovability\nimport Foundation.Modal.Kripke.GL.MDP\n\nnamespace LO.Modal\n\nopen System\nopen IntProp\n\nvariable [DecidableEq \u03b1]\n\ndef independency (\u03c6 : Formula \u03b1) := \u223c\u25a1\u03c6 \u22cf \u223c\u25a1(\u223c\u03c6)\n\ndef higherIndependency (\u03c6 : Formula \u03b1) : \u2115 \u2192 Formula \u03b1\n  | 0 => \u03c6\n  | n + 1 => independency (higherIndependency \u03c6 n)\n\nnamespace Hilbert.GL\n\nvariable {\u03c6 : Formula \u2115}\n\nlemma unprovable_notbox : (Hilbert.GL _) \u22ac \u223c\u25a1\u03c6 := by\n  by_contra hC;\n  have : (Hilbert.GL _) \u22a2! \u223c\u25a1\u03c6 \u279d \u223c\u25a1\u22a5 := contra\u2080'! (imply_box_distribute'! efq!)\n  have : Hilbert.GL _ \u22a2! \u223c\u25a1\u22a5 := this \u2a00 hC;\n  have : Hilbert.Cl \u2115 \u22a2! (\u22a5 \u279d \u22a5) \u279d \u22a5 := by simpa using provable_CL_verTranslated this;\n  simpa using Hilbert.Cl.classical_sound this;\n\nlemma unprovable_independency : (Hilbert.GL _) \u22ac independency \u03c6 := by\n  by_contra hC;\n  exact unprovable_notbox $ and\u2081'! hC;\n\n", "theoremStatement": "lemma unprovable_not_independency_of_consistency : (Hilbert.GL \u2115) \u22ac \u223c(independency (\u223c\u25a1\u22a5)) ", "theoremName": "LO.Modal.Hilbert.GL.unprovable_not_independency_of_consistency", "fileCreated": {"commit": "830d76e560f33054a2eb2051cf1fa73997706985", "date": "2025-01-01"}, "theoremCreated": {"commit": "830d76e560f33054a2eb2051cf1fa73997706985", "date": "2025-01-01"}, "file": "foundation/Foundation/Modal/Hilbert/GL_Independency.lean", "module": "Foundation.Modal.Hilbert.GL_Independency", "jsonFile": "Foundation.Modal.Hilbert.GL_Independency.jsonl", "positionMetadata": {"lineInFile": 32, "tokenPositionInFile": 834, "theoremPositionInFile": 3}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 34, "numPremises": 41}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  by_contra hC;\n  rcases modal_disjunctive (dne_or! $ demorgan\u2084'! hC) with (h | h);\n  . exact unprovable_notbox h;\n  . exact Consistent.not_bot (inferInstance) $ unnec! $ dne'! h", "proofType": "tactic", "proofLengthLines": 4, "proofLengthTokens": 184}}
{"srcContext": "import Foundation.IntFO.Basic.Rew\n\nnamespace LO.FirstOrder\n\nabbrev Sequent\u1d62 (L : Language) := List (SyntacticFormula\u1d62 L)\n\nopen Semiformula\u1d62\n\nvariable {L : Language} {T : Theory L}\n\nstructure Hilbert\u1d62 (L : Language) where\n  axiomSet : Set (SyntacticFormula\u1d62 L)\n  rewrite_closed {\u03c6 : SyntacticFormula\u1d62 L} : \u03c6 \u2208 axiomSet \u2192 \u2200 f : \u2115 \u2192 SyntacticTerm L, Rew.rewrite f \u25b9 \u03c6 \u2208 axiomSet\n\ninstance : SetLike (Hilbert\u1d62 L) (SyntacticFormula\u1d62 L) where\n  coe := Hilbert\u1d62.axiomSet\n  coe_injective' := by rintro \u27e8T, _\u27e9 \u27e8U, _\u27e9; simp\n\nnamespace Hilbert\u1d62\n\ndef Minimal : Hilbert\u1d62 L := \u27e8\u2205, by simp\u27e9\n\nnotation \"\ud835\udc0c\ud835\udc22\ud835\udc27\u00b9\" => Minimal\n\ndef Intuitionistic : Hilbert\u1d62 L := \u27e8{\u22a5 \u279d \u03c6 | \u03c6}, by rintro _ \u27e8\u03c6, rfl\u27e9 f; exact \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\u27e9\n\nnotation \"\ud835\udc08\ud835\udc27\ud835\udc2d\u00b9\" => Intuitionistic\n\ndef Classical : Hilbert\u1d62 L := \u27e8{\u22a5 \u279d \u03c6 | \u03c6} \u222a {\u03c6 \u22ce \u223c\u03c6 | \u03c6}, by\n  rintro _ (\u27e8\u03c6, rfl\u27e9 | \u27e8\u03c6, rfl\u27e9) f\n  \u00b7 exact Or.inl \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\n  \u00b7 exact Or.inr \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\u27e9\n\nnotation \"\ud835\udc02\ud835\udc25\u00b9\" => Classical\n\nlemma minimal_le (\u039b : Hilbert\u1d62 L) : (Minimal : Hilbert\u1d62 L) \u2264 \u039b := by rintro _ \u27e8\u27e9\n\nlemma intuitionistic_le_classical : (Intuitionistic : Hilbert\u1d62 L) \u2264 Classical := by rintro _ \u27e8\u03c6, rfl\u27e9; exact .inl \u27e8\u03c6, rfl\u27e9\n\nend Hilbert\u1d62\n\ninductive HilbertProof\u1d62 (\u039b : Hilbert\u1d62 L) : SyntacticFormula\u1d62 L \u2192 Type _\n  | eaxm {\u03c6}     : \u03c6 \u2208 \u039b \u2192 HilbertProof\u1d62 \u039b \u03c6\n  | mdp {\u03c6 \u03c8}    : HilbertProof\u1d62 \u039b (\u03c6 \u279d \u03c8) \u2192 HilbertProof\u1d62 \u039b \u03c6 \u2192 HilbertProof\u1d62 \u039b \u03c8\n  | gen {\u03c6}      : HilbertProof\u1d62 \u039b (Rewriting.free \u03c6) \u2192 HilbertProof\u1d62 \u039b (\u2200' \u03c6)\n  | verum        : HilbertProof\u1d62 \u039b \u22a4\n  | imply\u2081 \u03c6 \u03c8   : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c8 \u279d \u03c6\n  | imply\u2082 \u03c6 \u03c8 \u03c7 : HilbertProof\u1d62 \u039b <| (\u03c6 \u279d \u03c8 \u279d \u03c7) \u279d (\u03c6 \u279d \u03c8) \u279d \u03c6 \u279d \u03c7\n  | and\u2081 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u22cf \u03c8 \u279d \u03c6\n  | and\u2082 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u22cf \u03c8 \u279d \u03c8\n  | and\u2083 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c8 \u279d \u03c6 \u22cf \u03c8\n  | or\u2081 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c6 \u22ce \u03c8\n  | or\u2082 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u03c8 \u279d \u03c6 \u22ce \u03c8\n  | or\u2083 \u03c6 \u03c8 \u03c7    : HilbertProof\u1d62 \u039b <| (\u03c6 \u279d \u03c7) \u279d (\u03c8 \u279d \u03c7) \u279d (\u03c6 \u22ce \u03c8 \u279d \u03c7)\n  | all\u2081 \u03c6 t     : HilbertProof\u1d62 \u039b <| \u2200' \u03c6 \u279d \u03c6/[t]\n  | all\u2082 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u2200' (\u03c6/[] \u279d \u03c8) \u279d \u03c6 \u279d \u2200' \u03c8\n  | ex\u2081 t \u03c6      : HilbertProof\u1d62 \u039b <| \u03c6/[t] \u279d \u2203' \u03c6\n  | ex\u2082 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u2200' (\u03c6 \u279d \u03c8/[]) \u279d \u2203' \u03c6 \u279d \u03c8\n\ninstance : System (SyntacticFormula\u1d62 L) (Hilbert\u1d62 L) := \u27e8HilbertProof\u1d62\u27e9\n\nnamespace HilbertProof\u1d62\n\nopen System.FiniteContext Rewriting LawfulSyntacticRewriting\n\nvariable (\u039b : Hilbert\u1d62 L)\n\ninstance : System.ModusPonens \u039b := \u27e8mdp\u27e9\n\ninstance : System.HasAxiomAndInst \u039b := \u27e8and\u2083\u27e9\n\ninstance : System.HasAxiomImply\u2081 \u039b := \u27e8imply\u2081\u27e9\n\ninstance : System.HasAxiomImply\u2082 \u039b := \u27e8imply\u2082\u27e9\n\ninstance : System.Minimal \u039b where\n  mdp := mdp\n  verum := verum\n  imply\u2081 := imply\u2081\n  imply\u2082 := imply\u2082\n  and\u2081 := and\u2081\n  and\u2082 := and\u2082\n  and\u2083 := and\u2083\n  or\u2081 := or\u2081\n  or\u2082 := or\u2082\n  or\u2083 := or\u2083\n  neg_equiv _ := System.iffId _\n\nvariable {\u039b}\n\nprotected def cast {\u03c6 \u03c8} (b : \u039b \u22a2 \u03c6) (e : \u03c6 = \u03c8) : \u039b \u22a2 \u03c8 := e \u25b8 b\n\ndef depth {\u03c6} : \u039b \u22a2 \u03c6 \u2192 \u2115\n  | mdp b d => max (depth b) (depth d) + 1\n  | gen b   => depth b + 1\n  | _       => 0\n\nscoped notation \"\u2016\" d \"\u2016\" => depth d\n\n@[simp] lemma depth_eaxm (h : \u03c6 \u2208 \u039b) : \u2016eaxm h\u2016 = 0 := rfl\n@[simp] lemma depth_mdp (b : \u039b \u22a2 \u03c6 \u279d \u03c8) (d : \u039b \u22a2 \u03c6) : \u2016mdp b d\u2016 = max \u2016b\u2016 \u2016d\u2016 + 1 := rfl\n@[simp] lemma depth_gen (b : \u039b \u22a2 Rewriting.free \u03c6) : \u2016gen b\u2016 = \u2016b\u2016 + 1 := rfl\n@[simp] lemma depth_verum : \u2016(verum : \u039b \u22a2 \u22a4)\u2016 = 0 := rfl\n@[simp] lemma depth_imply\u2081 (\u03c6 \u03c8) : \u2016imply\u2081 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_imply\u2082 (\u03c6 \u03c8 \u03c7) : \u2016imply\u2082 (\u039b := \u039b) \u03c6 \u03c8 \u03c7\u2016 = 0 := rfl\n@[simp] lemma depth_and\u2081 (\u03c6 \u03c8) : \u2016and\u2081 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n", "theoremStatement": "@[simp] lemma depth_and\u2082 (\u03c6 \u03c8) : \u2016and\u2082 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 ", "theoremName": "LO.FirstOrder.HilbertProof\u1d62.depth_and\u2082", "fileCreated": {"commit": "7d9e3859942c3a17a697b129e7fb3869eca0066e", "date": "2024-11-09"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/IntFO/Basic/Deduction.lean", "module": "Foundation.IntFO.Basic.Deduction", "jsonFile": "Foundation.IntFO.Basic.Deduction.jsonl", "positionMetadata": {"lineInFile": 107, "tokenPositionInFile": 3476, "theoremPositionInFile": 18}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 10, "numPremises": 15}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "import Foundation.IntProp.Formula\nimport Foundation.Modal.Formula\n\nnamespace LO.IntProp\n\ndef Formula.toModalFormula : Formula \u03b1 \u2192 Modal.Formula \u03b1\n  | .atom a => Modal.Formula.atom a\n  | \u22a4 => \u22a4\n  | \u22a5 => \u22a5\n  | \u223c\u03c6 => \u223c(toModalFormula \u03c6)\n  | \u03c6 \u279d \u03c8 => (toModalFormula \u03c6) \u279d (toModalFormula \u03c8)\n  | \u03c6 \u22cf \u03c8 => (toModalFormula \u03c6) \u22cf (toModalFormula \u03c8)\n  | \u03c6 \u22ce \u03c8 => (toModalFormula \u03c6) \u22ce (toModalFormula \u03c8)\npostfix:75 \"\u1d39\" => Formula.toModalFormula\n\nnamespace Formula.toModalFormula\n\n@[simp] lemma def_top : (\u22a4 : Formula \u03b1)\u1d39 = \u22a4 := by rfl\n\n@[simp] lemma def_bot : (\u22a5 : Formula \u03b1)\u1d39 = \u22a5 := by rfl\n\n@[simp] lemma def_atom (a : \u03b1) : (atom a)\u1d39 = .atom a := by rfl\n\n@[simp] lemma def_not (\u03c6 : Formula \u03b1) : (\u223c\u03c6)\u1d39 = \u223c(\u03c6\u1d39) := by rfl\n\n", "theoremStatement": "@[simp] lemma def_imp (\u03c6 \u03c8 : Formula \u03b1) : (\u03c6 \u279d \u03c8)\u1d39 = (\u03c6\u1d39) \u279d (\u03c8\u1d39) ", "theoremName": "LO.IntProp.Formula.toModalFormula.def_imp", "fileCreated": {"commit": "a1bfd1fa480026f05e476050030c0b2d17983bb0", "date": "2024-11-28"}, "theoremCreated": {"commit": "54324e6e009f0d0a288897312d3feb1c0165ad19", "date": "2025-01-24"}, "file": "foundation/Foundation/Modal/IntProp.lean", "module": "Foundation.Modal.IntProp", "jsonFile": "Foundation.Modal.IntProp.jsonl", "positionMetadata": {"lineInFile": 26, "tokenPositionInFile": 710, "theoremPositionInFile": 5}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 8, "numPremises": 10}, "proofMetadata": {"hasProof": true, "proof": ":= by rfl", "proofType": "tactic", "proofLengthLines": 0, "proofLengthTokens": 9}}
{"srcContext": "import Foundation.Vorspiel.BinaryRelations\nimport Foundation.Modal.Kripke.Completeness\nimport Foundation.Modal.Hilbert.Geach\n\n\nnamespace LO.Modal\n\nnamespace Kripke\n\nabbrev GeachConfluentFrameClass (t : GeachConfluent.Taple) : FrameClass := { F | (GeachConfluent t) F.Rel }\n\ninstance GeachConfluentFrameClass.nonempty : (GeachConfluentFrameClass t).Nonempty := by\n  use reflexivePointFrame.toFrame;\n  intros x _ _ _; use x;\n  constructor <;> { apply Rel.iterate.true_any; tauto; }\n\n\nabbrev MultiGeachConfluentFrameClass (ts : List GeachConfluent.Taple) : FrameClass := { F | (MultiGeachConfluent ts) F.Rel }\n\nnamespace MultiGeachConfluentFrameClass\n\n@[simp] lemma def_nil : MultiGeachConfluentFrameClass [] = AllFrameClass := by rfl;\n\nlemma def_one (t : GeachConfluent.Taple) : MultiGeachConfluentFrameClass [t] = GeachConfluentFrameClass t := by rfl;\n\nlemma def_cons {t : GeachConfluent.Taple} {ts : List GeachConfluent.Taple} (ts_nil : ts \u2260 [])\n  : MultiGeachConfluentFrameClass (t :: ts) = GeachConfluentFrameClass t \u2229 MultiGeachConfluentFrameClass ts := by\n  apply Set.eq_of_subset_of_subset;\n  . rintro F hF;\n    apply MultiGeachConfluent.iff_cons ts_nil |>.mp;\n    exact hF;\n  . rintro F \u27e8hF\u2081, hF\u2082\u27e9;\n    apply MultiGeachConfluent.iff_cons ts_nil |>.mpr;\n    constructor;\n    . apply hF\u2081;\n    . apply hF\u2082;\n\n@[simp]\ninstance nonempty : (MultiGeachConfluentFrameClass ts).Nonempty := by\n  use \u27e8PUnit,  \u03bb _ _ => True\u27e9;\n  induction ts using List.induction_with_singleton with\n  | hnil => simp only [def_nil, Set.mem_univ];\n  | hsingle t =>\n    simp [GeachConfluentFrameClass];\n    intros x _ _ _; use x;\n    constructor <;> { apply Rel.iterate.true_any; tauto; }\n  | hcons t ts ts_nil ih =>\n    simp [MultiGeachConfluentFrameClass.def_cons ts_nil];\n    constructor;\n    . intro x _ _ _; use x;\n      constructor <;> { apply Rel.iterate.true_any; tauto; }\n    . exact ih;\n\nend MultiGeachConfluentFrameClass\n\n\nabbrev FrameClass.IsGeach (C : FrameClass) (ts : List GeachConfluent.Taple) := C = MultiGeachConfluentFrameClass ts\n\n\nsection\n\n/-- Frame class of `Hilbert.KT` -/\nabbrev ReflexiveFrameClass : FrameClass := { F | Reflexive F.Rel }\nlemma ReflexiveFrameClass.is_geach : ReflexiveFrameClass.IsGeach [\u27e80, 0, 1, 0\u27e9] := by\n  simp only [FrameClass.IsGeach, ReflexiveFrameClass, GeachConfluent.reflexive_def,\n    MultiGeachConfluentFrameClass.def_one, GeachConfluentFrameClass];\n\n/-- Frame class of `Hilbert.KD` -/\nabbrev SerialFrameClass : FrameClass := { F | Serial F.Rel }\nlemma SerialFrameClass.is_geach : SerialFrameClass.IsGeach [\u27e80, 0, 1, 1\u27e9] := by\n  simp only [FrameClass.IsGeach, SerialFrameClass, GeachConfluent.serial_def,\n    MultiGeachConfluentFrameClass.def_one, GeachConfluentFrameClass];\n\n/-- Frame class of `Hilbert.KB` -/\nabbrev SymmetricFrameClass : FrameClass := { F | Symmetric F.Rel }\nlemma SymmetricFrameClass.is_geach : SymmetricFrameClass.IsGeach [\u27e80, 1, 0, 1\u27e9] := by\n  simp only [FrameClass.IsGeach, SymmetricFrameClass, GeachConfluent.symmetric_def,\n    MultiGeachConfluentFrameClass.def_one, GeachConfluentFrameClass];\n\n/-- Frame class of `Hilbert.K4` -/\nabbrev TransitiveFrameClass : FrameClass := { F | Transitive F.Rel }\nlemma TransitiveFrameClass.is_geach : TransitiveFrameClass.IsGeach ([\u27e80, 2, 1, 0\u27e9]) := by\n  simp only [FrameClass.IsGeach, TransitiveFrameClass, GeachConfluent.transitive_def,\n    MultiGeachConfluentFrameClass.def_one, GeachConfluentFrameClass];\n\n/-- Frame class of `Hilbert.K5` -/\nabbrev EuclideanFrameClass : FrameClass := { F | Euclidean F.Rel }\nlemma EuclideanFrameClass.is_geach : EuclideanFrameClass.IsGeach ([\u27e81, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, EuclideanFrameClass, GeachConfluent.euclidean_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.S5` -/\nabbrev ReflexiveEuclideanFrameClass : FrameClass := { F | Reflexive F.Rel \u2227 Euclidean F.Rel }\nlemma ReflexiveEuclideanFrameClass.is_geach : ReflexiveEuclideanFrameClass.IsGeach ([\u27e80, 0, 1, 0\u27e9, \u27e81, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, ReflexiveEuclideanFrameClass, GeachConfluent.reflexive_def,\n    GeachConfluent.euclidean_def, MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.KTB` -/\nabbrev ReflexiveSymmetricFrameClass : FrameClass := { F | Reflexive F \u2227 Symmetric F }\nlemma ReflexiveSymmetricFrameClass.is_geach : ReflexiveSymmetricFrameClass.IsGeach ([\u27e80, 0, 1, 0\u27e9, \u27e80, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, ReflexiveSymmetricFrameClass, GeachConfluent.reflexive_def,\n    GeachConfluent.symmetric_def, MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.S4` -/\nabbrev ReflexiveTransitiveFrameClass : FrameClass := { F | Reflexive F \u2227 Transitive F }\nlemma ReflexiveTransitiveFrameClass.is_geach : ReflexiveTransitiveFrameClass.IsGeach ([\u27e80, 0, 1, 0\u27e9, \u27e80, 2, 1, 0\u27e9]) := by\n  simp only [FrameClass.IsGeach, ReflexiveTransitiveFrameClass, GeachConfluent.reflexive_def,\n    GeachConfluent.transitive_def, MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.S4Dot2` -/\nabbrev ReflexiveTransitiveConfluentFrameClass : FrameClass := { F | Reflexive F \u2227 Transitive F \u2227 Confluent F }\nlemma ReflexiveTransitiveConfluentFrameClass.is_geach : ReflexiveTransitiveConfluentFrameClass.IsGeach ([\u27e80, 0, 1, 0\u27e9, \u27e80, 2, 1, 0\u27e9, \u27e81, 1, 1, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, ReflexiveTransitiveConfluentFrameClass,\n    GeachConfluent.reflexive_def, GeachConfluent.transitive_def, GeachConfluent.confluent_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.KT4B` -/\nabbrev ReflexiveTransitiveSymmetricFrameClass : FrameClass := { F | Reflexive F \u2227 Transitive F \u2227 Symmetric F }\nlemma ReflexiveTransitiveSymmetricFrameClass.is_geach : ReflexiveTransitiveSymmetricFrameClass.IsGeach ([\u27e80, 0, 1, 0\u27e9, \u27e80, 2, 1, 0\u27e9, \u27e80, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, ReflexiveTransitiveSymmetricFrameClass,\n    GeachConfluent.reflexive_def, GeachConfluent.transitive_def, GeachConfluent.symmetric_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.KD45` -/\nabbrev SerialTransitiveEuclideanFrameClass : FrameClass := { F | Serial F \u2227 Transitive F \u2227 Euclidean F }\nlemma SerialTransitiveEuclideanFrameClass.is_geach : SerialTransitiveEuclideanFrameClass.IsGeach ([\u27e80, 0, 1, 1\u27e9, \u27e80, 2, 1, 0\u27e9, \u27e81, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, SerialTransitiveEuclideanFrameClass,\n    GeachConfluent.serial_def, GeachConfluent.transitive_def, GeachConfluent.euclidean_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.K45` -/\nabbrev TransitiveEuclideanFrameClass : FrameClass := { F | Transitive F \u2227 Euclidean F }\nlemma TransitiveEuclideanFrameClass.is_geach : TransitiveEuclideanFrameClass.IsGeach ([\u27e80, 2, 1, 0\u27e9, \u27e81, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, TransitiveEuclideanFrameClass,\n    GeachConfluent.transitive_def, GeachConfluent.euclidean_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.KB4` -/\nabbrev SymmetricTransitiveFrameClass : FrameClass := { F | Symmetric F \u2227 Transitive F }\nlemma SymmetricTransitiveFrameClass.is_geach : SymmetricTransitiveFrameClass.IsGeach ([\u27e80, 1, 0, 1\u27e9, \u27e80, 2, 1, 0\u27e9]) := by\n  simp only [FrameClass.IsGeach, SymmetricTransitiveFrameClass,\n    GeachConfluent.symmetric_def, GeachConfluent.transitive_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.KB5` -/\nabbrev SymmetricEuclideanFrameClass : FrameClass := { F | Symmetric F \u2227 Euclidean F }\nlemma SymmetricEuclideanFrameClass.is_geach : SymmetricEuclideanFrameClass.IsGeach ([\u27e80, 1, 0, 1\u27e9, \u27e81, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, SymmetricEuclideanFrameClass,\n    GeachConfluent.symmetric_def, GeachConfluent.euclidean_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.KDB` -/\nabbrev SerialSymmetricFrameClass : FrameClass := { F | Serial F \u2227 Symmetric F }\nlemma SerialSymmetricFrameClass.is_geach : SerialSymmetricFrameClass.IsGeach ([\u27e80, 0, 1, 1\u27e9, \u27e80, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, SerialSymmetricFrameClass,\n    GeachConfluent.serial_def, GeachConfluent.symmetric_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.KD4` -/\nabbrev SerialTransitiveFrameClass : FrameClass := { F | Serial F \u2227 Transitive F }\nlemma SerialTransitiveFrameClass.is_geach : SerialTransitiveFrameClass.IsGeach ([\u27e80, 0, 1, 1\u27e9, \u27e80, 2, 1, 0\u27e9]) := by\n  simp only [FrameClass.IsGeach, SerialTransitiveFrameClass,\n    GeachConfluent.serial_def, GeachConfluent.transitive_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent]\n\n/-- Frame class of `Hilbert.KD5` -/\nabbrev SerialEuclideanFrameClass : FrameClass := { F | Serial F \u2227 Euclidean F }\nlemma SerialEuclideanFrameClass.is_geach : SerialEuclideanFrameClass.IsGeach ([\u27e80, 0, 1, 1\u27e9, \u27e81, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, SerialEuclideanFrameClass,\n    GeachConfluent.serial_def, GeachConfluent.euclidean_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\nend\n\n\nsection definability\n\nopen Kripke\nopen Formula\nopen Formula.Kripke (Satisfies)\nopen Formula.Kripke.Satisfies\n\nlemma GeachConfluentFrameClass.isDefinedBy {t : GeachConfluent.Taple} : (GeachConfluentFrameClass t).DefinedBy \ud835\uddf4\ud835\uddf2(t) := by\n  intro F;\n  constructor;\n  . intro hG;\n    simp [GeachConfluentFrameClass];\n    intro \u03c6 V x him;\n    apply Satisfies.multibox_def.mpr;\n    intro z Rxz;\n    apply Satisfies.multidia_def.mpr;\n    obtain \u27e8y, Rxy, hbp\u27e9 := multidia_def.mp him;\n    obtain \u27e8u, Ryu, Rzu\u27e9 := hG \u27e8Rxy, Rxz\u27e9;\n    use u;\n    constructor;\n    . assumption;\n    . exact (Satisfies.multibox_def.mp hbp) Ryu;\n  . rintro h x y z \u27e8hi, hj\u27e9;\n    simp [Kripke.ValidOnFrame] at h;\n    let M : Model := \u27e8F, \u03bb v _ => y \u227a^[t.m] v \u27e9;\n    have him_x : Satisfies M x (\u25c7^[t.i](\u25a1^[t.m](atom 0))) := by\n      apply Satisfies.multidia_def.mpr;\n      use y;\n      constructor;\n      . exact hi;\n      . apply Satisfies.multibox_def.mpr; aesop;\n    have hjn_x : Kripke.Satisfies M x (\u25a1^[t.j](\u25c7^[t.n](atom 0))) := Satisfies.imp_def.mp (h (atom 0) M.Val x) him_x;\n    have hn_z : Kripke.Satisfies M z (\u25c7^[t.n](atom 0)) := Satisfies.multibox_def.mp hjn_x hj;\n    obtain \u27e8u, hzu, hyu\u27e9 := Kripke.Satisfies.multidia_def.mp hn_z;\n    use u;\n    exact \u27e8hyu, hzu\u27e9;\n\nlemma MultiGeachConfluentFrameClass.isDefinedBy {ts : List GeachConfluent.Taple} : (MultiGeachConfluentFrameClass ts).DefinedBy \ud835\uddda\ud835\uddf2(ts) := by\n  intro F;\n  induction ts using List.induction_with_singleton with\n  | hnil => simp [MultiGeachConfluentFrameClass];\n  | hsingle t =>\n    simp only [MultiGeachConfluentFrameClass.def_one, Axioms.MultiGeach.def_one];\n    apply GeachConfluentFrameClass.isDefinedBy;\n  | hcons t ts ts_nil ih =>\n    simp [MultiGeachConfluentFrameClass.def_cons (ts_nil := ts_nil)];\n    constructor;\n    . rintro \u27e8ht, hts\u27e9;\n      constructor;\n      . intro \u03c6\n        apply Semantics.realizeSet_iff.mp $ @GeachConfluentFrameClass.isDefinedBy (t := t) F |>.mp ht\n        tauto;\n      . apply ih.mp;\n        exact hts;\n    . rintro \u27e8ht, hts\u27e9;\n      constructor;\n      . apply @GeachConfluentFrameClass.isDefinedBy t F |>.mpr;\n        apply Semantics.realizeSet_iff.mpr;\n        simpa using ht;\n      . apply ih.mpr hts;\n\nlemma ReflexiveFrameClass.isDefinedBy : (ReflexiveFrameClass).DefinedBy \ud835\udde7 := by\n  rw [ReflexiveFrameClass.is_geach, Axioms.T.is_geach];\n  apply GeachConfluentFrameClass.isDefinedBy;\n\nlemma SerialFrameClass.isDefinedBy : (SerialFrameClass).DefinedBy \ud835\uddd7 := by\n  rw [SerialFrameClass.is_geach, Axioms.D.is_geach];\n  apply GeachConfluentFrameClass.isDefinedBy;\n\nlemma TransitiveFrameClass.isDefinedBy : (TransitiveFrameClass).DefinedBy \ud835\udff0 := by\n  rw [TransitiveFrameClass.is_geach, Axioms.Four.is_geach];\n  apply GeachConfluentFrameClass.isDefinedBy;\n\nend definability\n\nend Kripke\n\n\nnamespace Hilbert\n\nopen Modal.Kripke\n\nnamespace Kripke\n\nopen System\nopen Theory MaximalConsistentTheory\nopen canonicalFrame\n\nnamespace canonicalFrame\n\nvariable {Ax : Theory \u2115} [(Hilbert.ExtK Ax).Consistent]\n\nlemma is_geachConfluent_of_subset_Geach (h : \ud835\uddf4\ud835\uddf2(t) \u2286 Ax) : GeachConfluent t (canonicalFrame (Hilbert.ExtK Ax)).Rel := by\n  rintro \u03a9\u2081 \u03a9\u2082 \u03a9\u2083 h;\n  have \u27e8r\u2081\u2082, r\u2081\u2083\u27e9 := h; clear h;\n  have \u27e8\u03a9, h\u03a9\u27e9 := lindenbaum (H := (Hilbert.ExtK Ax)) (T := \u25a1''\u207b\u00b9^[t.m]\u03a9\u2082.theory \u222a \u25a1''\u207b\u00b9^[t.n]\u03a9\u2083.theory) $ by\n    apply intro_union_consistent;\n    rintro \u0393 \u0394 \u27e8h\u0393, h\u0394\u27e9 hC;\n\n    replace h\u0393 : \u2200 \u03c6 \u2208 \u0393, \u25a1^[t.m]\u03c6 \u2208 \u03a9\u2082.theory := by simpa using h\u0393;\n    have h\u0393conj : \u25a1^[t.m]\u22c0\u0393 \u2208 \u03a9\u2082.theory := iff_mem_multibox_conj.mpr h\u0393;\n\n    replace h\u0394 : \u2200 \u03c6 \u2208 \u0394, \u25a1^[t.n]\u03c6 \u2208 \u03a9\u2083.theory := by simpa using h\u0394;\n    have : \u25a1^[t.n]\u22c0\u0394 \u2208 \u03a9\u2083.theory := iff_mem_multibox_conj.mpr h\u0394;\n\n    have : \u25a1^[t.j](\u25c7^[t.n]\u22c0\u0393) \u2208 \u03a9\u2081.theory := iff_mem_imp.mp\n      (membership_iff.mpr $ Context.of! $ Hilbert.ExtK.maxm! (by aesop))\n      (multirel_def_multidia.mp r\u2081\u2082 h\u0393conj)\n    have : \u25c7^[t.n]\u22c0\u0393 \u2208 \u03a9\u2083.theory := multirel_def_multibox.mp r\u2081\u2083 this;\n\n    have : (Hilbert.ExtK Ax) \u22a2! \u25a1^[t.n]\u22c0\u0394 \u22cf \u25c7^[t.n]\u22c0\u0393 \u279d \u22a5 := by {\n      apply and_imply_iff_imply_imply'!.mpr;\n      exact imp_trans''!\n        (show _ \u22a2! \u25a1^[t.n]\u22c0\u0394 \u279d \u25a1^[t.n](\u223c\u22c0\u0393) by exact imply_multibox_distribute'! $ contra\u2081'! $ imp_trans''! (and_imply_iff_imply_imply'!.mp hC) (and\u2082'! neg_equiv!))\n        (show _ \u22a2! \u25a1^[t.n](\u223c\u22c0\u0393) \u279d (\u25c7^[t.n]\u22c0\u0393) \u279d \u22a5 by exact imp_trans''! (contra\u2081'! $ and\u2081'! $ multidia_duality!) (and\u2081'! neg_equiv!));\n    }\n    have : (Hilbert.ExtK Ax) \u22ac \u25a1^[t.n]\u22c0\u0394 \u22cf \u25c7^[t.n]\u22c0\u0393 \u279d \u22a5 := by simpa using (def_consistent.mp \u03a9\u2083.consistent) (\u0393 := [\u25a1^[t.n]\u22c0\u0394, \u25c7^[t.n]\u22c0\u0393]) (by simp_all)\n\n    contradiction;\n\n  use \u03a9; simp only [Set.union_subset_iff] at h\u03a9;\n  constructor;\n  . apply multirel_def_multibox.mpr; apply h\u03a9.1;\n  . apply multirel_def_multibox.mpr; apply h\u03a9.2;\n\nlemma is_multiGeachConfluent_of_subset_MultiGeach (h : \ud835\uddda\ud835\uddf2(ts) \u2286 Ax) : MultiGeachConfluent ts (canonicalFrame (Hilbert.ExtK Ax)).Rel := by\n  induction ts using List.induction_with_singleton with\n  | hnil => simp [MultiGeachConfluent];\n  | hsingle t =>\n    simp [MultiGeachConfluent.iff_singleton] at h;\n    exact is_geachConfluent_of_subset_Geach h;\n  | hcons t ts ts_nil ih =>\n    simp [(MultiGeachConfluent.iff_cons ts_nil)];\n    constructor;\n    . apply is_geachConfluent_of_subset_Geach; simp_all;\n    . apply ih; simp_all;\n\nlemma is_reflexive_of_subset_T (h : \ud835\udde7 \u2286 Ax) : Reflexive (canonicalFrame (Hilbert.ExtK Ax)).Rel := by\n  rw [GeachConfluent.reflexive_def, Axioms.T.is_geach] at *\n  apply is_geachConfluent_of_subset_Geach;\n  exact h;\n\nlemma is_serial_of_subset_D (h : \ud835\uddd7 \u2286 Ax) : Serial (canonicalFrame (Hilbert.ExtK Ax)).Rel := by\n  rw [GeachConfluent.serial_def, Axioms.D.is_geach] at *\n  apply is_geachConfluent_of_subset_Geach;\n  exact h;\n\nlemma is_transitive_of_subset_Four (h : \ud835\udff0 \u2286 Ax) : Transitive (canonicalFrame (Hilbert.ExtK Ax)).Rel := by\n  rw [GeachConfluent.transitive_def, Axioms.Four.is_geach] at *\n  apply is_geachConfluent_of_subset_Geach;\n  exact h;\n\nlemma is_euclidean_of_subset_Five (h : \ud835\udff1 \u2286 Ax) : Euclidean (canonicalFrame (Hilbert.ExtK Ax)).Rel := by\n  rw [GeachConfluent.euclidean_def, Axioms.Five.is_geach] at *\n  apply is_geachConfluent_of_subset_Geach;\n  exact h;\n\nlemma is_symmetric_of_subset_B (h : \ud835\uddd5 \u2286 Ax) : Symmetric (canonicalFrame (Hilbert.ExtK Ax)).Rel := by\n  rw [GeachConfluent.symmetric_def, Axioms.B.is_geach] at *\n  apply is_geachConfluent_of_subset_Geach;\n  exact h;\n\n", "theoremStatement": "lemma is_confluent_of_subset_dot2 (h : .\ud835\udfee \u2286 Ax) : Confluent (canonicalFrame (Hilbert.ExtK Ax)).Rel ", "theoremName": "LO.Modal.Hilbert.Kripke.canonicalFrame.is_confluent_of_subset_dot2", "fileCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "theoremCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "file": "foundation/Foundation/Modal/Kripke/Geach/Basic.lean", "module": "Foundation.Modal.Kripke.Geach.Basic", "jsonFile": "Foundation.Modal.Kripke.Geach.Basic.jsonl", "positionMetadata": {"lineInFile": 338, "tokenPositionInFile": 15342, "theoremPositionInFile": 52}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 18, "numPremises": 30}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [GeachConfluent.confluent_def, Axioms.Dot2.is_geach] at *\n  apply is_geachConfluent_of_subset_Geach;\n  exact h;", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 122}}
{"srcContext": "import Foundation.Vorspiel.BinaryRelations\nimport Foundation.Modal.Kripke.Completeness\nimport Foundation.Modal.Hilbert.Geach\n\n\nnamespace LO.Modal\n\nnamespace Kripke\n\nabbrev GeachConfluentFrameClass (t : GeachConfluent.Taple) : FrameClass := { F | (GeachConfluent t) F.Rel }\n\ninstance GeachConfluentFrameClass.nonempty : (GeachConfluentFrameClass t).Nonempty := by\n  use reflexivePointFrame.toFrame;\n  intros x _ _ _; use x;\n  constructor <;> { apply Rel.iterate.true_any; tauto; }\n\n\nabbrev MultiGeachConfluentFrameClass (ts : List GeachConfluent.Taple) : FrameClass := { F | (MultiGeachConfluent ts) F.Rel }\n\nnamespace MultiGeachConfluentFrameClass\n\n@[simp] lemma def_nil : MultiGeachConfluentFrameClass [] = AllFrameClass := by rfl;\n\nlemma def_one (t : GeachConfluent.Taple) : MultiGeachConfluentFrameClass [t] = GeachConfluentFrameClass t := by rfl;\n\nlemma def_cons {t : GeachConfluent.Taple} {ts : List GeachConfluent.Taple} (ts_nil : ts \u2260 [])\n  : MultiGeachConfluentFrameClass (t :: ts) = GeachConfluentFrameClass t \u2229 MultiGeachConfluentFrameClass ts := by\n  apply Set.eq_of_subset_of_subset;\n  . rintro F hF;\n    apply MultiGeachConfluent.iff_cons ts_nil |>.mp;\n    exact hF;\n  . rintro F \u27e8hF\u2081, hF\u2082\u27e9;\n    apply MultiGeachConfluent.iff_cons ts_nil |>.mpr;\n    constructor;\n    . apply hF\u2081;\n    . apply hF\u2082;\n\n@[simp]\ninstance nonempty : (MultiGeachConfluentFrameClass ts).Nonempty := by\n  use \u27e8PUnit,  \u03bb _ _ => True\u27e9;\n  induction ts using List.induction_with_singleton with\n  | hnil => simp only [def_nil, Set.mem_univ];\n  | hsingle t =>\n    simp [GeachConfluentFrameClass];\n    intros x _ _ _; use x;\n    constructor <;> { apply Rel.iterate.true_any; tauto; }\n  | hcons t ts ts_nil ih =>\n    simp [MultiGeachConfluentFrameClass.def_cons ts_nil];\n    constructor;\n    . intro x _ _ _; use x;\n      constructor <;> { apply Rel.iterate.true_any; tauto; }\n    . exact ih;\n\nend MultiGeachConfluentFrameClass\n\n\nabbrev FrameClass.IsGeach (C : FrameClass) (ts : List GeachConfluent.Taple) := C = MultiGeachConfluentFrameClass ts\n\n\nsection\n\n/-- Frame class of `Hilbert.KT` -/\nabbrev ReflexiveFrameClass : FrameClass := { F | Reflexive F.Rel }\nlemma ReflexiveFrameClass.is_geach : ReflexiveFrameClass.IsGeach [\u27e80, 0, 1, 0\u27e9] := by\n  simp only [FrameClass.IsGeach, ReflexiveFrameClass, GeachConfluent.reflexive_def,\n    MultiGeachConfluentFrameClass.def_one, GeachConfluentFrameClass];\n\n/-- Frame class of `Hilbert.KD` -/\nabbrev SerialFrameClass : FrameClass := { F | Serial F.Rel }\nlemma SerialFrameClass.is_geach : SerialFrameClass.IsGeach [\u27e80, 0, 1, 1\u27e9] := by\n  simp only [FrameClass.IsGeach, SerialFrameClass, GeachConfluent.serial_def,\n    MultiGeachConfluentFrameClass.def_one, GeachConfluentFrameClass];\n\n/-- Frame class of `Hilbert.KB` -/\nabbrev SymmetricFrameClass : FrameClass := { F | Symmetric F.Rel }\nlemma SymmetricFrameClass.is_geach : SymmetricFrameClass.IsGeach [\u27e80, 1, 0, 1\u27e9] := by\n  simp only [FrameClass.IsGeach, SymmetricFrameClass, GeachConfluent.symmetric_def,\n    MultiGeachConfluentFrameClass.def_one, GeachConfluentFrameClass];\n\n/-- Frame class of `Hilbert.K4` -/\nabbrev TransitiveFrameClass : FrameClass := { F | Transitive F.Rel }\nlemma TransitiveFrameClass.is_geach : TransitiveFrameClass.IsGeach ([\u27e80, 2, 1, 0\u27e9]) := by\n  simp only [FrameClass.IsGeach, TransitiveFrameClass, GeachConfluent.transitive_def,\n    MultiGeachConfluentFrameClass.def_one, GeachConfluentFrameClass];\n\n/-- Frame class of `Hilbert.K5` -/\nabbrev EuclideanFrameClass : FrameClass := { F | Euclidean F.Rel }\nlemma EuclideanFrameClass.is_geach : EuclideanFrameClass.IsGeach ([\u27e81, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, EuclideanFrameClass, GeachConfluent.euclidean_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.S5` -/\nabbrev ReflexiveEuclideanFrameClass : FrameClass := { F | Reflexive F.Rel \u2227 Euclidean F.Rel }\nlemma ReflexiveEuclideanFrameClass.is_geach : ReflexiveEuclideanFrameClass.IsGeach ([\u27e80, 0, 1, 0\u27e9, \u27e81, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, ReflexiveEuclideanFrameClass, GeachConfluent.reflexive_def,\n    GeachConfluent.euclidean_def, MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.KTB` -/\nabbrev ReflexiveSymmetricFrameClass : FrameClass := { F | Reflexive F \u2227 Symmetric F }\nlemma ReflexiveSymmetricFrameClass.is_geach : ReflexiveSymmetricFrameClass.IsGeach ([\u27e80, 0, 1, 0\u27e9, \u27e80, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, ReflexiveSymmetricFrameClass, GeachConfluent.reflexive_def,\n    GeachConfluent.symmetric_def, MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.S4` -/\nabbrev ReflexiveTransitiveFrameClass : FrameClass := { F | Reflexive F \u2227 Transitive F }\nlemma ReflexiveTransitiveFrameClass.is_geach : ReflexiveTransitiveFrameClass.IsGeach ([\u27e80, 0, 1, 0\u27e9, \u27e80, 2, 1, 0\u27e9]) := by\n  simp only [FrameClass.IsGeach, ReflexiveTransitiveFrameClass, GeachConfluent.reflexive_def,\n    GeachConfluent.transitive_def, MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.S4Dot2` -/\nabbrev ReflexiveTransitiveConfluentFrameClass : FrameClass := { F | Reflexive F \u2227 Transitive F \u2227 Confluent F }\nlemma ReflexiveTransitiveConfluentFrameClass.is_geach : ReflexiveTransitiveConfluentFrameClass.IsGeach ([\u27e80, 0, 1, 0\u27e9, \u27e80, 2, 1, 0\u27e9, \u27e81, 1, 1, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, ReflexiveTransitiveConfluentFrameClass,\n    GeachConfluent.reflexive_def, GeachConfluent.transitive_def, GeachConfluent.confluent_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.KT4B` -/\nabbrev ReflexiveTransitiveSymmetricFrameClass : FrameClass := { F | Reflexive F \u2227 Transitive F \u2227 Symmetric F }\nlemma ReflexiveTransitiveSymmetricFrameClass.is_geach : ReflexiveTransitiveSymmetricFrameClass.IsGeach ([\u27e80, 0, 1, 0\u27e9, \u27e80, 2, 1, 0\u27e9, \u27e80, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, ReflexiveTransitiveSymmetricFrameClass,\n    GeachConfluent.reflexive_def, GeachConfluent.transitive_def, GeachConfluent.symmetric_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.KD45` -/\nabbrev SerialTransitiveEuclideanFrameClass : FrameClass := { F | Serial F \u2227 Transitive F \u2227 Euclidean F }\nlemma SerialTransitiveEuclideanFrameClass.is_geach : SerialTransitiveEuclideanFrameClass.IsGeach ([\u27e80, 0, 1, 1\u27e9, \u27e80, 2, 1, 0\u27e9, \u27e81, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, SerialTransitiveEuclideanFrameClass,\n    GeachConfluent.serial_def, GeachConfluent.transitive_def, GeachConfluent.euclidean_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.K45` -/\nabbrev TransitiveEuclideanFrameClass : FrameClass := { F | Transitive F \u2227 Euclidean F }\nlemma TransitiveEuclideanFrameClass.is_geach : TransitiveEuclideanFrameClass.IsGeach ([\u27e80, 2, 1, 0\u27e9, \u27e81, 1, 0, 1\u27e9]) := by\n  simp only [FrameClass.IsGeach, TransitiveEuclideanFrameClass,\n    GeachConfluent.transitive_def, GeachConfluent.euclidean_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.KB4` -/\nabbrev SymmetricTransitiveFrameClass : FrameClass := { F | Symmetric F \u2227 Transitive F }\nlemma SymmetricTransitiveFrameClass.is_geach : SymmetricTransitiveFrameClass.IsGeach ([\u27e80, 1, 0, 1\u27e9, \u27e80, 2, 1, 0\u27e9]) := by\n  simp only [FrameClass.IsGeach, SymmetricTransitiveFrameClass,\n    GeachConfluent.symmetric_def, GeachConfluent.transitive_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];\n\n/-- Frame class of `Hilbert.KB5` -/\nabbrev SymmetricEuclideanFrameClass : FrameClass := { F | Symmetric F \u2227 Euclidean F }\n", "theoremStatement": "lemma SymmetricEuclideanFrameClass.is_geach : SymmetricEuclideanFrameClass.IsGeach ([\u27e80, 1, 0, 1\u27e9, \u27e81, 1, 0, 1\u27e9]) ", "theoremName": "LO.Modal.Kripke.SymmetricEuclideanFrameClass.is_geach", "fileCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "theoremCreated": {"commit": "7546c6fee2be1e5d6a872cf9cf43c9b08cdea405", "date": "2024-12-07"}, "file": "foundation/Foundation/Modal/Kripke/Geach/Basic.lean", "module": "Foundation.Modal.Kripke.Geach.Basic", "jsonFile": "Foundation.Modal.Kripke.Geach.Basic.jsonl", "positionMetadata": {"lineInFile": 147, "tokenPositionInFile": 7566, "theoremPositionInFile": 33}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 12, "numPremises": 30}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp only [FrameClass.IsGeach, SymmetricEuclideanFrameClass,\n    GeachConfluent.symmetric_def, GeachConfluent.euclidean_def,\n    MultiGeachConfluentFrameClass, MultiGeachConfluent];", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 189}}
{"srcContext": "import Foundation.IntFO.Basic.Rew\n\nnamespace LO.FirstOrder\n\nabbrev Sequent\u1d62 (L : Language) := List (SyntacticFormula\u1d62 L)\n\nopen Semiformula\u1d62\n\nvariable {L : Language} {T : Theory L}\n\nstructure Hilbert\u1d62 (L : Language) where\n  axiomSet : Set (SyntacticFormula\u1d62 L)\n  rewrite_closed {\u03c6 : SyntacticFormula\u1d62 L} : \u03c6 \u2208 axiomSet \u2192 \u2200 f : \u2115 \u2192 SyntacticTerm L, Rew.rewrite f \u25b9 \u03c6 \u2208 axiomSet\n\ninstance : SetLike (Hilbert\u1d62 L) (SyntacticFormula\u1d62 L) where\n  coe := Hilbert\u1d62.axiomSet\n  coe_injective' := by rintro \u27e8T, _\u27e9 \u27e8U, _\u27e9; simp\n\nnamespace Hilbert\u1d62\n\ndef Minimal : Hilbert\u1d62 L := \u27e8\u2205, by simp\u27e9\n\nnotation \"\ud835\udc0c\ud835\udc22\ud835\udc27\u00b9\" => Minimal\n\ndef Intuitionistic : Hilbert\u1d62 L := \u27e8{\u22a5 \u279d \u03c6 | \u03c6}, by rintro _ \u27e8\u03c6, rfl\u27e9 f; exact \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\u27e9\n\nnotation \"\ud835\udc08\ud835\udc27\ud835\udc2d\u00b9\" => Intuitionistic\n\ndef Classical : Hilbert\u1d62 L := \u27e8{\u22a5 \u279d \u03c6 | \u03c6} \u222a {\u03c6 \u22ce \u223c\u03c6 | \u03c6}, by\n  rintro _ (\u27e8\u03c6, rfl\u27e9 | \u27e8\u03c6, rfl\u27e9) f\n  \u00b7 exact Or.inl \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\n  \u00b7 exact Or.inr \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\u27e9\n\nnotation \"\ud835\udc02\ud835\udc25\u00b9\" => Classical\n\nlemma minimal_le (\u039b : Hilbert\u1d62 L) : (Minimal : Hilbert\u1d62 L) \u2264 \u039b := by rintro _ \u27e8\u27e9\n\nlemma intuitionistic_le_classical : (Intuitionistic : Hilbert\u1d62 L) \u2264 Classical := by rintro _ \u27e8\u03c6, rfl\u27e9; exact .inl \u27e8\u03c6, rfl\u27e9\n\nend Hilbert\u1d62\n\ninductive HilbertProof\u1d62 (\u039b : Hilbert\u1d62 L) : SyntacticFormula\u1d62 L \u2192 Type _\n  | eaxm {\u03c6}     : \u03c6 \u2208 \u039b \u2192 HilbertProof\u1d62 \u039b \u03c6\n  | mdp {\u03c6 \u03c8}    : HilbertProof\u1d62 \u039b (\u03c6 \u279d \u03c8) \u2192 HilbertProof\u1d62 \u039b \u03c6 \u2192 HilbertProof\u1d62 \u039b \u03c8\n  | gen {\u03c6}      : HilbertProof\u1d62 \u039b (Rewriting.free \u03c6) \u2192 HilbertProof\u1d62 \u039b (\u2200' \u03c6)\n  | verum        : HilbertProof\u1d62 \u039b \u22a4\n  | imply\u2081 \u03c6 \u03c8   : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c8 \u279d \u03c6\n  | imply\u2082 \u03c6 \u03c8 \u03c7 : HilbertProof\u1d62 \u039b <| (\u03c6 \u279d \u03c8 \u279d \u03c7) \u279d (\u03c6 \u279d \u03c8) \u279d \u03c6 \u279d \u03c7\n  | and\u2081 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u22cf \u03c8 \u279d \u03c6\n  | and\u2082 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u22cf \u03c8 \u279d \u03c8\n  | and\u2083 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c8 \u279d \u03c6 \u22cf \u03c8\n  | or\u2081 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c6 \u22ce \u03c8\n  | or\u2082 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u03c8 \u279d \u03c6 \u22ce \u03c8\n  | or\u2083 \u03c6 \u03c8 \u03c7    : HilbertProof\u1d62 \u039b <| (\u03c6 \u279d \u03c7) \u279d (\u03c8 \u279d \u03c7) \u279d (\u03c6 \u22ce \u03c8 \u279d \u03c7)\n  | all\u2081 \u03c6 t     : HilbertProof\u1d62 \u039b <| \u2200' \u03c6 \u279d \u03c6/[t]\n  | all\u2082 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u2200' (\u03c6/[] \u279d \u03c8) \u279d \u03c6 \u279d \u2200' \u03c8\n  | ex\u2081 t \u03c6      : HilbertProof\u1d62 \u039b <| \u03c6/[t] \u279d \u2203' \u03c6\n  | ex\u2082 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u2200' (\u03c6 \u279d \u03c8/[]) \u279d \u2203' \u03c6 \u279d \u03c8\n\ninstance : System (SyntacticFormula\u1d62 L) (Hilbert\u1d62 L) := \u27e8HilbertProof\u1d62\u27e9\n\nnamespace HilbertProof\u1d62\n\nopen System.FiniteContext Rewriting LawfulSyntacticRewriting\n\nvariable (\u039b : Hilbert\u1d62 L)\n\ninstance : System.ModusPonens \u039b := \u27e8mdp\u27e9\n\ninstance : System.HasAxiomAndInst \u039b := \u27e8and\u2083\u27e9\n\ninstance : System.HasAxiomImply\u2081 \u039b := \u27e8imply\u2081\u27e9\n\ninstance : System.HasAxiomImply\u2082 \u039b := \u27e8imply\u2082\u27e9\n\ninstance : System.Minimal \u039b where\n  mdp := mdp\n  verum := verum\n  imply\u2081 := imply\u2081\n  imply\u2082 := imply\u2082\n  and\u2081 := and\u2081\n  and\u2082 := and\u2082\n  and\u2083 := and\u2083\n  or\u2081 := or\u2081\n  or\u2082 := or\u2082\n  or\u2083 := or\u2083\n  neg_equiv _ := System.iffId _\n\nvariable {\u039b}\n\nprotected def cast {\u03c6 \u03c8} (b : \u039b \u22a2 \u03c6) (e : \u03c6 = \u03c8) : \u039b \u22a2 \u03c8 := e \u25b8 b\n\ndef depth {\u03c6} : \u039b \u22a2 \u03c6 \u2192 \u2115\n  | mdp b d => max (depth b) (depth d) + 1\n  | gen b   => depth b + 1\n  | _       => 0\n\nscoped notation \"\u2016\" d \"\u2016\" => depth d\n\n@[simp] lemma depth_eaxm (h : \u03c6 \u2208 \u039b) : \u2016eaxm h\u2016 = 0 := rfl\n@[simp] lemma depth_mdp (b : \u039b \u22a2 \u03c6 \u279d \u03c8) (d : \u039b \u22a2 \u03c6) : \u2016mdp b d\u2016 = max \u2016b\u2016 \u2016d\u2016 + 1 := rfl\n@[simp] lemma depth_gen (b : \u039b \u22a2 Rewriting.free \u03c6) : \u2016gen b\u2016 = \u2016b\u2016 + 1 := rfl\n@[simp] lemma depth_verum : \u2016(verum : \u039b \u22a2 \u22a4)\u2016 = 0 := rfl\n@[simp] lemma depth_imply\u2081 (\u03c6 \u03c8) : \u2016imply\u2081 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_imply\u2082 (\u03c6 \u03c8 \u03c7) : \u2016imply\u2082 (\u039b := \u039b) \u03c6 \u03c8 \u03c7\u2016 = 0 := rfl\n@[simp] lemma depth_and\u2081 (\u03c6 \u03c8) : \u2016and\u2081 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_and\u2082 (\u03c6 \u03c8) : \u2016and\u2082 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_and\u2083 (\u03c6 \u03c8) : \u2016and\u2083 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_or\u2081 (\u03c6 \u03c8) : \u2016or\u2081 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_or\u2082 (\u03c6 \u03c8) : \u2016or\u2082 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n", "theoremStatement": "@[simp] lemma depth_or\u2083 (\u03c6 \u03c8 \u03c7) : \u2016or\u2083 (\u039b := \u039b) \u03c6 \u03c8 \u03c7\u2016 = 0 ", "theoremName": "LO.FirstOrder.HilbertProof\u1d62.depth_or\u2083", "fileCreated": {"commit": "7d9e3859942c3a17a697b129e7fb3869eca0066e", "date": "2024-11-09"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/IntFO/Basic/Deduction.lean", "module": "Foundation.IntFO.Basic.Deduction", "jsonFile": "Foundation.IntFO.Basic.Deduction.jsonl", "positionMetadata": {"lineInFile": 111, "tokenPositionInFile": 3728, "theoremPositionInFile": 22}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 10, "numPremises": 15}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "import Foundation.FirstOrder.Arith.CobhamR0\nimport Foundation.Vorspiel.Arith\nimport Mathlib.Computability.Primrec\n\nnamespace Part\n\nlemma unit_dom_iff (x : Part Unit) : x.Dom \u2194 () \u2208 x := by simp [dom_iff_mem, show \u2200 x : Unit, x = () by intro x; rfl]\n\nend Part\n\nnamespace Mathlib.List.Vector\n\nvariable {\u03b1 : Type*}\n\n", "theoremStatement": "lemma cons_get (a : \u03b1) (v : List.Vector \u03b1 k) : (a ::\u1d65 v).get = a :> v.get ", "theoremName": "Mathlib.List.Vector.cons_get", "fileCreated": {"commit": "33e08c2b47f966f772df9af60cbdbc5688295bbf", "date": "2024-10-15"}, "theoremCreated": {"commit": "882430c05764b123332207cb6a2aa0f856c69063", "date": "2024-12-23"}, "file": "foundation/Foundation/FirstOrder/Arith/Representation.lean", "module": "Foundation.FirstOrder.Arith.Representation", "jsonFile": "Foundation.FirstOrder.Arith.Representation.jsonl", "positionMetadata": {"lineInFile": 15, "tokenPositionInFile": 313, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 32}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  ext i; cases i using Fin.cases <;> simp", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 47}}
{"srcContext": "import Foundation.Modal.Formula\n\nnamespace LO.Modal\n\nvariable {\u03b1 : Type u}\n\ninductive NNFormula (\u03b1 : Type u) : Type u where\n  | atom   : \u03b1 \u2192 NNFormula \u03b1\n  | natom  : \u03b1 \u2192 NNFormula \u03b1\n  | falsum : NNFormula \u03b1\n  | verum  : NNFormula \u03b1\n  | or     : NNFormula \u03b1 \u2192 NNFormula \u03b1 \u2192 NNFormula \u03b1\n  | and    : NNFormula \u03b1 \u2192 NNFormula \u03b1 \u2192 NNFormula \u03b1\n  | box    : NNFormula \u03b1 \u2192 NNFormula \u03b1\n  | dia    : NNFormula \u03b1 \u2192 NNFormula \u03b1\n  deriving DecidableEq\n\nnamespace NNFormula\n\nvariable {\u03c6 \u03c8 \u03c7 : NNFormula \u03b1}\n\ndef neg : NNFormula \u03b1 \u2192 NNFormula \u03b1\n  | atom a  => natom a\n  | natom a => atom a\n  | falsum  => verum\n  | verum   => falsum\n  | or \u03c6 \u03c8  => and (neg \u03c6) (neg \u03c8)\n  | and \u03c6 \u03c8 => or (neg \u03c6) (neg \u03c8)\n  | box \u03c6   => dia (neg \u03c6)\n  | dia \u03c6   => box (neg \u03c6)\n\ndef imp (\u03c6 \u03c8 : NNFormula \u03b1) : NNFormula \u03b1 := or (neg \u03c6) \u03c8\n\ninstance : BasicModalLogicalConnective (NNFormula \u03b1) where\n  tilde := neg\n  arrow := imp\n  wedge := and\n  vee := or\n  top := verum\n  bot := falsum\n  box := box\n  dia := dia\n\nlemma or_eq : or \u03c6 \u03c8 = \u03c6 \u22ce \u03c8 := rfl\n\nlemma and_eq : and \u03c6 \u03c8 = \u03c6 \u22cf \u03c8 := rfl\n\nlemma imp_eq : imp \u03c6 \u03c8 = \u03c6 \u279d \u03c8 := rfl\n\nlemma box_eq : box \u03c6 = \u25a1\u03c6 := rfl\n\nlemma dia_eq : dia \u03c6 = \u25c7\u03c6 := rfl\n\n@[simp] lemma imp_eq' : \u03c6 \u279d \u03c8 = \u223c\u03c6 \u22ce \u03c8 := rfl\n\n@[simp] lemma iff_eq : \u03c6 \u2b64 \u03c8 = (\u03c6 \u279d \u03c8) \u22cf (\u03c8 \u279d \u03c6) := rfl\n\nlemma falsum_eq : (falsum : NNFormula \u03b1) = \u22a5 := rfl\n\nlemma verum_eq : (verum : NNFormula \u03b1) = \u22a4 := rfl\n\n@[simp] lemma and_inj (\u03c6\u2081 \u03c8\u2081 \u03c6\u2082 \u03c8\u2082 : Formula \u03b1) : \u03c6\u2081 \u22cf \u03c6\u2082 = \u03c8\u2081 \u22cf \u03c8\u2082 \u2194 \u03c6\u2081 = \u03c8\u2081 \u2227 \u03c6\u2082 = \u03c8\u2082 := by simp[Wedge.wedge]\n\n@[simp] lemma or_inj (\u03c6\u2081 \u03c8\u2081 \u03c6\u2082 \u03c8\u2082 : Formula \u03b1) : \u03c6\u2081 \u22ce \u03c6\u2082 = \u03c8\u2081 \u22ce \u03c8\u2082 \u2194 \u03c6\u2081 = \u03c8\u2081 \u2227 \u03c6\u2082 = \u03c8\u2082 := by simp[Vee.vee]\n\n@[simp] lemma imp_inj (\u03c6\u2081 \u03c8\u2081 \u03c6\u2082 \u03c8\u2082 : Formula \u03b1) : \u03c6\u2081 \u279d \u03c6\u2082 = \u03c8\u2081 \u279d \u03c8\u2082 \u2194 \u03c6\u2081 = \u03c8\u2081 \u2227 \u03c6\u2082 = \u03c8\u2082 := by simp[Arrow.arrow]\n\n@[simp] lemma neg_inj (\u03c6 \u03c8 : Formula \u03b1) : \u223c\u03c6 = \u223c\u03c8 \u2194 \u03c6 = \u03c8 := by simp [NegAbbrev.neg];\n\nlemma neg_eq : neg \u03c6 = \u223c\u03c6 := rfl\n\n@[simp] lemma neg_atom (a : \u03b1) : \u223catom a = natom a := by rfl\n\n@[simp] lemma neg_natom (a : \u03b1) : \u223cnatom a = atom a := by rfl\n\nlemma negneg : \u223c\u223c\u03c6 = \u03c6 := by\n  induction \u03c6 with\n  | and \u03c6 \u03c8 ih\u03c6 ih\u03c8 =>\n    simp only [\u2190neg_eq, neg, and.injEq];\n    exact \u27e8ih\u03c6, ih\u03c8\u27e9;\n  | or \u03c6 \u03c8 ih\u03c6 ih\u03c8 =>\n    simp only [\u2190neg_eq, neg, or.injEq];\n    exact \u27e8ih\u03c6, ih\u03c8\u27e9;\n  | box \u03c6 ih\u03c6 =>\n    simp only [\u2190neg_eq, neg, box.injEq];\n    exact ih\u03c6;\n  | dia \u03c6 ih\u03c6 =>\n    simp only [\u2190neg_eq, neg, dia.injEq];\n    exact ih\u03c6;\n  | _ => tauto;\n\ninstance : ModalDeMorgan (NNFormula \u03b1) where\n  verum := by tauto;\n  falsum := by tauto;\n  and := by tauto;\n  or := by tauto;\n  box := by tauto;\n  dia := by tauto;\n  neg := \u03bb _ => negneg\n  imply := by tauto;\n\nsection toString\n\nvariable [ToString \u03b1]\ndef toStr : NNFormula \u03b1 \u2192 String\n  | atom a  => s!\"+{a}\"\n  | natom a => s!\"-{a}\"\n  | falsum  => \"\u22a5\"\n  | verum   => \"\u22a4\"\n  | or \u03c6 \u03c8  => s!\"({\u03c6.toStr} \u2228 {\u03c8.toStr})\"\n  | and \u03c6 \u03c8 => s!\"({\u03c6.toStr} \u2227 {\u03c8.toStr})\"\n  | box \u03c6   => s!\"\u25a1{\u03c6.toStr}\"\n  | dia \u03c6   => s!\"\u25c7{\u03c6.toStr}\"\ninstance : Repr (NNFormula \u03b1) := \u27e8fun t _ => toStr t\u27e9\n\nend toString\n\n\nsection toFormula\n\ndef toFormula : NNFormula \u03b1 \u2192 Formula \u03b1\n  | atom a  => Formula.atom a\n  | natom a => \u223cFormula.atom a\n  | \u22a5       => \u22a5\n  | \u22a4       => \u22a4\n  | \u03c6 \u22ce \u03c8   => \u03c6.toFormula \u22ce \u03c8.toFormula\n  | \u03c6 \u22cf \u03c8   => \u03c6.toFormula \u22cf \u03c8.toFormula\n  | \u25a1\u03c6      => \u25a1(\u03c6.toFormula)\n  | \u25c7\u03c6      => \u25c7(\u03c6.toFormula)\ninstance : Coe (NNFormula \u03b1) (Formula \u03b1) := \u27e8toFormula\u27e9\n\n@[simp] lemma toFormula_atom (a : \u03b1) : toFormula  (.atom a) = Formula.atom a := rfl\n\n@[simp] lemma toFormula_natom (a : \u03b1) : toFormula (.natom a) = \u223cFormula.atom a := rfl\n\n@[simp] lemma toFormula_falsum : toFormula \u22a5 = (\u22a5 : Formula \u03b1) := rfl\n\n@[simp] lemma toFormula_verum : toFormula \u22a4 = (\u22a4 : Formula \u03b1) := rfl\n\nend toFormula\n\n\nsection\n\n@[elab_as_elim]\ndef cases'\n  {C : NNFormula \u03b1 \u2192 Sort v}\n  (hAtom   : \u2200 a, C (atom a))\n  (hNatom  : \u2200 a, C (natom a))\n  (hFalsum : C \u22a5)\n  (hVerum  : C \u22a4)\n  (hOr     : \u2200 \u03c6 \u03c8, C (\u03c6 \u22ce \u03c8))\n  (hAnd    : \u2200 \u03c6 \u03c8, C (\u03c6 \u22cf \u03c8))\n  (hBox    : \u2200 \u03c6, C (\u25a1\u03c6))\n  (hDia    : \u2200 \u03c6, C (\u25c7\u03c6))\n  : \u2200 \u03c6, C \u03c6\n  | atom a  => hAtom a\n  | natom a => hNatom a\n  | \u22a5  => hFalsum\n  | \u22a4   => hVerum\n  | \u03c6 \u22ce \u03c8 => hOr \u03c6 \u03c8\n  | \u03c6 \u22cf \u03c8 => hAnd \u03c6 \u03c8\n  | \u25a1\u03c6 => hBox \u03c6\n  | \u25c7\u03c6 => hDia \u03c6\n\n@[elab_as_elim]\ndef rec'\n  {C : NNFormula \u03b1 \u2192 Sort v}\n  (hAtom   : \u2200 a, C (atom a))\n  (hNatom  : \u2200 a, C (natom a))\n  (hFalsum : C \u22a5)\n  (hVerum  : C \u22a4)\n  (hOr     : \u2200 \u03c6 \u03c8, C \u03c6 \u2192 C \u03c8 \u2192 C (\u03c6 \u22ce \u03c8))\n  (hAnd    : \u2200 \u03c6 \u03c8, C \u03c6 \u2192 C \u03c8 \u2192 C (\u03c6 \u22cf \u03c8))\n  (hBox    : \u2200 \u03c6, C \u03c6 \u2192 C (\u25a1\u03c6))\n  (hDia    : \u2200 \u03c6, C \u03c6 \u2192 C (\u25c7\u03c6))\n  : \u2200 \u03c6, C \u03c6\n  | atom a  => hAtom a\n  | natom a => hNatom a\n  | falsum  => hFalsum\n  | verum   => hVerum\n  | or \u03c6 \u03c8 => hOr \u03c6 \u03c8 (rec' hAtom hNatom hFalsum hVerum hOr hAnd hBox hDia \u03c6) (rec' hAtom hNatom hFalsum hVerum hOr hAnd hBox hDia \u03c8)\n  | and \u03c6 \u03c8 => hAnd \u03c6 \u03c8 (rec' hAtom hNatom hFalsum hVerum hOr hAnd hBox hDia \u03c6) (rec' hAtom hNatom hFalsum hVerum hOr hAnd hBox hDia \u03c8)\n  | box \u03c6 => hBox \u03c6 (rec' hAtom hNatom hFalsum hVerum hOr hAnd hBox hDia \u03c6)\n  | dia \u03c6 => hDia \u03c6 (rec' hAtom hNatom hFalsum hVerum hOr hAnd hBox hDia \u03c6)\n\nend\n\n\nsection Decidable\n\nend Decidable\n\n\nsection Encodable\n\nopen Encodable\n\nvariable [Encodable \u03b1]\n\ndef toNat : NNFormula \u03b1 \u2192 Nat\n  | \u22a5       => (Nat.pair 0 0) + 1\n  | \u22a4       => (Nat.pair 1 0) + 1\n  | atom a  => (Nat.pair 2 <| encode a) + 1\n  | natom a => (Nat.pair 3 <| encode a) + 1\n  | \u03c6 \u22ce \u03c8   => (Nat.pair 4 <| Nat.pair \u03c6.toNat \u03c8.toNat) + 1\n  | \u03c6 \u22cf \u03c8   => (Nat.pair 5 <| Nat.pair \u03c6.toNat \u03c8.toNat) + 1\n  | \u25a1\u03c6      => (Nat.pair 6 <| \u03c6.toNat) + 1\n  | \u25c7\u03c6      => (Nat.pair 7 <| \u03c6.toNat) + 1\n\ndef ofNat : Nat \u2192 Option (NNFormula \u03b1)\n  | 0 => none\n  | e + 1 =>\n    let idx := e.unpair.1\n    let c := e.unpair.2\n    match idx with\n    | 0 => some \u22a5\n    | 1 => some \u22a4\n    | 2 => (decode c).map NNFormula.atom\n    | 3 => (decode c).map NNFormula.natom\n    | 4 =>\n      have : c.unpair.1 < e + 1 := Nat.lt_succ.mpr $ le_trans (Nat.unpair_left_le _) $ Nat.unpair_right_le _\n      have : c.unpair.2 < e + 1 := Nat.lt_succ.mpr $ le_trans (Nat.unpair_right_le _) $ Nat.unpair_right_le _\n      do\n        let \u03c6 \u2190 ofNat c.unpair.1\n        let \u03c8 \u2190 ofNat c.unpair.2\n        return \u03c6 \u22ce \u03c8\n    | 5 =>\n      have : c.unpair.1 < e + 1 := Nat.lt_succ.mpr $ le_trans (Nat.unpair_left_le _) $ Nat.unpair_right_le _\n      have : c.unpair.2 < e + 1 := Nat.lt_succ.mpr $ le_trans (Nat.unpair_right_le _) $ Nat.unpair_right_le _\n      do\n        let \u03c6 \u2190 ofNat c.unpair.1\n        let \u03c8 \u2190 ofNat c.unpair.2\n        return \u03c6 \u22cf \u03c8\n    | 6 =>\n      have : c < e + 1 := Nat.lt_succ.mpr $ Nat.unpair_right_le _\n      do\n        let \u03c6 \u2190 ofNat c;\n        return \u25a1\u03c6\n    | 7 =>\n      have : c < e + 1 := Nat.lt_succ.mpr $ Nat.unpair_right_le _\n      do\n        let \u03c6 \u2190 ofNat c;\n        return \u25c7\u03c6\n    | _ => none\n\ninstance : Encodable (NNFormula \u03b1) where\n  encode := toNat\n  decode := ofNat\n  encodek := by\n    intro \u03c6;\n    induction \u03c6 using rec' <;> simp [toNat, ofNat, encodek, *]\n\nend Encodable\n\n\nend NNFormula\n\n\nnamespace Formula\n\ndef toNNFormula : Formula \u03b1 \u2192 NNFormula \u03b1\n  | atom a  => NNFormula.atom a\n  | \u22a5       => NNFormula.falsum\n  | \u03c6 \u279d \u03c8   => \u03c6.toNNFormula.neg \u22ce \u03c8.toNNFormula\n  | \u25a1\u03c6      => \u25a1\u03c6.toNNFormula\ninstance : Coe (Formula \u03b1) (NNFormula \u03b1) := \u27e8toNNFormula\u27e9\n\n@[simp] lemma toNNFormula_atom (a : \u03b1) : toNNFormula (atom a) = .atom a := rfl\n\n", "theoremStatement": "@[simp] lemma toNNFormula_falsum : toNNFormula \u22a5 = (\u22a5 : NNFormula \u03b1) ", "theoremName": "LO.Modal.Formula.toNNFormula_falsum", "fileCreated": {"commit": "1f10809ea0f0e98679f13cd2f7f5b706b01878a8", "date": "2024-11-20"}, "theoremCreated": {"commit": "54324e6e009f0d0a288897312d3feb1c0165ad19", "date": "2025-01-24"}, "file": "foundation/Foundation/Modal/NNFormula.lean", "module": "Foundation.Modal.NNFormula", "jsonFile": "Foundation.Modal.NNFormula.jsonl", "positionMetadata": {"lineInFile": 271, "tokenPositionInFile": 7089, "theoremPositionInFile": 23}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 7, "numPremises": 10}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "import Foundation.Modal.Formula\n\nnamespace LO.Modal\n\nvariable {\u03b1 : Type u}\n\ninductive NNFormula (\u03b1 : Type u) : Type u where\n  | atom   : \u03b1 \u2192 NNFormula \u03b1\n  | natom  : \u03b1 \u2192 NNFormula \u03b1\n  | falsum : NNFormula \u03b1\n  | verum  : NNFormula \u03b1\n  | or     : NNFormula \u03b1 \u2192 NNFormula \u03b1 \u2192 NNFormula \u03b1\n  | and    : NNFormula \u03b1 \u2192 NNFormula \u03b1 \u2192 NNFormula \u03b1\n  | box    : NNFormula \u03b1 \u2192 NNFormula \u03b1\n  | dia    : NNFormula \u03b1 \u2192 NNFormula \u03b1\n  deriving DecidableEq\n\nnamespace NNFormula\n\nvariable {\u03c6 \u03c8 \u03c7 : NNFormula \u03b1}\n\ndef neg : NNFormula \u03b1 \u2192 NNFormula \u03b1\n  | atom a  => natom a\n  | natom a => atom a\n  | falsum  => verum\n  | verum   => falsum\n  | or \u03c6 \u03c8  => and (neg \u03c6) (neg \u03c8)\n  | and \u03c6 \u03c8 => or (neg \u03c6) (neg \u03c8)\n  | box \u03c6   => dia (neg \u03c6)\n  | dia \u03c6   => box (neg \u03c6)\n\ndef imp (\u03c6 \u03c8 : NNFormula \u03b1) : NNFormula \u03b1 := or (neg \u03c6) \u03c8\n\ninstance : BasicModalLogicalConnective (NNFormula \u03b1) where\n  tilde := neg\n  arrow := imp\n  wedge := and\n  vee := or\n  top := verum\n  bot := falsum\n  box := box\n  dia := dia\n\nlemma or_eq : or \u03c6 \u03c8 = \u03c6 \u22ce \u03c8 := rfl\n\nlemma and_eq : and \u03c6 \u03c8 = \u03c6 \u22cf \u03c8 := rfl\n\nlemma imp_eq : imp \u03c6 \u03c8 = \u03c6 \u279d \u03c8 := rfl\n\nlemma box_eq : box \u03c6 = \u25a1\u03c6 := rfl\n\nlemma dia_eq : dia \u03c6 = \u25c7\u03c6 := rfl\n\n@[simp] lemma imp_eq' : \u03c6 \u279d \u03c8 = \u223c\u03c6 \u22ce \u03c8 := rfl\n\n@[simp] lemma iff_eq : \u03c6 \u2b64 \u03c8 = (\u03c6 \u279d \u03c8) \u22cf (\u03c8 \u279d \u03c6) := rfl\n\nlemma falsum_eq : (falsum : NNFormula \u03b1) = \u22a5 := rfl\n\nlemma verum_eq : (verum : NNFormula \u03b1) = \u22a4 := rfl\n\n@[simp] lemma and_inj (\u03c6\u2081 \u03c8\u2081 \u03c6\u2082 \u03c8\u2082 : Formula \u03b1) : \u03c6\u2081 \u22cf \u03c6\u2082 = \u03c8\u2081 \u22cf \u03c8\u2082 \u2194 \u03c6\u2081 = \u03c8\u2081 \u2227 \u03c6\u2082 = \u03c8\u2082 := by simp[Wedge.wedge]\n\n@[simp] lemma or_inj (\u03c6\u2081 \u03c8\u2081 \u03c6\u2082 \u03c8\u2082 : Formula \u03b1) : \u03c6\u2081 \u22ce \u03c6\u2082 = \u03c8\u2081 \u22ce \u03c8\u2082 \u2194 \u03c6\u2081 = \u03c8\u2081 \u2227 \u03c6\u2082 = \u03c8\u2082 := by simp[Vee.vee]\n\n@[simp] lemma imp_inj (\u03c6\u2081 \u03c8\u2081 \u03c6\u2082 \u03c8\u2082 : Formula \u03b1) : \u03c6\u2081 \u279d \u03c6\u2082 = \u03c8\u2081 \u279d \u03c8\u2082 \u2194 \u03c6\u2081 = \u03c8\u2081 \u2227 \u03c6\u2082 = \u03c8\u2082 := by simp[Arrow.arrow]\n\n@[simp] lemma neg_inj (\u03c6 \u03c8 : Formula \u03b1) : \u223c\u03c6 = \u223c\u03c8 \u2194 \u03c6 = \u03c8 := by simp [NegAbbrev.neg];\n\nlemma neg_eq : neg \u03c6 = \u223c\u03c6 := rfl\n\n@[simp] lemma neg_atom (a : \u03b1) : \u223catom a = natom a := by rfl\n\n@[simp] lemma neg_natom (a : \u03b1) : \u223cnatom a = atom a := by rfl\n\nlemma negneg : \u223c\u223c\u03c6 = \u03c6 := by\n  induction \u03c6 with\n  | and \u03c6 \u03c8 ih\u03c6 ih\u03c8 =>\n    simp only [\u2190neg_eq, neg, and.injEq];\n    exact \u27e8ih\u03c6, ih\u03c8\u27e9;\n  | or \u03c6 \u03c8 ih\u03c6 ih\u03c8 =>\n    simp only [\u2190neg_eq, neg, or.injEq];\n    exact \u27e8ih\u03c6, ih\u03c8\u27e9;\n  | box \u03c6 ih\u03c6 =>\n    simp only [\u2190neg_eq, neg, box.injEq];\n    exact ih\u03c6;\n  | dia \u03c6 ih\u03c6 =>\n    simp only [\u2190neg_eq, neg, dia.injEq];\n    exact ih\u03c6;\n  | _ => tauto;\n\ninstance : ModalDeMorgan (NNFormula \u03b1) where\n  verum := by tauto;\n  falsum := by tauto;\n  and := by tauto;\n  or := by tauto;\n  box := by tauto;\n  dia := by tauto;\n  neg := \u03bb _ => negneg\n  imply := by tauto;\n\nsection toString\n\nvariable [ToString \u03b1]\ndef toStr : NNFormula \u03b1 \u2192 String\n  | atom a  => s!\"+{a}\"\n  | natom a => s!\"-{a}\"\n  | falsum  => \"\u22a5\"\n  | verum   => \"\u22a4\"\n  | or \u03c6 \u03c8  => s!\"({\u03c6.toStr} \u2228 {\u03c8.toStr})\"\n  | and \u03c6 \u03c8 => s!\"({\u03c6.toStr} \u2227 {\u03c8.toStr})\"\n  | box \u03c6   => s!\"\u25a1{\u03c6.toStr}\"\n  | dia \u03c6   => s!\"\u25c7{\u03c6.toStr}\"\ninstance : Repr (NNFormula \u03b1) := \u27e8fun t _ => toStr t\u27e9\n\nend toString\n\n\nsection toFormula\n\ndef toFormula : NNFormula \u03b1 \u2192 Formula \u03b1\n  | atom a  => Formula.atom a\n  | natom a => \u223cFormula.atom a\n  | \u22a5       => \u22a5\n  | \u22a4       => \u22a4\n  | \u03c6 \u22ce \u03c8   => \u03c6.toFormula \u22ce \u03c8.toFormula\n  | \u03c6 \u22cf \u03c8   => \u03c6.toFormula \u22cf \u03c8.toFormula\n  | \u25a1\u03c6      => \u25a1(\u03c6.toFormula)\n  | \u25c7\u03c6      => \u25c7(\u03c6.toFormula)\ninstance : Coe (NNFormula \u03b1) (Formula \u03b1) := \u27e8toFormula\u27e9\n\n@[simp] lemma toFormula_atom (a : \u03b1) : toFormula  (.atom a) = Formula.atom a := rfl\n\n@[simp] lemma toFormula_natom (a : \u03b1) : toFormula (.natom a) = \u223cFormula.atom a := rfl\n\n@[simp] lemma toFormula_falsum : toFormula \u22a5 = (\u22a5 : Formula \u03b1) := rfl\n\n", "theoremStatement": "@[simp] lemma toFormula_verum : toFormula \u22a4 = (\u22a4 : Formula \u03b1) ", "theoremName": "LO.Modal.NNFormula.toFormula_verum", "fileCreated": {"commit": "1f10809ea0f0e98679f13cd2f7f5b706b01878a8", "date": "2024-11-20"}, "theoremCreated": {"commit": "54324e6e009f0d0a288897312d3feb1c0165ad19", "date": "2025-01-24"}, "file": "foundation/Foundation/Modal/NNFormula.lean", "module": "Foundation.Modal.NNFormula", "jsonFile": "Foundation.Modal.NNFormula.jsonl", "positionMetadata": {"lineInFile": 138, "tokenPositionInFile": 3505, "theoremPositionInFile": 21}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 7, "numPremises": 10}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "import Foundation.IntFO.Translation\n\n/-!\n#Algebraic Proofs of Cut Elimination\n\nMain reference: Jeremy Avigad, Algebraic proofs of cut elimination, The Journal of Logic and Algebraic Programming, Volume 49, Issues 1\u20132, 2001, Pages 15-30\n -/\n\nnamespace LO.FirstOrder\n\nvariable {L : Language.{u}}\n\nnamespace Derivation\n\ninductive IsCutFree : {\u0393 : Sequent L} \u2192 \u22a2\u1d40 \u0393 \u2192 Prop\n| axL (\u0393) {k} (r : L.Rel k) (v)                 : IsCutFree (axL \u0393 r v)\n| verum (\u0393)                                     : IsCutFree (verum \u0393)\n| or {\u0393 \u03c6 \u03c8} {d : \u22a2\u1d40 \u03c6 :: \u03c8 :: \u0393}               : IsCutFree d \u2192 IsCutFree d.or\n| and {\u0393 \u03c6 \u03c8} {d\u03c6 : \u22a2\u1d40 \u03c6 :: \u0393} {d\u03c8 : \u22a2\u1d40 \u03c8 :: \u0393} : IsCutFree d\u03c6 \u2192 IsCutFree d\u03c8 \u2192 IsCutFree (d\u03c6.and d\u03c8)\n| all {\u0393 \u03c6} {d : \u22a2\u1d40 Rewriting.free \u03c6 :: \u0393\u207a}     : IsCutFree d \u2192 IsCutFree d.all\n| ex {\u0393 \u03c6} (t) {d : \u22a2\u1d40 \u03c6/[t] :: \u0393}              : IsCutFree d \u2192 IsCutFree d.ex\n| wk {\u0394 \u0393} {d : \u22a2\u1d40 \u0394} (ss : \u0394 \u2286 \u0393)              : IsCutFree d \u2192 IsCutFree (d.wk ss)\n\nattribute [simp] IsCutFree.axL IsCutFree.verum\n\nvariable {\u0393 \u0394 : Sequent L}\n\n", "theoremStatement": "@[simp] lemma isCutFree_or_iff {d : \u22a2\u1d40 \u03c6 :: \u03c8 :: \u0393} :\n    IsCutFree d.or \u2194 IsCutFree d ", "theoremName": "LO.FirstOrder.Derivation.isCutFree_or_iff", "fileCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/FirstOrder/Hauptsatz.lean", "module": "Foundation.FirstOrder.Hauptsatz", "jsonFile": "Foundation.FirstOrder.Hauptsatz.jsonl", "positionMetadata": {"lineInFile": 28, "tokenPositionInFile": 1012, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 8, "repositoryPremises": true, "numRepositoryPremises": 48, "numPremises": 77}, "proofMetadata": {"hasProof": true, "proof": ":= \u27e8by rintro \u27e8\u27e9; assumption, .or\u27e9", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 34}}
{"srcContext": "import Foundation.Logic.Predicate.Term\nimport Foundation.Logic.Predicate.Quantifier\n\n/-!\n# Rewriting System\n\nterm/formula morphisms such as Rewritings, substitutions, and embeddings are handled by the structure `LO.FirstOrder.Rew`.\n- `LO.FirstOrder.Rew.rewrite f` is a Rewriting of the free variables occurring in the term by `f : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n`.\n- `LO.FirstOrder.Rew.substs v` is a substitution of the bounded variables occurring in the term by `v : Fin n \u2192 Semiterm L \u03be n'`.\n- `LO.FirstOrder.Rew.bShift` is a transformation of the bounded variables occurring in the term by `#x \u21a6 #(Fin.succ x)`.\n- `LO.FirstOrder.Rew.shift` is a transformation of the free variables occurring in the term by `&x \u21a6 &(x + 1)`.\n- `LO.FirstOrder.Rew.emb` is a embedding of the term with no free variables.\n\nRewritings `LO.FirstOrder.Rew` is naturally converted to formula Rewritings by `LO.FirstOrder.Rew.hom`.\n\n-/\n\nnamespace LO\n\nnamespace FirstOrder\n\nstructure Rew (L : Language) (\u03be\u2081 : Type*) (n\u2081 : \u2115) (\u03be\u2082 : Type*) (n\u2082 : \u2115) where\n  toFun : Semiterm L \u03be\u2081 n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082\n  func' : \u2200 {k} (f : L.Func k) (v : Fin k \u2192 Semiterm L \u03be\u2081 n\u2081), toFun (Semiterm.func f v) = Semiterm.func f (fun i => toFun (v i))\n\nabbrev SyntacticRew (L : Language) (n\u2081 n\u2082 : \u2115) := Rew L \u2115 n\u2081 \u2115 n\u2082\n\nnamespace Rew\n\nopen Semiterm\nvariable {L L' L\u2081 L\u2082 L\u2083 : Language} {\u03be \u03be' \u03be\u2081 \u03be\u2082 \u03be\u2083 : Type*} {n n\u2081 n\u2082 n\u2083 : \u2115}\nvariable (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082)\n\ninstance : FunLike (Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) (Semiterm L \u03be\u2081 n\u2081) (Semiterm L \u03be\u2082 n\u2082) where\n  coe := fun f => f.toFun\n  coe_injective' := fun f g h => by rcases f; rcases g; simpa using h\n\ninstance : CoeFun (Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) (fun _ => Semiterm L \u03be\u2081 n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) := DFunLike.hasCoeToFun\n\nprotected lemma func {k} (f : L.Func k) (v : Fin k \u2192 Semiterm L \u03be\u2081 n\u2081) :\n    \u03c9 (func f v) = func f (fun i => \u03c9 (v i)) := \u03c9.func' f v\n\nlemma func'' {k} (f : L.Func k) (v : Fin k \u2192 Semiterm L \u03be\u2081 n\u2081) :\n    \u03c9 (func f v) = func f (\u03c9 \u2218 v) := \u03c9.func' f v\n\n@[simp] lemma func0 (f : L.Func 0) (v : Fin 0 \u2192 Semiterm L \u03be\u2081 n\u2081) :\n    \u03c9 (func f v) = func f ![] := by simp[Rew.func, Matrix.empty_eq]\n\n@[simp] lemma func1 (f : L.Func 1) (t : Semiterm L \u03be\u2081 n\u2081) :\n    \u03c9 (func f ![t]) = func f ![\u03c9 t] := by simp[Matrix.constant_eq_singleton, Rew.func]\n\n@[simp] lemma func2 (f : L.Func 2) (t\u2081 t\u2082 : Semiterm L \u03be\u2081 n\u2081) :\n    \u03c9 (func f ![t\u2081, t\u2082]) = func f ![\u03c9 t\u2081, \u03c9 t\u2082] := by\n  simp only [Rew.func, func.injEq, heq_eq_eq, true_and]\n  funext i\n  induction i using Fin.induction <;> simp\n\n@[simp] lemma func3 (f : L.Func 3) (t\u2081 t\u2082 t\u2083 : Semiterm L \u03be\u2081 n\u2081) :\n    \u03c9 (func f ![t\u2081, t\u2082, t\u2083]) = func f ![\u03c9 t\u2081, \u03c9 t\u2082, \u03c9 t\u2083] := by\n  simp only [Rew.func, func.injEq, heq_eq_eq, true_and]\n  funext i; induction' i using Fin.induction with i\n  \u00b7 simp\n  \u00b7 induction' i using Fin.induction with i <;> simp\n\n@[ext] lemma ext (\u03c9\u2081 \u03c9\u2082 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) (hb : \u2200 x, \u03c9\u2081 #x = \u03c9\u2082 #x) (hf : \u2200 x, \u03c9\u2081 &x = \u03c9\u2082 &x) : \u03c9\u2081 = \u03c9\u2082 := by\n  apply DFunLike.ext \u03c9\u2081 \u03c9\u2082; intro t\n  induction t <;> simp[*, \u03c9\u2081.func, \u03c9\u2082.func]\n\nlemma ext' {\u03c9\u2081 \u03c9\u2082 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082} (h : \u03c9\u2081 = \u03c9\u2082) (t) : \u03c9\u2081 t = \u03c9\u2082 t := by simp[h]\n\nprotected def id : Rew L \u03be n \u03be n where\n  toFun := id\n  func' := fun _ _ => rfl\n\n@[simp] lemma id_app (t : Semiterm L \u03be n) : Rew.id t = t := rfl\n\nprotected def comp (\u03c9\u2082 : Rew L \u03be\u2082 n\u2082 \u03be\u2083 n\u2083) (\u03c9\u2081 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) : Rew L \u03be\u2081 n\u2081 \u03be\u2083 n\u2083 where\n  toFun := fun t => \u03c9\u2082 (\u03c9\u2081 t)\n  func' := fun f v => by simp[func'']; rfl\n\nlemma comp_app (\u03c9\u2082 : Rew L \u03be\u2082 n\u2082 \u03be\u2083 n\u2083) (\u03c9\u2081 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) (t : Semiterm L \u03be\u2081 n\u2081) :\n    (\u03c9\u2082.comp \u03c9\u2081) t = \u03c9\u2082 (\u03c9\u2081 t) := rfl\n\n@[simp] lemma id_comp (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) : Rew.id.comp \u03c9 = \u03c9 := by ext <;> simp[comp_app]\n\n@[simp] lemma comp_id (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) : \u03c9.comp Rew.id = \u03c9 := by ext <;> simp[comp_app]\n\ndef bindAux (b : Fin n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) (e : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) : Semiterm L \u03be\u2081 n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082\n  | (#x)       => b x\n  | (&x)       => e x\n  | (func f v) => func f (fun i => bindAux b e (v i))\n\ndef bind (b : Fin n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) (e : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082 where\n  toFun := bindAux b e\n  func' := fun _ _ => rfl\n\ndef rewrite (f : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n) : Rew L \u03be\u2081 n \u03be\u2082 n := bind Semiterm.bvar f\n\ndef rewriteMap (e : \u03be\u2081 \u2192 \u03be\u2082) : Rew L \u03be\u2081 n \u03be\u2082 n := rewrite (fun m => &(e m))\n\ndef map (b : Fin n\u2081 \u2192 Fin n\u2082) (e : \u03be\u2081 \u2192 \u03be\u2082) : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082 :=\n  bind (fun n => #(b n)) (fun m => &(e m))\n\ndef substs {n'} (v : Fin n \u2192 Semiterm L \u03be n') : Rew L \u03be n \u03be n' :=\n  bind v fvar\n\ndef emb {o : Type v\u2081} [h : IsEmpty o] {\u03be : Type v\u2082} {n} : Rew L o n \u03be n := map id h.elim\n\nabbrev embs {o : Type v\u2081} [IsEmpty o] {n} : Rew L o n \u2115 n := emb\n\ndef empty {o : Type v\u2081} [h : IsEmpty o] {\u03be : Type v\u2082} {n} : Rew L o 0 \u03be n := map Fin.elim0 h.elim\n\ndef bShift : Rew L \u03be n \u03be (n + 1) :=\n  map Fin.succ id\n\ndef bShiftAdd (m : \u2115) : Rew L \u03be n \u03be (n + m) :=\n  map (Fin.addNat \u00b7 m) id\n\ndef cast {n n' : \u2115} (h : n = n') : Rew L \u03be n \u03be n' :=\n  map (Fin.cast h) id\n\ndef castLE {n n' : \u2115} (h : n \u2264 n') : Rew L \u03be n \u03be n' :=\n  map (Fin.castLE h) id\n\ndef toS : Rew L (Fin n) 0 Empty n := Rew.bind ![] (#\u00b7)\n\ndef toF : Rew L Empty n (Fin n) 0 := Rew.bind (&\u00b7) Empty.elim\n\ndef embSubsts (v : Fin k \u2192 Semiterm L \u03be n) : Rew L Empty k \u03be n := Rew.bind v Empty.elim\n\nprotected def q (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) : Rew L \u03be\u2081 (n\u2081 + 1) \u03be\u2082 (n\u2082 + 1) :=\n  bind (#0 :> bShift \u2218 \u03c9 \u2218 bvar) (bShift \u2218 \u03c9 \u2218 fvar)\n\nlemma eq_id_of_eq {\u03c9 : Rew L \u03be n \u03be n} (hb : \u2200 x, \u03c9 #x = #x) (he : \u2200 x, \u03c9 &x = &x) (t) : \u03c9 t = t := by\n  have : \u03c9 = Rew.id := by ext <;> simp[*]\n  simp[this]\n\ndef qpow (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) : (k : \u2115) \u2192 Rew L \u03be\u2081 (n\u2081 + k) \u03be\u2082 (n\u2082 + k)\n  | 0     => \u03c9\n  | k + 1 => (\u03c9.qpow k).q\n\n@[simp] lemma qpow_zero (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) : qpow \u03c9 0 = \u03c9 := rfl\n\n@[simp] lemma qpow_succ (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) (k : \u2115) : qpow \u03c9 (k + 1) = (\u03c9.qpow k).q := rfl\n\nsection bind\n\nvariable (b : Fin n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) (e : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082)\n\n@[simp] lemma bind_fvar (m : \u03be\u2081) : bind b e (&m : Semiterm L \u03be\u2081 n\u2081) = e m := rfl\n\n@[simp] lemma bind_bvar (n : Fin n\u2081) : bind b e (#n : Semiterm L \u03be\u2081 n\u2081) = b n := rfl\n\nlemma eq_bind (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) : \u03c9 = bind (\u03c9 \u2218 bvar) (\u03c9 \u2218 fvar) := by\n  ext t; induction t ;simp [Rew.func'']; simp [*]\n\n@[simp] lemma bind_eq_id_of_zero (f : Fin 0 \u2192 Semiterm L \u03be\u2082 0) : bind f fvar = Rew.id := by\n  ext x <;> simp only [bind_bvar, bind_fvar, id_app]; exact Fin.elim0 x\n\nend bind\n\nsection map\n\nvariable (b : Fin n\u2081 \u2192 Fin n\u2082) (e : \u03be\u2081 \u2192 \u03be\u2082)\n\n@[simp] lemma map_fvar (m : \u03be\u2081) : map b e (&m : Semiterm L \u03be\u2081 n\u2081) = &(e m) := rfl\n\n@[simp] lemma map_bvar (n : Fin n\u2081) : map b e (#n : Semiterm L \u03be\u2081 n\u2081) = #(b n) := rfl\n\n@[simp] lemma map_id : map (L := L) (id : Fin n \u2192 Fin n) (id : \u03be \u2192 \u03be) = Rew.id := by ext <;> simp\n\nlemma map_inj {b : Fin n\u2081 \u2192 Fin n\u2082} {e : \u03be\u2081 \u2192 \u03be\u2082} (hb : Function.Injective b) (he : Function.Injective e) :\n    Function.Injective $ map (L := L) b e\n  | #x,                    #y                    => by simpa using @hb _ _\n  | #x,                    &y                    => by simp\n  | #x,                    func f w              => by simp [Rew.func]\n  | &x,                    #y                    => by simp\n  | &x,                    &y                    => by simpa using @he _ _\n  | &x,                    func f w              => by simp [Rew.func]\n  | func f v,              #y                    => by simp [Rew.func]\n  | func f v,              &y                    => by simp [Rew.func]\n  | func (arity := k) f v, func (arity := l) g w => fun h \u21a6 by\n    have : k = l := by simp [Rew.func] at h; simp_all\n    rcases this\n    have : f = g := by simp [Rew.func] at h; simp_all\n    rcases this\n    have : v = w := by\n      have : (fun i \u21a6 (map b e) (v i)) = (fun i \u21a6 (map b e) (w i)) := by simpa [Rew.func] using h\n      funext i; exact map_inj hb he (congrFun this i)\n    simp_all\n\nend map\n\nsection rewrite\n\nvariable (f : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n)\n\n@[simp] lemma rewrite_fvar (x : \u03be\u2081) : rewrite f &x = f x := rfl\n\n@[simp] lemma rewrite_bvar (x : Fin n) : rewrite e (#x : Semiterm L \u03be\u2081 n) = #x := rfl\n\nlemma rewrite_comp_rewrite (v : \u03be\u2082 \u2192 Semiterm L \u03be\u2083 n) (w : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n) :\n    (rewrite v).comp (rewrite w) = rewrite (rewrite v \u2218 w) :=\n  by ext <;> simp[comp_app]\n\n@[simp] lemma rewrite_eq_id : (rewrite Semiterm.fvar : Rew L \u03be n \u03be n) = Rew.id := by ext <;> simp\n\nend rewrite\n\nsection rewriteMap\n\nvariable (e : \u03be\u2081 \u2192 \u03be\u2082)\n\n@[simp] lemma rewriteMap_fvar (x : \u03be\u2081) : rewriteMap e (&x : Semiterm L \u03be\u2081 n) = &(e x) := rfl\n\n@[simp] lemma rewriteMap_bvar (x : Fin n) : rewriteMap e (#x : Semiterm L \u03be\u2081 n) = #x := rfl\n\n@[simp] lemma rewriteMap_id : rewriteMap (L := L) (n := n) (id : \u03be \u2192 \u03be) = Rew.id := by ext <;> simp\n\nlemma eq_rewriteMap_of_funEqOn_fv [DecidableEq \u03be\u2081] (t : Semiterm L \u03be\u2081 n\u2081) (f g : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) (h : Function.funEqOn t.FVar? f g) :\n    Rew.rewriteMap f t = Rew.rewriteMap g t := by\n  induction t\n  case bvar => simp\n  case fvar x => simpa using h x (by simp)\n  case func f v ih =>\n    simp only [Rew.func, func.injEq, heq_eq_eq, true_and]\n    funext i\n    exact ih i (fun x hx \u21a6 h x (by simpa [Semiterm.fvar?_func] using \u27e8i, hx\u27e9))\n\nend rewriteMap\n\nsection emb\n\nvariable {o : Type v\u2082} [IsEmpty o]\n\n@[simp] lemma emb_bvar (x : Fin n) : emb (\u03be := \u03be) (#x : Semiterm L o n) = #x := rfl\n\n@[simp] lemma emb_eq_id : (emb : Rew L o n o n) = Rew.id := by\n  ext x <;> simp only [emb_bvar, id_app]; exact isEmptyElim x\n\nlemma eq_empty [h : IsEmpty \u03be\u2081] (\u03c9 : Rew L \u03be\u2081 0 \u03be\u2082 n) :\n  \u03c9 = empty := by ext x; { exact x.elim0 }; { exact h.elim' x }\n\nend emb\n\nsection bShift\n\n@[simp] lemma bShift_bvar (x : Fin n) : bShift (#x : Semiterm L \u03be n) = #(Fin.succ x) := rfl\n\n@[simp] lemma bShift_fvar (x : \u03be) : bShift (&x : Semiterm L \u03be n) = &x := rfl\n\n@[simp] lemma bShift_ne_zero (t : Semiterm L \u03be n) : bShift t \u2260 #0 := by\n  cases t <;> simp[Rew.func, Fin.succ_ne_zero]\n\n@[simp] lemma bShift_positive (t : Semiterm L \u03be n) : (bShift t).Positive := by\n  induction t <;> simp [Rew.func, *]\n\nlemma positive_iff {t : Semiterm L \u03be (n + 1)} : t.Positive \u2194 \u2203 t', t = bShift t' :=\n  \u27e8by induction t <;> simp\n      case bvar x =>\n        intro hx; exact \u27e8#(x.pred (Fin.pos_iff_ne_zero.mp hx)), by simp\u27e9\n      case fvar x => exact \u27e8&x, by simp\u27e9\n      case func k f v ih =>\n        intro h\n        have : \u2200 i, \u2203 t', v i = bShift t' := fun i => ih i (h i)\n        choose w hw using this\n        exact \u27e8func f w, by simp [Rew.func]; funext i; exact hw i\u27e9,\n   by rintro \u27e8t', rfl\u27e9; simp\u27e9\n\n@[simp] lemma leftConcat_bShift_comp_bvar :\n    (#0 :> bShift \u2218 bvar : Fin (n + 1) \u2192 Semiterm L \u03be (n + 1)) = bvar :=\n  funext (Fin.cases (by simp) (by simp))\n\n@[simp] lemma bShift_comp_fvar :\n    (bShift \u2218 fvar : \u03be \u2192 Semiterm L \u03be (n + 1)) = fvar :=\n  funext (by simp)\n\nend bShift\n\nsection bShiftAdd\n\n@[simp] lemma bShiftAdd_bvar (m) (x : Fin n) : bShiftAdd m (#x : Semiterm L \u03be n) = #(Fin.addNat x m) := rfl\n\n@[simp] lemma bShiftAdd_fvar (m) (x : \u03be) : bShiftAdd m (&x : Semiterm L \u03be n) = &x := rfl\n\nend bShiftAdd\n\nsection substs\n\nvariable {n'} (w : Fin n \u2192 Semiterm L \u03be n')\n\n@[simp] lemma substs_bvar (x : Fin n) : substs w #x = w x :=\n  by simp[substs]\n\n@[simp] lemma substs_fvar (x : \u03be) : substs w &x = &x :=\n  by simp[substs]\n\n@[simp] lemma substs_zero (w : Fin 0 \u2192 Term L \u03be) : substs w = Rew.id :=\n  by ext x <;> simp; { exact Fin.elim0 x }\n\nlemma substs_comp_substs (v : Fin l \u2192 Semiterm L \u03be k) (w : Fin k \u2192 Semiterm L \u03be n) :\n    (substs w).comp (substs v) = substs (substs w \u2218 v) :=\n  by ext <;> simp[comp_app]\n\n@[simp] lemma substs_eq_id : (substs Semiterm.bvar : Rew L \u03be n \u03be n) = Rew.id := by ext <;> simp\n\nend substs\n\nsection cast\n\nvariable {n'} (h : n = n')\n\n@[simp] lemma cast_bvar (x : Fin n) : cast h (#x : Semiterm L \u03be n) = #(Fin.cast h x) := rfl\n\n@[simp] lemma cast_fvar (x : \u03be) : cast h (&x : Semiterm L \u03be n) = &x := rfl\n\n@[simp] lemma cast_eq_id {h} : (cast h : Rew L \u03be n \u03be n) = Rew.id := by ext <;> simp\n\nend cast\n\nsection castLE\n\n@[simp] lemma castLe_bvar {n'} (h : n \u2264 n') (x : Fin n) : castLE h (#x : Semiterm L \u03be n) = #(Fin.castLE h x) := rfl\n\n@[simp] lemma castLe_fvar {n'} (h : n \u2264 n') (x : \u03be) : castLE h (&x : Semiterm L \u03be n) = &x := rfl\n\n@[simp] lemma castLe_eq_id {h} : (castLE h : Rew L \u03be n \u03be n) = Rew.id := by ext <;> simp\n\nend castLE\n\nsection toS\n\n@[simp] lemma toS_fvar {n} (x : Fin n) : toS (&x : Term L (Fin n)) = #x := rfl\n\nend toS\n\nsection embSubsts\n\nvariable {k} (w : Fin k \u2192 Semiterm L \u03be n)\n\n@[simp] lemma embSubsts_bvar (x : Fin k) : embSubsts w #x = w x :=\n  by simp[embSubsts]\n\n@[simp] lemma embSubsts_zero (w : Fin 0 \u2192 Term L \u03be) : embSubsts w = Rew.emb := by\n  ext x <;> try simp\n  \u00b7 exact Fin.elim0 x\n  \u00b7 exact Empty.elim x\n\nlemma substs_comp_embSubsts (v : Fin l \u2192 Semiterm L \u03be k) (w : Fin k \u2192 Semiterm L \u03be n) :\n    (substs w).comp (embSubsts v) = embSubsts (substs w \u2218 v) := by\n  ext x <;> simp[comp_app]\n  exact Empty.elim x\n\n@[simp] lemma embSubsts_eq_id : (embSubsts Semiterm.bvar : Rew L Empty n \u03be n) = Rew.emb := by\n  ext x <;> try simp\n  \u00b7 exact Empty.elim x\n\nend embSubsts\n\nsection \u03c8\n\nvariable (\u03c9 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082)\n\n@[simp] lemma q_bvar_zero : \u03c9.q #0 = #0 := by simp[Rew.q]\n\n@[simp] lemma q_bvar_succ (i : Fin n\u2081) : \u03c9.q #(i.succ) = bShift (\u03c9 #i) := by simp[Rew.q]\n\n@[simp] lemma q_fvar (x : \u03be\u2081) : \u03c9.q &x = bShift (\u03c9 &x) := by simp[Rew.q]\n\n@[simp] lemma q_comp_bShift : \u03c9.q.comp bShift = bShift.comp \u03c9 := by\n  ext x <;> simp[comp_app]\n\n@[simp] lemma q_comp_bShift_app (t : Semiterm L \u03be\u2081 n\u2081) : \u03c9.q (bShift t) = bShift (\u03c9 t) := by\n  have := ext' (\u03c9.q_comp_bShift) t; simpa only [comp_app] using this\n\n@[simp] lemma q_id : (Rew.id : Rew L \u03be n \u03be n).q = Rew.id := by ext x; { cases x using Fin.cases <;> simp }; { simp }\n\n@[simp] lemma q_eq_zero_iff : \u03c9.q t = #0 \u2194 t = #0 := by\n  cases t <;> simp [Rew.func]\n  case bvar i =>\n    cases i using Fin.cases <;> simp [Fin.succ_ne_zero]\n\n@[simp] lemma q_positive_iff : (\u03c9.q t).Positive \u2194 t.Positive := by\n  induction t <;> simp [Rew.func, *]\n  case bvar x =>\n    cases x using Fin.cases <;> simp\n\n@[simp] lemma qpow_id {k} : (Rew.id : Rew L \u03be n \u03be n).qpow k = Rew.id := by induction k <;> simp[*]\n\nlemma q_comp (\u03c9\u2082 : Rew L \u03be\u2082 n\u2082 \u03be\u2083 n\u2083) (\u03c9\u2081 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) :\n    (Rew.comp \u03c9\u2082 \u03c9\u2081).q = \u03c9\u2082.q.comp \u03c9\u2081.q := by ext x; { cases x using Fin.cases <;> simp[comp_app] }; { simp[comp_app] }\n\nlemma qpow_comp (k) (\u03c9\u2082 : Rew L \u03be\u2082 n\u2082 \u03be\u2083 n\u2083) (\u03c9\u2081 : Rew L \u03be\u2081 n\u2081 \u03be\u2082 n\u2082) :\n    (Rew.comp \u03c9\u2082 \u03c9\u2081).qpow k = (\u03c9\u2082.qpow k).comp (\u03c9\u2081.qpow k) := by induction k <;> simp[*, q_comp]\n\nlemma q_bind (b : Fin n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) (e : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) :\n    (bind b e).q = bind (#0 :> bShift \u2218 b) (bShift \u2218 e) := by ext x; { cases x using Fin.cases <;> simp }; { simp }\n\nlemma q_map (b : Fin n\u2081 \u2192 Fin n\u2082) (e : \u03be\u2081 \u2192 \u03be\u2082) :\n    (map (L := L) b e).q = map (0 :> Fin.succ \u2218 b) e := by ext x; { cases x using Fin.cases <;> simp }; { simp }\n\nlemma q_rewrite (f : \u03be\u2081 \u2192 Semiterm L \u03be\u2082 n) :\n    (rewrite f).q = rewrite (bShift \u2218 f) := by ext x; { cases x using Fin.cases <;> simp[rewriteMap] }; { simp }\n\n@[simp] lemma q_rewriteMap (e : \u03be\u2081 \u2192 \u03be\u2082) :\n    (rewriteMap (L := L) (n := n) e).q = rewriteMap e := by ext x; { cases x using Fin.cases <;> simp[rewriteMap] }; { simp }\n\n@[simp] lemma q_emb {o : Type v\u2081} [e : IsEmpty o] {n} :\n    (emb (L := L) (o := o) (\u03be := \u03be\u2082) (n := n)).q = emb := by ext x; { cases x using Fin.cases <;> simp }; { exact e.elim x }\n\n@[simp] lemma qpow_emb {o : Type v\u2081} [e : IsEmpty o] {n k} :\n    (emb (L := L) (o := o) (\u03be := \u03be\u2082) (n := n)).qpow k = emb := by induction k <;> simp[*]\n\n@[simp] lemma q_cast {n n'} (h : n = n') :\n    (cast h : Rew L \u03be n \u03be n').q = cast (congrFun (congrArg HAdd.hAdd h) 1) := by\n  ext x <;> simp; cases x using Fin.cases <;> simp\n\n@[simp] lemma q_castLE {n n'} (h : n \u2264 n') :\n    (castLE h : Rew L \u03be n \u03be n').q = castLE (Nat.add_le_add_right h 1) := by\n  ext x <;> simp; cases x using Fin.cases <;> simp\n\nlemma q_toS :\n    (toS : Rew L (Fin n) 0 Empty n).q = bind ![#0] (#\u00b7.succ) := by\n  ext x <;> simp; cases x using Fin.cases <;> try simp\n  \u00b7 exact Fin.elim0 (by assumption)\n\n@[simp] lemma qpow_castLE {n n'} (h : n \u2264 n') :\n    (castLE h : Rew L \u03be n \u03be n').qpow k = castLE (Nat.add_le_add_right h k) := by\n  induction k <;> simp[*]\n\nlemma q_substs (w : Fin n \u2192 Semiterm L \u03be n') :\n    (substs w).q = substs (#0 :> bShift \u2218 w) := by ext x; { cases x using Fin.cases <;> simp }; { simp }\n\nlemma q_embSubsts (w : Fin k \u2192 Semiterm L \u03be n) :\n    (embSubsts w).q = embSubsts (#0 :> bShift \u2218 w) := by ext x; { cases x using Fin.cases <;> simp }; { simp; exact Empty.elim x }\n\nend \u03c8\n\nsection Syntactic\n\n/-\n  #0 #1 ... #(n - 1) &0 &1 ...\n   \u2193shift\n  #0 #1 ... #(n - 1) &1 &2 &3 ...\n-/\n\ndef shift : SyntacticRew L n n := map id Nat.succ\n\n/-\n  #0 #1 ... #(n - 1) #n &0 &1 ...\n   \u2193free           \u2191fix\n  #0 #1 ... #(n - 1) &0 &1 &2 ...\n -/\n\ndef free : SyntacticRew L (n + 1) n := bind (bvar <: &0) (fun m => &(Nat.succ m))\n\ndef fix : SyntacticRew L n (n + 1) := bind (fun x => #(Fin.castSucc x)) (#(Fin.last n) :>\u2099 fvar)\n\nabbrev rewrite1 (t : SyntacticSemiterm L n) : SyntacticRew L n n := bind Semiterm.bvar (t :>\u2099 fvar)\n\nsection shift\n\n@[simp] lemma shift_bvar (x : Fin n) : shift (#x : SyntacticSemiterm L n) = #x := rfl\n\n@[simp] lemma shift_fvar (x : \u2115) : shift (&x : SyntacticSemiterm L n) = &(x + 1) := rfl\n\nlemma shift_func {k} (f : L.Func k) (v : Fin k \u2192 SyntacticSemiterm L n) :\n    shift (func f v) = func f (fun i => shift (v i)) := rfl\n\nlemma shift_Injective : Function.Injective (@shift L n) :=\n  Function.LeftInverse.injective (g := map id Nat.pred)\n    (by intros \u03c6; simp[\u2190comp_app]; apply eq_id_of_eq <;> simp[comp_app])\n\nend shift\n\nsection free\n\n@[simp] lemma free_bvar_castSucc (x : Fin n) : free (#(Fin.castSucc x) : SyntacticSemiterm L (n + 1)) = #x := by simp[free]\n\n@[simp] lemma free_bvar_castSucc_zero : free (#0 : SyntacticSemiterm L (n + 1 + 1)) = #0 := free_bvar_castSucc 0\n\n@[simp] lemma free_bvar_last : free (#(Fin.last n) : SyntacticSemiterm L (n + 1)) = &0 := by simp[free]\n\n@[simp] lemma free_bvar_last_zero : free (#0 : SyntacticSemiterm L 1) = &0 := free_bvar_last\n\n@[simp] lemma free_fvar (x : \u2115) : free (&x : SyntacticSemiterm L (n + 1)) = &(x + 1) := by simp[free]\n\nend free\n\nsection fix\n\n@[simp] lemma fix_bvar (x : Fin n) : fix (#x : SyntacticSemiterm L n) = #(Fin.castSucc x) := by simp[fix]\n\n@[simp] lemma fix_fvar_zero : fix (&0 : SyntacticSemiterm L n) = #(Fin.last n) := by simp[fix]\n\n@[simp] lemma fix_fvar_succ (x : \u2115) : fix (&(x + 1) : SyntacticSemiterm L n) = &x := by simp[fix]\n\nend fix\n\n@[simp] lemma free_comp_fix : (free (L := L) (n := n)).comp fix = Rew.id := by\n  ext x <;> simp[comp_app]; { cases x <;> simp }\n\n@[simp] lemma fix_comp_free : (fix (L := L) (n := n)).comp free = Rew.id := by\n  ext x <;> simp[comp_app]; { cases x using Fin.lastCases <;> simp }\n\n@[simp] lemma bShift_free_eq_shift : (free (L := L) (n := 0)).comp bShift = shift := by\n  ext x <;> simp[comp_app]; { exact Fin.elim0 x }\n\nlemma bShift_comp_substs (v : Fin n\u2081 \u2192 Semiterm L \u03be\u2082 n\u2082) :\n  bShift.comp (substs v) = substs (bShift \u2218 v) := by ext x <;> simp[comp_app]\n\nlemma shift_comp_substs (v : Fin n\u2081 \u2192 SyntacticSemiterm L n\u2082) :\n  shift.comp (substs v) = (substs (shift \u2218 v)).comp shift := by ext x <;> simp[comp_app]\n\nlemma shift_comp_substs1 (t : SyntacticSemiterm L n\u2082) :\n  shift.comp (substs ![t]) = (substs ![shift t]).comp shift := by ext x <;> simp[comp_app]\n\n@[simp] lemma rewrite_comp_emb {o : Type v\u2081} [e : IsEmpty o] (f : \u03be\u2082 \u2192 Semiterm L \u03be\u2083 n) :\n  (rewrite f).comp emb = (emb : Rew L o n \u03be\u2083 n) := by ext x <;> simp[comp_app]; { exact IsEmpty.elim e x }\n\n@[simp] lemma shift_comp_emb {o : Type v\u2081} [e : IsEmpty o] :\n  shift.comp emb = (emb : Rew L o n \u2115 n) := by ext x <;> simp[comp_app]; { exact IsEmpty.elim e x }\n\nlemma rewrite_comp_free_eq_substs (t : SyntacticTerm L) :\n    (rewrite (t :>\u2099 Semiterm.fvar)).comp free = substs ![t] := by ext x <;> simp[comp_app, Fin.eq_zero]\n\nlemma rewrite_comp_shift_eq_id (t : SyntacticTerm L) :\n    (rewrite (t :>\u2099 Semiterm.fvar)).comp shift = Rew.id := by ext x <;> simp[comp_app]\n\n@[simp] lemma substs_mbar_zero_comp_shift_eq_free :\n    (substs (L := L) ![&0]).comp shift = free := by ext x <;> simp[comp_app, Fin.eq_zero]\n\n@[simp] lemma substs_comp_bShift_eq_id (v : Fin 1 \u2192 Semiterm L \u03be 0) :\n    (substs (L := L) v).comp bShift = Rew.id := by ext x <;> simp[comp_app]; exact Fin.elim0 x\n\nlemma free_comp_substs_eq_substs_comp_shift {n'} (w : Fin n' \u2192 SyntacticSemiterm Lf (n + 1)) :\n    free.comp (substs w) = (substs (free \u2218 w)).comp shift :=\n  by ext x <;> simp[comp_app]\n\n@[simp] lemma rewriteMap_comp_rewriteMap (f : \u03be\u2081 \u2192 \u03be\u2082) (g : \u03be\u2082 \u2192 \u03be\u2083) :\n  (rewriteMap (L := L) (n := n) g).comp (rewriteMap f) = rewriteMap (g \u2218 f) := by ext x <;> simp [comp_app]\n\n@[simp] lemma fix_free_app (t : SyntacticSemiterm L (n + 1)) : fix (free t) = t := by simp[\u2190comp_app]\n\n@[simp] lemma free_fix_app (t : SyntacticSemiterm L n) : free (fix t) = t := by simp[\u2190comp_app]\n\n@[simp] lemma free_bShift_app (t : SyntacticSemiterm L 0) : free (bShift t) = shift t := by simp[\u2190comp_app]\n\n@[simp] lemma substs_bShift_app (v : Fin 1 \u2192 Semiterm L \u03be 0) : substs v (bShift t) = t := by simp[\u2190comp_app]\n\nlemma rewrite_comp_fix_eq_substs (t) :\n    ((rewrite (t :>\u2099 (&\u00b7))).comp free : SyntacticRew L 1 0) = substs ![t] := by\n  ext x <;> simp[comp_app, Fin.eq_zero]\n\n", "theoremStatement": "lemma bShift_eq_rewrite :\n    (Rew.bShift : SyntacticRew L 0 1) = Rew.substs ![] ", "theoremName": "LO.FirstOrder.Rew.bShift_eq_rewrite", "fileCreated": {"commit": "f9b24e7d45330d9c809d246bb25b3aeccf722ef3", "date": "2024-11-06"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/Logic/Predicate/Rew.lean", "module": "Foundation.Logic.Predicate.Rew", "jsonFile": "Foundation.Logic.Predicate.Rew.jsonl", "positionMetadata": {"lineInFile": 555, "tokenPositionInFile": 20975, "theoremPositionInFile": 132}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 6, "repositoryPremises": true, "numRepositoryPremises": 10, "numPremises": 26}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  ext x\n  \u00b7 exact x.elim0\n  \u00b7 simp", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 40}}
{"srcContext": "import Foundation.IntFO.Basic.Rew\n\nnamespace LO.FirstOrder\n\nabbrev Sequent\u1d62 (L : Language) := List (SyntacticFormula\u1d62 L)\n\nopen Semiformula\u1d62\n\nvariable {L : Language} {T : Theory L}\n\nstructure Hilbert\u1d62 (L : Language) where\n  axiomSet : Set (SyntacticFormula\u1d62 L)\n  rewrite_closed {\u03c6 : SyntacticFormula\u1d62 L} : \u03c6 \u2208 axiomSet \u2192 \u2200 f : \u2115 \u2192 SyntacticTerm L, Rew.rewrite f \u25b9 \u03c6 \u2208 axiomSet\n\ninstance : SetLike (Hilbert\u1d62 L) (SyntacticFormula\u1d62 L) where\n  coe := Hilbert\u1d62.axiomSet\n  coe_injective' := by rintro \u27e8T, _\u27e9 \u27e8U, _\u27e9; simp\n\nnamespace Hilbert\u1d62\n\ndef Minimal : Hilbert\u1d62 L := \u27e8\u2205, by simp\u27e9\n\nnotation \"\ud835\udc0c\ud835\udc22\ud835\udc27\u00b9\" => Minimal\n\ndef Intuitionistic : Hilbert\u1d62 L := \u27e8{\u22a5 \u279d \u03c6 | \u03c6}, by rintro _ \u27e8\u03c6, rfl\u27e9 f; exact \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\u27e9\n\nnotation \"\ud835\udc08\ud835\udc27\ud835\udc2d\u00b9\" => Intuitionistic\n\ndef Classical : Hilbert\u1d62 L := \u27e8{\u22a5 \u279d \u03c6 | \u03c6} \u222a {\u03c6 \u22ce \u223c\u03c6 | \u03c6}, by\n  rintro _ (\u27e8\u03c6, rfl\u27e9 | \u27e8\u03c6, rfl\u27e9) f\n  \u00b7 exact Or.inl \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\n  \u00b7 exact Or.inr \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\u27e9\n\nnotation \"\ud835\udc02\ud835\udc25\u00b9\" => Classical\n\nlemma minimal_le (\u039b : Hilbert\u1d62 L) : (Minimal : Hilbert\u1d62 L) \u2264 \u039b := by rintro _ \u27e8\u27e9\n\nlemma intuitionistic_le_classical : (Intuitionistic : Hilbert\u1d62 L) \u2264 Classical := by rintro _ \u27e8\u03c6, rfl\u27e9; exact .inl \u27e8\u03c6, rfl\u27e9\n\nend Hilbert\u1d62\n\ninductive HilbertProof\u1d62 (\u039b : Hilbert\u1d62 L) : SyntacticFormula\u1d62 L \u2192 Type _\n  | eaxm {\u03c6}     : \u03c6 \u2208 \u039b \u2192 HilbertProof\u1d62 \u039b \u03c6\n  | mdp {\u03c6 \u03c8}    : HilbertProof\u1d62 \u039b (\u03c6 \u279d \u03c8) \u2192 HilbertProof\u1d62 \u039b \u03c6 \u2192 HilbertProof\u1d62 \u039b \u03c8\n  | gen {\u03c6}      : HilbertProof\u1d62 \u039b (Rewriting.free \u03c6) \u2192 HilbertProof\u1d62 \u039b (\u2200' \u03c6)\n  | verum        : HilbertProof\u1d62 \u039b \u22a4\n  | imply\u2081 \u03c6 \u03c8   : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c8 \u279d \u03c6\n  | imply\u2082 \u03c6 \u03c8 \u03c7 : HilbertProof\u1d62 \u039b <| (\u03c6 \u279d \u03c8 \u279d \u03c7) \u279d (\u03c6 \u279d \u03c8) \u279d \u03c6 \u279d \u03c7\n  | and\u2081 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u22cf \u03c8 \u279d \u03c6\n  | and\u2082 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u22cf \u03c8 \u279d \u03c8\n  | and\u2083 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c8 \u279d \u03c6 \u22cf \u03c8\n  | or\u2081 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c6 \u22ce \u03c8\n  | or\u2082 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u03c8 \u279d \u03c6 \u22ce \u03c8\n  | or\u2083 \u03c6 \u03c8 \u03c7    : HilbertProof\u1d62 \u039b <| (\u03c6 \u279d \u03c7) \u279d (\u03c8 \u279d \u03c7) \u279d (\u03c6 \u22ce \u03c8 \u279d \u03c7)\n  | all\u2081 \u03c6 t     : HilbertProof\u1d62 \u039b <| \u2200' \u03c6 \u279d \u03c6/[t]\n  | all\u2082 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u2200' (\u03c6/[] \u279d \u03c8) \u279d \u03c6 \u279d \u2200' \u03c8\n  | ex\u2081 t \u03c6      : HilbertProof\u1d62 \u039b <| \u03c6/[t] \u279d \u2203' \u03c6\n  | ex\u2082 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u2200' (\u03c6 \u279d \u03c8/[]) \u279d \u2203' \u03c6 \u279d \u03c8\n\ninstance : System (SyntacticFormula\u1d62 L) (Hilbert\u1d62 L) := \u27e8HilbertProof\u1d62\u27e9\n\nnamespace HilbertProof\u1d62\n\nopen System.FiniteContext Rewriting LawfulSyntacticRewriting\n\nvariable (\u039b : Hilbert\u1d62 L)\n\ninstance : System.ModusPonens \u039b := \u27e8mdp\u27e9\n\ninstance : System.HasAxiomAndInst \u039b := \u27e8and\u2083\u27e9\n\ninstance : System.HasAxiomImply\u2081 \u039b := \u27e8imply\u2081\u27e9\n\ninstance : System.HasAxiomImply\u2082 \u039b := \u27e8imply\u2082\u27e9\n\ninstance : System.Minimal \u039b where\n  mdp := mdp\n  verum := verum\n  imply\u2081 := imply\u2081\n  imply\u2082 := imply\u2082\n  and\u2081 := and\u2081\n  and\u2082 := and\u2082\n  and\u2083 := and\u2083\n  or\u2081 := or\u2081\n  or\u2082 := or\u2082\n  or\u2083 := or\u2083\n  neg_equiv _ := System.iffId _\n\nvariable {\u039b}\n\nprotected def cast {\u03c6 \u03c8} (b : \u039b \u22a2 \u03c6) (e : \u03c6 = \u03c8) : \u039b \u22a2 \u03c8 := e \u25b8 b\n\ndef depth {\u03c6} : \u039b \u22a2 \u03c6 \u2192 \u2115\n  | mdp b d => max (depth b) (depth d) + 1\n  | gen b   => depth b + 1\n  | _       => 0\n\nscoped notation \"\u2016\" d \"\u2016\" => depth d\n\n@[simp] lemma depth_eaxm (h : \u03c6 \u2208 \u039b) : \u2016eaxm h\u2016 = 0 := rfl\n@[simp] lemma depth_mdp (b : \u039b \u22a2 \u03c6 \u279d \u03c8) (d : \u039b \u22a2 \u03c6) : \u2016mdp b d\u2016 = max \u2016b\u2016 \u2016d\u2016 + 1 := rfl\n@[simp] lemma depth_gen (b : \u039b \u22a2 Rewriting.free \u03c6) : \u2016gen b\u2016 = \u2016b\u2016 + 1 := rfl\n@[simp] lemma depth_verum : \u2016(verum : \u039b \u22a2 \u22a4)\u2016 = 0 := rfl\n", "theoremStatement": "@[simp] lemma depth_imply\u2081 (\u03c6 \u03c8) : \u2016imply\u2081 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 ", "theoremName": "LO.FirstOrder.HilbertProof\u1d62.depth_imply\u2081", "fileCreated": {"commit": "7d9e3859942c3a17a697b129e7fb3869eca0066e", "date": "2024-11-09"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/IntFO/Basic/Deduction.lean", "module": "Foundation.IntFO.Basic.Deduction", "jsonFile": "Foundation.IntFO.Basic.Deduction.jsonl", "positionMetadata": {"lineInFile": 104, "tokenPositionInFile": 3272, "theoremPositionInFile": 15}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 7, "numPremises": 12}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "import Foundation.Modal.Formula\n\nnamespace LO.Modal\n\nvariable {\u03b1 : Type u}\n\ninductive NNFormula (\u03b1 : Type u) : Type u where\n  | atom   : \u03b1 \u2192 NNFormula \u03b1\n  | natom  : \u03b1 \u2192 NNFormula \u03b1\n  | falsum : NNFormula \u03b1\n  | verum  : NNFormula \u03b1\n  | or     : NNFormula \u03b1 \u2192 NNFormula \u03b1 \u2192 NNFormula \u03b1\n  | and    : NNFormula \u03b1 \u2192 NNFormula \u03b1 \u2192 NNFormula \u03b1\n  | box    : NNFormula \u03b1 \u2192 NNFormula \u03b1\n  | dia    : NNFormula \u03b1 \u2192 NNFormula \u03b1\n  deriving DecidableEq\n\nnamespace NNFormula\n\nvariable {\u03c6 \u03c8 \u03c7 : NNFormula \u03b1}\n\ndef neg : NNFormula \u03b1 \u2192 NNFormula \u03b1\n  | atom a  => natom a\n  | natom a => atom a\n  | falsum  => verum\n  | verum   => falsum\n  | or \u03c6 \u03c8  => and (neg \u03c6) (neg \u03c8)\n  | and \u03c6 \u03c8 => or (neg \u03c6) (neg \u03c8)\n  | box \u03c6   => dia (neg \u03c6)\n  | dia \u03c6   => box (neg \u03c6)\n\ndef imp (\u03c6 \u03c8 : NNFormula \u03b1) : NNFormula \u03b1 := or (neg \u03c6) \u03c8\n\ninstance : BasicModalLogicalConnective (NNFormula \u03b1) where\n  tilde := neg\n  arrow := imp\n  wedge := and\n  vee := or\n  top := verum\n  bot := falsum\n  box := box\n  dia := dia\n\nlemma or_eq : or \u03c6 \u03c8 = \u03c6 \u22ce \u03c8 := rfl\n\nlemma and_eq : and \u03c6 \u03c8 = \u03c6 \u22cf \u03c8 := rfl\n\nlemma imp_eq : imp \u03c6 \u03c8 = \u03c6 \u279d \u03c8 := rfl\n\nlemma box_eq : box \u03c6 = \u25a1\u03c6 := rfl\n\nlemma dia_eq : dia \u03c6 = \u25c7\u03c6 := rfl\n\n@[simp] lemma imp_eq' : \u03c6 \u279d \u03c8 = \u223c\u03c6 \u22ce \u03c8 := rfl\n\n@[simp] lemma iff_eq : \u03c6 \u2b64 \u03c8 = (\u03c6 \u279d \u03c8) \u22cf (\u03c8 \u279d \u03c6) := rfl\n\nlemma falsum_eq : (falsum : NNFormula \u03b1) = \u22a5 := rfl\n\nlemma verum_eq : (verum : NNFormula \u03b1) = \u22a4 := rfl\n\n@[simp] lemma and_inj (\u03c6\u2081 \u03c8\u2081 \u03c6\u2082 \u03c8\u2082 : Formula \u03b1) : \u03c6\u2081 \u22cf \u03c6\u2082 = \u03c8\u2081 \u22cf \u03c8\u2082 \u2194 \u03c6\u2081 = \u03c8\u2081 \u2227 \u03c6\u2082 = \u03c8\u2082 := by simp[Wedge.wedge]\n\n@[simp] lemma or_inj (\u03c6\u2081 \u03c8\u2081 \u03c6\u2082 \u03c8\u2082 : Formula \u03b1) : \u03c6\u2081 \u22ce \u03c6\u2082 = \u03c8\u2081 \u22ce \u03c8\u2082 \u2194 \u03c6\u2081 = \u03c8\u2081 \u2227 \u03c6\u2082 = \u03c8\u2082 := by simp[Vee.vee]\n\n@[simp] lemma imp_inj (\u03c6\u2081 \u03c8\u2081 \u03c6\u2082 \u03c8\u2082 : Formula \u03b1) : \u03c6\u2081 \u279d \u03c6\u2082 = \u03c8\u2081 \u279d \u03c8\u2082 \u2194 \u03c6\u2081 = \u03c8\u2081 \u2227 \u03c6\u2082 = \u03c8\u2082 := by simp[Arrow.arrow]\n\n@[simp] lemma neg_inj (\u03c6 \u03c8 : Formula \u03b1) : \u223c\u03c6 = \u223c\u03c8 \u2194 \u03c6 = \u03c8 := by simp [NegAbbrev.neg];\n\nlemma neg_eq : neg \u03c6 = \u223c\u03c6 := rfl\n\n@[simp] lemma neg_atom (a : \u03b1) : \u223catom a = natom a := by rfl\n\n@[simp] lemma neg_natom (a : \u03b1) : \u223cnatom a = atom a := by rfl\n\nlemma negneg : \u223c\u223c\u03c6 = \u03c6 := by\n  induction \u03c6 with\n  | and \u03c6 \u03c8 ih\u03c6 ih\u03c8 =>\n    simp only [\u2190neg_eq, neg, and.injEq];\n    exact \u27e8ih\u03c6, ih\u03c8\u27e9;\n  | or \u03c6 \u03c8 ih\u03c6 ih\u03c8 =>\n    simp only [\u2190neg_eq, neg, or.injEq];\n    exact \u27e8ih\u03c6, ih\u03c8\u27e9;\n  | box \u03c6 ih\u03c6 =>\n    simp only [\u2190neg_eq, neg, box.injEq];\n    exact ih\u03c6;\n  | dia \u03c6 ih\u03c6 =>\n    simp only [\u2190neg_eq, neg, dia.injEq];\n    exact ih\u03c6;\n  | _ => tauto;\n\ninstance : ModalDeMorgan (NNFormula \u03b1) where\n  verum := by tauto;\n  falsum := by tauto;\n  and := by tauto;\n  or := by tauto;\n  box := by tauto;\n  dia := by tauto;\n  neg := \u03bb _ => negneg\n  imply := by tauto;\n\nsection toString\n\nvariable [ToString \u03b1]\ndef toStr : NNFormula \u03b1 \u2192 String\n  | atom a  => s!\"+{a}\"\n  | natom a => s!\"-{a}\"\n  | falsum  => \"\u22a5\"\n  | verum   => \"\u22a4\"\n  | or \u03c6 \u03c8  => s!\"({\u03c6.toStr} \u2228 {\u03c8.toStr})\"\n  | and \u03c6 \u03c8 => s!\"({\u03c6.toStr} \u2227 {\u03c8.toStr})\"\n  | box \u03c6   => s!\"\u25a1{\u03c6.toStr}\"\n  | dia \u03c6   => s!\"\u25c7{\u03c6.toStr}\"\ninstance : Repr (NNFormula \u03b1) := \u27e8fun t _ => toStr t\u27e9\n\nend toString\n\n\nsection toFormula\n\ndef toFormula : NNFormula \u03b1 \u2192 Formula \u03b1\n  | atom a  => Formula.atom a\n  | natom a => \u223cFormula.atom a\n  | \u22a5       => \u22a5\n  | \u22a4       => \u22a4\n  | \u03c6 \u22ce \u03c8   => \u03c6.toFormula \u22ce \u03c8.toFormula\n  | \u03c6 \u22cf \u03c8   => \u03c6.toFormula \u22cf \u03c8.toFormula\n  | \u25a1\u03c6      => \u25a1(\u03c6.toFormula)\n  | \u25c7\u03c6      => \u25c7(\u03c6.toFormula)\ninstance : Coe (NNFormula \u03b1) (Formula \u03b1) := \u27e8toFormula\u27e9\n\n", "theoremStatement": "@[simp] lemma toFormula_atom (a : \u03b1) : toFormula  (.atom a) = Formula.atom a ", "theoremName": "LO.Modal.NNFormula.toFormula_atom", "fileCreated": {"commit": "1f10809ea0f0e98679f13cd2f7f5b706b01878a8", "date": "2024-11-20"}, "theoremCreated": {"commit": "54324e6e009f0d0a288897312d3feb1c0165ad19", "date": "2025-01-24"}, "file": "foundation/Foundation/Modal/NNFormula.lean", "module": "Foundation.Modal.NNFormula", "jsonFile": "Foundation.Modal.NNFormula.jsonl", "positionMetadata": {"lineInFile": 132, "tokenPositionInFile": 3262, "theoremPositionInFile": 18}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 4, "numPremises": 6}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "import Foundation.IntFO.Basic.Rew\n\nnamespace LO.FirstOrder\n\nabbrev Sequent\u1d62 (L : Language) := List (SyntacticFormula\u1d62 L)\n\nopen Semiformula\u1d62\n\nvariable {L : Language} {T : Theory L}\n\nstructure Hilbert\u1d62 (L : Language) where\n  axiomSet : Set (SyntacticFormula\u1d62 L)\n  rewrite_closed {\u03c6 : SyntacticFormula\u1d62 L} : \u03c6 \u2208 axiomSet \u2192 \u2200 f : \u2115 \u2192 SyntacticTerm L, Rew.rewrite f \u25b9 \u03c6 \u2208 axiomSet\n\ninstance : SetLike (Hilbert\u1d62 L) (SyntacticFormula\u1d62 L) where\n  coe := Hilbert\u1d62.axiomSet\n  coe_injective' := by rintro \u27e8T, _\u27e9 \u27e8U, _\u27e9; simp\n\nnamespace Hilbert\u1d62\n\ndef Minimal : Hilbert\u1d62 L := \u27e8\u2205, by simp\u27e9\n\nnotation \"\ud835\udc0c\ud835\udc22\ud835\udc27\u00b9\" => Minimal\n\ndef Intuitionistic : Hilbert\u1d62 L := \u27e8{\u22a5 \u279d \u03c6 | \u03c6}, by rintro _ \u27e8\u03c6, rfl\u27e9 f; exact \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\u27e9\n\nnotation \"\ud835\udc08\ud835\udc27\ud835\udc2d\u00b9\" => Intuitionistic\n\ndef Classical : Hilbert\u1d62 L := \u27e8{\u22a5 \u279d \u03c6 | \u03c6} \u222a {\u03c6 \u22ce \u223c\u03c6 | \u03c6}, by\n  rintro _ (\u27e8\u03c6, rfl\u27e9 | \u27e8\u03c6, rfl\u27e9) f\n  \u00b7 exact Or.inl \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\n  \u00b7 exact Or.inr \u27e8Rew.rewrite f \u25b9 \u03c6, by simp\u27e9\u27e9\n\nnotation \"\ud835\udc02\ud835\udc25\u00b9\" => Classical\n\nlemma minimal_le (\u039b : Hilbert\u1d62 L) : (Minimal : Hilbert\u1d62 L) \u2264 \u039b := by rintro _ \u27e8\u27e9\n\nlemma intuitionistic_le_classical : (Intuitionistic : Hilbert\u1d62 L) \u2264 Classical := by rintro _ \u27e8\u03c6, rfl\u27e9; exact .inl \u27e8\u03c6, rfl\u27e9\n\nend Hilbert\u1d62\n\ninductive HilbertProof\u1d62 (\u039b : Hilbert\u1d62 L) : SyntacticFormula\u1d62 L \u2192 Type _\n  | eaxm {\u03c6}     : \u03c6 \u2208 \u039b \u2192 HilbertProof\u1d62 \u039b \u03c6\n  | mdp {\u03c6 \u03c8}    : HilbertProof\u1d62 \u039b (\u03c6 \u279d \u03c8) \u2192 HilbertProof\u1d62 \u039b \u03c6 \u2192 HilbertProof\u1d62 \u039b \u03c8\n  | gen {\u03c6}      : HilbertProof\u1d62 \u039b (Rewriting.free \u03c6) \u2192 HilbertProof\u1d62 \u039b (\u2200' \u03c6)\n  | verum        : HilbertProof\u1d62 \u039b \u22a4\n  | imply\u2081 \u03c6 \u03c8   : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c8 \u279d \u03c6\n  | imply\u2082 \u03c6 \u03c8 \u03c7 : HilbertProof\u1d62 \u039b <| (\u03c6 \u279d \u03c8 \u279d \u03c7) \u279d (\u03c6 \u279d \u03c8) \u279d \u03c6 \u279d \u03c7\n  | and\u2081 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u22cf \u03c8 \u279d \u03c6\n  | and\u2082 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u22cf \u03c8 \u279d \u03c8\n  | and\u2083 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c8 \u279d \u03c6 \u22cf \u03c8\n  | or\u2081 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u03c6 \u279d \u03c6 \u22ce \u03c8\n  | or\u2082 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u03c8 \u279d \u03c6 \u22ce \u03c8\n  | or\u2083 \u03c6 \u03c8 \u03c7    : HilbertProof\u1d62 \u039b <| (\u03c6 \u279d \u03c7) \u279d (\u03c8 \u279d \u03c7) \u279d (\u03c6 \u22ce \u03c8 \u279d \u03c7)\n  | all\u2081 \u03c6 t     : HilbertProof\u1d62 \u039b <| \u2200' \u03c6 \u279d \u03c6/[t]\n  | all\u2082 \u03c6 \u03c8     : HilbertProof\u1d62 \u039b <| \u2200' (\u03c6/[] \u279d \u03c8) \u279d \u03c6 \u279d \u2200' \u03c8\n  | ex\u2081 t \u03c6      : HilbertProof\u1d62 \u039b <| \u03c6/[t] \u279d \u2203' \u03c6\n  | ex\u2082 \u03c6 \u03c8      : HilbertProof\u1d62 \u039b <| \u2200' (\u03c6 \u279d \u03c8/[]) \u279d \u2203' \u03c6 \u279d \u03c8\n\ninstance : System (SyntacticFormula\u1d62 L) (Hilbert\u1d62 L) := \u27e8HilbertProof\u1d62\u27e9\n\nnamespace HilbertProof\u1d62\n\nopen System.FiniteContext Rewriting LawfulSyntacticRewriting\n\nvariable (\u039b : Hilbert\u1d62 L)\n\ninstance : System.ModusPonens \u039b := \u27e8mdp\u27e9\n\ninstance : System.HasAxiomAndInst \u039b := \u27e8and\u2083\u27e9\n\ninstance : System.HasAxiomImply\u2081 \u039b := \u27e8imply\u2081\u27e9\n\ninstance : System.HasAxiomImply\u2082 \u039b := \u27e8imply\u2082\u27e9\n\ninstance : System.Minimal \u039b where\n  mdp := mdp\n  verum := verum\n  imply\u2081 := imply\u2081\n  imply\u2082 := imply\u2082\n  and\u2081 := and\u2081\n  and\u2082 := and\u2082\n  and\u2083 := and\u2083\n  or\u2081 := or\u2081\n  or\u2082 := or\u2082\n  or\u2083 := or\u2083\n  neg_equiv _ := System.iffId _\n\nvariable {\u039b}\n\nprotected def cast {\u03c6 \u03c8} (b : \u039b \u22a2 \u03c6) (e : \u03c6 = \u03c8) : \u039b \u22a2 \u03c8 := e \u25b8 b\n\ndef depth {\u03c6} : \u039b \u22a2 \u03c6 \u2192 \u2115\n  | mdp b d => max (depth b) (depth d) + 1\n  | gen b   => depth b + 1\n  | _       => 0\n\nscoped notation \"\u2016\" d \"\u2016\" => depth d\n\n@[simp] lemma depth_eaxm (h : \u03c6 \u2208 \u039b) : \u2016eaxm h\u2016 = 0 := rfl\n@[simp] lemma depth_mdp (b : \u039b \u22a2 \u03c6 \u279d \u03c8) (d : \u039b \u22a2 \u03c6) : \u2016mdp b d\u2016 = max \u2016b\u2016 \u2016d\u2016 + 1 := rfl\n@[simp] lemma depth_gen (b : \u039b \u22a2 Rewriting.free \u03c6) : \u2016gen b\u2016 = \u2016b\u2016 + 1 := rfl\n@[simp] lemma depth_verum : \u2016(verum : \u039b \u22a2 \u22a4)\u2016 = 0 := rfl\n@[simp] lemma depth_imply\u2081 (\u03c6 \u03c8) : \u2016imply\u2081 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 := rfl\n@[simp] lemma depth_imply\u2082 (\u03c6 \u03c8 \u03c7) : \u2016imply\u2082 (\u039b := \u039b) \u03c6 \u03c8 \u03c7\u2016 = 0 := rfl\n", "theoremStatement": "@[simp] lemma depth_and\u2081 (\u03c6 \u03c8) : \u2016and\u2081 (\u039b := \u039b) \u03c6 \u03c8\u2016 = 0 ", "theoremName": "LO.FirstOrder.HilbertProof\u1d62.depth_and\u2081", "fileCreated": {"commit": "7d9e3859942c3a17a697b129e7fb3869eca0066e", "date": "2024-11-09"}, "theoremCreated": {"commit": "12f31f32a1a909c5a21b1c97ac9ddbfc354abb67", "date": "2024-12-09"}, "file": "foundation/Foundation/IntFO/Basic/Deduction.lean", "module": "Foundation.IntFO.Basic.Deduction", "jsonFile": "Foundation.IntFO.Basic.Deduction.jsonl", "positionMetadata": {"lineInFile": 106, "tokenPositionInFile": 3412, "theoremPositionInFile": 17}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 10, "numPremises": 15}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "import Mathlib.Data.Vector.Basic\nimport Mathlib.Data.Fin.Basic\nimport Mathlib.Data.Fin.VecNotation\nimport Mathlib.Data.Fintype.Basic\nimport Mathlib.Data.Finset.Basic\nimport Mathlib.Data.Finset.Preimage\nimport Mathlib.Data.Finset.Sort\nimport Mathlib.Order.Filter.Ultrafilter.Defs\nimport Mathlib.Logic.Encodable.Basic\nimport Mathlib.Computability.Primrec\nimport Mathlib.Computability.Partrec\nimport Mathlib.Data.Finset.Sort\nimport Mathlib.Data.List.GetD\nimport Mathlib.Data.Set.Finite.Range\n\nnamespace Nat\nvariable {\u03b1 : \u2115 \u2192 Sort u}\n\ndef cases (hzero : \u03b1 0) (hsucc : \u2200 n, \u03b1 (n + 1)) : \u2200 n, \u03b1 n\n  | 0     => hzero\n  | n + 1 => hsucc n\n\ninfixr:70 \" :>\u2099 \" => cases\n\n@[simp] lemma cases_zero (hzero : \u03b1 0) (hsucc : \u2200 n, \u03b1 (n + 1)) :\n    (hzero :>\u2099 hsucc) 0 = hzero := rfl\n\n@[simp] lemma cases_succ (hzero : \u03b1 0) (hsucc : \u2200 n, \u03b1 (n + 1)) (n : \u2115) :\n    (hzero :>\u2099 hsucc) (n + 1) = hsucc n := rfl\n\n@[simp] lemma ne_step_max (n m : \u2115) : n \u2260 max n m + 1 :=\n  ne_of_lt $ Nat.lt_succ_of_le $ by simp\n\n@[simp] lemma ne_step_max' (n m : \u2115) : n \u2260 max m n + 1 :=\n  ne_of_lt $ Nat.lt_succ_of_le $ by simp\n\nlemma rec_eq {\u03b1 : Sort*} (a : \u03b1) (f\u2081 f\u2082 : \u2115 \u2192 \u03b1 \u2192 \u03b1) (n : \u2115) (H : \u2200 m < n, \u2200 a, f\u2081 m a = f\u2082 m a) :\n    (n.rec a f\u2081 : \u03b1) = n.rec a f\u2082 := by\n  induction' n with n ih <;> simp\n  \u00b7 have : (n.rec a f\u2081 : \u03b1) = n.rec a f\u2082 := ih (fun m hm a =>  H m (Nat.lt.step hm) a)\n    simpa [this] using H n (Nat.lt.base n) (n.rec a f\u2082)\n\nlemma least_number (P : \u2115 \u2192 Prop) (hP : \u2203 x, P x) : \u2203 x, P x \u2227 \u2200 z < x, \u00acP z := by\n  rcases hP with \u27e8n, hn\u27e9\n  induction' n using Nat.strongRec with n ih\n  by_cases H : \u2203 m < n, P m\n  \u00b7 rcases H with \u27e8m, hm, hPm\u27e9\n    exact ih m hm hPm\n  \u00b7 exact \u27e8n, hn, by simpa using H\u27e9\n\ndef toFin (n : \u2115) : \u2115 \u2192 Option (Fin n) := fun x => if hx : x < n then some \u27e8x, hx\u27e9 else none\n\nend Nat\n\nlemma eq_finZeroElim {\u03b1 : Sort u} (x : Fin 0 \u2192 \u03b1) : x = finZeroElim := funext (by rintro \u27e8_, _\u27e9; contradiction)\n\nnamespace Matrix\nopen Fin\nsection\nvariable {n : \u2115} {\u03b1 : Type u}\n\ninfixr:70 \" :> \" => vecCons\n\n@[simp] lemma vecCons_zero :\n    (a :> s) 0 = a := by simp\n\n@[simp] lemma vecCons_succ (i : Fin n) :\n    (a :> s) (Fin.succ i) = s i := by simp\n\n@[simp] lemma vecCons_last (a : C) (s : Fin (n + 1) \u2192 C) :\n    (a :> s) (Fin.last (n + 1)) = s (Fin.last n) := vecCons_succ (Fin.last n)\n\ndef vecConsLast {n : \u2115} (t : Fin n \u2192 \u03b1) (h : \u03b1) : Fin n.succ \u2192 \u03b1 :=\n  Fin.lastCases h t\n\n@[simp] lemma cons_app_one {n : \u2115} (a : \u03b1) (s : Fin n.succ \u2192 \u03b1) : (a :> s) 1 = s 0 := rfl\n\n@[simp] lemma cons_app_two {n : \u2115} (a : \u03b1) (s : Fin n.succ.succ \u2192 \u03b1) : (a :> s) 2 = s 1 := rfl\n\n@[simp] lemma cons_app_three {n : \u2115} (a : \u03b1) (s : Fin n.succ.succ.succ \u2192 \u03b1) : (a :> s) 3 = s 2 := rfl\n\nsection delab\nopen Lean PrettyPrinter Delaborator SubExpr\n\n@[app_unexpander Matrix.vecEmpty]\ndef unexpandVecEmpty : Unexpander\n  | `($(_)) => `(![])\n\n@[app_unexpander Matrix.vecCons]\ndef unexpandVecCons : Unexpander\n  | `($(_) $a ![])      => `(![$a])\n  | `($(_) $a ![$as,*]) => `(![$a, $as,*])\n  | _                   => throw ()\n\n#check ![1, 2]\n\nend delab\n\ninfixl:70 \" <: \" => vecConsLast\n\n@[simp] lemma rightConcat_last :\n    (s <: a) (last n) = a := by simp [vecConsLast]\n\n@[simp] lemma rightConcat_castSucc (i : Fin n) :\n    (s <: a) (Fin.castSucc i) = s i := by simp [vecConsLast]\n\n@[simp] lemma rightConcat_zero (a : \u03b1) (s : Fin n.succ \u2192 \u03b1) :\n    (s <: a) 0 = s 0 := rightConcat_castSucc 0\n\n@[simp] lemma zero_succ_eq_id {n} : (0 : Fin (n + 1)) :> succ = id :=\n  funext $ Fin.cases (by simp) (by simp)\n\n@[simp] lemma zero_cons_succ_eq_self (f : Fin (n + 1) \u2192 \u03b1) : (f 0 :> (f \u00b7.succ) : Fin (n + 1) \u2192 \u03b1) = f := by\n    funext x; cases x using Fin.cases <;> simp\n\nlemma eq_vecCons (s : Fin (n + 1) \u2192 C) : s = s 0 :> s \u2218 Fin.succ :=\n   funext $ Fin.cases (by simp) (by simp)\n\n@[simp] lemma vecCons_ext (a\u2081 a\u2082 : \u03b1) (s\u2081 s\u2082 : Fin n \u2192 \u03b1) :\n    a\u2081 :> s\u2081 = a\u2082 :> s\u2082 \u2194 a\u2081 = a\u2082 \u2227 s\u2081 = s\u2082 :=\n  \u27e8by intros h\n      constructor\n      \u00b7 exact congrFun h 0\n      \u00b7 exact funext (fun i => by simpa using congrFun h (Fin.castSucc i + 1)),\n   by intros h; simp [h]\u27e9\n\nlemma vecCons_assoc (a b : \u03b1) (s : Fin n \u2192 \u03b1) :\n    a :> (s <: b) = (a :> s) <: b := by\n  funext x; cases' x using Fin.cases with x <;> simp; cases x using Fin.lastCases <;> simp [Fin.succ_castSucc]\n\ndef decVec {\u03b1 : Type _} : {n : \u2115} \u2192 (v w : Fin n \u2192 \u03b1) \u2192 (\u2200 i, Decidable (v i = w i)) \u2192 Decidable (v = w)\n  | 0,     _, _, _ => by simpa [Matrix.empty_eq] using isTrue trivial\n  | n + 1, v, w, d => by\n      rw [eq_vecCons v, eq_vecCons w, vecCons_ext]\n      haveI : Decidable (v \u2218 Fin.succ = w \u2218 Fin.succ) := decVec _ _ (by intros i; simpa using d _)\n      refine instDecidableAnd\n\nlemma comp_vecCons (f : \u03b1 \u2192 \u03b2) (a : \u03b1) (s : Fin n \u2192 \u03b1) : (fun x => f $ (a :> s) x) = f a :> f \u2218 s :=\nfunext (fun i => cases (by simp) (by simp) i)\n\nlemma comp_vecCons' (f : \u03b1 \u2192 \u03b2) (a : \u03b1) (s : Fin n \u2192 \u03b1) : (fun x => f $ (a :> s) x) = f a :> fun i => f (s i) :=\n  comp_vecCons f a s\n\nlemma comp_vecCons'' (f : \u03b1 \u2192 \u03b2) (a : \u03b1) (s : Fin n \u2192 \u03b1) : f \u2218 (a :> s) = f a :> f \u2218 s :=\n  comp_vecCons f a s\n\n@[simp] lemma comp\u2080 : f \u2218 (![] : Fin 0 \u2192 \u03b1) = ![] := by simp [Matrix.empty_eq]\n\n@[simp] lemma comp\u2081 (a : \u03b1) : f \u2218 ![a] = ![f a] := by simp [comp_vecCons'']\n\n@[simp] lemma comp\u2082 (a\u2081 a\u2082 : \u03b1) : f \u2218 ![a\u2081, a\u2082] = ![f a\u2081, f a\u2082] := by simp [comp_vecCons'']\n\n@[simp] lemma comp\u2083 (a\u2081 a\u2082 a\u2083 : \u03b1) : f \u2218 ![a\u2081, a\u2082, a\u2083] = ![f a\u2081, f a\u2082, f a\u2083] := by simp [comp_vecCons'']\n\nlemma comp_vecConsLast (f : \u03b1 \u2192 \u03b2) (a : \u03b1) (s : Fin n \u2192 \u03b1) : (fun x => f $ (s <: a) x) = f \u2218 s <: f a :=\nfunext (fun i => lastCases (by simp) (by simp) i)\n\n@[simp] lemma vecHead_comp (f : \u03b1 \u2192 \u03b2) (v : Fin (n + 1) \u2192 \u03b1) : vecHead (f \u2218 v) = f (vecHead v) :=\n  by simp [vecHead]\n\n@[simp] lemma vecTail_comp (f : \u03b1 \u2192 \u03b2) (v : Fin (n + 1) \u2192 \u03b1) : vecTail (f \u2218 v) = f \u2218 (vecTail v) := by\n  simp [vecTail, Function.comp_assoc]\n\nlemma vecConsLast_vecEmpty {s : Fin 0 \u2192 \u03b1} (a : \u03b1) : s <: a = ![a] :=\n  funext (fun x => by\n    have : 0 = Fin.last 0 := by rfl\n    cases' x using Fin.cases with i\n    \u00b7 rw [this, rightConcat_last, cons_val_fin_one]\n    have := i.isLt; contradiction )\n\nlemma constant_eq_singleton {a : \u03b1} : (fun _ => a) = ![a] := by funext x; simp\n\nlemma constant_eq_singleton' {v : Fin 1 \u2192 \u03b1} : v = ![v 0] := by funext x; simp [Fin.eq_zero]\n\nlemma constant_eq_vec\u2082 {a : \u03b1} : (fun _ => a) = ![a, a] := by\n  funext x; cases x using Fin.cases <;> simp [Fin.eq_zero]\n\nlemma fun_eq_vec\u2082 {v : Fin 2 \u2192 \u03b1} : v = ![v 0, v 1] := by\n  funext x; cases x using Fin.cases <;> simp [Fin.eq_zero]\n\nlemma injective_vecCons {f : Fin n \u2192 \u03b1} (h : Function.Injective f) {a} (ha : \u2200 i, a \u2260 f i) : Function.Injective (a :> f) := by\n  have : \u2200 i, f i \u2260 a := fun i => (ha i).symm\n  intro i j; cases i using Fin.cases <;> cases j using Fin.cases\n  \u00b7 simp\n  \u00b7 simp [*]\n  \u00b7 simp [*]\n  \u00b7 simpa using @h _ _\n\nend\n\nvariable {\u03b1 : Type _}\n\ndef toList : {n : \u2115} \u2192 (Fin n \u2192 \u03b1) \u2192 List \u03b1\n  | 0,     _ => []\n  | _ + 1, v => v 0 :: toList (v \u2218 Fin.succ)\n\n@[simp] lemma toList_zero (v : Fin 0 \u2192 \u03b1) : toList v = [] := rfl\n\n@[simp] lemma toList_succ (v : Fin (n + 1) \u2192 \u03b1) : toList v = v 0 :: toList (v \u2218 Fin.succ) := rfl\n\n@[simp] lemma toList_length (v : Fin n \u2192 \u03b1) : (toList v).length = n :=\n  by induction n <;> simp [*]\n\n@[simp] lemma mem_toList_iff {v : Fin n \u2192 \u03b1} {a} : a \u2208 toList v \u2194 \u2203 i, v i = a := by\n  induction n\n  \u00b7 simp [*]\n  \u00b7 suffices (a = v 0 \u2228 \u2203 i : Fin _, v i.succ = a) \u2194 \u2203 i, v i = a by simp [*]\n    constructor\n    \u00b7 rintro (rfl | \u27e8i, rfl\u27e9) <;> simp\n    \u00b7 rintro \u27e8i, rfl\u27e9; cases i using Fin.cases <;> simp\n\nvariable {m : Type u \u2192 Type v} [Monad m] {\u03b1 : Type w} {\u03b2 : Type u}\n\ndef getM : {n : \u2115} \u2192 {\u03b2 : Fin n \u2192 Type u} \u2192 ((i : Fin n) \u2192 m (\u03b2 i)) \u2192 m ((i : Fin n) \u2192 \u03b2 i)\n  | 0,     _, _ => pure finZeroElim\n  | _ + 1, _, f => Fin.cases <$> f 0 <*> getM (f \u00b7.succ)\n\nlemma getM_pure [LawfulMonad m] {n} {\u03b2 : Fin n \u2192 Type u} (v : (i : Fin n) \u2192 \u03b2 i) :\n    getM (fun i => (pure (v i) : m (\u03b2 i))) = pure v := by\n  induction' n with n ih\n  \u00b7 unfold getM; congr; funext x; exact x.elim0\n  \u00b7 simp only [getM, map_pure, ih, seq_pure]\n    exact congr_arg _ (funext <| Fin.cases rfl fun i \u21a6 rfl)\n\n@[simp] lemma getM_some {n} {\u03b2 : Fin n \u2192 Type u} (v : (i : Fin n) \u2192 \u03b2 i) :\n    getM (fun i => (some (v i) : Option (\u03b2 i))) = some v := getM_pure v\n\ndef appendr {n m} (v : Fin n \u2192 \u03b1) (w : Fin m \u2192 \u03b1) : Fin (m + n) \u2192 \u03b1 := Matrix.vecAppend (add_comm m n) v w\n\n@[simp] lemma appendr_nil {m} (w : Fin m \u2192 \u03b1) : appendr ![] w = w := by funext i; simp [appendr]\n\n@[simp] lemma appendr_cons {m n} (x : \u03b1) (v : Fin n \u2192 \u03b1) (w : Fin m \u2192 \u03b1) : appendr (x :> v) w = x :> appendr v w := by funext i; simp [appendr]\n\nsection vecToNat\n\ndef vecToNat : {n : \u2115} \u2192 (Fin n \u2192 \u2115) \u2192 \u2115\n  | 0,     _ => 0\n  | _ + 1, v => Nat.pair (v 0) (vecToNat $ v \u2218 Fin.succ) + 1\n\nopen Encodable\n\n@[simp] lemma vecToNat_empty (v : Fin 0 \u2192 \u2115) : vecToNat v = 0 := by rfl\n\n@[simp] lemma encode_succ {n} (x : \u2115) (v : Fin n \u2192 \u2115) : vecToNat (x :> v) = Nat.pair x (vecToNat v) + 1 := by\n  simp [vecToNat, Function.comp_def]\n\nend vecToNat\n\nend Matrix\n\nnamespace DMatrix\n\ndef vecEmpty : Fin 0 \u2192 \u03b1 :=\n  Fin.elim0\n\nvariable {n} {\u03b1 : Fin (n + 1) \u2192 Type*}\n\ndef vecCons (h : \u03b1 0) (t : (i : Fin n) \u2192 \u03b1 i.succ) : (i : Fin n.succ) \u2192 \u03b1 i :=\n  Fin.cons h t\n\ninfixr:70 \" ::> \" => vecCons\n\n@[simp] lemma vecCons_zero (h : \u03b1 0) (t : (i : Fin n) \u2192 \u03b1 i.succ) : (h ::> t) 0 = h := rfl\n\n@[simp] lemma vecCons_succ (h : \u03b1 0) (t : (i : Fin n) \u2192 \u03b1 i.succ) (i : Fin n) : (h ::> t) i.succ = t i := rfl\n\nlemma eq_vecCons (s : (i : Fin (n + 1)) \u2192 \u03b1 i) : s = s 0 ::> fun i => s i.succ :=\n   funext $ Fin.cases (by simp) (by simp)\n\n@[simp] lemma vecCons_ext (a\u2081 a\u2082 : \u03b1 0) (s\u2081 s\u2082 : (i : Fin n) \u2192 \u03b1 i.succ) :\n    a\u2081 ::> s\u2081 = a\u2082 ::> s\u2082 \u2194 a\u2081 = a\u2082 \u2227 s\u2081 = s\u2082 :=\n  \u27e8by intros h\n      constructor\n      \u00b7 exact congrFun h 0\n      \u00b7 exact funext (fun i => by simpa using congrFun h i.succ),\n   by intros h; simp [h]\u27e9\n\ndef decVec {n : \u2115} {\u03b1 : Fin n \u2192 Type _}\n  (v w : (i : Fin n) \u2192 \u03b1 i) (h : \u2200 i, Decidable (v i = w i)) : Decidable (v = w) := by\n    induction' n with n ih\n    \u00b7 exact isTrue (by funext x; exact finZeroElim (\u03b1 := fun x => v x = w x) x)\n    \u00b7 rw [eq_vecCons v, eq_vecCons w, vecCons_ext]\n      haveI := ih (fun i => v i.succ) (fun i => w i.succ) (fun i => h i.succ)\n      refine instDecidableAnd\n\nend DMatrix\n\nnamespace Option\n\nlemma pure_eq_some (a : \u03b1) : pure a = some a := rfl\n\n@[simp] lemma toList_eq_iff {o : Option \u03b1} {a} :\n    o.toList = [a] \u2194 o = some a := by rcases o <;> simp\n\nend Option\n\ndef Nat.natToVec : \u2115 \u2192 (n : \u2115) \u2192 Option (Fin n \u2192 \u2115)\n  | 0,     0     => some Matrix.vecEmpty\n  | e + 1, n + 1 => Nat.natToVec e.unpair.2 n |>.map (e.unpair.1 :> \u00b7)\n  | _,     _     => none\n\nnamespace Nat\nopen Matrix\nvariable {n : \u2115}\n\n@[simp] lemma natToVec_vecToNat (v : Fin n \u2192 \u2115) : (vecToNat v).natToVec n = some v := by\n  induction n\n  \u00b7 simp [*, Nat.natToVec, vecToNat, Matrix.empty_eq]\n  \u00b7 suffices v 0 :> v \u2218 Fin.succ = v by simp [*, Nat.natToVec, vecToNat]\n    exact funext (fun i \u21a6 i.cases (by simp [Matrix.empty_eq]) (by simp [Matrix.empty_eq]))\n\nlemma lt_of_eq_natToVec {e : \u2115} {v : Fin n \u2192 \u2115} (h : e.natToVec n = some v) (i : Fin n) : v i < e := by\n  induction' n with n ih generalizing e\n  \u00b7 exact i.elim0\n  \u00b7 cases' e with e\n    \u00b7 simp [natToVec] at h\n    \u00b7 simp only [natToVec, Option.map_eq_some'] at h\n      rcases h with \u27e8v, hnv, rfl\u27e9\n      cases' i using Fin.cases with i\n      \u00b7 simp [lt_succ, unpair_left_le]\n      \u00b7 simp only [cons_val_succ]\n        exact lt_trans (ih hnv i) (lt_succ.mpr <| unpair_right_le e)\n\nlemma one_le_of_bodd {n : \u2115} (h : n.bodd = true) : 1 \u2264 n :=\nby induction n <;> simp [\u2190Nat.add_one] at h \u22a2\n\nlemma pair_le_pair_of_le {a\u2081 a\u2082 b\u2081 b\u2082 : \u2115} (ha : a\u2081 \u2264 a\u2082) (hb : b\u2081 \u2264 b\u2082) : a\u2081.pair b\u2081 \u2264 a\u2082.pair b\u2082 := by\n  rcases lt_or_eq_of_le ha with (ha | rfl) <;> rcases lt_or_eq_of_le hb with (hb | rfl)\n  { exact le_of_lt (lt_trans (Nat.pair_lt_pair_left b\u2081 ha) (Nat.pair_lt_pair_right a\u2082 hb)) }\n  { exact le_of_lt (Nat.pair_lt_pair_left b\u2081 ha) }\n  { exact le_of_lt (Nat.pair_lt_pair_right a\u2081 hb) }\n  { rfl }\n\nend Nat\n\nnamespace Fin\n\nlemma pos_of_coe_ne_zero {i : Fin (n + 1)} (h : (i : \u2115) \u2260 0) :\n    0 < i := Nat.pos_of_ne_zero h\n\n@[simp] lemma one_pos'' : (0 : Fin (n + 2)) < 1 := pos_of_coe_ne_zero (Nat.succ_ne_zero 0)\n\n@[simp] lemma two_pos : (0 : Fin (n + 3)) < 2 := pos_of_coe_ne_zero (Nat.succ_ne_zero 1)\n\n@[simp] lemma three_pos : (0 : Fin (n + 4)) < 3 := pos_of_coe_ne_zero (Nat.succ_ne_zero 2)\n\n@[simp] lemma four_pos : (0 : Fin (n + 5)) < 4 := pos_of_coe_ne_zero (Nat.succ_ne_zero 3)\n\n@[simp] lemma five_pos : (0 : Fin (n + 6)) < 5 := pos_of_coe_ne_zero (Nat.succ_ne_zero 4)\n\nend Fin\n\nnamespace Fintype\nvariable {\u03b9 : Type _} [Fintype \u03b9]\n\nsection\n\nvariable {\u03b1 : Type _} [SemilatticeSup \u03b1] [OrderBot \u03b1]\n\ndef sup (f : \u03b9 \u2192 \u03b1) : \u03b1 := (Finset.univ : Finset \u03b9).sup f\n\n@[simp] lemma elem_le_sup (f : \u03b9 \u2192 \u03b1) (i : \u03b9) : f i \u2264 sup f := Finset.le_sup (by simp)\n\nlemma le_sup {a : \u03b1} {f : \u03b9 \u2192 \u03b1} (i : \u03b9) (le : a \u2264 f i) : a \u2264 sup f := le_trans le (elem_le_sup _ _)\n\n@[simp] lemma sup_le_iff {f : \u03b9 \u2192 \u03b1} {a : \u03b1} :\n    sup f \u2264 a \u2194 (\u2200 i, f i \u2264 a) := by simp [sup]\n\n@[simp] lemma finsup_eq_0_of_empty [IsEmpty \u03b9] (f : \u03b9 \u2192 \u03b1) : sup f = \u22a5 := by simp [sup]\n\nend\n\ndef decideEqPi {\u03b2 : \u03b9 \u2192 Type*} (a b : (i : \u03b9) \u2192 \u03b2 i) (_ : (i : \u03b9) \u2192 Decidable (a i = b i)) : Decidable (a = b) :=\n  decidable_of_iff (\u2200 i, a i = b i) funext_iff.symm\n\nend Fintype\n\nnamespace String\n\ndef vecToStr : \u2200 {n}, (Fin n \u2192 String) \u2192 String\n  | 0,     _ => \"\"\n  | n + 1, s => if n = 0 then s 0 else s 0 ++ \", \" ++ @vecToStr n (fun i => s (Fin.succ i))\n\n#eval vecToStr ![\"a\", \"b\", \"c\", \"d\"]\n\nend String\n\nnamespace Empty\n\nlemma eq_elim {\u03b1 : Sort u} (f : Empty \u2192 \u03b1) : f = elim := funext (by rintro \u27e8\u27e9)\n\nend Empty\n\nnamespace IsEmpty\nvariable {o : Sort u} (h : IsEmpty o)\n\nlemma eq_elim {\u03b1 : Sort*} (f : o \u2192 \u03b1) : f = h.elim' := funext h.elim\n\nend IsEmpty\n\nnamespace Function\n\nvariable  {\u03b1 : Type u} {\u03b2 : Type v}\n\ndef funEqOn (\u03c6 : \u03b1 \u2192 Prop) (f g : \u03b1 \u2192 \u03b2) : Prop := \u2200 a, \u03c6 a \u2192 f a = g a\n\nlemma funEqOn.of_subset {\u03c6 \u03c8 : \u03b1 \u2192 Prop} {f g : \u03b1 \u2192 \u03b2} (e : funEqOn \u03c6 f g) (h : \u2200 a, \u03c8 a \u2192 \u03c6 a) : funEqOn \u03c8 f g :=\n  by intro a ha; exact e a (h a ha)\n\nend Function\n\nnamespace Quotient\nopen Matrix\nvariable {\u03b1 : Type u} [s : Setoid \u03b1] {\u03b2 : Sort v}\n\n@[elab_as_elim]\nlemma inductionOnVec {\u03c6 : (Fin n \u2192 Quotient s) \u2192 Prop} (v : Fin n \u2192 Quotient s)\n  (h : \u2200 v : Fin n \u2192 \u03b1, \u03c6 (fun i => Quotient.mk s (v i))) : \u03c6 v :=\n  Quotient.induction_on_pi v h\n\ndef liftVec : \u2200 {n} (f : (Fin n \u2192 \u03b1) \u2192 \u03b2),\n  (\u2200 v\u2081 v\u2082 : Fin n \u2192 \u03b1, (\u2200 n, v\u2081 n \u2248 v\u2082 n) \u2192 f v\u2081 = f v\u2082) \u2192 (Fin n \u2192 Quotient s) \u2192 \u03b2\n| 0,     f, _, _ => f ![]\n| n + 1, f, h, v =>\n  let ih : \u03b1 \u2192 (Fin n \u2192 Quotient s) \u2192 \u03b2 :=\n    fun a v => liftVec (n := n) (fun v => f (a :> v))\n      (fun v\u2081 v\u2082 hv => h (a :> v\u2081) (a :> v\u2082) (Fin.cases (by simpa using refl a) hv)) v\n  Quot.liftOn (vecHead v) (ih \u00b7 (vecTail v))\n    (fun a b hab => by\n      have : \u2200 v, f (a :> v) = f (b :> v) := fun v \u21a6 h _ _ (Fin.cases hab (by simpa using fun x \u21a6 refl _))\n      simp [this, ih])\n\n@[simp] lemma liftVec_zero (f : (Fin 0 \u2192 \u03b1) \u2192 \u03b2) (h) (v : Fin 0 \u2192 Quotient s) : liftVec f h v = f ![] := rfl\n\nlemma liftVec_mk {n} (f : (Fin n \u2192 \u03b1) \u2192 \u03b2) (h) (v : Fin n \u2192 \u03b1) :\n    liftVec f h (Quotient.mk s \u2218 v) = f v := by\n  induction' n with n ih <;> simp [liftVec, empty_eq, Quotient.liftOn_mk]\n  simpa using ih (fun v' => f (vecHead v :> v'))\n    (fun v\u2081 v\u2082 hv => h (vecHead v :> v\u2081) (vecHead v :> v\u2082) (Fin.cases (refl _) hv)) (vecTail v)\n\n@[simp] lemma liftVec_mk\u2081 (f : (Fin 1 \u2192 \u03b1) \u2192 \u03b2) (h) (a : \u03b1) :\n    liftVec f h ![Quotient.mk s a] = f ![a] := liftVec_mk f h ![a]\n\n@[simp] lemma liftVec_mk\u2082 (f : (Fin 2 \u2192 \u03b1) \u2192 \u03b2) (h) (a\u2081 a\u2082 : \u03b1) :\n    liftVec f h ![Quotient.mk s a\u2081, Quotient.mk s a\u2082] = f ![a\u2081, a\u2082] := liftVec_mk f h ![a\u2081, a\u2082]\n\nend Quotient\n\nnamespace List\n\nvariable {\u03b1 : Type u} {\u03b2: Type v}\n\nlemma getI_map_range [Inhabited \u03b1] (f : \u2115 \u2192 \u03b1) (h : i < n) : ((List.range n).map f).getI i = f i := by\n  simpa [h] using List.getI_eq_getElem ((List.range n).map f) (n := i) (by simpa using h)\n\ndef subsetSet (l : List \u03b1) (s : Set \u03b1) [DecidablePred s] : Bool :=\n  l.foldr (fun a ih => s a && ih) true\n\ndef upper : List \u2115 \u2192 \u2115\n  | []      => 0\n  | n :: ns => max (n + 1) ns.upper\n\n@[simp] lemma upper_nil : upper [] = 0 := rfl\n\n@[simp] lemma upper_cons (n : \u2115) (ns : List \u2115) : upper (n :: ns) = max (n + 1) ns.upper := rfl\n\nlemma lt_upper (l : List \u2115) {n} (h : n \u2208 l) : n < l.upper := by\n  induction' l with n ns ih\n  case nil => simp at h\n  case cons m =>\n    suffices m < n + 1 \u2228 m < ns.upper by simpa\n    rcases show m = n \u2228 m \u2208 ns by simpa using h with (rfl | h)\n    \u00b7 exact Or.inl (Nat.lt_succ_self _)\n    \u00b7 exact Or.inr (ih h)\n\nsection finset\n\nvariable [DecidableEq \u03b1] [DecidableEq \u03b2]\n\nlemma toFinset_map {f : \u03b1 \u2192 \u03b2} (l : List \u03b1) : (l.map f).toFinset = Finset.image f l.toFinset := by\n  induction l <;> simp [*]\n\nlemma toFinset_mono {l l' : List \u03b1} (h : l \u2286 l') : l.toFinset \u2286 l'.toFinset := by\n  intro a; simp only [mem_toFinset]; intro ha; exact h ha\n\nend finset\n\nsection sup\n\nvariable [SemilatticeSup \u03b1] [OrderBot \u03b1]\n\ndef sup : List \u03b1 \u2192 \u03b1\n  |      [] => \u22a5\n  | a :: as => a \u2294 as.sup\n\n@[simp] lemma sup_nil : ([] : List \u03b1).sup = \u22a5 := rfl\n\n@[simp] lemma sup_cons (a : \u03b1) (as : List \u03b1) : (a :: as).sup = a \u2294 as.sup := rfl\n\nlemma le_sup {a} {l : List \u03b1} : a \u2208 l \u2192 a \u2264 l.sup := by\n  induction' l with a l ih\n  \u00b7 simp\n  case cons _ b =>\n    intro h\n    rcases show b = a \u2228 b \u2208 l by simpa using h with (rfl | h)\n    \u00b7 simp\n    \u00b7 exact le_sup_of_le_right (ih h)\n\nlemma sup_ofFn (f : Fin n \u2192 \u03b1) : (ofFn f).sup = Finset.sup Finset.univ f := by\n  induction' n with n ih\n  \u00b7 simp\n  \u00b7 have h\u2081 : (Finset.univ : Finset (Fin (n + 1))) = insert 0 ((Finset.univ : Finset (Fin n)).image Fin.succ) := by\n      ext i; simp\n    have h\u2082 : Finset.sup Finset.univ (fun i \u21a6 f (Fin.succ i)) = Finset.sup {0}\u1d9c f := by\n      simpa [Function.comp] using Eq.symm <| Finset.sup_image (Finset.univ : Finset (Fin n)) Fin.succ f\n    calc\n      (ofFn f).sup = (f 0 \u2294 Finset.univ.sup fun i : Fin _ \u21a6 f i.succ) := by simp [ih]\n      _            = f 0 \u2294 Finset.sup {0}\u1d9c f                          := by rw [h\u2082]\n      _            = Finset.univ.sup f                                := by rw [h\u2081, Finset.sup_insert]; simp\n\nend sup\n\nlemma ofFn_get_eq_map_cast {n} (g : \u03b1 \u2192 \u03b2) (as : List \u03b1) {h} :\n    ofFn (fun i => g (as.get (i.cast h)) : Fin n \u2192 \u03b2) = as.map g := by\n  ext i b; simp\n  by_cases hi : i < n\n  \u00b7 simp [hi, List.ofFnNthVal, List.getElem?_eq_getElem (h \u25b8 hi)]\n  \u00b7 simp [hi, List.ofFnNthVal, List.getElem?_eq_none (le_of_not_lt $ h \u25b8 hi)]\n\nvariable {m : Type _ \u2192 Type _} {\u03b1 : Type _} {\u03b2 : Type _} [Monad m]\n\nlemma append_subset_append {l\u2081 l\u2082 l : List \u03b1} (h : l\u2081 \u2286 l\u2082) : l\u2081 ++ l \u2286 l\u2082 ++ l :=\n  List.append_subset.mpr \u27e8List.subset_append_of_subset_left _ h, subset_append_right l\u2082 l\u27e9\n\nlemma subset_of_eq {l\u2081 l\u2082 : List \u03b1} (e : l\u2081 = l\u2082) : l\u2081 \u2286 l\u2082 := by simp [e]\n\nsection remove\n\ndef remove [DecidableEq \u03b1] (a : \u03b1) : List \u03b1 \u2192 List \u03b1 := List.filter (\u00b7 \u2260 a)\n\nvariable [DecidableEq \u03b1]\n\n@[simp]\nlemma remove_nil (a : \u03b1) : [].remove a = [] := by simp [List.remove]\n\n@[simp]\nlemma eq_remove_cons {l : List \u03b1} : (\u03c8 :: l).remove \u03c8 = l.remove \u03c8 := by induction l <;> simp_all [List.remove];\n\n@[simp]\nlemma remove_singleton_of_ne {\u03c6 \u03c8 : \u03b1} (h : \u03c6 \u2260 \u03c8) : [\u03c6].remove \u03c8 = [\u03c6] := by simp_all [List.remove, Ne.symm];\n\nlemma mem_remove_iff {l : List \u03b1} : b \u2208 l.remove a \u2194 b \u2208 l \u2227 b \u2260 a := by\n  simp [List.remove, List.of_mem_filter]\n\nlemma mem_of_mem_remove {a b : \u03b1} {l : List \u03b1} (h : b \u2208 l.remove a) : b \u2208 l := by\n  rw [mem_remove_iff] at h; exact h.1\n\n@[simp] lemma remove_cons_self (l : List \u03b1) (a) :\n  (a :: l).remove a = l.remove a := by simp [remove]\n\nlemma remove_cons_of_ne (l : List \u03b1) {a b} (ne : a \u2260 b) :\n  (a :: l).remove b = a :: l.remove b := by simp_all [remove];\n\nlemma remove_subset (a) (l : List \u03b1) :\n    l.remove a \u2286 l := by\n  simp only [subset_def, mem_remove_iff, ne_eq, and_imp]\n  intros; simp [*]\n\nlemma remove_subset_remove (a) {l\u2081 l\u2082 : List \u03b1} (h : l\u2081 \u2286 l\u2082) :\n    l\u2081.remove a \u2286 l\u2082.remove a := by\n  simp only [subset_def, mem_remove_iff, ne_eq, and_imp]\n  intros\n  simpa [*] using h (by assumption)\n\nlemma remove_cons_subset_cons_remove (a b) (l : List \u03b1) :\n    (a :: l).remove b \u2286 a :: l.remove b := by\n  intro x\n  simp only [mem_remove_iff, mem_cons, ne_eq, and_imp]\n  rintro (rfl | hx) nex <;> simp [*]\n\nlemma remove_map_substet_map_remove [DecidableEq \u03b2] (f : \u03b1 \u2192 \u03b2) (l : List \u03b1) (a) :\n    (l.map f).remove (f a) \u2286 (l.remove a).map f := by\n  simp only [subset_def, mem_remove_iff, mem_map, ne_eq, and_imp, forall_exists_index,\n    forall_apply_eq_imp_iff\u2082]\n  intro b hb neb;\n  exact \u27e8b, \u27e8hb, by rintro rfl; exact neb rfl\u27e9, rfl\u27e9\n\nend remove\n\n@[elab_as_elim]\nlemma induction_with_singleton\n  {motive : List F \u2192 Prop}\n  (hnil : motive [])\n  (hsingle : \u2200 a, motive [a])\n  (hcons : \u2200 a as, as \u2260 [] \u2192 motive as \u2192 motive (a :: as)) : \u2200 as, motive as := by\n  intro as;\n  induction as with\n  | nil => exact hnil;\n  | cons a as ih => cases as with\n    | nil => exact hsingle a;\n    | cons b bs => exact hcons a (b :: bs) (by simp) ih;\n\n\n\nend List\n\nnamespace List.Vector\n\nvariable {\u03b1 : Type*}\n\nlemma get_mk_eq_get {n} (l : List \u03b1) (h : l.length = n) (i : Fin n) : List.Vector.get (\u27e8l, h\u27e9 : List.Vector \u03b1 n) i = l.get (i.cast h.symm) := rfl\n\nlemma get_one {\u03b1 : Type*} {n} (v : Vector \u03b1 (n + 2)) : v.get 1 = v.tail.head := by\n  rw [\u2190Vector.get_zero, Vector.get_tail_succ]; rfl\n\n", "theoremStatement": "lemma ofFn_vecCons (a : \u03b1) (v : Fin n \u2192 \u03b1) :\n    ofFn (a :> v) = a ::\u1d65 ofFn v ", "theoremName": "List.Vector.ofFn_vecCons", "fileCreated": {"commit": "33e08c2b47f966f772df9af60cbdbc5688295bbf", "date": "2024-10-15"}, "theoremCreated": {"commit": "882430c05764b123332207cb6a2aa0f856c69063", "date": "2024-12-23"}, "file": "foundation/Foundation/Vorspiel/Vorspiel.lean", "module": "Foundation.Vorspiel.Vorspiel", "jsonFile": "Foundation.Vorspiel.Vorspiel.jsonl", "positionMetadata": {"lineInFile": 616, "tokenPositionInFile": 21135, "theoremPositionInFile": 117}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 35}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  ext i; cases i using Fin.cases <;> simp", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 47}}
