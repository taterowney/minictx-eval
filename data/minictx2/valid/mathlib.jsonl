{"srcContext": "/-\nCopyright (c) 2024 Xavier Roblot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Xavier Roblot\n-/\nimport Mathlib.Analysis.BoxIntegral.UnitPartition\nimport Mathlib.MeasureTheory.Measure.Haar.InnerProductSpace\n\n/-!\n# Covolume of \u2124-lattices\n\nLet `E` be a finite dimensional real vector space.\n\nLet `L` be a `\u2124`-lattice `L` defined as a discrete `\u2124`-submodule of `E` that spans `E` over `\u211d`.\n\n## Main definitions and results\n\n* `ZLattice.covolume`: the covolume of `L` defined as the volume of an arbitrary fundamental\ndomain of `L`.\n\n* `ZLattice.covolume_eq_measure_fundamentalDomain`: the covolume of `L` does not depend on the\nchoice of the fundamental domain of `L`.\n\n* `ZLattice.covolume_eq_det`: if `L` is a lattice in `\u211d^n`, then its covolume is the absolute\nvalue of the determinant of any `\u2124`-basis of `L`.\n\n* `ZLattice.covolume.tendsto_card_div_pow`: Let `s` be a bounded measurable set of `\u03b9 \u2192 \u211d`, then\nthe number of points in `s \u2229 n\u207b\u00b9 \u2022 L` divided by `n ^ card \u03b9` tends to `volume s / covolume L`\nwhen `n : \u2115` tends to infinity. See also `ZLattice.covolume.tendsto_card_div_pow'` for a version\nfor `InnerProductSpace \u211d E` and `ZLattice.covolume.tendsto_card_div_pow''` for the general version.\n\n* `ZLattice.covolume.tendsto_card_le_div`: Let `X` be a cone in `\u03b9 \u2192 \u211d` and let `F : (\u03b9 \u2192 \u211d) \u2192 \u211d`\nbe a function such that `F (c \u2022 x) = c ^ card \u03b9 * F x`. Then the number of points `x \u2208 X` such that\n`F x \u2264 c` divided by `c` tends to `volume {x \u2208 X | F x \u2264 1} / covolume L` when `c : \u211d` tends to\ninfinity. See also `ZLattice.covolume.tendsto_card_le_div'` for a version for\n`InnerProductSpace \u211d E` and `ZLattice.covolume.tendsto_card_le_div''` for the general version.\n\n## Naming convention\n\nSome results are true in the case where the ambient finite dimensional real vector space is the\npi-space `\u03b9 \u2192 \u211d` and in the case where it is an `InnerProductSpace`. We use the following\nconvention: the plain name is for the pi case, for eg. `volume_image_eq_volume_div_covolume`. For\nthe same result in the `InnerProductSpace` case, we add a `prime`, for eg.\n`volume_image_eq_volume_div_covolume'`. When the same result exists in the\ngeneral case, we had two primes, eg. `covolume.tendsto_card_div_pow''`.\n\n-/\n\nnoncomputable section\n\nnamespace ZLattice\n\nopen Submodule MeasureTheory Module MeasureTheory Module ZSpan\n\nsection General\n\nvariable {E : Type*} [NormedAddCommGroup E] [MeasurableSpace E] (L : Submodule \u2124 E)\n\n/-- The covolume of a `\u2124`-lattice is the volume of some fundamental domain; see\n`ZLattice.covolume_eq_volume` for the proof that the volume does not depend on the choice of\nthe fundamental domain. -/\ndef covolume (\u03bc : Measure E := by volume_tac) : \u211d := (addCovolume L E \u03bc).toReal\n\nend General\n\nsection Basic\n\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] [FiniteDimensional \u211d E]\nvariable [MeasurableSpace E] [BorelSpace E]\nvariable (L : Submodule \u2124 E) [DiscreteTopology L] [IsZLattice \u211d L]\nvariable (\u03bc : Measure E := by volume_tac) [Measure.IsAddHaarMeasure \u03bc]\n\ntheorem covolume_eq_measure_fundamentalDomain {F : Set E} (h : IsAddFundamentalDomain L F \u03bc) :\n    covolume L \u03bc = (\u03bc F).toReal := by\n  have : MeasurableVAdd L E := (inferInstance : MeasurableVAdd L.toAddSubgroup E)\n  have : VAddInvariantMeasure L E \u03bc := (inferInstance : VAddInvariantMeasure L.toAddSubgroup E \u03bc)\n  exact congr_arg ENNReal.toReal (h.covolume_eq_volume \u03bc)\n\ntheorem covolume_ne_zero : covolume L \u03bc \u2260 0 := by\n  rw [covolume_eq_measure_fundamentalDomain L \u03bc (isAddFundamentalDomain (Free.chooseBasis \u2124 L) \u03bc),\n    ENNReal.toReal_ne_zero]\n  refine \u27e8measure_fundamentalDomain_ne_zero _, ne_of_lt ?_\u27e9\n  exact Bornology.IsBounded.measure_lt_top (fundamentalDomain_isBounded _)\n\ntheorem covolume_pos : 0 < covolume L \u03bc :=\n  lt_of_le_of_ne ENNReal.toReal_nonneg (covolume_ne_zero L \u03bc).symm\n\ntheorem covolume_comap {F : Type*} [NormedAddCommGroup F] [NormedSpace \u211d F] [FiniteDimensional \u211d F]\n    [MeasurableSpace F] [BorelSpace F] (\u03bd : Measure F := by volume_tac) [Measure.IsAddHaarMeasure \u03bd]\n    {e : F \u2243L[\u211d] E} (he : MeasurePreserving e \u03bd \u03bc) :\n    covolume (ZLattice.comap \u211d L e.toLinearMap) \u03bd = covolume L \u03bc := by\n  rw [covolume_eq_measure_fundamentalDomain _ _ (isAddFundamentalDomain (Free.chooseBasis \u2124 L) \u03bc),\n    covolume_eq_measure_fundamentalDomain _ _ ((isAddFundamentalDomain\n    ((Free.chooseBasis \u2124 L).ofZLatticeComap \u211d L e.toLinearEquiv) \u03bd)), \u2190 he.measure_preimage\n    (fundamentalDomain_measurableSet _).nullMeasurableSet, \u2190 e.image_symm_eq_preimage,\n    \u2190 e.symm.coe_toLinearEquiv, map_fundamentalDomain]\n  congr!\n  ext; simp\n\ntheorem covolume_eq_det_mul_measure {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (b : Basis \u03b9 \u2124 L)\n    (b\u2080 : Basis \u03b9 \u211d E) :\n    covolume L \u03bc = |b\u2080.det ((\u2191) \u2218 b)| * (\u03bc (fundamentalDomain b\u2080)).toReal := by\n  rw [covolume_eq_measure_fundamentalDomain L \u03bc (isAddFundamentalDomain b \u03bc),\n    measure_fundamentalDomain _ _ b\u2080,\n    measure_congr (fundamentalDomain_ae_parallelepiped b\u2080 \u03bc), ENNReal.toReal_mul,\n    ENNReal.toReal_ofReal (by positivity)]\n  congr\n  ext\n  exact b.ofZLatticeBasis_apply \u211d L _\n\ntheorem covolume_eq_det {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (L : Submodule \u2124 (\u03b9 \u2192 \u211d))\n    [DiscreteTopology L] [IsZLattice \u211d L] (b : Basis \u03b9 \u2124 L) :\n    covolume L = |(Matrix.of ((\u2191) \u2218 b)).det| := by\n  rw [covolume_eq_measure_fundamentalDomain L volume (isAddFundamentalDomain b volume),\n    volume_fundamentalDomain, ENNReal.toReal_ofReal (by positivity)]\n  congr\n  ext1\n  exact b.ofZLatticeBasis_apply \u211d L _\n\ntheorem covolume_eq_det_inv {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (L : Submodule \u2124 (\u03b9 \u2192 \u211d))\n    [DiscreteTopology L] [IsZLattice \u211d L] (b : Basis \u03b9 \u2124 L) :\n    covolume L = |(LinearEquiv.det (b.ofZLatticeBasis \u211d L).equivFun : \u211d)|\u207b\u00b9 := by\n  rw [covolume_eq_det L b, \u2190 Pi.basisFun_det_apply, show (((\u2191) : L \u2192 _) \u2218 \u21d1b) =\n    (b.ofZLatticeBasis \u211d) by ext; simp, \u2190 Basis.det_inv, \u2190 abs_inv, Units.val_inv_eq_inv_val,\n    IsUnit.unit_spec, \u2190 Basis.det_basis, LinearEquiv.coe_det]\n  rfl\n\ntheorem volume_image_eq_volume_div_covolume {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9]\n    (L : Submodule \u2124 (\u03b9 \u2192 \u211d)) [DiscreteTopology L] [IsZLattice \u211d L] (b : Basis \u03b9 \u2124 L)\n    {s : Set (\u03b9 \u2192 \u211d)} :\n    volume ((b.ofZLatticeBasis \u211d L).equivFun '' s) = volume s / ENNReal.ofReal (covolume L) := by\n  rw [LinearEquiv.image_eq_preimage, Measure.addHaar_preimage_linearEquiv, LinearEquiv.symm_symm,\n    covolume_eq_det_inv L b, ENNReal.div_eq_inv_mul, ENNReal.ofReal_inv_of_pos\n    (abs_pos.mpr (LinearEquiv.det _).ne_zero), inv_inv, LinearEquiv.coe_det]\n\n/-- A more general version of `ZLattice.volume_image_eq_volume_div_covolume`;\nsee the `Naming conventions` section in the introduction. -/\ntheorem volume_image_eq_volume_div_covolume' {E : Type*} [NormedAddCommGroup E]\n    [InnerProductSpace \u211d E] [FiniteDimensional \u211d E] [MeasurableSpace E] [BorelSpace E]\n    (L : Submodule \u2124 E) [DiscreteTopology L] [IsZLattice \u211d L] {\u03b9 : Type*} [Fintype \u03b9]\n    (b : Basis \u03b9 \u2124 L) {s : Set E} (hs : NullMeasurableSet s) :\n    volume ((b.ofZLatticeBasis \u211d).equivFun '' s) = volume s / ENNReal.ofReal (covolume L) := by\n  classical\n  let e : Fin (finrank \u211d E) \u2243 \u03b9 :=\n    Fintype.equivOfCardEq (by rw [Fintype.card_fin, finrank_eq_card_basis (b.ofZLatticeBasis \u211d)])\n  let f := (EuclideanSpace.equiv \u03b9 \u211d).symm.trans\n    ((stdOrthonormalBasis \u211d E).reindex e).repr.toContinuousLinearEquiv.symm\n  have hf : MeasurePreserving f :=\n    ((stdOrthonormalBasis \u211d E).reindex e).measurePreserving_repr_symm.comp\n      (EuclideanSpace.volume_preserving_measurableEquiv \u03b9).symm\n  rw [\u2190 hf.measure_preimage hs, \u2190 (covolume_comap L volume volume hf),\n    \u2190 volume_image_eq_volume_div_covolume (ZLattice.comap \u211d L f.toLinearMap)\n    (b.ofZLatticeComap \u211d L f.toLinearEquiv), Basis.ofZLatticeBasis_comap,\n    \u2190 f.image_symm_eq_preimage, \u2190 Set.image_comp]\n  simp only [Basis.equivFun_apply, ContinuousLinearEquiv.symm_toLinearEquiv, Basis.map_equivFun,\n    LinearEquiv.symm_symm, Function.comp_apply, LinearEquiv.trans_apply,\n    ContinuousLinearEquiv.coe_toLinearEquiv, ContinuousLinearEquiv.apply_symm_apply]\n\nend Basic\n\nnamespace covolume\n\nsection General\n\nopen Filter Fintype Pointwise Topology BoxIntegral Bornology\n\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]\nvariable {L : Submodule \u2124 E} [DiscreteTopology L] [IsZLattice \u211d L]\nvariable {\u03b9 : Type*} [Fintype \u03b9] (b : Basis \u03b9 \u2124 L)\n\n", "theoremStatement": "/-- A version of `ZLattice.covolume.tendsto_card_div_pow` for the general case;\nsee the `Naming convention` section in the introduction. -/\ntheorem tendsto_card_div_pow'' [FiniteDimensional \u211d E] [MeasurableSpace E] [BorelSpace E]\n    {s : Set E} (hs\u2081 : IsBounded s) (hs\u2082 : MeasurableSet s)\n    (hs\u2083 : volume (frontier ((b.ofZLatticeBasis \u211d).equivFun '' s)) = 0):\n    Tendsto (fun n : \u2115 \u21a6 (Nat.card (s \u2229 (n : \u211d)\u207b\u00b9 \u2022 L : Set E) : \u211d) / n ^ card \u03b9)\n      atTop (\ud835\udcdd (volume ((b.ofZLatticeBasis \u211d).equivFun '' s)).toReal) ", "theoremName": "ZLattice.covolume.tendsto_card_div_pow''", "fileCreated": {"commit": "85d6c78ac5782869d041c2ca6d3ca83cdde412c3", "date": "2024-09-09"}, "theoremCreated": {"commit": "211dc533566a173988a01067bb50d7917a097103", "date": "2024-12-18"}, "file": "mathlib/Mathlib/Algebra/Module/ZLattice/Covolume.lean", "module": "Mathlib.Algebra.Module.ZLattice.Covolume", "jsonFile": "Mathlib.Algebra.Module.ZLattice.Covolume.jsonl", "positionMetadata": {"lineInFile": 171, "tokenPositionInFile": 8341, "theoremPositionInFile": 10}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 270, "numPremises": 314}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  refine Tendsto.congr' ?_\n    (tendsto_card_div_pow_atTop_volume ((b.ofZLatticeBasis \u211d).equivFun '' s) ?_ ?_ hs\u2083)\n  \u00b7 filter_upwards [eventually_gt_atTop 0] with n hn\n    congr\n    refine Nat.card_congr <| ((b.ofZLatticeBasis \u211d).equivFun.toEquiv.subtypeEquiv fun x \u21a6 ?_).symm\n    simp_rw [Set.mem_inter_iff, \u2190 b.ofZLatticeBasis_span \u211d, LinearEquiv.coe_toEquiv,\n      Basis.equivFun_apply, Set.mem_image, DFunLike.coe_fn_eq, EmbeddingLike.apply_eq_iff_eq,\n      exists_eq_right, and_congr_right_iff, Set.mem_inv_smul_set_iff\u2080\n      (mod_cast hn.ne' : (n : \u211d) \u2260 0), \u2190 Finsupp.coe_smul, \u2190 LinearEquiv.map_smul, SetLike.mem_coe,\n      Basis.mem_span_iff_repr_mem, Pi.basisFun_repr, implies_true]\n  \u00b7 rw [\u2190 NormedSpace.isVonNBounded_iff \u211d] at hs\u2081 \u22a2\n    exact Bornology.IsVonNBounded.image hs\u2081 ((b.ofZLatticeBasis \u211d).equivFunL : E \u2192L[\u211d] \u03b9 \u2192 \u211d)\n  \u00b7 exact (b.ofZLatticeBasis \u211d).equivFunL.toHomeomorph.toMeasurableEquiv.measurableSet_image.mpr hs\u2082", "proofType": "tactic", "proofLengthLines": 13, "proofLengthTokens": 945}}
{"srcContext": "/-\nCopyright (c) 2017 Johannes H\u00f6lzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes H\u00f6lzl, Mario Carneiro, Kevin Buzzard, Yury Kudryashov, Fr\u00e9d\u00e9ric Dupuis,\n  Heather Macbeth\n-/\nimport Mathlib.Algebra.Module.Submodule.Lattice\n\n/-!\n# The span of a set of vectors, as a submodule\n\n* `Submodule.span s` is defined to be the smallest submodule containing the set `s`.\n\n## Notations\n\n* We introduce the notation `R \u2219 v` for the span of a singleton, `Submodule.span R {v}`.  This is\n  `\\span`, not the same as the scalar multiplication `\u2022`/`\\bub`.\n\n-/\n\nassert_not_exists Field\n\nvariable {R R\u2082 K M M\u2082 V S : Type*}\n\nnamespace Submodule\n\nopen Function Set\n\nopen Pointwise\n\nsection AddCommMonoid\n\nvariable [Semiring R] [AddCommMonoid M] [Module R M]\nvariable {x : M} (p p' : Submodule R M)\nvariable [Semiring R\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082}\nvariable [AddCommMonoid M\u2082] [Module R\u2082 M\u2082]\nvariable {F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082]\n\nsection\n\nvariable (R)\n\n/-- The span of a set `s \u2286 M` is the smallest submodule of M that contains `s`. -/\ndef span (s : Set M) : Submodule R M :=\n  sInf { p | s \u2286 p }\n\nvariable {R}\n\n-- Porting note: renamed field to `principal'` and added `principal` to fix explicit argument\n/-- An `R`-submodule of `M` is principal if it is generated by one element. -/\n@[mk_iff]\nclass IsPrincipal (S : Submodule R M) : Prop where\n  principal' : \u2203 a, S = span R {a}\n\ntheorem IsPrincipal.principal (S : Submodule R M) [S.IsPrincipal] :\n    \u2203 a, S = span R {a} :=\n  Submodule.IsPrincipal.principal'\n\nend\n\nvariable {s t : Set M}\n\ntheorem mem_span : x \u2208 span R s \u2194 \u2200 p : Submodule R M, s \u2286 p \u2192 x \u2208 p :=\n  mem_iInter\u2082\n\n@[aesop safe 20 apply (rule_sets := [SetLike])]\ntheorem subset_span : s \u2286 span R s := fun _ h => mem_span.2 fun _ hp => hp h\n\ntheorem span_le {p} : span R s \u2264 p \u2194 s \u2286 p :=\n  \u27e8Subset.trans subset_span, fun ss _ h => mem_span.1 h _ ss\u27e9\n\n@[gcongr] theorem span_mono (h : s \u2286 t) : span R s \u2264 span R t :=\n  span_le.2 <| Subset.trans h subset_span\n\ntheorem span_monotone : Monotone (span R : Set M \u2192 Submodule R M) := fun _ _ => span_mono\n\ntheorem span_eq_of_le (h\u2081 : s \u2286 p) (h\u2082 : p \u2264 span R s) : span R s = p :=\n  le_antisymm (span_le.2 h\u2081) h\u2082\n\ntheorem span_eq : span R (p : Set M) = p :=\n  span_eq_of_le _ (Subset.refl _) subset_span\n\ntheorem span_eq_span (hs : s \u2286 span R t) (ht : t \u2286 span R s) : span R s = span R t :=\n  le_antisymm (span_le.2 hs) (span_le.2 ht)\n\n/-- A version of `Submodule.span_eq` for subobjects closed under addition and scalar multiplication\nand containing zero. In general, this should not be used directly, but can be used to quickly\ngenerate proofs for specific types of subobjects. -/\nlemma coe_span_eq_self [SetLike S M] [AddSubmonoidClass S M] [SMulMemClass S R M] (s : S) :\n    (span R (s : Set M) : Set M) = s := by\n  refine le_antisymm ?_ subset_span\n  let s' : Submodule R M :=\n    { carrier := s\n      add_mem' := add_mem\n      zero_mem' := zero_mem _\n      smul_mem' := SMulMemClass.smul_mem }\n  exact span_le (p := s') |>.mpr le_rfl\n\n@[simp]\ntheorem span_insert_zero : span R (insert (0 : M) s) = span R s := by\n  refine le_antisymm ?_ (Submodule.span_mono (Set.subset_insert 0 s))\n  rw [span_le, Set.insert_subset_iff]\n  exact \u27e8by simp only [SetLike.mem_coe, Submodule.zero_mem], Submodule.subset_span\u27e9\n\ntheorem closure_subset_span {s : Set M} : (AddSubmonoid.closure s : Set M) \u2286 span R s :=\n  (@AddSubmonoid.closure_le _ _ _ (span R s).toAddSubmonoid).mpr subset_span\n\ntheorem closure_le_toAddSubmonoid_span {s : Set M} :\n    AddSubmonoid.closure s \u2264 (span R s).toAddSubmonoid :=\n  closure_subset_span\n\n@[simp]\ntheorem span_closure {s : Set M} : span R (AddSubmonoid.closure s : Set M) = span R s :=\n  le_antisymm (span_le.mpr closure_subset_span) (span_mono AddSubmonoid.subset_closure)\n\n/-- An induction principle for span membership. If `p` holds for 0 and all elements of `s`, and is\npreserved under addition and scalar multiplication, then `p` holds for all elements of the span of\n`s`. -/\n@[elab_as_elim]\ntheorem span_induction {p : (x : M) \u2192 x \u2208 span R s \u2192 Prop}\n    (mem : \u2200 (x) (h : x \u2208 s), p x (subset_span h))\n    (zero : p 0 (Submodule.zero_mem _))\n    (add : \u2200 x y hx hy, p x hx \u2192 p y hy \u2192 p (x + y) (Submodule.add_mem _ \u2039_\u203a \u2039_\u203a))\n    (smul : \u2200 (a : R) (x hx), p x hx \u2192 p (a \u2022 x) (Submodule.smul_mem _ _ \u2039_\u203a)) {x}\n    (hx : x \u2208 span R s) : p x hx := by\n  let p : Submodule R M :=\n    { carrier := { x | \u2203 hx, p x hx }\n      add_mem' := fun \u27e8_, hpx\u27e9 \u27e8_, hpy\u27e9 \u21a6 \u27e8_, add _ _ _ _ hpx hpy\u27e9\n      zero_mem' := \u27e8_, zero\u27e9\n      smul_mem' := fun r \u21a6 fun \u27e8_, hpx\u27e9 \u21a6 \u27e8_, smul r _ _ hpx\u27e9 }\n  exact span_le (p := p) |>.mpr (fun y hy \u21a6 \u27e8subset_span hy, mem y hy\u27e9) hx |>.elim fun _ \u21a6 id\n\n@[deprecated span_induction (since := \"2024-10-10\")]\nalias span_induction' := span_induction\n\n/-- An induction principle for span membership. This is a version of `Submodule.span_induction`\nfor binary predicates. -/\ntheorem span_induction\u2082 {N : Type*} [AddCommMonoid N] [Module R N] {t : Set N}\n    {p : (x : M) \u2192 (y : N) \u2192 x \u2208 span R s \u2192 y \u2208 span R t \u2192 Prop}\n    (mem_mem : \u2200 (x) (y) (hx : x \u2208 s) (hy : y \u2208 t), p x y (subset_span hx) (subset_span hy))\n    (zero_left : \u2200 y hy, p 0 y (zero_mem _) hy) (zero_right : \u2200 x hx, p x 0 hx (zero_mem _))\n    (add_left : \u2200 x y z hx hy hz, p x z hx hz \u2192 p y z hy hz \u2192 p (x + y) z (add_mem hx hy) hz)\n    (add_right : \u2200 x y z hx hy hz, p x y hx hy \u2192 p x z hx hz \u2192 p x (y + z) hx (add_mem hy hz))\n    (smul_left : \u2200 (r : R) x y hx hy, p x y hx hy \u2192 p (r \u2022 x) y (smul_mem _ r hx) hy)\n    (smul_right : \u2200 (r : R) x y hx hy, p x y hx hy \u2192 p x (r \u2022 y) hx (smul_mem _ r hy))\n    {a : M} {b : N} (ha : a \u2208 Submodule.span R s)\n    (hb : b \u2208 Submodule.span R t) : p a b ha hb := by\n  induction hb using span_induction with\n  | mem z hz => induction ha using span_induction with\n    | mem _ h => exact mem_mem _ _ h hz\n    | zero => exact zero_left _ _\n    | add _ _ _ _ h\u2081 h\u2082 => exact add_left _ _ _ _ _ _ h\u2081 h\u2082\n    | smul _ _ _ h => exact smul_left _ _ _ _ _ h\n  | zero => exact zero_right a ha\n  | add _ _ _ _ h\u2081 h\u2082 => exact add_right _ _ _ _ _ _ h\u2081 h\u2082\n  | smul _ _ _ h => exact smul_right _ _ _ _ _ h\n\nopen AddSubmonoid in\ntheorem span_eq_closure {s : Set M} : (span R s).toAddSubmonoid = closure (@univ R \u2022 s) := by\n  refine le_antisymm (fun x (hx : x \u2208 span R s) \u21a6 ?of_mem_span) (fun x hx \u21a6 ?of_mem_closure)\n  case of_mem_span =>\n    induction hx using span_induction with\n    | mem x hx => exact subset_closure \u27e81, trivial, x, hx, one_smul R x\u27e9\n    | zero => exact zero_mem _\n    | add _ _ _ _ h\u2081 h\u2082 => exact add_mem h\u2081 h\u2082\n    | smul r\u2081 y _h hy =>\n      clear _h\n      induction hy using AddSubmonoid.closure_induction with\n      | mem _ h =>\n        obtain \u27e8r\u2082, -, x, hx, rfl\u27e9 := h\n        exact subset_closure \u27e8r\u2081 * r\u2082, trivial, x, hx, mul_smul ..\u27e9\n      | one => simpa only [smul_zero] using zero_mem _\n      | mul _ _ _ _ h\u2081 h\u2082 => simpa only [smul_add] using add_mem h\u2081 h\u2082\n  case of_mem_closure =>\n    refine closure_le.2 ?_ hx\n    rintro - \u27e8r, -, x, hx, rfl\u27e9\n    exact smul_mem _ _ (subset_span hx)\n\nopen AddSubmonoid in\n/-- A variant of `span_induction` that combines `\u2200 x \u2208 s, p x` and `\u2200 r x, p x \u2192 p (r \u2022 x)`\ninto a single condition `\u2200 r, \u2200 x \u2208 s, p (r \u2022 x)`, which can be easier to verify. -/\n@[elab_as_elim]\ntheorem closure_induction {p : (x : M) \u2192 x \u2208 span R s \u2192 Prop}\n    (zero : p 0 (Submodule.zero_mem _))\n    (add : \u2200 x y hx hy, p x hx \u2192 p y hy \u2192 p (x + y) (Submodule.add_mem _ \u2039_\u203a \u2039_\u203a))\n    (smul_mem : \u2200 (r x) (h : x \u2208 s), p (r \u2022 x) (Submodule.smul_mem _ _ <| subset_span h)) {x}\n    (hx : x \u2208 span R s) : p x hx := by\n  have key {v} : v \u2208 span R s \u2194 v \u2208 closure (@univ R \u2022 s) := by simp [\u2190 span_eq_closure]\n  refine AddSubmonoid.closure_induction (p := fun x hx \u21a6 p x (key.mpr hx))\n    ?_ zero (by simpa only [key] using add) (key.mp hx)\n  rintro - \u27e8r, -, x, hx, rfl\u27e9\n  exact smul_mem r x hx\n\n@[deprecated closure_induction (since := \"2024-10-10\")]\nalias closure_induction' := closure_induction\n\n@[simp]\ntheorem span_span_coe_preimage : span R (((\u2191) : span R s \u2192 M) \u207b\u00b9' s) = \u22a4 :=\n  eq_top_iff.2 fun x _ \u21a6 Subtype.recOn x fun _ hx' \u21a6\n    span_induction (fun _ h \u21a6 subset_span h) (zero_mem _) (fun _ _ _ _ \u21a6 add_mem)\n      (fun _ _ _ \u21a6 smul_mem _ _) hx'\n\n@[simp]\nlemma span_setOf_mem_eq_top :\n    span R {x : span R s | (x : M) \u2208 s} = \u22a4 :=\n  span_span_coe_preimage\n\ntheorem span_nat_eq_addSubmonoid_closure (s : Set M) :\n    (span \u2115 s).toAddSubmonoid = AddSubmonoid.closure s := by\n  refine Eq.symm (AddSubmonoid.closure_eq_of_le subset_span ?_)\n  apply (OrderIso.to_galoisConnection (AddSubmonoid.toNatSubmodule (M := M)).symm).l_le\n     (a := span \u2115 s) (b := AddSubmonoid.closure s)\n  rw [span_le]\n  exact AddSubmonoid.subset_closure\n\n@[simp]\ntheorem span_nat_eq (s : AddSubmonoid M) : (span \u2115 (s : Set M)).toAddSubmonoid = s := by\n  rw [span_nat_eq_addSubmonoid_closure, s.closure_eq]\n\ntheorem span_int_eq_addSubgroup_closure {M : Type*} [AddCommGroup M] (s : Set M) :\n    (span \u2124 s).toAddSubgroup = AddSubgroup.closure s :=\n  Eq.symm <|\n    AddSubgroup.closure_eq_of_le _ subset_span fun _ hx =>\n      span_induction (fun _ hx => AddSubgroup.subset_closure hx) (AddSubgroup.zero_mem _)\n        (fun _ _ _ _ => AddSubgroup.add_mem _) (fun _ _ _ _ => AddSubgroup.zsmul_mem _ \u2039_\u203a _) hx\n\n@[simp]\ntheorem span_int_eq {M : Type*} [AddCommGroup M] (s : AddSubgroup M) :\n    (span \u2124 (s : Set M)).toAddSubgroup = s := by rw [span_int_eq_addSubgroup_closure, s.closure_eq]\n\nsection\n\nvariable (R M)\n\n/-- `span` forms a Galois insertion with the coercion from submodule to set. -/\nprotected def gi : GaloisInsertion (@span R M _ _ _) (\u2191) where\n  choice s _ := span R s\n  gc _ _ := span_le\n  le_l_u _ := subset_span\n  choice_eq _ _ := rfl\n\nend\n\n@[simp]\ntheorem span_empty : span R (\u2205 : Set M) = \u22a5 :=\n  (Submodule.gi R M).gc.l_bot\n\n@[simp]\ntheorem span_univ : span R (univ : Set M) = \u22a4 :=\n  eq_top_iff.2 <| SetLike.le_def.2 <| subset_span\n\ntheorem span_union (s t : Set M) : span R (s \u222a t) = span R s \u2294 span R t :=\n  (Submodule.gi R M).gc.l_sup\n\ntheorem span_iUnion {\u03b9} (s : \u03b9 \u2192 Set M) : span R (\u22c3 i, s i) = \u2a06 i, span R (s i) :=\n  (Submodule.gi R M).gc.l_iSup\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\ntheorem span_iUnion\u2082 {\u03b9} {\u03ba : \u03b9 \u2192 Sort*} (s : \u2200 i, \u03ba i \u2192 Set M) :\n    span R (\u22c3 (i) (j), s i j) = \u2a06 (i) (j), span R (s i j) :=\n  (Submodule.gi R M).gc.l_iSup\u2082\n\ntheorem span_attach_biUnion [DecidableEq M] {\u03b1 : Type*} (s : Finset \u03b1) (f : s \u2192 Finset M) :\n    span R (s.attach.biUnion f : Set M) = \u2a06 x, span R (f x) := by simp [span_iUnion]\n\ntheorem sup_span : p \u2294 span R s = span R (p \u222a s) := by rw [Submodule.span_union, p.span_eq]\n\ntheorem span_sup : span R s \u2294 p = span R (s \u222a p) := by rw [Submodule.span_union, p.span_eq]\n\nnotation:1000\n  /- Note that the character `\u2219` U+2219 used below is different from the scalar multiplication\ncharacter `\u2022` U+2022. -/\nR \" \u2219 \" x => span R (singleton x)\n\ntheorem span_eq_iSup_of_singleton_spans (s : Set M) : span R s = \u2a06 x \u2208 s, R \u2219 x := by\n  simp only [\u2190 span_iUnion, Set.biUnion_of_singleton s]\n\ntheorem span_range_eq_iSup {\u03b9 : Sort*} {v : \u03b9 \u2192 M} : span R (range v) = \u2a06 i, R \u2219 v i := by\n  rw [span_eq_iSup_of_singleton_spans, iSup_range]\n\ntheorem span_smul_le (s : Set M) (r : R) : span R (r \u2022 s) \u2264 span R s := by\n  rw [span_le]\n  rintro _ \u27e8x, hx, rfl\u27e9\n  exact smul_mem (span R s) r (subset_span hx)\n\ntheorem subset_span_trans {U V W : Set M} (hUV : U \u2286 Submodule.span R V)\n    (hVW : V \u2286 Submodule.span R W) : U \u2286 Submodule.span R W :=\n  (Submodule.gi R M).gc.le_u_l_trans hUV hVW\n\n@[simp]\ntheorem coe_iSup_of_directed {\u03b9} [Nonempty \u03b9] (S : \u03b9 \u2192 Submodule R M)\n    (H : Directed (\u00b7 \u2264 \u00b7) S) : ((iSup S : Submodule R M) : Set M) = \u22c3 i, S i :=\n  let s : Submodule R M :=\n    { __ := AddSubmonoid.copy _ _ (AddSubmonoid.coe_iSup_of_directed H).symm\n      smul_mem' := fun r _ hx \u21a6 have \u27e8i, hi\u27e9 := Set.mem_iUnion.mp hx\n        Set.mem_iUnion.mpr \u27e8i, (S i).smul_mem' r hi\u27e9 }\n  have : iSup S = s := le_antisymm\n    (iSup_le fun i \u21a6 le_iSup (fun i \u21a6 (S i : Set M)) i) (Set.iUnion_subset fun _ \u21a6 le_iSup S _)\n  this.symm \u25b8 rfl\n\n@[simp]\ntheorem mem_iSup_of_directed {\u03b9} [Nonempty \u03b9] (S : \u03b9 \u2192 Submodule R M) (H : Directed (\u00b7 \u2264 \u00b7) S) {x} :\n    x \u2208 iSup S \u2194 \u2203 i, x \u2208 S i := by\n  rw [\u2190 SetLike.mem_coe, coe_iSup_of_directed S H, mem_iUnion]\n  rfl\n\ntheorem mem_sSup_of_directed {s : Set (Submodule R M)} {z} (hs : s.Nonempty)\n    (hdir : DirectedOn (\u00b7 \u2264 \u00b7) s) : z \u2208 sSup s \u2194 \u2203 y \u2208 s, z \u2208 y := by\n  have : Nonempty s := hs.to_subtype\n  simp only [sSup_eq_iSup', mem_iSup_of_directed _ hdir.directed_val, SetCoe.exists, Subtype.coe_mk,\n    exists_prop]\n\n@[norm_cast, simp]\ntheorem coe_iSup_of_chain (a : \u2115 \u2192o Submodule R M) : (\u2191(\u2a06 k, a k) : Set M) = \u22c3 k, (a k : Set M) :=\n  coe_iSup_of_directed a a.monotone.directed_le\n\n@[simp]\ntheorem mem_iSup_of_chain (a : \u2115 \u2192o Submodule R M) (m : M) : (m \u2208 \u2a06 k, a k) \u2194 \u2203 k, m \u2208 a k :=\n  mem_iSup_of_directed a a.monotone.directed_le\n\nsection\n\nvariable {p p'}\n\ntheorem mem_sup : x \u2208 p \u2294 p' \u2194 \u2203 y \u2208 p, \u2203 z \u2208 p', y + z = x :=\n  \u27e8fun h => by\n    rw [\u2190 span_eq p, \u2190 span_eq p', \u2190 span_union] at h\n    refine span_induction ?_ ?_ ?_ ?_ h\n    \u00b7 rintro y (h | h)\n      \u00b7 exact \u27e8y, h, 0, by simp, by simp\u27e9\n      \u00b7 exact \u27e80, by simp, y, h, by simp\u27e9\n    \u00b7 exact \u27e80, by simp, 0, by simp\u27e9\n    \u00b7 rintro _ _ - - \u27e8y\u2081, hy\u2081, z\u2081, hz\u2081, rfl\u27e9 \u27e8y\u2082, hy\u2082, z\u2082, hz\u2082, rfl\u27e9\n      exact \u27e8_, add_mem hy\u2081 hy\u2082, _, add_mem hz\u2081 hz\u2082, by\n        rw [add_assoc, add_assoc, \u2190 add_assoc y\u2082, \u2190 add_assoc z\u2081, add_comm y\u2082]\u27e9\n    \u00b7 rintro a - _ \u27e8y, hy, z, hz, rfl\u27e9\n      exact \u27e8_, smul_mem _ a hy, _, smul_mem _ a hz, by simp [smul_add]\u27e9, by\n    rintro \u27e8y, hy, z, hz, rfl\u27e9\n    exact add_mem ((le_sup_left : p \u2264 p \u2294 p') hy) ((le_sup_right : p' \u2264 p \u2294 p') hz)\u27e9\n\ntheorem mem_sup' : x \u2208 p \u2294 p' \u2194 \u2203 (y : p) (z : p'), (y : M) + z = x :=\n  mem_sup.trans <| by simp only [Subtype.exists, exists_prop]\n\nlemma exists_add_eq_of_codisjoint (h : Codisjoint p p') (x : M) :\n    \u2203 y \u2208 p, \u2203 z \u2208 p', y + z = x := by\n  suffices x \u2208 p \u2294 p' by exact Submodule.mem_sup.mp this\n  simpa only [h.eq_top] using Submodule.mem_top\n\nvariable (p p')\n\ntheorem coe_sup : \u2191(p \u2294 p') = (p + p' : Set M) := by\n  ext\n  rw [SetLike.mem_coe, mem_sup, Set.mem_add]\n  simp\n\ntheorem sup_toAddSubmonoid : (p \u2294 p').toAddSubmonoid = p.toAddSubmonoid \u2294 p'.toAddSubmonoid := by\n  ext x\n  rw [mem_toAddSubmonoid, mem_sup, AddSubmonoid.mem_sup]\n  rfl\n\nend\n\ntheorem mem_span_singleton_self (x : M) : x \u2208 R \u2219 x :=\n  subset_span rfl\n\ntheorem nontrivial_span_singleton {x : M} (h : x \u2260 0) : Nontrivial (R \u2219 x) :=\n  \u27e8by\n    use 0, \u27e8x, Submodule.mem_span_singleton_self x\u27e9\n    intro H\n    rw [eq_comm, Submodule.mk_eq_zero] at H\n    exact h H\u27e9\n\ntheorem mem_span_singleton {y : M} : (x \u2208 R \u2219 y) \u2194 \u2203 a : R, a \u2022 y = x :=\n  \u27e8fun h => by\n    refine span_induction ?_ ?_ ?_ ?_ h\n    \u00b7 rintro y (rfl | \u27e8\u27e8_\u27e9\u27e9)\n      exact \u27e81, by simp\u27e9\n    \u00b7 exact \u27e80, by simp\u27e9\n    \u00b7 rintro _ _ - - \u27e8a, rfl\u27e9 \u27e8b, rfl\u27e9\n      exact \u27e8a + b, by simp [add_smul]\u27e9\n    \u00b7 rintro a _ - \u27e8b, rfl\u27e9\n      exact \u27e8a * b, by simp [smul_smul]\u27e9, by\n    rintro \u27e8a, y, rfl\u27e9; exact smul_mem _ _ (subset_span <| by simp)\u27e9\n\ntheorem le_span_singleton_iff {s : Submodule R M} {v\u2080 : M} :\n    (s \u2264 R \u2219 v\u2080) \u2194 \u2200 v \u2208 s, \u2203 r : R, r \u2022 v\u2080 = v := by simp_rw [SetLike.le_def, mem_span_singleton]\n\nvariable (R)\n\ntheorem span_singleton_eq_top_iff (x : M) : (R \u2219 x) = \u22a4 \u2194 \u2200 v, \u2203 r : R, r \u2022 x = v := by\n  rw [eq_top_iff, le_span_singleton_iff]\n  tauto\n\n@[simp]\ntheorem span_zero_singleton : (R \u2219 (0 : M)) = \u22a5 := by\n  ext\n  simp [mem_span_singleton, eq_comm]\n\ntheorem span_singleton_eq_range (y : M) : \u2191(R \u2219 y) = range ((\u00b7 \u2022 y) : R \u2192 M) :=\n  Set.ext fun _ => mem_span_singleton\n\ntheorem span_singleton_smul_le {S} [Monoid S] [SMul S R] [MulAction S M] [IsScalarTower S R M]\n    (r : S) (x : M) : (R \u2219 r \u2022 x) \u2264 R \u2219 x := by\n  rw [span_le, Set.singleton_subset_iff, SetLike.mem_coe]\n  exact smul_of_tower_mem _ _ (mem_span_singleton_self _)\n\ntheorem span_singleton_group_smul_eq {G} [Group G] [SMul G R] [MulAction G M] [IsScalarTower G R M]\n    (g : G) (x : M) : (R \u2219 g \u2022 x) = R \u2219 x := by\n  refine le_antisymm (span_singleton_smul_le R g x) ?_\n  convert span_singleton_smul_le R g\u207b\u00b9 (g \u2022 x)\n  exact (inv_smul_smul g x).symm\n\nvariable {R}\n\ntheorem span_singleton_smul_eq {r : R} (hr : IsUnit r) (x : M) : (R \u2219 r \u2022 x) = R \u2219 x := by\n  lift r to R\u02e3 using hr\n  rw [\u2190 Units.smul_def]\n  exact span_singleton_group_smul_eq R r x\n\ntheorem mem_span_singleton_trans {x y z : M} (hxy : x \u2208 R \u2219 y) (hyz : y \u2208 R \u2219 z) : x \u2208 R \u2219 z := by\n  rw [\u2190 SetLike.mem_coe, \u2190 singleton_subset_iff] at *\n  exact Submodule.subset_span_trans hxy hyz\n\ntheorem span_insert (x) (s : Set M) : span R (insert x s) = (R \u2219 x) \u2294 span R s := by\n  rw [insert_eq, span_union]\n\ntheorem span_insert_eq_span (h : x \u2208 span R s) : span R (insert x s) = span R s :=\n  span_eq_of_le _ (Set.insert_subset_iff.mpr \u27e8h, subset_span\u27e9) (span_mono <| subset_insert _ _)\n\ntheorem span_span : span R (span R s : Set M) = span R s :=\n  span_eq _\n\ntheorem mem_span_insert {y} :\n    x \u2208 span R (insert y s) \u2194 \u2203 a : R, \u2203 z \u2208 span R s, x = a \u2022 y + z := by\n  simp [span_insert, mem_sup, mem_span_singleton, eq_comm (a := x)]\n\ntheorem mem_span_pair {x y z : M} :\n    z \u2208 span R ({x, y} : Set M) \u2194 \u2203 a b : R, a \u2022 x + b \u2022 y = z := by\n  simp_rw [mem_span_insert, mem_span_singleton, exists_exists_eq_and, eq_comm]\n\ntheorem span_eq_bot : span R (s : Set M) = \u22a5 \u2194 \u2200 x \u2208 s, (x : M) = 0 :=\n  eq_bot_iff.trans\n    \u27e8fun H _ h => (mem_bot R).1 <| H <| subset_span h, fun H =>\n      span_le.2 fun x h => (mem_bot R).2 <| H x h\u27e9\n\n@[simp]\ntheorem span_singleton_eq_bot : (R \u2219 x) = \u22a5 \u2194 x = 0 :=\n  span_eq_bot.trans <| by simp\n\n@[simp]\ntheorem span_zero : span R (0 : Set M) = \u22a5 := by rw [\u2190 singleton_zero, span_singleton_eq_bot]\n\n@[simp]\ntheorem span_singleton_le_iff_mem (m : M) (p : Submodule R M) : (R \u2219 m) \u2264 p \u2194 m \u2208 p := by\n  rw [span_le, singleton_subset_iff, SetLike.mem_coe]\n\ntheorem iSup_span {\u03b9 : Sort*} (p : \u03b9 \u2192 Set M) : \u2a06 i, span R (p i) = span R (\u22c3 i, p i) :=\n  le_antisymm (iSup_le fun i => span_mono <| subset_iUnion _ i) <|\n    span_le.mpr <| iUnion_subset fun i _ hm => mem_iSup_of_mem i <| subset_span hm\n\ntheorem iSup_eq_span {\u03b9 : Sort*} (p : \u03b9 \u2192 Submodule R M) : \u2a06 i, p i = span R (\u22c3 i, \u2191(p i)) := by\n  simp_rw [\u2190 iSup_span, span_eq]\n\n/-- A submodule is equal to the supremum of the spans of the submodule's nonzero elements. -/\ntheorem submodule_eq_sSup_le_nonzero_spans (p : Submodule R M) :\n    p = sSup { T : Submodule R M | \u2203 m \u2208 p, m \u2260 0 \u2227 T = span R {m} } := by\n  let S := { T : Submodule R M | \u2203 m \u2208 p, m \u2260 0 \u2227 T = span R {m} }\n  apply le_antisymm\n  \u00b7 intro m hm\n    by_cases h : m = 0\n    \u00b7 rw [h]\n      simp\n    \u00b7 exact @le_sSup _ _ S _ \u27e8m, \u27e8hm, \u27e8h, rfl\u27e9\u27e9\u27e9 m (mem_span_singleton_self m)\n  \u00b7 rw [sSup_le_iff]\n    rintro S \u27e8_, \u27e8_, \u27e8_, rfl\u27e9\u27e9\u27e9\n    rwa [span_singleton_le_iff_mem]\n\ntheorem lt_sup_iff_not_mem {I : Submodule R M} {a : M} : (I < I \u2294 R \u2219 a) \u2194 a \u2209 I := by simp\n\ntheorem mem_iSup {\u03b9 : Sort*} (p : \u03b9 \u2192 Submodule R M) {m : M} :\n    (m \u2208 \u2a06 i, p i) \u2194 \u2200 N, (\u2200 i, p i \u2264 N) \u2192 m \u2208 N := by\n  rw [\u2190 span_singleton_le_iff_mem, le_iSup_iff]\n  simp only [span_singleton_le_iff_mem]\n\ntheorem mem_sSup {s : Set (Submodule R M)} {m : M} :\n    (m \u2208 sSup s) \u2194 \u2200 N, (\u2200 p \u2208 s, p \u2264 N) \u2192 m \u2208 N := by\n  simp_rw [sSup_eq_iSup, Submodule.mem_iSup, iSup_le_iff]\n\nsection\n\n/-- For every element in the span of a set, there exists a finite subset of the set\nsuch that the element is contained in the span of the subset. -/\ntheorem mem_span_finite_of_mem_span {S : Set M} {x : M} (hx : x \u2208 span R S) :\n    \u2203 T : Finset M, \u2191T \u2286 S \u2227 x \u2208 span R (T : Set M) := by\n  classical\n  refine span_induction (fun x hx => ?_) ?_ ?_ ?_ hx\n  \u00b7 refine \u27e8{x}, ?_, ?_\u27e9\n    \u00b7 rwa [Finset.coe_singleton, Set.singleton_subset_iff]\n    \u00b7 rw [Finset.coe_singleton]\n      exact Submodule.mem_span_singleton_self x\n  \u00b7 use \u2205\n    simp\n  \u00b7 rintro x y - - \u27e8X, hX, hxX\u27e9 \u27e8Y, hY, hyY\u27e9\n    refine \u27e8X \u222a Y, ?_, ?_\u27e9\n    \u00b7 rw [Finset.coe_union]\n      exact Set.union_subset hX hY\n    rw [Finset.coe_union, span_union, mem_sup]\n    exact \u27e8x, hxX, y, hyY, rfl\u27e9\n  \u00b7 rintro a x - \u27e8T, hT, h2\u27e9\n    exact \u27e8T, hT, smul_mem _ _ h2\u27e9\n\nend\n\nend AddCommMonoid\n\nsection AddCommGroup\n\nvariable [Ring R] [AddCommGroup M] [Module R M] {\u03b9 : Type*} [DecidableEq \u03b9] {i j : \u03b9}\n\nlemma sup_toAddSubgroup (p p' : Submodule R M) :\n    (p \u2294 p').toAddSubgroup = p.toAddSubgroup \u2294 p'.toAddSubgroup := by\n  ext x\n  rw [mem_toAddSubgroup, mem_sup, AddSubgroup.mem_sup]\n  rfl\n\ntheorem mem_span_insert' {x y} {s : Set M} :\n    x \u2208 span R (insert y s) \u2194 \u2203 a : R, x + a \u2022 y \u2208 span R s := by\n  rw [mem_span_insert]; constructor\n  \u00b7 rintro \u27e8a, z, hz, rfl\u27e9\n    exact \u27e8-a, by simp [hz, add_assoc]\u27e9\n  \u00b7 rintro \u27e8a, h\u27e9\n    exact \u27e8-a, _, h, by simp [add_comm, add_left_comm]\u27e9\n\nlemma span_range_update_add_smul (hij : i \u2260 j) (v : \u03b9 \u2192 M) (r : R) :\n    span R (Set.range (Function.update v j (v j + r \u2022 v i))) = span R (Set.range v) := by\n  refine le_antisymm ?_ ?_ <;> simp only [span_le, Set.range_subset_iff, SetLike.mem_coe] <;>\n    intro k <;> obtain rfl | hjk := eq_or_ne j k\n  \u00b7 rw [update_self]\n    exact add_mem (subset_span \u27e8j, rfl\u27e9) <| smul_mem _ _ <| subset_span \u27e8i, rfl\u27e9\n  \u00b7 exact subset_span \u27e8k, (update_of_ne hjk.symm ..).symm\u27e9\n  \u00b7 nth_rw 2 [\u2190 add_sub_cancel_right (v j) (r \u2022 v i)]\n    exact sub_mem (subset_span \u27e8j, update_self ..\u27e9)\n      (smul_mem _ _ (subset_span \u27e8i, update_of_ne hij ..\u27e9))\n  \u00b7 exact subset_span \u27e8k, update_of_ne hjk.symm ..\u27e9\n\n", "theoremStatement": "lemma span_range_update_sub_smul (hij : i \u2260 j) (v : \u03b9 \u2192 M) (r : R) :\n    span R (Set.range (Function.update v j (v j - r \u2022 v i))) = span R (Set.range v) ", "theoremName": "Submodule.span_range_update_sub_smul", "fileCreated": {"commit": "9127890bca642d6f8fee0ab73caa6134ed8890a3", "date": "2024-11-15"}, "theoremCreated": {"commit": "3f703ecb9714a08b92a17f9c3c19ffc32343fede", "date": "2024-12-29"}, "file": "mathlib/Mathlib/LinearAlgebra/Span/Defs.lean", "module": "Mathlib.LinearAlgebra.Span.Defs", "jsonFile": "Mathlib.LinearAlgebra.Span.Defs.jsonl", "positionMetadata": {"lineInFile": 547, "tokenPositionInFile": 21405, "theoremPositionInFile": 78}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 40, "numPremises": 53}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [sub_eq_add_neg, \u2190 neg_smul, span_range_update_add_smul hij]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 71}}
{"srcContext": "/-\nCopyright (c) 2020 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\nimport Mathlib.RingTheory.NonUnitalSubsemiring.Defs\n\n/-!\n# Bundled subsemirings\n\nWe define bundled subsemirings and some standard constructions: `subtype` and `inclusion`\nring homomorphisms.\n-/\n\n\nuniverse u v w\n\nsection AddSubmonoidWithOneClass\n\n/-- `AddSubmonoidWithOneClass S R` says `S` is a type of subsets `s \u2264 R` that contain `0`, `1`,\nand are closed under `(+)` -/\nclass AddSubmonoidWithOneClass (S : Type*) (R : outParam Type*) [AddMonoidWithOne R]\n  [SetLike S R] extends AddSubmonoidClass S R, OneMemClass S R : Prop\n\nvariable {S R : Type*} [AddMonoidWithOne R] [SetLike S R] (s : S)\n\n@[aesop safe apply (rule_sets := [SetLike])]\ntheorem natCast_mem [AddSubmonoidWithOneClass S R] (n : \u2115) : (n : R) \u2208 s := by\n  induction n <;> simp [zero_mem, add_mem, one_mem, *]\n\n@[aesop safe apply (rule_sets := [SetLike])]\nlemma ofNat_mem [AddSubmonoidWithOneClass S R] (s : S) (n : \u2115) [n.AtLeastTwo] :\n    ofNat(n) \u2208 s := by\n  rw [\u2190 Nat.cast_ofNat]; exact natCast_mem s n\n\ninstance (priority := 74) AddSubmonoidWithOneClass.toAddMonoidWithOne\n    [AddSubmonoidWithOneClass S R] : AddMonoidWithOne s :=\n  { AddSubmonoidClass.toAddMonoid s with\n    one := \u27e8_, one_mem s\u27e9\n    natCast := fun n => \u27e8n, natCast_mem s n\u27e9\n    natCast_zero := Subtype.ext Nat.cast_zero\n    natCast_succ := fun _ => Subtype.ext (Nat.cast_succ _) }\n\nend AddSubmonoidWithOneClass\n\nvariable {R : Type u} {S : Type v} [NonAssocSemiring R]\n\nsection SubsemiringClass\n\n/-- `SubsemiringClass S R` states that `S` is a type of subsets `s \u2286 R` that\nare both a multiplicative and an additive submonoid. -/\nclass SubsemiringClass (S : Type*) (R : outParam (Type u)) [NonAssocSemiring R]\n  [SetLike S R] extends SubmonoidClass S R, AddSubmonoidClass S R : Prop\n\n-- See note [lower instance priority]\ninstance (priority := 100) SubsemiringClass.addSubmonoidWithOneClass (S : Type*)\n    (R : Type u) {_ : NonAssocSemiring R} [SetLike S R] [h : SubsemiringClass S R] :\n    AddSubmonoidWithOneClass S R :=\n  { h with }\n\ninstance (priority := 100) SubsemiringClass.nonUnitalSubsemiringClass (S : Type*)\n    (R : Type u) [NonAssocSemiring R] [SetLike S R] [SubsemiringClass S R] :\n    NonUnitalSubsemiringClass S R where\n  mul_mem := mul_mem\n\nvariable [SetLike S R] [hSR : SubsemiringClass S R] (s : S)\n\nnamespace SubsemiringClass\n\n-- Prefer subclasses of `NonAssocSemiring` over subclasses of `SubsemiringClass`.\n/-- A subsemiring of a `NonAssocSemiring` inherits a `NonAssocSemiring` structure -/\ninstance (priority := 75) toNonAssocSemiring : NonAssocSemiring s := fast_instance%\n  Subtype.coe_injective.nonAssocSemiring Subtype.val rfl rfl (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) fun _ => rfl\n\ninstance nontrivial [Nontrivial R] : Nontrivial s :=\n  nontrivial_of_ne 0 1 fun H => zero_ne_one (congr_arg Subtype.val H)\n\ninstance noZeroDivisors [NoZeroDivisors R] : NoZeroDivisors s :=\n  Subtype.coe_injective.noZeroDivisors _ rfl fun _ _ => rfl\n\n/-- The natural ring hom from a subsemiring of semiring `R` to `R`. -/\ndef subtype : s \u2192+* R :=\n  { SubmonoidClass.subtype s, AddSubmonoidClass.subtype s with toFun := (\u2191) }\n\n@[simp]\ntheorem coe_subtype : (subtype s : s \u2192 R) = ((\u2191) : s \u2192 R) :=\n  rfl\n\n-- Prefer subclasses of `Semiring` over subclasses of `SubsemiringClass`.\n/-- A subsemiring of a `Semiring` is a `Semiring`. -/\ninstance (priority := 75) toSemiring {R} [Semiring R] [SetLike S R] [SubsemiringClass S R] :\n    Semiring s := fast_instance%\n  Subtype.coe_injective.semiring Subtype.val rfl rfl (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) fun _ => rfl\n\n@[simp, norm_cast]\ntheorem coe_pow {R} [Semiring R] [SetLike S R] [SubsemiringClass S R] (x : s) (n : \u2115) :\n    ((x ^ n : s) : R) = (x : R) ^ n := by\n  induction n with\n  | zero => simp\n  | succ n ih => simp [pow_succ, ih]\n\n/-- A subsemiring of a `CommSemiring` is a `CommSemiring`. -/\ninstance toCommSemiring {R} [CommSemiring R] [SetLike S R] [SubsemiringClass S R] :\n    CommSemiring s := fast_instance%\n  Subtype.coe_injective.commSemiring Subtype.val rfl rfl (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) fun _ => rfl\n\nend SubsemiringClass\n\nend SubsemiringClass\n\nvariable [NonAssocSemiring S]\n\n/-- A subsemiring of a semiring `R` is a subset `s` that is both a multiplicative and an additive\nsubmonoid. -/\nstructure Subsemiring (R : Type u) [NonAssocSemiring R] extends Submonoid R, AddSubmonoid R\n\n/-- Reinterpret a `Subsemiring` as a `Submonoid`. -/\nadd_decl_doc Subsemiring.toSubmonoid\n\n/-- Reinterpret a `Subsemiring` as an `AddSubmonoid`. -/\nadd_decl_doc Subsemiring.toAddSubmonoid\n\nnamespace Subsemiring\n\ninstance : SetLike (Subsemiring R) R where\n  coe s := s.carrier\n  coe_injective' p q h := by cases p; cases q; congr; exact SetLike.coe_injective' h\n\ninstance : SubsemiringClass (Subsemiring R) R where\n  zero_mem := zero_mem'\n  add_mem {s} := AddSubsemigroup.add_mem' s.toAddSubmonoid.toAddSubsemigroup\n  one_mem {s} := Submonoid.one_mem' s.toSubmonoid\n  mul_mem {s} := Subsemigroup.mul_mem' s.toSubmonoid.toSubsemigroup\n\ninitialize_simps_projections Subsemiring (carrier \u2192 coe, as_prefix coe)\n\n/-- Turn a `Subsemiring` into a `NonUnitalSubsemiring` by forgetting that it contains `1`. -/\ndef toNonUnitalSubsemiring (S : Subsemiring R) : NonUnitalSubsemiring R where __ := S\n\n@[simp]\ntheorem mem_toSubmonoid {s : Subsemiring R} {x : R} : x \u2208 s.toSubmonoid \u2194 x \u2208 s :=\n  Iff.rfl\n\n@[simp]\nlemma mem_toNonUnitalSubsemiring {S : Subsemiring R} {x : R} :\n    x \u2208 S.toNonUnitalSubsemiring \u2194 x \u2208 S := .rfl\n\ntheorem mem_carrier {s : Subsemiring R} {x : R} : x \u2208 s.carrier \u2194 x \u2208 s :=\n  Iff.rfl\n\n", "theoremStatement": "@[simp]\nlemma coe_toNonUnitalSubsemiring (S : Subsemiring R) : (S.toNonUnitalSubsemiring : Set R) = S ", "theoremName": "Subsemiring.coe_toNonUnitalSubsemiring", "fileCreated": {"commit": "ddfa45d21fa79757b4bb6bc13e35338db5d9b26c", "date": "2024-11-03"}, "theoremCreated": {"commit": "8b781ec918a891323c20be4ed923133e287d624c", "date": "2025-01-02"}, "file": "mathlib/Mathlib/Algebra/Ring/Subsemiring/Defs.lean", "module": "Mathlib.Algebra.Ring.Subsemiring.Defs", "jsonFile": "Mathlib.Algebra.Ring.Subsemiring.Defs.jsonl", "positionMetadata": {"lineInFile": 154, "tokenPositionInFile": 5741, "theoremPositionInFile": 8}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 9, "numPremises": 11}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "/-\nCopyright (c) 2024 Xavier Roblot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Xavier Roblot\n-/\nimport Mathlib.Analysis.BoxIntegral.UnitPartition\nimport Mathlib.MeasureTheory.Measure.Haar.InnerProductSpace\n\n/-!\n# Covolume of \u2124-lattices\n\nLet `E` be a finite dimensional real vector space.\n\nLet `L` be a `\u2124`-lattice `L` defined as a discrete `\u2124`-submodule of `E` that spans `E` over `\u211d`.\n\n## Main definitions and results\n\n* `ZLattice.covolume`: the covolume of `L` defined as the volume of an arbitrary fundamental\ndomain of `L`.\n\n* `ZLattice.covolume_eq_measure_fundamentalDomain`: the covolume of `L` does not depend on the\nchoice of the fundamental domain of `L`.\n\n* `ZLattice.covolume_eq_det`: if `L` is a lattice in `\u211d^n`, then its covolume is the absolute\nvalue of the determinant of any `\u2124`-basis of `L`.\n\n* `ZLattice.covolume.tendsto_card_div_pow`: Let `s` be a bounded measurable set of `\u03b9 \u2192 \u211d`, then\nthe number of points in `s \u2229 n\u207b\u00b9 \u2022 L` divided by `n ^ card \u03b9` tends to `volume s / covolume L`\nwhen `n : \u2115` tends to infinity. See also `ZLattice.covolume.tendsto_card_div_pow'` for a version\nfor `InnerProductSpace \u211d E` and `ZLattice.covolume.tendsto_card_div_pow''` for the general version.\n\n* `ZLattice.covolume.tendsto_card_le_div`: Let `X` be a cone in `\u03b9 \u2192 \u211d` and let `F : (\u03b9 \u2192 \u211d) \u2192 \u211d`\nbe a function such that `F (c \u2022 x) = c ^ card \u03b9 * F x`. Then the number of points `x \u2208 X` such that\n`F x \u2264 c` divided by `c` tends to `volume {x \u2208 X | F x \u2264 1} / covolume L` when `c : \u211d` tends to\ninfinity. See also `ZLattice.covolume.tendsto_card_le_div'` for a version for\n`InnerProductSpace \u211d E` and `ZLattice.covolume.tendsto_card_le_div''` for the general version.\n\n## Naming convention\n\nSome results are true in the case where the ambient finite dimensional real vector space is the\npi-space `\u03b9 \u2192 \u211d` and in the case where it is an `InnerProductSpace`. We use the following\nconvention: the plain name is for the pi case, for eg. `volume_image_eq_volume_div_covolume`. For\nthe same result in the `InnerProductSpace` case, we add a `prime`, for eg.\n`volume_image_eq_volume_div_covolume'`. When the same result exists in the\ngeneral case, we had two primes, eg. `covolume.tendsto_card_div_pow''`.\n\n-/\n\nnoncomputable section\n\nnamespace ZLattice\n\nopen Submodule MeasureTheory Module MeasureTheory Module ZSpan\n\nsection General\n\nvariable {E : Type*} [NormedAddCommGroup E] [MeasurableSpace E] (L : Submodule \u2124 E)\n\n/-- The covolume of a `\u2124`-lattice is the volume of some fundamental domain; see\n`ZLattice.covolume_eq_volume` for the proof that the volume does not depend on the choice of\nthe fundamental domain. -/\ndef covolume (\u03bc : Measure E := by volume_tac) : \u211d := (addCovolume L E \u03bc).toReal\n\nend General\n\nsection Basic\n\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] [FiniteDimensional \u211d E]\nvariable [MeasurableSpace E] [BorelSpace E]\nvariable (L : Submodule \u2124 E) [DiscreteTopology L] [IsZLattice \u211d L]\nvariable (\u03bc : Measure E := by volume_tac) [Measure.IsAddHaarMeasure \u03bc]\n\ntheorem covolume_eq_measure_fundamentalDomain {F : Set E} (h : IsAddFundamentalDomain L F \u03bc) :\n    covolume L \u03bc = (\u03bc F).toReal := by\n  have : MeasurableVAdd L E := (inferInstance : MeasurableVAdd L.toAddSubgroup E)\n  have : VAddInvariantMeasure L E \u03bc := (inferInstance : VAddInvariantMeasure L.toAddSubgroup E \u03bc)\n  exact congr_arg ENNReal.toReal (h.covolume_eq_volume \u03bc)\n\ntheorem covolume_ne_zero : covolume L \u03bc \u2260 0 := by\n  rw [covolume_eq_measure_fundamentalDomain L \u03bc (isAddFundamentalDomain (Free.chooseBasis \u2124 L) \u03bc),\n    ENNReal.toReal_ne_zero]\n  refine \u27e8measure_fundamentalDomain_ne_zero _, ne_of_lt ?_\u27e9\n  exact Bornology.IsBounded.measure_lt_top (fundamentalDomain_isBounded _)\n\ntheorem covolume_pos : 0 < covolume L \u03bc :=\n  lt_of_le_of_ne ENNReal.toReal_nonneg (covolume_ne_zero L \u03bc).symm\n\ntheorem covolume_comap {F : Type*} [NormedAddCommGroup F] [NormedSpace \u211d F] [FiniteDimensional \u211d F]\n    [MeasurableSpace F] [BorelSpace F] (\u03bd : Measure F := by volume_tac) [Measure.IsAddHaarMeasure \u03bd]\n    {e : F \u2243L[\u211d] E} (he : MeasurePreserving e \u03bd \u03bc) :\n    covolume (ZLattice.comap \u211d L e.toLinearMap) \u03bd = covolume L \u03bc := by\n  rw [covolume_eq_measure_fundamentalDomain _ _ (isAddFundamentalDomain (Free.chooseBasis \u2124 L) \u03bc),\n    covolume_eq_measure_fundamentalDomain _ _ ((isAddFundamentalDomain\n    ((Free.chooseBasis \u2124 L).ofZLatticeComap \u211d L e.toLinearEquiv) \u03bd)), \u2190 he.measure_preimage\n    (fundamentalDomain_measurableSet _).nullMeasurableSet, \u2190 e.image_symm_eq_preimage,\n    \u2190 e.symm.coe_toLinearEquiv, map_fundamentalDomain]\n  congr!\n  ext; simp\n\ntheorem covolume_eq_det_mul_measure {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (b : Basis \u03b9 \u2124 L)\n    (b\u2080 : Basis \u03b9 \u211d E) :\n    covolume L \u03bc = |b\u2080.det ((\u2191) \u2218 b)| * (\u03bc (fundamentalDomain b\u2080)).toReal := by\n  rw [covolume_eq_measure_fundamentalDomain L \u03bc (isAddFundamentalDomain b \u03bc),\n    measure_fundamentalDomain _ _ b\u2080,\n    measure_congr (fundamentalDomain_ae_parallelepiped b\u2080 \u03bc), ENNReal.toReal_mul,\n    ENNReal.toReal_ofReal (by positivity)]\n  congr\n  ext\n  exact b.ofZLatticeBasis_apply \u211d L _\n\ntheorem covolume_eq_det {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (L : Submodule \u2124 (\u03b9 \u2192 \u211d))\n    [DiscreteTopology L] [IsZLattice \u211d L] (b : Basis \u03b9 \u2124 L) :\n    covolume L = |(Matrix.of ((\u2191) \u2218 b)).det| := by\n  rw [covolume_eq_measure_fundamentalDomain L volume (isAddFundamentalDomain b volume),\n    volume_fundamentalDomain, ENNReal.toReal_ofReal (by positivity)]\n  congr\n  ext1\n  exact b.ofZLatticeBasis_apply \u211d L _\n\ntheorem covolume_eq_det_inv {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (L : Submodule \u2124 (\u03b9 \u2192 \u211d))\n    [DiscreteTopology L] [IsZLattice \u211d L] (b : Basis \u03b9 \u2124 L) :\n    covolume L = |(LinearEquiv.det (b.ofZLatticeBasis \u211d L).equivFun : \u211d)|\u207b\u00b9 := by\n  rw [covolume_eq_det L b, \u2190 Pi.basisFun_det_apply, show (((\u2191) : L \u2192 _) \u2218 \u21d1b) =\n    (b.ofZLatticeBasis \u211d) by ext; simp, \u2190 Basis.det_inv, \u2190 abs_inv, Units.val_inv_eq_inv_val,\n    IsUnit.unit_spec, \u2190 Basis.det_basis, LinearEquiv.coe_det]\n  rfl\n\ntheorem volume_image_eq_volume_div_covolume {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9]\n    (L : Submodule \u2124 (\u03b9 \u2192 \u211d)) [DiscreteTopology L] [IsZLattice \u211d L] (b : Basis \u03b9 \u2124 L)\n    {s : Set (\u03b9 \u2192 \u211d)} :\n    volume ((b.ofZLatticeBasis \u211d L).equivFun '' s) = volume s / ENNReal.ofReal (covolume L) := by\n  rw [LinearEquiv.image_eq_preimage, Measure.addHaar_preimage_linearEquiv, LinearEquiv.symm_symm,\n    covolume_eq_det_inv L b, ENNReal.div_eq_inv_mul, ENNReal.ofReal_inv_of_pos\n    (abs_pos.mpr (LinearEquiv.det _).ne_zero), inv_inv, LinearEquiv.coe_det]\n\n/-- A more general version of `ZLattice.volume_image_eq_volume_div_covolume`;\nsee the `Naming conventions` section in the introduction. -/\ntheorem volume_image_eq_volume_div_covolume' {E : Type*} [NormedAddCommGroup E]\n    [InnerProductSpace \u211d E] [FiniteDimensional \u211d E] [MeasurableSpace E] [BorelSpace E]\n    (L : Submodule \u2124 E) [DiscreteTopology L] [IsZLattice \u211d L] {\u03b9 : Type*} [Fintype \u03b9]\n    (b : Basis \u03b9 \u2124 L) {s : Set E} (hs : NullMeasurableSet s) :\n    volume ((b.ofZLatticeBasis \u211d).equivFun '' s) = volume s / ENNReal.ofReal (covolume L) := by\n  classical\n  let e : Fin (finrank \u211d E) \u2243 \u03b9 :=\n    Fintype.equivOfCardEq (by rw [Fintype.card_fin, finrank_eq_card_basis (b.ofZLatticeBasis \u211d)])\n  let f := (EuclideanSpace.equiv \u03b9 \u211d).symm.trans\n    ((stdOrthonormalBasis \u211d E).reindex e).repr.toContinuousLinearEquiv.symm\n  have hf : MeasurePreserving f :=\n    ((stdOrthonormalBasis \u211d E).reindex e).measurePreserving_repr_symm.comp\n      (EuclideanSpace.volume_preserving_measurableEquiv \u03b9).symm\n  rw [\u2190 hf.measure_preimage hs, \u2190 (covolume_comap L volume volume hf),\n    \u2190 volume_image_eq_volume_div_covolume (ZLattice.comap \u211d L f.toLinearMap)\n    (b.ofZLatticeComap \u211d L f.toLinearEquiv), Basis.ofZLatticeBasis_comap,\n    \u2190 f.image_symm_eq_preimage, \u2190 Set.image_comp]\n  simp only [Basis.equivFun_apply, ContinuousLinearEquiv.symm_toLinearEquiv, Basis.map_equivFun,\n    LinearEquiv.symm_symm, Function.comp_apply, LinearEquiv.trans_apply,\n    ContinuousLinearEquiv.coe_toLinearEquiv, ContinuousLinearEquiv.apply_symm_apply]\n\nend Basic\n\nnamespace covolume\n\nsection General\n\nopen Filter Fintype Pointwise Topology BoxIntegral Bornology\n\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]\nvariable {L : Submodule \u2124 E} [DiscreteTopology L] [IsZLattice \u211d L]\nvariable {\u03b9 : Type*} [Fintype \u03b9] (b : Basis \u03b9 \u2124 L)\n\n/-- A version of `ZLattice.covolume.tendsto_card_div_pow` for the general case;\nsee the `Naming convention` section in the introduction. -/\ntheorem tendsto_card_div_pow'' [FiniteDimensional \u211d E] [MeasurableSpace E] [BorelSpace E]\n    {s : Set E} (hs\u2081 : IsBounded s) (hs\u2082 : MeasurableSet s)\n    (hs\u2083 : volume (frontier ((b.ofZLatticeBasis \u211d).equivFun '' s)) = 0):\n    Tendsto (fun n : \u2115 \u21a6 (Nat.card (s \u2229 (n : \u211d)\u207b\u00b9 \u2022 L : Set E) : \u211d) / n ^ card \u03b9)\n      atTop (\ud835\udcdd (volume ((b.ofZLatticeBasis \u211d).equivFun '' s)).toReal) := by\n  refine Tendsto.congr' ?_\n    (tendsto_card_div_pow_atTop_volume ((b.ofZLatticeBasis \u211d).equivFun '' s) ?_ ?_ hs\u2083)\n  \u00b7 filter_upwards [eventually_gt_atTop 0] with n hn\n    congr\n    refine Nat.card_congr <| ((b.ofZLatticeBasis \u211d).equivFun.toEquiv.subtypeEquiv fun x \u21a6 ?_).symm\n    simp_rw [Set.mem_inter_iff, \u2190 b.ofZLatticeBasis_span \u211d, LinearEquiv.coe_toEquiv,\n      Basis.equivFun_apply, Set.mem_image, DFunLike.coe_fn_eq, EmbeddingLike.apply_eq_iff_eq,\n      exists_eq_right, and_congr_right_iff, Set.mem_inv_smul_set_iff\u2080\n      (mod_cast hn.ne' : (n : \u211d) \u2260 0), \u2190 Finsupp.coe_smul, \u2190 LinearEquiv.map_smul, SetLike.mem_coe,\n      Basis.mem_span_iff_repr_mem, Pi.basisFun_repr, implies_true]\n  \u00b7 rw [\u2190 NormedSpace.isVonNBounded_iff \u211d] at hs\u2081 \u22a2\n    exact Bornology.IsVonNBounded.image hs\u2081 ((b.ofZLatticeBasis \u211d).equivFunL : E \u2192L[\u211d] \u03b9 \u2192 \u211d)\n  \u00b7 exact (b.ofZLatticeBasis \u211d).equivFunL.toHomeomorph.toMeasurableEquiv.measurableSet_image.mpr hs\u2082\n\nprivate theorem tendsto_card_le_div''_aux {X : Set E} (hX : \u2200 \u2983x\u2984 \u2983r:\u211d\u2984, x \u2208 X \u2192 0 < r \u2192 r \u2022 x \u2208 X)\n    {F : E \u2192 \u211d} (hF\u2081 : \u2200 x \u2983r : \u211d\u2984, 0 \u2264 r \u2192 F (r \u2022 x) = r ^ card \u03b9 * (F x)) {c : \u211d} (hc : 0 < c) :\n    c \u2022 {x \u2208 X | F x \u2264 1} = {x \u2208 X | F x \u2264 c ^ card \u03b9} := by\n  ext x\n  simp_rw [Set.mem_smul_set_iff_inv_smul_mem\u2080 hc.ne', Set.mem_setOf_eq, hF\u2081 _\n    (inv_pos_of_pos hc).le, inv_pow, inv_mul_le_iff\u2080 (pow_pos hc _), mul_one, and_congr_left_iff]\n  exact fun _ \u21a6 \u27e8fun h \u21a6 (smul_inv_smul\u2080 hc.ne' x) \u25b8 hX h hc, fun h \u21a6 hX h (inv_pos_of_pos hc)\u27e9\n\n/-- A version of `ZLattice.covolume.tendsto_card_le_div` for the general case;\nsee the `Naming conventions` section in the introduction. -/\ntheorem tendsto_card_le_div'' [FiniteDimensional \u211d E] [MeasurableSpace E] [BorelSpace E]\n    [Nonempty \u03b9] {X : Set E} (hX : \u2200 \u2983x\u2984 \u2983r : \u211d\u2984, x \u2208 X \u2192 0 < r \u2192 r \u2022 x \u2208 X)\n    {F : E \u2192 \u211d} (h\u2081 : \u2200 x \u2983r : \u211d\u2984, 0 \u2264 r \u2192  F (r \u2022 x) = r ^ card \u03b9 * (F x))\n    (h\u2082 : IsBounded {x \u2208 X | F x \u2264 1}) (h\u2083 : MeasurableSet {x \u2208 X | F x \u2264 1})\n    (h\u2084 : volume (frontier ((b.ofZLatticeBasis \u211d L).equivFun '' {x | x \u2208 X \u2227 F x \u2264 1})) = 0) :\n    Tendsto (fun c : \u211d \u21a6\n      Nat.card ({x \u2208 X | F x \u2264 c} \u2229 L : Set E) / (c : \u211d))\n        atTop (\ud835\udcdd (volume ((b.ofZLatticeBasis \u211d).equivFun '' {x \u2208 X | F x \u2264 1})).toReal) := by\n\n  refine Tendsto.congr' ?_ <| (tendsto_card_div_pow_atTop_volume'\n      ((b.ofZLatticeBasis \u211d).equivFun '' {x \u2208 X | F x \u2264 1}) ?_ ?_ h\u2084 fun x y hx hy \u21a6 ?_).comp\n        (tendsto_rpow_atTop <| inv_pos.mpr\n          (Nat.cast_pos.mpr card_pos) : Tendsto (fun x \u21a6 x ^ (card \u03b9 : \u211d)\u207b\u00b9) atTop atTop)\n  \u00b7 filter_upwards [eventually_gt_atTop 0] with c hc\n    have aux\u2081 : (card \u03b9 : \u211d) \u2260 0 := Nat.cast_ne_zero.mpr card_ne_zero\n    have aux\u2082 : 0 < c ^ (card \u03b9 : \u211d)\u207b\u00b9 := Real.rpow_pos_of_pos hc _\n    have aux\u2083 : (c ^ (card \u03b9 : \u211d)\u207b\u00b9)\u207b\u00b9 \u2260 0 := inv_ne_zero aux\u2082.ne'\n    have aux\u2084 : c ^ (-(card \u03b9 : \u211d)\u207b\u00b9) \u2260 0 := (Real.rpow_pos_of_pos hc _).ne'\n    obtain \u27e8hc\u2081, hc\u2082\u27e9 := lt_iff_le_and_ne.mp hc\n    rw [Function.comp_apply, \u2190 Real.rpow_natCast, Real.rpow_inv_rpow hc\u2081 aux\u2081, eq_comm]\n    congr\n    refine Nat.card_congr <| Equiv.subtypeEquiv ((b.ofZLatticeBasis \u211d).equivFun.toEquiv.trans\n          (Equiv.smulRight aux\u2084)) fun _ \u21a6 ?_\n    rw [Set.mem_inter_iff, Set.mem_inter_iff, Equiv.trans_apply, LinearEquiv.coe_toEquiv,\n      Equiv.smulRight_apply, Real.rpow_neg hc\u2081, Set.smul_mem_smul_set_iff\u2080 aux\u2083,\n      \u2190 Set.mem_smul_set_iff_inv_smul_mem\u2080 aux\u2082.ne', \u2190 image_smul_set,\n      tendsto_card_le_div''_aux hX h\u2081 aux\u2082, \u2190 Real.rpow_natCast, \u2190 Real.rpow_mul hc\u2081,\n      inv_mul_cancel\u2080 aux\u2081, Real.rpow_one]\n    simp_rw [SetLike.mem_coe, Set.mem_image, EmbeddingLike.apply_eq_iff_eq, exists_eq_right,\n      and_congr_right_iff, \u2190 b.ofZLatticeBasis_span \u211d, Basis.mem_span_iff_repr_mem,\n      Pi.basisFun_repr, Basis.equivFun_apply, implies_true]\n  \u00b7 rw [\u2190 NormedSpace.isVonNBounded_iff \u211d] at h\u2082 \u22a2\n    exact Bornology.IsVonNBounded.image h\u2082 ((b.ofZLatticeBasis \u211d).equivFunL : E \u2192L[\u211d] \u03b9 \u2192 \u211d)\n  \u00b7 exact (b.ofZLatticeBasis \u211d).equivFunL.toHomeomorph.toMeasurableEquiv.measurableSet_image.mpr h\u2083\n  \u00b7 simp_rw [\u2190 image_smul_set]\n    apply Set.image_mono\n    rw [tendsto_card_le_div''_aux hX h\u2081 hx,\n      tendsto_card_le_div''_aux hX h\u2081 (lt_of_lt_of_le hx hy)]\n    exact fun a \u27e8ha\u2081, ha\u2082\u27e9 \u21a6 \u27e8ha\u2081, le_trans ha\u2082 <| pow_le_pow_left\u2080 (le_of_lt hx) hy _\u27e9\n\nend General\n\nsection Pi\n\nopen Filter Fintype Pointwise Topology Bornology\n\nprivate theorem frontier_equivFun {E : Type*} [AddCommGroup E] [Module \u211d E] {\u03b9 : Type*} [Fintype \u03b9]\n    [TopologicalSpace E] [TopologicalAddGroup E] [ContinuousSMul \u211d E] [T2Space E]\n    (b : Basis \u03b9 \u211d E) (s : Set E) :\n    frontier (b.equivFun '' s) = b.equivFun '' (frontier s) := by\n  rw [LinearEquiv.image_eq_preimage, LinearEquiv.image_eq_preimage]\n  exact (Homeomorph.preimage_frontier b.equivFunL.toHomeomorph.symm s).symm\n\nvariable {\u03b9 : Type*} [Fintype \u03b9]\nvariable (L : Submodule \u2124 (\u03b9 \u2192 \u211d)) [DiscreteTopology L] [IsZLattice \u211d L]\n\n", "theoremStatement": "theorem tendsto_card_div_pow (b : Basis \u03b9 \u2124 L) {s : Set (\u03b9 \u2192 \u211d)} (hs\u2081 : IsBounded s)\n    (hs\u2082 : MeasurableSet s) (hs\u2083 : volume (frontier s) = 0) :\n    Tendsto (fun n : \u2115 \u21a6 (Nat.card (s \u2229 (n : \u211d)\u207b\u00b9 \u2022 L : Set (\u03b9 \u2192 \u211d)) : \u211d) / n ^ card \u03b9)\n      atTop (\ud835\udcdd ((volume s).toReal / covolume L)) ", "theoremName": "ZLattice.covolume.tendsto_card_div_pow", "fileCreated": {"commit": "85d6c78ac5782869d041c2ca6d3ca83cdde412c3", "date": "2024-09-09"}, "theoremCreated": {"commit": "211dc533566a173988a01067bb50d7917a097103", "date": "2024-12-18"}, "file": "mathlib/Mathlib/Algebra/Module/ZLattice/Covolume.lean", "module": "Mathlib.Algebra.Module.ZLattice.Covolume", "jsonFile": "Mathlib.Algebra.Module.ZLattice.Covolume.jsonl", "positionMetadata": {"lineInFile": 258, "tokenPositionInFile": 13704, "theoremPositionInFile": 14}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 169, "numPremises": 194}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  classical\n  convert tendsto_card_div_pow'' b hs\u2081 hs\u2082 ?_\n  \u00b7 rw [volume_image_eq_volume_div_covolume L b, ENNReal.toReal_div,\n      ENNReal.toReal_ofReal (covolume_pos L volume).le]\n  \u00b7 rw [frontier_equivFun, volume_image_eq_volume_div_covolume, hs\u2083, ENNReal.zero_div]", "proofType": "tactic", "proofLengthLines": 5, "proofLengthTokens": 275}}
{"srcContext": "/-\nCopyright (c) 2024 Jo\u00ebl Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jo\u00ebl Riou\n-/\nimport Mathlib.Algebra.Homology.Embedding.Extend\nimport Mathlib.Algebra.Homology.Embedding.IsSupported\nimport Mathlib.Algebra.Homology.QuasiIso\n\n/-!\n# Homology of the extension of an homological complex\n\nGiven an embedding `e : c.Embedding c'` and `K : HomologicalComplex C c`, we shall\ncompute the homology of `K.extend e`. In degrees that are not in the image of `e.f`,\nthe homology is obviously zero. When `e.f j = j`, we construct an isomorphism\n`(K.extend e).homology j' \u2245 K.homology j`.\n\n-/\n\nopen CategoryTheory Limits Category\n\nnamespace HomologicalComplex\n\nvariable {\u03b9 \u03b9' : Type*} {c : ComplexShape \u03b9} {c' : ComplexShape \u03b9'}\n  {C : Type*} [Category C] [HasZeroMorphisms C]\n  [HasZeroObject C]\n\nvariable (K L M : HomologicalComplex C c) (\u03c6 : K \u27f6 L) (\u03c6' : L \u27f6 M) (e : c.Embedding c')\n\nnamespace extend\n\nsection HomologyData\n\nvariable {i j k : \u03b9} {i' j' k' : \u03b9'} (hj' : e.f j = j')\n  (hi : c.prev j = i) (hi' : c'.prev j' = i') (hk : c.next j = k) (hk' : c'.next j' = k')\n\ninclude hk hk' in\nlemma comp_d_eq_zero_iff \u2983W : C\u2984 (\u03c6 : W \u27f6 K.X j) :\n    \u03c6 \u226b K.d j k = 0 \u2194 \u03c6 \u226b (K.extendXIso e hj').inv \u226b (K.extend e).d j' k' = 0 := by\n  by_cases hjk : c.Rel j k\n  \u00b7 have hk' : e.f k = k' := by rw [\u2190 hk', \u2190 hj', c'.next_eq' (e.rel hjk)]\n    rw [K.extend_d_eq e hj' hk', Iso.inv_hom_id_assoc,\n      \u2190 cancel_mono (K.extendXIso e hk').inv, zero_comp, assoc]\n  \u00b7 simp only [K.shape _ _ hjk, comp_zero, true_iff]\n    rw [K.extend_d_from_eq_zero e j' k' j hj', comp_zero, comp_zero]\n    rw [hk]\n    exact hjk\n\ninclude hi hi' in\nlemma d_comp_eq_zero_iff \u2983W : C\u2984 (\u03c6 : K.X j \u27f6 W) :\n    K.d i j \u226b \u03c6 = 0 \u2194 (K.extend e).d i' j' \u226b (K.extendXIso e hj').hom \u226b \u03c6 = 0 := by\n  by_cases hij : c.Rel i j\n  \u00b7 have hi' : e.f i = i' := by rw [\u2190 hi', \u2190 hj', c'.prev_eq' (e.rel hij)]\n    rw [K.extend_d_eq e hi' hj', assoc, assoc, Iso.inv_hom_id_assoc,\n      \u2190 cancel_epi (K.extendXIso e hi').hom, comp_zero]\n  \u00b7 simp only [K.shape _ _ hij, zero_comp, true_iff]\n    rw [K.extend_d_to_eq_zero e i' j' j hj', zero_comp]\n    rw [hi]\n    exact hij\n\nnamespace leftHomologyData\n\nvariable (cone : KernelFork (K.d j k)) (hcone : IsLimit cone)\n\n/-- The kernel fork of `(K.extend e).d j' k'` that is deduced from a kernel\nfork of `K.d j k `. -/\n@[simp]\nnoncomputable def kernelFork : KernelFork ((K.extend e).d j' k') :=\n  KernelFork.of\u03b9 (cone.\u03b9 \u226b (extendXIso K e hj').inv)\n    (by rw [assoc, \u2190 comp_d_eq_zero_iff K e hj' hk hk' cone.\u03b9, cone.condition])\n\n/-- The limit kernel fork of `(K.extend e).d j' k'` that is deduced from a limit\nkernel fork of `K.d j k `. -/\nnoncomputable def isLimitKernelFork : IsLimit (kernelFork K e hj' hk hk' cone) :=\n  KernelFork.isLimitOfIsLimitOfIff hcone ((K.extend e).d j' k')\n    (extendXIso K e hj').symm (comp_d_eq_zero_iff K e hj' hk hk')\n\nvariable (cocone : CokernelCofork (hcone.lift (KernelFork.of\u03b9 (K.d i j) (K.d_comp_d i j k))))\n  (hcocone : IsColimit cocone)\n\ninclude hi hi' hcone in\n/-- Auxiliary lemma for `lift_d_comp_eq_zero_iff`. -/\nlemma lift_d_comp_eq_zero_iff' \u2983W : C\u2984 (f' : K.X i \u27f6 cone.pt)\n    (hf' : f' \u226b cone.\u03b9 = K.d i j)\n    (f'' : (K.extend e).X i' \u27f6 cone.pt)\n    (hf'' : f'' \u226b cone.\u03b9 \u226b (extendXIso K e hj').inv = (K.extend e).d i' j')\n    (\u03c6 : cone.pt \u27f6 W) :\n    f' \u226b \u03c6 = 0 \u2194 f'' \u226b \u03c6 = 0 := by\n  by_cases hij : c.Rel i j\n  \u00b7 have hi'' : e.f i = i' := by rw [\u2190 hi', \u2190 hj', c'.prev_eq' (e.rel hij)]\n    have : (K.extendXIso e hi'').hom \u226b f' = f'' := by\n      apply Fork.IsLimit.hom_ext hcone\n      rw [assoc, hf', \u2190 cancel_mono (extendXIso K e hj').inv, assoc, assoc, hf'',\n        K.extend_d_eq e hi'' hj']\n    rw [\u2190 cancel_epi (K.extendXIso e hi'').hom, comp_zero, \u2190 this, assoc]\n  \u00b7 have h\u2081 : f' = 0 := by\n      apply Fork.IsLimit.hom_ext hcone\n      simp only [zero_comp, hf', K.shape _ _ hij]\n    have h\u2082 : f'' = 0 := by\n      apply Fork.IsLimit.hom_ext hcone\n      dsimp\n      rw [\u2190 cancel_mono (extendXIso K e hj').inv, assoc, hf'', zero_comp, zero_comp,\n        K.extend_d_to_eq_zero e i' j' j hj']\n      rw [hi]\n      exact hij\n    simp [h\u2081, h\u2082]\n\ninclude hi hi' in\n", "theoremStatement": "lemma lift_d_comp_eq_zero_iff \u2983W : C\u2984 (\u03c6 : cone.pt \u27f6 W) :\n    hcone.lift (KernelFork.of\u03b9 (K.d i j) (K.d_comp_d i j k)) \u226b \u03c6 = 0 \u2194\n      ((isLimitKernelFork K e hj' hk hk' cone hcone).lift\n      (KernelFork.of\u03b9 ((K.extend e).d i' j') (d_comp_d _ _ _ _))) \u226b \u03c6 = 0 ", "theoremName": "HomologicalComplex.extend.leftHomologyData.lift_d_comp_eq_zero_iff", "fileCreated": {"commit": "9bdc1af76cf75d960f42c29f1c09917785066c8b", "date": "2024-11-30"}, "theoremCreated": {"commit": "9bdc1af76cf75d960f42c29f1c09917785066c8b", "date": "2024-11-30"}, "file": "mathlib/Mathlib/Algebra/Homology/Embedding/ExtendHomology.lean", "module": "Mathlib.Algebra.Homology.Embedding.ExtendHomology", "jsonFile": "Mathlib.Algebra.Homology.Embedding.ExtendHomology.jsonl", "positionMetadata": {"lineInFile": 109, "tokenPositionInFile": 4138, "theoremPositionInFile": 5}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 31, "numPremises": 35}, "proofMetadata": {"hasProof": true, "proof": ":=\n  lift_d_comp_eq_zero_iff' K e hj' hi hi' cone hcone _ (hcone.fac _ _) _\n    (IsLimit.fac _ _ WalkingParallelPair.zero) _", "proofType": "term", "proofLengthLines": 2, "proofLengthTokens": 124}}
{"srcContext": "/-\nCopyright (c) 2020 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\nimport Mathlib.RingTheory.NonUnitalSubsemiring.Defs\n\n/-!\n# Bundled subsemirings\n\nWe define bundled subsemirings and some standard constructions: `subtype` and `inclusion`\nring homomorphisms.\n-/\n\n\nuniverse u v w\n\nsection AddSubmonoidWithOneClass\n\n/-- `AddSubmonoidWithOneClass S R` says `S` is a type of subsets `s \u2264 R` that contain `0`, `1`,\nand are closed under `(+)` -/\nclass AddSubmonoidWithOneClass (S : Type*) (R : outParam Type*) [AddMonoidWithOne R]\n  [SetLike S R] extends AddSubmonoidClass S R, OneMemClass S R : Prop\n\nvariable {S R : Type*} [AddMonoidWithOne R] [SetLike S R] (s : S)\n\n@[aesop safe apply (rule_sets := [SetLike])]\ntheorem natCast_mem [AddSubmonoidWithOneClass S R] (n : \u2115) : (n : R) \u2208 s := by\n  induction n <;> simp [zero_mem, add_mem, one_mem, *]\n\n@[aesop safe apply (rule_sets := [SetLike])]\nlemma ofNat_mem [AddSubmonoidWithOneClass S R] (s : S) (n : \u2115) [n.AtLeastTwo] :\n    ofNat(n) \u2208 s := by\n  rw [\u2190 Nat.cast_ofNat]; exact natCast_mem s n\n\ninstance (priority := 74) AddSubmonoidWithOneClass.toAddMonoidWithOne\n    [AddSubmonoidWithOneClass S R] : AddMonoidWithOne s :=\n  { AddSubmonoidClass.toAddMonoid s with\n    one := \u27e8_, one_mem s\u27e9\n    natCast := fun n => \u27e8n, natCast_mem s n\u27e9\n    natCast_zero := Subtype.ext Nat.cast_zero\n    natCast_succ := fun _ => Subtype.ext (Nat.cast_succ _) }\n\nend AddSubmonoidWithOneClass\n\nvariable {R : Type u} {S : Type v} [NonAssocSemiring R]\n\nsection SubsemiringClass\n\n/-- `SubsemiringClass S R` states that `S` is a type of subsets `s \u2286 R` that\nare both a multiplicative and an additive submonoid. -/\nclass SubsemiringClass (S : Type*) (R : outParam (Type u)) [NonAssocSemiring R]\n  [SetLike S R] extends SubmonoidClass S R, AddSubmonoidClass S R : Prop\n\n-- See note [lower instance priority]\ninstance (priority := 100) SubsemiringClass.addSubmonoidWithOneClass (S : Type*)\n    (R : Type u) {_ : NonAssocSemiring R} [SetLike S R] [h : SubsemiringClass S R] :\n    AddSubmonoidWithOneClass S R :=\n  { h with }\n\ninstance (priority := 100) SubsemiringClass.nonUnitalSubsemiringClass (S : Type*)\n    (R : Type u) [NonAssocSemiring R] [SetLike S R] [SubsemiringClass S R] :\n    NonUnitalSubsemiringClass S R where\n  mul_mem := mul_mem\n\nvariable [SetLike S R] [hSR : SubsemiringClass S R] (s : S)\n\nnamespace SubsemiringClass\n\n-- Prefer subclasses of `NonAssocSemiring` over subclasses of `SubsemiringClass`.\n/-- A subsemiring of a `NonAssocSemiring` inherits a `NonAssocSemiring` structure -/\ninstance (priority := 75) toNonAssocSemiring : NonAssocSemiring s := fast_instance%\n  Subtype.coe_injective.nonAssocSemiring Subtype.val rfl rfl (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) fun _ => rfl\n\ninstance nontrivial [Nontrivial R] : Nontrivial s :=\n  nontrivial_of_ne 0 1 fun H => zero_ne_one (congr_arg Subtype.val H)\n\ninstance noZeroDivisors [NoZeroDivisors R] : NoZeroDivisors s :=\n  Subtype.coe_injective.noZeroDivisors _ rfl fun _ _ => rfl\n\n/-- The natural ring hom from a subsemiring of semiring `R` to `R`. -/\ndef subtype : s \u2192+* R :=\n  { SubmonoidClass.subtype s, AddSubmonoidClass.subtype s with toFun := (\u2191) }\n\n@[simp]\ntheorem coe_subtype : (subtype s : s \u2192 R) = ((\u2191) : s \u2192 R) :=\n  rfl\n\n-- Prefer subclasses of `Semiring` over subclasses of `SubsemiringClass`.\n/-- A subsemiring of a `Semiring` is a `Semiring`. -/\ninstance (priority := 75) toSemiring {R} [Semiring R] [SetLike S R] [SubsemiringClass S R] :\n    Semiring s := fast_instance%\n  Subtype.coe_injective.semiring Subtype.val rfl rfl (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) fun _ => rfl\n\n@[simp, norm_cast]\ntheorem coe_pow {R} [Semiring R] [SetLike S R] [SubsemiringClass S R] (x : s) (n : \u2115) :\n    ((x ^ n : s) : R) = (x : R) ^ n := by\n  induction n with\n  | zero => simp\n  | succ n ih => simp [pow_succ, ih]\n\n/-- A subsemiring of a `CommSemiring` is a `CommSemiring`. -/\ninstance toCommSemiring {R} [CommSemiring R] [SetLike S R] [SubsemiringClass S R] :\n    CommSemiring s := fast_instance%\n  Subtype.coe_injective.commSemiring Subtype.val rfl rfl (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) fun _ => rfl\n\nend SubsemiringClass\n\nend SubsemiringClass\n\nvariable [NonAssocSemiring S]\n\n/-- A subsemiring of a semiring `R` is a subset `s` that is both a multiplicative and an additive\nsubmonoid. -/\nstructure Subsemiring (R : Type u) [NonAssocSemiring R] extends Submonoid R, AddSubmonoid R\n\n/-- Reinterpret a `Subsemiring` as a `Submonoid`. -/\nadd_decl_doc Subsemiring.toSubmonoid\n\n/-- Reinterpret a `Subsemiring` as an `AddSubmonoid`. -/\nadd_decl_doc Subsemiring.toAddSubmonoid\n\nnamespace Subsemiring\n\ninstance : SetLike (Subsemiring R) R where\n  coe s := s.carrier\n  coe_injective' p q h := by cases p; cases q; congr; exact SetLike.coe_injective' h\n\ninstance : SubsemiringClass (Subsemiring R) R where\n  zero_mem := zero_mem'\n  add_mem {s} := AddSubsemigroup.add_mem' s.toAddSubmonoid.toAddSubsemigroup\n  one_mem {s} := Submonoid.one_mem' s.toSubmonoid\n  mul_mem {s} := Subsemigroup.mul_mem' s.toSubmonoid.toSubsemigroup\n\ninitialize_simps_projections Subsemiring (carrier \u2192 coe, as_prefix coe)\n\n/-- Turn a `Subsemiring` into a `NonUnitalSubsemiring` by forgetting that it contains `1`. -/\ndef toNonUnitalSubsemiring (S : Subsemiring R) : NonUnitalSubsemiring R where __ := S\n\n@[simp]\ntheorem mem_toSubmonoid {s : Subsemiring R} {x : R} : x \u2208 s.toSubmonoid \u2194 x \u2208 s :=\n  Iff.rfl\n\n", "theoremStatement": "@[simp]\nlemma mem_toNonUnitalSubsemiring {S : Subsemiring R} {x : R} :\n    x \u2208 S.toNonUnitalSubsemiring \u2194 x \u2208 S ", "theoremName": "Subsemiring.mem_toNonUnitalSubsemiring", "fileCreated": {"commit": "ddfa45d21fa79757b4bb6bc13e35338db5d9b26c", "date": "2024-11-03"}, "theoremCreated": {"commit": "8b781ec918a891323c20be4ed923133e287d624c", "date": "2025-01-02"}, "file": "mathlib/Mathlib/Algebra/Ring/Subsemiring/Defs.lean", "module": "Mathlib.Algebra.Ring.Subsemiring.Defs", "jsonFile": "Mathlib.Algebra.Ring.Subsemiring.Defs.jsonl", "positionMetadata": {"lineInFile": 147, "tokenPositionInFile": 5534, "theoremPositionInFile": 6}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 8, "numPremises": 11}, "proofMetadata": {"hasProof": true, "proof": ":= .rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 7}}
{"srcContext": "/-\nCopyright (c) 2024 Jo\u00ebl Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jo\u00ebl Riou\n-/\nimport Mathlib.Algebra.Homology.Embedding.Extend\nimport Mathlib.Algebra.Homology.Embedding.IsSupported\nimport Mathlib.Algebra.Homology.QuasiIso\n\n/-!\n# Homology of the extension of an homological complex\n\nGiven an embedding `e : c.Embedding c'` and `K : HomologicalComplex C c`, we shall\ncompute the homology of `K.extend e`. In degrees that are not in the image of `e.f`,\nthe homology is obviously zero. When `e.f j = j`, we construct an isomorphism\n`(K.extend e).homology j' \u2245 K.homology j`.\n\n-/\n\nopen CategoryTheory Limits Category\n\nnamespace HomologicalComplex\n\nvariable {\u03b9 \u03b9' : Type*} {c : ComplexShape \u03b9} {c' : ComplexShape \u03b9'}\n  {C : Type*} [Category C] [HasZeroMorphisms C]\n  [HasZeroObject C]\n\nvariable (K L M : HomologicalComplex C c) (\u03c6 : K \u27f6 L) (\u03c6' : L \u27f6 M) (e : c.Embedding c')\n\nnamespace extend\n\nsection HomologyData\n\nvariable {i j k : \u03b9} {i' j' k' : \u03b9'} (hj' : e.f j = j')\n  (hi : c.prev j = i) (hi' : c'.prev j' = i') (hk : c.next j = k) (hk' : c'.next j' = k')\n\ninclude hk hk' in\nlemma comp_d_eq_zero_iff \u2983W : C\u2984 (\u03c6 : W \u27f6 K.X j) :\n    \u03c6 \u226b K.d j k = 0 \u2194 \u03c6 \u226b (K.extendXIso e hj').inv \u226b (K.extend e).d j' k' = 0 := by\n  by_cases hjk : c.Rel j k\n  \u00b7 have hk' : e.f k = k' := by rw [\u2190 hk', \u2190 hj', c'.next_eq' (e.rel hjk)]\n    rw [K.extend_d_eq e hj' hk', Iso.inv_hom_id_assoc,\n      \u2190 cancel_mono (K.extendXIso e hk').inv, zero_comp, assoc]\n  \u00b7 simp only [K.shape _ _ hjk, comp_zero, true_iff]\n    rw [K.extend_d_from_eq_zero e j' k' j hj', comp_zero, comp_zero]\n    rw [hk]\n    exact hjk\n\ninclude hi hi' in\nlemma d_comp_eq_zero_iff \u2983W : C\u2984 (\u03c6 : K.X j \u27f6 W) :\n    K.d i j \u226b \u03c6 = 0 \u2194 (K.extend e).d i' j' \u226b (K.extendXIso e hj').hom \u226b \u03c6 = 0 := by\n  by_cases hij : c.Rel i j\n  \u00b7 have hi' : e.f i = i' := by rw [\u2190 hi', \u2190 hj', c'.prev_eq' (e.rel hij)]\n    rw [K.extend_d_eq e hi' hj', assoc, assoc, Iso.inv_hom_id_assoc,\n      \u2190 cancel_epi (K.extendXIso e hi').hom, comp_zero]\n  \u00b7 simp only [K.shape _ _ hij, zero_comp, true_iff]\n    rw [K.extend_d_to_eq_zero e i' j' j hj', zero_comp]\n    rw [hi]\n    exact hij\n\nnamespace leftHomologyData\n\nvariable (cone : KernelFork (K.d j k)) (hcone : IsLimit cone)\n\n/-- The kernel fork of `(K.extend e).d j' k'` that is deduced from a kernel\nfork of `K.d j k `. -/\n@[simp]\nnoncomputable def kernelFork : KernelFork ((K.extend e).d j' k') :=\n  KernelFork.of\u03b9 (cone.\u03b9 \u226b (extendXIso K e hj').inv)\n    (by rw [assoc, \u2190 comp_d_eq_zero_iff K e hj' hk hk' cone.\u03b9, cone.condition])\n\n/-- The limit kernel fork of `(K.extend e).d j' k'` that is deduced from a limit\nkernel fork of `K.d j k `. -/\nnoncomputable def isLimitKernelFork : IsLimit (kernelFork K e hj' hk hk' cone) :=\n  KernelFork.isLimitOfIsLimitOfIff hcone ((K.extend e).d j' k')\n    (extendXIso K e hj').symm (comp_d_eq_zero_iff K e hj' hk hk')\n\nvariable (cocone : CokernelCofork (hcone.lift (KernelFork.of\u03b9 (K.d i j) (K.d_comp_d i j k))))\n  (hcocone : IsColimit cocone)\n\ninclude hi hi' hcone in\n/-- Auxiliary lemma for `lift_d_comp_eq_zero_iff`. -/\nlemma lift_d_comp_eq_zero_iff' \u2983W : C\u2984 (f' : K.X i \u27f6 cone.pt)\n    (hf' : f' \u226b cone.\u03b9 = K.d i j)\n    (f'' : (K.extend e).X i' \u27f6 cone.pt)\n    (hf'' : f'' \u226b cone.\u03b9 \u226b (extendXIso K e hj').inv = (K.extend e).d i' j')\n    (\u03c6 : cone.pt \u27f6 W) :\n    f' \u226b \u03c6 = 0 \u2194 f'' \u226b \u03c6 = 0 := by\n  by_cases hij : c.Rel i j\n  \u00b7 have hi'' : e.f i = i' := by rw [\u2190 hi', \u2190 hj', c'.prev_eq' (e.rel hij)]\n    have : (K.extendXIso e hi'').hom \u226b f' = f'' := by\n      apply Fork.IsLimit.hom_ext hcone\n      rw [assoc, hf', \u2190 cancel_mono (extendXIso K e hj').inv, assoc, assoc, hf'',\n        K.extend_d_eq e hi'' hj']\n    rw [\u2190 cancel_epi (K.extendXIso e hi'').hom, comp_zero, \u2190 this, assoc]\n  \u00b7 have h\u2081 : f' = 0 := by\n      apply Fork.IsLimit.hom_ext hcone\n      simp only [zero_comp, hf', K.shape _ _ hij]\n    have h\u2082 : f'' = 0 := by\n      apply Fork.IsLimit.hom_ext hcone\n      dsimp\n      rw [\u2190 cancel_mono (extendXIso K e hj').inv, assoc, hf'', zero_comp, zero_comp,\n        K.extend_d_to_eq_zero e i' j' j hj']\n      rw [hi]\n      exact hij\n    simp [h\u2081, h\u2082]\n\ninclude hi hi' in\nlemma lift_d_comp_eq_zero_iff \u2983W : C\u2984 (\u03c6 : cone.pt \u27f6 W) :\n    hcone.lift (KernelFork.of\u03b9 (K.d i j) (K.d_comp_d i j k)) \u226b \u03c6 = 0 \u2194\n      ((isLimitKernelFork K e hj' hk hk' cone hcone).lift\n      (KernelFork.of\u03b9 ((K.extend e).d i' j') (d_comp_d _ _ _ _))) \u226b \u03c6 = 0 :=\n  lift_d_comp_eq_zero_iff' K e hj' hi hi' cone hcone _ (hcone.fac _ _) _\n    (IsLimit.fac _ _ WalkingParallelPair.zero) _\n\n/-- Auxiliary definition for `extend.leftHomologyData`. -/\nnoncomputable def cokernelCofork :\n    CokernelCofork ((isLimitKernelFork K e hj' hk hk' cone hcone).lift\n      (KernelFork.of\u03b9 ((K.extend e).d i' j') (d_comp_d _ _ _ _))) :=\n  CokernelCofork.of\u03c0 cocone.\u03c0 (by\n    rw [\u2190 lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' cone hcone]\n    exact cocone.condition)\n\n/-- Auxiliary definition for `extend.leftHomologyData`. -/\nnoncomputable def isColimitCokernelCofork :\n    IsColimit (cokernelCofork K e hj' hi hi' hk hk' cone hcone cocone) :=\n  CokernelCofork.isColimitOfIsColimitOfIff' hcocone _\n    (lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' cone hcone)\n\nend leftHomologyData\n\nopen leftHomologyData in\n/-- The left homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a left homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def leftHomologyData (h : (K.sc' i j k).LeftHomologyData) :\n    ((K.extend e).sc' i' j' k').LeftHomologyData where\n  K := h.K\n  H := h.H\n  i := h.i \u226b (extendXIso K e hj').inv\n  \u03c0 := h.\u03c0\n  wi := by\n    dsimp\n    rw [assoc, \u2190 comp_d_eq_zero_iff K e hj' hk hk']\n    exact h.wi\n  hi := isLimitKernelFork K e hj' hk hk' _ h.hi\n  w\u03c0 := by\n    dsimp\n    rw [\u2190 lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' _ h.hi]\n    exact h.w\u03c0\n  h\u03c0 := isColimitCokernelCofork K e hj' hi hi' hk hk' _ h.hi _ h.h\u03c0\n\nnamespace rightHomologyData\n\nvariable (cocone : CokernelCofork (K.d i j)) (hcocone : IsColimit cocone)\n\n/-- The cokernel cofork of `(K.extend e).d i' j'` that is deduced from a cokernel\ncofork of `K.d i j`. -/\n@[simp]\nnoncomputable def cokernelCofork : CokernelCofork ((K.extend e).d i' j') :=\n  CokernelCofork.of\u03c0 ((extendXIso K e hj').hom \u226b cocone.\u03c0) (by\n    rw [\u2190 d_comp_eq_zero_iff K e hj' hi hi' cocone.\u03c0, cocone.condition])\n\n/-- The colimit cokernel cofork of `(K.extend e).d i' j'` that is deduced from a\ncolimit cokernel cofork of `K.d i j`. -/\nnoncomputable def isColimitCokernelCofork : IsColimit (cokernelCofork K e hj' hi hi' cocone) :=\n  CokernelCofork.isColimitOfIsColimitOfIff hcocone ((K.extend e).d i' j')\n    (extendXIso K e hj') (d_comp_eq_zero_iff K e hj' hi hi')\n\nvariable (cone : KernelFork (hcocone.desc (CokernelCofork.of\u03c0 (K.d j k) (K.d_comp_d i j k))))\n  (hcone : IsLimit cone)\n\ninclude hk hk' hcocone in\nlemma d_comp_desc_eq_zero_iff' \u2983W : C\u2984 (f' : cocone.pt \u27f6 K.X k)\n    (hf' : cocone.\u03c0 \u226b f' = K.d j k)\n    (f'' : cocone.pt \u27f6 (K.extend e).X k')\n    (hf'' : (extendXIso K e hj').hom \u226b cocone.\u03c0 \u226b f'' = (K.extend e).d j' k')\n    (\u03c6 : W \u27f6 cocone.pt) :\n    \u03c6 \u226b f' = 0 \u2194 \u03c6 \u226b f'' = 0 := by\n  by_cases hjk : c.Rel j k\n  \u00b7 have hk'' : e.f k = k' := by rw [\u2190 hk', \u2190 hj', c'.next_eq' (e.rel hjk)]\n    have : f' \u226b (K.extendXIso e hk'').inv = f'' := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      rw [reassoc_of% hf', \u2190 cancel_epi (extendXIso K e hj').hom, hf'',\n        K.extend_d_eq e hj' hk'']\n    rw [\u2190 cancel_mono (K.extendXIso e hk'').inv, zero_comp, assoc, this]\n  \u00b7 have h\u2081 : f' = 0 := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      simp only [hf', comp_zero, K.shape _ _ hjk]\n    have h\u2082 : f'' = 0 := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      rw [\u2190 cancel_epi (extendXIso K e hj').hom, hf'', comp_zero, comp_zero,\n        K.extend_d_from_eq_zero e j' k' j hj']\n      rw [hk]\n      exact hjk\n    simp [h\u2081, h\u2082]\n\ninclude hk hk' in\nlemma d_comp_desc_eq_zero_iff \u2983W : C\u2984 (\u03c6 : W \u27f6 cocone.pt) :\n    \u03c6 \u226b hcocone.desc (CokernelCofork.of\u03c0 (K.d j k) (K.d_comp_d i j k)) = 0 \u2194\n      \u03c6 \u226b ((isColimitCokernelCofork K e hj' hi hi' cocone hcocone).desc\n      (CokernelCofork.of\u03c0 ((K.extend e).d j' k') (d_comp_d _ _ _ _))) = 0 :=\n  d_comp_desc_eq_zero_iff' K e hj' hk hk' cocone hcocone _ (hcocone.fac _ _) _ (by\n    simpa using (isColimitCokernelCofork K e hj' hi hi' cocone hcocone).fac _\n      WalkingParallelPair.one) _\n\n/-- Auxiliary definition for `extend.rightHomologyData`. -/\nnoncomputable def kernelFork :\n    KernelFork ((isColimitCokernelCofork K e hj' hi hi' cocone hcocone).desc\n      (CokernelCofork.of\u03c0 ((K.extend e).d j' k') (d_comp_d _ _ _ _))) :=\n  KernelFork.of\u03b9 cone.\u03b9 (by\n    rw [\u2190 d_comp_desc_eq_zero_iff K e hj' hi hi' hk hk' cocone hcocone]\n    exact cone.condition)\n\n/-- Auxiliary definition for `extend.rightHomologyData`. -/\nnoncomputable def isLimitKernelFork :\n    IsLimit (kernelFork K e hj' hi hi' hk hk' cocone hcocone cone) :=\n  KernelFork.isLimitOfIsLimitOfIff' hcone _\n    (d_comp_desc_eq_zero_iff K e hj' hi hi' hk hk' cocone hcocone)\n\nend rightHomologyData\n\nopen rightHomologyData in\n/-- The right homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a right homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def rightHomologyData (h : (K.sc' i j k).RightHomologyData) :\n    ((K.extend e).sc' i' j' k').RightHomologyData where\n  Q := h.Q\n  H := h.H\n  p := (extendXIso K e hj').hom \u226b h.p\n  \u03b9 := h.\u03b9\n  wp := by\n    dsimp\n    rw [\u2190 d_comp_eq_zero_iff K e hj' hi hi']\n    exact h.wp\n  hp := isColimitCokernelCofork K e hj' hi hi' _ h.hp\n  w\u03b9 := by\n    dsimp\n    rw [\u2190 d_comp_desc_eq_zero_iff K e hj' hi hi' hk hk' _ h.hp]\n    exact h.w\u03b9\n  h\u03b9 := isLimitKernelFork K e hj' hi hi' hk hk' _ h.hp _ h.h\u03b9\n\n/-- Computation of the `g'` field of `extend.rightHomologyData`. -/\nlemma rightHomologyData_g' (h : (K.sc' i j k).RightHomologyData) (hk'' : e.f k = k') :\n    (rightHomologyData K e hj' hi hi' hk hk' h).g' = h.g' \u226b (K.extendXIso e hk'').inv := by\n  rw [\u2190 cancel_epi h.p, \u2190 cancel_epi (extendXIso K e hj').hom]\n  have := (rightHomologyData K e hj' hi hi' hk hk' h).p_g'\n  dsimp at this\n  rw [assoc] at this\n  rw [this, K.extend_d_eq e hj' hk'', h.p_g'_assoc, shortComplexFunctor'_obj_g]\n\n/-- The homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def homologyData (h : (K.sc' i j k).HomologyData) :\n    ((K.extend e).sc' i' j' k').HomologyData where\n  left := leftHomologyData K e hj' hi hi' hk hk' h.left\n  right := rightHomologyData K e hj' hi hi' hk hk' h.right\n  iso := h.iso\n\n/-- The homology data of `(K.extend e).sc j'` that is deduced\nfrom a homology data of `K.sc' i j k`. -/\n@[simps!]\nnoncomputable def homologyData' (h : (K.sc' i j k).HomologyData) :\n    ((K.extend e).sc j').HomologyData :=\n  homologyData K e hj' hi rfl hk rfl h\n\nend HomologyData\n\nlemma hasHomology {j : \u03b9} {j' : \u03b9'} (hj' : e.f j = j') [K.HasHomology j] :\n    (K.extend e).HasHomology j' :=\n  ShortComplex.HasHomology.mk'\n    (homologyData' K e hj' rfl rfl ((K.sc j).homologyData))\n\ninstance (j : \u03b9) [K.HasHomology j] : (K.extend e).HasHomology (e.f j) :=\n  hasHomology K e rfl\n\ninstance [\u2200 j, K.HasHomology j] (j' : \u03b9') : (K.extend e).HasHomology j' := by\n  by_cases h : \u2203 j, e.f j = j'\n  \u00b7 obtain \u27e8j, rfl\u27e9 := h\n    infer_instance\n  \u00b7 have hj := isZero_extend_X K e j' (by tauto)\n    exact ShortComplex.HasHomology.mk'\n      (ShortComplex.HomologyData.ofZeros _ (hj.eq_of_tgt _ _) (hj.eq_of_src _ _))\n\nend extend\n\nlemma extend_exactAt (j' : \u03b9') (hj' : \u2200 j, e.f j \u2260 j') :\n    (K.extend e).ExactAt j' :=\n  exactAt_of_isSupported _ e j' hj'\n\nsection\n\nvariable {j : \u03b9} {j' : \u03b9'} (hj' : e.f j = j') [K.HasHomology j] [L.HasHomology j]\n  [(K.extend e).HasHomology j'] [(L.extend e).HasHomology j']\n\n/-- The isomorphism `(K.extend e).cycles j' \u2245 K.cycles j` when `e.f j = j'`. -/\nnoncomputable def extendCyclesIso :\n    (K.extend e).cycles j' \u2245 K.cycles j :=\n  (extend.homologyData' K e hj' rfl rfl (K.sc j).homologyData).left.cyclesIso \u226a\u226b\n    (K.sc j).homologyData.left.cyclesIso.symm\n\n/-- The isomorphism `(K.extend e).opcycles j' \u2245 K.opcycles j` when `e.f j = j'`. -/\nnoncomputable def extendOpcyclesIso :\n    (K.extend e).opcycles j' \u2245 K.opcycles j :=\n  (extend.homologyData' K e hj' rfl rfl (K.sc j).homologyData).right.opcyclesIso \u226a\u226b\n    (K.sc j).homologyData.right.opcyclesIso.symm\n\n/-- The isomorphism `(K.extend e).homology j' \u2245 K.homology j` when `e.f j = j'`. -/\nnoncomputable def extendHomologyIso :\n    (K.extend e).homology j' \u2245 K.homology j :=\n  (extend.homologyData' K e hj' rfl rfl (K.sc j).homologyData).left.homologyIso \u226a\u226b\n    (K.sc j).homologyData.left.homologyIso.symm\n\ninclude hj' in\nlemma extend_exactAt_iff :\n    (K.extend e).ExactAt j' \u2194 K.ExactAt j := by\n  simp only [HomologicalComplex.exactAt_iff_isZero_homology]\n  exact (K.extendHomologyIso e hj').isZero_iff\n\n@[reassoc (attr := simp)]\nlemma extendCyclesIso_hom_iCycles :\n    (K.extendCyclesIso e hj').hom \u226b K.iCycles j =\n      (K.extend e).iCycles j' \u226b (K.extendXIso e hj').hom := by\n  rw [\u2190 cancel_epi (K.extendCyclesIso e hj').inv, Iso.inv_hom_id_assoc]\n  dsimp [extendCyclesIso, iCycles]\n  rw [assoc, ShortComplex.LeftHomologyData.cyclesIso_inv_comp_iCycles_assoc]\n  dsimp\n  rw [assoc, Iso.inv_hom_id, comp_id,\n    ShortComplex.LeftHomologyData.cyclesIso_hom_comp_i]\n\n@[reassoc (attr := simp)]\nlemma extendCyclesIso_inv_iCycles :\n    (K.extendCyclesIso e hj').inv \u226b (K.extend e).iCycles j' =\n      K.iCycles j \u226b (K.extendXIso e hj').inv := by\n  simp only [\u2190 cancel_epi (K.extendCyclesIso e hj').hom, Iso.hom_inv_id_assoc,\n    extendCyclesIso_hom_iCycles_assoc, Iso.hom_inv_id, comp_id]\n\n@[reassoc (attr := simp)]\nlemma homology\u03c0_extendHomologyIso_hom :\n    (K.extend e).homology\u03c0 j' \u226b (K.extendHomologyIso e hj').hom =\n      (K.extendCyclesIso e hj').hom \u226b K.homology\u03c0 j := by\n  dsimp [extendHomologyIso, homology\u03c0]\n  rw [ShortComplex.LeftHomologyData.homology\u03c0_comp_homologyIso_hom_assoc,\n    \u2190 cancel_mono (K.sc j).homologyData.left.homologyIso.hom,\n    assoc, assoc, assoc, Iso.inv_hom_id, comp_id,\n    ShortComplex.LeftHomologyData.homology\u03c0_comp_homologyIso_hom]\n  dsimp [extendCyclesIso]\n  simp only [assoc, Iso.inv_hom_id_assoc]\n\n@[reassoc (attr := simp)]\nlemma homology\u03c0_extendHomologyIso_inv :\n    K.homology\u03c0 j \u226b (K.extendHomologyIso e hj').inv =\n      (K.extendCyclesIso e hj').inv \u226b (K.extend e).homology\u03c0 j' := by\n  simp only [\u2190 cancel_mono (K.extendHomologyIso e hj').hom,\n    assoc, Iso.inv_hom_id, comp_id, homology\u03c0_extendHomologyIso_hom, Iso.inv_hom_id_assoc]\n\n@[reassoc (attr := simp)]\nlemma pOpcycles_extendOpcyclesIso_inv :\n    K.pOpcycles j \u226b (K.extendOpcyclesIso e hj').inv =\n      (K.extendXIso e hj').inv \u226b (K.extend e).pOpcycles j' := by\n  rw [\u2190 cancel_mono (K.extendOpcyclesIso e hj').hom, assoc, assoc, Iso.inv_hom_id, comp_id]\n  dsimp [extendOpcyclesIso, pOpcycles]\n  rw [ShortComplex.RightHomologyData.pOpcycles_comp_opcyclesIso_hom_assoc]\n  dsimp\n  rw [assoc, Iso.inv_hom_id_assoc, ShortComplex.RightHomologyData.p_comp_opcyclesIso_inv]\n  rfl\n\n@[reassoc (attr := simp)]\nlemma pOpcycles_extendOpcyclesIso_hom :\n    (K.extend e).pOpcycles j' \u226b (K.extendOpcyclesIso e hj').hom =\n      (K.extendXIso e hj').hom \u226b K.pOpcycles j := by\n  simp only [\u2190 cancel_mono (K.extendOpcyclesIso e hj').inv,\n    assoc, Iso.hom_inv_id, comp_id, pOpcycles_extendOpcyclesIso_inv, Iso.hom_inv_id_assoc]\n\n", "theoremStatement": "@[reassoc (attr := simp)]\nlemma extendHomologyIso_hom_homology\u03b9 :\n    (K.extendHomologyIso e hj').hom \u226b K.homology\u03b9 j =\n      (K.extend e).homology\u03b9 j' \u226b (K.extendOpcyclesIso e hj').hom ", "theoremName": "HomologicalComplex.extendHomologyIso_hom_homology\u03b9", "fileCreated": {"commit": "9bdc1af76cf75d960f42c29f1c09917785066c8b", "date": "2024-11-30"}, "theoremCreated": {"commit": "b07a551a1451cbf8615f4e2a6c47052affadbae4", "date": "2025-01-17"}, "file": "mathlib/Mathlib/Algebra/Homology/Embedding/ExtendHomology.lean", "module": "Mathlib.Algebra.Homology.Embedding.ExtendHomology", "jsonFile": "Mathlib.Algebra.Homology.Embedding.ExtendHomology.jsonl", "positionMetadata": {"lineInFile": 377, "tokenPositionInFile": 15301, "theoremPositionInFile": 28}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 6, "repositoryPremises": true, "numRepositoryPremises": 33, "numPremises": 42}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp only [\u2190 cancel_epi ((K.extend e).homology\u03c0 j'),\n    homology\u03c0_extendHomologyIso_hom_assoc, homology_\u03c0_\u03b9, extendCyclesIso_hom_iCycles_assoc,\n    homology_\u03c0_\u03b9_assoc, pOpcycles_extendOpcyclesIso_hom]", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 209}}
{"srcContext": "/-\nCopyright (c) 2023 Jujian Zhang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jujian Zhang, Junyan Xu\n-/\n\nimport Mathlib.Algebra.Category.ModuleCat.Basic\nimport Mathlib.Algebra.Category.Grp.Injective\nimport Mathlib.Topology.Instances.AddCircle\nimport Mathlib.LinearAlgebra.Isomorphisms\n\n/-!\n# Character module of a module\n\nFor commutative ring `R` and an `R`-module `M` and an injective module `D`, its character module\n`M\u22c6` is defined to be `R`-linear maps `M \u27f6 D`.\n\n`M\u22c6` also has an `R`-module structure given by `(r \u2022 f) m = f (r \u2022 m)`.\n\n## Main results\n\n- `CharacterModuleFunctor` : the contravariant functor of `R`-modules where `M \u21a6 M\u22c6` and\nan `R`-linear map `l : M \u27f6 N` induces an `R`-linear map `l\u22c6 : f \u21a6 f \u2218 l` where `f : N\u22c6`.\n- `LinearMap.dual_surjective_of_injective` : If `l` is injective then `l\u22c6` is surjective,\n  in another word taking character module as a functor sends monos to epis.\n- `CharacterModule.homEquiv` : there is a bijection between linear map `Hom(N, M\u22c6)` and\n  `(N \u2297 M)\u22c6` given by `curry` and `uncurry`.\n\n-/\n\nopen CategoryTheory\n\nuniverse uR uA uB\n\nvariable (R : Type uR) [CommRing R]\nvariable (A : Type uA) [AddCommGroup A]\nvariable (A' : Type*) [AddCommGroup A']\nvariable (B : Type uB) [AddCommGroup B]\n\n/--\nThe character module of an abelian group `A` in the unit rational circle is `A\u22c6 := Hom_\u2124(A, \u211a \u29f8 \u2124)`.\n-/\ndef CharacterModule : Type uA := A \u2192+ AddCircle (1 : \u211a)\n\nnamespace CharacterModule\n\ninstance : FunLike (CharacterModule A) A (AddCircle (1 : \u211a)) where\n  coe c := c.toFun\n  coe_injective' _ _ _ := by aesop\n\ninstance : LinearMapClass (CharacterModule A) \u2124 A (AddCircle (1 : \u211a)) where\n  map_add _ _ _ := by rw [AddMonoidHom.map_add]\n  map_smul\u209b\u2097 _ _ _ := by rw [AddMonoidHom.map_zsmul, RingHom.id_apply]\n\ninstance : AddCommGroup (CharacterModule A) :=\n  inferInstanceAs (AddCommGroup (A \u2192+ _))\n\n@[ext] theorem ext {c c' : CharacterModule A} (h : \u2200 x, c x = c' x) : c = c' := DFunLike.ext _ _ h\n\nsection module\n\nvariable [Module R A] [Module R A'] [Module R B]\n\ninstance : Module R (CharacterModule A) :=\n  Module.compHom (A \u2192+ _) (RingEquiv.toOpposite _ |>.toRingHom : R \u2192+* R\u1d48\u1d50\u1d43)\n\nvariable {R A B}\n\n@[simp] lemma smul_apply (c : CharacterModule A) (r : R) (a : A) : (r \u2022 c) a = c (r \u2022 a) := rfl\n\n/--\nGiven an abelian group homomorphism `f : A \u2192 B`, `f\u22c6(L) := L \u2218 f` defines a linear map\nfrom `B\u22c6` to `A\u22c6`.\n-/\n@[simps] def dual (f : A \u2192\u2097[R] B) : CharacterModule B \u2192\u2097[R] CharacterModule A where\n  toFun L := L.comp f.toAddMonoidHom\n  map_add' := by aesop\n  map_smul' r c := by ext x; exact congr(c $(f.map_smul r x)).symm\n\n@[simp]\nlemma dual_zero : dual (0 : A \u2192\u2097[R] B) = 0 := by\n  ext f\n  exact map_zero f\n\nlemma dual_comp {C : Type*} [AddCommGroup C] [Module R C] (f : A \u2192\u2097[R] B) (g : B \u2192\u2097[R] C) :\n    dual (g.comp f) = (dual f).comp (dual g) := by\n  ext\n  rfl\n\nlemma dual_injective_of_surjective (f : A \u2192\u2097[R] B) (hf : Function.Surjective f) :\n    Function.Injective (dual f) := by\n  intro \u03c6 \u03c8 eq\n  ext x\n  obtain \u27e8y, rfl\u27e9 := hf x\n  change (dual f) \u03c6 _ = (dual f) \u03c8 _\n  rw [eq]\n\nlemma dual_surjective_of_injective (f : A \u2192\u2097[R] B) (hf : Function.Injective f) :\n    Function.Surjective (dual f) :=\n  (Module.Baer.of_divisible _).extension_property_addMonoidHom _ hf\n\n/--\nTwo isomorphic modules have isomorphic character modules.\n-/\ndef congr (e : A \u2243\u2097[R] B) : CharacterModule A \u2243\u2097[R] CharacterModule B :=\n  .ofLinear (dual e.symm) (dual e)\n    (by ext c _; exact congr(c $(e.right_inv _)))\n    (by ext c _; exact congr(c $(e.left_inv _)))\n\nopen TensorProduct\n\n/--\nAny linear map `L : A \u2192 B\u22c6` induces a character in `(A \u2297 B)\u22c6` by `a \u2297 b \u21a6 L a b`.\n-/\n@[simps] noncomputable def uncurry :\n    (A \u2192\u2097[R] CharacterModule B) \u2192\u2097[R] CharacterModule (A \u2297[R] B) where\n  toFun c := TensorProduct.liftAddHom c.toAddMonoidHom fun r a b \u21a6 congr($(c.map_smul r a) b)\n  map_add' c c' := DFunLike.ext _ _ fun x \u21a6 by refine x.induction_on ?_ ?_ ?_ <;> aesop\n  map_smul' r c := DFunLike.ext _ _ fun x \u21a6 x.induction_on\n    (by simp_rw [map_zero]) (fun a b \u21a6 congr($(c.map_smul r a) b).symm) (by aesop)\n\n/--\nAny character `c` in `(A \u2297 B)\u22c6` induces a linear map `A \u2192 B\u22c6` by `a \u21a6 b \u21a6 c (a \u2297 b)`.\n-/\n@[simps] noncomputable def curry :\n    CharacterModule (A \u2297[R] B) \u2192\u2097[R] (A \u2192\u2097[R] CharacterModule B) where\n  toFun c :=\n  { toFun := (c.comp <| TensorProduct.mk R A B \u00b7)\n    map_add' := fun _ _ \u21a6 DFunLike.ext _ _ fun b \u21a6\n      congr(c <| $(map_add (mk R A B) _ _) b).trans (c.map_add _ _)\n    map_smul' := fun r a \u21a6 by ext; exact congr(c $(TensorProduct.tmul_smul _ _ _)).symm }\n  map_add' _ _ := rfl\n  map_smul' r c := by ext; exact congr(c $(TensorProduct.tmul_smul _ _ _)).symm\n\n/--\nLinear maps into a character module are exactly characters of the tensor product.\n-/\n@[simps!] noncomputable def homEquiv :\n    (A \u2192\u2097[R] CharacterModule B) \u2243\u2097[R] CharacterModule (A \u2297[R] B) :=\n  .ofLinear uncurry curry (by ext _ z; refine z.induction_on ?_ ?_ ?_ <;> aesop) (by aesop)\n\ntheorem dual_rTensor_conj_homEquiv (f : A \u2192\u2097[R] A') :\n    homEquiv.symm.toLinearMap \u2218\u2097 dual (f.rTensor B) \u2218\u2097 homEquiv.toLinearMap = f.lcomp R _ := rfl\n\nend module\n\n/--\n`\u2124\u22c6`, the character module of `\u2124` in the unit rational circle.\n-/\nprotected abbrev int : Type := CharacterModule \u2124\n\n/-- Given `n : \u2115`, the map `m \u21a6 m / n`. -/\nprotected abbrev int.divByNat (n : \u2115) : CharacterModule.int :=\n  LinearMap.toSpanSingleton \u2124 _ (QuotientAddGroup.mk (n : \u211a)\u207b\u00b9) |>.toAddMonoidHom\n\nprotected lemma int.divByNat_self (n : \u2115) :\n    int.divByNat n n = 0 := by\n  obtain rfl | h0 := eq_or_ne n 0\n  \u00b7 apply map_zero\n  exact (AddCircle.coe_eq_zero_iff _).mpr\n    \u27e81, by simp [mul_inv_cancel\u2080 (Nat.cast_ne_zero (R := \u211a).mpr h0)]\u27e9\n\nvariable {A}\n\n/-- The `\u2124`-submodule spanned by a single element `a` is isomorphic to the quotient of `\u2124`\nby the ideal generated by the order of `a`. -/\n@[simps!] noncomputable def intSpanEquivQuotAddOrderOf (a : A) :\n    (\u2124 \u2219 a) \u2243\u2097[\u2124] \u2124 \u29f8 Ideal.span {(addOrderOf a : \u2124)} :=\n  LinearEquiv.ofEq _ _ (LinearMap.span_singleton_eq_range \u2124 A a) \u226a\u226b\u2097\n  (LinearMap.quotKerEquivRange <| LinearMap.toSpanSingleton \u2124 A a).symm \u226a\u226b\u2097\n  Submodule.quotEquivOfEq _ _ (by\n    ext1 x\n    rw [Ideal.mem_span_singleton, addOrderOf_dvd_iff_zsmul_eq_zero, LinearMap.mem_ker,\n      LinearMap.toSpanSingleton_apply])\n\nlemma intSpanEquivQuotAddOrderOf_apply_self (a : A) :\n    intSpanEquivQuotAddOrderOf a \u27e8a, Submodule.mem_span_singleton_self a\u27e9 =\n    Submodule.Quotient.mk 1 :=\n  (LinearEquiv.eq_symm_apply _).mp <| Subtype.ext (one_zsmul _).symm\n\n/--\nFor an abelian group `A` and an element `a \u2208 A`, there is a character `c : \u2124 \u2219 a \u2192 \u211a \u29f8 \u2124` given by\n`m \u2022 a \u21a6 m / n` where `n` is the smallest positive integer such that `n \u2022 a = 0` and when such `n`\ndoes not exist, `c` is defined by `m \u2022 a \u21a6 m / 2`.\n-/\nnoncomputable def ofSpanSingleton (a : A) : CharacterModule (\u2124 \u2219 a) :=\n  let l :  \u2124 \u29f8 Ideal.span {(addOrderOf a : \u2124)} \u2192\u2097[\u2124] AddCircle (1 : \u211a) :=\n    Submodule.liftQSpanSingleton _\n      (CharacterModule.int.divByNat <|\n        if addOrderOf a = 0 then 2 else addOrderOf a).toIntLinearMap <| by\n        split_ifs with h\n        \u00b7 rw [h, Nat.cast_zero, map_zero]\n        \u00b7 apply CharacterModule.int.divByNat_self\n  l \u2218\u2097 intSpanEquivQuotAddOrderOf a |>.toAddMonoidHom\n\nlemma eq_zero_of_ofSpanSingleton_apply_self (a : A)\n    (h : ofSpanSingleton a \u27e8a, Submodule.mem_span_singleton_self a\u27e9 = 0) : a = 0 := by\n  erw [ofSpanSingleton, LinearMap.toAddMonoidHom_coe, LinearMap.comp_apply,\n     intSpanEquivQuotAddOrderOf_apply_self, Submodule.liftQSpanSingleton_apply,\n    AddMonoidHom.coe_toIntLinearMap, int.divByNat, LinearMap.toSpanSingleton_one,\n    AddCircle.coe_eq_zero_iff] at h\n  rcases h with \u27e8n, hn\u27e9\n  apply_fun Rat.den at hn\n  rw [zsmul_one, Rat.den_intCast, Rat.inv_natCast_den_of_pos] at hn\n  \u00b7 split_ifs at hn\n    \u00b7 cases hn\n    \u00b7 rwa [eq_comm, AddMonoid.addOrderOf_eq_one_iff] at hn\n  \u00b7 split_ifs with h\n    \u00b7 norm_num\n    \u00b7 exact Nat.pos_of_ne_zero h\n\nlemma exists_character_apply_ne_zero_of_ne_zero {a : A} (ne_zero : a \u2260 0) :\n    \u2203 (c : CharacterModule A), c a \u2260 0 :=\n  have \u27e8c, hc\u27e9 := dual_surjective_of_injective _ (Submodule.injective_subtype _) (ofSpanSingleton a)\n  \u27e8c, fun h \u21a6 ne_zero <| eq_zero_of_ofSpanSingleton_apply_self a <| by rwa [\u2190 hc]\u27e9\n\nlemma eq_zero_of_character_apply {a : A} (h : \u2200 c : CharacterModule A, c a = 0) : a = 0 := by\n  contrapose! h; exact exists_character_apply_ne_zero_of_ne_zero h\n\nvariable [Module R A] [Module R A'] [Module R B] {R A' B}\n\nlemma dual_surjective_iff_injective {f : A \u2192\u2097[R] A'} :\n    Function.Surjective (dual f) \u2194 Function.Injective f :=\n  \u27e8fun h \u21a6 (injective_iff_map_eq_zero _).2 fun a h0 \u21a6 eq_zero_of_character_apply fun c \u21a6 by\n    obtain \u27e8c, rfl\u27e9 := h c; exact congr(c $h0).trans c.map_zero,\n  dual_surjective_of_injective f\u27e9\n\ntheorem _root_.rTensor_injective_iff_lcomp_surjective {f : A \u2192\u2097[R] A'} :\n    Function.Injective (f.rTensor B) \u2194 Function.Surjective (f.lcomp R <| CharacterModule B) := by\n  simp [\u2190 dual_rTensor_conj_homEquiv, dual_surjective_iff_injective]\n\nlemma surjective_of_dual_injective (f : A \u2192\u2097[R] A') (hf : Function.Injective (dual f)) :\n    Function.Surjective f := by\n  rw [\u2190 LinearMap.range_eq_top, \u2190 Submodule.unique_quotient_iff_eq_top]\n  refine \u27e8Unique.mk inferInstance fun a \u21a6 eq_zero_of_character_apply fun c \u21a6 ?_\u27e9\n  obtain \u27e8b, rfl\u27e9 := QuotientAddGroup.mk'_surjective _ a\n  suffices eq : dual (Submodule.mkQ _) c = 0 from congr($eq b)\n  refine hf ?_\n  rw [\u2190 LinearMap.comp_apply, \u2190 dual_comp, LinearMap.range_mkQ_comp, dual_zero]\n  rfl\n\nlemma dual_injective_iff_surjective {f : A \u2192\u2097[R] A'} :\n    Function.Injective (dual f) \u2194 Function.Surjective f :=\n  \u27e8fun h \u21a6 surjective_of_dual_injective f h, fun h \u21a6 dual_injective_of_surjective f h\u27e9\n\n", "theoremStatement": "lemma dual_bijective_iff_bijective {f : A \u2192\u2097[R] A'} :\n    Function.Bijective (dual f) \u2194 Function.Bijective f ", "theoremName": "CharacterModule.dual_bijective_iff_bijective", "fileCreated": {"commit": "65d37dc6412f280a667037cd83fc1f1423cb14cb", "date": "2024-02-27"}, "theoremCreated": {"commit": "e43c7732f3e074817dad5659dbc751a3a3bc9b1c", "date": "2025-01-20"}, "file": "mathlib/Mathlib/Algebra/Module/CharacterModule.lean", "module": "Mathlib.Algebra.Module.CharacterModule", "jsonFile": "Mathlib.Algebra.Module.CharacterModule.jsonl", "positionMetadata": {"lineInFile": 246, "tokenPositionInFile": 9665, "theoremPositionInFile": 23}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 6, "repositoryPremises": true, "numRepositoryPremises": 20, "numPremises": 27}, "proofMetadata": {"hasProof": true, "proof": ":=\n  \u27e8fun h \u21a6 \u27e8dual_surjective_iff_injective.mp h.2, dual_injective_iff_surjective.mp h.1\u27e9,\n  fun h \u21a6 \u27e8dual_injective_iff_surjective.mpr h.2, dual_surjective_iff_injective.mpr h.1\u27e9\u27e9", "proofType": "term", "proofLengthLines": 2, "proofLengthTokens": 181}}
{"srcContext": "/-\nCopyright (c) 2024 Fangming Li. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Fangming Li, Jujian Zhang\n-/\nimport Mathlib.Algebra.Polynomial.AlgebraMap\nimport Mathlib.Algebra.Polynomial.Eval.SMul\nimport Mathlib.Algebra.Polynomial.Roots\nimport Mathlib.Order.Interval.Set.Infinite\nimport Mathlib.RingTheory.Polynomial.Pochhammer\nimport Mathlib.RingTheory.PowerSeries.WellKnown\nimport Mathlib.Tactic.FieldSimp\n\n/-!\n# Hilbert polynomials\n\nIn this file, we formalise the following statement: if `F` is a field with characteristic `0`, then\ngiven any `p : F[X]` and `d : \u2115`, there exists some `h : F[X]` such that for any large enough\n`n : \u2115`, `h(n)` is equal to the coefficient of `X\u207f` in the power series expansion of `p/(1 - X)\u1d48`.\nThis `h` is unique and is denoted as `Polynomial.hilbertPoly p d`.\n\nFor example, given `d : \u2115`, the power series expansion of `1/(1 - X)\u1d48\u207a\u00b9` in `F[X]`\nis `\u03a3\u2099 ((d + n).choose d)X\u207f`, which equals `\u03a3\u2099 ((n + 1)\u00b7\u00b7\u00b7(n + d)/d!)X\u207f` and hence\n`Polynomial.hilbertPoly (1 : F[X]) (d + 1)` is the polynomial `(X + 1)\u00b7\u00b7\u00b7(X + d)/d!`. Note that\nif `d! = 0` in `F`, then the polynomial `(X + 1)\u00b7\u00b7\u00b7(X + d)/d!` no longer works, so we do not want\nthe characteristic of `F` to be divisible by `d!`. As `Polynomial.hilbertPoly` may take any\n`p : F[X]` and `d : \u2115` as its inputs, it is necessary for us to assume that `CharZero F`.\n\n## Main definitions\n\n* `Polynomial.hilbertPoly p d`. Given a field `F`, a polynomial `p : F[X]` and a natural number `d`,\n  if `F` is of characteristic `0`, then `Polynomial.hilbertPoly p d : F[X]` is the polynomial whose\n  value at `n` equals the coefficient of `X\u207f` in the power series expansion of `p/(1 - X)\u1d48`.\n\n## TODO\n\n* Hilbert polynomials of finitely generated graded modules over Noetherian rings.\n-/\n\nopen Nat PowerSeries\n\nvariable (F : Type*) [Field F]\n\nnamespace Polynomial\n\n/--\nFor any field `F` and natural numbers `d` and `k`, `Polynomial.preHilbertPoly F d k`\nis defined as `(d.factorial : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (X - (C (k : F)) + 1))`.\nThis is the most basic form of Hilbert polynomials. `Polynomial.preHilbertPoly \u211a d 0`\nis exactly the Hilbert polynomial of the polynomial ring `\u211a[X_0,...,X_d]` viewed as\na graded module over itself. In fact, `Polynomial.preHilbertPoly F d k` is the\nsame as `Polynomial.hilbertPoly ((X : F[X]) ^ k) (d + 1)` for any field `F` and\n`d k : \u2115` (see the lemma `Polynomial.hilbertPoly_X_pow_succ`). See also the lemma\n`Polynomial.preHilbertPoly_eq_choose_sub_add`, which states that if `CharZero F`,\nthen for any `d k n : \u2115` with `k \u2264 n`, `(Polynomial.preHilbertPoly F d k).eval (n : F)`\nequals `(n - k + d).choose d`.\n-/\nnoncomputable def preHilbertPoly (d k : \u2115) : F[X] :=\n  (d.factorial : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (Polynomial.X - (C (k : F)) + 1))\n\nlemma natDegree_preHilbertPoly [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).natDegree = d := by\n  have hne : (d ! : F) \u2260 0 := by norm_cast; positivity\n  rw [preHilbertPoly, natDegree_smul _ (inv_ne_zero hne), natDegree_comp, ascPochhammer_natDegree,\n    add_comm_sub, \u2190 C_1, \u2190 map_sub, natDegree_add_C, natDegree_X, mul_one]\n\nlemma coeff_preHilbertPoly_self [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).coeff d = (d ! : F)\u207b\u00b9 := by\n  delta preHilbertPoly\n  have hne : (d ! : F) \u2260 0 := by norm_cast; positivity\n  have heq : d = ((ascPochhammer F d).comp (X - C (k : F) + 1)).natDegree :=\n    (natDegree_preHilbertPoly F d k).symm.trans (natDegree_smul _ (inv_ne_zero hne))\n  nth_rw 3 [heq]\n  calc\n  _ = (d ! : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (X - C ((k : F) - 1))).leadingCoeff := by\n    simp only [sub_add, \u2190 C_1, \u2190 map_sub, coeff_smul, coeff_natDegree]\n  _ = (d ! : F)\u207b\u00b9 := by\n    simp only [leadingCoeff_comp (ne_of_eq_of_ne (natDegree_X_sub_C _) one_ne_zero), Monic.def.1\n      (monic_ascPochhammer _ _), one_mul, leadingCoeff_X_sub_C, one_pow, smul_eq_mul, mul_one]\n\nlemma leadingCoeff_preHilbertPoly [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).leadingCoeff = (d ! : F)\u207b\u00b9 := by\n  rw [leadingCoeff, natDegree_preHilbertPoly, coeff_preHilbertPoly_self]\n\nlemma preHilbertPoly_eq_choose_sub_add [CharZero F] (d : \u2115) {k n : \u2115} (hkn : k \u2264 n):\n    (preHilbertPoly F d k).eval (n : F) = (n - k + d).choose d := by\n  have : (d ! : F) \u2260 0 := by norm_cast; positivity\n  calc\n  _ = (\u2191d !)\u207b\u00b9 * eval (\u2191(n - k + 1)) (ascPochhammer F d) := by simp [cast_sub hkn, preHilbertPoly]\n  _ = (n - k + d).choose d := by\n    rw [ascPochhammer_nat_eq_natCast_ascFactorial];\n    field_simp [ascFactorial_eq_factorial_mul_choose]\n\nvariable {F}\n\n/--\n`Polynomial.hilbertPoly p 0 = 0`; for any `d : \u2115`, `Polynomial.hilbertPoly p (d + 1)`\nis defined as `\u2211 i \u2208 p.support, (p.coeff i) \u2022 Polynomial.preHilbertPoly F d i`. If\n`M` is a graded module whose Poincar\u00e9 series can be written as `p(X)/(1 - X)\u1d48` for some\n`p : \u211a[X]` with integer coefficients, then `Polynomial.hilbertPoly p d` is the Hilbert\npolynomial of `M`. See also `Polynomial.coeff_mul_invOneSubPow_eq_hilbertPoly_eval`,\nwhich says that `PowerSeries.coeff F n (p * PowerSeries.invOneSubPow F d)` equals\n`(Polynomial.hilbertPoly p d).eval (n : F)` for any large enough `n : \u2115`.\n-/\nnoncomputable def hilbertPoly (p : F[X]) : (d : \u2115) \u2192 F[X]\n  | 0 => 0\n  | d + 1 => \u2211 i \u2208 p.support, (p.coeff i) \u2022 preHilbertPoly F d i\n\nlemma hilbertPoly_zero_left (d : \u2115) : hilbertPoly (0 : F[X]) d = 0 := by\n  delta hilbertPoly; induction d with\n  | zero => simp only\n  | succ d _ => simp only [coeff_zero, zero_smul, Finset.sum_const_zero]\n\nlemma hilbertPoly_zero_right (p : F[X]) : hilbertPoly p 0 = 0 := rfl\n\nlemma hilbertPoly_succ (p : F[X]) (d : \u2115) :\n    hilbertPoly p (d + 1) = \u2211 i \u2208 p.support, (p.coeff i) \u2022 preHilbertPoly F d i := rfl\n\nlemma hilbertPoly_X_pow_succ (d k : \u2115) :\n    hilbertPoly ((X : F[X]) ^ k) (d + 1) = preHilbertPoly F d k := by\n  delta hilbertPoly; simp\n\nlemma hilbertPoly_add_left (p q : F[X]) (d : \u2115) :\n    hilbertPoly (p + q) d = hilbertPoly p d + hilbertPoly q d := by\n  delta hilbertPoly\n  induction d with\n  | zero => simp only [add_zero]\n  | succ d _ =>\n      simp only [\u2190 coeff_add]\n      rw [\u2190 sum_def _ fun _ r => r \u2022 _]\n      exact sum_add_index _ _ _ (fun _ => zero_smul ..) (fun _ _ _ => add_smul ..)\n\nlemma hilbertPoly_smul (a : F) (p : F[X]) (d : \u2115) :\n    hilbertPoly (a \u2022 p) d = a \u2022 hilbertPoly p d := by\n  delta hilbertPoly\n  induction d with\n  | zero => simp only [smul_zero]\n  | succ d _ =>\n      simp only\n      rw [\u2190 sum_def _ fun _ r => r \u2022 _, \u2190 sum_def _ fun _ r => r \u2022 _, Polynomial.smul_sum,\n        sum_smul_index' _ _ _ fun i => zero_smul F (preHilbertPoly F d i)]\n      simp only [smul_assoc]\n\nvariable (F) in\n/--\nThe function that sends any `p : F[X]` to `Polynomial.hilbertPoly p d` is an `F`-linear map from\n`F[X]` to `F[X]`.\n-/\nnoncomputable def hilbertPoly_linearMap (d : \u2115) : F[X] \u2192\u2097[F] F[X] where\n  toFun p := hilbertPoly p d\n  map_add' p q := hilbertPoly_add_left p q d\n  map_smul' r p := hilbertPoly_smul r p d\n\nvariable [CharZero F]\n\n", "theoremStatement": "/--\nThe key property of Hilbert polynomials. If `F` is a field with characteristic `0`, `p : F[X]` and\n`d : \u2115`, then for any large enough `n : \u2115`, `(Polynomial.hilbertPoly p d).eval (n : F)` equals the\ncoefficient of `X\u207f` in the power series expansion of `p/(1 - X)\u1d48`.\n-/\ntheorem coeff_mul_invOneSubPow_eq_hilbertPoly_eval\n    {p : F[X]} (d : \u2115) {n : \u2115} (hn : p.natDegree < n) :\n    PowerSeries.coeff F n (p * invOneSubPow F d) = (hilbertPoly p d).eval (n : F) ", "theoremName": "Polynomial.coeff_mul_invOneSubPow_eq_hilbertPoly_eval", "fileCreated": {"commit": "561e050467d2caa2e4ea5d81ca62600bf268b747", "date": "2024-12-02"}, "theoremCreated": {"commit": "561e050467d2caa2e4ea5d81ca62600bf268b747", "date": "2024-12-02"}, "file": "mathlib/Mathlib/RingTheory/Polynomial/HilbertPoly.lean", "module": "Mathlib.RingTheory.Polynomial.HilbertPoly", "jsonFile": "Mathlib.RingTheory.Polynomial.HilbertPoly.jsonl", "positionMetadata": {"lineInFile": 156, "tokenPositionInFile": 6945, "theoremPositionInFile": 11}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 121, "numPremises": 175}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  delta hilbertPoly; induction d with\n  | zero => simp only [invOneSubPow_zero, Units.val_one, mul_one, coeff_coe, eval_zero]\n            exact coeff_eq_zero_of_natDegree_lt hn\n  | succ d hd =>\n      simp only [eval_finset_sum, eval_smul, smul_eq_mul]\n      rw [\u2190 Finset.sum_coe_sort]\n      have h_le (i : p.support) : (i : \u2115) \u2264 n :=\n        le_trans (le_natDegree_of_ne_zero <| mem_support_iff.1 i.2) hn.le\n      have h (i : p.support) : eval \u2191n (preHilbertPoly F d \u2191i) = (n + d - \u2191i).choose d := by\n        rw [preHilbertPoly_eq_choose_sub_add _ _ (h_le i), Nat.sub_add_comm (h_le i)]\n      simp_rw [h]\n      rw [Finset.sum_coe_sort _ (fun x => (p.coeff \u2191x) * (_ + d - \u2191x).choose _),\n        PowerSeries.coeff_mul, Finset.Nat.sum_antidiagonal_eq_sum_range_succ_mk,\n        invOneSubPow_val_eq_mk_sub_one_add_choose_of_pos _ _ (zero_lt_succ d)]\n      simp only [coeff_coe, coeff_mk]\n      symm\n      refine Finset.sum_subset_zero_on_sdiff (fun s hs \u21a6 ?_) (fun x hx \u21a6 ?_) (fun x hx \u21a6 ?_)\n      \u00b7 rw [Finset.mem_range_succ_iff]\n        exact h_le \u27e8s, hs\u27e9\n      \u00b7 simp only [Finset.mem_sdiff, mem_support_iff, not_not] at hx\n        rw [hx.2, zero_mul]\n      \u00b7 rw [add_comm, Nat.add_sub_assoc (h_le \u27e8x, hx\u27e9), succ_eq_add_one, add_tsub_cancel_right]", "proofType": "tactic", "proofLengthLines": 22, "proofLengthTokens": 1252}}
{"srcContext": "/-\nCopyright (c) 2020 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\nimport Mathlib.Algebra.Algebra.Rat\nimport Mathlib.Algebra.BigOperators.NatAntidiagonal\nimport Mathlib.Data.Nat.Choose.Sum\nimport Mathlib.RingTheory.PowerSeries.Basic\n\n/-!\n# Definition of well-known power series\n\nIn this file we define the following power series:\n\n* `PowerSeries.invUnitsSub`: given `u : R\u02e3`, this is the series for `1 / (u - x)`.\n  It is given by `\u2211 n, x ^ n /\u209a u ^ (n + 1)`.\n\n* `PowerSeries.invOneSubPow`: given a commutative ring `S` and a number `d : \u2115`,\n  `PowerSeries.invOneSubPow S d` is the multiplicative inverse of `(1 - X) ^ d` in `S\u27e6X\u27e7\u02e3`.\n  When `d` is `0`, `PowerSeries.invOneSubPow S d` will just be `1`. When `d` is positive,\n  `PowerSeries.invOneSubPow S d` will be `\u2211 n, Nat.choose (d - 1 + n) (d - 1)`.\n\n* `PowerSeries.sin`, `PowerSeries.cos`, `PowerSeries.exp` : power series for sin, cosine, and\n  exponential functions.\n-/\n\n\nnamespace PowerSeries\n\nsection Ring\n\nvariable {R S : Type*} [Ring R] [Ring S]\n\n/-- The power series for `1 / (u - x)`. -/\ndef invUnitsSub (u : R\u02e3) : PowerSeries R :=\n  mk fun n => 1 /\u209a u ^ (n + 1)\n\n@[simp]\ntheorem coeff_invUnitsSub (u : R\u02e3) (n : \u2115) : coeff R n (invUnitsSub u) = 1 /\u209a u ^ (n + 1) :=\n  coeff_mk _ _\n\n@[simp]\ntheorem constantCoeff_invUnitsSub (u : R\u02e3) : constantCoeff R (invUnitsSub u) = 1 /\u209a u := by\n  rw [\u2190 coeff_zero_eq_constantCoeff_apply, coeff_invUnitsSub, zero_add, pow_one]\n\n@[simp]\ntheorem invUnitsSub_mul_X (u : R\u02e3) : invUnitsSub u * X = invUnitsSub u * C R u - 1 := by\n  ext (_ | n)\n  \u00b7 simp\n  \u00b7 simp [n.succ_ne_zero, pow_succ']\n\n@[simp]\ntheorem invUnitsSub_mul_sub (u : R\u02e3) : invUnitsSub u * (C R u - X) = 1 := by\n  simp [mul_sub, sub_sub_cancel]\n\ntheorem map_invUnitsSub (f : R \u2192+* S) (u : R\u02e3) :\n    map f (invUnitsSub u) = invUnitsSub (Units.map (f : R \u2192* S) u) := by\n  ext\n  simp only [\u2190 map_pow, coeff_map, coeff_invUnitsSub, one_divp]\n  rfl\n\nend Ring\n\nsection invOneSubPow\n\nvariable (S : Type*) [CommRing S] (d : \u2115)\n\n/--\n(1 + X + X^2 + ...) * (1 - X) = 1.\n\nNote that the power series `1 + X + X^2 + ...` is written as `mk 1` where `1` is the constant\nfunction so that `mk 1` is the power series with all coefficients equal to one.\n-/\ntheorem mk_one_mul_one_sub_eq_one : (mk 1 : S\u27e6X\u27e7) * (1 - X) = 1 := by\n  rw [mul_comm, PowerSeries.ext_iff]\n  intro n\n  cases n with\n  | zero => simp\n  | succ n => simp [sub_mul]\n\n/--\nNote that `mk 1` is the constant function `1` so the power series `1 + X + X^2 + ...`. This theorem\nstates that for any `d : \u2115`, `(1 + X + X^2 + ... : S\u27e6X\u27e7) ^ (d + 1)` is equal to the power series\n`mk fun n => Nat.choose (d + n) d : S\u27e6X\u27e7`.\n-/\ntheorem mk_one_pow_eq_mk_choose_add :\n    (mk 1 : S\u27e6X\u27e7) ^ (d + 1) = (mk fun n => Nat.choose (d + n) d : S\u27e6X\u27e7) := by\n  induction d with\n  | zero => ext; simp\n  | succ d hd =>\n      ext n\n      rw [pow_add, hd, pow_one, mul_comm, coeff_mul]\n      simp_rw [coeff_mk, Pi.one_apply, one_mul]\n      norm_cast\n      rw [Finset.sum_antidiagonal_choose_add, add_right_comm]\n\n/--\nGiven a natural number `d : \u2115` and a commutative ring `S`, `PowerSeries.invOneSubPow S d` is the\nmultiplicative inverse of `(1 - X) ^ d` in `S\u27e6X\u27e7\u02e3`. When `d` is `0`, `PowerSeries.invOneSubPow S d`\nwill just be `1`. When `d` is positive, `PowerSeries.invOneSubPow S d` will be the power series\n`mk fun n => Nat.choose (d - 1 + n) (d - 1)`.\n-/\nnoncomputable def invOneSubPow : \u2115 \u2192 S\u27e6X\u27e7\u02e3\n  | 0 => 1\n  | d + 1 => {\n    val := mk fun n => Nat.choose (d + n) d\n    inv := (1 - X) ^ (d + 1)\n    val_inv := by\n      rw [\u2190 mk_one_pow_eq_mk_choose_add, \u2190 mul_pow, mk_one_mul_one_sub_eq_one, one_pow]\n    inv_val := by\n      rw [\u2190 mk_one_pow_eq_mk_choose_add, \u2190 mul_pow, mul_comm, mk_one_mul_one_sub_eq_one, one_pow]\n    }\n\ntheorem invOneSubPow_zero : invOneSubPow S 0 = 1 := by\n  delta invOneSubPow\n  simp only [Units.val_one]\n\ntheorem invOneSubPow_val_eq_mk_sub_one_add_choose_of_pos (h : 0 < d) :\n    (invOneSubPow S d).val = (mk fun n => Nat.choose (d - 1 + n) (d - 1) : S\u27e6X\u27e7) := by\n  rw [\u2190 Nat.sub_one_add_one_eq_of_pos h, invOneSubPow, add_tsub_cancel_right]\n\ntheorem invOneSubPow_val_succ_eq_mk_add_choose :\n    (invOneSubPow S (d + 1)).val = (mk fun n => Nat.choose (d + n) d : S\u27e6X\u27e7) := rfl\n\ntheorem invOneSubPow_val_one_eq_invUnitSub_one :\n    (invOneSubPow S 1).val = invUnitsSub (1 : S\u02e3) := by\n  simp [invOneSubPow, invUnitsSub]\n\n/--\nThe theorem `PowerSeries.mk_one_mul_one_sub_eq_one` implies that `1 - X` is a unit in `S\u27e6X\u27e7`\nwhose inverse is the power series `1 + X + X^2 + ...`. This theorem states that for any `d : \u2115`,\n`PowerSeries.invOneSubPow S d` is equal to `(1 - X)\u207b\u00b9 ^ d`.\n-/\ntheorem invOneSubPow_eq_inv_one_sub_pow :\n    invOneSubPow S d =\n      (Units.mkOfMulEqOne (1 - X) (mk 1 : S\u27e6X\u27e7) <|\n        Eq.trans (mul_comm _ _) (mk_one_mul_one_sub_eq_one S))\u207b\u00b9 ^ d := by\n  induction d with\n  | zero => exact Eq.symm <| pow_zero _\n  | succ d _ =>\n      rw [inv_pow]\n      exact (DivisionMonoid.inv_eq_of_mul _ (invOneSubPow S (d + 1)) <| by\n        rw [\u2190 Units.val_eq_one, Units.val_mul, Units.val_pow_eq_pow_val]\n        exact (invOneSubPow S (d + 1)).inv_val).symm\n\ntheorem invOneSubPow_inv_eq_one_sub_pow :\n    (invOneSubPow S d).inv = (1 - X : S\u27e6X\u27e7) ^ d := by\n  induction d with\n  | zero => exact Eq.symm <| pow_zero _\n  | succ d => rfl\n\ntheorem invOneSubPow_inv_zero_eq_one : (invOneSubPow S 0).inv = 1 := by\n  delta invOneSubPow\n  simp only [Units.inv_eq_val_inv, inv_one, Units.val_one]\n\ntheorem mk_add_choose_mul_one_sub_pow_eq_one :\n    (mk fun n \u21a6 Nat.choose (d + n) d : S\u27e6X\u27e7) * ((1 - X) ^ (d + 1)) = 1 :=\n  (invOneSubPow S (d + 1)).val_inv\n\ntheorem invOneSubPow_add (e : \u2115) :\n    invOneSubPow S (d + e) = invOneSubPow S d * invOneSubPow S e := by\n  simp_rw [invOneSubPow_eq_inv_one_sub_pow, pow_add]\n\n", "theoremStatement": "theorem one_sub_pow_mul_invOneSubPow_val_add_eq_invOneSubPow_val (e : \u2115) :\n    (1 - X) ^ e * (invOneSubPow S (d + e)).val = (invOneSubPow S d).val ", "theoremName": "PowerSeries.one_sub_pow_mul_invOneSubPow_val_add_eq_invOneSubPow_val", "fileCreated": {"commit": "d22d5a028da58fd6edc1f288ee97594ef5b586a1", "date": "2023-05-22"}, "theoremCreated": {"commit": "7a05b449ac13af0118fd6b2c133d08e33e7e74ad", "date": "2024-12-04"}, "file": "mathlib/Mathlib/RingTheory/PowerSeries/WellKnown.lean", "module": "Mathlib.RingTheory.PowerSeries.WellKnown", "jsonFile": "Mathlib.RingTheory.PowerSeries.WellKnown.jsonl", "positionMetadata": {"lineInFile": 165, "tokenPositionInFile": 5797, "theoremPositionInFile": 17}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 48, "numPremises": 68}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp [invOneSubPow_add, Units.val_mul, mul_comm, mul_assoc, \u2190 invOneSubPow_inv_eq_one_sub_pow]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 102}}
{"srcContext": "/-\nCopyright (c) 2024 Xavier Roblot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Xavier Roblot\n-/\nimport Mathlib.Analysis.BoxIntegral.UnitPartition\nimport Mathlib.MeasureTheory.Measure.Haar.InnerProductSpace\n\n/-!\n# Covolume of \u2124-lattices\n\nLet `E` be a finite dimensional real vector space.\n\nLet `L` be a `\u2124`-lattice `L` defined as a discrete `\u2124`-submodule of `E` that spans `E` over `\u211d`.\n\n## Main definitions and results\n\n* `ZLattice.covolume`: the covolume of `L` defined as the volume of an arbitrary fundamental\ndomain of `L`.\n\n* `ZLattice.covolume_eq_measure_fundamentalDomain`: the covolume of `L` does not depend on the\nchoice of the fundamental domain of `L`.\n\n* `ZLattice.covolume_eq_det`: if `L` is a lattice in `\u211d^n`, then its covolume is the absolute\nvalue of the determinant of any `\u2124`-basis of `L`.\n\n* `ZLattice.covolume.tendsto_card_div_pow`: Let `s` be a bounded measurable set of `\u03b9 \u2192 \u211d`, then\nthe number of points in `s \u2229 n\u207b\u00b9 \u2022 L` divided by `n ^ card \u03b9` tends to `volume s / covolume L`\nwhen `n : \u2115` tends to infinity. See also `ZLattice.covolume.tendsto_card_div_pow'` for a version\nfor `InnerProductSpace \u211d E` and `ZLattice.covolume.tendsto_card_div_pow''` for the general version.\n\n* `ZLattice.covolume.tendsto_card_le_div`: Let `X` be a cone in `\u03b9 \u2192 \u211d` and let `F : (\u03b9 \u2192 \u211d) \u2192 \u211d`\nbe a function such that `F (c \u2022 x) = c ^ card \u03b9 * F x`. Then the number of points `x \u2208 X` such that\n`F x \u2264 c` divided by `c` tends to `volume {x \u2208 X | F x \u2264 1} / covolume L` when `c : \u211d` tends to\ninfinity. See also `ZLattice.covolume.tendsto_card_le_div'` for a version for\n`InnerProductSpace \u211d E` and `ZLattice.covolume.tendsto_card_le_div''` for the general version.\n\n## Naming convention\n\nSome results are true in the case where the ambient finite dimensional real vector space is the\npi-space `\u03b9 \u2192 \u211d` and in the case where it is an `InnerProductSpace`. We use the following\nconvention: the plain name is for the pi case, for eg. `volume_image_eq_volume_div_covolume`. For\nthe same result in the `InnerProductSpace` case, we add a `prime`, for eg.\n`volume_image_eq_volume_div_covolume'`. When the same result exists in the\ngeneral case, we had two primes, eg. `covolume.tendsto_card_div_pow''`.\n\n-/\n\nnoncomputable section\n\nnamespace ZLattice\n\nopen Submodule MeasureTheory Module MeasureTheory Module ZSpan\n\nsection General\n\nvariable {E : Type*} [NormedAddCommGroup E] [MeasurableSpace E] (L : Submodule \u2124 E)\n\n/-- The covolume of a `\u2124`-lattice is the volume of some fundamental domain; see\n`ZLattice.covolume_eq_volume` for the proof that the volume does not depend on the choice of\nthe fundamental domain. -/\ndef covolume (\u03bc : Measure E := by volume_tac) : \u211d := (addCovolume L E \u03bc).toReal\n\nend General\n\nsection Basic\n\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] [FiniteDimensional \u211d E]\nvariable [MeasurableSpace E] [BorelSpace E]\nvariable (L : Submodule \u2124 E) [DiscreteTopology L] [IsZLattice \u211d L]\nvariable (\u03bc : Measure E := by volume_tac) [Measure.IsAddHaarMeasure \u03bc]\n\ntheorem covolume_eq_measure_fundamentalDomain {F : Set E} (h : IsAddFundamentalDomain L F \u03bc) :\n    covolume L \u03bc = (\u03bc F).toReal := by\n  have : MeasurableVAdd L E := (inferInstance : MeasurableVAdd L.toAddSubgroup E)\n  have : VAddInvariantMeasure L E \u03bc := (inferInstance : VAddInvariantMeasure L.toAddSubgroup E \u03bc)\n  exact congr_arg ENNReal.toReal (h.covolume_eq_volume \u03bc)\n\ntheorem covolume_ne_zero : covolume L \u03bc \u2260 0 := by\n  rw [covolume_eq_measure_fundamentalDomain L \u03bc (isAddFundamentalDomain (Free.chooseBasis \u2124 L) \u03bc),\n    ENNReal.toReal_ne_zero]\n  refine \u27e8measure_fundamentalDomain_ne_zero _, ne_of_lt ?_\u27e9\n  exact Bornology.IsBounded.measure_lt_top (fundamentalDomain_isBounded _)\n\ntheorem covolume_pos : 0 < covolume L \u03bc :=\n  lt_of_le_of_ne ENNReal.toReal_nonneg (covolume_ne_zero L \u03bc).symm\n\ntheorem covolume_comap {F : Type*} [NormedAddCommGroup F] [NormedSpace \u211d F] [FiniteDimensional \u211d F]\n    [MeasurableSpace F] [BorelSpace F] (\u03bd : Measure F := by volume_tac) [Measure.IsAddHaarMeasure \u03bd]\n    {e : F \u2243L[\u211d] E} (he : MeasurePreserving e \u03bd \u03bc) :\n    covolume (ZLattice.comap \u211d L e.toLinearMap) \u03bd = covolume L \u03bc := by\n  rw [covolume_eq_measure_fundamentalDomain _ _ (isAddFundamentalDomain (Free.chooseBasis \u2124 L) \u03bc),\n    covolume_eq_measure_fundamentalDomain _ _ ((isAddFundamentalDomain\n    ((Free.chooseBasis \u2124 L).ofZLatticeComap \u211d L e.toLinearEquiv) \u03bd)), \u2190 he.measure_preimage\n    (fundamentalDomain_measurableSet _).nullMeasurableSet, \u2190 e.image_symm_eq_preimage,\n    \u2190 e.symm.coe_toLinearEquiv, map_fundamentalDomain]\n  congr!\n  ext; simp\n\ntheorem covolume_eq_det_mul_measure {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (b : Basis \u03b9 \u2124 L)\n    (b\u2080 : Basis \u03b9 \u211d E) :\n    covolume L \u03bc = |b\u2080.det ((\u2191) \u2218 b)| * (\u03bc (fundamentalDomain b\u2080)).toReal := by\n  rw [covolume_eq_measure_fundamentalDomain L \u03bc (isAddFundamentalDomain b \u03bc),\n    measure_fundamentalDomain _ _ b\u2080,\n    measure_congr (fundamentalDomain_ae_parallelepiped b\u2080 \u03bc), ENNReal.toReal_mul,\n    ENNReal.toReal_ofReal (by positivity)]\n  congr\n  ext\n  exact b.ofZLatticeBasis_apply \u211d L _\n\ntheorem covolume_eq_det {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (L : Submodule \u2124 (\u03b9 \u2192 \u211d))\n    [DiscreteTopology L] [IsZLattice \u211d L] (b : Basis \u03b9 \u2124 L) :\n    covolume L = |(Matrix.of ((\u2191) \u2218 b)).det| := by\n  rw [covolume_eq_measure_fundamentalDomain L volume (isAddFundamentalDomain b volume),\n    volume_fundamentalDomain, ENNReal.toReal_ofReal (by positivity)]\n  congr\n  ext1\n  exact b.ofZLatticeBasis_apply \u211d L _\n\ntheorem covolume_eq_det_inv {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (L : Submodule \u2124 (\u03b9 \u2192 \u211d))\n    [DiscreteTopology L] [IsZLattice \u211d L] (b : Basis \u03b9 \u2124 L) :\n    covolume L = |(LinearEquiv.det (b.ofZLatticeBasis \u211d L).equivFun : \u211d)|\u207b\u00b9 := by\n  rw [covolume_eq_det L b, \u2190 Pi.basisFun_det_apply, show (((\u2191) : L \u2192 _) \u2218 \u21d1b) =\n    (b.ofZLatticeBasis \u211d) by ext; simp, \u2190 Basis.det_inv, \u2190 abs_inv, Units.val_inv_eq_inv_val,\n    IsUnit.unit_spec, \u2190 Basis.det_basis, LinearEquiv.coe_det]\n  rfl\n\ntheorem volume_image_eq_volume_div_covolume {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9]\n    (L : Submodule \u2124 (\u03b9 \u2192 \u211d)) [DiscreteTopology L] [IsZLattice \u211d L] (b : Basis \u03b9 \u2124 L)\n    {s : Set (\u03b9 \u2192 \u211d)} :\n    volume ((b.ofZLatticeBasis \u211d L).equivFun '' s) = volume s / ENNReal.ofReal (covolume L) := by\n  rw [LinearEquiv.image_eq_preimage, Measure.addHaar_preimage_linearEquiv, LinearEquiv.symm_symm,\n    covolume_eq_det_inv L b, ENNReal.div_eq_inv_mul, ENNReal.ofReal_inv_of_pos\n    (abs_pos.mpr (LinearEquiv.det _).ne_zero), inv_inv, LinearEquiv.coe_det]\n\n/-- A more general version of `ZLattice.volume_image_eq_volume_div_covolume`;\nsee the `Naming conventions` section in the introduction. -/\ntheorem volume_image_eq_volume_div_covolume' {E : Type*} [NormedAddCommGroup E]\n    [InnerProductSpace \u211d E] [FiniteDimensional \u211d E] [MeasurableSpace E] [BorelSpace E]\n    (L : Submodule \u2124 E) [DiscreteTopology L] [IsZLattice \u211d L] {\u03b9 : Type*} [Fintype \u03b9]\n    (b : Basis \u03b9 \u2124 L) {s : Set E} (hs : NullMeasurableSet s) :\n    volume ((b.ofZLatticeBasis \u211d).equivFun '' s) = volume s / ENNReal.ofReal (covolume L) := by\n  classical\n  let e : Fin (finrank \u211d E) \u2243 \u03b9 :=\n    Fintype.equivOfCardEq (by rw [Fintype.card_fin, finrank_eq_card_basis (b.ofZLatticeBasis \u211d)])\n  let f := (EuclideanSpace.equiv \u03b9 \u211d).symm.trans\n    ((stdOrthonormalBasis \u211d E).reindex e).repr.toContinuousLinearEquiv.symm\n  have hf : MeasurePreserving f :=\n    ((stdOrthonormalBasis \u211d E).reindex e).measurePreserving_repr_symm.comp\n      (EuclideanSpace.volume_preserving_measurableEquiv \u03b9).symm\n  rw [\u2190 hf.measure_preimage hs, \u2190 (covolume_comap L volume volume hf),\n    \u2190 volume_image_eq_volume_div_covolume (ZLattice.comap \u211d L f.toLinearMap)\n    (b.ofZLatticeComap \u211d L f.toLinearEquiv), Basis.ofZLatticeBasis_comap,\n    \u2190 f.image_symm_eq_preimage, \u2190 Set.image_comp]\n  simp only [Basis.equivFun_apply, ContinuousLinearEquiv.symm_toLinearEquiv, Basis.map_equivFun,\n    LinearEquiv.symm_symm, Function.comp_apply, LinearEquiv.trans_apply,\n    ContinuousLinearEquiv.coe_toLinearEquiv, ContinuousLinearEquiv.apply_symm_apply]\n\nend Basic\n\nnamespace covolume\n\nsection General\n\nopen Filter Fintype Pointwise Topology BoxIntegral Bornology\n\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]\nvariable {L : Submodule \u2124 E} [DiscreteTopology L] [IsZLattice \u211d L]\nvariable {\u03b9 : Type*} [Fintype \u03b9] (b : Basis \u03b9 \u2124 L)\n\n/-- A version of `ZLattice.covolume.tendsto_card_div_pow` for the general case;\nsee the `Naming convention` section in the introduction. -/\ntheorem tendsto_card_div_pow'' [FiniteDimensional \u211d E] [MeasurableSpace E] [BorelSpace E]\n    {s : Set E} (hs\u2081 : IsBounded s) (hs\u2082 : MeasurableSet s)\n    (hs\u2083 : volume (frontier ((b.ofZLatticeBasis \u211d).equivFun '' s)) = 0):\n    Tendsto (fun n : \u2115 \u21a6 (Nat.card (s \u2229 (n : \u211d)\u207b\u00b9 \u2022 L : Set E) : \u211d) / n ^ card \u03b9)\n      atTop (\ud835\udcdd (volume ((b.ofZLatticeBasis \u211d).equivFun '' s)).toReal) := by\n  refine Tendsto.congr' ?_\n    (tendsto_card_div_pow_atTop_volume ((b.ofZLatticeBasis \u211d).equivFun '' s) ?_ ?_ hs\u2083)\n  \u00b7 filter_upwards [eventually_gt_atTop 0] with n hn\n    congr\n    refine Nat.card_congr <| ((b.ofZLatticeBasis \u211d).equivFun.toEquiv.subtypeEquiv fun x \u21a6 ?_).symm\n    simp_rw [Set.mem_inter_iff, \u2190 b.ofZLatticeBasis_span \u211d, LinearEquiv.coe_toEquiv,\n      Basis.equivFun_apply, Set.mem_image, DFunLike.coe_fn_eq, EmbeddingLike.apply_eq_iff_eq,\n      exists_eq_right, and_congr_right_iff, Set.mem_inv_smul_set_iff\u2080\n      (mod_cast hn.ne' : (n : \u211d) \u2260 0), \u2190 Finsupp.coe_smul, \u2190 LinearEquiv.map_smul, SetLike.mem_coe,\n      Basis.mem_span_iff_repr_mem, Pi.basisFun_repr, implies_true]\n  \u00b7 rw [\u2190 NormedSpace.isVonNBounded_iff \u211d] at hs\u2081 \u22a2\n    exact Bornology.IsVonNBounded.image hs\u2081 ((b.ofZLatticeBasis \u211d).equivFunL : E \u2192L[\u211d] \u03b9 \u2192 \u211d)\n  \u00b7 exact (b.ofZLatticeBasis \u211d).equivFunL.toHomeomorph.toMeasurableEquiv.measurableSet_image.mpr hs\u2082\n\n", "theoremStatement": "private theorem tendsto_card_le_div''_aux {X : Set E} (hX : \u2200 \u2983x\u2984 \u2983r:\u211d\u2984, x \u2208 X \u2192 0 < r \u2192 r \u2022 x \u2208 X)\n    {F : E \u2192 \u211d} (hF\u2081 : \u2200 x \u2983r : \u211d\u2984, 0 \u2264 r \u2192 F (r \u2022 x) = r ^ card \u03b9 * (F x)) {c : \u211d} (hc : 0 < c) :\n    c \u2022 {x \u2208 X | F x \u2264 1} = {x \u2208 X | F x \u2264 c ^ card \u03b9} ", "theoremName": "ZLattice.covolume.tendsto_card_le_div''_aux", "fileCreated": {"commit": "85d6c78ac5782869d041c2ca6d3ca83cdde412c3", "date": "2024-09-09"}, "theoremCreated": {"commit": "211dc533566a173988a01067bb50d7917a097103", "date": "2024-12-18"}, "file": "mathlib/Mathlib/Algebra/Module/ZLattice/Covolume.lean", "module": "Mathlib.Algebra.Module.ZLattice.Covolume", "jsonFile": "Mathlib.Algebra.Module.ZLattice.Covolume.jsonl", "positionMetadata": {"lineInFile": 192, "tokenPositionInFile": 9803, "theoremPositionInFile": 11}, "dependencyMetadata": {"inFilePremises": null, "numInFilePremises": null, "repositoryPremises": null, "numRepositoryPremises": null, "numPremises": null}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  ext x\n  simp_rw [Set.mem_smul_set_iff_inv_smul_mem\u2080 hc.ne', Set.mem_setOf_eq, hF\u2081 _\n    (inv_pos_of_pos hc).le, inv_pow, inv_mul_le_iff\u2080 (pow_pos hc _), mul_one, and_congr_left_iff]\n  exact fun _ \u21a6 \u27e8fun h \u21a6 (smul_inv_smul\u2080 hc.ne' x) \u25b8 hX h hc, fun h \u21a6 hX h (inv_pos_of_pos hc)\u27e9", "proofType": "tactic", "proofLengthLines": 4, "proofLengthTokens": 285}}
{"srcContext": "/-\nCopyright (c) 2024 Fangming Li. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Fangming Li, Jujian Zhang\n-/\nimport Mathlib.Algebra.Polynomial.AlgebraMap\nimport Mathlib.Algebra.Polynomial.Eval.SMul\nimport Mathlib.Algebra.Polynomial.Roots\nimport Mathlib.Order.Interval.Set.Infinite\nimport Mathlib.RingTheory.Polynomial.Pochhammer\nimport Mathlib.RingTheory.PowerSeries.WellKnown\nimport Mathlib.Tactic.FieldSimp\n\n/-!\n# Hilbert polynomials\n\nIn this file, we formalise the following statement: if `F` is a field with characteristic `0`, then\ngiven any `p : F[X]` and `d : \u2115`, there exists some `h : F[X]` such that for any large enough\n`n : \u2115`, `h(n)` is equal to the coefficient of `X\u207f` in the power series expansion of `p/(1 - X)\u1d48`.\nThis `h` is unique and is denoted as `Polynomial.hilbertPoly p d`.\n\nFor example, given `d : \u2115`, the power series expansion of `1/(1 - X)\u1d48\u207a\u00b9` in `F[X]`\nis `\u03a3\u2099 ((d + n).choose d)X\u207f`, which equals `\u03a3\u2099 ((n + 1)\u00b7\u00b7\u00b7(n + d)/d!)X\u207f` and hence\n`Polynomial.hilbertPoly (1 : F[X]) (d + 1)` is the polynomial `(X + 1)\u00b7\u00b7\u00b7(X + d)/d!`. Note that\nif `d! = 0` in `F`, then the polynomial `(X + 1)\u00b7\u00b7\u00b7(X + d)/d!` no longer works, so we do not want\nthe characteristic of `F` to be divisible by `d!`. As `Polynomial.hilbertPoly` may take any\n`p : F[X]` and `d : \u2115` as its inputs, it is necessary for us to assume that `CharZero F`.\n\n## Main definitions\n\n* `Polynomial.hilbertPoly p d`. Given a field `F`, a polynomial `p : F[X]` and a natural number `d`,\n  if `F` is of characteristic `0`, then `Polynomial.hilbertPoly p d : F[X]` is the polynomial whose\n  value at `n` equals the coefficient of `X\u207f` in the power series expansion of `p/(1 - X)\u1d48`.\n\n## TODO\n\n* Hilbert polynomials of finitely generated graded modules over Noetherian rings.\n-/\n\nopen Nat PowerSeries\n\nvariable (F : Type*) [Field F]\n\nnamespace Polynomial\n\n/--\nFor any field `F` and natural numbers `d` and `k`, `Polynomial.preHilbertPoly F d k`\nis defined as `(d.factorial : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (X - (C (k : F)) + 1))`.\nThis is the most basic form of Hilbert polynomials. `Polynomial.preHilbertPoly \u211a d 0`\nis exactly the Hilbert polynomial of the polynomial ring `\u211a[X_0,...,X_d]` viewed as\na graded module over itself. In fact, `Polynomial.preHilbertPoly F d k` is the\nsame as `Polynomial.hilbertPoly ((X : F[X]) ^ k) (d + 1)` for any field `F` and\n`d k : \u2115` (see the lemma `Polynomial.hilbertPoly_X_pow_succ`). See also the lemma\n`Polynomial.preHilbertPoly_eq_choose_sub_add`, which states that if `CharZero F`,\nthen for any `d k n : \u2115` with `k \u2264 n`, `(Polynomial.preHilbertPoly F d k).eval (n : F)`\nequals `(n - k + d).choose d`.\n-/\nnoncomputable def preHilbertPoly (d k : \u2115) : F[X] :=\n  (d.factorial : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (Polynomial.X - (C (k : F)) + 1))\n\nlemma natDegree_preHilbertPoly [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).natDegree = d := by\n  have hne : (d ! : F) \u2260 0 := by norm_cast; positivity\n  rw [preHilbertPoly, natDegree_smul _ (inv_ne_zero hne), natDegree_comp, ascPochhammer_natDegree,\n    add_comm_sub, \u2190 C_1, \u2190 map_sub, natDegree_add_C, natDegree_X, mul_one]\n\nlemma coeff_preHilbertPoly_self [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).coeff d = (d ! : F)\u207b\u00b9 := by\n  delta preHilbertPoly\n  have hne : (d ! : F) \u2260 0 := by norm_cast; positivity\n  have heq : d = ((ascPochhammer F d).comp (X - C (k : F) + 1)).natDegree :=\n    (natDegree_preHilbertPoly F d k).symm.trans (natDegree_smul _ (inv_ne_zero hne))\n  nth_rw 3 [heq]\n  calc\n  _ = (d ! : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (X - C ((k : F) - 1))).leadingCoeff := by\n    simp only [sub_add, \u2190 C_1, \u2190 map_sub, coeff_smul, coeff_natDegree]\n  _ = (d ! : F)\u207b\u00b9 := by\n    simp only [leadingCoeff_comp (ne_of_eq_of_ne (natDegree_X_sub_C _) one_ne_zero), Monic.def.1\n      (monic_ascPochhammer _ _), one_mul, leadingCoeff_X_sub_C, one_pow, smul_eq_mul, mul_one]\n\nlemma leadingCoeff_preHilbertPoly [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).leadingCoeff = (d ! : F)\u207b\u00b9 := by\n  rw [leadingCoeff, natDegree_preHilbertPoly, coeff_preHilbertPoly_self]\n\n", "theoremStatement": "lemma preHilbertPoly_eq_choose_sub_add [CharZero F] (d : \u2115) {k n : \u2115} (hkn : k \u2264 n):\n    (preHilbertPoly F d k).eval (n : F) = (n - k + d).choose d ", "theoremName": "Polynomial.preHilbertPoly_eq_choose_sub_add", "fileCreated": {"commit": "561e050467d2caa2e4ea5d81ca62600bf268b747", "date": "2024-12-02"}, "theoremCreated": {"commit": "561e050467d2caa2e4ea5d81ca62600bf268b747", "date": "2024-12-02"}, "file": "mathlib/Mathlib/RingTheory/Polynomial/HilbertPoly.lean", "module": "Mathlib.RingTheory.Polynomial.HilbertPoly", "jsonFile": "Mathlib.RingTheory.Polynomial.HilbertPoly.jsonl", "positionMetadata": {"lineInFile": 85, "tokenPositionInFile": 4089, "theoremPositionInFile": 4}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 120, "numPremises": 154}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  have : (d ! : F) \u2260 0 := by norm_cast; positivity\n  calc\n  _ = (\u2191d !)\u207b\u00b9 * eval (\u2191(n - k + 1)) (ascPochhammer F d) := by simp [cast_sub hkn, preHilbertPoly]\n  _ = (n - k + d).choose d := by\n    rw [ascPochhammer_nat_eq_natCast_ascFactorial];\n    field_simp [ascFactorial_eq_factorial_mul_choose]", "proofType": "tactic", "proofLengthLines": 6, "proofLengthTokens": 301}}
{"srcContext": "/-\nCopyright (c) 2024 Fangming Li. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Fangming Li, Jujian Zhang\n-/\nimport Mathlib.Algebra.Polynomial.AlgebraMap\nimport Mathlib.Algebra.Polynomial.Eval.SMul\nimport Mathlib.Algebra.Polynomial.Roots\nimport Mathlib.Order.Interval.Set.Infinite\nimport Mathlib.RingTheory.Polynomial.Pochhammer\nimport Mathlib.RingTheory.PowerSeries.WellKnown\nimport Mathlib.Tactic.FieldSimp\n\n/-!\n# Hilbert polynomials\n\nIn this file, we formalise the following statement: if `F` is a field with characteristic `0`, then\ngiven any `p : F[X]` and `d : \u2115`, there exists some `h : F[X]` such that for any large enough\n`n : \u2115`, `h(n)` is equal to the coefficient of `X\u207f` in the power series expansion of `p/(1 - X)\u1d48`.\nThis `h` is unique and is denoted as `Polynomial.hilbertPoly p d`.\n\nFor example, given `d : \u2115`, the power series expansion of `1/(1 - X)\u1d48\u207a\u00b9` in `F[X]`\nis `\u03a3\u2099 ((d + n).choose d)X\u207f`, which equals `\u03a3\u2099 ((n + 1)\u00b7\u00b7\u00b7(n + d)/d!)X\u207f` and hence\n`Polynomial.hilbertPoly (1 : F[X]) (d + 1)` is the polynomial `(X + 1)\u00b7\u00b7\u00b7(X + d)/d!`. Note that\nif `d! = 0` in `F`, then the polynomial `(X + 1)\u00b7\u00b7\u00b7(X + d)/d!` no longer works, so we do not want\nthe characteristic of `F` to be divisible by `d!`. As `Polynomial.hilbertPoly` may take any\n`p : F[X]` and `d : \u2115` as its inputs, it is necessary for us to assume that `CharZero F`.\n\n## Main definitions\n\n* `Polynomial.hilbertPoly p d`. Given a field `F`, a polynomial `p : F[X]` and a natural number `d`,\n  if `F` is of characteristic `0`, then `Polynomial.hilbertPoly p d : F[X]` is the polynomial whose\n  value at `n` equals the coefficient of `X\u207f` in the power series expansion of `p/(1 - X)\u1d48`.\n\n## TODO\n\n* Hilbert polynomials of finitely generated graded modules over Noetherian rings.\n-/\n\nopen Nat PowerSeries\n\nvariable (F : Type*) [Field F]\n\nnamespace Polynomial\n\n/--\nFor any field `F` and natural numbers `d` and `k`, `Polynomial.preHilbertPoly F d k`\nis defined as `(d.factorial : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (X - (C (k : F)) + 1))`.\nThis is the most basic form of Hilbert polynomials. `Polynomial.preHilbertPoly \u211a d 0`\nis exactly the Hilbert polynomial of the polynomial ring `\u211a[X_0,...,X_d]` viewed as\na graded module over itself. In fact, `Polynomial.preHilbertPoly F d k` is the\nsame as `Polynomial.hilbertPoly ((X : F[X]) ^ k) (d + 1)` for any field `F` and\n`d k : \u2115` (see the lemma `Polynomial.hilbertPoly_X_pow_succ`). See also the lemma\n`Polynomial.preHilbertPoly_eq_choose_sub_add`, which states that if `CharZero F`,\nthen for any `d k n : \u2115` with `k \u2264 n`, `(Polynomial.preHilbertPoly F d k).eval (n : F)`\nequals `(n - k + d).choose d`.\n-/\nnoncomputable def preHilbertPoly (d k : \u2115) : F[X] :=\n  (d.factorial : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (Polynomial.X - (C (k : F)) + 1))\n\nlemma natDegree_preHilbertPoly [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).natDegree = d := by\n  have hne : (d ! : F) \u2260 0 := by norm_cast; positivity\n  rw [preHilbertPoly, natDegree_smul _ (inv_ne_zero hne), natDegree_comp, ascPochhammer_natDegree,\n    add_comm_sub, \u2190 C_1, \u2190 map_sub, natDegree_add_C, natDegree_X, mul_one]\n\nlemma coeff_preHilbertPoly_self [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).coeff d = (d ! : F)\u207b\u00b9 := by\n  delta preHilbertPoly\n  have hne : (d ! : F) \u2260 0 := by norm_cast; positivity\n  have heq : d = ((ascPochhammer F d).comp (X - C (k : F) + 1)).natDegree :=\n    (natDegree_preHilbertPoly F d k).symm.trans (natDegree_smul _ (inv_ne_zero hne))\n  nth_rw 3 [heq]\n  calc\n  _ = (d ! : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (X - C ((k : F) - 1))).leadingCoeff := by\n    simp only [sub_add, \u2190 C_1, \u2190 map_sub, coeff_smul, coeff_natDegree]\n  _ = (d ! : F)\u207b\u00b9 := by\n    simp only [leadingCoeff_comp (ne_of_eq_of_ne (natDegree_X_sub_C _) one_ne_zero), Monic.def.1\n      (monic_ascPochhammer _ _), one_mul, leadingCoeff_X_sub_C, one_pow, smul_eq_mul, mul_one]\n\nlemma leadingCoeff_preHilbertPoly [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).leadingCoeff = (d ! : F)\u207b\u00b9 := by\n  rw [leadingCoeff, natDegree_preHilbertPoly, coeff_preHilbertPoly_self]\n\nlemma preHilbertPoly_eq_choose_sub_add [CharZero F] (d : \u2115) {k n : \u2115} (hkn : k \u2264 n):\n    (preHilbertPoly F d k).eval (n : F) = (n - k + d).choose d := by\n  have : (d ! : F) \u2260 0 := by norm_cast; positivity\n  calc\n  _ = (\u2191d !)\u207b\u00b9 * eval (\u2191(n - k + 1)) (ascPochhammer F d) := by simp [cast_sub hkn, preHilbertPoly]\n  _ = (n - k + d).choose d := by\n    rw [ascPochhammer_nat_eq_natCast_ascFactorial];\n    field_simp [ascFactorial_eq_factorial_mul_choose]\n\nvariable {F}\n\n/--\n`Polynomial.hilbertPoly p 0 = 0`; for any `d : \u2115`, `Polynomial.hilbertPoly p (d + 1)`\nis defined as `\u2211 i \u2208 p.support, (p.coeff i) \u2022 Polynomial.preHilbertPoly F d i`. If\n`M` is a graded module whose Poincar\u00e9 series can be written as `p(X)/(1 - X)\u1d48` for some\n`p : \u211a[X]` with integer coefficients, then `Polynomial.hilbertPoly p d` is the Hilbert\npolynomial of `M`. See also `Polynomial.coeff_mul_invOneSubPow_eq_hilbertPoly_eval`,\nwhich says that `PowerSeries.coeff F n (p * PowerSeries.invOneSubPow F d)` equals\n`(Polynomial.hilbertPoly p d).eval (n : F)` for any large enough `n : \u2115`.\n-/\nnoncomputable def hilbertPoly (p : F[X]) : (d : \u2115) \u2192 F[X]\n  | 0 => 0\n  | d + 1 => \u2211 i \u2208 p.support, (p.coeff i) \u2022 preHilbertPoly F d i\n\nlemma hilbertPoly_zero_left (d : \u2115) : hilbertPoly (0 : F[X]) d = 0 := by\n  delta hilbertPoly; induction d with\n  | zero => simp only\n  | succ d _ => simp only [coeff_zero, zero_smul, Finset.sum_const_zero]\n\nlemma hilbertPoly_zero_right (p : F[X]) : hilbertPoly p 0 = 0 := rfl\n\nlemma hilbertPoly_succ (p : F[X]) (d : \u2115) :\n    hilbertPoly p (d + 1) = \u2211 i \u2208 p.support, (p.coeff i) \u2022 preHilbertPoly F d i := rfl\n\n", "theoremStatement": "lemma hilbertPoly_X_pow_succ (d k : \u2115) :\n    hilbertPoly ((X : F[X]) ^ k) (d + 1) = preHilbertPoly F d k ", "theoremName": "Polynomial.hilbertPoly_X_pow_succ", "fileCreated": {"commit": "561e050467d2caa2e4ea5d81ca62600bf268b747", "date": "2024-12-02"}, "theoremCreated": {"commit": "561e050467d2caa2e4ea5d81ca62600bf268b747", "date": "2024-12-02"}, "file": "mathlib/Mathlib/RingTheory/Polynomial/HilbertPoly.lean", "module": "Mathlib.RingTheory.Polynomial.HilbertPoly", "jsonFile": "Mathlib.RingTheory.Polynomial.HilbertPoly.jsonl", "positionMetadata": {"lineInFile": 119, "tokenPositionInFile": 5690, "theoremPositionInFile": 8}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 64, "numPremises": 94}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  delta hilbertPoly; simp", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 31}}
{"srcContext": "/-\nCopyright (c) 2024 Fangming Li. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Fangming Li, Jujian Zhang\n-/\nimport Mathlib.Algebra.Polynomial.AlgebraMap\nimport Mathlib.Algebra.Polynomial.Eval.SMul\nimport Mathlib.Algebra.Polynomial.Roots\nimport Mathlib.Order.Interval.Set.Infinite\nimport Mathlib.RingTheory.Polynomial.Pochhammer\nimport Mathlib.RingTheory.PowerSeries.WellKnown\nimport Mathlib.Tactic.FieldSimp\n\n/-!\n# Hilbert polynomials\n\nIn this file, we formalise the following statement: if `F` is a field with characteristic `0`, then\ngiven any `p : F[X]` and `d : \u2115`, there exists some `h : F[X]` such that for any large enough\n`n : \u2115`, `h(n)` is equal to the coefficient of `X\u207f` in the power series expansion of `p/(1 - X)\u1d48`.\nThis `h` is unique and is denoted as `Polynomial.hilbertPoly p d`.\n\nFor example, given `d : \u2115`, the power series expansion of `1/(1 - X)\u1d48\u207a\u00b9` in `F[X]`\nis `\u03a3\u2099 ((d + n).choose d)X\u207f`, which equals `\u03a3\u2099 ((n + 1)\u00b7\u00b7\u00b7(n + d)/d!)X\u207f` and hence\n`Polynomial.hilbertPoly (1 : F[X]) (d + 1)` is the polynomial `(X + 1)\u00b7\u00b7\u00b7(X + d)/d!`. Note that\nif `d! = 0` in `F`, then the polynomial `(X + 1)\u00b7\u00b7\u00b7(X + d)/d!` no longer works, so we do not want\nthe characteristic of `F` to be divisible by `d!`. As `Polynomial.hilbertPoly` may take any\n`p : F[X]` and `d : \u2115` as its inputs, it is necessary for us to assume that `CharZero F`.\n\n## Main definitions\n\n* `Polynomial.hilbertPoly p d`. Given a field `F`, a polynomial `p : F[X]` and a natural number `d`,\n  if `F` is of characteristic `0`, then `Polynomial.hilbertPoly p d : F[X]` is the polynomial whose\n  value at `n` equals the coefficient of `X\u207f` in the power series expansion of `p/(1 - X)\u1d48`.\n\n## TODO\n\n* Hilbert polynomials of finitely generated graded modules over Noetherian rings.\n-/\n\nopen Nat PowerSeries\n\nvariable (F : Type*) [Field F]\n\nnamespace Polynomial\n\n/--\nFor any field `F` and natural numbers `d` and `k`, `Polynomial.preHilbertPoly F d k`\nis defined as `(d.factorial : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (X - (C (k : F)) + 1))`.\nThis is the most basic form of Hilbert polynomials. `Polynomial.preHilbertPoly \u211a d 0`\nis exactly the Hilbert polynomial of the polynomial ring `\u211a[X_0,...,X_d]` viewed as\na graded module over itself. In fact, `Polynomial.preHilbertPoly F d k` is the\nsame as `Polynomial.hilbertPoly ((X : F[X]) ^ k) (d + 1)` for any field `F` and\n`d k : \u2115` (see the lemma `Polynomial.hilbertPoly_X_pow_succ`). See also the lemma\n`Polynomial.preHilbertPoly_eq_choose_sub_add`, which states that if `CharZero F`,\nthen for any `d k n : \u2115` with `k \u2264 n`, `(Polynomial.preHilbertPoly F d k).eval (n : F)`\nequals `(n - k + d).choose d`.\n-/\nnoncomputable def preHilbertPoly (d k : \u2115) : F[X] :=\n  (d.factorial : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (Polynomial.X - (C (k : F)) + 1))\n\nlemma natDegree_preHilbertPoly [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).natDegree = d := by\n  have hne : (d ! : F) \u2260 0 := by norm_cast; positivity\n  rw [preHilbertPoly, natDegree_smul _ (inv_ne_zero hne), natDegree_comp, ascPochhammer_natDegree,\n    add_comm_sub, \u2190 C_1, \u2190 map_sub, natDegree_add_C, natDegree_X, mul_one]\n\nlemma coeff_preHilbertPoly_self [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).coeff d = (d ! : F)\u207b\u00b9 := by\n  delta preHilbertPoly\n  have hne : (d ! : F) \u2260 0 := by norm_cast; positivity\n  have heq : d = ((ascPochhammer F d).comp (X - C (k : F) + 1)).natDegree :=\n    (natDegree_preHilbertPoly F d k).symm.trans (natDegree_smul _ (inv_ne_zero hne))\n  nth_rw 3 [heq]\n  calc\n  _ = (d ! : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (X - C ((k : F) - 1))).leadingCoeff := by\n    simp only [sub_add, \u2190 C_1, \u2190 map_sub, coeff_smul, coeff_natDegree]\n  _ = (d ! : F)\u207b\u00b9 := by\n    simp only [leadingCoeff_comp (ne_of_eq_of_ne (natDegree_X_sub_C _) one_ne_zero), Monic.def.1\n      (monic_ascPochhammer _ _), one_mul, leadingCoeff_X_sub_C, one_pow, smul_eq_mul, mul_one]\n\nlemma leadingCoeff_preHilbertPoly [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).leadingCoeff = (d ! : F)\u207b\u00b9 := by\n  rw [leadingCoeff, natDegree_preHilbertPoly, coeff_preHilbertPoly_self]\n\nlemma preHilbertPoly_eq_choose_sub_add [CharZero F] (d : \u2115) {k n : \u2115} (hkn : k \u2264 n):\n    (preHilbertPoly F d k).eval (n : F) = (n - k + d).choose d := by\n  have : (d ! : F) \u2260 0 := by norm_cast; positivity\n  calc\n  _ = (\u2191d !)\u207b\u00b9 * eval (\u2191(n - k + 1)) (ascPochhammer F d) := by simp [cast_sub hkn, preHilbertPoly]\n  _ = (n - k + d).choose d := by\n    rw [ascPochhammer_nat_eq_natCast_ascFactorial];\n    field_simp [ascFactorial_eq_factorial_mul_choose]\n\nvariable {F}\n\n/--\n`Polynomial.hilbertPoly p 0 = 0`; for any `d : \u2115`, `Polynomial.hilbertPoly p (d + 1)`\nis defined as `\u2211 i \u2208 p.support, (p.coeff i) \u2022 Polynomial.preHilbertPoly F d i`. If\n`M` is a graded module whose Poincar\u00e9 series can be written as `p(X)/(1 - X)\u1d48` for some\n`p : \u211a[X]` with integer coefficients, then `Polynomial.hilbertPoly p d` is the Hilbert\npolynomial of `M`. See also `Polynomial.coeff_mul_invOneSubPow_eq_hilbertPoly_eval`,\nwhich says that `PowerSeries.coeff F n (p * PowerSeries.invOneSubPow F d)` equals\n`(Polynomial.hilbertPoly p d).eval (n : F)` for any large enough `n : \u2115`.\n-/\nnoncomputable def hilbertPoly (p : F[X]) : (d : \u2115) \u2192 F[X]\n  | 0 => 0\n  | d + 1 => \u2211 i \u2208 p.support, (p.coeff i) \u2022 preHilbertPoly F d i\n\nlemma hilbertPoly_zero_left (d : \u2115) : hilbertPoly (0 : F[X]) d = 0 := by\n  delta hilbertPoly; induction d with\n  | zero => simp only\n  | succ d _ => simp only [coeff_zero, zero_smul, Finset.sum_const_zero]\n\nlemma hilbertPoly_zero_right (p : F[X]) : hilbertPoly p 0 = 0 := rfl\n\nlemma hilbertPoly_succ (p : F[X]) (d : \u2115) :\n    hilbertPoly p (d + 1) = \u2211 i \u2208 p.support, (p.coeff i) \u2022 preHilbertPoly F d i := rfl\n\nlemma hilbertPoly_X_pow_succ (d k : \u2115) :\n    hilbertPoly ((X : F[X]) ^ k) (d + 1) = preHilbertPoly F d k := by\n  delta hilbertPoly; simp\n\nlemma hilbertPoly_add_left (p q : F[X]) (d : \u2115) :\n    hilbertPoly (p + q) d = hilbertPoly p d + hilbertPoly q d := by\n  delta hilbertPoly\n  induction d with\n  | zero => simp only [add_zero]\n  | succ d _ =>\n      simp only [\u2190 coeff_add]\n      rw [\u2190 sum_def _ fun _ r => r \u2022 _]\n      exact sum_add_index _ _ _ (fun _ => zero_smul ..) (fun _ _ _ => add_smul ..)\n\n", "theoremStatement": "lemma hilbertPoly_smul (a : F) (p : F[X]) (d : \u2115) :\n    hilbertPoly (a \u2022 p) d = a \u2022 hilbertPoly p d ", "theoremName": "Polynomial.hilbertPoly_smul", "fileCreated": {"commit": "561e050467d2caa2e4ea5d81ca62600bf268b747", "date": "2024-12-02"}, "theoremCreated": {"commit": "e0cf109cd53a9eab08403037e1190790ed020a9d", "date": "2024-12-20"}, "file": "mathlib/Mathlib/RingTheory/Polynomial/HilbertPoly.lean", "module": "Mathlib.RingTheory.Polynomial.HilbertPoly", "jsonFile": "Mathlib.RingTheory.Polynomial.HilbertPoly.jsonl", "positionMetadata": {"lineInFile": 133, "tokenPositionInFile": 6188, "theoremPositionInFile": 10}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 60, "numPremises": 80}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  delta hilbertPoly\n  induction d with\n  | zero => simp only [smul_zero]\n  | succ d _ =>\n      simp only\n      rw [\u2190 sum_def _ fun _ r => r \u2022 _, \u2190 sum_def _ fun _ r => r \u2022 _, Polynomial.smul_sum,\n        sum_smul_index' _ _ _ fun i => zero_smul F (preHilbertPoly F d i)]\n      simp only [smul_assoc]", "proofType": "tactic", "proofLengthLines": 8, "proofLengthTokens": 305}}
{"srcContext": "/-\nCopyright (c) 2024 Dagur Asgeirsson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Dagur Asgeirsson\n-/\nimport Mathlib.Algebra.Category.ModuleCat.AB\nimport Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Sheaf\nimport Mathlib.CategoryTheory.Sites.Coherent.ExtensiveColimits\nimport Mathlib.Condensed.Equivalence\nimport Mathlib.Condensed.Limits\n/-!\n\n# AB axioms in condensed modules\n\nThis file proves that the category of condensed modules over a ring satisfies Grothendieck's axioms\nAB5, AB4, and AB4*.\n-/\n\nuniverse u\n\nopen Condensed CategoryTheory Limits\n\nnamespace Condensed\n\nvariable (A J : Type*) [Category A] [Category J] [Preadditive A]\n  [\u2200 X, HasLimitsOfShape (StructuredArrow X Stonean.toCompHaus.op) A]\n  [HasWeakSheafify (coherentTopology CompHaus.{u}) A]\n  [HasWeakSheafify (extensiveTopology Stonean.{u}) A]\n-- One of the `HasWeakSheafify` instances could be deduced from the other using the dense subsite\n-- API, but when `A` is a concrete category, these will both be synthesized anyway.\n\nlemma hasExactColimitsOfShape [HasColimitsOfShape J A] [HasExactColimitsOfShape J A]\n    [HasFiniteLimits A] : HasExactColimitsOfShape J (Condensed.{u} A) := by\n  let e : Condensed.{u} A \u224c Sheaf (extensiveTopology Stonean.{u}) A :=\n    (StoneanCompHaus.equivalence A).symm.trans Presheaf.coherentExtensiveEquivalence\n  have : HasColimitsOfShape J (Sheaf (extensiveTopology Stonean.{u}) A) :=\n    hasColimitsOfShape_of_hasColimitsOfShape_createsColimitsOfShape e.inverse\n  exact HasExactColimitsOfShape.domain_of_functor _ e.functor\n\n", "theoremStatement": "lemma hasExactLimitsOfShape [HasLimitsOfShape J A] [HasExactLimitsOfShape J A]\n    [HasFiniteColimits A] : HasExactLimitsOfShape J (Condensed.{u} A) ", "theoremName": "Condensed.hasExactLimitsOfShape", "fileCreated": {"commit": "c06a93f81886f129d03fab41f3e479c1de7cfd65", "date": "2024-12-23"}, "theoremCreated": {"commit": "1957fef0f098a197410617514519012cccddd207", "date": "2024-12-06"}, "file": "mathlib/Mathlib/Condensed/AB.lean", "module": "Mathlib.Condensed.AB", "jsonFile": "Mathlib.Condensed.AB.jsonl", "positionMetadata": {"lineInFile": 40, "tokenPositionInFile": 1591, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 63, "numPremises": 65}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  let e : Condensed.{u} A \u224c Sheaf (extensiveTopology Stonean.{u}) A :=\n    (StoneanCompHaus.equivalence A).symm.trans Presheaf.coherentExtensiveEquivalence\n  have : HasLimitsOfShape J (Sheaf (extensiveTopology Stonean.{u}) A) :=\n    hasLimitsOfShape_of_hasLimitsOfShape_createsLimitsOfShape e.inverse\n  exact HasExactLimitsOfShape.domain_of_functor _ e.functor", "proofType": "tactic", "proofLengthLines": 5, "proofLengthTokens": 366}}
{"srcContext": "/-\nCopyright (c) 2024 Jo\u00ebl Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jo\u00ebl Riou\n-/\nimport Mathlib.Algebra.Homology.Embedding.Extend\nimport Mathlib.Algebra.Homology.Embedding.IsSupported\nimport Mathlib.Algebra.Homology.QuasiIso\n\n/-!\n# Homology of the extension of an homological complex\n\nGiven an embedding `e : c.Embedding c'` and `K : HomologicalComplex C c`, we shall\ncompute the homology of `K.extend e`. In degrees that are not in the image of `e.f`,\nthe homology is obviously zero. When `e.f j = j`, we construct an isomorphism\n`(K.extend e).homology j' \u2245 K.homology j`.\n\n-/\n\nopen CategoryTheory Limits Category\n\nnamespace HomologicalComplex\n\nvariable {\u03b9 \u03b9' : Type*} {c : ComplexShape \u03b9} {c' : ComplexShape \u03b9'}\n  {C : Type*} [Category C] [HasZeroMorphisms C]\n  [HasZeroObject C]\n\nvariable (K L M : HomologicalComplex C c) (\u03c6 : K \u27f6 L) (\u03c6' : L \u27f6 M) (e : c.Embedding c')\n\nnamespace extend\n\nsection HomologyData\n\nvariable {i j k : \u03b9} {i' j' k' : \u03b9'} (hj' : e.f j = j')\n  (hi : c.prev j = i) (hi' : c'.prev j' = i') (hk : c.next j = k) (hk' : c'.next j' = k')\n\ninclude hk hk' in\nlemma comp_d_eq_zero_iff \u2983W : C\u2984 (\u03c6 : W \u27f6 K.X j) :\n    \u03c6 \u226b K.d j k = 0 \u2194 \u03c6 \u226b (K.extendXIso e hj').inv \u226b (K.extend e).d j' k' = 0 := by\n  by_cases hjk : c.Rel j k\n  \u00b7 have hk' : e.f k = k' := by rw [\u2190 hk', \u2190 hj', c'.next_eq' (e.rel hjk)]\n    rw [K.extend_d_eq e hj' hk', Iso.inv_hom_id_assoc,\n      \u2190 cancel_mono (K.extendXIso e hk').inv, zero_comp, assoc]\n  \u00b7 simp only [K.shape _ _ hjk, comp_zero, true_iff]\n    rw [K.extend_d_from_eq_zero e j' k' j hj', comp_zero, comp_zero]\n    rw [hk]\n    exact hjk\n\ninclude hi hi' in\nlemma d_comp_eq_zero_iff \u2983W : C\u2984 (\u03c6 : K.X j \u27f6 W) :\n    K.d i j \u226b \u03c6 = 0 \u2194 (K.extend e).d i' j' \u226b (K.extendXIso e hj').hom \u226b \u03c6 = 0 := by\n  by_cases hij : c.Rel i j\n  \u00b7 have hi' : e.f i = i' := by rw [\u2190 hi', \u2190 hj', c'.prev_eq' (e.rel hij)]\n    rw [K.extend_d_eq e hi' hj', assoc, assoc, Iso.inv_hom_id_assoc,\n      \u2190 cancel_epi (K.extendXIso e hi').hom, comp_zero]\n  \u00b7 simp only [K.shape _ _ hij, zero_comp, true_iff]\n    rw [K.extend_d_to_eq_zero e i' j' j hj', zero_comp]\n    rw [hi]\n    exact hij\n\nnamespace leftHomologyData\n\nvariable (cone : KernelFork (K.d j k)) (hcone : IsLimit cone)\n\n/-- The kernel fork of `(K.extend e).d j' k'` that is deduced from a kernel\nfork of `K.d j k `. -/\n@[simp]\nnoncomputable def kernelFork : KernelFork ((K.extend e).d j' k') :=\n  KernelFork.of\u03b9 (cone.\u03b9 \u226b (extendXIso K e hj').inv)\n    (by rw [assoc, \u2190 comp_d_eq_zero_iff K e hj' hk hk' cone.\u03b9, cone.condition])\n\n/-- The limit kernel fork of `(K.extend e).d j' k'` that is deduced from a limit\nkernel fork of `K.d j k `. -/\nnoncomputable def isLimitKernelFork : IsLimit (kernelFork K e hj' hk hk' cone) :=\n  KernelFork.isLimitOfIsLimitOfIff hcone ((K.extend e).d j' k')\n    (extendXIso K e hj').symm (comp_d_eq_zero_iff K e hj' hk hk')\n\nvariable (cocone : CokernelCofork (hcone.lift (KernelFork.of\u03b9 (K.d i j) (K.d_comp_d i j k))))\n  (hcocone : IsColimit cocone)\n\ninclude hi hi' hcone in\n/-- Auxiliary lemma for `lift_d_comp_eq_zero_iff`. -/\nlemma lift_d_comp_eq_zero_iff' \u2983W : C\u2984 (f' : K.X i \u27f6 cone.pt)\n    (hf' : f' \u226b cone.\u03b9 = K.d i j)\n    (f'' : (K.extend e).X i' \u27f6 cone.pt)\n    (hf'' : f'' \u226b cone.\u03b9 \u226b (extendXIso K e hj').inv = (K.extend e).d i' j')\n    (\u03c6 : cone.pt \u27f6 W) :\n    f' \u226b \u03c6 = 0 \u2194 f'' \u226b \u03c6 = 0 := by\n  by_cases hij : c.Rel i j\n  \u00b7 have hi'' : e.f i = i' := by rw [\u2190 hi', \u2190 hj', c'.prev_eq' (e.rel hij)]\n    have : (K.extendXIso e hi'').hom \u226b f' = f'' := by\n      apply Fork.IsLimit.hom_ext hcone\n      rw [assoc, hf', \u2190 cancel_mono (extendXIso K e hj').inv, assoc, assoc, hf'',\n        K.extend_d_eq e hi'' hj']\n    rw [\u2190 cancel_epi (K.extendXIso e hi'').hom, comp_zero, \u2190 this, assoc]\n  \u00b7 have h\u2081 : f' = 0 := by\n      apply Fork.IsLimit.hom_ext hcone\n      simp only [zero_comp, hf', K.shape _ _ hij]\n    have h\u2082 : f'' = 0 := by\n      apply Fork.IsLimit.hom_ext hcone\n      dsimp\n      rw [\u2190 cancel_mono (extendXIso K e hj').inv, assoc, hf'', zero_comp, zero_comp,\n        K.extend_d_to_eq_zero e i' j' j hj']\n      rw [hi]\n      exact hij\n    simp [h\u2081, h\u2082]\n\ninclude hi hi' in\nlemma lift_d_comp_eq_zero_iff \u2983W : C\u2984 (\u03c6 : cone.pt \u27f6 W) :\n    hcone.lift (KernelFork.of\u03b9 (K.d i j) (K.d_comp_d i j k)) \u226b \u03c6 = 0 \u2194\n      ((isLimitKernelFork K e hj' hk hk' cone hcone).lift\n      (KernelFork.of\u03b9 ((K.extend e).d i' j') (d_comp_d _ _ _ _))) \u226b \u03c6 = 0 :=\n  lift_d_comp_eq_zero_iff' K e hj' hi hi' cone hcone _ (hcone.fac _ _) _\n    (IsLimit.fac _ _ WalkingParallelPair.zero) _\n\n/-- Auxiliary definition for `extend.leftHomologyData`. -/\nnoncomputable def cokernelCofork :\n    CokernelCofork ((isLimitKernelFork K e hj' hk hk' cone hcone).lift\n      (KernelFork.of\u03b9 ((K.extend e).d i' j') (d_comp_d _ _ _ _))) :=\n  CokernelCofork.of\u03c0 cocone.\u03c0 (by\n    rw [\u2190 lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' cone hcone]\n    exact cocone.condition)\n\n/-- Auxiliary definition for `extend.leftHomologyData`. -/\nnoncomputable def isColimitCokernelCofork :\n    IsColimit (cokernelCofork K e hj' hi hi' hk hk' cone hcone cocone) :=\n  CokernelCofork.isColimitOfIsColimitOfIff' hcocone _\n    (lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' cone hcone)\n\nend leftHomologyData\n\nopen leftHomologyData in\n/-- The left homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a left homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def leftHomologyData (h : (K.sc' i j k).LeftHomologyData) :\n    ((K.extend e).sc' i' j' k').LeftHomologyData where\n  K := h.K\n  H := h.H\n  i := h.i \u226b (extendXIso K e hj').inv\n  \u03c0 := h.\u03c0\n  wi := by\n    dsimp\n    rw [assoc, \u2190 comp_d_eq_zero_iff K e hj' hk hk']\n    exact h.wi\n  hi := isLimitKernelFork K e hj' hk hk' _ h.hi\n  w\u03c0 := by\n    dsimp\n    rw [\u2190 lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' _ h.hi]\n    exact h.w\u03c0\n  h\u03c0 := isColimitCokernelCofork K e hj' hi hi' hk hk' _ h.hi _ h.h\u03c0\n\nnamespace rightHomologyData\n\nvariable (cocone : CokernelCofork (K.d i j)) (hcocone : IsColimit cocone)\n\n/-- The cokernel cofork of `(K.extend e).d i' j'` that is deduced from a cokernel\ncofork of `K.d i j`. -/\n@[simp]\nnoncomputable def cokernelCofork : CokernelCofork ((K.extend e).d i' j') :=\n  CokernelCofork.of\u03c0 ((extendXIso K e hj').hom \u226b cocone.\u03c0) (by\n    rw [\u2190 d_comp_eq_zero_iff K e hj' hi hi' cocone.\u03c0, cocone.condition])\n\n/-- The colimit cokernel cofork of `(K.extend e).d i' j'` that is deduced from a\ncolimit cokernel cofork of `K.d i j`. -/\nnoncomputable def isColimitCokernelCofork : IsColimit (cokernelCofork K e hj' hi hi' cocone) :=\n  CokernelCofork.isColimitOfIsColimitOfIff hcocone ((K.extend e).d i' j')\n    (extendXIso K e hj') (d_comp_eq_zero_iff K e hj' hi hi')\n\nvariable (cone : KernelFork (hcocone.desc (CokernelCofork.of\u03c0 (K.d j k) (K.d_comp_d i j k))))\n  (hcone : IsLimit cone)\n\ninclude hk hk' hcocone in\nlemma d_comp_desc_eq_zero_iff' \u2983W : C\u2984 (f' : cocone.pt \u27f6 K.X k)\n    (hf' : cocone.\u03c0 \u226b f' = K.d j k)\n    (f'' : cocone.pt \u27f6 (K.extend e).X k')\n    (hf'' : (extendXIso K e hj').hom \u226b cocone.\u03c0 \u226b f'' = (K.extend e).d j' k')\n    (\u03c6 : W \u27f6 cocone.pt) :\n    \u03c6 \u226b f' = 0 \u2194 \u03c6 \u226b f'' = 0 := by\n  by_cases hjk : c.Rel j k\n  \u00b7 have hk'' : e.f k = k' := by rw [\u2190 hk', \u2190 hj', c'.next_eq' (e.rel hjk)]\n    have : f' \u226b (K.extendXIso e hk'').inv = f'' := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      rw [reassoc_of% hf', \u2190 cancel_epi (extendXIso K e hj').hom, hf'',\n        K.extend_d_eq e hj' hk'']\n    rw [\u2190 cancel_mono (K.extendXIso e hk'').inv, zero_comp, assoc, this]\n  \u00b7 have h\u2081 : f' = 0 := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      simp only [hf', comp_zero, K.shape _ _ hjk]\n    have h\u2082 : f'' = 0 := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      rw [\u2190 cancel_epi (extendXIso K e hj').hom, hf'', comp_zero, comp_zero,\n        K.extend_d_from_eq_zero e j' k' j hj']\n      rw [hk]\n      exact hjk\n    simp [h\u2081, h\u2082]\n\ninclude hk hk' in\nlemma d_comp_desc_eq_zero_iff \u2983W : C\u2984 (\u03c6 : W \u27f6 cocone.pt) :\n    \u03c6 \u226b hcocone.desc (CokernelCofork.of\u03c0 (K.d j k) (K.d_comp_d i j k)) = 0 \u2194\n      \u03c6 \u226b ((isColimitCokernelCofork K e hj' hi hi' cocone hcocone).desc\n      (CokernelCofork.of\u03c0 ((K.extend e).d j' k') (d_comp_d _ _ _ _))) = 0 :=\n  d_comp_desc_eq_zero_iff' K e hj' hk hk' cocone hcocone _ (hcocone.fac _ _) _ (by\n    simpa using (isColimitCokernelCofork K e hj' hi hi' cocone hcocone).fac _\n      WalkingParallelPair.one) _\n\n/-- Auxiliary definition for `extend.rightHomologyData`. -/\nnoncomputable def kernelFork :\n    KernelFork ((isColimitCokernelCofork K e hj' hi hi' cocone hcocone).desc\n      (CokernelCofork.of\u03c0 ((K.extend e).d j' k') (d_comp_d _ _ _ _))) :=\n  KernelFork.of\u03b9 cone.\u03b9 (by\n    rw [\u2190 d_comp_desc_eq_zero_iff K e hj' hi hi' hk hk' cocone hcocone]\n    exact cone.condition)\n\n/-- Auxiliary definition for `extend.rightHomologyData`. -/\nnoncomputable def isLimitKernelFork :\n    IsLimit (kernelFork K e hj' hi hi' hk hk' cocone hcocone cone) :=\n  KernelFork.isLimitOfIsLimitOfIff' hcone _\n    (d_comp_desc_eq_zero_iff K e hj' hi hi' hk hk' cocone hcocone)\n\nend rightHomologyData\n\nopen rightHomologyData in\n/-- The right homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a right homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def rightHomologyData (h : (K.sc' i j k).RightHomologyData) :\n    ((K.extend e).sc' i' j' k').RightHomologyData where\n  Q := h.Q\n  H := h.H\n  p := (extendXIso K e hj').hom \u226b h.p\n  \u03b9 := h.\u03b9\n  wp := by\n    dsimp\n    rw [\u2190 d_comp_eq_zero_iff K e hj' hi hi']\n    exact h.wp\n  hp := isColimitCokernelCofork K e hj' hi hi' _ h.hp\n  w\u03b9 := by\n    dsimp\n    rw [\u2190 d_comp_desc_eq_zero_iff K e hj' hi hi' hk hk' _ h.hp]\n    exact h.w\u03b9\n  h\u03b9 := isLimitKernelFork K e hj' hi hi' hk hk' _ h.hp _ h.h\u03b9\n\n/-- Computation of the `g'` field of `extend.rightHomologyData`. -/\nlemma rightHomologyData_g' (h : (K.sc' i j k).RightHomologyData) (hk'' : e.f k = k') :\n    (rightHomologyData K e hj' hi hi' hk hk' h).g' = h.g' \u226b (K.extendXIso e hk'').inv := by\n  rw [\u2190 cancel_epi h.p, \u2190 cancel_epi (extendXIso K e hj').hom]\n  have := (rightHomologyData K e hj' hi hi' hk hk' h).p_g'\n  dsimp at this\n  rw [assoc] at this\n  rw [this, K.extend_d_eq e hj' hk'', h.p_g'_assoc, shortComplexFunctor'_obj_g]\n\n/-- The homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def homologyData (h : (K.sc' i j k).HomologyData) :\n    ((K.extend e).sc' i' j' k').HomologyData where\n  left := leftHomologyData K e hj' hi hi' hk hk' h.left\n  right := rightHomologyData K e hj' hi hi' hk hk' h.right\n  iso := h.iso\n\n/-- The homology data of `(K.extend e).sc j'` that is deduced\nfrom a homology data of `K.sc' i j k`. -/\n@[simps!]\nnoncomputable def homologyData' (h : (K.sc' i j k).HomologyData) :\n    ((K.extend e).sc j').HomologyData :=\n  homologyData K e hj' hi rfl hk rfl h\n\nend HomologyData\n\nlemma hasHomology {j : \u03b9} {j' : \u03b9'} (hj' : e.f j = j') [K.HasHomology j] :\n    (K.extend e).HasHomology j' :=\n  ShortComplex.HasHomology.mk'\n    (homologyData' K e hj' rfl rfl ((K.sc j).homologyData))\n\ninstance (j : \u03b9) [K.HasHomology j] : (K.extend e).HasHomology (e.f j) :=\n  hasHomology K e rfl\n\ninstance [\u2200 j, K.HasHomology j] (j' : \u03b9') : (K.extend e).HasHomology j' := by\n  by_cases h : \u2203 j, e.f j = j'\n  \u00b7 obtain \u27e8j, rfl\u27e9 := h\n    infer_instance\n  \u00b7 have hj := isZero_extend_X K e j' (by tauto)\n    exact ShortComplex.HasHomology.mk'\n      (ShortComplex.HomologyData.ofZeros _ (hj.eq_of_tgt _ _) (hj.eq_of_src _ _))\n\nend extend\n\nlemma extend_exactAt (j' : \u03b9') (hj' : \u2200 j, e.f j \u2260 j') :\n    (K.extend e).ExactAt j' :=\n  exactAt_of_isSupported _ e j' hj'\n\nsection\n\nvariable {j : \u03b9} {j' : \u03b9'} (hj' : e.f j = j') [K.HasHomology j] [L.HasHomology j]\n  [(K.extend e).HasHomology j'] [(L.extend e).HasHomology j']\n\n/-- The isomorphism `(K.extend e).cycles j' \u2245 K.cycles j` when `e.f j = j'`. -/\nnoncomputable def extendCyclesIso :\n    (K.extend e).cycles j' \u2245 K.cycles j :=\n  (extend.homologyData' K e hj' rfl rfl (K.sc j).homologyData).left.cyclesIso \u226a\u226b\n    (K.sc j).homologyData.left.cyclesIso.symm\n\n/-- The isomorphism `(K.extend e).opcycles j' \u2245 K.opcycles j` when `e.f j = j'`. -/\nnoncomputable def extendOpcyclesIso :\n    (K.extend e).opcycles j' \u2245 K.opcycles j :=\n  (extend.homologyData' K e hj' rfl rfl (K.sc j).homologyData).right.opcyclesIso \u226a\u226b\n    (K.sc j).homologyData.right.opcyclesIso.symm\n\n/-- The isomorphism `(K.extend e).homology j' \u2245 K.homology j` when `e.f j = j'`. -/\nnoncomputable def extendHomologyIso :\n    (K.extend e).homology j' \u2245 K.homology j :=\n  (extend.homologyData' K e hj' rfl rfl (K.sc j).homologyData).left.homologyIso \u226a\u226b\n    (K.sc j).homologyData.left.homologyIso.symm\n\ninclude hj' in\nlemma extend_exactAt_iff :\n    (K.extend e).ExactAt j' \u2194 K.ExactAt j := by\n  simp only [HomologicalComplex.exactAt_iff_isZero_homology]\n  exact (K.extendHomologyIso e hj').isZero_iff\n\n", "theoremStatement": "@[reassoc (attr := simp)]\nlemma extendCyclesIso_hom_iCycles :\n    (K.extendCyclesIso e hj').hom \u226b K.iCycles j =\n      (K.extend e).iCycles j' \u226b (K.extendXIso e hj').hom ", "theoremName": "HomologicalComplex.extendCyclesIso_hom_iCycles", "fileCreated": {"commit": "9bdc1af76cf75d960f42c29f1c09917785066c8b", "date": "2024-11-30"}, "theoremCreated": {"commit": "b07a551a1451cbf8615f4e2a6c47052affadbae4", "date": "2025-01-17"}, "file": "mathlib/Mathlib/Algebra/Homology/Embedding/ExtendHomology.lean", "module": "Mathlib.Algebra.Homology.Embedding.ExtendHomology", "jsonFile": "Mathlib.Algebra.Homology.Embedding.ExtendHomology.jsonl", "positionMetadata": {"lineInFile": 322, "tokenPositionInFile": 12795, "theoremPositionInFile": 22}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 45, "numPremises": 57}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [\u2190 cancel_epi (K.extendCyclesIso e hj').inv, Iso.inv_hom_id_assoc]\n  dsimp [extendCyclesIso, iCycles]\n  rw [assoc, ShortComplex.LeftHomologyData.cyclesIso_inv_comp_iCycles_assoc]\n  dsimp\n  rw [assoc, Iso.inv_hom_id, comp_id,\n    ShortComplex.LeftHomologyData.cyclesIso_hom_comp_i]", "proofType": "tactic", "proofLengthLines": 6, "proofLengthTokens": 291}}
{"srcContext": "/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Chris Hughes, Anne Baanen\n-/\nimport Mathlib.Data.Matrix.Basic\nimport Mathlib.Data.Matrix.Block\nimport Mathlib.Data.Matrix.Notation\nimport Mathlib.Data.Matrix.RowCol\nimport Mathlib.GroupTheory.GroupAction.Ring\nimport Mathlib.GroupTheory.Perm.Fin\nimport Mathlib.LinearAlgebra.Alternating.Basic\nimport Mathlib.LinearAlgebra.Matrix.SemiringInverse\n\n/-!\n# Determinant of a matrix\n\nThis file defines the determinant of a matrix, `Matrix.det`, and its essential properties.\n\n## Main definitions\n\n - `Matrix.det`: the determinant of a square matrix, as a sum over permutations\n - `Matrix.detRowAlternating`: the determinant, as an `AlternatingMap` in the rows of the matrix\n\n## Main results\n\n - `det_mul`: the determinant of `A * B` is the product of determinants\n - `det_zero_of_row_eq`: the determinant is zero if there is a repeated row\n - `det_block_diagonal`: the determinant of a block diagonal matrix is a product\n   of the blocks' determinants\n\n## Implementation notes\n\nIt is possible to configure `simp` to compute determinants. See the file\n`MathlibTest/matrix.lean` for some examples.\n\n-/\n\n\nuniverse u v w z\n\nopen Equiv Equiv.Perm Finset Function\n\nnamespace Matrix\n\nvariable {m n : Type*} [DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m]\nvariable {R : Type v} [CommRing R]\n\nlocal notation \"\u03b5 \" \u03c3:arg => ((sign \u03c3 : \u2124) : R)\n\n/-- `det` is an `AlternatingMap` in the rows of the matrix. -/\ndef detRowAlternating : (n \u2192 R) [\u22c0^n]\u2192\u2097[R] R :=\n  MultilinearMap.alternatization ((MultilinearMap.mkPiAlgebra R n R).compLinearMap LinearMap.proj)\n\n/-- The determinant of a matrix given by the Leibniz formula. -/\nabbrev det (M : Matrix n n R) : R :=\n  detRowAlternating M\n\ntheorem det_apply (M : Matrix n n R) : M.det = \u2211 \u03c3 : Perm n, Equiv.Perm.sign \u03c3 \u2022 \u220f i, M (\u03c3 i) i :=\n  MultilinearMap.alternatization_apply _ M\n\n-- This is what the old definition was. We use it to avoid having to change the old proofs below\ntheorem det_apply' (M : Matrix n n R) : M.det = \u2211 \u03c3 : Perm n, \u03b5 \u03c3 * \u220f i, M (\u03c3 i) i := by\n  simp [det_apply, Units.smul_def]\n\ntheorem det_eq_detp_sub_detp (M : Matrix n n R) : M.det = M.detp 1 - M.detp (-1) := by\n  rw [det_apply, \u2190 Equiv.sum_comp (Equiv.inv (Perm n)), \u2190 ofSign_disjUnion, sum_disjUnion]\n  simp_rw [inv_apply, sign_inv, sub_eq_add_neg, detp, \u2190 sum_neg_distrib]\n  refine congr_arg\u2082 (\u00b7 + \u00b7) (sum_congr rfl fun \u03c3 h\u03c3 \u21a6 ?_) (sum_congr rfl fun \u03c3 h\u03c3 \u21a6 ?_) <;>\n    rw [mem_ofSign.mp h\u03c3, \u2190 Equiv.prod_comp \u03c3] <;> simp\n\n@[simp]\ntheorem det_diagonal {d : n \u2192 R} : det (diagonal d) = \u220f i, d i := by\n  rw [det_apply']\n  refine (Finset.sum_eq_single 1 ?_ ?_).trans ?_\n  \u00b7 rintro \u03c3 - h2\n    cases' not_forall.1 (mt Equiv.ext h2) with x h3\n    convert mul_zero (\u03b5 \u03c3)\n    apply Finset.prod_eq_zero (mem_univ x)\n    exact if_neg h3\n  \u00b7 simp\n  \u00b7 simp\n\ntheorem det_zero (_ : Nonempty n) : det (0 : Matrix n n R) = 0 :=\n  (detRowAlternating : (n \u2192 R) [\u22c0^n]\u2192\u2097[R] R).map_zero\n\n@[simp]\ntheorem det_one : det (1 : Matrix n n R) = 1 := by rw [\u2190 diagonal_one]; simp [-diagonal_one]\n\ntheorem det_isEmpty [IsEmpty n] {A : Matrix n n R} : det A = 1 := by simp [det_apply]\n\n@[simp]\ntheorem coe_det_isEmpty [IsEmpty n] : (det : Matrix n n R \u2192 R) = Function.const _ 1 := by\n  ext\n  exact det_isEmpty\n\ntheorem det_eq_one_of_card_eq_zero {A : Matrix n n R} (h : Fintype.card n = 0) : det A = 1 :=\n  haveI : IsEmpty n := Fintype.card_eq_zero_iff.mp h\n  det_isEmpty\n\n/-- If `n` has only one element, the determinant of an `n` by `n` matrix is just that element.\nAlthough `Unique` implies `DecidableEq` and `Fintype`, the instances might\nnot be syntactically equal. Thus, we need to fill in the args explicitly. -/\n@[simp]\ntheorem det_unique {n : Type*} [Unique n] [DecidableEq n] [Fintype n] (A : Matrix n n R) :\n    det A = A default default := by simp [det_apply, univ_unique]\n\ntheorem det_eq_elem_of_subsingleton [Subsingleton n] (A : Matrix n n R) (k : n) :\n    det A = A k k := by\n  have := uniqueOfSubsingleton k\n  convert det_unique A\n\ntheorem det_eq_elem_of_card_eq_one {A : Matrix n n R} (h : Fintype.card n = 1) (k : n) :\n    det A = A k k :=\n  haveI : Subsingleton n := Fintype.card_le_one_iff_subsingleton.mp h.le\n  det_eq_elem_of_subsingleton _ _\n\ntheorem det_mul_aux {M N : Matrix n n R} {p : n \u2192 n} (H : \u00acBijective p) :\n    (\u2211 \u03c3 : Perm n, \u03b5 \u03c3 * \u220f x, M (\u03c3 x) (p x) * N (p x) x) = 0 := by\n  obtain \u27e8i, j, hpij, hij\u27e9 : \u2203 i j, p i = p j \u2227 i \u2260 j := by\n    rw [\u2190 Finite.injective_iff_bijective, Injective] at H\n    push_neg at H\n    exact H\n  exact\n    sum_involution (fun \u03c3 _ => \u03c3 * Equiv.swap i j)\n      (fun \u03c3 _ => by\n        have : (\u220f x, M (\u03c3 x) (p x)) = \u220f x, M ((\u03c3 * Equiv.swap i j) x) (p x) :=\n          Fintype.prod_equiv (swap i j) _ _ (by simp [apply_swap_eq_self hpij])\n        simp [this, sign_swap hij, -sign_swap', prod_mul_distrib])\n      (fun \u03c3 _ _ => (not_congr mul_swap_eq_iff).mpr hij) (fun _ _ => mem_univ _) fun \u03c3 _ =>\n      mul_swap_involutive i j \u03c3\n\n@[simp]\ntheorem det_mul (M N : Matrix n n R) : det (M * N) = det M * det N :=\n  calc\n    det (M * N) = \u2211 p : n \u2192 n, \u2211 \u03c3 : Perm n, \u03b5 \u03c3 * \u220f i, M (\u03c3 i) (p i) * N (p i) i := by\n      simp only [det_apply', mul_apply, prod_univ_sum, mul_sum, Fintype.piFinset_univ]\n      rw [Finset.sum_comm]\n    _ = \u2211 p : n \u2192 n with Bijective p, \u2211 \u03c3 : Perm n, \u03b5 \u03c3 * \u220f i, M (\u03c3 i) (p i) * N (p i) i := by\n      refine (sum_subset (filter_subset _ _) fun f _ hbij \u21a6 det_mul_aux ?_).symm\n      simpa only [true_and, mem_filter, mem_univ] using hbij\n    _ = \u2211 \u03c4 : Perm n, \u2211 \u03c3 : Perm n, \u03b5 \u03c3 * \u220f i, M (\u03c3 i) (\u03c4 i) * N (\u03c4 i) i :=\n      sum_bij (fun p h \u21a6 Equiv.ofBijective p (mem_filter.1 h).2) (fun _ _ \u21a6 mem_univ _)\n        (fun _ _ _ _ h \u21a6 by injection h)\n        (fun b _ \u21a6 \u27e8b, mem_filter.2 \u27e8mem_univ _, b.bijective\u27e9, coe_fn_injective rfl\u27e9) fun _ _ \u21a6 rfl\n    _ = \u2211 \u03c3 : Perm n, \u2211 \u03c4 : Perm n, (\u220f i, N (\u03c3 i) i) * \u03b5 \u03c4 * \u220f j, M (\u03c4 j) (\u03c3 j) := by\n      simp only [mul_comm, mul_left_comm, prod_mul_distrib, mul_assoc]\n    _ = \u2211 \u03c3 : Perm n, \u2211 \u03c4 : Perm n, (\u220f i, N (\u03c3 i) i) * (\u03b5 \u03c3 * \u03b5 \u03c4) * \u220f i, M (\u03c4 i) i :=\n      (sum_congr rfl fun \u03c3 _ =>\n        Fintype.sum_equiv (Equiv.mulRight \u03c3\u207b\u00b9) _ _ fun \u03c4 => by\n          have : (\u220f j, M (\u03c4 j) (\u03c3 j)) = \u220f j, M ((\u03c4 * \u03c3\u207b\u00b9) j) j := by\n            rw [\u2190 (\u03c3\u207b\u00b9 : _ \u2243 _).prod_comp]\n            simp only [Equiv.Perm.coe_mul, apply_inv_self, Function.comp_apply]\n          have h : \u03b5 \u03c3 * \u03b5 (\u03c4 * \u03c3\u207b\u00b9) = \u03b5 \u03c4 :=\n            calc\n              \u03b5 \u03c3 * \u03b5 (\u03c4 * \u03c3\u207b\u00b9) = \u03b5 (\u03c4 * \u03c3\u207b\u00b9 * \u03c3) := by\n                rw [mul_comm, sign_mul (\u03c4 * \u03c3\u207b\u00b9)]\n                simp only [Int.cast_mul, Units.val_mul]\n              _ = \u03b5 \u03c4 := by simp only [inv_mul_cancel_right]\n\n          simp_rw [Equiv.coe_mulRight, h]\n          simp only [this])\n    _ = det M * det N := by\n      simp only [det_apply', Finset.mul_sum, mul_comm, mul_left_comm, mul_assoc]\n\n/-- The determinant of a matrix, as a monoid homomorphism. -/\ndef detMonoidHom : Matrix n n R \u2192* R where\n  toFun := det\n  map_one' := det_one\n  map_mul' := det_mul\n\n@[simp]\ntheorem coe_detMonoidHom : (detMonoidHom : Matrix n n R \u2192 R) = det :=\n  rfl\n\n/-- On square matrices, `mul_comm` applies under `det`. -/\ntheorem det_mul_comm (M N : Matrix m m R) : det (M * N) = det (N * M) := by\n  rw [det_mul, det_mul, mul_comm]\n\n/-- On square matrices, `mul_left_comm` applies under `det`. -/\ntheorem det_mul_left_comm (M N P : Matrix m m R) : det (M * (N * P)) = det (N * (M * P)) := by\n  rw [\u2190 Matrix.mul_assoc, \u2190 Matrix.mul_assoc, det_mul, det_mul_comm M N, \u2190 det_mul]\n\n/-- On square matrices, `mul_right_comm` applies under `det`. -/\ntheorem det_mul_right_comm (M N P : Matrix m m R) : det (M * N * P) = det (M * P * N) := by\n  rw [Matrix.mul_assoc, Matrix.mul_assoc, det_mul, det_mul_comm N P, \u2190 det_mul]\n\n-- TODO(https://github.com/leanprover-community/mathlib4/issues/6607): fix elaboration so `val` isn't needed\ntheorem det_units_conj (M : (Matrix m m R)\u02e3) (N : Matrix m m R) :\n    det (M.val * N * M\u207b\u00b9.val) = det N := by\n  rw [det_mul_right_comm, Units.mul_inv, one_mul]\n\n-- TODO(https://github.com/leanprover-community/mathlib4/issues/6607): fix elaboration so `val` isn't needed\ntheorem det_units_conj' (M : (Matrix m m R)\u02e3) (N : Matrix m m R) :\n    det (M\u207b\u00b9.val * N * \u2191M.val) = det N :=\n  det_units_conj M\u207b\u00b9 N\n\n/-- Transposing a matrix preserves the determinant. -/\n@[simp]\ntheorem det_transpose (M : Matrix n n R) : M\u1d40.det = M.det := by\n  rw [det_apply', det_apply']\n  refine Fintype.sum_bijective _ inv_involutive.bijective _ _ ?_\n  intro \u03c3\n  rw [sign_inv]\n  congr 1\n  apply Fintype.prod_equiv \u03c3\n  simp\n\n/-- Permuting the columns changes the sign of the determinant. -/\ntheorem det_permute (\u03c3 : Perm n) (M : Matrix n n R) :\n    (M.submatrix \u03c3 id).det = Perm.sign \u03c3 * M.det :=\n  ((detRowAlternating : (n \u2192 R) [\u22c0^n]\u2192\u2097[R] R).map_perm M \u03c3).trans (by simp [Units.smul_def])\n\n/-- Permuting the rows changes the sign of the determinant. -/\ntheorem det_permute' (\u03c3 : Perm n) (M : Matrix n n R) :\n    (M.submatrix id \u03c3).det = Perm.sign \u03c3 * M.det := by\n  rw [\u2190 det_transpose, transpose_submatrix, det_permute, det_transpose]\n\n/-- Permuting rows and columns with the same equivalence does not change the determinant. -/\n@[simp]\ntheorem det_submatrix_equiv_self (e : n \u2243 m) (A : Matrix m m R) :\n    det (A.submatrix e e) = det A := by\n  rw [det_apply', det_apply']\n  apply Fintype.sum_equiv (Equiv.permCongr e)\n  intro \u03c3\n  rw [Equiv.Perm.sign_permCongr e \u03c3]\n  congr 1\n  apply Fintype.prod_equiv e\n  intro i\n  rw [Equiv.permCongr_apply, Equiv.symm_apply_apply, submatrix_apply]\n\n/-- Permuting rows and columns with two equivalences does not change the absolute value of the\ndeterminant. -/\n@[simp]\ntheorem abs_det_submatrix_equiv_equiv {R : Type*} [LinearOrderedCommRing R]\n    (e\u2081 e\u2082 : n \u2243 m) (A : Matrix m m R) :\n    |(A.submatrix e\u2081 e\u2082).det| = |A.det| := by\n  have hee : e\u2082 = e\u2081.trans (e\u2081.symm.trans e\u2082) := by ext; simp\n  rw [hee]\n  show |((A.submatrix id (e\u2081.symm.trans e\u2082)).submatrix e\u2081 e\u2081).det| = |A.det|\n  rw [Matrix.det_submatrix_equiv_self, Matrix.det_permute', abs_mul, abs_unit_intCast, one_mul]\n\n/-- Reindexing both indices along the same equivalence preserves the determinant.\n\nFor the `simp` version of this lemma, see `det_submatrix_equiv_self`; this one is unsuitable because\n`Matrix.reindex_apply` unfolds `reindex` first.\n-/\ntheorem det_reindex_self (e : m \u2243 n) (A : Matrix m m R) : det (reindex e e A) = det A :=\n  det_submatrix_equiv_self e.symm A\n\ntheorem det_smul (A : Matrix n n R) (c : R) : det (c \u2022 A) = c ^ Fintype.card n * det A :=\n  calc\n    det (c \u2022 A) = det ((diagonal fun _ => c) * A) := by rw [smul_eq_diagonal_mul]\n    _ = det (diagonal fun _ => c) * det A := det_mul _ _\n    _ = c ^ Fintype.card n * det A := by simp [card_univ]\n\n@[simp]\ntheorem det_smul_of_tower {\u03b1} [Monoid \u03b1] [DistribMulAction \u03b1 R] [IsScalarTower \u03b1 R R]\n    [SMulCommClass \u03b1 R R] (c : \u03b1) (A : Matrix n n R) :\n    det (c \u2022 A) = c ^ Fintype.card n \u2022 det A := by\n  rw [\u2190 smul_one_smul R c A, det_smul, smul_pow, one_pow, smul_mul_assoc, one_mul]\n\ntheorem det_neg (A : Matrix n n R) : det (-A) = (-1) ^ Fintype.card n * det A := by\n  rw [\u2190 det_smul, neg_one_smul]\n\n/-- A variant of `Matrix.det_neg` with scalar multiplication by `Units \u2124` instead of multiplication\nby `R`. -/\ntheorem det_neg_eq_smul (A : Matrix n n R) :\n    det (-A) = (-1 : Units \u2124) ^ Fintype.card n \u2022 det A := by\n  rw [\u2190 det_smul_of_tower, Units.neg_smul, one_smul]\n\n/-- Multiplying each row by a fixed `v i` multiplies the determinant by\nthe product of the `v`s. -/\ntheorem det_mul_row (v : n \u2192 R) (A : Matrix n n R) :\n    det (of fun i j => v j * A i j) = (\u220f i, v i) * det A :=\n  calc\n    det (of fun i j => v j * A i j) = det (A * diagonal v) :=\n      congr_arg det <| by\n        ext\n        simp [mul_comm]\n    _ = (\u220f i, v i) * det A := by rw [det_mul, det_diagonal, mul_comm]\n\n/-- Multiplying each column by a fixed `v j` multiplies the determinant by\nthe product of the `v`s. -/\ntheorem det_mul_column (v : n \u2192 R) (A : Matrix n n R) :\n    det (of fun i j => v i * A i j) = (\u220f i, v i) * det A :=\n  MultilinearMap.map_smul_univ _ v A\n\n@[simp]\ntheorem det_pow (M : Matrix m m R) (n : \u2115) : det (M ^ n) = det M ^ n :=\n  (detMonoidHom : Matrix m m R \u2192* R).map_pow M n\n\nsection HomMap\n\nvariable {S : Type w} [CommRing S]\n\ntheorem _root_.RingHom.map_det (f : R \u2192+* S) (M : Matrix n n R) :\n    f M.det = Matrix.det (f.mapMatrix M) := by\n  simp [Matrix.det_apply', map_sum f, map_prod f]\n\ntheorem _root_.RingEquiv.map_det (f : R \u2243+* S) (M : Matrix n n R) :\n    f M.det = Matrix.det (f.mapMatrix M) :=\n  f.toRingHom.map_det _\n\ntheorem _root_.AlgHom.map_det [Algebra R S] {T : Type z} [CommRing T] [Algebra R T] (f : S \u2192\u2090[R] T)\n    (M : Matrix n n S) : f M.det = Matrix.det (f.mapMatrix M) :=\n  f.toRingHom.map_det _\n\ntheorem _root_.AlgEquiv.map_det [Algebra R S] {T : Type z} [CommRing T] [Algebra R T]\n    (f : S \u2243\u2090[R] T) (M : Matrix n n S) : f M.det = Matrix.det (f.mapMatrix M) :=\n  f.toAlgHom.map_det _\n\nend HomMap\n\n@[simp]\ntheorem det_conjTranspose [StarRing R] (M : Matrix m m R) : det M\u1d34 = star (det M) :=\n  ((starRingEnd R).map_det _).symm.trans <| congr_arg star M.det_transpose\n\nsection DetZero\n\n/-!\n### `det_zero` section\n\nProve that a matrix with a repeated column has determinant equal to zero.\n-/\n\n\ntheorem det_eq_zero_of_row_eq_zero {A : Matrix n n R} (i : n) (h : \u2200 j, A i j = 0) : det A = 0 :=\n  (detRowAlternating : (n \u2192 R) [\u22c0^n]\u2192\u2097[R] R).map_coord_zero i (funext h)\n\ntheorem det_eq_zero_of_column_eq_zero {A : Matrix n n R} (j : n) (h : \u2200 i, A i j = 0) :\n    det A = 0 := by\n  rw [\u2190 det_transpose]\n  exact det_eq_zero_of_row_eq_zero j h\n\nvariable {M : Matrix n n R} {i j : n}\n\n/-- If a matrix has a repeated row, the determinant will be zero. -/\ntheorem det_zero_of_row_eq (i_ne_j : i \u2260 j) (hij : M i = M j) : M.det = 0 :=\n  (detRowAlternating : (n \u2192 R) [\u22c0^n]\u2192\u2097[R] R).map_eq_zero_of_eq M hij i_ne_j\n\n/-- If a matrix has a repeated column, the determinant will be zero. -/\ntheorem det_zero_of_column_eq (i_ne_j : i \u2260 j) (hij : \u2200 k, M k i = M k j) : M.det = 0 := by\n  rw [\u2190 det_transpose, det_zero_of_row_eq i_ne_j]\n  exact funext hij\n\n/-- If we repeat a row of a matrix, we get a matrix of determinant zero. -/\ntheorem det_updateRow_eq_zero (h : i \u2260 j) :\n    (M.updateRow j (M i)).det = 0 := det_zero_of_row_eq h (by simp [h])\n\n/-- If we repeat a column of a matrix, we get a matrix of determinant zero. -/\ntheorem det_updateCol_eq_zero (h : i \u2260 j) :\n    (M.updateCol j (fun k \u21a6 M k i)).det = 0 := det_zero_of_column_eq h (by simp [h])\n\n@[deprecated (since := \"2024-12-11\")] alias det_updateColumn_eq_zero := det_updateCol_eq_zero\n\nend DetZero\n\ntheorem det_updateRow_add (M : Matrix n n R) (j : n) (u v : n \u2192 R) :\n    det (updateRow M j <| u + v) = det (updateRow M j u) + det (updateRow M j v) :=\n  (detRowAlternating : (n \u2192 R) [\u22c0^n]\u2192\u2097[R] R).map_update_add M j u v\n\ntheorem det_updateCol_add (M : Matrix n n R) (j : n) (u v : n \u2192 R) :\n    det (updateCol M j <| u + v) = det (updateCol M j u) + det (updateCol M j v) := by\n  rw [\u2190 det_transpose, \u2190 updateRow_transpose, det_updateRow_add]\n  simp [updateRow_transpose, det_transpose]\n\n@[deprecated (since := \"2024-12-11\")] alias det_updateColumn_add := det_updateCol_add\n\ntheorem det_updateRow_smul (M : Matrix n n R) (j : n) (s : R) (u : n \u2192 R) :\n    det (updateRow M j <| s \u2022 u) = s * det (updateRow M j u) :=\n  (detRowAlternating : (n \u2192 R) [\u22c0^n]\u2192\u2097[R] R).map_update_smul M j s u\n\ntheorem det_updateCol_smul (M : Matrix n n R) (j : n) (s : R) (u : n \u2192 R) :\n    det (updateCol M j <| s \u2022 u) = s * det (updateCol M j u) := by\n  rw [\u2190 det_transpose, \u2190 updateRow_transpose, det_updateRow_smul]\n  simp [updateRow_transpose, det_transpose]\n\n@[deprecated (since := \"2024-12-11\")] alias det_updateColumn_smul := det_updateCol_smul\n\ntheorem det_updateRow_smul_left (M : Matrix n n R) (j : n) (s : R) (u : n \u2192 R) :\n    det (updateRow (s \u2022 M) j u) = s ^ (Fintype.card n - 1) * det (updateRow M j u) :=\n  MultilinearMap.map_update_smul_left _ M j s u\n\n@[deprecated (since := \"2024-11-03\")] alias det_updateRow_smul' := det_updateRow_smul_left\n\n", "theoremStatement": "theorem det_updateCol_smul_left (M : Matrix n n R) (j : n) (s : R) (u : n \u2192 R) :\n    det (updateCol (s \u2022 M) j u) = s ^ (Fintype.card n - 1) * det (updateCol M j u) ", "theoremName": "Matrix.det_updateCol_smul_left", "fileCreated": {"commit": "3438911a821fa2fb5ba37cdbec993e952646aeca", "date": "2024-06-03"}, "theoremCreated": {"commit": "afdb9499da5095474266bcb3b723120eaf923aec", "date": "2024-12-11"}, "file": "mathlib/Mathlib/LinearAlgebra/Matrix/Determinant/Basic.lean", "module": "Mathlib.LinearAlgebra.Matrix.Determinant.Basic", "jsonFile": "Mathlib.LinearAlgebra.Matrix.Determinant.Basic.jsonl", "positionMetadata": {"lineInFile": 387, "tokenPositionInFile": 15991, "theoremPositionInFile": 51}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 28, "numPremises": 55}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [\u2190 det_transpose, \u2190 updateRow_transpose, transpose_smul, det_updateRow_smul_left]\n  simp [updateRow_transpose, det_transpose]", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 136}}
{"srcContext": "/-\nCopyright (c) 2015 Microsoft Corporation. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Leonardo de Moura, Jeremy Avigad, Mario Carneiro\n-/\nimport Batteries.Data.Nat.Gcd\nimport Mathlib.Algebra.Group.Nat.Units\nimport Mathlib.Algebra.GroupWithZero.Nat\nimport Mathlib.Algebra.Prime.Defs\nimport Mathlib.Data.Nat.Sqrt\nimport Mathlib.Order.Basic\n\n/-!\n# Prime numbers\n\nThis file deals with prime numbers: natural numbers `p \u2265 2` whose only divisors are `p` and `1`.\n\n## Important declarations\n\n- `Nat.Prime`: the predicate that expresses that a natural number `p` is prime\n- `Nat.Primes`: the subtype of natural numbers that are prime\n- `Nat.minFac n`: the minimal prime factor of a natural number `n \u2260 1`\n- `Nat.prime_iff`: `Nat.Prime` coincides with the general definition of `Prime`\n- `Nat.irreducible_iff_nat_prime`: a non-unit natural number is\n                                  only divisible by `1` iff it is prime\n\n-/\n\nassert_not_exists Ring\n\nopen Bool Subtype Nat\n\nnamespace Nat\nvariable {n : \u2115}\n\n/-- `Nat.Prime p` means that `p` is a prime number, that is, a natural number\n  at least 2 whose only divisors are `p` and `1`.\n  The theorem `Nat.prime_def` witnesses this description of a prime number. -/\n@[pp_nodot]\ndef Prime (p : \u2115) :=\n  Irreducible p\n\ntheorem irreducible_iff_nat_prime (a : \u2115) : Irreducible a \u2194 Nat.Prime a :=\n  Iff.rfl\n\n@[aesop safe destruct] theorem not_prime_zero : \u00acPrime 0\n  | h => h.ne_zero rfl\n\n@[aesop safe destruct] theorem not_prime_one : \u00acPrime 1\n  | h => h.ne_one rfl\n\ntheorem Prime.ne_zero {n : \u2115} (h : Prime n) : n \u2260 0 :=\n  Irreducible.ne_zero h\n\ntheorem Prime.pos {p : \u2115} (pp : Prime p) : 0 < p :=\n  Nat.pos_of_ne_zero pp.ne_zero\n\ntheorem Prime.two_le : \u2200 {p : \u2115}, Prime p \u2192 2 \u2264 p\n  | 0, h => (not_prime_zero h).elim\n  | 1, h => (not_prime_one h).elim\n  | _ + 2, _ => le_add_left 2 _\n\ntheorem Prime.one_lt {p : \u2115} : Prime p \u2192 1 < p :=\n  Prime.two_le\n\nlemma Prime.one_le {p : \u2115} (hp : p.Prime) : 1 \u2264 p := hp.one_lt.le\n\ninstance Prime.one_lt' (p : \u2115) [hp : Fact p.Prime] : Fact (1 < p) :=\n  \u27e8hp.1.one_lt\u27e9\n\ntheorem Prime.ne_one {p : \u2115} (hp : p.Prime) : p \u2260 1 :=\n  hp.one_lt.ne'\n\ntheorem Prime.eq_one_or_self_of_dvd {p : \u2115} (pp : p.Prime) (m : \u2115) (hm : m \u2223 p) :\n    m = 1 \u2228 m = p := by\n  obtain \u27e8n, hn\u27e9 := hm\n  have := pp.isUnit_or_isUnit hn\n  rw [Nat.isUnit_iff, Nat.isUnit_iff] at this\n  apply Or.imp_right _ this\n  rintro rfl\n  rw [hn, mul_one]\n\n@[inherit_doc Nat.Prime]\ntheorem prime_def {p : \u2115} : Prime p \u2194 2 \u2264 p \u2227 \u2200 m, m \u2223 p \u2192 m = 1 \u2228 m = p := by\n  refine \u27e8fun h => \u27e8h.two_le, h.eq_one_or_self_of_dvd\u27e9, fun h => ?_\u27e9\n  have h1 := Nat.one_lt_two.trans_le h.1\n  refine \u27e8mt Nat.isUnit_iff.mp h1.ne', fun a b hab => ?_\u27e9\n  simp only [Nat.isUnit_iff]\n  apply Or.imp_right _ (h.2 a _)\n  \u00b7 rintro rfl\n    rw [\u2190 mul_right_inj' (not_eq_zero_of_lt h1), \u2190 hab, mul_one]\n  \u00b7 rw [hab]\n    exact dvd_mul_right _ _\n\n@[deprecated (since := \"2024-11-19\")]\nalias prime_def_lt'' := prime_def\n\ntheorem prime_def_lt {p : \u2115} : Prime p \u2194 2 \u2264 p \u2227 \u2200 m < p, m \u2223 p \u2192 m = 1 :=\n  prime_def.trans <|\n    and_congr_right fun p2 =>\n      forall_congr' fun _ =>\n        \u27e8fun h l d => (h d).resolve_right (ne_of_lt l), fun h d =>\n          (le_of_dvd (le_of_succ_le p2) d).lt_or_eq_dec.imp_left fun l => h l d\u27e9\n\ntheorem prime_def_lt' {p : \u2115} : Prime p \u2194 2 \u2264 p \u2227 \u2200 m, 2 \u2264 m \u2192 m < p \u2192 \u00acm \u2223 p :=\n  prime_def_lt.trans <|\n    and_congr_right fun p2 =>\n      forall_congr' fun m =>\n        \u27e8fun h m2 l d => not_lt_of_ge m2 ((h l d).symm \u25b8 by decide), fun h l d => by\n          rcases m with (_ | _ | m)\n          \u00b7 rw [eq_zero_of_zero_dvd d] at p2\n            revert p2\n            decide\n          \u00b7 rfl\n          \u00b7 exact (h (le_add_left 2 m) l).elim d\u27e9\n\ntheorem prime_def_le_sqrt {p : \u2115} : Prime p \u2194 2 \u2264 p \u2227 \u2200 m, 2 \u2264 m \u2192 m \u2264 sqrt p \u2192 \u00acm \u2223 p :=\n  prime_def_lt'.trans <|\n    and_congr_right fun p2 =>\n      \u27e8fun a m m2 l => a m m2 <| lt_of_le_of_lt l <| sqrt_lt_self p2, fun a =>\n        have : \u2200 {m k : \u2115}, m \u2264 k \u2192 1 < m \u2192 p \u2260 m * k := fun {m k} mk m1 e =>\n          a m m1 (le_sqrt.2 (e.symm \u25b8 Nat.mul_le_mul_left m mk)) \u27e8k, e\u27e9\n        fun m m2 l \u27e8k, e\u27e9 => by\n        rcases le_total m k with mk | km\n        \u00b7 exact this mk m2 e\n        \u00b7 rw [mul_comm] at e\n          refine this km (Nat.lt_of_mul_lt_mul_right (a := m) ?_) e\n          rwa [one_mul, \u2190 e]\u27e9\n\ntheorem prime_of_coprime (n : \u2115) (h1 : 1 < n) (h : \u2200 m < n, m \u2260 0 \u2192 n.Coprime m) : Prime n := by\n  refine prime_def_lt.mpr \u27e8h1, fun m mlt mdvd => ?_\u27e9\n  have hm : m \u2260 0 := by\n    rintro rfl\n    rw [zero_dvd_iff] at mdvd\n    exact mlt.ne' mdvd\n  exact (h m mlt hm).symm.eq_one_of_dvd mdvd\n\n/--\nThis instance is set up to work in the kernel (`by decide`) for small values.\n\nBelow (`decidablePrime'`) we will define a faster variant to be used by the compiler\n(e.g. in `#eval` or `by native_decide`).\n\nIf you need to prove that a particular number is prime, in any case\nyou should not use `by decide`, but rather `by norm_num`, which is\nmuch faster.\n-/\ninstance decidablePrime (p : \u2115) : Decidable (Prime p) :=\n  decidable_of_iff' _ prime_def_lt'\n\ntheorem prime_two : Prime 2 := by decide\n\ntheorem prime_three : Prime 3 := by decide\n\ntheorem prime_five : Prime 5 := by decide\n\ntheorem dvd_prime {p m : \u2115} (pp : Prime p) : m \u2223 p \u2194 m = 1 \u2228 m = p :=\n  \u27e8fun d => pp.eq_one_or_self_of_dvd m d, fun h =>\n    h.elim (fun e => e.symm \u25b8 one_dvd _) fun e => e.symm \u25b8 dvd_rfl\u27e9\n\ntheorem dvd_prime_two_le {p m : \u2115} (pp : Prime p) (H : 2 \u2264 m) : m \u2223 p \u2194 m = p :=\n  (dvd_prime pp).trans <| or_iff_right_of_imp <| Not.elim <| ne_of_gt H\n\ntheorem prime_dvd_prime_iff_eq {p q : \u2115} (pp : p.Prime) (qp : q.Prime) : p \u2223 q \u2194 p = q :=\n  dvd_prime_two_le qp (Prime.two_le pp)\n\ntheorem Prime.not_dvd_one {p : \u2115} (pp : Prime p) : \u00acp \u2223 1 :=\n  Irreducible.not_dvd_one pp\n\nsection MinFac\n\ntheorem minFac_lemma (n k : \u2115) (h : \u00acn < k * k) : sqrt n - k < sqrt n + 2 - k :=\n  (Nat.sub_lt_sub_right <| le_sqrt.2 <| le_of_not_gt h) <| Nat.lt_add_of_pos_right (by decide)\n\n/--\nIf `n < k * k`, then `minFacAux n k = n`, if `k | n`, then `minFacAux n k = k`.\nOtherwise, `minFacAux n k = minFacAux n (k+2)` using well-founded recursion.\nIf `n` is odd and `1 < n`, then `minFacAux n 3` is the smallest prime factor of `n`.\n\nBy default this well-founded recursion would be irreducible.\nThis prevents use `decide` to resolve `Nat.prime n` for small values of `n`,\nso we mark this as `@[semireducible]`.\n\nIn future, we may want to remove this annotation and instead use `norm_num` instead of `decide`\nin these situations.\n-/\n@[semireducible] def minFacAux (n : \u2115) : \u2115 \u2192 \u2115\n  | k =>\n    if n < k * k then n\n    else\n      if k \u2223 n then k\n      else\n        minFacAux n (k + 2)\ntermination_by k => sqrt n + 2 - k\ndecreasing_by simp_wf; apply minFac_lemma n k; assumption\n\n/-- Returns the smallest prime factor of `n \u2260 1`. -/\ndef minFac (n : \u2115) : \u2115 :=\n  if 2 \u2223 n then 2 else minFacAux n 3\n\n@[simp]\ntheorem minFac_zero : minFac 0 = 2 :=\n  rfl\n\n@[simp]\ntheorem minFac_one : minFac 1 = 1 := by\n  simp [minFac, minFacAux]\n\n@[simp]\ntheorem minFac_two : minFac 2 = 2 := by\n  simp [minFac, minFacAux]\n\ntheorem minFac_eq (n : \u2115) : minFac n = if 2 \u2223 n then 2 else minFacAux n 3 := rfl\n\nprivate def minFacProp (n k : \u2115) :=\n  2 \u2264 k \u2227 k \u2223 n \u2227 \u2200 m, 2 \u2264 m \u2192 m \u2223 n \u2192 k \u2264 m\n\ntheorem minFacAux_has_prop {n : \u2115} (n2 : 2 \u2264 n) :\n    \u2200 k i, k = 2 * i + 3 \u2192 (\u2200 m, 2 \u2264 m \u2192 m \u2223 n \u2192 k \u2264 m) \u2192 minFacProp n (minFacAux n k)\n  | k => fun i e a => by\n    rw [minFacAux]\n    by_cases h : n < k * k\n    \u00b7 have pp : Prime n :=\n        prime_def_le_sqrt.2\n          \u27e8n2, fun m m2 l d => not_lt_of_ge l <| lt_of_lt_of_le (sqrt_lt.2 h) (a m m2 d)\u27e9\n      simpa only [k, h] using\n        \u27e8n2, dvd_rfl, fun m m2 d => le_of_eq ((dvd_prime_two_le pp m2).1 d).symm\u27e9\n    have k2 : 2 \u2264 k := by\n      subst e\n      apply Nat.le_add_left\n    simp only [k, h, \u2193reduceIte]\n    by_cases dk : k \u2223 n <;> simp only [k, dk, \u2193reduceIte]\n    \u00b7 exact \u27e8k2, dk, a\u27e9\n    \u00b7 refine\n        have := minFac_lemma n k h\n        minFacAux_has_prop n2 (k + 2) (i + 1) (by simp [k, e, Nat.left_distrib, add_right_comm])\n          fun m m2 d => ?_\n      rcases Nat.eq_or_lt_of_le (a m m2 d) with me | ml\n      \u00b7 subst me\n        contradiction\n      apply (Nat.eq_or_lt_of_le ml).resolve_left\n      intro me\n      rw [\u2190 me, e] at d\n      have d' : 2 * (i + 2) \u2223 n := d\n      have := a _ le_rfl (dvd_of_mul_right_dvd d')\n      rw [e] at this\n      exact absurd this (by contradiction)\n  termination_by k => sqrt n + 2 - k\n\ntheorem minFac_has_prop {n : \u2115} (n1 : n \u2260 1) : minFacProp n (minFac n) := by\n  by_cases n0 : n = 0\n  \u00b7 simp [n0, minFacProp, GE.ge]\n  have n2 : 2 \u2264 n := by\n    revert n0 n1\n    rcases n with (_ | _ | _) <;> simp [succ_le_succ]\n  simp only [minFac_eq, Nat.isUnit_iff]\n  by_cases d2 : 2 \u2223 n <;> simp only [d2, \u2193reduceIte]\n  \u00b7 exact \u27e8le_rfl, d2, fun k k2 _ => k2\u27e9\n  \u00b7 refine\n      minFacAux_has_prop n2 3 0 rfl fun m m2 d => (Nat.eq_or_lt_of_le m2).resolve_left (mt ?_ d2)\n    exact fun e => e.symm \u25b8 d\n\ntheorem minFac_dvd (n : \u2115) : minFac n \u2223 n :=\n  if n1 : n = 1 then by simp [n1] else (minFac_has_prop n1).2.1\n\ntheorem minFac_prime {n : \u2115} (n1 : n \u2260 1) : Prime (minFac n) :=\n  let \u27e8f2, fd, a\u27e9 := minFac_has_prop n1\n  prime_def_lt'.2 \u27e8f2, fun m m2 l d => not_le_of_gt l (a m m2 (d.trans fd))\u27e9\n\ntheorem minFac_le_of_dvd {n : \u2115} : \u2200 {m : \u2115}, 2 \u2264 m \u2192 m \u2223 n \u2192 minFac n \u2264 m := by\n  by_cases n1 : n = 1\n  \u00b7 exact fun m2 _ => n1.symm \u25b8 le_trans (by simp) m2\n  \u00b7 apply (minFac_has_prop n1).2.2\n\ntheorem minFac_pos (n : \u2115) : 0 < minFac n := by\n  by_cases n1 : n = 1\n  \u00b7 simp [n1]\n  \u00b7 exact (minFac_prime n1).pos\n\ntheorem minFac_le {n : \u2115} (H : 0 < n) : minFac n \u2264 n :=\n  le_of_dvd H (minFac_dvd n)\n\ntheorem le_minFac {m n : \u2115} : n = 1 \u2228 m \u2264 minFac n \u2194 \u2200 p, Prime p \u2192 p \u2223 n \u2192 m \u2264 p :=\n  \u27e8fun h p pp d =>\n    h.elim (by rintro rfl; cases pp.not_dvd_one d) fun h =>\n      le_trans h <| minFac_le_of_dvd pp.two_le d,\n    fun H => or_iff_not_imp_left.2 fun n1 => H _ (minFac_prime n1) (minFac_dvd _)\u27e9\n\ntheorem le_minFac' {m n : \u2115} : n = 1 \u2228 m \u2264 minFac n \u2194 \u2200 p, 2 \u2264 p \u2192 p \u2223 n \u2192 m \u2264 p :=\n  \u27e8fun h p (pp : 1 < p) d =>\n    h.elim (by rintro rfl; cases not_le_of_lt pp (le_of_dvd (by decide) d)) fun h =>\n      le_trans h <| minFac_le_of_dvd pp d,\n    fun H => le_minFac.2 fun p pp d => H p pp.two_le d\u27e9\n\ntheorem prime_def_minFac {p : \u2115} : Prime p \u2194 2 \u2264 p \u2227 minFac p = p :=\n  \u27e8fun pp =>\n    \u27e8pp.two_le,\n      let \u27e8f2, fd, _\u27e9 := minFac_has_prop <| ne_of_gt pp.one_lt\n      ((dvd_prime pp).1 fd).resolve_left (ne_of_gt f2)\u27e9,\n    fun \u27e8p2, e\u27e9 => e \u25b8 minFac_prime (ne_of_gt p2)\u27e9\n\n@[simp]\ntheorem Prime.minFac_eq {p : \u2115} (hp : Prime p) : minFac p = p :=\n  (prime_def_minFac.1 hp).2\n\n/--\nThis definition is faster in the virtual machine than `decidablePrime`,\nbut slower in the kernel.\n-/\ndef decidablePrime' (p : \u2115) : Decidable (Prime p) :=\n  decidable_of_iff' _ prime_def_minFac\n\n", "theoremStatement": "@[csimp] theorem decidablePrime_csimp :\n    @decidablePrime = @decidablePrime' ", "theoremName": "Nat.decidablePrime_csimp", "fileCreated": {"commit": "12473136ebd2e811c9c929c11522af5a32d603fb", "date": "2024-07-02"}, "theoremCreated": {"commit": "ef7c8b7a682df3d3fda03aa2aebc07d07433d1ca", "date": "2024-12-20"}, "file": "mathlib/Mathlib/Data/Nat/Prime/Defs.lean", "module": "Mathlib.Data.Nat.Prime.Defs", "jsonFile": "Mathlib.Data.Nat.Prime.Defs.jsonl", "positionMetadata": {"lineInFile": 313, "tokenPositionInFile": 10765, "theoremPositionInFile": 38}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 3, "numPremises": 9}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  funext; apply Subsingleton.elim", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 39}}
{"srcContext": "/-\nCopyright (c) 2020 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kevin Buzzard, Johan Commelin, Patrick Massot\n-/\nimport Mathlib.Algebra.Order.Hom.Monoid\nimport Mathlib.Algebra.Order.Ring.Basic\nimport Mathlib.RingTheory.Ideal.Maps\nimport Mathlib.Tactic.TFAE\n\n/-!\n\n# The basics of valuation theory.\n\nThe basic theory of valuations (non-archimedean norms) on a commutative ring,\nfollowing T. Wedhorn's unpublished notes \u201cAdic Spaces\u201d ([wedhorn_adic]).\n\nThe definition of a valuation we use here is Definition 1.22 of [wedhorn_adic].\nA valuation on a ring `R` is a monoid homomorphism `v` to a linearly ordered\ncommutative monoid with zero, that in addition satisfies the following two axioms:\n * `v 0 = 0`\n * `\u2200 x y, v (x + y) \u2264 max (v x) (v y)`\n\n`Valuation R \u0393\u2080`is the type of valuations `R \u2192 \u0393\u2080`, with a coercion to the underlying\nfunction. If `v` is a valuation from `R` to `\u0393\u2080` then the induced group\nhomomorphism `Units(R) \u2192 \u0393\u2080` is called `unit_map v`.\n\nThe equivalence \"relation\" `IsEquiv v\u2081 v\u2082 : Prop` defined in 1.27 of [wedhorn_adic] is not strictly\nspeaking a relation, because `v\u2081 : Valuation R \u0393\u2081` and `v\u2082 : Valuation R \u0393\u2082` might\nnot have the same type. This corresponds in ZFC to the set-theoretic difficulty\nthat the class of all valuations (as `\u0393\u2080` varies) on a ring `R` is not a set.\nThe \"relation\" is however reflexive, symmetric and transitive in the obvious\nsense. Note that we use 1.27(iii) of [wedhorn_adic] as the definition of equivalence.\n\n## Main definitions\n\n* `Valuation R \u0393\u2080`, the type of valuations on `R` with values in `\u0393\u2080`\n* `Valuation.IsEquiv`, the heterogeneous equivalence relation on valuations\n* `Valuation.supp`, the support of a valuation\n\n* `AddValuation R \u0393\u2080`, the type of additive valuations on `R` with values in a\n  linearly ordered additive commutative group with a top element, `\u0393\u2080`.\n\n## Implementation Details\n\n`AddValuation R \u0393\u2080` is implemented as `Valuation R (Multiplicative \u0393\u2080)\u1d52\u1d48`.\n\n## Notation\n\nIn the `DiscreteValuation` locale:\n\n * `\u2115\u2098\u2080` is a shorthand for `WithZero (Multiplicative \u2115)`\n * `\u2124\u2098\u2080` is a shorthand for `WithZero (Multiplicative \u2124)`\n\n## TODO\n\nIf ever someone extends `Valuation`, we should fully comply to the `DFunLike` by migrating the\nboilerplate lemmas to `ValuationClass`.\n-/\n\nopen Function Ideal\n\nnoncomputable section\n\nvariable {K F R : Type*} [DivisionRing K]\n\nsection\n\nvariable (F R) (\u0393\u2080 : Type*) [LinearOrderedCommMonoidWithZero \u0393\u2080] [Ring R]\n\n/-- The type of `\u0393\u2080`-valued valuations on `R`.\n\nWhen you extend this structure, make sure to extend `ValuationClass`. -/\nstructure Valuation extends R \u2192*\u2080 \u0393\u2080 where\n  /-- The valuation of a a sum is less that the sum of the valuations -/\n  map_add_le_max' : \u2200 x y, toFun (x + y) \u2264 max (toFun x) (toFun y)\n\n/-- `ValuationClass F \u03b1 \u03b2` states that `F` is a type of valuations.\n\nYou should also extend this typeclass when you extend `Valuation`. -/\nclass ValuationClass (F) (R \u0393\u2080 : outParam Type*) [LinearOrderedCommMonoidWithZero \u0393\u2080] [Ring R]\n  [FunLike F R \u0393\u2080]\n  extends MonoidWithZeroHomClass F R \u0393\u2080 : Prop where\n  /-- The valuation of a a sum is less that the sum of the valuations -/\n  map_add_le_max (f : F) (x y : R) : f (x + y) \u2264 max (f x) (f y)\n\nexport ValuationClass (map_add_le_max)\n\ninstance [FunLike F R \u0393\u2080] [ValuationClass F R \u0393\u2080] : CoeTC F (Valuation R \u0393\u2080) :=\n  \u27e8fun f =>\n    { toFun := f\n      map_one' := map_one f\n      map_zero' := map_zero f\n      map_mul' := map_mul f\n      map_add_le_max' := map_add_le_max f }\u27e9\n\nend\n\nnamespace Valuation\n\nvariable {\u0393\u2080 : Type*}\nvariable {\u0393'\u2080 : Type*}\nvariable {\u0393''\u2080 : Type*} [LinearOrderedCommMonoidWithZero \u0393''\u2080]\n\nsection Basic\n\nvariable [Ring R]\n\nsection Monoid\n\nvariable [LinearOrderedCommMonoidWithZero \u0393\u2080] [LinearOrderedCommMonoidWithZero \u0393'\u2080]\n\ninstance : FunLike (Valuation R \u0393\u2080) R \u0393\u2080 where\n  coe f := f.toFun\n  coe_injective' f g h := by\n    obtain \u27e8\u27e8\u27e8_,_\u27e9, _\u27e9, _\u27e9 := f\n    congr\n\ninstance : ValuationClass (Valuation R \u0393\u2080) R \u0393\u2080 where\n  map_mul f := f.map_mul'\n  map_one f := f.map_one'\n  map_zero f := f.map_zero'\n  map_add_le_max f := f.map_add_le_max'\n\n@[simp]\ntheorem coe_mk (f : R \u2192*\u2080 \u0393\u2080) (h) : \u21d1(Valuation.mk f h) = f := rfl\n\ntheorem toFun_eq_coe (v : Valuation R \u0393\u2080) : v.toFun = v := rfl\n\n@[simp]\ntheorem toMonoidWithZeroHom_coe_eq_coe (v : Valuation R \u0393\u2080) :\n    (v.toMonoidWithZeroHom : R \u2192 \u0393\u2080) = v := rfl\n\n@[ext]\ntheorem ext {v\u2081 v\u2082 : Valuation R \u0393\u2080} (h : \u2200 r, v\u2081 r = v\u2082 r) : v\u2081 = v\u2082 :=\n  DFunLike.ext _ _ h\n\nvariable (v : Valuation R \u0393\u2080)\n\n@[simp, norm_cast]\ntheorem coe_coe : \u21d1(v : R \u2192*\u2080 \u0393\u2080) = v := rfl\n\ntheorem map_zero : v 0 = 0 :=\n  v.map_zero'\n\ntheorem map_one : v 1 = 1 :=\n  v.map_one'\n\ntheorem map_mul : \u2200 x y, v (x * y) = v x * v y :=\n  v.map_mul'\n\n-- Porting note: LHS side simplified so created map_add'\ntheorem map_add : \u2200 x y, v (x + y) \u2264 max (v x) (v y) :=\n  v.map_add_le_max'\n\n@[simp]\ntheorem map_add' : \u2200 x y, v (x + y) \u2264 v x \u2228 v (x + y) \u2264 v y := by\n  intro x y\n  rw [\u2190 le_max_iff, \u2190 ge_iff_le]\n  apply map_add\n\ntheorem map_add_le {x y g} (hx : v x \u2264 g) (hy : v y \u2264 g) : v (x + y) \u2264 g :=\n  le_trans (v.map_add x y) <| max_le hx hy\n\ntheorem map_add_lt {x y g} (hx : v x < g) (hy : v y < g) : v (x + y) < g :=\n  lt_of_le_of_lt (v.map_add x y) <| max_lt hx hy\n\ntheorem map_sum_le {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hf : \u2200 i \u2208 s, v (f i) \u2264 g) :\n    v (\u2211 i \u2208 s, f i) \u2264 g := by\n  classical\n  refine\n    Finset.induction_on s (fun _ => v.map_zero \u25b8 zero_le')\n      (fun a s has ih hf => ?_) hf\n  rw [Finset.forall_mem_insert] at hf; rw [Finset.sum_insert has]\n  exact v.map_add_le hf.1 (ih hf.2)\n\ntheorem map_sum_lt {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hg : g \u2260 0)\n    (hf : \u2200 i \u2208 s, v (f i) < g) : v (\u2211 i \u2208 s, f i) < g := by\n  classical\n  refine\n    Finset.induction_on s (fun _ => v.map_zero \u25b8 (zero_lt_iff.2 hg))\n      (fun a s has ih hf => ?_) hf\n  rw [Finset.forall_mem_insert] at hf; rw [Finset.sum_insert has]\n  exact v.map_add_lt hf.1 (ih hf.2)\n\ntheorem map_sum_lt' {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hg : 0 < g)\n    (hf : \u2200 i \u2208 s, v (f i) < g) : v (\u2211 i \u2208 s, f i) < g :=\n  v.map_sum_lt (ne_of_gt hg) hf\n\ntheorem map_pow : \u2200 (x) (n : \u2115), v (x ^ n) = v x ^ n :=\n  v.toMonoidWithZeroHom.toMonoidHom.map_pow\n\n-- The following definition is not an instance, because we have more than one `v` on a given `R`.\n-- In addition, type class inference would not be able to infer `v`.\n/-- A valuation gives a preorder on the underlying ring. -/\ndef toPreorder : Preorder R :=\n  Preorder.lift v\n\n/-- If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. -/\ntheorem zero_iff [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) {x : K} : v x = 0 \u2194 x = 0 :=\n  map_eq_zero v\n\ntheorem ne_zero_iff [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) {x : K} : v x \u2260 0 \u2194 x \u2260 0 :=\n  map_ne_zero v\n\nlemma pos_iff [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) {x : K} : 0 < v x \u2194 x \u2260 0 := by\n  rw [zero_lt_iff, ne_zero_iff]\n\ntheorem unit_map_eq (u : R\u02e3) : (Units.map (v : R \u2192* \u0393\u2080) u : \u0393\u2080) = v u :=\n  rfl\n\ntheorem ne_zero_of_unit [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) (x : K\u02e3) : v x \u2260 (0 : \u0393\u2080) := by\n  simp only [ne_eq, Valuation.zero_iff, Units.ne_zero x, not_false_iff]\n\ntheorem ne_zero_of_isUnit [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) (x : K) (hx : IsUnit x) :\n    v x \u2260 (0 : \u0393\u2080) := by\n  simpa [hx.choose_spec] using ne_zero_of_unit v hx.choose\n\n/-- A ring homomorphism `S \u2192 R` induces a map `Valuation R \u0393\u2080 \u2192 Valuation S \u0393\u2080`. -/\ndef comap {S : Type*} [Ring S] (f : S \u2192+* R) (v : Valuation R \u0393\u2080) : Valuation S \u0393\u2080 :=\n  { v.toMonoidWithZeroHom.comp f.toMonoidWithZeroHom with\n    toFun := v \u2218 f\n    map_add_le_max' := fun x y => by simp only [comp_apply, map_add, f.map_add] }\n\n@[simp]\ntheorem comap_apply {S : Type*} [Ring S] (f : S \u2192+* R) (v : Valuation R \u0393\u2080) (s : S) :\n    v.comap f s = v (f s) := rfl\n\n@[simp]\ntheorem comap_id : v.comap (RingHom.id R) = v :=\n  ext fun _r => rfl\n\ntheorem comap_comp {S\u2081 : Type*} {S\u2082 : Type*} [Ring S\u2081] [Ring S\u2082] (f : S\u2081 \u2192+* S\u2082) (g : S\u2082 \u2192+* R) :\n    v.comap (g.comp f) = (v.comap g).comap f :=\n  ext fun _r => rfl\n\n/-- A `\u2264`-preserving group homomorphism `\u0393\u2080 \u2192 \u0393'\u2080` induces a map `Valuation R \u0393\u2080 \u2192 Valuation R \u0393'\u2080`.\n-/\ndef map (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080) (hf : Monotone f) (v : Valuation R \u0393\u2080) : Valuation R \u0393'\u2080 :=\n  { MonoidWithZeroHom.comp f v.toMonoidWithZeroHom with\n    toFun := f \u2218 v\n    map_add_le_max' := fun r s =>\n      calc\n        f (v (r + s)) \u2264 f (max (v r) (v s)) := hf (v.map_add r s)\n        _ = max (f (v r)) (f (v s)) := hf.map_max\n         }\n\n@[simp]\nlemma map_apply (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080) (hf : Monotone f) (v : Valuation R \u0393\u2080) (r : R) :\n    v.map f hf r = f (v r) := rfl\n\n/-- Two valuations on `R` are defined to be equivalent if they induce the same preorder on `R`. -/\ndef IsEquiv (v\u2081 : Valuation R \u0393\u2080) (v\u2082 : Valuation R \u0393'\u2080) : Prop :=\n  \u2200 r s, v\u2081 r \u2264 v\u2081 s \u2194 v\u2082 r \u2264 v\u2082 s\n\n@[simp]\ntheorem map_neg (x : R) : v (-x) = v x :=\n  v.toMonoidWithZeroHom.toMonoidHom.map_neg x\n\ntheorem map_sub_swap (x y : R) : v (x - y) = v (y - x) :=\n  v.toMonoidWithZeroHom.toMonoidHom.map_sub_swap x y\n\ntheorem map_sub (x y : R) : v (x - y) \u2264 max (v x) (v y) :=\n  calc\n    v (x - y) = v (x + -y) := by rw [sub_eq_add_neg]\n    _ \u2264 max (v x) (v <| -y) := v.map_add _ _\n    _ = max (v x) (v y) := by rw [map_neg]\n\ntheorem map_sub_le {x y g} (hx : v x \u2264 g) (hy : v y \u2264 g) : v (x - y) \u2264 g := by\n  rw [sub_eq_add_neg]\n  exact v.map_add_le hx (le_trans (le_of_eq (v.map_neg y)) hy)\n\nvariable {x y : R}\n\ntheorem map_add_of_distinct_val (h : v x \u2260 v y) : v (x + y) = max (v x) (v y) := by\n  suffices \u00acv (x + y) < max (v x) (v y) from\n    or_iff_not_imp_right.1 (le_iff_eq_or_lt.1 (v.map_add x y)) this\n  intro h'\n  wlog vyx : v y < v x generalizing x y\n  \u00b7 refine this h.symm ?_ (h.lt_or_lt.resolve_right vyx)\n    rwa [add_comm, max_comm]\n  rw [max_eq_left_of_lt vyx] at h'\n  apply lt_irrefl (v x)\n  calc\n    v x = v (x + y - y) := by simp\n    _ \u2264 max (v <| x + y) (v y) := map_sub _ _ _\n    _ < v x := max_lt h' vyx\n\ntheorem map_add_eq_of_lt_right (h : v x < v y) : v (x + y) = v y :=\n  (v.map_add_of_distinct_val h.ne).trans (max_eq_right_iff.mpr h.le)\n\ntheorem map_add_eq_of_lt_left (h : v y < v x) : v (x + y) = v x := by\n  rw [add_comm]; exact map_add_eq_of_lt_right _ h\n\ntheorem map_sub_eq_of_lt_right (h : v x < v y) : v (x - y) = v y := by\n  rw [sub_eq_add_neg, map_add_eq_of_lt_right, map_neg]\n  rwa [map_neg]\n\nopen scoped Classical in\ntheorem map_sum_eq_of_lt {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {j : \u03b9}\n    (hj : j \u2208 s) (h0 : v (f j) \u2260 0) (hf : \u2200 i \u2208 s \\ {j}, v (f i) < v (f j)) :\n    v (\u2211 i \u2208 s, f i) = v (f j) := by\n  rw [Finset.sum_eq_add_sum_diff_singleton hj]\n  exact map_add_eq_of_lt_left _ (map_sum_lt _ h0 hf)\n\ntheorem map_sub_eq_of_lt_left (h : v y < v x) : v (x - y) = v x := by\n  rw [sub_eq_add_neg, map_add_eq_of_lt_left]\n  rwa [map_neg]\n\ntheorem map_eq_of_sub_lt (h : v (y - x) < v x) : v y = v x := by\n  have := Valuation.map_add_of_distinct_val v (ne_of_gt h).symm\n  rw [max_eq_right (le_of_lt h)] at this\n  simpa using this\n\ntheorem map_one_add_of_lt (h : v x < 1) : v (1 + x) = 1 := by\n  rw [\u2190 v.map_one] at h\n  simpa only [v.map_one] using v.map_add_eq_of_lt_left h\n\ntheorem map_one_sub_of_lt (h : v x < 1) : v (1 - x) = 1 := by\n  rw [\u2190 v.map_one, \u2190 v.map_neg] at h\n  rw [sub_eq_add_neg 1 x]\n  simpa only [v.map_one, v.map_neg] using v.map_add_eq_of_lt_left h\n\n/-- An ordered monoid isomorphism `\u0393\u2080 \u2243 \u0393'\u2080` induces an equivalence\n`Valuation R \u0393\u2080 \u2243 Valuation R \u0393'\u2080`. -/\ndef congr (f : \u0393\u2080 \u2243*o \u0393'\u2080) : Valuation R \u0393\u2080 \u2243 Valuation R \u0393'\u2080 where\n  toFun := map f f.toOrderIso.monotone\n  invFun := map f.symm f.toOrderIso.symm.monotone\n  left_inv \u03bd := by ext; simp\n  right_inv \u03bd := by ext; simp\n\nend Monoid\n\nsection Group\n\nvariable [LinearOrderedCommGroupWithZero \u0393\u2080] (v : Valuation R \u0393\u2080) {x y : R}\n\ntheorem map_inv {R : Type*} [DivisionRing R] (v : Valuation R \u0393\u2080) : \u2200 x, v x\u207b\u00b9 = (v x)\u207b\u00b9 :=\n  map_inv\u2080 _\n\ntheorem map_div {R : Type*} [DivisionRing R] (v : Valuation R \u0393\u2080) : \u2200 x y, v (x / y) = v x / v y :=\n  map_div\u2080 _\n\ntheorem one_lt_val_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : 1 < v x \u2194 v x\u207b\u00b9 < 1 := by\n  simp [inv_lt_one\u2080 (v.pos_iff.2 h)]\n\ntheorem one_le_val_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : 1 \u2264 v x \u2194 v x\u207b\u00b9 \u2264 1 := by\n  simp [inv_le_one\u2080 (v.pos_iff.2 h)]\n\ntheorem val_lt_one_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : v x < 1 \u2194 1 < v x\u207b\u00b9 := by\n  simp [one_lt_inv\u2080 (v.pos_iff.2 h)]\n\ntheorem val_le_one_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : v x \u2264 1 \u2194 1 \u2264 v x\u207b\u00b9 := by\n  simp [one_le_inv\u2080 (v.pos_iff.2 h)]\n\ntheorem val_eq_one_iff (v : Valuation K \u0393\u2080) {x : K} : v x = 1 \u2194 v x\u207b\u00b9 = 1 := by\n  by_cases h : x = 0\n  \u00b7 simp only [map_inv\u2080, inv_eq_one]\n  \u00b7 simpa only [le_antisymm_iff, And.comm] using and_congr (one_le_val_iff v h) (val_le_one_iff v h)\n\ntheorem val_le_one_or_val_inv_lt_one (v : Valuation K \u0393\u2080) (x : K) : v x \u2264 1 \u2228 v x\u207b\u00b9 < 1 := by\n  by_cases h : x = 0\n  \u00b7 simp only [h, _root_.map_zero, zero_le', inv_zero, zero_lt_one, or_self]\n  \u00b7 simp only [\u2190 one_lt_val_iff v h, le_or_lt]\n\n/--\nThis theorem is a weaker version of `Valuation.val_le_one_or_val_inv_lt_one`, but more symmetric\nin `x` and `x\u207b\u00b9`.\n-/\ntheorem val_le_one_or_val_inv_le_one (v : Valuation K \u0393\u2080) (x : K) : v x \u2264 1 \u2228 v x\u207b\u00b9 \u2264 1 := by\n  by_cases h : x = 0\n  \u00b7 simp only [h, _root_.map_zero, zero_le', inv_zero, or_self]\n  \u00b7 simp only [\u2190 one_le_val_iff v h, le_total]\n\n/-- The subgroup of elements whose valuation is less than a certain unit. -/\ndef ltAddSubgroup (v : Valuation R \u0393\u2080) (\u03b3 : \u0393\u2080\u02e3) : AddSubgroup R where\n  carrier := { x | v x < \u03b3 }\n  zero_mem' := by simp\n  add_mem' {x y} x_in y_in := lt_of_le_of_lt (v.map_add x y) (max_lt x_in y_in)\n  neg_mem' x_in := by rwa [Set.mem_setOf, map_neg]\n\nend Group\n\nend Basic\n\n-- end of section\nnamespace IsEquiv\n\nvariable [Ring R] [LinearOrderedCommMonoidWithZero \u0393\u2080] [LinearOrderedCommMonoidWithZero \u0393'\u2080]\n  {v : Valuation R \u0393\u2080} {v\u2081 : Valuation R \u0393\u2080} {v\u2082 : Valuation R \u0393'\u2080} {v\u2083 : Valuation R \u0393''\u2080}\n\n@[refl]\ntheorem refl : v.IsEquiv v := fun _ _ => Iff.refl _\n\n@[symm]\ntheorem symm (h : v\u2081.IsEquiv v\u2082) : v\u2082.IsEquiv v\u2081 := fun _ _ => Iff.symm (h _ _)\n\n@[trans]\ntheorem trans (h\u2081\u2082 : v\u2081.IsEquiv v\u2082) (h\u2082\u2083 : v\u2082.IsEquiv v\u2083) : v\u2081.IsEquiv v\u2083 := fun _ _ =>\n  Iff.trans (h\u2081\u2082 _ _) (h\u2082\u2083 _ _)\n\ntheorem of_eq {v' : Valuation R \u0393\u2080} (h : v = v') : v.IsEquiv v' := by subst h; rfl\n\ntheorem map {v' : Valuation R \u0393\u2080} (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080) (hf : Monotone f) (inf : Injective f)\n    (h : v.IsEquiv v') : (v.map f hf).IsEquiv (v'.map f hf) :=\n  let H : StrictMono f := hf.strictMono_of_injective inf\n  fun r s =>\n  calc\n    f (v r) \u2264 f (v s) \u2194 v r \u2264 v s := by rw [H.le_iff_le]\n    _ \u2194 v' r \u2264 v' s := h r s\n    _ \u2194 f (v' r) \u2264 f (v' s) := by rw [H.le_iff_le]\n\n/-- `comap` preserves equivalence. -/\ntheorem comap {S : Type*} [Ring S] (f : S \u2192+* R) (h : v\u2081.IsEquiv v\u2082) :\n    (v\u2081.comap f).IsEquiv (v\u2082.comap f) := fun r s => h (f r) (f s)\n\ntheorem val_eq (h : v\u2081.IsEquiv v\u2082) {r s : R} : v\u2081 r = v\u2081 s \u2194 v\u2082 r = v\u2082 s := by\n  simpa only [le_antisymm_iff] using and_congr (h r s) (h s r)\n\ntheorem ne_zero (h : v\u2081.IsEquiv v\u2082) {r : R} : v\u2081 r \u2260 0 \u2194 v\u2082 r \u2260 0 := by\n  have : v\u2081 r \u2260 v\u2081 0 \u2194 v\u2082 r \u2260 v\u2082 0 := not_congr h.val_eq\n  rwa [v\u2081.map_zero, v\u2082.map_zero] at this\n\nend IsEquiv\n\n-- end of namespace\nsection\n\ntheorem isEquiv_of_map_strictMono [LinearOrderedCommMonoidWithZero \u0393\u2080]\n    [LinearOrderedCommMonoidWithZero \u0393'\u2080] [Ring R] {v : Valuation R \u0393\u2080} (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080)\n    (H : StrictMono f) : IsEquiv (v.map f H.monotone) v := fun _x _y =>\n  \u27e8H.le_iff_le.mp, fun h => H.monotone h\u27e9\n\ntheorem isEquiv_iff_val_lt_val [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x y : K}, v x < v y \u2194 v' x < v' y := by\n  simp only [IsEquiv, le_iff_le_iff_lt_iff_lt]\n  exact forall_comm\n\nalias \u27e8IsEquiv.lt_iff_lt, _\u27e9 := isEquiv_iff_val_lt_val\n\ntheorem isEquiv_of_val_le_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080}\n    (h : \u2200 {x : K}, v x \u2264 1 \u2194 v' x \u2264 1) : v.IsEquiv v' := by\n  intro x y\n  obtain rfl | hy := eq_or_ne y 0\n  \u00b7 simp\n  \u00b7 rw [\u2190 div_le_one\u2080, \u2190 v.map_div, h, v'.map_div, div_le_one\u2080] <;>\n      rwa [zero_lt_iff, ne_zero_iff]\n\ntheorem isEquiv_iff_val_le_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v x \u2264 1 \u2194 v' x \u2264 1 :=\n  \u27e8fun h x => by simpa using h x 1, isEquiv_of_val_le_one\u27e9\n\nalias \u27e8IsEquiv.le_one_iff_le_one, _\u27e9 := isEquiv_iff_val_le_one\n\ntheorem isEquiv_iff_val_eq_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v x = 1 \u2194 v' x = 1 := by\n  constructor\n  \u00b7 intro h x\n    simpa using @IsEquiv.val_eq _ _ _ _ _ _ v v' h x 1\n  \u00b7 intro h\n    apply isEquiv_of_val_le_one\n    intro x\n    constructor\n    \u00b7 intro hx\n      rcases lt_or_eq_of_le hx with hx' | hx'\n      \u00b7 have : v (1 + x) = 1 := by\n          rw [\u2190 v.map_one]\n          apply map_add_eq_of_lt_left\n          simpa\n        rw [h] at this\n        rw [show x = -1 + (1 + x) by simp]\n        refine le_trans (v'.map_add _ _) ?_\n        simp [this]\n      \u00b7 rw [h] at hx'\n        exact le_of_eq hx'\n    \u00b7 intro hx\n      rcases lt_or_eq_of_le hx with hx' | hx'\n      \u00b7 have : v' (1 + x) = 1 := by\n          rw [\u2190 v'.map_one]\n          apply map_add_eq_of_lt_left\n          simpa\n        rw [\u2190 h] at this\n        rw [show x = -1 + (1 + x) by simp]\n        refine le_trans (v.map_add _ _) ?_\n        simp [this]\n      \u00b7 rw [\u2190 h] at hx'\n        exact le_of_eq hx'\n\nalias \u27e8IsEquiv.eq_one_iff_eq_one, _\u27e9 := isEquiv_iff_val_eq_one\n\ntheorem isEquiv_iff_val_lt_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v x < 1 \u2194 v' x < 1 := by\n  constructor\n  \u00b7 intro h x\n    simp only [lt_iff_le_and_ne,\n      and_congr h.le_one_iff_le_one h.eq_one_iff_eq_one.not]\n  \u00b7 rw [isEquiv_iff_val_eq_one]\n    intro h x\n    by_cases hx : x = 0\n    \u00b7 simp only [(zero_iff _).2 hx, zero_ne_one]\n    constructor\n    \u00b7 intro hh\n      by_contra h_1\n      cases ne_iff_lt_or_gt.1 h_1 with\n      | inl h_2 => simpa [hh, lt_self_iff_false] using h.2 h_2\n      | inr h_2 =>\n          rw [\u2190 inv_one, \u2190 inv_eq_iff_eq_inv, \u2190 map_inv\u2080] at hh\n          exact hh.not_lt (h.2 ((one_lt_val_iff v' hx).1 h_2))\n    \u00b7 intro hh\n      by_contra h_1\n      cases ne_iff_lt_or_gt.1 h_1 with\n      | inl h_2 => simpa [hh, lt_self_iff_false] using h.1 h_2\n      | inr h_2 =>\n        rw [\u2190 inv_one, \u2190 inv_eq_iff_eq_inv, \u2190 map_inv\u2080] at hh\n        exact hh.not_lt (h.1 ((one_lt_val_iff v hx).1 h_2))\n\nalias \u27e8IsEquiv.lt_one_iff_lt_one, _\u27e9 := isEquiv_iff_val_lt_one\n\ntheorem isEquiv_iff_val_sub_one_lt_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v (x - 1) < 1 \u2194 v' (x - 1) < 1 := by\n  rw [isEquiv_iff_val_lt_one]\n  exact (Equiv.subRight 1).surjective.forall\n\nalias \u27e8IsEquiv.val_sub_one_lt_one_iff, _\u27e9 := isEquiv_iff_val_sub_one_lt_one\n\ntheorem isEquiv_tfae [LinearOrderedCommGroupWithZero \u0393\u2080] [LinearOrderedCommGroupWithZero \u0393'\u2080]\n    (v : Valuation K \u0393\u2080) (v' : Valuation K \u0393'\u2080) :\n    [ v.IsEquiv v',\n      \u2200 {x y}, v x < v y \u2194 v' x < v' y,\n      \u2200 {x}, v x \u2264 1 \u2194 v' x \u2264 1,\n      \u2200 {x}, v x = 1 \u2194 v' x = 1,\n      \u2200 {x}, v x < 1 \u2194 v' x < 1,\n      \u2200 {x}, v (x - 1) < 1 \u2194 v' (x - 1) < 1 ].TFAE := by\n  tfae_have 1 \u2194 2 := isEquiv_iff_val_lt_val\n  tfae_have 1 \u2194 3 := isEquiv_iff_val_le_one\n  tfae_have 1 \u2194 4 := isEquiv_iff_val_eq_one\n  tfae_have 1 \u2194 5 := isEquiv_iff_val_lt_one\n  tfae_have 1 \u2194 6 := isEquiv_iff_val_sub_one_lt_one\n  tfae_finish\n\nend\n\nsection Supp\n\nvariable [CommRing R] [LinearOrderedCommMonoidWithZero \u0393\u2080] (v : Valuation R \u0393\u2080)\n\n/-- The support of a valuation `v : R \u2192 \u0393\u2080` is the ideal of `R` where `v` vanishes. -/\ndef supp : Ideal R where\n  carrier := { x | v x = 0 }\n  zero_mem' := map_zero v\n  add_mem' {x y} hx hy := le_zero_iff.mp <|\n    calc\n      v (x + y) \u2264 max (v x) (v y) := v.map_add x y\n      _ \u2264 0 := max_le (le_zero_iff.mpr hx) (le_zero_iff.mpr hy)\n  smul_mem' c x hx :=\n    calc\n      v (c * x) = v c * v x := map_mul v c x\n      _ = v c * 0 := congr_arg _ hx\n      _ = 0 := mul_zero _\n\n@[simp]\ntheorem mem_supp_iff (x : R) : x \u2208 supp v \u2194 v x = 0 :=\n  Iff.rfl\n\n/-- The support of a valuation is a prime ideal. -/\ninstance [Nontrivial \u0393\u2080] [NoZeroDivisors \u0393\u2080] : Ideal.IsPrime (supp v) :=\n  \u27e8fun h =>\n    one_ne_zero (\u03b1 := \u0393\u2080) <|\n      calc\n        1 = v 1 := v.map_one.symm\n        _ = 0 := by rw [\u2190 mem_supp_iff, h]; exact Submodule.mem_top,\n   fun {x y} hxy => by\n    simp only [mem_supp_iff] at hxy \u22a2\n    rw [v.map_mul x y] at hxy\n    exact eq_zero_or_eq_zero_of_mul_eq_zero hxy\u27e9\n\ntheorem map_add_supp (a : R) {s : R} (h : s \u2208 supp v) : v (a + s) = v a := by\n  have aux : \u2200 a s, v s = 0 \u2192 v (a + s) \u2264 v a := by\n    intro a' s' h'\n    refine le_trans (v.map_add a' s') (max_le le_rfl ?_)\n    simp [h']\n  apply le_antisymm (aux a s h)\n  calc\n    v a = v (a + s + -s) := by simp\n    _ \u2264 v (a + s) := aux (a + s) (-s) (by rwa [\u2190 Ideal.neg_mem_iff] at h)\n\ntheorem comap_supp {S : Type*} [CommRing S] (f : S \u2192+* R) :\n    supp (v.comap f) = Ideal.comap f v.supp :=\n  Ideal.ext fun x => by rw [mem_supp_iff, Ideal.mem_comap, mem_supp_iff, comap_apply]\n\nend Supp\n\n-- end of section\nend Valuation\n\nsection AddMonoid\n\nvariable (R) [Ring R] (\u0393\u2080 : Type*) [LinearOrderedAddCommMonoidWithTop \u0393\u2080]\n\n/-- The type of `\u0393\u2080`-valued additive valuations on `R`. -/\ndef AddValuation :=\n  Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48)\n\nend AddMonoid\n\nnamespace AddValuation\n\nvariable {\u0393\u2080 : Type*} {\u0393'\u2080 : Type*}\n\nsection Basic\n\nsection Monoid\n\n/-- A valuation is coerced to the underlying function `R \u2192 \u0393\u2080`. -/\ninstance (R) (\u0393\u2080) [Ring R] [LinearOrderedAddCommMonoidWithTop \u0393\u2080] :\n    FunLike (AddValuation R \u0393\u2080) R \u0393\u2080 where\n  coe v := v.toMonoidWithZeroHom.toFun\n  coe_injective' f g := by cases f; cases g; simp (config := {contextual := true})\n\nvariable [Ring R] [LinearOrderedAddCommMonoidWithTop \u0393\u2080] [LinearOrderedAddCommMonoidWithTop \u0393'\u2080]\n  (v : AddValuation R \u0393\u2080)\n\nsection\n\nvariable (f : R \u2192 \u0393\u2080) (h0 : f 0 = \u22a4) (h1 : f 1 = 0)\nvariable (hadd : \u2200 x y, min (f x) (f y) \u2264 f (x + y)) (hmul : \u2200 x y, f (x * y) = f x + f y)\n\n/-- An alternate constructor of `AddValuation`, that doesn't reference `Multiplicative \u0393\u2080\u1d52\u1d48` -/\ndef of : AddValuation R \u0393\u2080 where\n  toFun := f\n  map_one' := h1\n  map_zero' := h0\n  map_add_le_max' := hadd\n  map_mul' := hmul\n\nvariable {h0} {h1} {hadd} {hmul} {r : R}\n\n@[simp]\ntheorem of_apply : (of f h0 h1 hadd hmul) r = f r := rfl\n\n/-- The `Valuation` associated to an `AddValuation` (useful if the latter is constructed using\n`AddValuation.of`). -/\ndef toValuation : AddValuation R \u0393\u2080 \u2243 Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48) :=\n  Equiv.refl _\n\n@[deprecated (since := \"2024-11-09\")]\nalias valuation := toValuation\n\n/-- The `AddValuation` associated to a `Valuation`.\n-/\ndef ofValuation : Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48) \u2243 AddValuation R \u0393\u2080 :=\n  Equiv.refl _\n\n@[simp]\nlemma ofValuation_symm_eq : ofValuation.symm = toValuation (R := R) (\u0393\u2080 := \u0393\u2080) := rfl\n\n@[simp]\nlemma toValuation_symm_eq : toValuation.symm = ofValuation (R := R) (\u0393\u2080 := \u0393\u2080) := rfl\n\n@[simp]\nlemma ofValuation_toValuation : ofValuation (toValuation v) = v := rfl\n\n@[simp]\nlemma toValuation_ofValuation (v : Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48)) :\n    toValuation (ofValuation v) = v := rfl\n\n@[simp]\ntheorem toValuation_apply (r : R) :\n    toValuation v r = Multiplicative.ofAdd (OrderDual.toDual (v r)) :=\n  rfl\n\n@[deprecated (since := \"2024-11-09\")]\nalias valuation_apply := toValuation_apply\n\n@[simp]\ntheorem ofValuation_apply (v : Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48)) (r : R) :\n    ofValuation v r = OrderDual.ofDual (Multiplicative.toAdd (v r)) :=\n  rfl\n\nend\n\n-- Porting note: Lean get confused about namespaces and instances below\n@[simp]\ntheorem map_zero : v 0 = (\u22a4 : \u0393\u2080) :=\n  Valuation.map_zero v\n\n@[simp]\ntheorem map_one : v 1 = (0 : \u0393\u2080) :=\n  Valuation.map_one v\n\n/- Porting note: helper wrapper to coerce `v` to the correct function type -/\n/-- A helper function for Lean to inferring types correctly -/\ndef asFun : R \u2192 \u0393\u2080 := v\n\n@[simp]\ntheorem map_mul : \u2200 (x y : R), v (x * y) = v x + v y :=\n  Valuation.map_mul v\n\n-- Porting note: LHS simplified so created map_add' and removed simp tag\ntheorem map_add : \u2200 (x y : R), min (v x) (v y) \u2264 v (x + y) :=\n  Valuation.map_add v\n\n@[simp]\ntheorem map_add' : \u2200 (x y : R), v x \u2264 v (x + y) \u2228 v y \u2264 v (x + y) := by\n  intro x y\n  rw [\u2190 @min_le_iff _ _ (v x) (v y) (v (x+y)), \u2190 ge_iff_le]\n  apply map_add\n\ntheorem map_le_add {x y : R} {g : \u0393\u2080} (hx : g \u2264 v x) (hy : g \u2264 v y) : g \u2264 v (x + y) :=\n  Valuation.map_add_le v hx hy\n\ntheorem map_lt_add {x y : R} {g : \u0393\u2080} (hx : g < v x) (hy : g < v y) : g < v (x + y) :=\n  Valuation.map_add_lt v hx hy\n\ntheorem map_le_sum {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hf : \u2200 i \u2208 s, g \u2264 v (f i)) :\n    g \u2264 v (\u2211 i \u2208 s, f i) :=\n  v.map_sum_le hf\n\ntheorem map_lt_sum {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hg : g \u2260 \u22a4)\n    (hf : \u2200 i \u2208 s, g < v (f i)) : g < v (\u2211 i \u2208 s, f i) :=\n  v.map_sum_lt hg hf\n\ntheorem map_lt_sum' {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hg : g < \u22a4)\n    (hf : \u2200 i \u2208 s, g < v (f i)) : g < v (\u2211 i \u2208 s, f i) :=\n  v.map_sum_lt' hg hf\n\n@[simp]\ntheorem map_pow : \u2200 (x : R) (n : \u2115), v (x ^ n) = n \u2022 (v x) :=\n  Valuation.map_pow v\n\n@[ext]\ntheorem ext {v\u2081 v\u2082 : AddValuation R \u0393\u2080} (h : \u2200 r, v\u2081 r = v\u2082 r) : v\u2081 = v\u2082 :=\n  Valuation.ext h\n\n-- The following definition is not an instance, because we have more than one `v` on a given `R`.\n-- In addition, type class inference would not be able to infer `v`.\n/-- A valuation gives a preorder on the underlying ring. -/\ndef toPreorder : Preorder R :=\n  Preorder.lift v\n\n/-- If `v` is an additive valuation on a division ring then `v(x) = \u22a4` iff `x = 0`. -/\n@[simp]\ntheorem top_iff [Nontrivial \u0393\u2080] (v : AddValuation K \u0393\u2080) {x : K} : v x = (\u22a4 : \u0393\u2080) \u2194 x = 0 :=\n  v.zero_iff\n\ntheorem ne_top_iff [Nontrivial \u0393\u2080] (v : AddValuation K \u0393\u2080) {x : K} : v x \u2260 (\u22a4 : \u0393\u2080) \u2194 x \u2260 0 :=\n  v.ne_zero_iff\n\n/-- A ring homomorphism `S \u2192 R` induces a map `AddValuation R \u0393\u2080 \u2192 AddValuation S \u0393\u2080`. -/\ndef comap {S : Type*} [Ring S] (f : S \u2192+* R) (v : AddValuation R \u0393\u2080) : AddValuation S \u0393\u2080 :=\n  Valuation.comap f v\n\n@[simp]\ntheorem comap_id : v.comap (RingHom.id R) = v :=\n  Valuation.comap_id v\n\ntheorem comap_comp {S\u2081 : Type*} {S\u2082 : Type*} [Ring S\u2081] [Ring S\u2082] (f : S\u2081 \u2192+* S\u2082) (g : S\u2082 \u2192+* R) :\n    v.comap (g.comp f) = (v.comap g).comap f :=\n  Valuation.comap_comp v f g\n\n/-- A `\u2264`-preserving, `\u22a4`-preserving group homomorphism `\u0393\u2080 \u2192 \u0393'\u2080` induces a map\n  `AddValuation R \u0393\u2080 \u2192 AddValuation R \u0393'\u2080`.\n-/\ndef map (f : \u0393\u2080 \u2192+ \u0393'\u2080) (ht : f \u22a4 = \u22a4) (hf : Monotone f) (v : AddValuation R \u0393\u2080) :\n    AddValuation R \u0393'\u2080 :=\n  @Valuation.map R (Multiplicative \u0393\u2080\u1d52\u1d48) (Multiplicative \u0393'\u2080\u1d52\u1d48) _ _ _\n    { toFun := f\n      map_mul' := f.map_add\n      map_one' := f.map_zero\n      map_zero' := ht } (fun _ _ h => hf h) v\n\n@[simp]\nlemma map_apply (f : \u0393\u2080 \u2192+ \u0393'\u2080) (ht : f \u22a4 = \u22a4) (hf : Monotone f) (v : AddValuation R \u0393\u2080) (r : R) :\n    v.map f ht hf r = f (v r) := rfl\n\n/-- Two additive valuations on `R` are defined to be equivalent if they induce the same\n  preorder on `R`. -/\ndef IsEquiv (v\u2081 : AddValuation R \u0393\u2080) (v\u2082 : AddValuation R \u0393'\u2080) : Prop :=\n  Valuation.IsEquiv v\u2081 v\u2082\n\n@[simp]\ntheorem map_neg (x : R) : v (-x) = v x :=\n  Valuation.map_neg v x\n\ntheorem map_sub_swap (x y : R) : v (x - y) = v (y - x) :=\n  Valuation.map_sub_swap v x y\n\ntheorem map_sub (x y : R) : min (v x) (v y) \u2264 v (x - y) :=\n  Valuation.map_sub v x y\n\ntheorem map_le_sub {x y : R} {g : \u0393\u2080} (hx : g \u2264 v x) (hy : g \u2264 v y) : g \u2264 v (x - y) :=\n  Valuation.map_sub_le v hx hy\n\nvariable {x y : R}\n\ntheorem map_add_of_distinct_val (h : v x \u2260 v y) : v (x + y) = @Min.min \u0393\u2080 _ (v x) (v y) :=\n  Valuation.map_add_of_distinct_val v h\n\ntheorem map_add_eq_of_lt_left {x y : R} (h : v x < v y) :\n    v (x + y) = v x := by\n  rw [map_add_of_distinct_val _ h.ne, min_eq_left h.le]\n\ntheorem map_add_eq_of_lt_right {x y : R} (hx : v y < v x) :\n    v (x + y) = v y := add_comm y x \u25b8 map_add_eq_of_lt_left v hx\n\ntheorem map_sub_eq_of_lt_left {x y : R} (hx : v x < v y) :\n    v (x - y) = v x := by\n  rw [sub_eq_add_neg]\n  apply map_add_eq_of_lt_left\n  rwa [map_neg]\n\ntheorem map_sub_eq_of_lt_right {x y : R} (hx : v y < v x) :\n    v (x - y) = v y := map_sub_swap v x y \u25b8 map_sub_eq_of_lt_left v hx\n\ntheorem map_eq_of_lt_sub (h : v x < v (y - x)) : v y = v x :=\n  Valuation.map_eq_of_sub_lt v h\n\nend Monoid\n\nsection Group\n\nvariable [LinearOrderedAddCommGroupWithTop \u0393\u2080] [Ring R] (v : AddValuation R \u0393\u2080) {x y : R}\n\n@[simp]\ntheorem map_inv (v : AddValuation K \u0393\u2080) {x : K} : v x\u207b\u00b9 = - (v x) :=\n  map_inv\u2080 (toValuation v) x\n\n@[simp]\ntheorem map_div (v : AddValuation K \u0393\u2080) {x y : K} : v (x / y) = v x - v y :=\n  map_div\u2080 (toValuation v) x y\n\nend Group\n\nend Basic\n\nnamespace IsEquiv\n\nvariable [LinearOrderedAddCommMonoidWithTop \u0393\u2080] [LinearOrderedAddCommMonoidWithTop \u0393'\u2080]\n  [Ring R]\n  {\u0393''\u2080 : Type*} [LinearOrderedAddCommMonoidWithTop \u0393''\u2080]\n  {v : AddValuation R \u0393\u2080}\n   {v\u2081 : AddValuation R \u0393\u2080} {v\u2082 : AddValuation R \u0393'\u2080} {v\u2083 : AddValuation R \u0393''\u2080}\n\n@[refl]\ntheorem refl : v.IsEquiv v :=\n  Valuation.IsEquiv.refl\n\n@[symm]\ntheorem symm (h : v\u2081.IsEquiv v\u2082) : v\u2082.IsEquiv v\u2081 :=\n  Valuation.IsEquiv.symm h\n\n@[trans]\ntheorem trans (h\u2081\u2082 : v\u2081.IsEquiv v\u2082) (h\u2082\u2083 : v\u2082.IsEquiv v\u2083) : v\u2081.IsEquiv v\u2083 :=\n  Valuation.IsEquiv.trans h\u2081\u2082 h\u2082\u2083\n\ntheorem of_eq {v' : AddValuation R \u0393\u2080} (h : v = v') : v.IsEquiv v' :=\n  Valuation.IsEquiv.of_eq h\n\ntheorem map {v' : AddValuation R \u0393\u2080} (f : \u0393\u2080 \u2192+ \u0393'\u2080) (ht : f \u22a4 = \u22a4) (hf : Monotone f)\n    (inf : Injective f) (h : v.IsEquiv v') : (v.map f ht hf).IsEquiv (v'.map f ht hf) :=\n  @Valuation.IsEquiv.map R (Multiplicative \u0393\u2080\u1d52\u1d48) (Multiplicative \u0393'\u2080\u1d52\u1d48) _ _ _ _ _\n    { toFun := f\n      map_mul' := f.map_add\n      map_one' := f.map_zero\n      map_zero' := ht } (fun _x _y h => hf h) inf h\n\n/-- `comap` preserves equivalence. -/\ntheorem comap {S : Type*} [Ring S] (f : S \u2192+* R) (h : v\u2081.IsEquiv v\u2082) :\n    (v\u2081.comap f).IsEquiv (v\u2082.comap f) :=\n  Valuation.IsEquiv.comap f h\n\ntheorem val_eq (h : v\u2081.IsEquiv v\u2082) {r s : R} : v\u2081 r = v\u2081 s \u2194 v\u2082 r = v\u2082 s :=\n  Valuation.IsEquiv.val_eq h\n\ntheorem ne_top (h : v\u2081.IsEquiv v\u2082) {r : R} : v\u2081 r \u2260 (\u22a4 : \u0393\u2080) \u2194 v\u2082 r \u2260 (\u22a4 : \u0393'\u2080) :=\n  Valuation.IsEquiv.ne_zero h\n\nend IsEquiv\n\nsection Supp\n\nvariable [LinearOrderedAddCommMonoidWithTop \u0393\u2080] [CommRing R] (v : AddValuation R \u0393\u2080)\n\n/-- The support of an additive valuation `v : R \u2192 \u0393\u2080` is the ideal of `R` where `v x = \u22a4` -/\ndef supp : Ideal R :=\n  Valuation.supp v\n\n@[simp]\ntheorem mem_supp_iff (x : R) : x \u2208 supp v \u2194 v x = (\u22a4 : \u0393\u2080) :=\n  Valuation.mem_supp_iff v x\n\ntheorem map_add_supp (a : R) {s : R} (h : s \u2208 supp v) : v (a + s) = v a :=\n  Valuation.map_add_supp v a h\n\nend Supp\n\n-- end of section\nend AddValuation\n\nnamespace Valuation\n\nvariable {K \u0393\u2080 : Type*} [Ring R] [LinearOrderedCommMonoidWithZero \u0393\u2080]\n\n/-- The `AddValuation` associated to a `Valuation`. -/\ndef toAddValuation : Valuation R \u0393\u2080 \u2243 AddValuation R (Additive \u0393\u2080)\u1d52\u1d48 :=\n  .trans (congr\n    { toFun := fun x \u21a6 .ofAdd <| .toDual <| .toDual <| .ofMul x\n      invFun := fun x \u21a6 x.toAdd.ofDual.ofDual.toMul\n      left_inv := fun _x \u21a6 rfl\n      right_inv := fun _x \u21a6 rfl\n      map_mul' := fun _x _y \u21a6 rfl\n      map_le_map_iff' := .rfl }) (AddValuation.ofValuation (R := R) (\u0393\u2080 := (Additive \u0393\u2080)\u1d52\u1d48))\n\n/-- The `Valuation` associated to a `AddValuation`.\n-/\ndef ofAddValuation : AddValuation R (Additive \u0393\u2080)\u1d52\u1d48 \u2243 Valuation R \u0393\u2080 :=\n  AddValuation.toValuation.trans <| congr <|\n    { toFun := fun x \u21a6 x.toAdd.ofDual.ofDual.toMul\n      invFun := fun x \u21a6 .ofAdd <| .toDual <| .toDual <| .ofMul x\n      left_inv := fun _x \u21a6 rfl\n      right_inv := fun _x \u21a6 rfl\n      map_mul' := fun _x _y \u21a6 rfl\n      map_le_map_iff' := .rfl }\n\n@[simp]\nlemma ofAddValuation_symm_eq : ofAddValuation.symm = toAddValuation (R := R) (\u0393\u2080 := \u0393\u2080) := rfl\n\n@[simp]\nlemma toAddValuation_symm_eq : toAddValuation.symm = ofAddValuation (R := R) (\u0393\u2080 := \u0393\u2080) := rfl\n\n@[simp]\nlemma ofAddValuation_toAddValuation (v : Valuation R \u0393\u2080) :\n  ofAddValuation (toAddValuation v) = v := rfl\n\n@[simp]\nlemma toValuation_ofValuation (v : AddValuation R (Additive \u0393\u2080)\u1d52\u1d48) :\n    toAddValuation (ofAddValuation v) = v := rfl\n\n@[simp]\ntheorem toAddValuation_apply (v : Valuation R \u0393\u2080) (r : R) :\n    toAddValuation v r = OrderDual.toDual (Additive.ofMul (v r)) :=\n  rfl\n\n@[simp]\ntheorem ofAddValuation_apply (v : AddValuation R (Additive \u0393\u2080)\u1d52\u1d48) (r : R) :\n    ofAddValuation v r = Additive.toMul (OrderDual.ofDual (v r)) :=\n  rfl\n\ninstance (v : Valuation R \u0393\u2080) : CommMonoidWithZero (MonoidHom.mrange v) where\n  zero := \u27e80, 0, by simp\u27e9\n  zero_mul := by\n    intro a\n    exact Subtype.ext (zero_mul a.val)\n  mul_zero := by\n    intro a\n    exact Subtype.ext (mul_zero a.val)\n\n", "theoremStatement": "@[simp]\nlemma val_mrange_zero (v : Valuation R \u0393\u2080) : ((0 : MonoidHom.mrange v) : \u0393\u2080) = 0 ", "theoremName": "Valuation.val_mrange_zero", "fileCreated": {"commit": "a9138cdba12f2110c86195f5eac26cb36dee2627", "date": "2023-03-17"}, "theoremCreated": {"commit": "4a30ca3ef1757348aacd416b9a7b02c455de6afd", "date": "2025-01-14"}, "file": "mathlib/Mathlib/RingTheory/Valuation/Basic.lean", "module": "Mathlib.RingTheory.Valuation.Basic", "jsonFile": "Mathlib.RingTheory.Valuation.Basic.jsonl", "positionMetadata": {"lineInFile": 964, "tokenPositionInFile": 32687, "theoremPositionInFile": 134}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 5, "repositoryPremises": true, "numRepositoryPremises": 21, "numPremises": 28}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "/-\nCopyright (c) 2024 Jo\u00ebl Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jo\u00ebl Riou\n-/\nimport Mathlib.Algebra.Homology.Embedding.Extend\nimport Mathlib.Algebra.Homology.Embedding.IsSupported\nimport Mathlib.Algebra.Homology.QuasiIso\n\n/-!\n# Homology of the extension of an homological complex\n\nGiven an embedding `e : c.Embedding c'` and `K : HomologicalComplex C c`, we shall\ncompute the homology of `K.extend e`. In degrees that are not in the image of `e.f`,\nthe homology is obviously zero. When `e.f j = j`, we construct an isomorphism\n`(K.extend e).homology j' \u2245 K.homology j`.\n\n-/\n\nopen CategoryTheory Limits Category\n\nnamespace HomologicalComplex\n\nvariable {\u03b9 \u03b9' : Type*} {c : ComplexShape \u03b9} {c' : ComplexShape \u03b9'}\n  {C : Type*} [Category C] [HasZeroMorphisms C]\n  [HasZeroObject C]\n\nvariable (K L M : HomologicalComplex C c) (\u03c6 : K \u27f6 L) (\u03c6' : L \u27f6 M) (e : c.Embedding c')\n\nnamespace extend\n\nsection HomologyData\n\nvariable {i j k : \u03b9} {i' j' k' : \u03b9'} (hj' : e.f j = j')\n  (hi : c.prev j = i) (hi' : c'.prev j' = i') (hk : c.next j = k) (hk' : c'.next j' = k')\n\ninclude hk hk' in\nlemma comp_d_eq_zero_iff \u2983W : C\u2984 (\u03c6 : W \u27f6 K.X j) :\n    \u03c6 \u226b K.d j k = 0 \u2194 \u03c6 \u226b (K.extendXIso e hj').inv \u226b (K.extend e).d j' k' = 0 := by\n  by_cases hjk : c.Rel j k\n  \u00b7 have hk' : e.f k = k' := by rw [\u2190 hk', \u2190 hj', c'.next_eq' (e.rel hjk)]\n    rw [K.extend_d_eq e hj' hk', Iso.inv_hom_id_assoc,\n      \u2190 cancel_mono (K.extendXIso e hk').inv, zero_comp, assoc]\n  \u00b7 simp only [K.shape _ _ hjk, comp_zero, true_iff]\n    rw [K.extend_d_from_eq_zero e j' k' j hj', comp_zero, comp_zero]\n    rw [hk]\n    exact hjk\n\ninclude hi hi' in\nlemma d_comp_eq_zero_iff \u2983W : C\u2984 (\u03c6 : K.X j \u27f6 W) :\n    K.d i j \u226b \u03c6 = 0 \u2194 (K.extend e).d i' j' \u226b (K.extendXIso e hj').hom \u226b \u03c6 = 0 := by\n  by_cases hij : c.Rel i j\n  \u00b7 have hi' : e.f i = i' := by rw [\u2190 hi', \u2190 hj', c'.prev_eq' (e.rel hij)]\n    rw [K.extend_d_eq e hi' hj', assoc, assoc, Iso.inv_hom_id_assoc,\n      \u2190 cancel_epi (K.extendXIso e hi').hom, comp_zero]\n  \u00b7 simp only [K.shape _ _ hij, zero_comp, true_iff]\n    rw [K.extend_d_to_eq_zero e i' j' j hj', zero_comp]\n    rw [hi]\n    exact hij\n\nnamespace leftHomologyData\n\nvariable (cone : KernelFork (K.d j k)) (hcone : IsLimit cone)\n\n/-- The kernel fork of `(K.extend e).d j' k'` that is deduced from a kernel\nfork of `K.d j k `. -/\n@[simp]\nnoncomputable def kernelFork : KernelFork ((K.extend e).d j' k') :=\n  KernelFork.of\u03b9 (cone.\u03b9 \u226b (extendXIso K e hj').inv)\n    (by rw [assoc, \u2190 comp_d_eq_zero_iff K e hj' hk hk' cone.\u03b9, cone.condition])\n\n/-- The limit kernel fork of `(K.extend e).d j' k'` that is deduced from a limit\nkernel fork of `K.d j k `. -/\nnoncomputable def isLimitKernelFork : IsLimit (kernelFork K e hj' hk hk' cone) :=\n  KernelFork.isLimitOfIsLimitOfIff hcone ((K.extend e).d j' k')\n    (extendXIso K e hj').symm (comp_d_eq_zero_iff K e hj' hk hk')\n\nvariable (cocone : CokernelCofork (hcone.lift (KernelFork.of\u03b9 (K.d i j) (K.d_comp_d i j k))))\n  (hcocone : IsColimit cocone)\n\ninclude hi hi' hcone in\n/-- Auxiliary lemma for `lift_d_comp_eq_zero_iff`. -/\nlemma lift_d_comp_eq_zero_iff' \u2983W : C\u2984 (f' : K.X i \u27f6 cone.pt)\n    (hf' : f' \u226b cone.\u03b9 = K.d i j)\n    (f'' : (K.extend e).X i' \u27f6 cone.pt)\n    (hf'' : f'' \u226b cone.\u03b9 \u226b (extendXIso K e hj').inv = (K.extend e).d i' j')\n    (\u03c6 : cone.pt \u27f6 W) :\n    f' \u226b \u03c6 = 0 \u2194 f'' \u226b \u03c6 = 0 := by\n  by_cases hij : c.Rel i j\n  \u00b7 have hi'' : e.f i = i' := by rw [\u2190 hi', \u2190 hj', c'.prev_eq' (e.rel hij)]\n    have : (K.extendXIso e hi'').hom \u226b f' = f'' := by\n      apply Fork.IsLimit.hom_ext hcone\n      rw [assoc, hf', \u2190 cancel_mono (extendXIso K e hj').inv, assoc, assoc, hf'',\n        K.extend_d_eq e hi'' hj']\n    rw [\u2190 cancel_epi (K.extendXIso e hi'').hom, comp_zero, \u2190 this, assoc]\n  \u00b7 have h\u2081 : f' = 0 := by\n      apply Fork.IsLimit.hom_ext hcone\n      simp only [zero_comp, hf', K.shape _ _ hij]\n    have h\u2082 : f'' = 0 := by\n      apply Fork.IsLimit.hom_ext hcone\n      dsimp\n      rw [\u2190 cancel_mono (extendXIso K e hj').inv, assoc, hf'', zero_comp, zero_comp,\n        K.extend_d_to_eq_zero e i' j' j hj']\n      rw [hi]\n      exact hij\n    simp [h\u2081, h\u2082]\n\ninclude hi hi' in\nlemma lift_d_comp_eq_zero_iff \u2983W : C\u2984 (\u03c6 : cone.pt \u27f6 W) :\n    hcone.lift (KernelFork.of\u03b9 (K.d i j) (K.d_comp_d i j k)) \u226b \u03c6 = 0 \u2194\n      ((isLimitKernelFork K e hj' hk hk' cone hcone).lift\n      (KernelFork.of\u03b9 ((K.extend e).d i' j') (d_comp_d _ _ _ _))) \u226b \u03c6 = 0 :=\n  lift_d_comp_eq_zero_iff' K e hj' hi hi' cone hcone _ (hcone.fac _ _) _\n    (IsLimit.fac _ _ WalkingParallelPair.zero) _\n\n/-- Auxiliary definition for `extend.leftHomologyData`. -/\nnoncomputable def cokernelCofork :\n    CokernelCofork ((isLimitKernelFork K e hj' hk hk' cone hcone).lift\n      (KernelFork.of\u03b9 ((K.extend e).d i' j') (d_comp_d _ _ _ _))) :=\n  CokernelCofork.of\u03c0 cocone.\u03c0 (by\n    rw [\u2190 lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' cone hcone]\n    exact cocone.condition)\n\n/-- Auxiliary definition for `extend.leftHomologyData`. -/\nnoncomputable def isColimitCokernelCofork :\n    IsColimit (cokernelCofork K e hj' hi hi' hk hk' cone hcone cocone) :=\n  CokernelCofork.isColimitOfIsColimitOfIff' hcocone _\n    (lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' cone hcone)\n\nend leftHomologyData\n\nopen leftHomologyData in\n/-- The left homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a left homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def leftHomologyData (h : (K.sc' i j k).LeftHomologyData) :\n    ((K.extend e).sc' i' j' k').LeftHomologyData where\n  K := h.K\n  H := h.H\n  i := h.i \u226b (extendXIso K e hj').inv\n  \u03c0 := h.\u03c0\n  wi := by\n    dsimp\n    rw [assoc, \u2190 comp_d_eq_zero_iff K e hj' hk hk']\n    exact h.wi\n  hi := isLimitKernelFork K e hj' hk hk' _ h.hi\n  w\u03c0 := by\n    dsimp\n    rw [\u2190 lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' _ h.hi]\n    exact h.w\u03c0\n  h\u03c0 := isColimitCokernelCofork K e hj' hi hi' hk hk' _ h.hi _ h.h\u03c0\n\nnamespace rightHomologyData\n\nvariable (cocone : CokernelCofork (K.d i j)) (hcocone : IsColimit cocone)\n\n/-- The cokernel cofork of `(K.extend e).d i' j'` that is deduced from a cokernel\ncofork of `K.d i j`. -/\n@[simp]\nnoncomputable def cokernelCofork : CokernelCofork ((K.extend e).d i' j') :=\n  CokernelCofork.of\u03c0 ((extendXIso K e hj').hom \u226b cocone.\u03c0) (by\n    rw [\u2190 d_comp_eq_zero_iff K e hj' hi hi' cocone.\u03c0, cocone.condition])\n\n/-- The colimit cokernel cofork of `(K.extend e).d i' j'` that is deduced from a\ncolimit cokernel cofork of `K.d i j`. -/\nnoncomputable def isColimitCokernelCofork : IsColimit (cokernelCofork K e hj' hi hi' cocone) :=\n  CokernelCofork.isColimitOfIsColimitOfIff hcocone ((K.extend e).d i' j')\n    (extendXIso K e hj') (d_comp_eq_zero_iff K e hj' hi hi')\n\nvariable (cone : KernelFork (hcocone.desc (CokernelCofork.of\u03c0 (K.d j k) (K.d_comp_d i j k))))\n  (hcone : IsLimit cone)\n\ninclude hk hk' hcocone in\nlemma d_comp_desc_eq_zero_iff' \u2983W : C\u2984 (f' : cocone.pt \u27f6 K.X k)\n    (hf' : cocone.\u03c0 \u226b f' = K.d j k)\n    (f'' : cocone.pt \u27f6 (K.extend e).X k')\n    (hf'' : (extendXIso K e hj').hom \u226b cocone.\u03c0 \u226b f'' = (K.extend e).d j' k')\n    (\u03c6 : W \u27f6 cocone.pt) :\n    \u03c6 \u226b f' = 0 \u2194 \u03c6 \u226b f'' = 0 := by\n  by_cases hjk : c.Rel j k\n  \u00b7 have hk'' : e.f k = k' := by rw [\u2190 hk', \u2190 hj', c'.next_eq' (e.rel hjk)]\n    have : f' \u226b (K.extendXIso e hk'').inv = f'' := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      rw [reassoc_of% hf', \u2190 cancel_epi (extendXIso K e hj').hom, hf'',\n        K.extend_d_eq e hj' hk'']\n    rw [\u2190 cancel_mono (K.extendXIso e hk'').inv, zero_comp, assoc, this]\n  \u00b7 have h\u2081 : f' = 0 := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      simp only [hf', comp_zero, K.shape _ _ hjk]\n    have h\u2082 : f'' = 0 := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      rw [\u2190 cancel_epi (extendXIso K e hj').hom, hf'', comp_zero, comp_zero,\n        K.extend_d_from_eq_zero e j' k' j hj']\n      rw [hk]\n      exact hjk\n    simp [h\u2081, h\u2082]\n\ninclude hk hk' in\nlemma d_comp_desc_eq_zero_iff \u2983W : C\u2984 (\u03c6 : W \u27f6 cocone.pt) :\n    \u03c6 \u226b hcocone.desc (CokernelCofork.of\u03c0 (K.d j k) (K.d_comp_d i j k)) = 0 \u2194\n      \u03c6 \u226b ((isColimitCokernelCofork K e hj' hi hi' cocone hcocone).desc\n      (CokernelCofork.of\u03c0 ((K.extend e).d j' k') (d_comp_d _ _ _ _))) = 0 :=\n  d_comp_desc_eq_zero_iff' K e hj' hk hk' cocone hcocone _ (hcocone.fac _ _) _ (by\n    simpa using (isColimitCokernelCofork K e hj' hi hi' cocone hcocone).fac _\n      WalkingParallelPair.one) _\n\n/-- Auxiliary definition for `extend.rightHomologyData`. -/\nnoncomputable def kernelFork :\n    KernelFork ((isColimitCokernelCofork K e hj' hi hi' cocone hcocone).desc\n      (CokernelCofork.of\u03c0 ((K.extend e).d j' k') (d_comp_d _ _ _ _))) :=\n  KernelFork.of\u03b9 cone.\u03b9 (by\n    rw [\u2190 d_comp_desc_eq_zero_iff K e hj' hi hi' hk hk' cocone hcocone]\n    exact cone.condition)\n\n/-- Auxiliary definition for `extend.rightHomologyData`. -/\nnoncomputable def isLimitKernelFork :\n    IsLimit (kernelFork K e hj' hi hi' hk hk' cocone hcocone cone) :=\n  KernelFork.isLimitOfIsLimitOfIff' hcone _\n    (d_comp_desc_eq_zero_iff K e hj' hi hi' hk hk' cocone hcocone)\n\nend rightHomologyData\n\nopen rightHomologyData in\n/-- The right homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a right homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def rightHomologyData (h : (K.sc' i j k).RightHomologyData) :\n    ((K.extend e).sc' i' j' k').RightHomologyData where\n  Q := h.Q\n  H := h.H\n  p := (extendXIso K e hj').hom \u226b h.p\n  \u03b9 := h.\u03b9\n  wp := by\n    dsimp\n    rw [\u2190 d_comp_eq_zero_iff K e hj' hi hi']\n    exact h.wp\n  hp := isColimitCokernelCofork K e hj' hi hi' _ h.hp\n  w\u03b9 := by\n    dsimp\n    rw [\u2190 d_comp_desc_eq_zero_iff K e hj' hi hi' hk hk' _ h.hp]\n    exact h.w\u03b9\n  h\u03b9 := isLimitKernelFork K e hj' hi hi' hk hk' _ h.hp _ h.h\u03b9\n\n/-- Computation of the `g'` field of `extend.rightHomologyData`. -/\nlemma rightHomologyData_g' (h : (K.sc' i j k).RightHomologyData) (hk'' : e.f k = k') :\n    (rightHomologyData K e hj' hi hi' hk hk' h).g' = h.g' \u226b (K.extendXIso e hk'').inv := by\n  rw [\u2190 cancel_epi h.p, \u2190 cancel_epi (extendXIso K e hj').hom]\n  have := (rightHomologyData K e hj' hi hi' hk hk' h).p_g'\n  dsimp at this\n  rw [assoc] at this\n  rw [this, K.extend_d_eq e hj' hk'', h.p_g'_assoc, shortComplexFunctor'_obj_g]\n\n/-- The homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def homologyData (h : (K.sc' i j k).HomologyData) :\n    ((K.extend e).sc' i' j' k').HomologyData where\n  left := leftHomologyData K e hj' hi hi' hk hk' h.left\n  right := rightHomologyData K e hj' hi hi' hk hk' h.right\n  iso := h.iso\n\n/-- The homology data of `(K.extend e).sc j'` that is deduced\nfrom a homology data of `K.sc' i j k`. -/\n@[simps!]\nnoncomputable def homologyData' (h : (K.sc' i j k).HomologyData) :\n    ((K.extend e).sc j').HomologyData :=\n  homologyData K e hj' hi rfl hk rfl h\n\nend HomologyData\n\nlemma hasHomology {j : \u03b9} {j' : \u03b9'} (hj' : e.f j = j') [K.HasHomology j] :\n    (K.extend e).HasHomology j' :=\n  ShortComplex.HasHomology.mk'\n    (homologyData' K e hj' rfl rfl ((K.sc j).homologyData))\n\ninstance (j : \u03b9) [K.HasHomology j] : (K.extend e).HasHomology (e.f j) :=\n  hasHomology K e rfl\n\ninstance [\u2200 j, K.HasHomology j] (j' : \u03b9') : (K.extend e).HasHomology j' := by\n  by_cases h : \u2203 j, e.f j = j'\n  \u00b7 obtain \u27e8j, rfl\u27e9 := h\n    infer_instance\n  \u00b7 have hj := isZero_extend_X K e j' (by tauto)\n    exact ShortComplex.HasHomology.mk'\n      (ShortComplex.HomologyData.ofZeros _ (hj.eq_of_tgt _ _) (hj.eq_of_src _ _))\n\nend extend\n\nlemma extend_exactAt (j' : \u03b9') (hj' : \u2200 j, e.f j \u2260 j') :\n    (K.extend e).ExactAt j' :=\n  exactAt_of_isSupported _ e j' hj'\n\nsection\n\nvariable {j : \u03b9} {j' : \u03b9'} (hj' : e.f j = j') [K.HasHomology j] [L.HasHomology j]\n  [(K.extend e).HasHomology j'] [(L.extend e).HasHomology j']\n\n/-- The isomorphism `(K.extend e).cycles j' \u2245 K.cycles j` when `e.f j = j'`. -/\nnoncomputable def extendCyclesIso :\n    (K.extend e).cycles j' \u2245 K.cycles j :=\n  (extend.homologyData' K e hj' rfl rfl (K.sc j).homologyData).left.cyclesIso \u226a\u226b\n    (K.sc j).homologyData.left.cyclesIso.symm\n\n/-- The isomorphism `(K.extend e).opcycles j' \u2245 K.opcycles j` when `e.f j = j'`. -/\nnoncomputable def extendOpcyclesIso :\n    (K.extend e).opcycles j' \u2245 K.opcycles j :=\n  (extend.homologyData' K e hj' rfl rfl (K.sc j).homologyData).right.opcyclesIso \u226a\u226b\n    (K.sc j).homologyData.right.opcyclesIso.symm\n\n/-- The isomorphism `(K.extend e).homology j' \u2245 K.homology j` when `e.f j = j'`. -/\nnoncomputable def extendHomologyIso :\n    (K.extend e).homology j' \u2245 K.homology j :=\n  (extend.homologyData' K e hj' rfl rfl (K.sc j).homologyData).left.homologyIso \u226a\u226b\n    (K.sc j).homologyData.left.homologyIso.symm\n\ninclude hj' in\nlemma extend_exactAt_iff :\n    (K.extend e).ExactAt j' \u2194 K.ExactAt j := by\n  simp only [HomologicalComplex.exactAt_iff_isZero_homology]\n  exact (K.extendHomologyIso e hj').isZero_iff\n\n@[reassoc (attr := simp)]\nlemma extendCyclesIso_hom_iCycles :\n    (K.extendCyclesIso e hj').hom \u226b K.iCycles j =\n      (K.extend e).iCycles j' \u226b (K.extendXIso e hj').hom := by\n  rw [\u2190 cancel_epi (K.extendCyclesIso e hj').inv, Iso.inv_hom_id_assoc]\n  dsimp [extendCyclesIso, iCycles]\n  rw [assoc, ShortComplex.LeftHomologyData.cyclesIso_inv_comp_iCycles_assoc]\n  dsimp\n  rw [assoc, Iso.inv_hom_id, comp_id,\n    ShortComplex.LeftHomologyData.cyclesIso_hom_comp_i]\n\n@[reassoc (attr := simp)]\nlemma extendCyclesIso_inv_iCycles :\n    (K.extendCyclesIso e hj').inv \u226b (K.extend e).iCycles j' =\n      K.iCycles j \u226b (K.extendXIso e hj').inv := by\n  simp only [\u2190 cancel_epi (K.extendCyclesIso e hj').hom, Iso.hom_inv_id_assoc,\n    extendCyclesIso_hom_iCycles_assoc, Iso.hom_inv_id, comp_id]\n\n@[reassoc (attr := simp)]\nlemma homology\u03c0_extendHomologyIso_hom :\n    (K.extend e).homology\u03c0 j' \u226b (K.extendHomologyIso e hj').hom =\n      (K.extendCyclesIso e hj').hom \u226b K.homology\u03c0 j := by\n  dsimp [extendHomologyIso, homology\u03c0]\n  rw [ShortComplex.LeftHomologyData.homology\u03c0_comp_homologyIso_hom_assoc,\n    \u2190 cancel_mono (K.sc j).homologyData.left.homologyIso.hom,\n    assoc, assoc, assoc, Iso.inv_hom_id, comp_id,\n    ShortComplex.LeftHomologyData.homology\u03c0_comp_homologyIso_hom]\n  dsimp [extendCyclesIso]\n  simp only [assoc, Iso.inv_hom_id_assoc]\n\n@[reassoc (attr := simp)]\nlemma homology\u03c0_extendHomologyIso_inv :\n    K.homology\u03c0 j \u226b (K.extendHomologyIso e hj').inv =\n      (K.extendCyclesIso e hj').inv \u226b (K.extend e).homology\u03c0 j' := by\n  simp only [\u2190 cancel_mono (K.extendHomologyIso e hj').hom,\n    assoc, Iso.inv_hom_id, comp_id, homology\u03c0_extendHomologyIso_hom, Iso.inv_hom_id_assoc]\n\n@[reassoc (attr := simp)]\nlemma pOpcycles_extendOpcyclesIso_inv :\n    K.pOpcycles j \u226b (K.extendOpcyclesIso e hj').inv =\n      (K.extendXIso e hj').inv \u226b (K.extend e).pOpcycles j' := by\n  rw [\u2190 cancel_mono (K.extendOpcyclesIso e hj').hom, assoc, assoc, Iso.inv_hom_id, comp_id]\n  dsimp [extendOpcyclesIso, pOpcycles]\n  rw [ShortComplex.RightHomologyData.pOpcycles_comp_opcyclesIso_hom_assoc]\n  dsimp\n  rw [assoc, Iso.inv_hom_id_assoc, ShortComplex.RightHomologyData.p_comp_opcyclesIso_inv]\n  rfl\n\n", "theoremStatement": "@[reassoc (attr := simp)]\nlemma pOpcycles_extendOpcyclesIso_hom :\n    (K.extend e).pOpcycles j' \u226b (K.extendOpcyclesIso e hj').hom =\n      (K.extendXIso e hj').hom \u226b K.pOpcycles j ", "theoremName": "HomologicalComplex.pOpcycles_extendOpcyclesIso_hom", "fileCreated": {"commit": "9bdc1af76cf75d960f42c29f1c09917785066c8b", "date": "2024-11-30"}, "theoremCreated": {"commit": "b07a551a1451cbf8615f4e2a6c47052affadbae4", "date": "2025-01-17"}, "file": "mathlib/Mathlib/Algebra/Homology/Embedding/ExtendHomology.lean", "module": "Mathlib.Algebra.Homology.Embedding.ExtendHomology", "jsonFile": "Mathlib.Algebra.Homology.Embedding.ExtendHomology.jsonl", "positionMetadata": {"lineInFile": 370, "tokenPositionInFile": 14964, "theoremPositionInFile": 27}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 31, "numPremises": 40}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp only [\u2190 cancel_mono (K.extendOpcyclesIso e hj').inv,\n    assoc, Iso.hom_inv_id, comp_id, pOpcycles_extendOpcyclesIso_inv, Iso.hom_inv_id_assoc]", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 156}}
{"srcContext": "/-\nCopyright (c) 2024 Xavier Roblot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Xavier Roblot\n-/\nimport Mathlib.Analysis.BoxIntegral.UnitPartition\nimport Mathlib.MeasureTheory.Measure.Haar.InnerProductSpace\n\n/-!\n# Covolume of \u2124-lattices\n\nLet `E` be a finite dimensional real vector space.\n\nLet `L` be a `\u2124`-lattice `L` defined as a discrete `\u2124`-submodule of `E` that spans `E` over `\u211d`.\n\n## Main definitions and results\n\n* `ZLattice.covolume`: the covolume of `L` defined as the volume of an arbitrary fundamental\ndomain of `L`.\n\n* `ZLattice.covolume_eq_measure_fundamentalDomain`: the covolume of `L` does not depend on the\nchoice of the fundamental domain of `L`.\n\n* `ZLattice.covolume_eq_det`: if `L` is a lattice in `\u211d^n`, then its covolume is the absolute\nvalue of the determinant of any `\u2124`-basis of `L`.\n\n* `ZLattice.covolume.tendsto_card_div_pow`: Let `s` be a bounded measurable set of `\u03b9 \u2192 \u211d`, then\nthe number of points in `s \u2229 n\u207b\u00b9 \u2022 L` divided by `n ^ card \u03b9` tends to `volume s / covolume L`\nwhen `n : \u2115` tends to infinity. See also `ZLattice.covolume.tendsto_card_div_pow'` for a version\nfor `InnerProductSpace \u211d E` and `ZLattice.covolume.tendsto_card_div_pow''` for the general version.\n\n* `ZLattice.covolume.tendsto_card_le_div`: Let `X` be a cone in `\u03b9 \u2192 \u211d` and let `F : (\u03b9 \u2192 \u211d) \u2192 \u211d`\nbe a function such that `F (c \u2022 x) = c ^ card \u03b9 * F x`. Then the number of points `x \u2208 X` such that\n`F x \u2264 c` divided by `c` tends to `volume {x \u2208 X | F x \u2264 1} / covolume L` when `c : \u211d` tends to\ninfinity. See also `ZLattice.covolume.tendsto_card_le_div'` for a version for\n`InnerProductSpace \u211d E` and `ZLattice.covolume.tendsto_card_le_div''` for the general version.\n\n## Naming convention\n\nSome results are true in the case where the ambient finite dimensional real vector space is the\npi-space `\u03b9 \u2192 \u211d` and in the case where it is an `InnerProductSpace`. We use the following\nconvention: the plain name is for the pi case, for eg. `volume_image_eq_volume_div_covolume`. For\nthe same result in the `InnerProductSpace` case, we add a `prime`, for eg.\n`volume_image_eq_volume_div_covolume'`. When the same result exists in the\ngeneral case, we had two primes, eg. `covolume.tendsto_card_div_pow''`.\n\n-/\n\nnoncomputable section\n\nnamespace ZLattice\n\nopen Submodule MeasureTheory Module MeasureTheory Module ZSpan\n\nsection General\n\nvariable {E : Type*} [NormedAddCommGroup E] [MeasurableSpace E] (L : Submodule \u2124 E)\n\n/-- The covolume of a `\u2124`-lattice is the volume of some fundamental domain; see\n`ZLattice.covolume_eq_volume` for the proof that the volume does not depend on the choice of\nthe fundamental domain. -/\ndef covolume (\u03bc : Measure E := by volume_tac) : \u211d := (addCovolume L E \u03bc).toReal\n\nend General\n\nsection Basic\n\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] [FiniteDimensional \u211d E]\nvariable [MeasurableSpace E] [BorelSpace E]\nvariable (L : Submodule \u2124 E) [DiscreteTopology L] [IsZLattice \u211d L]\nvariable (\u03bc : Measure E := by volume_tac) [Measure.IsAddHaarMeasure \u03bc]\n\ntheorem covolume_eq_measure_fundamentalDomain {F : Set E} (h : IsAddFundamentalDomain L F \u03bc) :\n    covolume L \u03bc = (\u03bc F).toReal := by\n  have : MeasurableVAdd L E := (inferInstance : MeasurableVAdd L.toAddSubgroup E)\n  have : VAddInvariantMeasure L E \u03bc := (inferInstance : VAddInvariantMeasure L.toAddSubgroup E \u03bc)\n  exact congr_arg ENNReal.toReal (h.covolume_eq_volume \u03bc)\n\ntheorem covolume_ne_zero : covolume L \u03bc \u2260 0 := by\n  rw [covolume_eq_measure_fundamentalDomain L \u03bc (isAddFundamentalDomain (Free.chooseBasis \u2124 L) \u03bc),\n    ENNReal.toReal_ne_zero]\n  refine \u27e8measure_fundamentalDomain_ne_zero _, ne_of_lt ?_\u27e9\n  exact Bornology.IsBounded.measure_lt_top (fundamentalDomain_isBounded _)\n\ntheorem covolume_pos : 0 < covolume L \u03bc :=\n  lt_of_le_of_ne ENNReal.toReal_nonneg (covolume_ne_zero L \u03bc).symm\n\ntheorem covolume_comap {F : Type*} [NormedAddCommGroup F] [NormedSpace \u211d F] [FiniteDimensional \u211d F]\n    [MeasurableSpace F] [BorelSpace F] (\u03bd : Measure F := by volume_tac) [Measure.IsAddHaarMeasure \u03bd]\n    {e : F \u2243L[\u211d] E} (he : MeasurePreserving e \u03bd \u03bc) :\n    covolume (ZLattice.comap \u211d L e.toLinearMap) \u03bd = covolume L \u03bc := by\n  rw [covolume_eq_measure_fundamentalDomain _ _ (isAddFundamentalDomain (Free.chooseBasis \u2124 L) \u03bc),\n    covolume_eq_measure_fundamentalDomain _ _ ((isAddFundamentalDomain\n    ((Free.chooseBasis \u2124 L).ofZLatticeComap \u211d L e.toLinearEquiv) \u03bd)), \u2190 he.measure_preimage\n    (fundamentalDomain_measurableSet _).nullMeasurableSet, \u2190 e.image_symm_eq_preimage,\n    \u2190 e.symm.coe_toLinearEquiv, map_fundamentalDomain]\n  congr!\n  ext; simp\n\ntheorem covolume_eq_det_mul_measure {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (b : Basis \u03b9 \u2124 L)\n    (b\u2080 : Basis \u03b9 \u211d E) :\n    covolume L \u03bc = |b\u2080.det ((\u2191) \u2218 b)| * (\u03bc (fundamentalDomain b\u2080)).toReal := by\n  rw [covolume_eq_measure_fundamentalDomain L \u03bc (isAddFundamentalDomain b \u03bc),\n    measure_fundamentalDomain _ _ b\u2080,\n    measure_congr (fundamentalDomain_ae_parallelepiped b\u2080 \u03bc), ENNReal.toReal_mul,\n    ENNReal.toReal_ofReal (by positivity)]\n  congr\n  ext\n  exact b.ofZLatticeBasis_apply \u211d L _\n\ntheorem covolume_eq_det {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (L : Submodule \u2124 (\u03b9 \u2192 \u211d))\n    [DiscreteTopology L] [IsZLattice \u211d L] (b : Basis \u03b9 \u2124 L) :\n    covolume L = |(Matrix.of ((\u2191) \u2218 b)).det| := by\n  rw [covolume_eq_measure_fundamentalDomain L volume (isAddFundamentalDomain b volume),\n    volume_fundamentalDomain, ENNReal.toReal_ofReal (by positivity)]\n  congr\n  ext1\n  exact b.ofZLatticeBasis_apply \u211d L _\n\ntheorem covolume_eq_det_inv {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (L : Submodule \u2124 (\u03b9 \u2192 \u211d))\n    [DiscreteTopology L] [IsZLattice \u211d L] (b : Basis \u03b9 \u2124 L) :\n    covolume L = |(LinearEquiv.det (b.ofZLatticeBasis \u211d L).equivFun : \u211d)|\u207b\u00b9 := by\n  rw [covolume_eq_det L b, \u2190 Pi.basisFun_det_apply, show (((\u2191) : L \u2192 _) \u2218 \u21d1b) =\n    (b.ofZLatticeBasis \u211d) by ext; simp, \u2190 Basis.det_inv, \u2190 abs_inv, Units.val_inv_eq_inv_val,\n    IsUnit.unit_spec, \u2190 Basis.det_basis, LinearEquiv.coe_det]\n  rfl\n\ntheorem volume_image_eq_volume_div_covolume {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9]\n    (L : Submodule \u2124 (\u03b9 \u2192 \u211d)) [DiscreteTopology L] [IsZLattice \u211d L] (b : Basis \u03b9 \u2124 L)\n    {s : Set (\u03b9 \u2192 \u211d)} :\n    volume ((b.ofZLatticeBasis \u211d L).equivFun '' s) = volume s / ENNReal.ofReal (covolume L) := by\n  rw [LinearEquiv.image_eq_preimage, Measure.addHaar_preimage_linearEquiv, LinearEquiv.symm_symm,\n    covolume_eq_det_inv L b, ENNReal.div_eq_inv_mul, ENNReal.ofReal_inv_of_pos\n    (abs_pos.mpr (LinearEquiv.det _).ne_zero), inv_inv, LinearEquiv.coe_det]\n\n", "theoremStatement": "/-- A more general version of `ZLattice.volume_image_eq_volume_div_covolume`;\nsee the `Naming conventions` section in the introduction. -/\ntheorem volume_image_eq_volume_div_covolume' {E : Type*} [NormedAddCommGroup E]\n    [InnerProductSpace \u211d E] [FiniteDimensional \u211d E] [MeasurableSpace E] [BorelSpace E]\n    (L : Submodule \u2124 E) [DiscreteTopology L] [IsZLattice \u211d L] {\u03b9 : Type*} [Fintype \u03b9]\n    (b : Basis \u03b9 \u2124 L) {s : Set E} (hs : NullMeasurableSet s) :\n    volume ((b.ofZLatticeBasis \u211d).equivFun '' s) = volume s / ENNReal.ofReal (covolume L) ", "theoremName": "ZLattice.volume_image_eq_volume_div_covolume'", "fileCreated": {"commit": "85d6c78ac5782869d041c2ca6d3ca83cdde412c3", "date": "2024-09-09"}, "theoremCreated": {"commit": "211dc533566a173988a01067bb50d7917a097103", "date": "2024-12-18"}, "file": "mathlib/Mathlib/Algebra/Module/ZLattice/Covolume.lean", "module": "Mathlib.Algebra.Module.ZLattice.Covolume", "jsonFile": "Mathlib.Algebra.Module.ZLattice.Covolume.jsonl", "positionMetadata": {"lineInFile": 136, "tokenPositionInFile": 6527, "theoremPositionInFile": 9}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 203, "numPremises": 227}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  classical\n  let e : Fin (finrank \u211d E) \u2243 \u03b9 :=\n    Fintype.equivOfCardEq (by rw [Fintype.card_fin, finrank_eq_card_basis (b.ofZLatticeBasis \u211d)])\n  let f := (EuclideanSpace.equiv \u03b9 \u211d).symm.trans\n    ((stdOrthonormalBasis \u211d E).reindex e).repr.toContinuousLinearEquiv.symm\n  have hf : MeasurePreserving f :=\n    ((stdOrthonormalBasis \u211d E).reindex e).measurePreserving_repr_symm.comp\n      (EuclideanSpace.volume_preserving_measurableEquiv \u03b9).symm\n  rw [\u2190 hf.measure_preimage hs, \u2190 (covolume_comap L volume volume hf),\n    \u2190 volume_image_eq_volume_div_covolume (ZLattice.comap \u211d L f.toLinearMap)\n    (b.ofZLatticeComap \u211d L f.toLinearEquiv), Basis.ofZLatticeBasis_comap,\n    \u2190 f.image_symm_eq_preimage, \u2190 Set.image_comp]\n  simp only [Basis.equivFun_apply, ContinuousLinearEquiv.symm_toLinearEquiv, Basis.map_equivFun,\n    LinearEquiv.symm_symm, Function.comp_apply, LinearEquiv.trans_apply,\n    ContinuousLinearEquiv.coe_toLinearEquiv, ContinuousLinearEquiv.apply_symm_apply]", "proofType": "tactic", "proofLengthLines": 15, "proofLengthTokens": 976}}
{"srcContext": "/-\nCopyright (c) 2020 Aaron Anderson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Aaron Anderson\n-/\nimport Mathlib.Data.Set.Lattice\nimport Mathlib.Data.SetLike.Basic\nimport Mathlib.Order.ModularLattice\nimport Mathlib.Order.SuccPred.Basic\nimport Mathlib.Order.WellFounded\nimport Mathlib.Tactic.Nontriviality\nimport Mathlib.Order.ConditionallyCompleteLattice.Indexed\n\n/-!\n# Atoms, Coatoms, and Simple Lattices\n\nThis module defines atoms, which are minimal non-`\u22a5` elements in bounded lattices, simple lattices,\nwhich are lattices with only two elements, and related ideas.\n\n## Main definitions\n\n### Atoms and Coatoms\n  * `IsAtom a` indicates that the only element below `a` is `\u22a5`.\n  * `IsCoatom a` indicates that the only element above `a` is `\u22a4`.\n\n### Atomic and Atomistic Lattices\n  * `IsAtomic` indicates that every element other than `\u22a5` is above an atom.\n  * `IsCoatomic` indicates that every element other than `\u22a4` is below a coatom.\n  * `IsAtomistic` indicates that every element is the `sSup` of a set of atoms.\n  * `IsCoatomistic` indicates that every element is the `sInf` of a set of coatoms.\n  * `IsStronglyAtomic` indicates that for all `a < b`, there is some `x` with `a \u22d6 x \u2264 b`.\n  * `IsStronglyCoatomic` indicates that for all `a < b`, there is some `x` with `a \u2264 x \u22d6 b`.\n\n### Simple Lattices\n  * `IsSimpleOrder` indicates that an order has only two unique elements, `\u22a5` and `\u22a4`.\n  * `IsSimpleOrder.boundedOrder`\n  * `IsSimpleOrder.distribLattice`\n  * Given an instance of `IsSimpleOrder`, we provide the following definitions. These are not\n    made global instances as they contain data :\n    * `IsSimpleOrder.booleanAlgebra`\n    * `IsSimpleOrder.completeLattice`\n    * `IsSimpleOrder.completeBooleanAlgebra`\n\n## Main results\n  * `isAtom_dual_iff_isCoatom` and `isCoatom_dual_iff_isAtom` express the (definitional) duality\n   of `IsAtom` and `IsCoatom`.\n  * `isSimpleOrder_iff_isAtom_top` and `isSimpleOrder_iff_isCoatom_bot` express the\n  connection between atoms, coatoms, and simple lattices\n  * `IsCompl.isAtom_iff_isCoatom` and `IsCompl.isCoatom_if_isAtom`: In a modular\n  bounded lattice, a complement of an atom is a coatom and vice versa.\n  * `isAtomic_iff_isCoatomic`: A modular complemented lattice is atomic iff it is coatomic.\n\n-/\n\nvariable {\u03b9 : Sort*} {\u03b1 \u03b2 : Type*}\n\nsection Atoms\n\nsection IsAtom\n\nsection Preorder\n\nvariable [Preorder \u03b1] [OrderBot \u03b1] {a b x : \u03b1}\n\n/-- An atom of an `OrderBot` is an element with no other element between it and `\u22a5`,\n  which is not `\u22a5`. -/\ndef IsAtom (a : \u03b1) : Prop :=\n  a \u2260 \u22a5 \u2227 \u2200 b, b < a \u2192 b = \u22a5\n\ntheorem IsAtom.Iic (ha : IsAtom a) (hax : a \u2264 x) : IsAtom (\u27e8a, hax\u27e9 : Set.Iic x) :=\n  \u27e8fun con => ha.1 (Subtype.mk_eq_mk.1 con), fun \u27e8b, _\u27e9 hba => Subtype.mk_eq_mk.2 (ha.2 b hba)\u27e9\n\ntheorem IsAtom.of_isAtom_coe_Iic {a : Set.Iic x} (ha : IsAtom a) : IsAtom (a : \u03b1) :=\n  \u27e8fun con => ha.1 (Subtype.ext con), fun b hba =>\n    Subtype.mk_eq_mk.1 (ha.2 \u27e8b, hba.le.trans a.prop\u27e9 hba)\u27e9\n\ntheorem isAtom_iff_le_of_ge : IsAtom a \u2194 a \u2260 \u22a5 \u2227 \u2200 b \u2260 \u22a5, b \u2264 a \u2192 a \u2264 b :=\n  and_congr Iff.rfl <|\n    forall_congr' fun b => by\n      simp only [Ne, @not_imp_comm (b = \u22a5), Classical.not_imp, lt_iff_le_not_le]\n\nend Preorder\n\nsection PartialOrder\n\nvariable [PartialOrder \u03b1] [OrderBot \u03b1] {a b x : \u03b1}\n\ntheorem IsAtom.lt_iff (h : IsAtom a) : x < a \u2194 x = \u22a5 :=\n  \u27e8h.2 x, fun hx => hx.symm \u25b8 h.1.bot_lt\u27e9\n\ntheorem IsAtom.le_iff (h : IsAtom a) : x \u2264 a \u2194 x = \u22a5 \u2228 x = a := by rw [le_iff_lt_or_eq, h.lt_iff]\n\nlemma IsAtom.bot_lt (h : IsAtom a) : \u22a5 < a :=\n  h.lt_iff.mpr rfl\n\nlemma IsAtom.le_iff_eq (ha : IsAtom a) (hb : b \u2260 \u22a5) : b \u2264 a \u2194 b = a :=\n  ha.le_iff.trans <| or_iff_right hb\n\ntheorem IsAtom.Iic_eq (h : IsAtom a) : Set.Iic a = {\u22a5, a} :=\n  Set.ext fun _ => h.le_iff\n\n@[simp]\ntheorem bot_covBy_iff : \u22a5 \u22d6 a \u2194 IsAtom a := by\n  simp only [CovBy, bot_lt_iff_ne_bot, IsAtom, not_imp_not]\n\nalias \u27e8CovBy.is_atom, IsAtom.bot_covBy\u27e9 := bot_covBy_iff\n\nend PartialOrder\n\ntheorem atom_le_iSup [Order.Frame \u03b1] {a : \u03b1} (ha : IsAtom a) {f : \u03b9 \u2192 \u03b1} :\n    a \u2264 iSup f \u2194 \u2203 i, a \u2264 f i := by\n  refine \u27e8?_, fun \u27e8i, hi\u27e9 => le_trans hi (le_iSup _ _)\u27e9\n  show (a \u2264 \u2a06 i, f i) \u2192 _\n  refine fun h => of_not_not fun ha' => ?_\n  push_neg at ha'\n  have ha'' : Disjoint a (\u2a06 i, f i) :=\n    disjoint_iSup_iff.2 fun i => fun x hxa hxf => le_bot_iff.2 <| of_not_not fun hx =>\n      have hxa : x < a := (le_iff_eq_or_lt.1 hxa).resolve_left (by rintro rfl; exact ha' _ hxf)\n      hx (ha.2 _ hxa)\n  obtain rfl := le_bot_iff.1 (ha'' le_rfl h)\n  exact ha.1 rfl\n\nend IsAtom\n\nsection IsCoatom\n\nsection Preorder\n\nvariable [Preorder \u03b1]\n\n/-- A coatom of an `OrderTop` is an element with no other element between it and `\u22a4`,\n  which is not `\u22a4`. -/\ndef IsCoatom [OrderTop \u03b1] (a : \u03b1) : Prop :=\n  a \u2260 \u22a4 \u2227 \u2200 b, a < b \u2192 b = \u22a4\n\n@[simp]\ntheorem isCoatom_dual_iff_isAtom [OrderBot \u03b1] {a : \u03b1} :\n    IsCoatom (OrderDual.toDual a) \u2194 IsAtom a :=\n  Iff.rfl\n\n@[simp]\ntheorem isAtom_dual_iff_isCoatom [OrderTop \u03b1] {a : \u03b1} :\n    IsAtom (OrderDual.toDual a) \u2194 IsCoatom a :=\n  Iff.rfl\n\nalias \u27e8_, IsAtom.dual\u27e9 := isCoatom_dual_iff_isAtom\n\nalias \u27e8_, IsCoatom.dual\u27e9 := isAtom_dual_iff_isCoatom\n\nvariable [OrderTop \u03b1] {a x : \u03b1}\n\ntheorem IsCoatom.Ici (ha : IsCoatom a) (hax : x \u2264 a) : IsCoatom (\u27e8a, hax\u27e9 : Set.Ici x) :=\n  ha.dual.Iic hax\n\ntheorem IsCoatom.of_isCoatom_coe_Ici {a : Set.Ici x} (ha : IsCoatom a) : IsCoatom (a : \u03b1) :=\n  @IsAtom.of_isAtom_coe_Iic \u03b1\u1d52\u1d48 _ _ x a ha\n\ntheorem isCoatom_iff_ge_of_le : IsCoatom a \u2194 a \u2260 \u22a4 \u2227 \u2200 b \u2260 \u22a4, a \u2264 b \u2192 b \u2264 a :=\n  isAtom_iff_le_of_ge (\u03b1 := \u03b1\u1d52\u1d48)\n\nend Preorder\n\nsection PartialOrder\n\nvariable [PartialOrder \u03b1] [OrderTop \u03b1] {a b x : \u03b1}\n\ntheorem IsCoatom.lt_iff (h : IsCoatom a) : a < x \u2194 x = \u22a4 :=\n  h.dual.lt_iff\n\ntheorem IsCoatom.le_iff (h : IsCoatom a) : a \u2264 x \u2194 x = \u22a4 \u2228 x = a :=\n  h.dual.le_iff\n\nlemma IsCoatom.lt_top (h : IsCoatom a) : a < \u22a4 :=\n  h.lt_iff.mpr rfl\n\nlemma IsCoatom.le_iff_eq (ha : IsCoatom a) (hb : b \u2260 \u22a4) : a \u2264 b \u2194 b = a := ha.dual.le_iff_eq hb\n\ntheorem IsCoatom.Ici_eq (h : IsCoatom a) : Set.Ici a = {\u22a4, a} :=\n  h.dual.Iic_eq\n\n@[simp]\ntheorem covBy_top_iff : a \u22d6 \u22a4 \u2194 IsCoatom a :=\n  toDual_covBy_toDual_iff.symm.trans bot_covBy_iff\n\nalias \u27e8CovBy.isCoatom, IsCoatom.covBy_top\u27e9 := covBy_top_iff\n\nnamespace SetLike\n\nvariable {A B : Type*} [SetLike A B]\n\ntheorem isAtom_iff [OrderBot A] {K : A} :\n    IsAtom K \u2194 K \u2260 \u22a5 \u2227 \u2200 H g, H \u2264 K \u2192 g \u2209 H \u2192 g \u2208 K \u2192 H = \u22a5 := by\n  simp_rw [IsAtom, lt_iff_le_not_le, SetLike.not_le_iff_exists,\n    and_comm (a := _ \u2264 _), and_imp, exists_imp, \u2190 and_imp, and_comm]\n\ntheorem isCoatom_iff [OrderTop A] {K : A} :\n    IsCoatom K \u2194 K \u2260 \u22a4 \u2227 \u2200 H g, K \u2264 H \u2192 g \u2209 K \u2192 g \u2208 H \u2192 H = \u22a4 := by\n  simp_rw [IsCoatom, lt_iff_le_not_le, SetLike.not_le_iff_exists,\n    and_comm (a := _ \u2264 _), and_imp, exists_imp, \u2190 and_imp, and_comm]\n\ntheorem covBy_iff {K L : A} :\n    K \u22d6 L \u2194 K < L \u2227 \u2200 H g, K \u2264 H \u2192 H \u2264 L \u2192 g \u2209 K \u2192 g \u2208 H \u2192 H = L := by\n  refine and_congr_right fun _ \u21a6 forall_congr' fun H \u21a6 not_iff_not.mp ?_\n  push_neg\n  rw [lt_iff_le_not_le, lt_iff_le_and_ne, and_and_and_comm]\n  simp_rw [exists_and_left, and_assoc, and_congr_right_iff, \u2190 and_assoc, and_comm, exists_and_left,\n    SetLike.not_le_iff_exists, and_comm, implies_true]\n\n", "theoremStatement": "/-- Dual variant of `SetLike.covBy_iff` -/\ntheorem covBy_iff' {K L : A} :\n    K \u22d6 L \u2194 K < L \u2227 \u2200 H g, K \u2264 H \u2192 H \u2264 L \u2192 g \u2209 H \u2192 g \u2208 L \u2192 H = K ", "theoremName": "SetLike.covBy_iff'", "fileCreated": {"commit": "8618f40d51539454fe06511d5c8504a77f30c598", "date": "2022-12-30"}, "theoremCreated": {"commit": "74fff29536e0a0eeca1aa8421089b76b157a3b2f", "date": "2025-01-14"}, "file": "mathlib/Mathlib/Order/Atoms.lean", "module": "Mathlib.Order.Atoms", "jsonFile": "Mathlib.Order.Atoms.jsonl", "positionMetadata": {"lineInFile": 209, "tokenPositionInFile": 7119, "theoremPositionInFile": 26}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 14, "numPremises": 46}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  refine and_congr_right fun _ \u21a6 forall_congr' fun H \u21a6 not_iff_not.mp ?_\n  push_neg\n  rw [lt_iff_le_and_ne, lt_iff_le_not_le, and_and_and_comm]\n  simp_rw [exists_and_left, and_assoc, and_congr_right_iff, \u2190 and_assoc, and_comm, exists_and_left,\n    SetLike.not_le_iff_exists, ne_comm, implies_true]", "proofType": "tactic", "proofLengthLines": 5, "proofLengthTokens": 303}}
{"srcContext": "/-\nCopyright (c) 2024 Fangming Li. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Fangming Li, Jujian Zhang\n-/\nimport Mathlib.Algebra.Polynomial.AlgebraMap\nimport Mathlib.Algebra.Polynomial.Eval.SMul\nimport Mathlib.Algebra.Polynomial.Roots\nimport Mathlib.Order.Interval.Set.Infinite\nimport Mathlib.RingTheory.Polynomial.Pochhammer\nimport Mathlib.RingTheory.PowerSeries.WellKnown\nimport Mathlib.Tactic.FieldSimp\n\n/-!\n# Hilbert polynomials\n\nIn this file, we formalise the following statement: if `F` is a field with characteristic `0`, then\ngiven any `p : F[X]` and `d : \u2115`, there exists some `h : F[X]` such that for any large enough\n`n : \u2115`, `h(n)` is equal to the coefficient of `X\u207f` in the power series expansion of `p/(1 - X)\u1d48`.\nThis `h` is unique and is denoted as `Polynomial.hilbertPoly p d`.\n\nFor example, given `d : \u2115`, the power series expansion of `1/(1 - X)\u1d48\u207a\u00b9` in `F[X]`\nis `\u03a3\u2099 ((d + n).choose d)X\u207f`, which equals `\u03a3\u2099 ((n + 1)\u00b7\u00b7\u00b7(n + d)/d!)X\u207f` and hence\n`Polynomial.hilbertPoly (1 : F[X]) (d + 1)` is the polynomial `(X + 1)\u00b7\u00b7\u00b7(X + d)/d!`. Note that\nif `d! = 0` in `F`, then the polynomial `(X + 1)\u00b7\u00b7\u00b7(X + d)/d!` no longer works, so we do not want\nthe characteristic of `F` to be divisible by `d!`. As `Polynomial.hilbertPoly` may take any\n`p : F[X]` and `d : \u2115` as its inputs, it is necessary for us to assume that `CharZero F`.\n\n## Main definitions\n\n* `Polynomial.hilbertPoly p d`. Given a field `F`, a polynomial `p : F[X]` and a natural number `d`,\n  if `F` is of characteristic `0`, then `Polynomial.hilbertPoly p d : F[X]` is the polynomial whose\n  value at `n` equals the coefficient of `X\u207f` in the power series expansion of `p/(1 - X)\u1d48`.\n\n## TODO\n\n* Hilbert polynomials of finitely generated graded modules over Noetherian rings.\n-/\n\nopen Nat PowerSeries\n\nvariable (F : Type*) [Field F]\n\nnamespace Polynomial\n\n/--\nFor any field `F` and natural numbers `d` and `k`, `Polynomial.preHilbertPoly F d k`\nis defined as `(d.factorial : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (X - (C (k : F)) + 1))`.\nThis is the most basic form of Hilbert polynomials. `Polynomial.preHilbertPoly \u211a d 0`\nis exactly the Hilbert polynomial of the polynomial ring `\u211a[X_0,...,X_d]` viewed as\na graded module over itself. In fact, `Polynomial.preHilbertPoly F d k` is the\nsame as `Polynomial.hilbertPoly ((X : F[X]) ^ k) (d + 1)` for any field `F` and\n`d k : \u2115` (see the lemma `Polynomial.hilbertPoly_X_pow_succ`). See also the lemma\n`Polynomial.preHilbertPoly_eq_choose_sub_add`, which states that if `CharZero F`,\nthen for any `d k n : \u2115` with `k \u2264 n`, `(Polynomial.preHilbertPoly F d k).eval (n : F)`\nequals `(n - k + d).choose d`.\n-/\nnoncomputable def preHilbertPoly (d k : \u2115) : F[X] :=\n  (d.factorial : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (Polynomial.X - (C (k : F)) + 1))\n\nlemma natDegree_preHilbertPoly [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).natDegree = d := by\n  have hne : (d ! : F) \u2260 0 := by norm_cast; positivity\n  rw [preHilbertPoly, natDegree_smul _ (inv_ne_zero hne), natDegree_comp, ascPochhammer_natDegree,\n    add_comm_sub, \u2190 C_1, \u2190 map_sub, natDegree_add_C, natDegree_X, mul_one]\n\nlemma coeff_preHilbertPoly_self [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).coeff d = (d ! : F)\u207b\u00b9 := by\n  delta preHilbertPoly\n  have hne : (d ! : F) \u2260 0 := by norm_cast; positivity\n  have heq : d = ((ascPochhammer F d).comp (X - C (k : F) + 1)).natDegree :=\n    (natDegree_preHilbertPoly F d k).symm.trans (natDegree_smul _ (inv_ne_zero hne))\n  nth_rw 3 [heq]\n  calc\n  _ = (d ! : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (X - C ((k : F) - 1))).leadingCoeff := by\n    simp only [sub_add, \u2190 C_1, \u2190 map_sub, coeff_smul, coeff_natDegree]\n  _ = (d ! : F)\u207b\u00b9 := by\n    simp only [leadingCoeff_comp (ne_of_eq_of_ne (natDegree_X_sub_C _) one_ne_zero), Monic.def.1\n      (monic_ascPochhammer _ _), one_mul, leadingCoeff_X_sub_C, one_pow, smul_eq_mul, mul_one]\n\nlemma leadingCoeff_preHilbertPoly [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).leadingCoeff = (d ! : F)\u207b\u00b9 := by\n  rw [leadingCoeff, natDegree_preHilbertPoly, coeff_preHilbertPoly_self]\n\nlemma preHilbertPoly_eq_choose_sub_add [CharZero F] (d : \u2115) {k n : \u2115} (hkn : k \u2264 n):\n    (preHilbertPoly F d k).eval (n : F) = (n - k + d).choose d := by\n  have : (d ! : F) \u2260 0 := by norm_cast; positivity\n  calc\n  _ = (\u2191d !)\u207b\u00b9 * eval (\u2191(n - k + 1)) (ascPochhammer F d) := by simp [cast_sub hkn, preHilbertPoly]\n  _ = (n - k + d).choose d := by\n    rw [ascPochhammer_nat_eq_natCast_ascFactorial];\n    field_simp [ascFactorial_eq_factorial_mul_choose]\n\nvariable {F}\n\n/--\n`Polynomial.hilbertPoly p 0 = 0`; for any `d : \u2115`, `Polynomial.hilbertPoly p (d + 1)`\nis defined as `\u2211 i \u2208 p.support, (p.coeff i) \u2022 Polynomial.preHilbertPoly F d i`. If\n`M` is a graded module whose Poincar\u00e9 series can be written as `p(X)/(1 - X)\u1d48` for some\n`p : \u211a[X]` with integer coefficients, then `Polynomial.hilbertPoly p d` is the Hilbert\npolynomial of `M`. See also `Polynomial.coeff_mul_invOneSubPow_eq_hilbertPoly_eval`,\nwhich says that `PowerSeries.coeff F n (p * PowerSeries.invOneSubPow F d)` equals\n`(Polynomial.hilbertPoly p d).eval (n : F)` for any large enough `n : \u2115`.\n-/\nnoncomputable def hilbertPoly (p : F[X]) : (d : \u2115) \u2192 F[X]\n  | 0 => 0\n  | d + 1 => \u2211 i \u2208 p.support, (p.coeff i) \u2022 preHilbertPoly F d i\n\nlemma hilbertPoly_zero_left (d : \u2115) : hilbertPoly (0 : F[X]) d = 0 := by\n  delta hilbertPoly; induction d with\n  | zero => simp only\n  | succ d _ => simp only [coeff_zero, zero_smul, Finset.sum_const_zero]\n\nlemma hilbertPoly_zero_right (p : F[X]) : hilbertPoly p 0 = 0 := rfl\n\nlemma hilbertPoly_succ (p : F[X]) (d : \u2115) :\n    hilbertPoly p (d + 1) = \u2211 i \u2208 p.support, (p.coeff i) \u2022 preHilbertPoly F d i := rfl\n\nlemma hilbertPoly_X_pow_succ (d k : \u2115) :\n    hilbertPoly ((X : F[X]) ^ k) (d + 1) = preHilbertPoly F d k := by\n  delta hilbertPoly; simp\n\nlemma hilbertPoly_add_left (p q : F[X]) (d : \u2115) :\n    hilbertPoly (p + q) d = hilbertPoly p d + hilbertPoly q d := by\n  delta hilbertPoly\n  induction d with\n  | zero => simp only [add_zero]\n  | succ d _ =>\n      simp only [\u2190 coeff_add]\n      rw [\u2190 sum_def _ fun _ r => r \u2022 _]\n      exact sum_add_index _ _ _ (fun _ => zero_smul ..) (fun _ _ _ => add_smul ..)\n\nlemma hilbertPoly_smul (a : F) (p : F[X]) (d : \u2115) :\n    hilbertPoly (a \u2022 p) d = a \u2022 hilbertPoly p d := by\n  delta hilbertPoly\n  induction d with\n  | zero => simp only [smul_zero]\n  | succ d _ =>\n      simp only\n      rw [\u2190 sum_def _ fun _ r => r \u2022 _, \u2190 sum_def _ fun _ r => r \u2022 _, Polynomial.smul_sum,\n        sum_smul_index' _ _ _ fun i => zero_smul F (preHilbertPoly F d i)]\n      simp only [smul_assoc]\n\nvariable (F) in\n/--\nThe function that sends any `p : F[X]` to `Polynomial.hilbertPoly p d` is an `F`-linear map from\n`F[X]` to `F[X]`.\n-/\nnoncomputable def hilbertPoly_linearMap (d : \u2115) : F[X] \u2192\u2097[F] F[X] where\n  toFun p := hilbertPoly p d\n  map_add' p q := hilbertPoly_add_left p q d\n  map_smul' r p := hilbertPoly_smul r p d\n\nvariable [CharZero F]\n\n/--\nThe key property of Hilbert polynomials. If `F` is a field with characteristic `0`, `p : F[X]` and\n`d : \u2115`, then for any large enough `n : \u2115`, `(Polynomial.hilbertPoly p d).eval (n : F)` equals the\ncoefficient of `X\u207f` in the power series expansion of `p/(1 - X)\u1d48`.\n-/\ntheorem coeff_mul_invOneSubPow_eq_hilbertPoly_eval\n    {p : F[X]} (d : \u2115) {n : \u2115} (hn : p.natDegree < n) :\n    PowerSeries.coeff F n (p * invOneSubPow F d) = (hilbertPoly p d).eval (n : F) := by\n  delta hilbertPoly; induction d with\n  | zero => simp only [invOneSubPow_zero, Units.val_one, mul_one, coeff_coe, eval_zero]\n            exact coeff_eq_zero_of_natDegree_lt hn\n  | succ d hd =>\n      simp only [eval_finset_sum, eval_smul, smul_eq_mul]\n      rw [\u2190 Finset.sum_coe_sort]\n      have h_le (i : p.support) : (i : \u2115) \u2264 n :=\n        le_trans (le_natDegree_of_ne_zero <| mem_support_iff.1 i.2) hn.le\n      have h (i : p.support) : eval \u2191n (preHilbertPoly F d \u2191i) = (n + d - \u2191i).choose d := by\n        rw [preHilbertPoly_eq_choose_sub_add _ _ (h_le i), Nat.sub_add_comm (h_le i)]\n      simp_rw [h]\n      rw [Finset.sum_coe_sort _ (fun x => (p.coeff \u2191x) * (_ + d - \u2191x).choose _),\n        PowerSeries.coeff_mul, Finset.Nat.sum_antidiagonal_eq_sum_range_succ_mk,\n        invOneSubPow_val_eq_mk_sub_one_add_choose_of_pos _ _ (zero_lt_succ d)]\n      simp only [coeff_coe, coeff_mk]\n      symm\n      refine Finset.sum_subset_zero_on_sdiff (fun s hs \u21a6 ?_) (fun x hx \u21a6 ?_) (fun x hx \u21a6 ?_)\n      \u00b7 rw [Finset.mem_range_succ_iff]\n        exact h_le \u27e8s, hs\u27e9\n      \u00b7 simp only [Finset.mem_sdiff, mem_support_iff, not_not] at hx\n        rw [hx.2, zero_mul]\n      \u00b7 rw [add_comm, Nat.add_sub_assoc (h_le \u27e8x, hx\u27e9), succ_eq_add_one, add_tsub_cancel_right]\n\n/--\nThe polynomial satisfying the key property of `Polynomial.hilbertPoly p d` is unique.\n-/\ntheorem existsUnique_hilbertPoly (p : F[X]) (d : \u2115) :\n    \u2203! h : F[X], \u2203 N : \u2115, \u2200 n > N,\n    PowerSeries.coeff F n (p * invOneSubPow F d) = h.eval (n : F) := by\n  use hilbertPoly p d; constructor\n  \u00b7 use p.natDegree\n    exact fun n => coeff_mul_invOneSubPow_eq_hilbertPoly_eval d\n  \u00b7 rintro h \u27e8N, hhN\u27e9\n    apply eq_of_infinite_eval_eq h (hilbertPoly p d)\n    apply ((Set.Ioi_infinite (max N p.natDegree)).image cast_injective.injOn).mono\n    rintro x \u27e8n, hn, rfl\u27e9\n    simp only [Set.mem_Ioi, sup_lt_iff, Set.mem_setOf_eq] at hn \u22a2\n    rw [\u2190 coeff_mul_invOneSubPow_eq_hilbertPoly_eval d hn.2, hhN n hn.1]\n\n@[deprecated (since := \"2024-12-17\")] alias exists_unique_hilbertPoly := existsUnique_hilbertPoly\n\n/--\nIf `h : F[X]` and there exists some `N : \u2115` such that for any number `n : \u2115` bigger than `N`\nwe have `PowerSeries.coeff F n (p * invOneSubPow F d) = h.eval (n : F)`, then `h` is exactly\n`Polynomial.hilbertPoly p d`.\n-/\ntheorem eq_hilbertPoly_of_forall_coeff_eq_eval\n    {p h : F[X]} {d : \u2115} (N : \u2115) (hhN : \u2200 n > N,\n    PowerSeries.coeff F n (p * invOneSubPow F d) = h.eval (n : F)) :\n    h = hilbertPoly p d :=\n  ExistsUnique.unique (existsUnique_hilbertPoly p d) \u27e8N, hhN\u27e9\n    \u27e8p.natDegree, fun _ x => coeff_mul_invOneSubPow_eq_hilbertPoly_eval d x\u27e9\n\nlemma hilbertPoly_mul_one_sub_succ (p : F[X]) (d : \u2115) :\n    hilbertPoly (p * (1 - X)) (d + 1) = hilbertPoly p d := by\n  apply eq_hilbertPoly_of_forall_coeff_eq_eval (p * (1 - X)).natDegree\n  intro n hn\n  have heq : 1 - PowerSeries.X = ((1 - X : F[X]) : F\u27e6X\u27e7) := by simp only [coe_sub, coe_one, coe_X]\n  rw [\u2190 one_sub_pow_mul_invOneSubPow_val_add_eq_invOneSubPow_val F d 1, pow_one, \u2190 mul_assoc, heq,\n    \u2190 coe_mul, coeff_mul_invOneSubPow_eq_hilbertPoly_eval (d + 1) hn]\n\n", "theoremStatement": "lemma hilbertPoly_mul_one_sub_pow_add (p : F[X]) (d e : \u2115) :\n    hilbertPoly (p * (1 - X) ^ e) (d + e) = hilbertPoly p d ", "theoremName": "Polynomial.hilbertPoly_mul_one_sub_pow_add", "fileCreated": {"commit": "561e050467d2caa2e4ea5d81ca62600bf268b747", "date": "2024-12-02"}, "theoremCreated": {"commit": "7a05b449ac13af0118fd6b2c133d08e33e7e74ad", "date": "2024-12-04"}, "file": "mathlib/Mathlib/RingTheory/Polynomial/HilbertPoly.lean", "module": "Mathlib.RingTheory.Polynomial.HilbertPoly", "jsonFile": "Mathlib.RingTheory.Polynomial.HilbertPoly.jsonl", "positionMetadata": {"lineInFile": 225, "tokenPositionInFile": 10482, "theoremPositionInFile": 15}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 48, "numPremises": 73}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  induction e with\n  | zero => simp\n  | succ e he => rw [pow_add, pow_one, \u2190 mul_assoc, \u2190 add_assoc, hilbertPoly_mul_one_sub_succ, he]", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 140}}
{"srcContext": "/-\nCopyright (c) 2017 Johannes H\u00f6lzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes H\u00f6lzl, Mario Carneiro, Kevin Buzzard, Yury Kudryashov, Fr\u00e9d\u00e9ric Dupuis,\n  Heather Macbeth\n-/\nimport Mathlib.Algebra.Module.Submodule.Lattice\n\n/-!\n# The span of a set of vectors, as a submodule\n\n* `Submodule.span s` is defined to be the smallest submodule containing the set `s`.\n\n## Notations\n\n* We introduce the notation `R \u2219 v` for the span of a singleton, `Submodule.span R {v}`.  This is\n  `\\span`, not the same as the scalar multiplication `\u2022`/`\\bub`.\n\n-/\n\nassert_not_exists Field\n\nvariable {R R\u2082 K M M\u2082 V S : Type*}\n\nnamespace Submodule\n\nopen Function Set\n\nopen Pointwise\n\nsection AddCommMonoid\n\nvariable [Semiring R] [AddCommMonoid M] [Module R M]\nvariable {x : M} (p p' : Submodule R M)\nvariable [Semiring R\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082}\nvariable [AddCommMonoid M\u2082] [Module R\u2082 M\u2082]\nvariable {F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082]\n\nsection\n\nvariable (R)\n\n/-- The span of a set `s \u2286 M` is the smallest submodule of M that contains `s`. -/\ndef span (s : Set M) : Submodule R M :=\n  sInf { p | s \u2286 p }\n\nvariable {R}\n\n-- Porting note: renamed field to `principal'` and added `principal` to fix explicit argument\n/-- An `R`-submodule of `M` is principal if it is generated by one element. -/\n@[mk_iff]\nclass IsPrincipal (S : Submodule R M) : Prop where\n  principal' : \u2203 a, S = span R {a}\n\ntheorem IsPrincipal.principal (S : Submodule R M) [S.IsPrincipal] :\n    \u2203 a, S = span R {a} :=\n  Submodule.IsPrincipal.principal'\n\nend\n\nvariable {s t : Set M}\n\ntheorem mem_span : x \u2208 span R s \u2194 \u2200 p : Submodule R M, s \u2286 p \u2192 x \u2208 p :=\n  mem_iInter\u2082\n\n@[aesop safe 20 apply (rule_sets := [SetLike])]\ntheorem subset_span : s \u2286 span R s := fun _ h => mem_span.2 fun _ hp => hp h\n\ntheorem span_le {p} : span R s \u2264 p \u2194 s \u2286 p :=\n  \u27e8Subset.trans subset_span, fun ss _ h => mem_span.1 h _ ss\u27e9\n\n@[gcongr] theorem span_mono (h : s \u2286 t) : span R s \u2264 span R t :=\n  span_le.2 <| Subset.trans h subset_span\n\ntheorem span_monotone : Monotone (span R : Set M \u2192 Submodule R M) := fun _ _ => span_mono\n\ntheorem span_eq_of_le (h\u2081 : s \u2286 p) (h\u2082 : p \u2264 span R s) : span R s = p :=\n  le_antisymm (span_le.2 h\u2081) h\u2082\n\ntheorem span_eq : span R (p : Set M) = p :=\n  span_eq_of_le _ (Subset.refl _) subset_span\n\ntheorem span_eq_span (hs : s \u2286 span R t) (ht : t \u2286 span R s) : span R s = span R t :=\n  le_antisymm (span_le.2 hs) (span_le.2 ht)\n\n/-- A version of `Submodule.span_eq` for subobjects closed under addition and scalar multiplication\nand containing zero. In general, this should not be used directly, but can be used to quickly\ngenerate proofs for specific types of subobjects. -/\nlemma coe_span_eq_self [SetLike S M] [AddSubmonoidClass S M] [SMulMemClass S R M] (s : S) :\n    (span R (s : Set M) : Set M) = s := by\n  refine le_antisymm ?_ subset_span\n  let s' : Submodule R M :=\n    { carrier := s\n      add_mem' := add_mem\n      zero_mem' := zero_mem _\n      smul_mem' := SMulMemClass.smul_mem }\n  exact span_le (p := s') |>.mpr le_rfl\n\n@[simp]\ntheorem span_insert_zero : span R (insert (0 : M) s) = span R s := by\n  refine le_antisymm ?_ (Submodule.span_mono (Set.subset_insert 0 s))\n  rw [span_le, Set.insert_subset_iff]\n  exact \u27e8by simp only [SetLike.mem_coe, Submodule.zero_mem], Submodule.subset_span\u27e9\n\ntheorem closure_subset_span {s : Set M} : (AddSubmonoid.closure s : Set M) \u2286 span R s :=\n  (@AddSubmonoid.closure_le _ _ _ (span R s).toAddSubmonoid).mpr subset_span\n\ntheorem closure_le_toAddSubmonoid_span {s : Set M} :\n    AddSubmonoid.closure s \u2264 (span R s).toAddSubmonoid :=\n  closure_subset_span\n\n@[simp]\ntheorem span_closure {s : Set M} : span R (AddSubmonoid.closure s : Set M) = span R s :=\n  le_antisymm (span_le.mpr closure_subset_span) (span_mono AddSubmonoid.subset_closure)\n\n/-- An induction principle for span membership. If `p` holds for 0 and all elements of `s`, and is\npreserved under addition and scalar multiplication, then `p` holds for all elements of the span of\n`s`. -/\n@[elab_as_elim]\ntheorem span_induction {p : (x : M) \u2192 x \u2208 span R s \u2192 Prop}\n    (mem : \u2200 (x) (h : x \u2208 s), p x (subset_span h))\n    (zero : p 0 (Submodule.zero_mem _))\n    (add : \u2200 x y hx hy, p x hx \u2192 p y hy \u2192 p (x + y) (Submodule.add_mem _ \u2039_\u203a \u2039_\u203a))\n    (smul : \u2200 (a : R) (x hx), p x hx \u2192 p (a \u2022 x) (Submodule.smul_mem _ _ \u2039_\u203a)) {x}\n    (hx : x \u2208 span R s) : p x hx := by\n  let p : Submodule R M :=\n    { carrier := { x | \u2203 hx, p x hx }\n      add_mem' := fun \u27e8_, hpx\u27e9 \u27e8_, hpy\u27e9 \u21a6 \u27e8_, add _ _ _ _ hpx hpy\u27e9\n      zero_mem' := \u27e8_, zero\u27e9\n      smul_mem' := fun r \u21a6 fun \u27e8_, hpx\u27e9 \u21a6 \u27e8_, smul r _ _ hpx\u27e9 }\n  exact span_le (p := p) |>.mpr (fun y hy \u21a6 \u27e8subset_span hy, mem y hy\u27e9) hx |>.elim fun _ \u21a6 id\n\n@[deprecated span_induction (since := \"2024-10-10\")]\nalias span_induction' := span_induction\n\n/-- An induction principle for span membership. This is a version of `Submodule.span_induction`\nfor binary predicates. -/\ntheorem span_induction\u2082 {N : Type*} [AddCommMonoid N] [Module R N] {t : Set N}\n    {p : (x : M) \u2192 (y : N) \u2192 x \u2208 span R s \u2192 y \u2208 span R t \u2192 Prop}\n    (mem_mem : \u2200 (x) (y) (hx : x \u2208 s) (hy : y \u2208 t), p x y (subset_span hx) (subset_span hy))\n    (zero_left : \u2200 y hy, p 0 y (zero_mem _) hy) (zero_right : \u2200 x hx, p x 0 hx (zero_mem _))\n    (add_left : \u2200 x y z hx hy hz, p x z hx hz \u2192 p y z hy hz \u2192 p (x + y) z (add_mem hx hy) hz)\n    (add_right : \u2200 x y z hx hy hz, p x y hx hy \u2192 p x z hx hz \u2192 p x (y + z) hx (add_mem hy hz))\n    (smul_left : \u2200 (r : R) x y hx hy, p x y hx hy \u2192 p (r \u2022 x) y (smul_mem _ r hx) hy)\n    (smul_right : \u2200 (r : R) x y hx hy, p x y hx hy \u2192 p x (r \u2022 y) hx (smul_mem _ r hy))\n    {a : M} {b : N} (ha : a \u2208 Submodule.span R s)\n    (hb : b \u2208 Submodule.span R t) : p a b ha hb := by\n  induction hb using span_induction with\n  | mem z hz => induction ha using span_induction with\n    | mem _ h => exact mem_mem _ _ h hz\n    | zero => exact zero_left _ _\n    | add _ _ _ _ h\u2081 h\u2082 => exact add_left _ _ _ _ _ _ h\u2081 h\u2082\n    | smul _ _ _ h => exact smul_left _ _ _ _ _ h\n  | zero => exact zero_right a ha\n  | add _ _ _ _ h\u2081 h\u2082 => exact add_right _ _ _ _ _ _ h\u2081 h\u2082\n  | smul _ _ _ h => exact smul_right _ _ _ _ _ h\n\nopen AddSubmonoid in\ntheorem span_eq_closure {s : Set M} : (span R s).toAddSubmonoid = closure (@univ R \u2022 s) := by\n  refine le_antisymm (fun x (hx : x \u2208 span R s) \u21a6 ?of_mem_span) (fun x hx \u21a6 ?of_mem_closure)\n  case of_mem_span =>\n    induction hx using span_induction with\n    | mem x hx => exact subset_closure \u27e81, trivial, x, hx, one_smul R x\u27e9\n    | zero => exact zero_mem _\n    | add _ _ _ _ h\u2081 h\u2082 => exact add_mem h\u2081 h\u2082\n    | smul r\u2081 y _h hy =>\n      clear _h\n      induction hy using AddSubmonoid.closure_induction with\n      | mem _ h =>\n        obtain \u27e8r\u2082, -, x, hx, rfl\u27e9 := h\n        exact subset_closure \u27e8r\u2081 * r\u2082, trivial, x, hx, mul_smul ..\u27e9\n      | one => simpa only [smul_zero] using zero_mem _\n      | mul _ _ _ _ h\u2081 h\u2082 => simpa only [smul_add] using add_mem h\u2081 h\u2082\n  case of_mem_closure =>\n    refine closure_le.2 ?_ hx\n    rintro - \u27e8r, -, x, hx, rfl\u27e9\n    exact smul_mem _ _ (subset_span hx)\n\nopen AddSubmonoid in\n/-- A variant of `span_induction` that combines `\u2200 x \u2208 s, p x` and `\u2200 r x, p x \u2192 p (r \u2022 x)`\ninto a single condition `\u2200 r, \u2200 x \u2208 s, p (r \u2022 x)`, which can be easier to verify. -/\n@[elab_as_elim]\ntheorem closure_induction {p : (x : M) \u2192 x \u2208 span R s \u2192 Prop}\n    (zero : p 0 (Submodule.zero_mem _))\n    (add : \u2200 x y hx hy, p x hx \u2192 p y hy \u2192 p (x + y) (Submodule.add_mem _ \u2039_\u203a \u2039_\u203a))\n    (smul_mem : \u2200 (r x) (h : x \u2208 s), p (r \u2022 x) (Submodule.smul_mem _ _ <| subset_span h)) {x}\n    (hx : x \u2208 span R s) : p x hx := by\n  have key {v} : v \u2208 span R s \u2194 v \u2208 closure (@univ R \u2022 s) := by simp [\u2190 span_eq_closure]\n  refine AddSubmonoid.closure_induction (p := fun x hx \u21a6 p x (key.mpr hx))\n    ?_ zero (by simpa only [key] using add) (key.mp hx)\n  rintro - \u27e8r, -, x, hx, rfl\u27e9\n  exact smul_mem r x hx\n\n@[deprecated closure_induction (since := \"2024-10-10\")]\nalias closure_induction' := closure_induction\n\n@[simp]\ntheorem span_span_coe_preimage : span R (((\u2191) : span R s \u2192 M) \u207b\u00b9' s) = \u22a4 :=\n  eq_top_iff.2 fun x _ \u21a6 Subtype.recOn x fun _ hx' \u21a6\n    span_induction (fun _ h \u21a6 subset_span h) (zero_mem _) (fun _ _ _ _ \u21a6 add_mem)\n      (fun _ _ _ \u21a6 smul_mem _ _) hx'\n\n@[simp]\nlemma span_setOf_mem_eq_top :\n    span R {x : span R s | (x : M) \u2208 s} = \u22a4 :=\n  span_span_coe_preimage\n\ntheorem span_nat_eq_addSubmonoid_closure (s : Set M) :\n    (span \u2115 s).toAddSubmonoid = AddSubmonoid.closure s := by\n  refine Eq.symm (AddSubmonoid.closure_eq_of_le subset_span ?_)\n  apply (OrderIso.to_galoisConnection (AddSubmonoid.toNatSubmodule (M := M)).symm).l_le\n     (a := span \u2115 s) (b := AddSubmonoid.closure s)\n  rw [span_le]\n  exact AddSubmonoid.subset_closure\n\n@[simp]\ntheorem span_nat_eq (s : AddSubmonoid M) : (span \u2115 (s : Set M)).toAddSubmonoid = s := by\n  rw [span_nat_eq_addSubmonoid_closure, s.closure_eq]\n\ntheorem span_int_eq_addSubgroup_closure {M : Type*} [AddCommGroup M] (s : Set M) :\n    (span \u2124 s).toAddSubgroup = AddSubgroup.closure s :=\n  Eq.symm <|\n    AddSubgroup.closure_eq_of_le _ subset_span fun _ hx =>\n      span_induction (fun _ hx => AddSubgroup.subset_closure hx) (AddSubgroup.zero_mem _)\n        (fun _ _ _ _ => AddSubgroup.add_mem _) (fun _ _ _ _ => AddSubgroup.zsmul_mem _ \u2039_\u203a _) hx\n\n@[simp]\ntheorem span_int_eq {M : Type*} [AddCommGroup M] (s : AddSubgroup M) :\n    (span \u2124 (s : Set M)).toAddSubgroup = s := by rw [span_int_eq_addSubgroup_closure, s.closure_eq]\n\nsection\n\nvariable (R M)\n\n/-- `span` forms a Galois insertion with the coercion from submodule to set. -/\nprotected def gi : GaloisInsertion (@span R M _ _ _) (\u2191) where\n  choice s _ := span R s\n  gc _ _ := span_le\n  le_l_u _ := subset_span\n  choice_eq _ _ := rfl\n\nend\n\n@[simp]\ntheorem span_empty : span R (\u2205 : Set M) = \u22a5 :=\n  (Submodule.gi R M).gc.l_bot\n\n@[simp]\ntheorem span_univ : span R (univ : Set M) = \u22a4 :=\n  eq_top_iff.2 <| SetLike.le_def.2 <| subset_span\n\ntheorem span_union (s t : Set M) : span R (s \u222a t) = span R s \u2294 span R t :=\n  (Submodule.gi R M).gc.l_sup\n\ntheorem span_iUnion {\u03b9} (s : \u03b9 \u2192 Set M) : span R (\u22c3 i, s i) = \u2a06 i, span R (s i) :=\n  (Submodule.gi R M).gc.l_iSup\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\ntheorem span_iUnion\u2082 {\u03b9} {\u03ba : \u03b9 \u2192 Sort*} (s : \u2200 i, \u03ba i \u2192 Set M) :\n    span R (\u22c3 (i) (j), s i j) = \u2a06 (i) (j), span R (s i j) :=\n  (Submodule.gi R M).gc.l_iSup\u2082\n\ntheorem span_attach_biUnion [DecidableEq M] {\u03b1 : Type*} (s : Finset \u03b1) (f : s \u2192 Finset M) :\n    span R (s.attach.biUnion f : Set M) = \u2a06 x, span R (f x) := by simp [span_iUnion]\n\ntheorem sup_span : p \u2294 span R s = span R (p \u222a s) := by rw [Submodule.span_union, p.span_eq]\n\ntheorem span_sup : span R s \u2294 p = span R (s \u222a p) := by rw [Submodule.span_union, p.span_eq]\n\nnotation:1000\n  /- Note that the character `\u2219` U+2219 used below is different from the scalar multiplication\ncharacter `\u2022` U+2022. -/\nR \" \u2219 \" x => span R (singleton x)\n\ntheorem span_eq_iSup_of_singleton_spans (s : Set M) : span R s = \u2a06 x \u2208 s, R \u2219 x := by\n  simp only [\u2190 span_iUnion, Set.biUnion_of_singleton s]\n\ntheorem span_range_eq_iSup {\u03b9 : Sort*} {v : \u03b9 \u2192 M} : span R (range v) = \u2a06 i, R \u2219 v i := by\n  rw [span_eq_iSup_of_singleton_spans, iSup_range]\n\ntheorem span_smul_le (s : Set M) (r : R) : span R (r \u2022 s) \u2264 span R s := by\n  rw [span_le]\n  rintro _ \u27e8x, hx, rfl\u27e9\n  exact smul_mem (span R s) r (subset_span hx)\n\ntheorem subset_span_trans {U V W : Set M} (hUV : U \u2286 Submodule.span R V)\n    (hVW : V \u2286 Submodule.span R W) : U \u2286 Submodule.span R W :=\n  (Submodule.gi R M).gc.le_u_l_trans hUV hVW\n\n@[simp]\ntheorem coe_iSup_of_directed {\u03b9} [Nonempty \u03b9] (S : \u03b9 \u2192 Submodule R M)\n    (H : Directed (\u00b7 \u2264 \u00b7) S) : ((iSup S : Submodule R M) : Set M) = \u22c3 i, S i :=\n  let s : Submodule R M :=\n    { __ := AddSubmonoid.copy _ _ (AddSubmonoid.coe_iSup_of_directed H).symm\n      smul_mem' := fun r _ hx \u21a6 have \u27e8i, hi\u27e9 := Set.mem_iUnion.mp hx\n        Set.mem_iUnion.mpr \u27e8i, (S i).smul_mem' r hi\u27e9 }\n  have : iSup S = s := le_antisymm\n    (iSup_le fun i \u21a6 le_iSup (fun i \u21a6 (S i : Set M)) i) (Set.iUnion_subset fun _ \u21a6 le_iSup S _)\n  this.symm \u25b8 rfl\n\n@[simp]\ntheorem mem_iSup_of_directed {\u03b9} [Nonempty \u03b9] (S : \u03b9 \u2192 Submodule R M) (H : Directed (\u00b7 \u2264 \u00b7) S) {x} :\n    x \u2208 iSup S \u2194 \u2203 i, x \u2208 S i := by\n  rw [\u2190 SetLike.mem_coe, coe_iSup_of_directed S H, mem_iUnion]\n  rfl\n\ntheorem mem_sSup_of_directed {s : Set (Submodule R M)} {z} (hs : s.Nonempty)\n    (hdir : DirectedOn (\u00b7 \u2264 \u00b7) s) : z \u2208 sSup s \u2194 \u2203 y \u2208 s, z \u2208 y := by\n  have : Nonempty s := hs.to_subtype\n  simp only [sSup_eq_iSup', mem_iSup_of_directed _ hdir.directed_val, SetCoe.exists, Subtype.coe_mk,\n    exists_prop]\n\n@[norm_cast, simp]\ntheorem coe_iSup_of_chain (a : \u2115 \u2192o Submodule R M) : (\u2191(\u2a06 k, a k) : Set M) = \u22c3 k, (a k : Set M) :=\n  coe_iSup_of_directed a a.monotone.directed_le\n\n@[simp]\ntheorem mem_iSup_of_chain (a : \u2115 \u2192o Submodule R M) (m : M) : (m \u2208 \u2a06 k, a k) \u2194 \u2203 k, m \u2208 a k :=\n  mem_iSup_of_directed a a.monotone.directed_le\n\nsection\n\nvariable {p p'}\n\ntheorem mem_sup : x \u2208 p \u2294 p' \u2194 \u2203 y \u2208 p, \u2203 z \u2208 p', y + z = x :=\n  \u27e8fun h => by\n    rw [\u2190 span_eq p, \u2190 span_eq p', \u2190 span_union] at h\n    refine span_induction ?_ ?_ ?_ ?_ h\n    \u00b7 rintro y (h | h)\n      \u00b7 exact \u27e8y, h, 0, by simp, by simp\u27e9\n      \u00b7 exact \u27e80, by simp, y, h, by simp\u27e9\n    \u00b7 exact \u27e80, by simp, 0, by simp\u27e9\n    \u00b7 rintro _ _ - - \u27e8y\u2081, hy\u2081, z\u2081, hz\u2081, rfl\u27e9 \u27e8y\u2082, hy\u2082, z\u2082, hz\u2082, rfl\u27e9\n      exact \u27e8_, add_mem hy\u2081 hy\u2082, _, add_mem hz\u2081 hz\u2082, by\n        rw [add_assoc, add_assoc, \u2190 add_assoc y\u2082, \u2190 add_assoc z\u2081, add_comm y\u2082]\u27e9\n    \u00b7 rintro a - _ \u27e8y, hy, z, hz, rfl\u27e9\n      exact \u27e8_, smul_mem _ a hy, _, smul_mem _ a hz, by simp [smul_add]\u27e9, by\n    rintro \u27e8y, hy, z, hz, rfl\u27e9\n    exact add_mem ((le_sup_left : p \u2264 p \u2294 p') hy) ((le_sup_right : p' \u2264 p \u2294 p') hz)\u27e9\n\ntheorem mem_sup' : x \u2208 p \u2294 p' \u2194 \u2203 (y : p) (z : p'), (y : M) + z = x :=\n  mem_sup.trans <| by simp only [Subtype.exists, exists_prop]\n\nlemma exists_add_eq_of_codisjoint (h : Codisjoint p p') (x : M) :\n    \u2203 y \u2208 p, \u2203 z \u2208 p', y + z = x := by\n  suffices x \u2208 p \u2294 p' by exact Submodule.mem_sup.mp this\n  simpa only [h.eq_top] using Submodule.mem_top\n\nvariable (p p')\n\ntheorem coe_sup : \u2191(p \u2294 p') = (p + p' : Set M) := by\n  ext\n  rw [SetLike.mem_coe, mem_sup, Set.mem_add]\n  simp\n\ntheorem sup_toAddSubmonoid : (p \u2294 p').toAddSubmonoid = p.toAddSubmonoid \u2294 p'.toAddSubmonoid := by\n  ext x\n  rw [mem_toAddSubmonoid, mem_sup, AddSubmonoid.mem_sup]\n  rfl\n\nend\n\ntheorem mem_span_singleton_self (x : M) : x \u2208 R \u2219 x :=\n  subset_span rfl\n\ntheorem nontrivial_span_singleton {x : M} (h : x \u2260 0) : Nontrivial (R \u2219 x) :=\n  \u27e8by\n    use 0, \u27e8x, Submodule.mem_span_singleton_self x\u27e9\n    intro H\n    rw [eq_comm, Submodule.mk_eq_zero] at H\n    exact h H\u27e9\n\ntheorem mem_span_singleton {y : M} : (x \u2208 R \u2219 y) \u2194 \u2203 a : R, a \u2022 y = x :=\n  \u27e8fun h => by\n    refine span_induction ?_ ?_ ?_ ?_ h\n    \u00b7 rintro y (rfl | \u27e8\u27e8_\u27e9\u27e9)\n      exact \u27e81, by simp\u27e9\n    \u00b7 exact \u27e80, by simp\u27e9\n    \u00b7 rintro _ _ - - \u27e8a, rfl\u27e9 \u27e8b, rfl\u27e9\n      exact \u27e8a + b, by simp [add_smul]\u27e9\n    \u00b7 rintro a _ - \u27e8b, rfl\u27e9\n      exact \u27e8a * b, by simp [smul_smul]\u27e9, by\n    rintro \u27e8a, y, rfl\u27e9; exact smul_mem _ _ (subset_span <| by simp)\u27e9\n\ntheorem le_span_singleton_iff {s : Submodule R M} {v\u2080 : M} :\n    (s \u2264 R \u2219 v\u2080) \u2194 \u2200 v \u2208 s, \u2203 r : R, r \u2022 v\u2080 = v := by simp_rw [SetLike.le_def, mem_span_singleton]\n\nvariable (R)\n\ntheorem span_singleton_eq_top_iff (x : M) : (R \u2219 x) = \u22a4 \u2194 \u2200 v, \u2203 r : R, r \u2022 x = v := by\n  rw [eq_top_iff, le_span_singleton_iff]\n  tauto\n\n@[simp]\ntheorem span_zero_singleton : (R \u2219 (0 : M)) = \u22a5 := by\n  ext\n  simp [mem_span_singleton, eq_comm]\n\ntheorem span_singleton_eq_range (y : M) : \u2191(R \u2219 y) = range ((\u00b7 \u2022 y) : R \u2192 M) :=\n  Set.ext fun _ => mem_span_singleton\n\ntheorem span_singleton_smul_le {S} [Monoid S] [SMul S R] [MulAction S M] [IsScalarTower S R M]\n    (r : S) (x : M) : (R \u2219 r \u2022 x) \u2264 R \u2219 x := by\n  rw [span_le, Set.singleton_subset_iff, SetLike.mem_coe]\n  exact smul_of_tower_mem _ _ (mem_span_singleton_self _)\n\ntheorem span_singleton_group_smul_eq {G} [Group G] [SMul G R] [MulAction G M] [IsScalarTower G R M]\n    (g : G) (x : M) : (R \u2219 g \u2022 x) = R \u2219 x := by\n  refine le_antisymm (span_singleton_smul_le R g x) ?_\n  convert span_singleton_smul_le R g\u207b\u00b9 (g \u2022 x)\n  exact (inv_smul_smul g x).symm\n\nvariable {R}\n\ntheorem span_singleton_smul_eq {r : R} (hr : IsUnit r) (x : M) : (R \u2219 r \u2022 x) = R \u2219 x := by\n  lift r to R\u02e3 using hr\n  rw [\u2190 Units.smul_def]\n  exact span_singleton_group_smul_eq R r x\n\ntheorem mem_span_singleton_trans {x y z : M} (hxy : x \u2208 R \u2219 y) (hyz : y \u2208 R \u2219 z) : x \u2208 R \u2219 z := by\n  rw [\u2190 SetLike.mem_coe, \u2190 singleton_subset_iff] at *\n  exact Submodule.subset_span_trans hxy hyz\n\ntheorem span_insert (x) (s : Set M) : span R (insert x s) = (R \u2219 x) \u2294 span R s := by\n  rw [insert_eq, span_union]\n\ntheorem span_insert_eq_span (h : x \u2208 span R s) : span R (insert x s) = span R s :=\n  span_eq_of_le _ (Set.insert_subset_iff.mpr \u27e8h, subset_span\u27e9) (span_mono <| subset_insert _ _)\n\ntheorem span_span : span R (span R s : Set M) = span R s :=\n  span_eq _\n\ntheorem mem_span_insert {y} :\n    x \u2208 span R (insert y s) \u2194 \u2203 a : R, \u2203 z \u2208 span R s, x = a \u2022 y + z := by\n  simp [span_insert, mem_sup, mem_span_singleton, eq_comm (a := x)]\n\ntheorem mem_span_pair {x y z : M} :\n    z \u2208 span R ({x, y} : Set M) \u2194 \u2203 a b : R, a \u2022 x + b \u2022 y = z := by\n  simp_rw [mem_span_insert, mem_span_singleton, exists_exists_eq_and, eq_comm]\n\ntheorem span_eq_bot : span R (s : Set M) = \u22a5 \u2194 \u2200 x \u2208 s, (x : M) = 0 :=\n  eq_bot_iff.trans\n    \u27e8fun H _ h => (mem_bot R).1 <| H <| subset_span h, fun H =>\n      span_le.2 fun x h => (mem_bot R).2 <| H x h\u27e9\n\n@[simp]\ntheorem span_singleton_eq_bot : (R \u2219 x) = \u22a5 \u2194 x = 0 :=\n  span_eq_bot.trans <| by simp\n\n@[simp]\ntheorem span_zero : span R (0 : Set M) = \u22a5 := by rw [\u2190 singleton_zero, span_singleton_eq_bot]\n\n@[simp]\ntheorem span_singleton_le_iff_mem (m : M) (p : Submodule R M) : (R \u2219 m) \u2264 p \u2194 m \u2208 p := by\n  rw [span_le, singleton_subset_iff, SetLike.mem_coe]\n\ntheorem iSup_span {\u03b9 : Sort*} (p : \u03b9 \u2192 Set M) : \u2a06 i, span R (p i) = span R (\u22c3 i, p i) :=\n  le_antisymm (iSup_le fun i => span_mono <| subset_iUnion _ i) <|\n    span_le.mpr <| iUnion_subset fun i _ hm => mem_iSup_of_mem i <| subset_span hm\n\ntheorem iSup_eq_span {\u03b9 : Sort*} (p : \u03b9 \u2192 Submodule R M) : \u2a06 i, p i = span R (\u22c3 i, \u2191(p i)) := by\n  simp_rw [\u2190 iSup_span, span_eq]\n\n/-- A submodule is equal to the supremum of the spans of the submodule's nonzero elements. -/\ntheorem submodule_eq_sSup_le_nonzero_spans (p : Submodule R M) :\n    p = sSup { T : Submodule R M | \u2203 m \u2208 p, m \u2260 0 \u2227 T = span R {m} } := by\n  let S := { T : Submodule R M | \u2203 m \u2208 p, m \u2260 0 \u2227 T = span R {m} }\n  apply le_antisymm\n  \u00b7 intro m hm\n    by_cases h : m = 0\n    \u00b7 rw [h]\n      simp\n    \u00b7 exact @le_sSup _ _ S _ \u27e8m, \u27e8hm, \u27e8h, rfl\u27e9\u27e9\u27e9 m (mem_span_singleton_self m)\n  \u00b7 rw [sSup_le_iff]\n    rintro S \u27e8_, \u27e8_, \u27e8_, rfl\u27e9\u27e9\u27e9\n    rwa [span_singleton_le_iff_mem]\n\ntheorem lt_sup_iff_not_mem {I : Submodule R M} {a : M} : (I < I \u2294 R \u2219 a) \u2194 a \u2209 I := by simp\n\ntheorem mem_iSup {\u03b9 : Sort*} (p : \u03b9 \u2192 Submodule R M) {m : M} :\n    (m \u2208 \u2a06 i, p i) \u2194 \u2200 N, (\u2200 i, p i \u2264 N) \u2192 m \u2208 N := by\n  rw [\u2190 span_singleton_le_iff_mem, le_iSup_iff]\n  simp only [span_singleton_le_iff_mem]\n\ntheorem mem_sSup {s : Set (Submodule R M)} {m : M} :\n    (m \u2208 sSup s) \u2194 \u2200 N, (\u2200 p \u2208 s, p \u2264 N) \u2192 m \u2208 N := by\n  simp_rw [sSup_eq_iSup, Submodule.mem_iSup, iSup_le_iff]\n\nsection\n\n/-- For every element in the span of a set, there exists a finite subset of the set\nsuch that the element is contained in the span of the subset. -/\ntheorem mem_span_finite_of_mem_span {S : Set M} {x : M} (hx : x \u2208 span R S) :\n    \u2203 T : Finset M, \u2191T \u2286 S \u2227 x \u2208 span R (T : Set M) := by\n  classical\n  refine span_induction (fun x hx => ?_) ?_ ?_ ?_ hx\n  \u00b7 refine \u27e8{x}, ?_, ?_\u27e9\n    \u00b7 rwa [Finset.coe_singleton, Set.singleton_subset_iff]\n    \u00b7 rw [Finset.coe_singleton]\n      exact Submodule.mem_span_singleton_self x\n  \u00b7 use \u2205\n    simp\n  \u00b7 rintro x y - - \u27e8X, hX, hxX\u27e9 \u27e8Y, hY, hyY\u27e9\n    refine \u27e8X \u222a Y, ?_, ?_\u27e9\n    \u00b7 rw [Finset.coe_union]\n      exact Set.union_subset hX hY\n    rw [Finset.coe_union, span_union, mem_sup]\n    exact \u27e8x, hxX, y, hyY, rfl\u27e9\n  \u00b7 rintro a x - \u27e8T, hT, h2\u27e9\n    exact \u27e8T, hT, smul_mem _ _ h2\u27e9\n\nend\n\nend AddCommMonoid\n\nsection AddCommGroup\n\nvariable [Ring R] [AddCommGroup M] [Module R M] {\u03b9 : Type*} [DecidableEq \u03b9] {i j : \u03b9}\n\nlemma sup_toAddSubgroup (p p' : Submodule R M) :\n    (p \u2294 p').toAddSubgroup = p.toAddSubgroup \u2294 p'.toAddSubgroup := by\n  ext x\n  rw [mem_toAddSubgroup, mem_sup, AddSubgroup.mem_sup]\n  rfl\n\ntheorem mem_span_insert' {x y} {s : Set M} :\n    x \u2208 span R (insert y s) \u2194 \u2203 a : R, x + a \u2022 y \u2208 span R s := by\n  rw [mem_span_insert]; constructor\n  \u00b7 rintro \u27e8a, z, hz, rfl\u27e9\n    exact \u27e8-a, by simp [hz, add_assoc]\u27e9\n  \u00b7 rintro \u27e8a, h\u27e9\n    exact \u27e8-a, _, h, by simp [add_comm, add_left_comm]\u27e9\n\n", "theoremStatement": "lemma span_range_update_add_smul (hij : i \u2260 j) (v : \u03b9 \u2192 M) (r : R) :\n    span R (Set.range (Function.update v j (v j + r \u2022 v i))) = span R (Set.range v) ", "theoremName": "Submodule.span_range_update_add_smul", "fileCreated": {"commit": "9127890bca642d6f8fee0ab73caa6134ed8890a3", "date": "2024-11-15"}, "theoremCreated": {"commit": "3f703ecb9714a08b92a17f9c3c19ffc32343fede", "date": "2024-12-29"}, "file": "mathlib/Mathlib/LinearAlgebra/Span/Defs.lean", "module": "Mathlib.LinearAlgebra.Span.Defs", "jsonFile": "Mathlib.LinearAlgebra.Span.Defs.jsonl", "positionMetadata": {"lineInFile": 535, "tokenPositionInFile": 20723, "theoremPositionInFile": 77}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 59, "numPremises": 82}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  refine le_antisymm ?_ ?_ <;> simp only [span_le, Set.range_subset_iff, SetLike.mem_coe] <;>\n    intro k <;> obtain rfl | hjk := eq_or_ne j k\n  \u00b7 rw [update_self]\n    exact add_mem (subset_span \u27e8j, rfl\u27e9) <| smul_mem _ _ <| subset_span \u27e8i, rfl\u27e9\n  \u00b7 exact subset_span \u27e8k, (update_of_ne hjk.symm ..).symm\u27e9\n  \u00b7 nth_rw 2 [\u2190 add_sub_cancel_right (v j) (r \u2022 v i)]\n    exact sub_mem (subset_span \u27e8j, update_self ..\u27e9)\n      (smul_mem _ _ (subset_span \u27e8i, update_of_ne hij ..\u27e9))\n  \u00b7 exact subset_span \u27e8k, update_of_ne hjk.symm ..\u27e9", "proofType": "tactic", "proofLengthLines": 9, "proofLengthTokens": 527}}
{"srcContext": "/-\nCopyright (c) 2018 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes, Abhimanyu Pallavi Sudhir, Jean Lo, Calle S\u00f6nne, S\u00e9bastien Gou\u00ebzel,\n  R\u00e9my Degenne\n-/\nimport Mathlib.Analysis.SpecialFunctions.Pow.Continuity\nimport Mathlib.Analysis.SpecialFunctions.Complex.LogDeriv\nimport Mathlib.Analysis.Calculus.FDeriv.Extend\nimport Mathlib.Analysis.Calculus.Deriv.Prod\nimport Mathlib.Analysis.SpecialFunctions.Log.Deriv\nimport Mathlib.Analysis.SpecialFunctions.Trigonometric.Deriv\n\n/-!\n# Derivatives of power function on `\u2102`, `\u211d`, `\u211d\u22650`, and `\u211d\u22650\u221e`\n\nWe also prove differentiability and provide derivatives for the power functions `x ^ y`.\n-/\n\n\nnoncomputable section\n\nopen scoped Real Topology NNReal ENNReal\nopen Filter\n\nnamespace Complex\n\ntheorem hasStrictFDerivAt_cpow {p : \u2102 \u00d7 \u2102} (hp : p.1 \u2208 slitPlane) :\n    HasStrictFDerivAt (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2)\n      ((p.2 * p.1 ^ (p.2 - 1)) \u2022 ContinuousLinearMap.fst \u2102 \u2102 \u2102 +\n        (p.1 ^ p.2 * log p.1) \u2022 ContinuousLinearMap.snd \u2102 \u2102 \u2102) p := by\n  have A : p.1 \u2260 0 := slitPlane_ne_zero hp\n  have : (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2) =\u1da0[\ud835\udcdd p] fun x => exp (log x.1 * x.2) :=\n    ((isOpen_ne.preimage continuous_fst).eventually_mem A).mono fun p hp =>\n      cpow_def_of_ne_zero hp _\n  rw [cpow_sub _ _ A, cpow_one, mul_div_left_comm, mul_smul, mul_smul]\n  refine HasStrictFDerivAt.congr_of_eventuallyEq ?_ this.symm\n  simpa only [cpow_def_of_ne_zero A, div_eq_mul_inv, mul_smul, add_comm, smul_add] using\n    ((hasStrictFDerivAt_fst.clog hp).mul hasStrictFDerivAt_snd).cexp\n\ntheorem hasStrictFDerivAt_cpow' {x y : \u2102} (hp : x \u2208 slitPlane) :\n    HasStrictFDerivAt (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2)\n      ((y * x ^ (y - 1)) \u2022 ContinuousLinearMap.fst \u2102 \u2102 \u2102 +\n        (x ^ y * log x) \u2022 ContinuousLinearMap.snd \u2102 \u2102 \u2102) (x, y) :=\n  @hasStrictFDerivAt_cpow (x, y) hp\n\ntheorem hasStrictDerivAt_const_cpow {x y : \u2102} (h : x \u2260 0 \u2228 y \u2260 0) :\n    HasStrictDerivAt (fun y => x ^ y) (x ^ y * log x) y := by\n  rcases em (x = 0) with (rfl | hx)\n  \u00b7 replace h := h.neg_resolve_left rfl\n    rw [log_zero, mul_zero]\n    refine (hasStrictDerivAt_const y 0).congr_of_eventuallyEq ?_\n    exact (isOpen_ne.eventually_mem h).mono fun y hy => (zero_cpow hy).symm\n  \u00b7 simpa only [cpow_def_of_ne_zero hx, mul_one] using\n      ((hasStrictDerivAt_id y).const_mul (log x)).cexp\n\ntheorem hasFDerivAt_cpow {p : \u2102 \u00d7 \u2102} (hp : p.1 \u2208 slitPlane) :\n    HasFDerivAt (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2)\n      ((p.2 * p.1 ^ (p.2 - 1)) \u2022 ContinuousLinearMap.fst \u2102 \u2102 \u2102 +\n        (p.1 ^ p.2 * log p.1) \u2022 ContinuousLinearMap.snd \u2102 \u2102 \u2102) p :=\n  (hasStrictFDerivAt_cpow hp).hasFDerivAt\n\nend Complex\n\nsection fderiv\n\nopen Complex\n\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f g : E \u2192 \u2102} {f' g' : E \u2192L[\u2102] \u2102}\n  {x : E} {s : Set E} {c : \u2102}\n\ntheorem HasStrictFDerivAt.cpow (hf : HasStrictFDerivAt f f' x) (hg : HasStrictFDerivAt g g' x)\n    (h0 : f x \u2208 slitPlane) : HasStrictFDerivAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) \u2022 f' + (f x ^ g x * Complex.log (f x)) \u2022 g') x := by\n  convert (@hasStrictFDerivAt_cpow ((fun x => (f x, g x)) x) h0).comp x (hf.prod hg)\n\ntheorem HasStrictFDerivAt.const_cpow (hf : HasStrictFDerivAt f f' x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasStrictFDerivAt (fun x => c ^ f x) ((c ^ f x * Complex.log c) \u2022 f') x :=\n  (hasStrictDerivAt_const_cpow h0).comp_hasStrictFDerivAt x hf\n\ntheorem HasFDerivAt.cpow (hf : HasFDerivAt f f' x) (hg : HasFDerivAt g g' x)\n    (h0 : f x \u2208 slitPlane) : HasFDerivAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) \u2022 f' + (f x ^ g x * Complex.log (f x)) \u2022 g') x := by\n  convert (@Complex.hasFDerivAt_cpow ((fun x => (f x, g x)) x) h0).comp x (hf.prod hg)\n\ntheorem HasFDerivAt.const_cpow (hf : HasFDerivAt f f' x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasFDerivAt (fun x => c ^ f x) ((c ^ f x * Complex.log c) \u2022 f') x :=\n  (hasStrictDerivAt_const_cpow h0).hasDerivAt.comp_hasFDerivAt x hf\n\ntheorem HasFDerivWithinAt.cpow (hf : HasFDerivWithinAt f f' s x) (hg : HasFDerivWithinAt g g' s x)\n    (h0 : f x \u2208 slitPlane) : HasFDerivWithinAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) \u2022 f' + (f x ^ g x * Complex.log (f x)) \u2022 g') s x := by\n  convert\n    (@Complex.hasFDerivAt_cpow ((fun x => (f x, g x)) x) h0).comp_hasFDerivWithinAt x (hf.prod hg)\n\ntheorem HasFDerivWithinAt.const_cpow (hf : HasFDerivWithinAt f f' s x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasFDerivWithinAt (fun x => c ^ f x) ((c ^ f x * Complex.log c) \u2022 f') s x :=\n  (hasStrictDerivAt_const_cpow h0).hasDerivAt.comp_hasFDerivWithinAt x hf\n\ntheorem DifferentiableAt.cpow (hf : DifferentiableAt \u2102 f x) (hg : DifferentiableAt \u2102 g x)\n    (h0 : f x \u2208 slitPlane) : DifferentiableAt \u2102 (fun x => f x ^ g x) x :=\n  (hf.hasFDerivAt.cpow hg.hasFDerivAt h0).differentiableAt\n\ntheorem DifferentiableAt.const_cpow (hf : DifferentiableAt \u2102 f x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    DifferentiableAt \u2102 (fun x => c ^ f x) x :=\n  (hf.hasFDerivAt.const_cpow h0).differentiableAt\n\ntheorem DifferentiableAt.cpow_const (hf : DifferentiableAt \u2102 f x) (h0 : f x \u2208 slitPlane) :\n    DifferentiableAt \u2102 (fun x => f x ^ c) x :=\n  hf.cpow (differentiableAt_const c) h0\n\ntheorem DifferentiableWithinAt.cpow (hf : DifferentiableWithinAt \u2102 f s x)\n    (hg : DifferentiableWithinAt \u2102 g s x) (h0 : f x \u2208 slitPlane) :\n    DifferentiableWithinAt \u2102 (fun x => f x ^ g x) s x :=\n  (hf.hasFDerivWithinAt.cpow hg.hasFDerivWithinAt h0).differentiableWithinAt\n\ntheorem DifferentiableWithinAt.const_cpow (hf : DifferentiableWithinAt \u2102 f s x)\n    (h0 : c \u2260 0 \u2228 f x \u2260 0) : DifferentiableWithinAt \u2102 (fun x => c ^ f x) s x :=\n  (hf.hasFDerivWithinAt.const_cpow h0).differentiableWithinAt\n\ntheorem DifferentiableWithinAt.cpow_const (hf : DifferentiableWithinAt \u2102 f s x)\n    (h0 : f x \u2208 slitPlane) :\n    DifferentiableWithinAt \u2102 (fun x => f x ^ c) s x :=\n  hf.cpow (differentiableWithinAt_const c) h0\n\ntheorem DifferentiableOn.cpow (hf : DifferentiableOn \u2102 f s) (hg : DifferentiableOn \u2102 g s)\n    (h0 : Set.MapsTo f s slitPlane) : DifferentiableOn \u2102 (fun x \u21a6 f x ^ g x) s :=\n  fun x hx \u21a6 (hf x hx).cpow (hg x hx) (h0 hx)\n\ntheorem DifferentiableOn.const_cpow (hf : DifferentiableOn \u2102 f s)\n    (h0 : c \u2260 0 \u2228 \u2200 x \u2208 s, f x \u2260 0) : DifferentiableOn \u2102 (fun x \u21a6 c ^ f x) s :=\n  fun x hx \u21a6 (hf x hx).const_cpow (h0.imp_right fun h \u21a6 h x hx)\n\ntheorem DifferentiableOn.cpow_const (hf : DifferentiableOn \u2102 f s)\n    (h0 : \u2200 x \u2208 s, f x \u2208 slitPlane) :\n    DifferentiableOn \u2102 (fun x => f x ^ c) s :=\n  hf.cpow (differentiableOn_const c) h0\n\ntheorem Differentiable.cpow (hf : Differentiable \u2102 f) (hg : Differentiable \u2102 g)\n    (h0 : \u2200 x, f x \u2208 slitPlane) : Differentiable \u2102 (fun x \u21a6 f x ^ g x) :=\n  fun x \u21a6 (hf x).cpow (hg x) (h0 x)\n\ntheorem Differentiable.const_cpow (hf : Differentiable \u2102 f)\n    (h0 : c \u2260 0 \u2228 \u2200 x, f x \u2260 0) : Differentiable \u2102 (fun x \u21a6 c ^ f x) :=\n  fun x \u21a6 (hf x).const_cpow (h0.imp_right fun h \u21a6 h x)\n\n@[fun_prop]\nlemma differentiable_const_cpow_of_neZero (z : \u2102) [NeZero z] :\n    Differentiable \u2102 fun s : \u2102 \u21a6 z ^ s :=\n  differentiable_id.const_cpow (.inl <| NeZero.ne z)\n\n@[fun_prop]\nlemma differentiableAt_const_cpow_of_neZero (z : \u2102) [NeZero z] (t : \u2102) :\n    DifferentiableAt \u2102 (fun s : \u2102 \u21a6 z ^ s) t :=\n  differentiableAt_id.const_cpow (.inl <| NeZero.ne z)\n\nend fderiv\n\nsection deriv\n\nopen Complex\n\nvariable {f g : \u2102 \u2192 \u2102} {s : Set \u2102} {f' g' x c : \u2102}\n\n/-- A private lemma that rewrites the output of lemmas like `HasFDerivAt.cpow` to the form\nexpected by lemmas like `HasDerivAt.cpow`. -/\nprivate theorem aux : ((g x * f x ^ (g x - 1)) \u2022 (1 : \u2102 \u2192L[\u2102] \u2102).smulRight f' +\n    (f x ^ g x * log (f x)) \u2022 (1 : \u2102 \u2192L[\u2102] \u2102).smulRight g') 1 =\n      g x * f x ^ (g x - 1) * f' + f x ^ g x * log (f x) * g' := by\n  simp only [Algebra.id.smul_eq_mul, one_mul, ContinuousLinearMap.one_apply,\n    ContinuousLinearMap.smulRight_apply, ContinuousLinearMap.add_apply, Pi.smul_apply,\n    ContinuousLinearMap.coe_smul']\n\nnonrec theorem HasStrictDerivAt.cpow (hf : HasStrictDerivAt f f' x) (hg : HasStrictDerivAt g g' x)\n    (h0 : f x \u2208 slitPlane) : HasStrictDerivAt (fun x => f x ^ g x)\n      (g x * f x ^ (g x - 1) * f' + f x ^ g x * Complex.log (f x) * g') x := by\n  simpa using (hf.cpow hg h0).hasStrictDerivAt\n\ntheorem HasStrictDerivAt.const_cpow (hf : HasStrictDerivAt f f' x) (h : c \u2260 0 \u2228 f x \u2260 0) :\n    HasStrictDerivAt (fun x => c ^ f x) (c ^ f x * Complex.log c * f') x :=\n  (hasStrictDerivAt_const_cpow h).comp x hf\n\ntheorem Complex.hasStrictDerivAt_cpow_const (h : x \u2208 slitPlane) :\n    HasStrictDerivAt (fun z : \u2102 => z ^ c) (c * x ^ (c - 1)) x := by\n  simpa only [mul_zero, add_zero, mul_one] using\n    (hasStrictDerivAt_id x).cpow (hasStrictDerivAt_const x c) h\n\ntheorem HasStrictDerivAt.cpow_const (hf : HasStrictDerivAt f f' x)\n    (h0 : f x \u2208 slitPlane) :\n    HasStrictDerivAt (fun x => f x ^ c) (c * f x ^ (c - 1) * f') x :=\n  (Complex.hasStrictDerivAt_cpow_const h0).comp x hf\n\ntheorem HasDerivAt.cpow (hf : HasDerivAt f f' x) (hg : HasDerivAt g g' x)\n    (h0 : f x \u2208 slitPlane) : HasDerivAt (fun x => f x ^ g x)\n      (g x * f x ^ (g x - 1) * f' + f x ^ g x * Complex.log (f x) * g') x := by\n  simpa only [aux] using (hf.hasFDerivAt.cpow hg h0).hasDerivAt\n\ntheorem HasDerivAt.const_cpow (hf : HasDerivAt f f' x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasDerivAt (fun x => c ^ f x) (c ^ f x * Complex.log c * f') x :=\n  (hasStrictDerivAt_const_cpow h0).hasDerivAt.comp x hf\n\ntheorem HasDerivAt.cpow_const (hf : HasDerivAt f f' x) (h0 : f x \u2208 slitPlane) :\n    HasDerivAt (fun x => f x ^ c) (c * f x ^ (c - 1) * f') x :=\n  (Complex.hasStrictDerivAt_cpow_const h0).hasDerivAt.comp x hf\n\ntheorem HasDerivWithinAt.cpow (hf : HasDerivWithinAt f f' s x) (hg : HasDerivWithinAt g g' s x)\n    (h0 : f x \u2208 slitPlane) : HasDerivWithinAt (fun x => f x ^ g x)\n      (g x * f x ^ (g x - 1) * f' + f x ^ g x * Complex.log (f x) * g') s x := by\n  simpa only [aux] using (hf.hasFDerivWithinAt.cpow hg h0).hasDerivWithinAt\n\ntheorem HasDerivWithinAt.const_cpow (hf : HasDerivWithinAt f f' s x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasDerivWithinAt (fun x => c ^ f x) (c ^ f x * Complex.log c * f') s x :=\n  (hasStrictDerivAt_const_cpow h0).hasDerivAt.comp_hasDerivWithinAt x hf\n\ntheorem HasDerivWithinAt.cpow_const (hf : HasDerivWithinAt f f' s x)\n    (h0 : f x \u2208 slitPlane) :\n    HasDerivWithinAt (fun x => f x ^ c) (c * f x ^ (c - 1) * f') s x :=\n  (Complex.hasStrictDerivAt_cpow_const h0).hasDerivAt.comp_hasDerivWithinAt x hf\n\n/-- Although `fun x => x ^ r` for fixed `r` is *not* complex-differentiable along the negative real\nline, it is still real-differentiable, and the derivative is what one would formally expect.\nSee `hasDerivAt_ofReal_cpow_const` for an alternate formulation. -/\ntheorem hasDerivAt_ofReal_cpow_const' {x : \u211d} (hx : x \u2260 0) {r : \u2102} (hr : r \u2260 -1) :\n    HasDerivAt (fun y : \u211d => (y : \u2102) ^ (r + 1) / (r + 1)) (x ^ r) x := by\n  rw [Ne, \u2190 add_eq_zero_iff_eq_neg, \u2190 Ne] at hr\n  rcases lt_or_gt_of_ne hx.symm with (hx | hx)\n  \u00b7 -- easy case : `0 < x`\n    -- Porting note: proof used to be\n    -- convert (((hasDerivAt_id (x : \u2102)).cpow_const _).div_const (r + 1)).comp_ofReal using 1\n    -- \u00b7 rw [add_sub_cancel, id.def, mul_one, mul_comm, mul_div_cancel _ hr]\n    -- \u00b7 rw [id.def, ofReal_re]; exact Or.inl hx\n    apply HasDerivAt.comp_ofReal (e := fun y => (y : \u2102) ^ (r + 1) / (r + 1))\n    convert HasDerivAt.div_const (\ud835\udd5c := \u2102) ?_ (r + 1) using 1\n    \u00b7 exact (mul_div_cancel_right\u2080 _ hr).symm\n    \u00b7 convert HasDerivAt.cpow_const ?_ ?_ using 1\n      \u00b7 rw [add_sub_cancel_right, mul_comm]; exact (mul_one _).symm\n      \u00b7 exact hasDerivAt_id (x : \u2102)\n      \u00b7 simp [hx]\n  \u00b7 -- harder case : `x < 0`\n    have : \u2200\u1da0 y : \u211d in \ud835\udcdd x,\n        (y : \u2102) ^ (r + 1) / (r + 1) = (-y : \u2102) ^ (r + 1) * exp (\u03c0 * I * (r + 1)) / (r + 1) := by\n      refine Filter.eventually_of_mem (Iio_mem_nhds hx) fun y hy => ?_\n      rw [ofReal_cpow_of_nonpos (le_of_lt hy)]\n    refine HasDerivAt.congr_of_eventuallyEq ?_ this\n    rw [ofReal_cpow_of_nonpos (le_of_lt hx)]\n    suffices HasDerivAt (fun y : \u211d => (-\u2191y) ^ (r + 1) * exp (\u2191\u03c0 * I * (r + 1)))\n        ((r + 1) * (-\u2191x) ^ r * exp (\u2191\u03c0 * I * r)) x by\n      convert this.div_const (r + 1) using 1\n      conv_rhs => rw [mul_assoc, mul_comm, mul_div_cancel_right\u2080 _ hr]\n    rw [mul_add ((\u03c0 : \u2102) * _), mul_one, exp_add, exp_pi_mul_I, mul_comm (_ : \u2102) (-1 : \u2102),\n      neg_one_mul]\n    simp_rw [mul_neg, \u2190 neg_mul, \u2190 ofReal_neg]\n    suffices HasDerivAt (fun y : \u211d => (\u2191(-y) : \u2102) ^ (r + 1)) (-(r + 1) * \u2191(-x) ^ r) x by\n      convert this.neg.mul_const _ using 1; ring\n    suffices HasDerivAt (fun y : \u211d => (y : \u2102) ^ (r + 1)) ((r + 1) * \u2191(-x) ^ r) (-x) by\n      convert @HasDerivAt.scomp \u211d _ \u2102 _ _ x \u211d _ _ _ _ _ _ _ _ this (hasDerivAt_neg x) using 1\n      rw [real_smul, ofReal_neg 1, ofReal_one]; ring\n    suffices HasDerivAt (fun y : \u2102 => y ^ (r + 1)) ((r + 1) * \u2191(-x) ^ r) \u2191(-x) by\n      exact this.comp_ofReal\n    conv in \u2191_ ^ _ => rw [(by ring : r = r + 1 - 1)]\n    convert HasDerivAt.cpow_const ?_ ?_ using 1\n    \u00b7 rw [add_sub_cancel_right, add_sub_cancel_right]; exact (mul_one _).symm\n    \u00b7 exact hasDerivAt_id ((-x : \u211d) : \u2102)\n    \u00b7 simp [hx]\n\n@[deprecated (since := \"2024-12-15\")] alias hasDerivAt_ofReal_cpow := hasDerivAt_ofReal_cpow_const'\n\n/-- An alternate formulation of `hasDerivAt_ofReal_cpow_const'`. -/\ntheorem hasDerivAt_ofReal_cpow_const {x : \u211d} (hx : x \u2260 0) {r : \u2102} (hr : r \u2260 0) :\n    HasDerivAt (fun y : \u211d => (y : \u2102) ^ r) (r * x ^ (r - 1)) x := by\n  have := HasDerivAt.const_mul r <| hasDerivAt_ofReal_cpow_const' hx\n    (by rwa [ne_eq, sub_eq_neg_self])\n  simpa [sub_add_cancel, mul_div_cancel\u2080 _ hr] using this\n\n/-- A version of `DifferentiableAt.cpow_const` for a real function. -/\ntheorem DifferentiableAt.ofReal_cpow_const {f : \u211d \u2192 \u211d} {x : \u211d} (hf : DifferentiableAt \u211d f x)\n    (h0 : f x \u2260 0) (h1 : c \u2260 0) :\n    DifferentiableAt \u211d (fun (y : \u211d) => (f y : \u2102) ^ c) x :=\n  (hasDerivAt_ofReal_cpow_const h0 h1).differentiableAt.comp x hf\n\ntheorem Complex.deriv_cpow_const (hx : x \u2208 Complex.slitPlane) :\n    deriv (fun (x : \u2102) \u21a6 x ^ c) x = c * x ^ (c - 1) :=\n  (hasStrictDerivAt_cpow_const hx).hasDerivAt.deriv\n\n", "theoremStatement": "/-- A version of `Complex.deriv_cpow_const` for a real variable. -/\ntheorem Complex.deriv_ofReal_cpow_const {x : \u211d} (hx : x \u2260 0) (hc : c \u2260 0) :\n    deriv (fun x : \u211d \u21a6 (x : \u2102) ^ c) x = c * x ^ (c - 1) ", "theoremName": "Complex.deriv_ofReal_cpow_const", "fileCreated": {"commit": "a9359cb30d5d2eb08c3c66959305c82fe45fab66", "date": "2023-06-06"}, "theoremCreated": {"commit": "006641492734e60b369ac830260c46c2dcdb7342", "date": "2025-01-20"}, "file": "mathlib/Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean", "module": "Mathlib.Analysis.SpecialFunctions.Pow.Deriv", "jsonFile": "Mathlib.Analysis.SpecialFunctions.Pow.Deriv.jsonl", "positionMetadata": {"lineInFile": 285, "tokenPositionInFile": 13946, "theoremPositionInFile": 38}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 32, "numPremises": 42}, "proofMetadata": {"hasProof": true, "proof": ":=\n  (hasDerivAt_ofReal_cpow_const hx hc).deriv", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 47}}
{"srcContext": "/-\nCopyright (c) 2020 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kevin Buzzard, Johan Commelin, Patrick Massot\n-/\nimport Mathlib.Algebra.Order.Hom.Monoid\nimport Mathlib.Algebra.Order.Ring.Basic\nimport Mathlib.RingTheory.Ideal.Maps\nimport Mathlib.Tactic.TFAE\n\n/-!\n\n# The basics of valuation theory.\n\nThe basic theory of valuations (non-archimedean norms) on a commutative ring,\nfollowing T. Wedhorn's unpublished notes \u201cAdic Spaces\u201d ([wedhorn_adic]).\n\nThe definition of a valuation we use here is Definition 1.22 of [wedhorn_adic].\nA valuation on a ring `R` is a monoid homomorphism `v` to a linearly ordered\ncommutative monoid with zero, that in addition satisfies the following two axioms:\n * `v 0 = 0`\n * `\u2200 x y, v (x + y) \u2264 max (v x) (v y)`\n\n`Valuation R \u0393\u2080`is the type of valuations `R \u2192 \u0393\u2080`, with a coercion to the underlying\nfunction. If `v` is a valuation from `R` to `\u0393\u2080` then the induced group\nhomomorphism `Units(R) \u2192 \u0393\u2080` is called `unit_map v`.\n\nThe equivalence \"relation\" `IsEquiv v\u2081 v\u2082 : Prop` defined in 1.27 of [wedhorn_adic] is not strictly\nspeaking a relation, because `v\u2081 : Valuation R \u0393\u2081` and `v\u2082 : Valuation R \u0393\u2082` might\nnot have the same type. This corresponds in ZFC to the set-theoretic difficulty\nthat the class of all valuations (as `\u0393\u2080` varies) on a ring `R` is not a set.\nThe \"relation\" is however reflexive, symmetric and transitive in the obvious\nsense. Note that we use 1.27(iii) of [wedhorn_adic] as the definition of equivalence.\n\n## Main definitions\n\n* `Valuation R \u0393\u2080`, the type of valuations on `R` with values in `\u0393\u2080`\n* `Valuation.IsEquiv`, the heterogeneous equivalence relation on valuations\n* `Valuation.supp`, the support of a valuation\n\n* `AddValuation R \u0393\u2080`, the type of additive valuations on `R` with values in a\n  linearly ordered additive commutative group with a top element, `\u0393\u2080`.\n\n## Implementation Details\n\n`AddValuation R \u0393\u2080` is implemented as `Valuation R (Multiplicative \u0393\u2080)\u1d52\u1d48`.\n\n## Notation\n\nIn the `DiscreteValuation` locale:\n\n * `\u2115\u2098\u2080` is a shorthand for `WithZero (Multiplicative \u2115)`\n * `\u2124\u2098\u2080` is a shorthand for `WithZero (Multiplicative \u2124)`\n\n## TODO\n\nIf ever someone extends `Valuation`, we should fully comply to the `DFunLike` by migrating the\nboilerplate lemmas to `ValuationClass`.\n-/\n\nopen Function Ideal\n\nnoncomputable section\n\nvariable {K F R : Type*} [DivisionRing K]\n\nsection\n\nvariable (F R) (\u0393\u2080 : Type*) [LinearOrderedCommMonoidWithZero \u0393\u2080] [Ring R]\n\n/-- The type of `\u0393\u2080`-valued valuations on `R`.\n\nWhen you extend this structure, make sure to extend `ValuationClass`. -/\nstructure Valuation extends R \u2192*\u2080 \u0393\u2080 where\n  /-- The valuation of a a sum is less that the sum of the valuations -/\n  map_add_le_max' : \u2200 x y, toFun (x + y) \u2264 max (toFun x) (toFun y)\n\n/-- `ValuationClass F \u03b1 \u03b2` states that `F` is a type of valuations.\n\nYou should also extend this typeclass when you extend `Valuation`. -/\nclass ValuationClass (F) (R \u0393\u2080 : outParam Type*) [LinearOrderedCommMonoidWithZero \u0393\u2080] [Ring R]\n  [FunLike F R \u0393\u2080]\n  extends MonoidWithZeroHomClass F R \u0393\u2080 : Prop where\n  /-- The valuation of a a sum is less that the sum of the valuations -/\n  map_add_le_max (f : F) (x y : R) : f (x + y) \u2264 max (f x) (f y)\n\nexport ValuationClass (map_add_le_max)\n\ninstance [FunLike F R \u0393\u2080] [ValuationClass F R \u0393\u2080] : CoeTC F (Valuation R \u0393\u2080) :=\n  \u27e8fun f =>\n    { toFun := f\n      map_one' := map_one f\n      map_zero' := map_zero f\n      map_mul' := map_mul f\n      map_add_le_max' := map_add_le_max f }\u27e9\n\nend\n\nnamespace Valuation\n\nvariable {\u0393\u2080 : Type*}\nvariable {\u0393'\u2080 : Type*}\nvariable {\u0393''\u2080 : Type*} [LinearOrderedCommMonoidWithZero \u0393''\u2080]\n\nsection Basic\n\nvariable [Ring R]\n\nsection Monoid\n\nvariable [LinearOrderedCommMonoidWithZero \u0393\u2080] [LinearOrderedCommMonoidWithZero \u0393'\u2080]\n\ninstance : FunLike (Valuation R \u0393\u2080) R \u0393\u2080 where\n  coe f := f.toFun\n  coe_injective' f g h := by\n    obtain \u27e8\u27e8\u27e8_,_\u27e9, _\u27e9, _\u27e9 := f\n    congr\n\ninstance : ValuationClass (Valuation R \u0393\u2080) R \u0393\u2080 where\n  map_mul f := f.map_mul'\n  map_one f := f.map_one'\n  map_zero f := f.map_zero'\n  map_add_le_max f := f.map_add_le_max'\n\n@[simp]\ntheorem coe_mk (f : R \u2192*\u2080 \u0393\u2080) (h) : \u21d1(Valuation.mk f h) = f := rfl\n\ntheorem toFun_eq_coe (v : Valuation R \u0393\u2080) : v.toFun = v := rfl\n\n@[simp]\ntheorem toMonoidWithZeroHom_coe_eq_coe (v : Valuation R \u0393\u2080) :\n    (v.toMonoidWithZeroHom : R \u2192 \u0393\u2080) = v := rfl\n\n@[ext]\ntheorem ext {v\u2081 v\u2082 : Valuation R \u0393\u2080} (h : \u2200 r, v\u2081 r = v\u2082 r) : v\u2081 = v\u2082 :=\n  DFunLike.ext _ _ h\n\nvariable (v : Valuation R \u0393\u2080)\n\n@[simp, norm_cast]\ntheorem coe_coe : \u21d1(v : R \u2192*\u2080 \u0393\u2080) = v := rfl\n\ntheorem map_zero : v 0 = 0 :=\n  v.map_zero'\n\ntheorem map_one : v 1 = 1 :=\n  v.map_one'\n\ntheorem map_mul : \u2200 x y, v (x * y) = v x * v y :=\n  v.map_mul'\n\n-- Porting note: LHS side simplified so created map_add'\ntheorem map_add : \u2200 x y, v (x + y) \u2264 max (v x) (v y) :=\n  v.map_add_le_max'\n\n@[simp]\ntheorem map_add' : \u2200 x y, v (x + y) \u2264 v x \u2228 v (x + y) \u2264 v y := by\n  intro x y\n  rw [\u2190 le_max_iff, \u2190 ge_iff_le]\n  apply map_add\n\ntheorem map_add_le {x y g} (hx : v x \u2264 g) (hy : v y \u2264 g) : v (x + y) \u2264 g :=\n  le_trans (v.map_add x y) <| max_le hx hy\n\ntheorem map_add_lt {x y g} (hx : v x < g) (hy : v y < g) : v (x + y) < g :=\n  lt_of_le_of_lt (v.map_add x y) <| max_lt hx hy\n\ntheorem map_sum_le {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hf : \u2200 i \u2208 s, v (f i) \u2264 g) :\n    v (\u2211 i \u2208 s, f i) \u2264 g := by\n  classical\n  refine\n    Finset.induction_on s (fun _ => v.map_zero \u25b8 zero_le')\n      (fun a s has ih hf => ?_) hf\n  rw [Finset.forall_mem_insert] at hf; rw [Finset.sum_insert has]\n  exact v.map_add_le hf.1 (ih hf.2)\n\ntheorem map_sum_lt {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hg : g \u2260 0)\n    (hf : \u2200 i \u2208 s, v (f i) < g) : v (\u2211 i \u2208 s, f i) < g := by\n  classical\n  refine\n    Finset.induction_on s (fun _ => v.map_zero \u25b8 (zero_lt_iff.2 hg))\n      (fun a s has ih hf => ?_) hf\n  rw [Finset.forall_mem_insert] at hf; rw [Finset.sum_insert has]\n  exact v.map_add_lt hf.1 (ih hf.2)\n\ntheorem map_sum_lt' {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hg : 0 < g)\n    (hf : \u2200 i \u2208 s, v (f i) < g) : v (\u2211 i \u2208 s, f i) < g :=\n  v.map_sum_lt (ne_of_gt hg) hf\n\ntheorem map_pow : \u2200 (x) (n : \u2115), v (x ^ n) = v x ^ n :=\n  v.toMonoidWithZeroHom.toMonoidHom.map_pow\n\n-- The following definition is not an instance, because we have more than one `v` on a given `R`.\n-- In addition, type class inference would not be able to infer `v`.\n/-- A valuation gives a preorder on the underlying ring. -/\ndef toPreorder : Preorder R :=\n  Preorder.lift v\n\n/-- If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. -/\ntheorem zero_iff [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) {x : K} : v x = 0 \u2194 x = 0 :=\n  map_eq_zero v\n\ntheorem ne_zero_iff [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) {x : K} : v x \u2260 0 \u2194 x \u2260 0 :=\n  map_ne_zero v\n\nlemma pos_iff [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) {x : K} : 0 < v x \u2194 x \u2260 0 := by\n  rw [zero_lt_iff, ne_zero_iff]\n\ntheorem unit_map_eq (u : R\u02e3) : (Units.map (v : R \u2192* \u0393\u2080) u : \u0393\u2080) = v u :=\n  rfl\n\ntheorem ne_zero_of_unit [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) (x : K\u02e3) : v x \u2260 (0 : \u0393\u2080) := by\n  simp only [ne_eq, Valuation.zero_iff, Units.ne_zero x, not_false_iff]\n\ntheorem ne_zero_of_isUnit [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) (x : K) (hx : IsUnit x) :\n    v x \u2260 (0 : \u0393\u2080) := by\n  simpa [hx.choose_spec] using ne_zero_of_unit v hx.choose\n\n/-- A ring homomorphism `S \u2192 R` induces a map `Valuation R \u0393\u2080 \u2192 Valuation S \u0393\u2080`. -/\ndef comap {S : Type*} [Ring S] (f : S \u2192+* R) (v : Valuation R \u0393\u2080) : Valuation S \u0393\u2080 :=\n  { v.toMonoidWithZeroHom.comp f.toMonoidWithZeroHom with\n    toFun := v \u2218 f\n    map_add_le_max' := fun x y => by simp only [comp_apply, map_add, f.map_add] }\n\n@[simp]\ntheorem comap_apply {S : Type*} [Ring S] (f : S \u2192+* R) (v : Valuation R \u0393\u2080) (s : S) :\n    v.comap f s = v (f s) := rfl\n\n@[simp]\ntheorem comap_id : v.comap (RingHom.id R) = v :=\n  ext fun _r => rfl\n\ntheorem comap_comp {S\u2081 : Type*} {S\u2082 : Type*} [Ring S\u2081] [Ring S\u2082] (f : S\u2081 \u2192+* S\u2082) (g : S\u2082 \u2192+* R) :\n    v.comap (g.comp f) = (v.comap g).comap f :=\n  ext fun _r => rfl\n\n/-- A `\u2264`-preserving group homomorphism `\u0393\u2080 \u2192 \u0393'\u2080` induces a map `Valuation R \u0393\u2080 \u2192 Valuation R \u0393'\u2080`.\n-/\ndef map (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080) (hf : Monotone f) (v : Valuation R \u0393\u2080) : Valuation R \u0393'\u2080 :=\n  { MonoidWithZeroHom.comp f v.toMonoidWithZeroHom with\n    toFun := f \u2218 v\n    map_add_le_max' := fun r s =>\n      calc\n        f (v (r + s)) \u2264 f (max (v r) (v s)) := hf (v.map_add r s)\n        _ = max (f (v r)) (f (v s)) := hf.map_max\n         }\n\n@[simp]\nlemma map_apply (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080) (hf : Monotone f) (v : Valuation R \u0393\u2080) (r : R) :\n    v.map f hf r = f (v r) := rfl\n\n/-- Two valuations on `R` are defined to be equivalent if they induce the same preorder on `R`. -/\ndef IsEquiv (v\u2081 : Valuation R \u0393\u2080) (v\u2082 : Valuation R \u0393'\u2080) : Prop :=\n  \u2200 r s, v\u2081 r \u2264 v\u2081 s \u2194 v\u2082 r \u2264 v\u2082 s\n\n@[simp]\ntheorem map_neg (x : R) : v (-x) = v x :=\n  v.toMonoidWithZeroHom.toMonoidHom.map_neg x\n\ntheorem map_sub_swap (x y : R) : v (x - y) = v (y - x) :=\n  v.toMonoidWithZeroHom.toMonoidHom.map_sub_swap x y\n\ntheorem map_sub (x y : R) : v (x - y) \u2264 max (v x) (v y) :=\n  calc\n    v (x - y) = v (x + -y) := by rw [sub_eq_add_neg]\n    _ \u2264 max (v x) (v <| -y) := v.map_add _ _\n    _ = max (v x) (v y) := by rw [map_neg]\n\ntheorem map_sub_le {x y g} (hx : v x \u2264 g) (hy : v y \u2264 g) : v (x - y) \u2264 g := by\n  rw [sub_eq_add_neg]\n  exact v.map_add_le hx (le_trans (le_of_eq (v.map_neg y)) hy)\n\nvariable {x y : R}\n\ntheorem map_add_of_distinct_val (h : v x \u2260 v y) : v (x + y) = max (v x) (v y) := by\n  suffices \u00acv (x + y) < max (v x) (v y) from\n    or_iff_not_imp_right.1 (le_iff_eq_or_lt.1 (v.map_add x y)) this\n  intro h'\n  wlog vyx : v y < v x generalizing x y\n  \u00b7 refine this h.symm ?_ (h.lt_or_lt.resolve_right vyx)\n    rwa [add_comm, max_comm]\n  rw [max_eq_left_of_lt vyx] at h'\n  apply lt_irrefl (v x)\n  calc\n    v x = v (x + y - y) := by simp\n    _ \u2264 max (v <| x + y) (v y) := map_sub _ _ _\n    _ < v x := max_lt h' vyx\n\ntheorem map_add_eq_of_lt_right (h : v x < v y) : v (x + y) = v y :=\n  (v.map_add_of_distinct_val h.ne).trans (max_eq_right_iff.mpr h.le)\n\ntheorem map_add_eq_of_lt_left (h : v y < v x) : v (x + y) = v x := by\n  rw [add_comm]; exact map_add_eq_of_lt_right _ h\n\ntheorem map_sub_eq_of_lt_right (h : v x < v y) : v (x - y) = v y := by\n  rw [sub_eq_add_neg, map_add_eq_of_lt_right, map_neg]\n  rwa [map_neg]\n\nopen scoped Classical in\ntheorem map_sum_eq_of_lt {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {j : \u03b9}\n    (hj : j \u2208 s) (h0 : v (f j) \u2260 0) (hf : \u2200 i \u2208 s \\ {j}, v (f i) < v (f j)) :\n    v (\u2211 i \u2208 s, f i) = v (f j) := by\n  rw [Finset.sum_eq_add_sum_diff_singleton hj]\n  exact map_add_eq_of_lt_left _ (map_sum_lt _ h0 hf)\n\ntheorem map_sub_eq_of_lt_left (h : v y < v x) : v (x - y) = v x := by\n  rw [sub_eq_add_neg, map_add_eq_of_lt_left]\n  rwa [map_neg]\n\ntheorem map_eq_of_sub_lt (h : v (y - x) < v x) : v y = v x := by\n  have := Valuation.map_add_of_distinct_val v (ne_of_gt h).symm\n  rw [max_eq_right (le_of_lt h)] at this\n  simpa using this\n\ntheorem map_one_add_of_lt (h : v x < 1) : v (1 + x) = 1 := by\n  rw [\u2190 v.map_one] at h\n  simpa only [v.map_one] using v.map_add_eq_of_lt_left h\n\ntheorem map_one_sub_of_lt (h : v x < 1) : v (1 - x) = 1 := by\n  rw [\u2190 v.map_one, \u2190 v.map_neg] at h\n  rw [sub_eq_add_neg 1 x]\n  simpa only [v.map_one, v.map_neg] using v.map_add_eq_of_lt_left h\n\n/-- An ordered monoid isomorphism `\u0393\u2080 \u2243 \u0393'\u2080` induces an equivalence\n`Valuation R \u0393\u2080 \u2243 Valuation R \u0393'\u2080`. -/\ndef congr (f : \u0393\u2080 \u2243*o \u0393'\u2080) : Valuation R \u0393\u2080 \u2243 Valuation R \u0393'\u2080 where\n  toFun := map f f.toOrderIso.monotone\n  invFun := map f.symm f.toOrderIso.symm.monotone\n  left_inv \u03bd := by ext; simp\n  right_inv \u03bd := by ext; simp\n\nend Monoid\n\nsection Group\n\nvariable [LinearOrderedCommGroupWithZero \u0393\u2080] (v : Valuation R \u0393\u2080) {x y : R}\n\ntheorem map_inv {R : Type*} [DivisionRing R] (v : Valuation R \u0393\u2080) : \u2200 x, v x\u207b\u00b9 = (v x)\u207b\u00b9 :=\n  map_inv\u2080 _\n\ntheorem map_div {R : Type*} [DivisionRing R] (v : Valuation R \u0393\u2080) : \u2200 x y, v (x / y) = v x / v y :=\n  map_div\u2080 _\n\ntheorem one_lt_val_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : 1 < v x \u2194 v x\u207b\u00b9 < 1 := by\n  simp [inv_lt_one\u2080 (v.pos_iff.2 h)]\n\ntheorem one_le_val_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : 1 \u2264 v x \u2194 v x\u207b\u00b9 \u2264 1 := by\n  simp [inv_le_one\u2080 (v.pos_iff.2 h)]\n\ntheorem val_lt_one_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : v x < 1 \u2194 1 < v x\u207b\u00b9 := by\n  simp [one_lt_inv\u2080 (v.pos_iff.2 h)]\n\ntheorem val_le_one_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : v x \u2264 1 \u2194 1 \u2264 v x\u207b\u00b9 := by\n  simp [one_le_inv\u2080 (v.pos_iff.2 h)]\n\ntheorem val_eq_one_iff (v : Valuation K \u0393\u2080) {x : K} : v x = 1 \u2194 v x\u207b\u00b9 = 1 := by\n  by_cases h : x = 0\n  \u00b7 simp only [map_inv\u2080, inv_eq_one]\n  \u00b7 simpa only [le_antisymm_iff, And.comm] using and_congr (one_le_val_iff v h) (val_le_one_iff v h)\n\ntheorem val_le_one_or_val_inv_lt_one (v : Valuation K \u0393\u2080) (x : K) : v x \u2264 1 \u2228 v x\u207b\u00b9 < 1 := by\n  by_cases h : x = 0\n  \u00b7 simp only [h, _root_.map_zero, zero_le', inv_zero, zero_lt_one, or_self]\n  \u00b7 simp only [\u2190 one_lt_val_iff v h, le_or_lt]\n\n/--\nThis theorem is a weaker version of `Valuation.val_le_one_or_val_inv_lt_one`, but more symmetric\nin `x` and `x\u207b\u00b9`.\n-/\ntheorem val_le_one_or_val_inv_le_one (v : Valuation K \u0393\u2080) (x : K) : v x \u2264 1 \u2228 v x\u207b\u00b9 \u2264 1 := by\n  by_cases h : x = 0\n  \u00b7 simp only [h, _root_.map_zero, zero_le', inv_zero, or_self]\n  \u00b7 simp only [\u2190 one_le_val_iff v h, le_total]\n\n/-- The subgroup of elements whose valuation is less than a certain unit. -/\ndef ltAddSubgroup (v : Valuation R \u0393\u2080) (\u03b3 : \u0393\u2080\u02e3) : AddSubgroup R where\n  carrier := { x | v x < \u03b3 }\n  zero_mem' := by simp\n  add_mem' {x y} x_in y_in := lt_of_le_of_lt (v.map_add x y) (max_lt x_in y_in)\n  neg_mem' x_in := by rwa [Set.mem_setOf, map_neg]\n\nend Group\n\nend Basic\n\n-- end of section\nnamespace IsEquiv\n\nvariable [Ring R] [LinearOrderedCommMonoidWithZero \u0393\u2080] [LinearOrderedCommMonoidWithZero \u0393'\u2080]\n  {v : Valuation R \u0393\u2080} {v\u2081 : Valuation R \u0393\u2080} {v\u2082 : Valuation R \u0393'\u2080} {v\u2083 : Valuation R \u0393''\u2080}\n\n@[refl]\ntheorem refl : v.IsEquiv v := fun _ _ => Iff.refl _\n\n@[symm]\ntheorem symm (h : v\u2081.IsEquiv v\u2082) : v\u2082.IsEquiv v\u2081 := fun _ _ => Iff.symm (h _ _)\n\n@[trans]\ntheorem trans (h\u2081\u2082 : v\u2081.IsEquiv v\u2082) (h\u2082\u2083 : v\u2082.IsEquiv v\u2083) : v\u2081.IsEquiv v\u2083 := fun _ _ =>\n  Iff.trans (h\u2081\u2082 _ _) (h\u2082\u2083 _ _)\n\ntheorem of_eq {v' : Valuation R \u0393\u2080} (h : v = v') : v.IsEquiv v' := by subst h; rfl\n\ntheorem map {v' : Valuation R \u0393\u2080} (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080) (hf : Monotone f) (inf : Injective f)\n    (h : v.IsEquiv v') : (v.map f hf).IsEquiv (v'.map f hf) :=\n  let H : StrictMono f := hf.strictMono_of_injective inf\n  fun r s =>\n  calc\n    f (v r) \u2264 f (v s) \u2194 v r \u2264 v s := by rw [H.le_iff_le]\n    _ \u2194 v' r \u2264 v' s := h r s\n    _ \u2194 f (v' r) \u2264 f (v' s) := by rw [H.le_iff_le]\n\n/-- `comap` preserves equivalence. -/\ntheorem comap {S : Type*} [Ring S] (f : S \u2192+* R) (h : v\u2081.IsEquiv v\u2082) :\n    (v\u2081.comap f).IsEquiv (v\u2082.comap f) := fun r s => h (f r) (f s)\n\ntheorem val_eq (h : v\u2081.IsEquiv v\u2082) {r s : R} : v\u2081 r = v\u2081 s \u2194 v\u2082 r = v\u2082 s := by\n  simpa only [le_antisymm_iff] using and_congr (h r s) (h s r)\n\ntheorem ne_zero (h : v\u2081.IsEquiv v\u2082) {r : R} : v\u2081 r \u2260 0 \u2194 v\u2082 r \u2260 0 := by\n  have : v\u2081 r \u2260 v\u2081 0 \u2194 v\u2082 r \u2260 v\u2082 0 := not_congr h.val_eq\n  rwa [v\u2081.map_zero, v\u2082.map_zero] at this\n\nend IsEquiv\n\n-- end of namespace\nsection\n\ntheorem isEquiv_of_map_strictMono [LinearOrderedCommMonoidWithZero \u0393\u2080]\n    [LinearOrderedCommMonoidWithZero \u0393'\u2080] [Ring R] {v : Valuation R \u0393\u2080} (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080)\n    (H : StrictMono f) : IsEquiv (v.map f H.monotone) v := fun _x _y =>\n  \u27e8H.le_iff_le.mp, fun h => H.monotone h\u27e9\n\ntheorem isEquiv_iff_val_lt_val [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x y : K}, v x < v y \u2194 v' x < v' y := by\n  simp only [IsEquiv, le_iff_le_iff_lt_iff_lt]\n  exact forall_comm\n\nalias \u27e8IsEquiv.lt_iff_lt, _\u27e9 := isEquiv_iff_val_lt_val\n\ntheorem isEquiv_of_val_le_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080}\n    (h : \u2200 {x : K}, v x \u2264 1 \u2194 v' x \u2264 1) : v.IsEquiv v' := by\n  intro x y\n  obtain rfl | hy := eq_or_ne y 0\n  \u00b7 simp\n  \u00b7 rw [\u2190 div_le_one\u2080, \u2190 v.map_div, h, v'.map_div, div_le_one\u2080] <;>\n      rwa [zero_lt_iff, ne_zero_iff]\n\ntheorem isEquiv_iff_val_le_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v x \u2264 1 \u2194 v' x \u2264 1 :=\n  \u27e8fun h x => by simpa using h x 1, isEquiv_of_val_le_one\u27e9\n\nalias \u27e8IsEquiv.le_one_iff_le_one, _\u27e9 := isEquiv_iff_val_le_one\n\ntheorem isEquiv_iff_val_eq_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v x = 1 \u2194 v' x = 1 := by\n  constructor\n  \u00b7 intro h x\n    simpa using @IsEquiv.val_eq _ _ _ _ _ _ v v' h x 1\n  \u00b7 intro h\n    apply isEquiv_of_val_le_one\n    intro x\n    constructor\n    \u00b7 intro hx\n      rcases lt_or_eq_of_le hx with hx' | hx'\n      \u00b7 have : v (1 + x) = 1 := by\n          rw [\u2190 v.map_one]\n          apply map_add_eq_of_lt_left\n          simpa\n        rw [h] at this\n        rw [show x = -1 + (1 + x) by simp]\n        refine le_trans (v'.map_add _ _) ?_\n        simp [this]\n      \u00b7 rw [h] at hx'\n        exact le_of_eq hx'\n    \u00b7 intro hx\n      rcases lt_or_eq_of_le hx with hx' | hx'\n      \u00b7 have : v' (1 + x) = 1 := by\n          rw [\u2190 v'.map_one]\n          apply map_add_eq_of_lt_left\n          simpa\n        rw [\u2190 h] at this\n        rw [show x = -1 + (1 + x) by simp]\n        refine le_trans (v.map_add _ _) ?_\n        simp [this]\n      \u00b7 rw [\u2190 h] at hx'\n        exact le_of_eq hx'\n\nalias \u27e8IsEquiv.eq_one_iff_eq_one, _\u27e9 := isEquiv_iff_val_eq_one\n\ntheorem isEquiv_iff_val_lt_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v x < 1 \u2194 v' x < 1 := by\n  constructor\n  \u00b7 intro h x\n    simp only [lt_iff_le_and_ne,\n      and_congr h.le_one_iff_le_one h.eq_one_iff_eq_one.not]\n  \u00b7 rw [isEquiv_iff_val_eq_one]\n    intro h x\n    by_cases hx : x = 0\n    \u00b7 simp only [(zero_iff _).2 hx, zero_ne_one]\n    constructor\n    \u00b7 intro hh\n      by_contra h_1\n      cases ne_iff_lt_or_gt.1 h_1 with\n      | inl h_2 => simpa [hh, lt_self_iff_false] using h.2 h_2\n      | inr h_2 =>\n          rw [\u2190 inv_one, \u2190 inv_eq_iff_eq_inv, \u2190 map_inv\u2080] at hh\n          exact hh.not_lt (h.2 ((one_lt_val_iff v' hx).1 h_2))\n    \u00b7 intro hh\n      by_contra h_1\n      cases ne_iff_lt_or_gt.1 h_1 with\n      | inl h_2 => simpa [hh, lt_self_iff_false] using h.1 h_2\n      | inr h_2 =>\n        rw [\u2190 inv_one, \u2190 inv_eq_iff_eq_inv, \u2190 map_inv\u2080] at hh\n        exact hh.not_lt (h.1 ((one_lt_val_iff v hx).1 h_2))\n\nalias \u27e8IsEquiv.lt_one_iff_lt_one, _\u27e9 := isEquiv_iff_val_lt_one\n\ntheorem isEquiv_iff_val_sub_one_lt_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v (x - 1) < 1 \u2194 v' (x - 1) < 1 := by\n  rw [isEquiv_iff_val_lt_one]\n  exact (Equiv.subRight 1).surjective.forall\n\nalias \u27e8IsEquiv.val_sub_one_lt_one_iff, _\u27e9 := isEquiv_iff_val_sub_one_lt_one\n\ntheorem isEquiv_tfae [LinearOrderedCommGroupWithZero \u0393\u2080] [LinearOrderedCommGroupWithZero \u0393'\u2080]\n    (v : Valuation K \u0393\u2080) (v' : Valuation K \u0393'\u2080) :\n    [ v.IsEquiv v',\n      \u2200 {x y}, v x < v y \u2194 v' x < v' y,\n      \u2200 {x}, v x \u2264 1 \u2194 v' x \u2264 1,\n      \u2200 {x}, v x = 1 \u2194 v' x = 1,\n      \u2200 {x}, v x < 1 \u2194 v' x < 1,\n      \u2200 {x}, v (x - 1) < 1 \u2194 v' (x - 1) < 1 ].TFAE := by\n  tfae_have 1 \u2194 2 := isEquiv_iff_val_lt_val\n  tfae_have 1 \u2194 3 := isEquiv_iff_val_le_one\n  tfae_have 1 \u2194 4 := isEquiv_iff_val_eq_one\n  tfae_have 1 \u2194 5 := isEquiv_iff_val_lt_one\n  tfae_have 1 \u2194 6 := isEquiv_iff_val_sub_one_lt_one\n  tfae_finish\n\nend\n\nsection Supp\n\nvariable [CommRing R] [LinearOrderedCommMonoidWithZero \u0393\u2080] (v : Valuation R \u0393\u2080)\n\n/-- The support of a valuation `v : R \u2192 \u0393\u2080` is the ideal of `R` where `v` vanishes. -/\ndef supp : Ideal R where\n  carrier := { x | v x = 0 }\n  zero_mem' := map_zero v\n  add_mem' {x y} hx hy := le_zero_iff.mp <|\n    calc\n      v (x + y) \u2264 max (v x) (v y) := v.map_add x y\n      _ \u2264 0 := max_le (le_zero_iff.mpr hx) (le_zero_iff.mpr hy)\n  smul_mem' c x hx :=\n    calc\n      v (c * x) = v c * v x := map_mul v c x\n      _ = v c * 0 := congr_arg _ hx\n      _ = 0 := mul_zero _\n\n@[simp]\ntheorem mem_supp_iff (x : R) : x \u2208 supp v \u2194 v x = 0 :=\n  Iff.rfl\n\n/-- The support of a valuation is a prime ideal. -/\ninstance [Nontrivial \u0393\u2080] [NoZeroDivisors \u0393\u2080] : Ideal.IsPrime (supp v) :=\n  \u27e8fun h =>\n    one_ne_zero (\u03b1 := \u0393\u2080) <|\n      calc\n        1 = v 1 := v.map_one.symm\n        _ = 0 := by rw [\u2190 mem_supp_iff, h]; exact Submodule.mem_top,\n   fun {x y} hxy => by\n    simp only [mem_supp_iff] at hxy \u22a2\n    rw [v.map_mul x y] at hxy\n    exact eq_zero_or_eq_zero_of_mul_eq_zero hxy\u27e9\n\ntheorem map_add_supp (a : R) {s : R} (h : s \u2208 supp v) : v (a + s) = v a := by\n  have aux : \u2200 a s, v s = 0 \u2192 v (a + s) \u2264 v a := by\n    intro a' s' h'\n    refine le_trans (v.map_add a' s') (max_le le_rfl ?_)\n    simp [h']\n  apply le_antisymm (aux a s h)\n  calc\n    v a = v (a + s + -s) := by simp\n    _ \u2264 v (a + s) := aux (a + s) (-s) (by rwa [\u2190 Ideal.neg_mem_iff] at h)\n\ntheorem comap_supp {S : Type*} [CommRing S] (f : S \u2192+* R) :\n    supp (v.comap f) = Ideal.comap f v.supp :=\n  Ideal.ext fun x => by rw [mem_supp_iff, Ideal.mem_comap, mem_supp_iff, comap_apply]\n\nend Supp\n\n-- end of section\nend Valuation\n\nsection AddMonoid\n\nvariable (R) [Ring R] (\u0393\u2080 : Type*) [LinearOrderedAddCommMonoidWithTop \u0393\u2080]\n\n/-- The type of `\u0393\u2080`-valued additive valuations on `R`. -/\ndef AddValuation :=\n  Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48)\n\nend AddMonoid\n\nnamespace AddValuation\n\nvariable {\u0393\u2080 : Type*} {\u0393'\u2080 : Type*}\n\nsection Basic\n\nsection Monoid\n\n/-- A valuation is coerced to the underlying function `R \u2192 \u0393\u2080`. -/\ninstance (R) (\u0393\u2080) [Ring R] [LinearOrderedAddCommMonoidWithTop \u0393\u2080] :\n    FunLike (AddValuation R \u0393\u2080) R \u0393\u2080 where\n  coe v := v.toMonoidWithZeroHom.toFun\n  coe_injective' f g := by cases f; cases g; simp (config := {contextual := true})\n\nvariable [Ring R] [LinearOrderedAddCommMonoidWithTop \u0393\u2080] [LinearOrderedAddCommMonoidWithTop \u0393'\u2080]\n  (v : AddValuation R \u0393\u2080)\n\nsection\n\nvariable (f : R \u2192 \u0393\u2080) (h0 : f 0 = \u22a4) (h1 : f 1 = 0)\nvariable (hadd : \u2200 x y, min (f x) (f y) \u2264 f (x + y)) (hmul : \u2200 x y, f (x * y) = f x + f y)\n\n/-- An alternate constructor of `AddValuation`, that doesn't reference `Multiplicative \u0393\u2080\u1d52\u1d48` -/\ndef of : AddValuation R \u0393\u2080 where\n  toFun := f\n  map_one' := h1\n  map_zero' := h0\n  map_add_le_max' := hadd\n  map_mul' := hmul\n\nvariable {h0} {h1} {hadd} {hmul} {r : R}\n\n@[simp]\ntheorem of_apply : (of f h0 h1 hadd hmul) r = f r := rfl\n\n/-- The `Valuation` associated to an `AddValuation` (useful if the latter is constructed using\n`AddValuation.of`). -/\ndef toValuation : AddValuation R \u0393\u2080 \u2243 Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48) :=\n  Equiv.refl _\n\n@[deprecated (since := \"2024-11-09\")]\nalias valuation := toValuation\n\n/-- The `AddValuation` associated to a `Valuation`.\n-/\ndef ofValuation : Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48) \u2243 AddValuation R \u0393\u2080 :=\n  Equiv.refl _\n\n@[simp]\nlemma ofValuation_symm_eq : ofValuation.symm = toValuation (R := R) (\u0393\u2080 := \u0393\u2080) := rfl\n\n@[simp]\nlemma toValuation_symm_eq : toValuation.symm = ofValuation (R := R) (\u0393\u2080 := \u0393\u2080) := rfl\n\n@[simp]\nlemma ofValuation_toValuation : ofValuation (toValuation v) = v := rfl\n\n", "theoremStatement": "@[simp]\nlemma toValuation_ofValuation (v : Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48)) :\n    toValuation (ofValuation v) = v ", "theoremName": "AddValuation.toValuation_ofValuation", "fileCreated": {"commit": "a9138cdba12f2110c86195f5eac26cb36dee2627", "date": "2023-03-17"}, "theoremCreated": {"commit": "625ac34a53dfa0eca4fb8a3a933409238e4f43f0", "date": "2024-12-16"}, "file": "mathlib/Mathlib/RingTheory/Valuation/Basic.lean", "module": "Mathlib.RingTheory.Valuation.Basic", "jsonFile": "Mathlib.RingTheory.Valuation.Basic.jsonl", "positionMetadata": {"lineInFile": 669, "tokenPositionInFile": 23240, "theoremPositionInFile": 78}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 12, "numPremises": 14}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Chris Hughes, Anne Baanen\n-/\nimport Mathlib.Data.Matrix.Basic\nimport Mathlib.Data.Matrix.Block\nimport Mathlib.Data.Matrix.Notation\nimport Mathlib.Data.Matrix.RowCol\nimport Mathlib.GroupTheory.GroupAction.Ring\nimport Mathlib.GroupTheory.Perm.Fin\nimport Mathlib.LinearAlgebra.Alternating.Basic\nimport Mathlib.LinearAlgebra.Matrix.SemiringInverse\n\n/-!\n# Determinant of a matrix\n\nThis file defines the determinant of a matrix, `Matrix.det`, and its essential properties.\n\n## Main definitions\n\n - `Matrix.det`: the determinant of a square matrix, as a sum over permutations\n - `Matrix.detRowAlternating`: the determinant, as an `AlternatingMap` in the rows of the matrix\n\n## Main results\n\n - `det_mul`: the determinant of `A * B` is the product of determinants\n - `det_zero_of_row_eq`: the determinant is zero if there is a repeated row\n - `det_block_diagonal`: the determinant of a block diagonal matrix is a product\n   of the blocks' determinants\n\n## Implementation notes\n\nIt is possible to configure `simp` to compute determinants. See the file\n`MathlibTest/matrix.lean` for some examples.\n\n-/\n\n\nuniverse u v w z\n\nopen Equiv Equiv.Perm Finset Function\n\nnamespace Matrix\n\nvariable {m n : Type*} [DecidableEq n] [Fintype n] [DecidableEq m] [Fintype m]\nvariable {R : Type v} [CommRing R]\n\nlocal notation \"\u03b5 \" \u03c3:arg => ((sign \u03c3 : \u2124) : R)\n\n/-- `det` is an `AlternatingMap` in the rows of the matrix. -/\ndef detRowAlternating : (n \u2192 R) [\u22c0^n]\u2192\u2097[R] R :=\n  MultilinearMap.alternatization ((MultilinearMap.mkPiAlgebra R n R).compLinearMap LinearMap.proj)\n\n/-- The determinant of a matrix given by the Leibniz formula. -/\nabbrev det (M : Matrix n n R) : R :=\n  detRowAlternating M\n\ntheorem det_apply (M : Matrix n n R) : M.det = \u2211 \u03c3 : Perm n, Equiv.Perm.sign \u03c3 \u2022 \u220f i, M (\u03c3 i) i :=\n  MultilinearMap.alternatization_apply _ M\n\n-- This is what the old definition was. We use it to avoid having to change the old proofs below\ntheorem det_apply' (M : Matrix n n R) : M.det = \u2211 \u03c3 : Perm n, \u03b5 \u03c3 * \u220f i, M (\u03c3 i) i := by\n  simp [det_apply, Units.smul_def]\n\ntheorem det_eq_detp_sub_detp (M : Matrix n n R) : M.det = M.detp 1 - M.detp (-1) := by\n  rw [det_apply, \u2190 Equiv.sum_comp (Equiv.inv (Perm n)), \u2190 ofSign_disjUnion, sum_disjUnion]\n  simp_rw [inv_apply, sign_inv, sub_eq_add_neg, detp, \u2190 sum_neg_distrib]\n  refine congr_arg\u2082 (\u00b7 + \u00b7) (sum_congr rfl fun \u03c3 h\u03c3 \u21a6 ?_) (sum_congr rfl fun \u03c3 h\u03c3 \u21a6 ?_) <;>\n    rw [mem_ofSign.mp h\u03c3, \u2190 Equiv.prod_comp \u03c3] <;> simp\n\n@[simp]\ntheorem det_diagonal {d : n \u2192 R} : det (diagonal d) = \u220f i, d i := by\n  rw [det_apply']\n  refine (Finset.sum_eq_single 1 ?_ ?_).trans ?_\n  \u00b7 rintro \u03c3 - h2\n    cases' not_forall.1 (mt Equiv.ext h2) with x h3\n    convert mul_zero (\u03b5 \u03c3)\n    apply Finset.prod_eq_zero (mem_univ x)\n    exact if_neg h3\n  \u00b7 simp\n  \u00b7 simp\n\ntheorem det_zero (_ : Nonempty n) : det (0 : Matrix n n R) = 0 :=\n  (detRowAlternating : (n \u2192 R) [\u22c0^n]\u2192\u2097[R] R).map_zero\n\n@[simp]\ntheorem det_one : det (1 : Matrix n n R) = 1 := by rw [\u2190 diagonal_one]; simp [-diagonal_one]\n\ntheorem det_isEmpty [IsEmpty n] {A : Matrix n n R} : det A = 1 := by simp [det_apply]\n\n@[simp]\ntheorem coe_det_isEmpty [IsEmpty n] : (det : Matrix n n R \u2192 R) = Function.const _ 1 := by\n  ext\n  exact det_isEmpty\n\ntheorem det_eq_one_of_card_eq_zero {A : Matrix n n R} (h : Fintype.card n = 0) : det A = 1 :=\n  haveI : IsEmpty n := Fintype.card_eq_zero_iff.mp h\n  det_isEmpty\n\n/-- If `n` has only one element, the determinant of an `n` by `n` matrix is just that element.\nAlthough `Unique` implies `DecidableEq` and `Fintype`, the instances might\nnot be syntactically equal. Thus, we need to fill in the args explicitly. -/\n@[simp]\ntheorem det_unique {n : Type*} [Unique n] [DecidableEq n] [Fintype n] (A : Matrix n n R) :\n    det A = A default default := by simp [det_apply, univ_unique]\n\ntheorem det_eq_elem_of_subsingleton [Subsingleton n] (A : Matrix n n R) (k : n) :\n    det A = A k k := by\n  have := uniqueOfSubsingleton k\n  convert det_unique A\n\ntheorem det_eq_elem_of_card_eq_one {A : Matrix n n R} (h : Fintype.card n = 1) (k : n) :\n    det A = A k k :=\n  haveI : Subsingleton n := Fintype.card_le_one_iff_subsingleton.mp h.le\n  det_eq_elem_of_subsingleton _ _\n\ntheorem det_mul_aux {M N : Matrix n n R} {p : n \u2192 n} (H : \u00acBijective p) :\n    (\u2211 \u03c3 : Perm n, \u03b5 \u03c3 * \u220f x, M (\u03c3 x) (p x) * N (p x) x) = 0 := by\n  obtain \u27e8i, j, hpij, hij\u27e9 : \u2203 i j, p i = p j \u2227 i \u2260 j := by\n    rw [\u2190 Finite.injective_iff_bijective, Injective] at H\n    push_neg at H\n    exact H\n  exact\n    sum_involution (fun \u03c3 _ => \u03c3 * Equiv.swap i j)\n      (fun \u03c3 _ => by\n        have : (\u220f x, M (\u03c3 x) (p x)) = \u220f x, M ((\u03c3 * Equiv.swap i j) x) (p x) :=\n          Fintype.prod_equiv (swap i j) _ _ (by simp [apply_swap_eq_self hpij])\n        simp [this, sign_swap hij, -sign_swap', prod_mul_distrib])\n      (fun \u03c3 _ _ => (not_congr mul_swap_eq_iff).mpr hij) (fun _ _ => mem_univ _) fun \u03c3 _ =>\n      mul_swap_involutive i j \u03c3\n\n@[simp]\ntheorem det_mul (M N : Matrix n n R) : det (M * N) = det M * det N :=\n  calc\n    det (M * N) = \u2211 p : n \u2192 n, \u2211 \u03c3 : Perm n, \u03b5 \u03c3 * \u220f i, M (\u03c3 i) (p i) * N (p i) i := by\n      simp only [det_apply', mul_apply, prod_univ_sum, mul_sum, Fintype.piFinset_univ]\n      rw [Finset.sum_comm]\n    _ = \u2211 p : n \u2192 n with Bijective p, \u2211 \u03c3 : Perm n, \u03b5 \u03c3 * \u220f i, M (\u03c3 i) (p i) * N (p i) i := by\n      refine (sum_subset (filter_subset _ _) fun f _ hbij \u21a6 det_mul_aux ?_).symm\n      simpa only [true_and, mem_filter, mem_univ] using hbij\n    _ = \u2211 \u03c4 : Perm n, \u2211 \u03c3 : Perm n, \u03b5 \u03c3 * \u220f i, M (\u03c3 i) (\u03c4 i) * N (\u03c4 i) i :=\n      sum_bij (fun p h \u21a6 Equiv.ofBijective p (mem_filter.1 h).2) (fun _ _ \u21a6 mem_univ _)\n        (fun _ _ _ _ h \u21a6 by injection h)\n        (fun b _ \u21a6 \u27e8b, mem_filter.2 \u27e8mem_univ _, b.bijective\u27e9, coe_fn_injective rfl\u27e9) fun _ _ \u21a6 rfl\n    _ = \u2211 \u03c3 : Perm n, \u2211 \u03c4 : Perm n, (\u220f i, N (\u03c3 i) i) * \u03b5 \u03c4 * \u220f j, M (\u03c4 j) (\u03c3 j) := by\n      simp only [mul_comm, mul_left_comm, prod_mul_distrib, mul_assoc]\n    _ = \u2211 \u03c3 : Perm n, \u2211 \u03c4 : Perm n, (\u220f i, N (\u03c3 i) i) * (\u03b5 \u03c3 * \u03b5 \u03c4) * \u220f i, M (\u03c4 i) i :=\n      (sum_congr rfl fun \u03c3 _ =>\n        Fintype.sum_equiv (Equiv.mulRight \u03c3\u207b\u00b9) _ _ fun \u03c4 => by\n          have : (\u220f j, M (\u03c4 j) (\u03c3 j)) = \u220f j, M ((\u03c4 * \u03c3\u207b\u00b9) j) j := by\n            rw [\u2190 (\u03c3\u207b\u00b9 : _ \u2243 _).prod_comp]\n            simp only [Equiv.Perm.coe_mul, apply_inv_self, Function.comp_apply]\n          have h : \u03b5 \u03c3 * \u03b5 (\u03c4 * \u03c3\u207b\u00b9) = \u03b5 \u03c4 :=\n            calc\n              \u03b5 \u03c3 * \u03b5 (\u03c4 * \u03c3\u207b\u00b9) = \u03b5 (\u03c4 * \u03c3\u207b\u00b9 * \u03c3) := by\n                rw [mul_comm, sign_mul (\u03c4 * \u03c3\u207b\u00b9)]\n                simp only [Int.cast_mul, Units.val_mul]\n              _ = \u03b5 \u03c4 := by simp only [inv_mul_cancel_right]\n\n          simp_rw [Equiv.coe_mulRight, h]\n          simp only [this])\n    _ = det M * det N := by\n      simp only [det_apply', Finset.mul_sum, mul_comm, mul_left_comm, mul_assoc]\n\n/-- The determinant of a matrix, as a monoid homomorphism. -/\ndef detMonoidHom : Matrix n n R \u2192* R where\n  toFun := det\n  map_one' := det_one\n  map_mul' := det_mul\n\n@[simp]\ntheorem coe_detMonoidHom : (detMonoidHom : Matrix n n R \u2192 R) = det :=\n  rfl\n\n/-- On square matrices, `mul_comm` applies under `det`. -/\ntheorem det_mul_comm (M N : Matrix m m R) : det (M * N) = det (N * M) := by\n  rw [det_mul, det_mul, mul_comm]\n\n/-- On square matrices, `mul_left_comm` applies under `det`. -/\ntheorem det_mul_left_comm (M N P : Matrix m m R) : det (M * (N * P)) = det (N * (M * P)) := by\n  rw [\u2190 Matrix.mul_assoc, \u2190 Matrix.mul_assoc, det_mul, det_mul_comm M N, \u2190 det_mul]\n\n/-- On square matrices, `mul_right_comm` applies under `det`. -/\ntheorem det_mul_right_comm (M N P : Matrix m m R) : det (M * N * P) = det (M * P * N) := by\n  rw [Matrix.mul_assoc, Matrix.mul_assoc, det_mul, det_mul_comm N P, \u2190 det_mul]\n\n-- TODO(https://github.com/leanprover-community/mathlib4/issues/6607): fix elaboration so `val` isn't needed\ntheorem det_units_conj (M : (Matrix m m R)\u02e3) (N : Matrix m m R) :\n    det (M.val * N * M\u207b\u00b9.val) = det N := by\n  rw [det_mul_right_comm, Units.mul_inv, one_mul]\n\n-- TODO(https://github.com/leanprover-community/mathlib4/issues/6607): fix elaboration so `val` isn't needed\ntheorem det_units_conj' (M : (Matrix m m R)\u02e3) (N : Matrix m m R) :\n    det (M\u207b\u00b9.val * N * \u2191M.val) = det N :=\n  det_units_conj M\u207b\u00b9 N\n\n/-- Transposing a matrix preserves the determinant. -/\n@[simp]\ntheorem det_transpose (M : Matrix n n R) : M\u1d40.det = M.det := by\n  rw [det_apply', det_apply']\n  refine Fintype.sum_bijective _ inv_involutive.bijective _ _ ?_\n  intro \u03c3\n  rw [sign_inv]\n  congr 1\n  apply Fintype.prod_equiv \u03c3\n  simp\n\n/-- Permuting the columns changes the sign of the determinant. -/\ntheorem det_permute (\u03c3 : Perm n) (M : Matrix n n R) :\n    (M.submatrix \u03c3 id).det = Perm.sign \u03c3 * M.det :=\n  ((detRowAlternating : (n \u2192 R) [\u22c0^n]\u2192\u2097[R] R).map_perm M \u03c3).trans (by simp [Units.smul_def])\n\n/-- Permuting the rows changes the sign of the determinant. -/\ntheorem det_permute' (\u03c3 : Perm n) (M : Matrix n n R) :\n    (M.submatrix id \u03c3).det = Perm.sign \u03c3 * M.det := by\n  rw [\u2190 det_transpose, transpose_submatrix, det_permute, det_transpose]\n\n/-- Permuting rows and columns with the same equivalence does not change the determinant. -/\n@[simp]\ntheorem det_submatrix_equiv_self (e : n \u2243 m) (A : Matrix m m R) :\n    det (A.submatrix e e) = det A := by\n  rw [det_apply', det_apply']\n  apply Fintype.sum_equiv (Equiv.permCongr e)\n  intro \u03c3\n  rw [Equiv.Perm.sign_permCongr e \u03c3]\n  congr 1\n  apply Fintype.prod_equiv e\n  intro i\n  rw [Equiv.permCongr_apply, Equiv.symm_apply_apply, submatrix_apply]\n\n/-- Permuting rows and columns with two equivalences does not change the absolute value of the\ndeterminant. -/\n@[simp]\ntheorem abs_det_submatrix_equiv_equiv {R : Type*} [LinearOrderedCommRing R]\n    (e\u2081 e\u2082 : n \u2243 m) (A : Matrix m m R) :\n    |(A.submatrix e\u2081 e\u2082).det| = |A.det| := by\n  have hee : e\u2082 = e\u2081.trans (e\u2081.symm.trans e\u2082) := by ext; simp\n  rw [hee]\n  show |((A.submatrix id (e\u2081.symm.trans e\u2082)).submatrix e\u2081 e\u2081).det| = |A.det|\n  rw [Matrix.det_submatrix_equiv_self, Matrix.det_permute', abs_mul, abs_unit_intCast, one_mul]\n\n/-- Reindexing both indices along the same equivalence preserves the determinant.\n\nFor the `simp` version of this lemma, see `det_submatrix_equiv_self`; this one is unsuitable because\n`Matrix.reindex_apply` unfolds `reindex` first.\n-/\ntheorem det_reindex_self (e : m \u2243 n) (A : Matrix m m R) : det (reindex e e A) = det A :=\n  det_submatrix_equiv_self e.symm A\n\ntheorem det_smul (A : Matrix n n R) (c : R) : det (c \u2022 A) = c ^ Fintype.card n * det A :=\n  calc\n    det (c \u2022 A) = det ((diagonal fun _ => c) * A) := by rw [smul_eq_diagonal_mul]\n    _ = det (diagonal fun _ => c) * det A := det_mul _ _\n    _ = c ^ Fintype.card n * det A := by simp [card_univ]\n\n@[simp]\ntheorem det_smul_of_tower {\u03b1} [Monoid \u03b1] [DistribMulAction \u03b1 R] [IsScalarTower \u03b1 R R]\n    [SMulCommClass \u03b1 R R] (c : \u03b1) (A : Matrix n n R) :\n    det (c \u2022 A) = c ^ Fintype.card n \u2022 det A := by\n  rw [\u2190 smul_one_smul R c A, det_smul, smul_pow, one_pow, smul_mul_assoc, one_mul]\n\ntheorem det_neg (A : Matrix n n R) : det (-A) = (-1) ^ Fintype.card n * det A := by\n  rw [\u2190 det_smul, neg_one_smul]\n\n/-- A variant of `Matrix.det_neg` with scalar multiplication by `Units \u2124` instead of multiplication\nby `R`. -/\ntheorem det_neg_eq_smul (A : Matrix n n R) :\n    det (-A) = (-1 : Units \u2124) ^ Fintype.card n \u2022 det A := by\n  rw [\u2190 det_smul_of_tower, Units.neg_smul, one_smul]\n\n/-- Multiplying each row by a fixed `v i` multiplies the determinant by\nthe product of the `v`s. -/\ntheorem det_mul_row (v : n \u2192 R) (A : Matrix n n R) :\n    det (of fun i j => v j * A i j) = (\u220f i, v i) * det A :=\n  calc\n    det (of fun i j => v j * A i j) = det (A * diagonal v) :=\n      congr_arg det <| by\n        ext\n        simp [mul_comm]\n    _ = (\u220f i, v i) * det A := by rw [det_mul, det_diagonal, mul_comm]\n\n/-- Multiplying each column by a fixed `v j` multiplies the determinant by\nthe product of the `v`s. -/\ntheorem det_mul_column (v : n \u2192 R) (A : Matrix n n R) :\n    det (of fun i j => v i * A i j) = (\u220f i, v i) * det A :=\n  MultilinearMap.map_smul_univ _ v A\n\n@[simp]\ntheorem det_pow (M : Matrix m m R) (n : \u2115) : det (M ^ n) = det M ^ n :=\n  (detMonoidHom : Matrix m m R \u2192* R).map_pow M n\n\nsection HomMap\n\nvariable {S : Type w} [CommRing S]\n\ntheorem _root_.RingHom.map_det (f : R \u2192+* S) (M : Matrix n n R) :\n    f M.det = Matrix.det (f.mapMatrix M) := by\n  simp [Matrix.det_apply', map_sum f, map_prod f]\n\ntheorem _root_.RingEquiv.map_det (f : R \u2243+* S) (M : Matrix n n R) :\n    f M.det = Matrix.det (f.mapMatrix M) :=\n  f.toRingHom.map_det _\n\ntheorem _root_.AlgHom.map_det [Algebra R S] {T : Type z} [CommRing T] [Algebra R T] (f : S \u2192\u2090[R] T)\n    (M : Matrix n n S) : f M.det = Matrix.det (f.mapMatrix M) :=\n  f.toRingHom.map_det _\n\ntheorem _root_.AlgEquiv.map_det [Algebra R S] {T : Type z} [CommRing T] [Algebra R T]\n    (f : S \u2243\u2090[R] T) (M : Matrix n n S) : f M.det = Matrix.det (f.mapMatrix M) :=\n  f.toAlgHom.map_det _\n\nend HomMap\n\n@[simp]\ntheorem det_conjTranspose [StarRing R] (M : Matrix m m R) : det M\u1d34 = star (det M) :=\n  ((starRingEnd R).map_det _).symm.trans <| congr_arg star M.det_transpose\n\nsection DetZero\n\n/-!\n### `det_zero` section\n\nProve that a matrix with a repeated column has determinant equal to zero.\n-/\n\n\ntheorem det_eq_zero_of_row_eq_zero {A : Matrix n n R} (i : n) (h : \u2200 j, A i j = 0) : det A = 0 :=\n  (detRowAlternating : (n \u2192 R) [\u22c0^n]\u2192\u2097[R] R).map_coord_zero i (funext h)\n\ntheorem det_eq_zero_of_column_eq_zero {A : Matrix n n R} (j : n) (h : \u2200 i, A i j = 0) :\n    det A = 0 := by\n  rw [\u2190 det_transpose]\n  exact det_eq_zero_of_row_eq_zero j h\n\nvariable {M : Matrix n n R} {i j : n}\n\n/-- If a matrix has a repeated row, the determinant will be zero. -/\ntheorem det_zero_of_row_eq (i_ne_j : i \u2260 j) (hij : M i = M j) : M.det = 0 :=\n  (detRowAlternating : (n \u2192 R) [\u22c0^n]\u2192\u2097[R] R).map_eq_zero_of_eq M hij i_ne_j\n\n/-- If a matrix has a repeated column, the determinant will be zero. -/\ntheorem det_zero_of_column_eq (i_ne_j : i \u2260 j) (hij : \u2200 k, M k i = M k j) : M.det = 0 := by\n  rw [\u2190 det_transpose, det_zero_of_row_eq i_ne_j]\n  exact funext hij\n\n/-- If we repeat a row of a matrix, we get a matrix of determinant zero. -/\ntheorem det_updateRow_eq_zero (h : i \u2260 j) :\n    (M.updateRow j (M i)).det = 0 := det_zero_of_row_eq h (by simp [h])\n\n/-- If we repeat a column of a matrix, we get a matrix of determinant zero. -/\ntheorem det_updateCol_eq_zero (h : i \u2260 j) :\n    (M.updateCol j (fun k \u21a6 M k i)).det = 0 := det_zero_of_column_eq h (by simp [h])\n\n@[deprecated (since := \"2024-12-11\")] alias det_updateColumn_eq_zero := det_updateCol_eq_zero\n\nend DetZero\n\ntheorem det_updateRow_add (M : Matrix n n R) (j : n) (u v : n \u2192 R) :\n    det (updateRow M j <| u + v) = det (updateRow M j u) + det (updateRow M j v) :=\n  (detRowAlternating : (n \u2192 R) [\u22c0^n]\u2192\u2097[R] R).map_update_add M j u v\n\ntheorem det_updateCol_add (M : Matrix n n R) (j : n) (u v : n \u2192 R) :\n    det (updateCol M j <| u + v) = det (updateCol M j u) + det (updateCol M j v) := by\n  rw [\u2190 det_transpose, \u2190 updateRow_transpose, det_updateRow_add]\n  simp [updateRow_transpose, det_transpose]\n\n@[deprecated (since := \"2024-12-11\")] alias det_updateColumn_add := det_updateCol_add\n\ntheorem det_updateRow_smul (M : Matrix n n R) (j : n) (s : R) (u : n \u2192 R) :\n    det (updateRow M j <| s \u2022 u) = s * det (updateRow M j u) :=\n  (detRowAlternating : (n \u2192 R) [\u22c0^n]\u2192\u2097[R] R).map_update_smul M j s u\n\ntheorem det_updateCol_smul (M : Matrix n n R) (j : n) (s : R) (u : n \u2192 R) :\n    det (updateCol M j <| s \u2022 u) = s * det (updateCol M j u) := by\n  rw [\u2190 det_transpose, \u2190 updateRow_transpose, det_updateRow_smul]\n  simp [updateRow_transpose, det_transpose]\n\n@[deprecated (since := \"2024-12-11\")] alias det_updateColumn_smul := det_updateCol_smul\n\ntheorem det_updateRow_smul_left (M : Matrix n n R) (j : n) (s : R) (u : n \u2192 R) :\n    det (updateRow (s \u2022 M) j u) = s ^ (Fintype.card n - 1) * det (updateRow M j u) :=\n  MultilinearMap.map_update_smul_left _ M j s u\n\n@[deprecated (since := \"2024-11-03\")] alias det_updateRow_smul' := det_updateRow_smul_left\n\ntheorem det_updateCol_smul_left (M : Matrix n n R) (j : n) (s : R) (u : n \u2192 R) :\n    det (updateCol (s \u2022 M) j u) = s ^ (Fintype.card n - 1) * det (updateCol M j u) := by\n  rw [\u2190 det_transpose, \u2190 updateRow_transpose, transpose_smul, det_updateRow_smul_left]\n  simp [updateRow_transpose, det_transpose]\n\n@[deprecated (since := \"2024-12-11\")] alias det_updateColumn_smul' := det_updateCol_smul_left\n@[deprecated (since := \"2024-12-11\")] alias det_updateColumn_smul_left := det_updateCol_smul_left\n\ntheorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j \u2209 s) (c : n \u2192 R)\n    (a : R) :\n    (M.updateRow j (a \u2022 M j + \u2211 k \u2208 s, (c k) \u2022 M k)).det = a \u2022 M.det := by\n  induction s using Finset.induction_on with\n  | empty => rw [Finset.sum_empty, add_zero, smul_eq_mul, det_updateRow_smul, updateRow_eq_self]\n  | @insert k _ hk h_ind =>\n      have h : k \u2260 j := fun h \u21a6 (h \u25b8 hj) (Finset.mem_insert_self _ _)\n      rw [Finset.sum_insert hk, add_comm ((c k) \u2022 M k), \u2190 add_assoc, det_updateRow_add,\n        det_updateRow_smul, det_updateRow_eq_zero h, mul_zero, add_zero, h_ind]\n      exact fun h \u21a6 hj (Finset.mem_insert_of_mem h)\n\n/-- If we replace a row of a matrix by a linear combination of its rows, then the determinant is\nmultiplied by the coefficient of that row. -/\ntheorem det_updateRow_sum (A : Matrix n n R) (j : n) (c : n \u2192 R) :\n    (A.updateRow j (\u2211 k, (c k) \u2022 A k)).det = (c j) \u2022 A.det := by\n  convert det_updateRow_sum_aux A (Finset.univ.erase j) (Finset.univ.not_mem_erase j) c (c j)\n  rw [\u2190 Finset.univ.add_sum_erase _ (Finset.mem_univ j)]\n\n/-- If we replace a column of a matrix by a linear combination of its columns, then the determinant\nis multiplied by the coefficient of that column. -/\ntheorem det_updateCol_sum (A : Matrix n n R) (j : n) (c : n \u2192 R) :\n    (A.updateCol j (fun k \u21a6 \u2211 i, (c i) \u2022 A k i)).det = (c j) \u2022 A.det := by\n  rw [\u2190 det_transpose, \u2190 updateRow_transpose, \u2190 det_transpose A]\n  convert det_updateRow_sum A.transpose j c\n  simp only [smul_eq_mul, Finset.sum_apply, Pi.smul_apply, transpose_apply]\n\n@[deprecated (since := \"2024-12-11\")] alias det_updateColumn_sum := det_updateCol_sum\n\nsection DetEq\n\n/-! ### `det_eq` section\n\nLemmas showing the determinant is invariant under a variety of operations.\n-/\n\n\ntheorem det_eq_of_eq_mul_det_one {A B : Matrix n n R} (C : Matrix n n R) (hC : det C = 1)\n    (hA : A = B * C) : det A = det B :=\n  calc\n    det A = det (B * C) := congr_arg _ hA\n    _ = det B * det C := det_mul _ _\n    _ = det B := by rw [hC, mul_one]\n\ntheorem det_eq_of_eq_det_one_mul {A B : Matrix n n R} (C : Matrix n n R) (hC : det C = 1)\n    (hA : A = C * B) : det A = det B :=\n  calc\n    det A = det (C * B) := congr_arg _ hA\n    _ = det C * det B := det_mul _ _\n    _ = det B := by rw [hC, one_mul]\n\ntheorem det_updateRow_add_self (A : Matrix n n R) {i j : n} (hij : i \u2260 j) :\n    det (updateRow A i (A i + A j)) = det A := by\n  simp [det_updateRow_add,\n    det_zero_of_row_eq hij (updateRow_self.trans (updateRow_ne hij.symm).symm)]\n\n", "theoremStatement": "theorem det_updateCol_add_self (A : Matrix n n R) {i j : n} (hij : i \u2260 j) :\n    det (updateCol A i fun k => A k i + A k j) = det A ", "theoremName": "Matrix.det_updateCol_add_self", "fileCreated": {"commit": "3438911a821fa2fb5ba37cdbec993e952646aeca", "date": "2024-06-03"}, "theoremCreated": {"commit": "afdb9499da5095474266bcb3b723120eaf923aec", "date": "2024-12-11"}, "file": "mathlib/Mathlib/LinearAlgebra/Matrix/Determinant/Basic.lean", "module": "Mathlib.LinearAlgebra.Matrix.Determinant.Basic", "jsonFile": "Mathlib.LinearAlgebra.Matrix.Determinant.Basic.jsonl", "positionMetadata": {"lineInFile": 450, "tokenPositionInFile": 18990, "theoremPositionInFile": 58}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 16, "numPremises": 25}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [\u2190 det_transpose, \u2190 updateRow_transpose, \u2190 det_transpose A]\n  exact det_updateRow_add_self A\u1d40 hij", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 108}}
{"srcContext": "/-\nCopyright (c) 2024 Fangming Li. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Fangming Li, Jujian Zhang\n-/\nimport Mathlib.Algebra.Polynomial.AlgebraMap\nimport Mathlib.Algebra.Polynomial.Eval.SMul\nimport Mathlib.Algebra.Polynomial.Roots\nimport Mathlib.Order.Interval.Set.Infinite\nimport Mathlib.RingTheory.Polynomial.Pochhammer\nimport Mathlib.RingTheory.PowerSeries.WellKnown\nimport Mathlib.Tactic.FieldSimp\n\n/-!\n# Hilbert polynomials\n\nIn this file, we formalise the following statement: if `F` is a field with characteristic `0`, then\ngiven any `p : F[X]` and `d : \u2115`, there exists some `h : F[X]` such that for any large enough\n`n : \u2115`, `h(n)` is equal to the coefficient of `X\u207f` in the power series expansion of `p/(1 - X)\u1d48`.\nThis `h` is unique and is denoted as `Polynomial.hilbertPoly p d`.\n\nFor example, given `d : \u2115`, the power series expansion of `1/(1 - X)\u1d48\u207a\u00b9` in `F[X]`\nis `\u03a3\u2099 ((d + n).choose d)X\u207f`, which equals `\u03a3\u2099 ((n + 1)\u00b7\u00b7\u00b7(n + d)/d!)X\u207f` and hence\n`Polynomial.hilbertPoly (1 : F[X]) (d + 1)` is the polynomial `(X + 1)\u00b7\u00b7\u00b7(X + d)/d!`. Note that\nif `d! = 0` in `F`, then the polynomial `(X + 1)\u00b7\u00b7\u00b7(X + d)/d!` no longer works, so we do not want\nthe characteristic of `F` to be divisible by `d!`. As `Polynomial.hilbertPoly` may take any\n`p : F[X]` and `d : \u2115` as its inputs, it is necessary for us to assume that `CharZero F`.\n\n## Main definitions\n\n* `Polynomial.hilbertPoly p d`. Given a field `F`, a polynomial `p : F[X]` and a natural number `d`,\n  if `F` is of characteristic `0`, then `Polynomial.hilbertPoly p d : F[X]` is the polynomial whose\n  value at `n` equals the coefficient of `X\u207f` in the power series expansion of `p/(1 - X)\u1d48`.\n\n## TODO\n\n* Hilbert polynomials of finitely generated graded modules over Noetherian rings.\n-/\n\nopen Nat PowerSeries\n\nvariable (F : Type*) [Field F]\n\nnamespace Polynomial\n\n/--\nFor any field `F` and natural numbers `d` and `k`, `Polynomial.preHilbertPoly F d k`\nis defined as `(d.factorial : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (X - (C (k : F)) + 1))`.\nThis is the most basic form of Hilbert polynomials. `Polynomial.preHilbertPoly \u211a d 0`\nis exactly the Hilbert polynomial of the polynomial ring `\u211a[X_0,...,X_d]` viewed as\na graded module over itself. In fact, `Polynomial.preHilbertPoly F d k` is the\nsame as `Polynomial.hilbertPoly ((X : F[X]) ^ k) (d + 1)` for any field `F` and\n`d k : \u2115` (see the lemma `Polynomial.hilbertPoly_X_pow_succ`). See also the lemma\n`Polynomial.preHilbertPoly_eq_choose_sub_add`, which states that if `CharZero F`,\nthen for any `d k n : \u2115` with `k \u2264 n`, `(Polynomial.preHilbertPoly F d k).eval (n : F)`\nequals `(n - k + d).choose d`.\n-/\nnoncomputable def preHilbertPoly (d k : \u2115) : F[X] :=\n  (d.factorial : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (Polynomial.X - (C (k : F)) + 1))\n\n", "theoremStatement": "lemma natDegree_preHilbertPoly [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).natDegree = d ", "theoremName": "Polynomial.natDegree_preHilbertPoly", "fileCreated": {"commit": "561e050467d2caa2e4ea5d81ca62600bf268b747", "date": "2024-12-02"}, "theoremCreated": {"commit": "bd9aea4b2403dcb1ec3998335f71109212ada88e", "date": "2024-12-09"}, "file": "mathlib/Mathlib/RingTheory/Polynomial/HilbertPoly.lean", "module": "Mathlib.RingTheory.Polynomial.HilbertPoly", "jsonFile": "Mathlib.RingTheory.Polynomial.HilbertPoly.jsonl", "positionMetadata": {"lineInFile": 61, "tokenPositionInFile": 2811, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 100, "numPremises": 124}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  have hne : (d ! : F) \u2260 0 := by norm_cast; positivity\n  rw [preHilbertPoly, natDegree_smul _ (inv_ne_zero hne), natDegree_comp, ascPochhammer_natDegree,\n    add_comm_sub, \u2190 C_1, \u2190 map_sub, natDegree_add_C, natDegree_X, mul_one]", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 234}}
{"srcContext": "/-\nCopyright (c) 2024 Jo\u00ebl Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jo\u00ebl Riou\n-/\nimport Mathlib.Algebra.Homology.Embedding.Extend\nimport Mathlib.Algebra.Homology.Embedding.IsSupported\nimport Mathlib.Algebra.Homology.QuasiIso\n\n/-!\n# Homology of the extension of an homological complex\n\nGiven an embedding `e : c.Embedding c'` and `K : HomologicalComplex C c`, we shall\ncompute the homology of `K.extend e`. In degrees that are not in the image of `e.f`,\nthe homology is obviously zero. When `e.f j = j`, we construct an isomorphism\n`(K.extend e).homology j' \u2245 K.homology j`.\n\n-/\n\nopen CategoryTheory Limits Category\n\nnamespace HomologicalComplex\n\nvariable {\u03b9 \u03b9' : Type*} {c : ComplexShape \u03b9} {c' : ComplexShape \u03b9'}\n  {C : Type*} [Category C] [HasZeroMorphisms C]\n  [HasZeroObject C]\n\nvariable (K L M : HomologicalComplex C c) (\u03c6 : K \u27f6 L) (\u03c6' : L \u27f6 M) (e : c.Embedding c')\n\nnamespace extend\n\nsection HomologyData\n\nvariable {i j k : \u03b9} {i' j' k' : \u03b9'} (hj' : e.f j = j')\n  (hi : c.prev j = i) (hi' : c'.prev j' = i') (hk : c.next j = k) (hk' : c'.next j' = k')\n\ninclude hk hk' in\nlemma comp_d_eq_zero_iff \u2983W : C\u2984 (\u03c6 : W \u27f6 K.X j) :\n    \u03c6 \u226b K.d j k = 0 \u2194 \u03c6 \u226b (K.extendXIso e hj').inv \u226b (K.extend e).d j' k' = 0 := by\n  by_cases hjk : c.Rel j k\n  \u00b7 have hk' : e.f k = k' := by rw [\u2190 hk', \u2190 hj', c'.next_eq' (e.rel hjk)]\n    rw [K.extend_d_eq e hj' hk', Iso.inv_hom_id_assoc,\n      \u2190 cancel_mono (K.extendXIso e hk').inv, zero_comp, assoc]\n  \u00b7 simp only [K.shape _ _ hjk, comp_zero, true_iff]\n    rw [K.extend_d_from_eq_zero e j' k' j hj', comp_zero, comp_zero]\n    rw [hk]\n    exact hjk\n\ninclude hi hi' in\nlemma d_comp_eq_zero_iff \u2983W : C\u2984 (\u03c6 : K.X j \u27f6 W) :\n    K.d i j \u226b \u03c6 = 0 \u2194 (K.extend e).d i' j' \u226b (K.extendXIso e hj').hom \u226b \u03c6 = 0 := by\n  by_cases hij : c.Rel i j\n  \u00b7 have hi' : e.f i = i' := by rw [\u2190 hi', \u2190 hj', c'.prev_eq' (e.rel hij)]\n    rw [K.extend_d_eq e hi' hj', assoc, assoc, Iso.inv_hom_id_assoc,\n      \u2190 cancel_epi (K.extendXIso e hi').hom, comp_zero]\n  \u00b7 simp only [K.shape _ _ hij, zero_comp, true_iff]\n    rw [K.extend_d_to_eq_zero e i' j' j hj', zero_comp]\n    rw [hi]\n    exact hij\n\nnamespace leftHomologyData\n\nvariable (cone : KernelFork (K.d j k)) (hcone : IsLimit cone)\n\n/-- The kernel fork of `(K.extend e).d j' k'` that is deduced from a kernel\nfork of `K.d j k `. -/\n@[simp]\nnoncomputable def kernelFork : KernelFork ((K.extend e).d j' k') :=\n  KernelFork.of\u03b9 (cone.\u03b9 \u226b (extendXIso K e hj').inv)\n    (by rw [assoc, \u2190 comp_d_eq_zero_iff K e hj' hk hk' cone.\u03b9, cone.condition])\n\n/-- The limit kernel fork of `(K.extend e).d j' k'` that is deduced from a limit\nkernel fork of `K.d j k `. -/\nnoncomputable def isLimitKernelFork : IsLimit (kernelFork K e hj' hk hk' cone) :=\n  KernelFork.isLimitOfIsLimitOfIff hcone ((K.extend e).d j' k')\n    (extendXIso K e hj').symm (comp_d_eq_zero_iff K e hj' hk hk')\n\nvariable (cocone : CokernelCofork (hcone.lift (KernelFork.of\u03b9 (K.d i j) (K.d_comp_d i j k))))\n  (hcocone : IsColimit cocone)\n\ninclude hi hi' hcone in\n/-- Auxiliary lemma for `lift_d_comp_eq_zero_iff`. -/\nlemma lift_d_comp_eq_zero_iff' \u2983W : C\u2984 (f' : K.X i \u27f6 cone.pt)\n    (hf' : f' \u226b cone.\u03b9 = K.d i j)\n    (f'' : (K.extend e).X i' \u27f6 cone.pt)\n    (hf'' : f'' \u226b cone.\u03b9 \u226b (extendXIso K e hj').inv = (K.extend e).d i' j')\n    (\u03c6 : cone.pt \u27f6 W) :\n    f' \u226b \u03c6 = 0 \u2194 f'' \u226b \u03c6 = 0 := by\n  by_cases hij : c.Rel i j\n  \u00b7 have hi'' : e.f i = i' := by rw [\u2190 hi', \u2190 hj', c'.prev_eq' (e.rel hij)]\n    have : (K.extendXIso e hi'').hom \u226b f' = f'' := by\n      apply Fork.IsLimit.hom_ext hcone\n      rw [assoc, hf', \u2190 cancel_mono (extendXIso K e hj').inv, assoc, assoc, hf'',\n        K.extend_d_eq e hi'' hj']\n    rw [\u2190 cancel_epi (K.extendXIso e hi'').hom, comp_zero, \u2190 this, assoc]\n  \u00b7 have h\u2081 : f' = 0 := by\n      apply Fork.IsLimit.hom_ext hcone\n      simp only [zero_comp, hf', K.shape _ _ hij]\n    have h\u2082 : f'' = 0 := by\n      apply Fork.IsLimit.hom_ext hcone\n      dsimp\n      rw [\u2190 cancel_mono (extendXIso K e hj').inv, assoc, hf'', zero_comp, zero_comp,\n        K.extend_d_to_eq_zero e i' j' j hj']\n      rw [hi]\n      exact hij\n    simp [h\u2081, h\u2082]\n\ninclude hi hi' in\nlemma lift_d_comp_eq_zero_iff \u2983W : C\u2984 (\u03c6 : cone.pt \u27f6 W) :\n    hcone.lift (KernelFork.of\u03b9 (K.d i j) (K.d_comp_d i j k)) \u226b \u03c6 = 0 \u2194\n      ((isLimitKernelFork K e hj' hk hk' cone hcone).lift\n      (KernelFork.of\u03b9 ((K.extend e).d i' j') (d_comp_d _ _ _ _))) \u226b \u03c6 = 0 :=\n  lift_d_comp_eq_zero_iff' K e hj' hi hi' cone hcone _ (hcone.fac _ _) _\n    (IsLimit.fac _ _ WalkingParallelPair.zero) _\n\n/-- Auxiliary definition for `extend.leftHomologyData`. -/\nnoncomputable def cokernelCofork :\n    CokernelCofork ((isLimitKernelFork K e hj' hk hk' cone hcone).lift\n      (KernelFork.of\u03b9 ((K.extend e).d i' j') (d_comp_d _ _ _ _))) :=\n  CokernelCofork.of\u03c0 cocone.\u03c0 (by\n    rw [\u2190 lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' cone hcone]\n    exact cocone.condition)\n\n/-- Auxiliary definition for `extend.leftHomologyData`. -/\nnoncomputable def isColimitCokernelCofork :\n    IsColimit (cokernelCofork K e hj' hi hi' hk hk' cone hcone cocone) :=\n  CokernelCofork.isColimitOfIsColimitOfIff' hcocone _\n    (lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' cone hcone)\n\nend leftHomologyData\n\nopen leftHomologyData in\n/-- The left homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a left homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def leftHomologyData (h : (K.sc' i j k).LeftHomologyData) :\n    ((K.extend e).sc' i' j' k').LeftHomologyData where\n  K := h.K\n  H := h.H\n  i := h.i \u226b (extendXIso K e hj').inv\n  \u03c0 := h.\u03c0\n  wi := by\n    dsimp\n    rw [assoc, \u2190 comp_d_eq_zero_iff K e hj' hk hk']\n    exact h.wi\n  hi := isLimitKernelFork K e hj' hk hk' _ h.hi\n  w\u03c0 := by\n    dsimp\n    rw [\u2190 lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' _ h.hi]\n    exact h.w\u03c0\n  h\u03c0 := isColimitCokernelCofork K e hj' hi hi' hk hk' _ h.hi _ h.h\u03c0\n\nnamespace rightHomologyData\n\nvariable (cocone : CokernelCofork (K.d i j)) (hcocone : IsColimit cocone)\n\n/-- The cokernel cofork of `(K.extend e).d i' j'` that is deduced from a cokernel\ncofork of `K.d i j`. -/\n@[simp]\nnoncomputable def cokernelCofork : CokernelCofork ((K.extend e).d i' j') :=\n  CokernelCofork.of\u03c0 ((extendXIso K e hj').hom \u226b cocone.\u03c0) (by\n    rw [\u2190 d_comp_eq_zero_iff K e hj' hi hi' cocone.\u03c0, cocone.condition])\n\n/-- The colimit cokernel cofork of `(K.extend e).d i' j'` that is deduced from a\ncolimit cokernel cofork of `K.d i j`. -/\nnoncomputable def isColimitCokernelCofork : IsColimit (cokernelCofork K e hj' hi hi' cocone) :=\n  CokernelCofork.isColimitOfIsColimitOfIff hcocone ((K.extend e).d i' j')\n    (extendXIso K e hj') (d_comp_eq_zero_iff K e hj' hi hi')\n\nvariable (cone : KernelFork (hcocone.desc (CokernelCofork.of\u03c0 (K.d j k) (K.d_comp_d i j k))))\n  (hcone : IsLimit cone)\n\ninclude hk hk' hcocone in\n", "theoremStatement": "lemma d_comp_desc_eq_zero_iff' \u2983W : C\u2984 (f' : cocone.pt \u27f6 K.X k)\n    (hf' : cocone.\u03c0 \u226b f' = K.d j k)\n    (f'' : cocone.pt \u27f6 (K.extend e).X k')\n    (hf'' : (extendXIso K e hj').hom \u226b cocone.\u03c0 \u226b f'' = (K.extend e).d j' k')\n    (\u03c6 : W \u27f6 cocone.pt) :\n    \u03c6 \u226b f' = 0 \u2194 \u03c6 \u226b f'' = 0 ", "theoremName": "HomologicalComplex.extend.rightHomologyData.d_comp_desc_eq_zero_iff'", "fileCreated": {"commit": "9bdc1af76cf75d960f42c29f1c09917785066c8b", "date": "2024-11-30"}, "theoremCreated": {"commit": "4e34721f6c89c3ff4282b58103694bbb523c209f", "date": "2024-12-20"}, "file": "mathlib/Mathlib/Algebra/Homology/Embedding/ExtendHomology.lean", "module": "Mathlib.Algebra.Homology.Embedding.ExtendHomology", "jsonFile": "Mathlib.Algebra.Homology.Embedding.ExtendHomology.jsonl", "positionMetadata": {"lineInFile": 174, "tokenPositionInFile": 6798, "theoremPositionInFile": 10}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 53, "numPremises": 76}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  by_cases hjk : c.Rel j k\n  \u00b7 have hk'' : e.f k = k' := by rw [\u2190 hk', \u2190 hj', c'.next_eq' (e.rel hjk)]\n    have : f' \u226b (K.extendXIso e hk'').inv = f'' := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      rw [reassoc_of% hf', \u2190 cancel_epi (extendXIso K e hj').hom, hf'',\n        K.extend_d_eq e hj' hk'']\n    rw [\u2190 cancel_mono (K.extendXIso e hk'').inv, zero_comp, assoc, this]\n  \u00b7 have h\u2081 : f' = 0 := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      simp only [hf', comp_zero, K.shape _ _ hjk]\n    have h\u2082 : f'' = 0 := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      rw [\u2190 cancel_epi (extendXIso K e hj').hom, hf'', comp_zero, comp_zero,\n        K.extend_d_from_eq_zero e j' k' j hj']\n      rw [hk]\n      exact hjk\n    simp [h\u2081, h\u2082]", "proofType": "tactic", "proofLengthLines": 17, "proofLengthTokens": 753}}
{"srcContext": "/-\nCopyright (c) 2024 Fangming Li. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Fangming Li, Jujian Zhang\n-/\nimport Mathlib.Algebra.Polynomial.AlgebraMap\nimport Mathlib.Algebra.Polynomial.Eval.SMul\nimport Mathlib.Algebra.Polynomial.Roots\nimport Mathlib.Order.Interval.Set.Infinite\nimport Mathlib.RingTheory.Polynomial.Pochhammer\nimport Mathlib.RingTheory.PowerSeries.WellKnown\nimport Mathlib.Tactic.FieldSimp\n\n/-!\n# Hilbert polynomials\n\nIn this file, we formalise the following statement: if `F` is a field with characteristic `0`, then\ngiven any `p : F[X]` and `d : \u2115`, there exists some `h : F[X]` such that for any large enough\n`n : \u2115`, `h(n)` is equal to the coefficient of `X\u207f` in the power series expansion of `p/(1 - X)\u1d48`.\nThis `h` is unique and is denoted as `Polynomial.hilbertPoly p d`.\n\nFor example, given `d : \u2115`, the power series expansion of `1/(1 - X)\u1d48\u207a\u00b9` in `F[X]`\nis `\u03a3\u2099 ((d + n).choose d)X\u207f`, which equals `\u03a3\u2099 ((n + 1)\u00b7\u00b7\u00b7(n + d)/d!)X\u207f` and hence\n`Polynomial.hilbertPoly (1 : F[X]) (d + 1)` is the polynomial `(X + 1)\u00b7\u00b7\u00b7(X + d)/d!`. Note that\nif `d! = 0` in `F`, then the polynomial `(X + 1)\u00b7\u00b7\u00b7(X + d)/d!` no longer works, so we do not want\nthe characteristic of `F` to be divisible by `d!`. As `Polynomial.hilbertPoly` may take any\n`p : F[X]` and `d : \u2115` as its inputs, it is necessary for us to assume that `CharZero F`.\n\n## Main definitions\n\n* `Polynomial.hilbertPoly p d`. Given a field `F`, a polynomial `p : F[X]` and a natural number `d`,\n  if `F` is of characteristic `0`, then `Polynomial.hilbertPoly p d : F[X]` is the polynomial whose\n  value at `n` equals the coefficient of `X\u207f` in the power series expansion of `p/(1 - X)\u1d48`.\n\n## TODO\n\n* Hilbert polynomials of finitely generated graded modules over Noetherian rings.\n-/\n\nopen Nat PowerSeries\n\nvariable (F : Type*) [Field F]\n\nnamespace Polynomial\n\n/--\nFor any field `F` and natural numbers `d` and `k`, `Polynomial.preHilbertPoly F d k`\nis defined as `(d.factorial : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (X - (C (k : F)) + 1))`.\nThis is the most basic form of Hilbert polynomials. `Polynomial.preHilbertPoly \u211a d 0`\nis exactly the Hilbert polynomial of the polynomial ring `\u211a[X_0,...,X_d]` viewed as\na graded module over itself. In fact, `Polynomial.preHilbertPoly F d k` is the\nsame as `Polynomial.hilbertPoly ((X : F[X]) ^ k) (d + 1)` for any field `F` and\n`d k : \u2115` (see the lemma `Polynomial.hilbertPoly_X_pow_succ`). See also the lemma\n`Polynomial.preHilbertPoly_eq_choose_sub_add`, which states that if `CharZero F`,\nthen for any `d k n : \u2115` with `k \u2264 n`, `(Polynomial.preHilbertPoly F d k).eval (n : F)`\nequals `(n - k + d).choose d`.\n-/\nnoncomputable def preHilbertPoly (d k : \u2115) : F[X] :=\n  (d.factorial : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (Polynomial.X - (C (k : F)) + 1))\n\nlemma natDegree_preHilbertPoly [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).natDegree = d := by\n  have hne : (d ! : F) \u2260 0 := by norm_cast; positivity\n  rw [preHilbertPoly, natDegree_smul _ (inv_ne_zero hne), natDegree_comp, ascPochhammer_natDegree,\n    add_comm_sub, \u2190 C_1, \u2190 map_sub, natDegree_add_C, natDegree_X, mul_one]\n\nlemma coeff_preHilbertPoly_self [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).coeff d = (d ! : F)\u207b\u00b9 := by\n  delta preHilbertPoly\n  have hne : (d ! : F) \u2260 0 := by norm_cast; positivity\n  have heq : d = ((ascPochhammer F d).comp (X - C (k : F) + 1)).natDegree :=\n    (natDegree_preHilbertPoly F d k).symm.trans (natDegree_smul _ (inv_ne_zero hne))\n  nth_rw 3 [heq]\n  calc\n  _ = (d ! : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (X - C ((k : F) - 1))).leadingCoeff := by\n    simp only [sub_add, \u2190 C_1, \u2190 map_sub, coeff_smul, coeff_natDegree]\n  _ = (d ! : F)\u207b\u00b9 := by\n    simp only [leadingCoeff_comp (ne_of_eq_of_ne (natDegree_X_sub_C _) one_ne_zero), Monic.def.1\n      (monic_ascPochhammer _ _), one_mul, leadingCoeff_X_sub_C, one_pow, smul_eq_mul, mul_one]\n\nlemma leadingCoeff_preHilbertPoly [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).leadingCoeff = (d ! : F)\u207b\u00b9 := by\n  rw [leadingCoeff, natDegree_preHilbertPoly, coeff_preHilbertPoly_self]\n\nlemma preHilbertPoly_eq_choose_sub_add [CharZero F] (d : \u2115) {k n : \u2115} (hkn : k \u2264 n):\n    (preHilbertPoly F d k).eval (n : F) = (n - k + d).choose d := by\n  have : (d ! : F) \u2260 0 := by norm_cast; positivity\n  calc\n  _ = (\u2191d !)\u207b\u00b9 * eval (\u2191(n - k + 1)) (ascPochhammer F d) := by simp [cast_sub hkn, preHilbertPoly]\n  _ = (n - k + d).choose d := by\n    rw [ascPochhammer_nat_eq_natCast_ascFactorial];\n    field_simp [ascFactorial_eq_factorial_mul_choose]\n\nvariable {F}\n\n/--\n`Polynomial.hilbertPoly p 0 = 0`; for any `d : \u2115`, `Polynomial.hilbertPoly p (d + 1)`\nis defined as `\u2211 i \u2208 p.support, (p.coeff i) \u2022 Polynomial.preHilbertPoly F d i`. If\n`M` is a graded module whose Poincar\u00e9 series can be written as `p(X)/(1 - X)\u1d48` for some\n`p : \u211a[X]` with integer coefficients, then `Polynomial.hilbertPoly p d` is the Hilbert\npolynomial of `M`. See also `Polynomial.coeff_mul_invOneSubPow_eq_hilbertPoly_eval`,\nwhich says that `PowerSeries.coeff F n (p * PowerSeries.invOneSubPow F d)` equals\n`(Polynomial.hilbertPoly p d).eval (n : F)` for any large enough `n : \u2115`.\n-/\nnoncomputable def hilbertPoly (p : F[X]) : (d : \u2115) \u2192 F[X]\n  | 0 => 0\n  | d + 1 => \u2211 i \u2208 p.support, (p.coeff i) \u2022 preHilbertPoly F d i\n\nlemma hilbertPoly_zero_left (d : \u2115) : hilbertPoly (0 : F[X]) d = 0 := by\n  delta hilbertPoly; induction d with\n  | zero => simp only\n  | succ d _ => simp only [coeff_zero, zero_smul, Finset.sum_const_zero]\n\nlemma hilbertPoly_zero_right (p : F[X]) : hilbertPoly p 0 = 0 := rfl\n\nlemma hilbertPoly_succ (p : F[X]) (d : \u2115) :\n    hilbertPoly p (d + 1) = \u2211 i \u2208 p.support, (p.coeff i) \u2022 preHilbertPoly F d i := rfl\n\nlemma hilbertPoly_X_pow_succ (d k : \u2115) :\n    hilbertPoly ((X : F[X]) ^ k) (d + 1) = preHilbertPoly F d k := by\n  delta hilbertPoly; simp\n\nlemma hilbertPoly_add_left (p q : F[X]) (d : \u2115) :\n    hilbertPoly (p + q) d = hilbertPoly p d + hilbertPoly q d := by\n  delta hilbertPoly\n  induction d with\n  | zero => simp only [add_zero]\n  | succ d _ =>\n      simp only [\u2190 coeff_add]\n      rw [\u2190 sum_def _ fun _ r => r \u2022 _]\n      exact sum_add_index _ _ _ (fun _ => zero_smul ..) (fun _ _ _ => add_smul ..)\n\nlemma hilbertPoly_smul (a : F) (p : F[X]) (d : \u2115) :\n    hilbertPoly (a \u2022 p) d = a \u2022 hilbertPoly p d := by\n  delta hilbertPoly\n  induction d with\n  | zero => simp only [smul_zero]\n  | succ d _ =>\n      simp only\n      rw [\u2190 sum_def _ fun _ r => r \u2022 _, \u2190 sum_def _ fun _ r => r \u2022 _, Polynomial.smul_sum,\n        sum_smul_index' _ _ _ fun i => zero_smul F (preHilbertPoly F d i)]\n      simp only [smul_assoc]\n\nvariable (F) in\n/--\nThe function that sends any `p : F[X]` to `Polynomial.hilbertPoly p d` is an `F`-linear map from\n`F[X]` to `F[X]`.\n-/\nnoncomputable def hilbertPoly_linearMap (d : \u2115) : F[X] \u2192\u2097[F] F[X] where\n  toFun p := hilbertPoly p d\n  map_add' p q := hilbertPoly_add_left p q d\n  map_smul' r p := hilbertPoly_smul r p d\n\nvariable [CharZero F]\n\n/--\nThe key property of Hilbert polynomials. If `F` is a field with characteristic `0`, `p : F[X]` and\n`d : \u2115`, then for any large enough `n : \u2115`, `(Polynomial.hilbertPoly p d).eval (n : F)` equals the\ncoefficient of `X\u207f` in the power series expansion of `p/(1 - X)\u1d48`.\n-/\ntheorem coeff_mul_invOneSubPow_eq_hilbertPoly_eval\n    {p : F[X]} (d : \u2115) {n : \u2115} (hn : p.natDegree < n) :\n    PowerSeries.coeff F n (p * invOneSubPow F d) = (hilbertPoly p d).eval (n : F) := by\n  delta hilbertPoly; induction d with\n  | zero => simp only [invOneSubPow_zero, Units.val_one, mul_one, coeff_coe, eval_zero]\n            exact coeff_eq_zero_of_natDegree_lt hn\n  | succ d hd =>\n      simp only [eval_finset_sum, eval_smul, smul_eq_mul]\n      rw [\u2190 Finset.sum_coe_sort]\n      have h_le (i : p.support) : (i : \u2115) \u2264 n :=\n        le_trans (le_natDegree_of_ne_zero <| mem_support_iff.1 i.2) hn.le\n      have h (i : p.support) : eval \u2191n (preHilbertPoly F d \u2191i) = (n + d - \u2191i).choose d := by\n        rw [preHilbertPoly_eq_choose_sub_add _ _ (h_le i), Nat.sub_add_comm (h_le i)]\n      simp_rw [h]\n      rw [Finset.sum_coe_sort _ (fun x => (p.coeff \u2191x) * (_ + d - \u2191x).choose _),\n        PowerSeries.coeff_mul, Finset.Nat.sum_antidiagonal_eq_sum_range_succ_mk,\n        invOneSubPow_val_eq_mk_sub_one_add_choose_of_pos _ _ (zero_lt_succ d)]\n      simp only [coeff_coe, coeff_mk]\n      symm\n      refine Finset.sum_subset_zero_on_sdiff (fun s hs \u21a6 ?_) (fun x hx \u21a6 ?_) (fun x hx \u21a6 ?_)\n      \u00b7 rw [Finset.mem_range_succ_iff]\n        exact h_le \u27e8s, hs\u27e9\n      \u00b7 simp only [Finset.mem_sdiff, mem_support_iff, not_not] at hx\n        rw [hx.2, zero_mul]\n      \u00b7 rw [add_comm, Nat.add_sub_assoc (h_le \u27e8x, hx\u27e9), succ_eq_add_one, add_tsub_cancel_right]\n\n/--\nThe polynomial satisfying the key property of `Polynomial.hilbertPoly p d` is unique.\n-/\ntheorem existsUnique_hilbertPoly (p : F[X]) (d : \u2115) :\n    \u2203! h : F[X], \u2203 N : \u2115, \u2200 n > N,\n    PowerSeries.coeff F n (p * invOneSubPow F d) = h.eval (n : F) := by\n  use hilbertPoly p d; constructor\n  \u00b7 use p.natDegree\n    exact fun n => coeff_mul_invOneSubPow_eq_hilbertPoly_eval d\n  \u00b7 rintro h \u27e8N, hhN\u27e9\n    apply eq_of_infinite_eval_eq h (hilbertPoly p d)\n    apply ((Set.Ioi_infinite (max N p.natDegree)).image cast_injective.injOn).mono\n    rintro x \u27e8n, hn, rfl\u27e9\n    simp only [Set.mem_Ioi, sup_lt_iff, Set.mem_setOf_eq] at hn \u22a2\n    rw [\u2190 coeff_mul_invOneSubPow_eq_hilbertPoly_eval d hn.2, hhN n hn.1]\n\n@[deprecated (since := \"2024-12-17\")] alias exists_unique_hilbertPoly := existsUnique_hilbertPoly\n\n/--\nIf `h : F[X]` and there exists some `N : \u2115` such that for any number `n : \u2115` bigger than `N`\nwe have `PowerSeries.coeff F n (p * invOneSubPow F d) = h.eval (n : F)`, then `h` is exactly\n`Polynomial.hilbertPoly p d`.\n-/\ntheorem eq_hilbertPoly_of_forall_coeff_eq_eval\n    {p h : F[X]} {d : \u2115} (N : \u2115) (hhN : \u2200 n > N,\n    PowerSeries.coeff F n (p * invOneSubPow F d) = h.eval (n : F)) :\n    h = hilbertPoly p d :=\n  ExistsUnique.unique (existsUnique_hilbertPoly p d) \u27e8N, hhN\u27e9\n    \u27e8p.natDegree, fun _ x => coeff_mul_invOneSubPow_eq_hilbertPoly_eval d x\u27e9\n\n", "theoremStatement": "lemma hilbertPoly_mul_one_sub_succ (p : F[X]) (d : \u2115) :\n    hilbertPoly (p * (1 - X)) (d + 1) = hilbertPoly p d ", "theoremName": "Polynomial.hilbertPoly_mul_one_sub_succ", "fileCreated": {"commit": "561e050467d2caa2e4ea5d81ca62600bf268b747", "date": "2024-12-02"}, "theoremCreated": {"commit": "7a05b449ac13af0118fd6b2c133d08e33e7e74ad", "date": "2024-12-04"}, "file": "mathlib/Mathlib/RingTheory/Polynomial/HilbertPoly.lean", "module": "Mathlib.RingTheory.Polynomial.HilbertPoly", "jsonFile": "Mathlib.RingTheory.Polynomial.HilbertPoly.jsonl", "positionMetadata": {"lineInFile": 217, "tokenPositionInFile": 10011, "theoremPositionInFile": 14}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 66, "numPremises": 94}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  apply eq_hilbertPoly_of_forall_coeff_eq_eval (p * (1 - X)).natDegree\n  intro n hn\n  have heq : 1 - PowerSeries.X = ((1 - X : F[X]) : F\u27e6X\u27e7) := by simp only [coe_sub, coe_one, coe_X]\n  rw [\u2190 one_sub_pow_mul_invOneSubPow_val_add_eq_invOneSubPow_val F d 1, pow_one, \u2190 mul_assoc, heq,\n    \u2190 coe_mul, coeff_mul_invOneSubPow_eq_hilbertPoly_eval (d + 1) hn]", "proofType": "tactic", "proofLengthLines": 5, "proofLengthTokens": 357}}
{"srcContext": "/-\nCopyright (c) 2024 Xavier Roblot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Xavier Roblot\n-/\nimport Mathlib.Analysis.BoxIntegral.UnitPartition\nimport Mathlib.MeasureTheory.Measure.Haar.InnerProductSpace\n\n/-!\n# Covolume of \u2124-lattices\n\nLet `E` be a finite dimensional real vector space.\n\nLet `L` be a `\u2124`-lattice `L` defined as a discrete `\u2124`-submodule of `E` that spans `E` over `\u211d`.\n\n## Main definitions and results\n\n* `ZLattice.covolume`: the covolume of `L` defined as the volume of an arbitrary fundamental\ndomain of `L`.\n\n* `ZLattice.covolume_eq_measure_fundamentalDomain`: the covolume of `L` does not depend on the\nchoice of the fundamental domain of `L`.\n\n* `ZLattice.covolume_eq_det`: if `L` is a lattice in `\u211d^n`, then its covolume is the absolute\nvalue of the determinant of any `\u2124`-basis of `L`.\n\n* `ZLattice.covolume.tendsto_card_div_pow`: Let `s` be a bounded measurable set of `\u03b9 \u2192 \u211d`, then\nthe number of points in `s \u2229 n\u207b\u00b9 \u2022 L` divided by `n ^ card \u03b9` tends to `volume s / covolume L`\nwhen `n : \u2115` tends to infinity. See also `ZLattice.covolume.tendsto_card_div_pow'` for a version\nfor `InnerProductSpace \u211d E` and `ZLattice.covolume.tendsto_card_div_pow''` for the general version.\n\n* `ZLattice.covolume.tendsto_card_le_div`: Let `X` be a cone in `\u03b9 \u2192 \u211d` and let `F : (\u03b9 \u2192 \u211d) \u2192 \u211d`\nbe a function such that `F (c \u2022 x) = c ^ card \u03b9 * F x`. Then the number of points `x \u2208 X` such that\n`F x \u2264 c` divided by `c` tends to `volume {x \u2208 X | F x \u2264 1} / covolume L` when `c : \u211d` tends to\ninfinity. See also `ZLattice.covolume.tendsto_card_le_div'` for a version for\n`InnerProductSpace \u211d E` and `ZLattice.covolume.tendsto_card_le_div''` for the general version.\n\n## Naming convention\n\nSome results are true in the case where the ambient finite dimensional real vector space is the\npi-space `\u03b9 \u2192 \u211d` and in the case where it is an `InnerProductSpace`. We use the following\nconvention: the plain name is for the pi case, for eg. `volume_image_eq_volume_div_covolume`. For\nthe same result in the `InnerProductSpace` case, we add a `prime`, for eg.\n`volume_image_eq_volume_div_covolume'`. When the same result exists in the\ngeneral case, we had two primes, eg. `covolume.tendsto_card_div_pow''`.\n\n-/\n\nnoncomputable section\n\nnamespace ZLattice\n\nopen Submodule MeasureTheory Module MeasureTheory Module ZSpan\n\nsection General\n\nvariable {E : Type*} [NormedAddCommGroup E] [MeasurableSpace E] (L : Submodule \u2124 E)\n\n/-- The covolume of a `\u2124`-lattice is the volume of some fundamental domain; see\n`ZLattice.covolume_eq_volume` for the proof that the volume does not depend on the choice of\nthe fundamental domain. -/\ndef covolume (\u03bc : Measure E := by volume_tac) : \u211d := (addCovolume L E \u03bc).toReal\n\nend General\n\nsection Basic\n\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] [FiniteDimensional \u211d E]\nvariable [MeasurableSpace E] [BorelSpace E]\nvariable (L : Submodule \u2124 E) [DiscreteTopology L] [IsZLattice \u211d L]\nvariable (\u03bc : Measure E := by volume_tac) [Measure.IsAddHaarMeasure \u03bc]\n\ntheorem covolume_eq_measure_fundamentalDomain {F : Set E} (h : IsAddFundamentalDomain L F \u03bc) :\n    covolume L \u03bc = (\u03bc F).toReal := by\n  have : MeasurableVAdd L E := (inferInstance : MeasurableVAdd L.toAddSubgroup E)\n  have : VAddInvariantMeasure L E \u03bc := (inferInstance : VAddInvariantMeasure L.toAddSubgroup E \u03bc)\n  exact congr_arg ENNReal.toReal (h.covolume_eq_volume \u03bc)\n\ntheorem covolume_ne_zero : covolume L \u03bc \u2260 0 := by\n  rw [covolume_eq_measure_fundamentalDomain L \u03bc (isAddFundamentalDomain (Free.chooseBasis \u2124 L) \u03bc),\n    ENNReal.toReal_ne_zero]\n  refine \u27e8measure_fundamentalDomain_ne_zero _, ne_of_lt ?_\u27e9\n  exact Bornology.IsBounded.measure_lt_top (fundamentalDomain_isBounded _)\n\ntheorem covolume_pos : 0 < covolume L \u03bc :=\n  lt_of_le_of_ne ENNReal.toReal_nonneg (covolume_ne_zero L \u03bc).symm\n\ntheorem covolume_comap {F : Type*} [NormedAddCommGroup F] [NormedSpace \u211d F] [FiniteDimensional \u211d F]\n    [MeasurableSpace F] [BorelSpace F] (\u03bd : Measure F := by volume_tac) [Measure.IsAddHaarMeasure \u03bd]\n    {e : F \u2243L[\u211d] E} (he : MeasurePreserving e \u03bd \u03bc) :\n    covolume (ZLattice.comap \u211d L e.toLinearMap) \u03bd = covolume L \u03bc := by\n  rw [covolume_eq_measure_fundamentalDomain _ _ (isAddFundamentalDomain (Free.chooseBasis \u2124 L) \u03bc),\n    covolume_eq_measure_fundamentalDomain _ _ ((isAddFundamentalDomain\n    ((Free.chooseBasis \u2124 L).ofZLatticeComap \u211d L e.toLinearEquiv) \u03bd)), \u2190 he.measure_preimage\n    (fundamentalDomain_measurableSet _).nullMeasurableSet, \u2190 e.image_symm_eq_preimage,\n    \u2190 e.symm.coe_toLinearEquiv, map_fundamentalDomain]\n  congr!\n  ext; simp\n\ntheorem covolume_eq_det_mul_measure {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (b : Basis \u03b9 \u2124 L)\n    (b\u2080 : Basis \u03b9 \u211d E) :\n    covolume L \u03bc = |b\u2080.det ((\u2191) \u2218 b)| * (\u03bc (fundamentalDomain b\u2080)).toReal := by\n  rw [covolume_eq_measure_fundamentalDomain L \u03bc (isAddFundamentalDomain b \u03bc),\n    measure_fundamentalDomain _ _ b\u2080,\n    measure_congr (fundamentalDomain_ae_parallelepiped b\u2080 \u03bc), ENNReal.toReal_mul,\n    ENNReal.toReal_ofReal (by positivity)]\n  congr\n  ext\n  exact b.ofZLatticeBasis_apply \u211d L _\n\ntheorem covolume_eq_det {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (L : Submodule \u2124 (\u03b9 \u2192 \u211d))\n    [DiscreteTopology L] [IsZLattice \u211d L] (b : Basis \u03b9 \u2124 L) :\n    covolume L = |(Matrix.of ((\u2191) \u2218 b)).det| := by\n  rw [covolume_eq_measure_fundamentalDomain L volume (isAddFundamentalDomain b volume),\n    volume_fundamentalDomain, ENNReal.toReal_ofReal (by positivity)]\n  congr\n  ext1\n  exact b.ofZLatticeBasis_apply \u211d L _\n\ntheorem covolume_eq_det_inv {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (L : Submodule \u2124 (\u03b9 \u2192 \u211d))\n    [DiscreteTopology L] [IsZLattice \u211d L] (b : Basis \u03b9 \u2124 L) :\n    covolume L = |(LinearEquiv.det (b.ofZLatticeBasis \u211d L).equivFun : \u211d)|\u207b\u00b9 := by\n  rw [covolume_eq_det L b, \u2190 Pi.basisFun_det_apply, show (((\u2191) : L \u2192 _) \u2218 \u21d1b) =\n    (b.ofZLatticeBasis \u211d) by ext; simp, \u2190 Basis.det_inv, \u2190 abs_inv, Units.val_inv_eq_inv_val,\n    IsUnit.unit_spec, \u2190 Basis.det_basis, LinearEquiv.coe_det]\n  rfl\n\ntheorem volume_image_eq_volume_div_covolume {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9]\n    (L : Submodule \u2124 (\u03b9 \u2192 \u211d)) [DiscreteTopology L] [IsZLattice \u211d L] (b : Basis \u03b9 \u2124 L)\n    {s : Set (\u03b9 \u2192 \u211d)} :\n    volume ((b.ofZLatticeBasis \u211d L).equivFun '' s) = volume s / ENNReal.ofReal (covolume L) := by\n  rw [LinearEquiv.image_eq_preimage, Measure.addHaar_preimage_linearEquiv, LinearEquiv.symm_symm,\n    covolume_eq_det_inv L b, ENNReal.div_eq_inv_mul, ENNReal.ofReal_inv_of_pos\n    (abs_pos.mpr (LinearEquiv.det _).ne_zero), inv_inv, LinearEquiv.coe_det]\n\n/-- A more general version of `ZLattice.volume_image_eq_volume_div_covolume`;\nsee the `Naming conventions` section in the introduction. -/\ntheorem volume_image_eq_volume_div_covolume' {E : Type*} [NormedAddCommGroup E]\n    [InnerProductSpace \u211d E] [FiniteDimensional \u211d E] [MeasurableSpace E] [BorelSpace E]\n    (L : Submodule \u2124 E) [DiscreteTopology L] [IsZLattice \u211d L] {\u03b9 : Type*} [Fintype \u03b9]\n    (b : Basis \u03b9 \u2124 L) {s : Set E} (hs : NullMeasurableSet s) :\n    volume ((b.ofZLatticeBasis \u211d).equivFun '' s) = volume s / ENNReal.ofReal (covolume L) := by\n  classical\n  let e : Fin (finrank \u211d E) \u2243 \u03b9 :=\n    Fintype.equivOfCardEq (by rw [Fintype.card_fin, finrank_eq_card_basis (b.ofZLatticeBasis \u211d)])\n  let f := (EuclideanSpace.equiv \u03b9 \u211d).symm.trans\n    ((stdOrthonormalBasis \u211d E).reindex e).repr.toContinuousLinearEquiv.symm\n  have hf : MeasurePreserving f :=\n    ((stdOrthonormalBasis \u211d E).reindex e).measurePreserving_repr_symm.comp\n      (EuclideanSpace.volume_preserving_measurableEquiv \u03b9).symm\n  rw [\u2190 hf.measure_preimage hs, \u2190 (covolume_comap L volume volume hf),\n    \u2190 volume_image_eq_volume_div_covolume (ZLattice.comap \u211d L f.toLinearMap)\n    (b.ofZLatticeComap \u211d L f.toLinearEquiv), Basis.ofZLatticeBasis_comap,\n    \u2190 f.image_symm_eq_preimage, \u2190 Set.image_comp]\n  simp only [Basis.equivFun_apply, ContinuousLinearEquiv.symm_toLinearEquiv, Basis.map_equivFun,\n    LinearEquiv.symm_symm, Function.comp_apply, LinearEquiv.trans_apply,\n    ContinuousLinearEquiv.coe_toLinearEquiv, ContinuousLinearEquiv.apply_symm_apply]\n\nend Basic\n\nnamespace covolume\n\nsection General\n\nopen Filter Fintype Pointwise Topology BoxIntegral Bornology\n\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]\nvariable {L : Submodule \u2124 E} [DiscreteTopology L] [IsZLattice \u211d L]\nvariable {\u03b9 : Type*} [Fintype \u03b9] (b : Basis \u03b9 \u2124 L)\n\n/-- A version of `ZLattice.covolume.tendsto_card_div_pow` for the general case;\nsee the `Naming convention` section in the introduction. -/\ntheorem tendsto_card_div_pow'' [FiniteDimensional \u211d E] [MeasurableSpace E] [BorelSpace E]\n    {s : Set E} (hs\u2081 : IsBounded s) (hs\u2082 : MeasurableSet s)\n    (hs\u2083 : volume (frontier ((b.ofZLatticeBasis \u211d).equivFun '' s)) = 0):\n    Tendsto (fun n : \u2115 \u21a6 (Nat.card (s \u2229 (n : \u211d)\u207b\u00b9 \u2022 L : Set E) : \u211d) / n ^ card \u03b9)\n      atTop (\ud835\udcdd (volume ((b.ofZLatticeBasis \u211d).equivFun '' s)).toReal) := by\n  refine Tendsto.congr' ?_\n    (tendsto_card_div_pow_atTop_volume ((b.ofZLatticeBasis \u211d).equivFun '' s) ?_ ?_ hs\u2083)\n  \u00b7 filter_upwards [eventually_gt_atTop 0] with n hn\n    congr\n    refine Nat.card_congr <| ((b.ofZLatticeBasis \u211d).equivFun.toEquiv.subtypeEquiv fun x \u21a6 ?_).symm\n    simp_rw [Set.mem_inter_iff, \u2190 b.ofZLatticeBasis_span \u211d, LinearEquiv.coe_toEquiv,\n      Basis.equivFun_apply, Set.mem_image, DFunLike.coe_fn_eq, EmbeddingLike.apply_eq_iff_eq,\n      exists_eq_right, and_congr_right_iff, Set.mem_inv_smul_set_iff\u2080\n      (mod_cast hn.ne' : (n : \u211d) \u2260 0), \u2190 Finsupp.coe_smul, \u2190 LinearEquiv.map_smul, SetLike.mem_coe,\n      Basis.mem_span_iff_repr_mem, Pi.basisFun_repr, implies_true]\n  \u00b7 rw [\u2190 NormedSpace.isVonNBounded_iff \u211d] at hs\u2081 \u22a2\n    exact Bornology.IsVonNBounded.image hs\u2081 ((b.ofZLatticeBasis \u211d).equivFunL : E \u2192L[\u211d] \u03b9 \u2192 \u211d)\n  \u00b7 exact (b.ofZLatticeBasis \u211d).equivFunL.toHomeomorph.toMeasurableEquiv.measurableSet_image.mpr hs\u2082\n\nprivate theorem tendsto_card_le_div''_aux {X : Set E} (hX : \u2200 \u2983x\u2984 \u2983r:\u211d\u2984, x \u2208 X \u2192 0 < r \u2192 r \u2022 x \u2208 X)\n    {F : E \u2192 \u211d} (hF\u2081 : \u2200 x \u2983r : \u211d\u2984, 0 \u2264 r \u2192 F (r \u2022 x) = r ^ card \u03b9 * (F x)) {c : \u211d} (hc : 0 < c) :\n    c \u2022 {x \u2208 X | F x \u2264 1} = {x \u2208 X | F x \u2264 c ^ card \u03b9} := by\n  ext x\n  simp_rw [Set.mem_smul_set_iff_inv_smul_mem\u2080 hc.ne', Set.mem_setOf_eq, hF\u2081 _\n    (inv_pos_of_pos hc).le, inv_pow, inv_mul_le_iff\u2080 (pow_pos hc _), mul_one, and_congr_left_iff]\n  exact fun _ \u21a6 \u27e8fun h \u21a6 (smul_inv_smul\u2080 hc.ne' x) \u25b8 hX h hc, fun h \u21a6 hX h (inv_pos_of_pos hc)\u27e9\n\n/-- A version of `ZLattice.covolume.tendsto_card_le_div` for the general case;\nsee the `Naming conventions` section in the introduction. -/\ntheorem tendsto_card_le_div'' [FiniteDimensional \u211d E] [MeasurableSpace E] [BorelSpace E]\n    [Nonempty \u03b9] {X : Set E} (hX : \u2200 \u2983x\u2984 \u2983r : \u211d\u2984, x \u2208 X \u2192 0 < r \u2192 r \u2022 x \u2208 X)\n    {F : E \u2192 \u211d} (h\u2081 : \u2200 x \u2983r : \u211d\u2984, 0 \u2264 r \u2192  F (r \u2022 x) = r ^ card \u03b9 * (F x))\n    (h\u2082 : IsBounded {x \u2208 X | F x \u2264 1}) (h\u2083 : MeasurableSet {x \u2208 X | F x \u2264 1})\n    (h\u2084 : volume (frontier ((b.ofZLatticeBasis \u211d L).equivFun '' {x | x \u2208 X \u2227 F x \u2264 1})) = 0) :\n    Tendsto (fun c : \u211d \u21a6\n      Nat.card ({x \u2208 X | F x \u2264 c} \u2229 L : Set E) / (c : \u211d))\n        atTop (\ud835\udcdd (volume ((b.ofZLatticeBasis \u211d).equivFun '' {x \u2208 X | F x \u2264 1})).toReal) := by\n\n  refine Tendsto.congr' ?_ <| (tendsto_card_div_pow_atTop_volume'\n      ((b.ofZLatticeBasis \u211d).equivFun '' {x \u2208 X | F x \u2264 1}) ?_ ?_ h\u2084 fun x y hx hy \u21a6 ?_).comp\n        (tendsto_rpow_atTop <| inv_pos.mpr\n          (Nat.cast_pos.mpr card_pos) : Tendsto (fun x \u21a6 x ^ (card \u03b9 : \u211d)\u207b\u00b9) atTop atTop)\n  \u00b7 filter_upwards [eventually_gt_atTop 0] with c hc\n    have aux\u2081 : (card \u03b9 : \u211d) \u2260 0 := Nat.cast_ne_zero.mpr card_ne_zero\n    have aux\u2082 : 0 < c ^ (card \u03b9 : \u211d)\u207b\u00b9 := Real.rpow_pos_of_pos hc _\n    have aux\u2083 : (c ^ (card \u03b9 : \u211d)\u207b\u00b9)\u207b\u00b9 \u2260 0 := inv_ne_zero aux\u2082.ne'\n    have aux\u2084 : c ^ (-(card \u03b9 : \u211d)\u207b\u00b9) \u2260 0 := (Real.rpow_pos_of_pos hc _).ne'\n    obtain \u27e8hc\u2081, hc\u2082\u27e9 := lt_iff_le_and_ne.mp hc\n    rw [Function.comp_apply, \u2190 Real.rpow_natCast, Real.rpow_inv_rpow hc\u2081 aux\u2081, eq_comm]\n    congr\n    refine Nat.card_congr <| Equiv.subtypeEquiv ((b.ofZLatticeBasis \u211d).equivFun.toEquiv.trans\n          (Equiv.smulRight aux\u2084)) fun _ \u21a6 ?_\n    rw [Set.mem_inter_iff, Set.mem_inter_iff, Equiv.trans_apply, LinearEquiv.coe_toEquiv,\n      Equiv.smulRight_apply, Real.rpow_neg hc\u2081, Set.smul_mem_smul_set_iff\u2080 aux\u2083,\n      \u2190 Set.mem_smul_set_iff_inv_smul_mem\u2080 aux\u2082.ne', \u2190 image_smul_set,\n      tendsto_card_le_div''_aux hX h\u2081 aux\u2082, \u2190 Real.rpow_natCast, \u2190 Real.rpow_mul hc\u2081,\n      inv_mul_cancel\u2080 aux\u2081, Real.rpow_one]\n    simp_rw [SetLike.mem_coe, Set.mem_image, EmbeddingLike.apply_eq_iff_eq, exists_eq_right,\n      and_congr_right_iff, \u2190 b.ofZLatticeBasis_span \u211d, Basis.mem_span_iff_repr_mem,\n      Pi.basisFun_repr, Basis.equivFun_apply, implies_true]\n  \u00b7 rw [\u2190 NormedSpace.isVonNBounded_iff \u211d] at h\u2082 \u22a2\n    exact Bornology.IsVonNBounded.image h\u2082 ((b.ofZLatticeBasis \u211d).equivFunL : E \u2192L[\u211d] \u03b9 \u2192 \u211d)\n  \u00b7 exact (b.ofZLatticeBasis \u211d).equivFunL.toHomeomorph.toMeasurableEquiv.measurableSet_image.mpr h\u2083\n  \u00b7 simp_rw [\u2190 image_smul_set]\n    apply Set.image_mono\n    rw [tendsto_card_le_div''_aux hX h\u2081 hx,\n      tendsto_card_le_div''_aux hX h\u2081 (lt_of_lt_of_le hx hy)]\n    exact fun a \u27e8ha\u2081, ha\u2082\u27e9 \u21a6 \u27e8ha\u2081, le_trans ha\u2082 <| pow_le_pow_left\u2080 (le_of_lt hx) hy _\u27e9\n\nend General\n\nsection Pi\n\nopen Filter Fintype Pointwise Topology Bornology\n\nprivate theorem frontier_equivFun {E : Type*} [AddCommGroup E] [Module \u211d E] {\u03b9 : Type*} [Fintype \u03b9]\n    [TopologicalSpace E] [TopologicalAddGroup E] [ContinuousSMul \u211d E] [T2Space E]\n    (b : Basis \u03b9 \u211d E) (s : Set E) :\n    frontier (b.equivFun '' s) = b.equivFun '' (frontier s) := by\n  rw [LinearEquiv.image_eq_preimage, LinearEquiv.image_eq_preimage]\n  exact (Homeomorph.preimage_frontier b.equivFunL.toHomeomorph.symm s).symm\n\nvariable {\u03b9 : Type*} [Fintype \u03b9]\nvariable (L : Submodule \u2124 (\u03b9 \u2192 \u211d)) [DiscreteTopology L] [IsZLattice \u211d L]\n\ntheorem tendsto_card_div_pow (b : Basis \u03b9 \u2124 L) {s : Set (\u03b9 \u2192 \u211d)} (hs\u2081 : IsBounded s)\n    (hs\u2082 : MeasurableSet s) (hs\u2083 : volume (frontier s) = 0) :\n    Tendsto (fun n : \u2115 \u21a6 (Nat.card (s \u2229 (n : \u211d)\u207b\u00b9 \u2022 L : Set (\u03b9 \u2192 \u211d)) : \u211d) / n ^ card \u03b9)\n      atTop (\ud835\udcdd ((volume s).toReal / covolume L)) := by\n  classical\n  convert tendsto_card_div_pow'' b hs\u2081 hs\u2082 ?_\n  \u00b7 rw [volume_image_eq_volume_div_covolume L b, ENNReal.toReal_div,\n      ENNReal.toReal_ofReal (covolume_pos L volume).le]\n  \u00b7 rw [frontier_equivFun, volume_image_eq_volume_div_covolume, hs\u2083, ENNReal.zero_div]\n\ntheorem tendsto_card_le_div {X : Set (\u03b9 \u2192 \u211d)} (hX : \u2200 \u2983x\u2984 \u2983r : \u211d\u2984, x \u2208 X \u2192 0 < r \u2192 r \u2022 x \u2208 X)\n    {F : (\u03b9 \u2192 \u211d) \u2192 \u211d} (h\u2081 : \u2200 x \u2983r : \u211d\u2984, 0 \u2264 r \u2192  F (r \u2022 x) = r ^ card \u03b9 * (F x))\n    (h\u2082 : IsBounded {x \u2208 X | F x \u2264 1}) (h\u2083 : MeasurableSet {x \u2208 X | F x \u2264 1})\n    (h\u2084 : volume (frontier {x | x \u2208 X \u2227 F x \u2264 1}) = 0) [Nonempty \u03b9] :\n    Tendsto (fun c : \u211d \u21a6\n      Nat.card ({x \u2208 X | F x \u2264 c} \u2229 L : Set (\u03b9 \u2192 \u211d)) / (c : \u211d))\n        atTop (\ud835\udcdd ((volume {x \u2208 X | F x \u2264 1}).toReal / covolume L)) := by\n  classical\n  let e : Free.ChooseBasisIndex \u2124 \u21a5L \u2243 \u03b9 := by\n    refine Fintype.equivOfCardEq ?_\n    rw [\u2190 finrank_eq_card_chooseBasisIndex, ZLattice.rank \u211d, finrank_fintype_fun_eq_card]\n  let b := (Module.Free.chooseBasis \u2124 L).reindex e\n  convert tendsto_card_le_div'' b hX h\u2081 h\u2082 h\u2083 ?_\n  \u00b7 rw [volume_image_eq_volume_div_covolume L b, ENNReal.toReal_div,\n      ENNReal.toReal_ofReal (covolume_pos L volume).le]\n  \u00b7 rw [frontier_equivFun, volume_image_eq_volume_div_covolume, h\u2084, ENNReal.zero_div]\n\nend Pi\n\nsection InnerProductSpace\n\nopen Filter Pointwise Topology Bornology\n\nvariable {E : Type*} [NormedAddCommGroup E] [InnerProductSpace \u211d E] [FiniteDimensional \u211d E]\n  [MeasurableSpace E] [BorelSpace E]\nvariable (L : Submodule \u2124 E) [DiscreteTopology L] [IsZLattice \u211d L]\n\n", "theoremStatement": "/-- A version of `ZLattice.covolume.tendsto_card_div_pow` for the `InnerProductSpace` case;\nsee the `Naming convention` section in the introduction. -/\ntheorem tendsto_card_div_pow' {s : Set E} (hs\u2081 : IsBounded s) (hs\u2082 : MeasurableSet s)\n    (hs\u2083 : volume (frontier s) = 0) :\n    Tendsto (fun n : \u2115 \u21a6 (Nat.card (s \u2229 (n : \u211d)\u207b\u00b9 \u2022 L : Set E) : \u211d) / n ^ finrank \u211d E)\n      atTop (\ud835\udcdd ((volume s).toReal / covolume L)) ", "theoremName": "ZLattice.covolume.tendsto_card_div_pow'", "fileCreated": {"commit": "85d6c78ac5782869d041c2ca6d3ca83cdde412c3", "date": "2024-09-09"}, "theoremCreated": {"commit": "211dc533566a173988a01067bb50d7917a097103", "date": "2024-12-18"}, "file": "mathlib/Mathlib/Algebra/Module/ZLattice/Covolume.lean", "module": "Mathlib.Algebra.Module.ZLattice.Covolume", "jsonFile": "Mathlib.Algebra.Module.ZLattice.Covolume.jsonl", "positionMetadata": {"lineInFile": 295, "tokenPositionInFile": 15522, "theoremPositionInFile": 16}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 150, "numPremises": 178}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  let b := Module.Free.chooseBasis \u2124 L\n  convert tendsto_card_div_pow'' b hs\u2081 hs\u2082 ?_\n  \u00b7 rw [\u2190 finrank_eq_card_chooseBasisIndex, ZLattice.rank \u211d L]\n  \u00b7 rw [volume_image_eq_volume_div_covolume' L b hs\u2082.nullMeasurableSet, ENNReal.toReal_div,\n      ENNReal.toReal_ofReal (covolume_pos L volume).le]\n  \u00b7 rw [frontier_equivFun, volume_image_eq_volume_div_covolume', hs\u2083, ENNReal.zero_div]\n    exact NullMeasurableSet.of_null hs\u2083", "proofType": "tactic", "proofLengthLines": 7, "proofLengthTokens": 429}}
{"srcContext": "/-\nCopyright (c) 2018 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes, Abhimanyu Pallavi Sudhir, Jean Lo, Calle S\u00f6nne, S\u00e9bastien Gou\u00ebzel,\n  R\u00e9my Degenne\n-/\nimport Mathlib.Analysis.SpecialFunctions.Pow.Continuity\nimport Mathlib.Analysis.SpecialFunctions.Complex.LogDeriv\nimport Mathlib.Analysis.Calculus.FDeriv.Extend\nimport Mathlib.Analysis.Calculus.Deriv.Prod\nimport Mathlib.Analysis.SpecialFunctions.Log.Deriv\nimport Mathlib.Analysis.SpecialFunctions.Trigonometric.Deriv\n\n/-!\n# Derivatives of power function on `\u2102`, `\u211d`, `\u211d\u22650`, and `\u211d\u22650\u221e`\n\nWe also prove differentiability and provide derivatives for the power functions `x ^ y`.\n-/\n\n\nnoncomputable section\n\nopen scoped Real Topology NNReal ENNReal\nopen Filter\n\nnamespace Complex\n\ntheorem hasStrictFDerivAt_cpow {p : \u2102 \u00d7 \u2102} (hp : p.1 \u2208 slitPlane) :\n    HasStrictFDerivAt (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2)\n      ((p.2 * p.1 ^ (p.2 - 1)) \u2022 ContinuousLinearMap.fst \u2102 \u2102 \u2102 +\n        (p.1 ^ p.2 * log p.1) \u2022 ContinuousLinearMap.snd \u2102 \u2102 \u2102) p := by\n  have A : p.1 \u2260 0 := slitPlane_ne_zero hp\n  have : (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2) =\u1da0[\ud835\udcdd p] fun x => exp (log x.1 * x.2) :=\n    ((isOpen_ne.preimage continuous_fst).eventually_mem A).mono fun p hp =>\n      cpow_def_of_ne_zero hp _\n  rw [cpow_sub _ _ A, cpow_one, mul_div_left_comm, mul_smul, mul_smul]\n  refine HasStrictFDerivAt.congr_of_eventuallyEq ?_ this.symm\n  simpa only [cpow_def_of_ne_zero A, div_eq_mul_inv, mul_smul, add_comm, smul_add] using\n    ((hasStrictFDerivAt_fst.clog hp).mul hasStrictFDerivAt_snd).cexp\n\ntheorem hasStrictFDerivAt_cpow' {x y : \u2102} (hp : x \u2208 slitPlane) :\n    HasStrictFDerivAt (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2)\n      ((y * x ^ (y - 1)) \u2022 ContinuousLinearMap.fst \u2102 \u2102 \u2102 +\n        (x ^ y * log x) \u2022 ContinuousLinearMap.snd \u2102 \u2102 \u2102) (x, y) :=\n  @hasStrictFDerivAt_cpow (x, y) hp\n\ntheorem hasStrictDerivAt_const_cpow {x y : \u2102} (h : x \u2260 0 \u2228 y \u2260 0) :\n    HasStrictDerivAt (fun y => x ^ y) (x ^ y * log x) y := by\n  rcases em (x = 0) with (rfl | hx)\n  \u00b7 replace h := h.neg_resolve_left rfl\n    rw [log_zero, mul_zero]\n    refine (hasStrictDerivAt_const y 0).congr_of_eventuallyEq ?_\n    exact (isOpen_ne.eventually_mem h).mono fun y hy => (zero_cpow hy).symm\n  \u00b7 simpa only [cpow_def_of_ne_zero hx, mul_one] using\n      ((hasStrictDerivAt_id y).const_mul (log x)).cexp\n\ntheorem hasFDerivAt_cpow {p : \u2102 \u00d7 \u2102} (hp : p.1 \u2208 slitPlane) :\n    HasFDerivAt (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2)\n      ((p.2 * p.1 ^ (p.2 - 1)) \u2022 ContinuousLinearMap.fst \u2102 \u2102 \u2102 +\n        (p.1 ^ p.2 * log p.1) \u2022 ContinuousLinearMap.snd \u2102 \u2102 \u2102) p :=\n  (hasStrictFDerivAt_cpow hp).hasFDerivAt\n\nend Complex\n\nsection fderiv\n\nopen Complex\n\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f g : E \u2192 \u2102} {f' g' : E \u2192L[\u2102] \u2102}\n  {x : E} {s : Set E} {c : \u2102}\n\ntheorem HasStrictFDerivAt.cpow (hf : HasStrictFDerivAt f f' x) (hg : HasStrictFDerivAt g g' x)\n    (h0 : f x \u2208 slitPlane) : HasStrictFDerivAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) \u2022 f' + (f x ^ g x * Complex.log (f x)) \u2022 g') x := by\n  convert (@hasStrictFDerivAt_cpow ((fun x => (f x, g x)) x) h0).comp x (hf.prod hg)\n\ntheorem HasStrictFDerivAt.const_cpow (hf : HasStrictFDerivAt f f' x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasStrictFDerivAt (fun x => c ^ f x) ((c ^ f x * Complex.log c) \u2022 f') x :=\n  (hasStrictDerivAt_const_cpow h0).comp_hasStrictFDerivAt x hf\n\ntheorem HasFDerivAt.cpow (hf : HasFDerivAt f f' x) (hg : HasFDerivAt g g' x)\n    (h0 : f x \u2208 slitPlane) : HasFDerivAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) \u2022 f' + (f x ^ g x * Complex.log (f x)) \u2022 g') x := by\n  convert (@Complex.hasFDerivAt_cpow ((fun x => (f x, g x)) x) h0).comp x (hf.prod hg)\n\ntheorem HasFDerivAt.const_cpow (hf : HasFDerivAt f f' x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasFDerivAt (fun x => c ^ f x) ((c ^ f x * Complex.log c) \u2022 f') x :=\n  (hasStrictDerivAt_const_cpow h0).hasDerivAt.comp_hasFDerivAt x hf\n\ntheorem HasFDerivWithinAt.cpow (hf : HasFDerivWithinAt f f' s x) (hg : HasFDerivWithinAt g g' s x)\n    (h0 : f x \u2208 slitPlane) : HasFDerivWithinAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) \u2022 f' + (f x ^ g x * Complex.log (f x)) \u2022 g') s x := by\n  convert\n    (@Complex.hasFDerivAt_cpow ((fun x => (f x, g x)) x) h0).comp_hasFDerivWithinAt x (hf.prod hg)\n\ntheorem HasFDerivWithinAt.const_cpow (hf : HasFDerivWithinAt f f' s x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasFDerivWithinAt (fun x => c ^ f x) ((c ^ f x * Complex.log c) \u2022 f') s x :=\n  (hasStrictDerivAt_const_cpow h0).hasDerivAt.comp_hasFDerivWithinAt x hf\n\ntheorem DifferentiableAt.cpow (hf : DifferentiableAt \u2102 f x) (hg : DifferentiableAt \u2102 g x)\n    (h0 : f x \u2208 slitPlane) : DifferentiableAt \u2102 (fun x => f x ^ g x) x :=\n  (hf.hasFDerivAt.cpow hg.hasFDerivAt h0).differentiableAt\n\ntheorem DifferentiableAt.const_cpow (hf : DifferentiableAt \u2102 f x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    DifferentiableAt \u2102 (fun x => c ^ f x) x :=\n  (hf.hasFDerivAt.const_cpow h0).differentiableAt\n\ntheorem DifferentiableAt.cpow_const (hf : DifferentiableAt \u2102 f x) (h0 : f x \u2208 slitPlane) :\n    DifferentiableAt \u2102 (fun x => f x ^ c) x :=\n  hf.cpow (differentiableAt_const c) h0\n\ntheorem DifferentiableWithinAt.cpow (hf : DifferentiableWithinAt \u2102 f s x)\n    (hg : DifferentiableWithinAt \u2102 g s x) (h0 : f x \u2208 slitPlane) :\n    DifferentiableWithinAt \u2102 (fun x => f x ^ g x) s x :=\n  (hf.hasFDerivWithinAt.cpow hg.hasFDerivWithinAt h0).differentiableWithinAt\n\ntheorem DifferentiableWithinAt.const_cpow (hf : DifferentiableWithinAt \u2102 f s x)\n    (h0 : c \u2260 0 \u2228 f x \u2260 0) : DifferentiableWithinAt \u2102 (fun x => c ^ f x) s x :=\n  (hf.hasFDerivWithinAt.const_cpow h0).differentiableWithinAt\n\ntheorem DifferentiableWithinAt.cpow_const (hf : DifferentiableWithinAt \u2102 f s x)\n    (h0 : f x \u2208 slitPlane) :\n    DifferentiableWithinAt \u2102 (fun x => f x ^ c) s x :=\n  hf.cpow (differentiableWithinAt_const c) h0\n\ntheorem DifferentiableOn.cpow (hf : DifferentiableOn \u2102 f s) (hg : DifferentiableOn \u2102 g s)\n    (h0 : Set.MapsTo f s slitPlane) : DifferentiableOn \u2102 (fun x \u21a6 f x ^ g x) s :=\n  fun x hx \u21a6 (hf x hx).cpow (hg x hx) (h0 hx)\n\ntheorem DifferentiableOn.const_cpow (hf : DifferentiableOn \u2102 f s)\n    (h0 : c \u2260 0 \u2228 \u2200 x \u2208 s, f x \u2260 0) : DifferentiableOn \u2102 (fun x \u21a6 c ^ f x) s :=\n  fun x hx \u21a6 (hf x hx).const_cpow (h0.imp_right fun h \u21a6 h x hx)\n\ntheorem DifferentiableOn.cpow_const (hf : DifferentiableOn \u2102 f s)\n    (h0 : \u2200 x \u2208 s, f x \u2208 slitPlane) :\n    DifferentiableOn \u2102 (fun x => f x ^ c) s :=\n  hf.cpow (differentiableOn_const c) h0\n\ntheorem Differentiable.cpow (hf : Differentiable \u2102 f) (hg : Differentiable \u2102 g)\n    (h0 : \u2200 x, f x \u2208 slitPlane) : Differentiable \u2102 (fun x \u21a6 f x ^ g x) :=\n  fun x \u21a6 (hf x).cpow (hg x) (h0 x)\n\ntheorem Differentiable.const_cpow (hf : Differentiable \u2102 f)\n    (h0 : c \u2260 0 \u2228 \u2200 x, f x \u2260 0) : Differentiable \u2102 (fun x \u21a6 c ^ f x) :=\n  fun x \u21a6 (hf x).const_cpow (h0.imp_right fun h \u21a6 h x)\n\n@[fun_prop]\nlemma differentiable_const_cpow_of_neZero (z : \u2102) [NeZero z] :\n    Differentiable \u2102 fun s : \u2102 \u21a6 z ^ s :=\n  differentiable_id.const_cpow (.inl <| NeZero.ne z)\n\n@[fun_prop]\nlemma differentiableAt_const_cpow_of_neZero (z : \u2102) [NeZero z] (t : \u2102) :\n    DifferentiableAt \u2102 (fun s : \u2102 \u21a6 z ^ s) t :=\n  differentiableAt_id.const_cpow (.inl <| NeZero.ne z)\n\nend fderiv\n\nsection deriv\n\nopen Complex\n\nvariable {f g : \u2102 \u2192 \u2102} {s : Set \u2102} {f' g' x c : \u2102}\n\n/-- A private lemma that rewrites the output of lemmas like `HasFDerivAt.cpow` to the form\nexpected by lemmas like `HasDerivAt.cpow`. -/\nprivate theorem aux : ((g x * f x ^ (g x - 1)) \u2022 (1 : \u2102 \u2192L[\u2102] \u2102).smulRight f' +\n    (f x ^ g x * log (f x)) \u2022 (1 : \u2102 \u2192L[\u2102] \u2102).smulRight g') 1 =\n      g x * f x ^ (g x - 1) * f' + f x ^ g x * log (f x) * g' := by\n  simp only [Algebra.id.smul_eq_mul, one_mul, ContinuousLinearMap.one_apply,\n    ContinuousLinearMap.smulRight_apply, ContinuousLinearMap.add_apply, Pi.smul_apply,\n    ContinuousLinearMap.coe_smul']\n\nnonrec theorem HasStrictDerivAt.cpow (hf : HasStrictDerivAt f f' x) (hg : HasStrictDerivAt g g' x)\n    (h0 : f x \u2208 slitPlane) : HasStrictDerivAt (fun x => f x ^ g x)\n      (g x * f x ^ (g x - 1) * f' + f x ^ g x * Complex.log (f x) * g') x := by\n  simpa using (hf.cpow hg h0).hasStrictDerivAt\n\ntheorem HasStrictDerivAt.const_cpow (hf : HasStrictDerivAt f f' x) (h : c \u2260 0 \u2228 f x \u2260 0) :\n    HasStrictDerivAt (fun x => c ^ f x) (c ^ f x * Complex.log c * f') x :=\n  (hasStrictDerivAt_const_cpow h).comp x hf\n\ntheorem Complex.hasStrictDerivAt_cpow_const (h : x \u2208 slitPlane) :\n    HasStrictDerivAt (fun z : \u2102 => z ^ c) (c * x ^ (c - 1)) x := by\n  simpa only [mul_zero, add_zero, mul_one] using\n    (hasStrictDerivAt_id x).cpow (hasStrictDerivAt_const x c) h\n\ntheorem HasStrictDerivAt.cpow_const (hf : HasStrictDerivAt f f' x)\n    (h0 : f x \u2208 slitPlane) :\n    HasStrictDerivAt (fun x => f x ^ c) (c * f x ^ (c - 1) * f') x :=\n  (Complex.hasStrictDerivAt_cpow_const h0).comp x hf\n\ntheorem HasDerivAt.cpow (hf : HasDerivAt f f' x) (hg : HasDerivAt g g' x)\n    (h0 : f x \u2208 slitPlane) : HasDerivAt (fun x => f x ^ g x)\n      (g x * f x ^ (g x - 1) * f' + f x ^ g x * Complex.log (f x) * g') x := by\n  simpa only [aux] using (hf.hasFDerivAt.cpow hg h0).hasDerivAt\n\ntheorem HasDerivAt.const_cpow (hf : HasDerivAt f f' x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasDerivAt (fun x => c ^ f x) (c ^ f x * Complex.log c * f') x :=\n  (hasStrictDerivAt_const_cpow h0).hasDerivAt.comp x hf\n\ntheorem HasDerivAt.cpow_const (hf : HasDerivAt f f' x) (h0 : f x \u2208 slitPlane) :\n    HasDerivAt (fun x => f x ^ c) (c * f x ^ (c - 1) * f') x :=\n  (Complex.hasStrictDerivAt_cpow_const h0).hasDerivAt.comp x hf\n\ntheorem HasDerivWithinAt.cpow (hf : HasDerivWithinAt f f' s x) (hg : HasDerivWithinAt g g' s x)\n    (h0 : f x \u2208 slitPlane) : HasDerivWithinAt (fun x => f x ^ g x)\n      (g x * f x ^ (g x - 1) * f' + f x ^ g x * Complex.log (f x) * g') s x := by\n  simpa only [aux] using (hf.hasFDerivWithinAt.cpow hg h0).hasDerivWithinAt\n\ntheorem HasDerivWithinAt.const_cpow (hf : HasDerivWithinAt f f' s x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasDerivWithinAt (fun x => c ^ f x) (c ^ f x * Complex.log c * f') s x :=\n  (hasStrictDerivAt_const_cpow h0).hasDerivAt.comp_hasDerivWithinAt x hf\n\ntheorem HasDerivWithinAt.cpow_const (hf : HasDerivWithinAt f f' s x)\n    (h0 : f x \u2208 slitPlane) :\n    HasDerivWithinAt (fun x => f x ^ c) (c * f x ^ (c - 1) * f') s x :=\n  (Complex.hasStrictDerivAt_cpow_const h0).hasDerivAt.comp_hasDerivWithinAt x hf\n\n/-- Although `fun x => x ^ r` for fixed `r` is *not* complex-differentiable along the negative real\nline, it is still real-differentiable, and the derivative is what one would formally expect.\nSee `hasDerivAt_ofReal_cpow_const` for an alternate formulation. -/\ntheorem hasDerivAt_ofReal_cpow_const' {x : \u211d} (hx : x \u2260 0) {r : \u2102} (hr : r \u2260 -1) :\n    HasDerivAt (fun y : \u211d => (y : \u2102) ^ (r + 1) / (r + 1)) (x ^ r) x := by\n  rw [Ne, \u2190 add_eq_zero_iff_eq_neg, \u2190 Ne] at hr\n  rcases lt_or_gt_of_ne hx.symm with (hx | hx)\n  \u00b7 -- easy case : `0 < x`\n    -- Porting note: proof used to be\n    -- convert (((hasDerivAt_id (x : \u2102)).cpow_const _).div_const (r + 1)).comp_ofReal using 1\n    -- \u00b7 rw [add_sub_cancel, id.def, mul_one, mul_comm, mul_div_cancel _ hr]\n    -- \u00b7 rw [id.def, ofReal_re]; exact Or.inl hx\n    apply HasDerivAt.comp_ofReal (e := fun y => (y : \u2102) ^ (r + 1) / (r + 1))\n    convert HasDerivAt.div_const (\ud835\udd5c := \u2102) ?_ (r + 1) using 1\n    \u00b7 exact (mul_div_cancel_right\u2080 _ hr).symm\n    \u00b7 convert HasDerivAt.cpow_const ?_ ?_ using 1\n      \u00b7 rw [add_sub_cancel_right, mul_comm]; exact (mul_one _).symm\n      \u00b7 exact hasDerivAt_id (x : \u2102)\n      \u00b7 simp [hx]\n  \u00b7 -- harder case : `x < 0`\n    have : \u2200\u1da0 y : \u211d in \ud835\udcdd x,\n        (y : \u2102) ^ (r + 1) / (r + 1) = (-y : \u2102) ^ (r + 1) * exp (\u03c0 * I * (r + 1)) / (r + 1) := by\n      refine Filter.eventually_of_mem (Iio_mem_nhds hx) fun y hy => ?_\n      rw [ofReal_cpow_of_nonpos (le_of_lt hy)]\n    refine HasDerivAt.congr_of_eventuallyEq ?_ this\n    rw [ofReal_cpow_of_nonpos (le_of_lt hx)]\n    suffices HasDerivAt (fun y : \u211d => (-\u2191y) ^ (r + 1) * exp (\u2191\u03c0 * I * (r + 1)))\n        ((r + 1) * (-\u2191x) ^ r * exp (\u2191\u03c0 * I * r)) x by\n      convert this.div_const (r + 1) using 1\n      conv_rhs => rw [mul_assoc, mul_comm, mul_div_cancel_right\u2080 _ hr]\n    rw [mul_add ((\u03c0 : \u2102) * _), mul_one, exp_add, exp_pi_mul_I, mul_comm (_ : \u2102) (-1 : \u2102),\n      neg_one_mul]\n    simp_rw [mul_neg, \u2190 neg_mul, \u2190 ofReal_neg]\n    suffices HasDerivAt (fun y : \u211d => (\u2191(-y) : \u2102) ^ (r + 1)) (-(r + 1) * \u2191(-x) ^ r) x by\n      convert this.neg.mul_const _ using 1; ring\n    suffices HasDerivAt (fun y : \u211d => (y : \u2102) ^ (r + 1)) ((r + 1) * \u2191(-x) ^ r) (-x) by\n      convert @HasDerivAt.scomp \u211d _ \u2102 _ _ x \u211d _ _ _ _ _ _ _ _ this (hasDerivAt_neg x) using 1\n      rw [real_smul, ofReal_neg 1, ofReal_one]; ring\n    suffices HasDerivAt (fun y : \u2102 => y ^ (r + 1)) ((r + 1) * \u2191(-x) ^ r) \u2191(-x) by\n      exact this.comp_ofReal\n    conv in \u2191_ ^ _ => rw [(by ring : r = r + 1 - 1)]\n    convert HasDerivAt.cpow_const ?_ ?_ using 1\n    \u00b7 rw [add_sub_cancel_right, add_sub_cancel_right]; exact (mul_one _).symm\n    \u00b7 exact hasDerivAt_id ((-x : \u211d) : \u2102)\n    \u00b7 simp [hx]\n\n@[deprecated (since := \"2024-12-15\")] alias hasDerivAt_ofReal_cpow := hasDerivAt_ofReal_cpow_const'\n\n/-- An alternate formulation of `hasDerivAt_ofReal_cpow_const'`. -/\ntheorem hasDerivAt_ofReal_cpow_const {x : \u211d} (hx : x \u2260 0) {r : \u2102} (hr : r \u2260 0) :\n    HasDerivAt (fun y : \u211d => (y : \u2102) ^ r) (r * x ^ (r - 1)) x := by\n  have := HasDerivAt.const_mul r <| hasDerivAt_ofReal_cpow_const' hx\n    (by rwa [ne_eq, sub_eq_neg_self])\n  simpa [sub_add_cancel, mul_div_cancel\u2080 _ hr] using this\n\n/-- A version of `DifferentiableAt.cpow_const` for a real function. -/\ntheorem DifferentiableAt.ofReal_cpow_const {f : \u211d \u2192 \u211d} {x : \u211d} (hf : DifferentiableAt \u211d f x)\n    (h0 : f x \u2260 0) (h1 : c \u2260 0) :\n    DifferentiableAt \u211d (fun (y : \u211d) => (f y : \u2102) ^ c) x :=\n  (hasDerivAt_ofReal_cpow_const h0 h1).differentiableAt.comp x hf\n\ntheorem Complex.deriv_cpow_const (hx : x \u2208 Complex.slitPlane) :\n    deriv (fun (x : \u2102) \u21a6 x ^ c) x = c * x ^ (c - 1) :=\n  (hasStrictDerivAt_cpow_const hx).hasDerivAt.deriv\n\n/-- A version of `Complex.deriv_cpow_const` for a real variable. -/\ntheorem Complex.deriv_ofReal_cpow_const {x : \u211d} (hx : x \u2260 0) (hc : c \u2260 0) :\n    deriv (fun x : \u211d \u21a6 (x : \u2102) ^ c) x = c * x ^ (c - 1) :=\n  (hasDerivAt_ofReal_cpow_const hx hc).deriv\n\ntheorem deriv_cpow_const (hf : DifferentiableAt \u2102 f x) (hx : f x \u2208 Complex.slitPlane) :\n    deriv (fun (x : \u2102) \u21a6 f x ^ c) x = c * f x ^ (c - 1) * deriv f x :=\n  (hf.hasDerivAt.cpow_const hx).deriv\n\ntheorem isTheta_deriv_ofReal_cpow_const_atTop {c : \u2102} (hc : c \u2260 0) :\n    deriv (fun (x : \u211d) => (x : \u2102) ^ c) =\u0398[atTop] fun x => x ^ (c.re - 1) := by\n  calc\n    _ =\u1da0[atTop] fun x : \u211d \u21a6 c * x ^ (c - 1) := by\n      filter_upwards [eventually_ne_atTop 0] with x hx using by rw [deriv_ofReal_cpow_const hx hc]\n    _ =\u0398[atTop] fun x : \u211d \u21a6 \u2016(x : \u2102) ^ (c - 1)\u2016 :=\n      (Asymptotics.IsTheta.of_norm_eventuallyEq EventuallyEq.rfl).const_mul_left hc\n    _ =\u1da0[atTop] fun x \u21a6 x ^ (c.re - 1) := by\n      filter_upwards [eventually_gt_atTop 0] with x hx\n      rw [norm_eq_abs, abs_cpow_eq_rpow_re_of_pos hx, sub_re, one_re]\n\n", "theoremStatement": "theorem isBigO_deriv_ofReal_cpow_const_atTop (c : \u2102) :\n    deriv (fun (x : \u211d) => (x : \u2102) ^ c) =O[atTop] fun x => x ^ (c.re - 1) ", "theoremName": "isBigO_deriv_ofReal_cpow_const_atTop", "fileCreated": {"commit": "a9359cb30d5d2eb08c3c66959305c82fe45fab66", "date": "2023-06-06"}, "theoremCreated": {"commit": "006641492734e60b369ac830260c46c2dcdb7342", "date": "2025-01-20"}, "file": "mathlib/Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean", "module": "Mathlib.Analysis.SpecialFunctions.Pow.Deriv", "jsonFile": "Mathlib.Analysis.SpecialFunctions.Pow.Deriv.jsonl", "positionMetadata": {"lineInFile": 305, "tokenPositionInFile": 15003, "theoremPositionInFile": 41}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 54, "numPremises": 74}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  obtain rfl | hc := eq_or_ne c 0\n  \u00b7 simp_rw [cpow_zero, deriv_const', Asymptotics.isBigO_zero]\n  \u00b7 exact (isTheta_deriv_ofReal_cpow_const_atTop hc).1", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 157}}
{"srcContext": "/-\nCopyright (c) 2018 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes, Abhimanyu Pallavi Sudhir, Jean Lo, Calle S\u00f6nne, S\u00e9bastien Gou\u00ebzel,\n  R\u00e9my Degenne\n-/\nimport Mathlib.Analysis.SpecialFunctions.Pow.Continuity\nimport Mathlib.Analysis.SpecialFunctions.Complex.LogDeriv\nimport Mathlib.Analysis.Calculus.FDeriv.Extend\nimport Mathlib.Analysis.Calculus.Deriv.Prod\nimport Mathlib.Analysis.SpecialFunctions.Log.Deriv\nimport Mathlib.Analysis.SpecialFunctions.Trigonometric.Deriv\n\n/-!\n# Derivatives of power function on `\u2102`, `\u211d`, `\u211d\u22650`, and `\u211d\u22650\u221e`\n\nWe also prove differentiability and provide derivatives for the power functions `x ^ y`.\n-/\n\n\nnoncomputable section\n\nopen scoped Real Topology NNReal ENNReal\nopen Filter\n\nnamespace Complex\n\ntheorem hasStrictFDerivAt_cpow {p : \u2102 \u00d7 \u2102} (hp : p.1 \u2208 slitPlane) :\n    HasStrictFDerivAt (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2)\n      ((p.2 * p.1 ^ (p.2 - 1)) \u2022 ContinuousLinearMap.fst \u2102 \u2102 \u2102 +\n        (p.1 ^ p.2 * log p.1) \u2022 ContinuousLinearMap.snd \u2102 \u2102 \u2102) p := by\n  have A : p.1 \u2260 0 := slitPlane_ne_zero hp\n  have : (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2) =\u1da0[\ud835\udcdd p] fun x => exp (log x.1 * x.2) :=\n    ((isOpen_ne.preimage continuous_fst).eventually_mem A).mono fun p hp =>\n      cpow_def_of_ne_zero hp _\n  rw [cpow_sub _ _ A, cpow_one, mul_div_left_comm, mul_smul, mul_smul]\n  refine HasStrictFDerivAt.congr_of_eventuallyEq ?_ this.symm\n  simpa only [cpow_def_of_ne_zero A, div_eq_mul_inv, mul_smul, add_comm, smul_add] using\n    ((hasStrictFDerivAt_fst.clog hp).mul hasStrictFDerivAt_snd).cexp\n\ntheorem hasStrictFDerivAt_cpow' {x y : \u2102} (hp : x \u2208 slitPlane) :\n    HasStrictFDerivAt (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2)\n      ((y * x ^ (y - 1)) \u2022 ContinuousLinearMap.fst \u2102 \u2102 \u2102 +\n        (x ^ y * log x) \u2022 ContinuousLinearMap.snd \u2102 \u2102 \u2102) (x, y) :=\n  @hasStrictFDerivAt_cpow (x, y) hp\n\ntheorem hasStrictDerivAt_const_cpow {x y : \u2102} (h : x \u2260 0 \u2228 y \u2260 0) :\n    HasStrictDerivAt (fun y => x ^ y) (x ^ y * log x) y := by\n  rcases em (x = 0) with (rfl | hx)\n  \u00b7 replace h := h.neg_resolve_left rfl\n    rw [log_zero, mul_zero]\n    refine (hasStrictDerivAt_const y 0).congr_of_eventuallyEq ?_\n    exact (isOpen_ne.eventually_mem h).mono fun y hy => (zero_cpow hy).symm\n  \u00b7 simpa only [cpow_def_of_ne_zero hx, mul_one] using\n      ((hasStrictDerivAt_id y).const_mul (log x)).cexp\n\ntheorem hasFDerivAt_cpow {p : \u2102 \u00d7 \u2102} (hp : p.1 \u2208 slitPlane) :\n    HasFDerivAt (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2)\n      ((p.2 * p.1 ^ (p.2 - 1)) \u2022 ContinuousLinearMap.fst \u2102 \u2102 \u2102 +\n        (p.1 ^ p.2 * log p.1) \u2022 ContinuousLinearMap.snd \u2102 \u2102 \u2102) p :=\n  (hasStrictFDerivAt_cpow hp).hasFDerivAt\n\nend Complex\n\nsection fderiv\n\nopen Complex\n\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f g : E \u2192 \u2102} {f' g' : E \u2192L[\u2102] \u2102}\n  {x : E} {s : Set E} {c : \u2102}\n\ntheorem HasStrictFDerivAt.cpow (hf : HasStrictFDerivAt f f' x) (hg : HasStrictFDerivAt g g' x)\n    (h0 : f x \u2208 slitPlane) : HasStrictFDerivAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) \u2022 f' + (f x ^ g x * Complex.log (f x)) \u2022 g') x := by\n  convert (@hasStrictFDerivAt_cpow ((fun x => (f x, g x)) x) h0).comp x (hf.prod hg)\n\ntheorem HasStrictFDerivAt.const_cpow (hf : HasStrictFDerivAt f f' x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasStrictFDerivAt (fun x => c ^ f x) ((c ^ f x * Complex.log c) \u2022 f') x :=\n  (hasStrictDerivAt_const_cpow h0).comp_hasStrictFDerivAt x hf\n\ntheorem HasFDerivAt.cpow (hf : HasFDerivAt f f' x) (hg : HasFDerivAt g g' x)\n    (h0 : f x \u2208 slitPlane) : HasFDerivAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) \u2022 f' + (f x ^ g x * Complex.log (f x)) \u2022 g') x := by\n  convert (@Complex.hasFDerivAt_cpow ((fun x => (f x, g x)) x) h0).comp x (hf.prod hg)\n\ntheorem HasFDerivAt.const_cpow (hf : HasFDerivAt f f' x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasFDerivAt (fun x => c ^ f x) ((c ^ f x * Complex.log c) \u2022 f') x :=\n  (hasStrictDerivAt_const_cpow h0).hasDerivAt.comp_hasFDerivAt x hf\n\ntheorem HasFDerivWithinAt.cpow (hf : HasFDerivWithinAt f f' s x) (hg : HasFDerivWithinAt g g' s x)\n    (h0 : f x \u2208 slitPlane) : HasFDerivWithinAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) \u2022 f' + (f x ^ g x * Complex.log (f x)) \u2022 g') s x := by\n  convert\n    (@Complex.hasFDerivAt_cpow ((fun x => (f x, g x)) x) h0).comp_hasFDerivWithinAt x (hf.prod hg)\n\ntheorem HasFDerivWithinAt.const_cpow (hf : HasFDerivWithinAt f f' s x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasFDerivWithinAt (fun x => c ^ f x) ((c ^ f x * Complex.log c) \u2022 f') s x :=\n  (hasStrictDerivAt_const_cpow h0).hasDerivAt.comp_hasFDerivWithinAt x hf\n\ntheorem DifferentiableAt.cpow (hf : DifferentiableAt \u2102 f x) (hg : DifferentiableAt \u2102 g x)\n    (h0 : f x \u2208 slitPlane) : DifferentiableAt \u2102 (fun x => f x ^ g x) x :=\n  (hf.hasFDerivAt.cpow hg.hasFDerivAt h0).differentiableAt\n\ntheorem DifferentiableAt.const_cpow (hf : DifferentiableAt \u2102 f x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    DifferentiableAt \u2102 (fun x => c ^ f x) x :=\n  (hf.hasFDerivAt.const_cpow h0).differentiableAt\n\ntheorem DifferentiableAt.cpow_const (hf : DifferentiableAt \u2102 f x) (h0 : f x \u2208 slitPlane) :\n    DifferentiableAt \u2102 (fun x => f x ^ c) x :=\n  hf.cpow (differentiableAt_const c) h0\n\ntheorem DifferentiableWithinAt.cpow (hf : DifferentiableWithinAt \u2102 f s x)\n    (hg : DifferentiableWithinAt \u2102 g s x) (h0 : f x \u2208 slitPlane) :\n    DifferentiableWithinAt \u2102 (fun x => f x ^ g x) s x :=\n  (hf.hasFDerivWithinAt.cpow hg.hasFDerivWithinAt h0).differentiableWithinAt\n\ntheorem DifferentiableWithinAt.const_cpow (hf : DifferentiableWithinAt \u2102 f s x)\n    (h0 : c \u2260 0 \u2228 f x \u2260 0) : DifferentiableWithinAt \u2102 (fun x => c ^ f x) s x :=\n  (hf.hasFDerivWithinAt.const_cpow h0).differentiableWithinAt\n\ntheorem DifferentiableWithinAt.cpow_const (hf : DifferentiableWithinAt \u2102 f s x)\n    (h0 : f x \u2208 slitPlane) :\n    DifferentiableWithinAt \u2102 (fun x => f x ^ c) s x :=\n  hf.cpow (differentiableWithinAt_const c) h0\n\ntheorem DifferentiableOn.cpow (hf : DifferentiableOn \u2102 f s) (hg : DifferentiableOn \u2102 g s)\n    (h0 : Set.MapsTo f s slitPlane) : DifferentiableOn \u2102 (fun x \u21a6 f x ^ g x) s :=\n  fun x hx \u21a6 (hf x hx).cpow (hg x hx) (h0 hx)\n\ntheorem DifferentiableOn.const_cpow (hf : DifferentiableOn \u2102 f s)\n    (h0 : c \u2260 0 \u2228 \u2200 x \u2208 s, f x \u2260 0) : DifferentiableOn \u2102 (fun x \u21a6 c ^ f x) s :=\n  fun x hx \u21a6 (hf x hx).const_cpow (h0.imp_right fun h \u21a6 h x hx)\n\ntheorem DifferentiableOn.cpow_const (hf : DifferentiableOn \u2102 f s)\n    (h0 : \u2200 x \u2208 s, f x \u2208 slitPlane) :\n    DifferentiableOn \u2102 (fun x => f x ^ c) s :=\n  hf.cpow (differentiableOn_const c) h0\n\ntheorem Differentiable.cpow (hf : Differentiable \u2102 f) (hg : Differentiable \u2102 g)\n    (h0 : \u2200 x, f x \u2208 slitPlane) : Differentiable \u2102 (fun x \u21a6 f x ^ g x) :=\n  fun x \u21a6 (hf x).cpow (hg x) (h0 x)\n\ntheorem Differentiable.const_cpow (hf : Differentiable \u2102 f)\n    (h0 : c \u2260 0 \u2228 \u2200 x, f x \u2260 0) : Differentiable \u2102 (fun x \u21a6 c ^ f x) :=\n  fun x \u21a6 (hf x).const_cpow (h0.imp_right fun h \u21a6 h x)\n\n@[fun_prop]\nlemma differentiable_const_cpow_of_neZero (z : \u2102) [NeZero z] :\n    Differentiable \u2102 fun s : \u2102 \u21a6 z ^ s :=\n  differentiable_id.const_cpow (.inl <| NeZero.ne z)\n\n@[fun_prop]\nlemma differentiableAt_const_cpow_of_neZero (z : \u2102) [NeZero z] (t : \u2102) :\n    DifferentiableAt \u2102 (fun s : \u2102 \u21a6 z ^ s) t :=\n  differentiableAt_id.const_cpow (.inl <| NeZero.ne z)\n\nend fderiv\n\nsection deriv\n\nopen Complex\n\nvariable {f g : \u2102 \u2192 \u2102} {s : Set \u2102} {f' g' x c : \u2102}\n\n/-- A private lemma that rewrites the output of lemmas like `HasFDerivAt.cpow` to the form\nexpected by lemmas like `HasDerivAt.cpow`. -/\nprivate theorem aux : ((g x * f x ^ (g x - 1)) \u2022 (1 : \u2102 \u2192L[\u2102] \u2102).smulRight f' +\n    (f x ^ g x * log (f x)) \u2022 (1 : \u2102 \u2192L[\u2102] \u2102).smulRight g') 1 =\n      g x * f x ^ (g x - 1) * f' + f x ^ g x * log (f x) * g' := by\n  simp only [Algebra.id.smul_eq_mul, one_mul, ContinuousLinearMap.one_apply,\n    ContinuousLinearMap.smulRight_apply, ContinuousLinearMap.add_apply, Pi.smul_apply,\n    ContinuousLinearMap.coe_smul']\n\nnonrec theorem HasStrictDerivAt.cpow (hf : HasStrictDerivAt f f' x) (hg : HasStrictDerivAt g g' x)\n    (h0 : f x \u2208 slitPlane) : HasStrictDerivAt (fun x => f x ^ g x)\n      (g x * f x ^ (g x - 1) * f' + f x ^ g x * Complex.log (f x) * g') x := by\n  simpa using (hf.cpow hg h0).hasStrictDerivAt\n\ntheorem HasStrictDerivAt.const_cpow (hf : HasStrictDerivAt f f' x) (h : c \u2260 0 \u2228 f x \u2260 0) :\n    HasStrictDerivAt (fun x => c ^ f x) (c ^ f x * Complex.log c * f') x :=\n  (hasStrictDerivAt_const_cpow h).comp x hf\n\ntheorem Complex.hasStrictDerivAt_cpow_const (h : x \u2208 slitPlane) :\n    HasStrictDerivAt (fun z : \u2102 => z ^ c) (c * x ^ (c - 1)) x := by\n  simpa only [mul_zero, add_zero, mul_one] using\n    (hasStrictDerivAt_id x).cpow (hasStrictDerivAt_const x c) h\n\ntheorem HasStrictDerivAt.cpow_const (hf : HasStrictDerivAt f f' x)\n    (h0 : f x \u2208 slitPlane) :\n    HasStrictDerivAt (fun x => f x ^ c) (c * f x ^ (c - 1) * f') x :=\n  (Complex.hasStrictDerivAt_cpow_const h0).comp x hf\n\ntheorem HasDerivAt.cpow (hf : HasDerivAt f f' x) (hg : HasDerivAt g g' x)\n    (h0 : f x \u2208 slitPlane) : HasDerivAt (fun x => f x ^ g x)\n      (g x * f x ^ (g x - 1) * f' + f x ^ g x * Complex.log (f x) * g') x := by\n  simpa only [aux] using (hf.hasFDerivAt.cpow hg h0).hasDerivAt\n\ntheorem HasDerivAt.const_cpow (hf : HasDerivAt f f' x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasDerivAt (fun x => c ^ f x) (c ^ f x * Complex.log c * f') x :=\n  (hasStrictDerivAt_const_cpow h0).hasDerivAt.comp x hf\n\ntheorem HasDerivAt.cpow_const (hf : HasDerivAt f f' x) (h0 : f x \u2208 slitPlane) :\n    HasDerivAt (fun x => f x ^ c) (c * f x ^ (c - 1) * f') x :=\n  (Complex.hasStrictDerivAt_cpow_const h0).hasDerivAt.comp x hf\n\ntheorem HasDerivWithinAt.cpow (hf : HasDerivWithinAt f f' s x) (hg : HasDerivWithinAt g g' s x)\n    (h0 : f x \u2208 slitPlane) : HasDerivWithinAt (fun x => f x ^ g x)\n      (g x * f x ^ (g x - 1) * f' + f x ^ g x * Complex.log (f x) * g') s x := by\n  simpa only [aux] using (hf.hasFDerivWithinAt.cpow hg h0).hasDerivWithinAt\n\ntheorem HasDerivWithinAt.const_cpow (hf : HasDerivWithinAt f f' s x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasDerivWithinAt (fun x => c ^ f x) (c ^ f x * Complex.log c * f') s x :=\n  (hasStrictDerivAt_const_cpow h0).hasDerivAt.comp_hasDerivWithinAt x hf\n\ntheorem HasDerivWithinAt.cpow_const (hf : HasDerivWithinAt f f' s x)\n    (h0 : f x \u2208 slitPlane) :\n    HasDerivWithinAt (fun x => f x ^ c) (c * f x ^ (c - 1) * f') s x :=\n  (Complex.hasStrictDerivAt_cpow_const h0).hasDerivAt.comp_hasDerivWithinAt x hf\n\n/-- Although `fun x => x ^ r` for fixed `r` is *not* complex-differentiable along the negative real\nline, it is still real-differentiable, and the derivative is what one would formally expect.\nSee `hasDerivAt_ofReal_cpow_const` for an alternate formulation. -/\ntheorem hasDerivAt_ofReal_cpow_const' {x : \u211d} (hx : x \u2260 0) {r : \u2102} (hr : r \u2260 -1) :\n    HasDerivAt (fun y : \u211d => (y : \u2102) ^ (r + 1) / (r + 1)) (x ^ r) x := by\n  rw [Ne, \u2190 add_eq_zero_iff_eq_neg, \u2190 Ne] at hr\n  rcases lt_or_gt_of_ne hx.symm with (hx | hx)\n  \u00b7 -- easy case : `0 < x`\n    -- Porting note: proof used to be\n    -- convert (((hasDerivAt_id (x : \u2102)).cpow_const _).div_const (r + 1)).comp_ofReal using 1\n    -- \u00b7 rw [add_sub_cancel, id.def, mul_one, mul_comm, mul_div_cancel _ hr]\n    -- \u00b7 rw [id.def, ofReal_re]; exact Or.inl hx\n    apply HasDerivAt.comp_ofReal (e := fun y => (y : \u2102) ^ (r + 1) / (r + 1))\n    convert HasDerivAt.div_const (\ud835\udd5c := \u2102) ?_ (r + 1) using 1\n    \u00b7 exact (mul_div_cancel_right\u2080 _ hr).symm\n    \u00b7 convert HasDerivAt.cpow_const ?_ ?_ using 1\n      \u00b7 rw [add_sub_cancel_right, mul_comm]; exact (mul_one _).symm\n      \u00b7 exact hasDerivAt_id (x : \u2102)\n      \u00b7 simp [hx]\n  \u00b7 -- harder case : `x < 0`\n    have : \u2200\u1da0 y : \u211d in \ud835\udcdd x,\n        (y : \u2102) ^ (r + 1) / (r + 1) = (-y : \u2102) ^ (r + 1) * exp (\u03c0 * I * (r + 1)) / (r + 1) := by\n      refine Filter.eventually_of_mem (Iio_mem_nhds hx) fun y hy => ?_\n      rw [ofReal_cpow_of_nonpos (le_of_lt hy)]\n    refine HasDerivAt.congr_of_eventuallyEq ?_ this\n    rw [ofReal_cpow_of_nonpos (le_of_lt hx)]\n    suffices HasDerivAt (fun y : \u211d => (-\u2191y) ^ (r + 1) * exp (\u2191\u03c0 * I * (r + 1)))\n        ((r + 1) * (-\u2191x) ^ r * exp (\u2191\u03c0 * I * r)) x by\n      convert this.div_const (r + 1) using 1\n      conv_rhs => rw [mul_assoc, mul_comm, mul_div_cancel_right\u2080 _ hr]\n    rw [mul_add ((\u03c0 : \u2102) * _), mul_one, exp_add, exp_pi_mul_I, mul_comm (_ : \u2102) (-1 : \u2102),\n      neg_one_mul]\n    simp_rw [mul_neg, \u2190 neg_mul, \u2190 ofReal_neg]\n    suffices HasDerivAt (fun y : \u211d => (\u2191(-y) : \u2102) ^ (r + 1)) (-(r + 1) * \u2191(-x) ^ r) x by\n      convert this.neg.mul_const _ using 1; ring\n    suffices HasDerivAt (fun y : \u211d => (y : \u2102) ^ (r + 1)) ((r + 1) * \u2191(-x) ^ r) (-x) by\n      convert @HasDerivAt.scomp \u211d _ \u2102 _ _ x \u211d _ _ _ _ _ _ _ _ this (hasDerivAt_neg x) using 1\n      rw [real_smul, ofReal_neg 1, ofReal_one]; ring\n    suffices HasDerivAt (fun y : \u2102 => y ^ (r + 1)) ((r + 1) * \u2191(-x) ^ r) \u2191(-x) by\n      exact this.comp_ofReal\n    conv in \u2191_ ^ _ => rw [(by ring : r = r + 1 - 1)]\n    convert HasDerivAt.cpow_const ?_ ?_ using 1\n    \u00b7 rw [add_sub_cancel_right, add_sub_cancel_right]; exact (mul_one _).symm\n    \u00b7 exact hasDerivAt_id ((-x : \u211d) : \u2102)\n    \u00b7 simp [hx]\n\n@[deprecated (since := \"2024-12-15\")] alias hasDerivAt_ofReal_cpow := hasDerivAt_ofReal_cpow_const'\n\n/-- An alternate formulation of `hasDerivAt_ofReal_cpow_const'`. -/\ntheorem hasDerivAt_ofReal_cpow_const {x : \u211d} (hx : x \u2260 0) {r : \u2102} (hr : r \u2260 0) :\n    HasDerivAt (fun y : \u211d => (y : \u2102) ^ r) (r * x ^ (r - 1)) x := by\n  have := HasDerivAt.const_mul r <| hasDerivAt_ofReal_cpow_const' hx\n    (by rwa [ne_eq, sub_eq_neg_self])\n  simpa [sub_add_cancel, mul_div_cancel\u2080 _ hr] using this\n\n", "theoremStatement": "/-- A version of `DifferentiableAt.cpow_const` for a real function. -/\ntheorem DifferentiableAt.ofReal_cpow_const {f : \u211d \u2192 \u211d} {x : \u211d} (hf : DifferentiableAt \u211d f x)\n    (h0 : f x \u2260 0) (h1 : c \u2260 0) :\n    DifferentiableAt \u211d (fun (y : \u211d) => (f y : \u2102) ^ c) x ", "theoremName": "DifferentiableAt.ofReal_cpow_const", "fileCreated": {"commit": "a9359cb30d5d2eb08c3c66959305c82fe45fab66", "date": "2023-06-06"}, "theoremCreated": {"commit": "006641492734e60b369ac830260c46c2dcdb7342", "date": "2025-01-20"}, "file": "mathlib/Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean", "module": "Mathlib.Analysis.SpecialFunctions.Pow.Deriv", "jsonFile": "Mathlib.Analysis.SpecialFunctions.Pow.Deriv.jsonl", "positionMetadata": {"lineInFile": 275, "tokenPositionInFile": 13450, "theoremPositionInFile": 36}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 38, "numPremises": 47}, "proofMetadata": {"hasProof": true, "proof": ":=\n  (hasDerivAt_ofReal_cpow_const h0 h1).differentiableAt.comp x hf", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 68}}
{"srcContext": "/-\nCopyright (c) 2020 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kevin Buzzard, Johan Commelin, Patrick Massot\n-/\nimport Mathlib.Algebra.Order.Hom.Monoid\nimport Mathlib.Algebra.Order.Ring.Basic\nimport Mathlib.RingTheory.Ideal.Maps\nimport Mathlib.Tactic.TFAE\n\n/-!\n\n# The basics of valuation theory.\n\nThe basic theory of valuations (non-archimedean norms) on a commutative ring,\nfollowing T. Wedhorn's unpublished notes \u201cAdic Spaces\u201d ([wedhorn_adic]).\n\nThe definition of a valuation we use here is Definition 1.22 of [wedhorn_adic].\nA valuation on a ring `R` is a monoid homomorphism `v` to a linearly ordered\ncommutative monoid with zero, that in addition satisfies the following two axioms:\n * `v 0 = 0`\n * `\u2200 x y, v (x + y) \u2264 max (v x) (v y)`\n\n`Valuation R \u0393\u2080`is the type of valuations `R \u2192 \u0393\u2080`, with a coercion to the underlying\nfunction. If `v` is a valuation from `R` to `\u0393\u2080` then the induced group\nhomomorphism `Units(R) \u2192 \u0393\u2080` is called `unit_map v`.\n\nThe equivalence \"relation\" `IsEquiv v\u2081 v\u2082 : Prop` defined in 1.27 of [wedhorn_adic] is not strictly\nspeaking a relation, because `v\u2081 : Valuation R \u0393\u2081` and `v\u2082 : Valuation R \u0393\u2082` might\nnot have the same type. This corresponds in ZFC to the set-theoretic difficulty\nthat the class of all valuations (as `\u0393\u2080` varies) on a ring `R` is not a set.\nThe \"relation\" is however reflexive, symmetric and transitive in the obvious\nsense. Note that we use 1.27(iii) of [wedhorn_adic] as the definition of equivalence.\n\n## Main definitions\n\n* `Valuation R \u0393\u2080`, the type of valuations on `R` with values in `\u0393\u2080`\n* `Valuation.IsEquiv`, the heterogeneous equivalence relation on valuations\n* `Valuation.supp`, the support of a valuation\n\n* `AddValuation R \u0393\u2080`, the type of additive valuations on `R` with values in a\n  linearly ordered additive commutative group with a top element, `\u0393\u2080`.\n\n## Implementation Details\n\n`AddValuation R \u0393\u2080` is implemented as `Valuation R (Multiplicative \u0393\u2080)\u1d52\u1d48`.\n\n## Notation\n\nIn the `DiscreteValuation` locale:\n\n * `\u2115\u2098\u2080` is a shorthand for `WithZero (Multiplicative \u2115)`\n * `\u2124\u2098\u2080` is a shorthand for `WithZero (Multiplicative \u2124)`\n\n## TODO\n\nIf ever someone extends `Valuation`, we should fully comply to the `DFunLike` by migrating the\nboilerplate lemmas to `ValuationClass`.\n-/\n\nopen Function Ideal\n\nnoncomputable section\n\nvariable {K F R : Type*} [DivisionRing K]\n\nsection\n\nvariable (F R) (\u0393\u2080 : Type*) [LinearOrderedCommMonoidWithZero \u0393\u2080] [Ring R]\n\n/-- The type of `\u0393\u2080`-valued valuations on `R`.\n\nWhen you extend this structure, make sure to extend `ValuationClass`. -/\nstructure Valuation extends R \u2192*\u2080 \u0393\u2080 where\n  /-- The valuation of a a sum is less that the sum of the valuations -/\n  map_add_le_max' : \u2200 x y, toFun (x + y) \u2264 max (toFun x) (toFun y)\n\n/-- `ValuationClass F \u03b1 \u03b2` states that `F` is a type of valuations.\n\nYou should also extend this typeclass when you extend `Valuation`. -/\nclass ValuationClass (F) (R \u0393\u2080 : outParam Type*) [LinearOrderedCommMonoidWithZero \u0393\u2080] [Ring R]\n  [FunLike F R \u0393\u2080]\n  extends MonoidWithZeroHomClass F R \u0393\u2080 : Prop where\n  /-- The valuation of a a sum is less that the sum of the valuations -/\n  map_add_le_max (f : F) (x y : R) : f (x + y) \u2264 max (f x) (f y)\n\nexport ValuationClass (map_add_le_max)\n\ninstance [FunLike F R \u0393\u2080] [ValuationClass F R \u0393\u2080] : CoeTC F (Valuation R \u0393\u2080) :=\n  \u27e8fun f =>\n    { toFun := f\n      map_one' := map_one f\n      map_zero' := map_zero f\n      map_mul' := map_mul f\n      map_add_le_max' := map_add_le_max f }\u27e9\n\nend\n\nnamespace Valuation\n\nvariable {\u0393\u2080 : Type*}\nvariable {\u0393'\u2080 : Type*}\nvariable {\u0393''\u2080 : Type*} [LinearOrderedCommMonoidWithZero \u0393''\u2080]\n\nsection Basic\n\nvariable [Ring R]\n\nsection Monoid\n\nvariable [LinearOrderedCommMonoidWithZero \u0393\u2080] [LinearOrderedCommMonoidWithZero \u0393'\u2080]\n\ninstance : FunLike (Valuation R \u0393\u2080) R \u0393\u2080 where\n  coe f := f.toFun\n  coe_injective' f g h := by\n    obtain \u27e8\u27e8\u27e8_,_\u27e9, _\u27e9, _\u27e9 := f\n    congr\n\ninstance : ValuationClass (Valuation R \u0393\u2080) R \u0393\u2080 where\n  map_mul f := f.map_mul'\n  map_one f := f.map_one'\n  map_zero f := f.map_zero'\n  map_add_le_max f := f.map_add_le_max'\n\n@[simp]\ntheorem coe_mk (f : R \u2192*\u2080 \u0393\u2080) (h) : \u21d1(Valuation.mk f h) = f := rfl\n\ntheorem toFun_eq_coe (v : Valuation R \u0393\u2080) : v.toFun = v := rfl\n\n@[simp]\ntheorem toMonoidWithZeroHom_coe_eq_coe (v : Valuation R \u0393\u2080) :\n    (v.toMonoidWithZeroHom : R \u2192 \u0393\u2080) = v := rfl\n\n@[ext]\ntheorem ext {v\u2081 v\u2082 : Valuation R \u0393\u2080} (h : \u2200 r, v\u2081 r = v\u2082 r) : v\u2081 = v\u2082 :=\n  DFunLike.ext _ _ h\n\nvariable (v : Valuation R \u0393\u2080)\n\n@[simp, norm_cast]\ntheorem coe_coe : \u21d1(v : R \u2192*\u2080 \u0393\u2080) = v := rfl\n\ntheorem map_zero : v 0 = 0 :=\n  v.map_zero'\n\ntheorem map_one : v 1 = 1 :=\n  v.map_one'\n\ntheorem map_mul : \u2200 x y, v (x * y) = v x * v y :=\n  v.map_mul'\n\n-- Porting note: LHS side simplified so created map_add'\ntheorem map_add : \u2200 x y, v (x + y) \u2264 max (v x) (v y) :=\n  v.map_add_le_max'\n\n@[simp]\ntheorem map_add' : \u2200 x y, v (x + y) \u2264 v x \u2228 v (x + y) \u2264 v y := by\n  intro x y\n  rw [\u2190 le_max_iff, \u2190 ge_iff_le]\n  apply map_add\n\ntheorem map_add_le {x y g} (hx : v x \u2264 g) (hy : v y \u2264 g) : v (x + y) \u2264 g :=\n  le_trans (v.map_add x y) <| max_le hx hy\n\ntheorem map_add_lt {x y g} (hx : v x < g) (hy : v y < g) : v (x + y) < g :=\n  lt_of_le_of_lt (v.map_add x y) <| max_lt hx hy\n\ntheorem map_sum_le {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hf : \u2200 i \u2208 s, v (f i) \u2264 g) :\n    v (\u2211 i \u2208 s, f i) \u2264 g := by\n  classical\n  refine\n    Finset.induction_on s (fun _ => v.map_zero \u25b8 zero_le')\n      (fun a s has ih hf => ?_) hf\n  rw [Finset.forall_mem_insert] at hf; rw [Finset.sum_insert has]\n  exact v.map_add_le hf.1 (ih hf.2)\n\ntheorem map_sum_lt {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hg : g \u2260 0)\n    (hf : \u2200 i \u2208 s, v (f i) < g) : v (\u2211 i \u2208 s, f i) < g := by\n  classical\n  refine\n    Finset.induction_on s (fun _ => v.map_zero \u25b8 (zero_lt_iff.2 hg))\n      (fun a s has ih hf => ?_) hf\n  rw [Finset.forall_mem_insert] at hf; rw [Finset.sum_insert has]\n  exact v.map_add_lt hf.1 (ih hf.2)\n\ntheorem map_sum_lt' {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hg : 0 < g)\n    (hf : \u2200 i \u2208 s, v (f i) < g) : v (\u2211 i \u2208 s, f i) < g :=\n  v.map_sum_lt (ne_of_gt hg) hf\n\ntheorem map_pow : \u2200 (x) (n : \u2115), v (x ^ n) = v x ^ n :=\n  v.toMonoidWithZeroHom.toMonoidHom.map_pow\n\n-- The following definition is not an instance, because we have more than one `v` on a given `R`.\n-- In addition, type class inference would not be able to infer `v`.\n/-- A valuation gives a preorder on the underlying ring. -/\ndef toPreorder : Preorder R :=\n  Preorder.lift v\n\n/-- If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. -/\ntheorem zero_iff [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) {x : K} : v x = 0 \u2194 x = 0 :=\n  map_eq_zero v\n\ntheorem ne_zero_iff [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) {x : K} : v x \u2260 0 \u2194 x \u2260 0 :=\n  map_ne_zero v\n\nlemma pos_iff [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) {x : K} : 0 < v x \u2194 x \u2260 0 := by\n  rw [zero_lt_iff, ne_zero_iff]\n\ntheorem unit_map_eq (u : R\u02e3) : (Units.map (v : R \u2192* \u0393\u2080) u : \u0393\u2080) = v u :=\n  rfl\n\ntheorem ne_zero_of_unit [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) (x : K\u02e3) : v x \u2260 (0 : \u0393\u2080) := by\n  simp only [ne_eq, Valuation.zero_iff, Units.ne_zero x, not_false_iff]\n\ntheorem ne_zero_of_isUnit [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) (x : K) (hx : IsUnit x) :\n    v x \u2260 (0 : \u0393\u2080) := by\n  simpa [hx.choose_spec] using ne_zero_of_unit v hx.choose\n\n/-- A ring homomorphism `S \u2192 R` induces a map `Valuation R \u0393\u2080 \u2192 Valuation S \u0393\u2080`. -/\ndef comap {S : Type*} [Ring S] (f : S \u2192+* R) (v : Valuation R \u0393\u2080) : Valuation S \u0393\u2080 :=\n  { v.toMonoidWithZeroHom.comp f.toMonoidWithZeroHom with\n    toFun := v \u2218 f\n    map_add_le_max' := fun x y => by simp only [comp_apply, map_add, f.map_add] }\n\n@[simp]\ntheorem comap_apply {S : Type*} [Ring S] (f : S \u2192+* R) (v : Valuation R \u0393\u2080) (s : S) :\n    v.comap f s = v (f s) := rfl\n\n@[simp]\ntheorem comap_id : v.comap (RingHom.id R) = v :=\n  ext fun _r => rfl\n\ntheorem comap_comp {S\u2081 : Type*} {S\u2082 : Type*} [Ring S\u2081] [Ring S\u2082] (f : S\u2081 \u2192+* S\u2082) (g : S\u2082 \u2192+* R) :\n    v.comap (g.comp f) = (v.comap g).comap f :=\n  ext fun _r => rfl\n\n/-- A `\u2264`-preserving group homomorphism `\u0393\u2080 \u2192 \u0393'\u2080` induces a map `Valuation R \u0393\u2080 \u2192 Valuation R \u0393'\u2080`.\n-/\ndef map (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080) (hf : Monotone f) (v : Valuation R \u0393\u2080) : Valuation R \u0393'\u2080 :=\n  { MonoidWithZeroHom.comp f v.toMonoidWithZeroHom with\n    toFun := f \u2218 v\n    map_add_le_max' := fun r s =>\n      calc\n        f (v (r + s)) \u2264 f (max (v r) (v s)) := hf (v.map_add r s)\n        _ = max (f (v r)) (f (v s)) := hf.map_max\n         }\n\n@[simp]\nlemma map_apply (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080) (hf : Monotone f) (v : Valuation R \u0393\u2080) (r : R) :\n    v.map f hf r = f (v r) := rfl\n\n/-- Two valuations on `R` are defined to be equivalent if they induce the same preorder on `R`. -/\ndef IsEquiv (v\u2081 : Valuation R \u0393\u2080) (v\u2082 : Valuation R \u0393'\u2080) : Prop :=\n  \u2200 r s, v\u2081 r \u2264 v\u2081 s \u2194 v\u2082 r \u2264 v\u2082 s\n\n@[simp]\ntheorem map_neg (x : R) : v (-x) = v x :=\n  v.toMonoidWithZeroHom.toMonoidHom.map_neg x\n\ntheorem map_sub_swap (x y : R) : v (x - y) = v (y - x) :=\n  v.toMonoidWithZeroHom.toMonoidHom.map_sub_swap x y\n\ntheorem map_sub (x y : R) : v (x - y) \u2264 max (v x) (v y) :=\n  calc\n    v (x - y) = v (x + -y) := by rw [sub_eq_add_neg]\n    _ \u2264 max (v x) (v <| -y) := v.map_add _ _\n    _ = max (v x) (v y) := by rw [map_neg]\n\ntheorem map_sub_le {x y g} (hx : v x \u2264 g) (hy : v y \u2264 g) : v (x - y) \u2264 g := by\n  rw [sub_eq_add_neg]\n  exact v.map_add_le hx (le_trans (le_of_eq (v.map_neg y)) hy)\n\nvariable {x y : R}\n\ntheorem map_add_of_distinct_val (h : v x \u2260 v y) : v (x + y) = max (v x) (v y) := by\n  suffices \u00acv (x + y) < max (v x) (v y) from\n    or_iff_not_imp_right.1 (le_iff_eq_or_lt.1 (v.map_add x y)) this\n  intro h'\n  wlog vyx : v y < v x generalizing x y\n  \u00b7 refine this h.symm ?_ (h.lt_or_lt.resolve_right vyx)\n    rwa [add_comm, max_comm]\n  rw [max_eq_left_of_lt vyx] at h'\n  apply lt_irrefl (v x)\n  calc\n    v x = v (x + y - y) := by simp\n    _ \u2264 max (v <| x + y) (v y) := map_sub _ _ _\n    _ < v x := max_lt h' vyx\n\ntheorem map_add_eq_of_lt_right (h : v x < v y) : v (x + y) = v y :=\n  (v.map_add_of_distinct_val h.ne).trans (max_eq_right_iff.mpr h.le)\n\ntheorem map_add_eq_of_lt_left (h : v y < v x) : v (x + y) = v x := by\n  rw [add_comm]; exact map_add_eq_of_lt_right _ h\n\ntheorem map_sub_eq_of_lt_right (h : v x < v y) : v (x - y) = v y := by\n  rw [sub_eq_add_neg, map_add_eq_of_lt_right, map_neg]\n  rwa [map_neg]\n\nopen scoped Classical in\ntheorem map_sum_eq_of_lt {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {j : \u03b9}\n    (hj : j \u2208 s) (h0 : v (f j) \u2260 0) (hf : \u2200 i \u2208 s \\ {j}, v (f i) < v (f j)) :\n    v (\u2211 i \u2208 s, f i) = v (f j) := by\n  rw [Finset.sum_eq_add_sum_diff_singleton hj]\n  exact map_add_eq_of_lt_left _ (map_sum_lt _ h0 hf)\n\ntheorem map_sub_eq_of_lt_left (h : v y < v x) : v (x - y) = v x := by\n  rw [sub_eq_add_neg, map_add_eq_of_lt_left]\n  rwa [map_neg]\n\ntheorem map_eq_of_sub_lt (h : v (y - x) < v x) : v y = v x := by\n  have := Valuation.map_add_of_distinct_val v (ne_of_gt h).symm\n  rw [max_eq_right (le_of_lt h)] at this\n  simpa using this\n\ntheorem map_one_add_of_lt (h : v x < 1) : v (1 + x) = 1 := by\n  rw [\u2190 v.map_one] at h\n  simpa only [v.map_one] using v.map_add_eq_of_lt_left h\n\ntheorem map_one_sub_of_lt (h : v x < 1) : v (1 - x) = 1 := by\n  rw [\u2190 v.map_one, \u2190 v.map_neg] at h\n  rw [sub_eq_add_neg 1 x]\n  simpa only [v.map_one, v.map_neg] using v.map_add_eq_of_lt_left h\n\n/-- An ordered monoid isomorphism `\u0393\u2080 \u2243 \u0393'\u2080` induces an equivalence\n`Valuation R \u0393\u2080 \u2243 Valuation R \u0393'\u2080`. -/\ndef congr (f : \u0393\u2080 \u2243*o \u0393'\u2080) : Valuation R \u0393\u2080 \u2243 Valuation R \u0393'\u2080 where\n  toFun := map f f.toOrderIso.monotone\n  invFun := map f.symm f.toOrderIso.symm.monotone\n  left_inv \u03bd := by ext; simp\n  right_inv \u03bd := by ext; simp\n\nend Monoid\n\nsection Group\n\nvariable [LinearOrderedCommGroupWithZero \u0393\u2080] (v : Valuation R \u0393\u2080) {x y : R}\n\ntheorem map_inv {R : Type*} [DivisionRing R] (v : Valuation R \u0393\u2080) : \u2200 x, v x\u207b\u00b9 = (v x)\u207b\u00b9 :=\n  map_inv\u2080 _\n\ntheorem map_div {R : Type*} [DivisionRing R] (v : Valuation R \u0393\u2080) : \u2200 x y, v (x / y) = v x / v y :=\n  map_div\u2080 _\n\ntheorem one_lt_val_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : 1 < v x \u2194 v x\u207b\u00b9 < 1 := by\n  simp [inv_lt_one\u2080 (v.pos_iff.2 h)]\n\ntheorem one_le_val_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : 1 \u2264 v x \u2194 v x\u207b\u00b9 \u2264 1 := by\n  simp [inv_le_one\u2080 (v.pos_iff.2 h)]\n\ntheorem val_lt_one_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : v x < 1 \u2194 1 < v x\u207b\u00b9 := by\n  simp [one_lt_inv\u2080 (v.pos_iff.2 h)]\n\ntheorem val_le_one_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : v x \u2264 1 \u2194 1 \u2264 v x\u207b\u00b9 := by\n  simp [one_le_inv\u2080 (v.pos_iff.2 h)]\n\ntheorem val_eq_one_iff (v : Valuation K \u0393\u2080) {x : K} : v x = 1 \u2194 v x\u207b\u00b9 = 1 := by\n  by_cases h : x = 0\n  \u00b7 simp only [map_inv\u2080, inv_eq_one]\n  \u00b7 simpa only [le_antisymm_iff, And.comm] using and_congr (one_le_val_iff v h) (val_le_one_iff v h)\n\ntheorem val_le_one_or_val_inv_lt_one (v : Valuation K \u0393\u2080) (x : K) : v x \u2264 1 \u2228 v x\u207b\u00b9 < 1 := by\n  by_cases h : x = 0\n  \u00b7 simp only [h, _root_.map_zero, zero_le', inv_zero, zero_lt_one, or_self]\n  \u00b7 simp only [\u2190 one_lt_val_iff v h, le_or_lt]\n\n/--\nThis theorem is a weaker version of `Valuation.val_le_one_or_val_inv_lt_one`, but more symmetric\nin `x` and `x\u207b\u00b9`.\n-/\ntheorem val_le_one_or_val_inv_le_one (v : Valuation K \u0393\u2080) (x : K) : v x \u2264 1 \u2228 v x\u207b\u00b9 \u2264 1 := by\n  by_cases h : x = 0\n  \u00b7 simp only [h, _root_.map_zero, zero_le', inv_zero, or_self]\n  \u00b7 simp only [\u2190 one_le_val_iff v h, le_total]\n\n/-- The subgroup of elements whose valuation is less than a certain unit. -/\ndef ltAddSubgroup (v : Valuation R \u0393\u2080) (\u03b3 : \u0393\u2080\u02e3) : AddSubgroup R where\n  carrier := { x | v x < \u03b3 }\n  zero_mem' := by simp\n  add_mem' {x y} x_in y_in := lt_of_le_of_lt (v.map_add x y) (max_lt x_in y_in)\n  neg_mem' x_in := by rwa [Set.mem_setOf, map_neg]\n\nend Group\n\nend Basic\n\n-- end of section\nnamespace IsEquiv\n\nvariable [Ring R] [LinearOrderedCommMonoidWithZero \u0393\u2080] [LinearOrderedCommMonoidWithZero \u0393'\u2080]\n  {v : Valuation R \u0393\u2080} {v\u2081 : Valuation R \u0393\u2080} {v\u2082 : Valuation R \u0393'\u2080} {v\u2083 : Valuation R \u0393''\u2080}\n\n@[refl]\ntheorem refl : v.IsEquiv v := fun _ _ => Iff.refl _\n\n@[symm]\ntheorem symm (h : v\u2081.IsEquiv v\u2082) : v\u2082.IsEquiv v\u2081 := fun _ _ => Iff.symm (h _ _)\n\n@[trans]\ntheorem trans (h\u2081\u2082 : v\u2081.IsEquiv v\u2082) (h\u2082\u2083 : v\u2082.IsEquiv v\u2083) : v\u2081.IsEquiv v\u2083 := fun _ _ =>\n  Iff.trans (h\u2081\u2082 _ _) (h\u2082\u2083 _ _)\n\ntheorem of_eq {v' : Valuation R \u0393\u2080} (h : v = v') : v.IsEquiv v' := by subst h; rfl\n\ntheorem map {v' : Valuation R \u0393\u2080} (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080) (hf : Monotone f) (inf : Injective f)\n    (h : v.IsEquiv v') : (v.map f hf).IsEquiv (v'.map f hf) :=\n  let H : StrictMono f := hf.strictMono_of_injective inf\n  fun r s =>\n  calc\n    f (v r) \u2264 f (v s) \u2194 v r \u2264 v s := by rw [H.le_iff_le]\n    _ \u2194 v' r \u2264 v' s := h r s\n    _ \u2194 f (v' r) \u2264 f (v' s) := by rw [H.le_iff_le]\n\n/-- `comap` preserves equivalence. -/\ntheorem comap {S : Type*} [Ring S] (f : S \u2192+* R) (h : v\u2081.IsEquiv v\u2082) :\n    (v\u2081.comap f).IsEquiv (v\u2082.comap f) := fun r s => h (f r) (f s)\n\ntheorem val_eq (h : v\u2081.IsEquiv v\u2082) {r s : R} : v\u2081 r = v\u2081 s \u2194 v\u2082 r = v\u2082 s := by\n  simpa only [le_antisymm_iff] using and_congr (h r s) (h s r)\n\ntheorem ne_zero (h : v\u2081.IsEquiv v\u2082) {r : R} : v\u2081 r \u2260 0 \u2194 v\u2082 r \u2260 0 := by\n  have : v\u2081 r \u2260 v\u2081 0 \u2194 v\u2082 r \u2260 v\u2082 0 := not_congr h.val_eq\n  rwa [v\u2081.map_zero, v\u2082.map_zero] at this\n\nend IsEquiv\n\n-- end of namespace\nsection\n\ntheorem isEquiv_of_map_strictMono [LinearOrderedCommMonoidWithZero \u0393\u2080]\n    [LinearOrderedCommMonoidWithZero \u0393'\u2080] [Ring R] {v : Valuation R \u0393\u2080} (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080)\n    (H : StrictMono f) : IsEquiv (v.map f H.monotone) v := fun _x _y =>\n  \u27e8H.le_iff_le.mp, fun h => H.monotone h\u27e9\n\ntheorem isEquiv_iff_val_lt_val [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x y : K}, v x < v y \u2194 v' x < v' y := by\n  simp only [IsEquiv, le_iff_le_iff_lt_iff_lt]\n  exact forall_comm\n\nalias \u27e8IsEquiv.lt_iff_lt, _\u27e9 := isEquiv_iff_val_lt_val\n\ntheorem isEquiv_of_val_le_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080}\n    (h : \u2200 {x : K}, v x \u2264 1 \u2194 v' x \u2264 1) : v.IsEquiv v' := by\n  intro x y\n  obtain rfl | hy := eq_or_ne y 0\n  \u00b7 simp\n  \u00b7 rw [\u2190 div_le_one\u2080, \u2190 v.map_div, h, v'.map_div, div_le_one\u2080] <;>\n      rwa [zero_lt_iff, ne_zero_iff]\n\ntheorem isEquiv_iff_val_le_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v x \u2264 1 \u2194 v' x \u2264 1 :=\n  \u27e8fun h x => by simpa using h x 1, isEquiv_of_val_le_one\u27e9\n\nalias \u27e8IsEquiv.le_one_iff_le_one, _\u27e9 := isEquiv_iff_val_le_one\n\ntheorem isEquiv_iff_val_eq_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v x = 1 \u2194 v' x = 1 := by\n  constructor\n  \u00b7 intro h x\n    simpa using @IsEquiv.val_eq _ _ _ _ _ _ v v' h x 1\n  \u00b7 intro h\n    apply isEquiv_of_val_le_one\n    intro x\n    constructor\n    \u00b7 intro hx\n      rcases lt_or_eq_of_le hx with hx' | hx'\n      \u00b7 have : v (1 + x) = 1 := by\n          rw [\u2190 v.map_one]\n          apply map_add_eq_of_lt_left\n          simpa\n        rw [h] at this\n        rw [show x = -1 + (1 + x) by simp]\n        refine le_trans (v'.map_add _ _) ?_\n        simp [this]\n      \u00b7 rw [h] at hx'\n        exact le_of_eq hx'\n    \u00b7 intro hx\n      rcases lt_or_eq_of_le hx with hx' | hx'\n      \u00b7 have : v' (1 + x) = 1 := by\n          rw [\u2190 v'.map_one]\n          apply map_add_eq_of_lt_left\n          simpa\n        rw [\u2190 h] at this\n        rw [show x = -1 + (1 + x) by simp]\n        refine le_trans (v.map_add _ _) ?_\n        simp [this]\n      \u00b7 rw [\u2190 h] at hx'\n        exact le_of_eq hx'\n\nalias \u27e8IsEquiv.eq_one_iff_eq_one, _\u27e9 := isEquiv_iff_val_eq_one\n\ntheorem isEquiv_iff_val_lt_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v x < 1 \u2194 v' x < 1 := by\n  constructor\n  \u00b7 intro h x\n    simp only [lt_iff_le_and_ne,\n      and_congr h.le_one_iff_le_one h.eq_one_iff_eq_one.not]\n  \u00b7 rw [isEquiv_iff_val_eq_one]\n    intro h x\n    by_cases hx : x = 0\n    \u00b7 simp only [(zero_iff _).2 hx, zero_ne_one]\n    constructor\n    \u00b7 intro hh\n      by_contra h_1\n      cases ne_iff_lt_or_gt.1 h_1 with\n      | inl h_2 => simpa [hh, lt_self_iff_false] using h.2 h_2\n      | inr h_2 =>\n          rw [\u2190 inv_one, \u2190 inv_eq_iff_eq_inv, \u2190 map_inv\u2080] at hh\n          exact hh.not_lt (h.2 ((one_lt_val_iff v' hx).1 h_2))\n    \u00b7 intro hh\n      by_contra h_1\n      cases ne_iff_lt_or_gt.1 h_1 with\n      | inl h_2 => simpa [hh, lt_self_iff_false] using h.1 h_2\n      | inr h_2 =>\n        rw [\u2190 inv_one, \u2190 inv_eq_iff_eq_inv, \u2190 map_inv\u2080] at hh\n        exact hh.not_lt (h.1 ((one_lt_val_iff v hx).1 h_2))\n\nalias \u27e8IsEquiv.lt_one_iff_lt_one, _\u27e9 := isEquiv_iff_val_lt_one\n\ntheorem isEquiv_iff_val_sub_one_lt_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v (x - 1) < 1 \u2194 v' (x - 1) < 1 := by\n  rw [isEquiv_iff_val_lt_one]\n  exact (Equiv.subRight 1).surjective.forall\n\nalias \u27e8IsEquiv.val_sub_one_lt_one_iff, _\u27e9 := isEquiv_iff_val_sub_one_lt_one\n\ntheorem isEquiv_tfae [LinearOrderedCommGroupWithZero \u0393\u2080] [LinearOrderedCommGroupWithZero \u0393'\u2080]\n    (v : Valuation K \u0393\u2080) (v' : Valuation K \u0393'\u2080) :\n    [ v.IsEquiv v',\n      \u2200 {x y}, v x < v y \u2194 v' x < v' y,\n      \u2200 {x}, v x \u2264 1 \u2194 v' x \u2264 1,\n      \u2200 {x}, v x = 1 \u2194 v' x = 1,\n      \u2200 {x}, v x < 1 \u2194 v' x < 1,\n      \u2200 {x}, v (x - 1) < 1 \u2194 v' (x - 1) < 1 ].TFAE := by\n  tfae_have 1 \u2194 2 := isEquiv_iff_val_lt_val\n  tfae_have 1 \u2194 3 := isEquiv_iff_val_le_one\n  tfae_have 1 \u2194 4 := isEquiv_iff_val_eq_one\n  tfae_have 1 \u2194 5 := isEquiv_iff_val_lt_one\n  tfae_have 1 \u2194 6 := isEquiv_iff_val_sub_one_lt_one\n  tfae_finish\n\nend\n\nsection Supp\n\nvariable [CommRing R] [LinearOrderedCommMonoidWithZero \u0393\u2080] (v : Valuation R \u0393\u2080)\n\n/-- The support of a valuation `v : R \u2192 \u0393\u2080` is the ideal of `R` where `v` vanishes. -/\ndef supp : Ideal R where\n  carrier := { x | v x = 0 }\n  zero_mem' := map_zero v\n  add_mem' {x y} hx hy := le_zero_iff.mp <|\n    calc\n      v (x + y) \u2264 max (v x) (v y) := v.map_add x y\n      _ \u2264 0 := max_le (le_zero_iff.mpr hx) (le_zero_iff.mpr hy)\n  smul_mem' c x hx :=\n    calc\n      v (c * x) = v c * v x := map_mul v c x\n      _ = v c * 0 := congr_arg _ hx\n      _ = 0 := mul_zero _\n\n@[simp]\ntheorem mem_supp_iff (x : R) : x \u2208 supp v \u2194 v x = 0 :=\n  Iff.rfl\n\n/-- The support of a valuation is a prime ideal. -/\ninstance [Nontrivial \u0393\u2080] [NoZeroDivisors \u0393\u2080] : Ideal.IsPrime (supp v) :=\n  \u27e8fun h =>\n    one_ne_zero (\u03b1 := \u0393\u2080) <|\n      calc\n        1 = v 1 := v.map_one.symm\n        _ = 0 := by rw [\u2190 mem_supp_iff, h]; exact Submodule.mem_top,\n   fun {x y} hxy => by\n    simp only [mem_supp_iff] at hxy \u22a2\n    rw [v.map_mul x y] at hxy\n    exact eq_zero_or_eq_zero_of_mul_eq_zero hxy\u27e9\n\ntheorem map_add_supp (a : R) {s : R} (h : s \u2208 supp v) : v (a + s) = v a := by\n  have aux : \u2200 a s, v s = 0 \u2192 v (a + s) \u2264 v a := by\n    intro a' s' h'\n    refine le_trans (v.map_add a' s') (max_le le_rfl ?_)\n    simp [h']\n  apply le_antisymm (aux a s h)\n  calc\n    v a = v (a + s + -s) := by simp\n    _ \u2264 v (a + s) := aux (a + s) (-s) (by rwa [\u2190 Ideal.neg_mem_iff] at h)\n\ntheorem comap_supp {S : Type*} [CommRing S] (f : S \u2192+* R) :\n    supp (v.comap f) = Ideal.comap f v.supp :=\n  Ideal.ext fun x => by rw [mem_supp_iff, Ideal.mem_comap, mem_supp_iff, comap_apply]\n\nend Supp\n\n-- end of section\nend Valuation\n\nsection AddMonoid\n\nvariable (R) [Ring R] (\u0393\u2080 : Type*) [LinearOrderedAddCommMonoidWithTop \u0393\u2080]\n\n/-- The type of `\u0393\u2080`-valued additive valuations on `R`. -/\ndef AddValuation :=\n  Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48)\n\nend AddMonoid\n\nnamespace AddValuation\n\nvariable {\u0393\u2080 : Type*} {\u0393'\u2080 : Type*}\n\nsection Basic\n\nsection Monoid\n\n/-- A valuation is coerced to the underlying function `R \u2192 \u0393\u2080`. -/\ninstance (R) (\u0393\u2080) [Ring R] [LinearOrderedAddCommMonoidWithTop \u0393\u2080] :\n    FunLike (AddValuation R \u0393\u2080) R \u0393\u2080 where\n  coe v := v.toMonoidWithZeroHom.toFun\n  coe_injective' f g := by cases f; cases g; simp (config := {contextual := true})\n\nvariable [Ring R] [LinearOrderedAddCommMonoidWithTop \u0393\u2080] [LinearOrderedAddCommMonoidWithTop \u0393'\u2080]\n  (v : AddValuation R \u0393\u2080)\n\nsection\n\nvariable (f : R \u2192 \u0393\u2080) (h0 : f 0 = \u22a4) (h1 : f 1 = 0)\nvariable (hadd : \u2200 x y, min (f x) (f y) \u2264 f (x + y)) (hmul : \u2200 x y, f (x * y) = f x + f y)\n\n/-- An alternate constructor of `AddValuation`, that doesn't reference `Multiplicative \u0393\u2080\u1d52\u1d48` -/\ndef of : AddValuation R \u0393\u2080 where\n  toFun := f\n  map_one' := h1\n  map_zero' := h0\n  map_add_le_max' := hadd\n  map_mul' := hmul\n\nvariable {h0} {h1} {hadd} {hmul} {r : R}\n\n@[simp]\ntheorem of_apply : (of f h0 h1 hadd hmul) r = f r := rfl\n\n/-- The `Valuation` associated to an `AddValuation` (useful if the latter is constructed using\n`AddValuation.of`). -/\ndef toValuation : AddValuation R \u0393\u2080 \u2243 Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48) :=\n  Equiv.refl _\n\n@[deprecated (since := \"2024-11-09\")]\nalias valuation := toValuation\n\n/-- The `AddValuation` associated to a `Valuation`.\n-/\ndef ofValuation : Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48) \u2243 AddValuation R \u0393\u2080 :=\n  Equiv.refl _\n\n@[simp]\nlemma ofValuation_symm_eq : ofValuation.symm = toValuation (R := R) (\u0393\u2080 := \u0393\u2080) := rfl\n\n@[simp]\nlemma toValuation_symm_eq : toValuation.symm = ofValuation (R := R) (\u0393\u2080 := \u0393\u2080) := rfl\n\n@[simp]\nlemma ofValuation_toValuation : ofValuation (toValuation v) = v := rfl\n\n@[simp]\nlemma toValuation_ofValuation (v : Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48)) :\n    toValuation (ofValuation v) = v := rfl\n\n@[simp]\ntheorem toValuation_apply (r : R) :\n    toValuation v r = Multiplicative.ofAdd (OrderDual.toDual (v r)) :=\n  rfl\n\n@[deprecated (since := \"2024-11-09\")]\nalias valuation_apply := toValuation_apply\n\n@[simp]\ntheorem ofValuation_apply (v : Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48)) (r : R) :\n    ofValuation v r = OrderDual.ofDual (Multiplicative.toAdd (v r)) :=\n  rfl\n\nend\n\n-- Porting note: Lean get confused about namespaces and instances below\n@[simp]\ntheorem map_zero : v 0 = (\u22a4 : \u0393\u2080) :=\n  Valuation.map_zero v\n\n@[simp]\ntheorem map_one : v 1 = (0 : \u0393\u2080) :=\n  Valuation.map_one v\n\n/- Porting note: helper wrapper to coerce `v` to the correct function type -/\n/-- A helper function for Lean to inferring types correctly -/\ndef asFun : R \u2192 \u0393\u2080 := v\n\n@[simp]\ntheorem map_mul : \u2200 (x y : R), v (x * y) = v x + v y :=\n  Valuation.map_mul v\n\n-- Porting note: LHS simplified so created map_add' and removed simp tag\ntheorem map_add : \u2200 (x y : R), min (v x) (v y) \u2264 v (x + y) :=\n  Valuation.map_add v\n\n@[simp]\ntheorem map_add' : \u2200 (x y : R), v x \u2264 v (x + y) \u2228 v y \u2264 v (x + y) := by\n  intro x y\n  rw [\u2190 @min_le_iff _ _ (v x) (v y) (v (x+y)), \u2190 ge_iff_le]\n  apply map_add\n\ntheorem map_le_add {x y : R} {g : \u0393\u2080} (hx : g \u2264 v x) (hy : g \u2264 v y) : g \u2264 v (x + y) :=\n  Valuation.map_add_le v hx hy\n\ntheorem map_lt_add {x y : R} {g : \u0393\u2080} (hx : g < v x) (hy : g < v y) : g < v (x + y) :=\n  Valuation.map_add_lt v hx hy\n\ntheorem map_le_sum {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hf : \u2200 i \u2208 s, g \u2264 v (f i)) :\n    g \u2264 v (\u2211 i \u2208 s, f i) :=\n  v.map_sum_le hf\n\ntheorem map_lt_sum {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hg : g \u2260 \u22a4)\n    (hf : \u2200 i \u2208 s, g < v (f i)) : g < v (\u2211 i \u2208 s, f i) :=\n  v.map_sum_lt hg hf\n\ntheorem map_lt_sum' {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hg : g < \u22a4)\n    (hf : \u2200 i \u2208 s, g < v (f i)) : g < v (\u2211 i \u2208 s, f i) :=\n  v.map_sum_lt' hg hf\n\n@[simp]\ntheorem map_pow : \u2200 (x : R) (n : \u2115), v (x ^ n) = n \u2022 (v x) :=\n  Valuation.map_pow v\n\n@[ext]\ntheorem ext {v\u2081 v\u2082 : AddValuation R \u0393\u2080} (h : \u2200 r, v\u2081 r = v\u2082 r) : v\u2081 = v\u2082 :=\n  Valuation.ext h\n\n-- The following definition is not an instance, because we have more than one `v` on a given `R`.\n-- In addition, type class inference would not be able to infer `v`.\n/-- A valuation gives a preorder on the underlying ring. -/\ndef toPreorder : Preorder R :=\n  Preorder.lift v\n\n/-- If `v` is an additive valuation on a division ring then `v(x) = \u22a4` iff `x = 0`. -/\n@[simp]\ntheorem top_iff [Nontrivial \u0393\u2080] (v : AddValuation K \u0393\u2080) {x : K} : v x = (\u22a4 : \u0393\u2080) \u2194 x = 0 :=\n  v.zero_iff\n\ntheorem ne_top_iff [Nontrivial \u0393\u2080] (v : AddValuation K \u0393\u2080) {x : K} : v x \u2260 (\u22a4 : \u0393\u2080) \u2194 x \u2260 0 :=\n  v.ne_zero_iff\n\n/-- A ring homomorphism `S \u2192 R` induces a map `AddValuation R \u0393\u2080 \u2192 AddValuation S \u0393\u2080`. -/\ndef comap {S : Type*} [Ring S] (f : S \u2192+* R) (v : AddValuation R \u0393\u2080) : AddValuation S \u0393\u2080 :=\n  Valuation.comap f v\n\n@[simp]\ntheorem comap_id : v.comap (RingHom.id R) = v :=\n  Valuation.comap_id v\n\ntheorem comap_comp {S\u2081 : Type*} {S\u2082 : Type*} [Ring S\u2081] [Ring S\u2082] (f : S\u2081 \u2192+* S\u2082) (g : S\u2082 \u2192+* R) :\n    v.comap (g.comp f) = (v.comap g).comap f :=\n  Valuation.comap_comp v f g\n\n/-- A `\u2264`-preserving, `\u22a4`-preserving group homomorphism `\u0393\u2080 \u2192 \u0393'\u2080` induces a map\n  `AddValuation R \u0393\u2080 \u2192 AddValuation R \u0393'\u2080`.\n-/\ndef map (f : \u0393\u2080 \u2192+ \u0393'\u2080) (ht : f \u22a4 = \u22a4) (hf : Monotone f) (v : AddValuation R \u0393\u2080) :\n    AddValuation R \u0393'\u2080 :=\n  @Valuation.map R (Multiplicative \u0393\u2080\u1d52\u1d48) (Multiplicative \u0393'\u2080\u1d52\u1d48) _ _ _\n    { toFun := f\n      map_mul' := f.map_add\n      map_one' := f.map_zero\n      map_zero' := ht } (fun _ _ h => hf h) v\n\n@[simp]\nlemma map_apply (f : \u0393\u2080 \u2192+ \u0393'\u2080) (ht : f \u22a4 = \u22a4) (hf : Monotone f) (v : AddValuation R \u0393\u2080) (r : R) :\n    v.map f ht hf r = f (v r) := rfl\n\n/-- Two additive valuations on `R` are defined to be equivalent if they induce the same\n  preorder on `R`. -/\ndef IsEquiv (v\u2081 : AddValuation R \u0393\u2080) (v\u2082 : AddValuation R \u0393'\u2080) : Prop :=\n  Valuation.IsEquiv v\u2081 v\u2082\n\n@[simp]\ntheorem map_neg (x : R) : v (-x) = v x :=\n  Valuation.map_neg v x\n\ntheorem map_sub_swap (x y : R) : v (x - y) = v (y - x) :=\n  Valuation.map_sub_swap v x y\n\ntheorem map_sub (x y : R) : min (v x) (v y) \u2264 v (x - y) :=\n  Valuation.map_sub v x y\n\ntheorem map_le_sub {x y : R} {g : \u0393\u2080} (hx : g \u2264 v x) (hy : g \u2264 v y) : g \u2264 v (x - y) :=\n  Valuation.map_sub_le v hx hy\n\nvariable {x y : R}\n\ntheorem map_add_of_distinct_val (h : v x \u2260 v y) : v (x + y) = @Min.min \u0393\u2080 _ (v x) (v y) :=\n  Valuation.map_add_of_distinct_val v h\n\ntheorem map_add_eq_of_lt_left {x y : R} (h : v x < v y) :\n    v (x + y) = v x := by\n  rw [map_add_of_distinct_val _ h.ne, min_eq_left h.le]\n\ntheorem map_add_eq_of_lt_right {x y : R} (hx : v y < v x) :\n    v (x + y) = v y := add_comm y x \u25b8 map_add_eq_of_lt_left v hx\n\ntheorem map_sub_eq_of_lt_left {x y : R} (hx : v x < v y) :\n    v (x - y) = v x := by\n  rw [sub_eq_add_neg]\n  apply map_add_eq_of_lt_left\n  rwa [map_neg]\n\ntheorem map_sub_eq_of_lt_right {x y : R} (hx : v y < v x) :\n    v (x - y) = v y := map_sub_swap v x y \u25b8 map_sub_eq_of_lt_left v hx\n\ntheorem map_eq_of_lt_sub (h : v x < v (y - x)) : v y = v x :=\n  Valuation.map_eq_of_sub_lt v h\n\nend Monoid\n\nsection Group\n\nvariable [LinearOrderedAddCommGroupWithTop \u0393\u2080] [Ring R] (v : AddValuation R \u0393\u2080) {x y : R}\n\n@[simp]\ntheorem map_inv (v : AddValuation K \u0393\u2080) {x : K} : v x\u207b\u00b9 = - (v x) :=\n  map_inv\u2080 (toValuation v) x\n\n@[simp]\ntheorem map_div (v : AddValuation K \u0393\u2080) {x y : K} : v (x / y) = v x - v y :=\n  map_div\u2080 (toValuation v) x y\n\nend Group\n\nend Basic\n\nnamespace IsEquiv\n\nvariable [LinearOrderedAddCommMonoidWithTop \u0393\u2080] [LinearOrderedAddCommMonoidWithTop \u0393'\u2080]\n  [Ring R]\n  {\u0393''\u2080 : Type*} [LinearOrderedAddCommMonoidWithTop \u0393''\u2080]\n  {v : AddValuation R \u0393\u2080}\n   {v\u2081 : AddValuation R \u0393\u2080} {v\u2082 : AddValuation R \u0393'\u2080} {v\u2083 : AddValuation R \u0393''\u2080}\n\n@[refl]\ntheorem refl : v.IsEquiv v :=\n  Valuation.IsEquiv.refl\n\n@[symm]\ntheorem symm (h : v\u2081.IsEquiv v\u2082) : v\u2082.IsEquiv v\u2081 :=\n  Valuation.IsEquiv.symm h\n\n@[trans]\ntheorem trans (h\u2081\u2082 : v\u2081.IsEquiv v\u2082) (h\u2082\u2083 : v\u2082.IsEquiv v\u2083) : v\u2081.IsEquiv v\u2083 :=\n  Valuation.IsEquiv.trans h\u2081\u2082 h\u2082\u2083\n\ntheorem of_eq {v' : AddValuation R \u0393\u2080} (h : v = v') : v.IsEquiv v' :=\n  Valuation.IsEquiv.of_eq h\n\ntheorem map {v' : AddValuation R \u0393\u2080} (f : \u0393\u2080 \u2192+ \u0393'\u2080) (ht : f \u22a4 = \u22a4) (hf : Monotone f)\n    (inf : Injective f) (h : v.IsEquiv v') : (v.map f ht hf).IsEquiv (v'.map f ht hf) :=\n  @Valuation.IsEquiv.map R (Multiplicative \u0393\u2080\u1d52\u1d48) (Multiplicative \u0393'\u2080\u1d52\u1d48) _ _ _ _ _\n    { toFun := f\n      map_mul' := f.map_add\n      map_one' := f.map_zero\n      map_zero' := ht } (fun _x _y h => hf h) inf h\n\n/-- `comap` preserves equivalence. -/\ntheorem comap {S : Type*} [Ring S] (f : S \u2192+* R) (h : v\u2081.IsEquiv v\u2082) :\n    (v\u2081.comap f).IsEquiv (v\u2082.comap f) :=\n  Valuation.IsEquiv.comap f h\n\ntheorem val_eq (h : v\u2081.IsEquiv v\u2082) {r s : R} : v\u2081 r = v\u2081 s \u2194 v\u2082 r = v\u2082 s :=\n  Valuation.IsEquiv.val_eq h\n\ntheorem ne_top (h : v\u2081.IsEquiv v\u2082) {r : R} : v\u2081 r \u2260 (\u22a4 : \u0393\u2080) \u2194 v\u2082 r \u2260 (\u22a4 : \u0393'\u2080) :=\n  Valuation.IsEquiv.ne_zero h\n\nend IsEquiv\n\nsection Supp\n\nvariable [LinearOrderedAddCommMonoidWithTop \u0393\u2080] [CommRing R] (v : AddValuation R \u0393\u2080)\n\n/-- The support of an additive valuation `v : R \u2192 \u0393\u2080` is the ideal of `R` where `v x = \u22a4` -/\ndef supp : Ideal R :=\n  Valuation.supp v\n\n@[simp]\ntheorem mem_supp_iff (x : R) : x \u2208 supp v \u2194 v x = (\u22a4 : \u0393\u2080) :=\n  Valuation.mem_supp_iff v x\n\ntheorem map_add_supp (a : R) {s : R} (h : s \u2208 supp v) : v (a + s) = v a :=\n  Valuation.map_add_supp v a h\n\nend Supp\n\n-- end of section\nend AddValuation\n\nnamespace Valuation\n\nvariable {K \u0393\u2080 : Type*} [Ring R] [LinearOrderedCommMonoidWithZero \u0393\u2080]\n\n/-- The `AddValuation` associated to a `Valuation`. -/\ndef toAddValuation : Valuation R \u0393\u2080 \u2243 AddValuation R (Additive \u0393\u2080)\u1d52\u1d48 :=\n  .trans (congr\n    { toFun := fun x \u21a6 .ofAdd <| .toDual <| .toDual <| .ofMul x\n      invFun := fun x \u21a6 x.toAdd.ofDual.ofDual.toMul\n      left_inv := fun _x \u21a6 rfl\n      right_inv := fun _x \u21a6 rfl\n      map_mul' := fun _x _y \u21a6 rfl\n      map_le_map_iff' := .rfl }) (AddValuation.ofValuation (R := R) (\u0393\u2080 := (Additive \u0393\u2080)\u1d52\u1d48))\n\n/-- The `Valuation` associated to a `AddValuation`.\n-/\ndef ofAddValuation : AddValuation R (Additive \u0393\u2080)\u1d52\u1d48 \u2243 Valuation R \u0393\u2080 :=\n  AddValuation.toValuation.trans <| congr <|\n    { toFun := fun x \u21a6 x.toAdd.ofDual.ofDual.toMul\n      invFun := fun x \u21a6 .ofAdd <| .toDual <| .toDual <| .ofMul x\n      left_inv := fun _x \u21a6 rfl\n      right_inv := fun _x \u21a6 rfl\n      map_mul' := fun _x _y \u21a6 rfl\n      map_le_map_iff' := .rfl }\n\n", "theoremStatement": "@[simp]\nlemma ofAddValuation_symm_eq : ofAddValuation.symm = toAddValuation (R := R) (\u0393\u2080 := \u0393\u2080) ", "theoremName": "Valuation.ofAddValuation_symm_eq", "fileCreated": {"commit": "a9138cdba12f2110c86195f5eac26cb36dee2627", "date": "2023-03-17"}, "theoremCreated": {"commit": "625ac34a53dfa0eca4fb8a3a933409238e4f43f0", "date": "2024-12-16"}, "file": "mathlib/Mathlib/RingTheory/Valuation/Basic.lean", "module": "Mathlib.RingTheory.Valuation.Basic", "jsonFile": "Mathlib.RingTheory.Valuation.Basic.jsonl", "positionMetadata": {"lineInFile": 931, "tokenPositionInFile": 31694, "theoremPositionInFile": 128}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 11, "numPremises": 13}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "/-\nCopyright (c) 2024 Fangming Li. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Fangming Li, Jujian Zhang\n-/\nimport Mathlib.Algebra.Polynomial.AlgebraMap\nimport Mathlib.Algebra.Polynomial.Eval.SMul\nimport Mathlib.Algebra.Polynomial.Roots\nimport Mathlib.Order.Interval.Set.Infinite\nimport Mathlib.RingTheory.Polynomial.Pochhammer\nimport Mathlib.RingTheory.PowerSeries.WellKnown\nimport Mathlib.Tactic.FieldSimp\n\n/-!\n# Hilbert polynomials\n\nIn this file, we formalise the following statement: if `F` is a field with characteristic `0`, then\ngiven any `p : F[X]` and `d : \u2115`, there exists some `h : F[X]` such that for any large enough\n`n : \u2115`, `h(n)` is equal to the coefficient of `X\u207f` in the power series expansion of `p/(1 - X)\u1d48`.\nThis `h` is unique and is denoted as `Polynomial.hilbertPoly p d`.\n\nFor example, given `d : \u2115`, the power series expansion of `1/(1 - X)\u1d48\u207a\u00b9` in `F[X]`\nis `\u03a3\u2099 ((d + n).choose d)X\u207f`, which equals `\u03a3\u2099 ((n + 1)\u00b7\u00b7\u00b7(n + d)/d!)X\u207f` and hence\n`Polynomial.hilbertPoly (1 : F[X]) (d + 1)` is the polynomial `(X + 1)\u00b7\u00b7\u00b7(X + d)/d!`. Note that\nif `d! = 0` in `F`, then the polynomial `(X + 1)\u00b7\u00b7\u00b7(X + d)/d!` no longer works, so we do not want\nthe characteristic of `F` to be divisible by `d!`. As `Polynomial.hilbertPoly` may take any\n`p : F[X]` and `d : \u2115` as its inputs, it is necessary for us to assume that `CharZero F`.\n\n## Main definitions\n\n* `Polynomial.hilbertPoly p d`. Given a field `F`, a polynomial `p : F[X]` and a natural number `d`,\n  if `F` is of characteristic `0`, then `Polynomial.hilbertPoly p d : F[X]` is the polynomial whose\n  value at `n` equals the coefficient of `X\u207f` in the power series expansion of `p/(1 - X)\u1d48`.\n\n## TODO\n\n* Hilbert polynomials of finitely generated graded modules over Noetherian rings.\n-/\n\nopen Nat PowerSeries\n\nvariable (F : Type*) [Field F]\n\nnamespace Polynomial\n\n/--\nFor any field `F` and natural numbers `d` and `k`, `Polynomial.preHilbertPoly F d k`\nis defined as `(d.factorial : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (X - (C (k : F)) + 1))`.\nThis is the most basic form of Hilbert polynomials. `Polynomial.preHilbertPoly \u211a d 0`\nis exactly the Hilbert polynomial of the polynomial ring `\u211a[X_0,...,X_d]` viewed as\na graded module over itself. In fact, `Polynomial.preHilbertPoly F d k` is the\nsame as `Polynomial.hilbertPoly ((X : F[X]) ^ k) (d + 1)` for any field `F` and\n`d k : \u2115` (see the lemma `Polynomial.hilbertPoly_X_pow_succ`). See also the lemma\n`Polynomial.preHilbertPoly_eq_choose_sub_add`, which states that if `CharZero F`,\nthen for any `d k n : \u2115` with `k \u2264 n`, `(Polynomial.preHilbertPoly F d k).eval (n : F)`\nequals `(n - k + d).choose d`.\n-/\nnoncomputable def preHilbertPoly (d k : \u2115) : F[X] :=\n  (d.factorial : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (Polynomial.X - (C (k : F)) + 1))\n\nlemma natDegree_preHilbertPoly [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).natDegree = d := by\n  have hne : (d ! : F) \u2260 0 := by norm_cast; positivity\n  rw [preHilbertPoly, natDegree_smul _ (inv_ne_zero hne), natDegree_comp, ascPochhammer_natDegree,\n    add_comm_sub, \u2190 C_1, \u2190 map_sub, natDegree_add_C, natDegree_X, mul_one]\n\nlemma coeff_preHilbertPoly_self [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).coeff d = (d ! : F)\u207b\u00b9 := by\n  delta preHilbertPoly\n  have hne : (d ! : F) \u2260 0 := by norm_cast; positivity\n  have heq : d = ((ascPochhammer F d).comp (X - C (k : F) + 1)).natDegree :=\n    (natDegree_preHilbertPoly F d k).symm.trans (natDegree_smul _ (inv_ne_zero hne))\n  nth_rw 3 [heq]\n  calc\n  _ = (d ! : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (X - C ((k : F) - 1))).leadingCoeff := by\n    simp only [sub_add, \u2190 C_1, \u2190 map_sub, coeff_smul, coeff_natDegree]\n  _ = (d ! : F)\u207b\u00b9 := by\n    simp only [leadingCoeff_comp (ne_of_eq_of_ne (natDegree_X_sub_C _) one_ne_zero), Monic.def.1\n      (monic_ascPochhammer _ _), one_mul, leadingCoeff_X_sub_C, one_pow, smul_eq_mul, mul_one]\n\nlemma leadingCoeff_preHilbertPoly [CharZero F] (d k : \u2115) :\n    (preHilbertPoly F d k).leadingCoeff = (d ! : F)\u207b\u00b9 := by\n  rw [leadingCoeff, natDegree_preHilbertPoly, coeff_preHilbertPoly_self]\n\nlemma preHilbertPoly_eq_choose_sub_add [CharZero F] (d : \u2115) {k n : \u2115} (hkn : k \u2264 n):\n    (preHilbertPoly F d k).eval (n : F) = (n - k + d).choose d := by\n  have : (d ! : F) \u2260 0 := by norm_cast; positivity\n  calc\n  _ = (\u2191d !)\u207b\u00b9 * eval (\u2191(n - k + 1)) (ascPochhammer F d) := by simp [cast_sub hkn, preHilbertPoly]\n  _ = (n - k + d).choose d := by\n    rw [ascPochhammer_nat_eq_natCast_ascFactorial];\n    field_simp [ascFactorial_eq_factorial_mul_choose]\n\nvariable {F}\n\n/--\n`Polynomial.hilbertPoly p 0 = 0`; for any `d : \u2115`, `Polynomial.hilbertPoly p (d + 1)`\nis defined as `\u2211 i \u2208 p.support, (p.coeff i) \u2022 Polynomial.preHilbertPoly F d i`. If\n`M` is a graded module whose Poincar\u00e9 series can be written as `p(X)/(1 - X)\u1d48` for some\n`p : \u211a[X]` with integer coefficients, then `Polynomial.hilbertPoly p d` is the Hilbert\npolynomial of `M`. See also `Polynomial.coeff_mul_invOneSubPow_eq_hilbertPoly_eval`,\nwhich says that `PowerSeries.coeff F n (p * PowerSeries.invOneSubPow F d)` equals\n`(Polynomial.hilbertPoly p d).eval (n : F)` for any large enough `n : \u2115`.\n-/\nnoncomputable def hilbertPoly (p : F[X]) : (d : \u2115) \u2192 F[X]\n  | 0 => 0\n  | d + 1 => \u2211 i \u2208 p.support, (p.coeff i) \u2022 preHilbertPoly F d i\n\nlemma hilbertPoly_zero_left (d : \u2115) : hilbertPoly (0 : F[X]) d = 0 := by\n  delta hilbertPoly; induction d with\n  | zero => simp only\n  | succ d _ => simp only [coeff_zero, zero_smul, Finset.sum_const_zero]\n\nlemma hilbertPoly_zero_right (p : F[X]) : hilbertPoly p 0 = 0 := rfl\n\nlemma hilbertPoly_succ (p : F[X]) (d : \u2115) :\n    hilbertPoly p (d + 1) = \u2211 i \u2208 p.support, (p.coeff i) \u2022 preHilbertPoly F d i := rfl\n\nlemma hilbertPoly_X_pow_succ (d k : \u2115) :\n    hilbertPoly ((X : F[X]) ^ k) (d + 1) = preHilbertPoly F d k := by\n  delta hilbertPoly; simp\n\nlemma hilbertPoly_add_left (p q : F[X]) (d : \u2115) :\n    hilbertPoly (p + q) d = hilbertPoly p d + hilbertPoly q d := by\n  delta hilbertPoly\n  induction d with\n  | zero => simp only [add_zero]\n  | succ d _ =>\n      simp only [\u2190 coeff_add]\n      rw [\u2190 sum_def _ fun _ r => r \u2022 _]\n      exact sum_add_index _ _ _ (fun _ => zero_smul ..) (fun _ _ _ => add_smul ..)\n\nlemma hilbertPoly_smul (a : F) (p : F[X]) (d : \u2115) :\n    hilbertPoly (a \u2022 p) d = a \u2022 hilbertPoly p d := by\n  delta hilbertPoly\n  induction d with\n  | zero => simp only [smul_zero]\n  | succ d _ =>\n      simp only\n      rw [\u2190 sum_def _ fun _ r => r \u2022 _, \u2190 sum_def _ fun _ r => r \u2022 _, Polynomial.smul_sum,\n        sum_smul_index' _ _ _ fun i => zero_smul F (preHilbertPoly F d i)]\n      simp only [smul_assoc]\n\nvariable (F) in\n/--\nThe function that sends any `p : F[X]` to `Polynomial.hilbertPoly p d` is an `F`-linear map from\n`F[X]` to `F[X]`.\n-/\nnoncomputable def hilbertPoly_linearMap (d : \u2115) : F[X] \u2192\u2097[F] F[X] where\n  toFun p := hilbertPoly p d\n  map_add' p q := hilbertPoly_add_left p q d\n  map_smul' r p := hilbertPoly_smul r p d\n\nvariable [CharZero F]\n\n/--\nThe key property of Hilbert polynomials. If `F` is a field with characteristic `0`, `p : F[X]` and\n`d : \u2115`, then for any large enough `n : \u2115`, `(Polynomial.hilbertPoly p d).eval (n : F)` equals the\ncoefficient of `X\u207f` in the power series expansion of `p/(1 - X)\u1d48`.\n-/\ntheorem coeff_mul_invOneSubPow_eq_hilbertPoly_eval\n    {p : F[X]} (d : \u2115) {n : \u2115} (hn : p.natDegree < n) :\n    PowerSeries.coeff F n (p * invOneSubPow F d) = (hilbertPoly p d).eval (n : F) := by\n  delta hilbertPoly; induction d with\n  | zero => simp only [invOneSubPow_zero, Units.val_one, mul_one, coeff_coe, eval_zero]\n            exact coeff_eq_zero_of_natDegree_lt hn\n  | succ d hd =>\n      simp only [eval_finset_sum, eval_smul, smul_eq_mul]\n      rw [\u2190 Finset.sum_coe_sort]\n      have h_le (i : p.support) : (i : \u2115) \u2264 n :=\n        le_trans (le_natDegree_of_ne_zero <| mem_support_iff.1 i.2) hn.le\n      have h (i : p.support) : eval \u2191n (preHilbertPoly F d \u2191i) = (n + d - \u2191i).choose d := by\n        rw [preHilbertPoly_eq_choose_sub_add _ _ (h_le i), Nat.sub_add_comm (h_le i)]\n      simp_rw [h]\n      rw [Finset.sum_coe_sort _ (fun x => (p.coeff \u2191x) * (_ + d - \u2191x).choose _),\n        PowerSeries.coeff_mul, Finset.Nat.sum_antidiagonal_eq_sum_range_succ_mk,\n        invOneSubPow_val_eq_mk_sub_one_add_choose_of_pos _ _ (zero_lt_succ d)]\n      simp only [coeff_coe, coeff_mk]\n      symm\n      refine Finset.sum_subset_zero_on_sdiff (fun s hs \u21a6 ?_) (fun x hx \u21a6 ?_) (fun x hx \u21a6 ?_)\n      \u00b7 rw [Finset.mem_range_succ_iff]\n        exact h_le \u27e8s, hs\u27e9\n      \u00b7 simp only [Finset.mem_sdiff, mem_support_iff, not_not] at hx\n        rw [hx.2, zero_mul]\n      \u00b7 rw [add_comm, Nat.add_sub_assoc (h_le \u27e8x, hx\u27e9), succ_eq_add_one, add_tsub_cancel_right]\n\n/--\nThe polynomial satisfying the key property of `Polynomial.hilbertPoly p d` is unique.\n-/\ntheorem existsUnique_hilbertPoly (p : F[X]) (d : \u2115) :\n    \u2203! h : F[X], \u2203 N : \u2115, \u2200 n > N,\n    PowerSeries.coeff F n (p * invOneSubPow F d) = h.eval (n : F) := by\n  use hilbertPoly p d; constructor\n  \u00b7 use p.natDegree\n    exact fun n => coeff_mul_invOneSubPow_eq_hilbertPoly_eval d\n  \u00b7 rintro h \u27e8N, hhN\u27e9\n    apply eq_of_infinite_eval_eq h (hilbertPoly p d)\n    apply ((Set.Ioi_infinite (max N p.natDegree)).image cast_injective.injOn).mono\n    rintro x \u27e8n, hn, rfl\u27e9\n    simp only [Set.mem_Ioi, sup_lt_iff, Set.mem_setOf_eq] at hn \u22a2\n    rw [\u2190 coeff_mul_invOneSubPow_eq_hilbertPoly_eval d hn.2, hhN n hn.1]\n\n@[deprecated (since := \"2024-12-17\")] alias exists_unique_hilbertPoly := existsUnique_hilbertPoly\n\n/--\nIf `h : F[X]` and there exists some `N : \u2115` such that for any number `n : \u2115` bigger than `N`\nwe have `PowerSeries.coeff F n (p * invOneSubPow F d) = h.eval (n : F)`, then `h` is exactly\n`Polynomial.hilbertPoly p d`.\n-/\ntheorem eq_hilbertPoly_of_forall_coeff_eq_eval\n    {p h : F[X]} {d : \u2115} (N : \u2115) (hhN : \u2200 n > N,\n    PowerSeries.coeff F n (p * invOneSubPow F d) = h.eval (n : F)) :\n    h = hilbertPoly p d :=\n  ExistsUnique.unique (existsUnique_hilbertPoly p d) \u27e8N, hhN\u27e9\n    \u27e8p.natDegree, fun _ x => coeff_mul_invOneSubPow_eq_hilbertPoly_eval d x\u27e9\n\nlemma hilbertPoly_mul_one_sub_succ (p : F[X]) (d : \u2115) :\n    hilbertPoly (p * (1 - X)) (d + 1) = hilbertPoly p d := by\n  apply eq_hilbertPoly_of_forall_coeff_eq_eval (p * (1 - X)).natDegree\n  intro n hn\n  have heq : 1 - PowerSeries.X = ((1 - X : F[X]) : F\u27e6X\u27e7) := by simp only [coe_sub, coe_one, coe_X]\n  rw [\u2190 one_sub_pow_mul_invOneSubPow_val_add_eq_invOneSubPow_val F d 1, pow_one, \u2190 mul_assoc, heq,\n    \u2190 coe_mul, coeff_mul_invOneSubPow_eq_hilbertPoly_eval (d + 1) hn]\n\nlemma hilbertPoly_mul_one_sub_pow_add (p : F[X]) (d e : \u2115) :\n    hilbertPoly (p * (1 - X) ^ e) (d + e) = hilbertPoly p d := by\n  induction e with\n  | zero => simp\n  | succ e he => rw [pow_add, pow_one, \u2190 mul_assoc, \u2190 add_assoc, hilbertPoly_mul_one_sub_succ, he]\n\nlemma hilbertPoly_eq_zero_of_le_rootMultiplicity_one\n    {p : F[X]} {d : \u2115} (hdp : d \u2264 p.rootMultiplicity 1) :\n    hilbertPoly p d = 0 := by\n  by_cases hp : p = 0\n  \u00b7 rw [hp, hilbertPoly_zero_left]\n  \u00b7 rcases exists_eq_pow_rootMultiplicity_mul_and_not_dvd p hp 1 with \u27e8q, hq1, hq2\u27e9\n    have heq : p = q * (- 1) ^ p.rootMultiplicity 1 * (1 - X) ^ p.rootMultiplicity 1 := by\n      simp only [mul_assoc, \u2190 mul_pow, neg_mul, one_mul, neg_sub]\n      exact hq1.trans (mul_comm _ _)\n    rw [heq, \u2190 zero_add d, \u2190 Nat.sub_add_cancel hdp, pow_add (1 - X), \u2190 mul_assoc,\n      hilbertPoly_mul_one_sub_pow_add, hilbertPoly]\n\n", "theoremStatement": "theorem natDegree_hilbertPoly_of_ne_zero_of_rootMultiplicity_lt\n    {p : F[X]} {d : \u2115} (hp : p \u2260 0) (hpd : p.rootMultiplicity 1 < d) :\n    (hilbertPoly p d).natDegree = d - p.rootMultiplicity 1 - 1 ", "theoremName": "Polynomial.natDegree_hilbertPoly_of_ne_zero_of_rootMultiplicity_lt", "fileCreated": {"commit": "561e050467d2caa2e4ea5d81ca62600bf268b747", "date": "2024-12-02"}, "theoremCreated": {"commit": "bd9aea4b2403dcb1ec3998335f71109212ada88e", "date": "2024-12-09"}, "file": "mathlib/Mathlib/RingTheory/Polynomial/HilbertPoly.lean", "module": "Mathlib.RingTheory.Polynomial.HilbertPoly", "jsonFile": "Mathlib.RingTheory.Polynomial.HilbertPoly.jsonl", "positionMetadata": {"lineInFile": 243, "tokenPositionInFile": 11357, "theoremPositionInFile": 17}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 5, "repositoryPremises": true, "numRepositoryPremises": 174, "numPremises": 232}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rcases exists_eq_pow_rootMultiplicity_mul_and_not_dvd p hp 1 with \u27e8q, hq1, hq2\u27e9\n  have heq : p = q * (- 1) ^ p.rootMultiplicity 1 * (1 - X) ^ p.rootMultiplicity 1 := by\n    simp only [mul_assoc, \u2190 mul_pow, neg_mul, one_mul, neg_sub]\n    exact hq1.trans (mul_comm _ _)\n  nth_rw 1 [heq, \u2190 Nat.sub_add_cancel (le_of_lt hpd), hilbertPoly_mul_one_sub_pow_add,\n    \u2190 Nat.sub_add_cancel (Nat.le_sub_of_add_le' <| add_one_le_of_lt hpd)]\n  delta hilbertPoly\n  apply natDegree_eq_of_le_of_coeff_ne_zero\n  \u00b7 apply natDegree_sum_le_of_forall_le _ _ <| fun _ _ => ?_\n    apply le_trans (natDegree_smul_le _ _)\n    rw [natDegree_preHilbertPoly]\n  \u00b7 have : (fun (x : \u2115) (a : F) => a) = fun x a => a * 1 ^ x := by simp only [one_pow, mul_one]\n    simp only [finset_sum_coeff, coeff_smul, smul_eq_mul, coeff_preHilbertPoly_self,\n      \u2190 Finset.sum_mul, \u2190 sum_def _ (fun _ a => a), this, \u2190 eval_eq_sum, eval_mul, eval_pow,\n      eval_neg, eval_one, _root_.mul_eq_zero, pow_eq_zero_iff', neg_eq_zero, one_ne_zero, ne_eq,\n      false_and, or_false, inv_eq_zero, cast_eq_zero, not_or]\n    exact \u27e8(not_iff_not.2 dvd_iff_isRoot).1 hq2, factorial_ne_zero _\u27e9", "proofType": "tactic", "proofLengthLines": 17, "proofLengthTokens": 1141}}
{"srcContext": "/-\nCopyright (c) 2024 Jo\u00ebl Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jo\u00ebl Riou\n-/\nimport Mathlib.Algebra.Homology.Embedding.Extend\nimport Mathlib.Algebra.Homology.Embedding.IsSupported\nimport Mathlib.Algebra.Homology.QuasiIso\n\n/-!\n# Homology of the extension of an homological complex\n\nGiven an embedding `e : c.Embedding c'` and `K : HomologicalComplex C c`, we shall\ncompute the homology of `K.extend e`. In degrees that are not in the image of `e.f`,\nthe homology is obviously zero. When `e.f j = j`, we construct an isomorphism\n`(K.extend e).homology j' \u2245 K.homology j`.\n\n-/\n\nopen CategoryTheory Limits Category\n\nnamespace HomologicalComplex\n\nvariable {\u03b9 \u03b9' : Type*} {c : ComplexShape \u03b9} {c' : ComplexShape \u03b9'}\n  {C : Type*} [Category C] [HasZeroMorphisms C]\n  [HasZeroObject C]\n\nvariable (K L M : HomologicalComplex C c) (\u03c6 : K \u27f6 L) (\u03c6' : L \u27f6 M) (e : c.Embedding c')\n\nnamespace extend\n\nsection HomologyData\n\nvariable {i j k : \u03b9} {i' j' k' : \u03b9'} (hj' : e.f j = j')\n  (hi : c.prev j = i) (hi' : c'.prev j' = i') (hk : c.next j = k) (hk' : c'.next j' = k')\n\ninclude hk hk' in\nlemma comp_d_eq_zero_iff \u2983W : C\u2984 (\u03c6 : W \u27f6 K.X j) :\n    \u03c6 \u226b K.d j k = 0 \u2194 \u03c6 \u226b (K.extendXIso e hj').inv \u226b (K.extend e).d j' k' = 0 := by\n  by_cases hjk : c.Rel j k\n  \u00b7 have hk' : e.f k = k' := by rw [\u2190 hk', \u2190 hj', c'.next_eq' (e.rel hjk)]\n    rw [K.extend_d_eq e hj' hk', Iso.inv_hom_id_assoc,\n      \u2190 cancel_mono (K.extendXIso e hk').inv, zero_comp, assoc]\n  \u00b7 simp only [K.shape _ _ hjk, comp_zero, true_iff]\n    rw [K.extend_d_from_eq_zero e j' k' j hj', comp_zero, comp_zero]\n    rw [hk]\n    exact hjk\n\ninclude hi hi' in\nlemma d_comp_eq_zero_iff \u2983W : C\u2984 (\u03c6 : K.X j \u27f6 W) :\n    K.d i j \u226b \u03c6 = 0 \u2194 (K.extend e).d i' j' \u226b (K.extendXIso e hj').hom \u226b \u03c6 = 0 := by\n  by_cases hij : c.Rel i j\n  \u00b7 have hi' : e.f i = i' := by rw [\u2190 hi', \u2190 hj', c'.prev_eq' (e.rel hij)]\n    rw [K.extend_d_eq e hi' hj', assoc, assoc, Iso.inv_hom_id_assoc,\n      \u2190 cancel_epi (K.extendXIso e hi').hom, comp_zero]\n  \u00b7 simp only [K.shape _ _ hij, zero_comp, true_iff]\n    rw [K.extend_d_to_eq_zero e i' j' j hj', zero_comp]\n    rw [hi]\n    exact hij\n\nnamespace leftHomologyData\n\nvariable (cone : KernelFork (K.d j k)) (hcone : IsLimit cone)\n\n/-- The kernel fork of `(K.extend e).d j' k'` that is deduced from a kernel\nfork of `K.d j k `. -/\n@[simp]\nnoncomputable def kernelFork : KernelFork ((K.extend e).d j' k') :=\n  KernelFork.of\u03b9 (cone.\u03b9 \u226b (extendXIso K e hj').inv)\n    (by rw [assoc, \u2190 comp_d_eq_zero_iff K e hj' hk hk' cone.\u03b9, cone.condition])\n\n/-- The limit kernel fork of `(K.extend e).d j' k'` that is deduced from a limit\nkernel fork of `K.d j k `. -/\nnoncomputable def isLimitKernelFork : IsLimit (kernelFork K e hj' hk hk' cone) :=\n  KernelFork.isLimitOfIsLimitOfIff hcone ((K.extend e).d j' k')\n    (extendXIso K e hj').symm (comp_d_eq_zero_iff K e hj' hk hk')\n\nvariable (cocone : CokernelCofork (hcone.lift (KernelFork.of\u03b9 (K.d i j) (K.d_comp_d i j k))))\n  (hcocone : IsColimit cocone)\n\ninclude hi hi' hcone in\n/-- Auxiliary lemma for `lift_d_comp_eq_zero_iff`. -/\nlemma lift_d_comp_eq_zero_iff' \u2983W : C\u2984 (f' : K.X i \u27f6 cone.pt)\n    (hf' : f' \u226b cone.\u03b9 = K.d i j)\n    (f'' : (K.extend e).X i' \u27f6 cone.pt)\n    (hf'' : f'' \u226b cone.\u03b9 \u226b (extendXIso K e hj').inv = (K.extend e).d i' j')\n    (\u03c6 : cone.pt \u27f6 W) :\n    f' \u226b \u03c6 = 0 \u2194 f'' \u226b \u03c6 = 0 := by\n  by_cases hij : c.Rel i j\n  \u00b7 have hi'' : e.f i = i' := by rw [\u2190 hi', \u2190 hj', c'.prev_eq' (e.rel hij)]\n    have : (K.extendXIso e hi'').hom \u226b f' = f'' := by\n      apply Fork.IsLimit.hom_ext hcone\n      rw [assoc, hf', \u2190 cancel_mono (extendXIso K e hj').inv, assoc, assoc, hf'',\n        K.extend_d_eq e hi'' hj']\n    rw [\u2190 cancel_epi (K.extendXIso e hi'').hom, comp_zero, \u2190 this, assoc]\n  \u00b7 have h\u2081 : f' = 0 := by\n      apply Fork.IsLimit.hom_ext hcone\n      simp only [zero_comp, hf', K.shape _ _ hij]\n    have h\u2082 : f'' = 0 := by\n      apply Fork.IsLimit.hom_ext hcone\n      dsimp\n      rw [\u2190 cancel_mono (extendXIso K e hj').inv, assoc, hf'', zero_comp, zero_comp,\n        K.extend_d_to_eq_zero e i' j' j hj']\n      rw [hi]\n      exact hij\n    simp [h\u2081, h\u2082]\n\ninclude hi hi' in\nlemma lift_d_comp_eq_zero_iff \u2983W : C\u2984 (\u03c6 : cone.pt \u27f6 W) :\n    hcone.lift (KernelFork.of\u03b9 (K.d i j) (K.d_comp_d i j k)) \u226b \u03c6 = 0 \u2194\n      ((isLimitKernelFork K e hj' hk hk' cone hcone).lift\n      (KernelFork.of\u03b9 ((K.extend e).d i' j') (d_comp_d _ _ _ _))) \u226b \u03c6 = 0 :=\n  lift_d_comp_eq_zero_iff' K e hj' hi hi' cone hcone _ (hcone.fac _ _) _\n    (IsLimit.fac _ _ WalkingParallelPair.zero) _\n\n/-- Auxiliary definition for `extend.leftHomologyData`. -/\nnoncomputable def cokernelCofork :\n    CokernelCofork ((isLimitKernelFork K e hj' hk hk' cone hcone).lift\n      (KernelFork.of\u03b9 ((K.extend e).d i' j') (d_comp_d _ _ _ _))) :=\n  CokernelCofork.of\u03c0 cocone.\u03c0 (by\n    rw [\u2190 lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' cone hcone]\n    exact cocone.condition)\n\n/-- Auxiliary definition for `extend.leftHomologyData`. -/\nnoncomputable def isColimitCokernelCofork :\n    IsColimit (cokernelCofork K e hj' hi hi' hk hk' cone hcone cocone) :=\n  CokernelCofork.isColimitOfIsColimitOfIff' hcocone _\n    (lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' cone hcone)\n\nend leftHomologyData\n\nopen leftHomologyData in\n/-- The left homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a left homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def leftHomologyData (h : (K.sc' i j k).LeftHomologyData) :\n    ((K.extend e).sc' i' j' k').LeftHomologyData where\n  K := h.K\n  H := h.H\n  i := h.i \u226b (extendXIso K e hj').inv\n  \u03c0 := h.\u03c0\n  wi := by\n    dsimp\n    rw [assoc, \u2190 comp_d_eq_zero_iff K e hj' hk hk']\n    exact h.wi\n  hi := isLimitKernelFork K e hj' hk hk' _ h.hi\n  w\u03c0 := by\n    dsimp\n    rw [\u2190 lift_d_comp_eq_zero_iff K e hj' hi hi' hk hk' _ h.hi]\n    exact h.w\u03c0\n  h\u03c0 := isColimitCokernelCofork K e hj' hi hi' hk hk' _ h.hi _ h.h\u03c0\n\nnamespace rightHomologyData\n\nvariable (cocone : CokernelCofork (K.d i j)) (hcocone : IsColimit cocone)\n\n/-- The cokernel cofork of `(K.extend e).d i' j'` that is deduced from a cokernel\ncofork of `K.d i j`. -/\n@[simp]\nnoncomputable def cokernelCofork : CokernelCofork ((K.extend e).d i' j') :=\n  CokernelCofork.of\u03c0 ((extendXIso K e hj').hom \u226b cocone.\u03c0) (by\n    rw [\u2190 d_comp_eq_zero_iff K e hj' hi hi' cocone.\u03c0, cocone.condition])\n\n/-- The colimit cokernel cofork of `(K.extend e).d i' j'` that is deduced from a\ncolimit cokernel cofork of `K.d i j`. -/\nnoncomputable def isColimitCokernelCofork : IsColimit (cokernelCofork K e hj' hi hi' cocone) :=\n  CokernelCofork.isColimitOfIsColimitOfIff hcocone ((K.extend e).d i' j')\n    (extendXIso K e hj') (d_comp_eq_zero_iff K e hj' hi hi')\n\nvariable (cone : KernelFork (hcocone.desc (CokernelCofork.of\u03c0 (K.d j k) (K.d_comp_d i j k))))\n  (hcone : IsLimit cone)\n\ninclude hk hk' hcocone in\nlemma d_comp_desc_eq_zero_iff' \u2983W : C\u2984 (f' : cocone.pt \u27f6 K.X k)\n    (hf' : cocone.\u03c0 \u226b f' = K.d j k)\n    (f'' : cocone.pt \u27f6 (K.extend e).X k')\n    (hf'' : (extendXIso K e hj').hom \u226b cocone.\u03c0 \u226b f'' = (K.extend e).d j' k')\n    (\u03c6 : W \u27f6 cocone.pt) :\n    \u03c6 \u226b f' = 0 \u2194 \u03c6 \u226b f'' = 0 := by\n  by_cases hjk : c.Rel j k\n  \u00b7 have hk'' : e.f k = k' := by rw [\u2190 hk', \u2190 hj', c'.next_eq' (e.rel hjk)]\n    have : f' \u226b (K.extendXIso e hk'').inv = f'' := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      rw [reassoc_of% hf', \u2190 cancel_epi (extendXIso K e hj').hom, hf'',\n        K.extend_d_eq e hj' hk'']\n    rw [\u2190 cancel_mono (K.extendXIso e hk'').inv, zero_comp, assoc, this]\n  \u00b7 have h\u2081 : f' = 0 := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      simp only [hf', comp_zero, K.shape _ _ hjk]\n    have h\u2082 : f'' = 0 := by\n      apply Cofork.IsColimit.hom_ext hcocone\n      rw [\u2190 cancel_epi (extendXIso K e hj').hom, hf'', comp_zero, comp_zero,\n        K.extend_d_from_eq_zero e j' k' j hj']\n      rw [hk]\n      exact hjk\n    simp [h\u2081, h\u2082]\n\ninclude hk hk' in\nlemma d_comp_desc_eq_zero_iff \u2983W : C\u2984 (\u03c6 : W \u27f6 cocone.pt) :\n    \u03c6 \u226b hcocone.desc (CokernelCofork.of\u03c0 (K.d j k) (K.d_comp_d i j k)) = 0 \u2194\n      \u03c6 \u226b ((isColimitCokernelCofork K e hj' hi hi' cocone hcocone).desc\n      (CokernelCofork.of\u03c0 ((K.extend e).d j' k') (d_comp_d _ _ _ _))) = 0 :=\n  d_comp_desc_eq_zero_iff' K e hj' hk hk' cocone hcocone _ (hcocone.fac _ _) _ (by\n    simpa using (isColimitCokernelCofork K e hj' hi hi' cocone hcocone).fac _\n      WalkingParallelPair.one) _\n\n/-- Auxiliary definition for `extend.rightHomologyData`. -/\nnoncomputable def kernelFork :\n    KernelFork ((isColimitCokernelCofork K e hj' hi hi' cocone hcocone).desc\n      (CokernelCofork.of\u03c0 ((K.extend e).d j' k') (d_comp_d _ _ _ _))) :=\n  KernelFork.of\u03b9 cone.\u03b9 (by\n    rw [\u2190 d_comp_desc_eq_zero_iff K e hj' hi hi' hk hk' cocone hcocone]\n    exact cone.condition)\n\n/-- Auxiliary definition for `extend.rightHomologyData`. -/\nnoncomputable def isLimitKernelFork :\n    IsLimit (kernelFork K e hj' hi hi' hk hk' cocone hcocone cone) :=\n  KernelFork.isLimitOfIsLimitOfIff' hcone _\n    (d_comp_desc_eq_zero_iff K e hj' hi hi' hk hk' cocone hcocone)\n\nend rightHomologyData\n\nopen rightHomologyData in\n/-- The right homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a right homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def rightHomologyData (h : (K.sc' i j k).RightHomologyData) :\n    ((K.extend e).sc' i' j' k').RightHomologyData where\n  Q := h.Q\n  H := h.H\n  p := (extendXIso K e hj').hom \u226b h.p\n  \u03b9 := h.\u03b9\n  wp := by\n    dsimp\n    rw [\u2190 d_comp_eq_zero_iff K e hj' hi hi']\n    exact h.wp\n  hp := isColimitCokernelCofork K e hj' hi hi' _ h.hp\n  w\u03b9 := by\n    dsimp\n    rw [\u2190 d_comp_desc_eq_zero_iff K e hj' hi hi' hk hk' _ h.hp]\n    exact h.w\u03b9\n  h\u03b9 := isLimitKernelFork K e hj' hi hi' hk hk' _ h.hp _ h.h\u03b9\n\n/-- Computation of the `g'` field of `extend.rightHomologyData`. -/\nlemma rightHomologyData_g' (h : (K.sc' i j k).RightHomologyData) (hk'' : e.f k = k') :\n    (rightHomologyData K e hj' hi hi' hk hk' h).g' = h.g' \u226b (K.extendXIso e hk'').inv := by\n  rw [\u2190 cancel_epi h.p, \u2190 cancel_epi (extendXIso K e hj').hom]\n  have := (rightHomologyData K e hj' hi hi' hk hk' h).p_g'\n  dsimp at this\n  rw [assoc] at this\n  rw [this, K.extend_d_eq e hj' hk'', h.p_g'_assoc, shortComplexFunctor'_obj_g]\n\n/-- The homology data of `(K.extend e).sc' i' j' k'` that is deduced\nfrom a homology data of `K.sc' i j k`. -/\n@[simps]\nnoncomputable def homologyData (h : (K.sc' i j k).HomologyData) :\n    ((K.extend e).sc' i' j' k').HomologyData where\n  left := leftHomologyData K e hj' hi hi' hk hk' h.left\n  right := rightHomologyData K e hj' hi hi' hk hk' h.right\n  iso := h.iso\n\n/-- The homology data of `(K.extend e).sc j'` that is deduced\nfrom a homology data of `K.sc' i j k`. -/\n@[simps!]\nnoncomputable def homologyData' (h : (K.sc' i j k).HomologyData) :\n    ((K.extend e).sc j').HomologyData :=\n  homologyData K e hj' hi rfl hk rfl h\n\nend HomologyData\n\nlemma hasHomology {j : \u03b9} {j' : \u03b9'} (hj' : e.f j = j') [K.HasHomology j] :\n    (K.extend e).HasHomology j' :=\n  ShortComplex.HasHomology.mk'\n    (homologyData' K e hj' rfl rfl ((K.sc j).homologyData))\n\ninstance (j : \u03b9) [K.HasHomology j] : (K.extend e).HasHomology (e.f j) :=\n  hasHomology K e rfl\n\ninstance [\u2200 j, K.HasHomology j] (j' : \u03b9') : (K.extend e).HasHomology j' := by\n  by_cases h : \u2203 j, e.f j = j'\n  \u00b7 obtain \u27e8j, rfl\u27e9 := h\n    infer_instance\n  \u00b7 have hj := isZero_extend_X K e j' (by tauto)\n    exact ShortComplex.HasHomology.mk'\n      (ShortComplex.HomologyData.ofZeros _ (hj.eq_of_tgt _ _) (hj.eq_of_src _ _))\n\nend extend\n\nlemma extend_exactAt (j' : \u03b9') (hj' : \u2200 j, e.f j \u2260 j') :\n    (K.extend e).ExactAt j' :=\n  exactAt_of_isSupported _ e j' hj'\n\nsection\n\nvariable {j : \u03b9} {j' : \u03b9'} (hj' : e.f j = j') [K.HasHomology j] [L.HasHomology j]\n  [(K.extend e).HasHomology j'] [(L.extend e).HasHomology j']\n\n/-- The isomorphism `(K.extend e).cycles j' \u2245 K.cycles j` when `e.f j = j'`. -/\nnoncomputable def extendCyclesIso :\n    (K.extend e).cycles j' \u2245 K.cycles j :=\n  (extend.homologyData' K e hj' rfl rfl (K.sc j).homologyData).left.cyclesIso \u226a\u226b\n    (K.sc j).homologyData.left.cyclesIso.symm\n\n/-- The isomorphism `(K.extend e).opcycles j' \u2245 K.opcycles j` when `e.f j = j'`. -/\nnoncomputable def extendOpcyclesIso :\n    (K.extend e).opcycles j' \u2245 K.opcycles j :=\n  (extend.homologyData' K e hj' rfl rfl (K.sc j).homologyData).right.opcyclesIso \u226a\u226b\n    (K.sc j).homologyData.right.opcyclesIso.symm\n\n/-- The isomorphism `(K.extend e).homology j' \u2245 K.homology j` when `e.f j = j'`. -/\nnoncomputable def extendHomologyIso :\n    (K.extend e).homology j' \u2245 K.homology j :=\n  (extend.homologyData' K e hj' rfl rfl (K.sc j).homologyData).left.homologyIso \u226a\u226b\n    (K.sc j).homologyData.left.homologyIso.symm\n\ninclude hj' in\nlemma extend_exactAt_iff :\n    (K.extend e).ExactAt j' \u2194 K.ExactAt j := by\n  simp only [HomologicalComplex.exactAt_iff_isZero_homology]\n  exact (K.extendHomologyIso e hj').isZero_iff\n\n@[reassoc (attr := simp)]\nlemma extendCyclesIso_hom_iCycles :\n    (K.extendCyclesIso e hj').hom \u226b K.iCycles j =\n      (K.extend e).iCycles j' \u226b (K.extendXIso e hj').hom := by\n  rw [\u2190 cancel_epi (K.extendCyclesIso e hj').inv, Iso.inv_hom_id_assoc]\n  dsimp [extendCyclesIso, iCycles]\n  rw [assoc, ShortComplex.LeftHomologyData.cyclesIso_inv_comp_iCycles_assoc]\n  dsimp\n  rw [assoc, Iso.inv_hom_id, comp_id,\n    ShortComplex.LeftHomologyData.cyclesIso_hom_comp_i]\n\n@[reassoc (attr := simp)]\nlemma extendCyclesIso_inv_iCycles :\n    (K.extendCyclesIso e hj').inv \u226b (K.extend e).iCycles j' =\n      K.iCycles j \u226b (K.extendXIso e hj').inv := by\n  simp only [\u2190 cancel_epi (K.extendCyclesIso e hj').hom, Iso.hom_inv_id_assoc,\n    extendCyclesIso_hom_iCycles_assoc, Iso.hom_inv_id, comp_id]\n\n", "theoremStatement": "@[reassoc (attr := simp)]\nlemma homology\u03c0_extendHomologyIso_hom :\n    (K.extend e).homology\u03c0 j' \u226b (K.extendHomologyIso e hj').hom =\n      (K.extendCyclesIso e hj').hom \u226b K.homology\u03c0 j ", "theoremName": "HomologicalComplex.homology\u03c0_extendHomologyIso_hom", "fileCreated": {"commit": "9bdc1af76cf75d960f42c29f1c09917785066c8b", "date": "2024-11-30"}, "theoremCreated": {"commit": "b07a551a1451cbf8615f4e2a6c47052affadbae4", "date": "2025-01-17"}, "file": "mathlib/Mathlib/Algebra/Homology/Embedding/ExtendHomology.lean", "module": "Mathlib.Algebra.Homology.Embedding.ExtendHomology", "jsonFile": "Mathlib.Algebra.Homology.Embedding.ExtendHomology.jsonl", "positionMetadata": {"lineInFile": 340, "tokenPositionInFile": 13576, "theoremPositionInFile": 24}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 48, "numPremises": 64}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  dsimp [extendHomologyIso, homology\u03c0]\n  rw [ShortComplex.LeftHomologyData.homology\u03c0_comp_homologyIso_hom_assoc,\n    \u2190 cancel_mono (K.sc j).homologyData.left.homologyIso.hom,\n    assoc, assoc, assoc, Iso.inv_hom_id, comp_id,\n    ShortComplex.LeftHomologyData.homology\u03c0_comp_homologyIso_hom]\n  dsimp [extendCyclesIso]\n  simp only [assoc, Iso.inv_hom_id_assoc]", "proofType": "tactic", "proofLengthLines": 7, "proofLengthTokens": 364}}
{"srcContext": "/-\nCopyright (c) 2020 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kevin Buzzard, Johan Commelin, Patrick Massot\n-/\nimport Mathlib.Algebra.Order.Hom.Monoid\nimport Mathlib.Algebra.Order.Ring.Basic\nimport Mathlib.RingTheory.Ideal.Maps\nimport Mathlib.Tactic.TFAE\n\n/-!\n\n# The basics of valuation theory.\n\nThe basic theory of valuations (non-archimedean norms) on a commutative ring,\nfollowing T. Wedhorn's unpublished notes \u201cAdic Spaces\u201d ([wedhorn_adic]).\n\nThe definition of a valuation we use here is Definition 1.22 of [wedhorn_adic].\nA valuation on a ring `R` is a monoid homomorphism `v` to a linearly ordered\ncommutative monoid with zero, that in addition satisfies the following two axioms:\n * `v 0 = 0`\n * `\u2200 x y, v (x + y) \u2264 max (v x) (v y)`\n\n`Valuation R \u0393\u2080`is the type of valuations `R \u2192 \u0393\u2080`, with a coercion to the underlying\nfunction. If `v` is a valuation from `R` to `\u0393\u2080` then the induced group\nhomomorphism `Units(R) \u2192 \u0393\u2080` is called `unit_map v`.\n\nThe equivalence \"relation\" `IsEquiv v\u2081 v\u2082 : Prop` defined in 1.27 of [wedhorn_adic] is not strictly\nspeaking a relation, because `v\u2081 : Valuation R \u0393\u2081` and `v\u2082 : Valuation R \u0393\u2082` might\nnot have the same type. This corresponds in ZFC to the set-theoretic difficulty\nthat the class of all valuations (as `\u0393\u2080` varies) on a ring `R` is not a set.\nThe \"relation\" is however reflexive, symmetric and transitive in the obvious\nsense. Note that we use 1.27(iii) of [wedhorn_adic] as the definition of equivalence.\n\n## Main definitions\n\n* `Valuation R \u0393\u2080`, the type of valuations on `R` with values in `\u0393\u2080`\n* `Valuation.IsEquiv`, the heterogeneous equivalence relation on valuations\n* `Valuation.supp`, the support of a valuation\n\n* `AddValuation R \u0393\u2080`, the type of additive valuations on `R` with values in a\n  linearly ordered additive commutative group with a top element, `\u0393\u2080`.\n\n## Implementation Details\n\n`AddValuation R \u0393\u2080` is implemented as `Valuation R (Multiplicative \u0393\u2080)\u1d52\u1d48`.\n\n## Notation\n\nIn the `DiscreteValuation` locale:\n\n * `\u2115\u2098\u2080` is a shorthand for `WithZero (Multiplicative \u2115)`\n * `\u2124\u2098\u2080` is a shorthand for `WithZero (Multiplicative \u2124)`\n\n## TODO\n\nIf ever someone extends `Valuation`, we should fully comply to the `DFunLike` by migrating the\nboilerplate lemmas to `ValuationClass`.\n-/\n\nopen Function Ideal\n\nnoncomputable section\n\nvariable {K F R : Type*} [DivisionRing K]\n\nsection\n\nvariable (F R) (\u0393\u2080 : Type*) [LinearOrderedCommMonoidWithZero \u0393\u2080] [Ring R]\n\n/-- The type of `\u0393\u2080`-valued valuations on `R`.\n\nWhen you extend this structure, make sure to extend `ValuationClass`. -/\nstructure Valuation extends R \u2192*\u2080 \u0393\u2080 where\n  /-- The valuation of a a sum is less that the sum of the valuations -/\n  map_add_le_max' : \u2200 x y, toFun (x + y) \u2264 max (toFun x) (toFun y)\n\n/-- `ValuationClass F \u03b1 \u03b2` states that `F` is a type of valuations.\n\nYou should also extend this typeclass when you extend `Valuation`. -/\nclass ValuationClass (F) (R \u0393\u2080 : outParam Type*) [LinearOrderedCommMonoidWithZero \u0393\u2080] [Ring R]\n  [FunLike F R \u0393\u2080]\n  extends MonoidWithZeroHomClass F R \u0393\u2080 : Prop where\n  /-- The valuation of a a sum is less that the sum of the valuations -/\n  map_add_le_max (f : F) (x y : R) : f (x + y) \u2264 max (f x) (f y)\n\nexport ValuationClass (map_add_le_max)\n\ninstance [FunLike F R \u0393\u2080] [ValuationClass F R \u0393\u2080] : CoeTC F (Valuation R \u0393\u2080) :=\n  \u27e8fun f =>\n    { toFun := f\n      map_one' := map_one f\n      map_zero' := map_zero f\n      map_mul' := map_mul f\n      map_add_le_max' := map_add_le_max f }\u27e9\n\nend\n\nnamespace Valuation\n\nvariable {\u0393\u2080 : Type*}\nvariable {\u0393'\u2080 : Type*}\nvariable {\u0393''\u2080 : Type*} [LinearOrderedCommMonoidWithZero \u0393''\u2080]\n\nsection Basic\n\nvariable [Ring R]\n\nsection Monoid\n\nvariable [LinearOrderedCommMonoidWithZero \u0393\u2080] [LinearOrderedCommMonoidWithZero \u0393'\u2080]\n\ninstance : FunLike (Valuation R \u0393\u2080) R \u0393\u2080 where\n  coe f := f.toFun\n  coe_injective' f g h := by\n    obtain \u27e8\u27e8\u27e8_,_\u27e9, _\u27e9, _\u27e9 := f\n    congr\n\ninstance : ValuationClass (Valuation R \u0393\u2080) R \u0393\u2080 where\n  map_mul f := f.map_mul'\n  map_one f := f.map_one'\n  map_zero f := f.map_zero'\n  map_add_le_max f := f.map_add_le_max'\n\n@[simp]\ntheorem coe_mk (f : R \u2192*\u2080 \u0393\u2080) (h) : \u21d1(Valuation.mk f h) = f := rfl\n\ntheorem toFun_eq_coe (v : Valuation R \u0393\u2080) : v.toFun = v := rfl\n\n@[simp]\ntheorem toMonoidWithZeroHom_coe_eq_coe (v : Valuation R \u0393\u2080) :\n    (v.toMonoidWithZeroHom : R \u2192 \u0393\u2080) = v := rfl\n\n@[ext]\ntheorem ext {v\u2081 v\u2082 : Valuation R \u0393\u2080} (h : \u2200 r, v\u2081 r = v\u2082 r) : v\u2081 = v\u2082 :=\n  DFunLike.ext _ _ h\n\nvariable (v : Valuation R \u0393\u2080)\n\n@[simp, norm_cast]\ntheorem coe_coe : \u21d1(v : R \u2192*\u2080 \u0393\u2080) = v := rfl\n\ntheorem map_zero : v 0 = 0 :=\n  v.map_zero'\n\ntheorem map_one : v 1 = 1 :=\n  v.map_one'\n\ntheorem map_mul : \u2200 x y, v (x * y) = v x * v y :=\n  v.map_mul'\n\n-- Porting note: LHS side simplified so created map_add'\ntheorem map_add : \u2200 x y, v (x + y) \u2264 max (v x) (v y) :=\n  v.map_add_le_max'\n\n@[simp]\ntheorem map_add' : \u2200 x y, v (x + y) \u2264 v x \u2228 v (x + y) \u2264 v y := by\n  intro x y\n  rw [\u2190 le_max_iff, \u2190 ge_iff_le]\n  apply map_add\n\ntheorem map_add_le {x y g} (hx : v x \u2264 g) (hy : v y \u2264 g) : v (x + y) \u2264 g :=\n  le_trans (v.map_add x y) <| max_le hx hy\n\ntheorem map_add_lt {x y g} (hx : v x < g) (hy : v y < g) : v (x + y) < g :=\n  lt_of_le_of_lt (v.map_add x y) <| max_lt hx hy\n\ntheorem map_sum_le {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hf : \u2200 i \u2208 s, v (f i) \u2264 g) :\n    v (\u2211 i \u2208 s, f i) \u2264 g := by\n  classical\n  refine\n    Finset.induction_on s (fun _ => v.map_zero \u25b8 zero_le')\n      (fun a s has ih hf => ?_) hf\n  rw [Finset.forall_mem_insert] at hf; rw [Finset.sum_insert has]\n  exact v.map_add_le hf.1 (ih hf.2)\n\ntheorem map_sum_lt {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hg : g \u2260 0)\n    (hf : \u2200 i \u2208 s, v (f i) < g) : v (\u2211 i \u2208 s, f i) < g := by\n  classical\n  refine\n    Finset.induction_on s (fun _ => v.map_zero \u25b8 (zero_lt_iff.2 hg))\n      (fun a s has ih hf => ?_) hf\n  rw [Finset.forall_mem_insert] at hf; rw [Finset.sum_insert has]\n  exact v.map_add_lt hf.1 (ih hf.2)\n\ntheorem map_sum_lt' {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hg : 0 < g)\n    (hf : \u2200 i \u2208 s, v (f i) < g) : v (\u2211 i \u2208 s, f i) < g :=\n  v.map_sum_lt (ne_of_gt hg) hf\n\ntheorem map_pow : \u2200 (x) (n : \u2115), v (x ^ n) = v x ^ n :=\n  v.toMonoidWithZeroHom.toMonoidHom.map_pow\n\n-- The following definition is not an instance, because we have more than one `v` on a given `R`.\n-- In addition, type class inference would not be able to infer `v`.\n/-- A valuation gives a preorder on the underlying ring. -/\ndef toPreorder : Preorder R :=\n  Preorder.lift v\n\n/-- If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. -/\ntheorem zero_iff [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) {x : K} : v x = 0 \u2194 x = 0 :=\n  map_eq_zero v\n\ntheorem ne_zero_iff [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) {x : K} : v x \u2260 0 \u2194 x \u2260 0 :=\n  map_ne_zero v\n\nlemma pos_iff [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) {x : K} : 0 < v x \u2194 x \u2260 0 := by\n  rw [zero_lt_iff, ne_zero_iff]\n\ntheorem unit_map_eq (u : R\u02e3) : (Units.map (v : R \u2192* \u0393\u2080) u : \u0393\u2080) = v u :=\n  rfl\n\ntheorem ne_zero_of_unit [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) (x : K\u02e3) : v x \u2260 (0 : \u0393\u2080) := by\n  simp only [ne_eq, Valuation.zero_iff, Units.ne_zero x, not_false_iff]\n\ntheorem ne_zero_of_isUnit [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) (x : K) (hx : IsUnit x) :\n    v x \u2260 (0 : \u0393\u2080) := by\n  simpa [hx.choose_spec] using ne_zero_of_unit v hx.choose\n\n/-- A ring homomorphism `S \u2192 R` induces a map `Valuation R \u0393\u2080 \u2192 Valuation S \u0393\u2080`. -/\ndef comap {S : Type*} [Ring S] (f : S \u2192+* R) (v : Valuation R \u0393\u2080) : Valuation S \u0393\u2080 :=\n  { v.toMonoidWithZeroHom.comp f.toMonoidWithZeroHom with\n    toFun := v \u2218 f\n    map_add_le_max' := fun x y => by simp only [comp_apply, map_add, f.map_add] }\n\n@[simp]\ntheorem comap_apply {S : Type*} [Ring S] (f : S \u2192+* R) (v : Valuation R \u0393\u2080) (s : S) :\n    v.comap f s = v (f s) := rfl\n\n@[simp]\ntheorem comap_id : v.comap (RingHom.id R) = v :=\n  ext fun _r => rfl\n\ntheorem comap_comp {S\u2081 : Type*} {S\u2082 : Type*} [Ring S\u2081] [Ring S\u2082] (f : S\u2081 \u2192+* S\u2082) (g : S\u2082 \u2192+* R) :\n    v.comap (g.comp f) = (v.comap g).comap f :=\n  ext fun _r => rfl\n\n/-- A `\u2264`-preserving group homomorphism `\u0393\u2080 \u2192 \u0393'\u2080` induces a map `Valuation R \u0393\u2080 \u2192 Valuation R \u0393'\u2080`.\n-/\ndef map (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080) (hf : Monotone f) (v : Valuation R \u0393\u2080) : Valuation R \u0393'\u2080 :=\n  { MonoidWithZeroHom.comp f v.toMonoidWithZeroHom with\n    toFun := f \u2218 v\n    map_add_le_max' := fun r s =>\n      calc\n        f (v (r + s)) \u2264 f (max (v r) (v s)) := hf (v.map_add r s)\n        _ = max (f (v r)) (f (v s)) := hf.map_max\n         }\n\n@[simp]\nlemma map_apply (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080) (hf : Monotone f) (v : Valuation R \u0393\u2080) (r : R) :\n    v.map f hf r = f (v r) := rfl\n\n/-- Two valuations on `R` are defined to be equivalent if they induce the same preorder on `R`. -/\ndef IsEquiv (v\u2081 : Valuation R \u0393\u2080) (v\u2082 : Valuation R \u0393'\u2080) : Prop :=\n  \u2200 r s, v\u2081 r \u2264 v\u2081 s \u2194 v\u2082 r \u2264 v\u2082 s\n\n@[simp]\ntheorem map_neg (x : R) : v (-x) = v x :=\n  v.toMonoidWithZeroHom.toMonoidHom.map_neg x\n\ntheorem map_sub_swap (x y : R) : v (x - y) = v (y - x) :=\n  v.toMonoidWithZeroHom.toMonoidHom.map_sub_swap x y\n\ntheorem map_sub (x y : R) : v (x - y) \u2264 max (v x) (v y) :=\n  calc\n    v (x - y) = v (x + -y) := by rw [sub_eq_add_neg]\n    _ \u2264 max (v x) (v <| -y) := v.map_add _ _\n    _ = max (v x) (v y) := by rw [map_neg]\n\ntheorem map_sub_le {x y g} (hx : v x \u2264 g) (hy : v y \u2264 g) : v (x - y) \u2264 g := by\n  rw [sub_eq_add_neg]\n  exact v.map_add_le hx (le_trans (le_of_eq (v.map_neg y)) hy)\n\nvariable {x y : R}\n\ntheorem map_add_of_distinct_val (h : v x \u2260 v y) : v (x + y) = max (v x) (v y) := by\n  suffices \u00acv (x + y) < max (v x) (v y) from\n    or_iff_not_imp_right.1 (le_iff_eq_or_lt.1 (v.map_add x y)) this\n  intro h'\n  wlog vyx : v y < v x generalizing x y\n  \u00b7 refine this h.symm ?_ (h.lt_or_lt.resolve_right vyx)\n    rwa [add_comm, max_comm]\n  rw [max_eq_left_of_lt vyx] at h'\n  apply lt_irrefl (v x)\n  calc\n    v x = v (x + y - y) := by simp\n    _ \u2264 max (v <| x + y) (v y) := map_sub _ _ _\n    _ < v x := max_lt h' vyx\n\ntheorem map_add_eq_of_lt_right (h : v x < v y) : v (x + y) = v y :=\n  (v.map_add_of_distinct_val h.ne).trans (max_eq_right_iff.mpr h.le)\n\ntheorem map_add_eq_of_lt_left (h : v y < v x) : v (x + y) = v x := by\n  rw [add_comm]; exact map_add_eq_of_lt_right _ h\n\ntheorem map_sub_eq_of_lt_right (h : v x < v y) : v (x - y) = v y := by\n  rw [sub_eq_add_neg, map_add_eq_of_lt_right, map_neg]\n  rwa [map_neg]\n\nopen scoped Classical in\ntheorem map_sum_eq_of_lt {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {j : \u03b9}\n    (hj : j \u2208 s) (h0 : v (f j) \u2260 0) (hf : \u2200 i \u2208 s \\ {j}, v (f i) < v (f j)) :\n    v (\u2211 i \u2208 s, f i) = v (f j) := by\n  rw [Finset.sum_eq_add_sum_diff_singleton hj]\n  exact map_add_eq_of_lt_left _ (map_sum_lt _ h0 hf)\n\ntheorem map_sub_eq_of_lt_left (h : v y < v x) : v (x - y) = v x := by\n  rw [sub_eq_add_neg, map_add_eq_of_lt_left]\n  rwa [map_neg]\n\ntheorem map_eq_of_sub_lt (h : v (y - x) < v x) : v y = v x := by\n  have := Valuation.map_add_of_distinct_val v (ne_of_gt h).symm\n  rw [max_eq_right (le_of_lt h)] at this\n  simpa using this\n\ntheorem map_one_add_of_lt (h : v x < 1) : v (1 + x) = 1 := by\n  rw [\u2190 v.map_one] at h\n  simpa only [v.map_one] using v.map_add_eq_of_lt_left h\n\ntheorem map_one_sub_of_lt (h : v x < 1) : v (1 - x) = 1 := by\n  rw [\u2190 v.map_one, \u2190 v.map_neg] at h\n  rw [sub_eq_add_neg 1 x]\n  simpa only [v.map_one, v.map_neg] using v.map_add_eq_of_lt_left h\n\n/-- An ordered monoid isomorphism `\u0393\u2080 \u2243 \u0393'\u2080` induces an equivalence\n`Valuation R \u0393\u2080 \u2243 Valuation R \u0393'\u2080`. -/\ndef congr (f : \u0393\u2080 \u2243*o \u0393'\u2080) : Valuation R \u0393\u2080 \u2243 Valuation R \u0393'\u2080 where\n  toFun := map f f.toOrderIso.monotone\n  invFun := map f.symm f.toOrderIso.symm.monotone\n  left_inv \u03bd := by ext; simp\n  right_inv \u03bd := by ext; simp\n\nend Monoid\n\nsection Group\n\nvariable [LinearOrderedCommGroupWithZero \u0393\u2080] (v : Valuation R \u0393\u2080) {x y : R}\n\ntheorem map_inv {R : Type*} [DivisionRing R] (v : Valuation R \u0393\u2080) : \u2200 x, v x\u207b\u00b9 = (v x)\u207b\u00b9 :=\n  map_inv\u2080 _\n\ntheorem map_div {R : Type*} [DivisionRing R] (v : Valuation R \u0393\u2080) : \u2200 x y, v (x / y) = v x / v y :=\n  map_div\u2080 _\n\ntheorem one_lt_val_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : 1 < v x \u2194 v x\u207b\u00b9 < 1 := by\n  simp [inv_lt_one\u2080 (v.pos_iff.2 h)]\n\ntheorem one_le_val_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : 1 \u2264 v x \u2194 v x\u207b\u00b9 \u2264 1 := by\n  simp [inv_le_one\u2080 (v.pos_iff.2 h)]\n\ntheorem val_lt_one_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : v x < 1 \u2194 1 < v x\u207b\u00b9 := by\n  simp [one_lt_inv\u2080 (v.pos_iff.2 h)]\n\ntheorem val_le_one_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : v x \u2264 1 \u2194 1 \u2264 v x\u207b\u00b9 := by\n  simp [one_le_inv\u2080 (v.pos_iff.2 h)]\n\ntheorem val_eq_one_iff (v : Valuation K \u0393\u2080) {x : K} : v x = 1 \u2194 v x\u207b\u00b9 = 1 := by\n  by_cases h : x = 0\n  \u00b7 simp only [map_inv\u2080, inv_eq_one]\n  \u00b7 simpa only [le_antisymm_iff, And.comm] using and_congr (one_le_val_iff v h) (val_le_one_iff v h)\n\ntheorem val_le_one_or_val_inv_lt_one (v : Valuation K \u0393\u2080) (x : K) : v x \u2264 1 \u2228 v x\u207b\u00b9 < 1 := by\n  by_cases h : x = 0\n  \u00b7 simp only [h, _root_.map_zero, zero_le', inv_zero, zero_lt_one, or_self]\n  \u00b7 simp only [\u2190 one_lt_val_iff v h, le_or_lt]\n\n/--\nThis theorem is a weaker version of `Valuation.val_le_one_or_val_inv_lt_one`, but more symmetric\nin `x` and `x\u207b\u00b9`.\n-/\ntheorem val_le_one_or_val_inv_le_one (v : Valuation K \u0393\u2080) (x : K) : v x \u2264 1 \u2228 v x\u207b\u00b9 \u2264 1 := by\n  by_cases h : x = 0\n  \u00b7 simp only [h, _root_.map_zero, zero_le', inv_zero, or_self]\n  \u00b7 simp only [\u2190 one_le_val_iff v h, le_total]\n\n/-- The subgroup of elements whose valuation is less than a certain unit. -/\ndef ltAddSubgroup (v : Valuation R \u0393\u2080) (\u03b3 : \u0393\u2080\u02e3) : AddSubgroup R where\n  carrier := { x | v x < \u03b3 }\n  zero_mem' := by simp\n  add_mem' {x y} x_in y_in := lt_of_le_of_lt (v.map_add x y) (max_lt x_in y_in)\n  neg_mem' x_in := by rwa [Set.mem_setOf, map_neg]\n\nend Group\n\nend Basic\n\n-- end of section\nnamespace IsEquiv\n\nvariable [Ring R] [LinearOrderedCommMonoidWithZero \u0393\u2080] [LinearOrderedCommMonoidWithZero \u0393'\u2080]\n  {v : Valuation R \u0393\u2080} {v\u2081 : Valuation R \u0393\u2080} {v\u2082 : Valuation R \u0393'\u2080} {v\u2083 : Valuation R \u0393''\u2080}\n\n@[refl]\ntheorem refl : v.IsEquiv v := fun _ _ => Iff.refl _\n\n@[symm]\ntheorem symm (h : v\u2081.IsEquiv v\u2082) : v\u2082.IsEquiv v\u2081 := fun _ _ => Iff.symm (h _ _)\n\n@[trans]\ntheorem trans (h\u2081\u2082 : v\u2081.IsEquiv v\u2082) (h\u2082\u2083 : v\u2082.IsEquiv v\u2083) : v\u2081.IsEquiv v\u2083 := fun _ _ =>\n  Iff.trans (h\u2081\u2082 _ _) (h\u2082\u2083 _ _)\n\ntheorem of_eq {v' : Valuation R \u0393\u2080} (h : v = v') : v.IsEquiv v' := by subst h; rfl\n\ntheorem map {v' : Valuation R \u0393\u2080} (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080) (hf : Monotone f) (inf : Injective f)\n    (h : v.IsEquiv v') : (v.map f hf).IsEquiv (v'.map f hf) :=\n  let H : StrictMono f := hf.strictMono_of_injective inf\n  fun r s =>\n  calc\n    f (v r) \u2264 f (v s) \u2194 v r \u2264 v s := by rw [H.le_iff_le]\n    _ \u2194 v' r \u2264 v' s := h r s\n    _ \u2194 f (v' r) \u2264 f (v' s) := by rw [H.le_iff_le]\n\n/-- `comap` preserves equivalence. -/\ntheorem comap {S : Type*} [Ring S] (f : S \u2192+* R) (h : v\u2081.IsEquiv v\u2082) :\n    (v\u2081.comap f).IsEquiv (v\u2082.comap f) := fun r s => h (f r) (f s)\n\ntheorem val_eq (h : v\u2081.IsEquiv v\u2082) {r s : R} : v\u2081 r = v\u2081 s \u2194 v\u2082 r = v\u2082 s := by\n  simpa only [le_antisymm_iff] using and_congr (h r s) (h s r)\n\ntheorem ne_zero (h : v\u2081.IsEquiv v\u2082) {r : R} : v\u2081 r \u2260 0 \u2194 v\u2082 r \u2260 0 := by\n  have : v\u2081 r \u2260 v\u2081 0 \u2194 v\u2082 r \u2260 v\u2082 0 := not_congr h.val_eq\n  rwa [v\u2081.map_zero, v\u2082.map_zero] at this\n\nend IsEquiv\n\n-- end of namespace\nsection\n\ntheorem isEquiv_of_map_strictMono [LinearOrderedCommMonoidWithZero \u0393\u2080]\n    [LinearOrderedCommMonoidWithZero \u0393'\u2080] [Ring R] {v : Valuation R \u0393\u2080} (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080)\n    (H : StrictMono f) : IsEquiv (v.map f H.monotone) v := fun _x _y =>\n  \u27e8H.le_iff_le.mp, fun h => H.monotone h\u27e9\n\ntheorem isEquiv_iff_val_lt_val [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x y : K}, v x < v y \u2194 v' x < v' y := by\n  simp only [IsEquiv, le_iff_le_iff_lt_iff_lt]\n  exact forall_comm\n\nalias \u27e8IsEquiv.lt_iff_lt, _\u27e9 := isEquiv_iff_val_lt_val\n\ntheorem isEquiv_of_val_le_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080}\n    (h : \u2200 {x : K}, v x \u2264 1 \u2194 v' x \u2264 1) : v.IsEquiv v' := by\n  intro x y\n  obtain rfl | hy := eq_or_ne y 0\n  \u00b7 simp\n  \u00b7 rw [\u2190 div_le_one\u2080, \u2190 v.map_div, h, v'.map_div, div_le_one\u2080] <;>\n      rwa [zero_lt_iff, ne_zero_iff]\n\ntheorem isEquiv_iff_val_le_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v x \u2264 1 \u2194 v' x \u2264 1 :=\n  \u27e8fun h x => by simpa using h x 1, isEquiv_of_val_le_one\u27e9\n\nalias \u27e8IsEquiv.le_one_iff_le_one, _\u27e9 := isEquiv_iff_val_le_one\n\ntheorem isEquiv_iff_val_eq_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v x = 1 \u2194 v' x = 1 := by\n  constructor\n  \u00b7 intro h x\n    simpa using @IsEquiv.val_eq _ _ _ _ _ _ v v' h x 1\n  \u00b7 intro h\n    apply isEquiv_of_val_le_one\n    intro x\n    constructor\n    \u00b7 intro hx\n      rcases lt_or_eq_of_le hx with hx' | hx'\n      \u00b7 have : v (1 + x) = 1 := by\n          rw [\u2190 v.map_one]\n          apply map_add_eq_of_lt_left\n          simpa\n        rw [h] at this\n        rw [show x = -1 + (1 + x) by simp]\n        refine le_trans (v'.map_add _ _) ?_\n        simp [this]\n      \u00b7 rw [h] at hx'\n        exact le_of_eq hx'\n    \u00b7 intro hx\n      rcases lt_or_eq_of_le hx with hx' | hx'\n      \u00b7 have : v' (1 + x) = 1 := by\n          rw [\u2190 v'.map_one]\n          apply map_add_eq_of_lt_left\n          simpa\n        rw [\u2190 h] at this\n        rw [show x = -1 + (1 + x) by simp]\n        refine le_trans (v.map_add _ _) ?_\n        simp [this]\n      \u00b7 rw [\u2190 h] at hx'\n        exact le_of_eq hx'\n\nalias \u27e8IsEquiv.eq_one_iff_eq_one, _\u27e9 := isEquiv_iff_val_eq_one\n\ntheorem isEquiv_iff_val_lt_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v x < 1 \u2194 v' x < 1 := by\n  constructor\n  \u00b7 intro h x\n    simp only [lt_iff_le_and_ne,\n      and_congr h.le_one_iff_le_one h.eq_one_iff_eq_one.not]\n  \u00b7 rw [isEquiv_iff_val_eq_one]\n    intro h x\n    by_cases hx : x = 0\n    \u00b7 simp only [(zero_iff _).2 hx, zero_ne_one]\n    constructor\n    \u00b7 intro hh\n      by_contra h_1\n      cases ne_iff_lt_or_gt.1 h_1 with\n      | inl h_2 => simpa [hh, lt_self_iff_false] using h.2 h_2\n      | inr h_2 =>\n          rw [\u2190 inv_one, \u2190 inv_eq_iff_eq_inv, \u2190 map_inv\u2080] at hh\n          exact hh.not_lt (h.2 ((one_lt_val_iff v' hx).1 h_2))\n    \u00b7 intro hh\n      by_contra h_1\n      cases ne_iff_lt_or_gt.1 h_1 with\n      | inl h_2 => simpa [hh, lt_self_iff_false] using h.1 h_2\n      | inr h_2 =>\n        rw [\u2190 inv_one, \u2190 inv_eq_iff_eq_inv, \u2190 map_inv\u2080] at hh\n        exact hh.not_lt (h.1 ((one_lt_val_iff v hx).1 h_2))\n\nalias \u27e8IsEquiv.lt_one_iff_lt_one, _\u27e9 := isEquiv_iff_val_lt_one\n\ntheorem isEquiv_iff_val_sub_one_lt_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v (x - 1) < 1 \u2194 v' (x - 1) < 1 := by\n  rw [isEquiv_iff_val_lt_one]\n  exact (Equiv.subRight 1).surjective.forall\n\nalias \u27e8IsEquiv.val_sub_one_lt_one_iff, _\u27e9 := isEquiv_iff_val_sub_one_lt_one\n\ntheorem isEquiv_tfae [LinearOrderedCommGroupWithZero \u0393\u2080] [LinearOrderedCommGroupWithZero \u0393'\u2080]\n    (v : Valuation K \u0393\u2080) (v' : Valuation K \u0393'\u2080) :\n    [ v.IsEquiv v',\n      \u2200 {x y}, v x < v y \u2194 v' x < v' y,\n      \u2200 {x}, v x \u2264 1 \u2194 v' x \u2264 1,\n      \u2200 {x}, v x = 1 \u2194 v' x = 1,\n      \u2200 {x}, v x < 1 \u2194 v' x < 1,\n      \u2200 {x}, v (x - 1) < 1 \u2194 v' (x - 1) < 1 ].TFAE := by\n  tfae_have 1 \u2194 2 := isEquiv_iff_val_lt_val\n  tfae_have 1 \u2194 3 := isEquiv_iff_val_le_one\n  tfae_have 1 \u2194 4 := isEquiv_iff_val_eq_one\n  tfae_have 1 \u2194 5 := isEquiv_iff_val_lt_one\n  tfae_have 1 \u2194 6 := isEquiv_iff_val_sub_one_lt_one\n  tfae_finish\n\nend\n\nsection Supp\n\nvariable [CommRing R] [LinearOrderedCommMonoidWithZero \u0393\u2080] (v : Valuation R \u0393\u2080)\n\n/-- The support of a valuation `v : R \u2192 \u0393\u2080` is the ideal of `R` where `v` vanishes. -/\ndef supp : Ideal R where\n  carrier := { x | v x = 0 }\n  zero_mem' := map_zero v\n  add_mem' {x y} hx hy := le_zero_iff.mp <|\n    calc\n      v (x + y) \u2264 max (v x) (v y) := v.map_add x y\n      _ \u2264 0 := max_le (le_zero_iff.mpr hx) (le_zero_iff.mpr hy)\n  smul_mem' c x hx :=\n    calc\n      v (c * x) = v c * v x := map_mul v c x\n      _ = v c * 0 := congr_arg _ hx\n      _ = 0 := mul_zero _\n\n@[simp]\ntheorem mem_supp_iff (x : R) : x \u2208 supp v \u2194 v x = 0 :=\n  Iff.rfl\n\n/-- The support of a valuation is a prime ideal. -/\ninstance [Nontrivial \u0393\u2080] [NoZeroDivisors \u0393\u2080] : Ideal.IsPrime (supp v) :=\n  \u27e8fun h =>\n    one_ne_zero (\u03b1 := \u0393\u2080) <|\n      calc\n        1 = v 1 := v.map_one.symm\n        _ = 0 := by rw [\u2190 mem_supp_iff, h]; exact Submodule.mem_top,\n   fun {x y} hxy => by\n    simp only [mem_supp_iff] at hxy \u22a2\n    rw [v.map_mul x y] at hxy\n    exact eq_zero_or_eq_zero_of_mul_eq_zero hxy\u27e9\n\ntheorem map_add_supp (a : R) {s : R} (h : s \u2208 supp v) : v (a + s) = v a := by\n  have aux : \u2200 a s, v s = 0 \u2192 v (a + s) \u2264 v a := by\n    intro a' s' h'\n    refine le_trans (v.map_add a' s') (max_le le_rfl ?_)\n    simp [h']\n  apply le_antisymm (aux a s h)\n  calc\n    v a = v (a + s + -s) := by simp\n    _ \u2264 v (a + s) := aux (a + s) (-s) (by rwa [\u2190 Ideal.neg_mem_iff] at h)\n\ntheorem comap_supp {S : Type*} [CommRing S] (f : S \u2192+* R) :\n    supp (v.comap f) = Ideal.comap f v.supp :=\n  Ideal.ext fun x => by rw [mem_supp_iff, Ideal.mem_comap, mem_supp_iff, comap_apply]\n\nend Supp\n\n-- end of section\nend Valuation\n\nsection AddMonoid\n\nvariable (R) [Ring R] (\u0393\u2080 : Type*) [LinearOrderedAddCommMonoidWithTop \u0393\u2080]\n\n/-- The type of `\u0393\u2080`-valued additive valuations on `R`. -/\ndef AddValuation :=\n  Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48)\n\nend AddMonoid\n\nnamespace AddValuation\n\nvariable {\u0393\u2080 : Type*} {\u0393'\u2080 : Type*}\n\nsection Basic\n\nsection Monoid\n\n/-- A valuation is coerced to the underlying function `R \u2192 \u0393\u2080`. -/\ninstance (R) (\u0393\u2080) [Ring R] [LinearOrderedAddCommMonoidWithTop \u0393\u2080] :\n    FunLike (AddValuation R \u0393\u2080) R \u0393\u2080 where\n  coe v := v.toMonoidWithZeroHom.toFun\n  coe_injective' f g := by cases f; cases g; simp (config := {contextual := true})\n\nvariable [Ring R] [LinearOrderedAddCommMonoidWithTop \u0393\u2080] [LinearOrderedAddCommMonoidWithTop \u0393'\u2080]\n  (v : AddValuation R \u0393\u2080)\n\nsection\n\nvariable (f : R \u2192 \u0393\u2080) (h0 : f 0 = \u22a4) (h1 : f 1 = 0)\nvariable (hadd : \u2200 x y, min (f x) (f y) \u2264 f (x + y)) (hmul : \u2200 x y, f (x * y) = f x + f y)\n\n/-- An alternate constructor of `AddValuation`, that doesn't reference `Multiplicative \u0393\u2080\u1d52\u1d48` -/\ndef of : AddValuation R \u0393\u2080 where\n  toFun := f\n  map_one' := h1\n  map_zero' := h0\n  map_add_le_max' := hadd\n  map_mul' := hmul\n\nvariable {h0} {h1} {hadd} {hmul} {r : R}\n\n@[simp]\ntheorem of_apply : (of f h0 h1 hadd hmul) r = f r := rfl\n\n/-- The `Valuation` associated to an `AddValuation` (useful if the latter is constructed using\n`AddValuation.of`). -/\ndef toValuation : AddValuation R \u0393\u2080 \u2243 Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48) :=\n  Equiv.refl _\n\n@[deprecated (since := \"2024-11-09\")]\nalias valuation := toValuation\n\n/-- The `AddValuation` associated to a `Valuation`.\n-/\ndef ofValuation : Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48) \u2243 AddValuation R \u0393\u2080 :=\n  Equiv.refl _\n\n@[simp]\nlemma ofValuation_symm_eq : ofValuation.symm = toValuation (R := R) (\u0393\u2080 := \u0393\u2080) := rfl\n\n@[simp]\nlemma toValuation_symm_eq : toValuation.symm = ofValuation (R := R) (\u0393\u2080 := \u0393\u2080) := rfl\n\n@[simp]\nlemma ofValuation_toValuation : ofValuation (toValuation v) = v := rfl\n\n@[simp]\nlemma toValuation_ofValuation (v : Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48)) :\n    toValuation (ofValuation v) = v := rfl\n\n@[simp]\ntheorem toValuation_apply (r : R) :\n    toValuation v r = Multiplicative.ofAdd (OrderDual.toDual (v r)) :=\n  rfl\n\n@[deprecated (since := \"2024-11-09\")]\nalias valuation_apply := toValuation_apply\n\n@[simp]\ntheorem ofValuation_apply (v : Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48)) (r : R) :\n    ofValuation v r = OrderDual.ofDual (Multiplicative.toAdd (v r)) :=\n  rfl\n\nend\n\n-- Porting note: Lean get confused about namespaces and instances below\n@[simp]\ntheorem map_zero : v 0 = (\u22a4 : \u0393\u2080) :=\n  Valuation.map_zero v\n\n@[simp]\ntheorem map_one : v 1 = (0 : \u0393\u2080) :=\n  Valuation.map_one v\n\n/- Porting note: helper wrapper to coerce `v` to the correct function type -/\n/-- A helper function for Lean to inferring types correctly -/\ndef asFun : R \u2192 \u0393\u2080 := v\n\n@[simp]\ntheorem map_mul : \u2200 (x y : R), v (x * y) = v x + v y :=\n  Valuation.map_mul v\n\n-- Porting note: LHS simplified so created map_add' and removed simp tag\ntheorem map_add : \u2200 (x y : R), min (v x) (v y) \u2264 v (x + y) :=\n  Valuation.map_add v\n\n@[simp]\ntheorem map_add' : \u2200 (x y : R), v x \u2264 v (x + y) \u2228 v y \u2264 v (x + y) := by\n  intro x y\n  rw [\u2190 @min_le_iff _ _ (v x) (v y) (v (x+y)), \u2190 ge_iff_le]\n  apply map_add\n\ntheorem map_le_add {x y : R} {g : \u0393\u2080} (hx : g \u2264 v x) (hy : g \u2264 v y) : g \u2264 v (x + y) :=\n  Valuation.map_add_le v hx hy\n\ntheorem map_lt_add {x y : R} {g : \u0393\u2080} (hx : g < v x) (hy : g < v y) : g < v (x + y) :=\n  Valuation.map_add_lt v hx hy\n\ntheorem map_le_sum {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hf : \u2200 i \u2208 s, g \u2264 v (f i)) :\n    g \u2264 v (\u2211 i \u2208 s, f i) :=\n  v.map_sum_le hf\n\ntheorem map_lt_sum {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hg : g \u2260 \u22a4)\n    (hf : \u2200 i \u2208 s, g < v (f i)) : g < v (\u2211 i \u2208 s, f i) :=\n  v.map_sum_lt hg hf\n\ntheorem map_lt_sum' {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hg : g < \u22a4)\n    (hf : \u2200 i \u2208 s, g < v (f i)) : g < v (\u2211 i \u2208 s, f i) :=\n  v.map_sum_lt' hg hf\n\n@[simp]\ntheorem map_pow : \u2200 (x : R) (n : \u2115), v (x ^ n) = n \u2022 (v x) :=\n  Valuation.map_pow v\n\n@[ext]\ntheorem ext {v\u2081 v\u2082 : AddValuation R \u0393\u2080} (h : \u2200 r, v\u2081 r = v\u2082 r) : v\u2081 = v\u2082 :=\n  Valuation.ext h\n\n-- The following definition is not an instance, because we have more than one `v` on a given `R`.\n-- In addition, type class inference would not be able to infer `v`.\n/-- A valuation gives a preorder on the underlying ring. -/\ndef toPreorder : Preorder R :=\n  Preorder.lift v\n\n/-- If `v` is an additive valuation on a division ring then `v(x) = \u22a4` iff `x = 0`. -/\n@[simp]\ntheorem top_iff [Nontrivial \u0393\u2080] (v : AddValuation K \u0393\u2080) {x : K} : v x = (\u22a4 : \u0393\u2080) \u2194 x = 0 :=\n  v.zero_iff\n\ntheorem ne_top_iff [Nontrivial \u0393\u2080] (v : AddValuation K \u0393\u2080) {x : K} : v x \u2260 (\u22a4 : \u0393\u2080) \u2194 x \u2260 0 :=\n  v.ne_zero_iff\n\n/-- A ring homomorphism `S \u2192 R` induces a map `AddValuation R \u0393\u2080 \u2192 AddValuation S \u0393\u2080`. -/\ndef comap {S : Type*} [Ring S] (f : S \u2192+* R) (v : AddValuation R \u0393\u2080) : AddValuation S \u0393\u2080 :=\n  Valuation.comap f v\n\n@[simp]\ntheorem comap_id : v.comap (RingHom.id R) = v :=\n  Valuation.comap_id v\n\ntheorem comap_comp {S\u2081 : Type*} {S\u2082 : Type*} [Ring S\u2081] [Ring S\u2082] (f : S\u2081 \u2192+* S\u2082) (g : S\u2082 \u2192+* R) :\n    v.comap (g.comp f) = (v.comap g).comap f :=\n  Valuation.comap_comp v f g\n\n/-- A `\u2264`-preserving, `\u22a4`-preserving group homomorphism `\u0393\u2080 \u2192 \u0393'\u2080` induces a map\n  `AddValuation R \u0393\u2080 \u2192 AddValuation R \u0393'\u2080`.\n-/\ndef map (f : \u0393\u2080 \u2192+ \u0393'\u2080) (ht : f \u22a4 = \u22a4) (hf : Monotone f) (v : AddValuation R \u0393\u2080) :\n    AddValuation R \u0393'\u2080 :=\n  @Valuation.map R (Multiplicative \u0393\u2080\u1d52\u1d48) (Multiplicative \u0393'\u2080\u1d52\u1d48) _ _ _\n    { toFun := f\n      map_mul' := f.map_add\n      map_one' := f.map_zero\n      map_zero' := ht } (fun _ _ h => hf h) v\n\n@[simp]\nlemma map_apply (f : \u0393\u2080 \u2192+ \u0393'\u2080) (ht : f \u22a4 = \u22a4) (hf : Monotone f) (v : AddValuation R \u0393\u2080) (r : R) :\n    v.map f ht hf r = f (v r) := rfl\n\n/-- Two additive valuations on `R` are defined to be equivalent if they induce the same\n  preorder on `R`. -/\ndef IsEquiv (v\u2081 : AddValuation R \u0393\u2080) (v\u2082 : AddValuation R \u0393'\u2080) : Prop :=\n  Valuation.IsEquiv v\u2081 v\u2082\n\n@[simp]\ntheorem map_neg (x : R) : v (-x) = v x :=\n  Valuation.map_neg v x\n\ntheorem map_sub_swap (x y : R) : v (x - y) = v (y - x) :=\n  Valuation.map_sub_swap v x y\n\ntheorem map_sub (x y : R) : min (v x) (v y) \u2264 v (x - y) :=\n  Valuation.map_sub v x y\n\ntheorem map_le_sub {x y : R} {g : \u0393\u2080} (hx : g \u2264 v x) (hy : g \u2264 v y) : g \u2264 v (x - y) :=\n  Valuation.map_sub_le v hx hy\n\nvariable {x y : R}\n\ntheorem map_add_of_distinct_val (h : v x \u2260 v y) : v (x + y) = @Min.min \u0393\u2080 _ (v x) (v y) :=\n  Valuation.map_add_of_distinct_val v h\n\ntheorem map_add_eq_of_lt_left {x y : R} (h : v x < v y) :\n    v (x + y) = v x := by\n  rw [map_add_of_distinct_val _ h.ne, min_eq_left h.le]\n\ntheorem map_add_eq_of_lt_right {x y : R} (hx : v y < v x) :\n    v (x + y) = v y := add_comm y x \u25b8 map_add_eq_of_lt_left v hx\n\ntheorem map_sub_eq_of_lt_left {x y : R} (hx : v x < v y) :\n    v (x - y) = v x := by\n  rw [sub_eq_add_neg]\n  apply map_add_eq_of_lt_left\n  rwa [map_neg]\n\ntheorem map_sub_eq_of_lt_right {x y : R} (hx : v y < v x) :\n    v (x - y) = v y := map_sub_swap v x y \u25b8 map_sub_eq_of_lt_left v hx\n\ntheorem map_eq_of_lt_sub (h : v x < v (y - x)) : v y = v x :=\n  Valuation.map_eq_of_sub_lt v h\n\nend Monoid\n\nsection Group\n\nvariable [LinearOrderedAddCommGroupWithTop \u0393\u2080] [Ring R] (v : AddValuation R \u0393\u2080) {x y : R}\n\n@[simp]\ntheorem map_inv (v : AddValuation K \u0393\u2080) {x : K} : v x\u207b\u00b9 = - (v x) :=\n  map_inv\u2080 (toValuation v) x\n\n@[simp]\ntheorem map_div (v : AddValuation K \u0393\u2080) {x y : K} : v (x / y) = v x - v y :=\n  map_div\u2080 (toValuation v) x y\n\nend Group\n\nend Basic\n\nnamespace IsEquiv\n\nvariable [LinearOrderedAddCommMonoidWithTop \u0393\u2080] [LinearOrderedAddCommMonoidWithTop \u0393'\u2080]\n  [Ring R]\n  {\u0393''\u2080 : Type*} [LinearOrderedAddCommMonoidWithTop \u0393''\u2080]\n  {v : AddValuation R \u0393\u2080}\n   {v\u2081 : AddValuation R \u0393\u2080} {v\u2082 : AddValuation R \u0393'\u2080} {v\u2083 : AddValuation R \u0393''\u2080}\n\n@[refl]\ntheorem refl : v.IsEquiv v :=\n  Valuation.IsEquiv.refl\n\n@[symm]\ntheorem symm (h : v\u2081.IsEquiv v\u2082) : v\u2082.IsEquiv v\u2081 :=\n  Valuation.IsEquiv.symm h\n\n@[trans]\ntheorem trans (h\u2081\u2082 : v\u2081.IsEquiv v\u2082) (h\u2082\u2083 : v\u2082.IsEquiv v\u2083) : v\u2081.IsEquiv v\u2083 :=\n  Valuation.IsEquiv.trans h\u2081\u2082 h\u2082\u2083\n\ntheorem of_eq {v' : AddValuation R \u0393\u2080} (h : v = v') : v.IsEquiv v' :=\n  Valuation.IsEquiv.of_eq h\n\ntheorem map {v' : AddValuation R \u0393\u2080} (f : \u0393\u2080 \u2192+ \u0393'\u2080) (ht : f \u22a4 = \u22a4) (hf : Monotone f)\n    (inf : Injective f) (h : v.IsEquiv v') : (v.map f ht hf).IsEquiv (v'.map f ht hf) :=\n  @Valuation.IsEquiv.map R (Multiplicative \u0393\u2080\u1d52\u1d48) (Multiplicative \u0393'\u2080\u1d52\u1d48) _ _ _ _ _\n    { toFun := f\n      map_mul' := f.map_add\n      map_one' := f.map_zero\n      map_zero' := ht } (fun _x _y h => hf h) inf h\n\n/-- `comap` preserves equivalence. -/\ntheorem comap {S : Type*} [Ring S] (f : S \u2192+* R) (h : v\u2081.IsEquiv v\u2082) :\n    (v\u2081.comap f).IsEquiv (v\u2082.comap f) :=\n  Valuation.IsEquiv.comap f h\n\ntheorem val_eq (h : v\u2081.IsEquiv v\u2082) {r s : R} : v\u2081 r = v\u2081 s \u2194 v\u2082 r = v\u2082 s :=\n  Valuation.IsEquiv.val_eq h\n\ntheorem ne_top (h : v\u2081.IsEquiv v\u2082) {r : R} : v\u2081 r \u2260 (\u22a4 : \u0393\u2080) \u2194 v\u2082 r \u2260 (\u22a4 : \u0393'\u2080) :=\n  Valuation.IsEquiv.ne_zero h\n\nend IsEquiv\n\nsection Supp\n\nvariable [LinearOrderedAddCommMonoidWithTop \u0393\u2080] [CommRing R] (v : AddValuation R \u0393\u2080)\n\n/-- The support of an additive valuation `v : R \u2192 \u0393\u2080` is the ideal of `R` where `v x = \u22a4` -/\ndef supp : Ideal R :=\n  Valuation.supp v\n\n@[simp]\ntheorem mem_supp_iff (x : R) : x \u2208 supp v \u2194 v x = (\u22a4 : \u0393\u2080) :=\n  Valuation.mem_supp_iff v x\n\ntheorem map_add_supp (a : R) {s : R} (h : s \u2208 supp v) : v (a + s) = v a :=\n  Valuation.map_add_supp v a h\n\nend Supp\n\n-- end of section\nend AddValuation\n\nnamespace Valuation\n\nvariable {K \u0393\u2080 : Type*} [Ring R] [LinearOrderedCommMonoidWithZero \u0393\u2080]\n\n/-- The `AddValuation` associated to a `Valuation`. -/\ndef toAddValuation : Valuation R \u0393\u2080 \u2243 AddValuation R (Additive \u0393\u2080)\u1d52\u1d48 :=\n  .trans (congr\n    { toFun := fun x \u21a6 .ofAdd <| .toDual <| .toDual <| .ofMul x\n      invFun := fun x \u21a6 x.toAdd.ofDual.ofDual.toMul\n      left_inv := fun _x \u21a6 rfl\n      right_inv := fun _x \u21a6 rfl\n      map_mul' := fun _x _y \u21a6 rfl\n      map_le_map_iff' := .rfl }) (AddValuation.ofValuation (R := R) (\u0393\u2080 := (Additive \u0393\u2080)\u1d52\u1d48))\n\n/-- The `Valuation` associated to a `AddValuation`.\n-/\ndef ofAddValuation : AddValuation R (Additive \u0393\u2080)\u1d52\u1d48 \u2243 Valuation R \u0393\u2080 :=\n  AddValuation.toValuation.trans <| congr <|\n    { toFun := fun x \u21a6 x.toAdd.ofDual.ofDual.toMul\n      invFun := fun x \u21a6 .ofAdd <| .toDual <| .toDual <| .ofMul x\n      left_inv := fun _x \u21a6 rfl\n      right_inv := fun _x \u21a6 rfl\n      map_mul' := fun _x _y \u21a6 rfl\n      map_le_map_iff' := .rfl }\n\n@[simp]\nlemma ofAddValuation_symm_eq : ofAddValuation.symm = toAddValuation (R := R) (\u0393\u2080 := \u0393\u2080) := rfl\n\n@[simp]\nlemma toAddValuation_symm_eq : toAddValuation.symm = ofAddValuation (R := R) (\u0393\u2080 := \u0393\u2080) := rfl\n\n@[simp]\nlemma ofAddValuation_toAddValuation (v : Valuation R \u0393\u2080) :\n  ofAddValuation (toAddValuation v) = v := rfl\n\n@[simp]\nlemma toValuation_ofValuation (v : AddValuation R (Additive \u0393\u2080)\u1d52\u1d48) :\n    toAddValuation (ofAddValuation v) = v := rfl\n\n", "theoremStatement": "@[simp]\ntheorem toAddValuation_apply (v : Valuation R \u0393\u2080) (r : R) :\n    toAddValuation v r = OrderDual.toDual (Additive.ofMul (v r)) ", "theoremName": "Valuation.toAddValuation_apply", "fileCreated": {"commit": "a9138cdba12f2110c86195f5eac26cb36dee2627", "date": "2023-03-17"}, "theoremCreated": {"commit": "625ac34a53dfa0eca4fb8a3a933409238e4f43f0", "date": "2024-12-16"}, "file": "mathlib/Mathlib/RingTheory/Valuation/Basic.lean", "module": "Mathlib.RingTheory.Valuation.Basic", "jsonFile": "Mathlib.RingTheory.Valuation.Basic.jsonl", "positionMetadata": {"lineInFile": 945, "tokenPositionInFile": 32144, "theoremPositionInFile": 132}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 5, "repositoryPremises": true, "numRepositoryPremises": 15, "numPremises": 17}, "proofMetadata": {"hasProof": true, "proof": ":=\n  rfl", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 8}}
{"srcContext": "/-\nCopyright (c) 2024 Xavier Roblot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Xavier Roblot\n-/\nimport Mathlib.Analysis.BoxIntegral.UnitPartition\nimport Mathlib.MeasureTheory.Measure.Haar.InnerProductSpace\n\n/-!\n# Covolume of \u2124-lattices\n\nLet `E` be a finite dimensional real vector space.\n\nLet `L` be a `\u2124`-lattice `L` defined as a discrete `\u2124`-submodule of `E` that spans `E` over `\u211d`.\n\n## Main definitions and results\n\n* `ZLattice.covolume`: the covolume of `L` defined as the volume of an arbitrary fundamental\ndomain of `L`.\n\n* `ZLattice.covolume_eq_measure_fundamentalDomain`: the covolume of `L` does not depend on the\nchoice of the fundamental domain of `L`.\n\n* `ZLattice.covolume_eq_det`: if `L` is a lattice in `\u211d^n`, then its covolume is the absolute\nvalue of the determinant of any `\u2124`-basis of `L`.\n\n* `ZLattice.covolume.tendsto_card_div_pow`: Let `s` be a bounded measurable set of `\u03b9 \u2192 \u211d`, then\nthe number of points in `s \u2229 n\u207b\u00b9 \u2022 L` divided by `n ^ card \u03b9` tends to `volume s / covolume L`\nwhen `n : \u2115` tends to infinity. See also `ZLattice.covolume.tendsto_card_div_pow'` for a version\nfor `InnerProductSpace \u211d E` and `ZLattice.covolume.tendsto_card_div_pow''` for the general version.\n\n* `ZLattice.covolume.tendsto_card_le_div`: Let `X` be a cone in `\u03b9 \u2192 \u211d` and let `F : (\u03b9 \u2192 \u211d) \u2192 \u211d`\nbe a function such that `F (c \u2022 x) = c ^ card \u03b9 * F x`. Then the number of points `x \u2208 X` such that\n`F x \u2264 c` divided by `c` tends to `volume {x \u2208 X | F x \u2264 1} / covolume L` when `c : \u211d` tends to\ninfinity. See also `ZLattice.covolume.tendsto_card_le_div'` for a version for\n`InnerProductSpace \u211d E` and `ZLattice.covolume.tendsto_card_le_div''` for the general version.\n\n## Naming convention\n\nSome results are true in the case where the ambient finite dimensional real vector space is the\npi-space `\u03b9 \u2192 \u211d` and in the case where it is an `InnerProductSpace`. We use the following\nconvention: the plain name is for the pi case, for eg. `volume_image_eq_volume_div_covolume`. For\nthe same result in the `InnerProductSpace` case, we add a `prime`, for eg.\n`volume_image_eq_volume_div_covolume'`. When the same result exists in the\ngeneral case, we had two primes, eg. `covolume.tendsto_card_div_pow''`.\n\n-/\n\nnoncomputable section\n\nnamespace ZLattice\n\nopen Submodule MeasureTheory Module MeasureTheory Module ZSpan\n\nsection General\n\nvariable {E : Type*} [NormedAddCommGroup E] [MeasurableSpace E] (L : Submodule \u2124 E)\n\n/-- The covolume of a `\u2124`-lattice is the volume of some fundamental domain; see\n`ZLattice.covolume_eq_volume` for the proof that the volume does not depend on the choice of\nthe fundamental domain. -/\ndef covolume (\u03bc : Measure E := by volume_tac) : \u211d := (addCovolume L E \u03bc).toReal\n\nend General\n\nsection Basic\n\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] [FiniteDimensional \u211d E]\nvariable [MeasurableSpace E] [BorelSpace E]\nvariable (L : Submodule \u2124 E) [DiscreteTopology L] [IsZLattice \u211d L]\nvariable (\u03bc : Measure E := by volume_tac) [Measure.IsAddHaarMeasure \u03bc]\n\ntheorem covolume_eq_measure_fundamentalDomain {F : Set E} (h : IsAddFundamentalDomain L F \u03bc) :\n    covolume L \u03bc = (\u03bc F).toReal := by\n  have : MeasurableVAdd L E := (inferInstance : MeasurableVAdd L.toAddSubgroup E)\n  have : VAddInvariantMeasure L E \u03bc := (inferInstance : VAddInvariantMeasure L.toAddSubgroup E \u03bc)\n  exact congr_arg ENNReal.toReal (h.covolume_eq_volume \u03bc)\n\ntheorem covolume_ne_zero : covolume L \u03bc \u2260 0 := by\n  rw [covolume_eq_measure_fundamentalDomain L \u03bc (isAddFundamentalDomain (Free.chooseBasis \u2124 L) \u03bc),\n    ENNReal.toReal_ne_zero]\n  refine \u27e8measure_fundamentalDomain_ne_zero _, ne_of_lt ?_\u27e9\n  exact Bornology.IsBounded.measure_lt_top (fundamentalDomain_isBounded _)\n\ntheorem covolume_pos : 0 < covolume L \u03bc :=\n  lt_of_le_of_ne ENNReal.toReal_nonneg (covolume_ne_zero L \u03bc).symm\n\ntheorem covolume_comap {F : Type*} [NormedAddCommGroup F] [NormedSpace \u211d F] [FiniteDimensional \u211d F]\n    [MeasurableSpace F] [BorelSpace F] (\u03bd : Measure F := by volume_tac) [Measure.IsAddHaarMeasure \u03bd]\n    {e : F \u2243L[\u211d] E} (he : MeasurePreserving e \u03bd \u03bc) :\n    covolume (ZLattice.comap \u211d L e.toLinearMap) \u03bd = covolume L \u03bc := by\n  rw [covolume_eq_measure_fundamentalDomain _ _ (isAddFundamentalDomain (Free.chooseBasis \u2124 L) \u03bc),\n    covolume_eq_measure_fundamentalDomain _ _ ((isAddFundamentalDomain\n    ((Free.chooseBasis \u2124 L).ofZLatticeComap \u211d L e.toLinearEquiv) \u03bd)), \u2190 he.measure_preimage\n    (fundamentalDomain_measurableSet _).nullMeasurableSet, \u2190 e.image_symm_eq_preimage,\n    \u2190 e.symm.coe_toLinearEquiv, map_fundamentalDomain]\n  congr!\n  ext; simp\n\ntheorem covolume_eq_det_mul_measure {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (b : Basis \u03b9 \u2124 L)\n    (b\u2080 : Basis \u03b9 \u211d E) :\n    covolume L \u03bc = |b\u2080.det ((\u2191) \u2218 b)| * (\u03bc (fundamentalDomain b\u2080)).toReal := by\n  rw [covolume_eq_measure_fundamentalDomain L \u03bc (isAddFundamentalDomain b \u03bc),\n    measure_fundamentalDomain _ _ b\u2080,\n    measure_congr (fundamentalDomain_ae_parallelepiped b\u2080 \u03bc), ENNReal.toReal_mul,\n    ENNReal.toReal_ofReal (by positivity)]\n  congr\n  ext\n  exact b.ofZLatticeBasis_apply \u211d L _\n\ntheorem covolume_eq_det {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (L : Submodule \u2124 (\u03b9 \u2192 \u211d))\n    [DiscreteTopology L] [IsZLattice \u211d L] (b : Basis \u03b9 \u2124 L) :\n    covolume L = |(Matrix.of ((\u2191) \u2218 b)).det| := by\n  rw [covolume_eq_measure_fundamentalDomain L volume (isAddFundamentalDomain b volume),\n    volume_fundamentalDomain, ENNReal.toReal_ofReal (by positivity)]\n  congr\n  ext1\n  exact b.ofZLatticeBasis_apply \u211d L _\n\ntheorem covolume_eq_det_inv {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (L : Submodule \u2124 (\u03b9 \u2192 \u211d))\n    [DiscreteTopology L] [IsZLattice \u211d L] (b : Basis \u03b9 \u2124 L) :\n    covolume L = |(LinearEquiv.det (b.ofZLatticeBasis \u211d L).equivFun : \u211d)|\u207b\u00b9 := by\n  rw [covolume_eq_det L b, \u2190 Pi.basisFun_det_apply, show (((\u2191) : L \u2192 _) \u2218 \u21d1b) =\n    (b.ofZLatticeBasis \u211d) by ext; simp, \u2190 Basis.det_inv, \u2190 abs_inv, Units.val_inv_eq_inv_val,\n    IsUnit.unit_spec, \u2190 Basis.det_basis, LinearEquiv.coe_det]\n  rfl\n\n", "theoremStatement": "theorem volume_image_eq_volume_div_covolume {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9]\n    (L : Submodule \u2124 (\u03b9 \u2192 \u211d)) [DiscreteTopology L] [IsZLattice \u211d L] (b : Basis \u03b9 \u2124 L)\n    {s : Set (\u03b9 \u2192 \u211d)} :\n    volume ((b.ofZLatticeBasis \u211d L).equivFun '' s) = volume s / ENNReal.ofReal (covolume L) ", "theoremName": "ZLattice.volume_image_eq_volume_div_covolume", "fileCreated": {"commit": "85d6c78ac5782869d041c2ca6d3ca83cdde412c3", "date": "2024-09-09"}, "theoremCreated": {"commit": "211dc533566a173988a01067bb50d7917a097103", "date": "2024-12-18"}, "file": "mathlib/Mathlib/Algebra/Module/ZLattice/Covolume.lean", "module": "Mathlib.Algebra.Module.ZLattice.Covolume", "jsonFile": "Mathlib.Algebra.Module.ZLattice.Covolume.jsonl", "positionMetadata": {"lineInFile": 128, "tokenPositionInFile": 5980, "theoremPositionInFile": 8}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 156, "numPremises": 174}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [LinearEquiv.image_eq_preimage, Measure.addHaar_preimage_linearEquiv, LinearEquiv.symm_symm,\n    covolume_eq_det_inv L b, ENNReal.div_eq_inv_mul, ENNReal.ofReal_inv_of_pos\n    (abs_pos.mpr (LinearEquiv.det _).ne_zero), inv_inv, LinearEquiv.coe_det]", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 259}}
{"srcContext": "/-\nCopyright (c) 2024 Jo\u00ebl Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jo\u00ebl Riou\n-/\nimport Mathlib.Algebra.Homology.Embedding.Extend\nimport Mathlib.Algebra.Homology.Embedding.IsSupported\nimport Mathlib.Algebra.Homology.QuasiIso\n\n/-!\n# Homology of the extension of an homological complex\n\nGiven an embedding `e : c.Embedding c'` and `K : HomologicalComplex C c`, we shall\ncompute the homology of `K.extend e`. In degrees that are not in the image of `e.f`,\nthe homology is obviously zero. When `e.f j = j`, we construct an isomorphism\n`(K.extend e).homology j' \u2245 K.homology j`.\n\n-/\n\nopen CategoryTheory Limits Category\n\nnamespace HomologicalComplex\n\nvariable {\u03b9 \u03b9' : Type*} {c : ComplexShape \u03b9} {c' : ComplexShape \u03b9'}\n  {C : Type*} [Category C] [HasZeroMorphisms C]\n  [HasZeroObject C]\n\nvariable (K L M : HomologicalComplex C c) (\u03c6 : K \u27f6 L) (\u03c6' : L \u27f6 M) (e : c.Embedding c')\n\nnamespace extend\n\nsection HomologyData\n\nvariable {i j k : \u03b9} {i' j' k' : \u03b9'} (hj' : e.f j = j')\n  (hi : c.prev j = i) (hi' : c'.prev j' = i') (hk : c.next j = k) (hk' : c'.next j' = k')\n\ninclude hk hk' in\nlemma comp_d_eq_zero_iff \u2983W : C\u2984 (\u03c6 : W \u27f6 K.X j) :\n    \u03c6 \u226b K.d j k = 0 \u2194 \u03c6 \u226b (K.extendXIso e hj').inv \u226b (K.extend e).d j' k' = 0 := by\n  by_cases hjk : c.Rel j k\n  \u00b7 have hk' : e.f k = k' := by rw [\u2190 hk', \u2190 hj', c'.next_eq' (e.rel hjk)]\n    rw [K.extend_d_eq e hj' hk', Iso.inv_hom_id_assoc,\n      \u2190 cancel_mono (K.extendXIso e hk').inv, zero_comp, assoc]\n  \u00b7 simp only [K.shape _ _ hjk, comp_zero, true_iff]\n    rw [K.extend_d_from_eq_zero e j' k' j hj', comp_zero, comp_zero]\n    rw [hk]\n    exact hjk\n\ninclude hi hi' in\nlemma d_comp_eq_zero_iff \u2983W : C\u2984 (\u03c6 : K.X j \u27f6 W) :\n    K.d i j \u226b \u03c6 = 0 \u2194 (K.extend e).d i' j' \u226b (K.extendXIso e hj').hom \u226b \u03c6 = 0 := by\n  by_cases hij : c.Rel i j\n  \u00b7 have hi' : e.f i = i' := by rw [\u2190 hi', \u2190 hj', c'.prev_eq' (e.rel hij)]\n    rw [K.extend_d_eq e hi' hj', assoc, assoc, Iso.inv_hom_id_assoc,\n      \u2190 cancel_epi (K.extendXIso e hi').hom, comp_zero]\n  \u00b7 simp only [K.shape _ _ hij, zero_comp, true_iff]\n    rw [K.extend_d_to_eq_zero e i' j' j hj', zero_comp]\n    rw [hi]\n    exact hij\n\nnamespace leftHomologyData\n\nvariable (cone : KernelFork (K.d j k)) (hcone : IsLimit cone)\n\n/-- The kernel fork of `(K.extend e).d j' k'` that is deduced from a kernel\nfork of `K.d j k `. -/\n@[simp]\nnoncomputable def kernelFork : KernelFork ((K.extend e).d j' k') :=\n  KernelFork.of\u03b9 (cone.\u03b9 \u226b (extendXIso K e hj').inv)\n    (by rw [assoc, \u2190 comp_d_eq_zero_iff K e hj' hk hk' cone.\u03b9, cone.condition])\n\n/-- The limit kernel fork of `(K.extend e).d j' k'` that is deduced from a limit\nkernel fork of `K.d j k `. -/\nnoncomputable def isLimitKernelFork : IsLimit (kernelFork K e hj' hk hk' cone) :=\n  KernelFork.isLimitOfIsLimitOfIff hcone ((K.extend e).d j' k')\n    (extendXIso K e hj').symm (comp_d_eq_zero_iff K e hj' hk hk')\n\nvariable (cocone : CokernelCofork (hcone.lift (KernelFork.of\u03b9 (K.d i j) (K.d_comp_d i j k))))\n  (hcocone : IsColimit cocone)\n\ninclude hi hi' hcone in\n", "theoremStatement": "/-- Auxiliary lemma for `lift_d_comp_eq_zero_iff`. -/\nlemma lift_d_comp_eq_zero_iff' \u2983W : C\u2984 (f' : K.X i \u27f6 cone.pt)\n    (hf' : f' \u226b cone.\u03b9 = K.d i j)\n    (f'' : (K.extend e).X i' \u27f6 cone.pt)\n    (hf'' : f'' \u226b cone.\u03b9 \u226b (extendXIso K e hj').inv = (K.extend e).d i' j')\n    (\u03c6 : cone.pt \u27f6 W) :\n    f' \u226b \u03c6 = 0 \u2194 f'' \u226b \u03c6 = 0 ", "theoremName": "HomologicalComplex.extend.leftHomologyData.lift_d_comp_eq_zero_iff'", "fileCreated": {"commit": "9bdc1af76cf75d960f42c29f1c09917785066c8b", "date": "2024-11-30"}, "theoremCreated": {"commit": "9bdc1af76cf75d960f42c29f1c09917785066c8b", "date": "2024-11-30"}, "file": "mathlib/Mathlib/Algebra/Homology/Embedding/ExtendHomology.lean", "module": "Mathlib.Algebra.Homology.Embedding.ExtendHomology", "jsonFile": "Mathlib.Algebra.Homology.Embedding.ExtendHomology.jsonl", "positionMetadata": {"lineInFile": 82, "tokenPositionInFile": 3035, "theoremPositionInFile": 4}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 49, "numPremises": 70}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  by_cases hij : c.Rel i j\n  \u00b7 have hi'' : e.f i = i' := by rw [\u2190 hi', \u2190 hj', c'.prev_eq' (e.rel hij)]\n    have : (K.extendXIso e hi'').hom \u226b f' = f'' := by\n      apply Fork.IsLimit.hom_ext hcone\n      rw [assoc, hf', \u2190 cancel_mono (extendXIso K e hj').inv, assoc, assoc, hf'',\n        K.extend_d_eq e hi'' hj']\n    rw [\u2190 cancel_epi (K.extendXIso e hi'').hom, comp_zero, \u2190 this, assoc]\n  \u00b7 have h\u2081 : f' = 0 := by\n      apply Fork.IsLimit.hom_ext hcone\n      simp only [zero_comp, hf', K.shape _ _ hij]\n    have h\u2082 : f'' = 0 := by\n      apply Fork.IsLimit.hom_ext hcone\n      dsimp\n      rw [\u2190 cancel_mono (extendXIso K e hj').inv, assoc, hf'', zero_comp, zero_comp,\n        K.extend_d_to_eq_zero e i' j' j hj']\n      rw [hi]\n      exact hij\n    simp [h\u2081, h\u2082]", "proofType": "tactic", "proofLengthLines": 18, "proofLengthTokens": 764}}
{"srcContext": "/-\nCopyright (c) 2023 Jujian Zhang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jujian Zhang, Junyan Xu\n-/\n\nimport Mathlib.Algebra.Category.ModuleCat.Basic\nimport Mathlib.Algebra.Category.Grp.Injective\nimport Mathlib.Topology.Instances.AddCircle\nimport Mathlib.LinearAlgebra.Isomorphisms\n\n/-!\n# Character module of a module\n\nFor commutative ring `R` and an `R`-module `M` and an injective module `D`, its character module\n`M\u22c6` is defined to be `R`-linear maps `M \u27f6 D`.\n\n`M\u22c6` also has an `R`-module structure given by `(r \u2022 f) m = f (r \u2022 m)`.\n\n## Main results\n\n- `CharacterModuleFunctor` : the contravariant functor of `R`-modules where `M \u21a6 M\u22c6` and\nan `R`-linear map `l : M \u27f6 N` induces an `R`-linear map `l\u22c6 : f \u21a6 f \u2218 l` where `f : N\u22c6`.\n- `LinearMap.dual_surjective_of_injective` : If `l` is injective then `l\u22c6` is surjective,\n  in another word taking character module as a functor sends monos to epis.\n- `CharacterModule.homEquiv` : there is a bijection between linear map `Hom(N, M\u22c6)` and\n  `(N \u2297 M)\u22c6` given by `curry` and `uncurry`.\n\n-/\n\nopen CategoryTheory\n\nuniverse uR uA uB\n\nvariable (R : Type uR) [CommRing R]\nvariable (A : Type uA) [AddCommGroup A]\nvariable (A' : Type*) [AddCommGroup A']\nvariable (B : Type uB) [AddCommGroup B]\n\n/--\nThe character module of an abelian group `A` in the unit rational circle is `A\u22c6 := Hom_\u2124(A, \u211a \u29f8 \u2124)`.\n-/\ndef CharacterModule : Type uA := A \u2192+ AddCircle (1 : \u211a)\n\nnamespace CharacterModule\n\ninstance : FunLike (CharacterModule A) A (AddCircle (1 : \u211a)) where\n  coe c := c.toFun\n  coe_injective' _ _ _ := by aesop\n\ninstance : LinearMapClass (CharacterModule A) \u2124 A (AddCircle (1 : \u211a)) where\n  map_add _ _ _ := by rw [AddMonoidHom.map_add]\n  map_smul\u209b\u2097 _ _ _ := by rw [AddMonoidHom.map_zsmul, RingHom.id_apply]\n\ninstance : AddCommGroup (CharacterModule A) :=\n  inferInstanceAs (AddCommGroup (A \u2192+ _))\n\n@[ext] theorem ext {c c' : CharacterModule A} (h : \u2200 x, c x = c' x) : c = c' := DFunLike.ext _ _ h\n\nsection module\n\nvariable [Module R A] [Module R A'] [Module R B]\n\ninstance : Module R (CharacterModule A) :=\n  Module.compHom (A \u2192+ _) (RingEquiv.toOpposite _ |>.toRingHom : R \u2192+* R\u1d48\u1d50\u1d43)\n\nvariable {R A B}\n\n@[simp] lemma smul_apply (c : CharacterModule A) (r : R) (a : A) : (r \u2022 c) a = c (r \u2022 a) := rfl\n\n/--\nGiven an abelian group homomorphism `f : A \u2192 B`, `f\u22c6(L) := L \u2218 f` defines a linear map\nfrom `B\u22c6` to `A\u22c6`.\n-/\n@[simps] def dual (f : A \u2192\u2097[R] B) : CharacterModule B \u2192\u2097[R] CharacterModule A where\n  toFun L := L.comp f.toAddMonoidHom\n  map_add' := by aesop\n  map_smul' r c := by ext x; exact congr(c $(f.map_smul r x)).symm\n\n@[simp]\nlemma dual_zero : dual (0 : A \u2192\u2097[R] B) = 0 := by\n  ext f\n  exact map_zero f\n\nlemma dual_comp {C : Type*} [AddCommGroup C] [Module R C] (f : A \u2192\u2097[R] B) (g : B \u2192\u2097[R] C) :\n    dual (g.comp f) = (dual f).comp (dual g) := by\n  ext\n  rfl\n\nlemma dual_injective_of_surjective (f : A \u2192\u2097[R] B) (hf : Function.Surjective f) :\n    Function.Injective (dual f) := by\n  intro \u03c6 \u03c8 eq\n  ext x\n  obtain \u27e8y, rfl\u27e9 := hf x\n  change (dual f) \u03c6 _ = (dual f) \u03c8 _\n  rw [eq]\n\nlemma dual_surjective_of_injective (f : A \u2192\u2097[R] B) (hf : Function.Injective f) :\n    Function.Surjective (dual f) :=\n  (Module.Baer.of_divisible _).extension_property_addMonoidHom _ hf\n\n/--\nTwo isomorphic modules have isomorphic character modules.\n-/\ndef congr (e : A \u2243\u2097[R] B) : CharacterModule A \u2243\u2097[R] CharacterModule B :=\n  .ofLinear (dual e.symm) (dual e)\n    (by ext c _; exact congr(c $(e.right_inv _)))\n    (by ext c _; exact congr(c $(e.left_inv _)))\n\nopen TensorProduct\n\n/--\nAny linear map `L : A \u2192 B\u22c6` induces a character in `(A \u2297 B)\u22c6` by `a \u2297 b \u21a6 L a b`.\n-/\n@[simps] noncomputable def uncurry :\n    (A \u2192\u2097[R] CharacterModule B) \u2192\u2097[R] CharacterModule (A \u2297[R] B) where\n  toFun c := TensorProduct.liftAddHom c.toAddMonoidHom fun r a b \u21a6 congr($(c.map_smul r a) b)\n  map_add' c c' := DFunLike.ext _ _ fun x \u21a6 by refine x.induction_on ?_ ?_ ?_ <;> aesop\n  map_smul' r c := DFunLike.ext _ _ fun x \u21a6 x.induction_on\n    (by simp_rw [map_zero]) (fun a b \u21a6 congr($(c.map_smul r a) b).symm) (by aesop)\n\n/--\nAny character `c` in `(A \u2297 B)\u22c6` induces a linear map `A \u2192 B\u22c6` by `a \u21a6 b \u21a6 c (a \u2297 b)`.\n-/\n@[simps] noncomputable def curry :\n    CharacterModule (A \u2297[R] B) \u2192\u2097[R] (A \u2192\u2097[R] CharacterModule B) where\n  toFun c :=\n  { toFun := (c.comp <| TensorProduct.mk R A B \u00b7)\n    map_add' := fun _ _ \u21a6 DFunLike.ext _ _ fun b \u21a6\n      congr(c <| $(map_add (mk R A B) _ _) b).trans (c.map_add _ _)\n    map_smul' := fun r a \u21a6 by ext; exact congr(c $(TensorProduct.tmul_smul _ _ _)).symm }\n  map_add' _ _ := rfl\n  map_smul' r c := by ext; exact congr(c $(TensorProduct.tmul_smul _ _ _)).symm\n\n/--\nLinear maps into a character module are exactly characters of the tensor product.\n-/\n@[simps!] noncomputable def homEquiv :\n    (A \u2192\u2097[R] CharacterModule B) \u2243\u2097[R] CharacterModule (A \u2297[R] B) :=\n  .ofLinear uncurry curry (by ext _ z; refine z.induction_on ?_ ?_ ?_ <;> aesop) (by aesop)\n\ntheorem dual_rTensor_conj_homEquiv (f : A \u2192\u2097[R] A') :\n    homEquiv.symm.toLinearMap \u2218\u2097 dual (f.rTensor B) \u2218\u2097 homEquiv.toLinearMap = f.lcomp R _ := rfl\n\nend module\n\n/--\n`\u2124\u22c6`, the character module of `\u2124` in the unit rational circle.\n-/\nprotected abbrev int : Type := CharacterModule \u2124\n\n/-- Given `n : \u2115`, the map `m \u21a6 m / n`. -/\nprotected abbrev int.divByNat (n : \u2115) : CharacterModule.int :=\n  LinearMap.toSpanSingleton \u2124 _ (QuotientAddGroup.mk (n : \u211a)\u207b\u00b9) |>.toAddMonoidHom\n\nprotected lemma int.divByNat_self (n : \u2115) :\n    int.divByNat n n = 0 := by\n  obtain rfl | h0 := eq_or_ne n 0\n  \u00b7 apply map_zero\n  exact (AddCircle.coe_eq_zero_iff _).mpr\n    \u27e81, by simp [mul_inv_cancel\u2080 (Nat.cast_ne_zero (R := \u211a).mpr h0)]\u27e9\n\nvariable {A}\n\n/-- The `\u2124`-submodule spanned by a single element `a` is isomorphic to the quotient of `\u2124`\nby the ideal generated by the order of `a`. -/\n@[simps!] noncomputable def intSpanEquivQuotAddOrderOf (a : A) :\n    (\u2124 \u2219 a) \u2243\u2097[\u2124] \u2124 \u29f8 Ideal.span {(addOrderOf a : \u2124)} :=\n  LinearEquiv.ofEq _ _ (LinearMap.span_singleton_eq_range \u2124 A a) \u226a\u226b\u2097\n  (LinearMap.quotKerEquivRange <| LinearMap.toSpanSingleton \u2124 A a).symm \u226a\u226b\u2097\n  Submodule.quotEquivOfEq _ _ (by\n    ext1 x\n    rw [Ideal.mem_span_singleton, addOrderOf_dvd_iff_zsmul_eq_zero, LinearMap.mem_ker,\n      LinearMap.toSpanSingleton_apply])\n\nlemma intSpanEquivQuotAddOrderOf_apply_self (a : A) :\n    intSpanEquivQuotAddOrderOf a \u27e8a, Submodule.mem_span_singleton_self a\u27e9 =\n    Submodule.Quotient.mk 1 :=\n  (LinearEquiv.eq_symm_apply _).mp <| Subtype.ext (one_zsmul _).symm\n\n/--\nFor an abelian group `A` and an element `a \u2208 A`, there is a character `c : \u2124 \u2219 a \u2192 \u211a \u29f8 \u2124` given by\n`m \u2022 a \u21a6 m / n` where `n` is the smallest positive integer such that `n \u2022 a = 0` and when such `n`\ndoes not exist, `c` is defined by `m \u2022 a \u21a6 m / 2`.\n-/\nnoncomputable def ofSpanSingleton (a : A) : CharacterModule (\u2124 \u2219 a) :=\n  let l :  \u2124 \u29f8 Ideal.span {(addOrderOf a : \u2124)} \u2192\u2097[\u2124] AddCircle (1 : \u211a) :=\n    Submodule.liftQSpanSingleton _\n      (CharacterModule.int.divByNat <|\n        if addOrderOf a = 0 then 2 else addOrderOf a).toIntLinearMap <| by\n        split_ifs with h\n        \u00b7 rw [h, Nat.cast_zero, map_zero]\n        \u00b7 apply CharacterModule.int.divByNat_self\n  l \u2218\u2097 intSpanEquivQuotAddOrderOf a |>.toAddMonoidHom\n\nlemma eq_zero_of_ofSpanSingleton_apply_self (a : A)\n    (h : ofSpanSingleton a \u27e8a, Submodule.mem_span_singleton_self a\u27e9 = 0) : a = 0 := by\n  erw [ofSpanSingleton, LinearMap.toAddMonoidHom_coe, LinearMap.comp_apply,\n     intSpanEquivQuotAddOrderOf_apply_self, Submodule.liftQSpanSingleton_apply,\n    AddMonoidHom.coe_toIntLinearMap, int.divByNat, LinearMap.toSpanSingleton_one,\n    AddCircle.coe_eq_zero_iff] at h\n  rcases h with \u27e8n, hn\u27e9\n  apply_fun Rat.den at hn\n  rw [zsmul_one, Rat.den_intCast, Rat.inv_natCast_den_of_pos] at hn\n  \u00b7 split_ifs at hn\n    \u00b7 cases hn\n    \u00b7 rwa [eq_comm, AddMonoid.addOrderOf_eq_one_iff] at hn\n  \u00b7 split_ifs with h\n    \u00b7 norm_num\n    \u00b7 exact Nat.pos_of_ne_zero h\n\nlemma exists_character_apply_ne_zero_of_ne_zero {a : A} (ne_zero : a \u2260 0) :\n    \u2203 (c : CharacterModule A), c a \u2260 0 :=\n  have \u27e8c, hc\u27e9 := dual_surjective_of_injective _ (Submodule.injective_subtype _) (ofSpanSingleton a)\n  \u27e8c, fun h \u21a6 ne_zero <| eq_zero_of_ofSpanSingleton_apply_self a <| by rwa [\u2190 hc]\u27e9\n\nlemma eq_zero_of_character_apply {a : A} (h : \u2200 c : CharacterModule A, c a = 0) : a = 0 := by\n  contrapose! h; exact exists_character_apply_ne_zero_of_ne_zero h\n\nvariable [Module R A] [Module R A'] [Module R B] {R A' B}\n\nlemma dual_surjective_iff_injective {f : A \u2192\u2097[R] A'} :\n    Function.Surjective (dual f) \u2194 Function.Injective f :=\n  \u27e8fun h \u21a6 (injective_iff_map_eq_zero _).2 fun a h0 \u21a6 eq_zero_of_character_apply fun c \u21a6 by\n    obtain \u27e8c, rfl\u27e9 := h c; exact congr(c $h0).trans c.map_zero,\n  dual_surjective_of_injective f\u27e9\n\ntheorem _root_.rTensor_injective_iff_lcomp_surjective {f : A \u2192\u2097[R] A'} :\n    Function.Injective (f.rTensor B) \u2194 Function.Surjective (f.lcomp R <| CharacterModule B) := by\n  simp [\u2190 dual_rTensor_conj_homEquiv, dual_surjective_iff_injective]\n\n", "theoremStatement": "lemma surjective_of_dual_injective (f : A \u2192\u2097[R] A') (hf : Function.Injective (dual f)) :\n    Function.Surjective f ", "theoremName": "CharacterModule.surjective_of_dual_injective", "fileCreated": {"commit": "65d37dc6412f280a667037cd83fc1f1423cb14cb", "date": "2024-02-27"}, "theoremCreated": {"commit": "f227e4af164386c81166cdc4e8e263323b586a36", "date": "2025-01-09"}, "file": "mathlib/Mathlib/Algebra/Module/CharacterModule.lean", "module": "Mathlib.Algebra.Module.CharacterModule", "jsonFile": "Mathlib.Algebra.Module.CharacterModule.jsonl", "positionMetadata": {"lineInFile": 232, "tokenPositionInFile": 8967, "theoremPositionInFile": 21}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 8, "repositoryPremises": true, "numRepositoryPremises": 72, "numPremises": 95}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [\u2190 LinearMap.range_eq_top, \u2190 Submodule.unique_quotient_iff_eq_top]\n  refine \u27e8Unique.mk inferInstance fun a \u21a6 eq_zero_of_character_apply fun c \u21a6 ?_\u27e9\n  obtain \u27e8b, rfl\u27e9 := QuotientAddGroup.mk'_surjective _ a\n  suffices eq : dual (Submodule.mkQ _) c = 0 from congr($eq b)\n  refine hf ?_\n  rw [\u2190 LinearMap.comp_apply, \u2190 dual_comp, LinearMap.range_mkQ_comp, dual_zero]\n  rfl", "proofType": "tactic", "proofLengthLines": 7, "proofLengthTokens": 379}}
{"srcContext": "/-\nCopyright (c) 2024 Fangming Li. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Fangming Li, Jujian Zhang\n-/\nimport Mathlib.Algebra.Polynomial.AlgebraMap\nimport Mathlib.Algebra.Polynomial.Eval.SMul\nimport Mathlib.Algebra.Polynomial.Roots\nimport Mathlib.Order.Interval.Set.Infinite\nimport Mathlib.RingTheory.Polynomial.Pochhammer\nimport Mathlib.RingTheory.PowerSeries.WellKnown\nimport Mathlib.Tactic.FieldSimp\n\n/-!\n# Hilbert polynomials\n\nIn this file, we formalise the following statement: if `F` is a field with characteristic `0`, then\ngiven any `p : F[X]` and `d : \u2115`, there exists some `h : F[X]` such that for any large enough\n`n : \u2115`, `h(n)` is equal to the coefficient of `X\u207f` in the power series expansion of `p/(1 - X)\u1d48`.\nThis `h` is unique and is denoted as `Polynomial.hilbertPoly p d`.\n\nFor example, given `d : \u2115`, the power series expansion of `1/(1 - X)\u1d48\u207a\u00b9` in `F[X]`\nis `\u03a3\u2099 ((d + n).choose d)X\u207f`, which equals `\u03a3\u2099 ((n + 1)\u00b7\u00b7\u00b7(n + d)/d!)X\u207f` and hence\n`Polynomial.hilbertPoly (1 : F[X]) (d + 1)` is the polynomial `(X + 1)\u00b7\u00b7\u00b7(X + d)/d!`. Note that\nif `d! = 0` in `F`, then the polynomial `(X + 1)\u00b7\u00b7\u00b7(X + d)/d!` no longer works, so we do not want\nthe characteristic of `F` to be divisible by `d!`. As `Polynomial.hilbertPoly` may take any\n`p : F[X]` and `d : \u2115` as its inputs, it is necessary for us to assume that `CharZero F`.\n\n## Main definitions\n\n* `Polynomial.hilbertPoly p d`. Given a field `F`, a polynomial `p : F[X]` and a natural number `d`,\n  if `F` is of characteristic `0`, then `Polynomial.hilbertPoly p d : F[X]` is the polynomial whose\n  value at `n` equals the coefficient of `X\u207f` in the power series expansion of `p/(1 - X)\u1d48`.\n\n## TODO\n\n* Hilbert polynomials of finitely generated graded modules over Noetherian rings.\n-/\n\nopen Nat PowerSeries\n\nvariable (F : Type*) [Field F]\n\nnamespace Polynomial\n\n", "theoremStatement": "/--\nFor any field `F` and natural numbers `d` and `k`, `Polynomial.preHilbertPoly F d k`\nis defined as `(d.factorial : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (X - (C (k : F)) + 1))`.\nThis is the most basic form of Hilbert polynomials. `Polynomial.preHilbertPoly \u211a d 0`\nis exactly the Hilbert polynomial of the polynomial ring `\u211a[X_0,...,X_d]` viewed as\na graded module over itself. In fact, `Polynomial.preHilbertPoly F d k` is the\nsame as `Polynomial.hilbertPoly ((X : F[X]) ^ k) (d + 1)` for any field `F` and\n`d k : \u2115` (see the lemma `Polynomial.hilbertPoly_X_pow_succ`). See also the lemma\n`Polynomial.preHilbertPoly_eq_choose_sub_add`, which states that if `CharZero F`,\nthen for any `d k n : \u2115` with `k \u2264 n`, `(Polynomial.preHilbertPoly F d k).eval (n : F)`\nequals `(n - k + d).choose d`.\n-/\nnoncomputable def preHilbertPoly (d k : \u2115) : F[X] ", "theoremName": "Polynomial.preHilbertPoly", "fileCreated": {"commit": "561e050467d2caa2e4ea5d81ca62600bf268b747", "date": "2024-12-02"}, "theoremCreated": {"commit": "561e050467d2caa2e4ea5d81ca62600bf268b747", "date": "2024-12-02"}, "file": "mathlib/Mathlib/RingTheory/Polynomial/HilbertPoly.lean", "module": "Mathlib.RingTheory.Polynomial.HilbertPoly", "jsonFile": "Mathlib.RingTheory.Polynomial.HilbertPoly.jsonl", "positionMetadata": {"lineInFile": 46, "tokenPositionInFile": 1881, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 37, "numPremises": 44}, "proofMetadata": {"hasProof": true, "proof": ":=\n  (d.factorial : F)\u207b\u00b9 \u2022 ((ascPochhammer F d).comp (Polynomial.X - (C (k : F)) + 1))", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 86}}
{"srcContext": "/-\nCopyright (c) 2018 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes, Abhimanyu Pallavi Sudhir, Jean Lo, Calle S\u00f6nne, S\u00e9bastien Gou\u00ebzel,\n  R\u00e9my Degenne\n-/\nimport Mathlib.Analysis.SpecialFunctions.Pow.Continuity\nimport Mathlib.Analysis.SpecialFunctions.Complex.LogDeriv\nimport Mathlib.Analysis.Calculus.FDeriv.Extend\nimport Mathlib.Analysis.Calculus.Deriv.Prod\nimport Mathlib.Analysis.SpecialFunctions.Log.Deriv\nimport Mathlib.Analysis.SpecialFunctions.Trigonometric.Deriv\n\n/-!\n# Derivatives of power function on `\u2102`, `\u211d`, `\u211d\u22650`, and `\u211d\u22650\u221e`\n\nWe also prove differentiability and provide derivatives for the power functions `x ^ y`.\n-/\n\n\nnoncomputable section\n\nopen scoped Real Topology NNReal ENNReal\nopen Filter\n\nnamespace Complex\n\ntheorem hasStrictFDerivAt_cpow {p : \u2102 \u00d7 \u2102} (hp : p.1 \u2208 slitPlane) :\n    HasStrictFDerivAt (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2)\n      ((p.2 * p.1 ^ (p.2 - 1)) \u2022 ContinuousLinearMap.fst \u2102 \u2102 \u2102 +\n        (p.1 ^ p.2 * log p.1) \u2022 ContinuousLinearMap.snd \u2102 \u2102 \u2102) p := by\n  have A : p.1 \u2260 0 := slitPlane_ne_zero hp\n  have : (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2) =\u1da0[\ud835\udcdd p] fun x => exp (log x.1 * x.2) :=\n    ((isOpen_ne.preimage continuous_fst).eventually_mem A).mono fun p hp =>\n      cpow_def_of_ne_zero hp _\n  rw [cpow_sub _ _ A, cpow_one, mul_div_left_comm, mul_smul, mul_smul]\n  refine HasStrictFDerivAt.congr_of_eventuallyEq ?_ this.symm\n  simpa only [cpow_def_of_ne_zero A, div_eq_mul_inv, mul_smul, add_comm, smul_add] using\n    ((hasStrictFDerivAt_fst.clog hp).mul hasStrictFDerivAt_snd).cexp\n\ntheorem hasStrictFDerivAt_cpow' {x y : \u2102} (hp : x \u2208 slitPlane) :\n    HasStrictFDerivAt (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2)\n      ((y * x ^ (y - 1)) \u2022 ContinuousLinearMap.fst \u2102 \u2102 \u2102 +\n        (x ^ y * log x) \u2022 ContinuousLinearMap.snd \u2102 \u2102 \u2102) (x, y) :=\n  @hasStrictFDerivAt_cpow (x, y) hp\n\ntheorem hasStrictDerivAt_const_cpow {x y : \u2102} (h : x \u2260 0 \u2228 y \u2260 0) :\n    HasStrictDerivAt (fun y => x ^ y) (x ^ y * log x) y := by\n  rcases em (x = 0) with (rfl | hx)\n  \u00b7 replace h := h.neg_resolve_left rfl\n    rw [log_zero, mul_zero]\n    refine (hasStrictDerivAt_const y 0).congr_of_eventuallyEq ?_\n    exact (isOpen_ne.eventually_mem h).mono fun y hy => (zero_cpow hy).symm\n  \u00b7 simpa only [cpow_def_of_ne_zero hx, mul_one] using\n      ((hasStrictDerivAt_id y).const_mul (log x)).cexp\n\ntheorem hasFDerivAt_cpow {p : \u2102 \u00d7 \u2102} (hp : p.1 \u2208 slitPlane) :\n    HasFDerivAt (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2)\n      ((p.2 * p.1 ^ (p.2 - 1)) \u2022 ContinuousLinearMap.fst \u2102 \u2102 \u2102 +\n        (p.1 ^ p.2 * log p.1) \u2022 ContinuousLinearMap.snd \u2102 \u2102 \u2102) p :=\n  (hasStrictFDerivAt_cpow hp).hasFDerivAt\n\nend Complex\n\nsection fderiv\n\nopen Complex\n\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f g : E \u2192 \u2102} {f' g' : E \u2192L[\u2102] \u2102}\n  {x : E} {s : Set E} {c : \u2102}\n\ntheorem HasStrictFDerivAt.cpow (hf : HasStrictFDerivAt f f' x) (hg : HasStrictFDerivAt g g' x)\n    (h0 : f x \u2208 slitPlane) : HasStrictFDerivAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) \u2022 f' + (f x ^ g x * Complex.log (f x)) \u2022 g') x := by\n  convert (@hasStrictFDerivAt_cpow ((fun x => (f x, g x)) x) h0).comp x (hf.prod hg)\n\ntheorem HasStrictFDerivAt.const_cpow (hf : HasStrictFDerivAt f f' x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasStrictFDerivAt (fun x => c ^ f x) ((c ^ f x * Complex.log c) \u2022 f') x :=\n  (hasStrictDerivAt_const_cpow h0).comp_hasStrictFDerivAt x hf\n\ntheorem HasFDerivAt.cpow (hf : HasFDerivAt f f' x) (hg : HasFDerivAt g g' x)\n    (h0 : f x \u2208 slitPlane) : HasFDerivAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) \u2022 f' + (f x ^ g x * Complex.log (f x)) \u2022 g') x := by\n  convert (@Complex.hasFDerivAt_cpow ((fun x => (f x, g x)) x) h0).comp x (hf.prod hg)\n\ntheorem HasFDerivAt.const_cpow (hf : HasFDerivAt f f' x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasFDerivAt (fun x => c ^ f x) ((c ^ f x * Complex.log c) \u2022 f') x :=\n  (hasStrictDerivAt_const_cpow h0).hasDerivAt.comp_hasFDerivAt x hf\n\ntheorem HasFDerivWithinAt.cpow (hf : HasFDerivWithinAt f f' s x) (hg : HasFDerivWithinAt g g' s x)\n    (h0 : f x \u2208 slitPlane) : HasFDerivWithinAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) \u2022 f' + (f x ^ g x * Complex.log (f x)) \u2022 g') s x := by\n  convert\n    (@Complex.hasFDerivAt_cpow ((fun x => (f x, g x)) x) h0).comp_hasFDerivWithinAt x (hf.prod hg)\n\ntheorem HasFDerivWithinAt.const_cpow (hf : HasFDerivWithinAt f f' s x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    HasFDerivWithinAt (fun x => c ^ f x) ((c ^ f x * Complex.log c) \u2022 f') s x :=\n  (hasStrictDerivAt_const_cpow h0).hasDerivAt.comp_hasFDerivWithinAt x hf\n\ntheorem DifferentiableAt.cpow (hf : DifferentiableAt \u2102 f x) (hg : DifferentiableAt \u2102 g x)\n    (h0 : f x \u2208 slitPlane) : DifferentiableAt \u2102 (fun x => f x ^ g x) x :=\n  (hf.hasFDerivAt.cpow hg.hasFDerivAt h0).differentiableAt\n\ntheorem DifferentiableAt.const_cpow (hf : DifferentiableAt \u2102 f x) (h0 : c \u2260 0 \u2228 f x \u2260 0) :\n    DifferentiableAt \u2102 (fun x => c ^ f x) x :=\n  (hf.hasFDerivAt.const_cpow h0).differentiableAt\n\ntheorem DifferentiableAt.cpow_const (hf : DifferentiableAt \u2102 f x) (h0 : f x \u2208 slitPlane) :\n    DifferentiableAt \u2102 (fun x => f x ^ c) x :=\n  hf.cpow (differentiableAt_const c) h0\n\ntheorem DifferentiableWithinAt.cpow (hf : DifferentiableWithinAt \u2102 f s x)\n    (hg : DifferentiableWithinAt \u2102 g s x) (h0 : f x \u2208 slitPlane) :\n    DifferentiableWithinAt \u2102 (fun x => f x ^ g x) s x :=\n  (hf.hasFDerivWithinAt.cpow hg.hasFDerivWithinAt h0).differentiableWithinAt\n\ntheorem DifferentiableWithinAt.const_cpow (hf : DifferentiableWithinAt \u2102 f s x)\n    (h0 : c \u2260 0 \u2228 f x \u2260 0) : DifferentiableWithinAt \u2102 (fun x => c ^ f x) s x :=\n  (hf.hasFDerivWithinAt.const_cpow h0).differentiableWithinAt\n\n", "theoremStatement": "theorem DifferentiableWithinAt.cpow_const (hf : DifferentiableWithinAt \u2102 f s x)\n    (h0 : f x \u2208 slitPlane) :\n    DifferentiableWithinAt \u2102 (fun x => f x ^ c) s x ", "theoremName": "DifferentiableWithinAt.cpow_const", "fileCreated": {"commit": "a9359cb30d5d2eb08c3c66959305c82fe45fab66", "date": "2023-06-06"}, "theoremCreated": {"commit": "006641492734e60b369ac830260c46c2dcdb7342", "date": "2025-01-20"}, "file": "mathlib/Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean", "module": "Mathlib.Analysis.SpecialFunctions.Pow.Deriv", "jsonFile": "Mathlib.Analysis.SpecialFunctions.Pow.Deriv.jsonl", "positionMetadata": {"lineInFile": 121, "tokenPositionInFile": 5613, "theoremPositionInFile": 15}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 30, "numPremises": 33}, "proofMetadata": {"hasProof": true, "proof": ":=\n  hf.cpow (differentiableWithinAt_const c) h0", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 48}}
{"srcContext": "/-\nCopyright (c) 2020 Aaron Anderson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Aaron Anderson\n-/\nimport Mathlib.Data.Set.Lattice\nimport Mathlib.Data.SetLike.Basic\nimport Mathlib.Order.ModularLattice\nimport Mathlib.Order.SuccPred.Basic\nimport Mathlib.Order.WellFounded\nimport Mathlib.Tactic.Nontriviality\nimport Mathlib.Order.ConditionallyCompleteLattice.Indexed\n\n/-!\n# Atoms, Coatoms, and Simple Lattices\n\nThis module defines atoms, which are minimal non-`\u22a5` elements in bounded lattices, simple lattices,\nwhich are lattices with only two elements, and related ideas.\n\n## Main definitions\n\n### Atoms and Coatoms\n  * `IsAtom a` indicates that the only element below `a` is `\u22a5`.\n  * `IsCoatom a` indicates that the only element above `a` is `\u22a4`.\n\n### Atomic and Atomistic Lattices\n  * `IsAtomic` indicates that every element other than `\u22a5` is above an atom.\n  * `IsCoatomic` indicates that every element other than `\u22a4` is below a coatom.\n  * `IsAtomistic` indicates that every element is the `sSup` of a set of atoms.\n  * `IsCoatomistic` indicates that every element is the `sInf` of a set of coatoms.\n  * `IsStronglyAtomic` indicates that for all `a < b`, there is some `x` with `a \u22d6 x \u2264 b`.\n  * `IsStronglyCoatomic` indicates that for all `a < b`, there is some `x` with `a \u2264 x \u22d6 b`.\n\n### Simple Lattices\n  * `IsSimpleOrder` indicates that an order has only two unique elements, `\u22a5` and `\u22a4`.\n  * `IsSimpleOrder.boundedOrder`\n  * `IsSimpleOrder.distribLattice`\n  * Given an instance of `IsSimpleOrder`, we provide the following definitions. These are not\n    made global instances as they contain data :\n    * `IsSimpleOrder.booleanAlgebra`\n    * `IsSimpleOrder.completeLattice`\n    * `IsSimpleOrder.completeBooleanAlgebra`\n\n## Main results\n  * `isAtom_dual_iff_isCoatom` and `isCoatom_dual_iff_isAtom` express the (definitional) duality\n   of `IsAtom` and `IsCoatom`.\n  * `isSimpleOrder_iff_isAtom_top` and `isSimpleOrder_iff_isCoatom_bot` express the\n  connection between atoms, coatoms, and simple lattices\n  * `IsCompl.isAtom_iff_isCoatom` and `IsCompl.isCoatom_if_isAtom`: In a modular\n  bounded lattice, a complement of an atom is a coatom and vice versa.\n  * `isAtomic_iff_isCoatomic`: A modular complemented lattice is atomic iff it is coatomic.\n\n-/\n\nvariable {\u03b9 : Sort*} {\u03b1 \u03b2 : Type*}\n\nsection Atoms\n\nsection IsAtom\n\nsection Preorder\n\nvariable [Preorder \u03b1] [OrderBot \u03b1] {a b x : \u03b1}\n\n/-- An atom of an `OrderBot` is an element with no other element between it and `\u22a5`,\n  which is not `\u22a5`. -/\ndef IsAtom (a : \u03b1) : Prop :=\n  a \u2260 \u22a5 \u2227 \u2200 b, b < a \u2192 b = \u22a5\n\ntheorem IsAtom.Iic (ha : IsAtom a) (hax : a \u2264 x) : IsAtom (\u27e8a, hax\u27e9 : Set.Iic x) :=\n  \u27e8fun con => ha.1 (Subtype.mk_eq_mk.1 con), fun \u27e8b, _\u27e9 hba => Subtype.mk_eq_mk.2 (ha.2 b hba)\u27e9\n\ntheorem IsAtom.of_isAtom_coe_Iic {a : Set.Iic x} (ha : IsAtom a) : IsAtom (a : \u03b1) :=\n  \u27e8fun con => ha.1 (Subtype.ext con), fun b hba =>\n    Subtype.mk_eq_mk.1 (ha.2 \u27e8b, hba.le.trans a.prop\u27e9 hba)\u27e9\n\ntheorem isAtom_iff_le_of_ge : IsAtom a \u2194 a \u2260 \u22a5 \u2227 \u2200 b \u2260 \u22a5, b \u2264 a \u2192 a \u2264 b :=\n  and_congr Iff.rfl <|\n    forall_congr' fun b => by\n      simp only [Ne, @not_imp_comm (b = \u22a5), Classical.not_imp, lt_iff_le_not_le]\n\nend Preorder\n\nsection PartialOrder\n\nvariable [PartialOrder \u03b1] [OrderBot \u03b1] {a b x : \u03b1}\n\ntheorem IsAtom.lt_iff (h : IsAtom a) : x < a \u2194 x = \u22a5 :=\n  \u27e8h.2 x, fun hx => hx.symm \u25b8 h.1.bot_lt\u27e9\n\ntheorem IsAtom.le_iff (h : IsAtom a) : x \u2264 a \u2194 x = \u22a5 \u2228 x = a := by rw [le_iff_lt_or_eq, h.lt_iff]\n\n", "theoremStatement": "lemma IsAtom.bot_lt (h : IsAtom a) : \u22a5 < a ", "theoremName": "IsAtom.bot_lt", "fileCreated": {"commit": "8618f40d51539454fe06511d5c8504a77f30c598", "date": "2022-12-30"}, "theoremCreated": {"commit": "f36aaf3682d93c2791bee76ef69613ff8c88f0fa", "date": "2025-01-02"}, "file": "mathlib/Mathlib/Order/Atoms.lean", "module": "Mathlib.Order.Atoms", "jsonFile": "Mathlib.Order.Atoms.jsonl", "positionMetadata": {"lineInFile": 93, "tokenPositionInFile": 3489, "theoremPositionInFile": 6}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 9, "numPremises": 13}, "proofMetadata": {"hasProof": true, "proof": ":=\n  h.lt_iff.mpr rfl", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 21}}
{"srcContext": "/-\nCopyright (c) 2020 Yakov Pechersky. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yakov Pechersky, Anthony DeRossi\n-/\nimport Mathlib.Data.List.Basic\n\n/-!\n# Properties of `List.reduceOption`\n\nIn this file we prove basic lemmas about `List.reduceOption`.\n-/\n\nnamespace List\n\nvariable {\u03b1 \u03b2 : Type*}\n\n@[simp]\ntheorem reduceOption_cons_of_some (x : \u03b1) (l : List (Option \u03b1)) :\n    reduceOption (some x :: l) = x :: l.reduceOption := by\n  simp only [reduceOption, filterMap, id, eq_self_iff_true, and_self_iff]\n\n@[simp]\ntheorem reduceOption_cons_of_none (l : List (Option \u03b1)) :\n    reduceOption (none :: l) = l.reduceOption := by simp only [reduceOption, filterMap, id]\n\n@[simp]\ntheorem reduceOption_nil : @reduceOption \u03b1 [] = [] :=\n  rfl\n\n@[simp]\ntheorem reduceOption_map {l : List (Option \u03b1)} {f : \u03b1 \u2192 \u03b2} :\n    reduceOption (map (Option.map f) l) = map f (reduceOption l) := by\n  induction' l with hd tl hl\n  \u00b7 simp only [reduceOption_nil, map_nil]\n  \u00b7 cases hd <;>\n      simpa [Option.map_some', map, eq_self_iff_true, reduceOption_cons_of_some] using hl\n\ntheorem reduceOption_append (l l' : List (Option \u03b1)) :\n    (l ++ l').reduceOption = l.reduceOption ++ l'.reduceOption :=\n  filterMap_append l l' id\n\n@[simp]\ntheorem reduceOption_replicate_none {n : \u2115} : (replicate n (@none \u03b1)).reduceOption = [] := by\n  dsimp [reduceOption]\n  rw [filterMap_replicate_of_none]\n  rfl\n\ntheorem reduceOption_eq_nil_iff (l : List (Option \u03b1)) :\n    l.reduceOption = [] \u2194 \u2203 n, l = replicate n none := by\n  dsimp [reduceOption]\n  rw [filterMap_eq_nil_iff]\n  constructor\n  \u00b7 intro h\n    exact \u27e8l.length, eq_replicate_of_mem h\u27e9\n  \u00b7 intro \u27e8_, h\u27e9\n    simp_rw [h, mem_replicate]\n    tauto\n\ntheorem reduceOption_eq_singleton_iff (l : List (Option \u03b1)) (a : \u03b1) :\n    l.reduceOption = [a] \u2194 \u2203 m n, l = replicate m none ++ some a :: replicate n none := by\n  dsimp [reduceOption]\n  constructor\n  \u00b7 intro h\n    rw [filterMap_eq_cons_iff] at h\n    obtain \u27e8l\u2081, _, l\u2082, h, hl\u2081, \u27e8\u27e9, hl\u2082\u27e9 := h\n    rw [filterMap_eq_nil_iff] at hl\u2082\n    apply eq_replicate_of_mem at hl\u2081\n    apply eq_replicate_of_mem at hl\u2082\n    rw [h, hl\u2081, hl\u2082]\n    use l\u2081.length, l\u2082.length\n  \u00b7 intro \u27e8_, _, h\u27e9\n    simp only [h, filterMap_append, filterMap_cons_some, filterMap_replicate_of_none, id_eq,\n      nil_append, Option.some.injEq]\n\ntheorem reduceOption_eq_append_iff (l : List (Option \u03b1)) (l'\u2081 l'\u2082 : List \u03b1) :\n    l.reduceOption = l'\u2081 ++ l'\u2082 \u2194\n      \u2203 l\u2081 l\u2082, l = l\u2081 ++ l\u2082 \u2227 l\u2081.reduceOption = l'\u2081 \u2227 l\u2082.reduceOption = l'\u2082 := by\n  dsimp [reduceOption]\n  constructor\n  \u00b7 intro h\n    rw [filterMap_eq_append_iff] at h\n    trivial\n  \u00b7 intro \u27e8_, _, h, hl\u2081, hl\u2082\u27e9\n    rw [h, filterMap_append, hl\u2081, hl\u2082]\n\n", "theoremStatement": "theorem reduceOption_eq_concat_iff (l : List (Option \u03b1)) (l' : List \u03b1) (a : \u03b1) :\n    l.reduceOption = l'.concat a \u2194\n      \u2203 l\u2081 l\u2082, l = l\u2081 ++ some a :: l\u2082 \u2227 l\u2081.reduceOption = l' \u2227 l\u2082.reduceOption = [] ", "theoremName": "List.reduceOption_eq_concat_iff", "fileCreated": {"commit": "5cc0a412b7d0d30421a2b126c6ebf629f735b59f", "date": "2024-03-26"}, "theoremCreated": {"commit": "c675cb586e7054488ba6962911a6e348356d8f33", "date": "2025-01-11"}, "file": "mathlib/Mathlib/Data/List/ReduceOption.lean", "module": "Mathlib.Data.List.ReduceOption", "jsonFile": "Mathlib.Data.List.ReduceOption.jsonl", "positionMetadata": {"lineInFile": 87, "tokenPositionInFile": 2683, "theoremPositionInFile": 9}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 5, "repositoryPremises": true, "numRepositoryPremises": 5, "numPremises": 42}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [concat_eq_append]\n  constructor\n  \u00b7 intro h\n    rw [reduceOption_eq_append_iff] at h\n    obtain \u27e8l\u2081, _, h, hl\u2081, hl\u2082\u27e9 := h\n    rw [reduceOption_eq_singleton_iff] at hl\u2082\n    obtain \u27e8m, n, hl\u2082\u27e9 := hl\u2082\n    use l\u2081 ++ replicate m none, replicate n none\n    simp_rw [h, reduceOption_append, reduceOption_replicate_none, append_assoc, append_nil, hl\u2081,\n      hl\u2082]\n    trivial\n  \u00b7 intro \u27e8_, _, h, hl\u2081, hl\u2082\u27e9\n    rw [h, reduceOption_append, reduceOption_cons_of_some, hl\u2081, hl\u2082]", "proofType": "tactic", "proofLengthLines": 13, "proofLengthTokens": 477}}
{"srcContext": "/-\nCopyright (c) 2020 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kevin Buzzard, Johan Commelin, Patrick Massot\n-/\nimport Mathlib.Algebra.Order.Hom.Monoid\nimport Mathlib.Algebra.Order.Ring.Basic\nimport Mathlib.RingTheory.Ideal.Maps\nimport Mathlib.Tactic.TFAE\n\n/-!\n\n# The basics of valuation theory.\n\nThe basic theory of valuations (non-archimedean norms) on a commutative ring,\nfollowing T. Wedhorn's unpublished notes \u201cAdic Spaces\u201d ([wedhorn_adic]).\n\nThe definition of a valuation we use here is Definition 1.22 of [wedhorn_adic].\nA valuation on a ring `R` is a monoid homomorphism `v` to a linearly ordered\ncommutative monoid with zero, that in addition satisfies the following two axioms:\n * `v 0 = 0`\n * `\u2200 x y, v (x + y) \u2264 max (v x) (v y)`\n\n`Valuation R \u0393\u2080`is the type of valuations `R \u2192 \u0393\u2080`, with a coercion to the underlying\nfunction. If `v` is a valuation from `R` to `\u0393\u2080` then the induced group\nhomomorphism `Units(R) \u2192 \u0393\u2080` is called `unit_map v`.\n\nThe equivalence \"relation\" `IsEquiv v\u2081 v\u2082 : Prop` defined in 1.27 of [wedhorn_adic] is not strictly\nspeaking a relation, because `v\u2081 : Valuation R \u0393\u2081` and `v\u2082 : Valuation R \u0393\u2082` might\nnot have the same type. This corresponds in ZFC to the set-theoretic difficulty\nthat the class of all valuations (as `\u0393\u2080` varies) on a ring `R` is not a set.\nThe \"relation\" is however reflexive, symmetric and transitive in the obvious\nsense. Note that we use 1.27(iii) of [wedhorn_adic] as the definition of equivalence.\n\n## Main definitions\n\n* `Valuation R \u0393\u2080`, the type of valuations on `R` with values in `\u0393\u2080`\n* `Valuation.IsEquiv`, the heterogeneous equivalence relation on valuations\n* `Valuation.supp`, the support of a valuation\n\n* `AddValuation R \u0393\u2080`, the type of additive valuations on `R` with values in a\n  linearly ordered additive commutative group with a top element, `\u0393\u2080`.\n\n## Implementation Details\n\n`AddValuation R \u0393\u2080` is implemented as `Valuation R (Multiplicative \u0393\u2080)\u1d52\u1d48`.\n\n## Notation\n\nIn the `DiscreteValuation` locale:\n\n * `\u2115\u2098\u2080` is a shorthand for `WithZero (Multiplicative \u2115)`\n * `\u2124\u2098\u2080` is a shorthand for `WithZero (Multiplicative \u2124)`\n\n## TODO\n\nIf ever someone extends `Valuation`, we should fully comply to the `DFunLike` by migrating the\nboilerplate lemmas to `ValuationClass`.\n-/\n\nopen Function Ideal\n\nnoncomputable section\n\nvariable {K F R : Type*} [DivisionRing K]\n\nsection\n\nvariable (F R) (\u0393\u2080 : Type*) [LinearOrderedCommMonoidWithZero \u0393\u2080] [Ring R]\n\n/-- The type of `\u0393\u2080`-valued valuations on `R`.\n\nWhen you extend this structure, make sure to extend `ValuationClass`. -/\nstructure Valuation extends R \u2192*\u2080 \u0393\u2080 where\n  /-- The valuation of a a sum is less that the sum of the valuations -/\n  map_add_le_max' : \u2200 x y, toFun (x + y) \u2264 max (toFun x) (toFun y)\n\n/-- `ValuationClass F \u03b1 \u03b2` states that `F` is a type of valuations.\n\nYou should also extend this typeclass when you extend `Valuation`. -/\nclass ValuationClass (F) (R \u0393\u2080 : outParam Type*) [LinearOrderedCommMonoidWithZero \u0393\u2080] [Ring R]\n  [FunLike F R \u0393\u2080]\n  extends MonoidWithZeroHomClass F R \u0393\u2080 : Prop where\n  /-- The valuation of a a sum is less that the sum of the valuations -/\n  map_add_le_max (f : F) (x y : R) : f (x + y) \u2264 max (f x) (f y)\n\nexport ValuationClass (map_add_le_max)\n\ninstance [FunLike F R \u0393\u2080] [ValuationClass F R \u0393\u2080] : CoeTC F (Valuation R \u0393\u2080) :=\n  \u27e8fun f =>\n    { toFun := f\n      map_one' := map_one f\n      map_zero' := map_zero f\n      map_mul' := map_mul f\n      map_add_le_max' := map_add_le_max f }\u27e9\n\nend\n\nnamespace Valuation\n\nvariable {\u0393\u2080 : Type*}\nvariable {\u0393'\u2080 : Type*}\nvariable {\u0393''\u2080 : Type*} [LinearOrderedCommMonoidWithZero \u0393''\u2080]\n\nsection Basic\n\nvariable [Ring R]\n\nsection Monoid\n\nvariable [LinearOrderedCommMonoidWithZero \u0393\u2080] [LinearOrderedCommMonoidWithZero \u0393'\u2080]\n\ninstance : FunLike (Valuation R \u0393\u2080) R \u0393\u2080 where\n  coe f := f.toFun\n  coe_injective' f g h := by\n    obtain \u27e8\u27e8\u27e8_,_\u27e9, _\u27e9, _\u27e9 := f\n    congr\n\ninstance : ValuationClass (Valuation R \u0393\u2080) R \u0393\u2080 where\n  map_mul f := f.map_mul'\n  map_one f := f.map_one'\n  map_zero f := f.map_zero'\n  map_add_le_max f := f.map_add_le_max'\n\n@[simp]\ntheorem coe_mk (f : R \u2192*\u2080 \u0393\u2080) (h) : \u21d1(Valuation.mk f h) = f := rfl\n\ntheorem toFun_eq_coe (v : Valuation R \u0393\u2080) : v.toFun = v := rfl\n\n@[simp]\ntheorem toMonoidWithZeroHom_coe_eq_coe (v : Valuation R \u0393\u2080) :\n    (v.toMonoidWithZeroHom : R \u2192 \u0393\u2080) = v := rfl\n\n@[ext]\ntheorem ext {v\u2081 v\u2082 : Valuation R \u0393\u2080} (h : \u2200 r, v\u2081 r = v\u2082 r) : v\u2081 = v\u2082 :=\n  DFunLike.ext _ _ h\n\nvariable (v : Valuation R \u0393\u2080)\n\n@[simp, norm_cast]\ntheorem coe_coe : \u21d1(v : R \u2192*\u2080 \u0393\u2080) = v := rfl\n\ntheorem map_zero : v 0 = 0 :=\n  v.map_zero'\n\ntheorem map_one : v 1 = 1 :=\n  v.map_one'\n\ntheorem map_mul : \u2200 x y, v (x * y) = v x * v y :=\n  v.map_mul'\n\n-- Porting note: LHS side simplified so created map_add'\ntheorem map_add : \u2200 x y, v (x + y) \u2264 max (v x) (v y) :=\n  v.map_add_le_max'\n\n@[simp]\ntheorem map_add' : \u2200 x y, v (x + y) \u2264 v x \u2228 v (x + y) \u2264 v y := by\n  intro x y\n  rw [\u2190 le_max_iff, \u2190 ge_iff_le]\n  apply map_add\n\ntheorem map_add_le {x y g} (hx : v x \u2264 g) (hy : v y \u2264 g) : v (x + y) \u2264 g :=\n  le_trans (v.map_add x y) <| max_le hx hy\n\ntheorem map_add_lt {x y g} (hx : v x < g) (hy : v y < g) : v (x + y) < g :=\n  lt_of_le_of_lt (v.map_add x y) <| max_lt hx hy\n\ntheorem map_sum_le {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hf : \u2200 i \u2208 s, v (f i) \u2264 g) :\n    v (\u2211 i \u2208 s, f i) \u2264 g := by\n  classical\n  refine\n    Finset.induction_on s (fun _ => v.map_zero \u25b8 zero_le')\n      (fun a s has ih hf => ?_) hf\n  rw [Finset.forall_mem_insert] at hf; rw [Finset.sum_insert has]\n  exact v.map_add_le hf.1 (ih hf.2)\n\ntheorem map_sum_lt {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hg : g \u2260 0)\n    (hf : \u2200 i \u2208 s, v (f i) < g) : v (\u2211 i \u2208 s, f i) < g := by\n  classical\n  refine\n    Finset.induction_on s (fun _ => v.map_zero \u25b8 (zero_lt_iff.2 hg))\n      (fun a s has ih hf => ?_) hf\n  rw [Finset.forall_mem_insert] at hf; rw [Finset.sum_insert has]\n  exact v.map_add_lt hf.1 (ih hf.2)\n\ntheorem map_sum_lt' {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hg : 0 < g)\n    (hf : \u2200 i \u2208 s, v (f i) < g) : v (\u2211 i \u2208 s, f i) < g :=\n  v.map_sum_lt (ne_of_gt hg) hf\n\ntheorem map_pow : \u2200 (x) (n : \u2115), v (x ^ n) = v x ^ n :=\n  v.toMonoidWithZeroHom.toMonoidHom.map_pow\n\n-- The following definition is not an instance, because we have more than one `v` on a given `R`.\n-- In addition, type class inference would not be able to infer `v`.\n/-- A valuation gives a preorder on the underlying ring. -/\ndef toPreorder : Preorder R :=\n  Preorder.lift v\n\n/-- If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. -/\ntheorem zero_iff [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) {x : K} : v x = 0 \u2194 x = 0 :=\n  map_eq_zero v\n\ntheorem ne_zero_iff [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) {x : K} : v x \u2260 0 \u2194 x \u2260 0 :=\n  map_ne_zero v\n\nlemma pos_iff [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) {x : K} : 0 < v x \u2194 x \u2260 0 := by\n  rw [zero_lt_iff, ne_zero_iff]\n\ntheorem unit_map_eq (u : R\u02e3) : (Units.map (v : R \u2192* \u0393\u2080) u : \u0393\u2080) = v u :=\n  rfl\n\ntheorem ne_zero_of_unit [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) (x : K\u02e3) : v x \u2260 (0 : \u0393\u2080) := by\n  simp only [ne_eq, Valuation.zero_iff, Units.ne_zero x, not_false_iff]\n\ntheorem ne_zero_of_isUnit [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) (x : K) (hx : IsUnit x) :\n    v x \u2260 (0 : \u0393\u2080) := by\n  simpa [hx.choose_spec] using ne_zero_of_unit v hx.choose\n\n/-- A ring homomorphism `S \u2192 R` induces a map `Valuation R \u0393\u2080 \u2192 Valuation S \u0393\u2080`. -/\ndef comap {S : Type*} [Ring S] (f : S \u2192+* R) (v : Valuation R \u0393\u2080) : Valuation S \u0393\u2080 :=\n  { v.toMonoidWithZeroHom.comp f.toMonoidWithZeroHom with\n    toFun := v \u2218 f\n    map_add_le_max' := fun x y => by simp only [comp_apply, map_add, f.map_add] }\n\n@[simp]\ntheorem comap_apply {S : Type*} [Ring S] (f : S \u2192+* R) (v : Valuation R \u0393\u2080) (s : S) :\n    v.comap f s = v (f s) := rfl\n\n@[simp]\ntheorem comap_id : v.comap (RingHom.id R) = v :=\n  ext fun _r => rfl\n\ntheorem comap_comp {S\u2081 : Type*} {S\u2082 : Type*} [Ring S\u2081] [Ring S\u2082] (f : S\u2081 \u2192+* S\u2082) (g : S\u2082 \u2192+* R) :\n    v.comap (g.comp f) = (v.comap g).comap f :=\n  ext fun _r => rfl\n\n/-- A `\u2264`-preserving group homomorphism `\u0393\u2080 \u2192 \u0393'\u2080` induces a map `Valuation R \u0393\u2080 \u2192 Valuation R \u0393'\u2080`.\n-/\ndef map (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080) (hf : Monotone f) (v : Valuation R \u0393\u2080) : Valuation R \u0393'\u2080 :=\n  { MonoidWithZeroHom.comp f v.toMonoidWithZeroHom with\n    toFun := f \u2218 v\n    map_add_le_max' := fun r s =>\n      calc\n        f (v (r + s)) \u2264 f (max (v r) (v s)) := hf (v.map_add r s)\n        _ = max (f (v r)) (f (v s)) := hf.map_max\n         }\n\n@[simp]\nlemma map_apply (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080) (hf : Monotone f) (v : Valuation R \u0393\u2080) (r : R) :\n    v.map f hf r = f (v r) := rfl\n\n/-- Two valuations on `R` are defined to be equivalent if they induce the same preorder on `R`. -/\ndef IsEquiv (v\u2081 : Valuation R \u0393\u2080) (v\u2082 : Valuation R \u0393'\u2080) : Prop :=\n  \u2200 r s, v\u2081 r \u2264 v\u2081 s \u2194 v\u2082 r \u2264 v\u2082 s\n\n@[simp]\ntheorem map_neg (x : R) : v (-x) = v x :=\n  v.toMonoidWithZeroHom.toMonoidHom.map_neg x\n\ntheorem map_sub_swap (x y : R) : v (x - y) = v (y - x) :=\n  v.toMonoidWithZeroHom.toMonoidHom.map_sub_swap x y\n\ntheorem map_sub (x y : R) : v (x - y) \u2264 max (v x) (v y) :=\n  calc\n    v (x - y) = v (x + -y) := by rw [sub_eq_add_neg]\n    _ \u2264 max (v x) (v <| -y) := v.map_add _ _\n    _ = max (v x) (v y) := by rw [map_neg]\n\ntheorem map_sub_le {x y g} (hx : v x \u2264 g) (hy : v y \u2264 g) : v (x - y) \u2264 g := by\n  rw [sub_eq_add_neg]\n  exact v.map_add_le hx (le_trans (le_of_eq (v.map_neg y)) hy)\n\nvariable {x y : R}\n\ntheorem map_add_of_distinct_val (h : v x \u2260 v y) : v (x + y) = max (v x) (v y) := by\n  suffices \u00acv (x + y) < max (v x) (v y) from\n    or_iff_not_imp_right.1 (le_iff_eq_or_lt.1 (v.map_add x y)) this\n  intro h'\n  wlog vyx : v y < v x generalizing x y\n  \u00b7 refine this h.symm ?_ (h.lt_or_lt.resolve_right vyx)\n    rwa [add_comm, max_comm]\n  rw [max_eq_left_of_lt vyx] at h'\n  apply lt_irrefl (v x)\n  calc\n    v x = v (x + y - y) := by simp\n    _ \u2264 max (v <| x + y) (v y) := map_sub _ _ _\n    _ < v x := max_lt h' vyx\n\ntheorem map_add_eq_of_lt_right (h : v x < v y) : v (x + y) = v y :=\n  (v.map_add_of_distinct_val h.ne).trans (max_eq_right_iff.mpr h.le)\n\ntheorem map_add_eq_of_lt_left (h : v y < v x) : v (x + y) = v x := by\n  rw [add_comm]; exact map_add_eq_of_lt_right _ h\n\ntheorem map_sub_eq_of_lt_right (h : v x < v y) : v (x - y) = v y := by\n  rw [sub_eq_add_neg, map_add_eq_of_lt_right, map_neg]\n  rwa [map_neg]\n\nopen scoped Classical in\ntheorem map_sum_eq_of_lt {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {j : \u03b9}\n    (hj : j \u2208 s) (h0 : v (f j) \u2260 0) (hf : \u2200 i \u2208 s \\ {j}, v (f i) < v (f j)) :\n    v (\u2211 i \u2208 s, f i) = v (f j) := by\n  rw [Finset.sum_eq_add_sum_diff_singleton hj]\n  exact map_add_eq_of_lt_left _ (map_sum_lt _ h0 hf)\n\ntheorem map_sub_eq_of_lt_left (h : v y < v x) : v (x - y) = v x := by\n  rw [sub_eq_add_neg, map_add_eq_of_lt_left]\n  rwa [map_neg]\n\ntheorem map_eq_of_sub_lt (h : v (y - x) < v x) : v y = v x := by\n  have := Valuation.map_add_of_distinct_val v (ne_of_gt h).symm\n  rw [max_eq_right (le_of_lt h)] at this\n  simpa using this\n\ntheorem map_one_add_of_lt (h : v x < 1) : v (1 + x) = 1 := by\n  rw [\u2190 v.map_one] at h\n  simpa only [v.map_one] using v.map_add_eq_of_lt_left h\n\ntheorem map_one_sub_of_lt (h : v x < 1) : v (1 - x) = 1 := by\n  rw [\u2190 v.map_one, \u2190 v.map_neg] at h\n  rw [sub_eq_add_neg 1 x]\n  simpa only [v.map_one, v.map_neg] using v.map_add_eq_of_lt_left h\n\n/-- An ordered monoid isomorphism `\u0393\u2080 \u2243 \u0393'\u2080` induces an equivalence\n`Valuation R \u0393\u2080 \u2243 Valuation R \u0393'\u2080`. -/\ndef congr (f : \u0393\u2080 \u2243*o \u0393'\u2080) : Valuation R \u0393\u2080 \u2243 Valuation R \u0393'\u2080 where\n  toFun := map f f.toOrderIso.monotone\n  invFun := map f.symm f.toOrderIso.symm.monotone\n  left_inv \u03bd := by ext; simp\n  right_inv \u03bd := by ext; simp\n\nend Monoid\n\nsection Group\n\nvariable [LinearOrderedCommGroupWithZero \u0393\u2080] (v : Valuation R \u0393\u2080) {x y : R}\n\ntheorem map_inv {R : Type*} [DivisionRing R] (v : Valuation R \u0393\u2080) : \u2200 x, v x\u207b\u00b9 = (v x)\u207b\u00b9 :=\n  map_inv\u2080 _\n\ntheorem map_div {R : Type*} [DivisionRing R] (v : Valuation R \u0393\u2080) : \u2200 x y, v (x / y) = v x / v y :=\n  map_div\u2080 _\n\ntheorem one_lt_val_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : 1 < v x \u2194 v x\u207b\u00b9 < 1 := by\n  simp [inv_lt_one\u2080 (v.pos_iff.2 h)]\n\ntheorem one_le_val_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : 1 \u2264 v x \u2194 v x\u207b\u00b9 \u2264 1 := by\n  simp [inv_le_one\u2080 (v.pos_iff.2 h)]\n\ntheorem val_lt_one_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : v x < 1 \u2194 1 < v x\u207b\u00b9 := by\n  simp [one_lt_inv\u2080 (v.pos_iff.2 h)]\n\ntheorem val_le_one_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : v x \u2264 1 \u2194 1 \u2264 v x\u207b\u00b9 := by\n  simp [one_le_inv\u2080 (v.pos_iff.2 h)]\n\ntheorem val_eq_one_iff (v : Valuation K \u0393\u2080) {x : K} : v x = 1 \u2194 v x\u207b\u00b9 = 1 := by\n  by_cases h : x = 0\n  \u00b7 simp only [map_inv\u2080, inv_eq_one]\n  \u00b7 simpa only [le_antisymm_iff, And.comm] using and_congr (one_le_val_iff v h) (val_le_one_iff v h)\n\ntheorem val_le_one_or_val_inv_lt_one (v : Valuation K \u0393\u2080) (x : K) : v x \u2264 1 \u2228 v x\u207b\u00b9 < 1 := by\n  by_cases h : x = 0\n  \u00b7 simp only [h, _root_.map_zero, zero_le', inv_zero, zero_lt_one, or_self]\n  \u00b7 simp only [\u2190 one_lt_val_iff v h, le_or_lt]\n\n/--\nThis theorem is a weaker version of `Valuation.val_le_one_or_val_inv_lt_one`, but more symmetric\nin `x` and `x\u207b\u00b9`.\n-/\ntheorem val_le_one_or_val_inv_le_one (v : Valuation K \u0393\u2080) (x : K) : v x \u2264 1 \u2228 v x\u207b\u00b9 \u2264 1 := by\n  by_cases h : x = 0\n  \u00b7 simp only [h, _root_.map_zero, zero_le', inv_zero, or_self]\n  \u00b7 simp only [\u2190 one_le_val_iff v h, le_total]\n\n/-- The subgroup of elements whose valuation is less than a certain unit. -/\ndef ltAddSubgroup (v : Valuation R \u0393\u2080) (\u03b3 : \u0393\u2080\u02e3) : AddSubgroup R where\n  carrier := { x | v x < \u03b3 }\n  zero_mem' := by simp\n  add_mem' {x y} x_in y_in := lt_of_le_of_lt (v.map_add x y) (max_lt x_in y_in)\n  neg_mem' x_in := by rwa [Set.mem_setOf, map_neg]\n\nend Group\n\nend Basic\n\n-- end of section\nnamespace IsEquiv\n\nvariable [Ring R] [LinearOrderedCommMonoidWithZero \u0393\u2080] [LinearOrderedCommMonoidWithZero \u0393'\u2080]\n  {v : Valuation R \u0393\u2080} {v\u2081 : Valuation R \u0393\u2080} {v\u2082 : Valuation R \u0393'\u2080} {v\u2083 : Valuation R \u0393''\u2080}\n\n@[refl]\ntheorem refl : v.IsEquiv v := fun _ _ => Iff.refl _\n\n@[symm]\ntheorem symm (h : v\u2081.IsEquiv v\u2082) : v\u2082.IsEquiv v\u2081 := fun _ _ => Iff.symm (h _ _)\n\n@[trans]\ntheorem trans (h\u2081\u2082 : v\u2081.IsEquiv v\u2082) (h\u2082\u2083 : v\u2082.IsEquiv v\u2083) : v\u2081.IsEquiv v\u2083 := fun _ _ =>\n  Iff.trans (h\u2081\u2082 _ _) (h\u2082\u2083 _ _)\n\ntheorem of_eq {v' : Valuation R \u0393\u2080} (h : v = v') : v.IsEquiv v' := by subst h; rfl\n\ntheorem map {v' : Valuation R \u0393\u2080} (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080) (hf : Monotone f) (inf : Injective f)\n    (h : v.IsEquiv v') : (v.map f hf).IsEquiv (v'.map f hf) :=\n  let H : StrictMono f := hf.strictMono_of_injective inf\n  fun r s =>\n  calc\n    f (v r) \u2264 f (v s) \u2194 v r \u2264 v s := by rw [H.le_iff_le]\n    _ \u2194 v' r \u2264 v' s := h r s\n    _ \u2194 f (v' r) \u2264 f (v' s) := by rw [H.le_iff_le]\n\n/-- `comap` preserves equivalence. -/\ntheorem comap {S : Type*} [Ring S] (f : S \u2192+* R) (h : v\u2081.IsEquiv v\u2082) :\n    (v\u2081.comap f).IsEquiv (v\u2082.comap f) := fun r s => h (f r) (f s)\n\ntheorem val_eq (h : v\u2081.IsEquiv v\u2082) {r s : R} : v\u2081 r = v\u2081 s \u2194 v\u2082 r = v\u2082 s := by\n  simpa only [le_antisymm_iff] using and_congr (h r s) (h s r)\n\ntheorem ne_zero (h : v\u2081.IsEquiv v\u2082) {r : R} : v\u2081 r \u2260 0 \u2194 v\u2082 r \u2260 0 := by\n  have : v\u2081 r \u2260 v\u2081 0 \u2194 v\u2082 r \u2260 v\u2082 0 := not_congr h.val_eq\n  rwa [v\u2081.map_zero, v\u2082.map_zero] at this\n\nend IsEquiv\n\n-- end of namespace\nsection\n\ntheorem isEquiv_of_map_strictMono [LinearOrderedCommMonoidWithZero \u0393\u2080]\n    [LinearOrderedCommMonoidWithZero \u0393'\u2080] [Ring R] {v : Valuation R \u0393\u2080} (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080)\n    (H : StrictMono f) : IsEquiv (v.map f H.monotone) v := fun _x _y =>\n  \u27e8H.le_iff_le.mp, fun h => H.monotone h\u27e9\n\ntheorem isEquiv_iff_val_lt_val [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x y : K}, v x < v y \u2194 v' x < v' y := by\n  simp only [IsEquiv, le_iff_le_iff_lt_iff_lt]\n  exact forall_comm\n\nalias \u27e8IsEquiv.lt_iff_lt, _\u27e9 := isEquiv_iff_val_lt_val\n\ntheorem isEquiv_of_val_le_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080}\n    (h : \u2200 {x : K}, v x \u2264 1 \u2194 v' x \u2264 1) : v.IsEquiv v' := by\n  intro x y\n  obtain rfl | hy := eq_or_ne y 0\n  \u00b7 simp\n  \u00b7 rw [\u2190 div_le_one\u2080, \u2190 v.map_div, h, v'.map_div, div_le_one\u2080] <;>\n      rwa [zero_lt_iff, ne_zero_iff]\n\ntheorem isEquiv_iff_val_le_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v x \u2264 1 \u2194 v' x \u2264 1 :=\n  \u27e8fun h x => by simpa using h x 1, isEquiv_of_val_le_one\u27e9\n\nalias \u27e8IsEquiv.le_one_iff_le_one, _\u27e9 := isEquiv_iff_val_le_one\n\ntheorem isEquiv_iff_val_eq_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v x = 1 \u2194 v' x = 1 := by\n  constructor\n  \u00b7 intro h x\n    simpa using @IsEquiv.val_eq _ _ _ _ _ _ v v' h x 1\n  \u00b7 intro h\n    apply isEquiv_of_val_le_one\n    intro x\n    constructor\n    \u00b7 intro hx\n      rcases lt_or_eq_of_le hx with hx' | hx'\n      \u00b7 have : v (1 + x) = 1 := by\n          rw [\u2190 v.map_one]\n          apply map_add_eq_of_lt_left\n          simpa\n        rw [h] at this\n        rw [show x = -1 + (1 + x) by simp]\n        refine le_trans (v'.map_add _ _) ?_\n        simp [this]\n      \u00b7 rw [h] at hx'\n        exact le_of_eq hx'\n    \u00b7 intro hx\n      rcases lt_or_eq_of_le hx with hx' | hx'\n      \u00b7 have : v' (1 + x) = 1 := by\n          rw [\u2190 v'.map_one]\n          apply map_add_eq_of_lt_left\n          simpa\n        rw [\u2190 h] at this\n        rw [show x = -1 + (1 + x) by simp]\n        refine le_trans (v.map_add _ _) ?_\n        simp [this]\n      \u00b7 rw [\u2190 h] at hx'\n        exact le_of_eq hx'\n\nalias \u27e8IsEquiv.eq_one_iff_eq_one, _\u27e9 := isEquiv_iff_val_eq_one\n\ntheorem isEquiv_iff_val_lt_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v x < 1 \u2194 v' x < 1 := by\n  constructor\n  \u00b7 intro h x\n    simp only [lt_iff_le_and_ne,\n      and_congr h.le_one_iff_le_one h.eq_one_iff_eq_one.not]\n  \u00b7 rw [isEquiv_iff_val_eq_one]\n    intro h x\n    by_cases hx : x = 0\n    \u00b7 simp only [(zero_iff _).2 hx, zero_ne_one]\n    constructor\n    \u00b7 intro hh\n      by_contra h_1\n      cases ne_iff_lt_or_gt.1 h_1 with\n      | inl h_2 => simpa [hh, lt_self_iff_false] using h.2 h_2\n      | inr h_2 =>\n          rw [\u2190 inv_one, \u2190 inv_eq_iff_eq_inv, \u2190 map_inv\u2080] at hh\n          exact hh.not_lt (h.2 ((one_lt_val_iff v' hx).1 h_2))\n    \u00b7 intro hh\n      by_contra h_1\n      cases ne_iff_lt_or_gt.1 h_1 with\n      | inl h_2 => simpa [hh, lt_self_iff_false] using h.1 h_2\n      | inr h_2 =>\n        rw [\u2190 inv_one, \u2190 inv_eq_iff_eq_inv, \u2190 map_inv\u2080] at hh\n        exact hh.not_lt (h.1 ((one_lt_val_iff v hx).1 h_2))\n\nalias \u27e8IsEquiv.lt_one_iff_lt_one, _\u27e9 := isEquiv_iff_val_lt_one\n\ntheorem isEquiv_iff_val_sub_one_lt_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] {v : Valuation K \u0393\u2080} {v' : Valuation K \u0393'\u2080} :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v (x - 1) < 1 \u2194 v' (x - 1) < 1 := by\n  rw [isEquiv_iff_val_lt_one]\n  exact (Equiv.subRight 1).surjective.forall\n\nalias \u27e8IsEquiv.val_sub_one_lt_one_iff, _\u27e9 := isEquiv_iff_val_sub_one_lt_one\n\ntheorem isEquiv_tfae [LinearOrderedCommGroupWithZero \u0393\u2080] [LinearOrderedCommGroupWithZero \u0393'\u2080]\n    (v : Valuation K \u0393\u2080) (v' : Valuation K \u0393'\u2080) :\n    [ v.IsEquiv v',\n      \u2200 {x y}, v x < v y \u2194 v' x < v' y,\n      \u2200 {x}, v x \u2264 1 \u2194 v' x \u2264 1,\n      \u2200 {x}, v x = 1 \u2194 v' x = 1,\n      \u2200 {x}, v x < 1 \u2194 v' x < 1,\n      \u2200 {x}, v (x - 1) < 1 \u2194 v' (x - 1) < 1 ].TFAE := by\n  tfae_have 1 \u2194 2 := isEquiv_iff_val_lt_val\n  tfae_have 1 \u2194 3 := isEquiv_iff_val_le_one\n  tfae_have 1 \u2194 4 := isEquiv_iff_val_eq_one\n  tfae_have 1 \u2194 5 := isEquiv_iff_val_lt_one\n  tfae_have 1 \u2194 6 := isEquiv_iff_val_sub_one_lt_one\n  tfae_finish\n\nend\n\nsection Supp\n\nvariable [CommRing R] [LinearOrderedCommMonoidWithZero \u0393\u2080] (v : Valuation R \u0393\u2080)\n\n/-- The support of a valuation `v : R \u2192 \u0393\u2080` is the ideal of `R` where `v` vanishes. -/\ndef supp : Ideal R where\n  carrier := { x | v x = 0 }\n  zero_mem' := map_zero v\n  add_mem' {x y} hx hy := le_zero_iff.mp <|\n    calc\n      v (x + y) \u2264 max (v x) (v y) := v.map_add x y\n      _ \u2264 0 := max_le (le_zero_iff.mpr hx) (le_zero_iff.mpr hy)\n  smul_mem' c x hx :=\n    calc\n      v (c * x) = v c * v x := map_mul v c x\n      _ = v c * 0 := congr_arg _ hx\n      _ = 0 := mul_zero _\n\n@[simp]\ntheorem mem_supp_iff (x : R) : x \u2208 supp v \u2194 v x = 0 :=\n  Iff.rfl\n\n/-- The support of a valuation is a prime ideal. -/\ninstance [Nontrivial \u0393\u2080] [NoZeroDivisors \u0393\u2080] : Ideal.IsPrime (supp v) :=\n  \u27e8fun h =>\n    one_ne_zero (\u03b1 := \u0393\u2080) <|\n      calc\n        1 = v 1 := v.map_one.symm\n        _ = 0 := by rw [\u2190 mem_supp_iff, h]; exact Submodule.mem_top,\n   fun {x y} hxy => by\n    simp only [mem_supp_iff] at hxy \u22a2\n    rw [v.map_mul x y] at hxy\n    exact eq_zero_or_eq_zero_of_mul_eq_zero hxy\u27e9\n\ntheorem map_add_supp (a : R) {s : R} (h : s \u2208 supp v) : v (a + s) = v a := by\n  have aux : \u2200 a s, v s = 0 \u2192 v (a + s) \u2264 v a := by\n    intro a' s' h'\n    refine le_trans (v.map_add a' s') (max_le le_rfl ?_)\n    simp [h']\n  apply le_antisymm (aux a s h)\n  calc\n    v a = v (a + s + -s) := by simp\n    _ \u2264 v (a + s) := aux (a + s) (-s) (by rwa [\u2190 Ideal.neg_mem_iff] at h)\n\ntheorem comap_supp {S : Type*} [CommRing S] (f : S \u2192+* R) :\n    supp (v.comap f) = Ideal.comap f v.supp :=\n  Ideal.ext fun x => by rw [mem_supp_iff, Ideal.mem_comap, mem_supp_iff, comap_apply]\n\nend Supp\n\n-- end of section\nend Valuation\n\nsection AddMonoid\n\nvariable (R) [Ring R] (\u0393\u2080 : Type*) [LinearOrderedAddCommMonoidWithTop \u0393\u2080]\n\n/-- The type of `\u0393\u2080`-valued additive valuations on `R`. -/\ndef AddValuation :=\n  Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48)\n\nend AddMonoid\n\nnamespace AddValuation\n\nvariable {\u0393\u2080 : Type*} {\u0393'\u2080 : Type*}\n\nsection Basic\n\nsection Monoid\n\n/-- A valuation is coerced to the underlying function `R \u2192 \u0393\u2080`. -/\ninstance (R) (\u0393\u2080) [Ring R] [LinearOrderedAddCommMonoidWithTop \u0393\u2080] :\n    FunLike (AddValuation R \u0393\u2080) R \u0393\u2080 where\n  coe v := v.toMonoidWithZeroHom.toFun\n  coe_injective' f g := by cases f; cases g; simp (config := {contextual := true})\n\nvariable [Ring R] [LinearOrderedAddCommMonoidWithTop \u0393\u2080] [LinearOrderedAddCommMonoidWithTop \u0393'\u2080]\n  (v : AddValuation R \u0393\u2080)\n\nsection\n\nvariable (f : R \u2192 \u0393\u2080) (h0 : f 0 = \u22a4) (h1 : f 1 = 0)\nvariable (hadd : \u2200 x y, min (f x) (f y) \u2264 f (x + y)) (hmul : \u2200 x y, f (x * y) = f x + f y)\n\n/-- An alternate constructor of `AddValuation`, that doesn't reference `Multiplicative \u0393\u2080\u1d52\u1d48` -/\ndef of : AddValuation R \u0393\u2080 where\n  toFun := f\n  map_one' := h1\n  map_zero' := h0\n  map_add_le_max' := hadd\n  map_mul' := hmul\n\nvariable {h0} {h1} {hadd} {hmul} {r : R}\n\n@[simp]\ntheorem of_apply : (of f h0 h1 hadd hmul) r = f r := rfl\n\n/-- The `Valuation` associated to an `AddValuation` (useful if the latter is constructed using\n`AddValuation.of`). -/\ndef toValuation : AddValuation R \u0393\u2080 \u2243 Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48) :=\n  Equiv.refl _\n\n@[deprecated (since := \"2024-11-09\")]\nalias valuation := toValuation\n\n/-- The `AddValuation` associated to a `Valuation`.\n-/\ndef ofValuation : Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48) \u2243 AddValuation R \u0393\u2080 :=\n  Equiv.refl _\n\n@[simp]\nlemma ofValuation_symm_eq : ofValuation.symm = toValuation (R := R) (\u0393\u2080 := \u0393\u2080) := rfl\n\n@[simp]\nlemma toValuation_symm_eq : toValuation.symm = ofValuation (R := R) (\u0393\u2080 := \u0393\u2080) := rfl\n\n@[simp]\nlemma ofValuation_toValuation : ofValuation (toValuation v) = v := rfl\n\n@[simp]\nlemma toValuation_ofValuation (v : Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48)) :\n    toValuation (ofValuation v) = v := rfl\n\n@[simp]\ntheorem toValuation_apply (r : R) :\n    toValuation v r = Multiplicative.ofAdd (OrderDual.toDual (v r)) :=\n  rfl\n\n@[deprecated (since := \"2024-11-09\")]\nalias valuation_apply := toValuation_apply\n\n", "theoremStatement": "@[simp]\ntheorem ofValuation_apply (v : Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48)) (r : R) :\n    ofValuation v r = OrderDual.ofDual (Multiplicative.toAdd (v r)) ", "theoremName": "AddValuation.ofValuation_apply", "fileCreated": {"commit": "a9138cdba12f2110c86195f5eac26cb36dee2627", "date": "2023-03-17"}, "theoremCreated": {"commit": "625ac34a53dfa0eca4fb8a3a933409238e4f43f0", "date": "2024-12-16"}, "file": "mathlib/Mathlib/RingTheory/Valuation/Basic.lean", "module": "Mathlib.RingTheory.Valuation.Basic", "jsonFile": "Mathlib.RingTheory.Valuation.Basic.jsonl", "positionMetadata": {"lineInFile": 681, "tokenPositionInFile": 23568, "theoremPositionInFile": 80}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 5, "repositoryPremises": true, "numRepositoryPremises": 15, "numPremises": 17}, "proofMetadata": {"hasProof": true, "proof": ":=\n  rfl", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 8}}
{"srcContext": "/-\nCopyright (c) 2023 Jujian Zhang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jujian Zhang, Junyan Xu\n-/\n\nimport Mathlib.Algebra.Category.ModuleCat.Basic\nimport Mathlib.Algebra.Category.Grp.Injective\nimport Mathlib.Topology.Instances.AddCircle\nimport Mathlib.LinearAlgebra.Isomorphisms\n\n/-!\n# Character module of a module\n\nFor commutative ring `R` and an `R`-module `M` and an injective module `D`, its character module\n`M\u22c6` is defined to be `R`-linear maps `M \u27f6 D`.\n\n`M\u22c6` also has an `R`-module structure given by `(r \u2022 f) m = f (r \u2022 m)`.\n\n## Main results\n\n- `CharacterModuleFunctor` : the contravariant functor of `R`-modules where `M \u21a6 M\u22c6` and\nan `R`-linear map `l : M \u27f6 N` induces an `R`-linear map `l\u22c6 : f \u21a6 f \u2218 l` where `f : N\u22c6`.\n- `LinearMap.dual_surjective_of_injective` : If `l` is injective then `l\u22c6` is surjective,\n  in another word taking character module as a functor sends monos to epis.\n- `CharacterModule.homEquiv` : there is a bijection between linear map `Hom(N, M\u22c6)` and\n  `(N \u2297 M)\u22c6` given by `curry` and `uncurry`.\n\n-/\n\nopen CategoryTheory\n\nuniverse uR uA uB\n\nvariable (R : Type uR) [CommRing R]\nvariable (A : Type uA) [AddCommGroup A]\nvariable (A' : Type*) [AddCommGroup A']\nvariable (B : Type uB) [AddCommGroup B]\n\n/--\nThe character module of an abelian group `A` in the unit rational circle is `A\u22c6 := Hom_\u2124(A, \u211a \u29f8 \u2124)`.\n-/\ndef CharacterModule : Type uA := A \u2192+ AddCircle (1 : \u211a)\n\nnamespace CharacterModule\n\ninstance : FunLike (CharacterModule A) A (AddCircle (1 : \u211a)) where\n  coe c := c.toFun\n  coe_injective' _ _ _ := by aesop\n\ninstance : LinearMapClass (CharacterModule A) \u2124 A (AddCircle (1 : \u211a)) where\n  map_add _ _ _ := by rw [AddMonoidHom.map_add]\n  map_smul\u209b\u2097 _ _ _ := by rw [AddMonoidHom.map_zsmul, RingHom.id_apply]\n\ninstance : AddCommGroup (CharacterModule A) :=\n  inferInstanceAs (AddCommGroup (A \u2192+ _))\n\n@[ext] theorem ext {c c' : CharacterModule A} (h : \u2200 x, c x = c' x) : c = c' := DFunLike.ext _ _ h\n\nsection module\n\nvariable [Module R A] [Module R A'] [Module R B]\n\ninstance : Module R (CharacterModule A) :=\n  Module.compHom (A \u2192+ _) (RingEquiv.toOpposite _ |>.toRingHom : R \u2192+* R\u1d48\u1d50\u1d43)\n\nvariable {R A B}\n\n@[simp] lemma smul_apply (c : CharacterModule A) (r : R) (a : A) : (r \u2022 c) a = c (r \u2022 a) := rfl\n\n/--\nGiven an abelian group homomorphism `f : A \u2192 B`, `f\u22c6(L) := L \u2218 f` defines a linear map\nfrom `B\u22c6` to `A\u22c6`.\n-/\n@[simps] def dual (f : A \u2192\u2097[R] B) : CharacterModule B \u2192\u2097[R] CharacterModule A where\n  toFun L := L.comp f.toAddMonoidHom\n  map_add' := by aesop\n  map_smul' r c := by ext x; exact congr(c $(f.map_smul r x)).symm\n\n@[simp]\nlemma dual_zero : dual (0 : A \u2192\u2097[R] B) = 0 := by\n  ext f\n  exact map_zero f\n\nlemma dual_comp {C : Type*} [AddCommGroup C] [Module R C] (f : A \u2192\u2097[R] B) (g : B \u2192\u2097[R] C) :\n    dual (g.comp f) = (dual f).comp (dual g) := by\n  ext\n  rfl\n\n", "theoremStatement": "lemma dual_injective_of_surjective (f : A \u2192\u2097[R] B) (hf : Function.Surjective f) :\n    Function.Injective (dual f) ", "theoremName": "CharacterModule.dual_injective_of_surjective", "fileCreated": {"commit": "65d37dc6412f280a667037cd83fc1f1423cb14cb", "date": "2024-02-27"}, "theoremCreated": {"commit": "f227e4af164386c81166cdc4e8e263323b586a36", "date": "2025-01-09"}, "file": "mathlib/Mathlib/Algebra/Module/CharacterModule.lean", "module": "Mathlib.Algebra.Module.CharacterModule", "jsonFile": "Mathlib.Algebra.Module.CharacterModule.jsonl", "positionMetadata": {"lineInFile": 90, "tokenPositionInFile": 2861, "theoremPositionInFile": 5}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 6, "repositoryPremises": true, "numRepositoryPremises": 21, "numPremises": 32}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  intro \u03c6 \u03c8 eq\n  ext x\n  obtain \u27e8y, rfl\u27e9 := hf x\n  change (dual f) \u03c6 _ = (dual f) \u03c8 _\n  rw [eq]", "proofType": "tactic", "proofLengthLines": 5, "proofLengthTokens": 101}}
{"srcContext": "/-\nCopyright (c) 2020 Yakov Pechersky. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yakov Pechersky, Anthony DeRossi\n-/\nimport Mathlib.Data.List.Basic\n\n/-!\n# Properties of `List.reduceOption`\n\nIn this file we prove basic lemmas about `List.reduceOption`.\n-/\n\nnamespace List\n\nvariable {\u03b1 \u03b2 : Type*}\n\n@[simp]\ntheorem reduceOption_cons_of_some (x : \u03b1) (l : List (Option \u03b1)) :\n    reduceOption (some x :: l) = x :: l.reduceOption := by\n  simp only [reduceOption, filterMap, id, eq_self_iff_true, and_self_iff]\n\n@[simp]\ntheorem reduceOption_cons_of_none (l : List (Option \u03b1)) :\n    reduceOption (none :: l) = l.reduceOption := by simp only [reduceOption, filterMap, id]\n\n@[simp]\ntheorem reduceOption_nil : @reduceOption \u03b1 [] = [] :=\n  rfl\n\n@[simp]\ntheorem reduceOption_map {l : List (Option \u03b1)} {f : \u03b1 \u2192 \u03b2} :\n    reduceOption (map (Option.map f) l) = map f (reduceOption l) := by\n  induction' l with hd tl hl\n  \u00b7 simp only [reduceOption_nil, map_nil]\n  \u00b7 cases hd <;>\n      simpa [Option.map_some', map, eq_self_iff_true, reduceOption_cons_of_some] using hl\n\ntheorem reduceOption_append (l l' : List (Option \u03b1)) :\n    (l ++ l').reduceOption = l.reduceOption ++ l'.reduceOption :=\n  filterMap_append l l' id\n\n@[simp]\ntheorem reduceOption_replicate_none {n : \u2115} : (replicate n (@none \u03b1)).reduceOption = [] := by\n  dsimp [reduceOption]\n  rw [filterMap_replicate_of_none]\n  rfl\n\n", "theoremStatement": "theorem reduceOption_eq_nil_iff (l : List (Option \u03b1)) :\n    l.reduceOption = [] \u2194 \u2203 n, l = replicate n none ", "theoremName": "List.reduceOption_eq_nil_iff", "fileCreated": {"commit": "5cc0a412b7d0d30421a2b126c6ebf629f735b59f", "date": "2024-03-26"}, "theoremCreated": {"commit": "c675cb586e7054488ba6962911a6e348356d8f33", "date": "2025-01-11"}, "file": "mathlib/Mathlib/Data/List/ReduceOption.lean", "module": "Mathlib.Data.List.ReduceOption", "jsonFile": "Mathlib.Data.List.ReduceOption.jsonl", "positionMetadata": {"lineInFile": 49, "tokenPositionInFile": 1423, "theoremPositionInFile": 6}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 32}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  dsimp [reduceOption]\n  rw [filterMap_eq_nil_iff]\n  constructor\n  \u00b7 intro h\n    exact \u27e8l.length, eq_replicate_of_mem h\u27e9\n  \u00b7 intro \u27e8_, h\u27e9\n    simp_rw [h, mem_replicate]\n    tauto", "proofType": "tactic", "proofLengthLines": 8, "proofLengthTokens": 184}}
{"srcContext": "/-\nCopyright (c) 2020 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\nimport Mathlib.RingTheory.NonUnitalSubsemiring.Defs\n\n/-!\n# Bundled subsemirings\n\nWe define bundled subsemirings and some standard constructions: `subtype` and `inclusion`\nring homomorphisms.\n-/\n\n\nuniverse u v w\n\nsection AddSubmonoidWithOneClass\n\n/-- `AddSubmonoidWithOneClass S R` says `S` is a type of subsets `s \u2264 R` that contain `0`, `1`,\nand are closed under `(+)` -/\nclass AddSubmonoidWithOneClass (S : Type*) (R : outParam Type*) [AddMonoidWithOne R]\n  [SetLike S R] extends AddSubmonoidClass S R, OneMemClass S R : Prop\n\nvariable {S R : Type*} [AddMonoidWithOne R] [SetLike S R] (s : S)\n\n@[aesop safe apply (rule_sets := [SetLike])]\ntheorem natCast_mem [AddSubmonoidWithOneClass S R] (n : \u2115) : (n : R) \u2208 s := by\n  induction n <;> simp [zero_mem, add_mem, one_mem, *]\n\n@[aesop safe apply (rule_sets := [SetLike])]\nlemma ofNat_mem [AddSubmonoidWithOneClass S R] (s : S) (n : \u2115) [n.AtLeastTwo] :\n    ofNat(n) \u2208 s := by\n  rw [\u2190 Nat.cast_ofNat]; exact natCast_mem s n\n\ninstance (priority := 74) AddSubmonoidWithOneClass.toAddMonoidWithOne\n    [AddSubmonoidWithOneClass S R] : AddMonoidWithOne s :=\n  { AddSubmonoidClass.toAddMonoid s with\n    one := \u27e8_, one_mem s\u27e9\n    natCast := fun n => \u27e8n, natCast_mem s n\u27e9\n    natCast_zero := Subtype.ext Nat.cast_zero\n    natCast_succ := fun _ => Subtype.ext (Nat.cast_succ _) }\n\nend AddSubmonoidWithOneClass\n\nvariable {R : Type u} {S : Type v} [NonAssocSemiring R]\n\nsection SubsemiringClass\n\n/-- `SubsemiringClass S R` states that `S` is a type of subsets `s \u2286 R` that\nare both a multiplicative and an additive submonoid. -/\nclass SubsemiringClass (S : Type*) (R : outParam (Type u)) [NonAssocSemiring R]\n  [SetLike S R] extends SubmonoidClass S R, AddSubmonoidClass S R : Prop\n\n-- See note [lower instance priority]\ninstance (priority := 100) SubsemiringClass.addSubmonoidWithOneClass (S : Type*)\n    (R : Type u) {_ : NonAssocSemiring R} [SetLike S R] [h : SubsemiringClass S R] :\n    AddSubmonoidWithOneClass S R :=\n  { h with }\n\ninstance (priority := 100) SubsemiringClass.nonUnitalSubsemiringClass (S : Type*)\n    (R : Type u) [NonAssocSemiring R] [SetLike S R] [SubsemiringClass S R] :\n    NonUnitalSubsemiringClass S R where\n  mul_mem := mul_mem\n\nvariable [SetLike S R] [hSR : SubsemiringClass S R] (s : S)\n\nnamespace SubsemiringClass\n\n-- Prefer subclasses of `NonAssocSemiring` over subclasses of `SubsemiringClass`.\n/-- A subsemiring of a `NonAssocSemiring` inherits a `NonAssocSemiring` structure -/\ninstance (priority := 75) toNonAssocSemiring : NonAssocSemiring s := fast_instance%\n  Subtype.coe_injective.nonAssocSemiring Subtype.val rfl rfl (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) fun _ => rfl\n\ninstance nontrivial [Nontrivial R] : Nontrivial s :=\n  nontrivial_of_ne 0 1 fun H => zero_ne_one (congr_arg Subtype.val H)\n\ninstance noZeroDivisors [NoZeroDivisors R] : NoZeroDivisors s :=\n  Subtype.coe_injective.noZeroDivisors _ rfl fun _ _ => rfl\n\n/-- The natural ring hom from a subsemiring of semiring `R` to `R`. -/\ndef subtype : s \u2192+* R :=\n  { SubmonoidClass.subtype s, AddSubmonoidClass.subtype s with toFun := (\u2191) }\n\n@[simp]\ntheorem coe_subtype : (subtype s : s \u2192 R) = ((\u2191) : s \u2192 R) :=\n  rfl\n\n-- Prefer subclasses of `Semiring` over subclasses of `SubsemiringClass`.\n/-- A subsemiring of a `Semiring` is a `Semiring`. -/\ninstance (priority := 75) toSemiring {R} [Semiring R] [SetLike S R] [SubsemiringClass S R] :\n    Semiring s := fast_instance%\n  Subtype.coe_injective.semiring Subtype.val rfl rfl (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) fun _ => rfl\n\n@[simp, norm_cast]\ntheorem coe_pow {R} [Semiring R] [SetLike S R] [SubsemiringClass S R] (x : s) (n : \u2115) :\n    ((x ^ n : s) : R) = (x : R) ^ n := by\n  induction n with\n  | zero => simp\n  | succ n ih => simp [pow_succ, ih]\n\n/-- A subsemiring of a `CommSemiring` is a `CommSemiring`. -/\ninstance toCommSemiring {R} [CommSemiring R] [SetLike S R] [SubsemiringClass S R] :\n    CommSemiring s := fast_instance%\n  Subtype.coe_injective.commSemiring Subtype.val rfl rfl (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) fun _ => rfl\n\nend SubsemiringClass\n\nend SubsemiringClass\n\nvariable [NonAssocSemiring S]\n\n/-- A subsemiring of a semiring `R` is a subset `s` that is both a multiplicative and an additive\nsubmonoid. -/\nstructure Subsemiring (R : Type u) [NonAssocSemiring R] extends Submonoid R, AddSubmonoid R\n\n/-- Reinterpret a `Subsemiring` as a `Submonoid`. -/\nadd_decl_doc Subsemiring.toSubmonoid\n\n/-- Reinterpret a `Subsemiring` as an `AddSubmonoid`. -/\nadd_decl_doc Subsemiring.toAddSubmonoid\n\nnamespace Subsemiring\n\ninstance : SetLike (Subsemiring R) R where\n  coe s := s.carrier\n  coe_injective' p q h := by cases p; cases q; congr; exact SetLike.coe_injective' h\n\ninstance : SubsemiringClass (Subsemiring R) R where\n  zero_mem := zero_mem'\n  add_mem {s} := AddSubsemigroup.add_mem' s.toAddSubmonoid.toAddSubsemigroup\n  one_mem {s} := Submonoid.one_mem' s.toSubmonoid\n  mul_mem {s} := Subsemigroup.mul_mem' s.toSubmonoid.toSubsemigroup\n\ninitialize_simps_projections Subsemiring (carrier \u2192 coe, as_prefix coe)\n\n/-- Turn a `Subsemiring` into a `NonUnitalSubsemiring` by forgetting that it contains `1`. -/\ndef toNonUnitalSubsemiring (S : Subsemiring R) : NonUnitalSubsemiring R where __ := S\n\n@[simp]\ntheorem mem_toSubmonoid {s : Subsemiring R} {x : R} : x \u2208 s.toSubmonoid \u2194 x \u2208 s :=\n  Iff.rfl\n\n@[simp]\nlemma mem_toNonUnitalSubsemiring {S : Subsemiring R} {x : R} :\n    x \u2208 S.toNonUnitalSubsemiring \u2194 x \u2208 S := .rfl\n\ntheorem mem_carrier {s : Subsemiring R} {x : R} : x \u2208 s.carrier \u2194 x \u2208 s :=\n  Iff.rfl\n\n@[simp]\nlemma coe_toNonUnitalSubsemiring (S : Subsemiring R) : (S.toNonUnitalSubsemiring : Set R) = S := rfl\n\n/-- Two subsemirings are equal if they have the same elements. -/\n@[ext]\ntheorem ext {S T : Subsemiring R} (h : \u2200 x, x \u2208 S \u2194 x \u2208 T) : S = T :=\n  SetLike.ext h\n\n/-- Copy of a subsemiring with a new `carrier` equal to the old one. Useful to fix definitional\nequalities. -/\n@[simps coe toSubmonoid]\nprotected def copy (S : Subsemiring R) (s : Set R) (hs : s = \u2191S) : Subsemiring R :=\n  { S.toAddSubmonoid.copy s hs, S.toSubmonoid.copy s hs with carrier := s }\n\ntheorem copy_eq (S : Subsemiring R) (s : Set R) (hs : s = \u2191S) : S.copy s hs = S :=\n  SetLike.coe_injective hs\n\ntheorem toSubmonoid_injective : Function.Injective (toSubmonoid : Subsemiring R \u2192 Submonoid R)\n  | _, _, h => ext (SetLike.ext_iff.mp h :)\n\ntheorem toAddSubmonoid_injective :\n    Function.Injective (toAddSubmonoid : Subsemiring R \u2192 AddSubmonoid R)\n  | _, _, h => ext (SetLike.ext_iff.mp h :)\n\n", "theoremStatement": "lemma toNonUnitalSubsemiring_injective :\n    Function.Injective (toNonUnitalSubsemiring : Subsemiring R \u2192 _) ", "theoremName": "Subsemiring.toNonUnitalSubsemiring_injective", "fileCreated": {"commit": "ddfa45d21fa79757b4bb6bc13e35338db5d9b26c", "date": "2024-11-03"}, "theoremCreated": {"commit": "8b781ec918a891323c20be4ed923133e287d624c", "date": "2025-01-02"}, "file": "mathlib/Mathlib/Algebra/Ring/Subsemiring/Defs.lean", "module": "Mathlib.Algebra.Ring.Subsemiring.Defs", "jsonFile": "Mathlib.Algebra.Ring.Subsemiring.Defs.jsonl", "positionMetadata": {"lineInFile": 178, "tokenPositionInFile": 6712, "theoremPositionInFile": 12}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 11, "numPremises": 15}, "proofMetadata": {"hasProof": true, "proof": ":=\n  fun S\u2081 S\u2082 h => SetLike.ext'_iff.2 (\n    show (S\u2081.toNonUnitalSubsemiring : Set R) = S\u2082 from SetLike.ext'_iff.1 h)", "proofType": "term", "proofLengthLines": 2, "proofLengthTokens": 117}}
{"srcContext": "/-\nCopyright (c) 2020 Aaron Anderson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Aaron Anderson\n-/\nimport Mathlib.Data.Set.Lattice\nimport Mathlib.Data.SetLike.Basic\nimport Mathlib.Order.ModularLattice\nimport Mathlib.Order.SuccPred.Basic\nimport Mathlib.Order.WellFounded\nimport Mathlib.Tactic.Nontriviality\nimport Mathlib.Order.ConditionallyCompleteLattice.Indexed\n\n/-!\n# Atoms, Coatoms, and Simple Lattices\n\nThis module defines atoms, which are minimal non-`\u22a5` elements in bounded lattices, simple lattices,\nwhich are lattices with only two elements, and related ideas.\n\n## Main definitions\n\n### Atoms and Coatoms\n  * `IsAtom a` indicates that the only element below `a` is `\u22a5`.\n  * `IsCoatom a` indicates that the only element above `a` is `\u22a4`.\n\n### Atomic and Atomistic Lattices\n  * `IsAtomic` indicates that every element other than `\u22a5` is above an atom.\n  * `IsCoatomic` indicates that every element other than `\u22a4` is below a coatom.\n  * `IsAtomistic` indicates that every element is the `sSup` of a set of atoms.\n  * `IsCoatomistic` indicates that every element is the `sInf` of a set of coatoms.\n  * `IsStronglyAtomic` indicates that for all `a < b`, there is some `x` with `a \u22d6 x \u2264 b`.\n  * `IsStronglyCoatomic` indicates that for all `a < b`, there is some `x` with `a \u2264 x \u22d6 b`.\n\n### Simple Lattices\n  * `IsSimpleOrder` indicates that an order has only two unique elements, `\u22a5` and `\u22a4`.\n  * `IsSimpleOrder.boundedOrder`\n  * `IsSimpleOrder.distribLattice`\n  * Given an instance of `IsSimpleOrder`, we provide the following definitions. These are not\n    made global instances as they contain data :\n    * `IsSimpleOrder.booleanAlgebra`\n    * `IsSimpleOrder.completeLattice`\n    * `IsSimpleOrder.completeBooleanAlgebra`\n\n## Main results\n  * `isAtom_dual_iff_isCoatom` and `isCoatom_dual_iff_isAtom` express the (definitional) duality\n   of `IsAtom` and `IsCoatom`.\n  * `isSimpleOrder_iff_isAtom_top` and `isSimpleOrder_iff_isCoatom_bot` express the\n  connection between atoms, coatoms, and simple lattices\n  * `IsCompl.isAtom_iff_isCoatom` and `IsCompl.isCoatom_if_isAtom`: In a modular\n  bounded lattice, a complement of an atom is a coatom and vice versa.\n  * `isAtomic_iff_isCoatomic`: A modular complemented lattice is atomic iff it is coatomic.\n\n-/\n\nvariable {\u03b9 : Sort*} {\u03b1 \u03b2 : Type*}\n\nsection Atoms\n\nsection IsAtom\n\nsection Preorder\n\nvariable [Preorder \u03b1] [OrderBot \u03b1] {a b x : \u03b1}\n\n/-- An atom of an `OrderBot` is an element with no other element between it and `\u22a5`,\n  which is not `\u22a5`. -/\ndef IsAtom (a : \u03b1) : Prop :=\n  a \u2260 \u22a5 \u2227 \u2200 b, b < a \u2192 b = \u22a5\n\ntheorem IsAtom.Iic (ha : IsAtom a) (hax : a \u2264 x) : IsAtom (\u27e8a, hax\u27e9 : Set.Iic x) :=\n  \u27e8fun con => ha.1 (Subtype.mk_eq_mk.1 con), fun \u27e8b, _\u27e9 hba => Subtype.mk_eq_mk.2 (ha.2 b hba)\u27e9\n\ntheorem IsAtom.of_isAtom_coe_Iic {a : Set.Iic x} (ha : IsAtom a) : IsAtom (a : \u03b1) :=\n  \u27e8fun con => ha.1 (Subtype.ext con), fun b hba =>\n    Subtype.mk_eq_mk.1 (ha.2 \u27e8b, hba.le.trans a.prop\u27e9 hba)\u27e9\n\ntheorem isAtom_iff_le_of_ge : IsAtom a \u2194 a \u2260 \u22a5 \u2227 \u2200 b \u2260 \u22a5, b \u2264 a \u2192 a \u2264 b :=\n  and_congr Iff.rfl <|\n    forall_congr' fun b => by\n      simp only [Ne, @not_imp_comm (b = \u22a5), Classical.not_imp, lt_iff_le_not_le]\n\nend Preorder\n\nsection PartialOrder\n\nvariable [PartialOrder \u03b1] [OrderBot \u03b1] {a b x : \u03b1}\n\ntheorem IsAtom.lt_iff (h : IsAtom a) : x < a \u2194 x = \u22a5 :=\n  \u27e8h.2 x, fun hx => hx.symm \u25b8 h.1.bot_lt\u27e9\n\ntheorem IsAtom.le_iff (h : IsAtom a) : x \u2264 a \u2194 x = \u22a5 \u2228 x = a := by rw [le_iff_lt_or_eq, h.lt_iff]\n\nlemma IsAtom.bot_lt (h : IsAtom a) : \u22a5 < a :=\n  h.lt_iff.mpr rfl\n\nlemma IsAtom.le_iff_eq (ha : IsAtom a) (hb : b \u2260 \u22a5) : b \u2264 a \u2194 b = a :=\n  ha.le_iff.trans <| or_iff_right hb\n\ntheorem IsAtom.Iic_eq (h : IsAtom a) : Set.Iic a = {\u22a5, a} :=\n  Set.ext fun _ => h.le_iff\n\n@[simp]\ntheorem bot_covBy_iff : \u22a5 \u22d6 a \u2194 IsAtom a := by\n  simp only [CovBy, bot_lt_iff_ne_bot, IsAtom, not_imp_not]\n\nalias \u27e8CovBy.is_atom, IsAtom.bot_covBy\u27e9 := bot_covBy_iff\n\nend PartialOrder\n\ntheorem atom_le_iSup [Order.Frame \u03b1] {a : \u03b1} (ha : IsAtom a) {f : \u03b9 \u2192 \u03b1} :\n    a \u2264 iSup f \u2194 \u2203 i, a \u2264 f i := by\n  refine \u27e8?_, fun \u27e8i, hi\u27e9 => le_trans hi (le_iSup _ _)\u27e9\n  show (a \u2264 \u2a06 i, f i) \u2192 _\n  refine fun h => of_not_not fun ha' => ?_\n  push_neg at ha'\n  have ha'' : Disjoint a (\u2a06 i, f i) :=\n    disjoint_iSup_iff.2 fun i => fun x hxa hxf => le_bot_iff.2 <| of_not_not fun hx =>\n      have hxa : x < a := (le_iff_eq_or_lt.1 hxa).resolve_left (by rintro rfl; exact ha' _ hxf)\n      hx (ha.2 _ hxa)\n  obtain rfl := le_bot_iff.1 (ha'' le_rfl h)\n  exact ha.1 rfl\n\nend IsAtom\n\nsection IsCoatom\n\nsection Preorder\n\nvariable [Preorder \u03b1]\n\n/-- A coatom of an `OrderTop` is an element with no other element between it and `\u22a4`,\n  which is not `\u22a4`. -/\ndef IsCoatom [OrderTop \u03b1] (a : \u03b1) : Prop :=\n  a \u2260 \u22a4 \u2227 \u2200 b, a < b \u2192 b = \u22a4\n\n@[simp]\ntheorem isCoatom_dual_iff_isAtom [OrderBot \u03b1] {a : \u03b1} :\n    IsCoatom (OrderDual.toDual a) \u2194 IsAtom a :=\n  Iff.rfl\n\n@[simp]\ntheorem isAtom_dual_iff_isCoatom [OrderTop \u03b1] {a : \u03b1} :\n    IsAtom (OrderDual.toDual a) \u2194 IsCoatom a :=\n  Iff.rfl\n\nalias \u27e8_, IsAtom.dual\u27e9 := isCoatom_dual_iff_isAtom\n\nalias \u27e8_, IsCoatom.dual\u27e9 := isAtom_dual_iff_isCoatom\n\nvariable [OrderTop \u03b1] {a x : \u03b1}\n\ntheorem IsCoatom.Ici (ha : IsCoatom a) (hax : x \u2264 a) : IsCoatom (\u27e8a, hax\u27e9 : Set.Ici x) :=\n  ha.dual.Iic hax\n\ntheorem IsCoatom.of_isCoatom_coe_Ici {a : Set.Ici x} (ha : IsCoatom a) : IsCoatom (a : \u03b1) :=\n  @IsAtom.of_isAtom_coe_Iic \u03b1\u1d52\u1d48 _ _ x a ha\n\ntheorem isCoatom_iff_ge_of_le : IsCoatom a \u2194 a \u2260 \u22a4 \u2227 \u2200 b \u2260 \u22a4, a \u2264 b \u2192 b \u2264 a :=\n  isAtom_iff_le_of_ge (\u03b1 := \u03b1\u1d52\u1d48)\n\nend Preorder\n\nsection PartialOrder\n\nvariable [PartialOrder \u03b1] [OrderTop \u03b1] {a b x : \u03b1}\n\ntheorem IsCoatom.lt_iff (h : IsCoatom a) : a < x \u2194 x = \u22a4 :=\n  h.dual.lt_iff\n\ntheorem IsCoatom.le_iff (h : IsCoatom a) : a \u2264 x \u2194 x = \u22a4 \u2228 x = a :=\n  h.dual.le_iff\n\n", "theoremStatement": "lemma IsCoatom.lt_top (h : IsCoatom a) : a < \u22a4 ", "theoremName": "IsCoatom.lt_top", "fileCreated": {"commit": "8618f40d51539454fe06511d5c8504a77f30c598", "date": "2022-12-30"}, "theoremCreated": {"commit": "f36aaf3682d93c2791bee76ef69613ff8c88f0fa", "date": "2025-01-02"}, "file": "mathlib/Mathlib/Order/Atoms.lean", "module": "Mathlib.Order.Atoms", "jsonFile": "Mathlib.Order.Atoms.jsonl", "positionMetadata": {"lineInFile": 173, "tokenPositionInFile": 5755, "theoremPositionInFile": 19}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 9, "numPremises": 13}, "proofMetadata": {"hasProof": true, "proof": ":=\n  h.lt_iff.mpr rfl", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 21}}
{"srcContext": "/-\nCopyright (c) 2018 S\u00e9bastien Gou\u00ebzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: S\u00e9bastien Gou\u00ebzel\n-/\nimport Mathlib.Data.Finset.Max\nimport Mathlib.Data.Set.Finite.Lattice\nimport Mathlib.Order.ConditionallyCompleteLattice.Indexed\n\n/-!\n# Conditionally complete lattices and finite sets.\n\n-/\n\n\nopen Set\n\nvariable {\u03b9 \u03b1 \u03b2 \u03b3 : Type*}\n\nsection ConditionallyCompleteLinearOrder\n\nvariable [ConditionallyCompleteLinearOrder \u03b1] {s t : Set \u03b1} {a b : \u03b1}\n\ntheorem Finset.Nonempty.csSup_eq_max' {s : Finset \u03b1} (h : s.Nonempty) : sSup \u2191s = s.max' h :=\n  eq_of_forall_ge_iff fun _ => (csSup_le_iff s.bddAbove h.to_set).trans (s.max'_le_iff h).symm\n\ntheorem Finset.Nonempty.csInf_eq_min' {s : Finset \u03b1} (h : s.Nonempty) : sInf \u2191s = s.min' h :=\n  @Finset.Nonempty.csSup_eq_max' \u03b1\u1d52\u1d48 _ s h\n\ntheorem Finset.Nonempty.csSup_mem {s : Finset \u03b1} (h : s.Nonempty) : sSup (s : Set \u03b1) \u2208 s := by\n  rw [h.csSup_eq_max']\n  exact s.max'_mem _\n\ntheorem Finset.Nonempty.csInf_mem {s : Finset \u03b1} (h : s.Nonempty) : sInf (s : Set \u03b1) \u2208 s :=\n  @Finset.Nonempty.csSup_mem \u03b1\u1d52\u1d48 _ _ h\n\ntheorem Set.Nonempty.csSup_mem (h : s.Nonempty) (hs : s.Finite) : sSup s \u2208 s := by\n  lift s to Finset \u03b1 using hs\n  exact Finset.Nonempty.csSup_mem h\n\ntheorem Set.Nonempty.csInf_mem (h : s.Nonempty) (hs : s.Finite) : sInf s \u2208 s :=\n  @Set.Nonempty.csSup_mem \u03b1\u1d52\u1d48 _ _ h hs\n\ntheorem Set.Finite.csSup_lt_iff (hs : s.Finite) (h : s.Nonempty) : sSup s < a \u2194 \u2200 x \u2208 s, x < a :=\n  \u27e8fun h _ hx => (le_csSup hs.bddAbove hx).trans_lt h, fun H => H _ <| h.csSup_mem hs\u27e9\n\ntheorem Set.Finite.lt_csInf_iff (hs : s.Finite) (h : s.Nonempty) : a < sInf s \u2194 \u2200 x \u2208 s, a < x :=\n  @Set.Finite.csSup_lt_iff \u03b1\u1d52\u1d48 _ _ _ hs h\n\nvariable (f : \u03b9 \u2192 \u03b1)\n\ntheorem Finset.ciSup_eq_max'_image {s : Finset \u03b9} (h : \u2203 x \u2208 s, sSup \u2205 \u2264 f x)\n    (h' : (s.image f).Nonempty := by classical exact image_nonempty.mpr (h.imp fun _ \u21a6 And.left)) :\n    \u2a06 i \u2208 s, f i = (s.image f).max' h' := by\n  classical\n  rw [iSup, \u2190 h'.csSup_eq_max', coe_image]\n  refine csSup_eq_csSup_of_forall_exists_le ?_ ?_\n  \u00b7 simp only [ciSup_eq_ite, dite_eq_ite, Set.mem_range, Set.mem_image, mem_coe,\n      exists_exists_and_eq_and, forall_exists_index, forall_apply_eq_imp_iff]\n    intro i\n    split_ifs\n    \u00b7 exact \u27e8_, by assumption, le_rfl\u27e9\n    \u00b7 obtain \u27e8a, ha, ha'\u27e9 := h\n      exact \u27e8a, ha, ha'\u27e9\n  \u00b7 simp only [Set.mem_image, mem_coe, ciSup_eq_ite, dite_eq_ite, Set.mem_range,\n      exists_exists_eq_and, forall_exists_index, and_imp, forall_apply_eq_imp_iff\u2082]\n    intro i hi\n    refine \u27e8i, ?_\u27e9\n    simp [hi]\n\ntheorem Finset.ciInf_eq_min'_image {s : Finset \u03b9} (h : \u2203 x \u2208 s, f x \u2264 sInf \u2205)\n    (h' : (s.image f).Nonempty := by classical exact image_nonempty.mpr (h.imp fun _ \u21a6 And.left)) :\n    \u2a05 i \u2208 s, f i = (s.image f).min' h' := by\n  classical\n  rw [\u2190 OrderDual.toDual_inj, toDual_min', toDual_iInf]\n  simp only [Function.comp_apply, toDual_iInf]\n  rw [ciSup_eq_max'_image _ h]\n  simp only [image_image]\n  congr\n\ntheorem Finset.ciSup_mem_image {s : Finset \u03b9} (h : \u2203 x \u2208 s, sSup \u2205 \u2264 f x) :\n    \u2a06 i \u2208 s, f i \u2208 s.image f := by\n  rw [ciSup_eq_max'_image _ h]\n  exact max'_mem (image f s) _\n\ntheorem Finset.ciInf_mem_image {s : Finset \u03b9} (h : \u2203 x \u2208 s, f x \u2264 sInf \u2205) :\n    \u2a05 i \u2208 s, f i \u2208 s.image f := by\n  rw [ciInf_eq_min'_image _ h]\n  exact min'_mem (image f s) _\n\ntheorem Set.Finite.ciSup_mem_image {s : Set \u03b9} (hs : s.Finite) (h : \u2203 x \u2208 s, sSup \u2205 \u2264 f x) :\n    \u2a06 i \u2208 s, f i \u2208 f '' s := by\n  lift s to Finset \u03b9 using hs\n  simp only [Finset.mem_coe] at h\n  simpa using Finset.ciSup_mem_image f h\n\ntheorem Set.Finite.ciInf_mem_image {s : Set \u03b9} (hs : s.Finite) (h : \u2203 x \u2208 s, f x \u2264 sInf \u2205) :\n    \u2a05 i \u2208 s, f i \u2208 f '' s := by\n  lift s to Finset \u03b9 using hs\n  simp only [Finset.mem_coe] at h\n  simpa using Finset.ciInf_mem_image f h\n\ntheorem Set.Finite.ciSup_lt_iff {s : Set \u03b9} {f : \u03b9 \u2192 \u03b1} (hs : s.Finite)\n    (h : \u2203 x \u2208 s, sSup \u2205 \u2264 f x) :\n    \u2a06 i \u2208 s, f i < a \u2194 \u2200 x \u2208 s, f x < a := by\n  constructor\n  \u00b7 intro h x hx\n    refine h.trans_le' (le_csSup ?_ ?_)\n    \u00b7 classical\n      refine (((hs.image f).union (finite_singleton (sSup \u2205))).subset ?_).bddAbove\n      intro\n      simp only [ciSup_eq_ite, dite_eq_ite, mem_range, union_singleton, mem_insert_iff, mem_image,\n        forall_exists_index]\n      intro x hx\n      split_ifs at hx\n      \u00b7 exact Or.inr \u27e8_, by assumption, hx\u27e9\n      \u00b7 simp_all\n    \u00b7 simp only [mem_range]\n      refine \u27e8x, ?_\u27e9\n      simp [hx]\n  \u00b7 intro H\n    have := hs.ciSup_mem_image _ h\n    simp only [mem_image] at this\n    obtain \u27e8_, hmem, hx\u27e9 := this\n    rw [\u2190 hx]\n    exact H _ hmem\n\ntheorem Set.Finite.lt_ciInf_iff {s : Set \u03b9} {f : \u03b9 \u2192 \u03b1} (hs : s.Finite)\n    (h : \u2203 x \u2208 s, f x \u2264 sInf \u2205) :\n    a < \u2a05 i \u2208 s, f i \u2194 \u2200 x \u2208 s, a < f x := by\n  constructor\n  \u00b7 intro h x hx\n    refine h.trans_le (csInf_le ?_ ?_)\n    \u00b7 classical\n      refine (((hs.image f).union (finite_singleton (sInf \u2205))).subset ?_).bddBelow\n      intro\n      simp only [ciInf_eq_ite, dite_eq_ite, mem_range, union_singleton, mem_insert_iff, mem_image,\n        forall_exists_index]\n      intro x hx\n      split_ifs at hx\n      \u00b7 exact Or.inr \u27e8_, by assumption, hx\u27e9\n      \u00b7 simp_all\n    \u00b7 simp only [mem_range]\n      refine \u27e8x, ?_\u27e9\n      simp [hx]\n  \u00b7 intro H\n    have := hs.ciInf_mem_image _ h\n    simp only [mem_image] at this\n    obtain \u27e8_, hmem, hx\u27e9 := this\n    rw [\u2190 hx]\n    exact H _ hmem\n\nsection ListMultiset\n\nlemma List.iSup_mem_map_of_exists_sSup_empty_le {l : List \u03b9} (f : \u03b9 \u2192 \u03b1)\n    (h : \u2203 x \u2208 l, sSup \u2205 \u2264 f x) :\n    \u2a06 x \u2208 l, f x \u2208 l.map f := by\n  classical\n  simpa using l.toFinset.ciSup_mem_image f (by simpa using h)\n\nlemma List.iInf_mem_map_of_exists_le_sInf_empty {l : List \u03b9} (f : \u03b9 \u2192 \u03b1)\n    (h : \u2203 x \u2208 l, f x \u2264 sInf \u2205) :\n    \u2a05 x \u2208 l, f x \u2208 l.map f := by\n  classical\n  simpa using l.toFinset.ciInf_mem_image f (by simpa using h)\n\nlemma Multiset.iSup_mem_map_of_exists_sSup_empty_le {s : Multiset \u03b9} (f : \u03b9 \u2192 \u03b1)\n    (h : \u2203 x \u2208 s, sSup \u2205 \u2264 f x) :\n    \u2a06 x \u2208 s, f x \u2208 s.map f := by\n  classical\n  simpa using s.toFinset.ciSup_mem_image f (by simpa using h)\n\nlemma Multiset.iInf_mem_map_of_exists_le_sInf_empty {s : Multiset \u03b9} (f : \u03b9 \u2192 \u03b1)\n    (h : \u2203 x \u2208 s, f x \u2264 sInf \u2205) :\n    \u2a05 x \u2208 s, f x \u2208 s.map f := by\n  classical\n  simpa using s.toFinset.ciInf_mem_image f (by simpa using h)\n\ntheorem exists_eq_ciSup_of_finite [Nonempty \u03b9] [Finite \u03b9] {f : \u03b9 \u2192 \u03b1} : \u2203 i, f i = \u2a06 i, f i :=\n  Nonempty.csSup_mem (range_nonempty f) (finite_range f)\n\ntheorem exists_eq_ciInf_of_finite [Nonempty \u03b9] [Finite \u03b9] {f : \u03b9 \u2192 \u03b1} : \u2203 i, f i = \u2a05 i, f i :=\n  Nonempty.csInf_mem (range_nonempty f) (finite_range f)\n\nend ListMultiset\n\nend ConditionallyCompleteLinearOrder\n\n/-!\n### Relation between `sSup` / `sInf` and `Finset.sup'` / `Finset.inf'`\n\nLike the `Sup` of a `ConditionallyCompleteLattice`, `Finset.sup'` also requires the set to be\nnon-empty. As a result, we can translate between the two.\n-/\n\nnamespace Finset\n\nsection ConditionallyCompleteLattice\nvariable [ConditionallyCompleteLattice \u03b1]\n\ntheorem sup'_eq_csSup_image (s : Finset \u03b9) (H : s.Nonempty) (f : \u03b9 \u2192 \u03b1) :\n    s.sup' H f = sSup (f '' s) :=\n  eq_of_forall_ge_iff fun a => by\n    simp [csSup_le_iff (s.finite_toSet.image f).bddAbove (H.to_set.image f)]\n\ntheorem inf'_eq_csInf_image (s : Finset \u03b9) (H : s.Nonempty) (f : \u03b9 \u2192 \u03b1) :\n    s.inf' H f = sInf (f '' s) :=\n  sup'_eq_csSup_image (\u03b1 := \u03b1\u1d52\u1d48) _ H _\n\ntheorem sup'_id_eq_csSup (s : Finset \u03b1) (hs) : s.sup' hs id = sSup s := by\n  rw [sup'_eq_csSup_image s hs, Set.image_id]\n\ntheorem inf'_id_eq_csInf (s : Finset \u03b1) (hs) : s.inf' hs id = sInf s :=\n  sup'_id_eq_csSup (\u03b1 := \u03b1\u1d52\u1d48) _ hs\n\nvariable [Fintype \u03b9] [Nonempty \u03b9]\n\n", "theoremStatement": "lemma sup'_univ_eq_ciSup (f : \u03b9 \u2192 \u03b1) : univ.sup' univ_nonempty f = \u2a06 i, f i ", "theoremName": "Finset.sup'_univ_eq_ciSup", "fileCreated": {"commit": "1ec531b5b05f9b64334db967ad7ae86625c588ce", "date": "2023-01-21"}, "theoremCreated": {"commit": "a38f191d0b038365a318f3334a591b52423e5aad", "date": "2024-12-10"}, "file": "mathlib/Mathlib/Order/ConditionallyCompleteLattice/Finset.lean", "module": "Mathlib.Order.ConditionallyCompleteLattice.Finset", "jsonFile": "Mathlib.Order.ConditionallyCompleteLattice.Finset.jsonl", "positionMetadata": {"lineInFile": 218, "tokenPositionInFile": 7528, "theoremPositionInFile": 26}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 18, "numPremises": 25}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp [sup'_eq_csSup_image, iSup]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 40}}
