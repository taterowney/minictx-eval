{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.Mathematics.Fin.Involutions\nimport HepLean.PerturbationTheory.WickContraction.ExtractEquiv\nimport HepLean.PerturbationTheory.WickContraction.Involutions\n/-!\n\n# Cardinality of Wick contractions\n-/\n\nopen FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\nnamespace WickContraction\nvariable {n : \u2115} (c : WickContraction n)\nopen HepLean.List\nopen FieldStatistic\nopen Nat\n\nlemma wickContraction_card_eq_sum_zero_none_isSome : Fintype.card (WickContraction n.succ)\n    = Fintype.card {c : WickContraction n.succ // \u00ac (c.getDual? 0).isSome} +\n    Fintype.card {c : WickContraction n.succ // (c.getDual? 0).isSome} := by\n  let e2 : WickContraction n.succ \u2243 {c : WickContraction n.succ // (c.getDual? 0).isSome} \u2295\n    {c : WickContraction n.succ // \u00ac (c.getDual? 0).isSome} := by\n    refine (Equiv.sumCompl _).symm\n  rw [Fintype.card_congr e2]\n  simp [add_comm]\n\nlemma wickContraction_zero_none_card :\n    Fintype.card {c : WickContraction n.succ // \u00ac (c.getDual? 0).isSome} =\n    Fintype.card (WickContraction n) := by\n  simp only [succ_eq_add_one, Bool.not_eq_true, Option.not_isSome, Option.isNone_iff_eq_none]\n  symm\n  exact Fintype.card_of_bijective (insertAndContractNat_bijective 0)\n\nlemma wickContraction_zero_some_eq_sum :\n    Fintype.card {c : WickContraction n.succ // (c.getDual? 0).isSome} =\n    \u2211 i, Fintype.card {c : WickContraction n.succ // (c.getDual? 0).isSome \u2227\n      \u2200 (h : (c.getDual? 0).isSome), (c.getDual? 0).get h = Fin.succ i} := by\n  let e1 : {c : WickContraction n.succ // (c.getDual? 0).isSome} \u2243\n    \u03a3 i, {c : WickContraction n.succ // (c.getDual? 0).isSome \u2227\n      \u2200 (h : (c.getDual? 0).isSome), (c.getDual? 0).get h = Fin.succ i} := {\n    toFun c := \u27e8((c.1.getDual? 0).get c.2).pred (by simp),\n      \u27e8c.1, \u27e8c.2, by simp\u27e9\u27e9\u27e9\n    invFun c := \u27e8c.2, c.2.2.1\u27e9\n    left_inv c := rfl\n    right_inv c := by\n      ext\n      \u00b7 simp [c.2.2.2]\n      \u00b7 rfl}\n  rw [Fintype.card_congr e1]\n  simp\n\nlemma finset_succAbove_succ_disjoint (a : Finset (Fin n)) (i : Fin n.succ) :\n    Disjoint ((Finset.map (Fin.succEmb (n + 1))) ((Finset.map i.succAboveEmb) a)) {0, i.succ} := by\n  simp only [succ_eq_add_one, Finset.disjoint_insert_right, Finset.mem_map, Fin.succAboveEmb_apply,\n    Fin.val_succEmb, exists_exists_and_eq_and, not_exists, not_and, Finset.disjoint_singleton_right,\n    Fin.succ_inj, exists_eq_right]\n  apply And.intro\n  \u00b7 exact fun x hx => Fin.succ_ne_zero (i.succAbove x)\n  \u00b7 exact fun x hx => Fin.succAbove_ne i x\n\n/-- The Wick contraction in `WickContraction n.succ.succ` formed by a Wick contraction\n  `WickContraction n` by inserting at the `0` and `i.succ` and contracting these two. -/\ndef consAddContract (i : Fin n.succ) (c : WickContraction n) :\n    WickContraction n.succ.succ :=\n  \u27e8(c.1.map (Finset.mapEmbedding i.succAboveEmb).toEmbedding).map\n    (Finset.mapEmbedding (Fin.succEmb n.succ)).toEmbedding \u222a {{0, i.succ}}, by\n    intro a\n    simp only [succ_eq_add_one, Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,\n      RelEmbedding.coe_toEmbedding, exists_exists_and_eq_and, Finset.mem_singleton]\n    intro h\n    rcases h with h | h\n    \u00b7 obtain \u27e8a, ha, rfl\u27e9 := h\n      rw [Finset.mapEmbedding_apply, Finset.mapEmbedding_apply]\n      simp only [Finset.card_map]\n      exact c.2.1 a ha\n    \u00b7 subst h\n      rw [@Finset.card_eq_two]\n      use 0, i.succ\n      simp only [succ_eq_add_one, ne_eq, and_true]\n      exact ne_of_beq_false rfl, by\n    intro a ha b hb\n    simp only [succ_eq_add_one, Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,\n      RelEmbedding.coe_toEmbedding, exists_exists_and_eq_and, Finset.mem_singleton] at ha hb\n    rcases ha with ha | ha <;> rcases hb with hb | hb\n    \u00b7 obtain \u27e8a, ha, rfl\u27e9 := ha\n      obtain \u27e8b, hb, rfl\u27e9 := hb\n      simp only [succ_eq_add_one, EmbeddingLike.apply_eq_iff_eq]\n      rw [Finset.mapEmbedding_apply, Finset.mapEmbedding_apply, Finset.mapEmbedding_apply,\n        Finset.mapEmbedding_apply, Finset.disjoint_map, Finset.disjoint_map]\n      exact c.2.2 a ha b hb\n    \u00b7 obtain \u27e8a, ha, rfl\u27e9 := ha\n      subst hb\n      right\n      rw [Finset.mapEmbedding_apply, Finset.mapEmbedding_apply]\n      exact finset_succAbove_succ_disjoint a i\n    \u00b7 obtain \u27e8b, hb, rfl\u27e9 := hb\n      subst ha\n      right\n      rw [Finset.mapEmbedding_apply, Finset.mapEmbedding_apply]\n      exact Disjoint.symm (finset_succAbove_succ_disjoint b i)\n    \u00b7 subst ha hb\n      simp\u27e9\n\n@[simp]\nlemma consAddContract_getDual?_zero (i : Fin n.succ) (c : WickContraction n) :\n    (consAddContract i c).getDual? 0 = some i.succ := by\n  rw [getDual?_eq_some_iff_mem]\n  simp [consAddContract]\n\n@[simp]\nlemma consAddContract_getDual?_self_succ (i : Fin n.succ) (c : WickContraction n) :\n    (consAddContract i c).getDual? i.succ = some 0 := by\n  rw [getDual?_eq_some_iff_mem]\n  simp [consAddContract, Finset.pair_comm]\n\nlemma mem_consAddContract_of_mem_iff (i : Fin n.succ) (c : WickContraction n) (a : Finset (Fin n)) :\n    a \u2208 c.1 \u2194 (a.map i.succAboveEmb).map (Fin.succEmb n.succ) \u2208 (consAddContract i c).1 := by\n  simp only [succ_eq_add_one, consAddContract, Finset.le_eq_subset, Finset.mem_union,\n    Finset.mem_map, RelEmbedding.coe_toEmbedding, exists_exists_and_eq_and, Finset.mem_singleton]\n  apply Iff.intro\n  \u00b7 intro h\n    left\n    use a\n    simp only [h, true_and]\n    rw [Finset.mapEmbedding_apply, Finset.mapEmbedding_apply]\n  \u00b7 intro h\n    rcases h with h | h\n    \u00b7 obtain \u27e8b, ha\u27e9 := h\n      rw [Finset.mapEmbedding_apply, Finset.mapEmbedding_apply] at ha\n      simp only [Finset.map_inj] at ha\n      rw [\u2190 ha.2]\n      exact ha.1\n    \u00b7 have h1 := finset_succAbove_succ_disjoint a i\n      rw [h] at h1\n      simp at h1\n\nlemma consAddContract_injective (i : Fin n.succ) : Function.Injective (consAddContract i) := by\n  intro c1 c2 h\n  apply Subtype.ext\n  ext a\n  apply Iff.intro\n  \u00b7 intro ha\n    have ha' : (a.map i.succAboveEmb).map (Fin.succEmb n.succ) \u2208 (consAddContract i c1).1 :=\n      (mem_consAddContract_of_mem_iff i c1 a).mp ha\n    rw [h] at ha'\n    rw [\u2190 mem_consAddContract_of_mem_iff] at ha'\n    exact ha'\n  \u00b7 intro ha\n    have ha' : (a.map i.succAboveEmb).map (Fin.succEmb n.succ) \u2208 (consAddContract i c2).1 :=\n      (mem_consAddContract_of_mem_iff i c2 a).mp ha\n    rw [\u2190 h] at ha'\n    rw [\u2190 mem_consAddContract_of_mem_iff] at ha'\n    exact ha'\n\n", "theoremStatement": "lemma consAddContract_surjective_on_zero_contract (i : Fin n.succ)\n    (c : WickContraction n.succ.succ)\n    (h : (c.getDual? 0).isSome) (h2 : (c.getDual? 0).get h = i.succ) :\n    \u2203 c', consAddContract i c' = c ", "theoremName": "WickContraction.consAddContract_surjective_on_zero_contract", "fileCreated": {"commit": "2a5193d5c9009d5f10823075d2855d0a81a09698", "date": "2025-02-04"}, "theoremCreated": {"commit": "2a5193d5c9009d5f10823075d2855d0a81a09698", "date": "2025-02-04"}, "file": "HepLean/HepLean/PerturbationTheory/WickContraction/Card.lean", "module": "HepLean.PerturbationTheory.WickContraction.Card", "jsonFile": "HepLean.PerturbationTheory.WickContraction.Card.jsonl", "positionMetadata": {"lineInFile": 159, "tokenPositionInFile": 6401, "theoremPositionInFile": 9}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 4, "numPremises": 181}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  let c' : WickContraction n :=\n      \u27e8Finset.filter\n      (fun x => (Finset.map i.succAboveEmb x).map (Fin.succEmb n.succ) \u2208 c.1) Finset.univ, by\n    intro a ha\n    simp only [succ_eq_add_one, Finset.mem_filter, Finset.mem_univ, true_and] at ha\n    simpa using c.2.1 _ ha, by\n    intro a ha b hb\n    simp only [Nat.succ_eq_add_one, Finset.mem_filter, Finset.mem_univ, true_and] at ha hb\n    rw [\u2190 Finset.disjoint_map i.succAboveEmb, \u2190 (Finset.map_injective i.succAboveEmb).eq_iff]\n    rw [\u2190 Finset.disjoint_map (Fin.succEmb n.succ),\n      \u2190 (Finset.map_injective (Fin.succEmb n.succ)).eq_iff]\n    exact c.2.2 _ ha _ hb\u27e9\n  use c'\n  apply Subtype.ext\n  ext a\n  simp [consAddContract]\n  apply Iff.intro\n  \u00b7 intro h\n    rcases h with h | h\n    \u00b7 obtain \u27e8b, hb, rfl\u27e9 := h\n      rw [Finset.mapEmbedding_apply, Finset.mapEmbedding_apply]\n      simp only [succ_eq_add_one, Finset.mem_filter, Finset.mem_univ, true_and, c'] at hb\n      exact hb\n    \u00b7 subst h\n      rw [\u2190 h2]\n      simp\n  \u00b7 intro h\n    by_cases ha : a = {0, i.succ}\n    \u00b7 simp [ha]\n    \u00b7 left\n      have hd := c.2.2 a h {0, i.succ} (by rw [\u2190 h2]; simp)\n      simp_all only [succ_eq_add_one, Finset.disjoint_insert_right, Finset.disjoint_singleton_right,\n        false_or]\n      have ha2 := c.2.1 a h\n      rw [@Finset.card_eq_two] at ha2\n      obtain \u27e8x, y, hx, rfl\u27e9 := ha2\n      simp_all only [succ_eq_add_one, ne_eq, Finset.mem_insert, Finset.mem_singleton, not_or]\n      obtain \u27e8x, rfl\u27e9 := Fin.exists_succ_eq (x := x).mpr (by omega)\n      obtain \u27e8y, rfl\u27e9 := Fin.exists_succ_eq (x := y).mpr (by omega)\n      simp_all only [Fin.succ_inj]\n      obtain \u27e8x, rfl\u27e9 := (Fin.exists_succAbove_eq (x := x) (y := i)) (by omega)\n      obtain \u27e8y, rfl\u27e9 := (Fin.exists_succAbove_eq (x := y) (y := i)) (by omega)\n      use {x, y}\n      simp only [Finset.map_insert, Fin.succAboveEmb_apply, Finset.map_singleton, Fin.val_succEmb,\n        h, true_and, c']\n      rw [Finset.mapEmbedding_apply, Finset.mapEmbedding_apply]\n      simpa using h", "proofType": "tactic", "proofLengthLines": 47, "proofLengthTokens": 1987}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.WickContraction.UncontractedList\n/-!\n\n# Inserting an element into a contraction based on a list\n\n-/\n\nopen FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\nnamespace WickContraction\nvariable {n : \u2115} (c : WickContraction n)\nopen HepLean.List\nopen HepLean.Fin\n\n/-!\n\n## Inserting an element into a list\n\n-/\n\n/-- Given a Wick contraction `\u03c6s\u039b` for a list `\u03c6s` of `\ud835\udcd5.FieldOp`,\n  an element `\u03c6` of `\ud835\udcd5.FieldOp`, an `i \u2264 \u03c6s.length` and a `j` which is either `none` or\n  some element of `\u03c6s\u039b.uncontracted`, the new Wick contraction\n  `\u03c6s\u039b.insertAndContract \u03c6 i j` is defined by inserting `\u03c6` into `\u03c6s` after\n  the first `i`-elements and moving the values representing the contracted pairs in `\u03c6s\u039b`\n  accordingly.\n  If `j` is not `none`, but rather `some j`, to this contraction is added the contraction\n  of `\u03c6` (at position `i`) with the new position of `j` after `\u03c6` is added.\n\n  In other words, `\u03c6s\u039b.insertAndContract \u03c6 i j` is formed by adding `\u03c6` to `\u03c6s` at position `i`,\n  and contracting `\u03c6` with the field originally at position `j` if `j` is not none.\n  It is a Wick contraction of `\u03c6s.insertIdx \u03c6 i`, the list `\u03c6s` with `\u03c6` inserted at\n  position `i`.\n\n  The notation `\u03c6s\u039b \u21a9\u039b \u03c6 i j` is used to denote `\u03c6s\u039b.insertAndContract \u03c6 i j`. -/\ndef insertAndContract {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (i : Fin \u03c6s.length.succ) (j : Option \u03c6s\u039b.uncontracted) :\n    WickContraction (\u03c6s.insertIdx i \u03c6).length :=\n  congr (by simp) (\u03c6s\u039b.insertAndContractNat i j)\n\n@[inherit_doc insertAndContract]\nscoped[WickContraction] notation \u03c6s \"\u21a9\u039b\" \u03c6:max i:max j => insertAndContract \u03c6 \u03c6s i j\n\n@[simp]\nlemma insertAndContract_fstFieldOfContract (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp)\n    (\u03c6s\u039b : WickContraction \u03c6s.length) (i : Fin \u03c6s.length.succ) (j : Option \u03c6s\u039b.uncontracted)\n    (a : \u03c6s\u039b.1) : (\u03c6s\u039b \u21a9\u039b \u03c6 i j).fstFieldOfContract\n    (congrLift (insertIdx_length_fin \u03c6 \u03c6s i).symm (insertLift i j a)) =\n    finCongr (insertIdx_length_fin \u03c6 \u03c6s i).symm (i.succAbove (\u03c6s\u039b.fstFieldOfContract a)) := by\n  simp [insertAndContract]\n\n@[simp]\nlemma insertAndContract_sndFieldOfContract (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp)\n    (\u03c6s\u039b : WickContraction \u03c6s.length) (i : Fin \u03c6s.length.succ) (j : Option (\u03c6s\u039b.uncontracted))\n    (a : \u03c6s\u039b.1) : (\u03c6s\u039b \u21a9\u039b \u03c6 i j).sndFieldOfContract\n    (congrLift (insertIdx_length_fin \u03c6 \u03c6s i).symm (insertLift i j a)) =\n    finCongr (insertIdx_length_fin \u03c6 \u03c6s i).symm (i.succAbove (\u03c6s\u039b.sndFieldOfContract a)) := by\n  simp [insertAndContract]\n\n@[simp]\nlemma insertAndContract_fstFieldOfContract_some_incl (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp)\n    (\u03c6s\u039b : WickContraction \u03c6s.length) (i : Fin \u03c6s.length.succ) (j : \u03c6s\u039b.uncontracted) :\n      (insertAndContract \u03c6 \u03c6s\u039b i (some j)).fstFieldOfContract\n      (congrLift (insertIdx_length_fin \u03c6 \u03c6s i).symm \u27e8{i, i.succAbove j}, by\n        simp [insertAndContractNat]\u27e9) =\n      if i < i.succAbove j.1 then\n      finCongr (insertIdx_length_fin \u03c6 \u03c6s i).symm i else\n      finCongr (insertIdx_length_fin \u03c6 \u03c6s i).symm (i.succAbove j.1) := by\n  split\n  \u00b7 rename_i h\n    refine (insertAndContract \u03c6 \u03c6s\u039b i (some j)).eq_fstFieldOfContract_of_mem\n      (a := congrLift (insertIdx_length_fin \u03c6 \u03c6s i).symm \u27e8{i, i.succAbove j}, by\n        simp [insertAndContractNat]\u27e9)\n      (i := finCongr (insertIdx_length_fin \u03c6 \u03c6s i).symm i) (j :=\n        finCongr (insertIdx_length_fin \u03c6 \u03c6s i).symm (i.succAbove j)) ?_ ?_ ?_\n    \u00b7 simp [congrLift]\n    \u00b7 simp [congrLift]\n    \u00b7 rw [Fin.lt_def] at h \u22a2\n      simp_all\n  \u00b7 rename_i h\n    refine (insertAndContract \u03c6 \u03c6s\u039b i (some j)).eq_fstFieldOfContract_of_mem\n      (a := congrLift (insertIdx_length_fin \u03c6 \u03c6s i).symm \u27e8{i, i.succAbove j}, by\n        simp [insertAndContractNat]\u27e9)\n      (i := finCongr (insertIdx_length_fin \u03c6 \u03c6s i).symm (i.succAbove j))\n      (j := finCongr (insertIdx_length_fin \u03c6 \u03c6s i).symm i) ?_ ?_ ?_\n    \u00b7 simp [congrLift]\n    \u00b7 simp [congrLift]\n    \u00b7 rw [Fin.lt_def] at h \u22a2\n      simp_all only [Nat.succ_eq_add_one, Fin.val_fin_lt, not_lt, finCongr_apply, Fin.coe_cast]\n      have hi : i.succAbove j \u2260 i := Fin.succAbove_ne i j\n      omega\n\n/-!\n\n## insertAndContract and getDual?\n\n-/\n\n@[simp]\nlemma insertAndContract_none_getDual?_self (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp)\n    (\u03c6s\u039b : WickContraction \u03c6s.length) (i : Fin \u03c6s.length.succ) :\n    (\u03c6s\u039b \u21a9\u039b \u03c6 i none).getDual? (Fin.cast (insertIdx_length_fin \u03c6 \u03c6s i).symm i) = none := by\n  simp only [Nat.succ_eq_add_one, insertAndContract, getDual?_congr, finCongr_apply, Fin.cast_trans,\n    Fin.cast_eq_self, Option.map_eq_none']\n  simp\n\nlemma insertAndContract_isSome_getDual?_self (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp)\n    (\u03c6s\u039b : WickContraction \u03c6s.length) (i : Fin \u03c6s.length.succ) (j : \u03c6s\u039b.uncontracted) :\n    ((\u03c6s\u039b \u21a9\u039b \u03c6 i (some j)).getDual?\n    (Fin.cast (insertIdx_length_fin \u03c6 \u03c6s i).symm i)).isSome := by\n  simp [insertAndContract, getDual?_congr]\n\n", "theoremStatement": "lemma insertAndContract_some_getDual?_self_not_none (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp)\n    (\u03c6s\u039b : WickContraction \u03c6s.length) (i : Fin \u03c6s.length.succ) (j : \u03c6s\u039b.uncontracted) :\n    \u00ac ((\u03c6s\u039b \u21a9\u039b \u03c6 i (some j)).getDual?\n    (Fin.cast (insertIdx_length_fin \u03c6 \u03c6s i).symm i)) = none ", "theoremName": "WickContraction.insertAndContract_some_getDual?_self_not_none", "fileCreated": {"commit": "fa7536bea9b5acc23e09f201a7765792caebb199", "date": "2025-01-24"}, "theoremCreated": {"commit": "fa7536bea9b5acc23e09f201a7765792caebb199", "date": "2025-01-24"}, "file": "HepLean/HepLean/PerturbationTheory/WickContraction/InsertAndContract.lean", "module": "HepLean.PerturbationTheory.WickContraction.InsertAndContract", "jsonFile": "HepLean.PerturbationTheory.WickContraction.InsertAndContract.jsonl", "positionMetadata": {"lineInFile": 119, "tokenPositionInFile": 5004, "theoremPositionInFile": 7}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 11, "numPremises": 50}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp [insertAndContract, getDual?_congr]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 48}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldSpecification.NormalOrder\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.SuperCommute\nimport HepLean.PerturbationTheory.Koszul.KoszulSign\n/-!\n\n# Normal Ordering in the FieldOpFreeAlgebra\n\nIn the module\n`HepLean.PerturbationTheory.FieldSpecification.NormalOrder`\nwe defined the normal ordering of a list of `CrAnFieldOp`.\nIn this module we extend the normal ordering to a linear map on `FieldOpFreeAlgebra`.\n\nWe derive properties of this normal ordering.\n\n-/\n\nnamespace FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\nopen FieldStatistic\n\nnamespace FieldOpFreeAlgebra\n\nnoncomputable section\n\n/-- For a field specification `\ud835\udcd5`, `normalOrderF` is the linear map\n\n  `FieldOpFreeAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpFreeAlgebra \ud835\udcd5`\n\n  defined by its action on the basis `ofCrAnListF \u03c6s`, taking `ofCrAnListF \u03c6s` to\n\n  `normalOrderSign \u03c6s \u2022 ofCrAnListF (normalOrderList \u03c6s)`.\n\n  That is, `normalOrderF` normal-orders the field operators and multiplies by the sign of the\n  normal order.\n\n  The notation `\ud835\udcdd\u1da0(a)` is used for `normalOrderF a` for `a` an element of\n  `FieldOpFreeAlgebra \ud835\udcd5`. -/\ndef normalOrderF : FieldOpFreeAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpFreeAlgebra \ud835\udcd5 :=\n  Basis.constr ofCrAnListFBasis \u2102 fun \u03c6s =>\n  normalOrderSign \u03c6s \u2022 ofCrAnListF (normalOrderList \u03c6s)\n\n@[inherit_doc normalOrderF]\nscoped[FieldSpecification.FieldOpFreeAlgebra] notation \"\ud835\udcdd\u1da0(\" a \")\" => normalOrderF a\n\nlemma normalOrderF_ofCrAnListF (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    \ud835\udcdd\u1da0(ofCrAnListF \u03c6s) = normalOrderSign \u03c6s \u2022 ofCrAnListF (normalOrderList \u03c6s) := by\n  rw [\u2190 ofListBasis_eq_ofList, normalOrderF, Basis.constr_basis]\n\nlemma ofCrAnListF_eq_normalOrderF (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnListF (normalOrderList \u03c6s) = normalOrderSign \u03c6s \u2022 \ud835\udcdd\u1da0(ofCrAnListF \u03c6s) := by\n  rw [normalOrderF_ofCrAnListF, normalOrderList, smul_smul, normalOrderSign,\n    Wick.koszulSign_mul_self, one_smul]\n\nlemma normalOrderF_one : normalOrderF (\ud835\udcd5 := \ud835\udcd5) 1 = 1 := by\n  rw [\u2190 ofCrAnListF_nil, normalOrderF_ofCrAnListF, normalOrderSign_nil, normalOrderList_nil,\n    ofCrAnListF_nil, one_smul]\n\nlemma normalOrderF_normalOrderF_mid (a b c : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \ud835\udcdd\u1da0(a * b * c) = \ud835\udcdd\u1da0(a * \ud835\udcdd\u1da0(b) * c) := by\n  let pc (c : \ud835\udcd5.FieldOpFreeAlgebra) (hc : c \u2208 Submodule.span \u2102 (Set.range ofCrAnListFBasis)) :\n    Prop := \ud835\udcdd\u1da0(a * b * c) = \ud835\udcdd\u1da0(a * \ud835\udcdd\u1da0(b) * c)\n  change pc c (Basis.mem_span _ c)\n  apply Submodule.span_induction\n  \u00b7 intro x hx\n    obtain \u27e8\u03c6s, rfl\u27e9 := hx\n    simp only [ofListBasis_eq_ofList, pc]\n    let pb (b : \ud835\udcd5.FieldOpFreeAlgebra) (hb : b \u2208 Submodule.span \u2102 (Set.range ofCrAnListFBasis)) :\n      Prop := \ud835\udcdd\u1da0(a * b * ofCrAnListF \u03c6s) = \ud835\udcdd\u1da0(a * \ud835\udcdd\u1da0(b) * ofCrAnListF \u03c6s)\n    change pb b (Basis.mem_span _ b)\n    apply Submodule.span_induction\n    \u00b7 intro x hx\n      obtain \u27e8\u03c6s', rfl\u27e9 := hx\n      simp only [ofListBasis_eq_ofList, pb]\n      let pa (a : \ud835\udcd5.FieldOpFreeAlgebra) (ha : a \u2208 Submodule.span \u2102 (Set.range ofCrAnListFBasis)) :\n        Prop := \ud835\udcdd\u1da0(a * ofCrAnListF \u03c6s' * ofCrAnListF \u03c6s) =\n        \ud835\udcdd\u1da0(a * \ud835\udcdd\u1da0(ofCrAnListF \u03c6s') * ofCrAnListF \u03c6s)\n      change pa a (Basis.mem_span _ a)\n      apply Submodule.span_induction\n      \u00b7 intro x hx\n        obtain \u27e8\u03c6s'', rfl\u27e9 := hx\n        simp only [ofListBasis_eq_ofList, pa]\n        rw [normalOrderF_ofCrAnListF]\n        simp only [\u2190 ofCrAnListF_append, Algebra.mul_smul_comm,\n          Algebra.smul_mul_assoc, map_smul]\n        rw [normalOrderF_ofCrAnListF, normalOrderF_ofCrAnListF, smul_smul]\n        congr 1\n        \u00b7 simp only [normalOrderSign, normalOrderList]\n          rw [Wick.koszulSign_of_append_eq_insertionSort, mul_comm]\n        \u00b7 congr 1\n          simp only [normalOrderList]\n          rw [HepLean.List.insertionSort_append_insertionSort_append]\n      \u00b7 simp [pa]\n      \u00b7 intro x y hx hy h1 h2\n        simp_all [pa, add_mul]\n      \u00b7 intro x hx h\n        simp_all [pa]\n    \u00b7 simp [pb]\n    \u00b7 intro x y hx hy h1 h2\n      simp_all [pb, mul_add, add_mul]\n    \u00b7 intro x hx h\n      simp_all [pb]\n  \u00b7 simp [pc]\n  \u00b7 intro x y hx hy h1 h2\n    simp_all [pc, mul_add]\n  \u00b7 intro x hx h hp\n    simp_all [pc]\n\n", "theoremStatement": "lemma normalOrderF_normalOrderF_right (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \ud835\udcdd\u1da0(a * b) = \ud835\udcdd\u1da0(a * \ud835\udcdd\u1da0(b)) ", "theoremName": "FieldSpecification.FieldOpFreeAlgebra.normalOrderF_normalOrderF_right", "fileCreated": {"commit": "ea6e12829370d9630a7e65200c8349e9086c05ba", "date": "2025-02-03"}, "theoremCreated": {"commit": "12d36dc1d9c726c035301091e57be0b29015e4ae", "date": "2025-01-31"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpFreeAlgebra/NormalOrder.lean", "module": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.NormalOrder", "jsonFile": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.NormalOrder.jsonl", "positionMetadata": {"lineInFile": 113, "tokenPositionInFile": 4186, "theoremPositionInFile": 6}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 5, "numPremises": 44}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  trans \ud835\udcdd\u1da0(a * b * 1)\n  \u00b7 simp\n  \u00b7 rw [normalOrderF_normalOrderF_mid]\n    simp", "proofType": "tactic", "proofLengthLines": 4, "proofLengthTokens": 84}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.TimeOrder\nimport HepLean.PerturbationTheory.FieldOpAlgebra.Basic\n/-!\n\n# SuperCommute on Field operator algebra\n\n-/\n\nnamespace FieldSpecification\nopen FieldOpFreeAlgebra\nopen HepLean.List\nopen FieldStatistic\n\nnamespace FieldOpAlgebra\nvariable {\ud835\udcd5 : FieldSpecification}\n\nlemma \u03b9_superCommuteF_eq_zero_of_\u03b9_right_zero (a b : \ud835\udcd5.FieldOpFreeAlgebra) (h : \u03b9 b = 0) :\n    \u03b9 [a, b]\u209bca = 0 := by\n  rw [superCommuteF_expand_bosonicProjF_fermionicProjF]\n  rw [\u03b9_eq_zero_iff_\u03b9_bosonicProjF_fermonicProj_zero] at h\n  simp_all\n\nlemma \u03b9_superCommuteF_eq_zero_of_\u03b9_left_zero (a b : \ud835\udcd5.FieldOpFreeAlgebra) (h : \u03b9 a = 0) :\n    \u03b9 [a, b]\u209bca = 0 := by\n  rw [superCommuteF_expand_bosonicProjF_fermionicProjF]\n  rw [\u03b9_eq_zero_iff_\u03b9_bosonicProjF_fermonicProj_zero] at h\n  simp_all\n\n/-!\n\n## Defining normal order for `FiedOpAlgebra`.\n\n-/\n\nlemma \u03b9_superCommuteF_right_zero_of_mem_ideal (a b : \ud835\udcd5.FieldOpFreeAlgebra)\n    (h : b \u2208 TwoSidedIdeal.span \ud835\udcd5.fieldOpIdealSet) : \u03b9 [a, b]\u209bca = 0 := by\n  apply \u03b9_superCommuteF_eq_zero_of_\u03b9_right_zero\n  exact (\u03b9_eq_zero_iff_mem_ideal b).mpr h\n\nlemma \u03b9_superCommuteF_eq_of_equiv_right (a b1 b2 : \ud835\udcd5.FieldOpFreeAlgebra) (h : b1 \u2248 b2) :\n    \u03b9 [a, b1]\u209bca = \u03b9 [a, b2]\u209bca := by\n  rw [equiv_iff_sub_mem_ideal] at h\n  rw [LinearMap.sub_mem_ker_iff.mp]\n  simp only [LinearMap.mem_ker, \u2190 map_sub]\n  exact \u03b9_superCommuteF_right_zero_of_mem_ideal a (b1 - b2) h\n\n/-- The super commutator on the `FieldOpAlgebra` defined as a linear map `[a,_]\u209b`. -/\nnoncomputable def superCommuteRight (a : \ud835\udcd5.FieldOpFreeAlgebra) :\n  FieldOpAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpAlgebra \ud835\udcd5 where\n  toFun := Quotient.lift (\u03b9.toLinearMap \u2218\u2097 superCommuteF a)\n    (\u03b9_superCommuteF_eq_of_equiv_right a)\n  map_add' x y := by\n    obtain \u27e8x, hx\u27e9 := \u03b9_surjective x\n    obtain \u27e8y, hy\u27e9 := \u03b9_surjective y\n    subst hx hy\n    rw [\u2190 map_add, \u03b9_apply, \u03b9_apply, \u03b9_apply]\n    rw [Quotient.lift_mk, Quotient.lift_mk, Quotient.lift_mk]\n    simp\n  map_smul' c y := by\n    obtain \u27e8y, hy\u27e9 := \u03b9_surjective y\n    subst hy\n    rw [\u2190 map_smul, \u03b9_apply, \u03b9_apply]\n    simp\n\nlemma superCommuteRight_apply_\u03b9 (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    superCommuteRight a (\u03b9 b) = \u03b9 [a, b]\u209bca := by rfl\n\nlemma superCommuteRight_apply_quot (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    superCommuteRight a \u27e6b\u27e7= \u03b9 [a, b]\u209bca := by rfl\n\nlemma superCommuteRight_eq_of_equiv (a1 a2 : \ud835\udcd5.FieldOpFreeAlgebra) (h : a1 \u2248 a2) :\n    superCommuteRight a1 = superCommuteRight a2 := by\n  rw [equiv_iff_sub_mem_ideal] at h\n  ext b\n  obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n  have ha1b1 : (superCommuteRight (a1 - a2)) (\u03b9 b) = 0 := by\n    rw [superCommuteRight_apply_\u03b9]\n    apply \u03b9_superCommuteF_eq_zero_of_\u03b9_left_zero\n    exact (\u03b9_eq_zero_iff_mem_ideal (a1 - a2)).mpr h\n  simp_all only [superCommuteRight_apply_\u03b9, map_sub, LinearMap.sub_apply]\n  trans \u03b9 ((superCommuteF a2) b) + 0\n  rw [\u2190 ha1b1]\n  simp only [add_sub_cancel]\n  simp\n\n/-- For a field specification `\ud835\udcd5`, `superCommute` is the linear map\n\n  `FieldOpAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpAlgebra \ud835\udcd5`\n\n  defined as the decent of `\u03b9 \u2218 superCommuteF` in both arguments.\n  In particular for `\u03c6s` and `\u03c6s'` lists of `\ud835\udcd5.CrAnFieldOp` in `FieldOpAlgebra \ud835\udcd5` the following\n  relation holds:\n\n  `superCommute \u03c6s \u03c6s' = \u03c6s * \u03c6s' - \ud835\udce2(\u03c6s, \u03c6s') \u2022 \u03c6s' * \u03c6s`\n\n  The notation `[a, b]\u209b` is used for `superCommute a b`.\n  -/\nnoncomputable def superCommute : FieldOpAlgebra \ud835\udcd5 \u2192\u2097[\u2102]\n    FieldOpAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpAlgebra \ud835\udcd5 where\n  toFun := Quotient.lift superCommuteRight superCommuteRight_eq_of_equiv\n  map_add' x y := by\n    obtain \u27e8x, rfl\u27e9 := \u03b9_surjective x\n    obtain \u27e8y, rfl\u27e9 := \u03b9_surjective y\n    ext b\n    obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n    rw [\u2190 map_add, \u03b9_apply, \u03b9_apply, \u03b9_apply, \u03b9_apply]\n    rw [Quotient.lift_mk, Quotient.lift_mk, Quotient.lift_mk]\n    simp only [LinearMap.add_apply]\n    rw [superCommuteRight_apply_quot, superCommuteRight_apply_quot, superCommuteRight_apply_quot]\n    simp\n  map_smul' c y := by\n    obtain \u27e8y, rfl\u27e9 := \u03b9_surjective y\n    ext b\n    obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n    rw [\u2190 map_smul, \u03b9_apply, \u03b9_apply, \u03b9_apply]\n    simp only [Quotient.lift_mk, RingHom.id_apply, LinearMap.smul_apply]\n    rw [superCommuteRight_apply_quot, superCommuteRight_apply_quot]\n    simp\n\n@[inherit_doc superCommute]\nscoped[FieldSpecification.FieldOpAlgebra] notation \"[\" a \",\" b \"]\u209b\" => superCommute a b\n\nlemma superCommute_eq_\u03b9_superCommuteF (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    [\u03b9 a, \u03b9 b]\u209b = \u03b9 [a, b]\u209bca := rfl\n\n/-!\n\n## Properties of `superCommute`.\n\n-/\n\n/-!\n\n## Properties from the definition of FieldOpAlgebra\n\n-/\n\nlemma superCommute_create_create {\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp}\n    (h : \ud835\udcd5 |>\u1d9c \u03c6 = .create) (h' : \ud835\udcd5 |>\u1d9c \u03c6' = .create) :\n    [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b = 0 := by\n  rw [ofCrAnOp, ofCrAnOp]\n  rw [superCommute_eq_\u03b9_superCommuteF, \u03b9_superCommuteF_of_create_create _ _ h h']\n\nlemma superCommute_annihilate_annihilate {\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp}\n    (h : \ud835\udcd5 |>\u1d9c \u03c6 = .annihilate) (h' : \ud835\udcd5 |>\u1d9c \u03c6' = .annihilate) :\n    [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b = 0 := by\n  rw [ofCrAnOp, ofCrAnOp]\n  rw [superCommute_eq_\u03b9_superCommuteF, \u03b9_superCommuteF_of_annihilate_annihilate _ _ h h']\n\nlemma superCommute_diff_statistic {\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp} (h : (\ud835\udcd5 |>\u209b \u03c6) \u2260 \ud835\udcd5 |>\u209b \u03c6') :\n    [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b = 0 := by\n  rw [ofCrAnOp, ofCrAnOp]\n  rw [superCommute_eq_\u03b9_superCommuteF, \u03b9_superCommuteF_of_diff_statistic h]\n\nlemma superCommute_ofCrAnOp_ofFieldOp_diff_stat_zero (\u03c6 : \ud835\udcd5.CrAnFieldOp) (\u03c8 : \ud835\udcd5.FieldOp)\n    (h : (\ud835\udcd5 |>\u209b \u03c6) \u2260 (\ud835\udcd5 |>\u209b \u03c8)) : [ofCrAnOp \u03c6, ofFieldOp \u03c8]\u209b = 0 := by\n  rw [ofFieldOp_eq_sum, map_sum]\n  rw [Finset.sum_eq_zero]\n  intro x hx\n  apply superCommute_diff_statistic\n  simpa [crAnStatistics] using h\n\nlemma superCommute_anPart_ofFieldOpF_diff_grade_zero (\u03c6 \u03c8 : \ud835\udcd5.FieldOp)\n    (h : (\ud835\udcd5 |>\u209b \u03c6) \u2260 (\ud835\udcd5 |>\u209b \u03c8)) : [anPart \u03c6, ofFieldOp \u03c8]\u209b = 0 := by\n  match \u03c6 with\n  | FieldOp.inAsymp _ =>\n    simp\n  | FieldOp.position \u03c6 =>\n    simp only [anPartF_position]\n    apply superCommute_ofCrAnOp_ofFieldOp_diff_stat_zero _ _ _\n    simpa [crAnStatistics] using h\n  | FieldOp.outAsymp _ =>\n    simp only [anPartF_posAsymp]\n    apply superCommute_ofCrAnOp_ofFieldOp_diff_stat_zero _ _\n    simpa [crAnStatistics] using h\n\nlemma superCommute_ofCrAnOp_ofCrAnOp_mem_center (\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b \u2208 Subalgebra.center \u2102 (FieldOpAlgebra \ud835\udcd5) := by\n  rw [ofCrAnOp, ofCrAnOp, superCommute_eq_\u03b9_superCommuteF]\n  exact \u03b9_superCommuteF_ofCrAnOpF_ofCrAnOpF_mem_center \u03c6 \u03c6'\n\nlemma superCommute_ofCrAnOp_ofCrAnOp_commute (\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp)\n    (a : FieldOpAlgebra \ud835\udcd5) :\n    a * [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b = [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b * a := by\n  have h1 := superCommute_ofCrAnOp_ofCrAnOp_mem_center \u03c6 \u03c6'\n  rw [@Subalgebra.mem_center_iff] at h1\n  exact h1 a\n\nlemma superCommute_ofCrAnOp_ofFieldOp_mem_center (\u03c6 : \ud835\udcd5.CrAnFieldOp) (\u03c6' : \ud835\udcd5.FieldOp) :\n    [ofCrAnOp \u03c6, ofFieldOp \u03c6']\u209b \u2208 Subalgebra.center \u2102 (FieldOpAlgebra \ud835\udcd5) := by\n  rw [ofFieldOp_eq_sum]\n  simp only [map_sum]\n  refine Subalgebra.sum_mem (Subalgebra.center \u2102 \ud835\udcd5.FieldOpAlgebra) ?_\n  intro x hx\n  exact superCommute_ofCrAnOp_ofCrAnOp_mem_center \u03c6 \u27e8\u03c6', x\u27e9\n\nlemma superCommute_ofCrAnOp_ofFieldOp_commute (\u03c6 : \ud835\udcd5.CrAnFieldOp) (\u03c6' : \ud835\udcd5.FieldOp)\n    (a : FieldOpAlgebra \ud835\udcd5) : a * [ofCrAnOp \u03c6, ofFieldOp \u03c6']\u209b =\n    [ofCrAnOp \u03c6, ofFieldOp \u03c6']\u209b * a := by\n  have h1 := superCommute_ofCrAnOp_ofFieldOp_mem_center \u03c6 \u03c6'\n  rw [@Subalgebra.mem_center_iff] at h1\n  exact h1 a\n\nlemma superCommute_anPart_ofFieldOp_mem_center (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [anPart \u03c6, ofFieldOp \u03c6']\u209b \u2208 Subalgebra.center \u2102 (FieldOpAlgebra \ud835\udcd5) := by\n  match \u03c6 with\n  | FieldOp.inAsymp _ =>\n    simp only [anPart_negAsymp, map_zero, LinearMap.zero_apply]\n    exact Subalgebra.zero_mem (Subalgebra.center \u2102 _)\n  | FieldOp.position \u03c6 =>\n    exact superCommute_ofCrAnOp_ofFieldOp_mem_center _ _\n  | FieldOp.outAsymp _ =>\n    exact superCommute_ofCrAnOp_ofFieldOp_mem_center _ _\n\n/-!\n\n### `superCommute` on different constructors.\n\n-/\n\nlemma superCommute_ofCrAnList_ofCrAnList (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnList \u03c6s, ofCrAnList \u03c6s']\u209b =\n    ofCrAnList (\u03c6s ++ \u03c6s') - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnList (\u03c6s' ++ \u03c6s) := by\n  rw [ofCrAnList_eq_\u03b9_ofCrAnListF, ofCrAnList_eq_\u03b9_ofCrAnListF]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_ofCrAnListF_ofCrAnListF]\n  rfl\n\nlemma superCommute_ofCrAnOp_ofCrAnOp (\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b = ofCrAnOp \u03c6 * ofCrAnOp \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 ofCrAnOp \u03c6' * ofCrAnOp \u03c6 := by\n  rw [ofCrAnOp, ofCrAnOp]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_ofCrAnOpF_ofCrAnOpF]\n  rfl\n\nlemma superCommute_ofCrAnList_ofFieldOpList (\u03c6cas : List \ud835\udcd5.CrAnFieldOp)\n    (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [ofCrAnList \u03c6cas, ofFieldOpList \u03c6s]\u209b = ofCrAnList \u03c6cas * ofFieldOpList \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6cas, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpList \u03c6s * ofCrAnList \u03c6cas := by\n  rw [ofCrAnList, ofFieldOpList]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_ofCrAnListF_ofFieldOpFsList]\n  rfl\n\nlemma superCommute_ofFieldOpList_ofFieldOpList (\u03c6s \u03c6s' : List \ud835\udcd5.FieldOp) :\n    [ofFieldOpList \u03c6s, ofFieldOpList \u03c6s']\u209b = ofFieldOpList \u03c6s * ofFieldOpList \u03c6s' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofFieldOpList \u03c6s' * ofFieldOpList \u03c6s := by\n  rw [ofFieldOpList, ofFieldOpList]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_ofFieldOpListF_ofFieldOpFsList]\n  rfl\n\nlemma superCommute_ofFieldOp_ofFieldOpList (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [ofFieldOp \u03c6, ofFieldOpList \u03c6s]\u209b = ofFieldOp \u03c6 * ofFieldOpList \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpList \u03c6s * ofFieldOp \u03c6 := by\n  rw [ofFieldOp, ofFieldOpList]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_ofFieldOpF_ofFieldOpFsList]\n  rfl\n\nlemma superCommute_ofFieldOpList_ofFieldOp (\u03c6s : List \ud835\udcd5.FieldOp) (\u03c6 : \ud835\udcd5.FieldOp) :\n    [ofFieldOpList \u03c6s, ofFieldOp \u03c6]\u209b = ofFieldOpList \u03c6s * ofFieldOp \u03c6 -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6) \u2022 ofFieldOp \u03c6 * ofFieldOpList \u03c6s := by\n  rw [ofFieldOpList, ofFieldOp]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_ofFieldOpListF_ofFieldOpF]\n  rfl\n\nlemma superCommute_anPart_crPart (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [anPart \u03c6, crPart \u03c6']\u209b = anPart \u03c6 * crPart \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 crPart \u03c6' * anPart \u03c6 := by\n  rw [anPart, crPart]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_anPartF_crPartF]\n  rfl\n\nlemma superCommute_crPart_anPart (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [crPart \u03c6, anPart \u03c6']\u209b = crPart \u03c6 * anPart \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 anPart \u03c6' * crPart \u03c6 := by\n  rw [anPart, crPart]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_crPartF_anPartF]\n  rfl\n\n@[simp]\nlemma superCommute_crPart_crPart (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) : [crPart \u03c6, crPart \u03c6']\u209b = 0 := by\n  match \u03c6, \u03c6' with\n  | FieldOp.outAsymp \u03c6, _ =>\n    simp\n  | _, FieldOp.outAsymp \u03c6 =>\n    simp\n  | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n    simp only [crPart_position]\n    apply superCommute_create_create\n    \u00b7 rfl\n    \u00b7 rfl\n  | FieldOp.position \u03c6, FieldOp.inAsymp \u03c6' =>\n    simp only [crPart_position, crPart_negAsymp]\n    apply superCommute_create_create\n    \u00b7 rfl\n    \u00b7 rfl\n  | FieldOp.inAsymp \u03c6, FieldOp.inAsymp \u03c6' =>\n    simp only [crPart_negAsymp]\n    apply superCommute_create_create\n    \u00b7 rfl\n    \u00b7 rfl\n  | FieldOp.inAsymp \u03c6, FieldOp.position \u03c6' =>\n    simp only [crPart_negAsymp, crPart_position]\n    apply superCommute_create_create\n    \u00b7 rfl\n    \u00b7 rfl\n\n@[simp]\nlemma superCommute_anPart_anPart (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) : [anPart \u03c6, anPart \u03c6']\u209b = 0 := by\n  match \u03c6, \u03c6' with\n  | FieldOp.inAsymp \u03c6, _ =>\n    simp\n  | _, FieldOp.inAsymp \u03c6 =>\n    simp\n  | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n    simp only [anPart_position]\n    apply superCommute_annihilate_annihilate\n    \u00b7 rfl\n    \u00b7 rfl\n  | FieldOp.position \u03c6, FieldOp.outAsymp \u03c6' =>\n    simp only [anPart_position, anPart_posAsymp]\n    apply superCommute_annihilate_annihilate\n    \u00b7 rfl\n    \u00b7 rfl\n  | FieldOp.outAsymp \u03c6, FieldOp.outAsymp \u03c6' =>\n    simp only [anPart_posAsymp]\n    apply superCommute_annihilate_annihilate\n    \u00b7 rfl\n    \u00b7 rfl\n  | FieldOp.outAsymp \u03c6, FieldOp.position \u03c6' =>\n    simp only [anPart_posAsymp, anPart_position]\n    apply superCommute_annihilate_annihilate\n    \u00b7 rfl\n    \u00b7 rfl\n\nlemma superCommute_crPart_ofFieldOpList (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [crPart \u03c6, ofFieldOpList \u03c6s]\u209b = crPart \u03c6 * ofFieldOpList \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpList \u03c6s * crPart \u03c6 := by\n  rw [crPart, ofFieldOpList]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_crPartF_ofFieldOpListF]\n  rfl\n\nlemma superCommute_anPart_ofFieldOpList (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [anPart \u03c6, ofFieldOpList \u03c6s]\u209b = anPart \u03c6 * ofFieldOpList \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpList \u03c6s * anPart \u03c6 := by\n  rw [anPart, ofFieldOpList]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_anPartF_ofFieldOpListF]\n  rfl\n\nlemma superCommute_crPart_ofFieldOp (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [crPart \u03c6, ofFieldOp \u03c6']\u209b = crPart \u03c6 * ofFieldOp \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 ofFieldOp \u03c6' * crPart \u03c6 := by\n  rw [crPart, ofFieldOp]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_crPartF_ofFieldOpF]\n  rfl\n\nlemma superCommute_anPart_ofFieldOp (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [anPart \u03c6, ofFieldOp \u03c6']\u209b = anPart \u03c6 * ofFieldOp \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 ofFieldOp \u03c6' * anPart \u03c6 := by\n  rw [anPart, ofFieldOp]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_anPartF_ofFieldOpF]\n  rfl\n\n/-!\n\n## Mul equal superCommute\n\nLemmas which rewrite a multiplication of two elements of the algebra as their commuted\nmultiplication with a sign plus the super commutator.\n\n-/\n\nlemma ofCrAnList_mul_ofCrAnList_eq_superCommute (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnList \u03c6s * ofCrAnList \u03c6s' =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnList \u03c6s' * ofCrAnList \u03c6s\n    + [ofCrAnList \u03c6s, ofCrAnList \u03c6s']\u209b := by\n  rw [superCommute_ofCrAnList_ofCrAnList]\n  simp [ofCrAnList_append]\n\nlemma ofCrAnOp_mul_ofCrAnList_eq_superCommute (\u03c6 : \ud835\udcd5.CrAnFieldOp)\n    (\u03c6s' : List \ud835\udcd5.CrAnFieldOp) : ofCrAnOp \u03c6 * ofCrAnList \u03c6s' =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnList \u03c6s' * ofCrAnOp \u03c6\n    + [ofCrAnOp \u03c6, ofCrAnList \u03c6s']\u209b := by\n  rw [\u2190 ofCrAnList_singleton, ofCrAnList_mul_ofCrAnList_eq_superCommute]\n  simp\n\nlemma ofFieldOpList_mul_ofFieldOpList_eq_superCommute (\u03c6s \u03c6s' : List \ud835\udcd5.FieldOp) :\n    ofFieldOpList \u03c6s * ofFieldOpList \u03c6s' =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofFieldOpList \u03c6s' * ofFieldOpList \u03c6s\n    + [ofFieldOpList \u03c6s, ofFieldOpList \u03c6s']\u209b := by\n  rw [superCommute_ofFieldOpList_ofFieldOpList]\n  simp\n\nlemma ofFieldOp_mul_ofFieldOpList_eq_superCommute (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s' : List \ud835\udcd5.FieldOp) :\n    ofFieldOp \u03c6 * ofFieldOpList \u03c6s' = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofFieldOpList \u03c6s' * ofFieldOp \u03c6\n    + [ofFieldOp \u03c6, ofFieldOpList \u03c6s']\u209b := by\n  rw [superCommute_ofFieldOp_ofFieldOpList]\n  simp\n\nlemma ofFieldOp_mul_ofFieldOp_eq_superCommute (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    ofFieldOp \u03c6 * ofFieldOp \u03c6' = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 ofFieldOp \u03c6' * ofFieldOp \u03c6\n    + [ofFieldOp \u03c6, ofFieldOp \u03c6']\u209b := by\n  rw [\u2190 ofFieldOpList_singleton, \u2190 ofFieldOpList_singleton]\n  rw [ofFieldOpList_mul_ofFieldOpList_eq_superCommute, ofFieldOpList_singleton]\n  simp\n\nlemma ofFieldOpList_mul_ofFieldOp_eq_superCommute (\u03c6s : List \ud835\udcd5.FieldOp) (\u03c6 : \ud835\udcd5.FieldOp) :\n    ofFieldOpList \u03c6s * ofFieldOp \u03c6 = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6) \u2022 ofFieldOp \u03c6 * ofFieldOpList \u03c6s\n    + [ofFieldOpList \u03c6s, ofFieldOp \u03c6]\u209b := by\n  rw [superCommute_ofFieldOpList_ofFieldOp]\n  simp\n\nlemma ofCrAnList_mul_ofFieldOpList_eq_superCommute (\u03c6s : List \ud835\udcd5.CrAnFieldOp)\n    (\u03c6s' : List \ud835\udcd5.FieldOp) : ofCrAnList \u03c6s * ofFieldOpList \u03c6s' =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofFieldOpList \u03c6s' * ofCrAnList \u03c6s\n    + [ofCrAnList \u03c6s, ofFieldOpList \u03c6s']\u209b := by\n  rw [superCommute_ofCrAnList_ofFieldOpList]\n  simp\n\nlemma crPart_mul_anPart_eq_superCommute (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    crPart \u03c6 * anPart \u03c6' = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 anPart \u03c6' * crPart \u03c6\n    + [crPart \u03c6, anPart \u03c6']\u209b := by\n  rw [superCommute_crPart_anPart]\n  simp\n\nlemma anPart_mul_crPart_eq_superCommute (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    anPart \u03c6 * crPart \u03c6' = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 crPart \u03c6' * anPart \u03c6\n    + [anPart \u03c6, crPart \u03c6']\u209b := by\n  rw [superCommute_anPart_crPart]\n  simp\n\nlemma crPart_mul_crPart_swap (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    crPart \u03c6 * crPart \u03c6' = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 crPart \u03c6' * crPart \u03c6 := by\n  trans \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 crPart \u03c6' * crPart \u03c6 + [crPart \u03c6, crPart \u03c6']\u209b\n  \u00b7 rw [crPart, crPart, superCommute_eq_\u03b9_superCommuteF, superCommuteF_crPartF_crPartF]\n    simp\n  \u00b7 simp\n\n", "theoremStatement": "lemma anPart_mul_anPart_swap (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    anPart \u03c6 * anPart \u03c6' = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 anPart \u03c6' * anPart \u03c6 ", "theoremName": "FieldSpecification.FieldOpAlgebra.anPart_mul_anPart_swap", "fileCreated": {"commit": "ea6e12829370d9630a7e65200c8349e9086c05ba", "date": "2025-02-03"}, "theoremCreated": {"commit": "c18b4850e54b74a6b63ae78ae4ef6a96be8e9569", "date": "2025-01-30"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpAlgebra/SuperCommute.lean", "module": "HepLean.PerturbationTheory.FieldOpAlgebra.SuperCommute", "jsonFile": "HepLean.PerturbationTheory.FieldOpAlgebra.SuperCommute.jsonl", "positionMetadata": {"lineInFile": 442, "tokenPositionInFile": 16344, "theoremPositionInFile": 43}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 20, "numPremises": 153}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  trans \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 anPart \u03c6' * anPart \u03c6 + [anPart \u03c6, anPart \u03c6']\u209b\n  \u00b7 rw [anPart, anPart, superCommute_eq_\u03b9_superCommuteF, superCommuteF_anPartF_anPartF]\n    simp\n  \u00b7 simp", "proofType": "tactic", "proofLengthLines": 4, "proofLengthTokens": 188}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.Basic\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.Grading\n/-!\n\n# Super Commute\n-/\n\nnamespace FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\nnamespace FieldOpFreeAlgebra\n\n/-!\n\n## The super commutator on the FieldOpFreeAlgebra.\n\n-/\n\nopen FieldStatistic\n\n/-- For a field specification `\ud835\udcd5`, the super commutator `superCommuteF` is defined as the linear\n  map `\ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102] \ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102] \ud835\udcd5.FieldOpFreeAlgebra`\n  which on the lists `\u03c6s` and `\u03c6s'` of `\ud835\udcd5.CrAnFieldOp` gives\n\n  `superCommuteF \u03c6s \u03c6s' = \u03c6s * \u03c6s' - \ud835\udce2(\u03c6s, \u03c6s') \u2022 \u03c6s' * \u03c6s`.\n\n  The notation `[a, b]\u209bca` can be used for `superCommuteF a b`. -/\nnoncomputable def superCommuteF : \ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102] \ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102]\n    \ud835\udcd5.FieldOpFreeAlgebra :=\n  Basis.constr ofCrAnListFBasis \u2102 fun \u03c6s =>\n  Basis.constr ofCrAnListFBasis \u2102 fun \u03c6s' =>\n  ofCrAnListF (\u03c6s ++ \u03c6s') - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnListF (\u03c6s' ++ \u03c6s)\n\n@[inherit_doc superCommuteF]\nscoped[FieldSpecification.FieldOpFreeAlgebra] notation \"[\" \u03c6s \",\" \u03c6s' \"]\u209bca\" => superCommuteF \u03c6s \u03c6s'\n\n/-!\n\n## The super commutator of different types of elements\n\n-/\n\nlemma superCommuteF_ofCrAnListF_ofCrAnListF (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnListF \u03c6s, ofCrAnListF \u03c6s']\u209bca =\n    ofCrAnListF (\u03c6s ++ \u03c6s') - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnListF (\u03c6s' ++ \u03c6s) := by\n  rw [\u2190 ofListBasis_eq_ofList, \u2190 ofListBasis_eq_ofList]\n  simp only [superCommuteF, Basis.constr_basis]\n\nlemma superCommuteF_ofCrAnOpF_ofCrAnOpF (\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnOpF \u03c6, ofCrAnOpF \u03c6']\u209bca =\n    ofCrAnOpF \u03c6 * ofCrAnOpF \u03c6' - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 ofCrAnOpF \u03c6' * ofCrAnOpF \u03c6 := by\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton]\n  rw [superCommuteF_ofCrAnListF_ofCrAnListF, ofCrAnListF_append]\n  congr\n  rw [ofCrAnListF_append]\n  rw [FieldStatistic.ofList_singleton, FieldStatistic.ofList_singleton, smul_mul_assoc]\n\nlemma superCommuteF_ofCrAnListF_ofFieldOpFsList (\u03c6cas : List \ud835\udcd5.CrAnFieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [ofCrAnListF \u03c6cas, ofFieldOpListF \u03c6s]\u209bca = ofCrAnListF \u03c6cas * ofFieldOpListF \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6cas, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpListF \u03c6s * ofCrAnListF \u03c6cas := by\n  conv_lhs => rw [ofFieldOpListF_sum]\n  rw [map_sum]\n  conv_lhs =>\n    enter [2, x]\n    rw [superCommuteF_ofCrAnListF_ofCrAnListF, CrAnSection.statistics_eq_state_statistics,\n      ofCrAnListF_append, ofCrAnListF_append]\n  rw [Finset.sum_sub_distrib, \u2190 Finset.mul_sum, \u2190 Finset.smul_sum,\n    \u2190 Finset.sum_mul, \u2190 ofFieldOpListF_sum]\n  simp\n\nlemma superCommuteF_ofFieldOpListF_ofFieldOpFsList (\u03c6 : List \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [ofFieldOpListF \u03c6, ofFieldOpListF \u03c6s]\u209bca = ofFieldOpListF \u03c6 * ofFieldOpListF \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpListF \u03c6s * ofFieldOpListF \u03c6 := by\n  conv_lhs => rw [ofFieldOpListF_sum]\n  simp only [map_sum, LinearMap.coeFn_sum, Finset.sum_apply, instCommGroup.eq_1,\n    Algebra.smul_mul_assoc]\n  conv_lhs =>\n    enter [2, x]\n    rw [superCommuteF_ofCrAnListF_ofFieldOpFsList]\n  simp only [instCommGroup.eq_1, CrAnSection.statistics_eq_state_statistics,\n    Algebra.smul_mul_assoc, Finset.sum_sub_distrib]\n  rw [\u2190 Finset.sum_mul, \u2190 Finset.smul_sum, \u2190 Finset.mul_sum, \u2190 ofFieldOpListF_sum]\n\nlemma superCommuteF_ofFieldOpF_ofFieldOpFsList (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [ofFieldOpF \u03c6, ofFieldOpListF \u03c6s]\u209bca = ofFieldOpF \u03c6 * ofFieldOpListF \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpListF \u03c6s * ofFieldOpF \u03c6 := by\n  rw [\u2190 ofFieldOpListF_singleton, superCommuteF_ofFieldOpListF_ofFieldOpFsList,\n    ofFieldOpListF_singleton]\n  simp\n\nlemma superCommuteF_ofFieldOpListF_ofFieldOpF (\u03c6s : List \ud835\udcd5.FieldOp) (\u03c6 : \ud835\udcd5.FieldOp) :\n    [ofFieldOpListF \u03c6s, ofFieldOpF \u03c6]\u209bca = ofFieldOpListF \u03c6s * ofFieldOpF \u03c6 -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6) \u2022 ofFieldOpF \u03c6 * ofFieldOpListF \u03c6s := by\n  rw [\u2190 ofFieldOpListF_singleton, superCommuteF_ofFieldOpListF_ofFieldOpFsList,\n    ofFieldOpListF_singleton]\n  simp\n\nlemma superCommuteF_anPartF_crPartF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [anPartF \u03c6, crPartF \u03c6']\u209bca = anPartF \u03c6 * crPartF \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 crPartF \u03c6' * anPartF \u03c6 := by\n  match \u03c6, \u03c6' with\n  | FieldOp.inAsymp \u03c6, _ =>\n    simp\n  | _, FieldOp.outAsymp \u03c6 =>\n    simp only [crPartF_posAsymp, map_zero, mul_zero, instCommGroup.eq_1, smul_zero, zero_mul,\n      sub_self]\n  | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n    simp only [anPartF_position, crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.outAsymp \u03c6, FieldOp.position \u03c6' =>\n    simp only [anPartF_posAsymp, crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.position \u03c6, FieldOp.inAsymp \u03c6' =>\n    simp only [anPartF_position, crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp only [List.singleton_append, instCommGroup.eq_1, crAnStatistics,\n      FieldStatistic.ofList_singleton, Function.comp_apply, crAnFieldOpToFieldOp_prod, \u2190\n      ofCrAnListF_append]\n  | FieldOp.outAsymp \u03c6, FieldOp.inAsymp \u03c6' =>\n    simp only [anPartF_posAsymp, crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n\nlemma superCommuteF_crPartF_anPartF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [crPartF \u03c6, anPartF \u03c6']\u209bca = crPartF \u03c6 * anPartF \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 anPartF \u03c6' * crPartF \u03c6 := by\n    match \u03c6, \u03c6' with\n    | FieldOp.outAsymp \u03c6, _ =>\n    simp only [crPartF_posAsymp, map_zero, LinearMap.zero_apply, zero_mul, instCommGroup.eq_1,\n      mul_zero, sub_self]\n    | _, FieldOp.inAsymp \u03c6 =>\n    simp only [anPartF_negAsymp, map_zero, mul_zero, instCommGroup.eq_1, smul_zero, zero_mul,\n      sub_self]\n    | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n    simp only [crPartF_position, anPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n    | FieldOp.position \u03c6, FieldOp.outAsymp \u03c6' =>\n    simp only [crPartF_position, anPartF_posAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n    | FieldOp.inAsymp \u03c6, FieldOp.position \u03c6' =>\n    simp only [crPartF_negAsymp, anPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n    | FieldOp.inAsymp \u03c6, FieldOp.outAsymp \u03c6' =>\n    simp only [crPartF_negAsymp, anPartF_posAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n\nlemma superCommuteF_crPartF_crPartF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [crPartF \u03c6, crPartF \u03c6']\u209bca = crPartF \u03c6 * crPartF \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 crPartF \u03c6' * crPartF \u03c6 := by\n  match \u03c6, \u03c6' with\n  | FieldOp.outAsymp \u03c6, _ =>\n  simp only [crPartF_posAsymp, map_zero, LinearMap.zero_apply, zero_mul, instCommGroup.eq_1,\n    mul_zero, sub_self]\n  | _, FieldOp.outAsymp \u03c6 =>\n  simp only [crPartF_posAsymp, map_zero, mul_zero, instCommGroup.eq_1, smul_zero, zero_mul,\n    sub_self]\n  | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n  simp only [crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.position \u03c6, FieldOp.inAsymp \u03c6' =>\n  simp only [crPartF_position, crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.inAsymp \u03c6, FieldOp.position \u03c6' =>\n  simp only [crPartF_negAsymp, crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.inAsymp \u03c6, FieldOp.inAsymp \u03c6' =>\n  simp only [crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp [crAnStatistics, \u2190 ofCrAnListF_append]\n\nlemma superCommuteF_anPartF_anPartF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [anPartF \u03c6, anPartF \u03c6']\u209bca =\n    anPartF \u03c6 * anPartF \u03c6' - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 anPartF \u03c6' * anPartF \u03c6 := by\n  match \u03c6, \u03c6' with\n  | FieldOp.inAsymp \u03c6, _ =>\n    simp\n  | _, FieldOp.inAsymp \u03c6 =>\n    simp\n  | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n    simp only [anPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.position \u03c6, FieldOp.outAsymp \u03c6' =>\n    simp only [anPartF_position, anPartF_posAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.outAsymp \u03c6, FieldOp.position \u03c6' =>\n    simp only [anPartF_posAsymp, anPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.outAsymp \u03c6, FieldOp.outAsymp \u03c6' =>\n    simp only [anPartF_posAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n\nlemma superCommuteF_crPartF_ofFieldOpListF (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [crPartF \u03c6, ofFieldOpListF \u03c6s]\u209bca =\n    crPartF \u03c6 * ofFieldOpListF \u03c6s - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpListF \u03c6s *\n    crPartF \u03c6 := by\n  match \u03c6 with\n  | FieldOp.inAsymp \u03c6 =>\n    simp only [crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofFieldOpFsList]\n    simp [crAnStatistics]\n  | FieldOp.position \u03c6 =>\n    simp only [crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofFieldOpFsList]\n    simp [crAnStatistics]\n  | FieldOp.outAsymp \u03c6 =>\n    simp\n\nlemma superCommuteF_anPartF_ofFieldOpListF (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [anPartF \u03c6, ofFieldOpListF \u03c6s]\u209bca =\n    anPartF \u03c6 * ofFieldOpListF \u03c6s - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022\n    ofFieldOpListF \u03c6s * anPartF \u03c6 := by\n  match \u03c6 with\n  | FieldOp.inAsymp \u03c6 =>\n    simp\n  | FieldOp.position \u03c6 =>\n    simp only [anPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofFieldOpFsList]\n    simp [crAnStatistics]\n  | FieldOp.outAsymp \u03c6 =>\n    simp only [anPartF_posAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofFieldOpFsList]\n    simp [crAnStatistics]\n\nlemma superCommuteF_crPartF_ofFieldOpF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [crPartF \u03c6, ofFieldOpF \u03c6']\u209bca =\n    crPartF \u03c6 * ofFieldOpF \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 ofFieldOpF \u03c6' * crPartF \u03c6 := by\n  rw [\u2190 ofFieldOpListF_singleton, superCommuteF_crPartF_ofFieldOpListF]\n  simp\n\nlemma superCommuteF_anPartF_ofFieldOpF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [anPartF \u03c6, ofFieldOpF \u03c6']\u209bca =\n    anPartF \u03c6 * ofFieldOpF \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 ofFieldOpF \u03c6' * anPartF \u03c6 := by\n  rw [\u2190 ofFieldOpListF_singleton, superCommuteF_anPartF_ofFieldOpListF]\n  simp\n\n/-!\n\n## Mul equal superCommuteF\n\nLemmas which rewrite a multiplication of two elements of the algebra as their commuted\nmultiplication with a sign plus the super commutator.\n\n-/\nlemma ofCrAnListF_mul_ofCrAnListF_eq_superCommuteF (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnListF \u03c6s * ofCrAnListF \u03c6s' = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnListF \u03c6s' * ofCrAnListF \u03c6s\n    + [ofCrAnListF \u03c6s, ofCrAnListF \u03c6s']\u209bca := by\n  rw [superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp [ofCrAnListF_append]\n\nlemma ofCrAnOpF_mul_ofCrAnListF_eq_superCommuteF (\u03c6 : \ud835\udcd5.CrAnFieldOp) (\u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnOpF \u03c6 * ofCrAnListF \u03c6s' = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnListF \u03c6s' * ofCrAnOpF \u03c6\n    + [ofCrAnOpF \u03c6, ofCrAnListF \u03c6s']\u209bca := by\n  rw [\u2190 ofCrAnListF_singleton, ofCrAnListF_mul_ofCrAnListF_eq_superCommuteF]\n  simp\n\n", "theoremStatement": "lemma ofFieldOpListF_mul_ofFieldOpListF_eq_superCommuteF (\u03c6s \u03c6s' : List \ud835\udcd5.FieldOp) :\n    ofFieldOpListF \u03c6s * ofFieldOpListF \u03c6s' =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofFieldOpListF \u03c6s' * ofFieldOpListF \u03c6s\n    + [ofFieldOpListF \u03c6s, ofFieldOpListF \u03c6s']\u209bca ", "theoremName": "FieldSpecification.FieldOpFreeAlgebra.ofFieldOpListF_mul_ofFieldOpListF_eq_superCommuteF", "fileCreated": {"commit": "ea6e12829370d9630a7e65200c8349e9086c05ba", "date": "2025-02-03"}, "theoremCreated": {"commit": "08260e709c7882cac7906bc05fe5fb9d03c44ba0", "date": "2025-02-03"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpFreeAlgebra/SuperCommute.lean", "module": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.SuperCommute", "jsonFile": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.SuperCommute.jsonl", "positionMetadata": {"lineInFile": 276, "tokenPositionInFile": 12991, "theoremPositionInFile": 18}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 14, "numPremises": 90}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [superCommuteF_ofFieldOpListF_ofFieldOpFsList]\n  simp", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 64}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldSpecification.CrAnFieldOp\n/-!\n\n# Creation and annihilation sections\n\nIn the module\n`HepLean.PerturbationTheory.FieldSpecification.Basic`\nwe defined states for a field specification, and in the module\n`HepLean.PerturbationTheory.FieldStatistics.CrAnFieldOp`\nwe defined a refinement of states called `CrAnFieldOp` which distinquishes between the\ncreation and annihilation components of states.\nThere exists, in particular, a map from `CrAnFieldOp` to `FieldOp` called `crAnFieldOpToFieldOp`.\n\nGiven a list of `FieldOp`, `\u03c6s`, in this module we define a section of `\u03c6s` to be a list of\n`CrAnFieldOp`, `\u03c8s`, such that under the map `crAnFieldOpToFieldOp`, `\u03c8s` is mapped to `\u03c6s`.\nThat is to say, the states underlying `\u03c8s` are the states in `\u03c6s`.\nWe denote these sections as `CrAnSection \u03c6s`.\n\nLooking forward the main consequence of this definition is the lemma\n`FieldSpecification.FieldOpFreeAlgebra.ofFieldOpListF_sum`.\n\nIn this module we define various properties of `CrAnSection`.\n\n-/\n\nnamespace FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\n/-- The sections in `\ud835\udcd5.CrAnFieldOp` over a list `\u03c6s : List \ud835\udcd5.FieldOp`.\n  In terms of physics, given some fields `\u03c6\u2081...\u03c6\u2099`, the different ways one can associate\n  each field as a `creation` or an `annilation` operator. E.g. the number of terms\n  `\u03c6\u2081\u2070\u03c6\u2082\u00b9...\u03c6\u2099\u2070` `\u03c6\u2081\u00b9\u03c6\u2082\u00b9...\u03c6\u2099\u2070` etc. If some fields are exclusively creation or annihilation\n  operators at this point (e.g. asymptotic states) this is accounted for. -/\ndef CrAnSection (\u03c6s : List \ud835\udcd5.FieldOp) : Type :=\n  {\u03c8s : List \ud835\udcd5.CrAnFieldOp // \u03c8s.map \ud835\udcd5.crAnFieldOpToFieldOp = \u03c6s}\n  -- \u03a0 i, \ud835\udcd5.fieldOpToCreateAnnihilateType (\u03c6s.get i)\n\nnamespace CrAnSection\nopen FieldStatistic\nvariable {\ud835\udcd5 : FieldSpecification} {\u03c6s : List \ud835\udcd5.FieldOp}\n\n@[simp]\nlemma length_eq (\u03c8s : CrAnSection \u03c6s) : \u03c8s.1.length = \u03c6s.length := by\n  simpa using congrArg List.length \u03c8s.2\n\n/-- The tail of a section for `\u03c6s`. -/\ndef tail : {\u03c6s : List \ud835\udcd5.FieldOp} \u2192 (\u03c8s : CrAnSection \u03c6s) \u2192 CrAnSection \u03c6s.tail\n  | [], \u27e8[], h\u27e9 => \u27e8[], h\u27e9\n  | \u03c6 :: \u03c6s, \u27e8[], h\u27e9 => False.elim (by simp at h)\n  | \u03c6 :: \u03c6s, \u27e8\u03c8 :: \u03c8s, h\u27e9 => \u27e8\u03c8s, by rw [List.map_cons, List.cons.injEq] at h; exact h.2\u27e9\n\nlemma head_state_eq {\u03c6 : \ud835\udcd5.FieldOp} : (\u03c8s : CrAnSection (\u03c6 :: \u03c6s)) \u2192\n    (\u03c8s.1.head (by simp [\u2190 List.length_pos_iff_ne_nil])).1 = \u03c6\n  | \u27e8[], h\u27e9 => False.elim (by simp at h)\n  | \u27e8\u03c8 :: \u03c8s, h\u27e9 => by\n    simp only [List.map_cons, List.cons.injEq] at h\n    exact h.1\n\nlemma statistics_eq_state_statistics (\u03c8s : CrAnSection \u03c6s) :\n    (\ud835\udcd5 |>\u209b \u03c8s.1) = \ud835\udcd5 |>\u209b \u03c6s := by\n  erw [FieldStatistic.ofList_eq_prod, FieldStatistic.ofList_eq_prod, crAnStatistics]\n  rw [\u2190 List.map_comp_map, Function.comp_apply, \u03c8s.2]\n\nlemma take_statistics_eq_take_state_statistics (\u03c8s : CrAnSection \u03c6s) n :\n    (\ud835\udcd5 |>\u209b (\u03c8s.1.take n)) = \ud835\udcd5 |>\u209b (\u03c6s.take n) := by\n  erw [FieldStatistic.ofList_eq_prod, FieldStatistic.ofList_eq_prod, crAnStatistics]\n  simp only [instCommGroup, List.map_take]\n  rw [\u2190 List.map_comp_map, Function.comp_apply, \u03c8s.2]\n\n/-- The head of a section for `\u03c6 :: \u03c6s` as an element in `\ud835\udcd5.fieldOpToCreateAnnihilateType \u03c6`. -/\ndef head : {\u03c6 : \ud835\udcd5.FieldOp} \u2192 (\u03c8s : CrAnSection (\u03c6 :: \u03c6s)) \u2192\n    \ud835\udcd5.fieldOpToCrAnType \u03c6\n  | \u03c6, \u27e8[], h\u27e9 => False.elim (by simp at h)\n  | \u03c6, \u27e8\u03c8 :: \u03c8s, h\u27e9 => \ud835\udcd5.fieldOpToCreateAnnihilateTypeCongr (by\n    simpa using head_state_eq \u27e8\u03c8 :: \u03c8s, h\u27e9) \u03c8.2\n\nlemma eq_head_cons_tail {\u03c6 : \ud835\udcd5.FieldOp} {\u03c8s : CrAnSection (\u03c6 :: \u03c6s)} :\n    \u03c8s.1 = \u27e8\u03c6, head \u03c8s\u27e9 :: \u03c8s.tail.1 := by\n  match \u03c8s with\n  | \u27e8[], h\u27e9 => exact False.elim (by simp at h)\n  | \u27e8\u03c8 :: \u03c8s, h\u27e9 =>\n    have h2 := head_state_eq \u27e8\u03c8 :: \u03c8s, h\u27e9\n    simp only [List.head_cons] at h2\n    subst h2\n    rfl\n\n/-- The creation of a section from for `\u03c6 : \u03c6s` from a section for `\u03c6s` and a\n  element of `\ud835\udcd5.fieldOpToCreateAnnihilateType \u03c6`. -/\ndef cons {\u03c6 : \ud835\udcd5.FieldOp} (\u03c8 : \ud835\udcd5.fieldOpToCrAnType \u03c6) (\u03c8s : CrAnSection \u03c6s) :\n    CrAnSection (\u03c6 :: \u03c6s) := \u27e8\u27e8\u03c6, \u03c8\u27e9 :: \u03c8s.1, by\n  simp [List.map_cons, \u03c8s.2]\u27e9\n\n/-- For the empty list of states there is only one `CrAnSection`. Corresponding to the\n  empty list of `CrAnFieldOp`. -/\ndef nilEquiv : CrAnSection (\ud835\udcd5 := \ud835\udcd5) [] \u2243 Unit where\n  toFun _ := ()\n  invFun _ := \u27e8[], rfl\u27e9\n  left_inv \u03c8s := Subtype.ext <| by\n    have h2 := \u03c8s.2\n    simp only [List.map_eq_nil_iff] at h2\n    simp [h2]\n  right_inv _ := by\n    simp\n\n/-- The creation and annihilation sections for a singleton list is given by\n  a choice of `\ud835\udcd5.fieldOpToCreateAnnihilateType \u03c6`. If `\u03c6` is a asymptotic state\n  there is no choice here, else there are two choices. -/\ndef singletonEquiv {\u03c6 : \ud835\udcd5.FieldOp} : CrAnSection [\u03c6] \u2243\n    \ud835\udcd5.fieldOpToCrAnType \u03c6 where\n  toFun \u03c8s := \u03c8s.head\n  invFun \u03c8 := \u27e8[\u27e8\u03c6, \u03c8\u27e9], by simp\u27e9\n  left_inv \u03c8s := by\n    apply Subtype.ext\n    simp only\n    have h1 := eq_head_cons_tail (\u03c8s := \u03c8s)\n    rw [h1]\n    have h2 := \u03c8s.tail.2\n    simp only [List.tail_cons, List.map_eq_nil_iff] at h2\n    simp [h2]\n  right_inv \u03c8 := by\n    simp only [head]\n    rfl\n\n/-- An equivalence separating the head of a creation and annihilation section\n  from the tail. -/\ndef consEquiv {\u03c6 : \ud835\udcd5.FieldOp} {\u03c6s : List \ud835\udcd5.FieldOp} : CrAnSection (\u03c6 :: \u03c6s) \u2243\n    \ud835\udcd5.fieldOpToCrAnType \u03c6 \u00d7 CrAnSection \u03c6s where\n  toFun \u03c8s := \u27e8\u03c8s.head, \u03c8s.tail\u27e9\n  invFun \u03c8\u03c8s :=\n    match \u03c8\u03c8s with\n    | (\u03c8, \u03c8s) => cons \u03c8 \u03c8s\n  left_inv \u03c8s := by\n    apply Subtype.ext\n    exact Eq.symm eq_head_cons_tail\n  right_inv \u03c8\u03c8s := by\n    match \u03c8\u03c8s with\n    | (\u03c8, \u03c8s) => rfl\n\n/-- The instance of a finite type on `CrAnSection`s defined recursively through\n  `consEquiv`. -/\ninstance fintype : (\u03c6s : List \ud835\udcd5.FieldOp) \u2192 Fintype (CrAnSection \u03c6s)\n  | [] => Fintype.ofEquiv _ nilEquiv.symm\n  | _ :: \u03c6s =>\n    haveI : Fintype (CrAnSection \u03c6s) := fintype \u03c6s\n    Fintype.ofEquiv _ consEquiv.symm\n\n@[simp]\nlemma card_nil_eq : Fintype.card (CrAnSection (\ud835\udcd5 := \ud835\udcd5) []) = 1 := by\n  rw [Fintype.ofEquiv_card nilEquiv.symm]\n  simp\n\nlemma card_cons_eq {\u03c6 : \ud835\udcd5.FieldOp} {\u03c6s : List \ud835\udcd5.FieldOp} :\n    Fintype.card (CrAnSection (\u03c6 :: \u03c6s)) = Fintype.card (\ud835\udcd5.fieldOpToCrAnType \u03c6) *\n    Fintype.card (CrAnSection \u03c6s) := by\n  rw [Fintype.ofEquiv_card consEquiv.symm]\n  simp\n\nlemma card_eq_mul : {\u03c6s : List \ud835\udcd5.FieldOp} \u2192 Fintype.card (CrAnSection \u03c6s) =\n    2 ^ (List.countP \ud835\udcd5.statesIsPosition \u03c6s)\n  | [] => by\n    simp\n  | FieldOp.position _ :: \u03c6s => by\n      simp only [statesIsPosition, List.countP_cons_of_pos]\n      rw [card_cons_eq]\n      rw [card_eq_mul]\n      simp only [fieldOpToCrAnType, CreateAnnihilate.CreateAnnihilate_card_eq_two]\n      ring\n  | FieldOp.inAsymp x_ :: \u03c6s => by\n      simp only [statesIsPosition, Bool.false_eq_true, not_false_eq_true, List.countP_cons_of_neg]\n      rw [card_cons_eq]\n      rw [card_eq_mul]\n      simp [fieldOpToCrAnType]\n  | FieldOp.outAsymp _ :: \u03c6s => by\n      simp only [statesIsPosition, Bool.false_eq_true, not_false_eq_true, List.countP_cons_of_neg]\n      rw [card_cons_eq]\n      rw [card_eq_mul]\n      simp [fieldOpToCrAnType]\n\nlemma card_perm_eq {\u03c6s \u03c6s' : List \ud835\udcd5.FieldOp} (h : \u03c6s.Perm \u03c6s') :\n    Fintype.card (CrAnSection \u03c6s) = Fintype.card (CrAnSection \u03c6s') := by\n  rw [card_eq_mul, card_eq_mul]\n  congr 1\n  exact List.Perm.countP_congr h fun x => congrFun rfl\n\n@[simp]\nlemma sum_nil (f : CrAnSection (\ud835\udcd5 := \ud835\udcd5) [] \u2192 M) [AddCommMonoid M] :\n    \u2211 (s : CrAnSection []), f s = f \u27e8[], rfl\u27e9 := by\n  rw [\u2190 nilEquiv.symm.sum_comp]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, Finset.sum_singleton]\n  rfl\n\nlemma sum_cons (f : CrAnSection (\u03c6 :: \u03c6s) \u2192 M) [AddCommMonoid M] :\n    \u2211 (s : CrAnSection (\u03c6 :: \u03c6s)), f s = \u2211 (a : \ud835\udcd5.fieldOpToCrAnType \u03c6),\n    \u2211 (s : CrAnSection \u03c6s), f (cons a s) := by\n  rw [\u2190 consEquiv.symm.sum_comp, Fintype.sum_prod_type]\n  rfl\n\nlemma sum_over_length {s : CrAnSection \u03c6s} (f : Fin s.1.length \u2192 M)\n    [AddCommMonoid M] : \u2211 (n : Fin s.1.length), f n =\n    \u2211 (n : Fin \u03c6s.length), f (Fin.cast (length_eq s).symm n) := by\n  rw [\u2190 (finCongr (length_eq s)).sum_comp]\n  rfl\n\n/-- The equivalence between `CrAnSection \u03c6s` and\n  `CrAnSection \u03c6s'` induced by an equality `\u03c6s = \u03c6s'`. -/\ndef congr : {\u03c6s \u03c6s' : List \ud835\udcd5.FieldOp} \u2192 (h : \u03c6s = \u03c6s') \u2192\n    CrAnSection \u03c6s \u2243 CrAnSection \u03c6s'\n  | _, _, rfl => Equiv.refl _\n\n@[simp]\nlemma congr_fst {\u03c6s \u03c6s' : List \ud835\udcd5.FieldOp} (h : \u03c6s = \u03c6s') (\u03c8s : CrAnSection \u03c6s) :\n    (congr h \u03c8s).1 = \u03c8s.1 := by\n  cases h\n  rfl\n\n@[simp]\nlemma congr_symm {\u03c6s \u03c6s' : List \ud835\udcd5.FieldOp} (h : \u03c6s = \u03c6s') :\n    (congr h).symm = congr h.symm := by\n  cases h\n  rfl\n\n@[simp]\nlemma congr_trans_apply {\u03c6s \u03c6s' \u03c6s'' : List \ud835\udcd5.FieldOp} (h1 : \u03c6s = \u03c6s') (h2 : \u03c6s' = \u03c6s'')\n    (\u03c8s : CrAnSection \u03c6s) :\n    (congr h2 (congr h1 \u03c8s)) = congr (by rw [h1, h2]) \u03c8s := by\n  subst h1 h2\n  rfl\n\n/-- Returns the first `n` elements of a section and its underlying list. -/\ndef take (n : \u2115) (\u03c8s : CrAnSection \u03c6s) : CrAnSection (\u03c6s.take n) :=\n  \u27e8\u03c8s.1.take n, by simp [\u03c8s.2]\u27e9\n\n@[simp]\nlemma take_congr {\u03c6s \u03c6s' : List \ud835\udcd5.FieldOp} (h : \u03c6s = \u03c6s') (n : \u2115)\n    (\u03c8s : CrAnSection \u03c6s) :\n    (take n (congr h \u03c8s)) = congr (by rw [h]) (take n \u03c8s) := by\n  subst h\n  rfl\n\n/-- Removes the first `n` elements of a section and its underlying list. -/\ndef drop (n : \u2115) (\u03c8s : CrAnSection \u03c6s) : CrAnSection (\u03c6s.drop n) :=\n  \u27e8\u03c8s.1.drop n, by simp [\u03c8s.2]\u27e9\n\n", "theoremStatement": "@[simp]\nlemma drop_congr {\u03c6s \u03c6s' : List \ud835\udcd5.FieldOp} (h : \u03c6s = \u03c6s') (n : \u2115)\n    (\u03c8s : CrAnSection \u03c6s) :\n    (drop n (congr h \u03c8s)) = congr (by rw [h]) (drop n \u03c8s) ", "theoremName": "FieldSpecification.CrAnSection.drop_congr", "fileCreated": {"commit": "b5c987180a78e45ea7ddb402cd866df26a7c1fa1", "date": "2025-01-21"}, "theoremCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "file": "HepLean/HepLean/PerturbationTheory/FieldSpecification/CrAnSection.lean", "module": "HepLean.PerturbationTheory.FieldSpecification.CrAnSection", "jsonFile": "HepLean.PerturbationTheory.FieldSpecification.CrAnSection.jsonl", "positionMetadata": {"lineInFile": 249, "tokenPositionInFile": 9184, "theoremPositionInFile": 18}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 5, "numPremises": 17}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  subst h\n  rfl", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 21}}
{"srcContext": "/-\nCopyright (c) 2024 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport Mathlib.LinearAlgebra.PiTensorProduct\nimport Mathlib.Tactic.Polyrith\nimport Mathlib.Tactic.Linarith\nimport Mathlib.Data.Nat.Factorial.DoubleFactorial\n/-!\n# Fin involutions\n\nSome properties of involutions of `Fin n`.\n\nThese involutions are used in e.g. proving results about Wick contractions.\n\n-/\nnamespace HepLean.Fin\n\nopen Nat\n\n/-- There is an equivalence between involutions of `Fin n.succ` and involutions of\n  `Fin n` and an optional valid choice of an element in `Fin n` (which is where `0`\n    in `Fin n.succ` will be sent). -/\ndef involutionCons (n : \u2115) : {f : Fin n.succ \u2192 Fin n.succ // Function.Involutive f } \u2243\n    (f : {f : Fin n \u2192 Fin n // Function.Involutive f}) \u00d7 {i : Option (Fin n) //\n      \u2200 (h : i.isSome), f.1 (Option.get i h) = (Option.get i h)} where\n  toFun f := \u27e8\u27e8\n    fun i =>\n    if h : f.1 i.succ = 0 then i\n    else Fin.pred (f.1 i.succ) h, by\n    intro i\n    by_cases h : f.1 i.succ = 0\n    \u00b7 simp [h]\n    \u00b7 simp only [succ_eq_add_one, h, \u2193reduceDIte, Fin.succ_pred]\n      simp only [f.2 i.succ, Fin.pred_succ, dite_eq_ite, ite_eq_right_iff]\n      intro h\n      exact False.elim (Fin.succ_ne_zero i h)\u27e9,\n    \u27e8if h : f.1 0 = 0 then none else Fin.pred (f.1 0) h, by\n    by_cases h0 : f.1 0 = 0\n    \u00b7 simp [h0]\n    \u00b7 simp only [succ_eq_add_one, h0, \u2193reduceDIte, Option.isSome_some, Option.get_some,\n      Fin.succ_pred, dite_eq_left_iff, Fin.pred_inj, forall_const]\n      refine fun h => False.elim (h (f.2 0))\u27e9\u27e9\n  invFun f := \u27e8\n      if h : (f.2.1).isSome then\n        Fin.cons (f.2.1.get h).succ (Function.update (Fin.succ \u2218 f.1.1) (f.2.1.get h) 0)\n      else\n        Fin.cons 0 (Fin.succ \u2218 f.1.1), by\n    by_cases hs : (f.2.1).isSome\n    \u00b7 simp only [Nat.succ_eq_add_one, hs, \u2193reduceDIte, Fin.coe_eq_castSucc]\n      let a := f.2.1.get hs\n      change Function.Involutive (Fin.cons a.succ (Function.update (Fin.succ \u2218 \u2191f.fst) a 0))\n      intro i\n      rcases Fin.eq_zero_or_eq_succ i with hi | \u27e8j, hj\u27e9\n      \u00b7 subst hi\n        rw [Fin.cons_zero, Fin.cons_succ]\n        simp\n      \u00b7 subst hj\n        rw [Fin.cons_succ]\n        by_cases hja : j = a\n        \u00b7 subst hja\n          simp\n        \u00b7 rw [Function.update_apply]\n          rw [if_neg hja]\n          simp only [Function.comp_apply, Fin.cons_succ]\n          have hf2 := f.2.2 hs\n          change f.1.1 a = a at hf2\n          have hjf1 : f.1.1 j \u2260 a := by\n            by_contra hn\n            have haj : j = f.1.1 a := by\n              rw [\u2190 hn]\n              rw [f.1.2]\n            rw [hf2] at haj\n            exact hja haj\n          rw [Function.update_apply, if_neg hjf1]\n          simp only [Function.comp_apply, Fin.succ_inj]\n          rw [f.1.2]\n    \u00b7 simp only [succ_eq_add_one, hs, Bool.false_eq_true, \u2193reduceDIte]\n      intro i\n      rcases Fin.eq_zero_or_eq_succ i with hi | \u27e8j, hj\u27e9\n      \u00b7 subst hi\n        simp\n      \u00b7 subst hj\n        simp only [Fin.cons_succ, Function.comp_apply, Fin.succ_inj]\n        rw [f.1.2]\u27e9\n  left_inv f := by\n    match f with\n    | \u27e8f, hf\u27e9 =>\n    simp only [succ_eq_add_one, Option.isSome_dite', Option.get_dite', Fin.succ_pred,\n      Fin.cons_update, dite_eq_ite, ite_not, Subtype.mk.injEq]\n    ext i\n    by_cases h0 : f 0 = 0\n    \u00b7 simp only [h0, \u2193reduceIte]\n      rcases Fin.eq_zero_or_eq_succ i with hi | \u27e8j, hj\u27e9\n      \u00b7 subst hi\n        simp [h0]\n      \u00b7 subst hj\n        simp only [Fin.cons_succ, Function.comp_apply, Fin.val_succ]\n        by_cases hj : f j.succ =0\n        \u00b7 rw [\u2190 h0] at hj\n          have hn := Function.Involutive.injective hf hj\n          exact False.elim (Fin.succ_ne_zero j hn)\n        \u00b7 simp only [hj, \u2193reduceDIte, Fin.coe_pred]\n          rw [Fin.ext_iff] at hj\n          simp only [succ_eq_add_one, Fin.val_zero] at hj\n          omega\n    \u00b7 rw [if_neg h0]\n      by_cases hf' : i = f 0\n      \u00b7 subst hf'\n        simp only [Function.update_self, Fin.val_zero]\n        rw [hf]\n        simp\n      \u00b7 rw [Function.update_apply, if_neg hf']\n        rcases Fin.eq_zero_or_eq_succ i with hi | \u27e8j, hj\u27e9\n        \u00b7 subst hi\n          simp\n        \u00b7 subst hj\n          simp only [Fin.cons_succ, Function.comp_apply, Fin.val_succ]\n          by_cases hj : f j.succ =0\n          \u00b7 rw [\u2190 hj] at hf'\n            rw [hf] at hf'\n            simp only [not_true_eq_false] at hf'\n          \u00b7 simp only [hj, \u2193reduceDIte, Fin.coe_pred]\n            rw [Fin.ext_iff] at hj\n            simp only [succ_eq_add_one, Fin.val_zero] at hj\n            omega\n  right_inv f := by\n    match f with\n    | \u27e8\u27e8f, hf\u27e9, \u27e8f0, hf0\u27e9\u27e9 =>\n    ext i\n    \u00b7 simp only [succ_eq_add_one, Fin.cons_update]\n      by_cases hs : f0.isSome\n      \u00b7 simp only [hs, \u2193reduceDIte]\n        by_cases hi : i = f0.get hs\n        \u00b7 simp only [Function.update_apply, hi, \u2193reduceIte, \u2193reduceDIte]\n          exact Eq.symm (Fin.val_eq_of_eq (hf0 hs))\n        \u00b7 simp only [ne_eq, Fin.succ_inj, hi, not_false_eq_true, Function.update_of_ne,\n          Fin.cons_succ, Function.comp_apply, Fin.pred_succ, dite_eq_ite]\n          split\n          \u00b7 rename_i h\n            exact False.elim (Fin.succ_ne_zero (f i) h)\n          \u00b7 rfl\n      \u00b7 simp only [hs, Bool.false_eq_true, \u2193reduceDIte, Fin.cons_succ, Function.comp_apply,\n        Fin.pred_succ, dite_eq_ite]\n        split\n        \u00b7 rename_i h\n          exact False.elim (Fin.succ_ne_zero (f i) h)\n        \u00b7 rfl\n    \u00b7 simp only [Nat.succ_eq_add_one, Option.mem_def,\n      Option.dite_none_left_eq_some, Option.some.injEq]\n      by_cases hs : f0.isSome\n      \u00b7 simp only [hs, \u2193reduceDIte]\n        simp only [Fin.cons_zero, Fin.pred_succ, exists_prop]\n        have hx : \u00ac (f0.get hs).succ = 0 := (Fin.succ_ne_zero (f0.get hs))\n        simp only [hx, not_false_eq_true, true_and]\n        refine Iff.intro (fun hi => ?_) (fun hi => ?_)\n        \u00b7 rw [\u2190 hi]\n          exact\n            Option.eq_some_of_isSome\n              (Eq.mpr_prop (Eq.refl (f0.isSome = true))\n                (of_eq_true (Eq.trans (congrArg (fun x => x = true) hs) (eq_self true))))\n        \u00b7 subst hi\n          exact rfl\n      \u00b7 simp only [hs, Bool.false_eq_true, \u2193reduceDIte, Fin.cons_zero, not_true_eq_false,\n        IsEmpty.exists_iff, false_iff]\n        simp only [Bool.not_eq_true, Option.not_isSome, Option.isNone_iff_eq_none] at hs\n        subst hs\n        exact ne_of_beq_false rfl\n\n", "theoremStatement": "lemma involutionCons_ext {n : \u2115} {f1 f2 : (f : {f : Fin n \u2192 Fin n // Function.Involutive f}) \u00d7\n    {i : Option (Fin n) // \u2200 (h : i.isSome), f.1 (Option.get i h) = (Option.get i h)}}\n    (h1 : f1.1 = f2.1) (h2 : f1.2 = Equiv.subtypeEquivRight (by rw [h1]; simp) f2.2) : f1 = f2 ", "theoremName": "HepLean.Fin.involutionCons_ext", "fileCreated": {"commit": "1ab0c6f76904b49d21f9c1e09d26746f52caa4eb", "date": "2025-01-05"}, "theoremCreated": {"commit": "eadb35447732dbd0ac584b4a198a1ff1632b74ea", "date": "2025-01-04"}, "file": "HepLean/HepLean/Mathematics/Fin/Involutions.lean", "module": "HepLean.Mathematics.Fin.Involutions", "jsonFile": "HepLean.Mathematics.Fin.Involutions.jsonl", "positionMetadata": {"lineInFile": 171, "tokenPositionInFile": 6350, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 44}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  cases f1\n  cases f2\n  simp only at h1 h2\n  subst h1\n  rename_i fst snd snd_1\n  simp_all only [Sigma.mk.inj_iff, heq_eq_eq, true_and]\n  obtain \u27e8val, property\u27e9 := fst\n  obtain \u27e8val_1, property_1\u27e9 := snd\n  obtain \u27e8val_2, property_2\u27e9 := snd_1\n  simp_all only\n  rfl", "proofType": "tactic", "proofLengthLines": 11, "proofLengthTokens": 268}}
{"srcContext": "/-\nCopyright (c) 2024 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.Mathematics.List.InsertIdx\n/-!\n# List lemmas\n\n-/\nnamespace HepLean.List\n\nopen Fin\nopen HepLean\nvariable {n : Nat}\n\nlemma insertionSortMin_lt_length_succ {\u03b1 : Type} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [DecidableRel r]\n    (i : \u03b1) (l : List \u03b1) :\n    insertionSortMinPos r i l < (insertionSortDropMinPos r i l).length.succ := by\n  rw [insertionSortMinPos]\n  simp only [List.length_cons, List.insertionSort.eq_2, insertionSortDropMinPos,\n    Nat.succ_eq_add_one]\n  rw [eraseIdx_length']\n  simp\n\n/-- Given a list `i :: l` the left-most minimal position `a` of `i :: l` wrt `r`\n  as an element of `Fin (insertionSortDropMinPos r i l).length.succ`. -/\ndef insertionSortMinPosFin {\u03b1 : Type} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [DecidableRel r] (i : \u03b1) (l : List \u03b1) :\n    Fin (insertionSortDropMinPos r i l).length.succ :=\n  \u27e8insertionSortMinPos r i l, insertionSortMin_lt_length_succ r i l\u27e9\n\nlemma insertionSortMin_lt_mem_insertionSortDropMinPos {\u03b1 : Type} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [DecidableRel r]\n    [IsTotal \u03b1 r] [IsTrans \u03b1 r] (a : \u03b1) (l : List \u03b1)\n    (i : Fin (insertionSortDropMinPos r a l).length) :\n    r (insertionSortMin r a l) ((insertionSortDropMinPos r a l)[i]) := by\n  let l1 := List.insertionSort r (a :: l)\n  have hl1 : l1.Sorted r := List.sorted_insertionSort r (a :: l)\n  simp only [l1] at hl1\n  rw [insertionSort_eq_insertionSortMin_cons r a l] at hl1\n  simp only [List.sorted_cons, List.mem_insertionSort] at hl1\n  apply hl1.1 ((insertionSortDropMinPos r a l)[i])\n  simp\n\nlemma insertionSortMinPos_insertionSortEquiv {\u03b1 : Type} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [DecidableRel r]\n    (a : \u03b1) (l : List \u03b1) :\n    insertionSortEquiv r (a ::l) (insertionSortMinPos r a l) =\n    \u27e80, by simp [List.orderedInsert_length]\u27e9 := by\n  rw [insertionSortMinPos]\n  exact\n    Equiv.apply_symm_apply (insertionSortEquiv r (a :: l)) \u27e80, insertionSortMinPos.proof_1 r a l\u27e9\n\nlemma insertionSortEquiv_gt_zero_of_ne_insertionSortMinPos {\u03b1 : Type} (r : \u03b1 \u2192 \u03b1 \u2192 Prop)\n    [DecidableRel r] (a : \u03b1) (l : List \u03b1) (k : Fin (a :: l).length)\n    (hk : k \u2260 insertionSortMinPos r a l) :\n    \u27e80, by simp [List.orderedInsert_length]\u27e9 < insertionSortEquiv r (a :: l) k := by\n  by_contra hn\n  simp only [List.insertionSort.eq_2, List.length_cons, not_lt] at hn\n  refine hk ((Equiv.apply_eq_iff_eq_symm_apply (insertionSortEquiv r (a :: l))).mp ?_)\n  simp_all only [List.length_cons, ne_eq, Fin.le_def, nonpos_iff_eq_zero, List.insertionSort.eq_2]\n  simp only [Fin.ext_iff]\n  omega\n\nlemma insertionSortMin_lt_mem_insertionSortDropMinPos_of_lt {\u03b1 : Type} (r : \u03b1 \u2192 \u03b1 \u2192 Prop)\n    [DecidableRel r] (a : \u03b1) (l : List \u03b1)\n    (i : Fin (insertionSortDropMinPos r a l).length)\n    (h : (insertionSortMinPosFin r a l).succAbove i < insertionSortMinPosFin r a l) :\n    \u00ac r ((insertionSortDropMinPos r a l)[i]) (insertionSortMin r a l) := by\n  simp only [Fin.getElem_fin, insertionSortMin, List.get_eq_getElem, List.length_cons]\n  have h1 : (insertionSortDropMinPos r a l)[i] =\n    (a :: l).get (finCongr (eraseIdx_length_succ (a :: l) (insertionSortMinPos r a l))\n    ((insertionSortMinPosFin r a l).succAbove i)) := by\n    trans (insertionSortDropMinPos r a l).get i\n    simp only [Fin.getElem_fin, List.get_eq_getElem]\n    simp only [insertionSortDropMinPos, List.length_cons, Nat.succ_eq_add_one,\n      finCongr_apply, Fin.coe_cast]\n    rw [eraseIdx_get]\n    simp only [List.length_cons, Function.comp_apply, List.get_eq_getElem, Fin.coe_cast]\n    rfl\n  erw [h1]\n  simp only [List.length_cons, Nat.succ_eq_add_one, List.get_eq_getElem,\n    Fin.coe_cast]\n  apply insertionSortEquiv_order\n  simpa using h\n  simp only [List.insertionSort.eq_2, List.length_cons, finCongr_apply]\n  apply lt_of_eq_of_lt (insertionSortMinPos_insertionSortEquiv r a l)\n  simp only [List.insertionSort.eq_2]\n  apply insertionSortEquiv_gt_zero_of_ne_insertionSortMinPos r a l\n  simp only [List.length_cons, ne_eq, Fin.ext_iff, Fin.coe_cast]\n  have hl : (insertionSortMinPos r a l).val = (insertionSortMinPosFin r a l).val := by\n    rfl\n  simp only [hl, Nat.succ_eq_add_one, Fin.val_eq_val, ne_eq]\n  exact Fin.succAbove_ne (insertionSortMinPosFin r a l) i\n\nlemma insertionSort_insertionSort {\u03b1 : Type} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [DecidableRel r]\n    [IsTotal \u03b1 r] [IsTrans \u03b1 r] (l1 : List \u03b1) :\n    List.insertionSort r (List.insertionSort r l1) = List.insertionSort r l1 := by\n  apply List.Sorted.insertionSort_eq\n  exact List.sorted_insertionSort r l1\n\nlemma orderedInsert_commute {\u03b1 : Type} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [DecidableRel r]\n    [IsTotal \u03b1 r] [IsTrans \u03b1 r] (a b : \u03b1) (hr : \u00ac r a b) : (l : List \u03b1) \u2192\n    List.orderedInsert r a (List.orderedInsert r b l) =\n      List.orderedInsert r b (List.orderedInsert r a l)\n  | [] => by\n    have hrb : r b a := by\n      have ht := IsTotal.total (r := r) a b\n      simp_all\n    simp [hr, hrb]\n  | c :: l => by\n    have hrb : r b a := by\n      have ht := IsTotal.total (r := r) a b\n      simp_all\n    simp only [List.orderedInsert]\n    by_cases h : r a c\n    \u00b7 simp only [h, \u2193reduceIte, List.orderedInsert.eq_2, hrb]\n      rw [if_pos]\n      simp only [List.orderedInsert, hr, \u2193reduceIte, h]\n      exact IsTrans.trans (r :=r) _ _ _ hrb h\n    \u00b7 simp only [h, \u2193reduceIte, List.orderedInsert.eq_2]\n      by_cases hbc : r b c\n      \u00b7 simp [hbc, hr, h]\n      \u00b7 simp only [hbc, \u2193reduceIte, List.orderedInsert.eq_2, h, List.cons.injEq, true_and]\n        exact orderedInsert_commute r a b hr l\n\nlemma insertionSort_orderedInsert_append {\u03b1 : Type} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [DecidableRel r]\n    [IsTotal \u03b1 r] [IsTrans \u03b1 r] (a : \u03b1) : (l1 l2 : List \u03b1) \u2192\n    List.insertionSort r (List.orderedInsert r a l1 ++ l2) = List.insertionSort r (a :: l1 ++ l2)\n  | [], l2 => by\n    simp\n  | b :: l1, l2 => by\n    conv_lhs => simp\n    by_cases h : r a b\n    \u00b7 simp [h]\n    conv_lhs => simp [h]\n    rw [insertionSort_orderedInsert_append r a l1 l2]\n    simp only [List.cons_append, List.insertionSort]\n    rw [orderedInsert_commute r a b h]\n\nlemma insertionSort_insertionSort_append {\u03b1 : Type} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [DecidableRel r]\n    [IsTotal \u03b1 r] [IsTrans \u03b1 r] : (l1 l2 : List \u03b1) \u2192\n    List.insertionSort r (List.insertionSort r l1 ++ l2) = List.insertionSort r (l1 ++ l2)\n  | [], l2 => by\n    simp\n  | a :: l1, l2 => by\n    conv_lhs => simp\n    rw [insertionSort_orderedInsert_append]\n    simp only [List.cons_append, List.insertionSort]\n    rw [insertionSort_insertionSort_append r l1 l2]\n\nlemma insertionSort_append_insertionSort_append {\u03b1 : Type} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [DecidableRel r]\n    [IsTotal \u03b1 r] [IsTrans \u03b1 r] : (l1 l2 l3 : List \u03b1) \u2192\n    List.insertionSort r (l1 ++ List.insertionSort r l2 ++ l3) =\n      List.insertionSort r (l1 ++ l2 ++ l3)\n  | [], l2, l3 => by\n    simp only [List.nil_append]\n    exact insertionSort_insertionSort_append r l2 l3\n  | a :: l1, l2, l3 => by\n    simp only [List.cons_append, List.insertionSort]\n    rw [insertionSort_append_insertionSort_append r l1 l2 l3]\n\n@[simp]\nlemma orderedInsert_length {\u03b1 : Type} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [DecidableRel r] (a : \u03b1) (l : List \u03b1) :\n    (List.orderedInsert r a l).length = (a :: l).length := by\n  apply List.Perm.length_eq\n  exact List.perm_orderedInsert r a l\n\nlemma takeWhile_orderedInsert {\u03b1 : Type} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [DecidableRel r]\n    [IsTotal \u03b1 r] [IsTrans \u03b1 r]\n    (a b : \u03b1) (hr : \u00ac r a b) : (l : List \u03b1) \u2192\n    (List.takeWhile (fun c => !decide (r a c)) (List.orderedInsert r b l)).length =\n    (List.takeWhile (fun c => !decide (r a c)) l).length + 1\n  | [] => by\n    simp [hr]\n  | c :: l => by\n    simp only [List.orderedInsert]\n    by_cases h : r b c\n    \u00b7 simp only [h, \u2193reduceIte]\n      rw [List.takeWhile_cons_of_pos]\n      simp only [List.length_cons]\n      simp [hr]\n    \u00b7 simp only [h, \u2193reduceIte]\n      have hrba : r b a:= by\n        have ht := IsTotal.total (r := r) a b\n        simp_all\n      have hl : \u00ac r a c := by\n        by_contra hn\n        apply h\n        exact IsTrans.trans _ _ _ hrba hn\n      simp only [hl, decide_false, Bool.not_false, List.takeWhile_cons_of_pos, List.length_cons,\n        add_left_inj]\n      exact takeWhile_orderedInsert r a b hr l\n\nlemma takeWhile_orderedInsert' {\u03b1 : Type} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [DecidableRel r]\n    [IsTotal \u03b1 r] [IsTrans \u03b1 r]\n    (a b : \u03b1) (hr : \u00ac r a b) : (l : List \u03b1) \u2192\n    (List.takeWhile (fun c => !decide (r b c)) (List.orderedInsert r a l)).length =\n    (List.takeWhile (fun c => !decide (r b c)) l).length\n  | [] => by\n    simp only [List.orderedInsert, List.takeWhile_nil, List.length_nil, List.length_eq_zero,\n      List.takeWhile_eq_nil_iff, List.length_singleton, zero_lt_one, Fin.zero_eta, Fin.isValue,\n      List.get_eq_getElem, Fin.val_eq_zero, List.getElem_cons_zero, Bool.not_eq_eq_eq_not,\n      Bool.not_true, decide_eq_false_iff_not, Decidable.not_not, forall_const]\n    have ht := IsTotal.total (r := r) a b\n    simp_all\n  | c :: l => by\n    have hrba : r b a:= by\n      have ht := IsTotal.total (r := r) a b\n      simp_all\n    simp only [List.orderedInsert]\n    by_cases h : r b c\n    \u00b7 simp only [h, decide_true, Bool.not_true, Bool.false_eq_true, not_false_eq_true,\n      List.takeWhile_cons_of_neg, List.length_nil, List.length_eq_zero, List.takeWhile_eq_nil_iff,\n      List.get_eq_getElem, Bool.not_eq_eq_eq_not, decide_eq_false_iff_not, Decidable.not_not]\n      by_cases hac : r a c\n      \u00b7 simp [hac, hrba]\n      \u00b7 simp [hac, h]\n    \u00b7 by_cases hac : r a c\n      \u00b7 refine False.elim (h ?_)\n        exact IsTrans.trans _ _ _ hrba hac\n      \u00b7 simp only [hac, \u2193reduceIte, h, decide_false, Bool.not_false, List.takeWhile_cons_of_pos,\n        List.length_cons, add_left_inj]\n        exact takeWhile_orderedInsert' r a b hr l\n\n", "theoremStatement": "lemma insertionSortEquiv_commute {\u03b1 : Type} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [DecidableRel r]\n    [IsTotal \u03b1 r] [IsTrans \u03b1 r] (a b : \u03b1) (hr : \u00ac r a b) (n : \u2115) : (l : List \u03b1) \u2192\n    (hn : n + 2 < (a :: b :: l).length) \u2192\n    insertionSortEquiv r (a :: b :: l) \u27e8n + 2, hn\u27e9 = (finCongr (by simp))\n    (insertionSortEquiv r (b :: a :: l) \u27e8n + 2, hn\u27e9) ", "theoremName": "HepLean.List.insertionSortEquiv_commute", "fileCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "theoremCreated": {"commit": "a79d0f8fed26c4d3ba883ce07d6348e6756dc03c", "date": "2025-01-28"}, "file": "HepLean/HepLean/Mathematics/List/InsertionSort.lean", "module": "HepLean.Mathematics.List.InsertionSort", "jsonFile": "HepLean.Mathematics.List.InsertionSort.jsonl", "positionMetadata": {"lineInFile": 224, "tokenPositionInFile": 9650, "theoremPositionInFile": 8}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 12, "numPremises": 180}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  have hrba : r b a:= by\n    have ht := IsTotal.total (r := r) a b\n    simp_all\n  intro l hn\n  simp only [List.insertionSort, List.length_cons, insertionSortEquiv, Nat.succ_eq_add_one,\n    equivCons_trans, Equiv.trans_apply, equivCons_succ, finCongr_apply]\n  conv_lhs => erw [equivCons_succ]\n  conv_rhs => erw [equivCons_succ]\n  simp only [Equiv.toFun_as_coe]\n  conv_lhs =>\n    rhs\n    rhs\n    erw [orderedInsertEquiv_succ]\n  conv_lhs => erw [orderedInsertEquiv_fin_succ]\n  simp only [Fin.eta, Fin.coe_cast]\n  conv_rhs =>\n    rhs\n    rhs\n    erw [orderedInsertEquiv_succ]\n  conv_rhs => erw [orderedInsertEquiv_fin_succ]\n  ext\n  simp only [Fin.coe_cast, Fin.eta, Fin.cast_trans]\n  let a1 : Fin ((List.orderedInsert r b (List.insertionSort r l)).length + 1) :=\n    \u27e8\u2191(orderedInsertPos r (List.orderedInsert r b (List.insertionSort r l)) a),\n      orderedInsertPos_lt_length r (List.orderedInsert r b (List.insertionSort r l)) a\u27e9\n  let b1 : Fin ((List.insertionSort r l).length + 1) :=\n    \u27e8\u2191(orderedInsertPos r (List.insertionSort r l) b),\n      orderedInsertPos_lt_length r (List.insertionSort r l) b\u27e9\n  let a2 : Fin ((List.insertionSort r l).length + 1) :=\n    \u27e8\u2191(orderedInsertPos r (List.insertionSort r l) a),\n      orderedInsertPos_lt_length r (List.insertionSort r l) a\u27e9\n  let b2 : Fin ((List.orderedInsert r a (List.insertionSort r l)).length + 1) :=\n    \u27e8\u2191(orderedInsertPos r (List.orderedInsert r a (List.insertionSort r l)) b),\n      orderedInsertPos_lt_length r (List.orderedInsert r a (List.insertionSort r l)) b\u27e9\n  have ht : (List.takeWhile (fun c => !decide (r b c)) (List.insertionSort r l))\n      = (List.takeWhile (fun c => !decide (r b c))\n        ((List.takeWhile (fun c => !decide (r a c)) (List.insertionSort r l)))) := by\n      rw [List.takeWhile_takeWhile]\n      simp only [Bool.not_eq_eq_eq_not, Bool.not_true, decide_eq_false_iff_not, Bool.decide_and,\n        decide_not]\n      congr\n      funext c\n      simp only [Bool.iff_self_and, Bool.not_eq_eq_eq_not, Bool.not_true, decide_eq_false_iff_not]\n      intro hbc hac\n      refine hbc ?_\n      exact IsTrans.trans _ _ _ hrba hac\n  have ha1 : b1.1 \u2264 a2.1 := by\n    simp only [orderedInsertPos, decide_not, b1, b2]\n    rw [ht]\n    apply List.Sublist.length_le\n    simp only [decide_not, b1]\n    exact List.takeWhile_sublist _\n  have ha2 : a1.1 = a2.1 + 1 := by\n    simp only [orderedInsertPos, decide_not, a1, a2]\n    rw [takeWhile_orderedInsert]\n    exact hr\n  have hb : b1.1 = b2.1 := by\n    simp only [orderedInsertPos, decide_not, b1, b2]\n    rw [takeWhile_orderedInsert']\n    exact hr\n  let n := ((insertionSortEquiv r l) \u27e8n, by simpa using hn\u27e9)\n  change (a1.succAbove \u27e8b1.succAbove n, _\u27e9).1 = (b2.succAbove \u27e8a2.succAbove n, _\u27e9).1\n  trans if (b1.succAbove n).1 < a1.1 then (b1.succAbove n).1 else (b1.succAbove n).1 + 1\n  \u00b7 rw [Fin.succAbove]\n    simp only [Fin.castSucc_mk, Fin.lt_def, Fin.succ_mk]\n    by_cases ha : (b1.succAbove n).1 < a1.1\n    \u00b7 simp [ha]\n    \u00b7 simp [ha]\n  trans if (a2.succAbove n).1 < b2.1 then (a2.succAbove n).1 else (a2.succAbove n).1 + 1\n  swap\n  \u00b7 conv_rhs => rw [Fin.succAbove]\n    simp only [Fin.castSucc_mk, Fin.lt_def, Fin.succ_mk]\n    by_cases ha : (a2.succAbove n).1 < b2.1\n    \u00b7 simp [ha]\n    \u00b7 simp [ha]\n  have hbs1 : (b1.succAbove n).1 = if n.1 < b1.1 then n.1 else n.1 + 1 := by\n    rw [Fin.succAbove]\n    simp only [Fin.castSucc_mk, Fin.lt_def, Fin.succ_mk]\n    by_cases ha : n.1 < b1.1\n    \u00b7 simp [ha]\n    \u00b7 simp [ha]\n  have has2 : (a2.succAbove n).1 = if n.1 < a2.1 then n.1 else n.1 + 1 := by\n    rw [Fin.succAbove]\n    simp only [Fin.castSucc_mk, Fin.lt_def, Fin.succ_mk]\n    by_cases ha : n.1 < a2.1\n    \u00b7 simp [ha]\n    \u00b7 simp [ha]\n  rw [hbs1, has2, hb, ha2]\n  have hnat (a2 b2 n : \u2115) (h : b2 \u2264 a2) : (if (if \u2191n < \u2191b2 then \u2191n else \u2191n + 1) < \u2191a2 + 1 then\n      if \u2191n < \u2191b2 then \u2191n else \u2191n + 1\n      else (if \u2191n < \u2191b2 then \u2191n else \u2191n + 1) + 1) =\n      if (if \u2191n < \u2191a2 then \u2191n else \u2191n + 1) < \u2191b2 then if \u2191n < \u2191a2 then \u2191n else \u2191n + 1\n      else (if \u2191n < \u2191a2 then \u2191n else \u2191n + 1) + 1 := by\n    by_cases hnb2 : n < b2\n    \u00b7 simp only [hnb2, \u2193reduceIte]\n      have h1 : n < a2 + 1 := by omega\n      have h2 : n < a2 := by omega\n      simp [h1, h2, hnb2]\n    \u00b7 simp only [hnb2, \u2193reduceIte, add_lt_add_iff_right]\n      by_cases ha2 : n < a2\n      \u00b7 simp [ha2, hnb2]\n      \u00b7 simp only [ha2, \u2193reduceIte]\n        rw [if_neg]\n        omega\n  apply hnat\n  rw [\u2190 hb]\n  exact ha1", "proofType": "tactic", "proofLengthLines": 107, "proofLengthTokens": 4389}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.SuperCommute\nimport Mathlib.Algebra.RingQuot\nimport Mathlib.RingTheory.TwoSidedIdeal.Operations\n/-!\n\n# Field operator algebra\n\n-/\n\nnamespace FieldSpecification\nopen FieldOpFreeAlgebra\nopen HepLean.List\nopen FieldStatistic\n\nvariable (\ud835\udcd5 : FieldSpecification)\n\n/-- The set contains the super-commutators equal to zero in the operator algebra.\n  This contains e.g. the super-commutator of two creation operators. -/\ndef fieldOpIdealSet : Set (FieldOpFreeAlgebra \ud835\udcd5) :=\n  { x |\n    (\u2203 (\u03c61 \u03c62 \u03c63 : \ud835\udcd5.CrAnFieldOp),\n        x = [ofCrAnOpF \u03c61, [ofCrAnOpF \u03c62, ofCrAnOpF \u03c63]\u209bca]\u209bca)\n    \u2228 (\u2203 (\u03c6c \u03c6c' : \ud835\udcd5.CrAnFieldOp) (_ : \ud835\udcd5 |>\u1d9c \u03c6c = .create) (_ : \ud835\udcd5 |>\u1d9c \u03c6c' = .create),\n      x = [ofCrAnOpF \u03c6c, ofCrAnOpF \u03c6c']\u209bca)\n    \u2228 (\u2203 (\u03c6a \u03c6a' : \ud835\udcd5.CrAnFieldOp) (_ : \ud835\udcd5 |>\u1d9c \u03c6a = .annihilate) (_ : \ud835\udcd5 |>\u1d9c \u03c6a' = .annihilate),\n      x = [ofCrAnOpF \u03c6a, ofCrAnOpF \u03c6a']\u209bca)\n    \u2228 (\u2203 (\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp) (_ : \u00ac (\ud835\udcd5 |>\u209b \u03c6) = (\ud835\udcd5 |>\u209b \u03c6')),\n      x = [ofCrAnOpF \u03c6, ofCrAnOpF \u03c6']\u209bca)}\n\n/-- For a field specification `\ud835\udcd5`, the algebra `\ud835\udcd5.FieldOpAlgebra` is defined as the quotient\n  of the free algebra `\ud835\udcd5.FieldOpFreeAlgebra` by the ideal generated by\n- `[ofCrAnOpF \u03c6c, ofCrAnOpF \u03c6c']\u209bca` for `\u03c6c` and `\u03c6c'` field creation operators.\n  This corresponds to the condition that two creation operators always super-commute.\n- `[ofCrAnOpF \u03c6a, ofCrAnOpF \u03c6a']\u209bca` for `\u03c6a` and `\u03c6a'` field annihilation operators.\n  This corresponds to the condition that two annihilation operators always super-commute.\n- `[ofCrAnOpF \u03c6, ofCrAnOpF \u03c6']\u209bca` for `\u03c6` and `\u03c6'` operators with different statistics.\n  This corresponds to the condition that two operators with different statistics always\n  super-commute. In other words, fermions and bosons always super-commute.\n- `[ofCrAnOpF \u03c61, [ofCrAnOpF \u03c62, ofCrAnOpF \u03c63]\u209bca]\u209bca`. This corresponds to the condition,\n  when combined with the conditions above, that the super-commutator is in the center of the\n  of the algebra.\n-/\nabbrev FieldOpAlgebra : Type := (TwoSidedIdeal.span \ud835\udcd5.fieldOpIdealSet).ringCon.Quotient\n\nnamespace FieldOpAlgebra\nvariable {\ud835\udcd5 : FieldSpecification}\n\n/-- The instance of a setoid on `FieldOpFreeAlgebra` from the ideal `TwoSidedIdeal`. -/\ninstance : Setoid (FieldOpFreeAlgebra \ud835\udcd5) := (TwoSidedIdeal.span \ud835\udcd5.fieldOpIdealSet).ringCon.toSetoid\n\nlemma equiv_iff_sub_mem_ideal (x y : FieldOpFreeAlgebra \ud835\udcd5) :\n    x \u2248 y \u2194 x - y \u2208 TwoSidedIdeal.span \ud835\udcd5.fieldOpIdealSet := by\n  rw [\u2190 TwoSidedIdeal.rel_iff]\n  rfl\n\nlemma equiv_iff_exists_add (x y : FieldOpFreeAlgebra \ud835\udcd5) :\n    x \u2248 y \u2194 \u2203 a, x = y + a \u2227 a \u2208 TwoSidedIdeal.span \ud835\udcd5.fieldOpIdealSet := by\n  apply Iff.intro\n  \u00b7 intro h\n    rw [equiv_iff_sub_mem_ideal] at h\n    use x - y\n    simp [h]\n  \u00b7 intro h\n    obtain \u27e8a, rfl, ha\u27e9 := h\n    rw [equiv_iff_sub_mem_ideal]\n    simp [ha]\n\n/-- For a field specification `\ud835\udcd5`, the projection\n\n`\ud835\udcd5.FieldOpFreeAlgebra \u2192\u2090[\u2102] FieldOpAlgebra \ud835\udcd5`\n\ntaking each element of `\ud835\udcd5.FieldOpFreeAlgebra` to its equivalence class in `FieldOpAlgebra \ud835\udcd5`. -/\ndef \u03b9 : FieldOpFreeAlgebra \ud835\udcd5 \u2192\u2090[\u2102] FieldOpAlgebra \ud835\udcd5 where\n  toFun := (TwoSidedIdeal.span \ud835\udcd5.fieldOpIdealSet).ringCon.mk'\n  map_one' := by rfl\n  map_mul' x y := by rfl\n  map_zero' := by rfl\n  map_add' x y := by rfl\n  commutes' x := by rfl\n\nlemma \u03b9_surjective : Function.Surjective (@\u03b9 \ud835\udcd5) := by\n  intro x\n  obtain \u27e8x\u27e9 := x\n  use x\n  rfl\n\nlemma \u03b9_apply (x : FieldOpFreeAlgebra \ud835\udcd5) : \u03b9 x = Quotient.mk _ x := rfl\n\nlemma \u03b9_of_mem_fieldOpIdealSet (x : FieldOpFreeAlgebra \ud835\udcd5) (hx : x \u2208 \ud835\udcd5.fieldOpIdealSet) :\n    \u03b9 x = 0 := by\n  rw [\u03b9_apply]\n  change \u27e6x\u27e7 = \u27e60\u27e7\n  simp only [ringConGen, Quotient.eq]\n  refine RingConGen.Rel.of x 0 ?_\n  simpa using hx\n\nlemma \u03b9_superCommuteF_of_create_create (\u03c6c \u03c6c' : \ud835\udcd5.CrAnFieldOp) (h\u03c6c : \ud835\udcd5 |>\u1d9c \u03c6c = .create)\n    (h\u03c6c' : \ud835\udcd5 |>\u1d9c \u03c6c' = .create) : \u03b9 [ofCrAnOpF \u03c6c, ofCrAnOpF \u03c6c']\u209bca = 0 := by\n  apply \u03b9_of_mem_fieldOpIdealSet\n  simp only [fieldOpIdealSet, exists_and_left, Set.mem_setOf_eq]\n  simp only [exists_prop]\n  right\n  left\n  use \u03c6c, \u03c6c', h\u03c6c, h\u03c6c'\n\nlemma \u03b9_superCommuteF_of_annihilate_annihilate (\u03c6a \u03c6a' : \ud835\udcd5.CrAnFieldOp)\n    (h\u03c6a : \ud835\udcd5 |>\u1d9c \u03c6a = .annihilate) (h\u03c6a' : \ud835\udcd5 |>\u1d9c \u03c6a' = .annihilate) :\n    \u03b9 [ofCrAnOpF \u03c6a, ofCrAnOpF \u03c6a']\u209bca = 0 := by\n  apply \u03b9_of_mem_fieldOpIdealSet\n  simp only [fieldOpIdealSet, exists_and_left, Set.mem_setOf_eq]\n  simp only [exists_prop]\n  right\n  right\n  left\n  use \u03c6a, \u03c6a', h\u03c6a, h\u03c6a'\n\nlemma \u03b9_superCommuteF_of_diff_statistic {\u03c6 \u03c8 : \ud835\udcd5.CrAnFieldOp}\n    (h : (\ud835\udcd5 |>\u209b \u03c6) \u2260 (\ud835\udcd5 |>\u209b \u03c8)) : \u03b9 [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca = 0 := by\n  apply \u03b9_of_mem_fieldOpIdealSet\n  simp only [fieldOpIdealSet, exists_prop, exists_and_left, Set.mem_setOf_eq]\n  right\n  right\n  right\n  use \u03c6, \u03c8\n\nlemma \u03b9_superCommuteF_zero_of_fermionic (\u03c6 \u03c8 : \ud835\udcd5.CrAnFieldOp)\n    (h : [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca \u2208 statisticSubmodule fermionic) :\n    \u03b9 [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca = 0 := by\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton] at h \u22a2\n  rcases statistic_neq_of_superCommuteF_fermionic h with h | h\n  \u00b7 simp only [ofCrAnListF_singleton]\n    apply \u03b9_superCommuteF_of_diff_statistic\n    simpa using h\n  \u00b7 simp [h]\n\nlemma \u03b9_superCommuteF_ofCrAnOpF_ofCrAnOpF_bosonic_or_zero (\u03c6 \u03c8 : \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca \u2208 statisticSubmodule bosonic \u2228\n    \u03b9 [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca = 0 := by\n  rcases superCommuteF_ofCrAnListF_ofCrAnListF_bosonic_or_fermionic [\u03c6] [\u03c8] with h | h\n  \u00b7 simp_all [ofCrAnListF_singleton]\n  \u00b7 simp_all only [ofCrAnListF_singleton]\n    right\n    exact \u03b9_superCommuteF_zero_of_fermionic _ _ h\n\n/-!\n\n## Super-commutes are in the center\n\n-/\n\n", "theoremStatement": "@[simp]\nlemma \u03b9_superCommuteF_ofCrAnOpF_superCommuteF_ofCrAnOpF_ofCrAnOpF (\u03c61 \u03c62 \u03c63 : \ud835\udcd5.CrAnFieldOp) :\n    \u03b9 [ofCrAnOpF \u03c61, [ofCrAnOpF \u03c62, ofCrAnOpF \u03c63]\u209bca]\u209bca = 0 ", "theoremName": "FieldSpecification.FieldOpAlgebra.\u03b9_superCommuteF_ofCrAnOpF_superCommuteF_ofCrAnOpF_ofCrAnOpF", "fileCreated": {"commit": "ea6e12829370d9630a7e65200c8349e9086c05ba", "date": "2025-02-03"}, "theoremCreated": {"commit": "171e80fc04016aed422340742f3e0a14de6d20b0", "date": "2025-02-03"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpAlgebra/Basic.lean", "module": "HepLean.PerturbationTheory.FieldOpAlgebra.Basic", "jsonFile": "HepLean.PerturbationTheory.FieldOpAlgebra.Basic.jsonl", "positionMetadata": {"lineInFile": 156, "tokenPositionInFile": 5651, "theoremPositionInFile": 12}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 15, "numPremises": 78}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  apply \u03b9_of_mem_fieldOpIdealSet\n  simp only [fieldOpIdealSet, exists_prop, exists_and_left, Set.mem_setOf_eq]\n  left\n  use \u03c61, \u03c62, \u03c63", "proofType": "tactic", "proofLengthLines": 4, "proofLengthTokens": 140}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.Basic\nimport Mathlib.RingTheory.GradedAlgebra.Basic\n/-!\n\n# Grading on the FieldOpFreeAlgebra\n\n-/\n\nnamespace FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\nopen FieldStatistic\n\nnamespace FieldOpFreeAlgebra\n\nnoncomputable section\n\n/-- The submodule of `FieldOpFreeAlgebra` spanned by lists of field statistic `f`. -/\ndef statisticSubmodule (f : FieldStatistic) : Submodule \u2102 \ud835\udcd5.FieldOpFreeAlgebra :=\n  Submodule.span \u2102 {a | \u2203 \u03c6s, a = ofCrAnListF \u03c6s \u2227 (\ud835\udcd5 |>\u209b \u03c6s) = f}\n\nlemma ofCrAnListF_mem_statisticSubmodule_of (\u03c6s : List \ud835\udcd5.CrAnFieldOp) (f : FieldStatistic)\n    (h : (\ud835\udcd5 |>\u209b \u03c6s) = f) :\n    ofCrAnListF \u03c6s \u2208 statisticSubmodule f := by\n  refine Submodule.mem_span.mpr fun _ a => a \u27e8\u03c6s, \u27e8rfl, h\u27e9\u27e9\n\n", "theoremStatement": "lemma ofCrAnListF_bosonic_or_fermionic (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnListF \u03c6s \u2208 statisticSubmodule bosonic \u2228\n    ofCrAnListF \u03c6s \u2208 statisticSubmodule fermionic ", "theoremName": "FieldSpecification.FieldOpFreeAlgebra.ofCrAnListF_bosonic_or_fermionic", "fileCreated": {"commit": "ea6e12829370d9630a7e65200c8349e9086c05ba", "date": "2025-02-03"}, "theoremCreated": {"commit": "171e80fc04016aed422340742f3e0a14de6d20b0", "date": "2025-02-03"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpFreeAlgebra/Grading.lean", "module": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.Grading", "jsonFile": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.Grading.jsonl", "positionMetadata": {"lineInFile": 31, "tokenPositionInFile": 913, "theoremPositionInFile": 2}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 13, "numPremises": 38}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  by_cases h : (\ud835\udcd5 |>\u209b \u03c6s) = bosonic\n  \u00b7 left\n    exact ofCrAnListF_mem_statisticSubmodule_of \u03c6s bosonic h\n  \u00b7 right\n    exact ofCrAnListF_mem_statisticSubmodule_of \u03c6s fermionic (by simpa using h)", "proofType": "tactic", "proofLengthLines": 5, "proofLengthTokens": 201}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.WickContraction.Sign.Basic\nimport HepLean.PerturbationTheory.FieldOpAlgebra.TimeContraction\n/-!\n\n# Time contractions\n\n-/\n\nopen FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\nnamespace WickContraction\nvariable {n : \u2115} (c : WickContraction n)\nopen HepLean.List\nopen FieldOpAlgebra\n\n/-- For a list `\u03c6s` of `\ud835\udcd5.FieldOp` and a Wick contraction `\u03c6s\u039b` the\n  element of the center of `\ud835\udcd5.FieldOpAlgebra`, `\u03c6s\u039b.timeContract` is defined as the product\n  of `timeContract \u03c6s[j] \u03c6s[k]` over contracted pairs `{j, k}` in `\u03c6s\u039b`\n  with `j < k`. -/\nnoncomputable def timeContract {\u03c6s : List \ud835\udcd5.FieldOp}\n    (\u03c6s\u039b : WickContraction \u03c6s.length) :\n    Subalgebra.center \u2102 \ud835\udcd5.FieldOpAlgebra :=\n  \u220f (a : \u03c6s\u039b.1), \u27e8FieldOpAlgebra.timeContract\n    (\u03c6s.get (\u03c6s\u039b.fstFieldOfContract a)) (\u03c6s.get (\u03c6s\u039b.sndFieldOfContract a)),\n    timeContract_mem_center _ _\u27e9\n\n/-- For a list `\u03c6s = \u03c6\u2080\u2026\u03c6\u2099` of `\ud835\udcd5.FieldOp`, a Wick contraction `\u03c6s\u039b` of `\u03c6s`, an element `\u03c6` of\n  `\ud835\udcd5.FieldOp`, and a `i \u2264 \u03c6s.length` the following relation holds\n\n  `(\u03c6s\u039b \u21a9\u039b \u03c6 i none).timeContract = \u03c6s\u039b.timeContract`\n\n  The prove of this result ultimately a consequence of definitions. -/\n@[simp]\nlemma timeContract_insert_none (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp)\n    (\u03c6s\u039b : WickContraction \u03c6s.length) (i : Fin \u03c6s.length.succ) :\n    (\u03c6s\u039b \u21a9\u039b \u03c6 i none).timeContract = \u03c6s\u039b.timeContract := by\n  rw [timeContract, insertAndContract_none_prod_contractions]\n  congr\n  ext a\n  simp\n\n/-- For a list `\u03c6s = \u03c6\u2080\u2026\u03c6\u2099` of `\ud835\udcd5.FieldOp`, a Wick contraction `\u03c6s\u039b` of `\u03c6s`, an element `\u03c6` of\n  `\ud835\udcd5.FieldOp`, a `i \u2264 \u03c6s.length` and a `k` in `\u03c6s\u039b.uncontracted`, then\n  `(\u03c6s\u039b \u21a9\u039b \u03c6 i (some k)).timeContract` is equal to the product of\n  - `timeContract \u03c6 \u03c6s[k]` if `i \u2264 k` or `timeContract \u03c6s[k] \u03c6` if `k < i`\n  - `\u03c6s\u039b.timeContract`.\n\n  The proof of this result ultimately a consequence of definitions. -/\nlemma timeContract_insertAndContract_some\n    (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp)\n    (\u03c6s\u039b : WickContraction \u03c6s.length) (i : Fin \u03c6s.length.succ) (j : \u03c6s\u039b.uncontracted) :\n    (\u03c6s\u039b \u21a9\u039b \u03c6 i (some j)).timeContract =\n    (if i < i.succAbove j then\n      \u27e8FieldOpAlgebra.timeContract \u03c6 \u03c6s[j.1], timeContract_mem_center _ _\u27e9\n    else \u27e8FieldOpAlgebra.timeContract \u03c6s[j.1] \u03c6, timeContract_mem_center _ _\u27e9) *\n    \u03c6s\u039b.timeContract := by\n  rw [timeContract, insertAndContract_some_prod_contractions]\n  congr 1\n  \u00b7 simp only [Nat.succ_eq_add_one, insertAndContract_fstFieldOfContract_some_incl, finCongr_apply,\n    List.get_eq_getElem, insertAndContract_sndFieldOfContract_some_incl, Fin.getElem_fin]\n    split\n    \u00b7 simp\n    \u00b7 simp\n  \u00b7 congr\n    ext a\n    simp\n\n@[simp]\nlemma timeContract_empty (\u03c6s : List \ud835\udcd5.FieldOp) :\n    (@empty \u03c6s.length).timeContract = 1 := by\n  rw [timeContract, empty]\n  simp\n\nopen FieldStatistic\n\n/-- For a list `\u03c6s = \u03c6\u2080\u2026\u03c6\u2099` of `\ud835\udcd5.FieldOp`, a Wick contraction `\u03c6s\u039b` of `\u03c6s`, an element `\u03c6` of\n  `\ud835\udcd5.FieldOp`, a `i \u2264 \u03c6s.length` and a `k` in `\u03c6s\u039b.uncontracted` such that `i \u2264 k`, with the\n  condition that `\u03c6` has greater or equal time to `\u03c6s[k]`, then\n  `(\u03c6s\u039b \u21a9\u039b \u03c6 i (some k)).timeContract` is equal to the product of\n  - `[anPart \u03c6, \u03c6s[k]]\u209b`\n  - `\u03c6s\u039b.timeContract`\n  - two copies of the exchange sign of `\u03c6` with the uncontracted fields in `\u03c6\u2080\u2026\u03c6\u2096\u208b\u2081`.\n    These two exchange signs cancel each other out but are included for convenience.\n\n  The proof of this result ultimately a consequence of definitions and\n  `timeContract_of_timeOrderRel`. -/\nlemma timeContract_insert_some_of_lt\n    (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp)\n    (\u03c6s\u039b : WickContraction \u03c6s.length) (i : Fin \u03c6s.length.succ) (k : \u03c6s\u039b.uncontracted)\n    (ht : \ud835\udcd5.timeOrderRel \u03c6 \u03c6s[k.1]) (hik : i < i.succAbove k) :\n    (\u03c6s\u039b \u21a9\u039b \u03c6 i (some k)).timeContract =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u27e8\u03c6s.get, (\u03c6s\u039b.uncontracted.filter (fun x => x < k))\u27e9)\n    \u2022 (contractStateAtIndex \u03c6 [\u03c6s\u039b]\u1d58\u1d9c ((uncontractedFieldOpEquiv \u03c6s \u03c6s\u039b) (some k)) *\n      \u03c6s\u039b.timeContract) := by\n  rw [timeContract_insertAndContract_some]\n  simp only [Nat.succ_eq_add_one, Fin.getElem_fin, ite_mul, instCommGroup.eq_1,\n    contractStateAtIndex, uncontractedFieldOpEquiv, Equiv.optionCongr_apply,\n    Equiv.coe_trans, Option.map_some', Function.comp_apply, finCongr_apply, Fin.coe_cast,\n    List.getElem_map, uncontractedList_getElem_uncontractedIndexEquiv_symm, List.get_eq_getElem,\n    Algebra.smul_mul_assoc, uncontractedListGet]\n  \u00b7 simp only [hik, \u2193reduceIte, MulMemClass.coe_mul]\n    rw [timeContract_of_timeOrderRel]\n    trans (1 : \u2102) \u2022 ((superCommute (anPart \u03c6)) (ofFieldOp \u03c6s[k.1]) * \u2191\u03c6s\u039b.timeContract)\n    \u00b7 simp\n    simp only [smul_smul]\n    congr 1\n    have h1 : ofList \ud835\udcd5.fieldOpStatistic (List.take (\u2191(\u03c6s\u039b.uncontractedIndexEquiv.symm k))\n        (List.map \u03c6s.get \u03c6s\u039b.uncontractedList))\n        = (\ud835\udcd5 |>\u209b \u27e8\u03c6s.get, (Finset.filter (fun x => x < k) \u03c6s\u039b.uncontracted)\u27e9) := by\n      simp only [ofFinset]\n      congr\n      rw [\u2190 List.map_take]\n      congr\n      rw [take_uncontractedIndexEquiv_symm]\n      rw [filter_uncontractedList]\n    rw [h1]\n    simp only [exchangeSign_mul_self]\n    \u00b7 exact ht\n\n", "theoremStatement": "/-- For a list `\u03c6s = \u03c6\u2080\u2026\u03c6\u2099` of `\ud835\udcd5.FieldOp`, a Wick contraction `\u03c6s\u039b` of `\u03c6s`, an element `\u03c6` of\n  `\ud835\udcd5.FieldOp`, a `i \u2264 \u03c6s.length` and a `k` in `\u03c6s\u039b.uncontracted` such that `k < i`, with the\n  condition that `\u03c6s[k]` does not have time greater or equal to `\u03c6`, then\n  `(\u03c6s\u039b \u21a9\u039b \u03c6 i (some k)).timeContract` is equal to the product of\n  - `[anPart \u03c6, \u03c6s[k]]\u209b`\n  - `\u03c6s\u039b.timeContract`\n  - the exchange sign of `\u03c6` with the uncontracted fields in `\u03c6\u2080\u2026\u03c6\u2096\u208b\u2081`.\n  - the exchange sign of `\u03c6` with the uncontracted fields in `\u03c6\u2080\u2026\u03c6\u2096`.\n\n  The proof of this result ultimately a consequence of definitions and\n  `timeContract_of_not_timeOrderRel_expand`. -/\nlemma timeContract_insert_some_of_not_lt\n    (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp)\n    (\u03c6s\u039b : WickContraction \u03c6s.length) (i : Fin \u03c6s.length.succ) (k : \u03c6s\u039b.uncontracted)\n    (ht : \u00ac \ud835\udcd5.timeOrderRel \u03c6s[k.1] \u03c6) (hik : \u00ac i < i.succAbove k) :\n    (\u03c6s\u039b \u21a9\u039b \u03c6 i (some k)).timeContract =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u27e8\u03c6s.get, (\u03c6s\u039b.uncontracted.filter (fun x => x \u2264 k))\u27e9)\n    \u2022 (contractStateAtIndex \u03c6 [\u03c6s\u039b]\u1d58\u1d9c\n      ((uncontractedFieldOpEquiv \u03c6s \u03c6s\u039b) (some k)) * \u03c6s\u039b.timeContract) ", "theoremName": "WickContraction.timeContract_insert_some_of_not_lt", "fileCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "theoremCreated": {"commit": "8434334bbfbf99e266d8f5c6762fc3b623a99e9d", "date": "2025-02-05"}, "file": "HepLean/HepLean/PerturbationTheory/WickContraction/TimeContract.lean", "module": "HepLean.PerturbationTheory.WickContraction.TimeContract", "jsonFile": "HepLean.PerturbationTheory.WickContraction.TimeContract.jsonl", "positionMetadata": {"lineInFile": 126, "tokenPositionInFile": 5135, "theoremPositionInFile": 5}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 39, "numPremises": 329}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [timeContract_insertAndContract_some]\n  simp only [Nat.succ_eq_add_one, Fin.getElem_fin, ite_mul, instCommGroup.eq_1,\n    contractStateAtIndex, uncontractedFieldOpEquiv, Equiv.optionCongr_apply,\n    Equiv.coe_trans, Option.map_some', Function.comp_apply, finCongr_apply, Fin.coe_cast,\n    List.getElem_map, uncontractedList_getElem_uncontractedIndexEquiv_symm, List.get_eq_getElem,\n    Algebra.smul_mul_assoc, uncontractedListGet]\n  simp only [hik, \u2193reduceIte, MulMemClass.coe_mul]\n  rw [timeContract_of_not_timeOrderRel, timeContract_of_timeOrderRel]\n  simp only [instCommGroup.eq_1, Algebra.smul_mul_assoc, smul_smul]\n  congr\n  have h1 : ofList \ud835\udcd5.fieldOpStatistic (List.take (\u2191(\u03c6s\u039b.uncontractedIndexEquiv.symm k))\n      (List.map \u03c6s.get \u03c6s\u039b.uncontractedList))\n      = (\ud835\udcd5 |>\u209b \u27e8\u03c6s.get, (Finset.filter (fun x => x < k) \u03c6s\u039b.uncontracted)\u27e9) := by\n    simp only [ofFinset]\n    congr\n    rw [\u2190 List.map_take]\n    congr\n    rw [take_uncontractedIndexEquiv_symm, filter_uncontractedList]\n  rw [h1]\n  trans \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u27e8\u03c6s.get, {k.1}\u27e9)\n  \u00b7 rw [exchangeSign_symm, ofFinset_singleton]\n    simp\n  rw [\u2190 map_mul]\n  congr\n  rw [ofFinset_union]\n  congr\n  ext a\n  simp only [Finset.mem_singleton, Finset.mem_sdiff, Finset.mem_union, Finset.mem_filter,\n    Finset.mem_inter, not_and, not_lt, and_imp]\n  apply Iff.intro\n  \u00b7 intro h\n    subst h\n    simp\n  \u00b7 intro h\n    have h1 := h.1\n    rcases h1 with h1 | h1\n    \u00b7 have h2' := h.2 h1.1 h1.2 h1.1\n      omega\n    \u00b7 have h2' := h.2 h1.1 (by omega) h1.1\n      omega\n  have ht := IsTotal.total (r := timeOrderRel) \u03c6s[k.1] \u03c6\n  simp_all only [Fin.getElem_fin, Nat.succ_eq_add_one, not_lt, false_or]\n  exact ht", "proofType": "tactic", "proofLengthLines": 43, "proofLengthTokens": 1654}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldSpecification.CrAnFieldOp\nimport HepLean.PerturbationTheory.FieldSpecification.CrAnSection\n/-!\n\n# Creation and annihilation free-algebra\n\nThis module defines the creation and annihilation algebra for a field structure.\n\nThe creation and annihilation algebra extends from the state algebra by adding information about\nwhether a state is a creation or annihilation operator.\n\nThe algebra is spanned by lists of creation/annihilation states.\n\nThe main structures defined in this module are:\n\n* `FieldOpFreeAlgebra` - The creation and annihilation algebra\n* `ofCrAnOpF` - Maps a creation/annihilation state to the algebra\n* `ofCrAnListF` - Maps a list of creation/annihilation states to the algebra\n* `ofFieldOpF` - Maps a state to a sum of creation and annihilation operators\n* `crPartF` - The creation part of a state in the algebra\n* `anPartF` - The annihilation part of a state in the algebra\n* `superCommuteF` - The super commutator on the algebra\n\nThe key lemmas show how these operators interact, particularly focusing on the\nsuper commutation relations between creation and annihilation operators.\n\n-/\n\nnamespace FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\n/-- For a field specification `\ud835\udcd5`, the algebra `\ud835\udcd5.FieldOpFreeAlgebra` is\n  the free algebra generated by `\ud835\udcd5.CrAnFieldOp`. -/\nabbrev FieldOpFreeAlgebra (\ud835\udcd5 : FieldSpecification) : Type := FreeAlgebra \u2102 \ud835\udcd5.CrAnFieldOp\n\nnamespace FieldOpFreeAlgebra\n\nremark naming_convention := \"\n  For mathematicial objects defined in relation to `FieldOpFreeAlgebra` the postfix `F`\n  may be given to\n  their names to indicate that they are related to the free algebra.\n  This is to avoid confusion when working within the context of `FieldOpAlgebra` which is defined\n  as a quotient of `FieldOpFreeAlgebra`.\"\n\n/-- For a field specification `\ud835\udcd5`, and a element `\u03c6` of `\ud835\udcd5.CrAnFieldOp`,\n  `ofCrAnOpF \u03c6` is defined as the element of `\ud835\udcd5.FieldOpFreeAlgebra` formed by `\u03c6`. -/\ndef ofCrAnOpF (\u03c6 : \ud835\udcd5.CrAnFieldOp) : FieldOpFreeAlgebra \ud835\udcd5 :=\n  FreeAlgebra.\u03b9 \u2102 \u03c6\n\n/--\nThe algebra `\ud835\udcd5.FieldOpFreeAlgebra` satisfies the universal property that for any other algebra\n  `A` (e.g. the operator algebra of the theory) with a map `f : \ud835\udcd5.CrAnFieldOp \u2192 A` (e.g.\n  the inclusion of the creation and annihilation parts of field operators into the\n  operator algebra) there is a unique algebra map `g : \ud835\udcd5.FieldOpFreeAlgebra \u2192 A`\n  such that `g \u2218 ofCrAnOpF = f`.\n\n  The unique `g` is given by `FreeAlgebra.lift \u2102 f`.\n-/\nlemma universality {A : Type} [Semiring A] [Algebra \u2102 A] (f : \ud835\udcd5.CrAnFieldOp \u2192 A) :\n    \u2203! g : FieldOpFreeAlgebra \ud835\udcd5 \u2192\u2090[\u2102] A, g \u2218 ofCrAnOpF = f := by\n  use FreeAlgebra.lift \u2102 f\n  apply And.intro\n  \u00b7 funext x\n    simp [ofCrAnOpF]\n  \u00b7 intro g hg\n    ext x\n    simpa using congrFun hg x\n\n/-- For a field specification `\ud835\udcd5`, and a list `\u03c6s` of `\ud835\udcd5.CrAnFieldOp`,\n `ofCrAnListF \u03c6s` is defined as the element of `\ud835\udcd5.FieldOpFreeAlgebra`\n  obtained by the product of `ofCrAnListF \u03c6` for each `\u03c6` in `\u03c6s`.\n  For example `ofCrAnListF [\u03c6\u2081, \u03c6\u2082, \u03c6\u2083] = ofCrAnOpF \u03c6\u2081 * ofCrAnOpF \u03c6\u2082 * ofCrAnOpF \u03c6\u2083`.\n  The set of all `ofCrAnListF \u03c6s` forms a basis of `FieldOpFreeAlgebra \ud835\udcd5`. -/\ndef ofCrAnListF (\u03c6s : List \ud835\udcd5.CrAnFieldOp) : FieldOpFreeAlgebra \ud835\udcd5 := (List.map ofCrAnOpF \u03c6s).prod\n\n@[simp]\nlemma ofCrAnListF_nil : ofCrAnListF ([] : List \ud835\udcd5.CrAnFieldOp) = 1 := rfl\n\nlemma ofCrAnListF_cons (\u03c6 : \ud835\udcd5.CrAnFieldOp) (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnListF (\u03c6 :: \u03c6s) = ofCrAnOpF \u03c6 * ofCrAnListF \u03c6s := rfl\n\nlemma ofCrAnListF_append (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnListF (\u03c6s ++ \u03c6s') = ofCrAnListF \u03c6s * ofCrAnListF \u03c6s' := by\n  simp [ofCrAnListF, List.map_append]\n\nlemma ofCrAnListF_singleton (\u03c6 : \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnListF [\u03c6] = ofCrAnOpF \u03c6 := by simp [ofCrAnListF]\n\n/-- For a field specification `\ud835\udcd5`, and an element `\u03c6` of  `\ud835\udcd5.FieldOp`,\n  `ofFieldOpF \u03c6` is the element of `\ud835\udcd5.FieldOpFreeAlgebra` formed  by summing over\n  `ofCrAnOpF` of the\n  creation and annihilation parts of `\u03c6`.\n\n  For example for `\u03c6` an incoming asymptotic field operator we get\n  `ofCrAnOpF \u27e8\u03c6, ()\u27e9`, and for `\u03c6` a\n  position field operator we get `ofCrAnOpF \u27e8\u03c6, .create\u27e9 + ofCrAnOpF \u27e8\u03c6, .annihilate\u27e9`. -/\ndef ofFieldOpF (\u03c6 : \ud835\udcd5.FieldOp) : FieldOpFreeAlgebra \ud835\udcd5 :=\n  \u2211 (i : \ud835\udcd5.fieldOpToCrAnType \u03c6), ofCrAnOpF \u27e8\u03c6, i\u27e9\n\n/-- For a field specification `\ud835\udcd5`, and a list `\u03c6s` of `\ud835\udcd5.FieldOp`,\n  `\ud835\udcd5.ofFieldOpListF \u03c6s` is defined as the element of `\ud835\udcd5.FieldOpFreeAlgebra`\n  obtained by the product of `ofFieldOpF \u03c6` for each `\u03c6` in `\u03c6s`.\n  For example `ofFieldOpListF [\u03c6\u2081, \u03c6\u2082, \u03c6\u2083] = ofFieldOpF \u03c6\u2081 * ofFieldOpF \u03c6\u2082 * ofFieldOpF \u03c6\u2083`. -/\ndef ofFieldOpListF (\u03c6s : List \ud835\udcd5.FieldOp) : FieldOpFreeAlgebra \ud835\udcd5 := (List.map ofFieldOpF \u03c6s).prod\n\nremark notation_drop := \"In doc-strings explicit applications of `ofCrAnOpF`,\n`ofCrAnListF`, `ofFieldOpF`, and `ofFieldOpListF` will often be dropped.\"\n\n/-- Coercion from `List \ud835\udcd5.FieldOp` to `FieldOpFreeAlgebra \ud835\udcd5` through `ofFieldOpListF`. -/\ninstance : Coe (List \ud835\udcd5.FieldOp) (FieldOpFreeAlgebra \ud835\udcd5) := \u27e8ofFieldOpListF\u27e9\n\n@[simp]\nlemma ofFieldOpListF_nil : ofFieldOpListF ([] : List \ud835\udcd5.FieldOp) = 1 := rfl\n\nlemma ofFieldOpListF_cons (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    ofFieldOpListF (\u03c6 :: \u03c6s) = ofFieldOpF \u03c6 * ofFieldOpListF \u03c6s := rfl\n\nlemma ofFieldOpListF_singleton (\u03c6 : \ud835\udcd5.FieldOp) :\n    ofFieldOpListF [\u03c6] = ofFieldOpF \u03c6 := by simp [ofFieldOpListF]\n\nlemma ofFieldOpListF_append (\u03c6s \u03c6s' : List \ud835\udcd5.FieldOp) :\n    ofFieldOpListF (\u03c6s ++ \u03c6s') = ofFieldOpListF \u03c6s * ofFieldOpListF \u03c6s' := by\n  dsimp only [ofFieldOpListF]\n  rw [List.map_append, List.prod_append]\n\nlemma ofFieldOpListF_sum (\u03c6s : List \ud835\udcd5.FieldOp) :\n    ofFieldOpListF \u03c6s = \u2211 (s : CrAnSection \u03c6s), ofCrAnListF s.1 := by\n  induction \u03c6s with\n  | nil => simp\n  | cons \u03c6 \u03c6s ih =>\n    rw [CrAnSection.sum_cons]\n    dsimp only [CrAnSection.cons, ofCrAnListF_cons]\n    conv_rhs =>\n      enter [2, x]\n      rw [\u2190 Finset.mul_sum]\n    rw [\u2190 Finset.sum_mul, ofFieldOpListF_cons, \u2190 ih]\n    rfl\n\n/-!\n\n## Creation and annihilation parts of a state\n\n-/\n\n/-- The algebra map taking an element of the free-state algebra to\n  the part of it in the creation and annihilation free algebra\n  spanned by creation operators. -/\ndef crPartF : \ud835\udcd5.FieldOp \u2192 \ud835\udcd5.FieldOpFreeAlgebra := fun \u03c6 =>\n  match \u03c6 with\n  | FieldOp.inAsymp \u03c6 => ofCrAnOpF \u27e8FieldOp.inAsymp \u03c6, ()\u27e9\n  | FieldOp.position \u03c6 => ofCrAnOpF \u27e8FieldOp.position \u03c6, CreateAnnihilate.create\u27e9\n  | FieldOp.outAsymp _ => 0\n\n@[simp]\nlemma crPartF_negAsymp (\u03c6 : (\u03a3 f, \ud835\udcd5.AsymptoticLabel f) \u00d7 (Fin 3 \u2192 \u211d)) :\n    crPartF (FieldOp.inAsymp \u03c6) = ofCrAnOpF \u27e8FieldOp.inAsymp \u03c6, ()\u27e9 := by\n  simp [crPartF]\n\n@[simp]\nlemma crPartF_position (\u03c6 : (\u03a3 f, \ud835\udcd5.PositionLabel f) \u00d7 SpaceTime) :\n    crPartF (FieldOp.position \u03c6) =\n    ofCrAnOpF \u27e8FieldOp.position \u03c6, CreateAnnihilate.create\u27e9 := by\n  simp [crPartF]\n\n@[simp]\nlemma crPartF_posAsymp (\u03c6 : (\u03a3 f, \ud835\udcd5.AsymptoticLabel f) \u00d7 (Fin 3 \u2192 \u211d)) :\n    crPartF (FieldOp.outAsymp \u03c6) = 0 := by\n  simp [crPartF]\n\n/-- The algebra map taking an element of the free-state algebra to\n  the part of it in the creation and annihilation free algebra\n  spanned by annihilation operators. -/\ndef anPartF : \ud835\udcd5.FieldOp \u2192 \ud835\udcd5.FieldOpFreeAlgebra := fun \u03c6 =>\n  match \u03c6 with\n  | FieldOp.inAsymp _ => 0\n  | FieldOp.position \u03c6 => ofCrAnOpF \u27e8FieldOp.position \u03c6, CreateAnnihilate.annihilate\u27e9\n  | FieldOp.outAsymp \u03c6 => ofCrAnOpF \u27e8FieldOp.outAsymp \u03c6, ()\u27e9\n\n", "theoremStatement": "@[simp]\nlemma anPartF_negAsymp (\u03c6 : (\u03a3 f, \ud835\udcd5.AsymptoticLabel f) \u00d7 (Fin 3 \u2192 \u211d)) :\n    anPartF (FieldOp.inAsymp \u03c6) = 0 ", "theoremName": "FieldSpecification.FieldOpFreeAlgebra.anPartF_negAsymp", "fileCreated": {"commit": "ea6e12829370d9630a7e65200c8349e9086c05ba", "date": "2025-02-03"}, "theoremCreated": {"commit": "f7e669910ceee9df476eef0815080acbaa61ee61", "date": "2025-01-30"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpFreeAlgebra/Basic.lean", "module": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.Basic", "jsonFile": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.Basic.jsonl", "positionMetadata": {"lineInFile": 184, "tokenPositionInFile": 7453, "theoremPositionInFile": 20}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 7, "numPremises": 21}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp [anPartF]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 22}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.TimeOrder\nimport HepLean.PerturbationTheory.FieldOpAlgebra.Basic\n/-!\n\n# SuperCommute on Field operator algebra\n\n-/\n\nnamespace FieldSpecification\nopen FieldOpFreeAlgebra\nopen HepLean.List\nopen FieldStatistic\n\nnamespace FieldOpAlgebra\nvariable {\ud835\udcd5 : FieldSpecification}\n\nlemma \u03b9_superCommuteF_eq_zero_of_\u03b9_right_zero (a b : \ud835\udcd5.FieldOpFreeAlgebra) (h : \u03b9 b = 0) :\n    \u03b9 [a, b]\u209bca = 0 := by\n  rw [superCommuteF_expand_bosonicProjF_fermionicProjF]\n  rw [\u03b9_eq_zero_iff_\u03b9_bosonicProjF_fermonicProj_zero] at h\n  simp_all\n\nlemma \u03b9_superCommuteF_eq_zero_of_\u03b9_left_zero (a b : \ud835\udcd5.FieldOpFreeAlgebra) (h : \u03b9 a = 0) :\n    \u03b9 [a, b]\u209bca = 0 := by\n  rw [superCommuteF_expand_bosonicProjF_fermionicProjF]\n  rw [\u03b9_eq_zero_iff_\u03b9_bosonicProjF_fermonicProj_zero] at h\n  simp_all\n\n/-!\n\n## Defining normal order for `FiedOpAlgebra`.\n\n-/\n\nlemma \u03b9_superCommuteF_right_zero_of_mem_ideal (a b : \ud835\udcd5.FieldOpFreeAlgebra)\n    (h : b \u2208 TwoSidedIdeal.span \ud835\udcd5.fieldOpIdealSet) : \u03b9 [a, b]\u209bca = 0 := by\n  apply \u03b9_superCommuteF_eq_zero_of_\u03b9_right_zero\n  exact (\u03b9_eq_zero_iff_mem_ideal b).mpr h\n\nlemma \u03b9_superCommuteF_eq_of_equiv_right (a b1 b2 : \ud835\udcd5.FieldOpFreeAlgebra) (h : b1 \u2248 b2) :\n    \u03b9 [a, b1]\u209bca = \u03b9 [a, b2]\u209bca := by\n  rw [equiv_iff_sub_mem_ideal] at h\n  rw [LinearMap.sub_mem_ker_iff.mp]\n  simp only [LinearMap.mem_ker, \u2190 map_sub]\n  exact \u03b9_superCommuteF_right_zero_of_mem_ideal a (b1 - b2) h\n\n/-- The super commutator on the `FieldOpAlgebra` defined as a linear map `[a,_]\u209b`. -/\nnoncomputable def superCommuteRight (a : \ud835\udcd5.FieldOpFreeAlgebra) :\n  FieldOpAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpAlgebra \ud835\udcd5 where\n  toFun := Quotient.lift (\u03b9.toLinearMap \u2218\u2097 superCommuteF a)\n    (\u03b9_superCommuteF_eq_of_equiv_right a)\n  map_add' x y := by\n    obtain \u27e8x, hx\u27e9 := \u03b9_surjective x\n    obtain \u27e8y, hy\u27e9 := \u03b9_surjective y\n    subst hx hy\n    rw [\u2190 map_add, \u03b9_apply, \u03b9_apply, \u03b9_apply]\n    rw [Quotient.lift_mk, Quotient.lift_mk, Quotient.lift_mk]\n    simp\n  map_smul' c y := by\n    obtain \u27e8y, hy\u27e9 := \u03b9_surjective y\n    subst hy\n    rw [\u2190 map_smul, \u03b9_apply, \u03b9_apply]\n    simp\n\nlemma superCommuteRight_apply_\u03b9 (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    superCommuteRight a (\u03b9 b) = \u03b9 [a, b]\u209bca := by rfl\n\nlemma superCommuteRight_apply_quot (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    superCommuteRight a \u27e6b\u27e7= \u03b9 [a, b]\u209bca := by rfl\n\nlemma superCommuteRight_eq_of_equiv (a1 a2 : \ud835\udcd5.FieldOpFreeAlgebra) (h : a1 \u2248 a2) :\n    superCommuteRight a1 = superCommuteRight a2 := by\n  rw [equiv_iff_sub_mem_ideal] at h\n  ext b\n  obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n  have ha1b1 : (superCommuteRight (a1 - a2)) (\u03b9 b) = 0 := by\n    rw [superCommuteRight_apply_\u03b9]\n    apply \u03b9_superCommuteF_eq_zero_of_\u03b9_left_zero\n    exact (\u03b9_eq_zero_iff_mem_ideal (a1 - a2)).mpr h\n  simp_all only [superCommuteRight_apply_\u03b9, map_sub, LinearMap.sub_apply]\n  trans \u03b9 ((superCommuteF a2) b) + 0\n  rw [\u2190 ha1b1]\n  simp only [add_sub_cancel]\n  simp\n\n/-- For a field specification `\ud835\udcd5`, `superCommute` is the linear map\n\n  `FieldOpAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpAlgebra \ud835\udcd5`\n\n  defined as the decent of `\u03b9 \u2218 superCommuteF` in both arguments.\n  In particular for `\u03c6s` and `\u03c6s'` lists of `\ud835\udcd5.CrAnFieldOp` in `FieldOpAlgebra \ud835\udcd5` the following\n  relation holds:\n\n  `superCommute \u03c6s \u03c6s' = \u03c6s * \u03c6s' - \ud835\udce2(\u03c6s, \u03c6s') \u2022 \u03c6s' * \u03c6s`\n\n  The notation `[a, b]\u209b` is used for `superCommute a b`.\n  -/\nnoncomputable def superCommute : FieldOpAlgebra \ud835\udcd5 \u2192\u2097[\u2102]\n    FieldOpAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpAlgebra \ud835\udcd5 where\n  toFun := Quotient.lift superCommuteRight superCommuteRight_eq_of_equiv\n  map_add' x y := by\n    obtain \u27e8x, rfl\u27e9 := \u03b9_surjective x\n    obtain \u27e8y, rfl\u27e9 := \u03b9_surjective y\n    ext b\n    obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n    rw [\u2190 map_add, \u03b9_apply, \u03b9_apply, \u03b9_apply, \u03b9_apply]\n    rw [Quotient.lift_mk, Quotient.lift_mk, Quotient.lift_mk]\n    simp only [LinearMap.add_apply]\n    rw [superCommuteRight_apply_quot, superCommuteRight_apply_quot, superCommuteRight_apply_quot]\n    simp\n  map_smul' c y := by\n    obtain \u27e8y, rfl\u27e9 := \u03b9_surjective y\n    ext b\n    obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n    rw [\u2190 map_smul, \u03b9_apply, \u03b9_apply, \u03b9_apply]\n    simp only [Quotient.lift_mk, RingHom.id_apply, LinearMap.smul_apply]\n    rw [superCommuteRight_apply_quot, superCommuteRight_apply_quot]\n    simp\n\n@[inherit_doc superCommute]\nscoped[FieldSpecification.FieldOpAlgebra] notation \"[\" a \",\" b \"]\u209b\" => superCommute a b\n\nlemma superCommute_eq_\u03b9_superCommuteF (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    [\u03b9 a, \u03b9 b]\u209b = \u03b9 [a, b]\u209bca := rfl\n\n/-!\n\n## Properties of `superCommute`.\n\n-/\n\n/-!\n\n## Properties from the definition of FieldOpAlgebra\n\n-/\n\nlemma superCommute_create_create {\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp}\n    (h : \ud835\udcd5 |>\u1d9c \u03c6 = .create) (h' : \ud835\udcd5 |>\u1d9c \u03c6' = .create) :\n    [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b = 0 := by\n  rw [ofCrAnOp, ofCrAnOp]\n  rw [superCommute_eq_\u03b9_superCommuteF, \u03b9_superCommuteF_of_create_create _ _ h h']\n\nlemma superCommute_annihilate_annihilate {\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp}\n    (h : \ud835\udcd5 |>\u1d9c \u03c6 = .annihilate) (h' : \ud835\udcd5 |>\u1d9c \u03c6' = .annihilate) :\n    [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b = 0 := by\n  rw [ofCrAnOp, ofCrAnOp]\n  rw [superCommute_eq_\u03b9_superCommuteF, \u03b9_superCommuteF_of_annihilate_annihilate _ _ h h']\n\nlemma superCommute_diff_statistic {\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp} (h : (\ud835\udcd5 |>\u209b \u03c6) \u2260 \ud835\udcd5 |>\u209b \u03c6') :\n    [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b = 0 := by\n  rw [ofCrAnOp, ofCrAnOp]\n  rw [superCommute_eq_\u03b9_superCommuteF, \u03b9_superCommuteF_of_diff_statistic h]\n\nlemma superCommute_ofCrAnOp_ofFieldOp_diff_stat_zero (\u03c6 : \ud835\udcd5.CrAnFieldOp) (\u03c8 : \ud835\udcd5.FieldOp)\n    (h : (\ud835\udcd5 |>\u209b \u03c6) \u2260 (\ud835\udcd5 |>\u209b \u03c8)) : [ofCrAnOp \u03c6, ofFieldOp \u03c8]\u209b = 0 := by\n  rw [ofFieldOp_eq_sum, map_sum]\n  rw [Finset.sum_eq_zero]\n  intro x hx\n  apply superCommute_diff_statistic\n  simpa [crAnStatistics] using h\n\nlemma superCommute_anPart_ofFieldOpF_diff_grade_zero (\u03c6 \u03c8 : \ud835\udcd5.FieldOp)\n    (h : (\ud835\udcd5 |>\u209b \u03c6) \u2260 (\ud835\udcd5 |>\u209b \u03c8)) : [anPart \u03c6, ofFieldOp \u03c8]\u209b = 0 := by\n  match \u03c6 with\n  | FieldOp.inAsymp _ =>\n    simp\n  | FieldOp.position \u03c6 =>\n    simp only [anPartF_position]\n    apply superCommute_ofCrAnOp_ofFieldOp_diff_stat_zero _ _ _\n    simpa [crAnStatistics] using h\n  | FieldOp.outAsymp _ =>\n    simp only [anPartF_posAsymp]\n    apply superCommute_ofCrAnOp_ofFieldOp_diff_stat_zero _ _\n    simpa [crAnStatistics] using h\n\nlemma superCommute_ofCrAnOp_ofCrAnOp_mem_center (\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b \u2208 Subalgebra.center \u2102 (FieldOpAlgebra \ud835\udcd5) := by\n  rw [ofCrAnOp, ofCrAnOp, superCommute_eq_\u03b9_superCommuteF]\n  exact \u03b9_superCommuteF_ofCrAnOpF_ofCrAnOpF_mem_center \u03c6 \u03c6'\n\nlemma superCommute_ofCrAnOp_ofCrAnOp_commute (\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp)\n    (a : FieldOpAlgebra \ud835\udcd5) :\n    a * [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b = [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b * a := by\n  have h1 := superCommute_ofCrAnOp_ofCrAnOp_mem_center \u03c6 \u03c6'\n  rw [@Subalgebra.mem_center_iff] at h1\n  exact h1 a\n\nlemma superCommute_ofCrAnOp_ofFieldOp_mem_center (\u03c6 : \ud835\udcd5.CrAnFieldOp) (\u03c6' : \ud835\udcd5.FieldOp) :\n    [ofCrAnOp \u03c6, ofFieldOp \u03c6']\u209b \u2208 Subalgebra.center \u2102 (FieldOpAlgebra \ud835\udcd5) := by\n  rw [ofFieldOp_eq_sum]\n  simp only [map_sum]\n  refine Subalgebra.sum_mem (Subalgebra.center \u2102 \ud835\udcd5.FieldOpAlgebra) ?_\n  intro x hx\n  exact superCommute_ofCrAnOp_ofCrAnOp_mem_center \u03c6 \u27e8\u03c6', x\u27e9\n\nlemma superCommute_ofCrAnOp_ofFieldOp_commute (\u03c6 : \ud835\udcd5.CrAnFieldOp) (\u03c6' : \ud835\udcd5.FieldOp)\n    (a : FieldOpAlgebra \ud835\udcd5) : a * [ofCrAnOp \u03c6, ofFieldOp \u03c6']\u209b =\n    [ofCrAnOp \u03c6, ofFieldOp \u03c6']\u209b * a := by\n  have h1 := superCommute_ofCrAnOp_ofFieldOp_mem_center \u03c6 \u03c6'\n  rw [@Subalgebra.mem_center_iff] at h1\n  exact h1 a\n\nlemma superCommute_anPart_ofFieldOp_mem_center (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [anPart \u03c6, ofFieldOp \u03c6']\u209b \u2208 Subalgebra.center \u2102 (FieldOpAlgebra \ud835\udcd5) := by\n  match \u03c6 with\n  | FieldOp.inAsymp _ =>\n    simp only [anPart_negAsymp, map_zero, LinearMap.zero_apply]\n    exact Subalgebra.zero_mem (Subalgebra.center \u2102 _)\n  | FieldOp.position \u03c6 =>\n    exact superCommute_ofCrAnOp_ofFieldOp_mem_center _ _\n  | FieldOp.outAsymp _ =>\n    exact superCommute_ofCrAnOp_ofFieldOp_mem_center _ _\n\n/-!\n\n### `superCommute` on different constructors.\n\n-/\n\nlemma superCommute_ofCrAnList_ofCrAnList (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnList \u03c6s, ofCrAnList \u03c6s']\u209b =\n    ofCrAnList (\u03c6s ++ \u03c6s') - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnList (\u03c6s' ++ \u03c6s) := by\n  rw [ofCrAnList_eq_\u03b9_ofCrAnListF, ofCrAnList_eq_\u03b9_ofCrAnListF]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_ofCrAnListF_ofCrAnListF]\n  rfl\n\nlemma superCommute_ofCrAnOp_ofCrAnOp (\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b = ofCrAnOp \u03c6 * ofCrAnOp \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 ofCrAnOp \u03c6' * ofCrAnOp \u03c6 := by\n  rw [ofCrAnOp, ofCrAnOp]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_ofCrAnOpF_ofCrAnOpF]\n  rfl\n\nlemma superCommute_ofCrAnList_ofFieldOpList (\u03c6cas : List \ud835\udcd5.CrAnFieldOp)\n    (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [ofCrAnList \u03c6cas, ofFieldOpList \u03c6s]\u209b = ofCrAnList \u03c6cas * ofFieldOpList \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6cas, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpList \u03c6s * ofCrAnList \u03c6cas := by\n  rw [ofCrAnList, ofFieldOpList]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_ofCrAnListF_ofFieldOpFsList]\n  rfl\n\n", "theoremStatement": "lemma superCommute_ofFieldOpList_ofFieldOpList (\u03c6s \u03c6s' : List \ud835\udcd5.FieldOp) :\n    [ofFieldOpList \u03c6s, ofFieldOpList \u03c6s']\u209b = ofFieldOpList \u03c6s * ofFieldOpList \u03c6s' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofFieldOpList \u03c6s' * ofFieldOpList \u03c6s ", "theoremName": "FieldSpecification.FieldOpAlgebra.superCommute_ofFieldOpList_ofFieldOpList", "fileCreated": {"commit": "ea6e12829370d9630a7e65200c8349e9086c05ba", "date": "2025-02-03"}, "theoremCreated": {"commit": "c18b4850e54b74a6b63ae78ae4ef6a96be8e9569", "date": "2025-01-30"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpAlgebra/SuperCommute.lean", "module": "HepLean.PerturbationTheory.FieldOpAlgebra.SuperCommute", "jsonFile": "HepLean.PerturbationTheory.FieldOpAlgebra.SuperCommute.jsonl", "positionMetadata": {"lineInFile": 248, "tokenPositionInFile": 9021, "theoremPositionInFile": 22}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 18, "numPremises": 97}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [ofFieldOpList, ofFieldOpList]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_ofFieldOpListF_ofFieldOpFsList]\n  rfl", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 132}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldSpecification.Basic\n/-!\n\n# Wick contractions\n\n-/\nopen FieldSpecification\n\nvariable {\ud835\udcd5 : FieldSpecification}\n\n/--\nGiven a natural number `n`, which will correspond to the number of fields needing\ncontracting, a Wick contraction\nis a finite set of pairs of `Fin n` (numbers `0`, \u2026, `n-1`), such that no\nelement of `Fin n` occurs in more then one pair. The pairs are the positions of fields we\n'contract' together.\n-/\ndef WickContraction (n : \u2115) : Type :=\n  {f : Finset ((Finset (Fin n))) // (\u2200 a \u2208 f, a.card = 2) \u2227\n    (\u2200 a \u2208 f, \u2200 b \u2208 f, a = b \u2228 Disjoint a b)}\n\nnamespace WickContraction\nvariable {n : \u2115} (c : WickContraction n)\nopen HepLean.List\n\nremark contraction_notation := \"Given a field specification `\ud835\udcd5`, and a list `\u03c6s`\n  of `\ud835\udcd5.FieldOp`, a Wick contraction of `\u03c6s` will mean a Wick contraction in\n  `WickContraction \u03c6s.length`. The notation `\u03c6s\u039b` will be used for such contractions.\n  The terminology that `\u03c6s\u039b` contracts pairs within of `\u03c6s` will also be used, even though\n  `\u03c6s\u039b` is really contains positions of `\u03c6s`.\"\n\n/-- Wick contractions are decidable. -/\ninstance : DecidableEq (WickContraction n) := Subtype.instDecidableEq\n\n/-- The contraction consisting of no contracted pairs. -/\ndef empty : WickContraction n := \u27e8\u2205, by simp, by simp\u27e9\n\nlemma card_zero_iff_empty (c : WickContraction n) : c.1.card = 0 \u2194 c = empty := by\n  rw [Subtype.eq_iff]\n  simp [empty]\n\nlemma exists_pair_of_not_eq_empty (c : WickContraction n) (h : c \u2260 empty) :\n    \u2203 i j, {i, j} \u2208 c.1 := by\n  by_contra hn\n  simp only [not_exists] at hn\n  have hc : c.1 = \u2205 := by\n    ext a\n    simp only [Finset.not_mem_empty, iff_false]\n    by_contra hn'\n    have hc := c.2.1 a hn'\n    rw [@Finset.card_eq_two] at hc\n    obtain \u27e8x, y, hx, rfl\u27e9 := hc\n    exact hn x y hn'\n  apply h\n  apply Subtype.eq\n  simp [empty, hc]\n\n/-- The equivalence between `WickContraction n` and `WickContraction m`\n  derived from a propositional equality of `n` and `m`. -/\ndef congr : {n m : \u2115} \u2192 (h : n = m) \u2192 WickContraction n \u2243 WickContraction m\n  | n, .(n), rfl => Equiv.refl _\n\n@[simp]\nlemma congr_refl : c.congr rfl = c := by\n  rfl\n\n@[simp]\nlemma card_congr {n m : \u2115} (h : n = m) (c : WickContraction n) :\n    (congr h c).1.card = c.1.card := by\n  subst h\n  simp\n\nlemma congr_contractions {n m : \u2115} (h : n = m) (c : WickContraction n) :\n    ((congr h) c).1 = Finset.map (Finset.mapEmbedding (finCongr h)).toEmbedding c.1 := by\n  subst h\n  simp only [congr_refl, Finset.le_eq_subset, finCongr_refl, Equiv.refl_toEmbedding]\n  ext a\n  apply Iff.intro\n  \u00b7 intro ha\n    simp only [Finset.mem_map, RelEmbedding.coe_toEmbedding]\n    use a\n    simp only [ha, true_and]\n    rw [Finset.mapEmbedding_apply]\n    simp\n  \u00b7 intro ha\n    simp only [Finset.mem_map, RelEmbedding.coe_toEmbedding] at ha\n    obtain \u27e8b, hb, hab\u27e9 := ha\n    rw [Finset.mapEmbedding_apply] at hab\n    simp only [Finset.map_refl] at hab\n    subst hab\n    exact hb\n\n@[simp]\nlemma congr_trans {n m o : \u2115} (h1 : n = m) (h2 : m = o) :\n    (congr h1).trans (congr h2) = congr (h1.trans h2) := by\n  subst h1 h2\n  simp [congr]\n\n@[simp]\nlemma congr_trans_apply {n m o : \u2115} (h1 : n = m) (h2 : m = o) (c : WickContraction n) :\n    (congr h2) ((congr h1) c) = congr (h1.trans h2) c := by\n  subst h1 h2\n  simp\n\nlemma mem_congr_iff {n m : \u2115} (h : n = m) {c : WickContraction n } {a : Finset (Fin m)} :\n    a \u2208 (congr h c).1 \u2194 Finset.map (finCongr h.symm).toEmbedding a \u2208 c.1 := by\n  subst h\n  simp\n\n/-- Given a contracted pair in `c : WickContraction n` the contracted pair\n  in `congr h c`. -/\ndef congrLift {n m : \u2115} (h : n = m) {c : WickContraction n} (a : c.1) : (congr h c).1 :=\n  \u27e8a.1.map (finCongr h).toEmbedding, by\n    subst h\n    simp\u27e9\n\n@[simp]\nlemma congrLift_rfl {n : \u2115} {c : WickContraction n} :\n    c.congrLift rfl = id := by\n  funext a\n  simp [congrLift]\n\nlemma congrLift_injective {n m : \u2115} {c : WickContraction n} (h : n = m) :\n    Function.Injective (c.congrLift h) := by\n  subst h\n  simp only [congrLift_rfl]\n  exact fun \u2983a\u2081 a\u2082\u2984 a => a\n\nlemma congrLift_surjective {n m : \u2115} {c : WickContraction n} (h : n = m) :\n    Function.Surjective (c.congrLift h) := by\n  subst h\n  simp only [congrLift_rfl]\n  exact Function.surjective_id\n\nlemma congrLift_bijective {n m : \u2115} {c : WickContraction n} (h : n = m) :\n    Function.Bijective (c.congrLift h) := by\n  exact \u27e8c.congrLift_injective h, c.congrLift_surjective h\u27e9\n\n/-- Given a contracted pair in `c : WickContraction n` the contracted pair\n  in `congr h c`. -/\ndef congrLiftInv {n m : \u2115} (h : n = m) {c : WickContraction n} (a : (congr h c).1) : c.1 :=\n  \u27e8a.1.map (finCongr h.symm).toEmbedding, by\n    subst h\n    simp\u27e9\n\nlemma congrLiftInv_rfl {n : \u2115} {c : WickContraction n} :\n    c.congrLiftInv rfl = id := by\n  funext a\n  simp [congrLiftInv]\n\nlemma eq_filter_mem_self : c.1 = Finset.filter (fun x => x \u2208 c.1) Finset.univ := by\n  exact Eq.symm (Finset.filter_univ_mem c.1)\n\n/-- For a contraction `c : WickContraction n` and `i : Fin n` the `j` such that\n  `{i, j}` is a contracted pair in `c`. If such an `j` does not exist, this returns `none`. -/\ndef getDual? (i : Fin n) : Option (Fin n) := Fin.find (fun j => {i, j} \u2208 c.1)\n\nlemma getDual?_congr {n m : \u2115} (h : n = m) (c : WickContraction n) (i : Fin m) :\n    (congr h c).getDual? i = Option.map (finCongr h) (c.getDual? (finCongr h.symm i)) := by\n  subst h\n  simp\n\nlemma getDual?_congr_get {n m : \u2115} (h : n = m) (c : WickContraction n) (i : Fin m)\n    (hg : ((congr h c).getDual? i).isSome) :\n    ((congr h c).getDual? i).get hg =\n    (finCongr h ((c.getDual? (finCongr h.symm i)).get (by simpa [getDual?_congr] using hg))) := by\n  simp only [getDual?_congr, finCongr_apply]\n  exact Option.get_map\n\nlemma getDual?_eq_some_iff_mem (i j : Fin n) :\n    c.getDual? i = some j \u2194 {i, j} \u2208 c.1 := by\n  simp only [getDual?]\n  rw [Fin.find_eq_some_iff]\n  apply Iff.intro\n  \u00b7 intro h\n    exact h.1\n  \u00b7 intro h\n    simp only [h, true_and]\n    intro k hk\n    have hc := c.2.2 _ h _ hk\n    simp only [Finset.disjoint_insert_right, Finset.mem_insert, Finset.mem_singleton, true_or,\n      not_true_eq_false, Finset.disjoint_singleton_right, not_or, false_and, or_false] at hc\n    have hj : k \u2208 ({i, j} : Finset (Fin n)) := by\n      simp [hc]\n    simp only [Finset.mem_insert, Finset.mem_singleton] at hj\n    rcases hj with hj | hj\n    \u00b7 subst hj\n      simp only [Finset.mem_singleton, Finset.insert_eq_of_mem] at hk\n      have hc := c.2.1 _ hk\n      simp at hc\n    \u00b7 subst hj\n      simp\n\n@[simp]\nlemma getDual?_one_eq_none (c : WickContraction 1) (i : Fin 1) : c.getDual? i = none := by\n  by_contra h\n  have hn : (c.getDual? i).isSome := by\n    rw [\u2190 Option.not_isSome_iff_eq_none] at h\n    simpa [- Option.not_isSome, -Option.isNone_iff_eq_none] using h\n  rw [@Option.isSome_iff_exists] at hn\n  obtain \u27e8a, hn\u27e9 := hn\n  rw [getDual?_eq_some_iff_mem] at hn\n  have hc := c.2.1 {i, a} hn\n  fin_cases i\n  fin_cases a\n  simp at hc\n\n@[simp]\nlemma getDual?_get_self_mem (i : Fin n) (h : (c.getDual? i).isSome) :\n    {(c.getDual? i).get h, i} \u2208 c.1 := by\n  rw [@Finset.pair_comm]\n  rw [\u2190 getDual?_eq_some_iff_mem]\n  simp\n\n", "theoremStatement": "@[simp]\nlemma self_getDual?_get_mem (i : Fin n) (h : (c.getDual? i).isSome) :\n    {i, (c.getDual? i).get h} \u2208 c.1 ", "theoremName": "WickContraction.self_getDual?_get_mem", "fileCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "theoremCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "file": "HepLean/HepLean/PerturbationTheory/WickContraction/Basic.lean", "module": "HepLean.PerturbationTheory.WickContraction.Basic", "jsonFile": "HepLean.PerturbationTheory.WickContraction.Basic.jsonl", "positionMetadata": {"lineInFile": 220, "tokenPositionInFile": 7221, "theoremPositionInFile": 24}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 3, "numPremises": 39}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [\u2190 getDual?_eq_some_iff_mem]\n  simp", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 46}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.WickContraction.Erase\n/-!\n\n# Inserting an element into a contraction\n\n-/\n\nopen FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\nnamespace WickContraction\nvariable {n : \u2115} (c : WickContraction n)\nopen HepLean.List\nopen HepLean.Fin\n\n/-!\n\n## Inserting an element into a contraction\n\n-/\n\n/-- Given a Wick contraction `c` for `n`, a position `i : Fin n.succ` and\n  an optional uncontracted element `j : Option (c.uncontracted)` of `c`.\n  The Wick contraction for `n.succ` formed by 'inserting' `i` into `Fin n`\n  and contracting it optionally with `j`. -/\ndef insertAndContractNat (c : WickContraction n) (i : Fin n.succ) (j : Option (c.uncontracted)) :\n    WickContraction n.succ := by\n  let f := Finset.map (Finset.mapEmbedding i.succAboveEmb).toEmbedding c.1\n  let f' := match j with | none => f | some j => Insert.insert {i, i.succAbove j} f\n  refine \u27e8f', ?_, ?_\u27e9\n  \u00b7 simp only [Nat.succ_eq_add_one, f']\n    match j with\n    | none =>\n      simp only [Finset.le_eq_subset, Finset.mem_map, RelEmbedding.coe_toEmbedding,\n        forall_exists_index, and_imp, forall_apply_eq_imp_iff\u2082, f]\n      intro a ha\n      rw [Finset.mapEmbedding_apply]\n      simp only [Finset.card_map]\n      exact c.2.1 a ha\n    | some j =>\n      simp only [Finset.mem_insert, forall_eq_or_imp]\n      apply And.intro\n      \u00b7 rw [@Finset.card_eq_two]\n        use i\n        use (i.succAbove j)\n        simp only [ne_eq, and_true]\n        exact Fin.ne_succAbove i j\n      \u00b7 simp only [Finset.le_eq_subset, Finset.mem_map, RelEmbedding.coe_toEmbedding,\n        forall_exists_index, and_imp, forall_apply_eq_imp_iff\u2082, f]\n        intro a ha\n        rw [Finset.mapEmbedding_apply]\n        simp only [Finset.card_map]\n        exact c.2.1 a ha\n  \u00b7 intro a ha b hb\n    simp only [Nat.succ_eq_add_one, f'] at ha hb\n    match j with\n    | none =>\n      simp_all only [f, Finset.le_eq_subset, Finset.mem_map, RelEmbedding.coe_toEmbedding,\n        Nat.succ_eq_add_one]\n      obtain \u27e8a', ha', ha''\u27e9 := ha\n      obtain \u27e8b', hb', hb''\u27e9 := hb\n      subst ha''\n      subst hb''\n      simp only [EmbeddingLike.apply_eq_iff_eq]\n      rw [Finset.mapEmbedding_apply, Finset.mapEmbedding_apply, Finset.disjoint_map]\n      exact c.2.2 a' ha' b' hb'\n    | some j =>\n      simp_all only [Finset.mem_insert, Nat.succ_eq_add_one]\n      match ha, hb with\n      | Or.inl ha, Or.inl hb =>\n        rw [ha, hb]\n        simp\n      | Or.inl ha, Or.inr hb =>\n        apply Or.inr\n        subst ha\n        simp only [Finset.disjoint_insert_left, Finset.disjoint_singleton_left]\n        simp only [Finset.le_eq_subset, Finset.mem_map, RelEmbedding.coe_toEmbedding, f] at hb\n        obtain \u27e8a', hb', hb''\u27e9 := hb\n        subst hb''\n        rw [Finset.mapEmbedding_apply]\n        apply And.intro\n        \u00b7 simp only [Finset.mem_map, Fin.succAboveEmb_apply, not_exists, not_and]\n          exact fun x _ => Fin.succAbove_ne i x\n        \u00b7 simp only [Finset.mem_map, Fin.succAboveEmb_apply, not_exists, not_and]\n          have hj := j.2\n          rw [mem_uncontracted_iff_not_contracted] at hj\n          intro a ha hja\n          rw [Function.Injective.eq_iff (Fin.succAbove_right_injective)] at hja\n          subst hja\n          exact False.elim (hj a' hb' ha)\n      | Or.inr ha, Or.inl hb =>\n        apply Or.inr\n        subst hb\n        simp only [Finset.disjoint_insert_right, Nat.succ_eq_add_one,\n          Finset.disjoint_singleton_right]\n        simp only [Finset.le_eq_subset, Finset.mem_map, RelEmbedding.coe_toEmbedding, f] at ha\n        obtain \u27e8a', ha', ha''\u27e9 := ha\n        subst ha''\n        rw [Finset.mapEmbedding_apply]\n        apply And.intro\n        \u00b7 simp only [Finset.mem_map, Fin.succAboveEmb_apply, not_exists, not_and]\n          exact fun x _ => Fin.succAbove_ne i x\n        \u00b7 simp only [Finset.mem_map, Fin.succAboveEmb_apply, not_exists, not_and]\n          have hj := j.2\n          rw [mem_uncontracted_iff_not_contracted] at hj\n          intro a ha hja\n          rw [Function.Injective.eq_iff (Fin.succAbove_right_injective)] at hja\n          subst hja\n          exact False.elim (hj a' ha' ha)\n      | Or.inr ha, Or.inr hb =>\n        simp_all only [f, Finset.le_eq_subset,\n          or_true, Finset.mem_map, RelEmbedding.coe_toEmbedding]\n        obtain \u27e8a', ha', ha''\u27e9 := ha\n        obtain \u27e8b', hb', hb''\u27e9 := hb\n        subst ha''\n        subst hb''\n        simp only [EmbeddingLike.apply_eq_iff_eq]\n        rw [Finset.mapEmbedding_apply, Finset.mapEmbedding_apply, Finset.disjoint_map]\n        exact c.2.2 a' ha' b' hb'\n\nlemma insertAndContractNat_of_isSome (c : WickContraction n) (i : Fin n.succ)\n    (j : Option c.uncontracted) (hj : j.isSome) :\n    (insertAndContractNat c i j).1 = Insert.insert {i, i.succAbove (j.get hj)}\n    (Finset.map (Finset.mapEmbedding i.succAboveEmb).toEmbedding c.1) := by\n  simp only [Nat.succ_eq_add_one, insertAndContractNat, Finset.le_eq_subset]\n  rw [@Option.isSome_iff_exists] at hj\n  obtain \u27e8j, hj\u27e9 := hj\n  subst hj\n  simp\n\n@[simp]\nlemma self_mem_uncontracted_of_insertAndContractNat_none (c : WickContraction n) (i : Fin n.succ) :\n    i \u2208 (insertAndContractNat c i none).uncontracted := by\n  rw [mem_uncontracted_iff_not_contracted]\n  intro p hp\n  simp only [Nat.succ_eq_add_one, insertAndContractNat, Finset.le_eq_subset, Finset.mem_map,\n    RelEmbedding.coe_toEmbedding] at hp\n  obtain \u27e8a, ha, ha'\u27e9 := hp\n  have hc := c.2.1 a ha\n  rw [@Finset.card_eq_two] at hc\n  obtain \u27e8x, y, hxy, ha\u27e9 := hc\n  subst ha\n  subst ha'\n  rw [Finset.mapEmbedding_apply]\n  simp only [Nat.succ_eq_add_one, Finset.map_insert, Fin.succAboveEmb_apply, Finset.map_singleton,\n    Finset.mem_insert, Finset.mem_singleton, not_or]\n  apply And.intro\n  \u00b7 exact Fin.ne_succAbove i x\n  \u00b7 exact Fin.ne_succAbove i y\n\n@[simp]\nlemma self_not_mem_uncontracted_of_insertAndContractNat_some (c : WickContraction n)\n    (i : Fin n.succ) (j : c.uncontracted) :\n    i \u2209 (insertAndContractNat c i (some j)).uncontracted := by\n  rw [mem_uncontracted_iff_not_contracted]\n  simp [insertAndContractNat]\n\nlemma insertAndContractNat_succAbove_mem_uncontracted_iff (c : WickContraction n) (i : Fin n.succ)\n    (j : Fin n) :\n    (i.succAbove j) \u2208 (insertAndContractNat c i none).uncontracted \u2194 j \u2208 c.uncontracted := by\n  rw [mem_uncontracted_iff_not_contracted, mem_uncontracted_iff_not_contracted]\n  simp only [Nat.succ_eq_add_one, insertAndContractNat, Finset.le_eq_subset, Finset.mem_map,\n    RelEmbedding.coe_toEmbedding, forall_exists_index, and_imp, forall_apply_eq_imp_iff\u2082]\n  apply Iff.intro\n  \u00b7 intro h p hp\n    have hp' := h p hp\n    have hc := c.2.1 p hp\n    rw [Finset.card_eq_two] at hc\n    obtain \u27e8x, y, hxy, hp\u27e9 := hc\n    subst hp\n    rw [Finset.mapEmbedding_apply] at hp'\n    simp only [Finset.map_insert, Fin.succAboveEmb_apply, Finset.map_singleton, Finset.mem_insert,\n      Finset.mem_singleton, not_or] at hp'\n    simp only [Finset.mem_insert, Finset.mem_singleton, not_or]\n    exact And.intro (fun a => hp'.1 (congrArg i.succAbove a))\n      (fun a => hp'.2 (congrArg i.succAbove a))\n  \u00b7 intro h p hp\n    have hc := c.2.1 p hp\n    rw [Finset.card_eq_two] at hc\n    obtain \u27e8x, y, hxy, hp\u27e9 := hc\n    subst hp\n    rw [Finset.mapEmbedding_apply]\n    simp only [Finset.map_insert, Fin.succAboveEmb_apply, Finset.map_singleton, Finset.mem_insert,\n      Finset.mem_singleton, not_or]\n    have hp' := h {x, y} hp\n    simp only [Finset.mem_insert, Finset.mem_singleton, not_or] at hp'\n    apply And.intro\n      (fun a => hp'.1 (i.succAbove_right_injective a))\n      (fun a => hp'.2 (i.succAbove_right_injective a))\n\n@[simp]\nlemma mem_uncontracted_insertAndContractNat_none_iff (c : WickContraction n) (i : Fin n.succ)\n    (k : Fin n.succ) : k \u2208 (insertAndContractNat c i none).uncontracted \u2194\n    k = i \u2228 \u2203 j, k = i.succAbove j \u2227 j \u2208 c.uncontracted := by\n  by_cases hi : k = i\n  \u00b7 subst hi\n    simp\n  \u00b7 simp only [Nat.succ_eq_add_one, \u2190 Fin.exists_succAbove_eq_iff] at hi\n    obtain \u27e8z, hk\u27e9 := hi\n    subst hk\n    have hn : \u00ac i.succAbove z = i := Fin.succAbove_ne i z\n    simp only [Nat.succ_eq_add_one, insertAndContractNat_succAbove_mem_uncontracted_iff, hn,\n      false_or]\n    apply Iff.intro\n    \u00b7 intro h\n      exact \u27e8z, rfl, h\u27e9\n    \u00b7 intro h\n      obtain \u27e8j, hk\u27e9 := h\n      have hjk : z = j := Fin.succAbove_right_inj.mp hk.1\n      subst hjk\n      exact hk.2\n\nlemma insertAndContractNat_none_uncontracted (c : WickContraction n) (i : Fin n.succ) :\n    (insertAndContractNat c i none).uncontracted =\n    Insert.insert i (c.uncontracted.map i.succAboveEmb) := by\n  ext a\n  simp only [Nat.succ_eq_add_one, mem_uncontracted_insertAndContractNat_none_iff, Finset.mem_insert,\n    Finset.mem_map, Fin.succAboveEmb_apply]\n  apply Iff.intro\n  \u00b7 intro a_1\n    cases a_1 with\n    | inl h =>\n      subst h\n      simp_all only [true_or]\n    | inr h_1 =>\n      obtain \u27e8w, h\u27e9 := h_1\n      obtain \u27e8left, right\u27e9 := h\n      subst left\n      apply Or.inr\n      apply Exists.intro\n      \u00b7 apply And.intro\n        on_goal 2 => {rfl\n        }\n        \u00b7 simp_all only\n  \u00b7 intro a_1\n    cases a_1 with\n    | inl h =>\n      subst h\n      simp_all only [true_or]\n    | inr h_1 =>\n      obtain \u27e8w, h\u27e9 := h_1\n      obtain \u27e8left, right\u27e9 := h\n      subst right\n      apply Or.inr\n      apply Exists.intro\n      \u00b7 apply And.intro\n        on_goal 2 => {exact left\n        }\n        \u00b7 simp_all only\n\n", "theoremStatement": "@[simp]\nlemma mem_uncontracted_insertAndContractNat_some_iff (c : WickContraction n) (i : Fin n.succ)\n    (k : Fin n.succ) (j : c.uncontracted) :\n    k \u2208 (insertAndContractNat c i (some j)).uncontracted \u2194\n    \u2203 z, k = i.succAbove z \u2227 z \u2208 c.uncontracted \u2227 z \u2260 j ", "theoremName": "WickContraction.mem_uncontracted_insertAndContractNat_some_iff", "fileCreated": {"commit": "fa7536bea9b5acc23e09f201a7765792caebb199", "date": "2025-01-24"}, "theoremCreated": {"commit": "fa7536bea9b5acc23e09f201a7765792caebb199", "date": "2025-01-24"}, "file": "HepLean/HepLean/PerturbationTheory/WickContraction/InsertAndContractNat.lean", "module": "HepLean.PerturbationTheory.WickContraction.InsertAndContractNat", "jsonFile": "HepLean.PerturbationTheory.WickContraction.InsertAndContractNat.jsonl", "positionMetadata": {"lineInFile": 256, "tokenPositionInFile": 9425, "theoremPositionInFile": 7}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 5, "numPremises": 106}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  by_cases hki : k = i\n  \u00b7 subst hki\n    simp only [Nat.succ_eq_add_one, self_not_mem_uncontracted_of_insertAndContractNat_some, ne_eq,\n      false_iff, not_exists, not_and, Decidable.not_not]\n    exact fun x hx => False.elim (Fin.ne_succAbove k x hx)\n  \u00b7 simp only [Nat.succ_eq_add_one, \u2190 Fin.exists_succAbove_eq_iff] at hki\n    obtain \u27e8z, hk\u27e9 := hki\n    subst hk\n    by_cases hjz : j = z\n    \u00b7 subst hjz\n      rw [mem_uncontracted_iff_not_contracted]\n      simp only [Nat.succ_eq_add_one, insertAndContractNat, Finset.le_eq_subset, Finset.mem_insert,\n        Finset.mem_map, RelEmbedding.coe_toEmbedding, forall_eq_or_imp, Finset.mem_singleton,\n        or_true, not_true_eq_false, forall_exists_index, and_imp, forall_apply_eq_imp_iff\u2082,\n        false_and, ne_eq, false_iff, not_exists, not_and, Decidable.not_not]\n      intro x\n      rw [Function.Injective.eq_iff (Fin.succAbove_right_injective)]\n      exact fun a _a => a.symm\n    \u00b7 apply Iff.intro\n      \u00b7 intro h\n        use z\n        simp only [Nat.succ_eq_add_one, ne_eq, true_and]\n        refine And.intro ?_ (fun a => hjz a.symm)\n        rw [mem_uncontracted_iff_not_contracted]\n        intro p hp\n        rw [mem_uncontracted_iff_not_contracted] at h\n        simp only [Nat.succ_eq_add_one, insertAndContractNat, Finset.le_eq_subset,\n          Finset.mem_insert, Finset.mem_map, RelEmbedding.coe_toEmbedding, forall_eq_or_imp,\n          Finset.mem_singleton, not_or, forall_exists_index, and_imp, forall_apply_eq_imp_iff\u2082] at h\n        have hc := h.2 p hp\n        rw [Finset.mapEmbedding_apply] at hc\n        exact (Finset.mem_map' (i.succAboveEmb)).mpr.mt hc\n      \u00b7 intro h\n        obtain \u27e8z', hz'1, hz'\u27e9 := h\n        rw [Function.Injective.eq_iff (Fin.succAbove_right_injective)] at hz'1\n        subst hz'1\n        rw [mem_uncontracted_iff_not_contracted]\n        simp only [Nat.succ_eq_add_one, insertAndContractNat, Finset.le_eq_subset,\n          Finset.mem_insert, Finset.mem_map, RelEmbedding.coe_toEmbedding, forall_eq_or_imp,\n          Finset.mem_singleton, not_or, forall_exists_index, and_imp, forall_apply_eq_imp_iff\u2082]\n        apply And.intro\n        \u00b7 rw [Function.Injective.eq_iff (Fin.succAbove_right_injective)]\n          exact And.intro (Fin.succAbove_ne i z) (fun a => hjz a.symm)\n        \u00b7 rw [mem_uncontracted_iff_not_contracted] at hz'\n          exact fun a ha hc => hz'.1 a ha ((Finset.mem_map' (i.succAboveEmb)).mp hc)", "proofType": "tactic", "proofLengthLines": 45, "proofLengthTokens": 2407}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.WickContraction.InsertAndContract\n\n/-!\n\n# Sign associated with a contraction\n\n-/\n\nopen FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\nnamespace WickContraction\nvariable {n : \u2115} (c : WickContraction n)\nopen HepLean.List\nopen FieldStatistic\n\n/-- Given a Wick contraction `c : WickContraction n` and `i1 i2 : Fin n` the finite set\n  of elements of `Fin n` between `i1` and `i2` which are either uncontracted\n  or are contracted but are contracted with an element occurring after `i1`.\n  In other words, the elements of `Fin n` between `i1` and `i2` which are not\n  contracted with before `i1`.\n  One should assume `i1 < i2` otherwise this finite set is empty. -/\ndef signFinset (c : WickContraction n) (i1 i2 : Fin n) : Finset (Fin n) :=\n  Finset.univ.filter (fun i => i1 < i \u2227 i < i2 \u2227\n  (c.getDual? i = none \u2228 \u2200 (h : (c.getDual? i).isSome), i1 < (c.getDual? i).get h))\n\n/-- For a list `\u03c6s` of `\ud835\udcd5.FieldOp`, and a Wick contraction `\u03c6s\u039b` of `\u03c6s`,\n  the complex number `\u03c6s\u039b.sign` is defined to be the sign (`1` or `-1`) corresponding\n  to the number of `fermionic`-`fermionic` exchanges that must be done to put\n  contracted pairs within `\u03c6s\u039b` next to one another, starting recursively\n  from the contracted pair\n  whose first element occurs at the left-most position. -/\ndef sign (\u03c6s : List \ud835\udcd5.FieldOp) (\u03c6s\u039b : WickContraction \u03c6s.length) : \u2102 :=\n  \u220f (a : \u03c6s\u039b.1), \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s[\u03c6s\u039b.sndFieldOfContract a],\n    \ud835\udcd5 |>\u209b \u27e8\u03c6s.get, \u03c6s\u039b.signFinset (\u03c6s\u039b.fstFieldOfContract a) (\u03c6s\u039b.sndFieldOfContract a)\u27e9)\n\nlemma sign_empty (\u03c6s : List \ud835\udcd5.FieldOp) :\n    sign \u03c6s empty = 1 := by\n  rw [sign]\n  simp [empty]\n\n", "theoremStatement": "lemma sign_congr {\u03c6s \u03c6s' : List \ud835\udcd5.FieldOp} (h : \u03c6s = \u03c6s') (\u03c6s\u039b : WickContraction \u03c6s.length) :\n    sign \u03c6s' (congr (by simp [h]) \u03c6s\u039b) = sign \u03c6s \u03c6s\u039b ", "theoremName": "WickContraction.sign_congr", "fileCreated": {"commit": "ff4a56226cdb330ba2e2fb86afe224b906b97b64", "date": "2025-02-03"}, "theoremCreated": {"commit": "12d36dc1d9c726c035301091e57be0b29015e4ae", "date": "2025-01-31"}, "file": "HepLean/HepLean/PerturbationTheory/WickContraction/Sign/Basic.lean", "module": "HepLean.PerturbationTheory.WickContraction.Sign.Basic", "jsonFile": "HepLean.PerturbationTheory.WickContraction.Sign.Basic.jsonl", "positionMetadata": {"lineInFile": 47, "tokenPositionInFile": 1785, "theoremPositionInFile": 3}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 5, "numPremises": 20}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  subst h\n  rfl", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 21}}
{"srcContext": "/-\nCopyright (c) 2024 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.Koszul.KoszulSignInsert\nimport HepLean.Mathematics.List.InsertionSort\n/-!\n\n# Koszul sign\n\n-/\n\nnamespace Wick\n\nopen HepLean.List\nopen FieldStatistic\n\nvariable {\ud835\udcd5 : Type} (q : \ud835\udcd5 \u2192 FieldStatistic) (le : \ud835\udcd5 \u2192 \ud835\udcd5 \u2192 Prop) [DecidableRel le]\n\n/-- Gives a factor of `- 1` for every fermion-fermion (`q` is `1`) crossing that occurs when sorting\n  a list of based on `r`. -/\ndef koszulSign (q : \ud835\udcd5 \u2192 FieldStatistic) (le : \ud835\udcd5 \u2192 \ud835\udcd5 \u2192 Prop) [DecidableRel le] :\n    List \ud835\udcd5 \u2192 \u2102\n  | [] => 1\n  | a :: l => koszulSignInsert q le a l * koszulSign q le l\n\n@[simp]\nlemma koszulSign_singleton (q : \ud835\udcd5 \u2192 FieldStatistic) (le : \ud835\udcd5 \u2192 \ud835\udcd5 \u2192 Prop) [DecidableRel le] (\u03c6 : \ud835\udcd5) :\n    koszulSign q le [\u03c6] = 1 := by\n  simp [koszulSign, koszulSignInsert]\n\n", "theoremStatement": "lemma koszulSign_mul_self (l : List \ud835\udcd5) : koszulSign q le l * koszulSign q le l = 1 ", "theoremName": "Wick.koszulSign_mul_self", "fileCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "theoremCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "file": "HepLean/HepLean/PerturbationTheory/Koszul/KoszulSign.lean", "module": "HepLean.PerturbationTheory.Koszul.KoszulSign", "jsonFile": "HepLean.PerturbationTheory.Koszul.KoszulSign.jsonl", "positionMetadata": {"lineInFile": 33, "tokenPositionInFile": 908, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 4, "numPremises": 69}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  induction l with\n  | nil => simp [koszulSign]\n  | cons a l ih =>\n    simp only [koszulSign]\n    trans (koszulSignInsert q le a l * koszulSignInsert q le a l) *\n      (koszulSign q le l * koszulSign q le l)\n    \u00b7 ring\n    \u00b7 rw [ih, koszulSignInsert_mul_self, mul_one]", "proofType": "tactic", "proofLengthLines": 8, "proofLengthTokens": 274}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpAlgebra.NormalOrder.Basic\n/-!\n\n# Basic properties of normal ordering\n\n-/\n\nnamespace FieldSpecification\nopen FieldOpFreeAlgebra\nopen HepLean.List\nopen FieldStatistic\n\nnamespace FieldOpAlgebra\nvariable {\ud835\udcd5 : FieldSpecification}\n\n/-!\n\n## Properties of normal ordering.\n\n-/\n\nlemma normalOrder_eq_\u03b9_normalOrderF (a : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \ud835\udcdd(\u03b9 a) = \u03b9 \ud835\udcdd\u1da0(a) := rfl\n\nlemma normalOrder_ofCrAnList (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    \ud835\udcdd(ofCrAnList \u03c6s) = normalOrderSign \u03c6s \u2022 ofCrAnList (normalOrderList \u03c6s) := by\n  rw [ofCrAnList, normalOrder_eq_\u03b9_normalOrderF, normalOrderF_ofCrAnListF]\n  rfl\n\n@[simp]\nlemma normalOrder_one_eq_one : normalOrder (\ud835\udcd5 := \ud835\udcd5) 1 = 1 := by\n  have h1 : 1 = ofCrAnList (\ud835\udcd5 := \ud835\udcd5) [] := by simp [ofCrAnList]\n  rw [h1]\n  rw [normalOrder_ofCrAnList]\n  simp\n\n@[simp]\nlemma normalOrder_ofFieldOpList_nil : normalOrder (\ud835\udcd5 := \ud835\udcd5) (ofFieldOpList []) = 1 := by\n  rw [ofFieldOpList]\n  rw [normalOrder_eq_\u03b9_normalOrderF]\n  simp only [ofFieldOpListF_nil]\n  change normalOrder (\ud835\udcd5 := \ud835\udcd5) 1 = _\n  simp\n\n@[simp]\nlemma normalOrder_ofCrAnList_nil : normalOrder (\ud835\udcd5 := \ud835\udcd5) (ofCrAnList []) = 1 := by\n  rw [normalOrder_ofCrAnList]\n  simp only [normalOrderSign_nil, normalOrderList_nil, one_smul]\n  rfl\n\nlemma ofCrAnList_eq_normalOrder (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnList (normalOrderList \u03c6s) = normalOrderSign \u03c6s \u2022 \ud835\udcdd(ofCrAnList \u03c6s) := by\n  rw [normalOrder_ofCrAnList, smul_smul, normalOrderSign, Wick.koszulSign_mul_self,\n    one_smul]\n\nlemma normalOrder_normalOrder_mid (a b c : \ud835\udcd5.FieldOpAlgebra) :\n    \ud835\udcdd(a * b * c) = \ud835\udcdd(a * \ud835\udcdd(b) * c) := by\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n  obtain \u27e8c, rfl\u27e9 := \u03b9_surjective c\n  rw [normalOrder_eq_\u03b9_normalOrderF]\n  simp only [\u2190 map_mul]\n  rw [normalOrder_eq_\u03b9_normalOrderF]\n  rw [normalOrderF_normalOrderF_mid]\n  rfl\n\nlemma normalOrder_normalOrder_left (a b : \ud835\udcd5.FieldOpAlgebra) :\n    \ud835\udcdd(a * b) = \ud835\udcdd(\ud835\udcdd(a) * b) := by\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n  rw [normalOrder_eq_\u03b9_normalOrderF]\n  simp only [\u2190 map_mul]\n  rw [normalOrder_eq_\u03b9_normalOrderF]\n  rw [normalOrderF_normalOrderF_left]\n  rfl\n\nlemma normalOrder_normalOrder_right (a b : \ud835\udcd5.FieldOpAlgebra) :\n    \ud835\udcdd(a * b) = \ud835\udcdd(a * \ud835\udcdd(b)) := by\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n  rw [normalOrder_eq_\u03b9_normalOrderF]\n  simp only [\u2190 map_mul]\n  rw [normalOrder_eq_\u03b9_normalOrderF]\n  rw [normalOrderF_normalOrderF_right]\n  rfl\n\nlemma normalOrder_normalOrder (a : \ud835\udcd5.FieldOpAlgebra) : \ud835\udcdd(\ud835\udcdd(a)) = \ud835\udcdd(a) := by\n  trans \ud835\udcdd(\ud835\udcdd(a) * 1)\n  \u00b7 simp\n  \u00b7 rw [\u2190 normalOrder_normalOrder_left]\n    simp\n\n/-!\n\n## mul anpart and crpart\n-/\n\nlemma normalOrder_mul_anPart (\u03c6 : \ud835\udcd5.FieldOp) (a : \ud835\udcd5.FieldOpAlgebra) :\n    \ud835\udcdd(a * anPart \u03c6) = \ud835\udcdd(a) * anPart \u03c6 := by\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  rw [anPart, \u2190 map_mul, normalOrder_eq_\u03b9_normalOrderF, normalOrderF_mul_anPartF]\n  rfl\n\nlemma crPart_mul_normalOrder (\u03c6 : \ud835\udcd5.FieldOp) (a : \ud835\udcd5.FieldOpAlgebra) :\n    \ud835\udcdd(crPart \u03c6 * a) = crPart \u03c6 * \ud835\udcdd(a) := by\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  rw [crPart, \u2190 map_mul, normalOrder_eq_\u03b9_normalOrderF, normalOrderF_crPartF_mul]\n  rfl\n\n/-!\n\n### Normal order and super commutes\n\n-/\n\n/-- For a field specification `\ud835\udcd5`, and `a` and `b` in `\ud835\udcd5.FieldOpAlgebra` the normal ordering\n  of the super commutator of `a` and `b` vanishes, i.e. `\ud835\udcdd([a,b]\u209b) = 0`. -/\n@[simp]\nlemma normalOrder_superCommute_eq_zero (a b : \ud835\udcd5.FieldOpAlgebra) :\n    \ud835\udcdd([a, b]\u209b) = 0 := by\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n  rw [superCommute_eq_\u03b9_superCommuteF, normalOrder_eq_\u03b9_normalOrderF]\n  simp\n\n@[simp]\nlemma normalOrder_superCommute_left_eq_zero (a b c: \ud835\udcd5.FieldOpAlgebra) :\n    \ud835\udcdd([a, b]\u209b * c) = 0 := by\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n  obtain \u27e8c, rfl\u27e9 := \u03b9_surjective c\n  rw [superCommute_eq_\u03b9_superCommuteF, \u2190 map_mul, normalOrder_eq_\u03b9_normalOrderF]\n  simp\n\n@[simp]\nlemma normalOrder_superCommute_right_eq_zero (a b c: \ud835\udcd5.FieldOpAlgebra) :\n    \ud835\udcdd(c * [a, b]\u209b) = 0 := by\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n  obtain \u27e8c, rfl\u27e9 := \u03b9_surjective c\n  rw [superCommute_eq_\u03b9_superCommuteF, \u2190 map_mul, normalOrder_eq_\u03b9_normalOrderF]\n  simp\n\n@[simp]\nlemma normalOrder_superCommute_mid_eq_zero (a b c d : \ud835\udcd5.FieldOpAlgebra) :\n    \ud835\udcdd(a * [c, d]\u209b * b) = 0 := by\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n  obtain \u27e8c, rfl\u27e9 := \u03b9_surjective c\n  obtain \u27e8d, rfl\u27e9 := \u03b9_surjective d\n  rw [superCommute_eq_\u03b9_superCommuteF, \u2190 map_mul, \u2190 map_mul, normalOrder_eq_\u03b9_normalOrderF]\n  simp\n\n/-!\n\n### Swapping terms in a normal order.\n\n-/\n\nlemma normalOrder_ofFieldOp_ofFieldOp_swap (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    \ud835\udcdd(ofFieldOp \u03c6 * ofFieldOp \u03c6') = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 \ud835\udcdd(ofFieldOp \u03c6' * ofFieldOp \u03c6) := by\n  rw [ofFieldOp_mul_ofFieldOp_eq_superCommute]\n  simp\n\nlemma normalOrder_ofCrAnOp_ofCrAnList (\u03c6 : \ud835\udcd5.CrAnFieldOp)\n    (\u03c6s : List \ud835\udcd5.CrAnFieldOp) : \ud835\udcdd(ofCrAnOp \u03c6 * ofCrAnList \u03c6s) =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 \ud835\udcdd(ofCrAnList \u03c6s * ofCrAnOp \u03c6) := by\n  rw [\u2190 ofCrAnList_singleton, ofCrAnList_mul_ofCrAnList_eq_superCommute]\n  simp\n\nlemma normalOrder_ofCrAnOp_ofFieldOpList_swap (\u03c6 : \ud835\udcd5.CrAnFieldOp) (\u03c6' : List \ud835\udcd5.FieldOp) :\n    \ud835\udcdd(ofCrAnOp \u03c6 * ofFieldOpList \u03c6') = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022\n    \ud835\udcdd(ofFieldOpList \u03c6' * ofCrAnOp \u03c6) := by\n  rw [\u2190 ofCrAnList_singleton, ofCrAnList_mul_ofFieldOpList_eq_superCommute]\n  simp\n\nlemma normalOrder_anPart_ofFieldOpList_swap (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6' : List \ud835\udcd5.FieldOp) :\n    \ud835\udcdd(anPart \u03c6 * ofFieldOpList \u03c6') = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 \ud835\udcdd(ofFieldOpList \u03c6' * anPart \u03c6) := by\n  match \u03c6 with\n  | .inAsymp \u03c6 =>\n    simp\n  | .position \u03c6 =>\n    simp only [anPart_position, instCommGroup.eq_1]\n    rw [normalOrder_ofCrAnOp_ofFieldOpList_swap]\n    rfl\n  | .outAsymp \u03c6 =>\n    simp only [anPart_posAsymp, instCommGroup.eq_1]\n    rw [normalOrder_ofCrAnOp_ofFieldOpList_swap]\n    rfl\n\nlemma normalOrder_ofFieldOpList_anPart_swap (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6' : List \ud835\udcd5.FieldOp) :\n    \ud835\udcdd(ofFieldOpList \u03c6' * anPart \u03c6) = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 \ud835\udcdd(anPart \u03c6 * ofFieldOpList \u03c6') := by\n  rw [normalOrder_anPart_ofFieldOpList_swap]\n  simp [smul_smul, FieldStatistic.exchangeSign_mul_self]\n\nlemma normalOrder_ofFieldOpList_mul_anPart_swap (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    \ud835\udcdd(ofFieldOpList \u03c6s) * anPart \u03c6 = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 \ud835\udcdd(anPart \u03c6 * ofFieldOpList \u03c6s) := by\n  rw [\u2190 normalOrder_mul_anPart]\n  rw [normalOrder_ofFieldOpList_anPart_swap]\n\nlemma anPart_mul_normalOrder_ofFieldOpList_eq_superCommute (\u03c6 : \ud835\udcd5.FieldOp)\n    (\u03c6s' : List \ud835\udcd5.FieldOp) : anPart \u03c6 * \ud835\udcdd(ofFieldOpList \u03c6s') =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s') \u2022 \ud835\udcdd(ofFieldOpList \u03c6s' * anPart \u03c6) +\n    [anPart \u03c6, \ud835\udcdd(ofFieldOpList \u03c6s')]\u209b := by\n  rw [anPart, ofFieldOpList, normalOrder_eq_\u03b9_normalOrderF, \u2190 map_mul]\n  rw [anPartF_mul_normalOrderF_ofFieldOpListF_eq_superCommuteF]\n  simp only [instCommGroup.eq_1, map_add, map_smul]\n  rfl\n\n/-!\n\n## Super commutators with a normal ordered term as sums\n\n-/\n\n/--\nFor a field specification `\ud835\udcd5`, an element `\u03c6` of `\ud835\udcd5.CrAnFieldOp`, a list `\u03c6s` of `\ud835\udcd5.CrAnFieldOp`,\n  the following relation holds\n\n`[\u03c6, \ud835\udcdd(\u03c6\u2080\u2026\u03c6\u2099)]\u209b = \u2211 i, \ud835\udce2(\u03c6, \u03c6\u2080\u2026\u03c6\u1d62\u208b\u2081) \u2022 [\u03c6, \u03c6\u1d62]\u209b * \ud835\udcdd(\u03c6\u2080\u2026\u03c6\u1d62\u208b\u2081\u03c6\u1d62\u208a\u2081\u2026\u03c6\u2099)`.\n\nThe proof of this result ultimately goes as follows\n- The definition of `normalOrder` is used to rewrite `\ud835\udcdd(\u03c6\u2080\u2026\u03c6\u2099)` as a scalar multiple of\n  a `ofCrAnList \u03c6sn` where `\u03c6sn` is the normal ordering of `\u03c6\u2080\u2026\u03c6\u2099`.\n- `superCommuteF_ofCrAnListF_ofCrAnListF_eq_sum` is used to rewrite the super commutator of `\u03c6`\n  (considered as a list with one element) with\n  `ofCrAnList \u03c6sn` as a sum of super commutators, one for each element of `\u03c6sn`.\n- The fact that super-commutators are in the center of `\ud835\udcd5.FieldOpAlgebra` is used to  rearrange\n  terms.\n- Properties of ordered lists, and `normalOrderSign_eraseIdx` are then used to complete the proof.\n-/\nlemma ofCrAnOp_superCommute_normalOrder_ofCrAnList_sum (\u03c6 : \ud835\udcd5.CrAnFieldOp)\n    (\u03c6s : List \ud835\udcd5.CrAnFieldOp) : [ofCrAnOp \u03c6, \ud835\udcdd(ofCrAnList \u03c6s)]\u209b = \u2211 n : Fin \u03c6s.length,\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b (\u03c6s.take n)) \u2022 [ofCrAnOp \u03c6, ofCrAnOp \u03c6s[n]]\u209b\n    * \ud835\udcdd(ofCrAnList (\u03c6s.eraseIdx n)) := by\n  rw [normalOrder_ofCrAnList, map_smul]\n  rw [superCommute_ofCrAnOp_ofCrAnList_eq_sum, Finset.smul_sum,\n    sum_normalOrderList_length]\n  congr\n  funext n\n  simp only [instCommGroup.eq_1, List.get_eq_getElem, normalOrderList_get_normalOrderEquiv,\n    normalOrderList_eraseIdx_normalOrderEquiv, Algebra.smul_mul_assoc, Fin.getElem_fin]\n  rw [ofCrAnList_eq_normalOrder, mul_smul_comm, smul_smul, smul_smul]\n  by_cases hs : (\ud835\udcd5 |>\u209b \u03c6) = (\ud835\udcd5 |>\u209b \u03c6s[n])\n  \u00b7 congr\n    erw [normalOrderSign_eraseIdx, \u2190 hs]\n    trans (normalOrderSign \u03c6s * normalOrderSign \u03c6s) *\n      (\ud835\udce2(\ud835\udcd5 |>\u209b (\u03c6s.get n), \ud835\udcd5 |>\u209b ((normalOrderList \u03c6s).take (normalOrderEquiv n))) *\n      \ud835\udce2(\ud835\udcd5 |>\u209b (\u03c6s.get n), \ud835\udcd5 |>\u209b ((normalOrderList \u03c6s).take (normalOrderEquiv n))))\n      * \ud835\udce2(\ud835\udcd5 |>\u209b (\u03c6s.get n), \ud835\udcd5 |>\u209b (\u03c6s.take n))\n    \u00b7 ring_nf\n      rw [hs]\n      rfl\n    \u00b7 simp [hs]\n  \u00b7 erw [superCommute_diff_statistic hs]\n    simp\n\nlemma ofCrAnOp_superCommute_normalOrder_ofFieldOpList_sum (\u03c6 : \ud835\udcd5.CrAnFieldOp)\n    (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [ofCrAnOp \u03c6, \ud835\udcdd(ofFieldOpList \u03c6s)]\u209b = \u2211 n : Fin \u03c6s.length, \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b (\u03c6s.take n)) \u2022\n    [ofCrAnOp \u03c6, ofFieldOp \u03c6s[n]]\u209b * \ud835\udcdd(ofFieldOpList (\u03c6s.eraseIdx n)) := by\n  conv_lhs =>\n    rw [ofFieldOpList_eq_sum, map_sum, map_sum]\n    enter [2, s]\n    rw [ofCrAnOp_superCommute_normalOrder_ofCrAnList_sum, CrAnSection.sum_over_length]\n    enter [2, n]\n    rw [CrAnSection.take_statistics_eq_take_state_statistics, smul_mul_assoc]\n  rw [Finset.sum_comm]\n  refine Finset.sum_congr rfl (fun n _ => ?_)\n  simp only [instCommGroup.eq_1, Fin.coe_cast, Fin.getElem_fin,\n    CrAnSection.sum_eraseIdxEquiv n _ n.prop,\n    CrAnSection.eraseIdxEquiv_symm_getElem,\n    CrAnSection.eraseIdxEquiv_symm_eraseIdx, \u2190 Finset.smul_sum, Algebra.smul_mul_assoc]\n  conv_lhs =>\n    enter [2, 2, n]\n    rw [\u2190 Finset.mul_sum]\n  rw [\u2190 Finset.sum_mul, \u2190 map_sum, \u2190 map_sum, \u2190 ofFieldOp_eq_sum, \u2190 ofFieldOpList_eq_sum]\n\n/--\nThe commutator of the annihilation part of a field operator with a normal ordered list of field\noperators can be decomposed into the sum of the commutators of the annihilation part with each\nelement of the list of field operators, i.e.\n`[anPart \u03c6, \ud835\udcdd(\u03c6\u2080\u2026\u03c6\u2099)]\u209b= \u2211 i, \ud835\udce2(\u03c6, \u03c6\u2080\u2026\u03c6\u1d62\u208b\u2081) \u2022 [anPart \u03c6, \u03c6\u1d62]\u209b * \ud835\udcdd(\u03c6\u2080\u2026\u03c6\u1d62\u208b\u2081\u03c6\u1d62\u208a\u2081\u2026\u03c6\u2099)`.\n-/\nlemma anPart_superCommute_normalOrder_ofFieldOpList_sum (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [anPart \u03c6, \ud835\udcdd(ofFieldOpList \u03c6s)]\u209b = \u2211 n : Fin \u03c6s.length, \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b (\u03c6s.take n)) \u2022\n    [anPart \u03c6, ofFieldOpF \u03c6s[n]]\u209b * \ud835\udcdd(ofFieldOpList (\u03c6s.eraseIdx n)) := by\n  match \u03c6 with\n  | .inAsymp \u03c6 =>\n    simp\n  | .position \u03c6 =>\n    simp only [anPart_position, instCommGroup.eq_1, Fin.getElem_fin, Algebra.smul_mul_assoc]\n    rw [ofCrAnOp_superCommute_normalOrder_ofFieldOpList_sum]\n    simp only [instCommGroup.eq_1, crAnStatistics, Function.comp_apply, crAnFieldOpToFieldOp_prod,\n      Fin.getElem_fin, Algebra.smul_mul_assoc]\n    rfl\n  | .outAsymp \u03c6 =>\n    simp only [anPart_posAsymp, instCommGroup.eq_1, Fin.getElem_fin, Algebra.smul_mul_assoc]\n    rw [ofCrAnOp_superCommute_normalOrder_ofFieldOpList_sum]\n    simp only [instCommGroup.eq_1, crAnStatistics, Function.comp_apply, crAnFieldOpToFieldOp_prod,\n      Fin.getElem_fin, Algebra.smul_mul_assoc]\n    rfl\n\n/-!\n\n## Multiplying with normal ordered terms\n\n-/\n/--\nWithin a proto-operator algebra we have that\n`anPartF \u03c6 * \ud835\udcdd(\u03c6\u2080\u03c6\u2081\u2026\u03c6\u2099) = \ud835\udcdd((anPart \u03c6)\u03c6\u2080\u03c6\u2081\u2026\u03c6\u2099) + [anpart \u03c6, \ud835\udcdd(\u03c6\u2080\u03c6\u2081\u2026\u03c6\u2099)]\u209b`.\n-/\nlemma anPart_mul_normalOrder_ofFieldOpList_eq_superCommute_reorder (\u03c6 : \ud835\udcd5.FieldOp)\n    (\u03c6s : List \ud835\udcd5.FieldOp) : anPart \u03c6 * \ud835\udcdd(ofFieldOpList \u03c6s) =\n    \ud835\udcdd(anPart \u03c6 * ofFieldOpList \u03c6s) + [anPart \u03c6, \ud835\udcdd(ofFieldOpList \u03c6s)]\u209b := by\n  rw [anPart_mul_normalOrder_ofFieldOpList_eq_superCommute]\n  simp only [instCommGroup.eq_1, add_left_inj]\n  rw [normalOrder_anPart_ofFieldOpList_swap]\n\n/--\nWithin a proto-operator algebra we have that\n`\u03c6 * \ud835\udcdd\u1da0(\u03c6\u2080\u03c6\u2081\u2026\u03c6\u2099) = \ud835\udcdd\u1da0(\u03c6\u03c6\u2080\u03c6\u2081\u2026\u03c6\u2099) + [anpart \u03c6, \ud835\udcdd\u1da0(\u03c6\u2080\u03c6\u2081\u2026\u03c6\u2099)]\u209bca`.\n-/\nlemma ofFieldOp_mul_normalOrder_ofFieldOpList_eq_superCommute (\u03c6 : \ud835\udcd5.FieldOp)\n    (\u03c6s : List \ud835\udcd5.FieldOp) : ofFieldOp \u03c6 * \ud835\udcdd(ofFieldOpList \u03c6s) =\n    \ud835\udcdd(ofFieldOp \u03c6 * ofFieldOpList \u03c6s) + [anPart \u03c6, \ud835\udcdd(ofFieldOpList \u03c6s)]\u209b := by\n  conv_lhs => rw [ofFieldOp_eq_crPart_add_anPart]\n  rw [add_mul, anPart_mul_normalOrder_ofFieldOpList_eq_superCommute_reorder, \u2190 add_assoc,\n    \u2190 crPart_mul_normalOrder, \u2190 map_add]\n  conv_lhs =>\n    lhs\n    rw [\u2190 add_mul, \u2190 ofFieldOp_eq_crPart_add_anPart]\n\n/-- In the expansion of `ofFieldOpF \u03c6 * normalOrderF (ofFieldOpListF \u03c6s)` the element\n  of `\ud835\udcde.A` associated with contracting `\u03c6` with the (optional) `n`th element of `\u03c6s`. -/\nnoncomputable def contractStateAtIndex (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp)\n    (n : Option (Fin \u03c6s.length)) : \ud835\udcd5.FieldOpAlgebra :=\n  match n with\n  | none => 1\n  | some n => \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b (\u03c6s.take n)) \u2022 [anPart \u03c6, ofFieldOp \u03c6s[n]]\u209b\n\n/--\nFor a field specification `\ud835\udcd5`, a `\u03c6` in `\ud835\udcd5.FieldOp` and a list `\u03c6s` of `\ud835\udcd5.FieldOp`\nthen `\u03c6 * \ud835\udcdd(\u03c6\u2080\u03c6\u2081\u2026\u03c6\u2099)` is equal to\n\n`\ud835\udcdd(\u03c6\u03c6\u2080\u03c6\u2081\u2026\u03c6\u2099) + \u2211 i, (\ud835\udce2(\u03c6,\u03c6\u2080\u03c6\u2081\u2026\u03c6\u1d62\u208b\u2081) \u2022 [anPart \u03c6, \u03c6\u1d62]\u209b) * \ud835\udcdd(\u03c6\u2080\u2026\u03c6\u1d62\u208b\u2081\u03c6\u1d62\u208a\u2081\u2026\u03c6\u2099)`.\n\nThe proof of ultimately goes as follows:\n- `ofFieldOp_eq_crPart_add_anPart` is used to split `\u03c6` into its creation and annihilation parts.\n- The following relation is then used\n\n  `crPart \u03c6 * \ud835\udcdd(\u03c6\u2080\u03c6\u2081\u2026\u03c6\u2099) = \ud835\udcdd(crPart \u03c6 * \u03c6\u2080\u03c6\u2081\u2026\u03c6\u2099)`.\n\n- It used that  `anPart \u03c6 * \ud835\udcdd(\u03c6\u2080\u03c6\u2081\u2026\u03c6\u2099)` is equal to\n\n  `\ud835\udce2(\u03c6, \u03c6\u2080\u03c6\u2081\u2026\u03c6\u2099) \ud835\udcdd(\u03c6\u2080\u03c6\u2081\u2026\u03c6\u2099) * anPart \u03c6 + [anPart \u03c6, \ud835\udcdd(\u03c6\u2080\u03c6\u2081\u2026\u03c6\u2099)]`\n\n- Then it is used that\n\n  `\ud835\udce2(\u03c6, \u03c6\u2080\u03c6\u2081\u2026\u03c6\u2099) \ud835\udcdd(\u03c6\u2080\u03c6\u2081\u2026\u03c6\u2099) * anPart \u03c6 = \ud835\udcdd(anPart \u03c6 * \u03c6\u2080\u03c6\u2081\u2026\u03c6\u2099)`\n\n- The result `ofCrAnOp_superCommute_normalOrder_ofCrAnList_sum` is used\n  to expand `[anPart \u03c6, \ud835\udcdd(\u03c6\u2080\u03c6\u2081\u2026\u03c6\u2099)]` as a sum.\n-/\nlemma ofFieldOp_mul_normalOrder_ofFieldOpList_eq_sum (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    ofFieldOp \u03c6 * \ud835\udcdd(ofFieldOpList \u03c6s) =\n    \u2211 n : Option (Fin \u03c6s.length), contractStateAtIndex \u03c6 \u03c6s n *\n    \ud835\udcdd(ofFieldOpList (optionEraseZ \u03c6s \u03c6 n)) := by\n  rw [ofFieldOp_mul_normalOrder_ofFieldOpList_eq_superCommute]\n  rw [anPart_superCommute_normalOrder_ofFieldOpList_sum]\n  simp only [instCommGroup.eq_1, Fin.getElem_fin, Algebra.smul_mul_assoc, contractStateAtIndex,\n    Fintype.sum_option, one_mul]\n  rfl\n\n/-!\n\n## Cons vs insertIdx for a normal ordered term.\n\n-/\n\n", "theoremStatement": "/--\nWithin a proto-operator algebra, `N(\u03c6\u03c6\u2080\u03c6\u2081\u2026\u03c6\u2099) = s \u2022 N(\u03c6\u2080\u2026\u03c6\u2096\u208b\u2081\u03c6\u03c6\u2096\u2026\u03c6\u2099)`, where\n`s` is the exchange sign for `\u03c6` and `\u03c6\u2080\u2026\u03c6\u2096\u208b\u2081`.\n-/\nlemma ofFieldOpList_normalOrder_insert (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp)\n    (k : Fin \u03c6s.length.succ) : \ud835\udcdd(ofFieldOpList (\u03c6 :: \u03c6s)) =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s.take k) \u2022 \ud835\udcdd(ofFieldOpList (\u03c6s.insertIdx k \u03c6)) ", "theoremName": "FieldSpecification.FieldOpAlgebra.ofFieldOpList_normalOrder_insert", "fileCreated": {"commit": "2e82f842a242717b98517656fc34b1b92f579b2e", "date": "2025-02-05"}, "theoremCreated": {"commit": "fc2009928299f5a839dd880670f22245b6a09f72", "date": "2025-01-30"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpAlgebra/NormalOrder/Lemmas.lean", "module": "HepLean.PerturbationTheory.FieldOpAlgebra.NormalOrder.Lemmas", "jsonFile": "HepLean.PerturbationTheory.FieldOpAlgebra.NormalOrder.Lemmas.jsonl", "positionMetadata": {"lineInFile": 386, "tokenPositionInFile": 14198, "theoremPositionInFile": 30}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 22, "numPremises": 161}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  have hl : \u03c6s.insertIdx k \u03c6 = \u03c6s.take k ++ [\u03c6] ++ \u03c6s.drop k := by\n    rw [HepLean.List.insertIdx_eq_take_drop]\n    simp\n  rw [hl]\n  rw [ofFieldOpList_append, ofFieldOpList_append]\n  rw [ofFieldOpList_mul_ofFieldOpList_eq_superCommute, add_mul]\n  simp only [instCommGroup.eq_1, Nat.succ_eq_add_one, ofList_singleton, Algebra.smul_mul_assoc,\n    map_add, map_smul, normalOrder_superCommute_left_eq_zero, add_zero, smul_smul,\n    exchangeSign_mul_self_swap, one_smul]\n  rw [\u2190 ofFieldOpList_append, \u2190 ofFieldOpList_append]\n  simp", "proofType": "tactic", "proofLengthLines": 11, "proofLengthTokens": 532}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldSpecification.CrAnFieldOp\nimport HepLean.PerturbationTheory.FieldSpecification.CrAnSection\n/-!\n\n# Creation and annihilation free-algebra\n\nThis module defines the creation and annihilation algebra for a field structure.\n\nThe creation and annihilation algebra extends from the state algebra by adding information about\nwhether a state is a creation or annihilation operator.\n\nThe algebra is spanned by lists of creation/annihilation states.\n\nThe main structures defined in this module are:\n\n* `FieldOpFreeAlgebra` - The creation and annihilation algebra\n* `ofCrAnOpF` - Maps a creation/annihilation state to the algebra\n* `ofCrAnListF` - Maps a list of creation/annihilation states to the algebra\n* `ofFieldOpF` - Maps a state to a sum of creation and annihilation operators\n* `crPartF` - The creation part of a state in the algebra\n* `anPartF` - The annihilation part of a state in the algebra\n* `superCommuteF` - The super commutator on the algebra\n\nThe key lemmas show how these operators interact, particularly focusing on the\nsuper commutation relations between creation and annihilation operators.\n\n-/\n\nnamespace FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\n/-- For a field specification `\ud835\udcd5`, the algebra `\ud835\udcd5.FieldOpFreeAlgebra` is\n  the free algebra generated by `\ud835\udcd5.CrAnFieldOp`. -/\nabbrev FieldOpFreeAlgebra (\ud835\udcd5 : FieldSpecification) : Type := FreeAlgebra \u2102 \ud835\udcd5.CrAnFieldOp\n\nnamespace FieldOpFreeAlgebra\n\nremark naming_convention := \"\n  For mathematicial objects defined in relation to `FieldOpFreeAlgebra` the postfix `F`\n  may be given to\n  their names to indicate that they are related to the free algebra.\n  This is to avoid confusion when working within the context of `FieldOpAlgebra` which is defined\n  as a quotient of `FieldOpFreeAlgebra`.\"\n\n/-- For a field specification `\ud835\udcd5`, and a element `\u03c6` of `\ud835\udcd5.CrAnFieldOp`,\n  `ofCrAnOpF \u03c6` is defined as the element of `\ud835\udcd5.FieldOpFreeAlgebra` formed by `\u03c6`. -/\ndef ofCrAnOpF (\u03c6 : \ud835\udcd5.CrAnFieldOp) : FieldOpFreeAlgebra \ud835\udcd5 :=\n  FreeAlgebra.\u03b9 \u2102 \u03c6\n\n/--\nThe algebra `\ud835\udcd5.FieldOpFreeAlgebra` satisfies the universal property that for any other algebra\n  `A` (e.g. the operator algebra of the theory) with a map `f : \ud835\udcd5.CrAnFieldOp \u2192 A` (e.g.\n  the inclusion of the creation and annihilation parts of field operators into the\n  operator algebra) there is a unique algebra map `g : \ud835\udcd5.FieldOpFreeAlgebra \u2192 A`\n  such that `g \u2218 ofCrAnOpF = f`.\n\n  The unique `g` is given by `FreeAlgebra.lift \u2102 f`.\n-/\nlemma universality {A : Type} [Semiring A] [Algebra \u2102 A] (f : \ud835\udcd5.CrAnFieldOp \u2192 A) :\n    \u2203! g : FieldOpFreeAlgebra \ud835\udcd5 \u2192\u2090[\u2102] A, g \u2218 ofCrAnOpF = f := by\n  use FreeAlgebra.lift \u2102 f\n  apply And.intro\n  \u00b7 funext x\n    simp [ofCrAnOpF]\n  \u00b7 intro g hg\n    ext x\n    simpa using congrFun hg x\n\n/-- For a field specification `\ud835\udcd5`, and a list `\u03c6s` of `\ud835\udcd5.CrAnFieldOp`,\n `ofCrAnListF \u03c6s` is defined as the element of `\ud835\udcd5.FieldOpFreeAlgebra`\n  obtained by the product of `ofCrAnListF \u03c6` for each `\u03c6` in `\u03c6s`.\n  For example `ofCrAnListF [\u03c6\u2081, \u03c6\u2082, \u03c6\u2083] = ofCrAnOpF \u03c6\u2081 * ofCrAnOpF \u03c6\u2082 * ofCrAnOpF \u03c6\u2083`.\n  The set of all `ofCrAnListF \u03c6s` forms a basis of `FieldOpFreeAlgebra \ud835\udcd5`. -/\ndef ofCrAnListF (\u03c6s : List \ud835\udcd5.CrAnFieldOp) : FieldOpFreeAlgebra \ud835\udcd5 := (List.map ofCrAnOpF \u03c6s).prod\n\n@[simp]\nlemma ofCrAnListF_nil : ofCrAnListF ([] : List \ud835\udcd5.CrAnFieldOp) = 1 := rfl\n\nlemma ofCrAnListF_cons (\u03c6 : \ud835\udcd5.CrAnFieldOp) (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnListF (\u03c6 :: \u03c6s) = ofCrAnOpF \u03c6 * ofCrAnListF \u03c6s := rfl\n\nlemma ofCrAnListF_append (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnListF (\u03c6s ++ \u03c6s') = ofCrAnListF \u03c6s * ofCrAnListF \u03c6s' := by\n  simp [ofCrAnListF, List.map_append]\n\nlemma ofCrAnListF_singleton (\u03c6 : \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnListF [\u03c6] = ofCrAnOpF \u03c6 := by simp [ofCrAnListF]\n\n/-- For a field specification `\ud835\udcd5`, and an element `\u03c6` of  `\ud835\udcd5.FieldOp`,\n  `ofFieldOpF \u03c6` is the element of `\ud835\udcd5.FieldOpFreeAlgebra` formed  by summing over\n  `ofCrAnOpF` of the\n  creation and annihilation parts of `\u03c6`.\n\n  For example for `\u03c6` an incoming asymptotic field operator we get\n  `ofCrAnOpF \u27e8\u03c6, ()\u27e9`, and for `\u03c6` a\n  position field operator we get `ofCrAnOpF \u27e8\u03c6, .create\u27e9 + ofCrAnOpF \u27e8\u03c6, .annihilate\u27e9`. -/\ndef ofFieldOpF (\u03c6 : \ud835\udcd5.FieldOp) : FieldOpFreeAlgebra \ud835\udcd5 :=\n  \u2211 (i : \ud835\udcd5.fieldOpToCrAnType \u03c6), ofCrAnOpF \u27e8\u03c6, i\u27e9\n\n/-- For a field specification `\ud835\udcd5`, and a list `\u03c6s` of `\ud835\udcd5.FieldOp`,\n  `\ud835\udcd5.ofFieldOpListF \u03c6s` is defined as the element of `\ud835\udcd5.FieldOpFreeAlgebra`\n  obtained by the product of `ofFieldOpF \u03c6` for each `\u03c6` in `\u03c6s`.\n  For example `ofFieldOpListF [\u03c6\u2081, \u03c6\u2082, \u03c6\u2083] = ofFieldOpF \u03c6\u2081 * ofFieldOpF \u03c6\u2082 * ofFieldOpF \u03c6\u2083`. -/\ndef ofFieldOpListF (\u03c6s : List \ud835\udcd5.FieldOp) : FieldOpFreeAlgebra \ud835\udcd5 := (List.map ofFieldOpF \u03c6s).prod\n\nremark notation_drop := \"In doc-strings explicit applications of `ofCrAnOpF`,\n`ofCrAnListF`, `ofFieldOpF`, and `ofFieldOpListF` will often be dropped.\"\n\n/-- Coercion from `List \ud835\udcd5.FieldOp` to `FieldOpFreeAlgebra \ud835\udcd5` through `ofFieldOpListF`. -/\ninstance : Coe (List \ud835\udcd5.FieldOp) (FieldOpFreeAlgebra \ud835\udcd5) := \u27e8ofFieldOpListF\u27e9\n\n@[simp]\nlemma ofFieldOpListF_nil : ofFieldOpListF ([] : List \ud835\udcd5.FieldOp) = 1 := rfl\n\nlemma ofFieldOpListF_cons (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    ofFieldOpListF (\u03c6 :: \u03c6s) = ofFieldOpF \u03c6 * ofFieldOpListF \u03c6s := rfl\n\nlemma ofFieldOpListF_singleton (\u03c6 : \ud835\udcd5.FieldOp) :\n    ofFieldOpListF [\u03c6] = ofFieldOpF \u03c6 := by simp [ofFieldOpListF]\n\nlemma ofFieldOpListF_append (\u03c6s \u03c6s' : List \ud835\udcd5.FieldOp) :\n    ofFieldOpListF (\u03c6s ++ \u03c6s') = ofFieldOpListF \u03c6s * ofFieldOpListF \u03c6s' := by\n  dsimp only [ofFieldOpListF]\n  rw [List.map_append, List.prod_append]\n\nlemma ofFieldOpListF_sum (\u03c6s : List \ud835\udcd5.FieldOp) :\n    ofFieldOpListF \u03c6s = \u2211 (s : CrAnSection \u03c6s), ofCrAnListF s.1 := by\n  induction \u03c6s with\n  | nil => simp\n  | cons \u03c6 \u03c6s ih =>\n    rw [CrAnSection.sum_cons]\n    dsimp only [CrAnSection.cons, ofCrAnListF_cons]\n    conv_rhs =>\n      enter [2, x]\n      rw [\u2190 Finset.mul_sum]\n    rw [\u2190 Finset.sum_mul, ofFieldOpListF_cons, \u2190 ih]\n    rfl\n\n/-!\n\n## Creation and annihilation parts of a state\n\n-/\n\n/-- The algebra map taking an element of the free-state algebra to\n  the part of it in the creation and annihilation free algebra\n  spanned by creation operators. -/\ndef crPartF : \ud835\udcd5.FieldOp \u2192 \ud835\udcd5.FieldOpFreeAlgebra := fun \u03c6 =>\n  match \u03c6 with\n  | FieldOp.inAsymp \u03c6 => ofCrAnOpF \u27e8FieldOp.inAsymp \u03c6, ()\u27e9\n  | FieldOp.position \u03c6 => ofCrAnOpF \u27e8FieldOp.position \u03c6, CreateAnnihilate.create\u27e9\n  | FieldOp.outAsymp _ => 0\n\n@[simp]\nlemma crPartF_negAsymp (\u03c6 : (\u03a3 f, \ud835\udcd5.AsymptoticLabel f) \u00d7 (Fin 3 \u2192 \u211d)) :\n    crPartF (FieldOp.inAsymp \u03c6) = ofCrAnOpF \u27e8FieldOp.inAsymp \u03c6, ()\u27e9 := by\n  simp [crPartF]\n\n@[simp]\nlemma crPartF_position (\u03c6 : (\u03a3 f, \ud835\udcd5.PositionLabel f) \u00d7 SpaceTime) :\n    crPartF (FieldOp.position \u03c6) =\n    ofCrAnOpF \u27e8FieldOp.position \u03c6, CreateAnnihilate.create\u27e9 := by\n  simp [crPartF]\n\n@[simp]\nlemma crPartF_posAsymp (\u03c6 : (\u03a3 f, \ud835\udcd5.AsymptoticLabel f) \u00d7 (Fin 3 \u2192 \u211d)) :\n    crPartF (FieldOp.outAsymp \u03c6) = 0 := by\n  simp [crPartF]\n\n/-- The algebra map taking an element of the free-state algebra to\n  the part of it in the creation and annihilation free algebra\n  spanned by annihilation operators. -/\ndef anPartF : \ud835\udcd5.FieldOp \u2192 \ud835\udcd5.FieldOpFreeAlgebra := fun \u03c6 =>\n  match \u03c6 with\n  | FieldOp.inAsymp _ => 0\n  | FieldOp.position \u03c6 => ofCrAnOpF \u27e8FieldOp.position \u03c6, CreateAnnihilate.annihilate\u27e9\n  | FieldOp.outAsymp \u03c6 => ofCrAnOpF \u27e8FieldOp.outAsymp \u03c6, ()\u27e9\n\n@[simp]\nlemma anPartF_negAsymp (\u03c6 : (\u03a3 f, \ud835\udcd5.AsymptoticLabel f) \u00d7 (Fin 3 \u2192 \u211d)) :\n    anPartF (FieldOp.inAsymp \u03c6) = 0 := by\n  simp [anPartF]\n\n@[simp]\nlemma anPartF_position (\u03c6 : (\u03a3 f, \ud835\udcd5.PositionLabel f) \u00d7 SpaceTime) :\n    anPartF (FieldOp.position \u03c6) =\n    ofCrAnOpF \u27e8FieldOp.position \u03c6, CreateAnnihilate.annihilate\u27e9 := by\n  simp [anPartF]\n\n@[simp]\nlemma anPartF_posAsymp (\u03c6 : (\u03a3 f, \ud835\udcd5.AsymptoticLabel f) \u00d7 (Fin 3 \u2192 \u211d)) :\n    anPartF (FieldOp.outAsymp \u03c6) = ofCrAnOpF \u27e8FieldOp.outAsymp \u03c6, ()\u27e9 := by\n  simp [anPartF]\n\n", "theoremStatement": "lemma ofFieldOpF_eq_crPartF_add_anPartF (\u03c6 : \ud835\udcd5.FieldOp) :\n    ofFieldOpF \u03c6 = crPartF \u03c6 + anPartF \u03c6 ", "theoremName": "FieldSpecification.FieldOpFreeAlgebra.ofFieldOpF_eq_crPartF_add_anPartF", "fileCreated": {"commit": "ea6e12829370d9630a7e65200c8349e9086c05ba", "date": "2025-02-03"}, "theoremCreated": {"commit": "93d06895c6832b943e9beae9b4d693e3d989abc8", "date": "2025-02-03"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpFreeAlgebra/Basic.lean", "module": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.Basic", "jsonFile": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.Basic.jsonl", "positionMetadata": {"lineInFile": 200, "tokenPositionInFile": 7966, "theoremPositionInFile": 23}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 11, "repositoryPremises": true, "numRepositoryPremises": 27, "numPremises": 83}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [ofFieldOpF]\n  cases \u03c6 with\n  | inAsymp \u03c6 => simp [fieldOpToCrAnType]\n  | position \u03c6 => simp [fieldOpToCrAnType, CreateAnnihilate.sum_eq]\n  | outAsymp \u03c6 => simp [fieldOpToCrAnType]", "proofType": "tactic", "proofLengthLines": 5, "proofLengthTokens": 191}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.WickContraction.SubContraction\n/-!\n\n# Singleton of contractions\n\n-/\n\nopen FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\nnamespace WickContraction\nvariable {n : \u2115} (c : WickContraction n)\nopen HepLean.List\nopen FieldOpAlgebra\nopen FieldStatistic\n\n/-- The Wick contraction formed from a single ordered pair. -/\ndef singleton {i j : Fin n} (hij : i < j) : WickContraction n :=\n  \u27e8{{i, j}}, by\n    intro i hi\n    simp only [Finset.mem_singleton] at hi\n    subst hi\n    rw [@Finset.card_eq_two]\n    use i, j\n    simp only [ne_eq, and_true]\n    omega, by\n    intro i hi j hj\n    simp_all\u27e9\n\nlemma mem_singleton {i j : Fin n} (hij : i < j) :\n    {i, j} \u2208 (singleton hij).1 := by\n  simp [singleton]\n\nlemma mem_singleton_iff {i j : Fin n} (hij : i < j) {a : Finset (Fin n)} :\n    a \u2208 (singleton hij).1 \u2194 a = {i, j} := by\n  simp [singleton]\n\nlemma of_singleton_eq {i j : Fin n} (hij : i < j) (a : (singleton hij).1) :\n    a = \u27e8{i, j}, mem_singleton hij\u27e9 := by\n  have ha2 := a.2\n  rw [@mem_singleton_iff] at ha2\n  exact Subtype.coe_eq_of_eq_mk ha2\n\nlemma singleton_prod {\u03c6s : List \ud835\udcd5.FieldOp} {i j : Fin \u03c6s.length} (hij : i < j)\n    (f : (singleton hij).1 \u2192 M) [CommMonoid M] :\n    \u220f a, f a = f \u27e8{i,j}, mem_singleton hij\u27e9:= by\n  simp [singleton, of_singleton_eq]\n\n@[simp]\nlemma singleton_fstFieldOfContract {i j : Fin n} (hij : i < j) :\n    (singleton hij).fstFieldOfContract \u27e8{i, j}, mem_singleton hij\u27e9 = i := by\n  refine eq_fstFieldOfContract_of_mem (singleton hij) \u27e8{i, j}, mem_singleton hij\u27e9 i j ?_ ?_ ?_\n  \u00b7 simp\n  \u00b7 simp\n  \u00b7 exact hij\n\n", "theoremStatement": "@[simp]\nlemma singleton_sndFieldOfContract {i j : Fin n} (hij : i < j) :\n    (singleton hij).sndFieldOfContract \u27e8{i, j}, mem_singleton hij\u27e9 = j ", "theoremName": "WickContraction.singleton_sndFieldOfContract", "fileCreated": {"commit": "12d36dc1d9c726c035301091e57be0b29015e4ae", "date": "2025-01-31"}, "theoremCreated": {"commit": "12d36dc1d9c726c035301091e57be0b29015e4ae", "date": "2025-01-31"}, "file": "HepLean/HepLean/PerturbationTheory/WickContraction/Singleton.lean", "module": "HepLean.PerturbationTheory.WickContraction.Singleton", "jsonFile": "HepLean.PerturbationTheory.WickContraction.Singleton.jsonl", "positionMetadata": {"lineInFile": 62, "tokenPositionInFile": 1733, "theoremPositionInFile": 6}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 4, "numPremises": 39}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  refine eq_sndFieldOfContract_of_mem (singleton hij) \u27e8{i, j}, mem_singleton hij\u27e9 i j ?_ ?_ ?_\n  \u00b7 simp\n  \u00b7 simp\n  \u00b7 exact hij", "proofType": "tactic", "proofLengthLines": 4, "proofLengthTokens": 132}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.WickContraction.TimeContract\nimport HepLean.PerturbationTheory.WickContraction.StaticContract\nimport HepLean.PerturbationTheory.FieldOpAlgebra.TimeContraction\nimport HepLean.PerturbationTheory.WickContraction.SubContraction\nimport HepLean.PerturbationTheory.WickContraction.Singleton\n\n/-!\n\n# Join of contractions\n\n-/\n\nopen FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\nnamespace WickContraction\nvariable {n : \u2115} (c : WickContraction n)\nopen HepLean.List\nopen FieldOpAlgebra\n\n/-- Given a list `\u03c6s` of `\ud835\udcd5.FieldOp`, a Wick contraction `\u03c6s\u039b` of `\u03c6s` and a Wick contraction\n  `\u03c6suc\u039b` of `[\u03c6s\u039b]\u1d58\u1d9c`, `join \u03c6s\u039b \u03c6suc\u039b` is defined as the Wick contraction of `\u03c6s` consisting of\n  the contractions in `\u03c6s\u039b` and those in `\u03c6suc\u039b`.\n\n  As an example, for `\u03c6s = [\u03c61, \u03c62, \u03c63, \u03c64]`,\n  `\u03c6s\u039b = {{0, 1}}` corresponding to the contraction of `\u03c61` and `\u03c62` in `\u03c6s` and\n  `\u03c6suc\u039b = {{0, 1}}`\n  corresponding to the contraction of `\u03c63` and `\u03c64` in `[\u03c6s\u039b]\u1d58\u1d9c = [\u03c63, \u03c64]`, then\n  `join \u03c6s\u039b \u03c6suc\u039b` is the contraction `{{0, 1}, {2, 3}}` of `\u03c6s`. -/\ndef join {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) : WickContraction \u03c6s.length :=\n  \u27e8\u03c6s\u039b.1 \u222a \u03c6suc\u039b.1.map (Finset.mapEmbedding uncontractedListEmd).toEmbedding, by\n    intro a ha\n    simp only [Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,\n      RelEmbedding.coe_toEmbedding] at ha\n    rcases ha with ha | ha\n    \u00b7 exact \u03c6s\u039b.2.1 a ha\n    \u00b7 obtain \u27e8a, ha, rfl\u27e9 := ha\n      rw [Finset.mapEmbedding_apply]\n      simp only [Finset.card_map]\n      exact \u03c6suc\u039b.2.1 a ha, by\n    intro a ha b hb\n    simp only [Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,\n      RelEmbedding.coe_toEmbedding] at ha hb\n    rcases ha with ha | ha <;> rcases hb with hb | hb\n    \u00b7 exact \u03c6s\u039b.2.2 a ha b hb\n    \u00b7 obtain \u27e8b, hb, rfl\u27e9 := hb\n      right\n      symm\n      rw [Finset.mapEmbedding_apply]\n      apply uncontractedListEmd_finset_disjoint_left\n      exact ha\n    \u00b7 obtain \u27e8a, ha, rfl\u27e9 := ha\n      right\n      rw [Finset.mapEmbedding_apply]\n      apply uncontractedListEmd_finset_disjoint_left\n      exact hb\n    \u00b7 obtain \u27e8a, ha, rfl\u27e9 := ha\n      obtain \u27e8b, hb, rfl\u27e9 := hb\n      simp only [EmbeddingLike.apply_eq_iff_eq]\n      rw [Finset.mapEmbedding_apply, Finset.mapEmbedding_apply]\n      rw [Finset.disjoint_map]\n      exact \u03c6suc\u039b.2.2 a ha b hb\u27e9\n\nlemma join_congr {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} {\u03c6s\u039b' : WickContraction \u03c6s.length}\n    (h1 : \u03c6s\u039b = \u03c6s\u039b') :\n    join \u03c6s\u039b \u03c6suc\u039b = join \u03c6s\u039b' (congr (by simp [h1]) \u03c6suc\u039b) := by\n  subst h1\n  rfl\n\n/-- Given a contracting pair within `\u03c6s\u039b` the corresponding contracting pair within\n  `(join \u03c6s\u039b \u03c6suc\u039b)`. -/\ndef joinLiftLeft {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} : \u03c6s\u039b.1 \u2192 (join \u03c6s\u039b \u03c6suc\u039b).1 :=\n  fun a => \u27e8a, by simp [join]\u27e9\n\nlemma jointLiftLeft_injective {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} :\n    Function.Injective (@joinLiftLeft _ _ \u03c6s\u039b \u03c6suc\u039b) := by\n  intro a b h\n  simp only [joinLiftLeft] at h\n  rw [Subtype.mk_eq_mk] at h\n  refine Subtype.eq h\n\n/-- Given a contracting pair within `\u03c6suc\u039b` the corresponding contracting pair within\n  `(join \u03c6s\u039b \u03c6suc\u039b)`. -/\ndef joinLiftRight {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} : \u03c6suc\u039b.1 \u2192 (join \u03c6s\u039b \u03c6suc\u039b).1 :=\n  fun a => \u27e8a.1.map uncontractedListEmd, by\n    simp only [join, Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,\n      RelEmbedding.coe_toEmbedding]\n    right\n    use a.1\n    simp only [Finset.coe_mem, true_and]\n    rfl\u27e9\n\nlemma joinLiftRight_injective {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} :\n    Function.Injective (@joinLiftRight _ _ \u03c6s\u039b \u03c6suc\u039b) := by\n  intro a b h\n  simp only [joinLiftRight] at h\n  rw [Subtype.mk_eq_mk] at h\n  simp only [Finset.map_inj] at h\n  refine Subtype.eq h\n\nlemma jointLiftLeft_disjoint_joinLiftRight {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} (a : \u03c6s\u039b.1) (b : \u03c6suc\u039b.1) :\n    Disjoint (@joinLiftLeft _ _ _ \u03c6suc\u039b a).1 (joinLiftRight b).1 := by\n  simp only [joinLiftLeft, joinLiftRight]\n  symm\n  apply uncontractedListEmd_finset_disjoint_left\n  exact a.2\n\nlemma jointLiftLeft_neq_joinLiftRight {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} (a : \u03c6s\u039b.1) (b : \u03c6suc\u039b.1) :\n    joinLiftLeft a \u2260 joinLiftRight b := by\n  by_contra hn\n  have h1 := jointLiftLeft_disjoint_joinLiftRight a b\n  rw [hn] at h1\n  simp only [disjoint_self, Finset.bot_eq_empty] at h1\n  have hj := (join \u03c6s\u039b \u03c6suc\u039b).2.1 (joinLiftRight b).1 (joinLiftRight b).2\n  rw [h1] at hj\n  simp at hj\n\n/-- The map from contracted pairs of `\u03c6s\u039b` and `\u03c6suc\u039b` to contracted pairs in\n  `(join \u03c6s\u039b \u03c6suc\u039b)`. -/\ndef joinLift {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} : \u03c6s\u039b.1 \u2295 \u03c6suc\u039b.1 \u2192 (join \u03c6s\u039b \u03c6suc\u039b).1 := fun a =>\n  match a with\n  | Sum.inl a => joinLiftLeft a\n  | Sum.inr a => joinLiftRight a\n\nlemma joinLift_injective {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} : Function.Injective (@joinLift _ _ \u03c6s\u039b \u03c6suc\u039b) := by\n  intro a b h\n  match a, b with\n  | Sum.inl a, Sum.inl b =>\n    simp only [Sum.inl.injEq]\n    exact jointLiftLeft_injective h\n  | Sum.inr a, Sum.inr b =>\n    simp only [Sum.inr.injEq]\n    exact joinLiftRight_injective h\n  | Sum.inl a, Sum.inr b =>\n    simp only [joinLift] at h\n    have h1 := jointLiftLeft_neq_joinLiftRight a b\n    simp_all\n  | Sum.inr a, Sum.inl b =>\n    simp only [joinLift] at h\n    have h1 := jointLiftLeft_neq_joinLiftRight b a\n    simp_all\n\nlemma joinLift_surjective {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} : Function.Surjective (@joinLift _ _ \u03c6s\u039b \u03c6suc\u039b) := by\n  intro a\n  have ha2 := a.2\n  simp only [join, Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,\n    RelEmbedding.coe_toEmbedding] at ha2\n  rcases ha2 with ha2 | \u27e8a2, ha3\u27e9\n  \u00b7 use Sum.inl \u27e8a, ha2\u27e9\n    simp [joinLift, joinLiftLeft]\n  \u00b7 rw [Finset.mapEmbedding_apply] at ha3\n    use Sum.inr \u27e8a2, ha3.1\u27e9\n    simp only [joinLift, joinLiftRight]\n    refine Subtype.eq ?_\n    exact ha3.2\n\nlemma joinLift_bijective {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} : Function.Bijective (@joinLift _ _ \u03c6s\u039b \u03c6suc\u039b) := by\n  apply And.intro\n  \u00b7 exact joinLift_injective\n  \u00b7 exact joinLift_surjective\n\nlemma prod_join {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) (f : (join \u03c6s\u039b \u03c6suc\u039b).1 \u2192 M) [CommMonoid M]:\n      \u220f (a : (join \u03c6s\u039b \u03c6suc\u039b).1), f a = (\u220f (a : \u03c6s\u039b.1), f (joinLiftLeft a)) *\n      \u220f (a : \u03c6suc\u039b.1), f (joinLiftRight a) := by\n  let e1 := Equiv.ofBijective (@joinLift _ _ \u03c6s\u039b \u03c6suc\u039b) joinLift_bijective\n  rw [\u2190 e1.prod_comp]\n  simp only [Fintype.prod_sum_type, Finset.univ_eq_attach]\n  rfl\n\nlemma joinLiftLeft_or_joinLiftRight_of_mem_join {\u03c6s : List \ud835\udcd5.FieldOp}\n    (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) {a : Finset (Fin \u03c6s.length)}\n    (ha : a \u2208 (join \u03c6s\u039b \u03c6suc\u039b).1) :\n    (\u2203 b, a = (joinLiftLeft (\u03c6suc\u039b := \u03c6suc\u039b) b).1) \u2228\n    (\u2203 b, a = (joinLiftRight (\u03c6suc\u039b := \u03c6suc\u039b) b).1) := by\n  simp only [join, Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,\n    RelEmbedding.coe_toEmbedding] at ha\n  rcases ha with ha | \u27e8a, ha, rfl\u27e9\n  \u00b7 left\n    use \u27e8a, ha\u27e9\n    rfl\n  \u00b7 right\n    use \u27e8a, ha\u27e9\n    rfl\n\n@[simp]\nlemma join_fstFieldOfContract_joinLiftRight {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) (a : \u03c6suc\u039b.1) :\n    (join \u03c6s\u039b \u03c6suc\u039b).fstFieldOfContract (joinLiftRight a) =\n    uncontractedListEmd (\u03c6suc\u039b.fstFieldOfContract a) := by\n  apply eq_fstFieldOfContract_of_mem _ _ _ (uncontractedListEmd (\u03c6suc\u039b.sndFieldOfContract a))\n  \u00b7 simp [joinLiftRight]\n  \u00b7 simp [joinLiftRight]\n  \u00b7 apply uncontractedListEmd_strictMono\n    exact fstFieldOfContract_lt_sndFieldOfContract \u03c6suc\u039b a\n\n@[simp]\nlemma join_sndFieldOfContract_joinLiftRight {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) (a : \u03c6suc\u039b.1) :\n    (join \u03c6s\u039b \u03c6suc\u039b).sndFieldOfContract (joinLiftRight a) =\n    uncontractedListEmd (\u03c6suc\u039b.sndFieldOfContract a) := by\n  apply eq_sndFieldOfContract_of_mem _ _ (uncontractedListEmd (\u03c6suc\u039b.fstFieldOfContract a))\n  \u00b7 simp [joinLiftRight]\n  \u00b7 simp [joinLiftRight]\n  \u00b7 apply uncontractedListEmd_strictMono\n    exact fstFieldOfContract_lt_sndFieldOfContract \u03c6suc\u039b a\n\n@[simp]\nlemma join_fstFieldOfContract_joinLiftLeft {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) (a : \u03c6s\u039b.1) :\n    (join \u03c6s\u039b \u03c6suc\u039b).fstFieldOfContract (joinLiftLeft a) =\n    (\u03c6s\u039b.fstFieldOfContract a) := by\n  apply eq_fstFieldOfContract_of_mem _ _ _ (\u03c6s\u039b.sndFieldOfContract a)\n  \u00b7 simp [joinLiftLeft]\n  \u00b7 simp [joinLiftLeft]\n  \u00b7 exact fstFieldOfContract_lt_sndFieldOfContract \u03c6s\u039b a\n\n@[simp]\nlemma join_sndFieldOfContract_joinLift {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) (a : \u03c6s\u039b.1) :\n    (join \u03c6s\u039b \u03c6suc\u039b).sndFieldOfContract (joinLiftLeft a) =\n    (\u03c6s\u039b.sndFieldOfContract a) := by\n  apply eq_sndFieldOfContract_of_mem _ _ (\u03c6s\u039b.fstFieldOfContract a) (\u03c6s\u039b.sndFieldOfContract a)\n  \u00b7 simp [joinLiftLeft]\n  \u00b7 simp [joinLiftLeft]\n  \u00b7 exact fstFieldOfContract_lt_sndFieldOfContract \u03c6s\u039b a\n\nlemma mem_join_right_iff {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) (a : Finset (Fin [\u03c6s\u039b]\u1d58\u1d9c.length)) :\n    a \u2208 \u03c6suc\u039b.1 \u2194 a.map uncontractedListEmd \u2208 (join \u03c6s\u039b \u03c6suc\u039b).1 := by\n  simp only [join, Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,\n    RelEmbedding.coe_toEmbedding]\n  have h1' : \u00ac Finset.map uncontractedListEmd a \u2208 \u03c6s\u039b.1 :=\n    uncontractedListEmd_finset_not_mem a\n  simp only [h1', false_or]\n  apply Iff.intro\n  \u00b7 intro h\n    use a\n    simp only [h, true_and]\n    rw [Finset.mapEmbedding_apply]\n  \u00b7 intro h\n    obtain \u27e8a, ha, h2\u27e9 := h\n    rw [Finset.mapEmbedding_apply] at h2\n    simp only [Finset.map_inj] at h2\n    subst h2\n    exact ha\n\nlemma join_card {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} :\n    (join \u03c6s\u039b \u03c6suc\u039b).1.card = \u03c6s\u039b.1.card + \u03c6suc\u039b.1.card := by\n  simp only [join, Finset.le_eq_subset]\n  rw [Finset.card_union_of_disjoint]\n  simp only [Finset.card_map]\n  rw [@Finset.disjoint_left]\n  intro a ha\n  simp only [Finset.mem_map, RelEmbedding.coe_toEmbedding, not_exists, not_and]\n  intro x hx\n  by_contra hn\n  have hdis : Disjoint (Finset.map uncontractedListEmd x) a := by\n    exact uncontractedListEmd_finset_disjoint_left x a ha\n  rw [Finset.mapEmbedding_apply] at hn\n  rw [hn] at hdis\n  simp only [disjoint_self, Finset.bot_eq_empty] at hdis\n  have hcard := \u03c6s\u039b.2.1 a ha\n  simp_all\n\n@[simp]\nlemma empty_join {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction [empty (n := \u03c6s.length)]\u1d58\u1d9c.length) :\n    join empty \u03c6s\u039b = congr (by simp) \u03c6s\u039b := by\n  apply Subtype.ext\n  simp only [join, Finset.le_eq_subset, uncontractedListEmd_empty]\n  ext a\n  conv_lhs =>\n    left\n    left\n    rw [empty]\n  simp only [Finset.empty_union, Finset.mem_map, RelEmbedding.coe_toEmbedding]\n  rw [mem_congr_iff]\n  apply Iff.intro\n  \u00b7 intro h\n    obtain \u27e8a, ha, rfl\u27e9 := h\n    rw [Finset.mapEmbedding_apply]\n    rw [Finset.map_map]\n    apply Set.mem_of_eq_of_mem _ ha\n    trans Finset.map (Equiv.refl _).toEmbedding a\n    rfl\n    simp\n  \u00b7 intro h\n    use Finset.map (finCongr (by simp)).toEmbedding a\n    simp only [h, true_and]\n    trans Finset.map (Equiv.refl _).toEmbedding a\n    rw [Finset.mapEmbedding_apply, Finset.map_map]\n    rfl\n    simp\n\n@[simp]\nlemma join_empty {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length) :\n    join \u03c6s\u039b empty = \u03c6s\u039b := by\n  apply Subtype.ext\n  ext a\n  simp [join, empty]\n\nlemma join_timeContract {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) :\n    (join \u03c6s\u039b \u03c6suc\u039b).timeContract = \u03c6s\u039b.timeContract * \u03c6suc\u039b.timeContract := by\n  simp only [timeContract, List.get_eq_getElem]\n  rw [prod_join]\n  congr 1\n  congr\n  funext a\n  simp\n\nlemma join_staticContract {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) :\n    (join \u03c6s\u039b \u03c6suc\u039b).staticContract = \u03c6s\u039b.staticContract * \u03c6suc\u039b.staticContract := by\n  simp only [staticContract, List.get_eq_getElem]\n  rw [prod_join]\n  congr 1\n  congr\n  funext a\n  simp\n\nlemma mem_join_uncontracted_of_mem_right_uncontracted {\u03c6s : List \ud835\udcd5.FieldOp}\n    (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) (i : Fin [\u03c6s\u039b]\u1d58\u1d9c.length)\n    (ha : i \u2208 \u03c6suc\u039b.uncontracted) :\n    uncontractedListEmd i \u2208 (join \u03c6s\u039b \u03c6suc\u039b).uncontracted := by\n  rw [mem_uncontracted_iff_not_contracted]\n  intro p hp\n  simp only [join, Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,\n    RelEmbedding.coe_toEmbedding] at hp\n  rcases hp with hp | hp\n  \u00b7 have hi : uncontractedListEmd i \u2208 \u03c6s\u039b.uncontracted := by\n      exact uncontractedListEmd_mem_uncontracted i\n    rw [mem_uncontracted_iff_not_contracted] at hi\n    exact hi p hp\n  \u00b7 obtain \u27e8p, hp, rfl\u27e9 := hp\n    rw [Finset.mapEmbedding_apply]\n    simp only [Finset.mem_map']\n    rw [mem_uncontracted_iff_not_contracted] at ha\n    exact ha p hp\n\nlemma exists_mem_left_uncontracted_of_mem_join_uncontracted {\u03c6s : List \ud835\udcd5.FieldOp}\n    (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) (i : Fin \u03c6s.length)\n    (ha : i \u2208 (join \u03c6s\u039b \u03c6suc\u039b).uncontracted) :\n    i \u2208 \u03c6s\u039b.uncontracted := by\n  rw [@mem_uncontracted_iff_not_contracted]\n  rw [@mem_uncontracted_iff_not_contracted] at ha\n  simp only [join, Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,\n    RelEmbedding.coe_toEmbedding] at ha\n  intro p hp\n  simp_all\n\nlemma exists_mem_right_uncontracted_of_mem_join_uncontracted {\u03c6s : List \ud835\udcd5.FieldOp}\n    (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) (i : Fin \u03c6s.length)\n    (hi : i \u2208 (join \u03c6s\u039b \u03c6suc\u039b).uncontracted) :\n    \u2203 a, uncontractedListEmd a = i \u2227 a \u2208 \u03c6suc\u039b.uncontracted := by\n  have hi' := exists_mem_left_uncontracted_of_mem_join_uncontracted _ _ i hi\n  obtain \u27e8j, rfl\u27e9 := uncontractedListEmd_surjective_mem_uncontracted i hi'\n  use j\n  simp only [true_and]\n  rw [mem_uncontracted_iff_not_contracted] at hi\n  rw [mem_uncontracted_iff_not_contracted]\n  intro p hp\n  have hip := hi (p.map uncontractedListEmd) (by\n    simp only [join, Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,\n      RelEmbedding.coe_toEmbedding]\n    right\n    use p\n    simp only [hp, true_and]\n    rw [Finset.mapEmbedding_apply])\n  simpa using hip\n\nlemma join_uncontractedList {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) :\n    (join \u03c6s\u039b \u03c6suc\u039b).uncontractedList = List.map uncontractedListEmd \u03c6suc\u039b.uncontractedList := by\n  rw [uncontractedList_eq_sort]\n  rw [uncontractedList_eq_sort]\n  rw [fin_finset_sort_map_monotone]\n  congr\n  ext a\n  simp only [Finset.mem_map]\n  apply Iff.intro\n  \u00b7 intro h\n    obtain \u27e8a, rfl, ha\u27e9 := exists_mem_right_uncontracted_of_mem_join_uncontracted _ _ a h\n    use a, ha\n  \u00b7 intro h\n    obtain \u27e8a, ha, rfl\u27e9 := h\n    exact mem_join_uncontracted_of_mem_right_uncontracted \u03c6s\u039b \u03c6suc\u039b a ha\n  \u00b7 intro a b h\n    exact uncontractedListEmd_strictMono h\n\nlemma join_uncontractedList_get {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) :\n    ((join \u03c6s\u039b \u03c6suc\u039b).uncontractedList).get =\n    \u03c6s\u039b.uncontractedListEmd \u2218 (\u03c6suc\u039b.uncontractedList).get \u2218\n        (Fin.cast (by rw [join_uncontractedList]; simp)) := by\n  have h1 {n : \u2115} (l1 l2 : List (Fin n)) (h : l1 = l2) :\n      l1.get = l2.get \u2218 Fin.cast (by rw [h]) := by\n    subst h\n    rfl\n  conv_lhs => rw [h1 _ _ (join_uncontractedList \u03c6s\u039b \u03c6suc\u039b)]\n  ext i\n  simp\n\nlemma join_uncontractedListGet {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) :\n    (join \u03c6s\u039b \u03c6suc\u039b).uncontractedListGet = \u03c6suc\u039b.uncontractedListGet := by\n  simp only [uncontractedListGet, join_uncontractedList, List.map_map, List.map_inj_left,\n    Function.comp_apply, List.get_eq_getElem, List.getElem_map]\n  intro a ha\n  simp only [uncontractedListEmd, uncontractedIndexEquiv, List.get_eq_getElem,\n    Equiv.trans_toEmbedding, Function.Embedding.trans_apply, Equiv.coe_toEmbedding, Equiv.coe_fn_mk,\n    Function.Embedding.coe_subtype]\n  rfl\n\nlemma join_uncontractedListEmb {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) :\n    (join \u03c6s\u039b \u03c6suc\u039b).uncontractedListEmd =\n    ((finCongr (congrArg List.length (join_uncontractedListGet _ _))).toEmbedding.trans\n      \u03c6suc\u039b.uncontractedListEmd).trans \u03c6s\u039b.uncontractedListEmd := by\n  refine Function.Embedding.ext_iff.mpr (congrFun ?_)\n  change uncontractedListEmd.toFun = _\n  rw [uncontractedListEmd_toFun_eq_get]\n  rw [join_uncontractedList_get]\n  rfl\n\nlemma join_assoc {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) (\u03c6suc\u039b' : WickContraction [\u03c6s\u039b.join \u03c6suc\u039b]\u1d58\u1d9c.length) :\n    join (join \u03c6s\u039b \u03c6suc\u039b) (\u03c6suc\u039b') = join \u03c6s\u039b (join \u03c6suc\u039b (congr\n      (congrArg List.length (join_uncontractedListGet _ _)) \u03c6suc\u039b')) := by\n  apply Subtype.ext\n  ext a\n  by_cases ha : a \u2208 \u03c6s\u039b.1\n  \u00b7 simp [ha, join]\n  simp only [join, Finset.le_eq_subset, Finset.union_assoc, Finset.mem_union, ha, Finset.mem_map,\n    RelEmbedding.coe_toEmbedding, false_or]\n  apply Iff.intro\n  \u00b7 intro h\n    rcases h with h | h\n    \u00b7 obtain \u27e8a, ha', rfl\u27e9 := h\n      use a\n      simp [ha']\n    \u00b7 obtain \u27e8a, ha', rfl\u27e9 := h\n      let a' := congrLift (congrArg List.length (join_uncontractedListGet _ _)) \u27e8a, ha'\u27e9\n      let a'' := joinLiftRight a'\n      use a''\n      apply And.intro\n      \u00b7 right\n        use a'\n        apply And.intro\n        \u00b7 exact a'.2\n        \u00b7 simp only [joinLiftRight, a'']\n          rfl\n      \u00b7 simp only [a'']\n        rw [Finset.mapEmbedding_apply, Finset.mapEmbedding_apply]\n        simp only [a', joinLiftRight, congrLift]\n        rw [join_uncontractedListEmb]\n        simp [Finset.map_map]\n  \u00b7 intro h\n    obtain \u27e8a, ha', rfl\u27e9 := h\n    rcases ha' with ha' | ha'\n    \u00b7 left\n      use a\n    \u00b7 obtain \u27e8a, ha', rfl\u27e9 := ha'\n      right\n      let a' := congrLiftInv _ \u27e8a, ha'\u27e9\n      use a'\n      simp only [Finset.coe_mem, true_and]\n      simp only [a']\n      rw [Finset.mapEmbedding_apply]\n      rw [join_uncontractedListEmb]\n      simp only [congrLiftInv, \u2190 Finset.map_map]\n      congr\n      rw [Finset.map_map]\n      change Finset.map (Equiv.refl _).toEmbedding a = _\n      simp only [Equiv.refl_toEmbedding, Finset.map_refl]\n\nlemma join_getDual?_apply_uncontractedListEmb_eq_none_iff {\u03c6s : List \ud835\udcd5.FieldOp}\n    (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) (i : Fin [\u03c6s\u039b]\u1d58\u1d9c.length) :\n    (join \u03c6s\u039b \u03c6suc\u039b).getDual? (uncontractedListEmd i) = none\n    \u2194 \u03c6suc\u039b.getDual? i = none := by\n  rw [getDual?_eq_none_iff_mem_uncontracted, getDual?_eq_none_iff_mem_uncontracted]\n  apply Iff.intro\n  \u00b7 intro h\n    obtain \u27e8a, ha', ha\u27e9 := exists_mem_right_uncontracted_of_mem_join_uncontracted _ _\n      (uncontractedListEmd i) h\n    simp only [EmbeddingLike.apply_eq_iff_eq] at ha'\n    subst ha'\n    exact ha\n  \u00b7 intro h\n    exact mem_join_uncontracted_of_mem_right_uncontracted \u03c6s\u039b \u03c6suc\u039b i h\n\nlemma join_getDual?_apply_uncontractedListEmb_isSome_iff {\u03c6s : List \ud835\udcd5.FieldOp}\n    (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) (i : Fin [\u03c6s\u039b]\u1d58\u1d9c.length) :\n    ((join \u03c6s\u039b \u03c6suc\u039b).getDual? (uncontractedListEmd i)).isSome\n    \u2194 (\u03c6suc\u039b.getDual? i).isSome := by\n  rw [\u2190 Decidable.not_iff_not]\n  simp [join_getDual?_apply_uncontractedListEmb_eq_none_iff]\n\nlemma join_getDual?_apply_uncontractedListEmb_some {\u03c6s : List \ud835\udcd5.FieldOp}\n    (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) (i : Fin [\u03c6s\u039b]\u1d58\u1d9c.length)\n    (hi :((join \u03c6s\u039b \u03c6suc\u039b).getDual? (uncontractedListEmd i)).isSome) :\n    ((join \u03c6s\u039b \u03c6suc\u039b).getDual? (uncontractedListEmd i)) =\n    some (uncontractedListEmd ((\u03c6suc\u039b.getDual? i).get (by\n    simpa [join_getDual?_apply_uncontractedListEmb_isSome_iff]using hi))) := by\n  rw [getDual?_eq_some_iff_mem]\n  simp only [join, Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,\n    RelEmbedding.coe_toEmbedding]\n  right\n  use {i, (\u03c6suc\u039b.getDual? i).get (by\n    simpa [join_getDual?_apply_uncontractedListEmb_isSome_iff] using hi)}\n  simp only [self_getDual?_get_mem, true_and]\n  rw [Finset.mapEmbedding_apply]\n  simp\n\n@[simp]\nlemma join_getDual?_apply_uncontractedListEmb {\u03c6s : List \ud835\udcd5.FieldOp}\n    (\u03c6s\u039b : WickContraction \u03c6s.length) (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length)\n    (i : Fin [\u03c6s\u039b]\u1d58\u1d9c.length) : ((join \u03c6s\u039b \u03c6suc\u039b).getDual? (uncontractedListEmd i)) =\n    Option.map uncontractedListEmd (\u03c6suc\u039b.getDual? i) := by\n  by_cases h : (\u03c6suc\u039b.getDual? i).isSome\n  \u00b7 rw [join_getDual?_apply_uncontractedListEmb_some]\n    have h1 : (\u03c6suc\u039b.getDual? i) = (\u03c6suc\u039b.getDual? i).get (by simpa using h) :=\n      Eq.symm (Option.some_get h)\n    conv_rhs => rw [h1]\n    simp only [Option.map_some']\n    exact (join_getDual?_apply_uncontractedListEmb_isSome_iff \u03c6s\u039b \u03c6suc\u039b i).mpr h\n  \u00b7 simp only [Bool.not_eq_true, Option.not_isSome, Option.isNone_iff_eq_none] at h\n    rw [h]\n    simp only [Option.map_none', join_getDual?_apply_uncontractedListEmb_eq_none_iff]\n    exact h\n\n/-!\n\n## Subcontractions and quotient contractions\n\n-/\n\nsection\n\nvariable {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n\nlemma join_sub_quot (S : Finset (Finset (Fin \u03c6s.length))) (ha : S \u2286 \u03c6s\u039b.1) :\n    join (subContraction S ha) (quotContraction S ha) = \u03c6s\u039b := by\n  apply Subtype.ext\n  ext a\n  simp only [join, Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,\n    RelEmbedding.coe_toEmbedding]\n  apply Iff.intro\n  \u00b7 intro h\n    rcases h with h | h\n    \u00b7 exact mem_of_mem_subContraction h\n    \u00b7 obtain \u27e8a, ha, rfl\u27e9 := h\n      apply mem_of_mem_quotContraction ha\n  \u00b7 intro h\n    have h1 := mem_subContraction_or_quotContraction (S := S) (a := a) (hs := ha) h\n    rcases h1 with h1 | h1\n    \u00b7 simp [h1]\n    \u00b7 right\n      obtain \u27e8a, rfl, ha\u27e9 := h1\n      use a\n      simp only [ha, true_and]\n      rw [Finset.mapEmbedding_apply]\n\nlemma subContraction_card_plus_quotContraction_card_eq (S : Finset (Finset (Fin \u03c6s.length)))\n    (ha : S \u2286 \u03c6s\u039b.1) :\n    (subContraction S ha).1.card + (quotContraction S ha).1.card = \u03c6s\u039b.1.card := by\n  rw [\u2190 join_card]\n  simp [join_sub_quot]\n\nend\nopen FieldStatistic\n\n@[simp]\nlemma join_singleton_getDual?_left {\u03c6s : List \ud835\udcd5.FieldOp}\n    {i j : Fin \u03c6s.length} (h : i < j)\n    (\u03c6suc\u039b : WickContraction [singleton h]\u1d58\u1d9c.length) :\n    (join (singleton h) \u03c6suc\u039b).getDual? i = some j := by\n  rw [@getDual?_eq_some_iff_mem]\n  simp [singleton, join]\n\n@[simp]\nlemma join_singleton_getDual?_right {\u03c6s : List \ud835\udcd5.FieldOp}\n    {i j : Fin \u03c6s.length} (h : i < j)\n    (\u03c6suc\u039b : WickContraction [singleton h]\u1d58\u1d9c.length) :\n    (join (singleton h) \u03c6suc\u039b).getDual? j = some i := by\n  rw [@getDual?_eq_some_iff_mem]\n  simp only [join, singleton, Finset.le_eq_subset, Finset.mem_union, Finset.mem_singleton,\n    Finset.mem_map, RelEmbedding.coe_toEmbedding]\n  left\n  exact Finset.pair_comm j i\n\nlemma exists_contraction_pair_of_card_ge_zero {\u03c6s : List \ud835\udcd5.FieldOp}\n    (\u03c6s\u039b : WickContraction \u03c6s.length) (h : 0 < \u03c6s\u039b.1.card) :\n    \u2203 a, a \u2208 \u03c6s\u039b.1 := by\n  simpa using h\n\nlemma exists_join_singleton_of_card_ge_zero {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (h : 0 < \u03c6s\u039b.1.card) (hc : \u03c6s\u039b.GradingCompliant) :\n    \u2203 (i j : Fin \u03c6s.length) (h : i < j) (\u03c6suc\u039b : WickContraction [singleton h]\u1d58\u1d9c.length),\n    \u03c6s\u039b = join (singleton h) \u03c6suc\u039b \u2227 (\ud835\udcd5 |>\u209b \u03c6s[i]) = (\ud835\udcd5 |>\u209b \u03c6s[j])\n    \u2227 \u03c6suc\u039b.GradingCompliant \u2227 \u03c6suc\u039b.1.card + 1 = \u03c6s\u039b.1.card := by\n  obtain \u27e8a, ha\u27e9 := exists_contraction_pair_of_card_ge_zero \u03c6s\u039b h\n  use \u03c6s\u039b.fstFieldOfContract \u27e8a, ha\u27e9\n  use \u03c6s\u039b.sndFieldOfContract \u27e8a, ha\u27e9\n  use \u03c6s\u039b.fstFieldOfContract_lt_sndFieldOfContract \u27e8a, ha\u27e9\n  let \u03c6suc\u039b :\n    WickContraction [singleton (\u03c6s\u039b.fstFieldOfContract_lt_sndFieldOfContract \u27e8a, ha\u27e9)]\u1d58\u1d9c.length :=\n    congr (by simp [\u2190 subContraction_singleton_eq_singleton])\n    (\u03c6s\u039b.quotContraction {a} (by simpa using ha))\n  use \u03c6suc\u039b\n  simp only [Fin.getElem_fin]\n  apply And.intro\n  \u00b7 have h1 := join_congr (subContraction_singleton_eq_singleton _ \u27e8a, ha\u27e9).symm (\u03c6suc\u039b := \u03c6suc\u039b)\n    simp only [id_eq, eq_mpr_eq_cast, h1, congr_trans_apply, congr_refl, \u03c6suc\u039b]\n    rw [join_sub_quot]\n  \u00b7 apply And.intro (hc \u27e8a, ha\u27e9)\n    apply And.intro\n    \u00b7 simp only [id_eq, eq_mpr_eq_cast, \u03c6suc\u039b]\n      rw [gradingCompliant_congr (\u03c6s' := [(\u03c6s\u039b.subContraction {a} (by simpa using ha))]\u1d58\u1d9c)]\n      simp only [id_eq, eq_mpr_eq_cast, congr_trans_apply, congr_refl]\n      exact quotContraction_gradingCompliant hc\n      rw [\u2190 subContraction_singleton_eq_singleton]\n    \u00b7 simp only [id_eq, eq_mpr_eq_cast, card_congr, \u03c6suc\u039b]\n      have h1 := subContraction_card_plus_quotContraction_card_eq _ {a} (by simpa using ha)\n      simp only [subContraction, Finset.card_singleton, id_eq, eq_mpr_eq_cast] at h1\n      omega\n\n", "theoremStatement": "lemma join_not_gradingCompliant_of_left_not_gradingCompliant {\u03c6s : List \ud835\udcd5.FieldOp}\n    (\u03c6s\u039b : WickContraction \u03c6s.length) (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length)\n    (hc : \u00ac \u03c6s\u039b.GradingCompliant) : \u00ac (join \u03c6s\u039b \u03c6suc\u039b).GradingCompliant ", "theoremName": "WickContraction.join_not_gradingCompliant_of_left_not_gradingCompliant", "fileCreated": {"commit": "12d36dc1d9c726c035301091e57be0b29015e4ae", "date": "2025-01-31"}, "theoremCreated": {"commit": "006e29fd08e20d8c1c3d81de0e3bfcb268782a3d", "date": "2025-02-01"}, "file": "HepLean/HepLean/PerturbationTheory/WickContraction/Join.lean", "module": "HepLean.PerturbationTheory.WickContraction.Join", "jsonFile": "HepLean.PerturbationTheory.WickContraction.Join.jsonl", "positionMetadata": {"lineInFile": 653, "tokenPositionInFile": 25362, "theoremPositionInFile": 42}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 13, "numPremises": 62}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp_all only [GradingCompliant, Fin.getElem_fin, Subtype.forall, not_forall]\n  obtain \u27e8a, ha, ha2\u27e9 := hc\n  use (joinLiftLeft (\u03c6suc\u039b := \u03c6suc\u039b) \u27e8a, ha\u27e9).1\n  use (joinLiftLeft (\u03c6suc\u039b := \u03c6suc\u039b) \u27e8a, ha\u27e9).2\n  simp only [Subtype.coe_eta, join_fstFieldOfContract_joinLiftLeft,\n    join_sndFieldOfContract_joinLift]\n  exact ha2", "proofType": "tactic", "proofLengthLines": 7, "proofLengthTokens": 327}}
{"srcContext": "/-\nCopyright (c) 2024 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport Mathlib.Algebra.FreeAlgebra\nimport Mathlib.Algebra.Lie.OfAssociative\nimport Mathlib.Analysis.Complex.Basic\nimport HepLean.Mathematics.List.InsertIdx\n/-!\n\n# Field statistics\n\nBasic properties related to whether a field, or list of fields, is bosonic or fermionic.\n\n-/\n\n/-- The type `FieldStatistic` is the type containing two elements `bosonic` and `fermionic`.\n  This type is used to specify if a field or operator obeys bosonic or fermionic statistics. -/\ninductive FieldStatistic : Type where\n  | bosonic : FieldStatistic\n  | fermionic : FieldStatistic\nderiving DecidableEq\n\nnamespace FieldStatistic\n\nvariable {\ud835\udcd5 : Type}\n\n/-- The type `FieldStatistic` carries an instance of a commutative group in which\n- `bosonic * bosonic = bosonic`\n- `bosonic * fermionic = fermionic`\n- `fermionic * bosonic = fermionic`\n- `fermionic * fermionic = bosonic`\n\nThis group is isomorphic to `\u2124\u2082`. -/\n@[simp]\ninstance : CommGroup FieldStatistic where\n  one := bosonic\n  mul a b :=\n    match a, b with\n    | bosonic, bosonic => bosonic\n    | bosonic, fermionic => fermionic\n    | fermionic, bosonic => fermionic\n    | fermionic, fermionic => bosonic\n  inv a := a\n  mul_assoc a b c := by\n    cases a <;> cases b <;> cases c <;>\n    dsimp [HMul.hMul]\n  one_mul a := by\n    cases a <;> dsimp [HMul.hMul]\n  mul_one a := by\n    cases a <;> dsimp [HMul.hMul]\n  inv_mul_cancel a := by\n    cases a <;> dsimp only [HMul.hMul, Nat.succ_eq_add_one] <;> rfl\n  mul_comm a b := by\n    cases a <;> cases b <;> rfl\n\n", "theoremStatement": "@[simp]\nlemma bosonic_mul_bosonic : bosonic * bosonic = bosonic ", "theoremName": "FieldStatistic.bosonic_mul_bosonic", "fileCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "theoremCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "file": "HepLean/HepLean/PerturbationTheory/FieldStatistics/Basic.lean", "module": "HepLean.PerturbationTheory.FieldStatistics.Basic", "jsonFile": "HepLean.PerturbationTheory.FieldStatistics.Basic.jsonl", "positionMetadata": {"lineInFile": 58, "tokenPositionInFile": 1651, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 3, "numPremises": 12}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpAlgebra.StaticWickTheorem\nimport HepLean.PerturbationTheory.FieldOpAlgebra.WicksTheorem\nimport HepLean.PerturbationTheory.WickContraction.Sign.Join\nimport HepLean.PerturbationTheory.WickContraction.TimeCond\n/-!\n\n# Wick's theorem for normal ordered lists\n\n-/\n\nnamespace FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\nopen FieldOpFreeAlgebra\nnamespace FieldOpAlgebra\nopen WickContraction\nopen EqTimeOnly\n\n/--\nFor a list `\u03c6s` of `\ud835\udcd5.FieldOp`, then\n\n`\ud835\udce3(\u03c6s) = \u2211 \u03c6s\u039b, \u03c6s\u039b.sign \u2022 \u03c6s\u039b.timeContract * \ud835\udce3(\ud835\udcdd([\u03c6s\u039b]\u1d58\u1d9c))`\n\nwhere the sum is over all Wick contraction `\u03c6s\u039b` which only have equal time contractions.\n\nThis result follows from\n- `static_wick_theorem` to rewrite `\ud835\udce3(\u03c6s)` on the left hand side as a sum of\n  `\ud835\udce3(\u03c6s\u039b.staticWickTerm)`.\n- `EqTimeOnly.timeOrder_staticContract_of_not_mem` and `timeOrder_timeOrder_mid` to set to\n  those `\ud835\udce3(\u03c6s\u039b.staticWickTerm)` for which `\u03c6s\u039b` has a contracted pair which are not\n  equal time to zero.\n- `staticContract_eq_timeContract_of_eqTimeOnly` to rewrite the static contract\n  in the remaining `\ud835\udce3(\u03c6s\u039b.staticWickTerm)` as a time contract.\n- `timeOrder_timeContract_mul_of_eqTimeOnly_left` to move the time contracts out of the time\n  ordering.\n-/\nlemma timeOrder_ofFieldOpList_eqTimeOnly (\u03c6s : List \ud835\udcd5.FieldOp) :\n    \ud835\udce3(ofFieldOpList \u03c6s) = \u2211 (\u03c6s\u039b : {\u03c6s\u039b // \u03c6s\u039b.EqTimeOnly (\u03c6s := \u03c6s)}),\n    \u03c6s\u039b.1.sign \u2022 \u03c6s\u039b.1.timeContract.1 * \ud835\udce3(\ud835\udcdd(ofFieldOpList [\u03c6s\u039b.1]\u1d58\u1d9c)) := by\n  rw [static_wick_theorem \u03c6s]\n  let e2 : WickContraction \u03c6s.length \u2243\n    {\u03c6s\u039b : WickContraction \u03c6s.length // \u03c6s\u039b.EqTimeOnly} \u2295\n    {\u03c6s\u039b : WickContraction \u03c6s.length // \u00ac \u03c6s\u039b.EqTimeOnly} :=\n    (Equiv.sumCompl _).symm\n  rw [\u2190 e2.symm.sum_comp]\n  simp only [Equiv.symm_symm, Algebra.smul_mul_assoc, Fintype.sum_sum_type,\n    Equiv.sumCompl_apply_inl, Equiv.sumCompl_apply_inr, map_add, map_sum, map_smul, e2]\n  simp only [staticWickTerm, Algebra.smul_mul_assoc, map_smul]\n  conv_lhs =>\n    enter [2, 2, x]\n    rw [timeOrder_timeOrder_left]\n    rw [timeOrder_staticContract_of_not_mem _ x.2]\n  simp only [Finset.univ_eq_attach, zero_mul, map_zero, smul_zero, Finset.sum_const_zero, add_zero]\n  congr\n  funext x\n  rw [staticContract_eq_timeContract_of_eqTimeOnly]\n  rw [timeOrder_timeContract_mul_of_eqTimeOnly_left]\n  exact x.2\n  exact x.2\n\nlemma timeOrder_ofFieldOpList_eq_eqTimeOnly_empty (\u03c6s : List \ud835\udcd5.FieldOp) :\n    \ud835\udce3(ofFieldOpList \u03c6s) = \ud835\udce3(\ud835\udcdd(ofFieldOpList \u03c6s)) +\n    \u2211 (\u03c6s\u039b : {\u03c6s\u039b // \u03c6s\u039b.EqTimeOnly (\u03c6s := \u03c6s) \u2227 \u03c6s\u039b \u2260 empty}),\n    \u03c6s\u039b.1.sign \u2022 \u03c6s\u039b.1.timeContract.1 * \ud835\udce3(\ud835\udcdd(ofFieldOpList [\u03c6s\u039b.1]\u1d58\u1d9c)) := by\n  let e1 : {\u03c6s\u039b : WickContraction \u03c6s.length // \u03c6s\u039b.EqTimeOnly} \u2243\n      {\u03c6s\u039b : {\u03c6s\u039b : WickContraction \u03c6s.length // \u03c6s\u039b.EqTimeOnly} // \u03c6s\u039b.1 = empty} \u2295\n      {\u03c6s\u039b : {\u03c6s\u039b : WickContraction \u03c6s.length // \u03c6s\u039b.EqTimeOnly} // \u00ac \u03c6s\u039b.1 = empty} :=\n      (Equiv.sumCompl _).symm\n  rw [timeOrder_ofFieldOpList_eqTimeOnly, \u2190 e1.symm.sum_comp]\n  simp only [Equiv.symm_symm, Algebra.smul_mul_assoc, Fintype.sum_sum_type,\n    Equiv.sumCompl_apply_inl, Equiv.sumCompl_apply_inr, ne_eq, e1]\n  congr 1\n  \u00b7 let e2 : {\u03c6s\u039b : {\u03c6s\u039b : WickContraction \u03c6s.length // \u03c6s\u039b.EqTimeOnly} // \u03c6s\u039b.1 = empty } \u2243\n      Unit := {\n      toFun := fun x => (), invFun := fun x => \u27e8\u27e8empty, by simp\u27e9, rfl\u27e9,\n      left_inv a := by\n        ext\n        simp [a.2], right_inv a := by simp}\n    rw [\u2190 e2.symm.sum_comp]\n    simp [e2, sign_empty]\n  \u00b7 let e2 : { \u03c6s\u039b : {\u03c6s\u039b : WickContraction \u03c6s.length // \u03c6s\u039b.EqTimeOnly} // \u00ac \u03c6s\u039b.1 = empty } \u2243\n      {\u03c6s\u039b // \u03c6s\u039b.EqTimeOnly \u2227 \u03c6s\u039b \u2260 empty} := {\n        toFun := fun x => \u27e8x, \u27e8x.1.2, x.2\u27e9\u27e9, invFun := fun x => \u27e8\u27e8x.1, x.2.1\u27e9, x.2.2\u27e9,\n        left_inv a := by rfl, right_inv a := by rfl }\n    rw [\u2190 e2.symm.sum_comp]\n    rfl\n\n", "theoremStatement": "/--\nFor a list `\u03c6s` of `\ud835\udcd5.FieldOp`, then\n\n`\ud835\udce3(\ud835\udcdd(\u03c6s)) = \ud835\udce3(\u03c6s) - \u2211 \u03c6s\u039b, \u03c6s\u039b.sign \u2022 \u03c6s\u039b.timeContract.1 * \ud835\udce3(\ud835\udcdd([\u03c6s\u039b]\u1d58\u1d9c))`\n\nwhere the sum is over all *non-empty* Wick contraction `\u03c6s\u039b` which only\n  have equal time contractions.\n\nThis result follows directly from\n- `timeOrder_ofFieldOpList_eqTimeOnly`\n-/\nlemma normalOrder_timeOrder_ofFieldOpList_eq_eqTimeOnly_empty (\u03c6s : List \ud835\udcd5.FieldOp) :\n    \ud835\udce3(\ud835\udcdd(ofFieldOpList \u03c6s)) = \ud835\udce3(ofFieldOpList \u03c6s) -\n    \u2211 (\u03c6s\u039b : {\u03c6s\u039b // \u03c6s\u039b.EqTimeOnly (\u03c6s := \u03c6s) \u2227 \u03c6s\u039b \u2260 empty}),\n    \u03c6s\u039b.1.sign \u2022 \u03c6s\u039b.1.timeContract.1 * \ud835\udce3(\ud835\udcdd(ofFieldOpList [\u03c6s\u039b.1]\u1d58\u1d9c)) ", "theoremName": "FieldSpecification.FieldOpAlgebra.normalOrder_timeOrder_ofFieldOpList_eq_eqTimeOnly_empty", "fileCreated": {"commit": "ea6e12829370d9630a7e65200c8349e9086c05ba", "date": "2025-02-03"}, "theoremCreated": {"commit": "d472604aec04e5ee9660eea917674e9a177477d0", "date": "2025-02-07"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpAlgebra/WicksTheoremNormal.lean", "module": "HepLean.PerturbationTheory.FieldOpAlgebra.WicksTheoremNormal", "jsonFile": "HepLean.PerturbationTheory.FieldOpAlgebra.WicksTheoremNormal.jsonl", "positionMetadata": {"lineInFile": 92, "tokenPositionInFile": 3819, "theoremPositionInFile": 2}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 19, "numPremises": 108}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [timeOrder_ofFieldOpList_eq_eqTimeOnly_empty]\n  simp", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 63}}
{"srcContext": "/-\nCopyright (c) 2024 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport Mathlib.LinearAlgebra.PiTensorProduct\nimport Mathlib.Tactic.Polyrith\nimport Mathlib.Tactic.Linarith\n/-!\n# Fin lemmas\n\nThe purpose of this file is to define some results Fin currently\nin Mathlib.\n\nAt some point these should either be up-streamed to Mathlib or replaced with definitions already\nin Mathlib.\n\n-/\nnamespace HepLean.Fin\n\nopen Fin\nvariable {n : Nat}\n\n/-- Given a `i` and `x` in `Fin n.succ.succ` returns an element of `Fin n.succ`\n  subtracting 1 if `i.val \u2264 x.val` else casting x. -/\ndef predAboveI (i x : Fin n.succ.succ) : Fin n.succ :=\n  if h : x.val < i.val then\n    \u27e8x.val, by omega\u27e9\n  else\n    \u27e8x.val - 1, by\n      by_cases hx : x = 0\n      \u00b7 omega\n      \u00b7 omega\u27e9\n\nlemma predAboveI_self (i : Fin n.succ.succ) : predAboveI i i = \u27e8i.val - 1, by omega\u27e9 := by\n  simp [predAboveI]\n\n@[simp]\nlemma predAboveI_succAbove (i : Fin n.succ.succ) (x : Fin n.succ) :\n    predAboveI i (Fin.succAbove i x) = x := by\n  simp only [Nat.succ_eq_add_one, predAboveI, Fin.succAbove, Fin.val_fin_lt, Fin.ext_iff]\n  split_ifs\n  \u00b7 rfl\n  \u00b7 rename_i h1 h2\n    simp only [Fin.lt_def, Fin.coe_castSucc, not_lt, Nat.succ_eq_add_one, Fin.val_succ] at h1 h2\n    omega\n  \u00b7 rfl\nlemma succsAbove_predAboveI {i x : Fin n.succ.succ} (h : i \u2260 x) :\n    Fin.succAbove i (predAboveI i x) = x := by\n  simp only [Fin.succAbove, predAboveI, Nat.succ_eq_add_one, Fin.val_fin_lt, Fin.ext_iff]\n  split_ifs\n  \u00b7 rfl\n  \u00b7 rename_i h1 h2\n    rw [Fin.lt_def] at h1 h2\n    simp only [Fin.succ_mk, Nat.succ_eq_add_one, add_right_eq_self, one_ne_zero]\n    simp only [Fin.castSucc_mk, Fin.eta, Fin.val_fin_lt, not_lt] at h2\n    rw [Fin.le_def] at h2\n    omega\n  \u00b7 rename_i h1 h2\n    simp only [not_lt] at h1\n    rw [Fin.le_def] at h1\n    rw [Fin.lt_def] at h2\n    simp only [Fin.castSucc_mk] at h2\n    omega\n  \u00b7 rename_i h1 h2\n    simp only [Fin.succ_mk, Nat.succ_eq_add_one]\n    simp only [not_lt] at h1\n    rw [Fin.le_def] at h1\n    omega\n\nlemma predAboveI_eq_iff {i x : Fin n.succ.succ} (h : i \u2260 x) (y : Fin n.succ) :\n    y = predAboveI i x \u2194 i.succAbove y = x := by\n  apply Iff.intro\n  \u00b7 intro h\n    subst h\n    rw [succsAbove_predAboveI h]\n  \u00b7 intro h\n    rw [\u2190 h]\n    simp\n\nlemma predAboveI_lt {i x : Fin n.succ.succ} (h : x.val < i.val) :\n    predAboveI i x = \u27e8x.val, by omega\u27e9 := by\n  simp [predAboveI, h]\n\nlemma predAboveI_ge {i x : Fin n.succ.succ} (h : i.val < x.val) :\n    predAboveI i x = \u27e8x.val - 1, by omega\u27e9 := by\n  simp only [Nat.succ_eq_add_one, predAboveI, Fin.val_fin_lt, dite_eq_right_iff, Fin.mk.injEq]\n  omega\n\nlemma succAbove_succAbove_predAboveI (i : Fin n.succ.succ) (j : Fin n.succ) (x : Fin n) :\n    i.succAbove (j.succAbove x) =\n    (i.succAbove j).succAbove ((predAboveI (i.succAbove j) i).succAbove x) := by\n  by_cases h1 : j.castSucc < i\n  \u00b7 have hx := Fin.succAbove_of_castSucc_lt _ _ h1\n    rw [hx]\n    rw [predAboveI_ge h1]\n    by_cases hx1 : x.castSucc < j\n    \u00b7 rw [Fin.succAbove_of_castSucc_lt _ _ hx1]\n      rw [Fin.succAbove_of_castSucc_lt _ _]\n      \u00b7 nth_rewrite 2 [Fin.succAbove_of_castSucc_lt _ _]\n        \u00b7 rw [Fin.succAbove_of_castSucc_lt _ _]\n          exact hx1\n        \u00b7 rw [Fin.lt_def] at h1 hx1 \u22a2\n          simp_all only [Nat.succ_eq_add_one, Fin.coe_castSucc]\n          omega\n      \u00b7 exact Nat.lt_trans hx1 h1\n    \u00b7 simp only [not_lt] at hx1\n      rw [Fin.le_def] at hx1\n      rw [Fin.lt_def] at h1\n      rw [Fin.succAbove_of_le_castSucc _ _ hx1]\n      by_cases hx2 : x.succ.castSucc < i\n      \u00b7 rw [Fin.succAbove_of_castSucc_lt _ _ hx2]\n        nth_rewrite 2 [Fin.succAbove_of_castSucc_lt _ _]\n        \u00b7 rw [Fin.succAbove_of_le_castSucc]\n          \u00b7 rfl\n          \u00b7 exact hx1\n        \u00b7 rw [Fin.lt_def] at hx2 \u22a2\n          simp_all only [Nat.succ_eq_add_one, Fin.coe_castSucc, Fin.val_succ]\n          omega\n      \u00b7 simp only [Nat.succ_eq_add_one, not_lt] at hx2\n        rw [Fin.succAbove_of_le_castSucc _ _ hx2]\n        nth_rewrite 2 [Fin.succAbove_of_le_castSucc]\n        \u00b7 rw [Fin.succAbove_of_le_castSucc]\n          rw [Fin.le_def]\n          exact Nat.le_succ_of_le hx1\n        \u00b7 rw [Fin.le_def] at hx2 \u22a2\n          simp_all\n  \u00b7 simp only [Nat.succ_eq_add_one, not_lt] at h1\n    have hx := Fin.succAbove_of_le_castSucc _ _ h1\n    rw [hx]\n    rw [predAboveI_lt (Nat.lt_add_one_of_le h1)]\n    by_cases hx1 : j \u2264 x.castSucc\n    \u00b7 rw [Fin.succAbove_of_le_castSucc _ _ hx1]\n      rw [Fin.succAbove_of_le_castSucc _ _]\n      \u00b7 nth_rewrite 2 [Fin.succAbove_of_le_castSucc _ _]\n        \u00b7 rw [Fin.succAbove_of_le_castSucc _ _]\n          rw [Fin.le_def] at hx1 \u22a2\n          simp_all only [Nat.succ_eq_add_one, Fin.coe_castSucc, Fin.val_succ, add_le_add_iff_right]\n        \u00b7 rw [Fin.le_def] at h1 hx1 \u22a2\n          simp_all only [Nat.succ_eq_add_one, Fin.coe_castSucc]\n          omega\n      \u00b7 rw [Fin.le_def] at hx1 h1 \u22a2\n        simp_all only [Nat.succ_eq_add_one, Fin.coe_castSucc, Fin.val_succ]\n        omega\n    \u00b7 simp only [Nat.succ_eq_add_one, not_le] at hx1\n      rw [Fin.lt_def] at hx1\n      rw [Fin.le_def] at h1\n      rw [Fin.succAbove_of_castSucc_lt _ _ hx1]\n      by_cases hx2 : x.castSucc.castSucc < i\n      \u00b7 rw [Fin.succAbove_of_castSucc_lt _ _ hx2]\n        nth_rewrite 2 [Fin.succAbove_of_castSucc_lt _ _]\n        \u00b7 rw [Fin.succAbove_of_castSucc_lt _ _]\n          rw [Fin.lt_def] at hx2 \u22a2\n          simp_all only [Nat.succ_eq_add_one, Fin.coe_castSucc, Fin.val_succ]\n          omega\n        \u00b7 rw [Fin.lt_def] at hx2 \u22a2\n          simp_all\n      \u00b7 simp only [not_lt] at hx2\n        rw [Fin.succAbove_of_le_castSucc _ _ hx2]\n        nth_rewrite 2 [Fin.succAbove_of_le_castSucc]\n        \u00b7 rw [Fin.succAbove_of_castSucc_lt]\n          \u00b7 rfl\n          exact Fin.castSucc_lt_succ_iff.mpr hx1\n        \u00b7 rw [Fin.le_def] at hx2 \u22a2\n          simp_all\n\n/-- The equivalence between `Fin n.succ` and `Fin 1 \u2295 Fin n` extracting the\n  `i`th component. -/\ndef finExtractOne {n : \u2115} (i : Fin n.succ) : Fin n.succ \u2243 Fin 1 \u2295 Fin n :=\n  (finCongr (by omega : n.succ = i + 1 + (n - i))).trans <|\n  finSumFinEquiv.symm.trans <|\n  (Equiv.sumCongr (finSumFinEquiv.symm.trans (Equiv.sumComm (Fin i) (Fin 1)))\n    (Equiv.refl (Fin (n-i)))).trans <|\n  (Equiv.sumAssoc (Fin 1) (Fin i) (Fin (n - i))).trans <|\n  Equiv.sumCongr (Equiv.refl (Fin 1)) (finSumFinEquiv.trans (finCongr (by omega)))\n\n@[simp]\nlemma finExtractOne_apply_eq {n : \u2115} (i : Fin n.succ) :\n    finExtractOne i i = Sum.inl 0 := by\n  simp only [Nat.succ_eq_add_one, finExtractOne, Equiv.trans_apply, finCongr_apply,\n    Equiv.sumCongr_apply, Equiv.coe_trans, Equiv.sumComm_apply, Equiv.coe_refl, Fin.isValue]\n  have h1 :\n      Fin.cast (finExtractOne.proof_1 i) i = Fin.castAdd ((n - \u2191i)) \u27e8i.1, lt_add_one i.1\u27e9 := by\n    rfl\n  rw [h1, finSumFinEquiv_symm_apply_castAdd]\n  simp only [Nat.succ_eq_add_one, Sum.map_inl, Function.comp_apply, Fin.isValue]\n  have h2 : @Fin.mk (\u2191i + 1) \u2191i (lt_add_one i.1) = Fin.natAdd i.val 1 := rfl\n  rw [h2, finSumFinEquiv_symm_apply_natAdd]\n  rfl\n\nlemma finExtractOne_symm_inr {n : \u2115} (i : Fin n.succ) :\n    (finExtractOne i).symm \u2218 Sum.inr = i.succAbove := by\n  ext x\n  simp only [Nat.succ_eq_add_one, finExtractOne, Function.comp_apply, Equiv.symm_trans_apply,\n    finCongr_symm, Equiv.symm_symm, Equiv.sumCongr_symm, Equiv.refl_symm, Equiv.sumCongr_apply,\n    Equiv.coe_refl, Sum.map_inr, finCongr_apply, Fin.coe_cast]\n  change (finSumFinEquiv\n    (Sum.map (\u21d1(finSumFinEquiv.symm.trans (Equiv.sumComm (Fin \u2191i) (Fin 1))).symm) id\n    ((Equiv.sumAssoc (Fin 1) (Fin \u2191i) (Fin (n - i))).symm\n    (Sum.inr (finSumFinEquiv.symm (Fin.cast (finExtractOne.proof_2 i).symm x)))))).val = _\n  by_cases hi : x.1 < i.1\n  \u00b7 have h1 : (finSumFinEquiv.symm (Fin.cast (finExtractOne.proof_2 i).symm x)) =\n        Sum.inl \u27e8x, hi\u27e9 := by\n      rw [\u2190 finSumFinEquiv_symm_apply_castAdd]\n      rfl\n    rw [h1]\n    simp only [Nat.succ_eq_add_one, Equiv.sumAssoc_symm_apply_inr_inl, Sum.map_inl,\n      Equiv.symm_trans_apply, Equiv.symm_symm, Equiv.sumComm_symm, Equiv.sumComm_apply,\n      Sum.swap_inr, finSumFinEquiv_apply_left, Fin.castAdd_mk]\n    rw [Fin.succAbove]\n    split\n    \u00b7 rfl\n    rename_i hn\n    simp_all only [Nat.succ_eq_add_one, not_lt, Fin.le_def, Fin.coe_castSucc, Fin.val_succ,\n      self_eq_add_right, one_ne_zero]\n    omega\n  \u00b7 have h1 : (finSumFinEquiv.symm (Fin.cast (finExtractOne.proof_2 i).symm x)) =\n        Sum.inr \u27e8x - i, by omega\u27e9 := by\n      rw [\u2190 finSumFinEquiv_symm_apply_natAdd]\n      apply congrArg\n      ext\n      simp only [Nat.succ_eq_add_one, Fin.coe_cast, Fin.natAdd_mk]\n      omega\n    rw [h1, Fin.succAbove]\n    split\n    \u00b7 rename_i hn\n      simp_all [Fin.lt_def]\n    simp only [Nat.succ_eq_add_one, Equiv.sumAssoc_symm_apply_inr_inr, Sum.map_inr, id_eq,\n      finSumFinEquiv_apply_right, Fin.natAdd_mk, Fin.val_succ]\n    omega\n\n@[simp]\nlemma finExtractOne_symm_inr_apply {n : \u2115} (i : Fin n.succ) (x : Fin n) :\n    (finExtractOne i).symm (Sum.inr x) = i.succAbove x := calc\n  _ = ((finExtractOne i).symm \u2218 Sum.inr) x := rfl\n  _ = i.succAbove x := by rw [finExtractOne_symm_inr]\n\n@[simp]\nlemma finExtractOne_symm_inl_apply {n : \u2115} (i : Fin n.succ) :\n    (finExtractOne i).symm (Sum.inl 0) = i := by\n  rfl\n\nlemma finExtractOne_apply_neq {n : \u2115} (i j : Fin n.succ.succ) (hij : i \u2260 j) :\n    finExtractOne i j = Sum.inr (predAboveI i j) := by\n  symm\n  apply (Equiv.symm_apply_eq _).mp ?_\n  simp only [Nat.succ_eq_add_one, finExtractOne_symm_inr_apply]\n  exact succsAbove_predAboveI hij\n\n/-- Given an equivalence `Fin n.succ.succ \u2243 Fin n.succ.succ`, and an `i : Fin n.succ.succ`,\n  the map `Fin n.succ \u2192 Fin n.succ` obtained by dropping `i` and it's image. -/\ndef finExtractOnPermHom {m : \u2115} (i : Fin n.succ.succ) (\u03c3 : Fin n.succ.succ \u2243 Fin m.succ.succ) :\n    Fin n.succ \u2192 Fin m.succ := fun x => predAboveI (\u03c3 i) (\u03c3 ((finExtractOne i).symm (Sum.inr x)))\n\nlemma finExtractOnPermHom_inv {m : \u2115} (i : Fin n.succ.succ)\n    (\u03c3 : Fin n.succ.succ \u2243 Fin m.succ.succ) :\n    (finExtractOnPermHom (\u03c3 i) \u03c3.symm) \u2218 (finExtractOnPermHom i \u03c3) = id := by\n  funext x\n  simp only [Nat.succ_eq_add_one, Function.comp_apply, finExtractOnPermHom, Equiv.symm_apply_apply,\n    finExtractOne_symm_inr_apply, id_eq]\n  by_cases h : \u03c3 (i.succAbove x) < \u03c3 i\n  \u00b7 rw [predAboveI_lt h, Fin.succAbove_of_castSucc_lt]\n    \u00b7 simp\n    \u00b7 simp_all [Fin.lt_def]\n  have h\u03c3 : \u03c3 (i.succAbove x) \u2260 \u03c3 i := by\n    simp only [Nat.succ_eq_add_one, ne_eq, EmbeddingLike.apply_eq_iff_eq]\n    exact Fin.succAbove_ne i x\n  have hn : \u03c3 i < \u03c3 (i.succAbove x) := by omega\n  rw [predAboveI_ge hn]\n  rw [Fin.succAbove_of_le_castSucc]\n  \u00b7 simp only [Nat.succ_eq_add_one, Fin.succ_mk]\n    trans predAboveI i (\u03c3.symm (\u03c3 (i.succAbove x)))\n    \u00b7 congr\n      exact Nat.sub_add_cancel (Fin.lt_of_le_of_lt (Fin.zero_le (\u03c3 i)) hn)\n    simp\n  rw [Fin.le_def]\n  simp only [Nat.succ_eq_add_one, Fin.castSucc_mk]\n  omega\n\n/-- Given an equivalence `Fin n.succ.succ \u2243 Fin n.succ.succ`, and an `i : Fin n.succ.succ`,\n  the equivalence `Fin n.succ \u2243 Fin n.succ` obtained by dropping `i` and it's image. -/\ndef finExtractOnePerm {m : \u2115} (i : Fin n.succ.succ) (\u03c3 : Fin n.succ.succ \u2243 Fin m.succ.succ) :\n    Fin n.succ \u2243 Fin m.succ where\n  toFun x := finExtractOnPermHom i \u03c3 x\n  invFun x := finExtractOnPermHom (\u03c3 i) \u03c3.symm x\n  left_inv x := by\n    simpa using congrFun (finExtractOnPermHom_inv i \u03c3) x\n  right_inv x := by\n    simpa using congrFun (finExtractOnPermHom_inv (\u03c3 i) \u03c3.symm) x\n\nlemma finExtractOnePerm_equiv {n m : \u2115} (e : Fin n.succ.succ \u2243 Fin m.succ.succ)\n    (i : Fin n.succ.succ) :\n    e \u2218 i.succAbove = (e i).succAbove \u2218 finExtractOnePerm i e := by\n  simp only [Nat.succ_eq_add_one, finExtractOnePerm, Equiv.coe_fn_mk]\n  funext x\n  simp only [Function.comp_apply, finExtractOnPermHom, Nat.succ_eq_add_one,\n    finExtractOne_symm_inr_apply]\n  rw [succsAbove_predAboveI]\n  simp only [Nat.succ_eq_add_one, ne_eq, EmbeddingLike.apply_eq_iff_eq]\n  exact Fin.ne_succAbove i x\n\n@[simp]\nlemma finExtractOnePerm_apply (i : Fin n.succ.succ) (\u03c3 : Fin n.succ.succ \u2243 Fin n.succ.succ)\n    (x : Fin n.succ) : finExtractOnePerm i \u03c3 x = predAboveI (\u03c3 i)\n    (\u03c3 ((finExtractOne i).symm (Sum.inr x))) := rfl\n\n@[simp]\nlemma finExtractOnePerm_symm_apply (i : Fin n.succ.succ) (\u03c3 : Fin n.succ.succ \u2243 Fin n.succ.succ)\n    (x : Fin n.succ) : (finExtractOnePerm i \u03c3).symm x = predAboveI (\u03c3.symm (\u03c3 i))\n    (\u03c3.symm ((finExtractOne (\u03c3 i)).symm (Sum.inr x))) := rfl\n\n/-- The equivalence of types `Fin n.succ.succ \u2243 (Fin 1 \u2295 Fin 1) \u2295 Fin n` extracting\n  the `i` and `(i.succAbove j)`. -/\ndef finExtractTwo {n : \u2115} (i : Fin n.succ.succ) (j : Fin n.succ) :\n    Fin n.succ.succ \u2243 (Fin 1 \u2295 Fin 1) \u2295 Fin n :=\n  (finExtractOne i).trans <|\n  (Equiv.sumCongr (Equiv.refl (Fin 1)) (finExtractOne j)).trans <|\n  (Equiv.sumAssoc (Fin 1) (Fin 1) (Fin n)).symm\n\n@[simp]\nlemma finExtractTwo_apply_fst {n : \u2115} (i : Fin n.succ.succ) (j : Fin n.succ) :\n    finExtractTwo i j i = Sum.inl (Sum.inl 0) := by\n  simp only [Nat.succ_eq_add_one, finExtractTwo, Equiv.trans_apply, Equiv.sumCongr_apply,\n    Equiv.coe_refl, Fin.isValue]\n  simp [finExtractOne_apply_eq]\n\nlemma finExtractTwo_symm_inr {n : \u2115} (i : Fin n.succ.succ) (j : Fin n.succ) :\n    (finExtractTwo i j).symm \u2218 Sum.inr = i.succAbove \u2218 j.succAbove := by\n  rw [finExtractTwo]\n  ext1 x\n  simp\n\n@[simp]\nlemma finExtractTwo_symm_inr_apply {n : \u2115} (i : Fin n.succ.succ) (j : Fin n.succ) (x : Fin n) :\n    (finExtractTwo i j).symm (Sum.inr x) = i.succAbove (j.succAbove x) := by\n  rw [finExtractTwo]\n  simp\n\n@[simp]\nlemma finExtractTwo_symm_inl_inr_apply {n : \u2115} (i : Fin n.succ.succ) (j : Fin n.succ) :\n    (finExtractTwo i j).symm (Sum.inl (Sum.inr 0)) = i.succAbove j := by\n  rw [finExtractTwo]\n  simp\n\n@[simp]\nlemma finExtractTwo_symm_inl_inl_apply {n : \u2115} (i : Fin n.succ.succ) (j : Fin n.succ) :\n    (finExtractTwo i j).symm (Sum.inl (Sum.inl 0)) = i := by rfl\n\n@[simp]\nlemma finExtractTwo_apply_snd {n : \u2115} (i : Fin n.succ.succ) (j : Fin n.succ) :\n    finExtractTwo i j (i.succAbove j) = Sum.inl (Sum.inr 0) := by\n  rw [\u2190 Equiv.eq_symm_apply]\n  simp\n\n/-- Takes two maps `Fin n \u2192 Fin n` and returns the equivalence they form. -/\ndef finMapToEquiv (f1 : Fin n \u2192 Fin m) (f2 : Fin m \u2192 Fin n)\n    (h : \u2200 x, f1 (f2 x) = x := by decide)\n    (h' : \u2200 x, f2 (f1 x) = x := by decide) : Fin n \u2243 Fin m where\n  toFun := f1\n  invFun := f2\n  left_inv := h'\n  right_inv := h\n\n@[simp]\nlemma finMapToEquiv_apply {f1 : Fin n \u2192 Fin m} {f2 : Fin m \u2192 Fin n}\n    {h : \u2200 x, f1 (f2 x) = x} {h' : \u2200 x, f2 (f1 x) = x} (x : Fin n) :\n    finMapToEquiv f1 f2 h h' x = f1 x := rfl\n\n@[simp]\nlemma finMapToEquiv_symm_apply {f1 : Fin n \u2192 Fin m} {f2 : Fin m \u2192 Fin n}\n    {h : \u2200 x, f1 (f2 x) = x} {h' : \u2200 x, f2 (f1 x) = x} (x : Fin m) :\n    (finMapToEquiv f1 f2 h h').symm x = f2 x := rfl\n\nlemma finMapToEquiv_symm_eq {f1 : Fin n \u2192 Fin m} {f2 : Fin m \u2192 Fin n}\n    {h : \u2200 x, f1 (f2 x) = x} {h' : \u2200 x, f2 (f1 x) = x} :\n    (finMapToEquiv f1 f2 h h').symm = finMapToEquiv f2 f1 h' h := by\n  rfl\n\n/-- Given an equivalence between `Fin n` and `Fin m`, the induced equivalence between\n  `Fin n.succ` and `Fin m.succ` derived by `Fin.cons`. -/\ndef equivCons {n m : \u2115} (e : Fin n \u2243 Fin m) : Fin n.succ \u2243 Fin m.succ where\n  toFun := Fin.cons 0 (Fin.succ \u2218 e.toFun)\n  invFun := Fin.cons 0 (Fin.succ \u2218 e.invFun)\n  left_inv i := by\n    rcases Fin.eq_zero_or_eq_succ i with hi | hi\n    \u00b7 subst hi\n      simp\n    \u00b7 obtain \u27e8j, hj\u27e9 := hi\n      subst hj\n      simp\n  right_inv i := by\n    rcases Fin.eq_zero_or_eq_succ i with hi | hi\n    \u00b7 subst hi\n      simp\n    \u00b7 obtain \u27e8j, hj\u27e9 := hi\n      subst hj\n      simp\n\n@[simp]\nlemma equivCons_zero {n m : \u2115} (e : Fin n \u2243 Fin m) :\n    equivCons e 0 = 0 := by\n  simp [equivCons]\n\n@[simp]\nlemma equivCons_trans {n m k : \u2115} (e : Fin n \u2243 Fin m) (f : Fin m \u2243 Fin k) :\n    Fin.equivCons (e.trans f) = (Fin.equivCons e).trans (Fin.equivCons f) := by\n  refine Equiv.ext_iff.mpr ?_\n  intro x\n  simp only [Nat.succ_eq_add_one, equivCons, Equiv.toFun_as_coe, Equiv.coe_trans,\n    Equiv.invFun_as_coe, Equiv.coe_fn_mk, Equiv.trans_apply]\n  match x with\n  | \u27e80, h\u27e9 => rfl\n  | \u27e8i + 1, h\u27e9 => rfl\n\n@[simp]\nlemma equivCons_castOrderIso {n m : \u2115} (h : n = m) :\n    (Fin.equivCons (Fin.castOrderIso h).toEquiv) = (Fin.castOrderIso (by simp [h])).toEquiv := by\n  refine Equiv.ext_iff.mpr ?_\n  intro x\n  simp only [Nat.succ_eq_add_one, equivCons, Equiv.toFun_as_coe, RelIso.coe_fn_toEquiv,\n    Equiv.invFun_as_coe, OrderIso.toEquiv_symm, Fin.symm_castOrderIso, Equiv.coe_fn_mk,\n    Fin.castOrderIso_apply]\n  match x with\n  | \u27e80, h\u27e9 => rfl\n  | \u27e8i + 1, h\u27e9 => rfl\n\n", "theoremStatement": "@[simp]\nlemma equivCons_symm_succ {n m : \u2115} (e : Fin n \u2243 Fin m) (i : \u2115) (hi : i + 1 < m.succ) :\n    (Fin.equivCons e).symm \u27e8i + 1, hi\u27e9 = (e.symm \u27e8i, Nat.succ_lt_succ_iff.mp hi\u27e9).succ ", "theoremName": "HepLean.Fin.equivCons_symm_succ", "fileCreated": {"commit": "d542ae3903c52a5c8aff332cb26b5f815fe40a04", "date": "2024-10-17"}, "theoremCreated": {"commit": "7ee877af559718130c44e3983e0bc537df97e6be", "date": "2024-12-10"}, "file": "HepLean/HepLean/Mathematics/Fin.lean", "module": "HepLean.Mathematics.Fin", "jsonFile": "HepLean.Mathematics.Fin.jsonl", "positionMetadata": {"lineInFile": 427, "tokenPositionInFile": 16444, "theoremPositionInFile": 32}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 1, "numPremises": 32}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp only [Nat.succ_eq_add_one, equivCons, Equiv.toFun_as_coe, Equiv.invFun_as_coe,\n    Equiv.coe_fn_symm_mk]\n  have hi : \u27e8i + 1, hi\u27e9 = Fin.succ \u27e8i, Nat.succ_lt_succ_iff.mp hi\u27e9 := by rfl\n  rw [hi]\n  rw [Fin.cons_succ]\n  simp", "proofType": "tactic", "proofLengthLines": 6, "proofLengthTokens": 232}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldSpecification.NormalOrder\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.SuperCommute\nimport HepLean.PerturbationTheory.Koszul.KoszulSign\n/-!\n\n# Normal Ordering in the FieldOpFreeAlgebra\n\nIn the module\n`HepLean.PerturbationTheory.FieldSpecification.NormalOrder`\nwe defined the normal ordering of a list of `CrAnFieldOp`.\nIn this module we extend the normal ordering to a linear map on `FieldOpFreeAlgebra`.\n\nWe derive properties of this normal ordering.\n\n-/\n\nnamespace FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\nopen FieldStatistic\n\nnamespace FieldOpFreeAlgebra\n\nnoncomputable section\n\n/-- For a field specification `\ud835\udcd5`, `normalOrderF` is the linear map\n\n  `FieldOpFreeAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpFreeAlgebra \ud835\udcd5`\n\n  defined by its action on the basis `ofCrAnListF \u03c6s`, taking `ofCrAnListF \u03c6s` to\n\n  `normalOrderSign \u03c6s \u2022 ofCrAnListF (normalOrderList \u03c6s)`.\n\n  That is, `normalOrderF` normal-orders the field operators and multiplies by the sign of the\n  normal order.\n\n  The notation `\ud835\udcdd\u1da0(a)` is used for `normalOrderF a` for `a` an element of\n  `FieldOpFreeAlgebra \ud835\udcd5`. -/\ndef normalOrderF : FieldOpFreeAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpFreeAlgebra \ud835\udcd5 :=\n  Basis.constr ofCrAnListFBasis \u2102 fun \u03c6s =>\n  normalOrderSign \u03c6s \u2022 ofCrAnListF (normalOrderList \u03c6s)\n\n@[inherit_doc normalOrderF]\nscoped[FieldSpecification.FieldOpFreeAlgebra] notation \"\ud835\udcdd\u1da0(\" a \")\" => normalOrderF a\n\nlemma normalOrderF_ofCrAnListF (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    \ud835\udcdd\u1da0(ofCrAnListF \u03c6s) = normalOrderSign \u03c6s \u2022 ofCrAnListF (normalOrderList \u03c6s) := by\n  rw [\u2190 ofListBasis_eq_ofList, normalOrderF, Basis.constr_basis]\n\nlemma ofCrAnListF_eq_normalOrderF (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnListF (normalOrderList \u03c6s) = normalOrderSign \u03c6s \u2022 \ud835\udcdd\u1da0(ofCrAnListF \u03c6s) := by\n  rw [normalOrderF_ofCrAnListF, normalOrderList, smul_smul, normalOrderSign,\n    Wick.koszulSign_mul_self, one_smul]\n\nlemma normalOrderF_one : normalOrderF (\ud835\udcd5 := \ud835\udcd5) 1 = 1 := by\n  rw [\u2190 ofCrAnListF_nil, normalOrderF_ofCrAnListF, normalOrderSign_nil, normalOrderList_nil,\n    ofCrAnListF_nil, one_smul]\n\nlemma normalOrderF_normalOrderF_mid (a b c : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \ud835\udcdd\u1da0(a * b * c) = \ud835\udcdd\u1da0(a * \ud835\udcdd\u1da0(b) * c) := by\n  let pc (c : \ud835\udcd5.FieldOpFreeAlgebra) (hc : c \u2208 Submodule.span \u2102 (Set.range ofCrAnListFBasis)) :\n    Prop := \ud835\udcdd\u1da0(a * b * c) = \ud835\udcdd\u1da0(a * \ud835\udcdd\u1da0(b) * c)\n  change pc c (Basis.mem_span _ c)\n  apply Submodule.span_induction\n  \u00b7 intro x hx\n    obtain \u27e8\u03c6s, rfl\u27e9 := hx\n    simp only [ofListBasis_eq_ofList, pc]\n    let pb (b : \ud835\udcd5.FieldOpFreeAlgebra) (hb : b \u2208 Submodule.span \u2102 (Set.range ofCrAnListFBasis)) :\n      Prop := \ud835\udcdd\u1da0(a * b * ofCrAnListF \u03c6s) = \ud835\udcdd\u1da0(a * \ud835\udcdd\u1da0(b) * ofCrAnListF \u03c6s)\n    change pb b (Basis.mem_span _ b)\n    apply Submodule.span_induction\n    \u00b7 intro x hx\n      obtain \u27e8\u03c6s', rfl\u27e9 := hx\n      simp only [ofListBasis_eq_ofList, pb]\n      let pa (a : \ud835\udcd5.FieldOpFreeAlgebra) (ha : a \u2208 Submodule.span \u2102 (Set.range ofCrAnListFBasis)) :\n        Prop := \ud835\udcdd\u1da0(a * ofCrAnListF \u03c6s' * ofCrAnListF \u03c6s) =\n        \ud835\udcdd\u1da0(a * \ud835\udcdd\u1da0(ofCrAnListF \u03c6s') * ofCrAnListF \u03c6s)\n      change pa a (Basis.mem_span _ a)\n      apply Submodule.span_induction\n      \u00b7 intro x hx\n        obtain \u27e8\u03c6s'', rfl\u27e9 := hx\n        simp only [ofListBasis_eq_ofList, pa]\n        rw [normalOrderF_ofCrAnListF]\n        simp only [\u2190 ofCrAnListF_append, Algebra.mul_smul_comm,\n          Algebra.smul_mul_assoc, map_smul]\n        rw [normalOrderF_ofCrAnListF, normalOrderF_ofCrAnListF, smul_smul]\n        congr 1\n        \u00b7 simp only [normalOrderSign, normalOrderList]\n          rw [Wick.koszulSign_of_append_eq_insertionSort, mul_comm]\n        \u00b7 congr 1\n          simp only [normalOrderList]\n          rw [HepLean.List.insertionSort_append_insertionSort_append]\n      \u00b7 simp [pa]\n      \u00b7 intro x y hx hy h1 h2\n        simp_all [pa, add_mul]\n      \u00b7 intro x hx h\n        simp_all [pa]\n    \u00b7 simp [pb]\n    \u00b7 intro x y hx hy h1 h2\n      simp_all [pb, mul_add, add_mul]\n    \u00b7 intro x hx h\n      simp_all [pb]\n  \u00b7 simp [pc]\n  \u00b7 intro x y hx hy h1 h2\n    simp_all [pc, mul_add]\n  \u00b7 intro x hx h hp\n    simp_all [pc]\n\nlemma normalOrderF_normalOrderF_right (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \ud835\udcdd\u1da0(a * b) = \ud835\udcdd\u1da0(a * \ud835\udcdd\u1da0(b)) := by\n  trans \ud835\udcdd\u1da0(a * b * 1)\n  \u00b7 simp\n  \u00b7 rw [normalOrderF_normalOrderF_mid]\n    simp\n\n", "theoremStatement": "lemma normalOrderF_normalOrderF_left (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \ud835\udcdd\u1da0(a * b) = \ud835\udcdd\u1da0(\ud835\udcdd\u1da0(a) * b) ", "theoremName": "FieldSpecification.FieldOpFreeAlgebra.normalOrderF_normalOrderF_left", "fileCreated": {"commit": "ea6e12829370d9630a7e65200c8349e9086c05ba", "date": "2025-02-03"}, "theoremCreated": {"commit": "12d36dc1d9c726c035301091e57be0b29015e4ae", "date": "2025-01-31"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpFreeAlgebra/NormalOrder.lean", "module": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.NormalOrder", "jsonFile": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.NormalOrder.jsonl", "positionMetadata": {"lineInFile": 120, "tokenPositionInFile": 4371, "theoremPositionInFile": 7}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 5, "numPremises": 44}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  trans \ud835\udcdd\u1da0(1 * a * b)\n  \u00b7 simp\n  \u00b7 rw [normalOrderF_normalOrderF_mid]\n    simp", "proofType": "tactic", "proofLengthLines": 4, "proofLengthTokens": 84}}
{"srcContext": "/-\nCopyright (c) 2024 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.Mathematics.Fin\n/-!\n# List lemmas\n\n-/\nnamespace HepLean.List\n\nopen Fin\nopen HepLean\nvariable {n : Nat}\n\nlemma takeWile_eraseIdx {I : Type} (P : I \u2192 Prop) [DecidablePred P] :\n    (l : List I) \u2192 (i : \u2115) \u2192 (hi : \u2200 (i j : Fin l.length), i < j \u2192 P (l.get j) \u2192 P (l.get i)) \u2192\n    List.takeWhile P (List.eraseIdx l i) = (List.takeWhile P l).eraseIdx i\n  | [], _, h => by\n    rfl\n  | a :: [], 0, h => by\n    simp only [List.takeWhile, List.eraseIdx_zero, List.nil_eq]\n    split\n    \u00b7 rfl\n    \u00b7 rfl\n  | a :: [], Nat.succ n, h => by\n    simp only [Nat.succ_eq_add_one, List.eraseIdx_cons_succ, List.eraseIdx_nil]\n    rw [List.eraseIdx_of_length_le]\n    have h1 : (List.takeWhile P [a]).length \u2264 [a].length :=\n        List.Sublist.length_le (List.takeWhile_sublist _)\n    simp only [List.length_singleton] at h1\n    omega\n  | a :: b :: l, 0, h => by\n    simp only [List.takeWhile, List.eraseIdx_zero]\n    by_cases hPb : P b\n    \u00b7 have hPa : P a := by\n        simpa using h \u27e80, by simp\u27e9 \u27e81, by simp\u27e9 (by simp [Fin.lt_def]) (by simpa using hPb)\n      simp [hPb, hPa]\n    \u00b7 simp only [hPb, decide_false, List.nil_eq]\n      simp_all only [List.length_cons, List.get_eq_getElem, List.tail_cons, decide_false,\n        Bool.false_eq_true, not_false_eq_true, List.takeWhile_cons_of_neg, List.nil_eq]\n      split\n      \u00b7 rfl\n      \u00b7 rfl\n  | a :: b :: l, Nat.succ n, h => by\n    simp only [Nat.succ_eq_add_one, List.eraseIdx_cons_succ]\n    by_cases hPa : P a\n    \u00b7 dsimp only [List.takeWhile]\n      simp only [hPa, decide_true, List.eraseIdx_cons_succ, List.cons.injEq, true_and]\n      rw [takeWile_eraseIdx]\n      rfl\n      intro i j hij hP\n      simpa using h (Fin.succ i) (Fin.succ j) (by simpa using hij) (by simpa using hP)\n    \u00b7 simp [hPa]\n\nlemma dropWile_eraseIdx {I : Type} (P : I \u2192 Prop) [DecidablePred P] :\n    (l : List I) \u2192 (i : \u2115) \u2192 (hi : \u2200 (i j : Fin l.length), i < j \u2192 P (l.get j) \u2192 P (l.get i)) \u2192\n    List.dropWhile P (List.eraseIdx l i) =\n      if (List.takeWhile P l).length \u2264 i then\n        (List.dropWhile P l).eraseIdx (i - (List.takeWhile P l).length)\n      else (List.dropWhile P l)\n  | [], _, h => by\n    simp\n  | a :: [], 0, h => by\n    simp only [List.dropWhile, nonpos_iff_eq_zero, List.length_eq_zero, List.takeWhile_eq_nil_iff,\n      List.length_singleton, zero_lt_one, Fin.zero_eta, Fin.isValue, List.get_eq_getElem,\n      Fin.val_eq_zero, List.getElem_cons_zero, decide_eq_true_eq, forall_const, zero_le,\n      Nat.sub_eq_zero_of_le, List.eraseIdx_zero, ite_not, List.nil_eq]\n    simp_all only [List.length_cons, List.length_nil, List.get_eq_getElem, Fin.val_eq_zero,\n      List.getElem_cons_zero, implies_true, List.tail_cons, List.dropWhile_nil, decide_true,\n      decide_false, ite_self]\n  | a :: [], Nat.succ n, h => by\n    simp only [List.dropWhile, List.eraseIdx_nil, List.takeWhile, Nat.succ_eq_add_one]\n    rw [List.eraseIdx_of_length_le]\n    simp_all only [List.length_singleton, List.get_eq_getElem, Fin.val_eq_zero,\n      List.getElem_cons_zero, implies_true, ite_self]\n    split\n    next x heq =>\n      simp_all only [decide_eq_true_eq, decide_true, List.dropWhile_cons_of_pos, List.dropWhile_nil,\n        List.length_singleton, le_add_iff_nonneg_left, zero_le, \u2193reduceIte, add_tsub_cancel_right, List.eraseIdx_nil]\n    next x heq =>\n      simp_all only [decide_eq_false_iff_not, decide_false, Bool.false_eq_true, not_false_eq_true,\n        List.dropWhile_cons_of_neg, List.length_nil, le_add_iff_nonneg_left, zero_le, \u2193reduceIte, tsub_zero,\n        List.eraseIdx_cons_succ, List.eraseIdx_nil]\n    exact Nat.le_add_left [a].length n\n  | a :: b :: l, 0, h => by\n    simp only [List.dropWhile, List.takeWhile, nonpos_iff_eq_zero, List.length_eq_zero, zero_le,\n      Nat.sub_eq_zero_of_le, List.eraseIdx_zero]\n    by_cases hPb : P b\n    \u00b7 have hPa : P a := by\n        simpa using h \u27e80, by simp\u27e9 \u27e81, by simp\u27e9 (by simp [Fin.lt_def]) (by simpa using hPb)\n      simp [hPb, hPa]\n    \u00b7 simp only [hPb, decide_false, nonpos_iff_eq_zero, List.length_eq_zero]\n      simp_all only [List.length_cons, List.get_eq_getElem]\n      simp_rw [decide_false]\n      simp_all only [List.tail_cons, decide_false, Bool.false_eq_true, not_false_eq_true,\n        List.dropWhile_cons_of_neg, nonpos_iff_eq_zero, List.length_eq_zero]\n      split\n      next x heq =>\n        simp_all only [decide_eq_true_eq, List.length_singleton, nonpos_iff_eq_zero, one_ne_zero,\n          \u2193reduceIte]\n      next x heq => simp_all only [decide_eq_false_iff_not, List.length_nil,\n        le_refl, \u2193reduceIte, List.tail_cons]\n  | a :: b :: l, Nat.succ n, h => by\n    simp only [Nat.succ_eq_add_one, List.eraseIdx_cons_succ]\n    by_cases hPb : P b\n    \u00b7 have hPa : P a := by\n        simpa using h \u27e80, by simp\u27e9 \u27e81, by simp\u27e9 (by simp [Fin.lt_def]) (by simpa using hPb)\n      simp only [List.dropWhile, hPa, decide_true, List.takeWhile, hPb, List.length_cons,\n        add_le_add_iff_right, Nat.reduceSubDiff]\n      rw [dropWile_eraseIdx]\n      simp_all only [List.length_cons, List.get_eq_getElem, decide_true, List.takeWhile_cons_of_pos,\n        List.dropWhile_cons_of_pos]\n      intro i j hij hP\n      simpa using h (Fin.succ i) (Fin.succ j) (by simpa using hij) (by simpa using hP)\n    \u00b7 simp only [List.dropWhile, List.takeWhile, hPb, decide_false]\n      by_cases hPa : P a\n      \u00b7 rw [dropWile_eraseIdx]\n        simp only [hPa, decide_true, hPb, decide_false, Bool.false_eq_true, not_false_eq_true,\n          List.takeWhile_cons_of_neg, List.length_nil, zero_le, \u2193reduceIte, List.dropWhile,\n          tsub_zero, List.length_singleton, le_add_iff_nonneg_left, add_tsub_cancel_right]\n        intro i j hij hP\n        simpa using h (Fin.succ i) (Fin.succ j) (by simpa using hij) (by simpa using hP)\n      \u00b7 simp [hPa]\n\nlemma insertionSort_length {I : Type} (le1 : I \u2192 I \u2192 Prop) [DecidableRel le1] (l : List I) :\n    (List.insertionSort le1 l).length = l.length := by\n  apply List.Perm.length_eq\n  exact List.perm_insertionSort le1 l\n\n/-- The position `r0` ends up in `r` on adding it via `List.orderedInsert _ r0 r`. -/\ndef orderedInsertPos {I : Type} (le1 : I \u2192 I \u2192 Prop) [DecidableRel le1] (r : List I) (r0 : I) :\n    Fin (List.orderedInsert le1 r0 r).length :=\n  \u27e8(List.takeWhile (fun b => decide \u00ac le1 r0 b) r).length, by\n    rw [List.orderedInsert_length]\n    have h1 : (List.takeWhile (fun b => decide \u00acle1 r0 b) r).length \u2264 r.length :=\n      List.Sublist.length_le (List.takeWhile_sublist fun b => decide \u00acle1 r0 b)\n    omega\u27e9\n\nlemma orderedInsertPos_lt_length {I : Type} (le1 : I \u2192 I \u2192 Prop) [DecidableRel le1] (r : List I)\n    (r0 : I) : orderedInsertPos le1 r r0 < (r0 :: r).length := by\n  simp only [orderedInsertPos, List.length_cons]\n  have h1 : (List.takeWhile (fun b => decide \u00acle1 r0 b) r).length \u2264 r.length :=\n    List.Sublist.length_le (List.takeWhile_sublist fun b => decide \u00acle1 r0 b)\n  omega\n\n@[simp]\nlemma orderedInsert_get_orderedInsertPos {I : Type} (le1 : I \u2192 I \u2192 Prop) [DecidableRel le1]\n    (r : List I) (r0 : I) :\n    (List.orderedInsert le1 r0 r)[(orderedInsertPos le1 r r0).val] = r0 := by\n  simp only [List.orderedInsert_eq_take_drop, decide_not, orderedInsertPos]\n  rw [List.getElem_append]\n  simp\n\n@[simp]\nlemma orderedInsert_eraseIdx_orderedInsertPos {I : Type} (le1 : I \u2192 I \u2192 Prop) [DecidableRel le1]\n    (r : List I) (r0 : I) :\n    (List.orderedInsert le1 r0 r).eraseIdx \u2191(orderedInsertPos le1 r r0) = r := by\n  simp only [List.orderedInsert_eq_take_drop]\n  rw [List.eraseIdx_append_of_length_le]\n  \u00b7 simp [orderedInsertPos]\n  \u00b7 rfl\n\nlemma orderedInsertPos_cons {I : Type} (le1 : I \u2192 I \u2192 Prop) [DecidableRel le1]\n    (r : List I) (r0 r1 : I) :\n    (orderedInsertPos le1 (r1 ::r) r0).val =\n    if le1 r0 r1 then \u27e80, by simp\u27e9 else (Fin.succ (orderedInsertPos le1 r r0)) := by\n  simp only [List.orderedInsert.eq_2, orderedInsertPos, List.takeWhile, decide_not, Fin.zero_eta,\n    Fin.succ_mk]\n  by_cases h : le1 r0 r1\n  \u00b7 simp [h]\n  \u00b7 simp [h]\n\nlemma orderedInsertPos_sigma {I : Type} {f : I \u2192 Type}\n    (le1 : I \u2192 I \u2192 Prop) [DecidableRel le1] (l : List (\u03a3 i, f i))\n    (k : I) (a : f k) :\n    (orderedInsertPos (fun (i j : \u03a3 i, f i) => le1 i.1 j.1) l \u27e8k, a\u27e9).1 =\n    (orderedInsertPos le1 (List.map (fun (i : \u03a3 i, f i) => i.1) l) k).1 := by\n  simp only [orderedInsertPos, decide_not]\n  induction l with\n  | nil =>\n    simp\n  | cons a l ih =>\n    simp only [List.takeWhile]\n    obtain \u27e8fst, snd\u27e9 := a\n    simp_all only\n    split\n    next x heq =>\n      simp_all only [Bool.not_eq_eq_eq_not, Bool.not_true, decide_eq_false_iff_not,\n        List.length_cons, List.map_cons, decide_false, Bool.not_false, List.takeWhile_cons_of_pos]\n    next x heq =>\n      simp_all only [Bool.not_eq_eq_eq_not, Bool.not_false, decide_eq_true_eq, List.length_nil,\n        List.map_cons, decide_true, Bool.not_true, Bool.false_eq_true, not_false_eq_true,\n        List.takeWhile_cons_of_neg]\n\nlemma orderedInsert_get_lt {I : Type} (le1 : I \u2192 I \u2192 Prop) [DecidableRel le1]\n    (r : List I) (r0 : I) (i : \u2115)\n    (hi : i < orderedInsertPos le1 r r0) :\n    (List.orderedInsert le1 r0 r)[i] = r.get \u27e8i, by\n      simp only [orderedInsertPos] at hi\n      have h1 : (List.takeWhile (fun b => decide \u00acle1 r0 b) r).length \u2264 r.length :=\n        List.Sublist.length_le (List.takeWhile_sublist fun b => decide \u00acle1 r0 b)\n      omega\u27e9 := by\n  simp only [orderedInsertPos, decide_not] at hi\n  simp only [List.orderedInsert_eq_take_drop, decide_not, List.get_eq_getElem]\n  rw [List.getElem_append]\n  simp only [hi, \u2193reduceDIte]\n  rw [List.IsPrefix.getElem]\n  exact List.takeWhile_prefix fun b => !decide (le1 r0 b)\n\nlemma orderedInsertPos_take_orderedInsert {I : Type} (le1 : I \u2192 I \u2192 Prop) [DecidableRel le1]\n    (r : List I) (r0 : I) :\n    (List.take (orderedInsertPos le1 r r0) (List.orderedInsert le1 r0 r)) =\n    List.takeWhile (fun b => decide \u00acle1 r0 b) r := by\n  simp [orderedInsertPos, List.orderedInsert_eq_take_drop]\n\nlemma orderedInsertPos_take_eq_orderedInsert {I : Type} (le1 : I \u2192 I \u2192 Prop) [DecidableRel le1]\n    (r : List I) (r0 : I) :\n    List.take (orderedInsertPos le1 r r0) r =\n    List.take (orderedInsertPos le1 r r0) (List.orderedInsert le1 r0 r) := by\n  refine List.ext_get ?_ ?_\n  \u00b7 simp only [List.length_take, Fin.is_le', inf_of_le_left, inf_eq_left]\n    exact Nat.le_of_lt_succ (orderedInsertPos_lt_length le1 r r0)\n  \u00b7 intro n h1 h2\n    simp only [List.get_eq_getElem, List.getElem_take]\n    erw [orderedInsert_get_lt le1 r r0 n]\n    rfl\n    simp only [List.length_take, lt_inf_iff] at h1\n    exact h1.1\n\nlemma orderedInsertPos_drop_eq_orderedInsert {I : Type} (le1 : I \u2192 I \u2192 Prop) [DecidableRel le1]\n    (r : List I) (r0 : I) :\n    List.drop (orderedInsertPos le1 r r0) r =\n    List.drop (orderedInsertPos le1 r r0).succ (List.orderedInsert le1 r0 r) := by\n  conv_rhs => simp [orderedInsertPos, List.orderedInsert_eq_take_drop]\n  have hr : r = List.takeWhile (fun b => !decide (le1 r0 b)) r ++\n      List.dropWhile (fun b => !decide (le1 r0 b)) r := by\n    exact Eq.symm (List.takeWhile_append_dropWhile (fun b => !decide (le1 r0 b)) r)\n  conv_lhs =>\n    rhs\n    rw [hr]\n  rw [List.drop_append_eq_append_drop]\n  simp [orderedInsertPos]\n\nlemma orderedInsertPos_take {I : Type} (le1 : I \u2192 I \u2192 Prop) [DecidableRel le1]\n    (r : List I) (r0 : I) :\n    List.take (orderedInsertPos le1 r r0) r = List.takeWhile (fun b => decide \u00acle1 r0 b) r := by\n  rw [orderedInsertPos_take_eq_orderedInsert]\n  rw [orderedInsertPos_take_orderedInsert]\n\nlemma orderedInsertPos_drop {I : Type} (le1 : I \u2192 I \u2192 Prop) [DecidableRel le1]\n    (r : List I) (r0 : I) :\n    List.drop (orderedInsertPos le1 r r0) r = List.dropWhile (fun b => decide \u00acle1 r0 b) r := by\n  rw [orderedInsertPos_drop_eq_orderedInsert]\n  simp [orderedInsertPos, List.orderedInsert_eq_take_drop]\n\nlemma orderedInsertPos_succ_take_orderedInsert {I : Type} (le1 : I \u2192 I \u2192 Prop) [DecidableRel le1]\n    (r : List I) (r0 : I) :\n    (List.take (orderedInsertPos le1 r r0).succ (List.orderedInsert le1 r0 r)) =\n    List.takeWhile (fun b => decide \u00acle1 r0 b) r ++ [r0] := by\n  simp [orderedInsertPos, List.orderedInsert_eq_take_drop, List.take_append_eq_append_take]\n\nlemma lt_orderedInsertPos_rel {I : Type} (le1 : I \u2192 I \u2192 Prop) [DecidableRel le1]\n    (r0 : I) (r : List I) (n : Fin r.length)\n    (hn : n.val < (orderedInsertPos le1 r r0).val) : \u00ac le1 r0 (r.get n) := by\n  have htake : r.get n \u2208 List.take (orderedInsertPos le1 r r0) r := by\n    rw [@List.mem_take_iff_getElem]\n    use n\n    simp only [List.get_eq_getElem, lt_inf_iff, Fin.is_lt, and_true, exists_prop]\n    exact hn\n  rw [orderedInsertPos_take] at htake\n  have htake' := List.mem_takeWhile_imp htake\n  simpa using htake'\n\nlemma lt_orderedInsertPos_rel_fin {I : Type} (le1 : I \u2192 I \u2192 Prop) [DecidableRel le1]\n    (r0 : I) (r : List I) (n : Fin (List.orderedInsert le1 r0 r).length)\n    (hn : n < (orderedInsertPos le1 r r0)) : \u00ac le1 r0 ((List.orderedInsert le1 r0 r).get n) := by\n  have htake : (List.orderedInsert le1 r0 r).get n \u2208 List.take (orderedInsertPos le1 r r0) r := by\n    rw [orderedInsertPos_take_eq_orderedInsert]\n    rw [List.mem_take_iff_getElem]\n    use n\n    simp only [List.get_eq_getElem, Fin.is_le', inf_of_le_left, Fin.val_fin_lt, exists_prop,\n      and_true]\n    exact hn\n  rw [orderedInsertPos_take] at htake\n  have htake' := List.mem_takeWhile_imp htake\n  simpa using htake'\n\nlemma gt_orderedInsertPos_rel {I : Type} (le1 : I \u2192 I \u2192 Prop) [DecidableRel le1]\n    [IsTotal I le1] [IsTrans I le1] (r0 : I) (r : List I) (hs : List.Sorted le1 r)\n    (n : Fin r.length)\n    (hn : \u00ac n.val < (orderedInsertPos le1 r r0).val) : le1 r0 (r.get n) := by\n  have hrsSorted : List.Sorted le1 (List.orderedInsert le1 r0 r) :=\n    List.Sorted.orderedInsert r0 r hs\n  apply List.Sorted.rel_of_mem_take_of_mem_drop (k := (orderedInsertPos le1 r r0).succ) hrsSorted\n  \u00b7 rw [orderedInsertPos_succ_take_orderedInsert]\n    simp\n  \u00b7 rw [\u2190 orderedInsertPos_drop_eq_orderedInsert]\n    refine List.mem_drop_iff_getElem.mpr ?hy.a\n    use n - (orderedInsertPos le1 r r0).val\n    have hn : \u2191n - \u2191(orderedInsertPos le1 r r0) + \u2191(orderedInsertPos le1 r r0) < r.length := by\n      omega\n    use hn\n    congr\n    omega\n\nlemma orderedInsert_eraseIdx_lt_orderedInsertPos {I : Type} (le1 : I \u2192 I \u2192 Prop) [DecidableRel le1]\n    (r : List I) (r0 : I) (i : \u2115)\n    (hi : i < orderedInsertPos le1 r r0)\n    (hr : \u2200 (i j : Fin r.length), i < j \u2192 \u00acle1 r0 (r.get j) \u2192 \u00acle1 r0 (r.get i)) :\n    (List.orderedInsert le1 r0 r).eraseIdx i = List.orderedInsert le1 r0 (r.eraseIdx i) := by\n  conv_lhs => simp only [List.orderedInsert_eq_take_drop]\n  rw [List.eraseIdx_append_of_lt_length]\n  \u00b7 simp only [List.orderedInsert_eq_take_drop]\n    congr 1\n    \u00b7 rw [takeWile_eraseIdx]\n      exact hr\n    \u00b7 rw [dropWile_eraseIdx]\n      simp only [orderedInsertPos, decide_not] at hi\n      have hi' : \u00ac (List.takeWhile (fun b => !decide (le1 r0 b)) r).length \u2264 \u2191i := by\n        omega\n      simp only [decide_not, hi', \u2193reduceIte]\n      exact fun i j a a_1 => hr i j a a_1\n  \u00b7 exact hi\n\nlemma orderedInsert_eraseIdx_orderedInsertPos_le {I : Type} (le1 : I \u2192 I \u2192 Prop) [DecidableRel le1]\n    (r : List I) (r0 : I) (i : \u2115)\n    (hi : orderedInsertPos le1 r r0 \u2264 i)\n    (hr : \u2200 (i j : Fin r.length), i < j \u2192 \u00acle1 r0 (r.get j) \u2192 \u00acle1 r0 (r.get i)) :\n    (List.orderedInsert le1 r0 r).eraseIdx (Nat.succ i) =\n    List.orderedInsert le1 r0 (r.eraseIdx i) := by\n  conv_lhs => simp only [List.orderedInsert_eq_take_drop]\n  rw [List.eraseIdx_append_of_length_le]\n  \u00b7 simp only [List.orderedInsert_eq_take_drop]\n    congr 1\n    \u00b7 rw [takeWile_eraseIdx]\n      rw [List.eraseIdx_of_length_le]\n      simp only [orderedInsertPos, decide_not] at hi\n      simp only [decide_not]\n      omega\n      exact hr\n    \u00b7 simp only [Nat.succ_eq_add_one]\n      have hn : (i + 1 - (List.takeWhile (fun b => (decide (\u00ac le1 r0 b))) r).length)\n        = (i - (List.takeWhile (fun b => decide (\u00ac le1 r0 b)) r).length) + 1 := by\n        simp only [orderedInsertPos] at hi\n        omega\n      rw [hn]\n      simp only [List.eraseIdx_cons_succ, List.cons.injEq, true_and]\n      rw [dropWile_eraseIdx]\n      rw [if_pos]\n      \u00b7 simp only [orderedInsertPos] at hi\n        omega\n      \u00b7 exact hr\n  \u00b7 simp only [orderedInsertPos] at hi\n    omega\n\n/-- The equivalence between `Fin (r0 :: r).length` and `Fin (List.orderedInsert le1 r0 r).length`\n  according to where the elements map, i.e. `0` is taken to `orderedInsertPos le1 r r0`. -/\ndef orderedInsertEquiv {I : Type} (le1 : I \u2192 I \u2192 Prop) [DecidableRel le1] (r : List I) (r0 : I) :\n    Fin (r0 :: r).length \u2243 Fin (List.orderedInsert le1 r0 r).length := by\n  let e2 : Fin (List.orderedInsert le1 r0 r).length \u2243 Fin (r0 :: r).length :=\n    (Fin.castOrderIso (List.orderedInsert_length le1 r r0)).toEquiv\n  let e3 : Fin (r0 :: r).length \u2243 Fin 1 \u2295 Fin (r).length := finExtractOne 0\n  let e4 : Fin (r0 :: r).length \u2243 Fin 1 \u2295 Fin (r).length :=\n    finExtractOne \u27e8orderedInsertPos le1 r r0, orderedInsertPos_lt_length le1 r r0\u27e9\n  exact e3.trans (e4.symm.trans e2.symm)\n\nlemma orderedInsertEquiv_zero {I : Type} (le1 : I \u2192 I \u2192 Prop) [DecidableRel le1] (r : List I)\n    (r0 : I) : orderedInsertEquiv le1 r r0 \u27e80, by simp\u27e9 = orderedInsertPos le1 r r0 := by\n  simp [orderedInsertEquiv]\n\nlemma orderedInsertEquiv_succ {I : Type} (le1 : I \u2192 I \u2192 Prop) [DecidableRel le1] (r : List I)\n    (r0 : I) (n : \u2115) (hn : Nat.succ n < (r0 :: r).length) :\n    orderedInsertEquiv le1 r r0 \u27e8Nat.succ n, hn\u27e9 =\n    Fin.cast (List.orderedInsert_length le1 r r0).symm\n    ((Fin.succAbove \u27e8(orderedInsertPos le1 r r0), orderedInsertPos_lt_length le1 r r0\u27e9)\n    \u27e8n, Nat.succ_lt_succ_iff.mp hn\u27e9) := by\n  simp only [List.length_cons, orderedInsertEquiv, Nat.succ_eq_add_one, OrderIso.toEquiv_symm,\n    Fin.symm_castOrderIso, Equiv.trans_apply, RelIso.coe_fn_toEquiv, Fin.castOrderIso_apply]\n  match r with\n  | [] =>\n    simp\n  | r1 :: r =>\n    erw [finExtractOne_apply_neq]\n    simp only [List.orderedInsert.eq_2, List.length_cons, orderedInsertPos, decide_not,\n      Nat.succ_eq_add_one, finExtractOne_symm_inr_apply]\n    rfl\n    exact ne_of_beq_false rfl\n\nlemma orderedInsertEquiv_fin_succ {I : Type} (le1 : I \u2192 I \u2192 Prop) [DecidableRel le1] (r : List I)\n    (r0 : I) (n : Fin r.length) :\n    orderedInsertEquiv le1 r r0 n.succ = Fin.cast (List.orderedInsert_length le1 r r0).symm\n    ((Fin.succAbove \u27e8(orderedInsertPos le1 r r0), orderedInsertPos_lt_length le1 r r0\u27e9)\n      \u27e8n, n.isLt\u27e9) := by\n  simp only [List.length_cons, orderedInsertEquiv, Nat.succ_eq_add_one, OrderIso.toEquiv_symm,\n    Fin.symm_castOrderIso, Equiv.trans_apply, RelIso.coe_fn_toEquiv, Fin.castOrderIso_apply,\n    Fin.eta]\n  match r with\n  | [] =>\n    simp\n  | r1 :: r =>\n    erw [finExtractOne_apply_neq]\n    simp only [List.orderedInsert.eq_2, List.length_cons, orderedInsertPos, decide_not,\n      Nat.succ_eq_add_one, finExtractOne_symm_inr_apply]\n    rfl\n    exact ne_of_beq_false rfl\n\nlemma orderedInsertEquiv_monotone_fin_succ {I : Type}\n    (le1 : I \u2192 I \u2192 Prop) [DecidableRel le1] (r : List I)\n    (r0 : I) (n m : Fin r.length)\n    (hx : orderedInsertEquiv le1 r r0 n.succ < orderedInsertEquiv le1 r r0 m.succ) :\n    n < m := by\n  rw [orderedInsertEquiv_fin_succ, orderedInsertEquiv_fin_succ] at hx\n  rw [Fin.lt_def] at hx\n  simp only [Fin.eta, Fin.coe_cast, Fin.val_fin_lt] at hx\n  rw [Fin.succAbove_lt_succAbove_iff] at hx\n  exact hx\n\nlemma orderedInsertEquiv_congr {\u03b1 : Type} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [DecidableRel r] (a : \u03b1)\n    (l l' : List \u03b1) (h : l = l') :\n    orderedInsertEquiv r l a = (Fin.castOrderIso (by simp [h])).toEquiv.trans\n    ((orderedInsertEquiv r l' a).trans (Fin.castOrderIso (by simp [h])).toEquiv) := by\n  subst h\n  rfl\n\nlemma get_eq_orderedInsertEquiv {I : Type} (le1 : I \u2192 I \u2192 Prop) [DecidableRel le1] (r : List I)\n    (r0 : I) :\n    (r0 :: r).get = (List.orderedInsert le1 r0 r).get \u2218 (orderedInsertEquiv le1 r r0) := by\n  funext x\n  match x with\n  | \u27e80, h\u27e9 =>\n    simp only [List.length_cons, Fin.zero_eta, List.get_eq_getElem, Fin.val_zero,\n      List.getElem_cons_zero, Function.comp_apply]\n    erw [orderedInsertEquiv_zero]\n    simp\n  | \u27e8Nat.succ n, h\u27e9 =>\n    simp only [List.length_cons, Nat.succ_eq_add_one, List.get_eq_getElem, List.getElem_cons_succ,\n      Function.comp_apply]\n    erw [orderedInsertEquiv_succ]\n    simp only [Fin.succAbove, Fin.castSucc_mk, Fin.mk_lt_mk, Fin.succ_mk, Fin.coe_cast]\n    by_cases hn : n < \u2191(orderedInsertPos le1 r r0)\n    \u00b7 simp [hn, orderedInsert_get_lt]\n    \u00b7 simp only [hn, \u2193reduceIte]\n      simp only [List.orderedInsert_eq_take_drop, decide_not]\n      rw [List.getElem_append]\n      have hn' : \u00ac n + 1 < (List.takeWhile (fun b => !decide (le1 r0 b)) r).length := by\n        simp only [orderedInsertPos, decide_not, not_lt] at hn\n        omega\n      simp only [hn', \u2193reduceDIte]\n      have hnn : n + 1 - (List.takeWhile (fun b => !decide (le1 r0 b)) r).length =\n        (n - (List.takeWhile (fun b => !decide (le1 r0 b)) r).length) + 1 := by\n        simp only [orderedInsertPos, decide_not, not_lt] at hn\n        omega\n      simp only [hnn, List.getElem_cons_succ]\n      conv_rhs =>\n        rw [List.IsSuffix.getElem (List.dropWhile_suffix fun b => !decide (le1 r0 b))]\n      congr\n      have hr : r.length = (List.takeWhile (fun b => !decide (le1 r0 b)) r).length +\n          (List.dropWhile (fun b => !decide (le1 r0 b)) r).length := by\n        rw [\u2190 List.length_append]\n        congr\n        exact Eq.symm (List.takeWhile_append_dropWhile (fun b => !decide (le1 r0 b)) r)\n      simp only [hr, add_tsub_cancel_right]\n      omega\n\nlemma orderedInsertEquiv_get {I : Type} (le1 : I \u2192 I \u2192 Prop) [DecidableRel le1] (r : List I)\n    (r0 : I) :\n    (r0 :: r).get \u2218 (orderedInsertEquiv le1 r r0).symm = (List.orderedInsert le1 r0 r).get := by\n  rw [get_eq_orderedInsertEquiv le1]\n  funext x\n  simp\n\nlemma orderedInsert_eraseIdx_orderedInsertEquiv_zero\n    {I : Type} (le1 : I \u2192 I \u2192 Prop) [DecidableRel le1] (r : List I) (r0 : I) :\n    (List.orderedInsert le1 r0 r).eraseIdx (orderedInsertEquiv le1 r r0 \u27e80, by simp\u27e9) = r := by\n  simp [orderedInsertEquiv]\n\nlemma orderedInsert_eraseIdx_orderedInsertEquiv_succ\n    {I : Type} (le1 : I \u2192 I \u2192 Prop) [DecidableRel le1] (r : List I) (r0 : I) (n : \u2115)\n    (hn : Nat.succ n < (r0 :: r).length)\n    (hr : \u2200 (i j : Fin r.length), i < j \u2192 \u00acle1 r0 (r.get j) \u2192 \u00acle1 r0 (r.get i)) :\n    (List.orderedInsert le1 r0 r).eraseIdx (orderedInsertEquiv le1 r r0 \u27e8Nat.succ n, hn\u27e9) =\n    (List.orderedInsert le1 r0 (r.eraseIdx n)) := by\n  induction r with\n  | nil =>\n    simp at hn\n  | cons r1 r ih =>\n    rw [orderedInsertEquiv_succ]\n    simp only [List.length_cons, Fin.succAbove,\n      Fin.castSucc_mk, Fin.mk_lt_mk, Fin.succ_mk, Fin.coe_cast]\n    by_cases hn' : n < (orderedInsertPos le1 (r1 :: r) r0)\n    \u00b7 simp only [hn', \u2193reduceIte]\n      rw [orderedInsert_eraseIdx_lt_orderedInsertPos le1 (r1 :: r) r0 n hn' hr]\n    \u00b7 simp only [hn', \u2193reduceIte]\n      rw [orderedInsert_eraseIdx_orderedInsertPos_le le1 (r1 :: r) r0 n _ hr]\n      omega\n\nlemma orderedInsert_eraseIdx_orderedInsertEquiv_fin_succ\n    {I : Type} (le1 : I \u2192 I \u2192 Prop) [DecidableRel le1] (r : List I) (r0 : I) (n : Fin r.length)\n    (hr : \u2200 (i j : Fin r.length), i < j \u2192 \u00acle1 r0 (r.get j) \u2192 \u00acle1 r0 (r.get i)) :\n    (List.orderedInsert le1 r0 r).eraseIdx (orderedInsertEquiv le1 r r0 n.succ) =\n    (List.orderedInsert le1 r0 (r.eraseIdx n)) := by\n  have hn : n.succ = \u27e8n.val + 1, by omega\u27e9 := by\n    rw [Fin.ext_iff]\n    rfl\n  rw [hn]\n  exact orderedInsert_eraseIdx_orderedInsertEquiv_succ le1 r r0 n.val _ hr\n\nlemma orderedInsertEquiv_sigma {I : Type} {f : I \u2192 Type}\n    (le1 : I \u2192 I \u2192 Prop) [DecidableRel le1] (l : List (\u03a3 i, f i))\n    (i : I) (a : f i) :\n    (orderedInsertEquiv (fun i j => le1 i.fst j.fst) l \u27e8i, a\u27e9) =\n    (Fin.castOrderIso (by simp)).toEquiv.trans\n    ((orderedInsertEquiv le1 (List.map (fun i => i.1) l) i).trans\n    (Fin.castOrderIso (by simp [List.orderedInsert_length])).toEquiv) := by\n  ext x\n  match x with\n  | \u27e80, h0\u27e9 =>\n    simp only [List.length_cons, Fin.zero_eta, Equiv.trans_apply, RelIso.coe_fn_toEquiv,\n      Fin.castOrderIso_apply, Fin.cast_zero, Fin.coe_cast]\n    erw [orderedInsertEquiv_zero, orderedInsertEquiv_zero]\n    simp [orderedInsertPos_sigma]\n  | \u27e8Nat.succ n, h0\u27e9 =>\n    simp only [List.length_cons, Nat.succ_eq_add_one, Equiv.trans_apply, RelIso.coe_fn_toEquiv,\n      Fin.castOrderIso_apply, Fin.cast_mk, Fin.coe_cast]\n    erw [orderedInsertEquiv_succ, orderedInsertEquiv_succ]\n    simp only [orderedInsertPos_sigma, Fin.coe_cast]\n    rw [Fin.succAbove, Fin.succAbove]\n    simp only [Fin.castSucc_mk, Fin.mk_lt_mk, Fin.succ_mk]\n    split\n    \u00b7 rfl\n    \u00b7 rfl\n\n/-- This result is taken from:\n  https://github.com/leanprover/lean4/blob/master/src/Init/Data/List/Nat/InsertIdx.lean\n  with simple modification here to make it run.\n  The file it was taken from is licensed under the Apache License, Version 2.0.\n  and written by Parikshit Khanna, Jeremy Avigad, Leonardo de Moura,\n    Floris van Doorn, Mario Carneiro.\n\n  Once HepLean is updated to a more recent version of Lean this result will be removed.\n-/\ntheorem length_insertIdx' : \u2200 n as, (List.insertIdx n a as).length =\n    if n \u2264 as.length then as.length + 1 else as.length\n  | 0, _ => by simp\n  | n + 1, [] => by rfl\n  | n + 1, a :: as => by\n    simp only [List.insertIdx_succ_cons, List.length_cons, length_insertIdx',\n      Nat.add_le_add_iff_right]\n    split <;> rfl\n\nlemma orderedInsert_eq_insertIdx_orderedInsertPos {I : Type} (le1 : I \u2192 I \u2192 Prop) [DecidableRel le1]\n    (r : List I) (r0 : I) :\n    List.orderedInsert le1 r0 r = List.insertIdx (orderedInsertPos le1 r r0).1 r0 r := by\n  apply List.ext_get\n  \u00b7 simp only [List.orderedInsert_length]\n    rw [List.length_insertIdx]\n    have h1 := orderedInsertPos_lt_length le1 r r0\n    exact (if_pos (Nat.le_of_succ_le_succ h1)).symm\n  intro n h1 h2\n  obtain \u27e8n', hn'\u27e9 := (orderedInsertEquiv le1 r r0).surjective \u27e8n, h1\u27e9\n  rw [\u2190 hn']\n  have hn'' : n = ((orderedInsertEquiv le1 r r0) n').val := by rw [hn']\n  subst hn''\n  rw [\u2190 orderedInsertEquiv_get]\n  simp only [List.length_cons, Function.comp_apply, Equiv.symm_apply_apply, List.get_eq_getElem]\n  match n' with\n  | \u27e80, h0\u27e9 =>\n    simp only [List.getElem_cons_zero, orderedInsertEquiv, List.length_cons, Nat.succ_eq_add_one,\n      OrderIso.toEquiv_symm, Fin.symm_castOrderIso, Fin.zero_eta, Equiv.trans_apply,\n      finExtractOne_apply_eq, Fin.isValue, finExtractOne_symm_inl_apply, RelIso.coe_fn_toEquiv,\n      Fin.castOrderIso_apply, Fin.cast_mk, Fin.eta]\n    rw [List.getElem_insertIdx_self]\n  | \u27e8Nat.succ n', h0\u27e9 =>\n    simp only [Nat.succ_eq_add_one, List.getElem_cons_succ, List.length_cons]\n    have hr := orderedInsertEquiv_succ le1 r r0 n' h0\n    trans (List.insertIdx (\u2191(orderedInsertPos le1 r r0)) r0 r).get\n      \u27e8\u2191((orderedInsertEquiv le1 r r0) \u27e8n' +1, h0\u27e9), h2\u27e9\n    swap\n    \u00b7 rfl\n    rw [Fin.ext_iff] at hr\n    have hx : (\u27e8\u2191((orderedInsertEquiv le1 r r0) \u27e8n' +1, h0\u27e9), h2\u27e9 :\n        Fin (List.insertIdx (\u2191(orderedInsertPos le1 r r0)) r0 r).length) =\n      \u27e8((\u27e8\u2191(orderedInsertPos le1 r r0),\n      orderedInsertPos_lt_length le1 r r0\u27e9 : Fin ((r).length + 1))).succAbove\n      \u27e8n', Nat.succ_lt_succ_iff.mp h0\u27e9, by\n          erw [\u2190 hr]\n          exact h2\u27e9 := by\n      rw [Fin.ext_iff]\n      simp only [List.length_cons]\n      simpa using hr\n    rw [hx]\n    simp only [Fin.succAbove, Fin.castSucc_mk, Fin.mk_lt_mk, Fin.succ_mk, List.get_eq_getElem]\n    by_cases hn' : n' < \u2191(orderedInsertPos le1 r r0)\n    \u00b7 simp only [hn', \u2193reduceIte]\n      erw [List.getElem_insertIdx_of_lt]\n      exact hn'\n    \u00b7 simp only [hn', \u2193reduceIte]\n      rw [List.getElem_insertIdx_of_ge]\n      \u00b7 rfl\n      \u00b7 omega\n\n/-- The equivalence between `Fin l.length \u2243 Fin (List.insertionSort r l).length` induced by the\n  sorting algorithm. -/\ndef insertionSortEquiv {\u03b1 : Type} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [DecidableRel r] : (l : List \u03b1) \u2192\n    Fin l.length \u2243 Fin (List.insertionSort r l).length\n  | [] => Equiv.refl _\n  | a :: l =>\n    (Fin.equivCons (insertionSortEquiv r l)).trans (orderedInsertEquiv r (List.insertionSort r l) a)\n\nlemma insertionSortEquiv_get {\u03b1 : Type} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [DecidableRel r] : (l : List \u03b1) \u2192\n    l.get \u2218 (insertionSortEquiv r l).symm = (List.insertionSort r l).get\n  | [] => by rfl\n  | a :: l => by\n    rw [insertionSortEquiv]\n    change ((a :: l).get \u2218 ((Fin.equivCons (insertionSortEquiv r l))).symm) \u2218\n      (orderedInsertEquiv r (List.insertionSort r l) a).symm = _\n    have hl : (a :: l).get \u2218 ((Fin.equivCons (insertionSortEquiv r l))).symm =\n        (a :: List.insertionSort r l).get := by\n      ext x\n      match x with\n      | \u27e80, h\u27e9 => rfl\n      | \u27e8Nat.succ x, h\u27e9 =>\n        change _ = (List.insertionSort r l).get _\n        rw [\u2190 insertionSortEquiv_get (r := r) l]\n        rfl\n    rw [hl]\n    rw [orderedInsertEquiv_get r (List.insertionSort r l) a]\n    rfl\n\nlemma insertionSortEquiv_congr {\u03b1 : Type} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [DecidableRel r] (l l' : List \u03b1)\n    (h : l = l') : insertionSortEquiv r l = (Fin.castOrderIso (by simp [h])).toEquiv.trans\n      ((insertionSortEquiv r l').trans (Fin.castOrderIso (by simp [h])).toEquiv) := by\n  subst h\n  rfl\n", "theoremStatement": "lemma insertionSort_get_comp_insertionSortEquiv {\u03b1 : Type} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [DecidableRel r]\n    (l : List \u03b1) : (List.insertionSort r l).get \u2218 (insertionSortEquiv r l) = l.get ", "theoremName": "HepLean.List.insertionSort_get_comp_insertionSortEquiv", "fileCreated": {"commit": "7ee877af559718130c44e3983e0bc537df97e6be", "date": "2024-12-10"}, "theoremCreated": {"commit": "dceaab71173d3015b4d43515a4f009c22028eee4", "date": "2024-12-17"}, "file": "HepLean/HepLean/Mathematics/List.lean", "module": "HepLean.Mathematics.List", "jsonFile": "HepLean.Mathematics.List.jsonl", "positionMetadata": {"lineInFile": 637, "tokenPositionInFile": 29021, "theoremPositionInFile": 33}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 31}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [\u2190 insertionSortEquiv_get]\n  funext x\n  simp", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 55}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.Basic\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.Grading\n/-!\n\n# Super Commute\n-/\n\nnamespace FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\nnamespace FieldOpFreeAlgebra\n\n/-!\n\n## The super commutator on the FieldOpFreeAlgebra.\n\n-/\n\nopen FieldStatistic\n\n/-- For a field specification `\ud835\udcd5`, the super commutator `superCommuteF` is defined as the linear\n  map `\ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102] \ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102] \ud835\udcd5.FieldOpFreeAlgebra`\n  which on the lists `\u03c6s` and `\u03c6s'` of `\ud835\udcd5.CrAnFieldOp` gives\n\n  `superCommuteF \u03c6s \u03c6s' = \u03c6s * \u03c6s' - \ud835\udce2(\u03c6s, \u03c6s') \u2022 \u03c6s' * \u03c6s`.\n\n  The notation `[a, b]\u209bca` can be used for `superCommuteF a b`. -/\nnoncomputable def superCommuteF : \ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102] \ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102]\n    \ud835\udcd5.FieldOpFreeAlgebra :=\n  Basis.constr ofCrAnListFBasis \u2102 fun \u03c6s =>\n  Basis.constr ofCrAnListFBasis \u2102 fun \u03c6s' =>\n  ofCrAnListF (\u03c6s ++ \u03c6s') - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnListF (\u03c6s' ++ \u03c6s)\n\n@[inherit_doc superCommuteF]\nscoped[FieldSpecification.FieldOpFreeAlgebra] notation \"[\" \u03c6s \",\" \u03c6s' \"]\u209bca\" => superCommuteF \u03c6s \u03c6s'\n\n/-!\n\n## The super commutator of different types of elements\n\n-/\n\nlemma superCommuteF_ofCrAnListF_ofCrAnListF (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnListF \u03c6s, ofCrAnListF \u03c6s']\u209bca =\n    ofCrAnListF (\u03c6s ++ \u03c6s') - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnListF (\u03c6s' ++ \u03c6s) := by\n  rw [\u2190 ofListBasis_eq_ofList, \u2190 ofListBasis_eq_ofList]\n  simp only [superCommuteF, Basis.constr_basis]\n\nlemma superCommuteF_ofCrAnOpF_ofCrAnOpF (\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnOpF \u03c6, ofCrAnOpF \u03c6']\u209bca =\n    ofCrAnOpF \u03c6 * ofCrAnOpF \u03c6' - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 ofCrAnOpF \u03c6' * ofCrAnOpF \u03c6 := by\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton]\n  rw [superCommuteF_ofCrAnListF_ofCrAnListF, ofCrAnListF_append]\n  congr\n  rw [ofCrAnListF_append]\n  rw [FieldStatistic.ofList_singleton, FieldStatistic.ofList_singleton, smul_mul_assoc]\n\nlemma superCommuteF_ofCrAnListF_ofFieldOpFsList (\u03c6cas : List \ud835\udcd5.CrAnFieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [ofCrAnListF \u03c6cas, ofFieldOpListF \u03c6s]\u209bca = ofCrAnListF \u03c6cas * ofFieldOpListF \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6cas, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpListF \u03c6s * ofCrAnListF \u03c6cas := by\n  conv_lhs => rw [ofFieldOpListF_sum]\n  rw [map_sum]\n  conv_lhs =>\n    enter [2, x]\n    rw [superCommuteF_ofCrAnListF_ofCrAnListF, CrAnSection.statistics_eq_state_statistics,\n      ofCrAnListF_append, ofCrAnListF_append]\n  rw [Finset.sum_sub_distrib, \u2190 Finset.mul_sum, \u2190 Finset.smul_sum,\n    \u2190 Finset.sum_mul, \u2190 ofFieldOpListF_sum]\n  simp\n\nlemma superCommuteF_ofFieldOpListF_ofFieldOpFsList (\u03c6 : List \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [ofFieldOpListF \u03c6, ofFieldOpListF \u03c6s]\u209bca = ofFieldOpListF \u03c6 * ofFieldOpListF \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpListF \u03c6s * ofFieldOpListF \u03c6 := by\n  conv_lhs => rw [ofFieldOpListF_sum]\n  simp only [map_sum, LinearMap.coeFn_sum, Finset.sum_apply, instCommGroup.eq_1,\n    Algebra.smul_mul_assoc]\n  conv_lhs =>\n    enter [2, x]\n    rw [superCommuteF_ofCrAnListF_ofFieldOpFsList]\n  simp only [instCommGroup.eq_1, CrAnSection.statistics_eq_state_statistics,\n    Algebra.smul_mul_assoc, Finset.sum_sub_distrib]\n  rw [\u2190 Finset.sum_mul, \u2190 Finset.smul_sum, \u2190 Finset.mul_sum, \u2190 ofFieldOpListF_sum]\n\nlemma superCommuteF_ofFieldOpF_ofFieldOpFsList (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [ofFieldOpF \u03c6, ofFieldOpListF \u03c6s]\u209bca = ofFieldOpF \u03c6 * ofFieldOpListF \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpListF \u03c6s * ofFieldOpF \u03c6 := by\n  rw [\u2190 ofFieldOpListF_singleton, superCommuteF_ofFieldOpListF_ofFieldOpFsList,\n    ofFieldOpListF_singleton]\n  simp\n\nlemma superCommuteF_ofFieldOpListF_ofFieldOpF (\u03c6s : List \ud835\udcd5.FieldOp) (\u03c6 : \ud835\udcd5.FieldOp) :\n    [ofFieldOpListF \u03c6s, ofFieldOpF \u03c6]\u209bca = ofFieldOpListF \u03c6s * ofFieldOpF \u03c6 -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6) \u2022 ofFieldOpF \u03c6 * ofFieldOpListF \u03c6s := by\n  rw [\u2190 ofFieldOpListF_singleton, superCommuteF_ofFieldOpListF_ofFieldOpFsList,\n    ofFieldOpListF_singleton]\n  simp\n\nlemma superCommuteF_anPartF_crPartF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [anPartF \u03c6, crPartF \u03c6']\u209bca = anPartF \u03c6 * crPartF \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 crPartF \u03c6' * anPartF \u03c6 := by\n  match \u03c6, \u03c6' with\n  | FieldOp.inAsymp \u03c6, _ =>\n    simp\n  | _, FieldOp.outAsymp \u03c6 =>\n    simp only [crPartF_posAsymp, map_zero, mul_zero, instCommGroup.eq_1, smul_zero, zero_mul,\n      sub_self]\n  | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n    simp only [anPartF_position, crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.outAsymp \u03c6, FieldOp.position \u03c6' =>\n    simp only [anPartF_posAsymp, crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.position \u03c6, FieldOp.inAsymp \u03c6' =>\n    simp only [anPartF_position, crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp only [List.singleton_append, instCommGroup.eq_1, crAnStatistics,\n      FieldStatistic.ofList_singleton, Function.comp_apply, crAnFieldOpToFieldOp_prod, \u2190\n      ofCrAnListF_append]\n  | FieldOp.outAsymp \u03c6, FieldOp.inAsymp \u03c6' =>\n    simp only [anPartF_posAsymp, crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n\nlemma superCommuteF_crPartF_anPartF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [crPartF \u03c6, anPartF \u03c6']\u209bca = crPartF \u03c6 * anPartF \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 anPartF \u03c6' * crPartF \u03c6 := by\n    match \u03c6, \u03c6' with\n    | FieldOp.outAsymp \u03c6, _ =>\n    simp only [crPartF_posAsymp, map_zero, LinearMap.zero_apply, zero_mul, instCommGroup.eq_1,\n      mul_zero, sub_self]\n    | _, FieldOp.inAsymp \u03c6 =>\n    simp only [anPartF_negAsymp, map_zero, mul_zero, instCommGroup.eq_1, smul_zero, zero_mul,\n      sub_self]\n    | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n    simp only [crPartF_position, anPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n    | FieldOp.position \u03c6, FieldOp.outAsymp \u03c6' =>\n    simp only [crPartF_position, anPartF_posAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n    | FieldOp.inAsymp \u03c6, FieldOp.position \u03c6' =>\n    simp only [crPartF_negAsymp, anPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n    | FieldOp.inAsymp \u03c6, FieldOp.outAsymp \u03c6' =>\n    simp only [crPartF_negAsymp, anPartF_posAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n\nlemma superCommuteF_crPartF_crPartF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [crPartF \u03c6, crPartF \u03c6']\u209bca = crPartF \u03c6 * crPartF \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 crPartF \u03c6' * crPartF \u03c6 := by\n  match \u03c6, \u03c6' with\n  | FieldOp.outAsymp \u03c6, _ =>\n  simp only [crPartF_posAsymp, map_zero, LinearMap.zero_apply, zero_mul, instCommGroup.eq_1,\n    mul_zero, sub_self]\n  | _, FieldOp.outAsymp \u03c6 =>\n  simp only [crPartF_posAsymp, map_zero, mul_zero, instCommGroup.eq_1, smul_zero, zero_mul,\n    sub_self]\n  | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n  simp only [crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.position \u03c6, FieldOp.inAsymp \u03c6' =>\n  simp only [crPartF_position, crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.inAsymp \u03c6, FieldOp.position \u03c6' =>\n  simp only [crPartF_negAsymp, crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.inAsymp \u03c6, FieldOp.inAsymp \u03c6' =>\n  simp only [crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp [crAnStatistics, \u2190 ofCrAnListF_append]\n\nlemma superCommuteF_anPartF_anPartF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [anPartF \u03c6, anPartF \u03c6']\u209bca =\n    anPartF \u03c6 * anPartF \u03c6' - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 anPartF \u03c6' * anPartF \u03c6 := by\n  match \u03c6, \u03c6' with\n  | FieldOp.inAsymp \u03c6, _ =>\n    simp\n  | _, FieldOp.inAsymp \u03c6 =>\n    simp\n  | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n    simp only [anPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.position \u03c6, FieldOp.outAsymp \u03c6' =>\n    simp only [anPartF_position, anPartF_posAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.outAsymp \u03c6, FieldOp.position \u03c6' =>\n    simp only [anPartF_posAsymp, anPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.outAsymp \u03c6, FieldOp.outAsymp \u03c6' =>\n    simp only [anPartF_posAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n\nlemma superCommuteF_crPartF_ofFieldOpListF (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [crPartF \u03c6, ofFieldOpListF \u03c6s]\u209bca =\n    crPartF \u03c6 * ofFieldOpListF \u03c6s - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpListF \u03c6s *\n    crPartF \u03c6 := by\n  match \u03c6 with\n  | FieldOp.inAsymp \u03c6 =>\n    simp only [crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofFieldOpFsList]\n    simp [crAnStatistics]\n  | FieldOp.position \u03c6 =>\n    simp only [crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofFieldOpFsList]\n    simp [crAnStatistics]\n  | FieldOp.outAsymp \u03c6 =>\n    simp\n\nlemma superCommuteF_anPartF_ofFieldOpListF (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [anPartF \u03c6, ofFieldOpListF \u03c6s]\u209bca =\n    anPartF \u03c6 * ofFieldOpListF \u03c6s - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022\n    ofFieldOpListF \u03c6s * anPartF \u03c6 := by\n  match \u03c6 with\n  | FieldOp.inAsymp \u03c6 =>\n    simp\n  | FieldOp.position \u03c6 =>\n    simp only [anPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofFieldOpFsList]\n    simp [crAnStatistics]\n  | FieldOp.outAsymp \u03c6 =>\n    simp only [anPartF_posAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofFieldOpFsList]\n    simp [crAnStatistics]\n\nlemma superCommuteF_crPartF_ofFieldOpF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [crPartF \u03c6, ofFieldOpF \u03c6']\u209bca =\n    crPartF \u03c6 * ofFieldOpF \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 ofFieldOpF \u03c6' * crPartF \u03c6 := by\n  rw [\u2190 ofFieldOpListF_singleton, superCommuteF_crPartF_ofFieldOpListF]\n  simp\n\nlemma superCommuteF_anPartF_ofFieldOpF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [anPartF \u03c6, ofFieldOpF \u03c6']\u209bca =\n    anPartF \u03c6 * ofFieldOpF \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 ofFieldOpF \u03c6' * anPartF \u03c6 := by\n  rw [\u2190 ofFieldOpListF_singleton, superCommuteF_anPartF_ofFieldOpListF]\n  simp\n\n/-!\n\n## Mul equal superCommuteF\n\nLemmas which rewrite a multiplication of two elements of the algebra as their commuted\nmultiplication with a sign plus the super commutator.\n\n-/\nlemma ofCrAnListF_mul_ofCrAnListF_eq_superCommuteF (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnListF \u03c6s * ofCrAnListF \u03c6s' = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnListF \u03c6s' * ofCrAnListF \u03c6s\n    + [ofCrAnListF \u03c6s, ofCrAnListF \u03c6s']\u209bca := by\n  rw [superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp [ofCrAnListF_append]\n\nlemma ofCrAnOpF_mul_ofCrAnListF_eq_superCommuteF (\u03c6 : \ud835\udcd5.CrAnFieldOp) (\u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnOpF \u03c6 * ofCrAnListF \u03c6s' = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnListF \u03c6s' * ofCrAnOpF \u03c6\n    + [ofCrAnOpF \u03c6, ofCrAnListF \u03c6s']\u209bca := by\n  rw [\u2190 ofCrAnListF_singleton, ofCrAnListF_mul_ofCrAnListF_eq_superCommuteF]\n  simp\n\nlemma ofFieldOpListF_mul_ofFieldOpListF_eq_superCommuteF (\u03c6s \u03c6s' : List \ud835\udcd5.FieldOp) :\n    ofFieldOpListF \u03c6s * ofFieldOpListF \u03c6s' =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofFieldOpListF \u03c6s' * ofFieldOpListF \u03c6s\n    + [ofFieldOpListF \u03c6s, ofFieldOpListF \u03c6s']\u209bca := by\n  rw [superCommuteF_ofFieldOpListF_ofFieldOpFsList]\n  simp\n\nlemma ofFieldOpF_mul_ofFieldOpListF_eq_superCommuteF (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s' : List \ud835\udcd5.FieldOp) :\n    ofFieldOpF \u03c6 * ofFieldOpListF \u03c6s' = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofFieldOpListF \u03c6s' * ofFieldOpF \u03c6\n    + [ofFieldOpF \u03c6, ofFieldOpListF \u03c6s']\u209bca := by\n  rw [superCommuteF_ofFieldOpF_ofFieldOpFsList]\n  simp\n\nlemma ofFieldOpListF_mul_ofFieldOpF_eq_superCommuteF (\u03c6s : List \ud835\udcd5.FieldOp) (\u03c6 : \ud835\udcd5.FieldOp) :\n    ofFieldOpListF \u03c6s * ofFieldOpF \u03c6 = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6) \u2022 ofFieldOpF \u03c6 * ofFieldOpListF \u03c6s\n    + [ofFieldOpListF \u03c6s, ofFieldOpF \u03c6]\u209bca := by\n  rw [superCommuteF_ofFieldOpListF_ofFieldOpF]\n  simp\n\nlemma crPartF_mul_anPartF_eq_superCommuteF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    crPartF \u03c6 * anPartF \u03c6' =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 anPartF \u03c6' * crPartF \u03c6 +\n    [crPartF \u03c6, anPartF \u03c6']\u209bca := by\n  rw [superCommuteF_crPartF_anPartF]\n  simp\n\nlemma anPartF_mul_crPartF_eq_superCommuteF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    anPartF \u03c6 * crPartF \u03c6' =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022\n    crPartF \u03c6' * anPartF \u03c6 +\n    [anPartF \u03c6, crPartF \u03c6']\u209bca := by\n  rw [superCommuteF_anPartF_crPartF]\n  simp\n\nlemma crPartF_mul_crPartF_eq_superCommuteF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    crPartF \u03c6 * crPartF \u03c6' =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 crPartF \u03c6' * crPartF \u03c6 +\n    [crPartF \u03c6, crPartF \u03c6']\u209bca := by\n  rw [superCommuteF_crPartF_crPartF]\n  simp\n\nlemma anPartF_mul_anPartF_eq_superCommuteF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    anPartF \u03c6 * anPartF \u03c6' = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 anPartF \u03c6' * anPartF \u03c6 +\n    [anPartF \u03c6, anPartF \u03c6']\u209bca := by\n  rw [superCommuteF_anPartF_anPartF]\n  simp\n\nlemma ofCrAnListF_mul_ofFieldOpListF_eq_superCommuteF (\u03c6s : List \ud835\udcd5.CrAnFieldOp)\n    (\u03c6s' : List \ud835\udcd5.FieldOp) : ofCrAnListF \u03c6s * ofFieldOpListF \u03c6s' =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofFieldOpListF \u03c6s' * ofCrAnListF \u03c6s\n    + [ofCrAnListF \u03c6s, ofFieldOpListF \u03c6s']\u209bca := by\n  rw [superCommuteF_ofCrAnListF_ofFieldOpFsList]\n  simp\n\n/-!\n\n## Symmetry of the super commutator.\n\n-/\n\nlemma superCommuteF_ofCrAnListF_ofCrAnListF_symm (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnListF \u03c6s, ofCrAnListF \u03c6s']\u209bca =\n    (- \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s')) \u2022 [ofCrAnListF \u03c6s', ofCrAnListF \u03c6s]\u209bca := by\n  rw [superCommuteF_ofCrAnListF_ofCrAnListF, superCommuteF_ofCrAnListF_ofCrAnListF, smul_sub]\n  simp only [instCommGroup.eq_1, neg_smul, sub_neg_eq_add]\n  rw [smul_smul]\n  conv_rhs =>\n    rhs\n    rw [exchangeSign_symm, exchangeSign_mul_self]\n  simp only [one_smul]\n  abel\n\nlemma superCommuteF_ofCrAnOpF_ofCrAnOpF_symm (\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnOpF \u03c6, ofCrAnOpF \u03c6']\u209bca =\n    (- \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6')) \u2022 [ofCrAnOpF \u03c6', ofCrAnOpF \u03c6]\u209bca := by\n  rw [superCommuteF_ofCrAnOpF_ofCrAnOpF, superCommuteF_ofCrAnOpF_ofCrAnOpF]\n  rw [smul_sub]\n  simp only [instCommGroup.eq_1, Algebra.smul_mul_assoc, neg_smul, sub_neg_eq_add]\n  rw [smul_smul]\n  conv_rhs =>\n    rhs\n    rw [exchangeSign_symm, exchangeSign_mul_self]\n  simp only [one_smul]\n  abel\n\n/-!\n\n## Splitting the super commutator on lists into sums.\n\n-/\n\nlemma superCommuteF_ofCrAnListF_ofCrAnListF_cons (\u03c6 : \ud835\udcd5.CrAnFieldOp) (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnListF \u03c6s, ofCrAnListF (\u03c6 :: \u03c6s')]\u209bca =\n    [ofCrAnListF \u03c6s, ofCrAnOpF \u03c6]\u209bca * ofCrAnListF \u03c6s' +\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6)\n    \u2022 ofCrAnOpF \u03c6 * [ofCrAnListF \u03c6s, ofCrAnListF \u03c6s']\u209bca := by\n  rw [superCommuteF_ofCrAnListF_ofCrAnListF]\n  conv_rhs =>\n    lhs\n    rw [\u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF, sub_mul,\n      \u2190 ofCrAnListF_append]\n    rhs\n    rw [FieldStatistic.ofList_singleton, ofCrAnListF_append, ofCrAnListF_singleton, smul_mul_assoc,\n      mul_assoc, \u2190 ofCrAnListF_append]\n  conv_rhs =>\n    rhs\n    rw [superCommuteF_ofCrAnListF_ofCrAnListF, mul_sub, smul_mul_assoc]\n  simp only [instCommGroup.eq_1, List.cons_append, List.append_assoc, List.nil_append,\n    Algebra.mul_smul_comm, Algebra.smul_mul_assoc, sub_add_sub_cancel, sub_right_inj]\n  rw [\u2190 ofCrAnListF_cons, smul_smul, FieldStatistic.ofList_cons_eq_mul]\n  simp only [instCommGroup, map_mul, mul_comm]\n\nlemma superCommuteF_ofCrAnListF_ofFieldOpListF_cons (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.CrAnFieldOp)\n    (\u03c6s' : List \ud835\udcd5.FieldOp) : [ofCrAnListF \u03c6s, ofFieldOpListF (\u03c6 :: \u03c6s')]\u209bca =\n    [ofCrAnListF \u03c6s, ofFieldOpF \u03c6]\u209bca * ofFieldOpListF \u03c6s' +\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6) \u2022 ofFieldOpF \u03c6 * [ofCrAnListF \u03c6s, ofFieldOpListF \u03c6s']\u209bca := by\n  rw [superCommuteF_ofCrAnListF_ofFieldOpFsList]\n  conv_rhs =>\n    lhs\n    rw [\u2190 ofFieldOpListF_singleton, superCommuteF_ofCrAnListF_ofFieldOpFsList, sub_mul, mul_assoc,\n      \u2190 ofFieldOpListF_append]\n    rhs\n    rw [FieldStatistic.ofList_singleton, ofFieldOpListF_singleton, smul_mul_assoc,\n      smul_mul_assoc, mul_assoc]\n  conv_rhs =>\n    rhs\n    rw [superCommuteF_ofCrAnListF_ofFieldOpFsList, mul_sub, smul_mul_assoc]\n  simp only [instCommGroup, Algebra.smul_mul_assoc, List.singleton_append, Algebra.mul_smul_comm,\n    sub_add_sub_cancel, sub_right_inj]\n  rw [ofFieldOpListF_cons, mul_assoc, smul_smul, FieldStatistic.ofList_cons_eq_mul]\n  simp [mul_comm]\n\n/--\nFor a field specification `\ud835\udcd5`, and two lists `\u03c6s = \u03c6\u2080\u2026\u03c6\u2099` and `\u03c6s'` of `\ud835\udcd5.CrAnFieldOp`\nthe following super commutation relation holds:\n\n`[\u03c6s', \u03c6\u2080\u2026\u03c6\u2099]\u209bca = \u2211 i, \ud835\udce2(\u03c6s', \u03c6\u2080\u2026\u03c6\u1d62\u208b\u2081) \u2022 \u03c6\u2080\u2026\u03c6\u1d62\u208b\u2081 * [\u03c6s', \u03c6\u1d62]\u209bca * \u03c6\u1d62\u208a\u2081 \u2026 \u03c6\u2099`\n\nThe proof of this relation is via induction on the length of `\u03c6s`.\n-/\nlemma superCommuteF_ofCrAnListF_ofCrAnListF_eq_sum (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    (\u03c6s' : List \ud835\udcd5.CrAnFieldOp) \u2192 [ofCrAnListF \u03c6s, ofCrAnListF \u03c6s']\u209bca =\n    \u2211 (n : Fin \u03c6s'.length), \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s'.take n) \u2022\n    ofCrAnListF (\u03c6s'.take n) * [ofCrAnListF \u03c6s, ofCrAnOpF (\u03c6s'.get n)]\u209bca *\n    ofCrAnListF (\u03c6s'.drop (n + 1))\n  | [] => by\n    simp [\u2190 ofCrAnListF_nil, superCommuteF_ofCrAnListF_ofCrAnListF]\n  | \u03c6 :: \u03c6s' => by\n    rw [superCommuteF_ofCrAnListF_ofCrAnListF_cons,\n      superCommuteF_ofCrAnListF_ofCrAnListF_eq_sum \u03c6s \u03c6s']\n    conv_rhs => erw [Fin.sum_univ_succ]\n    congr 1\n    \u00b7 simp\n    \u00b7 simp [Finset.mul_sum, smul_smul, ofCrAnListF_cons, mul_assoc,\n        FieldStatistic.ofList_cons_eq_mul, mul_comm]\n\nlemma superCommuteF_ofCrAnListF_ofFieldOpListF_eq_sum (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    (\u03c6s' : List \ud835\udcd5.FieldOp) \u2192\n    [ofCrAnListF \u03c6s, ofFieldOpListF \u03c6s']\u209bca =\n    \u2211 (n : Fin \u03c6s'.length), \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s'.take n) \u2022\n      ofFieldOpListF (\u03c6s'.take n) * [ofCrAnListF \u03c6s, ofFieldOpF (\u03c6s'.get n)]\u209bca *\n      ofFieldOpListF (\u03c6s'.drop (n + 1))\n  | [] => by\n    simp only [superCommuteF_ofCrAnListF_ofFieldOpFsList, instCommGroup, ofList_empty,\n      exchangeSign_bosonic, one_smul, List.length_nil, Finset.univ_eq_empty, List.take_nil,\n      List.get_eq_getElem, List.drop_nil, Finset.sum_empty]\n    simp\n  | \u03c6 :: \u03c6s' => by\n    rw [superCommuteF_ofCrAnListF_ofFieldOpListF_cons,\n      superCommuteF_ofCrAnListF_ofFieldOpListF_eq_sum \u03c6s \u03c6s']\n    conv_rhs => erw [Fin.sum_univ_succ]\n    congr 1\n    \u00b7 simp\n    \u00b7 simp [Finset.mul_sum, smul_smul, ofFieldOpListF_cons, mul_assoc,\n        FieldStatistic.ofList_cons_eq_mul, mul_comm]\n\nlemma summerCommute_jacobi_ofCrAnListF (\u03c6s1 \u03c6s2 \u03c6s3 : List \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnListF \u03c6s1, [ofCrAnListF \u03c6s2, ofCrAnListF \u03c6s3]\u209bca]\u209bca =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s1, \ud835\udcd5 |>\u209b \u03c6s3) \u2022\n    (- \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s2, \ud835\udcd5 |>\u209b \u03c6s3) \u2022 [ofCrAnListF \u03c6s3, [ofCrAnListF \u03c6s1, ofCrAnListF \u03c6s2]\u209bca]\u209bca -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s1, \ud835\udcd5 |>\u209b \u03c6s2) \u2022 [ofCrAnListF \u03c6s2, [ofCrAnListF \u03c6s3, ofCrAnListF \u03c6s1]\u209bca]\u209bca) := by\n  repeat rw [superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp only [instCommGroup, map_sub, map_smul, neg_smul]\n  repeat rw [superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp only [instCommGroup.eq_1, ofList_append_eq_mul, List.append_assoc]\n  by_cases h1 : (\ud835\udcd5 |>\u209b \u03c6s1) = bosonic <;>\n    by_cases h2 : (\ud835\udcd5 |>\u209b \u03c6s2) = bosonic <;>\n    by_cases h3 : (\ud835\udcd5 |>\u209b \u03c6s3) = bosonic\n  \u00b7 simp only [h1, h2, h3, mul_self, bosonic_exchangeSign, one_smul, exchangeSign_bosonic, neg_sub]\n    abel\n  \u00b7 simp only [h1, h2, bosonic_exchangeSign, one_smul, mul_bosonic, mul_self, map_one,\n    exchangeSign_bosonic, neg_sub]\n    abel\n  \u00b7 simp only [h1, h3, mul_bosonic, bosonic_exchangeSign, one_smul, exchangeSign_bosonic, neg_sub,\n    mul_self, map_one]\n    abel\n  \u00b7 simp only [neq_bosonic_iff_eq_fermionic] at h1 h2 h3\n    simp only [h1, h2, h3, mul_self, bosonic_exchangeSign, one_smul,\n      fermionic_exchangeSign_fermionic, neg_smul, neg_sub, bosonic_mul_fermionic, sub_neg_eq_add,\n      mul_bosonic, smul_add, exchangeSign_bosonic]\n    abel\n  \u00b7 simp only [neq_bosonic_iff_eq_fermionic] at h1 h2 h3\n    simp only [h1, h2, h3, mul_self, map_one, one_smul, exchangeSign_bosonic, mul_bosonic,\n      bosonic_exchangeSign, bosonic_mul_fermionic, neg_sub]\n    abel\n  \u00b7 simp only [neq_bosonic_iff_eq_fermionic] at h1 h2 h3\n    simp only [h1, h2, h3, bosonic_mul_fermionic, fermionic_exchangeSign_fermionic, neg_smul,\n      one_smul, sub_neg_eq_add, bosonic_exchangeSign, mul_bosonic, smul_add, exchangeSign_bosonic,\n      neg_sub, mul_self]\n    abel\n  \u00b7 simp only [neq_bosonic_iff_eq_fermionic] at h1 h2 h3\n    simp only [h1, h2, h3, mul_bosonic, fermionic_exchangeSign_fermionic, neg_smul, one_smul,\n      sub_neg_eq_add, exchangeSign_bosonic, bosonic_mul_fermionic, smul_add, mul_self,\n      bosonic_exchangeSign, neg_sub]\n    abel\n  \u00b7 simp only [neq_bosonic_iff_eq_fermionic] at h1 h2 h3\n    simp only [h1, h2, h3, mul_self, map_one, one_smul, fermionic_exchangeSign_fermionic, neg_smul,\n      neg_sub]\n    abel\n\n/-!\n\n## Interaction with grading.\n\n-/\n\nlemma superCommuteF_grade {a b : \ud835\udcd5.FieldOpFreeAlgebra} {f1 f2 : FieldStatistic}\n    (ha : a \u2208 statisticSubmodule f1) (hb : b \u2208 statisticSubmodule f2) :\n    [a, b]\u209bca \u2208 statisticSubmodule (f1 + f2) := by\n  let p (a2 : \ud835\udcd5.FieldOpFreeAlgebra) (hx : a2 \u2208 statisticSubmodule f2) : Prop :=\n    [a, a2]\u209bca \u2208 statisticSubmodule (f1 + f2)\n  change p b hb\n  apply Submodule.span_induction (p := p)\n  \u00b7 intro x hx\n    obtain \u27e8\u03c6s, rfl, h\u03c6s\u27e9 := hx\n    simp only [add_eq_mul, instCommGroup, p]\n    let p (a2 : \ud835\udcd5.FieldOpFreeAlgebra) (hx : a2 \u2208 statisticSubmodule f1) : Prop :=\n        [a2, ofCrAnListF \u03c6s]\u209bca \u2208 statisticSubmodule (f1 + f2)\n    change p a ha\n    apply Submodule.span_induction (p := p)\n    \u00b7 intro x hx\n      obtain \u27e8\u03c6s', rfl, h\u03c6s'\u27e9 := hx\n      simp only [add_eq_mul, instCommGroup, p]\n      rw [superCommuteF_ofCrAnListF_ofCrAnListF]\n      apply Submodule.sub_mem _\n      \u00b7 apply ofCrAnListF_mem_statisticSubmodule_of\n        rw [ofList_append_eq_mul, h\u03c6s, h\u03c6s']\n      \u00b7 apply Submodule.smul_mem\n        apply ofCrAnListF_mem_statisticSubmodule_of\n        rw [ofList_append_eq_mul, h\u03c6s, h\u03c6s']\n        rw [mul_comm]\n    \u00b7 simp [p]\n    \u00b7 intro x y hx hy hp1 hp2\n      simp only [add_eq_mul, instCommGroup, map_add, LinearMap.add_apply, p]\n      exact Submodule.add_mem _ hp1 hp2\n    \u00b7 intro c x hx hp1\n      simp only [add_eq_mul, instCommGroup, map_smul, LinearMap.smul_apply, p]\n      exact Submodule.smul_mem _ c hp1\n    \u00b7 exact ha\n  \u00b7 simp [p]\n  \u00b7 intro x y hx hy hp1 hp2\n    simp only [add_eq_mul, instCommGroup, map_add, p]\n    exact Submodule.add_mem _ hp1 hp2\n  \u00b7 intro c x hx hp1\n    simp only [add_eq_mul, instCommGroup, map_smul, p]\n    exact Submodule.smul_mem _ c hp1\n  \u00b7 exact hb\n\nlemma superCommuteF_bosonic_bosonic {a b : \ud835\udcd5.FieldOpFreeAlgebra}\n    (ha : a \u2208 statisticSubmodule bosonic) (hb : b \u2208 statisticSubmodule bosonic) :\n    [a, b]\u209bca = a * b - b * a := by\n  let p (a2 : \ud835\udcd5.FieldOpFreeAlgebra) (hx : a2 \u2208 statisticSubmodule bosonic) : Prop :=\n    [a, a2]\u209bca = a * a2 - a2 * a\n  change p b hb\n  apply Submodule.span_induction (p := p)\n  \u00b7 intro x hx\n    obtain \u27e8\u03c6s, rfl, h\u03c6s\u27e9 := hx\n    let p (a2 : \ud835\udcd5.FieldOpFreeAlgebra) (hx : a2 \u2208 statisticSubmodule bosonic) : Prop :=\n        [a2, ofCrAnListF \u03c6s]\u209bca = a2 * ofCrAnListF \u03c6s - ofCrAnListF \u03c6s * a2\n    change p a ha\n    apply Submodule.span_induction (p := p)\n    \u00b7 intro x hx\n      obtain \u27e8\u03c6s', rfl, h\u03c6s'\u27e9 := hx\n      simp only [p]\n      rw [superCommuteF_ofCrAnListF_ofCrAnListF]\n      simp [h\u03c6s, ofCrAnListF_append]\n    \u00b7 simp [p]\n    \u00b7 intro x y hx hy hp1 hp2\n      simp_all only [p, map_add, LinearMap.add_apply, add_mul, mul_add]\n      abel\n    \u00b7 intro c x hx hp1\n      simp_all [p, smul_sub]\n    \u00b7 exact ha\n  \u00b7 simp [p]\n  \u00b7 intro x y hx hy hp1 hp2\n    simp_all only [p, map_add, mul_add, add_mul]\n    abel\n  \u00b7 intro c x hx hp1\n    simp_all [p, smul_sub]\n  \u00b7 exact hb\n\nlemma superCommuteF_bosonic_fermionic {a b : \ud835\udcd5.FieldOpFreeAlgebra}\n    (ha : a \u2208 statisticSubmodule bosonic) (hb : b \u2208 statisticSubmodule fermionic) :\n    [a, b]\u209bca = a * b - b * a := by\n  let p (a2 : \ud835\udcd5.FieldOpFreeAlgebra) (hx : a2 \u2208 statisticSubmodule fermionic) : Prop :=\n    [a, a2]\u209bca = a * a2 - a2 * a\n  change p b hb\n  apply Submodule.span_induction (p := p)\n  \u00b7 intro x hx\n    obtain \u27e8\u03c6s, rfl, h\u03c6s\u27e9 := hx\n    let p (a2 : \ud835\udcd5.FieldOpFreeAlgebra) (hx : a2 \u2208 statisticSubmodule bosonic) : Prop :=\n        [a2, ofCrAnListF \u03c6s]\u209bca = a2 * ofCrAnListF \u03c6s - ofCrAnListF \u03c6s * a2\n    change p a ha\n    apply Submodule.span_induction (p := p)\n    \u00b7 intro x hx\n      obtain \u27e8\u03c6s', rfl, h\u03c6s'\u27e9 := hx\n      simp only [p]\n      rw [superCommuteF_ofCrAnListF_ofCrAnListF]\n      simp [h\u03c6s, h\u03c6s', ofCrAnListF_append]\n    \u00b7 simp [p]\n    \u00b7 intro x y hx hy hp1 hp2\n      simp_all only [p, map_add, LinearMap.add_apply, add_mul, mul_add]\n      abel\n    \u00b7 intro c x hx hp1\n      simp_all [p, smul_sub]\n    \u00b7 exact ha\n  \u00b7 simp [p]\n  \u00b7 intro x y hx hy hp1 hp2\n    simp_all only [p, map_add, mul_add, add_mul]\n    abel\n  \u00b7 intro c x hx hp1\n    simp_all [p, smul_sub]\n  \u00b7 exact hb\n\nlemma superCommuteF_fermionic_bonsonic {a b : \ud835\udcd5.FieldOpFreeAlgebra}\n    (ha : a \u2208 statisticSubmodule fermionic) (hb : b \u2208 statisticSubmodule bosonic) :\n    [a, b]\u209bca = a * b - b * a := by\n  let p (a2 : \ud835\udcd5.FieldOpFreeAlgebra) (hx : a2 \u2208 statisticSubmodule bosonic) : Prop :=\n    [a, a2]\u209bca = a * a2 - a2 * a\n  change p b hb\n  apply Submodule.span_induction (p := p)\n  \u00b7 intro x hx\n    obtain \u27e8\u03c6s, rfl, h\u03c6s\u27e9 := hx\n    let p (a2 : \ud835\udcd5.FieldOpFreeAlgebra) (hx : a2 \u2208 statisticSubmodule fermionic) : Prop :=\n        [a2, ofCrAnListF \u03c6s]\u209bca = a2 * ofCrAnListF \u03c6s - ofCrAnListF \u03c6s * a2\n    change p a ha\n    apply Submodule.span_induction (p := p)\n    \u00b7 intro x hx\n      obtain \u27e8\u03c6s', rfl, h\u03c6s'\u27e9 := hx\n      simp only [p]\n      rw [superCommuteF_ofCrAnListF_ofCrAnListF]\n      simp [h\u03c6s, h\u03c6s', ofCrAnListF_append]\n    \u00b7 simp [p]\n    \u00b7 intro x y hx hy hp1 hp2\n      simp_all only [p, map_add, LinearMap.add_apply, add_mul, mul_add]\n      abel\n    \u00b7 intro c x hx hp1\n      simp_all [p, smul_sub]\n    \u00b7 exact ha\n  \u00b7 simp [p]\n  \u00b7 intro x y hx hy hp1 hp2\n    simp_all only [map_add, mul_add, add_mul, p]\n    abel\n  \u00b7 intro c x hx hp1\n    simp_all [p, smul_sub]\n  \u00b7 exact hb\n\nlemma superCommuteF_bonsonic {a b : \ud835\udcd5.FieldOpFreeAlgebra} (hb : b \u2208 statisticSubmodule bosonic) :\n    [a, b]\u209bca = a * b - b * a := by\n  rw [\u2190 bosonicProjF_add_fermionicProjF a]\n  simp only [map_add, LinearMap.add_apply]\n  rw [superCommuteF_bosonic_bosonic (by simp) hb, superCommuteF_fermionic_bonsonic (by simp) hb]\n  simp only [add_mul, mul_add]\n  abel\n\nlemma bosonic_superCommuteF {a b : \ud835\udcd5.FieldOpFreeAlgebra} (ha : a \u2208 statisticSubmodule bosonic) :\n    [a, b]\u209bca = a * b - b * a := by\n  rw [\u2190 bosonicProjF_add_fermionicProjF b]\n  simp only [map_add, LinearMap.add_apply]\n  rw [superCommuteF_bosonic_bosonic ha (by simp), superCommuteF_bosonic_fermionic ha (by simp)]\n  simp only [add_mul, mul_add]\n  abel\n\nlemma superCommuteF_bonsonic_symm {a b : \ud835\udcd5.FieldOpFreeAlgebra}\n    (hb : b \u2208 statisticSubmodule bosonic) :\n    [a, b]\u209bca = - [b, a]\u209bca := by\n  rw [bosonic_superCommuteF hb, superCommuteF_bonsonic hb]\n  simp\n\n", "theoremStatement": "lemma bonsonic_superCommuteF_symm {a b : \ud835\udcd5.FieldOpFreeAlgebra}\n    (ha : a \u2208 statisticSubmodule bosonic) :\n    [a, b]\u209bca = - [b, a]\u209bca ", "theoremName": "FieldSpecification.FieldOpFreeAlgebra.bonsonic_superCommuteF_symm", "fileCreated": {"commit": "ea6e12829370d9630a7e65200c8349e9086c05ba", "date": "2025-02-03"}, "theoremCreated": {"commit": "289050c8295ee3d301068a0e283ebe00807a241c", "date": "2025-01-30"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpFreeAlgebra/SuperCommute.lean", "module": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.SuperCommute", "jsonFile": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.SuperCommute.jsonl", "positionMetadata": {"lineInFile": 665, "tokenPositionInFile": 28559, "theoremPositionInFile": 38}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 8, "numPremises": 59}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [bosonic_superCommuteF ha, superCommuteF_bonsonic ha]\n  simp", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 71}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.WickContraction.TimeContract\nimport HepLean.PerturbationTheory.WickContraction.StaticContract\nimport HepLean.PerturbationTheory.FieldOpAlgebra.TimeContraction\nimport HepLean.PerturbationTheory.WickContraction.SubContraction\nimport HepLean.PerturbationTheory.WickContraction.Singleton\n\n/-!\n\n# Join of contractions\n\n-/\n\nopen FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\nnamespace WickContraction\nvariable {n : \u2115} (c : WickContraction n)\nopen HepLean.List\nopen FieldOpAlgebra\n\n/-- Given a list `\u03c6s` of `\ud835\udcd5.FieldOp`, a Wick contraction `\u03c6s\u039b` of `\u03c6s` and a Wick contraction\n  `\u03c6suc\u039b` of `[\u03c6s\u039b]\u1d58\u1d9c`, `join \u03c6s\u039b \u03c6suc\u039b` is defined as the Wick contraction of `\u03c6s` consisting of\n  the contractions in `\u03c6s\u039b` and those in `\u03c6suc\u039b`.\n\n  As an example, for `\u03c6s = [\u03c61, \u03c62, \u03c63, \u03c64]`,\n  `\u03c6s\u039b = {{0, 1}}` corresponding to the contraction of `\u03c61` and `\u03c62` in `\u03c6s` and\n  `\u03c6suc\u039b = {{0, 1}}`\n  corresponding to the contraction of `\u03c63` and `\u03c64` in `[\u03c6s\u039b]\u1d58\u1d9c = [\u03c63, \u03c64]`, then\n  `join \u03c6s\u039b \u03c6suc\u039b` is the contraction `{{0, 1}, {2, 3}}` of `\u03c6s`. -/\ndef join {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) : WickContraction \u03c6s.length :=\n  \u27e8\u03c6s\u039b.1 \u222a \u03c6suc\u039b.1.map (Finset.mapEmbedding uncontractedListEmd).toEmbedding, by\n    intro a ha\n    simp only [Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,\n      RelEmbedding.coe_toEmbedding] at ha\n    rcases ha with ha | ha\n    \u00b7 exact \u03c6s\u039b.2.1 a ha\n    \u00b7 obtain \u27e8a, ha, rfl\u27e9 := ha\n      rw [Finset.mapEmbedding_apply]\n      simp only [Finset.card_map]\n      exact \u03c6suc\u039b.2.1 a ha, by\n    intro a ha b hb\n    simp only [Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,\n      RelEmbedding.coe_toEmbedding] at ha hb\n    rcases ha with ha | ha <;> rcases hb with hb | hb\n    \u00b7 exact \u03c6s\u039b.2.2 a ha b hb\n    \u00b7 obtain \u27e8b, hb, rfl\u27e9 := hb\n      right\n      symm\n      rw [Finset.mapEmbedding_apply]\n      apply uncontractedListEmd_finset_disjoint_left\n      exact ha\n    \u00b7 obtain \u27e8a, ha, rfl\u27e9 := ha\n      right\n      rw [Finset.mapEmbedding_apply]\n      apply uncontractedListEmd_finset_disjoint_left\n      exact hb\n    \u00b7 obtain \u27e8a, ha, rfl\u27e9 := ha\n      obtain \u27e8b, hb, rfl\u27e9 := hb\n      simp only [EmbeddingLike.apply_eq_iff_eq]\n      rw [Finset.mapEmbedding_apply, Finset.mapEmbedding_apply]\n      rw [Finset.disjoint_map]\n      exact \u03c6suc\u039b.2.2 a ha b hb\u27e9\n\nlemma join_congr {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} {\u03c6s\u039b' : WickContraction \u03c6s.length}\n    (h1 : \u03c6s\u039b = \u03c6s\u039b') :\n    join \u03c6s\u039b \u03c6suc\u039b = join \u03c6s\u039b' (congr (by simp [h1]) \u03c6suc\u039b) := by\n  subst h1\n  rfl\n\n/-- Given a contracting pair within `\u03c6s\u039b` the corresponding contracting pair within\n  `(join \u03c6s\u039b \u03c6suc\u039b)`. -/\ndef joinLiftLeft {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} : \u03c6s\u039b.1 \u2192 (join \u03c6s\u039b \u03c6suc\u039b).1 :=\n  fun a => \u27e8a, by simp [join]\u27e9\n\nlemma jointLiftLeft_injective {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} :\n    Function.Injective (@joinLiftLeft _ _ \u03c6s\u039b \u03c6suc\u039b) := by\n  intro a b h\n  simp only [joinLiftLeft] at h\n  rw [Subtype.mk_eq_mk] at h\n  refine Subtype.eq h\n\n/-- Given a contracting pair within `\u03c6suc\u039b` the corresponding contracting pair within\n  `(join \u03c6s\u039b \u03c6suc\u039b)`. -/\ndef joinLiftRight {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} : \u03c6suc\u039b.1 \u2192 (join \u03c6s\u039b \u03c6suc\u039b).1 :=\n  fun a => \u27e8a.1.map uncontractedListEmd, by\n    simp only [join, Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,\n      RelEmbedding.coe_toEmbedding]\n    right\n    use a.1\n    simp only [Finset.coe_mem, true_and]\n    rfl\u27e9\n\nlemma joinLiftRight_injective {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} :\n    Function.Injective (@joinLiftRight _ _ \u03c6s\u039b \u03c6suc\u039b) := by\n  intro a b h\n  simp only [joinLiftRight] at h\n  rw [Subtype.mk_eq_mk] at h\n  simp only [Finset.map_inj] at h\n  refine Subtype.eq h\n\nlemma jointLiftLeft_disjoint_joinLiftRight {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} (a : \u03c6s\u039b.1) (b : \u03c6suc\u039b.1) :\n    Disjoint (@joinLiftLeft _ _ _ \u03c6suc\u039b a).1 (joinLiftRight b).1 := by\n  simp only [joinLiftLeft, joinLiftRight]\n  symm\n  apply uncontractedListEmd_finset_disjoint_left\n  exact a.2\n\nlemma jointLiftLeft_neq_joinLiftRight {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} (a : \u03c6s\u039b.1) (b : \u03c6suc\u039b.1) :\n    joinLiftLeft a \u2260 joinLiftRight b := by\n  by_contra hn\n  have h1 := jointLiftLeft_disjoint_joinLiftRight a b\n  rw [hn] at h1\n  simp only [disjoint_self, Finset.bot_eq_empty] at h1\n  have hj := (join \u03c6s\u039b \u03c6suc\u039b).2.1 (joinLiftRight b).1 (joinLiftRight b).2\n  rw [h1] at hj\n  simp at hj\n\n/-- The map from contracted pairs of `\u03c6s\u039b` and `\u03c6suc\u039b` to contracted pairs in\n  `(join \u03c6s\u039b \u03c6suc\u039b)`. -/\ndef joinLift {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} : \u03c6s\u039b.1 \u2295 \u03c6suc\u039b.1 \u2192 (join \u03c6s\u039b \u03c6suc\u039b).1 := fun a =>\n  match a with\n  | Sum.inl a => joinLiftLeft a\n  | Sum.inr a => joinLiftRight a\n\nlemma joinLift_injective {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} : Function.Injective (@joinLift _ _ \u03c6s\u039b \u03c6suc\u039b) := by\n  intro a b h\n  match a, b with\n  | Sum.inl a, Sum.inl b =>\n    simp only [Sum.inl.injEq]\n    exact jointLiftLeft_injective h\n  | Sum.inr a, Sum.inr b =>\n    simp only [Sum.inr.injEq]\n    exact joinLiftRight_injective h\n  | Sum.inl a, Sum.inr b =>\n    simp only [joinLift] at h\n    have h1 := jointLiftLeft_neq_joinLiftRight a b\n    simp_all\n  | Sum.inr a, Sum.inl b =>\n    simp only [joinLift] at h\n    have h1 := jointLiftLeft_neq_joinLiftRight b a\n    simp_all\n\nlemma joinLift_surjective {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} : Function.Surjective (@joinLift _ _ \u03c6s\u039b \u03c6suc\u039b) := by\n  intro a\n  have ha2 := a.2\n  simp only [join, Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,\n    RelEmbedding.coe_toEmbedding] at ha2\n  rcases ha2 with ha2 | \u27e8a2, ha3\u27e9\n  \u00b7 use Sum.inl \u27e8a, ha2\u27e9\n    simp [joinLift, joinLiftLeft]\n  \u00b7 rw [Finset.mapEmbedding_apply] at ha3\n    use Sum.inr \u27e8a2, ha3.1\u27e9\n    simp only [joinLift, joinLiftRight]\n    refine Subtype.eq ?_\n    exact ha3.2\n\nlemma joinLift_bijective {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} : Function.Bijective (@joinLift _ _ \u03c6s\u039b \u03c6suc\u039b) := by\n  apply And.intro\n  \u00b7 exact joinLift_injective\n  \u00b7 exact joinLift_surjective\n\nlemma prod_join {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) (f : (join \u03c6s\u039b \u03c6suc\u039b).1 \u2192 M) [CommMonoid M]:\n      \u220f (a : (join \u03c6s\u039b \u03c6suc\u039b).1), f a = (\u220f (a : \u03c6s\u039b.1), f (joinLiftLeft a)) *\n      \u220f (a : \u03c6suc\u039b.1), f (joinLiftRight a) := by\n  let e1 := Equiv.ofBijective (@joinLift _ _ \u03c6s\u039b \u03c6suc\u039b) joinLift_bijective\n  rw [\u2190 e1.prod_comp]\n  simp only [Fintype.prod_sum_type, Finset.univ_eq_attach]\n  rfl\n\nlemma joinLiftLeft_or_joinLiftRight_of_mem_join {\u03c6s : List \ud835\udcd5.FieldOp}\n    (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) {a : Finset (Fin \u03c6s.length)}\n    (ha : a \u2208 (join \u03c6s\u039b \u03c6suc\u039b).1) :\n    (\u2203 b, a = (joinLiftLeft (\u03c6suc\u039b := \u03c6suc\u039b) b).1) \u2228\n    (\u2203 b, a = (joinLiftRight (\u03c6suc\u039b := \u03c6suc\u039b) b).1) := by\n  simp only [join, Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,\n    RelEmbedding.coe_toEmbedding] at ha\n  rcases ha with ha | \u27e8a, ha, rfl\u27e9\n  \u00b7 left\n    use \u27e8a, ha\u27e9\n    rfl\n  \u00b7 right\n    use \u27e8a, ha\u27e9\n    rfl\n\n@[simp]\nlemma join_fstFieldOfContract_joinLiftRight {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) (a : \u03c6suc\u039b.1) :\n    (join \u03c6s\u039b \u03c6suc\u039b).fstFieldOfContract (joinLiftRight a) =\n    uncontractedListEmd (\u03c6suc\u039b.fstFieldOfContract a) := by\n  apply eq_fstFieldOfContract_of_mem _ _ _ (uncontractedListEmd (\u03c6suc\u039b.sndFieldOfContract a))\n  \u00b7 simp [joinLiftRight]\n  \u00b7 simp [joinLiftRight]\n  \u00b7 apply uncontractedListEmd_strictMono\n    exact fstFieldOfContract_lt_sndFieldOfContract \u03c6suc\u039b a\n\n@[simp]\nlemma join_sndFieldOfContract_joinLiftRight {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) (a : \u03c6suc\u039b.1) :\n    (join \u03c6s\u039b \u03c6suc\u039b).sndFieldOfContract (joinLiftRight a) =\n    uncontractedListEmd (\u03c6suc\u039b.sndFieldOfContract a) := by\n  apply eq_sndFieldOfContract_of_mem _ _ (uncontractedListEmd (\u03c6suc\u039b.fstFieldOfContract a))\n  \u00b7 simp [joinLiftRight]\n  \u00b7 simp [joinLiftRight]\n  \u00b7 apply uncontractedListEmd_strictMono\n    exact fstFieldOfContract_lt_sndFieldOfContract \u03c6suc\u039b a\n\n@[simp]\nlemma join_fstFieldOfContract_joinLiftLeft {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) (a : \u03c6s\u039b.1) :\n    (join \u03c6s\u039b \u03c6suc\u039b).fstFieldOfContract (joinLiftLeft a) =\n    (\u03c6s\u039b.fstFieldOfContract a) := by\n  apply eq_fstFieldOfContract_of_mem _ _ _ (\u03c6s\u039b.sndFieldOfContract a)\n  \u00b7 simp [joinLiftLeft]\n  \u00b7 simp [joinLiftLeft]\n  \u00b7 exact fstFieldOfContract_lt_sndFieldOfContract \u03c6s\u039b a\n\n@[simp]\nlemma join_sndFieldOfContract_joinLift {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) (a : \u03c6s\u039b.1) :\n    (join \u03c6s\u039b \u03c6suc\u039b).sndFieldOfContract (joinLiftLeft a) =\n    (\u03c6s\u039b.sndFieldOfContract a) := by\n  apply eq_sndFieldOfContract_of_mem _ _ (\u03c6s\u039b.fstFieldOfContract a) (\u03c6s\u039b.sndFieldOfContract a)\n  \u00b7 simp [joinLiftLeft]\n  \u00b7 simp [joinLiftLeft]\n  \u00b7 exact fstFieldOfContract_lt_sndFieldOfContract \u03c6s\u039b a\n\nlemma mem_join_right_iff {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) (a : Finset (Fin [\u03c6s\u039b]\u1d58\u1d9c.length)) :\n    a \u2208 \u03c6suc\u039b.1 \u2194 a.map uncontractedListEmd \u2208 (join \u03c6s\u039b \u03c6suc\u039b).1 := by\n  simp only [join, Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,\n    RelEmbedding.coe_toEmbedding]\n  have h1' : \u00ac Finset.map uncontractedListEmd a \u2208 \u03c6s\u039b.1 :=\n    uncontractedListEmd_finset_not_mem a\n  simp only [h1', false_or]\n  apply Iff.intro\n  \u00b7 intro h\n    use a\n    simp only [h, true_and]\n    rw [Finset.mapEmbedding_apply]\n  \u00b7 intro h\n    obtain \u27e8a, ha, h2\u27e9 := h\n    rw [Finset.mapEmbedding_apply] at h2\n    simp only [Finset.map_inj] at h2\n    subst h2\n    exact ha\n\nlemma join_card {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} :\n    (join \u03c6s\u039b \u03c6suc\u039b).1.card = \u03c6s\u039b.1.card + \u03c6suc\u039b.1.card := by\n  simp only [join, Finset.le_eq_subset]\n  rw [Finset.card_union_of_disjoint]\n  simp only [Finset.card_map]\n  rw [@Finset.disjoint_left]\n  intro a ha\n  simp only [Finset.mem_map, RelEmbedding.coe_toEmbedding, not_exists, not_and]\n  intro x hx\n  by_contra hn\n  have hdis : Disjoint (Finset.map uncontractedListEmd x) a := by\n    exact uncontractedListEmd_finset_disjoint_left x a ha\n  rw [Finset.mapEmbedding_apply] at hn\n  rw [hn] at hdis\n  simp only [disjoint_self, Finset.bot_eq_empty] at hdis\n  have hcard := \u03c6s\u039b.2.1 a ha\n  simp_all\n\n", "theoremStatement": "@[simp]\nlemma empty_join {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction [empty (n := \u03c6s.length)]\u1d58\u1d9c.length) :\n    join empty \u03c6s\u039b = congr (by simp) \u03c6s\u039b ", "theoremName": "WickContraction.empty_join", "fileCreated": {"commit": "12d36dc1d9c726c035301091e57be0b29015e4ae", "date": "2025-01-31"}, "theoremCreated": {"commit": "12d36dc1d9c726c035301091e57be0b29015e4ae", "date": "2025-01-31"}, "file": "HepLean/HepLean/PerturbationTheory/WickContraction/Join.lean", "module": "HepLean.PerturbationTheory.WickContraction.Join", "jsonFile": "HepLean.PerturbationTheory.WickContraction.Join.jsonl", "positionMetadata": {"lineInFile": 285, "tokenPositionInFile": 11206, "theoremPositionInFile": 20}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 11, "numPremises": 93}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  apply Subtype.ext\n  simp only [join, Finset.le_eq_subset, uncontractedListEmd_empty]\n  ext a\n  conv_lhs =>\n    left\n    left\n    rw [empty]\n  simp only [Finset.empty_union, Finset.mem_map, RelEmbedding.coe_toEmbedding]\n  rw [mem_congr_iff]\n  apply Iff.intro\n  \u00b7 intro h\n    obtain \u27e8a, ha, rfl\u27e9 := h\n    rw [Finset.mapEmbedding_apply]\n    rw [Finset.map_map]\n    apply Set.mem_of_eq_of_mem _ ha\n    trans Finset.map (Equiv.refl _).toEmbedding a\n    rfl\n    simp\n  \u00b7 intro h\n    use Finset.map (finCongr (by simp)).toEmbedding a\n    simp only [h, true_and]\n    trans Finset.map (Equiv.refl _).toEmbedding a\n    rw [Finset.mapEmbedding_apply, Finset.map_map]\n    rfl\n    simp", "proofType": "tactic", "proofLengthLines": 25, "proofLengthTokens": 680}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.WickContraction.TimeContract\nimport HepLean.PerturbationTheory.WickContraction.StaticContract\nimport HepLean.PerturbationTheory.FieldOpAlgebra.TimeContraction\nimport HepLean.PerturbationTheory.WickContraction.SubContraction\nimport HepLean.PerturbationTheory.WickContraction.Singleton\n\n/-!\n\n# Join of contractions\n\n-/\n\nopen FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\nnamespace WickContraction\nvariable {n : \u2115} (c : WickContraction n)\nopen HepLean.List\nopen FieldOpAlgebra\n\n/-- Given a list `\u03c6s` of `\ud835\udcd5.FieldOp`, a Wick contraction `\u03c6s\u039b` of `\u03c6s` and a Wick contraction\n  `\u03c6suc\u039b` of `[\u03c6s\u039b]\u1d58\u1d9c`, `join \u03c6s\u039b \u03c6suc\u039b` is defined as the Wick contraction of `\u03c6s` consisting of\n  the contractions in `\u03c6s\u039b` and those in `\u03c6suc\u039b`.\n\n  As an example, for `\u03c6s = [\u03c61, \u03c62, \u03c63, \u03c64]`,\n  `\u03c6s\u039b = {{0, 1}}` corresponding to the contraction of `\u03c61` and `\u03c62` in `\u03c6s` and\n  `\u03c6suc\u039b = {{0, 1}}`\n  corresponding to the contraction of `\u03c63` and `\u03c64` in `[\u03c6s\u039b]\u1d58\u1d9c = [\u03c63, \u03c64]`, then\n  `join \u03c6s\u039b \u03c6suc\u039b` is the contraction `{{0, 1}, {2, 3}}` of `\u03c6s`. -/\ndef join {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) : WickContraction \u03c6s.length :=\n  \u27e8\u03c6s\u039b.1 \u222a \u03c6suc\u039b.1.map (Finset.mapEmbedding uncontractedListEmd).toEmbedding, by\n    intro a ha\n    simp only [Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,\n      RelEmbedding.coe_toEmbedding] at ha\n    rcases ha with ha | ha\n    \u00b7 exact \u03c6s\u039b.2.1 a ha\n    \u00b7 obtain \u27e8a, ha, rfl\u27e9 := ha\n      rw [Finset.mapEmbedding_apply]\n      simp only [Finset.card_map]\n      exact \u03c6suc\u039b.2.1 a ha, by\n    intro a ha b hb\n    simp only [Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,\n      RelEmbedding.coe_toEmbedding] at ha hb\n    rcases ha with ha | ha <;> rcases hb with hb | hb\n    \u00b7 exact \u03c6s\u039b.2.2 a ha b hb\n    \u00b7 obtain \u27e8b, hb, rfl\u27e9 := hb\n      right\n      symm\n      rw [Finset.mapEmbedding_apply]\n      apply uncontractedListEmd_finset_disjoint_left\n      exact ha\n    \u00b7 obtain \u27e8a, ha, rfl\u27e9 := ha\n      right\n      rw [Finset.mapEmbedding_apply]\n      apply uncontractedListEmd_finset_disjoint_left\n      exact hb\n    \u00b7 obtain \u27e8a, ha, rfl\u27e9 := ha\n      obtain \u27e8b, hb, rfl\u27e9 := hb\n      simp only [EmbeddingLike.apply_eq_iff_eq]\n      rw [Finset.mapEmbedding_apply, Finset.mapEmbedding_apply]\n      rw [Finset.disjoint_map]\n      exact \u03c6suc\u039b.2.2 a ha b hb\u27e9\n\nlemma join_congr {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} {\u03c6s\u039b' : WickContraction \u03c6s.length}\n    (h1 : \u03c6s\u039b = \u03c6s\u039b') :\n    join \u03c6s\u039b \u03c6suc\u039b = join \u03c6s\u039b' (congr (by simp [h1]) \u03c6suc\u039b) := by\n  subst h1\n  rfl\n\n/-- Given a contracting pair within `\u03c6s\u039b` the corresponding contracting pair within\n  `(join \u03c6s\u039b \u03c6suc\u039b)`. -/\ndef joinLiftLeft {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} : \u03c6s\u039b.1 \u2192 (join \u03c6s\u039b \u03c6suc\u039b).1 :=\n  fun a => \u27e8a, by simp [join]\u27e9\n\nlemma jointLiftLeft_injective {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} :\n    Function.Injective (@joinLiftLeft _ _ \u03c6s\u039b \u03c6suc\u039b) := by\n  intro a b h\n  simp only [joinLiftLeft] at h\n  rw [Subtype.mk_eq_mk] at h\n  refine Subtype.eq h\n\n/-- Given a contracting pair within `\u03c6suc\u039b` the corresponding contracting pair within\n  `(join \u03c6s\u039b \u03c6suc\u039b)`. -/\ndef joinLiftRight {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} : \u03c6suc\u039b.1 \u2192 (join \u03c6s\u039b \u03c6suc\u039b).1 :=\n  fun a => \u27e8a.1.map uncontractedListEmd, by\n    simp only [join, Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,\n      RelEmbedding.coe_toEmbedding]\n    right\n    use a.1\n    simp only [Finset.coe_mem, true_and]\n    rfl\u27e9\n\nlemma joinLiftRight_injective {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} :\n    Function.Injective (@joinLiftRight _ _ \u03c6s\u039b \u03c6suc\u039b) := by\n  intro a b h\n  simp only [joinLiftRight] at h\n  rw [Subtype.mk_eq_mk] at h\n  simp only [Finset.map_inj] at h\n  refine Subtype.eq h\n\nlemma jointLiftLeft_disjoint_joinLiftRight {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} (a : \u03c6s\u039b.1) (b : \u03c6suc\u039b.1) :\n    Disjoint (@joinLiftLeft _ _ _ \u03c6suc\u039b a).1 (joinLiftRight b).1 := by\n  simp only [joinLiftLeft, joinLiftRight]\n  symm\n  apply uncontractedListEmd_finset_disjoint_left\n  exact a.2\n\nlemma jointLiftLeft_neq_joinLiftRight {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} (a : \u03c6s\u039b.1) (b : \u03c6suc\u039b.1) :\n    joinLiftLeft a \u2260 joinLiftRight b := by\n  by_contra hn\n  have h1 := jointLiftLeft_disjoint_joinLiftRight a b\n  rw [hn] at h1\n  simp only [disjoint_self, Finset.bot_eq_empty] at h1\n  have hj := (join \u03c6s\u039b \u03c6suc\u039b).2.1 (joinLiftRight b).1 (joinLiftRight b).2\n  rw [h1] at hj\n  simp at hj\n\n/-- The map from contracted pairs of `\u03c6s\u039b` and `\u03c6suc\u039b` to contracted pairs in\n  `(join \u03c6s\u039b \u03c6suc\u039b)`. -/\ndef joinLift {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} : \u03c6s\u039b.1 \u2295 \u03c6suc\u039b.1 \u2192 (join \u03c6s\u039b \u03c6suc\u039b).1 := fun a =>\n  match a with\n  | Sum.inl a => joinLiftLeft a\n  | Sum.inr a => joinLiftRight a\n\nlemma joinLift_injective {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} : Function.Injective (@joinLift _ _ \u03c6s\u039b \u03c6suc\u039b) := by\n  intro a b h\n  match a, b with\n  | Sum.inl a, Sum.inl b =>\n    simp only [Sum.inl.injEq]\n    exact jointLiftLeft_injective h\n  | Sum.inr a, Sum.inr b =>\n    simp only [Sum.inr.injEq]\n    exact joinLiftRight_injective h\n  | Sum.inl a, Sum.inr b =>\n    simp only [joinLift] at h\n    have h1 := jointLiftLeft_neq_joinLiftRight a b\n    simp_all\n  | Sum.inr a, Sum.inl b =>\n    simp only [joinLift] at h\n    have h1 := jointLiftLeft_neq_joinLiftRight b a\n    simp_all\n\nlemma joinLift_surjective {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} : Function.Surjective (@joinLift _ _ \u03c6s\u039b \u03c6suc\u039b) := by\n  intro a\n  have ha2 := a.2\n  simp only [join, Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,\n    RelEmbedding.coe_toEmbedding] at ha2\n  rcases ha2 with ha2 | \u27e8a2, ha3\u27e9\n  \u00b7 use Sum.inl \u27e8a, ha2\u27e9\n    simp [joinLift, joinLiftLeft]\n  \u00b7 rw [Finset.mapEmbedding_apply] at ha3\n    use Sum.inr \u27e8a2, ha3.1\u27e9\n    simp only [joinLift, joinLiftRight]\n    refine Subtype.eq ?_\n    exact ha3.2\n\nlemma joinLift_bijective {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} : Function.Bijective (@joinLift _ _ \u03c6s\u039b \u03c6suc\u039b) := by\n  apply And.intro\n  \u00b7 exact joinLift_injective\n  \u00b7 exact joinLift_surjective\n\nlemma prod_join {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) (f : (join \u03c6s\u039b \u03c6suc\u039b).1 \u2192 M) [CommMonoid M]:\n      \u220f (a : (join \u03c6s\u039b \u03c6suc\u039b).1), f a = (\u220f (a : \u03c6s\u039b.1), f (joinLiftLeft a)) *\n      \u220f (a : \u03c6suc\u039b.1), f (joinLiftRight a) := by\n  let e1 := Equiv.ofBijective (@joinLift _ _ \u03c6s\u039b \u03c6suc\u039b) joinLift_bijective\n  rw [\u2190 e1.prod_comp]\n  simp only [Fintype.prod_sum_type, Finset.univ_eq_attach]\n  rfl\n\nlemma joinLiftLeft_or_joinLiftRight_of_mem_join {\u03c6s : List \ud835\udcd5.FieldOp}\n    (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) {a : Finset (Fin \u03c6s.length)}\n    (ha : a \u2208 (join \u03c6s\u039b \u03c6suc\u039b).1) :\n    (\u2203 b, a = (joinLiftLeft (\u03c6suc\u039b := \u03c6suc\u039b) b).1) \u2228\n    (\u2203 b, a = (joinLiftRight (\u03c6suc\u039b := \u03c6suc\u039b) b).1) := by\n  simp only [join, Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,\n    RelEmbedding.coe_toEmbedding] at ha\n  rcases ha with ha | \u27e8a, ha, rfl\u27e9\n  \u00b7 left\n    use \u27e8a, ha\u27e9\n    rfl\n  \u00b7 right\n    use \u27e8a, ha\u27e9\n    rfl\n\n@[simp]\nlemma join_fstFieldOfContract_joinLiftRight {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) (a : \u03c6suc\u039b.1) :\n    (join \u03c6s\u039b \u03c6suc\u039b).fstFieldOfContract (joinLiftRight a) =\n    uncontractedListEmd (\u03c6suc\u039b.fstFieldOfContract a) := by\n  apply eq_fstFieldOfContract_of_mem _ _ _ (uncontractedListEmd (\u03c6suc\u039b.sndFieldOfContract a))\n  \u00b7 simp [joinLiftRight]\n  \u00b7 simp [joinLiftRight]\n  \u00b7 apply uncontractedListEmd_strictMono\n    exact fstFieldOfContract_lt_sndFieldOfContract \u03c6suc\u039b a\n\n@[simp]\nlemma join_sndFieldOfContract_joinLiftRight {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) (a : \u03c6suc\u039b.1) :\n    (join \u03c6s\u039b \u03c6suc\u039b).sndFieldOfContract (joinLiftRight a) =\n    uncontractedListEmd (\u03c6suc\u039b.sndFieldOfContract a) := by\n  apply eq_sndFieldOfContract_of_mem _ _ (uncontractedListEmd (\u03c6suc\u039b.fstFieldOfContract a))\n  \u00b7 simp [joinLiftRight]\n  \u00b7 simp [joinLiftRight]\n  \u00b7 apply uncontractedListEmd_strictMono\n    exact fstFieldOfContract_lt_sndFieldOfContract \u03c6suc\u039b a\n\n@[simp]\nlemma join_fstFieldOfContract_joinLiftLeft {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) (a : \u03c6s\u039b.1) :\n    (join \u03c6s\u039b \u03c6suc\u039b).fstFieldOfContract (joinLiftLeft a) =\n    (\u03c6s\u039b.fstFieldOfContract a) := by\n  apply eq_fstFieldOfContract_of_mem _ _ _ (\u03c6s\u039b.sndFieldOfContract a)\n  \u00b7 simp [joinLiftLeft]\n  \u00b7 simp [joinLiftLeft]\n  \u00b7 exact fstFieldOfContract_lt_sndFieldOfContract \u03c6s\u039b a\n\n@[simp]\nlemma join_sndFieldOfContract_joinLift {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) (a : \u03c6s\u039b.1) :\n    (join \u03c6s\u039b \u03c6suc\u039b).sndFieldOfContract (joinLiftLeft a) =\n    (\u03c6s\u039b.sndFieldOfContract a) := by\n  apply eq_sndFieldOfContract_of_mem _ _ (\u03c6s\u039b.fstFieldOfContract a) (\u03c6s\u039b.sndFieldOfContract a)\n  \u00b7 simp [joinLiftLeft]\n  \u00b7 simp [joinLiftLeft]\n  \u00b7 exact fstFieldOfContract_lt_sndFieldOfContract \u03c6s\u039b a\n\nlemma mem_join_right_iff {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) (a : Finset (Fin [\u03c6s\u039b]\u1d58\u1d9c.length)) :\n    a \u2208 \u03c6suc\u039b.1 \u2194 a.map uncontractedListEmd \u2208 (join \u03c6s\u039b \u03c6suc\u039b).1 := by\n  simp only [join, Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,\n    RelEmbedding.coe_toEmbedding]\n  have h1' : \u00ac Finset.map uncontractedListEmd a \u2208 \u03c6s\u039b.1 :=\n    uncontractedListEmd_finset_not_mem a\n  simp only [h1', false_or]\n  apply Iff.intro\n  \u00b7 intro h\n    use a\n    simp only [h, true_and]\n    rw [Finset.mapEmbedding_apply]\n  \u00b7 intro h\n    obtain \u27e8a, ha, h2\u27e9 := h\n    rw [Finset.mapEmbedding_apply] at h2\n    simp only [Finset.map_inj] at h2\n    subst h2\n    exact ha\n\nlemma join_card {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length} :\n    (join \u03c6s\u039b \u03c6suc\u039b).1.card = \u03c6s\u039b.1.card + \u03c6suc\u039b.1.card := by\n  simp only [join, Finset.le_eq_subset]\n  rw [Finset.card_union_of_disjoint]\n  simp only [Finset.card_map]\n  rw [@Finset.disjoint_left]\n  intro a ha\n  simp only [Finset.mem_map, RelEmbedding.coe_toEmbedding, not_exists, not_and]\n  intro x hx\n  by_contra hn\n  have hdis : Disjoint (Finset.map uncontractedListEmd x) a := by\n    exact uncontractedListEmd_finset_disjoint_left x a ha\n  rw [Finset.mapEmbedding_apply] at hn\n  rw [hn] at hdis\n  simp only [disjoint_self, Finset.bot_eq_empty] at hdis\n  have hcard := \u03c6s\u039b.2.1 a ha\n  simp_all\n\n@[simp]\nlemma empty_join {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction [empty (n := \u03c6s.length)]\u1d58\u1d9c.length) :\n    join empty \u03c6s\u039b = congr (by simp) \u03c6s\u039b := by\n  apply Subtype.ext\n  simp only [join, Finset.le_eq_subset, uncontractedListEmd_empty]\n  ext a\n  conv_lhs =>\n    left\n    left\n    rw [empty]\n  simp only [Finset.empty_union, Finset.mem_map, RelEmbedding.coe_toEmbedding]\n  rw [mem_congr_iff]\n  apply Iff.intro\n  \u00b7 intro h\n    obtain \u27e8a, ha, rfl\u27e9 := h\n    rw [Finset.mapEmbedding_apply]\n    rw [Finset.map_map]\n    apply Set.mem_of_eq_of_mem _ ha\n    trans Finset.map (Equiv.refl _).toEmbedding a\n    rfl\n    simp\n  \u00b7 intro h\n    use Finset.map (finCongr (by simp)).toEmbedding a\n    simp only [h, true_and]\n    trans Finset.map (Equiv.refl _).toEmbedding a\n    rw [Finset.mapEmbedding_apply, Finset.map_map]\n    rfl\n    simp\n\n@[simp]\nlemma join_empty {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length) :\n    join \u03c6s\u039b empty = \u03c6s\u039b := by\n  apply Subtype.ext\n  ext a\n  simp [join, empty]\n\nlemma join_timeContract {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) :\n    (join \u03c6s\u039b \u03c6suc\u039b).timeContract = \u03c6s\u039b.timeContract * \u03c6suc\u039b.timeContract := by\n  simp only [timeContract, List.get_eq_getElem]\n  rw [prod_join]\n  congr 1\n  congr\n  funext a\n  simp\n\nlemma join_staticContract {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) :\n    (join \u03c6s\u039b \u03c6suc\u039b).staticContract = \u03c6s\u039b.staticContract * \u03c6suc\u039b.staticContract := by\n  simp only [staticContract, List.get_eq_getElem]\n  rw [prod_join]\n  congr 1\n  congr\n  funext a\n  simp\n\nlemma mem_join_uncontracted_of_mem_right_uncontracted {\u03c6s : List \ud835\udcd5.FieldOp}\n    (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) (i : Fin [\u03c6s\u039b]\u1d58\u1d9c.length)\n    (ha : i \u2208 \u03c6suc\u039b.uncontracted) :\n    uncontractedListEmd i \u2208 (join \u03c6s\u039b \u03c6suc\u039b).uncontracted := by\n  rw [mem_uncontracted_iff_not_contracted]\n  intro p hp\n  simp only [join, Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,\n    RelEmbedding.coe_toEmbedding] at hp\n  rcases hp with hp | hp\n  \u00b7 have hi : uncontractedListEmd i \u2208 \u03c6s\u039b.uncontracted := by\n      exact uncontractedListEmd_mem_uncontracted i\n    rw [mem_uncontracted_iff_not_contracted] at hi\n    exact hi p hp\n  \u00b7 obtain \u27e8p, hp, rfl\u27e9 := hp\n    rw [Finset.mapEmbedding_apply]\n    simp only [Finset.mem_map']\n    rw [mem_uncontracted_iff_not_contracted] at ha\n    exact ha p hp\n\nlemma exists_mem_left_uncontracted_of_mem_join_uncontracted {\u03c6s : List \ud835\udcd5.FieldOp}\n    (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) (i : Fin \u03c6s.length)\n    (ha : i \u2208 (join \u03c6s\u039b \u03c6suc\u039b).uncontracted) :\n    i \u2208 \u03c6s\u039b.uncontracted := by\n  rw [@mem_uncontracted_iff_not_contracted]\n  rw [@mem_uncontracted_iff_not_contracted] at ha\n  simp only [join, Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,\n    RelEmbedding.coe_toEmbedding] at ha\n  intro p hp\n  simp_all\n\nlemma exists_mem_right_uncontracted_of_mem_join_uncontracted {\u03c6s : List \ud835\udcd5.FieldOp}\n    (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) (i : Fin \u03c6s.length)\n    (hi : i \u2208 (join \u03c6s\u039b \u03c6suc\u039b).uncontracted) :\n    \u2203 a, uncontractedListEmd a = i \u2227 a \u2208 \u03c6suc\u039b.uncontracted := by\n  have hi' := exists_mem_left_uncontracted_of_mem_join_uncontracted _ _ i hi\n  obtain \u27e8j, rfl\u27e9 := uncontractedListEmd_surjective_mem_uncontracted i hi'\n  use j\n  simp only [true_and]\n  rw [mem_uncontracted_iff_not_contracted] at hi\n  rw [mem_uncontracted_iff_not_contracted]\n  intro p hp\n  have hip := hi (p.map uncontractedListEmd) (by\n    simp only [join, Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,\n      RelEmbedding.coe_toEmbedding]\n    right\n    use p\n    simp only [hp, true_and]\n    rw [Finset.mapEmbedding_apply])\n  simpa using hip\n\nlemma join_uncontractedList {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) :\n    (join \u03c6s\u039b \u03c6suc\u039b).uncontractedList = List.map uncontractedListEmd \u03c6suc\u039b.uncontractedList := by\n  rw [uncontractedList_eq_sort]\n  rw [uncontractedList_eq_sort]\n  rw [fin_finset_sort_map_monotone]\n  congr\n  ext a\n  simp only [Finset.mem_map]\n  apply Iff.intro\n  \u00b7 intro h\n    obtain \u27e8a, rfl, ha\u27e9 := exists_mem_right_uncontracted_of_mem_join_uncontracted _ _ a h\n    use a, ha\n  \u00b7 intro h\n    obtain \u27e8a, ha, rfl\u27e9 := h\n    exact mem_join_uncontracted_of_mem_right_uncontracted \u03c6s\u039b \u03c6suc\u039b a ha\n  \u00b7 intro a b h\n    exact uncontractedListEmd_strictMono h\n\nlemma join_uncontractedList_get {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) :\n    ((join \u03c6s\u039b \u03c6suc\u039b).uncontractedList).get =\n    \u03c6s\u039b.uncontractedListEmd \u2218 (\u03c6suc\u039b.uncontractedList).get \u2218\n        (Fin.cast (by rw [join_uncontractedList]; simp)) := by\n  have h1 {n : \u2115} (l1 l2 : List (Fin n)) (h : l1 = l2) :\n      l1.get = l2.get \u2218 Fin.cast (by rw [h]) := by\n    subst h\n    rfl\n  conv_lhs => rw [h1 _ _ (join_uncontractedList \u03c6s\u039b \u03c6suc\u039b)]\n  ext i\n  simp\n\nlemma join_uncontractedListGet {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) :\n    (join \u03c6s\u039b \u03c6suc\u039b).uncontractedListGet = \u03c6suc\u039b.uncontractedListGet := by\n  simp only [uncontractedListGet, join_uncontractedList, List.map_map, List.map_inj_left,\n    Function.comp_apply, List.get_eq_getElem, List.getElem_map]\n  intro a ha\n  simp only [uncontractedListEmd, uncontractedIndexEquiv, List.get_eq_getElem,\n    Equiv.trans_toEmbedding, Function.Embedding.trans_apply, Equiv.coe_toEmbedding, Equiv.coe_fn_mk,\n    Function.Embedding.coe_subtype]\n  rfl\n\nlemma join_uncontractedListEmb {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) :\n    (join \u03c6s\u039b \u03c6suc\u039b).uncontractedListEmd =\n    ((finCongr (congrArg List.length (join_uncontractedListGet _ _))).toEmbedding.trans\n      \u03c6suc\u039b.uncontractedListEmd).trans \u03c6s\u039b.uncontractedListEmd := by\n  refine Function.Embedding.ext_iff.mpr (congrFun ?_)\n  change uncontractedListEmd.toFun = _\n  rw [uncontractedListEmd_toFun_eq_get]\n  rw [join_uncontractedList_get]\n  rfl\n\nlemma join_assoc {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) (\u03c6suc\u039b' : WickContraction [\u03c6s\u039b.join \u03c6suc\u039b]\u1d58\u1d9c.length) :\n    join (join \u03c6s\u039b \u03c6suc\u039b) (\u03c6suc\u039b') = join \u03c6s\u039b (join \u03c6suc\u039b (congr\n      (congrArg List.length (join_uncontractedListGet _ _)) \u03c6suc\u039b')) := by\n  apply Subtype.ext\n  ext a\n  by_cases ha : a \u2208 \u03c6s\u039b.1\n  \u00b7 simp [ha, join]\n  simp only [join, Finset.le_eq_subset, Finset.union_assoc, Finset.mem_union, ha, Finset.mem_map,\n    RelEmbedding.coe_toEmbedding, false_or]\n  apply Iff.intro\n  \u00b7 intro h\n    rcases h with h | h\n    \u00b7 obtain \u27e8a, ha', rfl\u27e9 := h\n      use a\n      simp [ha']\n    \u00b7 obtain \u27e8a, ha', rfl\u27e9 := h\n      let a' := congrLift (congrArg List.length (join_uncontractedListGet _ _)) \u27e8a, ha'\u27e9\n      let a'' := joinLiftRight a'\n      use a''\n      apply And.intro\n      \u00b7 right\n        use a'\n        apply And.intro\n        \u00b7 exact a'.2\n        \u00b7 simp only [joinLiftRight, a'']\n          rfl\n      \u00b7 simp only [a'']\n        rw [Finset.mapEmbedding_apply, Finset.mapEmbedding_apply]\n        simp only [a', joinLiftRight, congrLift]\n        rw [join_uncontractedListEmb]\n        simp [Finset.map_map]\n  \u00b7 intro h\n    obtain \u27e8a, ha', rfl\u27e9 := h\n    rcases ha' with ha' | ha'\n    \u00b7 left\n      use a\n    \u00b7 obtain \u27e8a, ha', rfl\u27e9 := ha'\n      right\n      let a' := congrLiftInv _ \u27e8a, ha'\u27e9\n      use a'\n      simp only [Finset.coe_mem, true_and]\n      simp only [a']\n      rw [Finset.mapEmbedding_apply]\n      rw [join_uncontractedListEmb]\n      simp only [congrLiftInv, \u2190 Finset.map_map]\n      congr\n      rw [Finset.map_map]\n      change Finset.map (Equiv.refl _).toEmbedding a = _\n      simp only [Equiv.refl_toEmbedding, Finset.map_refl]\n\nlemma join_getDual?_apply_uncontractedListEmb_eq_none_iff {\u03c6s : List \ud835\udcd5.FieldOp}\n    (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) (i : Fin [\u03c6s\u039b]\u1d58\u1d9c.length) :\n    (join \u03c6s\u039b \u03c6suc\u039b).getDual? (uncontractedListEmd i) = none\n    \u2194 \u03c6suc\u039b.getDual? i = none := by\n  rw [getDual?_eq_none_iff_mem_uncontracted, getDual?_eq_none_iff_mem_uncontracted]\n  apply Iff.intro\n  \u00b7 intro h\n    obtain \u27e8a, ha', ha\u27e9 := exists_mem_right_uncontracted_of_mem_join_uncontracted _ _\n      (uncontractedListEmd i) h\n    simp only [EmbeddingLike.apply_eq_iff_eq] at ha'\n    subst ha'\n    exact ha\n  \u00b7 intro h\n    exact mem_join_uncontracted_of_mem_right_uncontracted \u03c6s\u039b \u03c6suc\u039b i h\n\nlemma join_getDual?_apply_uncontractedListEmb_isSome_iff {\u03c6s : List \ud835\udcd5.FieldOp}\n    (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) (i : Fin [\u03c6s\u039b]\u1d58\u1d9c.length) :\n    ((join \u03c6s\u039b \u03c6suc\u039b).getDual? (uncontractedListEmd i)).isSome\n    \u2194 (\u03c6suc\u039b.getDual? i).isSome := by\n  rw [\u2190 Decidable.not_iff_not]\n  simp [join_getDual?_apply_uncontractedListEmb_eq_none_iff]\n\nlemma join_getDual?_apply_uncontractedListEmb_some {\u03c6s : List \ud835\udcd5.FieldOp}\n    (\u03c6s\u039b : WickContraction \u03c6s.length)\n    (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length) (i : Fin [\u03c6s\u039b]\u1d58\u1d9c.length)\n    (hi :((join \u03c6s\u039b \u03c6suc\u039b).getDual? (uncontractedListEmd i)).isSome) :\n    ((join \u03c6s\u039b \u03c6suc\u039b).getDual? (uncontractedListEmd i)) =\n    some (uncontractedListEmd ((\u03c6suc\u039b.getDual? i).get (by\n    simpa [join_getDual?_apply_uncontractedListEmb_isSome_iff]using hi))) := by\n  rw [getDual?_eq_some_iff_mem]\n  simp only [join, Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,\n    RelEmbedding.coe_toEmbedding]\n  right\n  use {i, (\u03c6suc\u039b.getDual? i).get (by\n    simpa [join_getDual?_apply_uncontractedListEmb_isSome_iff] using hi)}\n  simp only [self_getDual?_get_mem, true_and]\n  rw [Finset.mapEmbedding_apply]\n  simp\n\n@[simp]\nlemma join_getDual?_apply_uncontractedListEmb {\u03c6s : List \ud835\udcd5.FieldOp}\n    (\u03c6s\u039b : WickContraction \u03c6s.length) (\u03c6suc\u039b : WickContraction [\u03c6s\u039b]\u1d58\u1d9c.length)\n    (i : Fin [\u03c6s\u039b]\u1d58\u1d9c.length) : ((join \u03c6s\u039b \u03c6suc\u039b).getDual? (uncontractedListEmd i)) =\n    Option.map uncontractedListEmd (\u03c6suc\u039b.getDual? i) := by\n  by_cases h : (\u03c6suc\u039b.getDual? i).isSome\n  \u00b7 rw [join_getDual?_apply_uncontractedListEmb_some]\n    have h1 : (\u03c6suc\u039b.getDual? i) = (\u03c6suc\u039b.getDual? i).get (by simpa using h) :=\n      Eq.symm (Option.some_get h)\n    conv_rhs => rw [h1]\n    simp only [Option.map_some']\n    exact (join_getDual?_apply_uncontractedListEmb_isSome_iff \u03c6s\u039b \u03c6suc\u039b i).mpr h\n  \u00b7 simp only [Bool.not_eq_true, Option.not_isSome, Option.isNone_iff_eq_none] at h\n    rw [h]\n    simp only [Option.map_none', join_getDual?_apply_uncontractedListEmb_eq_none_iff]\n    exact h\n\n/-!\n\n## Subcontractions and quotient contractions\n\n-/\n\nsection\n\nvariable {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length)\n\nlemma join_sub_quot (S : Finset (Finset (Fin \u03c6s.length))) (ha : S \u2286 \u03c6s\u039b.1) :\n    join (subContraction S ha) (quotContraction S ha) = \u03c6s\u039b := by\n  apply Subtype.ext\n  ext a\n  simp only [join, Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,\n    RelEmbedding.coe_toEmbedding]\n  apply Iff.intro\n  \u00b7 intro h\n    rcases h with h | h\n    \u00b7 exact mem_of_mem_subContraction h\n    \u00b7 obtain \u27e8a, ha, rfl\u27e9 := h\n      apply mem_of_mem_quotContraction ha\n  \u00b7 intro h\n    have h1 := mem_subContraction_or_quotContraction (S := S) (a := a) (hs := ha) h\n    rcases h1 with h1 | h1\n    \u00b7 simp [h1]\n    \u00b7 right\n      obtain \u27e8a, rfl, ha\u27e9 := h1\n      use a\n      simp only [ha, true_and]\n      rw [Finset.mapEmbedding_apply]\n\n", "theoremStatement": "lemma subContraction_card_plus_quotContraction_card_eq (S : Finset (Finset (Fin \u03c6s.length)))\n    (ha : S \u2286 \u03c6s\u039b.1) :\n    (subContraction S ha).1.card + (quotContraction S ha).1.card = \u03c6s\u039b.1.card ", "theoremName": "WickContraction.subContraction_card_plus_quotContraction_card_eq", "fileCreated": {"commit": "12d36dc1d9c726c035301091e57be0b29015e4ae", "date": "2025-01-31"}, "theoremCreated": {"commit": "12d36dc1d9c726c035301091e57be0b29015e4ae", "date": "2025-01-31"}, "file": "HepLean/HepLean/PerturbationTheory/WickContraction/Join.lean", "module": "HepLean.PerturbationTheory.WickContraction.Join", "jsonFile": "HepLean.PerturbationTheory.WickContraction.Join.jsonl", "positionMetadata": {"lineInFile": 589, "tokenPositionInFile": 22547, "theoremPositionInFile": 37}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 9, "numPremises": 40}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [\u2190 join_card]\n  simp [join_sub_quot]", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 47}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.TimeOrder\nimport HepLean.PerturbationTheory.FieldOpAlgebra.Basic\n/-!\n\n# SuperCommute on Field operator algebra\n\n-/\n\nnamespace FieldSpecification\nopen FieldOpFreeAlgebra\nopen HepLean.List\nopen FieldStatistic\n\nnamespace FieldOpAlgebra\nvariable {\ud835\udcd5 : FieldSpecification}\n\nlemma \u03b9_superCommuteF_eq_zero_of_\u03b9_right_zero (a b : \ud835\udcd5.FieldOpFreeAlgebra) (h : \u03b9 b = 0) :\n    \u03b9 [a, b]\u209bca = 0 := by\n  rw [superCommuteF_expand_bosonicProjF_fermionicProjF]\n  rw [\u03b9_eq_zero_iff_\u03b9_bosonicProjF_fermonicProj_zero] at h\n  simp_all\n\nlemma \u03b9_superCommuteF_eq_zero_of_\u03b9_left_zero (a b : \ud835\udcd5.FieldOpFreeAlgebra) (h : \u03b9 a = 0) :\n    \u03b9 [a, b]\u209bca = 0 := by\n  rw [superCommuteF_expand_bosonicProjF_fermionicProjF]\n  rw [\u03b9_eq_zero_iff_\u03b9_bosonicProjF_fermonicProj_zero] at h\n  simp_all\n\n/-!\n\n## Defining normal order for `FiedOpAlgebra`.\n\n-/\n\nlemma \u03b9_superCommuteF_right_zero_of_mem_ideal (a b : \ud835\udcd5.FieldOpFreeAlgebra)\n    (h : b \u2208 TwoSidedIdeal.span \ud835\udcd5.fieldOpIdealSet) : \u03b9 [a, b]\u209bca = 0 := by\n  apply \u03b9_superCommuteF_eq_zero_of_\u03b9_right_zero\n  exact (\u03b9_eq_zero_iff_mem_ideal b).mpr h\n\nlemma \u03b9_superCommuteF_eq_of_equiv_right (a b1 b2 : \ud835\udcd5.FieldOpFreeAlgebra) (h : b1 \u2248 b2) :\n    \u03b9 [a, b1]\u209bca = \u03b9 [a, b2]\u209bca := by\n  rw [equiv_iff_sub_mem_ideal] at h\n  rw [LinearMap.sub_mem_ker_iff.mp]\n  simp only [LinearMap.mem_ker, \u2190 map_sub]\n  exact \u03b9_superCommuteF_right_zero_of_mem_ideal a (b1 - b2) h\n\n/-- The super commutator on the `FieldOpAlgebra` defined as a linear map `[a,_]\u209b`. -/\nnoncomputable def superCommuteRight (a : \ud835\udcd5.FieldOpFreeAlgebra) :\n  FieldOpAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpAlgebra \ud835\udcd5 where\n  toFun := Quotient.lift (\u03b9.toLinearMap \u2218\u2097 superCommuteF a)\n    (\u03b9_superCommuteF_eq_of_equiv_right a)\n  map_add' x y := by\n    obtain \u27e8x, hx\u27e9 := \u03b9_surjective x\n    obtain \u27e8y, hy\u27e9 := \u03b9_surjective y\n    subst hx hy\n    rw [\u2190 map_add, \u03b9_apply, \u03b9_apply, \u03b9_apply]\n    rw [Quotient.lift_mk, Quotient.lift_mk, Quotient.lift_mk]\n    simp\n  map_smul' c y := by\n    obtain \u27e8y, hy\u27e9 := \u03b9_surjective y\n    subst hy\n    rw [\u2190 map_smul, \u03b9_apply, \u03b9_apply]\n    simp\n\nlemma superCommuteRight_apply_\u03b9 (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    superCommuteRight a (\u03b9 b) = \u03b9 [a, b]\u209bca := by rfl\n\nlemma superCommuteRight_apply_quot (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    superCommuteRight a \u27e6b\u27e7= \u03b9 [a, b]\u209bca := by rfl\n\nlemma superCommuteRight_eq_of_equiv (a1 a2 : \ud835\udcd5.FieldOpFreeAlgebra) (h : a1 \u2248 a2) :\n    superCommuteRight a1 = superCommuteRight a2 := by\n  rw [equiv_iff_sub_mem_ideal] at h\n  ext b\n  obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n  have ha1b1 : (superCommuteRight (a1 - a2)) (\u03b9 b) = 0 := by\n    rw [superCommuteRight_apply_\u03b9]\n    apply \u03b9_superCommuteF_eq_zero_of_\u03b9_left_zero\n    exact (\u03b9_eq_zero_iff_mem_ideal (a1 - a2)).mpr h\n  simp_all only [superCommuteRight_apply_\u03b9, map_sub, LinearMap.sub_apply]\n  trans \u03b9 ((superCommuteF a2) b) + 0\n  rw [\u2190 ha1b1]\n  simp only [add_sub_cancel]\n  simp\n\n/-- For a field specification `\ud835\udcd5`, `superCommute` is the linear map\n\n  `FieldOpAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpAlgebra \ud835\udcd5`\n\n  defined as the decent of `\u03b9 \u2218 superCommuteF` in both arguments.\n  In particular for `\u03c6s` and `\u03c6s'` lists of `\ud835\udcd5.CrAnFieldOp` in `FieldOpAlgebra \ud835\udcd5` the following\n  relation holds:\n\n  `superCommute \u03c6s \u03c6s' = \u03c6s * \u03c6s' - \ud835\udce2(\u03c6s, \u03c6s') \u2022 \u03c6s' * \u03c6s`\n\n  The notation `[a, b]\u209b` is used for `superCommute a b`.\n  -/\nnoncomputable def superCommute : FieldOpAlgebra \ud835\udcd5 \u2192\u2097[\u2102]\n    FieldOpAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpAlgebra \ud835\udcd5 where\n  toFun := Quotient.lift superCommuteRight superCommuteRight_eq_of_equiv\n  map_add' x y := by\n    obtain \u27e8x, rfl\u27e9 := \u03b9_surjective x\n    obtain \u27e8y, rfl\u27e9 := \u03b9_surjective y\n    ext b\n    obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n    rw [\u2190 map_add, \u03b9_apply, \u03b9_apply, \u03b9_apply, \u03b9_apply]\n    rw [Quotient.lift_mk, Quotient.lift_mk, Quotient.lift_mk]\n    simp only [LinearMap.add_apply]\n    rw [superCommuteRight_apply_quot, superCommuteRight_apply_quot, superCommuteRight_apply_quot]\n    simp\n  map_smul' c y := by\n    obtain \u27e8y, rfl\u27e9 := \u03b9_surjective y\n    ext b\n    obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n    rw [\u2190 map_smul, \u03b9_apply, \u03b9_apply, \u03b9_apply]\n    simp only [Quotient.lift_mk, RingHom.id_apply, LinearMap.smul_apply]\n    rw [superCommuteRight_apply_quot, superCommuteRight_apply_quot]\n    simp\n\n@[inherit_doc superCommute]\nscoped[FieldSpecification.FieldOpAlgebra] notation \"[\" a \",\" b \"]\u209b\" => superCommute a b\n\nlemma superCommute_eq_\u03b9_superCommuteF (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    [\u03b9 a, \u03b9 b]\u209b = \u03b9 [a, b]\u209bca := rfl\n\n/-!\n\n## Properties of `superCommute`.\n\n-/\n\n/-!\n\n## Properties from the definition of FieldOpAlgebra\n\n-/\n\nlemma superCommute_create_create {\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp}\n    (h : \ud835\udcd5 |>\u1d9c \u03c6 = .create) (h' : \ud835\udcd5 |>\u1d9c \u03c6' = .create) :\n    [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b = 0 := by\n  rw [ofCrAnOp, ofCrAnOp]\n  rw [superCommute_eq_\u03b9_superCommuteF, \u03b9_superCommuteF_of_create_create _ _ h h']\n\nlemma superCommute_annihilate_annihilate {\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp}\n    (h : \ud835\udcd5 |>\u1d9c \u03c6 = .annihilate) (h' : \ud835\udcd5 |>\u1d9c \u03c6' = .annihilate) :\n    [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b = 0 := by\n  rw [ofCrAnOp, ofCrAnOp]\n  rw [superCommute_eq_\u03b9_superCommuteF, \u03b9_superCommuteF_of_annihilate_annihilate _ _ h h']\n\nlemma superCommute_diff_statistic {\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp} (h : (\ud835\udcd5 |>\u209b \u03c6) \u2260 \ud835\udcd5 |>\u209b \u03c6') :\n    [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b = 0 := by\n  rw [ofCrAnOp, ofCrAnOp]\n  rw [superCommute_eq_\u03b9_superCommuteF, \u03b9_superCommuteF_of_diff_statistic h]\n\nlemma superCommute_ofCrAnOp_ofFieldOp_diff_stat_zero (\u03c6 : \ud835\udcd5.CrAnFieldOp) (\u03c8 : \ud835\udcd5.FieldOp)\n    (h : (\ud835\udcd5 |>\u209b \u03c6) \u2260 (\ud835\udcd5 |>\u209b \u03c8)) : [ofCrAnOp \u03c6, ofFieldOp \u03c8]\u209b = 0 := by\n  rw [ofFieldOp_eq_sum, map_sum]\n  rw [Finset.sum_eq_zero]\n  intro x hx\n  apply superCommute_diff_statistic\n  simpa [crAnStatistics] using h\n\nlemma superCommute_anPart_ofFieldOpF_diff_grade_zero (\u03c6 \u03c8 : \ud835\udcd5.FieldOp)\n    (h : (\ud835\udcd5 |>\u209b \u03c6) \u2260 (\ud835\udcd5 |>\u209b \u03c8)) : [anPart \u03c6, ofFieldOp \u03c8]\u209b = 0 := by\n  match \u03c6 with\n  | FieldOp.inAsymp _ =>\n    simp\n  | FieldOp.position \u03c6 =>\n    simp only [anPartF_position]\n    apply superCommute_ofCrAnOp_ofFieldOp_diff_stat_zero _ _ _\n    simpa [crAnStatistics] using h\n  | FieldOp.outAsymp _ =>\n    simp only [anPartF_posAsymp]\n    apply superCommute_ofCrAnOp_ofFieldOp_diff_stat_zero _ _\n    simpa [crAnStatistics] using h\n\nlemma superCommute_ofCrAnOp_ofCrAnOp_mem_center (\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b \u2208 Subalgebra.center \u2102 (FieldOpAlgebra \ud835\udcd5) := by\n  rw [ofCrAnOp, ofCrAnOp, superCommute_eq_\u03b9_superCommuteF]\n  exact \u03b9_superCommuteF_ofCrAnOpF_ofCrAnOpF_mem_center \u03c6 \u03c6'\n\nlemma superCommute_ofCrAnOp_ofCrAnOp_commute (\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp)\n    (a : FieldOpAlgebra \ud835\udcd5) :\n    a * [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b = [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b * a := by\n  have h1 := superCommute_ofCrAnOp_ofCrAnOp_mem_center \u03c6 \u03c6'\n  rw [@Subalgebra.mem_center_iff] at h1\n  exact h1 a\n\nlemma superCommute_ofCrAnOp_ofFieldOp_mem_center (\u03c6 : \ud835\udcd5.CrAnFieldOp) (\u03c6' : \ud835\udcd5.FieldOp) :\n    [ofCrAnOp \u03c6, ofFieldOp \u03c6']\u209b \u2208 Subalgebra.center \u2102 (FieldOpAlgebra \ud835\udcd5) := by\n  rw [ofFieldOp_eq_sum]\n  simp only [map_sum]\n  refine Subalgebra.sum_mem (Subalgebra.center \u2102 \ud835\udcd5.FieldOpAlgebra) ?_\n  intro x hx\n  exact superCommute_ofCrAnOp_ofCrAnOp_mem_center \u03c6 \u27e8\u03c6', x\u27e9\n\nlemma superCommute_ofCrAnOp_ofFieldOp_commute (\u03c6 : \ud835\udcd5.CrAnFieldOp) (\u03c6' : \ud835\udcd5.FieldOp)\n    (a : FieldOpAlgebra \ud835\udcd5) : a * [ofCrAnOp \u03c6, ofFieldOp \u03c6']\u209b =\n    [ofCrAnOp \u03c6, ofFieldOp \u03c6']\u209b * a := by\n  have h1 := superCommute_ofCrAnOp_ofFieldOp_mem_center \u03c6 \u03c6'\n  rw [@Subalgebra.mem_center_iff] at h1\n  exact h1 a\n\nlemma superCommute_anPart_ofFieldOp_mem_center (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [anPart \u03c6, ofFieldOp \u03c6']\u209b \u2208 Subalgebra.center \u2102 (FieldOpAlgebra \ud835\udcd5) := by\n  match \u03c6 with\n  | FieldOp.inAsymp _ =>\n    simp only [anPart_negAsymp, map_zero, LinearMap.zero_apply]\n    exact Subalgebra.zero_mem (Subalgebra.center \u2102 _)\n  | FieldOp.position \u03c6 =>\n    exact superCommute_ofCrAnOp_ofFieldOp_mem_center _ _\n  | FieldOp.outAsymp _ =>\n    exact superCommute_ofCrAnOp_ofFieldOp_mem_center _ _\n\n/-!\n\n### `superCommute` on different constructors.\n\n-/\n\nlemma superCommute_ofCrAnList_ofCrAnList (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnList \u03c6s, ofCrAnList \u03c6s']\u209b =\n    ofCrAnList (\u03c6s ++ \u03c6s') - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnList (\u03c6s' ++ \u03c6s) := by\n  rw [ofCrAnList_eq_\u03b9_ofCrAnListF, ofCrAnList_eq_\u03b9_ofCrAnListF]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_ofCrAnListF_ofCrAnListF]\n  rfl\n\nlemma superCommute_ofCrAnOp_ofCrAnOp (\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnOp \u03c6, ofCrAnOp \u03c6']\u209b = ofCrAnOp \u03c6 * ofCrAnOp \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 ofCrAnOp \u03c6' * ofCrAnOp \u03c6 := by\n  rw [ofCrAnOp, ofCrAnOp]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_ofCrAnOpF_ofCrAnOpF]\n  rfl\n\nlemma superCommute_ofCrAnList_ofFieldOpList (\u03c6cas : List \ud835\udcd5.CrAnFieldOp)\n    (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [ofCrAnList \u03c6cas, ofFieldOpList \u03c6s]\u209b = ofCrAnList \u03c6cas * ofFieldOpList \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6cas, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpList \u03c6s * ofCrAnList \u03c6cas := by\n  rw [ofCrAnList, ofFieldOpList]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_ofCrAnListF_ofFieldOpFsList]\n  rfl\n\nlemma superCommute_ofFieldOpList_ofFieldOpList (\u03c6s \u03c6s' : List \ud835\udcd5.FieldOp) :\n    [ofFieldOpList \u03c6s, ofFieldOpList \u03c6s']\u209b = ofFieldOpList \u03c6s * ofFieldOpList \u03c6s' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofFieldOpList \u03c6s' * ofFieldOpList \u03c6s := by\n  rw [ofFieldOpList, ofFieldOpList]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_ofFieldOpListF_ofFieldOpFsList]\n  rfl\n\nlemma superCommute_ofFieldOp_ofFieldOpList (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [ofFieldOp \u03c6, ofFieldOpList \u03c6s]\u209b = ofFieldOp \u03c6 * ofFieldOpList \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpList \u03c6s * ofFieldOp \u03c6 := by\n  rw [ofFieldOp, ofFieldOpList]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_ofFieldOpF_ofFieldOpFsList]\n  rfl\n\nlemma superCommute_ofFieldOpList_ofFieldOp (\u03c6s : List \ud835\udcd5.FieldOp) (\u03c6 : \ud835\udcd5.FieldOp) :\n    [ofFieldOpList \u03c6s, ofFieldOp \u03c6]\u209b = ofFieldOpList \u03c6s * ofFieldOp \u03c6 -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6) \u2022 ofFieldOp \u03c6 * ofFieldOpList \u03c6s := by\n  rw [ofFieldOpList, ofFieldOp]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_ofFieldOpListF_ofFieldOpF]\n  rfl\n\nlemma superCommute_anPart_crPart (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [anPart \u03c6, crPart \u03c6']\u209b = anPart \u03c6 * crPart \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 crPart \u03c6' * anPart \u03c6 := by\n  rw [anPart, crPart]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_anPartF_crPartF]\n  rfl\n\nlemma superCommute_crPart_anPart (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [crPart \u03c6, anPart \u03c6']\u209b = crPart \u03c6 * anPart \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 anPart \u03c6' * crPart \u03c6 := by\n  rw [anPart, crPart]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_crPartF_anPartF]\n  rfl\n\n@[simp]\nlemma superCommute_crPart_crPart (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) : [crPart \u03c6, crPart \u03c6']\u209b = 0 := by\n  match \u03c6, \u03c6' with\n  | FieldOp.outAsymp \u03c6, _ =>\n    simp\n  | _, FieldOp.outAsymp \u03c6 =>\n    simp\n  | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n    simp only [crPart_position]\n    apply superCommute_create_create\n    \u00b7 rfl\n    \u00b7 rfl\n  | FieldOp.position \u03c6, FieldOp.inAsymp \u03c6' =>\n    simp only [crPart_position, crPart_negAsymp]\n    apply superCommute_create_create\n    \u00b7 rfl\n    \u00b7 rfl\n  | FieldOp.inAsymp \u03c6, FieldOp.inAsymp \u03c6' =>\n    simp only [crPart_negAsymp]\n    apply superCommute_create_create\n    \u00b7 rfl\n    \u00b7 rfl\n  | FieldOp.inAsymp \u03c6, FieldOp.position \u03c6' =>\n    simp only [crPart_negAsymp, crPart_position]\n    apply superCommute_create_create\n    \u00b7 rfl\n    \u00b7 rfl\n\n@[simp]\nlemma superCommute_anPart_anPart (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) : [anPart \u03c6, anPart \u03c6']\u209b = 0 := by\n  match \u03c6, \u03c6' with\n  | FieldOp.inAsymp \u03c6, _ =>\n    simp\n  | _, FieldOp.inAsymp \u03c6 =>\n    simp\n  | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n    simp only [anPart_position]\n    apply superCommute_annihilate_annihilate\n    \u00b7 rfl\n    \u00b7 rfl\n  | FieldOp.position \u03c6, FieldOp.outAsymp \u03c6' =>\n    simp only [anPart_position, anPart_posAsymp]\n    apply superCommute_annihilate_annihilate\n    \u00b7 rfl\n    \u00b7 rfl\n  | FieldOp.outAsymp \u03c6, FieldOp.outAsymp \u03c6' =>\n    simp only [anPart_posAsymp]\n    apply superCommute_annihilate_annihilate\n    \u00b7 rfl\n    \u00b7 rfl\n  | FieldOp.outAsymp \u03c6, FieldOp.position \u03c6' =>\n    simp only [anPart_posAsymp, anPart_position]\n    apply superCommute_annihilate_annihilate\n    \u00b7 rfl\n    \u00b7 rfl\n\nlemma superCommute_crPart_ofFieldOpList (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [crPart \u03c6, ofFieldOpList \u03c6s]\u209b = crPart \u03c6 * ofFieldOpList \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpList \u03c6s * crPart \u03c6 := by\n  rw [crPart, ofFieldOpList]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_crPartF_ofFieldOpListF]\n  rfl\n\nlemma superCommute_anPart_ofFieldOpList (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [anPart \u03c6, ofFieldOpList \u03c6s]\u209b = anPart \u03c6 * ofFieldOpList \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpList \u03c6s * anPart \u03c6 := by\n  rw [anPart, ofFieldOpList]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_anPartF_ofFieldOpListF]\n  rfl\n\nlemma superCommute_crPart_ofFieldOp (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [crPart \u03c6, ofFieldOp \u03c6']\u209b = crPart \u03c6 * ofFieldOp \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 ofFieldOp \u03c6' * crPart \u03c6 := by\n  rw [crPart, ofFieldOp]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_crPartF_ofFieldOpF]\n  rfl\n\nlemma superCommute_anPart_ofFieldOp (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [anPart \u03c6, ofFieldOp \u03c6']\u209b = anPart \u03c6 * ofFieldOp \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 ofFieldOp \u03c6' * anPart \u03c6 := by\n  rw [anPart, ofFieldOp]\n  rw [superCommute_eq_\u03b9_superCommuteF, superCommuteF_anPartF_ofFieldOpF]\n  rfl\n\n/-!\n\n## Mul equal superCommute\n\nLemmas which rewrite a multiplication of two elements of the algebra as their commuted\nmultiplication with a sign plus the super commutator.\n\n-/\n\nlemma ofCrAnList_mul_ofCrAnList_eq_superCommute (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnList \u03c6s * ofCrAnList \u03c6s' =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnList \u03c6s' * ofCrAnList \u03c6s\n    + [ofCrAnList \u03c6s, ofCrAnList \u03c6s']\u209b := by\n  rw [superCommute_ofCrAnList_ofCrAnList]\n  simp [ofCrAnList_append]\n\nlemma ofCrAnOp_mul_ofCrAnList_eq_superCommute (\u03c6 : \ud835\udcd5.CrAnFieldOp)\n    (\u03c6s' : List \ud835\udcd5.CrAnFieldOp) : ofCrAnOp \u03c6 * ofCrAnList \u03c6s' =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnList \u03c6s' * ofCrAnOp \u03c6\n    + [ofCrAnOp \u03c6, ofCrAnList \u03c6s']\u209b := by\n  rw [\u2190 ofCrAnList_singleton, ofCrAnList_mul_ofCrAnList_eq_superCommute]\n  simp\n\nlemma ofFieldOpList_mul_ofFieldOpList_eq_superCommute (\u03c6s \u03c6s' : List \ud835\udcd5.FieldOp) :\n    ofFieldOpList \u03c6s * ofFieldOpList \u03c6s' =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofFieldOpList \u03c6s' * ofFieldOpList \u03c6s\n    + [ofFieldOpList \u03c6s, ofFieldOpList \u03c6s']\u209b := by\n  rw [superCommute_ofFieldOpList_ofFieldOpList]\n  simp\n\nlemma ofFieldOp_mul_ofFieldOpList_eq_superCommute (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s' : List \ud835\udcd5.FieldOp) :\n    ofFieldOp \u03c6 * ofFieldOpList \u03c6s' = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofFieldOpList \u03c6s' * ofFieldOp \u03c6\n    + [ofFieldOp \u03c6, ofFieldOpList \u03c6s']\u209b := by\n  rw [superCommute_ofFieldOp_ofFieldOpList]\n  simp\n\nlemma ofFieldOp_mul_ofFieldOp_eq_superCommute (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    ofFieldOp \u03c6 * ofFieldOp \u03c6' = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 ofFieldOp \u03c6' * ofFieldOp \u03c6\n    + [ofFieldOp \u03c6, ofFieldOp \u03c6']\u209b := by\n  rw [\u2190 ofFieldOpList_singleton, \u2190 ofFieldOpList_singleton]\n  rw [ofFieldOpList_mul_ofFieldOpList_eq_superCommute, ofFieldOpList_singleton]\n  simp\n\nlemma ofFieldOpList_mul_ofFieldOp_eq_superCommute (\u03c6s : List \ud835\udcd5.FieldOp) (\u03c6 : \ud835\udcd5.FieldOp) :\n    ofFieldOpList \u03c6s * ofFieldOp \u03c6 = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6) \u2022 ofFieldOp \u03c6 * ofFieldOpList \u03c6s\n    + [ofFieldOpList \u03c6s, ofFieldOp \u03c6]\u209b := by\n  rw [superCommute_ofFieldOpList_ofFieldOp]\n  simp\n\nlemma ofCrAnList_mul_ofFieldOpList_eq_superCommute (\u03c6s : List \ud835\udcd5.CrAnFieldOp)\n    (\u03c6s' : List \ud835\udcd5.FieldOp) : ofCrAnList \u03c6s * ofFieldOpList \u03c6s' =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofFieldOpList \u03c6s' * ofCrAnList \u03c6s\n    + [ofCrAnList \u03c6s, ofFieldOpList \u03c6s']\u209b := by\n  rw [superCommute_ofCrAnList_ofFieldOpList]\n  simp\n\nlemma crPart_mul_anPart_eq_superCommute (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    crPart \u03c6 * anPart \u03c6' = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 anPart \u03c6' * crPart \u03c6\n    + [crPart \u03c6, anPart \u03c6']\u209b := by\n  rw [superCommute_crPart_anPart]\n  simp\n\n", "theoremStatement": "lemma anPart_mul_crPart_eq_superCommute (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    anPart \u03c6 * crPart \u03c6' = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 crPart \u03c6' * anPart \u03c6\n    + [anPart \u03c6, crPart \u03c6']\u209b ", "theoremName": "FieldSpecification.FieldOpAlgebra.anPart_mul_crPart_eq_superCommute", "fileCreated": {"commit": "ea6e12829370d9630a7e65200c8349e9086c05ba", "date": "2025-02-03"}, "theoremCreated": {"commit": "509d536577fcd41a3684521c018d961d382be82c", "date": "2025-01-22"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpAlgebra/SuperCommute.lean", "module": "HepLean.PerturbationTheory.FieldOpAlgebra.SuperCommute", "jsonFile": "HepLean.PerturbationTheory.FieldOpAlgebra.SuperCommute.jsonl", "positionMetadata": {"lineInFile": 429, "tokenPositionInFile": 15824, "theoremPositionInFile": 41}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 16, "numPremises": 117}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [superCommute_anPart_crPart]\n  simp", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 46}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.TimeOrder\nimport HepLean.PerturbationTheory.FieldOpAlgebra.SuperCommute\n/-!\n\n# Time Ordering on Field operator algebra\n\n-/\n\nnamespace FieldSpecification\nopen FieldOpFreeAlgebra\nopen HepLean.List\nopen FieldStatistic\n\nnamespace FieldOpAlgebra\nvariable {\ud835\udcd5 : FieldSpecification}\n\nlemma \u03b9_timeOrderF_superCommuteF_superCommuteF_eq_time_ofCrAnListF {\u03c61 \u03c62 \u03c63 : \ud835\udcd5.CrAnFieldOp}\n    (\u03c6s1 \u03c6s2 : List \ud835\udcd5.CrAnFieldOp) (h :\n      crAnTimeOrderRel \u03c61 \u03c62 \u2227 crAnTimeOrderRel \u03c61 \u03c63 \u2227\n      crAnTimeOrderRel \u03c62 \u03c61 \u2227 crAnTimeOrderRel \u03c62 \u03c63 \u2227\n      crAnTimeOrderRel \u03c63 \u03c61 \u2227 crAnTimeOrderRel \u03c63 \u03c62) :\n    \u03b9 \ud835\udce3\u1da0(ofCrAnListF \u03c6s1 * [ofCrAnOpF \u03c61, [ofCrAnOpF \u03c62, ofCrAnOpF \u03c63]\u209bca]\u209bca *\n    ofCrAnListF \u03c6s2) = 0 := by\n  let l1 :=\n    (List.takeWhile (fun c => \u00ac crAnTimeOrderRel \u03c61 c)\n    ((\u03c6s1 ++ \u03c6s2).insertionSort crAnTimeOrderRel))\n    ++ (List.filter (fun c => crAnTimeOrderRel \u03c61 c \u2227 crAnTimeOrderRel c \u03c61) \u03c6s1)\n  let l2 := (List.filter (fun c => crAnTimeOrderRel \u03c61 c \u2227 crAnTimeOrderRel c \u03c61) \u03c6s2)\n    ++ (List.filter (fun c => crAnTimeOrderRel \u03c61 c \u2227 \u00ac crAnTimeOrderRel c \u03c61)\n    ((\u03c6s1 ++ \u03c6s2).insertionSort crAnTimeOrderRel))\n  have h123 : \u03b9 \ud835\udce3\u1da0(ofCrAnListF (\u03c6s1 ++ \u03c61 :: \u03c62 :: \u03c63 :: \u03c6s2)) =\n      crAnTimeOrderSign (\u03c6s1 ++ \u03c61 :: \u03c62 :: \u03c63 :: \u03c6s2)\n      \u2022 (\u03b9 (ofCrAnListF l1) * \u03b9 (ofCrAnListF [\u03c61, \u03c62, \u03c63]) * \u03b9 (ofCrAnListF l2)) := by\n    have h1 := insertionSort_of_eq_list \ud835\udcd5.crAnTimeOrderRel \u03c61 \u03c6s1 [\u03c61, \u03c62, \u03c63] \u03c6s2\n      (by simp_all)\n    rw [timeOrderF_ofCrAnListF, show \u03c6s1 ++ \u03c61 :: \u03c62 :: \u03c63 :: \u03c6s2 = \u03c6s1 ++ [\u03c61, \u03c62, \u03c63] ++ \u03c6s2\n      by simp, crAnTimeOrderList, h1]\n    simp only [List.append_assoc, List.singleton_append, decide_not,\n      Bool.decide_and, ofCrAnListF_append, map_smul, map_mul, l1, l2, mul_assoc]\n  have h132 : \u03b9 \ud835\udce3\u1da0(ofCrAnListF (\u03c6s1 ++ \u03c61 :: \u03c63 :: \u03c62 :: \u03c6s2)) =\n      crAnTimeOrderSign (\u03c6s1 ++ \u03c61 :: \u03c62 :: \u03c63 :: \u03c6s2)\n      \u2022 (\u03b9 (ofCrAnListF l1) * \u03b9 (ofCrAnListF [\u03c61, \u03c63, \u03c62]) * \u03b9 (ofCrAnListF l2)) := by\n    have h1 := insertionSort_of_eq_list \ud835\udcd5.crAnTimeOrderRel \u03c61 \u03c6s1 [\u03c61, \u03c63, \u03c62] \u03c6s2\n        (by simp_all)\n    rw [timeOrderF_ofCrAnListF, show \u03c6s1 ++ \u03c61 :: \u03c63 :: \u03c62 :: \u03c6s2 = \u03c6s1 ++ [\u03c61, \u03c63, \u03c62] ++ \u03c6s2\n      by simp, crAnTimeOrderList, h1]\n    simp only [List.singleton_append, decide_not,\n      Bool.decide_and, ofCrAnListF_append, map_smul, map_mul, l1, l2, mul_assoc]\n    congr 1\n    have hp : List.Perm [\u03c61, \u03c63, \u03c62] [\u03c61, \u03c62, \u03c63] := by\n      refine List.Perm.cons \u03c61 ?_\n      exact List.Perm.swap \u03c62 \u03c63 []\n    rw [crAnTimeOrderSign, Wick.koszulSign_perm_eq _ _ \u03c61 _ _ _ _ _ hp, \u2190 crAnTimeOrderSign]\n    \u00b7 simp\n    \u00b7 intro \u03c64 h\u03c64\n      simp only [List.mem_cons, List.mem_singleton, List.not_mem_nil, or_false] at h\u03c64\n      rcases h\u03c64 with h\u03c64 | h\u03c64 | h\u03c64\n      all_goals\n        subst h\u03c64\n        simp_all\n  have hp231 : List.Perm [\u03c62, \u03c63, \u03c61] [\u03c61, \u03c62, \u03c63] := by\n      refine List.Perm.trans (l\u2082 := [\u03c62, \u03c61, \u03c63]) ?_ ?_\n      refine List.Perm.cons \u03c62 (List.Perm.swap \u03c61 \u03c63 [])\n      exact List.Perm.swap \u03c61 \u03c62 [\u03c63]\n  have h231 : \u03b9 \ud835\udce3\u1da0(ofCrAnListF (\u03c6s1 ++ \u03c62 :: \u03c63 :: \u03c61 :: \u03c6s2)) =\n      crAnTimeOrderSign (\u03c6s1 ++ \u03c61 :: \u03c62 :: \u03c63 :: \u03c6s2)\n      \u2022 (\u03b9 (ofCrAnListF l1) * \u03b9 (ofCrAnListF [\u03c62, \u03c63, \u03c61]) * \u03b9 (ofCrAnListF l2)) := by\n    have h1 := insertionSort_of_eq_list \ud835\udcd5.crAnTimeOrderRel \u03c61 \u03c6s1 [\u03c62, \u03c63, \u03c61] \u03c6s2\n        (by simp_all)\n    rw [timeOrderF_ofCrAnListF, show \u03c6s1 ++ \u03c62 :: \u03c63 :: \u03c61 :: \u03c6s2 = \u03c6s1 ++ [\u03c62, \u03c63, \u03c61] ++ \u03c6s2\n      by simp, crAnTimeOrderList, h1]\n    simp only [List.singleton_append, decide_not,\n      Bool.decide_and, ofCrAnListF_append, map_smul, map_mul, l1, l2, mul_assoc]\n    congr 1\n    rw [crAnTimeOrderSign, Wick.koszulSign_perm_eq _ _ \u03c61 _ _ _ _ _ hp231, \u2190 crAnTimeOrderSign]\n    \u00b7 simp\n    \u00b7 intro \u03c64 h\u03c64\n      simp only [List.mem_cons, List.mem_singleton, List.not_mem_nil, or_false] at h\u03c64\n      rcases h\u03c64 with h\u03c64 | h\u03c64 | h\u03c64\n      all_goals\n        subst h\u03c64\n        simp_all\n  have h321 : \u03b9 \ud835\udce3\u1da0(ofCrAnListF (\u03c6s1 ++ \u03c63 :: \u03c62 :: \u03c61 :: \u03c6s2)) =\n      crAnTimeOrderSign (\u03c6s1 ++ \u03c61 :: \u03c62 :: \u03c63 :: \u03c6s2)\n      \u2022 (\u03b9 (ofCrAnListF l1) * \u03b9 (ofCrAnListF [\u03c63, \u03c62, \u03c61]) * \u03b9 (ofCrAnListF l2)) := by\n    have h1 := insertionSort_of_eq_list \ud835\udcd5.crAnTimeOrderRel \u03c61 \u03c6s1 [\u03c63, \u03c62, \u03c61] \u03c6s2\n        (by simp_all)\n    rw [timeOrderF_ofCrAnListF, show \u03c6s1 ++ \u03c63 :: \u03c62 :: \u03c61 :: \u03c6s2 = \u03c6s1 ++ [\u03c63, \u03c62, \u03c61] ++ \u03c6s2\n      by simp, crAnTimeOrderList, h1]\n    simp only [List.singleton_append, decide_not,\n      Bool.decide_and, ofCrAnListF_append, map_smul, map_mul, l1, l2, mul_assoc]\n    congr 1\n    have hp : List.Perm [\u03c63, \u03c62, \u03c61] [\u03c61, \u03c62, \u03c63] := by\n      refine List.Perm.trans ?_ hp231\n      exact List.Perm.swap \u03c62 \u03c63 [\u03c61]\n    rw [crAnTimeOrderSign, Wick.koszulSign_perm_eq _ _ \u03c61 _ _ _ _ _ hp, \u2190 crAnTimeOrderSign]\n    \u00b7 simp\n    \u00b7 intro \u03c64 h\u03c64\n      simp only [List.mem_cons, List.mem_singleton, List.not_mem_nil, or_false] at h\u03c64\n      rcases h\u03c64 with h\u03c64 | h\u03c64 | h\u03c64\n      all_goals\n        subst h\u03c64\n        simp_all\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton]\n  rw [superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp only [List.singleton_append, instCommGroup.eq_1, ofList_singleton, map_sub, map_smul]\n  rw [superCommuteF_ofCrAnListF_ofCrAnListF, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp only [List.cons_append, List.nil_append, instCommGroup.eq_1, ofList_singleton, mul_sub, \u2190\n    ofCrAnListF_append, Algebra.mul_smul_comm, sub_mul, List.append_assoc, Algebra.smul_mul_assoc,\n    map_sub, map_smul]\n  rw [h123, h132, h231, h321]\n  simp only [smul_smul]\n  rw [mul_comm, \u2190 smul_smul, mul_comm, \u2190 smul_smul]\n  rw [\u2190 smul_sub, \u2190 smul_sub, smul_smul, mul_comm, \u2190 smul_smul, \u2190 smul_sub]\n  simp only [smul_eq_zero]\n  right\n  rw [\u2190 smul_mul_assoc, \u2190 mul_smul_comm, mul_assoc]\n  rw [\u2190 smul_mul_assoc, \u2190 mul_smul_comm]\n  rw [smul_sub]\n  rw [\u2190 smul_mul_assoc, \u2190 mul_smul_comm]\n  rw [\u2190 smul_mul_assoc, \u2190 mul_smul_comm]\n  repeat rw [mul_assoc]\n  rw [\u2190 mul_sub, \u2190 mul_sub, \u2190 mul_sub]\n  rw [\u2190 sub_mul, \u2190 sub_mul, \u2190 sub_mul]\n  trans \u03b9 (ofCrAnListF l1) * \u03b9 [ofCrAnOpF \u03c61, [ofCrAnOpF \u03c62, ofCrAnOpF \u03c63]\u209bca]\u209bca *\n    \u03b9 (ofCrAnListF l2)\n  rw [mul_assoc]\n  congr\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton]\n  rw [superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp only [List.singleton_append, instCommGroup.eq_1, ofList_singleton, map_sub, map_smul]\n  rw [superCommuteF_ofCrAnListF_ofCrAnListF, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp only [List.cons_append, List.nil_append, instCommGroup.eq_1, ofList_singleton, map_sub,\n    map_smul, smul_sub]\n  simp_all\n\nlemma \u03b9_timeOrderF_superCommuteF_superCommuteF_ofCrAnListF {\u03c61 \u03c62 \u03c63 : \ud835\udcd5.CrAnFieldOp}\n    (\u03c6s1 \u03c6s2 : List \ud835\udcd5.CrAnFieldOp) :\n    \u03b9 \ud835\udce3\u1da0(ofCrAnListF \u03c6s1 * [ofCrAnOpF \u03c61, [ofCrAnOpF \u03c62, ofCrAnOpF \u03c63]\u209bca]\u209bca * ofCrAnListF \u03c6s2)\n    = 0 := by\n  by_cases h :\n      crAnTimeOrderRel \u03c61 \u03c62 \u2227 crAnTimeOrderRel \u03c61 \u03c63 \u2227\n      crAnTimeOrderRel \u03c62 \u03c61 \u2227 crAnTimeOrderRel \u03c62 \u03c63 \u2227\n      crAnTimeOrderRel \u03c63 \u03c61 \u2227 crAnTimeOrderRel \u03c63 \u03c62\n  \u00b7 exact \u03b9_timeOrderF_superCommuteF_superCommuteF_eq_time_ofCrAnListF \u03c6s1 \u03c6s2 h\n  \u00b7 rw [timeOrderF_timeOrderF_mid]\n    rw [timeOrderF_superCommuteF_ofCrAnOpF_superCommuteF_all_not_crAnTimeOrderRel _ _ _ h]\n    simp\n\n@[simp]\nlemma \u03b9_timeOrderF_superCommuteF_superCommuteF {\u03c61 \u03c62 \u03c63 : \ud835\udcd5.CrAnFieldOp}\n    (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \u03b9 \ud835\udce3\u1da0(a * [ofCrAnOpF \u03c61, [ofCrAnOpF \u03c62, ofCrAnOpF \u03c63]\u209bca]\u209bca * b) = 0 := by\n  let pb (b : \ud835\udcd5.FieldOpFreeAlgebra) (hc : b \u2208 Submodule.span \u2102 (Set.range ofCrAnListFBasis)) :\n    Prop := \u03b9 \ud835\udce3\u1da0(a * [ofCrAnOpF \u03c61, [ofCrAnOpF \u03c62, ofCrAnOpF \u03c63]\u209bca]\u209bca * b) = 0\n  change pb b (Basis.mem_span _ b)\n  apply Submodule.span_induction\n  \u00b7 intro x hx\n    obtain \u27e8\u03c6s, rfl\u27e9 := hx\n    simp only [ofListBasis_eq_ofList, pb]\n    let pa (a : \ud835\udcd5.FieldOpFreeAlgebra) (hc : a \u2208 Submodule.span \u2102 (Set.range ofCrAnListFBasis)) :\n      Prop := \u03b9 \ud835\udce3\u1da0(a * [ofCrAnOpF \u03c61, [ofCrAnOpF \u03c62, ofCrAnOpF \u03c63]\u209bca]\u209bca * ofCrAnListF \u03c6s) = 0\n    change pa a (Basis.mem_span _ a)\n    apply Submodule.span_induction\n    \u00b7 intro x hx\n      obtain \u27e8\u03c6s', rfl\u27e9 := hx\n      simp only [ofListBasis_eq_ofList, pa]\n      exact \u03b9_timeOrderF_superCommuteF_superCommuteF_ofCrAnListF \u03c6s' \u03c6s\n    \u00b7 simp [pa]\n    \u00b7 intro x y hx hy hpx hpy\n      simp_all [pa,mul_add, add_mul]\n    \u00b7 intro x hx hpx\n      simp_all [pa, hpx]\n  \u00b7 simp [pb]\n  \u00b7 intro x y hx hy hpx hpy\n    simp_all [pb,mul_add, add_mul]\n  \u00b7 intro x hx hpx\n    simp_all [pb, hpx]\n\nlemma \u03b9_timeOrderF_superCommuteF_eq_time {\u03c6 \u03c8 : \ud835\udcd5.CrAnFieldOp}\n    (h\u03c6\u03c8 : crAnTimeOrderRel \u03c6 \u03c8) (h\u03c8\u03c6 : crAnTimeOrderRel \u03c8 \u03c6) (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \u03b9 \ud835\udce3\u1da0(a * [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca * b) =\n    \u03b9 ([ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca * \ud835\udce3\u1da0(a * b)) := by\n  let pb (b : \ud835\udcd5.FieldOpFreeAlgebra) (hc : b \u2208 Submodule.span \u2102 (Set.range ofCrAnListFBasis)) :\n    Prop := \u03b9 \ud835\udce3\u1da0(a * [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca * b) =\n    \u03b9 ([ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca * \ud835\udce3\u1da0(a * b))\n  change pb b (Basis.mem_span _ b)\n  apply Submodule.span_induction\n  \u00b7 intro x hx\n    obtain \u27e8\u03c6s, rfl\u27e9 := hx\n    simp only [ofListBasis_eq_ofList, map_mul, pb]\n    let pa (a : \ud835\udcd5.FieldOpFreeAlgebra) (hc : a \u2208 Submodule.span \u2102 (Set.range ofCrAnListFBasis)) :\n      Prop := \u03b9 \ud835\udce3\u1da0(a * [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca * ofCrAnListF \u03c6s) =\n      \u03b9 ([ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca * \ud835\udce3\u1da0(a* ofCrAnListF \u03c6s))\n    change pa a (Basis.mem_span _ a)\n    apply Submodule.span_induction\n    \u00b7 intro x hx\n      obtain \u27e8\u03c6s', rfl\u27e9 := hx\n      simp only [ofListBasis_eq_ofList, map_mul, pa]\n      conv_lhs =>\n        rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n        simp [mul_sub, sub_mul, \u2190 ofCrAnListF_append]\n        rw [timeOrderF_ofCrAnListF, timeOrderF_ofCrAnListF]\n      have h1 : crAnTimeOrderSign (\u03c6s' ++ \u03c6 :: \u03c8 :: \u03c6s) =\n          crAnTimeOrderSign (\u03c6s' ++ \u03c8 :: \u03c6 :: \u03c6s) := by\n        trans crAnTimeOrderSign (\u03c6s' ++ [\u03c6, \u03c8] ++ \u03c6s)\n        simp only [List.append_assoc, List.cons_append, List.nil_append]\n        rw [crAnTimeOrderSign]\n        have hp : List.Perm [\u03c6,\u03c8] [\u03c8,\u03c6] := by exact List.Perm.swap \u03c8 \u03c6 []\n        rw [Wick.koszulSign_perm_eq _ _ \u03c6 _ _ _ _ _ hp]\n        simp only [List.append_assoc, List.cons_append, List.singleton_append]\n        rfl\n        simp_all\n      rw [h1]\n      simp only [map_smul]\n      have h1 := insertionSort_of_eq_list \ud835\udcd5.crAnTimeOrderRel \u03c6 \u03c6s' [\u03c6, \u03c8] \u03c6s\n        (by simp_all)\n      rw [crAnTimeOrderList, show \u03c6s' ++ \u03c6 :: \u03c8 :: \u03c6s = \u03c6s' ++ [\u03c6, \u03c8] ++ \u03c6s by simp, h1]\n      have h2 := insertionSort_of_eq_list \ud835\udcd5.crAnTimeOrderRel \u03c6 \u03c6s' [\u03c8, \u03c6] \u03c6s\n        (by simp_all)\n      rw [crAnTimeOrderList, show \u03c6s' ++ \u03c8 :: \u03c6 :: \u03c6s = \u03c6s' ++ [\u03c8, \u03c6] ++ \u03c6s by simp, h2]\n      repeat rw [ofCrAnListF_append]\n      rw [smul_smul, mul_comm, \u2190 smul_smul, \u2190 smul_sub]\n      rw [map_mul, map_mul, map_mul, map_mul, map_mul, map_mul, map_mul, map_mul]\n      rw [\u2190 mul_smul_comm]\n      rw [mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc]\n      rw [\u2190 mul_sub, \u2190 mul_sub, mul_smul_comm, mul_smul_comm, \u2190 smul_mul_assoc,\n        \u2190 smul_mul_assoc]\n      rw [\u2190 sub_mul]\n      have h1 : (\u03b9 (ofCrAnListF [\u03c6, \u03c8]) -\n          (exchangeSign (\ud835\udcd5.crAnStatistics \u03c6)) (\ud835\udcd5.crAnStatistics \u03c8) \u2022 \u03b9 (ofCrAnListF [\u03c8, \u03c6])) =\n        \u03b9 [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca := by\n        rw [superCommuteF_ofCrAnOpF_ofCrAnOpF]\n        rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_append]\n        simp only [instCommGroup.eq_1, List.singleton_append, Algebra.smul_mul_assoc, map_sub,\n          map_smul]\n        rw [\u2190 ofCrAnListF_append]\n        simp\n      rw [h1]\n      have hc : \u03b9 ((superCommuteF (ofCrAnOpF \u03c6)) (ofCrAnOpF \u03c8)) \u2208\n          Subalgebra.center \u2102 \ud835\udcd5.FieldOpAlgebra := by\n        apply \u03b9_superCommuteF_ofCrAnOpF_ofCrAnOpF_mem_center\n      rw [Subalgebra.mem_center_iff] at hc\n      repeat rw [\u2190 mul_assoc]\n      rw [hc]\n      repeat rw [mul_assoc]\n      rw [smul_mul_assoc]\n      rw [\u2190 map_mul, \u2190 map_mul, \u2190 map_mul, \u2190 map_mul]\n      rw [\u2190 ofCrAnListF_append, \u2190 ofCrAnListF_append, \u2190 ofCrAnListF_append, \u2190 ofCrAnListF_append]\n      have h1 := insertionSort_of_takeWhile_filter \ud835\udcd5.crAnTimeOrderRel \u03c6 \u03c6s' \u03c6s\n      simp only [decide_not, Bool.decide_and, List.append_assoc, List.cons_append,\n        List.singleton_append, Algebra.mul_smul_comm, map_mul] at h1 \u22a2\n      rw [\u2190 h1]\n      rw [\u2190 crAnTimeOrderList]\n      by_cases hq : (\ud835\udcd5 |>\u209b \u03c6) \u2260 (\ud835\udcd5 |>\u209b \u03c8)\n      \u00b7 rw [\u03b9_superCommuteF_of_diff_statistic hq]\n        simp\n      \u00b7 rw [crAnTimeOrderSign, Wick.koszulSign_eq_rel_eq_stat _ _, \u2190 crAnTimeOrderSign]\n        rw [timeOrderF_ofCrAnListF]\n        simp only [map_smul, Algebra.mul_smul_comm]\n        simp only [List.nil_append]\n        exact h\u03c8\u03c6\n        exact h\u03c6\u03c8\n        simpa using hq\n    \u00b7 simp only [map_mul, zero_mul, map_zero, mul_zero, pa]\n    \u00b7 intro x y hx hy hpx hpy\n      simp_all [pa,mul_add, add_mul]\n    \u00b7 intro x hx hpx\n      simp_all [pa, hpx]\n  \u00b7 simp only [map_mul, mul_zero, map_zero, pb]\n  \u00b7 intro x y hx hy hpx hpy\n    simp_all [pb,mul_add, add_mul]\n  \u00b7 intro x hx hpx\n    simp_all [pb, hpx]\n\nlemma \u03b9_timeOrderF_superCommuteF_neq_time {\u03c6 \u03c8 : \ud835\udcd5.CrAnFieldOp}\n    (h\u03c6\u03c8 : \u00ac (crAnTimeOrderRel \u03c6 \u03c8 \u2227 crAnTimeOrderRel \u03c8 \u03c6)) (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \u03b9 \ud835\udce3\u1da0(a * [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca * b) = 0 := by\n  rw [timeOrderF_timeOrderF_mid]\n  have h\u03c6\u03c8 : \u00ac (crAnTimeOrderRel \u03c6 \u03c8) \u2228 \u00ac (crAnTimeOrderRel \u03c8 \u03c6) := by\n    exact Decidable.not_and_iff_or_not.mp h\u03c6\u03c8\n  rcases h\u03c6\u03c8 with h\u03c6\u03c8 | h\u03c6\u03c8\n  \u00b7 rw [timeOrderF_superCommuteF_ofCrAnOpF_ofCrAnOpF_not_crAnTimeOrderRel]\n    simp_all only [false_and, not_false_eq_true, false_or, mul_zero, zero_mul, map_zero]\n    simp_all\n  \u00b7 rw [superCommuteF_ofCrAnOpF_ofCrAnOpF_symm]\n    simp only [instCommGroup.eq_1, neg_smul, map_neg, map_smul, mul_neg, Algebra.mul_smul_comm,\n      neg_mul, Algebra.smul_mul_assoc, neg_eq_zero, smul_eq_zero]\n    rw [timeOrderF_superCommuteF_ofCrAnOpF_ofCrAnOpF_not_crAnTimeOrderRel]\n    simp only [mul_zero, zero_mul, map_zero, or_true]\n    simp_all\n\n/-!\n\n## Defining time order for `FiedOpAlgebra`.\n\n-/\n\nlemma \u03b9_timeOrderF_zero_of_mem_ideal (a : \ud835\udcd5.FieldOpFreeAlgebra)\n    (h : a \u2208 TwoSidedIdeal.span \ud835\udcd5.fieldOpIdealSet) : \u03b9 \ud835\udce3\u1da0(a) = 0 := by\n  rw [TwoSidedIdeal.mem_span_iff_mem_addSubgroup_closure] at h\n  let p {k : Set \ud835\udcd5.FieldOpFreeAlgebra} (a : FieldOpFreeAlgebra \ud835\udcd5)\n    (h : a \u2208 AddSubgroup.closure k) := \u03b9 \ud835\udce3\u1da0(a) = 0\n  change p a h\n  apply AddSubgroup.closure_induction\n  \u00b7 intro x hx\n    obtain \u27e8a, ha, b, hb, rfl\u27e9 := Set.mem_mul.mp hx\n    obtain \u27e8a, ha, c, hc, rfl\u27e9 := ha\n    simp only [p]\n    simp only [fieldOpIdealSet, exists_prop, exists_and_left, Set.mem_setOf_eq] at hc\n    match hc with\n    | Or.inl hc =>\n      obtain \u27e8\u03c6a, \u03c6a', h\u03c6a, h\u03c6a', rfl\u27e9 := hc\n      simp only [\u03b9_timeOrderF_superCommuteF_superCommuteF]\n    | Or.inr (Or.inl hc) =>\n      obtain \u27e8\u03c6a, h\u03c6a, \u03c6b, h\u03c6b, rfl\u27e9 := hc\n      by_cases heqt : (crAnTimeOrderRel \u03c6a \u03c6b \u2227 crAnTimeOrderRel \u03c6b \u03c6a)\n      \u00b7 rw [\u03b9_timeOrderF_superCommuteF_eq_time]\n        simp only [map_mul]\n        rw [\u03b9_superCommuteF_of_create_create]\n        simp only [zero_mul]\n        \u00b7 exact h\u03c6a\n        \u00b7 exact h\u03c6b\n        \u00b7 exact heqt.1\n        \u00b7 exact heqt.2\n      \u00b7 rw [\u03b9_timeOrderF_superCommuteF_neq_time heqt]\n    | Or.inr (Or.inr (Or.inl hc)) =>\n      obtain \u27e8\u03c6a, h\u03c6a, \u03c6b, h\u03c6b, rfl\u27e9 := hc\n      by_cases heqt : (crAnTimeOrderRel \u03c6a \u03c6b \u2227 crAnTimeOrderRel \u03c6b \u03c6a)\n      \u00b7 rw [\u03b9_timeOrderF_superCommuteF_eq_time]\n        simp only [map_mul]\n        rw [\u03b9_superCommuteF_of_annihilate_annihilate]\n        simp only [zero_mul]\n        \u00b7 exact h\u03c6a\n        \u00b7 exact h\u03c6b\n        \u00b7 exact heqt.1\n        \u00b7 exact heqt.2\n      \u00b7 rw [\u03b9_timeOrderF_superCommuteF_neq_time heqt]\n    | Or.inr (Or.inr (Or.inr hc)) =>\n      obtain \u27e8\u03c6a, \u03c6b, hdiff, rfl\u27e9 := hc\n      by_cases heqt : (crAnTimeOrderRel \u03c6a \u03c6b \u2227 crAnTimeOrderRel \u03c6b \u03c6a)\n      \u00b7 rw [\u03b9_timeOrderF_superCommuteF_eq_time]\n        simp only [map_mul]\n        rw [\u03b9_superCommuteF_of_diff_statistic]\n        simp only [zero_mul]\n        \u00b7 exact hdiff\n        \u00b7 exact heqt.1\n        \u00b7 exact heqt.2\n      \u00b7 rw [\u03b9_timeOrderF_superCommuteF_neq_time heqt]\n  \u00b7 simp [p]\n  \u00b7 intro x y hx hy\n    simp only [map_add, p]\n    intro h1 h2\n    simp [h1, h2]\n  \u00b7 intro x hx\n    simp [p]\n\nlemma \u03b9_timeOrderF_eq_of_equiv (a b : \ud835\udcd5.FieldOpFreeAlgebra) (h : a \u2248 b) :\n    \u03b9 \ud835\udce3\u1da0(a) = \u03b9 \ud835\udce3\u1da0(b) := by\n  rw [equiv_iff_sub_mem_ideal] at h\n  rw [LinearMap.sub_mem_ker_iff.mp]\n  simp only [LinearMap.mem_ker, \u2190 map_sub]\n  exact \u03b9_timeOrderF_zero_of_mem_ideal (a - b) h\n\n/-- For a field specification `\ud835\udcd5`, `timeOrder` is the linear map\n\n`FieldOpAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpAlgebra \ud835\udcd5`\n\ndefined as the decent of `\u03b9 \u2218\u2097 timeOrderF : FieldOpFreeAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpAlgebra \ud835\udcd5` from\n`FieldOpFreeAlgebra \ud835\udcd5` to `FieldOpAlgebra \ud835\udcd5`.\nThis decent exists because `\u03b9 \u2218\u2097 timeOrderF` is well-defined on equivalence classes.\n\nThe notation `\ud835\udce3(a)` is used for `timeOrder a`. -/\nnoncomputable def timeOrder : FieldOpAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpAlgebra \ud835\udcd5 where\n  toFun := Quotient.lift (\u03b9.toLinearMap \u2218\u2097 timeOrderF) \u03b9_timeOrderF_eq_of_equiv\n  map_add' x y := by\n    obtain \u27e8x, hx\u27e9 := \u03b9_surjective x\n    obtain \u27e8y, hy\u27e9 := \u03b9_surjective y\n    subst hx hy\n    rw [\u2190 map_add, \u03b9_apply, \u03b9_apply, \u03b9_apply]\n    rw [Quotient.lift_mk, Quotient.lift_mk, Quotient.lift_mk]\n    simp\n  map_smul' c y := by\n    obtain \u27e8y, hy\u27e9 := \u03b9_surjective y\n    subst hy\n    rw [\u2190 map_smul, \u03b9_apply, \u03b9_apply]\n    simp\n\n@[inherit_doc timeOrder]\nscoped[FieldSpecification.FieldOpAlgebra] notation \"\ud835\udce3(\" a \")\" => timeOrder a\n\n/-!\n\n## Properties of time ordering\n\n-/\n\n", "theoremStatement": "lemma timeOrder_eq_\u03b9_timeOrderF (a : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \ud835\udce3(\u03b9 a) = \u03b9 \ud835\udce3\u1da0(a) ", "theoremName": "FieldSpecification.FieldOpAlgebra.timeOrder_eq_\u03b9_timeOrderF", "fileCreated": {"commit": "ea6e12829370d9630a7e65200c8349e9086c05ba", "date": "2025-02-03"}, "theoremCreated": {"commit": "fc2009928299f5a839dd880670f22245b6a09f72", "date": "2025-01-30"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpAlgebra/TimeOrder.lean", "module": "HepLean.PerturbationTheory.FieldOpAlgebra.TimeOrder", "jsonFile": "HepLean.PerturbationTheory.FieldOpAlgebra.TimeOrder.jsonl", "positionMetadata": {"lineInFile": 403, "tokenPositionInFile": 17442, "theoremPositionInFile": 8}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 8, "numPremises": 40}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.SuperCommute\nimport Mathlib.Algebra.RingQuot\nimport Mathlib.RingTheory.TwoSidedIdeal.Operations\n/-!\n\n# Field operator algebra\n\n-/\n\nnamespace FieldSpecification\nopen FieldOpFreeAlgebra\nopen HepLean.List\nopen FieldStatistic\n\nvariable (\ud835\udcd5 : FieldSpecification)\n\n/-- The set contains the super-commutators equal to zero in the operator algebra.\n  This contains e.g. the super-commutator of two creation operators. -/\ndef fieldOpIdealSet : Set (FieldOpFreeAlgebra \ud835\udcd5) :=\n  { x |\n    (\u2203 (\u03c61 \u03c62 \u03c63 : \ud835\udcd5.CrAnFieldOp),\n        x = [ofCrAnOpF \u03c61, [ofCrAnOpF \u03c62, ofCrAnOpF \u03c63]\u209bca]\u209bca)\n    \u2228 (\u2203 (\u03c6c \u03c6c' : \ud835\udcd5.CrAnFieldOp) (_ : \ud835\udcd5 |>\u1d9c \u03c6c = .create) (_ : \ud835\udcd5 |>\u1d9c \u03c6c' = .create),\n      x = [ofCrAnOpF \u03c6c, ofCrAnOpF \u03c6c']\u209bca)\n    \u2228 (\u2203 (\u03c6a \u03c6a' : \ud835\udcd5.CrAnFieldOp) (_ : \ud835\udcd5 |>\u1d9c \u03c6a = .annihilate) (_ : \ud835\udcd5 |>\u1d9c \u03c6a' = .annihilate),\n      x = [ofCrAnOpF \u03c6a, ofCrAnOpF \u03c6a']\u209bca)\n    \u2228 (\u2203 (\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp) (_ : \u00ac (\ud835\udcd5 |>\u209b \u03c6) = (\ud835\udcd5 |>\u209b \u03c6')),\n      x = [ofCrAnOpF \u03c6, ofCrAnOpF \u03c6']\u209bca)}\n\n/-- For a field specification `\ud835\udcd5`, the algebra `\ud835\udcd5.FieldOpAlgebra` is defined as the quotient\n  of the free algebra `\ud835\udcd5.FieldOpFreeAlgebra` by the ideal generated by\n- `[ofCrAnOpF \u03c6c, ofCrAnOpF \u03c6c']\u209bca` for `\u03c6c` and `\u03c6c'` field creation operators.\n  This corresponds to the condition that two creation operators always super-commute.\n- `[ofCrAnOpF \u03c6a, ofCrAnOpF \u03c6a']\u209bca` for `\u03c6a` and `\u03c6a'` field annihilation operators.\n  This corresponds to the condition that two annihilation operators always super-commute.\n- `[ofCrAnOpF \u03c6, ofCrAnOpF \u03c6']\u209bca` for `\u03c6` and `\u03c6'` operators with different statistics.\n  This corresponds to the condition that two operators with different statistics always\n  super-commute. In other words, fermions and bosons always super-commute.\n- `[ofCrAnOpF \u03c61, [ofCrAnOpF \u03c62, ofCrAnOpF \u03c63]\u209bca]\u209bca`. This corresponds to the condition,\n  when combined with the conditions above, that the super-commutator is in the center of the\n  of the algebra.\n-/\nabbrev FieldOpAlgebra : Type := (TwoSidedIdeal.span \ud835\udcd5.fieldOpIdealSet).ringCon.Quotient\n\nnamespace FieldOpAlgebra\nvariable {\ud835\udcd5 : FieldSpecification}\n\n/-- The instance of a setoid on `FieldOpFreeAlgebra` from the ideal `TwoSidedIdeal`. -/\ninstance : Setoid (FieldOpFreeAlgebra \ud835\udcd5) := (TwoSidedIdeal.span \ud835\udcd5.fieldOpIdealSet).ringCon.toSetoid\n\nlemma equiv_iff_sub_mem_ideal (x y : FieldOpFreeAlgebra \ud835\udcd5) :\n    x \u2248 y \u2194 x - y \u2208 TwoSidedIdeal.span \ud835\udcd5.fieldOpIdealSet := by\n  rw [\u2190 TwoSidedIdeal.rel_iff]\n  rfl\n\nlemma equiv_iff_exists_add (x y : FieldOpFreeAlgebra \ud835\udcd5) :\n    x \u2248 y \u2194 \u2203 a, x = y + a \u2227 a \u2208 TwoSidedIdeal.span \ud835\udcd5.fieldOpIdealSet := by\n  apply Iff.intro\n  \u00b7 intro h\n    rw [equiv_iff_sub_mem_ideal] at h\n    use x - y\n    simp [h]\n  \u00b7 intro h\n    obtain \u27e8a, rfl, ha\u27e9 := h\n    rw [equiv_iff_sub_mem_ideal]\n    simp [ha]\n\n/-- For a field specification `\ud835\udcd5`, the projection\n\n`\ud835\udcd5.FieldOpFreeAlgebra \u2192\u2090[\u2102] FieldOpAlgebra \ud835\udcd5`\n\ntaking each element of `\ud835\udcd5.FieldOpFreeAlgebra` to its equivalence class in `FieldOpAlgebra \ud835\udcd5`. -/\ndef \u03b9 : FieldOpFreeAlgebra \ud835\udcd5 \u2192\u2090[\u2102] FieldOpAlgebra \ud835\udcd5 where\n  toFun := (TwoSidedIdeal.span \ud835\udcd5.fieldOpIdealSet).ringCon.mk'\n  map_one' := by rfl\n  map_mul' x y := by rfl\n  map_zero' := by rfl\n  map_add' x y := by rfl\n  commutes' x := by rfl\n\nlemma \u03b9_surjective : Function.Surjective (@\u03b9 \ud835\udcd5) := by\n  intro x\n  obtain \u27e8x\u27e9 := x\n  use x\n  rfl\n\nlemma \u03b9_apply (x : FieldOpFreeAlgebra \ud835\udcd5) : \u03b9 x = Quotient.mk _ x := rfl\n\nlemma \u03b9_of_mem_fieldOpIdealSet (x : FieldOpFreeAlgebra \ud835\udcd5) (hx : x \u2208 \ud835\udcd5.fieldOpIdealSet) :\n    \u03b9 x = 0 := by\n  rw [\u03b9_apply]\n  change \u27e6x\u27e7 = \u27e60\u27e7\n  simp only [ringConGen, Quotient.eq]\n  refine RingConGen.Rel.of x 0 ?_\n  simpa using hx\n\nlemma \u03b9_superCommuteF_of_create_create (\u03c6c \u03c6c' : \ud835\udcd5.CrAnFieldOp) (h\u03c6c : \ud835\udcd5 |>\u1d9c \u03c6c = .create)\n    (h\u03c6c' : \ud835\udcd5 |>\u1d9c \u03c6c' = .create) : \u03b9 [ofCrAnOpF \u03c6c, ofCrAnOpF \u03c6c']\u209bca = 0 := by\n  apply \u03b9_of_mem_fieldOpIdealSet\n  simp only [fieldOpIdealSet, exists_and_left, Set.mem_setOf_eq]\n  simp only [exists_prop]\n  right\n  left\n  use \u03c6c, \u03c6c', h\u03c6c, h\u03c6c'\n\nlemma \u03b9_superCommuteF_of_annihilate_annihilate (\u03c6a \u03c6a' : \ud835\udcd5.CrAnFieldOp)\n    (h\u03c6a : \ud835\udcd5 |>\u1d9c \u03c6a = .annihilate) (h\u03c6a' : \ud835\udcd5 |>\u1d9c \u03c6a' = .annihilate) :\n    \u03b9 [ofCrAnOpF \u03c6a, ofCrAnOpF \u03c6a']\u209bca = 0 := by\n  apply \u03b9_of_mem_fieldOpIdealSet\n  simp only [fieldOpIdealSet, exists_and_left, Set.mem_setOf_eq]\n  simp only [exists_prop]\n  right\n  right\n  left\n  use \u03c6a, \u03c6a', h\u03c6a, h\u03c6a'\n\nlemma \u03b9_superCommuteF_of_diff_statistic {\u03c6 \u03c8 : \ud835\udcd5.CrAnFieldOp}\n    (h : (\ud835\udcd5 |>\u209b \u03c6) \u2260 (\ud835\udcd5 |>\u209b \u03c8)) : \u03b9 [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca = 0 := by\n  apply \u03b9_of_mem_fieldOpIdealSet\n  simp only [fieldOpIdealSet, exists_prop, exists_and_left, Set.mem_setOf_eq]\n  right\n  right\n  right\n  use \u03c6, \u03c8\n\n", "theoremStatement": "lemma \u03b9_superCommuteF_zero_of_fermionic (\u03c6 \u03c8 : \ud835\udcd5.CrAnFieldOp)\n    (h : [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca \u2208 statisticSubmodule fermionic) :\n    \u03b9 [ofCrAnOpF \u03c6, ofCrAnOpF \u03c8]\u209bca = 0 ", "theoremName": "FieldSpecification.FieldOpAlgebra.\u03b9_superCommuteF_zero_of_fermionic", "fileCreated": {"commit": "ea6e12829370d9630a7e65200c8349e9086c05ba", "date": "2025-02-03"}, "theoremCreated": {"commit": "289050c8295ee3d301068a0e283ebe00807a241c", "date": "2025-01-30"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpAlgebra/Basic.lean", "module": "HepLean.PerturbationTheory.FieldOpAlgebra.Basic", "jsonFile": "HepLean.PerturbationTheory.FieldOpAlgebra.Basic.jsonl", "positionMetadata": {"lineInFile": 131, "tokenPositionInFile": 4764, "theoremPositionInFile": 10}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 18, "numPremises": 95}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton] at h \u22a2\n  rcases statistic_neq_of_superCommuteF_fermionic h with h | h\n  \u00b7 simp only [ofCrAnListF_singleton]\n    apply \u03b9_superCommuteF_of_diff_statistic\n    simpa using h\n  \u00b7 simp [h]", "proofType": "tactic", "proofLengthLines": 6, "proofLengthTokens": 244}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.Basic\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.Grading\n/-!\n\n# Super Commute\n-/\n\nnamespace FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\nnamespace FieldOpFreeAlgebra\n\n/-!\n\n## The super commutator on the FieldOpFreeAlgebra.\n\n-/\n\nopen FieldStatistic\n\n/-- For a field specification `\ud835\udcd5`, the super commutator `superCommuteF` is defined as the linear\n  map `\ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102] \ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102] \ud835\udcd5.FieldOpFreeAlgebra`\n  which on the lists `\u03c6s` and `\u03c6s'` of `\ud835\udcd5.CrAnFieldOp` gives\n\n  `superCommuteF \u03c6s \u03c6s' = \u03c6s * \u03c6s' - \ud835\udce2(\u03c6s, \u03c6s') \u2022 \u03c6s' * \u03c6s`.\n\n  The notation `[a, b]\u209bca` can be used for `superCommuteF a b`. -/\nnoncomputable def superCommuteF : \ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102] \ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102]\n    \ud835\udcd5.FieldOpFreeAlgebra :=\n  Basis.constr ofCrAnListFBasis \u2102 fun \u03c6s =>\n  Basis.constr ofCrAnListFBasis \u2102 fun \u03c6s' =>\n  ofCrAnListF (\u03c6s ++ \u03c6s') - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnListF (\u03c6s' ++ \u03c6s)\n\n@[inherit_doc superCommuteF]\nscoped[FieldSpecification.FieldOpFreeAlgebra] notation \"[\" \u03c6s \",\" \u03c6s' \"]\u209bca\" => superCommuteF \u03c6s \u03c6s'\n\n/-!\n\n## The super commutator of different types of elements\n\n-/\n\nlemma superCommuteF_ofCrAnListF_ofCrAnListF (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnListF \u03c6s, ofCrAnListF \u03c6s']\u209bca =\n    ofCrAnListF (\u03c6s ++ \u03c6s') - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnListF (\u03c6s' ++ \u03c6s) := by\n  rw [\u2190 ofListBasis_eq_ofList, \u2190 ofListBasis_eq_ofList]\n  simp only [superCommuteF, Basis.constr_basis]\n\nlemma superCommuteF_ofCrAnOpF_ofCrAnOpF (\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnOpF \u03c6, ofCrAnOpF \u03c6']\u209bca =\n    ofCrAnOpF \u03c6 * ofCrAnOpF \u03c6' - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 ofCrAnOpF \u03c6' * ofCrAnOpF \u03c6 := by\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton]\n  rw [superCommuteF_ofCrAnListF_ofCrAnListF, ofCrAnListF_append]\n  congr\n  rw [ofCrAnListF_append]\n  rw [FieldStatistic.ofList_singleton, FieldStatistic.ofList_singleton, smul_mul_assoc]\n\nlemma superCommuteF_ofCrAnListF_ofFieldOpFsList (\u03c6cas : List \ud835\udcd5.CrAnFieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [ofCrAnListF \u03c6cas, ofFieldOpListF \u03c6s]\u209bca = ofCrAnListF \u03c6cas * ofFieldOpListF \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6cas, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpListF \u03c6s * ofCrAnListF \u03c6cas := by\n  conv_lhs => rw [ofFieldOpListF_sum]\n  rw [map_sum]\n  conv_lhs =>\n    enter [2, x]\n    rw [superCommuteF_ofCrAnListF_ofCrAnListF, CrAnSection.statistics_eq_state_statistics,\n      ofCrAnListF_append, ofCrAnListF_append]\n  rw [Finset.sum_sub_distrib, \u2190 Finset.mul_sum, \u2190 Finset.smul_sum,\n    \u2190 Finset.sum_mul, \u2190 ofFieldOpListF_sum]\n  simp\n\nlemma superCommuteF_ofFieldOpListF_ofFieldOpFsList (\u03c6 : List \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [ofFieldOpListF \u03c6, ofFieldOpListF \u03c6s]\u209bca = ofFieldOpListF \u03c6 * ofFieldOpListF \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpListF \u03c6s * ofFieldOpListF \u03c6 := by\n  conv_lhs => rw [ofFieldOpListF_sum]\n  simp only [map_sum, LinearMap.coeFn_sum, Finset.sum_apply, instCommGroup.eq_1,\n    Algebra.smul_mul_assoc]\n  conv_lhs =>\n    enter [2, x]\n    rw [superCommuteF_ofCrAnListF_ofFieldOpFsList]\n  simp only [instCommGroup.eq_1, CrAnSection.statistics_eq_state_statistics,\n    Algebra.smul_mul_assoc, Finset.sum_sub_distrib]\n  rw [\u2190 Finset.sum_mul, \u2190 Finset.smul_sum, \u2190 Finset.mul_sum, \u2190 ofFieldOpListF_sum]\n\nlemma superCommuteF_ofFieldOpF_ofFieldOpFsList (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [ofFieldOpF \u03c6, ofFieldOpListF \u03c6s]\u209bca = ofFieldOpF \u03c6 * ofFieldOpListF \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpListF \u03c6s * ofFieldOpF \u03c6 := by\n  rw [\u2190 ofFieldOpListF_singleton, superCommuteF_ofFieldOpListF_ofFieldOpFsList,\n    ofFieldOpListF_singleton]\n  simp\n\nlemma superCommuteF_ofFieldOpListF_ofFieldOpF (\u03c6s : List \ud835\udcd5.FieldOp) (\u03c6 : \ud835\udcd5.FieldOp) :\n    [ofFieldOpListF \u03c6s, ofFieldOpF \u03c6]\u209bca = ofFieldOpListF \u03c6s * ofFieldOpF \u03c6 -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6) \u2022 ofFieldOpF \u03c6 * ofFieldOpListF \u03c6s := by\n  rw [\u2190 ofFieldOpListF_singleton, superCommuteF_ofFieldOpListF_ofFieldOpFsList,\n    ofFieldOpListF_singleton]\n  simp\n\nlemma superCommuteF_anPartF_crPartF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [anPartF \u03c6, crPartF \u03c6']\u209bca = anPartF \u03c6 * crPartF \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 crPartF \u03c6' * anPartF \u03c6 := by\n  match \u03c6, \u03c6' with\n  | FieldOp.inAsymp \u03c6, _ =>\n    simp\n  | _, FieldOp.outAsymp \u03c6 =>\n    simp only [crPartF_posAsymp, map_zero, mul_zero, instCommGroup.eq_1, smul_zero, zero_mul,\n      sub_self]\n  | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n    simp only [anPartF_position, crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.outAsymp \u03c6, FieldOp.position \u03c6' =>\n    simp only [anPartF_posAsymp, crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.position \u03c6, FieldOp.inAsymp \u03c6' =>\n    simp only [anPartF_position, crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp only [List.singleton_append, instCommGroup.eq_1, crAnStatistics,\n      FieldStatistic.ofList_singleton, Function.comp_apply, crAnFieldOpToFieldOp_prod, \u2190\n      ofCrAnListF_append]\n  | FieldOp.outAsymp \u03c6, FieldOp.inAsymp \u03c6' =>\n    simp only [anPartF_posAsymp, crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n\nlemma superCommuteF_crPartF_anPartF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [crPartF \u03c6, anPartF \u03c6']\u209bca = crPartF \u03c6 * anPartF \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 anPartF \u03c6' * crPartF \u03c6 := by\n    match \u03c6, \u03c6' with\n    | FieldOp.outAsymp \u03c6, _ =>\n    simp only [crPartF_posAsymp, map_zero, LinearMap.zero_apply, zero_mul, instCommGroup.eq_1,\n      mul_zero, sub_self]\n    | _, FieldOp.inAsymp \u03c6 =>\n    simp only [anPartF_negAsymp, map_zero, mul_zero, instCommGroup.eq_1, smul_zero, zero_mul,\n      sub_self]\n    | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n    simp only [crPartF_position, anPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n    | FieldOp.position \u03c6, FieldOp.outAsymp \u03c6' =>\n    simp only [crPartF_position, anPartF_posAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n    | FieldOp.inAsymp \u03c6, FieldOp.position \u03c6' =>\n    simp only [crPartF_negAsymp, anPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n    | FieldOp.inAsymp \u03c6, FieldOp.outAsymp \u03c6' =>\n    simp only [crPartF_negAsymp, anPartF_posAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n\nlemma superCommuteF_crPartF_crPartF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [crPartF \u03c6, crPartF \u03c6']\u209bca = crPartF \u03c6 * crPartF \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 crPartF \u03c6' * crPartF \u03c6 := by\n  match \u03c6, \u03c6' with\n  | FieldOp.outAsymp \u03c6, _ =>\n  simp only [crPartF_posAsymp, map_zero, LinearMap.zero_apply, zero_mul, instCommGroup.eq_1,\n    mul_zero, sub_self]\n  | _, FieldOp.outAsymp \u03c6 =>\n  simp only [crPartF_posAsymp, map_zero, mul_zero, instCommGroup.eq_1, smul_zero, zero_mul,\n    sub_self]\n  | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n  simp only [crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.position \u03c6, FieldOp.inAsymp \u03c6' =>\n  simp only [crPartF_position, crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.inAsymp \u03c6, FieldOp.position \u03c6' =>\n  simp only [crPartF_negAsymp, crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.inAsymp \u03c6, FieldOp.inAsymp \u03c6' =>\n  simp only [crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp [crAnStatistics, \u2190 ofCrAnListF_append]\n\nlemma superCommuteF_anPartF_anPartF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [anPartF \u03c6, anPartF \u03c6']\u209bca =\n    anPartF \u03c6 * anPartF \u03c6' - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 anPartF \u03c6' * anPartF \u03c6 := by\n  match \u03c6, \u03c6' with\n  | FieldOp.inAsymp \u03c6, _ =>\n    simp\n  | _, FieldOp.inAsymp \u03c6 =>\n    simp\n  | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n    simp only [anPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.position \u03c6, FieldOp.outAsymp \u03c6' =>\n    simp only [anPartF_position, anPartF_posAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.outAsymp \u03c6, FieldOp.position \u03c6' =>\n    simp only [anPartF_posAsymp, anPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.outAsymp \u03c6, FieldOp.outAsymp \u03c6' =>\n    simp only [anPartF_posAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n\nlemma superCommuteF_crPartF_ofFieldOpListF (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [crPartF \u03c6, ofFieldOpListF \u03c6s]\u209bca =\n    crPartF \u03c6 * ofFieldOpListF \u03c6s - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpListF \u03c6s *\n    crPartF \u03c6 := by\n  match \u03c6 with\n  | FieldOp.inAsymp \u03c6 =>\n    simp only [crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofFieldOpFsList]\n    simp [crAnStatistics]\n  | FieldOp.position \u03c6 =>\n    simp only [crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofFieldOpFsList]\n    simp [crAnStatistics]\n  | FieldOp.outAsymp \u03c6 =>\n    simp\n\n", "theoremStatement": "lemma superCommuteF_anPartF_ofFieldOpListF (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [anPartF \u03c6, ofFieldOpListF \u03c6s]\u209bca =\n    anPartF \u03c6 * ofFieldOpListF \u03c6s - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022\n    ofFieldOpListF \u03c6s * anPartF \u03c6 ", "theoremName": "FieldSpecification.FieldOpFreeAlgebra.superCommuteF_anPartF_ofFieldOpListF", "fileCreated": {"commit": "ea6e12829370d9630a7e65200c8349e9086c05ba", "date": "2025-02-03"}, "theoremCreated": {"commit": "08260e709c7882cac7906bc05fe5fb9d03c44ba0", "date": "2025-02-03"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpFreeAlgebra/SuperCommute.lean", "module": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.SuperCommute", "jsonFile": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.SuperCommute.jsonl", "positionMetadata": {"lineInFile": 226, "tokenPositionInFile": 10975, "theoremPositionInFile": 13}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 33, "numPremises": 146}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  match \u03c6 with\n  | FieldOp.inAsymp \u03c6 =>\n    simp\n  | FieldOp.position \u03c6 =>\n    simp only [anPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofFieldOpFsList]\n    simp [crAnStatistics]\n  | FieldOp.outAsymp \u03c6 =>\n    simp only [anPartF_posAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofFieldOpFsList]\n    simp [crAnStatistics]", "proofType": "tactic", "proofLengthLines": 11, "proofLengthTokens": 464}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.WickContraction.ExtractEquiv\n/-!\n\n# List of uncontracted elements of a Wick contraction\n\n-/\n\nopen FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\nnamespace WickContraction\nvariable {n : \u2115} (c : WickContraction n)\nopen HepLean.List\nopen HepLean.Fin\n\n/-!\n\n## Some properties of lists of fin\n\n-/\n\nlemma fin_list_sorted_monotone_sorted {n m : \u2115} (l: List (Fin n)) (hl : l.Sorted (\u00b7 \u2264 \u00b7))\n    (f : Fin n \u2192 Fin m) (hf : StrictMono f) : ((List.map f l)).Sorted (\u00b7 \u2264 \u00b7) := by\n  induction l with\n  | nil => simp\n  | cons a l ih =>\n    simp only [List.map_cons, List.sorted_cons, List.mem_map, forall_exists_index, and_imp,\n      forall_apply_eq_imp_iff\u2082]\n    apply And.intro\n    \u00b7 simp only [List.sorted_cons] at hl\n      intro b hb\n      have hl1 := hl.1 b hb\n      exact (StrictMono.le_iff_le hf).mpr hl1\n    \u00b7 simp only [List.sorted_cons] at hl\n      exact ih hl.2\n\nlemma fin_list_sorted_succAboveEmb_sorted (l: List (Fin n)) (hl : l.Sorted (\u00b7 \u2264 \u00b7))\n    (i : Fin n.succ) : ((List.map i.succAboveEmb l)).Sorted (\u00b7 \u2264 \u00b7) := by\n  apply fin_list_sorted_monotone_sorted\n  exact hl\n  simp only [Fin.coe_succAboveEmb]\n  exact Fin.strictMono_succAbove i\n\nlemma fin_finset_sort_map_monotone {n m : \u2115} (a : Finset (Fin n)) (f : Fin n \u21aa Fin m)\n    (hf : StrictMono f) : (Finset.sort (\u00b7 \u2264 \u00b7) a).map f =\n    (Finset.sort (\u00b7 \u2264 \u00b7) (a.map f)) := by\n  have h1 : ((Finset.sort (\u00b7 \u2264 \u00b7) a).map f).Sorted (\u00b7 \u2264 \u00b7) := by\n    apply fin_list_sorted_monotone_sorted\n    exact Finset.sort_sorted (fun x1 x2 => x1 \u2264 x2) a\n    exact hf\n  have h2 : ((Finset.sort (\u00b7 \u2264 \u00b7) a).map f).Nodup := by\n    refine (List.nodup_map_iff_inj_on ?_).mpr ?_\n    exact Finset.sort_nodup (fun x1 x2 => x1 \u2264 x2) a\n    intro a ha b hb hf\n    exact f.2 hf\n  have h3 : ((Finset.sort (\u00b7 \u2264 \u00b7) a).map f).toFinset = (a.map f) := by\n    ext a\n    simp\n  rw [\u2190 h3]\n  exact ((List.toFinset_sort (\u00b7 \u2264 \u00b7) h2).mpr h1).symm\n\nlemma fin_list_sorted_split :\n    (l : List (Fin n)) \u2192 (hl : l.Sorted (\u00b7 \u2264 \u00b7)) \u2192 (i : \u2115) \u2192\n    l = l.filter (fun x => x.1 < i) ++ l.filter (fun x => i \u2264 x.1)\n  | [], _, _ => by simp\n  | a :: l, hl, i => by\n    simp only [List.sorted_cons] at hl\n    by_cases ha : a < i\n    \u00b7 conv_lhs => rw [fin_list_sorted_split l hl.2 i]\n      rw [\u2190 List.cons_append]\n      rw [List.filter_cons_of_pos, List.filter_cons_of_neg]\n      simp only [decide_eq_true_eq, not_le, ha]\n      simp [ha]\n    \u00b7 have hx : List.filter (fun x => decide (x.1 < i)) (a :: l) = [] := by\n        simp only [ha, decide_false, Bool.false_eq_true, not_false_eq_true, List.filter_cons_of_neg,\n          List.filter_eq_nil_iff, decide_eq_true_eq, not_lt]\n        intro b hb\n        have hb' := hl.1 b hb\n        omega\n      simp only [hx, List.nil_append]\n      rw [List.filter_cons_of_pos]\n      simp only [List.cons.injEq, true_and]\n      have hl' := fin_list_sorted_split l hl.2 i\n      have hx : List.filter (fun x => decide (x.1 < i)) (l) = [] := by\n        simp only [List.filter_eq_nil_iff, decide_eq_true_eq, not_lt]\n        intro b hb\n        have hb' := hl.1 b hb\n        omega\n      simp only [hx, List.nil_append] at hl'\n      conv_lhs => rw [hl']\n      simp only [decide_eq_true_eq]\n      omega\n\nlemma fin_list_sorted_indexOf_filter_le_mem :\n    (l : List (Fin n)) \u2192 (hl : l.Sorted (\u00b7 \u2264 \u00b7)) \u2192 (i : Fin n) \u2192\n    (hl : i \u2208 l) \u2192\n    List.indexOf i (List.filter (fun x => decide (\u2191i \u2264 \u2191x)) l) = 0\n  | [], _, _, _ => by simp\n  | a :: l, hl, i, hi => by\n    simp only [List.sorted_cons] at hl\n    by_cases ha : i \u2264 a\n    \u00b7 simp only [ha, decide_true, List.filter_cons_of_pos]\n      have ha : a = i := by\n        simp only [List.mem_cons] at hi\n        rcases hi with hi | hi\n        \u00b7 subst hi\n          rfl\n        \u00b7 have hl' := hl.1 i hi\n          exact Fin.le_antisymm hl' ha\n      subst ha\n      simp\n    \u00b7 simp only [not_le] at ha\n      rw [List.filter_cons_of_neg (by simpa using ha)]\n      rw [fin_list_sorted_indexOf_filter_le_mem l hl.2]\n      simp only [List.mem_cons] at hi\n      rcases hi with hi | hi\n      \u00b7 omega\n      \u00b7 exact hi\n\nlemma fin_list_sorted_indexOf_mem :\n    (l : List (Fin n)) \u2192 (hl : l.Sorted (\u00b7 \u2264 \u00b7)) \u2192 (i : Fin n) \u2192\n    (hi : i \u2208 l) \u2192\n    l.indexOf i = (l.filter (fun x => x.1 < i.1)).length := by\n  intro l hl i hi\n  conv_lhs => rw [fin_list_sorted_split l hl i]\n  rw [List.indexOf_append_of_not_mem]\n  erw [fin_list_sorted_indexOf_filter_le_mem l hl i hi]\n  \u00b7 simp\n  \u00b7 simp\n\nlemma orderedInsert_of_fin_list_sorted :\n    (l : List (Fin n)) \u2192 (hl : l.Sorted (\u00b7 \u2264 \u00b7)) \u2192 (i : Fin n) \u2192\n    List.orderedInsert (\u00b7 \u2264 \u00b7) i l = l.filter (fun x => x.1 < i.1) ++\n    i :: l.filter (fun x => i.1 \u2264 x.1)\n  | [], _, _ => by simp\n  | a :: l, hl, i => by\n    simp only [List.sorted_cons] at hl\n    by_cases ha : i \u2264 a\n    \u00b7 simp only [List.orderedInsert, ha, \u2193reduceIte, Fin.val_fin_lt, decide_eq_true_eq, not_lt,\n      List.filter_cons_of_neg, Fin.val_fin_le, decide_true, List.filter_cons_of_pos]\n      have h1 : List.filter (fun x => decide (\u2191x < \u2191i)) l = [] := by\n        simp only [List.filter_eq_nil_iff, decide_eq_true_eq, not_lt]\n        intro a ha\n        have ha' := hl.1 a ha\n        omega\n      have hl : l = List.filter (fun x => decide (i \u2264 x)) l := by\n        conv_lhs => rw [fin_list_sorted_split l hl.2 i]\n        simp [h1]\n      simp [\u2190 hl, h1]\n    \u00b7 simp only [List.orderedInsert, ha, \u2193reduceIte, Fin.val_fin_lt, Fin.val_fin_le, decide_false,\n      Bool.false_eq_true, not_false_eq_true, List.filter_cons_of_neg]\n      rw [List.filter_cons_of_pos]\n      rw [orderedInsert_of_fin_list_sorted l hl.2 i]\n      simp only [Fin.val_fin_lt, Fin.val_fin_le, List.cons_append]\n      simp only [decide_eq_true_eq]\n      omega\n\nlemma orderedInsert_eq_insertIdx_of_fin_list_sorted (l : List (Fin n)) (hl : l.Sorted (\u00b7 \u2264 \u00b7))\n    (i : Fin n) :\n    List.orderedInsert (\u00b7 \u2264 \u00b7) i l = l.insertIdx (l.filter (fun x => x.1 < i.1)).length i := by\n  let n : Fin l.length.succ := \u27e8(List.filter (fun x => decide (x < i)) l).length, by\n    have h1 := l.length_filter_le (fun x => x.1 < i.1)\n    simp only [Fin.val_fin_lt] at h1\n    omega\u27e9\n  simp only [Fin.val_fin_lt]\n  conv_rhs => rw [insertIdx_eq_take_drop _ _ n]\n  rw [orderedInsert_of_fin_list_sorted]\n  congr\n  \u00b7 conv_rhs =>\n      rhs\n      rw [fin_list_sorted_split l hl i]\n    simp [n]\n  \u00b7 conv_rhs =>\n      rhs\n      rw [fin_list_sorted_split l hl i]\n    simp [n]\n  exact hl\n\n/-!\n\n## Uncontracted List\n\n-/\n\n/-- Given a Wick contraction `c`, the ordered list of elements of `Fin n` which are not contracted,\n  i.e. do not appear anywhere in `c.1`. -/\ndef uncontractedList : List (Fin n) := List.filter (fun x => x \u2208 c.uncontracted) (List.finRange n)\n\nlemma uncontractedList_mem_iff (i : Fin n) :\n    i \u2208 c.uncontractedList \u2194 i \u2208 c.uncontracted := by\n  simp [uncontractedList]\n\n@[simp]\nlemma uncontractedList_empty : (empty (n := n)).uncontractedList = List.finRange n := by\n  simp [uncontractedList]\n\nlemma nil_zero_uncontractedList : (empty (n := 0)).uncontractedList = [] := by\n  simp [empty, uncontractedList]\n\nlemma congr_uncontractedList {n m : \u2115} (h : n = m) (c : WickContraction n) :\n    ((congr h) c).uncontractedList = List.map (finCongr h) c.uncontractedList := by\n  subst h\n  simp [congr]\n\nlemma uncontractedList_get_mem_uncontracted (i : Fin c.uncontractedList.length) :\n    c.uncontractedList.get i \u2208 c.uncontracted := by\n  rw [\u2190 uncontractedList_mem_iff]\n  simp\n\nlemma uncontractedList_sorted : List.Sorted (\u00b7 \u2264 \u00b7) c.uncontractedList := by\n  rw [uncontractedList]\n  apply List.Sorted.filter\n  rw [\u2190 List.ofFn_id]\n  exact Monotone.ofFn_sorted fun \u2983a b\u2984 a => a\n\nlemma uncontractedList_sorted_lt : List.Sorted (\u00b7 < \u00b7) c.uncontractedList := by\n  rw [uncontractedList]\n  apply List.Sorted.filter\n  rw [\u2190 List.ofFn_id]\n  exact List.sorted_lt_ofFn_iff.mpr fun \u2983a b\u2984 a => a\n\nlemma uncontractedList_nodup : c.uncontractedList.Nodup := by\n  rw [uncontractedList]\n  refine List.Nodup.filter (fun x => decide (x \u2208 c.uncontracted)) ?_\n  exact List.nodup_finRange n\n\nlemma uncontractedList_toFinset (c : WickContraction n) :\n    c.uncontractedList.toFinset = c.uncontracted := by\n  simp [uncontractedList]\n\nlemma uncontractedList_eq_sort (c : WickContraction n) :\n    c.uncontractedList = c.uncontracted.sort (\u00b7 \u2264 \u00b7) := by\n  symm\n  rw [\u2190 uncontractedList_toFinset]\n  refine (List.toFinset_sort (\u03b1 := Fin n) (\u00b7 \u2264 \u00b7) ?_).mpr ?_\n  \u00b7 exact uncontractedList_nodup c\n  \u00b7 exact uncontractedList_sorted c\n\nlemma uncontractedList_length_eq_card (c : WickContraction n) :\n    c.uncontractedList.length = c.uncontracted.card := by\n  rw [uncontractedList_eq_sort]\n  exact Finset.length_sort fun x1 x2 => x1 \u2264 x2\n\nlemma filter_uncontractedList (c : WickContraction n) (p : Fin n \u2192 Prop) [DecidablePred p] :\n    (c.uncontractedList.filter p) = (c.uncontracted.filter p).sort (\u00b7 \u2264 \u00b7) := by\n  have h1 : (c.uncontractedList.filter p).Sorted (\u00b7 \u2264 \u00b7) := by\n    apply List.Sorted.filter\n    exact uncontractedList_sorted c\n  have h2 : (c.uncontractedList.filter p).Nodup := by\n    refine List.Nodup.filter _ ?_\n    exact uncontractedList_nodup c\n  have h3 : (c.uncontractedList.filter p).toFinset = (c.uncontracted.filter p) := by\n    ext a\n    simp only [List.toFinset_filter, decide_eq_true_eq, Finset.mem_filter, List.mem_toFinset,\n      and_congr_left_iff]\n    rw [uncontractedList_mem_iff]\n    simp\n  have hx := (List.toFinset_sort (\u00b7 \u2264 \u00b7) h2).mpr h1\n  rw [\u2190 hx, h3]\n\n/-!\n\n## uncontractedIndexEquiv\n\n-/\n\n/-- The equivalence between the positions of `c.uncontractedList` i.e. elements of\n  `Fin (c.uncontractedList).length` and the finite set `c.uncontracted` considered as a finite type.\n-/\ndef uncontractedIndexEquiv (c : WickContraction n) :\n    Fin (c.uncontractedList).length \u2243 c.uncontracted where\n  toFun i := \u27e8c.uncontractedList.get i, c.uncontractedList_get_mem_uncontracted i\u27e9\n  invFun i := \u27e8List.indexOf i.1 c.uncontractedList,\n    List.indexOf_lt_length_iff.mpr ((c.uncontractedList_mem_iff i.1).mpr i.2)\u27e9\n  left_inv i := by\n    ext\n    exact List.get_indexOf (uncontractedList_nodup c) _\n  right_inv i := by\n    ext\n    simp\n\n@[simp]\nlemma uncontractedList_getElem_uncontractedIndexEquiv_symm (k : c.uncontracted) :\n    c.uncontractedList[(c.uncontractedIndexEquiv.symm k).val] = k := by\n  simp [uncontractedIndexEquiv]\n\nlemma uncontractedIndexEquiv_symm_eq_filter_length (k : c.uncontracted) :\n    (c.uncontractedIndexEquiv.symm k).val =\n    (List.filter (fun i => i < k.val) c.uncontractedList).length := by\n  simp only [uncontractedIndexEquiv, List.get_eq_getElem, Equiv.coe_fn_symm_mk]\n  rw [fin_list_sorted_indexOf_mem]\n  \u00b7 simp\n  \u00b7 exact uncontractedList_sorted c\n  \u00b7 rw [uncontractedList_mem_iff]\n    exact k.2\n\nlemma take_uncontractedIndexEquiv_symm (k : c.uncontracted) :\n    c.uncontractedList.take (c.uncontractedIndexEquiv.symm k).val =\n    c.uncontractedList.filter (fun i => i < k.val) := by\n  have hl := fin_list_sorted_split c.uncontractedList (uncontractedList_sorted c) k.val\n  conv_lhs =>\n    rhs\n    rw [hl]\n  rw [uncontractedIndexEquiv_symm_eq_filter_length]\n  simp\n/-!\n\n## Uncontracted List get\n\n-/\n\n/-- Given a Wick Contraction `\u03c6s\u039b` of a list `\u03c6s` of `\ud835\udcd5.FieldOp`. The list\n  `\u03c6s\u039b.uncontractedListGet` of `\ud835\udcd5.FieldOp` is defined as the list `\u03c6s` with\n  all contracted positions removed, leaving the uncontracted `\ud835\udcd5.FieldOp`.\n\n  The notation `[\u03c6s\u039b]\u1d58\u1d9c` is used for `\u03c6s\u039b.uncontractedListGet`. -/\ndef uncontractedListGet {\u03c6s : List \ud835\udcd5.FieldOp} (\u03c6s\u039b : WickContraction \u03c6s.length) :\n    List \ud835\udcd5.FieldOp := \u03c6s\u039b.uncontractedList.map \u03c6s.get\n\n@[inherit_doc uncontractedListGet]\nscoped[WickContraction] notation \"[\" \u03c6s\u039b \"]\u1d58\u1d9c\" => uncontractedListGet \u03c6s\u039b\n\n@[simp]\nlemma uncontractedListGet_empty {\u03c6s : List \ud835\udcd5.FieldOp} :\n    (empty (n := \u03c6s.length)).uncontractedListGet = \u03c6s := by\n  simp [uncontractedListGet]\n\n/-!\n\n## uncontractedFieldOpEquiv\n\n-/\n\n/-- The equivalence between the type `Option c.uncontracted` for `WickContraction \u03c6s.length` and\n  `Option (Fin (c.uncontractedList.map \u03c6s.get).length)`, that is optional positions of\n  `c.uncontractedList.map \u03c6s.get` induced by `uncontractedIndexEquiv`. -/\ndef uncontractedFieldOpEquiv (\u03c6s : List \ud835\udcd5.FieldOp) (\u03c6s\u039b : WickContraction \u03c6s.length) :\n    Option \u03c6s\u039b.uncontracted \u2243 Option (Fin [\u03c6s\u039b]\u1d58\u1d9c.length) :=\n  Equiv.optionCongr (\u03c6s\u039b.uncontractedIndexEquiv.symm.trans\n    (finCongr (by simp [uncontractedListGet])))\n\n@[simp]\nlemma uncontractedFieldOpEquiv_none (\u03c6s : List \ud835\udcd5.FieldOp) (\u03c6s\u039b : WickContraction \u03c6s.length) :\n    (uncontractedFieldOpEquiv \u03c6s \u03c6s\u039b).toFun none = none := by\n  simp [uncontractedFieldOpEquiv]\n\nlemma uncontractedFieldOpEquiv_list_sum [AddCommMonoid \u03b1] (\u03c6s : List \ud835\udcd5.FieldOp)\n    (\u03c6s\u039b : WickContraction \u03c6s.length) (f : Option (Fin [\u03c6s\u039b]\u1d58\u1d9c.length) \u2192 \u03b1) :\n    \u2211 (i : Option (Fin [\u03c6s\u039b]\u1d58\u1d9c.length)), f i =\n    \u2211 (i : Option \u03c6s\u039b.uncontracted), f (\u03c6s\u039b.uncontractedFieldOpEquiv \u03c6s i) := by\n  rw [(\u03c6s\u039b.uncontractedFieldOpEquiv \u03c6s).sum_comp]\n\n/-!\n\n## uncontractedListEmd\n\n-/\n\n/-- The embedding of `Fin [\u03c6s\u039b]\u1d58\u1d9c.length` into `Fin \u03c6s.length`. -/\ndef uncontractedListEmd {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length} :\n    Fin [\u03c6s\u039b]\u1d58\u1d9c.length \u21aa Fin \u03c6s.length := ((finCongr (by simp [uncontractedListGet])).trans\n  \u03c6s\u039b.uncontractedIndexEquiv).toEmbedding.trans\n  (Function.Embedding.subtype fun x => x \u2208 \u03c6s\u039b.uncontracted)\n\nlemma uncontractedListEmd_congr {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b \u03c6s\u039b' : WickContraction \u03c6s.length}\n    (h : \u03c6s\u039b = \u03c6s\u039b') : \u03c6s\u039b.uncontractedListEmd =\n    (finCongr (by simp [h])).toEmbedding.trans \u03c6s\u039b'.uncontractedListEmd := by\n  subst h\n  rfl\n\nlemma uncontractedListEmd_toFun_eq_get (\u03c6s : List \ud835\udcd5.FieldOp) (\u03c6s\u039b : WickContraction \u03c6s.length) :\n    (uncontractedListEmd (\u03c6s\u039b := \u03c6s\u039b)).toFun =\n    \u03c6s\u039b.uncontractedList.get \u2218 (finCongr (by simp [uncontractedListGet])) := by\n  rfl\n\nlemma uncontractedListEmd_strictMono {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    {i j : Fin [\u03c6s\u039b]\u1d58\u1d9c.length} (h : i < j) : uncontractedListEmd i < uncontractedListEmd j := by\n  simp only [uncontractedListEmd, uncontractedIndexEquiv, List.get_eq_getElem,\n    Equiv.trans_toEmbedding, Function.Embedding.trans_apply, Equiv.coe_toEmbedding, finCongr_apply,\n    Equiv.coe_fn_mk, Fin.coe_cast, Function.Embedding.coe_subtype]\n  exact List.Sorted.get_strictMono \u03c6s\u039b.uncontractedList_sorted_lt h\n\nlemma uncontractedListEmd_mem_uncontracted {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    (i : Fin [\u03c6s\u039b]\u1d58\u1d9c.length) : uncontractedListEmd i \u2208 \u03c6s\u039b.uncontracted := by\n  simp [uncontractedListEmd]\n\nlemma uncontractedListEmd_surjective_mem_uncontracted {\u03c6s : List \ud835\udcd5.FieldOp}\n    {\u03c6s\u039b : WickContraction \u03c6s.length} (i : Fin \u03c6s.length) (hi : i \u2208 \u03c6s\u039b.uncontracted) :\n    \u2203 j, \u03c6s\u039b.uncontractedListEmd j = i := by\n  simp only [uncontractedListEmd, Equiv.trans_toEmbedding, Function.Embedding.trans_apply,\n    Equiv.coe_toEmbedding, finCongr_apply, Function.Embedding.coe_subtype]\n  have hj : \u2203 j, \u03c6s\u039b.uncontractedIndexEquiv j = \u27e8i, hi\u27e9 := by\n    exact \u03c6s\u039b.uncontractedIndexEquiv.surjective \u27e8i, hi\u27e9\n  obtain \u27e8j, hj\u27e9 := hj\n  have hj' : \u2203 j', Fin.cast uncontractedListEmd.proof_1 j' = j := by\n    exact (finCongr uncontractedListEmd.proof_1).surjective j\n  obtain \u27e8j', rfl\u27e9 := hj'\n  use j'\n  rw [hj]\n\n@[simp]\nlemma uncontractedListEmd_finset_disjoint_left {\u03c6s : List \ud835\udcd5.FieldOp}\n    {\u03c6s\u039b : WickContraction \u03c6s.length} (a : Finset (Fin [\u03c6s\u039b]\u1d58\u1d9c.length))\n    (b : Finset (Fin \u03c6s.length)) (hb : b \u2208 \u03c6s\u039b.1) : Disjoint (a.map uncontractedListEmd) b := by\n  rw [Finset.disjoint_left]\n  intro x hx\n  simp only [Finset.mem_map] at hx\n  obtain \u27e8x, hx, rfl\u27e9 := hx\n  have h1 : uncontractedListEmd x \u2208 \u03c6s\u039b.uncontracted :=\n    uncontractedListEmd_mem_uncontracted x\n  rw [mem_uncontracted_iff_not_contracted] at h1\n  exact h1 b hb\n\nlemma uncontractedListEmd_finset_not_mem {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    (a : Finset (Fin [\u03c6s\u039b]\u1d58\u1d9c.length)) :\n    a.map uncontractedListEmd \u2209 \u03c6s\u039b.1 := by\n  by_contra hn\n  have h1 := uncontractedListEmd_finset_disjoint_left a (a.map uncontractedListEmd) hn\n  simp only [disjoint_self, Finset.bot_eq_empty, Finset.map_eq_empty] at h1\n  have h2 := \u03c6s\u039b.2.1 (a.map uncontractedListEmd) hn\n  rw [h1] at h2\n  simp at h2\n\n@[simp]\nlemma getElem_uncontractedListEmd {\u03c6s : List \ud835\udcd5.FieldOp} {\u03c6s\u039b : WickContraction \u03c6s.length}\n    (k : Fin [\u03c6s\u039b]\u1d58\u1d9c.length) : \u03c6s[(uncontractedListEmd k).1] = [\u03c6s\u039b]\u1d58\u1d9c[k.1] := by\n  simp only [uncontractedListGet, List.getElem_map, List.get_eq_getElem]\n  rfl\n\n", "theoremStatement": "@[simp]\nlemma uncontractedListEmd_empty {\u03c6s : List \ud835\udcd5.FieldOp} :\n    (empty (n := \u03c6s.length)).uncontractedListEmd = (finCongr (by simp)).toEmbedding ", "theoremName": "WickContraction.uncontractedListEmd_empty", "fileCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "theoremCreated": {"commit": "12d36dc1d9c726c035301091e57be0b29015e4ae", "date": "2025-01-31"}, "file": "HepLean/HepLean/PerturbationTheory/WickContraction/UncontractedList.lean", "module": "HepLean.PerturbationTheory.WickContraction.UncontractedList", "jsonFile": "HepLean.PerturbationTheory.WickContraction.UncontractedList.jsonl", "positionMetadata": {"lineInFile": 435, "tokenPositionInFile": 16365, "theoremPositionInFile": 36}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 6, "repositoryPremises": true, "numRepositoryPremises": 10, "numPremises": 65}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  ext x\n  simp [uncontractedListEmd, uncontractedIndexEquiv]", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 66}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.Mathematics.Fin.Involutions\nimport HepLean.PerturbationTheory.WickContraction.ExtractEquiv\nimport HepLean.PerturbationTheory.WickContraction.Involutions\n/-!\n\n# Full contraction\n\nWe say that a contraction is full if it has no uncontracted fields.\n\n-/\n\nopen FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\nnamespace WickContraction\nvariable {n : \u2115} (c : WickContraction n)\nopen HepLean.List\nopen FieldStatistic\nopen Nat\n\n/-- A contraction is full if there are no uncontracted fields, i.e. the finite set\n  of uncontracted fields is empty. -/\ndef IsFull : Prop := c.uncontracted = \u2205\n\n/-- The condition on whether or not a contraction is full is decidable. -/\ninstance : Decidable (IsFull c) := decEq c.uncontracted \u2205\n\nlemma isFull_iff_equivInvolution_no_fixed_point :\n    IsFull c \u2194 \u2200 (i : Fin n), (equivInvolution c).1 i \u2260 i := by\n  simp only [IsFull, ne_eq]\n  rw [Finset.eq_empty_iff_forall_not_mem]\n  simp [equivInvolution, toInvolution, uncontracted]\n\n/-- The equivalence between full contractions and fixed-point free involutions. -/\ndef isFullInvolutionEquiv : {c : WickContraction n // IsFull c} \u2243\n    {f : Fin n \u2192 Fin n // Function.Involutive f \u2227 (\u2200 i, f i \u2260 i)} where\n  toFun c := \u27e8equivInvolution c.1, by\n    apply And.intro (equivInvolution c.1).2\n    rw [\u2190 isFull_iff_equivInvolution_no_fixed_point]\n    exact c.2\u27e9\n  invFun f := \u27e8equivInvolution.symm \u27e8f.1, f.2.1\u27e9, by\n    rw [isFull_iff_equivInvolution_no_fixed_point]\n    simpa using f.2.2\u27e9\n  left_inv c := by simp\n  right_inv f := by simp\n\n", "theoremStatement": "/-- If `n` is even then the number of full contractions is `(n-1)!!`. -/\ntheorem card_of_isfull_even (he : Even n) :\n    Fintype.card {c : WickContraction n // IsFull c} = (n - 1)\u203c ", "theoremName": "WickContraction.card_of_isfull_even", "fileCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "theoremCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "file": "HepLean/HepLean/PerturbationTheory/WickContraction/IsFull.lean", "module": "HepLean.PerturbationTheory.WickContraction.IsFull", "jsonFile": "HepLean.PerturbationTheory.WickContraction.IsFull.jsonl", "positionMetadata": {"lineInFile": 51, "tokenPositionInFile": 1683, "theoremPositionInFile": 2}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 7, "numPremises": 28}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [Fintype.card_congr (isFullInvolutionEquiv)]\n  exact HepLean.Fin.involutionNoFixed_card_even n he", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 108}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldSpecification.NormalOrder\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.SuperCommute\nimport HepLean.PerturbationTheory.Koszul.KoszulSign\n/-!\n\n# Normal Ordering in the FieldOpFreeAlgebra\n\nIn the module\n`HepLean.PerturbationTheory.FieldSpecification.NormalOrder`\nwe defined the normal ordering of a list of `CrAnFieldOp`.\nIn this module we extend the normal ordering to a linear map on `FieldOpFreeAlgebra`.\n\nWe derive properties of this normal ordering.\n\n-/\n\nnamespace FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\nopen FieldStatistic\n\nnamespace FieldOpFreeAlgebra\n\nnoncomputable section\n\n/-- For a field specification `\ud835\udcd5`, `normalOrderF` is the linear map\n\n  `FieldOpFreeAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpFreeAlgebra \ud835\udcd5`\n\n  defined by its action on the basis `ofCrAnListF \u03c6s`, taking `ofCrAnListF \u03c6s` to\n\n  `normalOrderSign \u03c6s \u2022 ofCrAnListF (normalOrderList \u03c6s)`.\n\n  That is, `normalOrderF` normal-orders the field operators and multiplies by the sign of the\n  normal order.\n\n  The notation `\ud835\udcdd\u1da0(a)` is used for `normalOrderF a` for `a` an element of\n  `FieldOpFreeAlgebra \ud835\udcd5`. -/\ndef normalOrderF : FieldOpFreeAlgebra \ud835\udcd5 \u2192\u2097[\u2102] FieldOpFreeAlgebra \ud835\udcd5 :=\n  Basis.constr ofCrAnListFBasis \u2102 fun \u03c6s =>\n  normalOrderSign \u03c6s \u2022 ofCrAnListF (normalOrderList \u03c6s)\n\n@[inherit_doc normalOrderF]\nscoped[FieldSpecification.FieldOpFreeAlgebra] notation \"\ud835\udcdd\u1da0(\" a \")\" => normalOrderF a\n\nlemma normalOrderF_ofCrAnListF (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    \ud835\udcdd\u1da0(ofCrAnListF \u03c6s) = normalOrderSign \u03c6s \u2022 ofCrAnListF (normalOrderList \u03c6s) := by\n  rw [\u2190 ofListBasis_eq_ofList, normalOrderF, Basis.constr_basis]\n\nlemma ofCrAnListF_eq_normalOrderF (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnListF (normalOrderList \u03c6s) = normalOrderSign \u03c6s \u2022 \ud835\udcdd\u1da0(ofCrAnListF \u03c6s) := by\n  rw [normalOrderF_ofCrAnListF, normalOrderList, smul_smul, normalOrderSign,\n    Wick.koszulSign_mul_self, one_smul]\n\nlemma normalOrderF_one : normalOrderF (\ud835\udcd5 := \ud835\udcd5) 1 = 1 := by\n  rw [\u2190 ofCrAnListF_nil, normalOrderF_ofCrAnListF, normalOrderSign_nil, normalOrderList_nil,\n    ofCrAnListF_nil, one_smul]\n\nlemma normalOrderF_normalOrderF_mid (a b c : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \ud835\udcdd\u1da0(a * b * c) = \ud835\udcdd\u1da0(a * \ud835\udcdd\u1da0(b) * c) := by\n  let pc (c : \ud835\udcd5.FieldOpFreeAlgebra) (hc : c \u2208 Submodule.span \u2102 (Set.range ofCrAnListFBasis)) :\n    Prop := \ud835\udcdd\u1da0(a * b * c) = \ud835\udcdd\u1da0(a * \ud835\udcdd\u1da0(b) * c)\n  change pc c (Basis.mem_span _ c)\n  apply Submodule.span_induction\n  \u00b7 intro x hx\n    obtain \u27e8\u03c6s, rfl\u27e9 := hx\n    simp only [ofListBasis_eq_ofList, pc]\n    let pb (b : \ud835\udcd5.FieldOpFreeAlgebra) (hb : b \u2208 Submodule.span \u2102 (Set.range ofCrAnListFBasis)) :\n      Prop := \ud835\udcdd\u1da0(a * b * ofCrAnListF \u03c6s) = \ud835\udcdd\u1da0(a * \ud835\udcdd\u1da0(b) * ofCrAnListF \u03c6s)\n    change pb b (Basis.mem_span _ b)\n    apply Submodule.span_induction\n    \u00b7 intro x hx\n      obtain \u27e8\u03c6s', rfl\u27e9 := hx\n      simp only [ofListBasis_eq_ofList, pb]\n      let pa (a : \ud835\udcd5.FieldOpFreeAlgebra) (ha : a \u2208 Submodule.span \u2102 (Set.range ofCrAnListFBasis)) :\n        Prop := \ud835\udcdd\u1da0(a * ofCrAnListF \u03c6s' * ofCrAnListF \u03c6s) =\n        \ud835\udcdd\u1da0(a * \ud835\udcdd\u1da0(ofCrAnListF \u03c6s') * ofCrAnListF \u03c6s)\n      change pa a (Basis.mem_span _ a)\n      apply Submodule.span_induction\n      \u00b7 intro x hx\n        obtain \u27e8\u03c6s'', rfl\u27e9 := hx\n        simp only [ofListBasis_eq_ofList, pa]\n        rw [normalOrderF_ofCrAnListF]\n        simp only [\u2190 ofCrAnListF_append, Algebra.mul_smul_comm,\n          Algebra.smul_mul_assoc, map_smul]\n        rw [normalOrderF_ofCrAnListF, normalOrderF_ofCrAnListF, smul_smul]\n        congr 1\n        \u00b7 simp only [normalOrderSign, normalOrderList]\n          rw [Wick.koszulSign_of_append_eq_insertionSort, mul_comm]\n        \u00b7 congr 1\n          simp only [normalOrderList]\n          rw [HepLean.List.insertionSort_append_insertionSort_append]\n      \u00b7 simp [pa]\n      \u00b7 intro x y hx hy h1 h2\n        simp_all [pa, add_mul]\n      \u00b7 intro x hx h\n        simp_all [pa]\n    \u00b7 simp [pb]\n    \u00b7 intro x y hx hy h1 h2\n      simp_all [pb, mul_add, add_mul]\n    \u00b7 intro x hx h\n      simp_all [pb]\n  \u00b7 simp [pc]\n  \u00b7 intro x y hx hy h1 h2\n    simp_all [pc, mul_add]\n  \u00b7 intro x hx h hp\n    simp_all [pc]\n\nlemma normalOrderF_normalOrderF_right (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \ud835\udcdd\u1da0(a * b) = \ud835\udcdd\u1da0(a * \ud835\udcdd\u1da0(b)) := by\n  trans \ud835\udcdd\u1da0(a * b * 1)\n  \u00b7 simp\n  \u00b7 rw [normalOrderF_normalOrderF_mid]\n    simp\n\nlemma normalOrderF_normalOrderF_left (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \ud835\udcdd\u1da0(a * b) = \ud835\udcdd\u1da0(\ud835\udcdd\u1da0(a) * b) := by\n  trans \ud835\udcdd\u1da0(1 * a * b)\n  \u00b7 simp\n  \u00b7 rw [normalOrderF_normalOrderF_mid]\n    simp\n\n/-!\n\n## Normal ordering with a creation operator on the left or annihilation on the right\n\n-/\n\nlemma normalOrderF_ofCrAnListF_cons_create (\u03c6 : \ud835\udcd5.CrAnFieldOp)\n    (h\u03c6 : \ud835\udcd5 |>\u1d9c \u03c6 = CreateAnnihilate.create) (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    \ud835\udcdd\u1da0(ofCrAnListF (\u03c6 :: \u03c6s)) = ofCrAnOpF \u03c6 * \ud835\udcdd\u1da0(ofCrAnListF \u03c6s) := by\n  rw [normalOrderF_ofCrAnListF, normalOrderSign_cons_create \u03c6 h\u03c6,\n    normalOrderList_cons_create \u03c6 h\u03c6 \u03c6s]\n  rw [ofCrAnListF_cons, normalOrderF_ofCrAnListF, mul_smul_comm]\n\nlemma normalOrderF_create_mul (\u03c6 : \ud835\udcd5.CrAnFieldOp)\n    (h\u03c6 : \ud835\udcd5 |>\u1d9c \u03c6 = CreateAnnihilate.create) (a : FieldOpFreeAlgebra \ud835\udcd5) :\n    \ud835\udcdd\u1da0(ofCrAnOpF \u03c6 * a) = ofCrAnOpF \u03c6 * \ud835\udcdd\u1da0(a) := by\n  change (normalOrderF \u2218\u2097 mulLinearMap (ofCrAnOpF \u03c6)) a =\n    (mulLinearMap (ofCrAnOpF \u03c6) \u2218\u2097 normalOrderF) a\n  refine LinearMap.congr_fun (ofCrAnListFBasis.ext fun l \u21a6 ?_) a\n  simp only [mulLinearMap, LinearMap.coe_mk, AddHom.coe_mk, ofListBasis_eq_ofList,\n    LinearMap.coe_comp, Function.comp_apply]\n  rw [\u2190 ofCrAnListF_cons, normalOrderF_ofCrAnListF_cons_create \u03c6 h\u03c6]\n\nlemma normalOrderF_ofCrAnListF_append_annihilate (\u03c6 : \ud835\udcd5.CrAnFieldOp)\n    (h\u03c6 : \ud835\udcd5 |>\u1d9c \u03c6 = CreateAnnihilate.annihilate) (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    \ud835\udcdd\u1da0(ofCrAnListF (\u03c6s ++ [\u03c6])) = \ud835\udcdd\u1da0(ofCrAnListF \u03c6s) * ofCrAnOpF \u03c6 := by\n  rw [normalOrderF_ofCrAnListF, normalOrderSign_append_annihilate \u03c6 h\u03c6 \u03c6s,\n    normalOrderList_append_annihilate \u03c6 h\u03c6 \u03c6s, ofCrAnListF_append, ofCrAnListF_singleton,\n      normalOrderF_ofCrAnListF, smul_mul_assoc]\n\nlemma normalOrderF_mul_annihilate (\u03c6 : \ud835\udcd5.CrAnFieldOp)\n    (h\u03c6 : \ud835\udcd5 |>\u1d9c \u03c6 = CreateAnnihilate.annihilate)\n    (a : FieldOpFreeAlgebra \ud835\udcd5) : \ud835\udcdd\u1da0(a * ofCrAnOpF \u03c6) = \ud835\udcdd\u1da0(a) * ofCrAnOpF \u03c6 := by\n  change (normalOrderF \u2218\u2097 mulLinearMap.flip (ofCrAnOpF \u03c6)) a =\n    (mulLinearMap.flip (ofCrAnOpF \u03c6) \u2218\u2097 normalOrderF) a\n  refine LinearMap.congr_fun (ofCrAnListFBasis.ext fun l \u21a6 ?_) a\n  simp only [mulLinearMap, ofListBasis_eq_ofList, LinearMap.coe_comp, Function.comp_apply,\n    LinearMap.flip_apply, LinearMap.coe_mk, AddHom.coe_mk]\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_append, ofCrAnListF_singleton,\n    normalOrderF_ofCrAnListF_append_annihilate \u03c6 h\u03c6]\n\nlemma normalOrderF_crPartF_mul (\u03c6 : \ud835\udcd5.FieldOp) (a : FieldOpFreeAlgebra \ud835\udcd5) :\n    \ud835\udcdd\u1da0(crPartF \u03c6 * a) =\n    crPartF \u03c6 * \ud835\udcdd\u1da0(a) := by\n  match \u03c6 with\n  | .inAsymp \u03c6 =>\n    rw [crPartF]\n    exact normalOrderF_create_mul \u27e8FieldOp.inAsymp \u03c6, ()\u27e9 rfl a\n  | .position \u03c6 =>\n    rw [crPartF]\n    exact normalOrderF_create_mul _ rfl _\n  | .outAsymp \u03c6 => simp\n\nlemma normalOrderF_mul_anPartF (\u03c6 : \ud835\udcd5.FieldOp) (a : FieldOpFreeAlgebra \ud835\udcd5) :\n    \ud835\udcdd\u1da0(a * anPartF \u03c6) =\n    \ud835\udcdd\u1da0(a) * anPartF \u03c6 := by\n  match \u03c6 with\n  | .inAsymp \u03c6 => simp\n  | .position \u03c6 =>\n    rw [anPartF]\n    exact normalOrderF_mul_annihilate _ rfl _\n  | .outAsymp \u03c6 =>\n    rw [anPartF]\n    refine normalOrderF_mul_annihilate _ rfl _\n\n/-!\n\n## Normal ordering for an adjacent creation and annihliation state\n\nThe main result of this section is `normalOrderF_superCommuteF_annihilate_create`.\n-/\n\nlemma normalOrderF_swap_create_annihilate_ofCrAnListF_ofCrAnListF (\u03c6c \u03c6a : \ud835\udcd5.CrAnFieldOp)\n    (h\u03c6c : \ud835\udcd5 |>\u1d9c \u03c6c = CreateAnnihilate.create) (h\u03c6a : \ud835\udcd5 |>\u1d9c \u03c6a = CreateAnnihilate.annihilate)\n    (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    \ud835\udcdd\u1da0(ofCrAnListF \u03c6s' * ofCrAnOpF \u03c6c * ofCrAnOpF \u03c6a * ofCrAnListF \u03c6s) = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6c, \ud835\udcd5 |>\u209b \u03c6a) \u2022\n    \ud835\udcdd\u1da0(ofCrAnListF \u03c6s' * ofCrAnOpF \u03c6a * ofCrAnOpF \u03c6c * ofCrAnListF \u03c6s) := by\n  rw [mul_assoc, mul_assoc, \u2190 ofCrAnListF_cons, \u2190 ofCrAnListF_cons, \u2190 ofCrAnListF_append]\n  rw [normalOrderF_ofCrAnListF, normalOrderSign_swap_create_annihilate \u03c6c \u03c6a h\u03c6c h\u03c6a]\n  rw [normalOrderList_swap_create_annihilate \u03c6c \u03c6a h\u03c6c h\u03c6a, \u2190 smul_smul, \u2190 normalOrderF_ofCrAnListF]\n  rw [ofCrAnListF_append, ofCrAnListF_cons, ofCrAnListF_cons]\n  noncomm_ring\n\nlemma normalOrderF_swap_create_annihilate_ofCrAnListF (\u03c6c \u03c6a : \ud835\udcd5.CrAnFieldOp)\n    (h\u03c6c : \ud835\udcd5 |>\u1d9c \u03c6c = CreateAnnihilate.create) (h\u03c6a : \ud835\udcd5 |>\u1d9c \u03c6a = CreateAnnihilate.annihilate)\n    (\u03c6s : List \ud835\udcd5.CrAnFieldOp) (a : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \ud835\udcdd\u1da0(ofCrAnListF \u03c6s * ofCrAnOpF \u03c6c * ofCrAnOpF \u03c6a * a) = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6c, \ud835\udcd5 |>\u209b \u03c6a) \u2022\n    \ud835\udcdd\u1da0(ofCrAnListF \u03c6s * ofCrAnOpF \u03c6a * ofCrAnOpF \u03c6c * a) := by\n  change (normalOrderF \u2218\u2097 mulLinearMap (ofCrAnListF \u03c6s * ofCrAnOpF \u03c6c * ofCrAnOpF \u03c6a)) a =\n    (smulLinearMap _ \u2218\u2097 normalOrderF \u2218\u2097\n    mulLinearMap (ofCrAnListF \u03c6s * ofCrAnOpF \u03c6a * ofCrAnOpF \u03c6c)) a\n  refine LinearMap.congr_fun (ofCrAnListFBasis.ext fun l \u21a6 ?_) a\n  simp only [mulLinearMap, LinearMap.coe_mk, AddHom.coe_mk, ofListBasis_eq_ofList,\n    LinearMap.coe_comp, Function.comp_apply, instCommGroup.eq_1]\n  rw [normalOrderF_swap_create_annihilate_ofCrAnListF_ofCrAnListF \u03c6c \u03c6a h\u03c6c h\u03c6a]\n  rfl\n\nlemma normalOrderF_swap_create_annihilate (\u03c6c \u03c6a : \ud835\udcd5.CrAnFieldOp)\n    (h\u03c6c : \ud835\udcd5 |>\u1d9c \u03c6c = CreateAnnihilate.create) (h\u03c6a : \ud835\udcd5 |>\u1d9c \u03c6a = CreateAnnihilate.annihilate)\n    (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \ud835\udcdd\u1da0(a * ofCrAnOpF \u03c6c * ofCrAnOpF \u03c6a * b) = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6c, \ud835\udcd5 |>\u209b \u03c6a) \u2022\n    \ud835\udcdd\u1da0(a * ofCrAnOpF \u03c6a * ofCrAnOpF \u03c6c * b) := by\n  rw [mul_assoc, mul_assoc, mul_assoc, mul_assoc]\n  change (normalOrderF \u2218\u2097 mulLinearMap.flip (ofCrAnOpF \u03c6c * (ofCrAnOpF \u03c6a * b))) a =\n    (smulLinearMap (\ud835\udce2(\ud835\udcd5 |>\u209b \u03c6c, \ud835\udcd5 |>\u209b \u03c6a)) \u2218\u2097\n    normalOrderF \u2218\u2097 mulLinearMap.flip (ofCrAnOpF \u03c6a * (ofCrAnOpF \u03c6c * b))) a\n  refine LinearMap.congr_fun (ofCrAnListFBasis.ext fun l \u21a6 ?_) _\n  simp only [mulLinearMap, ofListBasis_eq_ofList, LinearMap.coe_comp, Function.comp_apply,\n    LinearMap.flip_apply, LinearMap.coe_mk, AddHom.coe_mk, instCommGroup.eq_1, \u2190 mul_assoc,\n      normalOrderF_swap_create_annihilate_ofCrAnListF \u03c6c \u03c6a h\u03c6c h\u03c6a]\n  rfl\n\nlemma normalOrderF_superCommuteF_create_annihilate (\u03c6c \u03c6a : \ud835\udcd5.CrAnFieldOp)\n    (h\u03c6c : \ud835\udcd5 |>\u1d9c \u03c6c = CreateAnnihilate.create) (h\u03c6a : \ud835\udcd5 |>\u1d9c \u03c6a = CreateAnnihilate.annihilate)\n    (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \ud835\udcdd\u1da0(a * [ofCrAnOpF \u03c6c, ofCrAnOpF \u03c6a]\u209bca * b) = 0 := by\n  simp only [superCommuteF_ofCrAnOpF_ofCrAnOpF, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n  rw [mul_sub, sub_mul, map_sub, \u2190 smul_mul_assoc, \u2190 mul_assoc, \u2190 mul_assoc,\n    normalOrderF_swap_create_annihilate \u03c6c \u03c6a h\u03c6c h\u03c6a]\n  simp\n\nlemma normalOrderF_superCommuteF_annihilate_create (\u03c6c \u03c6a : \ud835\udcd5.CrAnFieldOp)\n    (h\u03c6c : \ud835\udcd5 |>\u1d9c \u03c6c = CreateAnnihilate.create) (h\u03c6a : \ud835\udcd5 |>\u1d9c \u03c6a = CreateAnnihilate.annihilate)\n    (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \ud835\udcdd\u1da0(a * [ofCrAnOpF \u03c6a, ofCrAnOpF \u03c6c]\u209bca * b) = 0 := by\n  rw [superCommuteF_ofCrAnOpF_ofCrAnOpF_symm]\n  simp only [instCommGroup.eq_1, neg_smul, mul_neg, Algebra.mul_smul_comm, neg_mul,\n    Algebra.smul_mul_assoc, map_neg, map_smul, neg_eq_zero, smul_eq_zero]\n  exact Or.inr (normalOrderF_superCommuteF_create_annihilate \u03c6c \u03c6a h\u03c6c h\u03c6a ..)\n\nlemma normalOrderF_swap_crPartF_anPartF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) (a b : FieldOpFreeAlgebra \ud835\udcd5) :\n    \ud835\udcdd\u1da0(a * (crPartF \u03c6) * (anPartF \u03c6') * b) =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022\n    \ud835\udcdd\u1da0(a * (anPartF \u03c6') * (crPartF \u03c6) * b) := by\n  match \u03c6, \u03c6' with\n  | _, .inAsymp \u03c6' => simp\n  | .outAsymp \u03c6, _ => simp\n  | .position \u03c6, .position \u03c6' =>\n    simp only [crPartF_position, anPartF_position, instCommGroup.eq_1]\n    rw [normalOrderF_swap_create_annihilate]\n    simp only [instCommGroup.eq_1, crAnStatistics, Function.comp_apply, crAnFieldOpToFieldOp_prod]\n    rfl; rfl\n  | .inAsymp \u03c6, .outAsymp \u03c6' =>\n    simp only [crPartF_negAsymp, anPartF_posAsymp, instCommGroup.eq_1]\n    rw [normalOrderF_swap_create_annihilate]\n    simp only [instCommGroup.eq_1, crAnStatistics, Function.comp_apply, crAnFieldOpToFieldOp_prod]\n    rfl; rfl\n  | .inAsymp \u03c6, .position \u03c6' =>\n    simp only [crPartF_negAsymp, anPartF_position, instCommGroup.eq_1]\n    rw [normalOrderF_swap_create_annihilate]\n    simp only [instCommGroup.eq_1, crAnStatistics, Function.comp_apply, crAnFieldOpToFieldOp_prod]\n    rfl; rfl\n  | .position \u03c6, .outAsymp \u03c6' =>\n    simp only [crPartF_position, anPartF_posAsymp, instCommGroup.eq_1]\n    rw [normalOrderF_swap_create_annihilate]\n    simp only [instCommGroup.eq_1, crAnStatistics, Function.comp_apply, crAnFieldOpToFieldOp_prod]\n    rfl; rfl\n\n/-!\n\n## Normal ordering for an anPartF and crPartF\n\nUsing the results from above.\n\n-/\n\nlemma normalOrderF_swap_anPartF_crPartF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) (a b : FieldOpFreeAlgebra \ud835\udcd5) :\n    \ud835\udcdd\u1da0(a * (anPartF \u03c6) * (crPartF \u03c6') * b) =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 \ud835\udcdd\u1da0(a * (crPartF \u03c6') *\n      (anPartF \u03c6) * b) := by\n  simp [normalOrderF_swap_crPartF_anPartF, smul_smul]\n\nlemma normalOrderF_superCommuteF_crPartF_anPartF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) (a b : FieldOpFreeAlgebra \ud835\udcd5) :\n    \ud835\udcdd\u1da0(a * superCommuteF\n      (crPartF \u03c6) (anPartF \u03c6') * b) = 0 := by\n  match \u03c6, \u03c6' with\n  | _, .inAsymp \u03c6' => simp\n  | .outAsymp \u03c6', _ => simp\n  | .position \u03c6, .position \u03c6' =>\n    rw [crPartF_position, anPartF_position]\n    exact normalOrderF_superCommuteF_create_annihilate _ _ rfl rfl ..\n  | .inAsymp \u03c6, .outAsymp \u03c6' =>\n    rw [crPartF_negAsymp, anPartF_posAsymp]\n    exact normalOrderF_superCommuteF_create_annihilate _ _ rfl rfl ..\n  | .inAsymp \u03c6, .position \u03c6' =>\n    rw [crPartF_negAsymp, anPartF_position]\n    exact normalOrderF_superCommuteF_create_annihilate _ _ rfl rfl ..\n  | .position \u03c6, .outAsymp \u03c6' =>\n    rw [crPartF_position, anPartF_posAsymp]\n    exact normalOrderF_superCommuteF_create_annihilate _ _ rfl rfl ..\n\nlemma normalOrderF_superCommuteF_anPartF_crPartF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) (a b : FieldOpFreeAlgebra \ud835\udcd5) :\n    \ud835\udcdd\u1da0(a * superCommuteF\n    (anPartF \u03c6) (crPartF \u03c6') * b) = 0 := by\n  match \u03c6, \u03c6' with\n  | .inAsymp \u03c6', _ => simp\n  | _, .outAsymp \u03c6' => simp\n  | .position \u03c6, .position \u03c6' =>\n    rw [anPartF_position, crPartF_position]\n    exact normalOrderF_superCommuteF_annihilate_create _ _ rfl rfl ..\n  | .outAsymp \u03c6', .inAsymp \u03c6 =>\n    simp only [anPartF_posAsymp, crPartF_negAsymp]\n    exact normalOrderF_superCommuteF_annihilate_create _ _ rfl rfl ..\n  | .position \u03c6', .inAsymp \u03c6 =>\n    simp only [anPartF_position, crPartF_negAsymp]\n    exact normalOrderF_superCommuteF_annihilate_create _ _ rfl rfl ..\n  | .outAsymp \u03c6, .position \u03c6' =>\n    simp only [anPartF_posAsymp, crPartF_position]\n    exact normalOrderF_superCommuteF_annihilate_create _ _ rfl rfl ..\n\n/-!\n\n## The normal ordering of a product of two states\n\n-/\n\n@[simp]\nlemma normalOrderF_crPartF_mul_crPartF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    \ud835\udcdd\u1da0(crPartF \u03c6 * crPartF \u03c6') =\n    crPartF \u03c6 * crPartF \u03c6' := by\n  rw [normalOrderF_crPartF_mul]\n  conv_lhs => rw [\u2190 mul_one (crPartF \u03c6')]\n  rw [normalOrderF_crPartF_mul, normalOrderF_one]\n  simp\n\n@[simp]\nlemma normalOrderF_anPartF_mul_anPartF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    \ud835\udcdd\u1da0(anPartF \u03c6 * anPartF \u03c6') =\n    anPartF \u03c6 * anPartF \u03c6' := by\n  rw [normalOrderF_mul_anPartF]\n  conv_lhs => rw [\u2190 one_mul (anPartF \u03c6)]\n  rw [normalOrderF_mul_anPartF, normalOrderF_one]\n  simp\n\n", "theoremStatement": "@[simp]\nlemma normalOrderF_crPartF_mul_anPartF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    \ud835\udcdd\u1da0(crPartF \u03c6 * anPartF \u03c6') =\n    crPartF \u03c6 * anPartF \u03c6' ", "theoremName": "FieldSpecification.FieldOpFreeAlgebra.normalOrderF_crPartF_mul_anPartF", "fileCreated": {"commit": "ea6e12829370d9630a7e65200c8349e9086c05ba", "date": "2025-02-03"}, "theoremCreated": {"commit": "f7e669910ceee9df476eef0815080acbaa61ee61", "date": "2025-01-30"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpFreeAlgebra/NormalOrder.lean", "module": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.NormalOrder", "jsonFile": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.NormalOrder.jsonl", "positionMetadata": {"lineInFile": 361, "tokenPositionInFile": 15012, "theoremPositionInFile": 25}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 10, "numPremises": 50}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [normalOrderF_crPartF_mul]\n  conv_lhs => rw [\u2190 one_mul (anPartF \u03c6')]\n  rw [normalOrderF_mul_anPartF, normalOrderF_one]\n  simp", "proofType": "tactic", "proofLengthLines": 4, "proofLengthTokens": 136}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpAlgebra.Basic\n/-!\n\n# Grading on the field operation algebra\n\n-/\n\nnamespace FieldSpecification\nopen FieldOpFreeAlgebra\nopen HepLean.List\nopen FieldStatistic\n\nnamespace FieldOpAlgebra\nvariable {\ud835\udcd5 : FieldSpecification}\n\n/-- The submodule of `\ud835\udcd5.FieldOpAlgebra` spanned by lists of field statistic `f`. -/\ndef statSubmodule (f : FieldStatistic) : Submodule \u2102 \ud835\udcd5.FieldOpAlgebra :=\n  Submodule.span \u2102 {a | \u2203 \u03c6s, a = ofCrAnList \u03c6s \u2227 (\ud835\udcd5 |>\u209b \u03c6s) = f}\n\nlemma ofCrAnList_mem_statSubmodule_of_eq (\u03c6s : List \ud835\udcd5.CrAnFieldOp) (f : FieldStatistic)\n    (h : (\ud835\udcd5 |>\u209b \u03c6s) = f) : ofCrAnList \u03c6s \u2208 statSubmodule f :=\n  Submodule.mem_span.mpr fun _ a => a \u27e8\u03c6s, \u27e8rfl, h\u27e9\u27e9\n\nlemma ofCrAnList_mem_statSubmodule (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnList \u03c6s \u2208 statSubmodule (\ud835\udcd5 |>\u209b \u03c6s) :=\n  Submodule.mem_span.mpr fun _ a => a \u27e8\u03c6s, \u27e8rfl, rfl\u27e9\u27e9\n\nlemma mem_bosonic_of_mem_free_bosonic (a : \ud835\udcd5.FieldOpFreeAlgebra)\n    (h : a \u2208 statisticSubmodule bosonic) : \u03b9 a \u2208 statSubmodule .bosonic := by\n  let p (a : \ud835\udcd5.FieldOpFreeAlgebra) (hx : a \u2208 statisticSubmodule bosonic) : Prop :=\n    \u03b9 a \u2208 statSubmodule .bosonic\n  change p a h\n  apply Submodule.span_induction\n  \u00b7 intro x hx\n    simp only [Set.mem_setOf_eq] at hx\n    obtain \u27e8\u03c6s, rfl, h\u27e9 := hx\n    simp [p]\n    apply ofCrAnList_mem_statSubmodule_of_eq\n    exact h\n  \u00b7 simp only [map_zero, p]\n    exact Submodule.zero_mem (statSubmodule bosonic)\n  \u00b7 intro x y hx hy hpx hpy\n    simp_all only [p, map_add]\n    exact Submodule.add_mem _ hpx hpy\n  \u00b7 intro a x hx hy\n    simp_all only [p, map_smul]\n    exact Submodule.smul_mem _ _ hy\n\nlemma mem_fermionic_of_mem_free_fermionic (a : \ud835\udcd5.FieldOpFreeAlgebra)\n    (h : a \u2208 statisticSubmodule fermionic) : \u03b9 a \u2208 statSubmodule .fermionic := by\n  let p (a : \ud835\udcd5.FieldOpFreeAlgebra) (hx : a \u2208 statisticSubmodule fermionic) : Prop :=\n    \u03b9 a \u2208 statSubmodule .fermionic\n  change p a h\n  apply Submodule.span_induction\n  \u00b7 intro x hx\n    simp only [Set.mem_setOf_eq] at hx\n    obtain \u27e8\u03c6s, rfl, h\u27e9 := hx\n    simp [p]\n    apply ofCrAnList_mem_statSubmodule_of_eq\n    exact h\n  \u00b7 simp only [map_zero, p]\n    exact Submodule.zero_mem (statSubmodule fermionic)\n  \u00b7 intro x y hx hy hpx hpy\n    simp_all only [p, map_add]\n    exact Submodule.add_mem _ hpx hpy\n  \u00b7 intro a x hx hy\n    simp_all only [p, map_smul]\n    exact Submodule.smul_mem _ _ hy\n\nlemma mem_statSubmodule_of_mem_statisticSubmodule (f : FieldStatistic) (a : \ud835\udcd5.FieldOpFreeAlgebra)\n    (h : a \u2208 statisticSubmodule f) : \u03b9 a \u2208 statSubmodule f := by\n  fin_cases f\n  \u00b7 exact mem_bosonic_of_mem_free_bosonic a h\n  \u00b7 exact mem_fermionic_of_mem_free_fermionic a h\n\n/-- The projection of `statisticSubmodule (\ud835\udcd5 := \ud835\udcd5) f` defined in the free algebra to\n  `statSubmodule (\ud835\udcd5 := \ud835\udcd5) f`. -/\ndef \u03b9StateSubmodule (f : FieldStatistic) :\n    statisticSubmodule (\ud835\udcd5 := \ud835\udcd5) f \u2192\u2097[\u2102] statSubmodule (\ud835\udcd5 := \ud835\udcd5) f where\n  toFun a := \u27e8a.1, mem_statSubmodule_of_mem_statisticSubmodule f a.1 a.2\u27e9\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n\nnoncomputable section\n\n/-!\n\n## Defining bosonicProj\n\n-/\n\n/-- The projection of `\ud835\udcd5.FieldOpFreeAlgebra` to `statSubmodule (\ud835\udcd5 := \ud835\udcd5) bosonic`. -/\ndef bosonicProjFree : \ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102] statSubmodule (\ud835\udcd5 := \ud835\udcd5) bosonic :=\n  \u03b9StateSubmodule .bosonic \u2218\u2097 bosonicProjF\n\nlemma bosonicProjFree_eq_\u03b9_bosonicProjF (a : \ud835\udcd5.FieldOpFreeAlgebra) :\n    (bosonicProjFree a).1 = \u03b9 (bosonicProjF a) := rfl\n\nlemma bosonicProjFree_zero_of_\u03b9_zero (a : \ud835\udcd5.FieldOpFreeAlgebra) (h : \u03b9 a = 0) :\n    bosonicProjFree a = 0 := by\n  rw [\u03b9_eq_zero_iff_\u03b9_bosonicProjF_fermonicProj_zero] at h\n  apply Subtype.eq\n  rw [bosonicProjFree_eq_\u03b9_bosonicProjF]\n  exact h.1\n\nlemma bosonicProjFree_eq_of_equiv (a b : \ud835\udcd5.FieldOpFreeAlgebra) (h : a \u2248 b) :\n    bosonicProjFree a = bosonicProjFree b := by\n  rw [equiv_iff_sub_mem_ideal, \u2190 \u03b9_eq_zero_iff_mem_ideal] at h\n  rw [LinearMap.sub_mem_ker_iff.mp]\n  simp only [LinearMap.mem_ker, \u2190 map_sub]\n  exact bosonicProjFree_zero_of_\u03b9_zero (a - b) h\n\n/-- The projection of `\ud835\udcd5.FieldOpAlgebra` to `statSubmodule (\ud835\udcd5 := \ud835\udcd5) bosonic`. -/\ndef bosonicProj : \ud835\udcd5.FieldOpAlgebra \u2192\u2097[\u2102] statSubmodule (\ud835\udcd5 := \ud835\udcd5) bosonic where\n  toFun := Quotient.lift bosonicProjFree bosonicProjFree_eq_of_equiv\n  map_add' x y := by\n    obtain \u27e8x, hx\u27e9 := \u03b9_surjective x\n    obtain \u27e8y, hy\u27e9 := \u03b9_surjective y\n    subst hx hy\n    rw [\u2190 map_add, \u03b9_apply, \u03b9_apply, \u03b9_apply]\n    rw [Quotient.lift_mk, Quotient.lift_mk, Quotient.lift_mk]\n    simp\n  map_smul' c y := by\n    obtain \u27e8y, hy\u27e9 := \u03b9_surjective y\n    subst hy\n    rw [\u2190 map_smul, \u03b9_apply, \u03b9_apply]\n    simp\n\nlemma bosonicProj_eq_bosonicProjFree (a : \ud835\udcd5.FieldOpFreeAlgebra) :\n    bosonicProj (\u03b9 a) = bosonicProjFree a := rfl\n\n/-!\n\n## Defining fermionicProj\n\n-/\n\n/-- The projection of `\ud835\udcd5.FieldOpFreeAlgebra` to `statSubmodule (\ud835\udcd5 := \ud835\udcd5) fermionic`. -/\ndef fermionicProjFree : \ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102] statSubmodule (\ud835\udcd5 := \ud835\udcd5) fermionic :=\n  \u03b9StateSubmodule .fermionic \u2218\u2097 fermionicProjF\n\nlemma fermionicProjFree_eq_\u03b9_fermionicProjF (a : \ud835\udcd5.FieldOpFreeAlgebra) :\n    (fermionicProjFree a).1 = \u03b9 (fermionicProjF a) := rfl\n\nlemma fermionicProjFree_zero_of_\u03b9_zero (a : \ud835\udcd5.FieldOpFreeAlgebra) (h : \u03b9 a = 0) :\n    fermionicProjFree a = 0 := by\n  rw [\u03b9_eq_zero_iff_\u03b9_bosonicProjF_fermonicProj_zero] at h\n  apply Subtype.eq\n  rw [fermionicProjFree_eq_\u03b9_fermionicProjF]\n  exact h.2\n\nlemma fermionicProjFree_eq_of_equiv (a b : \ud835\udcd5.FieldOpFreeAlgebra) (h : a \u2248 b) :\n    fermionicProjFree a = fermionicProjFree b := by\n  rw [equiv_iff_sub_mem_ideal, \u2190 \u03b9_eq_zero_iff_mem_ideal] at h\n  rw [LinearMap.sub_mem_ker_iff.mp]\n  simp only [LinearMap.mem_ker, \u2190 map_sub]\n  exact fermionicProjFree_zero_of_\u03b9_zero (a - b) h\n\n/-- The projection of `\ud835\udcd5.FieldOpAlgebra` to `statSubmodule (\ud835\udcd5 := \ud835\udcd5) fermionic`. -/\ndef fermionicProj : \ud835\udcd5.FieldOpAlgebra \u2192\u2097[\u2102] statSubmodule (\ud835\udcd5 := \ud835\udcd5) fermionic where\n  toFun := Quotient.lift fermionicProjFree fermionicProjFree_eq_of_equiv\n  map_add' x y := by\n    obtain \u27e8x, hx\u27e9 := \u03b9_surjective x\n    obtain \u27e8y, hy\u27e9 := \u03b9_surjective y\n    subst hx hy\n    rw [\u2190 map_add, \u03b9_apply, \u03b9_apply, \u03b9_apply]\n    rw [Quotient.lift_mk, Quotient.lift_mk, Quotient.lift_mk]\n    simp\n  map_smul' c y := by\n    obtain \u27e8y, hy\u27e9 := \u03b9_surjective y\n    subst hy\n    rw [\u2190 map_smul, \u03b9_apply, \u03b9_apply]\n    simp\n\nlemma fermionicProj_eq_fermionicProjFree (a : \ud835\udcd5.FieldOpFreeAlgebra) :\n    fermionicProj (\u03b9 a) = fermionicProjFree a := rfl\n\n/-!\n\n## Interactino between bosonicProj and fermionicProj\n\n-/\n\nlemma bosonicProj_add_fermionicProj (a : \ud835\udcd5.FieldOpAlgebra) :\n    bosonicProj a + (fermionicProj a).1 = a := by\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  rw [fermionicProj_eq_fermionicProjFree, bosonicProj_eq_bosonicProjFree]\n  rw [bosonicProjFree_eq_\u03b9_bosonicProjF, fermionicProjFree_eq_\u03b9_fermionicProjF]\n  rw [\u2190 map_add, bosonicProjF_add_fermionicProjF]\n\nlemma bosonicProj_mem_bosonic (a : \ud835\udcd5.FieldOpAlgebra) (ha : a \u2208 statSubmodule .bosonic) :\n    bosonicProj a = \u27e8a, ha\u27e9 := by\n  let p (a : \ud835\udcd5.FieldOpAlgebra) (hx : a \u2208 statSubmodule bosonic) : Prop :=\n    (bosonicProj a) = \u27e8a, hx\u27e9\n  change p a ha\n  apply Submodule.span_induction\n  \u00b7 intro x hx\n    obtain \u27e8\u03c6s, rfl, h\u27e9 := hx\n    simp only [p]\n    apply Subtype.eq\n    simp only\n    rw [ofCrAnList]\n    rw [bosonicProj_eq_bosonicProjFree]\n    rw [bosonicProjFree_eq_\u03b9_bosonicProjF]\n    rw [bosonicProjF_of_mem_bosonic]\n    exact ofCrAnListF_mem_statisticSubmodule_of _ _ h\n  \u00b7 simp only [map_zero, p]\n    rfl\n  \u00b7 intro x y hx hy hpx hpy\n    simp_all [p]\n  \u00b7 intro a x hx hy\n    simp_all [p]\n\nlemma fermionicProj_mem_fermionic (a : \ud835\udcd5.FieldOpAlgebra) (ha : a \u2208 statSubmodule .fermionic) :\n    fermionicProj a = \u27e8a, ha\u27e9 := by\n  let p (a : \ud835\udcd5.FieldOpAlgebra) (hx : a \u2208 statSubmodule fermionic) : Prop :=\n    (fermionicProj a) = \u27e8a, hx\u27e9\n  change p a ha\n  apply Submodule.span_induction\n  \u00b7 intro x hx\n    obtain \u27e8\u03c6s, rfl, h\u27e9 := hx\n    simp only [p]\n    apply Subtype.eq\n    simp only\n    rw [ofCrAnList]\n    rw [fermionicProj_eq_fermionicProjFree]\n    rw [fermionicProjFree_eq_\u03b9_fermionicProjF]\n    rw [fermionicProjF_of_mem_fermionic]\n    exact ofCrAnListF_mem_statisticSubmodule_of _ _ h\n  \u00b7 simp only [map_zero, p]\n    rfl\n  \u00b7 intro x y hx hy hpx hpy\n    simp_all [p]\n  \u00b7 intro a x hx hy\n    simp_all [p]\n\nlemma bosonicProj_mem_fermionic (a : \ud835\udcd5.FieldOpAlgebra) (ha : a \u2208 statSubmodule .fermionic) :\n    bosonicProj a = 0 := by\n  have h := bosonicProj_add_fermionicProj a\n  rw [fermionicProj_mem_fermionic a ha] at h\n  simpa using h\n\nlemma fermionicProj_mem_bosonic (a : \ud835\udcd5.FieldOpAlgebra) (ha : a \u2208 statSubmodule .bosonic) :\n    fermionicProj a = 0 := by\n  have h := bosonicProj_add_fermionicProj a\n  rw [bosonicProj_mem_bosonic a ha] at h\n  simpa using h\n\nlemma mem_bosonic_iff_fermionicProj_eq_zero (a : \ud835\udcd5.FieldOpAlgebra) :\n    a \u2208 statSubmodule bosonic \u2194 fermionicProj a = 0 := by\n  apply Iff.intro\n  \u00b7 intro h\n    exact fermionicProj_mem_bosonic a h\n  \u00b7 intro h\n    have ha := bosonicProj_add_fermionicProj a\n    rw [h] at ha\n    simp_all\n    rw [\u2190 ha]\n    exact (bosonicProj a).2\n\nlemma mem_fermionic_iff_bosonicProj_eq_zero (a : \ud835\udcd5.FieldOpAlgebra) :\n    a \u2208 statSubmodule fermionic \u2194 bosonicProj a = 0 := by\n  apply Iff.intro\n  \u00b7 intro h\n    exact bosonicProj_mem_fermionic a h\n  \u00b7 intro h\n    have ha := bosonicProj_add_fermionicProj a\n    rw [h] at ha\n    simp_all\n    rw [\u2190 ha]\n    exact (fermionicProj a).2\n\nlemma eq_zero_of_bosonic_and_fermionic {a : \ud835\udcd5.FieldOpAlgebra}\n    (hb : a \u2208 statSubmodule bosonic) (hf : a \u2208 statSubmodule fermionic) : a = 0 := by\n  have ha := bosonicProj_mem_bosonic a hb\n  have hb := fermionicProj_mem_fermionic a hf\n  have hc := (bosonicProj_add_fermionicProj a)\n  rw [ha, hb] at hc\n  simpa using hc\n\n@[simp]\nlemma bosonicProj_fermionicProj_eq_zero (a : \ud835\udcd5.FieldOpAlgebra) :\n    bosonicProj (fermionicProj a).1 = 0 := by\n  apply bosonicProj_mem_fermionic\n  exact Submodule.coe_mem (fermionicProj a)\n\n@[simp]\nlemma fermionicProj_bosonicProj_eq_zero (a : \ud835\udcd5.FieldOpAlgebra) :\n    fermionicProj (bosonicProj a).1 = 0 := by\n  apply fermionicProj_mem_bosonic\n  exact Submodule.coe_mem (bosonicProj a)\n\n@[simp]\nlemma bosonicProj_bosonicProj_eq_bosonicProj (a : \ud835\udcd5.FieldOpAlgebra) :\n    bosonicProj (bosonicProj a).1 = bosonicProj a := by\n  apply bosonicProj_mem_bosonic\n\n@[simp]\nlemma fermionicProj_fermionicProj_eq_fermionicProj (a : \ud835\udcd5.FieldOpAlgebra) :\n    fermionicProj (fermionicProj a).1 = fermionicProj a := by\n  apply fermionicProj_mem_fermionic\n\n@[simp]\nlemma bosonicProj_of_bosonic_part\n    (a : DirectSum FieldStatistic (fun i => (statSubmodule (\ud835\udcd5 := \ud835\udcd5) i))) :\n    bosonicProj (a bosonic).1 = (a bosonic) := by\n  apply bosonicProj_mem_bosonic\n\n@[simp]\nlemma bosonicProj_of_fermionic_part\n    (a : DirectSum FieldStatistic (fun i => (statSubmodule (\ud835\udcd5 := \ud835\udcd5) i))) :\n    bosonicProj (a fermionic).1 = 0 := by\n  apply bosonicProj_mem_fermionic\n  exact Submodule.coe_mem (a.toFun fermionic)\n\n", "theoremStatement": "@[simp]\nlemma fermionicProj_of_bosonic_part\n    (a : DirectSum FieldStatistic (fun i => (statSubmodule (\ud835\udcd5 := \ud835\udcd5) i))) :\n    fermionicProj (a bosonic).1 = 0 ", "theoremName": "FieldSpecification.FieldOpAlgebra.fermionicProj_of_bosonic_part", "fileCreated": {"commit": "7d9e6af80c57599f68481948604d9f0aaba4a40f", "date": "2025-02-05"}, "theoremCreated": {"commit": "bcc7d8244ccb38474da96b746a2a8a39e0227966", "date": "2025-01-28"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpAlgebra/Grading.lean", "module": "HepLean.PerturbationTheory.FieldOpAlgebra.Grading", "jsonFile": "HepLean.PerturbationTheory.FieldOpAlgebra.Grading.jsonl", "positionMetadata": {"lineInFile": 321, "tokenPositionInFile": 10864, "theoremPositionInFile": 30}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 11, "numPremises": 57}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  apply fermionicProj_mem_bosonic\n  exact Submodule.coe_mem (a.toFun bosonic)", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 83}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.NormalOrder\nimport HepLean.PerturbationTheory.FieldOpAlgebra.SuperCommute\n/-!\n\n# Normal Ordering on Field operator algebra\n\n-/\n\nnamespace FieldSpecification\nopen FieldOpFreeAlgebra\nopen HepLean.List\nopen FieldStatistic\n\nnamespace FieldOpAlgebra\nvariable {\ud835\udcd5 : FieldSpecification}\n\n/-!\n\n## Normal order on super-commutators.\n\nThe main result of this is\n`\u03b9_normalOrderF_superCommuteF_eq_zero_mul`\nwhich states that applying `\u03b9` to the normal order of something containing a super-commutator\nis zero.\n\n-/\n\nlemma \u03b9_normalOrderF_superCommuteF_ofCrAnListF_ofCrAnListF_eq_zero\n    (\u03c6a \u03c6a' : \ud835\udcd5.CrAnFieldOp) (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    \u03b9 \ud835\udcdd\u1da0(ofCrAnListF \u03c6s * [ofCrAnOpF \u03c6a, ofCrAnOpF \u03c6a']\u209bca * ofCrAnListF \u03c6s') = 0 := by\n  rcases CreateAnnihilate.eq_create_or_annihilate (\ud835\udcd5 |>\u1d9c \u03c6a) with h\u03c6a | h\u03c6a\n  <;> rcases CreateAnnihilate.eq_create_or_annihilate (\ud835\udcd5 |>\u1d9c \u03c6a') with h\u03c6a' | h\u03c6a'\n  \u00b7 rw [normalOrderF_superCommuteF_ofCrAnListF_create_create_ofCrAnListF \u03c6a \u03c6a' h\u03c6a h\u03c6a' \u03c6s \u03c6s']\n    rw [map_smul, map_mul, map_mul, map_mul, \u03b9_superCommuteF_of_create_create \u03c6a \u03c6a' h\u03c6a h\u03c6a']\n    simp\n  \u00b7 rw [normalOrderF_superCommuteF_create_annihilate \u03c6a \u03c6a' h\u03c6a h\u03c6a' (ofCrAnListF \u03c6s)\n      (ofCrAnListF \u03c6s')]\n    simp\n  \u00b7 rw [normalOrderF_superCommuteF_annihilate_create \u03c6a' \u03c6a h\u03c6a' h\u03c6a (ofCrAnListF \u03c6s)\n      (ofCrAnListF \u03c6s')]\n    simp\n  \u00b7 rw [normalOrderF_superCommuteF_ofCrAnListF_annihilate_annihilate_ofCrAnListF\n      \u03c6a \u03c6a' h\u03c6a h\u03c6a' \u03c6s \u03c6s']\n    rw [map_smul, map_mul, map_mul, map_mul,\n      \u03b9_superCommuteF_of_annihilate_annihilate \u03c6a \u03c6a' h\u03c6a h\u03c6a']\n    simp\n\nlemma \u03b9_normalOrderF_superCommuteF_ofCrAnListF_eq_zero\n    (\u03c6a \u03c6a' : \ud835\udcd5.CrAnFieldOp) (\u03c6s : List \ud835\udcd5.CrAnFieldOp)\n    (a : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \u03b9 \ud835\udcdd\u1da0(ofCrAnListF \u03c6s * [ofCrAnOpF \u03c6a, ofCrAnOpF \u03c6a']\u209bca * a) = 0 := by\n  have hf : \u03b9.toLinearMap \u2218\u2097 normalOrderF \u2218\u2097\n      mulLinearMap (ofCrAnListF \u03c6s * [ofCrAnOpF \u03c6a, ofCrAnOpF \u03c6a']\u209bca) = 0 := by\n    apply ofCrAnListFBasis.ext\n    intro l\n    simp only [FieldOpFreeAlgebra.ofListBasis_eq_ofList, LinearMap.coe_comp, Function.comp_apply,\n      AlgHom.toLinearMap_apply, LinearMap.zero_apply]\n    exact \u03b9_normalOrderF_superCommuteF_ofCrAnListF_ofCrAnListF_eq_zero \u03c6a \u03c6a' \u03c6s l\n  change (\u03b9.toLinearMap \u2218\u2097 normalOrderF \u2218\u2097\n    mulLinearMap ((ofCrAnListF \u03c6s * [ofCrAnOpF \u03c6a, ofCrAnOpF \u03c6a']\u209bca))) a = 0\n  rw [hf]\n  simp\n\nlemma \u03b9_normalOrderF_superCommuteF_ofCrAnOpF_eq_zero_mul (\u03c6a \u03c6a' : \ud835\udcd5.CrAnFieldOp)\n    (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \u03b9 \ud835\udcdd\u1da0(a * [ofCrAnOpF \u03c6a, ofCrAnOpF \u03c6a']\u209bca * b) = 0 := by\n  rw [mul_assoc]\n  change (\u03b9.toLinearMap \u2218\u2097 normalOrderF \u2218\u2097 mulLinearMap.flip\n    ([ofCrAnOpF \u03c6a, ofCrAnOpF \u03c6a']\u209bca * b)) a = 0\n  have hf : \u03b9.toLinearMap \u2218\u2097 normalOrderF \u2218\u2097 mulLinearMap.flip\n      ([ofCrAnOpF \u03c6a, ofCrAnOpF \u03c6a']\u209bca * b) = 0 := by\n    apply ofCrAnListFBasis.ext\n    intro l\n    simp only [mulLinearMap, FieldOpFreeAlgebra.ofListBasis_eq_ofList, LinearMap.coe_comp,\n      Function.comp_apply, LinearMap.flip_apply, LinearMap.coe_mk, AddHom.coe_mk,\n      AlgHom.toLinearMap_apply, LinearMap.zero_apply]\n    rw [\u2190 mul_assoc]\n    exact \u03b9_normalOrderF_superCommuteF_ofCrAnListF_eq_zero \u03c6a \u03c6a' _ _\n  rw [hf]\n  simp\n\nlemma \u03b9_normalOrderF_superCommuteF_ofCrAnOpF_ofCrAnListF_eq_zero_mul (\u03c6a : \ud835\udcd5.CrAnFieldOp)\n    (\u03c6s : List \ud835\udcd5.CrAnFieldOp) (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \u03b9 \ud835\udcdd\u1da0(a * [ofCrAnOpF \u03c6a, ofCrAnListF \u03c6s]\u209bca * b) = 0 := by\n  rw [\u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF_eq_sum]\n  rw [Finset.mul_sum, Finset.sum_mul]\n  rw [map_sum, map_sum]\n  apply Fintype.sum_eq_zero\n  intro n\n  rw [\u2190 mul_assoc, \u2190 mul_assoc]\n  rw [mul_assoc _ _ b, ofCrAnListF_singleton]\n  rw [\u03b9_normalOrderF_superCommuteF_ofCrAnOpF_eq_zero_mul]\n\nlemma \u03b9_normalOrderF_superCommuteF_ofCrAnListF_ofCrAnOpF_eq_zero_mul (\u03c6a : \ud835\udcd5.CrAnFieldOp)\n    (\u03c6s : List \ud835\udcd5.CrAnFieldOp) (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \u03b9 \ud835\udcdd\u1da0(a * [ofCrAnListF \u03c6s, ofCrAnOpF \u03c6a]\u209bca * b) = 0 := by\n  rw [\u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF_symm, ofCrAnListF_singleton]\n  simp only [FieldStatistic.instCommGroup.eq_1, FieldStatistic.ofList_singleton, mul_neg,\n    Algebra.mul_smul_comm, neg_mul, Algebra.smul_mul_assoc, map_neg, map_smul]\n  rw [\u03b9_normalOrderF_superCommuteF_ofCrAnOpF_ofCrAnListF_eq_zero_mul]\n  simp\n\nlemma \u03b9_normalOrderF_superCommuteF_ofCrAnListF_ofCrAnListF_eq_zero_mul\n    (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) (a b : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \u03b9 \ud835\udcdd\u1da0(a * [ofCrAnListF \u03c6s, ofCrAnListF \u03c6s']\u209bca * b) = 0 := by\n  rw [superCommuteF_ofCrAnListF_ofCrAnListF_eq_sum, Finset.mul_sum, Finset.sum_mul]\n  rw [map_sum, map_sum]\n  apply Fintype.sum_eq_zero\n  intro n\n  rw [\u2190 mul_assoc, \u2190 mul_assoc]\n  rw [mul_assoc _ _ b]\n  rw [\u03b9_normalOrderF_superCommuteF_ofCrAnListF_ofCrAnOpF_eq_zero_mul]\n\nlemma \u03b9_normalOrderF_superCommuteF_ofCrAnListF_eq_zero_mul\n    (\u03c6s : List \ud835\udcd5.CrAnFieldOp)\n    (a b c : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \u03b9 \ud835\udcdd\u1da0(a * [ofCrAnListF \u03c6s, c]\u209bca * b) = 0 := by\n  change (\u03b9.toLinearMap \u2218\u2097 normalOrderF \u2218\u2097\n    mulLinearMap.flip b \u2218\u2097 mulLinearMap a \u2218\u2097 superCommuteF (ofCrAnListF \u03c6s)) c = 0\n  have hf : (\u03b9.toLinearMap \u2218\u2097 normalOrderF \u2218\u2097\n    mulLinearMap.flip b \u2218\u2097 mulLinearMap a \u2218\u2097 superCommuteF (ofCrAnListF \u03c6s)) = 0 := by\n    apply ofCrAnListFBasis.ext\n    intro \u03c6s'\n    simp only [mulLinearMap, LinearMap.coe_mk, AddHom.coe_mk, ofListBasis_eq_ofList,\n      LinearMap.coe_comp, Function.comp_apply, LinearMap.flip_apply, AlgHom.toLinearMap_apply,\n      LinearMap.zero_apply]\n    rw [\u03b9_normalOrderF_superCommuteF_ofCrAnListF_ofCrAnListF_eq_zero_mul]\n  rw [hf]\n  simp\n\n@[simp]\nlemma \u03b9_normalOrderF_superCommuteF_eq_zero_mul\n    (a b c d : \ud835\udcd5.FieldOpFreeAlgebra) : \u03b9 \ud835\udcdd\u1da0(a * [d, c]\u209bca * b) = 0 := by\n  change (\u03b9.toLinearMap \u2218\u2097 normalOrderF \u2218\u2097\n    mulLinearMap.flip b \u2218\u2097 mulLinearMap a \u2218\u2097 superCommuteF.flip c) d = 0\n  have hf : (\u03b9.toLinearMap \u2218\u2097 normalOrderF \u2218\u2097\n    mulLinearMap.flip b \u2218\u2097 mulLinearMap a \u2218\u2097 superCommuteF.flip c) = 0 := by\n    apply ofCrAnListFBasis.ext\n    intro \u03c6s\n    simp only [mulLinearMap, LinearMap.coe_mk, AddHom.coe_mk, ofListBasis_eq_ofList,\n      LinearMap.coe_comp, Function.comp_apply, LinearMap.flip_apply, AlgHom.toLinearMap_apply,\n      LinearMap.zero_apply]\n    rw [\u03b9_normalOrderF_superCommuteF_ofCrAnListF_eq_zero_mul]\n  rw [hf]\n  simp\n\n@[simp]\nlemma \u03b9_normalOrder_superCommuteF_eq_zero_mul_right (b c d : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \u03b9 \ud835\udcdd\u1da0([d, c]\u209bca * b) = 0 := by\n  rw [\u2190 \u03b9_normalOrderF_superCommuteF_eq_zero_mul 1 b c d]\n  simp\n\n", "theoremStatement": "@[simp]\nlemma \u03b9_normalOrderF_superCommuteF_eq_zero_mul_left (a c d : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \u03b9 \ud835\udcdd\u1da0(a * [d, c]\u209bca) = 0 ", "theoremName": "FieldSpecification.FieldOpAlgebra.\u03b9_normalOrderF_superCommuteF_eq_zero_mul_left", "fileCreated": {"commit": "2e82f842a242717b98517656fc34b1b92f579b2e", "date": "2025-02-05"}, "theoremCreated": {"commit": "f5e7bbad5971e380f8e9aa4f340d21a1d324f1a4", "date": "2025-01-30"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpAlgebra/NormalOrder/Basic.lean", "module": "HepLean.PerturbationTheory.FieldOpAlgebra.NormalOrder.Basic", "jsonFile": "HepLean.PerturbationTheory.FieldOpAlgebra.NormalOrder.Basic.jsonl", "positionMetadata": {"lineInFile": 158, "tokenPositionInFile": 6557, "theoremPositionInFile": 9}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 9, "numPremises": 78}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [\u2190 \u03b9_normalOrderF_superCommuteF_eq_zero_mul a 1 c d]\n  simp", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 70}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpAlgebra.NormalOrder.Basic\n/-!\n\n# Basic properties of normal ordering\n\n-/\n\nnamespace FieldSpecification\nopen FieldOpFreeAlgebra\nopen HepLean.List\nopen FieldStatistic\n\nnamespace FieldOpAlgebra\nvariable {\ud835\udcd5 : FieldSpecification}\n\n/-!\n\n## Properties of normal ordering.\n\n-/\n\nlemma normalOrder_eq_\u03b9_normalOrderF (a : \ud835\udcd5.FieldOpFreeAlgebra) :\n    \ud835\udcdd(\u03b9 a) = \u03b9 \ud835\udcdd\u1da0(a) := rfl\n\nlemma normalOrder_ofCrAnList (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    \ud835\udcdd(ofCrAnList \u03c6s) = normalOrderSign \u03c6s \u2022 ofCrAnList (normalOrderList \u03c6s) := by\n  rw [ofCrAnList, normalOrder_eq_\u03b9_normalOrderF, normalOrderF_ofCrAnListF]\n  rfl\n\n@[simp]\nlemma normalOrder_one_eq_one : normalOrder (\ud835\udcd5 := \ud835\udcd5) 1 = 1 := by\n  have h1 : 1 = ofCrAnList (\ud835\udcd5 := \ud835\udcd5) [] := by simp [ofCrAnList]\n  rw [h1]\n  rw [normalOrder_ofCrAnList]\n  simp\n\n@[simp]\nlemma normalOrder_ofFieldOpList_nil : normalOrder (\ud835\udcd5 := \ud835\udcd5) (ofFieldOpList []) = 1 := by\n  rw [ofFieldOpList]\n  rw [normalOrder_eq_\u03b9_normalOrderF]\n  simp only [ofFieldOpListF_nil]\n  change normalOrder (\ud835\udcd5 := \ud835\udcd5) 1 = _\n  simp\n\n@[simp]\nlemma normalOrder_ofCrAnList_nil : normalOrder (\ud835\udcd5 := \ud835\udcd5) (ofCrAnList []) = 1 := by\n  rw [normalOrder_ofCrAnList]\n  simp only [normalOrderSign_nil, normalOrderList_nil, one_smul]\n  rfl\n\nlemma ofCrAnList_eq_normalOrder (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnList (normalOrderList \u03c6s) = normalOrderSign \u03c6s \u2022 \ud835\udcdd(ofCrAnList \u03c6s) := by\n  rw [normalOrder_ofCrAnList, smul_smul, normalOrderSign, Wick.koszulSign_mul_self,\n    one_smul]\n\nlemma normalOrder_normalOrder_mid (a b c : \ud835\udcd5.FieldOpAlgebra) :\n    \ud835\udcdd(a * b * c) = \ud835\udcdd(a * \ud835\udcdd(b) * c) := by\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n  obtain \u27e8c, rfl\u27e9 := \u03b9_surjective c\n  rw [normalOrder_eq_\u03b9_normalOrderF]\n  simp only [\u2190 map_mul]\n  rw [normalOrder_eq_\u03b9_normalOrderF]\n  rw [normalOrderF_normalOrderF_mid]\n  rfl\n\nlemma normalOrder_normalOrder_left (a b : \ud835\udcd5.FieldOpAlgebra) :\n    \ud835\udcdd(a * b) = \ud835\udcdd(\ud835\udcdd(a) * b) := by\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n  rw [normalOrder_eq_\u03b9_normalOrderF]\n  simp only [\u2190 map_mul]\n  rw [normalOrder_eq_\u03b9_normalOrderF]\n  rw [normalOrderF_normalOrderF_left]\n  rfl\n\nlemma normalOrder_normalOrder_right (a b : \ud835\udcd5.FieldOpAlgebra) :\n    \ud835\udcdd(a * b) = \ud835\udcdd(a * \ud835\udcdd(b)) := by\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n  rw [normalOrder_eq_\u03b9_normalOrderF]\n  simp only [\u2190 map_mul]\n  rw [normalOrder_eq_\u03b9_normalOrderF]\n  rw [normalOrderF_normalOrderF_right]\n  rfl\n\nlemma normalOrder_normalOrder (a : \ud835\udcd5.FieldOpAlgebra) : \ud835\udcdd(\ud835\udcdd(a)) = \ud835\udcdd(a) := by\n  trans \ud835\udcdd(\ud835\udcdd(a) * 1)\n  \u00b7 simp\n  \u00b7 rw [\u2190 normalOrder_normalOrder_left]\n    simp\n\n/-!\n\n## mul anpart and crpart\n-/\n\nlemma normalOrder_mul_anPart (\u03c6 : \ud835\udcd5.FieldOp) (a : \ud835\udcd5.FieldOpAlgebra) :\n    \ud835\udcdd(a * anPart \u03c6) = \ud835\udcdd(a) * anPart \u03c6 := by\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  rw [anPart, \u2190 map_mul, normalOrder_eq_\u03b9_normalOrderF, normalOrderF_mul_anPartF]\n  rfl\n\nlemma crPart_mul_normalOrder (\u03c6 : \ud835\udcd5.FieldOp) (a : \ud835\udcd5.FieldOpAlgebra) :\n    \ud835\udcdd(crPart \u03c6 * a) = crPart \u03c6 * \ud835\udcdd(a) := by\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  rw [crPart, \u2190 map_mul, normalOrder_eq_\u03b9_normalOrderF, normalOrderF_crPartF_mul]\n  rfl\n\n/-!\n\n### Normal order and super commutes\n\n-/\n\n/-- For a field specification `\ud835\udcd5`, and `a` and `b` in `\ud835\udcd5.FieldOpAlgebra` the normal ordering\n  of the super commutator of `a` and `b` vanishes, i.e. `\ud835\udcdd([a,b]\u209b) = 0`. -/\n@[simp]\nlemma normalOrder_superCommute_eq_zero (a b : \ud835\udcd5.FieldOpAlgebra) :\n    \ud835\udcdd([a, b]\u209b) = 0 := by\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n  rw [superCommute_eq_\u03b9_superCommuteF, normalOrder_eq_\u03b9_normalOrderF]\n  simp\n\n@[simp]\nlemma normalOrder_superCommute_left_eq_zero (a b c: \ud835\udcd5.FieldOpAlgebra) :\n    \ud835\udcdd([a, b]\u209b * c) = 0 := by\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n  obtain \u27e8c, rfl\u27e9 := \u03b9_surjective c\n  rw [superCommute_eq_\u03b9_superCommuteF, \u2190 map_mul, normalOrder_eq_\u03b9_normalOrderF]\n  simp\n\n@[simp]\nlemma normalOrder_superCommute_right_eq_zero (a b c: \ud835\udcd5.FieldOpAlgebra) :\n    \ud835\udcdd(c * [a, b]\u209b) = 0 := by\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n  obtain \u27e8c, rfl\u27e9 := \u03b9_surjective c\n  rw [superCommute_eq_\u03b9_superCommuteF, \u2190 map_mul, normalOrder_eq_\u03b9_normalOrderF]\n  simp\n\n@[simp]\nlemma normalOrder_superCommute_mid_eq_zero (a b c d : \ud835\udcd5.FieldOpAlgebra) :\n    \ud835\udcdd(a * [c, d]\u209b * b) = 0 := by\n  obtain \u27e8a, rfl\u27e9 := \u03b9_surjective a\n  obtain \u27e8b, rfl\u27e9 := \u03b9_surjective b\n  obtain \u27e8c, rfl\u27e9 := \u03b9_surjective c\n  obtain \u27e8d, rfl\u27e9 := \u03b9_surjective d\n  rw [superCommute_eq_\u03b9_superCommuteF, \u2190 map_mul, \u2190 map_mul, normalOrder_eq_\u03b9_normalOrderF]\n  simp\n\n/-!\n\n### Swapping terms in a normal order.\n\n-/\n\nlemma normalOrder_ofFieldOp_ofFieldOp_swap (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    \ud835\udcdd(ofFieldOp \u03c6 * ofFieldOp \u03c6') = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 \ud835\udcdd(ofFieldOp \u03c6' * ofFieldOp \u03c6) := by\n  rw [ofFieldOp_mul_ofFieldOp_eq_superCommute]\n  simp\n\nlemma normalOrder_ofCrAnOp_ofCrAnList (\u03c6 : \ud835\udcd5.CrAnFieldOp)\n    (\u03c6s : List \ud835\udcd5.CrAnFieldOp) : \ud835\udcdd(ofCrAnOp \u03c6 * ofCrAnList \u03c6s) =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 \ud835\udcdd(ofCrAnList \u03c6s * ofCrAnOp \u03c6) := by\n  rw [\u2190 ofCrAnList_singleton, ofCrAnList_mul_ofCrAnList_eq_superCommute]\n  simp\n\nlemma normalOrder_ofCrAnOp_ofFieldOpList_swap (\u03c6 : \ud835\udcd5.CrAnFieldOp) (\u03c6' : List \ud835\udcd5.FieldOp) :\n    \ud835\udcdd(ofCrAnOp \u03c6 * ofFieldOpList \u03c6') = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022\n    \ud835\udcdd(ofFieldOpList \u03c6' * ofCrAnOp \u03c6) := by\n  rw [\u2190 ofCrAnList_singleton, ofCrAnList_mul_ofFieldOpList_eq_superCommute]\n  simp\n\nlemma normalOrder_anPart_ofFieldOpList_swap (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6' : List \ud835\udcd5.FieldOp) :\n    \ud835\udcdd(anPart \u03c6 * ofFieldOpList \u03c6') = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 \ud835\udcdd(ofFieldOpList \u03c6' * anPart \u03c6) := by\n  match \u03c6 with\n  | .inAsymp \u03c6 =>\n    simp\n  | .position \u03c6 =>\n    simp only [anPart_position, instCommGroup.eq_1]\n    rw [normalOrder_ofCrAnOp_ofFieldOpList_swap]\n    rfl\n  | .outAsymp \u03c6 =>\n    simp only [anPart_posAsymp, instCommGroup.eq_1]\n    rw [normalOrder_ofCrAnOp_ofFieldOpList_swap]\n    rfl\n\nlemma normalOrder_ofFieldOpList_anPart_swap (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6' : List \ud835\udcd5.FieldOp) :\n    \ud835\udcdd(ofFieldOpList \u03c6' * anPart \u03c6) = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 \ud835\udcdd(anPart \u03c6 * ofFieldOpList \u03c6') := by\n  rw [normalOrder_anPart_ofFieldOpList_swap]\n  simp [smul_smul, FieldStatistic.exchangeSign_mul_self]\n\nlemma normalOrder_ofFieldOpList_mul_anPart_swap (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    \ud835\udcdd(ofFieldOpList \u03c6s) * anPart \u03c6 = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 \ud835\udcdd(anPart \u03c6 * ofFieldOpList \u03c6s) := by\n  rw [\u2190 normalOrder_mul_anPart]\n  rw [normalOrder_ofFieldOpList_anPart_swap]\n\nlemma anPart_mul_normalOrder_ofFieldOpList_eq_superCommute (\u03c6 : \ud835\udcd5.FieldOp)\n    (\u03c6s' : List \ud835\udcd5.FieldOp) : anPart \u03c6 * \ud835\udcdd(ofFieldOpList \u03c6s') =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s') \u2022 \ud835\udcdd(ofFieldOpList \u03c6s' * anPart \u03c6) +\n    [anPart \u03c6, \ud835\udcdd(ofFieldOpList \u03c6s')]\u209b := by\n  rw [anPart, ofFieldOpList, normalOrder_eq_\u03b9_normalOrderF, \u2190 map_mul]\n  rw [anPartF_mul_normalOrderF_ofFieldOpListF_eq_superCommuteF]\n  simp only [instCommGroup.eq_1, map_add, map_smul]\n  rfl\n\n/-!\n\n## Super commutators with a normal ordered term as sums\n\n-/\n\n/--\nFor a field specification `\ud835\udcd5`, an element `\u03c6` of `\ud835\udcd5.CrAnFieldOp`, a list `\u03c6s` of `\ud835\udcd5.CrAnFieldOp`,\n  the following relation holds\n\n`[\u03c6, \ud835\udcdd(\u03c6\u2080\u2026\u03c6\u2099)]\u209b = \u2211 i, \ud835\udce2(\u03c6, \u03c6\u2080\u2026\u03c6\u1d62\u208b\u2081) \u2022 [\u03c6, \u03c6\u1d62]\u209b * \ud835\udcdd(\u03c6\u2080\u2026\u03c6\u1d62\u208b\u2081\u03c6\u1d62\u208a\u2081\u2026\u03c6\u2099)`.\n\nThe proof of this result ultimately goes as follows\n- The definition of `normalOrder` is used to rewrite `\ud835\udcdd(\u03c6\u2080\u2026\u03c6\u2099)` as a scalar multiple of\n  a `ofCrAnList \u03c6sn` where `\u03c6sn` is the normal ordering of `\u03c6\u2080\u2026\u03c6\u2099`.\n- `superCommuteF_ofCrAnListF_ofCrAnListF_eq_sum` is used to rewrite the super commutator of `\u03c6`\n  (considered as a list with one element) with\n  `ofCrAnList \u03c6sn` as a sum of super commutators, one for each element of `\u03c6sn`.\n- The fact that super-commutators are in the center of `\ud835\udcd5.FieldOpAlgebra` is used to  rearrange\n  terms.\n- Properties of ordered lists, and `normalOrderSign_eraseIdx` are then used to complete the proof.\n-/\nlemma ofCrAnOp_superCommute_normalOrder_ofCrAnList_sum (\u03c6 : \ud835\udcd5.CrAnFieldOp)\n    (\u03c6s : List \ud835\udcd5.CrAnFieldOp) : [ofCrAnOp \u03c6, \ud835\udcdd(ofCrAnList \u03c6s)]\u209b = \u2211 n : Fin \u03c6s.length,\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b (\u03c6s.take n)) \u2022 [ofCrAnOp \u03c6, ofCrAnOp \u03c6s[n]]\u209b\n    * \ud835\udcdd(ofCrAnList (\u03c6s.eraseIdx n)) := by\n  rw [normalOrder_ofCrAnList, map_smul]\n  rw [superCommute_ofCrAnOp_ofCrAnList_eq_sum, Finset.smul_sum,\n    sum_normalOrderList_length]\n  congr\n  funext n\n  simp only [instCommGroup.eq_1, List.get_eq_getElem, normalOrderList_get_normalOrderEquiv,\n    normalOrderList_eraseIdx_normalOrderEquiv, Algebra.smul_mul_assoc, Fin.getElem_fin]\n  rw [ofCrAnList_eq_normalOrder, mul_smul_comm, smul_smul, smul_smul]\n  by_cases hs : (\ud835\udcd5 |>\u209b \u03c6) = (\ud835\udcd5 |>\u209b \u03c6s[n])\n  \u00b7 congr\n    erw [normalOrderSign_eraseIdx, \u2190 hs]\n    trans (normalOrderSign \u03c6s * normalOrderSign \u03c6s) *\n      (\ud835\udce2(\ud835\udcd5 |>\u209b (\u03c6s.get n), \ud835\udcd5 |>\u209b ((normalOrderList \u03c6s).take (normalOrderEquiv n))) *\n      \ud835\udce2(\ud835\udcd5 |>\u209b (\u03c6s.get n), \ud835\udcd5 |>\u209b ((normalOrderList \u03c6s).take (normalOrderEquiv n))))\n      * \ud835\udce2(\ud835\udcd5 |>\u209b (\u03c6s.get n), \ud835\udcd5 |>\u209b (\u03c6s.take n))\n    \u00b7 ring_nf\n      rw [hs]\n      rfl\n    \u00b7 simp [hs]\n  \u00b7 erw [superCommute_diff_statistic hs]\n    simp\n\nlemma ofCrAnOp_superCommute_normalOrder_ofFieldOpList_sum (\u03c6 : \ud835\udcd5.CrAnFieldOp)\n    (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [ofCrAnOp \u03c6, \ud835\udcdd(ofFieldOpList \u03c6s)]\u209b = \u2211 n : Fin \u03c6s.length, \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b (\u03c6s.take n)) \u2022\n    [ofCrAnOp \u03c6, ofFieldOp \u03c6s[n]]\u209b * \ud835\udcdd(ofFieldOpList (\u03c6s.eraseIdx n)) := by\n  conv_lhs =>\n    rw [ofFieldOpList_eq_sum, map_sum, map_sum]\n    enter [2, s]\n    rw [ofCrAnOp_superCommute_normalOrder_ofCrAnList_sum, CrAnSection.sum_over_length]\n    enter [2, n]\n    rw [CrAnSection.take_statistics_eq_take_state_statistics, smul_mul_assoc]\n  rw [Finset.sum_comm]\n  refine Finset.sum_congr rfl (fun n _ => ?_)\n  simp only [instCommGroup.eq_1, Fin.coe_cast, Fin.getElem_fin,\n    CrAnSection.sum_eraseIdxEquiv n _ n.prop,\n    CrAnSection.eraseIdxEquiv_symm_getElem,\n    CrAnSection.eraseIdxEquiv_symm_eraseIdx, \u2190 Finset.smul_sum, Algebra.smul_mul_assoc]\n  conv_lhs =>\n    enter [2, 2, n]\n    rw [\u2190 Finset.mul_sum]\n  rw [\u2190 Finset.sum_mul, \u2190 map_sum, \u2190 map_sum, \u2190 ofFieldOp_eq_sum, \u2190 ofFieldOpList_eq_sum]\n\n", "theoremStatement": "/--\nThe commutator of the annihilation part of a field operator with a normal ordered list of field\noperators can be decomposed into the sum of the commutators of the annihilation part with each\nelement of the list of field operators, i.e.\n`[anPart \u03c6, \ud835\udcdd(\u03c6\u2080\u2026\u03c6\u2099)]\u209b= \u2211 i, \ud835\udce2(\u03c6, \u03c6\u2080\u2026\u03c6\u1d62\u208b\u2081) \u2022 [anPart \u03c6, \u03c6\u1d62]\u209b * \ud835\udcdd(\u03c6\u2080\u2026\u03c6\u1d62\u208b\u2081\u03c6\u1d62\u208a\u2081\u2026\u03c6\u2099)`.\n-/\nlemma anPart_superCommute_normalOrder_ofFieldOpList_sum (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [anPart \u03c6, \ud835\udcdd(ofFieldOpList \u03c6s)]\u209b = \u2211 n : Fin \u03c6s.length, \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b (\u03c6s.take n)) \u2022\n    [anPart \u03c6, ofFieldOpF \u03c6s[n]]\u209b * \ud835\udcdd(ofFieldOpList (\u03c6s.eraseIdx n)) ", "theoremName": "FieldSpecification.FieldOpAlgebra.anPart_superCommute_normalOrder_ofFieldOpList_sum", "fileCreated": {"commit": "2e82f842a242717b98517656fc34b1b92f579b2e", "date": "2025-02-05"}, "theoremCreated": {"commit": "fc2009928299f5a839dd880670f22245b6a09f72", "date": "2025-01-30"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpAlgebra/NormalOrder/Lemmas.lean", "module": "HepLean.PerturbationTheory.FieldOpAlgebra.NormalOrder.Lemmas", "jsonFile": "HepLean.PerturbationTheory.FieldOpAlgebra.NormalOrder.Lemmas.jsonl", "positionMetadata": {"lineInFile": 284, "tokenPositionInFile": 10037, "theoremPositionInFile": 25}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 34, "numPremises": 187}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  match \u03c6 with\n  | .inAsymp \u03c6 =>\n    simp\n  | .position \u03c6 =>\n    simp only [anPart_position, instCommGroup.eq_1, Fin.getElem_fin, Algebra.smul_mul_assoc]\n    rw [ofCrAnOp_superCommute_normalOrder_ofFieldOpList_sum]\n    simp only [instCommGroup.eq_1, crAnStatistics, Function.comp_apply, crAnFieldOpToFieldOp_prod,\n      Fin.getElem_fin, Algebra.smul_mul_assoc]\n    rfl\n  | .outAsymp \u03c6 =>\n    simp only [anPart_posAsymp, instCommGroup.eq_1, Fin.getElem_fin, Algebra.smul_mul_assoc]\n    rw [ofCrAnOp_superCommute_normalOrder_ofFieldOpList_sum]\n    simp only [instCommGroup.eq_1, crAnStatistics, Function.comp_apply, crAnFieldOpToFieldOp_prod,\n      Fin.getElem_fin, Algebra.smul_mul_assoc]\n    rfl", "proofType": "tactic", "proofLengthLines": 15, "proofLengthTokens": 701}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldSpecification.CrAnSection\nimport HepLean.PerturbationTheory.FieldSpecification.NormalOrder\n/-!\n\n# Time ordering of states\n\n-/\n\nnamespace FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\n/-!\n\n## Time ordering for states\n\n-/\n\n/-- The time ordering relation on states. We have that `timeOrderRel \u03c60 \u03c61` is true\n  if and only if `\u03c61` has a time less-then or equal to `\u03c60`, or `\u03c61` is a negative\n  asymptotic state, or `\u03c60` is a positive asymptotic state. -/\ndef timeOrderRel : \ud835\udcd5.FieldOp \u2192 \ud835\udcd5.FieldOp \u2192 Prop\n  | FieldOp.outAsymp _, _ => True\n  | FieldOp.position \u03c60, FieldOp.position \u03c61 => \u03c61.2 0 \u2264 \u03c60.2 0\n  | FieldOp.position _, FieldOp.inAsymp _ => True\n  | FieldOp.position _, FieldOp.outAsymp _ => False\n  | FieldOp.inAsymp _, FieldOp.outAsymp _ => False\n  | FieldOp.inAsymp _, FieldOp.position _ => False\n  | FieldOp.inAsymp _, FieldOp.inAsymp _ => True\n\n/-- The relation `timeOrderRel` is decidable, but not computable so due to\n  `Real.decidableLE`. -/\nnoncomputable instance : (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) \u2192 Decidable (timeOrderRel \u03c6 \u03c6')\n  | FieldOp.outAsymp _, _ => isTrue True.intro\n  | FieldOp.position \u03c60, FieldOp.position \u03c61 => inferInstanceAs (Decidable (\u03c61.2 0 \u2264 \u03c60.2 0))\n  | FieldOp.position _, FieldOp.inAsymp _ => isTrue True.intro\n  | FieldOp.position _, FieldOp.outAsymp _ => isFalse (fun a => a)\n  | FieldOp.inAsymp _, FieldOp.outAsymp _ => isFalse (fun a => a)\n  | FieldOp.inAsymp _, FieldOp.position _ => isFalse (fun a => a)\n  | FieldOp.inAsymp _, FieldOp.inAsymp _ => isTrue True.intro\n\n/-- Time ordering is total. -/\ninstance : IsTotal \ud835\udcd5.FieldOp \ud835\udcd5.timeOrderRel where\n  total a b := by\n    cases a <;> cases b <;>\n      simp only [or_self, or_false, or_true, timeOrderRel, Fin.isValue, implies_true, imp_self,\n        IsEmpty.forall_iff]\n    exact LinearOrder.le_total _ _\n\n/-- Time ordering is transitive. -/\ninstance : IsTrans \ud835\udcd5.FieldOp \ud835\udcd5.timeOrderRel where\n  trans a b c := by\n    cases a <;> cases b <;> cases c <;>\n      simp only [timeOrderRel, Fin.isValue, implies_true, imp_self, IsEmpty.forall_iff]\n    exact fun h1 h2 => Preorder.le_trans _ _ _ h2 h1\n\nnoncomputable section\n\nopen FieldStatistic\nopen HepLean.List\n\n/-- Given a list `\u03c6 :: \u03c6s` of states, the (zero-based) position of the state which is\n  of maximum time. For example\n  - for the list `[\u03c61(t = 4), \u03c62(t = 5), \u03c63(t = 3), \u03c64(t = 5)]` this would return `1`.\n  This is defined for a list `\u03c6 :: \u03c6s` instead of `\u03c6s` to ensure that such a position exists.\n-/\ndef maxTimeFieldPos (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) : \u2115 :=\n  insertionSortMinPos timeOrderRel \u03c6 \u03c6s\n\nlemma maxTimeFieldPos_lt_length (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    maxTimeFieldPos \u03c6 \u03c6s < (\u03c6 :: \u03c6s).length := by\n  simp [maxTimeFieldPos]\n\n/-- Given a list `\u03c6 :: \u03c6s` of states, the left-most state of maximum time, if there are more.\n  As an example:\n  - for the list `[\u03c61(t = 4), \u03c62(t = 5), \u03c63(t = 3), \u03c64(t = 5)]` this would return `\u03c62(t = 5)`.\n  It is the state at the position `maxTimeFieldPos \u03c6 \u03c6s`.\n-/\ndef maxTimeField (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) : \ud835\udcd5.FieldOp :=\n  insertionSortMin timeOrderRel \u03c6 \u03c6s\n\n/-- Given a list `\u03c6 :: \u03c6s` of states, the list with the left-most state of maximum\n  time removed.\n  As an example:\n  - for the list `[\u03c61(t = 4), \u03c62(t = 5), \u03c63(t = 3), \u03c64(t = 5)]` this would return\n    `[\u03c61(t = 4), \u03c63(t = 3), \u03c64(t = 5)]`.\n-/\ndef eraseMaxTimeField (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) : List \ud835\udcd5.FieldOp :=\n  insertionSortDropMinPos timeOrderRel \u03c6 \u03c6s\n\n@[simp]\nlemma eraseMaxTimeField_length (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    (eraseMaxTimeField \u03c6 \u03c6s).length = \u03c6s.length := by\n  simp [eraseMaxTimeField, insertionSortDropMinPos, eraseIdx_length']\n\nlemma maxTimeFieldPos_lt_eraseMaxTimeField_length_succ (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    maxTimeFieldPos \u03c6 \u03c6s < (eraseMaxTimeField \u03c6 \u03c6s).length.succ := by\n  simp only [eraseMaxTimeField_length, Nat.succ_eq_add_one]\n  exact maxTimeFieldPos_lt_length \u03c6 \u03c6s\n\n/-- Given a list `\u03c6 :: \u03c6s` of states, the position of the left-most state of maximum\n  time as an element of `Fin (eraseMaxTimeField \u03c6 \u03c6s).length.succ`.\n  As an example:\n  - for the list `[\u03c61(t = 4), \u03c62(t = 5), \u03c63(t = 3), \u03c64(t = 5)]` this would return `\u27e81,...\u27e9`.\n-/\ndef maxTimeFieldPosFin (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    Fin (eraseMaxTimeField \u03c6 \u03c6s).length.succ :=\n  insertionSortMinPosFin timeOrderRel \u03c6 \u03c6s\n\nlemma lt_maxTimeFieldPosFin_not_timeOrder (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp)\n    (i : Fin (eraseMaxTimeField \u03c6 \u03c6s).length)\n    (hi : (maxTimeFieldPosFin \u03c6 \u03c6s).succAbove i < maxTimeFieldPosFin \u03c6 \u03c6s) :\n    \u00ac timeOrderRel ((eraseMaxTimeField \u03c6 \u03c6s)[i.val]) (maxTimeField \u03c6 \u03c6s) := by\n  exact insertionSortMin_lt_mem_insertionSortDropMinPos_of_lt timeOrderRel \u03c6 \u03c6s i hi\n\nlemma timeOrder_maxTimeField (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp)\n    (i : Fin (eraseMaxTimeField \u03c6 \u03c6s).length) :\n    timeOrderRel (maxTimeField \u03c6 \u03c6s) ((eraseMaxTimeField \u03c6 \u03c6s)[i.val]) := by\n  exact insertionSortMin_lt_mem_insertionSortDropMinPos timeOrderRel \u03c6 \u03c6s _\n\n/-- The sign associated with putting a list of states into time order (with\n  the state of greatest time to the left).\n  We pick up a minus sign for every fermion paired crossed. -/\ndef timeOrderSign (\u03c6s : List \ud835\udcd5.FieldOp) : \u2102 :=\n  Wick.koszulSign \ud835\udcd5.fieldOpStatistic \ud835\udcd5.timeOrderRel \u03c6s\n\n@[simp]\nlemma timeOrderSign_nil : timeOrderSign (\ud835\udcd5 := \ud835\udcd5) [] = 1 := by\n  simp only [timeOrderSign]\n  rfl\n\nlemma timeOrderSign_pair_ordered {\u03c6 \u03c8 : \ud835\udcd5.FieldOp} (h : timeOrderRel \u03c6 \u03c8) :\n    timeOrderSign [\u03c6, \u03c8] = 1 := by\n  simp only [timeOrderSign, Wick.koszulSign, Wick.koszulSignInsert, mul_one, ite_eq_left_iff,\n    ite_eq_right_iff, and_imp]\n  exact fun h' => False.elim (h' h)\n\n", "theoremStatement": "lemma timeOrderSign_pair_not_ordered {\u03c6 \u03c8 : \ud835\udcd5.FieldOp} (h : \u00ac timeOrderRel \u03c6 \u03c8) :\n    timeOrderSign [\u03c6, \u03c8] = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c8) ", "theoremName": "FieldSpecification.timeOrderSign_pair_not_ordered", "fileCreated": {"commit": "b5c987180a78e45ea7ddb402cd866df26a7c1fa1", "date": "2025-01-21"}, "theoremCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "file": "HepLean/HepLean/PerturbationTheory/FieldSpecification/TimeOrder.lean", "module": "HepLean.PerturbationTheory.FieldSpecification.TimeOrder", "jsonFile": "HepLean.PerturbationTheory.FieldSpecification.TimeOrder.jsonl", "positionMetadata": {"lineInFile": 142, "tokenPositionInFile": 5826, "theoremPositionInFile": 12}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 14, "numPremises": 71}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp only [timeOrderSign, Wick.koszulSign, Wick.koszulSignInsert, mul_one, instCommGroup.eq_1]\n  rw [if_neg h]\n  simp [FieldStatistic.exchangeSign_eq_if]", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 161}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpAlgebra.Basic\n/-!\n\n# Grading on the field operation algebra\n\n-/\n\nnamespace FieldSpecification\nopen FieldOpFreeAlgebra\nopen HepLean.List\nopen FieldStatistic\n\nnamespace FieldOpAlgebra\nvariable {\ud835\udcd5 : FieldSpecification}\n\n/-- The submodule of `\ud835\udcd5.FieldOpAlgebra` spanned by lists of field statistic `f`. -/\ndef statSubmodule (f : FieldStatistic) : Submodule \u2102 \ud835\udcd5.FieldOpAlgebra :=\n  Submodule.span \u2102 {a | \u2203 \u03c6s, a = ofCrAnList \u03c6s \u2227 (\ud835\udcd5 |>\u209b \u03c6s) = f}\n\nlemma ofCrAnList_mem_statSubmodule_of_eq (\u03c6s : List \ud835\udcd5.CrAnFieldOp) (f : FieldStatistic)\n    (h : (\ud835\udcd5 |>\u209b \u03c6s) = f) : ofCrAnList \u03c6s \u2208 statSubmodule f :=\n  Submodule.mem_span.mpr fun _ a => a \u27e8\u03c6s, \u27e8rfl, h\u27e9\u27e9\n\nlemma ofCrAnList_mem_statSubmodule (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnList \u03c6s \u2208 statSubmodule (\ud835\udcd5 |>\u209b \u03c6s) :=\n  Submodule.mem_span.mpr fun _ a => a \u27e8\u03c6s, \u27e8rfl, rfl\u27e9\u27e9\n\nlemma mem_bosonic_of_mem_free_bosonic (a : \ud835\udcd5.FieldOpFreeAlgebra)\n    (h : a \u2208 statisticSubmodule bosonic) : \u03b9 a \u2208 statSubmodule .bosonic := by\n  let p (a : \ud835\udcd5.FieldOpFreeAlgebra) (hx : a \u2208 statisticSubmodule bosonic) : Prop :=\n    \u03b9 a \u2208 statSubmodule .bosonic\n  change p a h\n  apply Submodule.span_induction\n  \u00b7 intro x hx\n    simp only [Set.mem_setOf_eq] at hx\n    obtain \u27e8\u03c6s, rfl, h\u27e9 := hx\n    simp [p]\n    apply ofCrAnList_mem_statSubmodule_of_eq\n    exact h\n  \u00b7 simp only [map_zero, p]\n    exact Submodule.zero_mem (statSubmodule bosonic)\n  \u00b7 intro x y hx hy hpx hpy\n    simp_all only [p, map_add]\n    exact Submodule.add_mem _ hpx hpy\n  \u00b7 intro a x hx hy\n    simp_all only [p, map_smul]\n    exact Submodule.smul_mem _ _ hy\n\nlemma mem_fermionic_of_mem_free_fermionic (a : \ud835\udcd5.FieldOpFreeAlgebra)\n    (h : a \u2208 statisticSubmodule fermionic) : \u03b9 a \u2208 statSubmodule .fermionic := by\n  let p (a : \ud835\udcd5.FieldOpFreeAlgebra) (hx : a \u2208 statisticSubmodule fermionic) : Prop :=\n    \u03b9 a \u2208 statSubmodule .fermionic\n  change p a h\n  apply Submodule.span_induction\n  \u00b7 intro x hx\n    simp only [Set.mem_setOf_eq] at hx\n    obtain \u27e8\u03c6s, rfl, h\u27e9 := hx\n    simp [p]\n    apply ofCrAnList_mem_statSubmodule_of_eq\n    exact h\n  \u00b7 simp only [map_zero, p]\n    exact Submodule.zero_mem (statSubmodule fermionic)\n  \u00b7 intro x y hx hy hpx hpy\n    simp_all only [p, map_add]\n    exact Submodule.add_mem _ hpx hpy\n  \u00b7 intro a x hx hy\n    simp_all only [p, map_smul]\n    exact Submodule.smul_mem _ _ hy\n\nlemma mem_statSubmodule_of_mem_statisticSubmodule (f : FieldStatistic) (a : \ud835\udcd5.FieldOpFreeAlgebra)\n    (h : a \u2208 statisticSubmodule f) : \u03b9 a \u2208 statSubmodule f := by\n  fin_cases f\n  \u00b7 exact mem_bosonic_of_mem_free_bosonic a h\n  \u00b7 exact mem_fermionic_of_mem_free_fermionic a h\n\n/-- The projection of `statisticSubmodule (\ud835\udcd5 := \ud835\udcd5) f` defined in the free algebra to\n  `statSubmodule (\ud835\udcd5 := \ud835\udcd5) f`. -/\ndef \u03b9StateSubmodule (f : FieldStatistic) :\n    statisticSubmodule (\ud835\udcd5 := \ud835\udcd5) f \u2192\u2097[\u2102] statSubmodule (\ud835\udcd5 := \ud835\udcd5) f where\n  toFun a := \u27e8a.1, mem_statSubmodule_of_mem_statisticSubmodule f a.1 a.2\u27e9\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n\nnoncomputable section\n\n/-!\n\n## Defining bosonicProj\n\n-/\n\n/-- The projection of `\ud835\udcd5.FieldOpFreeAlgebra` to `statSubmodule (\ud835\udcd5 := \ud835\udcd5) bosonic`. -/\ndef bosonicProjFree : \ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102] statSubmodule (\ud835\udcd5 := \ud835\udcd5) bosonic :=\n  \u03b9StateSubmodule .bosonic \u2218\u2097 bosonicProjF\n\nlemma bosonicProjFree_eq_\u03b9_bosonicProjF (a : \ud835\udcd5.FieldOpFreeAlgebra) :\n    (bosonicProjFree a).1 = \u03b9 (bosonicProjF a) := rfl\n\nlemma bosonicProjFree_zero_of_\u03b9_zero (a : \ud835\udcd5.FieldOpFreeAlgebra) (h : \u03b9 a = 0) :\n    bosonicProjFree a = 0 := by\n  rw [\u03b9_eq_zero_iff_\u03b9_bosonicProjF_fermonicProj_zero] at h\n  apply Subtype.eq\n  rw [bosonicProjFree_eq_\u03b9_bosonicProjF]\n  exact h.1\n\nlemma bosonicProjFree_eq_of_equiv (a b : \ud835\udcd5.FieldOpFreeAlgebra) (h : a \u2248 b) :\n    bosonicProjFree a = bosonicProjFree b := by\n  rw [equiv_iff_sub_mem_ideal, \u2190 \u03b9_eq_zero_iff_mem_ideal] at h\n  rw [LinearMap.sub_mem_ker_iff.mp]\n  simp only [LinearMap.mem_ker, \u2190 map_sub]\n  exact bosonicProjFree_zero_of_\u03b9_zero (a - b) h\n\n/-- The projection of `\ud835\udcd5.FieldOpAlgebra` to `statSubmodule (\ud835\udcd5 := \ud835\udcd5) bosonic`. -/\ndef bosonicProj : \ud835\udcd5.FieldOpAlgebra \u2192\u2097[\u2102] statSubmodule (\ud835\udcd5 := \ud835\udcd5) bosonic where\n  toFun := Quotient.lift bosonicProjFree bosonicProjFree_eq_of_equiv\n  map_add' x y := by\n    obtain \u27e8x, hx\u27e9 := \u03b9_surjective x\n    obtain \u27e8y, hy\u27e9 := \u03b9_surjective y\n    subst hx hy\n    rw [\u2190 map_add, \u03b9_apply, \u03b9_apply, \u03b9_apply]\n    rw [Quotient.lift_mk, Quotient.lift_mk, Quotient.lift_mk]\n    simp\n  map_smul' c y := by\n    obtain \u27e8y, hy\u27e9 := \u03b9_surjective y\n    subst hy\n    rw [\u2190 map_smul, \u03b9_apply, \u03b9_apply]\n    simp\n\n", "theoremStatement": "lemma bosonicProj_eq_bosonicProjFree (a : \ud835\udcd5.FieldOpFreeAlgebra) :\n    bosonicProj (\u03b9 a) = bosonicProjFree a ", "theoremName": "FieldSpecification.FieldOpAlgebra.bosonicProj_eq_bosonicProjFree", "fileCreated": {"commit": "7d9e6af80c57599f68481948604d9f0aaba4a40f", "date": "2025-02-05"}, "theoremCreated": {"commit": "7d9e6af80c57599f68481948604d9f0aaba4a40f", "date": "2025-02-05"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpAlgebra/Grading.lean", "module": "HepLean.PerturbationTheory.FieldOpAlgebra.Grading", "jsonFile": "HepLean.PerturbationTheory.FieldOpAlgebra.Grading.jsonl", "positionMetadata": {"lineInFile": 134, "tokenPositionInFile": 4641, "theoremPositionInFile": 10}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 10, "numPremises": 49}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.Basic\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.Grading\n/-!\n\n# Super Commute\n-/\n\nnamespace FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\nnamespace FieldOpFreeAlgebra\n\n/-!\n\n## The super commutator on the FieldOpFreeAlgebra.\n\n-/\n\nopen FieldStatistic\n\n/-- For a field specification `\ud835\udcd5`, the super commutator `superCommuteF` is defined as the linear\n  map `\ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102] \ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102] \ud835\udcd5.FieldOpFreeAlgebra`\n  which on the lists `\u03c6s` and `\u03c6s'` of `\ud835\udcd5.CrAnFieldOp` gives\n\n  `superCommuteF \u03c6s \u03c6s' = \u03c6s * \u03c6s' - \ud835\udce2(\u03c6s, \u03c6s') \u2022 \u03c6s' * \u03c6s`.\n\n  The notation `[a, b]\u209bca` can be used for `superCommuteF a b`. -/\nnoncomputable def superCommuteF : \ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102] \ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102]\n    \ud835\udcd5.FieldOpFreeAlgebra :=\n  Basis.constr ofCrAnListFBasis \u2102 fun \u03c6s =>\n  Basis.constr ofCrAnListFBasis \u2102 fun \u03c6s' =>\n  ofCrAnListF (\u03c6s ++ \u03c6s') - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnListF (\u03c6s' ++ \u03c6s)\n\n@[inherit_doc superCommuteF]\nscoped[FieldSpecification.FieldOpFreeAlgebra] notation \"[\" \u03c6s \",\" \u03c6s' \"]\u209bca\" => superCommuteF \u03c6s \u03c6s'\n\n/-!\n\n## The super commutator of different types of elements\n\n-/\n\nlemma superCommuteF_ofCrAnListF_ofCrAnListF (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnListF \u03c6s, ofCrAnListF \u03c6s']\u209bca =\n    ofCrAnListF (\u03c6s ++ \u03c6s') - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnListF (\u03c6s' ++ \u03c6s) := by\n  rw [\u2190 ofListBasis_eq_ofList, \u2190 ofListBasis_eq_ofList]\n  simp only [superCommuteF, Basis.constr_basis]\n\nlemma superCommuteF_ofCrAnOpF_ofCrAnOpF (\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnOpF \u03c6, ofCrAnOpF \u03c6']\u209bca =\n    ofCrAnOpF \u03c6 * ofCrAnOpF \u03c6' - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 ofCrAnOpF \u03c6' * ofCrAnOpF \u03c6 := by\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton]\n  rw [superCommuteF_ofCrAnListF_ofCrAnListF, ofCrAnListF_append]\n  congr\n  rw [ofCrAnListF_append]\n  rw [FieldStatistic.ofList_singleton, FieldStatistic.ofList_singleton, smul_mul_assoc]\n\nlemma superCommuteF_ofCrAnListF_ofFieldOpFsList (\u03c6cas : List \ud835\udcd5.CrAnFieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [ofCrAnListF \u03c6cas, ofFieldOpListF \u03c6s]\u209bca = ofCrAnListF \u03c6cas * ofFieldOpListF \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6cas, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpListF \u03c6s * ofCrAnListF \u03c6cas := by\n  conv_lhs => rw [ofFieldOpListF_sum]\n  rw [map_sum]\n  conv_lhs =>\n    enter [2, x]\n    rw [superCommuteF_ofCrAnListF_ofCrAnListF, CrAnSection.statistics_eq_state_statistics,\n      ofCrAnListF_append, ofCrAnListF_append]\n  rw [Finset.sum_sub_distrib, \u2190 Finset.mul_sum, \u2190 Finset.smul_sum,\n    \u2190 Finset.sum_mul, \u2190 ofFieldOpListF_sum]\n  simp\n\nlemma superCommuteF_ofFieldOpListF_ofFieldOpFsList (\u03c6 : List \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [ofFieldOpListF \u03c6, ofFieldOpListF \u03c6s]\u209bca = ofFieldOpListF \u03c6 * ofFieldOpListF \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpListF \u03c6s * ofFieldOpListF \u03c6 := by\n  conv_lhs => rw [ofFieldOpListF_sum]\n  simp only [map_sum, LinearMap.coeFn_sum, Finset.sum_apply, instCommGroup.eq_1,\n    Algebra.smul_mul_assoc]\n  conv_lhs =>\n    enter [2, x]\n    rw [superCommuteF_ofCrAnListF_ofFieldOpFsList]\n  simp only [instCommGroup.eq_1, CrAnSection.statistics_eq_state_statistics,\n    Algebra.smul_mul_assoc, Finset.sum_sub_distrib]\n  rw [\u2190 Finset.sum_mul, \u2190 Finset.smul_sum, \u2190 Finset.mul_sum, \u2190 ofFieldOpListF_sum]\n\nlemma superCommuteF_ofFieldOpF_ofFieldOpFsList (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [ofFieldOpF \u03c6, ofFieldOpListF \u03c6s]\u209bca = ofFieldOpF \u03c6 * ofFieldOpListF \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpListF \u03c6s * ofFieldOpF \u03c6 := by\n  rw [\u2190 ofFieldOpListF_singleton, superCommuteF_ofFieldOpListF_ofFieldOpFsList,\n    ofFieldOpListF_singleton]\n  simp\n\nlemma superCommuteF_ofFieldOpListF_ofFieldOpF (\u03c6s : List \ud835\udcd5.FieldOp) (\u03c6 : \ud835\udcd5.FieldOp) :\n    [ofFieldOpListF \u03c6s, ofFieldOpF \u03c6]\u209bca = ofFieldOpListF \u03c6s * ofFieldOpF \u03c6 -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6) \u2022 ofFieldOpF \u03c6 * ofFieldOpListF \u03c6s := by\n  rw [\u2190 ofFieldOpListF_singleton, superCommuteF_ofFieldOpListF_ofFieldOpFsList,\n    ofFieldOpListF_singleton]\n  simp\n\nlemma superCommuteF_anPartF_crPartF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [anPartF \u03c6, crPartF \u03c6']\u209bca = anPartF \u03c6 * crPartF \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 crPartF \u03c6' * anPartF \u03c6 := by\n  match \u03c6, \u03c6' with\n  | FieldOp.inAsymp \u03c6, _ =>\n    simp\n  | _, FieldOp.outAsymp \u03c6 =>\n    simp only [crPartF_posAsymp, map_zero, mul_zero, instCommGroup.eq_1, smul_zero, zero_mul,\n      sub_self]\n  | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n    simp only [anPartF_position, crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.outAsymp \u03c6, FieldOp.position \u03c6' =>\n    simp only [anPartF_posAsymp, crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.position \u03c6, FieldOp.inAsymp \u03c6' =>\n    simp only [anPartF_position, crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp only [List.singleton_append, instCommGroup.eq_1, crAnStatistics,\n      FieldStatistic.ofList_singleton, Function.comp_apply, crAnFieldOpToFieldOp_prod, \u2190\n      ofCrAnListF_append]\n  | FieldOp.outAsymp \u03c6, FieldOp.inAsymp \u03c6' =>\n    simp only [anPartF_posAsymp, crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n\nlemma superCommuteF_crPartF_anPartF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [crPartF \u03c6, anPartF \u03c6']\u209bca = crPartF \u03c6 * anPartF \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 anPartF \u03c6' * crPartF \u03c6 := by\n    match \u03c6, \u03c6' with\n    | FieldOp.outAsymp \u03c6, _ =>\n    simp only [crPartF_posAsymp, map_zero, LinearMap.zero_apply, zero_mul, instCommGroup.eq_1,\n      mul_zero, sub_self]\n    | _, FieldOp.inAsymp \u03c6 =>\n    simp only [anPartF_negAsymp, map_zero, mul_zero, instCommGroup.eq_1, smul_zero, zero_mul,\n      sub_self]\n    | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n    simp only [crPartF_position, anPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n    | FieldOp.position \u03c6, FieldOp.outAsymp \u03c6' =>\n    simp only [crPartF_position, anPartF_posAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n    | FieldOp.inAsymp \u03c6, FieldOp.position \u03c6' =>\n    simp only [crPartF_negAsymp, anPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n    | FieldOp.inAsymp \u03c6, FieldOp.outAsymp \u03c6' =>\n    simp only [crPartF_negAsymp, anPartF_posAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n\nlemma superCommuteF_crPartF_crPartF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [crPartF \u03c6, crPartF \u03c6']\u209bca = crPartF \u03c6 * crPartF \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 crPartF \u03c6' * crPartF \u03c6 := by\n  match \u03c6, \u03c6' with\n  | FieldOp.outAsymp \u03c6, _ =>\n  simp only [crPartF_posAsymp, map_zero, LinearMap.zero_apply, zero_mul, instCommGroup.eq_1,\n    mul_zero, sub_self]\n  | _, FieldOp.outAsymp \u03c6 =>\n  simp only [crPartF_posAsymp, map_zero, mul_zero, instCommGroup.eq_1, smul_zero, zero_mul,\n    sub_self]\n  | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n  simp only [crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.position \u03c6, FieldOp.inAsymp \u03c6' =>\n  simp only [crPartF_position, crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.inAsymp \u03c6, FieldOp.position \u03c6' =>\n  simp only [crPartF_negAsymp, crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.inAsymp \u03c6, FieldOp.inAsymp \u03c6' =>\n  simp only [crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp [crAnStatistics, \u2190 ofCrAnListF_append]\n\nlemma superCommuteF_anPartF_anPartF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [anPartF \u03c6, anPartF \u03c6']\u209bca =\n    anPartF \u03c6 * anPartF \u03c6' - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 anPartF \u03c6' * anPartF \u03c6 := by\n  match \u03c6, \u03c6' with\n  | FieldOp.inAsymp \u03c6, _ =>\n    simp\n  | _, FieldOp.inAsymp \u03c6 =>\n    simp\n  | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n    simp only [anPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.position \u03c6, FieldOp.outAsymp \u03c6' =>\n    simp only [anPartF_position, anPartF_posAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.outAsymp \u03c6, FieldOp.position \u03c6' =>\n    simp only [anPartF_posAsymp, anPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.outAsymp \u03c6, FieldOp.outAsymp \u03c6' =>\n    simp only [anPartF_posAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n\nlemma superCommuteF_crPartF_ofFieldOpListF (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [crPartF \u03c6, ofFieldOpListF \u03c6s]\u209bca =\n    crPartF \u03c6 * ofFieldOpListF \u03c6s - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpListF \u03c6s *\n    crPartF \u03c6 := by\n  match \u03c6 with\n  | FieldOp.inAsymp \u03c6 =>\n    simp only [crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofFieldOpFsList]\n    simp [crAnStatistics]\n  | FieldOp.position \u03c6 =>\n    simp only [crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofFieldOpFsList]\n    simp [crAnStatistics]\n  | FieldOp.outAsymp \u03c6 =>\n    simp\n\nlemma superCommuteF_anPartF_ofFieldOpListF (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [anPartF \u03c6, ofFieldOpListF \u03c6s]\u209bca =\n    anPartF \u03c6 * ofFieldOpListF \u03c6s - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022\n    ofFieldOpListF \u03c6s * anPartF \u03c6 := by\n  match \u03c6 with\n  | FieldOp.inAsymp \u03c6 =>\n    simp\n  | FieldOp.position \u03c6 =>\n    simp only [anPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofFieldOpFsList]\n    simp [crAnStatistics]\n  | FieldOp.outAsymp \u03c6 =>\n    simp only [anPartF_posAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofFieldOpFsList]\n    simp [crAnStatistics]\n\nlemma superCommuteF_crPartF_ofFieldOpF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [crPartF \u03c6, ofFieldOpF \u03c6']\u209bca =\n    crPartF \u03c6 * ofFieldOpF \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 ofFieldOpF \u03c6' * crPartF \u03c6 := by\n  rw [\u2190 ofFieldOpListF_singleton, superCommuteF_crPartF_ofFieldOpListF]\n  simp\n\nlemma superCommuteF_anPartF_ofFieldOpF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [anPartF \u03c6, ofFieldOpF \u03c6']\u209bca =\n    anPartF \u03c6 * ofFieldOpF \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 ofFieldOpF \u03c6' * anPartF \u03c6 := by\n  rw [\u2190 ofFieldOpListF_singleton, superCommuteF_anPartF_ofFieldOpListF]\n  simp\n\n/-!\n\n## Mul equal superCommuteF\n\nLemmas which rewrite a multiplication of two elements of the algebra as their commuted\nmultiplication with a sign plus the super commutator.\n\n-/\nlemma ofCrAnListF_mul_ofCrAnListF_eq_superCommuteF (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnListF \u03c6s * ofCrAnListF \u03c6s' = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnListF \u03c6s' * ofCrAnListF \u03c6s\n    + [ofCrAnListF \u03c6s, ofCrAnListF \u03c6s']\u209bca := by\n  rw [superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp [ofCrAnListF_append]\n\nlemma ofCrAnOpF_mul_ofCrAnListF_eq_superCommuteF (\u03c6 : \ud835\udcd5.CrAnFieldOp) (\u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnOpF \u03c6 * ofCrAnListF \u03c6s' = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnListF \u03c6s' * ofCrAnOpF \u03c6\n    + [ofCrAnOpF \u03c6, ofCrAnListF \u03c6s']\u209bca := by\n  rw [\u2190 ofCrAnListF_singleton, ofCrAnListF_mul_ofCrAnListF_eq_superCommuteF]\n  simp\n\nlemma ofFieldOpListF_mul_ofFieldOpListF_eq_superCommuteF (\u03c6s \u03c6s' : List \ud835\udcd5.FieldOp) :\n    ofFieldOpListF \u03c6s * ofFieldOpListF \u03c6s' =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofFieldOpListF \u03c6s' * ofFieldOpListF \u03c6s\n    + [ofFieldOpListF \u03c6s, ofFieldOpListF \u03c6s']\u209bca := by\n  rw [superCommuteF_ofFieldOpListF_ofFieldOpFsList]\n  simp\n\nlemma ofFieldOpF_mul_ofFieldOpListF_eq_superCommuteF (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s' : List \ud835\udcd5.FieldOp) :\n    ofFieldOpF \u03c6 * ofFieldOpListF \u03c6s' = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofFieldOpListF \u03c6s' * ofFieldOpF \u03c6\n    + [ofFieldOpF \u03c6, ofFieldOpListF \u03c6s']\u209bca := by\n  rw [superCommuteF_ofFieldOpF_ofFieldOpFsList]\n  simp\n\nlemma ofFieldOpListF_mul_ofFieldOpF_eq_superCommuteF (\u03c6s : List \ud835\udcd5.FieldOp) (\u03c6 : \ud835\udcd5.FieldOp) :\n    ofFieldOpListF \u03c6s * ofFieldOpF \u03c6 = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6) \u2022 ofFieldOpF \u03c6 * ofFieldOpListF \u03c6s\n    + [ofFieldOpListF \u03c6s, ofFieldOpF \u03c6]\u209bca := by\n  rw [superCommuteF_ofFieldOpListF_ofFieldOpF]\n  simp\n\n", "theoremStatement": "lemma crPartF_mul_anPartF_eq_superCommuteF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    crPartF \u03c6 * anPartF \u03c6' =\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 anPartF \u03c6' * crPartF \u03c6 +\n    [crPartF \u03c6, anPartF \u03c6']\u209bca ", "theoremName": "FieldSpecification.FieldOpFreeAlgebra.crPartF_mul_anPartF_eq_superCommuteF", "fileCreated": {"commit": "ea6e12829370d9630a7e65200c8349e9086c05ba", "date": "2025-02-03"}, "theoremCreated": {"commit": "f7e669910ceee9df476eef0815080acbaa61ee61", "date": "2025-01-30"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpFreeAlgebra/SuperCommute.lean", "module": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.SuperCommute", "jsonFile": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.SuperCommute.jsonl", "positionMetadata": {"lineInFile": 295, "tokenPositionInFile": 13894, "theoremPositionInFile": 21}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 14, "numPremises": 89}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [superCommuteF_crPartF_anPartF]\n  simp", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 49}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.WickContraction.Uncontracted\n/-!\n\n# Erasing an element from a contraction\n\n-/\n\nopen FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\nnamespace WickContraction\nvariable {n : \u2115} (c : WickContraction n)\nopen HepLean.List\nopen HepLean.Fin\n\n/-- Given a Wick contraction `WickContraction n.succ` and a `i : Fin n.succ` the\n  Wick contraction associated with `n` obtained by removing `i`.\n  If `i` is contracted with `j` in the new Wick contraction `j` will be uncontracted. -/\ndef erase (c : WickContraction n.succ) (i : Fin n.succ) : WickContraction n := by\n  refine \u27e8Finset.filter (fun x => Finset.map i.succAboveEmb x \u2208 c.1) Finset.univ, ?_, ?_\u27e9\n  \u00b7 intro a ha\n    simpa using c.2.1 (Finset.map i.succAboveEmb a) (by simpa using ha)\n  \u00b7 intro a ha b hb\n    simp only [Nat.succ_eq_add_one, Finset.mem_filter, Finset.mem_univ, true_and] at ha hb\n    rw [\u2190 Finset.disjoint_map i.succAboveEmb, \u2190 (Finset.map_injective i.succAboveEmb).eq_iff]\n    exact c.2.2 _ ha _ hb\n\nlemma mem_erase_uncontracted_iff (c : WickContraction n.succ) (i : Fin n.succ) (j : Fin n) :\n    j \u2208 (c.erase i).uncontracted \u2194\n    i.succAbove j \u2208 c.uncontracted \u2228 c.getDual? (i.succAbove j) = some i := by\n  rw [getDual?_eq_some_iff_mem]\n  simp only [uncontracted, getDual?, erase, Nat.succ_eq_add_one, Finset.mem_filter, Finset.mem_univ,\n    Finset.map_insert, Fin.succAboveEmb_apply, Finset.map_singleton, true_and]\n  rw [Fin.find_eq_none_iff, Fin.find_eq_none_iff]\n  apply Iff.intro\n  \u00b7 intro h\n    by_cases hi : {i.succAbove j, i} \u2208 c.1\n    \u00b7 simp [hi]\n    \u00b7 apply Or.inl\n      intro k\n      by_cases hi' : k = i\n      \u00b7 subst hi'\n        exact hi\n      \u00b7 simp only [\u2190 Fin.exists_succAbove_eq_iff] at hi'\n        obtain \u27e8z, hz\u27e9 := hi'\n        subst hz\n        exact h z\n  \u00b7 intro h\n    intro k\n    rcases h with h | h\n    \u00b7 exact h (i.succAbove k)\n    \u00b7 by_contra hn\n      have hc := c.2.2 _ h _ hn\n      simp only [Nat.succ_eq_add_one, Finset.disjoint_insert_right, Finset.mem_insert,\n        Finset.mem_singleton, true_or, not_true_eq_false, Finset.disjoint_singleton_right, not_or,\n        false_and, or_false] at hc\n      have hi : i \u2208 ({i.succAbove j, i.succAbove k} : Finset (Fin n.succ)) := by\n        simp [\u2190 hc]\n      simp only [Nat.succ_eq_add_one, Finset.mem_insert, Finset.mem_singleton] at hi\n      rcases hi with hi | hi\n      \u00b7 exact False.elim (Fin.succAbove_ne _ _ hi.symm)\n      \u00b7 exact False.elim (Fin.succAbove_ne _ _ hi.symm)\n\nlemma mem_not_eq_erase_of_isSome (c : WickContraction n.succ) (i : Fin n.succ)\n    (h : (c.getDual? i).isSome) (ha : a \u2208 c.1) (ha2 : a \u2260 {i, (c.getDual? i).get h}) :\n    \u2203 a', a' \u2208 (c.erase i).1 \u2227 a = Finset.map i.succAboveEmb a' := by\n  have h2a := c.2.1 a ha\n  rw [@Finset.card_eq_two] at h2a\n  obtain \u27e8x, y, hx,hy\u27e9 := h2a\n  subst hy\n  have hxn : \u00ac x = i := by\n    by_contra hx\n    subst hx\n    rw [\u2190 @getDual?_eq_some_iff_mem] at ha\n    rw [(Option.get_of_mem h ha)] at ha2\n    simp at ha2\n  have hyn : \u00ac y = i := by\n    by_contra hy\n    subst hy\n    rw [@Finset.pair_comm] at ha\n    rw [\u2190 @getDual?_eq_some_iff_mem] at ha\n    rw [(Option.get_of_mem h ha)] at ha2\n    simp [Finset.pair_comm] at ha2\n  simp only [Nat.succ_eq_add_one, \u2190 Fin.exists_succAbove_eq_iff] at hxn hyn\n  obtain \u27e8x', hx'\u27e9 := hxn\n  obtain \u27e8y', hy'\u27e9 := hyn\n  use {x', y'}\n  subst hx' hy'\n  simp only [erase, Nat.succ_eq_add_one, Finset.mem_filter, Finset.mem_univ, Finset.map_insert,\n    Fin.succAboveEmb_apply, Finset.map_singleton, true_and, and_true]\n  exact ha\n\nlemma mem_not_eq_erase_of_isNone (c : WickContraction n.succ) (i : Fin n.succ)\n    (h : (c.getDual? i).isNone) (ha : a \u2208 c.1) :\n    \u2203 a', a' \u2208 (c.erase i).1 \u2227 a = Finset.map i.succAboveEmb a' := by\n  have h2a := c.2.1 a ha\n  rw [@Finset.card_eq_two] at h2a\n  obtain \u27e8x, y, hx,hy\u27e9 := h2a\n  subst hy\n  have hi : i \u2208 c.uncontracted := by\n    simp only [Nat.succ_eq_add_one, uncontracted, Finset.mem_filter, Finset.mem_univ, true_and]\n    simp_all only [Nat.succ_eq_add_one, Option.isNone_iff_eq_none, ne_eq]\n  rw [@mem_uncontracted_iff_not_contracted] at hi\n  have hxn : \u00ac x = i := by\n    by_contra hx\n    subst hx\n    exact hi {x, y} ha (by simp)\n  have hyn : \u00ac y = i := by\n    by_contra hy\n    subst hy\n    exact hi {x, y} ha (by simp)\n  simp only [Nat.succ_eq_add_one, \u2190 Fin.exists_succAbove_eq_iff] at hxn hyn\n  obtain \u27e8x', hx'\u27e9 := hxn\n  obtain \u27e8y', hy'\u27e9 := hyn\n  use {x', y'}\n  subst hx' hy'\n  simp only [erase, Nat.succ_eq_add_one, Finset.mem_filter, Finset.mem_univ, Finset.map_insert,\n    Fin.succAboveEmb_apply, Finset.map_singleton, true_and, and_true]\n  exact ha\n\n/-- Given a Wick contraction `c : WickContraction n.succ` and a `i : Fin n.succ` the (optional)\n  element of `(erase c i).uncontracted` which comes from the element in `c` contracted\n  with `i`. -/\ndef getDualErase {n : \u2115} (c : WickContraction n.succ) (i : Fin n.succ) :\n    Option ((erase c i).uncontracted) := by\n  match n with\n  | 0 => exact none\n  | Nat.succ n =>\n  refine if hj : (c.getDual? i).isSome then some \u27e8(predAboveI i ((c.getDual? i).get hj)), ?_\u27e9\n    else none\n  rw [mem_erase_uncontracted_iff]\n  apply Or.inr\n  rw [succsAbove_predAboveI, getDual?_eq_some_iff_mem]\n  \u00b7 simp\n  \u00b7 apply c.getDual?_eq_some_neq _ _ _\n    simp\n\n", "theoremStatement": "@[simp]\nlemma getDualErase_isSome_iff_getDual?_isSome (c : WickContraction n.succ) (i : Fin n.succ) :\n    (c.getDualErase i).isSome \u2194 (c.getDual? i).isSome ", "theoremName": "WickContraction.getDualErase_isSome_iff_getDual?_isSome", "fileCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "theoremCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "file": "HepLean/HepLean/PerturbationTheory/WickContraction/Erase.lean", "module": "HepLean.PerturbationTheory.WickContraction.Erase", "jsonFile": "HepLean.PerturbationTheory.WickContraction.Erase.jsonl", "positionMetadata": {"lineInFile": 143, "tokenPositionInFile": 5365, "theoremPositionInFile": 5}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 7, "numPremises": 68}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  match n with\n  | 0 =>\n    fin_cases i\n    simp [getDualErase]\n\n  | Nat.succ n =>\n    simp [getDualErase]", "proofType": "tactic", "proofLengthLines": 7, "proofLengthTokens": 112}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.WickContraction.Sign.Basic\nimport HepLean.PerturbationTheory.FieldOpAlgebra.TimeContraction\n/-!\n\n# Time contractions\n\n-/\n\nopen FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\nnamespace WickContraction\nvariable {n : \u2115} (c : WickContraction n)\nopen HepLean.List\nopen FieldOpAlgebra\n\n/-- For a list `\u03c6s` of `\ud835\udcd5.FieldOp` and a Wick contraction `\u03c6s\u039b` the\n  element of the center of `\ud835\udcd5.FieldOpAlgebra`, `\u03c6s\u039b.timeContract` is defined as the product\n  of `timeContract \u03c6s[j] \u03c6s[k]` over contracted pairs `{j, k}` in `\u03c6s\u039b`\n  with `j < k`. -/\nnoncomputable def timeContract {\u03c6s : List \ud835\udcd5.FieldOp}\n    (\u03c6s\u039b : WickContraction \u03c6s.length) :\n    Subalgebra.center \u2102 \ud835\udcd5.FieldOpAlgebra :=\n  \u220f (a : \u03c6s\u039b.1), \u27e8FieldOpAlgebra.timeContract\n    (\u03c6s.get (\u03c6s\u039b.fstFieldOfContract a)) (\u03c6s.get (\u03c6s\u039b.sndFieldOfContract a)),\n    timeContract_mem_center _ _\u27e9\n\n", "theoremStatement": "/-- For a list `\u03c6s = \u03c6\u2080\u2026\u03c6\u2099` of `\ud835\udcd5.FieldOp`, a Wick contraction `\u03c6s\u039b` of `\u03c6s`, an element `\u03c6` of\n  `\ud835\udcd5.FieldOp`, and a `i \u2264 \u03c6s.length` the following relation holds\n\n  `(\u03c6s\u039b \u21a9\u039b \u03c6 i none).timeContract = \u03c6s\u039b.timeContract`\n\n  The prove of this result ultimately a consequence of definitions. -/\n@[simp]\nlemma timeContract_insert_none (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp)\n    (\u03c6s\u039b : WickContraction \u03c6s.length) (i : Fin \u03c6s.length.succ) :\n    (\u03c6s\u039b \u21a9\u039b \u03c6 i none).timeContract = \u03c6s\u039b.timeContract ", "theoremName": "WickContraction.timeContract_insert_none", "fileCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "theoremCreated": {"commit": "8434334bbfbf99e266d8f5c6762fc3b623a99e9d", "date": "2025-02-05"}, "file": "HepLean/HepLean/PerturbationTheory/WickContraction/TimeContract.lean", "module": "HepLean.PerturbationTheory.WickContraction.TimeContract", "jsonFile": "HepLean.PerturbationTheory.WickContraction.TimeContract.jsonl", "positionMetadata": {"lineInFile": 33, "tokenPositionInFile": 1028, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 21, "numPremises": 100}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [timeContract, insertAndContract_none_prod_contractions]\n  congr\n  ext a\n  simp", "proofType": "tactic", "proofLengthLines": 4, "proofLengthTokens": 90}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldSpecification.CrAnSection\nimport HepLean.PerturbationTheory.FieldSpecification.NormalOrder\n/-!\n\n# Time ordering of states\n\n-/\n\nnamespace FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\n/-!\n\n## Time ordering for states\n\n-/\n\n/-- The time ordering relation on states. We have that `timeOrderRel \u03c60 \u03c61` is true\n  if and only if `\u03c61` has a time less-then or equal to `\u03c60`, or `\u03c61` is a negative\n  asymptotic state, or `\u03c60` is a positive asymptotic state. -/\ndef timeOrderRel : \ud835\udcd5.FieldOp \u2192 \ud835\udcd5.FieldOp \u2192 Prop\n  | FieldOp.outAsymp _, _ => True\n  | FieldOp.position \u03c60, FieldOp.position \u03c61 => \u03c61.2 0 \u2264 \u03c60.2 0\n  | FieldOp.position _, FieldOp.inAsymp _ => True\n  | FieldOp.position _, FieldOp.outAsymp _ => False\n  | FieldOp.inAsymp _, FieldOp.outAsymp _ => False\n  | FieldOp.inAsymp _, FieldOp.position _ => False\n  | FieldOp.inAsymp _, FieldOp.inAsymp _ => True\n\n/-- The relation `timeOrderRel` is decidable, but not computable so due to\n  `Real.decidableLE`. -/\nnoncomputable instance : (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) \u2192 Decidable (timeOrderRel \u03c6 \u03c6')\n  | FieldOp.outAsymp _, _ => isTrue True.intro\n  | FieldOp.position \u03c60, FieldOp.position \u03c61 => inferInstanceAs (Decidable (\u03c61.2 0 \u2264 \u03c60.2 0))\n  | FieldOp.position _, FieldOp.inAsymp _ => isTrue True.intro\n  | FieldOp.position _, FieldOp.outAsymp _ => isFalse (fun a => a)\n  | FieldOp.inAsymp _, FieldOp.outAsymp _ => isFalse (fun a => a)\n  | FieldOp.inAsymp _, FieldOp.position _ => isFalse (fun a => a)\n  | FieldOp.inAsymp _, FieldOp.inAsymp _ => isTrue True.intro\n\n/-- Time ordering is total. -/\ninstance : IsTotal \ud835\udcd5.FieldOp \ud835\udcd5.timeOrderRel where\n  total a b := by\n    cases a <;> cases b <;>\n      simp only [or_self, or_false, or_true, timeOrderRel, Fin.isValue, implies_true, imp_self,\n        IsEmpty.forall_iff]\n    exact LinearOrder.le_total _ _\n\n/-- Time ordering is transitive. -/\ninstance : IsTrans \ud835\udcd5.FieldOp \ud835\udcd5.timeOrderRel where\n  trans a b c := by\n    cases a <;> cases b <;> cases c <;>\n      simp only [timeOrderRel, Fin.isValue, implies_true, imp_self, IsEmpty.forall_iff]\n    exact fun h1 h2 => Preorder.le_trans _ _ _ h2 h1\n\nnoncomputable section\n\nopen FieldStatistic\nopen HepLean.List\n\n/-- Given a list `\u03c6 :: \u03c6s` of states, the (zero-based) position of the state which is\n  of maximum time. For example\n  - for the list `[\u03c61(t = 4), \u03c62(t = 5), \u03c63(t = 3), \u03c64(t = 5)]` this would return `1`.\n  This is defined for a list `\u03c6 :: \u03c6s` instead of `\u03c6s` to ensure that such a position exists.\n-/\ndef maxTimeFieldPos (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) : \u2115 :=\n  insertionSortMinPos timeOrderRel \u03c6 \u03c6s\n\nlemma maxTimeFieldPos_lt_length (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    maxTimeFieldPos \u03c6 \u03c6s < (\u03c6 :: \u03c6s).length := by\n  simp [maxTimeFieldPos]\n\n/-- Given a list `\u03c6 :: \u03c6s` of states, the left-most state of maximum time, if there are more.\n  As an example:\n  - for the list `[\u03c61(t = 4), \u03c62(t = 5), \u03c63(t = 3), \u03c64(t = 5)]` this would return `\u03c62(t = 5)`.\n  It is the state at the position `maxTimeFieldPos \u03c6 \u03c6s`.\n-/\ndef maxTimeField (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) : \ud835\udcd5.FieldOp :=\n  insertionSortMin timeOrderRel \u03c6 \u03c6s\n\n/-- Given a list `\u03c6 :: \u03c6s` of states, the list with the left-most state of maximum\n  time removed.\n  As an example:\n  - for the list `[\u03c61(t = 4), \u03c62(t = 5), \u03c63(t = 3), \u03c64(t = 5)]` this would return\n    `[\u03c61(t = 4), \u03c63(t = 3), \u03c64(t = 5)]`.\n-/\ndef eraseMaxTimeField (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) : List \ud835\udcd5.FieldOp :=\n  insertionSortDropMinPos timeOrderRel \u03c6 \u03c6s\n\n@[simp]\nlemma eraseMaxTimeField_length (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    (eraseMaxTimeField \u03c6 \u03c6s).length = \u03c6s.length := by\n  simp [eraseMaxTimeField, insertionSortDropMinPos, eraseIdx_length']\n\nlemma maxTimeFieldPos_lt_eraseMaxTimeField_length_succ (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    maxTimeFieldPos \u03c6 \u03c6s < (eraseMaxTimeField \u03c6 \u03c6s).length.succ := by\n  simp only [eraseMaxTimeField_length, Nat.succ_eq_add_one]\n  exact maxTimeFieldPos_lt_length \u03c6 \u03c6s\n\n/-- Given a list `\u03c6 :: \u03c6s` of states, the position of the left-most state of maximum\n  time as an element of `Fin (eraseMaxTimeField \u03c6 \u03c6s).length.succ`.\n  As an example:\n  - for the list `[\u03c61(t = 4), \u03c62(t = 5), \u03c63(t = 3), \u03c64(t = 5)]` this would return `\u27e81,...\u27e9`.\n-/\ndef maxTimeFieldPosFin (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    Fin (eraseMaxTimeField \u03c6 \u03c6s).length.succ :=\n  insertionSortMinPosFin timeOrderRel \u03c6 \u03c6s\n\nlemma lt_maxTimeFieldPosFin_not_timeOrder (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp)\n    (i : Fin (eraseMaxTimeField \u03c6 \u03c6s).length)\n    (hi : (maxTimeFieldPosFin \u03c6 \u03c6s).succAbove i < maxTimeFieldPosFin \u03c6 \u03c6s) :\n    \u00ac timeOrderRel ((eraseMaxTimeField \u03c6 \u03c6s)[i.val]) (maxTimeField \u03c6 \u03c6s) := by\n  exact insertionSortMin_lt_mem_insertionSortDropMinPos_of_lt timeOrderRel \u03c6 \u03c6s i hi\n\nlemma timeOrder_maxTimeField (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp)\n    (i : Fin (eraseMaxTimeField \u03c6 \u03c6s).length) :\n    timeOrderRel (maxTimeField \u03c6 \u03c6s) ((eraseMaxTimeField \u03c6 \u03c6s)[i.val]) := by\n  exact insertionSortMin_lt_mem_insertionSortDropMinPos timeOrderRel \u03c6 \u03c6s _\n\n/-- The sign associated with putting a list of states into time order (with\n  the state of greatest time to the left).\n  We pick up a minus sign for every fermion paired crossed. -/\ndef timeOrderSign (\u03c6s : List \ud835\udcd5.FieldOp) : \u2102 :=\n  Wick.koszulSign \ud835\udcd5.fieldOpStatistic \ud835\udcd5.timeOrderRel \u03c6s\n\n@[simp]\nlemma timeOrderSign_nil : timeOrderSign (\ud835\udcd5 := \ud835\udcd5) [] = 1 := by\n  simp only [timeOrderSign]\n  rfl\n\nlemma timeOrderSign_pair_ordered {\u03c6 \u03c8 : \ud835\udcd5.FieldOp} (h : timeOrderRel \u03c6 \u03c8) :\n    timeOrderSign [\u03c6, \u03c8] = 1 := by\n  simp only [timeOrderSign, Wick.koszulSign, Wick.koszulSignInsert, mul_one, ite_eq_left_iff,\n    ite_eq_right_iff, and_imp]\n  exact fun h' => False.elim (h' h)\n\nlemma timeOrderSign_pair_not_ordered {\u03c6 \u03c8 : \ud835\udcd5.FieldOp} (h : \u00ac timeOrderRel \u03c6 \u03c8) :\n    timeOrderSign [\u03c6, \u03c8] = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c8) := by\n  simp only [timeOrderSign, Wick.koszulSign, Wick.koszulSignInsert, mul_one, instCommGroup.eq_1]\n  rw [if_neg h]\n  simp [FieldStatistic.exchangeSign_eq_if]\n\nlemma timerOrderSign_of_eraseMaxTimeField (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    timeOrderSign (eraseMaxTimeField \u03c6 \u03c6s) = timeOrderSign (\u03c6 :: \u03c6s) *\n    \ud835\udce2(\ud835\udcd5 |>\u209b maxTimeField \u03c6 \u03c6s, \ud835\udcd5 |>\u209b (\u03c6 :: \u03c6s).take (maxTimeFieldPos \u03c6 \u03c6s)) := by\n  rw [eraseMaxTimeField, insertionSortDropMinPos, timeOrderSign,\n    Wick.koszulSign_eraseIdx_insertionSortMinPos]\n  rw [\u2190 timeOrderSign, \u2190 maxTimeField]\n  rfl\n\n/-- The time ordering of a list of states. A schematic example is:\n  - `normalOrderList [\u03c61(t = 4), \u03c62(t = 5), \u03c63(t = 3), \u03c64(t = 5)]` is equal to\n    `[\u03c62(t = 5), \u03c64(t = 5), \u03c61(t = 4), \u03c63(t = 3)]` -/\ndef timeOrderList (\u03c6s : List \ud835\udcd5.FieldOp) : List \ud835\udcd5.FieldOp :=\n  List.insertionSort \ud835\udcd5.timeOrderRel \u03c6s\n\nlemma timeOrderList_pair_ordered {\u03c6 \u03c8 : \ud835\udcd5.FieldOp} (h : timeOrderRel \u03c6 \u03c8) :\n    timeOrderList [\u03c6, \u03c8] = [\u03c6, \u03c8] := by\n  simp only [timeOrderList, List.insertionSort, List.orderedInsert, ite_eq_left_iff,\n    List.cons.injEq, and_true]\n  exact fun h' => False.elim (h' h)\n\nlemma timeOrderList_pair_not_ordered {\u03c6 \u03c8 : \ud835\udcd5.FieldOp} (h : \u00ac timeOrderRel \u03c6 \u03c8) :\n    timeOrderList [\u03c6, \u03c8] = [\u03c8, \u03c6] := by\n  simp only [timeOrderList, List.insertionSort, List.orderedInsert, ite_eq_right_iff,\n    List.cons.injEq, and_true]\n  exact fun h' => False.elim (h h')\n\n@[simp]\nlemma timeOrderList_nil : timeOrderList (\ud835\udcd5 := \ud835\udcd5) [] = [] := by\n  simp [timeOrderList]\n\nlemma timeOrderList_eq_maxTimeField_timeOrderList (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    timeOrderList (\u03c6 :: \u03c6s) = maxTimeField \u03c6 \u03c6s :: timeOrderList (eraseMaxTimeField \u03c6 \u03c6s) := by\n  exact insertionSort_eq_insertionSortMin_cons timeOrderRel \u03c6 \u03c6s\n\n/-!\n\n## Time ordering for CrAnFieldOp\n\n-/\n\n/-!\n\n## timeOrderRel\n\n-/\n\n/-- For a field specification `\ud835\udcd5`, `\ud835\udcd5.crAnTimeOrderRel` is a relation on\n  `\ud835\udcd5.CrAnFieldOp` representing time ordering.\n  It is defined such that `\ud835\udcd5.crAnTimeOrderRel \u03c6\u2080 \u03c6\u2081` is true if and only if one of the following\n  holds\n- `\u03c6\u2080` is an *outgoing* asymptotic operator\n- `\u03c6\u2081` is an *incoming* asymptotic field operator\n- `\u03c6\u2080` and `\u03c6\u2081` are both position field operators where\n  the `SpaceTime` point of `\u03c6\u2080` has a time *greater* then or equal to that of `\u03c6\u2081`.\n\nThus, colloquially `\ud835\udcd5.crAnTimeOrderRel \u03c6\u2080 \u03c6\u2081` if `\u03c6\u2080` has time *greater* then or equal to `\u03c6\u2081`.\nThe use of *greater* then rather then *less* then is because on ordering lists of operators\nit is needed that the operator with the greatest time is to the left.\n-/\ndef crAnTimeOrderRel (a b : \ud835\udcd5.CrAnFieldOp) : Prop := \ud835\udcd5.timeOrderRel a.1 b.1\n\n/-- The relation `crAnTimeOrderRel` is decidable, but not computable so due to\n  `Real.decidableLE`. -/\nnoncomputable instance (\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp) : Decidable (crAnTimeOrderRel \u03c6 \u03c6') :=\n  inferInstanceAs (Decidable (\ud835\udcd5.timeOrderRel \u03c6.1 \u03c6'.1))\n\n/-- Time ordering of `CrAnFieldOp` is total. -/\ninstance : IsTotal \ud835\udcd5.CrAnFieldOp \ud835\udcd5.crAnTimeOrderRel where\n  total a b := IsTotal.total (r := \ud835\udcd5.timeOrderRel) a.1 b.1\n\n/-- Time ordering of `CrAnFieldOp` is transitive. -/\ninstance : IsTrans \ud835\udcd5.CrAnFieldOp \ud835\udcd5.crAnTimeOrderRel where\n  trans a b c := IsTrans.trans (r := \ud835\udcd5.timeOrderRel) a.1 b.1 c.1\n\n@[simp]\nlemma crAnTimeOrderRel_refl (\u03c6 : \ud835\udcd5.CrAnFieldOp) : crAnTimeOrderRel \u03c6 \u03c6 := by\n  exact (IsTotal.to_isRefl (r := \ud835\udcd5.crAnTimeOrderRel)).refl \u03c6\n\n/-- For a field specification `\ud835\udcd5`, and a list `\u03c6s` of `\ud835\udcd5.CrAnFieldOp`,\n  `\ud835\udcd5.crAnTimeOrderSign \u03c6s` is the sign corresponding to the number of `ferimionic`-`fermionic`\n  exchanges undertaken to time-order (i.e. order with respect to `\ud835\udcd5.crAnTimeOrderRel`) `\u03c6s` using\n  the insertion sort algorithm. -/\ndef crAnTimeOrderSign (\u03c6s : List \ud835\udcd5.CrAnFieldOp) : \u2102 :=\n  Wick.koszulSign \ud835\udcd5.crAnStatistics \ud835\udcd5.crAnTimeOrderRel \u03c6s\n\n@[simp]\nlemma crAnTimeOrderSign_nil : crAnTimeOrderSign (\ud835\udcd5 := \ud835\udcd5) [] = 1 := by\n  simp only [crAnTimeOrderSign]\n  rfl\n\nlemma crAnTimeOrderSign_pair_ordered {\u03c6 \u03c8 : \ud835\udcd5.CrAnFieldOp} (h : crAnTimeOrderRel \u03c6 \u03c8) :\n    crAnTimeOrderSign [\u03c6, \u03c8] = 1 := by\n  simp only [crAnTimeOrderSign, Wick.koszulSign, Wick.koszulSignInsert, mul_one, ite_eq_left_iff,\n    ite_eq_right_iff, and_imp]\n  exact fun h' => False.elim (h' h)\n\nlemma crAnTimeOrderSign_pair_not_ordered {\u03c6 \u03c8 : \ud835\udcd5.CrAnFieldOp} (h : \u00ac crAnTimeOrderRel \u03c6 \u03c8) :\n    crAnTimeOrderSign [\u03c6, \u03c8] = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c8) := by\n  simp only [crAnTimeOrderSign, Wick.koszulSign, Wick.koszulSignInsert, mul_one, instCommGroup.eq_1]\n  rw [if_neg h]\n  simp [FieldStatistic.exchangeSign_eq_if]\n\nlemma crAnTimeOrderSign_swap_eq_time {\u03c6 \u03c8 : \ud835\udcd5.CrAnFieldOp}\n    (h1 : crAnTimeOrderRel \u03c6 \u03c8) (h2 : crAnTimeOrderRel \u03c8 \u03c6) (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    crAnTimeOrderSign (\u03c6s ++ \u03c6 :: \u03c8 :: \u03c6s') = crAnTimeOrderSign (\u03c6s ++ \u03c8 :: \u03c6 :: \u03c6s') := by\n  exact Wick.koszulSign_swap_eq_rel _ _ h1 h2 _ _\n\n/-- For a field specification `\ud835\udcd5`, and a list `\u03c6s` of `\ud835\udcd5.CrAnFieldOp`,\n  `\ud835\udcd5.crAnTimeOrderList \u03c6s` is the list `\u03c6s` time-ordered using the insertion sort algorithm. -/\ndef crAnTimeOrderList (\u03c6s : List \ud835\udcd5.CrAnFieldOp) : List \ud835\udcd5.CrAnFieldOp :=\n  List.insertionSort \ud835\udcd5.crAnTimeOrderRel \u03c6s\n\n@[simp]\nlemma crAnTimeOrderList_nil : crAnTimeOrderList (\ud835\udcd5 := \ud835\udcd5) [] = [] := by\n  simp [crAnTimeOrderList]\n\nlemma crAnTimeOrderList_pair_ordered {\u03c6 \u03c8 : \ud835\udcd5.CrAnFieldOp} (h : crAnTimeOrderRel \u03c6 \u03c8) :\n    crAnTimeOrderList [\u03c6, \u03c8] = [\u03c6, \u03c8] := by\n  simp only [crAnTimeOrderList, List.insertionSort, List.orderedInsert, ite_eq_left_iff,\n    List.cons.injEq, and_true]\n  exact fun h' => False.elim (h' h)\n\nlemma crAnTimeOrderList_pair_not_ordered {\u03c6 \u03c8 : \ud835\udcd5.CrAnFieldOp} (h : \u00ac crAnTimeOrderRel \u03c6 \u03c8) :\n    crAnTimeOrderList [\u03c6, \u03c8] = [\u03c8, \u03c6] := by\n  simp only [crAnTimeOrderList, List.insertionSort, List.orderedInsert, ite_eq_right_iff,\n    List.cons.injEq, and_true]\n  exact fun h' => False.elim (h h')\n\nlemma orderedInsert_swap_eq_time {\u03c6 \u03c8 : \ud835\udcd5.CrAnFieldOp}\n    (h1 : crAnTimeOrderRel \u03c6 \u03c8) (h2 : crAnTimeOrderRel \u03c8 \u03c6) (\u03c6s : List \ud835\udcd5.CrAnFieldOp) :\n    List.orderedInsert crAnTimeOrderRel \u03c6 (List.orderedInsert crAnTimeOrderRel \u03c8 \u03c6s) =\n    List.takeWhile (fun b => \u00ac crAnTimeOrderRel \u03c8 b) \u03c6s ++ \u03c6 :: \u03c8 ::\n    List.dropWhile (fun b => \u00ac crAnTimeOrderRel \u03c8 b) \u03c6s := by\n  rw [List.orderedInsert_eq_take_drop crAnTimeOrderRel \u03c8 \u03c6s]\n  simp only [decide_not]\n  rw [List.orderedInsert_eq_take_drop]\n  simp only [decide_not]\n  have h1 (b : \ud835\udcd5.CrAnFieldOp) : (crAnTimeOrderRel \u03c6 b) \u2194 (crAnTimeOrderRel \u03c8 b) :=\n    Iff.intro (fun h => IsTrans.trans _ _ _ h2 h) (fun h => IsTrans.trans _ _ _ h1 h)\n  simp only [h1]\n  rw [List.takeWhile_append]\n  rw [List.takeWhile_takeWhile]\n  simp only [Bool.not_eq_eq_eq_not, Bool.not_true, decide_eq_false_iff_not, and_self, decide_not,\n    \u2193reduceIte, crAnTimeOrderRel_refl, decide_true, Bool.false_eq_true, not_false_eq_true,\n    List.takeWhile_cons_of_neg, List.append_nil, List.append_cancel_left_eq, List.cons.injEq,\n    true_and]\n  rw [List.dropWhile_append]\n  simp only [List.isEmpty_eq_true, List.dropWhile_eq_nil_iff, Bool.not_eq_eq_eq_not, Bool.not_true,\n    decide_eq_false_iff_not, crAnTimeOrderRel_refl, decide_true, Bool.false_eq_true,\n    not_false_eq_true, List.dropWhile_cons_of_neg, ite_eq_left_iff, not_forall, Classical.not_imp,\n    Decidable.not_not, List.append_left_eq_self, forall_exists_index, and_imp]\n  intro x hx hx\u03c8\n  intro y hy\n  simpa using List.mem_takeWhile_imp hy\n\nlemma orderedInsert_in_swap_eq_time {\u03c6 \u03c8 \u03c6': \ud835\udcd5.CrAnFieldOp} (h1 : crAnTimeOrderRel \u03c6 \u03c8)\n    (h2 : crAnTimeOrderRel \u03c8 \u03c6) : (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) \u2192 \u2203 l1 l2,\n    List.orderedInsert crAnTimeOrderRel \u03c6' (\u03c6s ++ \u03c6 :: \u03c8 :: \u03c6s') = l1 ++ \u03c6 :: \u03c8 :: l2 \u2227\n    List.orderedInsert crAnTimeOrderRel \u03c6' (\u03c6s ++ \u03c8 :: \u03c6 :: \u03c6s') = l1 ++ \u03c8 :: \u03c6 :: l2\n  | [], \u03c6s' => by\n    have h1 (b : \ud835\udcd5.CrAnFieldOp) : (crAnTimeOrderRel b \u03c6) \u2194 (crAnTimeOrderRel b \u03c8) :=\n      Iff.intro (fun h => IsTrans.trans _ _ _ h h1) (fun h => IsTrans.trans _ _ _ h h2)\n    by_cases h : crAnTimeOrderRel \u03c6' \u03c6\n    \u00b7 simp only [List.nil_append, List.orderedInsert, h, \u2193reduceIte, \u2190 h1 \u03c6']\n      use [\u03c6'], \u03c6s'\n      simp\n    \u00b7 simp only [List.nil_append, List.orderedInsert, h, \u2193reduceIte, \u2190 h1 \u03c6']\n      use [], List.orderedInsert crAnTimeOrderRel \u03c6' \u03c6s'\n      simp\n  | \u03c6'' :: \u03c6s, \u03c6s' => by\n    obtain \u27e8l1, l2, hl\u27e9 := orderedInsert_in_swap_eq_time (\u03c6' := \u03c6') h1 h2 \u03c6s \u03c6s'\n    simp only [List.cons_append, List.orderedInsert]\n    rw [hl.1, hl.2]\n    by_cases h : crAnTimeOrderRel \u03c6' \u03c6''\n    \u00b7 simp only [h, \u2193reduceIte]\n      use (\u03c6' :: \u03c6'' :: \u03c6s), \u03c6s'\n      simp\n    \u00b7 simp only [h, \u2193reduceIte]\n      use (\u03c6'' :: l1), l2\n      simp\n\nlemma crAnTimeOrderList_swap_eq_time {\u03c6 \u03c8 : \ud835\udcd5.CrAnFieldOp}\n    (h1 : crAnTimeOrderRel \u03c6 \u03c8) (h2 : crAnTimeOrderRel \u03c8 \u03c6) :\n    (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) \u2192\n    \u2203 (l1 l2 : List \ud835\udcd5.CrAnFieldOp),\n      crAnTimeOrderList (\u03c6s ++ \u03c6 :: \u03c8 :: \u03c6s') = l1 ++ \u03c6 :: \u03c8 :: l2 \u2227\n      crAnTimeOrderList (\u03c6s ++ \u03c8 :: \u03c6 :: \u03c6s') = l1 ++ \u03c8 :: \u03c6 :: l2\n  | [], \u03c6s' => by\n    simp only [crAnTimeOrderList]\n    simp only [List.nil_append, List.insertionSort]\n    use List.takeWhile (fun b => \u00ac crAnTimeOrderRel \u03c8 b) (List.insertionSort crAnTimeOrderRel \u03c6s'),\n      List.dropWhile (fun b => \u00ac crAnTimeOrderRel \u03c8 b) (List.insertionSort crAnTimeOrderRel \u03c6s')\n    apply And.intro\n    \u00b7 exact orderedInsert_swap_eq_time h1 h2 _\n    \u00b7 have h1' (b : \ud835\udcd5.CrAnFieldOp) : (crAnTimeOrderRel \u03c6 b) \u2194 (crAnTimeOrderRel \u03c8 b) :=\n        Iff.intro (fun h => IsTrans.trans _ _ _ h2 h) (fun h => IsTrans.trans _ _ _ h1 h)\n      simp only [\u2190 h1', decide_not]\n      simpa using orderedInsert_swap_eq_time h2 h1 _\n  | \u03c6'' :: \u03c6s, \u03c6s' => by\n    rw [crAnTimeOrderList, crAnTimeOrderList]\n    simp only [List.cons_append, List.insertionSort]\n    obtain \u27e8l1, l2, hl\u27e9 := crAnTimeOrderList_swap_eq_time h1 h2 \u03c6s \u03c6s'\n    simp only [crAnTimeOrderList] at hl\n    rw [hl.1, hl.2]\n    obtain \u27e8l1', l2', hl'\u27e9 := orderedInsert_in_swap_eq_time (\u03c6' := \u03c6'') h1 h2 l1 l2\n    rw [hl'.1, hl'.2]\n    use l1', l2'\n\n/-!\n\n## Relationship to sections\n-/\n\nlemma koszulSignInsert_crAnTimeOrderRel_crAnSection {\u03c6 : \ud835\udcd5.FieldOp} {\u03c8 : \ud835\udcd5.CrAnFieldOp}\n    (h : \u03c8.1 = \u03c6) : {\u03c6s : List \ud835\udcd5.FieldOp} \u2192 (\u03c8s : CrAnSection \u03c6s) \u2192\n    Wick.koszulSignInsert \ud835\udcd5.crAnStatistics \ud835\udcd5.crAnTimeOrderRel \u03c8 \u03c8s.1 =\n    Wick.koszulSignInsert \ud835\udcd5.fieldOpStatistic \ud835\udcd5.timeOrderRel \u03c6 \u03c6s\n  | [], \u27e8[], h\u27e9 => by\n    simp [Wick.koszulSignInsert]\n  | \u03c6' :: \u03c6s, \u27e8\u03c8' :: \u03c8s, h1\u27e9 => by\n    simp only [Wick.koszulSignInsert, crAnTimeOrderRel, h]\n    simp only [List.map_cons, List.cons.injEq] at h1\n    have hi := koszulSignInsert_crAnTimeOrderRel_crAnSection h (\u03c6s := \u03c6s) \u27e8\u03c8s, h1.2\u27e9\n    rw [hi]\n    congr\n    \u00b7 exact h1.1\n    \u00b7 simp only [crAnStatistics, crAnFieldOpToFieldOp, Function.comp_apply]\n      congr\n    \u00b7 simp only [crAnStatistics, crAnFieldOpToFieldOp, Function.comp_apply]\n      congr\n      exact h1.1\n\n@[simp]\nlemma crAnTimeOrderSign_crAnSection : {\u03c6s : List \ud835\udcd5.FieldOp} \u2192 (\u03c8s : CrAnSection \u03c6s) \u2192\n    crAnTimeOrderSign \u03c8s.1 = timeOrderSign \u03c6s\n  | [], \u27e8[], h\u27e9 => by\n    simp\n  | \u03c6 :: \u03c6s, \u27e8\u03c8 :: \u03c8s, h\u27e9 => by\n    simp only [crAnTimeOrderSign, Wick.koszulSign, timeOrderSign]\n    simp only [List.map_cons, List.cons.injEq] at h\n    congr 1\n    \u00b7 rw [koszulSignInsert_crAnTimeOrderRel_crAnSection h.1 \u27e8\u03c8s, h.2\u27e9]\n    \u00b7 exact crAnTimeOrderSign_crAnSection \u27e8\u03c8s, h.2\u27e9\n\nlemma orderedInsert_crAnTimeOrderRel_crAnSection {\u03c6 : \ud835\udcd5.FieldOp} {\u03c8 : \ud835\udcd5.CrAnFieldOp}\n    (h : \u03c8.1 = \u03c6) : {\u03c6s : List \ud835\udcd5.FieldOp} \u2192 (\u03c8s : CrAnSection \u03c6s) \u2192\n    (List.orderedInsert \ud835\udcd5.crAnTimeOrderRel \u03c8 \u03c8s.1).map \ud835\udcd5.crAnFieldOpToFieldOp =\n    List.orderedInsert \ud835\udcd5.timeOrderRel \u03c6 \u03c6s\n  | [], \u27e8[], _\u27e9 => by\n    simp only [List.orderedInsert, List.map_cons, List.map_nil, List.cons.injEq, and_true]\n    exact h\n  | \u03c6' :: \u03c6s, \u27e8\u03c8' :: \u03c8s, h1\u27e9 => by\n    simp only [List.orderedInsert, crAnTimeOrderRel, h]\n    simp only [List.map_cons, List.cons.injEq] at h1\n    by_cases hr : timeOrderRel \u03c6 \u03c6'\n    \u00b7 simp only [hr, \u2193reduceIte]\n      rw [\u2190 h1.1] at hr\n      simp only [crAnFieldOpToFieldOp] at hr\n      simp only [hr, \u2193reduceIte, List.map_cons, List.cons.injEq]\n      exact And.intro h (And.intro h1.1 h1.2)\n    \u00b7 simp only [hr, \u2193reduceIte]\n      rw [\u2190 h1.1] at hr\n      simp only [crAnFieldOpToFieldOp] at hr\n      simp only [hr, \u2193reduceIte, List.map_cons, List.cons.injEq]\n      apply And.intro h1.1\n      exact orderedInsert_crAnTimeOrderRel_crAnSection h \u27e8\u03c8s, h1.2\u27e9\n\nlemma crAnTimeOrderList_crAnSection_is_crAnSection : {\u03c6s : List \ud835\udcd5.FieldOp} \u2192 (\u03c8s : CrAnSection \u03c6s) \u2192\n    (crAnTimeOrderList \u03c8s.1).map \ud835\udcd5.crAnFieldOpToFieldOp = timeOrderList \u03c6s\n  | [], \u27e8[], h\u27e9 => by\n    simp\n  | \u03c6 :: \u03c6s, \u27e8\u03c8 :: \u03c8s, h\u27e9 => by\n    simp only [crAnTimeOrderList, List.insertionSort, timeOrderList]\n    simp only [List.map_cons, List.cons.injEq] at h\n    exact orderedInsert_crAnTimeOrderRel_crAnSection h.1 \u27e8(List.insertionSort crAnTimeOrderRel \u03c8s),\n      crAnTimeOrderList_crAnSection_is_crAnSection \u27e8\u03c8s, h.2\u27e9\u27e9\n\n/-- Time ordering of sections of a list of states. -/\ndef crAnSectionTimeOrder (\u03c6s : List \ud835\udcd5.FieldOp) (\u03c8s : CrAnSection \u03c6s) :\n    CrAnSection (timeOrderList \u03c6s) :=\n  \u27e8crAnTimeOrderList \u03c8s.1, crAnTimeOrderList_crAnSection_is_crAnSection \u03c8s\u27e9\n\nlemma orderedInsert_crAnTimeOrderRel_injective {\u03c8 \u03c8' : \ud835\udcd5.CrAnFieldOp} (h : \u03c8.1 = \u03c8'.1) :\n    {\u03c6s : List \ud835\udcd5.FieldOp} \u2192 (\u03c8s \u03c8s' : \ud835\udcd5.CrAnSection \u03c6s) \u2192\n    (ho : List.orderedInsert crAnTimeOrderRel \u03c8 \u03c8s.1 =\n    List.orderedInsert crAnTimeOrderRel \u03c8' \u03c8s'.1) \u2192 \u03c8 = \u03c8' \u2227 \u03c8s = \u03c8s'\n  | [], \u27e8[], _\u27e9, \u27e8[], _\u27e9, h => by\n    simp only [List.orderedInsert, List.cons.injEq, and_true] at h\n    simpa using h\n  | \u03c6 :: \u03c6s, \u27e8\u03c81 :: \u03c8s, h1\u27e9, \u27e8\u03c81' :: \u03c8s', h1'\u27e9, ho => by\n    simp only [List.map_cons, List.cons.injEq] at h1 h1'\n    have ih := orderedInsert_crAnTimeOrderRel_injective h \u27e8\u03c8s, h1.2\u27e9 \u27e8\u03c8s', h1'.2\u27e9\n    simp only [List.orderedInsert] at ho\n    by_cases hr : crAnTimeOrderRel \u03c8 \u03c81\n    \u00b7 simp_all only [ite_true]\n      by_cases hr2 : crAnTimeOrderRel \u03c8' \u03c81'\n      \u00b7 simp_all\n      \u00b7 simp only [crAnTimeOrderRel] at hr hr2\n        simp_all only\n        rw [crAnFieldOpToFieldOp] at h1 h1'\n        rw [h1.1] at hr\n        rw [h1'.1] at hr2\n        exact False.elim (hr2 hr)\n    \u00b7 simp_all only [ite_false]\n      by_cases hr2 : crAnTimeOrderRel \u03c8' \u03c81'\n      \u00b7 simp only [crAnTimeOrderRel] at hr hr2\n        simp_all only\n        rw [crAnFieldOpToFieldOp] at h1 h1'\n        rw [h1.1] at hr\n        rw [h1'.1] at hr2\n        exact False.elim (hr hr2)\n      \u00b7 simp only [hr2, \u2193reduceIte, List.cons.injEq] at ho\n        have ih' := ih ho.2\n        simp_all only [and_self, implies_true, not_false_eq_true, true_and]\n        apply Subtype.ext\n        simp only [List.cons.injEq, true_and]\n        rw [Subtype.eq_iff] at ih'\n        exact ih'.2\n\nlemma crAnSectionTimeOrder_injective : {\u03c6s : List \ud835\udcd5.FieldOp} \u2192\n    Function.Injective (\ud835\udcd5.crAnSectionTimeOrder \u03c6s)\n  | [], \u27e8[], _\u27e9, \u27e8[], _\u27e9 => by\n    simp\n  | \u03c6 :: \u03c6s, \u27e8\u03c8 :: \u03c8s, h\u27e9, \u27e8\u03c8' :: \u03c8s', h'\u27e9 => by\n    intro h1\n    apply Subtype.ext\n    simp only [List.cons.injEq]\n    simp only [crAnSectionTimeOrder] at h1\n    rw [Subtype.eq_iff] at h1\n    simp only [crAnTimeOrderList, List.insertionSort] at h1\n    simp only [List.map_cons, List.cons.injEq] at h h'\n    rw [crAnFieldOpToFieldOp] at h h'\n    have hin := orderedInsert_crAnTimeOrderRel_injective (by rw [h.1, h'.1])\n      (\ud835\udcd5.crAnSectionTimeOrder \u03c6s \u27e8\u03c8s, h.2\u27e9)\n      (\ud835\udcd5.crAnSectionTimeOrder \u03c6s \u27e8\u03c8s', h'.2\u27e9) h1\n    apply And.intro hin.1\n    have hl := crAnSectionTimeOrder_injective hin.2\n    rw [Subtype.ext_iff] at hl\n    simpa using hl\n\nlemma crAnSectionTimeOrder_bijective (\u03c6s : List \ud835\udcd5.FieldOp) :\n    Function.Bijective (\ud835\udcd5.crAnSectionTimeOrder \u03c6s) := by\n  rw [Fintype.bijective_iff_injective_and_card]\n  apply And.intro crAnSectionTimeOrder_injective\n  apply CrAnSection.card_perm_eq\n  simp only [timeOrderList]\n  exact List.Perm.symm (List.perm_insertionSort timeOrderRel \u03c6s)\n\n", "theoremStatement": "lemma sum_crAnSections_timeOrder {\u03c6s : List \ud835\udcd5.FieldOp} [AddCommMonoid M]\n    (f : CrAnSection (timeOrderList \u03c6s) \u2192 M) : \u2211 s, f s = \u2211 s, f (\ud835\udcd5.crAnSectionTimeOrder \u03c6s s) ", "theoremName": "FieldSpecification.sum_crAnSections_timeOrder", "fileCreated": {"commit": "b5c987180a78e45ea7ddb402cd866df26a7c1fa1", "date": "2025-01-21"}, "theoremCreated": {"commit": "21f81a933118812c200fbfb4f921d42b79436a92", "date": "2025-01-27"}, "file": "HepLean/HepLean/PerturbationTheory/FieldSpecification/TimeOrder.lean", "module": "HepLean.PerturbationTheory.FieldSpecification.TimeOrder", "jsonFile": "HepLean.PerturbationTheory.FieldSpecification.TimeOrder.jsonl", "positionMetadata": {"lineInFile": 496, "tokenPositionInFile": 21546, "theoremPositionInFile": 33}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 7, "numPremises": 21}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  erw [(Equiv.ofBijective _ (\ud835\udcd5.crAnSectionTimeOrder_bijective \u03c6s)).sum_comp]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 82}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.Basic\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.Grading\n/-!\n\n# Super Commute\n-/\n\nnamespace FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\nnamespace FieldOpFreeAlgebra\n\n/-!\n\n## The super commutator on the FieldOpFreeAlgebra.\n\n-/\n\nopen FieldStatistic\n\n/-- For a field specification `\ud835\udcd5`, the super commutator `superCommuteF` is defined as the linear\n  map `\ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102] \ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102] \ud835\udcd5.FieldOpFreeAlgebra`\n  which on the lists `\u03c6s` and `\u03c6s'` of `\ud835\udcd5.CrAnFieldOp` gives\n\n  `superCommuteF \u03c6s \u03c6s' = \u03c6s * \u03c6s' - \ud835\udce2(\u03c6s, \u03c6s') \u2022 \u03c6s' * \u03c6s`.\n\n  The notation `[a, b]\u209bca` can be used for `superCommuteF a b`. -/\nnoncomputable def superCommuteF : \ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102] \ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102]\n    \ud835\udcd5.FieldOpFreeAlgebra :=\n  Basis.constr ofCrAnListFBasis \u2102 fun \u03c6s =>\n  Basis.constr ofCrAnListFBasis \u2102 fun \u03c6s' =>\n  ofCrAnListF (\u03c6s ++ \u03c6s') - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnListF (\u03c6s' ++ \u03c6s)\n\n@[inherit_doc superCommuteF]\nscoped[FieldSpecification.FieldOpFreeAlgebra] notation \"[\" \u03c6s \",\" \u03c6s' \"]\u209bca\" => superCommuteF \u03c6s \u03c6s'\n\n/-!\n\n## The super commutator of different types of elements\n\n-/\n\nlemma superCommuteF_ofCrAnListF_ofCrAnListF (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnListF \u03c6s, ofCrAnListF \u03c6s']\u209bca =\n    ofCrAnListF (\u03c6s ++ \u03c6s') - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnListF (\u03c6s' ++ \u03c6s) := by\n  rw [\u2190 ofListBasis_eq_ofList, \u2190 ofListBasis_eq_ofList]\n  simp only [superCommuteF, Basis.constr_basis]\n\nlemma superCommuteF_ofCrAnOpF_ofCrAnOpF (\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnOpF \u03c6, ofCrAnOpF \u03c6']\u209bca =\n    ofCrAnOpF \u03c6 * ofCrAnOpF \u03c6' - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 ofCrAnOpF \u03c6' * ofCrAnOpF \u03c6 := by\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton]\n  rw [superCommuteF_ofCrAnListF_ofCrAnListF, ofCrAnListF_append]\n  congr\n  rw [ofCrAnListF_append]\n  rw [FieldStatistic.ofList_singleton, FieldStatistic.ofList_singleton, smul_mul_assoc]\n\nlemma superCommuteF_ofCrAnListF_ofFieldOpFsList (\u03c6cas : List \ud835\udcd5.CrAnFieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [ofCrAnListF \u03c6cas, ofFieldOpListF \u03c6s]\u209bca = ofCrAnListF \u03c6cas * ofFieldOpListF \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6cas, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpListF \u03c6s * ofCrAnListF \u03c6cas := by\n  conv_lhs => rw [ofFieldOpListF_sum]\n  rw [map_sum]\n  conv_lhs =>\n    enter [2, x]\n    rw [superCommuteF_ofCrAnListF_ofCrAnListF, CrAnSection.statistics_eq_state_statistics,\n      ofCrAnListF_append, ofCrAnListF_append]\n  rw [Finset.sum_sub_distrib, \u2190 Finset.mul_sum, \u2190 Finset.smul_sum,\n    \u2190 Finset.sum_mul, \u2190 ofFieldOpListF_sum]\n  simp\n\nlemma superCommuteF_ofFieldOpListF_ofFieldOpFsList (\u03c6 : List \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [ofFieldOpListF \u03c6, ofFieldOpListF \u03c6s]\u209bca = ofFieldOpListF \u03c6 * ofFieldOpListF \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpListF \u03c6s * ofFieldOpListF \u03c6 := by\n  conv_lhs => rw [ofFieldOpListF_sum]\n  simp only [map_sum, LinearMap.coeFn_sum, Finset.sum_apply, instCommGroup.eq_1,\n    Algebra.smul_mul_assoc]\n  conv_lhs =>\n    enter [2, x]\n    rw [superCommuteF_ofCrAnListF_ofFieldOpFsList]\n  simp only [instCommGroup.eq_1, CrAnSection.statistics_eq_state_statistics,\n    Algebra.smul_mul_assoc, Finset.sum_sub_distrib]\n  rw [\u2190 Finset.sum_mul, \u2190 Finset.smul_sum, \u2190 Finset.mul_sum, \u2190 ofFieldOpListF_sum]\n\nlemma superCommuteF_ofFieldOpF_ofFieldOpFsList (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [ofFieldOpF \u03c6, ofFieldOpListF \u03c6s]\u209bca = ofFieldOpF \u03c6 * ofFieldOpListF \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpListF \u03c6s * ofFieldOpF \u03c6 := by\n  rw [\u2190 ofFieldOpListF_singleton, superCommuteF_ofFieldOpListF_ofFieldOpFsList,\n    ofFieldOpListF_singleton]\n  simp\n\nlemma superCommuteF_ofFieldOpListF_ofFieldOpF (\u03c6s : List \ud835\udcd5.FieldOp) (\u03c6 : \ud835\udcd5.FieldOp) :\n    [ofFieldOpListF \u03c6s, ofFieldOpF \u03c6]\u209bca = ofFieldOpListF \u03c6s * ofFieldOpF \u03c6 -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6) \u2022 ofFieldOpF \u03c6 * ofFieldOpListF \u03c6s := by\n  rw [\u2190 ofFieldOpListF_singleton, superCommuteF_ofFieldOpListF_ofFieldOpFsList,\n    ofFieldOpListF_singleton]\n  simp\n\nlemma superCommuteF_anPartF_crPartF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [anPartF \u03c6, crPartF \u03c6']\u209bca = anPartF \u03c6 * crPartF \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 crPartF \u03c6' * anPartF \u03c6 := by\n  match \u03c6, \u03c6' with\n  | FieldOp.inAsymp \u03c6, _ =>\n    simp\n  | _, FieldOp.outAsymp \u03c6 =>\n    simp only [crPartF_posAsymp, map_zero, mul_zero, instCommGroup.eq_1, smul_zero, zero_mul,\n      sub_self]\n  | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n    simp only [anPartF_position, crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.outAsymp \u03c6, FieldOp.position \u03c6' =>\n    simp only [anPartF_posAsymp, crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.position \u03c6, FieldOp.inAsymp \u03c6' =>\n    simp only [anPartF_position, crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp only [List.singleton_append, instCommGroup.eq_1, crAnStatistics,\n      FieldStatistic.ofList_singleton, Function.comp_apply, crAnFieldOpToFieldOp_prod, \u2190\n      ofCrAnListF_append]\n  | FieldOp.outAsymp \u03c6, FieldOp.inAsymp \u03c6' =>\n    simp only [anPartF_posAsymp, crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n\nlemma superCommuteF_crPartF_anPartF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [crPartF \u03c6, anPartF \u03c6']\u209bca = crPartF \u03c6 * anPartF \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 anPartF \u03c6' * crPartF \u03c6 := by\n    match \u03c6, \u03c6' with\n    | FieldOp.outAsymp \u03c6, _ =>\n    simp only [crPartF_posAsymp, map_zero, LinearMap.zero_apply, zero_mul, instCommGroup.eq_1,\n      mul_zero, sub_self]\n    | _, FieldOp.inAsymp \u03c6 =>\n    simp only [anPartF_negAsymp, map_zero, mul_zero, instCommGroup.eq_1, smul_zero, zero_mul,\n      sub_self]\n    | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n    simp only [crPartF_position, anPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n    | FieldOp.position \u03c6, FieldOp.outAsymp \u03c6' =>\n    simp only [crPartF_position, anPartF_posAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n    | FieldOp.inAsymp \u03c6, FieldOp.position \u03c6' =>\n    simp only [crPartF_negAsymp, anPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n    | FieldOp.inAsymp \u03c6, FieldOp.outAsymp \u03c6' =>\n    simp only [crPartF_negAsymp, anPartF_posAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n\nlemma superCommuteF_crPartF_crPartF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [crPartF \u03c6, crPartF \u03c6']\u209bca = crPartF \u03c6 * crPartF \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 crPartF \u03c6' * crPartF \u03c6 := by\n  match \u03c6, \u03c6' with\n  | FieldOp.outAsymp \u03c6, _ =>\n  simp only [crPartF_posAsymp, map_zero, LinearMap.zero_apply, zero_mul, instCommGroup.eq_1,\n    mul_zero, sub_self]\n  | _, FieldOp.outAsymp \u03c6 =>\n  simp only [crPartF_posAsymp, map_zero, mul_zero, instCommGroup.eq_1, smul_zero, zero_mul,\n    sub_self]\n  | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n  simp only [crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.position \u03c6, FieldOp.inAsymp \u03c6' =>\n  simp only [crPartF_position, crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.inAsymp \u03c6, FieldOp.position \u03c6' =>\n  simp only [crPartF_negAsymp, crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.inAsymp \u03c6, FieldOp.inAsymp \u03c6' =>\n  simp only [crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp [crAnStatistics, \u2190 ofCrAnListF_append]\n\nlemma superCommuteF_anPartF_anPartF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [anPartF \u03c6, anPartF \u03c6']\u209bca =\n    anPartF \u03c6 * anPartF \u03c6' - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 anPartF \u03c6' * anPartF \u03c6 := by\n  match \u03c6, \u03c6' with\n  | FieldOp.inAsymp \u03c6, _ =>\n    simp\n  | _, FieldOp.inAsymp \u03c6 =>\n    simp\n  | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n    simp only [anPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.position \u03c6, FieldOp.outAsymp \u03c6' =>\n    simp only [anPartF_position, anPartF_posAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.outAsymp \u03c6, FieldOp.position \u03c6' =>\n    simp only [anPartF_posAsymp, anPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.outAsymp \u03c6, FieldOp.outAsymp \u03c6' =>\n    simp only [anPartF_posAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n\nlemma superCommuteF_crPartF_ofFieldOpListF (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [crPartF \u03c6, ofFieldOpListF \u03c6s]\u209bca =\n    crPartF \u03c6 * ofFieldOpListF \u03c6s - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpListF \u03c6s *\n    crPartF \u03c6 := by\n  match \u03c6 with\n  | FieldOp.inAsymp \u03c6 =>\n    simp only [crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofFieldOpFsList]\n    simp [crAnStatistics]\n  | FieldOp.position \u03c6 =>\n    simp only [crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofFieldOpFsList]\n    simp [crAnStatistics]\n  | FieldOp.outAsymp \u03c6 =>\n    simp\n\nlemma superCommuteF_anPartF_ofFieldOpListF (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [anPartF \u03c6, ofFieldOpListF \u03c6s]\u209bca =\n    anPartF \u03c6 * ofFieldOpListF \u03c6s - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022\n    ofFieldOpListF \u03c6s * anPartF \u03c6 := by\n  match \u03c6 with\n  | FieldOp.inAsymp \u03c6 =>\n    simp\n  | FieldOp.position \u03c6 =>\n    simp only [anPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofFieldOpFsList]\n    simp [crAnStatistics]\n  | FieldOp.outAsymp \u03c6 =>\n    simp only [anPartF_posAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofFieldOpFsList]\n    simp [crAnStatistics]\n\nlemma superCommuteF_crPartF_ofFieldOpF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [crPartF \u03c6, ofFieldOpF \u03c6']\u209bca =\n    crPartF \u03c6 * ofFieldOpF \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 ofFieldOpF \u03c6' * crPartF \u03c6 := by\n  rw [\u2190 ofFieldOpListF_singleton, superCommuteF_crPartF_ofFieldOpListF]\n  simp\n\nlemma superCommuteF_anPartF_ofFieldOpF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [anPartF \u03c6, ofFieldOpF \u03c6']\u209bca =\n    anPartF \u03c6 * ofFieldOpF \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 ofFieldOpF \u03c6' * anPartF \u03c6 := by\n  rw [\u2190 ofFieldOpListF_singleton, superCommuteF_anPartF_ofFieldOpListF]\n  simp\n\n/-!\n\n## Mul equal superCommuteF\n\nLemmas which rewrite a multiplication of two elements of the algebra as their commuted\nmultiplication with a sign plus the super commutator.\n\n-/\nlemma ofCrAnListF_mul_ofCrAnListF_eq_superCommuteF (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnListF \u03c6s * ofCrAnListF \u03c6s' = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnListF \u03c6s' * ofCrAnListF \u03c6s\n    + [ofCrAnListF \u03c6s, ofCrAnListF \u03c6s']\u209bca := by\n  rw [superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp [ofCrAnListF_append]\n\n", "theoremStatement": "lemma ofCrAnOpF_mul_ofCrAnListF_eq_superCommuteF (\u03c6 : \ud835\udcd5.CrAnFieldOp) (\u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    ofCrAnOpF \u03c6 * ofCrAnListF \u03c6s' = \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnListF \u03c6s' * ofCrAnOpF \u03c6\n    + [ofCrAnOpF \u03c6, ofCrAnListF \u03c6s']\u209bca ", "theoremName": "FieldSpecification.FieldOpFreeAlgebra.ofCrAnOpF_mul_ofCrAnListF_eq_superCommuteF", "fileCreated": {"commit": "ea6e12829370d9630a7e65200c8349e9086c05ba", "date": "2025-02-03"}, "theoremCreated": {"commit": "171e80fc04016aed422340742f3e0a14de6d20b0", "date": "2025-02-03"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpFreeAlgebra/SuperCommute.lean", "module": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.SuperCommute", "jsonFile": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.SuperCommute.jsonl", "positionMetadata": {"lineInFile": 270, "tokenPositionInFile": 12672, "theoremPositionInFile": 17}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 16, "numPremises": 87}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [\u2190 ofCrAnListF_singleton, ofCrAnListF_mul_ofCrAnListF_eq_superCommuteF]\n  simp", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 89}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.WickContraction.SubContraction\n/-!\n\n# Singleton of contractions\n\n-/\n\nopen FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\nnamespace WickContraction\nvariable {n : \u2115} (c : WickContraction n)\nopen HepLean.List\nopen FieldOpAlgebra\nopen FieldStatistic\n\n/-- The Wick contraction formed from a single ordered pair. -/\ndef singleton {i j : Fin n} (hij : i < j) : WickContraction n :=\n  \u27e8{{i, j}}, by\n    intro i hi\n    simp only [Finset.mem_singleton] at hi\n    subst hi\n    rw [@Finset.card_eq_two]\n    use i, j\n    simp only [ne_eq, and_true]\n    omega, by\n    intro i hi j hj\n    simp_all\u27e9\n\nlemma mem_singleton {i j : Fin n} (hij : i < j) :\n    {i, j} \u2208 (singleton hij).1 := by\n  simp [singleton]\n\nlemma mem_singleton_iff {i j : Fin n} (hij : i < j) {a : Finset (Fin n)} :\n    a \u2208 (singleton hij).1 \u2194 a = {i, j} := by\n  simp [singleton]\n\nlemma of_singleton_eq {i j : Fin n} (hij : i < j) (a : (singleton hij).1) :\n    a = \u27e8{i, j}, mem_singleton hij\u27e9 := by\n  have ha2 := a.2\n  rw [@mem_singleton_iff] at ha2\n  exact Subtype.coe_eq_of_eq_mk ha2\n\nlemma singleton_prod {\u03c6s : List \ud835\udcd5.FieldOp} {i j : Fin \u03c6s.length} (hij : i < j)\n    (f : (singleton hij).1 \u2192 M) [CommMonoid M] :\n    \u220f a, f a = f \u27e8{i,j}, mem_singleton hij\u27e9:= by\n  simp [singleton, of_singleton_eq]\n\n", "theoremStatement": "@[simp]\nlemma singleton_fstFieldOfContract {i j : Fin n} (hij : i < j) :\n    (singleton hij).fstFieldOfContract \u27e8{i, j}, mem_singleton hij\u27e9 = i ", "theoremName": "WickContraction.singleton_fstFieldOfContract", "fileCreated": {"commit": "12d36dc1d9c726c035301091e57be0b29015e4ae", "date": "2025-01-31"}, "theoremCreated": {"commit": "12d36dc1d9c726c035301091e57be0b29015e4ae", "date": "2025-01-31"}, "file": "HepLean/HepLean/PerturbationTheory/WickContraction/Singleton.lean", "module": "HepLean.PerturbationTheory.WickContraction.Singleton", "jsonFile": "HepLean.PerturbationTheory.WickContraction.Singleton.jsonl", "positionMetadata": {"lineInFile": 54, "tokenPositionInFile": 1455, "theoremPositionInFile": 5}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 4, "numPremises": 39}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  refine eq_fstFieldOfContract_of_mem (singleton hij) \u27e8{i, j}, mem_singleton hij\u27e9 i j ?_ ?_ ?_\n  \u00b7 simp\n  \u00b7 simp\n  \u00b7 exact hij", "proofType": "tactic", "proofLengthLines": 4, "proofLengthTokens": 132}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.Basic\nimport HepLean.PerturbationTheory.FieldOpFreeAlgebra.Grading\n/-!\n\n# Super Commute\n-/\n\nnamespace FieldSpecification\nvariable {\ud835\udcd5 : FieldSpecification}\n\nnamespace FieldOpFreeAlgebra\n\n/-!\n\n## The super commutator on the FieldOpFreeAlgebra.\n\n-/\n\nopen FieldStatistic\n\n/-- For a field specification `\ud835\udcd5`, the super commutator `superCommuteF` is defined as the linear\n  map `\ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102] \ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102] \ud835\udcd5.FieldOpFreeAlgebra`\n  which on the lists `\u03c6s` and `\u03c6s'` of `\ud835\udcd5.CrAnFieldOp` gives\n\n  `superCommuteF \u03c6s \u03c6s' = \u03c6s * \u03c6s' - \ud835\udce2(\u03c6s, \u03c6s') \u2022 \u03c6s' * \u03c6s`.\n\n  The notation `[a, b]\u209bca` can be used for `superCommuteF a b`. -/\nnoncomputable def superCommuteF : \ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102] \ud835\udcd5.FieldOpFreeAlgebra \u2192\u2097[\u2102]\n    \ud835\udcd5.FieldOpFreeAlgebra :=\n  Basis.constr ofCrAnListFBasis \u2102 fun \u03c6s =>\n  Basis.constr ofCrAnListFBasis \u2102 fun \u03c6s' =>\n  ofCrAnListF (\u03c6s ++ \u03c6s') - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnListF (\u03c6s' ++ \u03c6s)\n\n@[inherit_doc superCommuteF]\nscoped[FieldSpecification.FieldOpFreeAlgebra] notation \"[\" \u03c6s \",\" \u03c6s' \"]\u209bca\" => superCommuteF \u03c6s \u03c6s'\n\n/-!\n\n## The super commutator of different types of elements\n\n-/\n\nlemma superCommuteF_ofCrAnListF_ofCrAnListF (\u03c6s \u03c6s' : List \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnListF \u03c6s, ofCrAnListF \u03c6s']\u209bca =\n    ofCrAnListF (\u03c6s ++ \u03c6s') - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6s') \u2022 ofCrAnListF (\u03c6s' ++ \u03c6s) := by\n  rw [\u2190 ofListBasis_eq_ofList, \u2190 ofListBasis_eq_ofList]\n  simp only [superCommuteF, Basis.constr_basis]\n\nlemma superCommuteF_ofCrAnOpF_ofCrAnOpF (\u03c6 \u03c6' : \ud835\udcd5.CrAnFieldOp) :\n    [ofCrAnOpF \u03c6, ofCrAnOpF \u03c6']\u209bca =\n    ofCrAnOpF \u03c6 * ofCrAnOpF \u03c6' - \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 ofCrAnOpF \u03c6' * ofCrAnOpF \u03c6 := by\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton]\n  rw [superCommuteF_ofCrAnListF_ofCrAnListF, ofCrAnListF_append]\n  congr\n  rw [ofCrAnListF_append]\n  rw [FieldStatistic.ofList_singleton, FieldStatistic.ofList_singleton, smul_mul_assoc]\n\nlemma superCommuteF_ofCrAnListF_ofFieldOpFsList (\u03c6cas : List \ud835\udcd5.CrAnFieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [ofCrAnListF \u03c6cas, ofFieldOpListF \u03c6s]\u209bca = ofCrAnListF \u03c6cas * ofFieldOpListF \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6cas, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpListF \u03c6s * ofCrAnListF \u03c6cas := by\n  conv_lhs => rw [ofFieldOpListF_sum]\n  rw [map_sum]\n  conv_lhs =>\n    enter [2, x]\n    rw [superCommuteF_ofCrAnListF_ofCrAnListF, CrAnSection.statistics_eq_state_statistics,\n      ofCrAnListF_append, ofCrAnListF_append]\n  rw [Finset.sum_sub_distrib, \u2190 Finset.mul_sum, \u2190 Finset.smul_sum,\n    \u2190 Finset.sum_mul, \u2190 ofFieldOpListF_sum]\n  simp\n\nlemma superCommuteF_ofFieldOpListF_ofFieldOpFsList (\u03c6 : List \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [ofFieldOpListF \u03c6, ofFieldOpListF \u03c6s]\u209bca = ofFieldOpListF \u03c6 * ofFieldOpListF \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpListF \u03c6s * ofFieldOpListF \u03c6 := by\n  conv_lhs => rw [ofFieldOpListF_sum]\n  simp only [map_sum, LinearMap.coeFn_sum, Finset.sum_apply, instCommGroup.eq_1,\n    Algebra.smul_mul_assoc]\n  conv_lhs =>\n    enter [2, x]\n    rw [superCommuteF_ofCrAnListF_ofFieldOpFsList]\n  simp only [instCommGroup.eq_1, CrAnSection.statistics_eq_state_statistics,\n    Algebra.smul_mul_assoc, Finset.sum_sub_distrib]\n  rw [\u2190 Finset.sum_mul, \u2190 Finset.smul_sum, \u2190 Finset.mul_sum, \u2190 ofFieldOpListF_sum]\n\nlemma superCommuteF_ofFieldOpF_ofFieldOpFsList (\u03c6 : \ud835\udcd5.FieldOp) (\u03c6s : List \ud835\udcd5.FieldOp) :\n    [ofFieldOpF \u03c6, ofFieldOpListF \u03c6s]\u209bca = ofFieldOpF \u03c6 * ofFieldOpListF \u03c6s -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6s) \u2022 ofFieldOpListF \u03c6s * ofFieldOpF \u03c6 := by\n  rw [\u2190 ofFieldOpListF_singleton, superCommuteF_ofFieldOpListF_ofFieldOpFsList,\n    ofFieldOpListF_singleton]\n  simp\n\nlemma superCommuteF_ofFieldOpListF_ofFieldOpF (\u03c6s : List \ud835\udcd5.FieldOp) (\u03c6 : \ud835\udcd5.FieldOp) :\n    [ofFieldOpListF \u03c6s, ofFieldOpF \u03c6]\u209bca = ofFieldOpListF \u03c6s * ofFieldOpF \u03c6 -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6s, \ud835\udcd5 |>\u209b \u03c6) \u2022 ofFieldOpF \u03c6 * ofFieldOpListF \u03c6s := by\n  rw [\u2190 ofFieldOpListF_singleton, superCommuteF_ofFieldOpListF_ofFieldOpFsList,\n    ofFieldOpListF_singleton]\n  simp\n\nlemma superCommuteF_anPartF_crPartF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [anPartF \u03c6, crPartF \u03c6']\u209bca = anPartF \u03c6 * crPartF \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 crPartF \u03c6' * anPartF \u03c6 := by\n  match \u03c6, \u03c6' with\n  | FieldOp.inAsymp \u03c6, _ =>\n    simp\n  | _, FieldOp.outAsymp \u03c6 =>\n    simp only [crPartF_posAsymp, map_zero, mul_zero, instCommGroup.eq_1, smul_zero, zero_mul,\n      sub_self]\n  | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n    simp only [anPartF_position, crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.outAsymp \u03c6, FieldOp.position \u03c6' =>\n    simp only [anPartF_posAsymp, crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.position \u03c6, FieldOp.inAsymp \u03c6' =>\n    simp only [anPartF_position, crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp only [List.singleton_append, instCommGroup.eq_1, crAnStatistics,\n      FieldStatistic.ofList_singleton, Function.comp_apply, crAnFieldOpToFieldOp_prod, \u2190\n      ofCrAnListF_append]\n  | FieldOp.outAsymp \u03c6, FieldOp.inAsymp \u03c6' =>\n    simp only [anPartF_posAsymp, crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n\nlemma superCommuteF_crPartF_anPartF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [crPartF \u03c6, anPartF \u03c6']\u209bca = crPartF \u03c6 * anPartF \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 anPartF \u03c6' * crPartF \u03c6 := by\n    match \u03c6, \u03c6' with\n    | FieldOp.outAsymp \u03c6, _ =>\n    simp only [crPartF_posAsymp, map_zero, LinearMap.zero_apply, zero_mul, instCommGroup.eq_1,\n      mul_zero, sub_self]\n    | _, FieldOp.inAsymp \u03c6 =>\n    simp only [anPartF_negAsymp, map_zero, mul_zero, instCommGroup.eq_1, smul_zero, zero_mul,\n      sub_self]\n    | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n    simp only [crPartF_position, anPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n    | FieldOp.position \u03c6, FieldOp.outAsymp \u03c6' =>\n    simp only [crPartF_position, anPartF_posAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n    | FieldOp.inAsymp \u03c6, FieldOp.position \u03c6' =>\n    simp only [crPartF_negAsymp, anPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n    | FieldOp.inAsymp \u03c6, FieldOp.outAsymp \u03c6' =>\n    simp only [crPartF_negAsymp, anPartF_posAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n    rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n    simp [crAnStatistics, \u2190 ofCrAnListF_append]\n\n", "theoremStatement": "lemma superCommuteF_crPartF_crPartF (\u03c6 \u03c6' : \ud835\udcd5.FieldOp) :\n    [crPartF \u03c6, crPartF \u03c6']\u209bca = crPartF \u03c6 * crPartF \u03c6' -\n    \ud835\udce2(\ud835\udcd5 |>\u209b \u03c6, \ud835\udcd5 |>\u209b \u03c6') \u2022 crPartF \u03c6' * crPartF \u03c6 ", "theoremName": "FieldSpecification.FieldOpFreeAlgebra.superCommuteF_crPartF_crPartF", "fileCreated": {"commit": "ea6e12829370d9630a7e65200c8349e9086c05ba", "date": "2025-02-03"}, "theoremCreated": {"commit": "f7e669910ceee9df476eef0815080acbaa61ee61", "date": "2025-01-30"}, "file": "HepLean/HepLean/PerturbationTheory/FieldOpFreeAlgebra/SuperCommute.lean", "module": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.SuperCommute", "jsonFile": "HepLean.PerturbationTheory.FieldOpFreeAlgebra.SuperCommute.jsonl", "positionMetadata": {"lineInFile": 158, "tokenPositionInFile": 7360, "theoremPositionInFile": 10}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 33, "numPremises": 156}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  match \u03c6, \u03c6' with\n  | FieldOp.outAsymp \u03c6, _ =>\n  simp only [crPartF_posAsymp, map_zero, LinearMap.zero_apply, zero_mul, instCommGroup.eq_1,\n    mul_zero, sub_self]\n  | _, FieldOp.outAsymp \u03c6 =>\n  simp only [crPartF_posAsymp, map_zero, mul_zero, instCommGroup.eq_1, smul_zero, zero_mul,\n    sub_self]\n  | FieldOp.position \u03c6, FieldOp.position \u03c6' =>\n  simp only [crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.position \u03c6, FieldOp.inAsymp \u03c6' =>\n  simp only [crPartF_position, crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.inAsymp \u03c6, FieldOp.position \u03c6' =>\n  simp only [crPartF_negAsymp, crPartF_position, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp [crAnStatistics, \u2190 ofCrAnListF_append]\n  | FieldOp.inAsymp \u03c6, FieldOp.inAsymp \u03c6' =>\n  simp only [crPartF_negAsymp, instCommGroup.eq_1, Algebra.smul_mul_assoc]\n  rw [\u2190 ofCrAnListF_singleton, \u2190 ofCrAnListF_singleton, superCommuteF_ofCrAnListF_ofCrAnListF]\n  simp [crAnStatistics, \u2190 ofCrAnListF_append]", "proofType": "tactic", "proofLengthLines": 23, "proofLengthTokens": 1389}}
{"srcContext": "/-\nCopyright (c) 2025 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport Mathlib.Algebra.BigOperators.Group.Finset.Basic\n/-!\n\n# Creation and annihilation parts of fields\n\n-/\n\n/-- The type `CreateAnnihilate` is the type containing two elements `create` and `annihilate`.\n  This type is used to specify if an operator is a creation, or annihilation, operator\n  or the sum thereof or integral thereover etc. -/\ninductive CreateAnnihilate where\n  | create : CreateAnnihilate\n  | annihilate : CreateAnnihilate\nderiving Inhabited, BEq, DecidableEq\n\nnamespace CreateAnnihilate\n\n/-- The type `CreateAnnihilate` is finite. -/\ninstance : Fintype CreateAnnihilate where\n  elems := {create, annihilate}\n  complete := by\n    intro c\n    cases c\n    \u00b7 exact Finset.mem_insert_self create {annihilate}\n    \u00b7 refine Finset.insert_eq_self.mp ?_\n      exact rfl\n\nlemma eq_create_or_annihilate (\u03c6 : CreateAnnihilate) : \u03c6 = create \u2228 \u03c6 = annihilate := by\n  cases \u03c6 <;> simp\n\n/-- The normal ordering on creation and annihilation operators.\n  Under this relation, `normalOrder a b` is false only if `a` is annihilate and `b` is create. -/\ndef normalOrder : CreateAnnihilate \u2192 CreateAnnihilate \u2192 Prop\n  | create, _ => True\n  | annihilate, annihilate => True\n  | annihilate, create => False\n\n/-- The normal ordering on `CreateAnnihilate` is decidable. -/\ninstance : (\u03c6 \u03c6' : CreateAnnihilate) \u2192 Decidable (normalOrder \u03c6 \u03c6')\n  | create, create => isTrue True.intro\n  | annihilate, annihilate => isTrue True.intro\n  | create, annihilate => isTrue True.intro\n  | annihilate, create => isFalse False.elim\n\n/-- Normal ordering is total. -/\ninstance : IsTotal CreateAnnihilate normalOrder where\n  total a b := by\n    cases a <;> cases b <;> simp [normalOrder]\n\n/-- Normal ordering is transitive. -/\ninstance : IsTrans CreateAnnihilate normalOrder where\n  trans a b c := by\n    cases a <;> cases b <;> cases c <;> simp [normalOrder]\n\n", "theoremStatement": "@[simp]\nlemma not_normalOrder_annihilate_iff_false (a : CreateAnnihilate) :\n    (\u00ac normalOrder a annihilate) \u2194 False ", "theoremName": "CreateAnnihilate.not_normalOrder_annihilate_iff_false", "fileCreated": {"commit": "fb311354268a39f2884e1b3c07dc698145717b46", "date": "2025-01-06"}, "theoremCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "file": "HepLean/HepLean/PerturbationTheory/CreateAnnihilate.lean", "module": "HepLean.PerturbationTheory.CreateAnnihilate", "jsonFile": "HepLean.PerturbationTheory.CreateAnnihilate.jsonl", "positionMetadata": {"lineInFile": 60, "tokenPositionInFile": 1997, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 4, "numPremises": 18}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  cases a\n  \u00b7 simp [normalOrder]\n  \u00b7 simp [normalOrder]", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 61}}
{"srcContext": "/-\nCopyright (c) 2024 Joseph Tooby-Smith. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Tooby-Smith\n-/\nimport Mathlib.Algebra.FreeAlgebra\nimport Mathlib.Algebra.Lie.OfAssociative\nimport Mathlib.Analysis.Complex.Basic\nimport HepLean.Mathematics.List.InsertIdx\n/-!\n\n# Field statistics\n\nBasic properties related to whether a field, or list of fields, is bosonic or fermionic.\n\n-/\n\n/-- The type `FieldStatistic` is the type containing two elements `bosonic` and `fermionic`.\n  This type is used to specify if a field or operator obeys bosonic or fermionic statistics. -/\ninductive FieldStatistic : Type where\n  | bosonic : FieldStatistic\n  | fermionic : FieldStatistic\nderiving DecidableEq\n\nnamespace FieldStatistic\n\nvariable {\ud835\udcd5 : Type}\n\n/-- The type `FieldStatistic` carries an instance of a commutative group in which\n- `bosonic * bosonic = bosonic`\n- `bosonic * fermionic = fermionic`\n- `fermionic * bosonic = fermionic`\n- `fermionic * fermionic = bosonic`\n\nThis group is isomorphic to `\u2124\u2082`. -/\n@[simp]\ninstance : CommGroup FieldStatistic where\n  one := bosonic\n  mul a b :=\n    match a, b with\n    | bosonic, bosonic => bosonic\n    | bosonic, fermionic => fermionic\n    | fermionic, bosonic => fermionic\n    | fermionic, fermionic => bosonic\n  inv a := a\n  mul_assoc a b c := by\n    cases a <;> cases b <;> cases c <;>\n    dsimp [HMul.hMul]\n  one_mul a := by\n    cases a <;> dsimp [HMul.hMul]\n  mul_one a := by\n    cases a <;> dsimp [HMul.hMul]\n  inv_mul_cancel a := by\n    cases a <;> dsimp only [HMul.hMul, Nat.succ_eq_add_one] <;> rfl\n  mul_comm a b := by\n    cases a <;> cases b <;> rfl\n\n@[simp]\nlemma bosonic_mul_bosonic : bosonic * bosonic = bosonic := rfl\n\n@[simp]\nlemma bosonic_mul_fermionic : bosonic * fermionic = fermionic := rfl\n\n@[simp]\nlemma fermionic_mul_bosonic : fermionic * bosonic = fermionic := rfl\n\n@[simp]\nlemma fermionic_mul_fermionic : fermionic * fermionic = bosonic := rfl\n\n@[simp]\nlemma mul_bosonic (a : FieldStatistic) : a * bosonic = a := by\n  cases a <;> rfl\n\n@[simp]\nlemma mul_self (a : FieldStatistic) : a * a = 1 := by\n  cases a <;> rfl\n\n/-- Field statics form a finite type. -/\ninstance : Fintype FieldStatistic where\n  elems := {bosonic, fermionic}\n  complete := by\n    intro c\n    cases c\n    \u00b7 exact Finset.mem_insert_self bosonic {fermionic}\n    \u00b7 refine Finset.insert_eq_self.mp ?_\n      exact rfl\n\n@[simp]\nlemma fermionic_not_eq_bonsic : \u00ac fermionic = bosonic := by\n  intro h\n  exact FieldStatistic.noConfusion h\n\nlemma bonsic_eq_fermionic_false : bosonic = fermionic \u2194 false := by\n  simp only [reduceCtorEq, Bool.false_eq_true]\n\n@[simp]\nlemma neq_fermionic_iff_eq_bosonic (a : FieldStatistic) : \u00ac a = fermionic \u2194 a = bosonic := by\n  fin_cases a\n  \u00b7 simp\n  \u00b7 simp\n\n@[simp]\nlemma neq_bosonic_iff_eq_fermionic (a : FieldStatistic) : \u00ac a = bosonic \u2194 a = fermionic := by\n  fin_cases a\n  \u00b7 simp\n  \u00b7 simp\n\n", "theoremStatement": "@[simp]\nlemma bosonic_neq_iff_fermionic_eq (a : FieldStatistic) : \u00ac bosonic = a \u2194 fermionic = a ", "theoremName": "FieldStatistic.bosonic_neq_iff_fermionic_eq", "fileCreated": {"commit": "17f84b7153aeabcd8d93d9128211c303b4c2cc7d", "date": "2025-01-20"}, "theoremCreated": {"commit": "83f5fc5e9cd0d22073c4d86838a04ed84144105d", "date": "2024-12-20"}, "file": "HepLean/HepLean/PerturbationTheory/FieldStatistics/Basic.lean", "module": "HepLean.PerturbationTheory.FieldStatistics.Basic", "jsonFile": "HepLean.PerturbationTheory.FieldStatistics.Basic.jsonl", "positionMetadata": {"lineInFile": 108, "tokenPositionInFile": 2899, "theoremPositionInFile": 10}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 6, "repositoryPremises": true, "numRepositoryPremises": 6, "numPremises": 41}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  fin_cases a\n  \u00b7 simp\n  \u00b7 simp", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 37}}
