{"srcContext": "import ConNF.Model.RaiseStrong\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nopen scoped Pointwise\n\nnamespace ConNF\n\nvariable [Params.{u}]\n\n/-- A redefinition of the derivative of allowable permutations that is invariant of level,\nbut still has nice definitional properties. -/\n@[default_instance 200]\ninstance {\u03b2 \u03b3 : TypeIndex} : Derivative (AllPerm \u03b2) (AllPerm \u03b3) \u03b2 \u03b3 where\n  deriv \u03c1 A :=\n    A.recSderiv\n    (motive := \u03bb (\u03b4 : TypeIndex) (A : \u03b2 \u219d \u03b4) \u21a6\n      letI : Level := \u27e8\u03b4.recBotCoe (Nonempty.some inferInstance) id\u27e9\n      letI : LeLevel \u03b4 := \u27e8\u03b4.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n        (show \u03b4.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n      AllPerm \u03b4)\n    \u03c1 (\u03bb \u03b4 \u03b5 A h \u03c1 \u21a6\n      letI : Level := \u27e8\u03b4.recBotCoe (Nonempty.some inferInstance) id\u27e9\n      letI : LeLevel \u03b4 := \u27e8\u03b4.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n        (show \u03b4.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n      letI : LeLevel \u03b5 := \u27e8h.le.trans LeLevel.elim\u27e9\n      PreCoherentData.allPermSderiv h \u03c1)\n\n@[simp]\ntheorem allPerm_deriv_nil' {\u03b2 : TypeIndex}\n    (\u03c1 : AllPerm \u03b2) :\n    \u03c1 \u21d8 (.nil : \u03b2 \u219d \u03b2) = \u03c1 :=\n  rfl\n\n@[simp]\ntheorem allPerm_deriv_sderiv' {\u03b2 \u03b3 \u03b4 : TypeIndex}\n    (\u03c1 : AllPerm \u03b2) (A : \u03b2 \u219d \u03b3) (h : \u03b4 < \u03b3) :\n    \u03c1 \u21d8 (A \u2198 h) = \u03c1 \u21d8 A \u2198 h :=\n  rfl\n\n@[simp]\ntheorem allPermSderiv_forget' {\u03b2 \u03b3 : TypeIndex} (h : \u03b3 < \u03b2) (\u03c1 : AllPerm \u03b2) :\n    (\u03c1 \u2198 h)\u1d41 = \u03c1\u1d41 \u2198 h :=\n  letI : Level := \u27e8\u03b2.recBotCoe (Nonempty.some inferInstance) id\u27e9\n  letI : LeLevel \u03b2 := \u27e8\u03b2.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n    (show \u03b2.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n  letI : LeLevel \u03b3 := \u27e8h.le.trans LeLevel.elim\u27e9\n  allPermSderiv_forget h \u03c1\n\n@[simp]\ntheorem allPerm_inv_sderiv' {\u03b2 \u03b3 : TypeIndex} (h : \u03b3 < \u03b2) (\u03c1 : AllPerm \u03b2) :\n    \u03c1\u207b\u00b9 \u2198 h = (\u03c1 \u2198 h)\u207b\u00b9 := by\n  apply allPermForget_injective\n  rw [allPermSderiv_forget', allPermForget_inv, Tree.inv_sderiv, allPermForget_inv,\n    allPermSderiv_forget']\n\ndef Symmetric {\u03b1 \u03b2 : \u039b} (s : Set (TSet \u03b2)) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) : Prop :=\n  \u2203 S : Support \u03b1, \u2200 \u03c1 : AllPerm \u03b1, \u03c1\u1d41 \u2022 S = S \u2192 \u03c1 \u2198 h\u03b2 \u2022 s = s\n\ndef newSetEquiv {\u03b1 : \u039b} :\n    letI : Level := \u27e8\u03b1\u27e9\n    @TSet _ \u03b1 newModelData.toPreModelData \u2243 TSet \u03b1 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castTSet (D\u2081 := newModelData) (D\u2082 := globalModelData) rfl\n    (by rw [globalModelData, motive_eq, constructMotive, globalLtData_eq])\n\n@[simp]\ntheorem newSetEquiv_forget {\u03b1 : \u039b}\n    (x : letI : Level := \u27e8\u03b1\u27e9; @TSet _ \u03b1 newModelData.toPreModelData) :\n    (newSetEquiv x)\u1d41 = x\u1d41 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castTSet_forget (D\u2081 := newModelData) (D\u2082 := globalModelData) _ x\n\ndef allPermEquiv {\u03b1 : \u039b} :\n    letI : Level := \u27e8\u03b1\u27e9\n    NewPerm \u2243 AllPerm \u03b1 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castAllPerm (D\u2081 := newModelData) (D\u2082 := globalModelData) rfl\n    (by rw [globalModelData, motive_eq, constructMotive, globalLtData_eq])\n\n@[simp]\ntheorem allPermEquiv_forget {\u03b1 : \u039b} (\u03c1 : letI : Level := \u27e8\u03b1\u27e9; NewPerm) :\n    (allPermEquiv \u03c1)\u1d41 = \u03c1\u1d41 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castAllPerm_forget (D\u2081 := newModelData) (D\u2082 := globalModelData) _ \u03c1\n\ntheorem allPermEquiv_sderiv {\u03b1 \u03b2 : \u039b}\n    (\u03c1 : letI : Level := \u27e8\u03b1\u27e9; NewPerm) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) :\n    letI : Level := \u27e8\u03b1\u27e9\n    letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n    allPermEquiv \u03c1 \u2198 h\u03b2 = \u03c1.sderiv \u03b2 := by\n  letI : Level := \u27e8\u03b1\u27e9\n  letI : LeLevel \u03b1 := \u27e8le_rfl\u27e9\n  letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n  apply allPermForget_injective\n  rw [allPermSderiv_forget, allPermEquiv_forget, NewPerm.forget_sderiv]\n\ntheorem TSet.exists_of_symmetric {\u03b1 \u03b2 : \u039b} (s : Set (TSet \u03b2)) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1)\n    (hs : Symmetric s h\u03b2) :\n    \u2203 x : TSet \u03b1, \u2200 y : TSet \u03b2, y \u2208[h\u03b2] x \u2194 y \u2208 s := by\n  letI : Level := \u27e8\u03b1\u27e9\n  letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n  suffices \u2203 x : (@TSet _ \u03b1 newModelData.toPreModelData), \u2200 y : TSet \u03b2, y\u1d41 \u2208[h\u03b2] x\u1d41 \u2194 y \u2208 s by\n    obtain \u27e8x, hx\u27e9 := this\n    use newSetEquiv x\n    intro y\n    rw [\u2190 hx, \u2190 TSet.forget_mem_forget, newSetEquiv_forget]\n  obtain rfl | hs' := s.eq_empty_or_nonempty\n  \u00b7 use none\n    intro y\n    simp only [Set.mem_empty_iff_false, iff_false]\n    exact not_mem_none y\n  \u00b7 use some (Code.toSet \u27e8\u03b2, s, hs'\u27e9 ?_)\n    \u00b7 intro y\n      erw [mem_some_iff]\n      exact Code.mem_toSet _\n    \u00b7 obtain \u27e8S, hS\u27e9 := hs\n      use S\n      intro \u03c1 h\u03c1S\n      have := hS (allPermEquiv \u03c1) ?_\n      \u00b7 simp only [NewPerm.smul_mk, Code.mk.injEq, heq_eq_eq, true_and]\n        rwa [allPermEquiv_sderiv] at this\n      \u00b7 rwa [allPermEquiv_forget]\n\ntheorem TSet.exists_support {\u03b1 : \u039b} (x : TSet \u03b1) :\n    \u2203 S : Support \u03b1, \u2200 \u03c1 : AllPerm \u03b1, \u03c1\u1d41 \u2022 S = S \u2192 \u03c1 \u2022 x = x := by\n  letI : Level := \u27e8\u03b1\u27e9\n  obtain \u27e8S, hS\u27e9 := NewSet.exists_support (newSetEquiv.symm x)\n  use S\n  intro \u03c1 h\u03c1\n  have := @Support.Supports.supports _ _ _ newPreModelData _ _ _ hS (allPermEquiv.symm \u03c1) ?_\n  \u00b7 apply tSetForget_injective\n    have := congr_arg (\u00b7\u1d41) this\n    simp only at this\n    erw [@smul_forget _ _ newModelData (allPermEquiv.symm \u03c1) (newSetEquiv.symm x),\n      \u2190 allPermEquiv_forget, \u2190 newSetEquiv_forget, Equiv.apply_symm_apply,\n      Equiv.apply_symm_apply] at this\n    rwa [smul_forget]\n  \u00b7 rwa [\u2190 allPermEquiv_forget, Equiv.apply_symm_apply]\n\n", "theoremStatement": "theorem TSet.symmetric {\u03b1 \u03b2 : \u039b} (x : TSet \u03b1) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) :\n    Symmetric {y : TSet \u03b2 | y \u2208[h\u03b2] x} h\u03b2 ", "theoremName": "ConNF.TSet.symmetric", "fileCreated": {"commit": "6fdc87c6b30b73931407a372f1430ecf0fef7601", "date": "2024-12-03"}, "theoremCreated": {"commit": "b0bc9d69a413800c2ef0d0e3495ee0e71dc3fea7", "date": "2024-12-01"}, "file": "ConNF/ConNF/Model/TTT.lean", "module": "ConNF.Model.TTT", "jsonFile": "ConNF.Model.TTT.jsonl", "positionMetadata": {"lineInFile": 154, "tokenPositionInFile": 5178, "theoremPositionInFile": 12}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 39, "numPremises": 84}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  obtain \u27e8S, hS\u27e9 := exists_support x\n  use S\n  intro \u03c1 h\u03c1\n  conv_rhs => rw [\u2190 hS \u03c1 h\u03c1]\n  simp only [\u2190 forget_mem_forget, smul_forget, StrSet.mem_smul_iff]\n  ext y\n  rw [Set.mem_smul_set_iff_inv_smul_mem, Set.mem_setOf_eq, Set.mem_setOf_eq,\n    smul_forget, allPermForget_inv, allPermSderiv_forget']", "proofType": "tactic", "proofLengthLines": 8, "proofLengthTokens": 304}}
{"srcContext": "import ConNF.Background.Rel\nimport ConNF.Base.Small\n\n/-!\n# Enumerations\n\nIn this file, we define enumerations of a type.\n\n## Main declarations\n\n* `ConNF.Enumeration`: The type family of enumerations.\n-/\n\nuniverse u\n\nopen Cardinal\n\nnamespace ConNF\n\nvariable [Params.{u}] {X Y : Type u}\n\n@[ext]\nstructure Enumeration (X : Type u) where\n  bound : \u03ba\n  rel : Rel \u03ba X\n  lt_bound : \u2200 i \u2208 rel.dom, i < bound\n  rel_coinjective : rel.Coinjective\n\nvariable {E F G : Enumeration X}\n\nnamespace Enumeration\n\ninstance : CoeTC (Enumeration X) (Set X) where\n  coe E := E.rel.codom\n\ninstance : Membership X (Enumeration X) where\n  mem E x := x \u2208 E.rel.codom\n\ntheorem mem_iff (x : X) (E : Enumeration X) :\n    x \u2208 E \u2194 x \u2208 E.rel.codom :=\n  Iff.rfl\n\ntheorem mem_congr {E F : Enumeration X} (h : E = F) :\n    \u2200 x, x \u2208 E \u2194 x \u2208 F := by\n  intro x\n  rw [h]\n\ntheorem dom_small (E : Enumeration X) :\n    Small E.rel.dom :=\n  (iio_small E.bound).mono E.lt_bound\n\ntheorem coe_small (E : Enumeration X) :\n    Small (E : Set X) :=\n  small_codom_of_small_dom E.rel_coinjective E.dom_small\n\ntheorem graph'_small (E : Enumeration X) :\n    Small E.rel.graph' :=\n  small_graph' E.dom_small E.coe_small\n\nnoncomputable def empty : Enumeration X where\n  bound := 0\n  rel _ _ := False\n  lt_bound _ h := by cases h; contradiction\n  rel_coinjective := by constructor; intros; contradiction\n\n", "theoremStatement": "@[simp]\ntheorem not_mem_empty (x : X) : x \u2209 Enumeration.empty ", "theoremName": "ConNF.Enumeration.not_mem_empty", "fileCreated": {"commit": "39c33b4a743bea62dbcc549548b712ffd38ca65c", "date": "2024-12-05"}, "theoremCreated": {"commit": "6709914ae7f5cd3e2bb24b413e09aa844554d234", "date": "2024-11-30"}, "file": "ConNF/ConNF/ModelData/Enumeration.lean", "module": "ConNF.ModelData.Enumeration", "jsonFile": "ConNF.ModelData.Enumeration.jsonl", "positionMetadata": {"lineInFile": 66, "tokenPositionInFile": 1348, "theoremPositionInFile": 5}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 6, "numPremises": 13}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rintro \u27e8i, h\u27e9\n  cases h", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 31}}
{"srcContext": "import ConNF.Levels.Path\n\n/-!\n# Trees\n\nIn this file, we define the notion of a tree on a type.\n\n## Main declarations\n\n* `ConNF.Tree`: The type family of trees parametrised by a given type.\n-/\n\nuniverse u\n\nopen Cardinal\n\nnamespace ConNF\n\nvariable [Params.{u}] {X Y : Type _} {\u03b1 \u03b2 \u03b3 : TypeIndex}\n\n/-- An `\u03b1`-tree of `X` associates an object of type `X` to each path `\u03b1 \u219d \u22a5`. -/\ndef Tree (X : Type _) (\u03b1 : TypeIndex) :=\n  (\u03b1 \u219d \u22a5) \u2192 X\n\nnamespace Tree\n\ninstance : Derivative (Tree X \u03b1) (Tree X \u03b2) \u03b1 \u03b2 where\n  deriv T A B := T (A \u21d8 B)\n\n@[simp]\ntheorem deriv_apply (T : Tree X \u03b1) (A : \u03b1 \u219d \u03b2) (B : \u03b2 \u219d \u22a5) :\n    (T \u21d8 A) B = T (A \u21d8 B) :=\n  rfl\n\n@[simp]\ntheorem deriv_nil (T : Tree X \u03b1) :\n    T \u21d8 .nil = T := by\n  funext A\n  rw [deriv_apply, Path.nil_deriv]\n\ntheorem deriv_deriv (T : Tree X \u03b1) (A : \u03b1 \u219d \u03b2) (B : \u03b2 \u219d \u03b3) :\n    T \u21d8 A \u21d8 B = T \u21d8 (A \u21d8 B) := by\n  funext C\n  simp only [deriv_apply, Path.deriv_assoc]\n\ntheorem deriv_sderiv (T : Tree X \u03b1) (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2) :\n    T \u21d8 A \u2198 h = T \u21d8 (A \u2198 h) := by\n  rw [\u2190 Derivative.deriv_single, \u2190 Derivative.deriv_single, deriv_deriv]\n\n@[simp]\ntheorem sderiv_apply (T : Tree X \u03b1) (h : \u03b2 < \u03b1) (B : \u03b2 \u219d \u22a5) :\n    (T \u2198 h) B = T (B \u2197 h) :=\n  rfl\n\ninstance : BotDerivative (Tree X \u03b1) X \u03b1 where\n  botDeriv T A := T A\n  botSderiv T := T <| Path.nil \u2198.\n  botDeriv_single T h := by\n    cases \u03b1 using WithBot.recBotCoe with\n      | bot => cases lt_irrefl \u22a5 h\n      | coe => rfl\n\n@[simp]\ntheorem botDeriv_eq (T : Tree X \u03b1) (A : \u03b1 \u219d \u22a5) :\n    T \u21d8. A = T A :=\n  rfl\n\ntheorem botSderiv_eq (T : Tree X \u03b1) :\n    T \u2198. = T (Path.nil \u2198.) :=\n  rfl\n\n/-- The group structure on the type of `\u03b1`-trees of `X` is given by \"branchwise\" multiplication,\ngiven by `Pi.group`. -/\ninstance group [Group X] : Group (Tree X \u03b1) :=\n  Pi.group\n\n@[simp]\ntheorem one_apply [Group X] (A : \u03b1 \u219d \u22a5) :\n    (1 : Tree X \u03b1) A = 1 :=\n  rfl\n\n@[simp]\ntheorem one_deriv [Group X] (A : \u03b1 \u219d \u03b2) :\n    (1 : Tree X \u03b1) \u21d8 A = 1 :=\n  rfl\n\n@[simp]\ntheorem one_sderiv [Group X] (h : \u03b2 < \u03b1) :\n    (1 : Tree X \u03b1) \u2198 h = 1 :=\n  rfl\n\n@[simp]\ntheorem one_sderivBot [Group X] :\n    (1 : Tree X \u03b1) \u2198. = 1 :=\n  rfl\n\n@[simp]\ntheorem mul_apply [Group X] (T\u2081 T\u2082 : Tree X \u03b1) (A : \u03b1 \u219d \u22a5) :\n    (T\u2081 * T\u2082) A = T\u2081 A * T\u2082 A :=\n  rfl\n\n", "theoremStatement": "@[simp]\ntheorem mul_deriv [Group X] (T\u2081 T\u2082 : Tree X \u03b1) (A : \u03b1 \u219d \u03b2) :\n    (T\u2081 * T\u2082) \u21d8 A = T\u2081 \u21d8 A * T\u2082 \u21d8 A ", "theoremName": "ConNF.Tree.mul_deriv", "fileCreated": {"commit": "8896e416a16c39e1fe487b5fc7c78bc20c4e182b", "date": "2024-12-03"}, "theoremCreated": {"commit": "012929981ca97cb4447881b386c61e3bac0c6b93", "date": "2024-11-30"}, "file": "ConNF/ConNF/Levels/Tree.lean", "module": "ConNF.Levels.Tree", "jsonFile": "ConNF.Levels.Tree.jsonl", "positionMetadata": {"lineInFile": 102, "tokenPositionInFile": 2187, "theoremPositionInFile": 13}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 7, "numPremises": 16}, "proofMetadata": {"hasProof": true, "proof": ":=\n  rfl", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 8}}
{"srcContext": "import ConNF.Model.Result\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal ConNF.TSet\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\ndef union (x y : TSet \u03b1) : TSet \u03b1 :=\n  (x\u1d9c' \u2293' y\u1d9c')\u1d9c'\n\nnotation:68 x:68 \" \u2294[\" h \"] \" y:68 => _root_.ConNF.union h x y\nnotation:68 x:68 \" \u2294' \" y:68 => x \u2294[by assumption] y\n\n@[simp]\ntheorem mem_union_iff (x y : TSet \u03b1) :\n    \u2200 z : TSet \u03b2, z \u2208' x \u2294' y \u2194 z \u2208' x \u2228 z \u2208' y := by\n  rw [union]\n  intro z\n  rw [mem_compl_iff, mem_inter_iff, mem_compl_iff, mem_compl_iff, or_iff_not_and_not]\n\ndef higherIndex (\u03b1 : \u039b) : \u039b :=\n  (exists_gt \u03b1).choose\n\ntheorem lt_higherIndex {\u03b1 : \u039b} :\n    (\u03b1 : TypeIndex) < higherIndex \u03b1 :=\n  WithBot.coe_lt_coe.mpr (exists_gt \u03b1).choose_spec\n\ntheorem tSet_nonempty (h : \u2203 \u03b2 : \u039b, (\u03b2 : TypeIndex) < \u03b1) : Nonempty (TSet \u03b1) := by\n  obtain \u27e8\u03b1', h\u03b1\u27e9 := h\n  constructor\n  apply typeLower lt_higherIndex lt_higherIndex lt_higherIndex h\u03b1\n  apply cardinalOne lt_higherIndex lt_higherIndex\n\ndef empty : TSet \u03b1 :=\n  (tSet_nonempty \u27e8\u03b2, h\u03b2\u27e9).some \u2293' (tSet_nonempty \u27e8\u03b2, h\u03b2\u27e9).some\u1d9c'\n\n@[simp]\ntheorem mem_empty_iff :\n    \u2200 x : TSet \u03b2, \u00acx \u2208' empty h\u03b2 := by\n  intro x\n  rw [empty, mem_inter_iff, mem_compl_iff]\n  exact and_not_self\n\ndef univ : TSet \u03b1 :=\n  (empty h\u03b2)\u1d9c'\n\n@[simp]\ntheorem mem_univ_iff :\n    \u2200 x : TSet \u03b2, x \u2208' univ h\u03b2 := by\n  intro x\n  simp only [univ, mem_compl_iff, mem_empty_iff, not_false_eq_true]\n\n/-- The set of all ordered pairs. -/\ndef orderedPairs : TSet \u03b1 :=\n  vCross h\u03b2 h\u03b3 h\u03b4 (univ h\u03b4)\n\n@[simp]\ntheorem mem_orderedPairs_iff (x : TSet \u03b2) :\n    x \u2208' orderedPairs h\u03b2 h\u03b3 h\u03b4 \u2194 \u2203 a b, x = \u27e8a, b\u27e9' := by\n  simp only [orderedPairs, vCross_spec, mem_univ_iff, and_true]\n\ndef converse (x : TSet \u03b1) : TSet \u03b1 :=\n  converse' h\u03b2 h\u03b3 h\u03b4 x \u2293' orderedPairs h\u03b2 h\u03b3 h\u03b4\n\n@[simp]\ntheorem op_mem_converse_iff (x : TSet \u03b1) :\n    \u2200 a b, \u27e8a, b\u27e9' \u2208' converse h\u03b2 h\u03b3 h\u03b4 x \u2194 \u27e8b, a\u27e9' \u2208' x := by\n  intro a b\n  simp only [converse, mem_inter_iff, converse'_spec, mem_orderedPairs_iff, op_inj, exists_and_left,\n    exists_eq', and_true]\n\ndef cross (x y : TSet \u03b3) : TSet \u03b1 :=\n  converse h\u03b2 h\u03b3 h\u03b4 (vCross h\u03b2 h\u03b3 h\u03b4 x) \u2293' vCross h\u03b2 h\u03b3 h\u03b4 y\n\n@[simp]\ntheorem mem_cross_iff (x y : TSet \u03b3) :\n    \u2200 a, a \u2208' cross h\u03b2 h\u03b3 h\u03b4 x y \u2194 \u2203 b c, a = \u27e8b, c\u27e9' \u2227 b \u2208' x \u2227 c \u2208' y := by\n  intro a\n  rw [cross, mem_inter_iff, vCross_spec]\n  constructor\n  \u00b7 rintro \u27e8h\u2081, b, c, rfl, h\u2082\u27e9\n    simp only [op_mem_converse_iff, vCross_spec, op_inj] at h\u2081\n    obtain \u27e8b', c', \u27e8rfl, rfl\u27e9, h\u2081\u27e9 := h\u2081\n    exact \u27e8b, c, rfl, h\u2081, h\u2082\u27e9\n  \u00b7 rintro \u27e8b, c, rfl, h\u2081, h\u2082\u27e9\n    simp only [op_mem_converse_iff, vCross_spec, op_inj]\n    exact \u27e8\u27e8c, b, \u27e8rfl, rfl\u27e9, h\u2081\u27e9, \u27e8b, c, \u27e8rfl, rfl\u27e9, h\u2082\u27e9\u27e9\n\ndef singletonImage (x : TSet \u03b2) : TSet \u03b1 :=\n  singletonImage' h\u03b2 h\u03b3 h\u03b4 h\u03b5 x \u2293' (cross h\u03b2 h\u03b3 h\u03b4 (cardinalOne h\u03b4 h\u03b5) (cardinalOne h\u03b4 h\u03b5))\n\n@[simp]\ntheorem singletonImage_spec (x : TSet \u03b2) :\n    \u2200 z w,\n    \u27e8 {z}', {w}' \u27e9' \u2208' singletonImage h\u03b2 h\u03b3 h\u03b4 h\u03b5 x \u2194 \u27e8z, w\u27e9' \u2208' x := by\n  intro z w\n  rw [singletonImage, mem_inter_iff, singletonImage'_spec, and_iff_left_iff_imp]\n  intro hzw\n  rw [mem_cross_iff]\n  refine \u27e8{z}', {w}', rfl, ?_\u27e9\n  simp only [mem_cardinalOne_iff, singleton_inj, exists_eq', and_self]\n\ntheorem exists_of_mem_singletonImage {x : TSet \u03b2} {z w : TSet \u03b4}\n    (h : \u27e8z, w\u27e9' \u2208' singletonImage h\u03b2 h\u03b3 h\u03b4 h\u03b5 x) :\n    \u2203 a b, z = {a}' \u2227 w = {b}' := by\n  simp only [singletonImage, mem_inter_iff, mem_cross_iff, op_inj, mem_cardinalOne_iff] at h\n  obtain \u27e8-, _, _, \u27e8rfl, rfl\u27e9, \u27e8a, rfl\u27e9, \u27e8b, rfl\u27e9\u27e9 := h\n  exact \u27e8a, b, rfl, rfl\u27e9\n\n/-- Turn a model element encoding a relation into an actual relation. -/\ndef ExternalRel (r : TSet \u03b1) : Rel (TSet \u03b4) (TSet \u03b4) :=\n  \u03bb x y \u21a6 \u27e8x, y\u27e9' \u2208' r\n\n@[simp]\ntheorem externalRel_converse (r : TSet \u03b1) :\n    ExternalRel h\u03b2 h\u03b3 h\u03b4 (converse h\u03b2 h\u03b3 h\u03b4 r) = (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).inv := by\n  ext\n  simp only [ExternalRel, op_mem_converse_iff, Rel.inv_apply]\n\n/-- The codomain of a relation. -/\ndef codom (r : TSet \u03b1) : TSet \u03b3 :=\n  (typeLower lt_higherIndex h\u03b2 h\u03b3 h\u03b4 (singletonImage lt_higherIndex h\u03b2 h\u03b3 h\u03b4 r)\u1d9c[lt_higherIndex])\u1d9c'\n\n", "theoremStatement": "@[simp]\ntheorem mem_codom_iff (r : TSet \u03b1) (x : TSet \u03b4) :\n    x \u2208' codom h\u03b2 h\u03b3 h\u03b4 r \u2194 x \u2208 (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).codom ", "theoremName": "ConNF.mem_codom_iff", "fileCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "theoremCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "file": "ConNF/ConNF/External/Basic.lean", "module": "ConNF.External.Basic", "jsonFile": "ConNF.External.Basic.jsonl", "positionMetadata": {"lineInFile": 139, "tokenPositionInFile": 4169, "theoremPositionInFile": 23}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 7, "repositoryPremises": true, "numRepositoryPremises": 22, "numPremises": 57}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp only [codom, mem_compl_iff, mem_typeLower_iff, not_forall, not_not]\n  constructor\n  \u00b7 rintro \u27e8y, hy\u27e9\n    obtain \u27e8a, b, rfl, hb\u27e9 := exists_of_mem_singletonImage lt_higherIndex h\u03b2 h\u03b3 h\u03b4 hy\n    rw [singleton_inj] at hb\n    subst hb\n    rw [singletonImage_spec] at hy\n    exact \u27e8a, hy\u27e9\n  \u00b7 rintro \u27e8a, ha\u27e9\n    use {a}'\n    rw [singletonImage_spec]\n    exact ha", "proofType": "tactic", "proofLengthLines": 12, "proofLengthTokens": 368}}
{"srcContext": "import ConNF.Model.Externalise\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b2 \u03b3 : \u039b} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n\nnamespace Support\n\ntheorem not_mem_scoderiv_botDeriv (S : Support \u03b3) (N : NearLitter) :\n    N \u2209 (S \u2197 h\u03b3 \u21d8. (Path.nil \u2198.))\u1d3a := by\n  rintro \u27e8i, \u27e8A, N'\u27e9, h\u2081, h\u2082\u27e9\n  simp only [Prod.mk.injEq] at h\u2082\n  cases A\n  case sderiv \u03b4 A h\u03b4 _ =>\n    simp only [Path.deriv_sderiv] at h\u2082\n    cases A\n    case nil => cases h\u2082.1\n    case sderiv \u03b6 A h\u03b6 _ =>\n      simp only [Path.deriv_sderiv] at h\u2082\n      cases h\u2082.1\n\nvariable [Level] [LtLevel \u03b2]\n\ntheorem not_mem_strong_botDeriv (S : Support \u03b3) (N : NearLitter) :\n    N \u2209 ((S \u2197 h\u03b3).strong \u21d8. (Path.nil \u2198.))\u1d3a := by\n  rintro h\n  rw [strong, close_nearLitters, preStrong_nearLitters, Enumeration.mem_add_iff] at h\n  obtain h | h := h\n  \u00b7 exact not_mem_scoderiv_botDeriv S N h\n  \u00b7 rw [mem_constrainsNearLitters_nearLitters] at h\n    obtain \u27e8B, N', hN', h\u27e9 := h\n    cases h using Relation.ReflTransGen.head_induction_on\n    case refl => exact not_mem_scoderiv_botDeriv S N hN'\n    case head x hx\u2081 hx\u2082 _ =>\n      obtain \u27e8\u27e8\u03b3, \u03b4, \u03b5, h\u03b4, h\u03b5, h\u03b4\u03b5, A\u27e9, t, B, hB, hN, ht\u27e9 := hx\u2082\n      simp only at hB\n      cases B\n      case nil =>\n        cases hB\n        obtain \u27e8C, N''\u27e9 := x\n        simp only at ht\n        cases ht.1\n        change _ \u2208 t.support\u1d3a at hN\n        rw [t.support_supports.2 rfl] at hN\n        obtain \u27e8i, hN\u27e9 := hN\n        cases hN\n      case sderiv \u03b4 B h\u03b4 _ _ =>\n        cases B\n        case nil => cases hB\n        case sderiv \u03b6 B h\u03b6 _ _ => cases hB\n\ntheorem raise_preStrong' (S : Support \u03b1) (hS : S.Strong) (T : Support \u03b3) (\u03c1 : AllPerm \u03b2)\n    (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2) :\n    (S + (\u03c1\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim).PreStrong := by\n  apply hS.toPreStrong.add\n  constructor\n  intro A N hN P t hA ht\n  obtain \u27e8A, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv hN\n  simp only [scoderiv_botDeriv_eq, add_derivBot, smul_derivBot,\n    BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters, interferenceSupport_nearLitters,\n    Enumeration.mem_add_iff, Enumeration.mem_smul, Enumeration.not_mem_empty, or_false] at hN\n  obtain \u27e8\u03b4, \u03b5, \u03b6, h\u03b5, h\u03b6, h\u03b5\u03b6, B\u27e9 := P\n  dsimp only at *\n  cases A\n  case sderiv \u03b6' A h\u03b6' _ =>\n    rw [\u2190 Path.coderiv_deriv] at hA\n    cases Path.sderiv_index_injective hA\n    apply Path.sderiv_left_inj.mp at hA\n    cases A\n    case nil =>\n      cases hA\n      cases not_mem_strong_botDeriv T _ hN\n    case sderiv \u03b9 A h\u03b9 _ _ =>\n      rw [\u2190 Path.coderiv_deriv] at hA\n      cases Path.sderiv_index_injective hA\n      cases hA\n      haveI : LtLevel \u03b4 := \u27e8A.le.trans_lt LtLevel.elim\u27e9\n      haveI : LtLevel \u03b5 := \u27e8h\u03b5.trans LtLevel.elim\u27e9\n      haveI : LtLevel \u03b6 := \u27e8h\u03b6.trans LtLevel.elim\u27e9\n      have := (T \u2197 h\u03b3).strong_strong.support_le hN \u27e8\u03b4, \u03b5, \u03b6, h\u03b5, h\u03b6, h\u03b5\u03b6, A\u27e9\n          (\u03c1\u207b\u00b9 \u21d8 A \u2198 h\u03b5 \u2022 t) rfl ?_\n      \u00b7 simp only [Tangle.smul_support, allPermSderiv_forget, allPermDeriv_forget,\n          allPermForget_inv, Tree.inv_deriv, Tree.inv_sderiv] at this\n        have := smul_le_smul this (\u03c1\u1d41 \u21d8 A \u2198 h\u03b5)\n        simp only [smul_inv_smul] at this\n        apply le_trans this\n        intro B\n        constructor\n        \u00b7 intro a ha\n          simp only [smul_derivBot, Tree.sderiv_apply, Tree.deriv_apply, Path.deriv_scoderiv,\n            deriv_derivBot, Enumeration.mem_smul] at ha\n          rw [deriv_derivBot, \u2190 Path.deriv_scoderiv, Path.coderiv_deriv', scoderiv_botDeriv_eq,]\n          simp only [Path.deriv_scoderiv, add_derivBot, smul_derivBot,\n            BaseSupport.add_atoms, BaseSupport.smul_atoms, Enumeration.mem_add_iff,\n            Enumeration.mem_smul]\n          exact Or.inl ha\n        \u00b7 intro N hN\n          simp only [smul_derivBot, Tree.sderiv_apply, Tree.deriv_apply, Path.deriv_scoderiv,\n            deriv_derivBot, Enumeration.mem_smul] at hN\n          rw [deriv_derivBot, \u2190 Path.deriv_scoderiv, Path.coderiv_deriv', scoderiv_botDeriv_eq,]\n          simp only [Path.deriv_scoderiv, add_derivBot, smul_derivBot,\n            BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters, Enumeration.mem_add_iff,\n            Enumeration.mem_smul]\n          exact Or.inl hN\n      \u00b7 rw [\u2190 smul_fuzz h\u03b5 h\u03b6 h\u03b5\u03b6, \u2190 ht]\n        simp only [Path.botSderiv_coe_eq, BasePerm.smul_nearLitter_litter, allPermDeriv_forget,\n          allPermForget_inv, Tree.inv_deriv, Tree.inv_sderiv, Tree.inv_sderivBot]\n        rfl\n\ntheorem raise_closed' (S : Support \u03b1) (hS : S.Strong) (T : Support \u03b3) (\u03c1 : AllPerm \u03b2)\n    (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n    (h\u03c1 : \u03c1\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim) :\n    (S + (\u03c1\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim).Closed := by\n  constructor\n  intro A\n  constructor\n  intro N\u2081 N\u2082 hN\u2081 hN\u2082 a ha\n  simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff,\n    BaseSupport.add_atoms] at hN\u2081 hN\u2082 \u22a2\n  obtain hN\u2081 | hN\u2081 := hN\u2081\n  \u00b7 obtain hN\u2082 | hN\u2082 := hN\u2082\n    \u00b7 exact Or.inl ((hS.closed A).interference_subset hN\u2081 hN\u2082 a ha)\n    \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv hN\u2082\n      simp only [smul_add, scoderiv_botDeriv_eq, add_derivBot, smul_derivBot,\n        BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters, Enumeration.mem_add_iff,\n        Enumeration.mem_smul, BaseSupport.add_atoms, BaseSupport.smul_atoms] at hN\u2081 hN\u2082 \u22a2\n      refine Or.inr (Or.inr ?_)\n      rw [mem_interferenceSupport_atoms]\n      refine \u27e8(\u03c1\u1d41 B)\u207b\u00b9 \u2022 N\u2081, ?_, (\u03c1\u1d41 B)\u207b\u00b9 \u2022 N\u2082, ?_, ?_\u27e9\n      \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n        rw [\u2190 Enumeration.mem_smul, \u2190 BaseSupport.smul_nearLitters, \u2190 smul_derivBot, h\u03c1]\n        exact Or.inl hN\u2081\n      \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n        simp only [interferenceSupport_nearLitters, Enumeration.not_mem_empty, or_false] at hN\u2082\n        exact Or.inr hN\u2082\n      \u00b7 rw [\u2190 BasePerm.smul_interference]\n        exact Set.smul_mem_smul_set ha\n  \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv hN\u2081\n    simp only [smul_add, scoderiv_botDeriv_eq, add_derivBot, smul_derivBot,\n      BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters, Enumeration.mem_add_iff,\n      Enumeration.mem_smul, BaseSupport.add_atoms, BaseSupport.smul_atoms] at hN\u2081 hN\u2082 \u22a2\n    refine Or.inr (Or.inr ?_)\n    rw [mem_interferenceSupport_atoms]\n    refine \u27e8(\u03c1\u1d41 B)\u207b\u00b9 \u2022 N\u2081, ?_, (\u03c1\u1d41 B)\u207b\u00b9 \u2022 N\u2082, ?_, ?_\u27e9\n    \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n      simp only [interferenceSupport_nearLitters, Enumeration.not_mem_empty, or_false] at hN\u2081\n      exact Or.inr hN\u2081\n    \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n      simp only [interferenceSupport_nearLitters, Enumeration.not_mem_empty, or_false] at hN\u2082\n      obtain hN\u2082 | hN\u2082 := hN\u2082\n      \u00b7 rw [\u2190 Enumeration.mem_smul, \u2190 BaseSupport.smul_nearLitters, \u2190 smul_derivBot, h\u03c1]\n        exact Or.inl hN\u2082\n      \u00b7 exact Or.inr hN\u2082\n    \u00b7 rw [\u2190 BasePerm.smul_interference]\n      exact Set.smul_mem_smul_set ha\n\ntheorem raise_strong' (S : Support \u03b1) (hS : S.Strong) (T : Support \u03b3) (\u03c1 : AllPerm \u03b2)\n    (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n    (h\u03c1 : \u03c1\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim) :\n    (S + (\u03c1\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim).Strong :=\n  \u27e8raise_preStrong' S hS T \u03c1 h\u03b3, raise_closed' S hS T \u03c1 h\u03b3 h\u03c1\u27e9\n\n", "theoremStatement": "theorem convAtoms_injective_of_fixes {S : Support \u03b1} {T : Support \u03b3}\n    {\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n    (h\u03c1\u2081 : \u03c1\u2081\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (h\u03c1\u2082 : \u03c1\u2082\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (A : \u2191\u03b1 \u219d \u22a5) :\n    (convAtoms\n      (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong + (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197\n        LtLevel.elim)\n      (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong + (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197\n        LtLevel.elim) A).Injective ", "theoremName": "ConNF.Support.convAtoms_injective_of_fixes", "fileCreated": {"commit": "abf71bc79c407ceb462cc2edd2d994cda9cdef05", "date": "2024-04-04"}, "theoremCreated": {"commit": "6709914ae7f5cd3e2bb24b413e09aa844554d234", "date": "2024-11-30"}, "file": "ConNF/ConNF/Model/RaiseStrong.lean", "module": "ConNF.Model.RaiseStrong", "jsonFile": "ConNF.Model.RaiseStrong.jsonl", "positionMetadata": {"lineInFile": 181, "tokenPositionInFile": 7503, "theoremPositionInFile": 5}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 71, "numPremises": 148}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [Support.smul_eq_iff] at h\u03c1\u2081 h\u03c1\u2082\n  constructor\n  rintro a\u2081 a\u2082 a\u2083 \u27e8i, hi\u2081, hi\u2082\u27e9 \u27e8j, hj\u2081, hj\u2082\u27e9\n  simp only [add_derivBot, BaseSupport.add_atoms, Rel.inv_apply,\n    Enumeration.rel_add_iff] at hi\u2081 hi\u2082 hj\u2081 hj\u2082\n  obtain hi\u2081 | \u27e8i, rfl, hi\u2081\u27e9 := hi\u2081\n  \u00b7 obtain hi\u2082 | \u27e8i', rfl, _\u27e9 := hi\u2082\n    swap\n    \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hi\u2081\u27e9\n      simp only [add_lt_iff_neg_left] at this\n      cases (\u03ba_zero_le i').not_lt this\n    cases (Enumeration.rel_coinjective _).coinjective hi\u2081 hi\u2082\n    obtain hj\u2081 | \u27e8j, rfl, hj\u2081\u27e9 := hj\u2081\n    \u00b7 obtain hj\u2082 | \u27e8j', rfl, _\u27e9 := hj\u2082\n      \u00b7 exact (Enumeration.rel_coinjective _).coinjective hj\u2082 hj\u2081\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2081\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j').not_lt this\n    \u00b7 obtain hj\u2082 | hj\u2082 := hj\u2082\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2082\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j).not_lt this\n      \u00b7 simp only [add_right_inj, exists_eq_left] at hj\u2082\n        obtain \u27e8B, rfl\u27e9 := eq_of_atom_mem_scoderiv_botDeriv \u27e8j, hj\u2081\u27e9\n        simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_atoms,\n          BaseSupport.add_atoms, Enumeration.smul_rel, add_right_inj, exists_eq_left] at hj\u2081 hj\u2082\n        have := (Enumeration.rel_coinjective _).coinjective hj\u2081 hj\u2082\n        rw [\u2190 (h\u03c1\u2082 B).1 a\u2081 \u27e8_, hi\u2081\u27e9, inv_smul_smul, inv_smul_eq_iff, (h\u03c1\u2081 B).1 a\u2081 \u27e8_, hi\u2081\u27e9] at this\n        exact this.symm\n  \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_atom_mem_scoderiv_botDeriv \u27e8i, hi\u2081\u27e9\n    simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_atoms,\n      BaseSupport.add_atoms, Enumeration.smul_rel, add_right_inj, exists_eq_left] at hi\u2081 hi\u2082 hj\u2081 hj\u2082\n    obtain hi\u2082 | hi\u2082 := hi\u2082\n    \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hi\u2082\u27e9\n      simp only [add_lt_iff_neg_left] at this\n      cases (\u03ba_zero_le i).not_lt this\n    have hi := (Enumeration.rel_coinjective _).coinjective hi\u2081 hi\u2082\n    suffices hj : (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 a\u2082 = (\u03c1\u2082\u1d41 B)\u207b\u00b9 \u2022 a\u2083 by\n      rwa [\u2190 hj, smul_left_cancel_iff] at hi\n    obtain hj\u2081 | \u27e8j, rfl, hj\u2081\u27e9 := hj\u2081\n    \u00b7 obtain hj\u2082 | \u27e8j', rfl, _\u27e9 := hj\u2082\n      \u00b7 rw [\u2190 (h\u03c1\u2081 B).1 a\u2082 \u27e8_, hj\u2081\u27e9, \u2190 (h\u03c1\u2082 B).1 a\u2083 \u27e8_, hj\u2082\u27e9, inv_smul_smul, inv_smul_smul]\n        exact (Enumeration.rel_coinjective _).coinjective hj\u2081 hj\u2082\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2081\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j').not_lt this\n    \u00b7 obtain hj\u2082 | hj\u2082 := hj\u2082\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2082\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j).not_lt this\n      \u00b7 simp only [add_right_inj, exists_eq_left] at hj\u2082\n        exact (Enumeration.rel_coinjective _).coinjective hj\u2081 hj\u2082", "proofType": "tactic", "proofLengthLines": 52, "proofLengthTokens": 2698}}
{"srcContext": "import ConNF.ModelData.PathEnumeration\n\n/-!\n# Supports\n\nIn this file, we define the notion of a support.\n\n## Main declarations\n\n* `ConNF.BaseSupport`: The type of supports of atoms.\n* `ConNF.Support`: The type of supports of objects of arbitrary type indices.\n-/\n\nuniverse u\n\nopen Cardinal\n\nnamespace ConNF\n\nvariable [Params.{u}]\n\n/-!\n## Base supports\n-/\n\nstructure BaseSupport where\n  atoms : Enumeration Atom\n  nearLitters : Enumeration NearLitter\n\nnamespace BaseSupport\n\ninstance : SuperA BaseSupport (Enumeration Atom) where\n  superA := atoms\n\ninstance : SuperN BaseSupport (Enumeration NearLitter) where\n  superN := nearLitters\n\n@[simp]\ntheorem mk_atoms {a : Enumeration Atom} {N : Enumeration NearLitter} :\n    (BaseSupport.mk a N)\u1d2c = a :=\n  rfl\n\n@[simp]\ntheorem mk_nearLitters {a : Enumeration Atom} {N : Enumeration NearLitter} :\n    (BaseSupport.mk a N)\u1d3a = N :=\n  rfl\n\ntheorem atoms_congr {S T : BaseSupport} (h : S = T) :\n    S\u1d2c = T\u1d2c :=\n  h \u25b8 rfl\n\ntheorem nearLitters_congr {S T : BaseSupport} (h : S = T) :\n    S\u1d3a = T\u1d3a :=\n  h \u25b8 rfl\n\n@[ext]\ntheorem ext {S T : BaseSupport} (h\u2081 : S\u1d2c = T\u1d2c) (h\u2082 : S\u1d3a = T\u1d3a) : S = T := by\n  obtain \u27e8SA, SN\u27e9 := S\n  obtain \u27e8TA, TN\u27e9 := T\n  cases h\u2081\n  cases h\u2082\n  rfl\n\ninstance : SMul BasePerm BaseSupport where\n  smul \u03c0 S := \u27e8\u03c0 \u2022 S\u1d2c, \u03c0 \u2022 S\u1d3a\u27e9\n\n@[simp]\ntheorem smul_atoms (\u03c0 : BasePerm) (S : BaseSupport) :\n    (\u03c0 \u2022 S)\u1d2c = \u03c0 \u2022 S\u1d2c :=\n  rfl\n\n@[simp]\ntheorem smul_nearLitters (\u03c0 : BasePerm) (S : BaseSupport) :\n    (\u03c0 \u2022 S)\u1d3a = \u03c0 \u2022 S\u1d3a :=\n  rfl\n\n@[simp]\ntheorem smul_atoms_eq_of_smul_eq {\u03c0 : BasePerm} {S : BaseSupport}\n    (h : \u03c0 \u2022 S = S) :\n    \u03c0 \u2022 S\u1d2c = S\u1d2c := by\n  rw [\u2190 smul_atoms, h]\n\n@[simp]\ntheorem smul_nearLitters_eq_of_smul_eq {\u03c0 : BasePerm} {S : BaseSupport}\n    (h : \u03c0 \u2022 S = S) :\n    \u03c0 \u2022 S\u1d3a = S\u1d3a := by\n  rw [\u2190 smul_nearLitters, h]\n\ninstance : MulAction BasePerm BaseSupport where\n  one_smul S := by\n    apply ext\n    \u00b7 rw [smul_atoms, one_smul]\n    \u00b7 rw [smul_nearLitters, one_smul]\n  mul_smul \u03c0\u2081 \u03c0\u2082 S := by\n    apply ext\n    \u00b7 rw [smul_atoms, smul_atoms, smul_atoms, mul_smul]\n    \u00b7 rw [smul_nearLitters, smul_nearLitters, smul_nearLitters, mul_smul]\n\ntheorem smul_eq_smul_iff (\u03c0\u2081 \u03c0\u2082 : BasePerm) (S : BaseSupport) :\n    \u03c0\u2081 \u2022 S = \u03c0\u2082 \u2022 S \u2194 (\u2200 a \u2208 S\u1d2c, \u03c0\u2081 \u2022 a = \u03c0\u2082 \u2022 a) \u2227 (\u2200 N \u2208 S\u1d3a, \u03c0\u2081 \u2022 N = \u03c0\u2082 \u2022 N) := by\n  constructor\n  \u00b7 intro h\n    constructor\n    \u00b7 rintro a \u27e8i, ha\u27e9\n      have := congr_arg (\u00b7\u1d2c.rel i (\u03c0\u2081 \u2022 a)) h\n      simp only [smul_atoms, Enumeration.smul_rel, inv_smul_smul, eq_iff_iff] at this\n      have := S\u1d2c.rel_coinjective.coinjective ha (this.mp ha)\n      rw [eq_inv_smul_iff] at this\n      rw [this]\n    \u00b7 rintro N \u27e8i, hN\u27e9\n      have := congr_arg (\u00b7\u1d3a.rel i (\u03c0\u2081 \u2022 N)) h\n      simp only [smul_nearLitters, Enumeration.smul_rel, inv_smul_smul, eq_iff_iff] at this\n      have := S\u1d3a.rel_coinjective.coinjective hN (this.mp hN)\n      rw [eq_inv_smul_iff] at this\n      rw [this]\n  \u00b7 intro h\n    ext : 2\n    \u00b7 rfl\n    \u00b7 ext i a : 3\n      rw [smul_atoms, smul_atoms, Enumeration.smul_rel, Enumeration.smul_rel]\n      constructor\n      \u00b7 intro ha\n        have := h.1 _ \u27e8i, ha\u27e9\n        rw [smul_inv_smul, \u2190 inv_smul_eq_iff] at this\n        rwa [this]\n      \u00b7 intro ha\n        have := h.1 _ \u27e8i, ha\u27e9\n        rw [smul_inv_smul, smul_eq_iff_eq_inv_smul] at this\n        rwa [\u2190 this]\n    \u00b7 rfl\n    \u00b7 ext i a : 3\n      rw [smul_nearLitters, smul_nearLitters, Enumeration.smul_rel, Enumeration.smul_rel]\n      constructor\n      \u00b7 intro hN\n        have := h.2 _ \u27e8i, hN\u27e9\n        rw [smul_inv_smul, \u2190 inv_smul_eq_iff] at this\n        rwa [this]\n      \u00b7 intro hN\n        have := h.2 _ \u27e8i, hN\u27e9\n        rw [smul_inv_smul, smul_eq_iff_eq_inv_smul] at this\n        rwa [\u2190 this]\n\ntheorem smul_eq_iff (\u03c0 : BasePerm) (S : BaseSupport) :\n    \u03c0 \u2022 S = S \u2194 (\u2200 a \u2208 S\u1d2c, \u03c0 \u2022 a = a) \u2227 (\u2200 N \u2208 S\u1d3a, \u03c0 \u2022 N = N) := by\n  have := smul_eq_smul_iff \u03c0 1 S\n  simp only [one_smul] at this\n  exact this\n\nnoncomputable instance : Add BaseSupport where\n  add S T := \u27e8S\u1d2c + T\u1d2c, S\u1d3a + T\u1d3a\u27e9\n\n@[simp]\ntheorem add_atoms (S T : BaseSupport) :\n    (S + T)\u1d2c = S\u1d2c + T\u1d2c :=\n  rfl\n\n@[simp]\ntheorem add_nearLitters (S T : BaseSupport) :\n    (S + T)\u1d3a = S\u1d3a + T\u1d3a :=\n  rfl\n\nend BaseSupport\n\ndef baseSupportEquiv : BaseSupport \u2243 Enumeration Atom \u00d7 Enumeration NearLitter where\n  toFun S := (S\u1d2c, S\u1d3a)\n  invFun S := \u27e8S.1, S.2\u27e9\n  left_inv _ := rfl\n  right_inv _ := rfl\n\ntheorem card_baseSupport : #BaseSupport = #\u03bc := by\n  rw [Cardinal.eq.mpr \u27e8baseSupportEquiv\u27e9, mk_prod, lift_id, lift_id,\n    card_enumeration_eq card_atom, card_enumeration_eq card_nearLitter, mul_eq_self aleph0_lt_\u03bc.le]\n\n/-!\n## Structural supports\n-/\n\nstructure Support (\u03b1 : TypeIndex) where\n  atoms : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)\n  nearLitters : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)\n\nnamespace Support\n\nvariable {\u03b1 \u03b2 : TypeIndex}\n\ninstance : SuperA (Support \u03b1) (Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) where\n  superA := atoms\n\ninstance : SuperN (Support \u03b1) (Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) where\n  superN := nearLitters\n\n@[simp]\ntheorem mk_atoms (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) (F : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) :\n    (\u27e8E, F\u27e9 : Support \u03b1)\u1d2c = E :=\n  rfl\n\n@[simp]\ntheorem mk_nearLitters (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) (F : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) :\n    (\u27e8E, F\u27e9 : Support \u03b1)\u1d3a = F :=\n  rfl\n\ninstance : Derivative (Support \u03b1) (Support \u03b2) \u03b1 \u03b2 where\n  deriv S A := \u27e8S\u1d2c \u21d8 A, S\u1d3a \u21d8 A\u27e9\n\ninstance : Coderivative (Support \u03b2) (Support \u03b1) \u03b1 \u03b2 where\n  coderiv S A := \u27e8S\u1d2c \u21d7 A, S\u1d3a \u21d7 A\u27e9\n\ninstance : BotDerivative (Support \u03b1) BaseSupport \u03b1 where\n  botDeriv S A := \u27e8S\u1d2c \u21d8. A, S\u1d3a \u21d8. A\u27e9\n  botSderiv S := \u27e8S\u1d2c \u2198., S\u1d3a \u2198.\u27e9\n  botDeriv_single S h := by dsimp only; rw [botDeriv_single, botDeriv_single]\n\n@[simp]\ntheorem deriv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u03b2) :\n    S\u1d2c \u21d8 A = (S \u21d8 A)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem deriv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u03b2) :\n    S\u1d3a \u21d8 A = (S \u21d8 A)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem sderiv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (h : \u03b2 < \u03b1) :\n    S\u1d2c \u2198 h = (S \u2198 h)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem sderiv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (h : \u03b2 < \u03b1) :\n    S\u1d3a \u2198 h = (S \u2198 h)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem coderiv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    S\u1d2c \u21d7 A = (S \u21d7 A)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem coderiv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    S\u1d3a \u21d7 A = (S \u21d7 A)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem scoderiv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (h : \u03b2 < \u03b1) :\n    S\u1d2c \u2197 h = (S \u2197 h)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem scoderiv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (h : \u03b2 < \u03b1) :\n    S\u1d3a \u2197 h = (S \u2197 h)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem derivBot_atoms {\u03b1 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u22a5) :\n    S\u1d2c \u21d8. A = (S \u21d8. A)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem derivBot_nearLitters {\u03b1 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u22a5) :\n    S\u1d3a \u21d8. A = (S \u21d8. A)\u1d3a :=\n  rfl\n\ntheorem ext' {S T : Support \u03b1} (h\u2081 : S\u1d2c = T\u1d2c) (h\u2082 : S\u1d3a = T\u1d3a) : S = T := by\n  obtain \u27e8SA, SN\u27e9 := S\n  obtain \u27e8TA, TN\u27e9 := T\n  cases h\u2081\n  cases h\u2082\n  rfl\n\n@[ext]\ntheorem ext {S T : Support \u03b1} (h : \u2200 A, S \u21d8. A = T \u21d8. A) : S = T := by\n  obtain \u27e8SA, SN\u27e9 := S\n  obtain \u27e8TA, TN\u27e9 := T\n  rw [mk.injEq]\n  constructor\n  \u00b7 apply Enumeration.ext_path\n    intro A\n    exact BaseSupport.atoms_congr (h A)\n  \u00b7 apply Enumeration.ext_path\n    intro A\n    exact BaseSupport.nearLitters_congr (h A)\n\n@[simp]\ntheorem deriv_derivBot {\u03b1 : TypeIndex} (S : Support \u03b1)\n    (A : \u03b1 \u219d \u03b2) (B : \u03b2 \u219d \u22a5) :\n    S \u21d8 A \u21d8. B = S \u21d8. (A \u21d8 B) :=\n  rfl\n\n@[simp]\ntheorem coderiv_deriv_eq {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    S \u21d7 A \u21d8 A = S :=\n  ext' (S\u1d2c.coderiv_deriv_eq A) (S\u1d3a.coderiv_deriv_eq A)\n\ntheorem eq_of_atom_mem_scoderiv_botDeriv {\u03b1 \u03b2 : TypeIndex} {S : Support \u03b2} {A : \u03b1 \u219d \u22a5}\n    {h : \u03b2 < \u03b1} {a : Atom} (ha : a \u2208 (S \u2197 h \u21d8. A)\u1d2c) :\n    \u2203 B : \u03b2 \u219d \u22a5, A = B \u2197 h :=\n  Enumeration.eq_of_mem_scoderiv_botDeriv ha\n\ntheorem eq_of_nearLitter_mem_scoderiv_botDeriv {\u03b1 \u03b2 : TypeIndex} {S : Support \u03b2} {A : \u03b1 \u219d \u22a5}\n    {h : \u03b2 < \u03b1} {N : NearLitter} (hN : N \u2208 (S \u2197 h \u21d8. A)\u1d3a) :\n    \u2203 B : \u03b2 \u219d \u22a5, A = B \u2197 h :=\n  Enumeration.eq_of_mem_scoderiv_botDeriv hN\n\n@[simp]\ntheorem scoderiv_botDeriv_eq {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (A : \u03b2 \u219d \u22a5) (h : \u03b2 < \u03b1) :\n    S \u2197 h \u21d8. (A \u2197 h) = S \u21d8. A :=\n  BaseSupport.ext (Enumeration.scoderiv_botDeriv_eq _ _ _) (Enumeration.scoderiv_botDeriv_eq _ _ _)\n\n@[simp]\ntheorem scoderiv_deriv_eq {\u03b1 \u03b2 \u03b3 : TypeIndex} (S : Support \u03b2) (A : \u03b2 \u219d \u03b3) (h : \u03b2 < \u03b1) :\n    S \u2197 h \u21d8 (A \u2197 h) = S \u21d8 A := by\n  apply ext\n  intro B\n  simp only [deriv_derivBot, \u2190 scoderiv_botDeriv_eq S (A \u21d8 B) h, Path.coderiv_deriv']\n\n@[simp]\ntheorem coderiv_inj {\u03b1 \u03b2 : TypeIndex} (S T : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    S \u21d7 A = T \u21d7 A \u2194 S = T := by\n  constructor\n  swap\n  \u00b7 rintro rfl\n    rfl\n  intro h\n  ext B : 1\n  have : S \u21d7 A \u21d8 A \u21d8. B = T \u21d7 A \u21d8 A \u21d8. B := by rw [h]\n  rwa [coderiv_deriv_eq, coderiv_deriv_eq] at this\n\n@[simp]\ntheorem scoderiv_inj {\u03b1 \u03b2 : TypeIndex} (S T : Support \u03b2) (h : \u03b2 < \u03b1) :\n    S \u2197 h = T \u2197 h \u2194 S = T :=\n  coderiv_inj S T (.single h)\n\ninstance {\u03b1 : TypeIndex} : SMul (StrPerm \u03b1) (Support \u03b1) where\n  smul \u03c0 S := \u27e8\u03c0 \u2022 S\u1d2c, \u03c0 \u2022 S\u1d3a\u27e9\n\n@[simp]\ntheorem smul_atoms {\u03b1 : TypeIndex} (\u03c0 : StrPerm \u03b1) (S : Support \u03b1) :\n    (\u03c0 \u2022 S)\u1d2c = \u03c0 \u2022 S\u1d2c :=\n  rfl\n\n@[simp]\ntheorem smul_nearLitters {\u03b1 : TypeIndex} (\u03c0 : StrPerm \u03b1) (S : Support \u03b1) :\n    (\u03c0 \u2022 S)\u1d3a = \u03c0 \u2022 S\u1d3a :=\n  rfl\n\ntheorem smul_atoms_eq_of_smul_eq {\u03b1 : TypeIndex} {\u03c0 : StrPerm \u03b1} {S : Support \u03b1}\n    (h : \u03c0 \u2022 S = S) :\n    \u03c0 \u2022 S\u1d2c = S\u1d2c := by\n  rw [\u2190 smul_atoms, h]\n\ntheorem smul_nearLitters_eq_of_smul_eq {\u03b1 : TypeIndex} {\u03c0 : StrPerm \u03b1} {S : Support \u03b1}\n    (h : \u03c0 \u2022 S = S) :\n    \u03c0 \u2022 S\u1d3a = S\u1d3a := by\n  rw [\u2190 smul_nearLitters, h]\n\ninstance {\u03b1 : TypeIndex} : MulAction (StrPerm \u03b1) (Support \u03b1) where\n  one_smul S := by\n    apply ext'\n    \u00b7 rw [smul_atoms, one_smul]\n    \u00b7 rw [smul_nearLitters, one_smul]\n  mul_smul \u03c0\u2081 \u03c0\u2082 S := by\n    apply ext'\n    \u00b7 rw [smul_atoms, smul_atoms, smul_atoms, mul_smul]\n    \u00b7 rw [smul_nearLitters, smul_nearLitters, smul_nearLitters, mul_smul]\n\n@[simp]\ntheorem smul_derivBot {\u03b1 : TypeIndex} (\u03c0 : StrPerm \u03b1) (S : Support \u03b1) (A : \u03b1 \u219d \u22a5) :\n    (\u03c0 \u2022 S) \u21d8. A = \u03c0 A \u2022 (S \u21d8. A) :=\n  rfl\n\ntheorem smul_coderiv {\u03b1 : TypeIndex} (\u03c0 : StrPerm \u03b1) (S : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    \u03c0 \u2022 S \u21d7 A = (\u03c0 \u21d8 A \u2022 S) \u21d7 A := by\n  ext B i x\n  \u00b7 rfl\n  \u00b7 constructor\n    \u00b7 rintro \u27e8\u27e8C, x\u27e9, hS, hx\u27e9\n      simp only [Prod.mk.injEq] at hx\n      obtain \u27e8rfl, rfl\u27e9 := hx\n      exact \u27e8\u27e8C, x\u27e9, hS, rfl\u27e9\n    \u00b7 rintro \u27e8\u27e8C, x\u27e9, hS, hx\u27e9\n      simp only [Prod.mk.injEq] at hx\n      obtain \u27e8rfl, rfl\u27e9 := hx\n      exact \u27e8\u27e8C, _\u27e9, hS, rfl\u27e9\n  \u00b7 rfl\n  \u00b7 constructor\n    \u00b7 rintro \u27e8\u27e8C, x\u27e9, hS, hx\u27e9\n      simp only [Prod.mk.injEq] at hx\n      obtain \u27e8rfl, rfl\u27e9 := hx\n      exact \u27e8\u27e8C, x\u27e9, hS, rfl\u27e9\n    \u00b7 rintro \u27e8\u27e8C, a\u27e9, hS, hx\u27e9\n      simp only [Prod.mk.injEq] at hx\n      obtain \u27e8rfl, rfl\u27e9 := hx\n      exact \u27e8\u27e8C, _\u27e9, hS, rfl\u27e9\n\ntheorem smul_scoderiv {\u03b1 : TypeIndex} (\u03c0 : StrPerm \u03b1) (S : Support \u03b2) (h : \u03b2 < \u03b1) :\n    \u03c0 \u2022 S \u2197 h = (\u03c0 \u2198 h \u2022 S) \u2197 h :=\n  smul_coderiv \u03c0 S (Path.single h)\n\ntheorem smul_eq_smul_iff (\u03c0\u2081 \u03c0\u2082 : StrPerm \u03b2) (S : Support \u03b2) :\n    \u03c0\u2081 \u2022 S = \u03c0\u2082 \u2022 S \u2194\n      \u2200 A, (\u2200 a \u2208 (S \u21d8. A)\u1d2c, \u03c0\u2081 A \u2022 a = \u03c0\u2082 A \u2022 a) \u2227 (\u2200 N \u2208 (S \u21d8. A)\u1d3a, \u03c0\u2081 A \u2022 N = \u03c0\u2082 A \u2022 N) := by\n  constructor\n  \u00b7 intro h A\n    have := congr_arg (\u00b7 \u21d8. A) h\n    simp only [smul_derivBot, BaseSupport.smul_eq_smul_iff] at this\n    exact this\n  \u00b7 intro h\n    apply ext\n    intro A\n    simp only [smul_derivBot, BaseSupport.smul_eq_smul_iff]\n    exact h A\n\ntheorem smul_eq_iff (\u03c0 : StrPerm \u03b2) (S : Support \u03b2) :\n    \u03c0 \u2022 S = S \u2194 \u2200 A, (\u2200 a \u2208 (S \u21d8. A)\u1d2c, \u03c0 A \u2022 a = a) \u2227 (\u2200 N \u2208 (S \u21d8. A)\u1d3a, \u03c0 A \u2022 N = N) := by\n  have := smul_eq_smul_iff \u03c0 1 S\n  simp only [one_smul, Tree.one_apply] at this\n  exact this\n\nnoncomputable instance : Add (Support \u03b1) where\n  add S T := \u27e8S\u1d2c + T\u1d2c, S\u1d3a + T\u1d3a\u27e9\n\n@[simp]\ntheorem add_derivBot (S T : Support \u03b1) (A : \u03b1 \u219d \u22a5) :\n    (S + T) \u21d8. A = (S \u21d8. A) + (T \u21d8. A) :=\n  rfl\n\ntheorem smul_add (S T : Support \u03b1) (\u03c0 : StrPerm \u03b1) :\n    \u03c0 \u2022 (S + T) = \u03c0 \u2022 S + \u03c0 \u2022 T :=\n  rfl\n\ntheorem add_inj_of_bound_eq_bound {S T U V : Support \u03b1}\n    (ha : S\u1d2c.bound = T\u1d2c.bound) (hN : S\u1d3a.bound = T\u1d3a.bound)\n    (h' : S + U = T + V) : S = T \u2227 U = V := by\n  have ha' := Enumeration.add_inj_of_bound_eq_bound ha (congr_arg (\u00b7\u1d2c) h')\n  have hN' := Enumeration.add_inj_of_bound_eq_bound hN (congr_arg (\u00b7\u1d3a) h')\n  constructor\n  \u00b7 exact Support.ext' ha'.1 hN'.1\n  \u00b7 exact Support.ext' ha'.2 hN'.2\n\nend Support\n\ndef supportEquiv {\u03b1 : TypeIndex} : Support \u03b1 \u2243\n    Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom) \u00d7 Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter) where\n  toFun S := (S\u1d2c, S\u1d3a)\n  invFun S := \u27e8S.1, S.2\u27e9\n  left_inv _ := rfl\n  right_inv _ := rfl\n\ntheorem card_support {\u03b1 : TypeIndex} : #(Support \u03b1) = #\u03bc := by\n  rw [Cardinal.eq.mpr \u27e8supportEquiv\u27e9, mk_prod, lift_id, lift_id,\n    card_enumeration_eq, card_enumeration_eq, mul_eq_self aleph0_lt_\u03bc.le]\n  \u00b7 rw [mk_prod, lift_id, lift_id, card_nearLitter,\n      mul_eq_right aleph0_lt_\u03bc.le (card_path_lt' \u03b1 \u22a5).le (card_path_ne_zero \u03b1)]\n  \u00b7 rw [mk_prod, lift_id, lift_id, card_atom,\n      mul_eq_right aleph0_lt_\u03bc.le (card_path_lt' \u03b1 \u22a5).le (card_path_ne_zero \u03b1)]\n\n/-!\n## Orders on supports\n-/\n\n-- TODO: Is this order used?\ninstance : LE BaseSupport where\n  le S T := (\u2200 a \u2208 S\u1d2c, a \u2208 T\u1d2c) \u2227 (\u2200 N \u2208 S\u1d3a, N \u2208 T\u1d3a)\n\ninstance : Preorder BaseSupport where\n  le_refl S := \u27e8\u03bb _ \u21a6 id, \u03bb _ \u21a6 id\u27e9\n  le_trans S T U h\u2081 h\u2082 := \u27e8\u03bb a h \u21a6 h\u2082.1 _ (h\u2081.1 a h), \u03bb N h \u21a6 h\u2082.2 _ (h\u2081.2 N h)\u27e9\n\ntheorem BaseSupport.smul_le_smul {S T : BaseSupport} (h : S \u2264 T) (\u03c0 : BasePerm) :\n    \u03c0 \u2022 S \u2264 \u03c0 \u2022 T := by\n  constructor\n  \u00b7 intro a\n    exact h.1 (\u03c0\u207b\u00b9 \u2022 a)\n  \u00b7 intro N\n    exact h.2 (\u03c0\u207b\u00b9 \u2022 N)\n\ntheorem BaseSupport.le_add_right {S T : BaseSupport} :\n    S \u2264 S + T := by\n  constructor\n  \u00b7 intro a ha\n    simp only [Support.add_derivBot, BaseSupport.add_atoms, Enumeration.mem_add_iff]\n    exact Or.inl ha\n  \u00b7 intro N hN\n    simp only [Support.add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n    exact Or.inl hN\n\n", "theoremStatement": "theorem BaseSupport.le_add_left {S T : BaseSupport} :\n    S \u2264 T + S ", "theoremName": "ConNF.BaseSupport.le_add_left", "fileCreated": {"commit": "39c33b4a743bea62dbcc549548b712ffd38ca65c", "date": "2024-12-05"}, "theoremCreated": {"commit": "251ac752f844dfde539ac2bd3ff112305ad59139", "date": "2024-11-30"}, "file": "ConNF/ConNF/ModelData/Support.lean", "module": "ConNF.ModelData.Support", "jsonFile": "ConNF.ModelData.Support.jsonl", "positionMetadata": {"lineInFile": 487, "tokenPositionInFile": 13576, "theoremPositionInFile": 51}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 5, "repositoryPremises": true, "numRepositoryPremises": 14, "numPremises": 25}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  constructor\n  \u00b7 intro a ha\n    simp only [add_atoms, Enumeration.mem_add_iff]\n    exact Or.inr ha\n  \u00b7 intro N hN\n    simp only [add_nearLitters, Enumeration.mem_add_iff]\n    exact Or.inr hN", "proofType": "tactic", "proofLengthLines": 7, "proofLengthTokens": 197}}
{"srcContext": "import ConNF.ModelData.PathEnumeration\n\n/-!\n# Supports\n\nIn this file, we define the notion of a support.\n\n## Main declarations\n\n* `ConNF.BaseSupport`: The type of supports of atoms.\n* `ConNF.Support`: The type of supports of objects of arbitrary type indices.\n-/\n\nuniverse u\n\nopen Cardinal\n\nnamespace ConNF\n\nvariable [Params.{u}]\n\n/-!\n## Base supports\n-/\n\nstructure BaseSupport where\n  atoms : Enumeration Atom\n  nearLitters : Enumeration NearLitter\n\nnamespace BaseSupport\n\ninstance : SuperA BaseSupport (Enumeration Atom) where\n  superA := atoms\n\ninstance : SuperN BaseSupport (Enumeration NearLitter) where\n  superN := nearLitters\n\n@[simp]\ntheorem mk_atoms {a : Enumeration Atom} {N : Enumeration NearLitter} :\n    (BaseSupport.mk a N)\u1d2c = a :=\n  rfl\n\n@[simp]\ntheorem mk_nearLitters {a : Enumeration Atom} {N : Enumeration NearLitter} :\n    (BaseSupport.mk a N)\u1d3a = N :=\n  rfl\n\ntheorem atoms_congr {S T : BaseSupport} (h : S = T) :\n    S\u1d2c = T\u1d2c :=\n  h \u25b8 rfl\n\ntheorem nearLitters_congr {S T : BaseSupport} (h : S = T) :\n    S\u1d3a = T\u1d3a :=\n  h \u25b8 rfl\n\n@[ext]\ntheorem ext {S T : BaseSupport} (h\u2081 : S\u1d2c = T\u1d2c) (h\u2082 : S\u1d3a = T\u1d3a) : S = T := by\n  obtain \u27e8SA, SN\u27e9 := S\n  obtain \u27e8TA, TN\u27e9 := T\n  cases h\u2081\n  cases h\u2082\n  rfl\n\ninstance : SMul BasePerm BaseSupport where\n  smul \u03c0 S := \u27e8\u03c0 \u2022 S\u1d2c, \u03c0 \u2022 S\u1d3a\u27e9\n\n@[simp]\ntheorem smul_atoms (\u03c0 : BasePerm) (S : BaseSupport) :\n    (\u03c0 \u2022 S)\u1d2c = \u03c0 \u2022 S\u1d2c :=\n  rfl\n\n@[simp]\ntheorem smul_nearLitters (\u03c0 : BasePerm) (S : BaseSupport) :\n    (\u03c0 \u2022 S)\u1d3a = \u03c0 \u2022 S\u1d3a :=\n  rfl\n\n@[simp]\ntheorem smul_atoms_eq_of_smul_eq {\u03c0 : BasePerm} {S : BaseSupport}\n    (h : \u03c0 \u2022 S = S) :\n    \u03c0 \u2022 S\u1d2c = S\u1d2c := by\n  rw [\u2190 smul_atoms, h]\n\n@[simp]\ntheorem smul_nearLitters_eq_of_smul_eq {\u03c0 : BasePerm} {S : BaseSupport}\n    (h : \u03c0 \u2022 S = S) :\n    \u03c0 \u2022 S\u1d3a = S\u1d3a := by\n  rw [\u2190 smul_nearLitters, h]\n\ninstance : MulAction BasePerm BaseSupport where\n  one_smul S := by\n    apply ext\n    \u00b7 rw [smul_atoms, one_smul]\n    \u00b7 rw [smul_nearLitters, one_smul]\n  mul_smul \u03c0\u2081 \u03c0\u2082 S := by\n    apply ext\n    \u00b7 rw [smul_atoms, smul_atoms, smul_atoms, mul_smul]\n    \u00b7 rw [smul_nearLitters, smul_nearLitters, smul_nearLitters, mul_smul]\n\ntheorem smul_eq_smul_iff (\u03c0\u2081 \u03c0\u2082 : BasePerm) (S : BaseSupport) :\n    \u03c0\u2081 \u2022 S = \u03c0\u2082 \u2022 S \u2194 (\u2200 a \u2208 S\u1d2c, \u03c0\u2081 \u2022 a = \u03c0\u2082 \u2022 a) \u2227 (\u2200 N \u2208 S\u1d3a, \u03c0\u2081 \u2022 N = \u03c0\u2082 \u2022 N) := by\n  constructor\n  \u00b7 intro h\n    constructor\n    \u00b7 rintro a \u27e8i, ha\u27e9\n      have := congr_arg (\u00b7\u1d2c.rel i (\u03c0\u2081 \u2022 a)) h\n      simp only [smul_atoms, Enumeration.smul_rel, inv_smul_smul, eq_iff_iff] at this\n      have := S\u1d2c.rel_coinjective.coinjective ha (this.mp ha)\n      rw [eq_inv_smul_iff] at this\n      rw [this]\n    \u00b7 rintro N \u27e8i, hN\u27e9\n      have := congr_arg (\u00b7\u1d3a.rel i (\u03c0\u2081 \u2022 N)) h\n      simp only [smul_nearLitters, Enumeration.smul_rel, inv_smul_smul, eq_iff_iff] at this\n      have := S\u1d3a.rel_coinjective.coinjective hN (this.mp hN)\n      rw [eq_inv_smul_iff] at this\n      rw [this]\n  \u00b7 intro h\n    ext : 2\n    \u00b7 rfl\n    \u00b7 ext i a : 3\n      rw [smul_atoms, smul_atoms, Enumeration.smul_rel, Enumeration.smul_rel]\n      constructor\n      \u00b7 intro ha\n        have := h.1 _ \u27e8i, ha\u27e9\n        rw [smul_inv_smul, \u2190 inv_smul_eq_iff] at this\n        rwa [this]\n      \u00b7 intro ha\n        have := h.1 _ \u27e8i, ha\u27e9\n        rw [smul_inv_smul, smul_eq_iff_eq_inv_smul] at this\n        rwa [\u2190 this]\n    \u00b7 rfl\n    \u00b7 ext i a : 3\n      rw [smul_nearLitters, smul_nearLitters, Enumeration.smul_rel, Enumeration.smul_rel]\n      constructor\n      \u00b7 intro hN\n        have := h.2 _ \u27e8i, hN\u27e9\n        rw [smul_inv_smul, \u2190 inv_smul_eq_iff] at this\n        rwa [this]\n      \u00b7 intro hN\n        have := h.2 _ \u27e8i, hN\u27e9\n        rw [smul_inv_smul, smul_eq_iff_eq_inv_smul] at this\n        rwa [\u2190 this]\n\ntheorem smul_eq_iff (\u03c0 : BasePerm) (S : BaseSupport) :\n    \u03c0 \u2022 S = S \u2194 (\u2200 a \u2208 S\u1d2c, \u03c0 \u2022 a = a) \u2227 (\u2200 N \u2208 S\u1d3a, \u03c0 \u2022 N = N) := by\n  have := smul_eq_smul_iff \u03c0 1 S\n  simp only [one_smul] at this\n  exact this\n\nnoncomputable instance : Add BaseSupport where\n  add S T := \u27e8S\u1d2c + T\u1d2c, S\u1d3a + T\u1d3a\u27e9\n\n@[simp]\ntheorem add_atoms (S T : BaseSupport) :\n    (S + T)\u1d2c = S\u1d2c + T\u1d2c :=\n  rfl\n\n@[simp]\ntheorem add_nearLitters (S T : BaseSupport) :\n    (S + T)\u1d3a = S\u1d3a + T\u1d3a :=\n  rfl\n\nend BaseSupport\n\ndef baseSupportEquiv : BaseSupport \u2243 Enumeration Atom \u00d7 Enumeration NearLitter where\n  toFun S := (S\u1d2c, S\u1d3a)\n  invFun S := \u27e8S.1, S.2\u27e9\n  left_inv _ := rfl\n  right_inv _ := rfl\n\ntheorem card_baseSupport : #BaseSupport = #\u03bc := by\n  rw [Cardinal.eq.mpr \u27e8baseSupportEquiv\u27e9, mk_prod, lift_id, lift_id,\n    card_enumeration_eq card_atom, card_enumeration_eq card_nearLitter, mul_eq_self aleph0_lt_\u03bc.le]\n\n/-!\n## Structural supports\n-/\n\nstructure Support (\u03b1 : TypeIndex) where\n  atoms : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)\n  nearLitters : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)\n\nnamespace Support\n\nvariable {\u03b1 \u03b2 : TypeIndex}\n\ninstance : SuperA (Support \u03b1) (Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) where\n  superA := atoms\n\ninstance : SuperN (Support \u03b1) (Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) where\n  superN := nearLitters\n\n@[simp]\ntheorem mk_atoms (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) (F : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) :\n    (\u27e8E, F\u27e9 : Support \u03b1)\u1d2c = E :=\n  rfl\n\n@[simp]\ntheorem mk_nearLitters (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) (F : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) :\n    (\u27e8E, F\u27e9 : Support \u03b1)\u1d3a = F :=\n  rfl\n\ninstance : Derivative (Support \u03b1) (Support \u03b2) \u03b1 \u03b2 where\n  deriv S A := \u27e8S\u1d2c \u21d8 A, S\u1d3a \u21d8 A\u27e9\n\ninstance : Coderivative (Support \u03b2) (Support \u03b1) \u03b1 \u03b2 where\n  coderiv S A := \u27e8S\u1d2c \u21d7 A, S\u1d3a \u21d7 A\u27e9\n\ninstance : BotDerivative (Support \u03b1) BaseSupport \u03b1 where\n  botDeriv S A := \u27e8S\u1d2c \u21d8. A, S\u1d3a \u21d8. A\u27e9\n  botSderiv S := \u27e8S\u1d2c \u2198., S\u1d3a \u2198.\u27e9\n  botDeriv_single S h := by dsimp only; rw [botDeriv_single, botDeriv_single]\n\n@[simp]\ntheorem deriv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u03b2) :\n    S\u1d2c \u21d8 A = (S \u21d8 A)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem deriv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u03b2) :\n    S\u1d3a \u21d8 A = (S \u21d8 A)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem sderiv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (h : \u03b2 < \u03b1) :\n    S\u1d2c \u2198 h = (S \u2198 h)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem sderiv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (h : \u03b2 < \u03b1) :\n    S\u1d3a \u2198 h = (S \u2198 h)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem coderiv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    S\u1d2c \u21d7 A = (S \u21d7 A)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem coderiv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    S\u1d3a \u21d7 A = (S \u21d7 A)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem scoderiv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (h : \u03b2 < \u03b1) :\n    S\u1d2c \u2197 h = (S \u2197 h)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem scoderiv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (h : \u03b2 < \u03b1) :\n    S\u1d3a \u2197 h = (S \u2197 h)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem derivBot_atoms {\u03b1 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u22a5) :\n    S\u1d2c \u21d8. A = (S \u21d8. A)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem derivBot_nearLitters {\u03b1 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u22a5) :\n    S\u1d3a \u21d8. A = (S \u21d8. A)\u1d3a :=\n  rfl\n\ntheorem ext' {S T : Support \u03b1} (h\u2081 : S\u1d2c = T\u1d2c) (h\u2082 : S\u1d3a = T\u1d3a) : S = T := by\n  obtain \u27e8SA, SN\u27e9 := S\n  obtain \u27e8TA, TN\u27e9 := T\n  cases h\u2081\n  cases h\u2082\n  rfl\n\n@[ext]\ntheorem ext {S T : Support \u03b1} (h : \u2200 A, S \u21d8. A = T \u21d8. A) : S = T := by\n  obtain \u27e8SA, SN\u27e9 := S\n  obtain \u27e8TA, TN\u27e9 := T\n  rw [mk.injEq]\n  constructor\n  \u00b7 apply Enumeration.ext_path\n    intro A\n    exact BaseSupport.atoms_congr (h A)\n  \u00b7 apply Enumeration.ext_path\n    intro A\n    exact BaseSupport.nearLitters_congr (h A)\n\n@[simp]\ntheorem deriv_derivBot {\u03b1 : TypeIndex} (S : Support \u03b1)\n    (A : \u03b1 \u219d \u03b2) (B : \u03b2 \u219d \u22a5) :\n    S \u21d8 A \u21d8. B = S \u21d8. (A \u21d8 B) :=\n  rfl\n\n@[simp]\ntheorem coderiv_deriv_eq {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    S \u21d7 A \u21d8 A = S :=\n  ext' (S\u1d2c.coderiv_deriv_eq A) (S\u1d3a.coderiv_deriv_eq A)\n\ntheorem eq_of_atom_mem_scoderiv_botDeriv {\u03b1 \u03b2 : TypeIndex} {S : Support \u03b2} {A : \u03b1 \u219d \u22a5}\n    {h : \u03b2 < \u03b1} {a : Atom} (ha : a \u2208 (S \u2197 h \u21d8. A)\u1d2c) :\n    \u2203 B : \u03b2 \u219d \u22a5, A = B \u2197 h :=\n  Enumeration.eq_of_mem_scoderiv_botDeriv ha\n\ntheorem eq_of_nearLitter_mem_scoderiv_botDeriv {\u03b1 \u03b2 : TypeIndex} {S : Support \u03b2} {A : \u03b1 \u219d \u22a5}\n    {h : \u03b2 < \u03b1} {N : NearLitter} (hN : N \u2208 (S \u2197 h \u21d8. A)\u1d3a) :\n    \u2203 B : \u03b2 \u219d \u22a5, A = B \u2197 h :=\n  Enumeration.eq_of_mem_scoderiv_botDeriv hN\n\n@[simp]\ntheorem scoderiv_botDeriv_eq {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (A : \u03b2 \u219d \u22a5) (h : \u03b2 < \u03b1) :\n    S \u2197 h \u21d8. (A \u2197 h) = S \u21d8. A :=\n  BaseSupport.ext (Enumeration.scoderiv_botDeriv_eq _ _ _) (Enumeration.scoderiv_botDeriv_eq _ _ _)\n\n@[simp]\ntheorem scoderiv_deriv_eq {\u03b1 \u03b2 \u03b3 : TypeIndex} (S : Support \u03b2) (A : \u03b2 \u219d \u03b3) (h : \u03b2 < \u03b1) :\n    S \u2197 h \u21d8 (A \u2197 h) = S \u21d8 A := by\n  apply ext\n  intro B\n  simp only [deriv_derivBot, \u2190 scoderiv_botDeriv_eq S (A \u21d8 B) h, Path.coderiv_deriv']\n\n@[simp]\ntheorem coderiv_inj {\u03b1 \u03b2 : TypeIndex} (S T : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    S \u21d7 A = T \u21d7 A \u2194 S = T := by\n  constructor\n  swap\n  \u00b7 rintro rfl\n    rfl\n  intro h\n  ext B : 1\n  have : S \u21d7 A \u21d8 A \u21d8. B = T \u21d7 A \u21d8 A \u21d8. B := by rw [h]\n  rwa [coderiv_deriv_eq, coderiv_deriv_eq] at this\n\n@[simp]\ntheorem scoderiv_inj {\u03b1 \u03b2 : TypeIndex} (S T : Support \u03b2) (h : \u03b2 < \u03b1) :\n    S \u2197 h = T \u2197 h \u2194 S = T :=\n  coderiv_inj S T (.single h)\n\ninstance {\u03b1 : TypeIndex} : SMul (StrPerm \u03b1) (Support \u03b1) where\n  smul \u03c0 S := \u27e8\u03c0 \u2022 S\u1d2c, \u03c0 \u2022 S\u1d3a\u27e9\n\n@[simp]\ntheorem smul_atoms {\u03b1 : TypeIndex} (\u03c0 : StrPerm \u03b1) (S : Support \u03b1) :\n    (\u03c0 \u2022 S)\u1d2c = \u03c0 \u2022 S\u1d2c :=\n  rfl\n\n@[simp]\ntheorem smul_nearLitters {\u03b1 : TypeIndex} (\u03c0 : StrPerm \u03b1) (S : Support \u03b1) :\n    (\u03c0 \u2022 S)\u1d3a = \u03c0 \u2022 S\u1d3a :=\n  rfl\n\ntheorem smul_atoms_eq_of_smul_eq {\u03b1 : TypeIndex} {\u03c0 : StrPerm \u03b1} {S : Support \u03b1}\n    (h : \u03c0 \u2022 S = S) :\n    \u03c0 \u2022 S\u1d2c = S\u1d2c := by\n  rw [\u2190 smul_atoms, h]\n\ntheorem smul_nearLitters_eq_of_smul_eq {\u03b1 : TypeIndex} {\u03c0 : StrPerm \u03b1} {S : Support \u03b1}\n    (h : \u03c0 \u2022 S = S) :\n    \u03c0 \u2022 S\u1d3a = S\u1d3a := by\n  rw [\u2190 smul_nearLitters, h]\n\ninstance {\u03b1 : TypeIndex} : MulAction (StrPerm \u03b1) (Support \u03b1) where\n  one_smul S := by\n    apply ext'\n    \u00b7 rw [smul_atoms, one_smul]\n    \u00b7 rw [smul_nearLitters, one_smul]\n  mul_smul \u03c0\u2081 \u03c0\u2082 S := by\n    apply ext'\n    \u00b7 rw [smul_atoms, smul_atoms, smul_atoms, mul_smul]\n    \u00b7 rw [smul_nearLitters, smul_nearLitters, smul_nearLitters, mul_smul]\n\n@[simp]\ntheorem smul_derivBot {\u03b1 : TypeIndex} (\u03c0 : StrPerm \u03b1) (S : Support \u03b1) (A : \u03b1 \u219d \u22a5) :\n    (\u03c0 \u2022 S) \u21d8. A = \u03c0 A \u2022 (S \u21d8. A) :=\n  rfl\n\ntheorem smul_coderiv {\u03b1 : TypeIndex} (\u03c0 : StrPerm \u03b1) (S : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    \u03c0 \u2022 S \u21d7 A = (\u03c0 \u21d8 A \u2022 S) \u21d7 A := by\n  ext B i x\n  \u00b7 rfl\n  \u00b7 constructor\n    \u00b7 rintro \u27e8\u27e8C, x\u27e9, hS, hx\u27e9\n      simp only [Prod.mk.injEq] at hx\n      obtain \u27e8rfl, rfl\u27e9 := hx\n      exact \u27e8\u27e8C, x\u27e9, hS, rfl\u27e9\n    \u00b7 rintro \u27e8\u27e8C, x\u27e9, hS, hx\u27e9\n      simp only [Prod.mk.injEq] at hx\n      obtain \u27e8rfl, rfl\u27e9 := hx\n      exact \u27e8\u27e8C, _\u27e9, hS, rfl\u27e9\n  \u00b7 rfl\n  \u00b7 constructor\n    \u00b7 rintro \u27e8\u27e8C, x\u27e9, hS, hx\u27e9\n      simp only [Prod.mk.injEq] at hx\n      obtain \u27e8rfl, rfl\u27e9 := hx\n      exact \u27e8\u27e8C, x\u27e9, hS, rfl\u27e9\n    \u00b7 rintro \u27e8\u27e8C, a\u27e9, hS, hx\u27e9\n      simp only [Prod.mk.injEq] at hx\n      obtain \u27e8rfl, rfl\u27e9 := hx\n      exact \u27e8\u27e8C, _\u27e9, hS, rfl\u27e9\n\ntheorem smul_scoderiv {\u03b1 : TypeIndex} (\u03c0 : StrPerm \u03b1) (S : Support \u03b2) (h : \u03b2 < \u03b1) :\n    \u03c0 \u2022 S \u2197 h = (\u03c0 \u2198 h \u2022 S) \u2197 h :=\n  smul_coderiv \u03c0 S (Path.single h)\n\ntheorem smul_eq_smul_iff (\u03c0\u2081 \u03c0\u2082 : StrPerm \u03b2) (S : Support \u03b2) :\n    \u03c0\u2081 \u2022 S = \u03c0\u2082 \u2022 S \u2194\n      \u2200 A, (\u2200 a \u2208 (S \u21d8. A)\u1d2c, \u03c0\u2081 A \u2022 a = \u03c0\u2082 A \u2022 a) \u2227 (\u2200 N \u2208 (S \u21d8. A)\u1d3a, \u03c0\u2081 A \u2022 N = \u03c0\u2082 A \u2022 N) := by\n  constructor\n  \u00b7 intro h A\n    have := congr_arg (\u00b7 \u21d8. A) h\n    simp only [smul_derivBot, BaseSupport.smul_eq_smul_iff] at this\n    exact this\n  \u00b7 intro h\n    apply ext\n    intro A\n    simp only [smul_derivBot, BaseSupport.smul_eq_smul_iff]\n    exact h A\n\ntheorem smul_eq_iff (\u03c0 : StrPerm \u03b2) (S : Support \u03b2) :\n    \u03c0 \u2022 S = S \u2194 \u2200 A, (\u2200 a \u2208 (S \u21d8. A)\u1d2c, \u03c0 A \u2022 a = a) \u2227 (\u2200 N \u2208 (S \u21d8. A)\u1d3a, \u03c0 A \u2022 N = N) := by\n  have := smul_eq_smul_iff \u03c0 1 S\n  simp only [one_smul, Tree.one_apply] at this\n  exact this\n\nnoncomputable instance : Add (Support \u03b1) where\n  add S T := \u27e8S\u1d2c + T\u1d2c, S\u1d3a + T\u1d3a\u27e9\n\n@[simp]\ntheorem add_derivBot (S T : Support \u03b1) (A : \u03b1 \u219d \u22a5) :\n    (S + T) \u21d8. A = (S \u21d8. A) + (T \u21d8. A) :=\n  rfl\n\ntheorem smul_add (S T : Support \u03b1) (\u03c0 : StrPerm \u03b1) :\n    \u03c0 \u2022 (S + T) = \u03c0 \u2022 S + \u03c0 \u2022 T :=\n  rfl\n\ntheorem add_inj_of_bound_eq_bound {S T U V : Support \u03b1}\n    (ha : S\u1d2c.bound = T\u1d2c.bound) (hN : S\u1d3a.bound = T\u1d3a.bound)\n    (h' : S + U = T + V) : S = T \u2227 U = V := by\n  have ha' := Enumeration.add_inj_of_bound_eq_bound ha (congr_arg (\u00b7\u1d2c) h')\n  have hN' := Enumeration.add_inj_of_bound_eq_bound hN (congr_arg (\u00b7\u1d3a) h')\n  constructor\n  \u00b7 exact Support.ext' ha'.1 hN'.1\n  \u00b7 exact Support.ext' ha'.2 hN'.2\n\nend Support\n\ndef supportEquiv {\u03b1 : TypeIndex} : Support \u03b1 \u2243\n    Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom) \u00d7 Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter) where\n  toFun S := (S\u1d2c, S\u1d3a)\n  invFun S := \u27e8S.1, S.2\u27e9\n  left_inv _ := rfl\n  right_inv _ := rfl\n\ntheorem card_support {\u03b1 : TypeIndex} : #(Support \u03b1) = #\u03bc := by\n  rw [Cardinal.eq.mpr \u27e8supportEquiv\u27e9, mk_prod, lift_id, lift_id,\n    card_enumeration_eq, card_enumeration_eq, mul_eq_self aleph0_lt_\u03bc.le]\n  \u00b7 rw [mk_prod, lift_id, lift_id, card_nearLitter,\n      mul_eq_right aleph0_lt_\u03bc.le (card_path_lt' \u03b1 \u22a5).le (card_path_ne_zero \u03b1)]\n  \u00b7 rw [mk_prod, lift_id, lift_id, card_atom,\n      mul_eq_right aleph0_lt_\u03bc.le (card_path_lt' \u03b1 \u22a5).le (card_path_ne_zero \u03b1)]\n\n/-!\n## Orders on supports\n-/\n\n-- TODO: Is this order used?\ninstance : LE BaseSupport where\n  le S T := (\u2200 a \u2208 S\u1d2c, a \u2208 T\u1d2c) \u2227 (\u2200 N \u2208 S\u1d3a, N \u2208 T\u1d3a)\n\ninstance : Preorder BaseSupport where\n  le_refl S := \u27e8\u03bb _ \u21a6 id, \u03bb _ \u21a6 id\u27e9\n  le_trans S T U h\u2081 h\u2082 := \u27e8\u03bb a h \u21a6 h\u2082.1 _ (h\u2081.1 a h), \u03bb N h \u21a6 h\u2082.2 _ (h\u2081.2 N h)\u27e9\n\ntheorem BaseSupport.smul_le_smul {S T : BaseSupport} (h : S \u2264 T) (\u03c0 : BasePerm) :\n    \u03c0 \u2022 S \u2264 \u03c0 \u2022 T := by\n  constructor\n  \u00b7 intro a\n    exact h.1 (\u03c0\u207b\u00b9 \u2022 a)\n  \u00b7 intro N\n    exact h.2 (\u03c0\u207b\u00b9 \u2022 N)\n\n", "theoremStatement": "theorem BaseSupport.le_add_right {S T : BaseSupport} :\n    S \u2264 S + T ", "theoremName": "ConNF.BaseSupport.le_add_right", "fileCreated": {"commit": "39c33b4a743bea62dbcc549548b712ffd38ca65c", "date": "2024-12-05"}, "theoremCreated": {"commit": "251ac752f844dfde539ac2bd3ff112305ad59139", "date": "2024-11-30"}, "file": "ConNF/ConNF/ModelData/Support.lean", "module": "ConNF.ModelData.Support", "jsonFile": "ConNF.ModelData.Support.jsonl", "positionMetadata": {"lineInFile": 477, "tokenPositionInFile": 13240, "theoremPositionInFile": 50}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 5, "repositoryPremises": true, "numRepositoryPremises": 14, "numPremises": 25}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  constructor\n  \u00b7 intro a ha\n    simp only [Support.add_derivBot, BaseSupport.add_atoms, Enumeration.mem_add_iff]\n    exact Or.inl ha\n  \u00b7 intro N hN\n    simp only [Support.add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n    exact Or.inl hN", "proofType": "tactic", "proofLengthLines": 7, "proofLengthTokens": 265}}
{"srcContext": "import ConNF.External.Basic\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal ConNF.TSet\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\n/-- A set in our model that is a well-order. Internal well-orders are exactly external well-orders,\nso we externalise the definition for convenience. -/\ndef InternalWellOrder (r : TSet \u03b1) : Prop :=\n  IsWellOrder (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).field\n    (InvImage (ExternalRel h\u03b2 h\u03b3 h\u03b4 r) Subtype.val)\n\ndef InternallyWellOrdered (x : TSet \u03b3) : Prop :=\n  {y : TSet \u03b4 | y \u2208' x}.Subsingleton \u2228 (\u2203 r, InternalWellOrder h\u03b2 h\u03b3 h\u03b4 r \u2227 x = field h\u03b2 h\u03b3 h\u03b4 r)\n\n@[simp]\ntheorem externalRel_smul (r : TSet \u03b1) (\u03c1 : AllPerm \u03b1) :\n    ExternalRel h\u03b2 h\u03b3 h\u03b4 (\u03c1 \u2022 r) =\n      InvImage (ExternalRel h\u03b2 h\u03b3 h\u03b4 r) ((\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4)\u207b\u00b9 \u2022 \u00b7) := by\n  ext a b\n  simp only [ExternalRel, mem_smul_iff', allPerm_inv_sderiv', smul_op, InvImage]\n\nomit [Params] in\n/-- Well-orders are rigid. -/\ntheorem apply_eq_of_isWellOrder {X : Type _} {r : Rel X X} {f : X \u2192 X}\n    (hr : IsWellOrder X r) (hf : Function.Bijective f) (hf' : \u2200 x y, r x y \u2194 r (f x) (f y)) :\n    \u2200 x, f x = x := by\n  let emb : r \u227ci r := \u27e8\u27e8\u27e8f, hf.injective\u27e9, \u03bb {a b} \u21a6 (hf' a b).symm\u27e9, ?_\u27e9\n  \u00b7 have : emb = InitialSeg.refl r := Subsingleton.elim _ _\n    intro x\n    exact congr_arg (\u03bb f \u21a6 f x) this\n  \u00b7 intro a b h\n    exact hf.surjective _\n\nomit [Params] in\ntheorem apply_eq_of_isWellOrder' {X : Type _} {r : Rel X X} {f : X \u2192 X}\n    (hr : IsWellOrder r.field (InvImage r Subtype.val)) (hf : Function.Bijective f)\n    (hf' : \u2200 x y, r x y \u2194 r (f x) (f y)) :\n    \u2200 x \u2208 r.field, f x = x := by\n  have : \u2200 x \u2208 r.field, f x \u2208 r.field := by\n    rintro x (\u27e8y, h\u27e9 | \u27e8y, h\u27e9)\n    \u00b7 exact Or.inl \u27e8f y, (hf' x y).mp h\u27e9\n    \u00b7 exact Or.inr \u27e8f y, (hf' y x).mp h\u27e9\n  have := apply_eq_of_isWellOrder (f := \u03bb x \u21a6 \u27e8f x.val, this x.val x.prop\u27e9) hr \u27e8?_, ?_\u27e9 ?_\n  \u00b7 intro x hx\n    exact congr_arg Subtype.val (this \u27e8x, hx\u27e9)\n  \u00b7 intro x y h\n    rw [Subtype.mk.injEq] at h\n    exact Subtype.val_injective (hf.injective h)\n  \u00b7 intro x\n    obtain \u27e8y, hy\u27e9 := hf.surjective x.val\n    refine \u27e8\u27e8y, ?_\u27e9, ?_\u27e9\n    \u00b7 obtain (\u27e8z, h\u27e9 | \u27e8z, h\u27e9) := x.prop <;>\n          rw [\u2190 hy] at h <;>\n          obtain \u27e8z, rfl\u27e9 := hf.surjective z\n      \u00b7 exact Or.inl \u27e8z, (hf' y z).mpr h\u27e9\n      \u00b7 exact Or.inr \u27e8z, (hf' z y).mpr h\u27e9\n    \u00b7 simp only [hy]\n  \u00b7 intros\n    apply hf'\n\ntheorem exists_common_support_of_internallyWellOrdered' {x : TSet \u03b4}\n    (h : InternallyWellOrdered h\u03b3 h\u03b4 h\u03b5 x) :\n    \u2203 S : Support \u03b2, \u2200 y, y \u2208' x \u2192 S.Supports { { {y}' }' }[h\u03b3] := by\n  obtain (h | \u27e8r, h, rfl\u27e9) := h\n  \u00b7 obtain (h | \u27e8y, hy\u27e9) := h.eq_empty_or_singleton\n    \u00b7 use \u27e8Enumeration.empty, Enumeration.empty\u27e9\n      intro y hy\n      rw [Set.eq_empty_iff_forall_not_mem] at h\n      cases h y hy\n    \u00b7 obtain \u27e8S, hS\u27e9 := TSet.exists_support y\n      use S \u2197 h\u03b5 \u2197 h\u03b4 \u2197 h\u03b3\n      intro z hz\n      rw [Set.eq_singleton_iff_unique_mem] at hy\n      cases hy.2 z hz\n      refine \u27e8?_, \u03bb h \u21a6 by cases h\u27e9\n      intro \u03c1 h\u03c1\n      simp only [Support.smul_scoderiv, \u2190 allPermSderiv_forget', Support.scoderiv_inj] at h\u03c1\n      simp only [smul_singleton, singleton_inj]\n      exact hS _ h\u03c1\n  obtain \u27e8S, hS\u27e9 := TSet.exists_support r\n  use S\n  intro a ha\n  refine \u27e8?_, \u03bb h \u21a6 by cases h\u27e9\n  intro \u03c1 h\u03c1\n  have := hS \u03c1 h\u03c1\n  simp only [smul_singleton, singleton_inj]\n  apply apply_eq_of_isWellOrder' (r := ExternalRel h\u03b3 h\u03b4 h\u03b5 r)\n  \u00b7 exact h\n  \u00b7 exact MulAction.bijective (\u03c1 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5)\n  \u00b7 intro x y\n    conv_rhs => rw [\u2190 this]\n    simp only [externalRel_smul, InvImage, inv_smul_smul]\n  \u00b7 rwa [mem_field_iff] at ha\n\ninclude h\u03b3 in\n", "theoremStatement": "theorem Support.Supports.ofSingleton {S : Support \u03b1} {x : TSet \u03b2}\n    (h : S.Supports {x}') :\n    letI : Level := \u27e8\u03b1\u27e9\n    letI : LeLevel \u03b1 := \u27e8le_rfl\u27e9\n    (S.strong \u2198 h\u03b2).Supports x ", "theoremName": "ConNF.Support.Supports.ofSingleton", "fileCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "theoremCreated": {"commit": "1c08486feb882444888c228ce1501e92bb85e0e2", "date": "2025-01-07"}, "file": "ConNF/ConNF/External/WellOrder.lean", "module": "ConNF.External.WellOrder", "jsonFile": "ConNF.External.WellOrder.jsonl", "positionMetadata": {"lineInFile": 113, "tokenPositionInFile": 3749, "theoremPositionInFile": 6}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 43, "numPremises": 114}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  refine \u27e8?_, \u03bb h \u21a6 by cases h\u27e9\n  intro \u03c1 h\u03c1\n  open scoped Pointwise in\n  have := sUnion_singleton_symmetric_aux h\u03b3 h\u03b2 {y | y \u2208' x} S ?_ \u03c1 h\u03c1\n  \u00b7 apply ConNF.ext h\u03b3\n    intro z\n    simp only [Set.ext_iff, Set.mem_setOf_eq, Set.mem_smul_set_iff_inv_smul_mem] at this\n    rw [mem_smul_iff', allPerm_inv_sderiv', this]\n  \u00b7 intro \u03c1 h\u03c1\n    ext z\n    simp only [Set.mem_smul_set_iff_inv_smul_mem, Set.mem_image, Set.mem_setOf_eq]\n    have := h.supports \u03c1 h\u03c1\n    simp only [smul_singleton, singleton_inj] at this\n    constructor\n    \u00b7 rintro \u27e8y, h\u2081, h\u2082\u27e9\n      rw [\u2190 smul_eq_iff_eq_inv_smul, smul_singleton] at h\u2082\n      refine \u27e8_, ?_, h\u2082\u27e9\n      rw [\u2190 this]\n      simp only [mem_smul_iff', allPerm_inv_sderiv', inv_smul_smul]\n      exact h\u2081\n    \u00b7 rintro \u27e8y, h, rfl\u27e9\n      refine \u27e8(\u03c1 \u2198 h\u03b2 \u2198 h\u03b3)\u207b\u00b9 \u2022 y, ?_, ?_\u27e9\n      \u00b7 rwa [\u2190 allPerm_inv_sderiv', \u2190 mem_smul_iff', this]\n      \u00b7 simp only [smul_singleton, allPerm_inv_sderiv']", "proofType": "tactic", "proofLengthLines": 24, "proofLengthTokens": 920}}
{"srcContext": "import ConNF.ModelData.PathEnumeration\n\n/-!\n# Supports\n\nIn this file, we define the notion of a support.\n\n## Main declarations\n\n* `ConNF.BaseSupport`: The type of supports of atoms.\n* `ConNF.Support`: The type of supports of objects of arbitrary type indices.\n-/\n\nuniverse u\n\nopen Cardinal\n\nnamespace ConNF\n\nvariable [Params.{u}]\n\n/-!\n## Base supports\n-/\n\nstructure BaseSupport where\n  atoms : Enumeration Atom\n  nearLitters : Enumeration NearLitter\n\nnamespace BaseSupport\n\ninstance : SuperA BaseSupport (Enumeration Atom) where\n  superA := atoms\n\ninstance : SuperN BaseSupport (Enumeration NearLitter) where\n  superN := nearLitters\n\n@[simp]\ntheorem mk_atoms {a : Enumeration Atom} {N : Enumeration NearLitter} :\n    (BaseSupport.mk a N)\u1d2c = a :=\n  rfl\n\n@[simp]\ntheorem mk_nearLitters {a : Enumeration Atom} {N : Enumeration NearLitter} :\n    (BaseSupport.mk a N)\u1d3a = N :=\n  rfl\n\ntheorem atoms_congr {S T : BaseSupport} (h : S = T) :\n    S\u1d2c = T\u1d2c :=\n  h \u25b8 rfl\n\ntheorem nearLitters_congr {S T : BaseSupport} (h : S = T) :\n    S\u1d3a = T\u1d3a :=\n  h \u25b8 rfl\n\n@[ext]\ntheorem ext {S T : BaseSupport} (h\u2081 : S\u1d2c = T\u1d2c) (h\u2082 : S\u1d3a = T\u1d3a) : S = T := by\n  obtain \u27e8SA, SN\u27e9 := S\n  obtain \u27e8TA, TN\u27e9 := T\n  cases h\u2081\n  cases h\u2082\n  rfl\n\ninstance : SMul BasePerm BaseSupport where\n  smul \u03c0 S := \u27e8\u03c0 \u2022 S\u1d2c, \u03c0 \u2022 S\u1d3a\u27e9\n\n@[simp]\ntheorem smul_atoms (\u03c0 : BasePerm) (S : BaseSupport) :\n    (\u03c0 \u2022 S)\u1d2c = \u03c0 \u2022 S\u1d2c :=\n  rfl\n\n@[simp]\ntheorem smul_nearLitters (\u03c0 : BasePerm) (S : BaseSupport) :\n    (\u03c0 \u2022 S)\u1d3a = \u03c0 \u2022 S\u1d3a :=\n  rfl\n\n@[simp]\ntheorem smul_atoms_eq_of_smul_eq {\u03c0 : BasePerm} {S : BaseSupport}\n    (h : \u03c0 \u2022 S = S) :\n    \u03c0 \u2022 S\u1d2c = S\u1d2c := by\n  rw [\u2190 smul_atoms, h]\n\n@[simp]\ntheorem smul_nearLitters_eq_of_smul_eq {\u03c0 : BasePerm} {S : BaseSupport}\n    (h : \u03c0 \u2022 S = S) :\n    \u03c0 \u2022 S\u1d3a = S\u1d3a := by\n  rw [\u2190 smul_nearLitters, h]\n\ninstance : MulAction BasePerm BaseSupport where\n  one_smul S := by\n    apply ext\n    \u00b7 rw [smul_atoms, one_smul]\n    \u00b7 rw [smul_nearLitters, one_smul]\n  mul_smul \u03c0\u2081 \u03c0\u2082 S := by\n    apply ext\n    \u00b7 rw [smul_atoms, smul_atoms, smul_atoms, mul_smul]\n    \u00b7 rw [smul_nearLitters, smul_nearLitters, smul_nearLitters, mul_smul]\n\ntheorem smul_eq_smul_iff (\u03c0\u2081 \u03c0\u2082 : BasePerm) (S : BaseSupport) :\n    \u03c0\u2081 \u2022 S = \u03c0\u2082 \u2022 S \u2194 (\u2200 a \u2208 S\u1d2c, \u03c0\u2081 \u2022 a = \u03c0\u2082 \u2022 a) \u2227 (\u2200 N \u2208 S\u1d3a, \u03c0\u2081 \u2022 N = \u03c0\u2082 \u2022 N) := by\n  constructor\n  \u00b7 intro h\n    constructor\n    \u00b7 rintro a \u27e8i, ha\u27e9\n      have := congr_arg (\u00b7\u1d2c.rel i (\u03c0\u2081 \u2022 a)) h\n      simp only [smul_atoms, Enumeration.smul_rel, inv_smul_smul, eq_iff_iff] at this\n      have := S\u1d2c.rel_coinjective.coinjective ha (this.mp ha)\n      rw [eq_inv_smul_iff] at this\n      rw [this]\n    \u00b7 rintro N \u27e8i, hN\u27e9\n      have := congr_arg (\u00b7\u1d3a.rel i (\u03c0\u2081 \u2022 N)) h\n      simp only [smul_nearLitters, Enumeration.smul_rel, inv_smul_smul, eq_iff_iff] at this\n      have := S\u1d3a.rel_coinjective.coinjective hN (this.mp hN)\n      rw [eq_inv_smul_iff] at this\n      rw [this]\n  \u00b7 intro h\n    ext : 2\n    \u00b7 rfl\n    \u00b7 ext i a : 3\n      rw [smul_atoms, smul_atoms, Enumeration.smul_rel, Enumeration.smul_rel]\n      constructor\n      \u00b7 intro ha\n        have := h.1 _ \u27e8i, ha\u27e9\n        rw [smul_inv_smul, \u2190 inv_smul_eq_iff] at this\n        rwa [this]\n      \u00b7 intro ha\n        have := h.1 _ \u27e8i, ha\u27e9\n        rw [smul_inv_smul, smul_eq_iff_eq_inv_smul] at this\n        rwa [\u2190 this]\n    \u00b7 rfl\n    \u00b7 ext i a : 3\n      rw [smul_nearLitters, smul_nearLitters, Enumeration.smul_rel, Enumeration.smul_rel]\n      constructor\n      \u00b7 intro hN\n        have := h.2 _ \u27e8i, hN\u27e9\n        rw [smul_inv_smul, \u2190 inv_smul_eq_iff] at this\n        rwa [this]\n      \u00b7 intro hN\n        have := h.2 _ \u27e8i, hN\u27e9\n        rw [smul_inv_smul, smul_eq_iff_eq_inv_smul] at this\n        rwa [\u2190 this]\n\ntheorem smul_eq_iff (\u03c0 : BasePerm) (S : BaseSupport) :\n    \u03c0 \u2022 S = S \u2194 (\u2200 a \u2208 S\u1d2c, \u03c0 \u2022 a = a) \u2227 (\u2200 N \u2208 S\u1d3a, \u03c0 \u2022 N = N) := by\n  have := smul_eq_smul_iff \u03c0 1 S\n  simp only [one_smul] at this\n  exact this\n\nnoncomputable instance : Add BaseSupport where\n  add S T := \u27e8S\u1d2c + T\u1d2c, S\u1d3a + T\u1d3a\u27e9\n\n@[simp]\ntheorem add_atoms (S T : BaseSupport) :\n    (S + T)\u1d2c = S\u1d2c + T\u1d2c :=\n  rfl\n\n@[simp]\ntheorem add_nearLitters (S T : BaseSupport) :\n    (S + T)\u1d3a = S\u1d3a + T\u1d3a :=\n  rfl\n\nend BaseSupport\n\ndef baseSupportEquiv : BaseSupport \u2243 Enumeration Atom \u00d7 Enumeration NearLitter where\n  toFun S := (S\u1d2c, S\u1d3a)\n  invFun S := \u27e8S.1, S.2\u27e9\n  left_inv _ := rfl\n  right_inv _ := rfl\n\ntheorem card_baseSupport : #BaseSupport = #\u03bc := by\n  rw [Cardinal.eq.mpr \u27e8baseSupportEquiv\u27e9, mk_prod, lift_id, lift_id,\n    card_enumeration_eq card_atom, card_enumeration_eq card_nearLitter, mul_eq_self aleph0_lt_\u03bc.le]\n\n/-!\n## Structural supports\n-/\n\nstructure Support (\u03b1 : TypeIndex) where\n  atoms : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)\n  nearLitters : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)\n\nnamespace Support\n\nvariable {\u03b1 \u03b2 : TypeIndex}\n\ninstance : SuperA (Support \u03b1) (Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) where\n  superA := atoms\n\ninstance : SuperN (Support \u03b1) (Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) where\n  superN := nearLitters\n\n@[simp]\ntheorem mk_atoms (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) (F : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) :\n    (\u27e8E, F\u27e9 : Support \u03b1)\u1d2c = E :=\n  rfl\n\n@[simp]\ntheorem mk_nearLitters (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) (F : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) :\n    (\u27e8E, F\u27e9 : Support \u03b1)\u1d3a = F :=\n  rfl\n\ninstance : Derivative (Support \u03b1) (Support \u03b2) \u03b1 \u03b2 where\n  deriv S A := \u27e8S\u1d2c \u21d8 A, S\u1d3a \u21d8 A\u27e9\n\ninstance : Coderivative (Support \u03b2) (Support \u03b1) \u03b1 \u03b2 where\n  coderiv S A := \u27e8S\u1d2c \u21d7 A, S\u1d3a \u21d7 A\u27e9\n\ninstance : BotDerivative (Support \u03b1) BaseSupport \u03b1 where\n  botDeriv S A := \u27e8S\u1d2c \u21d8. A, S\u1d3a \u21d8. A\u27e9\n  botSderiv S := \u27e8S\u1d2c \u2198., S\u1d3a \u2198.\u27e9\n  botDeriv_single S h := by dsimp only; rw [botDeriv_single, botDeriv_single]\n\n@[simp]\ntheorem deriv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u03b2) :\n    S\u1d2c \u21d8 A = (S \u21d8 A)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem deriv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u03b2) :\n    S\u1d3a \u21d8 A = (S \u21d8 A)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem sderiv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (h : \u03b2 < \u03b1) :\n    S\u1d2c \u2198 h = (S \u2198 h)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem sderiv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (h : \u03b2 < \u03b1) :\n    S\u1d3a \u2198 h = (S \u2198 h)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem coderiv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    S\u1d2c \u21d7 A = (S \u21d7 A)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem coderiv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    S\u1d3a \u21d7 A = (S \u21d7 A)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem scoderiv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (h : \u03b2 < \u03b1) :\n    S\u1d2c \u2197 h = (S \u2197 h)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem scoderiv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (h : \u03b2 < \u03b1) :\n    S\u1d3a \u2197 h = (S \u2197 h)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem derivBot_atoms {\u03b1 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u22a5) :\n    S\u1d2c \u21d8. A = (S \u21d8. A)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem derivBot_nearLitters {\u03b1 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u22a5) :\n    S\u1d3a \u21d8. A = (S \u21d8. A)\u1d3a :=\n  rfl\n\ntheorem ext' {S T : Support \u03b1} (h\u2081 : S\u1d2c = T\u1d2c) (h\u2082 : S\u1d3a = T\u1d3a) : S = T := by\n  obtain \u27e8SA, SN\u27e9 := S\n  obtain \u27e8TA, TN\u27e9 := T\n  cases h\u2081\n  cases h\u2082\n  rfl\n\n@[ext]\ntheorem ext {S T : Support \u03b1} (h : \u2200 A, S \u21d8. A = T \u21d8. A) : S = T := by\n  obtain \u27e8SA, SN\u27e9 := S\n  obtain \u27e8TA, TN\u27e9 := T\n  rw [mk.injEq]\n  constructor\n  \u00b7 apply Enumeration.ext_path\n    intro A\n    exact BaseSupport.atoms_congr (h A)\n  \u00b7 apply Enumeration.ext_path\n    intro A\n    exact BaseSupport.nearLitters_congr (h A)\n\n@[simp]\ntheorem deriv_derivBot {\u03b1 : TypeIndex} (S : Support \u03b1)\n    (A : \u03b1 \u219d \u03b2) (B : \u03b2 \u219d \u22a5) :\n    S \u21d8 A \u21d8. B = S \u21d8. (A \u21d8 B) :=\n  rfl\n\n@[simp]\ntheorem coderiv_deriv_eq {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    S \u21d7 A \u21d8 A = S :=\n  ext' (S\u1d2c.coderiv_deriv_eq A) (S\u1d3a.coderiv_deriv_eq A)\n\ntheorem eq_of_atom_mem_scoderiv_botDeriv {\u03b1 \u03b2 : TypeIndex} {S : Support \u03b2} {A : \u03b1 \u219d \u22a5}\n    {h : \u03b2 < \u03b1} {a : Atom} (ha : a \u2208 (S \u2197 h \u21d8. A)\u1d2c) :\n    \u2203 B : \u03b2 \u219d \u22a5, A = B \u2197 h :=\n  Enumeration.eq_of_mem_scoderiv_botDeriv ha\n\ntheorem eq_of_nearLitter_mem_scoderiv_botDeriv {\u03b1 \u03b2 : TypeIndex} {S : Support \u03b2} {A : \u03b1 \u219d \u22a5}\n    {h : \u03b2 < \u03b1} {N : NearLitter} (hN : N \u2208 (S \u2197 h \u21d8. A)\u1d3a) :\n    \u2203 B : \u03b2 \u219d \u22a5, A = B \u2197 h :=\n  Enumeration.eq_of_mem_scoderiv_botDeriv hN\n\n@[simp]\ntheorem scoderiv_botDeriv_eq {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (A : \u03b2 \u219d \u22a5) (h : \u03b2 < \u03b1) :\n    S \u2197 h \u21d8. (A \u2197 h) = S \u21d8. A :=\n  BaseSupport.ext (Enumeration.scoderiv_botDeriv_eq _ _ _) (Enumeration.scoderiv_botDeriv_eq _ _ _)\n\n@[simp]\ntheorem scoderiv_deriv_eq {\u03b1 \u03b2 \u03b3 : TypeIndex} (S : Support \u03b2) (A : \u03b2 \u219d \u03b3) (h : \u03b2 < \u03b1) :\n    S \u2197 h \u21d8 (A \u2197 h) = S \u21d8 A := by\n  apply ext\n  intro B\n  simp only [deriv_derivBot, \u2190 scoderiv_botDeriv_eq S (A \u21d8 B) h, Path.coderiv_deriv']\n\n@[simp]\ntheorem coderiv_inj {\u03b1 \u03b2 : TypeIndex} (S T : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    S \u21d7 A = T \u21d7 A \u2194 S = T := by\n  constructor\n  swap\n  \u00b7 rintro rfl\n    rfl\n  intro h\n  ext B : 1\n  have : S \u21d7 A \u21d8 A \u21d8. B = T \u21d7 A \u21d8 A \u21d8. B := by rw [h]\n  rwa [coderiv_deriv_eq, coderiv_deriv_eq] at this\n\n@[simp]\ntheorem scoderiv_inj {\u03b1 \u03b2 : TypeIndex} (S T : Support \u03b2) (h : \u03b2 < \u03b1) :\n    S \u2197 h = T \u2197 h \u2194 S = T :=\n  coderiv_inj S T (.single h)\n\ninstance {\u03b1 : TypeIndex} : SMul (StrPerm \u03b1) (Support \u03b1) where\n  smul \u03c0 S := \u27e8\u03c0 \u2022 S\u1d2c, \u03c0 \u2022 S\u1d3a\u27e9\n\n@[simp]\ntheorem smul_atoms {\u03b1 : TypeIndex} (\u03c0 : StrPerm \u03b1) (S : Support \u03b1) :\n    (\u03c0 \u2022 S)\u1d2c = \u03c0 \u2022 S\u1d2c :=\n  rfl\n\n@[simp]\ntheorem smul_nearLitters {\u03b1 : TypeIndex} (\u03c0 : StrPerm \u03b1) (S : Support \u03b1) :\n    (\u03c0 \u2022 S)\u1d3a = \u03c0 \u2022 S\u1d3a :=\n  rfl\n\ntheorem smul_atoms_eq_of_smul_eq {\u03b1 : TypeIndex} {\u03c0 : StrPerm \u03b1} {S : Support \u03b1}\n    (h : \u03c0 \u2022 S = S) :\n    \u03c0 \u2022 S\u1d2c = S\u1d2c := by\n  rw [\u2190 smul_atoms, h]\n\ntheorem smul_nearLitters_eq_of_smul_eq {\u03b1 : TypeIndex} {\u03c0 : StrPerm \u03b1} {S : Support \u03b1}\n    (h : \u03c0 \u2022 S = S) :\n    \u03c0 \u2022 S\u1d3a = S\u1d3a := by\n  rw [\u2190 smul_nearLitters, h]\n\ninstance {\u03b1 : TypeIndex} : MulAction (StrPerm \u03b1) (Support \u03b1) where\n  one_smul S := by\n    apply ext'\n    \u00b7 rw [smul_atoms, one_smul]\n    \u00b7 rw [smul_nearLitters, one_smul]\n  mul_smul \u03c0\u2081 \u03c0\u2082 S := by\n    apply ext'\n    \u00b7 rw [smul_atoms, smul_atoms, smul_atoms, mul_smul]\n    \u00b7 rw [smul_nearLitters, smul_nearLitters, smul_nearLitters, mul_smul]\n\n@[simp]\ntheorem smul_derivBot {\u03b1 : TypeIndex} (\u03c0 : StrPerm \u03b1) (S : Support \u03b1) (A : \u03b1 \u219d \u22a5) :\n    (\u03c0 \u2022 S) \u21d8. A = \u03c0 A \u2022 (S \u21d8. A) :=\n  rfl\n\ntheorem smul_coderiv {\u03b1 : TypeIndex} (\u03c0 : StrPerm \u03b1) (S : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    \u03c0 \u2022 S \u21d7 A = (\u03c0 \u21d8 A \u2022 S) \u21d7 A := by\n  ext B i x\n  \u00b7 rfl\n  \u00b7 constructor\n    \u00b7 rintro \u27e8\u27e8C, x\u27e9, hS, hx\u27e9\n      simp only [Prod.mk.injEq] at hx\n      obtain \u27e8rfl, rfl\u27e9 := hx\n      exact \u27e8\u27e8C, x\u27e9, hS, rfl\u27e9\n    \u00b7 rintro \u27e8\u27e8C, x\u27e9, hS, hx\u27e9\n      simp only [Prod.mk.injEq] at hx\n      obtain \u27e8rfl, rfl\u27e9 := hx\n      exact \u27e8\u27e8C, _\u27e9, hS, rfl\u27e9\n  \u00b7 rfl\n  \u00b7 constructor\n    \u00b7 rintro \u27e8\u27e8C, x\u27e9, hS, hx\u27e9\n      simp only [Prod.mk.injEq] at hx\n      obtain \u27e8rfl, rfl\u27e9 := hx\n      exact \u27e8\u27e8C, x\u27e9, hS, rfl\u27e9\n    \u00b7 rintro \u27e8\u27e8C, a\u27e9, hS, hx\u27e9\n      simp only [Prod.mk.injEq] at hx\n      obtain \u27e8rfl, rfl\u27e9 := hx\n      exact \u27e8\u27e8C, _\u27e9, hS, rfl\u27e9\n\ntheorem smul_scoderiv {\u03b1 : TypeIndex} (\u03c0 : StrPerm \u03b1) (S : Support \u03b2) (h : \u03b2 < \u03b1) :\n    \u03c0 \u2022 S \u2197 h = (\u03c0 \u2198 h \u2022 S) \u2197 h :=\n  smul_coderiv \u03c0 S (Path.single h)\n\ntheorem smul_eq_smul_iff (\u03c0\u2081 \u03c0\u2082 : StrPerm \u03b2) (S : Support \u03b2) :\n    \u03c0\u2081 \u2022 S = \u03c0\u2082 \u2022 S \u2194\n      \u2200 A, (\u2200 a \u2208 (S \u21d8. A)\u1d2c, \u03c0\u2081 A \u2022 a = \u03c0\u2082 A \u2022 a) \u2227 (\u2200 N \u2208 (S \u21d8. A)\u1d3a, \u03c0\u2081 A \u2022 N = \u03c0\u2082 A \u2022 N) := by\n  constructor\n  \u00b7 intro h A\n    have := congr_arg (\u00b7 \u21d8. A) h\n    simp only [smul_derivBot, BaseSupport.smul_eq_smul_iff] at this\n    exact this\n  \u00b7 intro h\n    apply ext\n    intro A\n    simp only [smul_derivBot, BaseSupport.smul_eq_smul_iff]\n    exact h A\n\ntheorem smul_eq_iff (\u03c0 : StrPerm \u03b2) (S : Support \u03b2) :\n    \u03c0 \u2022 S = S \u2194 \u2200 A, (\u2200 a \u2208 (S \u21d8. A)\u1d2c, \u03c0 A \u2022 a = a) \u2227 (\u2200 N \u2208 (S \u21d8. A)\u1d3a, \u03c0 A \u2022 N = N) := by\n  have := smul_eq_smul_iff \u03c0 1 S\n  simp only [one_smul, Tree.one_apply] at this\n  exact this\n\nnoncomputable instance : Add (Support \u03b1) where\n  add S T := \u27e8S\u1d2c + T\u1d2c, S\u1d3a + T\u1d3a\u27e9\n\n@[simp]\ntheorem add_derivBot (S T : Support \u03b1) (A : \u03b1 \u219d \u22a5) :\n    (S + T) \u21d8. A = (S \u21d8. A) + (T \u21d8. A) :=\n  rfl\n\ntheorem smul_add (S T : Support \u03b1) (\u03c0 : StrPerm \u03b1) :\n    \u03c0 \u2022 (S + T) = \u03c0 \u2022 S + \u03c0 \u2022 T :=\n  rfl\n\ntheorem add_inj_of_bound_eq_bound {S T U V : Support \u03b1}\n    (ha : S\u1d2c.bound = T\u1d2c.bound) (hN : S\u1d3a.bound = T\u1d3a.bound)\n    (h' : S + U = T + V) : S = T \u2227 U = V := by\n  have ha' := Enumeration.add_inj_of_bound_eq_bound ha (congr_arg (\u00b7\u1d2c) h')\n  have hN' := Enumeration.add_inj_of_bound_eq_bound hN (congr_arg (\u00b7\u1d3a) h')\n  constructor\n  \u00b7 exact Support.ext' ha'.1 hN'.1\n  \u00b7 exact Support.ext' ha'.2 hN'.2\n\nend Support\n\ndef supportEquiv {\u03b1 : TypeIndex} : Support \u03b1 \u2243\n    Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom) \u00d7 Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter) where\n  toFun S := (S\u1d2c, S\u1d3a)\n  invFun S := \u27e8S.1, S.2\u27e9\n  left_inv _ := rfl\n  right_inv _ := rfl\n\ntheorem card_support {\u03b1 : TypeIndex} : #(Support \u03b1) = #\u03bc := by\n  rw [Cardinal.eq.mpr \u27e8supportEquiv\u27e9, mk_prod, lift_id, lift_id,\n    card_enumeration_eq, card_enumeration_eq, mul_eq_self aleph0_lt_\u03bc.le]\n  \u00b7 rw [mk_prod, lift_id, lift_id, card_nearLitter,\n      mul_eq_right aleph0_lt_\u03bc.le (card_path_lt' \u03b1 \u22a5).le (card_path_ne_zero \u03b1)]\n  \u00b7 rw [mk_prod, lift_id, lift_id, card_atom,\n      mul_eq_right aleph0_lt_\u03bc.le (card_path_lt' \u03b1 \u22a5).le (card_path_ne_zero \u03b1)]\n\n/-!\n## Orders on supports\n-/\n\n-- TODO: Is this order used?\ninstance : LE BaseSupport where\n  le S T := (\u2200 a \u2208 S\u1d2c, a \u2208 T\u1d2c) \u2227 (\u2200 N \u2208 S\u1d3a, N \u2208 T\u1d3a)\n\ninstance : Preorder BaseSupport where\n  le_refl S := \u27e8\u03bb _ \u21a6 id, \u03bb _ \u21a6 id\u27e9\n  le_trans S T U h\u2081 h\u2082 := \u27e8\u03bb a h \u21a6 h\u2082.1 _ (h\u2081.1 a h), \u03bb N h \u21a6 h\u2082.2 _ (h\u2081.2 N h)\u27e9\n\ntheorem BaseSupport.smul_le_smul {S T : BaseSupport} (h : S \u2264 T) (\u03c0 : BasePerm) :\n    \u03c0 \u2022 S \u2264 \u03c0 \u2022 T := by\n  constructor\n  \u00b7 intro a\n    exact h.1 (\u03c0\u207b\u00b9 \u2022 a)\n  \u00b7 intro N\n    exact h.2 (\u03c0\u207b\u00b9 \u2022 N)\n\ntheorem BaseSupport.le_add_right {S T : BaseSupport} :\n    S \u2264 S + T := by\n  constructor\n  \u00b7 intro a ha\n    simp only [Support.add_derivBot, BaseSupport.add_atoms, Enumeration.mem_add_iff]\n    exact Or.inl ha\n  \u00b7 intro N hN\n    simp only [Support.add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n    exact Or.inl hN\n\ntheorem BaseSupport.le_add_left {S T : BaseSupport} :\n    S \u2264 T + S := by\n  constructor\n  \u00b7 intro a ha\n    simp only [add_atoms, Enumeration.mem_add_iff]\n    exact Or.inr ha\n  \u00b7 intro N hN\n    simp only [add_nearLitters, Enumeration.mem_add_iff]\n    exact Or.inr hN\n\ndef BaseSupport.Subsupport (S T : BaseSupport) : Prop :=\n  S\u1d2c.rel \u2264 T\u1d2c.rel \u2227 S\u1d3a.rel \u2264 T\u1d3a.rel\n\ntheorem BaseSupport.Subsupport.le {S T : BaseSupport}\n    (h : S.Subsupport T) : S \u2264 T := by\n  constructor\n  \u00b7 rintro a \u27e8i, hi\u27e9\n    exact \u27e8i, h.1 i a hi\u27e9\n  \u00b7 rintro N \u27e8i, hi\u27e9\n    exact \u27e8i, h.2 i N hi\u27e9\n\ntheorem BaseSupport.Subsupport.trans {S T U : BaseSupport}\n    (h\u2081 : S.Subsupport T) (h\u2082 : T.Subsupport U) :\n    S.Subsupport U :=\n  \u27e8h\u2081.1.trans h\u2082.1, h\u2081.2.trans h\u2082.2\u27e9\n\ntheorem BaseSupport.smul_subsupport_smul {S T : BaseSupport} (h : S.Subsupport T) (\u03c0 : BasePerm) :\n    (\u03c0 \u2022 S).Subsupport (\u03c0 \u2022 T) := by\n  constructor\n  \u00b7 intro i a ha\n    exact h.1 i _ ha\n  \u00b7 intro i N hN\n    exact h.2 i _ hN\n\ninstance {\u03b1 : TypeIndex} : LE (Support \u03b1) where\n  le S T := \u2200 A, S \u21d8. A \u2264 T \u21d8. A\n\ninstance {\u03b1 : TypeIndex} : Preorder (Support \u03b1) where\n  le_refl S := \u03bb A \u21a6 le_rfl\n  le_trans S T U h\u2081 h\u2082 := \u03bb A \u21a6 (h\u2081 A).trans (h\u2082 A)\n\ntheorem Support.smul_le_smul {\u03b1 : TypeIndex} {S T : Support \u03b1} (h : S \u2264 T) (\u03c0 : StrPerm \u03b1) :\n    \u03c0 \u2022 S \u2264 \u03c0 \u2022 T :=\n  \u03bb A \u21a6 BaseSupport.smul_le_smul (h A) (\u03c0 A)\n\n", "theoremStatement": "theorem Support.le_add_right {\u03b1 : TypeIndex} {S T : Support \u03b1} :\n    S \u2264 S + T ", "theoremName": "ConNF.Support.le_add_right", "fileCreated": {"commit": "39c33b4a743bea62dbcc549548b712ffd38ca65c", "date": "2024-12-05"}, "theoremCreated": {"commit": "251ac752f844dfde539ac2bd3ff112305ad59139", "date": "2024-11-30"}, "file": "ConNF/ConNF/ModelData/Support.lean", "module": "ConNF.ModelData.Support", "jsonFile": "ConNF.ModelData.Support.jsonl", "positionMetadata": {"lineInFile": 532, "tokenPositionInFile": 14912, "theoremPositionInFile": 57}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 9, "repositoryPremises": true, "numRepositoryPremises": 14, "numPremises": 23}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  intro A\n  rw [add_derivBot]\n  exact BaseSupport.le_add_right", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 68}}
{"srcContext": "import ConNF.Model.TTT\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\nnamespace TSet\n\ntheorem exists_inter (x y : TSet \u03b1) :\n    \u2203 w : TSet \u03b1, \u2200 z : TSet \u03b2, z \u2208[h\u03b2] w \u2194 z \u2208[h\u03b2] x \u2227 z \u2208[h\u03b2] y := by\n  refine exists_of_symmetric {z | z \u2208[h\u03b2] x \u2227 z \u2208[h\u03b2] y} h\u03b2 ?_\n  obtain \u27e8S, hS\u27e9 := symmetric x h\u03b2\n  obtain \u27e8T, hT\u27e9 := symmetric y h\u03b2\n  use S + T\n  intro \u03c1 h\u03c1\n  specialize hS \u03c1 (smul_eq_of_le Support.le_add_right h\u03c1)\n  specialize hT \u03c1 (smul_eq_of_le Support.le_add_left h\u03c1)\n  simp [Set.ext_iff, Set.mem_smul_set_iff_inv_smul_mem] at hS hT \u22a2\n  aesop\n\ntheorem exists_compl (x : TSet \u03b1) :\n    \u2203 y : TSet \u03b1, \u2200 z : TSet \u03b2, z \u2208[h\u03b2] y \u2194 \u00acz \u2208[h\u03b2] x := by\n  refine exists_of_symmetric {z | \u00acz \u2208[h\u03b2] x} h\u03b2 ?_\n  obtain \u27e8S, hS\u27e9 := symmetric x h\u03b2\n  use S\n  intro \u03c1 h\u03c1\n  specialize hS \u03c1 h\u03c1\n  simp [Set.ext_iff, Set.mem_smul_set_iff_inv_smul_mem] at hS \u22a2\n  aesop\n\ntheorem exists_up (x y : TSet \u03b2) :\n    \u2203 w : TSet \u03b1, \u2200 z : TSet \u03b2, z \u2208[h\u03b2] w \u2194 z = x \u2228 z = y := by\n  refine exists_of_symmetric {x, y} h\u03b2 ?_\n  obtain \u27e8S, hS\u27e9 := exists_support x\n  obtain \u27e8T, hT\u27e9 := exists_support y\n  use (S + T) \u2197 h\u03b2\n  intro \u03c1 h\u03c1\n  rw [Support.smul_scoderiv, Support.scoderiv_inj, \u2190 allPermSderiv_forget'] at h\u03c1\n  specialize hS (\u03c1 \u2198 h\u03b2) (smul_eq_of_le Support.le_add_right h\u03c1)\n  specialize hT (\u03c1 \u2198 h\u03b2) (smul_eq_of_le Support.le_add_left h\u03c1)\n  simp only [Set.smul_set_def, Set.image, Set.mem_insert_iff, Set.mem_singleton_iff,\n    exists_eq_or_imp, hS, exists_eq_left, hT]\n  ext z\n  rw [Set.mem_insert_iff, Set.mem_singleton_iff, Set.mem_setOf_eq]\n  aesop\n\n/-- The unordered pair. -/\ndef up (x y : TSet \u03b2) : TSet \u03b1 :=\n  (exists_up h\u03b2 x y).choose\n\n@[simp]\ntheorem mem_up_iff (x y z : TSet \u03b2) :\n    z \u2208[h\u03b2] up h\u03b2 x y \u2194 z = x \u2228 z = y :=\n  (exists_up h\u03b2 x y).choose_spec z\n\n/-- The Kuratowski ordered pair. -/\ndef op (x y : TSet \u03b3) : TSet \u03b1 :=\n  up h\u03b2 (singleton h\u03b3 x) (up h\u03b3 x y)\n\ntheorem up_injective {x y z w : TSet \u03b2} (h : up h\u03b2 x y = up h\u03b2 z w) :\n    (x = z \u2227 y = w) \u2228 (x = w \u2227 y = z) := by\n  have h\u2081 := mem_up_iff h\u03b2 x y z\n  have h\u2082 := mem_up_iff h\u03b2 x y w\n  have h\u2083 := mem_up_iff h\u03b2 z w x\n  have h\u2084 := mem_up_iff h\u03b2 z w y\n  rw [h, mem_up_iff] at h\u2081 h\u2082\n  rw [\u2190 h, mem_up_iff] at h\u2083 h\u2084\n  aesop\n\n@[simp]\ntheorem up_inj (x y z w : TSet \u03b2) :\n    up h\u03b2 x y = up h\u03b2 z w \u2194 (x = z \u2227 y = w) \u2228 (x = w \u2227 y = z) := by\n  constructor\n  \u00b7 exact up_injective h\u03b2\n  \u00b7 rintro (\u27e8rfl, rfl\u27e9 | \u27e8rfl, rfl\u27e9)\n    \u00b7 rfl\n    \u00b7 apply tSet_ext' h\u03b2\n      aesop\n\n@[simp]\ntheorem up_self {x : TSet \u03b2} :\n    up h\u03b2 x x = singleton h\u03b2 x := by\n  apply tSet_ext' h\u03b2\n  aesop\n\n@[simp]\ntheorem up_eq_singleton_iff (x y z : TSet \u03b2) :\n    up h\u03b2 x y = singleton h\u03b2 z \u2194 x = z \u2227 y = z := by\n  constructor\n  \u00b7 intro h\n    have h\u2081 := typedMem_singleton_iff' h\u03b2 z x\n    have h\u2082 := typedMem_singleton_iff' h\u03b2 z y\n    rw [\u2190 h, mem_up_iff] at h\u2081 h\u2082\n    aesop\n  \u00b7 rintro \u27e8rfl, rfl\u27e9\n    rw [up_self]\n\n", "theoremStatement": "@[simp]\ntheorem singleton_eq_up_iff (x y z : TSet \u03b2) :\n    singleton h\u03b2 z = up h\u03b2 x y \u2194 x = z \u2227 y = z ", "theoremName": "ConNF.TSet.singleton_eq_up_iff", "fileCreated": {"commit": "f804f5c71cfaa98223fc227dd822801e8bf77004", "date": "2024-03-30"}, "theoremCreated": {"commit": "79d0b7460f1a514629674a45c428d31c1a50bb03", "date": "2024-12-01"}, "file": "ConNF/ConNF/Model/Hailperin.lean", "module": "ConNF.Model.Hailperin", "jsonFile": "ConNF.Model.Hailperin.jsonl", "positionMetadata": {"lineInFile": 114, "tokenPositionInFile": 3103, "theoremPositionInFile": 10}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 10, "numPremises": 30}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [\u2190 up_eq_singleton_iff h\u03b2 x y z, eq_comm]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 52}}
{"srcContext": "import ConNF.Model.RunInduction\n\n/-!\n# Externalisation\n\nIn this file, we convert many of our *internal* results (i.e. inside the induction) to *external*\nones (i.e. defined using the global `TSet`/`AllPerm` definitions).\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal WithBot\n\nnamespace ConNF\n\nvariable [Params.{u}]\n\ninstance globalModelData : {\u03b1 : TypeIndex} \u2192 ModelData \u03b1\n  | (\u03b1 : \u039b) => (motive \u03b1).data\n  | \u22a5 => botModelData\n\ninstance globalPosition : {\u03b1 : TypeIndex} \u2192 Position (Tangle \u03b1)\n  | (\u03b1 : \u039b) => (motive \u03b1).pos\n  | \u22a5 => botPosition\n\ninstance globalTypedNearLitters {\u03b1 : \u039b} : TypedNearLitters \u03b1 :=\n  (motive \u03b1).typed\n\ninstance globalLtData [Level] : LtData where\n\ninstance globalLeData [Level] : LeData where\n\nomit [Params] in\ntheorem heq_funext {\u03b1 : Sort _} {\u03b2 \u03b3 : \u03b1 \u2192 Sort _} {f : (x : \u03b1) \u2192 \u03b2 x} {g : (x : \u03b1) \u2192 \u03b3 x}\n    (h : \u2200 x, HEq (f x) (g x)) : HEq f g := by\n  cases funext \u03bb x \u21a6 type_eq_of_heq (h x)\n  simp only [heq_eq_eq] at h \u22a2\n  exact funext h\n\ntheorem globalLtData_eq [Level] :\n    globalLtData = ltData (\u03bb \u03b2 _ \u21a6 motive \u03b2) := by\n  apply LtData.ext\n  \u00b7 ext \u03b2 h\u03b2\n    induction \u03b2 using recBotCoe\n    case bot => rfl\n    case coe \u03b2 => rfl\n  \u00b7 apply heq_funext\n    intro \u03b2\n    induction \u03b2 using recBotCoe\n    case bot => rfl\n    case coe \u03b2 => rfl\n  \u00b7 rfl\n\ntheorem globalLeData_eq [Level] :\n    globalLeData = leData (\u03bb \u03b2 _ \u21a6 motive \u03b2) := by\n  apply LeData.ext\n  \u00b7 ext \u03b2 h\u03b2\n    induction \u03b2 using recBotCoe\n    case bot => rfl\n    case coe \u03b2 =>\n      by_cases h : (\u03b2 : TypeIndex) = \u03b1\n      \u00b7 cases coe_injective h\n        rw [leData_data_eq]\n        unfold globalLeData globalModelData\n        dsimp only\n        rw [motive_eq]\n        rfl\n      \u00b7 rw [leData_data_lt _ (h\u03b2.elim.lt_of_ne h)]\n        rfl\n  \u00b7 apply heq_funext\n    intro \u03b2\n    apply heq_funext\n    intro h\u03b2\n    induction \u03b2 using recBotCoe\n    case bot => rfl\n    case coe \u03b2 =>\n      rw [leData]\n      simp only [coe_inj, id_eq, eq_mpr_eq_cast, recBotCoe_bot, recBotCoe_coe, LtLevel.elim.ne]\n      exact HEq.symm (cast_heq _ _)\n\ninstance globalPreCoherentData [Level] : PreCoherentData where\n  allPermSderiv h := cast (by rw [globalLeData_eq])\n    ((preCoherentData (\u03bb \u03b2 _ \u21a6 motive \u03b2) (\u03bb \u03b2 _ \u21a6 hypothesis \u03b2)).allPermSderiv h)\n  singleton h := cast (by rw [globalLeData_eq])\n    ((preCoherentData (\u03bb \u03b2 _ \u21a6 motive \u03b2) (\u03bb \u03b2 _ \u21a6 hypothesis \u03b2)).singleton h)\n\nomit [Params] in\n@[simp]\ntheorem heq_cast_eq_iff {\u03b1 \u03b2 \u03b3 : Type _} {x : \u03b1} {y : \u03b2} {h : \u03b1 = \u03b3} :\n    HEq (cast h x) y \u2194 HEq x y := by\n  cases h\n  rw [cast_eq]\n\n", "theoremStatement": "theorem globalPreCoherentData_eq [Level] :\n    globalPreCoherentData = preCoherentData (\u03bb \u03b2 _ \u21a6 motive \u03b2) (\u03bb \u03b2 _ \u21a6 hypothesis \u03b2) ", "theoremName": "ConNF.globalPreCoherentData_eq", "fileCreated": {"commit": "6fdc87c6b30b73931407a372f1430ecf0fef7601", "date": "2024-12-03"}, "theoremCreated": {"commit": "e409f3d0cd939e7218c3f39dcf3493c4b6e0b821", "date": "2024-11-29"}, "file": "ConNF/ConNF/Model/Externalise.lean", "module": "ConNF.Model.Externalise", "jsonFile": "ConNF.Model.Externalise.jsonl", "positionMetadata": {"lineInFile": 99, "tokenPositionInFile": 2555, "theoremPositionInFile": 4}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 5, "repositoryPremises": true, "numRepositoryPremises": 36, "numPremises": 61}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  have := globalLeData_eq\n  rw [LeData.ext_iff] at this\n  apply PreCoherentData.ext\n  \u00b7 exact this.1\n  \u00b7 exact this.2\n  \u00b7 unfold globalPreCoherentData\n    apply heq_funext; intro \u03b2\n    apply heq_funext; intro \u03b3\n    apply heq_funext; intro h\u03b2\n    apply heq_funext; intro h\u03b3\n    apply heq_funext; intro h\u03b2\u03b3\n    simp only [heq_cast_eq_iff]\n    rfl\n  \u00b7 unfold globalPreCoherentData\n    apply heq_funext; intro \u03b2\n    apply heq_funext; intro \u03b3\n    apply heq_funext; intro h\u03b2\n    apply heq_funext; intro h\u03b3\n    apply heq_funext; intro h\u03b2\u03b3\n    simp only [heq_cast_eq_iff]\n    rfl", "proofType": "tactic", "proofLengthLines": 21, "proofLengthTokens": 577}}
{"srcContext": "import ConNF.Model.Externalise\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b2 \u03b3 : \u039b} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n\nnamespace Support\n\n", "theoremStatement": "theorem not_mem_scoderiv_botDeriv (S : Support \u03b3) (N : NearLitter) :\n    N \u2209 (S \u2197 h\u03b3 \u21d8. (Path.nil \u2198.))\u1d3a ", "theoremName": "ConNF.Support.not_mem_scoderiv_botDeriv", "fileCreated": {"commit": "abf71bc79c407ceb462cc2edd2d994cda9cdef05", "date": "2024-04-04"}, "theoremCreated": {"commit": "251ac752f844dfde539ac2bd3ff112305ad59139", "date": "2024-11-30"}, "file": "ConNF/ConNF/Model/RaiseStrong.lean", "module": "ConNF.Model.RaiseStrong", "jsonFile": "ConNF.Model.RaiseStrong.jsonl", "positionMetadata": {"lineInFile": 24, "tokenPositionInFile": 274, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 32, "numPremises": 71}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rintro \u27e8i, \u27e8A, N'\u27e9, h\u2081, h\u2082\u27e9\n  simp only [Prod.mk.injEq] at h\u2082\n  cases A\n  case sderiv \u03b4 A h\u03b4 _ =>\n    simp only [Path.deriv_sderiv] at h\u2082\n    cases A\n    case nil => cases h\u2082.1\n    case sderiv \u03b6 A h\u03b6 _ =>\n      simp only [Path.deriv_sderiv] at h\u2082\n      cases h\u2082.1", "proofType": "tactic", "proofLengthLines": 10, "proofLengthTokens": 271}}
{"srcContext": "import ConNF.Model.RaiseStrong\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nopen scoped Pointwise\n\nnamespace ConNF\n\nvariable [Params.{u}]\n\n/-- A redefinition of the derivative of allowable permutations that is invariant of level,\nbut still has nice definitional properties. -/\n@[default_instance 200]\ninstance {\u03b2 \u03b3 : TypeIndex} : Derivative (AllPerm \u03b2) (AllPerm \u03b3) \u03b2 \u03b3 where\n  deriv \u03c1 A :=\n    A.recSderiv\n    (motive := \u03bb (\u03b4 : TypeIndex) (A : \u03b2 \u219d \u03b4) \u21a6\n      letI : Level := \u27e8\u03b4.recBotCoe (Nonempty.some inferInstance) id\u27e9\n      letI : LeLevel \u03b4 := \u27e8\u03b4.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n        (show \u03b4.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n      AllPerm \u03b4)\n    \u03c1 (\u03bb \u03b4 \u03b5 A h \u03c1 \u21a6\n      letI : Level := \u27e8\u03b4.recBotCoe (Nonempty.some inferInstance) id\u27e9\n      letI : LeLevel \u03b4 := \u27e8\u03b4.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n        (show \u03b4.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n      letI : LeLevel \u03b5 := \u27e8h.le.trans LeLevel.elim\u27e9\n      PreCoherentData.allPermSderiv h \u03c1)\n\n@[simp]\ntheorem allPerm_deriv_nil' {\u03b2 : TypeIndex}\n    (\u03c1 : AllPerm \u03b2) :\n    \u03c1 \u21d8 (.nil : \u03b2 \u219d \u03b2) = \u03c1 :=\n  rfl\n\n@[simp]\ntheorem allPerm_deriv_sderiv' {\u03b2 \u03b3 \u03b4 : TypeIndex}\n    (\u03c1 : AllPerm \u03b2) (A : \u03b2 \u219d \u03b3) (h : \u03b4 < \u03b3) :\n    \u03c1 \u21d8 (A \u2198 h) = \u03c1 \u21d8 A \u2198 h :=\n  rfl\n\n@[simp]\ntheorem allPermSderiv_forget' {\u03b2 \u03b3 : TypeIndex} (h : \u03b3 < \u03b2) (\u03c1 : AllPerm \u03b2) :\n    (\u03c1 \u2198 h)\u1d41 = \u03c1\u1d41 \u2198 h :=\n  letI : Level := \u27e8\u03b2.recBotCoe (Nonempty.some inferInstance) id\u27e9\n  letI : LeLevel \u03b2 := \u27e8\u03b2.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n    (show \u03b2.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n  letI : LeLevel \u03b3 := \u27e8h.le.trans LeLevel.elim\u27e9\n  allPermSderiv_forget h \u03c1\n\n@[simp]\ntheorem allPerm_inv_sderiv' {\u03b2 \u03b3 : TypeIndex} (h : \u03b3 < \u03b2) (\u03c1 : AllPerm \u03b2) :\n    \u03c1\u207b\u00b9 \u2198 h = (\u03c1 \u2198 h)\u207b\u00b9 := by\n  apply allPermForget_injective\n  rw [allPermSderiv_forget', allPermForget_inv, Tree.inv_sderiv, allPermForget_inv,\n    allPermSderiv_forget']\n\ndef Symmetric {\u03b1 \u03b2 : \u039b} (s : Set (TSet \u03b2)) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) : Prop :=\n  \u2203 S : Support \u03b1, \u2200 \u03c1 : AllPerm \u03b1, \u03c1\u1d41 \u2022 S = S \u2192 \u03c1 \u2198 h\u03b2 \u2022 s = s\n\ndef newSetEquiv {\u03b1 : \u039b} :\n    letI : Level := \u27e8\u03b1\u27e9\n    @TSet _ \u03b1 newModelData.toPreModelData \u2243 TSet \u03b1 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castTSet (D\u2081 := newModelData) (D\u2082 := globalModelData) rfl\n    (by rw [globalModelData, motive_eq, constructMotive, globalLtData_eq])\n\n@[simp]\ntheorem newSetEquiv_forget {\u03b1 : \u039b}\n    (x : letI : Level := \u27e8\u03b1\u27e9; @TSet _ \u03b1 newModelData.toPreModelData) :\n    (newSetEquiv x)\u1d41 = x\u1d41 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castTSet_forget (D\u2081 := newModelData) (D\u2082 := globalModelData) _ x\n\ndef allPermEquiv {\u03b1 : \u039b} :\n    letI : Level := \u27e8\u03b1\u27e9\n    NewPerm \u2243 AllPerm \u03b1 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castAllPerm (D\u2081 := newModelData) (D\u2082 := globalModelData) rfl\n    (by rw [globalModelData, motive_eq, constructMotive, globalLtData_eq])\n\n@[simp]\ntheorem allPermEquiv_forget {\u03b1 : \u039b} (\u03c1 : letI : Level := \u27e8\u03b1\u27e9; NewPerm) :\n    (allPermEquiv \u03c1)\u1d41 = \u03c1\u1d41 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castAllPerm_forget (D\u2081 := newModelData) (D\u2082 := globalModelData) _ \u03c1\n\ntheorem allPermEquiv_sderiv {\u03b1 \u03b2 : \u039b}\n    (\u03c1 : letI : Level := \u27e8\u03b1\u27e9; NewPerm) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) :\n    letI : Level := \u27e8\u03b1\u27e9\n    letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n    allPermEquiv \u03c1 \u2198 h\u03b2 = \u03c1.sderiv \u03b2 := by\n  letI : Level := \u27e8\u03b1\u27e9\n  letI : LeLevel \u03b1 := \u27e8le_rfl\u27e9\n  letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n  apply allPermForget_injective\n  rw [allPermSderiv_forget, allPermEquiv_forget, NewPerm.forget_sderiv]\n\ntheorem TSet.exists_of_symmetric {\u03b1 \u03b2 : \u039b} (s : Set (TSet \u03b2)) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1)\n    (hs : Symmetric s h\u03b2) :\n    \u2203 x : TSet \u03b1, \u2200 y : TSet \u03b2, y \u2208[h\u03b2] x \u2194 y \u2208 s := by\n  letI : Level := \u27e8\u03b1\u27e9\n  letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n  suffices \u2203 x : (@TSet _ \u03b1 newModelData.toPreModelData), \u2200 y : TSet \u03b2, y\u1d41 \u2208[h\u03b2] x\u1d41 \u2194 y \u2208 s by\n    obtain \u27e8x, hx\u27e9 := this\n    use newSetEquiv x\n    intro y\n    rw [\u2190 hx, \u2190 TSet.forget_mem_forget, newSetEquiv_forget]\n  obtain rfl | hs' := s.eq_empty_or_nonempty\n  \u00b7 use none\n    intro y\n    simp only [Set.mem_empty_iff_false, iff_false]\n    exact not_mem_none y\n  \u00b7 use some (Code.toSet \u27e8\u03b2, s, hs'\u27e9 ?_)\n    \u00b7 intro y\n      erw [mem_some_iff]\n      exact Code.mem_toSet _\n    \u00b7 obtain \u27e8S, hS\u27e9 := hs\n      use S\n      intro \u03c1 h\u03c1S\n      have := hS (allPermEquiv \u03c1) ?_\n      \u00b7 simp only [NewPerm.smul_mk, Code.mk.injEq, heq_eq_eq, true_and]\n        rwa [allPermEquiv_sderiv] at this\n      \u00b7 rwa [allPermEquiv_forget]\n\ntheorem TSet.exists_support {\u03b1 : \u039b} (x : TSet \u03b1) :\n    \u2203 S : Support \u03b1, \u2200 \u03c1 : AllPerm \u03b1, \u03c1\u1d41 \u2022 S = S \u2192 \u03c1 \u2022 x = x := by\n  letI : Level := \u27e8\u03b1\u27e9\n  obtain \u27e8S, hS\u27e9 := NewSet.exists_support (newSetEquiv.symm x)\n  use S\n  intro \u03c1 h\u03c1\n  have := @Support.Supports.supports _ _ _ newPreModelData _ _ _ hS (allPermEquiv.symm \u03c1) ?_\n  \u00b7 apply tSetForget_injective\n    have := congr_arg (\u00b7\u1d41) this\n    simp only at this\n    erw [@smul_forget _ _ newModelData (allPermEquiv.symm \u03c1) (newSetEquiv.symm x),\n      \u2190 allPermEquiv_forget, \u2190 newSetEquiv_forget, Equiv.apply_symm_apply,\n      Equiv.apply_symm_apply] at this\n    rwa [smul_forget]\n  \u00b7 rwa [\u2190 allPermEquiv_forget, Equiv.apply_symm_apply]\n\ntheorem TSet.symmetric {\u03b1 \u03b2 : \u039b} (x : TSet \u03b1) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) :\n    Symmetric {y : TSet \u03b2 | y \u2208[h\u03b2] x} h\u03b2 := by\n  obtain \u27e8S, hS\u27e9 := exists_support x\n  use S\n  intro \u03c1 h\u03c1\n  conv_rhs => rw [\u2190 hS \u03c1 h\u03c1]\n  simp only [\u2190 forget_mem_forget, smul_forget, StrSet.mem_smul_iff]\n  ext y\n  rw [Set.mem_smul_set_iff_inv_smul_mem, Set.mem_setOf_eq, Set.mem_setOf_eq,\n    smul_forget, allPermForget_inv, allPermSderiv_forget']\n\ntheorem tSet_ext' {\u03b1 \u03b2 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (x y : TSet \u03b1)\n    (h : \u2200 z : TSet \u03b2, z \u2208[h\u03b2] x \u2194 z \u2208[h\u03b2] y) : x = y :=\n  letI : Level := \u27e8\u03b1\u27e9\n  letI : LeLevel \u03b1 := \u27e8le_rfl\u27e9\n  letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n  tSet_ext h\u03b2 x y h\n\n@[simp]\ntheorem TSet.mem_smul_iff' {\u03b1 \u03b2 : TypeIndex}\n    {x : TSet \u03b2} {y : TSet \u03b1} (h : \u03b2 < \u03b1) (\u03c1 : AllPerm \u03b1) :\n    x \u2208[h] \u03c1 \u2022 y \u2194 \u03c1\u207b\u00b9 \u2198 h \u2022 x \u2208[h] y := by\n  letI : Level := \u27e8\u03b1.recBotCoe (Nonempty.some inferInstance) id\u27e9\n  letI : LeLevel \u03b1 := \u27e8\u03b1.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n    (show \u03b1.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n  letI : LtLevel \u03b2 := \u27e8h.trans_le LeLevel.elim\u27e9\n  exact mem_smul_iff h \u03c1  -- For some reason, using `exact` instead of term mode speeds this up!\n\ndef singleton {\u03b1 \u03b2 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (x : TSet \u03b2) : TSet \u03b1 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  letI : LeLevel \u03b1 := \u27e8le_rfl\u27e9\n  letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n  PreCoherentData.singleton h\u03b2 x\n\n@[simp]\ntheorem typedMem_singleton_iff' {\u03b1 \u03b2 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (x y : TSet \u03b2) :\n    y \u2208[h\u03b2] singleton h\u03b2 x \u2194 y = x :=\n  letI : Level := \u27e8\u03b1\u27e9\n  letI : LeLevel \u03b1 := \u27e8le_rfl\u27e9\n  letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n  typedMem_singleton_iff h\u03b2 x y\n\n@[simp]\ntheorem smul_singleton {\u03b1 \u03b2 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (x : TSet \u03b2) (\u03c1 : AllPerm \u03b1) :\n    \u03c1 \u2022 singleton h\u03b2 x = singleton h\u03b2 (\u03c1 \u2198 h\u03b2 \u2022 x) := by\n  apply tSet_ext' h\u03b2\n  intro z\n  rw [TSet.mem_smul_iff', allPerm_inv_sderiv', typedMem_singleton_iff', typedMem_singleton_iff',\n    inv_smul_eq_iff]\n\ntheorem singleton_injective {\u03b1 \u03b2 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) :\n    Function.Injective (singleton h\u03b2) := by\n  intro x y hxy\n  have := typedMem_singleton_iff' h\u03b2 x y\n  rw [hxy, typedMem_singleton_iff'] at this\n  exact (this.mp rfl).symm\n\n@[simp]\ntheorem singleton_inj {\u03b1 \u03b2 : \u039b} {h\u03b2 : (\u03b2 : TypeIndex) < \u03b1} {x y : TSet \u03b2} :\n    singleton h\u03b2 x = singleton h\u03b2 y \u2194 x = y :=\n  (singleton_injective h\u03b2).eq_iff\n\n", "theoremStatement": "theorem sUnion_singleton_symmetric_aux' {\u03b1 \u03b2 \u03b3 : \u039b}\n    (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (s : Set (TSet \u03b3)) (S : Support \u03b1)\n    (hS : \u2200 \u03c1 : AllPerm \u03b1, \u03c1\u1d41 \u2022 S = S \u2192 \u03c1 \u2198 h\u03b2 \u2022 singleton h\u03b3 '' s = singleton h\u03b3 '' s) :\n    letI : Level := \u27e8\u03b1\u27e9\n    letI : LeLevel \u03b1 := \u27e8le_rfl\u27e9\n    \u2200 (\u03c1 : AllPerm \u03b2), \u03c1\u1d41 \u2022 S.strong \u2198 h\u03b2 = S.strong \u2198 h\u03b2 \u2192 \u03c1 \u2198 h\u03b3 \u2022 s \u2286 s ", "theoremName": "ConNF.sUnion_singleton_symmetric_aux'", "fileCreated": {"commit": "6fdc87c6b30b73931407a372f1430ecf0fef7601", "date": "2024-12-03"}, "theoremCreated": {"commit": "1c08486feb882444888c228ce1501e92bb85e0e2", "date": "2025-01-07"}, "file": "ConNF/ConNF/Model/TTT.lean", "module": "ConNF.Model.TTT", "jsonFile": "ConNF.Model.TTT.jsonl", "positionMetadata": {"lineInFile": 216, "tokenPositionInFile": 7508, "theoremPositionInFile": 20}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 5, "repositoryPremises": true, "numRepositoryPremises": 43, "numPremises": 94}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  letI : Level := \u27e8\u03b1\u27e9\n  letI : LeLevel \u03b1 := \u27e8le_rfl\u27e9\n  letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n  rintro \u03c1 h\u03c1 _ \u27e8x, hx, rfl\u27e9\n  obtain \u27e8T, hT\u27e9 := exists_support x\n  obtain \u27e8\u03c1', h\u03c1'\u2081, h\u03c1'\u2082\u27e9 := Support.exists_allowable_of_fixes S.strong S.strong_strong T \u03c1 h\u03b3 h\u03c1\n  have h\u03c1's := hS \u03c1' (smul_eq_of_le (S.subsupport_strong.le) h\u03c1'\u2081)\n  have h\u03c1'x : \u03c1' \u2198 h\u03b2 \u2198 h\u03b3 \u2022 x = \u03c1 \u2198 h\u03b3 \u2022 x := by\n    apply hT.smul_eq_smul\n    simp only [allPermSderiv_forget', allPermSderiv_forget, WithBot.recBotCoe_coe, id_eq, h\u03c1'\u2082]\n  dsimp only\n  rw [\u2190 h\u03c1'x]\n  have := (Set.ext_iff.mp h\u03c1's (\u03c1' \u2198 h\u03b2 \u2022 singleton h\u03b3 x)).mp \u27e8_, Set.mem_image_of_mem _ hx, rfl\u27e9\n  rw [smul_singleton] at this\n  rwa [(singleton_injective h\u03b3).mem_set_image] at this", "proofType": "tactic", "proofLengthLines": 15, "proofLengthTokens": 698}}
{"srcContext": "import ConNF.Background.Rel\nimport ConNF.Base.Small\n\n/-!\n# Enumerations\n\nIn this file, we define enumerations of a type.\n\n## Main declarations\n\n* `ConNF.Enumeration`: The type family of enumerations.\n-/\n\nuniverse u\n\nopen Cardinal\n\nnamespace ConNF\n\nvariable [Params.{u}] {X Y : Type u}\n\n@[ext]\nstructure Enumeration (X : Type u) where\n  bound : \u03ba\n  rel : Rel \u03ba X\n  lt_bound : \u2200 i \u2208 rel.dom, i < bound\n  rel_coinjective : rel.Coinjective\n\nvariable {E F G : Enumeration X}\n\nnamespace Enumeration\n\ninstance : CoeTC (Enumeration X) (Set X) where\n  coe E := E.rel.codom\n\ninstance : Membership X (Enumeration X) where\n  mem E x := x \u2208 E.rel.codom\n\ntheorem mem_iff (x : X) (E : Enumeration X) :\n    x \u2208 E \u2194 x \u2208 E.rel.codom :=\n  Iff.rfl\n\ntheorem mem_congr {E F : Enumeration X} (h : E = F) :\n    \u2200 x, x \u2208 E \u2194 x \u2208 F := by\n  intro x\n  rw [h]\n\ntheorem dom_small (E : Enumeration X) :\n    Small E.rel.dom :=\n  (iio_small E.bound).mono E.lt_bound\n\ntheorem coe_small (E : Enumeration X) :\n    Small (E : Set X) :=\n  small_codom_of_small_dom E.rel_coinjective E.dom_small\n\ntheorem graph'_small (E : Enumeration X) :\n    Small E.rel.graph' :=\n  small_graph' E.dom_small E.coe_small\n\nnoncomputable def empty : Enumeration X where\n  bound := 0\n  rel _ _ := False\n  lt_bound _ h := by cases h; contradiction\n  rel_coinjective := by constructor; intros; contradiction\n\n@[simp]\ntheorem not_mem_empty (x : X) : x \u2209 Enumeration.empty := by\n  rintro \u27e8i, h\u27e9\n  cases h\n\nnoncomputable def singleton (x : X) : Enumeration X where\n  bound := 1\n  rel i y := i = 0 \u2227 y = x\n  lt_bound i h := by\n    have : i = 0 := by simpa only [Rel.dom, exists_eq_right, Set.setOf_eq_eq_singleton,\n      Set.mem_singleton_iff] using h\n    rw [this, \u03baEquiv_lt, \u2190 Subtype.coe_lt_coe, \u03baEquiv_ofNat, \u03baEquiv_ofNat, Nat.cast_zero,\n      Nat.cast_one]\n    exact zero_lt_one\n  rel_coinjective := by\n    constructor\n    cc\n\n@[simp]\ntheorem mem_singleton_iff (x y : X) :\n    y \u2208 singleton x \u2194 y = x := by\n  constructor\n  \u00b7 rintro \u27e8_, _, h\u27e9\n    exact h\n  \u00b7 intro h\n    exact \u27e80, rfl, h\u27e9\n\ntheorem singleton_injective : Function.Injective (singleton : X \u2192 Enumeration X) := by\n  intro x y h\n  have := mem_singleton_iff y x\n  rw [\u2190 h, mem_singleton_iff] at this\n  exact this.mp rfl\n\n/-!\n## Cardinality bounds on enumerations\n-/\n\nend Enumeration\n\ntheorem card_enumeration_ge (X : Type u) : #X \u2264 #(Enumeration X) :=\n  mk_le_of_injective Enumeration.singleton_injective\n\ndef enumerationEmbedding (X : Type u) : Enumeration X \u21aa \u03ba \u00d7 {s : Set (\u03ba \u00d7 X) | Small s} where\n  toFun E := (E.bound, \u27e8E.rel.graph', E.graph'_small\u27e9)\n  inj' := by\n    intro E F h\n    rw [Prod.mk.injEq, Subtype.mk.injEq] at h\n    exact Enumeration.ext h.1 (Rel.graph'_injective h.2)\n\ntheorem card_enumeration_le (h : #X \u2264 #\u03bc) : #(Enumeration X) \u2264 #\u03bc := by\n  apply (mk_le_of_injective (enumerationEmbedding X).injective).trans\n  rw [mk_prod, lift_id, lift_id]\n  apply mul_le_of_le aleph0_lt_\u03bc.le \u03ba_le_\u03bc\n  apply card_small_le\n  rw [mk_prod, lift_id, lift_id]\n  exact mul_le_of_le aleph0_lt_\u03bc.le \u03ba_le_\u03bc h\n\ntheorem card_enumeration_lt (h : #X < #\u03bc) : #(Enumeration X) < #\u03bc := by\n  apply (mk_le_of_injective (enumerationEmbedding X).injective).trans_lt\n  rw [mk_prod, lift_id, lift_id]\n  apply mul_lt_of_lt aleph0_lt_\u03bc.le \u03ba_lt_\u03bc\n  apply (mk_subtype_le _).trans_lt\n  rw [mk_set]\n  apply \u03bc_isStrongLimit.2\n  rw [mk_prod, lift_id, lift_id]\n  exact mul_lt_of_lt aleph0_lt_\u03bc.le \u03ba_lt_\u03bc h\n\ntheorem card_enumeration_eq (h : #X = #\u03bc) : #(Enumeration X) = #\u03bc :=\n  le_antisymm (card_enumeration_le h.le) (h.symm.le.trans (card_enumeration_ge X))\n\nnamespace Enumeration\n\n/-!\n## Enumerations from sets\n-/\n\ntheorem exists_equiv (s : Set X) (hs : Small s) :\n    Nonempty ((i : \u03ba) \u00d7 (s \u2243 Set.Iio i)) := by\n  rw [Small] at hs\n  refine \u27e8\u03baEquiv.symm \u27e8(#s).ord, ?_\u27e9, Nonempty.some ?_\u27e9\n  \u00b7 rwa [Set.mem_Iio, ord_lt_ord]\n  \u00b7 rw [\u2190 Cardinal.eq, Set.Iio, \u03ba_card_Iio_eq, Equiv.apply_symm_apply, card_ord]\n\nnoncomputable def ofSet (s : Set X) (hs : Small s) : Enumeration X where\n  bound := (exists_equiv s hs).some.1\n  rel i x := \u2203 h, i = (exists_equiv s hs).some.2 \u27e8x, h\u27e9\n  lt_bound := by\n    rintro _ \u27e8x, h, rfl\u27e9\n    exact ((exists_equiv s hs).some.2 \u27e8x, h\u27e9).prop\n  rel_coinjective := by\n    constructor\n    rintro x y i \u27e8hx, hix\u27e9 \u27e8hy, hiy\u27e9\n    rw [hix] at hiy\n    cases (exists_equiv s hs).some.2.injective (Subtype.coe_injective hiy)\n    rfl\n\n@[simp]\ntheorem mem_ofSet_iff (s : Set X) (hs : Small s) (x : X) :\n    x \u2208 ofSet s hs \u2194 x \u2208 s := by\n  constructor\n  \u00b7 rintro \u27e8i, hx, _\u27e9\n    exact hx\n  \u00b7 intro h\n    exact \u27e8(exists_equiv s hs).some.2 \u27e8x, h\u27e9, h, rfl\u27e9\n\n@[simp]\ntheorem ofSet_coe (s : Set X) (hs : Small s) :\n    (ofSet s hs : Set X) = s := by\n  ext x\n  rw [\u2190 mem_ofSet_iff s hs]\n  rfl\n\n/-!\n## Operations on enumerations\n-/\n\ndef image (E : Enumeration X) (f : X \u2192 Y) : Enumeration Y where\n  bound := E.bound\n  rel i y := \u2203 x, E.rel i x \u2227 f x = y\n  lt_bound := by\n    rintro i \u27e8_, x, hi, rfl\u27e9\n    exact E.lt_bound i \u27e8x, hi\u27e9\n  rel_coinjective := by\n    constructor\n    rintro i _ _ \u27e8x\u2081, hx\u2081, rfl\u27e9 \u27e8x\u2082, hx\u2082, rfl\u27e9\n    rw [E.rel_coinjective.coinjective hx\u2081 hx\u2082]\n\n@[simp]\ntheorem image_bound {f : X \u2192 Y} :\n    (E.image f).bound = E.bound :=\n  rfl\n\ntheorem image_rel {f : X \u2192 Y} (i : \u03ba) (y : Y) :\n    (E.image f).rel i y \u2194 \u2203 x, E.rel i x \u2227 f x = y :=\n  Iff.rfl\n\n@[simp]\ntheorem mem_image {f : X \u2192 Y} (y : Y) :\n    y \u2208 E.image f \u2194 y \u2208 f '' E := by\n  constructor\n  \u00b7 rintro \u27e8i, x, hx, rfl\u27e9\n    exact \u27e8x, \u27e8i, hx\u27e9, rfl\u27e9\n  \u00b7 rintro \u27e8x, \u27e8i, hx\u27e9, rfl\u27e9\n    exact \u27e8i, x, hx, rfl\u27e9\n\ndef invImage (E : Enumeration X) (f : Y \u2192 X) (hf : f.Injective) : Enumeration Y where\n  bound := E.bound\n  rel i y := E.rel i (f y)\n  lt_bound := by\n    rintro i \u27e8y, hy\u27e9\n    exact E.lt_bound i \u27e8f y, hy\u27e9\n  rel_coinjective := by\n    constructor\n    intro i y\u2081 y\u2082 h\u2081 h\u2082\n    exact hf <| E.rel_coinjective.coinjective h\u2081 h\u2082\n\ntheorem invImage_rel {f : Y \u2192 X} {hf : f.Injective} (i : \u03ba) (y : Y) :\n    (E.invImage f hf).rel i y \u2194 E.rel i (f y) :=\n  Iff.rfl\n\n@[simp]\ntheorem mem_invImage {f : Y \u2192 X} {hf : f.Injective} (y : Y) :\n    y \u2208 E.invImage f hf \u2194 f y \u2208 E :=\n  Iff.rfl\n\ndef comp (E : Enumeration X) (r : Rel X Y) (hr : r.Coinjective) : Enumeration Y where\n  bound := E.bound\n  rel := E.rel.comp r\n  lt_bound := by\n    rintro i \u27e8y, x, hy\u27e9\n    exact E.lt_bound i \u27e8x, hy.1\u27e9\n  rel_coinjective := E.rel_coinjective.comp hr\n\ninstance {G X : Type _} [Group G] [MulAction G X] :\n    SMul G (Enumeration X) where\n  smul \u03c0 E := E.invImage (\u03bb x \u21a6 \u03c0\u207b\u00b9 \u2022 x) (MulAction.injective \u03c0\u207b\u00b9)\n\n@[simp]\ntheorem smul_rel {G X : Type _} [Group G] [MulAction G X]\n    (\u03c0 : G) (E : Enumeration X) (i : \u03ba) (x : X) :\n    (\u03c0 \u2022 E).rel i x \u2194 E.rel i (\u03c0\u207b\u00b9 \u2022 x) :=\n  Iff.rfl\n\n@[simp]\ntheorem mem_smul {G X : Type _} [Group G] [MulAction G X]\n    (\u03c0 : G) (E : Enumeration X) (x : X) :\n    x \u2208 \u03c0 \u2022 E \u2194 \u03c0\u207b\u00b9 \u2022 x \u2208 E :=\n  Iff.rfl\n\n@[simp]\ntheorem smul_rel_dom {G X : Type _} [Group G] [MulAction G X]\n    (\u03c0 : G) (E : Enumeration X) :\n    (\u03c0 \u2022 E).rel.dom = E.rel.dom := by\n  ext i\n  constructor\n  \u00b7 rintro \u27e8x, h\u27e9\n    exact \u27e8\u03c0\u207b\u00b9 \u2022 x, h\u27e9\n  \u00b7 rintro \u27e8x, h\u27e9\n    use \u03c0 \u2022 x\n    rwa [smul_rel, inv_smul_smul]\n\nopen scoped Pointwise in\n@[simp]\ntheorem smul_rel_codom {G X : Type _} [Group G] [MulAction G X]\n    (\u03c0 : G) (E : Enumeration X) :\n    (\u03c0 \u2022 E).rel.codom = \u03c0 \u2022 E.rel.codom := by\n  ext x\n  constructor\n  \u00b7 rintro \u27e8i, h\u27e9\n    exact \u27e8\u03c0\u207b\u00b9 \u2022 x, \u27e8i, h\u27e9, smul_inv_smul \u03c0 x\u27e9\n  \u00b7 rintro \u27e8x, \u27e8i, h\u27e9, rfl\u27e9\n    use i\n    rwa [smul_rel, inv_smul_smul]\n\nopen scoped Pointwise in\n@[simp]\ntheorem smul_coe {G X : Type _} [Group G] [MulAction G X]\n    (\u03c0 : G) (E : Enumeration X) :\n    ((\u03c0 \u2022 E : Enumeration X) : Set X) = \u03c0 \u2022 (E : Set X) :=\n  smul_rel_codom \u03c0 E\n\ninstance {G X : Type _} [Group G] [MulAction G X] :\n    MulAction G (Enumeration X) where\n  one_smul E := by\n    ext i x\n    \u00b7 rfl\n    \u00b7 rw [smul_rel, inv_one, one_smul]\n  mul_smul \u03c0\u2081 \u03c0\u2082 E := by\n    ext i x\n    \u00b7 rfl\n    \u00b7 rw [smul_rel, smul_rel, smul_rel, mul_inv_rev, mul_smul]\n\ntheorem mem_smul_iff {G X : Type _} [Group G] [MulAction G X] (x : X) (g : G) (E : Enumeration X) :\n    x \u2208 g \u2022 E \u2194 g\u207b\u00b9 \u2022 x \u2208 E :=\n  Iff.rfl\n\ntheorem eq_of_smul_eq_smul {G X : Type _} [Group G] [MulAction G X] {g\u2081 g\u2082 : G} {E : Enumeration X}\n    (h : g\u2081 \u2022 E = g\u2082 \u2022 E) (x : X) (hx : x \u2208 E) : g\u2081 \u2022 x = g\u2082 \u2022 x := by\n  obtain \u27e8i, hi\u27e9 := hx\n  have : (g\u2081 \u2022 E).rel i (g\u2081 \u2022 x) := by rwa [smul_rel, inv_smul_smul]\n  rw [h] at this\n  have := E.rel_coinjective.coinjective hi this\n  exact (eq_inv_smul_iff.mp this).symm\n\ntheorem eq_of_smul_eq {G X : Type _} [Group G] [MulAction G X] {g : G} {E : Enumeration X}\n    (h : g \u2022 E = E) (x : X) (hx : x \u2208 E) : g \u2022 x = x := by\n  have := eq_of_smul_eq_smul (g\u2081 := g) (g\u2082 := 1) ?_ x hx\n  \u00b7 rwa [one_smul] at this\n  \u00b7 rwa [one_smul]\n\n@[simp]\ntheorem smul_singleton {G X : Type _} [Group G] [MulAction G X] {g : G} {x : X} :\n    g \u2022 singleton x = singleton (g \u2022 x) := by\n  apply Enumeration.ext\n  \u00b7 rfl\n  \u00b7 ext i y\n    rw [smul_rel]\n    simp only [singleton, and_congr_right_iff, inv_smul_eq_iff]\n\n/-!\n## Concatenation of enumerations\n-/\n\nnoncomputable instance : Add (Enumeration X) where\n  add E F := {\n    bound := E.bound + F.bound\n    rel := E.rel \u2294 Rel.comp (E.bound + \u00b7).graph.inv F.rel\n    lt_bound := by\n      rintro i \u27e8x, hi | \u27e8j, rfl, hjx\u27e9\u27e9\n      \u00b7 exact (E.lt_bound i \u27e8x, hi\u27e9).trans_le (\u03ba_le_add E.bound F.bound)\n      \u00b7 rw [add_lt_add_iff_left]\n        exact F.lt_bound j \u27e8x, hjx\u27e9\n    rel_coinjective := by\n      constructor\n      rintro x y i (hix | \u27e8j, hj, hjx\u27e9) (hiy | \u27e8k, hk, hky\u27e9)\n      \u00b7 exact E.rel_coinjective.coinjective hix hiy\n      \u00b7 cases hk\n        have := E.lt_bound _ \u27e8x, hix\u27e9\n        rw [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le k).not_lt this\n      \u00b7 cases hj\n        have := E.lt_bound _ \u27e8y, hiy\u27e9\n        rw [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j).not_lt this\n      \u00b7 cases hj\n        simp only [Rel.inv, flip, Function.graph_def, add_right_inj] at hk\n        cases hk\n        exact F.rel_coinjective.coinjective hjx hky\n  }\n\n@[simp]\ntheorem add_bound (E F : Enumeration X) :\n    (E + F).bound = E.bound + F.bound :=\n  rfl\n\ntheorem rel_add_iff {E F : Enumeration X} (i : \u03ba) (x : X) :\n    (E + F).rel i x \u2194 E.rel i x \u2228 \u2203 j, E.bound + j = i \u2227 F.rel j x :=\n  Iff.rfl\n\n", "theoremStatement": "theorem add_rel_dom {X : Type _} (E F : Enumeration X) :\n    (E + F).rel.dom = E.rel.dom \u222a (E.bound + \u00b7) '' F.rel.dom ", "theoremName": "ConNF.Enumeration.add_rel_dom", "fileCreated": {"commit": "39c33b4a743bea62dbcc549548b712ffd38ca65c", "date": "2024-12-05"}, "theoremCreated": {"commit": "6709914ae7f5cd3e2bb24b413e09aa844554d234", "date": "2024-11-30"}, "file": "ConNF/ConNF/ModelData/Enumeration.lean", "module": "ConNF.ModelData.Enumeration", "jsonFile": "ConNF.ModelData.Enumeration.jsonl", "positionMetadata": {"lineInFile": 365, "tokenPositionInFile": 10091, "theoremPositionInFile": 31}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 5, "repositoryPremises": true, "numRepositoryPremises": 9, "numPremises": 49}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  ext i\n  simp only [Rel.dom, rel_add_iff, Set.mem_setOf_eq, Set.mem_union, Set.mem_image]\n  aesop", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 104}}
{"srcContext": "import ConNF.Model.Hailperin\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal ConNF.TSet\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\ntheorem ext (x y : TSet \u03b1) :\n    (\u2200 z : TSet \u03b2, z \u2208' x \u2194 z \u2208' y) \u2192 x = y :=\n  tSet_ext' h\u03b2 x y\n\ndef inter (x y : TSet \u03b1) : TSet \u03b1 :=\n  (TSet.exists_inter h\u03b2 x y).choose\n\nnotation:69 x:69 \" \u2293[\" h \"] \" y:69 => _root_.ConNF.inter h x y\nnotation:69 x:69 \" \u2293' \" y:69 => x \u2293[by assumption] y\n\n@[simp]\ntheorem mem_inter_iff (x y : TSet \u03b1) :\n    \u2200 z : TSet \u03b2, z \u2208' x \u2293' y \u2194 z \u2208' x \u2227 z \u2208' y :=\n  (TSet.exists_inter h\u03b2 x y).choose_spec\n\ndef compl (x : TSet \u03b1) : TSet \u03b1 :=\n  (TSet.exists_compl h\u03b2 x).choose\n\nnotation:1024 x:1024 \" \u1d9c[\" h \"]\" => _root_.ConNF.compl h x\nnotation:1024 x:1024 \" \u1d9c'\" => x\u1d9c[by assumption]\n\n@[simp]\ntheorem mem_compl_iff (x : TSet \u03b1) :\n    \u2200 z : TSet \u03b2, z \u2208' x\u1d9c' \u2194 \u00acz \u2208' x :=\n  (TSet.exists_compl h\u03b2 x).choose_spec\n\nnotation:1024 \"{\" x \"}[\" h \"]\" => _root_.ConNF.singleton h x\nnotation:1024 \"{\" x \"}'\" => {x}[by assumption]\n\n@[simp]\ntheorem mem_singleton_iff (x y : TSet \u03b2) :\n    y \u2208' {x}' \u2194 y = x :=\n  typedMem_singleton_iff' h\u03b2 x y\n\nnotation:1024 \"{\" x \", \" y \"}[\" h \"]\" => _root_.ConNF.TSet.up h x y\nnotation:1024 \"{\" x \", \" y \"}'\" => {x, y}[by assumption]\n\n@[simp]\ntheorem mem_up_iff (x y z : TSet \u03b2) :\n    z \u2208' {x, y}' \u2194 z = x \u2228 z = y :=\n  TSet.mem_up_iff h\u03b2 x y z\n\nnotation:1024 \"\u27e8\" x \", \" y \"\u27e9[\" h \", \" h' \"]\" => _root_.ConNF.TSet.op h h' x y\nnotation:1024 \"\u27e8\" x \", \" y \"\u27e9'\" => \u27e8x, y\u27e9[by assumption, by assumption]\n\ntheorem op_def (x y : TSet \u03b3) :\n    (\u27e8x, y\u27e9' : TSet \u03b1) = { {x}', {x, y}' }' :=\n  rfl\n\ndef singletonImage' (x : TSet \u03b2) : TSet \u03b1 :=\n  (TSet.exists_singletonImage h\u03b2 h\u03b3 h\u03b4 h\u03b5 x).choose\n\n@[simp]\ntheorem singletonImage'_spec (x : TSet \u03b2) :\n    \u2200 z w,\n    \u27e8 {z}', {w}' \u27e9' \u2208' singletonImage' h\u03b2 h\u03b3 h\u03b4 h\u03b5 x \u2194 \u27e8z, w\u27e9' \u2208' x :=\n  (TSet.exists_singletonImage h\u03b2 h\u03b3 h\u03b4 h\u03b5 x).choose_spec\n\ndef insertion2' (x : TSet \u03b3) : TSet \u03b1 :=\n  (TSet.exists_insertion2 h\u03b2 h\u03b3 h\u03b4 h\u03b5 h\u03b6 x).choose\n\n@[simp]\ntheorem insertion2'_spec (x : TSet \u03b3) :\n    \u2200 a b c, \u27e8 { {a}' }', \u27e8b, c\u27e9' \u27e9' \u2208' insertion2' h\u03b2 h\u03b3 h\u03b4 h\u03b5 h\u03b6 x \u2194\n    \u27e8a, c\u27e9' \u2208' x :=\n  (TSet.exists_insertion2 h\u03b2 h\u03b3 h\u03b4 h\u03b5 h\u03b6 x).choose_spec\n\ndef insertion3' (x : TSet \u03b3) : TSet \u03b1 :=\n  (TSet.exists_insertion3 h\u03b2 h\u03b3 h\u03b4 h\u03b5 h\u03b6 x).choose\n\ntheorem insertion3'_spec (x : TSet \u03b3) :\n    \u2200 a b c, \u27e8 { {a}' }', \u27e8b, c\u27e9' \u27e9' \u2208' insertion3' h\u03b2 h\u03b3 h\u03b4 h\u03b5 h\u03b6 x \u2194\n    \u27e8a, b\u27e9' \u2208' x :=\n  (TSet.exists_insertion3 h\u03b2 h\u03b3 h\u03b4 h\u03b5 h\u03b6 x).choose_spec\n\ndef vCross (x : TSet \u03b3) : TSet \u03b1 :=\n  (TSet.exists_cross h\u03b2 h\u03b3 h\u03b4 x).choose\n\n@[simp]\ntheorem vCross_spec (x : TSet \u03b3) :\n    \u2200 a, a \u2208' vCross h\u03b2 h\u03b3 h\u03b4 x \u2194 \u2203 b c, a = \u27e8b, c\u27e9' \u2227 c \u2208' x :=\n  (TSet.exists_cross h\u03b2 h\u03b3 h\u03b4 x).choose_spec\n\ndef typeLower (x : TSet \u03b1) : TSet \u03b4 :=\n  (TSet.exists_typeLower h\u03b2 h\u03b3 h\u03b4 h\u03b5 x).choose\n\n", "theoremStatement": "@[simp]\ntheorem mem_typeLower_iff (x : TSet \u03b1) :\n    \u2200 a, a \u2208' typeLower h\u03b2 h\u03b3 h\u03b4 h\u03b5 x \u2194 \u2200 b, \u27e8 b, {a}' \u27e9' \u2208' x ", "theoremName": "ConNF.mem_typeLower_iff", "fileCreated": {"commit": "b12701769822aaf5451982e26d7b7d1c2f21b137", "date": "2024-04-11"}, "theoremCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "file": "ConNF/ConNF/Model/Result.lean", "module": "ConNF.Model.Result", "jsonFile": "ConNF.Model.Result.jsonl", "positionMetadata": {"lineInFile": 109, "tokenPositionInFile": 2983, "theoremPositionInFile": 27}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 13, "numPremises": 25}, "proofMetadata": {"hasProof": true, "proof": ":=\n  (TSet.exists_typeLower h\u03b2 h\u03b3 h\u03b4 h\u03b5 x).choose_spec", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 54}}
{"srcContext": "import ConNF.Base.TypeIndex\n\n/-!\n# Paths of type indices\n\nIn this file, we define the notion of a *path*, and the derivative and coderivative operations.\n\n## Main declarations\n\n* `ConNF.Path`: A path of type indices.\n* `ConNF.Path.recSderiv`, `ConNF.Path.recSderivLe`, `ConNF.Path.recSderivGlobal`:\n    Downwards induction principles for paths.\n* `ConNF.Path.recScoderiv`: An upwards induction principle for paths.\n-/\n\nuniverse u\n\nopen Cardinal WithBot\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 : TypeIndex}\n\n/-- A path of type indices starting at `\u03b1` and ending at `\u03b2` is a finite sequence of type indices\n`\u03b1 > ... > \u03b2`. -/\ninductive Path (\u03b1 : TypeIndex) : TypeIndex \u2192 Type u\n  | nil : Path \u03b1 \u03b1\n  | cons {\u03b2 \u03b3 : TypeIndex} : Path \u03b1 \u03b2 \u2192 \u03b3 < \u03b2 \u2192 Path \u03b1 \u03b3\n\n@[inherit_doc] infix:70 \" \u219d \"  => Path\n\ndef Path.single {\u03b1 \u03b2 : TypeIndex} (h : \u03b2 < \u03b1) : \u03b1 \u219d \u03b2 :=\n  .cons .nil h\n\n/-- Typeclass for the `\u2198` notation. -/\nclass SingleDerivative (X : Type _) (Y : outParam <| Type _)\n    (\u03b2 : outParam TypeIndex) (\u03b3 : TypeIndex) where\n  sderiv : X \u2192 \u03b3 < \u03b2 \u2192 Y\n\n/-- Typeclass for the `\u21d8` notation. -/\nclass Derivative (X : Type _) (Y : outParam <| Type _)\n    (\u03b2 : outParam TypeIndex) (\u03b3 : TypeIndex) extends SingleDerivative X Y \u03b2 \u03b3 where\n  deriv : X \u2192 \u03b2 \u219d \u03b3 \u2192 Y\n  sderiv x h := deriv x (.single h)\n  deriv_single : \u2200 x : X, \u2200 h : \u03b3 < \u03b2, deriv x (.single h) = sderiv x h := by intros; rfl\n\n/-- Typeclass for the `\u2198.` notation. -/\nclass BotSingleDerivative (X : Type _) (Y : outParam <| Type _) where\n  botSderiv : X \u2192 Y\n\n/-- Typeclass for the `\u21d8.` notation. -/\nclass BotDerivative (X : Type _) (Y : outParam <| Type _) (\u03b2 : outParam TypeIndex)\n    extends BotSingleDerivative X Y where\n  botDeriv : X \u2192 \u03b2 \u219d \u22a5 \u2192 Y\n  /-- We often need to do case analysis on `\u03b2` to show that it's a proper type index here.\n  This case check doesn't need to be done in most actual use cases of the notation. -/\n  botDeriv_single : \u2200 x : X, \u2200 h : \u22a5 < \u03b2, botDeriv x (.single h) = botSderiv x\n\n/-- Typeclass for the `\u2197` notation. -/\nclass SingleCoderivative (X : Type _) (Y : outParam <| Type _)\n    (\u03b2 : TypeIndex) (\u03b3 : outParam TypeIndex) where\n  scoderiv : X \u2192 \u03b3 < \u03b2 \u2192 Y\n\n/-- Typeclass for the `\u21d7` notation. -/\nclass Coderivative (X : Type _) (Y : outParam <| Type _)\n    (\u03b2 : TypeIndex) (\u03b3 : outParam TypeIndex) extends SingleCoderivative X Y \u03b2 \u03b3 where\n  coderiv : X \u2192 \u03b2 \u219d \u03b3 \u2192 Y\n  scoderiv x h := coderiv x (.single h)\n  coderiv_single : \u2200 x : X, \u2200 h : \u03b3 < \u03b2, coderiv x (.single h) = scoderiv x h := by intros; rfl\n\ninfixl:75 \" \u2198 \" => SingleDerivative.sderiv\ninfixl:75 \" \u21d8 \" => Derivative.deriv\npostfix:75 \" \u2198.\" => BotSingleDerivative.botSderiv\ninfixl:75 \" \u21d8. \" => BotDerivative.botDeriv\ninfixl:75 \" \u2197 \" => SingleCoderivative.scoderiv\ninfixl:75 \" \u21d7 \" => Coderivative.coderiv\n\n@[simp]\ntheorem deriv_single {X Y : Type _} [Derivative X Y \u03b2 \u03b3] (x : X) (h : \u03b3 < \u03b2) :\n    x \u21d8 .single h = x \u2198 h :=\n  Derivative.deriv_single x h\n\n@[simp]\ntheorem coderiv_single {X Y : Type _} [Coderivative X Y \u03b2 \u03b3] (x : X) (h : \u03b3 < \u03b2) :\n    x \u21d7 .single h = x \u2197 h :=\n  Coderivative.coderiv_single x h\n\n@[simp]\ntheorem botDeriv_single {X Y : Type _} [BotDerivative X Y \u03b2] (x : X) (h : \u22a5 < \u03b2) :\n    x \u21d8. .single h = x \u2198. :=\n  BotDerivative.botDeriv_single x h\n\n/-!\n## Downwards recursion along paths\n-/\n\ninstance : SingleDerivative (\u03b1 \u219d \u03b2) (\u03b1 \u219d \u03b3) \u03b2 \u03b3 where\n  sderiv := .cons\n\n/-- The downwards recursion principle for paths. -/\n@[elab_as_elim, induction_eliminator, cases_eliminator]\ndef Path.recSderiv {motive : \u2200 \u03b2, \u03b1 \u219d \u03b2 \u2192 Sort _}\n    (nil : motive \u03b1 .nil)\n    (sderiv : \u2200 \u03b2 \u03b3 (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2), motive \u03b2 A \u2192 motive \u03b3 (A \u2198 h)) :\n    {\u03b2 : TypeIndex} \u2192 (A : \u03b1 \u219d \u03b2) \u2192 motive \u03b2 A\n  | _, .nil => nil\n  | _, .cons A h => sderiv _ _ A h (recSderiv nil sderiv A)\n\n@[simp]\ntheorem Path.recSderiv_nil {motive : \u2200 \u03b2, \u03b1 \u219d \u03b2 \u2192 Sort _}\n    (nil : motive \u03b1 .nil)\n    (sderiv : \u2200 \u03b2 \u03b3 (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2), motive \u03b2 A \u2192 motive \u03b3 (A \u2198 h)) :\n    recSderiv (motive := motive) nil sderiv .nil = nil :=\n  rfl\n\n@[simp]\ntheorem Path.recSderiv_sderiv {motive : \u2200 \u03b2, \u03b1 \u219d \u03b2 \u2192 Sort _}\n    (nil : motive \u03b1 .nil)\n    (sderiv : \u2200 \u03b2 \u03b3 (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2), motive \u03b2 A \u2192 motive \u03b3 (A \u2198 h))\n    {\u03b2 \u03b3 : TypeIndex} (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2) :\n    recSderiv (motive := motive) nil sderiv (A \u2198 h) = sderiv \u03b2 \u03b3 A h (recSderiv nil sderiv A) :=\n  rfl\n\ntheorem Path.le (A : \u03b1 \u219d \u03b2) : \u03b2 \u2264 \u03b1 := by\n  induction A with\n  | nil => exact le_rfl\n  | sderiv \u03b2 \u03b3 _A h h' => exact h.le.trans h'\n\n/-- The downwards recursion principle for paths, specialised to the case where the motive at `\u03b2`\nonly depends on the fact that `\u03b2 \u2264 \u03b1`. -/\ndef Path.recSderivLe {motive : \u2200 \u03b2 \u2264 \u03b1, Sort _}\n    (nil : motive \u03b1 le_rfl)\n    (sderiv : \u2200 \u03b2 \u03b3, \u2200 (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2), motive \u03b2 A.le \u2192 motive \u03b3 (h.le.trans A.le)) :\n    {\u03b2 : TypeIndex} \u2192 (A : \u03b1 \u219d \u03b2) \u2192 motive \u03b2 A.le :=\n  Path.recSderiv (motive := \u03bb \u03b2 A \u21a6 motive \u03b2 A.le) nil sderiv\n\n@[simp]\ntheorem Path.recSderivLe_nil {motive : \u2200 \u03b2 \u2264 \u03b1, Sort _}\n    (nil : motive \u03b1 le_rfl)\n    (sderiv : \u2200 \u03b2 \u03b3 (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2), motive \u03b2 A.le \u2192 motive \u03b3 (h.le.trans A.le)) :\n    recSderivLe (motive := motive) nil sderiv .nil = nil :=\n  rfl\n\n@[simp]\ntheorem Path.recSderivLe_sderiv {motive : \u2200 \u03b2 \u2264 \u03b1, Sort _}\n    (nil : motive \u03b1 le_rfl)\n    (sderiv : \u2200 \u03b2 \u03b3 (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2), motive \u03b2 A.le \u2192 motive \u03b3 (h.le.trans A.le))\n    {\u03b2 \u03b3 : TypeIndex} (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2) :\n    recSderivLe (motive := motive) nil sderiv (A \u2198 h) = sderiv \u03b2 \u03b3 A h (recSderiv nil sderiv A) :=\n  rfl\n\n/-- The downwards recursion principle for paths, specialised to the case where the motive is not\ndependent on the relation of `\u03b2` to `\u03b1`. -/\n@[elab_as_elim]\ndef Path.recSderivGlobal {motive : TypeIndex \u2192 Sort _}\n    (nil : motive \u03b1)\n    (sderiv : \u2200 \u03b2 \u03b3, \u03b1 \u219d \u03b2 \u2192 \u03b3 < \u03b2 \u2192 motive \u03b2 \u2192 motive \u03b3) :\n    {\u03b2 : TypeIndex} \u2192 \u03b1 \u219d \u03b2 \u2192 motive \u03b2 :=\n  Path.recSderiv (motive := \u03bb \u03b2 _ \u21a6 motive \u03b2) nil sderiv\n\n@[simp]\ntheorem Path.recSderivGlobal_nil {motive : TypeIndex \u2192 Sort _}\n    (nil : motive \u03b1)\n    (sderiv : \u2200 \u03b2 \u03b3, \u03b1 \u219d \u03b2 \u2192 \u03b3 < \u03b2 \u2192 motive \u03b2 \u2192 motive \u03b3) :\n    recSderivGlobal (motive := motive) nil sderiv .nil = nil :=\n  rfl\n\n@[simp]\ntheorem Path.recSderivGlobal_sderiv {motive : TypeIndex \u2192 Sort _}\n    (nil : motive \u03b1)\n    (sderiv : \u2200 \u03b2 \u03b3, \u03b1 \u219d \u03b2 \u2192 \u03b3 < \u03b2 \u2192 motive \u03b2 \u2192 motive \u03b3)\n    {\u03b2 \u03b3 : TypeIndex} (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2) :\n    recSderivGlobal (motive := motive) nil sderiv (A \u2198 h) =\n      sderiv \u03b2 \u03b3 A h (recSderiv nil sderiv A) :=\n  rfl\n\n/-!\n## Derivatives of paths\n-/\n\ninstance : Derivative (\u03b1 \u219d \u03b2) (\u03b1 \u219d \u03b3) \u03b2 \u03b3 where\n  deriv A := Path.recSderivGlobal A (\u03bb _ _ _ h B \u21a6 B \u2198 h)\n\ninstance : BotDerivative (\u03b1 \u219d \u03b2) (\u03b1 \u219d \u22a5) \u03b2 where\n  botDeriv A B := A \u21d8 B\n  botSderiv A :=\n    match \u03b2 with\n      | \u22a5 => A\n      | (\u03b2 : \u039b) => A \u2198 bot_lt_coe \u03b2\n  botDeriv_single A h := by\n    cases \u03b2 using WithBot.recBotCoe with\n    | bot => cases lt_irrefl \u22a5 h\n    | coe => rfl\n\ninstance : Coderivative (\u03b2 \u219d \u03b3) (\u03b1 \u219d \u03b3) \u03b1 \u03b2 where\n  coderiv A B := B \u21d8 A\n\n@[simp]\ntheorem Path.deriv_nil (A : \u03b1 \u219d \u03b2) :\n    A \u21d8 .nil = A :=\n  rfl\n\n@[simp]\ntheorem Path.deriv_sderiv (A : \u03b1 \u219d \u03b2) (B : \u03b2 \u219d \u03b3) (h : \u03b4 < \u03b3) :\n    A \u21d8 (B \u2198 h) = A \u21d8 B \u2198 h :=\n  rfl\n\n@[simp]\ntheorem Path.nil_deriv (A : \u03b1 \u219d \u03b2) :\n    (.nil : \u03b1 \u219d \u03b1) \u21d8 A = A := by\n  induction A with\n  | nil => rfl\n  | sderiv \u03b3 \u03b4 A h ih => rw [deriv_sderiv, ih]\n\n@[simp]\ntheorem Path.deriv_sderivBot (A : \u03b1 \u219d \u03b2) (B : \u03b2 \u219d \u03b3) :\n    A \u21d8 (B \u2198.) = A \u21d8 B \u2198. := by\n  cases \u03b3 using WithBot.recBotCoe with\n  | bot => rfl\n  | coe => rfl\n\n@[simp]\ntheorem Path.botSderiv_bot_eq (A : \u03b1 \u219d \u22a5) :\n    A \u2198. = A :=\n  rfl\n\n@[simp]\ntheorem Path.botSderiv_coe_eq {\u03b2 : \u039b} (A : \u03b1 \u219d \u03b2) :\n    A \u2198 bot_lt_coe \u03b2 = A \u2198. :=\n  rfl\n\n@[simp]\ntheorem Path.deriv_assoc (A : \u03b1 \u219d \u03b2) (B : \u03b2 \u219d \u03b3) (C : \u03b3 \u219d \u03b4) :\n    A \u21d8 (B \u21d8 C) = A \u21d8 B \u21d8 C := by\n  induction C with\n  | nil => rfl\n  | sderiv \u03b5 \u03b6 C h ih => simp only [deriv_sderiv, ih]\n\n@[simp]\ntheorem Path.deriv_sderiv_assoc (A : \u03b1 \u219d \u03b2) (B : \u03b2 \u219d \u03b3) (h : \u03b4 < \u03b3) :\n    A \u21d8 (B \u2198 h) = A \u21d8 B \u2198 h :=\n  rfl\n\n@[simp]\ntheorem Path.deriv_scoderiv (A : \u03b1 \u219d \u03b2) (B : \u03b3 \u219d \u03b4) (h : \u03b3 < \u03b2) :\n    A \u21d8 (B \u2197 h) = A \u2198 h \u21d8 B := by\n  induction B with\n  | nil => rfl\n  | sderiv \u03b5 \u03b6 B h' ih =>\n    rw [deriv_sderiv, \u2190 ih]\n    rfl\n\n@[simp]\ntheorem Path.botDeriv_scoderiv (A : \u03b1 \u219d \u03b2) (B : \u03b3 \u219d \u22a5) (h : \u03b3 < \u03b2) :\n    A \u21d8. (B \u2197 h) = A \u2198 h \u21d8. B :=\n  deriv_scoderiv A B h\n\ntheorem Path.coderiv_eq_deriv (A : \u03b1 \u219d \u03b2) (B : \u03b2 \u219d \u03b3) :\n    B \u21d7 A = A \u21d8 B :=\n  rfl\n\ntheorem Path.coderiv_deriv (A : \u03b2 \u219d \u03b3) (h\u2081 : \u03b2 < \u03b1) (h\u2082 : \u03b4 < \u03b3) :\n    A \u2197 h\u2081 \u2198 h\u2082 = A \u2198 h\u2082 \u2197 h\u2081 :=\n  rfl\n\ntheorem Path.coderiv_deriv' (A : \u03b2 \u219d \u03b3) (h : \u03b2 < \u03b1) (B : \u03b3 \u219d \u03b4) :\n    A \u2197 h \u21d8 B = A \u21d8 B \u2197 h := by\n  induction B with\n  | nil => rfl\n  | sderiv \u03b5 \u03b6 B h' ih =>\n    rw [deriv_sderiv, ih]\n    rfl\n\ntheorem Path.eq_nil (A : \u03b2 \u219d \u03b2) :\n    A = .nil := by\n  cases A with\n  | nil => rfl\n  | sderiv \u03b3 _ A h => cases A.le.not_lt h\n\ntheorem Path.sderiv_index_injective {A : \u03b1 \u219d \u03b2} {B : \u03b1 \u219d \u03b3} {h\u03b4\u03b2 : \u03b4 < \u03b2} {h\u03b4\u03b3 : \u03b4 < \u03b3}\n    (h : A \u2198 h\u03b4\u03b2 = B \u2198 h\u03b4\u03b3) :\n    \u03b2 = \u03b3 := by\n  cases h\n  rfl\n\ntheorem Path.sderivBot_index_injective {\u03b2 \u03b3 : \u039b} {A : \u03b1 \u219d \u03b2} {B : \u03b1 \u219d \u03b3}\n    (h : A \u2198. = B \u2198.) :\n    \u03b2 = \u03b3 := by\n  cases h\n  rfl\n\ntheorem Path.sderiv_path_injective {A B : \u03b1 \u219d \u03b2} {h\u03b3 : \u03b3 < \u03b2} (h : A \u2198 h\u03b3 = B \u2198 h\u03b3) :\n    A = B := by\n  cases h\n  rfl\n\ntheorem Path.sderivBot_path_injective {\u03b2 : \u039b} {A B : \u03b1 \u219d \u03b2} (h : A \u2198. = B \u2198.) :\n    A = B := by\n  cases h\n  rfl\n\ntheorem Path.deriv_left_injective {A B : \u03b1 \u219d \u03b2} {C : \u03b2 \u219d \u03b3} (h : A \u21d8 C = B \u21d8 C) :\n    A = B := by\n  induction C with\n  | nil => exact h\n  | sderiv \u03b4 \u03b5 C h\u03b5 ih =>\n    rw [deriv_sderiv_assoc, deriv_sderiv_assoc] at h\n    exact ih (Path.sderiv_path_injective h)\n\ntheorem Path.deriv_right_injective {A : \u03b1 \u219d \u03b2} {B C : \u03b2 \u219d \u03b3} (h : A \u21d8 B = A \u21d8 C) :\n    B = C := by\n  induction C with\n  | nil => exact B.eq_nil\n  | sderiv \u03b4 \u03b5 C h\u03b5 ih =>\n    cases B with\n    | nil => cases C.le.not_lt h\u03b5\n    | sderiv \u03b6 \u03b7 B h\u03b5' =>\n      cases Path.sderiv_index_injective h\n      rw [deriv_sderiv_assoc, deriv_sderiv_assoc] at h\n      rw [ih (Path.sderiv_path_injective h)]\n\n@[simp]\ntheorem Path.sderiv_left_inj {A B : \u03b1 \u219d \u03b2} {h : \u03b3 < \u03b2} :\n    A \u2198 h = B \u2198 h \u2194 A = B :=\n  \u27e8Path.sderiv_path_injective, \u03bb h \u21a6 h \u25b8 rfl\u27e9\n\n@[simp]\ntheorem Path.deriv_left_inj {A B : \u03b1 \u219d \u03b2} {C : \u03b2 \u219d \u03b3} :\n    A \u21d8 C = B \u21d8 C \u2194 A = B :=\n  \u27e8deriv_left_injective, \u03bb h \u21a6 h \u25b8 rfl\u27e9\n\n@[simp]\ntheorem Path.deriv_right_inj {A : \u03b1 \u219d \u03b2} {B C : \u03b2 \u219d \u03b3} :\n    A \u21d8 B = A \u21d8 C \u2194 B = C :=\n  \u27e8deriv_right_injective, \u03bb h \u21a6 h \u25b8 rfl\u27e9\n\n", "theoremStatement": "@[simp]\ntheorem Path.scoderiv_left_inj {A B : \u03b2 \u219d \u03b3} {h : \u03b2 < \u03b1} :\n    A \u2197 h = B \u2197 h \u2194 A = B ", "theoremName": "ConNF.Path.scoderiv_left_inj", "fileCreated": {"commit": "8896e416a16c39e1fe487b5fc7c78bc20c4e182b", "date": "2024-12-03"}, "theoremCreated": {"commit": "ce890707e37ede74a2fcd66134d3f403335c5cc1", "date": "2024-11-30"}, "file": "ConNF/ConNF/Levels/Path.lean", "module": "ConNF.Levels.Path", "jsonFile": "ConNF.Levels.Path.jsonl", "positionMetadata": {"lineInFile": 337, "tokenPositionInFile": 10251, "theoremPositionInFile": 43}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 6, "repositoryPremises": true, "numRepositoryPremises": 11, "numPremises": 21}, "proofMetadata": {"hasProof": true, "proof": ":=\n  deriv_right_inj", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 20}}
{"srcContext": "import ConNF.Model.Externalise\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b2 \u03b3 : \u039b} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n\nnamespace Support\n\ntheorem not_mem_scoderiv_botDeriv (S : Support \u03b3) (N : NearLitter) :\n    N \u2209 (S \u2197 h\u03b3 \u21d8. (Path.nil \u2198.))\u1d3a := by\n  rintro \u27e8i, \u27e8A, N'\u27e9, h\u2081, h\u2082\u27e9\n  simp only [Prod.mk.injEq] at h\u2082\n  cases A\n  case sderiv \u03b4 A h\u03b4 _ =>\n    simp only [Path.deriv_sderiv] at h\u2082\n    cases A\n    case nil => cases h\u2082.1\n    case sderiv \u03b6 A h\u03b6 _ =>\n      simp only [Path.deriv_sderiv] at h\u2082\n      cases h\u2082.1\n\nvariable [Level] [LtLevel \u03b2]\n\ntheorem not_mem_strong_botDeriv (S : Support \u03b3) (N : NearLitter) :\n    N \u2209 ((S \u2197 h\u03b3).strong \u21d8. (Path.nil \u2198.))\u1d3a := by\n  rintro h\n  rw [strong, close_nearLitters, preStrong_nearLitters, Enumeration.mem_add_iff] at h\n  obtain h | h := h\n  \u00b7 exact not_mem_scoderiv_botDeriv S N h\n  \u00b7 rw [mem_constrainsNearLitters_nearLitters] at h\n    obtain \u27e8B, N', hN', h\u27e9 := h\n    cases h using Relation.ReflTransGen.head_induction_on\n    case refl => exact not_mem_scoderiv_botDeriv S N hN'\n    case head x hx\u2081 hx\u2082 _ =>\n      obtain \u27e8\u27e8\u03b3, \u03b4, \u03b5, h\u03b4, h\u03b5, h\u03b4\u03b5, A\u27e9, t, B, hB, hN, ht\u27e9 := hx\u2082\n      simp only at hB\n      cases B\n      case nil =>\n        cases hB\n        obtain \u27e8C, N''\u27e9 := x\n        simp only at ht\n        cases ht.1\n        change _ \u2208 t.support\u1d3a at hN\n        rw [t.support_supports.2 rfl] at hN\n        obtain \u27e8i, hN\u27e9 := hN\n        cases hN\n      case sderiv \u03b4 B h\u03b4 _ _ =>\n        cases B\n        case nil => cases hB\n        case sderiv \u03b6 B h\u03b6 _ _ => cases hB\n\ntheorem raise_preStrong' (S : Support \u03b1) (hS : S.Strong) (T : Support \u03b3) (\u03c1 : AllPerm \u03b2)\n    (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2) :\n    (S + (\u03c1\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim).PreStrong := by\n  apply hS.toPreStrong.add\n  constructor\n  intro A N hN P t hA ht\n  obtain \u27e8A, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv hN\n  simp only [scoderiv_botDeriv_eq, add_derivBot, smul_derivBot,\n    BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters, interferenceSupport_nearLitters,\n    Enumeration.mem_add_iff, Enumeration.mem_smul, Enumeration.not_mem_empty, or_false] at hN\n  obtain \u27e8\u03b4, \u03b5, \u03b6, h\u03b5, h\u03b6, h\u03b5\u03b6, B\u27e9 := P\n  dsimp only at *\n  cases A\n  case sderiv \u03b6' A h\u03b6' _ =>\n    rw [\u2190 Path.coderiv_deriv] at hA\n    cases Path.sderiv_index_injective hA\n    apply Path.sderiv_left_inj.mp at hA\n    cases A\n    case nil =>\n      cases hA\n      cases not_mem_strong_botDeriv T _ hN\n    case sderiv \u03b9 A h\u03b9 _ _ =>\n      rw [\u2190 Path.coderiv_deriv] at hA\n      cases Path.sderiv_index_injective hA\n      cases hA\n      haveI : LtLevel \u03b4 := \u27e8A.le.trans_lt LtLevel.elim\u27e9\n      haveI : LtLevel \u03b5 := \u27e8h\u03b5.trans LtLevel.elim\u27e9\n      haveI : LtLevel \u03b6 := \u27e8h\u03b6.trans LtLevel.elim\u27e9\n      have := (T \u2197 h\u03b3).strong_strong.support_le hN \u27e8\u03b4, \u03b5, \u03b6, h\u03b5, h\u03b6, h\u03b5\u03b6, A\u27e9\n          (\u03c1\u207b\u00b9 \u21d8 A \u2198 h\u03b5 \u2022 t) rfl ?_\n      \u00b7 simp only [Tangle.smul_support, allPermSderiv_forget, allPermDeriv_forget,\n          allPermForget_inv, Tree.inv_deriv, Tree.inv_sderiv] at this\n        have := smul_le_smul this (\u03c1\u1d41 \u21d8 A \u2198 h\u03b5)\n        simp only [smul_inv_smul] at this\n        apply le_trans this\n        intro B\n        constructor\n        \u00b7 intro a ha\n          simp only [smul_derivBot, Tree.sderiv_apply, Tree.deriv_apply, Path.deriv_scoderiv,\n            deriv_derivBot, Enumeration.mem_smul] at ha\n          rw [deriv_derivBot, \u2190 Path.deriv_scoderiv, Path.coderiv_deriv', scoderiv_botDeriv_eq,]\n          simp only [Path.deriv_scoderiv, add_derivBot, smul_derivBot,\n            BaseSupport.add_atoms, BaseSupport.smul_atoms, Enumeration.mem_add_iff,\n            Enumeration.mem_smul]\n          exact Or.inl ha\n        \u00b7 intro N hN\n          simp only [smul_derivBot, Tree.sderiv_apply, Tree.deriv_apply, Path.deriv_scoderiv,\n            deriv_derivBot, Enumeration.mem_smul] at hN\n          rw [deriv_derivBot, \u2190 Path.deriv_scoderiv, Path.coderiv_deriv', scoderiv_botDeriv_eq,]\n          simp only [Path.deriv_scoderiv, add_derivBot, smul_derivBot,\n            BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters, Enumeration.mem_add_iff,\n            Enumeration.mem_smul]\n          exact Or.inl hN\n      \u00b7 rw [\u2190 smul_fuzz h\u03b5 h\u03b6 h\u03b5\u03b6, \u2190 ht]\n        simp only [Path.botSderiv_coe_eq, BasePerm.smul_nearLitter_litter, allPermDeriv_forget,\n          allPermForget_inv, Tree.inv_deriv, Tree.inv_sderiv, Tree.inv_sderivBot]\n        rfl\n\ntheorem raise_closed' (S : Support \u03b1) (hS : S.Strong) (T : Support \u03b3) (\u03c1 : AllPerm \u03b2)\n    (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n    (h\u03c1 : \u03c1\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim) :\n    (S + (\u03c1\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim).Closed := by\n  constructor\n  intro A\n  constructor\n  intro N\u2081 N\u2082 hN\u2081 hN\u2082 a ha\n  simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff,\n    BaseSupport.add_atoms] at hN\u2081 hN\u2082 \u22a2\n  obtain hN\u2081 | hN\u2081 := hN\u2081\n  \u00b7 obtain hN\u2082 | hN\u2082 := hN\u2082\n    \u00b7 exact Or.inl ((hS.closed A).interference_subset hN\u2081 hN\u2082 a ha)\n    \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv hN\u2082\n      simp only [smul_add, scoderiv_botDeriv_eq, add_derivBot, smul_derivBot,\n        BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters, Enumeration.mem_add_iff,\n        Enumeration.mem_smul, BaseSupport.add_atoms, BaseSupport.smul_atoms] at hN\u2081 hN\u2082 \u22a2\n      refine Or.inr (Or.inr ?_)\n      rw [mem_interferenceSupport_atoms]\n      refine \u27e8(\u03c1\u1d41 B)\u207b\u00b9 \u2022 N\u2081, ?_, (\u03c1\u1d41 B)\u207b\u00b9 \u2022 N\u2082, ?_, ?_\u27e9\n      \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n        rw [\u2190 Enumeration.mem_smul, \u2190 BaseSupport.smul_nearLitters, \u2190 smul_derivBot, h\u03c1]\n        exact Or.inl hN\u2081\n      \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n        simp only [interferenceSupport_nearLitters, Enumeration.not_mem_empty, or_false] at hN\u2082\n        exact Or.inr hN\u2082\n      \u00b7 rw [\u2190 BasePerm.smul_interference]\n        exact Set.smul_mem_smul_set ha\n  \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv hN\u2081\n    simp only [smul_add, scoderiv_botDeriv_eq, add_derivBot, smul_derivBot,\n      BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters, Enumeration.mem_add_iff,\n      Enumeration.mem_smul, BaseSupport.add_atoms, BaseSupport.smul_atoms] at hN\u2081 hN\u2082 \u22a2\n    refine Or.inr (Or.inr ?_)\n    rw [mem_interferenceSupport_atoms]\n    refine \u27e8(\u03c1\u1d41 B)\u207b\u00b9 \u2022 N\u2081, ?_, (\u03c1\u1d41 B)\u207b\u00b9 \u2022 N\u2082, ?_, ?_\u27e9\n    \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n      simp only [interferenceSupport_nearLitters, Enumeration.not_mem_empty, or_false] at hN\u2081\n      exact Or.inr hN\u2081\n    \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n      simp only [interferenceSupport_nearLitters, Enumeration.not_mem_empty, or_false] at hN\u2082\n      obtain hN\u2082 | hN\u2082 := hN\u2082\n      \u00b7 rw [\u2190 Enumeration.mem_smul, \u2190 BaseSupport.smul_nearLitters, \u2190 smul_derivBot, h\u03c1]\n        exact Or.inl hN\u2082\n      \u00b7 exact Or.inr hN\u2082\n    \u00b7 rw [\u2190 BasePerm.smul_interference]\n      exact Set.smul_mem_smul_set ha\n\ntheorem raise_strong' (S : Support \u03b1) (hS : S.Strong) (T : Support \u03b3) (\u03c1 : AllPerm \u03b2)\n    (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n    (h\u03c1 : \u03c1\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim) :\n    (S + (\u03c1\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim).Strong :=\n  \u27e8raise_preStrong' S hS T \u03c1 h\u03b3, raise_closed' S hS T \u03c1 h\u03b3 h\u03c1\u27e9\n\ntheorem convAtoms_injective_of_fixes {S : Support \u03b1} {T : Support \u03b3}\n    {\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n    (h\u03c1\u2081 : \u03c1\u2081\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (h\u03c1\u2082 : \u03c1\u2082\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (A : \u2191\u03b1 \u219d \u22a5) :\n    (convAtoms\n      (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong + (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197\n        LtLevel.elim)\n      (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong + (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197\n        LtLevel.elim) A).Injective := by\n  rw [Support.smul_eq_iff] at h\u03c1\u2081 h\u03c1\u2082\n  constructor\n  rintro a\u2081 a\u2082 a\u2083 \u27e8i, hi\u2081, hi\u2082\u27e9 \u27e8j, hj\u2081, hj\u2082\u27e9\n  simp only [add_derivBot, BaseSupport.add_atoms, Rel.inv_apply,\n    Enumeration.rel_add_iff] at hi\u2081 hi\u2082 hj\u2081 hj\u2082\n  obtain hi\u2081 | \u27e8i, rfl, hi\u2081\u27e9 := hi\u2081\n  \u00b7 obtain hi\u2082 | \u27e8i', rfl, _\u27e9 := hi\u2082\n    swap\n    \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hi\u2081\u27e9\n      simp only [add_lt_iff_neg_left] at this\n      cases (\u03ba_zero_le i').not_lt this\n    cases (Enumeration.rel_coinjective _).coinjective hi\u2081 hi\u2082\n    obtain hj\u2081 | \u27e8j, rfl, hj\u2081\u27e9 := hj\u2081\n    \u00b7 obtain hj\u2082 | \u27e8j', rfl, _\u27e9 := hj\u2082\n      \u00b7 exact (Enumeration.rel_coinjective _).coinjective hj\u2082 hj\u2081\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2081\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j').not_lt this\n    \u00b7 obtain hj\u2082 | hj\u2082 := hj\u2082\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2082\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j).not_lt this\n      \u00b7 simp only [add_right_inj, exists_eq_left] at hj\u2082\n        obtain \u27e8B, rfl\u27e9 := eq_of_atom_mem_scoderiv_botDeriv \u27e8j, hj\u2081\u27e9\n        simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_atoms,\n          BaseSupport.add_atoms, Enumeration.smul_rel, add_right_inj, exists_eq_left] at hj\u2081 hj\u2082\n        have := (Enumeration.rel_coinjective _).coinjective hj\u2081 hj\u2082\n        rw [\u2190 (h\u03c1\u2082 B).1 a\u2081 \u27e8_, hi\u2081\u27e9, inv_smul_smul, inv_smul_eq_iff, (h\u03c1\u2081 B).1 a\u2081 \u27e8_, hi\u2081\u27e9] at this\n        exact this.symm\n  \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_atom_mem_scoderiv_botDeriv \u27e8i, hi\u2081\u27e9\n    simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_atoms,\n      BaseSupport.add_atoms, Enumeration.smul_rel, add_right_inj, exists_eq_left] at hi\u2081 hi\u2082 hj\u2081 hj\u2082\n    obtain hi\u2082 | hi\u2082 := hi\u2082\n    \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hi\u2082\u27e9\n      simp only [add_lt_iff_neg_left] at this\n      cases (\u03ba_zero_le i).not_lt this\n    have hi := (Enumeration.rel_coinjective _).coinjective hi\u2081 hi\u2082\n    suffices hj : (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 a\u2082 = (\u03c1\u2082\u1d41 B)\u207b\u00b9 \u2022 a\u2083 by\n      rwa [\u2190 hj, smul_left_cancel_iff] at hi\n    obtain hj\u2081 | \u27e8j, rfl, hj\u2081\u27e9 := hj\u2081\n    \u00b7 obtain hj\u2082 | \u27e8j', rfl, _\u27e9 := hj\u2082\n      \u00b7 rw [\u2190 (h\u03c1\u2081 B).1 a\u2082 \u27e8_, hj\u2081\u27e9, \u2190 (h\u03c1\u2082 B).1 a\u2083 \u27e8_, hj\u2082\u27e9, inv_smul_smul, inv_smul_smul]\n        exact (Enumeration.rel_coinjective _).coinjective hj\u2081 hj\u2082\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2081\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j').not_lt this\n    \u00b7 obtain hj\u2082 | hj\u2082 := hj\u2082\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2082\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j).not_lt this\n      \u00b7 simp only [add_right_inj, exists_eq_left] at hj\u2082\n        exact (Enumeration.rel_coinjective _).coinjective hj\u2081 hj\u2082\n\ntheorem atomMemRel_le_of_fixes {S : Support \u03b1} {T : Support \u03b3}\n    {\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n    (h\u03c1\u2081 : \u03c1\u2081\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (h\u03c1\u2082 : \u03c1\u2082\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (A : \u2191\u03b1 \u219d \u22a5) :\n    atomMemRel (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A \u2264\n    atomMemRel (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A := by\n  rw [Support.smul_eq_iff] at h\u03c1\u2081 h\u03c1\u2082\n  rintro i j \u27e8N, hN, a, haN, ha\u27e9\n  simp only [add_derivBot, BaseSupport.add_atoms, Rel.inv_apply, Enumeration.rel_add_iff,\n    BaseSupport.add_nearLitters] at ha hN\n  obtain hN | \u27e8i, rfl, hi\u27e9 := hN\n  \u00b7 obtain ha | \u27e8j, rfl, hj\u27e9 := ha\n    \u00b7 exact \u27e8N, Or.inl hN, a, haN, Or.inl ha\u27e9\n    \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_atom_mem_scoderiv_botDeriv \u27e8j, hj\u27e9\n      simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_atoms,\n        BaseSupport.add_atoms, Enumeration.smul_rel] at hj hN\n      refine \u27e8N, Or.inl hN, \u03c1\u2082\u1d41 B \u2022 (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 a, ?_, ?_\u27e9\n      \u00b7 dsimp only\n        rw [\u2190 (h\u03c1\u2082 B).2 N \u27e8_, hN\u27e9, BasePerm.smul_nearLitter_atoms, Set.smul_mem_smul_set_iff]\n        have := (h\u03c1\u2081 B).2 N \u27e8_, hN\u27e9\n        rw [smul_eq_iff_eq_inv_smul] at this\n        rwa [this, BasePerm.smul_nearLitter_atoms, Set.smul_mem_smul_set_iff]\n      \u00b7 rw [Rel.inv_apply, add_derivBot, BaseSupport.add_atoms, Enumeration.rel_add_iff]\n        simp only [add_right_inj, scoderiv_botDeriv_eq, smul_derivBot, add_derivBot,\n          BaseSupport.smul_atoms, BaseSupport.add_atoms, Enumeration.smul_rel, inv_smul_smul,\n          exists_eq_left]\n        exact Or.inr hj\n  \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv \u27e8i, hi\u27e9\n    simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_atoms,\n      BaseSupport.add_atoms, Enumeration.smul_rel] at hi ha\n    obtain ha | \u27e8j, rfl, hj\u27e9 := ha\n    \u00b7 refine \u27e8\u03c1\u2082\u1d41 B \u2022 (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 N, ?_, a, ?_, Or.inl ha\u27e9\n      \u00b7 rw [add_derivBot, BaseSupport.add_nearLitters, Enumeration.rel_add_iff]\n        simp only [add_right_inj, scoderiv_botDeriv_eq, smul_derivBot, add_derivBot,\n          BaseSupport.smul_nearLitters, BaseSupport.add_nearLitters, Enumeration.smul_rel,\n          inv_smul_smul, exists_eq_left]\n        exact Or.inr hi\n      \u00b7 dsimp only\n        rw [\u2190 (h\u03c1\u2082 B).1 a \u27e8_, ha\u27e9, BasePerm.smul_nearLitter_atoms, Set.smul_mem_smul_set_iff]\n        have := (h\u03c1\u2081 B).1 a \u27e8_, ha\u27e9\n        rw [smul_eq_iff_eq_inv_smul] at this\n        rwa [this, BasePerm.smul_nearLitter_atoms, Set.smul_mem_smul_set_iff]\n    \u00b7 refine \u27e8\u03c1\u2082\u1d41 B \u2022 (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 N, ?_, \u03c1\u2082\u1d41 B \u2022 (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 a, ?_, ?_\u27e9\n      \u00b7 rw [add_derivBot, BaseSupport.add_nearLitters, Enumeration.rel_add_iff]\n        simp only [add_right_inj, scoderiv_botDeriv_eq, smul_derivBot, add_derivBot,\n          BaseSupport.smul_nearLitters, BaseSupport.add_nearLitters, Enumeration.smul_rel,\n          inv_smul_smul, exists_eq_left]\n        exact Or.inr hi\n      \u00b7 simp only [BasePerm.smul_nearLitter_atoms, Set.smul_mem_smul_set_iff]\n        exact haN\n      \u00b7 rw [Rel.inv_apply, add_derivBot, BaseSupport.add_atoms, Enumeration.rel_add_iff]\n        simp only [add_right_inj, scoderiv_botDeriv_eq, smul_derivBot, add_derivBot,\n          BaseSupport.smul_atoms, BaseSupport.add_atoms, Enumeration.smul_rel, inv_smul_smul,\n          exists_eq_left]\n        exact Or.inr hj\n\ntheorem convNearLitters_cases {S : Support \u03b1} {T : Support \u03b3}\n    {\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n    {A : \u03b1 \u219d \u22a5} {N\u2081 N\u2082 : NearLitter} :\n  convNearLitters\n    (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim)\n    (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A N\u2081 N\u2082 \u2192\n    N\u2081 = N\u2082 \u2227 N\u2081 \u2208 (S \u21d8. A)\u1d3a \u2228\n    \u2203 B : \u03b2 \u219d \u22a5, A = B \u2197 LtLevel.elim \u2227 (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 N\u2081 = (\u03c1\u2082\u1d41 B)\u207b\u00b9 \u2022 N\u2082 \u2227\n      (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 N\u2081 \u2208 (((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport) \u21d8. B)\u1d3a := by\n  rintro \u27e8i, hN\u2081, hN\u2082\u27e9\n  simp only [add_derivBot, BaseSupport.add_nearLitters, Rel.inv_apply,\n    Enumeration.rel_add_iff] at hN\u2081 hN\u2082\n  obtain hN\u2081 | \u27e8i, rfl, hN\u2081\u27e9 := hN\u2081\n  \u00b7 obtain hN\u2082 | \u27e8i, rfl, hN\u2082\u27e9 := hN\u2082\n    swap\n    \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hN\u2081\u27e9\n      simp only [add_lt_iff_neg_left] at this\n      cases (\u03ba_zero_le i).not_lt this\n    exact Or.inl \u27e8(Enumeration.rel_coinjective _).coinjective hN\u2081 hN\u2082, _, hN\u2081\u27e9\n  \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv \u27e8i, hN\u2081\u27e9\n    simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_nearLitters,\n      BaseSupport.add_nearLitters, Enumeration.smul_rel, add_right_inj, exists_eq_left] at hN\u2081 hN\u2082\n    obtain hN\u2082 | hN\u2082 := hN\u2082\n    \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hN\u2082\u27e9\n      simp only [add_lt_iff_neg_left] at this\n      cases (\u03ba_zero_le i).not_lt this\n    exact Or.inr \u27e8B, rfl, (Enumeration.rel_coinjective _).coinjective hN\u2081 hN\u2082, _, hN\u2081\u27e9\n\ntheorem inflexible_of_inflexible_of_fixes {S : Support \u03b1} {T : Support \u03b3}\n    {\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n    (h\u03c1\u2081 : \u03c1\u2081\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (h\u03c1\u2082 : \u03c1\u2082\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    {A : \u03b1 \u219d \u22a5} {N\u2081 N\u2082 : NearLitter} :\n    convNearLitters\n      (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim)\n      (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A N\u2081 N\u2082 \u2192\n      \u2200 (P : InflexiblePath \u2191\u03b1) (t : Tangle P.\u03b4), A = P.A \u2198 P.h\u03b5 \u2198. \u2192 N\u2081\u1d38 = fuzz P.h\u03b4\u03b5 t \u2192\n      \u2203 \u03c1 : AllPerm P.\u03b4, N\u2082\u1d38 = fuzz P.h\u03b4\u03b5 (\u03c1 \u2022 t) := by\n  rintro hN \u27e8\u03b3, \u03b4, \u03b5, h\u03b4, h\u03b5, h\u03b4\u03b5, A\u27e9 t hA ht\n  haveI : LeLevel \u03b3 := \u27e8A.le\u27e9\n  haveI : LtLevel \u03b4 := \u27e8h\u03b4.trans_le LeLevel.elim\u27e9\n  haveI : LtLevel \u03b5 := \u27e8h\u03b5.trans_le LeLevel.elim\u27e9\n  obtain \u27e8rfl, _\u27e9 | \u27e8B, rfl, hN'\u27e9 := convNearLitters_cases hN\n  \u00b7 use 1\n    rw [one_smul, ht]\n  \u00b7 clear hN\n    cases B\n    case sderiv \u03b5 B h\u03b5' _ =>\n      rw [\u2190 Path.coderiv_deriv] at hA\n      cases Path.sderiv_index_injective hA\n      apply Path.sderiv_path_injective at hA\n      cases B\n      case nil =>\n        simp only [Path.botSderiv_coe_eq, add_derivBot, BaseSupport.add_nearLitters,\n          interferenceSupport_nearLitters, Enumeration.add_empty] at hN'\n        cases not_mem_strong_botDeriv _ _ hN'.2\n      case sderiv \u03b6 B h\u03b6 _ _ =>\n        rw [\u2190 Path.coderiv_deriv] at hA\n        cases Path.sderiv_index_injective hA\n        apply Path.sderiv_path_injective at hA\n        dsimp only at hA h\u03b6 h\u03b5' B t\n        cases hA\n        use (\u03c1\u2082 * \u03c1\u2081\u207b\u00b9) \u21d8 B \u2198 h\u03b4\n        rw [inv_smul_eq_iff] at hN'\n        rw [\u2190 smul_fuzz h\u03b4 h\u03b5 h\u03b4\u03b5, \u2190 ht, hN'.1]\n        simp only [allPermDeriv_forget, allPermForget_mul, allPermForget_inv, Tree.mul_deriv,\n          Tree.inv_deriv, Tree.mul_sderiv, Tree.inv_sderiv, Tree.mul_sderivBot, Tree.inv_sderivBot,\n          Path.botSderiv_coe_eq, BasePerm.smul_nearLitter_litter, mul_smul]\n        erw [inv_smul_smul, smul_inv_smul]\n\ntheorem atoms_of_inflexible_of_fixes {S : Support \u03b1} (hS : S.Strong) {T : Support \u03b3}\n    {\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n    (h\u03c1\u2081 : \u03c1\u2081\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (h\u03c1\u2082 : \u03c1\u2082\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (A : \u03b1 \u219d \u22a5) (N\u2081 N\u2082 : NearLitter) (P : InflexiblePath \u2191\u03b1) (t : Tangle P.\u03b4) (\u03c1 : AllPerm P.\u03b4) :\n    A = P.A \u2198 P.h\u03b5 \u2198. \u2192 N\u2081\u1d38 = fuzz P.h\u03b4\u03b5 t \u2192 N\u2082\u1d38 = fuzz P.h\u03b4\u03b5 (\u03c1 \u2022 t) \u2192\n    convNearLitters\n      (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim)\n      (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A N\u2081 N\u2082 \u2192\n    \u2200 (B : P.\u03b4 \u219d \u22a5), \u2200 a \u2208 (t.support \u21d8. B)\u1d2c, \u2200 (i : \u03ba),\n      ((S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong + (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197\n        LtLevel.elim) \u21d8. (P.A \u2198 P.h\u03b4 \u21d8 B))\u1d2c.rel i a \u2192\n      ((S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong + (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197\n        LtLevel.elim) \u21d8. (P.A \u2198 P.h\u03b4 \u21d8 B))\u1d2c.rel i (\u03c1\u1d41 B \u2022 a) := by\n  rw [Support.smul_eq_iff] at h\u03c1\u2081 h\u03c1\u2082\n  obtain \u27e8\u03b3, \u03b4, \u03b5, h\u03b4, h\u03b5, h\u03b4\u03b5, B\u27e9 := P\n  haveI : LeLevel \u03b3 := \u27e8B.le\u27e9\n  haveI : LtLevel \u03b4 := \u27e8h\u03b4.trans_le LeLevel.elim\u27e9\n  haveI : LtLevel \u03b5 := \u27e8h\u03b5.trans_le LeLevel.elim\u27e9\n  dsimp only at t \u03c1 \u22a2\n  intro hA hN\u2081 hN\u2082 hN C a ha i hi\n  obtain \u27e8rfl, hN'\u27e9 | \u27e8A, rfl, hN\u2081', hN\u2082'\u27e9 := convNearLitters_cases hN\n  \u00b7 have haS := (hS.support_le hN' \u27e8\u03b3, \u03b4, \u03b5, h\u03b4, h\u03b5, h\u03b4\u03b5, _\u27e9 t hA hN\u2081 _).1 a ha\n    rw [hN\u2082] at hN\u2081\n    have h\u03c1t := congr_arg Tangle.support (fuzz_injective hN\u2081)\n    rw [Tangle.smul_support, Support.smul_eq_iff] at h\u03c1t\n    simp only [add_derivBot, BaseSupport.add_atoms, Enumeration.rel_add_iff] at hi \u22a2\n    rw [(h\u03c1t C).1 a ha]\n    obtain hi | \u27e8i, rfl, hi\u27e9 := hi\n    \u00b7 exact Or.inl hi\n    \u00b7 simp only [add_right_inj, exists_eq_left]\n      obtain \u27e8D, hD\u27e9 := eq_of_atom_mem_scoderiv_botDeriv \u27e8i, hi\u27e9\n      cases B using Path.recScoderiv\n      case nil =>\n        cases Path.scoderiv_index_injective hD\n        cases Path.scoderiv_left_inj.mp hD\n        simp only [hD, Path.coderiv_deriv, Path.coderiv_deriv', scoderiv_botDeriv_eq, smul_derivBot,\n          add_derivBot, BaseSupport.smul_atoms, BaseSupport.add_atoms, Enumeration.smul_rel] at hi \u22a2\n        rw [deriv_derivBot, hD] at haS\n        rw [\u2190 (h\u03c1\u2082 _).1 a haS, inv_smul_smul]\n        rw [\u2190 (h\u03c1\u2081 _).1 a haS, inv_smul_smul] at hi\n        exact Or.inr hi\n      case scoderiv \u03b6 B h\u03b6' _ =>\n        rw [Path.coderiv_deriv, Path.coderiv_deriv'] at hD\n        cases Path.scoderiv_index_injective hD\n        rw [Path.scoderiv_left_inj] at hD\n        cases hD\n        simp only [Path.coderiv_deriv, Path.coderiv_deriv', scoderiv_botDeriv_eq, smul_derivBot,\n          add_derivBot, BaseSupport.smul_atoms, BaseSupport.add_atoms, Enumeration.smul_rel] at hi \u22a2\n        rw [deriv_derivBot, Path.coderiv_deriv, Path.coderiv_deriv'] at haS\n        rw [\u2190 (h\u03c1\u2082 _).1 a haS, inv_smul_smul]\n        rw [\u2190 (h\u03c1\u2081 _).1 a haS, inv_smul_smul] at hi\n        exact Or.inr hi\n  \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, interferenceSupport_nearLitters,\n      Enumeration.add_empty] at hN\u2082'\n    cases A\n    case sderiv \u03b6 A h\u03b6' _ =>\n      rw [\u2190 Path.coderiv_deriv] at hA\n      cases Path.sderiv_index_injective hA\n      apply Path.sderiv_path_injective at hA\n      cases A\n      case nil =>\n        cases hA\n        cases not_mem_strong_botDeriv _ _ hN\u2082'\n      case sderiv \u03b6 A h\u03b6 _ _ =>\n        rw [\u2190 Path.coderiv_deriv] at hA\n        cases Path.sderiv_index_injective hA\n        apply Path.sderiv_path_injective at hA\n        cases hA\n        simp only [Path.coderiv_deriv, Path.coderiv_deriv', add_derivBot, scoderiv_botDeriv_eq,\n          smul_derivBot, BaseSupport.add_atoms, BaseSupport.smul_atoms] at hi \u22a2\n        have : N\u2082\u1d38 = (\u03c1\u2082 \u21d8 A)\u1d41 \u2198 h\u03b6 \u2198. \u2022 (\u03c1\u2081\u207b\u00b9 \u21d8 A)\u1d41 \u2198 h\u03b6 \u2198. \u2022 fuzz h\u03b4\u03b5 t := by\n          rw [inv_smul_eq_iff] at hN\u2081'\n          rw [hN\u2081', Path.botSderiv_coe_eq, BasePerm.smul_nearLitter_litter,\n            BasePerm.smul_nearLitter_litter, smul_smul, smul_eq_iff_eq_inv_smul,\n            mul_inv_rev, inv_inv, mul_smul, \u2190 Tree.inv_apply, \u2190 allPermForget_inv] at hN\u2081\n          rw [hN\u2081]\n          simp only [allPermForget_inv, Tree.inv_apply, allPermDeriv_forget, Tree.inv_deriv,\n            Tree.inv_sderiv, Tree.inv_sderivBot]\n          rfl\n        rw [smul_fuzz h\u03b4 h\u03b5 h\u03b4\u03b5, smul_fuzz h\u03b4 h\u03b5 h\u03b4\u03b5] at this\n        have := fuzz_injective (hN\u2082.symm.trans this)\n        rw [smul_smul] at this\n        rw [t.smul_atom_eq_of_mem_support this ha]\n        rw [Enumeration.rel_add_iff] at hi \u22a2\n        obtain hi | \u27e8i, rfl, hi\u27e9 := hi\n        \u00b7 left\n          simp only [allPermForget_mul, allPermSderiv_forget, allPermDeriv_forget,\n            allPermForget_inv, Tree.inv_deriv, Tree.inv_sderiv, Tree.mul_apply, Tree.sderiv_apply,\n            Tree.deriv_apply, Path.deriv_scoderiv, Tree.inv_apply, mul_smul]\n          rwa [\u2190 (h\u03c1\u2081 _).1 a \u27e8i, hi\u27e9, inv_smul_smul, (h\u03c1\u2082 _).1 a \u27e8i, hi\u27e9]\n        \u00b7 refine Or.inr \u27e8i, rfl, ?_\u27e9\n          simp only [allPermForget_mul, allPermSderiv_forget, allPermDeriv_forget,\n            allPermForget_inv, Tree.inv_deriv, Tree.inv_sderiv, Tree.mul_apply, Tree.sderiv_apply,\n            Tree.deriv_apply, Path.deriv_scoderiv, Tree.inv_apply, mul_smul, Enumeration.smul_rel,\n            inv_smul_smul]\n          exact hi\n\ntheorem nearLitters_of_inflexible_of_fixes {S : Support \u03b1} (hS : S.Strong) {T : Support \u03b3}\n    {\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n    (h\u03c1\u2081 : \u03c1\u2081\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (h\u03c1\u2082 : \u03c1\u2082\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (A : \u03b1 \u219d \u22a5) (N\u2081 N\u2082 : NearLitter) (P : InflexiblePath \u2191\u03b1) (t : Tangle P.\u03b4) (\u03c1 : AllPerm P.\u03b4) :\n    A = P.A \u2198 P.h\u03b5 \u2198. \u2192 N\u2081\u1d38 = fuzz P.h\u03b4\u03b5 t \u2192 N\u2082\u1d38 = fuzz P.h\u03b4\u03b5 (\u03c1 \u2022 t) \u2192\n    convNearLitters\n      (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim)\n      (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A N\u2081 N\u2082 \u2192\n    \u2200 (B : P.\u03b4 \u219d \u22a5), \u2200 N \u2208 (t.support \u21d8. B)\u1d3a, \u2200 (i : \u03ba),\n      ((S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong + (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197\n        LtLevel.elim) \u21d8. (P.A \u2198 P.h\u03b4 \u21d8 B))\u1d3a.rel i N \u2192\n      ((S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong + (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197\n        LtLevel.elim) \u21d8. (P.A \u2198 P.h\u03b4 \u21d8 B))\u1d3a.rel i (\u03c1\u1d41 B \u2022 N) := by\n  rw [Support.smul_eq_iff] at h\u03c1\u2081 h\u03c1\u2082\n  obtain \u27e8\u03b3, \u03b4, \u03b5, h\u03b4, h\u03b5, h\u03b4\u03b5, B\u27e9 := P\n  haveI : LeLevel \u03b3 := \u27e8B.le\u27e9\n  haveI : LtLevel \u03b4 := \u27e8h\u03b4.trans_le LeLevel.elim\u27e9\n  haveI : LtLevel \u03b5 := \u27e8h\u03b5.trans_le LeLevel.elim\u27e9\n  dsimp only at t \u03c1 \u22a2\n  intro hA hN\u2081 hN\u2082 hN C N\u2080 hN\u2080 i hi\n  obtain \u27e8rfl, hN'\u27e9 | \u27e8A, rfl, hN\u2081', hN\u2082'\u27e9 := convNearLitters_cases hN\n  \u00b7 have haS := (hS.support_le hN' \u27e8\u03b3, \u03b4, \u03b5, h\u03b4, h\u03b5, h\u03b4\u03b5, _\u27e9 t hA hN\u2081 _).2 N\u2080 hN\u2080\n    rw [hN\u2082] at hN\u2081\n    have h\u03c1t := congr_arg Tangle.support (fuzz_injective hN\u2081)\n    rw [Tangle.smul_support, Support.smul_eq_iff] at h\u03c1t\n    simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.rel_add_iff] at hi \u22a2\n    rw [(h\u03c1t C).2 N\u2080 hN\u2080]\n    obtain hi | \u27e8i, rfl, hi\u27e9 := hi\n    \u00b7 exact Or.inl hi\n    \u00b7 simp only [add_right_inj, exists_eq_left]\n      obtain \u27e8D, hD\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv \u27e8i, hi\u27e9\n      cases B using Path.recScoderiv\n      case nil =>\n        cases Path.scoderiv_index_injective hD\n        cases Path.scoderiv_left_inj.mp hD\n        simp only [hD, Path.coderiv_deriv, Path.coderiv_deriv', scoderiv_botDeriv_eq, smul_derivBot,\n          add_derivBot, BaseSupport.smul_nearLitters, BaseSupport.add_nearLitters, Enumeration.smul_rel] at hi \u22a2\n        rw [deriv_derivBot, hD] at haS\n        rw [\u2190 (h\u03c1\u2082 _).2 N\u2080 haS, inv_smul_smul]\n        rw [\u2190 (h\u03c1\u2081 _).2 N\u2080 haS, inv_smul_smul] at hi\n        exact Or.inr hi\n      case scoderiv \u03b6 B h\u03b6' _ =>\n        rw [Path.coderiv_deriv, Path.coderiv_deriv'] at hD\n        cases Path.scoderiv_index_injective hD\n        rw [Path.scoderiv_left_inj] at hD\n        cases hD\n        simp only [Path.coderiv_deriv, Path.coderiv_deriv', scoderiv_botDeriv_eq, smul_derivBot,\n          add_derivBot, BaseSupport.smul_nearLitters, BaseSupport.add_nearLitters, Enumeration.smul_rel] at hi \u22a2\n        rw [deriv_derivBot, Path.coderiv_deriv, Path.coderiv_deriv'] at haS\n        rw [\u2190 (h\u03c1\u2082 _).2 N\u2080 haS, inv_smul_smul]\n        rw [\u2190 (h\u03c1\u2081 _).2 N\u2080 haS, inv_smul_smul] at hi\n        exact Or.inr hi\n  \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, interferenceSupport_nearLitters,\n      Enumeration.add_empty] at hN\u2082'\n    cases A\n    case sderiv \u03b6 A h\u03b6' _ =>\n      rw [\u2190 Path.coderiv_deriv] at hA\n      cases Path.sderiv_index_injective hA\n      apply Path.sderiv_path_injective at hA\n      cases A\n      case nil =>\n        cases hA\n        cases not_mem_strong_botDeriv _ _ hN\u2082'\n      case sderiv \u03b6 A h\u03b6 _ _ =>\n        rw [\u2190 Path.coderiv_deriv] at hA\n        cases Path.sderiv_index_injective hA\n        apply Path.sderiv_path_injective at hA\n        cases hA\n        simp only [Path.coderiv_deriv, Path.coderiv_deriv', add_derivBot, scoderiv_botDeriv_eq,\n          smul_derivBot, BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters] at hi \u22a2\n        have : N\u2082\u1d38 = (\u03c1\u2082 \u21d8 A)\u1d41 \u2198 h\u03b6 \u2198. \u2022 (\u03c1\u2081\u207b\u00b9 \u21d8 A)\u1d41 \u2198 h\u03b6 \u2198. \u2022 fuzz h\u03b4\u03b5 t := by\n          rw [inv_smul_eq_iff] at hN\u2081'\n          rw [hN\u2081', Path.botSderiv_coe_eq, BasePerm.smul_nearLitter_litter,\n            BasePerm.smul_nearLitter_litter, smul_smul, smul_eq_iff_eq_inv_smul,\n            mul_inv_rev, inv_inv, mul_smul, \u2190 Tree.inv_apply, \u2190 allPermForget_inv] at hN\u2081\n          rw [hN\u2081]\n          simp only [allPermForget_inv, Tree.inv_apply, allPermDeriv_forget, Tree.inv_deriv,\n            Tree.inv_sderiv, Tree.inv_sderivBot]\n          rfl\n        rw [smul_fuzz h\u03b4 h\u03b5 h\u03b4\u03b5, smul_fuzz h\u03b4 h\u03b5 h\u03b4\u03b5] at this\n        have := fuzz_injective (hN\u2082.symm.trans this)\n        rw [smul_smul] at this\n        rw [t.smul_nearLitter_eq_of_mem_support this hN\u2080]\n        rw [Enumeration.rel_add_iff] at hi \u22a2\n        obtain hi | \u27e8i, rfl, hi\u27e9 := hi\n        \u00b7 left\n          simp only [allPermForget_mul, allPermSderiv_forget, allPermDeriv_forget,\n            allPermForget_inv, Tree.inv_deriv, Tree.inv_sderiv, Tree.mul_apply, Tree.sderiv_apply,\n            Tree.deriv_apply, Path.deriv_scoderiv, Tree.inv_apply, mul_smul]\n          rwa [\u2190 (h\u03c1\u2081 _).2 N\u2080 \u27e8i, hi\u27e9, inv_smul_smul, (h\u03c1\u2082 _).2 N\u2080 \u27e8i, hi\u27e9]\n        \u00b7 refine Or.inr \u27e8i, rfl, ?_\u27e9\n          simp only [allPermForget_mul, allPermSderiv_forget, allPermDeriv_forget,\n            allPermForget_inv, Tree.inv_deriv, Tree.inv_sderiv, Tree.mul_apply, Tree.sderiv_apply,\n            Tree.deriv_apply, Path.deriv_scoderiv, Tree.inv_apply, mul_smul, Enumeration.smul_rel,\n            inv_smul_smul]\n          exact hi\n\ntheorem litter_eq_of_flexible_of_fixes {S : Support \u03b1} {T : Support \u03b3}\n    {\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n    (h\u03c1\u2081 : \u03c1\u2081\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (h\u03c1\u2082 : \u03c1\u2082\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    {A : \u2191\u03b1 \u219d \u22a5} {N\u2081 N\u2082 N\u2083 N\u2084 : NearLitter} :\n    convNearLitters\n      (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim)\n      (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A N\u2081 N\u2082 \u2192\n    convNearLitters\n      (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim)\n      (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A N\u2083 N\u2084 \u2192\n      \u00acInflexible A N\u2081\u1d38 \u2192 \u00acInflexible A N\u2082\u1d38 \u2192 \u00acInflexible A N\u2083\u1d38 \u2192 \u00acInflexible A N\u2084\u1d38 \u2192\n      N\u2081\u1d38 = N\u2083\u1d38 \u2192 N\u2082\u1d38 = N\u2084\u1d38 := by\n  rw [Support.smul_eq_iff] at h\u03c1\u2081 h\u03c1\u2082\n  rintro \u27e8i, hi\u2081, hi\u2082\u27e9 \u27e8j, hj\u2081, hj\u2082\u27e9 hN\u2081 hN\u2082 hN\u2083 hN\u2084 hN\u2081\u2083\n  simp only [add_derivBot, BaseSupport.add_nearLitters, Rel.inv_apply,\n    Enumeration.rel_add_iff] at hi\u2081 hi\u2082 hj\u2081 hj\u2082\n  obtain hi\u2081 | \u27e8i, rfl, hi\u2081\u27e9 := hi\u2081\n  \u00b7 obtain hi\u2082 | \u27e8i, rfl, hi\u2082\u27e9 := hi\u2082\n    swap\n    \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hi\u2081\u27e9\n      simp only [add_lt_iff_neg_left] at this\n      cases (\u03ba_zero_le i).not_lt this\n    cases (Enumeration.rel_coinjective _).coinjective hi\u2081 hi\u2082\n    obtain hj\u2081 | \u27e8j, rfl, hj\u2081\u27e9 := hj\u2081\n    \u00b7 obtain hj\u2082 | \u27e8j, rfl, hj\u2082\u27e9 := hj\u2082\n      swap\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2081\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j).not_lt this\n      cases (Enumeration.rel_coinjective _).coinjective hj\u2081 hj\u2082\n      exact hN\u2081\u2083\n    \u00b7 simp only [add_right_inj, exists_eq_left] at hj\u2082\n      obtain hj\u2082 | hj\u2082 := hj\u2082\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2082\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j).not_lt this\n      obtain \u27e8A, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv \u27e8j, hj\u2081\u27e9\n      simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_nearLitters,\n        BaseSupport.add_nearLitters, Enumeration.smul_rel] at hj\u2081 hj\u2082\n      have := congr_arg (\u00b7\u1d38) ((Enumeration.rel_coinjective _).coinjective hj\u2081 hj\u2082)\n      simp only [BasePerm.smul_nearLitter_litter] at this\n      rw [\u2190 hN\u2081\u2083, \u2190 (h\u03c1\u2081 A).2 N\u2081 \u27e8i, hi\u2081\u27e9, BasePerm.smul_nearLitter_litter, inv_smul_smul] at this\n      have hN\u2081' := (h\u03c1\u2082 A).2 N\u2081 \u27e8i, hi\u2081\u27e9\n      rw [smul_eq_iff_eq_inv_smul] at hN\u2081'\n      rwa [hN\u2081', BasePerm.smul_nearLitter_litter, smul_left_cancel_iff] at this\n  \u00b7 obtain hi\u2082 | hi\u2082 := hi\u2082\n    \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hi\u2082\u27e9\n      simp only [add_lt_iff_neg_left] at this\n      cases (\u03ba_zero_le i).not_lt this\n    simp only [add_right_inj, exists_eq_left] at hi\u2082\n    obtain \u27e8A, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv \u27e8i, hi\u2081\u27e9\n    simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_nearLitters,\n      BaseSupport.add_nearLitters, Enumeration.smul_rel] at hi\u2081 hi\u2082 hj\u2081 hj\u2082\n    have hN\u2081\u2082 := congr_arg (\u00b7\u1d38) ((Enumeration.rel_coinjective _).coinjective hi\u2081 hi\u2082)\n    obtain hj\u2081 | \u27e8j, rfl, hj\u2081\u27e9 := hj\u2081\n    \u00b7 obtain hj\u2082 | \u27e8j, rfl, hj\u2082\u27e9 := hj\u2082\n      swap\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2081\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j).not_lt this\n      cases (Enumeration.rel_coinjective _).coinjective hj\u2081 hj\u2082\n      simp only [BasePerm.smul_nearLitter_litter] at hN\u2081\u2082\n      rw [hN\u2081\u2083, \u2190 (h\u03c1\u2081 A).2 N\u2083 \u27e8j, hj\u2081\u27e9, BasePerm.smul_nearLitter_litter, inv_smul_smul,\n        eq_inv_smul_iff, \u2190 BasePerm.smul_nearLitter_litter, (h\u03c1\u2082 A).2 N\u2083 \u27e8j, hj\u2081\u27e9] at hN\u2081\u2082\n      rw [hN\u2081\u2082]\n    \u00b7 simp only [add_right_inj, exists_eq_left] at hj\u2082\n      obtain hj\u2082 | hj\u2082 := hj\u2082\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2082\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j).not_lt this\n      have hN\u2083\u2084 := congr_arg (\u00b7\u1d38) ((Enumeration.rel_coinjective _).coinjective hj\u2081 hj\u2082)\n      simp only [BasePerm.smul_nearLitter_litter] at hN\u2081\u2082 hN\u2083\u2084\n      rw [hN\u2081\u2083] at hN\u2081\u2082\n      rwa [hN\u2081\u2082, smul_left_cancel_iff] at hN\u2083\u2084\n\ntheorem sameSpecLe_of_fixes (S : Support \u03b1) (hS : S.Strong) (T : Support \u03b3) (\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2)\n    (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n    (h\u03c1\u2081 : \u03c1\u2081\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (h\u03c1\u2082 : \u03c1\u2082\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim) :\n    SameSpecLE\n    (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim)\n    (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) := by\n  constructor\n  case atoms_bound_eq => intro; rfl\n  case nearLitters_bound_eq => intro; rfl\n  case atoms_dom_subset =>\n    simp only [add_derivBot, BaseSupport.add_atoms, Enumeration.add_rel_dom,\n      Set.union_subset_iff, Set.subset_union_left, true_and]\n    rintro A _ \u27e8i, \u27e8a, \u27e8A, a\u27e9, h\u2081, h\u2082\u27e9, rfl\u27e9\n    cases h\u2082\n    right\n    apply Set.mem_image_of_mem\n    refine \u27e8\u03c1\u2082\u1d41 A \u2022 (\u03c1\u2081\u1d41 A)\u207b\u00b9 \u2022 a, \u27e8A, \u03c1\u2082\u1d41 A \u2022 (\u03c1\u2081\u1d41 A)\u207b\u00b9 \u2022 a\u27e9, ?_, rfl\u27e9\n    rw [smul_atoms, Enumeration.smulPath_rel] at h\u2081 \u22a2\n    simp only [inv_smul_smul]\n    exact h\u2081\n  case nearLitters_dom_subset =>\n    simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.add_rel_dom,\n      Set.union_subset_iff, Set.subset_union_left, true_and]\n    rintro A _ \u27e8i, \u27e8N, \u27e8A, N\u27e9, h\u2081, h\u2082\u27e9, rfl\u27e9\n    cases h\u2082\n    right\n    apply Set.mem_image_of_mem\n    refine \u27e8\u03c1\u2082\u1d41 A \u2022 (\u03c1\u2081\u1d41 A)\u207b\u00b9 \u2022 N, \u27e8A, \u03c1\u2082\u1d41 A \u2022 (\u03c1\u2081\u1d41 A)\u207b\u00b9 \u2022 N\u27e9, ?_, rfl\u27e9\n    rw [smul_nearLitters, Enumeration.smulPath_rel] at h\u2081 \u22a2\n    simp only [inv_smul_smul]\n    exact h\u2081\n  case convAtoms_injective => exact convAtoms_injective_of_fixes h\u03c1\u2081 h\u03c1\u2082\n  case atomMemRel_le => exact atomMemRel_le_of_fixes h\u03c1\u2081 h\u03c1\u2082\n  case inflexible_of_inflexible => exact inflexible_of_inflexible_of_fixes h\u03c1\u2081 h\u03c1\u2082\n  case atoms_of_inflexible => exact atoms_of_inflexible_of_fixes hS h\u03c1\u2081 h\u03c1\u2082\n  case nearLitters_of_inflexible => exact nearLitters_of_inflexible_of_fixes hS h\u03c1\u2081 h\u03c1\u2082\n  case litter_eq_of_flexible => exact litter_eq_of_flexible_of_fixes h\u03c1\u2081 h\u03c1\u2082\n\n", "theoremStatement": "theorem spec_same_of_fixes (S : Support \u03b1) (hS : S.Strong) (T : Support \u03b3) (\u03c1 : AllPerm \u03b2)\n    (h\u03c1 : \u03c1\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim) :\n    (S + ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport) \u2197 LtLevel.elim).spec =\n    (S + (\u03c1\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim).spec ", "theoremName": "ConNF.Support.spec_same_of_fixes", "fileCreated": {"commit": "abf71bc79c407ceb462cc2edd2d994cda9cdef05", "date": "2024-04-04"}, "theoremCreated": {"commit": "6709914ae7f5cd3e2bb24b413e09aa844554d234", "date": "2024-11-30"}, "file": "ConNF/ConNF/Model/RaiseStrong.lean", "module": "ConNF.Model.RaiseStrong", "jsonFile": "ConNF.Model.RaiseStrong.jsonl", "positionMetadata": {"lineInFile": 699, "tokenPositionInFile": 34619, "theoremPositionInFile": 13}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 46, "numPremises": 83}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [Support.spec_eq_spec_iff]\n  apply sameSpec_antisymm\n  \u00b7 have := sameSpecLe_of_fixes S hS T 1 \u03c1 h\u03b3 ?_ h\u03c1\n    \u00b7 simp only [allPermForget_one, one_smul, smul_add] at this\n      exact this\n    \u00b7 simp only [allPermForget_one, one_smul]\n  \u00b7 have := sameSpecLe_of_fixes S hS T \u03c1 1 h\u03b3 h\u03c1 ?_\n    \u00b7 simp only [allPermForget_one, one_smul, smul_add] at this\n      exact this\n    \u00b7 simp only [allPermForget_one, one_smul]", "proofType": "tactic", "proofLengthLines": 10, "proofLengthTokens": 421}}
{"srcContext": "import ConNF.Model.Hailperin\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal ConNF.TSet\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\ntheorem ext (x y : TSet \u03b1) :\n    (\u2200 z : TSet \u03b2, z \u2208' x \u2194 z \u2208' y) \u2192 x = y :=\n  tSet_ext' h\u03b2 x y\n\ndef inter (x y : TSet \u03b1) : TSet \u03b1 :=\n  (TSet.exists_inter h\u03b2 x y).choose\n\nnotation:69 x:69 \" \u2293[\" h \"] \" y:69 => _root_.ConNF.inter h x y\nnotation:69 x:69 \" \u2293' \" y:69 => x \u2293[by assumption] y\n\n@[simp]\ntheorem mem_inter_iff (x y : TSet \u03b1) :\n    \u2200 z : TSet \u03b2, z \u2208' x \u2293' y \u2194 z \u2208' x \u2227 z \u2208' y :=\n  (TSet.exists_inter h\u03b2 x y).choose_spec\n\ndef compl (x : TSet \u03b1) : TSet \u03b1 :=\n  (TSet.exists_compl h\u03b2 x).choose\n\nnotation:1024 x:1024 \" \u1d9c[\" h \"]\" => _root_.ConNF.compl h x\nnotation:1024 x:1024 \" \u1d9c'\" => x\u1d9c[by assumption]\n\n@[simp]\ntheorem mem_compl_iff (x : TSet \u03b1) :\n    \u2200 z : TSet \u03b2, z \u2208' x\u1d9c' \u2194 \u00acz \u2208' x :=\n  (TSet.exists_compl h\u03b2 x).choose_spec\n\nnotation:1024 \"{\" x \"}[\" h \"]\" => _root_.ConNF.singleton h x\nnotation:1024 \"{\" x \"}'\" => {x}[by assumption]\n\n@[simp]\ntheorem mem_singleton_iff (x y : TSet \u03b2) :\n    y \u2208' {x}' \u2194 y = x :=\n  typedMem_singleton_iff' h\u03b2 x y\n\nnotation:1024 \"{\" x \", \" y \"}[\" h \"]\" => _root_.ConNF.TSet.up h x y\nnotation:1024 \"{\" x \", \" y \"}'\" => {x, y}[by assumption]\n\n@[simp]\ntheorem mem_up_iff (x y z : TSet \u03b2) :\n    z \u2208' {x, y}' \u2194 z = x \u2228 z = y :=\n  TSet.mem_up_iff h\u03b2 x y z\n\nnotation:1024 \"\u27e8\" x \", \" y \"\u27e9[\" h \", \" h' \"]\" => _root_.ConNF.TSet.op h h' x y\nnotation:1024 \"\u27e8\" x \", \" y \"\u27e9'\" => \u27e8x, y\u27e9[by assumption, by assumption]\n\ntheorem op_def (x y : TSet \u03b3) :\n    (\u27e8x, y\u27e9' : TSet \u03b1) = { {x}', {x, y}' }' :=\n  rfl\n\ndef singletonImage' (x : TSet \u03b2) : TSet \u03b1 :=\n  (TSet.exists_singletonImage h\u03b2 h\u03b3 h\u03b4 h\u03b5 x).choose\n\n@[simp]\ntheorem singletonImage'_spec (x : TSet \u03b2) :\n    \u2200 z w,\n    \u27e8 {z}', {w}' \u27e9' \u2208' singletonImage' h\u03b2 h\u03b3 h\u03b4 h\u03b5 x \u2194 \u27e8z, w\u27e9' \u2208' x :=\n  (TSet.exists_singletonImage h\u03b2 h\u03b3 h\u03b4 h\u03b5 x).choose_spec\n\ndef insertion2' (x : TSet \u03b3) : TSet \u03b1 :=\n  (TSet.exists_insertion2 h\u03b2 h\u03b3 h\u03b4 h\u03b5 h\u03b6 x).choose\n\n@[simp]\ntheorem insertion2'_spec (x : TSet \u03b3) :\n    \u2200 a b c, \u27e8 { {a}' }', \u27e8b, c\u27e9' \u27e9' \u2208' insertion2' h\u03b2 h\u03b3 h\u03b4 h\u03b5 h\u03b6 x \u2194\n    \u27e8a, c\u27e9' \u2208' x :=\n  (TSet.exists_insertion2 h\u03b2 h\u03b3 h\u03b4 h\u03b5 h\u03b6 x).choose_spec\n\ndef insertion3' (x : TSet \u03b3) : TSet \u03b1 :=\n  (TSet.exists_insertion3 h\u03b2 h\u03b3 h\u03b4 h\u03b5 h\u03b6 x).choose\n\ntheorem insertion3'_spec (x : TSet \u03b3) :\n    \u2200 a b c, \u27e8 { {a}' }', \u27e8b, c\u27e9' \u27e9' \u2208' insertion3' h\u03b2 h\u03b3 h\u03b4 h\u03b5 h\u03b6 x \u2194\n    \u27e8a, b\u27e9' \u2208' x :=\n  (TSet.exists_insertion3 h\u03b2 h\u03b3 h\u03b4 h\u03b5 h\u03b6 x).choose_spec\n\ndef vCross (x : TSet \u03b3) : TSet \u03b1 :=\n  (TSet.exists_cross h\u03b2 h\u03b3 h\u03b4 x).choose\n\n", "theoremStatement": "@[simp]\ntheorem vCross_spec (x : TSet \u03b3) :\n    \u2200 a, a \u2208' vCross h\u03b2 h\u03b3 h\u03b4 x \u2194 \u2203 b c, a = \u27e8b, c\u27e9' \u2227 c \u2208' x ", "theoremName": "ConNF.vCross_spec", "fileCreated": {"commit": "b12701769822aaf5451982e26d7b7d1c2f21b137", "date": "2024-04-11"}, "theoremCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "file": "ConNF/ConNF/Model/Result.lean", "module": "ConNF.Model.Result", "jsonFile": "ConNF.Model.Result.jsonl", "positionMetadata": {"lineInFile": 101, "tokenPositionInFile": 2742, "theoremPositionInFile": 25}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 12, "numPremises": 27}, "proofMetadata": {"hasProof": true, "proof": ":=\n  (TSet.exists_cross h\u03b2 h\u03b3 h\u03b4 x).choose_spec", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 47}}
{"srcContext": "import ConNF.Model.Result\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal ConNF.TSet\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\ndef union (x y : TSet \u03b1) : TSet \u03b1 :=\n  (x\u1d9c' \u2293' y\u1d9c')\u1d9c'\n\nnotation:68 x:68 \" \u2294[\" h \"] \" y:68 => _root_.ConNF.union h x y\nnotation:68 x:68 \" \u2294' \" y:68 => x \u2294[by assumption] y\n\n@[simp]\ntheorem mem_union_iff (x y : TSet \u03b1) :\n    \u2200 z : TSet \u03b2, z \u2208' x \u2294' y \u2194 z \u2208' x \u2228 z \u2208' y := by\n  rw [union]\n  intro z\n  rw [mem_compl_iff, mem_inter_iff, mem_compl_iff, mem_compl_iff, or_iff_not_and_not]\n\ndef higherIndex (\u03b1 : \u039b) : \u039b :=\n  (exists_gt \u03b1).choose\n\ntheorem lt_higherIndex {\u03b1 : \u039b} :\n    (\u03b1 : TypeIndex) < higherIndex \u03b1 :=\n  WithBot.coe_lt_coe.mpr (exists_gt \u03b1).choose_spec\n\ntheorem tSet_nonempty (h : \u2203 \u03b2 : \u039b, (\u03b2 : TypeIndex) < \u03b1) : Nonempty (TSet \u03b1) := by\n  obtain \u27e8\u03b1', h\u03b1\u27e9 := h\n  constructor\n  apply typeLower lt_higherIndex lt_higherIndex lt_higherIndex h\u03b1\n  apply cardinalOne lt_higherIndex lt_higherIndex\n\ndef empty : TSet \u03b1 :=\n  (tSet_nonempty \u27e8\u03b2, h\u03b2\u27e9).some \u2293' (tSet_nonempty \u27e8\u03b2, h\u03b2\u27e9).some\u1d9c'\n\n@[simp]\ntheorem mem_empty_iff :\n    \u2200 x : TSet \u03b2, \u00acx \u2208' empty h\u03b2 := by\n  intro x\n  rw [empty, mem_inter_iff, mem_compl_iff]\n  exact and_not_self\n\ndef univ : TSet \u03b1 :=\n  (empty h\u03b2)\u1d9c'\n\n@[simp]\ntheorem mem_univ_iff :\n    \u2200 x : TSet \u03b2, x \u2208' univ h\u03b2 := by\n  intro x\n  simp only [univ, mem_compl_iff, mem_empty_iff, not_false_eq_true]\n\n/-- The set of all ordered pairs. -/\ndef orderedPairs : TSet \u03b1 :=\n  vCross h\u03b2 h\u03b3 h\u03b4 (univ h\u03b4)\n\n@[simp]\ntheorem mem_orderedPairs_iff (x : TSet \u03b2) :\n    x \u2208' orderedPairs h\u03b2 h\u03b3 h\u03b4 \u2194 \u2203 a b, x = \u27e8a, b\u27e9' := by\n  simp only [orderedPairs, vCross_spec, mem_univ_iff, and_true]\n\ndef converse (x : TSet \u03b1) : TSet \u03b1 :=\n  converse' h\u03b2 h\u03b3 h\u03b4 x \u2293' orderedPairs h\u03b2 h\u03b3 h\u03b4\n\n@[simp]\ntheorem op_mem_converse_iff (x : TSet \u03b1) :\n    \u2200 a b, \u27e8a, b\u27e9' \u2208' converse h\u03b2 h\u03b3 h\u03b4 x \u2194 \u27e8b, a\u27e9' \u2208' x := by\n  intro a b\n  simp only [converse, mem_inter_iff, converse'_spec, mem_orderedPairs_iff, op_inj, exists_and_left,\n    exists_eq', and_true]\n\ndef cross (x y : TSet \u03b3) : TSet \u03b1 :=\n  converse h\u03b2 h\u03b3 h\u03b4 (vCross h\u03b2 h\u03b3 h\u03b4 x) \u2293' vCross h\u03b2 h\u03b3 h\u03b4 y\n\n@[simp]\ntheorem mem_cross_iff (x y : TSet \u03b3) :\n    \u2200 a, a \u2208' cross h\u03b2 h\u03b3 h\u03b4 x y \u2194 \u2203 b c, a = \u27e8b, c\u27e9' \u2227 b \u2208' x \u2227 c \u2208' y := by\n  intro a\n  rw [cross, mem_inter_iff, vCross_spec]\n  constructor\n  \u00b7 rintro \u27e8h\u2081, b, c, rfl, h\u2082\u27e9\n    simp only [op_mem_converse_iff, vCross_spec, op_inj] at h\u2081\n    obtain \u27e8b', c', \u27e8rfl, rfl\u27e9, h\u2081\u27e9 := h\u2081\n    exact \u27e8b, c, rfl, h\u2081, h\u2082\u27e9\n  \u00b7 rintro \u27e8b, c, rfl, h\u2081, h\u2082\u27e9\n    simp only [op_mem_converse_iff, vCross_spec, op_inj]\n    exact \u27e8\u27e8c, b, \u27e8rfl, rfl\u27e9, h\u2081\u27e9, \u27e8b, c, \u27e8rfl, rfl\u27e9, h\u2082\u27e9\u27e9\n\ndef singletonImage (x : TSet \u03b2) : TSet \u03b1 :=\n  singletonImage' h\u03b2 h\u03b3 h\u03b4 h\u03b5 x \u2293' (cross h\u03b2 h\u03b3 h\u03b4 (cardinalOne h\u03b4 h\u03b5) (cardinalOne h\u03b4 h\u03b5))\n\n@[simp]\ntheorem singletonImage_spec (x : TSet \u03b2) :\n    \u2200 z w,\n    \u27e8 {z}', {w}' \u27e9' \u2208' singletonImage h\u03b2 h\u03b3 h\u03b4 h\u03b5 x \u2194 \u27e8z, w\u27e9' \u2208' x := by\n  intro z w\n  rw [singletonImage, mem_inter_iff, singletonImage'_spec, and_iff_left_iff_imp]\n  intro hzw\n  rw [mem_cross_iff]\n  refine \u27e8{z}', {w}', rfl, ?_\u27e9\n  simp only [mem_cardinalOne_iff, singleton_inj, exists_eq', and_self]\n\ntheorem exists_of_mem_singletonImage {x : TSet \u03b2} {z w : TSet \u03b4}\n    (h : \u27e8z, w\u27e9' \u2208' singletonImage h\u03b2 h\u03b3 h\u03b4 h\u03b5 x) :\n    \u2203 a b, z = {a}' \u2227 w = {b}' := by\n  simp only [singletonImage, mem_inter_iff, mem_cross_iff, op_inj, mem_cardinalOne_iff] at h\n  obtain \u27e8-, _, _, \u27e8rfl, rfl\u27e9, \u27e8a, rfl\u27e9, \u27e8b, rfl\u27e9\u27e9 := h\n  exact \u27e8a, b, rfl, rfl\u27e9\n\n/-- Turn a model element encoding a relation into an actual relation. -/\ndef ExternalRel (r : TSet \u03b1) : Rel (TSet \u03b4) (TSet \u03b4) :=\n  \u03bb x y \u21a6 \u27e8x, y\u27e9' \u2208' r\n\n@[simp]\ntheorem externalRel_converse (r : TSet \u03b1) :\n    ExternalRel h\u03b2 h\u03b3 h\u03b4 (converse h\u03b2 h\u03b3 h\u03b4 r) = (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).inv := by\n  ext\n  simp only [ExternalRel, op_mem_converse_iff, Rel.inv_apply]\n\n/-- The codomain of a relation. -/\ndef codom (r : TSet \u03b1) : TSet \u03b3 :=\n  (typeLower lt_higherIndex h\u03b2 h\u03b3 h\u03b4 (singletonImage lt_higherIndex h\u03b2 h\u03b3 h\u03b4 r)\u1d9c[lt_higherIndex])\u1d9c'\n\n@[simp]\ntheorem mem_codom_iff (r : TSet \u03b1) (x : TSet \u03b4) :\n    x \u2208' codom h\u03b2 h\u03b3 h\u03b4 r \u2194 x \u2208 (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).codom := by\n  simp only [codom, mem_compl_iff, mem_typeLower_iff, not_forall, not_not]\n  constructor\n  \u00b7 rintro \u27e8y, hy\u27e9\n    obtain \u27e8a, b, rfl, hb\u27e9 := exists_of_mem_singletonImage lt_higherIndex h\u03b2 h\u03b3 h\u03b4 hy\n    rw [singleton_inj] at hb\n    subst hb\n    rw [singletonImage_spec] at hy\n    exact \u27e8a, hy\u27e9\n  \u00b7 rintro \u27e8a, ha\u27e9\n    use {a}'\n    rw [singletonImage_spec]\n    exact ha\n\n/-- The domain of a relation. -/\ndef dom (r : TSet \u03b1) : TSet \u03b3 :=\n  codom h\u03b2 h\u03b3 h\u03b4 (converse h\u03b2 h\u03b3 h\u03b4 r)\n\n@[simp]\ntheorem mem_dom_iff (r : TSet \u03b1) (x : TSet \u03b4) :\n    x \u2208' dom h\u03b2 h\u03b3 h\u03b4 r \u2194 x \u2208 (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).dom := by\n  rw [dom, mem_codom_iff, externalRel_converse, Rel.inv_codom]\n\n/-- The field of a relation. -/\ndef field (r : TSet \u03b1) : TSet \u03b3 :=\n  dom h\u03b2 h\u03b3 h\u03b4 r \u2294' codom h\u03b2 h\u03b3 h\u03b4 r\n\n@[simp]\ntheorem mem_field_iff (r : TSet \u03b1) (x : TSet \u03b4) :\n    x \u2208' field h\u03b2 h\u03b3 h\u03b4 r \u2194 x \u2208 (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).field := by\n  rw [field, mem_union_iff, mem_dom_iff, mem_codom_iff, Rel.field, Set.mem_union]\n\ndef subset : TSet \u03b1 :=\n  subset' h\u03b2 h\u03b3 h\u03b4 h\u03b5 \u2293' orderedPairs h\u03b2 h\u03b3 h\u03b4\n\n@[simp]\ntheorem subset_spec :\n    \u2200 a b, \u27e8a, b\u27e9' \u2208' subset h\u03b2 h\u03b3 h\u03b4 h\u03b5 \u2194 a \u2286[TSet \u03b5] b := by\n  intro a b\n  simp only [subset, mem_inter_iff, subset'_spec, mem_orderedPairs_iff, op_inj, exists_and_left,\n    exists_eq', and_true]\n\ndef membership : TSet \u03b1 :=\n  subset h\u03b2 h\u03b3 h\u03b4 h\u03b5 \u2293' cross h\u03b2 h\u03b3 h\u03b4 (cardinalOne h\u03b4 h\u03b5) (univ h\u03b4)\n\n", "theoremStatement": "@[simp]\ntheorem membership_spec :\n    \u2200 a b, \u27e8{a}', b\u27e9' \u2208' membership h\u03b2 h\u03b3 h\u03b4 h\u03b5 \u2194 a \u2208' b ", "theoremName": "ConNF.membership_spec", "fileCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "theoremCreated": {"commit": "6dd8406a01cc28b071bb26965294469664a1b592", "date": "2025-01-07"}, "file": "ConNF/ConNF/External/Basic.lean", "module": "ConNF.External.Basic", "jsonFile": "ConNF.External.Basic.jsonl", "positionMetadata": {"lineInFile": 186, "tokenPositionInFile": 5663, "theoremPositionInFile": 31}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 7, "repositoryPremises": true, "numRepositoryPremises": 26, "numPremises": 64}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  intro a b\n  rw [membership, mem_inter_iff, subset_spec]\n  simp only [mem_cross_iff, op_inj, mem_cardinalOne_iff, mem_univ_iff, and_true, exists_and_right,\n    exists_and_left, exists_eq', exists_eq_left', singleton_inj]\n  constructor\n  \u00b7 intro h\n    exact h a ((typedMem_singleton_iff' h\u03b5 a a).mpr rfl)\n  \u00b7 intro h c hc\n    simp only [typedMem_singleton_iff'] at hc\n    cases hc\n    exact h", "proofType": "tactic", "proofLengthLines": 11, "proofLengthTokens": 398}}
{"srcContext": "import ConNF.ModelData.PathEnumeration\n\n/-!\n# Supports\n\nIn this file, we define the notion of a support.\n\n## Main declarations\n\n* `ConNF.BaseSupport`: The type of supports of atoms.\n* `ConNF.Support`: The type of supports of objects of arbitrary type indices.\n-/\n\nuniverse u\n\nopen Cardinal\n\nnamespace ConNF\n\nvariable [Params.{u}]\n\n/-!\n## Base supports\n-/\n\nstructure BaseSupport where\n  atoms : Enumeration Atom\n  nearLitters : Enumeration NearLitter\n\nnamespace BaseSupport\n\ninstance : SuperA BaseSupport (Enumeration Atom) where\n  superA := atoms\n\ninstance : SuperN BaseSupport (Enumeration NearLitter) where\n  superN := nearLitters\n\n@[simp]\ntheorem mk_atoms {a : Enumeration Atom} {N : Enumeration NearLitter} :\n    (BaseSupport.mk a N)\u1d2c = a :=\n  rfl\n\n@[simp]\ntheorem mk_nearLitters {a : Enumeration Atom} {N : Enumeration NearLitter} :\n    (BaseSupport.mk a N)\u1d3a = N :=\n  rfl\n\ntheorem atoms_congr {S T : BaseSupport} (h : S = T) :\n    S\u1d2c = T\u1d2c :=\n  h \u25b8 rfl\n\ntheorem nearLitters_congr {S T : BaseSupport} (h : S = T) :\n    S\u1d3a = T\u1d3a :=\n  h \u25b8 rfl\n\n@[ext]\ntheorem ext {S T : BaseSupport} (h\u2081 : S\u1d2c = T\u1d2c) (h\u2082 : S\u1d3a = T\u1d3a) : S = T := by\n  obtain \u27e8SA, SN\u27e9 := S\n  obtain \u27e8TA, TN\u27e9 := T\n  cases h\u2081\n  cases h\u2082\n  rfl\n\ninstance : SMul BasePerm BaseSupport where\n  smul \u03c0 S := \u27e8\u03c0 \u2022 S\u1d2c, \u03c0 \u2022 S\u1d3a\u27e9\n\n@[simp]\ntheorem smul_atoms (\u03c0 : BasePerm) (S : BaseSupport) :\n    (\u03c0 \u2022 S)\u1d2c = \u03c0 \u2022 S\u1d2c :=\n  rfl\n\n@[simp]\ntheorem smul_nearLitters (\u03c0 : BasePerm) (S : BaseSupport) :\n    (\u03c0 \u2022 S)\u1d3a = \u03c0 \u2022 S\u1d3a :=\n  rfl\n\n@[simp]\ntheorem smul_atoms_eq_of_smul_eq {\u03c0 : BasePerm} {S : BaseSupport}\n    (h : \u03c0 \u2022 S = S) :\n    \u03c0 \u2022 S\u1d2c = S\u1d2c := by\n  rw [\u2190 smul_atoms, h]\n\n@[simp]\ntheorem smul_nearLitters_eq_of_smul_eq {\u03c0 : BasePerm} {S : BaseSupport}\n    (h : \u03c0 \u2022 S = S) :\n    \u03c0 \u2022 S\u1d3a = S\u1d3a := by\n  rw [\u2190 smul_nearLitters, h]\n\ninstance : MulAction BasePerm BaseSupport where\n  one_smul S := by\n    apply ext\n    \u00b7 rw [smul_atoms, one_smul]\n    \u00b7 rw [smul_nearLitters, one_smul]\n  mul_smul \u03c0\u2081 \u03c0\u2082 S := by\n    apply ext\n    \u00b7 rw [smul_atoms, smul_atoms, smul_atoms, mul_smul]\n    \u00b7 rw [smul_nearLitters, smul_nearLitters, smul_nearLitters, mul_smul]\n\ntheorem smul_eq_smul_iff (\u03c0\u2081 \u03c0\u2082 : BasePerm) (S : BaseSupport) :\n    \u03c0\u2081 \u2022 S = \u03c0\u2082 \u2022 S \u2194 (\u2200 a \u2208 S\u1d2c, \u03c0\u2081 \u2022 a = \u03c0\u2082 \u2022 a) \u2227 (\u2200 N \u2208 S\u1d3a, \u03c0\u2081 \u2022 N = \u03c0\u2082 \u2022 N) := by\n  constructor\n  \u00b7 intro h\n    constructor\n    \u00b7 rintro a \u27e8i, ha\u27e9\n      have := congr_arg (\u00b7\u1d2c.rel i (\u03c0\u2081 \u2022 a)) h\n      simp only [smul_atoms, Enumeration.smul_rel, inv_smul_smul, eq_iff_iff] at this\n      have := S\u1d2c.rel_coinjective.coinjective ha (this.mp ha)\n      rw [eq_inv_smul_iff] at this\n      rw [this]\n    \u00b7 rintro N \u27e8i, hN\u27e9\n      have := congr_arg (\u00b7\u1d3a.rel i (\u03c0\u2081 \u2022 N)) h\n      simp only [smul_nearLitters, Enumeration.smul_rel, inv_smul_smul, eq_iff_iff] at this\n      have := S\u1d3a.rel_coinjective.coinjective hN (this.mp hN)\n      rw [eq_inv_smul_iff] at this\n      rw [this]\n  \u00b7 intro h\n    ext : 2\n    \u00b7 rfl\n    \u00b7 ext i a : 3\n      rw [smul_atoms, smul_atoms, Enumeration.smul_rel, Enumeration.smul_rel]\n      constructor\n      \u00b7 intro ha\n        have := h.1 _ \u27e8i, ha\u27e9\n        rw [smul_inv_smul, \u2190 inv_smul_eq_iff] at this\n        rwa [this]\n      \u00b7 intro ha\n        have := h.1 _ \u27e8i, ha\u27e9\n        rw [smul_inv_smul, smul_eq_iff_eq_inv_smul] at this\n        rwa [\u2190 this]\n    \u00b7 rfl\n    \u00b7 ext i a : 3\n      rw [smul_nearLitters, smul_nearLitters, Enumeration.smul_rel, Enumeration.smul_rel]\n      constructor\n      \u00b7 intro hN\n        have := h.2 _ \u27e8i, hN\u27e9\n        rw [smul_inv_smul, \u2190 inv_smul_eq_iff] at this\n        rwa [this]\n      \u00b7 intro hN\n        have := h.2 _ \u27e8i, hN\u27e9\n        rw [smul_inv_smul, smul_eq_iff_eq_inv_smul] at this\n        rwa [\u2190 this]\n\ntheorem smul_eq_iff (\u03c0 : BasePerm) (S : BaseSupport) :\n    \u03c0 \u2022 S = S \u2194 (\u2200 a \u2208 S\u1d2c, \u03c0 \u2022 a = a) \u2227 (\u2200 N \u2208 S\u1d3a, \u03c0 \u2022 N = N) := by\n  have := smul_eq_smul_iff \u03c0 1 S\n  simp only [one_smul] at this\n  exact this\n\nnoncomputable instance : Add BaseSupport where\n  add S T := \u27e8S\u1d2c + T\u1d2c, S\u1d3a + T\u1d3a\u27e9\n\n@[simp]\ntheorem add_atoms (S T : BaseSupport) :\n    (S + T)\u1d2c = S\u1d2c + T\u1d2c :=\n  rfl\n\n@[simp]\ntheorem add_nearLitters (S T : BaseSupport) :\n    (S + T)\u1d3a = S\u1d3a + T\u1d3a :=\n  rfl\n\nend BaseSupport\n\ndef baseSupportEquiv : BaseSupport \u2243 Enumeration Atom \u00d7 Enumeration NearLitter where\n  toFun S := (S\u1d2c, S\u1d3a)\n  invFun S := \u27e8S.1, S.2\u27e9\n  left_inv _ := rfl\n  right_inv _ := rfl\n\ntheorem card_baseSupport : #BaseSupport = #\u03bc := by\n  rw [Cardinal.eq.mpr \u27e8baseSupportEquiv\u27e9, mk_prod, lift_id, lift_id,\n    card_enumeration_eq card_atom, card_enumeration_eq card_nearLitter, mul_eq_self aleph0_lt_\u03bc.le]\n\n/-!\n## Structural supports\n-/\n\nstructure Support (\u03b1 : TypeIndex) where\n  atoms : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)\n  nearLitters : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)\n\nnamespace Support\n\nvariable {\u03b1 \u03b2 : TypeIndex}\n\ninstance : SuperA (Support \u03b1) (Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) where\n  superA := atoms\n\ninstance : SuperN (Support \u03b1) (Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) where\n  superN := nearLitters\n\n@[simp]\ntheorem mk_atoms (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) (F : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) :\n    (\u27e8E, F\u27e9 : Support \u03b1)\u1d2c = E :=\n  rfl\n\n@[simp]\ntheorem mk_nearLitters (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) (F : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) :\n    (\u27e8E, F\u27e9 : Support \u03b1)\u1d3a = F :=\n  rfl\n\ninstance : Derivative (Support \u03b1) (Support \u03b2) \u03b1 \u03b2 where\n  deriv S A := \u27e8S\u1d2c \u21d8 A, S\u1d3a \u21d8 A\u27e9\n\ninstance : Coderivative (Support \u03b2) (Support \u03b1) \u03b1 \u03b2 where\n  coderiv S A := \u27e8S\u1d2c \u21d7 A, S\u1d3a \u21d7 A\u27e9\n\ninstance : BotDerivative (Support \u03b1) BaseSupport \u03b1 where\n  botDeriv S A := \u27e8S\u1d2c \u21d8. A, S\u1d3a \u21d8. A\u27e9\n  botSderiv S := \u27e8S\u1d2c \u2198., S\u1d3a \u2198.\u27e9\n  botDeriv_single S h := by dsimp only; rw [botDeriv_single, botDeriv_single]\n\n@[simp]\ntheorem deriv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u03b2) :\n    S\u1d2c \u21d8 A = (S \u21d8 A)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem deriv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u03b2) :\n    S\u1d3a \u21d8 A = (S \u21d8 A)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem sderiv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (h : \u03b2 < \u03b1) :\n    S\u1d2c \u2198 h = (S \u2198 h)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem sderiv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (h : \u03b2 < \u03b1) :\n    S\u1d3a \u2198 h = (S \u2198 h)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem coderiv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    S\u1d2c \u21d7 A = (S \u21d7 A)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem coderiv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    S\u1d3a \u21d7 A = (S \u21d7 A)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem scoderiv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (h : \u03b2 < \u03b1) :\n    S\u1d2c \u2197 h = (S \u2197 h)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem scoderiv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (h : \u03b2 < \u03b1) :\n    S\u1d3a \u2197 h = (S \u2197 h)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem derivBot_atoms {\u03b1 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u22a5) :\n    S\u1d2c \u21d8. A = (S \u21d8. A)\u1d2c :=\n  rfl\n\n", "theoremStatement": "@[simp]\ntheorem derivBot_nearLitters {\u03b1 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u22a5) :\n    S\u1d3a \u21d8. A = (S \u21d8. A)\u1d3a ", "theoremName": "ConNF.Support.derivBot_nearLitters", "fileCreated": {"commit": "39c33b4a743bea62dbcc549548b712ffd38ca65c", "date": "2024-12-05"}, "theoremCreated": {"commit": "d9f28df240ac4df047c3af0d236aed2e437e571f", "date": "2025-01-07"}, "file": "ConNF/ConNF/ModelData/Support.lean", "module": "ConNF.ModelData.Support", "jsonFile": "ConNF.ModelData.Support.jsonl", "positionMetadata": {"lineInFile": 258, "tokenPositionInFile": 6529, "theoremPositionInFile": 25}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 5, "repositoryPremises": true, "numRepositoryPremises": 14, "numPremises": 19}, "proofMetadata": {"hasProof": true, "proof": ":=\n  rfl", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 8}}
{"srcContext": "import ConNF.ModelData.Enumeration\nimport ConNF.Levels.StrPerm\n\n/-!\n# Enumerations over paths\n\nIn this file, we provide extra features to `Enumeration`s that take values of the form `\u03b1 \u219d \u22a5 \u00d7 X`.\n\n## Main declarations\n\n* `ConNF.Enumeration.ext_path`: An extensionality principle for such `Enumeration`s.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nnamespace ConNF\n\nvariable [Params.{u}]\n\nnamespace Enumeration\n\n/-- A helper function for making relations with domain and codomain of the form `\u03b1 \u219d \u22a5 \u00d7 X`\nby defining it on each branch. -/\ndef relWithPath {X Y : Type u} {\u03b1 : TypeIndex} (f : \u03b1 \u219d \u22a5 \u2192 Rel X Y) :\n    Rel (\u03b1 \u219d \u22a5 \u00d7 X) (\u03b1 \u219d \u22a5 \u00d7 Y) :=\n  \u03bb x y \u21a6 x.1 = y.1 \u2227 f x.1 x.2 y.2\n\ntheorem relWithPath_coinjective {X Y : Type u} {\u03b1 : TypeIndex} {f : \u03b1 \u219d \u22a5 \u2192 Rel X Y}\n    (hf : \u2200 A, (f A).Coinjective) :\n    (relWithPath f).Coinjective := by\n  constructor\n  rintro \u27e8_, y\u2081\u27e9 \u27e8_, y\u2082\u27e9 \u27e8A, x\u27e9 \u27e8rfl, h\u2081\u27e9 \u27e8rfl, h\u2082\u27e9\n  cases (hf A).coinjective h\u2081 h\u2082\n  rfl\n\ninstance (X : Type u) (\u03b1 \u03b2 : TypeIndex) :\n    Derivative (Enumeration (\u03b1 \u219d \u22a5 \u00d7 X)) (Enumeration (\u03b2 \u219d \u22a5 \u00d7 X)) \u03b1 \u03b2 where\n  deriv E A := E.invImage (\u03bb x \u21a6 (x.1 \u21d7 A, x.2))\n    (\u03bb x y h \u21a6 Prod.ext (Path.deriv_right_injective\n      ((Prod.mk.injEq _ _ _ _).mp h).1) ((Prod.mk.injEq _ _ _ _).mp h).2)\n\ntheorem deriv_rel {X : Type _} {\u03b1 \u03b2 : TypeIndex} (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 X)) (A : \u03b1 \u219d \u03b2)\n    (i : \u03ba) (x : \u03b2 \u219d \u22a5 \u00d7 X) :\n    (E \u21d8 A).rel i x \u2194 E.rel i (x.1 \u21d7 A, x.2) :=\n  Iff.rfl\n\ninstance (X : Type u) (\u03b1 \u03b2 : TypeIndex) :\n    Coderivative (Enumeration (\u03b2 \u219d \u22a5 \u00d7 X)) (Enumeration (\u03b1 \u219d \u22a5 \u00d7 X)) \u03b1 \u03b2 where\n  coderiv E A := E.image (\u03bb x \u21a6 (x.1 \u21d7 A, x.2))\n\ntheorem coderiv_rel {X : Type _} {\u03b1 \u03b2 : TypeIndex} (E : Enumeration (\u03b2 \u219d \u22a5 \u00d7 X)) (A : \u03b1 \u219d \u03b2)\n    (i : \u03ba) (x : \u03b1 \u219d \u22a5 \u00d7 X) :\n    (E \u21d7 A).rel i x \u2194 \u2203 B, x.1 = A \u21d8 B \u2227 E.rel i (B, x.2) := by\n  constructor\n  \u00b7 rintro \u27e8x, h, rfl\u27e9\n    exact \u27e8_, rfl, h\u27e9\n  \u00b7 rintro \u27e8B, h\u2081, h\u2082\u27e9\n    refine \u27e8(B, x.2), h\u2082, ?_\u27e9\n    apply Prod.ext\n    \u00b7 dsimp only\n      exact h\u2081.symm\n    \u00b7 rfl\n\ntheorem scoderiv_rel {X : Type _} {\u03b1 \u03b2 : TypeIndex} (E : Enumeration (\u03b2 \u219d \u22a5 \u00d7 X)) (h : \u03b2 < \u03b1)\n    (i : \u03ba) (x : \u03b1 \u219d \u22a5 \u00d7 X) :\n    (E \u2197 h).rel i x \u2194 \u2203 B, x.1 = B \u2197 h \u2227 E.rel i (B, x.2) :=\n  coderiv_rel E (.single h) i x\n\ntheorem eq_of_scoderiv_mem {X : Type _} {\u03b1 \u03b2 \u03b3 : TypeIndex} (E : Enumeration (\u03b2 \u219d \u22a5 \u00d7 X))\n    (h : \u03b2 < \u03b1) (h' : \u03b3 < \u03b1)\n    (i : \u03ba) (A : \u03b3 \u219d \u22a5) (x : X) (h : (E \u2197 h).rel i \u27e8A \u2197 h', x\u27e9) :\n    \u03b2 = \u03b3 := by\n  rw [scoderiv_rel] at h\n  obtain \u27e8B, h\u2081, h\u2082\u27e9 := h\n  exact Path.scoderiv_index_injective h\u2081.symm\n\ninstance (X : Type u) (\u03b1 : TypeIndex) :\n    BotDerivative (Enumeration (\u03b1 \u219d \u22a5 \u00d7 X)) (Enumeration X) \u03b1 where\n  botDeriv E A := E.invImage (\u03bb x \u21a6 (A, x)) (Prod.mk.inj_left A)\n  botSderiv E := E.invImage (\u03bb x \u21a6 (Path.nil \u2198., x)) (Prod.mk.inj_left (Path.nil \u2198.))\n  botDeriv_single E h := by\n    cases \u03b1 using WithBot.recBotCoe with\n    | bot => cases lt_irrefl \u22a5 h\n    | coe => rfl\n\ntheorem derivBot_rel {X : Type _} {\u03b1 : TypeIndex} (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 X)) (A : \u03b1 \u219d \u22a5)\n    (i : \u03ba) (x : X) :\n    (E \u21d8. A).rel i x \u2194 E.rel i (A, x) :=\n  Iff.rfl\n\n@[simp]\ntheorem mem_path_iff {X : Type _} {\u03b1 : TypeIndex} (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 X))\n    (A : \u03b1 \u219d \u22a5) (x : X) :\n    (A, x) \u2208 E \u2194 x \u2208 E \u21d8. A :=\n  Iff.rfl\n\ntheorem ext_path {X : Type u} {\u03b1 : TypeIndex} {E F : Enumeration (\u03b1 \u219d \u22a5 \u00d7 X)}\n    (h : \u2200 A, E \u21d8. A = F \u21d8. A) :\n    E = F := by\n  ext i x\n  \u00b7 have := congr_arg bound (h (Path.nil \u2198.))\n    exact this\n  \u00b7 have := congr_arg rel (h x.1)\n    exact iff_of_eq (congr_fun\u2082 this i x.2)\n\ntheorem deriv_derivBot {X : Type _} {\u03b1 \u03b2 : TypeIndex} (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 X))\n    (A : \u03b1 \u219d \u03b2) (B : \u03b2 \u219d \u22a5) :\n    E \u21d8 A \u21d8. B = E \u21d8. (A \u21d8 B) :=\n  rfl\n\n@[simp]\ntheorem coderiv_deriv_eq {X : Type _} {\u03b1 \u03b2 : TypeIndex} (E : Enumeration (\u03b2 \u219d \u22a5 \u00d7 X)) (A : \u03b1 \u219d \u03b2) :\n    E \u21d7 A \u21d8 A = E := by\n  apply ext_path\n  intro B\n  ext i x\n  \u00b7 rfl\n  \u00b7 simp only [derivBot_rel, deriv_rel, coderiv_rel,\n      Path.coderiv_eq_deriv, Path.deriv_right_inj, exists_eq_left']\n\ntheorem eq_of_mem_scoderiv_botDeriv {X : Type _} {\u03b1 \u03b2 : TypeIndex} {S : Enumeration (\u03b2 \u219d \u22a5 \u00d7 X)}\n    {A : \u03b1 \u219d \u22a5} {h : \u03b2 < \u03b1} {x : X} (hx : x \u2208 S \u2197 h \u21d8. A) :\n    \u2203 B : \u03b2 \u219d \u22a5, A = B \u2197 h := by\n  obtain \u27e8i, \u27e8B, y\u27e9, hi\u2081, hi\u2082\u27e9 := hx\n  cases hi\u2082\n  exact \u27e8B, rfl\u27e9\n\n", "theoremStatement": "@[simp]\ntheorem scoderiv_botDeriv_eq {X : Type _} {\u03b1 \u03b2 : TypeIndex} (S : Enumeration (\u03b2 \u219d \u22a5 \u00d7 X))\n    (A : \u03b2 \u219d \u22a5) (h : \u03b2 < \u03b1) :\n    S \u2197 h \u21d8. (A \u2197 h) = S \u21d8. A ", "theoremName": "ConNF.Enumeration.scoderiv_botDeriv_eq", "fileCreated": {"commit": "39c33b4a743bea62dbcc549548b712ffd38ca65c", "date": "2024-12-05"}, "theoremCreated": {"commit": "ce890707e37ede74a2fcd66134d3f403335c5cc1", "date": "2024-11-30"}, "file": "ConNF/ConNF/ModelData/PathEnumeration.lean", "module": "ConNF.ModelData.PathEnumeration", "jsonFile": "ConNF.ModelData.PathEnumeration.jsonl", "positionMetadata": {"lineInFile": 131, "tokenPositionInFile": 4177, "theoremPositionInFile": 12}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 20, "numPremises": 49}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  ext i x\n  \u00b7 rfl\n  \u00b7 simp only [derivBot_rel, scoderiv_rel, Path.scoderiv_left_inj, exists_eq_left']", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 107}}
{"srcContext": "import ConNF.Model.Hailperin\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal ConNF.TSet\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\ntheorem ext (x y : TSet \u03b1) :\n    (\u2200 z : TSet \u03b2, z \u2208' x \u2194 z \u2208' y) \u2192 x = y :=\n  tSet_ext' h\u03b2 x y\n\ndef inter (x y : TSet \u03b1) : TSet \u03b1 :=\n  (TSet.exists_inter h\u03b2 x y).choose\n\nnotation:69 x:69 \" \u2293[\" h \"] \" y:69 => _root_.ConNF.inter h x y\nnotation:69 x:69 \" \u2293' \" y:69 => x \u2293[by assumption] y\n\n@[simp]\ntheorem mem_inter_iff (x y : TSet \u03b1) :\n    \u2200 z : TSet \u03b2, z \u2208' x \u2293' y \u2194 z \u2208' x \u2227 z \u2208' y :=\n  (TSet.exists_inter h\u03b2 x y).choose_spec\n\ndef compl (x : TSet \u03b1) : TSet \u03b1 :=\n  (TSet.exists_compl h\u03b2 x).choose\n\nnotation:1024 x:1024 \" \u1d9c[\" h \"]\" => _root_.ConNF.compl h x\nnotation:1024 x:1024 \" \u1d9c'\" => x\u1d9c[by assumption]\n\n@[simp]\ntheorem mem_compl_iff (x : TSet \u03b1) :\n    \u2200 z : TSet \u03b2, z \u2208' x\u1d9c' \u2194 \u00acz \u2208' x :=\n  (TSet.exists_compl h\u03b2 x).choose_spec\n\nnotation:1024 \"{\" x \"}[\" h \"]\" => _root_.ConNF.singleton h x\nnotation:1024 \"{\" x \"}'\" => {x}[by assumption]\n\n@[simp]\ntheorem mem_singleton_iff (x y : TSet \u03b2) :\n    y \u2208' {x}' \u2194 y = x :=\n  typedMem_singleton_iff' h\u03b2 x y\n\nnotation:1024 \"{\" x \", \" y \"}[\" h \"]\" => _root_.ConNF.TSet.up h x y\nnotation:1024 \"{\" x \", \" y \"}'\" => {x, y}[by assumption]\n\n@[simp]\ntheorem mem_up_iff (x y z : TSet \u03b2) :\n    z \u2208' {x, y}' \u2194 z = x \u2228 z = y :=\n  TSet.mem_up_iff h\u03b2 x y z\n\nnotation:1024 \"\u27e8\" x \", \" y \"\u27e9[\" h \", \" h' \"]\" => _root_.ConNF.TSet.op h h' x y\nnotation:1024 \"\u27e8\" x \", \" y \"\u27e9'\" => \u27e8x, y\u27e9[by assumption, by assumption]\n\ntheorem op_def (x y : TSet \u03b3) :\n    (\u27e8x, y\u27e9' : TSet \u03b1) = { {x}', {x, y}' }' :=\n  rfl\n\ndef singletonImage' (x : TSet \u03b2) : TSet \u03b1 :=\n  (TSet.exists_singletonImage h\u03b2 h\u03b3 h\u03b4 h\u03b5 x).choose\n\n@[simp]\ntheorem singletonImage'_spec (x : TSet \u03b2) :\n    \u2200 z w,\n    \u27e8 {z}', {w}' \u27e9' \u2208' singletonImage' h\u03b2 h\u03b3 h\u03b4 h\u03b5 x \u2194 \u27e8z, w\u27e9' \u2208' x :=\n  (TSet.exists_singletonImage h\u03b2 h\u03b3 h\u03b4 h\u03b5 x).choose_spec\n\ndef insertion2' (x : TSet \u03b3) : TSet \u03b1 :=\n  (TSet.exists_insertion2 h\u03b2 h\u03b3 h\u03b4 h\u03b5 h\u03b6 x).choose\n\n", "theoremStatement": "@[simp]\ntheorem insertion2'_spec (x : TSet \u03b3) :\n    \u2200 a b c, \u27e8 { {a}' }', \u27e8b, c\u27e9' \u27e9' \u2208' insertion2' h\u03b2 h\u03b3 h\u03b4 h\u03b5 h\u03b6 x \u2194\n    \u27e8a, c\u27e9' \u2208' x ", "theoremName": "ConNF.insertion2'_spec", "fileCreated": {"commit": "b12701769822aaf5451982e26d7b7d1c2f21b137", "date": "2024-04-11"}, "theoremCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "file": "ConNF/ConNF/Model/Result.lean", "module": "ConNF.Model.Result", "jsonFile": "ConNF.Model.Result.jsonl", "positionMetadata": {"lineInFile": 84, "tokenPositionInFile": 2188, "theoremPositionInFile": 21}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 13, "numPremises": 25}, "proofMetadata": {"hasProof": true, "proof": ":=\n  (TSet.exists_insertion2 h\u03b2 h\u03b3 h\u03b4 h\u03b5 h\u03b6 x).choose_spec", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 58}}
{"srcContext": "import ConNF.External.Basic\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal ConNF.TSet\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\n/-- A set in our model that is a well-order. Internal well-orders are exactly external well-orders,\nso we externalise the definition for convenience. -/\ndef InternalWellOrder (r : TSet \u03b1) : Prop :=\n  IsWellOrder (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).field\n    (InvImage (ExternalRel h\u03b2 h\u03b3 h\u03b4 r) Subtype.val)\n\ndef InternallyWellOrdered (x : TSet \u03b3) : Prop :=\n  {y : TSet \u03b4 | y \u2208' x}.Subsingleton \u2228 (\u2203 r, InternalWellOrder h\u03b2 h\u03b3 h\u03b4 r \u2227 x = field h\u03b2 h\u03b3 h\u03b4 r)\n\n@[simp]\ntheorem externalRel_smul (r : TSet \u03b1) (\u03c1 : AllPerm \u03b1) :\n    ExternalRel h\u03b2 h\u03b3 h\u03b4 (\u03c1 \u2022 r) =\n      InvImage (ExternalRel h\u03b2 h\u03b3 h\u03b4 r) ((\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4)\u207b\u00b9 \u2022 \u00b7) := by\n  ext a b\n  simp only [ExternalRel, mem_smul_iff', allPerm_inv_sderiv', smul_op, InvImage]\n\nomit [Params] in\n/-- Well-orders are rigid. -/\ntheorem apply_eq_of_isWellOrder {X : Type _} {r : Rel X X} {f : X \u2192 X}\n    (hr : IsWellOrder X r) (hf : Function.Bijective f) (hf' : \u2200 x y, r x y \u2194 r (f x) (f y)) :\n    \u2200 x, f x = x := by\n  let emb : r \u227ci r := \u27e8\u27e8\u27e8f, hf.injective\u27e9, \u03bb {a b} \u21a6 (hf' a b).symm\u27e9, ?_\u27e9\n  \u00b7 have : emb = InitialSeg.refl r := Subsingleton.elim _ _\n    intro x\n    exact congr_arg (\u03bb f \u21a6 f x) this\n  \u00b7 intro a b h\n    exact hf.surjective _\n\nomit [Params] in\ntheorem apply_eq_of_isWellOrder' {X : Type _} {r : Rel X X} {f : X \u2192 X}\n    (hr : IsWellOrder r.field (InvImage r Subtype.val)) (hf : Function.Bijective f)\n    (hf' : \u2200 x y, r x y \u2194 r (f x) (f y)) :\n    \u2200 x \u2208 r.field, f x = x := by\n  have : \u2200 x \u2208 r.field, f x \u2208 r.field := by\n    rintro x (\u27e8y, h\u27e9 | \u27e8y, h\u27e9)\n    \u00b7 exact Or.inl \u27e8f y, (hf' x y).mp h\u27e9\n    \u00b7 exact Or.inr \u27e8f y, (hf' y x).mp h\u27e9\n  have := apply_eq_of_isWellOrder (f := \u03bb x \u21a6 \u27e8f x.val, this x.val x.prop\u27e9) hr \u27e8?_, ?_\u27e9 ?_\n  \u00b7 intro x hx\n    exact congr_arg Subtype.val (this \u27e8x, hx\u27e9)\n  \u00b7 intro x y h\n    rw [Subtype.mk.injEq] at h\n    exact Subtype.val_injective (hf.injective h)\n  \u00b7 intro x\n    obtain \u27e8y, hy\u27e9 := hf.surjective x.val\n    refine \u27e8\u27e8y, ?_\u27e9, ?_\u27e9\n    \u00b7 obtain (\u27e8z, h\u27e9 | \u27e8z, h\u27e9) := x.prop <;>\n          rw [\u2190 hy] at h <;>\n          obtain \u27e8z, rfl\u27e9 := hf.surjective z\n      \u00b7 exact Or.inl \u27e8z, (hf' y z).mpr h\u27e9\n      \u00b7 exact Or.inr \u27e8z, (hf' z y).mpr h\u27e9\n    \u00b7 simp only [hy]\n  \u00b7 intros\n    apply hf'\n\ntheorem exists_common_support_of_internallyWellOrdered' {x : TSet \u03b4}\n    (h : InternallyWellOrdered h\u03b3 h\u03b4 h\u03b5 x) :\n    \u2203 S : Support \u03b2, \u2200 y, y \u2208' x \u2192 S.Supports { { {y}' }' }[h\u03b3] := by\n  obtain (h | \u27e8r, h, rfl\u27e9) := h\n  \u00b7 obtain (h | \u27e8y, hy\u27e9) := h.eq_empty_or_singleton\n    \u00b7 use \u27e8Enumeration.empty, Enumeration.empty\u27e9\n      intro y hy\n      rw [Set.eq_empty_iff_forall_not_mem] at h\n      cases h y hy\n    \u00b7 obtain \u27e8S, hS\u27e9 := TSet.exists_support y\n      use S \u2197 h\u03b5 \u2197 h\u03b4 \u2197 h\u03b3\n      intro z hz\n      rw [Set.eq_singleton_iff_unique_mem] at hy\n      cases hy.2 z hz\n      refine \u27e8?_, \u03bb h \u21a6 by cases h\u27e9\n      intro \u03c1 h\u03c1\n      simp only [Support.smul_scoderiv, \u2190 allPermSderiv_forget', Support.scoderiv_inj] at h\u03c1\n      simp only [smul_singleton, singleton_inj]\n      exact hS _ h\u03c1\n  obtain \u27e8S, hS\u27e9 := TSet.exists_support r\n  use S\n  intro a ha\n  refine \u27e8?_, \u03bb h \u21a6 by cases h\u27e9\n  intro \u03c1 h\u03c1\n  have := hS \u03c1 h\u03c1\n  simp only [smul_singleton, singleton_inj]\n  apply apply_eq_of_isWellOrder' (r := ExternalRel h\u03b3 h\u03b4 h\u03b5 r)\n  \u00b7 exact h\n  \u00b7 exact MulAction.bijective (\u03c1 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5)\n  \u00b7 intro x y\n    conv_rhs => rw [\u2190 this]\n    simp only [externalRel_smul, InvImage, inv_smul_smul]\n  \u00b7 rwa [mem_field_iff] at ha\n\ninclude h\u03b3 in\ntheorem Support.Supports.ofSingleton {S : Support \u03b1} {x : TSet \u03b2}\n    (h : S.Supports {x}') :\n    letI : Level := \u27e8\u03b1\u27e9\n    letI : LeLevel \u03b1 := \u27e8le_rfl\u27e9\n    (S.strong \u2198 h\u03b2).Supports x := by\n  refine \u27e8?_, \u03bb h \u21a6 by cases h\u27e9\n  intro \u03c1 h\u03c1\n  open scoped Pointwise in\n  have := sUnion_singleton_symmetric_aux h\u03b3 h\u03b2 {y | y \u2208' x} S ?_ \u03c1 h\u03c1\n  \u00b7 apply ConNF.ext h\u03b3\n    intro z\n    simp only [Set.ext_iff, Set.mem_setOf_eq, Set.mem_smul_set_iff_inv_smul_mem] at this\n    rw [mem_smul_iff', allPerm_inv_sderiv', this]\n  \u00b7 intro \u03c1 h\u03c1\n    ext z\n    simp only [Set.mem_smul_set_iff_inv_smul_mem, Set.mem_image, Set.mem_setOf_eq]\n    have := h.supports \u03c1 h\u03c1\n    simp only [smul_singleton, singleton_inj] at this\n    constructor\n    \u00b7 rintro \u27e8y, h\u2081, h\u2082\u27e9\n      rw [\u2190 smul_eq_iff_eq_inv_smul, smul_singleton] at h\u2082\n      refine \u27e8_, ?_, h\u2082\u27e9\n      rw [\u2190 this]\n      simp only [mem_smul_iff', allPerm_inv_sderiv', inv_smul_smul]\n      exact h\u2081\n    \u00b7 rintro \u27e8y, h, rfl\u27e9\n      refine \u27e8(\u03c1 \u2198 h\u03b2 \u2198 h\u03b3)\u207b\u00b9 \u2022 y, ?_, ?_\u27e9\n      \u00b7 rwa [\u2190 allPerm_inv_sderiv', \u2190 mem_smul_iff', this]\n      \u00b7 simp only [smul_singleton, allPerm_inv_sderiv']\n\ninclude h\u03b3 in\ntheorem supports_of_supports_singletons {S : Support \u03b1} {s : Set (TSet \u03b2)}\n    (h : \u2200 x \u2208 s, S.Supports {x}') :\n    \u2203 S : Support \u03b2, \u2200 x \u2208 s, S.Supports x :=\n  \u27e8_, \u03bb x hx \u21a6 (h x hx).ofSingleton h\u03b2 h\u03b3\u27e9\n\n", "theoremStatement": "theorem exists_common_support_of_internallyWellOrdered {x : TSet \u03b4}\n    (h : InternallyWellOrdered h\u03b3 h\u03b4 h\u03b5 x) :\n    \u2203 S : Support \u03b4, \u2200 y, y \u2208' x \u2192 S.Supports {y}' ", "theoremName": "ConNF.exists_common_support_of_internallyWellOrdered", "fileCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "theoremCreated": {"commit": "1c08486feb882444888c228ce1501e92bb85e0e2", "date": "2025-01-07"}, "file": "ConNF/ConNF/External/WellOrder.lean", "module": "ConNF.External.WellOrder", "jsonFile": "ConNF.External.WellOrder.jsonl", "positionMetadata": {"lineInFile": 149, "tokenPositionInFile": 5069, "theoremPositionInFile": 8}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 16, "numPremises": 52}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  obtain \u27e8S, hS\u27e9 := exists_common_support_of_internallyWellOrdered' h\u03b3 h\u03b4 h\u03b5 h\n  have := supports_of_supports_singletons (S := S)\n      (s := singleton h\u03b4 '' (singleton h\u03b5 '' {y | y \u2208' x})) h\u03b3 h\u03b4 ?_\n  swap\n  \u00b7 simp only [Set.mem_image, Set.mem_setOf_eq, exists_exists_and_eq_and, forall_exists_index,\n      and_imp, forall_apply_eq_imp_iff\u2082]\n    exact hS\n  obtain \u27e8T, hT\u27e9 := this\n  have := supports_of_supports_singletons (S := T)\n      (s := singleton h\u03b5 '' {y | y \u2208' x}) h\u03b4 h\u03b5 ?_\n  swap\n  \u00b7 simp only [Set.mem_image, Set.mem_setOf_eq, forall_exists_index, and_imp,\n      forall_apply_eq_imp_iff\u2082] at hT \u22a2\n    exact hT\n  simp only [Set.mem_image, Set.mem_setOf_eq, forall_exists_index, and_imp,\n    forall_apply_eq_imp_iff\u2082] at this\n  exact this", "proofType": "tactic", "proofLengthLines": 17, "proofLengthTokens": 752}}
{"srcContext": "import ConNF.Model.Externalise\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b2 \u03b3 : \u039b} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n\nnamespace Support\n\ntheorem not_mem_scoderiv_botDeriv (S : Support \u03b3) (N : NearLitter) :\n    N \u2209 (S \u2197 h\u03b3 \u21d8. (Path.nil \u2198.))\u1d3a := by\n  rintro \u27e8i, \u27e8A, N'\u27e9, h\u2081, h\u2082\u27e9\n  simp only [Prod.mk.injEq] at h\u2082\n  cases A\n  case sderiv \u03b4 A h\u03b4 _ =>\n    simp only [Path.deriv_sderiv] at h\u2082\n    cases A\n    case nil => cases h\u2082.1\n    case sderiv \u03b6 A h\u03b6 _ =>\n      simp only [Path.deriv_sderiv] at h\u2082\n      cases h\u2082.1\n\nvariable [Level] [LtLevel \u03b2]\n\ntheorem not_mem_strong_botDeriv (S : Support \u03b3) (N : NearLitter) :\n    N \u2209 ((S \u2197 h\u03b3).strong \u21d8. (Path.nil \u2198.))\u1d3a := by\n  rintro h\n  rw [strong, close_nearLitters, preStrong_nearLitters, Enumeration.mem_add_iff] at h\n  obtain h | h := h\n  \u00b7 exact not_mem_scoderiv_botDeriv S N h\n  \u00b7 rw [mem_constrainsNearLitters_nearLitters] at h\n    obtain \u27e8B, N', hN', h\u27e9 := h\n    cases h using Relation.ReflTransGen.head_induction_on\n    case refl => exact not_mem_scoderiv_botDeriv S N hN'\n    case head x hx\u2081 hx\u2082 _ =>\n      obtain \u27e8\u27e8\u03b3, \u03b4, \u03b5, h\u03b4, h\u03b5, h\u03b4\u03b5, A\u27e9, t, B, hB, hN, ht\u27e9 := hx\u2082\n      simp only at hB\n      cases B\n      case nil =>\n        cases hB\n        obtain \u27e8C, N''\u27e9 := x\n        simp only at ht\n        cases ht.1\n        change _ \u2208 t.support\u1d3a at hN\n        rw [t.support_supports.2 rfl] at hN\n        obtain \u27e8i, hN\u27e9 := hN\n        cases hN\n      case sderiv \u03b4 B h\u03b4 _ _ =>\n        cases B\n        case nil => cases hB\n        case sderiv \u03b6 B h\u03b6 _ _ => cases hB\n\ntheorem raise_preStrong' (S : Support \u03b1) (hS : S.Strong) (T : Support \u03b3) (\u03c1 : AllPerm \u03b2)\n    (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2) :\n    (S + (\u03c1\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim).PreStrong := by\n  apply hS.toPreStrong.add\n  constructor\n  intro A N hN P t hA ht\n  obtain \u27e8A, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv hN\n  simp only [scoderiv_botDeriv_eq, add_derivBot, smul_derivBot,\n    BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters, interferenceSupport_nearLitters,\n    Enumeration.mem_add_iff, Enumeration.mem_smul, Enumeration.not_mem_empty, or_false] at hN\n  obtain \u27e8\u03b4, \u03b5, \u03b6, h\u03b5, h\u03b6, h\u03b5\u03b6, B\u27e9 := P\n  dsimp only at *\n  cases A\n  case sderiv \u03b6' A h\u03b6' _ =>\n    rw [\u2190 Path.coderiv_deriv] at hA\n    cases Path.sderiv_index_injective hA\n    apply Path.sderiv_left_inj.mp at hA\n    cases A\n    case nil =>\n      cases hA\n      cases not_mem_strong_botDeriv T _ hN\n    case sderiv \u03b9 A h\u03b9 _ _ =>\n      rw [\u2190 Path.coderiv_deriv] at hA\n      cases Path.sderiv_index_injective hA\n      cases hA\n      haveI : LtLevel \u03b4 := \u27e8A.le.trans_lt LtLevel.elim\u27e9\n      haveI : LtLevel \u03b5 := \u27e8h\u03b5.trans LtLevel.elim\u27e9\n      haveI : LtLevel \u03b6 := \u27e8h\u03b6.trans LtLevel.elim\u27e9\n      have := (T \u2197 h\u03b3).strong_strong.support_le hN \u27e8\u03b4, \u03b5, \u03b6, h\u03b5, h\u03b6, h\u03b5\u03b6, A\u27e9\n          (\u03c1\u207b\u00b9 \u21d8 A \u2198 h\u03b5 \u2022 t) rfl ?_\n      \u00b7 simp only [Tangle.smul_support, allPermSderiv_forget, allPermDeriv_forget,\n          allPermForget_inv, Tree.inv_deriv, Tree.inv_sderiv] at this\n        have := smul_le_smul this (\u03c1\u1d41 \u21d8 A \u2198 h\u03b5)\n        simp only [smul_inv_smul] at this\n        apply le_trans this\n        intro B\n        constructor\n        \u00b7 intro a ha\n          simp only [smul_derivBot, Tree.sderiv_apply, Tree.deriv_apply, Path.deriv_scoderiv,\n            deriv_derivBot, Enumeration.mem_smul] at ha\n          rw [deriv_derivBot, \u2190 Path.deriv_scoderiv, Path.coderiv_deriv', scoderiv_botDeriv_eq,]\n          simp only [Path.deriv_scoderiv, add_derivBot, smul_derivBot,\n            BaseSupport.add_atoms, BaseSupport.smul_atoms, Enumeration.mem_add_iff,\n            Enumeration.mem_smul]\n          exact Or.inl ha\n        \u00b7 intro N hN\n          simp only [smul_derivBot, Tree.sderiv_apply, Tree.deriv_apply, Path.deriv_scoderiv,\n            deriv_derivBot, Enumeration.mem_smul] at hN\n          rw [deriv_derivBot, \u2190 Path.deriv_scoderiv, Path.coderiv_deriv', scoderiv_botDeriv_eq,]\n          simp only [Path.deriv_scoderiv, add_derivBot, smul_derivBot,\n            BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters, Enumeration.mem_add_iff,\n            Enumeration.mem_smul]\n          exact Or.inl hN\n      \u00b7 rw [\u2190 smul_fuzz h\u03b5 h\u03b6 h\u03b5\u03b6, \u2190 ht]\n        simp only [Path.botSderiv_coe_eq, BasePerm.smul_nearLitter_litter, allPermDeriv_forget,\n          allPermForget_inv, Tree.inv_deriv, Tree.inv_sderiv, Tree.inv_sderivBot]\n        rfl\n\ntheorem raise_closed' (S : Support \u03b1) (hS : S.Strong) (T : Support \u03b3) (\u03c1 : AllPerm \u03b2)\n    (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n    (h\u03c1 : \u03c1\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim) :\n    (S + (\u03c1\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim).Closed := by\n  constructor\n  intro A\n  constructor\n  intro N\u2081 N\u2082 hN\u2081 hN\u2082 a ha\n  simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff,\n    BaseSupport.add_atoms] at hN\u2081 hN\u2082 \u22a2\n  obtain hN\u2081 | hN\u2081 := hN\u2081\n  \u00b7 obtain hN\u2082 | hN\u2082 := hN\u2082\n    \u00b7 exact Or.inl ((hS.closed A).interference_subset hN\u2081 hN\u2082 a ha)\n    \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv hN\u2082\n      simp only [smul_add, scoderiv_botDeriv_eq, add_derivBot, smul_derivBot,\n        BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters, Enumeration.mem_add_iff,\n        Enumeration.mem_smul, BaseSupport.add_atoms, BaseSupport.smul_atoms] at hN\u2081 hN\u2082 \u22a2\n      refine Or.inr (Or.inr ?_)\n      rw [mem_interferenceSupport_atoms]\n      refine \u27e8(\u03c1\u1d41 B)\u207b\u00b9 \u2022 N\u2081, ?_, (\u03c1\u1d41 B)\u207b\u00b9 \u2022 N\u2082, ?_, ?_\u27e9\n      \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n        rw [\u2190 Enumeration.mem_smul, \u2190 BaseSupport.smul_nearLitters, \u2190 smul_derivBot, h\u03c1]\n        exact Or.inl hN\u2081\n      \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n        simp only [interferenceSupport_nearLitters, Enumeration.not_mem_empty, or_false] at hN\u2082\n        exact Or.inr hN\u2082\n      \u00b7 rw [\u2190 BasePerm.smul_interference]\n        exact Set.smul_mem_smul_set ha\n  \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv hN\u2081\n    simp only [smul_add, scoderiv_botDeriv_eq, add_derivBot, smul_derivBot,\n      BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters, Enumeration.mem_add_iff,\n      Enumeration.mem_smul, BaseSupport.add_atoms, BaseSupport.smul_atoms] at hN\u2081 hN\u2082 \u22a2\n    refine Or.inr (Or.inr ?_)\n    rw [mem_interferenceSupport_atoms]\n    refine \u27e8(\u03c1\u1d41 B)\u207b\u00b9 \u2022 N\u2081, ?_, (\u03c1\u1d41 B)\u207b\u00b9 \u2022 N\u2082, ?_, ?_\u27e9\n    \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n      simp only [interferenceSupport_nearLitters, Enumeration.not_mem_empty, or_false] at hN\u2081\n      exact Or.inr hN\u2081\n    \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n      simp only [interferenceSupport_nearLitters, Enumeration.not_mem_empty, or_false] at hN\u2082\n      obtain hN\u2082 | hN\u2082 := hN\u2082\n      \u00b7 rw [\u2190 Enumeration.mem_smul, \u2190 BaseSupport.smul_nearLitters, \u2190 smul_derivBot, h\u03c1]\n        exact Or.inl hN\u2082\n      \u00b7 exact Or.inr hN\u2082\n    \u00b7 rw [\u2190 BasePerm.smul_interference]\n      exact Set.smul_mem_smul_set ha\n\n", "theoremStatement": "theorem raise_strong' (S : Support \u03b1) (hS : S.Strong) (T : Support \u03b3) (\u03c1 : AllPerm \u03b2)\n    (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n    (h\u03c1 : \u03c1\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim) :\n    (S + (\u03c1\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim).Strong ", "theoremName": "ConNF.Support.raise_strong'", "fileCreated": {"commit": "abf71bc79c407ceb462cc2edd2d994cda9cdef05", "date": "2024-04-04"}, "theoremCreated": {"commit": "6709914ae7f5cd3e2bb24b413e09aa844554d234", "date": "2024-11-30"}, "file": "ConNF/ConNF/Model/RaiseStrong.lean", "module": "ConNF.Model.RaiseStrong", "jsonFile": "ConNF.Model.RaiseStrong.jsonl", "positionMetadata": {"lineInFile": 174, "tokenPositionInFile": 7129, "theoremPositionInFile": 4}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 32, "numPremises": 47}, "proofMetadata": {"hasProof": true, "proof": ":=\n  \u27e8raise_preStrong' S hS T \u03c1 h\u03b3, raise_closed' S hS T \u03c1 h\u03b3 h\u03c1\u27e9", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 65}}
{"srcContext": "import ConNF.Base.TypeIndex\n\n/-!\n# Paths of type indices\n\nIn this file, we define the notion of a *path*, and the derivative and coderivative operations.\n\n## Main declarations\n\n* `ConNF.Path`: A path of type indices.\n* `ConNF.Path.recSderiv`, `ConNF.Path.recSderivLe`, `ConNF.Path.recSderivGlobal`:\n    Downwards induction principles for paths.\n* `ConNF.Path.recScoderiv`: An upwards induction principle for paths.\n-/\n\nuniverse u\n\nopen Cardinal WithBot\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 : TypeIndex}\n\n/-- A path of type indices starting at `\u03b1` and ending at `\u03b2` is a finite sequence of type indices\n`\u03b1 > ... > \u03b2`. -/\ninductive Path (\u03b1 : TypeIndex) : TypeIndex \u2192 Type u\n  | nil : Path \u03b1 \u03b1\n  | cons {\u03b2 \u03b3 : TypeIndex} : Path \u03b1 \u03b2 \u2192 \u03b3 < \u03b2 \u2192 Path \u03b1 \u03b3\n\n@[inherit_doc] infix:70 \" \u219d \"  => Path\n\ndef Path.single {\u03b1 \u03b2 : TypeIndex} (h : \u03b2 < \u03b1) : \u03b1 \u219d \u03b2 :=\n  .cons .nil h\n\n/-- Typeclass for the `\u2198` notation. -/\nclass SingleDerivative (X : Type _) (Y : outParam <| Type _)\n    (\u03b2 : outParam TypeIndex) (\u03b3 : TypeIndex) where\n  sderiv : X \u2192 \u03b3 < \u03b2 \u2192 Y\n\n/-- Typeclass for the `\u21d8` notation. -/\nclass Derivative (X : Type _) (Y : outParam <| Type _)\n    (\u03b2 : outParam TypeIndex) (\u03b3 : TypeIndex) extends SingleDerivative X Y \u03b2 \u03b3 where\n  deriv : X \u2192 \u03b2 \u219d \u03b3 \u2192 Y\n  sderiv x h := deriv x (.single h)\n  deriv_single : \u2200 x : X, \u2200 h : \u03b3 < \u03b2, deriv x (.single h) = sderiv x h := by intros; rfl\n\n/-- Typeclass for the `\u2198.` notation. -/\nclass BotSingleDerivative (X : Type _) (Y : outParam <| Type _) where\n  botSderiv : X \u2192 Y\n\n/-- Typeclass for the `\u21d8.` notation. -/\nclass BotDerivative (X : Type _) (Y : outParam <| Type _) (\u03b2 : outParam TypeIndex)\n    extends BotSingleDerivative X Y where\n  botDeriv : X \u2192 \u03b2 \u219d \u22a5 \u2192 Y\n  /-- We often need to do case analysis on `\u03b2` to show that it's a proper type index here.\n  This case check doesn't need to be done in most actual use cases of the notation. -/\n  botDeriv_single : \u2200 x : X, \u2200 h : \u22a5 < \u03b2, botDeriv x (.single h) = botSderiv x\n\n/-- Typeclass for the `\u2197` notation. -/\nclass SingleCoderivative (X : Type _) (Y : outParam <| Type _)\n    (\u03b2 : TypeIndex) (\u03b3 : outParam TypeIndex) where\n  scoderiv : X \u2192 \u03b3 < \u03b2 \u2192 Y\n\n/-- Typeclass for the `\u21d7` notation. -/\nclass Coderivative (X : Type _) (Y : outParam <| Type _)\n    (\u03b2 : TypeIndex) (\u03b3 : outParam TypeIndex) extends SingleCoderivative X Y \u03b2 \u03b3 where\n  coderiv : X \u2192 \u03b2 \u219d \u03b3 \u2192 Y\n  scoderiv x h := coderiv x (.single h)\n  coderiv_single : \u2200 x : X, \u2200 h : \u03b3 < \u03b2, coderiv x (.single h) = scoderiv x h := by intros; rfl\n\ninfixl:75 \" \u2198 \" => SingleDerivative.sderiv\ninfixl:75 \" \u21d8 \" => Derivative.deriv\npostfix:75 \" \u2198.\" => BotSingleDerivative.botSderiv\ninfixl:75 \" \u21d8. \" => BotDerivative.botDeriv\ninfixl:75 \" \u2197 \" => SingleCoderivative.scoderiv\ninfixl:75 \" \u21d7 \" => Coderivative.coderiv\n\n@[simp]\ntheorem deriv_single {X Y : Type _} [Derivative X Y \u03b2 \u03b3] (x : X) (h : \u03b3 < \u03b2) :\n    x \u21d8 .single h = x \u2198 h :=\n  Derivative.deriv_single x h\n\n@[simp]\ntheorem coderiv_single {X Y : Type _} [Coderivative X Y \u03b2 \u03b3] (x : X) (h : \u03b3 < \u03b2) :\n    x \u21d7 .single h = x \u2197 h :=\n  Coderivative.coderiv_single x h\n\n@[simp]\ntheorem botDeriv_single {X Y : Type _} [BotDerivative X Y \u03b2] (x : X) (h : \u22a5 < \u03b2) :\n    x \u21d8. .single h = x \u2198. :=\n  BotDerivative.botDeriv_single x h\n\n/-!\n## Downwards recursion along paths\n-/\n\ninstance : SingleDerivative (\u03b1 \u219d \u03b2) (\u03b1 \u219d \u03b3) \u03b2 \u03b3 where\n  sderiv := .cons\n\n/-- The downwards recursion principle for paths. -/\n@[elab_as_elim, induction_eliminator, cases_eliminator]\ndef Path.recSderiv {motive : \u2200 \u03b2, \u03b1 \u219d \u03b2 \u2192 Sort _}\n    (nil : motive \u03b1 .nil)\n    (sderiv : \u2200 \u03b2 \u03b3 (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2), motive \u03b2 A \u2192 motive \u03b3 (A \u2198 h)) :\n    {\u03b2 : TypeIndex} \u2192 (A : \u03b1 \u219d \u03b2) \u2192 motive \u03b2 A\n  | _, .nil => nil\n  | _, .cons A h => sderiv _ _ A h (recSderiv nil sderiv A)\n\n@[simp]\ntheorem Path.recSderiv_nil {motive : \u2200 \u03b2, \u03b1 \u219d \u03b2 \u2192 Sort _}\n    (nil : motive \u03b1 .nil)\n    (sderiv : \u2200 \u03b2 \u03b3 (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2), motive \u03b2 A \u2192 motive \u03b3 (A \u2198 h)) :\n    recSderiv (motive := motive) nil sderiv .nil = nil :=\n  rfl\n\n@[simp]\ntheorem Path.recSderiv_sderiv {motive : \u2200 \u03b2, \u03b1 \u219d \u03b2 \u2192 Sort _}\n    (nil : motive \u03b1 .nil)\n    (sderiv : \u2200 \u03b2 \u03b3 (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2), motive \u03b2 A \u2192 motive \u03b3 (A \u2198 h))\n    {\u03b2 \u03b3 : TypeIndex} (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2) :\n    recSderiv (motive := motive) nil sderiv (A \u2198 h) = sderiv \u03b2 \u03b3 A h (recSderiv nil sderiv A) :=\n  rfl\n\ntheorem Path.le (A : \u03b1 \u219d \u03b2) : \u03b2 \u2264 \u03b1 := by\n  induction A with\n  | nil => exact le_rfl\n  | sderiv \u03b2 \u03b3 _A h h' => exact h.le.trans h'\n\n/-- The downwards recursion principle for paths, specialised to the case where the motive at `\u03b2`\nonly depends on the fact that `\u03b2 \u2264 \u03b1`. -/\ndef Path.recSderivLe {motive : \u2200 \u03b2 \u2264 \u03b1, Sort _}\n    (nil : motive \u03b1 le_rfl)\n    (sderiv : \u2200 \u03b2 \u03b3, \u2200 (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2), motive \u03b2 A.le \u2192 motive \u03b3 (h.le.trans A.le)) :\n    {\u03b2 : TypeIndex} \u2192 (A : \u03b1 \u219d \u03b2) \u2192 motive \u03b2 A.le :=\n  Path.recSderiv (motive := \u03bb \u03b2 A \u21a6 motive \u03b2 A.le) nil sderiv\n\n@[simp]\ntheorem Path.recSderivLe_nil {motive : \u2200 \u03b2 \u2264 \u03b1, Sort _}\n    (nil : motive \u03b1 le_rfl)\n    (sderiv : \u2200 \u03b2 \u03b3 (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2), motive \u03b2 A.le \u2192 motive \u03b3 (h.le.trans A.le)) :\n    recSderivLe (motive := motive) nil sderiv .nil = nil :=\n  rfl\n\n@[simp]\ntheorem Path.recSderivLe_sderiv {motive : \u2200 \u03b2 \u2264 \u03b1, Sort _}\n    (nil : motive \u03b1 le_rfl)\n    (sderiv : \u2200 \u03b2 \u03b3 (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2), motive \u03b2 A.le \u2192 motive \u03b3 (h.le.trans A.le))\n    {\u03b2 \u03b3 : TypeIndex} (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2) :\n    recSderivLe (motive := motive) nil sderiv (A \u2198 h) = sderiv \u03b2 \u03b3 A h (recSderiv nil sderiv A) :=\n  rfl\n\n/-- The downwards recursion principle for paths, specialised to the case where the motive is not\ndependent on the relation of `\u03b2` to `\u03b1`. -/\n@[elab_as_elim]\ndef Path.recSderivGlobal {motive : TypeIndex \u2192 Sort _}\n    (nil : motive \u03b1)\n    (sderiv : \u2200 \u03b2 \u03b3, \u03b1 \u219d \u03b2 \u2192 \u03b3 < \u03b2 \u2192 motive \u03b2 \u2192 motive \u03b3) :\n    {\u03b2 : TypeIndex} \u2192 \u03b1 \u219d \u03b2 \u2192 motive \u03b2 :=\n  Path.recSderiv (motive := \u03bb \u03b2 _ \u21a6 motive \u03b2) nil sderiv\n\n@[simp]\ntheorem Path.recSderivGlobal_nil {motive : TypeIndex \u2192 Sort _}\n    (nil : motive \u03b1)\n    (sderiv : \u2200 \u03b2 \u03b3, \u03b1 \u219d \u03b2 \u2192 \u03b3 < \u03b2 \u2192 motive \u03b2 \u2192 motive \u03b3) :\n    recSderivGlobal (motive := motive) nil sderiv .nil = nil :=\n  rfl\n\n@[simp]\ntheorem Path.recSderivGlobal_sderiv {motive : TypeIndex \u2192 Sort _}\n    (nil : motive \u03b1)\n    (sderiv : \u2200 \u03b2 \u03b3, \u03b1 \u219d \u03b2 \u2192 \u03b3 < \u03b2 \u2192 motive \u03b2 \u2192 motive \u03b3)\n    {\u03b2 \u03b3 : TypeIndex} (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2) :\n    recSderivGlobal (motive := motive) nil sderiv (A \u2198 h) =\n      sderiv \u03b2 \u03b3 A h (recSderiv nil sderiv A) :=\n  rfl\n\n/-!\n## Derivatives of paths\n-/\n\ninstance : Derivative (\u03b1 \u219d \u03b2) (\u03b1 \u219d \u03b3) \u03b2 \u03b3 where\n  deriv A := Path.recSderivGlobal A (\u03bb _ _ _ h B \u21a6 B \u2198 h)\n\ninstance : BotDerivative (\u03b1 \u219d \u03b2) (\u03b1 \u219d \u22a5) \u03b2 where\n  botDeriv A B := A \u21d8 B\n  botSderiv A :=\n    match \u03b2 with\n      | \u22a5 => A\n      | (\u03b2 : \u039b) => A \u2198 bot_lt_coe \u03b2\n  botDeriv_single A h := by\n    cases \u03b2 using WithBot.recBotCoe with\n    | bot => cases lt_irrefl \u22a5 h\n    | coe => rfl\n\ninstance : Coderivative (\u03b2 \u219d \u03b3) (\u03b1 \u219d \u03b3) \u03b1 \u03b2 where\n  coderiv A B := B \u21d8 A\n\n@[simp]\ntheorem Path.deriv_nil (A : \u03b1 \u219d \u03b2) :\n    A \u21d8 .nil = A :=\n  rfl\n\n@[simp]\ntheorem Path.deriv_sderiv (A : \u03b1 \u219d \u03b2) (B : \u03b2 \u219d \u03b3) (h : \u03b4 < \u03b3) :\n    A \u21d8 (B \u2198 h) = A \u21d8 B \u2198 h :=\n  rfl\n\n@[simp]\ntheorem Path.nil_deriv (A : \u03b1 \u219d \u03b2) :\n    (.nil : \u03b1 \u219d \u03b1) \u21d8 A = A := by\n  induction A with\n  | nil => rfl\n  | sderiv \u03b3 \u03b4 A h ih => rw [deriv_sderiv, ih]\n\n@[simp]\ntheorem Path.deriv_sderivBot (A : \u03b1 \u219d \u03b2) (B : \u03b2 \u219d \u03b3) :\n    A \u21d8 (B \u2198.) = A \u21d8 B \u2198. := by\n  cases \u03b3 using WithBot.recBotCoe with\n  | bot => rfl\n  | coe => rfl\n\n@[simp]\ntheorem Path.botSderiv_bot_eq (A : \u03b1 \u219d \u22a5) :\n    A \u2198. = A :=\n  rfl\n\n@[simp]\ntheorem Path.botSderiv_coe_eq {\u03b2 : \u039b} (A : \u03b1 \u219d \u03b2) :\n    A \u2198 bot_lt_coe \u03b2 = A \u2198. :=\n  rfl\n\n@[simp]\ntheorem Path.deriv_assoc (A : \u03b1 \u219d \u03b2) (B : \u03b2 \u219d \u03b3) (C : \u03b3 \u219d \u03b4) :\n    A \u21d8 (B \u21d8 C) = A \u21d8 B \u21d8 C := by\n  induction C with\n  | nil => rfl\n  | sderiv \u03b5 \u03b6 C h ih => simp only [deriv_sderiv, ih]\n\n@[simp]\ntheorem Path.deriv_sderiv_assoc (A : \u03b1 \u219d \u03b2) (B : \u03b2 \u219d \u03b3) (h : \u03b4 < \u03b3) :\n    A \u21d8 (B \u2198 h) = A \u21d8 B \u2198 h :=\n  rfl\n\n@[simp]\ntheorem Path.deriv_scoderiv (A : \u03b1 \u219d \u03b2) (B : \u03b3 \u219d \u03b4) (h : \u03b3 < \u03b2) :\n    A \u21d8 (B \u2197 h) = A \u2198 h \u21d8 B := by\n  induction B with\n  | nil => rfl\n  | sderiv \u03b5 \u03b6 B h' ih =>\n    rw [deriv_sderiv, \u2190 ih]\n    rfl\n\n@[simp]\ntheorem Path.botDeriv_scoderiv (A : \u03b1 \u219d \u03b2) (B : \u03b3 \u219d \u22a5) (h : \u03b3 < \u03b2) :\n    A \u21d8. (B \u2197 h) = A \u2198 h \u21d8. B :=\n  deriv_scoderiv A B h\n\ntheorem Path.coderiv_eq_deriv (A : \u03b1 \u219d \u03b2) (B : \u03b2 \u219d \u03b3) :\n    B \u21d7 A = A \u21d8 B :=\n  rfl\n\ntheorem Path.coderiv_deriv (A : \u03b2 \u219d \u03b3) (h\u2081 : \u03b2 < \u03b1) (h\u2082 : \u03b4 < \u03b3) :\n    A \u2197 h\u2081 \u2198 h\u2082 = A \u2198 h\u2082 \u2197 h\u2081 :=\n  rfl\n\ntheorem Path.coderiv_deriv' (A : \u03b2 \u219d \u03b3) (h : \u03b2 < \u03b1) (B : \u03b3 \u219d \u03b4) :\n    A \u2197 h \u21d8 B = A \u21d8 B \u2197 h := by\n  induction B with\n  | nil => rfl\n  | sderiv \u03b5 \u03b6 B h' ih =>\n    rw [deriv_sderiv, ih]\n    rfl\n\ntheorem Path.eq_nil (A : \u03b2 \u219d \u03b2) :\n    A = .nil := by\n  cases A with\n  | nil => rfl\n  | sderiv \u03b3 _ A h => cases A.le.not_lt h\n\ntheorem Path.sderiv_index_injective {A : \u03b1 \u219d \u03b2} {B : \u03b1 \u219d \u03b3} {h\u03b4\u03b2 : \u03b4 < \u03b2} {h\u03b4\u03b3 : \u03b4 < \u03b3}\n    (h : A \u2198 h\u03b4\u03b2 = B \u2198 h\u03b4\u03b3) :\n    \u03b2 = \u03b3 := by\n  cases h\n  rfl\n\ntheorem Path.sderivBot_index_injective {\u03b2 \u03b3 : \u039b} {A : \u03b1 \u219d \u03b2} {B : \u03b1 \u219d \u03b3}\n    (h : A \u2198. = B \u2198.) :\n    \u03b2 = \u03b3 := by\n  cases h\n  rfl\n\ntheorem Path.sderiv_path_injective {A B : \u03b1 \u219d \u03b2} {h\u03b3 : \u03b3 < \u03b2} (h : A \u2198 h\u03b3 = B \u2198 h\u03b3) :\n    A = B := by\n  cases h\n  rfl\n\ntheorem Path.sderivBot_path_injective {\u03b2 : \u039b} {A B : \u03b1 \u219d \u03b2} (h : A \u2198. = B \u2198.) :\n    A = B := by\n  cases h\n  rfl\n\ntheorem Path.deriv_left_injective {A B : \u03b1 \u219d \u03b2} {C : \u03b2 \u219d \u03b3} (h : A \u21d8 C = B \u21d8 C) :\n    A = B := by\n  induction C with\n  | nil => exact h\n  | sderiv \u03b4 \u03b5 C h\u03b5 ih =>\n    rw [deriv_sderiv_assoc, deriv_sderiv_assoc] at h\n    exact ih (Path.sderiv_path_injective h)\n\ntheorem Path.deriv_right_injective {A : \u03b1 \u219d \u03b2} {B C : \u03b2 \u219d \u03b3} (h : A \u21d8 B = A \u21d8 C) :\n    B = C := by\n  induction C with\n  | nil => exact B.eq_nil\n  | sderiv \u03b4 \u03b5 C h\u03b5 ih =>\n    cases B with\n    | nil => cases C.le.not_lt h\u03b5\n    | sderiv \u03b6 \u03b7 B h\u03b5' =>\n      cases Path.sderiv_index_injective h\n      rw [deriv_sderiv_assoc, deriv_sderiv_assoc] at h\n      rw [ih (Path.sderiv_path_injective h)]\n\n@[simp]\ntheorem Path.sderiv_left_inj {A B : \u03b1 \u219d \u03b2} {h : \u03b3 < \u03b2} :\n    A \u2198 h = B \u2198 h \u2194 A = B :=\n  \u27e8Path.sderiv_path_injective, \u03bb h \u21a6 h \u25b8 rfl\u27e9\n\n@[simp]\ntheorem Path.deriv_left_inj {A B : \u03b1 \u219d \u03b2} {C : \u03b2 \u219d \u03b3} :\n    A \u21d8 C = B \u21d8 C \u2194 A = B :=\n  \u27e8deriv_left_injective, \u03bb h \u21a6 h \u25b8 rfl\u27e9\n\n@[simp]\ntheorem Path.deriv_right_inj {A : \u03b1 \u219d \u03b2} {B C : \u03b2 \u219d \u03b3} :\n    A \u21d8 B = A \u21d8 C \u2194 B = C :=\n  \u27e8deriv_right_injective, \u03bb h \u21a6 h \u25b8 rfl\u27e9\n\n@[simp]\ntheorem Path.scoderiv_left_inj {A B : \u03b2 \u219d \u03b3} {h : \u03b2 < \u03b1} :\n    A \u2197 h = B \u2197 h \u2194 A = B :=\n  deriv_right_inj\n\n@[simp]\ntheorem Path.coderiv_left_inj {A B : \u03b2 \u219d \u03b3} {C : \u03b1 \u219d \u03b2} :\n    A \u21d7 C = B \u21d7 C \u2194 A = B :=\n  deriv_right_inj\n\n@[simp]\ntheorem Path.coderiv_right_inj {A : \u03b2 \u219d \u03b3} {B C : \u03b1 \u219d \u03b2} :\n    A \u21d7 B = A \u21d7 C \u2194 B = C :=\n  deriv_left_inj\n\n/-!\n## Upwards recursion along paths\n-/\n\n/--\nThe same as `Path`, but the components of this path point \"upwards\" instead of \"downwards\".\nThis type is only used for proving `revScoderiv`, and should be considered an implementation detail.\n-/\ninductive RevPath (\u03b1 : TypeIndex) : TypeIndex \u2192 Type u\n  | nil : RevPath \u03b1 \u03b1\n  | cons {\u03b2 \u03b3 : TypeIndex} : RevPath \u03b1 \u03b2 \u2192 \u03b2 < \u03b3 \u2192 RevPath \u03b1 \u03b3\n\n/-- A computable statement of the recursion principle for `RevPath`. This needs to be written due\nto a current limitation in the Lean 4 kernel: it cannot generate code for the `.rec` functions. -/\ndef RevPath.rec' {motive : (\u03b2 : TypeIndex) \u2192 RevPath \u03b1 \u03b2 \u2192 Sort _}\n    (nil : motive \u03b1 RevPath.nil)\n    (cons : {\u03b2 \u03b3 : TypeIndex} \u2192 (A : RevPath \u03b1 \u03b2) \u2192 (h : \u03b2 < \u03b3) \u2192\n      motive \u03b2 A \u2192 motive \u03b3 (A.cons h)) :\n    {\u03b2 : TypeIndex} \u2192 (A : RevPath \u03b1 \u03b2) \u2192 motive \u03b2 A\n  | _, .nil => nil\n  | _, .cons A h => cons A h (RevPath.rec' nil cons A)\n\ndef RevPath.snoc (h : \u03b3 < \u03b2) : {\u03b1 : TypeIndex} \u2192 RevPath \u03b2 \u03b1 \u2192 RevPath \u03b3 \u03b1\n  | _, .nil => .cons .nil h\n  | _, .cons A h' => (RevPath.snoc h A).cons h'\n\ndef Path.rev : \u03b1 \u219d \u03b2 \u2192 RevPath \u03b2 \u03b1 :=\n  Path.recSderiv .nil (\u03bb _ _ _ h \u21a6 RevPath.snoc h)\n\n@[simp]\ntheorem Path.rev_nil :\n    (.nil : \u03b1 \u219d \u03b1).rev = .nil :=\n  rfl\n\n@[simp]\ntheorem Path.rev_sderiv (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2) :\n    (A \u2198 h).rev = A.rev.snoc h :=\n  rfl\n\ndef RevPath.rev : {\u03b1 : TypeIndex} \u2192 RevPath \u03b2 \u03b1 \u2192 \u03b1 \u219d \u03b2\n  | _, .nil => .nil\n  | _, .cons A h => RevPath.rev A \u2197 h\n\ntheorem Path.sderiv_rev (A : \u03b1 \u219d \u03b2) (h : \u03b3 < \u03b2) :\n    (A \u2198 h).rev = A.rev.snoc h :=\n  rfl\n\ntheorem Path.scoderiv_rev (A : \u03b2 \u219d \u03b3) (h : \u03b2 < \u03b1) :\n    (A \u2197 h).rev = A.rev.cons h := by\n  induction A with\n  | nil => rfl\n  | sderiv \u03b4 \u03b5 A h ih => rw [rev_sderiv, \u2190 coderiv_deriv, rev_sderiv, ih, RevPath.snoc]\n\ntheorem RevPath.snoc_rev (A : RevPath \u03b2 \u03b1) (h : \u03b3 < \u03b2) :\n    (A.snoc h).rev = A.rev \u2198 h := by\n  induction A with\n  | nil => rfl\n  | cons A h ih => rw [snoc, rev, ih, rev, Path.coderiv_deriv]\n\ntheorem Path.rev_rev (A : \u03b1 \u219d \u03b2) : A.rev.rev = A := by\n  induction A with\n  | nil => rfl\n  | sderiv \u03b3 \u03b4 A h ih => rw [Path.sderiv_rev, RevPath.snoc_rev, ih]\n\ndef Path.recScoderiv' {motive : \u2200 \u03b2, \u03b2 \u219d \u03b3 \u2192 Sort _}\n    (nil : motive \u03b3 .nil)\n    (scoderiv : \u2200 \u03b1 \u03b2 (A : \u03b2 \u219d \u03b3) (h : \u03b2 < \u03b1), motive \u03b2 A \u2192 motive \u03b1 (A \u2197 h))\n    {\u03b2 : TypeIndex} (A : RevPath \u03b3 \u03b2) : motive \u03b2 A.rev :=\n  RevPath.rec' (motive := \u03bb \u03b2 A \u21a6 motive \u03b2 A.rev) nil (\u03bb A \u21a6 scoderiv _ _ A.rev) A\n\n@[simp]\ntheorem Path.recScoderiv'_nil {motive : \u2200 \u03b2, \u03b2 \u219d \u03b3 \u2192 Sort _}\n    (nil : motive \u03b3 .nil)\n    (scoderiv : \u2200 \u03b1 \u03b2 (A : \u03b2 \u219d \u03b3) (h : \u03b2 < \u03b1), motive \u03b2 A \u2192 motive \u03b1 (A \u2197 h)) :\n    recScoderiv' (motive := motive) nil scoderiv .nil = nil :=\n  rfl\n\n@[simp]\ntheorem Path.recScoderiv'_cons {motive : \u2200 \u03b2, \u03b2 \u219d \u03b3 \u2192 Sort _}\n    (nil : motive \u03b3 .nil)\n    (scoderiv : \u2200 \u03b1 \u03b2 (A : \u03b2 \u219d \u03b3) (h : \u03b2 < \u03b1), motive \u03b2 A \u2192 motive \u03b1 (A \u2197 h))\n    (A : RevPath \u03b3 \u03b2) (h : \u03b2 < \u03b1) :\n    recScoderiv' (motive := motive) nil scoderiv (A.cons h) =\n      scoderiv \u03b1 \u03b2 A.rev h (recScoderiv' nil scoderiv A) :=\n  rfl\n\n/-- The upwards recursion principle for paths. The `scoderiv` computation rule\n`recScoderiv_scoderiv` is not a definitional equality. -/\n@[elab_as_elim]\ndef Path.recScoderiv {motive : \u2200 \u03b2, \u03b2 \u219d \u03b3 \u2192 Sort _}\n    (nil : motive \u03b3 .nil)\n    (scoderiv : \u2200 \u03b1 \u03b2 (A : \u03b2 \u219d \u03b3) (h : \u03b2 < \u03b1), motive \u03b2 A \u2192 motive \u03b1 (A \u2197 h))\n    {\u03b2 : TypeIndex} (A : \u03b2 \u219d \u03b3) : motive \u03b2 A :=\n  cast (by rw [A.rev_rev]) (recScoderiv' nil scoderiv A.rev)\n\n@[simp]\ntheorem Path.recScoderiv_nil {motive : \u2200 \u03b2, \u03b2 \u219d \u03b3 \u2192 Sort _}\n    (nil : motive \u03b3 .nil)\n    (scoderiv : \u2200 \u03b1 \u03b2 (A : \u03b2 \u219d \u03b3) (h : \u03b2 < \u03b1), motive \u03b2 A \u2192 motive \u03b1 (A \u2197 h)) :\n    recScoderiv (motive := motive) nil scoderiv .nil = nil :=\n  rfl\n\n@[simp]\ntheorem Path.recScoderiv_scoderiv {motive : \u2200 \u03b2, \u03b2 \u219d \u03b3 \u2192 Sort _}\n    (nil : motive \u03b3 .nil)\n    (scoderiv : \u2200 \u03b1 \u03b2 (A : \u03b2 \u219d \u03b3) (h : \u03b2 < \u03b1), motive \u03b2 A \u2192 motive \u03b1 (A \u2197 h))\n    {\u03b1 \u03b2 : TypeIndex} (A : \u03b2 \u219d \u03b3) (h : \u03b2 < \u03b1) :\n    recScoderiv (motive := motive) nil scoderiv (A \u2197 h) =\n      scoderiv \u03b1 \u03b2 A h (recScoderiv nil scoderiv A) := by\n  unfold recScoderiv\n  rw [cast_eq_iff_heq, scoderiv_rev, recScoderiv'_cons]\n  congr 1\n  \u00b7 exact A.rev_rev\n  \u00b7 exact HEq.symm (cast_heq _ _)\n\n", "theoremStatement": "theorem Path.scoderiv_index_injective {A : \u03b2 \u219d \u03b4} {B : \u03b3 \u219d \u03b4} {h\u03b2\u03b1 : \u03b2 < \u03b1} {h\u03b3\u03b1 : \u03b3 < \u03b1}\n    (h : A \u2197 h\u03b2\u03b1 = B \u2197 h\u03b3\u03b1) :\n    \u03b2 = \u03b3 ", "theoremName": "ConNF.Path.scoderiv_index_injective", "fileCreated": {"commit": "8896e416a16c39e1fe487b5fc7c78bc20c4e182b", "date": "2024-12-03"}, "theoremCreated": {"commit": "ce890707e37ede74a2fcd66134d3f403335c5cc1", "date": "2024-11-30"}, "file": "ConNF/ConNF/Levels/Path.lean", "module": "ConNF.Levels.Path", "jsonFile": "ConNF.Levels.Path.jsonl", "positionMetadata": {"lineInFile": 467, "tokenPositionInFile": 14717, "theoremPositionInFile": 59}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 9, "repositoryPremises": true, "numRepositoryPremises": 14, "numPremises": 30}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  have := congr_arg rev h\n  rw [scoderiv_rev, scoderiv_rev, RevPath.cons.injEq] at this\n  exact this.1", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 108}}
{"srcContext": "import ConNF.ModelData.Enumeration\nimport ConNF.Levels.StrPerm\n\n/-!\n# Enumerations over paths\n\nIn this file, we provide extra features to `Enumeration`s that take values of the form `\u03b1 \u219d \u22a5 \u00d7 X`.\n\n## Main declarations\n\n* `ConNF.Enumeration.ext_path`: An extensionality principle for such `Enumeration`s.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nnamespace ConNF\n\nvariable [Params.{u}]\n\nnamespace Enumeration\n\n/-- A helper function for making relations with domain and codomain of the form `\u03b1 \u219d \u22a5 \u00d7 X`\nby defining it on each branch. -/\ndef relWithPath {X Y : Type u} {\u03b1 : TypeIndex} (f : \u03b1 \u219d \u22a5 \u2192 Rel X Y) :\n    Rel (\u03b1 \u219d \u22a5 \u00d7 X) (\u03b1 \u219d \u22a5 \u00d7 Y) :=\n  \u03bb x y \u21a6 x.1 = y.1 \u2227 f x.1 x.2 y.2\n\ntheorem relWithPath_coinjective {X Y : Type u} {\u03b1 : TypeIndex} {f : \u03b1 \u219d \u22a5 \u2192 Rel X Y}\n    (hf : \u2200 A, (f A).Coinjective) :\n    (relWithPath f).Coinjective := by\n  constructor\n  rintro \u27e8_, y\u2081\u27e9 \u27e8_, y\u2082\u27e9 \u27e8A, x\u27e9 \u27e8rfl, h\u2081\u27e9 \u27e8rfl, h\u2082\u27e9\n  cases (hf A).coinjective h\u2081 h\u2082\n  rfl\n\ninstance (X : Type u) (\u03b1 \u03b2 : TypeIndex) :\n    Derivative (Enumeration (\u03b1 \u219d \u22a5 \u00d7 X)) (Enumeration (\u03b2 \u219d \u22a5 \u00d7 X)) \u03b1 \u03b2 where\n  deriv E A := E.invImage (\u03bb x \u21a6 (x.1 \u21d7 A, x.2))\n    (\u03bb x y h \u21a6 Prod.ext (Path.deriv_right_injective\n      ((Prod.mk.injEq _ _ _ _).mp h).1) ((Prod.mk.injEq _ _ _ _).mp h).2)\n\ntheorem deriv_rel {X : Type _} {\u03b1 \u03b2 : TypeIndex} (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 X)) (A : \u03b1 \u219d \u03b2)\n    (i : \u03ba) (x : \u03b2 \u219d \u22a5 \u00d7 X) :\n    (E \u21d8 A).rel i x \u2194 E.rel i (x.1 \u21d7 A, x.2) :=\n  Iff.rfl\n\ninstance (X : Type u) (\u03b1 \u03b2 : TypeIndex) :\n    Coderivative (Enumeration (\u03b2 \u219d \u22a5 \u00d7 X)) (Enumeration (\u03b1 \u219d \u22a5 \u00d7 X)) \u03b1 \u03b2 where\n  coderiv E A := E.image (\u03bb x \u21a6 (x.1 \u21d7 A, x.2))\n\ntheorem coderiv_rel {X : Type _} {\u03b1 \u03b2 : TypeIndex} (E : Enumeration (\u03b2 \u219d \u22a5 \u00d7 X)) (A : \u03b1 \u219d \u03b2)\n    (i : \u03ba) (x : \u03b1 \u219d \u22a5 \u00d7 X) :\n    (E \u21d7 A).rel i x \u2194 \u2203 B, x.1 = A \u21d8 B \u2227 E.rel i (B, x.2) := by\n  constructor\n  \u00b7 rintro \u27e8x, h, rfl\u27e9\n    exact \u27e8_, rfl, h\u27e9\n  \u00b7 rintro \u27e8B, h\u2081, h\u2082\u27e9\n    refine \u27e8(B, x.2), h\u2082, ?_\u27e9\n    apply Prod.ext\n    \u00b7 dsimp only\n      exact h\u2081.symm\n    \u00b7 rfl\n\n", "theoremStatement": "theorem scoderiv_rel {X : Type _} {\u03b1 \u03b2 : TypeIndex} (E : Enumeration (\u03b2 \u219d \u22a5 \u00d7 X)) (h : \u03b2 < \u03b1)\n    (i : \u03ba) (x : \u03b1 \u219d \u22a5 \u00d7 X) :\n    (E \u2197 h).rel i x \u2194 \u2203 B, x.1 = B \u2197 h \u2227 E.rel i (B, x.2) ", "theoremName": "ConNF.Enumeration.scoderiv_rel", "fileCreated": {"commit": "39c33b4a743bea62dbcc549548b712ffd38ca65c", "date": "2024-12-05"}, "theoremCreated": {"commit": "ce890707e37ede74a2fcd66134d3f403335c5cc1", "date": "2024-11-30"}, "file": "ConNF/ConNF/ModelData/PathEnumeration.lean", "module": "ConNF.ModelData.PathEnumeration", "jsonFile": "ConNF.ModelData.PathEnumeration.jsonl", "positionMetadata": {"lineInFile": 67, "tokenPositionInFile": 1972, "theoremPositionInFile": 4}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 15, "numPremises": 33}, "proofMetadata": {"hasProof": true, "proof": ":=\n  coderiv_rel E (.single h) i x", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 34}}
{"srcContext": "import ConNF.ModelData.PathEnumeration\n\n/-!\n# Supports\n\nIn this file, we define the notion of a support.\n\n## Main declarations\n\n* `ConNF.BaseSupport`: The type of supports of atoms.\n* `ConNF.Support`: The type of supports of objects of arbitrary type indices.\n-/\n\nuniverse u\n\nopen Cardinal\n\nnamespace ConNF\n\nvariable [Params.{u}]\n\n/-!\n## Base supports\n-/\n\nstructure BaseSupport where\n  atoms : Enumeration Atom\n  nearLitters : Enumeration NearLitter\n\nnamespace BaseSupport\n\ninstance : SuperA BaseSupport (Enumeration Atom) where\n  superA := atoms\n\ninstance : SuperN BaseSupport (Enumeration NearLitter) where\n  superN := nearLitters\n\n@[simp]\ntheorem mk_atoms {a : Enumeration Atom} {N : Enumeration NearLitter} :\n    (BaseSupport.mk a N)\u1d2c = a :=\n  rfl\n\n@[simp]\ntheorem mk_nearLitters {a : Enumeration Atom} {N : Enumeration NearLitter} :\n    (BaseSupport.mk a N)\u1d3a = N :=\n  rfl\n\ntheorem atoms_congr {S T : BaseSupport} (h : S = T) :\n    S\u1d2c = T\u1d2c :=\n  h \u25b8 rfl\n\ntheorem nearLitters_congr {S T : BaseSupport} (h : S = T) :\n    S\u1d3a = T\u1d3a :=\n  h \u25b8 rfl\n\n@[ext]\ntheorem ext {S T : BaseSupport} (h\u2081 : S\u1d2c = T\u1d2c) (h\u2082 : S\u1d3a = T\u1d3a) : S = T := by\n  obtain \u27e8SA, SN\u27e9 := S\n  obtain \u27e8TA, TN\u27e9 := T\n  cases h\u2081\n  cases h\u2082\n  rfl\n\ninstance : SMul BasePerm BaseSupport where\n  smul \u03c0 S := \u27e8\u03c0 \u2022 S\u1d2c, \u03c0 \u2022 S\u1d3a\u27e9\n\n@[simp]\ntheorem smul_atoms (\u03c0 : BasePerm) (S : BaseSupport) :\n    (\u03c0 \u2022 S)\u1d2c = \u03c0 \u2022 S\u1d2c :=\n  rfl\n\n@[simp]\ntheorem smul_nearLitters (\u03c0 : BasePerm) (S : BaseSupport) :\n    (\u03c0 \u2022 S)\u1d3a = \u03c0 \u2022 S\u1d3a :=\n  rfl\n\n@[simp]\ntheorem smul_atoms_eq_of_smul_eq {\u03c0 : BasePerm} {S : BaseSupport}\n    (h : \u03c0 \u2022 S = S) :\n    \u03c0 \u2022 S\u1d2c = S\u1d2c := by\n  rw [\u2190 smul_atoms, h]\n\n@[simp]\ntheorem smul_nearLitters_eq_of_smul_eq {\u03c0 : BasePerm} {S : BaseSupport}\n    (h : \u03c0 \u2022 S = S) :\n    \u03c0 \u2022 S\u1d3a = S\u1d3a := by\n  rw [\u2190 smul_nearLitters, h]\n\ninstance : MulAction BasePerm BaseSupport where\n  one_smul S := by\n    apply ext\n    \u00b7 rw [smul_atoms, one_smul]\n    \u00b7 rw [smul_nearLitters, one_smul]\n  mul_smul \u03c0\u2081 \u03c0\u2082 S := by\n    apply ext\n    \u00b7 rw [smul_atoms, smul_atoms, smul_atoms, mul_smul]\n    \u00b7 rw [smul_nearLitters, smul_nearLitters, smul_nearLitters, mul_smul]\n\ntheorem smul_eq_smul_iff (\u03c0\u2081 \u03c0\u2082 : BasePerm) (S : BaseSupport) :\n    \u03c0\u2081 \u2022 S = \u03c0\u2082 \u2022 S \u2194 (\u2200 a \u2208 S\u1d2c, \u03c0\u2081 \u2022 a = \u03c0\u2082 \u2022 a) \u2227 (\u2200 N \u2208 S\u1d3a, \u03c0\u2081 \u2022 N = \u03c0\u2082 \u2022 N) := by\n  constructor\n  \u00b7 intro h\n    constructor\n    \u00b7 rintro a \u27e8i, ha\u27e9\n      have := congr_arg (\u00b7\u1d2c.rel i (\u03c0\u2081 \u2022 a)) h\n      simp only [smul_atoms, Enumeration.smul_rel, inv_smul_smul, eq_iff_iff] at this\n      have := S\u1d2c.rel_coinjective.coinjective ha (this.mp ha)\n      rw [eq_inv_smul_iff] at this\n      rw [this]\n    \u00b7 rintro N \u27e8i, hN\u27e9\n      have := congr_arg (\u00b7\u1d3a.rel i (\u03c0\u2081 \u2022 N)) h\n      simp only [smul_nearLitters, Enumeration.smul_rel, inv_smul_smul, eq_iff_iff] at this\n      have := S\u1d3a.rel_coinjective.coinjective hN (this.mp hN)\n      rw [eq_inv_smul_iff] at this\n      rw [this]\n  \u00b7 intro h\n    ext : 2\n    \u00b7 rfl\n    \u00b7 ext i a : 3\n      rw [smul_atoms, smul_atoms, Enumeration.smul_rel, Enumeration.smul_rel]\n      constructor\n      \u00b7 intro ha\n        have := h.1 _ \u27e8i, ha\u27e9\n        rw [smul_inv_smul, \u2190 inv_smul_eq_iff] at this\n        rwa [this]\n      \u00b7 intro ha\n        have := h.1 _ \u27e8i, ha\u27e9\n        rw [smul_inv_smul, smul_eq_iff_eq_inv_smul] at this\n        rwa [\u2190 this]\n    \u00b7 rfl\n    \u00b7 ext i a : 3\n      rw [smul_nearLitters, smul_nearLitters, Enumeration.smul_rel, Enumeration.smul_rel]\n      constructor\n      \u00b7 intro hN\n        have := h.2 _ \u27e8i, hN\u27e9\n        rw [smul_inv_smul, \u2190 inv_smul_eq_iff] at this\n        rwa [this]\n      \u00b7 intro hN\n        have := h.2 _ \u27e8i, hN\u27e9\n        rw [smul_inv_smul, smul_eq_iff_eq_inv_smul] at this\n        rwa [\u2190 this]\n\ntheorem smul_eq_iff (\u03c0 : BasePerm) (S : BaseSupport) :\n    \u03c0 \u2022 S = S \u2194 (\u2200 a \u2208 S\u1d2c, \u03c0 \u2022 a = a) \u2227 (\u2200 N \u2208 S\u1d3a, \u03c0 \u2022 N = N) := by\n  have := smul_eq_smul_iff \u03c0 1 S\n  simp only [one_smul] at this\n  exact this\n\nnoncomputable instance : Add BaseSupport where\n  add S T := \u27e8S\u1d2c + T\u1d2c, S\u1d3a + T\u1d3a\u27e9\n\n@[simp]\ntheorem add_atoms (S T : BaseSupport) :\n    (S + T)\u1d2c = S\u1d2c + T\u1d2c :=\n  rfl\n\n@[simp]\ntheorem add_nearLitters (S T : BaseSupport) :\n    (S + T)\u1d3a = S\u1d3a + T\u1d3a :=\n  rfl\n\nend BaseSupport\n\ndef baseSupportEquiv : BaseSupport \u2243 Enumeration Atom \u00d7 Enumeration NearLitter where\n  toFun S := (S\u1d2c, S\u1d3a)\n  invFun S := \u27e8S.1, S.2\u27e9\n  left_inv _ := rfl\n  right_inv _ := rfl\n\ntheorem card_baseSupport : #BaseSupport = #\u03bc := by\n  rw [Cardinal.eq.mpr \u27e8baseSupportEquiv\u27e9, mk_prod, lift_id, lift_id,\n    card_enumeration_eq card_atom, card_enumeration_eq card_nearLitter, mul_eq_self aleph0_lt_\u03bc.le]\n\n/-!\n## Structural supports\n-/\n\nstructure Support (\u03b1 : TypeIndex) where\n  atoms : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)\n  nearLitters : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)\n\nnamespace Support\n\nvariable {\u03b1 \u03b2 : TypeIndex}\n\ninstance : SuperA (Support \u03b1) (Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) where\n  superA := atoms\n\ninstance : SuperN (Support \u03b1) (Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) where\n  superN := nearLitters\n\n@[simp]\ntheorem mk_atoms (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) (F : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) :\n    (\u27e8E, F\u27e9 : Support \u03b1)\u1d2c = E :=\n  rfl\n\n@[simp]\ntheorem mk_nearLitters (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) (F : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) :\n    (\u27e8E, F\u27e9 : Support \u03b1)\u1d3a = F :=\n  rfl\n\ninstance : Derivative (Support \u03b1) (Support \u03b2) \u03b1 \u03b2 where\n  deriv S A := \u27e8S\u1d2c \u21d8 A, S\u1d3a \u21d8 A\u27e9\n\ninstance : Coderivative (Support \u03b2) (Support \u03b1) \u03b1 \u03b2 where\n  coderiv S A := \u27e8S\u1d2c \u21d7 A, S\u1d3a \u21d7 A\u27e9\n\ninstance : BotDerivative (Support \u03b1) BaseSupport \u03b1 where\n  botDeriv S A := \u27e8S\u1d2c \u21d8. A, S\u1d3a \u21d8. A\u27e9\n  botSderiv S := \u27e8S\u1d2c \u2198., S\u1d3a \u2198.\u27e9\n  botDeriv_single S h := by dsimp only; rw [botDeriv_single, botDeriv_single]\n\n@[simp]\ntheorem deriv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u03b2) :\n    S\u1d2c \u21d8 A = (S \u21d8 A)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem deriv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u03b2) :\n    S\u1d3a \u21d8 A = (S \u21d8 A)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem sderiv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (h : \u03b2 < \u03b1) :\n    S\u1d2c \u2198 h = (S \u2198 h)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem sderiv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (h : \u03b2 < \u03b1) :\n    S\u1d3a \u2198 h = (S \u2198 h)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem coderiv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    S\u1d2c \u21d7 A = (S \u21d7 A)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem coderiv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    S\u1d3a \u21d7 A = (S \u21d7 A)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem scoderiv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (h : \u03b2 < \u03b1) :\n    S\u1d2c \u2197 h = (S \u2197 h)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem scoderiv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (h : \u03b2 < \u03b1) :\n    S\u1d3a \u2197 h = (S \u2197 h)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem derivBot_atoms {\u03b1 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u22a5) :\n    S\u1d2c \u21d8. A = (S \u21d8. A)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem derivBot_nearLitters {\u03b1 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u22a5) :\n    S\u1d3a \u21d8. A = (S \u21d8. A)\u1d3a :=\n  rfl\n\ntheorem ext' {S T : Support \u03b1} (h\u2081 : S\u1d2c = T\u1d2c) (h\u2082 : S\u1d3a = T\u1d3a) : S = T := by\n  obtain \u27e8SA, SN\u27e9 := S\n  obtain \u27e8TA, TN\u27e9 := T\n  cases h\u2081\n  cases h\u2082\n  rfl\n\n@[ext]\ntheorem ext {S T : Support \u03b1} (h : \u2200 A, S \u21d8. A = T \u21d8. A) : S = T := by\n  obtain \u27e8SA, SN\u27e9 := S\n  obtain \u27e8TA, TN\u27e9 := T\n  rw [mk.injEq]\n  constructor\n  \u00b7 apply Enumeration.ext_path\n    intro A\n    exact BaseSupport.atoms_congr (h A)\n  \u00b7 apply Enumeration.ext_path\n    intro A\n    exact BaseSupport.nearLitters_congr (h A)\n\n@[simp]\ntheorem deriv_derivBot {\u03b1 : TypeIndex} (S : Support \u03b1)\n    (A : \u03b1 \u219d \u03b2) (B : \u03b2 \u219d \u22a5) :\n    S \u21d8 A \u21d8. B = S \u21d8. (A \u21d8 B) :=\n  rfl\n\n@[simp]\ntheorem coderiv_deriv_eq {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    S \u21d7 A \u21d8 A = S :=\n  ext' (S\u1d2c.coderiv_deriv_eq A) (S\u1d3a.coderiv_deriv_eq A)\n\ntheorem eq_of_atom_mem_scoderiv_botDeriv {\u03b1 \u03b2 : TypeIndex} {S : Support \u03b2} {A : \u03b1 \u219d \u22a5}\n    {h : \u03b2 < \u03b1} {a : Atom} (ha : a \u2208 (S \u2197 h \u21d8. A)\u1d2c) :\n    \u2203 B : \u03b2 \u219d \u22a5, A = B \u2197 h :=\n  Enumeration.eq_of_mem_scoderiv_botDeriv ha\n\ntheorem eq_of_nearLitter_mem_scoderiv_botDeriv {\u03b1 \u03b2 : TypeIndex} {S : Support \u03b2} {A : \u03b1 \u219d \u22a5}\n    {h : \u03b2 < \u03b1} {N : NearLitter} (hN : N \u2208 (S \u2197 h \u21d8. A)\u1d3a) :\n    \u2203 B : \u03b2 \u219d \u22a5, A = B \u2197 h :=\n  Enumeration.eq_of_mem_scoderiv_botDeriv hN\n\n@[simp]\ntheorem scoderiv_botDeriv_eq {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (A : \u03b2 \u219d \u22a5) (h : \u03b2 < \u03b1) :\n    S \u2197 h \u21d8. (A \u2197 h) = S \u21d8. A :=\n  BaseSupport.ext (Enumeration.scoderiv_botDeriv_eq _ _ _) (Enumeration.scoderiv_botDeriv_eq _ _ _)\n\n@[simp]\ntheorem scoderiv_deriv_eq {\u03b1 \u03b2 \u03b3 : TypeIndex} (S : Support \u03b2) (A : \u03b2 \u219d \u03b3) (h : \u03b2 < \u03b1) :\n    S \u2197 h \u21d8 (A \u2197 h) = S \u21d8 A := by\n  apply ext\n  intro B\n  simp only [deriv_derivBot, \u2190 scoderiv_botDeriv_eq S (A \u21d8 B) h, Path.coderiv_deriv']\n\n@[simp]\ntheorem coderiv_inj {\u03b1 \u03b2 : TypeIndex} (S T : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    S \u21d7 A = T \u21d7 A \u2194 S = T := by\n  constructor\n  swap\n  \u00b7 rintro rfl\n    rfl\n  intro h\n  ext B : 1\n  have : S \u21d7 A \u21d8 A \u21d8. B = T \u21d7 A \u21d8 A \u21d8. B := by rw [h]\n  rwa [coderiv_deriv_eq, coderiv_deriv_eq] at this\n\n@[simp]\ntheorem scoderiv_inj {\u03b1 \u03b2 : TypeIndex} (S T : Support \u03b2) (h : \u03b2 < \u03b1) :\n    S \u2197 h = T \u2197 h \u2194 S = T :=\n  coderiv_inj S T (.single h)\n\ninstance {\u03b1 : TypeIndex} : SMul (StrPerm \u03b1) (Support \u03b1) where\n  smul \u03c0 S := \u27e8\u03c0 \u2022 S\u1d2c, \u03c0 \u2022 S\u1d3a\u27e9\n\n@[simp]\ntheorem smul_atoms {\u03b1 : TypeIndex} (\u03c0 : StrPerm \u03b1) (S : Support \u03b1) :\n    (\u03c0 \u2022 S)\u1d2c = \u03c0 \u2022 S\u1d2c :=\n  rfl\n\n@[simp]\ntheorem smul_nearLitters {\u03b1 : TypeIndex} (\u03c0 : StrPerm \u03b1) (S : Support \u03b1) :\n    (\u03c0 \u2022 S)\u1d3a = \u03c0 \u2022 S\u1d3a :=\n  rfl\n\ntheorem smul_atoms_eq_of_smul_eq {\u03b1 : TypeIndex} {\u03c0 : StrPerm \u03b1} {S : Support \u03b1}\n    (h : \u03c0 \u2022 S = S) :\n    \u03c0 \u2022 S\u1d2c = S\u1d2c := by\n  rw [\u2190 smul_atoms, h]\n\ntheorem smul_nearLitters_eq_of_smul_eq {\u03b1 : TypeIndex} {\u03c0 : StrPerm \u03b1} {S : Support \u03b1}\n    (h : \u03c0 \u2022 S = S) :\n    \u03c0 \u2022 S\u1d3a = S\u1d3a := by\n  rw [\u2190 smul_nearLitters, h]\n\ninstance {\u03b1 : TypeIndex} : MulAction (StrPerm \u03b1) (Support \u03b1) where\n  one_smul S := by\n    apply ext'\n    \u00b7 rw [smul_atoms, one_smul]\n    \u00b7 rw [smul_nearLitters, one_smul]\n  mul_smul \u03c0\u2081 \u03c0\u2082 S := by\n    apply ext'\n    \u00b7 rw [smul_atoms, smul_atoms, smul_atoms, mul_smul]\n    \u00b7 rw [smul_nearLitters, smul_nearLitters, smul_nearLitters, mul_smul]\n\n@[simp]\ntheorem smul_derivBot {\u03b1 : TypeIndex} (\u03c0 : StrPerm \u03b1) (S : Support \u03b1) (A : \u03b1 \u219d \u22a5) :\n    (\u03c0 \u2022 S) \u21d8. A = \u03c0 A \u2022 (S \u21d8. A) :=\n  rfl\n\ntheorem smul_coderiv {\u03b1 : TypeIndex} (\u03c0 : StrPerm \u03b1) (S : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    \u03c0 \u2022 S \u21d7 A = (\u03c0 \u21d8 A \u2022 S) \u21d7 A := by\n  ext B i x\n  \u00b7 rfl\n  \u00b7 constructor\n    \u00b7 rintro \u27e8\u27e8C, x\u27e9, hS, hx\u27e9\n      simp only [Prod.mk.injEq] at hx\n      obtain \u27e8rfl, rfl\u27e9 := hx\n      exact \u27e8\u27e8C, x\u27e9, hS, rfl\u27e9\n    \u00b7 rintro \u27e8\u27e8C, x\u27e9, hS, hx\u27e9\n      simp only [Prod.mk.injEq] at hx\n      obtain \u27e8rfl, rfl\u27e9 := hx\n      exact \u27e8\u27e8C, _\u27e9, hS, rfl\u27e9\n  \u00b7 rfl\n  \u00b7 constructor\n    \u00b7 rintro \u27e8\u27e8C, x\u27e9, hS, hx\u27e9\n      simp only [Prod.mk.injEq] at hx\n      obtain \u27e8rfl, rfl\u27e9 := hx\n      exact \u27e8\u27e8C, x\u27e9, hS, rfl\u27e9\n    \u00b7 rintro \u27e8\u27e8C, a\u27e9, hS, hx\u27e9\n      simp only [Prod.mk.injEq] at hx\n      obtain \u27e8rfl, rfl\u27e9 := hx\n      exact \u27e8\u27e8C, _\u27e9, hS, rfl\u27e9\n\ntheorem smul_scoderiv {\u03b1 : TypeIndex} (\u03c0 : StrPerm \u03b1) (S : Support \u03b2) (h : \u03b2 < \u03b1) :\n    \u03c0 \u2022 S \u2197 h = (\u03c0 \u2198 h \u2022 S) \u2197 h :=\n  smul_coderiv \u03c0 S (Path.single h)\n\ntheorem smul_eq_smul_iff (\u03c0\u2081 \u03c0\u2082 : StrPerm \u03b2) (S : Support \u03b2) :\n    \u03c0\u2081 \u2022 S = \u03c0\u2082 \u2022 S \u2194\n      \u2200 A, (\u2200 a \u2208 (S \u21d8. A)\u1d2c, \u03c0\u2081 A \u2022 a = \u03c0\u2082 A \u2022 a) \u2227 (\u2200 N \u2208 (S \u21d8. A)\u1d3a, \u03c0\u2081 A \u2022 N = \u03c0\u2082 A \u2022 N) := by\n  constructor\n  \u00b7 intro h A\n    have := congr_arg (\u00b7 \u21d8. A) h\n    simp only [smul_derivBot, BaseSupport.smul_eq_smul_iff] at this\n    exact this\n  \u00b7 intro h\n    apply ext\n    intro A\n    simp only [smul_derivBot, BaseSupport.smul_eq_smul_iff]\n    exact h A\n\ntheorem smul_eq_iff (\u03c0 : StrPerm \u03b2) (S : Support \u03b2) :\n    \u03c0 \u2022 S = S \u2194 \u2200 A, (\u2200 a \u2208 (S \u21d8. A)\u1d2c, \u03c0 A \u2022 a = a) \u2227 (\u2200 N \u2208 (S \u21d8. A)\u1d3a, \u03c0 A \u2022 N = N) := by\n  have := smul_eq_smul_iff \u03c0 1 S\n  simp only [one_smul, Tree.one_apply] at this\n  exact this\n\nnoncomputable instance : Add (Support \u03b1) where\n  add S T := \u27e8S\u1d2c + T\u1d2c, S\u1d3a + T\u1d3a\u27e9\n\n@[simp]\ntheorem add_derivBot (S T : Support \u03b1) (A : \u03b1 \u219d \u22a5) :\n    (S + T) \u21d8. A = (S \u21d8. A) + (T \u21d8. A) :=\n  rfl\n\ntheorem smul_add (S T : Support \u03b1) (\u03c0 : StrPerm \u03b1) :\n    \u03c0 \u2022 (S + T) = \u03c0 \u2022 S + \u03c0 \u2022 T :=\n  rfl\n\ntheorem add_inj_of_bound_eq_bound {S T U V : Support \u03b1}\n    (ha : S\u1d2c.bound = T\u1d2c.bound) (hN : S\u1d3a.bound = T\u1d3a.bound)\n    (h' : S + U = T + V) : S = T \u2227 U = V := by\n  have ha' := Enumeration.add_inj_of_bound_eq_bound ha (congr_arg (\u00b7\u1d2c) h')\n  have hN' := Enumeration.add_inj_of_bound_eq_bound hN (congr_arg (\u00b7\u1d3a) h')\n  constructor\n  \u00b7 exact Support.ext' ha'.1 hN'.1\n  \u00b7 exact Support.ext' ha'.2 hN'.2\n\nend Support\n\ndef supportEquiv {\u03b1 : TypeIndex} : Support \u03b1 \u2243\n    Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom) \u00d7 Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter) where\n  toFun S := (S\u1d2c, S\u1d3a)\n  invFun S := \u27e8S.1, S.2\u27e9\n  left_inv _ := rfl\n  right_inv _ := rfl\n\ntheorem card_support {\u03b1 : TypeIndex} : #(Support \u03b1) = #\u03bc := by\n  rw [Cardinal.eq.mpr \u27e8supportEquiv\u27e9, mk_prod, lift_id, lift_id,\n    card_enumeration_eq, card_enumeration_eq, mul_eq_self aleph0_lt_\u03bc.le]\n  \u00b7 rw [mk_prod, lift_id, lift_id, card_nearLitter,\n      mul_eq_right aleph0_lt_\u03bc.le (card_path_lt' \u03b1 \u22a5).le (card_path_ne_zero \u03b1)]\n  \u00b7 rw [mk_prod, lift_id, lift_id, card_atom,\n      mul_eq_right aleph0_lt_\u03bc.le (card_path_lt' \u03b1 \u22a5).le (card_path_ne_zero \u03b1)]\n\n/-!\n## Orders on supports\n-/\n\n-- TODO: Is this order used?\ninstance : LE BaseSupport where\n  le S T := (\u2200 a \u2208 S\u1d2c, a \u2208 T\u1d2c) \u2227 (\u2200 N \u2208 S\u1d3a, N \u2208 T\u1d3a)\n\ninstance : Preorder BaseSupport where\n  le_refl S := \u27e8\u03bb _ \u21a6 id, \u03bb _ \u21a6 id\u27e9\n  le_trans S T U h\u2081 h\u2082 := \u27e8\u03bb a h \u21a6 h\u2082.1 _ (h\u2081.1 a h), \u03bb N h \u21a6 h\u2082.2 _ (h\u2081.2 N h)\u27e9\n\ntheorem BaseSupport.smul_le_smul {S T : BaseSupport} (h : S \u2264 T) (\u03c0 : BasePerm) :\n    \u03c0 \u2022 S \u2264 \u03c0 \u2022 T := by\n  constructor\n  \u00b7 intro a\n    exact h.1 (\u03c0\u207b\u00b9 \u2022 a)\n  \u00b7 intro N\n    exact h.2 (\u03c0\u207b\u00b9 \u2022 N)\n\ntheorem BaseSupport.le_add_right {S T : BaseSupport} :\n    S \u2264 S + T := by\n  constructor\n  \u00b7 intro a ha\n    simp only [Support.add_derivBot, BaseSupport.add_atoms, Enumeration.mem_add_iff]\n    exact Or.inl ha\n  \u00b7 intro N hN\n    simp only [Support.add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n    exact Or.inl hN\n\ntheorem BaseSupport.le_add_left {S T : BaseSupport} :\n    S \u2264 T + S := by\n  constructor\n  \u00b7 intro a ha\n    simp only [add_atoms, Enumeration.mem_add_iff]\n    exact Or.inr ha\n  \u00b7 intro N hN\n    simp only [add_nearLitters, Enumeration.mem_add_iff]\n    exact Or.inr hN\n\ndef BaseSupport.Subsupport (S T : BaseSupport) : Prop :=\n  S\u1d2c.rel \u2264 T\u1d2c.rel \u2227 S\u1d3a.rel \u2264 T\u1d3a.rel\n\ntheorem BaseSupport.Subsupport.le {S T : BaseSupport}\n    (h : S.Subsupport T) : S \u2264 T := by\n  constructor\n  \u00b7 rintro a \u27e8i, hi\u27e9\n    exact \u27e8i, h.1 i a hi\u27e9\n  \u00b7 rintro N \u27e8i, hi\u27e9\n    exact \u27e8i, h.2 i N hi\u27e9\n\ntheorem BaseSupport.Subsupport.trans {S T U : BaseSupport}\n    (h\u2081 : S.Subsupport T) (h\u2082 : T.Subsupport U) :\n    S.Subsupport U :=\n  \u27e8h\u2081.1.trans h\u2082.1, h\u2081.2.trans h\u2082.2\u27e9\n\ntheorem BaseSupport.smul_subsupport_smul {S T : BaseSupport} (h : S.Subsupport T) (\u03c0 : BasePerm) :\n    (\u03c0 \u2022 S).Subsupport (\u03c0 \u2022 T) := by\n  constructor\n  \u00b7 intro i a ha\n    exact h.1 i _ ha\n  \u00b7 intro i N hN\n    exact h.2 i _ hN\n\ninstance {\u03b1 : TypeIndex} : LE (Support \u03b1) where\n  le S T := \u2200 A, S \u21d8. A \u2264 T \u21d8. A\n\ninstance {\u03b1 : TypeIndex} : Preorder (Support \u03b1) where\n  le_refl S := \u03bb A \u21a6 le_rfl\n  le_trans S T U h\u2081 h\u2082 := \u03bb A \u21a6 (h\u2081 A).trans (h\u2082 A)\n\ntheorem Support.smul_le_smul {\u03b1 : TypeIndex} {S T : Support \u03b1} (h : S \u2264 T) (\u03c0 : StrPerm \u03b1) :\n    \u03c0 \u2022 S \u2264 \u03c0 \u2022 T :=\n  \u03bb A \u21a6 BaseSupport.smul_le_smul (h A) (\u03c0 A)\n\ntheorem Support.le_add_right {\u03b1 : TypeIndex} {S T : Support \u03b1} :\n    S \u2264 S + T := by\n  intro A\n  rw [add_derivBot]\n  exact BaseSupport.le_add_right\n\n", "theoremStatement": "theorem Support.le_add_left {\u03b1 : TypeIndex} {S T : Support \u03b1} :\n    S \u2264 T + S ", "theoremName": "ConNF.Support.le_add_left", "fileCreated": {"commit": "39c33b4a743bea62dbcc549548b712ffd38ca65c", "date": "2024-12-05"}, "theoremCreated": {"commit": "251ac752f844dfde539ac2bd3ff112305ad59139", "date": "2024-11-30"}, "file": "ConNF/ConNF/ModelData/Support.lean", "module": "ConNF.ModelData.Support", "jsonFile": "ConNF.ModelData.Support.jsonl", "positionMetadata": {"lineInFile": 538, "tokenPositionInFile": 15061, "theoremPositionInFile": 58}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 9, "repositoryPremises": true, "numRepositoryPremises": 14, "numPremises": 23}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  intro A\n  rw [add_derivBot]\n  exact BaseSupport.le_add_left", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 67}}
{"srcContext": "import ConNF.Model.Result\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal ConNF.TSet\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\ndef union (x y : TSet \u03b1) : TSet \u03b1 :=\n  (x\u1d9c' \u2293' y\u1d9c')\u1d9c'\n\nnotation:68 x:68 \" \u2294[\" h \"] \" y:68 => _root_.ConNF.union h x y\nnotation:68 x:68 \" \u2294' \" y:68 => x \u2294[by assumption] y\n\n@[simp]\ntheorem mem_union_iff (x y : TSet \u03b1) :\n    \u2200 z : TSet \u03b2, z \u2208' x \u2294' y \u2194 z \u2208' x \u2228 z \u2208' y := by\n  rw [union]\n  intro z\n  rw [mem_compl_iff, mem_inter_iff, mem_compl_iff, mem_compl_iff, or_iff_not_and_not]\n\ndef higherIndex (\u03b1 : \u039b) : \u039b :=\n  (exists_gt \u03b1).choose\n\ntheorem lt_higherIndex {\u03b1 : \u039b} :\n    (\u03b1 : TypeIndex) < higherIndex \u03b1 :=\n  WithBot.coe_lt_coe.mpr (exists_gt \u03b1).choose_spec\n\ntheorem tSet_nonempty (h : \u2203 \u03b2 : \u039b, (\u03b2 : TypeIndex) < \u03b1) : Nonempty (TSet \u03b1) := by\n  obtain \u27e8\u03b1', h\u03b1\u27e9 := h\n  constructor\n  apply typeLower lt_higherIndex lt_higherIndex lt_higherIndex h\u03b1\n  apply cardinalOne lt_higherIndex lt_higherIndex\n\ndef empty : TSet \u03b1 :=\n  (tSet_nonempty \u27e8\u03b2, h\u03b2\u27e9).some \u2293' (tSet_nonempty \u27e8\u03b2, h\u03b2\u27e9).some\u1d9c'\n\n@[simp]\ntheorem mem_empty_iff :\n    \u2200 x : TSet \u03b2, \u00acx \u2208' empty h\u03b2 := by\n  intro x\n  rw [empty, mem_inter_iff, mem_compl_iff]\n  exact and_not_self\n\ndef univ : TSet \u03b1 :=\n  (empty h\u03b2)\u1d9c'\n\n@[simp]\ntheorem mem_univ_iff :\n    \u2200 x : TSet \u03b2, x \u2208' univ h\u03b2 := by\n  intro x\n  simp only [univ, mem_compl_iff, mem_empty_iff, not_false_eq_true]\n\n/-- The set of all ordered pairs. -/\ndef orderedPairs : TSet \u03b1 :=\n  vCross h\u03b2 h\u03b3 h\u03b4 (univ h\u03b4)\n\n@[simp]\ntheorem mem_orderedPairs_iff (x : TSet \u03b2) :\n    x \u2208' orderedPairs h\u03b2 h\u03b3 h\u03b4 \u2194 \u2203 a b, x = \u27e8a, b\u27e9' := by\n  simp only [orderedPairs, vCross_spec, mem_univ_iff, and_true]\n\ndef converse (x : TSet \u03b1) : TSet \u03b1 :=\n  converse' h\u03b2 h\u03b3 h\u03b4 x \u2293' orderedPairs h\u03b2 h\u03b3 h\u03b4\n\n", "theoremStatement": "@[simp]\ntheorem op_mem_converse_iff (x : TSet \u03b1) :\n    \u2200 a b, \u27e8a, b\u27e9' \u2208' converse h\u03b2 h\u03b3 h\u03b4 x \u2194 \u27e8b, a\u27e9' \u2208' x ", "theoremName": "ConNF.op_mem_converse_iff", "fileCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "theoremCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "file": "ConNF/ConNF/External/Basic.lean", "module": "ConNF.External.Basic", "jsonFile": "ConNF.External.Basic.jsonl", "positionMetadata": {"lineInFile": 80, "tokenPositionInFile": 1953, "theoremPositionInFile": 14}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 18, "numPremises": 44}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  intro a b\n  simp only [converse, mem_inter_iff, converse'_spec, mem_orderedPairs_iff, op_inj, exists_and_left,\n    exists_eq', and_true]", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 144}}
{"srcContext": "import ConNF.Model.Externalise\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b2 \u03b3 : \u039b} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n\nnamespace Support\n\ntheorem not_mem_scoderiv_botDeriv (S : Support \u03b3) (N : NearLitter) :\n    N \u2209 (S \u2197 h\u03b3 \u21d8. (Path.nil \u2198.))\u1d3a := by\n  rintro \u27e8i, \u27e8A, N'\u27e9, h\u2081, h\u2082\u27e9\n  simp only [Prod.mk.injEq] at h\u2082\n  cases A\n  case sderiv \u03b4 A h\u03b4 _ =>\n    simp only [Path.deriv_sderiv] at h\u2082\n    cases A\n    case nil => cases h\u2082.1\n    case sderiv \u03b6 A h\u03b6 _ =>\n      simp only [Path.deriv_sderiv] at h\u2082\n      cases h\u2082.1\n\nvariable [Level] [LtLevel \u03b2]\n\ntheorem not_mem_strong_botDeriv (S : Support \u03b3) (N : NearLitter) :\n    N \u2209 ((S \u2197 h\u03b3).strong \u21d8. (Path.nil \u2198.))\u1d3a := by\n  rintro h\n  rw [strong, close_nearLitters, preStrong_nearLitters, Enumeration.mem_add_iff] at h\n  obtain h | h := h\n  \u00b7 exact not_mem_scoderiv_botDeriv S N h\n  \u00b7 rw [mem_constrainsNearLitters_nearLitters] at h\n    obtain \u27e8B, N', hN', h\u27e9 := h\n    cases h using Relation.ReflTransGen.head_induction_on\n    case refl => exact not_mem_scoderiv_botDeriv S N hN'\n    case head x hx\u2081 hx\u2082 _ =>\n      obtain \u27e8\u27e8\u03b3, \u03b4, \u03b5, h\u03b4, h\u03b5, h\u03b4\u03b5, A\u27e9, t, B, hB, hN, ht\u27e9 := hx\u2082\n      simp only at hB\n      cases B\n      case nil =>\n        cases hB\n        obtain \u27e8C, N''\u27e9 := x\n        simp only at ht\n        cases ht.1\n        change _ \u2208 t.support\u1d3a at hN\n        rw [t.support_supports.2 rfl] at hN\n        obtain \u27e8i, hN\u27e9 := hN\n        cases hN\n      case sderiv \u03b4 B h\u03b4 _ _ =>\n        cases B\n        case nil => cases hB\n        case sderiv \u03b6 B h\u03b6 _ _ => cases hB\n\ntheorem raise_preStrong' (S : Support \u03b1) (hS : S.Strong) (T : Support \u03b3) (\u03c1 : AllPerm \u03b2)\n    (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2) :\n    (S + (\u03c1\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim).PreStrong := by\n  apply hS.toPreStrong.add\n  constructor\n  intro A N hN P t hA ht\n  obtain \u27e8A, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv hN\n  simp only [scoderiv_botDeriv_eq, add_derivBot, smul_derivBot,\n    BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters, interferenceSupport_nearLitters,\n    Enumeration.mem_add_iff, Enumeration.mem_smul, Enumeration.not_mem_empty, or_false] at hN\n  obtain \u27e8\u03b4, \u03b5, \u03b6, h\u03b5, h\u03b6, h\u03b5\u03b6, B\u27e9 := P\n  dsimp only at *\n  cases A\n  case sderiv \u03b6' A h\u03b6' _ =>\n    rw [\u2190 Path.coderiv_deriv] at hA\n    cases Path.sderiv_index_injective hA\n    apply Path.sderiv_left_inj.mp at hA\n    cases A\n    case nil =>\n      cases hA\n      cases not_mem_strong_botDeriv T _ hN\n    case sderiv \u03b9 A h\u03b9 _ _ =>\n      rw [\u2190 Path.coderiv_deriv] at hA\n      cases Path.sderiv_index_injective hA\n      cases hA\n      haveI : LtLevel \u03b4 := \u27e8A.le.trans_lt LtLevel.elim\u27e9\n      haveI : LtLevel \u03b5 := \u27e8h\u03b5.trans LtLevel.elim\u27e9\n      haveI : LtLevel \u03b6 := \u27e8h\u03b6.trans LtLevel.elim\u27e9\n      have := (T \u2197 h\u03b3).strong_strong.support_le hN \u27e8\u03b4, \u03b5, \u03b6, h\u03b5, h\u03b6, h\u03b5\u03b6, A\u27e9\n          (\u03c1\u207b\u00b9 \u21d8 A \u2198 h\u03b5 \u2022 t) rfl ?_\n      \u00b7 simp only [Tangle.smul_support, allPermSderiv_forget, allPermDeriv_forget,\n          allPermForget_inv, Tree.inv_deriv, Tree.inv_sderiv] at this\n        have := smul_le_smul this (\u03c1\u1d41 \u21d8 A \u2198 h\u03b5)\n        simp only [smul_inv_smul] at this\n        apply le_trans this\n        intro B\n        constructor\n        \u00b7 intro a ha\n          simp only [smul_derivBot, Tree.sderiv_apply, Tree.deriv_apply, Path.deriv_scoderiv,\n            deriv_derivBot, Enumeration.mem_smul] at ha\n          rw [deriv_derivBot, \u2190 Path.deriv_scoderiv, Path.coderiv_deriv', scoderiv_botDeriv_eq,]\n          simp only [Path.deriv_scoderiv, add_derivBot, smul_derivBot,\n            BaseSupport.add_atoms, BaseSupport.smul_atoms, Enumeration.mem_add_iff,\n            Enumeration.mem_smul]\n          exact Or.inl ha\n        \u00b7 intro N hN\n          simp only [smul_derivBot, Tree.sderiv_apply, Tree.deriv_apply, Path.deriv_scoderiv,\n            deriv_derivBot, Enumeration.mem_smul] at hN\n          rw [deriv_derivBot, \u2190 Path.deriv_scoderiv, Path.coderiv_deriv', scoderiv_botDeriv_eq,]\n          simp only [Path.deriv_scoderiv, add_derivBot, smul_derivBot,\n            BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters, Enumeration.mem_add_iff,\n            Enumeration.mem_smul]\n          exact Or.inl hN\n      \u00b7 rw [\u2190 smul_fuzz h\u03b5 h\u03b6 h\u03b5\u03b6, \u2190 ht]\n        simp only [Path.botSderiv_coe_eq, BasePerm.smul_nearLitter_litter, allPermDeriv_forget,\n          allPermForget_inv, Tree.inv_deriv, Tree.inv_sderiv, Tree.inv_sderivBot]\n        rfl\n\ntheorem raise_closed' (S : Support \u03b1) (hS : S.Strong) (T : Support \u03b3) (\u03c1 : AllPerm \u03b2)\n    (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n    (h\u03c1 : \u03c1\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim) :\n    (S + (\u03c1\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim).Closed := by\n  constructor\n  intro A\n  constructor\n  intro N\u2081 N\u2082 hN\u2081 hN\u2082 a ha\n  simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff,\n    BaseSupport.add_atoms] at hN\u2081 hN\u2082 \u22a2\n  obtain hN\u2081 | hN\u2081 := hN\u2081\n  \u00b7 obtain hN\u2082 | hN\u2082 := hN\u2082\n    \u00b7 exact Or.inl ((hS.closed A).interference_subset hN\u2081 hN\u2082 a ha)\n    \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv hN\u2082\n      simp only [smul_add, scoderiv_botDeriv_eq, add_derivBot, smul_derivBot,\n        BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters, Enumeration.mem_add_iff,\n        Enumeration.mem_smul, BaseSupport.add_atoms, BaseSupport.smul_atoms] at hN\u2081 hN\u2082 \u22a2\n      refine Or.inr (Or.inr ?_)\n      rw [mem_interferenceSupport_atoms]\n      refine \u27e8(\u03c1\u1d41 B)\u207b\u00b9 \u2022 N\u2081, ?_, (\u03c1\u1d41 B)\u207b\u00b9 \u2022 N\u2082, ?_, ?_\u27e9\n      \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n        rw [\u2190 Enumeration.mem_smul, \u2190 BaseSupport.smul_nearLitters, \u2190 smul_derivBot, h\u03c1]\n        exact Or.inl hN\u2081\n      \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n        simp only [interferenceSupport_nearLitters, Enumeration.not_mem_empty, or_false] at hN\u2082\n        exact Or.inr hN\u2082\n      \u00b7 rw [\u2190 BasePerm.smul_interference]\n        exact Set.smul_mem_smul_set ha\n  \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv hN\u2081\n    simp only [smul_add, scoderiv_botDeriv_eq, add_derivBot, smul_derivBot,\n      BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters, Enumeration.mem_add_iff,\n      Enumeration.mem_smul, BaseSupport.add_atoms, BaseSupport.smul_atoms] at hN\u2081 hN\u2082 \u22a2\n    refine Or.inr (Or.inr ?_)\n    rw [mem_interferenceSupport_atoms]\n    refine \u27e8(\u03c1\u1d41 B)\u207b\u00b9 \u2022 N\u2081, ?_, (\u03c1\u1d41 B)\u207b\u00b9 \u2022 N\u2082, ?_, ?_\u27e9\n    \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n      simp only [interferenceSupport_nearLitters, Enumeration.not_mem_empty, or_false] at hN\u2081\n      exact Or.inr hN\u2081\n    \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n      simp only [interferenceSupport_nearLitters, Enumeration.not_mem_empty, or_false] at hN\u2082\n      obtain hN\u2082 | hN\u2082 := hN\u2082\n      \u00b7 rw [\u2190 Enumeration.mem_smul, \u2190 BaseSupport.smul_nearLitters, \u2190 smul_derivBot, h\u03c1]\n        exact Or.inl hN\u2082\n      \u00b7 exact Or.inr hN\u2082\n    \u00b7 rw [\u2190 BasePerm.smul_interference]\n      exact Set.smul_mem_smul_set ha\n\ntheorem raise_strong' (S : Support \u03b1) (hS : S.Strong) (T : Support \u03b3) (\u03c1 : AllPerm \u03b2)\n    (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n    (h\u03c1 : \u03c1\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim) :\n    (S + (\u03c1\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim).Strong :=\n  \u27e8raise_preStrong' S hS T \u03c1 h\u03b3, raise_closed' S hS T \u03c1 h\u03b3 h\u03c1\u27e9\n\ntheorem convAtoms_injective_of_fixes {S : Support \u03b1} {T : Support \u03b3}\n    {\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n    (h\u03c1\u2081 : \u03c1\u2081\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (h\u03c1\u2082 : \u03c1\u2082\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (A : \u2191\u03b1 \u219d \u22a5) :\n    (convAtoms\n      (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong + (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197\n        LtLevel.elim)\n      (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong + (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197\n        LtLevel.elim) A).Injective := by\n  rw [Support.smul_eq_iff] at h\u03c1\u2081 h\u03c1\u2082\n  constructor\n  rintro a\u2081 a\u2082 a\u2083 \u27e8i, hi\u2081, hi\u2082\u27e9 \u27e8j, hj\u2081, hj\u2082\u27e9\n  simp only [add_derivBot, BaseSupport.add_atoms, Rel.inv_apply,\n    Enumeration.rel_add_iff] at hi\u2081 hi\u2082 hj\u2081 hj\u2082\n  obtain hi\u2081 | \u27e8i, rfl, hi\u2081\u27e9 := hi\u2081\n  \u00b7 obtain hi\u2082 | \u27e8i', rfl, _\u27e9 := hi\u2082\n    swap\n    \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hi\u2081\u27e9\n      simp only [add_lt_iff_neg_left] at this\n      cases (\u03ba_zero_le i').not_lt this\n    cases (Enumeration.rel_coinjective _).coinjective hi\u2081 hi\u2082\n    obtain hj\u2081 | \u27e8j, rfl, hj\u2081\u27e9 := hj\u2081\n    \u00b7 obtain hj\u2082 | \u27e8j', rfl, _\u27e9 := hj\u2082\n      \u00b7 exact (Enumeration.rel_coinjective _).coinjective hj\u2082 hj\u2081\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2081\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j').not_lt this\n    \u00b7 obtain hj\u2082 | hj\u2082 := hj\u2082\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2082\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j).not_lt this\n      \u00b7 simp only [add_right_inj, exists_eq_left] at hj\u2082\n        obtain \u27e8B, rfl\u27e9 := eq_of_atom_mem_scoderiv_botDeriv \u27e8j, hj\u2081\u27e9\n        simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_atoms,\n          BaseSupport.add_atoms, Enumeration.smul_rel, add_right_inj, exists_eq_left] at hj\u2081 hj\u2082\n        have := (Enumeration.rel_coinjective _).coinjective hj\u2081 hj\u2082\n        rw [\u2190 (h\u03c1\u2082 B).1 a\u2081 \u27e8_, hi\u2081\u27e9, inv_smul_smul, inv_smul_eq_iff, (h\u03c1\u2081 B).1 a\u2081 \u27e8_, hi\u2081\u27e9] at this\n        exact this.symm\n  \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_atom_mem_scoderiv_botDeriv \u27e8i, hi\u2081\u27e9\n    simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_atoms,\n      BaseSupport.add_atoms, Enumeration.smul_rel, add_right_inj, exists_eq_left] at hi\u2081 hi\u2082 hj\u2081 hj\u2082\n    obtain hi\u2082 | hi\u2082 := hi\u2082\n    \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hi\u2082\u27e9\n      simp only [add_lt_iff_neg_left] at this\n      cases (\u03ba_zero_le i).not_lt this\n    have hi := (Enumeration.rel_coinjective _).coinjective hi\u2081 hi\u2082\n    suffices hj : (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 a\u2082 = (\u03c1\u2082\u1d41 B)\u207b\u00b9 \u2022 a\u2083 by\n      rwa [\u2190 hj, smul_left_cancel_iff] at hi\n    obtain hj\u2081 | \u27e8j, rfl, hj\u2081\u27e9 := hj\u2081\n    \u00b7 obtain hj\u2082 | \u27e8j', rfl, _\u27e9 := hj\u2082\n      \u00b7 rw [\u2190 (h\u03c1\u2081 B).1 a\u2082 \u27e8_, hj\u2081\u27e9, \u2190 (h\u03c1\u2082 B).1 a\u2083 \u27e8_, hj\u2082\u27e9, inv_smul_smul, inv_smul_smul]\n        exact (Enumeration.rel_coinjective _).coinjective hj\u2081 hj\u2082\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2081\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j').not_lt this\n    \u00b7 obtain hj\u2082 | hj\u2082 := hj\u2082\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2082\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j).not_lt this\n      \u00b7 simp only [add_right_inj, exists_eq_left] at hj\u2082\n        exact (Enumeration.rel_coinjective _).coinjective hj\u2081 hj\u2082\n\n", "theoremStatement": "theorem atomMemRel_le_of_fixes {S : Support \u03b1} {T : Support \u03b3}\n    {\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n    (h\u03c1\u2081 : \u03c1\u2081\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (h\u03c1\u2082 : \u03c1\u2082\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (A : \u2191\u03b1 \u219d \u22a5) :\n    atomMemRel (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A \u2264\n    atomMemRel (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A ", "theoremName": "ConNF.Support.atomMemRel_le_of_fixes", "fileCreated": {"commit": "abf71bc79c407ceb462cc2edd2d994cda9cdef05", "date": "2024-04-04"}, "theoremCreated": {"commit": "7965dba9f7fcbea5f6e2d5e3c622db5790f2f494", "date": "2024-11-30"}, "file": "ConNF/ConNF/Model/RaiseStrong.lean", "module": "ConNF.Model.RaiseStrong", "jsonFile": "ConNF.Model.RaiseStrong.jsonl", "positionMetadata": {"lineInFile": 244, "tokenPositionInFile": 10746, "theoremPositionInFile": 6}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 71, "numPremises": 146}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [Support.smul_eq_iff] at h\u03c1\u2081 h\u03c1\u2082\n  rintro i j \u27e8N, hN, a, haN, ha\u27e9\n  simp only [add_derivBot, BaseSupport.add_atoms, Rel.inv_apply, Enumeration.rel_add_iff,\n    BaseSupport.add_nearLitters] at ha hN\n  obtain hN | \u27e8i, rfl, hi\u27e9 := hN\n  \u00b7 obtain ha | \u27e8j, rfl, hj\u27e9 := ha\n    \u00b7 exact \u27e8N, Or.inl hN, a, haN, Or.inl ha\u27e9\n    \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_atom_mem_scoderiv_botDeriv \u27e8j, hj\u27e9\n      simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_atoms,\n        BaseSupport.add_atoms, Enumeration.smul_rel] at hj hN\n      refine \u27e8N, Or.inl hN, \u03c1\u2082\u1d41 B \u2022 (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 a, ?_, ?_\u27e9\n      \u00b7 dsimp only\n        rw [\u2190 (h\u03c1\u2082 B).2 N \u27e8_, hN\u27e9, BasePerm.smul_nearLitter_atoms, Set.smul_mem_smul_set_iff]\n        have := (h\u03c1\u2081 B).2 N \u27e8_, hN\u27e9\n        rw [smul_eq_iff_eq_inv_smul] at this\n        rwa [this, BasePerm.smul_nearLitter_atoms, Set.smul_mem_smul_set_iff]\n      \u00b7 rw [Rel.inv_apply, add_derivBot, BaseSupport.add_atoms, Enumeration.rel_add_iff]\n        simp only [add_right_inj, scoderiv_botDeriv_eq, smul_derivBot, add_derivBot,\n          BaseSupport.smul_atoms, BaseSupport.add_atoms, Enumeration.smul_rel, inv_smul_smul,\n          exists_eq_left]\n        exact Or.inr hj\n  \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv \u27e8i, hi\u27e9\n    simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_atoms,\n      BaseSupport.add_atoms, Enumeration.smul_rel] at hi ha\n    obtain ha | \u27e8j, rfl, hj\u27e9 := ha\n    \u00b7 refine \u27e8\u03c1\u2082\u1d41 B \u2022 (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 N, ?_, a, ?_, Or.inl ha\u27e9\n      \u00b7 rw [add_derivBot, BaseSupport.add_nearLitters, Enumeration.rel_add_iff]\n        simp only [add_right_inj, scoderiv_botDeriv_eq, smul_derivBot, add_derivBot,\n          BaseSupport.smul_nearLitters, BaseSupport.add_nearLitters, Enumeration.smul_rel,\n          inv_smul_smul, exists_eq_left]\n        exact Or.inr hi\n      \u00b7 dsimp only\n        rw [\u2190 (h\u03c1\u2082 B).1 a \u27e8_, ha\u27e9, BasePerm.smul_nearLitter_atoms, Set.smul_mem_smul_set_iff]\n        have := (h\u03c1\u2081 B).1 a \u27e8_, ha\u27e9\n        rw [smul_eq_iff_eq_inv_smul] at this\n        rwa [this, BasePerm.smul_nearLitter_atoms, Set.smul_mem_smul_set_iff]\n    \u00b7 refine \u27e8\u03c1\u2082\u1d41 B \u2022 (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 N, ?_, \u03c1\u2082\u1d41 B \u2022 (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 a, ?_, ?_\u27e9\n      \u00b7 rw [add_derivBot, BaseSupport.add_nearLitters, Enumeration.rel_add_iff]\n        simp only [add_right_inj, scoderiv_botDeriv_eq, smul_derivBot, add_derivBot,\n          BaseSupport.smul_nearLitters, BaseSupport.add_nearLitters, Enumeration.smul_rel,\n          inv_smul_smul, exists_eq_left]\n        exact Or.inr hi\n      \u00b7 simp only [BasePerm.smul_nearLitter_atoms, Set.smul_mem_smul_set_iff]\n        exact haN\n      \u00b7 rw [Rel.inv_apply, add_derivBot, BaseSupport.add_atoms, Enumeration.rel_add_iff]\n        simp only [add_right_inj, scoderiv_botDeriv_eq, smul_derivBot, add_derivBot,\n          BaseSupport.smul_atoms, BaseSupport.add_atoms, Enumeration.smul_rel, inv_smul_smul,\n          exists_eq_left]\n        exact Or.inr hj", "proofType": "tactic", "proofLengthLines": 49, "proofLengthTokens": 2905}}
{"srcContext": "import ConNF.Model.Result\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal ConNF.TSet\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\ndef union (x y : TSet \u03b1) : TSet \u03b1 :=\n  (x\u1d9c' \u2293' y\u1d9c')\u1d9c'\n\nnotation:68 x:68 \" \u2294[\" h \"] \" y:68 => _root_.ConNF.union h x y\nnotation:68 x:68 \" \u2294' \" y:68 => x \u2294[by assumption] y\n\n@[simp]\ntheorem mem_union_iff (x y : TSet \u03b1) :\n    \u2200 z : TSet \u03b2, z \u2208' x \u2294' y \u2194 z \u2208' x \u2228 z \u2208' y := by\n  rw [union]\n  intro z\n  rw [mem_compl_iff, mem_inter_iff, mem_compl_iff, mem_compl_iff, or_iff_not_and_not]\n\ndef higherIndex (\u03b1 : \u039b) : \u039b :=\n  (exists_gt \u03b1).choose\n\ntheorem lt_higherIndex {\u03b1 : \u039b} :\n    (\u03b1 : TypeIndex) < higherIndex \u03b1 :=\n  WithBot.coe_lt_coe.mpr (exists_gt \u03b1).choose_spec\n\ntheorem tSet_nonempty (h : \u2203 \u03b2 : \u039b, (\u03b2 : TypeIndex) < \u03b1) : Nonempty (TSet \u03b1) := by\n  obtain \u27e8\u03b1', h\u03b1\u27e9 := h\n  constructor\n  apply typeLower lt_higherIndex lt_higherIndex lt_higherIndex h\u03b1\n  apply cardinalOne lt_higherIndex lt_higherIndex\n\ndef empty : TSet \u03b1 :=\n  (tSet_nonempty \u27e8\u03b2, h\u03b2\u27e9).some \u2293' (tSet_nonempty \u27e8\u03b2, h\u03b2\u27e9).some\u1d9c'\n\n@[simp]\ntheorem mem_empty_iff :\n    \u2200 x : TSet \u03b2, \u00acx \u2208' empty h\u03b2 := by\n  intro x\n  rw [empty, mem_inter_iff, mem_compl_iff]\n  exact and_not_self\n\ndef univ : TSet \u03b1 :=\n  (empty h\u03b2)\u1d9c'\n\n@[simp]\ntheorem mem_univ_iff :\n    \u2200 x : TSet \u03b2, x \u2208' univ h\u03b2 := by\n  intro x\n  simp only [univ, mem_compl_iff, mem_empty_iff, not_false_eq_true]\n\n/-- The set of all ordered pairs. -/\ndef orderedPairs : TSet \u03b1 :=\n  vCross h\u03b2 h\u03b3 h\u03b4 (univ h\u03b4)\n\n@[simp]\ntheorem mem_orderedPairs_iff (x : TSet \u03b2) :\n    x \u2208' orderedPairs h\u03b2 h\u03b3 h\u03b4 \u2194 \u2203 a b, x = \u27e8a, b\u27e9' := by\n  simp only [orderedPairs, vCross_spec, mem_univ_iff, and_true]\n\ndef converse (x : TSet \u03b1) : TSet \u03b1 :=\n  converse' h\u03b2 h\u03b3 h\u03b4 x \u2293' orderedPairs h\u03b2 h\u03b3 h\u03b4\n\n@[simp]\ntheorem op_mem_converse_iff (x : TSet \u03b1) :\n    \u2200 a b, \u27e8a, b\u27e9' \u2208' converse h\u03b2 h\u03b3 h\u03b4 x \u2194 \u27e8b, a\u27e9' \u2208' x := by\n  intro a b\n  simp only [converse, mem_inter_iff, converse'_spec, mem_orderedPairs_iff, op_inj, exists_and_left,\n    exists_eq', and_true]\n\ndef cross (x y : TSet \u03b3) : TSet \u03b1 :=\n  converse h\u03b2 h\u03b3 h\u03b4 (vCross h\u03b2 h\u03b3 h\u03b4 x) \u2293' vCross h\u03b2 h\u03b3 h\u03b4 y\n\n@[simp]\ntheorem mem_cross_iff (x y : TSet \u03b3) :\n    \u2200 a, a \u2208' cross h\u03b2 h\u03b3 h\u03b4 x y \u2194 \u2203 b c, a = \u27e8b, c\u27e9' \u2227 b \u2208' x \u2227 c \u2208' y := by\n  intro a\n  rw [cross, mem_inter_iff, vCross_spec]\n  constructor\n  \u00b7 rintro \u27e8h\u2081, b, c, rfl, h\u2082\u27e9\n    simp only [op_mem_converse_iff, vCross_spec, op_inj] at h\u2081\n    obtain \u27e8b', c', \u27e8rfl, rfl\u27e9, h\u2081\u27e9 := h\u2081\n    exact \u27e8b, c, rfl, h\u2081, h\u2082\u27e9\n  \u00b7 rintro \u27e8b, c, rfl, h\u2081, h\u2082\u27e9\n    simp only [op_mem_converse_iff, vCross_spec, op_inj]\n    exact \u27e8\u27e8c, b, \u27e8rfl, rfl\u27e9, h\u2081\u27e9, \u27e8b, c, \u27e8rfl, rfl\u27e9, h\u2082\u27e9\u27e9\n\ndef singletonImage (x : TSet \u03b2) : TSet \u03b1 :=\n  singletonImage' h\u03b2 h\u03b3 h\u03b4 h\u03b5 x \u2293' (cross h\u03b2 h\u03b3 h\u03b4 (cardinalOne h\u03b4 h\u03b5) (cardinalOne h\u03b4 h\u03b5))\n\n@[simp]\ntheorem singletonImage_spec (x : TSet \u03b2) :\n    \u2200 z w,\n    \u27e8 {z}', {w}' \u27e9' \u2208' singletonImage h\u03b2 h\u03b3 h\u03b4 h\u03b5 x \u2194 \u27e8z, w\u27e9' \u2208' x := by\n  intro z w\n  rw [singletonImage, mem_inter_iff, singletonImage'_spec, and_iff_left_iff_imp]\n  intro hzw\n  rw [mem_cross_iff]\n  refine \u27e8{z}', {w}', rfl, ?_\u27e9\n  simp only [mem_cardinalOne_iff, singleton_inj, exists_eq', and_self]\n\ntheorem exists_of_mem_singletonImage {x : TSet \u03b2} {z w : TSet \u03b4}\n    (h : \u27e8z, w\u27e9' \u2208' singletonImage h\u03b2 h\u03b3 h\u03b4 h\u03b5 x) :\n    \u2203 a b, z = {a}' \u2227 w = {b}' := by\n  simp only [singletonImage, mem_inter_iff, mem_cross_iff, op_inj, mem_cardinalOne_iff] at h\n  obtain \u27e8-, _, _, \u27e8rfl, rfl\u27e9, \u27e8a, rfl\u27e9, \u27e8b, rfl\u27e9\u27e9 := h\n  exact \u27e8a, b, rfl, rfl\u27e9\n\n/-- Turn a model element encoding a relation into an actual relation. -/\ndef ExternalRel (r : TSet \u03b1) : Rel (TSet \u03b4) (TSet \u03b4) :=\n  \u03bb x y \u21a6 \u27e8x, y\u27e9' \u2208' r\n\n@[simp]\ntheorem externalRel_converse (r : TSet \u03b1) :\n    ExternalRel h\u03b2 h\u03b3 h\u03b4 (converse h\u03b2 h\u03b3 h\u03b4 r) = (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).inv := by\n  ext\n  simp only [ExternalRel, op_mem_converse_iff, Rel.inv_apply]\n\n/-- The codomain of a relation. -/\ndef codom (r : TSet \u03b1) : TSet \u03b3 :=\n  (typeLower lt_higherIndex h\u03b2 h\u03b3 h\u03b4 (singletonImage lt_higherIndex h\u03b2 h\u03b3 h\u03b4 r)\u1d9c[lt_higherIndex])\u1d9c'\n\n@[simp]\ntheorem mem_codom_iff (r : TSet \u03b1) (x : TSet \u03b4) :\n    x \u2208' codom h\u03b2 h\u03b3 h\u03b4 r \u2194 x \u2208 (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).codom := by\n  simp only [codom, mem_compl_iff, mem_typeLower_iff, not_forall, not_not]\n  constructor\n  \u00b7 rintro \u27e8y, hy\u27e9\n    obtain \u27e8a, b, rfl, hb\u27e9 := exists_of_mem_singletonImage lt_higherIndex h\u03b2 h\u03b3 h\u03b4 hy\n    rw [singleton_inj] at hb\n    subst hb\n    rw [singletonImage_spec] at hy\n    exact \u27e8a, hy\u27e9\n  \u00b7 rintro \u27e8a, ha\u27e9\n    use {a}'\n    rw [singletonImage_spec]\n    exact ha\n\n/-- The domain of a relation. -/\ndef dom (r : TSet \u03b1) : TSet \u03b3 :=\n  codom h\u03b2 h\u03b3 h\u03b4 (converse h\u03b2 h\u03b3 h\u03b4 r)\n\n@[simp]\ntheorem mem_dom_iff (r : TSet \u03b1) (x : TSet \u03b4) :\n    x \u2208' dom h\u03b2 h\u03b3 h\u03b4 r \u2194 x \u2208 (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).dom := by\n  rw [dom, mem_codom_iff, externalRel_converse, Rel.inv_codom]\n\n/-- The field of a relation. -/\ndef field (r : TSet \u03b1) : TSet \u03b3 :=\n  dom h\u03b2 h\u03b3 h\u03b4 r \u2294' codom h\u03b2 h\u03b3 h\u03b4 r\n\n@[simp]\ntheorem mem_field_iff (r : TSet \u03b1) (x : TSet \u03b4) :\n    x \u2208' field h\u03b2 h\u03b3 h\u03b4 r \u2194 x \u2208 (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).field := by\n  rw [field, mem_union_iff, mem_dom_iff, mem_codom_iff, Rel.field, Set.mem_union]\n\ndef subset : TSet \u03b1 :=\n  subset' h\u03b2 h\u03b3 h\u03b4 h\u03b5 \u2293' orderedPairs h\u03b2 h\u03b3 h\u03b4\n\n@[simp]\ntheorem subset_spec :\n    \u2200 a b, \u27e8a, b\u27e9' \u2208' subset h\u03b2 h\u03b3 h\u03b4 h\u03b5 \u2194 a \u2286[TSet \u03b5] b := by\n  intro a b\n  simp only [subset, mem_inter_iff, subset'_spec, mem_orderedPairs_iff, op_inj, exists_and_left,\n    exists_eq', and_true]\n\ndef membership : TSet \u03b1 :=\n  subset h\u03b2 h\u03b3 h\u03b4 h\u03b5 \u2293' cross h\u03b2 h\u03b3 h\u03b4 (cardinalOne h\u03b4 h\u03b5) (univ h\u03b4)\n\n@[simp]\ntheorem membership_spec :\n    \u2200 a b, \u27e8{a}', b\u27e9' \u2208' membership h\u03b2 h\u03b3 h\u03b4 h\u03b5 \u2194 a \u2208' b := by\n  intro a b\n  rw [membership, mem_inter_iff, subset_spec]\n  simp only [mem_cross_iff, op_inj, mem_cardinalOne_iff, mem_univ_iff, and_true, exists_and_right,\n    exists_and_left, exists_eq', exists_eq_left', singleton_inj]\n  constructor\n  \u00b7 intro h\n    exact h a ((typedMem_singleton_iff' h\u03b5 a a).mpr rfl)\n  \u00b7 intro h c hc\n    simp only [typedMem_singleton_iff'] at hc\n    cases hc\n    exact h\n\ndef powerset (x : TSet \u03b2) : TSet \u03b1 :=\n  dom lt_higherIndex lt_higherIndex h\u03b2\n    (subset lt_higherIndex lt_higherIndex h\u03b2 h\u03b3 \u2293[lt_higherIndex]\n      vCross lt_higherIndex lt_higherIndex h\u03b2 {x}')\n\n@[simp]\ntheorem mem_powerset_iff (x y : TSet \u03b2) :\n    x \u2208' powerset h\u03b2 h\u03b3 y \u2194 x \u2286[TSet \u03b3] y := by\n  rw [powerset, mem_dom_iff]\n  constructor\n  \u00b7 rintro \u27e8z, h\u27e9\n    simp only [ExternalRel, mem_inter_iff, subset_spec, vCross_spec, op_inj,\n      typedMem_singleton_iff', exists_eq_right, exists_and_right, exists_eq', true_and] at h\n    cases h.2\n    exact h.1\n  \u00b7 intro h\n    refine \u27e8y, ?_\u27e9\n    simp only [ExternalRel, mem_inter_iff, subset_spec, h, vCross_spec, op_inj,\n      typedMem_singleton_iff', exists_eq_right, and_true, exists_eq', and_self]\n\n/-- The set `\u03b9\u00b2''x = {{{a}} | a \u2208 x}`. -/\ndef doubleSingleton (x : TSet \u03b3) : TSet \u03b1 :=\n  cross h\u03b2 h\u03b3 h\u03b4 x x \u2293' cardinalOne h\u03b2 h\u03b3\n\n", "theoremStatement": "@[simp]\ntheorem mem_doubleSingleton_iff (x : TSet \u03b3) :\n    \u2200 y : TSet \u03b2, y \u2208' doubleSingleton h\u03b2 h\u03b3 h\u03b4 x \u2194\n    \u2203 z : TSet \u03b4, z \u2208' x \u2227 y = { {z}' }' ", "theoremName": "ConNF.mem_doubleSingleton_iff", "fileCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "theoremCreated": {"commit": "6dd8406a01cc28b071bb26965294469664a1b592", "date": "2025-01-07"}, "file": "ConNF/ConNF/External/Basic.lean", "module": "ConNF.External.Basic", "jsonFile": "ConNF.External.Basic.jsonl", "positionMetadata": {"lineInFile": 225, "tokenPositionInFile": 7029, "theoremPositionInFile": 35}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 19, "numPremises": 49}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  intro y\n  rw [doubleSingleton, mem_inter_iff, mem_cross_iff, mem_cardinalOne_iff]\n  constructor\n  \u00b7 rintro \u27e8\u27e8b, c, h\u2081, h\u2082, h\u2083\u27e9, \u27e8a, rfl\u27e9\u27e9\n    obtain \u27e8hbc, rfl\u27e9 := (op_eq_singleton_iff _ _ _ _ _).mp h\u2081.symm\n    exact \u27e8c, h\u2083, rfl\u27e9\n  \u00b7 rintro \u27e8z, h, rfl\u27e9\n    constructor\n    \u00b7 refine \u27e8z, z, ?_\u27e9\n      rw [eq_comm, op_eq_singleton_iff]\n      tauto\n    \u00b7 exact \u27e8_, rfl\u27e9", "proofType": "tactic", "proofLengthLines": 12, "proofLengthTokens": 372}}
{"srcContext": "import ConNF.Model.RunInduction\n\n/-!\n# Externalisation\n\nIn this file, we convert many of our *internal* results (i.e. inside the induction) to *external*\nones (i.e. defined using the global `TSet`/`AllPerm` definitions).\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal WithBot\n\nnamespace ConNF\n\nvariable [Params.{u}]\n\ninstance globalModelData : {\u03b1 : TypeIndex} \u2192 ModelData \u03b1\n  | (\u03b1 : \u039b) => (motive \u03b1).data\n  | \u22a5 => botModelData\n\ninstance globalPosition : {\u03b1 : TypeIndex} \u2192 Position (Tangle \u03b1)\n  | (\u03b1 : \u039b) => (motive \u03b1).pos\n  | \u22a5 => botPosition\n\ninstance globalTypedNearLitters {\u03b1 : \u039b} : TypedNearLitters \u03b1 :=\n  (motive \u03b1).typed\n\ninstance globalLtData [Level] : LtData where\n\ninstance globalLeData [Level] : LeData where\n\nomit [Params] in\ntheorem heq_funext {\u03b1 : Sort _} {\u03b2 \u03b3 : \u03b1 \u2192 Sort _} {f : (x : \u03b1) \u2192 \u03b2 x} {g : (x : \u03b1) \u2192 \u03b3 x}\n    (h : \u2200 x, HEq (f x) (g x)) : HEq f g := by\n  cases funext \u03bb x \u21a6 type_eq_of_heq (h x)\n  simp only [heq_eq_eq] at h \u22a2\n  exact funext h\n\ntheorem globalLtData_eq [Level] :\n    globalLtData = ltData (\u03bb \u03b2 _ \u21a6 motive \u03b2) := by\n  apply LtData.ext\n  \u00b7 ext \u03b2 h\u03b2\n    induction \u03b2 using recBotCoe\n    case bot => rfl\n    case coe \u03b2 => rfl\n  \u00b7 apply heq_funext\n    intro \u03b2\n    induction \u03b2 using recBotCoe\n    case bot => rfl\n    case coe \u03b2 => rfl\n  \u00b7 rfl\n\ntheorem globalLeData_eq [Level] :\n    globalLeData = leData (\u03bb \u03b2 _ \u21a6 motive \u03b2) := by\n  apply LeData.ext\n  \u00b7 ext \u03b2 h\u03b2\n    induction \u03b2 using recBotCoe\n    case bot => rfl\n    case coe \u03b2 =>\n      by_cases h : (\u03b2 : TypeIndex) = \u03b1\n      \u00b7 cases coe_injective h\n        rw [leData_data_eq]\n        unfold globalLeData globalModelData\n        dsimp only\n        rw [motive_eq]\n        rfl\n      \u00b7 rw [leData_data_lt _ (h\u03b2.elim.lt_of_ne h)]\n        rfl\n  \u00b7 apply heq_funext\n    intro \u03b2\n    apply heq_funext\n    intro h\u03b2\n    induction \u03b2 using recBotCoe\n    case bot => rfl\n    case coe \u03b2 =>\n      rw [leData]\n      simp only [coe_inj, id_eq, eq_mpr_eq_cast, recBotCoe_bot, recBotCoe_coe, LtLevel.elim.ne]\n      exact HEq.symm (cast_heq _ _)\n\ninstance globalPreCoherentData [Level] : PreCoherentData where\n  allPermSderiv h := cast (by rw [globalLeData_eq])\n    ((preCoherentData (\u03bb \u03b2 _ \u21a6 motive \u03b2) (\u03bb \u03b2 _ \u21a6 hypothesis \u03b2)).allPermSderiv h)\n  singleton h := cast (by rw [globalLeData_eq])\n    ((preCoherentData (\u03bb \u03b2 _ \u21a6 motive \u03b2) (\u03bb \u03b2 _ \u21a6 hypothesis \u03b2)).singleton h)\n\nomit [Params] in\n", "theoremStatement": "@[simp]\ntheorem heq_cast_eq_iff {\u03b1 \u03b2 \u03b3 : Type _} {x : \u03b1} {y : \u03b2} {h : \u03b1 = \u03b3} :\n    HEq (cast h x) y \u2194 HEq x y ", "theoremName": "ConNF.heq_cast_eq_iff", "fileCreated": {"commit": "6fdc87c6b30b73931407a372f1430ecf0fef7601", "date": "2024-12-03"}, "theoremCreated": {"commit": "e409f3d0cd939e7218c3f39dcf3493c4b6e0b821", "date": "2024-11-29"}, "file": "ConNF/ConNF/Model/Externalise.lean", "module": "ConNF.Model.Externalise", "jsonFile": "ConNF.Model.Externalise.jsonl", "positionMetadata": {"lineInFile": 93, "tokenPositionInFile": 2413, "theoremPositionInFile": 3}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 15}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  cases h\n  rw [cast_eq]", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 30}}
{"srcContext": "import ConNF.ModelData.Enumeration\nimport ConNF.Levels.StrPerm\n\n/-!\n# Enumerations over paths\n\nIn this file, we provide extra features to `Enumeration`s that take values of the form `\u03b1 \u219d \u22a5 \u00d7 X`.\n\n## Main declarations\n\n* `ConNF.Enumeration.ext_path`: An extensionality principle for such `Enumeration`s.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nnamespace ConNF\n\nvariable [Params.{u}]\n\nnamespace Enumeration\n\n/-- A helper function for making relations with domain and codomain of the form `\u03b1 \u219d \u22a5 \u00d7 X`\nby defining it on each branch. -/\ndef relWithPath {X Y : Type u} {\u03b1 : TypeIndex} (f : \u03b1 \u219d \u22a5 \u2192 Rel X Y) :\n    Rel (\u03b1 \u219d \u22a5 \u00d7 X) (\u03b1 \u219d \u22a5 \u00d7 Y) :=\n  \u03bb x y \u21a6 x.1 = y.1 \u2227 f x.1 x.2 y.2\n\ntheorem relWithPath_coinjective {X Y : Type u} {\u03b1 : TypeIndex} {f : \u03b1 \u219d \u22a5 \u2192 Rel X Y}\n    (hf : \u2200 A, (f A).Coinjective) :\n    (relWithPath f).Coinjective := by\n  constructor\n  rintro \u27e8_, y\u2081\u27e9 \u27e8_, y\u2082\u27e9 \u27e8A, x\u27e9 \u27e8rfl, h\u2081\u27e9 \u27e8rfl, h\u2082\u27e9\n  cases (hf A).coinjective h\u2081 h\u2082\n  rfl\n\ninstance (X : Type u) (\u03b1 \u03b2 : TypeIndex) :\n    Derivative (Enumeration (\u03b1 \u219d \u22a5 \u00d7 X)) (Enumeration (\u03b2 \u219d \u22a5 \u00d7 X)) \u03b1 \u03b2 where\n  deriv E A := E.invImage (\u03bb x \u21a6 (x.1 \u21d7 A, x.2))\n    (\u03bb x y h \u21a6 Prod.ext (Path.deriv_right_injective\n      ((Prod.mk.injEq _ _ _ _).mp h).1) ((Prod.mk.injEq _ _ _ _).mp h).2)\n\ntheorem deriv_rel {X : Type _} {\u03b1 \u03b2 : TypeIndex} (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 X)) (A : \u03b1 \u219d \u03b2)\n    (i : \u03ba) (x : \u03b2 \u219d \u22a5 \u00d7 X) :\n    (E \u21d8 A).rel i x \u2194 E.rel i (x.1 \u21d7 A, x.2) :=\n  Iff.rfl\n\ninstance (X : Type u) (\u03b1 \u03b2 : TypeIndex) :\n    Coderivative (Enumeration (\u03b2 \u219d \u22a5 \u00d7 X)) (Enumeration (\u03b1 \u219d \u22a5 \u00d7 X)) \u03b1 \u03b2 where\n  coderiv E A := E.image (\u03bb x \u21a6 (x.1 \u21d7 A, x.2))\n\ntheorem coderiv_rel {X : Type _} {\u03b1 \u03b2 : TypeIndex} (E : Enumeration (\u03b2 \u219d \u22a5 \u00d7 X)) (A : \u03b1 \u219d \u03b2)\n    (i : \u03ba) (x : \u03b1 \u219d \u22a5 \u00d7 X) :\n    (E \u21d7 A).rel i x \u2194 \u2203 B, x.1 = A \u21d8 B \u2227 E.rel i (B, x.2) := by\n  constructor\n  \u00b7 rintro \u27e8x, h, rfl\u27e9\n    exact \u27e8_, rfl, h\u27e9\n  \u00b7 rintro \u27e8B, h\u2081, h\u2082\u27e9\n    refine \u27e8(B, x.2), h\u2082, ?_\u27e9\n    apply Prod.ext\n    \u00b7 dsimp only\n      exact h\u2081.symm\n    \u00b7 rfl\n\ntheorem scoderiv_rel {X : Type _} {\u03b1 \u03b2 : TypeIndex} (E : Enumeration (\u03b2 \u219d \u22a5 \u00d7 X)) (h : \u03b2 < \u03b1)\n    (i : \u03ba) (x : \u03b1 \u219d \u22a5 \u00d7 X) :\n    (E \u2197 h).rel i x \u2194 \u2203 B, x.1 = B \u2197 h \u2227 E.rel i (B, x.2) :=\n  coderiv_rel E (.single h) i x\n\ntheorem eq_of_scoderiv_mem {X : Type _} {\u03b1 \u03b2 \u03b3 : TypeIndex} (E : Enumeration (\u03b2 \u219d \u22a5 \u00d7 X))\n    (h : \u03b2 < \u03b1) (h' : \u03b3 < \u03b1)\n    (i : \u03ba) (A : \u03b3 \u219d \u22a5) (x : X) (h : (E \u2197 h).rel i \u27e8A \u2197 h', x\u27e9) :\n    \u03b2 = \u03b3 := by\n  rw [scoderiv_rel] at h\n  obtain \u27e8B, h\u2081, h\u2082\u27e9 := h\n  exact Path.scoderiv_index_injective h\u2081.symm\n\ninstance (X : Type u) (\u03b1 : TypeIndex) :\n    BotDerivative (Enumeration (\u03b1 \u219d \u22a5 \u00d7 X)) (Enumeration X) \u03b1 where\n  botDeriv E A := E.invImage (\u03bb x \u21a6 (A, x)) (Prod.mk.inj_left A)\n  botSderiv E := E.invImage (\u03bb x \u21a6 (Path.nil \u2198., x)) (Prod.mk.inj_left (Path.nil \u2198.))\n  botDeriv_single E h := by\n    cases \u03b1 using WithBot.recBotCoe with\n    | bot => cases lt_irrefl \u22a5 h\n    | coe => rfl\n\ntheorem derivBot_rel {X : Type _} {\u03b1 : TypeIndex} (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 X)) (A : \u03b1 \u219d \u22a5)\n    (i : \u03ba) (x : X) :\n    (E \u21d8. A).rel i x \u2194 E.rel i (A, x) :=\n  Iff.rfl\n\n@[simp]\ntheorem mem_path_iff {X : Type _} {\u03b1 : TypeIndex} (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 X))\n    (A : \u03b1 \u219d \u22a5) (x : X) :\n    (A, x) \u2208 E \u2194 x \u2208 E \u21d8. A :=\n  Iff.rfl\n\ntheorem ext_path {X : Type u} {\u03b1 : TypeIndex} {E F : Enumeration (\u03b1 \u219d \u22a5 \u00d7 X)}\n    (h : \u2200 A, E \u21d8. A = F \u21d8. A) :\n    E = F := by\n  ext i x\n  \u00b7 have := congr_arg bound (h (Path.nil \u2198.))\n    exact this\n  \u00b7 have := congr_arg rel (h x.1)\n    exact iff_of_eq (congr_fun\u2082 this i x.2)\n\ntheorem deriv_derivBot {X : Type _} {\u03b1 \u03b2 : TypeIndex} (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 X))\n    (A : \u03b1 \u219d \u03b2) (B : \u03b2 \u219d \u22a5) :\n    E \u21d8 A \u21d8. B = E \u21d8. (A \u21d8 B) :=\n  rfl\n\n@[simp]\ntheorem coderiv_deriv_eq {X : Type _} {\u03b1 \u03b2 : TypeIndex} (E : Enumeration (\u03b2 \u219d \u22a5 \u00d7 X)) (A : \u03b1 \u219d \u03b2) :\n    E \u21d7 A \u21d8 A = E := by\n  apply ext_path\n  intro B\n  ext i x\n  \u00b7 rfl\n  \u00b7 simp only [derivBot_rel, deriv_rel, coderiv_rel,\n      Path.coderiv_eq_deriv, Path.deriv_right_inj, exists_eq_left']\n\ntheorem eq_of_mem_scoderiv_botDeriv {X : Type _} {\u03b1 \u03b2 : TypeIndex} {S : Enumeration (\u03b2 \u219d \u22a5 \u00d7 X)}\n    {A : \u03b1 \u219d \u22a5} {h : \u03b2 < \u03b1} {x : X} (hx : x \u2208 S \u2197 h \u21d8. A) :\n    \u2203 B : \u03b2 \u219d \u22a5, A = B \u2197 h := by\n  obtain \u27e8i, \u27e8B, y\u27e9, hi\u2081, hi\u2082\u27e9 := hx\n  cases hi\u2082\n  exact \u27e8B, rfl\u27e9\n\n@[simp]\ntheorem scoderiv_botDeriv_eq {X : Type _} {\u03b1 \u03b2 : TypeIndex} (S : Enumeration (\u03b2 \u219d \u22a5 \u00d7 X))\n    (A : \u03b2 \u219d \u22a5) (h : \u03b2 < \u03b1) :\n    S \u2197 h \u21d8. (A \u2197 h) = S \u21d8. A := by\n  ext i x\n  \u00b7 rfl\n  \u00b7 simp only [derivBot_rel, scoderiv_rel, Path.scoderiv_left_inj, exists_eq_left']\n\ntheorem mulAction_aux {X : Type _} {\u03b1 : TypeIndex} [MulAction BasePerm X] (\u03c0 : StrPerm \u03b1) :\n    Function.Injective (\u03bb x : \u03b1 \u219d \u22a5 \u00d7 X \u21a6 (x.1, (\u03c0 x.1)\u207b\u00b9 \u2022 x.2)) := by\n  rintro \u27e8A\u2081, x\u2081\u27e9 \u27e8A\u2082, x\u2082\u27e9 h\n  rw [Prod.mk.injEq] at h\n  cases h.1\n  exact Prod.ext h.1 (smul_left_cancel _ h.2)\n\ninstance {X : Type _} {\u03b1 : TypeIndex} [MulAction BasePerm X] :\n    SMul (StrPerm \u03b1) (Enumeration (\u03b1 \u219d \u22a5 \u00d7 X)) where\n  smul \u03c0 E := E.invImage (\u03bb x \u21a6 (x.1, (\u03c0 x.1)\u207b\u00b9 \u2022 x.2)) (mulAction_aux \u03c0)\n\n", "theoremStatement": "@[simp]\ntheorem smulPath_rel {X : Type _} {\u03b1 : TypeIndex} [MulAction BasePerm X]\n    (\u03c0 : StrPerm \u03b1) (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 X)) (i : \u03ba) (x : \u03b1 \u219d \u22a5 \u00d7 X) :\n    (\u03c0 \u2022 E).rel i x \u2194 E.rel i (x.1, (\u03c0 x.1)\u207b\u00b9 \u2022 x.2) ", "theoremName": "ConNF.Enumeration.smulPath_rel", "fileCreated": {"commit": "39c33b4a743bea62dbcc549548b712ffd38ca65c", "date": "2024-12-05"}, "theoremCreated": {"commit": "6709914ae7f5cd3e2bb24b413e09aa844554d234", "date": "2024-11-30"}, "file": "ConNF/ConNF/ModelData/PathEnumeration.lean", "module": "ConNF.ModelData.PathEnumeration", "jsonFile": "ConNF.ModelData.PathEnumeration.jsonl", "positionMetadata": {"lineInFile": 150, "tokenPositionInFile": 4913, "theoremPositionInFile": 14}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 12, "numPremises": 27}, "proofMetadata": {"hasProof": true, "proof": ":=\n  Iff.rfl", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 12}}
{"srcContext": "import ConNF.Model.Hailperin\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal ConNF.TSet\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\ntheorem ext (x y : TSet \u03b1) :\n    (\u2200 z : TSet \u03b2, z \u2208' x \u2194 z \u2208' y) \u2192 x = y :=\n  tSet_ext' h\u03b2 x y\n\ndef inter (x y : TSet \u03b1) : TSet \u03b1 :=\n  (TSet.exists_inter h\u03b2 x y).choose\n\nnotation:69 x:69 \" \u2293[\" h \"] \" y:69 => _root_.ConNF.inter h x y\nnotation:69 x:69 \" \u2293' \" y:69 => x \u2293[by assumption] y\n\n@[simp]\ntheorem mem_inter_iff (x y : TSet \u03b1) :\n    \u2200 z : TSet \u03b2, z \u2208' x \u2293' y \u2194 z \u2208' x \u2227 z \u2208' y :=\n  (TSet.exists_inter h\u03b2 x y).choose_spec\n\ndef compl (x : TSet \u03b1) : TSet \u03b1 :=\n  (TSet.exists_compl h\u03b2 x).choose\n\nnotation:1024 x:1024 \" \u1d9c[\" h \"]\" => _root_.ConNF.compl h x\nnotation:1024 x:1024 \" \u1d9c'\" => x\u1d9c[by assumption]\n\n@[simp]\ntheorem mem_compl_iff (x : TSet \u03b1) :\n    \u2200 z : TSet \u03b2, z \u2208' x\u1d9c' \u2194 \u00acz \u2208' x :=\n  (TSet.exists_compl h\u03b2 x).choose_spec\n\nnotation:1024 \"{\" x \"}[\" h \"]\" => _root_.ConNF.singleton h x\nnotation:1024 \"{\" x \"}'\" => {x}[by assumption]\n\n@[simp]\ntheorem mem_singleton_iff (x y : TSet \u03b2) :\n    y \u2208' {x}' \u2194 y = x :=\n  typedMem_singleton_iff' h\u03b2 x y\n\nnotation:1024 \"{\" x \", \" y \"}[\" h \"]\" => _root_.ConNF.TSet.up h x y\nnotation:1024 \"{\" x \", \" y \"}'\" => {x, y}[by assumption]\n\n@[simp]\ntheorem mem_up_iff (x y z : TSet \u03b2) :\n    z \u2208' {x, y}' \u2194 z = x \u2228 z = y :=\n  TSet.mem_up_iff h\u03b2 x y z\n\nnotation:1024 \"\u27e8\" x \", \" y \"\u27e9[\" h \", \" h' \"]\" => _root_.ConNF.TSet.op h h' x y\nnotation:1024 \"\u27e8\" x \", \" y \"\u27e9'\" => \u27e8x, y\u27e9[by assumption, by assumption]\n\ntheorem op_def (x y : TSet \u03b3) :\n    (\u27e8x, y\u27e9' : TSet \u03b1) = { {x}', {x, y}' }' :=\n  rfl\n\ndef singletonImage' (x : TSet \u03b2) : TSet \u03b1 :=\n  (TSet.exists_singletonImage h\u03b2 h\u03b3 h\u03b4 h\u03b5 x).choose\n\n@[simp]\ntheorem singletonImage'_spec (x : TSet \u03b2) :\n    \u2200 z w,\n    \u27e8 {z}', {w}' \u27e9' \u2208' singletonImage' h\u03b2 h\u03b3 h\u03b4 h\u03b5 x \u2194 \u27e8z, w\u27e9' \u2208' x :=\n  (TSet.exists_singletonImage h\u03b2 h\u03b3 h\u03b4 h\u03b5 x).choose_spec\n\ndef insertion2' (x : TSet \u03b3) : TSet \u03b1 :=\n  (TSet.exists_insertion2 h\u03b2 h\u03b3 h\u03b4 h\u03b5 h\u03b6 x).choose\n\n@[simp]\ntheorem insertion2'_spec (x : TSet \u03b3) :\n    \u2200 a b c, \u27e8 { {a}' }', \u27e8b, c\u27e9' \u27e9' \u2208' insertion2' h\u03b2 h\u03b3 h\u03b4 h\u03b5 h\u03b6 x \u2194\n    \u27e8a, c\u27e9' \u2208' x :=\n  (TSet.exists_insertion2 h\u03b2 h\u03b3 h\u03b4 h\u03b5 h\u03b6 x).choose_spec\n\ndef insertion3' (x : TSet \u03b3) : TSet \u03b1 :=\n  (TSet.exists_insertion3 h\u03b2 h\u03b3 h\u03b4 h\u03b5 h\u03b6 x).choose\n\ntheorem insertion3'_spec (x : TSet \u03b3) :\n    \u2200 a b c, \u27e8 { {a}' }', \u27e8b, c\u27e9' \u27e9' \u2208' insertion3' h\u03b2 h\u03b3 h\u03b4 h\u03b5 h\u03b6 x \u2194\n    \u27e8a, b\u27e9' \u2208' x :=\n  (TSet.exists_insertion3 h\u03b2 h\u03b3 h\u03b4 h\u03b5 h\u03b6 x).choose_spec\n\ndef vCross (x : TSet \u03b3) : TSet \u03b1 :=\n  (TSet.exists_cross h\u03b2 h\u03b3 h\u03b4 x).choose\n\n@[simp]\ntheorem vCross_spec (x : TSet \u03b3) :\n    \u2200 a, a \u2208' vCross h\u03b2 h\u03b3 h\u03b4 x \u2194 \u2203 b c, a = \u27e8b, c\u27e9' \u2227 c \u2208' x :=\n  (TSet.exists_cross h\u03b2 h\u03b3 h\u03b4 x).choose_spec\n\ndef typeLower (x : TSet \u03b1) : TSet \u03b4 :=\n  (TSet.exists_typeLower h\u03b2 h\u03b3 h\u03b4 h\u03b5 x).choose\n\n@[simp]\ntheorem mem_typeLower_iff (x : TSet \u03b1) :\n    \u2200 a, a \u2208' typeLower h\u03b2 h\u03b3 h\u03b4 h\u03b5 x \u2194 \u2200 b, \u27e8 b, {a}' \u27e9' \u2208' x :=\n  (TSet.exists_typeLower h\u03b2 h\u03b3 h\u03b4 h\u03b5 x).choose_spec\n\ndef converse' (x : TSet \u03b1) : TSet \u03b1 :=\n  (TSet.exists_converse h\u03b2 h\u03b3 h\u03b4 x).choose\n\n@[simp]\ntheorem converse'_spec (x : TSet \u03b1) :\n    \u2200 a b, \u27e8a, b\u27e9' \u2208' converse' h\u03b2 h\u03b3 h\u03b4 x \u2194 \u27e8b, a\u27e9' \u2208' x :=\n  (TSet.exists_converse h\u03b2 h\u03b3 h\u03b4 x).choose_spec\n\ndef cardinalOne : TSet \u03b1 :=\n  (TSet.exists_cardinalOne h\u03b2 h\u03b3).choose\n\n", "theoremStatement": "@[simp]\ntheorem mem_cardinalOne_iff :\n    \u2200 a : TSet \u03b2, a \u2208' cardinalOne h\u03b2 h\u03b3 \u2194 \u2203 b, a = {b}' ", "theoremName": "ConNF.mem_cardinalOne_iff", "fileCreated": {"commit": "b12701769822aaf5451982e26d7b7d1c2f21b137", "date": "2024-04-11"}, "theoremCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "file": "ConNF/ConNF/Model/Result.lean", "module": "ConNF.Model.Result", "jsonFile": "ConNF.Model.Result.jsonl", "positionMetadata": {"lineInFile": 125, "tokenPositionInFile": 3460, "theoremPositionInFile": 31}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 12, "numPremises": 26}, "proofMetadata": {"hasProof": true, "proof": ":=\n  (TSet.exists_cardinalOne h\u03b2 h\u03b3).choose_spec", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 48}}
{"srcContext": "import ConNF.Model.Result\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal ConNF.TSet\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\ndef union (x y : TSet \u03b1) : TSet \u03b1 :=\n  (x\u1d9c' \u2293' y\u1d9c')\u1d9c'\n\nnotation:68 x:68 \" \u2294[\" h \"] \" y:68 => _root_.ConNF.union h x y\nnotation:68 x:68 \" \u2294' \" y:68 => x \u2294[by assumption] y\n\n@[simp]\ntheorem mem_union_iff (x y : TSet \u03b1) :\n    \u2200 z : TSet \u03b2, z \u2208' x \u2294' y \u2194 z \u2208' x \u2228 z \u2208' y := by\n  rw [union]\n  intro z\n  rw [mem_compl_iff, mem_inter_iff, mem_compl_iff, mem_compl_iff, or_iff_not_and_not]\n\ndef higherIndex (\u03b1 : \u039b) : \u039b :=\n  (exists_gt \u03b1).choose\n\ntheorem lt_higherIndex {\u03b1 : \u039b} :\n    (\u03b1 : TypeIndex) < higherIndex \u03b1 :=\n  WithBot.coe_lt_coe.mpr (exists_gt \u03b1).choose_spec\n\ntheorem tSet_nonempty (h : \u2203 \u03b2 : \u039b, (\u03b2 : TypeIndex) < \u03b1) : Nonempty (TSet \u03b1) := by\n  obtain \u27e8\u03b1', h\u03b1\u27e9 := h\n  constructor\n  apply typeLower lt_higherIndex lt_higherIndex lt_higherIndex h\u03b1\n  apply cardinalOne lt_higherIndex lt_higherIndex\n\ndef empty : TSet \u03b1 :=\n  (tSet_nonempty \u27e8\u03b2, h\u03b2\u27e9).some \u2293' (tSet_nonempty \u27e8\u03b2, h\u03b2\u27e9).some\u1d9c'\n\n@[simp]\ntheorem mem_empty_iff :\n    \u2200 x : TSet \u03b2, \u00acx \u2208' empty h\u03b2 := by\n  intro x\n  rw [empty, mem_inter_iff, mem_compl_iff]\n  exact and_not_self\n\ndef univ : TSet \u03b1 :=\n  (empty h\u03b2)\u1d9c'\n\n@[simp]\ntheorem mem_univ_iff :\n    \u2200 x : TSet \u03b2, x \u2208' univ h\u03b2 := by\n  intro x\n  simp only [univ, mem_compl_iff, mem_empty_iff, not_false_eq_true]\n\n/-- The set of all ordered pairs. -/\ndef orderedPairs : TSet \u03b1 :=\n  vCross h\u03b2 h\u03b3 h\u03b4 (univ h\u03b4)\n\n@[simp]\ntheorem mem_orderedPairs_iff (x : TSet \u03b2) :\n    x \u2208' orderedPairs h\u03b2 h\u03b3 h\u03b4 \u2194 \u2203 a b, x = \u27e8a, b\u27e9' := by\n  simp only [orderedPairs, vCross_spec, mem_univ_iff, and_true]\n\ndef converse (x : TSet \u03b1) : TSet \u03b1 :=\n  converse' h\u03b2 h\u03b3 h\u03b4 x \u2293' orderedPairs h\u03b2 h\u03b3 h\u03b4\n\n@[simp]\ntheorem op_mem_converse_iff (x : TSet \u03b1) :\n    \u2200 a b, \u27e8a, b\u27e9' \u2208' converse h\u03b2 h\u03b3 h\u03b4 x \u2194 \u27e8b, a\u27e9' \u2208' x := by\n  intro a b\n  simp only [converse, mem_inter_iff, converse'_spec, mem_orderedPairs_iff, op_inj, exists_and_left,\n    exists_eq', and_true]\n\ndef cross (x y : TSet \u03b3) : TSet \u03b1 :=\n  converse h\u03b2 h\u03b3 h\u03b4 (vCross h\u03b2 h\u03b3 h\u03b4 x) \u2293' vCross h\u03b2 h\u03b3 h\u03b4 y\n\n@[simp]\ntheorem mem_cross_iff (x y : TSet \u03b3) :\n    \u2200 a, a \u2208' cross h\u03b2 h\u03b3 h\u03b4 x y \u2194 \u2203 b c, a = \u27e8b, c\u27e9' \u2227 b \u2208' x \u2227 c \u2208' y := by\n  intro a\n  rw [cross, mem_inter_iff, vCross_spec]\n  constructor\n  \u00b7 rintro \u27e8h\u2081, b, c, rfl, h\u2082\u27e9\n    simp only [op_mem_converse_iff, vCross_spec, op_inj] at h\u2081\n    obtain \u27e8b', c', \u27e8rfl, rfl\u27e9, h\u2081\u27e9 := h\u2081\n    exact \u27e8b, c, rfl, h\u2081, h\u2082\u27e9\n  \u00b7 rintro \u27e8b, c, rfl, h\u2081, h\u2082\u27e9\n    simp only [op_mem_converse_iff, vCross_spec, op_inj]\n    exact \u27e8\u27e8c, b, \u27e8rfl, rfl\u27e9, h\u2081\u27e9, \u27e8b, c, \u27e8rfl, rfl\u27e9, h\u2082\u27e9\u27e9\n\ndef singletonImage (x : TSet \u03b2) : TSet \u03b1 :=\n  singletonImage' h\u03b2 h\u03b3 h\u03b4 h\u03b5 x \u2293' (cross h\u03b2 h\u03b3 h\u03b4 (cardinalOne h\u03b4 h\u03b5) (cardinalOne h\u03b4 h\u03b5))\n\n@[simp]\ntheorem singletonImage_spec (x : TSet \u03b2) :\n    \u2200 z w,\n    \u27e8 {z}', {w}' \u27e9' \u2208' singletonImage h\u03b2 h\u03b3 h\u03b4 h\u03b5 x \u2194 \u27e8z, w\u27e9' \u2208' x := by\n  intro z w\n  rw [singletonImage, mem_inter_iff, singletonImage'_spec, and_iff_left_iff_imp]\n  intro hzw\n  rw [mem_cross_iff]\n  refine \u27e8{z}', {w}', rfl, ?_\u27e9\n  simp only [mem_cardinalOne_iff, singleton_inj, exists_eq', and_self]\n\ntheorem exists_of_mem_singletonImage {x : TSet \u03b2} {z w : TSet \u03b4}\n    (h : \u27e8z, w\u27e9' \u2208' singletonImage h\u03b2 h\u03b3 h\u03b4 h\u03b5 x) :\n    \u2203 a b, z = {a}' \u2227 w = {b}' := by\n  simp only [singletonImage, mem_inter_iff, mem_cross_iff, op_inj, mem_cardinalOne_iff] at h\n  obtain \u27e8-, _, _, \u27e8rfl, rfl\u27e9, \u27e8a, rfl\u27e9, \u27e8b, rfl\u27e9\u27e9 := h\n  exact \u27e8a, b, rfl, rfl\u27e9\n\n/-- Turn a model element encoding a relation into an actual relation. -/\ndef ExternalRel (r : TSet \u03b1) : Rel (TSet \u03b4) (TSet \u03b4) :=\n  \u03bb x y \u21a6 \u27e8x, y\u27e9' \u2208' r\n\n@[simp]\ntheorem externalRel_converse (r : TSet \u03b1) :\n    ExternalRel h\u03b2 h\u03b3 h\u03b4 (converse h\u03b2 h\u03b3 h\u03b4 r) = (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).inv := by\n  ext\n  simp only [ExternalRel, op_mem_converse_iff, Rel.inv_apply]\n\n/-- The codomain of a relation. -/\ndef codom (r : TSet \u03b1) : TSet \u03b3 :=\n  (typeLower lt_higherIndex h\u03b2 h\u03b3 h\u03b4 (singletonImage lt_higherIndex h\u03b2 h\u03b3 h\u03b4 r)\u1d9c[lt_higherIndex])\u1d9c'\n\n@[simp]\ntheorem mem_codom_iff (r : TSet \u03b1) (x : TSet \u03b4) :\n    x \u2208' codom h\u03b2 h\u03b3 h\u03b4 r \u2194 x \u2208 (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).codom := by\n  simp only [codom, mem_compl_iff, mem_typeLower_iff, not_forall, not_not]\n  constructor\n  \u00b7 rintro \u27e8y, hy\u27e9\n    obtain \u27e8a, b, rfl, hb\u27e9 := exists_of_mem_singletonImage lt_higherIndex h\u03b2 h\u03b3 h\u03b4 hy\n    rw [singleton_inj] at hb\n    subst hb\n    rw [singletonImage_spec] at hy\n    exact \u27e8a, hy\u27e9\n  \u00b7 rintro \u27e8a, ha\u27e9\n    use {a}'\n    rw [singletonImage_spec]\n    exact ha\n\n/-- The domain of a relation. -/\ndef dom (r : TSet \u03b1) : TSet \u03b3 :=\n  codom h\u03b2 h\u03b3 h\u03b4 (converse h\u03b2 h\u03b3 h\u03b4 r)\n\n@[simp]\ntheorem mem_dom_iff (r : TSet \u03b1) (x : TSet \u03b4) :\n    x \u2208' dom h\u03b2 h\u03b3 h\u03b4 r \u2194 x \u2208 (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).dom := by\n  rw [dom, mem_codom_iff, externalRel_converse, Rel.inv_codom]\n\n/-- The field of a relation. -/\ndef field (r : TSet \u03b1) : TSet \u03b3 :=\n  dom h\u03b2 h\u03b3 h\u03b4 r \u2294' codom h\u03b2 h\u03b3 h\u03b4 r\n\n", "theoremStatement": "@[simp]\ntheorem mem_field_iff (r : TSet \u03b1) (x : TSet \u03b4) :\n    x \u2208' field h\u03b2 h\u03b3 h\u03b4 r \u2194 x \u2208 (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).field ", "theoremName": "ConNF.mem_field_iff", "fileCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "theoremCreated": {"commit": "1c08486feb882444888c228ce1501e92bb85e0e2", "date": "2025-01-07"}, "file": "ConNF/ConNF/External/Basic.lean", "module": "ConNF.External.Basic", "jsonFile": "ConNF.External.Basic.jsonl", "positionMetadata": {"lineInFile": 168, "tokenPositionInFile": 5056, "theoremPositionInFile": 27}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 8, "repositoryPremises": true, "numRepositoryPremises": 18, "numPremises": 46}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [field, mem_union_iff, mem_dom_iff, mem_codom_iff, Rel.field, Set.mem_union]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 87}}
{"srcContext": "import ConNF.Model.Externalise\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b2 \u03b3 : \u039b} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n\nnamespace Support\n\ntheorem not_mem_scoderiv_botDeriv (S : Support \u03b3) (N : NearLitter) :\n    N \u2209 (S \u2197 h\u03b3 \u21d8. (Path.nil \u2198.))\u1d3a := by\n  rintro \u27e8i, \u27e8A, N'\u27e9, h\u2081, h\u2082\u27e9\n  simp only [Prod.mk.injEq] at h\u2082\n  cases A\n  case sderiv \u03b4 A h\u03b4 _ =>\n    simp only [Path.deriv_sderiv] at h\u2082\n    cases A\n    case nil => cases h\u2082.1\n    case sderiv \u03b6 A h\u03b6 _ =>\n      simp only [Path.deriv_sderiv] at h\u2082\n      cases h\u2082.1\n\nvariable [Level] [LtLevel \u03b2]\n\ntheorem not_mem_strong_botDeriv (S : Support \u03b3) (N : NearLitter) :\n    N \u2209 ((S \u2197 h\u03b3).strong \u21d8. (Path.nil \u2198.))\u1d3a := by\n  rintro h\n  rw [strong, close_nearLitters, preStrong_nearLitters, Enumeration.mem_add_iff] at h\n  obtain h | h := h\n  \u00b7 exact not_mem_scoderiv_botDeriv S N h\n  \u00b7 rw [mem_constrainsNearLitters_nearLitters] at h\n    obtain \u27e8B, N', hN', h\u27e9 := h\n    cases h using Relation.ReflTransGen.head_induction_on\n    case refl => exact not_mem_scoderiv_botDeriv S N hN'\n    case head x hx\u2081 hx\u2082 _ =>\n      obtain \u27e8\u27e8\u03b3, \u03b4, \u03b5, h\u03b4, h\u03b5, h\u03b4\u03b5, A\u27e9, t, B, hB, hN, ht\u27e9 := hx\u2082\n      simp only at hB\n      cases B\n      case nil =>\n        cases hB\n        obtain \u27e8C, N''\u27e9 := x\n        simp only at ht\n        cases ht.1\n        change _ \u2208 t.support\u1d3a at hN\n        rw [t.support_supports.2 rfl] at hN\n        obtain \u27e8i, hN\u27e9 := hN\n        cases hN\n      case sderiv \u03b4 B h\u03b4 _ _ =>\n        cases B\n        case nil => cases hB\n        case sderiv \u03b6 B h\u03b6 _ _ => cases hB\n\ntheorem raise_preStrong' (S : Support \u03b1) (hS : S.Strong) (T : Support \u03b3) (\u03c1 : AllPerm \u03b2)\n    (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2) :\n    (S + (\u03c1\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim).PreStrong := by\n  apply hS.toPreStrong.add\n  constructor\n  intro A N hN P t hA ht\n  obtain \u27e8A, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv hN\n  simp only [scoderiv_botDeriv_eq, add_derivBot, smul_derivBot,\n    BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters, interferenceSupport_nearLitters,\n    Enumeration.mem_add_iff, Enumeration.mem_smul, Enumeration.not_mem_empty, or_false] at hN\n  obtain \u27e8\u03b4, \u03b5, \u03b6, h\u03b5, h\u03b6, h\u03b5\u03b6, B\u27e9 := P\n  dsimp only at *\n  cases A\n  case sderiv \u03b6' A h\u03b6' _ =>\n    rw [\u2190 Path.coderiv_deriv] at hA\n    cases Path.sderiv_index_injective hA\n    apply Path.sderiv_left_inj.mp at hA\n    cases A\n    case nil =>\n      cases hA\n      cases not_mem_strong_botDeriv T _ hN\n    case sderiv \u03b9 A h\u03b9 _ _ =>\n      rw [\u2190 Path.coderiv_deriv] at hA\n      cases Path.sderiv_index_injective hA\n      cases hA\n      haveI : LtLevel \u03b4 := \u27e8A.le.trans_lt LtLevel.elim\u27e9\n      haveI : LtLevel \u03b5 := \u27e8h\u03b5.trans LtLevel.elim\u27e9\n      haveI : LtLevel \u03b6 := \u27e8h\u03b6.trans LtLevel.elim\u27e9\n      have := (T \u2197 h\u03b3).strong_strong.support_le hN \u27e8\u03b4, \u03b5, \u03b6, h\u03b5, h\u03b6, h\u03b5\u03b6, A\u27e9\n          (\u03c1\u207b\u00b9 \u21d8 A \u2198 h\u03b5 \u2022 t) rfl ?_\n      \u00b7 simp only [Tangle.smul_support, allPermSderiv_forget, allPermDeriv_forget,\n          allPermForget_inv, Tree.inv_deriv, Tree.inv_sderiv] at this\n        have := smul_le_smul this (\u03c1\u1d41 \u21d8 A \u2198 h\u03b5)\n        simp only [smul_inv_smul] at this\n        apply le_trans this\n        intro B\n        constructor\n        \u00b7 intro a ha\n          simp only [smul_derivBot, Tree.sderiv_apply, Tree.deriv_apply, Path.deriv_scoderiv,\n            deriv_derivBot, Enumeration.mem_smul] at ha\n          rw [deriv_derivBot, \u2190 Path.deriv_scoderiv, Path.coderiv_deriv', scoderiv_botDeriv_eq,]\n          simp only [Path.deriv_scoderiv, add_derivBot, smul_derivBot,\n            BaseSupport.add_atoms, BaseSupport.smul_atoms, Enumeration.mem_add_iff,\n            Enumeration.mem_smul]\n          exact Or.inl ha\n        \u00b7 intro N hN\n          simp only [smul_derivBot, Tree.sderiv_apply, Tree.deriv_apply, Path.deriv_scoderiv,\n            deriv_derivBot, Enumeration.mem_smul] at hN\n          rw [deriv_derivBot, \u2190 Path.deriv_scoderiv, Path.coderiv_deriv', scoderiv_botDeriv_eq,]\n          simp only [Path.deriv_scoderiv, add_derivBot, smul_derivBot,\n            BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters, Enumeration.mem_add_iff,\n            Enumeration.mem_smul]\n          exact Or.inl hN\n      \u00b7 rw [\u2190 smul_fuzz h\u03b5 h\u03b6 h\u03b5\u03b6, \u2190 ht]\n        simp only [Path.botSderiv_coe_eq, BasePerm.smul_nearLitter_litter, allPermDeriv_forget,\n          allPermForget_inv, Tree.inv_deriv, Tree.inv_sderiv, Tree.inv_sderivBot]\n        rfl\n\ntheorem raise_closed' (S : Support \u03b1) (hS : S.Strong) (T : Support \u03b3) (\u03c1 : AllPerm \u03b2)\n    (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n    (h\u03c1 : \u03c1\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim) :\n    (S + (\u03c1\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim).Closed := by\n  constructor\n  intro A\n  constructor\n  intro N\u2081 N\u2082 hN\u2081 hN\u2082 a ha\n  simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff,\n    BaseSupport.add_atoms] at hN\u2081 hN\u2082 \u22a2\n  obtain hN\u2081 | hN\u2081 := hN\u2081\n  \u00b7 obtain hN\u2082 | hN\u2082 := hN\u2082\n    \u00b7 exact Or.inl ((hS.closed A).interference_subset hN\u2081 hN\u2082 a ha)\n    \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv hN\u2082\n      simp only [smul_add, scoderiv_botDeriv_eq, add_derivBot, smul_derivBot,\n        BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters, Enumeration.mem_add_iff,\n        Enumeration.mem_smul, BaseSupport.add_atoms, BaseSupport.smul_atoms] at hN\u2081 hN\u2082 \u22a2\n      refine Or.inr (Or.inr ?_)\n      rw [mem_interferenceSupport_atoms]\n      refine \u27e8(\u03c1\u1d41 B)\u207b\u00b9 \u2022 N\u2081, ?_, (\u03c1\u1d41 B)\u207b\u00b9 \u2022 N\u2082, ?_, ?_\u27e9\n      \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n        rw [\u2190 Enumeration.mem_smul, \u2190 BaseSupport.smul_nearLitters, \u2190 smul_derivBot, h\u03c1]\n        exact Or.inl hN\u2081\n      \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n        simp only [interferenceSupport_nearLitters, Enumeration.not_mem_empty, or_false] at hN\u2082\n        exact Or.inr hN\u2082\n      \u00b7 rw [\u2190 BasePerm.smul_interference]\n        exact Set.smul_mem_smul_set ha\n  \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv hN\u2081\n    simp only [smul_add, scoderiv_botDeriv_eq, add_derivBot, smul_derivBot,\n      BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters, Enumeration.mem_add_iff,\n      Enumeration.mem_smul, BaseSupport.add_atoms, BaseSupport.smul_atoms] at hN\u2081 hN\u2082 \u22a2\n    refine Or.inr (Or.inr ?_)\n    rw [mem_interferenceSupport_atoms]\n    refine \u27e8(\u03c1\u1d41 B)\u207b\u00b9 \u2022 N\u2081, ?_, (\u03c1\u1d41 B)\u207b\u00b9 \u2022 N\u2082, ?_, ?_\u27e9\n    \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n      simp only [interferenceSupport_nearLitters, Enumeration.not_mem_empty, or_false] at hN\u2081\n      exact Or.inr hN\u2081\n    \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n      simp only [interferenceSupport_nearLitters, Enumeration.not_mem_empty, or_false] at hN\u2082\n      obtain hN\u2082 | hN\u2082 := hN\u2082\n      \u00b7 rw [\u2190 Enumeration.mem_smul, \u2190 BaseSupport.smul_nearLitters, \u2190 smul_derivBot, h\u03c1]\n        exact Or.inl hN\u2082\n      \u00b7 exact Or.inr hN\u2082\n    \u00b7 rw [\u2190 BasePerm.smul_interference]\n      exact Set.smul_mem_smul_set ha\n\ntheorem raise_strong' (S : Support \u03b1) (hS : S.Strong) (T : Support \u03b3) (\u03c1 : AllPerm \u03b2)\n    (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n    (h\u03c1 : \u03c1\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim) :\n    (S + (\u03c1\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim).Strong :=\n  \u27e8raise_preStrong' S hS T \u03c1 h\u03b3, raise_closed' S hS T \u03c1 h\u03b3 h\u03c1\u27e9\n\ntheorem convAtoms_injective_of_fixes {S : Support \u03b1} {T : Support \u03b3}\n    {\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n    (h\u03c1\u2081 : \u03c1\u2081\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (h\u03c1\u2082 : \u03c1\u2082\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (A : \u2191\u03b1 \u219d \u22a5) :\n    (convAtoms\n      (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong + (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197\n        LtLevel.elim)\n      (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong + (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197\n        LtLevel.elim) A).Injective := by\n  rw [Support.smul_eq_iff] at h\u03c1\u2081 h\u03c1\u2082\n  constructor\n  rintro a\u2081 a\u2082 a\u2083 \u27e8i, hi\u2081, hi\u2082\u27e9 \u27e8j, hj\u2081, hj\u2082\u27e9\n  simp only [add_derivBot, BaseSupport.add_atoms, Rel.inv_apply,\n    Enumeration.rel_add_iff] at hi\u2081 hi\u2082 hj\u2081 hj\u2082\n  obtain hi\u2081 | \u27e8i, rfl, hi\u2081\u27e9 := hi\u2081\n  \u00b7 obtain hi\u2082 | \u27e8i', rfl, _\u27e9 := hi\u2082\n    swap\n    \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hi\u2081\u27e9\n      simp only [add_lt_iff_neg_left] at this\n      cases (\u03ba_zero_le i').not_lt this\n    cases (Enumeration.rel_coinjective _).coinjective hi\u2081 hi\u2082\n    obtain hj\u2081 | \u27e8j, rfl, hj\u2081\u27e9 := hj\u2081\n    \u00b7 obtain hj\u2082 | \u27e8j', rfl, _\u27e9 := hj\u2082\n      \u00b7 exact (Enumeration.rel_coinjective _).coinjective hj\u2082 hj\u2081\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2081\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j').not_lt this\n    \u00b7 obtain hj\u2082 | hj\u2082 := hj\u2082\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2082\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j).not_lt this\n      \u00b7 simp only [add_right_inj, exists_eq_left] at hj\u2082\n        obtain \u27e8B, rfl\u27e9 := eq_of_atom_mem_scoderiv_botDeriv \u27e8j, hj\u2081\u27e9\n        simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_atoms,\n          BaseSupport.add_atoms, Enumeration.smul_rel, add_right_inj, exists_eq_left] at hj\u2081 hj\u2082\n        have := (Enumeration.rel_coinjective _).coinjective hj\u2081 hj\u2082\n        rw [\u2190 (h\u03c1\u2082 B).1 a\u2081 \u27e8_, hi\u2081\u27e9, inv_smul_smul, inv_smul_eq_iff, (h\u03c1\u2081 B).1 a\u2081 \u27e8_, hi\u2081\u27e9] at this\n        exact this.symm\n  \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_atom_mem_scoderiv_botDeriv \u27e8i, hi\u2081\u27e9\n    simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_atoms,\n      BaseSupport.add_atoms, Enumeration.smul_rel, add_right_inj, exists_eq_left] at hi\u2081 hi\u2082 hj\u2081 hj\u2082\n    obtain hi\u2082 | hi\u2082 := hi\u2082\n    \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hi\u2082\u27e9\n      simp only [add_lt_iff_neg_left] at this\n      cases (\u03ba_zero_le i).not_lt this\n    have hi := (Enumeration.rel_coinjective _).coinjective hi\u2081 hi\u2082\n    suffices hj : (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 a\u2082 = (\u03c1\u2082\u1d41 B)\u207b\u00b9 \u2022 a\u2083 by\n      rwa [\u2190 hj, smul_left_cancel_iff] at hi\n    obtain hj\u2081 | \u27e8j, rfl, hj\u2081\u27e9 := hj\u2081\n    \u00b7 obtain hj\u2082 | \u27e8j', rfl, _\u27e9 := hj\u2082\n      \u00b7 rw [\u2190 (h\u03c1\u2081 B).1 a\u2082 \u27e8_, hj\u2081\u27e9, \u2190 (h\u03c1\u2082 B).1 a\u2083 \u27e8_, hj\u2082\u27e9, inv_smul_smul, inv_smul_smul]\n        exact (Enumeration.rel_coinjective _).coinjective hj\u2081 hj\u2082\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2081\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j').not_lt this\n    \u00b7 obtain hj\u2082 | hj\u2082 := hj\u2082\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2082\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j).not_lt this\n      \u00b7 simp only [add_right_inj, exists_eq_left] at hj\u2082\n        exact (Enumeration.rel_coinjective _).coinjective hj\u2081 hj\u2082\n\ntheorem atomMemRel_le_of_fixes {S : Support \u03b1} {T : Support \u03b3}\n    {\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n    (h\u03c1\u2081 : \u03c1\u2081\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (h\u03c1\u2082 : \u03c1\u2082\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (A : \u2191\u03b1 \u219d \u22a5) :\n    atomMemRel (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A \u2264\n    atomMemRel (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A := by\n  rw [Support.smul_eq_iff] at h\u03c1\u2081 h\u03c1\u2082\n  rintro i j \u27e8N, hN, a, haN, ha\u27e9\n  simp only [add_derivBot, BaseSupport.add_atoms, Rel.inv_apply, Enumeration.rel_add_iff,\n    BaseSupport.add_nearLitters] at ha hN\n  obtain hN | \u27e8i, rfl, hi\u27e9 := hN\n  \u00b7 obtain ha | \u27e8j, rfl, hj\u27e9 := ha\n    \u00b7 exact \u27e8N, Or.inl hN, a, haN, Or.inl ha\u27e9\n    \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_atom_mem_scoderiv_botDeriv \u27e8j, hj\u27e9\n      simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_atoms,\n        BaseSupport.add_atoms, Enumeration.smul_rel] at hj hN\n      refine \u27e8N, Or.inl hN, \u03c1\u2082\u1d41 B \u2022 (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 a, ?_, ?_\u27e9\n      \u00b7 dsimp only\n        rw [\u2190 (h\u03c1\u2082 B).2 N \u27e8_, hN\u27e9, BasePerm.smul_nearLitter_atoms, Set.smul_mem_smul_set_iff]\n        have := (h\u03c1\u2081 B).2 N \u27e8_, hN\u27e9\n        rw [smul_eq_iff_eq_inv_smul] at this\n        rwa [this, BasePerm.smul_nearLitter_atoms, Set.smul_mem_smul_set_iff]\n      \u00b7 rw [Rel.inv_apply, add_derivBot, BaseSupport.add_atoms, Enumeration.rel_add_iff]\n        simp only [add_right_inj, scoderiv_botDeriv_eq, smul_derivBot, add_derivBot,\n          BaseSupport.smul_atoms, BaseSupport.add_atoms, Enumeration.smul_rel, inv_smul_smul,\n          exists_eq_left]\n        exact Or.inr hj\n  \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv \u27e8i, hi\u27e9\n    simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_atoms,\n      BaseSupport.add_atoms, Enumeration.smul_rel] at hi ha\n    obtain ha | \u27e8j, rfl, hj\u27e9 := ha\n    \u00b7 refine \u27e8\u03c1\u2082\u1d41 B \u2022 (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 N, ?_, a, ?_, Or.inl ha\u27e9\n      \u00b7 rw [add_derivBot, BaseSupport.add_nearLitters, Enumeration.rel_add_iff]\n        simp only [add_right_inj, scoderiv_botDeriv_eq, smul_derivBot, add_derivBot,\n          BaseSupport.smul_nearLitters, BaseSupport.add_nearLitters, Enumeration.smul_rel,\n          inv_smul_smul, exists_eq_left]\n        exact Or.inr hi\n      \u00b7 dsimp only\n        rw [\u2190 (h\u03c1\u2082 B).1 a \u27e8_, ha\u27e9, BasePerm.smul_nearLitter_atoms, Set.smul_mem_smul_set_iff]\n        have := (h\u03c1\u2081 B).1 a \u27e8_, ha\u27e9\n        rw [smul_eq_iff_eq_inv_smul] at this\n        rwa [this, BasePerm.smul_nearLitter_atoms, Set.smul_mem_smul_set_iff]\n    \u00b7 refine \u27e8\u03c1\u2082\u1d41 B \u2022 (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 N, ?_, \u03c1\u2082\u1d41 B \u2022 (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 a, ?_, ?_\u27e9\n      \u00b7 rw [add_derivBot, BaseSupport.add_nearLitters, Enumeration.rel_add_iff]\n        simp only [add_right_inj, scoderiv_botDeriv_eq, smul_derivBot, add_derivBot,\n          BaseSupport.smul_nearLitters, BaseSupport.add_nearLitters, Enumeration.smul_rel,\n          inv_smul_smul, exists_eq_left]\n        exact Or.inr hi\n      \u00b7 simp only [BasePerm.smul_nearLitter_atoms, Set.smul_mem_smul_set_iff]\n        exact haN\n      \u00b7 rw [Rel.inv_apply, add_derivBot, BaseSupport.add_atoms, Enumeration.rel_add_iff]\n        simp only [add_right_inj, scoderiv_botDeriv_eq, smul_derivBot, add_derivBot,\n          BaseSupport.smul_atoms, BaseSupport.add_atoms, Enumeration.smul_rel, inv_smul_smul,\n          exists_eq_left]\n        exact Or.inr hj\n\ntheorem convNearLitters_cases {S : Support \u03b1} {T : Support \u03b3}\n    {\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n    {A : \u03b1 \u219d \u22a5} {N\u2081 N\u2082 : NearLitter} :\n  convNearLitters\n    (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim)\n    (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A N\u2081 N\u2082 \u2192\n    N\u2081 = N\u2082 \u2227 N\u2081 \u2208 (S \u21d8. A)\u1d3a \u2228\n    \u2203 B : \u03b2 \u219d \u22a5, A = B \u2197 LtLevel.elim \u2227 (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 N\u2081 = (\u03c1\u2082\u1d41 B)\u207b\u00b9 \u2022 N\u2082 \u2227\n      (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 N\u2081 \u2208 (((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport) \u21d8. B)\u1d3a := by\n  rintro \u27e8i, hN\u2081, hN\u2082\u27e9\n  simp only [add_derivBot, BaseSupport.add_nearLitters, Rel.inv_apply,\n    Enumeration.rel_add_iff] at hN\u2081 hN\u2082\n  obtain hN\u2081 | \u27e8i, rfl, hN\u2081\u27e9 := hN\u2081\n  \u00b7 obtain hN\u2082 | \u27e8i, rfl, hN\u2082\u27e9 := hN\u2082\n    swap\n    \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hN\u2081\u27e9\n      simp only [add_lt_iff_neg_left] at this\n      cases (\u03ba_zero_le i).not_lt this\n    exact Or.inl \u27e8(Enumeration.rel_coinjective _).coinjective hN\u2081 hN\u2082, _, hN\u2081\u27e9\n  \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv \u27e8i, hN\u2081\u27e9\n    simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_nearLitters,\n      BaseSupport.add_nearLitters, Enumeration.smul_rel, add_right_inj, exists_eq_left] at hN\u2081 hN\u2082\n    obtain hN\u2082 | hN\u2082 := hN\u2082\n    \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hN\u2082\u27e9\n      simp only [add_lt_iff_neg_left] at this\n      cases (\u03ba_zero_le i).not_lt this\n    exact Or.inr \u27e8B, rfl, (Enumeration.rel_coinjective _).coinjective hN\u2081 hN\u2082, _, hN\u2081\u27e9\n\ntheorem inflexible_of_inflexible_of_fixes {S : Support \u03b1} {T : Support \u03b3}\n    {\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n    (h\u03c1\u2081 : \u03c1\u2081\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (h\u03c1\u2082 : \u03c1\u2082\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    {A : \u03b1 \u219d \u22a5} {N\u2081 N\u2082 : NearLitter} :\n    convNearLitters\n      (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim)\n      (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A N\u2081 N\u2082 \u2192\n      \u2200 (P : InflexiblePath \u2191\u03b1) (t : Tangle P.\u03b4), A = P.A \u2198 P.h\u03b5 \u2198. \u2192 N\u2081\u1d38 = fuzz P.h\u03b4\u03b5 t \u2192\n      \u2203 \u03c1 : AllPerm P.\u03b4, N\u2082\u1d38 = fuzz P.h\u03b4\u03b5 (\u03c1 \u2022 t) := by\n  rintro hN \u27e8\u03b3, \u03b4, \u03b5, h\u03b4, h\u03b5, h\u03b4\u03b5, A\u27e9 t hA ht\n  haveI : LeLevel \u03b3 := \u27e8A.le\u27e9\n  haveI : LtLevel \u03b4 := \u27e8h\u03b4.trans_le LeLevel.elim\u27e9\n  haveI : LtLevel \u03b5 := \u27e8h\u03b5.trans_le LeLevel.elim\u27e9\n  obtain \u27e8rfl, _\u27e9 | \u27e8B, rfl, hN'\u27e9 := convNearLitters_cases hN\n  \u00b7 use 1\n    rw [one_smul, ht]\n  \u00b7 clear hN\n    cases B\n    case sderiv \u03b5 B h\u03b5' _ =>\n      rw [\u2190 Path.coderiv_deriv] at hA\n      cases Path.sderiv_index_injective hA\n      apply Path.sderiv_path_injective at hA\n      cases B\n      case nil =>\n        simp only [Path.botSderiv_coe_eq, add_derivBot, BaseSupport.add_nearLitters,\n          interferenceSupport_nearLitters, Enumeration.add_empty] at hN'\n        cases not_mem_strong_botDeriv _ _ hN'.2\n      case sderiv \u03b6 B h\u03b6 _ _ =>\n        rw [\u2190 Path.coderiv_deriv] at hA\n        cases Path.sderiv_index_injective hA\n        apply Path.sderiv_path_injective at hA\n        dsimp only at hA h\u03b6 h\u03b5' B t\n        cases hA\n        use (\u03c1\u2082 * \u03c1\u2081\u207b\u00b9) \u21d8 B \u2198 h\u03b4\n        rw [inv_smul_eq_iff] at hN'\n        rw [\u2190 smul_fuzz h\u03b4 h\u03b5 h\u03b4\u03b5, \u2190 ht, hN'.1]\n        simp only [allPermDeriv_forget, allPermForget_mul, allPermForget_inv, Tree.mul_deriv,\n          Tree.inv_deriv, Tree.mul_sderiv, Tree.inv_sderiv, Tree.mul_sderivBot, Tree.inv_sderivBot,\n          Path.botSderiv_coe_eq, BasePerm.smul_nearLitter_litter, mul_smul]\n        erw [inv_smul_smul, smul_inv_smul]\n\n", "theoremStatement": "theorem atoms_of_inflexible_of_fixes {S : Support \u03b1} (hS : S.Strong) {T : Support \u03b3}\n    {\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n    (h\u03c1\u2081 : \u03c1\u2081\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (h\u03c1\u2082 : \u03c1\u2082\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (A : \u03b1 \u219d \u22a5) (N\u2081 N\u2082 : NearLitter) (P : InflexiblePath \u2191\u03b1) (t : Tangle P.\u03b4) (\u03c1 : AllPerm P.\u03b4) :\n    A = P.A \u2198 P.h\u03b5 \u2198. \u2192 N\u2081\u1d38 = fuzz P.h\u03b4\u03b5 t \u2192 N\u2082\u1d38 = fuzz P.h\u03b4\u03b5 (\u03c1 \u2022 t) \u2192\n    convNearLitters\n      (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim)\n      (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A N\u2081 N\u2082 \u2192\n    \u2200 (B : P.\u03b4 \u219d \u22a5), \u2200 a \u2208 (t.support \u21d8. B)\u1d2c, \u2200 (i : \u03ba),\n      ((S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong + (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197\n        LtLevel.elim) \u21d8. (P.A \u2198 P.h\u03b4 \u21d8 B))\u1d2c.rel i a \u2192\n      ((S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong + (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197\n        LtLevel.elim) \u21d8. (P.A \u2198 P.h\u03b4 \u21d8 B))\u1d2c.rel i (\u03c1\u1d41 B \u2022 a) ", "theoremName": "ConNF.Support.atoms_of_inflexible_of_fixes", "fileCreated": {"commit": "abf71bc79c407ceb462cc2edd2d994cda9cdef05", "date": "2024-04-04"}, "theoremCreated": {"commit": "2dd04bc4e7c491b6023c78aea4cd613f00becfc4", "date": "2024-11-30"}, "file": "ConNF/ConNF/Model/RaiseStrong.lean", "module": "ConNF.Model.RaiseStrong", "jsonFile": "ConNF.Model.RaiseStrong.jsonl", "positionMetadata": {"lineInFile": 378, "tokenPositionInFile": 17816, "theoremPositionInFile": 9}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 138, "numPremises": 231}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [Support.smul_eq_iff] at h\u03c1\u2081 h\u03c1\u2082\n  obtain \u27e8\u03b3, \u03b4, \u03b5, h\u03b4, h\u03b5, h\u03b4\u03b5, B\u27e9 := P\n  haveI : LeLevel \u03b3 := \u27e8B.le\u27e9\n  haveI : LtLevel \u03b4 := \u27e8h\u03b4.trans_le LeLevel.elim\u27e9\n  haveI : LtLevel \u03b5 := \u27e8h\u03b5.trans_le LeLevel.elim\u27e9\n  dsimp only at t \u03c1 \u22a2\n  intro hA hN\u2081 hN\u2082 hN C a ha i hi\n  obtain \u27e8rfl, hN'\u27e9 | \u27e8A, rfl, hN\u2081', hN\u2082'\u27e9 := convNearLitters_cases hN\n  \u00b7 have haS := (hS.support_le hN' \u27e8\u03b3, \u03b4, \u03b5, h\u03b4, h\u03b5, h\u03b4\u03b5, _\u27e9 t hA hN\u2081 _).1 a ha\n    rw [hN\u2082] at hN\u2081\n    have h\u03c1t := congr_arg Tangle.support (fuzz_injective hN\u2081)\n    rw [Tangle.smul_support, Support.smul_eq_iff] at h\u03c1t\n    simp only [add_derivBot, BaseSupport.add_atoms, Enumeration.rel_add_iff] at hi \u22a2\n    rw [(h\u03c1t C).1 a ha]\n    obtain hi | \u27e8i, rfl, hi\u27e9 := hi\n    \u00b7 exact Or.inl hi\n    \u00b7 simp only [add_right_inj, exists_eq_left]\n      obtain \u27e8D, hD\u27e9 := eq_of_atom_mem_scoderiv_botDeriv \u27e8i, hi\u27e9\n      cases B using Path.recScoderiv\n      case nil =>\n        cases Path.scoderiv_index_injective hD\n        cases Path.scoderiv_left_inj.mp hD\n        simp only [hD, Path.coderiv_deriv, Path.coderiv_deriv', scoderiv_botDeriv_eq, smul_derivBot,\n          add_derivBot, BaseSupport.smul_atoms, BaseSupport.add_atoms, Enumeration.smul_rel] at hi \u22a2\n        rw [deriv_derivBot, hD] at haS\n        rw [\u2190 (h\u03c1\u2082 _).1 a haS, inv_smul_smul]\n        rw [\u2190 (h\u03c1\u2081 _).1 a haS, inv_smul_smul] at hi\n        exact Or.inr hi\n      case scoderiv \u03b6 B h\u03b6' _ =>\n        rw [Path.coderiv_deriv, Path.coderiv_deriv'] at hD\n        cases Path.scoderiv_index_injective hD\n        rw [Path.scoderiv_left_inj] at hD\n        cases hD\n        simp only [Path.coderiv_deriv, Path.coderiv_deriv', scoderiv_botDeriv_eq, smul_derivBot,\n          add_derivBot, BaseSupport.smul_atoms, BaseSupport.add_atoms, Enumeration.smul_rel] at hi \u22a2\n        rw [deriv_derivBot, Path.coderiv_deriv, Path.coderiv_deriv'] at haS\n        rw [\u2190 (h\u03c1\u2082 _).1 a haS, inv_smul_smul]\n        rw [\u2190 (h\u03c1\u2081 _).1 a haS, inv_smul_smul] at hi\n        exact Or.inr hi\n  \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, interferenceSupport_nearLitters,\n      Enumeration.add_empty] at hN\u2082'\n    cases A\n    case sderiv \u03b6 A h\u03b6' _ =>\n      rw [\u2190 Path.coderiv_deriv] at hA\n      cases Path.sderiv_index_injective hA\n      apply Path.sderiv_path_injective at hA\n      cases A\n      case nil =>\n        cases hA\n        cases not_mem_strong_botDeriv _ _ hN\u2082'\n      case sderiv \u03b6 A h\u03b6 _ _ =>\n        rw [\u2190 Path.coderiv_deriv] at hA\n        cases Path.sderiv_index_injective hA\n        apply Path.sderiv_path_injective at hA\n        cases hA\n        simp only [Path.coderiv_deriv, Path.coderiv_deriv', add_derivBot, scoderiv_botDeriv_eq,\n          smul_derivBot, BaseSupport.add_atoms, BaseSupport.smul_atoms] at hi \u22a2\n        have : N\u2082\u1d38 = (\u03c1\u2082 \u21d8 A)\u1d41 \u2198 h\u03b6 \u2198. \u2022 (\u03c1\u2081\u207b\u00b9 \u21d8 A)\u1d41 \u2198 h\u03b6 \u2198. \u2022 fuzz h\u03b4\u03b5 t := by\n          rw [inv_smul_eq_iff] at hN\u2081'\n          rw [hN\u2081', Path.botSderiv_coe_eq, BasePerm.smul_nearLitter_litter,\n            BasePerm.smul_nearLitter_litter, smul_smul, smul_eq_iff_eq_inv_smul,\n            mul_inv_rev, inv_inv, mul_smul, \u2190 Tree.inv_apply, \u2190 allPermForget_inv] at hN\u2081\n          rw [hN\u2081]\n          simp only [allPermForget_inv, Tree.inv_apply, allPermDeriv_forget, Tree.inv_deriv,\n            Tree.inv_sderiv, Tree.inv_sderivBot]\n          rfl\n        rw [smul_fuzz h\u03b4 h\u03b5 h\u03b4\u03b5, smul_fuzz h\u03b4 h\u03b5 h\u03b4\u03b5] at this\n        have := fuzz_injective (hN\u2082.symm.trans this)\n        rw [smul_smul] at this\n        rw [t.smul_atom_eq_of_mem_support this ha]\n        rw [Enumeration.rel_add_iff] at hi \u22a2\n        obtain hi | \u27e8i, rfl, hi\u27e9 := hi\n        \u00b7 left\n          simp only [allPermForget_mul, allPermSderiv_forget, allPermDeriv_forget,\n            allPermForget_inv, Tree.inv_deriv, Tree.inv_sderiv, Tree.mul_apply, Tree.sderiv_apply,\n            Tree.deriv_apply, Path.deriv_scoderiv, Tree.inv_apply, mul_smul]\n          rwa [\u2190 (h\u03c1\u2081 _).1 a \u27e8i, hi\u27e9, inv_smul_smul, (h\u03c1\u2082 _).1 a \u27e8i, hi\u27e9]\n        \u00b7 refine Or.inr \u27e8i, rfl, ?_\u27e9\n          simp only [allPermForget_mul, allPermSderiv_forget, allPermDeriv_forget,\n            allPermForget_inv, Tree.inv_deriv, Tree.inv_sderiv, Tree.mul_apply, Tree.sderiv_apply,\n            Tree.deriv_apply, Path.deriv_scoderiv, Tree.inv_apply, mul_smul, Enumeration.smul_rel,\n            inv_smul_smul]\n          exact hi", "proofType": "tactic", "proofLengthLines": 83, "proofLengthTokens": 4222}}
{"srcContext": "import ConNF.Model.RunInduction\n\n/-!\n# Externalisation\n\nIn this file, we convert many of our *internal* results (i.e. inside the induction) to *external*\nones (i.e. defined using the global `TSet`/`AllPerm` definitions).\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal WithBot\n\nnamespace ConNF\n\nvariable [Params.{u}]\n\ninstance globalModelData : {\u03b1 : TypeIndex} \u2192 ModelData \u03b1\n  | (\u03b1 : \u039b) => (motive \u03b1).data\n  | \u22a5 => botModelData\n\ninstance globalPosition : {\u03b1 : TypeIndex} \u2192 Position (Tangle \u03b1)\n  | (\u03b1 : \u039b) => (motive \u03b1).pos\n  | \u22a5 => botPosition\n\ninstance globalTypedNearLitters {\u03b1 : \u039b} : TypedNearLitters \u03b1 :=\n  (motive \u03b1).typed\n\ninstance globalLtData [Level] : LtData where\n\ninstance globalLeData [Level] : LeData where\n\nomit [Params] in\n", "theoremStatement": "theorem heq_funext {\u03b1 : Sort _} {\u03b2 \u03b3 : \u03b1 \u2192 Sort _} {f : (x : \u03b1) \u2192 \u03b2 x} {g : (x : \u03b1) \u2192 \u03b3 x}\n    (h : \u2200 x, HEq (f x) (g x)) : HEq f g ", "theoremName": "ConNF.heq_funext", "fileCreated": {"commit": "6fdc87c6b30b73931407a372f1430ecf0fef7601", "date": "2024-12-03"}, "theoremCreated": {"commit": "e409f3d0cd939e7218c3f39dcf3493c4b6e0b821", "date": "2024-11-29"}, "file": "ConNF/ConNF/Model/Externalise.lean", "module": "ConNF.Model.Externalise", "jsonFile": "ConNF.Model.Externalise.jsonl", "positionMetadata": {"lineInFile": 39, "tokenPositionInFile": 803, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 14}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  cases funext \u03bb x \u21a6 type_eq_of_heq (h x)\n  simp only [heq_eq_eq] at h \u22a2\n  exact funext h", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 95}}
{"srcContext": "import ConNF.Model.TTT\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\nnamespace TSet\n\ntheorem exists_inter (x y : TSet \u03b1) :\n    \u2203 w : TSet \u03b1, \u2200 z : TSet \u03b2, z \u2208[h\u03b2] w \u2194 z \u2208[h\u03b2] x \u2227 z \u2208[h\u03b2] y := by\n  refine exists_of_symmetric {z | z \u2208[h\u03b2] x \u2227 z \u2208[h\u03b2] y} h\u03b2 ?_\n  obtain \u27e8S, hS\u27e9 := symmetric x h\u03b2\n  obtain \u27e8T, hT\u27e9 := symmetric y h\u03b2\n  use S + T\n  intro \u03c1 h\u03c1\n  specialize hS \u03c1 (smul_eq_of_le Support.le_add_right h\u03c1)\n  specialize hT \u03c1 (smul_eq_of_le Support.le_add_left h\u03c1)\n  simp [Set.ext_iff, Set.mem_smul_set_iff_inv_smul_mem] at hS hT \u22a2\n  aesop\n\ntheorem exists_compl (x : TSet \u03b1) :\n    \u2203 y : TSet \u03b1, \u2200 z : TSet \u03b2, z \u2208[h\u03b2] y \u2194 \u00acz \u2208[h\u03b2] x := by\n  refine exists_of_symmetric {z | \u00acz \u2208[h\u03b2] x} h\u03b2 ?_\n  obtain \u27e8S, hS\u27e9 := symmetric x h\u03b2\n  use S\n  intro \u03c1 h\u03c1\n  specialize hS \u03c1 h\u03c1\n  simp [Set.ext_iff, Set.mem_smul_set_iff_inv_smul_mem] at hS \u22a2\n  aesop\n\ntheorem exists_up (x y : TSet \u03b2) :\n    \u2203 w : TSet \u03b1, \u2200 z : TSet \u03b2, z \u2208[h\u03b2] w \u2194 z = x \u2228 z = y := by\n  refine exists_of_symmetric {x, y} h\u03b2 ?_\n  obtain \u27e8S, hS\u27e9 := exists_support x\n  obtain \u27e8T, hT\u27e9 := exists_support y\n  use (S + T) \u2197 h\u03b2\n  intro \u03c1 h\u03c1\n  rw [Support.smul_scoderiv, Support.scoderiv_inj, \u2190 allPermSderiv_forget'] at h\u03c1\n  specialize hS (\u03c1 \u2198 h\u03b2) (smul_eq_of_le Support.le_add_right h\u03c1)\n  specialize hT (\u03c1 \u2198 h\u03b2) (smul_eq_of_le Support.le_add_left h\u03c1)\n  simp only [Set.smul_set_def, Set.image, Set.mem_insert_iff, Set.mem_singleton_iff,\n    exists_eq_or_imp, hS, exists_eq_left, hT]\n  ext z\n  rw [Set.mem_insert_iff, Set.mem_singleton_iff, Set.mem_setOf_eq]\n  aesop\n\n/-- The unordered pair. -/\ndef up (x y : TSet \u03b2) : TSet \u03b1 :=\n  (exists_up h\u03b2 x y).choose\n\n@[simp]\ntheorem mem_up_iff (x y z : TSet \u03b2) :\n    z \u2208[h\u03b2] up h\u03b2 x y \u2194 z = x \u2228 z = y :=\n  (exists_up h\u03b2 x y).choose_spec z\n\n/-- The Kuratowski ordered pair. -/\ndef op (x y : TSet \u03b3) : TSet \u03b1 :=\n  up h\u03b2 (singleton h\u03b3 x) (up h\u03b3 x y)\n\ntheorem up_injective {x y z w : TSet \u03b2} (h : up h\u03b2 x y = up h\u03b2 z w) :\n    (x = z \u2227 y = w) \u2228 (x = w \u2227 y = z) := by\n  have h\u2081 := mem_up_iff h\u03b2 x y z\n  have h\u2082 := mem_up_iff h\u03b2 x y w\n  have h\u2083 := mem_up_iff h\u03b2 z w x\n  have h\u2084 := mem_up_iff h\u03b2 z w y\n  rw [h, mem_up_iff] at h\u2081 h\u2082\n  rw [\u2190 h, mem_up_iff] at h\u2083 h\u2084\n  aesop\n\n@[simp]\ntheorem up_inj (x y z w : TSet \u03b2) :\n    up h\u03b2 x y = up h\u03b2 z w \u2194 (x = z \u2227 y = w) \u2228 (x = w \u2227 y = z) := by\n  constructor\n  \u00b7 exact up_injective h\u03b2\n  \u00b7 rintro (\u27e8rfl, rfl\u27e9 | \u27e8rfl, rfl\u27e9)\n    \u00b7 rfl\n    \u00b7 apply tSet_ext' h\u03b2\n      aesop\n\n@[simp]\ntheorem up_self {x : TSet \u03b2} :\n    up h\u03b2 x x = singleton h\u03b2 x := by\n  apply tSet_ext' h\u03b2\n  aesop\n\n@[simp]\ntheorem up_eq_singleton_iff (x y z : TSet \u03b2) :\n    up h\u03b2 x y = singleton h\u03b2 z \u2194 x = z \u2227 y = z := by\n  constructor\n  \u00b7 intro h\n    have h\u2081 := typedMem_singleton_iff' h\u03b2 z x\n    have h\u2082 := typedMem_singleton_iff' h\u03b2 z y\n    rw [\u2190 h, mem_up_iff] at h\u2081 h\u2082\n    aesop\n  \u00b7 rintro \u27e8rfl, rfl\u27e9\n    rw [up_self]\n\n@[simp]\ntheorem singleton_eq_up_iff (x y z : TSet \u03b2) :\n    singleton h\u03b2 z = up h\u03b2 x y \u2194 x = z \u2227 y = z := by\n  rw [\u2190 up_eq_singleton_iff h\u03b2 x y z, eq_comm]\n\ntheorem op_injective {x y z w : TSet \u03b3} (h : op h\u03b2 h\u03b3 x y = op h\u03b2 h\u03b3 z w) :\n    x = z \u2227 y = w := by\n  rw [op, op] at h\n  simp only [up_inj, singleton_inj, singleton_eq_up_iff, up_eq_singleton_iff] at h\n  obtain (\u27e8rfl, \u27e8h, rfl\u27e9 | \u27e8rfl, rfl\u27e9\u27e9 | \u27e8\u27e8rfl, rfl\u27e9, \u27e8h, rfl\u27e9\u27e9) := h <;> simp only [and_self]\n\n@[simp]\ntheorem op_inj (x y z w : TSet \u03b3) :\n    op h\u03b2 h\u03b3 x y = op h\u03b2 h\u03b3 z w \u2194 x = z \u2227 y = w := by\n  constructor\n  \u00b7 exact op_injective h\u03b2 h\u03b3\n  \u00b7 rintro \u27e8rfl, rfl\u27e9\n    rfl\n\n@[simp]\ntheorem op_eq_singleton_iff (x y : TSet \u03b3) (z : TSet \u03b2) :\n    op h\u03b2 h\u03b3 x y = singleton h\u03b2 z \u2194 singleton h\u03b3 x = z \u2227 singleton h\u03b3 y = z := by\n  rw [op, up_eq_singleton_iff, and_congr_right_iff]\n  rintro rfl\n  simp only [up_eq_singleton_iff, true_and, singleton_inj]\n\n@[simp]\ntheorem smul_up (x y : TSet \u03b2) (\u03c1 : AllPerm \u03b1) :\n    \u03c1 \u2022 up h\u03b2 x y = up h\u03b2 (\u03c1 \u2198 h\u03b2 \u2022 x) (\u03c1 \u2198 h\u03b2 \u2022 y) := by\n  apply tSet_ext' h\u03b2\n  aesop\n\n@[simp]\ntheorem smul_op (x y : TSet \u03b3) (\u03c1 : AllPerm \u03b1) :\n    \u03c1 \u2022 op h\u03b2 h\u03b3 x y = op h\u03b2 h\u03b3 (\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2022 x) (\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2022 y) := by\n  apply tSet_ext' h\u03b2\n  simp only [op, smul_up, smul_singleton, mem_up_iff, implies_true]\n\ntheorem exists_singletonImage (x : TSet \u03b2) :\n    \u2203 y : TSet \u03b1, \u2200 z w,\n    op h\u03b3 h\u03b4 (singleton h\u03b5 z) (singleton h\u03b5 w) \u2208[h\u03b2] y \u2194 op h\u03b4 h\u03b5 z w \u2208[h\u03b3] x := by\n  have := exists_of_symmetric {u | \u2203 z w : TSet \u03b5, op h\u03b4 h\u03b5 z w \u2208[h\u03b3] x \u2227\n      u = op h\u03b3 h\u03b4 (singleton h\u03b5 z) (singleton h\u03b5 w)} h\u03b2 ?_\n  \u00b7 obtain \u27e8y, hy\u27e9 := this\n    use y\n    intro z w\n    rw [hy]\n    simp only [Set.mem_setOf_eq, op_inj, singleton_inj, exists_eq_right_right', exists_eq_right']\n  \u00b7 obtain \u27e8S, hS\u27e9 := exists_support x\n    use S \u2197 h\u03b2\n    intro \u03c1 h\u03c1\n    rw [Support.smul_scoderiv, Support.scoderiv_inj, \u2190 allPermSderiv_forget'] at h\u03c1\n    specialize hS (\u03c1 \u2198 h\u03b2) h\u03c1\n    ext z\n    constructor\n    \u00b7 rintro \u27e8_, \u27e8z, w, hab, rfl\u27e9, rfl\u27e9\n      refine \u27e8\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2022 z, \u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2022 w, ?_, ?_\u27e9\n      \u00b7 rwa [\u2190 hS, mem_smul_iff', smul_op, allPerm_inv_sderiv', allPerm_inv_sderiv',\n          allPerm_inv_sderiv', inv_smul_smul, inv_smul_smul]\n      \u00b7 simp only [smul_op, smul_singleton]\n    \u00b7 rintro \u27e8z, w, hab, rfl\u27e9\n      refine \u27e8\u03c1\u207b\u00b9 \u2198 h\u03b2 \u2022 op h\u03b3 h\u03b4 (singleton h\u03b5 z) (singleton h\u03b5 w), ?_, ?_\u27e9\n      \u00b7 simp only [allPerm_inv_sderiv', smul_op, smul_singleton, Set.mem_setOf_eq, op_inj,\n          singleton_inj, exists_eq_right_right', exists_eq_right']\n        rw [smul_eq_iff_eq_inv_smul] at hS\n        rw [hS]\n        simp only [mem_smul_iff', inv_inv, smul_op, smul_inv_smul]\n        exact hab\n      \u00b7 simp only [allPerm_inv_sderiv', smul_inv_smul]\n\ntheorem exists_insertion2 (x : TSet \u03b3) :\n    \u2203 y : TSet \u03b1, \u2200 a b c, op h\u03b3 h\u03b4 (singleton h\u03b5 (singleton h\u03b6 a)) (op h\u03b5 h\u03b6 b c) \u2208[h\u03b2] y \u2194\n    op h\u03b5 h\u03b6 a c \u2208[h\u03b4] x := by\n  have := exists_of_symmetric {u | \u2203 a b c : TSet \u03b6, op h\u03b5 h\u03b6 a c \u2208[h\u03b4] x \u2227\n      u = op h\u03b3 h\u03b4 (singleton h\u03b5 (singleton h\u03b6 a)) (op h\u03b5 h\u03b6 b c)} h\u03b2 ?_\n  \u00b7 obtain \u27e8y, hy\u27e9 := this\n    use y\n    intro a b c\n    rw [hy]\n    constructor\n    \u00b7 rintro \u27e8a', b', c', h\u2081, h\u2082\u27e9\n      simp only [op_inj, singleton_inj] at h\u2082\n      obtain \u27e8rfl, rfl, rfl\u27e9 := h\u2082\n      exact h\u2081\n    \u00b7 intro h\n      exact \u27e8a, b, c, h, rfl\u27e9\n  \u00b7 obtain \u27e8S, hS\u27e9 := exists_support x\n    use S \u2197 h\u03b3 \u2197 h\u03b2\n    intro \u03c1 h\u03c1\n    simp only [Support.smul_scoderiv, Support.scoderiv_inj, \u2190 allPermSderiv_forget'] at h\u03c1\n    specialize hS (\u03c1 \u2198 h\u03b2 \u2198 h\u03b3) h\u03c1\n    ext z\n    constructor\n    \u00b7 rintro \u27e8_, \u27e8a, b, c, hx, rfl\u27e9, rfl\u27e9\n      refine \u27e8\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 a, \u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 b,\n        \u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 c, ?_, ?_\u27e9\n      \u00b7 rw [\u2190 hS]\n        simp only [mem_smul_iff', allPerm_inv_sderiv', smul_op, inv_smul_smul]\n        exact hx\n      \u00b7 simp only [smul_op, smul_singleton]\n    \u00b7 rintro \u27e8a, b, c, hx, rfl\u27e9\n      rw [Set.mem_smul_set_iff_inv_smul_mem]\n      refine \u27e8\u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 a, \u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 b,\n        \u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 c, ?_, ?_\u27e9\n      \u00b7 rw [smul_eq_iff_eq_inv_smul] at hS\n        rw [hS, mem_smul_iff']\n        simp only [inv_inv, allPerm_inv_sderiv', smul_op, smul_inv_smul]\n        exact hx\n      \u00b7 simp only [smul_op, allPerm_inv_sderiv', smul_singleton]\n\n", "theoremStatement": "theorem exists_insertion3 (x : TSet \u03b3) :\n    \u2203 y : TSet \u03b1, \u2200 a b c, op h\u03b3 h\u03b4 (singleton h\u03b5 (singleton h\u03b6 a)) (op h\u03b5 h\u03b6 b c) \u2208[h\u03b2] y \u2194\n    op h\u03b5 h\u03b6 a b \u2208[h\u03b4] x ", "theoremName": "ConNF.TSet.exists_insertion3", "fileCreated": {"commit": "f804f5c71cfaa98223fc227dd822801e8bf77004", "date": "2024-03-30"}, "theoremCreated": {"commit": "f7c233c7f7fd9d8b74595bbfa2bbbd49d538ef59", "date": "2024-12-02"}, "file": "ConNF/ConNF/Model/Hailperin.lean", "module": "ConNF.Model.Hailperin", "jsonFile": "ConNF.Model.Hailperin.jsonl", "positionMetadata": {"lineInFile": 224, "tokenPositionInFile": 7357, "theoremPositionInFile": 18}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 44, "numPremises": 102}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  have := exists_of_symmetric {u | \u2203 a b c : TSet \u03b6, op h\u03b5 h\u03b6 a b \u2208[h\u03b4] x \u2227\n      u = op h\u03b3 h\u03b4 (singleton h\u03b5 (singleton h\u03b6 a)) (op h\u03b5 h\u03b6 b c)} h\u03b2 ?_\n  \u00b7 obtain \u27e8y, hy\u27e9 := this\n    use y\n    intro a b c\n    rw [hy]\n    constructor\n    \u00b7 rintro \u27e8a', b', c', h\u2081, h\u2082\u27e9\n      simp only [op_inj, singleton_inj] at h\u2082\n      obtain \u27e8rfl, rfl, rfl\u27e9 := h\u2082\n      exact h\u2081\n    \u00b7 intro h\n      exact \u27e8a, b, c, h, rfl\u27e9\n  \u00b7 obtain \u27e8S, hS\u27e9 := exists_support x\n    use S \u2197 h\u03b3 \u2197 h\u03b2\n    intro \u03c1 h\u03c1\n    simp only [Support.smul_scoderiv, Support.scoderiv_inj, \u2190 allPermSderiv_forget'] at h\u03c1\n    specialize hS (\u03c1 \u2198 h\u03b2 \u2198 h\u03b3) h\u03c1\n    ext z\n    constructor\n    \u00b7 rintro \u27e8_, \u27e8a, b, c, hx, rfl\u27e9, rfl\u27e9\n      refine \u27e8\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 a, \u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 b,\n        \u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 c, ?_, ?_\u27e9\n      \u00b7 rw [\u2190 hS]\n        simp only [mem_smul_iff', allPerm_inv_sderiv', smul_op, inv_smul_smul]\n        exact hx\n      \u00b7 simp only [smul_op, smul_singleton]\n    \u00b7 rintro \u27e8a, b, c, hx, rfl\u27e9\n      rw [Set.mem_smul_set_iff_inv_smul_mem]\n      refine \u27e8\u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 a, \u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 b,\n        \u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 c, ?_, ?_\u27e9\n      \u00b7 rw [smul_eq_iff_eq_inv_smul] at hS\n        rw [hS, mem_smul_iff']\n        simp only [inv_inv, allPerm_inv_sderiv', smul_op, smul_inv_smul]\n        exact hx\n      \u00b7 simp only [smul_op, allPerm_inv_sderiv', smul_singleton]", "proofType": "tactic", "proofLengthLines": 36, "proofLengthTokens": 1399}}
{"srcContext": "import ConNF.Background.ReflTransGen\nimport ConNF.FOA.Inflexible\n\n/-!\n# Strong supports\n\nIn this file, we define strong supports.\n\n## Main declarations\n\n* `ConNF.Support.Strong`: The property that a support is strong.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\nopen scoped symmDiff\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b2 : TypeIndex}\n\nstructure BaseSupport.Closed (S : BaseSupport) : Prop where\n  interference_subset {N\u2081 N\u2082 : NearLitter} :\n    N\u2081 \u2208 S\u1d3a \u2192 N\u2082 \u2208 S\u1d3a \u2192 \u2200 a \u2208 interference N\u2081 N\u2082, a \u2208 S\u1d2c\n\nnamespace Support\n\nvariable [Level] [CoherentData] [LeLevel \u03b2]\n\nstructure PreStrong (S : Support \u03b2) : Prop where\n  support_le {A : \u03b2 \u219d \u22a5} {N : NearLitter} (h : N \u2208 (S \u21d8. A)\u1d3a)\n    (P : InflexiblePath \u03b2) (t : Tangle P.\u03b4)\n    (hA : A = P.A \u2198 P.h\u03b5 \u2198.) (ht : N\u1d38 = fuzz P.h\u03b4\u03b5 t) :\n    t.support \u2264 S \u21d8 (P.A \u2198 P.h\u03b4)\n\nstructure Closed (S : Support \u03b2) : Prop where\n  closed : \u2200 A, (S \u21d8. A).Closed\n\nstructure Strong (S : Support \u03b2) extends S.PreStrong, S.Closed : Prop\n\ntheorem PreStrong.smul {S : Support \u03b2} (hS : S.PreStrong) (\u03c1 : AllPerm \u03b2) : (\u03c1\u1d41 \u2022 S).PreStrong := by\n  constructor\n  intro A N hN P t hA ht\n  rw [smul_derivBot, BaseSupport.smul_nearLitters, Enumeration.mem_smul] at hN\n  have := hS.support_le hN P (\u03c1\u207b\u00b9 \u21d8 P.A \u2198 P.h\u03b4 \u2022 t) hA ?_\n  \u00b7 convert smul_le_smul this (\u03c1\u1d41 \u21d8 P.A \u2198 P.h\u03b4) using 1\n    \u00b7 rw [Tangle.smul_support, smul_smul,\n        allPermSderiv_forget, allPermDeriv_forget, allPermForget_inv,\n        Tree.inv_deriv, Tree.inv_sderiv, mul_inv_cancel, one_smul]\n    \u00b7 ext B : 1\n      rw [smul_derivBot, Tree.sderiv_apply, Tree.deriv_apply, Path.deriv_scoderiv]\n      rfl\n  \u00b7 rw [\u2190 smul_fuzz P.h\u03b4 P.h\u03b5 P.h\u03b4\u03b5, allPermDeriv_forget, allPermForget_inv,\n      BasePerm.smul_nearLitter_litter, \u2190 Tree.inv_apply, hA, ht]\n    rfl\n\ntheorem Closed.smul {S : Support \u03b2} (hS : S.Closed) (\u03c1 : AllPerm \u03b2) : (\u03c1\u1d41 \u2022 S).Closed := by\n  constructor\n  intro A\n  constructor\n  intro N\u2081 N\u2082 h\u2081 h\u2082\n  simp only [smul_derivBot, BaseSupport.smul_nearLitters, BaseSupport.smul_atoms,\n    Enumeration.mem_smul] at h\u2081 h\u2082 \u22a2\n  intro a ha\n  apply (hS.closed A).interference_subset h\u2081 h\u2082\n  rwa [\u2190 BasePerm.smul_interference, Set.smul_mem_smul_set_iff]\n\ntheorem Strong.smul {S : Support \u03b2} (hS : S.Strong) (\u03c1 : AllPerm \u03b2) : (\u03c1\u1d41 \u2022 S).Strong :=\n  \u27e8hS.toPreStrong.smul \u03c1, hS.toClosed.smul \u03c1\u27e9\n\ntheorem PreStrong.add {S T : Support \u03b2} (hS : S.PreStrong) (hT : T.PreStrong) :\n    (S + T).PreStrong := by\n  constructor\n  intro A N hN P t hA ht\n  simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff] at hN\n  obtain hN | hN := hN\n  \u00b7 intro B\n    simp only [deriv_derivBot, add_derivBot]\n    exact (hS.support_le hN P t hA ht B).trans (BaseSupport.le_add_right)\n  \u00b7 intro B\n    simp only [deriv_derivBot, add_derivBot]\n    exact (hT.support_le hN P t hA ht B).trans (BaseSupport.le_add_left)\n\nomit [Level] [CoherentData] [LeLevel \u03b2] in\n", "theoremStatement": "theorem Closed.scoderiv {\u03b3 : TypeIndex} {S : Support \u03b3} (hS : S.Closed) (h\u03b3 : \u03b3 < \u03b2) :\n    (S \u2197 h\u03b3).Closed ", "theoremName": "ConNF.Support.Closed.scoderiv", "fileCreated": {"commit": "8896e416a16c39e1fe487b5fc7c78bc20c4e182b", "date": "2024-12-03"}, "theoremCreated": {"commit": "6709914ae7f5cd3e2bb24b413e09aa844554d234", "date": "2024-11-30"}, "file": "ConNF/ConNF/Strong/Strong.lean", "module": "ConNF.Strong.Strong", "jsonFile": "ConNF.Strong.Strong.jsonl", "positionMetadata": {"lineInFile": 87, "tokenPositionInFile": 2843, "theoremPositionInFile": 4}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 5, "repositoryPremises": true, "numRepositoryPremises": 35, "numPremises": 75}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  constructor\n  intro A\n  constructor\n  intro N\u2081 N\u2082 hN\u2081 hN\u2082 a ha\n  obtain \u27e8i, \u27e8B, N\u2081\u27e9, hi, hi'\u27e9 := hN\u2081\n  cases hi'\n  obtain \u27e8j, \u27e8C, N\u2082\u27e9, hj, hj'\u27e9 := hN\u2082\n  simp only [Prod.mk.injEq, Path.deriv_right_inj] at hj'\n  cases hj'.1\n  cases hj'.2\n  simp only\n  obtain \u27e8k, hk\u27e9 := (hS.closed B).interference_subset \u27e8i, hi\u27e9 \u27e8j, hj\u27e9 a ha\n  exact \u27e8k, \u27e8B, a\u27e9, hk, rfl\u27e9", "proofType": "tactic", "proofLengthLines": 13, "proofLengthTokens": 359}}
{"srcContext": "import ConNF.Model.Result\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal ConNF.TSet\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\ndef union (x y : TSet \u03b1) : TSet \u03b1 :=\n  (x\u1d9c' \u2293' y\u1d9c')\u1d9c'\n\nnotation:68 x:68 \" \u2294[\" h \"] \" y:68 => _root_.ConNF.union h x y\nnotation:68 x:68 \" \u2294' \" y:68 => x \u2294[by assumption] y\n\n@[simp]\ntheorem mem_union_iff (x y : TSet \u03b1) :\n    \u2200 z : TSet \u03b2, z \u2208' x \u2294' y \u2194 z \u2208' x \u2228 z \u2208' y := by\n  rw [union]\n  intro z\n  rw [mem_compl_iff, mem_inter_iff, mem_compl_iff, mem_compl_iff, or_iff_not_and_not]\n\ndef higherIndex (\u03b1 : \u039b) : \u039b :=\n  (exists_gt \u03b1).choose\n\ntheorem lt_higherIndex {\u03b1 : \u039b} :\n    (\u03b1 : TypeIndex) < higherIndex \u03b1 :=\n  WithBot.coe_lt_coe.mpr (exists_gt \u03b1).choose_spec\n\ntheorem tSet_nonempty (h : \u2203 \u03b2 : \u039b, (\u03b2 : TypeIndex) < \u03b1) : Nonempty (TSet \u03b1) := by\n  obtain \u27e8\u03b1', h\u03b1\u27e9 := h\n  constructor\n  apply typeLower lt_higherIndex lt_higherIndex lt_higherIndex h\u03b1\n  apply cardinalOne lt_higherIndex lt_higherIndex\n\ndef empty : TSet \u03b1 :=\n  (tSet_nonempty \u27e8\u03b2, h\u03b2\u27e9).some \u2293' (tSet_nonempty \u27e8\u03b2, h\u03b2\u27e9).some\u1d9c'\n\n@[simp]\ntheorem mem_empty_iff :\n    \u2200 x : TSet \u03b2, \u00acx \u2208' empty h\u03b2 := by\n  intro x\n  rw [empty, mem_inter_iff, mem_compl_iff]\n  exact and_not_self\n\ndef univ : TSet \u03b1 :=\n  (empty h\u03b2)\u1d9c'\n\n@[simp]\ntheorem mem_univ_iff :\n    \u2200 x : TSet \u03b2, x \u2208' univ h\u03b2 := by\n  intro x\n  simp only [univ, mem_compl_iff, mem_empty_iff, not_false_eq_true]\n\n/-- The set of all ordered pairs. -/\ndef orderedPairs : TSet \u03b1 :=\n  vCross h\u03b2 h\u03b3 h\u03b4 (univ h\u03b4)\n\n@[simp]\ntheorem mem_orderedPairs_iff (x : TSet \u03b2) :\n    x \u2208' orderedPairs h\u03b2 h\u03b3 h\u03b4 \u2194 \u2203 a b, x = \u27e8a, b\u27e9' := by\n  simp only [orderedPairs, vCross_spec, mem_univ_iff, and_true]\n\ndef converse (x : TSet \u03b1) : TSet \u03b1 :=\n  converse' h\u03b2 h\u03b3 h\u03b4 x \u2293' orderedPairs h\u03b2 h\u03b3 h\u03b4\n\n@[simp]\ntheorem op_mem_converse_iff (x : TSet \u03b1) :\n    \u2200 a b, \u27e8a, b\u27e9' \u2208' converse h\u03b2 h\u03b3 h\u03b4 x \u2194 \u27e8b, a\u27e9' \u2208' x := by\n  intro a b\n  simp only [converse, mem_inter_iff, converse'_spec, mem_orderedPairs_iff, op_inj, exists_and_left,\n    exists_eq', and_true]\n\ndef cross (x y : TSet \u03b3) : TSet \u03b1 :=\n  converse h\u03b2 h\u03b3 h\u03b4 (vCross h\u03b2 h\u03b3 h\u03b4 x) \u2293' vCross h\u03b2 h\u03b3 h\u03b4 y\n\n@[simp]\ntheorem mem_cross_iff (x y : TSet \u03b3) :\n    \u2200 a, a \u2208' cross h\u03b2 h\u03b3 h\u03b4 x y \u2194 \u2203 b c, a = \u27e8b, c\u27e9' \u2227 b \u2208' x \u2227 c \u2208' y := by\n  intro a\n  rw [cross, mem_inter_iff, vCross_spec]\n  constructor\n  \u00b7 rintro \u27e8h\u2081, b, c, rfl, h\u2082\u27e9\n    simp only [op_mem_converse_iff, vCross_spec, op_inj] at h\u2081\n    obtain \u27e8b', c', \u27e8rfl, rfl\u27e9, h\u2081\u27e9 := h\u2081\n    exact \u27e8b, c, rfl, h\u2081, h\u2082\u27e9\n  \u00b7 rintro \u27e8b, c, rfl, h\u2081, h\u2082\u27e9\n    simp only [op_mem_converse_iff, vCross_spec, op_inj]\n    exact \u27e8\u27e8c, b, \u27e8rfl, rfl\u27e9, h\u2081\u27e9, \u27e8b, c, \u27e8rfl, rfl\u27e9, h\u2082\u27e9\u27e9\n\ndef singletonImage (x : TSet \u03b2) : TSet \u03b1 :=\n  singletonImage' h\u03b2 h\u03b3 h\u03b4 h\u03b5 x \u2293' (cross h\u03b2 h\u03b3 h\u03b4 (cardinalOne h\u03b4 h\u03b5) (cardinalOne h\u03b4 h\u03b5))\n\n@[simp]\ntheorem singletonImage_spec (x : TSet \u03b2) :\n    \u2200 z w,\n    \u27e8 {z}', {w}' \u27e9' \u2208' singletonImage h\u03b2 h\u03b3 h\u03b4 h\u03b5 x \u2194 \u27e8z, w\u27e9' \u2208' x := by\n  intro z w\n  rw [singletonImage, mem_inter_iff, singletonImage'_spec, and_iff_left_iff_imp]\n  intro hzw\n  rw [mem_cross_iff]\n  refine \u27e8{z}', {w}', rfl, ?_\u27e9\n  simp only [mem_cardinalOne_iff, singleton_inj, exists_eq', and_self]\n\ntheorem exists_of_mem_singletonImage {x : TSet \u03b2} {z w : TSet \u03b4}\n    (h : \u27e8z, w\u27e9' \u2208' singletonImage h\u03b2 h\u03b3 h\u03b4 h\u03b5 x) :\n    \u2203 a b, z = {a}' \u2227 w = {b}' := by\n  simp only [singletonImage, mem_inter_iff, mem_cross_iff, op_inj, mem_cardinalOne_iff] at h\n  obtain \u27e8-, _, _, \u27e8rfl, rfl\u27e9, \u27e8a, rfl\u27e9, \u27e8b, rfl\u27e9\u27e9 := h\n  exact \u27e8a, b, rfl, rfl\u27e9\n\n/-- Turn a model element encoding a relation into an actual relation. -/\ndef ExternalRel (r : TSet \u03b1) : Rel (TSet \u03b4) (TSet \u03b4) :=\n  \u03bb x y \u21a6 \u27e8x, y\u27e9' \u2208' r\n\n@[simp]\ntheorem externalRel_converse (r : TSet \u03b1) :\n    ExternalRel h\u03b2 h\u03b3 h\u03b4 (converse h\u03b2 h\u03b3 h\u03b4 r) = (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).inv := by\n  ext\n  simp only [ExternalRel, op_mem_converse_iff, Rel.inv_apply]\n\n/-- The codomain of a relation. -/\ndef codom (r : TSet \u03b1) : TSet \u03b3 :=\n  (typeLower lt_higherIndex h\u03b2 h\u03b3 h\u03b4 (singletonImage lt_higherIndex h\u03b2 h\u03b3 h\u03b4 r)\u1d9c[lt_higherIndex])\u1d9c'\n\n@[simp]\ntheorem mem_codom_iff (r : TSet \u03b1) (x : TSet \u03b4) :\n    x \u2208' codom h\u03b2 h\u03b3 h\u03b4 r \u2194 x \u2208 (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).codom := by\n  simp only [codom, mem_compl_iff, mem_typeLower_iff, not_forall, not_not]\n  constructor\n  \u00b7 rintro \u27e8y, hy\u27e9\n    obtain \u27e8a, b, rfl, hb\u27e9 := exists_of_mem_singletonImage lt_higherIndex h\u03b2 h\u03b3 h\u03b4 hy\n    rw [singleton_inj] at hb\n    subst hb\n    rw [singletonImage_spec] at hy\n    exact \u27e8a, hy\u27e9\n  \u00b7 rintro \u27e8a, ha\u27e9\n    use {a}'\n    rw [singletonImage_spec]\n    exact ha\n\n/-- The domain of a relation. -/\ndef dom (r : TSet \u03b1) : TSet \u03b3 :=\n  codom h\u03b2 h\u03b3 h\u03b4 (converse h\u03b2 h\u03b3 h\u03b4 r)\n\n@[simp]\ntheorem mem_dom_iff (r : TSet \u03b1) (x : TSet \u03b4) :\n    x \u2208' dom h\u03b2 h\u03b3 h\u03b4 r \u2194 x \u2208 (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).dom := by\n  rw [dom, mem_codom_iff, externalRel_converse, Rel.inv_codom]\n\n/-- The field of a relation. -/\ndef field (r : TSet \u03b1) : TSet \u03b3 :=\n  dom h\u03b2 h\u03b3 h\u03b4 r \u2294' codom h\u03b2 h\u03b3 h\u03b4 r\n\n@[simp]\ntheorem mem_field_iff (r : TSet \u03b1) (x : TSet \u03b4) :\n    x \u2208' field h\u03b2 h\u03b3 h\u03b4 r \u2194 x \u2208 (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).field := by\n  rw [field, mem_union_iff, mem_dom_iff, mem_codom_iff, Rel.field, Set.mem_union]\n\ndef subset : TSet \u03b1 :=\n  subset' h\u03b2 h\u03b3 h\u03b4 h\u03b5 \u2293' orderedPairs h\u03b2 h\u03b3 h\u03b4\n\n@[simp]\ntheorem subset_spec :\n    \u2200 a b, \u27e8a, b\u27e9' \u2208' subset h\u03b2 h\u03b3 h\u03b4 h\u03b5 \u2194 a \u2286[TSet \u03b5] b := by\n  intro a b\n  simp only [subset, mem_inter_iff, subset'_spec, mem_orderedPairs_iff, op_inj, exists_and_left,\n    exists_eq', and_true]\n\ndef membership : TSet \u03b1 :=\n  subset h\u03b2 h\u03b3 h\u03b4 h\u03b5 \u2293' cross h\u03b2 h\u03b3 h\u03b4 (cardinalOne h\u03b4 h\u03b5) (univ h\u03b4)\n\n@[simp]\ntheorem membership_spec :\n    \u2200 a b, \u27e8{a}', b\u27e9' \u2208' membership h\u03b2 h\u03b3 h\u03b4 h\u03b5 \u2194 a \u2208' b := by\n  intro a b\n  rw [membership, mem_inter_iff, subset_spec]\n  simp only [mem_cross_iff, op_inj, mem_cardinalOne_iff, mem_univ_iff, and_true, exists_and_right,\n    exists_and_left, exists_eq', exists_eq_left', singleton_inj]\n  constructor\n  \u00b7 intro h\n    exact h a ((typedMem_singleton_iff' h\u03b5 a a).mpr rfl)\n  \u00b7 intro h c hc\n    simp only [typedMem_singleton_iff'] at hc\n    cases hc\n    exact h\n\ndef powerset (x : TSet \u03b2) : TSet \u03b1 :=\n  dom lt_higherIndex lt_higherIndex h\u03b2\n    (subset lt_higherIndex lt_higherIndex h\u03b2 h\u03b3 \u2293[lt_higherIndex]\n      vCross lt_higherIndex lt_higherIndex h\u03b2 {x}')\n\n@[simp]\ntheorem mem_powerset_iff (x y : TSet \u03b2) :\n    x \u2208' powerset h\u03b2 h\u03b3 y \u2194 x \u2286[TSet \u03b3] y := by\n  rw [powerset, mem_dom_iff]\n  constructor\n  \u00b7 rintro \u27e8z, h\u27e9\n    simp only [ExternalRel, mem_inter_iff, subset_spec, vCross_spec, op_inj,\n      typedMem_singleton_iff', exists_eq_right, exists_and_right, exists_eq', true_and] at h\n    cases h.2\n    exact h.1\n  \u00b7 intro h\n    refine \u27e8y, ?_\u27e9\n    simp only [ExternalRel, mem_inter_iff, subset_spec, h, vCross_spec, op_inj,\n      typedMem_singleton_iff', exists_eq_right, and_true, exists_eq', and_self]\n\n/-- The set `\u03b9\u00b2''x = {{{a}} | a \u2208 x}`. -/\ndef doubleSingleton (x : TSet \u03b3) : TSet \u03b1 :=\n  cross h\u03b2 h\u03b3 h\u03b4 x x \u2293' cardinalOne h\u03b2 h\u03b3\n\n@[simp]\ntheorem mem_doubleSingleton_iff (x : TSet \u03b3) :\n    \u2200 y : TSet \u03b2, y \u2208' doubleSingleton h\u03b2 h\u03b3 h\u03b4 x \u2194\n    \u2203 z : TSet \u03b4, z \u2208' x \u2227 y = { {z}' }' := by\n  intro y\n  rw [doubleSingleton, mem_inter_iff, mem_cross_iff, mem_cardinalOne_iff]\n  constructor\n  \u00b7 rintro \u27e8\u27e8b, c, h\u2081, h\u2082, h\u2083\u27e9, \u27e8a, rfl\u27e9\u27e9\n    obtain \u27e8hbc, rfl\u27e9 := (op_eq_singleton_iff _ _ _ _ _).mp h\u2081.symm\n    exact \u27e8c, h\u2083, rfl\u27e9\n  \u00b7 rintro \u27e8z, h, rfl\u27e9\n    constructor\n    \u00b7 refine \u27e8z, z, ?_\u27e9\n      rw [eq_comm, op_eq_singleton_iff]\n      tauto\n    \u00b7 exact \u27e8_, rfl\u27e9\n\n/-- The union of a set of *singletons*: `\u03b9\u207b\u00b9''x = {a | {a} \u2208 x}`. -/\ndef singletonUnion (x : TSet \u03b1) : TSet \u03b2 :=\n  typeLower lt_higherIndex lt_higherIndex h\u03b2 h\u03b3\n    (vCross lt_higherIndex lt_higherIndex h\u03b2 x)\n\n@[simp]\ntheorem mem_singletonUnion_iff (x : TSet \u03b1) :\n    \u2200 y : TSet \u03b3, y \u2208' singletonUnion h\u03b2 h\u03b3 x \u2194 {y}' \u2208' x := by\n  intro y\n  simp only [singletonUnion, mem_typeLower_iff, vCross_spec, op_inj]\n  constructor\n  \u00b7 intro h\n    obtain \u27e8a, b, \u27e8rfl, rfl\u27e9, hy\u27e9 := h {y}'\n    exact hy\n  \u00b7 intro h b\n    exact \u27e8b, _, \u27e8rfl, rfl\u27e9, h\u27e9\n\n/--\nThe union of a set of sets.\n\n```\nsingletonUnion dom {\u27e8{a}, b\u27e9 | a \u2208 b} \u2229 (1 \u00d7 x) =\nsingletonUnion dom {\u27e8{a}, b\u27e9 | a \u2208 b \u2227 b \u2208 x} =\nsingletonUnion {{a} | a \u2208 b \u2227 b \u2208 x} =\n{a | a \u2208 b \u2227 b \u2208 x} =\n\u22c3 x\n```\n-/\ndef sUnion (x : TSet \u03b1) : TSet \u03b2 :=\n  singletonUnion h\u03b2 h\u03b3\n    (dom lt_higherIndex lt_higherIndex h\u03b2\n      (membership lt_higherIndex lt_higherIndex h\u03b2 h\u03b3 \u2293[lt_higherIndex]\n        cross lt_higherIndex lt_higherIndex h\u03b2 (cardinalOne h\u03b2 h\u03b3) x))\n\n", "theoremStatement": "@[simp]\ntheorem mem_sUnion_iff (x : TSet \u03b1) :\n    \u2200 y : TSet \u03b3, y \u2208' sUnion h\u03b2 h\u03b3 x \u2194 \u2203 t : TSet \u03b2, t \u2208' x \u2227 y \u2208' t ", "theoremName": "ConNF.mem_sUnion_iff", "fileCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "theoremCreated": {"commit": "d9f28df240ac4df047c3af0d236aed2e437e571f", "date": "2025-01-07"}, "file": "ConNF/ConNF/External/Basic.lean", "module": "ConNF.External.Basic", "jsonFile": "ConNF.External.Basic.jsonl", "positionMetadata": {"lineInFile": 276, "tokenPositionInFile": 8540, "theoremPositionInFile": 39}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 12, "repositoryPremises": true, "numRepositoryPremises": 29, "numPremises": 69}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  intro y\n  simp only [sUnion, mem_singletonUnion_iff, mem_dom_iff, Rel.dom, ExternalRel, mem_inter_iff,\n    mem_cross_iff, op_inj, mem_cardinalOne_iff, Set.mem_setOf_eq, membership_spec]\n  constructor\n  \u00b7 rintro \u27e8z, h\u2081, a, b, \u27e8rfl, rfl\u27e9, \u27e8c, h\u2082\u27e9, h\u2083\u27e9\n    rw [singleton_inj] at h\u2082\n    cases h\u2082\n    exact \u27e8z, h\u2083, h\u2081\u27e9\n  \u00b7 rintro \u27e8z, h\u2082, h\u2083\u27e9\n    exact \u27e8z, h\u2083, _, _, \u27e8rfl, rfl\u27e9, \u27e8y, rfl\u27e9, h\u2082\u27e9", "proofType": "tactic", "proofLengthLines": 10, "proofLengthTokens": 394}}
{"srcContext": "import ConNF.ModelData.PathEnumeration\n\n/-!\n# Supports\n\nIn this file, we define the notion of a support.\n\n## Main declarations\n\n* `ConNF.BaseSupport`: The type of supports of atoms.\n* `ConNF.Support`: The type of supports of objects of arbitrary type indices.\n-/\n\nuniverse u\n\nopen Cardinal\n\nnamespace ConNF\n\nvariable [Params.{u}]\n\n/-!\n## Base supports\n-/\n\nstructure BaseSupport where\n  atoms : Enumeration Atom\n  nearLitters : Enumeration NearLitter\n\nnamespace BaseSupport\n\ninstance : SuperA BaseSupport (Enumeration Atom) where\n  superA := atoms\n\ninstance : SuperN BaseSupport (Enumeration NearLitter) where\n  superN := nearLitters\n\n@[simp]\ntheorem mk_atoms {a : Enumeration Atom} {N : Enumeration NearLitter} :\n    (BaseSupport.mk a N)\u1d2c = a :=\n  rfl\n\n@[simp]\ntheorem mk_nearLitters {a : Enumeration Atom} {N : Enumeration NearLitter} :\n    (BaseSupport.mk a N)\u1d3a = N :=\n  rfl\n\ntheorem atoms_congr {S T : BaseSupport} (h : S = T) :\n    S\u1d2c = T\u1d2c :=\n  h \u25b8 rfl\n\ntheorem nearLitters_congr {S T : BaseSupport} (h : S = T) :\n    S\u1d3a = T\u1d3a :=\n  h \u25b8 rfl\n\n@[ext]\ntheorem ext {S T : BaseSupport} (h\u2081 : S\u1d2c = T\u1d2c) (h\u2082 : S\u1d3a = T\u1d3a) : S = T := by\n  obtain \u27e8SA, SN\u27e9 := S\n  obtain \u27e8TA, TN\u27e9 := T\n  cases h\u2081\n  cases h\u2082\n  rfl\n\ninstance : SMul BasePerm BaseSupport where\n  smul \u03c0 S := \u27e8\u03c0 \u2022 S\u1d2c, \u03c0 \u2022 S\u1d3a\u27e9\n\n@[simp]\ntheorem smul_atoms (\u03c0 : BasePerm) (S : BaseSupport) :\n    (\u03c0 \u2022 S)\u1d2c = \u03c0 \u2022 S\u1d2c :=\n  rfl\n\n@[simp]\ntheorem smul_nearLitters (\u03c0 : BasePerm) (S : BaseSupport) :\n    (\u03c0 \u2022 S)\u1d3a = \u03c0 \u2022 S\u1d3a :=\n  rfl\n\n@[simp]\ntheorem smul_atoms_eq_of_smul_eq {\u03c0 : BasePerm} {S : BaseSupport}\n    (h : \u03c0 \u2022 S = S) :\n    \u03c0 \u2022 S\u1d2c = S\u1d2c := by\n  rw [\u2190 smul_atoms, h]\n\n@[simp]\ntheorem smul_nearLitters_eq_of_smul_eq {\u03c0 : BasePerm} {S : BaseSupport}\n    (h : \u03c0 \u2022 S = S) :\n    \u03c0 \u2022 S\u1d3a = S\u1d3a := by\n  rw [\u2190 smul_nearLitters, h]\n\ninstance : MulAction BasePerm BaseSupport where\n  one_smul S := by\n    apply ext\n    \u00b7 rw [smul_atoms, one_smul]\n    \u00b7 rw [smul_nearLitters, one_smul]\n  mul_smul \u03c0\u2081 \u03c0\u2082 S := by\n    apply ext\n    \u00b7 rw [smul_atoms, smul_atoms, smul_atoms, mul_smul]\n    \u00b7 rw [smul_nearLitters, smul_nearLitters, smul_nearLitters, mul_smul]\n\ntheorem smul_eq_smul_iff (\u03c0\u2081 \u03c0\u2082 : BasePerm) (S : BaseSupport) :\n    \u03c0\u2081 \u2022 S = \u03c0\u2082 \u2022 S \u2194 (\u2200 a \u2208 S\u1d2c, \u03c0\u2081 \u2022 a = \u03c0\u2082 \u2022 a) \u2227 (\u2200 N \u2208 S\u1d3a, \u03c0\u2081 \u2022 N = \u03c0\u2082 \u2022 N) := by\n  constructor\n  \u00b7 intro h\n    constructor\n    \u00b7 rintro a \u27e8i, ha\u27e9\n      have := congr_arg (\u00b7\u1d2c.rel i (\u03c0\u2081 \u2022 a)) h\n      simp only [smul_atoms, Enumeration.smul_rel, inv_smul_smul, eq_iff_iff] at this\n      have := S\u1d2c.rel_coinjective.coinjective ha (this.mp ha)\n      rw [eq_inv_smul_iff] at this\n      rw [this]\n    \u00b7 rintro N \u27e8i, hN\u27e9\n      have := congr_arg (\u00b7\u1d3a.rel i (\u03c0\u2081 \u2022 N)) h\n      simp only [smul_nearLitters, Enumeration.smul_rel, inv_smul_smul, eq_iff_iff] at this\n      have := S\u1d3a.rel_coinjective.coinjective hN (this.mp hN)\n      rw [eq_inv_smul_iff] at this\n      rw [this]\n  \u00b7 intro h\n    ext : 2\n    \u00b7 rfl\n    \u00b7 ext i a : 3\n      rw [smul_atoms, smul_atoms, Enumeration.smul_rel, Enumeration.smul_rel]\n      constructor\n      \u00b7 intro ha\n        have := h.1 _ \u27e8i, ha\u27e9\n        rw [smul_inv_smul, \u2190 inv_smul_eq_iff] at this\n        rwa [this]\n      \u00b7 intro ha\n        have := h.1 _ \u27e8i, ha\u27e9\n        rw [smul_inv_smul, smul_eq_iff_eq_inv_smul] at this\n        rwa [\u2190 this]\n    \u00b7 rfl\n    \u00b7 ext i a : 3\n      rw [smul_nearLitters, smul_nearLitters, Enumeration.smul_rel, Enumeration.smul_rel]\n      constructor\n      \u00b7 intro hN\n        have := h.2 _ \u27e8i, hN\u27e9\n        rw [smul_inv_smul, \u2190 inv_smul_eq_iff] at this\n        rwa [this]\n      \u00b7 intro hN\n        have := h.2 _ \u27e8i, hN\u27e9\n        rw [smul_inv_smul, smul_eq_iff_eq_inv_smul] at this\n        rwa [\u2190 this]\n\ntheorem smul_eq_iff (\u03c0 : BasePerm) (S : BaseSupport) :\n    \u03c0 \u2022 S = S \u2194 (\u2200 a \u2208 S\u1d2c, \u03c0 \u2022 a = a) \u2227 (\u2200 N \u2208 S\u1d3a, \u03c0 \u2022 N = N) := by\n  have := smul_eq_smul_iff \u03c0 1 S\n  simp only [one_smul] at this\n  exact this\n\nnoncomputable instance : Add BaseSupport where\n  add S T := \u27e8S\u1d2c + T\u1d2c, S\u1d3a + T\u1d3a\u27e9\n\n@[simp]\ntheorem add_atoms (S T : BaseSupport) :\n    (S + T)\u1d2c = S\u1d2c + T\u1d2c :=\n  rfl\n\n@[simp]\ntheorem add_nearLitters (S T : BaseSupport) :\n    (S + T)\u1d3a = S\u1d3a + T\u1d3a :=\n  rfl\n\nend BaseSupport\n\ndef baseSupportEquiv : BaseSupport \u2243 Enumeration Atom \u00d7 Enumeration NearLitter where\n  toFun S := (S\u1d2c, S\u1d3a)\n  invFun S := \u27e8S.1, S.2\u27e9\n  left_inv _ := rfl\n  right_inv _ := rfl\n\ntheorem card_baseSupport : #BaseSupport = #\u03bc := by\n  rw [Cardinal.eq.mpr \u27e8baseSupportEquiv\u27e9, mk_prod, lift_id, lift_id,\n    card_enumeration_eq card_atom, card_enumeration_eq card_nearLitter, mul_eq_self aleph0_lt_\u03bc.le]\n\n/-!\n## Structural supports\n-/\n\nstructure Support (\u03b1 : TypeIndex) where\n  atoms : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)\n  nearLitters : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)\n\nnamespace Support\n\nvariable {\u03b1 \u03b2 : TypeIndex}\n\ninstance : SuperA (Support \u03b1) (Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) where\n  superA := atoms\n\ninstance : SuperN (Support \u03b1) (Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) where\n  superN := nearLitters\n\n@[simp]\ntheorem mk_atoms (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) (F : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) :\n    (\u27e8E, F\u27e9 : Support \u03b1)\u1d2c = E :=\n  rfl\n\n@[simp]\ntheorem mk_nearLitters (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom)) (F : Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter)) :\n    (\u27e8E, F\u27e9 : Support \u03b1)\u1d3a = F :=\n  rfl\n\ninstance : Derivative (Support \u03b1) (Support \u03b2) \u03b1 \u03b2 where\n  deriv S A := \u27e8S\u1d2c \u21d8 A, S\u1d3a \u21d8 A\u27e9\n\ninstance : Coderivative (Support \u03b2) (Support \u03b1) \u03b1 \u03b2 where\n  coderiv S A := \u27e8S\u1d2c \u21d7 A, S\u1d3a \u21d7 A\u27e9\n\ninstance : BotDerivative (Support \u03b1) BaseSupport \u03b1 where\n  botDeriv S A := \u27e8S\u1d2c \u21d8. A, S\u1d3a \u21d8. A\u27e9\n  botSderiv S := \u27e8S\u1d2c \u2198., S\u1d3a \u2198.\u27e9\n  botDeriv_single S h := by dsimp only; rw [botDeriv_single, botDeriv_single]\n\n@[simp]\ntheorem deriv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u03b2) :\n    S\u1d2c \u21d8 A = (S \u21d8 A)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem deriv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u03b2) :\n    S\u1d3a \u21d8 A = (S \u21d8 A)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem sderiv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (h : \u03b2 < \u03b1) :\n    S\u1d2c \u2198 h = (S \u2198 h)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem sderiv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b1) (h : \u03b2 < \u03b1) :\n    S\u1d3a \u2198 h = (S \u2198 h)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem coderiv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    S\u1d2c \u21d7 A = (S \u21d7 A)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem coderiv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    S\u1d3a \u21d7 A = (S \u21d7 A)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem scoderiv_atoms {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (h : \u03b2 < \u03b1) :\n    S\u1d2c \u2197 h = (S \u2197 h)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem scoderiv_nearLitters {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (h : \u03b2 < \u03b1) :\n    S\u1d3a \u2197 h = (S \u2197 h)\u1d3a :=\n  rfl\n\n@[simp]\ntheorem derivBot_atoms {\u03b1 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u22a5) :\n    S\u1d2c \u21d8. A = (S \u21d8. A)\u1d2c :=\n  rfl\n\n@[simp]\ntheorem derivBot_nearLitters {\u03b1 : TypeIndex} (S : Support \u03b1) (A : \u03b1 \u219d \u22a5) :\n    S\u1d3a \u21d8. A = (S \u21d8. A)\u1d3a :=\n  rfl\n\ntheorem ext' {S T : Support \u03b1} (h\u2081 : S\u1d2c = T\u1d2c) (h\u2082 : S\u1d3a = T\u1d3a) : S = T := by\n  obtain \u27e8SA, SN\u27e9 := S\n  obtain \u27e8TA, TN\u27e9 := T\n  cases h\u2081\n  cases h\u2082\n  rfl\n\n@[ext]\ntheorem ext {S T : Support \u03b1} (h : \u2200 A, S \u21d8. A = T \u21d8. A) : S = T := by\n  obtain \u27e8SA, SN\u27e9 := S\n  obtain \u27e8TA, TN\u27e9 := T\n  rw [mk.injEq]\n  constructor\n  \u00b7 apply Enumeration.ext_path\n    intro A\n    exact BaseSupport.atoms_congr (h A)\n  \u00b7 apply Enumeration.ext_path\n    intro A\n    exact BaseSupport.nearLitters_congr (h A)\n\n@[simp]\ntheorem deriv_derivBot {\u03b1 : TypeIndex} (S : Support \u03b1)\n    (A : \u03b1 \u219d \u03b2) (B : \u03b2 \u219d \u22a5) :\n    S \u21d8 A \u21d8. B = S \u21d8. (A \u21d8 B) :=\n  rfl\n\n@[simp]\ntheorem coderiv_deriv_eq {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    S \u21d7 A \u21d8 A = S :=\n  ext' (S\u1d2c.coderiv_deriv_eq A) (S\u1d3a.coderiv_deriv_eq A)\n\ntheorem eq_of_atom_mem_scoderiv_botDeriv {\u03b1 \u03b2 : TypeIndex} {S : Support \u03b2} {A : \u03b1 \u219d \u22a5}\n    {h : \u03b2 < \u03b1} {a : Atom} (ha : a \u2208 (S \u2197 h \u21d8. A)\u1d2c) :\n    \u2203 B : \u03b2 \u219d \u22a5, A = B \u2197 h :=\n  Enumeration.eq_of_mem_scoderiv_botDeriv ha\n\ntheorem eq_of_nearLitter_mem_scoderiv_botDeriv {\u03b1 \u03b2 : TypeIndex} {S : Support \u03b2} {A : \u03b1 \u219d \u22a5}\n    {h : \u03b2 < \u03b1} {N : NearLitter} (hN : N \u2208 (S \u2197 h \u21d8. A)\u1d3a) :\n    \u2203 B : \u03b2 \u219d \u22a5, A = B \u2197 h :=\n  Enumeration.eq_of_mem_scoderiv_botDeriv hN\n\n@[simp]\ntheorem scoderiv_botDeriv_eq {\u03b1 \u03b2 : TypeIndex} (S : Support \u03b2) (A : \u03b2 \u219d \u22a5) (h : \u03b2 < \u03b1) :\n    S \u2197 h \u21d8. (A \u2197 h) = S \u21d8. A :=\n  BaseSupport.ext (Enumeration.scoderiv_botDeriv_eq _ _ _) (Enumeration.scoderiv_botDeriv_eq _ _ _)\n\n@[simp]\ntheorem scoderiv_deriv_eq {\u03b1 \u03b2 \u03b3 : TypeIndex} (S : Support \u03b2) (A : \u03b2 \u219d \u03b3) (h : \u03b2 < \u03b1) :\n    S \u2197 h \u21d8 (A \u2197 h) = S \u21d8 A := by\n  apply ext\n  intro B\n  simp only [deriv_derivBot, \u2190 scoderiv_botDeriv_eq S (A \u21d8 B) h, Path.coderiv_deriv']\n\n@[simp]\ntheorem coderiv_inj {\u03b1 \u03b2 : TypeIndex} (S T : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    S \u21d7 A = T \u21d7 A \u2194 S = T := by\n  constructor\n  swap\n  \u00b7 rintro rfl\n    rfl\n  intro h\n  ext B : 1\n  have : S \u21d7 A \u21d8 A \u21d8. B = T \u21d7 A \u21d8 A \u21d8. B := by rw [h]\n  rwa [coderiv_deriv_eq, coderiv_deriv_eq] at this\n\n@[simp]\ntheorem scoderiv_inj {\u03b1 \u03b2 : TypeIndex} (S T : Support \u03b2) (h : \u03b2 < \u03b1) :\n    S \u2197 h = T \u2197 h \u2194 S = T :=\n  coderiv_inj S T (.single h)\n\ninstance {\u03b1 : TypeIndex} : SMul (StrPerm \u03b1) (Support \u03b1) where\n  smul \u03c0 S := \u27e8\u03c0 \u2022 S\u1d2c, \u03c0 \u2022 S\u1d3a\u27e9\n\n@[simp]\ntheorem smul_atoms {\u03b1 : TypeIndex} (\u03c0 : StrPerm \u03b1) (S : Support \u03b1) :\n    (\u03c0 \u2022 S)\u1d2c = \u03c0 \u2022 S\u1d2c :=\n  rfl\n\n@[simp]\ntheorem smul_nearLitters {\u03b1 : TypeIndex} (\u03c0 : StrPerm \u03b1) (S : Support \u03b1) :\n    (\u03c0 \u2022 S)\u1d3a = \u03c0 \u2022 S\u1d3a :=\n  rfl\n\ntheorem smul_atoms_eq_of_smul_eq {\u03b1 : TypeIndex} {\u03c0 : StrPerm \u03b1} {S : Support \u03b1}\n    (h : \u03c0 \u2022 S = S) :\n    \u03c0 \u2022 S\u1d2c = S\u1d2c := by\n  rw [\u2190 smul_atoms, h]\n\ntheorem smul_nearLitters_eq_of_smul_eq {\u03b1 : TypeIndex} {\u03c0 : StrPerm \u03b1} {S : Support \u03b1}\n    (h : \u03c0 \u2022 S = S) :\n    \u03c0 \u2022 S\u1d3a = S\u1d3a := by\n  rw [\u2190 smul_nearLitters, h]\n\ninstance {\u03b1 : TypeIndex} : MulAction (StrPerm \u03b1) (Support \u03b1) where\n  one_smul S := by\n    apply ext'\n    \u00b7 rw [smul_atoms, one_smul]\n    \u00b7 rw [smul_nearLitters, one_smul]\n  mul_smul \u03c0\u2081 \u03c0\u2082 S := by\n    apply ext'\n    \u00b7 rw [smul_atoms, smul_atoms, smul_atoms, mul_smul]\n    \u00b7 rw [smul_nearLitters, smul_nearLitters, smul_nearLitters, mul_smul]\n\n@[simp]\ntheorem smul_derivBot {\u03b1 : TypeIndex} (\u03c0 : StrPerm \u03b1) (S : Support \u03b1) (A : \u03b1 \u219d \u22a5) :\n    (\u03c0 \u2022 S) \u21d8. A = \u03c0 A \u2022 (S \u21d8. A) :=\n  rfl\n\ntheorem smul_coderiv {\u03b1 : TypeIndex} (\u03c0 : StrPerm \u03b1) (S : Support \u03b2) (A : \u03b1 \u219d \u03b2) :\n    \u03c0 \u2022 S \u21d7 A = (\u03c0 \u21d8 A \u2022 S) \u21d7 A := by\n  ext B i x\n  \u00b7 rfl\n  \u00b7 constructor\n    \u00b7 rintro \u27e8\u27e8C, x\u27e9, hS, hx\u27e9\n      simp only [Prod.mk.injEq] at hx\n      obtain \u27e8rfl, rfl\u27e9 := hx\n      exact \u27e8\u27e8C, x\u27e9, hS, rfl\u27e9\n    \u00b7 rintro \u27e8\u27e8C, x\u27e9, hS, hx\u27e9\n      simp only [Prod.mk.injEq] at hx\n      obtain \u27e8rfl, rfl\u27e9 := hx\n      exact \u27e8\u27e8C, _\u27e9, hS, rfl\u27e9\n  \u00b7 rfl\n  \u00b7 constructor\n    \u00b7 rintro \u27e8\u27e8C, x\u27e9, hS, hx\u27e9\n      simp only [Prod.mk.injEq] at hx\n      obtain \u27e8rfl, rfl\u27e9 := hx\n      exact \u27e8\u27e8C, x\u27e9, hS, rfl\u27e9\n    \u00b7 rintro \u27e8\u27e8C, a\u27e9, hS, hx\u27e9\n      simp only [Prod.mk.injEq] at hx\n      obtain \u27e8rfl, rfl\u27e9 := hx\n      exact \u27e8\u27e8C, _\u27e9, hS, rfl\u27e9\n\ntheorem smul_scoderiv {\u03b1 : TypeIndex} (\u03c0 : StrPerm \u03b1) (S : Support \u03b2) (h : \u03b2 < \u03b1) :\n    \u03c0 \u2022 S \u2197 h = (\u03c0 \u2198 h \u2022 S) \u2197 h :=\n  smul_coderiv \u03c0 S (Path.single h)\n\ntheorem smul_eq_smul_iff (\u03c0\u2081 \u03c0\u2082 : StrPerm \u03b2) (S : Support \u03b2) :\n    \u03c0\u2081 \u2022 S = \u03c0\u2082 \u2022 S \u2194\n      \u2200 A, (\u2200 a \u2208 (S \u21d8. A)\u1d2c, \u03c0\u2081 A \u2022 a = \u03c0\u2082 A \u2022 a) \u2227 (\u2200 N \u2208 (S \u21d8. A)\u1d3a, \u03c0\u2081 A \u2022 N = \u03c0\u2082 A \u2022 N) := by\n  constructor\n  \u00b7 intro h A\n    have := congr_arg (\u00b7 \u21d8. A) h\n    simp only [smul_derivBot, BaseSupport.smul_eq_smul_iff] at this\n    exact this\n  \u00b7 intro h\n    apply ext\n    intro A\n    simp only [smul_derivBot, BaseSupport.smul_eq_smul_iff]\n    exact h A\n\ntheorem smul_eq_iff (\u03c0 : StrPerm \u03b2) (S : Support \u03b2) :\n    \u03c0 \u2022 S = S \u2194 \u2200 A, (\u2200 a \u2208 (S \u21d8. A)\u1d2c, \u03c0 A \u2022 a = a) \u2227 (\u2200 N \u2208 (S \u21d8. A)\u1d3a, \u03c0 A \u2022 N = N) := by\n  have := smul_eq_smul_iff \u03c0 1 S\n  simp only [one_smul, Tree.one_apply] at this\n  exact this\n\nnoncomputable instance : Add (Support \u03b1) where\n  add S T := \u27e8S\u1d2c + T\u1d2c, S\u1d3a + T\u1d3a\u27e9\n\n@[simp]\ntheorem add_derivBot (S T : Support \u03b1) (A : \u03b1 \u219d \u22a5) :\n    (S + T) \u21d8. A = (S \u21d8. A) + (T \u21d8. A) :=\n  rfl\n\ntheorem smul_add (S T : Support \u03b1) (\u03c0 : StrPerm \u03b1) :\n    \u03c0 \u2022 (S + T) = \u03c0 \u2022 S + \u03c0 \u2022 T :=\n  rfl\n\ntheorem add_inj_of_bound_eq_bound {S T U V : Support \u03b1}\n    (ha : S\u1d2c.bound = T\u1d2c.bound) (hN : S\u1d3a.bound = T\u1d3a.bound)\n    (h' : S + U = T + V) : S = T \u2227 U = V := by\n  have ha' := Enumeration.add_inj_of_bound_eq_bound ha (congr_arg (\u00b7\u1d2c) h')\n  have hN' := Enumeration.add_inj_of_bound_eq_bound hN (congr_arg (\u00b7\u1d3a) h')\n  constructor\n  \u00b7 exact Support.ext' ha'.1 hN'.1\n  \u00b7 exact Support.ext' ha'.2 hN'.2\n\nend Support\n\ndef supportEquiv {\u03b1 : TypeIndex} : Support \u03b1 \u2243\n    Enumeration (\u03b1 \u219d \u22a5 \u00d7 Atom) \u00d7 Enumeration (\u03b1 \u219d \u22a5 \u00d7 NearLitter) where\n  toFun S := (S\u1d2c, S\u1d3a)\n  invFun S := \u27e8S.1, S.2\u27e9\n  left_inv _ := rfl\n  right_inv _ := rfl\n\ntheorem card_support {\u03b1 : TypeIndex} : #(Support \u03b1) = #\u03bc := by\n  rw [Cardinal.eq.mpr \u27e8supportEquiv\u27e9, mk_prod, lift_id, lift_id,\n    card_enumeration_eq, card_enumeration_eq, mul_eq_self aleph0_lt_\u03bc.le]\n  \u00b7 rw [mk_prod, lift_id, lift_id, card_nearLitter,\n      mul_eq_right aleph0_lt_\u03bc.le (card_path_lt' \u03b1 \u22a5).le (card_path_ne_zero \u03b1)]\n  \u00b7 rw [mk_prod, lift_id, lift_id, card_atom,\n      mul_eq_right aleph0_lt_\u03bc.le (card_path_lt' \u03b1 \u22a5).le (card_path_ne_zero \u03b1)]\n\n/-!\n## Orders on supports\n-/\n\n-- TODO: Is this order used?\ninstance : LE BaseSupport where\n  le S T := (\u2200 a \u2208 S\u1d2c, a \u2208 T\u1d2c) \u2227 (\u2200 N \u2208 S\u1d3a, N \u2208 T\u1d3a)\n\ninstance : Preorder BaseSupport where\n  le_refl S := \u27e8\u03bb _ \u21a6 id, \u03bb _ \u21a6 id\u27e9\n  le_trans S T U h\u2081 h\u2082 := \u27e8\u03bb a h \u21a6 h\u2082.1 _ (h\u2081.1 a h), \u03bb N h \u21a6 h\u2082.2 _ (h\u2081.2 N h)\u27e9\n\ntheorem BaseSupport.smul_le_smul {S T : BaseSupport} (h : S \u2264 T) (\u03c0 : BasePerm) :\n    \u03c0 \u2022 S \u2264 \u03c0 \u2022 T := by\n  constructor\n  \u00b7 intro a\n    exact h.1 (\u03c0\u207b\u00b9 \u2022 a)\n  \u00b7 intro N\n    exact h.2 (\u03c0\u207b\u00b9 \u2022 N)\n\ntheorem BaseSupport.le_add_right {S T : BaseSupport} :\n    S \u2264 S + T := by\n  constructor\n  \u00b7 intro a ha\n    simp only [Support.add_derivBot, BaseSupport.add_atoms, Enumeration.mem_add_iff]\n    exact Or.inl ha\n  \u00b7 intro N hN\n    simp only [Support.add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n    exact Or.inl hN\n\ntheorem BaseSupport.le_add_left {S T : BaseSupport} :\n    S \u2264 T + S := by\n  constructor\n  \u00b7 intro a ha\n    simp only [add_atoms, Enumeration.mem_add_iff]\n    exact Or.inr ha\n  \u00b7 intro N hN\n    simp only [add_nearLitters, Enumeration.mem_add_iff]\n    exact Or.inr hN\n\ndef BaseSupport.Subsupport (S T : BaseSupport) : Prop :=\n  S\u1d2c.rel \u2264 T\u1d2c.rel \u2227 S\u1d3a.rel \u2264 T\u1d3a.rel\n\ntheorem BaseSupport.Subsupport.le {S T : BaseSupport}\n    (h : S.Subsupport T) : S \u2264 T := by\n  constructor\n  \u00b7 rintro a \u27e8i, hi\u27e9\n    exact \u27e8i, h.1 i a hi\u27e9\n  \u00b7 rintro N \u27e8i, hi\u27e9\n    exact \u27e8i, h.2 i N hi\u27e9\n\ntheorem BaseSupport.Subsupport.trans {S T U : BaseSupport}\n    (h\u2081 : S.Subsupport T) (h\u2082 : T.Subsupport U) :\n    S.Subsupport U :=\n  \u27e8h\u2081.1.trans h\u2082.1, h\u2081.2.trans h\u2082.2\u27e9\n\ntheorem BaseSupport.smul_subsupport_smul {S T : BaseSupport} (h : S.Subsupport T) (\u03c0 : BasePerm) :\n    (\u03c0 \u2022 S).Subsupport (\u03c0 \u2022 T) := by\n  constructor\n  \u00b7 intro i a ha\n    exact h.1 i _ ha\n  \u00b7 intro i N hN\n    exact h.2 i _ hN\n\ninstance {\u03b1 : TypeIndex} : LE (Support \u03b1) where\n  le S T := \u2200 A, S \u21d8. A \u2264 T \u21d8. A\n\ninstance {\u03b1 : TypeIndex} : Preorder (Support \u03b1) where\n  le_refl S := \u03bb A \u21a6 le_rfl\n  le_trans S T U h\u2081 h\u2082 := \u03bb A \u21a6 (h\u2081 A).trans (h\u2082 A)\n\ntheorem Support.smul_le_smul {\u03b1 : TypeIndex} {S T : Support \u03b1} (h : S \u2264 T) (\u03c0 : StrPerm \u03b1) :\n    \u03c0 \u2022 S \u2264 \u03c0 \u2022 T :=\n  \u03bb A \u21a6 BaseSupport.smul_le_smul (h A) (\u03c0 A)\n\ntheorem Support.le_add_right {\u03b1 : TypeIndex} {S T : Support \u03b1} :\n    S \u2264 S + T := by\n  intro A\n  rw [add_derivBot]\n  exact BaseSupport.le_add_right\n\ntheorem Support.le_add_left {\u03b1 : TypeIndex} {S T : Support \u03b1} :\n    S \u2264 T + S := by\n  intro A\n  rw [add_derivBot]\n  exact BaseSupport.le_add_left\n\ndef Support.Subsupport {\u03b1 : TypeIndex} (S T : Support \u03b1) : Prop :=\n  \u2200 A, (S \u21d8. A).Subsupport (T \u21d8. A)\n\ntheorem Support.Subsupport.le {\u03b1 : TypeIndex} {S T : Support \u03b1}\n    (h : S.Subsupport T) : S \u2264 T :=\n  \u03bb A \u21a6 (h A).le\n\ntheorem Support.Subsupport.trans {\u03b1 : TypeIndex} {S T U : Support \u03b1}\n    (h\u2081 : S.Subsupport T) (h\u2082 : T.Subsupport U) :\n    S.Subsupport U :=\n  \u03bb A \u21a6 (h\u2081 A).trans (h\u2082 A)\n\ntheorem Support.smul_subsupport_smul {\u03b1 : TypeIndex} {S T : Support \u03b1}\n    (h : S.Subsupport T) (\u03c0 : StrPerm \u03b1) :\n    (\u03c0 \u2022 S).Subsupport (\u03c0 \u2022 T) :=\n  \u03bb A \u21a6 BaseSupport.smul_subsupport_smul (h A) (\u03c0 A)\n\ntheorem subsupport_add {\u03b1 : TypeIndex} {S T : Support \u03b1} :\n    S.Subsupport (S + T) := by\n  intro A\n  constructor\n  \u00b7 intro i a ha\n    simp only [Support.add_derivBot, BaseSupport.add_atoms, Enumeration.rel_add_iff]\n    exact Or.inl ha\n  \u00b7 intro i N hN\n    simp only [Support.add_derivBot, BaseSupport.add_atoms, Enumeration.rel_add_iff]\n    exact Or.inl hN\n\ntheorem smul_eq_of_subsupport {\u03b1 : TypeIndex} {S T : Support \u03b1} {\u03c0 : StrPerm \u03b1}\n    (h\u2081 : S.Subsupport T) (h\u2082 : S.Subsupport (\u03c0 \u2022 T)) :\n    \u03c0 \u2022 S = S := by\n  rw [Support.smul_eq_iff]\n  intro A\n  constructor\n  \u00b7 rintro a \u27e8i, hi\u27e9\n    have hi\u2081 := (h\u2081 A).1 i a hi\n    have hi\u2082 := (h\u2082 A).1 i a hi\n    have := (T \u21d8. A)\u1d2c.rel_coinjective.coinjective hi\u2081 hi\u2082\n    dsimp only at this\n    rwa [smul_eq_iff_eq_inv_smul]\n  \u00b7 rintro N \u27e8i, hi\u27e9\n    have hi\u2081 := (h\u2081 A).2 i N hi\n    have hi\u2082 := (h\u2082 A).2 i N hi\n    have := (T \u21d8. A)\u1d3a.rel_coinjective.coinjective hi\u2081 hi\u2082\n    dsimp only at this\n    rwa [smul_eq_iff_eq_inv_smul]\n\n", "theoremStatement": "theorem smul_eq_smul_of_le {\u03b1 : TypeIndex} {S T : Support \u03b1} {\u03c0\u2081 \u03c0\u2082 : StrPerm \u03b1}\n    (h : S \u2264 T) (h\u2082 : \u03c0\u2081 \u2022 T = \u03c0\u2082 \u2022 T) :\n    \u03c0\u2081 \u2022 S = \u03c0\u2082 \u2022 S ", "theoremName": "ConNF.smul_eq_smul_of_le", "fileCreated": {"commit": "39c33b4a743bea62dbcc549548b712ffd38ca65c", "date": "2024-12-05"}, "theoremCreated": {"commit": "6709914ae7f5cd3e2bb24b413e09aa844554d234", "date": "2024-11-30"}, "file": "ConNF/ConNF/ModelData/Support.lean", "module": "ConNF.ModelData.Support", "jsonFile": "ConNF.ModelData.Support.jsonl", "positionMetadata": {"lineInFile": 591, "tokenPositionInFile": 16769, "theoremPositionInFile": 65}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 8, "repositoryPremises": true, "numRepositoryPremises": 23, "numPremises": 39}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [Support.smul_eq_smul_iff] at h\u2082 \u22a2\n  intro A\n  constructor\n  \u00b7 intro a ha\n    exact (h\u2082 A).1 a ((h A).1 a ha)\n  \u00b7 intro N hN\n    exact (h\u2082 A).2 N ((h A).2 N hN)", "proofType": "tactic", "proofLengthLines": 7, "proofLengthTokens": 171}}
{"srcContext": "import ConNF.Model.Result\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal ConNF.TSet\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\ndef union (x y : TSet \u03b1) : TSet \u03b1 :=\n  (x\u1d9c' \u2293' y\u1d9c')\u1d9c'\n\nnotation:68 x:68 \" \u2294[\" h \"] \" y:68 => _root_.ConNF.union h x y\nnotation:68 x:68 \" \u2294' \" y:68 => x \u2294[by assumption] y\n\n@[simp]\ntheorem mem_union_iff (x y : TSet \u03b1) :\n    \u2200 z : TSet \u03b2, z \u2208' x \u2294' y \u2194 z \u2208' x \u2228 z \u2208' y := by\n  rw [union]\n  intro z\n  rw [mem_compl_iff, mem_inter_iff, mem_compl_iff, mem_compl_iff, or_iff_not_and_not]\n\ndef higherIndex (\u03b1 : \u039b) : \u039b :=\n  (exists_gt \u03b1).choose\n\ntheorem lt_higherIndex {\u03b1 : \u039b} :\n    (\u03b1 : TypeIndex) < higherIndex \u03b1 :=\n  WithBot.coe_lt_coe.mpr (exists_gt \u03b1).choose_spec\n\ntheorem tSet_nonempty (h : \u2203 \u03b2 : \u039b, (\u03b2 : TypeIndex) < \u03b1) : Nonempty (TSet \u03b1) := by\n  obtain \u27e8\u03b1', h\u03b1\u27e9 := h\n  constructor\n  apply typeLower lt_higherIndex lt_higherIndex lt_higherIndex h\u03b1\n  apply cardinalOne lt_higherIndex lt_higherIndex\n\ndef empty : TSet \u03b1 :=\n  (tSet_nonempty \u27e8\u03b2, h\u03b2\u27e9).some \u2293' (tSet_nonempty \u27e8\u03b2, h\u03b2\u27e9).some\u1d9c'\n\n@[simp]\ntheorem mem_empty_iff :\n    \u2200 x : TSet \u03b2, \u00acx \u2208' empty h\u03b2 := by\n  intro x\n  rw [empty, mem_inter_iff, mem_compl_iff]\n  exact and_not_self\n\ndef univ : TSet \u03b1 :=\n  (empty h\u03b2)\u1d9c'\n\n@[simp]\ntheorem mem_univ_iff :\n    \u2200 x : TSet \u03b2, x \u2208' univ h\u03b2 := by\n  intro x\n  simp only [univ, mem_compl_iff, mem_empty_iff, not_false_eq_true]\n\n/-- The set of all ordered pairs. -/\ndef orderedPairs : TSet \u03b1 :=\n  vCross h\u03b2 h\u03b3 h\u03b4 (univ h\u03b4)\n\n@[simp]\ntheorem mem_orderedPairs_iff (x : TSet \u03b2) :\n    x \u2208' orderedPairs h\u03b2 h\u03b3 h\u03b4 \u2194 \u2203 a b, x = \u27e8a, b\u27e9' := by\n  simp only [orderedPairs, vCross_spec, mem_univ_iff, and_true]\n\ndef converse (x : TSet \u03b1) : TSet \u03b1 :=\n  converse' h\u03b2 h\u03b3 h\u03b4 x \u2293' orderedPairs h\u03b2 h\u03b3 h\u03b4\n\n@[simp]\ntheorem op_mem_converse_iff (x : TSet \u03b1) :\n    \u2200 a b, \u27e8a, b\u27e9' \u2208' converse h\u03b2 h\u03b3 h\u03b4 x \u2194 \u27e8b, a\u27e9' \u2208' x := by\n  intro a b\n  simp only [converse, mem_inter_iff, converse'_spec, mem_orderedPairs_iff, op_inj, exists_and_left,\n    exists_eq', and_true]\n\ndef cross (x y : TSet \u03b3) : TSet \u03b1 :=\n  converse h\u03b2 h\u03b3 h\u03b4 (vCross h\u03b2 h\u03b3 h\u03b4 x) \u2293' vCross h\u03b2 h\u03b3 h\u03b4 y\n\n@[simp]\ntheorem mem_cross_iff (x y : TSet \u03b3) :\n    \u2200 a, a \u2208' cross h\u03b2 h\u03b3 h\u03b4 x y \u2194 \u2203 b c, a = \u27e8b, c\u27e9' \u2227 b \u2208' x \u2227 c \u2208' y := by\n  intro a\n  rw [cross, mem_inter_iff, vCross_spec]\n  constructor\n  \u00b7 rintro \u27e8h\u2081, b, c, rfl, h\u2082\u27e9\n    simp only [op_mem_converse_iff, vCross_spec, op_inj] at h\u2081\n    obtain \u27e8b', c', \u27e8rfl, rfl\u27e9, h\u2081\u27e9 := h\u2081\n    exact \u27e8b, c, rfl, h\u2081, h\u2082\u27e9\n  \u00b7 rintro \u27e8b, c, rfl, h\u2081, h\u2082\u27e9\n    simp only [op_mem_converse_iff, vCross_spec, op_inj]\n    exact \u27e8\u27e8c, b, \u27e8rfl, rfl\u27e9, h\u2081\u27e9, \u27e8b, c, \u27e8rfl, rfl\u27e9, h\u2082\u27e9\u27e9\n\ndef singletonImage (x : TSet \u03b2) : TSet \u03b1 :=\n  singletonImage' h\u03b2 h\u03b3 h\u03b4 h\u03b5 x \u2293' (cross h\u03b2 h\u03b3 h\u03b4 (cardinalOne h\u03b4 h\u03b5) (cardinalOne h\u03b4 h\u03b5))\n\n", "theoremStatement": "@[simp]\ntheorem singletonImage_spec (x : TSet \u03b2) :\n    \u2200 z w,\n    \u27e8 {z}', {w}' \u27e9' \u2208' singletonImage h\u03b2 h\u03b3 h\u03b4 h\u03b5 x \u2194 \u27e8z, w\u27e9' \u2208' x ", "theoremName": "ConNF.singletonImage_spec", "fileCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "theoremCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "file": "ConNF/ConNF/External/Basic.lean", "module": "ConNF.External.Basic", "jsonFile": "ConNF.External.Basic.jsonl", "positionMetadata": {"lineInFile": 107, "tokenPositionInFile": 2947, "theoremPositionInFile": 18}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 21, "numPremises": 52}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  intro z w\n  rw [singletonImage, mem_inter_iff, singletonImage'_spec, and_iff_left_iff_imp]\n  intro hzw\n  rw [mem_cross_iff]\n  refine \u27e8{z}', {w}', rfl, ?_\u27e9\n  simp only [mem_cardinalOne_iff, singleton_inj, exists_eq', and_self]", "proofType": "tactic", "proofLengthLines": 6, "proofLengthTokens": 233}}
{"srcContext": "import ConNF.ModelData.Enumeration\nimport ConNF.Levels.StrPerm\n\n/-!\n# Enumerations over paths\n\nIn this file, we provide extra features to `Enumeration`s that take values of the form `\u03b1 \u219d \u22a5 \u00d7 X`.\n\n## Main declarations\n\n* `ConNF.Enumeration.ext_path`: An extensionality principle for such `Enumeration`s.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nnamespace ConNF\n\nvariable [Params.{u}]\n\nnamespace Enumeration\n\n/-- A helper function for making relations with domain and codomain of the form `\u03b1 \u219d \u22a5 \u00d7 X`\nby defining it on each branch. -/\ndef relWithPath {X Y : Type u} {\u03b1 : TypeIndex} (f : \u03b1 \u219d \u22a5 \u2192 Rel X Y) :\n    Rel (\u03b1 \u219d \u22a5 \u00d7 X) (\u03b1 \u219d \u22a5 \u00d7 Y) :=\n  \u03bb x y \u21a6 x.1 = y.1 \u2227 f x.1 x.2 y.2\n\ntheorem relWithPath_coinjective {X Y : Type u} {\u03b1 : TypeIndex} {f : \u03b1 \u219d \u22a5 \u2192 Rel X Y}\n    (hf : \u2200 A, (f A).Coinjective) :\n    (relWithPath f).Coinjective := by\n  constructor\n  rintro \u27e8_, y\u2081\u27e9 \u27e8_, y\u2082\u27e9 \u27e8A, x\u27e9 \u27e8rfl, h\u2081\u27e9 \u27e8rfl, h\u2082\u27e9\n  cases (hf A).coinjective h\u2081 h\u2082\n  rfl\n\ninstance (X : Type u) (\u03b1 \u03b2 : TypeIndex) :\n    Derivative (Enumeration (\u03b1 \u219d \u22a5 \u00d7 X)) (Enumeration (\u03b2 \u219d \u22a5 \u00d7 X)) \u03b1 \u03b2 where\n  deriv E A := E.invImage (\u03bb x \u21a6 (x.1 \u21d7 A, x.2))\n    (\u03bb x y h \u21a6 Prod.ext (Path.deriv_right_injective\n      ((Prod.mk.injEq _ _ _ _).mp h).1) ((Prod.mk.injEq _ _ _ _).mp h).2)\n\ntheorem deriv_rel {X : Type _} {\u03b1 \u03b2 : TypeIndex} (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 X)) (A : \u03b1 \u219d \u03b2)\n    (i : \u03ba) (x : \u03b2 \u219d \u22a5 \u00d7 X) :\n    (E \u21d8 A).rel i x \u2194 E.rel i (x.1 \u21d7 A, x.2) :=\n  Iff.rfl\n\ninstance (X : Type u) (\u03b1 \u03b2 : TypeIndex) :\n    Coderivative (Enumeration (\u03b2 \u219d \u22a5 \u00d7 X)) (Enumeration (\u03b1 \u219d \u22a5 \u00d7 X)) \u03b1 \u03b2 where\n  coderiv E A := E.image (\u03bb x \u21a6 (x.1 \u21d7 A, x.2))\n\ntheorem coderiv_rel {X : Type _} {\u03b1 \u03b2 : TypeIndex} (E : Enumeration (\u03b2 \u219d \u22a5 \u00d7 X)) (A : \u03b1 \u219d \u03b2)\n    (i : \u03ba) (x : \u03b1 \u219d \u22a5 \u00d7 X) :\n    (E \u21d7 A).rel i x \u2194 \u2203 B, x.1 = A \u21d8 B \u2227 E.rel i (B, x.2) := by\n  constructor\n  \u00b7 rintro \u27e8x, h, rfl\u27e9\n    exact \u27e8_, rfl, h\u27e9\n  \u00b7 rintro \u27e8B, h\u2081, h\u2082\u27e9\n    refine \u27e8(B, x.2), h\u2082, ?_\u27e9\n    apply Prod.ext\n    \u00b7 dsimp only\n      exact h\u2081.symm\n    \u00b7 rfl\n\ntheorem scoderiv_rel {X : Type _} {\u03b1 \u03b2 : TypeIndex} (E : Enumeration (\u03b2 \u219d \u22a5 \u00d7 X)) (h : \u03b2 < \u03b1)\n    (i : \u03ba) (x : \u03b1 \u219d \u22a5 \u00d7 X) :\n    (E \u2197 h).rel i x \u2194 \u2203 B, x.1 = B \u2197 h \u2227 E.rel i (B, x.2) :=\n  coderiv_rel E (.single h) i x\n\ntheorem eq_of_scoderiv_mem {X : Type _} {\u03b1 \u03b2 \u03b3 : TypeIndex} (E : Enumeration (\u03b2 \u219d \u22a5 \u00d7 X))\n    (h : \u03b2 < \u03b1) (h' : \u03b3 < \u03b1)\n    (i : \u03ba) (A : \u03b3 \u219d \u22a5) (x : X) (h : (E \u2197 h).rel i \u27e8A \u2197 h', x\u27e9) :\n    \u03b2 = \u03b3 := by\n  rw [scoderiv_rel] at h\n  obtain \u27e8B, h\u2081, h\u2082\u27e9 := h\n  exact Path.scoderiv_index_injective h\u2081.symm\n\ninstance (X : Type u) (\u03b1 : TypeIndex) :\n    BotDerivative (Enumeration (\u03b1 \u219d \u22a5 \u00d7 X)) (Enumeration X) \u03b1 where\n  botDeriv E A := E.invImage (\u03bb x \u21a6 (A, x)) (Prod.mk.inj_left A)\n  botSderiv E := E.invImage (\u03bb x \u21a6 (Path.nil \u2198., x)) (Prod.mk.inj_left (Path.nil \u2198.))\n  botDeriv_single E h := by\n    cases \u03b1 using WithBot.recBotCoe with\n    | bot => cases lt_irrefl \u22a5 h\n    | coe => rfl\n\n", "theoremStatement": "theorem derivBot_rel {X : Type _} {\u03b1 : TypeIndex} (E : Enumeration (\u03b1 \u219d \u22a5 \u00d7 X)) (A : \u03b1 \u219d \u22a5)\n    (i : \u03ba) (x : X) :\n    (E \u21d8. A).rel i x \u2194 E.rel i (A, x) ", "theoremName": "ConNF.Enumeration.derivBot_rel", "fileCreated": {"commit": "39c33b4a743bea62dbcc549548b712ffd38ca65c", "date": "2024-12-05"}, "theoremCreated": {"commit": "ce890707e37ede74a2fcd66134d3f403335c5cc1", "date": "2024-11-30"}, "file": "ConNF/ConNF/ModelData/PathEnumeration.lean", "module": "ConNF.ModelData.PathEnumeration", "jsonFile": "ConNF.ModelData.PathEnumeration.jsonl", "positionMetadata": {"lineInFile": 89, "tokenPositionInFile": 2868, "theoremPositionInFile": 6}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 9, "numPremises": 15}, "proofMetadata": {"hasProof": true, "proof": ":=\n  Iff.rfl", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 12}}
{"srcContext": "import ConNF.Model.RaiseStrong\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nopen scoped Pointwise\n\nnamespace ConNF\n\nvariable [Params.{u}]\n\n/-- A redefinition of the derivative of allowable permutations that is invariant of level,\nbut still has nice definitional properties. -/\n@[default_instance 200]\ninstance {\u03b2 \u03b3 : TypeIndex} : Derivative (AllPerm \u03b2) (AllPerm \u03b3) \u03b2 \u03b3 where\n  deriv \u03c1 A :=\n    A.recSderiv\n    (motive := \u03bb (\u03b4 : TypeIndex) (A : \u03b2 \u219d \u03b4) \u21a6\n      letI : Level := \u27e8\u03b4.recBotCoe (Nonempty.some inferInstance) id\u27e9\n      letI : LeLevel \u03b4 := \u27e8\u03b4.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n        (show \u03b4.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n      AllPerm \u03b4)\n    \u03c1 (\u03bb \u03b4 \u03b5 A h \u03c1 \u21a6\n      letI : Level := \u27e8\u03b4.recBotCoe (Nonempty.some inferInstance) id\u27e9\n      letI : LeLevel \u03b4 := \u27e8\u03b4.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n        (show \u03b4.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n      letI : LeLevel \u03b5 := \u27e8h.le.trans LeLevel.elim\u27e9\n      PreCoherentData.allPermSderiv h \u03c1)\n\n@[simp]\ntheorem allPerm_deriv_nil' {\u03b2 : TypeIndex}\n    (\u03c1 : AllPerm \u03b2) :\n    \u03c1 \u21d8 (.nil : \u03b2 \u219d \u03b2) = \u03c1 :=\n  rfl\n\n@[simp]\ntheorem allPerm_deriv_sderiv' {\u03b2 \u03b3 \u03b4 : TypeIndex}\n    (\u03c1 : AllPerm \u03b2) (A : \u03b2 \u219d \u03b3) (h : \u03b4 < \u03b3) :\n    \u03c1 \u21d8 (A \u2198 h) = \u03c1 \u21d8 A \u2198 h :=\n  rfl\n\n@[simp]\ntheorem allPermSderiv_forget' {\u03b2 \u03b3 : TypeIndex} (h : \u03b3 < \u03b2) (\u03c1 : AllPerm \u03b2) :\n    (\u03c1 \u2198 h)\u1d41 = \u03c1\u1d41 \u2198 h :=\n  letI : Level := \u27e8\u03b2.recBotCoe (Nonempty.some inferInstance) id\u27e9\n  letI : LeLevel \u03b2 := \u27e8\u03b2.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n    (show \u03b2.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n  letI : LeLevel \u03b3 := \u27e8h.le.trans LeLevel.elim\u27e9\n  allPermSderiv_forget h \u03c1\n\n@[simp]\ntheorem allPerm_inv_sderiv' {\u03b2 \u03b3 : TypeIndex} (h : \u03b3 < \u03b2) (\u03c1 : AllPerm \u03b2) :\n    \u03c1\u207b\u00b9 \u2198 h = (\u03c1 \u2198 h)\u207b\u00b9 := by\n  apply allPermForget_injective\n  rw [allPermSderiv_forget', allPermForget_inv, Tree.inv_sderiv, allPermForget_inv,\n    allPermSderiv_forget']\n\ndef Symmetric {\u03b1 \u03b2 : \u039b} (s : Set (TSet \u03b2)) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) : Prop :=\n  \u2203 S : Support \u03b1, \u2200 \u03c1 : AllPerm \u03b1, \u03c1\u1d41 \u2022 S = S \u2192 \u03c1 \u2198 h\u03b2 \u2022 s = s\n\ndef newSetEquiv {\u03b1 : \u039b} :\n    letI : Level := \u27e8\u03b1\u27e9\n    @TSet _ \u03b1 newModelData.toPreModelData \u2243 TSet \u03b1 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castTSet (D\u2081 := newModelData) (D\u2082 := globalModelData) rfl\n    (by rw [globalModelData, motive_eq, constructMotive, globalLtData_eq])\n\n@[simp]\ntheorem newSetEquiv_forget {\u03b1 : \u039b}\n    (x : letI : Level := \u27e8\u03b1\u27e9; @TSet _ \u03b1 newModelData.toPreModelData) :\n    (newSetEquiv x)\u1d41 = x\u1d41 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castTSet_forget (D\u2081 := newModelData) (D\u2082 := globalModelData) _ x\n\ndef allPermEquiv {\u03b1 : \u039b} :\n    letI : Level := \u27e8\u03b1\u27e9\n    NewPerm \u2243 AllPerm \u03b1 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castAllPerm (D\u2081 := newModelData) (D\u2082 := globalModelData) rfl\n    (by rw [globalModelData, motive_eq, constructMotive, globalLtData_eq])\n\n@[simp]\ntheorem allPermEquiv_forget {\u03b1 : \u039b} (\u03c1 : letI : Level := \u27e8\u03b1\u27e9; NewPerm) :\n    (allPermEquiv \u03c1)\u1d41 = \u03c1\u1d41 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  castAllPerm_forget (D\u2081 := newModelData) (D\u2082 := globalModelData) _ \u03c1\n\ntheorem allPermEquiv_sderiv {\u03b1 \u03b2 : \u039b}\n    (\u03c1 : letI : Level := \u27e8\u03b1\u27e9; NewPerm) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) :\n    letI : Level := \u27e8\u03b1\u27e9\n    letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n    allPermEquiv \u03c1 \u2198 h\u03b2 = \u03c1.sderiv \u03b2 := by\n  letI : Level := \u27e8\u03b1\u27e9\n  letI : LeLevel \u03b1 := \u27e8le_rfl\u27e9\n  letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n  apply allPermForget_injective\n  rw [allPermSderiv_forget, allPermEquiv_forget, NewPerm.forget_sderiv]\n\ntheorem TSet.exists_of_symmetric {\u03b1 \u03b2 : \u039b} (s : Set (TSet \u03b2)) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1)\n    (hs : Symmetric s h\u03b2) :\n    \u2203 x : TSet \u03b1, \u2200 y : TSet \u03b2, y \u2208[h\u03b2] x \u2194 y \u2208 s := by\n  letI : Level := \u27e8\u03b1\u27e9\n  letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n  suffices \u2203 x : (@TSet _ \u03b1 newModelData.toPreModelData), \u2200 y : TSet \u03b2, y\u1d41 \u2208[h\u03b2] x\u1d41 \u2194 y \u2208 s by\n    obtain \u27e8x, hx\u27e9 := this\n    use newSetEquiv x\n    intro y\n    rw [\u2190 hx, \u2190 TSet.forget_mem_forget, newSetEquiv_forget]\n  obtain rfl | hs' := s.eq_empty_or_nonempty\n  \u00b7 use none\n    intro y\n    simp only [Set.mem_empty_iff_false, iff_false]\n    exact not_mem_none y\n  \u00b7 use some (Code.toSet \u27e8\u03b2, s, hs'\u27e9 ?_)\n    \u00b7 intro y\n      erw [mem_some_iff]\n      exact Code.mem_toSet _\n    \u00b7 obtain \u27e8S, hS\u27e9 := hs\n      use S\n      intro \u03c1 h\u03c1S\n      have := hS (allPermEquiv \u03c1) ?_\n      \u00b7 simp only [NewPerm.smul_mk, Code.mk.injEq, heq_eq_eq, true_and]\n        rwa [allPermEquiv_sderiv] at this\n      \u00b7 rwa [allPermEquiv_forget]\n\ntheorem TSet.exists_support {\u03b1 : \u039b} (x : TSet \u03b1) :\n    \u2203 S : Support \u03b1, \u2200 \u03c1 : AllPerm \u03b1, \u03c1\u1d41 \u2022 S = S \u2192 \u03c1 \u2022 x = x := by\n  letI : Level := \u27e8\u03b1\u27e9\n  obtain \u27e8S, hS\u27e9 := NewSet.exists_support (newSetEquiv.symm x)\n  use S\n  intro \u03c1 h\u03c1\n  have := @Support.Supports.supports _ _ _ newPreModelData _ _ _ hS (allPermEquiv.symm \u03c1) ?_\n  \u00b7 apply tSetForget_injective\n    have := congr_arg (\u00b7\u1d41) this\n    simp only at this\n    erw [@smul_forget _ _ newModelData (allPermEquiv.symm \u03c1) (newSetEquiv.symm x),\n      \u2190 allPermEquiv_forget, \u2190 newSetEquiv_forget, Equiv.apply_symm_apply,\n      Equiv.apply_symm_apply] at this\n    rwa [smul_forget]\n  \u00b7 rwa [\u2190 allPermEquiv_forget, Equiv.apply_symm_apply]\n\ntheorem TSet.symmetric {\u03b1 \u03b2 : \u039b} (x : TSet \u03b1) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) :\n    Symmetric {y : TSet \u03b2 | y \u2208[h\u03b2] x} h\u03b2 := by\n  obtain \u27e8S, hS\u27e9 := exists_support x\n  use S\n  intro \u03c1 h\u03c1\n  conv_rhs => rw [\u2190 hS \u03c1 h\u03c1]\n  simp only [\u2190 forget_mem_forget, smul_forget, StrSet.mem_smul_iff]\n  ext y\n  rw [Set.mem_smul_set_iff_inv_smul_mem, Set.mem_setOf_eq, Set.mem_setOf_eq,\n    smul_forget, allPermForget_inv, allPermSderiv_forget']\n\ntheorem tSet_ext' {\u03b1 \u03b2 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (x y : TSet \u03b1)\n    (h : \u2200 z : TSet \u03b2, z \u2208[h\u03b2] x \u2194 z \u2208[h\u03b2] y) : x = y :=\n  letI : Level := \u27e8\u03b1\u27e9\n  letI : LeLevel \u03b1 := \u27e8le_rfl\u27e9\n  letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n  tSet_ext h\u03b2 x y h\n\n@[simp]\ntheorem TSet.mem_smul_iff' {\u03b1 \u03b2 : TypeIndex}\n    {x : TSet \u03b2} {y : TSet \u03b1} (h : \u03b2 < \u03b1) (\u03c1 : AllPerm \u03b1) :\n    x \u2208[h] \u03c1 \u2022 y \u2194 \u03c1\u207b\u00b9 \u2198 h \u2022 x \u2208[h] y := by\n  letI : Level := \u27e8\u03b1.recBotCoe (Nonempty.some inferInstance) id\u27e9\n  letI : LeLevel \u03b1 := \u27e8\u03b1.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n    (show \u03b1.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n  letI : LtLevel \u03b2 := \u27e8h.trans_le LeLevel.elim\u27e9\n  exact mem_smul_iff h \u03c1  -- For some reason, using `exact` instead of term mode speeds this up!\n\ndef singleton {\u03b1 \u03b2 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (x : TSet \u03b2) : TSet \u03b1 :=\n  letI : Level := \u27e8\u03b1\u27e9\n  letI : LeLevel \u03b1 := \u27e8le_rfl\u27e9\n  letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n  PreCoherentData.singleton h\u03b2 x\n\n@[simp]\ntheorem typedMem_singleton_iff' {\u03b1 \u03b2 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (x y : TSet \u03b2) :\n    y \u2208[h\u03b2] singleton h\u03b2 x \u2194 y = x :=\n  letI : Level := \u27e8\u03b1\u27e9\n  letI : LeLevel \u03b1 := \u27e8le_rfl\u27e9\n  letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n  typedMem_singleton_iff h\u03b2 x y\n\n@[simp]\ntheorem smul_singleton {\u03b1 \u03b2 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (x : TSet \u03b2) (\u03c1 : AllPerm \u03b1) :\n    \u03c1 \u2022 singleton h\u03b2 x = singleton h\u03b2 (\u03c1 \u2198 h\u03b2 \u2022 x) := by\n  apply tSet_ext' h\u03b2\n  intro z\n  rw [TSet.mem_smul_iff', allPerm_inv_sderiv', typedMem_singleton_iff', typedMem_singleton_iff',\n    inv_smul_eq_iff]\n\ntheorem singleton_injective {\u03b1 \u03b2 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) :\n    Function.Injective (singleton h\u03b2) := by\n  intro x y hxy\n  have := typedMem_singleton_iff' h\u03b2 x y\n  rw [hxy, typedMem_singleton_iff'] at this\n  exact (this.mp rfl).symm\n\n@[simp]\ntheorem singleton_inj {\u03b1 \u03b2 : \u039b} {h\u03b2 : (\u03b2 : TypeIndex) < \u03b1} {x y : TSet \u03b2} :\n    singleton h\u03b2 x = singleton h\u03b2 y \u2194 x = y :=\n  (singleton_injective h\u03b2).eq_iff\n\ntheorem sUnion_singleton_symmetric_aux' {\u03b1 \u03b2 \u03b3 : \u039b}\n    (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (s : Set (TSet \u03b3)) (S : Support \u03b1)\n    (hS : \u2200 \u03c1 : AllPerm \u03b1, \u03c1\u1d41 \u2022 S = S \u2192 \u03c1 \u2198 h\u03b2 \u2022 singleton h\u03b3 '' s = singleton h\u03b3 '' s) :\n    letI : Level := \u27e8\u03b1\u27e9\n    letI : LeLevel \u03b1 := \u27e8le_rfl\u27e9\n    \u2200 (\u03c1 : AllPerm \u03b2), \u03c1\u1d41 \u2022 S.strong \u2198 h\u03b2 = S.strong \u2198 h\u03b2 \u2192 \u03c1 \u2198 h\u03b3 \u2022 s \u2286 s := by\n  letI : Level := \u27e8\u03b1\u27e9\n  letI : LeLevel \u03b1 := \u27e8le_rfl\u27e9\n  letI : LtLevel \u03b2 := \u27e8h\u03b2\u27e9\n  rintro \u03c1 h\u03c1 _ \u27e8x, hx, rfl\u27e9\n  obtain \u27e8T, hT\u27e9 := exists_support x\n  obtain \u27e8\u03c1', h\u03c1'\u2081, h\u03c1'\u2082\u27e9 := Support.exists_allowable_of_fixes S.strong S.strong_strong T \u03c1 h\u03b3 h\u03c1\n  have h\u03c1's := hS \u03c1' (smul_eq_of_le (S.subsupport_strong.le) h\u03c1'\u2081)\n  have h\u03c1'x : \u03c1' \u2198 h\u03b2 \u2198 h\u03b3 \u2022 x = \u03c1 \u2198 h\u03b3 \u2022 x := by\n    apply hT.smul_eq_smul\n    simp only [allPermSderiv_forget', allPermSderiv_forget, WithBot.recBotCoe_coe, id_eq, h\u03c1'\u2082]\n  dsimp only\n  rw [\u2190 h\u03c1'x]\n  have := (Set.ext_iff.mp h\u03c1's (\u03c1' \u2198 h\u03b2 \u2022 singleton h\u03b3 x)).mp \u27e8_, Set.mem_image_of_mem _ hx, rfl\u27e9\n  rw [smul_singleton] at this\n  rwa [(singleton_injective h\u03b3).mem_set_image] at this\n\ntheorem sUnion_singleton_symmetric_aux {\u03b1 \u03b2 \u03b3 : \u039b}\n    (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (s : Set (TSet \u03b3)) (S : Support \u03b1)\n    (hS : \u2200 \u03c1 : AllPerm \u03b1, \u03c1\u1d41 \u2022 S = S \u2192 \u03c1 \u2198 h\u03b2 \u2022 singleton h\u03b3 '' s = singleton h\u03b3 '' s) :\n    letI : Level := \u27e8\u03b1\u27e9\n    letI : LeLevel \u03b1 := \u27e8le_rfl\u27e9\n    \u2200 (\u03c1 : AllPerm \u03b2), \u03c1\u1d41 \u2022 S.strong \u2198 h\u03b2 = S.strong \u2198 h\u03b2 \u2192 \u03c1 \u2198 h\u03b3 \u2022 s = s := by\n  intro \u03c1 h\u03c1\n  apply subset_antisymm\n  \u00b7 exact sUnion_singleton_symmetric_aux' h\u03b3 h\u03b2 s S hS \u03c1 h\u03c1\n  \u00b7 have := sUnion_singleton_symmetric_aux' h\u03b3 h\u03b2 s S hS \u03c1\u207b\u00b9 ?_\n    \u00b7 rwa [allPerm_inv_sderiv', Set.set_smul_subset_iff, inv_inv] at this\n    \u00b7 rw [allPermForget_inv, inv_smul_eq_iff, h\u03c1]\n\n", "theoremStatement": "theorem sUnion_singleton_symmetric {\u03b1 \u03b2 \u03b3 : \u039b} (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2) (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1)\n    (s : Set (TSet \u03b3)) (hs : Symmetric (singleton h\u03b3 '' s) h\u03b2) :\n    Symmetric s h\u03b3 ", "theoremName": "ConNF.sUnion_singleton_symmetric", "fileCreated": {"commit": "6fdc87c6b30b73931407a372f1430ecf0fef7601", "date": "2024-12-03"}, "theoremCreated": {"commit": "2e25ffbc94af48261308cea0d8c55205cc388ef0", "date": "2024-12-01"}, "file": "ConNF/ConNF/Model/TTT.lean", "module": "ConNF.Model.TTT", "jsonFile": "ConNF.Model.TTT.jsonl", "positionMetadata": {"lineInFile": 251, "tokenPositionInFile": 9233, "theoremPositionInFile": 22}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 27, "numPremises": 49}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  letI : Level := \u27e8\u03b1\u27e9\n  letI : LeLevel \u03b1 := \u27e8le_rfl\u27e9\n  obtain \u27e8S, hS\u27e9 := hs\n  use S.strong \u2198 h\u03b2\n  exact sUnion_singleton_symmetric_aux h\u03b3 h\u03b2 s S hS", "proofType": "tactic", "proofLengthLines": 5, "proofLengthTokens": 153}}
{"srcContext": "import ConNF.Model.TTT\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\nnamespace TSet\n\ntheorem exists_inter (x y : TSet \u03b1) :\n    \u2203 w : TSet \u03b1, \u2200 z : TSet \u03b2, z \u2208[h\u03b2] w \u2194 z \u2208[h\u03b2] x \u2227 z \u2208[h\u03b2] y := by\n  refine exists_of_symmetric {z | z \u2208[h\u03b2] x \u2227 z \u2208[h\u03b2] y} h\u03b2 ?_\n  obtain \u27e8S, hS\u27e9 := symmetric x h\u03b2\n  obtain \u27e8T, hT\u27e9 := symmetric y h\u03b2\n  use S + T\n  intro \u03c1 h\u03c1\n  specialize hS \u03c1 (smul_eq_of_le Support.le_add_right h\u03c1)\n  specialize hT \u03c1 (smul_eq_of_le Support.le_add_left h\u03c1)\n  simp [Set.ext_iff, Set.mem_smul_set_iff_inv_smul_mem] at hS hT \u22a2\n  aesop\n\ntheorem exists_compl (x : TSet \u03b1) :\n    \u2203 y : TSet \u03b1, \u2200 z : TSet \u03b2, z \u2208[h\u03b2] y \u2194 \u00acz \u2208[h\u03b2] x := by\n  refine exists_of_symmetric {z | \u00acz \u2208[h\u03b2] x} h\u03b2 ?_\n  obtain \u27e8S, hS\u27e9 := symmetric x h\u03b2\n  use S\n  intro \u03c1 h\u03c1\n  specialize hS \u03c1 h\u03c1\n  simp [Set.ext_iff, Set.mem_smul_set_iff_inv_smul_mem] at hS \u22a2\n  aesop\n\ntheorem exists_up (x y : TSet \u03b2) :\n    \u2203 w : TSet \u03b1, \u2200 z : TSet \u03b2, z \u2208[h\u03b2] w \u2194 z = x \u2228 z = y := by\n  refine exists_of_symmetric {x, y} h\u03b2 ?_\n  obtain \u27e8S, hS\u27e9 := exists_support x\n  obtain \u27e8T, hT\u27e9 := exists_support y\n  use (S + T) \u2197 h\u03b2\n  intro \u03c1 h\u03c1\n  rw [Support.smul_scoderiv, Support.scoderiv_inj, \u2190 allPermSderiv_forget'] at h\u03c1\n  specialize hS (\u03c1 \u2198 h\u03b2) (smul_eq_of_le Support.le_add_right h\u03c1)\n  specialize hT (\u03c1 \u2198 h\u03b2) (smul_eq_of_le Support.le_add_left h\u03c1)\n  simp only [Set.smul_set_def, Set.image, Set.mem_insert_iff, Set.mem_singleton_iff,\n    exists_eq_or_imp, hS, exists_eq_left, hT]\n  ext z\n  rw [Set.mem_insert_iff, Set.mem_singleton_iff, Set.mem_setOf_eq]\n  aesop\n\n/-- The unordered pair. -/\ndef up (x y : TSet \u03b2) : TSet \u03b1 :=\n  (exists_up h\u03b2 x y).choose\n\n@[simp]\ntheorem mem_up_iff (x y z : TSet \u03b2) :\n    z \u2208[h\u03b2] up h\u03b2 x y \u2194 z = x \u2228 z = y :=\n  (exists_up h\u03b2 x y).choose_spec z\n\n/-- The Kuratowski ordered pair. -/\ndef op (x y : TSet \u03b3) : TSet \u03b1 :=\n  up h\u03b2 (singleton h\u03b3 x) (up h\u03b3 x y)\n\ntheorem up_injective {x y z w : TSet \u03b2} (h : up h\u03b2 x y = up h\u03b2 z w) :\n    (x = z \u2227 y = w) \u2228 (x = w \u2227 y = z) := by\n  have h\u2081 := mem_up_iff h\u03b2 x y z\n  have h\u2082 := mem_up_iff h\u03b2 x y w\n  have h\u2083 := mem_up_iff h\u03b2 z w x\n  have h\u2084 := mem_up_iff h\u03b2 z w y\n  rw [h, mem_up_iff] at h\u2081 h\u2082\n  rw [\u2190 h, mem_up_iff] at h\u2083 h\u2084\n  aesop\n\n@[simp]\ntheorem up_inj (x y z w : TSet \u03b2) :\n    up h\u03b2 x y = up h\u03b2 z w \u2194 (x = z \u2227 y = w) \u2228 (x = w \u2227 y = z) := by\n  constructor\n  \u00b7 exact up_injective h\u03b2\n  \u00b7 rintro (\u27e8rfl, rfl\u27e9 | \u27e8rfl, rfl\u27e9)\n    \u00b7 rfl\n    \u00b7 apply tSet_ext' h\u03b2\n      aesop\n\n@[simp]\ntheorem up_self {x : TSet \u03b2} :\n    up h\u03b2 x x = singleton h\u03b2 x := by\n  apply tSet_ext' h\u03b2\n  aesop\n\n@[simp]\ntheorem up_eq_singleton_iff (x y z : TSet \u03b2) :\n    up h\u03b2 x y = singleton h\u03b2 z \u2194 x = z \u2227 y = z := by\n  constructor\n  \u00b7 intro h\n    have h\u2081 := typedMem_singleton_iff' h\u03b2 z x\n    have h\u2082 := typedMem_singleton_iff' h\u03b2 z y\n    rw [\u2190 h, mem_up_iff] at h\u2081 h\u2082\n    aesop\n  \u00b7 rintro \u27e8rfl, rfl\u27e9\n    rw [up_self]\n\n@[simp]\ntheorem singleton_eq_up_iff (x y z : TSet \u03b2) :\n    singleton h\u03b2 z = up h\u03b2 x y \u2194 x = z \u2227 y = z := by\n  rw [\u2190 up_eq_singleton_iff h\u03b2 x y z, eq_comm]\n\ntheorem op_injective {x y z w : TSet \u03b3} (h : op h\u03b2 h\u03b3 x y = op h\u03b2 h\u03b3 z w) :\n    x = z \u2227 y = w := by\n  rw [op, op] at h\n  simp only [up_inj, singleton_inj, singleton_eq_up_iff, up_eq_singleton_iff] at h\n  obtain (\u27e8rfl, \u27e8h, rfl\u27e9 | \u27e8rfl, rfl\u27e9\u27e9 | \u27e8\u27e8rfl, rfl\u27e9, \u27e8h, rfl\u27e9\u27e9) := h <;> simp only [and_self]\n\n@[simp]\ntheorem op_inj (x y z w : TSet \u03b3) :\n    op h\u03b2 h\u03b3 x y = op h\u03b2 h\u03b3 z w \u2194 x = z \u2227 y = w := by\n  constructor\n  \u00b7 exact op_injective h\u03b2 h\u03b3\n  \u00b7 rintro \u27e8rfl, rfl\u27e9\n    rfl\n\n@[simp]\ntheorem op_eq_singleton_iff (x y : TSet \u03b3) (z : TSet \u03b2) :\n    op h\u03b2 h\u03b3 x y = singleton h\u03b2 z \u2194 singleton h\u03b3 x = z \u2227 singleton h\u03b3 y = z := by\n  rw [op, up_eq_singleton_iff, and_congr_right_iff]\n  rintro rfl\n  simp only [up_eq_singleton_iff, true_and, singleton_inj]\n\n@[simp]\ntheorem smul_up (x y : TSet \u03b2) (\u03c1 : AllPerm \u03b1) :\n    \u03c1 \u2022 up h\u03b2 x y = up h\u03b2 (\u03c1 \u2198 h\u03b2 \u2022 x) (\u03c1 \u2198 h\u03b2 \u2022 y) := by\n  apply tSet_ext' h\u03b2\n  aesop\n\n@[simp]\ntheorem smul_op (x y : TSet \u03b3) (\u03c1 : AllPerm \u03b1) :\n    \u03c1 \u2022 op h\u03b2 h\u03b3 x y = op h\u03b2 h\u03b3 (\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2022 x) (\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2022 y) := by\n  apply tSet_ext' h\u03b2\n  simp only [op, smul_up, smul_singleton, mem_up_iff, implies_true]\n\ntheorem exists_singletonImage (x : TSet \u03b2) :\n    \u2203 y : TSet \u03b1, \u2200 z w,\n    op h\u03b3 h\u03b4 (singleton h\u03b5 z) (singleton h\u03b5 w) \u2208[h\u03b2] y \u2194 op h\u03b4 h\u03b5 z w \u2208[h\u03b3] x := by\n  have := exists_of_symmetric {u | \u2203 z w : TSet \u03b5, op h\u03b4 h\u03b5 z w \u2208[h\u03b3] x \u2227\n      u = op h\u03b3 h\u03b4 (singleton h\u03b5 z) (singleton h\u03b5 w)} h\u03b2 ?_\n  \u00b7 obtain \u27e8y, hy\u27e9 := this\n    use y\n    intro z w\n    rw [hy]\n    simp only [Set.mem_setOf_eq, op_inj, singleton_inj, exists_eq_right_right', exists_eq_right']\n  \u00b7 obtain \u27e8S, hS\u27e9 := exists_support x\n    use S \u2197 h\u03b2\n    intro \u03c1 h\u03c1\n    rw [Support.smul_scoderiv, Support.scoderiv_inj, \u2190 allPermSderiv_forget'] at h\u03c1\n    specialize hS (\u03c1 \u2198 h\u03b2) h\u03c1\n    ext z\n    constructor\n    \u00b7 rintro \u27e8_, \u27e8z, w, hab, rfl\u27e9, rfl\u27e9\n      refine \u27e8\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2022 z, \u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2022 w, ?_, ?_\u27e9\n      \u00b7 rwa [\u2190 hS, mem_smul_iff', smul_op, allPerm_inv_sderiv', allPerm_inv_sderiv',\n          allPerm_inv_sderiv', inv_smul_smul, inv_smul_smul]\n      \u00b7 simp only [smul_op, smul_singleton]\n    \u00b7 rintro \u27e8z, w, hab, rfl\u27e9\n      refine \u27e8\u03c1\u207b\u00b9 \u2198 h\u03b2 \u2022 op h\u03b3 h\u03b4 (singleton h\u03b5 z) (singleton h\u03b5 w), ?_, ?_\u27e9\n      \u00b7 simp only [allPerm_inv_sderiv', smul_op, smul_singleton, Set.mem_setOf_eq, op_inj,\n          singleton_inj, exists_eq_right_right', exists_eq_right']\n        rw [smul_eq_iff_eq_inv_smul] at hS\n        rw [hS]\n        simp only [mem_smul_iff', inv_inv, smul_op, smul_inv_smul]\n        exact hab\n      \u00b7 simp only [allPerm_inv_sderiv', smul_inv_smul]\n\ntheorem exists_insertion2 (x : TSet \u03b3) :\n    \u2203 y : TSet \u03b1, \u2200 a b c, op h\u03b3 h\u03b4 (singleton h\u03b5 (singleton h\u03b6 a)) (op h\u03b5 h\u03b6 b c) \u2208[h\u03b2] y \u2194\n    op h\u03b5 h\u03b6 a c \u2208[h\u03b4] x := by\n  have := exists_of_symmetric {u | \u2203 a b c : TSet \u03b6, op h\u03b5 h\u03b6 a c \u2208[h\u03b4] x \u2227\n      u = op h\u03b3 h\u03b4 (singleton h\u03b5 (singleton h\u03b6 a)) (op h\u03b5 h\u03b6 b c)} h\u03b2 ?_\n  \u00b7 obtain \u27e8y, hy\u27e9 := this\n    use y\n    intro a b c\n    rw [hy]\n    constructor\n    \u00b7 rintro \u27e8a', b', c', h\u2081, h\u2082\u27e9\n      simp only [op_inj, singleton_inj] at h\u2082\n      obtain \u27e8rfl, rfl, rfl\u27e9 := h\u2082\n      exact h\u2081\n    \u00b7 intro h\n      exact \u27e8a, b, c, h, rfl\u27e9\n  \u00b7 obtain \u27e8S, hS\u27e9 := exists_support x\n    use S \u2197 h\u03b3 \u2197 h\u03b2\n    intro \u03c1 h\u03c1\n    simp only [Support.smul_scoderiv, Support.scoderiv_inj, \u2190 allPermSderiv_forget'] at h\u03c1\n    specialize hS (\u03c1 \u2198 h\u03b2 \u2198 h\u03b3) h\u03c1\n    ext z\n    constructor\n    \u00b7 rintro \u27e8_, \u27e8a, b, c, hx, rfl\u27e9, rfl\u27e9\n      refine \u27e8\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 a, \u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 b,\n        \u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 c, ?_, ?_\u27e9\n      \u00b7 rw [\u2190 hS]\n        simp only [mem_smul_iff', allPerm_inv_sderiv', smul_op, inv_smul_smul]\n        exact hx\n      \u00b7 simp only [smul_op, smul_singleton]\n    \u00b7 rintro \u27e8a, b, c, hx, rfl\u27e9\n      rw [Set.mem_smul_set_iff_inv_smul_mem]\n      refine \u27e8\u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 a, \u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 b,\n        \u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 c, ?_, ?_\u27e9\n      \u00b7 rw [smul_eq_iff_eq_inv_smul] at hS\n        rw [hS, mem_smul_iff']\n        simp only [inv_inv, allPerm_inv_sderiv', smul_op, smul_inv_smul]\n        exact hx\n      \u00b7 simp only [smul_op, allPerm_inv_sderiv', smul_singleton]\n\ntheorem exists_insertion3 (x : TSet \u03b3) :\n    \u2203 y : TSet \u03b1, \u2200 a b c, op h\u03b3 h\u03b4 (singleton h\u03b5 (singleton h\u03b6 a)) (op h\u03b5 h\u03b6 b c) \u2208[h\u03b2] y \u2194\n    op h\u03b5 h\u03b6 a b \u2208[h\u03b4] x := by\n  have := exists_of_symmetric {u | \u2203 a b c : TSet \u03b6, op h\u03b5 h\u03b6 a b \u2208[h\u03b4] x \u2227\n      u = op h\u03b3 h\u03b4 (singleton h\u03b5 (singleton h\u03b6 a)) (op h\u03b5 h\u03b6 b c)} h\u03b2 ?_\n  \u00b7 obtain \u27e8y, hy\u27e9 := this\n    use y\n    intro a b c\n    rw [hy]\n    constructor\n    \u00b7 rintro \u27e8a', b', c', h\u2081, h\u2082\u27e9\n      simp only [op_inj, singleton_inj] at h\u2082\n      obtain \u27e8rfl, rfl, rfl\u27e9 := h\u2082\n      exact h\u2081\n    \u00b7 intro h\n      exact \u27e8a, b, c, h, rfl\u27e9\n  \u00b7 obtain \u27e8S, hS\u27e9 := exists_support x\n    use S \u2197 h\u03b3 \u2197 h\u03b2\n    intro \u03c1 h\u03c1\n    simp only [Support.smul_scoderiv, Support.scoderiv_inj, \u2190 allPermSderiv_forget'] at h\u03c1\n    specialize hS (\u03c1 \u2198 h\u03b2 \u2198 h\u03b3) h\u03c1\n    ext z\n    constructor\n    \u00b7 rintro \u27e8_, \u27e8a, b, c, hx, rfl\u27e9, rfl\u27e9\n      refine \u27e8\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 a, \u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 b,\n        \u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 c, ?_, ?_\u27e9\n      \u00b7 rw [\u2190 hS]\n        simp only [mem_smul_iff', allPerm_inv_sderiv', smul_op, inv_smul_smul]\n        exact hx\n      \u00b7 simp only [smul_op, smul_singleton]\n    \u00b7 rintro \u27e8a, b, c, hx, rfl\u27e9\n      rw [Set.mem_smul_set_iff_inv_smul_mem]\n      refine \u27e8\u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 a, \u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 b,\n        \u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5 \u2198 h\u03b6 \u2022 c, ?_, ?_\u27e9\n      \u00b7 rw [smul_eq_iff_eq_inv_smul] at hS\n        rw [hS, mem_smul_iff']\n        simp only [inv_inv, allPerm_inv_sderiv', smul_op, smul_inv_smul]\n        exact hx\n      \u00b7 simp only [smul_op, allPerm_inv_sderiv', smul_singleton]\n\ntheorem exists_cross (x : TSet \u03b3) :\n    \u2203 y : TSet \u03b1, \u2200 a, a \u2208[h\u03b2] y \u2194 \u2203 b c, a = op h\u03b3 h\u03b4 b c \u2227 c \u2208[h\u03b4] x := by\n  have := exists_of_symmetric {a | \u2203 b c, a = op h\u03b3 h\u03b4 b c \u2227 c \u2208[h\u03b4] x} h\u03b2 ?_\n  \u00b7 obtain \u27e8y, hy\u27e9 := this\n    use y\n    intro a\n    rw [hy]\n    rfl\n  \u00b7 obtain \u27e8S, hS\u27e9 := exists_support x\n    use S \u2197 h\u03b3 \u2197 h\u03b2\n    intro \u03c1 h\u03c1\n    simp only [Support.smul_scoderiv, Support.scoderiv_inj, \u2190 allPermSderiv_forget'] at h\u03c1\n    specialize hS (\u03c1 \u2198 h\u03b2 \u2198 h\u03b3) h\u03c1\n    ext z\n    constructor\n    \u00b7 rintro \u27e8_, \u27e8a, b, rfl, hab\u27e9, rfl\u27e9\n      refine \u27e8\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2022 a, \u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2022 b, ?_, ?_\u27e9\n      \u00b7 simp only [smul_op]\n      \u00b7 rw [\u2190 hS]\n        simp only [mem_smul_iff', allPerm_inv_sderiv', inv_smul_smul]\n        exact hab\n    \u00b7 rintro \u27e8a, b, rfl, hab\u27e9\n      rw [Set.mem_smul_set_iff_inv_smul_mem]\n      refine \u27e8\u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2022 a, \u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2022 b, ?_, ?_\u27e9\n      \u00b7 simp only [smul_op, allPerm_inv_sderiv']\n      \u00b7 rw [smul_eq_iff_eq_inv_smul] at hS\n        rw [hS]\n        simp only [allPerm_inv_sderiv', mem_smul_iff', inv_inv, smul_inv_smul]\n        exact hab\n\ntheorem exists_typeLower (x : TSet \u03b1) :\n    \u2203 y : TSet \u03b4, \u2200 a, a \u2208[h\u03b5] y \u2194 \u2200 b, op h\u03b3 h\u03b4 b (singleton h\u03b5 a) \u2208[h\u03b2] x := by\n  have := exists_of_symmetric {a | \u2200 b, op h\u03b3 h\u03b4 b (singleton h\u03b5 a) \u2208[h\u03b2] x} h\u03b5 ?_\n  \u00b7 obtain \u27e8y, hy\u27e9 := this\n    use y\n    intro a\n    rw [hy]\n    rfl\n  \u00b7 apply sUnion_singleton_symmetric h\u03b5 h\u03b4\n    apply sUnion_singleton_symmetric h\u03b4 h\u03b3\n    apply sUnion_singleton_symmetric h\u03b3 h\u03b2\n    obtain \u27e8S, hS\u27e9 := exists_support x\n    use S\n    intro \u03c1 h\u03c1\n    specialize hS \u03c1 h\u03c1\n    ext z\n    constructor\n    \u00b7 rintro \u27e8_, \u27e8_, \u27e8a, \u27e8b, hb, rfl\u27e9, rfl\u27e9, rfl\u27e9, rfl\u27e9\n      simp only [smul_singleton, Set.mem_image, Set.mem_setOf_eq, exists_exists_and_eq_and,\n        singleton_inj, exists_eq_right]\n      intro c\n      have := hb (\u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2022 c)\n      rw [smul_eq_iff_eq_inv_smul] at hS\n      rw [hS] at this\n      simp only [allPerm_inv_sderiv', mem_smul_iff', inv_inv, smul_op, smul_inv_smul,\n        smul_singleton] at this\n      exact this\n    \u00b7 rintro \u27e8_, \u27e8a, \u27e8b, hb, rfl\u27e9, rfl\u27e9, rfl\u27e9\n      rw [Set.mem_smul_set_iff_inv_smul_mem]\n      simp only [smul_singleton, allPerm_inv_sderiv', Set.mem_image, Set.mem_setOf_eq,\n        exists_exists_and_eq_and, singleton_inj, exists_eq_right]\n      intro c\n      have := hb (\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2022 c)\n      rw [\u2190 hS] at this\n      simp only [mem_smul_iff', allPerm_inv_sderiv', smul_op, inv_smul_smul, smul_singleton] at this\n      exact this\n\ntheorem exists_converse (x : TSet \u03b1) :\n    \u2203 y : TSet \u03b1, \u2200 a b, op h\u03b3 h\u03b4 a b \u2208[h\u03b2] y \u2194 op h\u03b3 h\u03b4 b a \u2208[h\u03b2] x := by\n  have := exists_of_symmetric {a | \u2203 b c, a = op h\u03b3 h\u03b4 b c \u2227 op h\u03b3 h\u03b4 c b \u2208[h\u03b2] x} h\u03b2 ?_\n  \u00b7 obtain \u27e8y, hy\u27e9 := this\n    use y\n    intro a b\n    rw [hy]\n    simp only [Set.mem_setOf_eq, op_inj]\n    constructor\n    \u00b7 rintro \u27e8a', b', \u27e8rfl, rfl\u27e9, h\u27e9\n      exact h\n    \u00b7 intro h\n      exact \u27e8a, b, \u27e8rfl, rfl\u27e9, h\u27e9\n  \u00b7 obtain \u27e8S, hS\u27e9 := exists_support x\n    use S\n    intro \u03c1 h\u03c1\n    specialize hS \u03c1 h\u03c1\n    ext z\n    constructor\n    \u00b7 rintro \u27e8_, \u27e8a, b, rfl, hab\u27e9, rfl\u27e9\n      refine \u27e8\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2022 a, \u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2022 b, ?_, ?_\u27e9\n      \u00b7 simp only [smul_op]\n      \u00b7 rw [\u2190 hS]\n        simp only [mem_smul_iff', allPerm_inv_sderiv', smul_op, inv_smul_smul]\n        exact hab\n    \u00b7 rintro \u27e8a, b, rfl, hab\u27e9\n      rw [Set.mem_smul_set_iff_inv_smul_mem]\n      refine \u27e8\u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2022 a, \u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4 \u2022 b, ?_, ?_\u27e9\n      \u00b7 simp only [smul_op, allPerm_inv_sderiv']\n      \u00b7 rw [smul_eq_iff_eq_inv_smul] at hS\n        rw [hS]\n        simp only [allPerm_inv_sderiv', mem_smul_iff', inv_inv, smul_op, smul_inv_smul]\n        exact hab\n\n", "theoremStatement": "theorem exists_cardinalOne :\n    \u2203 x : TSet \u03b1, \u2200 a : TSet \u03b2, a \u2208[h\u03b2] x \u2194 \u2203 b, a = singleton h\u03b3 b ", "theoremName": "ConNF.TSet.exists_cardinalOne", "fileCreated": {"commit": "f804f5c71cfaa98223fc227dd822801e8bf77004", "date": "2024-03-30"}, "theoremCreated": {"commit": "f7c233c7f7fd9d8b74595bbfa2bbbd49d538ef59", "date": "2024-12-02"}, "file": "ConNF/ConNF/Model/Hailperin.lean", "module": "ConNF.Model.Hailperin", "jsonFile": "ConNF.Model.Hailperin.jsonl", "positionMetadata": {"lineInFile": 365, "tokenPositionInFile": 12537, "theoremPositionInFile": 22}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 31, "numPremises": 83}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  have := exists_of_symmetric {a | \u2203 b, a = singleton h\u03b3 b} h\u03b2 ?_\n  \u00b7 obtain \u27e8y, hy\u27e9 := this\n    use y\n    intro a\n    rw [hy]\n    rfl\n  \u00b7 use \u27e8.empty, .empty\u27e9\n    intro \u03c1 h\u03c1\n    ext z\n    constructor\n    \u00b7 rintro \u27e8z, \u27e8a, ha\u27e9, rfl\u27e9\n      refine \u27e8\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2022 a, ?_\u27e9\n      simp only [ha, smul_singleton]\n    \u00b7 rintro \u27e8a, ha\u27e9\n      rw [Set.mem_smul_set_iff_inv_smul_mem]\n      refine \u27e8\u03c1\u207b\u00b9 \u2198 h\u03b2 \u2198 h\u03b3 \u2022 a, ?_\u27e9\n      simp only [ha, smul_singleton, allPerm_inv_sderiv']", "proofType": "tactic", "proofLengthLines": 17, "proofLengthTokens": 470}}
{"srcContext": "import ConNF.Model.Result\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal ConNF.TSet\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\ndef union (x y : TSet \u03b1) : TSet \u03b1 :=\n  (x\u1d9c' \u2293' y\u1d9c')\u1d9c'\n\nnotation:68 x:68 \" \u2294[\" h \"] \" y:68 => _root_.ConNF.union h x y\nnotation:68 x:68 \" \u2294' \" y:68 => x \u2294[by assumption] y\n\n@[simp]\ntheorem mem_union_iff (x y : TSet \u03b1) :\n    \u2200 z : TSet \u03b2, z \u2208' x \u2294' y \u2194 z \u2208' x \u2228 z \u2208' y := by\n  rw [union]\n  intro z\n  rw [mem_compl_iff, mem_inter_iff, mem_compl_iff, mem_compl_iff, or_iff_not_and_not]\n\ndef higherIndex (\u03b1 : \u039b) : \u039b :=\n  (exists_gt \u03b1).choose\n\n", "theoremStatement": "theorem lt_higherIndex {\u03b1 : \u039b} :\n    (\u03b1 : TypeIndex) < higherIndex \u03b1 ", "theoremName": "ConNF.lt_higherIndex", "fileCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "theoremCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "file": "ConNF/ConNF/External/Basic.lean", "module": "ConNF.External.Basic", "jsonFile": "ConNF.External.Basic.jsonl", "positionMetadata": {"lineInFile": 39, "tokenPositionInFile": 817, "theoremPositionInFile": 5}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 6, "numPremises": 21}, "proofMetadata": {"hasProof": true, "proof": ":=\n  WithBot.coe_lt_coe.mpr (exists_gt \u03b1).choose_spec", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 53}}
{"srcContext": "import ConNF.External.Basic\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal ConNF.TSet\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\n/-- A set in our model that is a well-order. Internal well-orders are exactly external well-orders,\nso we externalise the definition for convenience. -/\ndef InternalWellOrder (r : TSet \u03b1) : Prop :=\n  IsWellOrder (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).field\n    (InvImage (ExternalRel h\u03b2 h\u03b3 h\u03b4 r) Subtype.val)\n\ndef InternallyWellOrdered (x : TSet \u03b3) : Prop :=\n  {y : TSet \u03b4 | y \u2208' x}.Subsingleton \u2228 (\u2203 r, InternalWellOrder h\u03b2 h\u03b3 h\u03b4 r \u2227 x = field h\u03b2 h\u03b3 h\u03b4 r)\n\n@[simp]\ntheorem externalRel_smul (r : TSet \u03b1) (\u03c1 : AllPerm \u03b1) :\n    ExternalRel h\u03b2 h\u03b3 h\u03b4 (\u03c1 \u2022 r) =\n      InvImage (ExternalRel h\u03b2 h\u03b3 h\u03b4 r) ((\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4)\u207b\u00b9 \u2022 \u00b7) := by\n  ext a b\n  simp only [ExternalRel, mem_smul_iff', allPerm_inv_sderiv', smul_op, InvImage]\n\nomit [Params] in\n/-- Well-orders are rigid. -/\ntheorem apply_eq_of_isWellOrder {X : Type _} {r : Rel X X} {f : X \u2192 X}\n    (hr : IsWellOrder X r) (hf : Function.Bijective f) (hf' : \u2200 x y, r x y \u2194 r (f x) (f y)) :\n    \u2200 x, f x = x := by\n  let emb : r \u227ci r := \u27e8\u27e8\u27e8f, hf.injective\u27e9, \u03bb {a b} \u21a6 (hf' a b).symm\u27e9, ?_\u27e9\n  \u00b7 have : emb = InitialSeg.refl r := Subsingleton.elim _ _\n    intro x\n    exact congr_arg (\u03bb f \u21a6 f x) this\n  \u00b7 intro a b h\n    exact hf.surjective _\n\nomit [Params] in\ntheorem apply_eq_of_isWellOrder' {X : Type _} {r : Rel X X} {f : X \u2192 X}\n    (hr : IsWellOrder r.field (InvImage r Subtype.val)) (hf : Function.Bijective f)\n    (hf' : \u2200 x y, r x y \u2194 r (f x) (f y)) :\n    \u2200 x \u2208 r.field, f x = x := by\n  have : \u2200 x \u2208 r.field, f x \u2208 r.field := by\n    rintro x (\u27e8y, h\u27e9 | \u27e8y, h\u27e9)\n    \u00b7 exact Or.inl \u27e8f y, (hf' x y).mp h\u27e9\n    \u00b7 exact Or.inr \u27e8f y, (hf' y x).mp h\u27e9\n  have := apply_eq_of_isWellOrder (f := \u03bb x \u21a6 \u27e8f x.val, this x.val x.prop\u27e9) hr \u27e8?_, ?_\u27e9 ?_\n  \u00b7 intro x hx\n    exact congr_arg Subtype.val (this \u27e8x, hx\u27e9)\n  \u00b7 intro x y h\n    rw [Subtype.mk.injEq] at h\n    exact Subtype.val_injective (hf.injective h)\n  \u00b7 intro x\n    obtain \u27e8y, hy\u27e9 := hf.surjective x.val\n    refine \u27e8\u27e8y, ?_\u27e9, ?_\u27e9\n    \u00b7 obtain (\u27e8z, h\u27e9 | \u27e8z, h\u27e9) := x.prop <;>\n          rw [\u2190 hy] at h <;>\n          obtain \u27e8z, rfl\u27e9 := hf.surjective z\n      \u00b7 exact Or.inl \u27e8z, (hf' y z).mpr h\u27e9\n      \u00b7 exact Or.inr \u27e8z, (hf' z y).mpr h\u27e9\n    \u00b7 simp only [hy]\n  \u00b7 intros\n    apply hf'\n\ntheorem exists_common_support_of_internallyWellOrdered' {x : TSet \u03b4}\n    (h : InternallyWellOrdered h\u03b3 h\u03b4 h\u03b5 x) :\n    \u2203 S : Support \u03b2, \u2200 y, y \u2208' x \u2192 S.Supports { { {y}' }' }[h\u03b3] := by\n  obtain (h | \u27e8r, h, rfl\u27e9) := h\n  \u00b7 obtain (h | \u27e8y, hy\u27e9) := h.eq_empty_or_singleton\n    \u00b7 use \u27e8Enumeration.empty, Enumeration.empty\u27e9\n      intro y hy\n      rw [Set.eq_empty_iff_forall_not_mem] at h\n      cases h y hy\n    \u00b7 obtain \u27e8S, hS\u27e9 := TSet.exists_support y\n      use S \u2197 h\u03b5 \u2197 h\u03b4 \u2197 h\u03b3\n      intro z hz\n      rw [Set.eq_singleton_iff_unique_mem] at hy\n      cases hy.2 z hz\n      refine \u27e8?_, \u03bb h \u21a6 by cases h\u27e9\n      intro \u03c1 h\u03c1\n      simp only [Support.smul_scoderiv, \u2190 allPermSderiv_forget', Support.scoderiv_inj] at h\u03c1\n      simp only [smul_singleton, singleton_inj]\n      exact hS _ h\u03c1\n  obtain \u27e8S, hS\u27e9 := TSet.exists_support r\n  use S\n  intro a ha\n  refine \u27e8?_, \u03bb h \u21a6 by cases h\u27e9\n  intro \u03c1 h\u03c1\n  have := hS \u03c1 h\u03c1\n  simp only [smul_singleton, singleton_inj]\n  apply apply_eq_of_isWellOrder' (r := ExternalRel h\u03b3 h\u03b4 h\u03b5 r)\n  \u00b7 exact h\n  \u00b7 exact MulAction.bijective (\u03c1 \u2198 h\u03b3 \u2198 h\u03b4 \u2198 h\u03b5)\n  \u00b7 intro x y\n    conv_rhs => rw [\u2190 this]\n    simp only [externalRel_smul, InvImage, inv_smul_smul]\n  \u00b7 rwa [mem_field_iff] at ha\n\ninclude h\u03b3 in\ntheorem Support.Supports.ofSingleton {S : Support \u03b1} {x : TSet \u03b2}\n    (h : S.Supports {x}') :\n    letI : Level := \u27e8\u03b1\u27e9\n    letI : LeLevel \u03b1 := \u27e8le_rfl\u27e9\n    (S.strong \u2198 h\u03b2).Supports x := by\n  refine \u27e8?_, \u03bb h \u21a6 by cases h\u27e9\n  intro \u03c1 h\u03c1\n  open scoped Pointwise in\n  have := sUnion_singleton_symmetric_aux h\u03b3 h\u03b2 {y | y \u2208' x} S ?_ \u03c1 h\u03c1\n  \u00b7 apply ConNF.ext h\u03b3\n    intro z\n    simp only [Set.ext_iff, Set.mem_setOf_eq, Set.mem_smul_set_iff_inv_smul_mem] at this\n    rw [mem_smul_iff', allPerm_inv_sderiv', this]\n  \u00b7 intro \u03c1 h\u03c1\n    ext z\n    simp only [Set.mem_smul_set_iff_inv_smul_mem, Set.mem_image, Set.mem_setOf_eq]\n    have := h.supports \u03c1 h\u03c1\n    simp only [smul_singleton, singleton_inj] at this\n    constructor\n    \u00b7 rintro \u27e8y, h\u2081, h\u2082\u27e9\n      rw [\u2190 smul_eq_iff_eq_inv_smul, smul_singleton] at h\u2082\n      refine \u27e8_, ?_, h\u2082\u27e9\n      rw [\u2190 this]\n      simp only [mem_smul_iff', allPerm_inv_sderiv', inv_smul_smul]\n      exact h\u2081\n    \u00b7 rintro \u27e8y, h, rfl\u27e9\n      refine \u27e8(\u03c1 \u2198 h\u03b2 \u2198 h\u03b3)\u207b\u00b9 \u2022 y, ?_, ?_\u27e9\n      \u00b7 rwa [\u2190 allPerm_inv_sderiv', \u2190 mem_smul_iff', this]\n      \u00b7 simp only [smul_singleton, allPerm_inv_sderiv']\n\ninclude h\u03b3 in\ntheorem supports_of_supports_singletons {S : Support \u03b1} {s : Set (TSet \u03b2)}\n    (h : \u2200 x \u2208 s, S.Supports {x}') :\n    \u2203 S : Support \u03b2, \u2200 x \u2208 s, S.Supports x :=\n  \u27e8_, \u03bb x hx \u21a6 (h x hx).ofSingleton h\u03b2 h\u03b3\u27e9\n\ntheorem exists_common_support_of_internallyWellOrdered {x : TSet \u03b4}\n    (h : InternallyWellOrdered h\u03b3 h\u03b4 h\u03b5 x) :\n    \u2203 S : Support \u03b4, \u2200 y, y \u2208' x \u2192 S.Supports {y}' := by\n  obtain \u27e8S, hS\u27e9 := exists_common_support_of_internallyWellOrdered' h\u03b3 h\u03b4 h\u03b5 h\n  have := supports_of_supports_singletons (S := S)\n      (s := singleton h\u03b4 '' (singleton h\u03b5 '' {y | y \u2208' x})) h\u03b3 h\u03b4 ?_\n  swap\n  \u00b7 simp only [Set.mem_image, Set.mem_setOf_eq, exists_exists_and_eq_and, forall_exists_index,\n      and_imp, forall_apply_eq_imp_iff\u2082]\n    exact hS\n  obtain \u27e8T, hT\u27e9 := this\n  have := supports_of_supports_singletons (S := T)\n      (s := singleton h\u03b5 '' {y | y \u2208' x}) h\u03b4 h\u03b5 ?_\n  swap\n  \u00b7 simp only [Set.mem_image, Set.mem_setOf_eq, forall_exists_index, and_imp,\n      forall_apply_eq_imp_iff\u2082] at hT \u22a2\n    exact hT\n  simp only [Set.mem_image, Set.mem_setOf_eq, forall_exists_index, and_imp,\n    forall_apply_eq_imp_iff\u2082] at this\n  exact this\n\ntheorem internallyWellOrdered_of_common_support_of_nontrivial {x : TSet \u03b3}\n    (hx : {y : TSet \u03b4 | y \u2208' x}.Nontrivial)\n    (S : Support \u03b4) (hS : \u2200 y : TSet \u03b4, y \u2208' x \u2192 S.Supports y) :\n    InternallyWellOrdered h\u03b2 h\u03b3 h\u03b4 x := by\n  have := exists_of_symmetric\n      {p : TSet \u03b2 | \u2203 a b : TSet \u03b4, p = \u27e8a, b\u27e9' \u2227 a \u2208' x \u2227 b \u2208' x \u2227 WellOrderingRel a b} h\u03b2 ?_\n  swap\n  \u00b7 use S \u2197 h\u03b4 \u2197 h\u03b3 \u2197 h\u03b2\n    intro \u03c1 h\u03c1\n    ext z\n    simp only [Support.smul_scoderiv, \u2190 allPermSderiv_forget', Support.scoderiv_inj] at h\u03c1\n    simp only [Set.mem_smul_set_iff_inv_smul_mem, Set.mem_setOf_eq]\n    constructor\n    \u00b7 rintro \u27e8a, b, h\u2081, h\u2082, h\u2083, h\u2084\u27e9\n      refine \u27e8a, b, ?_, h\u2082, h\u2083, h\u2084\u27e9\n      rw [inv_smul_eq_iff] at h\u2081\n      rw [h\u2081, smul_op, op_inj]\n      exact \u27e8(hS a h\u2082).supports _ h\u03c1, (hS b h\u2083).supports _ h\u03c1\u27e9\n    \u00b7 rintro \u27e8a, b, h\u2081, h\u2082, h\u2083, h\u2084\u27e9\n      refine \u27e8a, b, ?_, h\u2082, h\u2083, h\u2084\u27e9\n      rw [h\u2081, smul_op, op_inj]\n      simp only [allPerm_inv_sderiv', inv_smul_eq_iff]\n      rw [(hS a h\u2082).supports _ h\u03c1, (hS b h\u2083).supports _ h\u03c1]\n      exact \u27e8rfl, rfl\u27e9\n  obtain \u27e8r, hr\u27e9 := this\n  right\n  use r\n  have hr' : \u2200 a b, ExternalRel h\u03b2 h\u03b3 h\u03b4 r a b \u2194 a \u2208' x \u2227 b \u2208' x \u2227 WellOrderingRel a b := by\n    intro a b\n    rw [ExternalRel, hr]\n    simp only [Set.mem_setOf_eq, op_inj]\n    constructor\n    \u00b7 rintro \u27e8a, b, \u27e8rfl, rfl\u27e9, h\u27e9\n      exact h\n    \u00b7 intro h\n      exact \u27e8a, b, \u27e8rfl, rfl\u27e9, h\u27e9\n  have hrx : \u2200 a, a \u2208 (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).field \u2194 a \u2208' x := by\n    intro a\n    constructor\n    \u00b7 rintro (\u27e8b, h\u27e9 | \u27e8b, h\u27e9)\n      \u00b7 rw [hr'] at h\n        exact h.1\n      \u00b7 rw [hr'] at h\n        exact h.2.1\n    \u00b7 intro h\n      obtain \u27e8b, h\u2081, h\u2082\u27e9 := hx.exists_ne a\n      obtain (h\u2083 | h\u2083 | h\u2083) := WellOrderingRel.isWellOrder.trichotomous a b\n      \u00b7 refine Or.inl \u27e8b, ?_\u27e9\n        rw [hr']\n        exact \u27e8h, h\u2081, h\u2083\u27e9\n      \u00b7 cases h\u2082 h\u2083.symm\n      \u00b7 refine Or.inr \u27e8b, ?_\u27e9\n        rw [hr']\n        exact \u27e8h\u2081, h, h\u2083\u27e9\n  refine \u27e8?_, ?_\u27e9\n  swap\n  \u00b7 apply ext h\u03b4\n    intro z\n    rw [mem_field_iff, hrx]\n  refine @IsWellOrder.mk _ _ ?_ ?_ ?_\n  \u00b7 constructor\n    intro a b\n    obtain (h | h | h) := WellOrderingRel.isWellOrder.trichotomous a.val b.val\n    \u00b7 apply Or.inl\n      rw [InvImage, hr']\n      exact \u27e8(hrx a).mp a.prop, (hrx b).mp b.prop, h\u27e9\n    \u00b7 exact Or.inr (Or.inl (Subtype.val_injective h))\n    \u00b7 apply Or.inr \u2218 Or.inr\n      rw [InvImage, hr']\n      exact \u27e8(hrx b).mp b.prop, (hrx a).mp a.prop, h\u27e9\n  \u00b7 constructor\n    intro a b c h\u2081 h\u2082\n    rw [InvImage, hr'] at h\u2081 h\u2082 \u22a2\n    exact \u27e8h\u2081.1, h\u2082.2.1, WellOrderingRel.isWellOrder.trans _ _ _ h\u2081.2.2 h\u2082.2.2\u27e9\n  \u00b7 constructor\n    apply InvImage.wf\n    refine Subrelation.wf ?_ WellOrderingRel.isWellOrder.wf\n    intro a b h\n    rw [hr'] at h\n    exact h.2.2\n\n", "theoremStatement": "theorem internallyWellOrdered_of_common_support {x : TSet \u03b3}\n    (S : Support \u03b4) (hS : \u2200 y : TSet \u03b4, y \u2208' x \u2192 S.Supports y) :\n    InternallyWellOrdered h\u03b2 h\u03b3 h\u03b4 x ", "theoremName": "ConNF.internallyWellOrdered_of_common_support", "fileCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "theoremCreated": {"commit": "1c08486feb882444888c228ce1501e92bb85e0e2", "date": "2025-01-07"}, "file": "ConNF/ConNF/External/WellOrder.lean", "module": "ConNF.External.WellOrder", "jsonFile": "ConNF.External.WellOrder.jsonl", "positionMetadata": {"lineInFile": 251, "tokenPositionInFile": 8640, "theoremPositionInFile": 10}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 16, "numPremises": 36}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  obtain (hx | hx) := Set.subsingleton_or_nontrivial {y : TSet \u03b4 | y \u2208' x}\n  \u00b7 exact Or.inl hx\n  \u00b7 exact internallyWellOrdered_of_common_support_of_nontrivial h\u03b2 h\u03b3 h\u03b4 hx S hS", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 181}}
{"srcContext": "import ConNF.Model.Result\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal ConNF.TSet\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\ndef union (x y : TSet \u03b1) : TSet \u03b1 :=\n  (x\u1d9c' \u2293' y\u1d9c')\u1d9c'\n\nnotation:68 x:68 \" \u2294[\" h \"] \" y:68 => _root_.ConNF.union h x y\nnotation:68 x:68 \" \u2294' \" y:68 => x \u2294[by assumption] y\n\n@[simp]\ntheorem mem_union_iff (x y : TSet \u03b1) :\n    \u2200 z : TSet \u03b2, z \u2208' x \u2294' y \u2194 z \u2208' x \u2228 z \u2208' y := by\n  rw [union]\n  intro z\n  rw [mem_compl_iff, mem_inter_iff, mem_compl_iff, mem_compl_iff, or_iff_not_and_not]\n\ndef higherIndex (\u03b1 : \u039b) : \u039b :=\n  (exists_gt \u03b1).choose\n\ntheorem lt_higherIndex {\u03b1 : \u039b} :\n    (\u03b1 : TypeIndex) < higherIndex \u03b1 :=\n  WithBot.coe_lt_coe.mpr (exists_gt \u03b1).choose_spec\n\ntheorem tSet_nonempty (h : \u2203 \u03b2 : \u039b, (\u03b2 : TypeIndex) < \u03b1) : Nonempty (TSet \u03b1) := by\n  obtain \u27e8\u03b1', h\u03b1\u27e9 := h\n  constructor\n  apply typeLower lt_higherIndex lt_higherIndex lt_higherIndex h\u03b1\n  apply cardinalOne lt_higherIndex lt_higherIndex\n\ndef empty : TSet \u03b1 :=\n  (tSet_nonempty \u27e8\u03b2, h\u03b2\u27e9).some \u2293' (tSet_nonempty \u27e8\u03b2, h\u03b2\u27e9).some\u1d9c'\n\n@[simp]\ntheorem mem_empty_iff :\n    \u2200 x : TSet \u03b2, \u00acx \u2208' empty h\u03b2 := by\n  intro x\n  rw [empty, mem_inter_iff, mem_compl_iff]\n  exact and_not_self\n\ndef univ : TSet \u03b1 :=\n  (empty h\u03b2)\u1d9c'\n\n@[simp]\ntheorem mem_univ_iff :\n    \u2200 x : TSet \u03b2, x \u2208' univ h\u03b2 := by\n  intro x\n  simp only [univ, mem_compl_iff, mem_empty_iff, not_false_eq_true]\n\n/-- The set of all ordered pairs. -/\ndef orderedPairs : TSet \u03b1 :=\n  vCross h\u03b2 h\u03b3 h\u03b4 (univ h\u03b4)\n\n@[simp]\ntheorem mem_orderedPairs_iff (x : TSet \u03b2) :\n    x \u2208' orderedPairs h\u03b2 h\u03b3 h\u03b4 \u2194 \u2203 a b, x = \u27e8a, b\u27e9' := by\n  simp only [orderedPairs, vCross_spec, mem_univ_iff, and_true]\n\ndef converse (x : TSet \u03b1) : TSet \u03b1 :=\n  converse' h\u03b2 h\u03b3 h\u03b4 x \u2293' orderedPairs h\u03b2 h\u03b3 h\u03b4\n\n@[simp]\ntheorem op_mem_converse_iff (x : TSet \u03b1) :\n    \u2200 a b, \u27e8a, b\u27e9' \u2208' converse h\u03b2 h\u03b3 h\u03b4 x \u2194 \u27e8b, a\u27e9' \u2208' x := by\n  intro a b\n  simp only [converse, mem_inter_iff, converse'_spec, mem_orderedPairs_iff, op_inj, exists_and_left,\n    exists_eq', and_true]\n\ndef cross (x y : TSet \u03b3) : TSet \u03b1 :=\n  converse h\u03b2 h\u03b3 h\u03b4 (vCross h\u03b2 h\u03b3 h\u03b4 x) \u2293' vCross h\u03b2 h\u03b3 h\u03b4 y\n\n@[simp]\ntheorem mem_cross_iff (x y : TSet \u03b3) :\n    \u2200 a, a \u2208' cross h\u03b2 h\u03b3 h\u03b4 x y \u2194 \u2203 b c, a = \u27e8b, c\u27e9' \u2227 b \u2208' x \u2227 c \u2208' y := by\n  intro a\n  rw [cross, mem_inter_iff, vCross_spec]\n  constructor\n  \u00b7 rintro \u27e8h\u2081, b, c, rfl, h\u2082\u27e9\n    simp only [op_mem_converse_iff, vCross_spec, op_inj] at h\u2081\n    obtain \u27e8b', c', \u27e8rfl, rfl\u27e9, h\u2081\u27e9 := h\u2081\n    exact \u27e8b, c, rfl, h\u2081, h\u2082\u27e9\n  \u00b7 rintro \u27e8b, c, rfl, h\u2081, h\u2082\u27e9\n    simp only [op_mem_converse_iff, vCross_spec, op_inj]\n    exact \u27e8\u27e8c, b, \u27e8rfl, rfl\u27e9, h\u2081\u27e9, \u27e8b, c, \u27e8rfl, rfl\u27e9, h\u2082\u27e9\u27e9\n\ndef singletonImage (x : TSet \u03b2) : TSet \u03b1 :=\n  singletonImage' h\u03b2 h\u03b3 h\u03b4 h\u03b5 x \u2293' (cross h\u03b2 h\u03b3 h\u03b4 (cardinalOne h\u03b4 h\u03b5) (cardinalOne h\u03b4 h\u03b5))\n\n@[simp]\ntheorem singletonImage_spec (x : TSet \u03b2) :\n    \u2200 z w,\n    \u27e8 {z}', {w}' \u27e9' \u2208' singletonImage h\u03b2 h\u03b3 h\u03b4 h\u03b5 x \u2194 \u27e8z, w\u27e9' \u2208' x := by\n  intro z w\n  rw [singletonImage, mem_inter_iff, singletonImage'_spec, and_iff_left_iff_imp]\n  intro hzw\n  rw [mem_cross_iff]\n  refine \u27e8{z}', {w}', rfl, ?_\u27e9\n  simp only [mem_cardinalOne_iff, singleton_inj, exists_eq', and_self]\n\ntheorem exists_of_mem_singletonImage {x : TSet \u03b2} {z w : TSet \u03b4}\n    (h : \u27e8z, w\u27e9' \u2208' singletonImage h\u03b2 h\u03b3 h\u03b4 h\u03b5 x) :\n    \u2203 a b, z = {a}' \u2227 w = {b}' := by\n  simp only [singletonImage, mem_inter_iff, mem_cross_iff, op_inj, mem_cardinalOne_iff] at h\n  obtain \u27e8-, _, _, \u27e8rfl, rfl\u27e9, \u27e8a, rfl\u27e9, \u27e8b, rfl\u27e9\u27e9 := h\n  exact \u27e8a, b, rfl, rfl\u27e9\n\n/-- Turn a model element encoding a relation into an actual relation. -/\ndef ExternalRel (r : TSet \u03b1) : Rel (TSet \u03b4) (TSet \u03b4) :=\n  \u03bb x y \u21a6 \u27e8x, y\u27e9' \u2208' r\n\n@[simp]\ntheorem externalRel_converse (r : TSet \u03b1) :\n    ExternalRel h\u03b2 h\u03b3 h\u03b4 (converse h\u03b2 h\u03b3 h\u03b4 r) = (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).inv := by\n  ext\n  simp only [ExternalRel, op_mem_converse_iff, Rel.inv_apply]\n\n/-- The codomain of a relation. -/\ndef codom (r : TSet \u03b1) : TSet \u03b3 :=\n  (typeLower lt_higherIndex h\u03b2 h\u03b3 h\u03b4 (singletonImage lt_higherIndex h\u03b2 h\u03b3 h\u03b4 r)\u1d9c[lt_higherIndex])\u1d9c'\n\n@[simp]\ntheorem mem_codom_iff (r : TSet \u03b1) (x : TSet \u03b4) :\n    x \u2208' codom h\u03b2 h\u03b3 h\u03b4 r \u2194 x \u2208 (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).codom := by\n  simp only [codom, mem_compl_iff, mem_typeLower_iff, not_forall, not_not]\n  constructor\n  \u00b7 rintro \u27e8y, hy\u27e9\n    obtain \u27e8a, b, rfl, hb\u27e9 := exists_of_mem_singletonImage lt_higherIndex h\u03b2 h\u03b3 h\u03b4 hy\n    rw [singleton_inj] at hb\n    subst hb\n    rw [singletonImage_spec] at hy\n    exact \u27e8a, hy\u27e9\n  \u00b7 rintro \u27e8a, ha\u27e9\n    use {a}'\n    rw [singletonImage_spec]\n    exact ha\n\n/-- The domain of a relation. -/\ndef dom (r : TSet \u03b1) : TSet \u03b3 :=\n  codom h\u03b2 h\u03b3 h\u03b4 (converse h\u03b2 h\u03b3 h\u03b4 r)\n\n@[simp]\ntheorem mem_dom_iff (r : TSet \u03b1) (x : TSet \u03b4) :\n    x \u2208' dom h\u03b2 h\u03b3 h\u03b4 r \u2194 x \u2208 (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).dom := by\n  rw [dom, mem_codom_iff, externalRel_converse, Rel.inv_codom]\n\n/-- The field of a relation. -/\ndef field (r : TSet \u03b1) : TSet \u03b3 :=\n  dom h\u03b2 h\u03b3 h\u03b4 r \u2294' codom h\u03b2 h\u03b3 h\u03b4 r\n\n@[simp]\ntheorem mem_field_iff (r : TSet \u03b1) (x : TSet \u03b4) :\n    x \u2208' field h\u03b2 h\u03b3 h\u03b4 r \u2194 x \u2208 (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).field := by\n  rw [field, mem_union_iff, mem_dom_iff, mem_codom_iff, Rel.field, Set.mem_union]\n\ndef subset : TSet \u03b1 :=\n  subset' h\u03b2 h\u03b3 h\u03b4 h\u03b5 \u2293' orderedPairs h\u03b2 h\u03b3 h\u03b4\n\n@[simp]\ntheorem subset_spec :\n    \u2200 a b, \u27e8a, b\u27e9' \u2208' subset h\u03b2 h\u03b3 h\u03b4 h\u03b5 \u2194 a \u2286[TSet \u03b5] b := by\n  intro a b\n  simp only [subset, mem_inter_iff, subset'_spec, mem_orderedPairs_iff, op_inj, exists_and_left,\n    exists_eq', and_true]\n\ndef membership : TSet \u03b1 :=\n  subset h\u03b2 h\u03b3 h\u03b4 h\u03b5 \u2293' cross h\u03b2 h\u03b3 h\u03b4 (cardinalOne h\u03b4 h\u03b5) (univ h\u03b4)\n\n@[simp]\ntheorem membership_spec :\n    \u2200 a b, \u27e8{a}', b\u27e9' \u2208' membership h\u03b2 h\u03b3 h\u03b4 h\u03b5 \u2194 a \u2208' b := by\n  intro a b\n  rw [membership, mem_inter_iff, subset_spec]\n  simp only [mem_cross_iff, op_inj, mem_cardinalOne_iff, mem_univ_iff, and_true, exists_and_right,\n    exists_and_left, exists_eq', exists_eq_left', singleton_inj]\n  constructor\n  \u00b7 intro h\n    exact h a ((typedMem_singleton_iff' h\u03b5 a a).mpr rfl)\n  \u00b7 intro h c hc\n    simp only [typedMem_singleton_iff'] at hc\n    cases hc\n    exact h\n\ndef powerset (x : TSet \u03b2) : TSet \u03b1 :=\n  dom lt_higherIndex lt_higherIndex h\u03b2\n    (subset lt_higherIndex lt_higherIndex h\u03b2 h\u03b3 \u2293[lt_higherIndex]\n      vCross lt_higherIndex lt_higherIndex h\u03b2 {x}')\n\n@[simp]\ntheorem mem_powerset_iff (x y : TSet \u03b2) :\n    x \u2208' powerset h\u03b2 h\u03b3 y \u2194 x \u2286[TSet \u03b3] y := by\n  rw [powerset, mem_dom_iff]\n  constructor\n  \u00b7 rintro \u27e8z, h\u27e9\n    simp only [ExternalRel, mem_inter_iff, subset_spec, vCross_spec, op_inj,\n      typedMem_singleton_iff', exists_eq_right, exists_and_right, exists_eq', true_and] at h\n    cases h.2\n    exact h.1\n  \u00b7 intro h\n    refine \u27e8y, ?_\u27e9\n    simp only [ExternalRel, mem_inter_iff, subset_spec, h, vCross_spec, op_inj,\n      typedMem_singleton_iff', exists_eq_right, and_true, exists_eq', and_self]\n\n/-- The set `\u03b9\u00b2''x = {{{a}} | a \u2208 x}`. -/\ndef doubleSingleton (x : TSet \u03b3) : TSet \u03b1 :=\n  cross h\u03b2 h\u03b3 h\u03b4 x x \u2293' cardinalOne h\u03b2 h\u03b3\n\n@[simp]\ntheorem mem_doubleSingleton_iff (x : TSet \u03b3) :\n    \u2200 y : TSet \u03b2, y \u2208' doubleSingleton h\u03b2 h\u03b3 h\u03b4 x \u2194\n    \u2203 z : TSet \u03b4, z \u2208' x \u2227 y = { {z}' }' := by\n  intro y\n  rw [doubleSingleton, mem_inter_iff, mem_cross_iff, mem_cardinalOne_iff]\n  constructor\n  \u00b7 rintro \u27e8\u27e8b, c, h\u2081, h\u2082, h\u2083\u27e9, \u27e8a, rfl\u27e9\u27e9\n    obtain \u27e8hbc, rfl\u27e9 := (op_eq_singleton_iff _ _ _ _ _).mp h\u2081.symm\n    exact \u27e8c, h\u2083, rfl\u27e9\n  \u00b7 rintro \u27e8z, h, rfl\u27e9\n    constructor\n    \u00b7 refine \u27e8z, z, ?_\u27e9\n      rw [eq_comm, op_eq_singleton_iff]\n      tauto\n    \u00b7 exact \u27e8_, rfl\u27e9\n\n/-- The union of a set of *singletons*: `\u03b9\u207b\u00b9''x = {a | {a} \u2208 x}`. -/\ndef singletonUnion (x : TSet \u03b1) : TSet \u03b2 :=\n  typeLower lt_higherIndex lt_higherIndex h\u03b2 h\u03b3\n    (vCross lt_higherIndex lt_higherIndex h\u03b2 x)\n\n@[simp]\ntheorem mem_singletonUnion_iff (x : TSet \u03b1) :\n    \u2200 y : TSet \u03b3, y \u2208' singletonUnion h\u03b2 h\u03b3 x \u2194 {y}' \u2208' x := by\n  intro y\n  simp only [singletonUnion, mem_typeLower_iff, vCross_spec, op_inj]\n  constructor\n  \u00b7 intro h\n    obtain \u27e8a, b, \u27e8rfl, rfl\u27e9, hy\u27e9 := h {y}'\n    exact hy\n  \u00b7 intro h b\n    exact \u27e8b, _, \u27e8rfl, rfl\u27e9, h\u27e9\n\n/--\nThe union of a set of sets.\n\n```\nsingletonUnion dom {\u27e8{a}, b\u27e9 | a \u2208 b} \u2229 (1 \u00d7 x) =\nsingletonUnion dom {\u27e8{a}, b\u27e9 | a \u2208 b \u2227 b \u2208 x} =\nsingletonUnion {{a} | a \u2208 b \u2227 b \u2208 x} =\n{a | a \u2208 b \u2227 b \u2208 x} =\n\u22c3 x\n```\n-/\ndef sUnion (x : TSet \u03b1) : TSet \u03b2 :=\n  singletonUnion h\u03b2 h\u03b3\n    (dom lt_higherIndex lt_higherIndex h\u03b2\n      (membership lt_higherIndex lt_higherIndex h\u03b2 h\u03b3 \u2293[lt_higherIndex]\n        cross lt_higherIndex lt_higherIndex h\u03b2 (cardinalOne h\u03b2 h\u03b3) x))\n\n@[simp]\ntheorem mem_sUnion_iff (x : TSet \u03b1) :\n    \u2200 y : TSet \u03b3, y \u2208' sUnion h\u03b2 h\u03b3 x \u2194 \u2203 t : TSet \u03b2, t \u2208' x \u2227 y \u2208' t := by\n  intro y\n  simp only [sUnion, mem_singletonUnion_iff, mem_dom_iff, Rel.dom, ExternalRel, mem_inter_iff,\n    mem_cross_iff, op_inj, mem_cardinalOne_iff, Set.mem_setOf_eq, membership_spec]\n  constructor\n  \u00b7 rintro \u27e8z, h\u2081, a, b, \u27e8rfl, rfl\u27e9, \u27e8c, h\u2082\u27e9, h\u2083\u27e9\n    rw [singleton_inj] at h\u2082\n    cases h\u2082\n    exact \u27e8z, h\u2083, h\u2081\u27e9\n  \u00b7 rintro \u27e8z, h\u2082, h\u2083\u27e9\n    exact \u27e8z, h\u2083, _, _, \u27e8rfl, rfl\u27e9, \u27e8y, rfl\u27e9, h\u2082\u27e9\n\ntheorem exists_smallUnion (s : Set (TSet \u03b1)) (hs : Small s) :\n    \u2203 x : TSet \u03b1, \u2200 y : TSet \u03b2, y \u2208' x \u2194 \u2203 t \u2208 s, y \u2208' t := by\n  apply exists_of_symmetric\n  have := exists_support (\u03b1 := \u03b1)\n  choose S hS using this\n  refine \u27e8\u27e8Enumeration.ofSet (\u22c3 t \u2208 s, (S t)\u1d2c) ?_, Enumeration.ofSet (\u22c3 t \u2208 s, (S t)\u1d3a) ?_\u27e9, ?_\u27e9\n  \u00b7 apply small_biUnion hs\n    intros\n    exact (S _)\u1d2c.coe_small\n  \u00b7 apply small_biUnion hs\n    intros\n    exact (S _)\u1d3a.coe_small\n  intro \u03c1 h\u03c1\n  suffices \u2200 t \u2208 s, \u03c1 \u2022 t = t by\n    ext y\n    rw [Set.mem_smul_set_iff_inv_smul_mem]\n    constructor\n    \u00b7 rintro \u27e8t, h\u2081, h\u2082\u27e9\n      refine \u27e8t, h\u2081, ?_\u27e9\n      rw [\u2190 this t h\u2081]\n      rwa [mem_smul_iff', allPerm_inv_sderiv']\n    \u00b7 rintro \u27e8t, h\u2081, h\u2082\u27e9\n      refine \u27e8t, h\u2081, ?_\u27e9\n      have := this t h\u2081\n      rw [smul_eq_iff_eq_inv_smul] at this\n      rwa [this, mem_smul_iff', inv_inv, smul_inv_smul]\n  intro t ht\n  apply (hS t).supports \u03c1\n  refine smul_eq_of_le ?_ h\u03c1\n  intro A\n  constructor\n  \u00b7 intro a ha\n    rw [\u2190 Support.derivBot_atoms, Support.mk_atoms, \u2190 Enumeration.mem_path_iff,\n      Enumeration.mem_ofSet_iff, Set.mem_iUnion]\n    use t\n    rw [Set.mem_iUnion]\n    use ht\n    exact ha\n  \u00b7 intro a ha\n    rw [\u2190 Support.derivBot_nearLitters, Support.mk_nearLitters, \u2190 Enumeration.mem_path_iff,\n      Enumeration.mem_ofSet_iff, Set.mem_iUnion]\n    use t\n    rw [Set.mem_iUnion]\n    use ht\n    exact ha\n\n/-- Our model is `\u03ba`-complete; small unions exist.\nIn particular, the model knows the correct natural numbers. -/\ndef smallUnion (s : Set (TSet \u03b1)) (hs : Small s) : TSet \u03b1 :=\n  (exists_smallUnion h\u03b2 s hs).choose\n\n", "theoremStatement": "@[simp]\ntheorem mem_smallUnion_iff (s : Set (TSet \u03b1)) (hs : Small s) :\n    \u2200 x : TSet \u03b2, x \u2208' smallUnion h\u03b2 s hs \u2194 \u2203 t \u2208 s, x \u2208' t ", "theoremName": "ConNF.mem_smallUnion_iff", "fileCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "theoremCreated": {"commit": "6dd8406a01cc28b071bb26965294469664a1b592", "date": "2025-01-07"}, "file": "ConNF/ConNF/External/Basic.lean", "module": "ConNF.External.Basic", "jsonFile": "ConNF.External.Basic.jsonl", "positionMetadata": {"lineInFile": 341, "tokenPositionInFile": 10620, "theoremPositionInFile": 42}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 12, "numPremises": 29}, "proofMetadata": {"hasProof": true, "proof": ":=\n  (exists_smallUnion h\u03b2 s hs).choose_spec", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 44}}
{"srcContext": "import ConNF.External.Basic\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal ConNF.TSet\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : \u039b} (h\u03b2 : (\u03b2 : TypeIndex) < \u03b1) (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n  (h\u03b4 : (\u03b4 : TypeIndex) < \u03b3) (h\u03b5 : (\u03b5 : TypeIndex) < \u03b4) (h\u03b6 : (\u03b6 : TypeIndex) < \u03b5)\n\n/-- A set in our model that is a well-order. Internal well-orders are exactly external well-orders,\nso we externalise the definition for convenience. -/\ndef InternalWellOrder (r : TSet \u03b1) : Prop :=\n  IsWellOrder (ExternalRel h\u03b2 h\u03b3 h\u03b4 r).field\n    (InvImage (ExternalRel h\u03b2 h\u03b3 h\u03b4 r) Subtype.val)\n\ndef InternallyWellOrdered (x : TSet \u03b3) : Prop :=\n  {y : TSet \u03b4 | y \u2208' x}.Subsingleton \u2228 (\u2203 r, InternalWellOrder h\u03b2 h\u03b3 h\u03b4 r \u2227 x = field h\u03b2 h\u03b3 h\u03b4 r)\n\n@[simp]\ntheorem externalRel_smul (r : TSet \u03b1) (\u03c1 : AllPerm \u03b1) :\n    ExternalRel h\u03b2 h\u03b3 h\u03b4 (\u03c1 \u2022 r) =\n      InvImage (ExternalRel h\u03b2 h\u03b3 h\u03b4 r) ((\u03c1 \u2198 h\u03b2 \u2198 h\u03b3 \u2198 h\u03b4)\u207b\u00b9 \u2022 \u00b7) := by\n  ext a b\n  simp only [ExternalRel, mem_smul_iff', allPerm_inv_sderiv', smul_op, InvImage]\n\nomit [Params] in\n/-- Well-orders are rigid. -/\ntheorem apply_eq_of_isWellOrder {X : Type _} {r : Rel X X} {f : X \u2192 X}\n    (hr : IsWellOrder X r) (hf : Function.Bijective f) (hf' : \u2200 x y, r x y \u2194 r (f x) (f y)) :\n    \u2200 x, f x = x := by\n  let emb : r \u227ci r := \u27e8\u27e8\u27e8f, hf.injective\u27e9, \u03bb {a b} \u21a6 (hf' a b).symm\u27e9, ?_\u27e9\n  \u00b7 have : emb = InitialSeg.refl r := Subsingleton.elim _ _\n    intro x\n    exact congr_arg (\u03bb f \u21a6 f x) this\n  \u00b7 intro a b h\n    exact hf.surjective _\n\nomit [Params] in\n", "theoremStatement": "theorem apply_eq_of_isWellOrder' {X : Type _} {r : Rel X X} {f : X \u2192 X}\n    (hr : IsWellOrder r.field (InvImage r Subtype.val)) (hf : Function.Bijective f)\n    (hf' : \u2200 x y, r x y \u2194 r (f x) (f y)) :\n    \u2200 x \u2208 r.field, f x = x ", "theoremName": "ConNF.apply_eq_of_isWellOrder'", "fileCreated": {"commit": "66f4e3291020d4198ca6ede816acae5cee584a07", "date": "2025-01-06"}, "theoremCreated": {"commit": "1c08486feb882444888c228ce1501e92bb85e0e2", "date": "2025-01-07"}, "file": "ConNF/ConNF/External/WellOrder.lean", "module": "ConNF.External.WellOrder", "jsonFile": "ConNF.External.WellOrder.jsonl", "positionMetadata": {"lineInFile": 52, "tokenPositionInFile": 1567, "theoremPositionInFile": 4}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 45}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  have : \u2200 x \u2208 r.field, f x \u2208 r.field := by\n    rintro x (\u27e8y, h\u27e9 | \u27e8y, h\u27e9)\n    \u00b7 exact Or.inl \u27e8f y, (hf' x y).mp h\u27e9\n    \u00b7 exact Or.inr \u27e8f y, (hf' y x).mp h\u27e9\n  have := apply_eq_of_isWellOrder (f := \u03bb x \u21a6 \u27e8f x.val, this x.val x.prop\u27e9) hr \u27e8?_, ?_\u27e9 ?_\n  \u00b7 intro x hx\n    exact congr_arg Subtype.val (this \u27e8x, hx\u27e9)\n  \u00b7 intro x y h\n    rw [Subtype.mk.injEq] at h\n    exact Subtype.val_injective (hf.injective h)\n  \u00b7 intro x\n    obtain \u27e8y, hy\u27e9 := hf.surjective x.val\n    refine \u27e8\u27e8y, ?_\u27e9, ?_\u27e9\n    \u00b7 obtain (\u27e8z, h\u27e9 | \u27e8z, h\u27e9) := x.prop <;>\n          rw [\u2190 hy] at h <;>\n          obtain \u27e8z, rfl\u27e9 := hf.surjective z\n      \u00b7 exact Or.inl \u27e8z, (hf' y z).mpr h\u27e9\n      \u00b7 exact Or.inr \u27e8z, (hf' z y).mpr h\u27e9\n    \u00b7 simp only [hy]\n  \u00b7 intros\n    apply hf'", "proofType": "tactic", "proofLengthLines": 21, "proofLengthTokens": 739}}
{"srcContext": "import ConNF.Model.Externalise\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nnamespace ConNF\n\nvariable [Params.{u}] {\u03b2 \u03b3 : \u039b} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n\nnamespace Support\n\ntheorem not_mem_scoderiv_botDeriv (S : Support \u03b3) (N : NearLitter) :\n    N \u2209 (S \u2197 h\u03b3 \u21d8. (Path.nil \u2198.))\u1d3a := by\n  rintro \u27e8i, \u27e8A, N'\u27e9, h\u2081, h\u2082\u27e9\n  simp only [Prod.mk.injEq] at h\u2082\n  cases A\n  case sderiv \u03b4 A h\u03b4 _ =>\n    simp only [Path.deriv_sderiv] at h\u2082\n    cases A\n    case nil => cases h\u2082.1\n    case sderiv \u03b6 A h\u03b6 _ =>\n      simp only [Path.deriv_sderiv] at h\u2082\n      cases h\u2082.1\n\nvariable [Level] [LtLevel \u03b2]\n\ntheorem not_mem_strong_botDeriv (S : Support \u03b3) (N : NearLitter) :\n    N \u2209 ((S \u2197 h\u03b3).strong \u21d8. (Path.nil \u2198.))\u1d3a := by\n  rintro h\n  rw [strong, close_nearLitters, preStrong_nearLitters, Enumeration.mem_add_iff] at h\n  obtain h | h := h\n  \u00b7 exact not_mem_scoderiv_botDeriv S N h\n  \u00b7 rw [mem_constrainsNearLitters_nearLitters] at h\n    obtain \u27e8B, N', hN', h\u27e9 := h\n    cases h using Relation.ReflTransGen.head_induction_on\n    case refl => exact not_mem_scoderiv_botDeriv S N hN'\n    case head x hx\u2081 hx\u2082 _ =>\n      obtain \u27e8\u27e8\u03b3, \u03b4, \u03b5, h\u03b4, h\u03b5, h\u03b4\u03b5, A\u27e9, t, B, hB, hN, ht\u27e9 := hx\u2082\n      simp only at hB\n      cases B\n      case nil =>\n        cases hB\n        obtain \u27e8C, N''\u27e9 := x\n        simp only at ht\n        cases ht.1\n        change _ \u2208 t.support\u1d3a at hN\n        rw [t.support_supports.2 rfl] at hN\n        obtain \u27e8i, hN\u27e9 := hN\n        cases hN\n      case sderiv \u03b4 B h\u03b4 _ _ =>\n        cases B\n        case nil => cases hB\n        case sderiv \u03b6 B h\u03b6 _ _ => cases hB\n\ntheorem raise_preStrong' (S : Support \u03b1) (hS : S.Strong) (T : Support \u03b3) (\u03c1 : AllPerm \u03b2)\n    (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2) :\n    (S + (\u03c1\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim).PreStrong := by\n  apply hS.toPreStrong.add\n  constructor\n  intro A N hN P t hA ht\n  obtain \u27e8A, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv hN\n  simp only [scoderiv_botDeriv_eq, add_derivBot, smul_derivBot,\n    BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters, interferenceSupport_nearLitters,\n    Enumeration.mem_add_iff, Enumeration.mem_smul, Enumeration.not_mem_empty, or_false] at hN\n  obtain \u27e8\u03b4, \u03b5, \u03b6, h\u03b5, h\u03b6, h\u03b5\u03b6, B\u27e9 := P\n  dsimp only at *\n  cases A\n  case sderiv \u03b6' A h\u03b6' _ =>\n    rw [\u2190 Path.coderiv_deriv] at hA\n    cases Path.sderiv_index_injective hA\n    apply Path.sderiv_left_inj.mp at hA\n    cases A\n    case nil =>\n      cases hA\n      cases not_mem_strong_botDeriv T _ hN\n    case sderiv \u03b9 A h\u03b9 _ _ =>\n      rw [\u2190 Path.coderiv_deriv] at hA\n      cases Path.sderiv_index_injective hA\n      cases hA\n      haveI : LtLevel \u03b4 := \u27e8A.le.trans_lt LtLevel.elim\u27e9\n      haveI : LtLevel \u03b5 := \u27e8h\u03b5.trans LtLevel.elim\u27e9\n      haveI : LtLevel \u03b6 := \u27e8h\u03b6.trans LtLevel.elim\u27e9\n      have := (T \u2197 h\u03b3).strong_strong.support_le hN \u27e8\u03b4, \u03b5, \u03b6, h\u03b5, h\u03b6, h\u03b5\u03b6, A\u27e9\n          (\u03c1\u207b\u00b9 \u21d8 A \u2198 h\u03b5 \u2022 t) rfl ?_\n      \u00b7 simp only [Tangle.smul_support, allPermSderiv_forget, allPermDeriv_forget,\n          allPermForget_inv, Tree.inv_deriv, Tree.inv_sderiv] at this\n        have := smul_le_smul this (\u03c1\u1d41 \u21d8 A \u2198 h\u03b5)\n        simp only [smul_inv_smul] at this\n        apply le_trans this\n        intro B\n        constructor\n        \u00b7 intro a ha\n          simp only [smul_derivBot, Tree.sderiv_apply, Tree.deriv_apply, Path.deriv_scoderiv,\n            deriv_derivBot, Enumeration.mem_smul] at ha\n          rw [deriv_derivBot, \u2190 Path.deriv_scoderiv, Path.coderiv_deriv', scoderiv_botDeriv_eq,]\n          simp only [Path.deriv_scoderiv, add_derivBot, smul_derivBot,\n            BaseSupport.add_atoms, BaseSupport.smul_atoms, Enumeration.mem_add_iff,\n            Enumeration.mem_smul]\n          exact Or.inl ha\n        \u00b7 intro N hN\n          simp only [smul_derivBot, Tree.sderiv_apply, Tree.deriv_apply, Path.deriv_scoderiv,\n            deriv_derivBot, Enumeration.mem_smul] at hN\n          rw [deriv_derivBot, \u2190 Path.deriv_scoderiv, Path.coderiv_deriv', scoderiv_botDeriv_eq,]\n          simp only [Path.deriv_scoderiv, add_derivBot, smul_derivBot,\n            BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters, Enumeration.mem_add_iff,\n            Enumeration.mem_smul]\n          exact Or.inl hN\n      \u00b7 rw [\u2190 smul_fuzz h\u03b5 h\u03b6 h\u03b5\u03b6, \u2190 ht]\n        simp only [Path.botSderiv_coe_eq, BasePerm.smul_nearLitter_litter, allPermDeriv_forget,\n          allPermForget_inv, Tree.inv_deriv, Tree.inv_sderiv, Tree.inv_sderivBot]\n        rfl\n\ntheorem raise_closed' (S : Support \u03b1) (hS : S.Strong) (T : Support \u03b3) (\u03c1 : AllPerm \u03b2)\n    (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n    (h\u03c1 : \u03c1\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim) :\n    (S + (\u03c1\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim).Closed := by\n  constructor\n  intro A\n  constructor\n  intro N\u2081 N\u2082 hN\u2081 hN\u2082 a ha\n  simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff,\n    BaseSupport.add_atoms] at hN\u2081 hN\u2082 \u22a2\n  obtain hN\u2081 | hN\u2081 := hN\u2081\n  \u00b7 obtain hN\u2082 | hN\u2082 := hN\u2082\n    \u00b7 exact Or.inl ((hS.closed A).interference_subset hN\u2081 hN\u2082 a ha)\n    \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv hN\u2082\n      simp only [smul_add, scoderiv_botDeriv_eq, add_derivBot, smul_derivBot,\n        BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters, Enumeration.mem_add_iff,\n        Enumeration.mem_smul, BaseSupport.add_atoms, BaseSupport.smul_atoms] at hN\u2081 hN\u2082 \u22a2\n      refine Or.inr (Or.inr ?_)\n      rw [mem_interferenceSupport_atoms]\n      refine \u27e8(\u03c1\u1d41 B)\u207b\u00b9 \u2022 N\u2081, ?_, (\u03c1\u1d41 B)\u207b\u00b9 \u2022 N\u2082, ?_, ?_\u27e9\n      \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n        rw [\u2190 Enumeration.mem_smul, \u2190 BaseSupport.smul_nearLitters, \u2190 smul_derivBot, h\u03c1]\n        exact Or.inl hN\u2081\n      \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n        simp only [interferenceSupport_nearLitters, Enumeration.not_mem_empty, or_false] at hN\u2082\n        exact Or.inr hN\u2082\n      \u00b7 rw [\u2190 BasePerm.smul_interference]\n        exact Set.smul_mem_smul_set ha\n  \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv hN\u2081\n    simp only [smul_add, scoderiv_botDeriv_eq, add_derivBot, smul_derivBot,\n      BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters, Enumeration.mem_add_iff,\n      Enumeration.mem_smul, BaseSupport.add_atoms, BaseSupport.smul_atoms] at hN\u2081 hN\u2082 \u22a2\n    refine Or.inr (Or.inr ?_)\n    rw [mem_interferenceSupport_atoms]\n    refine \u27e8(\u03c1\u1d41 B)\u207b\u00b9 \u2022 N\u2081, ?_, (\u03c1\u1d41 B)\u207b\u00b9 \u2022 N\u2082, ?_, ?_\u27e9\n    \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n      simp only [interferenceSupport_nearLitters, Enumeration.not_mem_empty, or_false] at hN\u2081\n      exact Or.inr hN\u2081\n    \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.mem_add_iff]\n      simp only [interferenceSupport_nearLitters, Enumeration.not_mem_empty, or_false] at hN\u2082\n      obtain hN\u2082 | hN\u2082 := hN\u2082\n      \u00b7 rw [\u2190 Enumeration.mem_smul, \u2190 BaseSupport.smul_nearLitters, \u2190 smul_derivBot, h\u03c1]\n        exact Or.inl hN\u2082\n      \u00b7 exact Or.inr hN\u2082\n    \u00b7 rw [\u2190 BasePerm.smul_interference]\n      exact Set.smul_mem_smul_set ha\n\ntheorem raise_strong' (S : Support \u03b1) (hS : S.Strong) (T : Support \u03b3) (\u03c1 : AllPerm \u03b2)\n    (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n    (h\u03c1 : \u03c1\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim) :\n    (S + (\u03c1\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim).Strong :=\n  \u27e8raise_preStrong' S hS T \u03c1 h\u03b3, raise_closed' S hS T \u03c1 h\u03b3 h\u03c1\u27e9\n\ntheorem convAtoms_injective_of_fixes {S : Support \u03b1} {T : Support \u03b3}\n    {\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n    (h\u03c1\u2081 : \u03c1\u2081\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (h\u03c1\u2082 : \u03c1\u2082\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (A : \u2191\u03b1 \u219d \u22a5) :\n    (convAtoms\n      (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong + (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197\n        LtLevel.elim)\n      (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong + (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197\n        LtLevel.elim) A).Injective := by\n  rw [Support.smul_eq_iff] at h\u03c1\u2081 h\u03c1\u2082\n  constructor\n  rintro a\u2081 a\u2082 a\u2083 \u27e8i, hi\u2081, hi\u2082\u27e9 \u27e8j, hj\u2081, hj\u2082\u27e9\n  simp only [add_derivBot, BaseSupport.add_atoms, Rel.inv_apply,\n    Enumeration.rel_add_iff] at hi\u2081 hi\u2082 hj\u2081 hj\u2082\n  obtain hi\u2081 | \u27e8i, rfl, hi\u2081\u27e9 := hi\u2081\n  \u00b7 obtain hi\u2082 | \u27e8i', rfl, _\u27e9 := hi\u2082\n    swap\n    \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hi\u2081\u27e9\n      simp only [add_lt_iff_neg_left] at this\n      cases (\u03ba_zero_le i').not_lt this\n    cases (Enumeration.rel_coinjective _).coinjective hi\u2081 hi\u2082\n    obtain hj\u2081 | \u27e8j, rfl, hj\u2081\u27e9 := hj\u2081\n    \u00b7 obtain hj\u2082 | \u27e8j', rfl, _\u27e9 := hj\u2082\n      \u00b7 exact (Enumeration.rel_coinjective _).coinjective hj\u2082 hj\u2081\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2081\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j').not_lt this\n    \u00b7 obtain hj\u2082 | hj\u2082 := hj\u2082\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2082\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j).not_lt this\n      \u00b7 simp only [add_right_inj, exists_eq_left] at hj\u2082\n        obtain \u27e8B, rfl\u27e9 := eq_of_atom_mem_scoderiv_botDeriv \u27e8j, hj\u2081\u27e9\n        simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_atoms,\n          BaseSupport.add_atoms, Enumeration.smul_rel, add_right_inj, exists_eq_left] at hj\u2081 hj\u2082\n        have := (Enumeration.rel_coinjective _).coinjective hj\u2081 hj\u2082\n        rw [\u2190 (h\u03c1\u2082 B).1 a\u2081 \u27e8_, hi\u2081\u27e9, inv_smul_smul, inv_smul_eq_iff, (h\u03c1\u2081 B).1 a\u2081 \u27e8_, hi\u2081\u27e9] at this\n        exact this.symm\n  \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_atom_mem_scoderiv_botDeriv \u27e8i, hi\u2081\u27e9\n    simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_atoms,\n      BaseSupport.add_atoms, Enumeration.smul_rel, add_right_inj, exists_eq_left] at hi\u2081 hi\u2082 hj\u2081 hj\u2082\n    obtain hi\u2082 | hi\u2082 := hi\u2082\n    \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hi\u2082\u27e9\n      simp only [add_lt_iff_neg_left] at this\n      cases (\u03ba_zero_le i).not_lt this\n    have hi := (Enumeration.rel_coinjective _).coinjective hi\u2081 hi\u2082\n    suffices hj : (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 a\u2082 = (\u03c1\u2082\u1d41 B)\u207b\u00b9 \u2022 a\u2083 by\n      rwa [\u2190 hj, smul_left_cancel_iff] at hi\n    obtain hj\u2081 | \u27e8j, rfl, hj\u2081\u27e9 := hj\u2081\n    \u00b7 obtain hj\u2082 | \u27e8j', rfl, _\u27e9 := hj\u2082\n      \u00b7 rw [\u2190 (h\u03c1\u2081 B).1 a\u2082 \u27e8_, hj\u2081\u27e9, \u2190 (h\u03c1\u2082 B).1 a\u2083 \u27e8_, hj\u2082\u27e9, inv_smul_smul, inv_smul_smul]\n        exact (Enumeration.rel_coinjective _).coinjective hj\u2081 hj\u2082\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2081\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j').not_lt this\n    \u00b7 obtain hj\u2082 | hj\u2082 := hj\u2082\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2082\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j).not_lt this\n      \u00b7 simp only [add_right_inj, exists_eq_left] at hj\u2082\n        exact (Enumeration.rel_coinjective _).coinjective hj\u2081 hj\u2082\n\ntheorem atomMemRel_le_of_fixes {S : Support \u03b1} {T : Support \u03b3}\n    {\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n    (h\u03c1\u2081 : \u03c1\u2081\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (h\u03c1\u2082 : \u03c1\u2082\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (A : \u2191\u03b1 \u219d \u22a5) :\n    atomMemRel (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A \u2264\n    atomMemRel (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A := by\n  rw [Support.smul_eq_iff] at h\u03c1\u2081 h\u03c1\u2082\n  rintro i j \u27e8N, hN, a, haN, ha\u27e9\n  simp only [add_derivBot, BaseSupport.add_atoms, Rel.inv_apply, Enumeration.rel_add_iff,\n    BaseSupport.add_nearLitters] at ha hN\n  obtain hN | \u27e8i, rfl, hi\u27e9 := hN\n  \u00b7 obtain ha | \u27e8j, rfl, hj\u27e9 := ha\n    \u00b7 exact \u27e8N, Or.inl hN, a, haN, Or.inl ha\u27e9\n    \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_atom_mem_scoderiv_botDeriv \u27e8j, hj\u27e9\n      simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_atoms,\n        BaseSupport.add_atoms, Enumeration.smul_rel] at hj hN\n      refine \u27e8N, Or.inl hN, \u03c1\u2082\u1d41 B \u2022 (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 a, ?_, ?_\u27e9\n      \u00b7 dsimp only\n        rw [\u2190 (h\u03c1\u2082 B).2 N \u27e8_, hN\u27e9, BasePerm.smul_nearLitter_atoms, Set.smul_mem_smul_set_iff]\n        have := (h\u03c1\u2081 B).2 N \u27e8_, hN\u27e9\n        rw [smul_eq_iff_eq_inv_smul] at this\n        rwa [this, BasePerm.smul_nearLitter_atoms, Set.smul_mem_smul_set_iff]\n      \u00b7 rw [Rel.inv_apply, add_derivBot, BaseSupport.add_atoms, Enumeration.rel_add_iff]\n        simp only [add_right_inj, scoderiv_botDeriv_eq, smul_derivBot, add_derivBot,\n          BaseSupport.smul_atoms, BaseSupport.add_atoms, Enumeration.smul_rel, inv_smul_smul,\n          exists_eq_left]\n        exact Or.inr hj\n  \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv \u27e8i, hi\u27e9\n    simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_atoms,\n      BaseSupport.add_atoms, Enumeration.smul_rel] at hi ha\n    obtain ha | \u27e8j, rfl, hj\u27e9 := ha\n    \u00b7 refine \u27e8\u03c1\u2082\u1d41 B \u2022 (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 N, ?_, a, ?_, Or.inl ha\u27e9\n      \u00b7 rw [add_derivBot, BaseSupport.add_nearLitters, Enumeration.rel_add_iff]\n        simp only [add_right_inj, scoderiv_botDeriv_eq, smul_derivBot, add_derivBot,\n          BaseSupport.smul_nearLitters, BaseSupport.add_nearLitters, Enumeration.smul_rel,\n          inv_smul_smul, exists_eq_left]\n        exact Or.inr hi\n      \u00b7 dsimp only\n        rw [\u2190 (h\u03c1\u2082 B).1 a \u27e8_, ha\u27e9, BasePerm.smul_nearLitter_atoms, Set.smul_mem_smul_set_iff]\n        have := (h\u03c1\u2081 B).1 a \u27e8_, ha\u27e9\n        rw [smul_eq_iff_eq_inv_smul] at this\n        rwa [this, BasePerm.smul_nearLitter_atoms, Set.smul_mem_smul_set_iff]\n    \u00b7 refine \u27e8\u03c1\u2082\u1d41 B \u2022 (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 N, ?_, \u03c1\u2082\u1d41 B \u2022 (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 a, ?_, ?_\u27e9\n      \u00b7 rw [add_derivBot, BaseSupport.add_nearLitters, Enumeration.rel_add_iff]\n        simp only [add_right_inj, scoderiv_botDeriv_eq, smul_derivBot, add_derivBot,\n          BaseSupport.smul_nearLitters, BaseSupport.add_nearLitters, Enumeration.smul_rel,\n          inv_smul_smul, exists_eq_left]\n        exact Or.inr hi\n      \u00b7 simp only [BasePerm.smul_nearLitter_atoms, Set.smul_mem_smul_set_iff]\n        exact haN\n      \u00b7 rw [Rel.inv_apply, add_derivBot, BaseSupport.add_atoms, Enumeration.rel_add_iff]\n        simp only [add_right_inj, scoderiv_botDeriv_eq, smul_derivBot, add_derivBot,\n          BaseSupport.smul_atoms, BaseSupport.add_atoms, Enumeration.smul_rel, inv_smul_smul,\n          exists_eq_left]\n        exact Or.inr hj\n\ntheorem convNearLitters_cases {S : Support \u03b1} {T : Support \u03b3}\n    {\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n    {A : \u03b1 \u219d \u22a5} {N\u2081 N\u2082 : NearLitter} :\n  convNearLitters\n    (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim)\n    (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A N\u2081 N\u2082 \u2192\n    N\u2081 = N\u2082 \u2227 N\u2081 \u2208 (S \u21d8. A)\u1d3a \u2228\n    \u2203 B : \u03b2 \u219d \u22a5, A = B \u2197 LtLevel.elim \u2227 (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 N\u2081 = (\u03c1\u2082\u1d41 B)\u207b\u00b9 \u2022 N\u2082 \u2227\n      (\u03c1\u2081\u1d41 B)\u207b\u00b9 \u2022 N\u2081 \u2208 (((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport) \u21d8. B)\u1d3a := by\n  rintro \u27e8i, hN\u2081, hN\u2082\u27e9\n  simp only [add_derivBot, BaseSupport.add_nearLitters, Rel.inv_apply,\n    Enumeration.rel_add_iff] at hN\u2081 hN\u2082\n  obtain hN\u2081 | \u27e8i, rfl, hN\u2081\u27e9 := hN\u2081\n  \u00b7 obtain hN\u2082 | \u27e8i, rfl, hN\u2082\u27e9 := hN\u2082\n    swap\n    \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hN\u2081\u27e9\n      simp only [add_lt_iff_neg_left] at this\n      cases (\u03ba_zero_le i).not_lt this\n    exact Or.inl \u27e8(Enumeration.rel_coinjective _).coinjective hN\u2081 hN\u2082, _, hN\u2081\u27e9\n  \u00b7 obtain \u27e8B, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv \u27e8i, hN\u2081\u27e9\n    simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_nearLitters,\n      BaseSupport.add_nearLitters, Enumeration.smul_rel, add_right_inj, exists_eq_left] at hN\u2081 hN\u2082\n    obtain hN\u2082 | hN\u2082 := hN\u2082\n    \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hN\u2082\u27e9\n      simp only [add_lt_iff_neg_left] at this\n      cases (\u03ba_zero_le i).not_lt this\n    exact Or.inr \u27e8B, rfl, (Enumeration.rel_coinjective _).coinjective hN\u2081 hN\u2082, _, hN\u2081\u27e9\n\ntheorem inflexible_of_inflexible_of_fixes {S : Support \u03b1} {T : Support \u03b3}\n    {\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n    (h\u03c1\u2081 : \u03c1\u2081\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (h\u03c1\u2082 : \u03c1\u2082\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    {A : \u03b1 \u219d \u22a5} {N\u2081 N\u2082 : NearLitter} :\n    convNearLitters\n      (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim)\n      (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A N\u2081 N\u2082 \u2192\n      \u2200 (P : InflexiblePath \u2191\u03b1) (t : Tangle P.\u03b4), A = P.A \u2198 P.h\u03b5 \u2198. \u2192 N\u2081\u1d38 = fuzz P.h\u03b4\u03b5 t \u2192\n      \u2203 \u03c1 : AllPerm P.\u03b4, N\u2082\u1d38 = fuzz P.h\u03b4\u03b5 (\u03c1 \u2022 t) := by\n  rintro hN \u27e8\u03b3, \u03b4, \u03b5, h\u03b4, h\u03b5, h\u03b4\u03b5, A\u27e9 t hA ht\n  haveI : LeLevel \u03b3 := \u27e8A.le\u27e9\n  haveI : LtLevel \u03b4 := \u27e8h\u03b4.trans_le LeLevel.elim\u27e9\n  haveI : LtLevel \u03b5 := \u27e8h\u03b5.trans_le LeLevel.elim\u27e9\n  obtain \u27e8rfl, _\u27e9 | \u27e8B, rfl, hN'\u27e9 := convNearLitters_cases hN\n  \u00b7 use 1\n    rw [one_smul, ht]\n  \u00b7 clear hN\n    cases B\n    case sderiv \u03b5 B h\u03b5' _ =>\n      rw [\u2190 Path.coderiv_deriv] at hA\n      cases Path.sderiv_index_injective hA\n      apply Path.sderiv_path_injective at hA\n      cases B\n      case nil =>\n        simp only [Path.botSderiv_coe_eq, add_derivBot, BaseSupport.add_nearLitters,\n          interferenceSupport_nearLitters, Enumeration.add_empty] at hN'\n        cases not_mem_strong_botDeriv _ _ hN'.2\n      case sderiv \u03b6 B h\u03b6 _ _ =>\n        rw [\u2190 Path.coderiv_deriv] at hA\n        cases Path.sderiv_index_injective hA\n        apply Path.sderiv_path_injective at hA\n        dsimp only at hA h\u03b6 h\u03b5' B t\n        cases hA\n        use (\u03c1\u2082 * \u03c1\u2081\u207b\u00b9) \u21d8 B \u2198 h\u03b4\n        rw [inv_smul_eq_iff] at hN'\n        rw [\u2190 smul_fuzz h\u03b4 h\u03b5 h\u03b4\u03b5, \u2190 ht, hN'.1]\n        simp only [allPermDeriv_forget, allPermForget_mul, allPermForget_inv, Tree.mul_deriv,\n          Tree.inv_deriv, Tree.mul_sderiv, Tree.inv_sderiv, Tree.mul_sderivBot, Tree.inv_sderivBot,\n          Path.botSderiv_coe_eq, BasePerm.smul_nearLitter_litter, mul_smul]\n        erw [inv_smul_smul, smul_inv_smul]\n\ntheorem atoms_of_inflexible_of_fixes {S : Support \u03b1} (hS : S.Strong) {T : Support \u03b3}\n    {\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n    (h\u03c1\u2081 : \u03c1\u2081\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (h\u03c1\u2082 : \u03c1\u2082\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (A : \u03b1 \u219d \u22a5) (N\u2081 N\u2082 : NearLitter) (P : InflexiblePath \u2191\u03b1) (t : Tangle P.\u03b4) (\u03c1 : AllPerm P.\u03b4) :\n    A = P.A \u2198 P.h\u03b5 \u2198. \u2192 N\u2081\u1d38 = fuzz P.h\u03b4\u03b5 t \u2192 N\u2082\u1d38 = fuzz P.h\u03b4\u03b5 (\u03c1 \u2022 t) \u2192\n    convNearLitters\n      (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim)\n      (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A N\u2081 N\u2082 \u2192\n    \u2200 (B : P.\u03b4 \u219d \u22a5), \u2200 a \u2208 (t.support \u21d8. B)\u1d2c, \u2200 (i : \u03ba),\n      ((S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong + (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197\n        LtLevel.elim) \u21d8. (P.A \u2198 P.h\u03b4 \u21d8 B))\u1d2c.rel i a \u2192\n      ((S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong + (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197\n        LtLevel.elim) \u21d8. (P.A \u2198 P.h\u03b4 \u21d8 B))\u1d2c.rel i (\u03c1\u1d41 B \u2022 a) := by\n  rw [Support.smul_eq_iff] at h\u03c1\u2081 h\u03c1\u2082\n  obtain \u27e8\u03b3, \u03b4, \u03b5, h\u03b4, h\u03b5, h\u03b4\u03b5, B\u27e9 := P\n  haveI : LeLevel \u03b3 := \u27e8B.le\u27e9\n  haveI : LtLevel \u03b4 := \u27e8h\u03b4.trans_le LeLevel.elim\u27e9\n  haveI : LtLevel \u03b5 := \u27e8h\u03b5.trans_le LeLevel.elim\u27e9\n  dsimp only at t \u03c1 \u22a2\n  intro hA hN\u2081 hN\u2082 hN C a ha i hi\n  obtain \u27e8rfl, hN'\u27e9 | \u27e8A, rfl, hN\u2081', hN\u2082'\u27e9 := convNearLitters_cases hN\n  \u00b7 have haS := (hS.support_le hN' \u27e8\u03b3, \u03b4, \u03b5, h\u03b4, h\u03b5, h\u03b4\u03b5, _\u27e9 t hA hN\u2081 _).1 a ha\n    rw [hN\u2082] at hN\u2081\n    have h\u03c1t := congr_arg Tangle.support (fuzz_injective hN\u2081)\n    rw [Tangle.smul_support, Support.smul_eq_iff] at h\u03c1t\n    simp only [add_derivBot, BaseSupport.add_atoms, Enumeration.rel_add_iff] at hi \u22a2\n    rw [(h\u03c1t C).1 a ha]\n    obtain hi | \u27e8i, rfl, hi\u27e9 := hi\n    \u00b7 exact Or.inl hi\n    \u00b7 simp only [add_right_inj, exists_eq_left]\n      obtain \u27e8D, hD\u27e9 := eq_of_atom_mem_scoderiv_botDeriv \u27e8i, hi\u27e9\n      cases B using Path.recScoderiv\n      case nil =>\n        cases Path.scoderiv_index_injective hD\n        cases Path.scoderiv_left_inj.mp hD\n        simp only [hD, Path.coderiv_deriv, Path.coderiv_deriv', scoderiv_botDeriv_eq, smul_derivBot,\n          add_derivBot, BaseSupport.smul_atoms, BaseSupport.add_atoms, Enumeration.smul_rel] at hi \u22a2\n        rw [deriv_derivBot, hD] at haS\n        rw [\u2190 (h\u03c1\u2082 _).1 a haS, inv_smul_smul]\n        rw [\u2190 (h\u03c1\u2081 _).1 a haS, inv_smul_smul] at hi\n        exact Or.inr hi\n      case scoderiv \u03b6 B h\u03b6' _ =>\n        rw [Path.coderiv_deriv, Path.coderiv_deriv'] at hD\n        cases Path.scoderiv_index_injective hD\n        rw [Path.scoderiv_left_inj] at hD\n        cases hD\n        simp only [Path.coderiv_deriv, Path.coderiv_deriv', scoderiv_botDeriv_eq, smul_derivBot,\n          add_derivBot, BaseSupport.smul_atoms, BaseSupport.add_atoms, Enumeration.smul_rel] at hi \u22a2\n        rw [deriv_derivBot, Path.coderiv_deriv, Path.coderiv_deriv'] at haS\n        rw [\u2190 (h\u03c1\u2082 _).1 a haS, inv_smul_smul]\n        rw [\u2190 (h\u03c1\u2081 _).1 a haS, inv_smul_smul] at hi\n        exact Or.inr hi\n  \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, interferenceSupport_nearLitters,\n      Enumeration.add_empty] at hN\u2082'\n    cases A\n    case sderiv \u03b6 A h\u03b6' _ =>\n      rw [\u2190 Path.coderiv_deriv] at hA\n      cases Path.sderiv_index_injective hA\n      apply Path.sderiv_path_injective at hA\n      cases A\n      case nil =>\n        cases hA\n        cases not_mem_strong_botDeriv _ _ hN\u2082'\n      case sderiv \u03b6 A h\u03b6 _ _ =>\n        rw [\u2190 Path.coderiv_deriv] at hA\n        cases Path.sderiv_index_injective hA\n        apply Path.sderiv_path_injective at hA\n        cases hA\n        simp only [Path.coderiv_deriv, Path.coderiv_deriv', add_derivBot, scoderiv_botDeriv_eq,\n          smul_derivBot, BaseSupport.add_atoms, BaseSupport.smul_atoms] at hi \u22a2\n        have : N\u2082\u1d38 = (\u03c1\u2082 \u21d8 A)\u1d41 \u2198 h\u03b6 \u2198. \u2022 (\u03c1\u2081\u207b\u00b9 \u21d8 A)\u1d41 \u2198 h\u03b6 \u2198. \u2022 fuzz h\u03b4\u03b5 t := by\n          rw [inv_smul_eq_iff] at hN\u2081'\n          rw [hN\u2081', Path.botSderiv_coe_eq, BasePerm.smul_nearLitter_litter,\n            BasePerm.smul_nearLitter_litter, smul_smul, smul_eq_iff_eq_inv_smul,\n            mul_inv_rev, inv_inv, mul_smul, \u2190 Tree.inv_apply, \u2190 allPermForget_inv] at hN\u2081\n          rw [hN\u2081]\n          simp only [allPermForget_inv, Tree.inv_apply, allPermDeriv_forget, Tree.inv_deriv,\n            Tree.inv_sderiv, Tree.inv_sderivBot]\n          rfl\n        rw [smul_fuzz h\u03b4 h\u03b5 h\u03b4\u03b5, smul_fuzz h\u03b4 h\u03b5 h\u03b4\u03b5] at this\n        have := fuzz_injective (hN\u2082.symm.trans this)\n        rw [smul_smul] at this\n        rw [t.smul_atom_eq_of_mem_support this ha]\n        rw [Enumeration.rel_add_iff] at hi \u22a2\n        obtain hi | \u27e8i, rfl, hi\u27e9 := hi\n        \u00b7 left\n          simp only [allPermForget_mul, allPermSderiv_forget, allPermDeriv_forget,\n            allPermForget_inv, Tree.inv_deriv, Tree.inv_sderiv, Tree.mul_apply, Tree.sderiv_apply,\n            Tree.deriv_apply, Path.deriv_scoderiv, Tree.inv_apply, mul_smul]\n          rwa [\u2190 (h\u03c1\u2081 _).1 a \u27e8i, hi\u27e9, inv_smul_smul, (h\u03c1\u2082 _).1 a \u27e8i, hi\u27e9]\n        \u00b7 refine Or.inr \u27e8i, rfl, ?_\u27e9\n          simp only [allPermForget_mul, allPermSderiv_forget, allPermDeriv_forget,\n            allPermForget_inv, Tree.inv_deriv, Tree.inv_sderiv, Tree.mul_apply, Tree.sderiv_apply,\n            Tree.deriv_apply, Path.deriv_scoderiv, Tree.inv_apply, mul_smul, Enumeration.smul_rel,\n            inv_smul_smul]\n          exact hi\n\ntheorem nearLitters_of_inflexible_of_fixes {S : Support \u03b1} (hS : S.Strong) {T : Support \u03b3}\n    {\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n    (h\u03c1\u2081 : \u03c1\u2081\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (h\u03c1\u2082 : \u03c1\u2082\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (A : \u03b1 \u219d \u22a5) (N\u2081 N\u2082 : NearLitter) (P : InflexiblePath \u2191\u03b1) (t : Tangle P.\u03b4) (\u03c1 : AllPerm P.\u03b4) :\n    A = P.A \u2198 P.h\u03b5 \u2198. \u2192 N\u2081\u1d38 = fuzz P.h\u03b4\u03b5 t \u2192 N\u2082\u1d38 = fuzz P.h\u03b4\u03b5 (\u03c1 \u2022 t) \u2192\n    convNearLitters\n      (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim)\n      (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A N\u2081 N\u2082 \u2192\n    \u2200 (B : P.\u03b4 \u219d \u22a5), \u2200 N \u2208 (t.support \u21d8. B)\u1d3a, \u2200 (i : \u03ba),\n      ((S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong + (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197\n        LtLevel.elim) \u21d8. (P.A \u2198 P.h\u03b4 \u21d8 B))\u1d3a.rel i N \u2192\n      ((S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong + (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197\n        LtLevel.elim) \u21d8. (P.A \u2198 P.h\u03b4 \u21d8 B))\u1d3a.rel i (\u03c1\u1d41 B \u2022 N) := by\n  rw [Support.smul_eq_iff] at h\u03c1\u2081 h\u03c1\u2082\n  obtain \u27e8\u03b3, \u03b4, \u03b5, h\u03b4, h\u03b5, h\u03b4\u03b5, B\u27e9 := P\n  haveI : LeLevel \u03b3 := \u27e8B.le\u27e9\n  haveI : LtLevel \u03b4 := \u27e8h\u03b4.trans_le LeLevel.elim\u27e9\n  haveI : LtLevel \u03b5 := \u27e8h\u03b5.trans_le LeLevel.elim\u27e9\n  dsimp only at t \u03c1 \u22a2\n  intro hA hN\u2081 hN\u2082 hN C N\u2080 hN\u2080 i hi\n  obtain \u27e8rfl, hN'\u27e9 | \u27e8A, rfl, hN\u2081', hN\u2082'\u27e9 := convNearLitters_cases hN\n  \u00b7 have haS := (hS.support_le hN' \u27e8\u03b3, \u03b4, \u03b5, h\u03b4, h\u03b5, h\u03b4\u03b5, _\u27e9 t hA hN\u2081 _).2 N\u2080 hN\u2080\n    rw [hN\u2082] at hN\u2081\n    have h\u03c1t := congr_arg Tangle.support (fuzz_injective hN\u2081)\n    rw [Tangle.smul_support, Support.smul_eq_iff] at h\u03c1t\n    simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.rel_add_iff] at hi \u22a2\n    rw [(h\u03c1t C).2 N\u2080 hN\u2080]\n    obtain hi | \u27e8i, rfl, hi\u27e9 := hi\n    \u00b7 exact Or.inl hi\n    \u00b7 simp only [add_right_inj, exists_eq_left]\n      obtain \u27e8D, hD\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv \u27e8i, hi\u27e9\n      cases B using Path.recScoderiv\n      case nil =>\n        cases Path.scoderiv_index_injective hD\n        cases Path.scoderiv_left_inj.mp hD\n        simp only [hD, Path.coderiv_deriv, Path.coderiv_deriv', scoderiv_botDeriv_eq, smul_derivBot,\n          add_derivBot, BaseSupport.smul_nearLitters, BaseSupport.add_nearLitters, Enumeration.smul_rel] at hi \u22a2\n        rw [deriv_derivBot, hD] at haS\n        rw [\u2190 (h\u03c1\u2082 _).2 N\u2080 haS, inv_smul_smul]\n        rw [\u2190 (h\u03c1\u2081 _).2 N\u2080 haS, inv_smul_smul] at hi\n        exact Or.inr hi\n      case scoderiv \u03b6 B h\u03b6' _ =>\n        rw [Path.coderiv_deriv, Path.coderiv_deriv'] at hD\n        cases Path.scoderiv_index_injective hD\n        rw [Path.scoderiv_left_inj] at hD\n        cases hD\n        simp only [Path.coderiv_deriv, Path.coderiv_deriv', scoderiv_botDeriv_eq, smul_derivBot,\n          add_derivBot, BaseSupport.smul_nearLitters, BaseSupport.add_nearLitters, Enumeration.smul_rel] at hi \u22a2\n        rw [deriv_derivBot, Path.coderiv_deriv, Path.coderiv_deriv'] at haS\n        rw [\u2190 (h\u03c1\u2082 _).2 N\u2080 haS, inv_smul_smul]\n        rw [\u2190 (h\u03c1\u2081 _).2 N\u2080 haS, inv_smul_smul] at hi\n        exact Or.inr hi\n  \u00b7 simp only [add_derivBot, BaseSupport.add_nearLitters, interferenceSupport_nearLitters,\n      Enumeration.add_empty] at hN\u2082'\n    cases A\n    case sderiv \u03b6 A h\u03b6' _ =>\n      rw [\u2190 Path.coderiv_deriv] at hA\n      cases Path.sderiv_index_injective hA\n      apply Path.sderiv_path_injective at hA\n      cases A\n      case nil =>\n        cases hA\n        cases not_mem_strong_botDeriv _ _ hN\u2082'\n      case sderiv \u03b6 A h\u03b6 _ _ =>\n        rw [\u2190 Path.coderiv_deriv] at hA\n        cases Path.sderiv_index_injective hA\n        apply Path.sderiv_path_injective at hA\n        cases hA\n        simp only [Path.coderiv_deriv, Path.coderiv_deriv', add_derivBot, scoderiv_botDeriv_eq,\n          smul_derivBot, BaseSupport.add_nearLitters, BaseSupport.smul_nearLitters] at hi \u22a2\n        have : N\u2082\u1d38 = (\u03c1\u2082 \u21d8 A)\u1d41 \u2198 h\u03b6 \u2198. \u2022 (\u03c1\u2081\u207b\u00b9 \u21d8 A)\u1d41 \u2198 h\u03b6 \u2198. \u2022 fuzz h\u03b4\u03b5 t := by\n          rw [inv_smul_eq_iff] at hN\u2081'\n          rw [hN\u2081', Path.botSderiv_coe_eq, BasePerm.smul_nearLitter_litter,\n            BasePerm.smul_nearLitter_litter, smul_smul, smul_eq_iff_eq_inv_smul,\n            mul_inv_rev, inv_inv, mul_smul, \u2190 Tree.inv_apply, \u2190 allPermForget_inv] at hN\u2081\n          rw [hN\u2081]\n          simp only [allPermForget_inv, Tree.inv_apply, allPermDeriv_forget, Tree.inv_deriv,\n            Tree.inv_sderiv, Tree.inv_sderivBot]\n          rfl\n        rw [smul_fuzz h\u03b4 h\u03b5 h\u03b4\u03b5, smul_fuzz h\u03b4 h\u03b5 h\u03b4\u03b5] at this\n        have := fuzz_injective (hN\u2082.symm.trans this)\n        rw [smul_smul] at this\n        rw [t.smul_nearLitter_eq_of_mem_support this hN\u2080]\n        rw [Enumeration.rel_add_iff] at hi \u22a2\n        obtain hi | \u27e8i, rfl, hi\u27e9 := hi\n        \u00b7 left\n          simp only [allPermForget_mul, allPermSderiv_forget, allPermDeriv_forget,\n            allPermForget_inv, Tree.inv_deriv, Tree.inv_sderiv, Tree.mul_apply, Tree.sderiv_apply,\n            Tree.deriv_apply, Path.deriv_scoderiv, Tree.inv_apply, mul_smul]\n          rwa [\u2190 (h\u03c1\u2081 _).2 N\u2080 \u27e8i, hi\u27e9, inv_smul_smul, (h\u03c1\u2082 _).2 N\u2080 \u27e8i, hi\u27e9]\n        \u00b7 refine Or.inr \u27e8i, rfl, ?_\u27e9\n          simp only [allPermForget_mul, allPermSderiv_forget, allPermDeriv_forget,\n            allPermForget_inv, Tree.inv_deriv, Tree.inv_sderiv, Tree.mul_apply, Tree.sderiv_apply,\n            Tree.deriv_apply, Path.deriv_scoderiv, Tree.inv_apply, mul_smul, Enumeration.smul_rel,\n            inv_smul_smul]\n          exact hi\n\ntheorem litter_eq_of_flexible_of_fixes {S : Support \u03b1} {T : Support \u03b3}\n    {\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2} {h\u03b3 : (\u03b3 : TypeIndex) < \u03b2}\n    (h\u03c1\u2081 : \u03c1\u2081\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (h\u03c1\u2082 : \u03c1\u2082\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    {A : \u2191\u03b1 \u219d \u22a5} {N\u2081 N\u2082 N\u2083 N\u2084 : NearLitter} :\n    convNearLitters\n      (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim)\n      (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A N\u2081 N\u2082 \u2192\n    convNearLitters\n      (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim)\n      (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n        (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) A N\u2083 N\u2084 \u2192\n      \u00acInflexible A N\u2081\u1d38 \u2192 \u00acInflexible A N\u2082\u1d38 \u2192 \u00acInflexible A N\u2083\u1d38 \u2192 \u00acInflexible A N\u2084\u1d38 \u2192\n      N\u2081\u1d38 = N\u2083\u1d38 \u2192 N\u2082\u1d38 = N\u2084\u1d38 := by\n  rw [Support.smul_eq_iff] at h\u03c1\u2081 h\u03c1\u2082\n  rintro \u27e8i, hi\u2081, hi\u2082\u27e9 \u27e8j, hj\u2081, hj\u2082\u27e9 hN\u2081 hN\u2082 hN\u2083 hN\u2084 hN\u2081\u2083\n  simp only [add_derivBot, BaseSupport.add_nearLitters, Rel.inv_apply,\n    Enumeration.rel_add_iff] at hi\u2081 hi\u2082 hj\u2081 hj\u2082\n  obtain hi\u2081 | \u27e8i, rfl, hi\u2081\u27e9 := hi\u2081\n  \u00b7 obtain hi\u2082 | \u27e8i, rfl, hi\u2082\u27e9 := hi\u2082\n    swap\n    \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hi\u2081\u27e9\n      simp only [add_lt_iff_neg_left] at this\n      cases (\u03ba_zero_le i).not_lt this\n    cases (Enumeration.rel_coinjective _).coinjective hi\u2081 hi\u2082\n    obtain hj\u2081 | \u27e8j, rfl, hj\u2081\u27e9 := hj\u2081\n    \u00b7 obtain hj\u2082 | \u27e8j, rfl, hj\u2082\u27e9 := hj\u2082\n      swap\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2081\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j).not_lt this\n      cases (Enumeration.rel_coinjective _).coinjective hj\u2081 hj\u2082\n      exact hN\u2081\u2083\n    \u00b7 simp only [add_right_inj, exists_eq_left] at hj\u2082\n      obtain hj\u2082 | hj\u2082 := hj\u2082\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2082\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j).not_lt this\n      obtain \u27e8A, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv \u27e8j, hj\u2081\u27e9\n      simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_nearLitters,\n        BaseSupport.add_nearLitters, Enumeration.smul_rel] at hj\u2081 hj\u2082\n      have := congr_arg (\u00b7\u1d38) ((Enumeration.rel_coinjective _).coinjective hj\u2081 hj\u2082)\n      simp only [BasePerm.smul_nearLitter_litter] at this\n      rw [\u2190 hN\u2081\u2083, \u2190 (h\u03c1\u2081 A).2 N\u2081 \u27e8i, hi\u2081\u27e9, BasePerm.smul_nearLitter_litter, inv_smul_smul] at this\n      have hN\u2081' := (h\u03c1\u2082 A).2 N\u2081 \u27e8i, hi\u2081\u27e9\n      rw [smul_eq_iff_eq_inv_smul] at hN\u2081'\n      rwa [hN\u2081', BasePerm.smul_nearLitter_litter, smul_left_cancel_iff] at this\n  \u00b7 obtain hi\u2082 | hi\u2082 := hi\u2082\n    \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hi\u2082\u27e9\n      simp only [add_lt_iff_neg_left] at this\n      cases (\u03ba_zero_le i).not_lt this\n    simp only [add_right_inj, exists_eq_left] at hi\u2082\n    obtain \u27e8A, rfl\u27e9 := eq_of_nearLitter_mem_scoderiv_botDeriv \u27e8i, hi\u2081\u27e9\n    simp only [scoderiv_botDeriv_eq, smul_derivBot, add_derivBot, BaseSupport.smul_nearLitters,\n      BaseSupport.add_nearLitters, Enumeration.smul_rel] at hi\u2081 hi\u2082 hj\u2081 hj\u2082\n    have hN\u2081\u2082 := congr_arg (\u00b7\u1d38) ((Enumeration.rel_coinjective _).coinjective hi\u2081 hi\u2082)\n    obtain hj\u2081 | \u27e8j, rfl, hj\u2081\u27e9 := hj\u2081\n    \u00b7 obtain hj\u2082 | \u27e8j, rfl, hj\u2082\u27e9 := hj\u2082\n      swap\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2081\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j).not_lt this\n      cases (Enumeration.rel_coinjective _).coinjective hj\u2081 hj\u2082\n      simp only [BasePerm.smul_nearLitter_litter] at hN\u2081\u2082\n      rw [hN\u2081\u2083, \u2190 (h\u03c1\u2081 A).2 N\u2083 \u27e8j, hj\u2081\u27e9, BasePerm.smul_nearLitter_litter, inv_smul_smul,\n        eq_inv_smul_iff, \u2190 BasePerm.smul_nearLitter_litter, (h\u03c1\u2082 A).2 N\u2083 \u27e8j, hj\u2081\u27e9] at hN\u2081\u2082\n      rw [hN\u2081\u2082]\n    \u00b7 simp only [add_right_inj, exists_eq_left] at hj\u2082\n      obtain hj\u2082 | hj\u2082 := hj\u2082\n      \u00b7 have := Enumeration.lt_bound _ _ \u27e8_, hj\u2082\u27e9\n        simp only [add_lt_iff_neg_left] at this\n        cases (\u03ba_zero_le j).not_lt this\n      have hN\u2083\u2084 := congr_arg (\u00b7\u1d38) ((Enumeration.rel_coinjective _).coinjective hj\u2081 hj\u2082)\n      simp only [BasePerm.smul_nearLitter_litter] at hN\u2081\u2082 hN\u2083\u2084\n      rw [hN\u2081\u2083] at hN\u2081\u2082\n      rwa [hN\u2081\u2082, smul_left_cancel_iff] at hN\u2083\u2084\n\ntheorem sameSpecLe_of_fixes (S : Support \u03b1) (hS : S.Strong) (T : Support \u03b3) (\u03c1\u2081 \u03c1\u2082 : AllPerm \u03b2)\n    (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n    (h\u03c1\u2081 : \u03c1\u2081\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim)\n    (h\u03c1\u2082 : \u03c1\u2082\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim) :\n    SameSpecLE\n    (S + (\u03c1\u2081\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim)\n    (S + (\u03c1\u2082\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim) := by\n  constructor\n  case atoms_bound_eq => intro; rfl\n  case nearLitters_bound_eq => intro; rfl\n  case atoms_dom_subset =>\n    simp only [add_derivBot, BaseSupport.add_atoms, Enumeration.add_rel_dom,\n      Set.union_subset_iff, Set.subset_union_left, true_and]\n    rintro A _ \u27e8i, \u27e8a, \u27e8A, a\u27e9, h\u2081, h\u2082\u27e9, rfl\u27e9\n    cases h\u2082\n    right\n    apply Set.mem_image_of_mem\n    refine \u27e8\u03c1\u2082\u1d41 A \u2022 (\u03c1\u2081\u1d41 A)\u207b\u00b9 \u2022 a, \u27e8A, \u03c1\u2082\u1d41 A \u2022 (\u03c1\u2081\u1d41 A)\u207b\u00b9 \u2022 a\u27e9, ?_, rfl\u27e9\n    rw [smul_atoms, Enumeration.smulPath_rel] at h\u2081 \u22a2\n    simp only [inv_smul_smul]\n    exact h\u2081\n  case nearLitters_dom_subset =>\n    simp only [add_derivBot, BaseSupport.add_nearLitters, Enumeration.add_rel_dom,\n      Set.union_subset_iff, Set.subset_union_left, true_and]\n    rintro A _ \u27e8i, \u27e8N, \u27e8A, N\u27e9, h\u2081, h\u2082\u27e9, rfl\u27e9\n    cases h\u2082\n    right\n    apply Set.mem_image_of_mem\n    refine \u27e8\u03c1\u2082\u1d41 A \u2022 (\u03c1\u2081\u1d41 A)\u207b\u00b9 \u2022 N, \u27e8A, \u03c1\u2082\u1d41 A \u2022 (\u03c1\u2081\u1d41 A)\u207b\u00b9 \u2022 N\u27e9, ?_, rfl\u27e9\n    rw [smul_nearLitters, Enumeration.smulPath_rel] at h\u2081 \u22a2\n    simp only [inv_smul_smul]\n    exact h\u2081\n  case convAtoms_injective => exact convAtoms_injective_of_fixes h\u03c1\u2081 h\u03c1\u2082\n  case atomMemRel_le => exact atomMemRel_le_of_fixes h\u03c1\u2081 h\u03c1\u2082\n  case inflexible_of_inflexible => exact inflexible_of_inflexible_of_fixes h\u03c1\u2081 h\u03c1\u2082\n  case atoms_of_inflexible => exact atoms_of_inflexible_of_fixes hS h\u03c1\u2081 h\u03c1\u2082\n  case nearLitters_of_inflexible => exact nearLitters_of_inflexible_of_fixes hS h\u03c1\u2081 h\u03c1\u2082\n  case litter_eq_of_flexible => exact litter_eq_of_flexible_of_fixes h\u03c1\u2081 h\u03c1\u2082\n\ntheorem spec_same_of_fixes (S : Support \u03b1) (hS : S.Strong) (T : Support \u03b3) (\u03c1 : AllPerm \u03b2)\n    (h\u03c1 : \u03c1\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim) :\n    (S + ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport) \u2197 LtLevel.elim).spec =\n    (S + (\u03c1\u1d41 \u2022 ((T \u2197 h\u03b3).strong +\n      (S \u2198 LtLevel.elim + (T \u2197 h\u03b3).strong).interferenceSupport)) \u2197 LtLevel.elim).spec := by\n  rw [Support.spec_eq_spec_iff]\n  apply sameSpec_antisymm\n  \u00b7 have := sameSpecLe_of_fixes S hS T 1 \u03c1 h\u03b3 ?_ h\u03c1\n    \u00b7 simp only [allPermForget_one, one_smul, smul_add] at this\n      exact this\n    \u00b7 simp only [allPermForget_one, one_smul]\n  \u00b7 have := sameSpecLe_of_fixes S hS T \u03c1 1 h\u03b3 h\u03c1 ?_\n    \u00b7 simp only [allPermForget_one, one_smul, smul_add] at this\n      exact this\n    \u00b7 simp only [allPermForget_one, one_smul]\n\n", "theoremStatement": "theorem exists_allowable_of_fixes (S : Support \u03b1) (hS : S.Strong) (T : Support \u03b3) (\u03c1 : AllPerm \u03b2)\n    (h\u03b3 : (\u03b3 : TypeIndex) < \u03b2)\n    (h\u03c1 : \u03c1\u1d41 \u2022 (S \u2198 LtLevel.elim : Support \u03b2) = S \u2198 LtLevel.elim) :\n    \u2203 \u03c1' : AllPerm \u03b1, \u03c1'\u1d41 \u2022 S = S \u2227 \u03c1'\u1d41 \u2198 LtLevel.elim \u2198 h\u03b3 \u2022 T = \u03c1\u1d41 \u2198 h\u03b3 \u2022 T ", "theoremName": "ConNF.Support.exists_allowable_of_fixes", "fileCreated": {"commit": "abf71bc79c407ceb462cc2edd2d994cda9cdef05", "date": "2024-04-04"}, "theoremCreated": {"commit": "2e25ffbc94af48261308cea0d8c55205cc388ef0", "date": "2024-12-01"}, "file": "ConNF/ConNF/Model/RaiseStrong.lean", "module": "ConNF.Model.RaiseStrong", "jsonFile": "ConNF.Model.RaiseStrong.jsonl", "positionMetadata": {"lineInFile": 716, "tokenPositionInFile": 35436, "theoremPositionInFile": 14}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 66, "numPremises": 110}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  have := spec_same_of_fixes (h\u03b3 := h\u03b3) S hS T \u03c1 h\u03c1\n  have := exists_conv this ?_ ?_\n  \u00b7 obtain \u27e8\u03c1', h\u03c1'\u27e9 := this\n    use \u03c1'\n    simp only [Support.smul_add] at h\u03c1'\n    obtain \u27e8h\u03c1'\u2081, h\u03c1'\u2082\u27e9 := add_inj_of_bound_eq_bound (by rfl) (by rfl) h\u03c1'\n    rw [Support.smul_scoderiv, scoderiv_inj, smul_add] at h\u03c1'\u2082\n    obtain \u27e8h\u03c1'\u2083, -\u27e9 := add_inj_of_bound_eq_bound (by rfl) (by rfl) h\u03c1'\u2082\n    have := smul_eq_smul_of_le (T \u2197 h\u03b3).subsupport_strong.le h\u03c1'\u2083\n    rw [Support.smul_scoderiv, smul_scoderiv, scoderiv_inj] at this\n    exact \u27e8h\u03c1'\u2081, this\u27e9\n  \u00b7 have := raise_strong' S hS T 1 h\u03b3 (by simp only [allPermForget_one, one_smul])\n    simp only [allPermForget_one, one_smul] at this\n    exact this\n  \u00b7 exact raise_strong' S hS T \u03c1 h\u03b3 h\u03c1", "proofType": "tactic", "proofLengthLines": 15, "proofLengthTokens": 727}}
{"srcContext": "import ConNF.Model.RaiseStrong\n\n/-!\n# New file\n\nIn this file...\n\n## Main declarations\n\n* `ConNF.foo`: Something new.\n-/\n\nnoncomputable section\nuniverse u\n\nopen Cardinal Ordinal\n\nopen scoped Pointwise\n\nnamespace ConNF\n\nvariable [Params.{u}]\n\n/-- A redefinition of the derivative of allowable permutations that is invariant of level,\nbut still has nice definitional properties. -/\n@[default_instance 200]\ninstance {\u03b2 \u03b3 : TypeIndex} : Derivative (AllPerm \u03b2) (AllPerm \u03b3) \u03b2 \u03b3 where\n  deriv \u03c1 A :=\n    A.recSderiv\n    (motive := \u03bb (\u03b4 : TypeIndex) (A : \u03b2 \u219d \u03b4) \u21a6\n      letI : Level := \u27e8\u03b4.recBotCoe (Nonempty.some inferInstance) id\u27e9\n      letI : LeLevel \u03b4 := \u27e8\u03b4.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n        (show \u03b4.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n      AllPerm \u03b4)\n    \u03c1 (\u03bb \u03b4 \u03b5 A h \u03c1 \u21a6\n      letI : Level := \u27e8\u03b4.recBotCoe (Nonempty.some inferInstance) id\u27e9\n      letI : LeLevel \u03b4 := \u27e8\u03b4.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n        (show \u03b4.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n      letI : LeLevel \u03b5 := \u27e8h.le.trans LeLevel.elim\u27e9\n      PreCoherentData.allPermSderiv h \u03c1)\n\n@[simp]\ntheorem allPerm_deriv_nil' {\u03b2 : TypeIndex}\n    (\u03c1 : AllPerm \u03b2) :\n    \u03c1 \u21d8 (.nil : \u03b2 \u219d \u03b2) = \u03c1 :=\n  rfl\n\n@[simp]\ntheorem allPerm_deriv_sderiv' {\u03b2 \u03b3 \u03b4 : TypeIndex}\n    (\u03c1 : AllPerm \u03b2) (A : \u03b2 \u219d \u03b3) (h : \u03b4 < \u03b3) :\n    \u03c1 \u21d8 (A \u2198 h) = \u03c1 \u21d8 A \u2198 h :=\n  rfl\n\n@[simp]\ntheorem allPermSderiv_forget' {\u03b2 \u03b3 : TypeIndex} (h : \u03b3 < \u03b2) (\u03c1 : AllPerm \u03b2) :\n    (\u03c1 \u2198 h)\u1d41 = \u03c1\u1d41 \u2198 h :=\n  letI : Level := \u27e8\u03b2.recBotCoe (Nonempty.some inferInstance) id\u27e9\n  letI : LeLevel \u03b2 := \u27e8\u03b2.recBotCoe (\u03bb _ \u21a6 bot_le) (\u03bb _ h \u21a6 WithBot.coe_le_coe.mpr h.le)\n    (show \u03b2.recBotCoe (Nonempty.some inferInstance) id = Level.\u03b1 from rfl)\u27e9\n  letI : LeLevel \u03b3 := \u27e8h.le.trans LeLevel.elim\u27e9\n  allPermSderiv_forget h \u03c1\n\n", "theoremStatement": "@[simp]\ntheorem allPerm_inv_sderiv' {\u03b2 \u03b3 : TypeIndex} (h : \u03b3 < \u03b2) (\u03c1 : AllPerm \u03b2) :\n    \u03c1\u207b\u00b9 \u2198 h = (\u03c1 \u2198 h)\u207b\u00b9 ", "theoremName": "ConNF.allPerm_inv_sderiv'", "fileCreated": {"commit": "6fdc87c6b30b73931407a372f1430ecf0fef7601", "date": "2024-12-03"}, "theoremCreated": {"commit": "2e25ffbc94af48261308cea0d8c55205cc388ef0", "date": "2024-12-01"}, "file": "ConNF/ConNF/Model/TTT.lean", "module": "ConNF.Model.TTT", "jsonFile": "ConNF.Model.TTT.jsonl", "positionMetadata": {"lineInFile": 63, "tokenPositionInFile": 1837, "theoremPositionInFile": 3}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 24, "numPremises": 42}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  apply allPermForget_injective\n  rw [allPermSderiv_forget', allPermForget_inv, Tree.inv_sderiv, allPermForget_inv,\n    allPermSderiv_forget']", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 148}}
