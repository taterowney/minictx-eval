{"srcContext": "/-\nCopyright (c) 2024 James Sundstrom. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: James Sundstrom\n-/\nimport Mathlib.MeasureTheory.Constructions.BorelSpace.Metric\n\n/-!\n# Annulus\n\nIn this file we define an annulus in a pseudometric space `X` to be a set consisting of all `y`\nsuch that `dist x y` lies in an interval between `r` and `R`. An annulus is defined for each type\nof interval (`Ioo`, `Ioc`, etc.) with a parallel naming scheme, except that we do not define annuli\nfor `Iio` and `Ico`, as they would be balls.\n\nWe also define `EAnnulus` similarly using `edist` instead of `dist`.\n\n## Tags\n\nannulus, eannulus\n-/\n\nopen Set Metric ENNReal\n\nvariable {X : Type*} [PseudoMetricSpace X]\n\nnamespace Set\n\nnamespace Annulus\n\ndef oo (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d) := {y | dist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d) := {y | dist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d) := {y | dist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d) := {y | dist x y \u2208 Ici r}\n\nlemma oo_eq {x : X} {r R : \u211d} : oo x r R = ball x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oo, dist_comm, and_comm]\n\nlemma oc_eq {x : X} {r R : \u211d} : oc x r R = closedBall x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oc, dist_comm, and_comm]\n\nlemma co_eq {x : X} {r R : \u211d} : co x r R = ball x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [co, dist_comm, and_comm]\n\nlemma cc_eq {x : X} {r R : \u211d} : cc x r R = closedBall x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [cc, dist_comm, and_comm]\n\nlemma oi_eq {x : X} {r : \u211d} : oi x r = (closedBall x r)\u1d9c := by\n  ext; simp [oi, dist_comm]\n\nlemma ci_eq {x : X} {r : \u211d} : ci x r = (ball x r)\u1d9c := by\n  ext; simp [ci, dist_comm]\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : co x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma co_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : co x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\nlemma cc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : cc x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma cc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : cc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\n@[simp]\nlemma oc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    oc x r r' \u222a oo x r' R = oo x r R := by\n  ext; simp_rw [oc, oo, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioo_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    oc x r r' \u222a oc x r' R = oc x r R := by\n  ext; simp_rw [oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_co {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a co x r' R = oo x r R := by\n  ext; simp_rw [oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ico_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a cc x r' R = oc x r R := by\n  ext; simp_rw [oo, cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Icc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    cc x r r' \u222a oo x r' R = co x r R := by\n  ext; simp_rw [cc, oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioo_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    cc x r r' \u222a oc x r' R = cc x r R := by\n  ext; simp_rw [cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_co {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a co x r' R = co x r R := by\n  ext; simp_rw [co, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ico_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a cc x r' R = cc x r R := by\n  ext; simp_rw [co, cc, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Icc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : oc x r R \u222a oi x R = oi x r := by\n  ext; simp_rw [oc, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioi_eq_Ioi h]\n\n@[simp]\nlemma oo_union_ci {x : X} {r R : \u211d} (h : r < R) :\n    oo x r R \u222a ci x R = oi x r := by\n  ext; simp_rw [oo, ci, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ici_eq_Ioi h]\n\n@[simp]\nlemma cc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : cc x r R \u222a oi x R = ci x r := by\n  ext; simp_rw [cc, oi, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioi_eq_Ici h]\n\n@[simp]\nlemma co_union_ci {x : X} {r R : \u211d} (h : r \u2264 R) : co x r R \u222a ci x R = ci x r := by\n  ext; simp_rw [co, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ici_eq_Ici h]\n\n\nvariable [MeasurableSpace X] [OpensMeasurableSpace X]\n\n@[measurability]\nlemma measurableSet_oo {x : X} {r R : \u211d} : MeasurableSet (oo x r R) := by\n  rw [oo_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oc {x : X} {r R : \u211d} : MeasurableSet (oc x r R) := by\n rw [oc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_co {x : X} {r R : \u211d} : MeasurableSet (co x r R) := by\n  rw [co_eq]; measurability\n\n@[measurability]\nlemma measurableSet_cc {x : X} {r R : \u211d} : MeasurableSet (cc x r R) := by\n rw [cc_eq]; measurability\n\n", "theoremStatement": "@[measurability]\nlemma measurableSet_oi {x : X} {r : \u211d} : MeasurableSet (oi x r) ", "theoremName": "Set.Annulus.measurableSet_oi", "fileCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "theoremCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "file": "carleson/Carleson/ToMathlib/Annulus.lean", "module": "Carleson.ToMathlib.Annulus", "jsonFile": "Carleson.ToMathlib.Annulus.jsonl", "positionMetadata": {"lineInFile": 237, "tokenPositionInFile": 8822, "theoremPositionInFile": 56}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 20}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [oi_eq]; measurability", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 33}}
{"srcContext": "import Mathlib.Analysis.Convex.PartitionOfUnity\nimport Mathlib.Analysis.Calculus.ContDiff.Basic\nimport Mathlib.MeasureTheory.Integral.Average\nimport Mathlib.MeasureTheory.Integral.Bochner\nimport Mathlib.MeasureTheory.Measure.Haar.OfBasis\nimport Mathlib.Topology.MetricSpace.Holder\nimport Mathlib.Data.Set.Card\nimport Mathlib.Data.Real.ENatENNReal\nimport Carleson.ToMathlib.MeasureReal\n\n/-\n* This file can import all ToMathlib files.\n* If adding more than a few results, please put them in a more appropriate file in ToMathlib.\n-/\n\nopen Function Set\nopen scoped ENNReal\n\nsection ENNReal\n\nlemma tsum_one_eq' {\u03b1 : Type*} (s : Set \u03b1) : \u2211' (_:s), (1 : \u211d\u22650\u221e) = s.encard := by\n  if hfin : s.Finite then\n    have hfin' : Finite s := hfin\n    rw [tsum_def]\n    simp only [ENNReal.summable, \u2193reduceDIte]\n    have hsup: support (fun (_ : s) \u21a6 (1 : \u211d\u22650\u221e)) = Set.univ := by\n      ext i\n      simp only [mem_support, ne_eq, one_ne_zero, not_false_eq_true, mem_univ]\n    have hsupfin: (Set.univ : Set s).Finite := finite_univ\n    rw [\u2190 hsup] at hsupfin\n    rw [if_pos hsupfin]\n    rw [hfin.encard_eq_coe_toFinset_card]\n    simp only [ENat.toENNReal_coe]\n    rw [Finset.card_eq_sum_ones]\n    rw [finsum_eq_sum (fun (_ : s) \u21a6 (1 :\u211d\u22650\u221e)) hsupfin]\n    simp only [Finset.sum_const, nsmul_eq_mul, mul_one, smul_eq_mul, Nat.cast_inj]\n    apply Finset.card_bij (fun a _ => a.val)\n    \u00b7 intro a\n      simp only [Finite.mem_toFinset, mem_support, ne_eq, one_ne_zero, not_false_eq_true,\n        Subtype.coe_prop, imp_self]\n    \u00b7 intro a _ a' _ heq\n      ext\n      exact heq\n    \u00b7 intro a ha\n      use \u27e8a,by\n        simp only [Finite.mem_toFinset] at ha\n        exact ha\u27e9\n      simp only [Finite.mem_toFinset, mem_support, ne_eq, one_ne_zero, not_false_eq_true,\n        exists_const]\n  else\n  have : Infinite s := infinite_coe_iff.mpr hfin\n  rw [ENNReal.tsum_const_eq_top_of_ne_zero (by norm_num)]\n  rw [Set.encard_eq_top_iff.mpr hfin]\n  simp only [ENat.toENNReal_top]\n\nlemma ENNReal.tsum_const_eq' {\u03b1 : Type*} (s : Set \u03b1) (c : \u211d\u22650\u221e) :\n    \u2211' (_:s), (c : \u211d\u22650\u221e) = s.encard * c := by\n  nth_rw 1 [\u2190 one_mul c]\n  rw [ENNReal.tsum_mul_right,tsum_one_eq']\n\n/-! ## `ENNReal` manipulation lemmas -/\n\nlemma ENNReal.sum_geometric_two_pow_toNNReal {k : \u2115} (hk : k > 0) :\n    \u2211' (n : \u2115), (2 : \u211d\u22650\u221e) ^ (-k * n : \u2124) = (1 / (1 - 1 / 2 ^ k) : \u211d).toNNReal := by\n  conv_lhs =>\n    enter [1, n]\n    rw [\u2190 rpow_intCast, show (-k * n : \u2124) = (-k * n : \u211d) by simp, rpow_mul, rpow_natCast]\n  rw [tsum_geometric, show (2 : \u211d\u22650\u221e) = (2 : \u211d).toNNReal by simp,\n    \u2190 coe_rpow_of_ne_zero (by simp), \u2190 Real.toNNReal_rpow_of_nonneg zero_le_two,\n    \u2190 coe_one, \u2190 Real.toNNReal_one, \u2190 coe_sub, NNReal.sub_def,\n    Real.toNNReal_one, NNReal.coe_one, Real.coe_toNNReal', max_eq_left (by positivity),\n    Real.rpow_neg zero_le_two, Real.rpow_natCast, one_div]\n  have : ((1 : \u211d) - (2 ^ k)\u207b\u00b9).toNNReal \u2260 0 := by\n    rw [ne_eq, Real.toNNReal_eq_zero, tsub_le_iff_right, zero_add, not_le, inv_lt_one_iff\u2080]\n    right; exact one_lt_pow\u2080 (M\u2080 := \u211d) _root_.one_lt_two hk.ne'\n  rw [\u2190 coe_inv this, coe_inj, Real.toNNReal_inv, one_div]\n\nlemma ENNReal.sum_geometric_two_pow_neg_one : \u2211' (n : \u2115), (2 : \u211d\u22650\u221e) ^ (-n : \u2124) = 2 := by\n  conv_lhs => enter [1, n]; rw [\u2190 one_mul (n : \u2124), \u2190 neg_mul, \u2190 Nat.cast_one]\n  rw [ENNReal.sum_geometric_two_pow_toNNReal zero_lt_one]; norm_num\n\nlemma ENNReal.sum_geometric_two_pow_neg_two :\n    \u2211' (n : \u2115), (2 : \u211d\u22650\u221e) ^ (-2 * n : \u2124) = ((4 : \u211d) / 3).toNNReal := by\n  conv_lhs => enter [1, n, 2]; rw [\u2190 Nat.cast_two]\n  rw [ENNReal.sum_geometric_two_pow_toNNReal zero_lt_two]; norm_num\n\nlemma tsum_geometric_ite_eq_tsum_geometric {k c : \u2115} :\n    (\u2211' (n : \u2115), if k \u2264 n then (2 : \u211d\u22650\u221e) ^ (-c * (n - k) : \u2124) else 0) =\n    \u2211' (n : \u2115), 2 ^ (-c * n : \u2124) := by\n  convert (Injective.tsum_eq (f := fun n \u21a6 if k \u2264 n then (2 : \u211d\u22650\u221e) ^ (-c * (n - k) : \u2124) else 0)\n    (add_left_injective k) (fun n mn \u21a6 _)).symm\n  \u00b7 simp\n  \u00b7 rw [mem_support, ne_eq, ite_eq_right_iff, Classical.not_imp] at mn\n    use n - k, Nat.sub_add_cancel mn.1\n\nlemma ENNReal.toReal_zpow (x : \u211d\u22650\u221e) (z : \u2124) : x.toReal ^ z = (x ^ z).toReal := by\n  rw [\u2190 rpow_intCast, \u2190 toReal_rpow, Real.rpow_intCast]\n\nend ENNReal\n\nsection Indicator\nattribute [gcongr] Set.indicator_le_indicator mulIndicator_le_mulIndicator_of_subset\nend Indicator\n\n\nnamespace MeasureTheory\n\n/-! ## Partitioning an interval -/\n\n\nlemma lintegral_Ioc_partition {a b : \u2115} {c : \u211d} {f : \u211d \u2192 \u211d\u22650\u221e} (hc : 0 \u2264 c) :\n    \u222b\u207b t in Ioc (a * c) (b * c), f t =\n    \u2211 l \u2208 Finset.Ico a b, \u222b\u207b t in Ioc (l * c) ((l + 1 : \u2115) * c), f t := by\n  rcases lt_or_le b a with h | h\n  \u00b7 rw [Finset.Ico_eq_empty (by omega), Ioc_eq_empty (by rw [not_lt]; gcongr),\n      setLIntegral_empty, Finset.sum_empty]\n  induction b, h using Nat.le_induction with\n  | base =>\n    rw [Finset.Ico_self, Ioc_self, setLIntegral_empty, Finset.sum_empty]\n  | succ b h ih =>\n    have li : a * c \u2264 b * c := by gcongr\n    rw [\u2190 Ioc_union_Ioc_eq_Ioc li (by gcongr; omega),\n      lintegral_union measurableSet_Ioc Ioc_disjoint_Ioc_same,\n      Nat.Ico_succ_right_eq_insert_Ico h, Finset.sum_insert Finset.right_not_mem_Ico,\n      add_comm (lintegral ..), ih]\n\n/-! ## Averaging -/\n\n-- Named for consistency with `lintegral_add_left'`\n-- Maybe add laverage/laverage theorems for all the other lintegral_add statements?\nlemma laverage_add_left {\u03b1 : Type*} {m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}\n    {f g : \u03b1 \u2192 ENNReal} (hf : AEMeasurable f \u03bc) :\n    \u2a0d\u207b x, (f x + g x) \u2202\u03bc = \u2a0d\u207b x, f x \u2202\u03bc + \u2a0d\u207b x, g x \u2202\u03bc := by\n  simp_rw [laverage_eq, ENNReal.div_add_div_same, lintegral_add_left' hf]\n\n-- Named for consistency with `lintegral_mono'`\nlemma laverage_mono {\u03b1 : Type*} {m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}\n    {f g : \u03b1 \u2192 ENNReal} (h : \u2200 x, f x \u2264 g x) :\n    \u2a0d\u207b x, f x \u2202\u03bc \u2264 \u2a0d\u207b x, g x \u2202\u03bc := by\n  simp_rw [laverage_eq]\n  exact ENNReal.div_le_div_right (lintegral_mono h) (\u03bc univ)\n\nlemma laverage_const_mul {\u03b1 : Type*} {m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}\n    {f : \u03b1 \u2192 ENNReal} {c : ENNReal} (hc : c \u2260 \u22a4) :\n    c * \u2a0d\u207b x, f x \u2202\u03bc = \u2a0d\u207b x, c * f x \u2202\u03bc := by\n  simp_rw [laverage_eq, \u2190 mul_div_assoc c, lintegral_const_mul' c f hc]\n\n-- The following two lemmas are unused\n\n-- Named for consistency with `lintegral_add_left'`\n-- Maybe add laverage/setLaverage theorems for all the other lintegral_add statements?\nlemma setLaverage_add_left' {\u03b1 : Type*} {m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}\n    {s : Set \u03b1} {f g : \u03b1 \u2192 ENNReal} (hf : AEMeasurable f \u03bc) :\n    \u2a0d\u207b x in s, (f x + g x) \u2202\u03bc = \u2a0d\u207b x in s, f x \u2202\u03bc + \u2a0d\u207b x in s, g x \u2202\u03bc := by\n  simp_rw [setLaverage_eq, ENNReal.div_add_div_same, lintegral_add_left' hf.restrict]\n\n-- Named for consistency with `setLintegral_mono'`\nlemma setLaverage_mono' {\u03b1 : Type*} {m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}\n    {s : Set \u03b1} (hs : MeasurableSet s) {f g : \u03b1 \u2192 ENNReal} (h : \u2200 x \u2208 s, f x \u2264 g x) :\n    \u2a0d\u207b x in s, f x \u2202\u03bc \u2264 \u2a0d\u207b x in s, g x \u2202\u03bc := by\n  simp_rw [setLaverage_eq]\n  exact ENNReal.div_le_div_right (setLIntegral_mono' hs h) (\u03bc s)\n\nend MeasureTheory\n\nnamespace MeasureTheory\nvariable {\u03b1 : Type*} {m : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} {s : Set \u03b1}\n  {F : Type*} [NormedAddCommGroup F]\n\nattribute [fun_prop] Continuous.comp_aestronglyMeasurable\n  AEStronglyMeasurable.mul AEStronglyMeasurable.prod_mk\nattribute [gcongr] Measure.AbsolutelyContinuous.prod -- todo: also add one-sided versions for gcongr\n\n\ntheorem AEStronglyMeasurable.ennreal_toReal {u : \u03b1 \u2192 \u211d\u22650\u221e} (hu : AEStronglyMeasurable u \u03bc) :\n    AEStronglyMeasurable (fun x \u21a6 (u x).toReal) \u03bc := by\n  refine aestronglyMeasurable_iff_aemeasurable.mpr ?_\n  exact ENNReal.measurable_toReal.comp_aemeasurable hu.aemeasurable\n\nlemma laverage_mono_ae {f g : \u03b1 \u2192 \u211d\u22650\u221e} (h : \u2200\u1d50 a \u2202\u03bc, f a \u2264 g a) :\n    \u2a0d\u207b a, f a \u2202\u03bc \u2264 \u2a0d\u207b a, g a \u2202\u03bc := by\n  exact lintegral_mono_ae <| h.filter_mono <| Measure.ae_mono' Measure.smul_absolutelyContinuous\n\n@[gcongr]\nlemma setLAverage_mono_ae {f g : \u03b1 \u2192 \u211d\u22650\u221e} (h : \u2200\u1d50 a \u2202\u03bc, f a \u2264 g a) :\n    \u2a0d\u207b a in s, f a \u2202\u03bc \u2264 \u2a0d\u207b a in s, g a \u2202\u03bc := by\n  refine laverage_mono_ae <| h.filter_mono <| ae_mono Measure.restrict_le_self\n\nlemma setLaverage_const_le {c : \u211d\u22650\u221e} : \u2a0d\u207b _x in s, c \u2202\u03bc \u2264 c := by\n  simp_rw [setLaverage_eq, lintegral_const, Measure.restrict_apply MeasurableSet.univ,\n    univ_inter, div_eq_mul_inv, mul_assoc]\n  conv_rhs => rw [\u2190 mul_one c]\n  gcongr\n  exact ENNReal.mul_inv_le_one (\u03bc s)\n\ntheorem eLpNormEssSup_lt_top_of_ae_ennnorm_bound {f : \u03b1 \u2192 F} {C : \u211d\u22650\u221e}\n    (hfC : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016\u208a \u2264 C) : eLpNormEssSup f \u03bc \u2264 C := essSup_le_of_ae_le C hfC\n\n@[simp]\nlemma ENNReal.nnorm_toReal {x : \u211d\u22650\u221e} : \u2016x.toReal\u2016\u208a = x.toNNReal := by\n  ext; simp [ENNReal.toReal]\n\ntheorem restrict_absolutelyContinuous : \u03bc.restrict s \u226a \u03bc :=\n  fun s hs \u21a6 Measure.restrict_le_self s |>.trans hs.le |>.antisymm <| zero_le _\n\nend MeasureTheory\n\nsection\n\nopen MeasureTheory Bornology\nvariable {E X : Type*} {p : \u211d\u22650\u221e} [NormedAddCommGroup E] [TopologicalSpace X] [MeasurableSpace X]\n  {\u03bc : Measure X} [IsFiniteMeasureOnCompacts \u03bc] {f : X \u2192 E}\n\n---- now obsolete -> `BoundedCompactSupport.mem\u2112p`\n-- lemma _root_.HasCompactSupport.mem\u2112p_of_isBounded (hf : HasCompactSupport f)\n--     (h2f : IsBounded (range f))\n--     (h3f : AEStronglyMeasurable f \u03bc) {p : \u211d\u22650\u221e} : Mem\u2112p f p \u03bc := by\n--   obtain \u27e8C, hC\u27e9 := h2f.exists_norm_le\n--   simp only [mem_range, forall_exists_index, forall_apply_eq_imp_iff] at hC\n--   exact hf.mem\u2112p_of_bound h3f C <| .of_forall hC\n\nend\n\n/-! ## `EquivalenceOn` -/\n\n/-- An equivalence relation on the set `s`. -/\nstructure EquivalenceOn {\u03b1 : Type*} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : Set \u03b1) : Prop where\n  /-- An equivalence relation is reflexive: `x ~ x` -/\n  refl  : \u2200 x \u2208 s, r x x\n  /-- An equivalence relation is symmetric: `x ~ y` implies `y ~ x` -/\n  symm  : \u2200 {x y}, x \u2208 s \u2192 y \u2208 s \u2192 r x y \u2192 r y x\n  /-- An equivalence relation is transitive: `x ~ y` and `y ~ z` implies `x ~ z` -/\n  trans : \u2200 {x y z}, x \u2208 s \u2192 y \u2208 s \u2192 z \u2208 s \u2192 r x y \u2192 r y z \u2192 r x z\n\n\nnamespace EquivalenceOn\n\nvariable {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : Set \u03b1} {hr : EquivalenceOn r s} {x y : \u03b1}\n\nvariable (hr) in\n/-- The setoid defined from an equivalence relation on a set. -/\nprotected def setoid : Setoid s where\n  r x y := r x y\n  iseqv := {\n    refl := fun x \u21a6 hr.refl x x.2\n    symm := fun {x y} \u21a6 hr.symm x.2 y.2\n    trans := fun {x y z} \u21a6 hr.trans x.2 y.2 z.2\n  }\n\ninclude hr in\nlemma exists_rep (x : \u03b1) : \u2203 y, x \u2208 s \u2192 y \u2208 s \u2227 r x y :=\n  \u27e8x, fun hx \u21a6 \u27e8hx, hr.refl x hx\u27e9\u27e9\n\nopen Classical in\nvariable (hr) in\n/-- An arbitrary representative of `x` w.r.t. the equivalence relation `r`. -/\nprotected noncomputable def out (x : \u03b1) : \u03b1 :=\n  if hx : x \u2208 s then (Quotient.out (s := hr.setoid) \u27e6\u27e8x, hx\u27e9\u27e7 : s) else x\n\nlemma out_mem (hx : x \u2208 s) : hr.out x \u2208 s := by\n  rw [EquivalenceOn.out, dif_pos hx]\n  apply Subtype.prop\n\n@[simp]\nlemma out_mem_iff : hr.out x \u2208 s \u2194 x \u2208 s := by\n  refine \u27e8fun h \u21a6 ?_, out_mem\u27e9\n  by_contra hx\n  rw [EquivalenceOn.out, dif_neg hx] at h\n  exact hx h\n\nlemma out_rel (hx : x \u2208 s) : r (hr.out x) x := by\n  rw [EquivalenceOn.out, dif_pos hx]\n  exact @Quotient.mk_out _ (hr.setoid) \u27e8x, hx\u27e9\n\nlemma rel_out (hx : x \u2208 s) : r x (hr.out x) := hr.symm (out_mem hx) hx (out_rel hx)\n\nlemma out_inj (hx : x \u2208 s) (hy : y \u2208 s) (h : r x y) : hr.out x = hr.out y := by\n  simp_rw [EquivalenceOn.out, dif_pos hx, dif_pos hy]\n  congr 1\n  simp_rw [Quotient.out_inj, Quotient.eq]\n  exact h\n\nlemma out_inj' (hx : x \u2208 s) (hy : y \u2208 s) (h : r (hr.out x) (hr.out y)) : hr.out x = hr.out y := by\n  apply out_inj hx hy\n  refine hr.trans hx ?_ hy (rel_out hx) <| hr.trans ?_ ?_ hy h <| out_rel hy\n  all_goals simpa\n\nvariable (hr) in\n/-- The set of representatives of an equivalence relation on a set. -/\ndef reprs : Set \u03b1 := hr.out '' s\n\nlemma out_mem_reprs (hx : x \u2208 s) : hr.out x \u2208 hr.reprs := \u27e8x, hx, rfl\u27e9\n\nlemma reprs_subset : hr.reprs \u2286 s := by\n  rintro _ \u27e8x, hx, rfl\u27e9\n  exact out_mem hx\n\nlemma reprs_inj (hx : x \u2208 hr.reprs) (hy : y \u2208 hr.reprs) (h : r x y) : x = y := by\n  obtain \u27e8x, hx, rfl\u27e9 := hx\n  obtain \u27e8y, hy, rfl\u27e9 := hy\n  exact out_inj' hx hy h\n\nend EquivalenceOn\n\nnamespace Set.Finite\n\nlemma biSup_eq {\u03b1 : Type*} {\u03b9 : Type*} [CompleteLinearOrder \u03b1] {s : Set \u03b9}\n    (hs : s.Finite) (hs' : s.Nonempty) (f : \u03b9 \u2192 \u03b1) :\n    \u2203 i \u2208 s, \u2a06 j \u2208 s, f j = f i := by\n  simpa [sSup_image, eq_comm] using hs'.image f |>.csSup_mem (hs.image f)\n\nend Set.Finite\n\nlemma Real.self_lt_two_rpow (x : \u211d) : x < 2 ^ x := by\n  rcases lt_or_le x 0 with h | h\n  \u00b7 exact h.trans (rpow_pos_of_pos zero_lt_two x)\n  \u00b7 calc\n      _ < (\u230ax\u230b\u208a.succ : \u211d) := Nat.lt_succ_floor x\n      _ \u2264 2 ^ (\u230ax\u230b\u208a : \u211d) := by exact_mod_cast Nat.lt_pow_self one_lt_two\n      _ \u2264 _ := rpow_le_rpow_of_exponent_le one_le_two (Nat.floor_le h)\n\nnamespace Set\n\nopen ComplexConjugate\n\n", "theoremStatement": "lemma indicator_eq_indicator_one_mul {\u03b9 M:Type*} [MulZeroOneClass M]\n    (s : Set \u03b9) (f : \u03b9 \u2192 M) (x : \u03b9) : s.indicator f x = s.indicator 1 x * f x ", "theoremName": "Set.indicator_eq_indicator_one_mul", "fileCreated": {"commit": "f75995f44d3cb33c8f91a124bbc1149e570a24c5", "date": "2023-12-11"}, "theoremCreated": {"commit": "ec175b9008144d009269ce427b9ad43dbd70d0a5", "date": "2024-12-09"}, "file": "carleson/Carleson/ToMathlib/Misc.lean", "module": "Carleson.ToMathlib.Misc", "jsonFile": "Carleson.ToMathlib.Misc.jsonl", "positionMetadata": {"lineInFile": 326, "tokenPositionInFile": 12505, "theoremPositionInFile": 34}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 35}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp only [indicator]; split_ifs <;> simp", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 49}}
{"srcContext": "/-\nCopyright (c) 2024 James Sundstrom. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: James Sundstrom\n-/\nimport Mathlib.MeasureTheory.Constructions.BorelSpace.Metric\n\n/-!\n# Annulus\n\nIn this file we define an annulus in a pseudometric space `X` to be a set consisting of all `y`\nsuch that `dist x y` lies in an interval between `r` and `R`. An annulus is defined for each type\nof interval (`Ioo`, `Ioc`, etc.) with a parallel naming scheme, except that we do not define annuli\nfor `Iio` and `Ico`, as they would be balls.\n\nWe also define `EAnnulus` similarly using `edist` instead of `dist`.\n\n## Tags\n\nannulus, eannulus\n-/\n\nopen Set Metric ENNReal\n\nvariable {X : Type*} [PseudoMetricSpace X]\n\nnamespace Set\n\nnamespace Annulus\n\ndef oo (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d) := {y | dist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d) := {y | dist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d) := {y | dist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d) := {y | dist x y \u2208 Ici r}\n\nlemma oo_eq {x : X} {r R : \u211d} : oo x r R = ball x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oo, dist_comm, and_comm]\n\nlemma oc_eq {x : X} {r R : \u211d} : oc x r R = closedBall x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oc, dist_comm, and_comm]\n\nlemma co_eq {x : X} {r R : \u211d} : co x r R = ball x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [co, dist_comm, and_comm]\n\nlemma cc_eq {x : X} {r R : \u211d} : cc x r R = closedBall x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [cc, dist_comm, and_comm]\n\nlemma oi_eq {x : X} {r : \u211d} : oi x r = (closedBall x r)\u1d9c := by\n  ext; simp [oi, dist_comm]\n\nlemma ci_eq {x : X} {r : \u211d} : ci x r = (ball x r)\u1d9c := by\n  ext; simp [ci, dist_comm]\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : co x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma co_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : co x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\nlemma cc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : cc x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma cc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : cc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\n@[simp]\nlemma oc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    oc x r r' \u222a oo x r' R = oo x r R := by\n  ext; simp_rw [oc, oo, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioo_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    oc x r r' \u222a oc x r' R = oc x r R := by\n  ext; simp_rw [oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_co {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a co x r' R = oo x r R := by\n  ext; simp_rw [oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ico_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a cc x r' R = oc x r R := by\n  ext; simp_rw [oo, cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Icc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    cc x r r' \u222a oo x r' R = co x r R := by\n  ext; simp_rw [cc, oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioo_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    cc x r r' \u222a oc x r' R = cc x r R := by\n  ext; simp_rw [cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_co {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a co x r' R = co x r R := by\n  ext; simp_rw [co, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ico_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a cc x r' R = cc x r R := by\n  ext; simp_rw [co, cc, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Icc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : oc x r R \u222a oi x R = oi x r := by\n  ext; simp_rw [oc, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioi_eq_Ioi h]\n\n@[simp]\nlemma oo_union_ci {x : X} {r R : \u211d} (h : r < R) :\n    oo x r R \u222a ci x R = oi x r := by\n  ext; simp_rw [oo, ci, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ici_eq_Ioi h]\n\n@[simp]\nlemma cc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : cc x r R \u222a oi x R = ci x r := by\n  ext; simp_rw [cc, oi, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioi_eq_Ici h]\n\n@[simp]\nlemma co_union_ci {x : X} {r R : \u211d} (h : r \u2264 R) : co x r R \u222a ci x R = ci x r := by\n  ext; simp_rw [co, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ici_eq_Ici h]\n\n\nvariable [MeasurableSpace X] [OpensMeasurableSpace X]\n\n@[measurability]\nlemma measurableSet_oo {x : X} {r R : \u211d} : MeasurableSet (oo x r R) := by\n  rw [oo_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oc {x : X} {r R : \u211d} : MeasurableSet (oc x r R) := by\n rw [oc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_co {x : X} {r R : \u211d} : MeasurableSet (co x r R) := by\n  rw [co_eq]; measurability\n\n@[measurability]\nlemma measurableSet_cc {x : X} {r R : \u211d} : MeasurableSet (cc x r R) := by\n rw [cc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oi {x : X} {r : \u211d} : MeasurableSet (oi x r) := by\n  rw [oi_eq]; measurability\n\n@[measurability]\nlemma measurableSet_ci {x : X} {r : \u211d} : MeasurableSet (ci x r) := by\n  rw [ci_eq]; measurability\n\nend Annulus\n\nnamespace EAnnulus\n\ndef oo (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ici r}\n\n\nlemma oo_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oo x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oo x r R := by\n  simp_rw [oo, Annulus.oo, edist_dist, mem_Ioo, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma oc_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [oc, Annulus.oc, edist_dist, mem_Ioc, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  \u00b7 have R_le_r := (lt_of_lt_of_le (lt_of_not_ge hR) hr).le\n    rw [Annulus.oc_eq_empty R_le_r]\n    refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n    exact not_le_of_gt (lt_of_le_of_lt (ENNReal.ofReal_le_ofReal R_le_r) hy.1) hy.2\n\nlemma co_eq_annulus {x : X} {r R : \u211d} :\n    co x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.co x r R := by\n  simp_rw [co, Annulus.co, edist_dist, mem_Ico, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma cc_eq_annulus {x : X} {r R : \u211d} (h : r > 0 \u2228 R \u2265 0) :\n    cc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.cc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [cc, Annulus.cc, edist_dist, mem_Icc, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  have r0 := h.resolve_right hR\n  have R_lt_r := (lt_of_not_ge hR).trans r0\n  rw [Annulus.cc_eq_empty R_lt_r]\n  refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n  exact not_le_of_gt ((ENNReal.ofReal_lt_ofReal_iff r0).mpr R_lt_r) (hy.1.trans hy.2)\n\nlemma oi_eq_annulus {x : X} {r : \u211d} (hr : r \u2265 0) : oi x (ENNReal.ofReal r) = Annulus.oi x r := by\n  simp_rw [oi, Annulus.oi, edist_dist, mem_Ioi, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr]\n\nlemma ci_eq_annulus {x : X} {r : \u211d} : ci x (ENNReal.ofReal r) = Annulus.ci x r := by\n  simp_rw [ci, Annulus.ci, edist_dist, mem_Ici, ENNReal.ofReal_le_ofReal_iff dist_nonneg]\n\n\nlemma oo_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oo x r R = ball x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oo, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma oc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oc x r R = closedBall x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oc, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma co_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    co x r R = ball x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [co, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma cc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    cc x r R = closedBall x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [cc, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma oi_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : oi x r = (closedBall x r.toReal)\u1d9c := by\n  ext; simp [oi, edist_dist, dist_comm, lt_ofReal_iff_toReal_lt hr.ne]\n\nlemma ci_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : ci x r = (ball x r.toReal)\u1d9c := by\n  ext; simp [ci, edist_dist, dist_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg]\n\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n", "theoremStatement": "@[simp]\nlemma cc_top_eq_empty {x : X} {R : \u211d\u22650\u221e} : cc x \u22a4 R = \u2205 ", "theoremName": "Set.EAnnulus.cc_top_eq_empty", "fileCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "theoremCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "file": "carleson/Carleson/ToMathlib/Annulus.lean", "module": "Carleson.ToMathlib.Annulus", "jsonFile": "Carleson.ToMathlib.Annulus.jsonl", "positionMetadata": {"lineInFile": 342, "tokenPositionInFile": 13233, "theoremPositionInFile": 80}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 1, "numPremises": 30}, "proofMetadata": {"hasProof": true, "proof": ":=\n  eq_empty_of_forall_not_mem (fun y hy \u21a6 (edist_ne_top x y) (top_le_iff.mp hy.1))", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 84}}
{"srcContext": "/-\nCopyright (c) 2024 James Sundstrom. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: James Sundstrom\n-/\nimport Mathlib.MeasureTheory.Constructions.BorelSpace.Metric\n\n/-!\n# Annulus\n\nIn this file we define an annulus in a pseudometric space `X` to be a set consisting of all `y`\nsuch that `dist x y` lies in an interval between `r` and `R`. An annulus is defined for each type\nof interval (`Ioo`, `Ioc`, etc.) with a parallel naming scheme, except that we do not define annuli\nfor `Iio` and `Ico`, as they would be balls.\n\nWe also define `EAnnulus` similarly using `edist` instead of `dist`.\n\n## Tags\n\nannulus, eannulus\n-/\n\nopen Set Metric ENNReal\n\nvariable {X : Type*} [PseudoMetricSpace X]\n\nnamespace Set\n\nnamespace Annulus\n\ndef oo (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d) := {y | dist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d) := {y | dist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d) := {y | dist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d) := {y | dist x y \u2208 Ici r}\n\nlemma oo_eq {x : X} {r R : \u211d} : oo x r R = ball x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oo, dist_comm, and_comm]\n\nlemma oc_eq {x : X} {r R : \u211d} : oc x r R = closedBall x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oc, dist_comm, and_comm]\n\nlemma co_eq {x : X} {r R : \u211d} : co x r R = ball x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [co, dist_comm, and_comm]\n\nlemma cc_eq {x : X} {r R : \u211d} : cc x r R = closedBall x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [cc, dist_comm, and_comm]\n\nlemma oi_eq {x : X} {r : \u211d} : oi x r = (closedBall x r)\u1d9c := by\n  ext; simp [oi, dist_comm]\n\nlemma ci_eq {x : X} {r : \u211d} : ci x r = (ball x r)\u1d9c := by\n  ext; simp [ci, dist_comm]\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : co x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma co_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : co x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\nlemma cc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : cc x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma cc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : cc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\n@[simp]\nlemma oc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    oc x r r' \u222a oo x r' R = oo x r R := by\n  ext; simp_rw [oc, oo, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioo_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    oc x r r' \u222a oc x r' R = oc x r R := by\n  ext; simp_rw [oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_co {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a co x r' R = oo x r R := by\n  ext; simp_rw [oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ico_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a cc x r' R = oc x r R := by\n  ext; simp_rw [oo, cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Icc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    cc x r r' \u222a oo x r' R = co x r R := by\n  ext; simp_rw [cc, oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioo_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    cc x r r' \u222a oc x r' R = cc x r R := by\n  ext; simp_rw [cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_co {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a co x r' R = co x r R := by\n  ext; simp_rw [co, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ico_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a cc x r' R = cc x r R := by\n  ext; simp_rw [co, cc, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Icc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : oc x r R \u222a oi x R = oi x r := by\n  ext; simp_rw [oc, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioi_eq_Ioi h]\n\n@[simp]\nlemma oo_union_ci {x : X} {r R : \u211d} (h : r < R) :\n    oo x r R \u222a ci x R = oi x r := by\n  ext; simp_rw [oo, ci, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ici_eq_Ioi h]\n\n@[simp]\nlemma cc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : cc x r R \u222a oi x R = ci x r := by\n  ext; simp_rw [cc, oi, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioi_eq_Ici h]\n\n@[simp]\nlemma co_union_ci {x : X} {r R : \u211d} (h : r \u2264 R) : co x r R \u222a ci x R = ci x r := by\n  ext; simp_rw [co, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ici_eq_Ici h]\n\n\nvariable [MeasurableSpace X] [OpensMeasurableSpace X]\n\n@[measurability]\nlemma measurableSet_oo {x : X} {r R : \u211d} : MeasurableSet (oo x r R) := by\n  rw [oo_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oc {x : X} {r R : \u211d} : MeasurableSet (oc x r R) := by\n rw [oc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_co {x : X} {r R : \u211d} : MeasurableSet (co x r R) := by\n  rw [co_eq]; measurability\n\n@[measurability]\nlemma measurableSet_cc {x : X} {r R : \u211d} : MeasurableSet (cc x r R) := by\n rw [cc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oi {x : X} {r : \u211d} : MeasurableSet (oi x r) := by\n  rw [oi_eq]; measurability\n\n@[measurability]\nlemma measurableSet_ci {x : X} {r : \u211d} : MeasurableSet (ci x r) := by\n  rw [ci_eq]; measurability\n\nend Annulus\n\nnamespace EAnnulus\n\ndef oo (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ici r}\n\n\nlemma oo_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oo x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oo x r R := by\n  simp_rw [oo, Annulus.oo, edist_dist, mem_Ioo, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma oc_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [oc, Annulus.oc, edist_dist, mem_Ioc, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  \u00b7 have R_le_r := (lt_of_lt_of_le (lt_of_not_ge hR) hr).le\n    rw [Annulus.oc_eq_empty R_le_r]\n    refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n    exact not_le_of_gt (lt_of_le_of_lt (ENNReal.ofReal_le_ofReal R_le_r) hy.1) hy.2\n\nlemma co_eq_annulus {x : X} {r R : \u211d} :\n    co x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.co x r R := by\n  simp_rw [co, Annulus.co, edist_dist, mem_Ico, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma cc_eq_annulus {x : X} {r R : \u211d} (h : r > 0 \u2228 R \u2265 0) :\n    cc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.cc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [cc, Annulus.cc, edist_dist, mem_Icc, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  have r0 := h.resolve_right hR\n  have R_lt_r := (lt_of_not_ge hR).trans r0\n  rw [Annulus.cc_eq_empty R_lt_r]\n  refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n  exact not_le_of_gt ((ENNReal.ofReal_lt_ofReal_iff r0).mpr R_lt_r) (hy.1.trans hy.2)\n\nlemma oi_eq_annulus {x : X} {r : \u211d} (hr : r \u2265 0) : oi x (ENNReal.ofReal r) = Annulus.oi x r := by\n  simp_rw [oi, Annulus.oi, edist_dist, mem_Ioi, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr]\n\nlemma ci_eq_annulus {x : X} {r : \u211d} : ci x (ENNReal.ofReal r) = Annulus.ci x r := by\n  simp_rw [ci, Annulus.ci, edist_dist, mem_Ici, ENNReal.ofReal_le_ofReal_iff dist_nonneg]\n\n\nlemma oo_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oo x r R = ball x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oo, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma oc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oc x r R = closedBall x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oc, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma co_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    co x r R = ball x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [co, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma cc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    cc x r R = closedBall x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [cc, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma oi_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : oi x r = (closedBall x r.toReal)\u1d9c := by\n  ext; simp [oi, edist_dist, dist_comm, lt_ofReal_iff_toReal_lt hr.ne]\n\nlemma ci_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : ci x r = (ball x r.toReal)\u1d9c := by\n  ext; simp [ci, edist_dist, dist_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg]\n\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n@[simp]\nlemma cc_top_eq_empty {x : X} {R : \u211d\u22650\u221e} : cc x \u22a4 R = \u2205 :=\n  eq_empty_of_forall_not_mem (fun y hy \u21a6 (edist_ne_top x y) (top_le_iff.mp hy.1))\n\n@[simp]\nlemma oi_eq_empty {x : X} : oi x \u22a4 = \u2205 := by simp [oi, edist_dist]\n\n@[simp]\nlemma ci_eq_empty {x : X} : ci x \u22a4 = \u2205 := by simp [ci, edist_dist]\n\n\nlemma oo_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) :\n    oo x r \u22a4 = (closedBall x r.toReal)\u1d9c := by\n  ext; simpa [oo, edist_dist, dist_comm] using lt_ofReal_iff_toReal_lt hr.ne\n\nlemma oc_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) :\n    oc x r \u22a4 = (closedBall x r.toReal)\u1d9c := by\n  ext; simpa [oc, edist_dist, dist_comm] using lt_ofReal_iff_toReal_lt hr.ne\n\nlemma co_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : co x r \u22a4 = (ball x r.toReal)\u1d9c := by\n  ext; simpa [co, edist_dist, dist_comm] using le_ofReal_iff_toReal_le hr.ne dist_nonneg\n\nlemma cc_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : cc x r \u22a4 = (ball x r.toReal)\u1d9c := by\n  ext; simpa [cc, edist_dist, dist_comm] using le_ofReal_iff_toReal_le hr.ne dist_nonneg\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\n", "theoremStatement": "lemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 ", "theoremName": "Set.EAnnulus.oo_subset_co", "fileCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "theoremCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "file": "carleson/Carleson/ToMathlib/Annulus.lean", "module": "Carleson.ToMathlib.Annulus", "jsonFile": "Carleson.ToMathlib.Annulus.jsonl", "positionMetadata": {"lineInFile": 376, "tokenPositionInFile": 14603, "theoremPositionInFile": 89}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 27}, "proofMetadata": {"hasProof": true, "proof": ":=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 64}}
{"srcContext": "/-\nCopyright (c) 2024 James Sundstrom. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: James Sundstrom\n-/\nimport Mathlib.MeasureTheory.Constructions.BorelSpace.Metric\n\n/-!\n# Annulus\n\nIn this file we define an annulus in a pseudometric space `X` to be a set consisting of all `y`\nsuch that `dist x y` lies in an interval between `r` and `R`. An annulus is defined for each type\nof interval (`Ioo`, `Ioc`, etc.) with a parallel naming scheme, except that we do not define annuli\nfor `Iio` and `Ico`, as they would be balls.\n\nWe also define `EAnnulus` similarly using `edist` instead of `dist`.\n\n## Tags\n\nannulus, eannulus\n-/\n\nopen Set Metric ENNReal\n\nvariable {X : Type*} [PseudoMetricSpace X]\n\nnamespace Set\n\nnamespace Annulus\n\ndef oo (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d) := {y | dist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d) := {y | dist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d) := {y | dist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d) := {y | dist x y \u2208 Ici r}\n\nlemma oo_eq {x : X} {r R : \u211d} : oo x r R = ball x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oo, dist_comm, and_comm]\n\nlemma oc_eq {x : X} {r R : \u211d} : oc x r R = closedBall x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oc, dist_comm, and_comm]\n\nlemma co_eq {x : X} {r R : \u211d} : co x r R = ball x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [co, dist_comm, and_comm]\n\nlemma cc_eq {x : X} {r R : \u211d} : cc x r R = closedBall x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [cc, dist_comm, and_comm]\n\nlemma oi_eq {x : X} {r : \u211d} : oi x r = (closedBall x r)\u1d9c := by\n  ext; simp [oi, dist_comm]\n\nlemma ci_eq {x : X} {r : \u211d} : ci x r = (ball x r)\u1d9c := by\n  ext; simp [ci, dist_comm]\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\n", "theoremStatement": "lemma co_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 ", "theoremName": "Set.Annulus.co_subset_cc", "fileCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "theoremCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "file": "carleson/Carleson/ToMathlib/Annulus.lean", "module": "Carleson.ToMathlib.Annulus", "jsonFile": "Carleson.ToMathlib.Annulus.jsonl", "positionMetadata": {"lineInFile": 129, "tokenPositionInFile": 4560, "theoremPositionInFile": 31}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 21}, "proofMetadata": {"hasProof": true, "proof": ":=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.le.trans hR\u27e9", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 55}}
{"srcContext": "import Carleson.Discrete.Defs\nimport Mathlib.Combinatorics.Enumerative.DoubleCounting\nimport Carleson.Antichain.AntichainOperator\nimport Carleson.Discrete.SumEstimates\n\nopen MeasureTheory Measure NNReal Metric Complex Set\nopen scoped ENNReal\nopen Classical -- We use quite some `Finset.filter`\nnoncomputable section\n\nopen scoped ShortVariables\nvariable {X : Type*} {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102} {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X}\n  [MetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] [TileStructure Q D \u03ba S o]\n\nvariable {k n j l : \u2115} {p p' u u' : \ud835\udd13 X} {x : X}\n\n/-! ## Section 5.5 and Lemma 5.1.3 -/\n\n/-- The set \ud835\udd13_{G\\G'} in the blueprint -/\ndef \ud835\udd13pos : Set (\ud835\udd13 X) := { p : \ud835\udd13 X | 0 < volume (\ud835\udcd8 p \u2229 G \u2229 G'\u1d9c) }\n\nlemma exists_mem_aux\ud835\udcd2 {i : Grid X} (hi : 0 < volume (G \u2229 i)) : \u2203 k, i \u2208 aux\ud835\udcd2 (k + 1) := by\n  have vlt : volume (i : Set X) < \u22a4 := volume_coeGrid_lt_top\n  have one_le_quot : 1 \u2264 volume (i : Set X) / volume (G \u2229 i) := by\n    rw [ENNReal.le_div_iff_mul_le (Or.inl hi.ne') (Or.inr vlt.ne), one_mul]\n    exact measure_mono inter_subset_right\n  have quot_ne_top : volume (i : Set X) / volume (G \u2229 i) \u2260 \u22a4 := by\n    rw [Ne, ENNReal.div_eq_top, not_or, not_and_or, not_and_or]\n    exact \u27e8Or.inr hi.ne', Or.inl vlt.ne\u27e9\n  have ornz : 0 < (volume (i : Set X) / volume (G \u2229 i)).toReal :=\n    ENNReal.toReal_pos (zero_lt_one.trans_le one_le_quot).ne' quot_ne_top\n  let k : \u211d := Real.logb 2 (volume (i : Set X) / volume (G \u2229 i)).toReal\n  use \u230ak\u230b\u208a, i, le_rfl\n  nth_rw 1 [\u2190 ENNReal.mul_lt_mul_left (show 2 ^ (\u230ak\u230b\u208a + 1) \u2260 0 by simp) (by simp), \u2190 mul_assoc,\n    \u2190 ENNReal.rpow_natCast, \u2190 ENNReal.rpow_intCast, \u2190 ENNReal.rpow_add _ _ (by simp) (by simp)]\n  rw [Int.cast_neg, Int.cast_natCast, add_neg_cancel, ENNReal.rpow_zero, one_mul,\n    \u2190 ENNReal.div_lt_iff (Or.inl hi.ne') (Or.inr vlt.ne), \u2190 ENNReal.ofReal_toReal quot_ne_top,\n    \u2190 @ENNReal.ofReal_toReal (2 ^ (\u230ak\u230b\u208a + 1)) (by simp), ENNReal.ofReal_lt_ofReal_iff (by simp),\n    ENNReal.toReal_pow, ENNReal.toReal_ofNat, \u2190 Real.rpow_natCast,\n    \u2190 Real.logb_lt_iff_lt_rpow one_lt_two ornz]\n  exact Nat.lt_succ_floor k\n\nlemma exists_k_of_mem_\ud835\udd13pos (h : p \u2208 \ud835\udd13pos (X := X)) : \u2203 k, p \u2208 TilesAt k := by\n  let C : Set \u2115 := {k | \ud835\udcd8 p \u2208 aux\ud835\udcd2 k}\n  have Cn : C.Nonempty := by\n    rw [\ud835\udd13pos, mem_setOf] at h\n    have vpos : 0 < volume (G \u2229 \ud835\udcd8 p) := by\n      rw [inter_comm]; exact h.trans_le (measure_mono inter_subset_left)\n    obtain \u27e8k, hk\u27e9 := exists_mem_aux\ud835\udcd2 vpos; exact \u27e8_, hk\u27e9\n  let s : \u2115 := WellFounded.min wellFounded_lt _ Cn\n  have s_mem : s \u2208 C := WellFounded.min_mem ..\n  have s_min : \u2200 t \u2208 C, s \u2264 t := fun t mt \u21a6 WellFounded.min_le _ mt _\n  have s_pos : 0 < s := by\n    by_contra! h; rw [nonpos_iff_eq_zero] at h\n    simp_rw [h, C, aux\ud835\udcd2, mem_setOf] at s_mem; apply absurd s_mem; push_neg; intro _ _\n    rw [Int.neg_ofNat_zero, zpow_zero, one_mul]; exact measure_mono inter_subset_right\n  use s - 1; rw [TilesAt, mem_preimage, \ud835\udcd2, mem_diff, Nat.sub_add_cancel s_pos]\n  have : \u2200 t < s, t \u2209 C := fun t mt \u21a6 by contrapose! mt; exact s_min t mt\n  exact \u27e8s_mem, this (s - 1) (Nat.sub_one_lt_of_lt s_pos)\u27e9\n\nlemma dens'_le_of_mem_\ud835\udd13pos (h : p \u2208 \ud835\udd13pos (X := X)) : dens' k {p} \u2264 2 ^ (-k : \u2124) := by\n  simp_rw [dens', mem_singleton_iff, iSup_iSup_eq_left, iSup_le_iff]; intro l hl p' mp' sl\n  have vpos : 0 < volume (\ud835\udcd8 p' : Set X) := by\n    refine lt_of_lt_of_le ?_ (measure_mono sl.1.1)\n    rw [\ud835\udd13pos, mem_setOf, inter_assoc] at h; exact h.trans_le (measure_mono inter_subset_left)\n  rw [ENNReal.div_le_iff vpos.ne' volume_coeGrid_lt_top.ne]\n  calc\n    _ \u2264 volume (E\u2082 l p') := by\n      nth_rw 2 [\u2190 one_mul (volume _)]; apply mul_le_mul_right'\n      rw [show 1 = (l : \u211d\u22650\u221e) ^ (0 : \u2124) by simp]; apply ENNReal.zpow_le_of_le\n      \u00b7 rw [ENNReal.one_le_coe_iff]; exact one_le_two.trans hl\n      \u00b7 linarith [four_le_a X]\n    _ \u2264 _ := by\n      have E : E\u2082 l p' \u2286 \ud835\udcd8 p' \u2229 G := inter_subset_left\n      rw [TilesAt, mem_preimage, \ud835\udcd2, mem_diff] at mp'; replace mp' := mp'.2\n      rw [aux\ud835\udcd2, mem_setOf] at mp'; push_neg at mp'; specialize mp' (\ud835\udcd8 p') le_rfl\n      rw [inter_comm] at E; exact (measure_mono E).trans mp'\n\nlemma exists_E\u2082_volume_pos_of_mem_\ud835\udd13pos (h : p \u2208 \ud835\udd13pos (X := X)) : \u2203 r : \u2115, 0 < volume (E\u2082 r p) := by\n  apply exists_measure_pos_of_not_measure_iUnion_null\n  change volume (\u22c3 n : \u2115, \ud835\udcd8 p \u2229 G \u2229 Q \u207b\u00b9' ball_(p) (\ud835\udcac p) n) \u2260 0\n  rw [\u2190 inter_iUnion]\n  suffices \u22c3 i : \u2115, Q \u207b\u00b9' ball_(p) (\ud835\udcac p) i = univ by\n    rw [this, inter_univ, \u2190 pos_iff_ne_zero]\n    rw [\ud835\udd13pos, mem_setOf] at h; exact h.trans_le (measure_mono inter_subset_left)\n  simp_rw [iUnion_eq_univ_iff, mem_preimage, mem_ball]\n  exact fun x \u21a6 exists_nat_gt (dist_(p) (Q x) (\ud835\udcac p))\n\nlemma dens'_pos_of_mem_\ud835\udd13pos (h : p \u2208 \ud835\udd13pos (X := X)) (hp : p \u2208 TilesAt k) : 0 < dens' k {p} := by\n  simp_rw [dens', mem_singleton_iff, iSup_iSup_eq_left, lt_iSup_iff]\n  obtain \u27e8l, hl\u27e9 := exists_E\u2082_volume_pos_of_mem_\ud835\udd13pos h\n  use max 2 l, le_max_left .., p, hp, le_rfl\n  simp_rw [ENNReal.div_pos_iff, ne_eq, mul_eq_zero, not_or, \u2190 ne_eq, \u2190 pos_iff_ne_zero]\n  refine \u27e8\u27e8ENNReal.zpow_pos (by simp) (by simp) _, ?_\u27e9, volume_coeGrid_lt_top.ne\u27e9\n  refine hl.trans_le <| measure_mono <| inter_subset_inter_right _ <| preimage_mono ?_\n  change ball_(p) (\ud835\udcac p) _ \u2286 ball_(p) (\ud835\udcac p) _\n  exact ball_subset_ball (by simp)\n\nlemma exists_k_n_of_mem_\ud835\udd13pos (h : p \u2208 \ud835\udd13pos (X := X)) : \u2203 k n, p \u2208 \u212d k n \u2227 k \u2264 n := by\n  obtain \u27e8k, mp\u27e9 := exists_k_of_mem_\ud835\udd13pos h; use k\n  have dens'_pos : 0 < dens' k {p} := dens'_pos_of_mem_\ud835\udd13pos h mp\n  have dens'_le : dens' k {p} \u2264 2 ^ (-k : \u2124) := dens'_le_of_mem_\ud835\udd13pos h\n  have dens'_lt_top : dens' k {p} < \u22a4 :=\n    dens'_le.trans_lt (ENNReal.zpow_lt_top (by simp) (by simp) _)\n  have dens'_toReal_pos : 0 < (dens' k {p}).toReal :=\n    ENNReal.toReal_pos dens'_pos.ne' dens'_lt_top.ne\n  -- 2 ^ (4 * a - n) < dens' k {p} \u2264 2 ^ (4 * a - n + 1)\n  -- 4 * a - n < log_2 dens' k {p} \u2264 4 * a - n + 1\n  -- -n < log_2 dens' k {p} - 4 * a \u2264 -n + 1\n  -- n - 1 \u2264 4 * a - log_2 dens' k {p} < n\n  -- n \u2264 4 * a - log_2 dens' k {p} + 1 < n + 1\n  -- n = 4 * a + \u230a-log_2 dens' k {p}\u230b + 1\n  let v : \u211d := -Real.logb 2 (dens' k {p}).toReal\n  have klv : k \u2264 v := by\n    rw [le_neg, Real.logb_le_iff_le_rpow one_lt_two dens'_toReal_pos,\n      show (2 : \u211d) = (2 : \u211d\u22650\u221e).toReal by rfl, ENNReal.toReal_rpow,\n      ENNReal.toReal_le_toReal dens'_lt_top.ne (by simp)]\n    exact_mod_cast dens'_le\n  have klq : k \u2264 \u230av\u230b\u208a := Nat.le_floor klv\n  let n : \u2115 := 4 * a + \u230av\u230b\u208a + 1; use n; refine \u27e8\u27e8mp, ?_\u27e9, by omega\u27e9\n  rw [show 4 * (a : \u2124) - (4 * a + \u230av\u230b\u208a + 1 : \u2115) = (-\u230av\u230b\u208a - 1 : \u2124) by omega, sub_add_cancel, mem_Ioc,\n    \u2190 ENNReal.ofReal_toReal dens'_lt_top.ne, \u2190 ENNReal.rpow_intCast, \u2190 ENNReal.rpow_intCast,\n    show (2 : \u211d\u22650\u221e) = ENNReal.ofReal (2 : \u211d) by norm_cast,\n    ENNReal.ofReal_rpow_of_pos zero_lt_two, ENNReal.ofReal_rpow_of_pos zero_lt_two,\n    ENNReal.ofReal_lt_ofReal_iff dens'_toReal_pos, ENNReal.ofReal_le_ofReal_iff (by positivity),\n    \u2190 Real.logb_le_iff_le_rpow one_lt_two dens'_toReal_pos,\n    \u2190 Real.lt_logb_iff_rpow_lt one_lt_two dens'_toReal_pos,\n    Int.cast_sub, Int.cast_neg, Int.cast_natCast, Int.cast_one, neg_sub_left, neg_lt, le_neg]\n  constructor\n  \u00b7 rw [add_comm]; exact_mod_cast Nat.lt_succ_floor _\n  \u00b7 exact Nat.floor_le ((Nat.cast_nonneg' k).trans klv)\n\nprivate lemma two_mul_n_add_six_lt : 2 * n + 6 < 2 ^ (n + 3) := by\n  induction n with\n  | zero => norm_num\n  | succ n ih =>\n    calc\n      _ = 2 * n + 6 + 2 := by ring\n      _ < 2 ^ (n + 3) + 2 := by gcongr\n      _ < 2 ^ (n + 3) + 2 ^ (n + 3) := by omega\n      _ = _ := by ring\n\nlemma exists_j_of_mem_\ud835\udd13pos_\u212d (h : p \u2208 \ud835\udd13pos (X := X)) (mp : p \u2208 \u212d k n) (hkn : k \u2264 n) :\n    p \u2208 \ud835\udd0f\u2080 k n \u2228 \u2203 j \u2264 2 * n + 3, p \u2208 \u212d\u2081 k n j := by\n  rw [\ud835\udd13pos, mem_setOf, inter_comm _ G'\u1d9c, \u2190 inter_assoc] at h\n  replace h : 0 < volume (G'\u1d9c \u2229 (\ud835\udcd8 p : Set X)) := h.trans_le (measure_mono inter_subset_left)\n  rw [inter_comm, G', compl_union, compl_union, inter_comm G\u2081\u1d9c, \u2190 inter_assoc, \u2190 inter_assoc] at h\n  replace h : 0 < volume ((\ud835\udcd8 p : Set X) \u2229 G\u2082\u1d9c) :=\n    h.trans_le (measure_mono (inter_subset_left.trans inter_subset_left))\n  obtain \u27e8x, mx, nx\u27e9 := nonempty_of_measure_ne_zero h.ne'\n  simp_rw [G\u2082, mem_compl_iff, mem_iUnion] at nx; push_neg at nx; specialize nx n k hkn\n  let B : \u2115 := Finset.card { q | q \u2208 \ud835\udd05 k n p }\n  have Blt : B < 2 ^ (2 * n + 4) := by\n    calc\n      _ \u2264 Finset.card { m | m \u2208 \ud835\udd10 k n \u2227 x \u2208 \ud835\udcd8 m } :=\n        Finset.card_le_card (Finset.monotone_filter_right _ (Pi.le_def.mpr fun m \u27e8m\u2081, m\u2082\u27e9 \u21a6\n          \u27e8m\u2081, m\u2082.1.1 mx\u27e9))\n      _ = stackSize (\ud835\udd10 k n) x := by\n        simp_rw [stackSize, indicator_apply, Pi.one_apply, Finset.sum_boole, Nat.cast_id,\n          Finset.filter_filter]; rfl\n      _ \u2264 (2 * n + 6) * 2 ^ (n + 1) := by rwa [setA, mem_setOf, not_lt] at nx\n      _ < _ := by\n        rw [show 2 * n + 4 = (n + 3) + (n + 1) by omega, pow_add _ (n + 3)]\n        exact mul_lt_mul_of_pos_right two_mul_n_add_six_lt (by positivity)\n  rcases B.eq_zero_or_pos with Bz | Bpos\n  \u00b7 simp_rw [B, filter_mem_univ_eq_toFinset, Finset.card_eq_zero, toFinset_eq_empty] at Bz\n    exact Or.inl \u27e8mp, Bz\u27e9\n  \u00b7 right; use Nat.log 2 B; rw [Nat.lt_pow_iff_log_lt one_lt_two Bpos.ne'] at Blt\n    refine \u27e8by omega, (?_ : _ \u2227 _ \u2264 B), (?_ : \u00ac(_ \u2227 _ \u2264 B))\u27e9\n    \u00b7 exact \u27e8mp, Nat.pow_log_le_self 2 Bpos.ne'\u27e9\n    \u00b7 rw [not_and, not_le]; exact fun _ \u21a6 Nat.lt_pow_succ_log_self one_lt_two _\n\nlemma exists_k_n_j_of_mem_\ud835\udd13pos (h : p \u2208 \ud835\udd13pos (X := X)) :\n    \u2203 k n, k \u2264 n \u2227 (p \u2208 \ud835\udd0f\u2080 k n \u2228 \u2203 j \u2264 2 * n + 3, p \u2208 \u212d\u2081 k n j) := by\n  obtain \u27e8k, n, mp, hkn\u27e9 := exists_k_n_of_mem_\ud835\udd13pos h\n  exact \u27e8k, n, hkn, exists_j_of_mem_\ud835\udd13pos_\u212d h mp hkn\u27e9\n\n/-- The union occurring in the statement of Lemma 5.5.1 containing \ud835\udd0f\u2080 -/\ndef \u211c\u2080 : Set (\ud835\udd13 X) := \ud835\udd13pos \u2229 \u22c3 (n : \u2115) (k \u2264 n), \ud835\udd0f\u2080 k n\n\n/-- The union occurring in the statement of Lemma 5.5.1 containing \ud835\udd0f\u2081 -/\ndef \u211c\u2081 : Set (\ud835\udd13 X) := \ud835\udd13pos \u2229 \u22c3 (n : \u2115) (k \u2264 n) (j \u2264 2 * n + 3) (l \u2264 Z * (n + 1)), \ud835\udd0f\u2081 k n j l\n\n/-- The union occurring in the statement of Lemma 5.5.1 containing \ud835\udd0f\u2082 -/\ndef \u211c\u2082 : Set (\ud835\udd13 X) := \ud835\udd13pos \u2229 \u22c3 (n : \u2115) (k \u2264 n) (j \u2264 2 * n + 3), \ud835\udd0f\u2082 k n j\n\n/-- The union occurring in the statement of Lemma 5.5.1 containing \ud835\udd0f\u2083 -/\ndef \u211c\u2083 : Set (\ud835\udd13 X) := \ud835\udd13pos \u2229 \u22c3 (n : \u2115) (k \u2264 n) (j \u2264 2 * n + 3) (l \u2264 Z * (n + 1)), \ud835\udd0f\u2083 k n j l\n\n/-- Lemma allowing to peel `\u22c3 (n : \u2115) (k \u2264 n)` from unions in the proof of Lemma 5.5.1. -/\nlemma mem_iUnion_iff_mem_of_mem_\u212d {f : \u2115 \u2192 \u2115 \u2192 Set (\ud835\udd13 X)} (hp : p \u2208 \u212d k n \u2227 k \u2264 n)\n    (hf : \u2200 k n, f k n \u2286 \u212d k n) : p \u2208 \u22c3 (n : \u2115) (k \u2264 n), f k n \u2194 p \u2208 f k n := by\n  simp_rw [mem_iUnion]; constructor <;> intro h\n  \u00b7 obtain \u27e8n', k', _, mp\u27e9 := h\n    have e := pairwiseDisjoint_\u212d (X := X).elim (mem_univ (k, n)) (mem_univ (k', n'))\n      (not_disjoint_iff.mpr \u27e8p, hp.1, hf k' n' mp\u27e9)\n    rw [Prod.mk.inj_iff] at e\n    exact e.1 \u25b8 e.2 \u25b8 mp\n  \u00b7 use n, k, hp.2\n\n/-- Lemma allowing to peel `\u22c3 (j \u2264 2 * n + 3)` from unions in the proof of Lemma 5.5.1. -/\nlemma mem_iUnion_iff_mem_of_mem_\u212d\u2081 {f : \u2115 \u2192 Set (\ud835\udd13 X)} (hp : p \u2208 \u212d\u2081 k n j \u2227 j \u2264 2 * n + 3)\n    (hf : \u2200 j, f j \u2286 \u212d\u2081 k n j) : p \u2208 \u22c3 (j \u2264 2 * n + 3), f j \u2194 p \u2208 f j := by\n  simp_rw [mem_iUnion]; constructor <;> intro h\n  \u00b7 obtain \u27e8j', _, mp\u27e9 := h\n    have e := pairwiseDisjoint_\u212d\u2081 (X := X).elim (mem_univ j) (mem_univ j')\n      (not_disjoint_iff.mpr \u27e8p, hp.1, hf j' mp\u27e9)\n    exact e \u25b8 mp\n  \u00b7 use j, hp.2\n\nlemma nmem_\u212d\u2085_iff_mem_\ud835\udd0f\u2083 (hkn : k \u2264 n) (hj : j \u2264 2 * n + 3)\n    (h : p \u2208 \ud835\udd13pos) (mc2 : p \u2208 \u212d\u2082 k n j) (ml2 : p \u2209 \ud835\udd0f\u2082 k n j) :\n    p \u2209 \u212d\u2085 k n j \u2194 p \u2208 \u22c3 l, \u22c3 (_ : l \u2264 Z * (n + 1)), \ud835\udd0f\u2083 k n j l := by\n  have mc3 : p \u2208 \u212d\u2083 k n j := \u27e8mc2, ml2\u27e9\n  by_cases mc4 : p \u2209 \u212d\u2084 k n j\n  all_goals\n    have mc4' := mc4\n    simp_rw [\u212d\u2084, layersBelow, mem_diff, not_and, mc3, true_implies, not_not_mem] at mc4'\n  \u00b7 change p \u2208 \u22c3 (l \u2264 Z * (n + 1)), \ud835\udd0f\u2083 k n j l at mc4'\n    simp_rw [mc4', iff_true]; contrapose! mc4\n    exact \u212d\u2085_subset_\u212d\u2084 mc4\n  change p \u2209 \u22c3 (l \u2264 Z * (n + 1)), \ud835\udd0f\u2083 k n j l at mc4'\n  simp_rw [mc4', iff_false, \u212d\u2085]; rw [not_not_mem] at mc4 \u22a2; simp_rw [mem_diff, mc4, true_and]\n  have nG\u2083 : \u00ac(\ud835\udcd8 p : Set X) \u2286 G\u2083 := by\n    suffices \u00ac(\ud835\udcd8 p : Set X) \u2286 G' by contrapose! this; exact subset_union_of_subset_right this _\n    by_contra hv\n    rw [\ud835\udd13pos, mem_setOf, inter_comm _ G'\u1d9c, \u2190 inter_assoc, \u2190 diff_eq_compl_inter,\n      diff_eq_empty.mpr hv] at h\n    simp at h\n  contrapose! nG\u2083\n  exact le_iSup\u2082_of_le n k <| le_iSup\u2082_of_le hkn j <|\n    le_iSup\u2082_of_le hj p <| le_iSup_of_le nG\u2083 Subset.rfl\n\n\n/-- Lemma 5.5.1.\n\nWe will not use the lemma in this form, as to decompose the Carleson sum it is also crucial that\nthe union is disjoint. This is easier to formalize by decomposing into successive terms, taking\nadvantage of disjointess at each step, instead of doing everything in one go. Still, we keep this\nlemma as it corresponds to the blueprint, and the key steps of its proof will also be the key steps\nwhen doing the successive decompositions.\n -/\nlemma antichain_decomposition : \ud835\udd13pos (X := X) \u2229 \ud835\udd13\u2081\u1d9c = \u211c\u2080 \u222a \u211c\u2081 \u222a \u211c\u2082 \u222a \u211c\u2083 := by\n  unfold \u211c\u2080 \u211c\u2081 \u211c\u2082 \u211c\u2083 \ud835\udd13\u2081; simp_rw [\u2190 inter_union_distrib_left]; ext p\n  simp_rw [mem_inter_iff, and_congr_right_iff, mem_compl_iff, mem_union]; intro h\n  obtain \u27e8k, n, hkn, split\u27e9 := exists_k_n_j_of_mem_\ud835\udd13pos h\n  have pc : p \u2208 \u212d k n := by\n    rcases split with ml0 | \u27e8_, _, mc1\u27e9\n    \u00b7 exact \ud835\udd0f\u2080_subset_\u212d ml0\n    \u00b7 exact \u212d\u2081_subset_\u212d mc1\n  iterate 5 rw [mem_iUnion_iff_mem_of_mem_\u212d \u27e8pc, hkn\u27e9]\n  pick_goal 5; \u00b7 exact fun _ _ \u21a6 \ud835\udd0f\u2080_subset_\u212d\n  pick_goal 4; \u00b7 exact fun _ _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 \ud835\udd0f\u2081_subset_\u212d\n  pick_goal 3; \u00b7 exact fun _ _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 \ud835\udd0f\u2082_subset_\u212d\n  pick_goal 2; \u00b7 exact fun _ _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 \ud835\udd0f\u2083_subset_\u212d\n  pick_goal -1; \u00b7 exact fun _ _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 \u212d\u2085_subset_\u212d\n  by_cases ml0 : p \u2208 \ud835\udd0f\u2080 k n\n  \u00b7 simp_rw [ml0, true_or, iff_true, mem_iUnion\u2082]; push_neg; intros\n    exact fun a \u21a6 disjoint_left.mp \ud835\udd0f\u2080_disjoint_\u212d\u2081 ml0 (\u212d\u2085_subset_\u212d\u2081 a)\n  simp_rw [ml0, false_or] at split \u22a2\n  obtain \u27e8j, hj, mc1\u27e9 := split\n  iterate 4 rw [mem_iUnion_iff_mem_of_mem_\u212d\u2081 \u27e8mc1, hj\u27e9]\n  pick_goal 4; \u00b7 exact fun _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 \ud835\udd0f\u2081_subset_\u212d\u2081\n  pick_goal 3; \u00b7 exact fun _ \u21a6 \ud835\udd0f\u2082_subset_\u212d\u2081\n  pick_goal 2; \u00b7 exact fun _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 \ud835\udd0f\u2083_subset_\u212d\u2081\n  pick_goal -1; \u00b7 exact fun _ \u21a6 \u212d\u2085_subset_\u212d\u2081\n  by_cases mc2 : p \u2209 \u212d\u2082 k n j\n  all_goals\n    have mc2' := mc2\n    simp_rw [\u212d\u2082, layersAbove, mem_diff, not_and, mc1, true_implies, not_not_mem] at mc2'\n  \u00b7 change p \u2208 \u22c3 (l \u2264 Z * (n + 1)), \ud835\udd0f\u2081 k n j l at mc2'\n    simp_rw [mc2', true_or, iff_true]; contrapose! mc2\n    exact \u212d\u2085_subset_\u212d\u2084.trans \u212d\u2084_subset_\u212d\u2083 |>.trans \u212d\u2083_subset_\u212d\u2082 mc2\n  change p \u2209 \u22c3 (l \u2264 Z * (n + 1)), \ud835\udd0f\u2081 k n j l at mc2'; simp_rw [mc2', false_or]\n  rw [not_not_mem] at mc2; by_cases ml2 : p \u2208 \ud835\udd0f\u2082 k n j\n  \u00b7 simp_rw [ml2, true_or, iff_true]\n    exact fun a \u21a6 disjoint_left.mp \ud835\udd0f\u2082_disjoint_\u212d\u2083 ml2 (\u212d\u2085_subset_\u212d\u2084.trans \u212d\u2084_subset_\u212d\u2083 a)\n  simp_rw [ml2, false_or]\n  exact nmem_\u212d\u2085_iff_mem_\ud835\udd0f\u2083 hkn hj h mc2 ml2\n\n/-- The subset `\ud835\udd0f\u2080(k, n, l)` of `\ud835\udd0f\u2080(k, n)`, given in Lemma 5.5.3.\n  We use the name `\ud835\udd0f\u2080'` in Lean. -/\ndef \ud835\udd0f\u2080' (k n l : \u2115) : Set (\ud835\udd13 X) := (\ud835\udd0f\u2080 k n).minLayer l\n\n/-- Logarithmic inequality used in the proof of Lemma 5.5.2. -/\nlemma ceil_log2_le_floor_four_add_log2 {l : \u211d} (hl : 2 \u2264 l) :\n    \u2308Real.logb 2 ((l + 6 / 5) / 5\u207b\u00b9)\u2309\u208a \u2264 \u230a4 + Real.logb 2 l\u230b\u208a := by\n  have : 2 \u2264 Real.logb 2 (l + 6 / 5) + Real.logb 2 5 :=\n    calc\n      _ \u2265 Real.logb 2 (2 ^ (0 : \u211d)) + Real.logb 2 (2 ^ (2 : \u211d)) :=\n        add_le_add\n          (Real.logb_le_logb_of_le one_lt_two (by positivity) (by linarith))\n          (Real.logb_le_logb_of_le one_lt_two (by positivity) (by norm_num))\n      _ \u2265 _ := by simp_rw [Real.logb_rpow zero_lt_two one_lt_two.ne']; norm_num\n  rw [div_inv_eq_mul, Real.logb_mul (by positivity) (by positivity), Nat.le_floor_iff']\n  \u00b7 calc\n      _ \u2264 1 + Real.logb 2 (l + 6 / 5) + Real.logb 2 5 := by\n        rw [add_rotate]; exact (Nat.ceil_lt_add_one (zero_le_two.trans this)).le\n      _ \u2264 1 + Real.logb 2 (8 / 5 * l) + Real.logb 2 5 := by\n        gcongr\n        \u00b7 exact one_lt_two\n        \u00b7 linarith\n      _ = _ := by\n        rw [add_assoc, \u2190 Real.logb_mul (by positivity) (by positivity), \u2190 mul_rotate,\n          show (5 : \u211d) * (8 / 5) = 2 ^ 3 by norm_num,\n          Real.logb_mul (by positivity) (by positivity), \u2190 Real.rpow_natCast,\n          Real.logb_rpow zero_lt_two one_lt_two.ne', \u2190 add_assoc]\n        norm_num\n  \u00b7 exact (zero_lt_one.trans_le (Nat.one_le_ceil_iff.mpr (zero_lt_two.trans_le this))).ne'\n\n/-- The set `\ud835\udd12` in the proof of Lemma 5.5.2. -/\ndef \ud835\udd12 (p' : \ud835\udd13 X) (l : \u211d\u22650) : Finset (\ud835\udd13 X) :=\n  {p'' | \ud835\udcd8 p'' = \ud835\udcd8 p' \u2227 \u00acDisjoint (ball_(p') (\ud835\udcac p') l) (\u03a9 p'')}\n\nlemma card_\ud835\udd12 (p' : \ud835\udd13 X) {l : \u211d\u22650} (hl : 2 \u2264 l) : (\ud835\udd12 p' l).card \u2264 \u230a2 ^ (4 * a) * l ^ a\u230b\u208a := by\n  have djO : (\ud835\udd12 p' l).toSet.PairwiseDisjoint fun p'' \u21a6 ball_(p') (\ud835\udcac p'') 5\u207b\u00b9 :=\n    fun p\u2081 mp\u2081 p\u2082 mp\u2082 hn \u21a6 by\n      simp_rw [\ud835\udd12, Finset.coe_filter, mem_setOf, Finset.mem_univ, true_and] at mp\u2081 mp\u2082\n      change Disjoint (ball_{\ud835\udcd8 p'} (\ud835\udcac p\u2081) 5\u207b\u00b9) (ball_{\ud835\udcd8 p'} (\ud835\udcac p\u2082) 5\u207b\u00b9)\n      conv => enter [1]; rw [\u2190 mp\u2081.1]\n      conv => enter [2]; rw [\u2190 mp\u2082.1]\n      exact cball_disjoint hn (mp\u2081.1.trans mp\u2082.1.symm)\n  have tO : \u2200 p'' \u2208 \ud835\udd12 p' l,\n      ball_(p') (\ud835\udcac p'') 5\u207b\u00b9 \u2286 ball_(p') (\ud835\udcac p') (l + 6 / 5) := fun p'' mp'' \u21a6 by\n    apply ball_subset_ball'\n    simp_rw [\ud835\udd12, Finset.mem_filter, Finset.mem_univ, true_and] at mp''\n    obtain \u27e8x, mx\u2081, mx\u2082\u27e9 := not_disjoint_iff.mp mp''.2\n    replace mx\u2082 := _root_.subset_cball mx\u2082\n    rw [@mem_ball] at mx\u2081 mx\u2082\n    calc\n      _ \u2264 5\u207b\u00b9 + (dist_{\ud835\udcd8 p'} x (\ud835\udcac p'') + dist_{\ud835\udcd8 p'} x (\ud835\udcac p')) :=\n        add_le_add_left (dist_triangle_left ..) _\n      _ \u2264 5\u207b\u00b9 + (1 + l) := by gcongr; rw [\u2190 mp''.1]; exact mx\u2082.le\n      _ = _ := by rw [inv_eq_one_div, \u2190 add_assoc, add_comm _ l.toReal]; norm_num\n  have vO : CoveredByBalls (ball_(p') (\ud835\udcac p') (l + 6 / 5)) \u230a2 ^ (4 * a) * l ^ a\u230b\u208a 5\u207b\u00b9 := by\n    apply (ballsCoverBalls_iterate (show 0 < l.toReal + 6 / 5 by positivity)\n      (show 0 < 5\u207b\u00b9 by positivity) (\ud835\udcac p')).mono_nat\n    calc\n      _ \u2264 (defaultA a) ^ \u230a4 + Real.logb 2 l\u230b\u208a :=\n        pow_le_pow_right\u2080 Nat.one_le_two_pow (ceil_log2_le_floor_four_add_log2 hl)\n      _ \u2264 \u230a(defaultA a : \u211d) ^ (4 + Real.logb 2 l)\u230b\u208a := by\n        apply Nat.le_floor; rw [Nat.cast_npow, \u2190 Real.rpow_natCast]\n        refine Real.rpow_le_rpow_of_exponent_le (by exact_mod_cast Nat.one_le_two_pow)\n          (Nat.floor_le ?_)\n        calc\n          _ \u2265 4 + Real.logb 2 2 :=\n            add_le_add_left (Real.logb_le_logb_of_le one_lt_two zero_lt_two hl) _\n          _ \u2265 _ := by rw [Real.logb_self_eq_one one_lt_two]; norm_num\n      _ = _ := by\n        rw [Nat.cast_pow, Nat.cast_ofNat, \u2190 Real.rpow_natCast, \u2190 Real.rpow_mul zero_le_two,\n          mul_comm, add_mul, Real.rpow_add zero_lt_two, show (4 : \u211d) * a = (4 * a : \u2115) by simp,\n          Real.rpow_natCast, Real.rpow_mul zero_le_two, Real.rpow_natCast,\n          Real.rpow_logb zero_lt_two one_lt_two.ne']\n        congr 1; exact zero_lt_two.trans_le hl\n  obtain \u27e8(T : Finset (\u0398 X)), cT, uT\u27e9 := vO\n  refine (Finset.card_le_card_of_forall_subsingleton (fun p'' t \u21a6 \ud835\udcac p'' \u2208 ball_(p') t 5\u207b\u00b9)\n      (fun p'' mp'' \u21a6 ?_) (fun t _ o\u2081 mo\u2081 o\u2082 mo\u2082 \u21a6 ?_)).trans cT\n  \u00b7 have := (tO _ mp'').trans uT (mem_ball_self (by positivity))\n    rwa [mem_iUnion\u2082, bex_def] at this\n  \u00b7 simp_rw [mem_setOf_eq] at mo\u2081 mo\u2082; rw [@mem_ball_comm] at mo\u2081 mo\u2082\n    exact djO.elim mo\u2081.1 mo\u2082.1 (not_disjoint_iff.mpr \u27e8t, mo\u2081.2, mo\u2082.2\u27e9)\n\nsection\n\nvariable {p' : \ud835\udd13 X} {l : \u211d\u22650} (hl : 2 \u2264 l)\n  (qp' : 2 ^ (4 * a - n : \u2124) < l ^ (-a : \u2124) * volume (E\u2082 l p') / volume (\ud835\udcd8 p' : Set X))\ninclude hl qp'\n\nlemma lt_quotient_rearrange :\n    (2 ^ (4 * a) * l ^ a : \u211d\u22650) * 2 ^ (-n : \u2124) < volume (E\u2082 l p') / volume (\ud835\udcd8 p' : Set X) := by\n  rw [mul_div_assoc] at qp'; convert ENNReal.div_lt_of_lt_mul' qp' using 1\n  rw [ENNReal.div_eq_inv_mul,\n    \u2190 ENNReal.zpow_neg (by exact_mod_cast (zero_lt_two.trans_le hl).ne') ENNReal.coe_ne_top,\n    neg_neg, ENNReal.coe_mul, mul_rotate, mul_assoc, ENNReal.coe_pow, zpow_natCast]\n  congr 1\n  rw [ENNReal.coe_pow, ENNReal.coe_ofNat, \u2190 zpow_natCast,\n    \u2190 ENNReal.zpow_add two_ne_zero ENNReal.ofNat_ne_top]\n  congr 1; omega\n\nlemma l_upper_bound : l < 2 ^ n := by\n  have ql1 : volume (E\u2082 l p') / volume (\ud835\udcd8 p' : Set X) \u2264 1 := by\n    apply ENNReal.div_le_of_le_mul; rw [one_mul]; exact measure_mono (E\u2082_subset ..)\n  replace qp' := (lt_quotient_rearrange hl qp').trans_le ql1\n  rw [\u2190 ENNReal.mul_lt_mul_right (c := 2 ^ (n : \u2124)) (by simp) (by simp), one_mul, mul_assoc,\n    \u2190 ENNReal.zpow_add two_ne_zero ENNReal.ofNat_ne_top, neg_add_cancel, zpow_zero, mul_one,\n    show (2 ^ (n : \u2124) : \u211d\u22650\u221e) = (2 ^ (n : \u2124) : \u211d\u22650) by simp, ENNReal.coe_lt_coe,\n    zpow_natCast] at qp'\n  calc\n    _ \u2264 l ^ a := le_self_pow\u2080 (one_le_two.trans hl) (by linarith [four_le_a X])\n    _ \u2264 2 ^ (4 * a) * l ^ a := by\n      nth_rw 1 [\u2190 one_mul (l ^ a)]; gcongr; exact_mod_cast Nat.one_le_two_pow\n    _ < _ := qp'\n\nlemma exists_\ud835\udd12_with_le_quotient :\n    \u2203 b \u2208 \ud835\udd12 p' l, 2 ^ (-n : \u2124) < volume (E\u2081 b) / volume (\ud835\udcd8 b : Set X) := by\n  have cO : (\ud835\udd12 p' l).card \u2264 \u230a2 ^ (4 * a) * l ^ a\u230b\u208a := card_\ud835\udd12 _ hl\n  have ltq : (2 ^ (4 * a) * l ^ a : \u211d\u22650) * 2 ^ (-n : \u2124) <\n      \u2211 p'' \u2208 \ud835\udd12 p' l, volume (E\u2081 p'') / volume (\ud835\udcd8 p'' : Set X) :=\n    calc\n      _ < volume (E\u2082 l p') / volume (\ud835\udcd8 p' : Set X) := lt_quotient_rearrange hl qp'\n      _ \u2264 volume (\u22c3 p'' \u2208 \ud835\udd12 p' l, E\u2081 p'') / volume (\ud835\udcd8 p' : Set X) := by\n        gcongr; simp_rw [E\u2081, E\u2082, smul, toTileLike, TileLike.toSet]; intro x mx\n        have rsub := biUnion_\u03a9 (i := \ud835\udcd8 p'); rw [range_subset_iff] at rsub; specialize rsub x\n        simp_rw [mem_iUnion\u2082, mem_preimage, mem_singleton_iff, exists_prop] at rsub\n        obtain \u27e8(ps : \ud835\udd13 X), (ips : \ud835\udcd8 ps = \ud835\udcd8 p'), mps\u27e9 := rsub; rw [\u2190 mem_preimage] at mps\n        rw [mem_iUnion\u2082]; refine \u27e8ps, ?_, ?_\u27e9\n        \u00b7 simp_rw [\ud835\udd12, Finset.mem_filter, Finset.mem_univ, ips, true_and, not_disjoint_iff]\n          use Q x, mem_preimage.mp mx.2, mem_preimage.mp mps\n        \u00b7 exact \u27e8\u27e8ips.symm \u25b8 mx.1.1, mx.1.2\u27e9, mps\u27e9\n      _ \u2264 (\u2211 p'' \u2208 \ud835\udd12 p' l, volume (E\u2081 p'')) / volume (\ud835\udcd8 p' : Set X) :=\n        ENNReal.div_le_div_right (measure_biUnion_finset_le _ _) _\n      _ = \u2211 p'' \u2208 \ud835\udd12 p' l, volume (E\u2081 p'') / volume (\ud835\udcd8 p' : Set X) := by\n        simp_rw [ENNReal.div_eq_inv_mul, Finset.mul_sum]\n      _ = _ := by\n        refine Finset.sum_congr rfl fun p'' mp'' \u21a6 ?_\n        rw [\ud835\udd12, Finset.mem_filter] at mp''; rw [mp''.2.1]\n  by_contra! h\n  have : \u2211 p'' \u2208 \ud835\udd12 p' l, volume (E\u2081 p'') / volume (\ud835\udcd8 p'' : Set X) \u2264\n      (2 ^ (4 * a) * l ^ a : \u211d\u22650) * 2 ^ (-n : \u2124) :=\n    calc\n      _ \u2264 \u2211 _ \u2208 \ud835\udd12 p' l, (2 : \u211d\u22650\u221e) ^ (-n : \u2124) := by\n        refine Finset.sum_le_sum h\n      _ = (\ud835\udd12 p' l).card * (2 : \u211d\u22650\u221e) ^ (-n : \u2124) := by rw [Finset.sum_const, nsmul_eq_mul]\n      _ \u2264 _ := by\n        refine mul_le_mul_right' ?_ _\n        rw [show ((\ud835\udd12 p' l).card : \u211d\u22650\u221e) = ((\ud835\udd12 p' l).card : \u211d\u22650) by simp, ENNReal.coe_le_coe]\n        rw [\u2190 Nat.cast_le (\u03b1 := \u211d\u22650)] at cO\n        exact cO.trans (Nat.floor_le (by positivity))\n  exact (ltq.trans_le this).false\n\nend\n\n/-- Main part of Lemma 5.5.2. -/\nlemma iUnion_L0' : \u22c3 (l < n), \ud835\udd0f\u2080' (X := X) k n l = \ud835\udd0f\u2080 k n := by\n  refine iUnion_lt_minLayer_iff_bounded_series.mpr fun p \u21a6 ?_\n  suffices \u00ac\u2203 s : LTSeries (\ud835\udd0f\u2080 (X := X) k n), s.length = n by\n    rcases lt_or_le p.length n with c | c\n    \u00b7 exact c\n    \u00b7 exact absurd \u27e8p.take \u27e8n, by omega\u27e9, by rw [RelSeries.take_length]\u27e9 this\n  by_contra h; obtain \u27e8s, hs\u27e9 := h; let sl := s.last; have dsl := sl.2.1.2.1\n  simp_rw [dens', lt_iSup_iff, mem_singleton_iff, exists_prop, exists_eq_left] at dsl\n  obtain \u27e8l, hl, p', mp', sp', qp'\u27e9 := dsl\n  obtain \u27e8b, mb, qb\u27e9 := exists_\ud835\udd12_with_le_quotient hl qp'\n  have \ud835\udcd8p'b : \ud835\udcd8 p' = \ud835\udcd8 b := by rw [\ud835\udd12, Finset.mem_filter] at mb; exact mb.2.1.symm\n  replace qb := ENNReal.mul_lt_of_lt_div qb\n  have mba : b \u2208 (aux\ud835\udd10 k n).toFinset := by\n    simp_rw [mem_toFinset, aux\ud835\udd10, mem_setOf, qb, and_true]; rw [TilesAt, mem_preimage] at mp' \u22a2\n    exact \ud835\udcd8p'b \u25b8 mp'\n  obtain \u27e8m, lm, maxm\u27e9 := (aux\ud835\udd10 k n).toFinset.exists_le_maximal mba\n  replace maxm : m \u2208 \ud835\udd10 k n := by simpa only [mem_toFinset] using maxm\n  -- We will now show a contradiction. As a member of `\ud835\udd0f\u2080 k n` the _first_ element `s\u2080` of the\n  -- `LTSeries s` satisfies `\ud835\udd05 k n s\u2080 = \u2205`. But we will show that `m \u2208 \ud835\udd05 k n s\u2080`,\n  -- i.e. `smul 100 s\u2080 \u2264 smul 1 m`.\n  let s\u2080 := s.head; apply absurd s\u2080.2.2; rw [\u2190 ne_eq, \u2190 nonempty_iff_ne_empty]; use m, maxm\n  constructor\n  \u00b7 have l1 : \ud835\udcd8 s\u2080.1 \u2264 \ud835\udcd8 sl.1 := s.head_le_last.1\n    have l2 : \ud835\udcd8 sl.1 \u2264 \ud835\udcd8 b := \ud835\udcd8p'b \u25b8 sp'.1\n    have l3 : \ud835\udcd8 b \u2264 \ud835\udcd8 m := lm.1\n    exact (l1.trans l2).trans l3\n  change ball_(m) (\ud835\udcac m) 1 \u2286 ball_(s\u2080.1) (\ud835\udcac s\u2080.1) 100; intro (\u03b8 : \u0398 X) m\u03b8; rw [@mem_ball] at m\u03b8 \u22a2\n  have aux : dist_(sl.1) (\ud835\udcac sl.1) \u03b8 < 2 * l + 3 :=\n    calc\n      _ \u2264 dist_(sl.1) (\ud835\udcac sl.1) (\ud835\udcac p') + dist_(sl.1) (\ud835\udcac p') \u03b8 := dist_triangle ..\n      _ < l + dist_(sl.1) (\ud835\udcac p') \u03b8 := by\n        apply add_lt_add_right\n        have : \ud835\udcac p' \u2208 ball_(p') (\ud835\udcac p') l := by convert mem_ball_self (zero_lt_two.trans_le hl)\n        exact mem_ball'.mp (sp'.2 this)\n      _ \u2264 l + dist_(p') (\ud835\udcac p') \u03b8 := add_le_add_left (Grid.dist_mono sp'.1) _\n      _ \u2264 l + dist_(p') (\ud835\udcac p') (\ud835\udcac b) + dist_(p') (\ud835\udcac b) \u03b8 := by\n        rw [add_assoc]; apply add_le_add_left; exact dist_triangle ..\n      _ \u2264 l + (l + 1) + dist_(b) (\ud835\udcac b) \u03b8 := by\n        gcongr\n        \u00b7 rw [\ud835\udd12, Finset.mem_filter] at mb\n          obtain \u27e8(x : \u0398 X), x\u2081, x\u2082\u27e9 := not_disjoint_iff.mp mb.2.2\n          replace x\u2082 := _root_.subset_cball x\u2082\n          rw [@mem_ball] at x\u2081 x\u2082\n          calc\n            _ \u2264 dist_(p') x (\ud835\udcac p') + dist_(p') x (\ud835\udcac b) := dist_triangle_left ..\n            _ \u2264 _ := by\n              apply add_le_add x\u2081.le\n              change dist_{\ud835\udcd8 p'} x (\ud835\udcac b) \u2264 1; rw [\ud835\udcd8p'b]; exact x\u2082.le\n        \u00b7 change dist_{\ud835\udcd8 p'} (\ud835\udcac b) \u03b8 \u2264 dist_{\ud835\udcd8 b} (\ud835\udcac b) \u03b8; rw [\ud835\udcd8p'b]\n      _ \u2264 l + (l + 1) + (dist_(b) (\ud835\udcac m) (\ud835\udcac b) + dist_(b) (\ud835\udcac m) \u03b8) :=\n        add_le_add_left (dist_triangle_left ..) _\n      _ \u2264 l + (l + 1) + (1 + dist_(m) (\ud835\udcac m) \u03b8) := by\n        gcongr\n        \u00b7 exact (dist_\ud835\udcac_lt_one_of_le lm).le\n        \u00b7 exact Grid.dist_mono lm.1\n      _ < l + (l + 1) + (1 + 1) := by gcongr; exact mem_ball'.mp m\u03b8\n      _ = _ := by ring\n  calc\n    _ \u2264 dist_(s\u2080.1) (\ud835\udcac sl.1) \u03b8 + dist_(s\u2080.1) (\ud835\udcac sl.1) (\ud835\udcac s\u2080.1) := dist_triangle_left ..\n    _ < 1 + dist_(s\u2080.1) (\ud835\udcac sl.1) \u03b8 := by\n      rw [add_comm]; exact add_lt_add_right (dist_\ud835\udcac_lt_one_of_le s.head_le_last) _\n    _ \u2264 1 + C2_1_2 a ^ n * dist_(sl.1) (\ud835\udcac sl.1) \u03b8 := add_le_add_left (dist_LTSeries hs) _\n    _ < 1 + C2_1_2 a ^ n * (2 * l + 3) := by gcongr; rw [C2_1_2]; positivity\n    _ \u2264 1 + (1 / 512) ^ n * (2 * 2 ^ n + 3) := by\n      gcongr\n      \u00b7 rw [C2_1_2]; positivity\n      \u00b7 exact C2_1_2_le_inv_512 X\n      \u00b7 exact_mod_cast (l_upper_bound hl qp').le\n    _ = 1 + 2 * (2 / 512) ^ n + (1 / 512) ^ n * 3 := by\n      simp [div_pow]; ring\n    _ \u2264 1 + 2 * (2 / 512) ^ 0 + (1 / 512) ^ 0 * 3 := by\n      gcongr 1 + 2 * ?_ + ?_ * 3 <;>\n        exact pow_le_pow_of_le_one (by norm_num) (by norm_num) (by omega)\n    _ < _ := by norm_num\n\n/-- Part of Lemma 5.5.2 -/\nlemma pairwiseDisjoint_L0' : univ.PairwiseDisjoint (\ud835\udd0f\u2080' (X := X) k n) := pairwiseDisjoint_minLayer\n\n/-- Part of Lemma 5.5.2 -/\nlemma antichain_L0' : IsAntichain (\u00b7 \u2264 \u00b7) (\ud835\udd0f\u2080' (X := X) k n l) := isAntichain_minLayer\n\nsection L2Antichain\n\n/-- Type synonym of `\u212d\u2081` to apply the `Preorder` of the proof of Lemma 5.5.3 on. -/\nprivate def \u212d\u2081' (k n j : \u2115) : Type _ := \u212d\u2081 (X := X) k n j\n\nprivate instance : Fintype (\u212d\u2081' (X := X) k n j) := inferInstanceAs (Fintype (\u212d\u2081 k n j))\n\nprivate instance : Preorder (\u212d\u2081' (X := X) k n j) where\n  le x y := smul 200 x.1 \u2264 smul 200 y.1\n  le_refl := by simp\n  le_trans _ _ _ xy yz := by\n    change smul _ _ \u2264 smul _ _ at xy yz \u22a2\n    exact xy.trans yz\n\n/-- Lemma 5.5.3 -/\nlemma antichain_L2 : IsAntichain (\u00b7 \u2264 \u00b7) (\ud835\udd0f\u2082 (X := X) k n j) := by\n  by_contra h; rw [isAntichain_iff_forall_not_lt] at h; push_neg at h\n  obtain \u27e8p', mp', p, mp, l\u27e9 := h\n  have p200 : smul 2 p' \u2264 smul 200 p := by\n    calc\n      _ \u2264 smul (11 / 10 + C2_1_2 a * 200) p' := by\n        apply smul_mono_left\n        calc\n          _ \u2264 11 / 10 + 1 / 512 * (200 : \u211d) := by gcongr; exact C2_1_2_le_inv_512 X\n          _ \u2264 _ := by norm_num\n      _ \u2264 _ := by\n        refine smul_C2_1_2 _ (by norm_num) ?_ (wiggle_order_11_10 l.le (C5_3_3_le (X := X)))\n        exact (\ud835\udcd8_strictMono l).ne\n  have cp : p \u2208 \u212d\u2081 k n j := (\ud835\udd0f\u2082_subset_\u212d\u2082.trans \u212d\u2082_subset_\u212d\u2081) mp\n  let C : Finset (LTSeries (\u212d\u2081' k n j)) := { s | s.head = \u27e8p, cp\u27e9 }\n  have Cn : C.Nonempty := by\n    use RelSeries.singleton _ \u27e8p, cp\u27e9\n    simp_rw [C, Finset.mem_filter, Finset.mem_univ, true_and]; rfl\n  obtain \u27e8z, mz, maxz\u27e9 := C.exists_max_image (\u00b7.length) Cn\n  simp_rw [C, Finset.mem_filter, Finset.mem_univ, true_and] at mz\n  by_cases mu : z.last.1 \u2208 \ud835\udd18\u2081 k n j\n  \u00b7 have px : z.head \u2264 z.last := z.monotone (Fin.zero_le _)\n    rw [mz] at px\n    apply absurd mp'; rw [\ud835\udd0f\u2082, mem_setOf, not_and_or, not_not]; right; use z.last.1, mu\n    have : \ud835\udcd8 p' < \ud835\udcd8 p := \ud835\udcd8_strictMono l\n    exact \u27e8(this.trans_le px.1).ne, (p200.trans px).trans (smul_mono_left (by norm_num))\u27e9\n  \u00b7 simp_rw [\ud835\udd18\u2081, mem_setOf, not_and, z.last.2, true_implies, not_forall, exists_prop] at mu\n    obtain \u27e8q, mq, lq, ndjq\u27e9 := mu; rw [not_disjoint_iff] at ndjq; obtain \u27e8\u03d1, m\u03d1\u2081, m\u03d1\u2082\u27e9 := ndjq\n    have cpos : 0 < C2_1_2 a := by rw [C2_1_2]; positivity\n    have s200 : smul 200 z.last.1 \u2264 smul 200 q := by\n      refine \u27e8lq.le, (?_ : ball_(q) (\ud835\udcac q) 200 \u2286 ball_(z.last.1) (\ud835\udcac z.last.1) 200)\u27e9\n      intro (r : \u0398 X) mr\n      rw [@mem_ball] at mr m\u03d1\u2081 m\u03d1\u2082 \u22a2\n      calc\n        _ \u2264 dist_(z.last.1) r (\ud835\udcac q) + dist_(z.last.1) (\ud835\udcac q) \u03d1 + dist_(z.last.1) \u03d1 (\ud835\udcac z.last.1) :=\n          dist_triangle4 ..\n        _ \u2264 C2_1_2 a * dist_(q) r (\ud835\udcac q) + C2_1_2 a * dist_(q) (\ud835\udcac q) \u03d1 + 100 := by\n          gcongr <;> exact Grid.dist_strictMono lq\n        _ \u2264 C2_1_2 a * (200 + 100) + 100 := by rw [mul_add]; gcongr; rw [dist_comm]; exact m\u03d1\u2082.le\n        _ \u2264 (1 / 512) * 300 + 100 := by\n          rw [show (200 : \u211d) + 100 = 300 by norm_num]; gcongr\n          exact C2_1_2_le_inv_512 X\n        _ < _ := by norm_num\n    have : z.last < \u27e8q, mq\u27e9 := by\n      refine \u27e8s200, (?_ : \u00ac(smul 200 q \u2264 smul 200 z.last.1))\u27e9\n      rw [TileLike.le_def, not_and_or]; exact Or.inl (not_le_of_gt lq)\n    apply absurd maxz; push_neg; use z.snoc \u27e8q, mq\u27e9 this, by simp [C, mz], by simp\n\nend L2Antichain\n\n/-- Part of Lemma 5.5.4 -/\nlemma antichain_L1 : IsAntichain (\u00b7 \u2264 \u00b7) (\ud835\udd0f\u2081 (X := X) k n j l) := isAntichain_minLayer\n\n/-- Part of Lemma 5.5.4 -/\nlemma antichain_L3 : IsAntichain (\u00b7 \u2264 \u00b7) (\ud835\udd0f\u2083 (X := X) k n j l) := isAntichain_maxLayer\n\n/- Our goal is now to estimate `\u222b\u207b x in G \\ G', \u2016carlesonSum \ud835\udd13\u2081\u1d9c f x\u2016\u208a` by decomposing `\ud835\udd13\u2081\u1d9c` as a\nunion of disjoint antichains. For this, we proceed step by step, isolating some antichains and\nsome sets that remain to be decomposed. After 4 steps, we will get a sum of integrals corresponding\nto the (disjoint) decomposition in Lemma 5.5.1.\n-/\n\n", "theoremStatement": "/-- The Carleson sum over `\ud835\udd13\u2081\u1d9c` and `\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c` coincide at ae every point of `G \\ G'`. -/\nlemma carlesonSum_\ud835\udd13\u2081_compl_eq_\ud835\udd13pos_inter (f : X \u2192 \u2102) :\n    \u2200\u1d50 x, x \u2208 G \\ G' \u2192 carlesonSum \ud835\udd13\u2081\u1d9c f x = carlesonSum (\ud835\udd13pos (X := X) \u2229 \ud835\udd13\u2081\u1d9c) f x ", "theoremName": "carlesonSum_\ud835\udd13\u2081_compl_eq_\ud835\udd13pos_inter", "fileCreated": {"commit": "310e13d16e51600777fc841833f4bce112b5f73a", "date": "2024-09-24"}, "theoremCreated": {"commit": "77d4285c51ebe49f9035715383dfd7aef6aecf25", "date": "2025-01-09"}, "file": "carleson/Carleson/Discrete/ForestComplement.lean", "module": "Carleson.Discrete.ForestComplement", "jsonFile": "Carleson.Discrete.ForestComplement.jsonl", "positionMetadata": {"lineInFile": 592, "tokenPositionInFile": 30264, "theoremPositionInFile": 32}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 41, "numPremises": 222}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  have A p (hp : p \u2208 (\ud835\udd13pos (X := X))\u1d9c) : \u2200\u1d50 x, x \u2208 G \\ G' \u2192 x \u2209 \ud835\udcd8 p := by\n    simp only [\ud835\udd13pos, mem_compl_iff, mem_setOf_eq, not_lt, nonpos_iff_eq_zero] at hp\n    filter_upwards [measure_zero_iff_ae_nmem.mp hp] with x hx h'x (h''x : x \u2208 (\ud835\udcd8 p : Set X))\n    simp [h''x, h'x.1, h'x.2] at hx\n  rw [\u2190 ae_ball_iff (to_countable \ud835\udd13pos\u1d9c)] at A\n  filter_upwards [A] with x hx h'x\n  simp only [carlesonSum]\n  symm\n  apply Finset.sum_subset\n  \u00b7 intro p hp\n    simp only [Finset.mem_filter, Finset.mem_univ, true_and] at hp \u22a2\n    exact hp.2\n  \u00b7 intro p hp h'p\n    simp only [Finset.mem_filter, Finset.mem_univ, true_and] at hp h'p\n    simp only [mem_inter_iff, hp, and_true] at h'p\n    have : x \u2209 \ud835\udcd8 p := hx _ h'p h'x\n    have : x \u2209 E p := by simp at this; simp [E, this]\n    simp [carlesonOn, this]", "proofType": "tactic", "proofLengthLines": 18, "proofLengthTokens": 790}}
{"srcContext": "import Carleson.ToMathlib.DoublingMeasure\nimport Carleson.ToMathlib.WeakType\nimport Mathlib.Algebra.Order.Group.Int\nimport Mathlib.Analysis.CStarAlgebra.Classes\nimport Mathlib.Data.Int.Star\n\nopen MeasureTheory Measure NNReal Metric Complex Set TopologicalSpace Bornology Function\nopen scoped ENNReal\nnoncomputable section\n\n-- todo: rename and protect `Real.RCLike`\n\n/-! Miscellaneous definitions.\nThese are mostly the definitions used to state the metric Carleson theorem.\nWe should move them to separate files once we start proving things about them. -/\n\nsection DoublingMeasure\nuniverse u\n\nvariable {\ud835\udd5c X : Type*} {A : \u2115} [_root_.RCLike \ud835\udd5c] [PseudoMetricSpace X]\n\nsection localOscillation\n\n/-- The local oscillation of two functions w.r.t. a set `E`. This is `d_E` in the blueprint. -/\ndef localOscillation (E : Set X) (f g : C(X, \ud835\udd5c)) : \u211d\u22650\u221e :=\n  \u2a06 z \u2208 E \u00d7\u02e2 E, ENNReal.ofReal \u2016f z.1 - g z.1 - f z.2 + g z.2\u2016\n\n-- example (E : Set X) (hE : IsBounded E) (f : C(X, \u211d)) :\n--     BddAbove (range fun z : E \u21a6 f z) := by\n--   have : IsCompact (closure E) := IsBounded.isCompact_closure hE\n--   sorry\n\n-- lemma bddAbove_localOscillation (E : Set X) [Fact (IsBounded E)] (f g : C(X, \ud835\udd5c)) :\n--     BddAbove ((fun z : X \u00d7 X \u21a6 \u2016f z.1 - g z.1 - f z.2 + g z.2\u2016) '' E \u00d7\u02e2 E) := sorry\n\nvariable {E : Set X} {f g : C(X, \ud835\udd5c)}\n\n--old\n/-- A ball w.r.t. the distance `localOscillation` -/\ndef localOscillationBall (E : Set X) (f : C(X, \ud835\udd5c)) (r : \u211d) :\n    Set C(X, \ud835\udd5c) :=\n  { g : C(X, \ud835\udd5c) | localOscillation E f g < ENNReal.ofReal r }\n\nend localOscillation\n\nlemma fact_isCompact_ball (x : X) (r : \u211d) : Fact (IsBounded (ball x r)) :=\n  \u27e8isBounded_ball\u27e9\nattribute [local instance] fact_isCompact_ball\n\n/-- A class stating that continuous functions have distances associated to every ball.\nWe use a separate type to conveniently index these functions. -/\nclass FunctionDistances (\ud835\udd5c : outParam Type*) (X : Type u)\n    [NormedField \ud835\udd5c] [TopologicalSpace X] where\n  \u0398 : Type u\n  coe\u0398 : \u0398 \u2192 C(X, \ud835\udd5c)\n  coe\u0398_injective {f g : \u0398} (h : \u2200 x, coe\u0398 f x = coe\u0398 g x) : f = g\n  metric : \u2200 (_x : X) (_r : \u211d), PseudoMetricSpace \u0398\n\nexport FunctionDistances (\u0398 coe\u0398)\n\nsection FunctionDistances\nvariable [FunctionDistances \ud835\udd5c X]\n\ninstance : Coe (\u0398 X) C(X, \ud835\udd5c) := \u27e8FunctionDistances.coe\u0398\u27e9\ninstance : FunLike (\u0398 X) X \ud835\udd5c where\n  coe := fun f \u21a6 (f : C(X, \ud835\udd5c))\n  coe_injective' _ _ hfg := FunctionDistances.coe\u0398_injective fun x \u21a6 congrFun hfg x\ninstance : ContinuousMapClass (\u0398 X) X \ud835\udd5c := \u27e8fun f \u21a6 (f : C(X, \ud835\udd5c)).2\u27e9\n\nset_option linter.unusedVariables false in\n@[nolint unusedArguments]\ndef WithFunctionDistance (x : X) (r : \u211d) := \u0398 X\n\nvariable {x : X} {r : \u211d}\n\ndef toWithFunctionDistance [FunctionDistances \ud835\udd5c X] : \u0398 X \u2243 WithFunctionDistance x r :=\n  .refl _\n\n-- instance : FunLike (WithFunctionDistance \u0398 x r) X \ud835\udd5c := ContinuousMap.funLike\n-- instance : ContinuousMapClass (WithFunctionDistance \u0398 x r) X \ud835\udd5c :=\n--   ContinuousMap.toContinuousMapClass\n\ninstance [d : FunctionDistances \ud835\udd5c X] : PseudoMetricSpace (WithFunctionDistance x r) :=\n  d.metric x r\n\nend FunctionDistances\n\nnotation3 \"dist_{\" x \" ,\" r \"}\" => @dist (WithFunctionDistance x r) _\nnotation3 \"nndist_{\" x \" ,\" r \"}\" => @nndist (WithFunctionDistance x r) _\nnotation3 \"ball_{\" x \" ,\" r \"}\" => @ball (WithFunctionDistance x r) _ in\n\n/-- A set `\u0398` of (continuous) functions is compatible. `A` will usually be `2 ^ a`. -/\nclass CompatibleFunctions (\ud835\udd5c : outParam Type*) (X : Type u) (A : outParam \u2115)\n  [RCLike \ud835\udd5c] [PseudoMetricSpace X] extends FunctionDistances \ud835\udd5c X where\n  eq_zero : \u2203 o : X, \u2200 f : \u0398, f o = 0\n  /-- The distance is bounded below by the local oscillation. (1.0.7) -/\n  localOscillation_le_cdist {x : X} {r : \u211d} {f g : \u0398} :\n    localOscillation (ball x r) (coe\u0398 f) (coe\u0398 g) \u2264 ENNReal.ofReal (dist_{x, r} f g)\n  /-- The distance is monotone in the ball. (1.0.9) -/\n  cdist_mono {x\u2081 x\u2082 : X} {r\u2081 r\u2082 : \u211d} {f g : \u0398}\n    (h : ball x\u2081 r\u2081 \u2286 ball x\u2082 r\u2082) : dist_{x\u2081, r\u2081} f g \u2264 dist_{x\u2082, r\u2082} f g\n  /-- The distance of a ball with large radius is bounded above. (1.0.8) -/\n  cdist_le {x\u2081 x\u2082 : X} {r : \u211d} {f g : \u0398} (h : dist x\u2081 x\u2082 < 2 * r) :\n    dist_{x\u2082, 2 * r} f g \u2264 A * dist_{x\u2081, r} f g\n  /-- The distance of a ball with large radius is bounded below. (1.0.10) -/\n  le_cdist {x\u2081 x\u2082 : X} {r : \u211d} {f g : \u0398} (h1 : ball x\u2081 r \u2286 ball x\u2082 (A * r)) :\n    /-(h2 : A * r \u2264 Metric.diam (univ : Set X))-/\n    2 * dist_{x\u2081, r} f g \u2264 dist_{x\u2082, A * r} f g\n  /-- The distance of a ball with large radius is bounded below. (1.0.11) -/\n  ballsCoverBalls {x : X} {r R : \u211d} :\n    BallsCoverBalls (X := WithFunctionDistance x r) (2 * R) R A\n\ninstance nonempty_Space [CompatibleFunctions \ud835\udd5c X A] : Nonempty X := by\n  obtain \u27e8x,_\u27e9 := \u2039CompatibleFunctions \ud835\udd5c X A\u203a.eq_zero\n  use x\n\ninstance inhabited_Space [CompatibleFunctions \ud835\udd5c X A] : Inhabited X :=\n  \u27e8nonempty_Space.some\u27e9\n\nlemma le_localOscillation [CompatibleFunctions \ud835\udd5c X A] (x : X) (r : \u211d) (f g : \u0398 X) {y z : X}\n    (hy : y \u2208 ball x r) (hz : z \u2208 ball x r) : \u2016coe\u0398 f y - coe\u0398 g y - coe\u0398 f z + coe\u0398 g z\u2016 \u2264\n    ENNReal.toReal (localOscillation (ball x r) (coe\u0398 f) (coe\u0398 g)) := by\n  rw [(ENNReal.toReal_ofReal (norm_nonneg _)).symm]\n  let f (z) := \u2a06 (_ : z \u2208 ball x r \u00d7\u02e2 ball x r), ENNReal.ofReal \u2016f z.1 - g z.1 - f z.2 + g z.2\u2016\n  apply ENNReal.toReal_mono\n  \u00b7 exact lt_of_le_of_lt CompatibleFunctions.localOscillation_le_cdist ENNReal.ofReal_lt_top |>.ne\n  \u00b7 exact le_of_eq_of_le (Eq.symm (iSup_pos \u27e8hy, hz\u27e9)) (le_iSup f \u27e8y, z\u27e9)\n\nlemma oscillation_le_cdist [CompatibleFunctions \ud835\udd5c X A] (x : X) (r : \u211d) (f g : \u0398 X) {y z : X}\n    (hy : y \u2208 ball x r) (hz : z \u2208 ball x r) :\n    \u2016coe\u0398 f y - coe\u0398 g y - coe\u0398 f z + coe\u0398 g z\u2016 \u2264 dist_{x, r} f g := by\n  apply le_trans <| le_localOscillation x r f g hy hz\n  rw [\u2190 ENNReal.toReal_ofReal dist_nonneg]\n  exact ENNReal.toReal_mono ENNReal.ofReal_ne_top CompatibleFunctions.localOscillation_le_cdist\n\nexport CompatibleFunctions (localOscillation_le_cdist cdist_mono cdist_le le_cdist)\n\nlemma dist_congr [FunctionDistances \ud835\udd5c X] {x\u2081 x\u2082 : X} {r\u2081 r\u2082 : \u211d} {f g : \u0398 X}\n    (e\u2081 : x\u2081 = x\u2082) (e\u2082 : r\u2081 = r\u2082) : dist_{x\u2081, r\u2081} f g = dist_{x\u2082, r\u2082} f g := by congr\n\nvariable (X) in\n/-- The point `o` in the blueprint -/\ndef cancelPt [CompatibleFunctions \ud835\udd5c X A] : X :=\n  CompatibleFunctions.eq_zero (\ud835\udd5c := \ud835\udd5c) |>.choose\nlemma cancelPt_eq_zero [CompatibleFunctions \ud835\udd5c X A] {f : \u0398 X} : f (cancelPt X) = 0 :=\n  CompatibleFunctions.eq_zero (\ud835\udd5c := \ud835\udd5c) |>.choose_spec f\n\n-- not sure if needed\n-- lemma CompatibleFunctions.IsSeparable [CompatibleFunctions \ud835\udd5c X A] :\n--   IsSeparable (range (coe\u0398 (X := X))) :=\n--   sorry\n\nset_option linter.unusedVariables false in\n/-- The inhomogeneous Lipschitz norm on a ball. -/\ndef iLipNorm {\ud835\udd5c} [NormedField \ud835\udd5c] (\u03d5 : X \u2192 \ud835\udd5c) (x\u2080 : X) (R : \u211d) : \u211d :=\n  (\u2a06 x \u2208 ball x\u2080 R, \u2016\u03d5 x\u2016) + R * \u2a06 (x : X) (y : X) (h : x \u2260 y), \u2016\u03d5 x - \u03d5 y\u2016 / dist x y\n\nlemma iLipNorm_nonneg {\ud835\udd5c} [NormedField \ud835\udd5c] {\u03d5 : X \u2192 \ud835\udd5c} {x\u2080 : X} {R : \u211d} (hR : 0 \u2264 R) :\n    0 \u2264 iLipNorm \u03d5 x\u2080 R :=\n  add_nonneg (Real.iSup_nonneg fun _ \u21a6 Real.iSup_nonneg fun _ \u21a6 norm_nonneg _)\n    (mul_nonneg hR (Real.iSup_nonneg fun _ \u21a6 Real.iSup_nonneg fun _ \u21a6 Real.iSup_nonneg\n    fun _ \u21a6 div_nonneg (norm_nonneg _) dist_nonneg))\n\nvariable [DoublingMeasure X A]\n\nvariable (X) in\n/-- \u0398 is \u03c4-cancellative. `\u03c4` will usually be `1 / a` -/\nclass IsCancellative (\u03c4 : \u211d) [CompatibleFunctions \u211d X A] : Prop where\n  norm_integral_exp_le {x : X} {r : \u211d} {\u03d5 : X \u2192 \u2102} {K : \u211d\u22650} (h1 : LipschitzWith K \u03d5)\n    (h2 : tsupport \u03d5 \u2286 ball x r) {f g : \u0398 X} :\n    \u2016\u222b x in ball x r, exp (I * (f x - g x)) * \u03d5 x\u2016 \u2264\n    A * volume.real (ball x r) * iLipNorm \u03d5 x r * (1 + dist_{x, r} f g) ^ (- \u03c4)\n\nexport IsCancellative (norm_integral_exp_le)\n\n/-- The \"volume function\" `V`. Note that we will need to assume\n`IsFiniteMeasureOnCompacts` and `ProperSpace` to actually know that this volume is finite. -/\ndef Real.vol {X : Type*} [PseudoMetricSpace X] [MeasureSpace X] (x y : X) : \u211d :=\n  volume.real (ball x (dist x y))\n\n-- /-- In Mathlib we only have the operator norm for continuous linear maps,\n-- and `T_*` is not linear.\n-- Here is the norm for an arbitrary map `T` between normed spaces\n-- (the infimum is defined to be 0 if the operator is not bounded). -/\n-- def operatorNorm {E F : Type*} [NormedAddCommGroup E] [NormedAddCommGroup F] (T : E \u2192 F) : \u211d :=\n--   sInf { c | 0 \u2264 c \u2227 \u2200 x, \u2016T x\u2016 \u2264 c * \u2016x\u2016 }\n\n/-- The Calderon Zygmund operator `T_r` in chapter Two-sided Metric Space Carleson -/\ndef CZOperator (K : X \u2192 X \u2192 \u2102) (r : \u211d) (f : X \u2192 \u2102) (x : X) : \u2102 :=\n  \u222b y in (ball x r)\u1d9c, K x y * f y\n\n/-- `R_Q(\u03b8, x)` defined in (1.0.20). -/\ndef upperRadius [FunctionDistances \u211d X] (Q : X \u2192 \u0398 X) (\u03b8 : \u0398 X) (x : X) : \u211d\u22650\u221e :=\n  \u2a06 (r : \u211d) (_ : dist_{x, r} \u03b8 (Q x) < 1), ENNReal.ofReal r\n\nlemma le_upperRadius [FunctionDistances \u211d X] {Q : X \u2192 \u0398 X} {\u03b8 : \u0398 X} {x : X} {r : \u211d}\n    (hr : dist_{x, r} \u03b8 (Q x) < 1) : ENNReal.ofReal r \u2264 upperRadius Q \u03b8 x := by\n  apply le_iSup\u2082 (f := fun r _ \u21a6 ENNReal.ofReal r) r hr\n\n/-- The linearized maximally truncated nontangential Calderon Zygmund operator `T_Q^\u03b8` -/\ndef linearizedNontangentialOperator [FunctionDistances \u211d X] (Q : X \u2192 \u0398 X) (\u03b8 : \u0398 X)\n    (K : X \u2192 X \u2192 \u2102) (f : X \u2192 \u2102) (x : X) : \u211d\u22650\u221e :=\n  \u2a06 (R\u2081 : \u211d) (x' : X) (_ : dist x x' \u2264 R\u2081),\n  \u2016\u222b y in {y | ENNReal.ofReal (dist x' y) \u2208 Ioo (ENNReal.ofReal R\u2081) (upperRadius Q \u03b8 x')},\n    K x' y * f y\u2016\u208a\n\n/-- The maximally truncated nontangential Calderon Zygmund operator `T_*` -/\ndef nontangentialOperator (K : X \u2192 X \u2192 \u2102) (f : X \u2192 \u2102) (x : X) : \u211d\u22650\u221e :=\n  \u2a06 (R\u2081 : \u211d) (R\u2082 : \u211d) (_ : R\u2081 < R\u2082) (x' : X) (_ : dist x x' < R\u2081),\n  \u2016\u222b y in {y | dist x' y \u2208 Ioo R\u2081 R\u2082}, K x' y * f y\u2016\u208a\n\n/-- The linearized generalized Carleson operator `T_Q`, taking values in `\u211d\u22650\u221e`.\nUse `ENNReal.toReal` to get the corresponding real number. -/\ndef linearizedCarlesonOperator [FunctionDistances \u211d X] (Q : X \u2192 \u0398 X) (K : X \u2192 X \u2192 \u2102)\n    (f : X \u2192 \u2102) (x : X) : \u211d\u22650\u221e :=\n  \u2a06 (R\u2081 : \u211d) (R\u2082 : \u211d) (_ : 0 < R\u2081) (_ : R\u2081 < R\u2082),\n  \u2016\u222b y in {y | dist x y \u2208 Ioo R\u2081 R\u2082}, K x y * f y * exp (I * Q x y)\u2016\u208a\n\n/-- The generalized Carleson operator `T`, taking values in `\u211d\u22650\u221e`.\nUse `ENNReal.toReal` to get the corresponding real number. -/\ndef carlesonOperator [FunctionDistances \u211d X] (K : X \u2192 X \u2192 \u2102) (f : X \u2192 \u2102) (x : X) : \u211d\u22650\u221e :=\n  \u2a06 (\u03b8 : \u0398 X), linearizedCarlesonOperator (fun _ \u21a6 \u03b8) K f x\n\n\nend DoublingMeasure\n\n/-- This is usually the value of the argument `A` in `DoublingMeasure`\nand `CompatibleFunctions` -/\n@[simp] abbrev defaultA (a : \u2115) : \u2115 := 2 ^ a\n@[simp] def defaultD (a : \u2115) : \u2115 := 2 ^ (100 * a ^ 2)\n@[simp] def default\u03ba (a : \u2115) : \u211d := 2 ^ (-10 * (a : \u211d))\n@[simp] def defaultZ (a : \u2115) : \u2115 := 2 ^ (12 * a)\n@[simp] def default\u03c4 (a : \u2115) : \u211d := a\u207b\u00b9\n\nlemma defaultD_pos (a : \u2115) : 0 < (defaultD a : \u211d) := by rw [defaultD]; positivity\n\nlemma defaultD_pos' (a : \u2115) : 0 < defaultD a := by exact_mod_cast defaultD_pos a\n\nlemma defaultD_pow_pos (a : \u2115) (z : \u2124) : 0 < (defaultD a : \u211d) ^ z :=\n  zpow_pos (defaultD_pos _) _\n\nlemma mul_defaultD_pow_pos (a : \u2115) {r : \u211d} (hr : 0 < r) (z : \u2124) : 0 < r * (defaultD a : \u211d) ^ z :=\n  mul_pos hr (defaultD_pow_pos a z)\n\nsection Kernel\n\nvariable {X : Type*} {a : \u2115} {K : X \u2192 X \u2192 \u2102} [PseudoMetricSpace X] [MeasureSpace X]\nopen Real (vol)\nopen Function\n\n/-- The constant used twice in the definition of the Calderon-Zygmund kernel. -/\n@[simp] def C_K (a : \u211d) : \u211d := 2 ^ a ^ 3\n\nlemma C_K_pos (a : \u211d) : 0 < C_K a := by unfold C_K; positivity\n\n/-- `K` is a one-sided Calderon-Zygmund kernel\nIn the formalization `K x y` is defined everywhere, even for `x = y`. The assumptions on `K` show\nthat `K x x = 0`. -/\nclass IsOneSidedKernel (a : outParam \u2115) (K : X \u2192 X \u2192 \u2102) : Prop where\n  measurable_K : Measurable (uncurry K)\n  norm_K_le_vol_inv (x y : X) : \u2016K x y\u2016 \u2264 C_K a / vol x y\n  norm_K_sub_le {x y y' : X} (h : 2 * dist y y' \u2264 dist x y) :\n    \u2016K x y - K x y'\u2016 \u2264 (dist y y' / dist x y) ^ (a : \u211d)\u207b\u00b9 * (C_K a / vol x y)\n\nexport IsOneSidedKernel (measurable_K norm_K_le_vol_inv norm_K_sub_le)\n\nlemma MeasureTheory.stronglyMeasurable_K [IsOneSidedKernel a K] :\n    StronglyMeasurable (uncurry K) :=\n  measurable_K.stronglyMeasurable\n\nlemma MeasureTheory.aestronglyMeasurable_K [IsOneSidedKernel a K] :\n    AEStronglyMeasurable (uncurry K) :=\n  measurable_K.aestronglyMeasurable\n\nlemma measurable_K_left [IsOneSidedKernel a K] (y : X) : Measurable (K \u00b7 y) :=\n  measurable_K.of_uncurry_right\n\nlemma measurable_K_right [IsOneSidedKernel a K] (x : X) : Measurable (K x) :=\n  measurable_K.of_uncurry_left\n\nlemma integrableOn_K_Icc [IsOpenPosMeasure (volume : Measure X)] [ProperSpace X]\n    [Regular (volume : Measure X)] [IsOneSidedKernel a K] {x : X} {r R : \u211d} (hr : r > 0) :\n    IntegrableOn (K x) {y | dist x y \u2208 Icc r R} volume := by\n  use Measurable.aestronglyMeasurable (measurable_K_right x)\n  rw [hasFiniteIntegral_def]\n  calc \u222b\u207b (y : X) in {y | dist x y \u2208 Icc r R}, \u2016K x y\u2016\u2091\n    _ \u2264 \u222b\u207b (y : X) in {y | dist x y \u2208 Icc r R},\n          ENNReal.ofReal (C_K a / volume.real (ball x r)) := by\n      refine setLIntegral_mono measurable_const (fun y hy \u21a6 ?_)\n      rw [\u2190 ofReal_norm]\n      refine ENNReal.ofReal_le_ofReal <| (norm_K_le_vol_inv x y).trans ?_\n      gcongr\n      \u00b7 exact (C_K_pos a).le\n      \u00b7 rw [measureReal_def]\n        apply ENNReal.toReal_pos (ne_of_gt <| measure_ball_pos volume x hr)\n        exact measure_ball_ne_top x r\n      \u00b7 exact measureReal_mono (ball_subset_ball hy.1)\n    _ < _ := by\n      rw [lintegral_const]\n      apply ENNReal.mul_lt_top ENNReal.ofReal_lt_top\n      rw [Measure.restrict_apply MeasurableSet.univ, univ_inter]\n      refine (Ne.lt_top fun h \u21a6 ?_)\n      have : {y | dist x y \u2208 Icc r R} \u2286 closedBall x R := by\n        intro y \u27e8_, hy\u27e9\n        exact mem_closedBall_comm.mp hy\n      exact measure_closedBall_lt_top.ne (measure_mono_top this h)\n\n/-- `K` is a two-sided Calderon-Zygmund kernel\nIn the formalization `K x y` is defined everywhere, even for `x = y`. The assumptions on `K` show\nthat `K x x = 0`. -/\nclass IsTwoSidedKernel (a : outParam \u2115) (K : X \u2192 X \u2192 \u2102) extends IsOneSidedKernel a K where\n  norm_K_sub_le' {x x' y : X} (h : 2 * dist x x' \u2264 dist x y) :\n    \u2016K x y - K x' y\u2016 \u2264 (dist x x' / dist x y) ^ (a : \u211d)\u207b\u00b9 * (C_K a / vol x y)\n\nexport IsTwoSidedKernel (norm_K_sub_le')\n\n-- maybe show: `K` is a 2-sided kernel iff `K` and `fun x y \u21a6 K y x` are one-sided kernels.\n\nend Kernel\n\n-- to show: K is locally bounded and hence integrable outside the diagonal\n\n\n/- A constant used on the boundedness of `T_*`. We generally assume\n`HasBoundedStrongType (nontangentialOperator K) volume volume 2 2 (C_Ts a)`\nthroughout this formalization. -/\ndef C_Ts (a : \u211d) : \u211d\u22650 := 2 ^ a ^ 3\n\n/-- Data common through most of chapters 2-9. -/\nclass PreProofData {X : Type*} (a : outParam \u2115) (q : outParam \u211d) (K : outParam (X \u2192 X \u2192 \u2102))\n  (\u03c3\u2081 \u03c3\u2082 : outParam (X \u2192 \u2124)) (F G : outParam (Set X)) [PseudoMetricSpace X] where\n  d : DoublingMeasure X (defaultA a)\n  four_le_a : 4 \u2264 a\n  cf : CompatibleFunctions \u211d X (defaultA a)\n  c : IsCancellative X (default\u03c4 a)\n  hcz : IsOneSidedKernel a K\n  hasBoundedStrongType_Tstar :\n    HasBoundedStrongType (nontangentialOperator K \u00b7 \u00b7) 2 2 volume volume (C_Ts a)\n  measurableSet_F : MeasurableSet F\n  measurableSet_G : MeasurableSet G\n  measurable_\u03c3\u2081 : Measurable \u03c3\u2081\n  measurable_\u03c3\u2082 : Measurable \u03c3\u2082\n  finite_range_\u03c3\u2081 : Finite (range \u03c3\u2081)\n  finite_range_\u03c3\u2082 : Finite (range \u03c3\u2082)\n  \u03c3\u2081_le_\u03c3\u2082 : \u03c3\u2081 \u2264 \u03c3\u2082\n  Q : SimpleFunc X (\u0398 X)\n  q_mem_Ioc : q \u2208 Ioc 1 2\n\nexport PreProofData (four_le_a hasBoundedStrongType_Tstar measurableSet_F measurableSet_G\n  measurable_\u03c3\u2081 measurable_\u03c3\u2082 finite_range_\u03c3\u2081 finite_range_\u03c3\u2082 \u03c3\u2081_le_\u03c3\u2082 Q q_mem_Ioc)\nattribute [instance] PreProofData.d PreProofData.cf PreProofData.c PreProofData.hcz\n\nsection ProofData\n\nvariable {X : Type*} {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102} {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X}\n  [PseudoMetricSpace X] [PreProofData a q K \u03c3\u2081 \u03c3\u2082 F G]\n\nsection Iterate\n\nlemma le_cdist_iterate {x : X} {r : \u211d} (hr : 0 \u2264 r) (f g : \u0398 X) (k : \u2115) :\n    2 ^ k * dist_{x, r} f g \u2264 dist_{x, (defaultA a) ^ k * r} f g := by\n  induction k with\n  | zero => rw [pow_zero, one_mul]; congr! <;> simp\n  | succ k ih =>\n    trans 2 * dist_{x, (defaultA a) ^ k * r} f g\n    \u00b7 rw [pow_succ', mul_assoc]\n      exact (mul_le_mul_left zero_lt_two).mpr ih\n    \u00b7 convert le_cdist (ball_subset_ball _) using 1\n      \u00b7 exact dist_congr rfl (by rw [\u2190 mul_assoc, pow_succ'])\n      \u00b7 nth_rw 1 [\u2190 one_mul ((defaultA a) ^ k * r)]; gcongr\n        rw [\u2190 Nat.cast_one, Nat.cast_le]; exact Nat.one_le_two_pow\n\nlemma cdist_le_iterate {x : X} {r : \u211d} (hr : 0 < r) (f g : \u0398 X) (k : \u2115) :\n    dist_{x, 2 ^ k * r} f g \u2264 (defaultA a) ^ k * dist_{x, r} f g := by\n  induction k with\n  | zero => simp_rw [pow_zero, one_mul]; congr! <;> simp\n  | succ k ih =>\n    trans defaultA a * dist_{x, 2 ^ k * r} f g\n    \u00b7 convert cdist_le _ using 1\n      \u00b7 exact dist_congr rfl (by ring)\n      \u00b7 rw [dist_self]; positivity\n    \u00b7 replace ih := (mul_le_mul_left (show 0 < (defaultA a : \u211d) by positivity)).mpr ih\n      rwa [\u2190 mul_assoc, \u2190 pow_succ'] at ih\n\nlemma ballsCoverBalls_iterate_nat {x : X} {d r : \u211d} {n : \u2115} :\n    BallsCoverBalls (WithFunctionDistance x d) (2 ^ n * r) r (defaultA a ^ n) := by\n  have double := fun s \u21a6 PreProofData.cf.ballsCoverBalls (x := x) (r := d) (R := s)\n  apply BallsCoverBalls.pow_mul double\n\nlemma ballsCoverBalls_iterate {x : X} {d R r : \u211d} (hR : 0 < R) (hr : 0 < r) :\n    BallsCoverBalls (WithFunctionDistance x d) R r (defaultA a ^ \u2308Real.logb 2 (R / r)\u2309\u208a) := by\n  apply ballsCoverBalls_iterate_nat.mono\n  calc\n    _ = R / r * r := by rw [div_mul_cancel\u2080 R hr.ne']\n    _ = 2 ^ Real.logb 2 (R / r) * r := by\n      rw [Real.rpow_logb zero_lt_two one_lt_two.ne' (by positivity)]\n    _ \u2264 _ := by\n      gcongr\n      rw [\u2190 Real.rpow_natCast]\n      exact Real.rpow_le_rpow_of_exponent_le one_le_two (Nat.le_ceil _)\n\nend Iterate\n\n@[fun_prop]\nlemma measurable_Q\u2082 : Measurable fun p : X \u00d7 X \u21a6 Q p.1 p.2 := fun s meass \u21a6 by\n  have : (fun p : X \u00d7 X \u21a6 (Q p.1) p.2) \u207b\u00b9' s = \u22c3 \u03b8 \u2208 Q.range, (Q \u207b\u00b9' {\u03b8}) \u00d7\u02e2 (\u03b8 \u207b\u00b9' s) := by\n    ext \u27e8x, y\u27e9\n    simp only [mem_preimage, SimpleFunc.mem_range, mem_range, iUnion_exists, iUnion_iUnion_eq',\n      mem_iUnion, mem_prod, mem_singleton_iff]\n    constructor <;> intro h\n    \u00b7 use x\n    \u00b7 obtain \u27e8j, hj\u27e9 := h; exact congr($(hj.1) y).symm \u25b8 hj.2\n  rw [this]\n  exact Q.range.measurableSet_biUnion fun \u03b8 _ \u21a6\n    (Q.measurableSet_fiber \u03b8).prod (meass.preimage (map_continuous \u03b8).measurable)\n\nlemma stronglyMeasurable_Q\u2082 : StronglyMeasurable fun p : X \u00d7 X \u21a6 Q p.1 p.2 :=\n  measurable_Q\u2082.stronglyMeasurable\n\n@[fun_prop]\nlemma aestronglyMeasurable_Q\u2082 : AEStronglyMeasurable fun p : X \u00d7 X \u21a6 Q p.1 p.2 :=\n  measurable_Q\u2082.aestronglyMeasurable\n\n@[fun_prop]\nlemma measurable_Q\u2081 (x : X) : Measurable (Q x) :=\n  let Q' : X \u2192 X \u2192 \u211d := fun x' y \u21a6 Q x' y\n  have : (fun y \u21a6 Q' x y) = Q x := rfl\n  this \u25b8 measurable_Q\u2082.of_uncurry_left\n\ninclude a q K \u03c3\u2081 \u03c3\u2082 F G\n\nvariable (X) in\nlemma S_spec : \u2203 n : \u2115, \u2200 x, -n \u2264 \u03c3\u2081 x \u2227 \u03c3\u2082 x \u2264 n := by\n  have h1 : (range \u03c3\u2081).Finite := finite_range_\u03c3\u2081\n  have h2 : (range \u03c3\u2082).Finite := finite_range_\u03c3\u2082\n  have h1' := bddBelow_def.mp h1.bddBelow\n  have h2' := bddAbove_def.mp h2.bddAbove\n  refine \u27e8(max (-h1'.choose) h2'.choose).toNat, fun x \u21a6 ?_\u27e9\n  simp only [Int.ofNat_toNat, \u2190 min_neg_neg, neg_neg, min_le_iff, le_max_iff]\n  exact \u27e8Or.inl (Or.inl (h1'.choose_spec _ (mem_range_self x))),\n    Or.inl (Or.inr (h2'.choose_spec _ (mem_range_self x)))\u27e9\n\nsection DBounds\n\nvariable (X)\n\n-- used in 4.1.7 (`small_boundary`)\nlemma twentyfive_le_realD : (25 : \u211d) \u2264 defaultD a := by\n  simp only [defaultD, Nat.ofNat_le_cast]\n  have : 4 \u2264 a := four_le_a X\n  calc\n    (25 : \u2115)\n      \u2264 32 := Nat.le_of_ble_eq_true rfl\n    _ = 2 ^ (5) := by rfl\n    _ \u2264 2 ^ (100 * 4 ^ 2) := Nat.le_of_ble_eq_true (by norm_num)\n    _ \u2264 2 ^ (100 * a ^ 2) := Nat.pow_le_pow_right (by norm_num)\n      (mul_le_mul_of_nonneg_left (Nat.pow_le_pow_of_le_left this 2) (by norm_num))\n\n-- used in 4.1.3 (`I3_prop_3_1`)\nlemma eight_le_realD : (8 : \u211d) \u2264 defaultD a := by\n  linarith [twentyfive_le_realD X]\n\n-- used in 4.1.6 (`transitive_boundary`)\nlemma five_le_realD : (5 : \u211d) \u2264 defaultD a := by\n  linarith [twentyfive_le_realD X]\n\n-- used in various places in `Carleson.TileExistence`\nlemma four_le_realD : (4 : \u211d) \u2264 defaultD a := by\n  linarith [twentyfive_le_realD X]\n\nlemma one_le_realD : (1 : \u211d) \u2264 defaultD a := by\n  linarith [twentyfive_le_realD X]\n\nopen Classical in\ndef defaultS : \u2115 := Nat.find (S_spec X)\n\nend DBounds\n\nlemma range_\u03c3\u2081_subset : range \u03c3\u2081 \u2286 Icc (- defaultS X) (defaultS X) := by\n  classical\n  rw [range_subset_iff]\n  exact fun x \u21a6 \u27e8(Nat.find_spec (S_spec X) x).1, (\u03c3\u2081_le_\u03c3\u2082 x).trans (Nat.find_spec (S_spec X) x).2\u27e9\n\nlemma range_\u03c3\u2082_subset : range \u03c3\u2082 \u2286 Icc (- defaultS X) (defaultS X) := by\n  classical\n  rw [range_subset_iff]\n  exact fun x \u21a6 \u27e8(Nat.find_spec (S_spec X) x).1.trans (\u03c3\u2081_le_\u03c3\u2082 x), (Nat.find_spec (S_spec X) x).2\u27e9\n\nlemma Icc_\u03c3_subset_Icc_S {x : X} : Icc (\u03c3\u2081 x) (\u03c3\u2082 x) \u2286 Icc (- defaultS X) (defaultS X) :=\n  fun _ h \u21a6 \u27e8(range_\u03c3\u2081_subset \u27e8x, rfl\u27e9).1.trans h.1, h.2.trans (range_\u03c3\u2082_subset \u27e8x, rfl\u27e9).2\u27e9\n\nlemma neg_S_mem_or_S_mem [Nonempty X] :\n    (- defaultS X : \u2124) \u2208 range \u03c3\u2081 \u2228 (defaultS X : \u2124) \u2208 range \u03c3\u2082 := by\n  by_cases h\u2080 : defaultS X = 0\n  \u00b7 right\n    simp only [h\u2080, CharP.cast_eq_zero, mem_range]\n    have : range \u03c3\u2082 \u2286 Icc (- defaultS X) (defaultS X) := range_\u03c3\u2082_subset\n    simp only [h\u2080, CharP.cast_eq_zero, neg_zero, Icc_self, subset_singleton_iff, mem_range,\n      forall_exists_index, forall_apply_eq_imp_iff] at this\n    let x : X := Classical.choice inferInstance\n    exact \u27e8x, this x\u27e9\n  by_contra! h\n  let n := (defaultS X) - 1\n  have h1 (x : X) : -n \u2264 \u03c3\u2081 x := by\n    rw [Int.natCast_sub (Nat.one_le_iff_ne_zero.mpr h\u2080), neg_sub, sub_eq_add_neg, add_comm]\n    exact lt_iff_le_and_ne.mpr \u27e8(range_\u03c3\u2081_subset (mem_range_self x)).1,\n      fun h' \u21a6 h.1 <| mem_range.mpr \u27e8x, h'.symm\u27e9\u27e9\n  have h2 (x : X) : \u03c3\u2082 x \u2264 n :=\n    Int.natCast_sub (Nat.one_le_iff_ne_zero.mpr h\u2080) \u25b8 le_sub_right_of_add_le (lt_iff_le_and_ne.mpr\n      \u27e8(range_\u03c3\u2082_subset (mem_range_self x)).2, fun h' \u21a6 h.2 <| mem_range.mpr \u27e8x, h'\u27e9\u27e9)\n  have hn : n < defaultS X := by\n    simp only [tsub_lt_self_iff, zero_lt_one, and_true, n]\n    exact Nat.zero_lt_of_ne_zero h\u2080\n  classical\n  exact Nat.find_min (S_spec X) hn fun x \u21a6 \u27e8h1 x, h2 x\u27e9\n\nvariable (X)\n\nlemma a_pos : 0 < a := by linarith [four_le_a X]\nlemma cast_a_pos : 0 < (a : \u211d) := by norm_cast; exact a_pos X\nlemma \u03c4_pos : 0 < default\u03c4 a := inv_pos.mpr (cast_a_pos X)\nlemma \u03c4_nonneg : 0 \u2264 default\u03c4 a := (\u03c4_pos X).le\n\n/-- `\u03c4` as an element of `\u211d\u22650`. -/\ndef nn\u03c4 : \u211d\u22650 := \u27e8default\u03c4 a, \u03c4_nonneg X\u27e9\n\nlemma one_lt_q : 1 < q := (q_mem_Ioc X).1\nlemma q_le_two : q \u2264 2 := (q_mem_Ioc X).2\nlemma q_pos : 0 < q := zero_lt_one.trans (one_lt_q X)\nlemma q_nonneg : 0 \u2264 q := (q_pos X).le\nlemma inv_q_sub_half_nonneg : 0 \u2264 q\u207b\u00b9 - 2\u207b\u00b9 := by\n  simp [inv_le_inv\u2080 zero_lt_two (q_pos X), q_le_two X]\n\n/-- `q` as an element of `\u211d\u22650`. -/\ndef nnq : \u211d\u22650 := \u27e8q, q_nonneg X\u27e9\n\nlemma one_lt_nnq : 1 < nnq X := one_lt_q X\nlemma nnq_le_two : nnq X \u2264 2 := q_le_two X\nlemma nnq_pos : 0 < nnq X := q_pos X\nlemma nnq_mem_Ioc : nnq X \u2208 Ioc 1 2 :=\n  \u27e8NNReal.coe_lt_coe.mp (q_mem_Ioc X).1, NNReal.coe_le_coe.mp (q_mem_Ioc X).2\u27e9\n\nend ProofData\n\nclass ProofData {X : Type*} (a : outParam \u2115) (q : outParam \u211d) (K : outParam (X \u2192 X \u2192 \u2102))\n    (\u03c3\u2081 \u03c3\u2082 : outParam (X \u2192 \u2124)) (F G : outParam (Set X)) [PseudoMetricSpace X]\n    extends PreProofData a q K \u03c3\u2081 \u03c3\u2082 F G where\n  F_subset : F \u2286 ball (cancelPt X) (defaultD a ^ defaultS X / 4)\n  G_subset : G \u2286 ball (cancelPt X) (defaultD a ^ defaultS X / 4)\n  /- The next two conditions are not in the blueprint, but will be useful in various steps.\n  It is easy to prove finitary_carleson (or metric_carleson) separately when either of these\n  fails. -/\n  volume_F_pos : 0 < volume F\n  volume_G_pos : 0 < volume G\n\nnamespace ShortVariables\n-- open this section to get shorter 1-letter names for a bunch of variables\n\nset_option hygiene false\nscoped notation \"D\" => defaultD a\nscoped notation \"\u03ba\" => default\u03ba a\nscoped notation \"Z\" => defaultZ a\nscoped notation \"\u03c4\" => default\u03c4 a\nscoped notation \"o\" => cancelPt X\nscoped notation \"S\" => defaultS X\nscoped notation \"nn\u03c4\" => nn\u03c4 X\nscoped notation \"nnq\" => nnq X\n\nend ShortVariables\n\nopen scoped ShortVariables\nvariable {X : Type*} {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102} {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X}\n\nlemma one_lt_D [PseudoMetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] : 1 < (D : \u211d) := by\n  exact_mod_cast one_lt_pow\u2080 Nat.one_lt_two (by nlinarith [four_le_a X])\n\nlemma one_le_D : 1 \u2264 (D : \u211d) := by\n  rw [\u2190 Nat.cast_one, Nat.cast_le, defaultD, \u2190 pow_zero 2]\n  exact pow_le_pow_right' one_le_two (by positivity)\n\nlemma D_nonneg : 0 \u2264 (D : \u211d) := zero_le_one.trans one_le_D\n\nlemma \u03ba_nonneg : 0 \u2264 \u03ba := by\n  rw [default\u03ba]\n  exact Real.rpow_nonneg (by norm_num) _\n\n/-- Used in `third_exception` (Lemma 5.2.10). -/\nlemma two_le_\u03baZ [PseudoMetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] : 2 \u2264 \u03ba * Z := by\n  rw [default\u03ba, defaultZ, Nat.cast_pow, show ((2 : \u2115) : \u211d) = 2 by rfl,\n    show (2 : \u211d) ^ (12 * a) = 2 ^ (12 * a : \u211d) by norm_cast, \u2190 Real.rpow_add zero_lt_two,\n    show (-10 * a + 12 * a : \u211d) = 2 * a by ring]\n  norm_cast; change 2 ^ 1 \u2264 _\n  exact Nat.pow_le_pow_of_le one_lt_two (by linarith [four_le_a X])\n\n/-- Used in `third_exception` (Lemma 5.2.10). -/\nlemma D\u03baZ_le_two_rpow_100 [PseudoMetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] :\n    (D : \u211d\u22650\u221e) ^ (-\u03ba * Z) \u2264 2 ^ (-100 : \u211d) := by\n  rw [defaultD, Nat.cast_pow, \u2190 ENNReal.rpow_natCast, \u2190 ENNReal.rpow_mul,\n    show ((2 : \u2115) : \u211d\u22650\u221e) = 2 by rfl]\n  apply ENNReal.rpow_le_rpow_of_exponent_le one_le_two\n  rw [default\u03ba, defaultZ, Nat.cast_pow, show ((2 : \u2115) : \u211d) = 2 by rfl, neg_mul,\n    show (2 : \u211d) ^ (12 * a) = 2 ^ (12 * a : \u211d) by norm_cast, mul_neg,\n    \u2190 Real.rpow_add zero_lt_two, show (-10 * a + 12 * a : \u211d) = 2 * a by ring,\n    neg_le_neg_iff]\n  norm_cast\n  calc\n    _ \u2264 100 * a ^ 2 := by nlinarith [four_le_a X]\n    _ \u2264 _ := by\n      nth_rw 1 [\u2190 mul_one (a ^ 2), \u2190 mul_assoc]\n      gcongr; exact Nat.one_le_two_pow\n\nlemma four_le_Z [PseudoMetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] : 4 \u2264 Z := by\n  rw [defaultZ, show 4 = 2 ^ 2 by rfl]\n  exact Nat.pow_le_pow_right zero_lt_two (by linarith [four_le_a X])\n\nvariable (a) in\n/-- `D` as an element of `\u211d\u22650`. -/\ndef nnD : \u211d\u22650 := \u27e8D, by simp [D_nonneg]\u27e9\n\nnamespace ShortVariables\n\nset_option hygiene false\nscoped notation \"nnD\" => nnD a\n\nend ShortVariables\n\nvariable [PseudoMetricSpace X] [h : ProofData a q K \u03c3\u2081 \u03c3\u2082 F G]\n\nlemma volume_F_lt_top : volume F < \u22a4 :=\n  lt_of_le_of_lt (measure_mono ProofData.F_subset) measure_ball_lt_top\n\nlemma volume_F_ne_top : volume F \u2260 \u22a4 := volume_F_lt_top.ne\n\nlemma volume_G_lt_top : volume G < \u22a4 :=\n  lt_of_le_of_lt (measure_mono ProofData.G_subset) measure_ball_lt_top\n\nlemma volume_G_ne_top : volume G \u2260 \u22a4 := volume_G_lt_top.ne\n\ninclude h in\nlemma isBounded_F : IsBounded F := IsBounded.subset isBounded_ball ProofData.F_subset\n\ninclude h in\n", "theoremStatement": "lemma isBounded_G : IsBounded G ", "theoremName": "isBounded_G", "fileCreated": {"commit": "238b977db22d5b1107a09468e95b78facfd58fd1", "date": "2023-10-20"}, "theoremCreated": {"commit": "88d85ba29f717ee3bb9fbd37379a6fb77b57265f", "date": "2025-01-06"}, "file": "carleson/Carleson/Defs.lean", "module": "Carleson.Defs", "jsonFile": "Carleson.Defs.jsonl", "positionMetadata": {"lineInFile": 643, "tokenPositionInFile": 26515, "theoremPositionInFile": 96}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 8, "repositoryPremises": true, "numRepositoryPremises": 8, "numPremises": 34}, "proofMetadata": {"hasProof": true, "proof": ":= IsBounded.subset isBounded_ball ProofData.G_subset", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 53}}
{"srcContext": "/-\nCopyright (c) 2024 Joris Roos. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joris Roos, S\u00e9bastien Gou\u00ebzel\n-/\n\nimport Mathlib.Analysis.Convex.PartitionOfUnity\nimport Mathlib.Analysis.Calculus.ContDiff.Basic\nimport Mathlib.MeasureTheory.Integral.Average\nimport Mathlib.MeasureTheory.Integral.Bochner\nimport Mathlib.MeasureTheory.Integral.Prod\nimport Mathlib.MeasureTheory.Measure.Haar.OfBasis\nimport Mathlib.Topology.MetricSpace.Holder\nimport Mathlib.Data.Set.Card\nimport Mathlib.Data.Real.ENatENNReal\nimport Carleson.ToMathlib.Misc\n\n/-!\n\nEXPERIMENTAL\n\n# Bounded compactly supported functions\n\nThe purpose of this file is to provide helper lemmas to streamline proofs that\nfunctions are (essentially) bounded, compactly supported and measurable.\n\nMost functions we need to deal with are of this class.\nThis can be a useful way to streamline proofs of `L^p` membership,\nin particular integrability.\n\nTodo: make `Mathlib.Tactic.FunProp` work for this\n\nThis can be expanded as needed\n\n-/\n\nset_option linter.unusedSectionVars false -- remove for mathlib\n\nnamespace MeasureTheory\n\nopen Bornology Function Set HasCompactSupport\nopen scoped ENNReal\n\nsection\n\n-- This setting should be enough for this project, but\n-- for mathlib should generalize to vector-valued, and use `MeasurableSpace X`, `Measure \u03bc`\nvariable {X \ud835\udd5c} [MeasurableSpace X] [RCLike \ud835\udd5c] {f : X \u2192 \ud835\udd5c} {\u03bc : Measure X}\nvariable [TopologicalSpace X]\n-- variable [T2Space X] -- for mathlib should remove this\n-- variable [IsFiniteMeasureOnCompacts \u03bc]\n-- variable [SigmaFinite (volume : Measure X)]\n\n/-- Bounded compactly supported measurable functions -/\n-- There are various alternative definitions one could use here\n-- After all it does seem to be better to use `IsBounded (range f)`\n-- Todo: Refactor accordingly\nstructure BoundedCompactSupport (f : X \u2192 \ud835\udd5c) : Prop where\n  isBounded : IsBounded (range f)\n  stronglyMeasurable : StronglyMeasurable f\n  hasCompactSupport : HasCompactSupport f\n\nlemma isBounded_range_iff_forall_norm_le {\u03b1 \u03b2} [SeminormedAddCommGroup \u03b1] {f : \u03b2 \u2192 \u03b1} :\n    IsBounded (range f) \u2194 \u2203 C, \u2200 x, \u2016f x\u2016 \u2264 C := by convert isBounded_iff_forall_norm_le; simp\n\nomit [TopologicalSpace X] in\nlemma _root_.Bornology.IsBounded.eLpNorm_top_lt_top (hf : IsBounded (range f)) :\n    eLpNorm f \u22a4 \u03bc < \u22a4 := by\n  obtain \u27e8C, hC\u27e9 := isBounded_range_iff_forall_norm_le.mp hf\n  apply eLpNormEssSup_lt_top_of_ae_bound (C := C)\n  exact ae_of_all \u03bc hC\n\nomit [TopologicalSpace X] in\n-- maybe in mathlib, but couldn't find it\ntheorem ae_le_of_eLpNorm_top_lt_top (hf : eLpNorm f \u22a4 \u03bc < \u22a4) :\n    \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016 \u2264 ENNReal.toReal (eLpNorm f \u22a4 \u03bc) := by\n  have := coe_nnnorm_ae_le_eLpNormEssSup f \u03bc\n  filter_upwards [this] with x hx\n  have : ENNReal.ofReal \u2016f x\u2016\u208a \u2260 \u22a4 := ENNReal.ofReal_ne_top\n  convert (ENNReal.toReal_le_toReal this ?_).mpr ?_\n  \u00b7 simp\n  \u00b7 exact hf.ne_top\n  \u00b7 exact trans ENNReal.ofReal_coe_nnreal hx\n\nnamespace BoundedCompactSupport\n\nprotected theorem zero : BoundedCompactSupport (fun (_ : X) \u21a6 (0 : \ud835\udd5c)) where\n  isBounded := isBounded_range_iff_forall_norm_le.2 \u27e80, by simp\u27e9\n  stronglyMeasurable := stronglyMeasurable_const\n  hasCompactSupport := HasCompactSupport.zero\n\ntheorem indicator_of_isBounded_range {X : Type*} [MetricSpace X] [ProperSpace X]\n    [MeasurableSpace X] [BorelSpace X] {f : X \u2192 \ud835\udd5c} (hf : IsBounded (range f))\n    (h'f : StronglyMeasurable f) {s : Set X} (h's : IsBounded s) (hs : MeasurableSet s) :\n    BoundedCompactSupport (s.indicator f) where\n  stronglyMeasurable := h'f.indicator hs\n  isBounded := by\n    rcases isBounded_range_iff_forall_norm_le.1 hf with \u27e8C, hC\u27e9\n    apply isBounded_range_iff_forall_norm_le.2 \u27e8C, fun x \u21a6 ?_\u27e9\n    simp only [indicator]\n    split_ifs\n    \u00b7 exact hC x\n    \u00b7 simp only [norm_zero]\n      apply (norm_nonneg _).trans (hC x)\n  hasCompactSupport := by\n    apply HasCompactSupport.intro (K := closure s)\n    \u00b7 apply Metric.isCompact_of_isClosed_isBounded isClosed_closure h's.closure\n    \u00b7 intro x hx\n      have : x \u2209 s := by\n        contrapose! hx; exact subset_closure hx\n      simp [this]\n\nvariable {f : X \u2192 \ud835\udd5c}\nvariable {g : X \u2192 \ud835\udd5c}\n\nvariable (hf : BoundedCompactSupport f)\nvariable (hg : BoundedCompactSupport g)\n\nsection Includehf\n\ninclude hf\n\ntheorem aestronglyMeasurable : AEStronglyMeasurable f \u03bc :=\n  hf.stronglyMeasurable.aestronglyMeasurable\n\ntheorem mem\u2112p_top : Mem\u2112p f \u22a4 \u03bc :=\n  \u27e8hf.aestronglyMeasurable, hf.isBounded.eLpNorm_top_lt_top\u27e9\n\ntheorem ae_le : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016 \u2264 ENNReal.toReal (eLpNorm f \u22a4 \u03bc) :=\n  ae_le_of_eLpNorm_top_lt_top hf.mem\u2112p_top.2\n\n/-- Bounded compactly supported functions are in all `L\u1d56` spaces. -/\ntheorem mem\u2112p [IsFiniteMeasureOnCompacts \u03bc] (p : ENNReal) : Mem\u2112p f p \u03bc :=\n  hf.hasCompactSupport.mem\u2112p_of_bound hf.aestronglyMeasurable _ hf.ae_le\n\n/-- Bounded compactly supported functions are integrable. -/\ntheorem integrable [IsFiniteMeasureOnCompacts \u03bc] : Integrable f \u03bc :=\n  mem\u2112p_one_iff_integrable.mp <| mem\u2112p hf 1\n\ntheorem mul_bdd_right (hg : IsBounded (range g)) (h2g : StronglyMeasurable g) :\n    BoundedCompactSupport (f * g) where\n  isBounded := by\n    rcases isBounded_range_iff_forall_norm_le.1 hf.isBounded with \u27e8C, hC\u27e9\n    rcases isBounded_range_iff_forall_norm_le.1 hg with \u27e8D, hD\u27e9\n    apply isBounded_range_iff_forall_norm_le.2 \u27e8C * D, fun x \u21a6 ?_\u27e9\n    simp only [Pi.mul_apply, norm_mul]\n    gcongr\n    \u00b7 apply (norm_nonneg _).trans (hC x)\n    \u00b7 exact hC x\n    \u00b7 exact hD x\n  stronglyMeasurable := hf.stronglyMeasurable.mul h2g\n  hasCompactSupport := hf.hasCompactSupport.mul_right\n\ntheorem mul_bdd_left (hg : IsBounded (range g)) (h2g : StronglyMeasurable g) :\n    BoundedCompactSupport (g * f) := by\n  rw [mul_comm]; exact mul_bdd_right hf hg h2g\n\n-- doesn't use compact support but is convenient to have here\ntheorem integrable_mul (hg : Integrable g \u03bc) : Integrable (f * g) \u03bc :=\n  Integrable.bdd_mul' hg hf.aestronglyMeasurable hf.ae_le\n\ntheorem conj : BoundedCompactSupport (star f) where\n  isBounded := by simpa [star, isBounded_range_iff_forall_norm_le] using hf.isBounded\n  stronglyMeasurable := RCLike.continuous_conj.comp_stronglyMeasurable hf.stronglyMeasurable\n  hasCompactSupport := by -- mathlib should have a lemma `HasCompactSupport.conj`?\n    simp only [star, RCLike.star_def]\n    apply (hasCompactSupport_comp_left (by simp)).2 hf.hasCompactSupport\n\ntheorem norm : BoundedCompactSupport (\u2016f \u00b7\u2016) where\n  isBounded := by simpa [isBounded_range_iff_forall_norm_le] using hf.isBounded\n  stronglyMeasurable := hf.stronglyMeasurable.norm\n  hasCompactSupport := hf.hasCompactSupport.norm\n\ntheorem const_mul (c : \ud835\udd5c) : BoundedCompactSupport (fun x \u21a6 c * (f x)) where\n  isBounded := by\n    rcases isBounded_range_iff_forall_norm_le.1 hf.isBounded with \u27e8C, hC\u27e9\n    apply isBounded_range_iff_forall_norm_le.2 \u27e8\u2016c\u2016 * C, fun x \u21a6 ?_\u27e9\n    simp only [norm_mul]\n    gcongr\n    exact hC x\n  stronglyMeasurable := hf.stronglyMeasurable.const_mul _\n  hasCompactSupport := by\n    suffices support (fun x \u21a6 c * (f x)) \u2286 support f from\n      hf.hasCompactSupport.mono this\n    exact support_mul_subset_right ..\n\ntheorem mul_const (c : \ud835\udd5c) : BoundedCompactSupport (fun x \u21a6 (f x) * c) := by\n  simp_rw [mul_comm]; exact hf.const_mul _\n\nend Includehf\n\nsection Includehfhg\n\ninclude hf hg\n\ntheorem mul : BoundedCompactSupport (f * g) := mul_bdd_right hf hg.isBounded hg.stronglyMeasurable\n\nprotected theorem add : BoundedCompactSupport (f + g) where\n  isBounded := by\n    rcases isBounded_range_iff_forall_norm_le.1 hf.isBounded with \u27e8C, hC\u27e9\n    rcases isBounded_range_iff_forall_norm_le.1 hg.isBounded with \u27e8D, hD\u27e9\n    apply isBounded_range_iff_forall_norm_le.2 \u27e8C + D, fun x \u21a6 ?_\u27e9\n    apply (norm_add_le _ _).trans\n    gcongr\n    exacts [hC x, hD x]\n  stronglyMeasurable := hf.stronglyMeasurable.add hg.stronglyMeasurable\n  hasCompactSupport := hf.hasCompactSupport.add hg.hasCompactSupport\n\nprotected theorem sub : BoundedCompactSupport (f - g) := by\n  rw [sub_eq_add_neg, neg_eq_neg_one_mul]\n  exact hf.add (hg.const_mul (-1))\n\nend Includehfhg\n\n/-- If `\u2016f\u2016` is bounded by `g` and `g` is bounded compactly supported, then so is `f`. -/\ntheorem mono {g : X \u2192 \u211d} (hg : BoundedCompactSupport g) (hf : StronglyMeasurable f)\n    (hfg : \u2200 x, \u2016f x\u2016 \u2264 g x) : BoundedCompactSupport f where\n  isBounded := by\n    rcases isBounded_range_iff_forall_norm_le.1 hg.isBounded with \u27e8C, hC\u27e9\n    refine isBounded_range_iff_forall_norm_le.2 \u27e8C, fun x \u21a6 ?_\u27e9\n    exact (hfg x).trans ((le_abs_self _).trans (hC x))\n  hasCompactSupport := by\n    refine hg.hasCompactSupport.mono ?_\n    by_contra h\n    simp only [support_subset_iff, ne_eq, mem_support, not_forall, Classical.not_imp,\n      Decidable.not_not] at h\n    obtain \u27e8x, hfx, hgx\u27e9 := h\n    specialize hfg x\n    rw [hgx] at hfg\n    exact hfx <| norm_le_zero_iff.mp hfg\n  stronglyMeasurable := hf\n\n", "theoremStatement": "theorem of_norm_le_const_mul {g : X \u2192 \u211d} {M : \u211d} (hg : BoundedCompactSupport g)\n    (hf : StronglyMeasurable f)\n    (hfg : \u2200 x, \u2016f x\u2016 \u2264 M * g x) : BoundedCompactSupport f ", "theoremName": "MeasureTheory.BoundedCompactSupport.of_norm_le_const_mul", "fileCreated": {"commit": "ec175b9008144d009269ce427b9ad43dbd70d0a5", "date": "2024-12-09"}, "theoremCreated": {"commit": "ec175b9008144d009269ce427b9ad43dbd70d0a5", "date": "2024-12-09"}, "file": "carleson/Carleson/ToMathlib/BoundedCompactSupport.lean", "module": "Carleson.ToMathlib.BoundedCompactSupport", "jsonFile": "Carleson.ToMathlib.BoundedCompactSupport.jsonl", "positionMetadata": {"lineInFile": 233, "tokenPositionInFile": 8739, "theoremPositionInFile": 13}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 3, "numPremises": 31}, "proofMetadata": {"hasProof": true, "proof": ":=\n  BoundedCompactSupport.mono (hg.const_mul M) hf hfg", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 55}}
{"srcContext": "/-\nCopyright (c) 2024 Joris Roos. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joris Roos, S\u00e9bastien Gou\u00ebzel\n-/\n\nimport Mathlib.Analysis.Convex.PartitionOfUnity\nimport Mathlib.Analysis.Calculus.ContDiff.Basic\nimport Mathlib.MeasureTheory.Integral.Average\nimport Mathlib.MeasureTheory.Integral.Bochner\nimport Mathlib.MeasureTheory.Integral.Prod\nimport Mathlib.MeasureTheory.Measure.Haar.OfBasis\nimport Mathlib.Topology.MetricSpace.Holder\nimport Mathlib.Data.Set.Card\nimport Mathlib.Data.Real.ENatENNReal\nimport Carleson.ToMathlib.Misc\n\n/-!\n\nEXPERIMENTAL\n\n# Bounded compactly supported functions\n\nThe purpose of this file is to provide helper lemmas to streamline proofs that\nfunctions are (essentially) bounded, compactly supported and measurable.\n\nMost functions we need to deal with are of this class.\nThis can be a useful way to streamline proofs of `L^p` membership,\nin particular integrability.\n\nTodo: make `Mathlib.Tactic.FunProp` work for this\n\nThis can be expanded as needed\n\n-/\n\nset_option linter.unusedSectionVars false -- remove for mathlib\n\nnamespace MeasureTheory\n\nopen Bornology Function Set HasCompactSupport\nopen scoped ENNReal\n\nsection\n\n-- This setting should be enough for this project, but\n-- for mathlib should generalize to vector-valued, and use `MeasurableSpace X`, `Measure \u03bc`\nvariable {X \ud835\udd5c} [MeasurableSpace X] [RCLike \ud835\udd5c] {f : X \u2192 \ud835\udd5c} {\u03bc : Measure X}\nvariable [TopologicalSpace X]\n-- variable [T2Space X] -- for mathlib should remove this\n-- variable [IsFiniteMeasureOnCompacts \u03bc]\n-- variable [SigmaFinite (volume : Measure X)]\n\n/-- Bounded compactly supported measurable functions -/\n-- There are various alternative definitions one could use here\n-- After all it does seem to be better to use `IsBounded (range f)`\n-- Todo: Refactor accordingly\nstructure BoundedCompactSupport (f : X \u2192 \ud835\udd5c) : Prop where\n  isBounded : IsBounded (range f)\n  stronglyMeasurable : StronglyMeasurable f\n  hasCompactSupport : HasCompactSupport f\n\nlemma isBounded_range_iff_forall_norm_le {\u03b1 \u03b2} [SeminormedAddCommGroup \u03b1] {f : \u03b2 \u2192 \u03b1} :\n    IsBounded (range f) \u2194 \u2203 C, \u2200 x, \u2016f x\u2016 \u2264 C := by convert isBounded_iff_forall_norm_le; simp\n\nomit [TopologicalSpace X] in\nlemma _root_.Bornology.IsBounded.eLpNorm_top_lt_top (hf : IsBounded (range f)) :\n    eLpNorm f \u22a4 \u03bc < \u22a4 := by\n  obtain \u27e8C, hC\u27e9 := isBounded_range_iff_forall_norm_le.mp hf\n  apply eLpNormEssSup_lt_top_of_ae_bound (C := C)\n  exact ae_of_all \u03bc hC\n\nomit [TopologicalSpace X] in\n-- maybe in mathlib, but couldn't find it\ntheorem ae_le_of_eLpNorm_top_lt_top (hf : eLpNorm f \u22a4 \u03bc < \u22a4) :\n    \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016 \u2264 ENNReal.toReal (eLpNorm f \u22a4 \u03bc) := by\n  have := coe_nnnorm_ae_le_eLpNormEssSup f \u03bc\n  filter_upwards [this] with x hx\n  have : ENNReal.ofReal \u2016f x\u2016\u208a \u2260 \u22a4 := ENNReal.ofReal_ne_top\n  convert (ENNReal.toReal_le_toReal this ?_).mpr ?_\n  \u00b7 simp\n  \u00b7 exact hf.ne_top\n  \u00b7 exact trans ENNReal.ofReal_coe_nnreal hx\n\nnamespace BoundedCompactSupport\n\nprotected theorem zero : BoundedCompactSupport (fun (_ : X) \u21a6 (0 : \ud835\udd5c)) where\n  isBounded := isBounded_range_iff_forall_norm_le.2 \u27e80, by simp\u27e9\n  stronglyMeasurable := stronglyMeasurable_const\n  hasCompactSupport := HasCompactSupport.zero\n\ntheorem indicator_of_isBounded_range {X : Type*} [MetricSpace X] [ProperSpace X]\n    [MeasurableSpace X] [BorelSpace X] {f : X \u2192 \ud835\udd5c} (hf : IsBounded (range f))\n    (h'f : StronglyMeasurable f) {s : Set X} (h's : IsBounded s) (hs : MeasurableSet s) :\n    BoundedCompactSupport (s.indicator f) where\n  stronglyMeasurable := h'f.indicator hs\n  isBounded := by\n    rcases isBounded_range_iff_forall_norm_le.1 hf with \u27e8C, hC\u27e9\n    apply isBounded_range_iff_forall_norm_le.2 \u27e8C, fun x \u21a6 ?_\u27e9\n    simp only [indicator]\n    split_ifs\n    \u00b7 exact hC x\n    \u00b7 simp only [norm_zero]\n      apply (norm_nonneg _).trans (hC x)\n  hasCompactSupport := by\n    apply HasCompactSupport.intro (K := closure s)\n    \u00b7 apply Metric.isCompact_of_isClosed_isBounded isClosed_closure h's.closure\n    \u00b7 intro x hx\n      have : x \u2209 s := by\n        contrapose! hx; exact subset_closure hx\n      simp [this]\n\nvariable {f : X \u2192 \ud835\udd5c}\nvariable {g : X \u2192 \ud835\udd5c}\n\nvariable (hf : BoundedCompactSupport f)\nvariable (hg : BoundedCompactSupport g)\n\nsection Includehf\n\ninclude hf\n\ntheorem aestronglyMeasurable : AEStronglyMeasurable f \u03bc :=\n  hf.stronglyMeasurable.aestronglyMeasurable\n\ntheorem mem\u2112p_top : Mem\u2112p f \u22a4 \u03bc :=\n  \u27e8hf.aestronglyMeasurable, hf.isBounded.eLpNorm_top_lt_top\u27e9\n\ntheorem ae_le : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016 \u2264 ENNReal.toReal (eLpNorm f \u22a4 \u03bc) :=\n  ae_le_of_eLpNorm_top_lt_top hf.mem\u2112p_top.2\n\n", "theoremStatement": "/-- Bounded compactly supported functions are in all `L\u1d56` spaces. -/\ntheorem mem\u2112p [IsFiniteMeasureOnCompacts \u03bc] (p : ENNReal) : Mem\u2112p f p \u03bc ", "theoremName": "MeasureTheory.BoundedCompactSupport.mem\u2112p", "fileCreated": {"commit": "ec175b9008144d009269ce427b9ad43dbd70d0a5", "date": "2024-12-09"}, "theoremCreated": {"commit": "ec175b9008144d009269ce427b9ad43dbd70d0a5", "date": "2024-12-09"}, "file": "carleson/Carleson/ToMathlib/BoundedCompactSupport.lean", "module": "Carleson.ToMathlib.BoundedCompactSupport", "jsonFile": "Carleson.ToMathlib.BoundedCompactSupport.jsonl", "positionMetadata": {"lineInFile": 132, "tokenPositionInFile": 4532, "theoremPositionInFile": 6}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 4, "numPremises": 33}, "proofMetadata": {"hasProof": true, "proof": ":=\n  hf.hasCompactSupport.mem\u2112p_of_bound hf.aestronglyMeasurable _ hf.ae_le", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 75}}
{"srcContext": "import Mathlib.MeasureTheory.Integral.MeanInequalities\nimport Mathlib.MeasureTheory.Integral.Layercake\nimport Mathlib.MeasureTheory.Integral.Lebesgue\nimport Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar\nimport Mathlib.Analysis.SpecialFunctions.Pow.Integral\nimport Carleson.ToMathlib.ENorm\nimport Carleson.ToMathlib.Misc\n\nnoncomputable section\n\nopen NNReal ENNReal NormedSpace MeasureTheory Set Filter Topology Function\n\nsection move\n\n\nvariable {\u03b1 \ud835\udd5c E : Type*} {m : MeasurableSpace \u03b1}\n  {\u03bc : Measure \u03b1} [NontriviallyNormedField \ud835\udd5c]\n  [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]\n  {p : \u211d\u22650\u221e}\n\n-- todo: move/rename/and perhaps reformulate in terms of \u2016.\u2016\u2091\nlemma ENNNorm_absolute_homogeneous {c : \ud835\udd5c} (z : E) : ofNNReal \u2016c \u2022 z\u2016\u208a = \u2191\u2016c\u2016\u208a * \u2191\u2016z\u2016\u208a :=\n  (toReal_eq_toReal_iff' coe_ne_top coe_ne_top).mp (norm_smul c z)\n\nlemma ENNNorm_add_le (y z : E) : ofNNReal \u2016y + z\u2016\u208a \u2264 \u2191\u2016y\u2016\u208a + \u2191\u2016z\u2016\u208a :=\n  (toReal_le_toReal coe_ne_top coe_ne_top).mp (nnnorm_add_le ..)\n\nlemma measure_mono_ae' {A B : Set \u03b1} (h : \u03bc (B \\ A) = 0) :\n    \u03bc B \u2264 \u03bc A := by\n  apply measure_mono_ae\n  change \u03bc {x | \u00ac B x \u2264 A x} = 0\n  simp only [le_Prop_eq, Classical.not_imp]\n  exact h\n\n\nlemma eLpNormEssSup_toReal_le {f : \u03b1 \u2192 \u211d\u22650\u221e} :\n    eLpNormEssSup (ENNReal.toReal \u2218 f) \u03bc \u2264 eLpNormEssSup f \u03bc := by\n  simp_rw [eLpNormEssSup, enorm_eq_self]\n  apply essSup_mono_ae\n  apply Eventually.of_forall\n  simp [implies_true]\n\n", "theoremStatement": "lemma eLpNormEssSup_toReal_eq {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : \u2200\u1d50 x \u2202\u03bc, f x \u2260 \u221e) :\n    eLpNormEssSup (ENNReal.toReal \u2218 f) \u03bc = eLpNormEssSup f \u03bc ", "theoremName": "eLpNormEssSup_toReal_eq", "fileCreated": {"commit": "1a36cbeaee9466fb56c9aca49ef373f9f9cc7ab7", "date": "2025-01-23"}, "theoremCreated": {"commit": "451f4568375c1be265a0beb82adb601f9a3ee74d", "date": "2025-01-20"}, "file": "carleson/Carleson/ToMathlib/WeakType.lean", "module": "Carleson.ToMathlib.WeakType", "jsonFile": "Carleson.ToMathlib.WeakType.jsonl", "positionMetadata": {"lineInFile": 43, "tokenPositionInFile": 1365, "theoremPositionInFile": 4}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 3, "numPremises": 50}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp_rw [eLpNormEssSup, enorm_eq_self]\n  apply essSup_congr_ae\n  filter_upwards [hf] with x hx\n  simp [hx]", "proofType": "tactic", "proofLengthLines": 4, "proofLengthTokens": 114}}
{"srcContext": "import Carleson.Forest\nimport Carleson.ToMathlib.HardyLittlewood\nimport Carleson.ToMathlib.BoundedCompactSupport\nimport Carleson.ToMathlib.Misc\nimport Carleson.Psi\n\nopen ShortVariables TileStructure\nvariable {X : Type*} {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102} {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X}\n  [MetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] [TileStructure Q D \u03ba S o]\n  {n j j' : \u2115} {t : Forest X n} {u u\u2081 u\u2082 p : \ud835\udd13 X} {x x' : X} {\ud835\udd16 : Set (\ud835\udd13 X)}\n  {f f\u2081 f\u2082 g g\u2081 g\u2082 : X \u2192 \u2102} {I J J' L : Grid X}\nvariable {E' : Type*} [NormedAddCommGroup E'] [NormedSpace \u211d E']\n\nnoncomputable section\n\nopen Set MeasureTheory Metric Function Complex Bornology TileStructure Classical Filter\nopen scoped NNReal ENNReal ComplexConjugate\n\nnamespace TileStructure.Forest\n\n/-! ## Section 7.1 and Lemma 7.1.3 -/\n\nvariable (t) in\n/-- The definition `\u03c3(u, x)` given in Section 7.1.\nWe may assume `u \u2208 t` whenever proving things about this definition. -/\ndef \u03c3 (u : \ud835\udd13 X) (x : X) : Finset \u2124 := .image \ud835\udd30 { p | p \u2208 t u \u2227 x \u2208 E p }\n\nvariable (t) in\nprivate lemma exists_p_of_mem_\u03c3 (u : \ud835\udd13 X) (x : X) {s : \u2124} (hs : s \u2208 t.\u03c3 u x) :\n    \u2203 p \u2208 t.\ud835\udd17 u, x \u2208 E p \u2227 \ud835\udd30 p = s := by\n  have \u27e8p, hp\u27e9 := Finset.mem_image.mp hs\n  simp only [mem_\ud835\udd17, Finset.mem_filter] at hp\n  use p, hp.1.2.1, hp.1.2.2, hp.2\n\n/- \\overline{\u03c3} from the blueprint. -/\nvariable (t) in\ndef \u03c3Max (u : \ud835\udd13 X) (x : X) (h\u03c3 : (t.\u03c3 u x).Nonempty) : \u2124 :=\n  t.\u03c3 u x |>.max' h\u03c3\n\n/- \\underline{\u03c3} from the blueprint. -/\nvariable (t) in\ndef \u03c3Min (u : \ud835\udd13 X) (x : X) (h\u03c3 : (t.\u03c3 u x).Nonempty) : \u2124 :=\n  t.\u03c3 u x |>.min' h\u03c3\n\nvariable (t) in\nprivate lemma \u03c3Max_mem_\u03c3 (u : \ud835\udd13 X) (x : X) (h\u03c3 : (t.\u03c3 u x).Nonempty) : \u03c3Max t u x h\u03c3 \u2208 t.\u03c3 u x :=\n  (t.\u03c3 u x).max'_mem h\u03c3\n\n/-- The definition of `\ud835\udcd9\u2080(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcd9\u2080 (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {J : Grid X | s J = -S \u2228 \u2200 p \u2208 \ud835\udd16, \u00ac(\ud835\udcd8 p : Set X) \u2286 ball (c J) (100 * D ^ (s J + 1))}\n\n/-- The definition of `\ud835\udcd9(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcd9 (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {x | Maximal (\u00b7 \u2208 \ud835\udcd9\u2080 \ud835\udd16) x}\n\nlemma \ud835\udcd9_subset_\ud835\udcd9\u2080 {\ud835\udd16 : Set (\ud835\udd13 X)} : \ud835\udcd9 \ud835\udd16 \u2286 \ud835\udcd9\u2080 \ud835\udd16 := sep_subset ..\n\nlemma pairwiseDisjoint_\ud835\udcd9 : (\ud835\udcd9 \ud835\udd16).PairwiseDisjoint (fun I \u21a6 (I : Set X)) := fun I mI J mJ hn \u21a6 by\n  have : IsAntichain (\u00b7 \u2264 \u00b7) (\ud835\udcd9 \ud835\udd16) := setOf_maximal_antichain _\n  exact (le_or_ge_or_disjoint.resolve_left (this mI mJ hn)).resolve_left (this mJ mI hn.symm)\n\n/-- The definition of `\ud835\udcdb\u2080(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcdb\u2080 (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {L : Grid X | s L = -S \u2228 (\u2203 p \u2208 \ud835\udd16, L \u2264 \ud835\udcd8 p) \u2227 \u2200 p \u2208 \ud835\udd16, \u00ac\ud835\udcd8 p \u2264 L}\n\n/-- The definition of `\ud835\udcdb(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcdb (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {x | Maximal (\u00b7 \u2208 \ud835\udcdb\u2080 \ud835\udd16) x}\n\nlemma \ud835\udcdb_subset_\ud835\udcdb\u2080 {\ud835\udd16 : Set (\ud835\udd13 X)} : \ud835\udcdb \ud835\udd16 \u2286 \ud835\udcdb\u2080 \ud835\udd16 := sep_subset ..\n\nprivate lemma s_le_s_of_mem_\ud835\udcdb {\ud835\udd16 : Set (\ud835\udd13 X)} {L : Grid X} (hL : L \u2208 \ud835\udcdb \ud835\udd16)\n    {p : \ud835\udd13 X} (hp : p \u2208 \ud835\udd16) (hpL : \u00ac Disjoint (\ud835\udcd8 p : Set X) (L : Set X)) : s L \u2264 s (\ud835\udcd8 p) := by\n  simp only [\ud835\udcdb, \ud835\udcdb\u2080, Grid.le_def, not_and, not_le, and_imp] at hL\n  rcases hL.1 with h | h\n  \u00b7 exact h \u25b8 (range_s_subset \u27e8\ud835\udcd8 p, rfl\u27e9).1\n  \u00b7 by_contra!\n    exact lt_asymm this <| h.2 p hp <| (GridStructure.fundamental_dyadic' this.le).resolve_right hpL\n\nprivate lemma subset_of_mem_\ud835\udcdb {\ud835\udd16 : Set (\ud835\udd13 X)} {L : Grid X} (hL : L \u2208 \ud835\udcdb \ud835\udd16) {p : \ud835\udd13 X}\n    (hp : p \u2208 \ud835\udd16) (hpL : \u00ac Disjoint (\ud835\udcd8 p : Set X) (L : Set X)) : (L : Set X) \u2286 (\ud835\udcd8 p : Set X) :=\n  GridStructure.fundamental_dyadic' (s_le_s_of_mem_\ud835\udcdb hL hp hpL) |>.resolve_right fun h \u21a6 hpL h.symm\n\n/-- The projection operator `P_\ud835\udcd2 f(x)`, given above Lemma 7.1.3.\nIn lemmas the `c` will be pairwise disjoint on `C`. -/\ndef approxOnCube (C : Set (Grid X)) (f : X \u2192 E') (x : X) : E' :=\n  \u2211 J \u2208 { p | p \u2208 C }, (J : Set X).indicator (fun _ \u21a6 \u2a0d y in J, f y) x\n\nlemma stronglyMeasurable_approxOnCube (C : Set (Grid X)) (f : X \u2192 E') :\n    StronglyMeasurable (approxOnCube (X := X) (K := K) C f) :=\n  Finset.stronglyMeasurable_sum _ (fun _ _ \u21a6 stronglyMeasurable_const.indicator coeGrid_measurable)\n\nlemma integrable_approxOnCube (C : Set (Grid X)) {f : X \u2192 E'} : Integrable (approxOnCube C f) := by\n  refine integrable_finset_sum _ (fun i hi \u21a6 ?_)\n  constructor\n  \u00b7 exact (aestronglyMeasurable_indicator_iff coeGrid_measurable).mpr aestronglyMeasurable_const\n  \u00b7 simp_rw [hasFiniteIntegral_iff_enorm, enorm_indicator_eq_indicator_enorm]\n    apply lt_of_le_of_lt <| lintegral_indicator_const_le (i : Set X) _\n    exact ENNReal.mul_lt_top ENNReal.coe_lt_top volume_coeGrid_lt_top\n\nlemma approxOnCube_nonneg {C : Set (Grid X)} {f : X \u2192 \u211d} (hf : \u2200 (y : X), f y \u2265 0) {x : X} :\n    approxOnCube C f x \u2265 0 :=\n  Finset.sum_nonneg' (fun _ \u21a6 Set.indicator_nonneg (fun _ _ \u21a6 integral_nonneg hf) _)\n\nlemma approxOnCube_apply {C : Set (Grid X)} (hC : C.PairwiseDisjoint (fun I \u21a6 (I : Set X)))\n    (f : X \u2192 E') {x : X} {J : Grid X} (hJ : J \u2208 C) (xJ : x \u2208 J) :\n    (approxOnCube C f) x = \u2a0d y in J, f y := by\n  rw [approxOnCube, \u2190 Finset.sum_filter_not_add_sum_filter _ (J = \u00b7)]\n  have eq0 : \u2211 i \u2208 Finset.filter (\u00ac J = \u00b7) (Finset.univ.filter (\u00b7 \u2208 C)),\n      (i : Set X).indicator (fun _ \u21a6 \u2a0d y in i, f y) x = 0 := by\n    suffices \u2200 i \u2208 (Finset.univ.filter (\u00b7 \u2208 C)).filter (\u00ac J = \u00b7),\n      (i : Set X).indicator (fun _ \u21a6 \u2a0d y in i, f y) x = 0 by simp [Finset.sum_congr rfl this]\n    intro i hi\n    simp only [Finset.mem_filter, Finset.mem_univ, true_and] at hi\n    apply indicator_of_not_mem <|\n      Set.disjoint_left.mp ((hC.eq_or_disjoint hJ hi.1).resolve_left hi.2) xJ\n  have eq_ave : \u2211 i \u2208 (Finset.univ.filter (\u00b7 \u2208 C)).filter (J = \u00b7),\n      (i : Set X).indicator (fun _ \u21a6 \u2a0d y in i, f y) x = \u2a0d y in J, f y := by\n    suffices (Finset.univ.filter (\u00b7 \u2208 C)).filter (J = \u00b7) = {J} by simp [this, xJ, \u2190 Grid.mem_def]\n    exact subset_antisymm (fun _ h \u21a6 Finset.mem_singleton.mpr (Finset.mem_filter.mp h).2.symm)\n      (fun _ h \u21a6 by simp [Finset.mem_singleton.mp h, hJ])\n  rw [eq0, eq_ave, zero_add]\n\nlemma boundedCompactSupport_approxOnCube {\ud835\udd5c : Type*} [RCLike \ud835\udd5c] {C : Set (Grid X)} {f : X \u2192 \ud835\udd5c} :\n    BoundedCompactSupport (approxOnCube C f) :=\n  BoundedCompactSupport.finset_sum fun J hJ \u21a6\n    BoundedCompactSupport.indicator_of_isBounded_range (by simp) stronglyMeasurable_const\n    ((isBounded_iff_subset_ball (c J)).mpr \u27e84 * D ^ s J, Grid_subset_ball\u27e9) coeGrid_measurable\n\n-- Used in the proof of Lemma 7.1.6\nlemma integral_eq_lintegral_approxOnCube {C : Set (Grid X)}\n    (hC : C.PairwiseDisjoint fun I \u21a6 (I : Set X)) {J : Grid X} (hJ : J \u2208 C) {f : X \u2192 \u2102}\n    (hf : BoundedCompactSupport f) : ENNReal.ofReal (\u222b y in J, \u2016f y\u2016) =\n    \u222b\u207b (y : X) in J, \u2016approxOnCube C (fun x \u21a6 (\u2016f x\u2016 : \u2102)) y\u2016\u208a := by\n  have nonneg : 0 \u2264\u1da0[ae (volume.restrict J)] fun y \u21a6 \u2016f y\u2016 := Filter.Eventually.of_forall (by simp)\n  have vol_J_ne_zero := (volume_coeGrid_pos (X := X) (i := J) (defaultD_pos' a)).ne.symm\n  have eq : \u222b\u207b (y : X) in J, \u2016approxOnCube C (fun x \u21a6 (\u2016f x\u2016 : \u2102)) y\u2016\u208a =\n      \u222b\u207b y in (J : Set X), ENNReal.ofReal (\u2a0d z in J, \u2016f z\u2016) := by\n    refine setLIntegral_congr_fun coeGrid_measurable (Filter.Eventually.of_forall fun y hy \u21a6 ?_)\n    rw [approxOnCube_apply hC _ hJ hy, ENNReal.ofReal]\n    \u00b7 apply congrArg\n      have : \u2016\u2a0d y in J, (\u2016f y\u2016 : \u2102)\u2016\u208a = \u2016\u2a0d y in J, \u2016f y\u2016\u2016\u208a := by\n        convert congrArg (\u2016\u00b7\u2016\u208a) <| integral_ofReal (f := (\u2016f \u00b7\u2016)) using 1\n        simp [average]\n      exact this \u25b8 (Real.toNNReal_eq_nnnorm_of_nonneg <| integral_nonneg (fun y \u21a6 by simp)).symm\n  rw [ofReal_integral_eq_lintegral_ofReal hf.integrable.norm.restrict nonneg,\n    eq, lintegral_const, average_eq, smul_eq_mul, ENNReal.ofReal_mul, ENNReal.ofReal_inv_of_pos,\n    ENNReal.ofReal_toReal, ofReal_integral_eq_lintegral_ofReal hf.norm.integrable nonneg, mul_comm,\n    \u2190 mul_assoc, Measure.restrict_apply MeasurableSet.univ, univ_inter,\n    ENNReal.mul_inv_cancel vol_J_ne_zero volume_coeGrid_lt_top.ne, one_mul]\n  \u00b7 simp [volume_coeGrid_lt_top.ne]\n  \u00b7 simpa using ENNReal.toReal_pos vol_J_ne_zero volume_coeGrid_lt_top.ne\n  \u00b7 exact inv_nonneg.mpr ENNReal.toReal_nonneg\n\nlemma approxOnCube_ofReal (C : Set (Grid X)) (f : X \u2192 \u211d) (x : X) :\n    approxOnCube C (Complex.ofReal <| f \u00b7) x = Complex.ofReal (approxOnCube C f x) := by\n  simp_rw [approxOnCube, ofReal_sum]\n  refine Finset.sum_congr rfl (fun J _ \u21a6 ?_)\n  by_cases hx : x \u2208 (J : Set X)\n  \u00b7 simpa only [indicator_of_mem hx] using integral_ofReal\n  \u00b7 simp only [indicator_of_not_mem hx, ofReal_zero]\n\nlemma norm_approxOnCube_le_approxOnCube_norm {C : Set (Grid X)} {f : X \u2192 E'} {x : X} :\n    \u2016approxOnCube C f x\u2016 \u2264 approxOnCube C (\u2016f \u00b7\u2016) x := by\n  refine (norm_sum_le _ _).trans <| Finset.sum_le_sum (fun J hJ \u21a6 ?_)\n  rw [norm_indicator_eq_indicator_norm]\n  gcongr\n  apply norm_integral_le_integral_norm\n\n/-- The definition `I_i(x)`, given above Lemma 7.1.3.\nThe cube of scale `s` that contains `x`. There is at most 1 such cube, if it exists. -/\ndef cubeOf (i : \u2124) (x : X) : Grid X :=\n  Classical.epsilon (fun I \u21a6 x \u2208 I \u2227 s I = i)\n\nlemma cubeOf_spec {i : \u2124} (hi : i \u2208 Icc (-S : \u2124) S) (I : Grid X) {x : X} (hx : x \u2208 I) :\n    x \u2208 cubeOf i x \u2227 s (cubeOf i x) = i := by\n  apply epsilon_spec (p := fun I \u21a6 x \u2208 I \u2227 s I = i)\n  by_cases hiS : i = S\n  \u00b7 use topCube, subset_topCube hx, hiS \u25b8 s_topCube\n  simpa [and_comm] using Set.mem_iUnion\u2082.mp <| Grid_subset_biUnion i\n    \u27e8hi.1, s_topCube (X := X) \u25b8 lt_of_le_of_ne hi.2 hiS\u27e9 (subset_topCube hx)\n\n/-- The definition `T_\ud835\udcdd^\u03b8 f(x)`, given in (7.1.3).\nFor convenience, the suprema are written a bit differently than in the blueprint\n(avoiding `cubeOf`), but this should be equivalent.\nThis is `0` if `x` doesn't lie in a cube. -/\ndef nontangentialMaximalFunction (\u03b8 : \u0398 X) (f : X \u2192 \u2102) (x : X) : \u211d\u22650\u221e :=\n  \u2a06 (I : Grid X) (_ : x \u2208 I) (x' \u2208 I) (s\u2082 \u2208 Icc (s I) S)\n  (_ : ENNReal.ofReal (D ^ (s\u2082 - 1)) \u2264 upperRadius Q \u03b8 x'),\n  \u2016\u2211 i \u2208 Icc (s I) s\u2082, \u222b y, Ks i x' y * f y\u2016\u208a\n\nprotected theorem MeasureTheory.Measurable.nontangentialMaximalFunction {\u03b8 : \u0398 X} {f : X \u2192 \u2102} :\n    Measurable (nontangentialMaximalFunction \u03b8 f) := by\n  refine Measurable.iSup (fun I \u21a6 ?_)\n  let c := \u2a06 x' \u2208 I, \u2a06 s\u2082 \u2208 Icc (s I) S, \u2a06 (_ : ENNReal.ofReal (D ^ (s\u2082 - 1)) \u2264 upperRadius Q \u03b8 x'),\n    (\u2016\u2211 i \u2208 (Icc (s I) s\u2082), \u222b (y : X), Ks i x' y * f y\u2016\u208a : ENNReal)\n  have : (fun x \u21a6 \u2a06 (_ : x \u2208 I), c) = fun x \u21a6 ite (x \u2208 I) c 0 := by\n    ext x; by_cases hx : x \u2208 I <;> simp [hx]\n  convert (measurable_const.ite coeGrid_measurable measurable_const) using 1\n\n-- Set used in definition of `boundaryOperator`\nvariable (t) (u) in private def \ud835\udcd9' (x : X) (i : \u2124) : Finset (Grid X) :=\n  { J | J \u2208 \ud835\udcd9 (t u) \u2227 (J : Set X) \u2286 ball x (16 * D ^ i) \u2227 s J \u2264 i }\n\nprivate lemma mem_\ud835\udcd9_of_mem_\ud835\udcd9' {x : X} {i : \u2124} {J : Grid X} : J \u2208 \ud835\udcd9' t u x i \u2192 J \u2208 \ud835\udcd9 (t u) := by\n  intro hJ\n  simp only [\ud835\udcd9', Finset.mem_filter] at hJ\n  exact hJ.2.1\n\nvariable (t) in\n/-- The operator `S_{1,\ud835\udd32} f(x)`, given in (7.1.4). -/\ndef boundaryOperator (u : \ud835\udd13 X) (f : X \u2192 \u2102) (x : X) : \u211d\u22650\u221e :=\n  \u2211 I : Grid X, (I : Set X).indicator (x := x) fun _ \u21a6 \u2211 J \u2208 \ud835\udcd9' t u (c I) (s I),\n  D ^ ((s J - s I) / (a : \u211d)) / volume (ball (c I) (16 * D ^ (s I))) * \u222b\u207b y in (J : Set X), \u2016f y\u2016\u208a\n\nprotected theorem MeasureTheory.Measurable.boundaryOperator {u : \ud835\udd13 X} {f : X \u2192 \u2102} :\n    Measurable (t.boundaryOperator u f) := by\n  refine Finset.measurable_sum _ (fun I _ \u21a6 ?_)\n  exact (Finset.measurable_sum _ (fun J _ \u21a6 measurable_const)).indicator coeGrid_measurable\n\n-- Currently unused; uncomment if needed.\n/- lemma boundaryOperator_lt_top (hf : BoundedCompactSupport f) : t.boundaryOperator u f x < \u22a4 := by\n  refine ENNReal.sum_lt_top.mpr (fun I _ \u21a6 ?_)\n  by_cases hx : x \u2208 (I : Set X)\n  \u00b7 rw [indicator_of_mem hx]\n    refine ENNReal.sum_lt_top.mpr (fun J hJ \u21a6 ENNReal.mul_lt_top ?_ hf.integrable.integrableOn.2)\n    apply ENNReal.div_lt_top (by simp)\n    exact ne_of_gt <| measure_ball_pos volume _ <| mul_pos (by norm_num) (defaultD_pow_pos a (s I))\n  \u00b7 simp [hx] -/\n\n/-- The indexing set for the collection of balls \ud835\udcd1, defined above Lemma 7.1.3. -/\ndef \ud835\udcd1 : Set (\u2115 \u00d7 Grid X) := Icc 0 (S + 5) \u00d7\u02e2 univ\n\n/-- The center function for the collection of balls \ud835\udcd1. -/\ndef c\ud835\udcd1 (z : \u2115 \u00d7 Grid X) : X := c z.2\n\n/-- The radius function for the collection of balls \ud835\udcd1. -/\ndef r\ud835\udcd1 (z : \u2115 \u00d7 Grid X) : \u211d := 2 ^ z.1 * D ^ s z.2\n\nlemma \ud835\udcd1_finite : (\ud835\udcd1 (X := X)).Finite :=\n  finite_Icc .. |>.prod finite_univ\n\n/-- Lemma 7.1.1, freely translated. -/\nlemma convex_scales (hu : u \u2208 t) : OrdConnected (t.\u03c3 u x : Set \u2124) := by\n  rw [ordConnected_def]; intro i mi j mj k mk\n  simp_rw [Finset.mem_coe, \u03c3, Finset.mem_image, Finset.mem_filter, Finset.mem_univ,\n    true_and] at mi mj \u22a2\n  obtain \u27e8p, \u27e8mp, xp, Qxp, sxp\u27e9, sp\u27e9 := mi\n  obtain \u27e8p'', \u27e8mp'', xp'', Qxp'', sxp''\u27e9, sp''\u27e9 := mj\n  have ilj : i \u2264 j := nonempty_Icc.mp \u27e8k, mk\u27e9\n  rw [\u2190 sp, \u2190 sp''] at ilj mk\n  obtain \u27e8K, sK, lK, Kl\u27e9 := Grid.exists_sandwiched (le_of_mem_of_mem ilj xp xp'') k mk\n  have := range_subset_iff.mp (biUnion_\u03a9 (i := K)) x\n  simp_rw [mem_preimage, mem_singleton_iff, mem_iUnion, exists_prop] at this\n  obtain \u27e8(p' : \ud835\udd13 X), (\ud835\udcd8p' : \ud835\udcd8 p' = K), Qxp'\u27e9 := this\n  rw [\u2190 \ud835\udcd8p'] at lK Kl sK; refine \u27e8p', ?_, sK\u27e9\n  have l\u2081 : p \u2264 p' := \u27e8lK,\n    (relative_fundamental_dyadic lK).resolve_left (not_disjoint_iff.mpr \u27e8_, Qxp, Qxp'\u27e9)\u27e9\n  have l\u2082 : p' \u2264 p'' := \u27e8Kl,\n    (relative_fundamental_dyadic Kl).resolve_left (not_disjoint_iff.mpr \u27e8_, Qxp', Qxp''\u27e9)\u27e9\n  refine \u27e8(t.ordConnected hu).out mp mp'' \u27e8l\u2081, l\u2082\u27e9, \u27e8(Grid.le_def.mp lK).1 xp, Qxp', ?_\u27e9\u27e9\n  exact Icc_subset_Icc sxp.1 sxp''.2 \u27e8(Grid.le_def.mp lK).2, (Grid.le_def.mp Kl).2\u27e9\n\n/-- Part of Lemma 7.1.2 -/\n@[simp]\nlemma biUnion_\ud835\udcd9 : \u22c3 J \u2208 \ud835\udcd9 \ud835\udd16, J = \u22c3 I : Grid X, (I : Set X) := by\n  refine subset_antisymm (iUnion\u2082_subset_iUnion ..) fun x mx \u21a6 ?_\n  simp_rw [mem_iUnion] at mx \u22a2; obtain \u27e8I, mI\u27e9 := mx\n  obtain \u27e8J, sJ, mJ\u27e9 :=\n    Grid.exists_containing_subcube _ \u27e8le_rfl, scale_mem_Icc.1\u27e9 mI\n  have : J \u2208 (\ud835\udcd9\u2080 \ud835\udd16).toFinset := by rw [mem_toFinset]; left; exact sJ\n  obtain \u27e8M, lM, maxM\u27e9 := (\ud835\udcd9\u2080 \ud835\udd16).toFinset.exists_le_maximal this\n  simp_rw [mem_toFinset] at maxM\n  use M, maxM, (Grid.le_def.mp lM).1 mJ\n\n/-- Part of Lemma 7.1.2 -/\n@[simp]\nlemma biUnion_\ud835\udcdb : \u22c3 J \u2208 \ud835\udcdb \ud835\udd16, J = \u22c3 I : Grid X, (I : Set X) := by\n  refine subset_antisymm (iUnion\u2082_subset_iUnion ..) fun x mx \u21a6 ?_\n  simp_rw [mem_iUnion] at mx \u22a2; obtain \u27e8I, mI\u27e9 := mx\n  obtain \u27e8J, sJ, mJ\u27e9 :=\n    Grid.exists_containing_subcube _ \u27e8le_rfl, scale_mem_Icc.1\u27e9 mI\n  have : J \u2208 (\ud835\udcdb\u2080 \ud835\udd16).toFinset := by rw [mem_toFinset]; left; exact sJ\n  obtain \u27e8M, lM, maxM\u27e9 := (\ud835\udcdb\u2080 \ud835\udd16).toFinset.exists_le_maximal this\n  simp_rw [mem_toFinset] at maxM\n  use M, maxM, (Grid.le_def.mp lM).1 mJ\n\n/-- Part of Lemma 7.1.2 -/\nlemma pairwiseDisjoint_\ud835\udcdb : (\ud835\udcdb \ud835\udd16).PairwiseDisjoint (fun I \u21a6 (I : Set X)) := fun I mI J mJ hn \u21a6 by\n  have : IsAntichain (\u00b7 \u2264 \u00b7) (\ud835\udcdb \ud835\udd16) := setOf_maximal_antichain _\n  exact (le_or_ge_or_disjoint.resolve_left (this mI mJ hn)).resolve_left (this mJ mI hn.symm)\n\n/-- The constant used in `first_tree_pointwise`.\nHas value `10 * 2 ^ (104 * a ^ 3)` in the blueprint. -/\n-- Todo: define this recursively in terms of previous constants\nirreducible_def C7_1_4 (a : \u2115) : \u211d\u22650 := 10 * 2 ^ (104 * (a : \u211d) ^ 3)\n\n-- Used in the proof of `exp_sub_one_le`, which is used to prove Lemma 7.1.4\nprivate lemma exp_Lipschitz : LipschitzWith 1 (fun (t : \u211d) \u21a6 exp (.I * t)) := by\n  have mul_I : Differentiable \u211d fun (t : \u211d) \u21a6 I * t := Complex.ofRealCLM.differentiable.const_mul I\n  refine lipschitzWith_of_nnnorm_deriv_le mul_I.cexp (fun x \u21a6 ?_)\n  have : (fun (t : \u211d) \u21a6 cexp (I * t)) = cexp \u2218 (fun (t : \u211d) \u21a6 I * t) := rfl\n  rw [this, deriv_comp x differentiableAt_exp (mul_I x), Complex.deriv_exp, deriv_const_mul_field']\n  simp_rw [show deriv ofReal x = 1 from ofRealCLM.hasDerivAt.deriv, mul_one]\n  rw [nnnorm_mul, nnnorm_I, mul_one, \u2190 norm_toNNReal, mul_comm, Complex.norm_exp_ofReal_mul_I]\n  exact Real.toNNReal_one.le\n\n-- Used in the proof of Lemma 7.1.4\nprivate lemma exp_sub_one_le (t : \u211d) : \u2016exp (.I * t) - 1\u2016 \u2264 \u2016t\u2016 := by\n  simpa [enorm_eq_nnnorm] using exp_Lipschitz t 0\n\n-- Used in the proofs of Lemmas 7.1.4 and 7.1.5\nprivate lemma dist_lt_5 (hu : u \u2208 t) (mp : p \u2208 t.\ud835\udd17 u) (Qxp : Q x \u2208 \u03a9 p) :\n    dist_(p) (\ud835\udcac u) (Q x) < 5 := calc\n  _ \u2264 dist_(p) (\ud835\udcac u) (\ud835\udcac p) + dist_(p) (Q x) (\ud835\udcac p) := dist_triangle_right ..\n  _ < 4 + 1 :=\n    add_lt_add ((t.smul_four_le hu mp).2 (by convert mem_ball_self zero_lt_one)) (subset_cball Qxp)\n  _ = 5 := by norm_num\n\n-- The bound in the third display in the proof of Lemma 7.1.4\n", "theoremStatement": "private lemma L7_1_4_bound (hu : u \u2208 t) {s : \u2124} (hs : s \u2208 t.\u03c3 u x) {y : X} (hKxy : Ks s x y \u2260 0) :\n    \u2016exp (.I * (-\ud835\udcac u y + Q x y + \ud835\udcac u x - Q x x)) - 1\u2016 \u2264\n    5 * 2 ^ (4 * a) * 2 ^ (s - \u03c3Max t u x \u27e8s, hs\u27e9) ", "theoremName": "TileStructure.Forest.L7_1_4_bound", "fileCreated": {"commit": "5e49c3692f6d7344434caa7eea5f412f0ee35863", "date": "2024-09-27"}, "theoremCreated": {"commit": "3298f748e9eb26a242da5ee38cb50dc55e604935", "date": "2025-01-08"}, "file": "carleson/Carleson/ForestOperator/PointwiseEstimate.lean", "module": "Carleson.ForestOperator.PointwiseEstimate", "jsonFile": "Carleson.ForestOperator.PointwiseEstimate.jsonl", "positionMetadata": {"lineInFile": 322, "tokenPositionInFile": 15985, "theoremPositionInFile": 43}, "dependencyMetadata": {"inFilePremises": null, "numInFilePremises": null, "repositoryPremises": null, "numRepositoryPremises": null, "numPremises": null}, "proofMetadata": {"hasProof": true, "proof": ":=\n  have \u27e8p\u209b, pu, xp\u209b, hp\u209b\u27e9 := t.exists_p_of_mem_\u03c3 u x hs\n  have \u27e8p', p'u, xp', hp'\u27e9 := t.exists_p_of_mem_\u03c3 u x (t.\u03c3Max_mem_\u03c3 u x \u27e8s, hs\u27e9)\n  have hr : (D : \u211d) ^ s / 2 > 0 := by rw [defaultD]; positivity\n  have s_le : GridStructure.s (\ud835\udcd8 p\u209b) \u2264 GridStructure.s (\ud835\udcd8 p') := by convert (\u03c3 t u x).le_max' s hs\n  have exp_bound :\n      \u2016exp (.I * (- \ud835\udcac u y + Q x y + \ud835\udcac u x - Q x x)) - 1\u2016 \u2264 \u2016\ud835\udcac u y - Q x y - \ud835\udcac u x + Q x x\u2016 := by\n    convert exp_sub_one_le (- \ud835\udcac u y + Q x y + \ud835\udcac u x - Q x x) using 1\n    \u00b7 simp\n    \u00b7 rw [\u2190 norm_neg]; ring_nf\n  have : dist_(p\u209b) (\ud835\udcac u) (Q x) \u2264 2 ^ (s - \u03c3Max t u x \u27e8s, hs\u27e9) * dist_(p') (\ud835\udcac u) (Q x) := by\n    have p\u209b_le_p' : \ud835\udcd8 p\u209b \u2264 \ud835\udcd8 p' := le_of_mem_of_mem s_le xp\u209b.1 xp'.1\n    have sub_ge_0 : t.\u03c3Max u x \u27e8s, hs\u27e9 - s \u2265 0 := by unfold \u03c3Max; linarith [(\u03c3 t u x).le_max' s hs]\n    have : GridStructure.s (\ud835\udcd8 p\u209b) + (\u03c3Max t u x \u27e8s, hs\u27e9 - s) = GridStructure.s (\ud835\udcd8 p') := by\n      simp_rw [\u2190 hp', \u2190 hp\u209b, \ud835\udd30, _root_.s]; ring\n    apply le_trans <| Grid.dist_strictMono_iterate' sub_ge_0 p\u209b_le_p' this\n    gcongr\n    calc  C2_1_2 a ^ (t.\u03c3Max u x \u27e8s, hs\u27e9 - s)\n      _ \u2264 C2_1_2 a ^ (t.\u03c3Max u x \u27e8s, hs\u27e9 - s : \u211d)                     := by norm_cast\n      _ \u2264 (1 / 2 : \u211d) ^ (t.\u03c3Max u x \u27e8s, hs\u27e9 - s : \u211d)                  :=\n        Real.rpow_le_rpow (by rw [C2_1_2]; positivity)\n          ((C2_1_2_le_inv_512 X).trans (by norm_num)) (by norm_cast)\n      _ = 2 ^ (s - \u03c3Max t u x \u27e8s, hs\u27e9)                                := by simp [\u2190 Int.cast_sub]\n  calc \u2016exp (.I * (-\ud835\udcac u y + Q x y + \ud835\udcac u x - Q x x)) - 1\u2016\n    _ \u2264 dist_{x, D ^ s / 2} (\ud835\udcac u) (Q x) :=\n      exp_bound.trans <| oscillation_le_cdist x _ (\ud835\udcac u) (Q x)\n        (mem_ball_comm.mp (mem_Ioo.mp (dist_mem_Ioo_of_Ks_ne_zero hKxy)).2) (mem_ball_self hr)\n    _ \u2264 _ := cdist_mono <| ball_subset_ball (show (D : \u211d) ^ s / 2 \u2264 4 * D ^ s by linarith)\n    _ \u2264 defaultA a * dist_{\ud835\udd20 p\u209b, 2 * D ^ s} (\ud835\udcac u) (Q x) := by\n      have two_mul_two : 2 * (2 * (D : \u211d) ^ s) = 4 * D ^ s := by ring\n      have x_in_ball : dist (\ud835\udd20 p\u209b) x < 2 * (2 * D ^ s) := by\n        rw [two_mul_two, \u2190 hp\u209b]\n        exact mem_ball'.mp <| Grid_subset_ball xp\u209b.1\n      refine le_of_eq_of_le ?_ (cdist_le x_in_ball)\n      rw [two_mul_two]\n    _ \u2264 defaultA a * (defaultA a ^ 3 * dist_(p\u209b) (\ud835\udcac u) (Q x)) := by\n      gcongr\n      convert cdist_le_iterate (div_pos (defaultD_pow_pos a s) four_pos) _ _ _ using 2\n      \u00b7 rw [show 2 ^ 3 * ((D : \u211d) ^ s / 4) = 2 * D ^ s by ring]\n      \u00b7 rw [hp\u209b]\n    _ = (defaultA a) ^ 4 * dist_(p\u209b) (\ud835\udcac u) (Q x) := by ring\n    _ \u2264 (2 ^ a) ^ 4 * (2 ^ (s - t.\u03c3Max u x _) * dist_(p') (\ud835\udcac u) (Q x)) := by norm_cast; gcongr\n    _ \u2264 (2 ^ a) ^ 4 * (2 ^ (s - t.\u03c3Max u x _) * 5) := by gcongr; exact (dist_lt_5 hu p'u xp'.2.1).le\n    _ = 5 * 2 ^ (4 * a) * 2 ^ (s - \u03c3Max t u x \u27e8s, hs\u27e9) := by ring", "proofType": "term", "proofLengthLines": 43, "proofLengthTokens": 2715}}
{"srcContext": "import Carleson.Forest\nimport Carleson.ToMathlib.HardyLittlewood\nimport Carleson.ToMathlib.BoundedCompactSupport\nimport Carleson.ToMathlib.Misc\nimport Carleson.Psi\n\nopen ShortVariables TileStructure\nvariable {X : Type*} {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102} {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X}\n  [MetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] [TileStructure Q D \u03ba S o]\n  {n j j' : \u2115} {t : Forest X n} {u u\u2081 u\u2082 p : \ud835\udd13 X} {x x' : X} {\ud835\udd16 : Set (\ud835\udd13 X)}\n  {f f\u2081 f\u2082 g g\u2081 g\u2082 : X \u2192 \u2102} {I J J' L : Grid X}\nvariable {E' : Type*} [NormedAddCommGroup E'] [NormedSpace \u211d E']\n\nnoncomputable section\n\nopen Set MeasureTheory Metric Function Complex Bornology TileStructure Classical Filter\nopen scoped NNReal ENNReal ComplexConjugate\n\nnamespace TileStructure.Forest\n\n/-! ## Section 7.1 and Lemma 7.1.3 -/\n\nvariable (t) in\n/-- The definition `\u03c3(u, x)` given in Section 7.1.\nWe may assume `u \u2208 t` whenever proving things about this definition. -/\ndef \u03c3 (u : \ud835\udd13 X) (x : X) : Finset \u2124 := .image \ud835\udd30 { p | p \u2208 t u \u2227 x \u2208 E p }\n\nvariable (t) in\nprivate lemma exists_p_of_mem_\u03c3 (u : \ud835\udd13 X) (x : X) {s : \u2124} (hs : s \u2208 t.\u03c3 u x) :\n    \u2203 p \u2208 t.\ud835\udd17 u, x \u2208 E p \u2227 \ud835\udd30 p = s := by\n  have \u27e8p, hp\u27e9 := Finset.mem_image.mp hs\n  simp only [mem_\ud835\udd17, Finset.mem_filter] at hp\n  use p, hp.1.2.1, hp.1.2.2, hp.2\n\n/- \\overline{\u03c3} from the blueprint. -/\nvariable (t) in\ndef \u03c3Max (u : \ud835\udd13 X) (x : X) (h\u03c3 : (t.\u03c3 u x).Nonempty) : \u2124 :=\n  t.\u03c3 u x |>.max' h\u03c3\n\n/- \\underline{\u03c3} from the blueprint. -/\nvariable (t) in\ndef \u03c3Min (u : \ud835\udd13 X) (x : X) (h\u03c3 : (t.\u03c3 u x).Nonempty) : \u2124 :=\n  t.\u03c3 u x |>.min' h\u03c3\n\nvariable (t) in\nprivate lemma \u03c3Max_mem_\u03c3 (u : \ud835\udd13 X) (x : X) (h\u03c3 : (t.\u03c3 u x).Nonempty) : \u03c3Max t u x h\u03c3 \u2208 t.\u03c3 u x :=\n  (t.\u03c3 u x).max'_mem h\u03c3\n\n/-- The definition of `\ud835\udcd9\u2080(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcd9\u2080 (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {J : Grid X | s J = -S \u2228 \u2200 p \u2208 \ud835\udd16, \u00ac(\ud835\udcd8 p : Set X) \u2286 ball (c J) (100 * D ^ (s J + 1))}\n\n/-- The definition of `\ud835\udcd9(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcd9 (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {x | Maximal (\u00b7 \u2208 \ud835\udcd9\u2080 \ud835\udd16) x}\n\nlemma \ud835\udcd9_subset_\ud835\udcd9\u2080 {\ud835\udd16 : Set (\ud835\udd13 X)} : \ud835\udcd9 \ud835\udd16 \u2286 \ud835\udcd9\u2080 \ud835\udd16 := sep_subset ..\n\nlemma pairwiseDisjoint_\ud835\udcd9 : (\ud835\udcd9 \ud835\udd16).PairwiseDisjoint (fun I \u21a6 (I : Set X)) := fun I mI J mJ hn \u21a6 by\n  have : IsAntichain (\u00b7 \u2264 \u00b7) (\ud835\udcd9 \ud835\udd16) := setOf_maximal_antichain _\n  exact (le_or_ge_or_disjoint.resolve_left (this mI mJ hn)).resolve_left (this mJ mI hn.symm)\n\n/-- The definition of `\ud835\udcdb\u2080(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcdb\u2080 (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {L : Grid X | s L = -S \u2228 (\u2203 p \u2208 \ud835\udd16, L \u2264 \ud835\udcd8 p) \u2227 \u2200 p \u2208 \ud835\udd16, \u00ac\ud835\udcd8 p \u2264 L}\n\n/-- The definition of `\ud835\udcdb(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcdb (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {x | Maximal (\u00b7 \u2208 \ud835\udcdb\u2080 \ud835\udd16) x}\n\nlemma \ud835\udcdb_subset_\ud835\udcdb\u2080 {\ud835\udd16 : Set (\ud835\udd13 X)} : \ud835\udcdb \ud835\udd16 \u2286 \ud835\udcdb\u2080 \ud835\udd16 := sep_subset ..\n\nprivate lemma s_le_s_of_mem_\ud835\udcdb {\ud835\udd16 : Set (\ud835\udd13 X)} {L : Grid X} (hL : L \u2208 \ud835\udcdb \ud835\udd16)\n    {p : \ud835\udd13 X} (hp : p \u2208 \ud835\udd16) (hpL : \u00ac Disjoint (\ud835\udcd8 p : Set X) (L : Set X)) : s L \u2264 s (\ud835\udcd8 p) := by\n  simp only [\ud835\udcdb, \ud835\udcdb\u2080, Grid.le_def, not_and, not_le, and_imp] at hL\n  rcases hL.1 with h | h\n  \u00b7 exact h \u25b8 (range_s_subset \u27e8\ud835\udcd8 p, rfl\u27e9).1\n  \u00b7 by_contra!\n    exact lt_asymm this <| h.2 p hp <| (GridStructure.fundamental_dyadic' this.le).resolve_right hpL\n\nprivate lemma subset_of_mem_\ud835\udcdb {\ud835\udd16 : Set (\ud835\udd13 X)} {L : Grid X} (hL : L \u2208 \ud835\udcdb \ud835\udd16) {p : \ud835\udd13 X}\n    (hp : p \u2208 \ud835\udd16) (hpL : \u00ac Disjoint (\ud835\udcd8 p : Set X) (L : Set X)) : (L : Set X) \u2286 (\ud835\udcd8 p : Set X) :=\n  GridStructure.fundamental_dyadic' (s_le_s_of_mem_\ud835\udcdb hL hp hpL) |>.resolve_right fun h \u21a6 hpL h.symm\n\n/-- The projection operator `P_\ud835\udcd2 f(x)`, given above Lemma 7.1.3.\nIn lemmas the `c` will be pairwise disjoint on `C`. -/\ndef approxOnCube (C : Set (Grid X)) (f : X \u2192 E') (x : X) : E' :=\n  \u2211 J \u2208 { p | p \u2208 C }, (J : Set X).indicator (fun _ \u21a6 \u2a0d y in J, f y) x\n\nlemma stronglyMeasurable_approxOnCube (C : Set (Grid X)) (f : X \u2192 E') :\n    StronglyMeasurable (approxOnCube (X := X) (K := K) C f) :=\n  Finset.stronglyMeasurable_sum _ (fun _ _ \u21a6 stronglyMeasurable_const.indicator coeGrid_measurable)\n\nlemma integrable_approxOnCube (C : Set (Grid X)) {f : X \u2192 E'} : Integrable (approxOnCube C f) := by\n  refine integrable_finset_sum _ (fun i hi \u21a6 ?_)\n  constructor\n  \u00b7 exact (aestronglyMeasurable_indicator_iff coeGrid_measurable).mpr aestronglyMeasurable_const\n  \u00b7 simp_rw [hasFiniteIntegral_iff_enorm, enorm_indicator_eq_indicator_enorm]\n    apply lt_of_le_of_lt <| lintegral_indicator_const_le (i : Set X) _\n    exact ENNReal.mul_lt_top ENNReal.coe_lt_top volume_coeGrid_lt_top\n\nlemma approxOnCube_nonneg {C : Set (Grid X)} {f : X \u2192 \u211d} (hf : \u2200 (y : X), f y \u2265 0) {x : X} :\n    approxOnCube C f x \u2265 0 :=\n  Finset.sum_nonneg' (fun _ \u21a6 Set.indicator_nonneg (fun _ _ \u21a6 integral_nonneg hf) _)\n\nlemma approxOnCube_apply {C : Set (Grid X)} (hC : C.PairwiseDisjoint (fun I \u21a6 (I : Set X)))\n    (f : X \u2192 E') {x : X} {J : Grid X} (hJ : J \u2208 C) (xJ : x \u2208 J) :\n    (approxOnCube C f) x = \u2a0d y in J, f y := by\n  rw [approxOnCube, \u2190 Finset.sum_filter_not_add_sum_filter _ (J = \u00b7)]\n  have eq0 : \u2211 i \u2208 Finset.filter (\u00ac J = \u00b7) (Finset.univ.filter (\u00b7 \u2208 C)),\n      (i : Set X).indicator (fun _ \u21a6 \u2a0d y in i, f y) x = 0 := by\n    suffices \u2200 i \u2208 (Finset.univ.filter (\u00b7 \u2208 C)).filter (\u00ac J = \u00b7),\n      (i : Set X).indicator (fun _ \u21a6 \u2a0d y in i, f y) x = 0 by simp [Finset.sum_congr rfl this]\n    intro i hi\n    simp only [Finset.mem_filter, Finset.mem_univ, true_and] at hi\n    apply indicator_of_not_mem <|\n      Set.disjoint_left.mp ((hC.eq_or_disjoint hJ hi.1).resolve_left hi.2) xJ\n  have eq_ave : \u2211 i \u2208 (Finset.univ.filter (\u00b7 \u2208 C)).filter (J = \u00b7),\n      (i : Set X).indicator (fun _ \u21a6 \u2a0d y in i, f y) x = \u2a0d y in J, f y := by\n    suffices (Finset.univ.filter (\u00b7 \u2208 C)).filter (J = \u00b7) = {J} by simp [this, xJ, \u2190 Grid.mem_def]\n    exact subset_antisymm (fun _ h \u21a6 Finset.mem_singleton.mpr (Finset.mem_filter.mp h).2.symm)\n      (fun _ h \u21a6 by simp [Finset.mem_singleton.mp h, hJ])\n  rw [eq0, eq_ave, zero_add]\n\nlemma boundedCompactSupport_approxOnCube {\ud835\udd5c : Type*} [RCLike \ud835\udd5c] {C : Set (Grid X)} {f : X \u2192 \ud835\udd5c} :\n    BoundedCompactSupport (approxOnCube C f) :=\n  BoundedCompactSupport.finset_sum fun J hJ \u21a6\n    BoundedCompactSupport.indicator_of_isBounded_range (by simp) stronglyMeasurable_const\n    ((isBounded_iff_subset_ball (c J)).mpr \u27e84 * D ^ s J, Grid_subset_ball\u27e9) coeGrid_measurable\n\n-- Used in the proof of Lemma 7.1.6\n", "theoremStatement": "lemma integral_eq_lintegral_approxOnCube {C : Set (Grid X)}\n    (hC : C.PairwiseDisjoint fun I \u21a6 (I : Set X)) {J : Grid X} (hJ : J \u2208 C) {f : X \u2192 \u2102}\n    (hf : BoundedCompactSupport f) : ENNReal.ofReal (\u222b y in J, \u2016f y\u2016) =\n    \u222b\u207b (y : X) in J, \u2016approxOnCube C (fun x \u21a6 (\u2016f x\u2016 : \u2102)) y\u2016\u208a ", "theoremName": "TileStructure.Forest.integral_eq_lintegral_approxOnCube", "fileCreated": {"commit": "5e49c3692f6d7344434caa7eea5f412f0ee35863", "date": "2024-09-27"}, "theoremCreated": {"commit": "2457452cfac134a22b7c5ed56b8812e776a34801", "date": "2025-01-14"}, "file": "carleson/Carleson/ForestOperator/PointwiseEstimate.lean", "module": "Carleson.ForestOperator.PointwiseEstimate", "jsonFile": "Carleson.ForestOperator.PointwiseEstimate.jsonl", "positionMetadata": {"lineInFile": 132, "tokenPositionInFile": 6138, "theoremPositionInFile": 20}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 30, "numPremises": 305}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  have nonneg : 0 \u2264\u1da0[ae (volume.restrict J)] fun y \u21a6 \u2016f y\u2016 := Filter.Eventually.of_forall (by simp)\n  have vol_J_ne_zero := (volume_coeGrid_pos (X := X) (i := J) (defaultD_pos' a)).ne.symm\n  have eq : \u222b\u207b (y : X) in J, \u2016approxOnCube C (fun x \u21a6 (\u2016f x\u2016 : \u2102)) y\u2016\u208a =\n      \u222b\u207b y in (J : Set X), ENNReal.ofReal (\u2a0d z in J, \u2016f z\u2016) := by\n    refine setLIntegral_congr_fun coeGrid_measurable (Filter.Eventually.of_forall fun y hy \u21a6 ?_)\n    rw [approxOnCube_apply hC _ hJ hy, ENNReal.ofReal]\n    \u00b7 apply congrArg\n      have : \u2016\u2a0d y in J, (\u2016f y\u2016 : \u2102)\u2016\u208a = \u2016\u2a0d y in J, \u2016f y\u2016\u2016\u208a := by\n        convert congrArg (\u2016\u00b7\u2016\u208a) <| integral_ofReal (f := (\u2016f \u00b7\u2016)) using 1\n        simp [average]\n      exact this \u25b8 (Real.toNNReal_eq_nnnorm_of_nonneg <| integral_nonneg (fun y \u21a6 by simp)).symm\n  rw [ofReal_integral_eq_lintegral_ofReal hf.integrable.norm.restrict nonneg,\n    eq, lintegral_const, average_eq, smul_eq_mul, ENNReal.ofReal_mul, ENNReal.ofReal_inv_of_pos,\n    ENNReal.ofReal_toReal, ofReal_integral_eq_lintegral_ofReal hf.norm.integrable nonneg, mul_comm,\n    \u2190 mul_assoc, Measure.restrict_apply MeasurableSet.univ, univ_inter,\n    ENNReal.mul_inv_cancel vol_J_ne_zero volume_coeGrid_lt_top.ne, one_mul]\n  \u00b7 simp [volume_coeGrid_lt_top.ne]\n  \u00b7 simpa using ENNReal.toReal_pos vol_J_ne_zero volume_coeGrid_lt_top.ne\n  \u00b7 exact inv_nonneg.mpr ENNReal.toReal_nonneg", "proofType": "tactic", "proofLengthLines": 19, "proofLengthTokens": 1345}}
{"srcContext": "/-\nCopyright (c) 2024 James Sundstrom. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: James Sundstrom\n-/\nimport Mathlib.MeasureTheory.Constructions.BorelSpace.Metric\n\n/-!\n# Annulus\n\nIn this file we define an annulus in a pseudometric space `X` to be a set consisting of all `y`\nsuch that `dist x y` lies in an interval between `r` and `R`. An annulus is defined for each type\nof interval (`Ioo`, `Ioc`, etc.) with a parallel naming scheme, except that we do not define annuli\nfor `Iio` and `Ico`, as they would be balls.\n\nWe also define `EAnnulus` similarly using `edist` instead of `dist`.\n\n## Tags\n\nannulus, eannulus\n-/\n\nopen Set Metric ENNReal\n\nvariable {X : Type*} [PseudoMetricSpace X]\n\nnamespace Set\n\nnamespace Annulus\n\ndef oo (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d) := {y | dist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d) := {y | dist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d) := {y | dist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d) := {y | dist x y \u2208 Ici r}\n\nlemma oo_eq {x : X} {r R : \u211d} : oo x r R = ball x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oo, dist_comm, and_comm]\n\nlemma oc_eq {x : X} {r R : \u211d} : oc x r R = closedBall x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oc, dist_comm, and_comm]\n\nlemma co_eq {x : X} {r R : \u211d} : co x r R = ball x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [co, dist_comm, and_comm]\n\nlemma cc_eq {x : X} {r R : \u211d} : cc x r R = closedBall x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [cc, dist_comm, and_comm]\n\nlemma oi_eq {x : X} {r : \u211d} : oi x r = (closedBall x r)\u1d9c := by\n  ext; simp [oi, dist_comm]\n\nlemma ci_eq {x : X} {r : \u211d} : ci x r = (ball x r)\u1d9c := by\n  ext; simp [ci, dist_comm]\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n", "theoremStatement": "@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oc x r R = \u2205 ", "theoremName": "Set.Annulus.oc_eq_empty", "fileCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "theoremCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "file": "carleson/Carleson/ToMathlib/Annulus.lean", "module": "Carleson.ToMathlib.Annulus", "jsonFile": "Carleson.ToMathlib.Annulus.jsonl", "positionMetadata": {"lineInFile": 60, "tokenPositionInFile": 1846, "theoremPositionInFile": 13}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 1, "numPremises": 26}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp [oc, Ioc_eq_empty_of_le h]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 39}}
{"srcContext": "/-\nCopyright (c) 2024 James Sundstrom. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: James Sundstrom\n-/\nimport Mathlib.MeasureTheory.Constructions.BorelSpace.Metric\n\n/-!\n# Annulus\n\nIn this file we define an annulus in a pseudometric space `X` to be a set consisting of all `y`\nsuch that `dist x y` lies in an interval between `r` and `R`. An annulus is defined for each type\nof interval (`Ioo`, `Ioc`, etc.) with a parallel naming scheme, except that we do not define annuli\nfor `Iio` and `Ico`, as they would be balls.\n\nWe also define `EAnnulus` similarly using `edist` instead of `dist`.\n\n## Tags\n\nannulus, eannulus\n-/\n\nopen Set Metric ENNReal\n\nvariable {X : Type*} [PseudoMetricSpace X]\n\nnamespace Set\n\nnamespace Annulus\n\ndef oo (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d) := {y | dist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d) := {y | dist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d) := {y | dist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d) := {y | dist x y \u2208 Ici r}\n\nlemma oo_eq {x : X} {r R : \u211d} : oo x r R = ball x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oo, dist_comm, and_comm]\n\nlemma oc_eq {x : X} {r R : \u211d} : oc x r R = closedBall x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oc, dist_comm, and_comm]\n\nlemma co_eq {x : X} {r R : \u211d} : co x r R = ball x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [co, dist_comm, and_comm]\n\nlemma cc_eq {x : X} {r R : \u211d} : cc x r R = closedBall x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [cc, dist_comm, and_comm]\n\nlemma oi_eq {x : X} {r : \u211d} : oi x r = (closedBall x r)\u1d9c := by\n  ext; simp [oi, dist_comm]\n\nlemma ci_eq {x : X} {r : \u211d} : ci x r = (ball x r)\u1d9c := by\n  ext; simp [ci, dist_comm]\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : co x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma co_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : co x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\nlemma cc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : cc x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma cc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : cc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\n@[simp]\nlemma oc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    oc x r r' \u222a oo x r' R = oo x r R := by\n  ext; simp_rw [oc, oo, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioo_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    oc x r r' \u222a oc x r' R = oc x r R := by\n  ext; simp_rw [oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_co {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a co x r' R = oo x r R := by\n  ext; simp_rw [oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ico_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a cc x r' R = oc x r R := by\n  ext; simp_rw [oo, cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Icc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    cc x r r' \u222a oo x r' R = co x r R := by\n  ext; simp_rw [cc, oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioo_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    cc x r r' \u222a oc x r' R = cc x r R := by\n  ext; simp_rw [cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_co {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a co x r' R = co x r R := by\n  ext; simp_rw [co, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ico_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a cc x r' R = cc x r R := by\n  ext; simp_rw [co, cc, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Icc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : oc x r R \u222a oi x R = oi x r := by\n  ext; simp_rw [oc, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioi_eq_Ioi h]\n\n@[simp]\nlemma oo_union_ci {x : X} {r R : \u211d} (h : r < R) :\n    oo x r R \u222a ci x R = oi x r := by\n  ext; simp_rw [oo, ci, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ici_eq_Ioi h]\n\n@[simp]\nlemma cc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : cc x r R \u222a oi x R = ci x r := by\n  ext; simp_rw [cc, oi, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioi_eq_Ici h]\n\n@[simp]\nlemma co_union_ci {x : X} {r R : \u211d} (h : r \u2264 R) : co x r R \u222a ci x R = ci x r := by\n  ext; simp_rw [co, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ici_eq_Ici h]\n\n\nvariable [MeasurableSpace X] [OpensMeasurableSpace X]\n\n@[measurability]\nlemma measurableSet_oo {x : X} {r R : \u211d} : MeasurableSet (oo x r R) := by\n  rw [oo_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oc {x : X} {r R : \u211d} : MeasurableSet (oc x r R) := by\n rw [oc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_co {x : X} {r R : \u211d} : MeasurableSet (co x r R) := by\n  rw [co_eq]; measurability\n\n@[measurability]\nlemma measurableSet_cc {x : X} {r R : \u211d} : MeasurableSet (cc x r R) := by\n rw [cc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oi {x : X} {r : \u211d} : MeasurableSet (oi x r) := by\n  rw [oi_eq]; measurability\n\n@[measurability]\nlemma measurableSet_ci {x : X} {r : \u211d} : MeasurableSet (ci x r) := by\n  rw [ci_eq]; measurability\n\nend Annulus\n\nnamespace EAnnulus\n\ndef oo (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ici r}\n\n\nlemma oo_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oo x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oo x r R := by\n  simp_rw [oo, Annulus.oo, edist_dist, mem_Ioo, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma oc_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [oc, Annulus.oc, edist_dist, mem_Ioc, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  \u00b7 have R_le_r := (lt_of_lt_of_le (lt_of_not_ge hR) hr).le\n    rw [Annulus.oc_eq_empty R_le_r]\n    refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n    exact not_le_of_gt (lt_of_le_of_lt (ENNReal.ofReal_le_ofReal R_le_r) hy.1) hy.2\n\nlemma co_eq_annulus {x : X} {r R : \u211d} :\n    co x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.co x r R := by\n  simp_rw [co, Annulus.co, edist_dist, mem_Ico, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma cc_eq_annulus {x : X} {r R : \u211d} (h : r > 0 \u2228 R \u2265 0) :\n    cc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.cc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [cc, Annulus.cc, edist_dist, mem_Icc, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  have r0 := h.resolve_right hR\n  have R_lt_r := (lt_of_not_ge hR).trans r0\n  rw [Annulus.cc_eq_empty R_lt_r]\n  refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n  exact not_le_of_gt ((ENNReal.ofReal_lt_ofReal_iff r0).mpr R_lt_r) (hy.1.trans hy.2)\n\nlemma oi_eq_annulus {x : X} {r : \u211d} (hr : r \u2265 0) : oi x (ENNReal.ofReal r) = Annulus.oi x r := by\n  simp_rw [oi, Annulus.oi, edist_dist, mem_Ioi, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr]\n\nlemma ci_eq_annulus {x : X} {r : \u211d} : ci x (ENNReal.ofReal r) = Annulus.ci x r := by\n  simp_rw [ci, Annulus.ci, edist_dist, mem_Ici, ENNReal.ofReal_le_ofReal_iff dist_nonneg]\n\n\nlemma oo_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oo x r R = ball x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oo, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma oc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oc x r R = closedBall x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oc, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma co_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    co x r R = ball x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [co, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma cc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    cc x r R = closedBall x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [cc, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma oi_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : oi x r = (closedBall x r.toReal)\u1d9c := by\n  ext; simp [oi, edist_dist, dist_comm, lt_ofReal_iff_toReal_lt hr.ne]\n\nlemma ci_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : ci x r = (ball x r.toReal)\u1d9c := by\n  ext; simp [ci, edist_dist, dist_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg]\n\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n@[simp]\nlemma cc_top_eq_empty {x : X} {R : \u211d\u22650\u221e} : cc x \u22a4 R = \u2205 :=\n  eq_empty_of_forall_not_mem (fun y hy \u21a6 (edist_ne_top x y) (top_le_iff.mp hy.1))\n\n@[simp]\nlemma oi_eq_empty {x : X} : oi x \u22a4 = \u2205 := by simp [oi, edist_dist]\n\n@[simp]\nlemma ci_eq_empty {x : X} : ci x \u22a4 = \u2205 := by simp [ci, edist_dist]\n\n\nlemma oo_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) :\n    oo x r \u22a4 = (closedBall x r.toReal)\u1d9c := by\n  ext; simpa [oo, edist_dist, dist_comm] using lt_ofReal_iff_toReal_lt hr.ne\n\nlemma oc_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) :\n    oc x r \u22a4 = (closedBall x r.toReal)\u1d9c := by\n  ext; simpa [oc, edist_dist, dist_comm] using lt_ofReal_iff_toReal_lt hr.ne\n\nlemma co_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : co x r \u22a4 = (ball x r.toReal)\u1d9c := by\n  ext; simpa [co, edist_dist, dist_comm] using le_ofReal_iff_toReal_le hr.ne dist_nonneg\n\nlemma cc_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : cc x r \u22a4 = (ball x r.toReal)\u1d9c := by\n  ext; simpa [cc, edist_dist, dist_comm] using le_ofReal_iff_toReal_le hr.ne dist_nonneg\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) : co x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma co_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : co x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\nlemma cc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) : cc x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma cc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : cc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\n@[simp]\nlemma oc_union_oo {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    oc x r r' \u222a oo x r' R = oo x r R := by\n  ext; simp_rw [oc, oo, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioo_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oc {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    oc x r r' \u222a oc x r' R = oc x r R := by\n  ext; simp_rw [oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_co {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a co x r' R = oo x r R := by\n  ext; simp_rw [oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ico_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_cc {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a cc x r' R = oc x r R := by\n  ext; simp_rw [oo, cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Icc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oo {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    cc x r r' \u222a oo x r' R = co x r R := by\n  ext; simp_rw [cc, oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioo_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oc {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    cc x r r' \u222a oc x r' R = cc x r R := by\n  ext; simp_rw [cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_co {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a co x r' R = co x r R := by\n  ext; simp_rw [co, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ico_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_cc {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a cc x r' R = cc x r R := by\n  ext; simp_rw [co, cc, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Icc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oi {x : X} {r R : \u211d\u22650\u221e} (h : r \u2264 R) : oc x r R \u222a oi x R = oi x r := by\n  ext; simp_rw [oc, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioi_eq_Ioi h]\n\n@[simp]\nlemma oo_union_ci {x : X} {r R : \u211d\u22650\u221e} (h : r < R) :\n    oo x r R \u222a ci x R = oi x r := by\n  ext; simp_rw [oo, ci, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ici_eq_Ioi h]\n\n", "theoremStatement": "@[simp]\nlemma cc_union_oi {x : X} {r R : \u211d\u22650\u221e} (h : r \u2264 R) : cc x r R \u222a oi x R = ci x r ", "theoremName": "Set.EAnnulus.cc_union_oi", "fileCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "theoremCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "file": "carleson/Carleson/ToMathlib/Annulus.lean", "module": "Carleson.ToMathlib.Annulus", "jsonFile": "Carleson.ToMathlib.Annulus.jsonl", "positionMetadata": {"lineInFile": 505, "tokenPositionInFile": 20096, "theoremPositionInFile": 121}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 3, "numPremises": 47}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  ext; simp_rw [cc, oi, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioi_eq_Ici h]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 95}}
{"srcContext": "/- This file contains the proof of Lemma 11.1.10 (spectral projection bound).\n   At the moment, its results are not used as the section about truncated Hilbert transforms\n   is still missing.\n   Thus, the result here might not yet have the exact form needed later.\n-/\n\nimport Carleson.Classical.Basic\n\nopen MeasureTheory AddCircle\nopen scoped InnerProductSpace\n\n--TODO: move somewhere else?\nlemma L2norm_sq_eq {T : \u211d} [hT : Fact (0 < T)] (f : Lp \u2102 2 <| @haarAddCircle T hT) :\n    \u2016f\u2016 ^ 2 = \u222b (x : AddCircle T), \u2016f x\u2016 ^ 2 \u2202haarAddCircle := by\n  /- The proof is inspired by parts of the proof of tsum_sq_fourierCoeff. -/\n  rw [@norm_sq_eq_inner \u2102, @L2.inner_def (AddCircle T) \u2102 \u2102 _ _ _ _ _ f f, \u2190 integral_re (L2.integrable_inner f f)]\n  simp only [\u2190 norm_sq_eq_inner]\n\nlemma fourierCoeff_eq_innerProduct {T : \u211d} [hT : Fact (0 < T)] [h2 : Fact (1 \u2264 2)] {f : \u21a5(Lp \u2102 2 haarAddCircle)} {n : \u2124} :\n    fourierCoeff f n = \u27ea@fourierLp T hT 2 h2 n, f\u27eb_\u2102 := by\n  rw [\u2190 coe_fourierBasis, \u2190 fourierBasis_repr]\n  exact HilbertBasis.repr_apply_apply fourierBasis f n\n\n\nnoncomputable section\ndef partialFourierSumLp {T : \u211d} [hT : Fact (0 < T)] (p : ENNReal) [Fact (1 \u2264 p)] (N : \u2115) (f : \u21a5(Lp \u2102 2 (@haarAddCircle T hT))) : Lp \u2102 p (@haarAddCircle T hT) :=\n    \u2211 n \u2208 Finset.Icc (-Int.ofNat N) N, fourierCoeff f n \u2022 fourierLp p n\n\n--TODO: add some lemma relating partialFourierSum and partialFourierSumLp\n\n\nlemma partialFourierSumL2_norm {T : \u211d} [hT : Fact (0 < T)] [h2 : Fact (1 \u2264 (2 : ENNReal))] {f : \u21a5(Lp \u2102 2 haarAddCircle)} {N : \u2115} :\n    \u2016partialFourierSumLp 2 N f\u2016 ^ 2 = \u2211 n \u2208 Finset.Icc (-Int.ofNat N) N, \u2016@fourierCoeff T hT _ _ _ f n\u2016 ^ 2 := by\n  calc \u2016partialFourierSumLp 2 N f\u2016 ^ 2\n    _ = \u2016partialFourierSumLp 2 N f\u2016 ^ (2 : \u211d) := by\n      rw [\u2190 Real.rpow_natCast]; rfl\n    _ = \u2016fourierBasis.repr (partialFourierSumLp 2 N f)\u2016 ^ (2 : \u211d) := by\n      rw [fourierBasis.repr.norm_map (partialFourierSumLp 2 N f)]\n    _ = \u2016\u2211 n \u2208 Finset.Icc (-Int.ofNat N) N, fourierCoeff f n \u2022 (fourierBasis.repr (@fourierLp T hT 2 h2 n))\u2016 ^ (2 : \u211d) := by\n      rw [partialFourierSumLp, map_sum]\n      simp_rw [LinearMapClass.map_smul]\n    _ = \u2211 n \u2208 Finset.Icc (-Int.ofNat N) N, \u2016fourierCoeff f n\u2016 ^ (2 : \u211d) := by\n      rw [\u2190 coe_fourierBasis]\n      simp only [LinearIsometryEquiv.apply_symm_apply, lp.coeFn_smul, Pi.smul_apply, \u2190 lp.single_smul]\n      have : 2 = (2 : ENNReal).toReal := by simp\n      rw [this, \u2190 lp.norm_sum_single (by simp), \u2190 this]\n      congr 2\n      refine Finset.sum_congr (by simp) fun n \u21a6 ?_\n      simp only [smul_eq_mul, mul_one]\n      congr!\n    _ = \u2211 n \u2208 Finset.Icc (-Int.ofNat N) N, \u2016fourierCoeff f n\u2016 ^ 2 := by\n      simp_rw [\u2190 Real.rpow_natCast]; rfl\n\nlemma spectral_projection_bound_sq {T : \u211d} [hT : Fact (0 < T)] (N : \u2115) (f : Lp \u2102 2 <| @haarAddCircle T hT) :\n    \u2016partialFourierSumLp 2 N f\u2016 ^ 2 \u2264 \u2016f\u2016 ^ 2 := by\n  rw [partialFourierSumL2_norm]\n  simp_rw [fourierCoeff_eq_innerProduct]\n  exact orthonormal_fourier.sum_inner_products_le _\n\nlemma spectral_projection_bound_sq_integral {N : \u2115} {T : \u211d} [hT : Fact (0 < T)] (f : Lp \u2102 2 <| @haarAddCircle T hT) :\n    \u222b t : AddCircle T, \u2016partialFourierSumLp 2 N f t\u2016 ^ 2 \u2202haarAddCircle \u2264 \u222b t : AddCircle T, \u2016f t\u2016 ^ 2 \u2202haarAddCircle := by\n  rw [\u2190 L2norm_sq_eq, \u2190 L2norm_sq_eq]\n  exact spectral_projection_bound_sq _ _\n\n", "theoremStatement": "lemma spectral_projection_bound_lp {N : \u2115} {T : \u211d} [hT : Fact (0 < T)] (f : Lp \u2102 2 <| @haarAddCircle T hT) :\n    \u2016partialFourierSumLp 2 N f\u2016 \u2264 \u2016f\u2016 ", "theoremName": "spectral_projection_bound_lp", "fileCreated": {"commit": "74b37f80e34d12aec7b7ef8e3df940595b31825c", "date": "2024-07-25"}, "theoremCreated": {"commit": "068d8329dd78e1232054702f7bfdf1f8123a656a", "date": "2025-01-23"}, "file": "carleson/Carleson/Classical/SpectralProjectionBound.lean", "module": "Carleson.Classical.SpectralProjectionBound", "jsonFile": "Carleson.Classical.SpectralProjectionBound.jsonl", "positionMetadata": {"lineInFile": 65, "tokenPositionInFile": 3257, "theoremPositionInFile": 6}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 82}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [\u2190 abs_norm, \u2190 abs_norm f, \u2190 sq_le_sq]\n  exact spectral_projection_bound_sq _ _", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 90}}
{"srcContext": "/-\nCopyright (c) 2024 James Sundstrom. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: James Sundstrom\n-/\nimport Mathlib.MeasureTheory.Constructions.BorelSpace.Metric\n\n/-!\n# Annulus\n\nIn this file we define an annulus in a pseudometric space `X` to be a set consisting of all `y`\nsuch that `dist x y` lies in an interval between `r` and `R`. An annulus is defined for each type\nof interval (`Ioo`, `Ioc`, etc.) with a parallel naming scheme, except that we do not define annuli\nfor `Iio` and `Ico`, as they would be balls.\n\nWe also define `EAnnulus` similarly using `edist` instead of `dist`.\n\n## Tags\n\nannulus, eannulus\n-/\n\nopen Set Metric ENNReal\n\nvariable {X : Type*} [PseudoMetricSpace X]\n\nnamespace Set\n\nnamespace Annulus\n\ndef oo (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d) := {y | dist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d) := {y | dist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d) := {y | dist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d) := {y | dist x y \u2208 Ici r}\n\nlemma oo_eq {x : X} {r R : \u211d} : oo x r R = ball x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oo, dist_comm, and_comm]\n\nlemma oc_eq {x : X} {r R : \u211d} : oc x r R = closedBall x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oc, dist_comm, and_comm]\n\nlemma co_eq {x : X} {r R : \u211d} : co x r R = ball x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [co, dist_comm, and_comm]\n\nlemma cc_eq {x : X} {r R : \u211d} : cc x r R = closedBall x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [cc, dist_comm, and_comm]\n\nlemma oi_eq {x : X} {r : \u211d} : oi x r = (closedBall x r)\u1d9c := by\n  ext; simp [oi, dist_comm]\n\nlemma ci_eq {x : X} {r : \u211d} : ci x r = (ball x r)\u1d9c := by\n  ext; simp [ci, dist_comm]\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : co x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma co_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : co x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\nlemma cc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : cc x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma cc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : cc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\n@[simp]\nlemma oc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    oc x r r' \u222a oo x r' R = oo x r R := by\n  ext; simp_rw [oc, oo, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioo_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    oc x r r' \u222a oc x r' R = oc x r R := by\n  ext; simp_rw [oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_co {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a co x r' R = oo x r R := by\n  ext; simp_rw [oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ico_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a cc x r' R = oc x r R := by\n  ext; simp_rw [oo, cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Icc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    cc x r r' \u222a oo x r' R = co x r R := by\n  ext; simp_rw [cc, oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioo_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    cc x r r' \u222a oc x r' R = cc x r R := by\n  ext; simp_rw [cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_co {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a co x r' R = co x r R := by\n  ext; simp_rw [co, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ico_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a cc x r' R = cc x r R := by\n  ext; simp_rw [co, cc, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Icc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : oc x r R \u222a oi x R = oi x r := by\n  ext; simp_rw [oc, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioi_eq_Ioi h]\n\n@[simp]\nlemma oo_union_ci {x : X} {r R : \u211d} (h : r < R) :\n    oo x r R \u222a ci x R = oi x r := by\n  ext; simp_rw [oo, ci, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ici_eq_Ioi h]\n\n@[simp]\nlemma cc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : cc x r R \u222a oi x R = ci x r := by\n  ext; simp_rw [cc, oi, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioi_eq_Ici h]\n\n@[simp]\nlemma co_union_ci {x : X} {r R : \u211d} (h : r \u2264 R) : co x r R \u222a ci x R = ci x r := by\n  ext; simp_rw [co, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ici_eq_Ici h]\n\n\nvariable [MeasurableSpace X] [OpensMeasurableSpace X]\n\n@[measurability]\nlemma measurableSet_oo {x : X} {r R : \u211d} : MeasurableSet (oo x r R) := by\n  rw [oo_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oc {x : X} {r R : \u211d} : MeasurableSet (oc x r R) := by\n rw [oc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_co {x : X} {r R : \u211d} : MeasurableSet (co x r R) := by\n  rw [co_eq]; measurability\n\n@[measurability]\nlemma measurableSet_cc {x : X} {r R : \u211d} : MeasurableSet (cc x r R) := by\n rw [cc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oi {x : X} {r : \u211d} : MeasurableSet (oi x r) := by\n  rw [oi_eq]; measurability\n\n@[measurability]\nlemma measurableSet_ci {x : X} {r : \u211d} : MeasurableSet (ci x r) := by\n  rw [ci_eq]; measurability\n\nend Annulus\n\nnamespace EAnnulus\n\ndef oo (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ici r}\n\n\nlemma oo_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oo x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oo x r R := by\n  simp_rw [oo, Annulus.oo, edist_dist, mem_Ioo, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma oc_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [oc, Annulus.oc, edist_dist, mem_Ioc, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  \u00b7 have R_le_r := (lt_of_lt_of_le (lt_of_not_ge hR) hr).le\n    rw [Annulus.oc_eq_empty R_le_r]\n    refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n    exact not_le_of_gt (lt_of_le_of_lt (ENNReal.ofReal_le_ofReal R_le_r) hy.1) hy.2\n\nlemma co_eq_annulus {x : X} {r R : \u211d} :\n    co x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.co x r R := by\n  simp_rw [co, Annulus.co, edist_dist, mem_Ico, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma cc_eq_annulus {x : X} {r R : \u211d} (h : r > 0 \u2228 R \u2265 0) :\n    cc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.cc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [cc, Annulus.cc, edist_dist, mem_Icc, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  have r0 := h.resolve_right hR\n  have R_lt_r := (lt_of_not_ge hR).trans r0\n  rw [Annulus.cc_eq_empty R_lt_r]\n  refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n  exact not_le_of_gt ((ENNReal.ofReal_lt_ofReal_iff r0).mpr R_lt_r) (hy.1.trans hy.2)\n\nlemma oi_eq_annulus {x : X} {r : \u211d} (hr : r \u2265 0) : oi x (ENNReal.ofReal r) = Annulus.oi x r := by\n  simp_rw [oi, Annulus.oi, edist_dist, mem_Ioi, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr]\n\nlemma ci_eq_annulus {x : X} {r : \u211d} : ci x (ENNReal.ofReal r) = Annulus.ci x r := by\n  simp_rw [ci, Annulus.ci, edist_dist, mem_Ici, ENNReal.ofReal_le_ofReal_iff dist_nonneg]\n\n\nlemma oo_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oo x r R = ball x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oo, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma oc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oc x r R = closedBall x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oc, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma co_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    co x r R = ball x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [co, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma cc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    cc x r R = closedBall x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [cc, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma oi_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : oi x r = (closedBall x r.toReal)\u1d9c := by\n  ext; simp [oi, edist_dist, dist_comm, lt_ofReal_iff_toReal_lt hr.ne]\n\nlemma ci_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : ci x r = (ball x r.toReal)\u1d9c := by\n  ext; simp [ci, edist_dist, dist_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg]\n\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n@[simp]\nlemma cc_top_eq_empty {x : X} {R : \u211d\u22650\u221e} : cc x \u22a4 R = \u2205 :=\n  eq_empty_of_forall_not_mem (fun y hy \u21a6 (edist_ne_top x y) (top_le_iff.mp hy.1))\n\n@[simp]\nlemma oi_eq_empty {x : X} : oi x \u22a4 = \u2205 := by simp [oi, edist_dist]\n\n@[simp]\nlemma ci_eq_empty {x : X} : ci x \u22a4 = \u2205 := by simp [ci, edist_dist]\n\n\nlemma oo_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) :\n    oo x r \u22a4 = (closedBall x r.toReal)\u1d9c := by\n  ext; simpa [oo, edist_dist, dist_comm] using lt_ofReal_iff_toReal_lt hr.ne\n\nlemma oc_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) :\n    oc x r \u22a4 = (closedBall x r.toReal)\u1d9c := by\n  ext; simpa [oc, edist_dist, dist_comm] using lt_ofReal_iff_toReal_lt hr.ne\n\nlemma co_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : co x r \u22a4 = (ball x r.toReal)\u1d9c := by\n  ext; simpa [co, edist_dist, dist_comm] using le_ofReal_iff_toReal_le hr.ne dist_nonneg\n\nlemma cc_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : cc x r \u22a4 = (ball x r.toReal)\u1d9c := by\n  ext; simpa [cc, edist_dist, dist_comm] using le_ofReal_iff_toReal_le hr.ne dist_nonneg\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) : co x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma co_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : co x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\nlemma cc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) : cc x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma cc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : cc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\n@[simp]\nlemma oc_union_oo {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    oc x r r' \u222a oo x r' R = oo x r R := by\n  ext; simp_rw [oc, oo, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioo_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oc {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    oc x r r' \u222a oc x r' R = oc x r R := by\n  ext; simp_rw [oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_co {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a co x r' R = oo x r R := by\n  ext; simp_rw [oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ico_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_cc {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a cc x r' R = oc x r R := by\n  ext; simp_rw [oo, cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Icc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oo {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    cc x r r' \u222a oo x r' R = co x r R := by\n  ext; simp_rw [cc, oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioo_eq_Ico h\u2081 h\u2082]\n\n", "theoremStatement": "@[simp]\nlemma cc_union_oc {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    cc x r r' \u222a oc x r' R = cc x r R ", "theoremName": "Set.EAnnulus.cc_union_oc", "fileCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "theoremCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "file": "carleson/Carleson/ToMathlib/Annulus.lean", "module": "Carleson.ToMathlib.Annulus", "jsonFile": "Carleson.ToMathlib.Annulus.jsonl", "positionMetadata": {"lineInFile": 481, "tokenPositionInFile": 19088, "theoremPositionInFile": 116}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 45}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  ext; simp_rw [cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioc_eq_Icc h\u2081 h\u2082]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 95}}
{"srcContext": "/-\nCopyright (c) 2024 James Sundstrom. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: James Sundstrom\n-/\nimport Mathlib.MeasureTheory.Constructions.BorelSpace.Metric\n\n/-!\n# Annulus\n\nIn this file we define an annulus in a pseudometric space `X` to be a set consisting of all `y`\nsuch that `dist x y` lies in an interval between `r` and `R`. An annulus is defined for each type\nof interval (`Ioo`, `Ioc`, etc.) with a parallel naming scheme, except that we do not define annuli\nfor `Iio` and `Ico`, as they would be balls.\n\nWe also define `EAnnulus` similarly using `edist` instead of `dist`.\n\n## Tags\n\nannulus, eannulus\n-/\n\nopen Set Metric ENNReal\n\nvariable {X : Type*} [PseudoMetricSpace X]\n\nnamespace Set\n\nnamespace Annulus\n\ndef oo (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d) := {y | dist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d) := {y | dist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d) := {y | dist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d) := {y | dist x y \u2208 Ici r}\n\nlemma oo_eq {x : X} {r R : \u211d} : oo x r R = ball x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oo, dist_comm, and_comm]\n\nlemma oc_eq {x : X} {r R : \u211d} : oc x r R = closedBall x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oc, dist_comm, and_comm]\n\nlemma co_eq {x : X} {r R : \u211d} : co x r R = ball x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [co, dist_comm, and_comm]\n\nlemma cc_eq {x : X} {r R : \u211d} : cc x r R = closedBall x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [cc, dist_comm, and_comm]\n\nlemma oi_eq {x : X} {r : \u211d} : oi x r = (closedBall x r)\u1d9c := by\n  ext; simp [oi, dist_comm]\n\nlemma ci_eq {x : X} {r : \u211d} : ci x r = (ball x r)\u1d9c := by\n  ext; simp [ci, dist_comm]\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\n", "theoremStatement": "lemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 ", "theoremName": "Set.Annulus.oc_subset_oo", "fileCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "theoremCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "file": "carleson/Carleson/ToMathlib/Annulus.lean", "module": "Carleson.ToMathlib.Annulus", "jsonFile": "Carleson.ToMathlib.Annulus.jsonl", "positionMetadata": {"lineInFile": 95, "tokenPositionInFile": 3111, "theoremPositionInFile": 22}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 21}, "proofMetadata": {"hasProof": true, "proof": ":=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 70}}
{"srcContext": "import Carleson.Defs\nimport Mathlib.Algebra.Lie.OfAssociative\nimport Mathlib.Topology.EMetricSpace.Paracompact\n\nopen MeasureTheory Measure NNReal Metric Set TopologicalSpace Function DoublingMeasure Bornology\nopen scoped ENNReal\nnoncomputable section\n\n/-! The function `\u03c8` -/\n\nsection D\nvariable {D : \u2115} {x : \u211d} {s : \u2124} (hD : 1 < (D : \u211d))\n\nopen Real\n\nsection -- We record here some trivial inequalities that are used repeatedly below.\nprivate lemma fourD0' (hD : 1 \u2264 D) : 0 < (4 * D : \u211d) := by positivity\nprivate lemma four_x0 {x : \u211d} (hx : 0 < x) : 0 < 4 * x := mul_pos four_pos hx\ninclude hD\nprivate lemma D0 : 0 < (D : \u211d) := one_pos.trans hD\nprivate lemma D2 : 2 \u2264 (D : \u211d) := by exact_mod_cast hD\nprivate lemma twoD0 : 0 < (2 * D : \u211d) := by linarith\nprivate lemma fourD0 : 0 < (4 * D : \u211d) := by linarith\nprivate lemma D_pow0 (r : \u211d) : 0 < (D : \u211d) ^ r := by positivity\nprivate lemma D_pow0' (r : \u2124) : 0 < (D : \u211d) ^ r := by positivity\nprivate lemma cDx0 {c x : \u211d} (hc : c > 0) (hx : 0 < x) : c * D * x > 0 := by positivity\nend\n\ndef \u03c8 (D : \u2115) (x : \u211d) : \u211d :=\n  max 0 <| min 1 <| min (4 * D * x - 1) (2 - 4 * x)\n\nset_option hygiene false\nscoped[ShortVariables] notation \"\u03c8\" => \u03c8 (defaultD a)\n\nlemma zero_le_\u03c8 (D : \u2115) (x : \u211d) : 0 \u2264 \u03c8 D x :=\n  le_max_left 0 _\n\nlemma \u03c8_le_one (D : \u2115) (x : \u211d) : \u03c8 D x \u2264 1 :=\n  max_le (one_pos.le) (min_le_left 1 _)\n\nlemma abs_\u03c8_le_one (D : \u2115) (x : \u211d) : |\u03c8 D x| \u2264 1 :=\n  abs_le.2 \u27e8by linarith [zero_le_\u03c8 D x], \u03c8_le_one D x\u27e9\n\n---------------------------------------------\n/- `\u03c8_formula\u2080` through `\u03c8_formula\u2084` establish the piecewise formula for `\u03c8`. -/\n\nlemma \u03c8_formula\u2080 {x : \u211d} (hx : x \u2264 1 / (4 * D : \u211d)) : \u03c8 D x = 0 := by\n  by_cases hD : D = 0\n  \u00b7 simp [\u03c8, hD]\n  \u00b7 exact max_eq_left <| (min_le_right 1 _).trans <| (min_le_left _ _).trans <|\n      tsub_nonpos.2 <| (le_div_iff\u2080' (mul_pos four_pos\n      (by exact_mod_cast Nat.zero_lt_of_ne_zero hD))).1 hx\n\ninclude hD in\nlemma \u03c8_formula\u2081 {x : \u211d} (hx : 1 / (4 * D) \u2264 x \u2227 x \u2264 1 / (2 * D)) :\n    \u03c8 D x = 4 * D * x - 1 := by\n  have : x \u2265 0 := le_trans (one_div_nonneg.2 (fourD0 hD).le) hx.1\n  have hx1 := (div_le_iff\u2080' (fourD0 hD)).1 hx.1\n  have hx2 := (le_div_iff\u2080' (twoD0 hD)).1 hx.2\n  have ineq\u2080 : 4 * D * x - 1 \u2264 2 - 4 * x := by\n    suffices (2 * D + 2 * D + 4) * x \u2264 3 by linarith\n    exact le_trans (by gcongr; linarith [D2 hD]) (by linarith: (2 * D + 2 * D + 2 * D) * x \u2264 3)\n  have ineq\u2081 : 4 * D * x - 1 \u2264 1 := by linarith\n  have ineq\u2082 : 0 \u2264 4 * D * x - 1 := by linarith\n  rw [\u03c8, min_eq_left ineq\u2080, min_eq_right ineq\u2081, max_eq_right ineq\u2082]\n\ninclude hD in\nlemma \u03c8_formula\u2082 {x : \u211d} (hx : 1 / (2 * D) \u2264 x \u2227 x \u2264 1 / 4) : \u03c8 D x = 1 := by\n  unfold \u03c8\n  suffices min 1 (min (4 * D * x - 1) (2 - 4 * x)) = 1 from this.symm \u25b8 max_eq_right_of_lt one_pos\n  have := (div_le_iff\u2080' (twoD0 hD)).1 hx.1\n  exact min_eq_left (le_min (by linarith) (by linarith))\n\ninclude hD in\nlemma \u03c8_formula\u2083 {x : \u211d} (hx : 1 / 4 \u2264 x \u2227 x \u2264 1 / 2) : \u03c8 D x = 2 - 4 * x := by\n  have ineq\u2080 : 2 - 4 * x \u2264 4 * D * x - 1 := by nlinarith [D2 hD]\n  have ineq\u2081 : 2 - 4 * x \u2264 1 := by linarith\n  have ineq\u2082 : 2 - 4 * x \u2265 0 := by linarith\n  rw [\u03c8, min_eq_right ineq\u2080, min_eq_right ineq\u2081, max_eq_right ineq\u2082]\n\nlemma \u03c8_formula\u2084 {x : \u211d} (hx : x \u2265 1 / 2) : \u03c8 D x = 0 :=\n  max_eq_left <| (min_le_right _ _).trans <| (min_le_right _ _).trans (by linarith)\n---------------------------------------------\n\nlemma psi_zero : \u03c8 D 0 = 0 := \u03c8_formula\u2080 (by positivity)\n\nlemma continuous_\u03c8 : Continuous (\u03c8 D) := by\n  unfold \u03c8; fun_prop\n\ninclude hD in\nlemma support_\u03c8 : support (\u03c8 D) = Ioo (4 * D : \u211d)\u207b\u00b9 2\u207b\u00b9 := by\n  ext x\n  by_cases hx\u2080 : x \u2264 1 / (4 * D)\n  \u00b7 suffices x \u2264 (D : \u211d)\u207b\u00b9 * 4\u207b\u00b9 by simp [\u03c8_formula\u2080 hx\u2080, this]\n    rwa [one_div, mul_inv_rev] at hx\u2080\n  push_neg at hx\u2080\n  have hx\u2080_inv : (D : \u211d)\u207b\u00b9 * 4\u207b\u00b9 < x := by convert hx\u2080 using 1; simp\n  have ne\u2080 : 4 * D * x - 1 \u2260 0 := ne_of_gt (by rwa [sub_pos, \u2190 div_lt_iff\u2080' (fourD0 hD)])\n  by_cases hx\u2081 : x \u2264 1 / (2 * D)\n  \u00b7 suffices (D : \u211d)\u207b\u00b9 * 4\u207b\u00b9 < x \u2227 x < 2\u207b\u00b9 by simpa [ne\u2080, \u03c8_formula\u2081 hD \u27e8hx\u2080.le, hx\u2081\u27e9]\n    exact \u27e8hx\u2080_inv, lt_of_le_of_lt hx\u2081 (by simp [_root_.inv_lt_one_iff\u2080, hD])\u27e9\n  push_neg at hx\u2081\n  by_cases hx\u2082 : x \u2264 1 / 4\n  \u00b7 simpa [\u03c8_formula\u2082 hD \u27e8hx\u2081.le, hx\u2082\u27e9, hx\u2080_inv] using lt_of_le_of_lt hx\u2082 (by norm_num)\n  push_neg at hx\u2082\n  by_cases hx\u2083 : x < 1 / 2\n  \u00b7 have : \u00ac 2 - 4 * x = 0 := by linarith\n    simpa [\u03c8_formula\u2083 hD \u27e8hx\u2082.le, hx\u2083.le\u27e9, hx\u2080, hx\u2083, \u2190 one_div]\n  \u00b7 rw [mem_support, \u03c8_formula\u2084 (not_lt.1 hx\u2083), ne_self_iff_false, false_iff, mem_Ioo, not_and,\n      inv_eq_one_div 2]\n    exact fun _ \u21a6 hx\u2083\n\nlemma lipschitzWith_\u03c8 (hD : 1 \u2264 D) : LipschitzWith (4 * D) (\u03c8 D) := by\n  have max_eq_4D : max 0 (4 * D : \u211d\u22650) = 4 * D := max_eq_right (fourD0' hD).le\n  have max_eq_4D' : max (4 * D) 4 = 4 * D := by apply max_eq_left; linarith\n  suffices LipschitzWith (4 * D) (fun (x : \u211d) \u21a6 min 1 <| min (4 * D * x - 1) (2 - 4 * x)) from\n    max_eq_4D \u25b8 (LipschitzWith.const 0).max this\n  suffices LipschitzWith (4 * D) (fun (x : \u211d) \u21a6 min (4 * D * x - 1) (2 - 4 * x)) from\n    max_eq_4D \u25b8 (LipschitzWith.const 1).min this\n  have lw1 : LipschitzWith (4 * D) (fun (x : \u211d) \u21a6 4 * D * x - 1) := by\n    refine LipschitzWith.of_le_add_mul (4 * D) (fun x y \u21a6 ?_)\n    suffices 4 * D * (x - y) \u2264 4 * D * dist x y by norm_cast at this \u22a2; linarith\n    exact (mul_le_mul_left (fourD0' hD)).2 <| sub_le_dist x y\n  have lw2 : LipschitzWith 4 (fun (x : \u211d) \u21a6 2 - 4 * x) := by\n    refine LipschitzWith.of_le_add_mul 4 (fun x y \u21a6 ?_)\n    suffices 4 * (y - x) \u2264 4 * dist x y by norm_cast at this \u22a2; linarith\n    gcongr\n    exact dist_comm x y \u25b8 sub_le_dist y x\n  have := lw1.min lw2\n  norm_cast at this \u22a2\n  convert max_eq_4D' \u25b8 this\n\n-- Alternate version of `lipschitzWith_\u03c8` that avoids using `ENNReal`.\nlemma lipschitzWith_\u03c8' (hD : 1 \u2264 D) (a b : \u211d) : \u2016\u03c8 D a - \u03c8 D b\u2016 \u2264 4 * D * dist a b := by\n  have lipschitz := lipschitzWith_\u03c8 hD a b\n  rw [edist_dist, edist_dist, dist_eq_norm_sub] at lipschitz\n  norm_cast at lipschitz\n  rw [\u2190 ENNReal.ofReal_natCast, \u2190 ENNReal.ofReal_mul (by exact_mod_cast (fourD0' hD).le),\n    \u2190 ENNReal.toReal_le_toReal ENNReal.ofReal_ne_top ENNReal.ofReal_ne_top] at lipschitz\n  repeat rw [ENNReal.toReal_ofReal (by positivity)] at lipschitz\n  norm_cast\n\n/- the one or two numbers `s` where `\u03c8 (D ^ (-s) * x)` is possibly nonzero -/\nvariable (D) in def nonzeroS (x : \u211d) : Finset \u2124 :=\n  Finset.Icc \u230a(1 + logb D (2 * x))\u230b \u2308logb D (4 * x)\u2309\n\n---------------------------------------------\n\nsection include_hD\n\n/- The goal of the next several lemmas is to prove `sum_\u03c8`, which says that\n`\u2211 s \u2208 nonzeroS D x, \u03c8 D (D ^ (-s) * x) = 1`.\n\nThe first four lemmas prove some properties of the endpoints of `nonzeroS D x`, and in particular\nshow that `nonzeroS D x` has either 1 or 2 elements. The next two lemmas prove `sum_\u03c8` in the\n1-element and 2-element cases, respectively, and then `sum_\u03c8` follows immediately.\n-/\n\ninclude hD\n\nprivate lemma le_div_ceil_mul (hx : 0 < x) : 1 / (4 * D) \u2264 D ^ (-\u2308logb D (4 * x)\u2309) * x := by\n  rw [\u2190 div_le_iff\u2080 hx, div_div, \u2190 rpow_logb (D0 hD) (ne_of_gt hD) (cDx0 hD four_pos hx),\n    \u2190 inv_eq_one_div, (by norm_cast : (D : \u211d) ^ (-\u2308logb D (4 * x)\u2309) = D ^ (-\u2308logb D (4 * x)\u2309 : \u211d)),\n    \u2190 rpow_neg (D0 hD).le, rpow_le_rpow_left_iff hD, neg_le_neg_iff]\n  apply le_of_le_of_eq <| calc\n    (\u2308logb D (4 * x)\u2309 : \u211d) \u2264 \u230alogb D (4 * x)\u230b + 1 := by exact_mod_cast Int.ceil_le_floor_add_one _\n    _                     \u2264 logb D (4 * x) + 1   := by gcongr; exact Int.floor_le (logb D (4 * x))\n  rw [\u2190 logb_self_eq_one hD, \u2190 logb_mul (mul_pos four_pos hx).ne.symm (ne_of_gt (D0 hD)),\n    mul_assoc, mul_assoc, mul_comm _ x]\n\nprivate lemma one_add_logb (hx : x > 0) : 1 + logb D (2 * x) = logb D (2 * D * x) := by\n  rw [\u2190 logb_self_eq_one hD, \u2190 logb_mul (D0 hD).ne.symm (mul_pos two_pos hx).ne.symm,\n    \u2190 mul_assoc, mul_comm (D : \u211d) 2]\n\n-- If `D ^ (-\u2308logb D (4 * x)\u2309) \u2265 1 / (2 * D * x)`, then the endpoints of `nonzeroS x` are equal.\nprivate lemma eq_endpoints (hx : 0 < x) (h : D ^ (-\u2308logb D (4 * x)\u2309) \u2265 1 / (2 * D * x)) :\n    \u230a(1 + logb D (2 * x))\u230b = \u2308logb D (4 * x)\u2309 := by\n  rw [Int.floor_eq_iff, one_add_logb hD hx]\n  constructor\n  \u00b7 rw [\u2190 rpow_le_rpow_left_iff hD, \u2190 inv_le_inv\u2080 (D_pow0 hD _) (D_pow0 hD _),\n      rpow_logb (D0 hD) (ne_of_gt hD) (cDx0 hD two_pos hx),\n      \u2190 rpow_neg (D0 hD).le, inv_eq_one_div]\n    exact_mod_cast h.le\n  \u00b7 have : logb D (2 * D * x) < logb D (4 * D * x) := by\n      refine (strictMonoOn_logb hD) ?_ ?_ (by linarith [(cDx0 hD two_pos hx)]) <;>\n        exact mem_Ioi.2 (cDx0 hD (by norm_num) hx)\n    apply lt_of_lt_of_le this\n    rw [mul_comm, \u2190 mul_assoc, mul_comm x 4, logb_mul (mul_pos four_pos hx).ne.symm (D0 hD).ne.symm,\n      logb_self_eq_one hD, add_le_add_iff_right, mul_comm]\n    exact Int.le_ceil _\n\n-- If `D ^ (-\u2308logb D (4 * x)\u2309) < 1 / (2 * D * x)`, then the endpoints of `nonzeroS x` differ by 1.\nprivate lemma endpoint_sub_one (hx : 0 < x) (h : D ^ (-\u2308logb D (4 * x)\u2309) < 1 / (2 * D * x)) :\n    \u230a1 + logb D (2 * x)\u230b = \u2308logb D (4 * x)\u2309 - 1 := by\n  rw [one_add_logb hD hx]\n  apply le_antisymm\n  \u00b7 rw [\u2190 inv_eq_one_div, zpow_neg, inv_lt_inv\u2080 (D_pow0' hD _) (cDx0 hD two_pos hx)] at h\n    rw [Int.floor_le_sub_one_iff, \u2190 rpow_lt_rpow_left_iff hD,\n      rpow_logb (D0 hD) (ne_of_gt hD) (cDx0 hD two_pos hx)]\n    exact_mod_cast h\n  \u00b7 apply sub_le_iff_le_add.2 \u2218 Int.ceil_le.2\n    suffices logb D (4 * x) \u2264 logb D (2 * D * x) by\n      exact_mod_cast (lt_of_le_of_lt this (Int.lt_floor_add_one _)).le\n    have : 4 * x \u2264 2 * D * x := (mul_le_mul_right hx).2 (by linarith [D2 hD])\n    refine (strictMonoOn_logb hD).monotoneOn ?_ ?_ this <;> exact mem_Ioi.2 (by positivity)\n\n-- Special case of `sum_\u03c8`, for the case where `nonzeroS D x` has one element.\nprivate lemma sum_\u03c8\u2081 (hx : 0 < x) (h : D ^ (-\u2308logb D (4 * x)\u2309) \u2265 1 / (2 * D * x)) :\n    \u2211 s \u2208 nonzeroS D x, \u03c8 D (D ^ (-s) * x) = 1 := by\n  rw [nonzeroS, eq_endpoints hD hx h, Finset.Icc_self, Finset.sum_singleton]\n  refine \u03c8_formula\u2082 hD \u27e8le_of_eq_of_le (by field_simp) ((mul_le_mul_right hx).2 h), ?_\u27e9\n  calc\n    D ^ (-\u2308logb D (4 * x)\u2309) * x\n      = D ^ (-\u2308logb D (4 * x)\u2309 : \u211d) * x := by norm_cast\n    _ \u2264 D ^ (-logb D (4 * x)) * x      := by\n      gcongr\n      \u00b7 exact hD.le\n      \u00b7 exact Int.le_ceil (logb D (4 * x))\n    _ = 1 / (4 * x) * x                := by\n      rw [rpow_neg (D0 hD).le, inv_eq_one_div, rpow_logb (D0 hD) hD.ne.symm (by linarith)]\n    _ = 1 / 4                          := by field_simp; exact mul_comm x 4\n\n-- Special case of `sum_\u03c8`, for the case where `nonzeroS D x` has two elements.\nprivate lemma sum_\u03c8\u2082 (hx : 0 < x)\n    (h : D ^ (-\u2308logb D (4 * x)\u2309) < 1 / (2 * D * x)) :\n    \u2211 s \u2208 nonzeroS D x, \u03c8 D (D ^ (-s) * x) = 1 := by\n  -- Replace `nonzeroS D x` with `{s\u2080 - 1, s\u2080}`, where `s\u2080 := \u2308logb D (4 * x)\u2309`\n  have endpts := endpoint_sub_one hD hx h\n  have ne : \u2308logb D (4 * x)\u2309 - 1 \u2260 \u2308logb D (4 * x)\u2309 := pred_ne_self _\n  have : nonzeroS D x = {\u2308logb D (4 * x)\u2309 - 1, \u2308logb D (4 * x)\u2309} := by\n    rw [nonzeroS, \u2190 endpts]\n    have Icc_of_eq_add_one {a b : \u2124} (h : a + 1 = b) : Finset.Icc a b = {a, b} := by\n      subst h; exact Int.Icc_eq_pair a\n    exact Icc_of_eq_add_one (add_eq_of_eq_sub endpts)\n  set s\u2080 := \u2308logb D (4 * x)\u2309\n  rw [this, Finset.sum_insert ((Finset.not_mem_singleton).2 ne), Finset.sum_singleton]\n  -- Now calculate the sum\n  have Ds\u2080x_lt := (mul_lt_mul_right hx).2 h\n  rw [\u2190 div_div, div_mul_cancel\u2080 _ (ne_of_gt hx)] at Ds\u2080x_lt\n  have hs\u2080 := And.intro (le_div_ceil_mul hD hx) Ds\u2080x_lt.le\n  suffices 1 / 4 \u2264 D ^ (-(s\u2080 - 1)) * x \u2227 D ^ (-(s\u2080 - 1)) * x \u2264 1 / 2 by\n    rw [\u03c8_formula\u2081 hD hs\u2080, \u03c8_formula\u2083 hD this]\n    suffices (D : \u211d) ^ (1 - s\u2080) = D * D ^ (-s\u2080) by rw [neg_sub, this]; ring\n    rw [zpow_sub\u2080 (ne_of_gt (D0 hD)), zpow_neg, zpow_one, div_eq_mul_inv]\n  rw [neg_sub, sub_eq_add_neg, zpow_add\u2080 (ne_of_gt (D0 hD)), zpow_one, mul_assoc]\n  constructor\n  \u00b7 rw [\u2190 div_le_iff\u2080' (D0 hD), div_div]; exact hs\u2080.1\n  \u00b7 rw [\u2190 le_div_iff\u2080' (D0 hD), div_div]; exact hs\u2080.2\n\n-- See `finsum_\u03c8` for the version that doesn't explicitly restrict to the support.\nlemma sum_\u03c8 (hx : 0 < x) : \u2211 s \u2208 nonzeroS D x, \u03c8 D (D ^ (-s) * x) = 1 := by\n  by_cases h : D ^ (-\u2308logb D (4 * x)\u2309) \u2265 1 / (2 * D * x)\n  \u00b7 exact sum_\u03c8\u2081 hD hx h\n  \u00b7 exact sum_\u03c8\u2082 hD hx (lt_of_not_ge h)\n\n--------------------------------------------------\n/- Now we prove that `nonzeroS D x` is the support of `s \u21a6 \u03c8 D (D ^ (-s) * x)`. This converts\n`sum_\u03c8` into `finsum_\u03c8`, which states that `\u2211\u1da0 s : \u2124, \u03c8 D (D ^ (-s) * x) = 1`. -/\n\nlemma mem_nonzeroS_iff {i : \u2124} {x : \u211d} (hx : 0 < x) :\n    i \u2208 nonzeroS D x \u2194 (D ^ (-i) * x) \u2208 Ioo (4 * D : \u211d)\u207b\u00b9 2\u207b\u00b9 := by\n  rw [mem_Ioo, nonzeroS, Finset.mem_Icc, Int.floor_le_iff, Int.le_ceil_iff, mul_inv_rev,\n    add_comm _ 1, Real.add_lt_add_iff_left, \u2190 lt_div_iff\u2080 hx, mul_comm (D : \u211d)\u207b\u00b9,\n    \u2190 div_lt_div_iff\u2080 hx (inv_pos.2 (D0 hD)), div_inv_eq_mul, \u2190 zpow_add_one\u2080 ((D0 hD).ne.symm),\n    zpow_neg, \u2190 Real.rpow_intCast, \u2190 Real.rpow_intCast, lt_logb_iff_rpow_lt hD (four_x0 hx),\n    logb_lt_iff_lt_rpow hD (mul_pos two_pos hx), \u2190 sub_eq_neg_add, \u2190 neg_sub i 1, \u2190 inv_mul',\n    \u2190 inv_mul', inv_lt_inv\u2080 (D_pow0 hD _) (mul_pos two_pos hx), Int.cast_neg, Int.cast_sub,\n    Int.cast_one, rpow_neg (D0 hD).le, inv_lt_inv\u2080 (four_x0 hx) (D_pow0 hD _), and_comm]\n\nlemma psi_ne_zero_iff {x : \u211d} (hx : 0 < x) :\n    \u03c8 D (D ^ (-s) * x) \u2260 0 \u2194 s \u2208 nonzeroS D x := by\n  rw [\u2190 mem_support, support_\u03c8 (by exact_mod_cast hD), mem_nonzeroS_iff hD hx]\n\nlemma psi_eq_zero_iff {x : \u211d} (hx : 0 < x) : \u03c8 D (D ^ (-s) * x) = 0 \u2194 s \u2209 nonzeroS D x := by\n  rw [\u2190 iff_not_comm, \u2190 psi_ne_zero_iff hD hx]\n\nlemma support_\u03c8S (hx : 0 < x) : support (fun (s : \u2124) \u21a6 \u03c8 D (D ^ (-s) * x)) = nonzeroS D x := by\n  ext; rw [mem_support]; exact psi_ne_zero_iff hD hx\n\nlemma support_\u03c8S_subset_Icc {b c : \u2124} {x : \u211d}\n    (h : x \u2208 Icc ((D : \u211d) ^ (b - 1) / 2) (D ^ c / 4)) :\n    support (fun (s : \u2124) \u21a6 \u03c8 D (D ^ (-s) * x)) \u2286 Icc b c := by\n  intro i hi\n  have hx : x > 0 := lt_of_lt_of_le (by positivity) h.1\n  simp only [support_\u03c8S hD hx, nonzeroS, Finset.coe_Icc, mem_Icc] at hi\n  simp only [toFinset_Icc, Finset.coe_Icc, mem_Icc]\n  refine \u27e8le_trans ?_ hi.1, le_trans hi.2 ?_\u27e9\n  \u00b7 rw [\u2190 Nat.cast_one, Int.floor_nat_add, Nat.cast_one, \u2190 sub_le_iff_le_add', Int.le_floor,\n      Real.le_logb_iff_rpow_le hD (mul_pos two_pos hx), mul_comm]\n    exact_mod_cast (div_le_iff\u2080 two_pos).mp h.1\n  \u00b7 rw [Int.ceil_le, Real.logb_le_iff_le_rpow hD (mul_pos four_pos hx), mul_comm]\n    exact_mod_cast (le_div_iff\u2080 four_pos).mp h.2\n\nlemma finsum_\u03c8 (hx : 0 < x) : \u2211\u1da0 s : \u2124, \u03c8 D (D ^ (-s) * x) = 1 := by\n  refine Eq.trans ?_ (sum_\u03c8 hD hx)\n  apply Eq.trans <| finsum_eq_sum _ <| support_\u03c8S hD hx \u25b8 Finset.finite_toSet (nonzeroS D x)\n  congr\n  ext\n  rw [Finite.mem_toFinset, support_\u03c8S hD hx, Finset.mem_coe]\n\nlemma sum_\u03c8_le (S : Finset \u2124) (hx : 0 < x) : \u2211 s \u2208 S, \u03c8 D (D ^ (-s) * x) \u2264 1 := calc\n  _ = \u2211 s \u2208 S \u2229 (nonzeroS D x), \u03c8 D (D ^ (-s) * x) := by\n    refine (Finset.sum_subset Finset.inter_subset_left (fun s sS hs \u21a6 ?_)).symm\n    exact (psi_eq_zero_iff hD hx).mpr (fun h \u21a6 hs <| Finset.mem_inter.mpr \u27e8sS, h\u27e9)\n  _ \u2264 \u2211 s \u2208 nonzeroS D x, \u03c8 D (D ^ (-s) * x) :=\n    Finset.sum_le_sum_of_subset_of_nonneg Finset.inter_subset_right (fun _ _ _ \u21a6 zero_le_\u03c8 ..)\n  _ = 1 := sum_\u03c8 hD hx\n\nend include_hD\n\nend D\n\n\nopen Complex\n\nopen scoped ShortVariables\nvariable (X : Type*) {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102} {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X}\n  [PseudoMetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G]\nvariable {s : \u2124} {x y : X}\n\nsection -- Again, we start by recording some trivial inequalities that will be needed repeatedly.\ninclude q K \u03c3\u2081 \u03c3\u2082 F G\nprivate lemma a0' : a > 0 := by linarith [four_le_a X]\nprivate lemma a0 : (a : \u211d) > 0 := by exact_mod_cast (a0' X)\nprivate lemma D1 : (D : \u211d) > 1 := by norm_cast; norm_num; exact (a0' X).ne.symm\nprivate lemma D0' : (D : \u211d) > 0 := one_pos.trans (D1 X)\nprivate lemma D0'' : D > 0 := by exact_mod_cast (D0' X)\nprivate lemma Ds0 (s : \u2124) : (D : \u211d) ^ s > 0 := have := D0' X; by positivity\nend\n\nvariable {X}\n\n/-- K_s in the blueprint -/\n@[nolint unusedArguments]\ndef Ks [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] (s : \u2124) (x y : X) : \u2102 :=\n  K x y * \u03c8 (D ^ (-s) * dist x y)\n\nlemma Ks_def (s : \u2124) (x y : X) : Ks s x y = K x y * \u03c8 (D ^ (-s) * dist x y) := rfl\n\nlemma sum_Ks {t : Finset \u2124} (hs : nonzeroS D (dist x y) \u2286 t) (hD : 1 < (D : \u211d)) (h : 0 < dist x y) :\n    \u2211 i \u2208 t, Ks i x y = K x y := by\n  simp_rw [Ks, \u2190 Finset.mul_sum]\n  norm_cast\n  suffices \u2211 i \u2208 t, \u03c8 (D ^ (-i) * dist x y) = 1 by rw [this, ofReal_one, mul_one]\n  rw [\u2190 Finset.sum_subset hs, sum_\u03c8 hD h]\n  intros\n  rwa [psi_eq_zero_iff hD h]\n\n-- maybe this version is also useful?\n-- lemma sum_Ks' {t : Finset \u2124}\n--     (hs : \u2200 i : \u2124, (D ^ i * dist x y) \u2208 Ioo (4 * D)\u207b\u00b9 2\u207b\u00b9 \u2192 i \u2208 t)\n--     (hD : 1 < D) (h : x \u2260 y) : \u2211 i \u2208 t, Ks i x y = K x y := by\n--   sorry\n\n", "theoremStatement": "lemma dist_mem_Ioo_of_Ks_ne_zero {s : \u2124} {x y : X} (h : Ks s x y \u2260 0) :\n    dist x y \u2208 Ioo ((D ^ (s - 1) : \u211d) / 4) (D ^ s / 2) ", "theoremName": "dist_mem_Ioo_of_Ks_ne_zero", "fileCreated": {"commit": "743fbe4ea5741cd92c855e66055ba156f232beff", "date": "2024-06-16"}, "theoremCreated": {"commit": "3298f748e9eb26a242da5ee38cb50dc55e604935", "date": "2025-01-08"}, "file": "carleson/Carleson/Psi.lean", "module": "Carleson.Psi", "jsonFile": "Carleson.Psi.jsonl", "positionMetadata": {"lineInFile": 355, "tokenPositionInFile": 16534, "theoremPositionInFile": 48}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 5, "numPremises": 147}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp only [Ks, Nat.cast_pow, Nat.cast_ofNat, zpow_neg, ne_eq, mul_eq_zero, ofReal_eq_zero] at h\n  have dist_mem_Ioo := support_\u03c8 (D1 X) \u25b8 mem_support.2 (not_or.1 h).2\n  rwa [mem_Ioo, \u2190 div_eq_inv_mul, lt_div_iff\u2080 (D_pow0' (D1 X) s),\n    div_lt_iff\u2080 (D_pow0' (D1 X) s), mul_inv, mul_assoc, inv_mul_eq_div (4 : \u211d), \u2190 zpow_neg_one,\n    \u2190 zpow_add\u2080 (D0' X).ne.symm, neg_add_eq_sub, \u2190 div_eq_inv_mul] at dist_mem_Ioo", "proofType": "tactic", "proofLengthLines": 5, "proofLengthTokens": 419}}
{"srcContext": "import Carleson.GridStructure\nimport Carleson.Psi\nimport Carleson.ToMathlib.BoundedCompactSupport\n\nopen Set MeasureTheory Metric Function Complex Bornology\nopen scoped NNReal ENNReal ComplexConjugate\nnoncomputable section\n\nsection Generic\nuniverse u\nvariable {\ud835\udd5c : Type*} [_root_.RCLike \ud835\udd5c]\nvariable {X : Type u} {A : \u211d\u22650} [PseudoMetricSpace X] [DoublingMeasure X A]\n\n/- The data in a tile structure, and some basic properties.\nThis is mostly separated out so that we can nicely define the notation `d_\ud835\udd2d`.\nNote: compose `\ud835\udcd8` with `Grid` to get the `\ud835\udcd8` of the paper. -/\nclass PreTileStructure {A : outParam \u211d\u22650} [PseudoMetricSpace X] [DoublingMeasure X A]\n  [FunctionDistances \ud835\udd5c X] (Q : outParam (SimpleFunc X (\u0398 X)))\n  (D : outParam \u2115) (\u03ba : outParam \u211d) (S : outParam \u2115) (o : outParam X)\n  extends GridStructure X D \u03ba S o where\n  protected \ud835\udd13 : Type u\n  fintype_\ud835\udd13 : Fintype \ud835\udd13\n  protected \ud835\udcd8 : \ud835\udd13 \u2192 Grid\n  surjective_\ud835\udcd8 : Surjective \ud835\udcd8\n  \ud835\udcac : \ud835\udd13 \u2192 \u0398 X\n  range_\ud835\udcac : range \ud835\udcac \u2286 range Q\n\nexport PreTileStructure (\ud835\udcac range_\ud835\udcac)\n\nvariable {D : \u2115} {\u03ba : \u211d} {S : \u2115} {o : X}\nvariable [FunctionDistances \ud835\udd5c X]  {Q : SimpleFunc X (\u0398 X)} [PreTileStructure Q D \u03ba S o]\n\nvariable (X) in\ndef \ud835\udd13 := PreTileStructure.\ud835\udd13 \ud835\udd5c X\ninstance : Fintype (\ud835\udd13 X) := PreTileStructure.fintype_\ud835\udd13\ndef \ud835\udcd8 : \ud835\udd13 X \u2192 Grid X := PreTileStructure.\ud835\udcd8\nlemma surjective_\ud835\udcd8 : Surjective (\ud835\udcd8 : \ud835\udd13 X \u2192 Grid X) := PreTileStructure.surjective_\ud835\udcd8\ninstance : Inhabited (\ud835\udd13 X) := \u27e8(surjective_\ud835\udcd8 default).choose\u27e9\ndef \ud835\udd20 (p : \ud835\udd13 X) : X := c (\ud835\udcd8 p)\ndef \ud835\udd30 (p : \ud835\udd13 X) : \u2124 := s (\ud835\udcd8 p)\n\nlocal notation \"ball_(\" D \",\" \ud835\udd2d \")\" => @ball (WithFunctionDistance (\ud835\udd20 \ud835\udd2d) (D ^ \ud835\udd30 \ud835\udd2d / 4)) _\n\n/-- A tile structure. -/\n-- note: we don't explicitly include injectivity of `\u03a9` on `\ud835\udd13(I)`, since it follows from these\n-- axioms: see `toTileLike_injective`\nclass TileStructure {A : outParam \u211d\u22650} [PseudoMetricSpace X] [DoublingMeasure X A]\n    [FunctionDistances \u211d X] (Q : outParam (SimpleFunc X (\u0398 X)))\n    (D : outParam \u2115) (\u03ba : outParam \u211d) (S : outParam \u2115) (o : outParam X)\n    extends PreTileStructure Q D \u03ba S o where\n  \u03a9 : \ud835\udd13 \u2192 Set (\u0398 X)\n  biUnion_\u03a9 {i} : range Q \u2286 \u22c3 p \u2208 \ud835\udcd8 \u207b\u00b9' {i}, \u03a9 p -- 2.0.13, union contains `Q`\n  disjoint_\u03a9 {p p'} (h : p \u2260 p') (hp : \ud835\udcd8 p = \ud835\udcd8 p') : -- 2.0.13, union is disjoint\n    Disjoint (\u03a9 p) (\u03a9 p')\n  relative_fundamental_dyadic {p p'} (h : \ud835\udcd8 p \u2264 \ud835\udcd8 p') : -- 2.0.14\n    Disjoint (\u03a9 p) (\u03a9 p') \u2228 \u03a9 p' \u2286 \u03a9 p\n  cball_subset {p} : ball_(D, p) (\ud835\udcac p) 5\u207b\u00b9 \u2286 \u03a9 p -- 2.0.15, first inclusion\n  subset_cball {p} : \u03a9 p \u2286 ball_(D, p) (\ud835\udcac p) 1 -- 2.0.15, second inclusion\n\nexport TileStructure (\u03a9 biUnion_\u03a9 disjoint_\u03a9 relative_fundamental_dyadic)\n\nend Generic\n\n\nopen scoped ShortVariables\nvariable {X : Type*} [PseudoMetricSpace X] {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102}\n  {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X} [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G]\n\nsection\n\nvariable [TileStructure Q D \u03ba S o] {p p' : \ud835\udd13 X} {f g : \u0398 X}\n\n-- maybe we should delete the following three notations, and use `dist_{\ud835\udcd8 p}` instead?\nnotation \"dist_(\" \ud835\udd2d \")\" => @dist (WithFunctionDistance (\ud835\udd20 \ud835\udd2d) (D ^ \ud835\udd30 \ud835\udd2d / 4)) _\nnotation \"nndist_(\" \ud835\udd2d \")\" => @nndist (WithFunctionDistance (\ud835\udd20 \ud835\udd2d) (D ^ \ud835\udd30 \ud835\udd2d / 4)) _\nnotation \"ball_(\" \ud835\udd2d \")\" => @ball (WithFunctionDistance (\ud835\udd20 \ud835\udd2d) (D ^ \ud835\udd30 \ud835\udd2d / 4)) _\n\n\n@[simp] lemma dist_\ud835\udcd8 (p : \ud835\udd13 X) : dist_{\ud835\udcd8 p} f g = dist_(p) f g := rfl\n@[simp] lemma nndist_\ud835\udcd8 (p : \ud835\udd13 X) : nndist_{\ud835\udcd8 p} f g = nndist_(p) f g := rfl\n@[simp] lemma ball_\ud835\udcd8 (p : \ud835\udd13 X) {r : \u211d} : ball_{\ud835\udcd8 p} f r = ball_(p) f r := rfl\n\n@[simp] lemma cball_subset {p : \ud835\udd13 X} : ball_(p) (\ud835\udcac p) 5\u207b\u00b9 \u2286 \u03a9 p := TileStructure.cball_subset\n@[simp] lemma subset_cball {p : \ud835\udd13 X} : \u03a9 p \u2286 ball_(p) (\ud835\udcac p) 1 := TileStructure.subset_cball\n\nlemma ball_eq_of_grid_eq {p q : \ud835\udd13 X} {\u03d1 : \u0398 X} {r : \u211d} (h : \ud835\udcd8 p = \ud835\udcd8 q) :\n    ball_(p) \u03d1 r = ball_(q) \u03d1 r := by rw [\u2190 ball_\ud835\udcd8, h]\n\nlemma cball_disjoint {p p' : \ud835\udd13 X} (h : p \u2260 p') (hp : \ud835\udcd8 p = \ud835\udcd8 p') :\n    Disjoint (ball_(p) (\ud835\udcac p) 5\u207b\u00b9) (ball_(p') (\ud835\udcac p') 5\u207b\u00b9) :=\n  disjoint_of_subset cball_subset cball_subset (disjoint_\u03a9 h hp)\n\n/-- The set `E` defined in Proposition 2.0.2. -/\ndef E (p : \ud835\udd13 X) : Set X :=\n  { x \u2208 \ud835\udcd8 p | Q x \u2208 \u03a9 p \u2227 \ud835\udd30 p \u2208 Icc (\u03c3\u2081 x) (\u03c3\u2082 x) }\n\nlemma E_subset_\ud835\udcd8 {p : \ud835\udd13 X} : E p \u2286 \ud835\udcd8 p := fun _ \u21a6 mem_of_mem_inter_left\n\nlemma measurableSet_E {p : \ud835\udd13 X} : MeasurableSet (E p) := by\n  refine (Measurable.and ?_ (Measurable.and ?_ ?_)).setOf\n  \u00b7 rw [\u2190 measurableSet_setOf]; exact coeGrid_measurable\n  \u00b7 simp_rw [\u2190 mem_preimage, \u2190 measurableSet_setOf]; exact SimpleFunc.measurableSet_preimage ..\n  \u00b7 apply (measurable_set_mem _).comp\n    apply Measurable.comp (f := fun x \u21a6 (\u03c3\u2081 x, \u03c3\u2082 x)) (g := fun p \u21a6 Icc p.1 p.2)\n    \u00b7 exact measurable_from_prod_countable fun _ _ _ \u21a6 trivial\n    \u00b7 exact measurable_\u03c3\u2081.prod_mk measurable_\u03c3\u2082\n\nlemma volume_E_lt_top : volume (E p) < \u22a4 := trans (measure_mono E_subset_\ud835\udcd8) volume_coeGrid_lt_top\n\nsection T\n\n/-- The operator `T_\ud835\udd2d` defined in Proposition 2.0.2, considered on the set `F`.\nIt is the map `T \u2218 (1_F * \u00b7) : f \u21a6 T (1_F * f)`, also denoted `T1_F`\nThe operator `T` in Proposition 2.0.2 is therefore applied to `(F := Set.univ)`. -/\ndef carlesonOn (p : \ud835\udd13 X) (f : X \u2192 \u2102) : X \u2192 \u2102 :=\n  indicator (E p)\n    fun x \u21a6 \u222b y, exp (I * (Q x y - Q x x)) * K x y * \u03c8 (D ^ (- \ud835\udd30 p) * dist x y) * f y\n\n-- not used anywhere and deprecated for `AEStronglyMeasurable.carlesonOn`\nlemma measurable_carlesonOn {p : \ud835\udd13 X} {f : X \u2192 \u2102} (measf : Measurable f) :\n    Measurable (carlesonOn p f) := by\n  refine (StronglyMeasurable.integral_prod_right ?_).measurable.indicator measurableSet_E\n  refine (((Measurable.mul ?_ measurable_K).mul ?_).mul ?_).stronglyMeasurable\n  \u00b7 have : Measurable fun (p : X \u00d7 X) \u21a6 (p.1, p.1) := by fun_prop\n    refine ((Measurable.sub ?_ ?_).const_mul I).cexp <;> apply measurable_ofReal.comp\n    \u00b7 exact measurable_Q\u2082\n    \u00b7 exact measurable_Q\u2082.comp this\n  \u00b7 apply measurable_ofReal.comp\n    apply Measurable.comp (f := fun x : X \u00d7 X \u21a6 D ^ (-\ud835\udd30 p) * dist x.1 x.2) (g := \u03c8)\n    \u00b7 exact measurable_const.max (measurable_const.min (Measurable.min (by fun_prop) (by fun_prop)))\n    \u00b7 exact measurable_dist.const_mul _\n  \u00b7 exact measf.comp measurable_snd\n\nopen Classical in\n/-- The operator `T_\u212d f` defined at the bottom of Section 7.4.\nWe will use this in other places of the formalization as well. -/\ndef carlesonSum (\u212d : Set (\ud835\udd13 X)) (f : X \u2192 \u2102) (x : X) : \u2102 :=\n  \u2211 p \u2208 {p | p \u2208 \u212d}, carlesonOn p f x\n\n-- not used anywhere and deprecated for `AEStronglyMeasurable.carlesonSum`\n@[fun_prop]\nlemma measurable_carlesonSum {\u212d : Set (\ud835\udd13 X)} {f : X \u2192 \u2102} (measf : Measurable f) :\n    Measurable (carlesonSum \u212d f) :=\n  Finset.measurable_sum _ fun _ _ \u21a6 measurable_carlesonOn measf\n\nlemma _root_.MeasureTheory.AEStronglyMeasurable.carlesonOn {p : \ud835\udd13 X} {f : X \u2192 \u2102}\n    (hf : AEStronglyMeasurable f) : AEStronglyMeasurable (carlesonOn p f) := by\n  refine .indicator ?_ measurableSet_E\n  refine .integral_prod_right'\n    (f := fun z \u21a6 exp (Complex.I * (Q z.1 z.2 - Q z.1 z.1)) * K z.1 z.2 *\n      \u03c8 (D ^ (- \ud835\udd30 p) * dist z.1 z.2) * f z.2) ?_\n  refine (((AEStronglyMeasurable.mul ?_ aestronglyMeasurable_K).mul ?_).mul ?_)\n  \u00b7 apply Measurable.aestronglyMeasurable\n    have : Measurable fun (p : X \u00d7 X) \u21a6 (p.1, p.1) := by fun_prop\n    refine ((Measurable.sub ?_ ?_).const_mul I).cexp <;> apply measurable_ofReal.comp\n    \u00b7 exact measurable_Q\u2082\n    \u00b7 exact measurable_Q\u2082.comp this\n  \u00b7 apply Measurable.aestronglyMeasurable\n    apply measurable_ofReal.comp\n    apply Measurable.comp (f := fun x : X \u00d7 X \u21a6 D ^ (-\ud835\udd30 p) * dist x.1 x.2) (g := \u03c8)\n    \u00b7 exact measurable_const.max (measurable_const.min (Measurable.min (by fun_prop) (by fun_prop)))\n    \u00b7 exact measurable_dist.const_mul _\n  \u00b7 exact hf.snd\n\nlemma _root_.MeasureTheory.AEStronglyMeasurable.carlesonSum {\u212d : Set (\ud835\udd13 X)}\n    {f : X \u2192 \u2102} (hf : AEStronglyMeasurable f) : AEStronglyMeasurable (carlesonSum \u212d f) :=\n  Finset.aestronglyMeasurable_sum _ fun _ _ \u21a6 hf.carlesonOn\n\nlemma carlesonOn_def' (p : \ud835\udd13 X) (f : X \u2192 \u2102) : carlesonOn p f =\n    indicator (E p) fun x \u21a6 \u222b y, Ks (\ud835\udd30 p) x y * f y * exp (I * (Q x y - Q x x)) := by\n  unfold carlesonOn Ks\n  exact congr_arg _ (funext fun x \u21a6 (congr_arg _ (funext fun y \u21a6 by ring)))\n\nlemma support_carlesonOn_subset_E {f : X \u2192 \u2102} : support (carlesonOn p f) \u2286 E p :=\n  fun _ hx \u21a6 mem_of_indicator_ne_zero hx\n\nlemma support_carlesonSum_subset {\u212d : Set (\ud835\udd13 X)} {f : X \u2192 \u2102} :\n    support (carlesonSum \u212d f) \u2286 (\u22c3 p \u2208 \u212d, \ud835\udcd8 p) := by\n  intro x hx\n  rw [mem_support] at hx\n  contrapose! hx\n  refine Finset.sum_eq_zero (fun p hp \u21a6 nmem_support.mp (fun hxp \u21a6 hx ?_))\n  simp only [Finset.mem_filter] at hp\n  exact Set.mem_biUnion hp.2 <| E_subset_\ud835\udcd8 (support_carlesonOn_subset_E hxp)\n\ntheorem _root_.MeasureTheory.BoundedCompactSupport.carlesonOn {f : X \u2192 \u2102}\n    (hf : BoundedCompactSupport f) : BoundedCompactSupport (carlesonOn p f) where\n  stronglyMeasurable :=\n    (measurable_carlesonOn hf.stronglyMeasurable.measurable).stronglyMeasurable\n  isBounded := by\n    let x\u2080 : X := Classical.choice inferInstance\n    obtain \u27e8r\u2080, hr\u2080, hfr\u2080\u27e9 := hf.isBoundedSupport.subset_closedBall_lt 0 x\u2080\n    let r\u2081 := (\u2191D ^ \ud835\udd30 p / 2) + r\u2080\n    have hcf : support (_root_.carlesonOn p f) \u2286 closedBall x\u2080 r\u2081 := by\n      simp_rw [carlesonOn_def']\n      intro x hx\n      simp only [mem_support] at hx\n      apply indicator_apply_ne_zero.mp at hx\n      replace hx := hx.2\n      simp only [mem_support] at hx\n      have : \u2203 y, Ks (\ud835\udd30 p) x y * f y * cexp (I * (\u2191((Q x) y) - \u2191((Q x) x))) \u2260 0 := by\n        -- mathlib lemma: if integral ne zero, then integrand ne zero at a point\n        by_contra hc\n        simp only [not_exists, ne_eq, not_not] at hc\n        refine hx ?_\n        refine integral_eq_zero_of_ae ?_\n        simp_all only [support_subset_iff, ne_eq,\n          mem_closedBall, integral_zero, not_true_eq_false, x\u2080]\n      obtain \u27e8y, hy\u27e9 := this\n      simp only [ne_eq, mul_eq_zero, exp_ne_zero, or_false, not_or] at hy\n      have := dist_mem_Icc_of_Ks_ne_zero hy.1\n      apply (dist_triangle _ y _).trans\n      unfold r\u2081\n      gcongr\n      \u00b7 exact (dist_mem_Icc_of_Ks_ne_zero hy.1).2\n      \u00b7 exact hfr\u2080 hy.2\n    obtain \u27e8CK, hCK, hCK\u27e9 :=\n      IsBounded.exists_bound_of_norm_Ks (Metric.isBounded_closedBall (x := x\u2080) (r := r\u2081)) (\ud835\udd30 p)\n    let C := volume.real (closedBall x\u2080 r\u2080) * (CK * (eLpNorm f \u22a4).toReal)\n    apply isBounded_range_iff_forall_norm_le.2 \u27e8C, fun x \u21a6 ?_\u27e9\n    wlog hx : x \u2208 support (_root_.carlesonOn p f)\n    \u00b7 simp only [mem_support, ne_eq, not_not] at hx\n      rw [hx, norm_zero]\n      positivity\n    \u00b7 simp_rw [carlesonOn_def']\n      refine trans (norm_indicator_le_norm_self _ _) ?_\n      let g := (closedBall x\u2080 r\u2080).indicator (fun _ \u21a6 CK * (eLpNorm f \u22a4).toReal)\n      have hK : \u2200\u1d50 y, \u2016Ks (\ud835\udd30 p) x y * f y * cexp (I * (\u2191((Q x) y) - \u2191((Q x) x)))\u2016 \u2264 g y := by\n        filter_upwards [hf.ae_le] with y hy\n        by_cases hy' : y \u2208 support f\n        \u00b7 have := hfr\u2080 hy'\n          calc\n            _ \u2264 \u2016Ks (\ud835\udd30 p) x y * f y\u2016 * \u2016cexp (I * (\u2191((Q x) y) - \u2191((Q x) x)))\u2016 := norm_mul_le ..\n            _ = \u2016Ks (\ud835\udd30 p) x y * f y\u2016 := by rw [norm_exp_I_mul_sub_ofReal, mul_one]\n            _ \u2264 \u2016Ks (\ud835\udd30 p) x y\u2016 * \u2016f y\u2016 := norm_mul_le ..\n            _ \u2264 CK * (eLpNorm f \u22a4).toReal := by gcongr; exact hCK x y (hcf hx)\n            _ = g y := by simp_all only [indicator_of_mem, g]\n        \u00b7 simp only [mem_support, ne_eq, not_not] at hy'\n          rw [hy']\n          simp only [mul_zero, zero_mul, norm_zero, g]\n          unfold indicator\n          split_ifs <;> positivity\n      calc\n        _ \u2264 \u222b y, g y := by\n          refine norm_integral_le_of_norm_le ?_ hK\n          exact Integrable.indicator_const measurableSet_closedBall measure_closedBall_lt_top\n        _ = volume.real (closedBall x\u2080 r\u2080) * (CK * (eLpNorm f \u22a4 volume).toReal) :=\n          integral_indicator_const _ measurableSet_closedBall\n  hasCompactSupport := by\n    suffices support (_root_.carlesonOn p f) \u2286 \ud835\udcd8 p by\n      refine HasCompactSupport.of_support_subset_isBounded ?_ this\n      exact Metric.isBounded_ball.subset Grid_subset_ball\n    exact Trans.trans support_carlesonOn_subset_E E_subset_\ud835\udcd8\n\ntheorem _root_.MeasureTheory.BoundedCompactSupport.carlesonSum {\u212d : Set (\ud835\udd13 X)} {f : X \u2192 \u2102}\n    (hf : BoundedCompactSupport f) : BoundedCompactSupport (carlesonSum \u212d f) :=\n  .finset_sum (fun _ _ \u21a6 hf.carlesonOn)\n\nlemma carlesonSum_inter_add_inter_compl {f : X \u2192 \u2102} {x : X} (A B : Set (\ud835\udd13 X)) :\n    carlesonSum (A \u2229 B) f x + carlesonSum (A \u2229 B\u1d9c) f x = carlesonSum A f x := by\n  classical\n  simp only [carlesonSum]\n  conv_rhs => rw [\u2190 Finset.sum_filter_add_sum_filter_not _ (fun p \u21a6 p \u2208 B)]\n  congr 2\n  \u00b7 ext; simp\n  \u00b7 ext; simp\n\nlemma sum_carlesonSum_of_pairwiseDisjoint {\u03b9 : Type*} {f : X \u2192 \u2102} {x : X} {A : \u03b9 \u2192 Set (\ud835\udd13 X)}\n    {s : Finset \u03b9} (hs : (s : Set \u03b9).PairwiseDisjoint A) :\n    \u2211 i \u2208 s, carlesonSum (A i) f x = carlesonSum (\u22c3 i \u2208 s, A i) f x := by\n  classical\n  simp only [carlesonSum]\n  rw [\u2190 Finset.sum_biUnion]\n  \u00b7 congr\n    ext p\n    simp\n  \u00b7 convert hs\n    refine \u27e8fun h \u21a6 ?_, fun h \u21a6 ?_\u27e9\n    \u00b7 intro i hi j hj hij\n      convert Finset.disjoint_coe.2 (h hi hj hij)\n      \u00b7 ext; simp\n      \u00b7 ext; simp\n    \u00b7 intro i hi j hj hij\n      apply Finset.disjoint_coe.1\n      convert h hi hj hij\n      \u00b7 ext; simp\n      \u00b7 ext; simp\n\nend T\n\nvariable (X) in\ndef TileLike : Type _ := Grid X \u00d7 OrderDual (Set (\u0398 X))\n\ndef TileLike.fst (x : TileLike X) : Grid X := x.1\ndef TileLike.snd (x : TileLike X) : Set (\u0398 X) := x.2\n\n@[simp] lemma TileLike.fst_mk (x : Grid X) (y : Set (\u0398 X)) : TileLike.fst (x, y) = x := by rfl\n@[simp] lemma TileLike.snd_mk (x : Grid X) (y : Set (\u0398 X)) : TileLike.snd (x, y) = y := by rfl\n\ninstance : PartialOrder (TileLike X) := by dsimp [TileLike]; infer_instance\n\nlemma TileLike.le_def (x y : TileLike X) : x \u2264 y \u2194 x.fst \u2264 y.fst \u2227 y.snd \u2286 x.snd := by rfl\n\ndef toTileLike (p : \ud835\udd13 X) : TileLike X := (\ud835\udcd8 p, \u03a9 p)\n\n@[simp] lemma toTileLike_fst (p : \ud835\udd13 X) : (toTileLike p).fst = \ud835\udcd8 p := by rfl\n@[simp] lemma toTileLike_snd (p : \ud835\udd13 X) : (toTileLike p).snd = \u03a9 p := by rfl\n\n/-- This is not defined as such in the blueprint, but `\u03bbp \u2272 \u03bb'p'` can be written using\n`smul l p \u2264 smul l' p'`.\nBeware: `smul 1 p` is very different from `toTileLike p`. -/\ndef smul (l : \u211d) (p : \ud835\udd13 X) : TileLike X :=\n  (\ud835\udcd8 p, ball_(p) (\ud835\udcac p) l)\n\n@[simp] lemma smul_fst (l : \u211d) (p : \ud835\udd13 X) : (smul l p).fst = \ud835\udcd8 p := by rfl\n@[simp] lemma smul_snd (l : \u211d) (p : \ud835\udd13 X) : (smul l p).snd = ball_(p) (\ud835\udcac p) l := by rfl\n\nlemma smul_mono_left {l l' : \u211d} {p : \ud835\udd13 X} (h : l \u2264 l') : smul l' p \u2264 smul l p := by\n  simp [TileLike.le_def, h, ball_subset_ball]\n\nlemma smul_le_toTileLike : smul 1 p \u2264 toTileLike p := by\n  simp [TileLike.le_def, subset_cball (p := p)]\n\nlemma toTileLike_le_smul : toTileLike p \u2264 smul 5\u207b\u00b9 p := by\n  simp [TileLike.le_def, cball_subset (p := p)]\n\nlemma \ud835\udcac_mem_\u03a9 : \ud835\udcac p \u2208 \u03a9 p := cball_subset <| mem_ball_self <| by norm_num\n\nlemma \ud835\udcac_inj {p' : \ud835\udd13 X} (h : \ud835\udcac p = \ud835\udcac p') (h\ud835\udcd8 : \ud835\udcd8 p = \ud835\udcd8 p') : p = p' := by\n  contrapose! h\n  exact fun h\ud835\udcac \u21a6 (not_disjoint_iff.2 \u27e8\ud835\udcac p, \ud835\udcac_mem_\u03a9, h\ud835\udcac \u25b8 \ud835\udcac_mem_\u03a9\u27e9) (disjoint_\u03a9 h h\ud835\udcd8)\n\nlemma toTileLike_injective : Injective (fun p : \ud835\udd13 X \u21a6 toTileLike p) := by\n  intros p p' h\n  simp_rw [toTileLike, TileLike, Prod.ext_iff] at h\n  by_contra h2\n  have : Disjoint (\u03a9 p) (\u03a9 p') := disjoint_\u03a9 h2 h.1\n  have : \u03a9 p = \u2205 := by simpa [\u2190 h.2]\n  exact not_mem_empty _ (by rw [\u2190 this]; exact \ud835\udcac_mem_\u03a9)\n\ninstance : PartialOrder (\ud835\udd13 X) := PartialOrder.lift toTileLike toTileLike_injective\n\nlemma \ud835\udd13.le_def {p q : \ud835\udd13 X} : p \u2264 q \u2194 toTileLike p \u2264 toTileLike q := by rfl\nlemma \ud835\udd13.le_def' {p q : \ud835\udd13 X} : p \u2264 q \u2194 \ud835\udcd8 p \u2264 \ud835\udcd8 q \u2227 \u03a9 q \u2286 \u03a9 p := by rfl\n\nlemma dist_\ud835\udcac_lt_one_of_le {p q : \ud835\udd13 X} (h : p \u2264 q) : dist_(p) (\ud835\udcac q) (\ud835\udcac p) < 1 :=\n  ((cball_subset.trans h.2).trans subset_cball) (mem_ball_self (by norm_num))\n\nlemma dist_\ud835\udcac_lt_one_of_le' {p q : \ud835\udd13 X} (h : p \u2264 q) : dist_(p) (\ud835\udcac p) (\ud835\udcac q) < 1 :=\n  mem_ball'.mp (dist_\ud835\udcac_lt_one_of_le h)\n\nlemma \ud835\udcd8_strictMono : StrictMono (\ud835\udcd8 (X := X)) := fun _ _ h \u21a6 h.le.1.lt_of_ne <|\n  fun h' \u21a6 disjoint_left.mp (disjoint_\u03a9 h.ne h') (h.le.2 \ud835\udcac_mem_\u03a9) \ud835\udcac_mem_\u03a9\n\n/-- Lemma 5.3.1 -/\nlemma smul_mono {m m' n n' : \u211d} (hp : smul n p \u2264 smul m p') (hm : m' \u2264 m) (hn : n \u2264 n') :\n    smul n' p \u2264 smul m' p' :=\n  smul_mono_left hn |>.trans hp |>.trans <| smul_mono_left hm\n\n/-- Lemma 5.3.2 (generalizing `1` to `k > 0`) -/\nlemma smul_C2_1_2 (m : \u211d) {n k : \u211d} (hk : 0 < k) (hp : \ud835\udcd8 p \u2260 \ud835\udcd8 p') (hl : smul n p \u2264 smul k p') :\n    smul (n + C2_1_2 a * m) p \u2264 smul m p' := by\n  replace hp : \ud835\udcd8 p < \ud835\udcd8 p' := hl.1.lt_of_ne hp\n  have : ball_(p') (\ud835\udcac p') m \u2286 ball_(p) (\ud835\udcac p) (n + C2_1_2 a * m) := fun x hx \u21a6 by\n    rw [@mem_ball] at hx \u22a2\n    calc\n      _ \u2264 dist_(p) x (\ud835\udcac p') + dist_(p) (\ud835\udcac p') (\ud835\udcac p) := dist_triangle ..\n      _ \u2264 C2_1_2 a * dist_(p') x (\ud835\udcac p') + dist_(p) (\ud835\udcac p') (\ud835\udcac p) := by\n        gcongr; exact Grid.dist_strictMono hp\n      _ < C2_1_2 a * m + dist_(p) (\ud835\udcac p') (\ud835\udcac p) := by gcongr; rw [C2_1_2]; positivity\n      _ < _ := by\n        rw [add_comm]; gcongr\n        exact mem_ball.mp <| mem_of_mem_of_subset (by convert mem_ball_self hk) hl.2\n  exact \u27e8hl.1, this\u27e9\n\nlemma dist_LTSeries {n : \u2115} {u : Set (\ud835\udd13 X)} {s : LTSeries u} (hs : s.length = n) {f g : \u0398 X} :\n    dist_(s.head.1) f g \u2264 C2_1_2 a ^ n * dist_(s.last.1) f g := by\n  induction n generalizing s with\n  | zero => rw [pow_zero, one_mul]; apply Grid.dist_mono s.head_le_last.1\n  | succ n ih =>\n    let s' : LTSeries u := s.eraseLast\n    specialize ih (show s'.length = n by simp [s', hs])\n    have link : dist_(s'.last.1) f g \u2264 C2_1_2 a * dist_(s.last.1) f g :=\n      Grid.dist_strictMono <| \ud835\udcd8_strictMono <| s.eraseLast_last_rel_last (by omega)\n    apply ih.trans; rw [pow_succ, mul_assoc]; gcongr; unfold C2_1_2; positivity\n\nend\n\n/-- The constraint on `\u03bb` in the first part of Lemma 5.3.3. -/\ndef C5_3_3 (a : \u2115) : \u211d := (1 - C2_1_2 a)\u207b\u00b9\n\ninclude q K \u03c3\u2081 \u03c3\u2082 F G in\nlemma C5_3_3_le : C5_3_3 a \u2264 11 / 10 := by\n  rw [C5_3_3, inv_le_comm\u2080 (sub_pos.mpr <| C2_1_2_lt_one X) (by norm_num), le_sub_comm]\n  exact C2_1_2_le_inv_512 X |>.trans <| by norm_num\n\nvariable [TileStructure Q D \u03ba S o] {p p' : \ud835\udd13 X} {f g : \u0398 X}\n\n/-- Lemma 5.3.3, Equation (5.3.3) -/\nlemma wiggle_order_11_10 {n : \u211d} (hp : p \u2264 p') (hn : C5_3_3 a \u2264 n) : smul n p \u2264 smul n p' := by\n  rcases eq_or_ne (\ud835\udcd8 p) (\ud835\udcd8 p') with h | h\n  \u00b7 rcases eq_or_ne p p' with rfl | h2\n    \u00b7 rfl\n    \u00b7 exact absurd h (\ud835\udcd8_strictMono (lt_of_le_of_ne hp h2)).ne\n  \u00b7 calc\n      _ \u2264 smul (1 + C2_1_2 a * n) p := by\n        apply smul_mono_left\n        rwa [\u2190 le_sub_iff_add_le, \u2190 one_sub_mul, \u2190 inv_le_iff_one_le_mul\u2080']\n        linarith [C2_1_2_le_inv_512 (X := X)]\n      _ \u2264 smul n p' := smul_C2_1_2 (k := 5\u207b\u00b9) n (by norm_num) h\n        (smul_le_toTileLike.trans <| \ud835\udd13.le_def.mp hp |>.trans toTileLike_le_smul)\n\n/-- Lemma 5.3.3, Equation (5.3.4) -/\nlemma wiggle_order_100 (hp : smul 10 p \u2264 smul 1 p') (hn : \ud835\udcd8 p \u2260 \ud835\udcd8 p') :\n    smul 100 p \u2264 smul 100 p' :=\n  calc\n    _ \u2264 smul (10 + C2_1_2 a * 100) p :=\n      smul_mono_left (by linarith [C2_1_2_le_inv_512 (X := X)])\n    _ \u2264 _ := smul_C2_1_2 100 zero_lt_one hn hp\n\n/-- Lemma 5.3.3, Equation (5.3.5) -/\nlemma wiggle_order_500 (hp : smul 2 p \u2264 smul 1 p') (hn : \ud835\udcd8 p \u2260 \ud835\udcd8 p') :\n    smul 4 p \u2264 smul 500 p' :=\n  calc\n    _ \u2264 smul (2 + C2_1_2 a * 500) p :=\n      smul_mono_left (by linarith [C2_1_2_le_inv_512 (X := X)])\n    _ \u2264 _ := smul_C2_1_2 500 zero_lt_one hn hp\n\ndef C5_3_2 (a : \u2115) : \u211d := 2 ^ (-95 * (a : \u211d))\n\ndef TileLike.toTile (t : TileLike X) : Set (X \u00d7 \u0398 X) :=\n  (t.fst : Set X) \u00d7\u02e2 t.snd\n\n/-- From a TileLike, we can construct a set. This is used in the definitions `E\u2081` and `E\u2082`. -/\ndef TileLike.toSet (t : TileLike X) : Set X :=\n  t.fst \u2229 G \u2229 Q \u207b\u00b9' t.snd\n\ndef E\u2081 (p : \ud835\udd13 X) : Set X :=\n  (toTileLike p).toSet\n\ndef E\u2082 (l : \u211d) (p : \ud835\udd13 X) : Set X :=\n  (smul l p).toSet\n\nlemma E\u2081_subset (p : \ud835\udd13 X) : E\u2081 p \u2286 \ud835\udcd8 p := by\n  change \u2191(\ud835\udcd8 p) \u2229 G \u2229 (Q \u207b\u00b9' \u03a9 p) \u2286 \u2191(\ud835\udcd8 p)\n  rw [inter_assoc]\n  exact inter_subset_left\n\nlemma E\u2082_subset (l : \u211d) (p : \ud835\udd13 X) : E\u2082 l p \u2286 \ud835\udcd8 p := by\n  change \u2191(\ud835\udcd8 p) \u2229 G \u2229 (Q \u207b\u00b9' (ball_(p) (\ud835\udcac p) l)) \u2286 \u2191(\ud835\udcd8 p)\n  rw [inter_assoc]\n  exact inter_subset_left\n\n/-! `\ud835\udd13(\ud835\udd13')` in the blueprint is `lowerClosure \ud835\udd13'` in Lean. -/\n\n/-- This density is defined to live in `\u211d\u22650\u221e`. Use `ENNReal.toReal` to get a real number. -/\ndef dens\u2081 (\ud835\udd13' : Set (\ud835\udd13 X)) : \u211d\u22650\u221e :=\n  \u2a06 (p' \u2208 \ud835\udd13') (l \u2265 (2 : \u211d\u22650)), l ^ (-a : \u211d) *\n  \u2a06 (p \u2208 lowerClosure \ud835\udd13') (_h2 : smul l p' \u2264 smul l p),\n  volume (E\u2082 l p) / volume (\ud835\udcd8 p : Set X)\n\nlemma dens\u2081_mono {\ud835\udd13\u2081 \ud835\udd13\u2082 : Set (\ud835\udd13 X)} (h : \ud835\udd13\u2081 \u2286 \ud835\udd13\u2082) :\n    dens\u2081 \ud835\udd13\u2081 \u2264 dens\u2081 \ud835\udd13\u2082 := by\n  simp only [dens\u2081, iSup_le_iff]\n  intro p hp r hr\n  refine le_iSup\u2082_of_le p (h hp) ?_\n  apply ENNReal.mul_le_of_le_div'\n  simp only [iSup_le_iff]\n  intro q hq hqr\n  rw [ENNReal.le_div_iff_mul_le (by left; simp)]\n  \u00b7 refine le_iSup\u2082_of_le r hr ?_\n    rw [mul_comm]\n    gcongr\n    exact le_iSup\u2082_of_le q (lowerClosure_mono h hq) (le_iSup_iff.mpr fun b a \u21a6 a hqr)\n  \u00b7 left\n    have hr0 : r \u2260 0 := by positivity\n    simp [hr0]\n\n/-- This density is defined to live in `\u211d\u22650\u221e`. Use `ENNReal.toReal` to get a real number. -/\ndef dens\u2082 (\ud835\udd13' : Set (\ud835\udd13 X)) : \u211d\u22650\u221e :=\n  \u2a06 (p \u2208 \ud835\udd13') (r \u2265 4 * (D ^ \ud835\udd30 p : \u211d)),\n  volume (F \u2229 ball (\ud835\udd20 p) r) / volume (ball (\ud835\udd20 p) r)\n\nlemma dens\u2082_eq_biSup_dens\u2082 (\ud835\udd13' : Set (\ud835\udd13 X)) :\n    dens\u2082 (\ud835\udd13') = \u2a06 (p \u2208 \ud835\udd13'), dens\u2082 ({p}) := by\n  simp [dens\u2082]\n\n-- a small characterization that might be useful\nlemma isAntichain_iff_disjoint (\ud835\udd04 : Set (\ud835\udd13 X)) :\n    IsAntichain (\u00b7\u2264\u00b7) (toTileLike (X := X) '' \ud835\udd04) \u2194\n    \u2200 p p', p \u2208 \ud835\udd04 \u2192 p' \u2208 \ud835\udd04 \u2192 p \u2260 p' \u2192\n    Disjoint (toTileLike (X := X) p).toTile (toTileLike p').toTile := sorry\n\nlemma ENNReal.rpow_le_rpow_of_nonpos {x y : \u211d\u22650\u221e} {z : \u211d} (hz : z \u2264 0) (h : x \u2264 y) :\n    y ^ z \u2264 x ^ z := by\n  rw [\u2190 neg_neg z, rpow_neg y, rpow_neg x, \u2190 inv_rpow, \u2190 inv_rpow]\n  exact rpow_le_rpow (ENNReal.inv_le_inv.mpr h) (neg_nonneg.mpr hz)\n\n/- A rough estimate. It's also less than 2 ^ (-a) -/\ndef dens\u2081_le_one {\ud835\udd13' : Set (\ud835\udd13 X)} : dens\u2081 \ud835\udd13' \u2264 1 := by\n  conv_rhs => rw [\u2190 mul_one 1]\n  simp only [dens\u2081, mem_lowerClosure, iSup_exists, iSup_le_iff]\n  intros i _ j hj\n  gcongr\n  \u00b7 calc\n    (j : \u211d\u22650\u221e) ^ (-(a : \u211d)) \u2264 2 ^ (-(a : \u211d)) := by\n      apply ENNReal.rpow_le_rpow_of_nonpos\n      \u00b7 simp_rw [neg_nonpos, Nat.cast_nonneg']\n      exact_mod_cast hj\n    _ \u2264 2 ^ (0 : \u211d) :=\n      ENNReal.rpow_le_rpow_of_exponent_le (by norm_num) (neg_nonpos.mpr (Nat.cast_nonneg' _))\n    _ = 1 := by norm_num\n  simp only [iSup_le_iff, and_imp]\n  intros i' _ _ _ _\n  calc\n  volume (E\u2082 j i') / volume (\ud835\udcd8 i' : Set X) \u2264 volume (\ud835\udcd8 i' : Set X) / volume (\ud835\udcd8 i' : Set X) := by\n    gcongr\n    apply E\u2082_subset\n  _ \u2264 1 := ENNReal.div_self_le_one\n\n/-! ### Stack sizes -/\n\nvariable {C C' : Set (\ud835\udd13 X)} {x x' : X}\nopen scoped Classical\n\n/-- The number of tiles `p` in `s` whose underlying cube `\ud835\udcd8 p` contains `x`. -/\ndef stackSize (C : Set (\ud835\udd13 X)) (x : X) : \u2115 :=\n  \u2211 p \u2208 { p | p \u2208 C }, (\ud835\udcd8 p : Set X).indicator 1 x\n\nlemma stackSize_setOf_add_stackSize_setOf_not {P : \ud835\udd13 X \u2192 Prop} :\n    stackSize {p \u2208 C | P p} x + stackSize {p \u2208 C | \u00ac P p} x = stackSize C x := by\n  simp_rw [stackSize]\n  conv_rhs => rw [\u2190 Finset.sum_filter_add_sum_filter_not _ P]\n  simp_rw [Finset.filter_filter]\n  congr\n\nlemma stackSize_congr (h : \u2200 p \u2208 C, x \u2208 (\ud835\udcd8 p : Set X) \u2194 x' \u2208 (\ud835\udcd8 p : Set X)) :\n    stackSize C x = stackSize C x' := by\n  refine Finset.sum_congr rfl fun p hp \u21a6 ?_\n  simp_rw [Finset.mem_filter, Finset.mem_univ, true_and] at hp\n  simp_rw [indicator, h p hp, Pi.one_apply]\n\nlemma stackSize_mono (h : C \u2286 C') : stackSize C x \u2264 stackSize C' x := by\n  apply Finset.sum_le_sum_of_subset (fun x \u21a6 ?_)\n  simp [iff_true_intro (@h x)]\n\n-- Simplify the cast of `stackSize C x` from `\u2115` to `\u211d`\nlemma stackSize_real (C : Set (\ud835\udd13 X)) (x : X) : (stackSize C x : \u211d) =\n    \u2211 p \u2208 { p | p \u2208 C }, (\ud835\udcd8 p : Set X).indicator (1 : X \u2192 \u211d) x := by\n  rw [stackSize, Nat.cast_sum]\n  refine Finset.sum_congr rfl (fun u _ \u21a6 ?_)\n  by_cases hx : x \u2208 (\ud835\udcd8 u : Set X) <;> simp [hx]\n\nlemma stackSize_measurable : Measurable fun x \u21a6 (stackSize C x : \u211d\u22650\u221e) := by\n  simp_rw [stackSize, Nat.cast_sum, indicator, Nat.cast_ite]\n  refine Finset.measurable_sum _ fun _ _ \u21a6 Measurable.ite coeGrid_measurable ?_ ?_ <;> simp\n\nlemma stackSize_le_one_of_pairwiseDisjoint {C : Set (\ud835\udd13 X)} {x : X}\n    (h : C.PairwiseDisjoint (fun p \u21a6 (\ud835\udcd8 p : Set X))) : stackSize C x \u2264 1 := by\n  by_cases hx : \u2203 p \u2208 C, x \u2208 (\ud835\udcd8 p : Set X)\n  \u00b7 rcases hx with \u27e8p, pC, hp\u27e9\n    rw [stackSize, Finset.sum_eq_single_of_mem p]; rotate_left\n    \u00b7 simp [pC]\n    \u00b7 intro b hb hbp\n      simp only [indicator_apply_eq_zero, Pi.one_apply, one_ne_zero, imp_false]\n      simp only [Finset.mem_filter, Finset.mem_univ, true_and] at hb\n      exact disjoint_left.1 (h pC hb hbp.symm) hp\n    simp [hp]\n  \u00b7 have : stackSize C x = 0 := by\n      apply Finset.sum_eq_zero (fun p hp \u21a6 ?_)\n      simp only [Finset.mem_filter, Finset.mem_univ, true_and, not_exists, not_and,\n        indicator_apply_eq_zero, Pi.one_apply, one_ne_zero, imp_false] at hp hx \u22a2\n      exact hx _ hp\n    linarith\n\n/-! ### Decomposing a set of tiles into disjoint subfamilies -/\n\n/-- Given any family of tiles, one can extract a maximal disjoint subfamily, covering everything. -/\nlemma exists_maximal_disjoint_covering_subfamily (A : Set (\ud835\udd13 X)) :\n    \u2203 (B : Set (\ud835\udd13 X)), B.PairwiseDisjoint (fun p \u21a6 (\ud835\udcd8 p : Set X)) \u2227\n      B \u2286 A \u2227 (\u2200 a \u2208 A, \u2203 b \u2208 B, (\ud835\udcd8 a : Set X) \u2286 \ud835\udcd8 b) := by\n  -- consider the pairwise disjoint families in `A` such that any element of `A` is disjoint from\n  -- every member of the family, or contained in one of them.\n  let M : Set (Set (\ud835\udd13 X)) := {B | B.PairwiseDisjoint (fun p \u21a6 (\ud835\udcd8 p : Set X)) \u2227 B \u2286 A \u2227 \u2200 a \u2208 A,\n    (\u2203 b \u2208 B, (\ud835\udcd8 a : Set X) \u2286 \ud835\udcd8 b) \u2228 (\u2200 b \u2208 B, Disjoint (\ud835\udcd8 a : Set X) (\ud835\udcd8 b))}\n  -- let `B` be a maximal such family. It satisfies the properties of the lemma.\n  obtain \u27e8B, BM, hB\u27e9 : \u2203 B \u2208 M, \u2200 B' \u2208 M, B \u2286 B' \u2192 B = B' :=\n    Finite.exists_maximal_wrt id _ (toFinite M) \u27e8\u2205, by simp [M]\u27e9\n  refine \u27e8B, BM.1, BM.2.1, fun a ha \u21a6 ?_\u27e9\n  rcases BM.2.2 a ha with h'a | h'a\n  \u00b7 exact h'a\n  exfalso\n  let F := {a' \u2208 A | (\ud835\udcd8 a : Set X) \u2286 \ud835\udcd8 a' \u2227 \u2200 b \u2208 B, Disjoint (\ud835\udcd8 a' : Set X) (\ud835\udcd8 b)}\n  obtain \u27e8a', a'F, ha'\u27e9 : \u2203 a' \u2208 F, \u2200 p \u2208 F, (\ud835\udcd8 a' : Set X) \u2286 \ud835\udcd8 p \u2192 (\ud835\udcd8 a' : Set X) = \ud835\udcd8 p := by\n    apply Finite.exists_maximal_wrt _ _ (toFinite F)\n    exact \u27e8a, by simpa [F, ha] using h'a\u27e9\n  have : insert a' B \u2208 M := by\n    refine \u27e8?_, ?_, fun p hp \u21a6 ?_\u27e9\n    \u00b7 apply PairwiseDisjoint.insert BM.1 (fun b hb h'b \u21a6 a'F.2.2 b hb)\n    \u00b7 apply insert_subset a'F.1 BM.2.1\n    rcases BM.2.2 p hp with \u27e8b, hb\u27e9 | h'p\n    \u00b7 exact Or.inl \u27e8b, mem_insert_of_mem _ hb.1, hb.2\u27e9\n    by_cases Hp : Disjoint (\ud835\udcd8 p : Set X) (\ud835\udcd8 a')\n    \u00b7 right\n      simpa [Hp] using h'p\n    refine Or.inl \u27e8a', mem_insert a' B, ?_\u27e9\n    rcases le_or_ge_or_disjoint (i := \ud835\udcd8 p) (j := \ud835\udcd8 a') with hij | hij |hij\n    \u00b7 exact (Grid.le_def.1 hij).1\n    \u00b7 have : p \u2208 F := \u27e8hp, a'F.2.1.trans (Grid.le_def.1 hij).1, h'p\u27e9\n      rw [ha' p this (Grid.le_def.1 hij).1]\n    \u00b7 exact (Hp hij).elim\n  have : B = insert a' B := hB _ this (subset_insert a' B)\n  have : a' \u2208 B := by rw [this]; exact mem_insert a' B\n  have : Disjoint (\ud835\udcd8 a' : Set X) (\ud835\udcd8 a' : Set X) := a'F.2.2 _ this\n  exact disjoint_left.1 this Grid.c_mem_Grid Grid.c_mem_Grid\n\n/-- A disjoint subfamily of `A` covering everything. -/\ndef maximalSubfamily (A : Set (\ud835\udd13 X)) : Set (\ud835\udd13 X) :=\n  (exists_maximal_disjoint_covering_subfamily A).choose\n\n/-- Iterating `maximalSubfamily` to obtain disjoint subfamilies of `A`. -/\ndef iteratedMaximalSubfamily (A : Set (\ud835\udd13 X)) (n : \u2115) : Set (\ud835\udd13 X) :=\n  maximalSubfamily (A \\ (\u22c3 (i : {i | i < n}), have : i < n := i.2; iteratedMaximalSubfamily A i))\n\n", "theoremStatement": "lemma pairwiseDisjoint_iteratedMaximalSubfamily_image (A : Set (\ud835\udd13 X)) (n : \u2115) :\n    (iteratedMaximalSubfamily A n).PairwiseDisjoint (fun p \u21a6 (\ud835\udcd8 p : Set X)) ", "theoremName": "pairwiseDisjoint_iteratedMaximalSubfamily_image", "fileCreated": {"commit": "b788b2495b5cc06cb8507186eee8b90405f8730a", "date": "2024-07-03"}, "theoremCreated": {"commit": "88d85ba29f717ee3bb9fbd37379a6fb77b57265f", "date": "2025-01-06"}, "file": "carleson/Carleson/TileStructure.lean", "module": "Carleson.TileStructure", "jsonFile": "Carleson.TileStructure.jsonl", "positionMetadata": {"lineInFile": 625, "tokenPositionInFile": 26899, "theoremPositionInFile": 86}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 8, "repositoryPremises": true, "numRepositoryPremises": 20, "numPremises": 68}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [iteratedMaximalSubfamily]\n  exact (exists_maximal_disjoint_covering_subfamily (X := X) _).choose_spec.1", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 115}}
{"srcContext": "import Carleson.Discrete.Defs\nimport Mathlib.Combinatorics.Enumerative.DoubleCounting\nimport Carleson.Antichain.AntichainOperator\nimport Carleson.Discrete.SumEstimates\n\nopen MeasureTheory Measure NNReal Metric Complex Set\nopen scoped ENNReal\nopen Classical -- We use quite some `Finset.filter`\nnoncomputable section\n\nopen scoped ShortVariables\nvariable {X : Type*} {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102} {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X}\n  [MetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] [TileStructure Q D \u03ba S o]\n\nvariable {k n j l : \u2115} {p p' u u' : \ud835\udd13 X} {x : X}\n\n/-! ## Section 5.5 and Lemma 5.1.3 -/\n\n/-- The set \ud835\udd13_{G\\G'} in the blueprint -/\ndef \ud835\udd13pos : Set (\ud835\udd13 X) := { p : \ud835\udd13 X | 0 < volume (\ud835\udcd8 p \u2229 G \u2229 G'\u1d9c) }\n\nlemma exists_mem_aux\ud835\udcd2 {i : Grid X} (hi : 0 < volume (G \u2229 i)) : \u2203 k, i \u2208 aux\ud835\udcd2 (k + 1) := by\n  have vlt : volume (i : Set X) < \u22a4 := volume_coeGrid_lt_top\n  have one_le_quot : 1 \u2264 volume (i : Set X) / volume (G \u2229 i) := by\n    rw [ENNReal.le_div_iff_mul_le (Or.inl hi.ne') (Or.inr vlt.ne), one_mul]\n    exact measure_mono inter_subset_right\n  have quot_ne_top : volume (i : Set X) / volume (G \u2229 i) \u2260 \u22a4 := by\n    rw [Ne, ENNReal.div_eq_top, not_or, not_and_or, not_and_or]\n    exact \u27e8Or.inr hi.ne', Or.inl vlt.ne\u27e9\n  have ornz : 0 < (volume (i : Set X) / volume (G \u2229 i)).toReal :=\n    ENNReal.toReal_pos (zero_lt_one.trans_le one_le_quot).ne' quot_ne_top\n  let k : \u211d := Real.logb 2 (volume (i : Set X) / volume (G \u2229 i)).toReal\n  use \u230ak\u230b\u208a, i, le_rfl\n  nth_rw 1 [\u2190 ENNReal.mul_lt_mul_left (show 2 ^ (\u230ak\u230b\u208a + 1) \u2260 0 by simp) (by simp), \u2190 mul_assoc,\n    \u2190 ENNReal.rpow_natCast, \u2190 ENNReal.rpow_intCast, \u2190 ENNReal.rpow_add _ _ (by simp) (by simp)]\n  rw [Int.cast_neg, Int.cast_natCast, add_neg_cancel, ENNReal.rpow_zero, one_mul,\n    \u2190 ENNReal.div_lt_iff (Or.inl hi.ne') (Or.inr vlt.ne), \u2190 ENNReal.ofReal_toReal quot_ne_top,\n    \u2190 @ENNReal.ofReal_toReal (2 ^ (\u230ak\u230b\u208a + 1)) (by simp), ENNReal.ofReal_lt_ofReal_iff (by simp),\n    ENNReal.toReal_pow, ENNReal.toReal_ofNat, \u2190 Real.rpow_natCast,\n    \u2190 Real.logb_lt_iff_lt_rpow one_lt_two ornz]\n  exact Nat.lt_succ_floor k\n\nlemma exists_k_of_mem_\ud835\udd13pos (h : p \u2208 \ud835\udd13pos (X := X)) : \u2203 k, p \u2208 TilesAt k := by\n  let C : Set \u2115 := {k | \ud835\udcd8 p \u2208 aux\ud835\udcd2 k}\n  have Cn : C.Nonempty := by\n    rw [\ud835\udd13pos, mem_setOf] at h\n    have vpos : 0 < volume (G \u2229 \ud835\udcd8 p) := by\n      rw [inter_comm]; exact h.trans_le (measure_mono inter_subset_left)\n    obtain \u27e8k, hk\u27e9 := exists_mem_aux\ud835\udcd2 vpos; exact \u27e8_, hk\u27e9\n  let s : \u2115 := WellFounded.min wellFounded_lt _ Cn\n  have s_mem : s \u2208 C := WellFounded.min_mem ..\n  have s_min : \u2200 t \u2208 C, s \u2264 t := fun t mt \u21a6 WellFounded.min_le _ mt _\n  have s_pos : 0 < s := by\n    by_contra! h; rw [nonpos_iff_eq_zero] at h\n    simp_rw [h, C, aux\ud835\udcd2, mem_setOf] at s_mem; apply absurd s_mem; push_neg; intro _ _\n    rw [Int.neg_ofNat_zero, zpow_zero, one_mul]; exact measure_mono inter_subset_right\n  use s - 1; rw [TilesAt, mem_preimage, \ud835\udcd2, mem_diff, Nat.sub_add_cancel s_pos]\n  have : \u2200 t < s, t \u2209 C := fun t mt \u21a6 by contrapose! mt; exact s_min t mt\n  exact \u27e8s_mem, this (s - 1) (Nat.sub_one_lt_of_lt s_pos)\u27e9\n\nlemma dens'_le_of_mem_\ud835\udd13pos (h : p \u2208 \ud835\udd13pos (X := X)) : dens' k {p} \u2264 2 ^ (-k : \u2124) := by\n  simp_rw [dens', mem_singleton_iff, iSup_iSup_eq_left, iSup_le_iff]; intro l hl p' mp' sl\n  have vpos : 0 < volume (\ud835\udcd8 p' : Set X) := by\n    refine lt_of_lt_of_le ?_ (measure_mono sl.1.1)\n    rw [\ud835\udd13pos, mem_setOf, inter_assoc] at h; exact h.trans_le (measure_mono inter_subset_left)\n  rw [ENNReal.div_le_iff vpos.ne' volume_coeGrid_lt_top.ne]\n  calc\n    _ \u2264 volume (E\u2082 l p') := by\n      nth_rw 2 [\u2190 one_mul (volume _)]; apply mul_le_mul_right'\n      rw [show 1 = (l : \u211d\u22650\u221e) ^ (0 : \u2124) by simp]; apply ENNReal.zpow_le_of_le\n      \u00b7 rw [ENNReal.one_le_coe_iff]; exact one_le_two.trans hl\n      \u00b7 linarith [four_le_a X]\n    _ \u2264 _ := by\n      have E : E\u2082 l p' \u2286 \ud835\udcd8 p' \u2229 G := inter_subset_left\n      rw [TilesAt, mem_preimage, \ud835\udcd2, mem_diff] at mp'; replace mp' := mp'.2\n      rw [aux\ud835\udcd2, mem_setOf] at mp'; push_neg at mp'; specialize mp' (\ud835\udcd8 p') le_rfl\n      rw [inter_comm] at E; exact (measure_mono E).trans mp'\n\nlemma exists_E\u2082_volume_pos_of_mem_\ud835\udd13pos (h : p \u2208 \ud835\udd13pos (X := X)) : \u2203 r : \u2115, 0 < volume (E\u2082 r p) := by\n  apply exists_measure_pos_of_not_measure_iUnion_null\n  change volume (\u22c3 n : \u2115, \ud835\udcd8 p \u2229 G \u2229 Q \u207b\u00b9' ball_(p) (\ud835\udcac p) n) \u2260 0\n  rw [\u2190 inter_iUnion]\n  suffices \u22c3 i : \u2115, Q \u207b\u00b9' ball_(p) (\ud835\udcac p) i = univ by\n    rw [this, inter_univ, \u2190 pos_iff_ne_zero]\n    rw [\ud835\udd13pos, mem_setOf] at h; exact h.trans_le (measure_mono inter_subset_left)\n  simp_rw [iUnion_eq_univ_iff, mem_preimage, mem_ball]\n  exact fun x \u21a6 exists_nat_gt (dist_(p) (Q x) (\ud835\udcac p))\n\nlemma dens'_pos_of_mem_\ud835\udd13pos (h : p \u2208 \ud835\udd13pos (X := X)) (hp : p \u2208 TilesAt k) : 0 < dens' k {p} := by\n  simp_rw [dens', mem_singleton_iff, iSup_iSup_eq_left, lt_iSup_iff]\n  obtain \u27e8l, hl\u27e9 := exists_E\u2082_volume_pos_of_mem_\ud835\udd13pos h\n  use max 2 l, le_max_left .., p, hp, le_rfl\n  simp_rw [ENNReal.div_pos_iff, ne_eq, mul_eq_zero, not_or, \u2190 ne_eq, \u2190 pos_iff_ne_zero]\n  refine \u27e8\u27e8ENNReal.zpow_pos (by simp) (by simp) _, ?_\u27e9, volume_coeGrid_lt_top.ne\u27e9\n  refine hl.trans_le <| measure_mono <| inter_subset_inter_right _ <| preimage_mono ?_\n  change ball_(p) (\ud835\udcac p) _ \u2286 ball_(p) (\ud835\udcac p) _\n  exact ball_subset_ball (by simp)\n\nlemma exists_k_n_of_mem_\ud835\udd13pos (h : p \u2208 \ud835\udd13pos (X := X)) : \u2203 k n, p \u2208 \u212d k n \u2227 k \u2264 n := by\n  obtain \u27e8k, mp\u27e9 := exists_k_of_mem_\ud835\udd13pos h; use k\n  have dens'_pos : 0 < dens' k {p} := dens'_pos_of_mem_\ud835\udd13pos h mp\n  have dens'_le : dens' k {p} \u2264 2 ^ (-k : \u2124) := dens'_le_of_mem_\ud835\udd13pos h\n  have dens'_lt_top : dens' k {p} < \u22a4 :=\n    dens'_le.trans_lt (ENNReal.zpow_lt_top (by simp) (by simp) _)\n  have dens'_toReal_pos : 0 < (dens' k {p}).toReal :=\n    ENNReal.toReal_pos dens'_pos.ne' dens'_lt_top.ne\n  -- 2 ^ (4 * a - n) < dens' k {p} \u2264 2 ^ (4 * a - n + 1)\n  -- 4 * a - n < log_2 dens' k {p} \u2264 4 * a - n + 1\n  -- -n < log_2 dens' k {p} - 4 * a \u2264 -n + 1\n  -- n - 1 \u2264 4 * a - log_2 dens' k {p} < n\n  -- n \u2264 4 * a - log_2 dens' k {p} + 1 < n + 1\n  -- n = 4 * a + \u230a-log_2 dens' k {p}\u230b + 1\n  let v : \u211d := -Real.logb 2 (dens' k {p}).toReal\n  have klv : k \u2264 v := by\n    rw [le_neg, Real.logb_le_iff_le_rpow one_lt_two dens'_toReal_pos,\n      show (2 : \u211d) = (2 : \u211d\u22650\u221e).toReal by rfl, ENNReal.toReal_rpow,\n      ENNReal.toReal_le_toReal dens'_lt_top.ne (by simp)]\n    exact_mod_cast dens'_le\n  have klq : k \u2264 \u230av\u230b\u208a := Nat.le_floor klv\n  let n : \u2115 := 4 * a + \u230av\u230b\u208a + 1; use n; refine \u27e8\u27e8mp, ?_\u27e9, by omega\u27e9\n  rw [show 4 * (a : \u2124) - (4 * a + \u230av\u230b\u208a + 1 : \u2115) = (-\u230av\u230b\u208a - 1 : \u2124) by omega, sub_add_cancel, mem_Ioc,\n    \u2190 ENNReal.ofReal_toReal dens'_lt_top.ne, \u2190 ENNReal.rpow_intCast, \u2190 ENNReal.rpow_intCast,\n    show (2 : \u211d\u22650\u221e) = ENNReal.ofReal (2 : \u211d) by norm_cast,\n    ENNReal.ofReal_rpow_of_pos zero_lt_two, ENNReal.ofReal_rpow_of_pos zero_lt_two,\n    ENNReal.ofReal_lt_ofReal_iff dens'_toReal_pos, ENNReal.ofReal_le_ofReal_iff (by positivity),\n    \u2190 Real.logb_le_iff_le_rpow one_lt_two dens'_toReal_pos,\n    \u2190 Real.lt_logb_iff_rpow_lt one_lt_two dens'_toReal_pos,\n    Int.cast_sub, Int.cast_neg, Int.cast_natCast, Int.cast_one, neg_sub_left, neg_lt, le_neg]\n  constructor\n  \u00b7 rw [add_comm]; exact_mod_cast Nat.lt_succ_floor _\n  \u00b7 exact Nat.floor_le ((Nat.cast_nonneg' k).trans klv)\n\nprivate lemma two_mul_n_add_six_lt : 2 * n + 6 < 2 ^ (n + 3) := by\n  induction n with\n  | zero => norm_num\n  | succ n ih =>\n    calc\n      _ = 2 * n + 6 + 2 := by ring\n      _ < 2 ^ (n + 3) + 2 := by gcongr\n      _ < 2 ^ (n + 3) + 2 ^ (n + 3) := by omega\n      _ = _ := by ring\n\n", "theoremStatement": "lemma exists_j_of_mem_\ud835\udd13pos_\u212d (h : p \u2208 \ud835\udd13pos (X := X)) (mp : p \u2208 \u212d k n) (hkn : k \u2264 n) :\n    p \u2208 \ud835\udd0f\u2080 k n \u2228 \u2203 j \u2264 2 * n + 3, p \u2208 \u212d\u2081 k n j ", "theoremName": "exists_j_of_mem_\ud835\udd13pos_\u212d", "fileCreated": {"commit": "310e13d16e51600777fc841833f4bce112b5f73a", "date": "2024-09-24"}, "theoremCreated": {"commit": "77d4285c51ebe49f9035715383dfd7aef6aecf25", "date": "2025-01-09"}, "file": "carleson/Carleson/Discrete/ForestComplement.lean", "module": "Carleson.Discrete.ForestComplement", "jsonFile": "Carleson.Discrete.ForestComplement.jsonl", "positionMetadata": {"lineInFile": 143, "tokenPositionInFile": 7379, "theoremPositionInFile": 8}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 41, "numPremises": 322}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [\ud835\udd13pos, mem_setOf, inter_comm _ G'\u1d9c, \u2190 inter_assoc] at h\n  replace h : 0 < volume (G'\u1d9c \u2229 (\ud835\udcd8 p : Set X)) := h.trans_le (measure_mono inter_subset_left)\n  rw [inter_comm, G', compl_union, compl_union, inter_comm G\u2081\u1d9c, \u2190 inter_assoc, \u2190 inter_assoc] at h\n  replace h : 0 < volume ((\ud835\udcd8 p : Set X) \u2229 G\u2082\u1d9c) :=\n    h.trans_le (measure_mono (inter_subset_left.trans inter_subset_left))\n  obtain \u27e8x, mx, nx\u27e9 := nonempty_of_measure_ne_zero h.ne'\n  simp_rw [G\u2082, mem_compl_iff, mem_iUnion] at nx; push_neg at nx; specialize nx n k hkn\n  let B : \u2115 := Finset.card { q | q \u2208 \ud835\udd05 k n p }\n  have Blt : B < 2 ^ (2 * n + 4) := by\n    calc\n      _ \u2264 Finset.card { m | m \u2208 \ud835\udd10 k n \u2227 x \u2208 \ud835\udcd8 m } :=\n        Finset.card_le_card (Finset.monotone_filter_right _ (Pi.le_def.mpr fun m \u27e8m\u2081, m\u2082\u27e9 \u21a6\n          \u27e8m\u2081, m\u2082.1.1 mx\u27e9))\n      _ = stackSize (\ud835\udd10 k n) x := by\n        simp_rw [stackSize, indicator_apply, Pi.one_apply, Finset.sum_boole, Nat.cast_id,\n          Finset.filter_filter]; rfl\n      _ \u2264 (2 * n + 6) * 2 ^ (n + 1) := by rwa [setA, mem_setOf, not_lt] at nx\n      _ < _ := by\n        rw [show 2 * n + 4 = (n + 3) + (n + 1) by omega, pow_add _ (n + 3)]\n        exact mul_lt_mul_of_pos_right two_mul_n_add_six_lt (by positivity)\n  rcases B.eq_zero_or_pos with Bz | Bpos\n  \u00b7 simp_rw [B, filter_mem_univ_eq_toFinset, Finset.card_eq_zero, toFinset_eq_empty] at Bz\n    exact Or.inl \u27e8mp, Bz\u27e9\n  \u00b7 right; use Nat.log 2 B; rw [Nat.lt_pow_iff_log_lt one_lt_two Bpos.ne'] at Blt\n    refine \u27e8by omega, (?_ : _ \u2227 _ \u2264 B), (?_ : \u00ac(_ \u2227 _ \u2264 B))\u27e9\n    \u00b7 exact \u27e8mp, Nat.pow_log_le_self 2 Bpos.ne'\u27e9\n    \u00b7 rw [not_and, not_le]; exact fun _ \u21a6 Nat.lt_pow_succ_log_self one_lt_two _", "proofType": "tactic", "proofLengthLines": 27, "proofLengthTokens": 1636}}
{"srcContext": "import Carleson.GridStructure\nimport Carleson.Psi\nimport Carleson.ToMathlib.BoundedCompactSupport\n\nopen Set MeasureTheory Metric Function Complex Bornology\nopen scoped NNReal ENNReal ComplexConjugate\nnoncomputable section\n\nsection Generic\nuniverse u\nvariable {\ud835\udd5c : Type*} [_root_.RCLike \ud835\udd5c]\nvariable {X : Type u} {A : \u211d\u22650} [PseudoMetricSpace X] [DoublingMeasure X A]\n\n/- The data in a tile structure, and some basic properties.\nThis is mostly separated out so that we can nicely define the notation `d_\ud835\udd2d`.\nNote: compose `\ud835\udcd8` with `Grid` to get the `\ud835\udcd8` of the paper. -/\nclass PreTileStructure {A : outParam \u211d\u22650} [PseudoMetricSpace X] [DoublingMeasure X A]\n  [FunctionDistances \ud835\udd5c X] (Q : outParam (SimpleFunc X (\u0398 X)))\n  (D : outParam \u2115) (\u03ba : outParam \u211d) (S : outParam \u2115) (o : outParam X)\n  extends GridStructure X D \u03ba S o where\n  protected \ud835\udd13 : Type u\n  fintype_\ud835\udd13 : Fintype \ud835\udd13\n  protected \ud835\udcd8 : \ud835\udd13 \u2192 Grid\n  surjective_\ud835\udcd8 : Surjective \ud835\udcd8\n  \ud835\udcac : \ud835\udd13 \u2192 \u0398 X\n  range_\ud835\udcac : range \ud835\udcac \u2286 range Q\n\nexport PreTileStructure (\ud835\udcac range_\ud835\udcac)\n\nvariable {D : \u2115} {\u03ba : \u211d} {S : \u2115} {o : X}\nvariable [FunctionDistances \ud835\udd5c X]  {Q : SimpleFunc X (\u0398 X)} [PreTileStructure Q D \u03ba S o]\n\nvariable (X) in\ndef \ud835\udd13 := PreTileStructure.\ud835\udd13 \ud835\udd5c X\ninstance : Fintype (\ud835\udd13 X) := PreTileStructure.fintype_\ud835\udd13\ndef \ud835\udcd8 : \ud835\udd13 X \u2192 Grid X := PreTileStructure.\ud835\udcd8\nlemma surjective_\ud835\udcd8 : Surjective (\ud835\udcd8 : \ud835\udd13 X \u2192 Grid X) := PreTileStructure.surjective_\ud835\udcd8\ninstance : Inhabited (\ud835\udd13 X) := \u27e8(surjective_\ud835\udcd8 default).choose\u27e9\ndef \ud835\udd20 (p : \ud835\udd13 X) : X := c (\ud835\udcd8 p)\ndef \ud835\udd30 (p : \ud835\udd13 X) : \u2124 := s (\ud835\udcd8 p)\n\nlocal notation \"ball_(\" D \",\" \ud835\udd2d \")\" => @ball (WithFunctionDistance (\ud835\udd20 \ud835\udd2d) (D ^ \ud835\udd30 \ud835\udd2d / 4)) _\n\n/-- A tile structure. -/\n-- note: we don't explicitly include injectivity of `\u03a9` on `\ud835\udd13(I)`, since it follows from these\n-- axioms: see `toTileLike_injective`\nclass TileStructure {A : outParam \u211d\u22650} [PseudoMetricSpace X] [DoublingMeasure X A]\n    [FunctionDistances \u211d X] (Q : outParam (SimpleFunc X (\u0398 X)))\n    (D : outParam \u2115) (\u03ba : outParam \u211d) (S : outParam \u2115) (o : outParam X)\n    extends PreTileStructure Q D \u03ba S o where\n  \u03a9 : \ud835\udd13 \u2192 Set (\u0398 X)\n  biUnion_\u03a9 {i} : range Q \u2286 \u22c3 p \u2208 \ud835\udcd8 \u207b\u00b9' {i}, \u03a9 p -- 2.0.13, union contains `Q`\n  disjoint_\u03a9 {p p'} (h : p \u2260 p') (hp : \ud835\udcd8 p = \ud835\udcd8 p') : -- 2.0.13, union is disjoint\n    Disjoint (\u03a9 p) (\u03a9 p')\n  relative_fundamental_dyadic {p p'} (h : \ud835\udcd8 p \u2264 \ud835\udcd8 p') : -- 2.0.14\n    Disjoint (\u03a9 p) (\u03a9 p') \u2228 \u03a9 p' \u2286 \u03a9 p\n  cball_subset {p} : ball_(D, p) (\ud835\udcac p) 5\u207b\u00b9 \u2286 \u03a9 p -- 2.0.15, first inclusion\n  subset_cball {p} : \u03a9 p \u2286 ball_(D, p) (\ud835\udcac p) 1 -- 2.0.15, second inclusion\n\nexport TileStructure (\u03a9 biUnion_\u03a9 disjoint_\u03a9 relative_fundamental_dyadic)\n\nend Generic\n\n\nopen scoped ShortVariables\nvariable {X : Type*} [PseudoMetricSpace X] {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102}\n  {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X} [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G]\n\nsection\n\nvariable [TileStructure Q D \u03ba S o] {p p' : \ud835\udd13 X} {f g : \u0398 X}\n\n-- maybe we should delete the following three notations, and use `dist_{\ud835\udcd8 p}` instead?\nnotation \"dist_(\" \ud835\udd2d \")\" => @dist (WithFunctionDistance (\ud835\udd20 \ud835\udd2d) (D ^ \ud835\udd30 \ud835\udd2d / 4)) _\nnotation \"nndist_(\" \ud835\udd2d \")\" => @nndist (WithFunctionDistance (\ud835\udd20 \ud835\udd2d) (D ^ \ud835\udd30 \ud835\udd2d / 4)) _\nnotation \"ball_(\" \ud835\udd2d \")\" => @ball (WithFunctionDistance (\ud835\udd20 \ud835\udd2d) (D ^ \ud835\udd30 \ud835\udd2d / 4)) _\n\n\n@[simp] lemma dist_\ud835\udcd8 (p : \ud835\udd13 X) : dist_{\ud835\udcd8 p} f g = dist_(p) f g := rfl\n@[simp] lemma nndist_\ud835\udcd8 (p : \ud835\udd13 X) : nndist_{\ud835\udcd8 p} f g = nndist_(p) f g := rfl\n@[simp] lemma ball_\ud835\udcd8 (p : \ud835\udd13 X) {r : \u211d} : ball_{\ud835\udcd8 p} f r = ball_(p) f r := rfl\n\n@[simp] lemma cball_subset {p : \ud835\udd13 X} : ball_(p) (\ud835\udcac p) 5\u207b\u00b9 \u2286 \u03a9 p := TileStructure.cball_subset\n@[simp] lemma subset_cball {p : \ud835\udd13 X} : \u03a9 p \u2286 ball_(p) (\ud835\udcac p) 1 := TileStructure.subset_cball\n\n", "theoremStatement": "lemma ball_eq_of_grid_eq {p q : \ud835\udd13 X} {\u03d1 : \u0398 X} {r : \u211d} (h : \ud835\udcd8 p = \ud835\udcd8 q) :\n    ball_(p) \u03d1 r = ball_(q) \u03d1 r ", "theoremName": "ball_eq_of_grid_eq", "fileCreated": {"commit": "b788b2495b5cc06cb8507186eee8b90405f8730a", "date": "2024-07-03"}, "theoremCreated": {"commit": "d0d69eeea3eccc4dac0fa34394fb0de483afe375", "date": "2024-12-05"}, "file": "carleson/Carleson/TileStructure.lean", "module": "Carleson.TileStructure", "jsonFile": "Carleson.TileStructure.jsonl", "positionMetadata": {"lineInFile": 86, "tokenPositionInFile": 3531, "theoremPositionInFile": 13}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 8, "repositoryPremises": true, "numRepositoryPremises": 25, "numPremises": 62}, "proofMetadata": {"hasProof": true, "proof": ":= by rw [\u2190 ball_\ud835\udcd8, h]", "proofType": "tactic", "proofLengthLines": 0, "proofLengthTokens": 22}}
{"srcContext": "import Carleson.Discrete.Defs\nimport Mathlib.Combinatorics.Enumerative.DoubleCounting\nimport Carleson.Antichain.AntichainOperator\nimport Carleson.Discrete.SumEstimates\n\nopen MeasureTheory Measure NNReal Metric Complex Set\nopen scoped ENNReal\nopen Classical -- We use quite some `Finset.filter`\nnoncomputable section\n\nopen scoped ShortVariables\nvariable {X : Type*} {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102} {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X}\n  [MetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] [TileStructure Q D \u03ba S o]\n\nvariable {k n j l : \u2115} {p p' u u' : \ud835\udd13 X} {x : X}\n\n/-! ## Section 5.5 and Lemma 5.1.3 -/\n\n/-- The set \ud835\udd13_{G\\G'} in the blueprint -/\ndef \ud835\udd13pos : Set (\ud835\udd13 X) := { p : \ud835\udd13 X | 0 < volume (\ud835\udcd8 p \u2229 G \u2229 G'\u1d9c) }\n\nlemma exists_mem_aux\ud835\udcd2 {i : Grid X} (hi : 0 < volume (G \u2229 i)) : \u2203 k, i \u2208 aux\ud835\udcd2 (k + 1) := by\n  have vlt : volume (i : Set X) < \u22a4 := volume_coeGrid_lt_top\n  have one_le_quot : 1 \u2264 volume (i : Set X) / volume (G \u2229 i) := by\n    rw [ENNReal.le_div_iff_mul_le (Or.inl hi.ne') (Or.inr vlt.ne), one_mul]\n    exact measure_mono inter_subset_right\n  have quot_ne_top : volume (i : Set X) / volume (G \u2229 i) \u2260 \u22a4 := by\n    rw [Ne, ENNReal.div_eq_top, not_or, not_and_or, not_and_or]\n    exact \u27e8Or.inr hi.ne', Or.inl vlt.ne\u27e9\n  have ornz : 0 < (volume (i : Set X) / volume (G \u2229 i)).toReal :=\n    ENNReal.toReal_pos (zero_lt_one.trans_le one_le_quot).ne' quot_ne_top\n  let k : \u211d := Real.logb 2 (volume (i : Set X) / volume (G \u2229 i)).toReal\n  use \u230ak\u230b\u208a, i, le_rfl\n  nth_rw 1 [\u2190 ENNReal.mul_lt_mul_left (show 2 ^ (\u230ak\u230b\u208a + 1) \u2260 0 by simp) (by simp), \u2190 mul_assoc,\n    \u2190 ENNReal.rpow_natCast, \u2190 ENNReal.rpow_intCast, \u2190 ENNReal.rpow_add _ _ (by simp) (by simp)]\n  rw [Int.cast_neg, Int.cast_natCast, add_neg_cancel, ENNReal.rpow_zero, one_mul,\n    \u2190 ENNReal.div_lt_iff (Or.inl hi.ne') (Or.inr vlt.ne), \u2190 ENNReal.ofReal_toReal quot_ne_top,\n    \u2190 @ENNReal.ofReal_toReal (2 ^ (\u230ak\u230b\u208a + 1)) (by simp), ENNReal.ofReal_lt_ofReal_iff (by simp),\n    ENNReal.toReal_pow, ENNReal.toReal_ofNat, \u2190 Real.rpow_natCast,\n    \u2190 Real.logb_lt_iff_lt_rpow one_lt_two ornz]\n  exact Nat.lt_succ_floor k\n\nlemma exists_k_of_mem_\ud835\udd13pos (h : p \u2208 \ud835\udd13pos (X := X)) : \u2203 k, p \u2208 TilesAt k := by\n  let C : Set \u2115 := {k | \ud835\udcd8 p \u2208 aux\ud835\udcd2 k}\n  have Cn : C.Nonempty := by\n    rw [\ud835\udd13pos, mem_setOf] at h\n    have vpos : 0 < volume (G \u2229 \ud835\udcd8 p) := by\n      rw [inter_comm]; exact h.trans_le (measure_mono inter_subset_left)\n    obtain \u27e8k, hk\u27e9 := exists_mem_aux\ud835\udcd2 vpos; exact \u27e8_, hk\u27e9\n  let s : \u2115 := WellFounded.min wellFounded_lt _ Cn\n  have s_mem : s \u2208 C := WellFounded.min_mem ..\n  have s_min : \u2200 t \u2208 C, s \u2264 t := fun t mt \u21a6 WellFounded.min_le _ mt _\n  have s_pos : 0 < s := by\n    by_contra! h; rw [nonpos_iff_eq_zero] at h\n    simp_rw [h, C, aux\ud835\udcd2, mem_setOf] at s_mem; apply absurd s_mem; push_neg; intro _ _\n    rw [Int.neg_ofNat_zero, zpow_zero, one_mul]; exact measure_mono inter_subset_right\n  use s - 1; rw [TilesAt, mem_preimage, \ud835\udcd2, mem_diff, Nat.sub_add_cancel s_pos]\n  have : \u2200 t < s, t \u2209 C := fun t mt \u21a6 by contrapose! mt; exact s_min t mt\n  exact \u27e8s_mem, this (s - 1) (Nat.sub_one_lt_of_lt s_pos)\u27e9\n\nlemma dens'_le_of_mem_\ud835\udd13pos (h : p \u2208 \ud835\udd13pos (X := X)) : dens' k {p} \u2264 2 ^ (-k : \u2124) := by\n  simp_rw [dens', mem_singleton_iff, iSup_iSup_eq_left, iSup_le_iff]; intro l hl p' mp' sl\n  have vpos : 0 < volume (\ud835\udcd8 p' : Set X) := by\n    refine lt_of_lt_of_le ?_ (measure_mono sl.1.1)\n    rw [\ud835\udd13pos, mem_setOf, inter_assoc] at h; exact h.trans_le (measure_mono inter_subset_left)\n  rw [ENNReal.div_le_iff vpos.ne' volume_coeGrid_lt_top.ne]\n  calc\n    _ \u2264 volume (E\u2082 l p') := by\n      nth_rw 2 [\u2190 one_mul (volume _)]; apply mul_le_mul_right'\n      rw [show 1 = (l : \u211d\u22650\u221e) ^ (0 : \u2124) by simp]; apply ENNReal.zpow_le_of_le\n      \u00b7 rw [ENNReal.one_le_coe_iff]; exact one_le_two.trans hl\n      \u00b7 linarith [four_le_a X]\n    _ \u2264 _ := by\n      have E : E\u2082 l p' \u2286 \ud835\udcd8 p' \u2229 G := inter_subset_left\n      rw [TilesAt, mem_preimage, \ud835\udcd2, mem_diff] at mp'; replace mp' := mp'.2\n      rw [aux\ud835\udcd2, mem_setOf] at mp'; push_neg at mp'; specialize mp' (\ud835\udcd8 p') le_rfl\n      rw [inter_comm] at E; exact (measure_mono E).trans mp'\n\nlemma exists_E\u2082_volume_pos_of_mem_\ud835\udd13pos (h : p \u2208 \ud835\udd13pos (X := X)) : \u2203 r : \u2115, 0 < volume (E\u2082 r p) := by\n  apply exists_measure_pos_of_not_measure_iUnion_null\n  change volume (\u22c3 n : \u2115, \ud835\udcd8 p \u2229 G \u2229 Q \u207b\u00b9' ball_(p) (\ud835\udcac p) n) \u2260 0\n  rw [\u2190 inter_iUnion]\n  suffices \u22c3 i : \u2115, Q \u207b\u00b9' ball_(p) (\ud835\udcac p) i = univ by\n    rw [this, inter_univ, \u2190 pos_iff_ne_zero]\n    rw [\ud835\udd13pos, mem_setOf] at h; exact h.trans_le (measure_mono inter_subset_left)\n  simp_rw [iUnion_eq_univ_iff, mem_preimage, mem_ball]\n  exact fun x \u21a6 exists_nat_gt (dist_(p) (Q x) (\ud835\udcac p))\n\nlemma dens'_pos_of_mem_\ud835\udd13pos (h : p \u2208 \ud835\udd13pos (X := X)) (hp : p \u2208 TilesAt k) : 0 < dens' k {p} := by\n  simp_rw [dens', mem_singleton_iff, iSup_iSup_eq_left, lt_iSup_iff]\n  obtain \u27e8l, hl\u27e9 := exists_E\u2082_volume_pos_of_mem_\ud835\udd13pos h\n  use max 2 l, le_max_left .., p, hp, le_rfl\n  simp_rw [ENNReal.div_pos_iff, ne_eq, mul_eq_zero, not_or, \u2190 ne_eq, \u2190 pos_iff_ne_zero]\n  refine \u27e8\u27e8ENNReal.zpow_pos (by simp) (by simp) _, ?_\u27e9, volume_coeGrid_lt_top.ne\u27e9\n  refine hl.trans_le <| measure_mono <| inter_subset_inter_right _ <| preimage_mono ?_\n  change ball_(p) (\ud835\udcac p) _ \u2286 ball_(p) (\ud835\udcac p) _\n  exact ball_subset_ball (by simp)\n\nlemma exists_k_n_of_mem_\ud835\udd13pos (h : p \u2208 \ud835\udd13pos (X := X)) : \u2203 k n, p \u2208 \u212d k n \u2227 k \u2264 n := by\n  obtain \u27e8k, mp\u27e9 := exists_k_of_mem_\ud835\udd13pos h; use k\n  have dens'_pos : 0 < dens' k {p} := dens'_pos_of_mem_\ud835\udd13pos h mp\n  have dens'_le : dens' k {p} \u2264 2 ^ (-k : \u2124) := dens'_le_of_mem_\ud835\udd13pos h\n  have dens'_lt_top : dens' k {p} < \u22a4 :=\n    dens'_le.trans_lt (ENNReal.zpow_lt_top (by simp) (by simp) _)\n  have dens'_toReal_pos : 0 < (dens' k {p}).toReal :=\n    ENNReal.toReal_pos dens'_pos.ne' dens'_lt_top.ne\n  -- 2 ^ (4 * a - n) < dens' k {p} \u2264 2 ^ (4 * a - n + 1)\n  -- 4 * a - n < log_2 dens' k {p} \u2264 4 * a - n + 1\n  -- -n < log_2 dens' k {p} - 4 * a \u2264 -n + 1\n  -- n - 1 \u2264 4 * a - log_2 dens' k {p} < n\n  -- n \u2264 4 * a - log_2 dens' k {p} + 1 < n + 1\n  -- n = 4 * a + \u230a-log_2 dens' k {p}\u230b + 1\n  let v : \u211d := -Real.logb 2 (dens' k {p}).toReal\n  have klv : k \u2264 v := by\n    rw [le_neg, Real.logb_le_iff_le_rpow one_lt_two dens'_toReal_pos,\n      show (2 : \u211d) = (2 : \u211d\u22650\u221e).toReal by rfl, ENNReal.toReal_rpow,\n      ENNReal.toReal_le_toReal dens'_lt_top.ne (by simp)]\n    exact_mod_cast dens'_le\n  have klq : k \u2264 \u230av\u230b\u208a := Nat.le_floor klv\n  let n : \u2115 := 4 * a + \u230av\u230b\u208a + 1; use n; refine \u27e8\u27e8mp, ?_\u27e9, by omega\u27e9\n  rw [show 4 * (a : \u2124) - (4 * a + \u230av\u230b\u208a + 1 : \u2115) = (-\u230av\u230b\u208a - 1 : \u2124) by omega, sub_add_cancel, mem_Ioc,\n    \u2190 ENNReal.ofReal_toReal dens'_lt_top.ne, \u2190 ENNReal.rpow_intCast, \u2190 ENNReal.rpow_intCast,\n    show (2 : \u211d\u22650\u221e) = ENNReal.ofReal (2 : \u211d) by norm_cast,\n    ENNReal.ofReal_rpow_of_pos zero_lt_two, ENNReal.ofReal_rpow_of_pos zero_lt_two,\n    ENNReal.ofReal_lt_ofReal_iff dens'_toReal_pos, ENNReal.ofReal_le_ofReal_iff (by positivity),\n    \u2190 Real.logb_le_iff_le_rpow one_lt_two dens'_toReal_pos,\n    \u2190 Real.lt_logb_iff_rpow_lt one_lt_two dens'_toReal_pos,\n    Int.cast_sub, Int.cast_neg, Int.cast_natCast, Int.cast_one, neg_sub_left, neg_lt, le_neg]\n  constructor\n  \u00b7 rw [add_comm]; exact_mod_cast Nat.lt_succ_floor _\n  \u00b7 exact Nat.floor_le ((Nat.cast_nonneg' k).trans klv)\n\nprivate lemma two_mul_n_add_six_lt : 2 * n + 6 < 2 ^ (n + 3) := by\n  induction n with\n  | zero => norm_num\n  | succ n ih =>\n    calc\n      _ = 2 * n + 6 + 2 := by ring\n      _ < 2 ^ (n + 3) + 2 := by gcongr\n      _ < 2 ^ (n + 3) + 2 ^ (n + 3) := by omega\n      _ = _ := by ring\n\nlemma exists_j_of_mem_\ud835\udd13pos_\u212d (h : p \u2208 \ud835\udd13pos (X := X)) (mp : p \u2208 \u212d k n) (hkn : k \u2264 n) :\n    p \u2208 \ud835\udd0f\u2080 k n \u2228 \u2203 j \u2264 2 * n + 3, p \u2208 \u212d\u2081 k n j := by\n  rw [\ud835\udd13pos, mem_setOf, inter_comm _ G'\u1d9c, \u2190 inter_assoc] at h\n  replace h : 0 < volume (G'\u1d9c \u2229 (\ud835\udcd8 p : Set X)) := h.trans_le (measure_mono inter_subset_left)\n  rw [inter_comm, G', compl_union, compl_union, inter_comm G\u2081\u1d9c, \u2190 inter_assoc, \u2190 inter_assoc] at h\n  replace h : 0 < volume ((\ud835\udcd8 p : Set X) \u2229 G\u2082\u1d9c) :=\n    h.trans_le (measure_mono (inter_subset_left.trans inter_subset_left))\n  obtain \u27e8x, mx, nx\u27e9 := nonempty_of_measure_ne_zero h.ne'\n  simp_rw [G\u2082, mem_compl_iff, mem_iUnion] at nx; push_neg at nx; specialize nx n k hkn\n  let B : \u2115 := Finset.card { q | q \u2208 \ud835\udd05 k n p }\n  have Blt : B < 2 ^ (2 * n + 4) := by\n    calc\n      _ \u2264 Finset.card { m | m \u2208 \ud835\udd10 k n \u2227 x \u2208 \ud835\udcd8 m } :=\n        Finset.card_le_card (Finset.monotone_filter_right _ (Pi.le_def.mpr fun m \u27e8m\u2081, m\u2082\u27e9 \u21a6\n          \u27e8m\u2081, m\u2082.1.1 mx\u27e9))\n      _ = stackSize (\ud835\udd10 k n) x := by\n        simp_rw [stackSize, indicator_apply, Pi.one_apply, Finset.sum_boole, Nat.cast_id,\n          Finset.filter_filter]; rfl\n      _ \u2264 (2 * n + 6) * 2 ^ (n + 1) := by rwa [setA, mem_setOf, not_lt] at nx\n      _ < _ := by\n        rw [show 2 * n + 4 = (n + 3) + (n + 1) by omega, pow_add _ (n + 3)]\n        exact mul_lt_mul_of_pos_right two_mul_n_add_six_lt (by positivity)\n  rcases B.eq_zero_or_pos with Bz | Bpos\n  \u00b7 simp_rw [B, filter_mem_univ_eq_toFinset, Finset.card_eq_zero, toFinset_eq_empty] at Bz\n    exact Or.inl \u27e8mp, Bz\u27e9\n  \u00b7 right; use Nat.log 2 B; rw [Nat.lt_pow_iff_log_lt one_lt_two Bpos.ne'] at Blt\n    refine \u27e8by omega, (?_ : _ \u2227 _ \u2264 B), (?_ : \u00ac(_ \u2227 _ \u2264 B))\u27e9\n    \u00b7 exact \u27e8mp, Nat.pow_log_le_self 2 Bpos.ne'\u27e9\n    \u00b7 rw [not_and, not_le]; exact fun _ \u21a6 Nat.lt_pow_succ_log_self one_lt_two _\n\nlemma exists_k_n_j_of_mem_\ud835\udd13pos (h : p \u2208 \ud835\udd13pos (X := X)) :\n    \u2203 k n, k \u2264 n \u2227 (p \u2208 \ud835\udd0f\u2080 k n \u2228 \u2203 j \u2264 2 * n + 3, p \u2208 \u212d\u2081 k n j) := by\n  obtain \u27e8k, n, mp, hkn\u27e9 := exists_k_n_of_mem_\ud835\udd13pos h\n  exact \u27e8k, n, hkn, exists_j_of_mem_\ud835\udd13pos_\u212d h mp hkn\u27e9\n\n/-- The union occurring in the statement of Lemma 5.5.1 containing \ud835\udd0f\u2080 -/\ndef \u211c\u2080 : Set (\ud835\udd13 X) := \ud835\udd13pos \u2229 \u22c3 (n : \u2115) (k \u2264 n), \ud835\udd0f\u2080 k n\n\n/-- The union occurring in the statement of Lemma 5.5.1 containing \ud835\udd0f\u2081 -/\ndef \u211c\u2081 : Set (\ud835\udd13 X) := \ud835\udd13pos \u2229 \u22c3 (n : \u2115) (k \u2264 n) (j \u2264 2 * n + 3) (l \u2264 Z * (n + 1)), \ud835\udd0f\u2081 k n j l\n\n/-- The union occurring in the statement of Lemma 5.5.1 containing \ud835\udd0f\u2082 -/\ndef \u211c\u2082 : Set (\ud835\udd13 X) := \ud835\udd13pos \u2229 \u22c3 (n : \u2115) (k \u2264 n) (j \u2264 2 * n + 3), \ud835\udd0f\u2082 k n j\n\n/-- The union occurring in the statement of Lemma 5.5.1 containing \ud835\udd0f\u2083 -/\ndef \u211c\u2083 : Set (\ud835\udd13 X) := \ud835\udd13pos \u2229 \u22c3 (n : \u2115) (k \u2264 n) (j \u2264 2 * n + 3) (l \u2264 Z * (n + 1)), \ud835\udd0f\u2083 k n j l\n\n/-- Lemma allowing to peel `\u22c3 (n : \u2115) (k \u2264 n)` from unions in the proof of Lemma 5.5.1. -/\nlemma mem_iUnion_iff_mem_of_mem_\u212d {f : \u2115 \u2192 \u2115 \u2192 Set (\ud835\udd13 X)} (hp : p \u2208 \u212d k n \u2227 k \u2264 n)\n    (hf : \u2200 k n, f k n \u2286 \u212d k n) : p \u2208 \u22c3 (n : \u2115) (k \u2264 n), f k n \u2194 p \u2208 f k n := by\n  simp_rw [mem_iUnion]; constructor <;> intro h\n  \u00b7 obtain \u27e8n', k', _, mp\u27e9 := h\n    have e := pairwiseDisjoint_\u212d (X := X).elim (mem_univ (k, n)) (mem_univ (k', n'))\n      (not_disjoint_iff.mpr \u27e8p, hp.1, hf k' n' mp\u27e9)\n    rw [Prod.mk.inj_iff] at e\n    exact e.1 \u25b8 e.2 \u25b8 mp\n  \u00b7 use n, k, hp.2\n\n/-- Lemma allowing to peel `\u22c3 (j \u2264 2 * n + 3)` from unions in the proof of Lemma 5.5.1. -/\nlemma mem_iUnion_iff_mem_of_mem_\u212d\u2081 {f : \u2115 \u2192 Set (\ud835\udd13 X)} (hp : p \u2208 \u212d\u2081 k n j \u2227 j \u2264 2 * n + 3)\n    (hf : \u2200 j, f j \u2286 \u212d\u2081 k n j) : p \u2208 \u22c3 (j \u2264 2 * n + 3), f j \u2194 p \u2208 f j := by\n  simp_rw [mem_iUnion]; constructor <;> intro h\n  \u00b7 obtain \u27e8j', _, mp\u27e9 := h\n    have e := pairwiseDisjoint_\u212d\u2081 (X := X).elim (mem_univ j) (mem_univ j')\n      (not_disjoint_iff.mpr \u27e8p, hp.1, hf j' mp\u27e9)\n    exact e \u25b8 mp\n  \u00b7 use j, hp.2\n\nlemma nmem_\u212d\u2085_iff_mem_\ud835\udd0f\u2083 (hkn : k \u2264 n) (hj : j \u2264 2 * n + 3)\n    (h : p \u2208 \ud835\udd13pos) (mc2 : p \u2208 \u212d\u2082 k n j) (ml2 : p \u2209 \ud835\udd0f\u2082 k n j) :\n    p \u2209 \u212d\u2085 k n j \u2194 p \u2208 \u22c3 l, \u22c3 (_ : l \u2264 Z * (n + 1)), \ud835\udd0f\u2083 k n j l := by\n  have mc3 : p \u2208 \u212d\u2083 k n j := \u27e8mc2, ml2\u27e9\n  by_cases mc4 : p \u2209 \u212d\u2084 k n j\n  all_goals\n    have mc4' := mc4\n    simp_rw [\u212d\u2084, layersBelow, mem_diff, not_and, mc3, true_implies, not_not_mem] at mc4'\n  \u00b7 change p \u2208 \u22c3 (l \u2264 Z * (n + 1)), \ud835\udd0f\u2083 k n j l at mc4'\n    simp_rw [mc4', iff_true]; contrapose! mc4\n    exact \u212d\u2085_subset_\u212d\u2084 mc4\n  change p \u2209 \u22c3 (l \u2264 Z * (n + 1)), \ud835\udd0f\u2083 k n j l at mc4'\n  simp_rw [mc4', iff_false, \u212d\u2085]; rw [not_not_mem] at mc4 \u22a2; simp_rw [mem_diff, mc4, true_and]\n  have nG\u2083 : \u00ac(\ud835\udcd8 p : Set X) \u2286 G\u2083 := by\n    suffices \u00ac(\ud835\udcd8 p : Set X) \u2286 G' by contrapose! this; exact subset_union_of_subset_right this _\n    by_contra hv\n    rw [\ud835\udd13pos, mem_setOf, inter_comm _ G'\u1d9c, \u2190 inter_assoc, \u2190 diff_eq_compl_inter,\n      diff_eq_empty.mpr hv] at h\n    simp at h\n  contrapose! nG\u2083\n  exact le_iSup\u2082_of_le n k <| le_iSup\u2082_of_le hkn j <|\n    le_iSup\u2082_of_le hj p <| le_iSup_of_le nG\u2083 Subset.rfl\n\n\n/-- Lemma 5.5.1.\n\nWe will not use the lemma in this form, as to decompose the Carleson sum it is also crucial that\nthe union is disjoint. This is easier to formalize by decomposing into successive terms, taking\nadvantage of disjointess at each step, instead of doing everything in one go. Still, we keep this\nlemma as it corresponds to the blueprint, and the key steps of its proof will also be the key steps\nwhen doing the successive decompositions.\n -/\nlemma antichain_decomposition : \ud835\udd13pos (X := X) \u2229 \ud835\udd13\u2081\u1d9c = \u211c\u2080 \u222a \u211c\u2081 \u222a \u211c\u2082 \u222a \u211c\u2083 := by\n  unfold \u211c\u2080 \u211c\u2081 \u211c\u2082 \u211c\u2083 \ud835\udd13\u2081; simp_rw [\u2190 inter_union_distrib_left]; ext p\n  simp_rw [mem_inter_iff, and_congr_right_iff, mem_compl_iff, mem_union]; intro h\n  obtain \u27e8k, n, hkn, split\u27e9 := exists_k_n_j_of_mem_\ud835\udd13pos h\n  have pc : p \u2208 \u212d k n := by\n    rcases split with ml0 | \u27e8_, _, mc1\u27e9\n    \u00b7 exact \ud835\udd0f\u2080_subset_\u212d ml0\n    \u00b7 exact \u212d\u2081_subset_\u212d mc1\n  iterate 5 rw [mem_iUnion_iff_mem_of_mem_\u212d \u27e8pc, hkn\u27e9]\n  pick_goal 5; \u00b7 exact fun _ _ \u21a6 \ud835\udd0f\u2080_subset_\u212d\n  pick_goal 4; \u00b7 exact fun _ _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 \ud835\udd0f\u2081_subset_\u212d\n  pick_goal 3; \u00b7 exact fun _ _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 \ud835\udd0f\u2082_subset_\u212d\n  pick_goal 2; \u00b7 exact fun _ _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 \ud835\udd0f\u2083_subset_\u212d\n  pick_goal -1; \u00b7 exact fun _ _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 \u212d\u2085_subset_\u212d\n  by_cases ml0 : p \u2208 \ud835\udd0f\u2080 k n\n  \u00b7 simp_rw [ml0, true_or, iff_true, mem_iUnion\u2082]; push_neg; intros\n    exact fun a \u21a6 disjoint_left.mp \ud835\udd0f\u2080_disjoint_\u212d\u2081 ml0 (\u212d\u2085_subset_\u212d\u2081 a)\n  simp_rw [ml0, false_or] at split \u22a2\n  obtain \u27e8j, hj, mc1\u27e9 := split\n  iterate 4 rw [mem_iUnion_iff_mem_of_mem_\u212d\u2081 \u27e8mc1, hj\u27e9]\n  pick_goal 4; \u00b7 exact fun _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 \ud835\udd0f\u2081_subset_\u212d\u2081\n  pick_goal 3; \u00b7 exact fun _ \u21a6 \ud835\udd0f\u2082_subset_\u212d\u2081\n  pick_goal 2; \u00b7 exact fun _ \u21a6 iUnion\u2082_subset fun _ _ \u21a6 \ud835\udd0f\u2083_subset_\u212d\u2081\n  pick_goal -1; \u00b7 exact fun _ \u21a6 \u212d\u2085_subset_\u212d\u2081\n  by_cases mc2 : p \u2209 \u212d\u2082 k n j\n  all_goals\n    have mc2' := mc2\n    simp_rw [\u212d\u2082, layersAbove, mem_diff, not_and, mc1, true_implies, not_not_mem] at mc2'\n  \u00b7 change p \u2208 \u22c3 (l \u2264 Z * (n + 1)), \ud835\udd0f\u2081 k n j l at mc2'\n    simp_rw [mc2', true_or, iff_true]; contrapose! mc2\n    exact \u212d\u2085_subset_\u212d\u2084.trans \u212d\u2084_subset_\u212d\u2083 |>.trans \u212d\u2083_subset_\u212d\u2082 mc2\n  change p \u2209 \u22c3 (l \u2264 Z * (n + 1)), \ud835\udd0f\u2081 k n j l at mc2'; simp_rw [mc2', false_or]\n  rw [not_not_mem] at mc2; by_cases ml2 : p \u2208 \ud835\udd0f\u2082 k n j\n  \u00b7 simp_rw [ml2, true_or, iff_true]\n    exact fun a \u21a6 disjoint_left.mp \ud835\udd0f\u2082_disjoint_\u212d\u2083 ml2 (\u212d\u2085_subset_\u212d\u2084.trans \u212d\u2084_subset_\u212d\u2083 a)\n  simp_rw [ml2, false_or]\n  exact nmem_\u212d\u2085_iff_mem_\ud835\udd0f\u2083 hkn hj h mc2 ml2\n\n/-- The subset `\ud835\udd0f\u2080(k, n, l)` of `\ud835\udd0f\u2080(k, n)`, given in Lemma 5.5.3.\n  We use the name `\ud835\udd0f\u2080'` in Lean. -/\ndef \ud835\udd0f\u2080' (k n l : \u2115) : Set (\ud835\udd13 X) := (\ud835\udd0f\u2080 k n).minLayer l\n\n/-- Logarithmic inequality used in the proof of Lemma 5.5.2. -/\nlemma ceil_log2_le_floor_four_add_log2 {l : \u211d} (hl : 2 \u2264 l) :\n    \u2308Real.logb 2 ((l + 6 / 5) / 5\u207b\u00b9)\u2309\u208a \u2264 \u230a4 + Real.logb 2 l\u230b\u208a := by\n  have : 2 \u2264 Real.logb 2 (l + 6 / 5) + Real.logb 2 5 :=\n    calc\n      _ \u2265 Real.logb 2 (2 ^ (0 : \u211d)) + Real.logb 2 (2 ^ (2 : \u211d)) :=\n        add_le_add\n          (Real.logb_le_logb_of_le one_lt_two (by positivity) (by linarith))\n          (Real.logb_le_logb_of_le one_lt_two (by positivity) (by norm_num))\n      _ \u2265 _ := by simp_rw [Real.logb_rpow zero_lt_two one_lt_two.ne']; norm_num\n  rw [div_inv_eq_mul, Real.logb_mul (by positivity) (by positivity), Nat.le_floor_iff']\n  \u00b7 calc\n      _ \u2264 1 + Real.logb 2 (l + 6 / 5) + Real.logb 2 5 := by\n        rw [add_rotate]; exact (Nat.ceil_lt_add_one (zero_le_two.trans this)).le\n      _ \u2264 1 + Real.logb 2 (8 / 5 * l) + Real.logb 2 5 := by\n        gcongr\n        \u00b7 exact one_lt_two\n        \u00b7 linarith\n      _ = _ := by\n        rw [add_assoc, \u2190 Real.logb_mul (by positivity) (by positivity), \u2190 mul_rotate,\n          show (5 : \u211d) * (8 / 5) = 2 ^ 3 by norm_num,\n          Real.logb_mul (by positivity) (by positivity), \u2190 Real.rpow_natCast,\n          Real.logb_rpow zero_lt_two one_lt_two.ne', \u2190 add_assoc]\n        norm_num\n  \u00b7 exact (zero_lt_one.trans_le (Nat.one_le_ceil_iff.mpr (zero_lt_two.trans_le this))).ne'\n\n/-- The set `\ud835\udd12` in the proof of Lemma 5.5.2. -/\ndef \ud835\udd12 (p' : \ud835\udd13 X) (l : \u211d\u22650) : Finset (\ud835\udd13 X) :=\n  {p'' | \ud835\udcd8 p'' = \ud835\udcd8 p' \u2227 \u00acDisjoint (ball_(p') (\ud835\udcac p') l) (\u03a9 p'')}\n\nlemma card_\ud835\udd12 (p' : \ud835\udd13 X) {l : \u211d\u22650} (hl : 2 \u2264 l) : (\ud835\udd12 p' l).card \u2264 \u230a2 ^ (4 * a) * l ^ a\u230b\u208a := by\n  have djO : (\ud835\udd12 p' l).toSet.PairwiseDisjoint fun p'' \u21a6 ball_(p') (\ud835\udcac p'') 5\u207b\u00b9 :=\n    fun p\u2081 mp\u2081 p\u2082 mp\u2082 hn \u21a6 by\n      simp_rw [\ud835\udd12, Finset.coe_filter, mem_setOf, Finset.mem_univ, true_and] at mp\u2081 mp\u2082\n      change Disjoint (ball_{\ud835\udcd8 p'} (\ud835\udcac p\u2081) 5\u207b\u00b9) (ball_{\ud835\udcd8 p'} (\ud835\udcac p\u2082) 5\u207b\u00b9)\n      conv => enter [1]; rw [\u2190 mp\u2081.1]\n      conv => enter [2]; rw [\u2190 mp\u2082.1]\n      exact cball_disjoint hn (mp\u2081.1.trans mp\u2082.1.symm)\n  have tO : \u2200 p'' \u2208 \ud835\udd12 p' l,\n      ball_(p') (\ud835\udcac p'') 5\u207b\u00b9 \u2286 ball_(p') (\ud835\udcac p') (l + 6 / 5) := fun p'' mp'' \u21a6 by\n    apply ball_subset_ball'\n    simp_rw [\ud835\udd12, Finset.mem_filter, Finset.mem_univ, true_and] at mp''\n    obtain \u27e8x, mx\u2081, mx\u2082\u27e9 := not_disjoint_iff.mp mp''.2\n    replace mx\u2082 := _root_.subset_cball mx\u2082\n    rw [@mem_ball] at mx\u2081 mx\u2082\n    calc\n      _ \u2264 5\u207b\u00b9 + (dist_{\ud835\udcd8 p'} x (\ud835\udcac p'') + dist_{\ud835\udcd8 p'} x (\ud835\udcac p')) :=\n        add_le_add_left (dist_triangle_left ..) _\n      _ \u2264 5\u207b\u00b9 + (1 + l) := by gcongr; rw [\u2190 mp''.1]; exact mx\u2082.le\n      _ = _ := by rw [inv_eq_one_div, \u2190 add_assoc, add_comm _ l.toReal]; norm_num\n  have vO : CoveredByBalls (ball_(p') (\ud835\udcac p') (l + 6 / 5)) \u230a2 ^ (4 * a) * l ^ a\u230b\u208a 5\u207b\u00b9 := by\n    apply (ballsCoverBalls_iterate (show 0 < l.toReal + 6 / 5 by positivity)\n      (show 0 < 5\u207b\u00b9 by positivity) (\ud835\udcac p')).mono_nat\n    calc\n      _ \u2264 (defaultA a) ^ \u230a4 + Real.logb 2 l\u230b\u208a :=\n        pow_le_pow_right\u2080 Nat.one_le_two_pow (ceil_log2_le_floor_four_add_log2 hl)\n      _ \u2264 \u230a(defaultA a : \u211d) ^ (4 + Real.logb 2 l)\u230b\u208a := by\n        apply Nat.le_floor; rw [Nat.cast_npow, \u2190 Real.rpow_natCast]\n        refine Real.rpow_le_rpow_of_exponent_le (by exact_mod_cast Nat.one_le_two_pow)\n          (Nat.floor_le ?_)\n        calc\n          _ \u2265 4 + Real.logb 2 2 :=\n            add_le_add_left (Real.logb_le_logb_of_le one_lt_two zero_lt_two hl) _\n          _ \u2265 _ := by rw [Real.logb_self_eq_one one_lt_two]; norm_num\n      _ = _ := by\n        rw [Nat.cast_pow, Nat.cast_ofNat, \u2190 Real.rpow_natCast, \u2190 Real.rpow_mul zero_le_two,\n          mul_comm, add_mul, Real.rpow_add zero_lt_two, show (4 : \u211d) * a = (4 * a : \u2115) by simp,\n          Real.rpow_natCast, Real.rpow_mul zero_le_two, Real.rpow_natCast,\n          Real.rpow_logb zero_lt_two one_lt_two.ne']\n        congr 1; exact zero_lt_two.trans_le hl\n  obtain \u27e8(T : Finset (\u0398 X)), cT, uT\u27e9 := vO\n  refine (Finset.card_le_card_of_forall_subsingleton (fun p'' t \u21a6 \ud835\udcac p'' \u2208 ball_(p') t 5\u207b\u00b9)\n      (fun p'' mp'' \u21a6 ?_) (fun t _ o\u2081 mo\u2081 o\u2082 mo\u2082 \u21a6 ?_)).trans cT\n  \u00b7 have := (tO _ mp'').trans uT (mem_ball_self (by positivity))\n    rwa [mem_iUnion\u2082, bex_def] at this\n  \u00b7 simp_rw [mem_setOf_eq] at mo\u2081 mo\u2082; rw [@mem_ball_comm] at mo\u2081 mo\u2082\n    exact djO.elim mo\u2081.1 mo\u2082.1 (not_disjoint_iff.mpr \u27e8t, mo\u2081.2, mo\u2082.2\u27e9)\n\nsection\n\nvariable {p' : \ud835\udd13 X} {l : \u211d\u22650} (hl : 2 \u2264 l)\n  (qp' : 2 ^ (4 * a - n : \u2124) < l ^ (-a : \u2124) * volume (E\u2082 l p') / volume (\ud835\udcd8 p' : Set X))\ninclude hl qp'\n\nlemma lt_quotient_rearrange :\n    (2 ^ (4 * a) * l ^ a : \u211d\u22650) * 2 ^ (-n : \u2124) < volume (E\u2082 l p') / volume (\ud835\udcd8 p' : Set X) := by\n  rw [mul_div_assoc] at qp'; convert ENNReal.div_lt_of_lt_mul' qp' using 1\n  rw [ENNReal.div_eq_inv_mul,\n    \u2190 ENNReal.zpow_neg (by exact_mod_cast (zero_lt_two.trans_le hl).ne') ENNReal.coe_ne_top,\n    neg_neg, ENNReal.coe_mul, mul_rotate, mul_assoc, ENNReal.coe_pow, zpow_natCast]\n  congr 1\n  rw [ENNReal.coe_pow, ENNReal.coe_ofNat, \u2190 zpow_natCast,\n    \u2190 ENNReal.zpow_add two_ne_zero ENNReal.ofNat_ne_top]\n  congr 1; omega\n\nlemma l_upper_bound : l < 2 ^ n := by\n  have ql1 : volume (E\u2082 l p') / volume (\ud835\udcd8 p' : Set X) \u2264 1 := by\n    apply ENNReal.div_le_of_le_mul; rw [one_mul]; exact measure_mono (E\u2082_subset ..)\n  replace qp' := (lt_quotient_rearrange hl qp').trans_le ql1\n  rw [\u2190 ENNReal.mul_lt_mul_right (c := 2 ^ (n : \u2124)) (by simp) (by simp), one_mul, mul_assoc,\n    \u2190 ENNReal.zpow_add two_ne_zero ENNReal.ofNat_ne_top, neg_add_cancel, zpow_zero, mul_one,\n    show (2 ^ (n : \u2124) : \u211d\u22650\u221e) = (2 ^ (n : \u2124) : \u211d\u22650) by simp, ENNReal.coe_lt_coe,\n    zpow_natCast] at qp'\n  calc\n    _ \u2264 l ^ a := le_self_pow\u2080 (one_le_two.trans hl) (by linarith [four_le_a X])\n    _ \u2264 2 ^ (4 * a) * l ^ a := by\n      nth_rw 1 [\u2190 one_mul (l ^ a)]; gcongr; exact_mod_cast Nat.one_le_two_pow\n    _ < _ := qp'\n\nlemma exists_\ud835\udd12_with_le_quotient :\n    \u2203 b \u2208 \ud835\udd12 p' l, 2 ^ (-n : \u2124) < volume (E\u2081 b) / volume (\ud835\udcd8 b : Set X) := by\n  have cO : (\ud835\udd12 p' l).card \u2264 \u230a2 ^ (4 * a) * l ^ a\u230b\u208a := card_\ud835\udd12 _ hl\n  have ltq : (2 ^ (4 * a) * l ^ a : \u211d\u22650) * 2 ^ (-n : \u2124) <\n      \u2211 p'' \u2208 \ud835\udd12 p' l, volume (E\u2081 p'') / volume (\ud835\udcd8 p'' : Set X) :=\n    calc\n      _ < volume (E\u2082 l p') / volume (\ud835\udcd8 p' : Set X) := lt_quotient_rearrange hl qp'\n      _ \u2264 volume (\u22c3 p'' \u2208 \ud835\udd12 p' l, E\u2081 p'') / volume (\ud835\udcd8 p' : Set X) := by\n        gcongr; simp_rw [E\u2081, E\u2082, smul, toTileLike, TileLike.toSet]; intro x mx\n        have rsub := biUnion_\u03a9 (i := \ud835\udcd8 p'); rw [range_subset_iff] at rsub; specialize rsub x\n        simp_rw [mem_iUnion\u2082, mem_preimage, mem_singleton_iff, exists_prop] at rsub\n        obtain \u27e8(ps : \ud835\udd13 X), (ips : \ud835\udcd8 ps = \ud835\udcd8 p'), mps\u27e9 := rsub; rw [\u2190 mem_preimage] at mps\n        rw [mem_iUnion\u2082]; refine \u27e8ps, ?_, ?_\u27e9\n        \u00b7 simp_rw [\ud835\udd12, Finset.mem_filter, Finset.mem_univ, ips, true_and, not_disjoint_iff]\n          use Q x, mem_preimage.mp mx.2, mem_preimage.mp mps\n        \u00b7 exact \u27e8\u27e8ips.symm \u25b8 mx.1.1, mx.1.2\u27e9, mps\u27e9\n      _ \u2264 (\u2211 p'' \u2208 \ud835\udd12 p' l, volume (E\u2081 p'')) / volume (\ud835\udcd8 p' : Set X) :=\n        ENNReal.div_le_div_right (measure_biUnion_finset_le _ _) _\n      _ = \u2211 p'' \u2208 \ud835\udd12 p' l, volume (E\u2081 p'') / volume (\ud835\udcd8 p' : Set X) := by\n        simp_rw [ENNReal.div_eq_inv_mul, Finset.mul_sum]\n      _ = _ := by\n        refine Finset.sum_congr rfl fun p'' mp'' \u21a6 ?_\n        rw [\ud835\udd12, Finset.mem_filter] at mp''; rw [mp''.2.1]\n  by_contra! h\n  have : \u2211 p'' \u2208 \ud835\udd12 p' l, volume (E\u2081 p'') / volume (\ud835\udcd8 p'' : Set X) \u2264\n      (2 ^ (4 * a) * l ^ a : \u211d\u22650) * 2 ^ (-n : \u2124) :=\n    calc\n      _ \u2264 \u2211 _ \u2208 \ud835\udd12 p' l, (2 : \u211d\u22650\u221e) ^ (-n : \u2124) := by\n        refine Finset.sum_le_sum h\n      _ = (\ud835\udd12 p' l).card * (2 : \u211d\u22650\u221e) ^ (-n : \u2124) := by rw [Finset.sum_const, nsmul_eq_mul]\n      _ \u2264 _ := by\n        refine mul_le_mul_right' ?_ _\n        rw [show ((\ud835\udd12 p' l).card : \u211d\u22650\u221e) = ((\ud835\udd12 p' l).card : \u211d\u22650) by simp, ENNReal.coe_le_coe]\n        rw [\u2190 Nat.cast_le (\u03b1 := \u211d\u22650)] at cO\n        exact cO.trans (Nat.floor_le (by positivity))\n  exact (ltq.trans_le this).false\n\nend\n\n/-- Main part of Lemma 5.5.2. -/\nlemma iUnion_L0' : \u22c3 (l < n), \ud835\udd0f\u2080' (X := X) k n l = \ud835\udd0f\u2080 k n := by\n  refine iUnion_lt_minLayer_iff_bounded_series.mpr fun p \u21a6 ?_\n  suffices \u00ac\u2203 s : LTSeries (\ud835\udd0f\u2080 (X := X) k n), s.length = n by\n    rcases lt_or_le p.length n with c | c\n    \u00b7 exact c\n    \u00b7 exact absurd \u27e8p.take \u27e8n, by omega\u27e9, by rw [RelSeries.take_length]\u27e9 this\n  by_contra h; obtain \u27e8s, hs\u27e9 := h; let sl := s.last; have dsl := sl.2.1.2.1\n  simp_rw [dens', lt_iSup_iff, mem_singleton_iff, exists_prop, exists_eq_left] at dsl\n  obtain \u27e8l, hl, p', mp', sp', qp'\u27e9 := dsl\n  obtain \u27e8b, mb, qb\u27e9 := exists_\ud835\udd12_with_le_quotient hl qp'\n  have \ud835\udcd8p'b : \ud835\udcd8 p' = \ud835\udcd8 b := by rw [\ud835\udd12, Finset.mem_filter] at mb; exact mb.2.1.symm\n  replace qb := ENNReal.mul_lt_of_lt_div qb\n  have mba : b \u2208 (aux\ud835\udd10 k n).toFinset := by\n    simp_rw [mem_toFinset, aux\ud835\udd10, mem_setOf, qb, and_true]; rw [TilesAt, mem_preimage] at mp' \u22a2\n    exact \ud835\udcd8p'b \u25b8 mp'\n  obtain \u27e8m, lm, maxm\u27e9 := (aux\ud835\udd10 k n).toFinset.exists_le_maximal mba\n  replace maxm : m \u2208 \ud835\udd10 k n := by simpa only [mem_toFinset] using maxm\n  -- We will now show a contradiction. As a member of `\ud835\udd0f\u2080 k n` the _first_ element `s\u2080` of the\n  -- `LTSeries s` satisfies `\ud835\udd05 k n s\u2080 = \u2205`. But we will show that `m \u2208 \ud835\udd05 k n s\u2080`,\n  -- i.e. `smul 100 s\u2080 \u2264 smul 1 m`.\n  let s\u2080 := s.head; apply absurd s\u2080.2.2; rw [\u2190 ne_eq, \u2190 nonempty_iff_ne_empty]; use m, maxm\n  constructor\n  \u00b7 have l1 : \ud835\udcd8 s\u2080.1 \u2264 \ud835\udcd8 sl.1 := s.head_le_last.1\n    have l2 : \ud835\udcd8 sl.1 \u2264 \ud835\udcd8 b := \ud835\udcd8p'b \u25b8 sp'.1\n    have l3 : \ud835\udcd8 b \u2264 \ud835\udcd8 m := lm.1\n    exact (l1.trans l2).trans l3\n  change ball_(m) (\ud835\udcac m) 1 \u2286 ball_(s\u2080.1) (\ud835\udcac s\u2080.1) 100; intro (\u03b8 : \u0398 X) m\u03b8; rw [@mem_ball] at m\u03b8 \u22a2\n  have aux : dist_(sl.1) (\ud835\udcac sl.1) \u03b8 < 2 * l + 3 :=\n    calc\n      _ \u2264 dist_(sl.1) (\ud835\udcac sl.1) (\ud835\udcac p') + dist_(sl.1) (\ud835\udcac p') \u03b8 := dist_triangle ..\n      _ < l + dist_(sl.1) (\ud835\udcac p') \u03b8 := by\n        apply add_lt_add_right\n        have : \ud835\udcac p' \u2208 ball_(p') (\ud835\udcac p') l := by convert mem_ball_self (zero_lt_two.trans_le hl)\n        exact mem_ball'.mp (sp'.2 this)\n      _ \u2264 l + dist_(p') (\ud835\udcac p') \u03b8 := add_le_add_left (Grid.dist_mono sp'.1) _\n      _ \u2264 l + dist_(p') (\ud835\udcac p') (\ud835\udcac b) + dist_(p') (\ud835\udcac b) \u03b8 := by\n        rw [add_assoc]; apply add_le_add_left; exact dist_triangle ..\n      _ \u2264 l + (l + 1) + dist_(b) (\ud835\udcac b) \u03b8 := by\n        gcongr\n        \u00b7 rw [\ud835\udd12, Finset.mem_filter] at mb\n          obtain \u27e8(x : \u0398 X), x\u2081, x\u2082\u27e9 := not_disjoint_iff.mp mb.2.2\n          replace x\u2082 := _root_.subset_cball x\u2082\n          rw [@mem_ball] at x\u2081 x\u2082\n          calc\n            _ \u2264 dist_(p') x (\ud835\udcac p') + dist_(p') x (\ud835\udcac b) := dist_triangle_left ..\n            _ \u2264 _ := by\n              apply add_le_add x\u2081.le\n              change dist_{\ud835\udcd8 p'} x (\ud835\udcac b) \u2264 1; rw [\ud835\udcd8p'b]; exact x\u2082.le\n        \u00b7 change dist_{\ud835\udcd8 p'} (\ud835\udcac b) \u03b8 \u2264 dist_{\ud835\udcd8 b} (\ud835\udcac b) \u03b8; rw [\ud835\udcd8p'b]\n      _ \u2264 l + (l + 1) + (dist_(b) (\ud835\udcac m) (\ud835\udcac b) + dist_(b) (\ud835\udcac m) \u03b8) :=\n        add_le_add_left (dist_triangle_left ..) _\n      _ \u2264 l + (l + 1) + (1 + dist_(m) (\ud835\udcac m) \u03b8) := by\n        gcongr\n        \u00b7 exact (dist_\ud835\udcac_lt_one_of_le lm).le\n        \u00b7 exact Grid.dist_mono lm.1\n      _ < l + (l + 1) + (1 + 1) := by gcongr; exact mem_ball'.mp m\u03b8\n      _ = _ := by ring\n  calc\n    _ \u2264 dist_(s\u2080.1) (\ud835\udcac sl.1) \u03b8 + dist_(s\u2080.1) (\ud835\udcac sl.1) (\ud835\udcac s\u2080.1) := dist_triangle_left ..\n    _ < 1 + dist_(s\u2080.1) (\ud835\udcac sl.1) \u03b8 := by\n      rw [add_comm]; exact add_lt_add_right (dist_\ud835\udcac_lt_one_of_le s.head_le_last) _\n    _ \u2264 1 + C2_1_2 a ^ n * dist_(sl.1) (\ud835\udcac sl.1) \u03b8 := add_le_add_left (dist_LTSeries hs) _\n    _ < 1 + C2_1_2 a ^ n * (2 * l + 3) := by gcongr; rw [C2_1_2]; positivity\n    _ \u2264 1 + (1 / 512) ^ n * (2 * 2 ^ n + 3) := by\n      gcongr\n      \u00b7 rw [C2_1_2]; positivity\n      \u00b7 exact C2_1_2_le_inv_512 X\n      \u00b7 exact_mod_cast (l_upper_bound hl qp').le\n    _ = 1 + 2 * (2 / 512) ^ n + (1 / 512) ^ n * 3 := by\n      simp [div_pow]; ring\n    _ \u2264 1 + 2 * (2 / 512) ^ 0 + (1 / 512) ^ 0 * 3 := by\n      gcongr 1 + 2 * ?_ + ?_ * 3 <;>\n        exact pow_le_pow_of_le_one (by norm_num) (by norm_num) (by omega)\n    _ < _ := by norm_num\n\n/-- Part of Lemma 5.5.2 -/\nlemma pairwiseDisjoint_L0' : univ.PairwiseDisjoint (\ud835\udd0f\u2080' (X := X) k n) := pairwiseDisjoint_minLayer\n\n/-- Part of Lemma 5.5.2 -/\nlemma antichain_L0' : IsAntichain (\u00b7 \u2264 \u00b7) (\ud835\udd0f\u2080' (X := X) k n l) := isAntichain_minLayer\n\nsection L2Antichain\n\n/-- Type synonym of `\u212d\u2081` to apply the `Preorder` of the proof of Lemma 5.5.3 on. -/\nprivate def \u212d\u2081' (k n j : \u2115) : Type _ := \u212d\u2081 (X := X) k n j\n\nprivate instance : Fintype (\u212d\u2081' (X := X) k n j) := inferInstanceAs (Fintype (\u212d\u2081 k n j))\n\nprivate instance : Preorder (\u212d\u2081' (X := X) k n j) where\n  le x y := smul 200 x.1 \u2264 smul 200 y.1\n  le_refl := by simp\n  le_trans _ _ _ xy yz := by\n    change smul _ _ \u2264 smul _ _ at xy yz \u22a2\n    exact xy.trans yz\n\n/-- Lemma 5.5.3 -/\nlemma antichain_L2 : IsAntichain (\u00b7 \u2264 \u00b7) (\ud835\udd0f\u2082 (X := X) k n j) := by\n  by_contra h; rw [isAntichain_iff_forall_not_lt] at h; push_neg at h\n  obtain \u27e8p', mp', p, mp, l\u27e9 := h\n  have p200 : smul 2 p' \u2264 smul 200 p := by\n    calc\n      _ \u2264 smul (11 / 10 + C2_1_2 a * 200) p' := by\n        apply smul_mono_left\n        calc\n          _ \u2264 11 / 10 + 1 / 512 * (200 : \u211d) := by gcongr; exact C2_1_2_le_inv_512 X\n          _ \u2264 _ := by norm_num\n      _ \u2264 _ := by\n        refine smul_C2_1_2 _ (by norm_num) ?_ (wiggle_order_11_10 l.le (C5_3_3_le (X := X)))\n        exact (\ud835\udcd8_strictMono l).ne\n  have cp : p \u2208 \u212d\u2081 k n j := (\ud835\udd0f\u2082_subset_\u212d\u2082.trans \u212d\u2082_subset_\u212d\u2081) mp\n  let C : Finset (LTSeries (\u212d\u2081' k n j)) := { s | s.head = \u27e8p, cp\u27e9 }\n  have Cn : C.Nonempty := by\n    use RelSeries.singleton _ \u27e8p, cp\u27e9\n    simp_rw [C, Finset.mem_filter, Finset.mem_univ, true_and]; rfl\n  obtain \u27e8z, mz, maxz\u27e9 := C.exists_max_image (\u00b7.length) Cn\n  simp_rw [C, Finset.mem_filter, Finset.mem_univ, true_and] at mz\n  by_cases mu : z.last.1 \u2208 \ud835\udd18\u2081 k n j\n  \u00b7 have px : z.head \u2264 z.last := z.monotone (Fin.zero_le _)\n    rw [mz] at px\n    apply absurd mp'; rw [\ud835\udd0f\u2082, mem_setOf, not_and_or, not_not]; right; use z.last.1, mu\n    have : \ud835\udcd8 p' < \ud835\udcd8 p := \ud835\udcd8_strictMono l\n    exact \u27e8(this.trans_le px.1).ne, (p200.trans px).trans (smul_mono_left (by norm_num))\u27e9\n  \u00b7 simp_rw [\ud835\udd18\u2081, mem_setOf, not_and, z.last.2, true_implies, not_forall, exists_prop] at mu\n    obtain \u27e8q, mq, lq, ndjq\u27e9 := mu; rw [not_disjoint_iff] at ndjq; obtain \u27e8\u03d1, m\u03d1\u2081, m\u03d1\u2082\u27e9 := ndjq\n    have cpos : 0 < C2_1_2 a := by rw [C2_1_2]; positivity\n    have s200 : smul 200 z.last.1 \u2264 smul 200 q := by\n      refine \u27e8lq.le, (?_ : ball_(q) (\ud835\udcac q) 200 \u2286 ball_(z.last.1) (\ud835\udcac z.last.1) 200)\u27e9\n      intro (r : \u0398 X) mr\n      rw [@mem_ball] at mr m\u03d1\u2081 m\u03d1\u2082 \u22a2\n      calc\n        _ \u2264 dist_(z.last.1) r (\ud835\udcac q) + dist_(z.last.1) (\ud835\udcac q) \u03d1 + dist_(z.last.1) \u03d1 (\ud835\udcac z.last.1) :=\n          dist_triangle4 ..\n        _ \u2264 C2_1_2 a * dist_(q) r (\ud835\udcac q) + C2_1_2 a * dist_(q) (\ud835\udcac q) \u03d1 + 100 := by\n          gcongr <;> exact Grid.dist_strictMono lq\n        _ \u2264 C2_1_2 a * (200 + 100) + 100 := by rw [mul_add]; gcongr; rw [dist_comm]; exact m\u03d1\u2082.le\n        _ \u2264 (1 / 512) * 300 + 100 := by\n          rw [show (200 : \u211d) + 100 = 300 by norm_num]; gcongr\n          exact C2_1_2_le_inv_512 X\n        _ < _ := by norm_num\n    have : z.last < \u27e8q, mq\u27e9 := by\n      refine \u27e8s200, (?_ : \u00ac(smul 200 q \u2264 smul 200 z.last.1))\u27e9\n      rw [TileLike.le_def, not_and_or]; exact Or.inl (not_le_of_gt lq)\n    apply absurd maxz; push_neg; use z.snoc \u27e8q, mq\u27e9 this, by simp [C, mz], by simp\n\nend L2Antichain\n\n/-- Part of Lemma 5.5.4 -/\nlemma antichain_L1 : IsAntichain (\u00b7 \u2264 \u00b7) (\ud835\udd0f\u2081 (X := X) k n j l) := isAntichain_minLayer\n\n/-- Part of Lemma 5.5.4 -/\nlemma antichain_L3 : IsAntichain (\u00b7 \u2264 \u00b7) (\ud835\udd0f\u2083 (X := X) k n j l) := isAntichain_maxLayer\n\n/- Our goal is now to estimate `\u222b\u207b x in G \\ G', \u2016carlesonSum \ud835\udd13\u2081\u1d9c f x\u2016\u208a` by decomposing `\ud835\udd13\u2081\u1d9c` as a\nunion of disjoint antichains. For this, we proceed step by step, isolating some antichains and\nsome sets that remain to be decomposed. After 4 steps, we will get a sum of integrals corresponding\nto the (disjoint) decomposition in Lemma 5.5.1.\n-/\n\n/-- The Carleson sum over `\ud835\udd13\u2081\u1d9c` and `\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c` coincide at ae every point of `G \\ G'`. -/\nlemma carlesonSum_\ud835\udd13\u2081_compl_eq_\ud835\udd13pos_inter (f : X \u2192 \u2102) :\n    \u2200\u1d50 x, x \u2208 G \\ G' \u2192 carlesonSum \ud835\udd13\u2081\u1d9c f x = carlesonSum (\ud835\udd13pos (X := X) \u2229 \ud835\udd13\u2081\u1d9c) f x := by\n  have A p (hp : p \u2208 (\ud835\udd13pos (X := X))\u1d9c) : \u2200\u1d50 x, x \u2208 G \\ G' \u2192 x \u2209 \ud835\udcd8 p := by\n    simp only [\ud835\udd13pos, mem_compl_iff, mem_setOf_eq, not_lt, nonpos_iff_eq_zero] at hp\n    filter_upwards [measure_zero_iff_ae_nmem.mp hp] with x hx h'x (h''x : x \u2208 (\ud835\udcd8 p : Set X))\n    simp [h''x, h'x.1, h'x.2] at hx\n  rw [\u2190 ae_ball_iff (to_countable \ud835\udd13pos\u1d9c)] at A\n  filter_upwards [A] with x hx h'x\n  simp only [carlesonSum]\n  symm\n  apply Finset.sum_subset\n  \u00b7 intro p hp\n    simp only [Finset.mem_filter, Finset.mem_univ, true_and] at hp \u22a2\n    exact hp.2\n  \u00b7 intro p hp h'p\n    simp only [Finset.mem_filter, Finset.mem_univ, true_and] at hp h'p\n    simp only [mem_inter_iff, hp, and_true] at h'p\n    have : x \u2209 \ud835\udcd8 p := hx _ h'p h'x\n    have : x \u2209 E p := by simp at this; simp [E, this]\n    simp [carlesonOn, this]\n\n/-- The Carleson sum over `\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c` can be decomposed as a sum over the intersections of this\nset with various `\u212d k n`. -/\nlemma carlesonSum_\ud835\udd13pos_eq_sum {f : X \u2192 \u2102} {x : X} :\n    carlesonSum (\ud835\udd13pos (X := X) \u2229 \ud835\udd13\u2081\u1d9c) f x =\n      \u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, carlesonSum (\ud835\udd13pos (X := X) \u2229 \ud835\udd13\u2081\u1d9c \u2229 \u212d k n) f x := by\n  simp only [Finset.sum_sigma']\n  rw [sum_carlesonSum_of_pairwiseDisjoint]; swap\n  \u00b7 rintro \u27e8n, k\u27e9 - \u27e8n', k'\u27e9 - h\n    simp only [ne_eq, Sigma.mk.inj_iff, heq_eq_eq] at h\n    simp only [Function.onFun, disjoint_iff_forall_ne]\n    have W := pairwiseDisjoint_\u212d (X := X) (mem_univ \u27e8k, n\u27e9) (mem_univ \u27e8k', n'\u27e9)\n      (by simp [-not_and]; tauto)\n    intro x hx y hy\n    exact (disjoint_iff_forall_ne.1 W) hx.2 hy.2\n  congr\n  ext p\n  simp only [mem_inter_iff, mem_compl_iff, Finset.mem_sigma,\n    Finset.mem_Iic, mem_iUnion, exists_and_left, exists_prop, Sigma.exists, iff_self_and, and_imp]\n  intro hp h'p\n  rcases exists_k_n_of_mem_\ud835\udd13pos hp with \u27e8k, n, h'p, hkn\u27e9\n  exact \u27e8n, k, \u27e8le_max\u212d_of_nonempty \u27e8p, h'p\u27e9 , hkn\u27e9, h'p\u27e9\n\n/-- In each set `\u212d k n`, the Carleson sum can be decomposed as a sum over `\ud835\udd0f\u2080 k n` and over\nvarious `\u212d\u2081 k n j`. -/\nlemma carlesonSum_\ud835\udd13pos_inter_\u212d_eq_add_sum {f : X \u2192 \u2102} {x : X} (hkn : k \u2264 n) :\n    carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \u212d k n) f x =\n      carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2080 k n) f x\n      + \u2211 j \u2264 2 * n + 3, carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \u212d\u2081 k n j) f x := by\n  conv_lhs => rw [\u2190 carlesonSum_inter_add_inter_compl _ (\ud835\udd0f\u2080 k n)]\n  rw [sum_carlesonSum_of_pairwiseDisjoint]; swap\n  \u00b7 apply PairwiseDisjoint.subset _ (subset_univ _)\n    apply (pairwiseDisjoint_\u212d\u2081 (k := k) (n := n)).mono\n    intro j\n    exact inter_subset_right\n  congr 2\n  \u00b7 ext p\n    simp only [mem_inter_iff, mem_compl_iff, and_congr_left_iff, and_iff_left_iff_imp, and_imp]\n    intro hp\n    simp [\ud835\udd0f\u2080_subset_\u212d hp]\n  \u00b7 apply Subset.antisymm\n    \u00b7 rintro p \u27e8\u27e8hp, Hp\u27e9, h'p\u27e9\n      rcases exists_j_of_mem_\ud835\udd13pos_\u212d hp.1 Hp hkn with H\n      simp only [mem_compl_iff] at h'p\n      simp only [h'p, false_or] at H\n      simp only [Finset.mem_Iic, mem_iUnion, mem_inter_iff, hp, true_and, exists_prop]\n      exact H\n    \u00b7 intro p hp\n      simp only [Finset.mem_Iic, mem_iUnion, mem_compl_iff, exists_and_left, exists_prop] at hp\n      rcases hp with \u27e8i, hi, h'i, h''i\u27e9\n      exact \u27e8\u27e8h'i, \u212d\u2081_subset_\u212d h''i\u27e9, disjoint_left.1 \ud835\udd0f\u2080_disjoint_\u212d\u2081.symm h''i\u27e9\n\nlemma carlesonSum_\ud835\udd13pos_inter_\ud835\udd0f\u2080_eq_sum {f : X \u2192 \u2102} {x : X} :\n    carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2080 k n) f x =\n      \u2211 l < n, carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2080' k n l) f x := by\n  rw [sum_carlesonSum_of_pairwiseDisjoint]; swap\n  \u00b7 apply PairwiseDisjoint.subset _ (subset_univ _)\n    apply (pairwiseDisjoint_L0' (k := k) (n := n)).mono\n    intro j\n    exact inter_subset_right\n  congr\n  rw [\u2190 iUnion_L0']\n  ext p\n  simp\n\n/-- In each set `\u212d\u2081 k n j`, the Carleson sum can be decomposed as a sum over `\u212d\u2082 k n j` and over\nvarious `\ud835\udd0f\u2081 k n j l`. -/\nlemma carlesonSum_\ud835\udd13pos_inter_\u212d\u2081_eq_add_sum {f : X \u2192 \u2102} {x : X} :\n    carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \u212d\u2081 k n j) f x =\n      carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \u212d\u2082 k n j) f x\n      + \u2211 l \u2264 Z * (n + 1), carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2081 k n j l) f x := by\n  conv_lhs => rw [\u2190 carlesonSum_inter_add_inter_compl _ (\u212d\u2082 k n j)]\n  rw [sum_carlesonSum_of_pairwiseDisjoint]; swap\n  \u00b7 apply PairwiseDisjoint.subset _ (subset_univ _)\n    have : univ.PairwiseDisjoint fun l \u21a6 \ud835\udd0f\u2081 (X := X) k n j l := pairwiseDisjoint_minLayer\n    apply this.mono\n    intro j\n    exact inter_subset_right\n  congr 2\n  \u00b7 ext p\n    simp only [mem_inter_iff, mem_compl_iff, and_congr_left_iff, and_iff_left_iff_imp, and_imp]\n    intro hp\n    simp [\u212d\u2082_subset_\u212d\u2081 hp]\n  \u00b7 ext p\n    simp only [\u212d\u2082, layersAbove, mem_inter_iff,\n      mem_compl_iff, mem_diff, mem_iUnion, exists_prop, not_exists, not_and, not_forall,\n      Classical.not_imp, Decidable.not_not, Finset.mem_Iic, \ud835\udd0f\u2081, exists_and_left]\n    refine \u27e8fun h \u21a6 ?_, fun h \u21a6 ?_\u27e9\n    \u00b7 simpa [h.1.1] using h.2 h.1.2\n    \u00b7 rcases h with \u27e8i, hi, h'i\u27e9\n      simp only [h'i.1, not_false_eq_true, and_self, minLayer_subset h'i.2, forall_const, true_and]\n      exact \u27e8i, hi, h'i.2\u27e9\n\n/-- In each set `\u212d\u2082 k n j`, the Carleson sum can be decomposed as a sum over `\ud835\udd0f\u2082 k n j` and over\nvarious `\ud835\udd0f\u2083 k n j l`. -/\nlemma carlesonSum_\ud835\udd13pos_inter_\u212d\u2082_eq_add_sum {f : X \u2192 \u2102} {x : X} (hkn : k \u2264 n) (hj : j \u2264 2 * n + 3) :\n    carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \u212d\u2082 k n j) f x =\n      carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2082 k n j) f x\n      + \u2211 l \u2264 Z * (n + 1), carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2083 k n j l) f x := by\n  conv_lhs => rw [\u2190 carlesonSum_inter_add_inter_compl _ (\ud835\udd0f\u2082 k n j)]\n  rw [sum_carlesonSum_of_pairwiseDisjoint]; swap\n  \u00b7 apply PairwiseDisjoint.subset _ (subset_univ _)\n    have : univ.PairwiseDisjoint fun l \u21a6 \ud835\udd0f\u2083 (X := X) k n j l := pairwiseDisjoint_minLayer\n    apply this.mono\n    intro j\n    exact inter_subset_right\n  congr 2\n  \u00b7 ext p\n    simp only [mem_inter_iff, mem_compl_iff, and_congr_left_iff, and_iff_left_iff_imp, and_imp]\n    intro hp\n    simp [\ud835\udd0f\u2082_subset_\u212d\u2082 hp]\n  \u00b7 ext p\n    simp only [mem_inter_iff, mem_compl_iff,\n      Finset.mem_Iic, mem_iUnion, exists_and_left, exists_prop]\n    refine \u27e8fun h \u21a6 ?_, fun h \u21a6 ?_\u27e9\n    \u00b7 refine \u27e8h.1.1, ?_\u27e9\n      simp only [\ud835\udd13\u2081, mem_iUnion, exists_prop, not_exists, not_and] at h\n      have : p \u2209 \u212d\u2085 k n j := h.1.1.2 n k hkn j hj\n      simpa using (nmem_\u212d\u2085_iff_mem_\ud835\udd0f\u2083 (X := X) hkn hj h.1.1.1 h.1.2 h.2).1 this\n    \u00b7 rcases h.2 with \u27e8l, lZ, hl\u27e9\n      exact \u27e8\u27e8h.1, \u212d\u2083_subset_\u212d\u2082 (maxLayer_subset hl)\u27e9,\n        disjoint_right.1 \ud835\udd0f\u2082_disjoint_\u212d\u2083 (maxLayer_subset hl)\u27e9\n\n/-- Putting together all the previous decomposition lemmas, one gets an estimate of the integral\nof `\u2016carlesonSum \ud835\udd13\u2081\u1d9c f x\u2016\u208a` by a sum of integrals of the same form over various subsets of `\ud835\udd13`,\nwhich are all antichains by design. -/\nlemma lintegral_carlesonSum_\ud835\udd13\u2081_compl_le_sum_lintegral {f : X \u2192 \u2102} (h'f : Measurable f) :\n    \u222b\u207b x in G \\ G', \u2016carlesonSum \ud835\udd13\u2081\u1d9c f x\u2016\u208a \u2264\n        (\u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 l < n,\n          \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2080' k n l) f x\u2016\u208a)\n      + (\u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3, \u2211 l \u2264 Z * (n + 1),\n          \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2081 k n j l) f x\u2016\u208a)\n      + (\u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3,\n          \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2082 k n j) f x\u2016\u208a)\n      + (\u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3, \u2211 l \u2264 Z * (n + 1),\n          \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2083 k n j l) f x\u2016\u208a) := calc\n  \u222b\u207b x in G \\ G', \u2016carlesonSum \ud835\udd13\u2081\u1d9c f x\u2016\u208a\n  _ = \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c) f x\u2016\u208a := by\n    apply lintegral_congr_ae\n    apply (ae_restrict_iff' (measurableSet_G.diff measurable_G')).2\n    filter_upwards [carlesonSum_\ud835\udd13\u2081_compl_eq_\ud835\udd13pos_inter f] with x hx h'x\n    simp [hx h'x]\n  _ \u2264 \u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \u212d k n) f x\u2016\u208a := by\n    simp only [Finset.sum_sigma']\n    rw [\u2190 lintegral_finset_sum']; swap\n    \u00b7 exact fun b hb \u21a6 h'f.aestronglyMeasurable.carlesonSum.restrict.enorm\n    apply lintegral_mono (fun x \u21a6 ?_)\n    simp only [Finset.sum_sigma', carlesonSum_\ud835\udd13pos_eq_sum]\n    exact (ENNReal.coe_le_coe.2 (nnnorm_sum_le _ _)).trans_eq (by simp)\n  _ \u2264 \u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, ((\u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2080 k n) f x\u2016\u208a)\n      + \u2211 j \u2264 2 * n + 3, \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \u212d\u2081 k n j) f x\u2016\u208a) := by\n    gcongr with n hn k hkn\n    simp only [Finset.mem_Iic] at hkn\n    rw [\u2190 lintegral_finset_sum']; swap\n    \u00b7 exact fun b hb \u21a6 h'f.aestronglyMeasurable.carlesonSum.restrict.enorm\n    rw [\u2190 lintegral_add_left']; swap\n    \u00b7 exact h'f.aestronglyMeasurable.carlesonSum.restrict.enorm\n    apply lintegral_mono (fun x \u21a6 ?_)\n    rw [carlesonSum_\ud835\udd13pos_inter_\u212d_eq_add_sum hkn]\n    norm_cast\n    apply ENNReal.coe_le_coe.2\n    apply (nnnorm_add_le _ _).trans\n    gcongr\n    apply nnnorm_sum_le\n  _ = (\u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2080 k n) f x\u2016\u208a)\n      + \u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3,\n        \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \u212d\u2081 k n j) f x\u2016\u208a := by\n    simp only [Finset.sum_add_distrib]\n  _ \u2264 (\u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 l < n, \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2080' k n l) f x\u2016\u208a)\n      + \u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3,\n        \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \u212d\u2081 k n j) f x\u2016\u208a := by\n    gcongr with n hn k hk\n    rw [\u2190 lintegral_finset_sum']; swap\n    \u00b7 exact fun b hb \u21a6 h'f.aestronglyMeasurable.carlesonSum.restrict.enorm\n    apply lintegral_mono (fun x \u21a6 ?_)\n    rw [carlesonSum_\ud835\udd13pos_inter_\ud835\udd0f\u2080_eq_sum]\n    norm_cast\n    apply ENNReal.coe_le_coe.2\n    apply nnnorm_sum_le\n  _ \u2264 (\u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 l < n, \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2080' k n l) f x\u2016\u208a)\n      + \u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3,\n      ((\u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \u212d\u2082 k n j) f x\u2016\u208a)\n        + \u2211 l \u2264 Z * (n + 1), \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2081 k n j l) f x\u2016\u208a) := by\n    gcongr with n hn k hk j hj\n    rw [\u2190 lintegral_finset_sum']; swap\n    \u00b7 exact fun b hb \u21a6 h'f.aestronglyMeasurable.carlesonSum.restrict.enorm\n    rw [\u2190 lintegral_add_left']; swap\n    \u00b7 exact h'f.aestronglyMeasurable.carlesonSum.restrict.enorm\n    apply lintegral_mono (fun x \u21a6 ?_)\n    rw [carlesonSum_\ud835\udd13pos_inter_\u212d\u2081_eq_add_sum]\n    norm_cast\n    apply ENNReal.coe_le_coe.2\n    apply (nnnorm_add_le _ _).trans\n    gcongr\n    apply nnnorm_sum_le\n  _ = (\u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 l < n, \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2080' k n l) f x\u2016\u208a)\n      + (\u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3, \u2211 l \u2264 Z * (n + 1),\n          \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2081 k n j l) f x\u2016\u208a)\n      + \u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3,\n          \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \u212d\u2082 k n j) f x\u2016\u208a := by\n    simp only [Finset.sum_add_distrib]\n    abel\n  _ \u2264 (\u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 l < n, \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2080' k n l) f x\u2016\u208a)\n      + (\u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3, \u2211 l \u2264 Z * (n + 1),\n          \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2081 k n j l) f x\u2016\u208a)\n      + \u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3,\n        ((\u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2082 k n j) f x\u2016\u208a)\n          + \u2211 l \u2264 Z * (n + 1), \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2083 k n j l) f x\u2016\u208a) := by\n    gcongr with n hn k hkn j hj\n    simp only [Finset.mem_Iic] at hkn hj\n    rw [\u2190 lintegral_finset_sum']; swap\n    \u00b7 exact fun b hb \u21a6 h'f.aestronglyMeasurable.carlesonSum.restrict.enorm\n    rw [\u2190 lintegral_add_left']; swap\n    \u00b7 exact h'f.aestronglyMeasurable.carlesonSum.restrict.enorm\n    apply lintegral_mono (fun x \u21a6 ?_)\n    rw [carlesonSum_\ud835\udd13pos_inter_\u212d\u2082_eq_add_sum hkn hj]\n    norm_cast\n    apply ENNReal.coe_le_coe.2\n    apply (nnnorm_add_le _ _).trans\n    gcongr\n    apply nnnorm_sum_le\n  _ = (\u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 l < n, \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2080' k n l) f x\u2016\u208a)\n      + (\u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3, \u2211 l \u2264 Z * (n + 1),\n          \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2081 k n j l) f x\u2016\u208a)\n      + (\u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3,\n          \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2082 k n j) f x\u2016\u208a)\n      + \u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3, \u2211 l \u2264 Z * (n + 1),\n          \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd0f\u2083 k n j l) f x\u2016\u208a := by\n    simp only [Finset.sum_add_distrib]\n    abel\n\n/-- Custom version of the antichain operator theorem, in the specific form we need to handle\nthe various terms in the previous statement. -/\nlemma lintegral_nnnorm_carlesonSum_le_of_isAntichain_subset_\u212d\n    {f : X \u2192 \u2102} {\ud835\udd04 : Set (\ud835\udd13 X)} (hf : \u2200 x, \u2016f x\u2016 \u2264 F.indicator 1 x) (h'f : Measurable f)\n    (hA : IsAntichain (\u00b7 \u2264 \u00b7) \ud835\udd04) (h'A : \ud835\udd04 \u2286 \u212d k n) :\n    \u222b\u207b x in G \\ G', \u2016carlesonSum (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd04) f x\u2016\u208a\n    \u2264 C_2_0_3 a nnq * 2 ^ (a + 3) * volume G ^ (1 - q\u207b\u00b9) * volume F ^ (q\u207b\u00b9)\n      * 2 ^ (- ((q - 1) / (8 * a ^ 4) * n)) := by\n  have I : 0 \u2264 q - 1 := by linarith [one_lt_q X]\n  have J : 0 \u2264 q\u207b\u00b9 - 2\u207b\u00b9 := inv_q_sub_half_nonneg X\n  apply (antichain_operator_le_volume h'f hf diff_subset\n    (hA.subset inter_subset_right)).trans\n  simp only [mul_assoc]\n  apply mul_le_mul_left'\n  have : dens\u2081 (\ud835\udd13pos (X := X) \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd04) \u2264 2 ^ (4 * a - n + 1 : \u211d) :=\n    dens1_le (inter_subset_right.trans h'A)\n  have : dens\u2082 (\ud835\udd13pos (X := X) \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd04) \u2264 2 ^ (2 * a + 5) * volume F / volume G := by\n    rw [dens\u2082_eq_biSup_dens\u2082]\n    simp only [mem_iUnion, exists_prop, iSup_exists, iSup_le_iff, and_imp]\n    intro p hp\n    have : \u00ac (\ud835\udcd8 p : Set X) \u2286 G\u2081 := by\n      have W := hp.1.1\n      contrapose! W\n      have : \u2191(\ud835\udcd8 p) \u2229 G \u2229 G'\u1d9c = \u2205 := by\n        simp only [G', compl_union]\n        apply eq_empty_of_subset_empty\n        intro x hx\n        exact (hx.2.1.1 (W hx.1.1)).elim\n      simp only [\ud835\udd13pos, mem_setOf_eq, this, measure_empty, lt_self_iff_false, not_false_eq_true]\n    contrapose! this\n    have : p \u2208 highDensityTiles := by simp [highDensityTiles, this]\n    apply subset_biUnion_of_mem this\n  calc\n  dens\u2081 (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd04) ^ ((q - 1) / (8 * \u2191a ^ 4)) *\n    (dens\u2082 (\ud835\udd13pos \u2229 \ud835\udd13\u2081\u1d9c \u2229 \ud835\udd04) ^ (q\u207b\u00b9 - 2\u207b\u00b9) * (volume F ^ (1 / 2 : \u211d) * volume G ^ (1 / 2 : \u211d)))\n  _ \u2264 (2 ^ (4 * a - n + 1 : \u211d)) ^ ((q - 1) / (8 * \u2191a ^ 4)) *\n    ((2 ^ (2 * a + 5) * volume F / volume G) ^ (q\u207b\u00b9 - 2\u207b\u00b9)\n      * ((volume F ^ (1 / 2 : \u211d) * volume G ^ (1 / 2 : \u211d)))) := by gcongr\n  _ = (2 ^ ((4 * a + 1) * (q - 1) / (8 * \u2191a ^ 4)) * 2 ^ (- ((q - 1) / (8 * \u2191a ^ 4) * n))) *\n    ((2 ^ ((2 * a + 5) * (q\u207b\u00b9 - 2\u207b\u00b9)) * volume F ^ (q\u207b\u00b9 - 2\u207b\u00b9) / volume G ^ (q\u207b\u00b9 - 2\u207b\u00b9))\n      * ((volume F ^ (1 / 2 : \u211d) * volume G ^ (1 / 2 : \u211d)))) := by\n    rw [ENNReal.div_rpow_of_nonneg _ _ J, ENNReal.mul_rpow_of_nonneg _ _ J,\n      \u2190 ENNReal.rpow_natCast, \u2190 ENNReal.rpow_mul, \u2190 ENNReal.rpow_mul,\n      \u2190 ENNReal.rpow_add _ _ (NeZero.ne 2) ENNReal.ofNat_ne_top]\n    congr\n    \u00b7 ring\n    \u00b7 simp\n  _ = 2 ^ ((4 * a + 1) * (q - 1) / (8 * \u2191a ^ 4)) * 2 ^ ((2 * a + 5) * (q\u207b\u00b9 - 2\u207b\u00b9)) *\n      (volume G ^ (1 - q\u207b\u00b9) * (volume F ^ q\u207b\u00b9 * 2 ^ (- ((q - 1) / (8 * \u2191a ^ 4) * n)))) := by\n    have IF : (volume F) ^ (q\u207b\u00b9) = (volume F) ^ ((q \u207b\u00b9 - 2\u207b\u00b9) + 2\u207b\u00b9) := by congr; abel\n    have IG : (volume G) ^ (1 - q\u207b\u00b9) = (volume G) ^ (2\u207b\u00b9 - (q\u207b\u00b9 - 2\u207b\u00b9)) := by\n      congr 1\n      simp only [sub_sub_eq_add_sub, sub_left_inj]\n      norm_num\n    rw [IF, IG, ENNReal.rpow_sub (2\u207b\u00b9) _ ProofData.volume_G_pos.ne' volume_G_ne_top,\n      ENNReal.rpow_add_of_nonneg (x := volume F) _ _ (inv_q_sub_half_nonneg X) (by norm_num),\n      ENNReal.div_eq_inv_mul, ENNReal.div_eq_inv_mul]\n    ring_nf\n  _ \u2264 2 ^ ((2 : \u211d)\u207b\u00b9 + (a + 5/2)) *\n      (volume G ^ (1 - q\u207b\u00b9) * (volume F ^ q\u207b\u00b9 * 2 ^ (- ((q - 1) / (8 * \u2191a ^ 4) * n)))) := by\n    rw [\u2190 ENNReal.rpow_add _ _ (NeZero.ne 2) ENNReal.ofNat_ne_top]\n    have : (4 : \u211d) \u2264 a := mod_cast (four_le_a X)\n    gcongr\n    \u00b7 exact one_le_two\n    \u00b7 calc\n      (4 * a + 1) * (q - 1) / (8 * a ^ 4 : \u211d)\n      _ \u2264 (4 * a + a) * (2 - 1) / (8 * a ^ 4) := by\n         gcongr\n         \u00b7 norm_cast\n           linarith [four_le_a X]\n         \u00b7 exact q_le_two X\n      _ = 5 / (8 * a ^ 3) := by field_simp; ring\n      _ \u2264 5 / (8 * (4 : \u211d) ^ 3) := by gcongr\n      _ \u2264 2\u207b\u00b9 := by norm_num\n    \u00b7 calc\n      (2 * \u2191a + 5) * (q\u207b\u00b9 - 2\u207b\u00b9)\n      _ \u2264 (2 * \u2191a + 5) * (1\u207b\u00b9 - 2\u207b\u00b9) := by gcongr; exact (one_lt_q X).le\n      _ = a + 5/2 := by ring\n  _ = 2 ^ (a + 3) *\n      (volume G ^ (1 - q\u207b\u00b9) * (volume F ^ q\u207b\u00b9 * 2 ^ (- ((q - 1) / (8 * \u2191a ^ 4) * n)))) := by\n    congr 1\n    rw [\u2190 ENNReal.rpow_natCast]\n    congr\n    simp\n    ring\n\nopen scoped Nat\n\nomit [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] [TileStructure Q D \u03ba S o] in\nlemma lintegral_carlesonSum_\ud835\udd13\u2081_compl_le_sum_aux1 [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] {N : \u2115} :\n    \u2211 x \u2264 N,\n      (((12 + 8 * Z) * x ^ 0 + (19 + 20 * Z) * x ^ 1 + (7 + 16 * Z) * x ^ 2 + (4 * Z) * x ^ 3) *\n        (2 : \u211d) ^ (-((q - 1) / (8 * \u2191a ^ 4) * x : \u211d))) \u2264 2 ^ (28 * a + 20) / (q - 1) ^ 4 := by\n  simp only [add_mul _ _ ((2 : \u211d) ^ (_ : \u211d)), Finset.sum_add_distrib]\n  simp only [mul_assoc, \u2190 Finset.mul_sum]\n  simp only [\u2190 mul_assoc]\n  have : 0 < q - 1 := by linarith [one_lt_q X]\n  have : 0 < a := a_pos X\n  have : q \u2264 2 := q_le_two X\n  have : (4 : \u211d) \u2264 a := mod_cast (four_le_a X)\n  have P : 0 < (q - 1) / (8 * \u2191a ^ 4) := by positivity\n  have : 0.6931471803 \u2264 Real.log 2 := Real.log_two_gt_d9.le\n  have : (1 : \u211d) \u2264 Z / 2 ^ 48 := by\n    rw [one_le_div (by positivity)]\n    simp only [defaultZ, Nat.cast_pow, Nat.cast_ofNat]\n    gcongr\n    \u00b7 exact one_le_two\n    \u00b7 linarith [four_le_a X]\n  calc\n  (12 + 8 * \u2191Z) * \u2211 i \u2264 N, \u2191i ^ 0 * (2 : \u211d) ^ (-((q - 1) / (8 * a ^ 4) * i)) +\n      (19 + 20 * \u2191Z) * \u2211 i \u2264 N, \u2191i ^ 1 * 2 ^ (-((q - 1) / (8 * a ^ 4) * i)) +\n      (7 + 16 * \u2191Z) * \u2211 i \u2264 N, \u2191i ^ 2 * 2 ^ (-((q - 1) / (8 * a ^ 4) * i)) +\n      (4 * \u2191Z) * \u2211 i \u2264 N, \u2191i ^ 3 * 2 ^ (-((q - 1) / (8 * a ^ 4) * i))\n  _ \u2264 (12 + 8 * \u2191Z) * ((2 : \u211d) ^ ((q - 1) / (8 * a ^ 4)) *\n        0 ! / (Real.log 2 * ((q - 1) / (8 * a ^ 4))) ^ (0 + 1)) +\n      (19 + 20 * \u2191Z) * ((2 : \u211d) ^ ((q - 1) / (8 * a ^ 4)) *\n        1 ! / (Real.log 2 * ((q - 1) / (8 * a ^ 4))) ^ (1 + 1)) +\n      (7 + 16 * \u2191Z) * ((2 : \u211d) ^ ((q - 1) / (8 * a ^ 4)) *\n        2 ! / (Real.log 2 * ((q - 1) / (8 * a ^ 4))) ^ (2 + 1)) +\n      (4 * \u2191Z) * ((2 : \u211d) ^ ((q - 1) / (8 * a ^ 4)) *\n        3 ! / (Real.log 2 * ((q - 1) / (8 * a ^ 4))) ^ (3 + 1)) := by\n    gcongr <;> apply sum_Iic_pow_mul_two_pow_neg_le P\n  _ = (2 : \u211d) ^ ((q - 1) / (8 * a ^ 4)) *\n      ( (12 + 8 * \u2191Z) / (Real.log 2 * ((q - 1) / (8 * a ^ 4)))\n      + (19 + 20 * \u2191Z)  / (Real.log 2 * ((q - 1) / (8 * a ^ 4))) ^ 2\n      + (14 + 32 * \u2191Z) / (Real.log 2 * ((q - 1) / (8 * a ^ 4))) ^ 3\n      + (24 * \u2191Z) /  (Real.log 2 * ((q - 1) / (8 * a ^ 4))) ^ 4) := by\n    simp only [Nat.cast_pow, Nat.cast_ofNat, Nat.factorial, Nat.cast_one, mul_one,\n      zero_add, pow_one, Nat.succ_eq_add_one, Nat.reduceAdd, Nat.reduceMul]\n    ring\n  _ \u2264 (2 : \u211d) ^ (1 : \u211d) *\n      ( (12 + 8 * \u2191Z) / (Real.log 2 * ((q - 1) / (8 * a ^ 4)))\n      + (19 + 20 * \u2191Z)  / (Real.log 2 * ((q - 1) / (8 * a ^ 4))) ^ 2\n      + (14 + 32 * \u2191Z) / (Real.log 2 * ((q - 1) / (8 * a ^ 4))) ^ 3\n      + (24 * \u2191Z) /  (Real.log 2 * ((q - 1) / (8 * a ^ 4))) ^ 4) := by\n    gcongr\n    \u00b7 exact one_le_two\n    \u00b7 apply div_le_one_of_le\u2080 _ (by positivity)\n      have : 8 * (4 : \u211d) ^ 4 \u2264 8 * a ^ 4 := by gcongr\n      linarith\n  _ = (24 + 16 * \u2191Z) / (Real.log 2 * ((q - 1) / (8 * a ^ 4)))\n      + (38 + 40 * \u2191Z)  / (Real.log 2 * ((q - 1) / (8 * a ^ 4))) ^ 2\n      + (28 + 64 * \u2191Z) / (Real.log 2 * ((q - 1) / (8 * a ^ 4))) ^ 3\n      + (48 * \u2191Z) /  (Real.log 2 * ((q - 1) / (8 * a ^ 4))) ^ 4 := by\n    simp only [Real.rpow_one, Nat.cast_pow, Nat.cast_ofNat]\n    ring\n  _ = ((8 * a ^ 4) / (q - 1)) ^ 4 *\n     (((q - 1) / (8 * a ^ 4)) ^ 3 * (24 * 1 + 16 * \u2191Z) / Real.log 2\n      + ((q - 1) / (8 * a ^ 4)) ^ 2 * (38 * 1 + 40 * \u2191Z)  / (Real.log 2) ^ 2\n      + ((q - 1) / (8 * a ^ 4)) * (28 * 1 + 64 * \u2191Z) / (Real.log 2) ^ 3\n      + (48 * \u2191Z) /  (Real.log 2) ^ 4) := by\n    field_simp only\n    ring\n  _ \u2264 ((8 * a ^ 4) / (q - 1)) ^ 4 *\n     (((2 - 1) / (8 * 4 ^ 4)) ^ 3 * (24 * (Z / 2 ^ 48) + 16 * \u2191Z) / 0.6931471803\n      + ((2 - 1) / (8 * 4 ^ 4)) ^ 2 * (38 * (Z / 2 ^ 48) + 40 * \u2191Z)  / 0.6931471803 ^ 2\n      + ((2 - 1) / (8 * 4 ^ 4)) * (28 * (Z / 2 ^ 48) + 64 * \u2191Z) / 0.6931471803 ^ 3\n      + (48 * \u2191Z) / 0.6931471803 ^ 4) := by gcongr\n  _ = a ^ 16 / (q - 1) ^ 4 * Z * (8 ^ 4 *\n      (((2 - 1) / (8 * 4 ^ 4)) ^ 3 * (24 * (1 / 2 ^ 48) + 16) / 0.6931471803\n      + ((2 - 1) / (8 * 4 ^ 4)) ^ 2 * (38 * (1 / 2 ^ 48) + 40)  / 0.6931471803 ^ 2\n      + ((2 - 1) / (8 * 4 ^ 4)) * (28 * (1 / 2 ^ 48) + 64) / 0.6931471803 ^ 3\n      + 48 / 0.6931471803 ^ 4)) := by\n    rw [div_pow]; ring\n  _ \u2264 a ^ 16 / (q - 1) ^ 4 * Z * 2 ^ 20 := by gcongr; norm_num\n  _ \u2264 (2 ^ a) ^ 16 / (q - 1) ^ 4 * Z * 2 ^ 20 := by\n    gcongr\n    exact_mod_cast (Nat.lt_pow_self one_lt_two).le\n  _ = (2 ^ (16 * a) * 2 ^ (12 * a) * 2 ^ 20) / (q - 1) ^ 4 := by\n    simp [\u2190 pow_mul, mul_comm a]\n    ring\n  _ = 2 ^ (28 * a + 20) / (q - 1) ^ 4 := by\n    simp only [\u2190 pow_add]\n    congr\n    omega\n\n omit [TileStructure Q D \u03ba S o] in\n ", "theoremStatement": "lemma lintegral_carlesonSum_\ud835\udd13\u2081_compl_le_sum_aux2 {N : \u2115} :\n    \u2211 x \u2264 N, (((12 + 8 * Z) + (19 + 20 * Z) * x + (7 + 16 * Z) * x ^ 2 + (4 * Z) * x ^ 3) *\n        (2 : \u211d\u22650\u221e) ^ (-((q - 1) / (8 * \u2191a ^ 4) * x : \u211d)))\n    \u2264 (2 : \u211d\u22650\u221e) ^ (28 * a + 20) / (nnq - 1) ^ 4 ", "theoremName": "lintegral_carlesonSum_\ud835\udd13\u2081_compl_le_sum_aux2", "fileCreated": {"commit": "310e13d16e51600777fc841833f4bce112b5f73a", "date": "2024-09-24"}, "theoremCreated": {"commit": "77d4285c51ebe49f9035715383dfd7aef6aecf25", "date": "2025-01-09"}, "file": "carleson/Carleson/Discrete/ForestComplement.lean", "module": "Carleson.Discrete.ForestComplement", "jsonFile": "Carleson.Discrete.ForestComplement.jsonl", "positionMetadata": {"lineInFile": 1021, "tokenPositionInFile": 50909, "theoremPositionInFile": 41}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 9, "numPremises": 259}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  have : 0 < q - 1 := by linarith [one_lt_q X]\n  have A : (2 : \u211d\u22650\u221e) = ENNReal.ofReal (2 : \u211d) := by simp\n  simp_rw [A, ENNReal.ofReal_rpow_of_pos zero_lt_two]\n  simp only [Finset.sum_const, Nat.card_Iio, nsmul_eq_mul, Nat.cast_add, Nat.cast_mul,\n    Nat.cast_ofNat, Nat.card_Iic, Nat.cast_one, ge_iff_le]\n  calc\n  \u2211 x \u2264 N, (((12 + 8 * \u2191Z) + (19 + 20 * \u2191Z) * x + (7 + 16 * \u2191Z) * x ^ 2 + (4 * \u2191Z) * x ^ 3)\n      * ENNReal.ofReal (2 ^ (-((q - 1) / (8 * \u2191a ^ 4) * x : \u211d))))\n  _ = \u2211 x \u2264 N, ENNReal.ofReal\n      (((12 + 8 * Z) + (19 + 20 * Z) * x + (7 + 16 * Z) * x ^ 2 + (4 * Z) * x ^ 3) *\n        2 ^ (-((q - 1) / (8 * \u2191a ^ 4) * x : \u211d))) := by\n    congr with i\n    rw [ENNReal.ofReal_mul (by positivity)]\n    congr\n    norm_cast\n  _ = ENNReal.ofReal (\u2211 x \u2264 N,\n      (((12 + 8 * Z) + (19 + 20 * Z) * x + (7 + 16 * Z) * x ^ 2 + (4 * Z) * x ^ 3) *\n        2 ^ (-((q - 1) / (8 * \u2191a ^ 4) * x : \u211d)))) := by\n    rw [ENNReal.ofReal_sum_of_nonneg]\n    intro i hi\n    positivity\n  _ \u2264 ENNReal.ofReal (2 ^ (28 * a + 20) / (q - 1) ^ 4) := by\n    apply ENNReal.ofReal_le_ofReal\n    simpa using lintegral_carlesonSum_\ud835\udd13\u2081_compl_le_sum_aux1 (X := X)\n  _ = 2 ^ (28 * a + 20) / (ENNReal.ofReal (q - 1)) ^ 4 := by\n    rw [ENNReal.ofReal_div_of_pos (by positivity)]\n    congr\n    \u00b7 norm_cast\n    \u00b7 rw [ENNReal.ofReal_pow]\n      linarith\n  _ = (ENNReal.ofReal 2) ^ (28 * a + 20) / (nnq - 1) ^ 4 := by\n    rw [\u2190 A]\n    rfl", "proofType": "tactic", "proofLengthLines": 33, "proofLengthTokens": 1401}}
{"srcContext": "/-\nCopyright (c) 2024 James Sundstrom. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: James Sundstrom\n-/\nimport Mathlib.MeasureTheory.Constructions.BorelSpace.Metric\n\n/-!\n# Annulus\n\nIn this file we define an annulus in a pseudometric space `X` to be a set consisting of all `y`\nsuch that `dist x y` lies in an interval between `r` and `R`. An annulus is defined for each type\nof interval (`Ioo`, `Ioc`, etc.) with a parallel naming scheme, except that we do not define annuli\nfor `Iio` and `Ico`, as they would be balls.\n\nWe also define `EAnnulus` similarly using `edist` instead of `dist`.\n\n## Tags\n\nannulus, eannulus\n-/\n\nopen Set Metric ENNReal\n\nvariable {X : Type*} [PseudoMetricSpace X]\n\nnamespace Set\n\nnamespace Annulus\n\ndef oo (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d) := {y | dist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d) := {y | dist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d) := {y | dist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d) := {y | dist x y \u2208 Ici r}\n\nlemma oo_eq {x : X} {r R : \u211d} : oo x r R = ball x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oo, dist_comm, and_comm]\n\nlemma oc_eq {x : X} {r R : \u211d} : oc x r R = closedBall x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oc, dist_comm, and_comm]\n\nlemma co_eq {x : X} {r R : \u211d} : co x r R = ball x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [co, dist_comm, and_comm]\n\nlemma cc_eq {x : X} {r R : \u211d} : cc x r R = closedBall x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [cc, dist_comm, and_comm]\n\nlemma oi_eq {x : X} {r : \u211d} : oi x r = (closedBall x r)\u1d9c := by\n  ext; simp [oi, dist_comm]\n\nlemma ci_eq {x : X} {r : \u211d} : ci x r = (ball x r)\u1d9c := by\n  ext; simp [ci, dist_comm]\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : co x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma co_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : co x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\nlemma cc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : cc x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma cc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : cc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\n@[simp]\nlemma oc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    oc x r r' \u222a oo x r' R = oo x r R := by\n  ext; simp_rw [oc, oo, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioo_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    oc x r r' \u222a oc x r' R = oc x r R := by\n  ext; simp_rw [oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_co {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a co x r' R = oo x r R := by\n  ext; simp_rw [oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ico_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a cc x r' R = oc x r R := by\n  ext; simp_rw [oo, cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Icc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    cc x r r' \u222a oo x r' R = co x r R := by\n  ext; simp_rw [cc, oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioo_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    cc x r r' \u222a oc x r' R = cc x r R := by\n  ext; simp_rw [cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_co {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a co x r' R = co x r R := by\n  ext; simp_rw [co, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ico_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a cc x r' R = cc x r R := by\n  ext; simp_rw [co, cc, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Icc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : oc x r R \u222a oi x R = oi x r := by\n  ext; simp_rw [oc, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioi_eq_Ioi h]\n\n@[simp]\nlemma oo_union_ci {x : X} {r R : \u211d} (h : r < R) :\n    oo x r R \u222a ci x R = oi x r := by\n  ext; simp_rw [oo, ci, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ici_eq_Ioi h]\n\n@[simp]\nlemma cc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : cc x r R \u222a oi x R = ci x r := by\n  ext; simp_rw [cc, oi, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioi_eq_Ici h]\n\n@[simp]\nlemma co_union_ci {x : X} {r R : \u211d} (h : r \u2264 R) : co x r R \u222a ci x R = ci x r := by\n  ext; simp_rw [co, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ici_eq_Ici h]\n\n\nvariable [MeasurableSpace X] [OpensMeasurableSpace X]\n\n@[measurability]\nlemma measurableSet_oo {x : X} {r R : \u211d} : MeasurableSet (oo x r R) := by\n  rw [oo_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oc {x : X} {r R : \u211d} : MeasurableSet (oc x r R) := by\n rw [oc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_co {x : X} {r R : \u211d} : MeasurableSet (co x r R) := by\n  rw [co_eq]; measurability\n\n@[measurability]\nlemma measurableSet_cc {x : X} {r R : \u211d} : MeasurableSet (cc x r R) := by\n rw [cc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oi {x : X} {r : \u211d} : MeasurableSet (oi x r) := by\n  rw [oi_eq]; measurability\n\n@[measurability]\nlemma measurableSet_ci {x : X} {r : \u211d} : MeasurableSet (ci x r) := by\n  rw [ci_eq]; measurability\n\nend Annulus\n\nnamespace EAnnulus\n\ndef oo (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ici r}\n\n\nlemma oo_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oo x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oo x r R := by\n  simp_rw [oo, Annulus.oo, edist_dist, mem_Ioo, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma oc_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [oc, Annulus.oc, edist_dist, mem_Ioc, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  \u00b7 have R_le_r := (lt_of_lt_of_le (lt_of_not_ge hR) hr).le\n    rw [Annulus.oc_eq_empty R_le_r]\n    refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n    exact not_le_of_gt (lt_of_le_of_lt (ENNReal.ofReal_le_ofReal R_le_r) hy.1) hy.2\n\nlemma co_eq_annulus {x : X} {r R : \u211d} :\n    co x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.co x r R := by\n  simp_rw [co, Annulus.co, edist_dist, mem_Ico, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma cc_eq_annulus {x : X} {r R : \u211d} (h : r > 0 \u2228 R \u2265 0) :\n    cc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.cc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [cc, Annulus.cc, edist_dist, mem_Icc, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  have r0 := h.resolve_right hR\n  have R_lt_r := (lt_of_not_ge hR).trans r0\n  rw [Annulus.cc_eq_empty R_lt_r]\n  refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n  exact not_le_of_gt ((ENNReal.ofReal_lt_ofReal_iff r0).mpr R_lt_r) (hy.1.trans hy.2)\n\nlemma oi_eq_annulus {x : X} {r : \u211d} (hr : r \u2265 0) : oi x (ENNReal.ofReal r) = Annulus.oi x r := by\n  simp_rw [oi, Annulus.oi, edist_dist, mem_Ioi, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr]\n\nlemma ci_eq_annulus {x : X} {r : \u211d} : ci x (ENNReal.ofReal r) = Annulus.ci x r := by\n  simp_rw [ci, Annulus.ci, edist_dist, mem_Ici, ENNReal.ofReal_le_ofReal_iff dist_nonneg]\n\n\nlemma oo_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oo x r R = ball x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oo, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma oc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oc x r R = closedBall x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oc, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma co_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    co x r R = ball x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [co, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma cc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    cc x r R = closedBall x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [cc, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma oi_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : oi x r = (closedBall x r.toReal)\u1d9c := by\n  ext; simp [oi, edist_dist, dist_comm, lt_ofReal_iff_toReal_lt hr.ne]\n\nlemma ci_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : ci x r = (ball x r.toReal)\u1d9c := by\n  ext; simp [ci, edist_dist, dist_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg]\n\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n@[simp]\nlemma cc_top_eq_empty {x : X} {R : \u211d\u22650\u221e} : cc x \u22a4 R = \u2205 :=\n  eq_empty_of_forall_not_mem (fun y hy \u21a6 (edist_ne_top x y) (top_le_iff.mp hy.1))\n\n@[simp]\nlemma oi_eq_empty {x : X} : oi x \u22a4 = \u2205 := by simp [oi, edist_dist]\n\n@[simp]\nlemma ci_eq_empty {x : X} : ci x \u22a4 = \u2205 := by simp [ci, edist_dist]\n\n\nlemma oo_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) :\n    oo x r \u22a4 = (closedBall x r.toReal)\u1d9c := by\n  ext; simpa [oo, edist_dist, dist_comm] using lt_ofReal_iff_toReal_lt hr.ne\n\nlemma oc_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) :\n    oc x r \u22a4 = (closedBall x r.toReal)\u1d9c := by\n  ext; simpa [oc, edist_dist, dist_comm] using lt_ofReal_iff_toReal_lt hr.ne\n\nlemma co_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : co x r \u22a4 = (ball x r.toReal)\u1d9c := by\n  ext; simpa [co, edist_dist, dist_comm] using le_ofReal_iff_toReal_le hr.ne dist_nonneg\n\nlemma cc_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : cc x r \u22a4 = (ball x r.toReal)\u1d9c := by\n  ext; simpa [cc, edist_dist, dist_comm] using le_ofReal_iff_toReal_le hr.ne dist_nonneg\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) : co x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma co_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : co x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\nlemma cc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) : cc x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma cc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : cc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\n@[simp]\nlemma oc_union_oo {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    oc x r r' \u222a oo x r' R = oo x r R := by\n  ext; simp_rw [oc, oo, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioo_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oc {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    oc x r r' \u222a oc x r' R = oc x r R := by\n  ext; simp_rw [oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_co {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a co x r' R = oo x r R := by\n  ext; simp_rw [oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ico_eq_Ioo h\u2081 h\u2082]\n\n", "theoremStatement": "@[simp]\nlemma oo_union_cc {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a cc x r' R = oc x r R ", "theoremName": "Set.EAnnulus.oo_union_cc", "fileCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "theoremCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "file": "carleson/Carleson/ToMathlib/Annulus.lean", "module": "Carleson.ToMathlib.Annulus", "jsonFile": "Carleson.ToMathlib.Annulus.jsonl", "positionMetadata": {"lineInFile": 471, "tokenPositionInFile": 18652, "theoremPositionInFile": 114}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 3, "numPremises": 49}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  ext; simp_rw [oo, cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Icc_eq_Ioc h\u2081 h\u2082]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 99}}
{"srcContext": "import Carleson.ToMathlib.DoublingMeasure\nimport Carleson.ToMathlib.WeakType\nimport Mathlib.Algebra.Order.Group.Int\nimport Mathlib.Analysis.CStarAlgebra.Classes\nimport Mathlib.Data.Int.Star\n\nopen MeasureTheory Measure NNReal Metric Complex Set TopologicalSpace Bornology Function\nopen scoped ENNReal\nnoncomputable section\n\n-- todo: rename and protect `Real.RCLike`\n\n/-! Miscellaneous definitions.\nThese are mostly the definitions used to state the metric Carleson theorem.\nWe should move them to separate files once we start proving things about them. -/\n\nsection DoublingMeasure\nuniverse u\n\nvariable {\ud835\udd5c X : Type*} {A : \u2115} [_root_.RCLike \ud835\udd5c] [PseudoMetricSpace X]\n\nsection localOscillation\n\n/-- The local oscillation of two functions w.r.t. a set `E`. This is `d_E` in the blueprint. -/\ndef localOscillation (E : Set X) (f g : C(X, \ud835\udd5c)) : \u211d\u22650\u221e :=\n  \u2a06 z \u2208 E \u00d7\u02e2 E, ENNReal.ofReal \u2016f z.1 - g z.1 - f z.2 + g z.2\u2016\n\n-- example (E : Set X) (hE : IsBounded E) (f : C(X, \u211d)) :\n--     BddAbove (range fun z : E \u21a6 f z) := by\n--   have : IsCompact (closure E) := IsBounded.isCompact_closure hE\n--   sorry\n\n-- lemma bddAbove_localOscillation (E : Set X) [Fact (IsBounded E)] (f g : C(X, \ud835\udd5c)) :\n--     BddAbove ((fun z : X \u00d7 X \u21a6 \u2016f z.1 - g z.1 - f z.2 + g z.2\u2016) '' E \u00d7\u02e2 E) := sorry\n\nvariable {E : Set X} {f g : C(X, \ud835\udd5c)}\n\n--old\n/-- A ball w.r.t. the distance `localOscillation` -/\ndef localOscillationBall (E : Set X) (f : C(X, \ud835\udd5c)) (r : \u211d) :\n    Set C(X, \ud835\udd5c) :=\n  { g : C(X, \ud835\udd5c) | localOscillation E f g < ENNReal.ofReal r }\n\nend localOscillation\n\nlemma fact_isCompact_ball (x : X) (r : \u211d) : Fact (IsBounded (ball x r)) :=\n  \u27e8isBounded_ball\u27e9\nattribute [local instance] fact_isCompact_ball\n\n/-- A class stating that continuous functions have distances associated to every ball.\nWe use a separate type to conveniently index these functions. -/\nclass FunctionDistances (\ud835\udd5c : outParam Type*) (X : Type u)\n    [NormedField \ud835\udd5c] [TopologicalSpace X] where\n  \u0398 : Type u\n  coe\u0398 : \u0398 \u2192 C(X, \ud835\udd5c)\n  coe\u0398_injective {f g : \u0398} (h : \u2200 x, coe\u0398 f x = coe\u0398 g x) : f = g\n  metric : \u2200 (_x : X) (_r : \u211d), PseudoMetricSpace \u0398\n\nexport FunctionDistances (\u0398 coe\u0398)\n\nsection FunctionDistances\nvariable [FunctionDistances \ud835\udd5c X]\n\ninstance : Coe (\u0398 X) C(X, \ud835\udd5c) := \u27e8FunctionDistances.coe\u0398\u27e9\ninstance : FunLike (\u0398 X) X \ud835\udd5c where\n  coe := fun f \u21a6 (f : C(X, \ud835\udd5c))\n  coe_injective' _ _ hfg := FunctionDistances.coe\u0398_injective fun x \u21a6 congrFun hfg x\ninstance : ContinuousMapClass (\u0398 X) X \ud835\udd5c := \u27e8fun f \u21a6 (f : C(X, \ud835\udd5c)).2\u27e9\n\nset_option linter.unusedVariables false in\n@[nolint unusedArguments]\ndef WithFunctionDistance (x : X) (r : \u211d) := \u0398 X\n\nvariable {x : X} {r : \u211d}\n\ndef toWithFunctionDistance [FunctionDistances \ud835\udd5c X] : \u0398 X \u2243 WithFunctionDistance x r :=\n  .refl _\n\n-- instance : FunLike (WithFunctionDistance \u0398 x r) X \ud835\udd5c := ContinuousMap.funLike\n-- instance : ContinuousMapClass (WithFunctionDistance \u0398 x r) X \ud835\udd5c :=\n--   ContinuousMap.toContinuousMapClass\n\ninstance [d : FunctionDistances \ud835\udd5c X] : PseudoMetricSpace (WithFunctionDistance x r) :=\n  d.metric x r\n\nend FunctionDistances\n\nnotation3 \"dist_{\" x \" ,\" r \"}\" => @dist (WithFunctionDistance x r) _\nnotation3 \"nndist_{\" x \" ,\" r \"}\" => @nndist (WithFunctionDistance x r) _\nnotation3 \"ball_{\" x \" ,\" r \"}\" => @ball (WithFunctionDistance x r) _ in\n\n/-- A set `\u0398` of (continuous) functions is compatible. `A` will usually be `2 ^ a`. -/\nclass CompatibleFunctions (\ud835\udd5c : outParam Type*) (X : Type u) (A : outParam \u2115)\n  [RCLike \ud835\udd5c] [PseudoMetricSpace X] extends FunctionDistances \ud835\udd5c X where\n  eq_zero : \u2203 o : X, \u2200 f : \u0398, f o = 0\n  /-- The distance is bounded below by the local oscillation. (1.0.7) -/\n  localOscillation_le_cdist {x : X} {r : \u211d} {f g : \u0398} :\n    localOscillation (ball x r) (coe\u0398 f) (coe\u0398 g) \u2264 ENNReal.ofReal (dist_{x, r} f g)\n  /-- The distance is monotone in the ball. (1.0.9) -/\n  cdist_mono {x\u2081 x\u2082 : X} {r\u2081 r\u2082 : \u211d} {f g : \u0398}\n    (h : ball x\u2081 r\u2081 \u2286 ball x\u2082 r\u2082) : dist_{x\u2081, r\u2081} f g \u2264 dist_{x\u2082, r\u2082} f g\n  /-- The distance of a ball with large radius is bounded above. (1.0.8) -/\n  cdist_le {x\u2081 x\u2082 : X} {r : \u211d} {f g : \u0398} (h : dist x\u2081 x\u2082 < 2 * r) :\n    dist_{x\u2082, 2 * r} f g \u2264 A * dist_{x\u2081, r} f g\n  /-- The distance of a ball with large radius is bounded below. (1.0.10) -/\n  le_cdist {x\u2081 x\u2082 : X} {r : \u211d} {f g : \u0398} (h1 : ball x\u2081 r \u2286 ball x\u2082 (A * r)) :\n    /-(h2 : A * r \u2264 Metric.diam (univ : Set X))-/\n    2 * dist_{x\u2081, r} f g \u2264 dist_{x\u2082, A * r} f g\n  /-- The distance of a ball with large radius is bounded below. (1.0.11) -/\n  ballsCoverBalls {x : X} {r R : \u211d} :\n    BallsCoverBalls (X := WithFunctionDistance x r) (2 * R) R A\n\ninstance nonempty_Space [CompatibleFunctions \ud835\udd5c X A] : Nonempty X := by\n  obtain \u27e8x,_\u27e9 := \u2039CompatibleFunctions \ud835\udd5c X A\u203a.eq_zero\n  use x\n\ninstance inhabited_Space [CompatibleFunctions \ud835\udd5c X A] : Inhabited X :=\n  \u27e8nonempty_Space.some\u27e9\n\nlemma le_localOscillation [CompatibleFunctions \ud835\udd5c X A] (x : X) (r : \u211d) (f g : \u0398 X) {y z : X}\n    (hy : y \u2208 ball x r) (hz : z \u2208 ball x r) : \u2016coe\u0398 f y - coe\u0398 g y - coe\u0398 f z + coe\u0398 g z\u2016 \u2264\n    ENNReal.toReal (localOscillation (ball x r) (coe\u0398 f) (coe\u0398 g)) := by\n  rw [(ENNReal.toReal_ofReal (norm_nonneg _)).symm]\n  let f (z) := \u2a06 (_ : z \u2208 ball x r \u00d7\u02e2 ball x r), ENNReal.ofReal \u2016f z.1 - g z.1 - f z.2 + g z.2\u2016\n  apply ENNReal.toReal_mono\n  \u00b7 exact lt_of_le_of_lt CompatibleFunctions.localOscillation_le_cdist ENNReal.ofReal_lt_top |>.ne\n  \u00b7 exact le_of_eq_of_le (Eq.symm (iSup_pos \u27e8hy, hz\u27e9)) (le_iSup f \u27e8y, z\u27e9)\n\nlemma oscillation_le_cdist [CompatibleFunctions \ud835\udd5c X A] (x : X) (r : \u211d) (f g : \u0398 X) {y z : X}\n    (hy : y \u2208 ball x r) (hz : z \u2208 ball x r) :\n    \u2016coe\u0398 f y - coe\u0398 g y - coe\u0398 f z + coe\u0398 g z\u2016 \u2264 dist_{x, r} f g := by\n  apply le_trans <| le_localOscillation x r f g hy hz\n  rw [\u2190 ENNReal.toReal_ofReal dist_nonneg]\n  exact ENNReal.toReal_mono ENNReal.ofReal_ne_top CompatibleFunctions.localOscillation_le_cdist\n\nexport CompatibleFunctions (localOscillation_le_cdist cdist_mono cdist_le le_cdist)\n\nlemma dist_congr [FunctionDistances \ud835\udd5c X] {x\u2081 x\u2082 : X} {r\u2081 r\u2082 : \u211d} {f g : \u0398 X}\n    (e\u2081 : x\u2081 = x\u2082) (e\u2082 : r\u2081 = r\u2082) : dist_{x\u2081, r\u2081} f g = dist_{x\u2082, r\u2082} f g := by congr\n\nvariable (X) in\n/-- The point `o` in the blueprint -/\ndef cancelPt [CompatibleFunctions \ud835\udd5c X A] : X :=\n  CompatibleFunctions.eq_zero (\ud835\udd5c := \ud835\udd5c) |>.choose\nlemma cancelPt_eq_zero [CompatibleFunctions \ud835\udd5c X A] {f : \u0398 X} : f (cancelPt X) = 0 :=\n  CompatibleFunctions.eq_zero (\ud835\udd5c := \ud835\udd5c) |>.choose_spec f\n\n-- not sure if needed\n-- lemma CompatibleFunctions.IsSeparable [CompatibleFunctions \ud835\udd5c X A] :\n--   IsSeparable (range (coe\u0398 (X := X))) :=\n--   sorry\n\nset_option linter.unusedVariables false in\n/-- The inhomogeneous Lipschitz norm on a ball. -/\ndef iLipNorm {\ud835\udd5c} [NormedField \ud835\udd5c] (\u03d5 : X \u2192 \ud835\udd5c) (x\u2080 : X) (R : \u211d) : \u211d :=\n  (\u2a06 x \u2208 ball x\u2080 R, \u2016\u03d5 x\u2016) + R * \u2a06 (x : X) (y : X) (h : x \u2260 y), \u2016\u03d5 x - \u03d5 y\u2016 / dist x y\n\nlemma iLipNorm_nonneg {\ud835\udd5c} [NormedField \ud835\udd5c] {\u03d5 : X \u2192 \ud835\udd5c} {x\u2080 : X} {R : \u211d} (hR : 0 \u2264 R) :\n    0 \u2264 iLipNorm \u03d5 x\u2080 R :=\n  add_nonneg (Real.iSup_nonneg fun _ \u21a6 Real.iSup_nonneg fun _ \u21a6 norm_nonneg _)\n    (mul_nonneg hR (Real.iSup_nonneg fun _ \u21a6 Real.iSup_nonneg fun _ \u21a6 Real.iSup_nonneg\n    fun _ \u21a6 div_nonneg (norm_nonneg _) dist_nonneg))\n\nvariable [DoublingMeasure X A]\n\nvariable (X) in\n/-- \u0398 is \u03c4-cancellative. `\u03c4` will usually be `1 / a` -/\nclass IsCancellative (\u03c4 : \u211d) [CompatibleFunctions \u211d X A] : Prop where\n  norm_integral_exp_le {x : X} {r : \u211d} {\u03d5 : X \u2192 \u2102} {K : \u211d\u22650} (h1 : LipschitzWith K \u03d5)\n    (h2 : tsupport \u03d5 \u2286 ball x r) {f g : \u0398 X} :\n    \u2016\u222b x in ball x r, exp (I * (f x - g x)) * \u03d5 x\u2016 \u2264\n    A * volume.real (ball x r) * iLipNorm \u03d5 x r * (1 + dist_{x, r} f g) ^ (- \u03c4)\n\nexport IsCancellative (norm_integral_exp_le)\n\n/-- The \"volume function\" `V`. Note that we will need to assume\n`IsFiniteMeasureOnCompacts` and `ProperSpace` to actually know that this volume is finite. -/\ndef Real.vol {X : Type*} [PseudoMetricSpace X] [MeasureSpace X] (x y : X) : \u211d :=\n  volume.real (ball x (dist x y))\n\n-- /-- In Mathlib we only have the operator norm for continuous linear maps,\n-- and `T_*` is not linear.\n-- Here is the norm for an arbitrary map `T` between normed spaces\n-- (the infimum is defined to be 0 if the operator is not bounded). -/\n-- def operatorNorm {E F : Type*} [NormedAddCommGroup E] [NormedAddCommGroup F] (T : E \u2192 F) : \u211d :=\n--   sInf { c | 0 \u2264 c \u2227 \u2200 x, \u2016T x\u2016 \u2264 c * \u2016x\u2016 }\n\n/-- The Calderon Zygmund operator `T_r` in chapter Two-sided Metric Space Carleson -/\ndef CZOperator (K : X \u2192 X \u2192 \u2102) (r : \u211d) (f : X \u2192 \u2102) (x : X) : \u2102 :=\n  \u222b y in (ball x r)\u1d9c, K x y * f y\n\n/-- `R_Q(\u03b8, x)` defined in (1.0.20). -/\ndef upperRadius [FunctionDistances \u211d X] (Q : X \u2192 \u0398 X) (\u03b8 : \u0398 X) (x : X) : \u211d\u22650\u221e :=\n  \u2a06 (r : \u211d) (_ : dist_{x, r} \u03b8 (Q x) < 1), ENNReal.ofReal r\n\nlemma le_upperRadius [FunctionDistances \u211d X] {Q : X \u2192 \u0398 X} {\u03b8 : \u0398 X} {x : X} {r : \u211d}\n    (hr : dist_{x, r} \u03b8 (Q x) < 1) : ENNReal.ofReal r \u2264 upperRadius Q \u03b8 x := by\n  apply le_iSup\u2082 (f := fun r _ \u21a6 ENNReal.ofReal r) r hr\n\n/-- The linearized maximally truncated nontangential Calderon Zygmund operator `T_Q^\u03b8` -/\ndef linearizedNontangentialOperator [FunctionDistances \u211d X] (Q : X \u2192 \u0398 X) (\u03b8 : \u0398 X)\n    (K : X \u2192 X \u2192 \u2102) (f : X \u2192 \u2102) (x : X) : \u211d\u22650\u221e :=\n  \u2a06 (R\u2081 : \u211d) (x' : X) (_ : dist x x' \u2264 R\u2081),\n  \u2016\u222b y in {y | ENNReal.ofReal (dist x' y) \u2208 Ioo (ENNReal.ofReal R\u2081) (upperRadius Q \u03b8 x')},\n    K x' y * f y\u2016\u208a\n\n/-- The maximally truncated nontangential Calderon Zygmund operator `T_*` -/\ndef nontangentialOperator (K : X \u2192 X \u2192 \u2102) (f : X \u2192 \u2102) (x : X) : \u211d\u22650\u221e :=\n  \u2a06 (R\u2081 : \u211d) (R\u2082 : \u211d) (_ : R\u2081 < R\u2082) (x' : X) (_ : dist x x' < R\u2081),\n  \u2016\u222b y in {y | dist x' y \u2208 Ioo R\u2081 R\u2082}, K x' y * f y\u2016\u208a\n\n/-- The linearized generalized Carleson operator `T_Q`, taking values in `\u211d\u22650\u221e`.\nUse `ENNReal.toReal` to get the corresponding real number. -/\ndef linearizedCarlesonOperator [FunctionDistances \u211d X] (Q : X \u2192 \u0398 X) (K : X \u2192 X \u2192 \u2102)\n    (f : X \u2192 \u2102) (x : X) : \u211d\u22650\u221e :=\n  \u2a06 (R\u2081 : \u211d) (R\u2082 : \u211d) (_ : 0 < R\u2081) (_ : R\u2081 < R\u2082),\n  \u2016\u222b y in {y | dist x y \u2208 Ioo R\u2081 R\u2082}, K x y * f y * exp (I * Q x y)\u2016\u208a\n\n/-- The generalized Carleson operator `T`, taking values in `\u211d\u22650\u221e`.\nUse `ENNReal.toReal` to get the corresponding real number. -/\ndef carlesonOperator [FunctionDistances \u211d X] (K : X \u2192 X \u2192 \u2102) (f : X \u2192 \u2102) (x : X) : \u211d\u22650\u221e :=\n  \u2a06 (\u03b8 : \u0398 X), linearizedCarlesonOperator (fun _ \u21a6 \u03b8) K f x\n\n\nend DoublingMeasure\n\n/-- This is usually the value of the argument `A` in `DoublingMeasure`\nand `CompatibleFunctions` -/\n@[simp] abbrev defaultA (a : \u2115) : \u2115 := 2 ^ a\n@[simp] def defaultD (a : \u2115) : \u2115 := 2 ^ (100 * a ^ 2)\n@[simp] def default\u03ba (a : \u2115) : \u211d := 2 ^ (-10 * (a : \u211d))\n@[simp] def defaultZ (a : \u2115) : \u2115 := 2 ^ (12 * a)\n@[simp] def default\u03c4 (a : \u2115) : \u211d := a\u207b\u00b9\n\nlemma defaultD_pos (a : \u2115) : 0 < (defaultD a : \u211d) := by rw [defaultD]; positivity\n\nlemma defaultD_pos' (a : \u2115) : 0 < defaultD a := by exact_mod_cast defaultD_pos a\n\nlemma defaultD_pow_pos (a : \u2115) (z : \u2124) : 0 < (defaultD a : \u211d) ^ z :=\n  zpow_pos (defaultD_pos _) _\n\nlemma mul_defaultD_pow_pos (a : \u2115) {r : \u211d} (hr : 0 < r) (z : \u2124) : 0 < r * (defaultD a : \u211d) ^ z :=\n  mul_pos hr (defaultD_pow_pos a z)\n\nsection Kernel\n\nvariable {X : Type*} {a : \u2115} {K : X \u2192 X \u2192 \u2102} [PseudoMetricSpace X] [MeasureSpace X]\nopen Real (vol)\nopen Function\n\n/-- The constant used twice in the definition of the Calderon-Zygmund kernel. -/\n@[simp] def C_K (a : \u211d) : \u211d := 2 ^ a ^ 3\n\nlemma C_K_pos (a : \u211d) : 0 < C_K a := by unfold C_K; positivity\n\n/-- `K` is a one-sided Calderon-Zygmund kernel\nIn the formalization `K x y` is defined everywhere, even for `x = y`. The assumptions on `K` show\nthat `K x x = 0`. -/\nclass IsOneSidedKernel (a : outParam \u2115) (K : X \u2192 X \u2192 \u2102) : Prop where\n  measurable_K : Measurable (uncurry K)\n  norm_K_le_vol_inv (x y : X) : \u2016K x y\u2016 \u2264 C_K a / vol x y\n  norm_K_sub_le {x y y' : X} (h : 2 * dist y y' \u2264 dist x y) :\n    \u2016K x y - K x y'\u2016 \u2264 (dist y y' / dist x y) ^ (a : \u211d)\u207b\u00b9 * (C_K a / vol x y)\n\nexport IsOneSidedKernel (measurable_K norm_K_le_vol_inv norm_K_sub_le)\n\nlemma MeasureTheory.stronglyMeasurable_K [IsOneSidedKernel a K] :\n    StronglyMeasurable (uncurry K) :=\n  measurable_K.stronglyMeasurable\n\nlemma MeasureTheory.aestronglyMeasurable_K [IsOneSidedKernel a K] :\n    AEStronglyMeasurable (uncurry K) :=\n  measurable_K.aestronglyMeasurable\n\nlemma measurable_K_left [IsOneSidedKernel a K] (y : X) : Measurable (K \u00b7 y) :=\n  measurable_K.of_uncurry_right\n\nlemma measurable_K_right [IsOneSidedKernel a K] (x : X) : Measurable (K x) :=\n  measurable_K.of_uncurry_left\n\nlemma integrableOn_K_Icc [IsOpenPosMeasure (volume : Measure X)] [ProperSpace X]\n    [Regular (volume : Measure X)] [IsOneSidedKernel a K] {x : X} {r R : \u211d} (hr : r > 0) :\n    IntegrableOn (K x) {y | dist x y \u2208 Icc r R} volume := by\n  use Measurable.aestronglyMeasurable (measurable_K_right x)\n  rw [hasFiniteIntegral_def]\n  calc \u222b\u207b (y : X) in {y | dist x y \u2208 Icc r R}, \u2016K x y\u2016\u2091\n    _ \u2264 \u222b\u207b (y : X) in {y | dist x y \u2208 Icc r R},\n          ENNReal.ofReal (C_K a / volume.real (ball x r)) := by\n      refine setLIntegral_mono measurable_const (fun y hy \u21a6 ?_)\n      rw [\u2190 ofReal_norm]\n      refine ENNReal.ofReal_le_ofReal <| (norm_K_le_vol_inv x y).trans ?_\n      gcongr\n      \u00b7 exact (C_K_pos a).le\n      \u00b7 rw [measureReal_def]\n        apply ENNReal.toReal_pos (ne_of_gt <| measure_ball_pos volume x hr)\n        exact measure_ball_ne_top x r\n      \u00b7 exact measureReal_mono (ball_subset_ball hy.1)\n    _ < _ := by\n      rw [lintegral_const]\n      apply ENNReal.mul_lt_top ENNReal.ofReal_lt_top\n      rw [Measure.restrict_apply MeasurableSet.univ, univ_inter]\n      refine (Ne.lt_top fun h \u21a6 ?_)\n      have : {y | dist x y \u2208 Icc r R} \u2286 closedBall x R := by\n        intro y \u27e8_, hy\u27e9\n        exact mem_closedBall_comm.mp hy\n      exact measure_closedBall_lt_top.ne (measure_mono_top this h)\n\n/-- `K` is a two-sided Calderon-Zygmund kernel\nIn the formalization `K x y` is defined everywhere, even for `x = y`. The assumptions on `K` show\nthat `K x x = 0`. -/\nclass IsTwoSidedKernel (a : outParam \u2115) (K : X \u2192 X \u2192 \u2102) extends IsOneSidedKernel a K where\n  norm_K_sub_le' {x x' y : X} (h : 2 * dist x x' \u2264 dist x y) :\n    \u2016K x y - K x' y\u2016 \u2264 (dist x x' / dist x y) ^ (a : \u211d)\u207b\u00b9 * (C_K a / vol x y)\n\nexport IsTwoSidedKernel (norm_K_sub_le')\n\n-- maybe show: `K` is a 2-sided kernel iff `K` and `fun x y \u21a6 K y x` are one-sided kernels.\n\nend Kernel\n\n-- to show: K is locally bounded and hence integrable outside the diagonal\n\n\n/- A constant used on the boundedness of `T_*`. We generally assume\n`HasBoundedStrongType (nontangentialOperator K) volume volume 2 2 (C_Ts a)`\nthroughout this formalization. -/\ndef C_Ts (a : \u211d) : \u211d\u22650 := 2 ^ a ^ 3\n\n/-- Data common through most of chapters 2-9. -/\nclass PreProofData {X : Type*} (a : outParam \u2115) (q : outParam \u211d) (K : outParam (X \u2192 X \u2192 \u2102))\n  (\u03c3\u2081 \u03c3\u2082 : outParam (X \u2192 \u2124)) (F G : outParam (Set X)) [PseudoMetricSpace X] where\n  d : DoublingMeasure X (defaultA a)\n  four_le_a : 4 \u2264 a\n  cf : CompatibleFunctions \u211d X (defaultA a)\n  c : IsCancellative X (default\u03c4 a)\n  hcz : IsOneSidedKernel a K\n  hasBoundedStrongType_Tstar :\n    HasBoundedStrongType (nontangentialOperator K \u00b7 \u00b7) 2 2 volume volume (C_Ts a)\n  measurableSet_F : MeasurableSet F\n  measurableSet_G : MeasurableSet G\n  measurable_\u03c3\u2081 : Measurable \u03c3\u2081\n  measurable_\u03c3\u2082 : Measurable \u03c3\u2082\n  finite_range_\u03c3\u2081 : Finite (range \u03c3\u2081)\n  finite_range_\u03c3\u2082 : Finite (range \u03c3\u2082)\n  \u03c3\u2081_le_\u03c3\u2082 : \u03c3\u2081 \u2264 \u03c3\u2082\n  Q : SimpleFunc X (\u0398 X)\n  q_mem_Ioc : q \u2208 Ioc 1 2\n\nexport PreProofData (four_le_a hasBoundedStrongType_Tstar measurableSet_F measurableSet_G\n  measurable_\u03c3\u2081 measurable_\u03c3\u2082 finite_range_\u03c3\u2081 finite_range_\u03c3\u2082 \u03c3\u2081_le_\u03c3\u2082 Q q_mem_Ioc)\nattribute [instance] PreProofData.d PreProofData.cf PreProofData.c PreProofData.hcz\n\nsection ProofData\n\nvariable {X : Type*} {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102} {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X}\n  [PseudoMetricSpace X] [PreProofData a q K \u03c3\u2081 \u03c3\u2082 F G]\n\nsection Iterate\n\nlemma le_cdist_iterate {x : X} {r : \u211d} (hr : 0 \u2264 r) (f g : \u0398 X) (k : \u2115) :\n    2 ^ k * dist_{x, r} f g \u2264 dist_{x, (defaultA a) ^ k * r} f g := by\n  induction k with\n  | zero => rw [pow_zero, one_mul]; congr! <;> simp\n  | succ k ih =>\n    trans 2 * dist_{x, (defaultA a) ^ k * r} f g\n    \u00b7 rw [pow_succ', mul_assoc]\n      exact (mul_le_mul_left zero_lt_two).mpr ih\n    \u00b7 convert le_cdist (ball_subset_ball _) using 1\n      \u00b7 exact dist_congr rfl (by rw [\u2190 mul_assoc, pow_succ'])\n      \u00b7 nth_rw 1 [\u2190 one_mul ((defaultA a) ^ k * r)]; gcongr\n        rw [\u2190 Nat.cast_one, Nat.cast_le]; exact Nat.one_le_two_pow\n\nlemma cdist_le_iterate {x : X} {r : \u211d} (hr : 0 < r) (f g : \u0398 X) (k : \u2115) :\n    dist_{x, 2 ^ k * r} f g \u2264 (defaultA a) ^ k * dist_{x, r} f g := by\n  induction k with\n  | zero => simp_rw [pow_zero, one_mul]; congr! <;> simp\n  | succ k ih =>\n    trans defaultA a * dist_{x, 2 ^ k * r} f g\n    \u00b7 convert cdist_le _ using 1\n      \u00b7 exact dist_congr rfl (by ring)\n      \u00b7 rw [dist_self]; positivity\n    \u00b7 replace ih := (mul_le_mul_left (show 0 < (defaultA a : \u211d) by positivity)).mpr ih\n      rwa [\u2190 mul_assoc, \u2190 pow_succ'] at ih\n\nlemma ballsCoverBalls_iterate_nat {x : X} {d r : \u211d} {n : \u2115} :\n    BallsCoverBalls (WithFunctionDistance x d) (2 ^ n * r) r (defaultA a ^ n) := by\n  have double := fun s \u21a6 PreProofData.cf.ballsCoverBalls (x := x) (r := d) (R := s)\n  apply BallsCoverBalls.pow_mul double\n\nlemma ballsCoverBalls_iterate {x : X} {d R r : \u211d} (hR : 0 < R) (hr : 0 < r) :\n    BallsCoverBalls (WithFunctionDistance x d) R r (defaultA a ^ \u2308Real.logb 2 (R / r)\u2309\u208a) := by\n  apply ballsCoverBalls_iterate_nat.mono\n  calc\n    _ = R / r * r := by rw [div_mul_cancel\u2080 R hr.ne']\n    _ = 2 ^ Real.logb 2 (R / r) * r := by\n      rw [Real.rpow_logb zero_lt_two one_lt_two.ne' (by positivity)]\n    _ \u2264 _ := by\n      gcongr\n      rw [\u2190 Real.rpow_natCast]\n      exact Real.rpow_le_rpow_of_exponent_le one_le_two (Nat.le_ceil _)\n\nend Iterate\n\n@[fun_prop]\nlemma measurable_Q\u2082 : Measurable fun p : X \u00d7 X \u21a6 Q p.1 p.2 := fun s meass \u21a6 by\n  have : (fun p : X \u00d7 X \u21a6 (Q p.1) p.2) \u207b\u00b9' s = \u22c3 \u03b8 \u2208 Q.range, (Q \u207b\u00b9' {\u03b8}) \u00d7\u02e2 (\u03b8 \u207b\u00b9' s) := by\n    ext \u27e8x, y\u27e9\n    simp only [mem_preimage, SimpleFunc.mem_range, mem_range, iUnion_exists, iUnion_iUnion_eq',\n      mem_iUnion, mem_prod, mem_singleton_iff]\n    constructor <;> intro h\n    \u00b7 use x\n    \u00b7 obtain \u27e8j, hj\u27e9 := h; exact congr($(hj.1) y).symm \u25b8 hj.2\n  rw [this]\n  exact Q.range.measurableSet_biUnion fun \u03b8 _ \u21a6\n    (Q.measurableSet_fiber \u03b8).prod (meass.preimage (map_continuous \u03b8).measurable)\n\nlemma stronglyMeasurable_Q\u2082 : StronglyMeasurable fun p : X \u00d7 X \u21a6 Q p.1 p.2 :=\n  measurable_Q\u2082.stronglyMeasurable\n\n@[fun_prop]\nlemma aestronglyMeasurable_Q\u2082 : AEStronglyMeasurable fun p : X \u00d7 X \u21a6 Q p.1 p.2 :=\n  measurable_Q\u2082.aestronglyMeasurable\n\n@[fun_prop]\nlemma measurable_Q\u2081 (x : X) : Measurable (Q x) :=\n  let Q' : X \u2192 X \u2192 \u211d := fun x' y \u21a6 Q x' y\n  have : (fun y \u21a6 Q' x y) = Q x := rfl\n  this \u25b8 measurable_Q\u2082.of_uncurry_left\n\ninclude a q K \u03c3\u2081 \u03c3\u2082 F G\n\nvariable (X) in\nlemma S_spec : \u2203 n : \u2115, \u2200 x, -n \u2264 \u03c3\u2081 x \u2227 \u03c3\u2082 x \u2264 n := by\n  have h1 : (range \u03c3\u2081).Finite := finite_range_\u03c3\u2081\n  have h2 : (range \u03c3\u2082).Finite := finite_range_\u03c3\u2082\n  have h1' := bddBelow_def.mp h1.bddBelow\n  have h2' := bddAbove_def.mp h2.bddAbove\n  refine \u27e8(max (-h1'.choose) h2'.choose).toNat, fun x \u21a6 ?_\u27e9\n  simp only [Int.ofNat_toNat, \u2190 min_neg_neg, neg_neg, min_le_iff, le_max_iff]\n  exact \u27e8Or.inl (Or.inl (h1'.choose_spec _ (mem_range_self x))),\n    Or.inl (Or.inr (h2'.choose_spec _ (mem_range_self x)))\u27e9\n\nsection DBounds\n\nvariable (X)\n\n-- used in 4.1.7 (`small_boundary`)\nlemma twentyfive_le_realD : (25 : \u211d) \u2264 defaultD a := by\n  simp only [defaultD, Nat.ofNat_le_cast]\n  have : 4 \u2264 a := four_le_a X\n  calc\n    (25 : \u2115)\n      \u2264 32 := Nat.le_of_ble_eq_true rfl\n    _ = 2 ^ (5) := by rfl\n    _ \u2264 2 ^ (100 * 4 ^ 2) := Nat.le_of_ble_eq_true (by norm_num)\n    _ \u2264 2 ^ (100 * a ^ 2) := Nat.pow_le_pow_right (by norm_num)\n      (mul_le_mul_of_nonneg_left (Nat.pow_le_pow_of_le_left this 2) (by norm_num))\n\n-- used in 4.1.3 (`I3_prop_3_1`)\nlemma eight_le_realD : (8 : \u211d) \u2264 defaultD a := by\n  linarith [twentyfive_le_realD X]\n\n-- used in 4.1.6 (`transitive_boundary`)\nlemma five_le_realD : (5 : \u211d) \u2264 defaultD a := by\n  linarith [twentyfive_le_realD X]\n\n-- used in various places in `Carleson.TileExistence`\nlemma four_le_realD : (4 : \u211d) \u2264 defaultD a := by\n  linarith [twentyfive_le_realD X]\n\nlemma one_le_realD : (1 : \u211d) \u2264 defaultD a := by\n  linarith [twentyfive_le_realD X]\n\nopen Classical in\ndef defaultS : \u2115 := Nat.find (S_spec X)\n\nend DBounds\n\nlemma range_\u03c3\u2081_subset : range \u03c3\u2081 \u2286 Icc (- defaultS X) (defaultS X) := by\n  classical\n  rw [range_subset_iff]\n  exact fun x \u21a6 \u27e8(Nat.find_spec (S_spec X) x).1, (\u03c3\u2081_le_\u03c3\u2082 x).trans (Nat.find_spec (S_spec X) x).2\u27e9\n\nlemma range_\u03c3\u2082_subset : range \u03c3\u2082 \u2286 Icc (- defaultS X) (defaultS X) := by\n  classical\n  rw [range_subset_iff]\n  exact fun x \u21a6 \u27e8(Nat.find_spec (S_spec X) x).1.trans (\u03c3\u2081_le_\u03c3\u2082 x), (Nat.find_spec (S_spec X) x).2\u27e9\n\nlemma Icc_\u03c3_subset_Icc_S {x : X} : Icc (\u03c3\u2081 x) (\u03c3\u2082 x) \u2286 Icc (- defaultS X) (defaultS X) :=\n  fun _ h \u21a6 \u27e8(range_\u03c3\u2081_subset \u27e8x, rfl\u27e9).1.trans h.1, h.2.trans (range_\u03c3\u2082_subset \u27e8x, rfl\u27e9).2\u27e9\n\nlemma neg_S_mem_or_S_mem [Nonempty X] :\n    (- defaultS X : \u2124) \u2208 range \u03c3\u2081 \u2228 (defaultS X : \u2124) \u2208 range \u03c3\u2082 := by\n  by_cases h\u2080 : defaultS X = 0\n  \u00b7 right\n    simp only [h\u2080, CharP.cast_eq_zero, mem_range]\n    have : range \u03c3\u2082 \u2286 Icc (- defaultS X) (defaultS X) := range_\u03c3\u2082_subset\n    simp only [h\u2080, CharP.cast_eq_zero, neg_zero, Icc_self, subset_singleton_iff, mem_range,\n      forall_exists_index, forall_apply_eq_imp_iff] at this\n    let x : X := Classical.choice inferInstance\n    exact \u27e8x, this x\u27e9\n  by_contra! h\n  let n := (defaultS X) - 1\n  have h1 (x : X) : -n \u2264 \u03c3\u2081 x := by\n    rw [Int.natCast_sub (Nat.one_le_iff_ne_zero.mpr h\u2080), neg_sub, sub_eq_add_neg, add_comm]\n    exact lt_iff_le_and_ne.mpr \u27e8(range_\u03c3\u2081_subset (mem_range_self x)).1,\n      fun h' \u21a6 h.1 <| mem_range.mpr \u27e8x, h'.symm\u27e9\u27e9\n  have h2 (x : X) : \u03c3\u2082 x \u2264 n :=\n    Int.natCast_sub (Nat.one_le_iff_ne_zero.mpr h\u2080) \u25b8 le_sub_right_of_add_le (lt_iff_le_and_ne.mpr\n      \u27e8(range_\u03c3\u2082_subset (mem_range_self x)).2, fun h' \u21a6 h.2 <| mem_range.mpr \u27e8x, h'\u27e9\u27e9)\n  have hn : n < defaultS X := by\n    simp only [tsub_lt_self_iff, zero_lt_one, and_true, n]\n    exact Nat.zero_lt_of_ne_zero h\u2080\n  classical\n  exact Nat.find_min (S_spec X) hn fun x \u21a6 \u27e8h1 x, h2 x\u27e9\n\nvariable (X)\n\nlemma a_pos : 0 < a := by linarith [four_le_a X]\nlemma cast_a_pos : 0 < (a : \u211d) := by norm_cast; exact a_pos X\nlemma \u03c4_pos : 0 < default\u03c4 a := inv_pos.mpr (cast_a_pos X)\nlemma \u03c4_nonneg : 0 \u2264 default\u03c4 a := (\u03c4_pos X).le\n\n/-- `\u03c4` as an element of `\u211d\u22650`. -/\ndef nn\u03c4 : \u211d\u22650 := \u27e8default\u03c4 a, \u03c4_nonneg X\u27e9\n\nlemma one_lt_q : 1 < q := (q_mem_Ioc X).1\nlemma q_le_two : q \u2264 2 := (q_mem_Ioc X).2\nlemma q_pos : 0 < q := zero_lt_one.trans (one_lt_q X)\nlemma q_nonneg : 0 \u2264 q := (q_pos X).le\nlemma inv_q_sub_half_nonneg : 0 \u2264 q\u207b\u00b9 - 2\u207b\u00b9 := by\n  simp [inv_le_inv\u2080 zero_lt_two (q_pos X), q_le_two X]\n\n/-- `q` as an element of `\u211d\u22650`. -/\ndef nnq : \u211d\u22650 := \u27e8q, q_nonneg X\u27e9\n\nlemma one_lt_nnq : 1 < nnq X := one_lt_q X\nlemma nnq_le_two : nnq X \u2264 2 := q_le_two X\nlemma nnq_pos : 0 < nnq X := q_pos X\nlemma nnq_mem_Ioc : nnq X \u2208 Ioc 1 2 :=\n  \u27e8NNReal.coe_lt_coe.mp (q_mem_Ioc X).1, NNReal.coe_le_coe.mp (q_mem_Ioc X).2\u27e9\n\nend ProofData\n\nclass ProofData {X : Type*} (a : outParam \u2115) (q : outParam \u211d) (K : outParam (X \u2192 X \u2192 \u2102))\n    (\u03c3\u2081 \u03c3\u2082 : outParam (X \u2192 \u2124)) (F G : outParam (Set X)) [PseudoMetricSpace X]\n    extends PreProofData a q K \u03c3\u2081 \u03c3\u2082 F G where\n  F_subset : F \u2286 ball (cancelPt X) (defaultD a ^ defaultS X / 4)\n  G_subset : G \u2286 ball (cancelPt X) (defaultD a ^ defaultS X / 4)\n  /- The next two conditions are not in the blueprint, but will be useful in various steps.\n  It is easy to prove finitary_carleson (or metric_carleson) separately when either of these\n  fails. -/\n  volume_F_pos : 0 < volume F\n  volume_G_pos : 0 < volume G\n\nnamespace ShortVariables\n-- open this section to get shorter 1-letter names for a bunch of variables\n\nset_option hygiene false\nscoped notation \"D\" => defaultD a\nscoped notation \"\u03ba\" => default\u03ba a\nscoped notation \"Z\" => defaultZ a\nscoped notation \"\u03c4\" => default\u03c4 a\nscoped notation \"o\" => cancelPt X\nscoped notation \"S\" => defaultS X\nscoped notation \"nn\u03c4\" => nn\u03c4 X\nscoped notation \"nnq\" => nnq X\n\nend ShortVariables\n\nopen scoped ShortVariables\nvariable {X : Type*} {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102} {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X}\n\nlemma one_lt_D [PseudoMetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] : 1 < (D : \u211d) := by\n  exact_mod_cast one_lt_pow\u2080 Nat.one_lt_two (by nlinarith [four_le_a X])\n\nlemma one_le_D : 1 \u2264 (D : \u211d) := by\n  rw [\u2190 Nat.cast_one, Nat.cast_le, defaultD, \u2190 pow_zero 2]\n  exact pow_le_pow_right' one_le_two (by positivity)\n\nlemma D_nonneg : 0 \u2264 (D : \u211d) := zero_le_one.trans one_le_D\n\nlemma \u03ba_nonneg : 0 \u2264 \u03ba := by\n  rw [default\u03ba]\n  exact Real.rpow_nonneg (by norm_num) _\n\n/-- Used in `third_exception` (Lemma 5.2.10). -/\nlemma two_le_\u03baZ [PseudoMetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] : 2 \u2264 \u03ba * Z := by\n  rw [default\u03ba, defaultZ, Nat.cast_pow, show ((2 : \u2115) : \u211d) = 2 by rfl,\n    show (2 : \u211d) ^ (12 * a) = 2 ^ (12 * a : \u211d) by norm_cast, \u2190 Real.rpow_add zero_lt_two,\n    show (-10 * a + 12 * a : \u211d) = 2 * a by ring]\n  norm_cast; change 2 ^ 1 \u2264 _\n  exact Nat.pow_le_pow_of_le one_lt_two (by linarith [four_le_a X])\n\n/-- Used in `third_exception` (Lemma 5.2.10). -/\nlemma D\u03baZ_le_two_rpow_100 [PseudoMetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] :\n    (D : \u211d\u22650\u221e) ^ (-\u03ba * Z) \u2264 2 ^ (-100 : \u211d) := by\n  rw [defaultD, Nat.cast_pow, \u2190 ENNReal.rpow_natCast, \u2190 ENNReal.rpow_mul,\n    show ((2 : \u2115) : \u211d\u22650\u221e) = 2 by rfl]\n  apply ENNReal.rpow_le_rpow_of_exponent_le one_le_two\n  rw [default\u03ba, defaultZ, Nat.cast_pow, show ((2 : \u2115) : \u211d) = 2 by rfl, neg_mul,\n    show (2 : \u211d) ^ (12 * a) = 2 ^ (12 * a : \u211d) by norm_cast, mul_neg,\n    \u2190 Real.rpow_add zero_lt_two, show (-10 * a + 12 * a : \u211d) = 2 * a by ring,\n    neg_le_neg_iff]\n  norm_cast\n  calc\n    _ \u2264 100 * a ^ 2 := by nlinarith [four_le_a X]\n    _ \u2264 _ := by\n      nth_rw 1 [\u2190 mul_one (a ^ 2), \u2190 mul_assoc]\n      gcongr; exact Nat.one_le_two_pow\n\nlemma four_le_Z [PseudoMetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] : 4 \u2264 Z := by\n  rw [defaultZ, show 4 = 2 ^ 2 by rfl]\n  exact Nat.pow_le_pow_right zero_lt_two (by linarith [four_le_a X])\n\nvariable (a) in\n/-- `D` as an element of `\u211d\u22650`. -/\ndef nnD : \u211d\u22650 := \u27e8D, by simp [D_nonneg]\u27e9\n\nnamespace ShortVariables\n\nset_option hygiene false\nscoped notation \"nnD\" => nnD a\n\nend ShortVariables\n\nvariable [PseudoMetricSpace X] [h : ProofData a q K \u03c3\u2081 \u03c3\u2082 F G]\n\nlemma volume_F_lt_top : volume F < \u22a4 :=\n  lt_of_le_of_lt (measure_mono ProofData.F_subset) measure_ball_lt_top\n\nlemma volume_F_ne_top : volume F \u2260 \u22a4 := volume_F_lt_top.ne\n\nlemma volume_G_lt_top : volume G < \u22a4 :=\n  lt_of_le_of_lt (measure_mono ProofData.G_subset) measure_ball_lt_top\n\n", "theoremStatement": "lemma volume_G_ne_top : volume G \u2260 \u22a4 ", "theoremName": "volume_G_ne_top", "fileCreated": {"commit": "238b977db22d5b1107a09468e95b78facfd58fd1", "date": "2023-10-20"}, "theoremCreated": {"commit": "88d85ba29f717ee3bb9fbd37379a6fb77b57265f", "date": "2025-01-06"}, "file": "carleson/Carleson/Defs.lean", "module": "Carleson.Defs", "jsonFile": "Carleson.Defs.jsonl", "positionMetadata": {"lineInFile": 637, "tokenPositionInFile": 26342, "theoremPositionInFile": 94}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 5, "repositoryPremises": true, "numRepositoryPremises": 6, "numPremises": 35}, "proofMetadata": {"hasProof": true, "proof": ":= volume_G_lt_top.ne", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 21}}
{"srcContext": "import Mathlib.Analysis.Convex.PartitionOfUnity\nimport Mathlib.Analysis.Calculus.ContDiff.Basic\nimport Mathlib.MeasureTheory.Integral.Average\nimport Mathlib.MeasureTheory.Integral.Bochner\nimport Mathlib.MeasureTheory.Measure.Haar.OfBasis\nimport Mathlib.Topology.MetricSpace.Holder\nimport Mathlib.Data.Set.Card\nimport Mathlib.Data.Real.ENatENNReal\nimport Carleson.ToMathlib.MeasureReal\n\n/-\n* This file can import all ToMathlib files.\n* If adding more than a few results, please put them in a more appropriate file in ToMathlib.\n-/\n\nopen Function Set\nopen scoped ENNReal\n\nsection ENNReal\n\nlemma tsum_one_eq' {\u03b1 : Type*} (s : Set \u03b1) : \u2211' (_:s), (1 : \u211d\u22650\u221e) = s.encard := by\n  if hfin : s.Finite then\n    have hfin' : Finite s := hfin\n    rw [tsum_def]\n    simp only [ENNReal.summable, \u2193reduceDIte]\n    have hsup: support (fun (_ : s) \u21a6 (1 : \u211d\u22650\u221e)) = Set.univ := by\n      ext i\n      simp only [mem_support, ne_eq, one_ne_zero, not_false_eq_true, mem_univ]\n    have hsupfin: (Set.univ : Set s).Finite := finite_univ\n    rw [\u2190 hsup] at hsupfin\n    rw [if_pos hsupfin]\n    rw [hfin.encard_eq_coe_toFinset_card]\n    simp only [ENat.toENNReal_coe]\n    rw [Finset.card_eq_sum_ones]\n    rw [finsum_eq_sum (fun (_ : s) \u21a6 (1 :\u211d\u22650\u221e)) hsupfin]\n    simp only [Finset.sum_const, nsmul_eq_mul, mul_one, smul_eq_mul, Nat.cast_inj]\n    apply Finset.card_bij (fun a _ => a.val)\n    \u00b7 intro a\n      simp only [Finite.mem_toFinset, mem_support, ne_eq, one_ne_zero, not_false_eq_true,\n        Subtype.coe_prop, imp_self]\n    \u00b7 intro a _ a' _ heq\n      ext\n      exact heq\n    \u00b7 intro a ha\n      use \u27e8a,by\n        simp only [Finite.mem_toFinset] at ha\n        exact ha\u27e9\n      simp only [Finite.mem_toFinset, mem_support, ne_eq, one_ne_zero, not_false_eq_true,\n        exists_const]\n  else\n  have : Infinite s := infinite_coe_iff.mpr hfin\n  rw [ENNReal.tsum_const_eq_top_of_ne_zero (by norm_num)]\n  rw [Set.encard_eq_top_iff.mpr hfin]\n  simp only [ENat.toENNReal_top]\n\nlemma ENNReal.tsum_const_eq' {\u03b1 : Type*} (s : Set \u03b1) (c : \u211d\u22650\u221e) :\n    \u2211' (_:s), (c : \u211d\u22650\u221e) = s.encard * c := by\n  nth_rw 1 [\u2190 one_mul c]\n  rw [ENNReal.tsum_mul_right,tsum_one_eq']\n\n/-! ## `ENNReal` manipulation lemmas -/\n\nlemma ENNReal.sum_geometric_two_pow_toNNReal {k : \u2115} (hk : k > 0) :\n    \u2211' (n : \u2115), (2 : \u211d\u22650\u221e) ^ (-k * n : \u2124) = (1 / (1 - 1 / 2 ^ k) : \u211d).toNNReal := by\n  conv_lhs =>\n    enter [1, n]\n    rw [\u2190 rpow_intCast, show (-k * n : \u2124) = (-k * n : \u211d) by simp, rpow_mul, rpow_natCast]\n  rw [tsum_geometric, show (2 : \u211d\u22650\u221e) = (2 : \u211d).toNNReal by simp,\n    \u2190 coe_rpow_of_ne_zero (by simp), \u2190 Real.toNNReal_rpow_of_nonneg zero_le_two,\n    \u2190 coe_one, \u2190 Real.toNNReal_one, \u2190 coe_sub, NNReal.sub_def,\n    Real.toNNReal_one, NNReal.coe_one, Real.coe_toNNReal', max_eq_left (by positivity),\n    Real.rpow_neg zero_le_two, Real.rpow_natCast, one_div]\n  have : ((1 : \u211d) - (2 ^ k)\u207b\u00b9).toNNReal \u2260 0 := by\n    rw [ne_eq, Real.toNNReal_eq_zero, tsub_le_iff_right, zero_add, not_le, inv_lt_one_iff\u2080]\n    right; exact one_lt_pow\u2080 (M\u2080 := \u211d) _root_.one_lt_two hk.ne'\n  rw [\u2190 coe_inv this, coe_inj, Real.toNNReal_inv, one_div]\n\nlemma ENNReal.sum_geometric_two_pow_neg_one : \u2211' (n : \u2115), (2 : \u211d\u22650\u221e) ^ (-n : \u2124) = 2 := by\n  conv_lhs => enter [1, n]; rw [\u2190 one_mul (n : \u2124), \u2190 neg_mul, \u2190 Nat.cast_one]\n  rw [ENNReal.sum_geometric_two_pow_toNNReal zero_lt_one]; norm_num\n\nlemma ENNReal.sum_geometric_two_pow_neg_two :\n    \u2211' (n : \u2115), (2 : \u211d\u22650\u221e) ^ (-2 * n : \u2124) = ((4 : \u211d) / 3).toNNReal := by\n  conv_lhs => enter [1, n, 2]; rw [\u2190 Nat.cast_two]\n  rw [ENNReal.sum_geometric_two_pow_toNNReal zero_lt_two]; norm_num\n\nlemma tsum_geometric_ite_eq_tsum_geometric {k c : \u2115} :\n    (\u2211' (n : \u2115), if k \u2264 n then (2 : \u211d\u22650\u221e) ^ (-c * (n - k) : \u2124) else 0) =\n    \u2211' (n : \u2115), 2 ^ (-c * n : \u2124) := by\n  convert (Injective.tsum_eq (f := fun n \u21a6 if k \u2264 n then (2 : \u211d\u22650\u221e) ^ (-c * (n - k) : \u2124) else 0)\n    (add_left_injective k) (fun n mn \u21a6 _)).symm\n  \u00b7 simp\n  \u00b7 rw [mem_support, ne_eq, ite_eq_right_iff, Classical.not_imp] at mn\n    use n - k, Nat.sub_add_cancel mn.1\n\nlemma ENNReal.toReal_zpow (x : \u211d\u22650\u221e) (z : \u2124) : x.toReal ^ z = (x ^ z).toReal := by\n  rw [\u2190 rpow_intCast, \u2190 toReal_rpow, Real.rpow_intCast]\n\nend ENNReal\n\nsection Indicator\nattribute [gcongr] Set.indicator_le_indicator mulIndicator_le_mulIndicator_of_subset\nend Indicator\n\n\nnamespace MeasureTheory\n\n/-! ## Partitioning an interval -/\n\n\nlemma lintegral_Ioc_partition {a b : \u2115} {c : \u211d} {f : \u211d \u2192 \u211d\u22650\u221e} (hc : 0 \u2264 c) :\n    \u222b\u207b t in Ioc (a * c) (b * c), f t =\n    \u2211 l \u2208 Finset.Ico a b, \u222b\u207b t in Ioc (l * c) ((l + 1 : \u2115) * c), f t := by\n  rcases lt_or_le b a with h | h\n  \u00b7 rw [Finset.Ico_eq_empty (by omega), Ioc_eq_empty (by rw [not_lt]; gcongr),\n      setLIntegral_empty, Finset.sum_empty]\n  induction b, h using Nat.le_induction with\n  | base =>\n    rw [Finset.Ico_self, Ioc_self, setLIntegral_empty, Finset.sum_empty]\n  | succ b h ih =>\n    have li : a * c \u2264 b * c := by gcongr\n    rw [\u2190 Ioc_union_Ioc_eq_Ioc li (by gcongr; omega),\n      lintegral_union measurableSet_Ioc Ioc_disjoint_Ioc_same,\n      Nat.Ico_succ_right_eq_insert_Ico h, Finset.sum_insert Finset.right_not_mem_Ico,\n      add_comm (lintegral ..), ih]\n\n/-! ## Averaging -/\n\n-- Named for consistency with `lintegral_add_left'`\n-- Maybe add laverage/laverage theorems for all the other lintegral_add statements?\nlemma laverage_add_left {\u03b1 : Type*} {m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}\n    {f g : \u03b1 \u2192 ENNReal} (hf : AEMeasurable f \u03bc) :\n    \u2a0d\u207b x, (f x + g x) \u2202\u03bc = \u2a0d\u207b x, f x \u2202\u03bc + \u2a0d\u207b x, g x \u2202\u03bc := by\n  simp_rw [laverage_eq, ENNReal.div_add_div_same, lintegral_add_left' hf]\n\n-- Named for consistency with `lintegral_mono'`\nlemma laverage_mono {\u03b1 : Type*} {m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}\n    {f g : \u03b1 \u2192 ENNReal} (h : \u2200 x, f x \u2264 g x) :\n    \u2a0d\u207b x, f x \u2202\u03bc \u2264 \u2a0d\u207b x, g x \u2202\u03bc := by\n  simp_rw [laverage_eq]\n  exact ENNReal.div_le_div_right (lintegral_mono h) (\u03bc univ)\n\nlemma laverage_const_mul {\u03b1 : Type*} {m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}\n    {f : \u03b1 \u2192 ENNReal} {c : ENNReal} (hc : c \u2260 \u22a4) :\n    c * \u2a0d\u207b x, f x \u2202\u03bc = \u2a0d\u207b x, c * f x \u2202\u03bc := by\n  simp_rw [laverage_eq, \u2190 mul_div_assoc c, lintegral_const_mul' c f hc]\n\n-- The following two lemmas are unused\n\n-- Named for consistency with `lintegral_add_left'`\n-- Maybe add laverage/setLaverage theorems for all the other lintegral_add statements?\nlemma setLaverage_add_left' {\u03b1 : Type*} {m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}\n    {s : Set \u03b1} {f g : \u03b1 \u2192 ENNReal} (hf : AEMeasurable f \u03bc) :\n    \u2a0d\u207b x in s, (f x + g x) \u2202\u03bc = \u2a0d\u207b x in s, f x \u2202\u03bc + \u2a0d\u207b x in s, g x \u2202\u03bc := by\n  simp_rw [setLaverage_eq, ENNReal.div_add_div_same, lintegral_add_left' hf.restrict]\n\n-- Named for consistency with `setLintegral_mono'`\nlemma setLaverage_mono' {\u03b1 : Type*} {m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}\n    {s : Set \u03b1} (hs : MeasurableSet s) {f g : \u03b1 \u2192 ENNReal} (h : \u2200 x \u2208 s, f x \u2264 g x) :\n    \u2a0d\u207b x in s, f x \u2202\u03bc \u2264 \u2a0d\u207b x in s, g x \u2202\u03bc := by\n  simp_rw [setLaverage_eq]\n  exact ENNReal.div_le_div_right (setLIntegral_mono' hs h) (\u03bc s)\n\nend MeasureTheory\n\nnamespace MeasureTheory\nvariable {\u03b1 : Type*} {m : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} {s : Set \u03b1}\n  {F : Type*} [NormedAddCommGroup F]\n\nattribute [fun_prop] Continuous.comp_aestronglyMeasurable\n  AEStronglyMeasurable.mul AEStronglyMeasurable.prod_mk\nattribute [gcongr] Measure.AbsolutelyContinuous.prod -- todo: also add one-sided versions for gcongr\n\n\ntheorem AEStronglyMeasurable.ennreal_toReal {u : \u03b1 \u2192 \u211d\u22650\u221e} (hu : AEStronglyMeasurable u \u03bc) :\n    AEStronglyMeasurable (fun x \u21a6 (u x).toReal) \u03bc := by\n  refine aestronglyMeasurable_iff_aemeasurable.mpr ?_\n  exact ENNReal.measurable_toReal.comp_aemeasurable hu.aemeasurable\n\nlemma laverage_mono_ae {f g : \u03b1 \u2192 \u211d\u22650\u221e} (h : \u2200\u1d50 a \u2202\u03bc, f a \u2264 g a) :\n    \u2a0d\u207b a, f a \u2202\u03bc \u2264 \u2a0d\u207b a, g a \u2202\u03bc := by\n  exact lintegral_mono_ae <| h.filter_mono <| Measure.ae_mono' Measure.smul_absolutelyContinuous\n\n@[gcongr]\nlemma setLAverage_mono_ae {f g : \u03b1 \u2192 \u211d\u22650\u221e} (h : \u2200\u1d50 a \u2202\u03bc, f a \u2264 g a) :\n    \u2a0d\u207b a in s, f a \u2202\u03bc \u2264 \u2a0d\u207b a in s, g a \u2202\u03bc := by\n  refine laverage_mono_ae <| h.filter_mono <| ae_mono Measure.restrict_le_self\n\nlemma setLaverage_const_le {c : \u211d\u22650\u221e} : \u2a0d\u207b _x in s, c \u2202\u03bc \u2264 c := by\n  simp_rw [setLaverage_eq, lintegral_const, Measure.restrict_apply MeasurableSet.univ,\n    univ_inter, div_eq_mul_inv, mul_assoc]\n  conv_rhs => rw [\u2190 mul_one c]\n  gcongr\n  exact ENNReal.mul_inv_le_one (\u03bc s)\n\ntheorem eLpNormEssSup_lt_top_of_ae_ennnorm_bound {f : \u03b1 \u2192 F} {C : \u211d\u22650\u221e}\n    (hfC : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016\u208a \u2264 C) : eLpNormEssSup f \u03bc \u2264 C := essSup_le_of_ae_le C hfC\n\n@[simp]\nlemma ENNReal.nnorm_toReal {x : \u211d\u22650\u221e} : \u2016x.toReal\u2016\u208a = x.toNNReal := by\n  ext; simp [ENNReal.toReal]\n\ntheorem restrict_absolutelyContinuous : \u03bc.restrict s \u226a \u03bc :=\n  fun s hs \u21a6 Measure.restrict_le_self s |>.trans hs.le |>.antisymm <| zero_le _\n\nend MeasureTheory\n\nsection\n\nopen MeasureTheory Bornology\nvariable {E X : Type*} {p : \u211d\u22650\u221e} [NormedAddCommGroup E] [TopologicalSpace X] [MeasurableSpace X]\n  {\u03bc : Measure X} [IsFiniteMeasureOnCompacts \u03bc] {f : X \u2192 E}\n\n---- now obsolete -> `BoundedCompactSupport.mem\u2112p`\n-- lemma _root_.HasCompactSupport.mem\u2112p_of_isBounded (hf : HasCompactSupport f)\n--     (h2f : IsBounded (range f))\n--     (h3f : AEStronglyMeasurable f \u03bc) {p : \u211d\u22650\u221e} : Mem\u2112p f p \u03bc := by\n--   obtain \u27e8C, hC\u27e9 := h2f.exists_norm_le\n--   simp only [mem_range, forall_exists_index, forall_apply_eq_imp_iff] at hC\n--   exact hf.mem\u2112p_of_bound h3f C <| .of_forall hC\n\nend\n\n/-! ## `EquivalenceOn` -/\n\n/-- An equivalence relation on the set `s`. -/\nstructure EquivalenceOn {\u03b1 : Type*} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : Set \u03b1) : Prop where\n  /-- An equivalence relation is reflexive: `x ~ x` -/\n  refl  : \u2200 x \u2208 s, r x x\n  /-- An equivalence relation is symmetric: `x ~ y` implies `y ~ x` -/\n  symm  : \u2200 {x y}, x \u2208 s \u2192 y \u2208 s \u2192 r x y \u2192 r y x\n  /-- An equivalence relation is transitive: `x ~ y` and `y ~ z` implies `x ~ z` -/\n  trans : \u2200 {x y z}, x \u2208 s \u2192 y \u2208 s \u2192 z \u2208 s \u2192 r x y \u2192 r y z \u2192 r x z\n\n\nnamespace EquivalenceOn\n\nvariable {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : Set \u03b1} {hr : EquivalenceOn r s} {x y : \u03b1}\n\nvariable (hr) in\n/-- The setoid defined from an equivalence relation on a set. -/\nprotected def setoid : Setoid s where\n  r x y := r x y\n  iseqv := {\n    refl := fun x \u21a6 hr.refl x x.2\n    symm := fun {x y} \u21a6 hr.symm x.2 y.2\n    trans := fun {x y z} \u21a6 hr.trans x.2 y.2 z.2\n  }\n\ninclude hr in\nlemma exists_rep (x : \u03b1) : \u2203 y, x \u2208 s \u2192 y \u2208 s \u2227 r x y :=\n  \u27e8x, fun hx \u21a6 \u27e8hx, hr.refl x hx\u27e9\u27e9\n\nopen Classical in\nvariable (hr) in\n/-- An arbitrary representative of `x` w.r.t. the equivalence relation `r`. -/\nprotected noncomputable def out (x : \u03b1) : \u03b1 :=\n  if hx : x \u2208 s then (Quotient.out (s := hr.setoid) \u27e6\u27e8x, hx\u27e9\u27e7 : s) else x\n\nlemma out_mem (hx : x \u2208 s) : hr.out x \u2208 s := by\n  rw [EquivalenceOn.out, dif_pos hx]\n  apply Subtype.prop\n\n@[simp]\nlemma out_mem_iff : hr.out x \u2208 s \u2194 x \u2208 s := by\n  refine \u27e8fun h \u21a6 ?_, out_mem\u27e9\n  by_contra hx\n  rw [EquivalenceOn.out, dif_neg hx] at h\n  exact hx h\n\nlemma out_rel (hx : x \u2208 s) : r (hr.out x) x := by\n  rw [EquivalenceOn.out, dif_pos hx]\n  exact @Quotient.mk_out _ (hr.setoid) \u27e8x, hx\u27e9\n\nlemma rel_out (hx : x \u2208 s) : r x (hr.out x) := hr.symm (out_mem hx) hx (out_rel hx)\n\nlemma out_inj (hx : x \u2208 s) (hy : y \u2208 s) (h : r x y) : hr.out x = hr.out y := by\n  simp_rw [EquivalenceOn.out, dif_pos hx, dif_pos hy]\n  congr 1\n  simp_rw [Quotient.out_inj, Quotient.eq]\n  exact h\n\nlemma out_inj' (hx : x \u2208 s) (hy : y \u2208 s) (h : r (hr.out x) (hr.out y)) : hr.out x = hr.out y := by\n  apply out_inj hx hy\n  refine hr.trans hx ?_ hy (rel_out hx) <| hr.trans ?_ ?_ hy h <| out_rel hy\n  all_goals simpa\n\nvariable (hr) in\n/-- The set of representatives of an equivalence relation on a set. -/\ndef reprs : Set \u03b1 := hr.out '' s\n\nlemma out_mem_reprs (hx : x \u2208 s) : hr.out x \u2208 hr.reprs := \u27e8x, hx, rfl\u27e9\n\nlemma reprs_subset : hr.reprs \u2286 s := by\n  rintro _ \u27e8x, hx, rfl\u27e9\n  exact out_mem hx\n\nlemma reprs_inj (hx : x \u2208 hr.reprs) (hy : y \u2208 hr.reprs) (h : r x y) : x = y := by\n  obtain \u27e8x, hx, rfl\u27e9 := hx\n  obtain \u27e8y, hy, rfl\u27e9 := hy\n  exact out_inj' hx hy h\n\nend EquivalenceOn\n\nnamespace Set.Finite\n\nlemma biSup_eq {\u03b1 : Type*} {\u03b9 : Type*} [CompleteLinearOrder \u03b1] {s : Set \u03b9}\n    (hs : s.Finite) (hs' : s.Nonempty) (f : \u03b9 \u2192 \u03b1) :\n    \u2203 i \u2208 s, \u2a06 j \u2208 s, f j = f i := by\n  simpa [sSup_image, eq_comm] using hs'.image f |>.csSup_mem (hs.image f)\n\nend Set.Finite\n\nlemma Real.self_lt_two_rpow (x : \u211d) : x < 2 ^ x := by\n  rcases lt_or_le x 0 with h | h\n  \u00b7 exact h.trans (rpow_pos_of_pos zero_lt_two x)\n  \u00b7 calc\n      _ < (\u230ax\u230b\u208a.succ : \u211d) := Nat.lt_succ_floor x\n      _ \u2264 2 ^ (\u230ax\u230b\u208a : \u211d) := by exact_mod_cast Nat.lt_pow_self one_lt_two\n      _ \u2264 _ := rpow_le_rpow_of_exponent_le one_le_two (Nat.floor_le h)\n\nnamespace Set\n\nopen ComplexConjugate\n\nlemma indicator_eq_indicator_one_mul {\u03b9 M:Type*} [MulZeroOneClass M]\n    (s : Set \u03b9) (f : \u03b9 \u2192 M) (x : \u03b9) : s.indicator f x = s.indicator 1 x * f x := by\n  simp only [indicator]; split_ifs <;> simp\n\nlemma conj_indicator {\u03b1 \ud835\udd5c : Type*} [RCLike \ud835\udd5c] {f : \u03b1 \u2192 \ud835\udd5c} (s : Set \u03b1) (x : \u03b1):\n    conj (s.indicator f x) = s.indicator (conj f) x := by\n  simp only [indicator]; split_ifs <;> simp\n\nend Set\n\nsection Norm\n\nopen Complex\n\n-- for mathlib?\nlemma norm_indicator_one_le {\u03b1 E}\n    [SeminormedAddCommGroup E] [One E] [NormOneClass E] {s : Set \u03b1} (x : \u03b1) :\n    \u2016s.indicator (1 : \u03b1 \u2192 E) x\u2016 \u2264 1 :=\n  Trans.trans (norm_indicator_le_norm_self 1 x) norm_one\n\nlemma norm_exp_I_mul_ofReal (x : \u211d) : \u2016exp (.I * x)\u2016 = 1 := by\n  rw [mul_comm, Complex.norm_exp_ofReal_mul_I]\n\nlemma norm_exp_I_mul_sub_ofReal (x y: \u211d) : \u2016exp (.I * (x - y))\u2016 = 1 := by\n  rw [mul_comm, \u2190 ofReal_sub, Complex.norm_exp_ofReal_mul_I]\n\nend Norm\n\nnamespace MeasureTheory\n\nopen Metric Bornology\nvariable {\ud835\udd5c: Type*}\nvariable [RCLike \ud835\udd5c]\n\nvariable {X \u03b1: Type*}\n\nnamespace HasCompactSupport\n\nvariable [Zero \u03b1] {f : X \u2192 \u03b1}\n\nvariable [PseudoMetricSpace X] [ProperSpace X]\n\ntheorem of_support_subset_closedBall {x : X}\n    {r : \u211d} (hf : support f \u2286 closedBall x r) :\n    HasCompactSupport f :=\n  HasCompactSupport.of_support_subset_isCompact (isCompact_closedBall ..) hf\n\ntheorem of_support_subset_isBounded {s : Set X}\n    (hs : IsBounded s) (hf : support f \u2286 s) :\n    HasCompactSupport f :=\n  IsCompact.closure_of_subset hs.isCompact_closure <| Trans.trans hf subset_closure\n\nend HasCompactSupport\n\nnamespace Integrable\n\nvariable [MeasureSpace X]\n\n-- must be in mathlib but can't find it\n", "theoremStatement": "theorem indicator_const {c : \u211d} {s: Set X}\n    (hs: MeasurableSet s) (h2s : volume s < \u22a4) : Integrable (s.indicator (fun _ \u21a6 c)) ", "theoremName": "MeasureTheory.Integrable.indicator_const", "fileCreated": {"commit": "f75995f44d3cb33c8f91a124bbc1149e570a24c5", "date": "2023-12-11"}, "theoremCreated": {"commit": "ec175b9008144d009269ce427b9ad43dbd70d0a5", "date": "2024-12-09"}, "file": "carleson/Carleson/ToMathlib/Misc.lean", "module": "Carleson.ToMathlib.Misc", "jsonFile": "Carleson.ToMathlib.Misc.jsonl", "positionMetadata": {"lineInFile": 385, "tokenPositionInFile": 14139, "theoremPositionInFile": 41}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 56}, "proofMetadata": {"hasProof": true, "proof": ":=\n  (integrable_indicator_iff hs).mpr <| integrableOn_const.mpr <| Or.inr h2s", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 78}}
{"srcContext": "import Carleson.MinLayerTiles\n\nopen MeasureTheory Measure NNReal Metric Set\nopen scoped ENNReal\nopen Classical -- We use quite some `Finset.filter`\nnoncomputable section\n\nopen scoped ShortVariables\nvariable {X : Type*} {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102} {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X}\n  [MetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] [TileStructure Q D \u03ba S o]\n\ndef aux\ud835\udcd2 (k : \u2115) : Set (Grid X) :=\n  {i : Grid X | \u2203 j : Grid X, i \u2264 j \u2227 2 ^ (-k : \u2124) * volume (j : Set X) < volume (G \u2229 j) }\n\n/-- The partition `\ud835\udcd2(G, k)` of `Grid X` by volume, given in (5.1.1) and (5.1.2).\nNote: the `G` is fixed with properties in `ProofData`. -/\ndef \ud835\udcd2 (k : \u2115) : Set (Grid X) :=\n  aux\ud835\udcd2 (k + 1) \\ aux\ud835\udcd2 k\n\n/-- The definition `\ud835\udd13(k)` given in (5.1.3). -/\ndef TilesAt (k : \u2115) : Set (\ud835\udd13 X) := \ud835\udcd8 \u207b\u00b9' \ud835\udcd2 k\n\nlemma disjoint_TilesAt_of_ne {m n : \u2115} (h : m \u2260 n) : Disjoint (TilesAt (X := X) m) (TilesAt n) := by\n  wlog hl : m < n generalizing m n; \u00b7 exact (this h.symm (by omega)).symm\n  by_contra! h; rw [not_disjoint_iff] at h; obtain \u27e8p, mp\u2081, mp\u2082\u27e9 := h\n  simp_rw [TilesAt, mem_preimage, \ud835\udcd2, mem_diff, aux\ud835\udcd2, mem_setOf] at mp\u2081 mp\u2082\n  apply absurd _ mp\u2082.2; obtain \u27e8j, lj, vj\u27e9 := mp\u2081.1; use j, lj; apply lt_of_le_of_lt _ vj\n  exact mul_le_mul_right' (ENNReal.zpow_le_of_le one_le_two (by omega)) _\n\nlemma pairwiseDisjoint_TilesAt : univ.PairwiseDisjoint (TilesAt (X := X)) := fun _ _ _ _ \u21a6\n  disjoint_TilesAt_of_ne\n\ndef aux\ud835\udd10 (k n : \u2115) : Set (\ud835\udd13 X) :=\n  {p \u2208 TilesAt k | 2 ^ (-n : \u2124) * volume (\ud835\udcd8 p : Set X) < volume (E\u2081 p) }\n\n/-- The definition `\ud835\udd10(k, n)` given in (5.1.4) and (5.1.5). -/\ndef \ud835\udd10 (k n : \u2115) : Set (\ud835\udd13 X) := {m | Maximal (\u00b7 \u2208 aux\ud835\udd10 k n) m}\n\n/-- The definition `dens'_k(\ud835\udd13')` given in (5.1.6). -/\ndef dens' (k : \u2115) (P' : Set (\ud835\udd13 X)) : \u211d\u22650\u221e :=\n  \u2a06 p' \u2208 P', \u2a06 (l : \u211d\u22650), \u2a06 (_hl : 2 \u2264 l),\n  \u2a06 (p : \ud835\udd13 X) (_h1p : p \u2208 TilesAt k) (_h2p : smul l p' \u2264 smul l p),\n  l ^ (-a : \u2124) * volume (E\u2082 l p) / volume (\ud835\udcd8 p : Set X)\n\nlemma dens'_iSup {k : \u2115} {P : Set (\ud835\udd13 X)} : dens' k P = \u2a06 p \u2208 P, dens' k {p} := by\n  simp_rw [dens', mem_singleton_iff, iSup_iSup_eq_left]\n\ndef aux\u212d (k n : \u2115) : Set (\ud835\udd13 X) :=\n  { p \u2208 TilesAt k | 2 ^ (4 * a - n) < dens' k {p} }\n\n/-- The partition `\u212d(k, n)` of `\ud835\udd13(k)` by density, given in (5.1.7). -/\ndef \u212d (k n : \u2115) : Set (\ud835\udd13 X) :=\n  { p \u2208 TilesAt k | dens' k {p} \u2208 Ioc (2 ^ (4 * a - n : \u2124)) (2 ^ (4 * a - n + 1 : \u2124)) }\n\nlemma \u212d_subset_TilesAt {k n : \u2115} : \u212d k n \u2286 TilesAt (X := X) k := fun t mt \u21a6 by\n  rw [\u212d, mem_setOf] at mt; exact mt.1\n\nlemma disjoint_\u212d_of_ne {k m n : \u2115} (h : m \u2260 n) : Disjoint (\u212d (X := X) k m) (\u212d k n) := by\n  wlog hl : m < n generalizing m n; \u00b7 exact (this h.symm (by omega)).symm\n  by_contra! h; rw [not_disjoint_iff] at h; obtain \u27e8p, mp\u2081, mp\u2082\u27e9 := h\n  apply absurd _ (not_disjoint_iff.mpr \u27e8_, mp\u2081.2, mp\u2082.2\u27e9)\n  rw [Ioc_disjoint_Ioc, le_max_iff]; left; rw [min_le_iff]; right\n  exact ENNReal.zpow_le_of_le one_le_two (by omega)\n\nlemma pairwiseDisjoint_\u212d :\n    (univ : Set (\u2115 \u00d7 \u2115)).PairwiseDisjoint (fun kn \u21a6 \u212d (X := X) kn.1 kn.2) :=\n  fun \u27e8k\u2081, n\u2081\u27e9 _ \u27e8k\u2082, n\u2082\u27e9 _ hn \u21a6 by\n    change Disjoint (\u212d k\u2081 n\u2081) (\u212d k\u2082 n\u2082)\n    by_cases hk : k\u2081 = k\u2082\n    \u00b7 rw [ne_eq, Prod.mk.injEq, not_and] at hn; exact hk \u25b8 disjoint_\u212d_of_ne (hn hk)\n    \u00b7 exact disjoint_of_subset \u212d_subset_TilesAt \u212d_subset_TilesAt (disjoint_TilesAt_of_ne hk)\n\nlemma exists_bound_\u212d : \u2203 (n : \u2115 \u00d7 \u2115),\n    \u2200 x \u2208 {kn : \u2115 \u00d7 \u2115 | (\u212d (X := X) kn.1 kn.2).Nonempty}, Prod.snd x \u2264 Prod.snd n := by\n  apply exists_upper_bound_image\n  have : Set.Finite (\u22c3 kn : \u2115 \u00d7 \u2115, \u212d (X := X) kn.1 kn.2) := toFinite _\n  exact ((Set.finite_iUnion_iff (fun i j hij \u21a6 pairwiseDisjoint_\u212d (mem_univ i) (mem_univ j) hij)).1\n    this).2\n\nvariable (X) in\ndef max\u212d : \u2115 := (exists_bound_\u212d (X := X)).choose.2\n\nlemma le_max\u212d_of_nonempty {k n : \u2115} (h : (\u212d (X := X) k n).Nonempty) : n \u2264 max\u212d X :=\n  (exists_bound_\u212d (X := X)).choose_spec (k, n) h\n\nlemma eq_empty_of_max\u212d_lt {k n : \u2115} (hn : max\u212d X < n) : \u212d (X := X) k n = \u2205 := by\n  contrapose! hn\n  exact (exists_bound_\u212d (X := X)).choose_spec (k, n) hn\n\n/-- Lemma 5.3.11 -/\nlemma dens1_le_dens' {k : \u2115} {P : Set (\ud835\udd13 X)} (hP : P \u2286 TilesAt k) : dens\u2081 P \u2264 dens' k P := by\n  rw [dens\u2081, dens']; gcongr with p' mp' l hl\n  simp_rw [ENNReal.mul_iSup, iSup_le_iff, mul_div_assoc]; intro p mp sl\n  suffices p \u2208 TilesAt k by\n    exact le_iSup_of_le p (le_iSup\u2082_of_le this sl (mul_le_mul' (by norm_cast) le_rfl))\n  simp_rw [TilesAt, mem_preimage, \ud835\udcd2, mem_diff, aux\ud835\udcd2, mem_setOf]\n  constructor\n  \u00b7 rw [mem_lowerClosure] at mp; obtain \u27e8p'', mp'', lp''\u27e9 := mp\n    have hp'' := mem_of_mem_of_subset mp'' hP\n    simp_rw [TilesAt, mem_preimage, \ud835\udcd2, mem_diff, aux\ud835\udcd2, mem_setOf] at hp''\n    obtain \u27e8J, lJ, vJ\u27e9 := hp''.1; use J, lp''.1.trans lJ\n  \u00b7 by_contra h; obtain \u27e8J, lJ, vJ\u27e9 := h\n    have hp' := mem_of_mem_of_subset mp' hP\n    simp_rw [TilesAt, mem_preimage, \ud835\udcd2, mem_diff, aux\ud835\udcd2, mem_setOf] at hp'\n    apply absurd _ hp'.2; use J, sl.1.trans lJ\n\n/-- Lemma 5.3.12 -/\nlemma dens1_le {k n : \u2115} {A : Set (\ud835\udd13 X)} (hA : A \u2286 \u212d k n) : dens\u2081 A \u2264 2 ^ (4 * (a : \u211d) - n + 1) :=\n  calc\n    _ \u2264 dens' k A := dens1_le_dens' (hA.trans \u212d_subset_TilesAt)\n    _ \u2264 dens' k (\u212d (X := X) k n) := iSup_le_iSup_of_subset hA\n    _ \u2264 _ := by\n      rw [dens'_iSup, iSup\u2082_le_iff]; intro p mp\n      rw [\u212d, mem_setOf] at mp; exact_mod_cast mp.2.2\n\n/-- The subset `\ud835\udd05(p)` of `\ud835\udd10(k, n)`, given in (5.1.8). -/\ndef \ud835\udd05 (k n : \u2115) (p : \ud835\udd13 X) : Set (\ud835\udd13 X) :=\n  { m \u2208 \ud835\udd10 k n | smul 100 p \u2264 smul 1 m }\n\ndef pre\u212d\u2081 (k n j : \u2115) : Set (\ud835\udd13 X) :=\n  { p \u2208 \u212d k n | 2 ^ j \u2264 Finset.card { q | q \u2208 \ud835\udd05 k n p } }\n\n/-- The subset `\u212d\u2081(k, n, j)` of `\u212d(k, n)`, given in (5.1.9).\nTogether with `\ud835\udd0f\u2080(k, n)` this forms a partition. -/\ndef \u212d\u2081 (k n j : \u2115) : Set (\ud835\udd13 X) :=\n  pre\u212d\u2081 k n j \\ pre\u212d\u2081 k n (j + 1)\n\nlemma \u212d\u2081_subset_\u212d {k n j : \u2115} : \u212d\u2081 k n j \u2286 \u212d (X := X) k n := fun t mt \u21a6 by\n  rw [\u212d\u2081, pre\u212d\u2081, mem_diff, mem_setOf] at mt; exact mt.1.1\n\nlemma disjoint_\u212d\u2081_of_ne {k n j l : \u2115} (h : j \u2260 l) : Disjoint (\u212d\u2081 (X := X) k n j) (\u212d\u2081 k n l) := by\n  wlog hl : j < l generalizing j l; \u00b7 exact (this h.symm (by omega)).symm\n  by_contra! h; rw [not_disjoint_iff] at h; obtain \u27e8p, mp\u2081, mp\u2082\u27e9 := h\n  simp_rw [\u212d\u2081, mem_diff, pre\u212d\u2081, mem_setOf, mp\u2081.1.1, true_and, not_le] at mp\u2081 mp\u2082\n  have := mp\u2082.1.trans_lt mp\u2081.2\n  rw [pow_lt_pow_iff_right\u2080 one_lt_two] at this; omega\n\nlemma pairwiseDisjoint_\u212d\u2081 {k n : \u2115} : univ.PairwiseDisjoint (\u212d\u2081 (X := X) k n) := fun _ _ _ _ \u21a6\n  disjoint_\u212d\u2081_of_ne\n\nlemma pairwiseDisjoint_\u212d\u2081' :\n    (univ : Set (\u2115 \u00d7 \u2115 \u00d7 \u2115)).PairwiseDisjoint (fun knj \u21a6 \u212d\u2081 (X := X) knj.1 knj.2.1 knj.2.2) := by\n  rintro \u27e8k, n, j\u27e9 - \u27e8k', n', j'\u27e9 - h\n  rcases ne_or_eq k k' with hkk' | rfl\n  \u00b7 have := pairwiseDisjoint_\u212d (X := X) (mem_univ (k, n)) (mem_univ (k', n')) (by simp [hkk'])\n    exact this.mono \u212d\u2081_subset_\u212d \u212d\u2081_subset_\u212d\n  rcases ne_or_eq n n' with hnn' | rfl\n  \u00b7 have := pairwiseDisjoint_\u212d (X := X) (mem_univ (k, n)) (mem_univ (k, n')) (by simp [hnn'])\n    exact this.mono \u212d\u2081_subset_\u212d \u212d\u2081_subset_\u212d\n  exact disjoint_\u212d\u2081_of_ne (by simpa using h)\n\nlemma card_\ud835\udd05_of_mem_\u212d\u2081 {k n j : \u2115} {p : \ud835\udd13 X} (hp : p \u2208 \u212d\u2081 k n j) :\n    (\ud835\udd05 k n p).toFinset.card \u2208 Ico (2 ^ j) (2 ^ (j + 1)) := by\n  simp_rw [\u212d\u2081, mem_diff, pre\u212d\u2081, mem_setOf, hp.1.1, true_and, not_le] at hp\n  constructor\n  \u00b7 convert hp.1; ext; simp\n  \u00b7 convert hp.2; ext; simp\n\n/-- The subset `\ud835\udd0f\u2080(k, n)` of `\u212d(k, n)`, given in (5.1.10).\nNot to be confused with `\ud835\udd0f\u2080(k, n, j)` which is called `\ud835\udd0f\u2080'` in Lean. -/\ndef \ud835\udd0f\u2080 (k n : \u2115) : Set (\ud835\udd13 X) :=\n  { p \u2208 \u212d k n | \ud835\udd05 k n p = \u2205 }\n\n/-- `\ud835\udd0f\u2081(k, n, j, l)` consists of the minimal elements in `\u212d\u2081(k, n, j)` not in\n  `\ud835\udd0f\u2081(k, n, j, l')` for some `l' < l`. Defined near (5.1.11). -/\ndef \ud835\udd0f\u2081 (k n j l : \u2115) : Set (\ud835\udd13 X) :=\n  (\u212d\u2081 k n j).minLayer l\n\n/-- The subset `\u212d\u2082(k, n, j)` of `\u212d\u2081(k, n, j)`, given in (5.1.13). -/\ndef \u212d\u2082 (k n j : \u2115) : Set (\ud835\udd13 X) :=\n  (\u212d\u2081 k n j).layersAbove (Z * (n + 1))\n\nlemma \u212d\u2082_subset_\u212d\u2081 {k n j : \u2115} : \u212d\u2082 k n j \u2286 \u212d\u2081 (X := X) k n j := layersAbove_subset\n\n/-- The subset `\ud835\udd18\u2081(k, n, j)` of `\u212d\u2081(k, n, j)`, given in (5.1.14). -/\ndef \ud835\udd18\u2081 (k n j : \u2115) : Set (\ud835\udd13 X) :=\n  { u \u2208 \u212d\u2081 k n j | \u2200 p \u2208 \u212d\u2081 k n j, \ud835\udcd8 u < \ud835\udcd8 p \u2192 Disjoint (ball_(u) (\ud835\udcac u) 100) (ball_(p) (\ud835\udcac p) 100) }\n\nlemma \ud835\udd18\u2081_subset_\u212d\u2081 {k n j : \u2115} : \ud835\udd18\u2081 k n j \u2286 \u212d\u2081 (X := X) k n j := fun _ mu \u21a6 mu.1\n\n/-- The subset `\ud835\udd0f\u2082(k, n, j)` of `\u212d\u2082(k, n, j)`, given in (5.1.15). -/\ndef \ud835\udd0f\u2082 (k n j : \u2115) : Set (\ud835\udd13 X) :=\n  { p \u2208 \u212d\u2082 k n j | \u00ac \u2203 u \u2208 \ud835\udd18\u2081 k n j, \ud835\udcd8 p \u2260 \ud835\udcd8 u \u2227 smul 2 p \u2264 smul 1 u }\n\nlemma \ud835\udd0f\u2082_subset_\u212d\u2082 {k n j : \u2115} : \ud835\udd0f\u2082 k n j \u2286 \u212d\u2082 (X := X) k n j := fun _ mu \u21a6 mu.1\n\n/-- The subset `\u212d\u2083(k, n, j)` of `\u212d\u2082(k, n, j)`, given in (5.1.16). -/\ndef \u212d\u2083 (k n j : \u2115) : Set (\ud835\udd13 X) :=\n  \u212d\u2082 k n j \\ \ud835\udd0f\u2082 k n j\n\nlemma \u212d\u2083_def {k n j : \u2115} {p : \ud835\udd13 X} :\n    p \u2208 \u212d\u2083 k n j \u2194 p \u2208 \u212d\u2082 k n j \u2227 \u2203 u \u2208 \ud835\udd18\u2081 k n j, \ud835\udcd8 p \u2260 \ud835\udcd8 u \u2227 smul 2 p \u2264 smul 1 u := by\n  rw [\u212d\u2083, mem_diff, \ud835\udd0f\u2082, mem_setOf, not_and, and_congr_right_iff]; intro h\n  simp_rw [h, true_implies, not_not]\n\nlemma \u212d\u2083_subset_\u212d\u2082 {k n j : \u2115} : \u212d\u2083 k n j \u2286 \u212d\u2082 (X := X) k n j := fun t mt \u21a6 by\n  rw [\u212d\u2083, mem_diff] at mt; exact mt.1\n\n/-- `\ud835\udd0f\u2083(k, n, j, l)` consists of the maximal elements in `\u212d\u2083(k, n, j)` not in\n  `\ud835\udd0f\u2083(k, n, j, l')` for some `l' < l`. Defined near (5.1.17). -/\ndef \ud835\udd0f\u2083 (k n j l : \u2115) : Set (\ud835\udd13 X) :=\n (\u212d\u2083 k n j).maxLayer l\n\n/-- The subset `\u212d\u2084(k, n, j)` of `\u212d\u2083(k, n, j)`, given in (5.1.19). -/\ndef \u212d\u2084 (k n j : \u2115) : Set (\ud835\udd13 X) :=\n  (\u212d\u2083 k n j).layersBelow (Z * (n + 1))\n\nlemma \u212d\u2084_subset_\u212d\u2083 {k n j : \u2115} : \u212d\u2084 k n j \u2286 \u212d\u2083 (X := X) k n j := layersBelow_subset\n\n/-- The subset `\ud835\udcdb(u)` of `Grid X`, given near (5.1.20).\nNote: It seems to also depend on `n`. -/\ndef \ud835\udcdb (n : \u2115) (u : \ud835\udd13 X) : Set (Grid X) :=\n  { i : Grid X | i \u2264 \ud835\udcd8 u \u2227 s i + (Z * (n + 1) : \u2115) + 1 = \ud835\udd30 u \u2227 \u00ac ball (c i) (8 * D ^ s i) \u2286 \ud835\udcd8 u }\n\n/-- The subset `\ud835\udd0f\u2084(k, n, j)` of `\u212d\u2084(k, n, j)`, given near (5.1.22).\nTodo: we may need to change the definition to say that `p`\nis at most the least upper bound of `\ud835\udcdb n u` in `Grid X`. -/\ndef \ud835\udd0f\u2084 (k n j : \u2115) : Set (\ud835\udd13 X) :=\n  { p \u2208 \u212d\u2084 k n j | \u2203 u \u2208 \ud835\udd18\u2081 k n j, (\ud835\udcd8 p : Set X) \u2286 \u22c3 (i \u2208 \ud835\udcdb (X := X) n u), i }\n\nlemma \ud835\udd0f\u2084_subset_\u212d\u2084 {k n j : \u2115} : \ud835\udd0f\u2084 k n j \u2286 \u212d\u2084 (X := X) k n j := fun _ mu \u21a6 mu.1\n\n/-- The subset `\u212d\u2085(k, n, j)` of `\u212d\u2084(k, n, j)`, given in (5.1.23). -/\ndef \u212d\u2085 (k n j : \u2115) : Set (\ud835\udd13 X) :=\n  \u212d\u2084 k n j \\ \ud835\udd0f\u2084 k n j\n\nlemma \u212d\u2085_def {k n j : \u2115} {p : \ud835\udd13 X} :\n    p \u2208 \u212d\u2085 k n j \u2194 p \u2208 \u212d\u2084 k n j \u2227 \u2200 u \u2208 \ud835\udd18\u2081 k n j, \u00ac(\ud835\udcd8 p : Set X) \u2286 \u22c3 (i \u2208 \ud835\udcdb (X := X) n u), i := by\n  rw [\u212d\u2085, mem_diff, \ud835\udd0f\u2084, mem_setOf, not_and, and_congr_right_iff]; intro h\n  simp_rw [h, true_implies]; push_neg; rfl\n\nlemma \u212d\u2085_subset_\u212d\u2084 {k n j : \u2115} : \u212d\u2085 k n j \u2286 \u212d\u2084 (X := X) k n j := fun t mt \u21a6 by\n  rw [\u212d\u2085, mem_diff] at mt; exact mt.1\n\nlemma \u212d\u2085_subset_\u212d\u2081 {k n j : \u2115} : \u212d\u2085 k n j \u2286 \u212d\u2081 (X := X) k n j :=\n  \u212d\u2085_subset_\u212d\u2084.trans <| \u212d\u2084_subset_\u212d\u2083.trans <| \u212d\u2083_subset_\u212d\u2082.trans \u212d\u2082_subset_\u212d\u2081\n\n", "theoremStatement": "lemma pairwiseDisjoint_\u212d\u2085 :\n    (univ : Set (\u2115 \u00d7 \u2115 \u00d7 \u2115)).PairwiseDisjoint (fun knj \u21a6 \u212d\u2085 (X := X) knj.1 knj.2.1 knj.2.2) ", "theoremName": "pairwiseDisjoint_\u212d\u2085", "fileCreated": {"commit": "59dcd932bc2be479437177e0c3ee897b9c8cba1e", "date": "2024-08-14"}, "theoremCreated": {"commit": "88d85ba29f717ee3bb9fbd37379a6fb77b57265f", "date": "2025-01-06"}, "file": "carleson/Carleson/Discrete/Defs.lean", "module": "Carleson.Discrete.Defs", "jsonFile": "Carleson.Discrete.Defs.jsonl", "positionMetadata": {"lineInFile": 238, "tokenPositionInFile": 10404, "theoremPositionInFile": 49}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 18, "numPremises": 48}, "proofMetadata": {"hasProof": true, "proof": ":=\n  pairwiseDisjoint_\u212d\u2081'.mono (fun _ \u21a6 \u212d\u2085_subset_\u212d\u2081)", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 53}}
{"srcContext": "import Mathlib.MeasureTheory.Integral.MeanInequalities\nimport Mathlib.MeasureTheory.Integral.Layercake\nimport Mathlib.MeasureTheory.Integral.Lebesgue\nimport Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar\nimport Mathlib.Analysis.SpecialFunctions.Pow.Integral\nimport Carleson.ToMathlib.ENorm\nimport Carleson.ToMathlib.Misc\n\nnoncomputable section\n\nopen NNReal ENNReal NormedSpace MeasureTheory Set Filter Topology Function\n\nsection move\n\n\nvariable {\u03b1 \ud835\udd5c E : Type*} {m : MeasurableSpace \u03b1}\n  {\u03bc : Measure \u03b1} [NontriviallyNormedField \ud835\udd5c]\n  [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]\n  {p : \u211d\u22650\u221e}\n\n-- todo: move/rename/and perhaps reformulate in terms of \u2016.\u2016\u2091\nlemma ENNNorm_absolute_homogeneous {c : \ud835\udd5c} (z : E) : ofNNReal \u2016c \u2022 z\u2016\u208a = \u2191\u2016c\u2016\u208a * \u2191\u2016z\u2016\u208a :=\n  (toReal_eq_toReal_iff' coe_ne_top coe_ne_top).mp (norm_smul c z)\n\nlemma ENNNorm_add_le (y z : E) : ofNNReal \u2016y + z\u2016\u208a \u2264 \u2191\u2016y\u2016\u208a + \u2191\u2016z\u2016\u208a :=\n  (toReal_le_toReal coe_ne_top coe_ne_top).mp (nnnorm_add_le ..)\n\nlemma measure_mono_ae' {A B : Set \u03b1} (h : \u03bc (B \\ A) = 0) :\n    \u03bc B \u2264 \u03bc A := by\n  apply measure_mono_ae\n  change \u03bc {x | \u00ac B x \u2264 A x} = 0\n  simp only [le_Prop_eq, Classical.not_imp]\n  exact h\n\n\n", "theoremStatement": "lemma eLpNormEssSup_toReal_le {f : \u03b1 \u2192 \u211d\u22650\u221e} :\n    eLpNormEssSup (ENNReal.toReal \u2218 f) \u03bc \u2264 eLpNormEssSup f \u03bc ", "theoremName": "eLpNormEssSup_toReal_le", "fileCreated": {"commit": "1a36cbeaee9466fb56c9aca49ef373f9f9cc7ab7", "date": "2025-01-23"}, "theoremCreated": {"commit": "b069d5bb71885f498386762866228ac78bf5409e", "date": "2025-01-13"}, "file": "carleson/Carleson/ToMathlib/WeakType.lean", "module": "Carleson.ToMathlib.WeakType", "jsonFile": "Carleson.ToMathlib.WeakType.jsonl", "positionMetadata": {"lineInFile": 36, "tokenPositionInFile": 1135, "theoremPositionInFile": 3}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 3, "numPremises": 46}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp_rw [eLpNormEssSup, enorm_eq_self]\n  apply essSup_mono_ae\n  apply Eventually.of_forall\n  simp [implies_true]", "proofType": "tactic", "proofLengthLines": 4, "proofLengthTokens": 120}}
{"srcContext": "/-\nCopyright (c) 2024 James Sundstrom. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: James Sundstrom\n-/\nimport Mathlib.MeasureTheory.Constructions.BorelSpace.Metric\n\n/-!\n# Annulus\n\nIn this file we define an annulus in a pseudometric space `X` to be a set consisting of all `y`\nsuch that `dist x y` lies in an interval between `r` and `R`. An annulus is defined for each type\nof interval (`Ioo`, `Ioc`, etc.) with a parallel naming scheme, except that we do not define annuli\nfor `Iio` and `Ico`, as they would be balls.\n\nWe also define `EAnnulus` similarly using `edist` instead of `dist`.\n\n## Tags\n\nannulus, eannulus\n-/\n\nopen Set Metric ENNReal\n\nvariable {X : Type*} [PseudoMetricSpace X]\n\nnamespace Set\n\nnamespace Annulus\n\ndef oo (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d) := {y | dist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d) := {y | dist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d) := {y | dist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d) := {y | dist x y \u2208 Ici r}\n\nlemma oo_eq {x : X} {r R : \u211d} : oo x r R = ball x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oo, dist_comm, and_comm]\n\nlemma oc_eq {x : X} {r R : \u211d} : oc x r R = closedBall x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oc, dist_comm, and_comm]\n\nlemma co_eq {x : X} {r R : \u211d} : co x r R = ball x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [co, dist_comm, and_comm]\n\nlemma cc_eq {x : X} {r R : \u211d} : cc x r R = closedBall x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [cc, dist_comm, and_comm]\n\nlemma oi_eq {x : X} {r : \u211d} : oi x r = (closedBall x r)\u1d9c := by\n  ext; simp [oi, dist_comm]\n\nlemma ci_eq {x : X} {r : \u211d} : ci x r = (ball x r)\u1d9c := by\n  ext; simp [ci, dist_comm]\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : co x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma co_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : co x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\nlemma cc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : cc x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma cc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : cc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\n@[simp]\nlemma oc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    oc x r r' \u222a oo x r' R = oo x r R := by\n  ext; simp_rw [oc, oo, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioo_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    oc x r r' \u222a oc x r' R = oc x r R := by\n  ext; simp_rw [oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_co {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a co x r' R = oo x r R := by\n  ext; simp_rw [oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ico_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a cc x r' R = oc x r R := by\n  ext; simp_rw [oo, cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Icc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    cc x r r' \u222a oo x r' R = co x r R := by\n  ext; simp_rw [cc, oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioo_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    cc x r r' \u222a oc x r' R = cc x r R := by\n  ext; simp_rw [cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_co {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a co x r' R = co x r R := by\n  ext; simp_rw [co, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ico_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a cc x r' R = cc x r R := by\n  ext; simp_rw [co, cc, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Icc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : oc x r R \u222a oi x R = oi x r := by\n  ext; simp_rw [oc, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioi_eq_Ioi h]\n\n@[simp]\nlemma oo_union_ci {x : X} {r R : \u211d} (h : r < R) :\n    oo x r R \u222a ci x R = oi x r := by\n  ext; simp_rw [oo, ci, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ici_eq_Ioi h]\n\n@[simp]\nlemma cc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : cc x r R \u222a oi x R = ci x r := by\n  ext; simp_rw [cc, oi, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioi_eq_Ici h]\n\n@[simp]\nlemma co_union_ci {x : X} {r R : \u211d} (h : r \u2264 R) : co x r R \u222a ci x R = ci x r := by\n  ext; simp_rw [co, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ici_eq_Ici h]\n\n\nvariable [MeasurableSpace X] [OpensMeasurableSpace X]\n\n@[measurability]\nlemma measurableSet_oo {x : X} {r R : \u211d} : MeasurableSet (oo x r R) := by\n  rw [oo_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oc {x : X} {r R : \u211d} : MeasurableSet (oc x r R) := by\n rw [oc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_co {x : X} {r R : \u211d} : MeasurableSet (co x r R) := by\n  rw [co_eq]; measurability\n\n@[measurability]\nlemma measurableSet_cc {x : X} {r R : \u211d} : MeasurableSet (cc x r R) := by\n rw [cc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oi {x : X} {r : \u211d} : MeasurableSet (oi x r) := by\n  rw [oi_eq]; measurability\n\n@[measurability]\nlemma measurableSet_ci {x : X} {r : \u211d} : MeasurableSet (ci x r) := by\n  rw [ci_eq]; measurability\n\nend Annulus\n\nnamespace EAnnulus\n\ndef oo (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ici r}\n\n\nlemma oo_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oo x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oo x r R := by\n  simp_rw [oo, Annulus.oo, edist_dist, mem_Ioo, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma oc_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [oc, Annulus.oc, edist_dist, mem_Ioc, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  \u00b7 have R_le_r := (lt_of_lt_of_le (lt_of_not_ge hR) hr).le\n    rw [Annulus.oc_eq_empty R_le_r]\n    refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n    exact not_le_of_gt (lt_of_le_of_lt (ENNReal.ofReal_le_ofReal R_le_r) hy.1) hy.2\n\nlemma co_eq_annulus {x : X} {r R : \u211d} :\n    co x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.co x r R := by\n  simp_rw [co, Annulus.co, edist_dist, mem_Ico, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma cc_eq_annulus {x : X} {r R : \u211d} (h : r > 0 \u2228 R \u2265 0) :\n    cc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.cc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [cc, Annulus.cc, edist_dist, mem_Icc, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  have r0 := h.resolve_right hR\n  have R_lt_r := (lt_of_not_ge hR).trans r0\n  rw [Annulus.cc_eq_empty R_lt_r]\n  refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n  exact not_le_of_gt ((ENNReal.ofReal_lt_ofReal_iff r0).mpr R_lt_r) (hy.1.trans hy.2)\n\nlemma oi_eq_annulus {x : X} {r : \u211d} (hr : r \u2265 0) : oi x (ENNReal.ofReal r) = Annulus.oi x r := by\n  simp_rw [oi, Annulus.oi, edist_dist, mem_Ioi, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr]\n\nlemma ci_eq_annulus {x : X} {r : \u211d} : ci x (ENNReal.ofReal r) = Annulus.ci x r := by\n  simp_rw [ci, Annulus.ci, edist_dist, mem_Ici, ENNReal.ofReal_le_ofReal_iff dist_nonneg]\n\n\nlemma oo_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oo x r R = ball x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oo, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma oc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oc x r R = closedBall x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oc, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma co_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    co x r R = ball x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [co, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma cc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    cc x r R = closedBall x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [cc, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma oi_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : oi x r = (closedBall x r.toReal)\u1d9c := by\n  ext; simp [oi, edist_dist, dist_comm, lt_ofReal_iff_toReal_lt hr.ne]\n\nlemma ci_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : ci x r = (ball x r.toReal)\u1d9c := by\n  ext; simp [ci, edist_dist, dist_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg]\n\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n@[simp]\nlemma cc_top_eq_empty {x : X} {R : \u211d\u22650\u221e} : cc x \u22a4 R = \u2205 :=\n  eq_empty_of_forall_not_mem (fun y hy \u21a6 (edist_ne_top x y) (top_le_iff.mp hy.1))\n\n@[simp]\nlemma oi_eq_empty {x : X} : oi x \u22a4 = \u2205 := by simp [oi, edist_dist]\n\n@[simp]\nlemma ci_eq_empty {x : X} : ci x \u22a4 = \u2205 := by simp [ci, edist_dist]\n\n\nlemma oo_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) :\n    oo x r \u22a4 = (closedBall x r.toReal)\u1d9c := by\n  ext; simpa [oo, edist_dist, dist_comm] using lt_ofReal_iff_toReal_lt hr.ne\n\nlemma oc_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) :\n    oc x r \u22a4 = (closedBall x r.toReal)\u1d9c := by\n  ext; simpa [oc, edist_dist, dist_comm] using lt_ofReal_iff_toReal_lt hr.ne\n\nlemma co_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : co x r \u22a4 = (ball x r.toReal)\u1d9c := by\n  ext; simpa [co, edist_dist, dist_comm] using le_ofReal_iff_toReal_le hr.ne dist_nonneg\n\nlemma cc_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : cc x r \u22a4 = (ball x r.toReal)\u1d9c := by\n  ext; simpa [cc, edist_dist, dist_comm] using le_ofReal_iff_toReal_le hr.ne dist_nonneg\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\n", "theoremStatement": "lemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 ", "theoremName": "Set.EAnnulus.oo_subset_cc", "fileCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "theoremCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "file": "carleson/Carleson/ToMathlib/Annulus.lean", "module": "Carleson.ToMathlib.Annulus", "jsonFile": "Carleson.ToMathlib.Annulus.jsonl", "positionMetadata": {"lineInFile": 380, "tokenPositionInFile": 14777, "theoremPositionInFile": 90}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 26}, "proofMetadata": {"hasProof": true, "proof": ":=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 58}}
{"srcContext": "/-\nCopyright (c) 2024 James Sundstrom. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: James Sundstrom\n-/\nimport Mathlib.MeasureTheory.Constructions.BorelSpace.Metric\n\n/-!\n# Annulus\n\nIn this file we define an annulus in a pseudometric space `X` to be a set consisting of all `y`\nsuch that `dist x y` lies in an interval between `r` and `R`. An annulus is defined for each type\nof interval (`Ioo`, `Ioc`, etc.) with a parallel naming scheme, except that we do not define annuli\nfor `Iio` and `Ico`, as they would be balls.\n\nWe also define `EAnnulus` similarly using `edist` instead of `dist`.\n\n## Tags\n\nannulus, eannulus\n-/\n\nopen Set Metric ENNReal\n\nvariable {X : Type*} [PseudoMetricSpace X]\n\nnamespace Set\n\nnamespace Annulus\n\ndef oo (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d) := {y | dist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d) := {y | dist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d) := {y | dist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d) := {y | dist x y \u2208 Ici r}\n\nlemma oo_eq {x : X} {r R : \u211d} : oo x r R = ball x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oo, dist_comm, and_comm]\n\nlemma oc_eq {x : X} {r R : \u211d} : oc x r R = closedBall x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oc, dist_comm, and_comm]\n\nlemma co_eq {x : X} {r R : \u211d} : co x r R = ball x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [co, dist_comm, and_comm]\n\nlemma cc_eq {x : X} {r R : \u211d} : cc x r R = closedBall x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [cc, dist_comm, and_comm]\n\nlemma oi_eq {x : X} {r : \u211d} : oi x r = (closedBall x r)\u1d9c := by\n  ext; simp [oi, dist_comm]\n\nlemma ci_eq {x : X} {r : \u211d} : ci x r = (ball x r)\u1d9c := by\n  ext; simp [ci, dist_comm]\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : co x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma co_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : co x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\nlemma cc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : cc x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma cc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : cc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\n@[simp]\nlemma oc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    oc x r r' \u222a oo x r' R = oo x r R := by\n  ext; simp_rw [oc, oo, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioo_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    oc x r r' \u222a oc x r' R = oc x r R := by\n  ext; simp_rw [oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_co {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a co x r' R = oo x r R := by\n  ext; simp_rw [oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ico_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a cc x r' R = oc x r R := by\n  ext; simp_rw [oo, cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Icc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    cc x r r' \u222a oo x r' R = co x r R := by\n  ext; simp_rw [cc, oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioo_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    cc x r r' \u222a oc x r' R = cc x r R := by\n  ext; simp_rw [cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_co {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a co x r' R = co x r R := by\n  ext; simp_rw [co, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ico_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a cc x r' R = cc x r R := by\n  ext; simp_rw [co, cc, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Icc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : oc x r R \u222a oi x R = oi x r := by\n  ext; simp_rw [oc, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioi_eq_Ioi h]\n\n@[simp]\nlemma oo_union_ci {x : X} {r R : \u211d} (h : r < R) :\n    oo x r R \u222a ci x R = oi x r := by\n  ext; simp_rw [oo, ci, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ici_eq_Ioi h]\n\n@[simp]\nlemma cc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : cc x r R \u222a oi x R = ci x r := by\n  ext; simp_rw [cc, oi, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioi_eq_Ici h]\n\n@[simp]\nlemma co_union_ci {x : X} {r R : \u211d} (h : r \u2264 R) : co x r R \u222a ci x R = ci x r := by\n  ext; simp_rw [co, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ici_eq_Ici h]\n\n\nvariable [MeasurableSpace X] [OpensMeasurableSpace X]\n\n@[measurability]\nlemma measurableSet_oo {x : X} {r R : \u211d} : MeasurableSet (oo x r R) := by\n  rw [oo_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oc {x : X} {r R : \u211d} : MeasurableSet (oc x r R) := by\n rw [oc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_co {x : X} {r R : \u211d} : MeasurableSet (co x r R) := by\n  rw [co_eq]; measurability\n\n@[measurability]\nlemma measurableSet_cc {x : X} {r R : \u211d} : MeasurableSet (cc x r R) := by\n rw [cc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oi {x : X} {r : \u211d} : MeasurableSet (oi x r) := by\n  rw [oi_eq]; measurability\n\n@[measurability]\nlemma measurableSet_ci {x : X} {r : \u211d} : MeasurableSet (ci x r) := by\n  rw [ci_eq]; measurability\n\nend Annulus\n\nnamespace EAnnulus\n\ndef oo (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ici r}\n\n\nlemma oo_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oo x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oo x r R := by\n  simp_rw [oo, Annulus.oo, edist_dist, mem_Ioo, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma oc_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [oc, Annulus.oc, edist_dist, mem_Ioc, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  \u00b7 have R_le_r := (lt_of_lt_of_le (lt_of_not_ge hR) hr).le\n    rw [Annulus.oc_eq_empty R_le_r]\n    refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n    exact not_le_of_gt (lt_of_le_of_lt (ENNReal.ofReal_le_ofReal R_le_r) hy.1) hy.2\n\nlemma co_eq_annulus {x : X} {r R : \u211d} :\n    co x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.co x r R := by\n  simp_rw [co, Annulus.co, edist_dist, mem_Ico, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma cc_eq_annulus {x : X} {r R : \u211d} (h : r > 0 \u2228 R \u2265 0) :\n    cc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.cc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [cc, Annulus.cc, edist_dist, mem_Icc, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  have r0 := h.resolve_right hR\n  have R_lt_r := (lt_of_not_ge hR).trans r0\n  rw [Annulus.cc_eq_empty R_lt_r]\n  refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n  exact not_le_of_gt ((ENNReal.ofReal_lt_ofReal_iff r0).mpr R_lt_r) (hy.1.trans hy.2)\n\nlemma oi_eq_annulus {x : X} {r : \u211d} (hr : r \u2265 0) : oi x (ENNReal.ofReal r) = Annulus.oi x r := by\n  simp_rw [oi, Annulus.oi, edist_dist, mem_Ioi, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr]\n\nlemma ci_eq_annulus {x : X} {r : \u211d} : ci x (ENNReal.ofReal r) = Annulus.ci x r := by\n  simp_rw [ci, Annulus.ci, edist_dist, mem_Ici, ENNReal.ofReal_le_ofReal_iff dist_nonneg]\n\n\nlemma oo_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oo x r R = ball x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oo, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma oc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oc x r R = closedBall x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oc, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma co_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    co x r R = ball x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [co, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma cc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    cc x r R = closedBall x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [cc, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma oi_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : oi x r = (closedBall x r.toReal)\u1d9c := by\n  ext; simp [oi, edist_dist, dist_comm, lt_ofReal_iff_toReal_lt hr.ne]\n\nlemma ci_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : ci x r = (ball x r.toReal)\u1d9c := by\n  ext; simp [ci, edist_dist, dist_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg]\n\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n@[simp]\nlemma cc_top_eq_empty {x : X} {R : \u211d\u22650\u221e} : cc x \u22a4 R = \u2205 :=\n  eq_empty_of_forall_not_mem (fun y hy \u21a6 (edist_ne_top x y) (top_le_iff.mp hy.1))\n\n@[simp]\nlemma oi_eq_empty {x : X} : oi x \u22a4 = \u2205 := by simp [oi, edist_dist]\n\n@[simp]\nlemma ci_eq_empty {x : X} : ci x \u22a4 = \u2205 := by simp [ci, edist_dist]\n\n\nlemma oo_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) :\n    oo x r \u22a4 = (closedBall x r.toReal)\u1d9c := by\n  ext; simpa [oo, edist_dist, dist_comm] using lt_ofReal_iff_toReal_lt hr.ne\n\nlemma oc_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) :\n    oc x r \u22a4 = (closedBall x r.toReal)\u1d9c := by\n  ext; simpa [oc, edist_dist, dist_comm] using lt_ofReal_iff_toReal_lt hr.ne\n\nlemma co_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : co x r \u22a4 = (ball x r.toReal)\u1d9c := by\n  ext; simpa [co, edist_dist, dist_comm] using le_ofReal_iff_toReal_le hr.ne dist_nonneg\n\nlemma cc_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : cc x r \u22a4 = (ball x r.toReal)\u1d9c := by\n  ext; simpa [cc, edist_dist, dist_comm] using le_ofReal_iff_toReal_le hr.ne dist_nonneg\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) : co x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma co_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : co x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\nlemma cc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) : cc x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma cc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : cc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\n@[simp]\nlemma oc_union_oo {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    oc x r r' \u222a oo x r' R = oo x r R := by\n  ext; simp_rw [oc, oo, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioo_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oc {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    oc x r r' \u222a oc x r' R = oc x r R := by\n  ext; simp_rw [oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_co {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a co x r' R = oo x r R := by\n  ext; simp_rw [oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ico_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_cc {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a cc x r' R = oc x r R := by\n  ext; simp_rw [oo, cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Icc_eq_Ioc h\u2081 h\u2082]\n\n", "theoremStatement": "@[simp]\nlemma cc_union_oo {x : X} {r r' R : \u211d\u22650\u221e} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    cc x r r' \u222a oo x r' R = co x r R ", "theoremName": "Set.EAnnulus.cc_union_oo", "fileCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "theoremCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "file": "carleson/Carleson/ToMathlib/Annulus.lean", "module": "Carleson.ToMathlib.Annulus", "jsonFile": "Carleson.ToMathlib.Annulus.jsonl", "positionMetadata": {"lineInFile": 476, "tokenPositionInFile": 18870, "theoremPositionInFile": 115}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 3, "numPremises": 49}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  ext; simp_rw [cc, oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioo_eq_Ico h\u2081 h\u2082]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 99}}
{"srcContext": "/-\nCopyright (c) 2024 James Sundstrom. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: James Sundstrom\n-/\nimport Mathlib.MeasureTheory.Constructions.BorelSpace.Metric\n\n/-!\n# Annulus\n\nIn this file we define an annulus in a pseudometric space `X` to be a set consisting of all `y`\nsuch that `dist x y` lies in an interval between `r` and `R`. An annulus is defined for each type\nof interval (`Ioo`, `Ioc`, etc.) with a parallel naming scheme, except that we do not define annuli\nfor `Iio` and `Ico`, as they would be balls.\n\nWe also define `EAnnulus` similarly using `edist` instead of `dist`.\n\n## Tags\n\nannulus, eannulus\n-/\n\nopen Set Metric ENNReal\n\nvariable {X : Type*} [PseudoMetricSpace X]\n\nnamespace Set\n\nnamespace Annulus\n\ndef oo (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d) := {y | dist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d) := {y | dist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d) := {y | dist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d) := {y | dist x y \u2208 Ici r}\n\nlemma oo_eq {x : X} {r R : \u211d} : oo x r R = ball x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oo, dist_comm, and_comm]\n\nlemma oc_eq {x : X} {r R : \u211d} : oc x r R = closedBall x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oc, dist_comm, and_comm]\n\nlemma co_eq {x : X} {r R : \u211d} : co x r R = ball x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [co, dist_comm, and_comm]\n\nlemma cc_eq {x : X} {r R : \u211d} : cc x r R = closedBall x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [cc, dist_comm, and_comm]\n\nlemma oi_eq {x : X} {r : \u211d} : oi x r = (closedBall x r)\u1d9c := by\n  ext; simp [oi, dist_comm]\n\nlemma ci_eq {x : X} {r : \u211d} : ci x r = (ball x r)\u1d9c := by\n  ext; simp [ci, dist_comm]\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : co x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma co_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : co x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\nlemma cc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : cc x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma cc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : cc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\n@[simp]\nlemma oc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    oc x r r' \u222a oo x r' R = oo x r R := by\n  ext; simp_rw [oc, oo, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioo_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    oc x r r' \u222a oc x r' R = oc x r R := by\n  ext; simp_rw [oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_co {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a co x r' R = oo x r R := by\n  ext; simp_rw [oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ico_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a cc x r' R = oc x r R := by\n  ext; simp_rw [oo, cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Icc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    cc x r r' \u222a oo x r' R = co x r R := by\n  ext; simp_rw [cc, oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioo_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    cc x r r' \u222a oc x r' R = cc x r R := by\n  ext; simp_rw [cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_co {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a co x r' R = co x r R := by\n  ext; simp_rw [co, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ico_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a cc x r' R = cc x r R := by\n  ext; simp_rw [co, cc, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Icc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : oc x r R \u222a oi x R = oi x r := by\n  ext; simp_rw [oc, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioi_eq_Ioi h]\n\n@[simp]\nlemma oo_union_ci {x : X} {r R : \u211d} (h : r < R) :\n    oo x r R \u222a ci x R = oi x r := by\n  ext; simp_rw [oo, ci, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ici_eq_Ioi h]\n\n@[simp]\nlemma cc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : cc x r R \u222a oi x R = ci x r := by\n  ext; simp_rw [cc, oi, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioi_eq_Ici h]\n\n@[simp]\nlemma co_union_ci {x : X} {r R : \u211d} (h : r \u2264 R) : co x r R \u222a ci x R = ci x r := by\n  ext; simp_rw [co, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ici_eq_Ici h]\n\n\nvariable [MeasurableSpace X] [OpensMeasurableSpace X]\n\n@[measurability]\nlemma measurableSet_oo {x : X} {r R : \u211d} : MeasurableSet (oo x r R) := by\n  rw [oo_eq]; measurability\n\n", "theoremStatement": "@[measurability]\nlemma measurableSet_oc {x : X} {r R : \u211d} : MeasurableSet (oc x r R) ", "theoremName": "Set.Annulus.measurableSet_oc", "fileCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "theoremCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "file": "carleson/Carleson/ToMathlib/Annulus.lean", "module": "Carleson.ToMathlib.Annulus", "jsonFile": "Carleson.ToMathlib.Annulus.jsonl", "positionMetadata": {"lineInFile": 225, "tokenPositionInFile": 8464, "theoremPositionInFile": 53}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 23}, "proofMetadata": {"hasProof": true, "proof": ":= by\n rw [oc_eq]; measurability", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 32}}
{"srcContext": "/-\nCopyright (c) 2024 James Sundstrom. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: James Sundstrom\n-/\nimport Mathlib.MeasureTheory.Constructions.BorelSpace.Metric\n\n/-!\n# Annulus\n\nIn this file we define an annulus in a pseudometric space `X` to be a set consisting of all `y`\nsuch that `dist x y` lies in an interval between `r` and `R`. An annulus is defined for each type\nof interval (`Ioo`, `Ioc`, etc.) with a parallel naming scheme, except that we do not define annuli\nfor `Iio` and `Ico`, as they would be balls.\n\nWe also define `EAnnulus` similarly using `edist` instead of `dist`.\n\n## Tags\n\nannulus, eannulus\n-/\n\nopen Set Metric ENNReal\n\nvariable {X : Type*} [PseudoMetricSpace X]\n\nnamespace Set\n\nnamespace Annulus\n\ndef oo (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d) := {y | dist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d) := {y | dist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d) := {y | dist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d) := {y | dist x y \u2208 Ici r}\n\nlemma oo_eq {x : X} {r R : \u211d} : oo x r R = ball x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oo, dist_comm, and_comm]\n\nlemma oc_eq {x : X} {r R : \u211d} : oc x r R = closedBall x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oc, dist_comm, and_comm]\n\nlemma co_eq {x : X} {r R : \u211d} : co x r R = ball x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [co, dist_comm, and_comm]\n\nlemma cc_eq {x : X} {r R : \u211d} : cc x r R = closedBall x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [cc, dist_comm, and_comm]\n\nlemma oi_eq {x : X} {r : \u211d} : oi x r = (closedBall x r)\u1d9c := by\n  ext; simp [oi, dist_comm]\n\nlemma ci_eq {x : X} {r : \u211d} : ci x r = (ball x r)\u1d9c := by\n  ext; simp [ci, dist_comm]\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : co x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma co_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : co x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\nlemma cc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : cc x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma cc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : cc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\n@[simp]\nlemma oc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    oc x r r' \u222a oo x r' R = oo x r R := by\n  ext; simp_rw [oc, oo, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioo_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    oc x r r' \u222a oc x r' R = oc x r R := by\n  ext; simp_rw [oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_co {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a co x r' R = oo x r R := by\n  ext; simp_rw [oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ico_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a cc x r' R = oc x r R := by\n  ext; simp_rw [oo, cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Icc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    cc x r r' \u222a oo x r' R = co x r R := by\n  ext; simp_rw [cc, oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioo_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    cc x r r' \u222a oc x r' R = cc x r R := by\n  ext; simp_rw [cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_co {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a co x r' R = co x r R := by\n  ext; simp_rw [co, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ico_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a cc x r' R = cc x r R := by\n  ext; simp_rw [co, cc, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Icc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : oc x r R \u222a oi x R = oi x r := by\n  ext; simp_rw [oc, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioi_eq_Ioi h]\n\n@[simp]\nlemma oo_union_ci {x : X} {r R : \u211d} (h : r < R) :\n    oo x r R \u222a ci x R = oi x r := by\n  ext; simp_rw [oo, ci, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ici_eq_Ioi h]\n\n@[simp]\nlemma cc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : cc x r R \u222a oi x R = ci x r := by\n  ext; simp_rw [cc, oi, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioi_eq_Ici h]\n\n@[simp]\nlemma co_union_ci {x : X} {r R : \u211d} (h : r \u2264 R) : co x r R \u222a ci x R = ci x r := by\n  ext; simp_rw [co, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ici_eq_Ici h]\n\n\nvariable [MeasurableSpace X] [OpensMeasurableSpace X]\n\n@[measurability]\nlemma measurableSet_oo {x : X} {r R : \u211d} : MeasurableSet (oo x r R) := by\n  rw [oo_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oc {x : X} {r R : \u211d} : MeasurableSet (oc x r R) := by\n rw [oc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_co {x : X} {r R : \u211d} : MeasurableSet (co x r R) := by\n  rw [co_eq]; measurability\n\n", "theoremStatement": "@[measurability]\nlemma measurableSet_cc {x : X} {r R : \u211d} : MeasurableSet (cc x r R) ", "theoremName": "Set.Annulus.measurableSet_cc", "fileCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "theoremCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "file": "carleson/Carleson/ToMathlib/Annulus.lean", "module": "Carleson.ToMathlib.Annulus", "jsonFile": "Carleson.ToMathlib.Annulus.jsonl", "positionMetadata": {"lineInFile": 233, "tokenPositionInFile": 8703, "theoremPositionInFile": 55}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 25}, "proofMetadata": {"hasProof": true, "proof": ":= by\n rw [cc_eq]; measurability", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 32}}
{"srcContext": "/-\nCopyright (c) 2024 James Sundstrom. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: James Sundstrom\n-/\nimport Mathlib.MeasureTheory.Constructions.BorelSpace.Metric\n\n/-!\n# Annulus\n\nIn this file we define an annulus in a pseudometric space `X` to be a set consisting of all `y`\nsuch that `dist x y` lies in an interval between `r` and `R`. An annulus is defined for each type\nof interval (`Ioo`, `Ioc`, etc.) with a parallel naming scheme, except that we do not define annuli\nfor `Iio` and `Ico`, as they would be balls.\n\nWe also define `EAnnulus` similarly using `edist` instead of `dist`.\n\n## Tags\n\nannulus, eannulus\n-/\n\nopen Set Metric ENNReal\n\nvariable {X : Type*} [PseudoMetricSpace X]\n\nnamespace Set\n\nnamespace Annulus\n\ndef oo (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d) := {y | dist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d) := {y | dist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d) := {y | dist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d) := {y | dist x y \u2208 Ici r}\n\nlemma oo_eq {x : X} {r R : \u211d} : oo x r R = ball x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oo, dist_comm, and_comm]\n\nlemma oc_eq {x : X} {r R : \u211d} : oc x r R = closedBall x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oc, dist_comm, and_comm]\n\nlemma co_eq {x : X} {r R : \u211d} : co x r R = ball x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [co, dist_comm, and_comm]\n\nlemma cc_eq {x : X} {r R : \u211d} : cc x r R = closedBall x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [cc, dist_comm, and_comm]\n\nlemma oi_eq {x : X} {r : \u211d} : oi x r = (closedBall x r)\u1d9c := by\n  ext; simp [oi, dist_comm]\n\nlemma ci_eq {x : X} {r : \u211d} : ci x r = (ball x r)\u1d9c := by\n  ext; simp [ci, dist_comm]\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : co x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma co_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : co x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\nlemma cc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : cc x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma cc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : cc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\n@[simp]\nlemma oc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    oc x r r' \u222a oo x r' R = oo x r R := by\n  ext; simp_rw [oc, oo, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioo_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    oc x r r' \u222a oc x r' R = oc x r R := by\n  ext; simp_rw [oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_co {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a co x r' R = oo x r R := by\n  ext; simp_rw [oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ico_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a cc x r' R = oc x r R := by\n  ext; simp_rw [oo, cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Icc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    cc x r r' \u222a oo x r' R = co x r R := by\n  ext; simp_rw [cc, oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioo_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    cc x r r' \u222a oc x r' R = cc x r R := by\n  ext; simp_rw [cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_co {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a co x r' R = co x r R := by\n  ext; simp_rw [co, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ico_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a cc x r' R = cc x r R := by\n  ext; simp_rw [co, cc, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Icc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : oc x r R \u222a oi x R = oi x r := by\n  ext; simp_rw [oc, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioi_eq_Ioi h]\n\n@[simp]\nlemma oo_union_ci {x : X} {r R : \u211d} (h : r < R) :\n    oo x r R \u222a ci x R = oi x r := by\n  ext; simp_rw [oo, ci, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ici_eq_Ioi h]\n\n@[simp]\nlemma cc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : cc x r R \u222a oi x R = ci x r := by\n  ext; simp_rw [cc, oi, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioi_eq_Ici h]\n\n@[simp]\nlemma co_union_ci {x : X} {r R : \u211d} (h : r \u2264 R) : co x r R \u222a ci x R = ci x r := by\n  ext; simp_rw [co, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ici_eq_Ici h]\n\n\nvariable [MeasurableSpace X] [OpensMeasurableSpace X]\n\n@[measurability]\nlemma measurableSet_oo {x : X} {r R : \u211d} : MeasurableSet (oo x r R) := by\n  rw [oo_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oc {x : X} {r R : \u211d} : MeasurableSet (oc x r R) := by\n rw [oc_eq]; measurability\n\n", "theoremStatement": "@[measurability]\nlemma measurableSet_co {x : X} {r R : \u211d} : MeasurableSet (co x r R) ", "theoremName": "Set.Annulus.measurableSet_co", "fileCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "theoremCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "file": "carleson/Carleson/ToMathlib/Annulus.lean", "module": "Carleson.ToMathlib.Annulus", "jsonFile": "Carleson.ToMathlib.Annulus.jsonl", "positionMetadata": {"lineInFile": 229, "tokenPositionInFile": 8583, "theoremPositionInFile": 54}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 23}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [co_eq]; measurability", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 33}}
{"srcContext": "import Mathlib.Analysis.Normed.Group.Basic\nimport Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic\nimport Mathlib.MeasureTheory.Function.StronglyMeasurable.AEStronglyMeasurable\n\nnoncomputable section\n\nopen ENNReal NNReal Function Set\n\nvariable {\u03b1 \u03b1' E E\u2081 E\u2082 F : Type*} [ENorm F]\n\n@[simp] lemma enorm_toReal_le {x : \u211d\u22650\u221e} : \u2016x.toReal\u2016\u2091 \u2264 x := by simp [\u2190 ofReal_norm, ofReal_toReal_le]\n\n@[simp] lemma enorm_toReal {x : \u211d\u22650\u221e} (hx : x \u2260 \u22a4) : \u2016x.toReal\u2016\u2091 = x := by\n  simp [hx, \u2190 ofReal_norm_eq_enorm]\n\n/-- A type `E` equipped with a continuous map `\u2016\u00b7\u2016\u2091 : E \u2192 \u211d\u22650\u221e`.\nNote: do we want to unbundle this (at least separate out `TopologicalSpace E`?)\nNote: not sure if this is the \"right\" class to add to Mathlib. -/\nclass ContinuousENorm (E : Type*) extends ENorm E, TopologicalSpace E where\n  continuous_enorm : Continuous enorm\n  -- the topology is somehow defined by the enorm.\n\n-- todo: maybe generalize to ENormedMonoid and use `to_additive` if necessary for Mathlib.\n/-- An enormed monoid is an additive monoid endowed with a continuous enorm.\nNote: not sure if this is the \"right\" class to add to Mathlib. -/\nclass ENormedAddMonoid (E : Type*) extends ContinuousENorm E, AddMonoid E where\n  enorm_eq_zero : \u2200 x : E, \u2016x\u2016\u2091 = 0 \u2194 x = 0\n  -- enorm_neg : \u2200 x y : E, x + y = 0 \u2192 \u2016x\u2016\u2091 = \u2016y\u2016\u2091 -- this is a silly way to write this\n  enorm_add_le : \u2200 x y : E, \u2016x + y\u2016\u2091 \u2264 \u2016x\u2016\u2091 + \u2016y\u2016\u2091\n\n/-- An enormed monoid is an additive monoid endowed with a continuous enorm.\nNote: not sure if this is the \"right\" class to add to Mathlib. -/\nclass ENormedAddCommMonoid (E : Type*) extends ENormedAddMonoid E, AddCommMonoid E where\n\n/-- An enormed monoid is an additive monoid endowed with a continuous enorm.\nNote: not sure if this is the \"right\" class to add to Mathlib. -/\nclass ENormedAddCommSubMonoid (E : Type*) extends ENormedAddCommMonoid E, Sub E where\n  sub_add_cancel_of_enorm_le : \u2200 \u2983x y : E\u2984, \u2016y\u2016\u2091 \u2264 \u2016x\u2016\u2091 \u2192 x - y + y = x\n  add_right_cancel_of_enorm_lt_top : \u2200 \u2983x : E\u2984, \u2016x\u2016\u2091 < \u22a4 \u2192 \u2200 {y z : E}, y + x = z + x \u2192 y = z\n  esub_self : \u2200 x : E, x - x = 0\n\n/-- An enormed space is an additive monoid endowed with a continuous enorm.\nNote: not sure if this is the \"right\" class to add to Mathlib. -/\nclass ENormedSpace (E : Type*) extends ENormedAddCommMonoid E, Module \u211d\u22650 E where\n  enorm_smul : \u2200 (c : \u211d\u22650) (x : E), \u2016c \u2022 x\u2016\u2091 = c \u2022 \u2016x\u2016\u2091\n\nexport ENormedAddMonoid (enorm_eq_zero enorm_add_le)\nexport ENormedAddCommSubMonoid\n  (sub_add_cancel_of_enorm_le add_right_cancel_of_enorm_lt_top esub_self)\nexport ENormedSpace (enorm_smul)\n\nattribute [simp] ENormedAddMonoid.enorm_eq_zero ENormedSpace.enorm_smul\n\n@[simp] lemma enorm_zero' {\u03b5} [ENormedAddMonoid \u03b5] : \u2016(0 : \u03b5)\u2016\u2091 = 0 := by simp\n\ninstance : ENormedSpace \u211d\u22650\u221e where\n  enorm := id\n  enorm_eq_zero := by simp\n  -- enorm_neg := by simp\n  enorm_add_le := by simp\n  add_comm := by simp [add_comm]\n  continuous_enorm := continuous_id\n  enorm_smul := by simp\n\ninstance [SeminormedAddGroup E] : ContinuousENorm E where\n  continuous_enorm := ENNReal.continuous_coe.comp continuous_nnnorm\n\ninstance [NormedAddGroup E] : ENormedAddMonoid E where\n  enorm_eq_zero := by simp [enorm_eq_nnnorm]\n  -- enorm_neg := by\n  --   simp (config := {contextual := true}) [\u2190 eq_neg_iff_add_eq_zero, enorm_eq_nnnorm]\n  enorm_add_le := by simp [enorm_eq_nnnorm, \u2190 ENNReal.coe_add, nnnorm_add_le]\n\ninstance [NormedAddCommGroup E] : ENormedAddCommMonoid E where\n  add_comm := by simp [add_comm]\n\ninstance [NormedAddCommGroup E] [NormedSpace \u211d E] : ENormedSpace E where\n  enorm_smul := by simp_rw [enorm_eq_nnnorm, ENNReal.smul_def, NNReal.smul_def, nnnorm_smul]; simp\n\nnamespace MeasureTheory\nsection ContinuousENorm\nvariable {\u03b1 E : Type*} {m : MeasurableSpace \u03b1} [ContinuousENorm E] {\u03bc : Measure \u03b1}\n\nexport ContinuousENorm (continuous_enorm)\n\n@[fun_prop]\nprotected theorem Continuous.enorm {X : Type*} [TopologicalSpace X] {f : X \u2192 E}\n    (hf : Continuous f) : Continuous (fun x => (\u2016f x\u2016\u2091)) :=\n  continuous_enorm.comp hf\n\n@[fun_prop]\ntheorem measurable_enorm [MeasurableSpace E] [OpensMeasurableSpace E] :\n    Measurable (fun a : E => (\u2016a\u2016\u2091)) :=\n  continuous_enorm.measurable\n\n@[fun_prop]\nprotected theorem AEMeasurable.enorm [MeasurableSpace E] [OpensMeasurableSpace E] {f : \u03b1 \u2192 E}\n    (hf : AEMeasurable f \u03bc) : AEMeasurable (fun a => (\u2016f a\u2016\u2091)) \u03bc :=\n  measurable_enorm.comp_aemeasurable hf\n\n", "theoremStatement": "@[fun_prop]\nprotected theorem AEStronglyMeasurable.enorm' {f : \u03b1 \u2192 E}\n    (hf : AEStronglyMeasurable f \u03bc) : AEMeasurable (fun a => (\u2016f a\u2016\u2091)) \u03bc ", "theoremName": "MeasureTheory.AEStronglyMeasurable.enorm'", "fileCreated": {"commit": "14c6f6b1cdd37ef5156f01fbdb655940317f7110", "date": "2024-11-07"}, "theoremCreated": {"commit": "a5d265f109105809de4aaff16776b7c16b1c0bd5", "date": "2025-02-07"}, "file": "carleson/Carleson/ToMathlib/ENorm.lean", "module": "Carleson.ToMathlib.ENorm", "jsonFile": "Carleson.ToMathlib.ENorm.jsonl", "positionMetadata": {"lineInFile": 101, "tokenPositionInFile": 4301, "theoremPositionInFile": 6}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 4, "numPremises": 17}, "proofMetadata": {"hasProof": true, "proof": ":=\n  continuous_enorm.comp_aestronglyMeasurable hf |>.aemeasurable", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 66}}
{"srcContext": "import Carleson.GridStructure\nimport Carleson.Psi\nimport Carleson.ToMathlib.BoundedCompactSupport\n\nopen Set MeasureTheory Metric Function Complex Bornology\nopen scoped NNReal ENNReal ComplexConjugate\nnoncomputable section\n\nsection Generic\nuniverse u\nvariable {\ud835\udd5c : Type*} [_root_.RCLike \ud835\udd5c]\nvariable {X : Type u} {A : \u211d\u22650} [PseudoMetricSpace X] [DoublingMeasure X A]\n\n/- The data in a tile structure, and some basic properties.\nThis is mostly separated out so that we can nicely define the notation `d_\ud835\udd2d`.\nNote: compose `\ud835\udcd8` with `Grid` to get the `\ud835\udcd8` of the paper. -/\nclass PreTileStructure {A : outParam \u211d\u22650} [PseudoMetricSpace X] [DoublingMeasure X A]\n  [FunctionDistances \ud835\udd5c X] (Q : outParam (SimpleFunc X (\u0398 X)))\n  (D : outParam \u2115) (\u03ba : outParam \u211d) (S : outParam \u2115) (o : outParam X)\n  extends GridStructure X D \u03ba S o where\n  protected \ud835\udd13 : Type u\n  fintype_\ud835\udd13 : Fintype \ud835\udd13\n  protected \ud835\udcd8 : \ud835\udd13 \u2192 Grid\n  surjective_\ud835\udcd8 : Surjective \ud835\udcd8\n  \ud835\udcac : \ud835\udd13 \u2192 \u0398 X\n  range_\ud835\udcac : range \ud835\udcac \u2286 range Q\n\nexport PreTileStructure (\ud835\udcac range_\ud835\udcac)\n\nvariable {D : \u2115} {\u03ba : \u211d} {S : \u2115} {o : X}\nvariable [FunctionDistances \ud835\udd5c X]  {Q : SimpleFunc X (\u0398 X)} [PreTileStructure Q D \u03ba S o]\n\nvariable (X) in\ndef \ud835\udd13 := PreTileStructure.\ud835\udd13 \ud835\udd5c X\ninstance : Fintype (\ud835\udd13 X) := PreTileStructure.fintype_\ud835\udd13\ndef \ud835\udcd8 : \ud835\udd13 X \u2192 Grid X := PreTileStructure.\ud835\udcd8\nlemma surjective_\ud835\udcd8 : Surjective (\ud835\udcd8 : \ud835\udd13 X \u2192 Grid X) := PreTileStructure.surjective_\ud835\udcd8\ninstance : Inhabited (\ud835\udd13 X) := \u27e8(surjective_\ud835\udcd8 default).choose\u27e9\ndef \ud835\udd20 (p : \ud835\udd13 X) : X := c (\ud835\udcd8 p)\ndef \ud835\udd30 (p : \ud835\udd13 X) : \u2124 := s (\ud835\udcd8 p)\n\nlocal notation \"ball_(\" D \",\" \ud835\udd2d \")\" => @ball (WithFunctionDistance (\ud835\udd20 \ud835\udd2d) (D ^ \ud835\udd30 \ud835\udd2d / 4)) _\n\n/-- A tile structure. -/\n-- note: we don't explicitly include injectivity of `\u03a9` on `\ud835\udd13(I)`, since it follows from these\n-- axioms: see `toTileLike_injective`\nclass TileStructure {A : outParam \u211d\u22650} [PseudoMetricSpace X] [DoublingMeasure X A]\n    [FunctionDistances \u211d X] (Q : outParam (SimpleFunc X (\u0398 X)))\n    (D : outParam \u2115) (\u03ba : outParam \u211d) (S : outParam \u2115) (o : outParam X)\n    extends PreTileStructure Q D \u03ba S o where\n  \u03a9 : \ud835\udd13 \u2192 Set (\u0398 X)\n  biUnion_\u03a9 {i} : range Q \u2286 \u22c3 p \u2208 \ud835\udcd8 \u207b\u00b9' {i}, \u03a9 p -- 2.0.13, union contains `Q`\n  disjoint_\u03a9 {p p'} (h : p \u2260 p') (hp : \ud835\udcd8 p = \ud835\udcd8 p') : -- 2.0.13, union is disjoint\n    Disjoint (\u03a9 p) (\u03a9 p')\n  relative_fundamental_dyadic {p p'} (h : \ud835\udcd8 p \u2264 \ud835\udcd8 p') : -- 2.0.14\n    Disjoint (\u03a9 p) (\u03a9 p') \u2228 \u03a9 p' \u2286 \u03a9 p\n  cball_subset {p} : ball_(D, p) (\ud835\udcac p) 5\u207b\u00b9 \u2286 \u03a9 p -- 2.0.15, first inclusion\n  subset_cball {p} : \u03a9 p \u2286 ball_(D, p) (\ud835\udcac p) 1 -- 2.0.15, second inclusion\n\nexport TileStructure (\u03a9 biUnion_\u03a9 disjoint_\u03a9 relative_fundamental_dyadic)\n\nend Generic\n\n\nopen scoped ShortVariables\nvariable {X : Type*} [PseudoMetricSpace X] {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102}\n  {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X} [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G]\n\nsection\n\nvariable [TileStructure Q D \u03ba S o] {p p' : \ud835\udd13 X} {f g : \u0398 X}\n\n-- maybe we should delete the following three notations, and use `dist_{\ud835\udcd8 p}` instead?\nnotation \"dist_(\" \ud835\udd2d \")\" => @dist (WithFunctionDistance (\ud835\udd20 \ud835\udd2d) (D ^ \ud835\udd30 \ud835\udd2d / 4)) _\nnotation \"nndist_(\" \ud835\udd2d \")\" => @nndist (WithFunctionDistance (\ud835\udd20 \ud835\udd2d) (D ^ \ud835\udd30 \ud835\udd2d / 4)) _\nnotation \"ball_(\" \ud835\udd2d \")\" => @ball (WithFunctionDistance (\ud835\udd20 \ud835\udd2d) (D ^ \ud835\udd30 \ud835\udd2d / 4)) _\n\n\n@[simp] lemma dist_\ud835\udcd8 (p : \ud835\udd13 X) : dist_{\ud835\udcd8 p} f g = dist_(p) f g := rfl\n@[simp] lemma nndist_\ud835\udcd8 (p : \ud835\udd13 X) : nndist_{\ud835\udcd8 p} f g = nndist_(p) f g := rfl\n@[simp] lemma ball_\ud835\udcd8 (p : \ud835\udd13 X) {r : \u211d} : ball_{\ud835\udcd8 p} f r = ball_(p) f r := rfl\n\n@[simp] lemma cball_subset {p : \ud835\udd13 X} : ball_(p) (\ud835\udcac p) 5\u207b\u00b9 \u2286 \u03a9 p := TileStructure.cball_subset\n@[simp] lemma subset_cball {p : \ud835\udd13 X} : \u03a9 p \u2286 ball_(p) (\ud835\udcac p) 1 := TileStructure.subset_cball\n\nlemma ball_eq_of_grid_eq {p q : \ud835\udd13 X} {\u03d1 : \u0398 X} {r : \u211d} (h : \ud835\udcd8 p = \ud835\udcd8 q) :\n    ball_(p) \u03d1 r = ball_(q) \u03d1 r := by rw [\u2190 ball_\ud835\udcd8, h]\n\nlemma cball_disjoint {p p' : \ud835\udd13 X} (h : p \u2260 p') (hp : \ud835\udcd8 p = \ud835\udcd8 p') :\n    Disjoint (ball_(p) (\ud835\udcac p) 5\u207b\u00b9) (ball_(p') (\ud835\udcac p') 5\u207b\u00b9) :=\n  disjoint_of_subset cball_subset cball_subset (disjoint_\u03a9 h hp)\n\n/-- The set `E` defined in Proposition 2.0.2. -/\ndef E (p : \ud835\udd13 X) : Set X :=\n  { x \u2208 \ud835\udcd8 p | Q x \u2208 \u03a9 p \u2227 \ud835\udd30 p \u2208 Icc (\u03c3\u2081 x) (\u03c3\u2082 x) }\n\nlemma E_subset_\ud835\udcd8 {p : \ud835\udd13 X} : E p \u2286 \ud835\udcd8 p := fun _ \u21a6 mem_of_mem_inter_left\n\nlemma measurableSet_E {p : \ud835\udd13 X} : MeasurableSet (E p) := by\n  refine (Measurable.and ?_ (Measurable.and ?_ ?_)).setOf\n  \u00b7 rw [\u2190 measurableSet_setOf]; exact coeGrid_measurable\n  \u00b7 simp_rw [\u2190 mem_preimage, \u2190 measurableSet_setOf]; exact SimpleFunc.measurableSet_preimage ..\n  \u00b7 apply (measurable_set_mem _).comp\n    apply Measurable.comp (f := fun x \u21a6 (\u03c3\u2081 x, \u03c3\u2082 x)) (g := fun p \u21a6 Icc p.1 p.2)\n    \u00b7 exact measurable_from_prod_countable fun _ _ _ \u21a6 trivial\n    \u00b7 exact measurable_\u03c3\u2081.prod_mk measurable_\u03c3\u2082\n\nlemma volume_E_lt_top : volume (E p) < \u22a4 := trans (measure_mono E_subset_\ud835\udcd8) volume_coeGrid_lt_top\n\nsection T\n\n/-- The operator `T_\ud835\udd2d` defined in Proposition 2.0.2, considered on the set `F`.\nIt is the map `T \u2218 (1_F * \u00b7) : f \u21a6 T (1_F * f)`, also denoted `T1_F`\nThe operator `T` in Proposition 2.0.2 is therefore applied to `(F := Set.univ)`. -/\ndef carlesonOn (p : \ud835\udd13 X) (f : X \u2192 \u2102) : X \u2192 \u2102 :=\n  indicator (E p)\n    fun x \u21a6 \u222b y, exp (I * (Q x y - Q x x)) * K x y * \u03c8 (D ^ (- \ud835\udd30 p) * dist x y) * f y\n\n-- not used anywhere and deprecated for `AEStronglyMeasurable.carlesonOn`\nlemma measurable_carlesonOn {p : \ud835\udd13 X} {f : X \u2192 \u2102} (measf : Measurable f) :\n    Measurable (carlesonOn p f) := by\n  refine (StronglyMeasurable.integral_prod_right ?_).measurable.indicator measurableSet_E\n  refine (((Measurable.mul ?_ measurable_K).mul ?_).mul ?_).stronglyMeasurable\n  \u00b7 have : Measurable fun (p : X \u00d7 X) \u21a6 (p.1, p.1) := by fun_prop\n    refine ((Measurable.sub ?_ ?_).const_mul I).cexp <;> apply measurable_ofReal.comp\n    \u00b7 exact measurable_Q\u2082\n    \u00b7 exact measurable_Q\u2082.comp this\n  \u00b7 apply measurable_ofReal.comp\n    apply Measurable.comp (f := fun x : X \u00d7 X \u21a6 D ^ (-\ud835\udd30 p) * dist x.1 x.2) (g := \u03c8)\n    \u00b7 exact measurable_const.max (measurable_const.min (Measurable.min (by fun_prop) (by fun_prop)))\n    \u00b7 exact measurable_dist.const_mul _\n  \u00b7 exact measf.comp measurable_snd\n\nopen Classical in\n/-- The operator `T_\u212d f` defined at the bottom of Section 7.4.\nWe will use this in other places of the formalization as well. -/\ndef carlesonSum (\u212d : Set (\ud835\udd13 X)) (f : X \u2192 \u2102) (x : X) : \u2102 :=\n  \u2211 p \u2208 {p | p \u2208 \u212d}, carlesonOn p f x\n\n-- not used anywhere and deprecated for `AEStronglyMeasurable.carlesonSum`\n@[fun_prop]\nlemma measurable_carlesonSum {\u212d : Set (\ud835\udd13 X)} {f : X \u2192 \u2102} (measf : Measurable f) :\n    Measurable (carlesonSum \u212d f) :=\n  Finset.measurable_sum _ fun _ _ \u21a6 measurable_carlesonOn measf\n\nlemma _root_.MeasureTheory.AEStronglyMeasurable.carlesonOn {p : \ud835\udd13 X} {f : X \u2192 \u2102}\n    (hf : AEStronglyMeasurable f) : AEStronglyMeasurable (carlesonOn p f) := by\n  refine .indicator ?_ measurableSet_E\n  refine .integral_prod_right'\n    (f := fun z \u21a6 exp (Complex.I * (Q z.1 z.2 - Q z.1 z.1)) * K z.1 z.2 *\n      \u03c8 (D ^ (- \ud835\udd30 p) * dist z.1 z.2) * f z.2) ?_\n  refine (((AEStronglyMeasurable.mul ?_ aestronglyMeasurable_K).mul ?_).mul ?_)\n  \u00b7 apply Measurable.aestronglyMeasurable\n    have : Measurable fun (p : X \u00d7 X) \u21a6 (p.1, p.1) := by fun_prop\n    refine ((Measurable.sub ?_ ?_).const_mul I).cexp <;> apply measurable_ofReal.comp\n    \u00b7 exact measurable_Q\u2082\n    \u00b7 exact measurable_Q\u2082.comp this\n  \u00b7 apply Measurable.aestronglyMeasurable\n    apply measurable_ofReal.comp\n    apply Measurable.comp (f := fun x : X \u00d7 X \u21a6 D ^ (-\ud835\udd30 p) * dist x.1 x.2) (g := \u03c8)\n    \u00b7 exact measurable_const.max (measurable_const.min (Measurable.min (by fun_prop) (by fun_prop)))\n    \u00b7 exact measurable_dist.const_mul _\n  \u00b7 exact hf.snd\n\nlemma _root_.MeasureTheory.AEStronglyMeasurable.carlesonSum {\u212d : Set (\ud835\udd13 X)}\n    {f : X \u2192 \u2102} (hf : AEStronglyMeasurable f) : AEStronglyMeasurable (carlesonSum \u212d f) :=\n  Finset.aestronglyMeasurable_sum _ fun _ _ \u21a6 hf.carlesonOn\n\nlemma carlesonOn_def' (p : \ud835\udd13 X) (f : X \u2192 \u2102) : carlesonOn p f =\n    indicator (E p) fun x \u21a6 \u222b y, Ks (\ud835\udd30 p) x y * f y * exp (I * (Q x y - Q x x)) := by\n  unfold carlesonOn Ks\n  exact congr_arg _ (funext fun x \u21a6 (congr_arg _ (funext fun y \u21a6 by ring)))\n\nlemma support_carlesonOn_subset_E {f : X \u2192 \u2102} : support (carlesonOn p f) \u2286 E p :=\n  fun _ hx \u21a6 mem_of_indicator_ne_zero hx\n\nlemma support_carlesonSum_subset {\u212d : Set (\ud835\udd13 X)} {f : X \u2192 \u2102} :\n    support (carlesonSum \u212d f) \u2286 (\u22c3 p \u2208 \u212d, \ud835\udcd8 p) := by\n  intro x hx\n  rw [mem_support] at hx\n  contrapose! hx\n  refine Finset.sum_eq_zero (fun p hp \u21a6 nmem_support.mp (fun hxp \u21a6 hx ?_))\n  simp only [Finset.mem_filter] at hp\n  exact Set.mem_biUnion hp.2 <| E_subset_\ud835\udcd8 (support_carlesonOn_subset_E hxp)\n\ntheorem _root_.MeasureTheory.BoundedCompactSupport.carlesonOn {f : X \u2192 \u2102}\n    (hf : BoundedCompactSupport f) : BoundedCompactSupport (carlesonOn p f) where\n  stronglyMeasurable :=\n    (measurable_carlesonOn hf.stronglyMeasurable.measurable).stronglyMeasurable\n  isBounded := by\n    let x\u2080 : X := Classical.choice inferInstance\n    obtain \u27e8r\u2080, hr\u2080, hfr\u2080\u27e9 := hf.isBoundedSupport.subset_closedBall_lt 0 x\u2080\n    let r\u2081 := (\u2191D ^ \ud835\udd30 p / 2) + r\u2080\n    have hcf : support (_root_.carlesonOn p f) \u2286 closedBall x\u2080 r\u2081 := by\n      simp_rw [carlesonOn_def']\n      intro x hx\n      simp only [mem_support] at hx\n      apply indicator_apply_ne_zero.mp at hx\n      replace hx := hx.2\n      simp only [mem_support] at hx\n      have : \u2203 y, Ks (\ud835\udd30 p) x y * f y * cexp (I * (\u2191((Q x) y) - \u2191((Q x) x))) \u2260 0 := by\n        -- mathlib lemma: if integral ne zero, then integrand ne zero at a point\n        by_contra hc\n        simp only [not_exists, ne_eq, not_not] at hc\n        refine hx ?_\n        refine integral_eq_zero_of_ae ?_\n        simp_all only [support_subset_iff, ne_eq,\n          mem_closedBall, integral_zero, not_true_eq_false, x\u2080]\n      obtain \u27e8y, hy\u27e9 := this\n      simp only [ne_eq, mul_eq_zero, exp_ne_zero, or_false, not_or] at hy\n      have := dist_mem_Icc_of_Ks_ne_zero hy.1\n      apply (dist_triangle _ y _).trans\n      unfold r\u2081\n      gcongr\n      \u00b7 exact (dist_mem_Icc_of_Ks_ne_zero hy.1).2\n      \u00b7 exact hfr\u2080 hy.2\n    obtain \u27e8CK, hCK, hCK\u27e9 :=\n      IsBounded.exists_bound_of_norm_Ks (Metric.isBounded_closedBall (x := x\u2080) (r := r\u2081)) (\ud835\udd30 p)\n    let C := volume.real (closedBall x\u2080 r\u2080) * (CK * (eLpNorm f \u22a4).toReal)\n    apply isBounded_range_iff_forall_norm_le.2 \u27e8C, fun x \u21a6 ?_\u27e9\n    wlog hx : x \u2208 support (_root_.carlesonOn p f)\n    \u00b7 simp only [mem_support, ne_eq, not_not] at hx\n      rw [hx, norm_zero]\n      positivity\n    \u00b7 simp_rw [carlesonOn_def']\n      refine trans (norm_indicator_le_norm_self _ _) ?_\n      let g := (closedBall x\u2080 r\u2080).indicator (fun _ \u21a6 CK * (eLpNorm f \u22a4).toReal)\n      have hK : \u2200\u1d50 y, \u2016Ks (\ud835\udd30 p) x y * f y * cexp (I * (\u2191((Q x) y) - \u2191((Q x) x)))\u2016 \u2264 g y := by\n        filter_upwards [hf.ae_le] with y hy\n        by_cases hy' : y \u2208 support f\n        \u00b7 have := hfr\u2080 hy'\n          calc\n            _ \u2264 \u2016Ks (\ud835\udd30 p) x y * f y\u2016 * \u2016cexp (I * (\u2191((Q x) y) - \u2191((Q x) x)))\u2016 := norm_mul_le ..\n            _ = \u2016Ks (\ud835\udd30 p) x y * f y\u2016 := by rw [norm_exp_I_mul_sub_ofReal, mul_one]\n            _ \u2264 \u2016Ks (\ud835\udd30 p) x y\u2016 * \u2016f y\u2016 := norm_mul_le ..\n            _ \u2264 CK * (eLpNorm f \u22a4).toReal := by gcongr; exact hCK x y (hcf hx)\n            _ = g y := by simp_all only [indicator_of_mem, g]\n        \u00b7 simp only [mem_support, ne_eq, not_not] at hy'\n          rw [hy']\n          simp only [mul_zero, zero_mul, norm_zero, g]\n          unfold indicator\n          split_ifs <;> positivity\n      calc\n        _ \u2264 \u222b y, g y := by\n          refine norm_integral_le_of_norm_le ?_ hK\n          exact Integrable.indicator_const measurableSet_closedBall measure_closedBall_lt_top\n        _ = volume.real (closedBall x\u2080 r\u2080) * (CK * (eLpNorm f \u22a4 volume).toReal) :=\n          integral_indicator_const _ measurableSet_closedBall\n  hasCompactSupport := by\n    suffices support (_root_.carlesonOn p f) \u2286 \ud835\udcd8 p by\n      refine HasCompactSupport.of_support_subset_isBounded ?_ this\n      exact Metric.isBounded_ball.subset Grid_subset_ball\n    exact Trans.trans support_carlesonOn_subset_E E_subset_\ud835\udcd8\n\ntheorem _root_.MeasureTheory.BoundedCompactSupport.carlesonSum {\u212d : Set (\ud835\udd13 X)} {f : X \u2192 \u2102}\n    (hf : BoundedCompactSupport f) : BoundedCompactSupport (carlesonSum \u212d f) :=\n  .finset_sum (fun _ _ \u21a6 hf.carlesonOn)\n\nlemma carlesonSum_inter_add_inter_compl {f : X \u2192 \u2102} {x : X} (A B : Set (\ud835\udd13 X)) :\n    carlesonSum (A \u2229 B) f x + carlesonSum (A \u2229 B\u1d9c) f x = carlesonSum A f x := by\n  classical\n  simp only [carlesonSum]\n  conv_rhs => rw [\u2190 Finset.sum_filter_add_sum_filter_not _ (fun p \u21a6 p \u2208 B)]\n  congr 2\n  \u00b7 ext; simp\n  \u00b7 ext; simp\n\nlemma sum_carlesonSum_of_pairwiseDisjoint {\u03b9 : Type*} {f : X \u2192 \u2102} {x : X} {A : \u03b9 \u2192 Set (\ud835\udd13 X)}\n    {s : Finset \u03b9} (hs : (s : Set \u03b9).PairwiseDisjoint A) :\n    \u2211 i \u2208 s, carlesonSum (A i) f x = carlesonSum (\u22c3 i \u2208 s, A i) f x := by\n  classical\n  simp only [carlesonSum]\n  rw [\u2190 Finset.sum_biUnion]\n  \u00b7 congr\n    ext p\n    simp\n  \u00b7 convert hs\n    refine \u27e8fun h \u21a6 ?_, fun h \u21a6 ?_\u27e9\n    \u00b7 intro i hi j hj hij\n      convert Finset.disjoint_coe.2 (h hi hj hij)\n      \u00b7 ext; simp\n      \u00b7 ext; simp\n    \u00b7 intro i hi j hj hij\n      apply Finset.disjoint_coe.1\n      convert h hi hj hij\n      \u00b7 ext; simp\n      \u00b7 ext; simp\n\nend T\n\nvariable (X) in\ndef TileLike : Type _ := Grid X \u00d7 OrderDual (Set (\u0398 X))\n\ndef TileLike.fst (x : TileLike X) : Grid X := x.1\ndef TileLike.snd (x : TileLike X) : Set (\u0398 X) := x.2\n\n@[simp] lemma TileLike.fst_mk (x : Grid X) (y : Set (\u0398 X)) : TileLike.fst (x, y) = x := by rfl\n@[simp] lemma TileLike.snd_mk (x : Grid X) (y : Set (\u0398 X)) : TileLike.snd (x, y) = y := by rfl\n\ninstance : PartialOrder (TileLike X) := by dsimp [TileLike]; infer_instance\n\nlemma TileLike.le_def (x y : TileLike X) : x \u2264 y \u2194 x.fst \u2264 y.fst \u2227 y.snd \u2286 x.snd := by rfl\n\ndef toTileLike (p : \ud835\udd13 X) : TileLike X := (\ud835\udcd8 p, \u03a9 p)\n\n@[simp] lemma toTileLike_fst (p : \ud835\udd13 X) : (toTileLike p).fst = \ud835\udcd8 p := by rfl\n@[simp] lemma toTileLike_snd (p : \ud835\udd13 X) : (toTileLike p).snd = \u03a9 p := by rfl\n\n/-- This is not defined as such in the blueprint, but `\u03bbp \u2272 \u03bb'p'` can be written using\n`smul l p \u2264 smul l' p'`.\nBeware: `smul 1 p` is very different from `toTileLike p`. -/\ndef smul (l : \u211d) (p : \ud835\udd13 X) : TileLike X :=\n  (\ud835\udcd8 p, ball_(p) (\ud835\udcac p) l)\n\n@[simp] lemma smul_fst (l : \u211d) (p : \ud835\udd13 X) : (smul l p).fst = \ud835\udcd8 p := by rfl\n@[simp] lemma smul_snd (l : \u211d) (p : \ud835\udd13 X) : (smul l p).snd = ball_(p) (\ud835\udcac p) l := by rfl\n\nlemma smul_mono_left {l l' : \u211d} {p : \ud835\udd13 X} (h : l \u2264 l') : smul l' p \u2264 smul l p := by\n  simp [TileLike.le_def, h, ball_subset_ball]\n\nlemma smul_le_toTileLike : smul 1 p \u2264 toTileLike p := by\n  simp [TileLike.le_def, subset_cball (p := p)]\n\nlemma toTileLike_le_smul : toTileLike p \u2264 smul 5\u207b\u00b9 p := by\n  simp [TileLike.le_def, cball_subset (p := p)]\n\nlemma \ud835\udcac_mem_\u03a9 : \ud835\udcac p \u2208 \u03a9 p := cball_subset <| mem_ball_self <| by norm_num\n\nlemma \ud835\udcac_inj {p' : \ud835\udd13 X} (h : \ud835\udcac p = \ud835\udcac p') (h\ud835\udcd8 : \ud835\udcd8 p = \ud835\udcd8 p') : p = p' := by\n  contrapose! h\n  exact fun h\ud835\udcac \u21a6 (not_disjoint_iff.2 \u27e8\ud835\udcac p, \ud835\udcac_mem_\u03a9, h\ud835\udcac \u25b8 \ud835\udcac_mem_\u03a9\u27e9) (disjoint_\u03a9 h h\ud835\udcd8)\n\nlemma toTileLike_injective : Injective (fun p : \ud835\udd13 X \u21a6 toTileLike p) := by\n  intros p p' h\n  simp_rw [toTileLike, TileLike, Prod.ext_iff] at h\n  by_contra h2\n  have : Disjoint (\u03a9 p) (\u03a9 p') := disjoint_\u03a9 h2 h.1\n  have : \u03a9 p = \u2205 := by simpa [\u2190 h.2]\n  exact not_mem_empty _ (by rw [\u2190 this]; exact \ud835\udcac_mem_\u03a9)\n\ninstance : PartialOrder (\ud835\udd13 X) := PartialOrder.lift toTileLike toTileLike_injective\n\nlemma \ud835\udd13.le_def {p q : \ud835\udd13 X} : p \u2264 q \u2194 toTileLike p \u2264 toTileLike q := by rfl\nlemma \ud835\udd13.le_def' {p q : \ud835\udd13 X} : p \u2264 q \u2194 \ud835\udcd8 p \u2264 \ud835\udcd8 q \u2227 \u03a9 q \u2286 \u03a9 p := by rfl\n\nlemma dist_\ud835\udcac_lt_one_of_le {p q : \ud835\udd13 X} (h : p \u2264 q) : dist_(p) (\ud835\udcac q) (\ud835\udcac p) < 1 :=\n  ((cball_subset.trans h.2).trans subset_cball) (mem_ball_self (by norm_num))\n\nlemma dist_\ud835\udcac_lt_one_of_le' {p q : \ud835\udd13 X} (h : p \u2264 q) : dist_(p) (\ud835\udcac p) (\ud835\udcac q) < 1 :=\n  mem_ball'.mp (dist_\ud835\udcac_lt_one_of_le h)\n\nlemma \ud835\udcd8_strictMono : StrictMono (\ud835\udcd8 (X := X)) := fun _ _ h \u21a6 h.le.1.lt_of_ne <|\n  fun h' \u21a6 disjoint_left.mp (disjoint_\u03a9 h.ne h') (h.le.2 \ud835\udcac_mem_\u03a9) \ud835\udcac_mem_\u03a9\n\n/-- Lemma 5.3.1 -/\nlemma smul_mono {m m' n n' : \u211d} (hp : smul n p \u2264 smul m p') (hm : m' \u2264 m) (hn : n \u2264 n') :\n    smul n' p \u2264 smul m' p' :=\n  smul_mono_left hn |>.trans hp |>.trans <| smul_mono_left hm\n\n/-- Lemma 5.3.2 (generalizing `1` to `k > 0`) -/\nlemma smul_C2_1_2 (m : \u211d) {n k : \u211d} (hk : 0 < k) (hp : \ud835\udcd8 p \u2260 \ud835\udcd8 p') (hl : smul n p \u2264 smul k p') :\n    smul (n + C2_1_2 a * m) p \u2264 smul m p' := by\n  replace hp : \ud835\udcd8 p < \ud835\udcd8 p' := hl.1.lt_of_ne hp\n  have : ball_(p') (\ud835\udcac p') m \u2286 ball_(p) (\ud835\udcac p) (n + C2_1_2 a * m) := fun x hx \u21a6 by\n    rw [@mem_ball] at hx \u22a2\n    calc\n      _ \u2264 dist_(p) x (\ud835\udcac p') + dist_(p) (\ud835\udcac p') (\ud835\udcac p) := dist_triangle ..\n      _ \u2264 C2_1_2 a * dist_(p') x (\ud835\udcac p') + dist_(p) (\ud835\udcac p') (\ud835\udcac p) := by\n        gcongr; exact Grid.dist_strictMono hp\n      _ < C2_1_2 a * m + dist_(p) (\ud835\udcac p') (\ud835\udcac p) := by gcongr; rw [C2_1_2]; positivity\n      _ < _ := by\n        rw [add_comm]; gcongr\n        exact mem_ball.mp <| mem_of_mem_of_subset (by convert mem_ball_self hk) hl.2\n  exact \u27e8hl.1, this\u27e9\n\nlemma dist_LTSeries {n : \u2115} {u : Set (\ud835\udd13 X)} {s : LTSeries u} (hs : s.length = n) {f g : \u0398 X} :\n    dist_(s.head.1) f g \u2264 C2_1_2 a ^ n * dist_(s.last.1) f g := by\n  induction n generalizing s with\n  | zero => rw [pow_zero, one_mul]; apply Grid.dist_mono s.head_le_last.1\n  | succ n ih =>\n    let s' : LTSeries u := s.eraseLast\n    specialize ih (show s'.length = n by simp [s', hs])\n    have link : dist_(s'.last.1) f g \u2264 C2_1_2 a * dist_(s.last.1) f g :=\n      Grid.dist_strictMono <| \ud835\udcd8_strictMono <| s.eraseLast_last_rel_last (by omega)\n    apply ih.trans; rw [pow_succ, mul_assoc]; gcongr; unfold C2_1_2; positivity\n\nend\n\n/-- The constraint on `\u03bb` in the first part of Lemma 5.3.3. -/\ndef C5_3_3 (a : \u2115) : \u211d := (1 - C2_1_2 a)\u207b\u00b9\n\ninclude q K \u03c3\u2081 \u03c3\u2082 F G in\nlemma C5_3_3_le : C5_3_3 a \u2264 11 / 10 := by\n  rw [C5_3_3, inv_le_comm\u2080 (sub_pos.mpr <| C2_1_2_lt_one X) (by norm_num), le_sub_comm]\n  exact C2_1_2_le_inv_512 X |>.trans <| by norm_num\n\nvariable [TileStructure Q D \u03ba S o] {p p' : \ud835\udd13 X} {f g : \u0398 X}\n\n/-- Lemma 5.3.3, Equation (5.3.3) -/\nlemma wiggle_order_11_10 {n : \u211d} (hp : p \u2264 p') (hn : C5_3_3 a \u2264 n) : smul n p \u2264 smul n p' := by\n  rcases eq_or_ne (\ud835\udcd8 p) (\ud835\udcd8 p') with h | h\n  \u00b7 rcases eq_or_ne p p' with rfl | h2\n    \u00b7 rfl\n    \u00b7 exact absurd h (\ud835\udcd8_strictMono (lt_of_le_of_ne hp h2)).ne\n  \u00b7 calc\n      _ \u2264 smul (1 + C2_1_2 a * n) p := by\n        apply smul_mono_left\n        rwa [\u2190 le_sub_iff_add_le, \u2190 one_sub_mul, \u2190 inv_le_iff_one_le_mul\u2080']\n        linarith [C2_1_2_le_inv_512 (X := X)]\n      _ \u2264 smul n p' := smul_C2_1_2 (k := 5\u207b\u00b9) n (by norm_num) h\n        (smul_le_toTileLike.trans <| \ud835\udd13.le_def.mp hp |>.trans toTileLike_le_smul)\n\n/-- Lemma 5.3.3, Equation (5.3.4) -/\nlemma wiggle_order_100 (hp : smul 10 p \u2264 smul 1 p') (hn : \ud835\udcd8 p \u2260 \ud835\udcd8 p') :\n    smul 100 p \u2264 smul 100 p' :=\n  calc\n    _ \u2264 smul (10 + C2_1_2 a * 100) p :=\n      smul_mono_left (by linarith [C2_1_2_le_inv_512 (X := X)])\n    _ \u2264 _ := smul_C2_1_2 100 zero_lt_one hn hp\n\n/-- Lemma 5.3.3, Equation (5.3.5) -/\nlemma wiggle_order_500 (hp : smul 2 p \u2264 smul 1 p') (hn : \ud835\udcd8 p \u2260 \ud835\udcd8 p') :\n    smul 4 p \u2264 smul 500 p' :=\n  calc\n    _ \u2264 smul (2 + C2_1_2 a * 500) p :=\n      smul_mono_left (by linarith [C2_1_2_le_inv_512 (X := X)])\n    _ \u2264 _ := smul_C2_1_2 500 zero_lt_one hn hp\n\ndef C5_3_2 (a : \u2115) : \u211d := 2 ^ (-95 * (a : \u211d))\n\ndef TileLike.toTile (t : TileLike X) : Set (X \u00d7 \u0398 X) :=\n  (t.fst : Set X) \u00d7\u02e2 t.snd\n\n/-- From a TileLike, we can construct a set. This is used in the definitions `E\u2081` and `E\u2082`. -/\ndef TileLike.toSet (t : TileLike X) : Set X :=\n  t.fst \u2229 G \u2229 Q \u207b\u00b9' t.snd\n\ndef E\u2081 (p : \ud835\udd13 X) : Set X :=\n  (toTileLike p).toSet\n\ndef E\u2082 (l : \u211d) (p : \ud835\udd13 X) : Set X :=\n  (smul l p).toSet\n\nlemma E\u2081_subset (p : \ud835\udd13 X) : E\u2081 p \u2286 \ud835\udcd8 p := by\n  change \u2191(\ud835\udcd8 p) \u2229 G \u2229 (Q \u207b\u00b9' \u03a9 p) \u2286 \u2191(\ud835\udcd8 p)\n  rw [inter_assoc]\n  exact inter_subset_left\n\nlemma E\u2082_subset (l : \u211d) (p : \ud835\udd13 X) : E\u2082 l p \u2286 \ud835\udcd8 p := by\n  change \u2191(\ud835\udcd8 p) \u2229 G \u2229 (Q \u207b\u00b9' (ball_(p) (\ud835\udcac p) l)) \u2286 \u2191(\ud835\udcd8 p)\n  rw [inter_assoc]\n  exact inter_subset_left\n\n/-! `\ud835\udd13(\ud835\udd13')` in the blueprint is `lowerClosure \ud835\udd13'` in Lean. -/\n\n/-- This density is defined to live in `\u211d\u22650\u221e`. Use `ENNReal.toReal` to get a real number. -/\ndef dens\u2081 (\ud835\udd13' : Set (\ud835\udd13 X)) : \u211d\u22650\u221e :=\n  \u2a06 (p' \u2208 \ud835\udd13') (l \u2265 (2 : \u211d\u22650)), l ^ (-a : \u211d) *\n  \u2a06 (p \u2208 lowerClosure \ud835\udd13') (_h2 : smul l p' \u2264 smul l p),\n  volume (E\u2082 l p) / volume (\ud835\udcd8 p : Set X)\n\nlemma dens\u2081_mono {\ud835\udd13\u2081 \ud835\udd13\u2082 : Set (\ud835\udd13 X)} (h : \ud835\udd13\u2081 \u2286 \ud835\udd13\u2082) :\n    dens\u2081 \ud835\udd13\u2081 \u2264 dens\u2081 \ud835\udd13\u2082 := by\n  simp only [dens\u2081, iSup_le_iff]\n  intro p hp r hr\n  refine le_iSup\u2082_of_le p (h hp) ?_\n  apply ENNReal.mul_le_of_le_div'\n  simp only [iSup_le_iff]\n  intro q hq hqr\n  rw [ENNReal.le_div_iff_mul_le (by left; simp)]\n  \u00b7 refine le_iSup\u2082_of_le r hr ?_\n    rw [mul_comm]\n    gcongr\n    exact le_iSup\u2082_of_le q (lowerClosure_mono h hq) (le_iSup_iff.mpr fun b a \u21a6 a hqr)\n  \u00b7 left\n    have hr0 : r \u2260 0 := by positivity\n    simp [hr0]\n\n/-- This density is defined to live in `\u211d\u22650\u221e`. Use `ENNReal.toReal` to get a real number. -/\ndef dens\u2082 (\ud835\udd13' : Set (\ud835\udd13 X)) : \u211d\u22650\u221e :=\n  \u2a06 (p \u2208 \ud835\udd13') (r \u2265 4 * (D ^ \ud835\udd30 p : \u211d)),\n  volume (F \u2229 ball (\ud835\udd20 p) r) / volume (ball (\ud835\udd20 p) r)\n\nlemma dens\u2082_eq_biSup_dens\u2082 (\ud835\udd13' : Set (\ud835\udd13 X)) :\n    dens\u2082 (\ud835\udd13') = \u2a06 (p \u2208 \ud835\udd13'), dens\u2082 ({p}) := by\n  simp [dens\u2082]\n\n-- a small characterization that might be useful\nlemma isAntichain_iff_disjoint (\ud835\udd04 : Set (\ud835\udd13 X)) :\n    IsAntichain (\u00b7\u2264\u00b7) (toTileLike (X := X) '' \ud835\udd04) \u2194\n    \u2200 p p', p \u2208 \ud835\udd04 \u2192 p' \u2208 \ud835\udd04 \u2192 p \u2260 p' \u2192\n    Disjoint (toTileLike (X := X) p).toTile (toTileLike p').toTile := sorry\n\nlemma ENNReal.rpow_le_rpow_of_nonpos {x y : \u211d\u22650\u221e} {z : \u211d} (hz : z \u2264 0) (h : x \u2264 y) :\n    y ^ z \u2264 x ^ z := by\n  rw [\u2190 neg_neg z, rpow_neg y, rpow_neg x, \u2190 inv_rpow, \u2190 inv_rpow]\n  exact rpow_le_rpow (ENNReal.inv_le_inv.mpr h) (neg_nonneg.mpr hz)\n\n/- A rough estimate. It's also less than 2 ^ (-a) -/\ndef dens\u2081_le_one {\ud835\udd13' : Set (\ud835\udd13 X)} : dens\u2081 \ud835\udd13' \u2264 1 := by\n  conv_rhs => rw [\u2190 mul_one 1]\n  simp only [dens\u2081, mem_lowerClosure, iSup_exists, iSup_le_iff]\n  intros i _ j hj\n  gcongr\n  \u00b7 calc\n    (j : \u211d\u22650\u221e) ^ (-(a : \u211d)) \u2264 2 ^ (-(a : \u211d)) := by\n      apply ENNReal.rpow_le_rpow_of_nonpos\n      \u00b7 simp_rw [neg_nonpos, Nat.cast_nonneg']\n      exact_mod_cast hj\n    _ \u2264 2 ^ (0 : \u211d) :=\n      ENNReal.rpow_le_rpow_of_exponent_le (by norm_num) (neg_nonpos.mpr (Nat.cast_nonneg' _))\n    _ = 1 := by norm_num\n  simp only [iSup_le_iff, and_imp]\n  intros i' _ _ _ _\n  calc\n  volume (E\u2082 j i') / volume (\ud835\udcd8 i' : Set X) \u2264 volume (\ud835\udcd8 i' : Set X) / volume (\ud835\udcd8 i' : Set X) := by\n    gcongr\n    apply E\u2082_subset\n  _ \u2264 1 := ENNReal.div_self_le_one\n\n/-! ### Stack sizes -/\n\nvariable {C C' : Set (\ud835\udd13 X)} {x x' : X}\nopen scoped Classical\n\n/-- The number of tiles `p` in `s` whose underlying cube `\ud835\udcd8 p` contains `x`. -/\ndef stackSize (C : Set (\ud835\udd13 X)) (x : X) : \u2115 :=\n  \u2211 p \u2208 { p | p \u2208 C }, (\ud835\udcd8 p : Set X).indicator 1 x\n\nlemma stackSize_setOf_add_stackSize_setOf_not {P : \ud835\udd13 X \u2192 Prop} :\n    stackSize {p \u2208 C | P p} x + stackSize {p \u2208 C | \u00ac P p} x = stackSize C x := by\n  simp_rw [stackSize]\n  conv_rhs => rw [\u2190 Finset.sum_filter_add_sum_filter_not _ P]\n  simp_rw [Finset.filter_filter]\n  congr\n\nlemma stackSize_congr (h : \u2200 p \u2208 C, x \u2208 (\ud835\udcd8 p : Set X) \u2194 x' \u2208 (\ud835\udcd8 p : Set X)) :\n    stackSize C x = stackSize C x' := by\n  refine Finset.sum_congr rfl fun p hp \u21a6 ?_\n  simp_rw [Finset.mem_filter, Finset.mem_univ, true_and] at hp\n  simp_rw [indicator, h p hp, Pi.one_apply]\n\nlemma stackSize_mono (h : C \u2286 C') : stackSize C x \u2264 stackSize C' x := by\n  apply Finset.sum_le_sum_of_subset (fun x \u21a6 ?_)\n  simp [iff_true_intro (@h x)]\n\n-- Simplify the cast of `stackSize C x` from `\u2115` to `\u211d`\nlemma stackSize_real (C : Set (\ud835\udd13 X)) (x : X) : (stackSize C x : \u211d) =\n    \u2211 p \u2208 { p | p \u2208 C }, (\ud835\udcd8 p : Set X).indicator (1 : X \u2192 \u211d) x := by\n  rw [stackSize, Nat.cast_sum]\n  refine Finset.sum_congr rfl (fun u _ \u21a6 ?_)\n  by_cases hx : x \u2208 (\ud835\udcd8 u : Set X) <;> simp [hx]\n\nlemma stackSize_measurable : Measurable fun x \u21a6 (stackSize C x : \u211d\u22650\u221e) := by\n  simp_rw [stackSize, Nat.cast_sum, indicator, Nat.cast_ite]\n  refine Finset.measurable_sum _ fun _ _ \u21a6 Measurable.ite coeGrid_measurable ?_ ?_ <;> simp\n\nlemma stackSize_le_one_of_pairwiseDisjoint {C : Set (\ud835\udd13 X)} {x : X}\n    (h : C.PairwiseDisjoint (fun p \u21a6 (\ud835\udcd8 p : Set X))) : stackSize C x \u2264 1 := by\n  by_cases hx : \u2203 p \u2208 C, x \u2208 (\ud835\udcd8 p : Set X)\n  \u00b7 rcases hx with \u27e8p, pC, hp\u27e9\n    rw [stackSize, Finset.sum_eq_single_of_mem p]; rotate_left\n    \u00b7 simp [pC]\n    \u00b7 intro b hb hbp\n      simp only [indicator_apply_eq_zero, Pi.one_apply, one_ne_zero, imp_false]\n      simp only [Finset.mem_filter, Finset.mem_univ, true_and] at hb\n      exact disjoint_left.1 (h pC hb hbp.symm) hp\n    simp [hp]\n  \u00b7 have : stackSize C x = 0 := by\n      apply Finset.sum_eq_zero (fun p hp \u21a6 ?_)\n      simp only [Finset.mem_filter, Finset.mem_univ, true_and, not_exists, not_and,\n        indicator_apply_eq_zero, Pi.one_apply, one_ne_zero, imp_false] at hp hx \u22a2\n      exact hx _ hp\n    linarith\n\n/-! ### Decomposing a set of tiles into disjoint subfamilies -/\n\n/-- Given any family of tiles, one can extract a maximal disjoint subfamily, covering everything. -/\nlemma exists_maximal_disjoint_covering_subfamily (A : Set (\ud835\udd13 X)) :\n    \u2203 (B : Set (\ud835\udd13 X)), B.PairwiseDisjoint (fun p \u21a6 (\ud835\udcd8 p : Set X)) \u2227\n      B \u2286 A \u2227 (\u2200 a \u2208 A, \u2203 b \u2208 B, (\ud835\udcd8 a : Set X) \u2286 \ud835\udcd8 b) := by\n  -- consider the pairwise disjoint families in `A` such that any element of `A` is disjoint from\n  -- every member of the family, or contained in one of them.\n  let M : Set (Set (\ud835\udd13 X)) := {B | B.PairwiseDisjoint (fun p \u21a6 (\ud835\udcd8 p : Set X)) \u2227 B \u2286 A \u2227 \u2200 a \u2208 A,\n    (\u2203 b \u2208 B, (\ud835\udcd8 a : Set X) \u2286 \ud835\udcd8 b) \u2228 (\u2200 b \u2208 B, Disjoint (\ud835\udcd8 a : Set X) (\ud835\udcd8 b))}\n  -- let `B` be a maximal such family. It satisfies the properties of the lemma.\n  obtain \u27e8B, BM, hB\u27e9 : \u2203 B \u2208 M, \u2200 B' \u2208 M, B \u2286 B' \u2192 B = B' :=\n    Finite.exists_maximal_wrt id _ (toFinite M) \u27e8\u2205, by simp [M]\u27e9\n  refine \u27e8B, BM.1, BM.2.1, fun a ha \u21a6 ?_\u27e9\n  rcases BM.2.2 a ha with h'a | h'a\n  \u00b7 exact h'a\n  exfalso\n  let F := {a' \u2208 A | (\ud835\udcd8 a : Set X) \u2286 \ud835\udcd8 a' \u2227 \u2200 b \u2208 B, Disjoint (\ud835\udcd8 a' : Set X) (\ud835\udcd8 b)}\n  obtain \u27e8a', a'F, ha'\u27e9 : \u2203 a' \u2208 F, \u2200 p \u2208 F, (\ud835\udcd8 a' : Set X) \u2286 \ud835\udcd8 p \u2192 (\ud835\udcd8 a' : Set X) = \ud835\udcd8 p := by\n    apply Finite.exists_maximal_wrt _ _ (toFinite F)\n    exact \u27e8a, by simpa [F, ha] using h'a\u27e9\n  have : insert a' B \u2208 M := by\n    refine \u27e8?_, ?_, fun p hp \u21a6 ?_\u27e9\n    \u00b7 apply PairwiseDisjoint.insert BM.1 (fun b hb h'b \u21a6 a'F.2.2 b hb)\n    \u00b7 apply insert_subset a'F.1 BM.2.1\n    rcases BM.2.2 p hp with \u27e8b, hb\u27e9 | h'p\n    \u00b7 exact Or.inl \u27e8b, mem_insert_of_mem _ hb.1, hb.2\u27e9\n    by_cases Hp : Disjoint (\ud835\udcd8 p : Set X) (\ud835\udcd8 a')\n    \u00b7 right\n      simpa [Hp] using h'p\n    refine Or.inl \u27e8a', mem_insert a' B, ?_\u27e9\n    rcases le_or_ge_or_disjoint (i := \ud835\udcd8 p) (j := \ud835\udcd8 a') with hij | hij |hij\n    \u00b7 exact (Grid.le_def.1 hij).1\n    \u00b7 have : p \u2208 F := \u27e8hp, a'F.2.1.trans (Grid.le_def.1 hij).1, h'p\u27e9\n      rw [ha' p this (Grid.le_def.1 hij).1]\n    \u00b7 exact (Hp hij).elim\n  have : B = insert a' B := hB _ this (subset_insert a' B)\n  have : a' \u2208 B := by rw [this]; exact mem_insert a' B\n  have : Disjoint (\ud835\udcd8 a' : Set X) (\ud835\udcd8 a' : Set X) := a'F.2.2 _ this\n  exact disjoint_left.1 this Grid.c_mem_Grid Grid.c_mem_Grid\n\n/-- A disjoint subfamily of `A` covering everything. -/\ndef maximalSubfamily (A : Set (\ud835\udd13 X)) : Set (\ud835\udd13 X) :=\n  (exists_maximal_disjoint_covering_subfamily A).choose\n\n/-- Iterating `maximalSubfamily` to obtain disjoint subfamilies of `A`. -/\ndef iteratedMaximalSubfamily (A : Set (\ud835\udd13 X)) (n : \u2115) : Set (\ud835\udd13 X) :=\n  maximalSubfamily (A \\ (\u22c3 (i : {i | i < n}), have : i < n := i.2; iteratedMaximalSubfamily A i))\n\nlemma pairwiseDisjoint_iteratedMaximalSubfamily_image (A : Set (\ud835\udd13 X)) (n : \u2115) :\n    (iteratedMaximalSubfamily A n).PairwiseDisjoint (fun p \u21a6 (\ud835\udcd8 p : Set X)) := by\n  rw [iteratedMaximalSubfamily]\n  exact (exists_maximal_disjoint_covering_subfamily (X := X) _).choose_spec.1\n\nlemma iteratedMaximalSubfamily_subset (A : Set (\ud835\udd13 X)) (n : \u2115) :\n    iteratedMaximalSubfamily A n \u2286 A := by\n  rw [iteratedMaximalSubfamily]\n  exact (exists_maximal_disjoint_covering_subfamily (X := X) _).choose_spec.2.1.trans diff_subset\n\nlemma pairwiseDisjoint_iteratedMaximalSubfamily (A : Set (\ud835\udd13 X)) :\n    univ.PairwiseDisjoint (iteratedMaximalSubfamily A) := by\n  intro m hm n hn hmn\n  wlog h'mn : m < n generalizing m n with H\n  \u00b7 exact (H (mem_univ n) (mem_univ m) hmn.symm (by omega)).symm\n  have : iteratedMaximalSubfamily A n\n      \u2286 A \\ \u22c3 (i : {i | i < n}), iteratedMaximalSubfamily A i := by\n    conv_lhs => rw [iteratedMaximalSubfamily]\n    apply (exists_maximal_disjoint_covering_subfamily _).choose_spec.2.1\n  apply subset_compl_iff_disjoint_left.1\n  rw [compl_eq_univ_diff]\n  apply this.trans\n  apply diff_subset_diff (subset_univ _)\n  apply subset_iUnion_of_subset \u27e8m, h'mn\u27e9\n  simp\n\n", "theoremStatement": "/-- Any set of tiles can be written as the union of disjoint subfamilies, their number being\ncontrolled by the maximal stack size. -/\nlemma eq_biUnion_iteratedMaximalSubfamily (A : Set (\ud835\udd13 X)) {N : \u2115} (hN : \u2200 x, stackSize A x \u2264 N) :\n    A = \u22c3 n < N, iteratedMaximalSubfamily A n ", "theoremName": "eq_biUnion_iteratedMaximalSubfamily", "fileCreated": {"commit": "b788b2495b5cc06cb8507186eee8b90405f8730a", "date": "2024-07-03"}, "theoremCreated": {"commit": "88d85ba29f717ee3bb9fbd37379a6fb77b57265f", "date": "2025-01-06"}, "file": "carleson/Carleson/TileStructure.lean", "module": "Carleson.TileStructure", "jsonFile": "Carleson.TileStructure.jsonl", "positionMetadata": {"lineInFile": 651, "tokenPositionInFile": 28070, "theoremPositionInFile": 89}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 14, "repositoryPremises": true, "numRepositoryPremises": 28, "numPremises": 279}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  apply Subset.antisymm; swap\n  \u00b7 simp [iUnion_subset_iff, iteratedMaximalSubfamily_subset]\n  -- we show that after `N` steps the maximal subfamilies cover everything. Otherwise, say some\n  -- `p` is left. Then `\ud835\udcd8 p` is contained in an element of each of the previous subfamilies.\n  -- This gives `N+1` different elements containing any element of `\ud835\udcd8 p`, a contradiction with\n  -- the maximal stack size.\n  intro p hp\n  contrapose! hN\n  simp only [mem_iUnion, exists_prop, not_exists, not_and] at hN\n  have E n (hn : n < N) : \u2203 u \u2208 iteratedMaximalSubfamily A n, (\ud835\udcd8 p : Set X) \u2286 (\ud835\udcd8 u : Set X) := by\n    rw [iteratedMaximalSubfamily]\n    apply (exists_maximal_disjoint_covering_subfamily _).choose_spec.2.2\n    simp only [coe_setOf, mem_setOf_eq, mem_diff, hp,\n      mem_iUnion, Subtype.exists, exists_prop, not_exists, not_and, true_and]\n    intro i hi\n    exact hN i (hi.trans hn)\n  choose! u hu h'u using E\n  obtain \u27e8x, hxp\u27e9 : \u2203 x, x \u2208 (\ud835\udcd8 p : Set X) := \u27e8_, Grid.c_mem_Grid\u27e9\n  use x\n  have : stackSize {q \u2208 A | q = p} x + stackSize {q \u2208 A | q \u2260 p} x = stackSize A x :=\n    stackSize_setOf_add_stackSize_setOf_not\n  have : 1 = stackSize {q \u2208 A | q = p} x := by\n    have : 1 = \u2211 q \u2208 {p}, (\ud835\udcd8 q : Set X).indicator 1 x := by simp [hxp]\n    rw [this]\n    congr\n    ext\n    simp (config := {contextual := true}) [hp]\n  have : \u2211 p \u2208 {p | p \u2208 u '' (Iio N)}, (\ud835\udcd8 p : Set X).indicator 1 x\n      \u2264 stackSize {q | q \u2208 A \u2227 q \u2260 p} x := by\n    apply Finset.sum_le_sum_of_subset\n    rintro p hp\n    simp only [mem_image, mem_Iio, Finset.mem_filter, Finset.mem_univ, true_and] at hp\n    rcases hp with \u27e8n, hn, rfl\u27e9\n    simp only [ne_eq, mem_setOf_eq, Finset.mem_filter,\n      Finset.mem_univ, iteratedMaximalSubfamily_subset _ _ (hu n hn), true_and]\n    rintro rfl\n    exact hN n hn (hu n hn)\n  have : \u2211 p \u2208 {p | p \u2208 u '' (Iio N)}, (\ud835\udcd8 p : Set X).indicator 1 x\n      = \u2211 p \u2208 {p | p \u2208 u '' (Iio N)}, 1 := by\n    apply Finset.sum_congr rfl (fun p hp \u21a6 ?_)\n    simp only [mem_image, mem_Iio, Finset.mem_filter, Finset.mem_univ, true_and] at hp\n    rcases hp with \u27e8n, hn, rfl\u27e9\n    have : x \u2208 (\ud835\udcd8 (u n) : Set X) := h'u n hn hxp\n    simp [this]\n  have : \u2211 p \u2208 {p | p \u2208 u '' (Iio N)}, 1 = N := by\n    have : Finset.filter (fun p \u21a6 p \u2208 u '' Iio N) Finset.univ = Finset.image u (Finset.Iio N) := by\n      ext p; simp\n    simp only [Finset.sum_const, smul_eq_mul, mul_one, this]\n    rw [Finset.card_image_of_injOn, Nat.card_Iio N]\n    intro a ha b hb hab\n    contrapose! hab\n    simp only [Finset.coe_Iio, mem_Iio] at ha hb\n    have := pairwiseDisjoint_iteratedMaximalSubfamily A (mem_univ a) (mem_univ b) hab\n    exact disjoint_iff_forall_ne.1 this (hu a ha) (hu b hb)\n  omega", "proofType": "tactic", "proofLengthLines": 55, "proofLengthTokens": 2652}}
{"srcContext": "import Carleson.Forest\nimport Carleson.ToMathlib.HardyLittlewood\nimport Carleson.ToMathlib.BoundedCompactSupport\nimport Carleson.ToMathlib.Misc\nimport Carleson.Psi\n\nopen ShortVariables TileStructure\nvariable {X : Type*} {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102} {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X}\n  [MetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] [TileStructure Q D \u03ba S o]\n  {n j j' : \u2115} {t : Forest X n} {u u\u2081 u\u2082 p : \ud835\udd13 X} {x x' : X} {\ud835\udd16 : Set (\ud835\udd13 X)}\n  {f f\u2081 f\u2082 g g\u2081 g\u2082 : X \u2192 \u2102} {I J J' L : Grid X}\nvariable {E' : Type*} [NormedAddCommGroup E'] [NormedSpace \u211d E']\n\nnoncomputable section\n\nopen Set MeasureTheory Metric Function Complex Bornology TileStructure Classical Filter\nopen scoped NNReal ENNReal ComplexConjugate\n\nnamespace TileStructure.Forest\n\n/-! ## Section 7.1 and Lemma 7.1.3 -/\n\nvariable (t) in\n/-- The definition `\u03c3(u, x)` given in Section 7.1.\nWe may assume `u \u2208 t` whenever proving things about this definition. -/\ndef \u03c3 (u : \ud835\udd13 X) (x : X) : Finset \u2124 := .image \ud835\udd30 { p | p \u2208 t u \u2227 x \u2208 E p }\n\nvariable (t) in\nprivate lemma exists_p_of_mem_\u03c3 (u : \ud835\udd13 X) (x : X) {s : \u2124} (hs : s \u2208 t.\u03c3 u x) :\n    \u2203 p \u2208 t.\ud835\udd17 u, x \u2208 E p \u2227 \ud835\udd30 p = s := by\n  have \u27e8p, hp\u27e9 := Finset.mem_image.mp hs\n  simp only [mem_\ud835\udd17, Finset.mem_filter] at hp\n  use p, hp.1.2.1, hp.1.2.2, hp.2\n\n/- \\overline{\u03c3} from the blueprint. -/\nvariable (t) in\ndef \u03c3Max (u : \ud835\udd13 X) (x : X) (h\u03c3 : (t.\u03c3 u x).Nonempty) : \u2124 :=\n  t.\u03c3 u x |>.max' h\u03c3\n\n/- \\underline{\u03c3} from the blueprint. -/\nvariable (t) in\ndef \u03c3Min (u : \ud835\udd13 X) (x : X) (h\u03c3 : (t.\u03c3 u x).Nonempty) : \u2124 :=\n  t.\u03c3 u x |>.min' h\u03c3\n\nvariable (t) in\nprivate lemma \u03c3Max_mem_\u03c3 (u : \ud835\udd13 X) (x : X) (h\u03c3 : (t.\u03c3 u x).Nonempty) : \u03c3Max t u x h\u03c3 \u2208 t.\u03c3 u x :=\n  (t.\u03c3 u x).max'_mem h\u03c3\n\n/-- The definition of `\ud835\udcd9\u2080(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcd9\u2080 (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {J : Grid X | s J = -S \u2228 \u2200 p \u2208 \ud835\udd16, \u00ac(\ud835\udcd8 p : Set X) \u2286 ball (c J) (100 * D ^ (s J + 1))}\n\n/-- The definition of `\ud835\udcd9(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcd9 (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {x | Maximal (\u00b7 \u2208 \ud835\udcd9\u2080 \ud835\udd16) x}\n\nlemma \ud835\udcd9_subset_\ud835\udcd9\u2080 {\ud835\udd16 : Set (\ud835\udd13 X)} : \ud835\udcd9 \ud835\udd16 \u2286 \ud835\udcd9\u2080 \ud835\udd16 := sep_subset ..\n\nlemma pairwiseDisjoint_\ud835\udcd9 : (\ud835\udcd9 \ud835\udd16).PairwiseDisjoint (fun I \u21a6 (I : Set X)) := fun I mI J mJ hn \u21a6 by\n  have : IsAntichain (\u00b7 \u2264 \u00b7) (\ud835\udcd9 \ud835\udd16) := setOf_maximal_antichain _\n  exact (le_or_ge_or_disjoint.resolve_left (this mI mJ hn)).resolve_left (this mJ mI hn.symm)\n\n/-- The definition of `\ud835\udcdb\u2080(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcdb\u2080 (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {L : Grid X | s L = -S \u2228 (\u2203 p \u2208 \ud835\udd16, L \u2264 \ud835\udcd8 p) \u2227 \u2200 p \u2208 \ud835\udd16, \u00ac\ud835\udcd8 p \u2264 L}\n\n/-- The definition of `\ud835\udcdb(\ud835\udd16), defined above Lemma 7.1.2 -/\ndef \ud835\udcdb (\ud835\udd16 : Set (\ud835\udd13 X)) : Set (Grid X) :=\n  {x | Maximal (\u00b7 \u2208 \ud835\udcdb\u2080 \ud835\udd16) x}\n\nlemma \ud835\udcdb_subset_\ud835\udcdb\u2080 {\ud835\udd16 : Set (\ud835\udd13 X)} : \ud835\udcdb \ud835\udd16 \u2286 \ud835\udcdb\u2080 \ud835\udd16 := sep_subset ..\n\n", "theoremStatement": "private lemma s_le_s_of_mem_\ud835\udcdb {\ud835\udd16 : Set (\ud835\udd13 X)} {L : Grid X} (hL : L \u2208 \ud835\udcdb \ud835\udd16)\n    {p : \ud835\udd13 X} (hp : p \u2208 \ud835\udd16) (hpL : \u00ac Disjoint (\ud835\udcd8 p : Set X) (L : Set X)) : s L \u2264 s (\ud835\udcd8 p) ", "theoremName": "TileStructure.Forest.s_le_s_of_mem_\ud835\udcdb", "fileCreated": {"commit": "5e49c3692f6d7344434caa7eea5f412f0ee35863", "date": "2024-09-27"}, "theoremCreated": {"commit": "3298f748e9eb26a242da5ee38cb50dc55e604935", "date": "2025-01-08"}, "file": "carleson/Carleson/ForestOperator/PointwiseEstimate.lean", "module": "Carleson.ForestOperator.PointwiseEstimate", "jsonFile": "Carleson.ForestOperator.PointwiseEstimate.jsonl", "positionMetadata": {"lineInFile": 73, "tokenPositionInFile": 2654, "theoremPositionInFile": 12}, "dependencyMetadata": {"inFilePremises": null, "numInFilePremises": null, "repositoryPremises": null, "numRepositoryPremises": null, "numPremises": null}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp only [\ud835\udcdb, \ud835\udcdb\u2080, Grid.le_def, not_and, not_le, and_imp] at hL\n  rcases hL.1 with h | h\n  \u00b7 exact h \u25b8 (range_s_subset \u27e8\ud835\udcd8 p, rfl\u27e9).1\n  \u00b7 by_contra!\n    exact lt_asymm this <| h.2 p hp <| (GridStructure.fundamental_dyadic' this.le).resolve_right hpL", "proofType": "tactic", "proofLengthLines": 5, "proofLengthTokens": 255}}
{"srcContext": "import Carleson.ForestOperator.PointwiseEstimate\nimport Carleson.ToMathlib.Misc\nimport Carleson.ToMathlib.ENorm\nimport Carleson.ToMathlib.Annulus\n\nnoncomputable section\n\nopen Set MeasureTheory Metric Function Complex Bornology TileStructure Classical Filter\nopen scoped NNReal ENNReal ComplexConjugate\n\nopen ShortVariables\nvariable {X : Type*} {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102} {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X}\n  [MetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] {f : X \u2192 \u2102}\n\nlemma integrableOn_K_mul_f (x' : X) (hf : BoundedCompactSupport f) (r : \u211d\u22650\u221e) (hr : 0 < r) :\n    IntegrableOn (fun y \u21a6 K x' y * f y) (EAnnulus.ci x' r) := by\n  by_cases supp_f : (support f).Nonempty; swap\n  \u00b7 simp [Function.support_eq_empty_iff.mp <| Set.not_nonempty_iff_eq_empty.mp supp_f]\n  by_cases r_top : r = \u22a4\n  \u00b7 simp [r_top]\n  have \u27e8x'', hx''\u27e9 := supp_f\n  have \u27e8C, hC\u27e9 := Metric.isBounded_iff.mp hf.isBoundedSupport\n  have : support (fun y \u21a6 f y * K x' y) \u2286 closedBall x' (dist x' x'' + C) := by\n    intro y hy\n    have : y \u2208 support f := by contrapose! hy; simp [hy]\n    exact mem_closedBall'.mp <| (dist_triangle x' x'' y).trans <| add_le_add_left (hC hx'' this) _\n  simp_rw [mul_comm (K x' _), IntegrableOn, \u2190 integrableOn_iff_integrable_of_support_subset this]\n  apply hf.integrable_mul\n  rw [Measure.restrict_restrict measurableSet_closedBall, inter_comm, \u2190 IntegrableOn]\n  convert integrableOn_K_Icc (K := K) (R := dist x' x'' + C) (r.toReal_pos hr.ne.symm r_top) using 1\n  ext y\n  simp [edist_dist, dist_comm y, EAnnulus.ci, ENNReal.le_ofReal_iff_toReal_le r_top dist_nonneg]\n\n\n-- Truncated version of `K` used in proof of `nontangential_pointwise_bound`\nprivate def K' (b : \u2124) (c : \u2124) (x y : X) := \u2211 i \u2208 (Icc b c).toFinset, Ks i x y\n\nnamespace K'\n\nprivate lemma eq_K (b : \u2124) (c : \u2124) (x y : X)\n    (h : dist x y \u2208 Icc ((D : \u211d) ^ (b - 1) / 2) (D ^ c / 4)) : K' b c x y = K x y := by\n  have hxy : dist x y > 0 := lt_of_lt_of_le (div_pos (defaultD_pow_pos a (b - 1)) two_pos) h.1\n  simp_rw [K', Ks, \u2190 Finset.mul_sum, \u2190 Complex.ofReal_sum]\n  rw [\u2190 finsum_eq_sum_of_support_subset, finsum_\u03c8 (one_lt_D (X := X)) hxy, ofReal_one, mul_one]\n  rw [toFinset_Icc, Finset.coe_Icc]\n  exact support_\u03c8S_subset_Icc (one_lt_D (X := X)) h\n\nprivate lemma integrableOn_mul_f (x' : X) (hf : BoundedCompactSupport f) (r : \u211d\u22650\u221e) (hr : 0 < r)\n    (s\u2081 s\u2082 : \u2124) : IntegrableOn (fun y \u21a6 K' s\u2081 s\u2082 x' y * f y) (EAnnulus.ci x' r) := by\n  simp_rw [K', Ks, mul_comm (K x' _) (\u03c8 _), \u2190 Finset.sum_mul, mul_assoc]\n  apply Integrable.bdd_mul (integrableOn_K_mul_f x' hf r hr)\n  \u00b7 refine (Finset.aestronglyMeasurable_sum _ (fun i hi \u21a6 ?_)).restrict\n    apply continuous_ofReal.comp_aestronglyMeasurable \u2218 continuous_\u03c8.comp_aestronglyMeasurable\n    exact (continuous_const.dist continuous_id').aestronglyMeasurable.const_mul _\n  \u00b7 refine \u27e8(s\u2082 + 1 - s\u2081).toNat, fun _ \u21a6 le_trans (norm_sum_le ..) ?_\u27e9\n    simp_rw [norm_eq_abs, abs_ofReal]\n    exact le_of_le_of_eq (Finset.sum_le_sum fun _ _ \u21a6 abs_\u03c8_le_one _ _) (by simp)\n\nprivate lemma support_subset (b : \u2124) (c : \u2124) (x : X) :\n    support (K' b c x) \u2286 Annulus.cc x (D ^ (b - 1) / 4) (D ^ c / 2) := by\n  refine subset_trans ?_ (Annulus.oo_subset_cc (le_refl _) (le_refl _))\n  intro y hy\n  rw [mem_support] at hy\n  simp only [Annulus.oo, mem_Ioo, mem_setOf_eq]\n  contrapose! hy\n  refine Finset.sum_eq_zero (fun s hs \u21a6 ?_)\n  rw [toFinset_Icc] at hs\n  suffices ((D : \u211d) ^ s)\u207b\u00b9 * dist x y \u2209 support \u03c8 by simp [Ks, nmem_support.mp this, -defaultD]\n  rw [support_\u03c8 (one_lt_D (X := X)), mem_Ioo, not_and_or]\n  by_cases h : (D : \u211d) ^ (b - 1) / 4 < dist x y\n  \u00b7 exact Or.inr <| not_lt_of_ge <| calc\n      _ \u2265 ((D : \u211d) ^ c)\u207b\u00b9 * (D ^ c / 2) := by\n        gcongr\n        \u00b7 exact defaultD_pow_pos a s\n        \u00b7 exact one_le_D\n        \u00b7 exact (Finset.mem_Icc.mp hs).2\n        \u00b7 exact hy h\n      _ = 2\u207b\u00b9 := by field_simp\n  \u00b7 push_neg at h\n    exact Or.inl <| not_lt_of_ge <| calc\n      ((D : \u211d) ^ s)\u207b\u00b9 * dist x y \u2264 ((D : \u211d) ^ b)\u207b\u00b9 * (D ^ (b - 1) / 4) := by\n                                 refine mul_le_mul ?_ h dist_nonneg ?_\n                                 \u00b7 apply inv_anti\u2080 (defaultD_pow_pos a b)\n                                   exact zpow_right_mono\u2080 one_le_D (Finset.mem_Icc.mp hs).1\n                                 \u00b7 exact inv_nonneg.mpr (defaultD_pow_pos a b).le\n      _                          = (4 * (D : \u211d))\u207b\u00b9 := by\n                                 rw [zpow_sub\u2080 (defaultD_pos a).ne.symm]; field_simp; apply mul_comm\n\nprivate lemma enorm_le_enorm_K (a : \u2124) (b : \u2124) (x y : X) : \u2016K' a b x y\u2016\u2091 \u2264 \u2016K x y\u2016\u2091 := by\n  unfold K' Ks\n  by_cases hxy : 0 = dist x y\n  \u00b7 simp [\u2190 hxy, psi_zero]\n  rw [\u2190 mul_one \u2016K x y\u2016\u2091, \u2190 Finset.mul_sum, enorm_mul]\n  apply mul_le_mul_left'\n  rw [enorm_eq_nnnorm]\n  norm_cast\n  apply le_trans <| nnnorm_sum_le _ _\n  simp_rw [\u2190 norm_toNNReal, Real.norm_eq_abs, \u2190 Real.toNNReal_sum_of_nonneg fun _ _ \u21a6 abs_nonneg _,\n    Real.toNNReal_le_one, abs_eq_self.mpr <| zero_le_\u03c8 _ _]\n  exact sum_\u03c8_le (one_lt_D (X := X)) _ <| lt_of_le_of_ne dist_nonneg hxy\n\nend K'\n\n-- Bound needed for proof of `nontangential_pointwise_bound`, splitting the annulus between radii\n-- `r\u2081` and `r\u2084` into annuli between `r\u2081` and `r\u2082`, between `r\u2082` and `r\u2083`, and between `r\u2083` and\n-- `r\u2084`. Note that we assume only `r\u2081 \u2264 r\u2082` and `r\u2083 \u2264 r\u2084`.\nprivate lemma annulus_integral_bound (x : X) (g : X \u2192 \u2102) {r\u2081 r\u2082 r\u2083 r\u2084 : \u211d} (h\u2081\u2082 : r\u2081 \u2264 r\u2082)\n    (h\u2083\u2084 : r\u2083 \u2264 r\u2084) (hg : IntegrableOn g (Annulus.cc x r\u2081 r\u2084)) :\n    \u2016\u222b y in Annulus.cc x r\u2081 r\u2084, g y\u2016\u2091 \u2264 \u2016\u222b y in Annulus.oo x r\u2082 r\u2083, g y\u2016\u2091 +\n    ((\u222b\u207b y in Annulus.cc x r\u2081 r\u2082, \u2016g y\u2016\u2091) + \u222b\u207b y in Annulus.cc x r\u2083 r\u2084, \u2016g y\u2016\u2091) := calc\n  _ = \u2016(\u222b y in Annulus.cc x r\u2081 r\u2084 \u2229 Annulus.oo x r\u2082 r\u2083, g y) +\n        \u222b y in Annulus.cc x r\u2081 r\u2084 \u2229 (Annulus.oo x r\u2082 r\u2083)\u1d9c, g y\u2016\u2091 := by\n    apply congrArg (\u2016\u00b7\u2016\u2091)\n    rw [\u2190 setIntegral_union (Set.disjoint_left.mpr (fun _ h\u2081 h\u2082 \u21a6 h\u2082.2 h\u2081.2)) (by measurability),\n        inter_union_compl] <;>\n      exact hg.mono_set inter_subset_left\n  _ \u2264 \u2016\u222b y in Annulus.cc x r\u2081 r\u2084 \u2229 Annulus.oo x r\u2082 r\u2083, g y\u2016\u2091 +\n        \u2016\u222b y in Annulus.cc x r\u2081 r\u2084 \u2229 (Annulus.oo x r\u2082 r\u2083)\u1d9c, g y\u2016\u2091 := by apply ENormedAddMonoid.enorm_add_le\n  _ \u2264 _ := by\n    gcongr\n    \u00b7 rw [inter_eq_self_of_subset_right <| Annulus.oo_subset_cc h\u2081\u2082 h\u2083\u2084]\n    \u00b7 calc\n        _ \u2264 _ := enorm_integral_le_lintegral_enorm _\n        _ \u2264 \u222b\u207b y in Annulus.cc x r\u2081 r\u2082 \u222a Annulus.cc x r\u2083 r\u2084, \u2016g y\u2016\u2091 := by\n          refine lintegral_mono_set (fun y \u21a6 ?_)\n          simp only [Annulus.oo, Annulus.cc, edist_dist, mem_Ioo, mem_Icc, mem_inter_iff,\n            mem_setOf_eq, mem_compl_iff, not_and, not_le, mem_union, and_imp]\n          intro hr\u2081 hr\u2084 hr\u2082\u2083\n          by_cases hr\u2082 : r\u2082 < dist x y\n          \u00b7 exact Or.inr \u27e8le_of_not_gt (hr\u2082\u2083 hr\u2082), hr\u2084\u27e9\n          \u00b7 exact Or.inl \u27e8hr\u2081, le_of_not_gt hr\u2082\u27e9\n        _ \u2264 _ := lintegral_union_le _ _ _\n\nlemma CMB_defaultA_two_eq {a : \u2115} : CMB (defaultA a) 2 = 2 ^ (a + (3 / 2 : \u211d)) := by\n  suffices (2 : \u211d\u22650) * 2 ^ (2 : \u211d)\u207b\u00b9 * (ENNReal.ofReal |2 - 1|\u207b\u00b9).toNNReal ^ (2 : \u211d)\u207b\u00b9 *\n      ((2 ^ a) ^ (2 : \u211d)) ^ (2 : \u211d)\u207b\u00b9 = 2 ^ (a + 3 / (2 : \u211d)) by\n    simpa [CMB, C_realInterpolation, C_realInterpolation_ENNReal]\n  rw [\u2190 NNReal.rpow_mul, show (3 / 2 : \u211d) = 1 + (1 / 2 : \u211d) by norm_num]\n  repeat rw [NNReal.rpow_add two_ne_zero]\n  norm_num\n  ring\n\nopen ShortVariables TileStructure\nvariable {X : Type*} {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102} {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X}\n  [MetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] [TileStructure Q D \u03ba S o]\n  {n j j' : \u2115} {t : Forest X n} {u u\u2081 u\u2082 p : \ud835\udd13 X} {x x' : X} {\ud835\udd16 : Set (\ud835\udd13 X)}\n  {f f\u2081 f\u2082 g g\u2081 g\u2082 : X \u2192 \u2102} {I J J' L : Grid X}\nvariable {E' : Type*} [NormedAddCommGroup E'] [NormedSpace \u211d E']\n\nnamespace TileStructure.Forest\n\nlemma eLpNorm_MB_le {\ud835\udd5c : Type*} [RCLike \ud835\udd5c] {f : X \u2192 \ud835\udd5c} (hf : BoundedCompactSupport f) :\n    eLpNorm (MB volume \ud835\udcd1 c\ud835\udcd1 r\ud835\udcd1 f \u00b7) 2 volume \u2264 CMB (defaultA a : \u211d\u22650) 2 * eLpNorm f 2 volume :=\n  hasStrongType_MB_finite \ud835\udcd1_finite one_lt_two f (hf.mem\u2112p 2) |>.2\n\n/-! ## Section 7.2 and Lemma 7.2.1 -/\n\n/-- The constant used in `nontangential_operator_bound`.\nPreviously had value `2 ^ (103 * a ^ 3)` in the blueprint. -/\n-- Todo: define this recursively in terms of previous constants\nirreducible_def C7_2_2 (a : \u2115) : \u211d\u22650 := 2 ^ (102 * (a : \u211d) ^ 3)\n\n-- Bound for (7.2.3) in the proof of `nontangential_pointwise_bound`\nomit [TileStructure Q D \u03ba S o] in\nprivate lemma nontangential_integral_bound\u2081 {x x' : X} {r : \u211d} (R : \u211d) (hr : dist x x' < r) :\n    \u2016\u222b y in Annulus.oo x' r R, K x' y * f y\u2016\u2091 \u2264 nontangentialOperator K f x := by\n  by_cases r_lt_R : r < R; swap\n  \u00b7 simp [-defaultD, Annulus.oo_eq_empty (le_of_not_gt r_lt_R)]\n  refine le_trans ?_ <| le_iSup _ r\n  refine le_trans ?_ <| le_iSup _ R\n  rw [iSup_pos r_lt_R]\n  refine le_of_eq_of_le ?_ <| le_iSup _ x'\n  rw [iSup_pos hr, Annulus.oo, enorm_eq_nnnorm]\n\n-- Bound for (7.2.4) and (7.2.5) in the proof of `nontangential_pointwise_bound`\nprivate lemma nontangential_integral_bound\u2082 (hf : BoundedCompactSupport f) {x x' : X}\n    {I : Grid X} (hx : x \u2208 I) (hx' : x' \u2208 I) {R : \u211d} (h : R \u2264 8 * D ^ (s I)) :\n    \u222b\u207b y in Annulus.cc x' ((D : \u211d) ^ (s I - 1) / 4) R, \u2016K x' y * f y\u2016\u2091 \u2264\n    2 ^ (7 * (a : \u211d) + 101 * a ^ 3) * MB volume \ud835\udcd1 c\ud835\udcd1 r\ud835\udcd1 f x := by\n  apply (lintegral_mono_set (Annulus.cc_subset_cc (le_refl _) h)).trans\n  have ineq : \u2200 y \u2208 Annulus.cc x' ((D : \u211d) ^ (s I - 1) / 4) (8 * D ^ (s I)), \u2016K x' y * f y\u2016\u2091 \u2264\n      2 ^ (7 * (a : \u211d) + 101 * a ^ 3) / volume (ball (c I) (16 * D ^ (s I))) * \u2016f y\u2016\u2091 := by\n    intro y hy\n    rw [Annulus.cc] at hy\n    rw [enorm_mul]\n    refine mul_le_mul_right' ((ennnorm_K_le 5 hy.1).trans ?_) \u2016f y\u2016\u2091\n    gcongr\n    \u00b7 norm_num\n    \u00b7 norm_num\n    \u00b7 suffices dist (c I) x' < 16 * D ^ (s I) from ball_subset_ball' (by linarith)\n      rw [\u2190 mem_ball', s]\n      refine ball_subset_ball ?_ (Grid_subset_ball hx')\n      linarith [defaultD_pow_pos a (GridStructure.s I)]\n  apply le_trans <| setLIntegral_mono (hf.stronglyMeasurable.measurable.enorm.const_mul _) ineq\n  simp_rw [ENNReal.mul_comm_div, div_eq_mul_inv]\n  have := hf.stronglyMeasurable.measurable.enorm\n  rw [lintegral_const_mul _ (this.mul_const _), lintegral_mul_const _ this, \u2190 div_eq_mul_inv]\n  apply mul_left_mono\n  calc\n    _ \u2264 (\u222b\u207b y in ball (c I) (16 * D ^ s I), \u2016f y\u2016\u2091) / volume (ball (c I) (16 * D ^ s I)) := by\n      gcongr\n      refine lintegral_mono' (Measure.le_iff.mpr (fun T hT \u21a6  ?_)) (le_refl _)\n      rw [Measure.restrict_apply hT, Measure.restrict_apply hT]\n      refine measure_mono (inter_subset_inter_right T (fun y \u21a6 ?_))\n      simp only [Annulus.cc, mem_Icc, mem_setOf_eq, mem_ball, and_imp, dist_comm x']\n      intro _ h\n      calc dist y (c I)\n        _ \u2264 dist y x' + dist x' (c I) := dist_triangle y x' (c I)\n        _ \u2264 8 * (D : \u211d) ^ s I + 4 * (D : \u211d) ^ s I :=\n          add_le_add h (mem_ball.mp (Grid_subset_ball hx')).le\n        _ < 16 * (D : \u211d) ^ s I := by linarith [defaultD_pow_pos a (s I)]\n    _ = \u2a0d\u207b y in ball (c I) (16 * D ^ s I), \u2016f y\u2016\u2091 \u2202volume := by rw [setLaverage_eq]\n    _ \u2264 MB volume \ud835\udcd1 c\ud835\udcd1 r\ud835\udcd1 f x := by\n      rw [MB, maximalFunction, inv_one, ENNReal.rpow_one]\n      have : \u27e84, I\u27e9 \u2208 \ud835\udcd1 := by simp [\ud835\udcd1]\n      refine le_of_eq_of_le ?_ (le_biSup _ this)\n      have : x \u2208 ball (c I) (2 ^ 4 * (D : \u211d) ^ s I) := by\n        refine (ball_subset_ball ?_) (Grid_subset_ball hx)\n        unfold s\n        linarith [defaultD_pow_pos a (GridStructure.s I)]\n      simp_rw [c\ud835\udcd1, r\ud835\udcd1, ENNReal.rpow_one, indicator_of_mem this, enorm_eq_nnnorm]\n      norm_num\n\n-- Pointwise bound needed for Lemma 7.2.2\nprivate lemma nontangential_pointwise_bound (hf : BoundedCompactSupport f) (\u03b8 : \u0398 X) (x : X) :\n    nontangentialMaximalFunction \u03b8 f x \u2264 nontangentialOperator K f x +\n      2 ^ (1 + 7 * (a : \u211d) + 101 * a ^ 3) * MB volume \ud835\udcd1 c\ud835\udcd1 r\ud835\udcd1 f x := by\n  refine iSup\u2082_le fun I hI \u21a6 iSup\u2082_le fun x' hx' \u21a6 iSup\u2082_le fun s\u2082 hs\u2082 \u21a6 iSup_le fun _ \u21a6 ?_\n  rw [\u2190 enorm_eq_nnnorm, \u2190 integral_finset_sum]; swap\n  \u00b7 intro i hi\n    simp_rw [mul_comm]\n    exact hf.integrable_mul (integrable_Ks_x <| one_lt_D (X := X))\n  simp_rw [\u2190 Finset.sum_mul]\n  have ineq {n : \u2115} (hn : n > 0) : (D : \u211d) ^ (s I - 1) / n < 8 * D ^ s I := by\n    rw [zpow_sub\u2080 (defaultD_pos a).ne.symm, div_div, zpow_one]\n    calc (D : \u211d) ^ s I / ((D : \u211d) * n)\n      _ \u2264 D ^ s I / 1 := by gcongr; exact_mod_cast (mul_pos (defaultD_pos' a) hn)\n      _ < 8 * D ^ s I := by linarith [defaultD_pow_pos a (s I)]\n  calc\n    _ = \u2016\u222b y in Annulus.cc x' (D ^ (s I - 1) / 4) (D ^ s\u2082 / 2), K' (s I) s\u2082 x' y * f y\u2016\u2091 := by\n      rw [\u2190 integral_indicator Annulus.measurableSet_cc]\n      congr\n      ext y\n      by_cases hy : y \u2208 Annulus.cc x' (D ^ (s I - 1) / 4) (D ^ s\u2082 / 2)\n      \u00b7 simp only [K', hy, indicator_of_mem]\n      \u00b7 have K'_eq_zero := nmem_support.mp <| not_mem_subset (K'.support_subset (s I) s\u2082 x') hy\n        rw [\u2190 K', K'_eq_zero, zero_mul, indicator_of_not_mem hy]\n    _ \u2264 \u2016\u222b y in Annulus.oo x' (8 * D ^ (s I)) (D ^ (s\u2082 - 1) / 4), K' (s I) s\u2082 x' y * f y\u2016\u2091 +\n          ((\u222b\u207b y in Annulus.cc x' (D ^ (s I - 1) / 4) (8 * D ^ (s I)), \u2016K' (s I) s\u2082 x' y * f y\u2016\u2091) +\n          \u222b\u207b y in Annulus.cc x' (D ^ (s\u2082 - 1) / 4) (D ^ s\u2082 / 2), \u2016K' (s I) s\u2082 x' y * f y\u2016\u2091) := by\n      apply annulus_integral_bound\n      \u00b7 exact (ineq four_pos).le\n      \u00b7 gcongr\n        \u00b7 exact one_lt_D (X := X) |>.le\n        \u00b7 exact sub_one_lt s\u2082 |>.le\n        \u00b7 norm_num\n      \u00b7 refine K'.integrableOn_mul_f x' hf (ENNReal.ofReal (D ^ (s I - 1) / 4)) ?_ (s I) s\u2082\n          |>.mono_set ?_\n        \u00b7 exact ENNReal.ofReal_pos.mpr <| div_pos (defaultD_pow_pos a (s I - 1)) four_pos\n        \u00b7 rw [EAnnulus.ci_eq_annulus]\n          exact Annulus.cc_subset_ci (le_refl _)\n    _ \u2264 \u2016\u222b y in Annulus.oo x' (8 * D ^ (s I)) (D ^ (s\u2082 - 1) / 4), K x' y * f y\u2016\u2091 +\n          ((\u222b\u207b y in Annulus.cc x' (D ^ (s I - 1) / 4) (8 * D ^ (s I)), \u2016K x' y * f y\u2016\u2091) +\n          \u222b\u207b y in Annulus.cc x' (D ^ (s\u2082 - 1) / 4) (D ^ s\u2082 / 2), \u2016K x' y * f y\u2016\u2091) := by\n      have norm_K'_f_le : \u2200 (y : X), \u2016K' (s I) s\u2082 x' y * f y\u2016\u2091 \u2264 \u2016K x' y * f y\u2016\u2091 := by\n        simp_rw [enorm_mul]\n        exact fun y \u21a6 mul_le_mul_of_nonneg_right (K'.enorm_le_enorm_K _ _ _ _) (zero_le _)\n      gcongr\n      \u00b7 refine (congrArg (\u2016\u00b7\u2016\u2091) <| setIntegral_congr_fun Annulus.measurableSet_oo fun y hy \u21a6 ?_).le\n        apply mul_eq_mul_right_iff.mpr \u2218 Or.inl \u2218 K'.eq_K (s I) s\u2082 x' y\n        simp only [Annulus.oo, mem_Ioo, mem_setOf_eq] at hy\n        have i1 := hy.1\n        have i2 := hy.2.le\n        refine mem_Icc.mpr \u27e8(lt_trans (ineq two_pos) i1).le, i2.trans ?_\u27e9\n        rw [zpow_sub\u2080 (defaultD_pos a).ne.symm, div_div, zpow_one]\n        have : (D : \u211d) * 4 > 0 := mul_pos (defaultD_pos a) four_pos\n        apply (div_le_div_iff_of_pos_left (defaultD_pow_pos a s\u2082) this four_pos).mpr\n        norm_cast\n        linarith [defaultD_pos' a]\n      \u00b7 exact norm_K'_f_le _\n      \u00b7 exact norm_K'_f_le _\n    _ \u2264 nontangentialOperator K f x + (2 ^ (7 * (a : \u211d) + 101 * a ^ 3) * MB volume \ud835\udcd1 c\ud835\udcd1 r\ud835\udcd1 f x +\n          2 ^ (7 * (a : \u211d) + 101 * a ^ 3) * MB volume \ud835\udcd1 c\ud835\udcd1 r\ud835\udcd1 f x) := by\n      gcongr\n      \u00b7 apply nontangential_integral_bound\u2081 (D ^ (s\u2082 - 1) / 4)\n        apply lt_of_le_of_lt (dist_triangle x (c I) x')\n        replace hI := mem_ball.mp (Grid_subset_ball hI)\n        replace hx' := mem_ball'.mp (Grid_subset_ball hx')\n        apply lt_of_lt_of_eq (add_lt_add hI hx')\n        unfold s\n        ring\n      \u00b7 exact nontangential_integral_bound\u2082 hf hI hx' (le_refl _)\n      \u00b7 let I\u2082 := cubeOf s\u2082 x\n        have hs\u2082' : s\u2082 \u2208 Icc (-(S : \u2124)) (S : \u2124) :=\n          Icc_subset_Icc (Set.range_subset_iff.mp range_s_subset I |>.1) (le_refl (S : \u2124)) hs\u2082\n        have \u27e8xI\u2082, hI\u2082\u27e9 := cubeOf_spec hs\u2082' I hI\n        rw [\u2190 hI\u2082]\n        have : s I \u2264 s I\u2082 := by rw [hI\u2082]; exact hs\u2082.1\n        have := (fundamental_dyadic this).resolve_right (Set.not_disjoint_iff.mpr \u27e8x, \u27e8hI, xI\u2082\u27e9\u27e9)\n        apply nontangential_integral_bound\u2082 hf xI\u2082 (this hx')\n        linarith [defaultD_pow_pos a (s (cubeOf s\u2082 x))]\n    _ = _ := by\n      rw [\u2190 two_mul, \u2190 mul_assoc, add_assoc, ENNReal.rpow_add 1 _ two_ne_zero ENNReal.ofNat_ne_top,\n        ENNReal.rpow_one]\n\n/-- Lemma 7.2.2. -/\nlemma nontangential_operator_bound\n    (hf : BoundedCompactSupport f)\n    (\u03b8 : \u0398 X) :\n    eLpNorm (nontangentialMaximalFunction \u03b8 f \u00b7) 2 volume \u2264 (C7_2_2 a) * eLpNorm f 2 volume := by\n  have ha : 4 \u2264 (a : \u211d) := by exact_mod_cast four_le_a X\n  have aemeas_MB : AEMeasurable (MB volume \ud835\udcd1 c\ud835\udcd1 r\ud835\udcd1 f \u00b7) :=\n    (AEStronglyMeasurable.maximalFunction (to_countable \ud835\udcd1)).aemeasurable\n  have \u27e8hT\u2081, hT\u2082\u27e9 := hasBoundedStrongType_Tstar f (hf.mem\u2112p 2) hf.mem\u2112p_top.eLpNorm_lt_top\n    hf.isBoundedSupport.measure_lt_top\n  calc eLpNorm (nontangentialMaximalFunction \u03b8 f) 2 volume\n    _ \u2264 eLpNorm (fun x \u21a6 nontangentialOperator K f x +\n          2 ^ (1 + 7 * (a : \u211d) + 101 * a ^ 3) * MB volume \ud835\udcd1 c\ud835\udcd1 r\ud835\udcd1 f x) 2 volume := by\n      simp only [eLpNorm, OfNat.ofNat_ne_zero, reduceIte, ENNReal.ofNat_ne_top, eLpNorm']\n      gcongr\n      exact nontangential_pointwise_bound hf \u03b8 _\n    _ \u2264 eLpNorm (nontangentialOperator K f) 2 volume +\n          eLpNorm ((2 : \u211d\u22650\u221e) ^ (1 + 7 * (a : \u211d) + 101 * a ^ 3) *\n          MB volume \ud835\udcd1 c\ud835\udcd1 r\ud835\udcd1 f \u00b7) 2 volume := by\n      simpa [eLpNorm, eLpNorm'] using\n        ENNReal.lintegral_Lp_add_le hT\u2081.aemeasurable (aemeas_MB.const_mul _) one_le_two\n    _ = eLpNorm (nontangentialOperator K f) 2 volume +\n          2 ^ (1 + 7 * (a : \u211d) + 101 * a ^ 3) * eLpNorm (MB volume \ud835\udcd1 c\ud835\udcd1 r\ud835\udcd1 f \u00b7) 2 volume := by\n      congr\n      simp only [eLpNorm, eLpNorm', OfNat.ofNat_ne_zero, reduceIte, ENNReal.ofNat_ne_top]\n      convert ENNReal.lintegral_Lp_smul aemeas_MB two_pos ((2 : \u211d\u22650) ^ (1 + 7 * a + 101 * a ^ 3))\n      \u00b7 congr; norm_cast\n      \u00b7 ext; rw [ENNReal.smul_def]; norm_cast\n    _ \u2264 (C_Ts a + 2 ^ (1 + 7 * a + 101 * a ^ 3 : \u211d) * CMB (defaultA a) 2) * eLpNorm f 2 volume := by\n      rw [add_mul, mul_assoc]; gcongr; exact eLpNorm_MB_le hf\n    _ \u2264 ((2 ^ a ^ 3) + 2 ^ (1 + 7 * a + 101 * a ^ 3) * (2 ^ (2 * a))) * eLpNorm f 2 volume := by\n      rw [C_Ts, CMB_defaultA_two_eq]\n      gcongr <;> norm_cast\n      simp only [Nat.cast_pow, Nat.cast_ofNat, \u2190 NNReal.rpow_natCast]\n      apply NNReal.rpow_le_rpow_of_exponent_le one_le_two\n      rw [Nat.cast_mul]\n      linarith\n    _ \u2264 (C7_2_2 a) * eLpNorm f 2 volume := by\n      rw [\u2190 ENNReal.rpow_natCast, Nat.cast_pow]\n      exact mul_right_mono <| calc 2 ^ (a : \u211d) ^ 3 + 2 ^ (1 + 7 * a + 101 * a ^ 3) * 2 ^ (2 * a)\n        _ \u2264 (2 : \u211d\u22650\u221e) ^ ((101.6 : \u211d) * a ^ 3) + (2 : \u211d\u22650\u221e) ^ ((101.6 : \u211d) * a ^ 3) := by\n          gcongr\n          \u00b7 exact one_le_two\n          \u00b7 linarith [pow_pos (cast_a_pos X) 3]\n          \u00b7 simp_rw [\u2190 pow_add, \u2190 ENNReal.rpow_natCast, Nat.cast_add, Nat.cast_mul, Nat.cast_pow]\n            apply ENNReal.rpow_le_rpow_of_exponent_le one_le_two\n            linarith [show 4 ^ 2 * (a : \u211d) \u2264 a ^ 2 * a by gcongr]\n        _ = (2 : \u211d\u22650\u221e) ^ (101.6 * (a : \u211d) ^ 3 + 1) := by\n          rw [\u2190 mul_two, ENNReal.rpow_add _ _ two_ne_zero ENNReal.ofNat_ne_top, ENNReal.rpow_one]\n        _ \u2264 C7_2_2 a := by\n          have := ENNReal.coe_rpow_def 2 (102 * a ^ 3)\n          simp only [ENNReal.coe_ofNat, OfNat.ofNat_ne_zero, false_and, reduceIte] at this\n          rw [C7_2_2, \u2190 this]\n          apply ENNReal.rpow_le_rpow_of_exponent_le one_le_two\n          linarith [show 0.4 * 4 ^ 3 \u2264 (0.4 : \u211d) * a ^ 3 by gcongr]\n\n/-- The set of cubes in Lemma 7.2.4. -/\ndef kissing (I : Grid X) : Finset (Grid X) :=\n  {J | s J = s I \u2227 \u00acDisjoint (ball (c I) (16 * D ^ s I)) (ball (c J) (16 * D ^ s J))}\n\nlemma subset_of_kissing (h : J \u2208 kissing I) :\n    ball (c J) (D ^ s J / 4) \u2286 ball (c I) (33 * D ^ s I) := by\n  simp_rw [kissing, Finset.mem_filter, Finset.mem_univ, true_and] at h\n  obtain \u27e8x, xI, xJ\u27e9 := not_disjoint_iff.mp h.2\n  apply ball_subset_ball'\n  calc\n    _ \u2264 D ^ s J / 4 + dist (c J) x + dist x (c I) := by\n      rw [add_assoc]; exact add_le_add_left (dist_triangle ..) _\n    _ \u2264 D ^ s J / 4 + 16 * D ^ s J + 16 * D ^ s I := by\n      gcongr\n      \u00b7 exact (mem_ball'.mp xJ).le\n      \u00b7 exact (mem_ball.mp xI).le\n    _ \u2264 _ := by\n      rw [h.1, div_eq_mul_inv, mul_comm _ 4\u207b\u00b9, \u2190 distrib_three_right]\n      gcongr\n      norm_num\n\nlemma volume_le_of_kissing (h : J \u2208 kissing I) :\n    volume (ball (c I) (33 * D ^ s I)) \u2264 2 ^ (9 * a) * volume (ball (c J) (D ^ s J / 4)) := by\n  simp_rw [kissing, Finset.mem_filter, Finset.mem_univ, true_and] at h\n  obtain \u27e8x, xI, xJ\u27e9 := not_disjoint_iff.mp h.2\n  have : ball (c I) (33 * D ^ s I) \u2286 ball (c J) (128 * D ^ s J) := by\n    apply ball_subset_ball'\n    calc\n      _ \u2264 33 * D ^ s I + dist (c I) x + dist x (c J) := by\n        rw [add_assoc]; exact add_le_add_left (dist_triangle ..) _\n      _ \u2264 33 * D ^ s I + 16 * D ^ s I + 16 * D ^ s J := by\n        gcongr\n        \u00b7 exact (mem_ball'.mp xI).le\n        \u00b7 exact (mem_ball.mp xJ).le\n      _ \u2264 _ := by\n        rw [h.1, \u2190 distrib_three_right]\n        gcongr; norm_num\n  have double := measure_ball_le_pow_two' (\u03bc := volume) (x := c J) (r := D ^ s J / 4) (n := 9)\n  have A9 : (defaultA a : \u211d\u22650) ^ 9 = (2 : \u211d\u22650\u221e) ^ (9 * a) := by\n    simp only [defaultA]; norm_cast; ring\n  rw [show (2 : \u211d) ^ 9 * (D ^ s J / 4) = 128 * D ^ s J by ring, A9] at double\n  exact (measure_mono this).trans double\n\nlemma pairwiseDisjoint_of_kissing :\n    (kissing I).toSet.PairwiseDisjoint fun i \u21a6 ball (c i) (D ^ s i / 4) := fun j mj k mk hn \u21a6 by\n  apply disjoint_of_subset ball_subset_Grid ball_subset_Grid\n  simp_rw [Finset.mem_coe, kissing, Finset.mem_filter] at mj mk\n  exact (eq_or_disjoint (mj.2.1.trans mk.2.1.symm)).resolve_left hn\n\n/-- Lemma 7.2.4. -/\nlemma boundary_overlap (I : Grid X) : (kissing I).card \u2264 2 ^ (9 * a) := by\n  have key : (kissing I).card * volume (ball (c I) (33 * D ^ s I)) \u2264\n      2 ^ (9 * a) * volume (ball (c I) (33 * D ^ s I)) := by\n    calc\n      _ = \u2211 _ \u2208 kissing I, volume (ball (c I) (33 * D ^ s I)) := by\n        rw [Finset.sum_const, nsmul_eq_mul]\n      _ \u2264 \u2211 J \u2208 kissing I, 2 ^ (9 * a) * volume (ball (c J) (D ^ s J / 4)) :=\n        Finset.sum_le_sum fun _ \u21a6 volume_le_of_kissing\n      _ = 2 ^ (9 * a) * volume (\u22c3 J \u2208 kissing I, ball (c J) (D ^ s J / 4)) := by\n        rw [\u2190 Finset.mul_sum]; congr\n        exact (measure_biUnion_finset pairwiseDisjoint_of_kissing fun _ _ \u21a6 measurableSet_ball).symm\n      _ \u2264 _ := by gcongr; exact iUnion\u2082_subset fun _ \u21a6 subset_of_kissing\n  have vn0 : volume (ball (c I) (33 * D ^ s I)) \u2260 0 := by\n    refine (measure_ball_pos volume _ ?_).ne'; simp only [defaultD]; positivity\n  rw [ENNReal.mul_le_mul_right vn0 (measure_ball_ne_top _ _)] at key; norm_cast at key\n\nirreducible_def C7_2_3 (a : \u2115) : \u211d\u22650 := 2 ^ (12 * (a : \u211d))\n\n/-- Lemma 7.2.3. -/\nlemma boundary_operator_bound\n    (hf : BoundedCompactSupport f) (hu : u \u2208 t) :\n    eLpNorm (boundaryOperator t u f) 2 volume \u2264 (C7_2_3 a) * eLpNorm f 2 volume := by\n  sorry\n\n/-- The constant used in `tree_projection_estimate`.\nOriginally had value `2 ^ (104 * a ^ 3)` in the blueprint, but that seems to be a mistake. -/\n-- Todo: define this recursively in terms of previous constants\nirreducible_def C7_2_1 (a : \u2115) : \u211d\u22650 := 2 ^ (152 * (a : \u211d) ^ 3)\n\n-- Auxiliary function used in the proof of Lemma 7.2.1\nprivate def eI\ud835\udcacu_mul (u : \ud835\udd13 X) (f : X \u2192 \u2102) : X \u2192 \u2102 := fun y \u21a6 exp (.I * \ud835\udcac u y) * f y\n\nprivate lemma boundedCompactSupport_eI\ud835\udcacu_mul (u : \ud835\udd13 X) {f : X \u2192 \u2102} (hf : BoundedCompactSupport f) :\n    BoundedCompactSupport (eI\ud835\udcacu_mul u f) := by\n  apply hf.mul_bdd_left\n  \u00b7 refine isBounded_iff_forall_norm_le.mpr \u27e81, fun _ h \u21a6 ?_\u27e9\n    obtain \u27e8_, rfl\u27e9 := mem_range.mp h\n    rw [mul_comm, norm_exp_ofReal_mul_I]\n  \u00b7 apply measurable_exp.stronglyMeasurable.comp_measurable\n    exact (measurable_ofReal.comp' (map_continuous (\ud835\udcac u)).measurable).const_mul I\n\nprivate lemma norm_eI\ud835\udcacu_mul_eq (u : \ud835\udd13 X) (f : X \u2192 \u2102) (x : X) : \u2016eI\ud835\udcacu_mul u f x\u2016 = \u2016f x\u2016 := by\n  simp [eI\ud835\udcacu_mul, mul_comm I]\n\n-- The bound for `carlesonSum` from `pointwise_tree_estimate` (Lemma 7.1.3)\nvariable (t) (u) (f) in\nprivate def cS_bound (x' : X) :=\n    C7_1_3 a * (MB volume \ud835\udcd1 c\ud835\udcd1 r\ud835\udcd1 (approxOnCube (\ud835\udcd9 (t u)) (\u2016f \u00b7\u2016)) x' +\n    t.boundaryOperator u (approxOnCube (\ud835\udcd9 (t u)) (\u2016f \u00b7\u2016)) x') +\n    nontangentialMaximalFunction (\ud835\udcac u) (approxOnCube (\ud835\udcd9 (t u)) (eI\ud835\udcacu_mul u f)) x'\n\nprivate lemma aeMeasurable_cS_bound : AEMeasurable (cS_bound t u f) := by\n  refine AEMeasurable.add ?_ MeasureTheory.Measurable.nontangentialMaximalFunction.aemeasurable\n  apply ((AEStronglyMeasurable.maximalFunction (to_countable \ud835\udcd1)).aemeasurable.add ?_).const_mul\n  exact MeasureTheory.Measurable.boundaryOperator.aemeasurable\n\n-- The natural constant for Lemma 7.2.1 is \u2264 the simpler constant `C7_2_1` we use instead.\n", "theoremStatement": "private lemma le_C7_2_1 {a : \u2115} (ha : 4 \u2264 a) :\n    C7_1_3 a * CMB (defaultA a) 2 + C7_1_3 a * C7_2_3 a + C7_2_2 a \u2264 (C7_2_1 a : \u211d\u22650\u221e) ", "theoremName": "TileStructure.Forest.le_C7_2_1", "fileCreated": {"commit": "5e49c3692f6d7344434caa7eea5f412f0ee35863", "date": "2024-09-27"}, "theoremCreated": {"commit": "0138d636eed1475ea5e848ef6cf4b141636056cc", "date": "2025-01-20"}, "file": "carleson/Carleson/ForestOperator/L2Estimate.lean", "module": "Carleson.ForestOperator.L2Estimate", "jsonFile": "Carleson.ForestOperator.L2Estimate.jsonl", "positionMetadata": {"lineInFile": 469, "tokenPositionInFile": 24142, "theoremPositionInFile": 27}, "dependencyMetadata": {"inFilePremises": null, "numInFilePremises": null, "repositoryPremises": null, "numRepositoryPremises": null, "numPremises": null}, "proofMetadata": {"hasProof": true, "proof": ":= calc\n  _ \u2264 (3 : \u2115) \u2022 (2 : \u211d\u22650\u221e) ^ (151 * (a : \u211d) ^ 3 + 12 * a) := by\n    rw [three'_nsmul]\n    gcongr\n    \u00b7 rw [C7_1_3_eq_C7_1_6 ha, C7_1_6_def, CMB_defaultA_two_eq, \u2190 ENNReal.coe_mul,\n        \u2190 NNReal.rpow_add two_ne_zero, ENNReal.coe_rpow_of_ne_zero two_ne_zero, ENNReal.coe_ofNat]\n      apply ENNReal.rpow_le_rpow_of_exponent_le one_le_two ?_\n      linarith [show 4 \u2264 (a : \u211d) by exact_mod_cast ha]\n    \u00b7 rw [C7_1_3_eq_C7_1_6 ha, C7_2_3_def, C7_1_6_def]\n      norm_cast\n      exact le_of_eq (pow_add _ _ _).symm\n    \u00b7 rw [C7_2_2_def]\n      norm_cast\n      exact pow_right_mono\u2080 one_le_two <| (Nat.mul_le_mul_right _ (by norm_num)).trans le_self_add\n  _ = 3 * 2 ^ (12 * (a : \u211d)) * (2 : \u211d\u22650\u221e) ^ (151 * (a : \u211d) ^ 3) := by\n    rw [add_comm, ENNReal.rpow_add _ _ two_ne_zero ENNReal.ofNat_ne_top]; ring\n  _ \u2264 (2 : \u211d\u22650\u221e) ^ ((a : \u211d) ^ 3) * (2 : \u211d\u22650\u221e) ^ (151 * (a : \u211d) ^ 3) := by\n    apply mul_right_mono\n    norm_cast\n    calc\n      3 * 2 ^ (12 * a) \u2264 2 ^ 2 * 2 ^ (12 * a) := by gcongr; norm_num\n      _                = 2 ^ (2 + 12 * a)     := by rw [pow_add]\n      _                \u2264 2 ^ (a ^ 3)          := pow_le_pow_right\u2080 one_le_two <| calc\n                          2 + 12 * a \u2264 a + 12 * a  := by apply add_le_add_right; linarith\n                          _          = 13 * a      := by ring\n                          _          \u2264 a ^ 2 * a   := by rw [mul_le_mul_right] <;> nlinarith\n                          _          = a ^ 3       := rfl\n  _ = _ := by\n    rw [C7_2_1_def, \u2190 ENNReal.rpow_add _ _ two_ne_zero ENNReal.ofNat_ne_top]\n    norm_cast\n    ring", "proofType": "term", "proofLengthLines": 30, "proofLengthTokens": 1561}}
{"srcContext": "/-\nCopyright (c) 2024 Joris Roos. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joris Roos, S\u00e9bastien Gou\u00ebzel\n-/\n\nimport Mathlib.Analysis.Convex.PartitionOfUnity\nimport Mathlib.Analysis.Calculus.ContDiff.Basic\nimport Mathlib.MeasureTheory.Integral.Average\nimport Mathlib.MeasureTheory.Integral.Bochner\nimport Mathlib.MeasureTheory.Integral.Prod\nimport Mathlib.MeasureTheory.Measure.Haar.OfBasis\nimport Mathlib.Topology.MetricSpace.Holder\nimport Mathlib.Data.Set.Card\nimport Mathlib.Data.Real.ENatENNReal\nimport Carleson.ToMathlib.Misc\n\n/-!\n\nEXPERIMENTAL\n\n# Bounded compactly supported functions\n\nThe purpose of this file is to provide helper lemmas to streamline proofs that\nfunctions are (essentially) bounded, compactly supported and measurable.\n\nMost functions we need to deal with are of this class.\nThis can be a useful way to streamline proofs of `L^p` membership,\nin particular integrability.\n\nTodo: make `Mathlib.Tactic.FunProp` work for this\n\nThis can be expanded as needed\n\n-/\n\nset_option linter.unusedSectionVars false -- remove for mathlib\n\nnamespace MeasureTheory\n\nopen Bornology Function Set HasCompactSupport\nopen scoped ENNReal\n\nsection\n\n-- This setting should be enough for this project, but\n-- for mathlib should generalize to vector-valued, and use `MeasurableSpace X`, `Measure \u03bc`\nvariable {X \ud835\udd5c} [MeasurableSpace X] [RCLike \ud835\udd5c] {f : X \u2192 \ud835\udd5c} {\u03bc : Measure X}\nvariable [TopologicalSpace X]\n-- variable [T2Space X] -- for mathlib should remove this\n-- variable [IsFiniteMeasureOnCompacts \u03bc]\n-- variable [SigmaFinite (volume : Measure X)]\n\n/-- Bounded compactly supported measurable functions -/\n-- There are various alternative definitions one could use here\n-- After all it does seem to be better to use `IsBounded (range f)`\n-- Todo: Refactor accordingly\nstructure BoundedCompactSupport (f : X \u2192 \ud835\udd5c) : Prop where\n  isBounded : IsBounded (range f)\n  stronglyMeasurable : StronglyMeasurable f\n  hasCompactSupport : HasCompactSupport f\n\nlemma isBounded_range_iff_forall_norm_le {\u03b1 \u03b2} [SeminormedAddCommGroup \u03b1] {f : \u03b2 \u2192 \u03b1} :\n    IsBounded (range f) \u2194 \u2203 C, \u2200 x, \u2016f x\u2016 \u2264 C := by convert isBounded_iff_forall_norm_le; simp\n\nomit [TopologicalSpace X] in\nlemma _root_.Bornology.IsBounded.eLpNorm_top_lt_top (hf : IsBounded (range f)) :\n    eLpNorm f \u22a4 \u03bc < \u22a4 := by\n  obtain \u27e8C, hC\u27e9 := isBounded_range_iff_forall_norm_le.mp hf\n  apply eLpNormEssSup_lt_top_of_ae_bound (C := C)\n  exact ae_of_all \u03bc hC\n\nomit [TopologicalSpace X] in\n-- maybe in mathlib, but couldn't find it\ntheorem ae_le_of_eLpNorm_top_lt_top (hf : eLpNorm f \u22a4 \u03bc < \u22a4) :\n    \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016 \u2264 ENNReal.toReal (eLpNorm f \u22a4 \u03bc) := by\n  have := coe_nnnorm_ae_le_eLpNormEssSup f \u03bc\n  filter_upwards [this] with x hx\n  have : ENNReal.ofReal \u2016f x\u2016\u208a \u2260 \u22a4 := ENNReal.ofReal_ne_top\n  convert (ENNReal.toReal_le_toReal this ?_).mpr ?_\n  \u00b7 simp\n  \u00b7 exact hf.ne_top\n  \u00b7 exact trans ENNReal.ofReal_coe_nnreal hx\n\nnamespace BoundedCompactSupport\n\nprotected theorem zero : BoundedCompactSupport (fun (_ : X) \u21a6 (0 : \ud835\udd5c)) where\n  isBounded := isBounded_range_iff_forall_norm_le.2 \u27e80, by simp\u27e9\n  stronglyMeasurable := stronglyMeasurable_const\n  hasCompactSupport := HasCompactSupport.zero\n\ntheorem indicator_of_isBounded_range {X : Type*} [MetricSpace X] [ProperSpace X]\n    [MeasurableSpace X] [BorelSpace X] {f : X \u2192 \ud835\udd5c} (hf : IsBounded (range f))\n    (h'f : StronglyMeasurable f) {s : Set X} (h's : IsBounded s) (hs : MeasurableSet s) :\n    BoundedCompactSupport (s.indicator f) where\n  stronglyMeasurable := h'f.indicator hs\n  isBounded := by\n    rcases isBounded_range_iff_forall_norm_le.1 hf with \u27e8C, hC\u27e9\n    apply isBounded_range_iff_forall_norm_le.2 \u27e8C, fun x \u21a6 ?_\u27e9\n    simp only [indicator]\n    split_ifs\n    \u00b7 exact hC x\n    \u00b7 simp only [norm_zero]\n      apply (norm_nonneg _).trans (hC x)\n  hasCompactSupport := by\n    apply HasCompactSupport.intro (K := closure s)\n    \u00b7 apply Metric.isCompact_of_isClosed_isBounded isClosed_closure h's.closure\n    \u00b7 intro x hx\n      have : x \u2209 s := by\n        contrapose! hx; exact subset_closure hx\n      simp [this]\n\nvariable {f : X \u2192 \ud835\udd5c}\nvariable {g : X \u2192 \ud835\udd5c}\n\nvariable (hf : BoundedCompactSupport f)\nvariable (hg : BoundedCompactSupport g)\n\nsection Includehf\n\ninclude hf\n\ntheorem aestronglyMeasurable : AEStronglyMeasurable f \u03bc :=\n  hf.stronglyMeasurable.aestronglyMeasurable\n\ntheorem mem\u2112p_top : Mem\u2112p f \u22a4 \u03bc :=\n  \u27e8hf.aestronglyMeasurable, hf.isBounded.eLpNorm_top_lt_top\u27e9\n\ntheorem ae_le : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016 \u2264 ENNReal.toReal (eLpNorm f \u22a4 \u03bc) :=\n  ae_le_of_eLpNorm_top_lt_top hf.mem\u2112p_top.2\n\n/-- Bounded compactly supported functions are in all `L\u1d56` spaces. -/\ntheorem mem\u2112p [IsFiniteMeasureOnCompacts \u03bc] (p : ENNReal) : Mem\u2112p f p \u03bc :=\n  hf.hasCompactSupport.mem\u2112p_of_bound hf.aestronglyMeasurable _ hf.ae_le\n\n/-- Bounded compactly supported functions are integrable. -/\ntheorem integrable [IsFiniteMeasureOnCompacts \u03bc] : Integrable f \u03bc :=\n  mem\u2112p_one_iff_integrable.mp <| mem\u2112p hf 1\n\ntheorem mul_bdd_right (hg : IsBounded (range g)) (h2g : StronglyMeasurable g) :\n    BoundedCompactSupport (f * g) where\n  isBounded := by\n    rcases isBounded_range_iff_forall_norm_le.1 hf.isBounded with \u27e8C, hC\u27e9\n    rcases isBounded_range_iff_forall_norm_le.1 hg with \u27e8D, hD\u27e9\n    apply isBounded_range_iff_forall_norm_le.2 \u27e8C * D, fun x \u21a6 ?_\u27e9\n    simp only [Pi.mul_apply, norm_mul]\n    gcongr\n    \u00b7 apply (norm_nonneg _).trans (hC x)\n    \u00b7 exact hC x\n    \u00b7 exact hD x\n  stronglyMeasurable := hf.stronglyMeasurable.mul h2g\n  hasCompactSupport := hf.hasCompactSupport.mul_right\n\ntheorem mul_bdd_left (hg : IsBounded (range g)) (h2g : StronglyMeasurable g) :\n    BoundedCompactSupport (g * f) := by\n  rw [mul_comm]; exact mul_bdd_right hf hg h2g\n\n-- doesn't use compact support but is convenient to have here\ntheorem integrable_mul (hg : Integrable g \u03bc) : Integrable (f * g) \u03bc :=\n  Integrable.bdd_mul' hg hf.aestronglyMeasurable hf.ae_le\n\ntheorem conj : BoundedCompactSupport (star f) where\n  isBounded := by simpa [star, isBounded_range_iff_forall_norm_le] using hf.isBounded\n  stronglyMeasurable := RCLike.continuous_conj.comp_stronglyMeasurable hf.stronglyMeasurable\n  hasCompactSupport := by -- mathlib should have a lemma `HasCompactSupport.conj`?\n    simp only [star, RCLike.star_def]\n    apply (hasCompactSupport_comp_left (by simp)).2 hf.hasCompactSupport\n\ntheorem norm : BoundedCompactSupport (\u2016f \u00b7\u2016) where\n  isBounded := by simpa [isBounded_range_iff_forall_norm_le] using hf.isBounded\n  stronglyMeasurable := hf.stronglyMeasurable.norm\n  hasCompactSupport := hf.hasCompactSupport.norm\n\ntheorem const_mul (c : \ud835\udd5c) : BoundedCompactSupport (fun x \u21a6 c * (f x)) where\n  isBounded := by\n    rcases isBounded_range_iff_forall_norm_le.1 hf.isBounded with \u27e8C, hC\u27e9\n    apply isBounded_range_iff_forall_norm_le.2 \u27e8\u2016c\u2016 * C, fun x \u21a6 ?_\u27e9\n    simp only [norm_mul]\n    gcongr\n    exact hC x\n  stronglyMeasurable := hf.stronglyMeasurable.const_mul _\n  hasCompactSupport := by\n    suffices support (fun x \u21a6 c * (f x)) \u2286 support f from\n      hf.hasCompactSupport.mono this\n    exact support_mul_subset_right ..\n\ntheorem mul_const (c : \ud835\udd5c) : BoundedCompactSupport (fun x \u21a6 (f x) * c) := by\n  simp_rw [mul_comm]; exact hf.const_mul _\n\nend Includehf\n\nsection Includehfhg\n\ninclude hf hg\n\n", "theoremStatement": "theorem mul : BoundedCompactSupport (f * g) ", "theoremName": "MeasureTheory.BoundedCompactSupport.mul", "fileCreated": {"commit": "ec175b9008144d009269ce427b9ad43dbd70d0a5", "date": "2024-12-09"}, "theoremCreated": {"commit": "ec175b9008144d009269ce427b9ad43dbd70d0a5", "date": "2024-12-09"}, "file": "carleson/Carleson/ToMathlib/BoundedCompactSupport.lean", "module": "Carleson.ToMathlib.BoundedCompactSupport", "jsonFile": "Carleson.ToMathlib.BoundedCompactSupport.jsonl", "positionMetadata": {"lineInFile": 196, "tokenPositionInFile": 7196, "theoremPositionInFile": 11}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 4, "numPremises": 21}, "proofMetadata": {"hasProof": true, "proof": ":= mul_bdd_right hf hg.isBounded hg.stronglyMeasurable", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 54}}
{"srcContext": "/-\nCopyright (c) 2024 James Sundstrom. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: James Sundstrom\n-/\nimport Mathlib.MeasureTheory.Constructions.BorelSpace.Metric\n\n/-!\n# Annulus\n\nIn this file we define an annulus in a pseudometric space `X` to be a set consisting of all `y`\nsuch that `dist x y` lies in an interval between `r` and `R`. An annulus is defined for each type\nof interval (`Ioo`, `Ioc`, etc.) with a parallel naming scheme, except that we do not define annuli\nfor `Iio` and `Ico`, as they would be balls.\n\nWe also define `EAnnulus` similarly using `edist` instead of `dist`.\n\n## Tags\n\nannulus, eannulus\n-/\n\nopen Set Metric ENNReal\n\nvariable {X : Type*} [PseudoMetricSpace X]\n\nnamespace Set\n\nnamespace Annulus\n\ndef oo (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d) := {y | dist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d) := {y | dist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d) := {y | dist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d) := {y | dist x y \u2208 Ici r}\n\nlemma oo_eq {x : X} {r R : \u211d} : oo x r R = ball x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oo, dist_comm, and_comm]\n\nlemma oc_eq {x : X} {r R : \u211d} : oc x r R = closedBall x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oc, dist_comm, and_comm]\n\nlemma co_eq {x : X} {r R : \u211d} : co x r R = ball x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [co, dist_comm, and_comm]\n\nlemma cc_eq {x : X} {r R : \u211d} : cc x r R = closedBall x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [cc, dist_comm, and_comm]\n\nlemma oi_eq {x : X} {r : \u211d} : oi x r = (closedBall x r)\u1d9c := by\n  ext; simp [oi, dist_comm]\n\nlemma ci_eq {x : X} {r : \u211d} : ci x r = (ball x r)\u1d9c := by\n  ext; simp [ci, dist_comm]\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\n", "theoremStatement": "lemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 ", "theoremName": "Set.Annulus.oc_subset_cc", "fileCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "theoremCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "file": "carleson/Carleson/ToMathlib/Annulus.lean", "module": "Carleson.ToMathlib.Annulus", "jsonFile": "Carleson.ToMathlib.Annulus.jsonl", "positionMetadata": {"lineInFile": 107, "tokenPositionInFile": 3627, "theoremPositionInFile": 25}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 22}, "proofMetadata": {"hasProof": true, "proof": ":=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 66}}
{"srcContext": "/-\nCopyright (c) 2024 James Sundstrom. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: James Sundstrom\n-/\nimport Mathlib.MeasureTheory.Constructions.BorelSpace.Metric\n\n/-!\n# Annulus\n\nIn this file we define an annulus in a pseudometric space `X` to be a set consisting of all `y`\nsuch that `dist x y` lies in an interval between `r` and `R`. An annulus is defined for each type\nof interval (`Ioo`, `Ioc`, etc.) with a parallel naming scheme, except that we do not define annuli\nfor `Iio` and `Ico`, as they would be balls.\n\nWe also define `EAnnulus` similarly using `edist` instead of `dist`.\n\n## Tags\n\nannulus, eannulus\n-/\n\nopen Set Metric ENNReal\n\nvariable {X : Type*} [PseudoMetricSpace X]\n\nnamespace Set\n\nnamespace Annulus\n\ndef oo (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d) := {y | dist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d) := {y | dist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d) := {y | dist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d) := {y | dist x y \u2208 Ici r}\n\nlemma oo_eq {x : X} {r R : \u211d} : oo x r R = ball x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oo, dist_comm, and_comm]\n\nlemma oc_eq {x : X} {r R : \u211d} : oc x r R = closedBall x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oc, dist_comm, and_comm]\n\nlemma co_eq {x : X} {r R : \u211d} : co x r R = ball x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [co, dist_comm, and_comm]\n\nlemma cc_eq {x : X} {r R : \u211d} : cc x r R = closedBall x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [cc, dist_comm, and_comm]\n\nlemma oi_eq {x : X} {r : \u211d} : oi x r = (closedBall x r)\u1d9c := by\n  ext; simp [oi, dist_comm]\n\nlemma ci_eq {x : X} {r : \u211d} : ci x r = (ball x r)\u1d9c := by\n  ext; simp [ci, dist_comm]\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : co x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma co_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : co x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\nlemma cc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\n", "theoremStatement": "lemma cc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 ", "theoremName": "Set.Annulus.cc_subset_oc", "fileCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "theoremCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "file": "carleson/Carleson/ToMathlib/Annulus.lean", "module": "Carleson.ToMathlib.Annulus", "jsonFile": "Carleson.ToMathlib.Annulus.jsonl", "positionMetadata": {"lineInFile": 143, "tokenPositionInFile": 5140, "theoremPositionInFile": 35}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 22}, "proofMetadata": {"hasProof": true, "proof": ":=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.trans hR\u27e9", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 61}}
{"srcContext": "import Carleson.ToMathlib.CoverByBalls\nimport Mathlib.Data.Real.StarOrdered\nimport Mathlib.MeasureTheory.Measure.Lebesgue.VolumeOfBalls\nimport Mathlib.Order.CompletePartialOrder\n\nopen MeasureTheory Measure NNReal ENNReal Metric Filter Topology TopologicalSpace\nnoncomputable section\n\nnamespace MeasureTheory\n\n\n/-- A doubling measure is a measure on a metric space with the condition that doubling\nthe radius of a ball only increases the volume by a constant factor, independent of the ball. -/\nclass Measure.IsDoubling {X : Type*} [MeasurableSpace X] [PseudoMetricSpace X]\n    (\u03bc : Measure X) (A : outParam \u211d\u22650) : Prop where\n  measure_ball_two_le_same : \u2200 (x : X) r, \u03bc (ball x (2 * r)) \u2264 A * \u03bc (ball x r)\nexport IsDoubling (measure_ball_two_le_same)\n\nsection PseudoMetric\n\nvariable {X : Type*} [PseudoMetricSpace X]\n\nlemma ball_subset_ball_of_le {x x' : X} {r r' : \u211d}\n    (hr : dist x x' + r' \u2264 r) : ball x' r' \u2286 ball x r := by\n  intro y h\n  have h1 : dist x y < r := by\n    calc dist x y \u2264 dist x x' + dist x' y := dist_triangle _ _ _\n        _ < dist x x' + r' := by gcongr; exact mem_ball'.mp h\n        _ \u2264 r := hr\n  exact mem_ball'.mpr h1\n\nvariable {A : \u211d\u22650} [MeasurableSpace X] {\u03bc : Measure X} [\u03bc.IsDoubling A]\n\nlemma IsDoubling.mono {A'} (h : A \u2264 A') : IsDoubling \u03bc A' where\n  measure_ball_two_le_same := by\n    intro x r\n    calc \u03bc (Metric.ball x (2 * r))\n      _ \u2264 A * \u03bc (Metric.ball x r) := measure_ball_two_le_same _ _\n      _ \u2264 A' * \u03bc (Metric.ball x r) := by gcongr\n\nvariable [ProperSpace X] [IsFiniteMeasureOnCompacts \u03bc]\n\nlemma measure_real_ball_two_le_same (x : X) (r : \u211d) :\n    \u03bc.real (ball x (2 * r)) \u2264 A * \u03bc.real (ball x r) := by\n  simp_rw [Measure.real, \u2190 ENNReal.coe_toReal, \u2190 toReal_mul]\n  gcongr\n  \u00b7 exact ENNReal.mul_ne_top coe_ne_top measure_ball_lt_top.ne\n  \u00b7 exact measure_ball_two_le_same x r\n\n", "theoremStatement": "lemma measure_real_ball_two_le_same_iterate (x : X) (r : \u211d) (n : \u2115) :\n    \u03bc.real (ball x ((2 ^ n) * r)) \u2264 A ^ n * \u03bc.real (ball x r) ", "theoremName": "MeasureTheory.measure_real_ball_two_le_same_iterate", "fileCreated": {"commit": "1a36cbeaee9466fb56c9aca49ef373f9f9cc7ab7", "date": "2025-01-23"}, "theoremCreated": {"commit": "3298f748e9eb26a242da5ee38cb50dc55e604935", "date": "2025-01-08"}, "file": "carleson/Carleson/ToMathlib/DoublingMeasure.lean", "module": "Carleson.ToMathlib.DoublingMeasure", "jsonFile": "Carleson.ToMathlib.DoublingMeasure.jsonl", "positionMetadata": {"lineInFile": 50, "tokenPositionInFile": 1819, "theoremPositionInFile": 2}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 3, "numPremises": 71}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  induction n with\n  | zero => simp\n  | succ m ih =>\n      simp_rw [add_comm m 1, pow_add, pow_one, mul_assoc]\n      exact le_trans (measure_real_ball_two_le_same x _) (by gcongr)", "proofType": "tactic", "proofLengthLines": 5, "proofLengthTokens": 185}}
{"srcContext": "import Mathlib.Analysis.Convex.PartitionOfUnity\nimport Mathlib.Analysis.Calculus.ContDiff.Basic\nimport Mathlib.MeasureTheory.Integral.Average\nimport Mathlib.MeasureTheory.Integral.Bochner\nimport Mathlib.MeasureTheory.Measure.Haar.OfBasis\nimport Mathlib.Topology.MetricSpace.Holder\nimport Mathlib.Data.Set.Card\nimport Mathlib.Data.Real.ENatENNReal\nimport Carleson.ToMathlib.MeasureReal\n\n/-\n* This file can import all ToMathlib files.\n* If adding more than a few results, please put them in a more appropriate file in ToMathlib.\n-/\n\nopen Function Set\nopen scoped ENNReal\n\nsection ENNReal\n\nlemma tsum_one_eq' {\u03b1 : Type*} (s : Set \u03b1) : \u2211' (_:s), (1 : \u211d\u22650\u221e) = s.encard := by\n  if hfin : s.Finite then\n    have hfin' : Finite s := hfin\n    rw [tsum_def]\n    simp only [ENNReal.summable, \u2193reduceDIte]\n    have hsup: support (fun (_ : s) \u21a6 (1 : \u211d\u22650\u221e)) = Set.univ := by\n      ext i\n      simp only [mem_support, ne_eq, one_ne_zero, not_false_eq_true, mem_univ]\n    have hsupfin: (Set.univ : Set s).Finite := finite_univ\n    rw [\u2190 hsup] at hsupfin\n    rw [if_pos hsupfin]\n    rw [hfin.encard_eq_coe_toFinset_card]\n    simp only [ENat.toENNReal_coe]\n    rw [Finset.card_eq_sum_ones]\n    rw [finsum_eq_sum (fun (_ : s) \u21a6 (1 :\u211d\u22650\u221e)) hsupfin]\n    simp only [Finset.sum_const, nsmul_eq_mul, mul_one, smul_eq_mul, Nat.cast_inj]\n    apply Finset.card_bij (fun a _ => a.val)\n    \u00b7 intro a\n      simp only [Finite.mem_toFinset, mem_support, ne_eq, one_ne_zero, not_false_eq_true,\n        Subtype.coe_prop, imp_self]\n    \u00b7 intro a _ a' _ heq\n      ext\n      exact heq\n    \u00b7 intro a ha\n      use \u27e8a,by\n        simp only [Finite.mem_toFinset] at ha\n        exact ha\u27e9\n      simp only [Finite.mem_toFinset, mem_support, ne_eq, one_ne_zero, not_false_eq_true,\n        exists_const]\n  else\n  have : Infinite s := infinite_coe_iff.mpr hfin\n  rw [ENNReal.tsum_const_eq_top_of_ne_zero (by norm_num)]\n  rw [Set.encard_eq_top_iff.mpr hfin]\n  simp only [ENat.toENNReal_top]\n\nlemma ENNReal.tsum_const_eq' {\u03b1 : Type*} (s : Set \u03b1) (c : \u211d\u22650\u221e) :\n    \u2211' (_:s), (c : \u211d\u22650\u221e) = s.encard * c := by\n  nth_rw 1 [\u2190 one_mul c]\n  rw [ENNReal.tsum_mul_right,tsum_one_eq']\n\n/-! ## `ENNReal` manipulation lemmas -/\n\nlemma ENNReal.sum_geometric_two_pow_toNNReal {k : \u2115} (hk : k > 0) :\n    \u2211' (n : \u2115), (2 : \u211d\u22650\u221e) ^ (-k * n : \u2124) = (1 / (1 - 1 / 2 ^ k) : \u211d).toNNReal := by\n  conv_lhs =>\n    enter [1, n]\n    rw [\u2190 rpow_intCast, show (-k * n : \u2124) = (-k * n : \u211d) by simp, rpow_mul, rpow_natCast]\n  rw [tsum_geometric, show (2 : \u211d\u22650\u221e) = (2 : \u211d).toNNReal by simp,\n    \u2190 coe_rpow_of_ne_zero (by simp), \u2190 Real.toNNReal_rpow_of_nonneg zero_le_two,\n    \u2190 coe_one, \u2190 Real.toNNReal_one, \u2190 coe_sub, NNReal.sub_def,\n    Real.toNNReal_one, NNReal.coe_one, Real.coe_toNNReal', max_eq_left (by positivity),\n    Real.rpow_neg zero_le_two, Real.rpow_natCast, one_div]\n  have : ((1 : \u211d) - (2 ^ k)\u207b\u00b9).toNNReal \u2260 0 := by\n    rw [ne_eq, Real.toNNReal_eq_zero, tsub_le_iff_right, zero_add, not_le, inv_lt_one_iff\u2080]\n    right; exact one_lt_pow\u2080 (M\u2080 := \u211d) _root_.one_lt_two hk.ne'\n  rw [\u2190 coe_inv this, coe_inj, Real.toNNReal_inv, one_div]\n\nlemma ENNReal.sum_geometric_two_pow_neg_one : \u2211' (n : \u2115), (2 : \u211d\u22650\u221e) ^ (-n : \u2124) = 2 := by\n  conv_lhs => enter [1, n]; rw [\u2190 one_mul (n : \u2124), \u2190 neg_mul, \u2190 Nat.cast_one]\n  rw [ENNReal.sum_geometric_two_pow_toNNReal zero_lt_one]; norm_num\n\nlemma ENNReal.sum_geometric_two_pow_neg_two :\n    \u2211' (n : \u2115), (2 : \u211d\u22650\u221e) ^ (-2 * n : \u2124) = ((4 : \u211d) / 3).toNNReal := by\n  conv_lhs => enter [1, n, 2]; rw [\u2190 Nat.cast_two]\n  rw [ENNReal.sum_geometric_two_pow_toNNReal zero_lt_two]; norm_num\n\nlemma tsum_geometric_ite_eq_tsum_geometric {k c : \u2115} :\n    (\u2211' (n : \u2115), if k \u2264 n then (2 : \u211d\u22650\u221e) ^ (-c * (n - k) : \u2124) else 0) =\n    \u2211' (n : \u2115), 2 ^ (-c * n : \u2124) := by\n  convert (Injective.tsum_eq (f := fun n \u21a6 if k \u2264 n then (2 : \u211d\u22650\u221e) ^ (-c * (n - k) : \u2124) else 0)\n    (add_left_injective k) (fun n mn \u21a6 _)).symm\n  \u00b7 simp\n  \u00b7 rw [mem_support, ne_eq, ite_eq_right_iff, Classical.not_imp] at mn\n    use n - k, Nat.sub_add_cancel mn.1\n\nlemma ENNReal.toReal_zpow (x : \u211d\u22650\u221e) (z : \u2124) : x.toReal ^ z = (x ^ z).toReal := by\n  rw [\u2190 rpow_intCast, \u2190 toReal_rpow, Real.rpow_intCast]\n\nend ENNReal\n\nsection Indicator\nattribute [gcongr] Set.indicator_le_indicator mulIndicator_le_mulIndicator_of_subset\nend Indicator\n\n\nnamespace MeasureTheory\n\n/-! ## Partitioning an interval -/\n\n\nlemma lintegral_Ioc_partition {a b : \u2115} {c : \u211d} {f : \u211d \u2192 \u211d\u22650\u221e} (hc : 0 \u2264 c) :\n    \u222b\u207b t in Ioc (a * c) (b * c), f t =\n    \u2211 l \u2208 Finset.Ico a b, \u222b\u207b t in Ioc (l * c) ((l + 1 : \u2115) * c), f t := by\n  rcases lt_or_le b a with h | h\n  \u00b7 rw [Finset.Ico_eq_empty (by omega), Ioc_eq_empty (by rw [not_lt]; gcongr),\n      setLIntegral_empty, Finset.sum_empty]\n  induction b, h using Nat.le_induction with\n  | base =>\n    rw [Finset.Ico_self, Ioc_self, setLIntegral_empty, Finset.sum_empty]\n  | succ b h ih =>\n    have li : a * c \u2264 b * c := by gcongr\n    rw [\u2190 Ioc_union_Ioc_eq_Ioc li (by gcongr; omega),\n      lintegral_union measurableSet_Ioc Ioc_disjoint_Ioc_same,\n      Nat.Ico_succ_right_eq_insert_Ico h, Finset.sum_insert Finset.right_not_mem_Ico,\n      add_comm (lintegral ..), ih]\n\n/-! ## Averaging -/\n\n-- Named for consistency with `lintegral_add_left'`\n-- Maybe add laverage/laverage theorems for all the other lintegral_add statements?\nlemma laverage_add_left {\u03b1 : Type*} {m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}\n    {f g : \u03b1 \u2192 ENNReal} (hf : AEMeasurable f \u03bc) :\n    \u2a0d\u207b x, (f x + g x) \u2202\u03bc = \u2a0d\u207b x, f x \u2202\u03bc + \u2a0d\u207b x, g x \u2202\u03bc := by\n  simp_rw [laverage_eq, ENNReal.div_add_div_same, lintegral_add_left' hf]\n\n-- Named for consistency with `lintegral_mono'`\nlemma laverage_mono {\u03b1 : Type*} {m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}\n    {f g : \u03b1 \u2192 ENNReal} (h : \u2200 x, f x \u2264 g x) :\n    \u2a0d\u207b x, f x \u2202\u03bc \u2264 \u2a0d\u207b x, g x \u2202\u03bc := by\n  simp_rw [laverage_eq]\n  exact ENNReal.div_le_div_right (lintegral_mono h) (\u03bc univ)\n\nlemma laverage_const_mul {\u03b1 : Type*} {m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}\n    {f : \u03b1 \u2192 ENNReal} {c : ENNReal} (hc : c \u2260 \u22a4) :\n    c * \u2a0d\u207b x, f x \u2202\u03bc = \u2a0d\u207b x, c * f x \u2202\u03bc := by\n  simp_rw [laverage_eq, \u2190 mul_div_assoc c, lintegral_const_mul' c f hc]\n\n-- The following two lemmas are unused\n\n-- Named for consistency with `lintegral_add_left'`\n-- Maybe add laverage/setLaverage theorems for all the other lintegral_add statements?\nlemma setLaverage_add_left' {\u03b1 : Type*} {m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}\n    {s : Set \u03b1} {f g : \u03b1 \u2192 ENNReal} (hf : AEMeasurable f \u03bc) :\n    \u2a0d\u207b x in s, (f x + g x) \u2202\u03bc = \u2a0d\u207b x in s, f x \u2202\u03bc + \u2a0d\u207b x in s, g x \u2202\u03bc := by\n  simp_rw [setLaverage_eq, ENNReal.div_add_div_same, lintegral_add_left' hf.restrict]\n\n-- Named for consistency with `setLintegral_mono'`\nlemma setLaverage_mono' {\u03b1 : Type*} {m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}\n    {s : Set \u03b1} (hs : MeasurableSet s) {f g : \u03b1 \u2192 ENNReal} (h : \u2200 x \u2208 s, f x \u2264 g x) :\n    \u2a0d\u207b x in s, f x \u2202\u03bc \u2264 \u2a0d\u207b x in s, g x \u2202\u03bc := by\n  simp_rw [setLaverage_eq]\n  exact ENNReal.div_le_div_right (setLIntegral_mono' hs h) (\u03bc s)\n\nend MeasureTheory\n\nnamespace MeasureTheory\nvariable {\u03b1 : Type*} {m : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} {s : Set \u03b1}\n  {F : Type*} [NormedAddCommGroup F]\n\nattribute [fun_prop] Continuous.comp_aestronglyMeasurable\n  AEStronglyMeasurable.mul AEStronglyMeasurable.prod_mk\nattribute [gcongr] Measure.AbsolutelyContinuous.prod -- todo: also add one-sided versions for gcongr\n\n\ntheorem AEStronglyMeasurable.ennreal_toReal {u : \u03b1 \u2192 \u211d\u22650\u221e} (hu : AEStronglyMeasurable u \u03bc) :\n    AEStronglyMeasurable (fun x \u21a6 (u x).toReal) \u03bc := by\n  refine aestronglyMeasurable_iff_aemeasurable.mpr ?_\n  exact ENNReal.measurable_toReal.comp_aemeasurable hu.aemeasurable\n\nlemma laverage_mono_ae {f g : \u03b1 \u2192 \u211d\u22650\u221e} (h : \u2200\u1d50 a \u2202\u03bc, f a \u2264 g a) :\n    \u2a0d\u207b a, f a \u2202\u03bc \u2264 \u2a0d\u207b a, g a \u2202\u03bc := by\n  exact lintegral_mono_ae <| h.filter_mono <| Measure.ae_mono' Measure.smul_absolutelyContinuous\n\n@[gcongr]\nlemma setLAverage_mono_ae {f g : \u03b1 \u2192 \u211d\u22650\u221e} (h : \u2200\u1d50 a \u2202\u03bc, f a \u2264 g a) :\n    \u2a0d\u207b a in s, f a \u2202\u03bc \u2264 \u2a0d\u207b a in s, g a \u2202\u03bc := by\n  refine laverage_mono_ae <| h.filter_mono <| ae_mono Measure.restrict_le_self\n\nlemma setLaverage_const_le {c : \u211d\u22650\u221e} : \u2a0d\u207b _x in s, c \u2202\u03bc \u2264 c := by\n  simp_rw [setLaverage_eq, lintegral_const, Measure.restrict_apply MeasurableSet.univ,\n    univ_inter, div_eq_mul_inv, mul_assoc]\n  conv_rhs => rw [\u2190 mul_one c]\n  gcongr\n  exact ENNReal.mul_inv_le_one (\u03bc s)\n\ntheorem eLpNormEssSup_lt_top_of_ae_ennnorm_bound {f : \u03b1 \u2192 F} {C : \u211d\u22650\u221e}\n    (hfC : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016\u208a \u2264 C) : eLpNormEssSup f \u03bc \u2264 C := essSup_le_of_ae_le C hfC\n\n@[simp]\nlemma ENNReal.nnorm_toReal {x : \u211d\u22650\u221e} : \u2016x.toReal\u2016\u208a = x.toNNReal := by\n  ext; simp [ENNReal.toReal]\n\ntheorem restrict_absolutelyContinuous : \u03bc.restrict s \u226a \u03bc :=\n  fun s hs \u21a6 Measure.restrict_le_self s |>.trans hs.le |>.antisymm <| zero_le _\n\nend MeasureTheory\n\nsection\n\nopen MeasureTheory Bornology\nvariable {E X : Type*} {p : \u211d\u22650\u221e} [NormedAddCommGroup E] [TopologicalSpace X] [MeasurableSpace X]\n  {\u03bc : Measure X} [IsFiniteMeasureOnCompacts \u03bc] {f : X \u2192 E}\n\n---- now obsolete -> `BoundedCompactSupport.mem\u2112p`\n-- lemma _root_.HasCompactSupport.mem\u2112p_of_isBounded (hf : HasCompactSupport f)\n--     (h2f : IsBounded (range f))\n--     (h3f : AEStronglyMeasurable f \u03bc) {p : \u211d\u22650\u221e} : Mem\u2112p f p \u03bc := by\n--   obtain \u27e8C, hC\u27e9 := h2f.exists_norm_le\n--   simp only [mem_range, forall_exists_index, forall_apply_eq_imp_iff] at hC\n--   exact hf.mem\u2112p_of_bound h3f C <| .of_forall hC\n\nend\n\n/-! ## `EquivalenceOn` -/\n\n/-- An equivalence relation on the set `s`. -/\nstructure EquivalenceOn {\u03b1 : Type*} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : Set \u03b1) : Prop where\n  /-- An equivalence relation is reflexive: `x ~ x` -/\n  refl  : \u2200 x \u2208 s, r x x\n  /-- An equivalence relation is symmetric: `x ~ y` implies `y ~ x` -/\n  symm  : \u2200 {x y}, x \u2208 s \u2192 y \u2208 s \u2192 r x y \u2192 r y x\n  /-- An equivalence relation is transitive: `x ~ y` and `y ~ z` implies `x ~ z` -/\n  trans : \u2200 {x y z}, x \u2208 s \u2192 y \u2208 s \u2192 z \u2208 s \u2192 r x y \u2192 r y z \u2192 r x z\n\n\nnamespace EquivalenceOn\n\nvariable {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : Set \u03b1} {hr : EquivalenceOn r s} {x y : \u03b1}\n\nvariable (hr) in\n/-- The setoid defined from an equivalence relation on a set. -/\nprotected def setoid : Setoid s where\n  r x y := r x y\n  iseqv := {\n    refl := fun x \u21a6 hr.refl x x.2\n    symm := fun {x y} \u21a6 hr.symm x.2 y.2\n    trans := fun {x y z} \u21a6 hr.trans x.2 y.2 z.2\n  }\n\ninclude hr in\nlemma exists_rep (x : \u03b1) : \u2203 y, x \u2208 s \u2192 y \u2208 s \u2227 r x y :=\n  \u27e8x, fun hx \u21a6 \u27e8hx, hr.refl x hx\u27e9\u27e9\n\nopen Classical in\nvariable (hr) in\n/-- An arbitrary representative of `x` w.r.t. the equivalence relation `r`. -/\nprotected noncomputable def out (x : \u03b1) : \u03b1 :=\n  if hx : x \u2208 s then (Quotient.out (s := hr.setoid) \u27e6\u27e8x, hx\u27e9\u27e7 : s) else x\n\nlemma out_mem (hx : x \u2208 s) : hr.out x \u2208 s := by\n  rw [EquivalenceOn.out, dif_pos hx]\n  apply Subtype.prop\n\n@[simp]\nlemma out_mem_iff : hr.out x \u2208 s \u2194 x \u2208 s := by\n  refine \u27e8fun h \u21a6 ?_, out_mem\u27e9\n  by_contra hx\n  rw [EquivalenceOn.out, dif_neg hx] at h\n  exact hx h\n\nlemma out_rel (hx : x \u2208 s) : r (hr.out x) x := by\n  rw [EquivalenceOn.out, dif_pos hx]\n  exact @Quotient.mk_out _ (hr.setoid) \u27e8x, hx\u27e9\n\nlemma rel_out (hx : x \u2208 s) : r x (hr.out x) := hr.symm (out_mem hx) hx (out_rel hx)\n\nlemma out_inj (hx : x \u2208 s) (hy : y \u2208 s) (h : r x y) : hr.out x = hr.out y := by\n  simp_rw [EquivalenceOn.out, dif_pos hx, dif_pos hy]\n  congr 1\n  simp_rw [Quotient.out_inj, Quotient.eq]\n  exact h\n\nlemma out_inj' (hx : x \u2208 s) (hy : y \u2208 s) (h : r (hr.out x) (hr.out y)) : hr.out x = hr.out y := by\n  apply out_inj hx hy\n  refine hr.trans hx ?_ hy (rel_out hx) <| hr.trans ?_ ?_ hy h <| out_rel hy\n  all_goals simpa\n\nvariable (hr) in\n/-- The set of representatives of an equivalence relation on a set. -/\ndef reprs : Set \u03b1 := hr.out '' s\n\nlemma out_mem_reprs (hx : x \u2208 s) : hr.out x \u2208 hr.reprs := \u27e8x, hx, rfl\u27e9\n\nlemma reprs_subset : hr.reprs \u2286 s := by\n  rintro _ \u27e8x, hx, rfl\u27e9\n  exact out_mem hx\n\nlemma reprs_inj (hx : x \u2208 hr.reprs) (hy : y \u2208 hr.reprs) (h : r x y) : x = y := by\n  obtain \u27e8x, hx, rfl\u27e9 := hx\n  obtain \u27e8y, hy, rfl\u27e9 := hy\n  exact out_inj' hx hy h\n\nend EquivalenceOn\n\nnamespace Set.Finite\n\nlemma biSup_eq {\u03b1 : Type*} {\u03b9 : Type*} [CompleteLinearOrder \u03b1] {s : Set \u03b9}\n    (hs : s.Finite) (hs' : s.Nonempty) (f : \u03b9 \u2192 \u03b1) :\n    \u2203 i \u2208 s, \u2a06 j \u2208 s, f j = f i := by\n  simpa [sSup_image, eq_comm] using hs'.image f |>.csSup_mem (hs.image f)\n\nend Set.Finite\n\nlemma Real.self_lt_two_rpow (x : \u211d) : x < 2 ^ x := by\n  rcases lt_or_le x 0 with h | h\n  \u00b7 exact h.trans (rpow_pos_of_pos zero_lt_two x)\n  \u00b7 calc\n      _ < (\u230ax\u230b\u208a.succ : \u211d) := Nat.lt_succ_floor x\n      _ \u2264 2 ^ (\u230ax\u230b\u208a : \u211d) := by exact_mod_cast Nat.lt_pow_self one_lt_two\n      _ \u2264 _ := rpow_le_rpow_of_exponent_le one_le_two (Nat.floor_le h)\n\nnamespace Set\n\nopen ComplexConjugate\n\nlemma indicator_eq_indicator_one_mul {\u03b9 M:Type*} [MulZeroOneClass M]\n    (s : Set \u03b9) (f : \u03b9 \u2192 M) (x : \u03b9) : s.indicator f x = s.indicator 1 x * f x := by\n  simp only [indicator]; split_ifs <;> simp\n\nlemma conj_indicator {\u03b1 \ud835\udd5c : Type*} [RCLike \ud835\udd5c] {f : \u03b1 \u2192 \ud835\udd5c} (s : Set \u03b1) (x : \u03b1):\n    conj (s.indicator f x) = s.indicator (conj f) x := by\n  simp only [indicator]; split_ifs <;> simp\n\nend Set\n\nsection Norm\n\nopen Complex\n\n-- for mathlib?\nlemma norm_indicator_one_le {\u03b1 E}\n    [SeminormedAddCommGroup E] [One E] [NormOneClass E] {s : Set \u03b1} (x : \u03b1) :\n    \u2016s.indicator (1 : \u03b1 \u2192 E) x\u2016 \u2264 1 :=\n  Trans.trans (norm_indicator_le_norm_self 1 x) norm_one\n\nlemma norm_exp_I_mul_ofReal (x : \u211d) : \u2016exp (.I * x)\u2016 = 1 := by\n  rw [mul_comm, Complex.norm_exp_ofReal_mul_I]\n\nlemma norm_exp_I_mul_sub_ofReal (x y: \u211d) : \u2016exp (.I * (x - y))\u2016 = 1 := by\n  rw [mul_comm, \u2190 ofReal_sub, Complex.norm_exp_ofReal_mul_I]\n\nend Norm\n\nnamespace MeasureTheory\n\nopen Metric Bornology\nvariable {\ud835\udd5c: Type*}\nvariable [RCLike \ud835\udd5c]\n\nvariable {X \u03b1: Type*}\n\nnamespace HasCompactSupport\n\nvariable [Zero \u03b1] {f : X \u2192 \u03b1}\n\nvariable [PseudoMetricSpace X] [ProperSpace X]\n\ntheorem of_support_subset_closedBall {x : X}\n    {r : \u211d} (hf : support f \u2286 closedBall x r) :\n    HasCompactSupport f :=\n  HasCompactSupport.of_support_subset_isCompact (isCompact_closedBall ..) hf\n\n", "theoremStatement": "theorem of_support_subset_isBounded {s : Set X}\n    (hs : IsBounded s) (hf : support f \u2286 s) :\n    HasCompactSupport f ", "theoremName": "MeasureTheory.HasCompactSupport.of_support_subset_isBounded", "fileCreated": {"commit": "f75995f44d3cb33c8f91a124bbc1149e570a24c5", "date": "2023-12-11"}, "theoremCreated": {"commit": "ec175b9008144d009269ce427b9ad43dbd70d0a5", "date": "2024-12-09"}, "file": "carleson/Carleson/ToMathlib/Misc.lean", "module": "Carleson.ToMathlib.Misc", "jsonFile": "Carleson.ToMathlib.Misc.jsonl", "positionMetadata": {"lineInFile": 373, "tokenPositionInFile": 13821, "theoremPositionInFile": 40}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 20}, "proofMetadata": {"hasProof": true, "proof": ":=\n  IsCompact.closure_of_subset hs.isCompact_closure <| Trans.trans hf subset_closure", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 86}}
{"srcContext": "import Carleson.Discrete.Defs\nimport Carleson.ForestOperator.Forests\nimport Carleson.Discrete.SumEstimates\n\nopen MeasureTheory Measure NNReal Metric Complex Set\nopen scoped ENNReal\nopen Classical -- We use quite some `Finset.filter`\nnoncomputable section\n\nopen scoped ShortVariables\nvariable {X : Type*} {a : \u2115} {q : \u211d} {K : X \u2192 X \u2192 \u2102} {\u03c3\u2081 \u03c3\u2082 : X \u2192 \u2124} {F G : Set X}\n  [MetricSpace X] [ProofData a q K \u03c3\u2081 \u03c3\u2082 F G] [TileStructure Q D \u03ba S o]\n\nvariable {k n j l : \u2115} {p p' u u' : \ud835\udd13 X} {x : X}\n\n/-! ## Section 5.3 -/\n\n/-! Note: the lemmas 5.3.1-5.3.3 are in `TileStructure`. -/\n\n/-- Lemma 5.3.4 -/\nlemma ordConnected_tilesAt : OrdConnected (TilesAt k : Set (\ud835\udd13 X)) := by\n  rw [ordConnected_def]; intro p mp p'' mp'' p' mp'\n  simp_rw [TilesAt, mem_preimage, \ud835\udcd2, mem_diff, aux\ud835\udcd2, mem_setOf] at mp mp'' \u22a2\n  constructor\n  \u00b7 obtain \u27e8J, hJ, _\u27e9 := mp''.1\n    use J, mp'.2.1.trans hJ\n  \u00b7 push_neg at mp \u22a2\n    exact fun J hJ \u21a6 mp.2 J (mp'.1.1.trans hJ)\n\n/-- Lemma 5.3.5 -/\nlemma ordConnected_C : OrdConnected (\u212d k n : Set (\ud835\udd13 X)) := by\n  rw [ordConnected_def]; intro p mp p'' mp'' p' mp'\n  rw [\u212d, mem_setOf] at mp mp'' \u22a2\n  have z := mem_of_mem_of_subset mp' (ordConnected_tilesAt.out mp.1 mp''.1)\n  refine \u27e8z, ?_\u27e9\n  have hk : \u2200 q' \u2208 TilesAt (X := X) k, \u2200 q \u2264 q', dens' k {q'} \u2264 dens' k {q} := fun q' _ q hq \u21a6 by\n    simp_rw [dens', mem_singleton_iff, iSup_iSup_eq_left]; gcongr with l hl a _\n    exact iSup_const_mono fun h \u21a6\n      wiggle_order_11_10 hq (C5_3_3_le (X := X).trans (by norm_num) |>.trans hl) |>.trans h\n  exact \u27e8mp''.2.1.trans_le (hk _ mp''.1 _ mp'.2), (hk _ z _ mp'.1).trans mp.2.2\u27e9\n\n/-- Lemma 5.3.6 -/\nlemma ordConnected_C1 : OrdConnected (\u212d\u2081 k n j : Set (\ud835\udd13 X)) := by\n  rw [ordConnected_def]; intro p mp p'' mp'' p' mp'\n  have mp'\u2081 : p' \u2208 \u212d (X := X) k n := mem_of_mem_of_subset mp'\n    (ordConnected_C.out (mem_of_mem_of_subset mp \u212d\u2081_subset_\u212d)\n      (mem_of_mem_of_subset mp'' \u212d\u2081_subset_\u212d))\n  simp_rw [\u212d\u2081, mem_diff, pre\u212d\u2081, mem_setOf, not_and, not_le] at mp mp'' \u22a2\n  simp_rw [mp.1.1, true_and, true_implies] at mp\n  simp_rw [mp'\u2081, true_and, true_implies]\n  simp_rw [mp''.1.1, true_and, true_implies] at mp''\n  constructor\n  \u00b7 refine mp''.1.trans (Finset.card_le_card fun b mb \u21a6 ?_)\n    simp_rw [Finset.mem_filter, Finset.mem_univ, true_and, \ud835\udd05, mem_setOf] at mb \u22a2\n    have h100 := wiggle_order_11_10 (n := 100) mp'.2 (C5_3_3_le (X := X).trans (by norm_num))\n    exact \u27e8mb.1, h100.trans mb.2\u27e9\n  \u00b7 refine (Finset.card_le_card fun b mb \u21a6 ?_).trans_lt mp.2\n    simp_rw [Finset.mem_filter, Finset.mem_univ, true_and, \ud835\udd05, mem_setOf] at mb \u22a2\n    have h100 := wiggle_order_11_10 (n := 100) mp'.1 (C5_3_3_le (X := X).trans (by norm_num))\n    exact \u27e8mb.1, h100.trans mb.2\u27e9\n\n/-- Lemma 5.3.7 -/\nlemma ordConnected_C2 : OrdConnected (\u212d\u2082 k n j : Set (\ud835\udd13 X)) := by\n  rw [ordConnected_def]; intro p mp p'' mp'' p' mp'\n  have mp\u2081 := mem_of_mem_of_subset mp \u212d\u2082_subset_\u212d\u2081\n  have mp'\u2081 : p' \u2208 \u212d\u2081 (X := X) k n j := mem_of_mem_of_subset mp'\n    (ordConnected_C1.out mp\u2081 (mem_of_mem_of_subset mp'' \u212d\u2082_subset_\u212d\u2081))\n  by_cases e : p = p'; \u00b7 rwa [e] at mp\n  simp_rw [\u212d\u2082, layersAbove, mem_diff, mp'\u2081, true_and]\n  by_contra h; rw [mem_iUnion\u2082] at h; obtain \u27e8l', bl', p'm\u27e9 := h\n  rw [minLayer, mem_setOf, minimal_iff] at p'm\n  have pnm : p \u2209 \u22c3 l'', \u22c3 (_ : l'' < l'), \ud835\udd0f\u2081 k n j l'' := by\n    replace mp := mp.2; contrapose! mp\n    exact mem_of_mem_of_subset mp\n      (iUnion_mono'' fun i \u21a6 iUnion_subset_iUnion_const fun hi \u21a6 (hi.trans_le bl').le)\n  exact absurd (p'm.2 \u27e8mp.1, pnm\u27e9 mp'.1).symm e\n\n/-- Lemma 5.3.8 -/\nlemma ordConnected_C3 : OrdConnected (\u212d\u2083 k n j : Set (\ud835\udd13 X)) := by\n  rw [ordConnected_def]; intro p mp p'' mp'' p' mp'\n  have mp\u2081 := mem_of_mem_of_subset mp \u212d\u2083_subset_\u212d\u2082\n  have mp''\u2081 := mem_of_mem_of_subset mp'' \u212d\u2083_subset_\u212d\u2082\n  have mp'\u2081 : p' \u2208 \u212d\u2082 (X := X) k n j := mem_of_mem_of_subset mp' (ordConnected_C2.out mp\u2081 mp''\u2081)\n  rw [\u212d\u2083_def] at mp'' \u22a2\n  obtain \u27e8-, u, mu, \ud835\udcd8nu, su\u27e9 := mp''; refine \u27e8mp'\u2081, \u27e8u, mu, ?_\u27e9\u27e9\n  exact \u27e8(mp'.2.1.trans_lt (lt_of_le_of_ne su.1 \ud835\udcd8nu)).ne,\n    (wiggle_order_11_10 mp'.2 (C5_3_3_le (X := X).trans (by norm_num))).trans su\u27e9\n\n/-- Lemma 5.3.9 -/\nlemma ordConnected_C4 : OrdConnected (\u212d\u2084 k n j : Set (\ud835\udd13 X)) := by\n  rw [ordConnected_def]; intro p mp p'' mp'' p' mp'\n  have mp''\u2081 := mem_of_mem_of_subset mp'' \u212d\u2084_subset_\u212d\u2083\n  have mp'\u2081 : p' \u2208 \u212d\u2083 (X := X) k n j := mem_of_mem_of_subset mp'\n    (ordConnected_C3.out (mem_of_mem_of_subset mp \u212d\u2084_subset_\u212d\u2083) mp''\u2081)\n  by_cases e : p' = p''; \u00b7 rwa [\u2190 e] at mp''\n  simp_rw [\u212d\u2084, layersBelow, mem_diff, mp'\u2081, true_and]\n  by_contra h; simp_rw [mem_iUnion] at h; obtain \u27e8l', hl', p'm\u27e9 := h\n  rw [maxLayer_def, mem_setOf, maximal_iff] at p'm\n  simp_rw [mem_diff] at p'm\n  have p''nm : p'' \u2209 \u22c3 l'', \u22c3 (_ : l'' < l'), \ud835\udd0f\u2083 k n j l'' := by\n    replace mp'' := mp''.2; contrapose! mp''\n    refine mem_of_mem_of_subset mp'' <| iUnion\u2082_mono' fun i hi \u21a6 \u27e8i, hi.le.trans hl', subset_rfl\u27e9\n  exact absurd (p'm.2 \u27e8mp''\u2081, p''nm\u27e9 mp'.2) e\n\n/-- Lemma 5.3.10 -/\nlemma ordConnected_C5 : OrdConnected (\u212d\u2085 k n j : Set (\ud835\udd13 X)) := by\n  rw [ordConnected_def]; intro p mp p'' mp'' p' mp'\n  have mp\u2081 := mem_of_mem_of_subset mp \u212d\u2085_subset_\u212d\u2084\n  have mp'\u2081 : p' \u2208 \u212d\u2084 (X := X) k n j := mem_of_mem_of_subset mp'\n    (ordConnected_C4.out mp\u2081 (mem_of_mem_of_subset mp'' \u212d\u2085_subset_\u212d\u2084))\n  simp_rw [\u212d\u2085, mem_diff, mp\u2081, mp'\u2081, true_and, \ud835\udd0f\u2084, mem_setOf,\n    mp\u2081, mp'\u2081, true_and] at mp \u22a2\n  contrapose! mp; obtain \u27e8u, mu, s\ud835\udcd8u\u27e9 := mp; use u, mu, mp'.1.1.1.trans s\ud835\udcd8u\n\n/-! ## Section 5.4 and Lemma 5.1.2 -/\n\n/-- The subset `\u212d\u2086(k, n, j)` of `\u212d\u2085(k, n, j)`, given above (5.4.1). -/\ndef \u212d\u2086 (k n j : \u2115) : Set (\ud835\udd13 X) :=\n  { p \u2208 \u212d\u2085 k n j | \u00ac (\ud835\udcd8 p : Set X) \u2286 G' }\n\nlemma \u212d\u2086_subset_\u212d\u2085 : \u212d\u2086 (X := X) k n j \u2286 \u212d\u2085 k n j := sep_subset ..\nlemma \u212d\u2086_subset_\u212d : \u212d\u2086 (X := X) k n j \u2286 \u212d k n := \u212d\u2086_subset_\u212d\u2085.trans \u212d\u2085_subset_\u212d\n\n/-- The subset `\ud835\udd17\u2081(u)` of `\u212d\u2081(k, n, j)`, given in (5.4.1).\nIn lemmas, we will assume `u \u2208 \ud835\udd18\u2081 k n l` -/\ndef \ud835\udd17\u2081 (k n j : \u2115) (u : \ud835\udd13 X) : Set (\ud835\udd13 X) :=\n  { p \u2208 \u212d\u2081 k n j | \ud835\udcd8 p \u2260 \ud835\udcd8 u \u2227 smul 2 p \u2264 smul 1 u }\n\nlemma \ud835\udcd8_lt_of_mem_\ud835\udd17\u2081 (h : p \u2208 \ud835\udd17\u2081 k n j p') : \ud835\udcd8 p < \ud835\udcd8 p' := by\n  rw [\ud835\udd17\u2081, mem_setOf] at h; exact lt_of_le_of_ne h.2.2.1 h.2.1\n\n/-- The subset `\ud835\udd18\u2082(k, n, j)` of `\ud835\udd18\u2081(k, n, j)`, given in (5.4.2). -/\ndef \ud835\udd18\u2082 (k n j : \u2115) : Set (\ud835\udd13 X) :=\n  { u \u2208 \ud835\udd18\u2081 k n j | \u00ac Disjoint (\ud835\udd17\u2081 k n j u) (\u212d\u2086 k n j) }\n\nlemma \ud835\udd18\u2082_subset_\ud835\udd18\u2081 : \ud835\udd18\u2082 k n j \u2286 \ud835\udd18\u2081 (X := X) k n j := fun _ mu \u21a6 mu.1\n\n/-- The relation `\u223c` defined below (5.4.2). It is an equivalence relation on `\ud835\udd18\u2082 k n j`. -/\ndef URel (k n j : \u2115) (u u' : \ud835\udd13 X) : Prop :=\n  u = u' \u2228 \u2203 p \u2208 \ud835\udd17\u2081 k n j u, smul 10 p \u2264 smul 1 u'\n\nnonrec lemma URel.rfl : URel k n j u u := Or.inl rfl\n\n/-- Lemma 5.4.1, part 2. -/\nlemma URel.not_disjoint (hu : u \u2208 \ud835\udd18\u2082 k n j) (hu' : u' \u2208 \ud835\udd18\u2082 k n j) (huu' : URel k n j u u') :\n    \u00acDisjoint (ball_(u) (\ud835\udcac u) 100) (ball_(u') (\ud835\udcac u') 100) := by\n  by_cases e : u = u'; \u00b7 rw [e]; simp\n  simp_rw [URel, e, false_or, \ud835\udd17\u2081, mem_setOf] at huu'; obtain \u27e8p, \u27e8mp, np, sl\u2081\u27e9, sl\u2082\u27e9 := huu'\n  by_cases e' : \ud835\udcd8 p = \ud835\udcd8 u'\n  \u00b7 refine not_disjoint_iff.mpr \u27e8\ud835\udcac u, mem_ball_self (by positivity), ?_\u27e9\n    rw [@mem_ball]\n    have i1 : ball_{\ud835\udcd8 u} (\ud835\udcac u) 1 \u2286 ball_{\ud835\udcd8 p} (\ud835\udcac p) 2 := sl\u2081.2\n    have i2 : ball_{\ud835\udcd8 u'} (\ud835\udcac u') 1 \u2286 ball_{\ud835\udcd8 p} (\ud835\udcac p) 10 := sl\u2082.2\n    replace i1 : \ud835\udcac u \u2208 ball_{\ud835\udcd8 p} (\ud835\udcac p) 2 := i1 (mem_ball_self zero_lt_one)\n    replace i2 : \ud835\udcac u' \u2208 ball_{\ud835\udcd8 p} (\ud835\udcac p) 10 := i2 (mem_ball_self zero_lt_one)\n    rw [e', @mem_ball] at i1 i2\n    calc\n      _ \u2264 dist_{\ud835\udcd8 u'} (\ud835\udcac u) (\ud835\udcac p) + dist_{\ud835\udcd8 u'} (\ud835\udcac u') (\ud835\udcac p) := dist_triangle_right ..\n      _ < 2 + 10 := add_lt_add i1 i2\n      _ < 100 := by norm_num\n  have plu : smul 100 p \u2264 smul 100 u := wiggle_order_100 (smul_mono sl\u2081 le_rfl (by norm_num)) np\n  have plu' : smul 100 p \u2264 smul 100 u' := wiggle_order_100 sl\u2082 e'\n  by_contra h\n  have \ud835\udd05dj : Disjoint (\ud835\udd05 k n u) (\ud835\udd05 k n u') := by\n    simp_rw [\ud835\udd05, disjoint_left, mem_setOf, not_and]; intro q \u27e8_, sl\u27e9 _\n    simp_rw [TileLike.le_def, smul_fst, smul_snd, not_and_or] at sl \u22a2; right\n    have := disjoint_left.mp (h.mono_left sl.2) (mem_ball_self zero_lt_one)\n    rw [not_subset]; use \ud835\udcac q, mem_ball_self zero_lt_one\n  have usp : \ud835\udd05 k n u \u2286 \ud835\udd05 k n p := fun q mq \u21a6 by\n    rw [\ud835\udd05, mem_setOf] at mq \u22a2; exact \u27e8mq.1, plu.trans mq.2\u27e9\n  have u'sp : \ud835\udd05 k n u' \u2286 \ud835\udd05 k n p := fun q mq \u21a6 by\n    rw [\ud835\udd05, mem_setOf] at mq \u22a2; exact \u27e8mq.1, plu'.trans mq.2\u27e9\n  rw [\ud835\udd18\u2082, mem_setOf, \ud835\udd18\u2081, mem_setOf] at hu hu'\n  apply absurd (card_\ud835\udd05_of_mem_\u212d\u2081 mp).2; rw [not_lt]\n  calc\n    _ = 2 ^ j + 2 ^ j := Nat.two_pow_succ j\n    _ \u2264 (\ud835\udd05 k n u).toFinset.card + (\ud835\udd05 k n u').toFinset.card :=\n      add_le_add (card_\ud835\udd05_of_mem_\u212d\u2081 hu.1.1).1 (card_\ud835\udd05_of_mem_\u212d\u2081 hu'.1.1).1\n    _ = (\ud835\udd05 k n u \u222a \ud835\udd05 k n u').toFinset.card := by\n      rw [toFinset_union]; refine (Finset.card_union_of_disjoint ?_).symm\n      simpa using \ud835\udd05dj\n    _ \u2264 _ := by\n      apply Finset.card_le_card\n      simp_rw [toFinset_union, subset_toFinset, Finset.coe_union, coe_toFinset, union_subset_iff]\n      exact \u27e8usp, u'sp\u27e9\n\n/-- Lemma 5.4.1, part 1. -/\nlemma URel.eq (hu : u \u2208 \ud835\udd18\u2082 k n j) (hu' : u' \u2208 \ud835\udd18\u2082 k n j) (huu' : URel k n j u u') : \ud835\udcd8 u = \ud835\udcd8 u' := by\n  by_cases e : u = u'; \u00b7 rw [e]\n  have ndj := not_disjoint hu hu' huu'\n  have n\u2081 := (hu.1.2 _ hu'.1.1).mt ndj\n  rw [disjoint_comm] at ndj\n  have n\u2082 := (hu'.1.2 _ hu.1.1).mt ndj\n  simp_rw [URel, e, false_or, \ud835\udd17\u2081, mem_setOf] at huu'; obtain \u27e8p, \u27e8_, _, sl\u2081\u27e9, sl\u2082\u27e9 := huu'\n  rcases le_or_lt (\ud835\udd30 u) (\ud835\udd30 u') with h | h\n  \u00b7 exact eq_of_le_of_not_lt (Grid.le_dyadic h sl\u2081.1 sl\u2082.1) n\u2081\n  \u00b7 exact (eq_of_le_of_not_lt (Grid.le_dyadic h.le sl\u2082.1 sl\u2081.1) n\u2082).symm\n\n/-- Helper for 5.4.2 that is also used in 5.4.9. -/\nlemma urel_of_not_disjoint {x y : \ud835\udd13 X} (my : y \u2208 \ud835\udd18\u2082 k n j) (xye : \ud835\udcd8 x = \ud835\udcd8 y)\n    (nd : \u00acDisjoint (ball_(x) (\ud835\udcac x) 100) (ball_(y) (\ud835\udcac y) 100)) : URel k n j y x := by\n  rw [not_disjoint_iff] at nd\n  obtain \u27e8(\u03d1 : \u0398 X), (\u03d1x : \u03d1 \u2208 ball_{\ud835\udcd8 x} (\ud835\udcac x) 100), (\u03d1y : \u03d1 \u2208 ball_{\ud835\udcd8 y} (\ud835\udcac y) 100)\u27e9 := nd\n  rw [\ud835\udd18\u2082, mem_setOf, not_disjoint_iff] at my; obtain \u27e8p, hp, _\u27e9 := my.2\n  suffices w : ball_(x) (\ud835\udcac x) 1 \u2286 ball_(y) (\ud835\udcac y) 500 by\n    right; use p, hp; obtain \u27e8_, np, sl\u27e9 := hp\n    have hpy : smul 10 p \u2264 smul 500 y :=\n      (smul_mono_left (by norm_num)).trans (wiggle_order_500 sl np)\n    exact \u27e8(xye \u25b8 sl.1 : \ud835\udcd8 p \u2264 \ud835\udcd8 x), hpy.2.trans w\u27e9\n  intro (q : \u0398 X) (mq : q \u2208 ball_{\ud835\udcd8 x} (\ud835\udcac x) 1)\n  rw [@mem_ball] at mq \u22a2\n  calc\n    _ \u2264 dist_(y) q \u03d1 + dist_(y) \u03d1 (\ud835\udcac y) := dist_triangle ..\n    _ \u2264 dist_(y) q (\ud835\udcac x) + dist_(y) \u03d1 (\ud835\udcac x) + dist_(y) \u03d1 (\ud835\udcac y) := by\n      gcongr; apply dist_triangle_right\n    _ < 1 + 100 + 100 := by\n      gcongr\n      \u00b7 rwa [xye] at mq\n      \u00b7 rwa [@mem_ball, xye] at \u03d1x\n      \u00b7 rwa [@mem_ball] at \u03d1y\n    _ < _ := by norm_num\n\n/-- Lemma 5.4.2. -/\nlemma equivalenceOn_urel : EquivalenceOn (URel (X := X) k n j) (\ud835\udd18\u2082 k n j) where\n  refl _ _ := .rfl\n  trans {x y z} mx my mz xy yz := by\n    by_cases xny : x = y; \u00b7 rwa [xny]\n    have xye := URel.eq mx my xy\n    have hxy := URel.not_disjoint mx my xy\n    rw [not_disjoint_iff] at hxy\n    obtain \u27e8(\u03d1 : \u0398 X), (\u03d1x : \u03d1 \u2208 ball_{\ud835\udcd8 x} (\ud835\udcac x) 100), (\u03d1y : \u03d1 \u2208 ball_{\ud835\udcd8 y} (\ud835\udcac y) 100)\u27e9 := hxy\n    have yze := URel.eq my mz yz\n    have hyz := URel.not_disjoint my mz yz\n    rw [not_disjoint_iff] at hyz\n    obtain \u27e8(\u03b8 : \u0398 X), (\u03b8y : \u03b8 \u2208 ball_{\ud835\udcd8 y} (\ud835\udcac y) 100), (\u03b8z : \u03b8 \u2208 ball_{\ud835\udcd8 z} (\ud835\udcac z) 100)\u27e9 := hyz\n    simp_rw [URel, xny, false_or] at xy; obtain \u27e8p, mp, sp\u27e9 := xy\n    suffices ball_(z) (\ud835\udcac z) 1 \u2286 ball_(x) (\ud835\udcac x) 500 by\n      right; use p, mp; obtain \u27e8_, np, sl\u27e9 := mp\n      have w : ball_(x) (\ud835\udcac x) 500 \u2286 ball_(p) (\ud835\udcac p) 4 := (wiggle_order_500 sl np).2\n      exact \u27e8(yze \u25b8 xye \u25b8 sl.1 : \ud835\udcd8 p \u2264 \ud835\udcd8 z), (this.trans w).trans (ball_subset_ball (by norm_num))\u27e9\n    intro (q : \u0398 X) (mq : q \u2208 ball_{\ud835\udcd8 z} (\ud835\udcac z) 1)\n    rw [@mem_ball] at mq \u22a2\n    calc\n      _ \u2264 dist_(x) q \u03d1 + dist_(x) \u03d1 (\ud835\udcac x) := dist_triangle ..\n      _ < dist_(x) q \u03d1 + 100 := by gcongr; rwa [@mem_ball] at \u03d1x\n      _ \u2264 dist_(x) q (\ud835\udcac y) + dist_(x) \u03d1 (\ud835\udcac y) + 100 := by gcongr; exact dist_triangle_right ..\n      _ < dist_(x) q (\ud835\udcac y) + 100 + 100 := by gcongr; rwa [@mem_ball, \u2190 xye] at \u03d1y\n      _ \u2264 dist_(x) q \u03b8 + dist_(x) \u03b8 (\ud835\udcac y) + 100 + 100 := by gcongr; exact dist_triangle ..\n      _ < dist_(x) q \u03b8 + 100 + 100 + 100 := by gcongr; rwa [@mem_ball, \u2190 xye] at \u03b8y\n      _ \u2264 dist_(x) q (\ud835\udcac z) + dist_(x) \u03b8 (\ud835\udcac z) + 100 + 100 + 100 := by\n        gcongr; exact dist_triangle_right ..\n      _ < 1 + 100 + 100 + 100 + 100 := by\n        gcongr\n        \u00b7 rwa [\u2190 yze, \u2190 xye] at mq\n        \u00b7 rwa [@mem_ball, \u2190 yze, \u2190 xye] at \u03b8z\n      _ < _ := by norm_num\n  symm {x y} mx my xy := urel_of_not_disjoint my (URel.eq mx my xy) (URel.not_disjoint mx my xy)\n\n/-- `\ud835\udd18\u2083(k, n, j) \u2286 \ud835\udd18\u2082 k n j` is an arbitary set of representatives of `URel` on `\ud835\udd18\u2082 k n j`,\ngiven above (5.4.5). -/\ndef \ud835\udd18\u2083 (k n j : \u2115) : Set (\ud835\udd13 X) :=\n  (equivalenceOn_urel (k := k) (n := n) (j := j)).reprs\n\nlemma \ud835\udd18\u2083_subset_\ud835\udd18\u2082 : \ud835\udd18\u2083 k n j \u2286 \ud835\udd18\u2082 (X := X) k n j := EquivalenceOn.reprs_subset\n\n/-- The subset `\ud835\udd17\u2082(u)` of `\u212d\u2086(k, n, j)`, given in (5.4.5).\nIn lemmas, we will assume `u \u2208 \ud835\udd18\u2083 k n l` -/\ndef \ud835\udd17\u2082 (k n j : \u2115) (u : \ud835\udd13 X) : Set (\ud835\udd13 X) :=\n  \u212d\u2086 k n j \u2229 \u22c3 (u' \u2208 \ud835\udd18\u2082 k n j) (_ : URel k n j u u'), \ud835\udd17\u2081 k n j u'\n\nlemma \ud835\udd17\u2082_subset_\u212d\u2086 : \ud835\udd17\u2082 k n j u \u2286 \u212d\u2086 k n j := inter_subset_left ..\n\n/-- Lemma 5.4.3 -/\nlemma C6_forest : \u212d\u2086 (X := X) k n j = \u22c3 u \u2208 \ud835\udd18\u2083 k n j, \ud835\udd17\u2082 k n j u := by\n  ext p; constructor <;> intro h\n  \u00b7 have hp : p \u2208 \u212d\u2083 k n j := (\u212d\u2086_subset_\u212d\u2085 |>.trans \u212d\u2085_subset_\u212d\u2084 |>.trans \u212d\u2084_subset_\u212d\u2083) h\n    rw [\u212d\u2083, mem_diff, \ud835\udd0f\u2082, mem_setOf] at hp\n    have mp := hp.1\n    simp_rw [hp.1, true_and, not_not] at hp\n    obtain \u27e8u, mu, np, sl\u27e9 := hp\n    have mp' : p \u2208 \ud835\udd17\u2081 k n j u := by\n      rw [\ud835\udd17\u2081, mem_setOf]; exact \u27e8\u212d\u2082_subset_\u212d\u2081 mp, np, sl\u27e9\n    have mu' : u \u2208 \ud835\udd18\u2082 k n j := by\n      rw [\ud835\udd18\u2082, mem_setOf]; exact \u27e8mu, not_disjoint_iff.mpr \u27e8_, mp', h\u27e9\u27e9\n    let rr := equivalenceOn_urel (X := X) (k := k) (n := n) (j := j)\n    rw [mem_iUnion\u2082]; use rr.out u, (rr.out_mem_reprs mu')\n    refine \u27e8h, ?_\u27e9; rw [mem_iUnion\u2082]; use u, mu'; rw [mem_iUnion]; use rr.out_rel mu'\n  \u00b7 rw [mem_iUnion\u2082] at h; obtain \u27e8_, _, mp, _\u27e9 := h; exact mp\n\n/-- This one could deserve a lemma in the blueprint, as it is needed to decompose the sum\nof Carleson operators over disjoint subfamilies. -/\nlemma forest_disjoint : (\ud835\udd18\u2083 k n j).PairwiseDisjoint (fun u \u21a6 \ud835\udd17\u2082 (X := X) k n j u) := by\n  intro u hu u' hu' huu'\n  simp only [Function.onFun]\n  apply disjoint_left.2 (fun p pu pu' \u21a6 huu' ?_)\n  simp only [\ud835\udd17\u2082, mem_inter_iff, mem_iUnion, exists_prop, exists_and_left] at pu pu'\n  rcases pu.2 with \u27e8v, v_mem, v_rel, pv\u27e9\n  rcases pu'.2 with \u27e8v', v'_mem, v'_rel, pv'\u27e9\n  have E : URel k n j v v' :=\n    Or.inr \u27e8p, pv, smul_mono pv'.2.2 le_rfl (by norm_num)\u27e9\n  have : URel k n j u v' :=\n    (equivalenceOn_urel (X := X)).trans (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 hu) v_mem v'_mem v_rel E\n  have : URel k n j u u' := by\n    apply (equivalenceOn_urel (X := X)).trans (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 hu) v'_mem (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 hu') this\n    exact (equivalenceOn_urel (X := X)).symm (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 hu') v'_mem v'_rel\n  exact (equivalenceOn_urel (X := X)).reprs_inj hu hu' this\n\n/-- Lemma 5.4.4, verifying (2.0.32) -/\nlemma forest_geometry (hu : u \u2208 \ud835\udd18\u2083 k n j) (hp : p \u2208 \ud835\udd17\u2082 k n j u) : smul 4 p \u2264 smul 1 u := by\n  rw [\ud835\udd17\u2082, mem_inter_iff, mem_iUnion\u2082] at hp\n  obtain \u27e8_, u', mu', w\u27e9 := hp; rw [mem_iUnion] at w; obtain \u27e8ru, mp'\u27e9 := w\n  rw [\ud835\udd17\u2081, mem_setOf] at mp'; obtain \u27e8_, np, sl\u27e9 := mp'\n  have xye := URel.eq (EquivalenceOn.reprs_subset hu) mu' ru\n  have huu' := URel.not_disjoint (EquivalenceOn.reprs_subset hu) mu' ru\n  rw [not_disjoint_iff] at huu'\n  obtain \u27e8(\u03d1 : \u0398 X), (\u03d1x : \u03d1 \u2208 ball_{\ud835\udcd8 u} (\ud835\udcac u) 100), (\u03d1y : \u03d1 \u2208 ball_{\ud835\udcd8 u'} (\ud835\udcac u') 100)\u27e9 := huu'\n  suffices ball_(u) (\ud835\udcac u) 1 \u2286 ball_(u') (\ud835\udcac u') 500 by\n    have w : smul 4 p \u2264 smul 500 u' := (wiggle_order_500 sl np)\n    exact \u27e8(xye \u25b8 sl.1 : \ud835\udcd8 p \u2264 \ud835\udcd8 u), w.2.trans this\u27e9\n  intro (q : \u0398 X) (mq : q \u2208 ball_{\ud835\udcd8 u} (\ud835\udcac u) 1)\n  rw [@mem_ball] at mq \u22a2\n  calc\n    _ \u2264 dist_(u') q \u03d1 + dist_(u') \u03d1 (\ud835\udcac u') := dist_triangle ..\n    _ \u2264 dist_(u') q (\ud835\udcac u) + dist_(u') \u03d1 (\ud835\udcac u) + dist_(u') \u03d1 (\ud835\udcac u') := by\n      gcongr; apply dist_triangle_right\n    _ < 1 + 100 + 100 := by\n      gcongr\n      \u00b7 rwa [xye] at mq\n      \u00b7 rwa [@mem_ball, xye] at \u03d1x\n      \u00b7 rwa [@mem_ball] at \u03d1y\n    _ < _ := by norm_num\n\n/-- Lemma 5.4.5, verifying (2.0.33) -/\nlemma forest_convex : OrdConnected (\ud835\udd17\u2082 k n j u) := by\n  rw [ordConnected_def]; intro p mp p'' mp'' p' mp'\n  have mp'\u2085 : p' \u2208 \u212d\u2085 (X := X) k n j :=\n    (ordConnected_C5.out ((\ud835\udd17\u2082_subset_\u212d\u2086.trans \u212d\u2086_subset_\u212d\u2085) mp)\n      ((\ud835\udd17\u2082_subset_\u212d\u2086.trans \u212d\u2086_subset_\u212d\u2085) mp'')) mp'\n  have mp'\u2086 : p' \u2208 \u212d\u2086 k n j := by\n    have hp := \ud835\udd17\u2082_subset_\u212d\u2086 mp; rw [\u212d\u2086, mem_setOf] at hp \u22a2\n    refine \u27e8mp'\u2085, ?_\u27e9; have hpG := hp.2; contrapose! hpG\n    exact mp'.1.1.1.trans hpG\n  simp_rw [\ud835\udd17\u2082, mem_inter_iff, mp'\u2086, true_and, mem_iUnion\u2082, mem_iUnion] at mp'' \u22a2\n  obtain \u27e8u', mu', ru, _, np'', sl\u27e9 := mp''.2\n  have pnu : \ud835\udcd8 p' < \ud835\udcd8 u' := (mp'.2.1).trans_lt (lt_of_le_of_ne sl.1 np'')\n  use u', mu', ru; rw [\ud835\udd17\u2081, mem_setOf]\n  use (\u212d\u2085_subset_\u212d\u2084 |>.trans \u212d\u2084_subset_\u212d\u2083 |>.trans \u212d\u2083_subset_\u212d\u2082 |>.trans \u212d\u2082_subset_\u212d\u2081) mp'\u2085, pnu.ne\n  exact (wiggle_order_11_10 mp'.2 (C5_3_3_le (X := X).trans (by norm_num))).trans sl\n\n/-- Lemma 5.4.6, verifying (2.0.36)\nNote: swapped `u` and `u'` to match (2.0.36) -/\nlemma forest_separation (hu : u \u2208 \ud835\udd18\u2083 k n j) (hu' : u' \u2208 \ud835\udd18\u2083 k n j) (huu' : u \u2260 u')\n    (hp : p \u2208 \ud835\udd17\u2082 k n j u') (h : \ud835\udcd8 p \u2264 \ud835\udcd8 u) : 2 ^ (Z * (n + 1)) < dist_(p) (\ud835\udcac p) (\ud835\udcac u) := by\n  simp_rw [\ud835\udd17\u2082, mem_inter_iff, mem_iUnion\u2082, mem_iUnion] at hp\n  obtain \u27e8mp\u2086, v, mv, rv, \u27e8-, np, sl\u27e9\u27e9 := hp\n  obtain \u27e8p', mp', lp', sp'\u27e9 := exists_scale_add_le_of_mem_layersAbove <|\n    (\u212d\u2086_subset_\u212d\u2085 |>.trans \u212d\u2085_subset_\u212d\u2084 |>.trans \u212d\u2084_subset_\u212d\u2083 |>.trans \u212d\u2083_subset_\u212d\u2082) mp\u2086\n  have np'u : \u00acURel k n j v u := by\n    by_contra h; apply absurd (Eq.symm _) huu'\n    replace h := equivalenceOn_urel.trans (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 hu') mv (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 hu) rv h\n    exact EquivalenceOn.reprs_inj hu' hu h\n  have vnu : v \u2260 u := by by_contra h; subst h; exact absurd URel.rfl np'u\n  simp_rw [URel, vnu, false_or, not_exists, not_and] at np'u\n  have mpt : p' \u2208 \ud835\udd17\u2081 k n j v := by\n    refine \u27e8minLayer_subset mp', ?_, ?_\u27e9\n    \u00b7 exact (lp'.1.trans_lt (lt_of_le_of_ne sl.1 np)).ne\n    \u00b7 exact (wiggle_order_11_10 lp' (C5_3_3_le (X := X).trans (by norm_num))).trans sl\n  specialize np'u p' mpt\n  have \ud835\udcd8p'u : \ud835\udcd8 p' \u2264 \ud835\udcd8 u := lp'.1.trans h\n  simp_rw [TileLike.le_def, smul_fst, smul_snd, \ud835\udcd8p'u, true_and,\n    not_subset_iff_exists_mem_not_mem] at np'u\n  obtain \u27e8(q : \u0398 X), mq, nq\u27e9 := np'u\n  simp_rw [mem_ball, not_lt] at mq nq\n  have d8 : 8 < dist_(p') (\ud835\udcac p) (\ud835\udcac u) :=\n    calc\n      _ = 10 - 1 - 1 := by norm_num\n      _ < 10 - 1 - dist_(u) q (\ud835\udcac u) := by gcongr\n      _ \u2264 10 - 1 - dist_(p') q (\ud835\udcac u) := tsub_le_tsub_left (Grid.dist_mono \ud835\udcd8p'u) _\n      _ \u2264 dist_(p') q (\ud835\udcac p') - 1 - dist_(p') q (\ud835\udcac u) := by gcongr\n      _ < dist_(p') q (\ud835\udcac p') - dist_(p') (\ud835\udcac p) (\ud835\udcac p') - dist_(p') q (\ud835\udcac u) := by\n        gcongr; rw [\u2190 @mem_ball]; exact subset_cball (lp'.2 \ud835\udcac_mem_\u03a9)\n      _ \u2264 _ := by\n        rw [sub_le_iff_le_add', sub_le_iff_le_add]\n        nth_rw 3 [dist_comm]; apply dist_triangle4\n  have Znpos : 0 < Z * (n + 1) := by rw [defaultZ]; positivity\n  let d : \u2115 := (\ud835\udd30 p - \ud835\udd30 p').toNat\n  have sd : \ud835\udd30 p' + d = \ud835\udd30 p := by simp_rw [d]; rw [Int.toNat_sub_of_le] <;> omega\n  have d1 : dist_(p') (\ud835\udcac p) (\ud835\udcac u) \u2264 C2_1_2 a ^ d * dist_(p) (\ud835\udcac p) (\ud835\udcac u) :=\n    Grid.dist_strictMono_iterate lp'.1 sd\n  have Cdpos : 0 < C2_1_2 a ^ d := by rw [C2_1_2]; positivity\n  have Cidpos : 0 < (C2_1_2 a)\u207b\u00b9 ^ d := by rw [C2_1_2]; positivity\n  calc\n    _ \u2264 (C2_1_2 a)\u207b\u00b9 ^ (Z * (n + 1)) := by\n      refine pow_le_pow_left\u2080 zero_le_two ?_ _\n      nth_rw 1 [C2_1_2, \u2190 Real.inv_rpow zero_le_two, \u2190 Real.rpow_neg_one,\n        \u2190 Real.rpow_mul zero_le_two, neg_one_mul, neg_mul, neg_neg, \u2190 Real.rpow_one 2]\n      apply Real.rpow_le_rpow_of_exponent_le one_le_two\n      norm_cast; linarith [four_le_a X]\n    _ \u2264 (C2_1_2 a)\u207b\u00b9 ^ d := by\n      refine pow_le_pow_right\u2080 ?_ (by omega)\n      simp_rw [one_le_inv_iff\u2080, C2_1_2_le_one (X := X), and_true, C2_1_2]; positivity\n    _ \u2264 (C2_1_2 a)\u207b\u00b9 ^ d * 8 := by nth_rw 1 [\u2190 mul_one (_ ^ d)]; gcongr; norm_num\n    _ < (C2_1_2 a)\u207b\u00b9 ^ d * dist_(p') (\ud835\udcac p) (\ud835\udcac u) := by gcongr\n    _ \u2264 _ := by\n      rwa [\u2190 mul_le_mul_iff_of_pos_left Cdpos, inv_pow, \u2190 mul_assoc, mul_inv_cancel\u2080 Cdpos.ne',\n        one_mul]\n\n/-- Lemma 5.4.7, verifying (2.0.37) -/\nlemma forest_inner (hu : u \u2208 \ud835\udd18\u2083 k n j) (hp : p \u2208 \ud835\udd17\u2082 k n j u) :\n    ball (\ud835\udd20 p) (8 * D ^ \ud835\udd30 p) \u2286 \ud835\udcd8 u := by\n  have p\u2084 := (\ud835\udd17\u2082_subset_\u212d\u2086.trans \u212d\u2086_subset_\u212d\u2085 |>.trans \u212d\u2085_subset_\u212d\u2084) hp\n  have p\u2081 := (\u212d\u2084_subset_\u212d\u2083.trans \u212d\u2083_subset_\u212d\u2082 |>.trans \u212d\u2082_subset_\u212d\u2081) p\u2084\n  obtain \u27e8q, mq, lq, sq\u27e9 := exists_le_add_scale_of_mem_layersBelow p\u2084\n  obtain \u27e8-, u'', mu'', nu'', sl\u27e9 := \u212d\u2083_def.mp (maxLayer_subset mq)\n  replace nu'' : \ud835\udcd8 q < \ud835\udcd8 u'' := lt_of_le_of_ne sl.1 nu''\n  have s2 : smul 2 p \u2264 smul 2 q := wiggle_order_11_10 lq (C5_3_3_le (X := X).trans (by norm_num))\n  have s2' : smul 2 p \u2264 smul 1 u'' := s2.trans sl\n  have s10 : smul 10 p \u2264 smul 1 u'' := smul_mono s2' le_rfl (by norm_num)\n  simp_rw [\ud835\udd17\u2082, mem_inter_iff, mem_iUnion\u2082, mem_iUnion] at hp\n  obtain \u27e8p\u2086, u', mu', ru', pu'\u27e9 := hp\n  have ur : URel k n j u' u'' := Or.inr \u27e8p, pu', s10\u27e9\n  have hu'' : u'' \u2208 \ud835\udd18\u2082 k n j := by\n    rw [\ud835\udd18\u2082, mem_setOf, not_disjoint_iff]\n    refine \u27e8mu'', \u27e8p, ?_, p\u2086\u27e9\u27e9\n    simpa [\ud835\udd17\u2081, p\u2081, s2'] using (lq.1.trans_lt nu'').ne\n  have ru'' : URel k n j u u'' := equivalenceOn_urel.trans (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 hu) mu' hu'' ru' ur\n  have qlu : \ud835\udcd8 q < \ud835\udcd8 u := URel.eq (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 hu) hu'' ru'' \u25b8 nu''\n  have squ : \ud835\udd30 q < \ud835\udd30 u := (Grid.lt_def.mp qlu).2\n  have spu : \ud835\udd30 p \u2264 \ud835\udd30 u - (Z * (n + 1) : \u2115) - 1 := by omega\n  have \u27e8I, sI, plI, Ilu\u27e9 : \u2203 I, s I = \ud835\udd30 u - (Z * (n + 1) : \u2115) - 1 \u2227 \ud835\udcd8 p \u2264 I \u2227 I \u2264 \ud835\udcd8 u := by\n    apply Grid.exists_sandwiched (lq.1.trans qlu.le) (\ud835\udd30 u - (Z * (n + 1) : \u2115) - 1)\n    refine \u27e8spu, ?_\u27e9\n    change _ \u2264 \ud835\udd30 u\n    omega\n  have bI : I \u2209 \ud835\udcdb n u := by\n    have p\u2085 := \u212d\u2086_subset_\u212d\u2085 p\u2086\n    rw [\u212d\u2085_def] at p\u2085; replace p\u2085 := p\u2085.2; contrapose! p\u2085\n    use u, (\ud835\udd18\u2083_subset_\ud835\udd18\u2082.trans \ud835\udd18\u2082_subset_\ud835\udd18\u2081) hu, plI.1.trans (subset_biUnion_of_mem p\u2085)\n  rw [\ud835\udcdb, mem_setOf, not_and] at bI; specialize bI Ilu\n  rw [not_and, not_not] at bI; specialize bI (by omega); rw [\u2190 sI] at spu\n  rcases spu.eq_or_lt with h | h\n  \u00b7 have hI : \ud835\udcd8 p = I := by\n      apply eq_of_le_of_not_lt plI; rw [Grid.lt_def, not_and_or, not_lt]; exact Or.inr h.symm.le\n    rwa [\u2190 hI] at bI\n  \u00b7 apply subset_trans (ball_subset_ball' _) bI\n    have ds : c (\ud835\udcd8 p) \u2208 ball (c I) (4 * D ^ s I) := (plI.1.trans Grid_subset_ball) Grid.c_mem_Grid\n    rw [mem_ball] at ds\n    calc\n      _ \u2264 4 * D * (D : \u211d) ^ \ud835\udd30 p + 4 * D ^ s I := by\n        gcongr\n        \u00b7 linarith [four_le_realD X]\n        \u00b7 exact ds.le\n      _ = 4 * D ^ (\ud835\udd30 p + 1) + 4 * D ^ s I := by\n        rw [mul_assoc]; congr; rw [mul_comm, \u2190 zpow_add_one\u2080 (defaultD_pos _).ne']\n      _ \u2264 4 * D ^ s I + 4 * D ^ s I := by\n        gcongr\n        \u00b7 exact one_le_D\n        \u00b7 omega\n      _ = _ := by ring\n\n/-- The multiplicity appearing in Lemma 5.4.8. -/\ndef C5_4_8 (n : \u2115) : \u2115 := (4 * n + 12) * 2 ^ n\n\nlemma exists_smul_le_of_\ud835\udd18\u2083 (u : \ud835\udd18\u2083 k n j) : \u2203 m : \ud835\udd10 (X := X) k n, smul 100 u.1 \u2264 smul 1 m.1 := by\n  obtain \u27e8u, mu\u27e9 := u\n  replace mu := (\ud835\udd18\u2083_subset_\ud835\udd18\u2082.trans \ud835\udd18\u2082_subset_\ud835\udd18\u2081 |>.trans \ud835\udd18\u2081_subset_\u212d\u2081) mu\n  rw [\u212d\u2081, mem_diff, pre\u212d\u2081, mem_setOf, filter_mem_univ_eq_toFinset] at mu\n  replace mu := (show 0 < 2 ^ j by positivity).trans_le mu.1.2\n  rw [Finset.card_pos] at mu; obtain \u27e8m, hm\u27e9 := mu\n  rw [mem_toFinset, \ud835\udd05] at hm; exact \u27e8\u27e8m, hm.1\u27e9, hm.2\u27e9\n\nvariable (k n j) in\n/-- The good choice of an element to get a contradiction in the proof of Lemma 5.4.8. -/\ndef mf (u : \ud835\udd18\u2083 (X := X) k n j) : \ud835\udd10 (X := X) k n := (exists_smul_le_of_\ud835\udd18\u2083 u).choose\n\nlemma mf_injOn : InjOn (mf k n j) {u | x \u2208 \ud835\udcd8 u.1} := fun u mu u' mu' e \u21a6 by\n  set m := mf k n j u\n  have iu : smul 100 u.1 \u2264 smul 1 m.1 := (exists_smul_le_of_\ud835\udd18\u2083 u).choose_spec\n  have iu' : smul 100 u'.1 \u2264 smul 1 m.1 := e \u25b8 (exists_smul_le_of_\ud835\udd18\u2083 u').choose_spec\n  have su : ball_{\ud835\udcd8 m.1} (\ud835\udcac m.1) 1 \u2286 ball_{\ud835\udcd8 u.1} (\ud835\udcac u.1) 100 := iu.2\n  have su' : ball_{\ud835\udcd8 m.1} (\ud835\udcac m.1) 1 \u2286 ball_{\ud835\udcd8 u'.1} (\ud835\udcac u'.1) 100 := iu'.2\n  have nd : \u00acDisjoint (ball_{\ud835\udcd8 u.1} (\ud835\udcac u.1) 100) (ball_{\ud835\udcd8 u'.1} (\ud835\udcac u'.1) 100) := by\n    rw [not_disjoint_iff]\n    use \ud835\udcac m.1, su (mem_ball_self zero_lt_one), su' (mem_ball_self zero_lt_one)\n  by_contra! h; rw [\u2190 Subtype.coe_ne_coe] at h; apply absurd _ nd\n  have nr : \u00acURel k n j u.1 u'.1 := by contrapose! h; exact EquivalenceOn.reprs_inj u.2 u'.2 h\n  have n\ud835\udcd8 : \ud835\udcd8 u.1 \u2260 \ud835\udcd8 u'.1 := by\n    contrapose! nr; rw [disjoint_comm] at nd\n    exact urel_of_not_disjoint (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 u.2) nr.symm nd\n  rcases le_or_lt (s (\ud835\udcd8 u.1)) (s (\ud835\udcd8 u'.1)) with hs | hs\n  \u00b7 have hu := lt_of_le_of_ne ((le_or_disjoint hs).resolve_right\n      (not_disjoint_iff.mpr \u27e8_, mu, mu'\u27e9)) n\ud835\udcd8\n    have u\u2081 := (\ud835\udd18\u2083_subset_\ud835\udd18\u2082.trans \ud835\udd18\u2082_subset_\ud835\udd18\u2081) u.2\n    exact u\u2081.2 u' ((\ud835\udd18\u2083_subset_\ud835\udd18\u2082.trans \ud835\udd18\u2082_subset_\ud835\udd18\u2081 |>.trans \ud835\udd18\u2081_subset_\u212d\u2081) u'.2) hu\n  \u00b7 have hu := lt_of_le_of_ne ((le_or_disjoint hs.le).resolve_right\n      (not_disjoint_iff.mpr \u27e8_, mu', mu\u27e9)) n\ud835\udcd8.symm\n    have u'\u2081 := (\ud835\udd18\u2083_subset_\ud835\udd18\u2082.trans \ud835\udd18\u2082_subset_\ud835\udd18\u2081) u'.2\n    exact (u'\u2081.2 u ((\ud835\udd18\u2083_subset_\ud835\udd18\u2082.trans \ud835\udd18\u2082_subset_\ud835\udd18\u2081 |>.trans \ud835\udd18\u2081_subset_\u212d\u2081) u.2) hu).symm\n\nlemma stackSize_\ud835\udd18\u2083_le_\ud835\udd10 (x : X) : stackSize (\ud835\udd18\u2083 k n j) x \u2264 stackSize (\ud835\udd10 k n) x := by\n  let mf' : \ud835\udd13 X \u2192 \ud835\udd13 X := fun u \u21a6 if mu : u \u2208 \ud835\udd18\u2083 k n j then mf k n j \u27e8u, mu\u27e9 else default\n  simp_rw [stackSize, indicator_apply, Pi.one_apply, Finset.sum_boole, Nat.cast_id]\n  refine Finset.card_le_card_of_injOn mf' (fun u mu \u21a6 ?_) (fun u mu u' mu' e \u21a6 ?_)\n  \u00b7 simp_rw [Finset.mem_filter, Finset.mem_univ, true_and] at mu \u22a2\n    simp_rw [mf', mu.1, dite_true]\n    have hu : \ud835\udcd8 u \u2264 \ud835\udcd8 (mf k n j \u27e8u, mu.1\u27e9) := (exists_smul_le_of_\ud835\udd18\u2083 \u27e8u, mu.1\u27e9).choose_spec.1\n    exact \u27e8(mf k n j \u27e8u, mu.1\u27e9).2, hu.1 mu.2\u27e9\n  \u00b7 simp_rw [Finset.coe_filter, mem_setOf, Finset.mem_filter, Finset.mem_univ, true_and] at mu mu'\n    simp_rw [mf', mu.1, mu'.1, dite_true, Subtype.val_inj] at e\n    simpa using mf_injOn mu.2 mu'.2 e\n\n/-- Lemma 5.4.8, used to verify that \ud835\udd18\u2084 satisfies 2.0.34. -/\nlemma forest_stacking (x : X) (hkn : k \u2264 n) : stackSize (\ud835\udd18\u2083 (X := X) k n j) x \u2264 C5_4_8 n := by\n  by_contra! h\n  let C : Finset (\ud835\udd13 X) := { u | u \u2208 \ud835\udd18\u2083 (X := X) k n j \u2227 x \u2208 \ud835\udcd8 u }\n  have Cc : C.card = stackSize (\ud835\udd18\u2083 k n j) x := by\n    simp_rw [stackSize, indicator_apply, Pi.one_apply, Finset.sum_boole, Nat.cast_id,\n      C, Grid.mem_def, Finset.filter_filter]\n  have Cn : C.Nonempty := by\n    by_contra! Ce; rw [Finset.not_nonempty_iff_eq_empty] at Ce\n    simp_rw [\u2190 Cc, Ce, Finset.card_empty, not_lt_zero'] at h\n  let C' : Finset (Grid X) := C.image \ud835\udcd8\n  have C'n : C'.Nonempty := by rwa [Finset.image_nonempty]\n  obtain \u27e8i, mi, li\u27e9 := C'.exists_minimal C'n\n  simp_rw [C', Finset.mem_image, C, Finset.mem_filter, Finset.mem_univ, true_and] at mi\n  obtain \u27e8u, \u27e8mu, mx\u27e9, uei\u27e9 := mi; subst uei\n  have uA : (\ud835\udcd8 u : Set X) \u2286 setA (2 * n + 6) k n := fun y my \u21a6\n    calc\n      _ = (4 * n + 12) * 2 ^ n := by ring\n      _ < stackSize (\ud835\udd18\u2083 k n j) x := h\n      _ \u2264 stackSize (\ud835\udd18\u2083 k n j) y := by\n        simp_rw [stackSize, indicator_apply, Pi.one_apply, Finset.sum_boole, Nat.cast_id]\n        apply Finset.card_le_card fun v mv \u21a6 ?_\n        simp_rw [Finset.mem_filter, Finset.mem_univ, true_and] at mv \u22a2\n        have mvC' : \ud835\udcd8 v \u2208 C' := by\n          simp_rw [C', Finset.mem_image]; use v\n          simp_rw [C, Finset.mem_filter, Finset.mem_univ, true_and, and_true]; exact mv\n        specialize li _ mvC'\n        have inc := (or_assoc.mpr (le_or_ge_or_disjoint (i := \ud835\udcd8 u) (j := \ud835\udcd8 v))).resolve_right\n          (not_disjoint_iff.mpr \u27e8_, mx, mv.2\u27e9)\n        simp_rw [le_iff_eq_or_lt] at inc\n        replace inc : \ud835\udcd8 u = \ud835\udcd8 v \u2228 \ud835\udcd8 u < \ud835\udcd8 v := by tauto\n        rw [\u2190 le_iff_eq_or_lt] at inc\n        exact \u27e8mv.1, inc.1 my\u27e9\n      _ \u2264 _ := stackSize_\ud835\udd18\u2083_le_\ud835\udd10 _\n  refine absurd (disjoint_left.mpr fun v mv \u21a6 ?_) (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 mu).2\n  rw [\ud835\udd17\u2081, mem_setOf] at mv; rw [\u212d\u2086, mem_setOf, not_and, not_not]\n  refine fun _ \u21a6 (mv.2.2.1).1.trans ?_\n  calc\n    _ \u2286 setA (2 * n + 6) k n := uA\n    _ \u2286 G\u2082 := subset_iUnion\u2082_of_subset n k (subset_iUnion_of_subset hkn subset_rfl)\n    _ \u2286 _ := subset_union_of_subset_left subset_union_right G\u2083\n\n/-- Define `\ud835\udd18\u2084 k n j l` as the union of `2 ^ n` disjoint subfamilies in `\ud835\udd18\u2083 k n j`, to make sure\nthe multiplicity is at most `2 ^ n` to get a forest. -/\ndef \ud835\udd18\u2084 (k n j l : \u2115) : Set (\ud835\udd13 X) :=\n  \u22c3 i \u2208 Ico (l * 2 ^ n) ((l + 1) * 2 ^ n), iteratedMaximalSubfamily (\ud835\udd18\u2083 k n j) i\n\nlemma \ud835\udd18\u2084_subset_\ud835\udd18\u2083 {k n j l} : \ud835\udd18\u2084 (X := X) k n j l \u2286 \ud835\udd18\u2083 k n j := by\n  simp [\ud835\udd18\u2084, iteratedMaximalSubfamily_subset]\n\n/-- The sets `(\ud835\udd18\u2084(k, n, j, l))_l` form a partition of `\ud835\udd18\u2083 k n j`. -/\nlemma iUnion_\ud835\udd18\u2084 (hkn : k \u2264 n) : \u22c3 l \u2208 Iio (4 * n + 12), \ud835\udd18\u2084 (X := X) k n j l = \ud835\udd18\u2083 k n j := by\n  have : \u22c3 l \u2208 Iio (4 * n + 12), \ud835\udd18\u2084 (X := X) k n j l =\n      \u22c3 i < (4 * n + 12) * 2 ^ n, iteratedMaximalSubfamily (\ud835\udd18\u2083 k n j) i := by\n    apply Subset.antisymm\n    \u00b7 simp only [mem_Iio, \ud835\udd18\u2084, mem_Ico, biUnion_and', iUnion_subset_iff]\n      intro l i hi hl h'i\n      apply subset_biUnion_of_mem\n      change i + 1 \u2264 (4 * n + 12) * 2 ^ n\n      suffices i < (4 * n + 12) * 2 ^ n by omega\n      exact h'i.trans_le (mul_le_mul' (by omega) le_rfl)\n    \u00b7 simp only [\ud835\udd18\u2084, iUnion_subset_iff]\n      intro i hi\n      let l := i / 2 ^ n\n      have : iteratedMaximalSubfamily (\ud835\udd18\u2083 k n j) i \u2286 \u22c3 i \u2208 Ico (l * 2 ^ n) ((l + 1) * 2 ^ n),\n          iteratedMaximalSubfamily (X := X) (\ud835\udd18\u2083 k n j) i := by\n        apply subset_biUnion_of_mem\n        refine \u27e8Nat.div_mul_le_self _ _, ?_\u27e9\n        rw [\u2190 Nat.div_lt_iff_lt_mul (Nat.two_pow_pos n)]\n        exact lt_add_one _\n      apply this.trans\n      apply subset_biUnion_of_mem (u := fun l \u21a6\n        \u22c3 i \u2208 Ico (l * 2 ^ n) ((l + 1) * 2 ^ n), iteratedMaximalSubfamily (\ud835\udd18\u2083 k n j) i)\n      simp only [mem_Iio, l]\n      rwa [Nat.div_lt_iff_lt_mul (Nat.two_pow_pos n)]\n  rw [this, eq_comm]\n  apply eq_biUnion_iteratedMaximalSubfamily\n  intro x\n  apply forest_stacking x hkn\n\nlemma C6_forest' (hkn : k \u2264 n) :\n    \u212d\u2086 (X := X) k n j = \u22c3 l \u2208 Iio (4 * n + 12), \u22c3 u \u2208 \ud835\udd18\u2084 k n j l, \ud835\udd17\u2082 k n j u := by\n  rw [C6_forest, \u2190 iUnion_\ud835\udd18\u2084 hkn]\n  simp\n\nlemma pairwiseDisjoint_\ud835\udd18\u2084 : univ.PairwiseDisjoint (\ud835\udd18\u2084 (X := X) k n j) := by\n  intro l hl m hm hml\n  apply disjoint_iff_forall_ne.2 (fun x hx y hy \u21a6 ?_)\n  simp only [\ud835\udd18\u2084, mem_Ico, mem_iUnion, exists_prop] at hx hy\n  rcases hx with \u27e8a, \u27e8ha, h'a\u27e9, xa\u27e9\n  rcases hy with \u27e8b, \u27e8hb, h'b\u27e9, yb\u27e9\n  have h : a \u2260 b := by\n    rcases lt_or_gt_of_ne hml with h | h\n    \u00b7 exact (h'a.trans_le (le_trans (mul_le_mul' h le_rfl) hb)).ne\n    \u00b7 exact (h'b.trans_le (le_trans (mul_le_mul' h le_rfl) ha)).ne'\n  have := pairwiseDisjoint_iteratedMaximalSubfamily (\ud835\udd18\u2083 (X := X) k n j) (mem_univ a) (mem_univ b) h\n  exact disjoint_iff_forall_ne.1 this xa yb\n\nlemma stackSize_\ud835\udd18\u2084_le (x : X) : stackSize (\ud835\udd18\u2084 (X := X) k n j l) x \u2264 2 ^ n := calc\n  stackSize (\ud835\udd18\u2084 (X := X) k n j l) x\n  _ = \u2211 i \u2208 Finset.Ico (l * 2 ^ n) ((l + 1) * 2 ^ n),\n        stackSize (iteratedMaximalSubfamily (\ud835\udd18\u2083 k n j) i) x := by\n    simp only [stackSize, \ud835\udd18\u2084]\n    rw [\u2190 Finset.sum_biUnion]; swap\n    \u00b7 intro a ha b hb hab\n      apply Finset.disjoint_coe.1\n      apply disjoint_iff_forall_ne.2 (fun p hp q hq \u21a6 ?_)\n      simp only [Finset.coe_filter, Finset.mem_univ, true_and, setOf_mem_eq] at hp hq\n      have := pairwiseDisjoint_iteratedMaximalSubfamily (\ud835\udd18\u2083 (X := X) k n j)\n        (mem_univ a) (mem_univ b) hab\n      exact disjoint_iff_forall_ne.1 this hp hq\n    congr\n    ext p\n    simp\n  _ \u2264 \u2211 i \u2208 Finset.Ico (l * 2 ^ n) ((l + 1) * 2 ^ n), 1 := by\n    gcongr with i hi\n    apply stackSize_le_one_of_pairwiseDisjoint\n    apply pairwiseDisjoint_iteratedMaximalSubfamily_image\n  _ = 2 ^ n := by simp [add_mul]\n\nopen TileStructure\nvariable (k n j l) in\n/-- The forest based on `\ud835\udd18\u2084 k n j l`. -/\ndef forest : Forest X n where\n  \ud835\udd18 := \ud835\udd18\u2084 k n j l\n  \ud835\udd17 := \ud835\udd17\u2082 k n j\n  nonempty' {u} hu := by\n    have m : u \u2208 \ud835\udd18\u2082 k n j := (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 (\ud835\udd18\u2084_subset_\ud835\udd18\u2083 hu))\n    have : \u212d\u2086 k n j \u2229 \ud835\udd17\u2081 k n j u \u2286 \ud835\udd17\u2082 k n j u := by\n      apply inter_subset_inter_right\n      have : \ud835\udd17\u2081 k n j u \u2286 \u22c3 (_ : URel k n j u u), \ud835\udd17\u2081 k n j u := by\n        have : URel k n j u u := (equivalenceOn_urel (X := X)).refl _ m\n        simp [this]\n      apply this.trans\n      apply subset_biUnion_of_mem (u := fun u' \u21a6 \u22c3 (_ : URel k n j u u'), \ud835\udd17\u2081 k n j u') m\n    apply Nonempty.mono this\n    rw [inter_comm]\n    simp only [\ud835\udd18\u2082, not_disjoint_iff_nonempty_inter, mem_setOf_eq] at m\n    exact m.2\n  ordConnected' {u} hu := forest_convex\n  \ud835\udcd8_ne_\ud835\udcd8' {u} hu p hp := by\n    have := hp.2\n    simp only [mem_iUnion, exists_prop, exists_and_left] at this\n    rcases this with \u27e8u', hu', u'rel, hu'I\u27e9\n    rw [URel.eq (\ud835\udd18\u2083_subset_\ud835\udd18\u2082 (\ud835\udd18\u2084_subset_\ud835\udd18\u2083 hu)) hu' u'rel]\n    exact (\ud835\udcd8_lt_of_mem_\ud835\udd17\u2081 hu'I).ne\n  smul_four_le' {u} hu := forest_geometry <| \ud835\udd18\u2084_subset_\ud835\udd18\u2083 hu\n  stackSize_le' {x} := stackSize_\ud835\udd18\u2084_le x\n  dens\u2081_\ud835\udd17_le' {u} hu := dens1_le <| \ud835\udd17\u2082_subset_\u212d\u2086.trans \u212d\u2086_subset_\u212d\n  lt_dist' hu hu' huu' p hp := forest_separation (\ud835\udd18\u2084_subset_\ud835\udd18\u2083 hu) (\ud835\udd18\u2084_subset_\ud835\udd18\u2083 hu') huu' hp\n  ball_subset' hu p hp := forest_inner (\ud835\udd18\u2084_subset_\ud835\udd18\u2083 hu) hp\n\n/-- From the fact that the `\u212d\u2085 k n j` are disjoint, one can rewrite the whole Carleson sum over\n`\ud835\udd13\u2081` (the union of the `\u212d\u2085 k n j`) as a sum of Carleson sums over the `\u212d\u2085 k n j`. -/\nlemma carlesonSum_\ud835\udd13\u2081_eq_sum {f : X \u2192 \u2102} {x : X} :\n    carlesonSum \ud835\udd13\u2081 f x = \u2211 n \u2264 max\u212d X, \u2211 k \u2264 n, \u2211 j \u2264 2 * n + 3, carlesonSum (\u212d\u2085 k n j) f x := by\n  simp only [Finset.sum_sigma']\n  rw [sum_carlesonSum_of_pairwiseDisjoint]; swap\n  \u00b7 rintro \u27e8n, k, j\u27e9 - \u27e8n', k', j'\u27e9 - h\n    simp only [ne_eq, Sigma.mk.inj_iff, heq_eq_eq] at h\n    simp only [Function.onFun, Finset.disjoint_filter, Finset.mem_univ, forall_const]\n    have W := pairwiseDisjoint_\u212d\u2085 (X := X) (mem_univ \u27e8k, n, j\u27e9) (mem_univ \u27e8k', n', j'\u27e9)\n      (by simp [-not_and]; tauto)\n    simpa [Function.onFun, disjoint_left] using W\n  congr\n  ext p\n  simp only [\ud835\udd13\u2081, mem_iUnion, exists_prop, Finset.mem_sigma, Finset.mem_Iic, Sigma.exists]\n  constructor\n  \u00b7 rintro \u27e8n, k, hk, j, hj, hp\u27e9\n    refine \u27e8n, k, j, \u27e8?_, hk, hj\u27e9, hp\u27e9\n    have : (\u212d (X := X) k n).Nonempty := \u27e8p, \u212d\u2085_subset_\u212d hp\u27e9\n    exact le_max\u212d_of_nonempty this\n  \u00b7 rintro \u27e8n, k, j, \u27e8hn, hk, hj\u27e9, hp\u27e9\n    exact \u27e8n, k, hk, j, hj, hp\u27e9\n\n/-- The Carleson sum over `\u212d\u2085` and `\u212d\u2086` coincide, for points in `G \\ G'`. -/\nlemma carlesonSum_\u212d\u2085_eq_\u212d\u2086 {f : X \u2192 \u2102} {x : X} (hx : x \u2208 G \\ G') {k n j : \u2115} :\n    carlesonSum (\u212d\u2085 k n j) f x = carlesonSum (\u212d\u2086 k n j) f x := by\n  simp only [carlesonSum]\n  symm\n  apply Finset.sum_subset\n  \u00b7 intro p hp\n    simp only [mem_iUnion, exists_prop, Finset.mem_filter, Finset.mem_univ, true_and] at hp \u22a2\n    exact \u212d\u2086_subset_\u212d\u2085 hp\n  \u00b7 intro p hp h'p\n    simp only [mem_iUnion, exists_prop, Finset.mem_filter,\n      Finset.mem_univ, true_and, not_exists, not_and] at hp h'p\n    have : x \u2209 \ud835\udcd8 p := by\n      simp only [\u212d\u2086, mem_setOf_eq, not_and, Decidable.not_not] at h'p\n      intro h'x\n      exact hx.2 (h'p hp h'x)\n    have : x \u2209 E p := by simp at this; simp [E, this]\n    simp [carlesonOn, this]\n\n", "theoremStatement": "/-- The Carleson sum over `\u212d\u2086` can be decomposed as a sum over `4 n + 12` forests\nbased on `\ud835\udd18\u2084 k n j l`. -/\nlemma carlesonSum_\u212d\u2086_eq_sum {f : X \u2192 \u2102} {x : X} {k n j : \u2115} (hkn : k \u2264 n) :\n    carlesonSum (\u212d\u2086 k n j) f x =\n      \u2211 l < 4 * n + 12, carlesonSum (\u22c3 u \u2208 \ud835\udd18\u2084 k n j l, \ud835\udd17\u2082 k n j u) f x ", "theoremName": "carlesonSum_\u212d\u2086_eq_sum", "fileCreated": {"commit": "310e13d16e51600777fc841833f4bce112b5f73a", "date": "2024-09-24"}, "theoremCreated": {"commit": "88d85ba29f717ee3bb9fbd37379a6fb77b57265f", "date": "2025-01-06"}, "file": "carleson/Carleson/Discrete/ForestUnion.lean", "module": "Carleson.Discrete.ForestUnion", "jsonFile": "Carleson.Discrete.ForestUnion.jsonl", "positionMetadata": {"lineInFile": 706, "tokenPositionInFile": 34218, "theoremPositionInFile": 43}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 7, "repositoryPremises": true, "numRepositoryPremises": 25, "numPremises": 135}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [sum_carlesonSum_of_pairwiseDisjoint]; swap\n  \u00b7 intro a ha b hb hab\n    simp only [Function.onFun, disjoint_iff_forall_ne, mem_iUnion, exists_prop, ne_eq,\n      forall_exists_index, and_imp]\n    intro q p hp hq q' p' hp' hq'\n    have := pairwiseDisjoint_\ud835\udd18\u2084 (X := X) (k := k) (n := n) (j := j) (mem_univ a) (mem_univ b) hab\n    have : p \u2260 p' := disjoint_iff_forall_ne.1 this hp hp'\n    have := forest_disjoint (\ud835\udd18\u2084_subset_\ud835\udd18\u2083 hp) (\ud835\udd18\u2084_subset_\ud835\udd18\u2083 hp') this\n    exact disjoint_iff_forall_ne.1 this hq hq'\n  congr\n  ext p\n  simp [C6_forest' hkn]", "proofType": "tactic", "proofLengthLines": 12, "proofLengthTokens": 548}}
{"srcContext": "/-\nCopyright (c) 2024 James Sundstrom. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: James Sundstrom\n-/\nimport Mathlib.MeasureTheory.Constructions.BorelSpace.Metric\n\n/-!\n# Annulus\n\nIn this file we define an annulus in a pseudometric space `X` to be a set consisting of all `y`\nsuch that `dist x y` lies in an interval between `r` and `R`. An annulus is defined for each type\nof interval (`Ioo`, `Ioc`, etc.) with a parallel naming scheme, except that we do not define annuli\nfor `Iio` and `Ico`, as they would be balls.\n\nWe also define `EAnnulus` similarly using `edist` instead of `dist`.\n\n## Tags\n\nannulus, eannulus\n-/\n\nopen Set Metric ENNReal\n\nvariable {X : Type*} [PseudoMetricSpace X]\n\nnamespace Set\n\nnamespace Annulus\n\ndef oo (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d) := {y | dist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d) := {y | dist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d) := {y | dist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d) := {y | dist x y \u2208 Ici r}\n\nlemma oo_eq {x : X} {r R : \u211d} : oo x r R = ball x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oo, dist_comm, and_comm]\n\nlemma oc_eq {x : X} {r R : \u211d} : oc x r R = closedBall x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oc, dist_comm, and_comm]\n\nlemma co_eq {x : X} {r R : \u211d} : co x r R = ball x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [co, dist_comm, and_comm]\n\nlemma cc_eq {x : X} {r R : \u211d} : cc x r R = closedBall x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [cc, dist_comm, and_comm]\n\nlemma oi_eq {x : X} {r : \u211d} : oi x r = (closedBall x r)\u1d9c := by\n  ext; simp [oi, dist_comm]\n\nlemma ci_eq {x : X} {r : \u211d} : ci x r = (ball x r)\u1d9c := by\n  ext; simp [ci, dist_comm]\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : co x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma co_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : co x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\nlemma cc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : cc x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma cc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : cc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\n@[simp]\nlemma oc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    oc x r r' \u222a oo x r' R = oo x r R := by\n  ext; simp_rw [oc, oo, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioo_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    oc x r r' \u222a oc x r' R = oc x r R := by\n  ext; simp_rw [oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_co {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a co x r' R = oo x r R := by\n  ext; simp_rw [oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ico_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a cc x r' R = oc x r R := by\n  ext; simp_rw [oo, cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Icc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    cc x r r' \u222a oo x r' R = co x r R := by\n  ext; simp_rw [cc, oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioo_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    cc x r r' \u222a oc x r' R = cc x r R := by\n  ext; simp_rw [cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_co {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a co x r' R = co x r R := by\n  ext; simp_rw [co, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ico_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a cc x r' R = cc x r R := by\n  ext; simp_rw [co, cc, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Icc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : oc x r R \u222a oi x R = oi x r := by\n  ext; simp_rw [oc, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioi_eq_Ioi h]\n\n@[simp]\nlemma oo_union_ci {x : X} {r R : \u211d} (h : r < R) :\n    oo x r R \u222a ci x R = oi x r := by\n  ext; simp_rw [oo, ci, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ici_eq_Ioi h]\n\n@[simp]\nlemma cc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : cc x r R \u222a oi x R = ci x r := by\n  ext; simp_rw [cc, oi, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioi_eq_Ici h]\n\n@[simp]\nlemma co_union_ci {x : X} {r R : \u211d} (h : r \u2264 R) : co x r R \u222a ci x R = ci x r := by\n  ext; simp_rw [co, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ici_eq_Ici h]\n\n\nvariable [MeasurableSpace X] [OpensMeasurableSpace X]\n\n@[measurability]\nlemma measurableSet_oo {x : X} {r R : \u211d} : MeasurableSet (oo x r R) := by\n  rw [oo_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oc {x : X} {r R : \u211d} : MeasurableSet (oc x r R) := by\n rw [oc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_co {x : X} {r R : \u211d} : MeasurableSet (co x r R) := by\n  rw [co_eq]; measurability\n\n@[measurability]\nlemma measurableSet_cc {x : X} {r R : \u211d} : MeasurableSet (cc x r R) := by\n rw [cc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oi {x : X} {r : \u211d} : MeasurableSet (oi x r) := by\n  rw [oi_eq]; measurability\n\n@[measurability]\nlemma measurableSet_ci {x : X} {r : \u211d} : MeasurableSet (ci x r) := by\n  rw [ci_eq]; measurability\n\nend Annulus\n\nnamespace EAnnulus\n\ndef oo (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ici r}\n\n\nlemma oo_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oo x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oo x r R := by\n  simp_rw [oo, Annulus.oo, edist_dist, mem_Ioo, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma oc_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [oc, Annulus.oc, edist_dist, mem_Ioc, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  \u00b7 have R_le_r := (lt_of_lt_of_le (lt_of_not_ge hR) hr).le\n    rw [Annulus.oc_eq_empty R_le_r]\n    refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n    exact not_le_of_gt (lt_of_le_of_lt (ENNReal.ofReal_le_ofReal R_le_r) hy.1) hy.2\n\nlemma co_eq_annulus {x : X} {r R : \u211d} :\n    co x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.co x r R := by\n  simp_rw [co, Annulus.co, edist_dist, mem_Ico, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma cc_eq_annulus {x : X} {r R : \u211d} (h : r > 0 \u2228 R \u2265 0) :\n    cc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.cc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [cc, Annulus.cc, edist_dist, mem_Icc, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  have r0 := h.resolve_right hR\n  have R_lt_r := (lt_of_not_ge hR).trans r0\n  rw [Annulus.cc_eq_empty R_lt_r]\n  refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n  exact not_le_of_gt ((ENNReal.ofReal_lt_ofReal_iff r0).mpr R_lt_r) (hy.1.trans hy.2)\n\nlemma oi_eq_annulus {x : X} {r : \u211d} (hr : r \u2265 0) : oi x (ENNReal.ofReal r) = Annulus.oi x r := by\n  simp_rw [oi, Annulus.oi, edist_dist, mem_Ioi, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr]\n\nlemma ci_eq_annulus {x : X} {r : \u211d} : ci x (ENNReal.ofReal r) = Annulus.ci x r := by\n  simp_rw [ci, Annulus.ci, edist_dist, mem_Ici, ENNReal.ofReal_le_ofReal_iff dist_nonneg]\n\n\nlemma oo_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oo x r R = ball x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oo, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma oc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oc x r R = closedBall x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oc, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma co_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    co x r R = ball x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [co, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma cc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    cc x r R = closedBall x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [cc, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma oi_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : oi x r = (closedBall x r.toReal)\u1d9c := by\n  ext; simp [oi, edist_dist, dist_comm, lt_ofReal_iff_toReal_lt hr.ne]\n\nlemma ci_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : ci x r = (ball x r.toReal)\u1d9c := by\n  ext; simp [ci, edist_dist, dist_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg]\n\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n@[simp]\nlemma cc_top_eq_empty {x : X} {R : \u211d\u22650\u221e} : cc x \u22a4 R = \u2205 :=\n  eq_empty_of_forall_not_mem (fun y hy \u21a6 (edist_ne_top x y) (top_le_iff.mp hy.1))\n\n@[simp]\nlemma oi_eq_empty {x : X} : oi x \u22a4 = \u2205 := by simp [oi, edist_dist]\n\n@[simp]\nlemma ci_eq_empty {x : X} : ci x \u22a4 = \u2205 := by simp [ci, edist_dist]\n\n\nlemma oo_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) :\n    oo x r \u22a4 = (closedBall x r.toReal)\u1d9c := by\n  ext; simpa [oo, edist_dist, dist_comm] using lt_ofReal_iff_toReal_lt hr.ne\n\nlemma oc_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) :\n    oc x r \u22a4 = (closedBall x r.toReal)\u1d9c := by\n  ext; simpa [oc, edist_dist, dist_comm] using lt_ofReal_iff_toReal_lt hr.ne\n\nlemma co_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : co x r \u22a4 = (ball x r.toReal)\u1d9c := by\n  ext; simpa [co, edist_dist, dist_comm] using le_ofReal_iff_toReal_le hr.ne dist_nonneg\n\nlemma cc_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : cc x r \u22a4 = (ball x r.toReal)\u1d9c := by\n  ext; simpa [cc, edist_dist, dist_comm] using le_ofReal_iff_toReal_le hr.ne dist_nonneg\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) : co x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma co_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : co x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\nlemma cc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\n", "theoremStatement": "lemma cc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 ", "theoremName": "Set.EAnnulus.cc_subset_cc", "fileCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "theoremCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "file": "carleson/Carleson/ToMathlib/Annulus.lean", "module": "Carleson.ToMathlib.Annulus", "jsonFile": "Carleson.ToMathlib.Annulus.jsonl", "positionMetadata": {"lineInFile": 446, "tokenPositionInFile": 17605, "theoremPositionInFile": 108}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 1, "numPremises": 22}, "proofMetadata": {"hasProof": true, "proof": ":=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.trans hR\u27e9", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 52}}
{"srcContext": "/-\nCopyright (c) 2024 James Sundstrom. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: James Sundstrom\n-/\nimport Mathlib.MeasureTheory.Constructions.BorelSpace.Metric\n\n/-!\n# Annulus\n\nIn this file we define an annulus in a pseudometric space `X` to be a set consisting of all `y`\nsuch that `dist x y` lies in an interval between `r` and `R`. An annulus is defined for each type\nof interval (`Ioo`, `Ioc`, etc.) with a parallel naming scheme, except that we do not define annuli\nfor `Iio` and `Ico`, as they would be balls.\n\nWe also define `EAnnulus` similarly using `edist` instead of `dist`.\n\n## Tags\n\nannulus, eannulus\n-/\n\nopen Set Metric ENNReal\n\nvariable {X : Type*} [PseudoMetricSpace X]\n\nnamespace Set\n\nnamespace Annulus\n\ndef oo (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d) := {y | dist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d) := {y | dist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d) := {y | dist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d) := {y | dist x y \u2208 Ici r}\n\nlemma oo_eq {x : X} {r R : \u211d} : oo x r R = ball x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oo, dist_comm, and_comm]\n\nlemma oc_eq {x : X} {r R : \u211d} : oc x r R = closedBall x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oc, dist_comm, and_comm]\n\nlemma co_eq {x : X} {r R : \u211d} : co x r R = ball x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [co, dist_comm, and_comm]\n\nlemma cc_eq {x : X} {r R : \u211d} : cc x r R = closedBall x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [cc, dist_comm, and_comm]\n\nlemma oi_eq {x : X} {r : \u211d} : oi x r = (closedBall x r)\u1d9c := by\n  ext; simp [oi, dist_comm]\n\nlemma ci_eq {x : X} {r : \u211d} : ci x r = (ball x r)\u1d9c := by\n  ext; simp [ci, dist_comm]\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : co x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma co_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : co x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\nlemma cc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : cc x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma cc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : cc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\n@[simp]\nlemma oc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    oc x r r' \u222a oo x r' R = oo x r R := by\n  ext; simp_rw [oc, oo, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioo_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    oc x r r' \u222a oc x r' R = oc x r R := by\n  ext; simp_rw [oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_co {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a co x r' R = oo x r R := by\n  ext; simp_rw [oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ico_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a cc x r' R = oc x r R := by\n  ext; simp_rw [oo, cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Icc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    cc x r r' \u222a oo x r' R = co x r R := by\n  ext; simp_rw [cc, oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioo_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    cc x r r' \u222a oc x r' R = cc x r R := by\n  ext; simp_rw [cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_co {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a co x r' R = co x r R := by\n  ext; simp_rw [co, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ico_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a cc x r' R = cc x r R := by\n  ext; simp_rw [co, cc, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Icc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : oc x r R \u222a oi x R = oi x r := by\n  ext; simp_rw [oc, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioi_eq_Ioi h]\n\n@[simp]\nlemma oo_union_ci {x : X} {r R : \u211d} (h : r < R) :\n    oo x r R \u222a ci x R = oi x r := by\n  ext; simp_rw [oo, ci, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ici_eq_Ioi h]\n\n@[simp]\nlemma cc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : cc x r R \u222a oi x R = ci x r := by\n  ext; simp_rw [cc, oi, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioi_eq_Ici h]\n\n@[simp]\nlemma co_union_ci {x : X} {r R : \u211d} (h : r \u2264 R) : co x r R \u222a ci x R = ci x r := by\n  ext; simp_rw [co, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ici_eq_Ici h]\n\n\nvariable [MeasurableSpace X] [OpensMeasurableSpace X]\n\n@[measurability]\nlemma measurableSet_oo {x : X} {r R : \u211d} : MeasurableSet (oo x r R) := by\n  rw [oo_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oc {x : X} {r R : \u211d} : MeasurableSet (oc x r R) := by\n rw [oc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_co {x : X} {r R : \u211d} : MeasurableSet (co x r R) := by\n  rw [co_eq]; measurability\n\n@[measurability]\nlemma measurableSet_cc {x : X} {r R : \u211d} : MeasurableSet (cc x r R) := by\n rw [cc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oi {x : X} {r : \u211d} : MeasurableSet (oi x r) := by\n  rw [oi_eq]; measurability\n\n@[measurability]\nlemma measurableSet_ci {x : X} {r : \u211d} : MeasurableSet (ci x r) := by\n  rw [ci_eq]; measurability\n\nend Annulus\n\nnamespace EAnnulus\n\ndef oo (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ici r}\n\n\nlemma oo_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oo x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oo x r R := by\n  simp_rw [oo, Annulus.oo, edist_dist, mem_Ioo, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma oc_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [oc, Annulus.oc, edist_dist, mem_Ioc, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  \u00b7 have R_le_r := (lt_of_lt_of_le (lt_of_not_ge hR) hr).le\n    rw [Annulus.oc_eq_empty R_le_r]\n    refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n    exact not_le_of_gt (lt_of_le_of_lt (ENNReal.ofReal_le_ofReal R_le_r) hy.1) hy.2\n\nlemma co_eq_annulus {x : X} {r R : \u211d} :\n    co x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.co x r R := by\n  simp_rw [co, Annulus.co, edist_dist, mem_Ico, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma cc_eq_annulus {x : X} {r R : \u211d} (h : r > 0 \u2228 R \u2265 0) :\n    cc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.cc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [cc, Annulus.cc, edist_dist, mem_Icc, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  have r0 := h.resolve_right hR\n  have R_lt_r := (lt_of_not_ge hR).trans r0\n  rw [Annulus.cc_eq_empty R_lt_r]\n  refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n  exact not_le_of_gt ((ENNReal.ofReal_lt_ofReal_iff r0).mpr R_lt_r) (hy.1.trans hy.2)\n\nlemma oi_eq_annulus {x : X} {r : \u211d} (hr : r \u2265 0) : oi x (ENNReal.ofReal r) = Annulus.oi x r := by\n  simp_rw [oi, Annulus.oi, edist_dist, mem_Ioi, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr]\n\nlemma ci_eq_annulus {x : X} {r : \u211d} : ci x (ENNReal.ofReal r) = Annulus.ci x r := by\n  simp_rw [ci, Annulus.ci, edist_dist, mem_Ici, ENNReal.ofReal_le_ofReal_iff dist_nonneg]\n\n\nlemma oo_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oo x r R = ball x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oo, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma oc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oc x r R = closedBall x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oc, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma co_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    co x r R = ball x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [co, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma cc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    cc x r R = closedBall x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [cc, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma oi_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : oi x r = (closedBall x r.toReal)\u1d9c := by\n  ext; simp [oi, edist_dist, dist_comm, lt_ofReal_iff_toReal_lt hr.ne]\n\nlemma ci_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : ci x r = (ball x r.toReal)\u1d9c := by\n  ext; simp [ci, edist_dist, dist_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg]\n\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n@[simp]\nlemma cc_top_eq_empty {x : X} {R : \u211d\u22650\u221e} : cc x \u22a4 R = \u2205 :=\n  eq_empty_of_forall_not_mem (fun y hy \u21a6 (edist_ne_top x y) (top_le_iff.mp hy.1))\n\n@[simp]\nlemma oi_eq_empty {x : X} : oi x \u22a4 = \u2205 := by simp [oi, edist_dist]\n\n@[simp]\nlemma ci_eq_empty {x : X} : ci x \u22a4 = \u2205 := by simp [ci, edist_dist]\n\n\nlemma oo_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) :\n    oo x r \u22a4 = (closedBall x r.toReal)\u1d9c := by\n  ext; simpa [oo, edist_dist, dist_comm] using lt_ofReal_iff_toReal_lt hr.ne\n\nlemma oc_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) :\n    oc x r \u22a4 = (closedBall x r.toReal)\u1d9c := by\n  ext; simpa [oc, edist_dist, dist_comm] using lt_ofReal_iff_toReal_lt hr.ne\n\nlemma co_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : co x r \u22a4 = (ball x r.toReal)\u1d9c := by\n  ext; simpa [co, edist_dist, dist_comm] using le_ofReal_iff_toReal_le hr.ne dist_nonneg\n\nlemma cc_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : cc x r \u22a4 = (ball x r.toReal)\u1d9c := by\n  ext; simpa [cc, edist_dist, dist_comm] using le_ofReal_iff_toReal_le hr.ne dist_nonneg\n\n\n", "theoremStatement": "lemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 ", "theoremName": "Set.EAnnulus.oo_subset_oo", "fileCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "theoremCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "file": "carleson/Carleson/ToMathlib/Annulus.lean", "module": "Carleson.ToMathlib.Annulus", "jsonFile": "Carleson.ToMathlib.Annulus.jsonl", "positionMetadata": {"lineInFile": 368, "tokenPositionInFile": 14249, "theoremPositionInFile": 87}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 1, "numPremises": 25}, "proofMetadata": {"hasProof": true, "proof": ":=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 70}}
{"srcContext": "/-\nCopyright (c) 2024 James Sundstrom. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: James Sundstrom\n-/\nimport Mathlib.MeasureTheory.Constructions.BorelSpace.Metric\n\n/-!\n# Annulus\n\nIn this file we define an annulus in a pseudometric space `X` to be a set consisting of all `y`\nsuch that `dist x y` lies in an interval between `r` and `R`. An annulus is defined for each type\nof interval (`Ioo`, `Ioc`, etc.) with a parallel naming scheme, except that we do not define annuli\nfor `Iio` and `Ico`, as they would be balls.\n\nWe also define `EAnnulus` similarly using `edist` instead of `dist`.\n\n## Tags\n\nannulus, eannulus\n-/\n\nopen Set Metric ENNReal\n\nvariable {X : Type*} [PseudoMetricSpace X]\n\nnamespace Set\n\nnamespace Annulus\n\ndef oo (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d) := {y | dist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d) := {y | dist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d) := {y | dist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d) := {y | dist x y \u2208 Ici r}\n\nlemma oo_eq {x : X} {r R : \u211d} : oo x r R = ball x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oo, dist_comm, and_comm]\n\nlemma oc_eq {x : X} {r R : \u211d} : oc x r R = closedBall x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oc, dist_comm, and_comm]\n\nlemma co_eq {x : X} {r R : \u211d} : co x r R = ball x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [co, dist_comm, and_comm]\n\nlemma cc_eq {x : X} {r R : \u211d} : cc x r R = closedBall x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [cc, dist_comm, and_comm]\n\nlemma oi_eq {x : X} {r : \u211d} : oi x r = (closedBall x r)\u1d9c := by\n  ext; simp [oi, dist_comm]\n\nlemma ci_eq {x : X} {r : \u211d} : ci x r = (ball x r)\u1d9c := by\n  ext; simp [ci, dist_comm]\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : co x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma co_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : co x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\nlemma cc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : cc x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma cc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : cc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\n@[simp]\nlemma oc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    oc x r r' \u222a oo x r' R = oo x r R := by\n  ext; simp_rw [oc, oo, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioo_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    oc x r r' \u222a oc x r' R = oc x r R := by\n  ext; simp_rw [oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_co {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a co x r' R = oo x r R := by\n  ext; simp_rw [oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ico_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a cc x r' R = oc x r R := by\n  ext; simp_rw [oo, cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Icc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    cc x r r' \u222a oo x r' R = co x r R := by\n  ext; simp_rw [cc, oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioo_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    cc x r r' \u222a oc x r' R = cc x r R := by\n  ext; simp_rw [cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_co {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a co x r' R = co x r R := by\n  ext; simp_rw [co, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ico_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a cc x r' R = cc x r R := by\n  ext; simp_rw [co, cc, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Icc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : oc x r R \u222a oi x R = oi x r := by\n  ext; simp_rw [oc, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioi_eq_Ioi h]\n\n@[simp]\nlemma oo_union_ci {x : X} {r R : \u211d} (h : r < R) :\n    oo x r R \u222a ci x R = oi x r := by\n  ext; simp_rw [oo, ci, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ici_eq_Ioi h]\n\n@[simp]\nlemma cc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : cc x r R \u222a oi x R = ci x r := by\n  ext; simp_rw [cc, oi, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioi_eq_Ici h]\n\n@[simp]\nlemma co_union_ci {x : X} {r R : \u211d} (h : r \u2264 R) : co x r R \u222a ci x R = ci x r := by\n  ext; simp_rw [co, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ici_eq_Ici h]\n\n\nvariable [MeasurableSpace X] [OpensMeasurableSpace X]\n\n@[measurability]\nlemma measurableSet_oo {x : X} {r R : \u211d} : MeasurableSet (oo x r R) := by\n  rw [oo_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oc {x : X} {r R : \u211d} : MeasurableSet (oc x r R) := by\n rw [oc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_co {x : X} {r R : \u211d} : MeasurableSet (co x r R) := by\n  rw [co_eq]; measurability\n\n@[measurability]\nlemma measurableSet_cc {x : X} {r R : \u211d} : MeasurableSet (cc x r R) := by\n rw [cc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oi {x : X} {r : \u211d} : MeasurableSet (oi x r) := by\n  rw [oi_eq]; measurability\n\n@[measurability]\nlemma measurableSet_ci {x : X} {r : \u211d} : MeasurableSet (ci x r) := by\n  rw [ci_eq]; measurability\n\nend Annulus\n\nnamespace EAnnulus\n\ndef oo (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ici r}\n\n\nlemma oo_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oo x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oo x r R := by\n  simp_rw [oo, Annulus.oo, edist_dist, mem_Ioo, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma oc_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [oc, Annulus.oc, edist_dist, mem_Ioc, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  \u00b7 have R_le_r := (lt_of_lt_of_le (lt_of_not_ge hR) hr).le\n    rw [Annulus.oc_eq_empty R_le_r]\n    refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n    exact not_le_of_gt (lt_of_le_of_lt (ENNReal.ofReal_le_ofReal R_le_r) hy.1) hy.2\n\nlemma co_eq_annulus {x : X} {r R : \u211d} :\n    co x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.co x r R := by\n  simp_rw [co, Annulus.co, edist_dist, mem_Ico, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma cc_eq_annulus {x : X} {r R : \u211d} (h : r > 0 \u2228 R \u2265 0) :\n    cc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.cc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [cc, Annulus.cc, edist_dist, mem_Icc, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  have r0 := h.resolve_right hR\n  have R_lt_r := (lt_of_not_ge hR).trans r0\n  rw [Annulus.cc_eq_empty R_lt_r]\n  refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n  exact not_le_of_gt ((ENNReal.ofReal_lt_ofReal_iff r0).mpr R_lt_r) (hy.1.trans hy.2)\n\nlemma oi_eq_annulus {x : X} {r : \u211d} (hr : r \u2265 0) : oi x (ENNReal.ofReal r) = Annulus.oi x r := by\n  simp_rw [oi, Annulus.oi, edist_dist, mem_Ioi, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr]\n\nlemma ci_eq_annulus {x : X} {r : \u211d} : ci x (ENNReal.ofReal r) = Annulus.ci x r := by\n  simp_rw [ci, Annulus.ci, edist_dist, mem_Ici, ENNReal.ofReal_le_ofReal_iff dist_nonneg]\n\n\nlemma oo_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oo x r R = ball x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oo, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma oc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oc x r R = closedBall x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oc, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma co_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    co x r R = ball x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [co, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma cc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    cc x r R = closedBall x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [cc, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma oi_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : oi x r = (closedBall x r.toReal)\u1d9c := by\n  ext; simp [oi, edist_dist, dist_comm, lt_ofReal_iff_toReal_lt hr.ne]\n\n", "theoremStatement": "lemma ci_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : ci x r = (ball x r.toReal)\u1d9c ", "theoremName": "Set.EAnnulus.ci_eq_of_lt_top", "fileCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "theoremCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "file": "carleson/Carleson/ToMathlib/Annulus.lean", "module": "Carleson.ToMathlib.Annulus", "jsonFile": "Carleson.ToMathlib.Annulus.jsonl", "positionMetadata": {"lineInFile": 322, "tokenPositionInFile": 12598, "theoremPositionInFile": 75}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 1, "numPremises": 61}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  ext; simp [ci, edist_dist, dist_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 88}}
{"srcContext": "import Carleson.ToMathlib.DoublingMeasure\nimport Carleson.ToMathlib.WeakType\nimport Mathlib.Algebra.Order.Group.Int\nimport Mathlib.Analysis.CStarAlgebra.Classes\nimport Mathlib.Data.Int.Star\n\nopen MeasureTheory Measure NNReal Metric Complex Set TopologicalSpace Bornology Function\nopen scoped ENNReal\nnoncomputable section\n\n-- todo: rename and protect `Real.RCLike`\n\n/-! Miscellaneous definitions.\nThese are mostly the definitions used to state the metric Carleson theorem.\nWe should move them to separate files once we start proving things about them. -/\n\nsection DoublingMeasure\nuniverse u\n\nvariable {\ud835\udd5c X : Type*} {A : \u2115} [_root_.RCLike \ud835\udd5c] [PseudoMetricSpace X]\n\nsection localOscillation\n\n/-- The local oscillation of two functions w.r.t. a set `E`. This is `d_E` in the blueprint. -/\ndef localOscillation (E : Set X) (f g : C(X, \ud835\udd5c)) : \u211d\u22650\u221e :=\n  \u2a06 z \u2208 E \u00d7\u02e2 E, ENNReal.ofReal \u2016f z.1 - g z.1 - f z.2 + g z.2\u2016\n\n-- example (E : Set X) (hE : IsBounded E) (f : C(X, \u211d)) :\n--     BddAbove (range fun z : E \u21a6 f z) := by\n--   have : IsCompact (closure E) := IsBounded.isCompact_closure hE\n--   sorry\n\n-- lemma bddAbove_localOscillation (E : Set X) [Fact (IsBounded E)] (f g : C(X, \ud835\udd5c)) :\n--     BddAbove ((fun z : X \u00d7 X \u21a6 \u2016f z.1 - g z.1 - f z.2 + g z.2\u2016) '' E \u00d7\u02e2 E) := sorry\n\nvariable {E : Set X} {f g : C(X, \ud835\udd5c)}\n\n--old\n/-- A ball w.r.t. the distance `localOscillation` -/\ndef localOscillationBall (E : Set X) (f : C(X, \ud835\udd5c)) (r : \u211d) :\n    Set C(X, \ud835\udd5c) :=\n  { g : C(X, \ud835\udd5c) | localOscillation E f g < ENNReal.ofReal r }\n\nend localOscillation\n\nlemma fact_isCompact_ball (x : X) (r : \u211d) : Fact (IsBounded (ball x r)) :=\n  \u27e8isBounded_ball\u27e9\nattribute [local instance] fact_isCompact_ball\n\n/-- A class stating that continuous functions have distances associated to every ball.\nWe use a separate type to conveniently index these functions. -/\nclass FunctionDistances (\ud835\udd5c : outParam Type*) (X : Type u)\n    [NormedField \ud835\udd5c] [TopologicalSpace X] where\n  \u0398 : Type u\n  coe\u0398 : \u0398 \u2192 C(X, \ud835\udd5c)\n  coe\u0398_injective {f g : \u0398} (h : \u2200 x, coe\u0398 f x = coe\u0398 g x) : f = g\n  metric : \u2200 (_x : X) (_r : \u211d), PseudoMetricSpace \u0398\n\nexport FunctionDistances (\u0398 coe\u0398)\n\nsection FunctionDistances\nvariable [FunctionDistances \ud835\udd5c X]\n\ninstance : Coe (\u0398 X) C(X, \ud835\udd5c) := \u27e8FunctionDistances.coe\u0398\u27e9\ninstance : FunLike (\u0398 X) X \ud835\udd5c where\n  coe := fun f \u21a6 (f : C(X, \ud835\udd5c))\n  coe_injective' _ _ hfg := FunctionDistances.coe\u0398_injective fun x \u21a6 congrFun hfg x\ninstance : ContinuousMapClass (\u0398 X) X \ud835\udd5c := \u27e8fun f \u21a6 (f : C(X, \ud835\udd5c)).2\u27e9\n\nset_option linter.unusedVariables false in\n@[nolint unusedArguments]\ndef WithFunctionDistance (x : X) (r : \u211d) := \u0398 X\n\nvariable {x : X} {r : \u211d}\n\ndef toWithFunctionDistance [FunctionDistances \ud835\udd5c X] : \u0398 X \u2243 WithFunctionDistance x r :=\n  .refl _\n\n-- instance : FunLike (WithFunctionDistance \u0398 x r) X \ud835\udd5c := ContinuousMap.funLike\n-- instance : ContinuousMapClass (WithFunctionDistance \u0398 x r) X \ud835\udd5c :=\n--   ContinuousMap.toContinuousMapClass\n\ninstance [d : FunctionDistances \ud835\udd5c X] : PseudoMetricSpace (WithFunctionDistance x r) :=\n  d.metric x r\n\nend FunctionDistances\n\nnotation3 \"dist_{\" x \" ,\" r \"}\" => @dist (WithFunctionDistance x r) _\nnotation3 \"nndist_{\" x \" ,\" r \"}\" => @nndist (WithFunctionDistance x r) _\nnotation3 \"ball_{\" x \" ,\" r \"}\" => @ball (WithFunctionDistance x r) _ in\n\n/-- A set `\u0398` of (continuous) functions is compatible. `A` will usually be `2 ^ a`. -/\nclass CompatibleFunctions (\ud835\udd5c : outParam Type*) (X : Type u) (A : outParam \u2115)\n  [RCLike \ud835\udd5c] [PseudoMetricSpace X] extends FunctionDistances \ud835\udd5c X where\n  eq_zero : \u2203 o : X, \u2200 f : \u0398, f o = 0\n  /-- The distance is bounded below by the local oscillation. (1.0.7) -/\n  localOscillation_le_cdist {x : X} {r : \u211d} {f g : \u0398} :\n    localOscillation (ball x r) (coe\u0398 f) (coe\u0398 g) \u2264 ENNReal.ofReal (dist_{x, r} f g)\n  /-- The distance is monotone in the ball. (1.0.9) -/\n  cdist_mono {x\u2081 x\u2082 : X} {r\u2081 r\u2082 : \u211d} {f g : \u0398}\n    (h : ball x\u2081 r\u2081 \u2286 ball x\u2082 r\u2082) : dist_{x\u2081, r\u2081} f g \u2264 dist_{x\u2082, r\u2082} f g\n  /-- The distance of a ball with large radius is bounded above. (1.0.8) -/\n  cdist_le {x\u2081 x\u2082 : X} {r : \u211d} {f g : \u0398} (h : dist x\u2081 x\u2082 < 2 * r) :\n    dist_{x\u2082, 2 * r} f g \u2264 A * dist_{x\u2081, r} f g\n  /-- The distance of a ball with large radius is bounded below. (1.0.10) -/\n  le_cdist {x\u2081 x\u2082 : X} {r : \u211d} {f g : \u0398} (h1 : ball x\u2081 r \u2286 ball x\u2082 (A * r)) :\n    /-(h2 : A * r \u2264 Metric.diam (univ : Set X))-/\n    2 * dist_{x\u2081, r} f g \u2264 dist_{x\u2082, A * r} f g\n  /-- The distance of a ball with large radius is bounded below. (1.0.11) -/\n  ballsCoverBalls {x : X} {r R : \u211d} :\n    BallsCoverBalls (X := WithFunctionDistance x r) (2 * R) R A\n\ninstance nonempty_Space [CompatibleFunctions \ud835\udd5c X A] : Nonempty X := by\n  obtain \u27e8x,_\u27e9 := \u2039CompatibleFunctions \ud835\udd5c X A\u203a.eq_zero\n  use x\n\ninstance inhabited_Space [CompatibleFunctions \ud835\udd5c X A] : Inhabited X :=\n  \u27e8nonempty_Space.some\u27e9\n\nlemma le_localOscillation [CompatibleFunctions \ud835\udd5c X A] (x : X) (r : \u211d) (f g : \u0398 X) {y z : X}\n    (hy : y \u2208 ball x r) (hz : z \u2208 ball x r) : \u2016coe\u0398 f y - coe\u0398 g y - coe\u0398 f z + coe\u0398 g z\u2016 \u2264\n    ENNReal.toReal (localOscillation (ball x r) (coe\u0398 f) (coe\u0398 g)) := by\n  rw [(ENNReal.toReal_ofReal (norm_nonneg _)).symm]\n  let f (z) := \u2a06 (_ : z \u2208 ball x r \u00d7\u02e2 ball x r), ENNReal.ofReal \u2016f z.1 - g z.1 - f z.2 + g z.2\u2016\n  apply ENNReal.toReal_mono\n  \u00b7 exact lt_of_le_of_lt CompatibleFunctions.localOscillation_le_cdist ENNReal.ofReal_lt_top |>.ne\n  \u00b7 exact le_of_eq_of_le (Eq.symm (iSup_pos \u27e8hy, hz\u27e9)) (le_iSup f \u27e8y, z\u27e9)\n\n", "theoremStatement": "lemma oscillation_le_cdist [CompatibleFunctions \ud835\udd5c X A] (x : X) (r : \u211d) (f g : \u0398 X) {y z : X}\n    (hy : y \u2208 ball x r) (hz : z \u2208 ball x r) :\n    \u2016coe\u0398 f y - coe\u0398 g y - coe\u0398 f z + coe\u0398 g z\u2016 \u2264 dist_{x, r} f g ", "theoremName": "oscillation_le_cdist", "fileCreated": {"commit": "238b977db22d5b1107a09468e95b78facfd58fd1", "date": "2023-10-20"}, "theoremCreated": {"commit": "3298f748e9eb26a242da5ee38cb50dc55e604935", "date": "2025-01-08"}, "file": "carleson/Carleson/Defs.lean", "module": "Carleson.Defs", "jsonFile": "Carleson.Defs.jsonl", "positionMetadata": {"lineInFile": 129, "tokenPositionInFile": 5353, "theoremPositionInFile": 9}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 9, "repositoryPremises": true, "numRepositoryPremises": 11, "numPremises": 69}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  apply le_trans <| le_localOscillation x r f g hy hz\n  rw [\u2190 ENNReal.toReal_ofReal dist_nonneg]\n  exact ENNReal.toReal_mono ENNReal.ofReal_ne_top CompatibleFunctions.localOscillation_le_cdist", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 198}}
{"srcContext": "/-\nCopyright (c) 2024 James Sundstrom. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: James Sundstrom\n-/\nimport Mathlib.MeasureTheory.Constructions.BorelSpace.Metric\n\n/-!\n# Annulus\n\nIn this file we define an annulus in a pseudometric space `X` to be a set consisting of all `y`\nsuch that `dist x y` lies in an interval between `r` and `R`. An annulus is defined for each type\nof interval (`Ioo`, `Ioc`, etc.) with a parallel naming scheme, except that we do not define annuli\nfor `Iio` and `Ico`, as they would be balls.\n\nWe also define `EAnnulus` similarly using `edist` instead of `dist`.\n\n## Tags\n\nannulus, eannulus\n-/\n\nopen Set Metric ENNReal\n\nvariable {X : Type*} [PseudoMetricSpace X]\n\nnamespace Set\n\nnamespace Annulus\n\ndef oo (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d) := {y | dist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d) := {y | dist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d) := {y | dist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d) := {y | dist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d) := {y | dist x y \u2208 Ici r}\n\nlemma oo_eq {x : X} {r R : \u211d} : oo x r R = ball x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oo, dist_comm, and_comm]\n\nlemma oc_eq {x : X} {r R : \u211d} : oc x r R = closedBall x R \u2229 (closedBall x r)\u1d9c := by\n  ext; simp [oc, dist_comm, and_comm]\n\nlemma co_eq {x : X} {r R : \u211d} : co x r R = ball x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [co, dist_comm, and_comm]\n\nlemma cc_eq {x : X} {r R : \u211d} : cc x r R = closedBall x R \u2229 (ball x r)\u1d9c := by\n  ext; simp [cc, dist_comm, and_comm]\n\nlemma oi_eq {x : X} {r : \u211d} : oi x r = (closedBall x r)\u1d9c := by\n  ext; simp [oi, dist_comm]\n\nlemma ci_eq {x : X} {r : \u211d} : ci x r = (ball x r)\u1d9c := by\n  ext; simp [ci, dist_comm]\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : co x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma co_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : co x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\nlemma cc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma cc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 < r\u2081) : cc x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma cc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d} (hr : r\u2082 \u2264 r\u2081) : cc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\n@[simp]\nlemma oc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    oc x r r' \u222a oo x r' R = oo x r R := by\n  ext; simp_rw [oc, oo, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioo_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    oc x r r' \u222a oc x r' R = oc x r R := by\n  ext; simp_rw [oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_co {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a co x r' R = oo x r R := by\n  ext; simp_rw [oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ico_eq_Ioo h\u2081 h\u2082]\n\n@[simp]\nlemma oo_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r < r') (h\u2082 : r' \u2264 R) :\n    oo x r r' \u222a cc x r' R = oc x r R := by\n  ext; simp_rw [oo, cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Icc_eq_Ioc h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oo {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' < R) :\n    cc x r r' \u222a oo x r' R = co x r R := by\n  ext; simp_rw [cc, oo, co, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioo_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma cc_union_oc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    cc x r r' \u222a oc x r' R = cc x r R := by\n  ext; simp_rw [cc, oc, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_co {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a co x r' R = co x r R := by\n  ext; simp_rw [co, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ico_eq_Ico h\u2081 h\u2082]\n\n@[simp]\nlemma co_union_cc {x : X} {r r' R : \u211d} (h\u2081 : r \u2264 r') (h\u2082 : r' \u2264 R) :\n    co x r r' \u222a cc x r' R = cc x r R := by\n  ext; simp_rw [co, cc, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Icc_eq_Icc h\u2081 h\u2082]\n\n@[simp]\nlemma oc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : oc x r R \u222a oi x R = oi x r := by\n  ext; simp_rw [oc, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioc_union_Ioi_eq_Ioi h]\n\n@[simp]\nlemma oo_union_ci {x : X} {r R : \u211d} (h : r < R) :\n    oo x r R \u222a ci x R = oi x r := by\n  ext; simp_rw [oo, ci, oi, mem_union, mem_setOf_eq, \u2190 mem_union, Ioo_union_Ici_eq_Ioi h]\n\n@[simp]\nlemma cc_union_oi {x : X} {r R : \u211d} (h : r \u2264 R) : cc x r R \u222a oi x R = ci x r := by\n  ext; simp_rw [cc, oi, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Icc_union_Ioi_eq_Ici h]\n\n@[simp]\nlemma co_union_ci {x : X} {r R : \u211d} (h : r \u2264 R) : co x r R \u222a ci x R = ci x r := by\n  ext; simp_rw [co, ci, mem_union, mem_setOf_eq, \u2190 mem_union, Ico_union_Ici_eq_Ici h]\n\n\nvariable [MeasurableSpace X] [OpensMeasurableSpace X]\n\n@[measurability]\nlemma measurableSet_oo {x : X} {r R : \u211d} : MeasurableSet (oo x r R) := by\n  rw [oo_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oc {x : X} {r R : \u211d} : MeasurableSet (oc x r R) := by\n rw [oc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_co {x : X} {r R : \u211d} : MeasurableSet (co x r R) := by\n  rw [co_eq]; measurability\n\n@[measurability]\nlemma measurableSet_cc {x : X} {r R : \u211d} : MeasurableSet (cc x r R) := by\n rw [cc_eq]; measurability\n\n@[measurability]\nlemma measurableSet_oi {x : X} {r : \u211d} : MeasurableSet (oi x r) := by\n  rw [oi_eq]; measurability\n\n@[measurability]\nlemma measurableSet_ci {x : X} {r : \u211d} : MeasurableSet (ci x r) := by\n  rw [ci_eq]; measurability\n\nend Annulus\n\nnamespace EAnnulus\n\ndef oo (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioo r R}\ndef oc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioc r R}\ndef co (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Ico r R}\ndef cc (x : X) (r R : \u211d\u22650\u221e) := {y | edist x y \u2208 Icc r R}\ndef oi (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ioi r}\ndef ci (x : X) (r : \u211d\u22650\u221e) := {y | edist x y \u2208 Ici r}\n\n\nlemma oo_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oo x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oo x r R := by\n  simp_rw [oo, Annulus.oo, edist_dist, mem_Ioo, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma oc_eq_annulus {x : X} {r R : \u211d} (hr : r \u2265 0) :\n    oc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.oc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [oc, Annulus.oc, edist_dist, mem_Ioc, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  \u00b7 have R_le_r := (lt_of_lt_of_le (lt_of_not_ge hR) hr).le\n    rw [Annulus.oc_eq_empty R_le_r]\n    refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n    exact not_le_of_gt (lt_of_le_of_lt (ENNReal.ofReal_le_ofReal R_le_r) hy.1) hy.2\n\nlemma co_eq_annulus {x : X} {r R : \u211d} :\n    co x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.co x r R := by\n  simp_rw [co, Annulus.co, edist_dist, mem_Ico, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n    ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\nlemma cc_eq_annulus {x : X} {r R : \u211d} (h : r > 0 \u2228 R \u2265 0) :\n    cc x (ENNReal.ofReal r) (ENNReal.ofReal R) = Annulus.cc x r R := by\n  by_cases hR : R \u2265 0\n  \u00b7 simp_rw [cc, Annulus.cc, edist_dist, mem_Icc, ENNReal.ofReal_le_ofReal_iff dist_nonneg,\n      ENNReal.ofReal_le_ofReal_iff hR]\n  have r0 := h.resolve_right hR\n  have R_lt_r := (lt_of_not_ge hR).trans r0\n  rw [Annulus.cc_eq_empty R_lt_r]\n  refine eq_empty_of_forall_not_mem (fun y hy \u21a6 ?_)\n  exact not_le_of_gt ((ENNReal.ofReal_lt_ofReal_iff r0).mpr R_lt_r) (hy.1.trans hy.2)\n\nlemma oi_eq_annulus {x : X} {r : \u211d} (hr : r \u2265 0) : oi x (ENNReal.ofReal r) = Annulus.oi x r := by\n  simp_rw [oi, Annulus.oi, edist_dist, mem_Ioi, ENNReal.ofReal_lt_ofReal_iff_of_nonneg hr]\n\nlemma ci_eq_annulus {x : X} {r : \u211d} : ci x (ENNReal.ofReal r) = Annulus.ci x r := by\n  simp_rw [ci, Annulus.ci, edist_dist, mem_Ici, ENNReal.ofReal_le_ofReal_iff dist_nonneg]\n\n\nlemma oo_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oo x r R = ball x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oo, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma oc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    oc x r R = closedBall x R.toReal \u2229 (closedBall x r.toReal)\u1d9c := by\n  ext\n  simp [oc, edist_dist, dist_comm, and_comm, lt_ofReal_iff_toReal_lt hr.ne,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma co_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    co x r R = ball x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [co, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_lt_iff_lt_toReal dist_nonneg hR.ne]\n\nlemma cc_eq_of_lt_top {x : X} {r R : \u211d\u22650\u221e} (hr : r < \u22a4) (hR : R < \u22a4) :\n    cc x r R = closedBall x R.toReal \u2229 (ball x r.toReal)\u1d9c := by\n  ext\n  simp [cc, edist_dist, dist_comm, and_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg,\n    ofReal_le_iff_le_toReal hR.ne]\n\nlemma oi_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : oi x r = (closedBall x r.toReal)\u1d9c := by\n  ext; simp [oi, edist_dist, dist_comm, lt_ofReal_iff_toReal_lt hr.ne]\n\nlemma ci_eq_of_lt_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : ci x r = (ball x r.toReal)\u1d9c := by\n  ext; simp [ci, edist_dist, dist_comm, le_ofReal_iff_toReal_le hr.ne dist_nonneg]\n\n\n@[simp]\nlemma oo_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : oo x r R = \u2205 := by\n  simp [oo, Ioo_eq_empty_of_le h]\n\n@[simp]\nlemma oc_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : oc x r R = \u2205 := by\n  simp [oc, Ioc_eq_empty_of_le h]\n\n@[simp]\nlemma co_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r \u2265 R) : co x r R = \u2205 := by\n  simp [co, Ico_eq_empty_of_le h]\n\n@[simp]\nlemma cc_eq_empty {x : X} {r R : \u211d\u22650\u221e} (h : r > R) : cc x r R = \u2205 := by\n  simp [cc, Icc_eq_empty_of_lt h]\n\n@[simp]\nlemma cc_top_eq_empty {x : X} {R : \u211d\u22650\u221e} : cc x \u22a4 R = \u2205 :=\n  eq_empty_of_forall_not_mem (fun y hy \u21a6 (edist_ne_top x y) (top_le_iff.mp hy.1))\n\n@[simp]\nlemma oi_eq_empty {x : X} : oi x \u22a4 = \u2205 := by simp [oi, edist_dist]\n\n@[simp]\nlemma ci_eq_empty {x : X} : ci x \u22a4 = \u2205 := by simp [ci, edist_dist]\n\n\nlemma oo_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) :\n    oo x r \u22a4 = (closedBall x r.toReal)\u1d9c := by\n  ext; simpa [oo, edist_dist, dist_comm] using lt_ofReal_iff_toReal_lt hr.ne\n\nlemma oc_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) :\n    oc x r \u22a4 = (closedBall x r.toReal)\u1d9c := by\n  ext; simpa [oc, edist_dist, dist_comm] using lt_ofReal_iff_toReal_lt hr.ne\n\nlemma co_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : co x r \u22a4 = (ball x r.toReal)\u1d9c := by\n  ext; simpa [co, edist_dist, dist_comm] using le_ofReal_iff_toReal_le hr.ne dist_nonneg\n\nlemma cc_eq_of_top {x : X} {r : \u211d\u22650\u221e} (hr : r < \u22a4) : cc x r \u22a4 = (ball x r.toReal)\u1d9c := by\n  ext; simpa [cc, edist_dist, dist_comm] using le_ofReal_iff_toReal_le hr.ne dist_nonneg\n\n\nlemma oo_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma oo_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oo x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, hR\u2081.le.trans hR\u27e9\n\nlemma oo_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oo_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma oc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_le_of_lt hr hr\u2081, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081.le, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma oc_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    oc x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8(lt_of_le_of_lt hr hr\u2081).le, hR\u2081.trans hR\u27e9\n\nlemma oc_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oo x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_le_of_lt hr hr\u2081\n\nlemma oc_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : oc x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081.le\n\nlemma co_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_lt_of_le hR\u2081 hR\u27e9\n\nlemma co_subset_cc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    co x r\u2081 R\u2081 \u2286 cc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, hR\u2081.le.trans hR\u27e9\n\nlemma co_subset_oi {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) : co x r\u2081 R\u2081 \u2286 oi x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 lt_of_lt_of_le hr hr\u2081\n\nlemma co_subset_ci {x : X} {r\u2081 R\u2081 r\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) : co x r\u2081 R\u2081 \u2286 ci x r\u2082 :=\n  fun _ \u27e8hr\u2081, _\u27e9 \u21a6 hr.trans hr\u2081\n\nlemma cc_subset_oo {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oo x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9\n\nlemma cc_subset_oc {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 < r\u2081) (hR : R\u2081 \u2264 R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 oc x r\u2082 R\u2082 :=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8lt_of_lt_of_le hr hr\u2081, hR\u2081.trans hR\u27e9\n\n", "theoremStatement": "lemma cc_subset_co {x : X} {r\u2081 R\u2081 r\u2082 R\u2082 : \u211d\u22650\u221e} (hr : r\u2082 \u2264 r\u2081) (hR : R\u2081 < R\u2082) :\n    cc x r\u2081 R\u2081 \u2286 co x r\u2082 R\u2082 ", "theoremName": "Set.EAnnulus.cc_subset_co", "fileCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "theoremCreated": {"commit": "0495438c0d02f90a1b74daf13a0bfcb22062e51e", "date": "2025-01-30"}, "file": "carleson/Carleson/ToMathlib/Annulus.lean", "module": "Carleson.ToMathlib.Annulus", "jsonFile": "Carleson.ToMathlib.Annulus.jsonl", "positionMetadata": {"lineInFile": 442, "tokenPositionInFile": 17434, "theoremPositionInFile": 107}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 26}, "proofMetadata": {"hasProof": true, "proof": ":=\n  fun _ \u27e8hr\u2081, hR\u2081\u27e9 \u21a6 \u27e8hr.trans hr\u2081, lt_of_le_of_lt hR\u2081 hR\u27e9", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 61}}
{"srcContext": "import Mathlib.Analysis.Convex.SpecificFunctions.Basic\n\nopen Set Bornology Function ENNReal Metric\n\n-- TODO: Not needed, but good for completeness\n-- theorem strictConvexOn_rpow_left (b : \u211d) (hb : 0 < b) :\n--     StrictConvexOn \u211d Set.univ (fun (x : \u211d) => b ^ x) := by\n--   sorry\n\n", "theoremStatement": "theorem ConvexOn_rpow_left (b : \u211d) (hb : 0 < b) :\n    ConvexOn \u211d Set.univ (fun (x : \u211d) => b ^ x) ", "theoremName": "ConvexOn_rpow_left", "fileCreated": {"commit": "00461dab835e5d7d24409f817f9b57c9d3db66ab", "date": "2025-02-03"}, "theoremCreated": {"commit": "00461dab835e5d7d24409f817f9b57c9d3db66ab", "date": "2025-02-03"}, "file": "carleson/Carleson/ToMathlib/Analysis/Convex/SpecificFunctions/Basic.lean", "module": "Carleson.ToMathlib.Analysis.Convex.SpecificFunctions.Basic", "jsonFile": "Carleson.ToMathlib.Analysis.Convex.SpecificFunctions.Basic.jsonl", "positionMetadata": {"lineInFile": 10, "tokenPositionInFile": 280, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 71}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  have : (fun x => b ^ x) = (Real.exp \u2218 (Real.log b * \u00b7)) := by\n    ext x\n    simp only [comp_apply]\n    rw [<-Real.rpow_def_of_pos hb]\n  rw [this]\n  exact ConvexOn.comp_linearMap convexOn_exp (LinearMap.mul \u211d \u211d (Real.log b))", "proofType": "tactic", "proofLengthLines": 6, "proofLengthTokens": 231}}
{"srcContext": "import Carleson.ToMathlib.DoublingMeasure\nimport Carleson.ToMathlib.RealInterpolation\nimport Mathlib.MeasureTheory.Covering.Vitali\n\nopen MeasureTheory Metric Bornology Set TopologicalSpace Vitali Filter ENNReal Pointwise\nopen scoped NNReal\nnoncomputable section\n\n/-! This should roughly contain the contents of chapter 9. -/\n\nsection Prelude\n\nvariable {X : Type*} [PseudoMetricSpace X] [SeparableSpace X]\n\nvariable (X) in\n/-- Lemma 9.0.2 -/\nlemma covering_separable_space :\n    \u2203 C : Set X, C.Countable \u2227 \u2200 r > 0, \u22c3 c \u2208 C, ball c r = univ := by\n  simp_rw [\u2190 Metric.dense_iff_iUnion_ball, exists_countable_dense]\n\nlemma countable_globalMaximalFunction :\n    (covering_separable_space X).choose \u00d7\u02e2 (univ : Set \u2124) |>.Countable :=\n  (covering_separable_space X).choose_spec.1.prod countable_univ\n\nlemma exists_ball_subset_ball_two (c : X) {r : \u211d} (hr : 0 < r) :\n    \u2203 c' \u2208 (covering_separable_space X).choose,\n      \u2203 m : \u2124, ball c r \u2286 ball c' (2 ^ m) \u2227 2 ^ m \u2264 2 * r \u2227 ball c' (2 ^ m) \u2286 ball c (4 * r) := by\n  obtain \u27e8_, hCr\u27e9 := (covering_separable_space X).choose_spec\n  let m := \u230aReal.logb 2 r\u230b\n  have hm : 2 ^ m \u2264 r := by\n    calc _ \u2264 (2 : \u211d) ^ (Real.logb 2 r) := by\n          convert Real.monotone_rpow_of_base_ge_one one_le_two (Int.floor_le _)\n          exact (Real.rpow_intCast 2 m).symm\n      _ = _ := Real.rpow_logb zero_lt_two (OfNat.one_ne_ofNat 2).symm hr\n  have hm' : r < 2 ^ (m + 1) := by\n    calc _ = (2 : \u211d) ^ Real.logb 2 r := (Real.rpow_logb zero_lt_two (OfNat.one_ne_ofNat 2).symm hr).symm\n      _ < _ := by\n        rw [\u2190 Real.rpow_intCast 2 (m + 1)]\n        refine Real.strictMono_rpow_of_base_gt_one one_lt_two ?_\n        simp [m]\n  let a := ((2 : \u211d) ^ (m + 1) - r) / 2\n  have h_univ := hCr a (by simp [a, hm'])\n  obtain \u27e8c', hc', hcc'\u27e9 := mem_iUnion\u2082.mp <| h_univ \u25b8 Set.mem_univ c\n  refine \u27e8c', hc', m + 1, ball_subset_ball_of_le ?_, ?_, ?_\u27e9\n  \u00b7 calc\n      _ \u2264 a + r := by gcongr; exact (dist_comm c c' \u25b8 mem_ball.mp hcc').le\n      _ \u2264 _ := by simp only [a, sub_div]; linarith\n  \u00b7 rw [\u2190 Real.rpow_intCast 2 (m + 1)]\n    push_cast\n    rw [Real.rpow_add_one two_ne_zero m, mul_comm]\n    gcongr\n    exact_mod_cast hm\n  \u00b7 refine ball_subset_ball_of_le ?_\n    calc\n      _ \u2264 a + 2 ^ (m + 1) := by gcongr; exact (mem_ball.mp hcc').le\n      _ \u2264 2 ^ (m + 1) + 2 ^ (m + 1) := by\n        gcongr\n        simp only [a]\n        linarith\n      _ \u2264 2 * r + 2 * r := by\n        rw [\u2190 Real.rpow_intCast 2 (m + 1)]\n        push_cast\n        rw [Real.rpow_add_one two_ne_zero m, mul_comm]\n        gcongr <;> simp [hm]\n      _ = 4 * r := by ring\n\nend Prelude\n\nvariable {X E : Type*} {A : \u211d\u22650} [MetricSpace X] [MeasurableSpace X]\n  {\u03bc : Measure X} [\u03bc.IsDoubling A] [NormedAddCommGroup E]\n  {f : X \u2192 E} {x : X} {\u03b9 : Type*} {\ud835\udcd1 : Set \u03b9} {c : \u03b9 \u2192 X} {r : \u03b9 \u2192 \u211d}\n  -- feel free to assume `A \u2265 16` or similar\n\n/-- The Hardy-Littlewood maximal function w.r.t. a collection of balls \ud835\udcd1.\nM_{\ud835\udcd1, p} in the blueprint. -/\ndef maximalFunction (\u03bc : Measure X) (\ud835\udcd1 : Set \u03b9) (c : \u03b9 \u2192 X) (r : \u03b9 \u2192 \u211d)\n    (p : \u211d) (u : X \u2192 E) (x : X) : \u211d\u22650\u221e :=\n  (\u2a06 i \u2208 \ud835\udcd1, (ball (c i) (r i)).indicator (x := x)\n    fun _ \u21a6 \u2a0d\u207b y in ball (c i) (r i), \u2016u y\u2016\u208a ^ p \u2202\u03bc) ^ p\u207b\u00b9\n\n/-- The Hardy-Littlewood maximal function w.r.t. a collection of balls \ud835\udcd1 with exponent 1.\nM_\ud835\udcd1 in the blueprint. -/\nabbrev MB (\u03bc : Measure X) (\ud835\udcd1 : Set \u03b9) (c : \u03b9 \u2192 X) (r : \u03b9 \u2192 \u211d) (u : X \u2192 E) (x : X) : \u211d\u22650\u221e :=\n  maximalFunction \u03bc \ud835\udcd1 c r 1 u x\n\nlemma maximalFunction_eq_MB\n    {\u03bc : Measure X} {\ud835\udcd1 : Set \u03b9} {c : \u03b9 \u2192 X} {r : \u03b9 \u2192 \u211d} {p : \u211d} {u : X \u2192 E} {x : X} (hp : 0 \u2264 p) :\n    maximalFunction \u03bc \ud835\udcd1 c r p u x = (MB \u03bc \ud835\udcd1 c r (\u2016u \u00b7\u2016 ^ p) x) ^ p\u207b\u00b9 := by\n  unfold MB maximalFunction; rw [\u2190 ENNReal.rpow_mul, inv_one, one_mul]; congr! 8\n  rw [ENNReal.rpow_one, \u2190 ENNReal.coe_rpow_of_nonneg _ hp, ENNReal.coe_inj,\n    Real.nnnorm_rpow_of_nonneg (by simp), nnnorm_norm]\n\n-- We will replace the criterion `P` used in `MeasureTheory.AESublinearOn.maximalFunction` with the\n-- weaker criterion `LocallyIntegrable` that is closed under addition and scalar multiplication.\n\n-- The average that appears in the definition of `MB`\nvariable (\u03bc c r) in\nprivate def T (i : \u03b9) (u : X \u2192 E) := \u2a0d\u207b (y : X) in ball (c i) (r i), \u2016u y\u2016\u208a \u2202\u03bc\n\n-- move\nlemma MeasureTheory.LocallyIntegrable.integrableOn_of_isBounded [ProperSpace X]\n    {f : X \u2192 E} (hf : LocallyIntegrable f \u03bc) {s : Set X}\n    (hs : IsBounded s) : IntegrableOn f s \u03bc :=\n  hf.integrableOn_isCompact hs.isCompact_closure |>.mono_set subset_closure\n\n-- move\nlemma MeasureTheory.LocallyIntegrable.integrableOn_ball [ProperSpace X]\n    {f : X \u2192 E} (hf : LocallyIntegrable f \u03bc) {x : X} {r : \u211d} : IntegrableOn f (ball x r) \u03bc :=\n  hf.integrableOn_of_isBounded isBounded_ball\n\n-- move\nlemma MeasureTheory.LocallyIntegrable.laverage_ball_lt_top [ProperSpace X]\n    {f : X \u2192 E} (hf : LocallyIntegrable f \u03bc)\n    {x\u2080 : X} {r : \u211d} :\n    \u2a0d\u207b x in ball x\u2080 r, \u2016f x\u2016\u208a \u2202\u03bc < \u22a4 :=\n  laverage_lt_top hf.integrableOn_ball.2.ne\n\nprivate lemma T.add_le [MeasurableSpace E] [BorelSpace E] [BorelSpace X] [ProperSpace X]\n    (i : \u03b9) {f g : X \u2192 E} (hf : LocallyIntegrable f \u03bc) :\n    \u2016T \u03bc c r i (f + g)\u2016\u2091 \u2264 \u2016T \u03bc c r i f\u2016\u2091 + \u2016T \u03bc c r i g\u2016\u2091 := by\n  simp only [T, Pi.add_apply, enorm_eq_self, \u2190 enorm_eq_nnnorm]\n  rw [\u2190 laverage_add_left hf.integrableOn_ball.aemeasurable.enorm]\n  exact laverage_mono (fun x \u21a6 ENNNorm_add_le (f x) (g x))\n\n-- move\nlemma NNReal.smul_ennreal_eq_mul (x : \u211d\u22650) (y : \u211d\u22650\u221e) : x \u2022 y = x * y := rfl\n\nprivate lemma T.smul [NormedSpace \u211d E] (i : \u03b9) : \u2200 {f : X \u2192 E} {d : \u211d\u22650}, LocallyIntegrable f \u03bc \u2192\n    T \u03bc c r i (d \u2022 f) = d \u2022 T \u03bc c r i f := by\n  intro f d _\n  simp_rw [T, Pi.smul_apply, NNReal.smul_def, NNReal.smul_ennreal_eq_mul,\n    laverage_const_mul ENNReal.coe_ne_top]\n  simp [nnnorm_smul]\n\n-- todo: move\n-- slightly more general than the Mathlib version\n-- the extra conclusion says that if there is a nonnegative radius, then we can choose `r b` to be\n-- larger than `r a` (up to a constant)\ntheorem exists_disjoint_subfamily_covering_enlargement_closedBall' {\u03b1} [MetricSpace \u03b1] (t : Set \u03b9)\n    (x : \u03b9 \u2192 \u03b1) (r : \u03b9 \u2192 \u211d) (R : \u211d) (hr : \u2200 a \u2208 t, r a \u2264 R) (\u03c4 : \u211d) (h\u03c4 : 3 < \u03c4) :\n    \u2203 u \u2286 t,\n      (u.PairwiseDisjoint fun a => closedBall (x a) (r a)) \u2227\n        \u2200 a \u2208 t, \u2203 b \u2208 u, closedBall (x a) (r a) \u2286 closedBall (x b) (\u03c4 * r b) \u2227\n        (\u2200 u \u2208 t, 0 \u2264 r u \u2192 r a \u2264 (\u03c4 - 1) / 2 * r b) := by\n  rcases eq_empty_or_nonempty t with (rfl | _)\n  \u00b7 exact \u27e8\u2205, Subset.refl _, pairwiseDisjoint_empty, by simp\u27e9\n  by_cases ht : \u2200 a \u2208 t, r a < 0\n  \u00b7 refine \u27e8t, .rfl, fun a ha b _ _ \u21a6 by\n      simp only [Function.onFun, closedBall_eq_empty.2 (ht a ha), empty_disjoint],\n      fun a ha => \u27e8a, ha, by simp only [closedBall_eq_empty.2 (ht a ha), empty_subset],\n      fun u hut hu \u21a6 (ht u hut).not_le hu |>.elim\u27e9\u27e9\n  push_neg at ht\n  let t' := { a \u2208 t | 0 \u2264 r a }\n  have h2\u03c4 : 1 < (\u03c4 - 1) / 2 := by linarith\n  rcases exists_disjoint_subfamily_covering_enlargement (fun a => closedBall (x a) (r a)) t' r\n      ((\u03c4 - 1) / 2) h2\u03c4 (fun a ha => ha.2) R (fun a ha => hr a ha.1) fun a ha =>\n      \u27e8x a, mem_closedBall_self ha.2\u27e9 with\n    \u27e8u, ut', u_disj, hu\u27e9\n  have A : \u2200 a \u2208 t', \u2203 b \u2208 u, closedBall (x a) (r a) \u2286 closedBall (x b) (\u03c4 * r b) \u2227\n    \u2200 u \u2208 t, 0 \u2264 r u \u2192 r a \u2264 (\u03c4 - 1) / 2 * r b := by\n    intro a ha\n    rcases hu a ha with \u27e8b, bu, hb, rb\u27e9\n    refine \u27e8b, bu, ?_\u27e9\n    have : dist (x a) (x b) \u2264 r a + r b := dist_le_add_of_nonempty_closedBall_inter_closedBall hb\n    exact \u27e8closedBall_subset_closedBall' <| by linarith, fun _ _ _ \u21a6 rb\u27e9\n  refine \u27e8u, ut'.trans fun a ha => ha.1, u_disj, fun a ha => ?_\u27e9\n  rcases le_or_lt 0 (r a) with (h'a | h'a)\n  \u00b7 exact A a \u27e8ha, h'a\u27e9\n  \u00b7 rcases ht with \u27e8b, rb\u27e9\n    rcases A b \u27e8rb.1, rb.2\u27e9 with \u27e8c, cu, _, hc\u27e9\n    refine \u27e8c, cu, by simp only [closedBall_eq_empty.2 h'a, empty_subset], fun _ _ _ \u21a6 ?_\u27e9\n    have : 0 \u2264 r c := nonneg_of_mul_nonneg_right (rb.2.trans <| hc b rb.1 rb.2) (by positivity)\n    exact h'a.le.trans <| by positivity\n\n-- move to Vitali\ntheorem Vitali.exists_disjoint_subfamily_covering_enlargement_ball {\u03b1} [MetricSpace \u03b1] (t : Set \u03b9)\n    (x : \u03b9 \u2192 \u03b1) (r : \u03b9 \u2192 \u211d) (R : \u211d) (hr : \u2200 a \u2208 t, r a \u2264 R) (\u03c4 : \u211d) (h\u03c4 : 3 < \u03c4) :\n    \u2203 u \u2286 t,\n      (u.PairwiseDisjoint fun a => ball (x a) (r a)) \u2227\n        \u2200 a \u2208 t, \u2203 b \u2208 u, ball (x a) (r a) \u2286 ball (x b) (\u03c4 * r b) := by\n  obtain \u27e8\u03c3, h\u03c3, h\u03c3\u03c4\u27e9 := exists_between h\u03c4\n  obtain \u27e8u, hut, hux, hu\u27e9 :=\n    exists_disjoint_subfamily_covering_enlargement_closedBall' t x r R hr \u03c3 h\u03c3\n  refine \u27e8u, hut, fun i hi j hj hij \u21a6 ?_, fun a ha => ?_\u27e9\n  \u00b7 exact (hux hi hj hij).mono ball_subset_closedBall ball_subset_closedBall\n  obtain \u27e8b, hbu, hb\u27e9 := hu a ha\n  refine \u27e8b, hbu, ?_\u27e9\n  obtain h2a|h2a := le_or_lt (r a) 0\n  \u00b7 simp_rw [ball_eq_empty.mpr h2a, empty_subset]\n  refine ball_subset_closedBall.trans hb.1 |>.trans <| closedBall_subset_ball ?_\n  gcongr\n  apply pos_of_mul_pos_right <| h2a.trans_le <| hb.2 a ha h2a.le\n  linarith\n\n-- move next to Finset.exists_le\nlemma Finset.exists_image_le {\u03b1 \u03b2} [Nonempty \u03b2] [Preorder \u03b2] [IsDirected \u03b2 (\u00b7 \u2264 \u00b7)]\n    (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) : \u2203 b : \u03b2, \u2200 a \u2208 s, f a \u2264 b := by\n  classical\n  simpa using s.image f |>.exists_le\n\n-- move\nlemma Set.Finite.exists_image_le {\u03b1 \u03b2} [Nonempty \u03b2] [Preorder \u03b2] [IsDirected \u03b2 (\u00b7 \u2264 \u00b7)]\n    {s : Set \u03b1} (hs : s.Finite) (f : \u03b1 \u2192 \u03b2) : \u2203 b : \u03b2, \u2200 a \u2208 s, f a \u2264 b := by\n  simpa using hs.toFinset.exists_image_le f\n\ntheorem Set.Countable.measure_biUnion_le_lintegral [OpensMeasurableSpace X] (h\ud835\udcd1 : \ud835\udcd1.Countable)\n    (l : \u211d\u22650\u221e) (u : X \u2192 \u211d\u22650\u221e) (R : \u211d) (hR : \u2200 a \u2208 \ud835\udcd1, r a \u2264 R)\n    (h2u : \u2200 i \u2208 \ud835\udcd1, l * \u03bc (ball (c i) (r i)) \u2264 \u222b\u207b x in ball (c i) (r i), u x \u2202\u03bc) :\n    l * \u03bc (\u22c3 i \u2208 \ud835\udcd1, ball (c i) (r i)) \u2264 A ^ 2 * \u222b\u207b x, u x \u2202\u03bc  := by\n  obtain \u27e8B, hB\ud835\udcd1, hB, h2B\u27e9 := Vitali.exists_disjoint_subfamily_covering_enlargement_ball\n    \ud835\udcd1 c r R hR (2 ^ 2) (by norm_num)\n  have : Countable B := h\ud835\udcd1.mono hB\ud835\udcd1\n  have disj := fun i j hij \u21a6\n    hB (Subtype.coe_prop i) (Subtype.coe_prop j) (Subtype.coe_ne_coe.mpr hij)\n  calc\n    l * \u03bc (\u22c3 i \u2208 \ud835\udcd1, ball (c i) (r i)) \u2264 l * \u03bc (\u22c3 i \u2208 B, ball (c i) (2 ^ 2 * r i)) := by\n          refine mul_left_mono (\u03bc.mono fun x hx \u21a6 ?_)\n          simp only [mem_iUnion, mem_ball, exists_prop] at hx\n          rcases hx with \u27e8i, i\ud835\udcd1, hi\u27e9\n          obtain \u27e8b, bB, hb\u27e9 := h2B i i\ud835\udcd1\n          refine mem_iUnion\u2082.mpr \u27e8b, bB, hb <| mem_ball.mpr hi\u27e9\n    _ \u2264 l * \u2211' i : B, \u03bc (ball (c i) (2 ^ 2 * r i)) :=\n          mul_left_mono <| measure_biUnion_le \u03bc (h\ud835\udcd1.mono hB\ud835\udcd1) fun i \u21a6 ball (c i) (2 ^ 2 * r i)\n    _ \u2264 l * \u2211' i : B, A ^ 2 * \u03bc (ball (c i) (r i)) := by\n          refine mul_left_mono <| ENNReal.tsum_le_tsum (fun i \u21a6 ?_)\n          rw [sq, sq, mul_assoc, mul_assoc]\n          apply (measure_ball_two_le_same (c i) (2 * r i)).trans\n          exact mul_left_mono (measure_ball_two_le_same (c i) (r i))\n    _ = A ^ 2 * \u2211' i : B, l * \u03bc (ball (c i) (r i)) := by\n          rw [ENNReal.tsum_mul_left, ENNReal.tsum_mul_left, \u2190 mul_assoc, \u2190 mul_assoc, mul_comm l]\n    _ \u2264 A ^ 2 * \u2211' i : B, \u222b\u207b x in ball (c i) (r i), u x \u2202\u03bc := by\n          gcongr; exact h2u _ (hB\ud835\udcd1 (Subtype.coe_prop _))\n    _ = A ^ 2 * \u222b\u207b x in \u22c3 i \u2208 B, ball (c i) (r i), u x \u2202\u03bc := by\n          congr; simpa using (lintegral_iUnion (fun i \u21a6 measurableSet_ball) disj u).symm\n    _ \u2264 A ^ 2 * \u222b\u207b x, u x \u2202\u03bc := by\n          gcongr; exact setLIntegral_le_lintegral (\u22c3 i \u2208 B, ball (c i) (r i)) u\n\nprotected theorem Finset.measure_biUnion_le_lintegral [OpensMeasurableSpace X] (\ud835\udcd1 : Finset \u03b9)\n    (l : \u211d\u22650\u221e) (u : X \u2192 \u211d\u22650\u221e)\n    (h2u : \u2200 i \u2208 \ud835\udcd1, l * \u03bc (ball (c i) (r i)) \u2264 \u222b\u207b x in ball (c i) (r i), u x \u2202\u03bc) :\n    l * \u03bc (\u22c3 i \u2208 \ud835\udcd1, ball (c i) (r i)) \u2264 A ^ 2 * \u222b\u207b x, u x \u2202\u03bc  :=\n  let \u27e8c, hc\u27e9 := \ud835\udcd1.exists_image_le r\n  \ud835\udcd1.countable_toSet.measure_biUnion_le_lintegral l u c hc h2u\n\nprotected theorem MeasureTheory.AEStronglyMeasurable.maximalFunction [BorelSpace X] {p : \u211d}\n    {u : X \u2192 E} (h\ud835\udcd1 : \ud835\udcd1.Countable) : AEStronglyMeasurable (maximalFunction \u03bc \ud835\udcd1 c r p u) \u03bc :=\n  (AEMeasurable.biSup \ud835\udcd1 h\ud835\udcd1 fun _ _ \u21a6 aemeasurable_const.indicator measurableSet_ball).pow\n    aemeasurable_const |>.aestronglyMeasurable\n\ntheorem MeasureTheory.AEStronglyMeasurable.maximalFunction_toReal [BorelSpace X]\n    {p : \u211d} {u : X \u2192 E} (h\ud835\udcd1 : \ud835\udcd1.Countable) :\n    AEStronglyMeasurable (fun x \u21a6 maximalFunction \u03bc \ud835\udcd1 c r p u x |>.toReal) \u03bc :=\n  AEStronglyMeasurable.maximalFunction h\ud835\udcd1 |>.ennreal_toReal\n\ntheorem MB_le_eLpNormEssSup {u : X \u2192 E} {x : X} : MB \u03bc \ud835\udcd1 c r u x \u2264 eLpNormEssSup u \u03bc :=\n  calc MB \u03bc \ud835\udcd1 c r u x \u2264\n    \u2a06 i \u2208 \ud835\udcd1, (ball (c i) (r i)).indicator (x := x)\n        fun _x \u21a6 \u2a0d\u207b _y in ball (c i) (r i), eLpNormEssSup u \u03bc \u2202\u03bc := by\n        simp_rw [MB, maximalFunction, inv_one, ENNReal.rpow_one]\n        gcongr\n        exact coe_nnnorm_ae_le_eLpNormEssSup u \u03bc\n    _ \u2264 \u2a06 i \u2208 \ud835\udcd1, (ball (c i) (r i)).indicator (x := x) fun _x \u21a6 eLpNormEssSup u \u03bc := by\n      gcongr; apply setLaverage_const_le\n    _ \u2264 \u2a06 i \u2208 \ud835\udcd1, eLpNormEssSup u \u03bc := by gcongr; apply indicator_le_self\n    _ \u2264 eLpNormEssSup u \u03bc := by\n      simp_rw [iSup_le_iff, le_refl, implies_true]\n\nprotected theorem HasStrongType.MB_top [BorelSpace X] (h\ud835\udcd1 : \ud835\udcd1.Countable) :\n    HasStrongType (fun (u : X \u2192 E) (x : X) \u21a6 MB \u03bc \ud835\udcd1 c r u x |>.toReal) \u22a4 \u22a4 \u03bc \u03bc 1 := by\n  intro f _\n  use AEStronglyMeasurable.maximalFunction_toReal h\ud835\udcd1\n  simp only [ENNReal.coe_one, one_mul, eLpNorm_exponent_top]\n  refine essSup_le_of_ae_le _ (Eventually.of_forall fun x \u21a6 ?_)\n  simp_rw [enorm_eq_nnnorm, ENNReal.nnorm_toReal]\n  exact ENNReal.coe_toNNReal_le_self |>.trans MB_le_eLpNormEssSup\n\n/- The proof is roughly between (9.0.12)-(9.0.22). -/\nprotected theorem HasWeakType.MB_one [BorelSpace X] (h\ud835\udcd1 : \ud835\udcd1.Countable)\n    {R : \u211d} (hR : \u2200 i \u2208 \ud835\udcd1, r i \u2264 R) :\n    HasWeakType (MB (E := E) \u03bc \ud835\udcd1 c r) 1 1 \u03bc \u03bc (A ^ 2) := by\n  intro f _\n  use AEStronglyMeasurable.maximalFunction h\ud835\udcd1\n  let B\u2097 (\u2113 : \u211d\u22650\u221e) := { i \u2208 \ud835\udcd1 | \u222b\u207b y in (ball (c i) (r i)), \u2016f y\u2016\u208a \u2202\u03bc \u2265 \u2113 * \u03bc (ball (c i) (r i)) }\n  simp only [wnorm, one_ne_top, wnorm', one_toReal, inv_one, ENNReal.rpow_one, reduceIte,\n    ENNReal.coe_pow, eLpNorm, one_ne_zero, eLpNorm', ne_eq, not_false_eq_true, div_self,\n    iSup_le_iff]\n  intro t\n  by_cases ht : t = 0\n  \u00b7 simp [ht]\n  have hB\u2097 : (B\u2097 t).Countable := h\ud835\udcd1.mono (fun i hi \u21a6 mem_of_mem_inter_left hi)\n  refine le_trans ?_ (hB\u2097.measure_biUnion_le_lintegral (c := c) (r := r) (l := t)\n    (u := fun x \u21a6 \u2016f x\u2016\u208a) (R := R) ?_ ?_)\n  \u00b7 refine mul_left_mono <| \u03bc.mono (fun x hx \u21a6 mem_iUnion\u2082.mpr ?_)\n    -- We need a ball in `B\u2097 t` containing `x`. Since `MB \u03bc \ud835\udcd1 c r f x` is large, such a ball exists\n    simp only [mem_setOf_eq] at hx\n    -- replace hx := lt_of_lt_of_le hx coe_toNNReal_le_self\n    simp only [MB, maximalFunction, ENNReal.rpow_one, inv_one] at hx\n    obtain \u27e8i, ht\u27e9 := lt_iSup_iff.mp hx\n    replace hx : x \u2208 ball (c i) (r i) :=\n      by_contradiction <| fun h \u21a6 not_lt_of_ge (zero_le t) (ENNReal.coe_lt_coe.mp <| by simp [h] at ht)\n    refine \u27e8i, ?_, hx\u27e9\n    -- It remains only to confirm that the chosen ball is actually in `B\u2097 t`\n    simp only [ge_iff_le, mem_setOf_eq, B\u2097]\n    have hi : i \u2208 \ud835\udcd1 :=\n      by_contradiction <| fun h \u21a6 not_lt_of_ge (zero_le t) (ENNReal.coe_lt_coe.mp <| by simp [h] at ht)\n    exact \u27e8hi, mul_le_of_le_div <| le_of_lt (by simpa [setLaverage_eq, hi, hx] using ht)\u27e9\n  \u00b7 exact fun i hi \u21a6 hR i (mem_of_mem_inter_left hi)\n  \u00b7 exact fun i hi \u21a6 hi.2.trans (setLIntegral_mono' measurableSet_ball fun x _ \u21a6 by simp)\n\nprotected theorem HasWeakType.MB_one_toReal [BorelSpace X] (h\ud835\udcd1 : \ud835\udcd1.Countable)\n    {R : \u211d} (hR : \u2200 i \u2208 \ud835\udcd1, r i \u2264 R) :\n    HasWeakType (fun (u : X \u2192 E) (x : X) \u21a6 MB \u03bc \ud835\udcd1 c r u x |>.toReal) 1 1 \u03bc \u03bc (A ^ 2) :=\n  HasWeakType.MB_one h\ud835\udcd1 hR |>.toReal\n\ninclude A in\ntheorem MB_ae_ne_top [BorelSpace X] (h\ud835\udcd1 : \ud835\udcd1.Countable)\n    {R : \u211d} (hR : \u2200 i \u2208 \ud835\udcd1, r i \u2264 R)\n    {u : X \u2192 E} (hu : Mem\u2112p u 1 \u03bc) : \u2200\u1d50 x : X \u2202\u03bc, MB \u03bc \ud835\udcd1 c r u x \u2260 \u221e := by\n  simpa only [enorm_eq_self] using HasWeakType.MB_one h\ud835\udcd1 hR |>.memW\u2112p hu |>.ae_ne_top\n\n-- move\n", "theoremStatement": "lemma MeasureTheory.Mem\u2112p.eLpNormEssSup_lt_top {\u03b1} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1}\n    {u : \u03b1 \u2192 E} (hu : Mem\u2112p u \u22a4 \u03bc) : eLpNormEssSup u \u03bc < \u22a4 ", "theoremName": "MeasureTheory.Mem\u2112p.eLpNormEssSup_lt_top", "fileCreated": {"commit": "1a36cbeaee9466fb56c9aca49ef373f9f9cc7ab7", "date": "2025-01-23"}, "theoremCreated": {"commit": "b069d5bb71885f498386762866228ac78bf5409e", "date": "2025-01-13"}, "file": "carleson/Carleson/ToMathlib/HardyLittlewood.lean", "module": "Carleson.ToMathlib.HardyLittlewood", "jsonFile": "Carleson.ToMathlib.HardyLittlewood.jsonl", "positionMetadata": {"lineInFile": 322, "tokenPositionInFile": 15567, "theoremPositionInFile": 26}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 3, "numPremises": 32}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp_rw [Mem\u2112p, eLpNorm_exponent_top] at hu\n  exact hu.2", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 64}}
{"srcContext": "import Mathlib.MeasureTheory.Integral.MeanInequalities\nimport Mathlib.MeasureTheory.Integral.Layercake\nimport Mathlib.MeasureTheory.Integral.Lebesgue\nimport Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar\nimport Mathlib.Analysis.SpecialFunctions.Pow.Integral\nimport Carleson.ToMathlib.ENorm\nimport Carleson.ToMathlib.Misc\n\nnoncomputable section\n\nopen NNReal ENNReal NormedSpace MeasureTheory Set Filter Topology Function\n\nsection move\n\n\nvariable {\u03b1 \ud835\udd5c E : Type*} {m : MeasurableSpace \u03b1}\n  {\u03bc : Measure \u03b1} [NontriviallyNormedField \ud835\udd5c]\n  [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]\n  {p : \u211d\u22650\u221e}\n\n-- todo: move/rename/and perhaps reformulate in terms of \u2016.\u2016\u2091\nlemma ENNNorm_absolute_homogeneous {c : \ud835\udd5c} (z : E) : ofNNReal \u2016c \u2022 z\u2016\u208a = \u2191\u2016c\u2016\u208a * \u2191\u2016z\u2016\u208a :=\n  (toReal_eq_toReal_iff' coe_ne_top coe_ne_top).mp (norm_smul c z)\n\nlemma ENNNorm_add_le (y z : E) : ofNNReal \u2016y + z\u2016\u208a \u2264 \u2191\u2016y\u2016\u208a + \u2191\u2016z\u2016\u208a :=\n  (toReal_le_toReal coe_ne_top coe_ne_top).mp (nnnorm_add_le ..)\n\nlemma measure_mono_ae' {A B : Set \u03b1} (h : \u03bc (B \\ A) = 0) :\n    \u03bc B \u2264 \u03bc A := by\n  apply measure_mono_ae\n  change \u03bc {x | \u00ac B x \u2264 A x} = 0\n  simp only [le_Prop_eq, Classical.not_imp]\n  exact h\n\n\nlemma eLpNormEssSup_toReal_le {f : \u03b1 \u2192 \u211d\u22650\u221e} :\n    eLpNormEssSup (ENNReal.toReal \u2218 f) \u03bc \u2264 eLpNormEssSup f \u03bc := by\n  simp_rw [eLpNormEssSup, enorm_eq_self]\n  apply essSup_mono_ae\n  apply Eventually.of_forall\n  simp [implies_true]\n\nlemma eLpNormEssSup_toReal_eq {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : \u2200\u1d50 x \u2202\u03bc, f x \u2260 \u221e) :\n    eLpNormEssSup (ENNReal.toReal \u2218 f) \u03bc = eLpNormEssSup f \u03bc := by\n  simp_rw [eLpNormEssSup, enorm_eq_self]\n  apply essSup_congr_ae\n  filter_upwards [hf] with x hx\n  simp [hx]\n\nlemma eLpNorm'_toReal_le {f : \u03b1 \u2192 \u211d\u22650\u221e} {p : \u211d} (hp : 0 \u2264 p) :\n    eLpNorm' (ENNReal.toReal \u2218 f) p \u03bc \u2264 eLpNorm' f p \u03bc := by\n  simp_rw [eLpNorm', enorm_eq_self]\n  gcongr\n  simp\n\nlemma eLpNorm'_toReal_eq {f : \u03b1 \u2192 \u211d\u22650\u221e} {p : \u211d} (hf : \u2200\u1d50 x \u2202\u03bc, f x \u2260 \u221e) :\n    eLpNorm' (ENNReal.toReal \u2218 f) p \u03bc = eLpNorm' f p \u03bc := by\n  simp_rw [eLpNorm', enorm_eq_self]\n  congr 1\n  apply lintegral_congr_ae\n  filter_upwards [hf] with x hx\n  simp [hx]\n\nlemma eLpNorm_toReal_le {f : \u03b1 \u2192 \u211d\u22650\u221e} :\n    eLpNorm (ENNReal.toReal \u2218 f) p \u03bc \u2264 eLpNorm f p \u03bc := by\n  simp_rw [eLpNorm]\n  split_ifs\n  \u00b7 rfl\n  \u00b7 exact eLpNormEssSup_toReal_le\n  \u00b7 exact eLpNorm'_toReal_le toReal_nonneg\n\nlemma eLpNorm_toReal_eq {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : \u2200\u1d50 x \u2202\u03bc, f x \u2260 \u221e) :\n    eLpNorm (ENNReal.toReal \u2218 f) p \u03bc = eLpNorm f p \u03bc := by\n  simp_rw [eLpNorm]\n  split_ifs\n  \u00b7 rfl\n  \u00b7 exact eLpNormEssSup_toReal_eq hf\n  \u00b7 exact eLpNorm'_toReal_eq hf\n\nend move\n\nnamespace MeasureTheory\n\nvariable {\u03b1 \u03b1' \u03b5 \u03b5\u2081 \u03b5\u2082 \u03b5\u2083 \ud835\udd5c E E\u2081 E\u2082 E\u2083 : Type*} {m : MeasurableSpace \u03b1} {m : MeasurableSpace \u03b1'}\n  {p p' q : \u211d\u22650\u221e} {c : \u211d\u22650}\n  {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b1'} [NontriviallyNormedField \ud835\udd5c]\n  [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]\n  [NormedAddCommGroup E\u2081] [NormedSpace \ud835\udd5c E\u2081]\n  [NormedAddCommGroup E\u2082] [NormedSpace \ud835\udd5c E\u2082]\n  [NormedAddCommGroup E\u2083] [NormedSpace \ud835\udd5c E\u2083]\n  (L : E\u2081 \u2192L[\ud835\udd5c] E\u2082 \u2192L[\ud835\udd5c] E\u2083)\n  {t s x y : \u211d\u22650\u221e}\n  {T : (\u03b1 \u2192 \u03b5\u2081) \u2192 (\u03b1' \u2192 \u03b5\u2082)}\n\nsection ENorm\n\nvariable [ENorm \u03b5] {f g g\u2081 g\u2082 : \u03b1 \u2192 \u03b5}\n\n/- Proofs for this file can be found in\nFolland, Real Analysis. Modern Techniques and Their Applications, section 6.3. -/\n\n/-! # The distribution function `d_f` -/\n\n/-- The distribution function of a function `f`.\nNote that unlike the notes, we also define this for `t = \u221e`.\nNote: we also want to use this for functions with codomain `\u211d\u22650\u221e`, but for those we just write\n`\u03bc { x | t < f x }` -/\ndef distribution (f : \u03b1 \u2192 \u03b5) (t : \u211d\u22650\u221e) (\u03bc : Measure \u03b1) : \u211d\u22650\u221e :=\n  \u03bc { x | t < \u2016f x\u2016\u2091 }\n\n@[gcongr]\nlemma distribution_mono_right (h : t \u2264 s) : distribution f s \u03bc \u2264 distribution f t \u03bc :=\n  measure_mono fun _ a \u21a6 lt_of_le_of_lt h a\n\nlemma distribution_mono_right' : (Antitone (fun t \u21a6 distribution f t \u03bc)) :=\n  fun _ _ h \u21a6 distribution_mono_right h\n\n@[measurability, fun_prop]\nlemma distribution_measurable\u2080 : Measurable (fun t \u21a6 distribution f t \u03bc) :=\n  Antitone.measurable (distribution_mono_right' (f := f) (\u03bc := \u03bc))\n\n@[measurability, fun_prop]\nlemma distribution_measurable {g : \u03b1' \u2192 \u211d\u22650\u221e} (hg : Measurable g) :\n    Measurable (fun y : \u03b1' \u21a6 distribution f (g y) \u03bc) := by\n  fun_prop\n\nlemma distribution_toReal_le {f : \u03b1 \u2192 \u211d\u22650\u221e} :\n    distribution (ENNReal.toReal \u2218 f) t \u03bc \u2264 distribution f t \u03bc := by\n  simp_rw [distribution]\n  apply measure_mono\n  simp_rw [comp_apply, enorm_eq_self, setOf_subset_setOf]\n  intro x hx\n  exact hx.trans_le enorm_toReal_le\n\nlemma distribution_toReal_eq {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : \u2200\u1d50 x \u2202\u03bc, f x \u2260 \u221e) :\n    distribution (ENNReal.toReal \u2218 f) t \u03bc = distribution f t \u03bc := by\n  refine measure_congr (.set_eq ?_)\n  filter_upwards [hf] with x hx\n  simp [hx]\n\nlemma distribution_add_le_of_enorm {A : \u211d\u22650\u221e}\n    (h : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016\u2091 \u2264 A * (\u2016g\u2081 x\u2016\u2091 + \u2016g\u2082 x\u2016\u2091)) :\n    distribution f (A * (t + s)) \u03bc \u2264 distribution g\u2081 t \u03bc + distribution g\u2082 s \u03bc := by\n  unfold distribution\n  have h\u2081 : \u03bc ({x | A * (t + s) < \u2016f x\u2016\u2091} \\\n      ({x | t < \u2016g\u2081 x\u2016\u2091} \u222a {x | s < \u2016g\u2082 x\u2016\u2091})) = 0 := by\n    apply measure_mono_null ?_ h\n    intro x\n    simp only [mem_diff, mem_setOf_eq, mem_union, not_or, not_lt, mem_compl_iff, not_le, and_imp]\n    intro h\u2081 h\u2082 h\u2083\n    refine lt_of_le_of_lt ?_ h\u2081\n    gcongr\n  calc\n    \u03bc {x | A * (t + s) < \u2016f x\u2016\u2091}\n      \u2264 \u03bc ({x | t < \u2016g\u2081 x\u2016\u2091} \u222a {x | s < \u2016g\u2082 x\u2016\u2091}) := measure_mono_ae' h\u2081\n    _ \u2264 \u03bc {x | t < \u2016g\u2081 x\u2016\u2091} + \u03bc {x | s < \u2016g\u2082 x\u2016\u2091} := measure_union_le _ _\n\nlemma approx_above_superset (t\u2080 : \u211d\u22650\u221e) :\n    \u22c3 n, (fun n : \u2115 \u21a6 {x | t\u2080 + (\u2191n)\u207b\u00b9 < \u2016f x\u2016\u2091}) n = {x | t\u2080 < \u2016f x\u2016\u2091} := by\n  ext y\n  constructor <;> intro h\n  \u00b7 obtain \u27e8n, wn\u27e9 := exists_exists_eq_and.mp h\n    calc\n      t\u2080 \u2264 t\u2080 + (\u2191n)\u207b\u00b9 := le_self_add\n      _  < \u2016f y\u2016\u2091      := wn\n  \u00b7 have h\u2081 : Iio (\u2016f y\u2016\u2091 - t\u2080) \u2208 \ud835\udcdd 0 := Iio_mem_nhds (tsub_pos_of_lt h)\n    have h\u2082 := ENNReal.tendsto_inv_nat_nhds_zero h\u2081\n    simp only [mem_map, mem_atTop_sets, mem_preimage, mem_Iio] at h\u2082\n    rcases h\u2082 with \u27e8n, wn\u27e9\n    simp only [mem_iUnion, mem_setOf_eq]\n    use n\n    exact lt_tsub_iff_left.mp (wn n (Nat.le_refl n))\n\nlemma tendsto_measure_iUnion_distribution (t\u2080 : \u211d\u22650\u221e) :\n    Filter.Tendsto (\u21d1\u03bc \u2218 (fun n : \u2115 \u21a6 {x | t\u2080 + (\u2191n)\u207b\u00b9 < \u2016f x\u2016\u2091}))\n      Filter.atTop (nhds (\u03bc ({x | t\u2080 < \u2016f x\u2016\u2091}))) := by\n  rw [\u2190 approx_above_superset]\n  apply tendsto_measure_iUnion_atTop\n  intro a b h x h\u2081\n  calc\n    _ \u2264 t\u2080 + (\u2191a)\u207b\u00b9 := by gcongr\n    _ < _ := h\u2081\n\nlemma select_neighborhood_distribution (t\u2080 : \u211d\u22650\u221e) (l : \u211d\u22650\u221e)\n    (hu : l < distribution f t\u2080 \u03bc) :\n    \u2203 n : \u2115, l < distribution f (t\u2080 + (\u2191n)\u207b\u00b9) \u03bc := by\n  have h\u2081 : Ioi l \u2208 (\ud835\udcdd (distribution f t\u2080 \u03bc)) := Ioi_mem_nhds hu\n  have h\u2082 := (tendsto_measure_iUnion_distribution t\u2080) h\u2081\n  simp only [mem_map, mem_atTop_sets, mem_preimage, comp_apply, mem_Ioi] at h\u2082\n  rcases h\u2082 with \u27e8n, wn\u27e9\n  use n; exact wn n (Nat.le_refl n)\n\nlemma continuousWithinAt_distribution (t\u2080 : \u211d\u22650\u221e) :\n    ContinuousWithinAt (distribution f \u00b7 \u03bc) (Ioi t\u2080) t\u2080 := by\n  rcases (eq_top_or_lt_top t\u2080) with t\u2080top | t\u2080nottop\n  \u00b7 rw [t\u2080top]\n    apply continuousWithinAt_of_not_mem_closure\n    simp\n  \u00b7 unfold ContinuousWithinAt\n    rcases (eq_top_or_lt_top (distribution f t\u2080 \u03bc)) with db_top | db_not_top\n    -- Case: distribution f t\u2080 \u03bc = \u22a4\n    \u00b7 simp only\n      rw [db_top, ENNReal.tendsto_nhds_top_iff_nnreal]\n      intro b\n      have h\u2080 : \u2203 n : \u2115, \u2191b < distribution f (t\u2080 + (\u2191n)\u207b\u00b9) \u03bc :=\n        select_neighborhood_distribution _ _ (db_top \u25b8 coe_lt_top)\n      rcases h\u2080 with \u27e8n, wn\u27e9\n      refine eventually_mem_set.mpr (mem_inf_iff_superset.mpr \u27e8Iio (t\u2080 + (\u2191n)\u207b\u00b9), ?_, ?_\u27e9)\n      \u00b7 exact Iio_mem_nhds (lt_add_right t\u2080nottop.ne_top\n          (ENNReal.inv_ne_zero.mpr (ENNReal.natCast_ne_top n)))\n      \u00b7 exact \u27e8Ioi t\u2080, by simp, fun z h\u2081 \u21a6 wn.trans_le (distribution_mono_right (le_of_lt h\u2081.1))\u27e9\n    -- Case: distribution f t\u2080 \u03bc < \u22a4\n    \u00b7 refine (ENNReal.tendsto_nhds db_not_top.ne_top).mpr fun \u03b5 \u03b5_gt_0 \u21a6\n        eventually_mem_set.mpr (mem_inf_iff_superset.mpr ?_)\n      rcases eq_zero_or_pos (distribution f t\u2080 \u03bc) with db_zero | db_not_zero\n      -- Case: distribution f t\u2080 \u03bc = 0\n      \u00b7 use Ico 0 (t\u2080 + 1)\n        constructor\n        \u00b7 refine IsOpen.mem_nhds isOpen_Ico_zero ?_\n          simp only [mem_Ico, zero_le, lt_add_right t\u2080nottop.ne_top one_ne_zero, and_self]\n        \u00b7 use Ioi t\u2080\n          refine \u27e8by simp, fun z hz \u21a6 ?_\u27e9\n          rw [db_zero]\n          simp only [ge_iff_le, zero_le, tsub_eq_zero_of_le, zero_add]\n          have h\u2082 : distribution f z \u03bc \u2264 distribution f t\u2080 \u03bc :=\n            distribution_mono_right (le_of_lt hz.2)\n          rw [db_zero] at h\u2082\n          change Icc 0 \u03b5 (distribution f z \u03bc)\n          rw [nonpos_iff_eq_zero.mp h\u2082]\n          exact \u27e8zero_le 0, zero_le \u03b5\u27e9\n      -- Case: 0 < distribution f t\u2080 \u03bc\n      \u00b7 obtain \u27e8n, wn\u27e9 :=\n          select_neighborhood_distribution t\u2080 _ (ENNReal.sub_lt_self db_not_top.ne_top\n              (ne_of_lt db_not_zero).symm (ne_of_lt \u03b5_gt_0).symm)\n        use Iio (t\u2080 + (\u2191n)\u207b\u00b9)\n        constructor\n        \u00b7 exact Iio_mem_nhds (lt_add_right t\u2080nottop.ne_top\n            (ENNReal.inv_ne_zero.mpr (ENNReal.natCast_ne_top n)))\n        \u00b7 use Ioi t\u2080\n          refine \u27e8by simp, fun z h \u21a6 \u27e8?_, ?_\u27e9\u27e9\n          \u00b7 calc\n              distribution f t\u2080 \u03bc - \u03b5\n                \u2264 distribution f (t\u2080 + (\u2191n)\u207b\u00b9) \u03bc := le_of_lt wn\n              _ \u2264 distribution f z \u03bc             := distribution_mono_right (le_of_lt h.1)\n          \u00b7 calc\n              distribution f z \u03bc\n                \u2264 distribution f t\u2080 \u03bc := distribution_mono_right (le_of_lt h.2)\n              _ \u2264 distribution f t\u2080 \u03bc + \u03b5 := le_self_add\n\n/- The lemmas below are almost already in Mathlib, see\n`MeasureTheory.lintegral_rpow_eq_lintegral_meas_lt_mul`. -/\n\n-- /-- The layer-cake theorem, or Cavalieri's principle for functions into `\u211d\u22650\u221e` -/\n-- lemma lintegral_norm_pow_eq_measure_lt {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : AEMeasurable f \u03bc)\n--     {p : \u211d} (hp : 1 \u2264 p) :\n--     \u222b\u207b x, (f x) ^ p \u2202\u03bc =\n--     \u222b\u207b t in Ioi (0 : \u211d), .ofReal (p * t ^ (p - 1)) * \u03bc { x | ENNReal.ofReal t < f x } := by\n--   sorry\n\n/-- The weak L^p norm of a function, for `p < \u221e` -/\ndef wnorm' (f : \u03b1 \u2192 \u03b5) (p : \u211d) (\u03bc : Measure \u03b1) : \u211d\u22650\u221e :=\n  \u2a06 t : \u211d\u22650, t * distribution f t \u03bc ^ (p : \u211d)\u207b\u00b9\n\nlemma wnorm'_zero (f : \u03b1 \u2192 \u03b5) (\u03bc : Measure \u03b1) : wnorm' f 0 \u03bc = \u221e := by\n  simp only [wnorm', GroupWithZero.inv_zero, ENNReal.rpow_zero, mul_one, iSup_eq_top]\n  refine fun b hb \u21a6 \u27e8b.toNNReal + 1, ?_\u27e9\n  rw [coe_add, ENNReal.coe_one, coe_toNNReal hb.ne_top]\n  exact lt_add_right hb.ne_top one_ne_zero\n\nlemma wnorm'_toReal_le {f : \u03b1 \u2192 \u211d\u22650\u221e} {p : \u211d} (hp : 0 \u2264 p) :\n    wnorm' (ENNReal.toReal \u2218 f) p \u03bc \u2264 wnorm' f p \u03bc := by\n  refine iSup_mono fun x \u21a6 ?_\n  gcongr\n  exact distribution_toReal_le\n\nlemma wnorm'_toReal_eq {f : \u03b1 \u2192 \u211d\u22650\u221e} {p : \u211d} (hf : \u2200\u1d50 x \u2202\u03bc, f x \u2260 \u221e) :\n    wnorm' (ENNReal.toReal \u2218 f) p \u03bc = wnorm' f p \u03bc := by\n  simp_rw [wnorm', distribution_toReal_eq hf]\n\n/-- The weak L^p norm of a function. -/\ndef wnorm (f : \u03b1 \u2192 \u03b5) (p : \u211d\u22650\u221e) (\u03bc : Measure \u03b1) : \u211d\u22650\u221e :=\n  if p = \u221e then eLpNormEssSup f \u03bc else wnorm' f (ENNReal.toReal p) \u03bc\n\nlemma wnorm_zero : wnorm f 0 \u03bc = \u221e := by\n  simp [wnorm, wnorm'_zero]\n\n@[simp]\nlemma wnorm_top : wnorm f \u22a4 \u03bc = eLpNormEssSup f \u03bc := by simp [wnorm]\n\nlemma wnorm_coe {p : \u211d\u22650} : wnorm f p \u03bc = wnorm' f p \u03bc := by simp [wnorm]\n\nlemma wnorm_ofReal {p : \u211d} (hp : 0 \u2264 p) : wnorm f (.ofReal p) \u03bc = wnorm' f p \u03bc := by\n  simp [wnorm, hp]\n\nlemma wnorm_toReal_le {f : \u03b1 \u2192 \u211d\u22650\u221e} {p : \u211d\u22650\u221e} :\n    wnorm (ENNReal.toReal \u2218 f) p \u03bc \u2264 wnorm f p \u03bc := by\n  induction p\n  \u00b7 simp [eLpNormEssSup_toReal_le]\n  exact wnorm'_toReal_le toReal_nonneg\n\nlemma wnorm_toReal_eq {f : \u03b1 \u2192 \u211d\u22650\u221e} {p : \u211d\u22650\u221e} (hf : \u2200\u1d50 x \u2202\u03bc, f x \u2260 \u221e) :\n    wnorm (ENNReal.toReal \u2218 f) p \u03bc = wnorm f p \u03bc := by\n  simp_rw [wnorm, eLpNormEssSup_toReal_eq hf, wnorm'_toReal_eq hf]\n\nend ENorm\n\nsection ContinuousENorm\n\nvariable [ContinuousENorm \u03b5] [ContinuousENorm \u03b5\u2081] [ContinuousENorm \u03b5\u2082] [ContinuousENorm \u03b5\u2083]\n    {f : \u03b1 \u2192 \u03b5} {f\u2081 : \u03b1 \u2192 \u03b5\u2081}\n\nlemma wnorm'_le_eLpNorm' (hf : AEStronglyMeasurable f \u03bc) {p : \u211d} (hp : 1 \u2264 p) :\n    wnorm' f p \u03bc \u2264 eLpNorm' f p \u03bc := by\n  refine iSup_le (fun t \u21a6 ?_)\n  simp_rw [distribution, eLpNorm']\n  have p0 : 0 < p := lt_of_lt_of_le one_pos hp\n  have p0' : 0 \u2264 1 / p := (div_pos one_pos p0).le\n  have set_eq : {x | ofNNReal t < \u2016f x\u2016\u2091} = {x | ofNNReal t ^ p < \u2016f x\u2016\u2091 ^ p} := by\n    simp [ENNReal.rpow_lt_rpow_iff p0]\n  have : ofNNReal t = (ofNNReal t ^ p) ^ (1 / p) := by simp [p0.ne.symm]\n  nth_rewrite 1 [inv_eq_one_div p, this, \u2190 mul_rpow_of_nonneg _ _ p0', set_eq]\n  refine rpow_le_rpow ?_ p0'\n  refine le_trans ?_ <| mul_meas_ge_le_lintegral\u2080 (hf.enorm'.pow_const p) (ofNNReal t ^ p)\n  gcongr\n  exact setOf_subset_setOf.mpr (fun _ h \u21a6 h.le)\n\nlemma wnorm_le_eLpNorm (hf : AEStronglyMeasurable f \u03bc) {p : \u211d\u22650\u221e} (hp : 1 \u2264 p) :\n    wnorm f p \u03bc \u2264 eLpNorm f p \u03bc := by\n  by_cases h : p = \u22a4\n  \u00b7 simp [h, wnorm, eLpNorm]\n  \u00b7 have p0 : p \u2260 0 := (lt_of_lt_of_le one_pos hp).ne.symm\n    simpa [h, wnorm, eLpNorm, p0] using wnorm'_le_eLpNorm' hf (toReal_mono h hp)\n\n/-- A function is in weak-L^p if it is (strongly a.e.)-measurable and has finite weak L^p norm. -/\ndef MemW\u2112p (f : \u03b1 \u2192 \u03b5) (p : \u211d\u22650\u221e) (\u03bc : Measure \u03b1) : Prop :=\n  AEStronglyMeasurable f \u03bc \u2227 wnorm f p \u03bc < \u221e\n\nlemma Mem\u2112p.memW\u2112p (hp : 1 \u2264 p) (hf : Mem\u2112p f p \u03bc) : MemW\u2112p f p \u03bc :=\n  \u27e8hf.1, wnorm_le_eLpNorm hf.1 hp |>.trans_lt hf.2\u27e9\n\nlemma MemW\u2112p_zero : \u00ac MemW\u2112p f 0 \u03bc := by\n  simp [MemW\u2112p, wnorm_zero]\n\nlemma MemW\u2112p.aeStronglyMeasurable (hf : MemW\u2112p f p \u03bc) : AEStronglyMeasurable f \u03bc :=\n  hf.1\n\nlemma MemW\u2112p.wnorm_lt_top (hf : MemW\u2112p f p \u03bc) : wnorm f p \u03bc < \u22a4 :=\n  hf.2\n\nlemma MemW\u2112p.ennreal_toReal {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : MemW\u2112p f p \u03bc) :\n    MemW\u2112p (ENNReal.toReal \u2218 f) p \u03bc :=\n  \u27e8hf.aeStronglyMeasurable.ennreal_toReal, wnorm_toReal_le.trans_lt hf.2\u27e9\n\n/-- If a function `f` is `MemW\u2112p`, then its norm is almost everywhere finite.-/\ntheorem MemW\u2112p.ae_ne_top {f : \u03b1 \u2192 \u03b5} {p : \u211d\u22650\u221e} {\u03bc : Measure \u03b1}\n    (hf : MemW\u2112p f p \u03bc) : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016\u2091 \u2260 \u221e := by\n  by_cases hp_inf : p = \u221e\n  \u00b7 rw [hp_inf] at hf\n    simp_rw [\u2190 lt_top_iff_ne_top]\n    exact ae_lt_of_essSup_lt hf.2\n  by_cases hp_zero : p = 0\n  \u00b7 exact (MemW\u2112p_zero <| hp_zero \u25b8 hf).elim\n  set A := {x | \u2016f x\u2016\u2091 = \u221e} with hA\n  unfold MemW\u2112p wnorm wnorm' at hf\n  simp only [hp_inf] at hf\n  rw [Filter.eventually_iff, mem_ae_iff]\n  simp only [ne_eq, compl_def, mem_setOf_eq, Decidable.not_not, \u2190 hA]\n  have hp_toReal_zero := toReal_ne_zero.mpr \u27e8hp_zero, hp_inf\u27e9\n  have h1 (t : \u211d\u22650) : \u03bc A \u2264 distribution f t \u03bc := by\n    refine \u03bc.mono ?_\n    simp_all only [setOf_subset_setOf, coe_lt_top, implies_true, A]\n  set C := \u2a06 t : \u211d\u22650, t * distribution f t \u03bc ^ p.toReal\u207b\u00b9\n  by_cases hC_zero : C = 0\n  \u00b7 simp only [ENNReal.iSup_eq_zero, mul_eq_zero, ENNReal.rpow_eq_zero_iff, inv_neg'', C] at hC_zero\n    specialize hC_zero 1\n    simp only [one_ne_zero, ENNReal.coe_one, toReal_nonneg.not_lt, and_false, or_false,\n      false_or] at hC_zero\n    exact measure_mono_null (setOf_subset_setOf.mpr fun x hx => hx \u25b8 one_lt_top) hC_zero.1\n  by_contra h\n  have h2 : C < \u221e := by aesop\n  have h3 (t : \u211d\u22650) : distribution f t \u03bc \u2264 (C / t) ^ p.toReal := by\n    rw [\u2190 rpow_inv_rpow hp_toReal_zero (distribution ..)]\n    refine rpow_le_rpow ?_ toReal_nonneg\n    rw [ENNReal.le_div_iff_mul_le (Or.inr hC_zero) (Or.inl coe_ne_top), mul_comm]\n    exact le_iSup_iff.mpr fun _ a \u21a6 a t\n  have h4 (t : \u211d\u22650) : \u03bc A \u2264 (C / t) ^ p.toReal := (h1 t).trans (h3 t)\n  have h5 : \u03bc A \u2264 \u03bc A / 2 := by\n    convert h4 (C * (2 / \u03bc A) ^ p.toReal\u207b\u00b9).toNNReal\n    rw [coe_toNNReal ?_]\n    swap\n    \u00b7 refine mul_ne_top h2.ne_top (rpow_ne_top_of_nonneg (inv_nonneg.mpr toReal_nonneg) ?_)\n      simp [div_eq_top, h]\n    nth_rw 1 [\u2190 mul_one C]\n    rw [ENNReal.mul_div_mul_left _ _ hC_zero h2.ne_top, div_rpow_of_nonneg _ _ toReal_nonneg,\n      ENNReal.rpow_inv_rpow hp_toReal_zero, ENNReal.one_rpow, one_div,\n        ENNReal.inv_div (Or.inr ofNat_ne_top) (Or.inr (NeZero.ne' 2).symm)]\n  have h6 : \u03bc A = 0 := by\n    convert (fun hh \u21a6 ENNReal.half_lt_self hh (ne_top_of_le_ne_top (rpow_ne_top_of_nonneg\n      toReal_nonneg ((div_one C).symm \u25b8 h2.ne_top)) (h4 1))).mt h5.not_lt\n    tauto\n  exact h h6\n\n/- Todo: define `MeasureTheory.WLp` as a subgroup, similar to `MeasureTheory.Lp` -/\n\n/-- An operator has weak type `(p, q)` if it is bounded as a map from L^p to weak-L^q.\n`HasWeakType T p p' \u03bc \u03bd c` means that `T` has weak type (p, p') w.r.t. measures `\u03bc`, `\u03bd`\nand constant `c`.  -/\ndef HasWeakType (T : (\u03b1 \u2192 \u03b5\u2081) \u2192 (\u03b1' \u2192 \u03b5\u2082)) (p p' : \u211d\u22650\u221e) (\u03bc : Measure \u03b1) (\u03bd : Measure \u03b1')\n    (c : \u211d\u22650) : Prop :=\n  \u2200 f : \u03b1 \u2192 \u03b5\u2081, Mem\u2112p f p \u03bc \u2192 AEStronglyMeasurable (T f) \u03bd \u2227 wnorm (T f) p' \u03bd \u2264 c * eLpNorm f p \u03bc\n\n/-- A weaker version of `HasWeakType`. -/\ndef HasBoundedWeakType {\u03b1 \u03b1' : Type*} [Zero \u03b5\u2081]\n    {_x : MeasurableSpace \u03b1} {_x' : MeasurableSpace \u03b1'} (T : (\u03b1 \u2192 \u03b5\u2081) \u2192 (\u03b1' \u2192 \u03b5\u2082))\n    (p p' : \u211d\u22650\u221e) (\u03bc : Measure \u03b1) (\u03bd : Measure \u03b1') (c : \u211d\u22650) : Prop :=\n  \u2200 f : \u03b1 \u2192 \u03b5\u2081, Mem\u2112p f p \u03bc \u2192 eLpNorm f \u221e \u03bc < \u221e \u2192 \u03bc (support f) < \u221e \u2192\n  AEStronglyMeasurable (T f) \u03bd \u2227 wnorm (T f) p' \u03bd \u2264 c * eLpNorm f p \u03bc\n\n/-- An operator has strong type (p, q) if it is bounded as an operator on `L^p \u2192 L^q`.\n`HasStrongType T p p' \u03bc \u03bd c` means that `T` has strong type (p, p') w.r.t. measures `\u03bc`, `\u03bd`\nand constant `c`.  -/\ndef HasStrongType {\u03b1 \u03b1' : Type*}\n    {_x : MeasurableSpace \u03b1} {_x' : MeasurableSpace \u03b1'} (T : (\u03b1 \u2192 \u03b5\u2081) \u2192 (\u03b1' \u2192 \u03b5\u2082))\n    (p p' : \u211d\u22650\u221e) (\u03bc : Measure \u03b1) (\u03bd : Measure \u03b1') (c : \u211d\u22650) : Prop :=\n  \u2200 f : \u03b1 \u2192 \u03b5\u2081, Mem\u2112p f p \u03bc \u2192 AEStronglyMeasurable (T f) \u03bd \u2227 eLpNorm (T f) p' \u03bd \u2264 c * eLpNorm f p \u03bc\n\n/-- A weaker version of `HasStrongType`. This is the same as `HasStrongType` if `T` is continuous\nw.r.t. the L^2 norm, but weaker in general. -/\ndef HasBoundedStrongType {\u03b1 \u03b1' : Type*} [Zero \u03b5\u2081]\n    {_x : MeasurableSpace \u03b1} {_x' : MeasurableSpace \u03b1'} (T : (\u03b1 \u2192 \u03b5\u2081) \u2192 (\u03b1' \u2192 \u03b5\u2082))\n    (p p' : \u211d\u22650\u221e) (\u03bc : Measure \u03b1) (\u03bd : Measure \u03b1') (c : \u211d\u22650) : Prop :=\n  \u2200 f : \u03b1 \u2192 \u03b5\u2081, Mem\u2112p f p \u03bc \u2192 eLpNorm f \u221e \u03bc < \u221e \u2192 \u03bc (support f) < \u221e \u2192\n  AEStronglyMeasurable (T f) \u03bd \u2227 eLpNorm (T f) p' \u03bd \u2264 c * eLpNorm f p \u03bc\n\n\n/-! ### Lemmas about `HasWeakType` -/\n\nlemma HasWeakType.memW\u2112p (h : HasWeakType T p p' \u03bc \u03bd c) (hf\u2081 : Mem\u2112p f\u2081 p \u03bc) :\n    MemW\u2112p (T f\u2081) p' \u03bd :=\n  \u27e8(h f\u2081 hf\u2081).1, h f\u2081 hf\u2081 |>.2.trans_lt <| mul_lt_top coe_lt_top hf\u2081.2\u27e9\n\n", "theoremStatement": "lemma HasWeakType.toReal {T : (\u03b1 \u2192 \u03b5\u2081) \u2192 (\u03b1' \u2192 \u211d\u22650\u221e)} (h : HasWeakType T p p' \u03bc \u03bd c) :\n    HasWeakType (T \u00b7 \u00b7 |>.toReal) p p' \u03bc \u03bd c ", "theoremName": "MeasureTheory.HasWeakType.toReal", "fileCreated": {"commit": "1a36cbeaee9466fb56c9aca49ef373f9f9cc7ab7", "date": "2025-01-23"}, "theoremCreated": {"commit": "451f4568375c1be265a0beb82adb601f9a3ee74d", "date": "2025-01-20"}, "file": "carleson/Carleson/ToMathlib/WeakType.lean", "module": "Carleson.ToMathlib.WeakType", "jsonFile": "Carleson.ToMathlib.WeakType.jsonl", "positionMetadata": {"lineInFile": 442, "tokenPositionInFile": 17863, "theoremPositionInFile": 46}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 12, "numPremises": 51}, "proofMetadata": {"hasProof": true, "proof": ":=\n  fun f hf \u21a6 \u27e8(h f hf).1.ennreal_toReal, wnorm_toReal_le.trans (h f hf).2 \u27e9", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 78}}
