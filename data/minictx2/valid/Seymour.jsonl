{"srcContext": "import Seymour.Basic\nimport Seymour.Matroid.Constructors.VectorMatroid\nimport Seymour.Matroid.Classes.Representable\n\n\nvariable {\u03b1 : Type}\n\nsection Definitions\n\n/-- Binary matroid is vector matroid of matrix over `Z2`. -/\nabbrev BinaryMatroid (\u03b1 : Type) := VectorMatroid \u03b1 Z2\n\n/-- Matroid `M` is binary if it is representable over `Z2` -/\ndef Matroid.IsBinary [DecidableEq \u03b1] (M : Matroid \u03b1) : Prop :=\n  M.IsRepresentableOver Z2\n\n/-- `Matroid` is binary iff it can be constructed from a `BinaryMatroid`. -/\nlemma Matroid.isBinary_iff [DecidableEq \u03b1] (M : Matroid \u03b1) : M.IsBinary \u2194 \u2203 B : BinaryMatroid \u03b1, B.toMatroid = M := by\n  rfl\n\n", "theoremStatement": "/-- Every `BinaryMatroid` is binary. -/\nlemma BinaryMatroid.isBinary [DecidableEq \u03b1] (M : BinaryMatroid \u03b1) : M.toMatroid.IsBinary ", "theoremName": "BinaryMatroid.isBinary", "fileCreated": {"commit": "d0eaaa305c96cd81ac061f505a81614db6856b21", "date": "2025-01-09"}, "theoremCreated": {"commit": "0fb287b12bb6587271dd81f6c6af767716cf889a", "date": "2025-01-09"}, "file": "Seymour/Seymour/Matroid/Classes/Binary.lean", "module": "Seymour.Matroid.Classes.Binary", "jsonFile": "Seymour.Matroid.Classes.Binary.jsonl", "positionMetadata": {"lineInFile": 21, "tokenPositionInFile": 632, "theoremPositionInFile": 3}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 5, "numPremises": 21}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  use M", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 13}}
{"srcContext": "import Seymour.Matroid.Operations.SumDelta.Basic\nimport Seymour.ForMathlib.SetTheory\n\nset_option linter.unusedVariables false\n\nvariable {\u03b1 : Type} [DecidableEq \u03b1]\n\n\nsection Basic\n\n/-- Nonempty union of disjoint circuits of `M\u2081` satisfies circuit form of `M\u2081 \u0394 M\u2082`  -/\nlemma deltaSumCircuitForm_left {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : C.Nonempty) (hCE : C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)) (hCM\u2081 : M\u2081.toMatroid.IsUnionDisjointCircuits C) :\n    DeltaSumCircuitForm M\u2081 M\u2082 C :=\n  \u27e8hC, hCE, C, \u2205, by simp, hCM\u2081, M\u2082.toMatroid.emptyUnionDisjointCircuits\u27e9\n\n/-- Nonempty union of disjoint circuits of `M\u2082` satisfies circuit form of `M\u2081 \u0394 M\u2082`  -/\nlemma deltaSumCircuitForm_right {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : C.Nonempty) (hCE : C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)) (hCM\u2082 : M\u2082.toMatroid.IsUnionDisjointCircuits C) :\n    DeltaSumCircuitForm M\u2081 M\u2082 C :=\n  \u27e8hC, hCE, \u2205, C, by simp, M\u2081.toMatroid.emptyUnionDisjointCircuits, hCM\u2082\u27e9\n\nend Basic\n\n\nsection CircuitForm1\n\n/-- Form 1 of circuits in `M\u2081 \u0394 M\u2082`: circuits of `M\u2081` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef DeltaSumCircuitForm1 (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.toMatroid.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Circuit of form 1 is a circuit in `M\u2081` -/\nlemma DeltaSumCircuitForm1.circuit_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    M\u2081.toMatroid.Circuit C :=\n  hC.left\n\n/-- Circuit of form 1 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm1.disjoint_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of form 1 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma DeltaSumCircuitForm1.subset_union {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_left hC.circuit_M\u2081.subset_ground M\u2082.E\n\n/-- Circuit of form 1 lies in ground set of `M\u2081 \u0394 M\u2082` -/\nlemma DeltaSumCircuitForm1.subset_ground {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of form 1 lies in `M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma DeltaSumCircuitForm1.subset_M\u2081_diff_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2286 M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2081.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of form 1 is disjoint with `M\u2082.E` -/\nlemma DeltaSumCircuitForm1.disjoint_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2ad7 M\u2082.E := by\n  have hMM := diff_inter_disjoint_diff_inter M\u2081.E M\u2082.E\n  have hCM\u2082 := Set.disjoint_of_subset_left hC.subset_M\u2081_diff_inter hMM\n  have hCM\u2082 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2082, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_right] at hCM\u2082\n  exact hCM\u2082\n\n/-- Circuit of form 1 satisfies circuit form of `M\u2081 \u0394 M\u2082` -/\nlemma DeltaSumCircuitForm1.circuit_form {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    DeltaSumCircuitForm M\u2081 M\u2082 C :=\n  deltaSumCircuitForm_left hC.circuit_M\u2081.nonempty hC.subset_ground hC.circuit_M\u2081.isUnionDisjointCircuits\n\n/-- If `C` satisfies circuit predicate and is a union of disjoint circuits of `M\u2081`, then `C` is a circuit of `M\u2081` -/\nlemma DeltaSumCircuitPred.udc_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (C_pred : DeltaSumCircuitPred M\u2081 M\u2082 C) (C_udc : M\u2081.toMatroid.IsUnionDisjointCircuits C) :\n    M\u2081.toMatroid.Circuit C :=\n  have \u27e8\u27e8hC, hCE, _\u27e9, hCmin\u27e9 := C_pred\n  \u27e8C_udc.nonempty_dep hC, fun D hD hDC =>\n    have \u27e8_, D', hD', hDD'\u27e9 := M\u2081.toMatroid.dep_iff_has_circuit.\u2192 hD\n    (hCmin\n        (DeltaSumCircuitForm1.circuit_form \u27e8hD', (Set.subset_diff.\u2192 ((hDD'.trans hDC).trans hCE)).right\u27e9)\n        (hDD'.trans hDC)\n      ).trans hDD'\u27e9\n\nend CircuitForm1\n\n\nsection CircuitForm2\n\n/-- Form 2 of circuits in `M\u2081 \u0394 M\u2082`: circuits of `M\u2082` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef DeltaSumCircuitForm2 (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2082.toMatroid.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Circuit of form 2 is a circuit in `M\u2081` -/\nlemma DeltaSumCircuitForm2.circuit_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    M\u2082.toMatroid.Circuit C :=\n  hC.left\n\n/-- Circuit of form 2 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm2.disjoint_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of form 2 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma DeltaSumCircuitForm2.subset_union {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_right hC.circuit_M\u2082.subset_ground M\u2081.E\n\n/-- Circuit of form 2 lies in ground set of `M\u2081 \u0394 M\u2082` -/\nlemma DeltaSumCircuitForm2.subset_ground {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of form 2 lies in `M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma DeltaSumCircuitForm2.subset_M\u2082_diff_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2286 M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2082.subset_ground, hC.disjoint_inter\u27e9\n\n", "theoremStatement": "/-- Circuit of form 2 is disjoint with `M\u2082.E` -/\nlemma DeltaSumCircuitForm2.disjoint_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2ad7 M\u2081.E ", "theoremName": "DeltaSumCircuitForm2.disjoint_M\u2081", "fileCreated": {"commit": "aae07a69b2ec95e3d9a1436952a123dcb7d0d06f", "date": "2025-01-03"}, "theoremCreated": {"commit": "67629d2b74be7b972786897531b678f585a7af28", "date": "2025-02-03"}, "file": "Seymour/Seymour/Matroid/Operations/SumDelta/CircuitForms.lean", "module": "Seymour.Matroid.Operations.SumDelta.CircuitForms", "jsonFile": "Seymour.Matroid.Operations.SumDelta.CircuitForms.jsonl", "positionMetadata": {"lineInFile": 129, "tokenPositionInFile": 5324, "theoremPositionInFile": 17}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 7, "numPremises": 44}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  have hMM := diff_inter_disjoint_diff_inter M\u2081.E M\u2082.E\n  have hCM\u2082 := Set.disjoint_of_subset_right hC.subset_M\u2082_diff_inter hMM\n  have hCM\u2082 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2082.symm, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_left] at hCM\u2082\n  exact hCM\u2082", "proofType": "tactic", "proofLengthLines": 5, "proofLengthTokens": 280}}
{"srcContext": "import Mathlib.Data.Set.SymmDiff\nimport Mathlib.Order.CompletePartialOrder\nimport Mathlib.Order.Disjoint\nimport Mathlib.Order.SymmDiff\nimport Mathlib.Tactic\n\nimport Seymour.Basic\n\n/-!\nThis provides lemmas about sets (mostly dealing with disjointness) that are missing in Mathlib.\n-/\n\nvariable {\u03b1 : Type}\n\nsection Other\n\nlemma set_union_union_eq_rev (X Y Z : Set \u03b1) : X \u222a Y \u222a Z = Z \u222a Y \u222a X := by\n  rw [Set.union_assoc, Set.union_comm, Set.union_comm Y Z]\n\nlemma setminus_inter_union_eq_union {X Y : Set \u03b1} : X \\ (X \u2229 Y) \u222a Y = X \u222a Y := by\n  tauto_set\n\nlemma nonempty_inter_not_ssubset_empty_inter {A B E : Set \u03b1} (hA : (A \u2229 E).Nonempty) (hB : B \u2229 E = \u2205) :\n    \u00ac(A \u2282 B) := by\n  intro \u27e8hAB, _\u27e9\n  obtain \u27e8x, hxAE\u27e9 := hA\n  have hxBE : x \u2208 B \u2229 E := (Set.inter_subset_inter hAB fun _ => id) hxAE\n  rw [hB] at hxBE\n  tauto\n\nlemma ssubset_self_union_other_elem {a : \u03b1} {X : Set \u03b1} (ha : a \u2209 X) :\n    X \u2282 X \u222a {a} := by\n  constructor\n  \u00b7 exact Set.subset_union_left\n  \u00b7 by_contra hX\n    rw [Set.union_subset_iff] at hX\n    obtain \u27e8_, haa\u27e9 := hX\n    tauto\n\nlemma singleton_union_ssubset_union_iff {a : \u03b1} {A B : Set \u03b1} (haA : a \u2209 A) (haB : a \u2209 B) :\n    A \u222a {a} \u2282 B \u222a {a} \u2194 A \u2282 B := by\n  constructor\n  \u00b7 intro hAB\n    obtain \u27e8hABl, hABr\u27e9 := hAB\n    constructor\n    \u00b7 intro x hx\n      apply ne_of_mem_of_not_mem hx at haA\n      cases hABl (Set.mem_union_left {a} hx) <;> tauto\n    \u00b7 by_contra hBA\n      apply Set.union_subset_union_left {a} at hBA\n      tauto\n  \u00b7 intro hAB\n    obtain \u27e8hABl, hABr\u27e9 := hAB\n    constructor\n    \u00b7 exact Set.union_subset_union_left {a} hABl\n    \u00b7 by_contra hBA\n      rw [Set.union_singleton, Set.union_singleton] at hBA\n      apply (Set.insert_subset_insert_iff haB).\u2192 at hBA\n      tauto\n\nlemma ssub_parts_ssub {A B E\u2081 E\u2082 : Set \u03b1}\n    (hA : A \u2286 E\u2081 \u222a E\u2082) (hB : B \u2286 E\u2081 \u222a E\u2082) (hAB\u2081 : A \u2229 E\u2081 \u2282 B \u2229 E\u2081) (hAB\u2082 : A \u2229 E\u2082 \u2282 B \u2229 E\u2082) :\n    A \u2282 B := by\n  constructor\n  \u00b7 obtain \u27e8hE\u2081, _\u27e9 := hAB\u2081\n    obtain \u27e8hE\u2082, _\u27e9 := hAB\u2082\n    rw [Set.left_eq_inter.\u2190 hA, Set.left_eq_inter.\u2190 hB, Set.inter_union_distrib_left, Set.inter_union_distrib_left]\n    exact Set.union_subset_union hE\u2081 hE\u2082\n  \u00b7 intro hBA\n    obtain \u27e8_, hE\u2081\u27e9 := hAB\u2081\n    obtain \u27e8x, hxBE\u2081, hxnAE\u2081\u27e9 := Set.not_subset.\u2192 hE\u2081\n    have hxB : x \u2208 B := Set.mem_of_mem_inter_left hxBE\u2081\n    have hxE\u2081 : x \u2208 E\u2081 := Set.mem_of_mem_inter_right hxBE\u2081\n    tauto\n\nlemma HasSubset.Subset.parts_eq {A E\u2081 E\u2082 : Set \u03b1} (hA : A \u2286 E\u2081 \u222a E\u2082) : (A \u2229 E\u2081) \u222a (A \u2229 E\u2082) = A :=\n  ((subset_of_subset_of_eq\n    (Set.subset_inter (fun _ => id) hA)\n    (Set.inter_union_distrib_left A E\u2081 E\u2082)).antisymm\n  (Set.union_subset Set.inter_subset_left Set.inter_subset_left)).symm\n\nlemma elem_notin_set_minus_singleton (a : \u03b1) (X : Set \u03b1) : a \u2209 X \\ {a} := Set.not_mem_diff_of_mem rfl\n\nlemma sub_union_diff_sub_union {A B C : Set \u03b1} (hA : A \u2286 B \\ C) : A \u2286 B :=\n  fun _ hA' => Set.diff_subset (hA hA')\n\nlemma singleton_inter_in_left {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : a \u2208 X :=\n  Set.mem_of_mem_inter_left (ha.symm.subset rfl)\n\nlemma singleton_inter_in_right {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : a \u2208 Y :=\n  Set.mem_of_mem_inter_right (ha.symm.subset rfl)\n\nlemma singleton_inter_subset_left {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : {a} \u2286 X := by\n  rw [Set.singleton_subset_iff]\n  exact singleton_inter_in_left ha\n\nlemma singleton_inter_subset_right {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : {a} \u2286 Y := by\n  rw [Set.singleton_subset_iff]\n  exact singleton_inter_in_right ha\n\n/-- Being a subset is preserved under subtracting sets. -/\nlemma diff_subset_parent {X\u2081 X\u2082 E : Set \u03b1} (hX\u2081E : X\u2081 \u2286 E) :\n    X\u2081 \\ X\u2082 \u2286 E :=\n  Set.diff_subset_iff.\u2190 (Set.subset_union_of_subset_right hX\u2081E X\u2082)\n\n/-- Being a subset is preserved under taking intersections. -/\nlemma inter_subset_parent_left {X\u2081 X\u2082 E : Set \u03b1} (hX\u2081E : X\u2081 \u2286 E) :\n    X\u2081 \u2229 X\u2082 \u2286 E :=\n  (Set.inter_subset_inter_left X\u2082 hX\u2081E).trans Set.inter_subset_left\n\n/-- Being a subset is preserved under taking intersections. -/\nlemma inter_subset_parent_right {X\u2081 X\u2082 E : Set \u03b1} (hX\u2082E : X\u2082 \u2286 E) :\n    X\u2081 \u2229 X\u2082 \u2286 E := by\n  rw [Set.inter_comm]\n  exact inter_subset_parent_left hX\u2082E\n\n/-- Intersection of two sets is subset of their union. -/\nlemma inter_subset_union {X\u2081 X\u2082 : Set \u03b1} :\n    X\u2081 \u2229 X\u2082 \u2286 X\u2081 \u222a X\u2082 :=\n  inter_subset_parent_left Set.subset_union_left\n\nlemma subset_diff_empty_eq {A B : Set \u03b1} (hAB : A \u2286 B) (hBA : B \\ A = \u2205) : A = B :=\n  A.union_empty \u25b8 hBA \u25b8 Set.union_diff_cancel hAB\n\nend Other\n\n\nsection Disjoint\n\nlemma Disjoint.ni_of_in {X Y : Set \u03b1} {a : \u03b1} (hXY : X \u2ad7 Y) (ha : a \u2208 X) :\n    a \u2209 Y := by\n  intro ha'\n  simpa [hXY.inter_eq] using Set.mem_inter ha ha'\n\nlemma disjoint_of_singleton_inter_left_wo {X Y : Set \u03b1} {a : \u03b1} (hXY : X \u2229 Y = {a}) :\n    X \\ {a} \u2ad7 Y := by\n  tauto_set\n\nlemma disjoint_of_singleton_inter_right_wo {X Y : Set \u03b1} {a : \u03b1} (hXY : X \u2229 Y = {a}) :\n    X \u2ad7 Y \\ {a} := by\n  rw [disjoint_comm]\n  rw [Set.inter_comm] at hXY\n  exact disjoint_of_singleton_inter_left_wo hXY\n\n", "theoremStatement": "lemma disjoint_of_singleton_inter_both_wo {X Y : Set \u03b1} {a : \u03b1} (hXY : X \u2229 Y = {a}) :\n    X \\ {a} \u2ad7 Y \\ {a} ", "theoremName": "disjoint_of_singleton_inter_both_wo", "fileCreated": {"commit": "b44bff2f1ee71349fa9fa251579a0f5a0e575538", "date": "2024-12-19"}, "theoremCreated": {"commit": "f9d717ecfb54b3a7b794411b4c1af1f5c8ffb7c3", "date": "2024-12-26"}, "file": "Seymour/Seymour/ForMathlib/SetTheory.lean", "module": "Seymour.ForMathlib.SetTheory", "jsonFile": "Seymour.ForMathlib.SetTheory.jsonl", "positionMetadata": {"lineInFile": 145, "tokenPositionInFile": 4862, "theoremPositionInFile": 21}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 1, "numPremises": 23}, "proofMetadata": {"hasProof": true, "proof": ":=\n  Disjoint.disjoint_sdiff_left (disjoint_of_singleton_inter_right_wo hXY)", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 76}}
{"srcContext": "import Mathlib.Data.Set.Card\nimport Mathlib.Data.Matroid.Dual\n\nimport Seymour.ForMathlib.SetTheory\nimport Seymour.Matroid.Notions.Circuit\nimport Seymour.Matroid.Notions.CircuitAxioms\nimport Seymour.Matroid.Notions.Connectivity\nimport Seymour.Matroid.Constructors.CircuitMatroid\n\n/-!\nThis file defines 2-sum of two (general) matroids `M\u2081` and `M\u2082`, denoted as `M\u2081 \u2295\u2082 M\u2082`.\n-/\n\nvariable {\u03b1 : Type}\n\n\nsection MainDefinitions\n\n/-- `M\u2081 \u2295\u2082 M\u2082` is defined if `M\u2081` and `M\u2082` satisfy the following assumptions -/\nstructure TwoSumAssumptions (M\u2081 M\u2082 : Matroid \u03b1) : Prop where\n  /-- `M\u2081` is finite -/\n  M\u2081fin : M\u2081.Finite\n  /-- `M\u2082` is finite -/\n  M\u2082fin : M\u2082.Finite\n  /-- `M\u2081` contains at least 2 elements -/\n  M\u2081card : M\u2081.E.encard \u2265 2\n  /-- `M\u2082` contains at least 2 elements -/\n  M\u2082card : M\u2082.E.encard \u2265 2\n  /-- `M\u2081` and `M\u2082` have exactly one element in common -/\n  interSingleton : (M\u2081.E \u2229 M\u2082.E).encard = 1\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2081` -/\n  M\u2081sep : \u00acM\u2081.Separator (M\u2081.E \u2229 M\u2082.E)\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2082` -/\n  M\u2082sep : \u00acM\u2082.Separator (M\u2081.E \u2229 M\u2082.E)\n\n-- question: can avoid this assumption? -- which assumption? the finiteness?\n\n/-- Ground set of `M\u2081 \u2295\u2082 M\u2082` -/\ndef twoSumGround (M\u2081 M\u2082 : Matroid \u03b1) : Set \u03b1 :=\n  (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)\n\n/-- Type 1 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2081` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType1 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 2 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2082` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType2 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2082.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 3 of circuits in `M\u2081 \u2295\u2082 M\u2082`:\n    sets `(C\u2081 \u222a C\u2082) \\ (M\u2081.E \u2229 M\u2082.E)` where `C\u2081` and `C\u2082` are circuits in `M\u2081` and `M\u2082`, respectively,\n    and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2081` and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2082` -/\ndef TwoSumCircuitType3 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit ((C \u2229 M\u2081.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 M\u2082.Circuit ((C \u2229 M\u2082.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 C \u2286 twoSumGround M\u2081 M\u2082\n\n/-- Circuit predicate of `M\u2081 \u2295\u2082 M\u2082`, which defines 2-sum as `CircuitMatroid` -/\ndef TwoSumCircuitPred (M\u2081 M\u2082 : Matroid \u03b1) : CircuitPredicate \u03b1 :=\n  fun C : Set \u03b1 =>\n    TwoSumCircuitType1 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType2 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType3 M\u2081 M\u2082 C\n\nend MainDefinitions\n\n\nsection PropertiesAssumptions\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1}\n\n/-- 2-sum assumptions are symmetric -/\nlemma TwoSumAssumptions.symm (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    TwoSumAssumptions M\u2082 M\u2081 :=\n  \u27e8\n    assumptions.M\u2082fin,\n    assumptions.M\u2081fin,\n    assumptions.M\u2082card,\n    assumptions.M\u2081card,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.interSingleton,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2082sep,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2081sep,\n  \u27e9\n\n", "theoremStatement": "/-- Intersection of ground sets is nonempty -/\nlemma TwoSumAssumptions.inter_nonempty (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (M\u2081.E \u2229 M\u2082.E).Nonempty ", "theoremName": "TwoSumAssumptions.inter_nonempty", "fileCreated": {"commit": "d0eaaa305c96cd81ac061f505a81614db6856b21", "date": "2025-01-09"}, "theoremCreated": {"commit": "439c72996f29168161b974bc602629cac773728f", "date": "2025-01-08"}, "file": "Seymour/Seymour/Matroid/Operations/Sum2/Basic.lean", "module": "Seymour.Matroid.Operations.Sum2.Basic", "jsonFile": "Seymour.Matroid.Operations.Sum2.Basic.jsonl", "positionMetadata": {"lineInFile": 83, "tokenPositionInFile": 2810, "theoremPositionInFile": 6}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 33}, "proofMetadata": {"hasProof": true, "proof": ":=\n  Set.one_le_encard_iff_nonempty.\u2192 assumptions.interSingleton.symm.le", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 72}}
{"srcContext": "import Seymour.Matroid.Operations.SumDelta.Basic\nimport Seymour.ForMathlib.SetTheory\n\nset_option linter.unusedVariables false\n\nvariable {\u03b1 : Type} [DecidableEq \u03b1]\n\n\nsection Basic\n\n/-- Nonempty union of disjoint circuits of `M\u2081` satisfies circuit form of `M\u2081 \u0394 M\u2082`  -/\nlemma deltaSumCircuitForm_left {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : C.Nonempty) (hCE : C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)) (hCM\u2081 : M\u2081.toMatroid.IsUnionDisjointCircuits C) :\n    DeltaSumCircuitForm M\u2081 M\u2082 C :=\n  \u27e8hC, hCE, C, \u2205, by simp, hCM\u2081, M\u2082.toMatroid.emptyUnionDisjointCircuits\u27e9\n\n/-- Nonempty union of disjoint circuits of `M\u2082` satisfies circuit form of `M\u2081 \u0394 M\u2082`  -/\nlemma deltaSumCircuitForm_right {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : C.Nonempty) (hCE : C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)) (hCM\u2082 : M\u2082.toMatroid.IsUnionDisjointCircuits C) :\n    DeltaSumCircuitForm M\u2081 M\u2082 C :=\n  \u27e8hC, hCE, \u2205, C, by simp, M\u2081.toMatroid.emptyUnionDisjointCircuits, hCM\u2082\u27e9\n\nend Basic\n\n\nsection CircuitForm1\n\n/-- Form 1 of circuits in `M\u2081 \u0394 M\u2082`: circuits of `M\u2081` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef DeltaSumCircuitForm1 (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.toMatroid.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Circuit of form 1 is a circuit in `M\u2081` -/\nlemma DeltaSumCircuitForm1.circuit_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    M\u2081.toMatroid.Circuit C :=\n  hC.left\n\n", "theoremStatement": "/-- Circuit of form 1 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm1.disjoint_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2ad7 M\u2081.E \u2229 M\u2082.E ", "theoremName": "DeltaSumCircuitForm1.disjoint_inter", "fileCreated": {"commit": "aae07a69b2ec95e3d9a1436952a123dcb7d0d06f", "date": "2025-01-03"}, "theoremCreated": {"commit": "67629d2b74be7b972786897531b678f585a7af28", "date": "2025-02-03"}, "file": "Seymour/Seymour/Matroid/Operations/SumDelta/CircuitForms.lean", "module": "Seymour.Matroid.Operations.SumDelta.CircuitForms", "jsonFile": "Seymour.Matroid.Operations.SumDelta.CircuitForms.jsonl", "positionMetadata": {"lineInFile": 38, "tokenPositionInFile": 1393, "theoremPositionInFile": 4}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 6, "numPremises": 29}, "proofMetadata": {"hasProof": true, "proof": ":=\n  hC.right", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 13}}
{"srcContext": "import Seymour.Matroid.Operations.SumDelta.Basic\nimport Seymour.ForMathlib.SetTheory\n\nset_option linter.unusedVariables false\n\nvariable {\u03b1 : Type} [DecidableEq \u03b1]\n\n\nsection Basic\n\n/-- Nonempty union of disjoint circuits of `M\u2081` satisfies circuit form of `M\u2081 \u0394 M\u2082`  -/\nlemma deltaSumCircuitForm_left {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : C.Nonempty) (hCE : C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)) (hCM\u2081 : M\u2081.toMatroid.IsUnionDisjointCircuits C) :\n    DeltaSumCircuitForm M\u2081 M\u2082 C :=\n  \u27e8hC, hCE, C, \u2205, by simp, hCM\u2081, M\u2082.toMatroid.emptyUnionDisjointCircuits\u27e9\n\n/-- Nonempty union of disjoint circuits of `M\u2082` satisfies circuit form of `M\u2081 \u0394 M\u2082`  -/\nlemma deltaSumCircuitForm_right {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : C.Nonempty) (hCE : C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)) (hCM\u2082 : M\u2082.toMatroid.IsUnionDisjointCircuits C) :\n    DeltaSumCircuitForm M\u2081 M\u2082 C :=\n  \u27e8hC, hCE, \u2205, C, by simp, M\u2081.toMatroid.emptyUnionDisjointCircuits, hCM\u2082\u27e9\n\nend Basic\n\n\nsection CircuitForm1\n\n/-- Form 1 of circuits in `M\u2081 \u0394 M\u2082`: circuits of `M\u2081` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef DeltaSumCircuitForm1 (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.toMatroid.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Circuit of form 1 is a circuit in `M\u2081` -/\nlemma DeltaSumCircuitForm1.circuit_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    M\u2081.toMatroid.Circuit C :=\n  hC.left\n\n/-- Circuit of form 1 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm1.disjoint_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of form 1 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma DeltaSumCircuitForm1.subset_union {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_left hC.circuit_M\u2081.subset_ground M\u2082.E\n\n/-- Circuit of form 1 lies in ground set of `M\u2081 \u0394 M\u2082` -/\nlemma DeltaSumCircuitForm1.subset_ground {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of form 1 lies in `M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma DeltaSumCircuitForm1.subset_M\u2081_diff_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2286 M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2081.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of form 1 is disjoint with `M\u2082.E` -/\nlemma DeltaSumCircuitForm1.disjoint_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2ad7 M\u2082.E := by\n  have hMM := diff_inter_disjoint_diff_inter M\u2081.E M\u2082.E\n  have hCM\u2082 := Set.disjoint_of_subset_left hC.subset_M\u2081_diff_inter hMM\n  have hCM\u2082 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2082, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_right] at hCM\u2082\n  exact hCM\u2082\n\n/-- Circuit of form 1 satisfies circuit form of `M\u2081 \u0394 M\u2082` -/\nlemma DeltaSumCircuitForm1.circuit_form {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    DeltaSumCircuitForm M\u2081 M\u2082 C :=\n  deltaSumCircuitForm_left hC.circuit_M\u2081.nonempty hC.subset_ground hC.circuit_M\u2081.isUnionDisjointCircuits\n\n/-- If `C` satisfies circuit predicate and is a union of disjoint circuits of `M\u2081`, then `C` is a circuit of `M\u2081` -/\nlemma DeltaSumCircuitPred.udc_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (C_pred : DeltaSumCircuitPred M\u2081 M\u2082 C) (C_udc : M\u2081.toMatroid.IsUnionDisjointCircuits C) :\n    M\u2081.toMatroid.Circuit C :=\n  have \u27e8\u27e8hC, hCE, _\u27e9, hCmin\u27e9 := C_pred\n  \u27e8C_udc.nonempty_dep hC, fun D hD hDC =>\n    have \u27e8_, D', hD', hDD'\u27e9 := M\u2081.toMatroid.dep_iff_has_circuit.\u2192 hD\n    (hCmin\n        (DeltaSumCircuitForm1.circuit_form \u27e8hD', (Set.subset_diff.\u2192 ((hDD'.trans hDC).trans hCE)).right\u27e9)\n        (hDD'.trans hDC)\n      ).trans hDD'\u27e9\n\nend CircuitForm1\n\n\nsection CircuitForm2\n\n/-- Form 2 of circuits in `M\u2081 \u0394 M\u2082`: circuits of `M\u2082` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef DeltaSumCircuitForm2 (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2082.toMatroid.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Circuit of form 2 is a circuit in `M\u2081` -/\nlemma DeltaSumCircuitForm2.circuit_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    M\u2082.toMatroid.Circuit C :=\n  hC.left\n\n/-- Circuit of form 2 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm2.disjoint_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of form 2 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma DeltaSumCircuitForm2.subset_union {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_right hC.circuit_M\u2082.subset_ground M\u2081.E\n\n/-- Circuit of form 2 lies in ground set of `M\u2081 \u0394 M\u2082` -/\nlemma DeltaSumCircuitForm2.subset_ground {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of form 2 lies in `M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma DeltaSumCircuitForm2.subset_M\u2082_diff_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2286 M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2082.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of form 2 is disjoint with `M\u2082.E` -/\nlemma DeltaSumCircuitForm2.disjoint_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2ad7 M\u2081.E := by\n  have hMM := diff_inter_disjoint_diff_inter M\u2081.E M\u2082.E\n  have hCM\u2082 := Set.disjoint_of_subset_right hC.subset_M\u2082_diff_inter hMM\n  have hCM\u2082 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2082.symm, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_left] at hCM\u2082\n  exact hCM\u2082\n\n/-- Circuit of form 2 satisfies circuit form of `M\u2081 \u0394 M\u2082` -/\nlemma DeltaSumCircuitForm2.circuit_form {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    DeltaSumCircuitForm M\u2081 M\u2082 C :=\n  deltaSumCircuitForm_right hC.circuit_M\u2082.nonempty hC.subset_ground hC.circuit_M\u2082.isUnionDisjointCircuits\n\n/-- If `C` satisfies circuit predicate and is a union of disjoint circuits of `M\u2082`, then `C` is a circuit of `M\u2082` -/\nlemma DeltaSumCircuitPred.udc_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hCpred : DeltaSumCircuitPred M\u2081 M\u2082 C) (hCudc : M\u2082.toMatroid.IsUnionDisjointCircuits C) :\n    M\u2082.toMatroid.Circuit C :=\n  have \u27e8\u27e8C_nempty, hCE, _\u27e9, hCmin\u27e9 := hCpred\n  \u27e8hCudc.nonempty_dep C_nempty, fun D hD hDC =>\n    have \u27e8_, D', hD', hDD'\u27e9 := M\u2082.toMatroid.dep_iff_has_circuit.\u2192 hD\n    (hCmin\n        (DeltaSumCircuitForm2.circuit_form \u27e8hD', (Set.subset_diff.\u2192 ((hDD'.trans hDC).trans hCE)).right\u27e9)\n        (hDD'.trans hDC)\n      ).trans hDD'\u27e9\n\nend CircuitForm2\n\n\nsection CircuitForm3\n\n/-- Form 3 of circuits in `M\u2081 \u0394 M\u2082`:\n    sets `C\u2081 \u0394 C\u2082` where `C\u2081` and `C\u2082` are circuits in `M\u2081` and `M\u2082`, respectively,\n    with `C\u2081 \u2229 (M\u2081.E \u2229 M\u2082.E)` and `C\u2082 \u2229 (M\u2081.E \u2229 M\u2082.E)` being the same one-element set.\n    Here we use equivalent definition by denoting `p` the single element in `C\u2081 \u2229 C\u2082` and\n    expressing `C\u2081` and `C\u2082` via `p`, `C`, and ground sets of `M\u2081` and `M\u2082`. -/\ndef DeltaSumCircuitForm3 (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C : Set \u03b1) (p : \u03b1) : Prop :=\n  M\u2081.toMatroid.Circuit ((C \u2229 M\u2081.E) \u222a {p}) \u2227\n  M\u2082.toMatroid.Circuit ((C \u2229 M\u2082.E) \u222a {p}) \u2227\n  C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)\n\n/-- Existential version of form 3 of circuits -/\ndef IsDeltaSumCircuitForm3 (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C : Set \u03b1) : Prop :=\n  \u2203 p \u2208 M\u2081.E \u2229 M\u2082.E, DeltaSumCircuitForm3 M\u2081 M\u2082 C p\n\nvariable {C : Set \u03b1} {p : \u03b1}\n\n/-- Circuit of form 3 yields a circuit in `M\u2081` after intersecting it with `M\u2081.E` and adding `p` -/\ndef DeltaSumCircuitForm3.to_circuit_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    M\u2081.toMatroid.Circuit ((C \u2229 M\u2081.E) \u222a {p}) :=\n  hC.left\n\n/-- Circuit of form 3 yields a circuit in `M\u2082` after intersecting it with `M\u2081.E` and adding `p` -/\ndef DeltaSumCircuitForm3.to_circuit_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    M\u2082.toMatroid.Circuit ((C \u2229 M\u2082.E) \u222a {p}) :=\n  hC.right.left\n\n/-- Circuit of form 3 is subset of ground set of `M\u2081 \u0394 M\u2082` -/\ndef DeltaSumCircuitForm3.subset_ground {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E) :=\n  hC.right.right\n\n/-- Singleton element in definition of circuit form 3 lies in `M\u2081.E` -/\nlemma DeltaSumCircuitForm3.singleton_subset_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    {p} \u2286 M\u2081.E :=\n  (Set.union_subset_iff.\u2192 hC.to_circuit_M\u2081.subset_ground).right\n\n/-- Singleton element in definition of circuit form 3 lies in `M\u2082.E` -/\nlemma DeltaSumCircuitForm3.singleton_subset_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    {p} \u2286 M\u2082.E :=\n  (Set.union_subset_iff.\u2192 hC.to_circuit_M\u2082.subset_ground).right\n\n/-- Singleton element in definition of circuit form 3 lies in `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm3.singleton_subset_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    {p} \u2286 M\u2081.E \u2229 M\u2082.E :=\n  Set.subset_inter hC.singleton_subset_M\u2081 hC.singleton_subset_M\u2082\n\n/-- Circuit of form 3 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma DeltaSumCircuitForm3.subset_union {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    C \u2286 M\u2081.E \u222a M\u2082.E :=\n  sub_union_diff_sub_union hC.subset_ground\n\n/-- Circuit of form 3 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm3.disjoint_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  Set.disjoint_of_subset_left hC.subset_ground Set.disjoint_sdiff_left\n\n", "theoremStatement": "/-- Circuit of form 3 intersected with `M\u2081.E` is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm3.disjoint_inter_M\u2081_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    C \u2229 M\u2081.E \u2ad7 M\u2081.E \u2229 M\u2082.E ", "theoremName": "DeltaSumCircuitForm3.disjoint_inter_M\u2081_inter", "fileCreated": {"commit": "aae07a69b2ec95e3d9a1436952a123dcb7d0d06f", "date": "2025-01-03"}, "theoremCreated": {"commit": "67629d2b74be7b972786897531b678f585a7af28", "date": "2025-02-03"}, "file": "Seymour/Seymour/Matroid/Operations/SumDelta/CircuitForms.lean", "module": "Seymour.Matroid.Operations.SumDelta.CircuitForms", "jsonFile": "Seymour.Matroid.Operations.SumDelta.CircuitForms.jsonl", "positionMetadata": {"lineInFile": 226, "tokenPositionInFile": 9669, "theoremPositionInFile": 30}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 5, "numPremises": 20}, "proofMetadata": {"hasProof": true, "proof": ":=\n  hC.disjoint_inter.inter_left M\u2081.E", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 38}}
{"srcContext": "import Mathlib.Data.Set.Card\nimport Mathlib.Data.Matroid.Dual\n\nimport Seymour.ForMathlib.SetTheory\nimport Seymour.Matroid.Notions.Circuit\nimport Seymour.Matroid.Notions.CircuitAxioms\nimport Seymour.Matroid.Notions.Connectivity\nimport Seymour.Matroid.Constructors.CircuitMatroid\n\n/-!\nThis file defines 2-sum of two (general) matroids `M\u2081` and `M\u2082`, denoted as `M\u2081 \u2295\u2082 M\u2082`.\n-/\n\nvariable {\u03b1 : Type}\n\n\nsection MainDefinitions\n\n/-- `M\u2081 \u2295\u2082 M\u2082` is defined if `M\u2081` and `M\u2082` satisfy the following assumptions -/\nstructure TwoSumAssumptions (M\u2081 M\u2082 : Matroid \u03b1) : Prop where\n  /-- `M\u2081` is finite -/\n  M\u2081fin : M\u2081.Finite\n  /-- `M\u2082` is finite -/\n  M\u2082fin : M\u2082.Finite\n  /-- `M\u2081` contains at least 2 elements -/\n  M\u2081card : M\u2081.E.encard \u2265 2\n  /-- `M\u2082` contains at least 2 elements -/\n  M\u2082card : M\u2082.E.encard \u2265 2\n  /-- `M\u2081` and `M\u2082` have exactly one element in common -/\n  interSingleton : (M\u2081.E \u2229 M\u2082.E).encard = 1\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2081` -/\n  M\u2081sep : \u00acM\u2081.Separator (M\u2081.E \u2229 M\u2082.E)\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2082` -/\n  M\u2082sep : \u00acM\u2082.Separator (M\u2081.E \u2229 M\u2082.E)\n\n-- question: can avoid this assumption? -- which assumption? the finiteness?\n\n/-- Ground set of `M\u2081 \u2295\u2082 M\u2082` -/\ndef twoSumGround (M\u2081 M\u2082 : Matroid \u03b1) : Set \u03b1 :=\n  (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)\n\n/-- Type 1 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2081` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType1 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 2 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2082` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType2 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2082.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 3 of circuits in `M\u2081 \u2295\u2082 M\u2082`:\n    sets `(C\u2081 \u222a C\u2082) \\ (M\u2081.E \u2229 M\u2082.E)` where `C\u2081` and `C\u2082` are circuits in `M\u2081` and `M\u2082`, respectively,\n    and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2081` and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2082` -/\ndef TwoSumCircuitType3 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit ((C \u2229 M\u2081.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 M\u2082.Circuit ((C \u2229 M\u2082.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 C \u2286 twoSumGround M\u2081 M\u2082\n\n/-- Circuit predicate of `M\u2081 \u2295\u2082 M\u2082`, which defines 2-sum as `CircuitMatroid` -/\ndef TwoSumCircuitPred (M\u2081 M\u2082 : Matroid \u03b1) : CircuitPredicate \u03b1 :=\n  fun C : Set \u03b1 =>\n    TwoSumCircuitType1 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType2 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType3 M\u2081 M\u2082 C\n\nend MainDefinitions\n\n\nsection PropertiesAssumptions\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1}\n\n/-- 2-sum assumptions are symmetric -/\nlemma TwoSumAssumptions.symm (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    TwoSumAssumptions M\u2082 M\u2081 :=\n  \u27e8\n    assumptions.M\u2082fin,\n    assumptions.M\u2081fin,\n    assumptions.M\u2082card,\n    assumptions.M\u2081card,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.interSingleton,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2082sep,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2081sep,\n  \u27e9\n\n/-- Intersection of ground sets is nonempty -/\nlemma TwoSumAssumptions.inter_nonempty (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (M\u2081.E \u2229 M\u2082.E).Nonempty :=\n  Set.one_le_encard_iff_nonempty.\u2192 assumptions.interSingleton.symm.le\n\n/-- Intersection of ground sets is a singleton set -/\nlemma TwoSumAssumptions.inter_singleton (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    \u2203 p : \u03b1, M\u2081.E \u2229 M\u2082.E = {p} :=\n  Set.encard_eq_one.\u2192 assumptions.interSingleton\n\nvariable {p : \u03b1}\n\n/-- Singleton element in intersection of ground sets in not a loop in `M\u2081` -/\nlemma TwoSumAssumptions.inter_singleton_not_loop_M\u2081 (assumptions : TwoSumAssumptions M\u2081 M\u2082)\n    (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2081.Loop p) :=\n  (hp \u25b8 assumptions.M\u2081sep <| Matroid.separator_loop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a coloop in `M\u2081` -/\nlemma TwoSumAssumptions.inter_singleton_not_coloop_M\u2081 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2081.Coloop p) :=\n  (hp \u25b8 assumptions.M\u2081sep <| Matroid.separator_coloop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a loop in `M\u2082` -/\nlemma TwoSumAssumptions.inter_singleton_not_loop_M\u2082 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2082.Loop p) :=\n  (hp \u25b8 assumptions.M\u2082sep <| Matroid.separator_loop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a coloop in `M\u2082` -/\nlemma TwoSumAssumptions.inter_singleton_not_coloop_M\u2082 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2082.Coloop p) :=\n  (hp \u25b8 assumptions.M\u2082sep <| Matroid.separator_coloop \u00b7)\n\nend PropertiesAssumptions\n\n\nsection PropertiesGroundSet\n\n/-- Ground set of 2-sum is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma twoSumGround_disjoint_inter (M\u2081 M\u2082 : Matroid \u03b1) :\n    twoSumGround M\u2081 M\u2082 \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  Set.disjoint_sdiff_left\n\n/-- Ground sets minus their intersection are disjoint sets -/\nlemma twoSum_disjoint_grounds_diff_inter (M\u2081 M\u2082 : Matroid \u03b1) :\n    M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) \u2ad7 M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E) := by\n  rw [Set.diff_self_inter, Set.diff_inter_self_eq_diff]\n  exact disjoint_sdiff_sdiff\n\nend PropertiesGroundSet\n\n\nsection PropertiesCircuitType1\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1} {C : Set \u03b1}\n\n/-- Circuit of type 1 is a circuit in `M\u2081` -/\nlemma TwoSumCircuitType1.circuit_M\u2081 (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : M\u2081.Circuit C :=\n  hC.left\n\n/-- Circuit of type 1 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType1.disjoint_inter (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of type 1 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma TwoSumCircuitType1.subset_union (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_left hC.circuit_M\u2081.subset_ground M\u2082.E\n\n/-- Circuit of type 1 lies in ground set of `M\u2081 \u2295\u2082 M\u2082` -/\nlemma TwoSumCircuitType1.subset_ground (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 twoSumGround M\u2081 M\u2082 :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 1 lies in `M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma TwoSumCircuitType1.subset_M\u2081_diff_inter (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2081.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 1 is disjoint with `M\u2082.E` -/\nlemma TwoSumCircuitType1.disjoint_M\u2082 (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2ad7 M\u2082.E := by\n  have hMM := twoSum_disjoint_grounds_diff_inter M\u2081 M\u2082\n  have hCM\u2082 := Set.disjoint_of_subset_left hC.subset_M\u2081_diff_inter hMM\n  have hCM\u2082 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2082, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_right] at hCM\u2082\n  exact hCM\u2082\n\nend PropertiesCircuitType1\n\n\nsection PropertiesCircuitType2\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1} {C : Set \u03b1}\n\n/-- Circuit of type 2 is a circuit in `M\u2082` -/\nlemma TwoSumCircuitType2.circuit_M\u2082 (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : M\u2082.Circuit C :=\n  hC.left\n\n/-- Circuit of type 2 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType2.disjoint_inter (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of type 2 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma TwoSumCircuitType2.subset_union (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_right hC.circuit_M\u2082.subset_ground M\u2081.E\n\n/-- Circuit of type 2 lies in ground set of `M\u2081 \u2295\u2082 M\u2082` -/\nlemma TwoSumCircuitType2.subset_ground (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2286 twoSumGround M\u2081 M\u2082 :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 2 lies in `M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma TwoSumCircuitType2.subset_M\u2082_diff_inter (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2286 M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2082.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 2 is disjoint with `M\u2081.E` -/\nlemma TwoSumCircuitType2.disjoint_M\u2081 (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E := by\n  have hMM := twoSum_disjoint_grounds_diff_inter M\u2081 M\u2082\n  have hCM\u2081 := (Set.disjoint_of_subset_right hC.subset_M\u2082_diff_inter hMM).symm\n  have hCM\u2081 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2081, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_left] at hCM\u2081\n  exact hCM\u2081\n\nend PropertiesCircuitType2\n\n\nsection PropertiesCircuitType3\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1} {C : Set \u03b1}\n\n/-- Circuit of type 3 yields a circuit in `M\u2081` after intersecting it with `M\u2081.E` and adding `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType3.to_circuit_M\u2081 (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : M\u2081.Circuit ((C \u2229 M\u2081.E) \u222a (M\u2081.E \u2229 M\u2082.E)) :=\n  hC.left\n\n/-- Circuit of type 3 yields a circuit in `M\u2082` after intersecting it with `M\u2081.E` and adding `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType3.to_circuit_M\u2082 (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : M\u2082.Circuit ((C \u2229 M\u2082.E) \u222a (M\u2081.E \u2229 M\u2082.E)) :=\n  hC.right.left\n\n/-- Circuit of type 3 is subset of ground set of `M\u2081 \u2295\u2082 M\u2082` -/\ndef TwoSumCircuitType3.subset_ground (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2286 twoSumGround M\u2081 M\u2082 :=\n  hC.right.right\n\n/-- Circuit of type 3 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma TwoSumCircuitType3.subset_union (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \u222a M\u2082.E :=\n  sub_union_diff_sub_union hC.subset_ground\n\n/-- Circuit of type 3 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType3.disjoint_inter (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  Set.disjoint_of_subset_left hC.subset_ground (twoSumGround_disjoint_inter M\u2081 M\u2082)\n\n/-- Circuit of type 3 intersected with `M\u2081.E` is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType3.disjoint_inter_M\u2081_inter (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2229 M\u2081.E \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.disjoint_inter.inter_left M\u2081.E\n\n/-- Circuit of type 3 intersected with `M\u2082.E` is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType3.disjoint_inter_M\u2082_inter (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2229 M\u2082.E \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.disjoint_inter.inter_left M\u2082.E\n\n/-- Circuit of type 3 has nonempty intersection with `M\u2081.E` -/\nlemma TwoSumCircuitType3.inter_M\u2081_nonempty (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (C \u2229 M\u2081.E).Nonempty := by\n  by_contra! hCM\u2081\n  have hM\u2081 := hC.to_circuit_M\u2081\n  have \u27e8p, hp\u27e9 := assumptions.inter_singleton\n  rw [hCM\u2081, Set.empty_union, hp, \u2190Matroid.loop_iff_circuit M\u2081] at hM\u2081\n  have hpM\u2081 := assumptions.inter_singleton_not_loop_M\u2081 hp\n  exact hpM\u2081 hM\u2081\n\n/-- Circuit of type 3 has nonempty intersection with `M\u2082.E` -/\nlemma TwoSumCircuitType3.inter_M\u2082_nonempty (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (C \u2229 M\u2082.E).Nonempty := by\n  by_contra! hCM\u2082empty\n  have hCM\u2082 := hC.to_circuit_M\u2082\n  have \u27e8p, hp\u27e9 := assumptions.inter_singleton\n  rw [hCM\u2082empty, Set.empty_union, hp, \u2190Matroid.loop_iff_circuit M\u2082] at hCM\u2082\n  exact assumptions.inter_singleton_not_loop_M\u2082 hp hCM\u2082\n\nend PropertiesCircuitType3\n\n\nsection PropertiesCircuitTypePairs1\n\n/-- Circuit of type 1 is not a strict subset of any circuit of type 1 -/\nlemma TwoSumCircuitType1.not_ssubset_circuit_type_1 {M\u2081 M\u2082 : Matroid \u03b1} {C C' : Set \u03b1}\n    (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) (hC' : TwoSumCircuitType1 M\u2081 M\u2082 C') :\n    \u00ac(C \u2282 C') :=\n  hC.circuit_M\u2081.not_ssubset_circuit hC'.circuit_M\u2081\n\n/-- Circuit of type 1 is disjoint with any circuit of type 2 -/\nlemma TwoSumCircuitType1.disjoint_circuit_type_2 {M\u2081 M\u2082 : Matroid \u03b1} {C\u2081 C\u2082 : Set \u03b1}\n    (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) :\n    C\u2081 \u2ad7 C\u2082 := by\n  have hC\u2081M\u2081 := hC\u2081.subset_M\u2081_diff_inter\n  have hC\u2082M\u2082 := hC\u2082.subset_M\u2082_diff_inter\n  have hMM := twoSum_disjoint_grounds_diff_inter M\u2081 M\u2082\n  exact Set.disjoint_of_subset hC\u2081M\u2081 hC\u2082M\u2082 hMM\n\n/-- Circuit of type 1 is not a strict subset of any circuit of type 2 -/\nlemma TwoSumCircuitType1.not_ssubset_circuit_type_2 {M\u2081 M\u2082 : Matroid \u03b1} {C\u2081 C\u2082 : Set \u03b1}\n    (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) :\n    \u00ac(C\u2081 \u2282 C\u2082) :=\n  disjoint_nonempty_not_ssubset (hC\u2081.disjoint_circuit_type_2 hC\u2082) hC\u2081.circuit_M\u2081.nonempty\n\n/-- Circuit of type 1 is not a strict subset of any circuit of type 3 -/\nlemma TwoSumCircuitType1.not_ssubset_circuit_type_3 {M\u2081 M\u2082 : Matroid \u03b1} {C\u2081 C\u2083 : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) (hC\u2083 : TwoSumCircuitType3 M\u2081 M\u2082 C\u2083) :\n    \u00ac(C\u2081 \u2282 C\u2083) :=\n  fun hCC =>\n    hC\u2081.circuit_M\u2081.not_ssubset_circuit hC\u2083.to_circuit_M\u2081\n      (Set.ssubset_of_ssubset_of_subset (ssubset_union_disjoint_nonempty hC\u2081.disjoint_inter assumptions.inter_nonempty)\n        (Set.union_subset_union_left (M\u2081.E \u2229 M\u2082.E) (Set.subset_inter hCC.left hC\u2081.circuit_M\u2081.subset_ground)))\n\n/-- Circuit of type 1 is not a strict subset of any other circuit -/\nlemma TwoSumCircuitType1.not_ssubset_circuit {M\u2081 M\u2082 : Matroid \u03b1} {C\u2081 C : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) (hC : TwoSumCircuitPred M\u2081 M\u2082 C) :\n    \u00ac(C\u2081 \u2282 C) := by\n  cases hC with\n  | inl hC => exact hC\u2081.not_ssubset_circuit_type_1 hC\n  | inr hC => cases hC with\n    | inl hC => exact hC\u2081.not_ssubset_circuit_type_2 hC\n    | inr hC => exact hC\u2081.not_ssubset_circuit_type_3 assumptions hC\n\nend PropertiesCircuitTypePairs1\n\n\nsection PropertiesCircuitTypePairs2\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1}\n\n/-- Circuits of type 2 are disjoint with circuits of type 1 -/\nlemma TwoSumCircuitType2.disjoint_circuitType1 {C\u2081 C\u2082 : Set \u03b1}\n    (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) :\n    C\u2082 \u2ad7 C\u2081 :=\n  (hC\u2081.disjoint_circuit_type_2 hC\u2082).symm\n\n/-- Circuit of type 2 is not a strict subset of any circuit of type 1 -/\nlemma TwoSumCircuitType2.not_ssubset_circuitType1 {C\u2081 C\u2082 : Set \u03b1}\n    (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) :\n    \u00ac(C\u2082 \u2282 C\u2081) :=\n  disjoint_nonempty_not_ssubset (hC\u2082.disjoint_circuitType1 hC\u2081) hC\u2082.circuit_M\u2082.nonempty\n\n/-- Circuit of type 2 is not a strict subset of any circuit of type 2 -/\nlemma TwoSumCircuitType2.not_ssubset_circuitType2 {C C' : Set \u03b1}\n    (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) (hC' : TwoSumCircuitType2 M\u2081 M\u2082 C') :\n    \u00ac(C \u2282 C') :=\n  hC.circuit_M\u2082.not_ssubset_circuit hC'.circuit_M\u2082\n\n/-- Circuit of type 2 is not a strict subset of any circuit of type 3 -/\nlemma TwoSumAssumptions.circuitType2_not_ssubset_circuitType3 {C\u2082 C\u2083 : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) (hC\u2083 : TwoSumCircuitType3 M\u2081 M\u2082 C\u2083) :\n    \u00ac(C\u2082 \u2282 C\u2083) :=\n  fun hCC =>\n    hC\u2082.circuit_M\u2082.not_ssubset_circuit hC\u2083.to_circuit_M\u2082\n      (Set.ssubset_of_ssubset_of_subset (ssubset_union_disjoint_nonempty hC\u2082.disjoint_inter assumptions.inter_nonempty)\n        (Set.union_subset_union_left (M\u2081.E \u2229 M\u2082.E) (Set.subset_inter hCC.left hC\u2082.circuit_M\u2082.subset_ground)))\n\n/-- Circuit of type 2 is not a strict subset of any other circuit -/\nlemma TwoSumAssumptions.circuitType2_not_ssubset {C\u2082 C : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) (hC : TwoSumCircuitPred M\u2081 M\u2082 C) :\n    \u00ac(C\u2082 \u2282 C) := by\n  cases hC with\n  | inl hC => exact hC\u2082.not_ssubset_circuitType1 hC\n  | inr hC => cases hC with\n    | inl hC => exact hC\u2082.not_ssubset_circuitType2 hC\n    | inr hC => exact assumptions.circuitType2_not_ssubset_circuitType3 hC\u2082 hC\n\nend PropertiesCircuitTypePairs2\n\n\nsection PropertiesCircuitTypePairs3\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1}\n\n/-- Circuit of type 3 is not a strict subset of any circuit of type 1 -/\nlemma TwoSumAssumptions.circuitType3_not_ssubset_circuitType1 {C\u2081 C\u2083 : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2083 : TwoSumCircuitType3 M\u2081 M\u2082 C\u2083) (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) :\n    \u00ac(C\u2083 \u2282 C\u2081) :=\n  nonempty_inter_not_ssubset_empty_inter (hC\u2083.inter_M\u2082_nonempty assumptions) hC\u2081.disjoint_M\u2082.inter_eq\n\n/-- Circuit of type 3 is not a strict subset of any circuit of type 2 -/\nlemma TwoSumAssumptions.circuitType3_not_ssubset_circuitType2 {C\u2082 C\u2083 : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2083 : TwoSumCircuitType3 M\u2081 M\u2082 C\u2083) (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) :\n    \u00ac(C\u2083 \u2282 C\u2082) :=\n  nonempty_inter_not_ssubset_empty_inter (hC\u2083.inter_M\u2081_nonempty assumptions) hC\u2082.disjoint_M\u2081.inter_eq\n\n/-- Circuit of type 3 is not a strict subset of any circuit of type 3 -/\nlemma TwoSumCircuitType3.not_ssubset_circuitType3 {C C' : Set \u03b1}\n    (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) (hC' : TwoSumCircuitType3 M\u2081 M\u2082 C') :\n    \u00ac(C \u2282 C') := by\n  intro \u27e8hCC', hnCC'\u27e9\n  have M\u2081_circ_nssub := Set.ssubset_def \u25b8 hC.to_circuit_M\u2081.not_ssubset_circuit hC'.to_circuit_M\u2081\n  have M\u2082_circ_nssub := Set.ssubset_def \u25b8 hC.to_circuit_M\u2082.not_ssubset_circuit hC'.to_circuit_M\u2082\n  push_neg at M\u2081_circ_nssub\n  push_neg at M\u2082_circ_nssub\n  have M\u2081_circ_sub := (union_subset_union_iff hC'.disjoint_inter_M\u2081_inter hC.disjoint_inter_M\u2081_inter).\u2192\n    (M\u2081_circ_nssub (Set.union_subset_union_left (M\u2081.E \u2229 M\u2082.E) (Set.inter_subset_inter_left M\u2081.E hCC')))\n  have M\u2082_circ_sub := (union_subset_union_iff hC'.disjoint_inter_M\u2082_inter hC.disjoint_inter_M\u2082_inter).\u2192\n    (M\u2082_circ_nssub (Set.union_subset_union_left (M\u2081.E \u2229 M\u2082.E) (Set.inter_subset_inter_left M\u2082.E hCC')))\n  exact hnCC' (hC.subset_union.parts_eq \u25b8 hC'.subset_union.parts_eq \u25b8 Set.union_subset_union M\u2081_circ_sub M\u2082_circ_sub)\n\n/-- Circuit of type 3 is not a strict subset of any other circuit -/\nlemma TwoSumAssumptions.circuitType3_not_ssubset_circuit {C\u2083 C : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2083 : TwoSumCircuitType3 M\u2081 M\u2082 C\u2083) (hC : TwoSumCircuitPred M\u2081 M\u2082 C) :\n    \u00ac(C\u2083 \u2282 C) := by\n  cases hC with\n  | inl hC => exact assumptions.circuitType3_not_ssubset_circuitType1 hC\u2083 hC\n  | inr hC => cases hC with\n    | inl hC => exact assumptions.circuitType3_not_ssubset_circuitType2 hC\u2083 hC\n    | inr hC => exact hC\u2083.not_ssubset_circuitType3 hC\n\nend PropertiesCircuitTypePairs3\n\n\nsection PropertiesCircuitPred\n\n/-- In definition of 2-sum, empty set is not a circuit -/\nlemma TwoSumAssumptions.twoSumCircuitPred_notCircuitEmpty {M\u2081 M\u2082 : Matroid \u03b1} (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (TwoSumCircuitPred M\u2081 M\u2082).NotCircuitEmpty := by\n  unfold CircuitPredicate.NotCircuitEmpty TwoSumCircuitPred\n  push_neg\n  refine \u27e8(\u00b7.circuit_M\u2081.nonempty.ne_empty rfl), (\u00b7.circuit_M\u2082.nonempty.ne_empty rfl), fun \u27e8hpM\u2081, hpM\u2082, hE\u27e9 => ?_\u27e9\n  have \u27e8p, hp\u27e9 := assumptions.inter_singleton\n  rw [Set.empty_inter, Set.empty_union, hp, \u2190Matroid.loop_iff_circuit M\u2081] at hpM\u2081\n  exact (hp \u25b8 assumptions.M\u2081sep) (Matroid.separator_loop hpM\u2081)\n\n/-- In definition of 2-sum, no circuit is a strict subset of another -/\nlemma TwoSumAssumptions.twoSumCircuitPred_circuitNotSsubset {M\u2081 M\u2082 : Matroid \u03b1} (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (TwoSumCircuitPred M\u2081 M\u2082).CircuitNotSsubset := by\n  intro C\u2081 C\u2082 hC\u2081 hC\u2082\n  cases hC\u2082 with\n  | inl hC\u2082 => exact hC\u2082.not_ssubset_circuit assumptions hC\u2081\n  | inr hC\u2082 => cases hC\u2082 with\n    | inl hC\u2082 => exact assumptions.circuitType2_not_ssubset hC\u2082 hC\u2081\n    | inr hC\u2082 => exact assumptions.circuitType3_not_ssubset_circuit hC\u2082 hC\u2081\n\n-- todo: remaining circuit axioms\n\n/-- todo: desc -/\nlemma TwoSumAssumptions.CircuitPred.subset_ground (M\u2081 M\u2082 : Matroid \u03b1) :\n    (TwoSumCircuitPred M\u2081 M\u2082).SubsetGround (twoSumGround M\u2081 M\u2082) := by\n  intro C hC\n  cases hC with\n  | inl hC => exact hC.subset_ground\n  | inr hC => cases hC with\n    | inl hC => exact hC.subset_ground\n    | inr hC => exact hC.subset_ground\n\nend PropertiesCircuitPred\n\n\nsection TwoSumDefinition\n\n/-- `CircuitMatroid` defining `M\u2081 \u2295\u2082 M\u2082` -/\ndef TwoSumAssumptions.build2sumCircuitMatroid {M\u2081 M\u2082 : Matroid \u03b1} (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    CircuitMatroid \u03b1 where\n  E := twoSumGround M\u2081 M\u2082\n  CircuitPred := TwoSumCircuitPred M\u2081 M\u2082\n  not_circuit_empty := assumptions.twoSumCircuitPred_notCircuitEmpty\n  circuit_not_ssubset := assumptions.twoSumCircuitPred_circuitNotSsubset\n  circuit_c3 := sorry -- todo: should simplify in finite case\n  circuit_maximal := sorry -- todo: should simplify in finite case\n  subset_ground := CircuitPred.subset_ground M\u2081 M\u2082\n\n@[simp]\nlemma TwoSumAssumptions.build2sumCircuitMatroid_circuitPred {M\u2081 M\u2082 : Matroid \u03b1} (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    assumptions.build2sumCircuitMatroid.CircuitPred = TwoSumCircuitPred M\u2081 M\u2082 :=\n  rfl\n\n/-- The main way of creating a 2-sum of any matroids. -/\ndef TwoSumAssumptions.build2sum {M\u2081 M\u2082 : Matroid \u03b1} (assumptions : TwoSumAssumptions M\u2081 M\u2082) : Matroid \u03b1 :=\n  assumptions.build2sumCircuitMatroid.toMatroid\n\n", "theoremStatement": "@[simp]\nlemma TwoSumAssumptions.build2sum_E {M\u2081 M\u2082 : Matroid \u03b1} (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    assumptions.build2sum.E = (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E) ", "theoremName": "TwoSumAssumptions.build2sum_E", "fileCreated": {"commit": "d0eaaa305c96cd81ac061f505a81614db6856b21", "date": "2025-01-09"}, "theoremCreated": {"commit": "439c72996f29168161b974bc602629cac773728f", "date": "2025-01-08"}, "file": "Seymour/Seymour/Matroid/Operations/Sum2/Basic.lean", "module": "Seymour.Matroid.Operations.Sum2.Basic", "jsonFile": "Seymour.Matroid.Operations.Sum2.Basic.jsonl", "positionMetadata": {"lineInFile": 451, "tokenPositionInFile": 19772, "theoremPositionInFile": 54}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 13}, "proofMetadata": {"hasProof": true, "proof": ":=\n  rfl", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 8}}
{"srcContext": "import Mathlib.Order.RelClasses\nimport Mathlib.Data.Matroid.IndepAxioms\n\nimport Seymour.Basic\nimport Seymour.Matroid.Notions.IndepAxioms\nimport Seymour.Matroid.Notions.CircuitAxioms\nimport Seymour.Matroid.Notions.Circuit\n\n\n/-- Matroid defined by circuit axioms. -/\nstructure CircuitMatroid (\u03b1 : Type) where\n  /-- The ground set -/\n  E : Set \u03b1\n  /-- The circuit predicate -/\n  CircuitPred : CircuitPredicate \u03b1\n  /-- Empty set is not a circuit -/\n  not_circuit_empty : CircuitPred.NotCircuitEmpty\n  /-- No circuit is a subset of another circuit -/\n  circuit_not_ssubset : CircuitPred.CircuitNotSsubset\n  /-- Condition (C3) from Bruhn et al. -/\n  circuit_c3 : CircuitPred.BruhnC3\n  /-- Corresponding family of independent sets satisfies the maximal subset property -/\n  circuit_maximal : CircuitPred.CircuitMaximal E\n  /-- Every circuit is a subset of the ground set -/\n  subset_ground : CircuitPred.SubsetGround E -- question: unused?\n\nvariable {\u03b1 : Type}\n\n/-- Corresponding independence predicate of circuit matroid. -/\ndef CircuitMatroid.IndepPred (M : CircuitMatroid \u03b1) :\n    IndepPredicate \u03b1 :=\n  M.CircuitPred.toIndepPredicate M.E\n\n/-- Corresponding independence predicate of circuit matroid satisfies (I1): empty set is independent. -/\nlemma CircuitMatroid.indep_empty (M : CircuitMatroid \u03b1) :\n    M.IndepPred.IndepEmpty :=\n  CircuitPredicate.toIndepPredicate_indepEmpty M.not_circuit_empty M.E\n\n", "theoremStatement": "/-- Corresponding independence predicate of circuit matroid satisfies (I2): subsets of independent sets are independent. -/\nlemma CircuitMatroid.indep_subset (M : CircuitMatroid \u03b1) :\n    M.IndepPred.IndepSubset ", "theoremName": "CircuitMatroid.indep_subset", "fileCreated": {"commit": "b44bff2f1ee71349fa9fa251579a0f5a0e575538", "date": "2024-12-19"}, "theoremCreated": {"commit": "4d9233309fad6a3c9d3d0d88dcfa6420fcb14dcb", "date": "2024-12-18"}, "file": "Seymour/Seymour/Matroid/Constructors/CircuitMatroid.lean", "module": "Seymour.Matroid.Constructors.CircuitMatroid", "jsonFile": "Seymour.Matroid.Constructors.CircuitMatroid.jsonl", "positionMetadata": {"lineInFile": 39, "tokenPositionInFile": 1400, "theoremPositionInFile": 2}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 6, "numPremises": 6}, "proofMetadata": {"hasProof": true, "proof": ":=\n  CircuitPredicate.toIndepPredicate_indepSubset M.CircuitPred M.E", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 68}}
{"srcContext": "import Mathlib.Data.Set.Card\nimport Mathlib.Data.Matroid.Dual\n\nimport Seymour.ForMathlib.SetTheory\nimport Seymour.Matroid.Notions.Circuit\nimport Seymour.Matroid.Notions.CircuitAxioms\nimport Seymour.Matroid.Notions.Connectivity\nimport Seymour.Matroid.Constructors.CircuitMatroid\n\n/-!\nThis file defines 2-sum of two (general) matroids `M\u2081` and `M\u2082`, denoted as `M\u2081 \u2295\u2082 M\u2082`.\n-/\n\nvariable {\u03b1 : Type}\n\n\nsection MainDefinitions\n\n/-- `M\u2081 \u2295\u2082 M\u2082` is defined if `M\u2081` and `M\u2082` satisfy the following assumptions -/\nstructure TwoSumAssumptions (M\u2081 M\u2082 : Matroid \u03b1) : Prop where\n  /-- `M\u2081` is finite -/\n  M\u2081fin : M\u2081.Finite\n  /-- `M\u2082` is finite -/\n  M\u2082fin : M\u2082.Finite\n  /-- `M\u2081` contains at least 2 elements -/\n  M\u2081card : M\u2081.E.encard \u2265 2\n  /-- `M\u2082` contains at least 2 elements -/\n  M\u2082card : M\u2082.E.encard \u2265 2\n  /-- `M\u2081` and `M\u2082` have exactly one element in common -/\n  interSingleton : (M\u2081.E \u2229 M\u2082.E).encard = 1\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2081` -/\n  M\u2081sep : \u00acM\u2081.Separator (M\u2081.E \u2229 M\u2082.E)\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2082` -/\n  M\u2082sep : \u00acM\u2082.Separator (M\u2081.E \u2229 M\u2082.E)\n\n-- question: can avoid this assumption? -- which assumption? the finiteness?\n\n/-- Ground set of `M\u2081 \u2295\u2082 M\u2082` -/\ndef twoSumGround (M\u2081 M\u2082 : Matroid \u03b1) : Set \u03b1 :=\n  (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)\n\n/-- Type 1 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2081` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType1 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 2 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2082` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType2 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2082.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 3 of circuits in `M\u2081 \u2295\u2082 M\u2082`:\n    sets `(C\u2081 \u222a C\u2082) \\ (M\u2081.E \u2229 M\u2082.E)` where `C\u2081` and `C\u2082` are circuits in `M\u2081` and `M\u2082`, respectively,\n    and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2081` and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2082` -/\ndef TwoSumCircuitType3 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit ((C \u2229 M\u2081.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 M\u2082.Circuit ((C \u2229 M\u2082.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 C \u2286 twoSumGround M\u2081 M\u2082\n\n/-- Circuit predicate of `M\u2081 \u2295\u2082 M\u2082`, which defines 2-sum as `CircuitMatroid` -/\ndef TwoSumCircuitPred (M\u2081 M\u2082 : Matroid \u03b1) : CircuitPredicate \u03b1 :=\n  fun C : Set \u03b1 =>\n    TwoSumCircuitType1 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType2 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType3 M\u2081 M\u2082 C\n\nend MainDefinitions\n\n\nsection PropertiesAssumptions\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1}\n\n/-- 2-sum assumptions are symmetric -/\nlemma TwoSumAssumptions.symm (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    TwoSumAssumptions M\u2082 M\u2081 :=\n  \u27e8\n    assumptions.M\u2082fin,\n    assumptions.M\u2081fin,\n    assumptions.M\u2082card,\n    assumptions.M\u2081card,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.interSingleton,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2082sep,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2081sep,\n  \u27e9\n\n/-- Intersection of ground sets is nonempty -/\nlemma TwoSumAssumptions.inter_nonempty (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (M\u2081.E \u2229 M\u2082.E).Nonempty :=\n  Set.one_le_encard_iff_nonempty.\u2192 assumptions.interSingleton.symm.le\n\n/-- Intersection of ground sets is a singleton set -/\nlemma TwoSumAssumptions.inter_singleton (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    \u2203 p : \u03b1, M\u2081.E \u2229 M\u2082.E = {p} :=\n  Set.encard_eq_one.\u2192 assumptions.interSingleton\n\nvariable {p : \u03b1}\n\n/-- Singleton element in intersection of ground sets in not a loop in `M\u2081` -/\nlemma TwoSumAssumptions.inter_singleton_not_loop_M\u2081 (assumptions : TwoSumAssumptions M\u2081 M\u2082)\n    (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2081.Loop p) :=\n  (hp \u25b8 assumptions.M\u2081sep <| Matroid.separator_loop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a coloop in `M\u2081` -/\nlemma TwoSumAssumptions.inter_singleton_not_coloop_M\u2081 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2081.Coloop p) :=\n  (hp \u25b8 assumptions.M\u2081sep <| Matroid.separator_coloop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a loop in `M\u2082` -/\nlemma TwoSumAssumptions.inter_singleton_not_loop_M\u2082 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2082.Loop p) :=\n  (hp \u25b8 assumptions.M\u2082sep <| Matroid.separator_loop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a coloop in `M\u2082` -/\nlemma TwoSumAssumptions.inter_singleton_not_coloop_M\u2082 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2082.Coloop p) :=\n  (hp \u25b8 assumptions.M\u2082sep <| Matroid.separator_coloop \u00b7)\n\nend PropertiesAssumptions\n\n\nsection PropertiesGroundSet\n\n/-- Ground set of 2-sum is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma twoSumGround_disjoint_inter (M\u2081 M\u2082 : Matroid \u03b1) :\n    twoSumGround M\u2081 M\u2082 \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  Set.disjoint_sdiff_left\n\n/-- Ground sets minus their intersection are disjoint sets -/\nlemma twoSum_disjoint_grounds_diff_inter (M\u2081 M\u2082 : Matroid \u03b1) :\n    M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) \u2ad7 M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E) := by\n  rw [Set.diff_self_inter, Set.diff_inter_self_eq_diff]\n  exact disjoint_sdiff_sdiff\n\nend PropertiesGroundSet\n\n\nsection PropertiesCircuitType1\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1} {C : Set \u03b1}\n\n/-- Circuit of type 1 is a circuit in `M\u2081` -/\nlemma TwoSumCircuitType1.circuit_M\u2081 (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : M\u2081.Circuit C :=\n  hC.left\n\n/-- Circuit of type 1 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType1.disjoint_inter (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of type 1 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma TwoSumCircuitType1.subset_union (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_left hC.circuit_M\u2081.subset_ground M\u2082.E\n\n/-- Circuit of type 1 lies in ground set of `M\u2081 \u2295\u2082 M\u2082` -/\nlemma TwoSumCircuitType1.subset_ground (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 twoSumGround M\u2081 M\u2082 :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 1 lies in `M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma TwoSumCircuitType1.subset_M\u2081_diff_inter (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2081.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 1 is disjoint with `M\u2082.E` -/\nlemma TwoSumCircuitType1.disjoint_M\u2082 (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2ad7 M\u2082.E := by\n  have hMM := twoSum_disjoint_grounds_diff_inter M\u2081 M\u2082\n  have hCM\u2082 := Set.disjoint_of_subset_left hC.subset_M\u2081_diff_inter hMM\n  have hCM\u2082 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2082, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_right] at hCM\u2082\n  exact hCM\u2082\n\nend PropertiesCircuitType1\n\n\nsection PropertiesCircuitType2\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1} {C : Set \u03b1}\n\n/-- Circuit of type 2 is a circuit in `M\u2082` -/\nlemma TwoSumCircuitType2.circuit_M\u2082 (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : M\u2082.Circuit C :=\n  hC.left\n\n/-- Circuit of type 2 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType2.disjoint_inter (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of type 2 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma TwoSumCircuitType2.subset_union (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_right hC.circuit_M\u2082.subset_ground M\u2081.E\n\n/-- Circuit of type 2 lies in ground set of `M\u2081 \u2295\u2082 M\u2082` -/\nlemma TwoSumCircuitType2.subset_ground (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2286 twoSumGround M\u2081 M\u2082 :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 2 lies in `M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma TwoSumCircuitType2.subset_M\u2082_diff_inter (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2286 M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2082.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 2 is disjoint with `M\u2081.E` -/\nlemma TwoSumCircuitType2.disjoint_M\u2081 (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E := by\n  have hMM := twoSum_disjoint_grounds_diff_inter M\u2081 M\u2082\n  have hCM\u2081 := (Set.disjoint_of_subset_right hC.subset_M\u2082_diff_inter hMM).symm\n  have hCM\u2081 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2081, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_left] at hCM\u2081\n  exact hCM\u2081\n\nend PropertiesCircuitType2\n\n\nsection PropertiesCircuitType3\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1} {C : Set \u03b1}\n\n/-- Circuit of type 3 yields a circuit in `M\u2081` after intersecting it with `M\u2081.E` and adding `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType3.to_circuit_M\u2081 (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : M\u2081.Circuit ((C \u2229 M\u2081.E) \u222a (M\u2081.E \u2229 M\u2082.E)) :=\n  hC.left\n\n/-- Circuit of type 3 yields a circuit in `M\u2082` after intersecting it with `M\u2081.E` and adding `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType3.to_circuit_M\u2082 (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : M\u2082.Circuit ((C \u2229 M\u2082.E) \u222a (M\u2081.E \u2229 M\u2082.E)) :=\n  hC.right.left\n\n/-- Circuit of type 3 is subset of ground set of `M\u2081 \u2295\u2082 M\u2082` -/\ndef TwoSumCircuitType3.subset_ground (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2286 twoSumGround M\u2081 M\u2082 :=\n  hC.right.right\n\n/-- Circuit of type 3 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma TwoSumCircuitType3.subset_union (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \u222a M\u2082.E :=\n  sub_union_diff_sub_union hC.subset_ground\n\n/-- Circuit of type 3 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType3.disjoint_inter (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  Set.disjoint_of_subset_left hC.subset_ground (twoSumGround_disjoint_inter M\u2081 M\u2082)\n\n/-- Circuit of type 3 intersected with `M\u2081.E` is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType3.disjoint_inter_M\u2081_inter (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2229 M\u2081.E \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.disjoint_inter.inter_left M\u2081.E\n\n/-- Circuit of type 3 intersected with `M\u2082.E` is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType3.disjoint_inter_M\u2082_inter (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2229 M\u2082.E \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.disjoint_inter.inter_left M\u2082.E\n\n/-- Circuit of type 3 has nonempty intersection with `M\u2081.E` -/\nlemma TwoSumCircuitType3.inter_M\u2081_nonempty (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (C \u2229 M\u2081.E).Nonempty := by\n  by_contra! hCM\u2081\n  have hM\u2081 := hC.to_circuit_M\u2081\n  have \u27e8p, hp\u27e9 := assumptions.inter_singleton\n  rw [hCM\u2081, Set.empty_union, hp, \u2190Matroid.loop_iff_circuit M\u2081] at hM\u2081\n  have hpM\u2081 := assumptions.inter_singleton_not_loop_M\u2081 hp\n  exact hpM\u2081 hM\u2081\n\n/-- Circuit of type 3 has nonempty intersection with `M\u2082.E` -/\nlemma TwoSumCircuitType3.inter_M\u2082_nonempty (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (C \u2229 M\u2082.E).Nonempty := by\n  by_contra! hCM\u2082empty\n  have hCM\u2082 := hC.to_circuit_M\u2082\n  have \u27e8p, hp\u27e9 := assumptions.inter_singleton\n  rw [hCM\u2082empty, Set.empty_union, hp, \u2190Matroid.loop_iff_circuit M\u2082] at hCM\u2082\n  exact assumptions.inter_singleton_not_loop_M\u2082 hp hCM\u2082\n\nend PropertiesCircuitType3\n\n\nsection PropertiesCircuitTypePairs1\n\n/-- Circuit of type 1 is not a strict subset of any circuit of type 1 -/\nlemma TwoSumCircuitType1.not_ssubset_circuit_type_1 {M\u2081 M\u2082 : Matroid \u03b1} {C C' : Set \u03b1}\n    (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) (hC' : TwoSumCircuitType1 M\u2081 M\u2082 C') :\n    \u00ac(C \u2282 C') :=\n  hC.circuit_M\u2081.not_ssubset_circuit hC'.circuit_M\u2081\n\n/-- Circuit of type 1 is disjoint with any circuit of type 2 -/\nlemma TwoSumCircuitType1.disjoint_circuit_type_2 {M\u2081 M\u2082 : Matroid \u03b1} {C\u2081 C\u2082 : Set \u03b1}\n    (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) :\n    C\u2081 \u2ad7 C\u2082 := by\n  have hC\u2081M\u2081 := hC\u2081.subset_M\u2081_diff_inter\n  have hC\u2082M\u2082 := hC\u2082.subset_M\u2082_diff_inter\n  have hMM := twoSum_disjoint_grounds_diff_inter M\u2081 M\u2082\n  exact Set.disjoint_of_subset hC\u2081M\u2081 hC\u2082M\u2082 hMM\n\n/-- Circuit of type 1 is not a strict subset of any circuit of type 2 -/\nlemma TwoSumCircuitType1.not_ssubset_circuit_type_2 {M\u2081 M\u2082 : Matroid \u03b1} {C\u2081 C\u2082 : Set \u03b1}\n    (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) :\n    \u00ac(C\u2081 \u2282 C\u2082) :=\n  disjoint_nonempty_not_ssubset (hC\u2081.disjoint_circuit_type_2 hC\u2082) hC\u2081.circuit_M\u2081.nonempty\n\n/-- Circuit of type 1 is not a strict subset of any circuit of type 3 -/\nlemma TwoSumCircuitType1.not_ssubset_circuit_type_3 {M\u2081 M\u2082 : Matroid \u03b1} {C\u2081 C\u2083 : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) (hC\u2083 : TwoSumCircuitType3 M\u2081 M\u2082 C\u2083) :\n    \u00ac(C\u2081 \u2282 C\u2083) :=\n  fun hCC =>\n    hC\u2081.circuit_M\u2081.not_ssubset_circuit hC\u2083.to_circuit_M\u2081\n      (Set.ssubset_of_ssubset_of_subset (ssubset_union_disjoint_nonempty hC\u2081.disjoint_inter assumptions.inter_nonempty)\n        (Set.union_subset_union_left (M\u2081.E \u2229 M\u2082.E) (Set.subset_inter hCC.left hC\u2081.circuit_M\u2081.subset_ground)))\n\n/-- Circuit of type 1 is not a strict subset of any other circuit -/\nlemma TwoSumCircuitType1.not_ssubset_circuit {M\u2081 M\u2082 : Matroid \u03b1} {C\u2081 C : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) (hC : TwoSumCircuitPred M\u2081 M\u2082 C) :\n    \u00ac(C\u2081 \u2282 C) := by\n  cases hC with\n  | inl hC => exact hC\u2081.not_ssubset_circuit_type_1 hC\n  | inr hC => cases hC with\n    | inl hC => exact hC\u2081.not_ssubset_circuit_type_2 hC\n    | inr hC => exact hC\u2081.not_ssubset_circuit_type_3 assumptions hC\n\nend PropertiesCircuitTypePairs1\n\n\nsection PropertiesCircuitTypePairs2\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1}\n\n/-- Circuits of type 2 are disjoint with circuits of type 1 -/\nlemma TwoSumCircuitType2.disjoint_circuitType1 {C\u2081 C\u2082 : Set \u03b1}\n    (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) :\n    C\u2082 \u2ad7 C\u2081 :=\n  (hC\u2081.disjoint_circuit_type_2 hC\u2082).symm\n\n/-- Circuit of type 2 is not a strict subset of any circuit of type 1 -/\nlemma TwoSumCircuitType2.not_ssubset_circuitType1 {C\u2081 C\u2082 : Set \u03b1}\n    (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) :\n    \u00ac(C\u2082 \u2282 C\u2081) :=\n  disjoint_nonempty_not_ssubset (hC\u2082.disjoint_circuitType1 hC\u2081) hC\u2082.circuit_M\u2082.nonempty\n\n/-- Circuit of type 2 is not a strict subset of any circuit of type 2 -/\nlemma TwoSumCircuitType2.not_ssubset_circuitType2 {C C' : Set \u03b1}\n    (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) (hC' : TwoSumCircuitType2 M\u2081 M\u2082 C') :\n    \u00ac(C \u2282 C') :=\n  hC.circuit_M\u2082.not_ssubset_circuit hC'.circuit_M\u2082\n\n/-- Circuit of type 2 is not a strict subset of any circuit of type 3 -/\nlemma TwoSumAssumptions.circuitType2_not_ssubset_circuitType3 {C\u2082 C\u2083 : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) (hC\u2083 : TwoSumCircuitType3 M\u2081 M\u2082 C\u2083) :\n    \u00ac(C\u2082 \u2282 C\u2083) :=\n  fun hCC =>\n    hC\u2082.circuit_M\u2082.not_ssubset_circuit hC\u2083.to_circuit_M\u2082\n      (Set.ssubset_of_ssubset_of_subset (ssubset_union_disjoint_nonempty hC\u2082.disjoint_inter assumptions.inter_nonempty)\n        (Set.union_subset_union_left (M\u2081.E \u2229 M\u2082.E) (Set.subset_inter hCC.left hC\u2082.circuit_M\u2082.subset_ground)))\n\n/-- Circuit of type 2 is not a strict subset of any other circuit -/\nlemma TwoSumAssumptions.circuitType2_not_ssubset {C\u2082 C : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) (hC : TwoSumCircuitPred M\u2081 M\u2082 C) :\n    \u00ac(C\u2082 \u2282 C) := by\n  cases hC with\n  | inl hC => exact hC\u2082.not_ssubset_circuitType1 hC\n  | inr hC => cases hC with\n    | inl hC => exact hC\u2082.not_ssubset_circuitType2 hC\n    | inr hC => exact assumptions.circuitType2_not_ssubset_circuitType3 hC\u2082 hC\n\nend PropertiesCircuitTypePairs2\n\n\nsection PropertiesCircuitTypePairs3\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1}\n\n/-- Circuit of type 3 is not a strict subset of any circuit of type 1 -/\nlemma TwoSumAssumptions.circuitType3_not_ssubset_circuitType1 {C\u2081 C\u2083 : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2083 : TwoSumCircuitType3 M\u2081 M\u2082 C\u2083) (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) :\n    \u00ac(C\u2083 \u2282 C\u2081) :=\n  nonempty_inter_not_ssubset_empty_inter (hC\u2083.inter_M\u2082_nonempty assumptions) hC\u2081.disjoint_M\u2082.inter_eq\n\n/-- Circuit of type 3 is not a strict subset of any circuit of type 2 -/\nlemma TwoSumAssumptions.circuitType3_not_ssubset_circuitType2 {C\u2082 C\u2083 : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2083 : TwoSumCircuitType3 M\u2081 M\u2082 C\u2083) (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) :\n    \u00ac(C\u2083 \u2282 C\u2082) :=\n  nonempty_inter_not_ssubset_empty_inter (hC\u2083.inter_M\u2081_nonempty assumptions) hC\u2082.disjoint_M\u2081.inter_eq\n\n/-- Circuit of type 3 is not a strict subset of any circuit of type 3 -/\nlemma TwoSumCircuitType3.not_ssubset_circuitType3 {C C' : Set \u03b1}\n    (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) (hC' : TwoSumCircuitType3 M\u2081 M\u2082 C') :\n    \u00ac(C \u2282 C') := by\n  intro \u27e8hCC', hnCC'\u27e9\n  have M\u2081_circ_nssub := Set.ssubset_def \u25b8 hC.to_circuit_M\u2081.not_ssubset_circuit hC'.to_circuit_M\u2081\n  have M\u2082_circ_nssub := Set.ssubset_def \u25b8 hC.to_circuit_M\u2082.not_ssubset_circuit hC'.to_circuit_M\u2082\n  push_neg at M\u2081_circ_nssub\n  push_neg at M\u2082_circ_nssub\n  have M\u2081_circ_sub := (union_subset_union_iff hC'.disjoint_inter_M\u2081_inter hC.disjoint_inter_M\u2081_inter).\u2192\n    (M\u2081_circ_nssub (Set.union_subset_union_left (M\u2081.E \u2229 M\u2082.E) (Set.inter_subset_inter_left M\u2081.E hCC')))\n  have M\u2082_circ_sub := (union_subset_union_iff hC'.disjoint_inter_M\u2082_inter hC.disjoint_inter_M\u2082_inter).\u2192\n    (M\u2082_circ_nssub (Set.union_subset_union_left (M\u2081.E \u2229 M\u2082.E) (Set.inter_subset_inter_left M\u2082.E hCC')))\n  exact hnCC' (hC.subset_union.parts_eq \u25b8 hC'.subset_union.parts_eq \u25b8 Set.union_subset_union M\u2081_circ_sub M\u2082_circ_sub)\n\n/-- Circuit of type 3 is not a strict subset of any other circuit -/\nlemma TwoSumAssumptions.circuitType3_not_ssubset_circuit {C\u2083 C : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2083 : TwoSumCircuitType3 M\u2081 M\u2082 C\u2083) (hC : TwoSumCircuitPred M\u2081 M\u2082 C) :\n    \u00ac(C\u2083 \u2282 C) := by\n  cases hC with\n  | inl hC => exact assumptions.circuitType3_not_ssubset_circuitType1 hC\u2083 hC\n  | inr hC => cases hC with\n    | inl hC => exact assumptions.circuitType3_not_ssubset_circuitType2 hC\u2083 hC\n    | inr hC => exact hC\u2083.not_ssubset_circuitType3 hC\n\nend PropertiesCircuitTypePairs3\n\n\nsection PropertiesCircuitPred\n\n/-- In definition of 2-sum, empty set is not a circuit -/\nlemma TwoSumAssumptions.twoSumCircuitPred_notCircuitEmpty {M\u2081 M\u2082 : Matroid \u03b1} (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (TwoSumCircuitPred M\u2081 M\u2082).NotCircuitEmpty := by\n  unfold CircuitPredicate.NotCircuitEmpty TwoSumCircuitPred\n  push_neg\n  refine \u27e8(\u00b7.circuit_M\u2081.nonempty.ne_empty rfl), (\u00b7.circuit_M\u2082.nonempty.ne_empty rfl), fun \u27e8hpM\u2081, hpM\u2082, hE\u27e9 => ?_\u27e9\n  have \u27e8p, hp\u27e9 := assumptions.inter_singleton\n  rw [Set.empty_inter, Set.empty_union, hp, \u2190Matroid.loop_iff_circuit M\u2081] at hpM\u2081\n  exact (hp \u25b8 assumptions.M\u2081sep) (Matroid.separator_loop hpM\u2081)\n\n", "theoremStatement": "/-- In definition of 2-sum, no circuit is a strict subset of another -/\nlemma TwoSumAssumptions.twoSumCircuitPred_circuitNotSsubset {M\u2081 M\u2082 : Matroid \u03b1} (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (TwoSumCircuitPred M\u2081 M\u2082).CircuitNotSsubset ", "theoremName": "TwoSumAssumptions.twoSumCircuitPred_circuitNotSsubset", "fileCreated": {"commit": "d0eaaa305c96cd81ac061f505a81614db6856b21", "date": "2025-01-09"}, "theoremCreated": {"commit": "43c746e51146ac13aa709eefe36b9f185633ea8b", "date": "2025-02-03"}, "file": "Seymour/Seymour/Matroid/Operations/Sum2/Basic.lean", "module": "Seymour.Matroid.Operations.Sum2.Basic", "jsonFile": "Seymour.Matroid.Operations.Sum2.Basic.jsonl", "positionMetadata": {"lineInFile": 404, "tokenPositionInFile": 17827, "theoremPositionInFile": 50}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 8, "repositoryPremises": true, "numRepositoryPremises": 9, "numPremises": 20}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  intro C\u2081 C\u2082 hC\u2081 hC\u2082\n  cases hC\u2082 with\n  | inl hC\u2082 => exact hC\u2082.not_ssubset_circuit assumptions hC\u2081\n  | inr hC\u2082 => cases hC\u2082 with\n    | inl hC\u2082 => exact assumptions.circuitType2_not_ssubset hC\u2082 hC\u2081\n    | inr hC\u2082 => exact assumptions.circuitType3_not_ssubset_circuit hC\u2082 hC\u2081", "proofType": "tactic", "proofLengthLines": 6, "proofLengthTokens": 279}}
{"srcContext": "import Mathlib.Data.Set.SymmDiff\nimport Mathlib.Order.CompletePartialOrder\nimport Mathlib.Order.Disjoint\nimport Mathlib.Order.SymmDiff\nimport Mathlib.Tactic\n\nimport Seymour.Basic\n\n/-!\nThis provides lemmas about sets (mostly dealing with disjointness) that are missing in Mathlib.\n-/\n\nvariable {\u03b1 : Type}\n\nsection Other\n\nlemma set_union_union_eq_rev (X Y Z : Set \u03b1) : X \u222a Y \u222a Z = Z \u222a Y \u222a X := by\n  rw [Set.union_assoc, Set.union_comm, Set.union_comm Y Z]\n\nlemma setminus_inter_union_eq_union {X Y : Set \u03b1} : X \\ (X \u2229 Y) \u222a Y = X \u222a Y := by\n  tauto_set\n\nlemma nonempty_inter_not_ssubset_empty_inter {A B E : Set \u03b1} (hA : (A \u2229 E).Nonempty) (hB : B \u2229 E = \u2205) :\n    \u00ac(A \u2282 B) := by\n  intro \u27e8hAB, _\u27e9\n  obtain \u27e8x, hxAE\u27e9 := hA\n  have hxBE : x \u2208 B \u2229 E := (Set.inter_subset_inter hAB fun _ => id) hxAE\n  rw [hB] at hxBE\n  tauto\n\nlemma ssubset_self_union_other_elem {a : \u03b1} {X : Set \u03b1} (ha : a \u2209 X) :\n    X \u2282 X \u222a {a} := by\n  constructor\n  \u00b7 exact Set.subset_union_left\n  \u00b7 by_contra hX\n    rw [Set.union_subset_iff] at hX\n    obtain \u27e8_, haa\u27e9 := hX\n    tauto\n\nlemma singleton_union_ssubset_union_iff {a : \u03b1} {A B : Set \u03b1} (haA : a \u2209 A) (haB : a \u2209 B) :\n    A \u222a {a} \u2282 B \u222a {a} \u2194 A \u2282 B := by\n  constructor\n  \u00b7 intro hAB\n    obtain \u27e8hABl, hABr\u27e9 := hAB\n    constructor\n    \u00b7 intro x hx\n      apply ne_of_mem_of_not_mem hx at haA\n      cases hABl (Set.mem_union_left {a} hx) <;> tauto\n    \u00b7 by_contra hBA\n      apply Set.union_subset_union_left {a} at hBA\n      tauto\n  \u00b7 intro hAB\n    obtain \u27e8hABl, hABr\u27e9 := hAB\n    constructor\n    \u00b7 exact Set.union_subset_union_left {a} hABl\n    \u00b7 by_contra hBA\n      rw [Set.union_singleton, Set.union_singleton] at hBA\n      apply (Set.insert_subset_insert_iff haB).\u2192 at hBA\n      tauto\n\nlemma ssub_parts_ssub {A B E\u2081 E\u2082 : Set \u03b1}\n    (hA : A \u2286 E\u2081 \u222a E\u2082) (hB : B \u2286 E\u2081 \u222a E\u2082) (hAB\u2081 : A \u2229 E\u2081 \u2282 B \u2229 E\u2081) (hAB\u2082 : A \u2229 E\u2082 \u2282 B \u2229 E\u2082) :\n    A \u2282 B := by\n  constructor\n  \u00b7 obtain \u27e8hE\u2081, _\u27e9 := hAB\u2081\n    obtain \u27e8hE\u2082, _\u27e9 := hAB\u2082\n    rw [Set.left_eq_inter.\u2190 hA, Set.left_eq_inter.\u2190 hB, Set.inter_union_distrib_left, Set.inter_union_distrib_left]\n    exact Set.union_subset_union hE\u2081 hE\u2082\n  \u00b7 intro hBA\n    obtain \u27e8_, hE\u2081\u27e9 := hAB\u2081\n    obtain \u27e8x, hxBE\u2081, hxnAE\u2081\u27e9 := Set.not_subset.\u2192 hE\u2081\n    have hxB : x \u2208 B := Set.mem_of_mem_inter_left hxBE\u2081\n    have hxE\u2081 : x \u2208 E\u2081 := Set.mem_of_mem_inter_right hxBE\u2081\n    tauto\n\nlemma HasSubset.Subset.parts_eq {A E\u2081 E\u2082 : Set \u03b1} (hA : A \u2286 E\u2081 \u222a E\u2082) : (A \u2229 E\u2081) \u222a (A \u2229 E\u2082) = A :=\n  ((subset_of_subset_of_eq\n    (Set.subset_inter (fun _ => id) hA)\n    (Set.inter_union_distrib_left A E\u2081 E\u2082)).antisymm\n  (Set.union_subset Set.inter_subset_left Set.inter_subset_left)).symm\n\nlemma elem_notin_set_minus_singleton (a : \u03b1) (X : Set \u03b1) : a \u2209 X \\ {a} := Set.not_mem_diff_of_mem rfl\n\nlemma sub_union_diff_sub_union {A B C : Set \u03b1} (hA : A \u2286 B \\ C) : A \u2286 B :=\n  fun _ hA' => Set.diff_subset (hA hA')\n\nlemma singleton_inter_in_left {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : a \u2208 X :=\n  Set.mem_of_mem_inter_left (ha.symm.subset rfl)\n\nlemma singleton_inter_in_right {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : a \u2208 Y :=\n  Set.mem_of_mem_inter_right (ha.symm.subset rfl)\n\nlemma singleton_inter_subset_left {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : {a} \u2286 X := by\n  rw [Set.singleton_subset_iff]\n  exact singleton_inter_in_left ha\n\nlemma singleton_inter_subset_right {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : {a} \u2286 Y := by\n  rw [Set.singleton_subset_iff]\n  exact singleton_inter_in_right ha\n\n/-- Being a subset is preserved under subtracting sets. -/\nlemma diff_subset_parent {X\u2081 X\u2082 E : Set \u03b1} (hX\u2081E : X\u2081 \u2286 E) :\n    X\u2081 \\ X\u2082 \u2286 E :=\n  Set.diff_subset_iff.\u2190 (Set.subset_union_of_subset_right hX\u2081E X\u2082)\n\n/-- Being a subset is preserved under taking intersections. -/\nlemma inter_subset_parent_left {X\u2081 X\u2082 E : Set \u03b1} (hX\u2081E : X\u2081 \u2286 E) :\n    X\u2081 \u2229 X\u2082 \u2286 E :=\n  (Set.inter_subset_inter_left X\u2082 hX\u2081E).trans Set.inter_subset_left\n\n", "theoremStatement": "/-- Being a subset is preserved under taking intersections. -/\nlemma inter_subset_parent_right {X\u2081 X\u2082 E : Set \u03b1} (hX\u2082E : X\u2082 \u2286 E) :\n    X\u2081 \u2229 X\u2082 \u2286 E ", "theoremName": "inter_subset_parent_right", "fileCreated": {"commit": "b44bff2f1ee71349fa9fa251579a0f5a0e575538", "date": "2024-12-19"}, "theoremCreated": {"commit": "4d9233309fad6a3c9d3d0d88dcfa6420fcb14dcb", "date": "2024-12-18"}, "file": "Seymour/Seymour/ForMathlib/SetTheory.lean", "module": "Seymour.ForMathlib.SetTheory", "jsonFile": "Seymour.ForMathlib.SetTheory.jsonl", "positionMetadata": {"lineInFile": 111, "tokenPositionInFile": 3824, "theoremPositionInFile": 15}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 1, "numPremises": 11}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [Set.inter_comm]\n  exact inter_subset_parent_left hX\u2082E", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 65}}
{"srcContext": "import Mathlib.Data.Set.Card\nimport Mathlib.Data.Matroid.Dual\n\nimport Seymour.ForMathlib.SetTheory\nimport Seymour.Matroid.Notions.Circuit\nimport Seymour.Matroid.Notions.CircuitAxioms\nimport Seymour.Matroid.Notions.Connectivity\nimport Seymour.Matroid.Constructors.CircuitMatroid\n\n/-!\nThis file defines 2-sum of two (general) matroids `M\u2081` and `M\u2082`, denoted as `M\u2081 \u2295\u2082 M\u2082`.\n-/\n\nvariable {\u03b1 : Type}\n\n\nsection MainDefinitions\n\n/-- `M\u2081 \u2295\u2082 M\u2082` is defined if `M\u2081` and `M\u2082` satisfy the following assumptions -/\nstructure TwoSumAssumptions (M\u2081 M\u2082 : Matroid \u03b1) : Prop where\n  /-- `M\u2081` is finite -/\n  M\u2081fin : M\u2081.Finite\n  /-- `M\u2082` is finite -/\n  M\u2082fin : M\u2082.Finite\n  /-- `M\u2081` contains at least 2 elements -/\n  M\u2081card : M\u2081.E.encard \u2265 2\n  /-- `M\u2082` contains at least 2 elements -/\n  M\u2082card : M\u2082.E.encard \u2265 2\n  /-- `M\u2081` and `M\u2082` have exactly one element in common -/\n  interSingleton : (M\u2081.E \u2229 M\u2082.E).encard = 1\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2081` -/\n  M\u2081sep : \u00acM\u2081.Separator (M\u2081.E \u2229 M\u2082.E)\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2082` -/\n  M\u2082sep : \u00acM\u2082.Separator (M\u2081.E \u2229 M\u2082.E)\n\n-- question: can avoid this assumption? -- which assumption? the finiteness?\n\n/-- Ground set of `M\u2081 \u2295\u2082 M\u2082` -/\ndef twoSumGround (M\u2081 M\u2082 : Matroid \u03b1) : Set \u03b1 :=\n  (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)\n\n/-- Type 1 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2081` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType1 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 2 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2082` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType2 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2082.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 3 of circuits in `M\u2081 \u2295\u2082 M\u2082`:\n    sets `(C\u2081 \u222a C\u2082) \\ (M\u2081.E \u2229 M\u2082.E)` where `C\u2081` and `C\u2082` are circuits in `M\u2081` and `M\u2082`, respectively,\n    and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2081` and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2082` -/\ndef TwoSumCircuitType3 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit ((C \u2229 M\u2081.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 M\u2082.Circuit ((C \u2229 M\u2082.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 C \u2286 twoSumGround M\u2081 M\u2082\n\n/-- Circuit predicate of `M\u2081 \u2295\u2082 M\u2082`, which defines 2-sum as `CircuitMatroid` -/\ndef TwoSumCircuitPred (M\u2081 M\u2082 : Matroid \u03b1) : CircuitPredicate \u03b1 :=\n  fun C : Set \u03b1 =>\n    TwoSumCircuitType1 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType2 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType3 M\u2081 M\u2082 C\n\nend MainDefinitions\n\n\nsection PropertiesAssumptions\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1}\n\n/-- 2-sum assumptions are symmetric -/\nlemma TwoSumAssumptions.symm (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    TwoSumAssumptions M\u2082 M\u2081 :=\n  \u27e8\n    assumptions.M\u2082fin,\n    assumptions.M\u2081fin,\n    assumptions.M\u2082card,\n    assumptions.M\u2081card,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.interSingleton,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2082sep,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2081sep,\n  \u27e9\n\n/-- Intersection of ground sets is nonempty -/\nlemma TwoSumAssumptions.inter_nonempty (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (M\u2081.E \u2229 M\u2082.E).Nonempty :=\n  Set.one_le_encard_iff_nonempty.\u2192 assumptions.interSingleton.symm.le\n\n/-- Intersection of ground sets is a singleton set -/\nlemma TwoSumAssumptions.inter_singleton (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    \u2203 p : \u03b1, M\u2081.E \u2229 M\u2082.E = {p} :=\n  Set.encard_eq_one.\u2192 assumptions.interSingleton\n\nvariable {p : \u03b1}\n\n/-- Singleton element in intersection of ground sets in not a loop in `M\u2081` -/\nlemma TwoSumAssumptions.inter_singleton_not_loop_M\u2081 (assumptions : TwoSumAssumptions M\u2081 M\u2082)\n    (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2081.Loop p) :=\n  (hp \u25b8 assumptions.M\u2081sep <| Matroid.separator_loop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a coloop in `M\u2081` -/\nlemma TwoSumAssumptions.inter_singleton_not_coloop_M\u2081 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2081.Coloop p) :=\n  (hp \u25b8 assumptions.M\u2081sep <| Matroid.separator_coloop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a loop in `M\u2082` -/\nlemma TwoSumAssumptions.inter_singleton_not_loop_M\u2082 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2082.Loop p) :=\n  (hp \u25b8 assumptions.M\u2082sep <| Matroid.separator_loop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a coloop in `M\u2082` -/\nlemma TwoSumAssumptions.inter_singleton_not_coloop_M\u2082 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2082.Coloop p) :=\n  (hp \u25b8 assumptions.M\u2082sep <| Matroid.separator_coloop \u00b7)\n\nend PropertiesAssumptions\n\n\nsection PropertiesGroundSet\n\n/-- Ground set of 2-sum is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma twoSumGround_disjoint_inter (M\u2081 M\u2082 : Matroid \u03b1) :\n    twoSumGround M\u2081 M\u2082 \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  Set.disjoint_sdiff_left\n\n/-- Ground sets minus their intersection are disjoint sets -/\nlemma twoSum_disjoint_grounds_diff_inter (M\u2081 M\u2082 : Matroid \u03b1) :\n    M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) \u2ad7 M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E) := by\n  rw [Set.diff_self_inter, Set.diff_inter_self_eq_diff]\n  exact disjoint_sdiff_sdiff\n\nend PropertiesGroundSet\n\n\nsection PropertiesCircuitType1\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1} {C : Set \u03b1}\n\n/-- Circuit of type 1 is a circuit in `M\u2081` -/\nlemma TwoSumCircuitType1.circuit_M\u2081 (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : M\u2081.Circuit C :=\n  hC.left\n\n/-- Circuit of type 1 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType1.disjoint_inter (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of type 1 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma TwoSumCircuitType1.subset_union (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_left hC.circuit_M\u2081.subset_ground M\u2082.E\n\n/-- Circuit of type 1 lies in ground set of `M\u2081 \u2295\u2082 M\u2082` -/\nlemma TwoSumCircuitType1.subset_ground (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 twoSumGround M\u2081 M\u2082 :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 1 lies in `M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma TwoSumCircuitType1.subset_M\u2081_diff_inter (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2081.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 1 is disjoint with `M\u2082.E` -/\nlemma TwoSumCircuitType1.disjoint_M\u2082 (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2ad7 M\u2082.E := by\n  have hMM := twoSum_disjoint_grounds_diff_inter M\u2081 M\u2082\n  have hCM\u2082 := Set.disjoint_of_subset_left hC.subset_M\u2081_diff_inter hMM\n  have hCM\u2082 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2082, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_right] at hCM\u2082\n  exact hCM\u2082\n\nend PropertiesCircuitType1\n\n\nsection PropertiesCircuitType2\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1} {C : Set \u03b1}\n\n/-- Circuit of type 2 is a circuit in `M\u2082` -/\nlemma TwoSumCircuitType2.circuit_M\u2082 (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : M\u2082.Circuit C :=\n  hC.left\n\n/-- Circuit of type 2 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType2.disjoint_inter (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of type 2 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma TwoSumCircuitType2.subset_union (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_right hC.circuit_M\u2082.subset_ground M\u2081.E\n\n/-- Circuit of type 2 lies in ground set of `M\u2081 \u2295\u2082 M\u2082` -/\nlemma TwoSumCircuitType2.subset_ground (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2286 twoSumGround M\u2081 M\u2082 :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 2 lies in `M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma TwoSumCircuitType2.subset_M\u2082_diff_inter (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2286 M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2082.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 2 is disjoint with `M\u2081.E` -/\nlemma TwoSumCircuitType2.disjoint_M\u2081 (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E := by\n  have hMM := twoSum_disjoint_grounds_diff_inter M\u2081 M\u2082\n  have hCM\u2081 := (Set.disjoint_of_subset_right hC.subset_M\u2082_diff_inter hMM).symm\n  have hCM\u2081 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2081, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_left] at hCM\u2081\n  exact hCM\u2081\n\nend PropertiesCircuitType2\n\n\nsection PropertiesCircuitType3\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1} {C : Set \u03b1}\n\n/-- Circuit of type 3 yields a circuit in `M\u2081` after intersecting it with `M\u2081.E` and adding `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType3.to_circuit_M\u2081 (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : M\u2081.Circuit ((C \u2229 M\u2081.E) \u222a (M\u2081.E \u2229 M\u2082.E)) :=\n  hC.left\n\n/-- Circuit of type 3 yields a circuit in `M\u2082` after intersecting it with `M\u2081.E` and adding `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType3.to_circuit_M\u2082 (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : M\u2082.Circuit ((C \u2229 M\u2082.E) \u222a (M\u2081.E \u2229 M\u2082.E)) :=\n  hC.right.left\n\n/-- Circuit of type 3 is subset of ground set of `M\u2081 \u2295\u2082 M\u2082` -/\ndef TwoSumCircuitType3.subset_ground (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2286 twoSumGround M\u2081 M\u2082 :=\n  hC.right.right\n\n/-- Circuit of type 3 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma TwoSumCircuitType3.subset_union (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \u222a M\u2082.E :=\n  sub_union_diff_sub_union hC.subset_ground\n\n/-- Circuit of type 3 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType3.disjoint_inter (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  Set.disjoint_of_subset_left hC.subset_ground (twoSumGround_disjoint_inter M\u2081 M\u2082)\n\n/-- Circuit of type 3 intersected with `M\u2081.E` is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType3.disjoint_inter_M\u2081_inter (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2229 M\u2081.E \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.disjoint_inter.inter_left M\u2081.E\n\n/-- Circuit of type 3 intersected with `M\u2082.E` is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType3.disjoint_inter_M\u2082_inter (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2229 M\u2082.E \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.disjoint_inter.inter_left M\u2082.E\n\n/-- Circuit of type 3 has nonempty intersection with `M\u2081.E` -/\nlemma TwoSumCircuitType3.inter_M\u2081_nonempty (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (C \u2229 M\u2081.E).Nonempty := by\n  by_contra! hCM\u2081\n  have hM\u2081 := hC.to_circuit_M\u2081\n  have \u27e8p, hp\u27e9 := assumptions.inter_singleton\n  rw [hCM\u2081, Set.empty_union, hp, \u2190Matroid.loop_iff_circuit M\u2081] at hM\u2081\n  have hpM\u2081 := assumptions.inter_singleton_not_loop_M\u2081 hp\n  exact hpM\u2081 hM\u2081\n\n/-- Circuit of type 3 has nonempty intersection with `M\u2082.E` -/\nlemma TwoSumCircuitType3.inter_M\u2082_nonempty (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (C \u2229 M\u2082.E).Nonempty := by\n  by_contra! hCM\u2082empty\n  have hCM\u2082 := hC.to_circuit_M\u2082\n  have \u27e8p, hp\u27e9 := assumptions.inter_singleton\n  rw [hCM\u2082empty, Set.empty_union, hp, \u2190Matroid.loop_iff_circuit M\u2082] at hCM\u2082\n  exact assumptions.inter_singleton_not_loop_M\u2082 hp hCM\u2082\n\nend PropertiesCircuitType3\n\n\nsection PropertiesCircuitTypePairs1\n\n/-- Circuit of type 1 is not a strict subset of any circuit of type 1 -/\nlemma TwoSumCircuitType1.not_ssubset_circuit_type_1 {M\u2081 M\u2082 : Matroid \u03b1} {C C' : Set \u03b1}\n    (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) (hC' : TwoSumCircuitType1 M\u2081 M\u2082 C') :\n    \u00ac(C \u2282 C') :=\n  hC.circuit_M\u2081.not_ssubset_circuit hC'.circuit_M\u2081\n\n/-- Circuit of type 1 is disjoint with any circuit of type 2 -/\nlemma TwoSumCircuitType1.disjoint_circuit_type_2 {M\u2081 M\u2082 : Matroid \u03b1} {C\u2081 C\u2082 : Set \u03b1}\n    (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) :\n    C\u2081 \u2ad7 C\u2082 := by\n  have hC\u2081M\u2081 := hC\u2081.subset_M\u2081_diff_inter\n  have hC\u2082M\u2082 := hC\u2082.subset_M\u2082_diff_inter\n  have hMM := twoSum_disjoint_grounds_diff_inter M\u2081 M\u2082\n  exact Set.disjoint_of_subset hC\u2081M\u2081 hC\u2082M\u2082 hMM\n\n/-- Circuit of type 1 is not a strict subset of any circuit of type 2 -/\nlemma TwoSumCircuitType1.not_ssubset_circuit_type_2 {M\u2081 M\u2082 : Matroid \u03b1} {C\u2081 C\u2082 : Set \u03b1}\n    (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) :\n    \u00ac(C\u2081 \u2282 C\u2082) :=\n  disjoint_nonempty_not_ssubset (hC\u2081.disjoint_circuit_type_2 hC\u2082) hC\u2081.circuit_M\u2081.nonempty\n\n/-- Circuit of type 1 is not a strict subset of any circuit of type 3 -/\nlemma TwoSumCircuitType1.not_ssubset_circuit_type_3 {M\u2081 M\u2082 : Matroid \u03b1} {C\u2081 C\u2083 : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) (hC\u2083 : TwoSumCircuitType3 M\u2081 M\u2082 C\u2083) :\n    \u00ac(C\u2081 \u2282 C\u2083) :=\n  fun hCC =>\n    hC\u2081.circuit_M\u2081.not_ssubset_circuit hC\u2083.to_circuit_M\u2081\n      (Set.ssubset_of_ssubset_of_subset (ssubset_union_disjoint_nonempty hC\u2081.disjoint_inter assumptions.inter_nonempty)\n        (Set.union_subset_union_left (M\u2081.E \u2229 M\u2082.E) (Set.subset_inter hCC.left hC\u2081.circuit_M\u2081.subset_ground)))\n\n/-- Circuit of type 1 is not a strict subset of any other circuit -/\nlemma TwoSumCircuitType1.not_ssubset_circuit {M\u2081 M\u2082 : Matroid \u03b1} {C\u2081 C : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) (hC : TwoSumCircuitPred M\u2081 M\u2082 C) :\n    \u00ac(C\u2081 \u2282 C) := by\n  cases hC with\n  | inl hC => exact hC\u2081.not_ssubset_circuit_type_1 hC\n  | inr hC => cases hC with\n    | inl hC => exact hC\u2081.not_ssubset_circuit_type_2 hC\n    | inr hC => exact hC\u2081.not_ssubset_circuit_type_3 assumptions hC\n\nend PropertiesCircuitTypePairs1\n\n\nsection PropertiesCircuitTypePairs2\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1}\n\n", "theoremStatement": "/-- Circuits of type 2 are disjoint with circuits of type 1 -/\nlemma TwoSumCircuitType2.disjoint_circuitType1 {C\u2081 C\u2082 : Set \u03b1}\n    (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) :\n    C\u2082 \u2ad7 C\u2081 ", "theoremName": "TwoSumCircuitType2.disjoint_circuitType1", "fileCreated": {"commit": "d0eaaa305c96cd81ac061f505a81614db6856b21", "date": "2025-01-09"}, "theoremCreated": {"commit": "439c72996f29168161b974bc602629cac773728f", "date": "2025-01-08"}, "file": "Seymour/Seymour/Matroid/Operations/Sum2/Basic.lean", "module": "Seymour.Matroid.Operations.Sum2.Basic", "jsonFile": "Seymour.Matroid.Operations.Sum2.Basic.jsonl", "positionMetadata": {"lineInFile": 308, "tokenPositionInFile": 12748, "theoremPositionInFile": 40}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 3, "numPremises": 16}, "proofMetadata": {"hasProof": true, "proof": ":=\n  (hC\u2081.disjoint_circuit_type_2 hC\u2082).symm", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 43}}
{"srcContext": "import Mathlib.Data.Set.Card\nimport Mathlib.Data.Matroid.Dual\n\nimport Seymour.ForMathlib.SetTheory\nimport Seymour.Matroid.Notions.Circuit\nimport Seymour.Matroid.Notions.CircuitAxioms\nimport Seymour.Matroid.Notions.Connectivity\nimport Seymour.Matroid.Constructors.CircuitMatroid\n\n/-!\nThis file defines 2-sum of two (general) matroids `M\u2081` and `M\u2082`, denoted as `M\u2081 \u2295\u2082 M\u2082`.\n-/\n\nvariable {\u03b1 : Type}\n\n\nsection MainDefinitions\n\n/-- `M\u2081 \u2295\u2082 M\u2082` is defined if `M\u2081` and `M\u2082` satisfy the following assumptions -/\nstructure TwoSumAssumptions (M\u2081 M\u2082 : Matroid \u03b1) : Prop where\n  /-- `M\u2081` is finite -/\n  M\u2081fin : M\u2081.Finite\n  /-- `M\u2082` is finite -/\n  M\u2082fin : M\u2082.Finite\n  /-- `M\u2081` contains at least 2 elements -/\n  M\u2081card : M\u2081.E.encard \u2265 2\n  /-- `M\u2082` contains at least 2 elements -/\n  M\u2082card : M\u2082.E.encard \u2265 2\n  /-- `M\u2081` and `M\u2082` have exactly one element in common -/\n  interSingleton : (M\u2081.E \u2229 M\u2082.E).encard = 1\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2081` -/\n  M\u2081sep : \u00acM\u2081.Separator (M\u2081.E \u2229 M\u2082.E)\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2082` -/\n  M\u2082sep : \u00acM\u2082.Separator (M\u2081.E \u2229 M\u2082.E)\n\n-- question: can avoid this assumption? -- which assumption? the finiteness?\n\n/-- Ground set of `M\u2081 \u2295\u2082 M\u2082` -/\ndef twoSumGround (M\u2081 M\u2082 : Matroid \u03b1) : Set \u03b1 :=\n  (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)\n\n/-- Type 1 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2081` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType1 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 2 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2082` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType2 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2082.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 3 of circuits in `M\u2081 \u2295\u2082 M\u2082`:\n    sets `(C\u2081 \u222a C\u2082) \\ (M\u2081.E \u2229 M\u2082.E)` where `C\u2081` and `C\u2082` are circuits in `M\u2081` and `M\u2082`, respectively,\n    and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2081` and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2082` -/\ndef TwoSumCircuitType3 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit ((C \u2229 M\u2081.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 M\u2082.Circuit ((C \u2229 M\u2082.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 C \u2286 twoSumGround M\u2081 M\u2082\n\n/-- Circuit predicate of `M\u2081 \u2295\u2082 M\u2082`, which defines 2-sum as `CircuitMatroid` -/\ndef TwoSumCircuitPred (M\u2081 M\u2082 : Matroid \u03b1) : CircuitPredicate \u03b1 :=\n  fun C : Set \u03b1 =>\n    TwoSumCircuitType1 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType2 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType3 M\u2081 M\u2082 C\n\nend MainDefinitions\n\n\nsection PropertiesAssumptions\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1}\n\n/-- 2-sum assumptions are symmetric -/\nlemma TwoSumAssumptions.symm (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    TwoSumAssumptions M\u2082 M\u2081 :=\n  \u27e8\n    assumptions.M\u2082fin,\n    assumptions.M\u2081fin,\n    assumptions.M\u2082card,\n    assumptions.M\u2081card,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.interSingleton,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2082sep,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2081sep,\n  \u27e9\n\n/-- Intersection of ground sets is nonempty -/\nlemma TwoSumAssumptions.inter_nonempty (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (M\u2081.E \u2229 M\u2082.E).Nonempty :=\n  Set.one_le_encard_iff_nonempty.\u2192 assumptions.interSingleton.symm.le\n\n/-- Intersection of ground sets is a singleton set -/\nlemma TwoSumAssumptions.inter_singleton (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    \u2203 p : \u03b1, M\u2081.E \u2229 M\u2082.E = {p} :=\n  Set.encard_eq_one.\u2192 assumptions.interSingleton\n\nvariable {p : \u03b1}\n\n/-- Singleton element in intersection of ground sets in not a loop in `M\u2081` -/\nlemma TwoSumAssumptions.inter_singleton_not_loop_M\u2081 (assumptions : TwoSumAssumptions M\u2081 M\u2082)\n    (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2081.Loop p) :=\n  (hp \u25b8 assumptions.M\u2081sep <| Matroid.separator_loop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a coloop in `M\u2081` -/\nlemma TwoSumAssumptions.inter_singleton_not_coloop_M\u2081 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2081.Coloop p) :=\n  (hp \u25b8 assumptions.M\u2081sep <| Matroid.separator_coloop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a loop in `M\u2082` -/\nlemma TwoSumAssumptions.inter_singleton_not_loop_M\u2082 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2082.Loop p) :=\n  (hp \u25b8 assumptions.M\u2082sep <| Matroid.separator_loop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a coloop in `M\u2082` -/\nlemma TwoSumAssumptions.inter_singleton_not_coloop_M\u2082 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2082.Coloop p) :=\n  (hp \u25b8 assumptions.M\u2082sep <| Matroid.separator_coloop \u00b7)\n\nend PropertiesAssumptions\n\n\nsection PropertiesGroundSet\n\n/-- Ground set of 2-sum is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma twoSumGround_disjoint_inter (M\u2081 M\u2082 : Matroid \u03b1) :\n    twoSumGround M\u2081 M\u2082 \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  Set.disjoint_sdiff_left\n\n/-- Ground sets minus their intersection are disjoint sets -/\nlemma twoSum_disjoint_grounds_diff_inter (M\u2081 M\u2082 : Matroid \u03b1) :\n    M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) \u2ad7 M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E) := by\n  rw [Set.diff_self_inter, Set.diff_inter_self_eq_diff]\n  exact disjoint_sdiff_sdiff\n\nend PropertiesGroundSet\n\n\nsection PropertiesCircuitType1\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1} {C : Set \u03b1}\n\n/-- Circuit of type 1 is a circuit in `M\u2081` -/\nlemma TwoSumCircuitType1.circuit_M\u2081 (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : M\u2081.Circuit C :=\n  hC.left\n\n/-- Circuit of type 1 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType1.disjoint_inter (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of type 1 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma TwoSumCircuitType1.subset_union (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_left hC.circuit_M\u2081.subset_ground M\u2082.E\n\n/-- Circuit of type 1 lies in ground set of `M\u2081 \u2295\u2082 M\u2082` -/\nlemma TwoSumCircuitType1.subset_ground (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 twoSumGround M\u2081 M\u2082 :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 1 lies in `M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma TwoSumCircuitType1.subset_M\u2081_diff_inter (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2081.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 1 is disjoint with `M\u2082.E` -/\nlemma TwoSumCircuitType1.disjoint_M\u2082 (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2ad7 M\u2082.E := by\n  have hMM := twoSum_disjoint_grounds_diff_inter M\u2081 M\u2082\n  have hCM\u2082 := Set.disjoint_of_subset_left hC.subset_M\u2081_diff_inter hMM\n  have hCM\u2082 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2082, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_right] at hCM\u2082\n  exact hCM\u2082\n\nend PropertiesCircuitType1\n\n\nsection PropertiesCircuitType2\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1} {C : Set \u03b1}\n\n/-- Circuit of type 2 is a circuit in `M\u2082` -/\nlemma TwoSumCircuitType2.circuit_M\u2082 (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : M\u2082.Circuit C :=\n  hC.left\n\n/-- Circuit of type 2 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType2.disjoint_inter (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of type 2 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma TwoSumCircuitType2.subset_union (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_right hC.circuit_M\u2082.subset_ground M\u2081.E\n\n/-- Circuit of type 2 lies in ground set of `M\u2081 \u2295\u2082 M\u2082` -/\nlemma TwoSumCircuitType2.subset_ground (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2286 twoSumGround M\u2081 M\u2082 :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 2 lies in `M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma TwoSumCircuitType2.subset_M\u2082_diff_inter (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2286 M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2082.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 2 is disjoint with `M\u2081.E` -/\nlemma TwoSumCircuitType2.disjoint_M\u2081 (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E := by\n  have hMM := twoSum_disjoint_grounds_diff_inter M\u2081 M\u2082\n  have hCM\u2081 := (Set.disjoint_of_subset_right hC.subset_M\u2082_diff_inter hMM).symm\n  have hCM\u2081 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2081, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_left] at hCM\u2081\n  exact hCM\u2081\n\nend PropertiesCircuitType2\n\n\nsection PropertiesCircuitType3\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1} {C : Set \u03b1}\n\n/-- Circuit of type 3 yields a circuit in `M\u2081` after intersecting it with `M\u2081.E` and adding `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType3.to_circuit_M\u2081 (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : M\u2081.Circuit ((C \u2229 M\u2081.E) \u222a (M\u2081.E \u2229 M\u2082.E)) :=\n  hC.left\n\n/-- Circuit of type 3 yields a circuit in `M\u2082` after intersecting it with `M\u2081.E` and adding `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType3.to_circuit_M\u2082 (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : M\u2082.Circuit ((C \u2229 M\u2082.E) \u222a (M\u2081.E \u2229 M\u2082.E)) :=\n  hC.right.left\n\n/-- Circuit of type 3 is subset of ground set of `M\u2081 \u2295\u2082 M\u2082` -/\ndef TwoSumCircuitType3.subset_ground (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2286 twoSumGround M\u2081 M\u2082 :=\n  hC.right.right\n\n", "theoremStatement": "/-- Circuit of type 3 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma TwoSumCircuitType3.subset_union (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \u222a M\u2082.E ", "theoremName": "TwoSumCircuitType3.subset_union", "fileCreated": {"commit": "d0eaaa305c96cd81ac061f505a81614db6856b21", "date": "2025-01-09"}, "theoremCreated": {"commit": "439c72996f29168161b974bc602629cac773728f", "date": "2025-01-08"}, "file": "Seymour/Seymour/Matroid/Operations/Sum2/Basic.lean", "module": "Seymour.Matroid.Operations.Sum2.Basic", "jsonFile": "Seymour.Matroid.Operations.Sum2.Basic.jsonl", "positionMetadata": {"lineInFile": 221, "tokenPositionInFile": 8618, "theoremPositionInFile": 29}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 3, "numPremises": 12}, "proofMetadata": {"hasProof": true, "proof": ":=\n  sub_union_diff_sub_union hC.subset_ground", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 46}}
{"srcContext": "import Seymour.Matroid.Operations.SumDelta.Basic\nimport Seymour.ForMathlib.SetTheory\n\nset_option linter.unusedVariables false\n\nvariable {\u03b1 : Type} [DecidableEq \u03b1]\n\n\nsection Basic\n\n", "theoremStatement": "/-- Nonempty union of disjoint circuits of `M\u2081` satisfies circuit form of `M\u2081 \u0394 M\u2082`  -/\nlemma deltaSumCircuitForm_left {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : C.Nonempty) (hCE : C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)) (hCM\u2081 : M\u2081.toMatroid.IsUnionDisjointCircuits C) :\n    DeltaSumCircuitForm M\u2081 M\u2082 C ", "theoremName": "deltaSumCircuitForm_left", "fileCreated": {"commit": "aae07a69b2ec95e3d9a1436952a123dcb7d0d06f", "date": "2025-01-03"}, "theoremCreated": {"commit": "67629d2b74be7b972786897531b678f585a7af28", "date": "2025-02-03"}, "file": "Seymour/Seymour/Matroid/Operations/SumDelta/CircuitForms.lean", "module": "Seymour.Matroid.Operations.SumDelta.CircuitForms", "jsonFile": "Seymour.Matroid.Operations.SumDelta.CircuitForms.jsonl", "positionMetadata": {"lineInFile": 11, "tokenPositionInFile": 180, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 8, "numPremises": 43}, "proofMetadata": {"hasProof": true, "proof": ":=\n  \u27e8hC, hCE, C, \u2205, by simp, hCM\u2081, M\u2082.toMatroid.emptyUnionDisjointCircuits\u27e9", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 76}}
{"srcContext": "import Mathlib.Data.Set.SymmDiff\nimport Mathlib.Order.CompletePartialOrder\nimport Mathlib.Order.Disjoint\nimport Mathlib.Order.SymmDiff\nimport Mathlib.Tactic\n\nimport Seymour.Basic\n\n/-!\nThis provides lemmas about sets (mostly dealing with disjointness) that are missing in Mathlib.\n-/\n\nvariable {\u03b1 : Type}\n\nsection Other\n\nlemma set_union_union_eq_rev (X Y Z : Set \u03b1) : X \u222a Y \u222a Z = Z \u222a Y \u222a X := by\n  rw [Set.union_assoc, Set.union_comm, Set.union_comm Y Z]\n\nlemma setminus_inter_union_eq_union {X Y : Set \u03b1} : X \\ (X \u2229 Y) \u222a Y = X \u222a Y := by\n  tauto_set\n\nlemma nonempty_inter_not_ssubset_empty_inter {A B E : Set \u03b1} (hA : (A \u2229 E).Nonempty) (hB : B \u2229 E = \u2205) :\n    \u00ac(A \u2282 B) := by\n  intro \u27e8hAB, _\u27e9\n  obtain \u27e8x, hxAE\u27e9 := hA\n  have hxBE : x \u2208 B \u2229 E := (Set.inter_subset_inter hAB fun _ => id) hxAE\n  rw [hB] at hxBE\n  tauto\n\nlemma ssubset_self_union_other_elem {a : \u03b1} {X : Set \u03b1} (ha : a \u2209 X) :\n    X \u2282 X \u222a {a} := by\n  constructor\n  \u00b7 exact Set.subset_union_left\n  \u00b7 by_contra hX\n    rw [Set.union_subset_iff] at hX\n    obtain \u27e8_, haa\u27e9 := hX\n    tauto\n\nlemma singleton_union_ssubset_union_iff {a : \u03b1} {A B : Set \u03b1} (haA : a \u2209 A) (haB : a \u2209 B) :\n    A \u222a {a} \u2282 B \u222a {a} \u2194 A \u2282 B := by\n  constructor\n  \u00b7 intro hAB\n    obtain \u27e8hABl, hABr\u27e9 := hAB\n    constructor\n    \u00b7 intro x hx\n      apply ne_of_mem_of_not_mem hx at haA\n      cases hABl (Set.mem_union_left {a} hx) <;> tauto\n    \u00b7 by_contra hBA\n      apply Set.union_subset_union_left {a} at hBA\n      tauto\n  \u00b7 intro hAB\n    obtain \u27e8hABl, hABr\u27e9 := hAB\n    constructor\n    \u00b7 exact Set.union_subset_union_left {a} hABl\n    \u00b7 by_contra hBA\n      rw [Set.union_singleton, Set.union_singleton] at hBA\n      apply (Set.insert_subset_insert_iff haB).\u2192 at hBA\n      tauto\n\nlemma ssub_parts_ssub {A B E\u2081 E\u2082 : Set \u03b1}\n    (hA : A \u2286 E\u2081 \u222a E\u2082) (hB : B \u2286 E\u2081 \u222a E\u2082) (hAB\u2081 : A \u2229 E\u2081 \u2282 B \u2229 E\u2081) (hAB\u2082 : A \u2229 E\u2082 \u2282 B \u2229 E\u2082) :\n    A \u2282 B := by\n  constructor\n  \u00b7 obtain \u27e8hE\u2081, _\u27e9 := hAB\u2081\n    obtain \u27e8hE\u2082, _\u27e9 := hAB\u2082\n    rw [Set.left_eq_inter.\u2190 hA, Set.left_eq_inter.\u2190 hB, Set.inter_union_distrib_left, Set.inter_union_distrib_left]\n    exact Set.union_subset_union hE\u2081 hE\u2082\n  \u00b7 intro hBA\n    obtain \u27e8_, hE\u2081\u27e9 := hAB\u2081\n    obtain \u27e8x, hxBE\u2081, hxnAE\u2081\u27e9 := Set.not_subset.\u2192 hE\u2081\n    have hxB : x \u2208 B := Set.mem_of_mem_inter_left hxBE\u2081\n    have hxE\u2081 : x \u2208 E\u2081 := Set.mem_of_mem_inter_right hxBE\u2081\n    tauto\n\nlemma HasSubset.Subset.parts_eq {A E\u2081 E\u2082 : Set \u03b1} (hA : A \u2286 E\u2081 \u222a E\u2082) : (A \u2229 E\u2081) \u222a (A \u2229 E\u2082) = A :=\n  ((subset_of_subset_of_eq\n    (Set.subset_inter (fun _ => id) hA)\n    (Set.inter_union_distrib_left A E\u2081 E\u2082)).antisymm\n  (Set.union_subset Set.inter_subset_left Set.inter_subset_left)).symm\n\nlemma elem_notin_set_minus_singleton (a : \u03b1) (X : Set \u03b1) : a \u2209 X \\ {a} := Set.not_mem_diff_of_mem rfl\n\nlemma sub_union_diff_sub_union {A B C : Set \u03b1} (hA : A \u2286 B \\ C) : A \u2286 B :=\n  fun _ hA' => Set.diff_subset (hA hA')\n\nlemma singleton_inter_in_left {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : a \u2208 X :=\n  Set.mem_of_mem_inter_left (ha.symm.subset rfl)\n\nlemma singleton_inter_in_right {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : a \u2208 Y :=\n  Set.mem_of_mem_inter_right (ha.symm.subset rfl)\n\nlemma singleton_inter_subset_left {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : {a} \u2286 X := by\n  rw [Set.singleton_subset_iff]\n  exact singleton_inter_in_left ha\n\nlemma singleton_inter_subset_right {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : {a} \u2286 Y := by\n  rw [Set.singleton_subset_iff]\n  exact singleton_inter_in_right ha\n\n/-- Being a subset is preserved under subtracting sets. -/\nlemma diff_subset_parent {X\u2081 X\u2082 E : Set \u03b1} (hX\u2081E : X\u2081 \u2286 E) :\n    X\u2081 \\ X\u2082 \u2286 E :=\n  Set.diff_subset_iff.\u2190 (Set.subset_union_of_subset_right hX\u2081E X\u2082)\n\n/-- Being a subset is preserved under taking intersections. -/\nlemma inter_subset_parent_left {X\u2081 X\u2082 E : Set \u03b1} (hX\u2081E : X\u2081 \u2286 E) :\n    X\u2081 \u2229 X\u2082 \u2286 E :=\n  (Set.inter_subset_inter_left X\u2082 hX\u2081E).trans Set.inter_subset_left\n\n/-- Being a subset is preserved under taking intersections. -/\nlemma inter_subset_parent_right {X\u2081 X\u2082 E : Set \u03b1} (hX\u2082E : X\u2082 \u2286 E) :\n    X\u2081 \u2229 X\u2082 \u2286 E := by\n  rw [Set.inter_comm]\n  exact inter_subset_parent_left hX\u2082E\n\n/-- Intersection of two sets is subset of their union. -/\nlemma inter_subset_union {X\u2081 X\u2082 : Set \u03b1} :\n    X\u2081 \u2229 X\u2082 \u2286 X\u2081 \u222a X\u2082 :=\n  inter_subset_parent_left Set.subset_union_left\n\nlemma subset_diff_empty_eq {A B : Set \u03b1} (hAB : A \u2286 B) (hBA : B \\ A = \u2205) : A = B :=\n  A.union_empty \u25b8 hBA \u25b8 Set.union_diff_cancel hAB\n\nend Other\n\n\nsection Disjoint\n\nlemma Disjoint.ni_of_in {X Y : Set \u03b1} {a : \u03b1} (hXY : X \u2ad7 Y) (ha : a \u2208 X) :\n    a \u2209 Y := by\n  intro ha'\n  simpa [hXY.inter_eq] using Set.mem_inter ha ha'\n\nlemma disjoint_of_singleton_inter_left_wo {X Y : Set \u03b1} {a : \u03b1} (hXY : X \u2229 Y = {a}) :\n    X \\ {a} \u2ad7 Y := by\n  tauto_set\n\nlemma disjoint_of_singleton_inter_right_wo {X Y : Set \u03b1} {a : \u03b1} (hXY : X \u2229 Y = {a}) :\n    X \u2ad7 Y \\ {a} := by\n  rw [disjoint_comm]\n  rw [Set.inter_comm] at hXY\n  exact disjoint_of_singleton_inter_left_wo hXY\n\nlemma disjoint_of_singleton_inter_both_wo {X Y : Set \u03b1} {a : \u03b1} (hXY : X \u2229 Y = {a}) :\n    X \\ {a} \u2ad7 Y \\ {a} :=\n  Disjoint.disjoint_sdiff_left (disjoint_of_singleton_inter_right_wo hXY)\n\nlemma disjoint_of_singleton_inter_subset_left {X Y Z : Set \u03b1} {a : \u03b1} (hXY : X \u2229 Y = {a}) (hZ : Z \u2286 X) (haZ : a \u2209 Z) :\n    Z \u2ad7 Y := by\n  have hY : (Y \\ {a}) \u222a {a} = Y := (Set.diff_union_of_subset (singleton_inter_subset_right hXY))\n  rw [\u2190hY, Set.disjoint_union_right]\n  constructor\n  \u00b7 exact Set.disjoint_of_subset_left hZ (disjoint_of_singleton_inter_right_wo hXY)\n  \u00b7 exact Set.disjoint_singleton_right.\u2190 haZ\n\nlemma disjoint_of_singleton_inter_subset_right {X Y Z : Set \u03b1} {a : \u03b1} (hXY : X \u2229 Y = {a}) (hZ : Z \u2286 Y) (haZ : a \u2209 Z) :\n    X \u2ad7 Z := by\n  rw [Set.inter_comm] at hXY\n  rw [disjoint_comm]\n  exact disjoint_of_singleton_inter_subset_left hXY hZ haZ\n\nlemma disjoint_nonempty_not_subset {A B : Set \u03b1} (hAB : A \u2ad7 B) (hA : A.Nonempty) :\n    \u00ac(A \u2286 B) := by\n  intro contr\n  simp [Disjoint.eq_bot_of_le hAB, contr] at hA\n\nlemma disjoint_nonempty_not_ssubset {A B : Set \u03b1} (hAB : A \u2ad7 B) (hA : A.Nonempty) :\n    \u00ac(A \u2282 B) := by\n  apply disjoint_nonempty_not_subset hAB at hA\n  intro \u27e8_, _\u27e9\n  tauto\n\nlemma ssubset_union_disjoint_nonempty {X Y : Set \u03b1} (hXY : X \u2ad7 Y) (hY : Y.Nonempty) :\n    X \u2282 X \u222a Y := by\n  constructor\n  \u00b7 exact Set.subset_union_left\n  \u00b7 by_contra hX\n    apply Set.diff_subset_diff_left at hX\n    rw [Set.union_diff_cancel_left (Set.disjoint_iff.\u2192 hXY), Set.diff_self] at hX\n    exact Set.not_nonempty_empty (Set.eq_empty_of_subset_empty hX \u25b8 hY)\n\nlemma union_ssubset_union_iff {A B X : Set \u03b1} (hAX : A \u2ad7 X) (hBX : B \u2ad7 X) :\n    A \u222a X \u2282 B \u222a X \u2194 A \u2282 B := by\n  constructor\n  \u00b7 intro hAB\n    rw [Set.ssubset_iff_subset_ne] at hAB \u22a2\n    constructor\n    \u00b7 have hXX : X \u2286 X := Set.Subset.rfl\n      have hAXXBXX := Set.diff_subset_diff hAB.left hXX\n      rwa [Set.union_diff_cancel_right, Set.union_diff_cancel_right] at hAXXBXX\n      \u00b7 rwa [Set.disjoint_iff] at hBX\n      \u00b7 rwa [Set.disjoint_iff] at hAX\n    \u00b7 intro\n      simp_all\n  \u00b7 intro hAB\n    have hAB' : A \u2286 B := hAB.subset\n    rw [Set.ssubset_iff_of_subset hAB'] at hAB\n    obtain \u27e8x, hx\u27e9 := hAB\n    rw [Set.ssubset_iff_of_subset (Set.union_subset_union_left X hAB')]\n    refine \u27e8x, Set.mem_union_left X hx.left, fun hx' => ?_\u27e9\n    rw [Set.mem_union] at hx'\n    cases hx' with\n    | inl hA => exact hx.right hA\n    | inr hX => exact hBX.ni_of_in hx.left hX\n\nlemma union_subset_union_iff {A B X : Set \u03b1} (hAX : A \u2ad7 X) (hBX : B \u2ad7 X) :\n    A \u222a X \u2286 B \u222a X \u2194 A \u2286 B := by\n  constructor\n  \u00b7 intro hABX\n    have hXX : (A \u222a X) \\ X \u2286 (B \u222a X) \\ X := Set.diff_subset_diff_left hABX\n    have hXA : (A \u222a X) \\ X = A := Set.union_diff_cancel_right (Set.disjoint_iff.\u2192 hAX)\n    have hXB : (B \u222a X) \\ X = B := Set.union_diff_cancel_right (Set.disjoint_iff.\u2192 hBX)\n    rwa [hXA, hXB] at hXX\n  \u00b7 exact Set.union_subset_union_left X\n\nlemma ssubset_disjoint_union_nonempty {X\u2081 X\u2082 : Set \u03b1} (hXX : X\u2081 \u2ad7 X\u2082) (hX\u2082 : X\u2082.Nonempty) :\n    X\u2081 \u2282 X\u2081 \u222a X\u2082 := by\n  rw [Set.ssubset_iff_of_subset Set.subset_union_left]\n  obtain \u27e8x, hx\u27e9 := hX\u2082\n  exact \u27e8x, Set.mem_union_right X\u2081 hx, Disjoint.ni_of_in hXX.symm hx\u27e9\n\nlemma ssubset_disjoint_nonempty_union {X\u2081 X\u2082 : Set \u03b1} (hXX : X\u2081 \u2ad7 X\u2082) (hX\u2081 : X\u2081.Nonempty) :\n    X\u2082 \u2282 X\u2081 \u222a X\u2082 := by\n  rw [disjoint_comm] at hXX\n  rw [Set.union_comm]\n  exact ssubset_disjoint_union_nonempty hXX hX\u2081\n\n/-- If two sets are disjoint, then any set is disjoint with their intersection -/\nlemma disjoint_inter_disjoint {A B : Set \u03b1} (C : Set \u03b1) (hAB : A \u2ad7 B) : C \u2ad7 A \u2229 B := by\n  rw [hAB.inter_eq]\n  exact Set.disjoint_empty C\n\nlemma diff_inter_disjoint_diff_inter (X\u2081 X\u2082 : Set \u03b1) :\n    X\u2081 \\ (X\u2081 \u2229 X\u2082) \u2ad7 X\u2082 \\ (X\u2081 \u2229 X\u2082) := by\n  rw [Set.diff_self_inter, Set.diff_inter_self_eq_diff]\n  exact disjoint_sdiff_sdiff\n\nend Disjoint\n\n\nsection symmDiff\n\n/-- Symmetric difference of two sets is their union minus their intersection. -/\nlemma symmDiff_eq_alt (X Y : Set \u03b1) : symmDiff X Y = (X \u222a Y) \\ (X \u2229 Y) := by\n  tauto_set\n\n/-- Symmetric difference of two sets is disjoint with their intersection. -/\nlemma symmDiff_disjoint_inter (X Y : Set \u03b1) : symmDiff X Y \u2ad7 X \u2229 Y := by\n  rw [symmDiff_eq_alt]\n  exact Set.disjoint_sdiff_left\n\n", "theoremStatement": "lemma symmDiff_empty_eq (X : Set \u03b1) : symmDiff X \u2205 = X ", "theoremName": "symmDiff_empty_eq", "fileCreated": {"commit": "b44bff2f1ee71349fa9fa251579a0f5a0e575538", "date": "2024-12-19"}, "theoremCreated": {"commit": "ee35fddd27b04eb576eb64b8bb74af513408f6ef", "date": "2024-12-21"}, "file": "Seymour/Seymour/ForMathlib/SetTheory.lean", "module": "Seymour.ForMathlib.SetTheory", "jsonFile": "Seymour.ForMathlib.SetTheory.jsonl", "positionMetadata": {"lineInFile": 253, "tokenPositionInFile": 9017, "theoremPositionInFile": 35}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 1, "numPremises": 25}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [symmDiff_eq_alt, Set.union_empty, Set.inter_empty, Set.diff_empty]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 78}}
{"srcContext": "import Seymour.Matroid.Operations.Sum2.Basic\nimport Seymour.Matroid.Operations.SumDelta.CircuitForms\n\n\nvariable {\u03b1 : Type} [DecidableEq \u03b1] {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n\n\nsection CircuitFormsProperties\n\n/-- Circuit of form 1 satisfies circuit predicate of `M\u2081 \u0394 M\u2082` if `M\u2081.E` and `M\u2082.E` satisfy the 2-sum assumptions -/\nlemma DeltaSumCircuitForm1.sum2_circuit_pred {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) (assumptions : TwoSumAssumptions M\u2081.toMatroid M\u2082.toMatroid) :\n    DeltaSumCircuitPred M\u2081 M\u2082 C := by\n  constructor\n  \u00b7 exact hC.circuit_form\n  \u00b7 intro C' hC' hCC'\n    replace \u27e8hC, _\u27e9 := hC\n    obtain \u27e8C'_nonempty, _, X\u2081, X\u2082, hXX, hX\u2081, hX\u2082\u27e9 := hC'\n    cases hX\u2082.dep_or_empty with\n    | inl X\u2082_dep =>\n      have X\u2082_eq : X\u2082 = M\u2081.E \u2229 M\u2082.E :=\n        have symDiff_sub_E\u2081 := symmDiff_eq_alt X\u2081 X\u2082 \u25b8 hXX \u25b8 hCC'.trans hC.subset_ground\n        have X\u2082_sub_E\u2081 := M\u2081.toMatroid_E \u25b8 symmDiff_subset_ground_right symDiff_sub_E\u2081 hX\u2081.subset_ground\n        have X\u2082_sub_inter := Set.subset_inter X\u2082_sub_E\u2081 X\u2082_dep.subset_ground\n        have inter_finite := Set.finite_of_encard_eq_coe assumptions.interSingleton\n        have inter_encard_le_X\u2082_encard := le_of_eq_of_le assumptions.interSingleton\n          (Set.one_le_encard_iff_nonempty.\u2190 X\u2082_dep.nonempty)\n        inter_finite.eq_of_subset_of_encard_le X\u2082_sub_inter inter_encard_le_X\u2082_encard\n      have \u27e8p, hp\u27e9 := assumptions.inter_singleton\n      have M\u2082_loop_p : M\u2082.toMatroid.Loop p := \u27e8singleton_inter_in_right hp, hp \u25b8 X\u2082_eq \u25b8 X\u2082_dep\u27e9\n      exfalso\n      exact assumptions.inter_singleton_not_loop_M\u2082 hp M\u2082_loop_p\n    | inr X\u2082_empty =>\n      rw [X\u2082_empty, Set.union_empty, Set.inter_empty, Set.diff_empty] at hXX\n      rw [hXX] at hCC' C'_nonempty \u22a2\n      have X\u2081_dep := hX\u2081.nonempty_dep C'_nonempty\n      exact hC.right X\u2081_dep hCC'\n\n/-- Circuit of form 2 satisfies circuit predicate of `M\u2081 \u0394 M\u2082` if `M\u2081.E` and `M\u2082.E` satisfy the 2-sum assumptions -/\nlemma DeltaSumCircuitForm2.sum2_circuit_pred {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) (assumptions : TwoSumAssumptions M\u2081.toMatroid M\u2082.toMatroid) :\n    DeltaSumCircuitPred M\u2081 M\u2082 C := by\n  constructor\n  \u00b7 exact hC.circuit_form\n  \u00b7 intro C' hC' hCC'\n    replace \u27e8hC, _\u27e9 := hC\n    obtain \u27e8C'_nonempty, _, X\u2081, X\u2082, hXX, hX\u2081, hX\u2082\u27e9 := hC'\n    cases hX\u2081.dep_or_empty with\n    | inl X\u2081_dep =>\n      have X\u2081_eq : X\u2081 = M\u2081.E \u2229 M\u2082.E :=\n        have symDiff_sub_E\u2082 := symmDiff_eq_alt X\u2081 X\u2082 \u25b8 hXX \u25b8 hCC'.trans hC.subset_ground\n        have X\u2081_sub_E\u2082 := M\u2082.toMatroid_E \u25b8 symmDiff_subset_ground_left symDiff_sub_E\u2082 hX\u2082.subset_ground\n        have hX\u2081sub_inter := Set.subset_inter X\u2081_dep.subset_ground X\u2081_sub_E\u2082\n        have inter_finite := Set.finite_of_encard_eq_coe assumptions.interSingleton\n        have inter_encard_le_X\u2081_encard := le_of_eq_of_le assumptions.interSingleton\n          (Set.one_le_encard_iff_nonempty.\u2190 X\u2081_dep.nonempty)\n        inter_finite.eq_of_subset_of_encard_le hX\u2081sub_inter inter_encard_le_X\u2081_encard\n      obtain \u27e8p, hp\u27e9 := assumptions.inter_singleton\n      have M\u2081_loop_p : M\u2081.toMatroid.Loop p := \u27e8singleton_inter_in_left hp, hp \u25b8 X\u2081_eq \u25b8 X\u2081_dep\u27e9\n      exfalso\n      exact assumptions.inter_singleton_not_loop_M\u2081 hp M\u2081_loop_p\n    | inr X\u2081_empty =>\n      rw [X\u2081_empty, Set.empty_union, Set.empty_inter, Set.diff_empty] at hXX\n      rw [hXX] at hCC' C'_nonempty \u22a2\n      have X\u2082_dep := hX\u2082.nonempty_dep C'_nonempty\n      exact hC.right X\u2082_dep hCC'\n\n/-- Under 2-sum assumptions, `{p}` in definition of circuits of form 3 is exactly `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm3.sum2_singleton_eq {C : Set \u03b1} {p : \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) (assumptions : TwoSumAssumptions M\u2081.toMatroid M\u2082.toMatroid) :\n    M\u2081.E \u2229 M\u2082.E = {p} := by\n  have inter_encard_eq_1 := M\u2081.toMatroid_E \u25b8 M\u2082.toMatroid_E \u25b8 assumptions.interSingleton\n  have inter_finite := Set.finite_of_encard_eq_coe inter_encard_eq_1\n  have inter_subsingleton_encard := ((Set.encard_singleton p).symm \u25b8 inter_encard_eq_1).le\n  exact (inter_finite.eq_of_subset_of_encard_le hC.singleton_subset_inter inter_subsingleton_encard).symm\n\n", "theoremStatement": "/-- Circuit of form 3 satisfies circuit predicate of `M\u2081 \u0394 M\u2082` if `M\u2081.E` and `M\u2082.E` satisfy the 2-sum assumptions -/\nlemma DeltaSumCircuitForm3.sum2_circuit_pred {C : Set \u03b1} {p : \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) (assumptions : TwoSumAssumptions M\u2081.toMatroid M\u2082.toMatroid) :\n    DeltaSumCircuitPred M\u2081 M\u2082 C ", "theoremName": "DeltaSumCircuitForm3.sum2_circuit_pred", "fileCreated": {"commit": "aae07a69b2ec95e3d9a1436952a123dcb7d0d06f", "date": "2025-01-03"}, "theoremCreated": {"commit": "67629d2b74be7b972786897531b678f585a7af28", "date": "2025-02-03"}, "file": "Seymour/Seymour/Matroid/Operations/SumDelta/SpecialCase2Sum.lean", "module": "Seymour.Matroid.Operations.SumDelta.SpecialCase2Sum", "jsonFile": "Seymour.Matroid.Operations.SumDelta.SpecialCase2Sum.jsonl", "positionMetadata": {"lineInFile": 77, "tokenPositionInFile": 4017, "theoremPositionInFile": 3}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 27, "numPremises": 134}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  have hp := hC.sum2_singleton_eq assumptions\n  have not_loop_p := (assumptions.inter_singleton_not_loop_M\u2081 hp)\n  rw [M\u2081.toMatroid.loop_iff_circuit] at not_loop_p\n  apply hC.inter_M\u2081_nonempty at not_loop_p\n  apply Set.Nonempty.left at not_loop_p\n  constructor\n  \u00b7 exact hC.circuit_form not_loop_p\n  \u00b7 intro D hD hDC\n    have \u27e8D_nonempty, hDE, X\u2081, X\u2082, hDXX, hX\u2081, hX\u2082\u27e9 := hD\n    have \u27e8hCpM\u2081, hCpM\u2082, hCE\u27e9 := hC\n    have hXX := Set.inter_subset_inter hX\u2081.subset_ground hX\u2082.subset_ground\n    erw [M\u2081.toMatroid_E, M\u2082.toMatroid_E, hp] at hXX\n    have hCX\u2081 : X\u2081 \u2286 C \u2229 M\u2081.E \u222a {p}\n    \u00b7 rw [(Set.diff_union_inter X\u2081 X\u2082).symm]\n      rw [\u2190symmDiff_eq_alt, symmDiff_def] at hDXX\n      simp only [Set.sup_eq_union] at hDXX\n      have hXXC := (hDXX \u25b8 Set.subset_union_left).trans hDC\n      have hXXE := Set.diff_subset_iff.\u2190 (Set.subset_union_of_subset_right hX\u2081.subset_ground X\u2082)\n      have hXXCE := Set.subset_inter hXXC hXXE\n      exact Set.union_subset_union hXXCE hXX\n    have hCX\u2082 : X\u2082 \u2286 C \u2229 M\u2082.E \u222a {p}\n    \u00b7 rw [(Set.diff_union_inter X\u2082 X\u2081).symm]\n      rw [\u2190symmDiff_eq_alt, symmDiff_def] at hDXX\n      simp only [Set.sup_eq_union] at hDXX\n      have hXXC := (hDXX \u25b8 Set.subset_union_right).trans hDC\n      have hXXE := Set.diff_subset_iff.\u2190 (Set.subset_union_of_subset_right hX\u2082.subset_ground X\u2081)\n      have hXXCE := Set.subset_inter hXXC hXXE\n      exact Set.union_subset_union hXXCE (Set.inter_comm X\u2081 X\u2082 \u25b8 hXX)\n    cases hX\u2081.dep_or_empty with\n    | inl X\u2081_dep =>\n      replace hCX\u2081 := hCpM\u2081.right X\u2081_dep hCX\u2081\n      cases hX\u2082.dep_or_empty with\n      | inl X\u2082_dep =>\n        replace hCX\u2082 := hCpM\u2082.right X\u2082_dep hCX\u2082\n        have hXXp : X\u2081 \u2229 X\u2082 = {p} :=\n          hXX.antisymm (Set.subset_inter (Set.union_subset_iff.\u2192 hCX\u2081).right (Set.union_subset_iff.\u2192 hCX\u2082).right)\n        have hCD : (C \u2229 M\u2081.E \u222a {p} \u222a (C \u2229 M\u2082.E \u222a {p})) \\ {p} \u2286 (X\u2081 \u222a X\u2082) \\ {p} :=\n          Set.diff_subset_diff_left (Set.union_subset_union hCX\u2081 hCX\u2082)\n        rwa [Set.union_diff_distrib, Set.union_diff_right, Set.union_diff_right,\n            Disjoint.sdiff_eq_left (hp \u25b8 hC.disjoint_inter_M\u2081_inter),\n            Disjoint.sdiff_eq_left (hp \u25b8 hC.disjoint_inter_M\u2082_inter),\n            hC.subset_union.parts_eq, \u2190hXXp, \u2190hDXX\n        ] at hCD\n      | inr X\u2082_empty =>\n        rw [X\u2082_empty, Set.union_empty, Set.inter_empty, Set.diff_empty] at hDXX\n        rw [hDXX] at D_nonempty\n        have hpX\u2081 := hDXX \u25b8 (Set.union_subset_iff.\u2192 hCX\u2081).right\n        have disjoint_D_p := hp \u25b8 Set.disjoint_of_subset_left hDE Set.disjoint_sdiff_left\n        exact (disjoint_D_p hpX\u2081 Set.Subset.rfl rfl).elim\n    | inr X\u2081_empty =>\n      rw [X\u2081_empty, Set.empty_union, Set.empty_inter, Set.diff_empty] at hDXX\n      have X\u2082_dep := hX\u2082.nonempty_dep (hDXX \u25b8 D_nonempty)\n      have hCX\u2082 := hCpM\u2082.right X\u2082_dep hCX\u2082\n      have hpX\u2082 := hDXX \u25b8 (Set.union_subset_iff.\u2192 hCX\u2082).right\n      have disjoint_D_p := hp \u25b8 Set.disjoint_of_subset_left hDE Set.disjoint_sdiff_left\n      exact (disjoint_D_p hpX\u2082 Set.Subset.rfl rfl).elim", "proofType": "tactic", "proofLengthLines": 56, "proofLengthTokens": 2962}}
{"srcContext": "import Mathlib.Tactic\n\n\n", "theoremStatement": "lemma finset_of_cardinality_between {\u03b1 \u03b2 : Type} [Fintype \u03b1] [Fintype \u03b2] {n : \u2115}\n    (h\u03b1 : Fintype.card \u03b1 < n) (hn : n \u2264 Fintype.card \u03b1 + Fintype.card \u03b2) :\n    \u2203 b : Finset \u03b2, Fintype.card (\u03b1 \u2295 b) = n \u2227 Nonempty b ", "theoremName": "finset_of_cardinality_between", "fileCreated": {"commit": "458d46a280637e93aa2f0374e73699d0498fed06", "date": "2024-11-18"}, "theoremCreated": {"commit": "f8cedea76301fe0b2dfe3701c7f2d556b12fa386", "date": "2025-01-02"}, "file": "Seymour/Seymour/ForMathlib/Basic.lean", "module": "Seymour.ForMathlib.Basic", "jsonFile": "Seymour.ForMathlib.Basic.jsonl", "positionMetadata": {"lineInFile": 4, "tokenPositionInFile": 24, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 123}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  have beta' : n - Fintype.card \u03b1 \u2264 Fintype.card \u03b2\n  \u00b7 omega\n  obtain \u27e8s, hs\u27e9 : \u2203 s : Finset \u03b2, s.card = n - Fintype.card \u03b1 :=\n    (Finset.exists_subset_card_eq beta').imp (by simp)\n  use s\n  rw [Fintype.card_sum, Fintype.card_coe, hs]\n  constructor\n  \u00b7 omega\n  \u00b7 by_contra ifempty\n    have : s.card = 0\n    \u00b7 rw [Finset.card_eq_zero]\n      rw [nonempty_subtype, not_exists] at ifempty\n      exact Finset.eq_empty_of_forall_not_mem ifempty\n    omega", "proofType": "tactic", "proofLengthLines": 14, "proofLengthTokens": 455}}
{"srcContext": "import Seymour.Matroid.Notions.Circuit\nimport Seymour.Matroid.Notions.Loop\nimport Seymour.Matroid.Notions.Coloop\n\n\nvariable {\u03b1 : Type}\n\nsection SimpleConnectivity\n\n/-- The connectivity relation, aka \u03be in Oxley's book -/\ndef Matroid.ConnectivityRelation (M : Matroid \u03b1) (e f : \u03b1) : Prop :=\n  e = f \u2228 \u2203 C : Set \u03b1, C \u2286 M.E \u2227 M.Circuit C \u2227 e \u2208 C \u2227 f \u2208 C\n\n/-- The connectivity relation is reflexive -/\n@[refl]\nlemma Matroid.ConnectivityRelation.refl (M : Matroid \u03b1) {e : \u03b1} :\n    M.ConnectivityRelation e e :=\n  Or.inl rfl\n\n/-- The connectivity relation is symmetric -/\n@[symm]\nlemma Matroid.ConnectivityRelation.symm (M : Matroid \u03b1) {e f : \u03b1} :\n    M.ConnectivityRelation e f \u2192 M.ConnectivityRelation f e := by\n  intro hef\n  cases hef with\n  | inl hef => exact Or.inl hef.symm\n  | inr hef =>\n    right\n    obtain \u27e8C, _, _, _, _\u27e9 := hef\n    use C\n\n/-- The connectivity relation is transitive -/\n@[trans]\nlemma Matroid.ConnectivityRelation.trans (M : Matroid \u03b1) {e f g : \u03b1} :\n    M.ConnectivityRelation e f \u2192 M.ConnectivityRelation f g \u2192 M.ConnectivityRelation e g := by\n  intro hef hfg\n  cases hef with\n  | inl hef => exact hef \u25b8 hfg\n  | inr hef =>\n    cases hfg with\n    | inl hfg => exact Or.inr (hfg \u25b8 hef)\n    | inr hfg =>\n      obtain \u27e8C\u2081, hC\u2081, hMC\u2081, heC\u2081, hfC\u2081\u27e9 := hef\n      obtain \u27e8C\u2082, hC\u2082, hMC\u2082, hfC\u2082, hgC\u2082\u27e9 := hfg\n      right\n      -- todo: see proof of Lemma 7 in Bruhn Wollman 2011 (page 5)\n      -- note: that proof uses matroid contraction\n      sorry\n\n/-- A component is an equivalence class under the connectivity relation, i.e., a \u03be-equivalence class -/\ndef Matroid.Component (M : Matroid \u03b1) (X : Set \u03b1) : Prop :=\n  \u2200 e \u2208 X, \u2200 f \u2208 M.E, M.ConnectivityRelation e f \u2194 f \u2208 X\n\n/-- A separator is a union of components -/\ndef Matroid.Separator (M : Matroid \u03b1) (X : Set \u03b1) : Prop :=\n  \u2200 e \u2208 X, \u2200 f \u2208 M.E, M.ConnectivityRelation e f \u2192 f \u2208 X\n\n/-- Every component is a separator -/\nlemma Matroid.separator_component (M : Matroid \u03b1) {X : Set \u03b1} (hX : M.Component X) :\n    M.Separator X :=\n  fun e he f hf hef => (hX e he f hf).\u2192 hef\n\n/-- Every loop is a separator -/\nlemma Matroid.separator_loop {M : Matroid \u03b1} {x : \u03b1} (hx : M.Loop x) :\n    M.Separator {x} := by\n  intro e hex f hfE hf\n  cases hf with\n  | inl hef => exact Set.mem_of_eq_of_mem hef.symm hex\n  | inr hfC =>\n    obtain \u27e8C, hCE, circC, heC, hfC\u27e9 := hfC\n    rw [hex, \u2190Set.singleton_subset_iff] at heC\n    rw [Matroid.loop_iff_circuit] at hx\n    apply Matroid.Circuit.not_ssubset_circuit hx at circC\n    rw [Set.ssubset_def] at circC\n    push_neg at circC\n    exact circC heC hfC\n\n", "theoremStatement": "/-- Every coloop is a separator -/\nlemma Matroid.separator_coloop {M : Matroid \u03b1} {x : \u03b1} (hx : M.Coloop x) :\n    M.Separator {x} ", "theoremName": "Matroid.separator_coloop", "fileCreated": {"commit": "b44bff2f1ee71349fa9fa251579a0f5a0e575538", "date": "2024-12-19"}, "theoremCreated": {"commit": "f9d717ecfb54b3a7b794411b4c1af1f5c8ffb7c3", "date": "2024-12-26"}, "file": "Seymour/Seymour/Matroid/Notions/Connectivity.lean", "module": "Seymour.Matroid.Notions.Connectivity", "jsonFile": "Seymour.Matroid.Notions.Connectivity.jsonl", "positionMetadata": {"lineInFile": 78, "tokenPositionInFile": 2543, "theoremPositionInFile": 8}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 5, "numPremises": 33}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  intro e hex f hfE hf\n  cases hf with\n  | inl hef => exact Set.mem_of_eq_of_mem hef.symm hex\n  | inr hfC =>\n    rw [Matroid.coloop_iff_in_no_circuit] at hx\n    obtain \u27e8_hxE, hxC\u27e9 := hx\n    obtain \u27e8C, _hCE, hCcirc, heC, hfC\u27e9 := hfC\n    rw [hex, \u2190Set.singleton_subset_iff] at heC\n    specialize hxC C hCcirc\n    tauto", "proofType": "tactic", "proofLengthLines": 10, "proofLengthTokens": 322}}
{"srcContext": "import Mathlib.Data.Matroid.IndepAxioms\nimport Mathlib.Data.Matroid.Dual\n\nimport Seymour.Basic\n\n\nsection Definition\n\n/-- Vector matroid `M[A]` of matrix `A`. -/\nstructure VectorMatroid (\u03b1 R : Type) where\n  /-- Row indices. -/\n  X : Type\n  /-- Column indices. -/\n  Y : Type\n  /-- Full representation matrix. -/\n  A : Matrix X Y R\n  /-- The matrix has finite number of columns. -/\n  finY : Fintype Y\n  /-- How the columns correspond to the elements of the resulting matroid. -/\n  emb : Y \u21aa \u03b1\n\nattribute [instance] VectorMatroid.finY\n\nopen scoped Matrix\n\nvariable {\u03b1 R : Type} [DecidableEq \u03b1] [Semiring R]\n\ndef VectorMatroid.E (M : VectorMatroid \u03b1 R) : Set \u03b1 :=\n  Set.range M.emb\n\n/-- A set `S` is independent in `M[A]` iff\n    `S \u2286 Y` and `S` corresponds to a linearly independent submultiset of columns in `A`. -/\ndef VectorMatroid.IndepCols (M : VectorMatroid \u03b1 R) (S : Set \u03b1) : Prop :=\n  \u2203 hS : S \u2286 M.E, LinearIndependent R (fun s : S => (M.A \u00b7 (M.emb.invOfMemRange (hS.elem s))))\n\n/-- A set `S` is independent in `M[A]` iff\n    `S \u2286 Y` and the submatrix that contains only columns of `S` has linearly independent columns. -/\nlemma VectorMatroid.indepCols_iff_submatrix (M : VectorMatroid \u03b1 R) (S : Set \u03b1) :\n    M.IndepCols S \u2194 \u2203 hS : S \u2286 M.E, LinearIndependent R (M.A.submatrix id (M.emb.invOfMemRange \u2218 hS.elem))\u1d40 := by\n  rfl\n\n/-- Empty set is independent. -/\ntheorem VectorMatroid.indepCols_empty (M : VectorMatroid \u03b1 R) :\n    M.IndepCols \u2205 :=\n  \u27e8M.E.empty_subset, linearIndependent_empty_type\u27e9\n\n/-- A subset of a linearly independent set of columns is linearly independent. -/\ntheorem VectorMatroid.indepCols_subset (M : VectorMatroid \u03b1 R) (I J : Set \u03b1) (hMJ : M.IndepCols J) (hIJ : I \u2286 J) :\n    M.IndepCols I :=\n  have \u27e8hJ, hM\u27e9 := hMJ\n  \u27e8hIJ.trans hJ, hM.comp hIJ.elem hIJ.elem_injective\u27e9\n\n/-- A non-maximal linearly independent set of columns can be augmented with another linearly independent column. -/\ntheorem VectorMatroid.indepCols_aug (M : VectorMatroid \u03b1 R) (I J : Set \u03b1)\n    (hMI : M.IndepCols I) (hMI' : \u00acMaximal M.IndepCols I) (hMJ : Maximal M.IndepCols J) :\n    \u2203 x \u2208 J \\ I, M.IndepCols (x \u1543 I) := by\n  by_contra! non_aug\n  rw [Maximal] at hMI'\n  push_neg at hMI'\n  obtain \u27e8hI, I_indep\u27e9 := hMI\n  obtain \u27e8\u27e8hJ, J_indep\u27e9, hJ'\u27e9 := hMJ\n\n  -- let I' : Set M.E := { x : M.E.Elem | x.val \u2208 I }\n  -- let J' : Set M.E := { x : M.E.Elem | x.val \u2208 J }\n  -- let I\u1d65 : Set (M.X \u2192 R) := M.A\u1d40 '' I'\n  -- let J\u1d65 : Set (M.X \u2192 R) := M.A\u1d40 '' J'\n  -- let I\u209b : Submodule R (M.X \u2192 R) := Submodule.span R I\u1d65\n  -- let J\u209b : Submodule R (M.X \u2192 R) := Submodule.span R J\u1d65\n\n  -- have J\u1d65_ss_I\u209b : J\u1d65 \u2286 I\u209b\n  -- \u00b7 intro v \u27e8x, hxJ, hxv\u27e9\n  --   by_cases hvI : v \u2208 I\u1d65\n  --   \u00b7 aesop\n  --   \u00b7 have x_in_J : \u2191x \u2208 J := hxJ\n  --     have x_ni_I : \u2191x \u2209 I := by aesop\n  --     have x_in_JwoI : \u2191x \u2208 J \\ I := Set.mem_diff_of_mem x_in_J x_ni_I\n  --     have hMxI : \u00acM.IndepCols (\u2191x \u1543 I) := non_aug \u2191x x_in_JwoI\n  --     sorry\n  -- have I\u1d65_ss_J\u209b : I\u1d65 \u2286 J\u209b\n  -- \u00b7 intro v \u27e8x, hxI, hxv\u27e9\n  --   have hMxJ : M.IndepCols (\u2191x \u1543 J)\n  --   \u00b7 have hxJ : (\u2191x \u1543 J) \u2286 M.E := Set.insert_subset (hI hxI) hJ\n  --     have hvJ : (M.A.submatrix id hxJ.elem)\u1d40 '' Set.univ = v \u1543 J\u1d65\n  --     \u00b7 sorry\n  --     sorry\n  --   have v_in_J\u1d65 : v \u2208 J\u1d65 := by aesop\n  --   exact Set.mem_of_mem_of_subset v_in_J\u1d65 Submodule.subset_span\n  -- have J\u209b_le_I\u209b : J\u209b \u2264 I\u209b := Submodule.span_le.\u2190 J\u1d65_ss_I\u209b\n  -- have I\u209b_le_J\u209b : I\u209b \u2264 J\u209b := Submodule.span_le.\u2190 I\u1d65_ss_J\u209b\n  -- have I\u209b_eq_J\u209b : I\u209b = J\u209b := Submodule.span_eq_span I\u1d65_ss_J\u209b J\u1d65_ss_I\u209b\n  -- clear J\u1d65_ss_I\u209b I\u1d65_ss_J\u209b J\u209b_le_I\u209b I\u209b_le_J\u209b\n  sorry\n\n/-- Every set of columns contains a maximal independent subset of columns. -/\ntheorem VectorMatroid.indepCols_maximal (M : VectorMatroid \u03b1 R) (S : Set \u03b1) :\n    Matroid.ExistsMaximalSubsetProperty M.IndepCols S := by\n  sorry\n\n/-- Vector matroid expressed as `IndepMatroid`. -/\ndef VectorMatroid.toIndepMatroid (M : VectorMatroid \u03b1 R) : IndepMatroid \u03b1 where\n  E := M.E\n  Indep := M.IndepCols\n  indep_empty := M.indepCols_empty\n  indep_subset := M.indepCols_subset\n  indep_aug := M.indepCols_aug\n  indep_maximal S _ := M.indepCols_maximal S\n  subset_ground _ := Exists.choose\n\nend Definition\n\n\nsection API\n\nvariable {\u03b1 R : Type} [DecidableEq \u03b1] [Semiring R]\n\n/-- Vector matroid converted to `Matroid`. -/\ndef VectorMatroid.toMatroid (M : VectorMatroid \u03b1 R) : Matroid \u03b1 :=\n  M.toIndepMatroid.matroid\n\n", "theoremStatement": "@[simp]\nlemma VectorMatroid.toMatroid_E (M : VectorMatroid \u03b1 R) : M.toMatroid.E = Set.range M.emb ", "theoremName": "VectorMatroid.toMatroid_E", "fileCreated": {"commit": "b44bff2f1ee71349fa9fa251579a0f5a0e575538", "date": "2024-12-19"}, "theoremCreated": {"commit": "1a6d79dfb5649dbdf07194ae0bd21376f5682084", "date": "2025-01-07"}, "file": "Seymour/Seymour/Matroid/Constructors/VectorMatroid.lean", "module": "Seymour.Matroid.Constructors.VectorMatroid", "jsonFile": "Seymour.Matroid.Constructors.VectorMatroid.jsonl", "positionMetadata": {"lineInFile": 120, "tokenPositionInFile": 4323, "theoremPositionInFile": 8}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 4, "numPremises": 14}, "proofMetadata": {"hasProof": true, "proof": ":=\n  rfl", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 8}}
{"srcContext": "import Seymour.Matroid.Operations.MatrixSums.BinaryMatroids\n\n/-!\nThis file contains everything about 3-sum of binary matroids \u2014 the old version (in terms of explicit matrices).\n-/\n\nvariable {\u03b1 : Type}\n\n/-- `Matrix`-level 3-sum for matroids defined by their standard representation matrices; does not check legitimacy. -/\nnoncomputable abbrev Matrix_3sumComposition {\u03b2 : Type} [CommRing \u03b2] {X\u2081 Y\u2081 X\u2082 Y\u2082 : Set \u03b1}\n    (A\u2081 : Matrix X\u2081 (Y\u2081 \u2295 Fin 2) \u03b2) (A\u2082 : Matrix (Fin 2 \u2295 X\u2082) Y\u2082 \u03b2)\n    (z\u2081 : Y\u2081 \u2192 \u03b2) (z\u2082 : X\u2082 \u2192 \u03b2) (D : Matrix (Fin 2) (Fin 2) \u03b2) (D\u2081 : Matrix (Fin 2) Y\u2081 \u03b2) (D\u2082 : Matrix X\u2082 (Fin 2) \u03b2) :\n    Matrix ((X\u2081 \u2295 Unit) \u2295 (Fin 2 \u2295 X\u2082)) ((Y\u2081 \u2295 Fin 2) \u2295 (Unit \u2295 Y\u2082)) \u03b2 :=\n  -- Unfortunately `Ring.inverse` is `noncomputable` and upgrading `\u03b2` to `Field` does not help.\n  let D\u2081\u2082 : Matrix X\u2082 Y\u2081 \u03b2 := D\u2082 * D\u207b\u00b9 * D\u2081\n  Matrix.fromBlocks\n    (Matrix.fromRows A\u2081 (Matrix.row Unit (Sum.elim z\u2081 ![1, 1]))) 0\n    (Matrix.fromBlocks D\u2081 D D\u2081\u2082 D\u2082) (Matrix.fromCols (Matrix.col Unit (Sum.elim ![1, 1] z\u2082)) A\u2082)\n\nvariable [DecidableEq \u03b1] {M\u2081 M\u2082 : StandardRepresentation \u03b1}\n\n/-- `StandardRepresentation`-level 3-sum of two matroids.\nThe second part checks legitimacy (invertibility of a certain 2x2 submatrix and specific 1s and 0s on concrete positions). -/\nnoncomputable def StandardRepresentation_3sum {x\u2081 x\u2082 x\u2083 y\u2081 y\u2082 y\u2083 : \u03b1}\n    (hXX : M\u2081.X \u2229 M\u2082.X = {x\u2081, x\u2082, x\u2083}) (hYY : M\u2081.Y \u2229 M\u2082.Y = {y\u2081, y\u2082, y\u2083}) (hXY : M\u2081.X \u2ad7 M\u2082.Y) (hYX : M\u2081.Y \u2ad7 M\u2082.X) :\n    StandardRepresentation \u03b1 \u00d7 Prop :=\n  have hxxx\u2081 : {x\u2081, x\u2082, x\u2083} \u2286 M\u2081.X := hXX.symm.subset.trans Set.inter_subset_left\n  have hxxx\u2082 : {x\u2081, x\u2082, x\u2083} \u2286 M\u2082.X := hXX.symm.subset.trans Set.inter_subset_right\n  have hyyy\u2081 : {y\u2081, y\u2082, y\u2083} \u2286 M\u2081.Y := hYY.symm.subset.trans Set.inter_subset_left\n  have hyyy\u2082 : {y\u2081, y\u2082, y\u2083} \u2286 M\u2082.Y := hYY.symm.subset.trans Set.inter_subset_right\n  have x\u2081inX\u2081 : x\u2081 \u2208 M\u2081.X := hxxx\u2081 (Set.mem_insert x\u2081 {x\u2082, x\u2083})\n  have x\u2081inX\u2082 : x\u2081 \u2208 M\u2082.X := hxxx\u2082 (Set.mem_insert x\u2081 {x\u2082, x\u2083})\n  have x\u2082inX\u2081 : x\u2082 \u2208 M\u2081.X := hxxx\u2081 (Set.insert_comm x\u2081 x\u2082 {x\u2083} \u25b8 Set.mem_insert x\u2082 {x\u2081, x\u2083})\n  have x\u2082inX\u2082 : x\u2082 \u2208 M\u2082.X := hxxx\u2082 (Set.insert_comm x\u2081 x\u2082 {x\u2083} \u25b8 Set.mem_insert x\u2082 {x\u2081, x\u2083})\n  have x\u2083inX\u2081 : x\u2083 \u2208 M\u2081.X := hxxx\u2081 (by simp)\n  have x\u2083inX\u2082 : x\u2083 \u2208 M\u2082.X := hxxx\u2082 (by simp)\n  have y\u2083inY\u2081 : y\u2083 \u2208 M\u2081.Y := hyyy\u2081 (by simp)\n  have y\u2083inY\u2082 : y\u2083 \u2208 M\u2082.Y := hyyy\u2082 (by simp)\n  have y\u2082inY\u2081 : y\u2082 \u2208 M\u2081.Y := hyyy\u2081 (Set.insert_comm y\u2081 y\u2082 {y\u2083} \u25b8 Set.mem_insert y\u2082 {y\u2081, y\u2083})\n  have y\u2082inY\u2082 : y\u2082 \u2208 M\u2082.Y := hyyy\u2082 (Set.insert_comm y\u2081 y\u2082 {y\u2083} \u25b8 Set.mem_insert y\u2082 {y\u2081, y\u2083})\n  have y\u2081inY\u2081 : y\u2081 \u2208 M\u2081.Y := hyyy\u2081 (Set.mem_insert y\u2081 {y\u2082, y\u2083})\n  have y\u2081inY\u2082 : y\u2081 \u2208 M\u2082.Y := hyyy\u2082 (Set.mem_insert y\u2081 {y\u2082, y\u2083})\n  -- The actual definition starts here:\n  let A\u2081 : Matrix (M\u2081.X \\ {x\u2081, x\u2082, x\u2083}).Elem ((M\u2081.Y \\ {y\u2081, y\u2082, y\u2083}).Elem \u2295 Fin 2) Z2 := -- the top left submatrix\n    Matrix.of (fun i j => M\u2081.B\n        \u27e8i.val, Set.mem_of_mem_diff i.property\u27e9\n        (j.casesOn (fun j' => \u27e8j'.val, Set.mem_of_mem_diff j'.property\u27e9) ![\u27e8y\u2082, y\u2082inY\u2081\u27e9, \u27e8y\u2081, y\u2081inY\u2081\u27e9]))\n  let A\u2082 : Matrix (Fin 2 \u2295 (M\u2082.X \\ {x\u2081, x\u2082, x\u2083}).Elem) (M\u2082.Y \\ {y\u2081, y\u2082, y\u2083}).Elem Z2 := -- the bottom right submatrix\n    Matrix.of (fun i j => M\u2082.B\n        (i.casesOn ![\u27e8x\u2082, x\u2082inX\u2082\u27e9, \u27e8x\u2083, x\u2083inX\u2082\u27e9] (fun i' => \u27e8i'.val, Set.mem_of_mem_diff i'.property\u27e9))\n        \u27e8j.val, Set.mem_of_mem_diff j.property\u27e9)\n  let z\u2081 : (M\u2081.Y \\ {y\u2081, y\u2082, y\u2083}).Elem \u2192 Z2 := -- the middle left \"row vector\"\n    (fun j => M\u2081.B \u27e8x\u2081, x\u2081inX\u2081\u27e9 \u27e8j.val, Set.mem_of_mem_diff j.property\u27e9)\n  let z\u2082 : (M\u2082.X \\ {x\u2081, x\u2082, x\u2083}).Elem \u2192 Z2 := -- the bottom middle \"column vector\"\n    (fun i => M\u2082.B \u27e8i.val, Set.mem_of_mem_diff i.property\u27e9 \u27e8y\u2083, y\u2083inY\u2082\u27e9)\n  let D_\u2081 : Matrix (Fin 2) (Fin 2) Z2 := -- the bottom middle 2x2 submatrix\n    Matrix.of (fun i j => M\u2081.B (![\u27e8x\u2082, x\u2082inX\u2081\u27e9, \u27e8x\u2083, x\u2083inX\u2081\u27e9] i) (![\u27e8y\u2082, y\u2082inY\u2081\u27e9, \u27e8y\u2081, y\u2081inY\u2081\u27e9] j))\n  let D_\u2082 : Matrix (Fin 2) (Fin 2) Z2 := -- the middle left 2x2 submatrix\n    Matrix.of (fun i j => M\u2082.B (![\u27e8x\u2082, x\u2082inX\u2082\u27e9, \u27e8x\u2083, x\u2083inX\u2082\u27e9] i) (![\u27e8y\u2082, y\u2082inY\u2082\u27e9, \u27e8y\u2081, y\u2081inY\u2082\u27e9] j))\n  let D\u2081 : Matrix (Fin 2) (M\u2081.Y \\ {y\u2081, y\u2082, y\u2083}).Elem Z2 := -- the bottom left submatrix\n    Matrix.of (fun i j => M\u2081.B (![\u27e8x\u2082, x\u2082inX\u2081\u27e9, \u27e8x\u2083, x\u2083inX\u2081\u27e9] i) \u27e8j.val, Set.mem_of_mem_diff j.property\u27e9)\n  let D\u2082 : Matrix (M\u2082.X \\ {x\u2081, x\u2082, x\u2083}).Elem (Fin 2) Z2 := -- the bottom left submatrix\n    Matrix.of (fun i j => M\u2082.B \u27e8i.val, Set.mem_of_mem_diff i.property\u27e9 (![\u27e8y\u2082, y\u2082inY\u2082\u27e9, \u27e8y\u2081, y\u2081inY\u2082\u27e9] j))\n  \u27e8\n    \u27e8\n      (M\u2081.X \\ {x\u2081, x\u2082, x\u2083}) \u222a M\u2082.X,\n      M\u2081.Y \u222a (M\u2082.Y \\ {y\u2081, y\u2082, y\u2083}),\n      inferInstance,\n      inferInstance,\n      by\n        rw [Set.disjoint_union_right, Set.disjoint_union_left, Set.disjoint_union_left]\n        exact\n          \u27e8\u27e8M\u2081.hXY.disjoint_sdiff_left, hYX.symm\u27e9, \u27e8hXY.disjoint_sdiff_right.disjoint_sdiff_left, M\u2082.hXY.disjoint_sdiff_right\u27e9\u27e9,\n      Matrix.of (fun i j =>\n        Matrix_3sumComposition A\u2081 A\u2082 z\u2081 z\u2082 D_\u2081 D\u2081 D\u2082 (\n          if hi\u2081 : i.val \u2208 M\u2081.X \\ {x\u2081, x\u2082, x\u2083} then Sum.inl (Sum.inl \u27e8i, hi\u2081\u27e9) else\n          if hi\u2082 : i.val \u2208 M\u2082.X \\ {x\u2081, x\u2082, x\u2083} then Sum.inr (Sum.inr \u27e8i, hi\u2082\u27e9) else\n          if hx\u2081 : i.val = x\u2081 then Sum.inl (Sum.inr ()) else\n          if hx\u2082 : i.val = x\u2082 then Sum.inr (Sum.inl 0) else\n          if hx\u2083 : i.val = x\u2083 then Sum.inr (Sum.inl 1) else\n          (i.property.elim hi\u2081 (by simp_all)).elim\n          -- TODO can `Matrix.toMatrixUnionUnion` be combined with something else to simplify this definition?\n        ) (\n          if hj\u2081 : j.val \u2208 M\u2081.Y \\ {y\u2081, y\u2082, y\u2083} then Sum.inl (Sum.inl \u27e8j, hj\u2081\u27e9) else\n          if hj\u2082 : j.val \u2208 M\u2082.Y \\ {y\u2081, y\u2082, y\u2083} then Sum.inr (Sum.inr \u27e8j, hj\u2082\u27e9) else\n          if hy\u2081 : j.val = y\u2081 then Sum.inl (Sum.inr 1) else\n          if hy\u2082 : j.val = y\u2082 then Sum.inl (Sum.inr 0) else\n          if hy\u2083 : j.val = y\u2083 then Sum.inr (Sum.inl ()) else\n          (j.property.elim (by simp_all) hj\u2082).elim\n        )\n      )\n    \u27e9,\n    IsUnit D_\u2081 \u2227 D_\u2081 = D_\u2082 -- the matrix `D_\u2081 = D_\u2082` (called D-bar in the book) is invertible\n    \u2227 M\u2081.B \u27e8x\u2081, x\u2081inX\u2081\u27e9 \u27e8y\u2081, y\u2081inY\u2081\u27e9 = 1\n    \u2227 M\u2081.B \u27e8x\u2081, x\u2081inX\u2081\u27e9 \u27e8y\u2082, y\u2082inY\u2081\u27e9 = 1\n    \u2227 M\u2081.B \u27e8x\u2082, x\u2082inX\u2081\u27e9 \u27e8y\u2083, y\u2083inY\u2081\u27e9 = 1\n    \u2227 M\u2081.B \u27e8x\u2083, x\u2083inX\u2081\u27e9 \u27e8y\u2083, y\u2083inY\u2081\u27e9 = 1\n    \u2227 M\u2082.B \u27e8x\u2081, x\u2081inX\u2082\u27e9 \u27e8y\u2081, y\u2081inY\u2082\u27e9 = 1\n    \u2227 M\u2082.B \u27e8x\u2081, x\u2081inX\u2082\u27e9 \u27e8y\u2082, y\u2082inY\u2082\u27e9 = 1\n    \u2227 M\u2082.B \u27e8x\u2082, x\u2082inX\u2082\u27e9 \u27e8y\u2083, y\u2083inY\u2082\u27e9 = 1\n    \u2227 M\u2082.B \u27e8x\u2083, x\u2083inX\u2082\u27e9 \u27e8y\u2083, y\u2083inY\u2082\u27e9 = 1\n    \u2227 (\u2200 x : \u03b1, \u2200 hx : x \u2208 M\u2081.X, x \u2260 x\u2082 \u2227 x \u2260 x\u2083 \u2192 M\u2081.B \u27e8x, hx\u27e9 \u27e8y\u2083, y\u2083inY\u2081\u27e9 = 0) -- the rest of the rightmost column is `0`s\n    \u2227 (\u2200 y : \u03b1, \u2200 hy : y \u2208 M\u2082.Y, y \u2260 y\u2082 \u2227 y \u2260 y\u2081 \u2192 M\u2082.B \u27e8x\u2081, x\u2081inX\u2082\u27e9 \u27e8y, hy\u27e9 = 0) -- the rest of the topmost row is `0`s\n  \u27e9\n\n/-- Binary matroid `M` is a result of 3-summing `M\u2081` and `M\u2082` in some way. -/\ndef StandardRepresentation.Is3sumOf (M : StandardRepresentation \u03b1) (M\u2081 M\u2082 : StandardRepresentation \u03b1) : Prop :=\n  \u2203 x\u2081 x\u2082 x\u2083 y\u2081 y\u2082 y\u2083 : \u03b1,\n    \u2203 hXX : M\u2081.X \u2229 M\u2082.X = {x\u2081, x\u2082, x\u2083}, \u2203 hYY : M\u2081.Y \u2229 M\u2082.Y = {y\u2081, y\u2082, y\u2083}, \u2203 hXY : M\u2081.X \u2ad7 M\u2082.Y, \u2203 hYX : M\u2081.Y \u2ad7 M\u2082.X,\n      let M\u2080 := StandardRepresentation_3sum hXX hYY hXY hYX\n      M.toMatroid = M\u2080.fst.toMatroid \u2227 M\u2080.snd\n\nvariable {M : StandardRepresentation \u03b1}\n\n-- API for access to individual assumptions and identities in the definition of 3-sum\n\nlemma StandardRepresentation.Is3sumOf.interXX (hM : M.Is3sumOf M\u2081 M\u2082) :\n    \u2203 x\u2081 x\u2082 x\u2083 : \u03b1, M\u2081.X \u2229 M\u2082.X = {x\u2081, x\u2082, x\u2083} := by\n  obtain \u27e8x\u2081, x\u2082, x\u2083, -, -, -, hXX, -\u27e9 := hM\n  exact \u27e8x\u2081, x\u2082, x\u2083, hXX\u27e9\n\nlemma StandardRepresentation.Is3sumOf.interYY (hM : M.Is3sumOf M\u2081 M\u2082) :\n    \u2203 y\u2081 y\u2082 y\u2083 : \u03b1, M\u2081.Y \u2229 M\u2082.Y = {y\u2081, y\u2082, y\u2083} := by\n  obtain \u27e8-, -, -, y\u2081, y\u2082, y\u2083, -, hYY, -\u27e9 := hM\n  exact \u27e8y\u2081, y\u2082, y\u2083, hYY\u27e9\n\nlemma StandardRepresentation.Is3sumOf.disjoXY (hM : M.Is3sumOf M\u2081 M\u2082) :\n    M\u2081.X \u2ad7 M\u2082.Y := by\n  obtain \u27e8-, -, -, -, -, -, -, -, hXY, -\u27e9 := hM\n  exact hXY\n\nlemma StandardRepresentation.Is3sumOf.disjoYX (hM : M.Is3sumOf M\u2081 M\u2082) :\n    M\u2081.Y \u2ad7 M\u2082.X := by\n  obtain \u27e8-, -, -, -, -, -, -, -, -, hYX, -\u27e9 := hM\n  exact hYX\n\n", "theoremStatement": "lemma StandardRepresentation.Is3sumOf.indep (hM : M.Is3sumOf M\u2081 M\u2082) :\n    \u2203 x\u2081 x\u2082 x\u2083 y\u2081 y\u2082 y\u2083 : \u03b1,\n    \u2203 x\u2081inX\u2081 : x\u2081 \u2208 M\u2081.X,\n    \u2203 x\u2082inX\u2081 : x\u2082 \u2208 M\u2081.X,\n    \u2203 x\u2082inX\u2082 : x\u2082 \u2208 M\u2082.X,\n    \u2203 x\u2083inX\u2081 : x\u2083 \u2208 M\u2081.X,\n    \u2203 x\u2083inX\u2082 : x\u2083 \u2208 M\u2082.X,\n    \u2203 y\u2083inY\u2082 : y\u2083 \u2208 M\u2082.Y,\n    \u2203 y\u2082inY\u2081 : y\u2082 \u2208 M\u2081.Y,\n    \u2203 y\u2082inY\u2082 : y\u2082 \u2208 M\u2082.Y,\n    \u2203 y\u2081inY\u2081 : y\u2081 \u2208 M\u2081.Y,\n    \u2203 y\u2081inY\u2082 : y\u2081 \u2208 M\u2082.Y,\n      let A\u2081 : Matrix (M\u2081.X \\ {x\u2081, x\u2082, x\u2083}).Elem ((M\u2081.Y \\ {y\u2081, y\u2082, y\u2083}).Elem \u2295 Fin 2) Z2 := -- the top left submatrix\n        Matrix.of (fun i j => M\u2081.B\n            \u27e8i.val, Set.mem_of_mem_diff i.property\u27e9\n            (j.casesOn (fun j' => \u27e8j'.val, Set.mem_of_mem_diff j'.property\u27e9) ![\u27e8y\u2082, y\u2082inY\u2081\u27e9, \u27e8y\u2081, y\u2081inY\u2081\u27e9]))\n      let A\u2082 : Matrix (Fin 2 \u2295 (M\u2082.X \\ {x\u2081, x\u2082, x\u2083}).Elem) (M\u2082.Y \\ {y\u2081, y\u2082, y\u2083}).Elem Z2 := -- the bottom right submatrix\n        Matrix.of (fun i j => M\u2082.B\n            (i.casesOn ![\u27e8x\u2082, x\u2082inX\u2082\u27e9, \u27e8x\u2083, x\u2083inX\u2082\u27e9] (fun i' => \u27e8i'.val, Set.mem_of_mem_diff i'.property\u27e9))\n            \u27e8j.val, Set.mem_of_mem_diff j.property\u27e9)\n      let z\u2081 : (M\u2081.Y \\ {y\u2081, y\u2082, y\u2083}).Elem \u2192 Z2 := -- the middle left \"row vector\"\n        (fun j => M\u2081.B \u27e8x\u2081, x\u2081inX\u2081\u27e9 \u27e8j.val, Set.mem_of_mem_diff j.property\u27e9)\n      let z\u2082 : (M\u2082.X \\ {x\u2081, x\u2082, x\u2083}).Elem \u2192 Z2 := -- the bottom middle \"column vector\"\n        (fun i => M\u2082.B \u27e8i.val, Set.mem_of_mem_diff i.property\u27e9 \u27e8y\u2083, y\u2083inY\u2082\u27e9)\n      let D_\u2081 : Matrix (Fin 2) (Fin 2) Z2 := -- the bottom middle 2x2 submatrix\n        Matrix.of (fun i j => M\u2081.B (![\u27e8x\u2082, x\u2082inX\u2081\u27e9, \u27e8x\u2083, x\u2083inX\u2081\u27e9] i) (![\u27e8y\u2082, y\u2082inY\u2081\u27e9, \u27e8y\u2081, y\u2081inY\u2081\u27e9] j))\n      let D\u2081 : Matrix (Fin 2) (M\u2081.Y \\ {y\u2081, y\u2082, y\u2083}).Elem Z2 := -- the bottom left submatrix\n        Matrix.of (fun i j => M\u2081.B (![\u27e8x\u2082, x\u2082inX\u2081\u27e9, \u27e8x\u2083, x\u2083inX\u2081\u27e9] i) \u27e8j.val, Set.mem_of_mem_diff j.property\u27e9)\n      let D\u2082 : Matrix (M\u2082.X \\ {x\u2081, x\u2082, x\u2083}).Elem (Fin 2) Z2 := -- the bottom left submatrix\n        Matrix.of (fun i j => M\u2082.B \u27e8i.val, Set.mem_of_mem_diff i.property\u27e9 (![\u27e8y\u2082, y\u2082inY\u2082\u27e9, \u27e8y\u2081, y\u2081inY\u2082\u27e9] j))\n      (Matrix.of (\n        fun i : ((M\u2081.X \\ {x\u2081, x\u2082, x\u2083}) \u222a M\u2082.X).Elem =>\n        fun j : (M\u2081.Y \u222a (M\u2082.Y \\ {y\u2081, y\u2082, y\u2083})).Elem =>\n          Matrix_3sumComposition A\u2081 A\u2082 z\u2081 z\u2082 D_\u2081 D\u2081 D\u2082 (\n            if hi\u2081 : i.val \u2208 M\u2081.X \\ {x\u2081, x\u2082, x\u2083} then Sum.inl (Sum.inl \u27e8i, hi\u2081\u27e9) else\n            if hi\u2082 : i.val \u2208 M\u2082.X \\ {x\u2081, x\u2082, x\u2083} then Sum.inr (Sum.inr \u27e8i, hi\u2082\u27e9) else\n            if hx\u2081 : i.val = x\u2081 then Sum.inl (Sum.inr ()) else\n            if hx\u2082 : i.val = x\u2082 then Sum.inr (Sum.inl 0) else\n            if hx\u2083 : i.val = x\u2083 then Sum.inr (Sum.inl 1) else\n            (i.property.elim hi\u2081 (by simp_all)).elim\n          ) (\n            if hj\u2081 : j.val \u2208 M\u2081.Y \\ {y\u2081, y\u2082, y\u2083} then Sum.inl (Sum.inl \u27e8j, hj\u2081\u27e9) else\n            if hj\u2082 : j.val \u2208 M\u2082.Y \\ {y\u2081, y\u2082, y\u2083} then Sum.inr (Sum.inr \u27e8j, hj\u2082\u27e9) else\n            if hy\u2081 : j.val = y\u2081 then Sum.inl (Sum.inr 1) else\n            if hy\u2082 : j.val = y\u2082 then Sum.inl (Sum.inr 0) else\n            if hy\u2083 : j.val = y\u2083 then Sum.inr (Sum.inl ()) else\n            (j.property.elim (by simp_all) hj\u2082).elim\n          )\n        )\n      ).IndepCols =\n    M.toMatroid.Indep ", "theoremName": "StandardRepresentation.Is3sumOf.indep", "fileCreated": {"commit": "614ecc7fe89749171933326a0f077e8d8a24cecb", "date": "2025-02-03"}, "theoremCreated": {"commit": "74722a3f54befb275eb7729e168db1478932de5e", "date": "2024-12-05"}, "file": "Seymour/Seymour/Matroid/Operations/MatrixSums/Sum3.lean", "module": "Seymour.Matroid.Operations.MatrixSums.Sum3", "jsonFile": "Seymour.Matroid.Operations.MatrixSums.Sum3.jsonl", "positionMetadata": {"lineInFile": 137, "tokenPositionInFile": 7640, "theoremPositionInFile": 7}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 12, "numPremises": 117}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  obtain \u27e8x\u2081, x\u2082, x\u2083, y\u2081, y\u2082, y\u2083, hXX, hYY, _, _, hMM, -\u27e9 := hM\n  have hxxx\u2081 : {x\u2081, x\u2082, x\u2083} \u2286 M\u2081.X := hXX.symm.subset.trans Set.inter_subset_left\n  have hxxx\u2082 : {x\u2081, x\u2082, x\u2083} \u2286 M\u2082.X := hXX.symm.subset.trans Set.inter_subset_right\n  have hyyy\u2081 : {y\u2081, y\u2082, y\u2083} \u2286 M\u2081.Y := hYY.symm.subset.trans Set.inter_subset_left\n  have hyyy\u2082 : {y\u2081, y\u2082, y\u2083} \u2286 M\u2082.Y := hYY.symm.subset.trans Set.inter_subset_right\n  use x\u2081, x\u2082, x\u2083, y\u2081, y\u2082, y\u2083,\n    hxxx\u2081 (Set.mem_insert x\u2081 {x\u2082, x\u2083}),\n    hxxx\u2081 (Set.insert_comm x\u2081 x\u2082 {x\u2083} \u25b8 Set.mem_insert x\u2082 {x\u2081, x\u2083}),\n    hxxx\u2082 (Set.insert_comm x\u2081 x\u2082 {x\u2083} \u25b8 Set.mem_insert x\u2082 {x\u2081, x\u2083}),\n    hxxx\u2081 (by simp),\n    hxxx\u2082 (by simp),\n    hyyy\u2082 (by simp),\n    hyyy\u2081 (Set.insert_comm y\u2081 y\u2082 {y\u2083} \u25b8 Set.mem_insert y\u2082 {y\u2081, y\u2083}),\n    hyyy\u2082 (Set.insert_comm y\u2081 y\u2082 {y\u2083} \u25b8 Set.mem_insert y\u2082 {y\u2081, y\u2083}),\n    hyyy\u2081 (Set.mem_insert y\u2081 {y\u2082, y\u2083}),\n    hyyy\u2082 (Set.mem_insert y\u2081 {y\u2082, y\u2083})\n  rewrite [hMM]\n  rfl", "proofType": "tactic", "proofLengthLines": 18, "proofLengthTokens": 909}}
{"srcContext": "import Mathlib.Data.Matroid.IndepAxioms\nimport Mathlib.Data.Matroid.Dual\n\nimport Seymour.Basic\n\n\nsection Definition\n\n/-- Vector matroid `M[A]` of matrix `A`. -/\nstructure VectorMatroid (\u03b1 R : Type) where\n  /-- Row indices. -/\n  X : Type\n  /-- Column indices. -/\n  Y : Type\n  /-- Full representation matrix. -/\n  A : Matrix X Y R\n  /-- The matrix has finite number of columns. -/\n  finY : Fintype Y\n  /-- How the columns correspond to the elements of the resulting matroid. -/\n  emb : Y \u21aa \u03b1\n\nattribute [instance] VectorMatroid.finY\n\nopen scoped Matrix\n\nvariable {\u03b1 R : Type} [DecidableEq \u03b1] [Semiring R]\n\ndef VectorMatroid.E (M : VectorMatroid \u03b1 R) : Set \u03b1 :=\n  Set.range M.emb\n\n/-- A set `S` is independent in `M[A]` iff\n    `S \u2286 Y` and `S` corresponds to a linearly independent submultiset of columns in `A`. -/\ndef VectorMatroid.IndepCols (M : VectorMatroid \u03b1 R) (S : Set \u03b1) : Prop :=\n  \u2203 hS : S \u2286 M.E, LinearIndependent R (fun s : S => (M.A \u00b7 (M.emb.invOfMemRange (hS.elem s))))\n\n/-- A set `S` is independent in `M[A]` iff\n    `S \u2286 Y` and the submatrix that contains only columns of `S` has linearly independent columns. -/\nlemma VectorMatroid.indepCols_iff_submatrix (M : VectorMatroid \u03b1 R) (S : Set \u03b1) :\n    M.IndepCols S \u2194 \u2203 hS : S \u2286 M.E, LinearIndependent R (M.A.submatrix id (M.emb.invOfMemRange \u2218 hS.elem))\u1d40 := by\n  rfl\n\n", "theoremStatement": "/-- Empty set is independent. -/\ntheorem VectorMatroid.indepCols_empty (M : VectorMatroid \u03b1 R) :\n    M.IndepCols \u2205 ", "theoremName": "VectorMatroid.indepCols_empty", "fileCreated": {"commit": "b44bff2f1ee71349fa9fa251579a0f5a0e575538", "date": "2024-12-19"}, "theoremCreated": {"commit": "bf43676cb2f39b2473eb162d9b855d46616cd5a4", "date": "2025-01-08"}, "file": "Seymour/Seymour/Matroid/Constructors/VectorMatroid.lean", "module": "Seymour.Matroid.Constructors.VectorMatroid", "jsonFile": "Seymour.Matroid.Constructors.VectorMatroid.jsonl", "positionMetadata": {"lineInFile": 42, "tokenPositionInFile": 1330, "theoremPositionInFile": 3}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 8, "repositoryPremises": true, "numRepositoryPremises": 9, "numPremises": 29}, "proofMetadata": {"hasProof": true, "proof": ":=\n  \u27e8M.E.empty_subset, linearIndependent_empty_type\u27e9", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 53}}
{"srcContext": "import Seymour.Matroid.Operations.SumDelta.Basic\nimport Seymour.ForMathlib.SetTheory\n\nset_option linter.unusedVariables false\n\nvariable {\u03b1 : Type} [DecidableEq \u03b1]\n\n\nsection Basic\n\n/-- Nonempty union of disjoint circuits of `M\u2081` satisfies circuit form of `M\u2081 \u0394 M\u2082`  -/\nlemma deltaSumCircuitForm_left {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : C.Nonempty) (hCE : C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)) (hCM\u2081 : M\u2081.toMatroid.IsUnionDisjointCircuits C) :\n    DeltaSumCircuitForm M\u2081 M\u2082 C :=\n  \u27e8hC, hCE, C, \u2205, by simp, hCM\u2081, M\u2082.toMatroid.emptyUnionDisjointCircuits\u27e9\n\n/-- Nonempty union of disjoint circuits of `M\u2082` satisfies circuit form of `M\u2081 \u0394 M\u2082`  -/\nlemma deltaSumCircuitForm_right {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : C.Nonempty) (hCE : C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)) (hCM\u2082 : M\u2082.toMatroid.IsUnionDisjointCircuits C) :\n    DeltaSumCircuitForm M\u2081 M\u2082 C :=\n  \u27e8hC, hCE, \u2205, C, by simp, M\u2081.toMatroid.emptyUnionDisjointCircuits, hCM\u2082\u27e9\n\nend Basic\n\n\nsection CircuitForm1\n\n/-- Form 1 of circuits in `M\u2081 \u0394 M\u2082`: circuits of `M\u2081` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef DeltaSumCircuitForm1 (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.toMatroid.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Circuit of form 1 is a circuit in `M\u2081` -/\nlemma DeltaSumCircuitForm1.circuit_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    M\u2081.toMatroid.Circuit C :=\n  hC.left\n\n/-- Circuit of form 1 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm1.disjoint_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of form 1 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma DeltaSumCircuitForm1.subset_union {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_left hC.circuit_M\u2081.subset_ground M\u2082.E\n\n/-- Circuit of form 1 lies in ground set of `M\u2081 \u0394 M\u2082` -/\nlemma DeltaSumCircuitForm1.subset_ground {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of form 1 lies in `M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma DeltaSumCircuitForm1.subset_M\u2081_diff_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2286 M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2081.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of form 1 is disjoint with `M\u2082.E` -/\nlemma DeltaSumCircuitForm1.disjoint_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2ad7 M\u2082.E := by\n  have hMM := diff_inter_disjoint_diff_inter M\u2081.E M\u2082.E\n  have hCM\u2082 := Set.disjoint_of_subset_left hC.subset_M\u2081_diff_inter hMM\n  have hCM\u2082 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2082, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_right] at hCM\u2082\n  exact hCM\u2082\n\n/-- Circuit of form 1 satisfies circuit form of `M\u2081 \u0394 M\u2082` -/\nlemma DeltaSumCircuitForm1.circuit_form {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    DeltaSumCircuitForm M\u2081 M\u2082 C :=\n  deltaSumCircuitForm_left hC.circuit_M\u2081.nonempty hC.subset_ground hC.circuit_M\u2081.isUnionDisjointCircuits\n\n/-- If `C` satisfies circuit predicate and is a union of disjoint circuits of `M\u2081`, then `C` is a circuit of `M\u2081` -/\nlemma DeltaSumCircuitPred.udc_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (C_pred : DeltaSumCircuitPred M\u2081 M\u2082 C) (C_udc : M\u2081.toMatroid.IsUnionDisjointCircuits C) :\n    M\u2081.toMatroid.Circuit C :=\n  have \u27e8\u27e8hC, hCE, _\u27e9, hCmin\u27e9 := C_pred\n  \u27e8C_udc.nonempty_dep hC, fun D hD hDC =>\n    have \u27e8_, D', hD', hDD'\u27e9 := M\u2081.toMatroid.dep_iff_has_circuit.\u2192 hD\n    (hCmin\n        (DeltaSumCircuitForm1.circuit_form \u27e8hD', (Set.subset_diff.\u2192 ((hDD'.trans hDC).trans hCE)).right\u27e9)\n        (hDD'.trans hDC)\n      ).trans hDD'\u27e9\n\nend CircuitForm1\n\n\nsection CircuitForm2\n\n/-- Form 2 of circuits in `M\u2081 \u0394 M\u2082`: circuits of `M\u2082` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef DeltaSumCircuitForm2 (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2082.toMatroid.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Circuit of form 2 is a circuit in `M\u2081` -/\nlemma DeltaSumCircuitForm2.circuit_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    M\u2082.toMatroid.Circuit C :=\n  hC.left\n\n/-- Circuit of form 2 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm2.disjoint_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of form 2 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma DeltaSumCircuitForm2.subset_union {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_right hC.circuit_M\u2082.subset_ground M\u2081.E\n\n/-- Circuit of form 2 lies in ground set of `M\u2081 \u0394 M\u2082` -/\nlemma DeltaSumCircuitForm2.subset_ground {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of form 2 lies in `M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma DeltaSumCircuitForm2.subset_M\u2082_diff_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2286 M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2082.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of form 2 is disjoint with `M\u2082.E` -/\nlemma DeltaSumCircuitForm2.disjoint_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2ad7 M\u2081.E := by\n  have hMM := diff_inter_disjoint_diff_inter M\u2081.E M\u2082.E\n  have hCM\u2082 := Set.disjoint_of_subset_right hC.subset_M\u2082_diff_inter hMM\n  have hCM\u2082 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2082.symm, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_left] at hCM\u2082\n  exact hCM\u2082\n\n", "theoremStatement": "/-- Circuit of form 2 satisfies circuit form of `M\u2081 \u0394 M\u2082` -/\nlemma DeltaSumCircuitForm2.circuit_form {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    DeltaSumCircuitForm M\u2081 M\u2082 C ", "theoremName": "DeltaSumCircuitForm2.circuit_form", "fileCreated": {"commit": "aae07a69b2ec95e3d9a1436952a123dcb7d0d06f", "date": "2025-01-03"}, "theoremCreated": {"commit": "67629d2b74be7b972786897531b678f585a7af28", "date": "2025-02-03"}, "file": "Seymour/Seymour/Matroid/Operations/SumDelta/CircuitForms.lean", "module": "Seymour.Matroid.Operations.SumDelta.CircuitForms", "jsonFile": "Seymour.Matroid.Operations.SumDelta.CircuitForms.jsonl", "positionMetadata": {"lineInFile": 139, "tokenPositionInFile": 5787, "theoremPositionInFile": 18}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 10, "numPremises": 20}, "proofMetadata": {"hasProof": true, "proof": ":=\n  deltaSumCircuitForm_right hC.circuit_M\u2082.nonempty hC.subset_ground hC.circuit_M\u2082.isUnionDisjointCircuits", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 108}}
{"srcContext": "import Seymour.Matroid.Notions.Circuit\n\n\nvariable {\u03b1 : Type}\n\n\nsection DisjointCircuitFamily\n\n/-- Family of disjoint circuits of matroid `M`. -/\nstructure Matroid.DisjointCircuitFamily (M : Matroid \u03b1) where\n  /-- Indexing set -/\n  \u03b9 : Set \u03b1\n  -- question: upgrade from indexing by Set \u03b1 to indexing by Sort v (see Set.iUnion in Mathlib.Order.SetNotation)?\n  -- note: if we know that `C` is a disjoint union of circuits of `M`,\n  -- then wlog we can choose `\u03b9` to be set of representatives of those circuits\n  /-- Set family indexed by `\u03b9` -/\n  F : \u03b9 \u2192 Set \u03b1\n  /-- All sets in family are circuits in `M` -/\n  AllCircuits : \u2200 x : \u03b9, M.Circuit (F x)\n  /-- All sets in family are disjoint -/\n  AllDisjoint : \u2200 x y : \u03b9, x \u2260 y \u2192 F x \u2ad7 F y\n\n/-- Shorthand for union of sets in `M.DisjointCircuitFamily`. -/\ndef Matroid.DisjointCircuitFamily.union {M : Matroid \u03b1} (F : M.DisjointCircuitFamily) : Set \u03b1 :=\n  Set.iUnion F.F\n\n/-- Every element in `M.DisjointCircuitFamily` is subset of ground set. -/\nlemma Matroid.DisjointCircuitFamily.mem_subset_ground {M : Matroid \u03b1} (F : M.DisjointCircuitFamily) (x : F.\u03b9) :\n    F.F x \u2286 M.E :=\n  (F.AllCircuits x).subset_ground\n\n/-- Union of sets in `M.DisjointCircuitFamily` is subset of ground set. -/\nlemma Matroid.DisjointCircuitFamily.union_subset_ground {M : Matroid \u03b1} (F : M.DisjointCircuitFamily) :\n    F.union \u2286 M.E := by\n  simp only [Matroid.DisjointCircuitFamily.union, Set.iUnion_coe_set, Set.iUnion_subset_iff]\n  exact fun i hi => mem_subset_ground F \u27e8i, hi\u27e9\n\n/-- If union of disjoint circuits is independent, then it is empty. -/\nlemma Matroid.DisjointCircuitFamily.union_indep_empty {M : Matroid \u03b1} (F : M.DisjointCircuitFamily) (hMF : M.Indep F.union):\n    F.union = \u2205 := by\n  by_contra\n  obtain \u27e8x, -\u27e9 : \u2203 x : F.\u03b9.Elem, (F.F x).Nonempty\n  \u00b7 by_contra!\n    simp_all only [Matroid.DisjointCircuitFamily.union, Set.iUnion_coe_set, Set.iUnion_empty, not_true_eq_false]\n  exact (F.AllCircuits x).left.not_indep (hMF.subset (Set.subset_iUnion_of_subset x Set.Subset.rfl))\n\n", "theoremStatement": "/-- Nonempty union of disjoint circuits is dependent. -/\nlemma Matroid.DisjointCircuitFamily.union_nonempty_dep {M : Matroid \u03b1} (F : M.DisjointCircuitFamily) (hF : F.union.Nonempty) :\n    M.Dep F.union ", "theoremName": "Matroid.DisjointCircuitFamily.union_nonempty_dep", "fileCreated": {"commit": "67629d2b74be7b972786897531b678f585a7af28", "date": "2025-02-03"}, "theoremCreated": {"commit": "43c746e51146ac13aa709eefe36b9f185633ea8b", "date": "2025-02-03"}, "file": "Seymour/Seymour/Matroid/Notions/DisjointCircuitFamily.lean", "module": "Seymour.Matroid.Notions.DisjointCircuitFamily", "jsonFile": "Seymour.Matroid.Notions.DisjointCircuitFamily.jsonl", "positionMetadata": {"lineInFile": 47, "tokenPositionInFile": 2011, "theoremPositionInFile": 4}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 4, "numPremises": 16}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  by_contra contr\n  exact Set.not_nonempty_empty (F.union_indep_empty (Matroid.indep_of_not_dep contr F.union_subset_ground) \u25b8 hF)", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 136}}
{"srcContext": "import Mathlib.Data.Set.Card\nimport Mathlib.Data.Matroid.Dual\n\nimport Seymour.ForMathlib.SetTheory\nimport Seymour.Matroid.Notions.Circuit\nimport Seymour.Matroid.Notions.CircuitAxioms\nimport Seymour.Matroid.Notions.Connectivity\nimport Seymour.Matroid.Constructors.CircuitMatroid\n\n/-!\nThis file defines 2-sum of two (general) matroids `M\u2081` and `M\u2082`, denoted as `M\u2081 \u2295\u2082 M\u2082`.\n-/\n\nvariable {\u03b1 : Type}\n\n\nsection MainDefinitions\n\n/-- `M\u2081 \u2295\u2082 M\u2082` is defined if `M\u2081` and `M\u2082` satisfy the following assumptions -/\nstructure TwoSumAssumptions (M\u2081 M\u2082 : Matroid \u03b1) : Prop where\n  /-- `M\u2081` is finite -/\n  M\u2081fin : M\u2081.Finite\n  /-- `M\u2082` is finite -/\n  M\u2082fin : M\u2082.Finite\n  /-- `M\u2081` contains at least 2 elements -/\n  M\u2081card : M\u2081.E.encard \u2265 2\n  /-- `M\u2082` contains at least 2 elements -/\n  M\u2082card : M\u2082.E.encard \u2265 2\n  /-- `M\u2081` and `M\u2082` have exactly one element in common -/\n  interSingleton : (M\u2081.E \u2229 M\u2082.E).encard = 1\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2081` -/\n  M\u2081sep : \u00acM\u2081.Separator (M\u2081.E \u2229 M\u2082.E)\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2082` -/\n  M\u2082sep : \u00acM\u2082.Separator (M\u2081.E \u2229 M\u2082.E)\n\n-- question: can avoid this assumption? -- which assumption? the finiteness?\n\n/-- Ground set of `M\u2081 \u2295\u2082 M\u2082` -/\ndef twoSumGround (M\u2081 M\u2082 : Matroid \u03b1) : Set \u03b1 :=\n  (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)\n\n/-- Type 1 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2081` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType1 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 2 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2082` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType2 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2082.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 3 of circuits in `M\u2081 \u2295\u2082 M\u2082`:\n    sets `(C\u2081 \u222a C\u2082) \\ (M\u2081.E \u2229 M\u2082.E)` where `C\u2081` and `C\u2082` are circuits in `M\u2081` and `M\u2082`, respectively,\n    and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2081` and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2082` -/\ndef TwoSumCircuitType3 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit ((C \u2229 M\u2081.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 M\u2082.Circuit ((C \u2229 M\u2082.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 C \u2286 twoSumGround M\u2081 M\u2082\n\n/-- Circuit predicate of `M\u2081 \u2295\u2082 M\u2082`, which defines 2-sum as `CircuitMatroid` -/\ndef TwoSumCircuitPred (M\u2081 M\u2082 : Matroid \u03b1) : CircuitPredicate \u03b1 :=\n  fun C : Set \u03b1 =>\n    TwoSumCircuitType1 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType2 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType3 M\u2081 M\u2082 C\n\nend MainDefinitions\n\n\nsection PropertiesAssumptions\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1}\n\n/-- 2-sum assumptions are symmetric -/\nlemma TwoSumAssumptions.symm (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    TwoSumAssumptions M\u2082 M\u2081 :=\n  \u27e8\n    assumptions.M\u2082fin,\n    assumptions.M\u2081fin,\n    assumptions.M\u2082card,\n    assumptions.M\u2081card,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.interSingleton,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2082sep,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2081sep,\n  \u27e9\n\n/-- Intersection of ground sets is nonempty -/\nlemma TwoSumAssumptions.inter_nonempty (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (M\u2081.E \u2229 M\u2082.E).Nonempty :=\n  Set.one_le_encard_iff_nonempty.\u2192 assumptions.interSingleton.symm.le\n\n/-- Intersection of ground sets is a singleton set -/\nlemma TwoSumAssumptions.inter_singleton (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    \u2203 p : \u03b1, M\u2081.E \u2229 M\u2082.E = {p} :=\n  Set.encard_eq_one.\u2192 assumptions.interSingleton\n\nvariable {p : \u03b1}\n\n/-- Singleton element in intersection of ground sets in not a loop in `M\u2081` -/\nlemma TwoSumAssumptions.inter_singleton_not_loop_M\u2081 (assumptions : TwoSumAssumptions M\u2081 M\u2082)\n    (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2081.Loop p) :=\n  (hp \u25b8 assumptions.M\u2081sep <| Matroid.separator_loop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a coloop in `M\u2081` -/\nlemma TwoSumAssumptions.inter_singleton_not_coloop_M\u2081 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2081.Coloop p) :=\n  (hp \u25b8 assumptions.M\u2081sep <| Matroid.separator_coloop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a loop in `M\u2082` -/\nlemma TwoSumAssumptions.inter_singleton_not_loop_M\u2082 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2082.Loop p) :=\n  (hp \u25b8 assumptions.M\u2082sep <| Matroid.separator_loop \u00b7)\n\n", "theoremStatement": "/-- Singleton element in intersection of ground sets in not a coloop in `M\u2082` -/\nlemma TwoSumAssumptions.inter_singleton_not_coloop_M\u2082 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2082.Coloop p) ", "theoremName": "TwoSumAssumptions.inter_singleton_not_coloop_M\u2082", "fileCreated": {"commit": "d0eaaa305c96cd81ac061f505a81614db6856b21", "date": "2025-01-09"}, "theoremCreated": {"commit": "439c72996f29168161b974bc602629cac773728f", "date": "2025-01-08"}, "file": "Seymour/Seymour/Matroid/Operations/Sum2/Basic.lean", "module": "Seymour.Matroid.Operations.Sum2.Basic", "jsonFile": "Seymour.Matroid.Operations.Sum2.Basic.jsonl", "positionMetadata": {"lineInFile": 111, "tokenPositionInFile": 4108, "theoremPositionInFile": 11}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 5, "numPremises": 15}, "proofMetadata": {"hasProof": true, "proof": ":=\n  (hp \u25b8 assumptions.M\u2082sep <| Matroid.separator_coloop \u00b7)", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 59}}
{"srcContext": "import Seymour.Matroid.Notions.Circuit\n\n\nvariable {\u03b1 : Type}\n\n\nsection DisjointCircuitFamily\n\n/-- Family of disjoint circuits of matroid `M`. -/\nstructure Matroid.DisjointCircuitFamily (M : Matroid \u03b1) where\n  /-- Indexing set -/\n  \u03b9 : Set \u03b1\n  -- question: upgrade from indexing by Set \u03b1 to indexing by Sort v (see Set.iUnion in Mathlib.Order.SetNotation)?\n  -- note: if we know that `C` is a disjoint union of circuits of `M`,\n  -- then wlog we can choose `\u03b9` to be set of representatives of those circuits\n  /-- Set family indexed by `\u03b9` -/\n  F : \u03b9 \u2192 Set \u03b1\n  /-- All sets in family are circuits in `M` -/\n  AllCircuits : \u2200 x : \u03b9, M.Circuit (F x)\n  /-- All sets in family are disjoint -/\n  AllDisjoint : \u2200 x y : \u03b9, x \u2260 y \u2192 F x \u2ad7 F y\n\n/-- Shorthand for union of sets in `M.DisjointCircuitFamily`. -/\ndef Matroid.DisjointCircuitFamily.union {M : Matroid \u03b1} (F : M.DisjointCircuitFamily) : Set \u03b1 :=\n  Set.iUnion F.F\n\n/-- Every element in `M.DisjointCircuitFamily` is subset of ground set. -/\nlemma Matroid.DisjointCircuitFamily.mem_subset_ground {M : Matroid \u03b1} (F : M.DisjointCircuitFamily) (x : F.\u03b9) :\n    F.F x \u2286 M.E :=\n  (F.AllCircuits x).subset_ground\n\n/-- Union of sets in `M.DisjointCircuitFamily` is subset of ground set. -/\nlemma Matroid.DisjointCircuitFamily.union_subset_ground {M : Matroid \u03b1} (F : M.DisjointCircuitFamily) :\n    F.union \u2286 M.E := by\n  simp only [Matroid.DisjointCircuitFamily.union, Set.iUnion_coe_set, Set.iUnion_subset_iff]\n  exact fun i hi => mem_subset_ground F \u27e8i, hi\u27e9\n\n/-- If union of disjoint circuits is independent, then it is empty. -/\nlemma Matroid.DisjointCircuitFamily.union_indep_empty {M : Matroid \u03b1} (F : M.DisjointCircuitFamily) (hMF : M.Indep F.union):\n    F.union = \u2205 := by\n  by_contra\n  obtain \u27e8x, -\u27e9 : \u2203 x : F.\u03b9.Elem, (F.F x).Nonempty\n  \u00b7 by_contra!\n    simp_all only [Matroid.DisjointCircuitFamily.union, Set.iUnion_coe_set, Set.iUnion_empty, not_true_eq_false]\n  exact (F.AllCircuits x).left.not_indep (hMF.subset (Set.subset_iUnion_of_subset x Set.Subset.rfl))\n\n/-- Nonempty union of disjoint circuits is dependent. -/\nlemma Matroid.DisjointCircuitFamily.union_nonempty_dep {M : Matroid \u03b1} (F : M.DisjointCircuitFamily) (hF : F.union.Nonempty) :\n    M.Dep F.union := by\n  by_contra contr\n  exact Set.not_nonempty_empty (F.union_indep_empty (Matroid.indep_of_not_dep contr F.union_subset_ground) \u25b8 hF)\n\n/-- Union of disjoint circuits is either dependent or empty. -/\nlemma Matroid.DisjointCircuitFamily.dep_or_empty {M : Matroid \u03b1} (F : M.DisjointCircuitFamily) :\n    M.Dep F.union \u2228 F.union = \u2205 := by\n  if hMF : M.Indep F.union then\n    exact Or.inr (F.union_indep_empty hMF)\n  else\n    exact Or.inl \u27e8hMF, F.union_subset_ground\u27e9\n\n/-- Empty family of disjoint circuits. -/\ndef Matroid.emptyDisjointCircuitFamily (M : Matroid \u03b1) :\n    M.DisjointCircuitFamily where\n  \u03b9 := \u2205\n  F _ := \u2205\n  AllCircuits x := x.property.elim\n  AllDisjoint x := x.property.elim\n\n/-- Union of sets in empty family is empty. -/\nlemma Matroid.emptyDisjointCircuitFamily_union (M : Matroid \u03b1) :\n    M.emptyDisjointCircuitFamily.union = \u2205 :=\n  Set.iUnion_empty\n\n/-- Family of one circuit, indexed by one element --- that circuit. -/\ndef Matroid.Circuit.singleDisjointCircuitFamily {M : Matroid \u03b1} {C : Set \u03b1} (hC : M.Circuit C) (p : \u03b1) :\n    M.DisjointCircuitFamily where\n  \u03b9 := {p}\n  F _ := C\n  AllCircuits _ := hC\n  AllDisjoint x y hxy := ((x.property \u25b8 y.property \u25b8 Subtype.coe_ne_coe.\u2190 hxy) rfl).elim\n\n/-- Union of sets in family of one circuit is that circuit. -/\nlemma Matroid.Circuit.singleDisjointCircuitFamily_union {M : Matroid \u03b1} {C : Set \u03b1} (hC : M.Circuit C) (p : \u03b1) :\n    (hC.singleDisjointCircuitFamily p).union = C := by\n  simp only [Matroid.Circuit.singleDisjointCircuitFamily, Matroid.DisjointCircuitFamily.union, Set.iUnion_coe_set,\n    Set.mem_singleton_iff, Set.iUnion_iUnion_eq_left]\n\nend DisjointCircuitFamily\n\n\nsection UnionDisjointCircuits\n\n/-- Set `C` can be represented as disjoint union of circuits of `M`. -/\ndef Matroid.IsUnionDisjointCircuits (M : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  \u2203 F : M.DisjointCircuitFamily, F.union = C\n\n/-- Empty set is disjoint union of circuits. -/\nlemma Matroid.emptyUnionDisjointCircuits (M : Matroid \u03b1) :\n    M.IsUnionDisjointCircuits \u2205 :=\n  \u27e8M.emptyDisjointCircuitFamily, M.emptyDisjointCircuitFamily_union\u27e9\n\n/-- If union of disjoint circuits is independent, then it is empty. -/\nlemma Matroid.IsUnionDisjointCircuits.indep_empty {M : Matroid \u03b1} {X : Set \u03b1}\n    (hMX : M.IsUnionDisjointCircuits X) (hMX' : M.Indep X) :\n    X = \u2205 :=\n  have \u27e8F, hXF\u27e9 := hMX\n  F.union_indep_empty (hXF \u25b8 hMX') \u25b8 hXF.symm\n\n/-- Nonempty union of disjoint circuits is dependent. -/\nlemma Matroid.IsUnionDisjointCircuits.nonempty_dep {M : Matroid \u03b1} {X : Set \u03b1}\n    (hMX : M.IsUnionDisjointCircuits X) (hX : X.Nonempty) :\n    M.Dep X :=\n  have \u27e8F, hXF\u27e9 := hMX\n  hXF \u25b8 F.union_nonempty_dep (hXF \u25b8 hX)\n\n/-- Union of disjoint circuits is either dependent or empty. -/\nlemma Matroid.IsUnionDisjointCircuits.dep_or_empty {M : Matroid \u03b1} {X : Set \u03b1} (hMX : M.IsUnionDisjointCircuits X) :\n    M.Dep X \u2228 X = \u2205 :=\n  have \u27e8F, hXF\u27e9 := hMX\n  hXF \u25b8 F.dep_or_empty\n\n", "theoremStatement": "/-- One circuit is disjoint union of circuits. -/\nlemma Matroid.Circuit.isUnionDisjointCircuits {M : Matroid \u03b1} {C : Set \u03b1} (hC : M.Circuit C) :\n    M.IsUnionDisjointCircuits C ", "theoremName": "Matroid.Circuit.isUnionDisjointCircuits", "fileCreated": {"commit": "67629d2b74be7b972786897531b678f585a7af28", "date": "2025-02-03"}, "theoremCreated": {"commit": "1a6d79dfb5649dbdf07194ae0bd21376f5682084", "date": "2025-01-07"}, "file": "Seymour/Seymour/Matroid/Notions/DisjointCircuitFamily.lean", "module": "Seymour.Matroid.Notions.DisjointCircuitFamily", "jsonFile": "Seymour.Matroid.Notions.DisjointCircuitFamily.jsonl", "positionMetadata": {"lineInFile": 122, "tokenPositionInFile": 5108, "theoremPositionInFile": 13}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 5, "repositoryPremises": true, "numRepositoryPremises": 7, "numPremises": 15}, "proofMetadata": {"hasProof": true, "proof": ":=\n  have \u27e8x, _\u27e9 := hC.nonempty\n  \u27e8hC.singleDisjointCircuitFamily x, hC.singleDisjointCircuitFamily_union x\u27e9", "proofType": "term", "proofLengthLines": 2, "proofLengthTokens": 108}}
{"srcContext": "import Seymour.Matroid.Notions.Circuit\nimport Seymour.Matroid.Notions.Loop\nimport Seymour.Matroid.Notions.Coloop\n\n\nvariable {\u03b1 : Type}\n\nsection SimpleConnectivity\n\n/-- The connectivity relation, aka \u03be in Oxley's book -/\ndef Matroid.ConnectivityRelation (M : Matroid \u03b1) (e f : \u03b1) : Prop :=\n  e = f \u2228 \u2203 C : Set \u03b1, C \u2286 M.E \u2227 M.Circuit C \u2227 e \u2208 C \u2227 f \u2208 C\n\n/-- The connectivity relation is reflexive -/\n@[refl]\nlemma Matroid.ConnectivityRelation.refl (M : Matroid \u03b1) {e : \u03b1} :\n    M.ConnectivityRelation e e :=\n  Or.inl rfl\n\n/-- The connectivity relation is symmetric -/\n@[symm]\nlemma Matroid.ConnectivityRelation.symm (M : Matroid \u03b1) {e f : \u03b1} :\n    M.ConnectivityRelation e f \u2192 M.ConnectivityRelation f e := by\n  intro hef\n  cases hef with\n  | inl hef => exact Or.inl hef.symm\n  | inr hef =>\n    right\n    obtain \u27e8C, _, _, _, _\u27e9 := hef\n    use C\n\n/-- The connectivity relation is transitive -/\n@[trans]\nlemma Matroid.ConnectivityRelation.trans (M : Matroid \u03b1) {e f g : \u03b1} :\n    M.ConnectivityRelation e f \u2192 M.ConnectivityRelation f g \u2192 M.ConnectivityRelation e g := by\n  intro hef hfg\n  cases hef with\n  | inl hef => exact hef \u25b8 hfg\n  | inr hef =>\n    cases hfg with\n    | inl hfg => exact Or.inr (hfg \u25b8 hef)\n    | inr hfg =>\n      obtain \u27e8C\u2081, hC\u2081, hMC\u2081, heC\u2081, hfC\u2081\u27e9 := hef\n      obtain \u27e8C\u2082, hC\u2082, hMC\u2082, hfC\u2082, hgC\u2082\u27e9 := hfg\n      right\n      -- todo: see proof of Lemma 7 in Bruhn Wollman 2011 (page 5)\n      -- note: that proof uses matroid contraction\n      sorry\n\n/-- A component is an equivalence class under the connectivity relation, i.e., a \u03be-equivalence class -/\ndef Matroid.Component (M : Matroid \u03b1) (X : Set \u03b1) : Prop :=\n  \u2200 e \u2208 X, \u2200 f \u2208 M.E, M.ConnectivityRelation e f \u2194 f \u2208 X\n\n/-- A separator is a union of components -/\ndef Matroid.Separator (M : Matroid \u03b1) (X : Set \u03b1) : Prop :=\n  \u2200 e \u2208 X, \u2200 f \u2208 M.E, M.ConnectivityRelation e f \u2192 f \u2208 X\n\n/-- Every component is a separator -/\nlemma Matroid.separator_component (M : Matroid \u03b1) {X : Set \u03b1} (hX : M.Component X) :\n    M.Separator X :=\n  fun e he f hf hef => (hX e he f hf).\u2192 hef\n\n", "theoremStatement": "/-- Every loop is a separator -/\nlemma Matroid.separator_loop {M : Matroid \u03b1} {x : \u03b1} (hx : M.Loop x) :\n    M.Separator {x} ", "theoremName": "Matroid.separator_loop", "fileCreated": {"commit": "b44bff2f1ee71349fa9fa251579a0f5a0e575538", "date": "2024-12-19"}, "theoremCreated": {"commit": "f9d717ecfb54b3a7b794411b4c1af1f5c8ffb7c3", "date": "2024-12-26"}, "file": "Seymour/Seymour/Matroid/Notions/Connectivity.lean", "module": "Seymour.Matroid.Notions.Connectivity", "jsonFile": "Seymour.Matroid.Notions.Connectivity.jsonl", "positionMetadata": {"lineInFile": 63, "tokenPositionInFile": 2034, "theoremPositionInFile": 7}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 6, "numPremises": 39}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  intro e hex f hfE hf\n  cases hf with\n  | inl hef => exact Set.mem_of_eq_of_mem hef.symm hex\n  | inr hfC =>\n    obtain \u27e8C, hCE, circC, heC, hfC\u27e9 := hfC\n    rw [hex, \u2190Set.singleton_subset_iff] at heC\n    rw [Matroid.loop_iff_circuit] at hx\n    apply Matroid.Circuit.not_ssubset_circuit hx at circC\n    rw [Set.ssubset_def] at circC\n    push_neg at circC\n    exact circC heC hfC", "proofType": "tactic", "proofLengthLines": 11, "proofLengthTokens": 383}}
{"srcContext": "import Mathlib.LinearAlgebra.Matrix.Determinant.TotallyUnimodular\nimport Seymour.ForMathlib.Basic\nimport Seymour.ForMathlib.FunctionDecompose\n\n\nvariable {X\u2081 X\u2082 Z R : Type}\n\n", "theoremStatement": "lemma Matrix.IsTotallyUnimodular.comp_rows [CommRing R] {A : Matrix X\u2081 X\u2082 R}\n    (hA : A.IsTotallyUnimodular) (e : Z \u2192 X\u2081) :\n    Matrix.IsTotallyUnimodular (A \u2218 e) ", "theoremName": "Matrix.IsTotallyUnimodular.comp_rows", "fileCreated": {"commit": "0d6d3e28dde67309db0ac43d0d4fd6f74f500560", "date": "2024-11-03"}, "theoremCreated": {"commit": "d168101cdc0e5416bc0db8fd409e3a139171eed4", "date": "2024-12-20"}, "file": "Seymour/Seymour/ForMathlib/MatrixTU.lean", "module": "Seymour.ForMathlib.MatrixTU", "jsonFile": "Seymour.ForMathlib.MatrixTU.jsonl", "positionMetadata": {"lineInFile": 8, "tokenPositionInFile": 173, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 39}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [Matrix.isTotallyUnimodular_iff] at hA \u22a2\n  intro k f g\n  exact hA k (e \u2218 f) g", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 88}}
{"srcContext": "import Mathlib.Data.Set.Card\nimport Mathlib.Data.Matroid.Dual\n\nimport Seymour.ForMathlib.SetTheory\nimport Seymour.Matroid.Notions.Circuit\nimport Seymour.Matroid.Notions.CircuitAxioms\nimport Seymour.Matroid.Notions.Connectivity\nimport Seymour.Matroid.Constructors.CircuitMatroid\n\n/-!\nThis file defines 2-sum of two (general) matroids `M\u2081` and `M\u2082`, denoted as `M\u2081 \u2295\u2082 M\u2082`.\n-/\n\nvariable {\u03b1 : Type}\n\n\nsection MainDefinitions\n\n/-- `M\u2081 \u2295\u2082 M\u2082` is defined if `M\u2081` and `M\u2082` satisfy the following assumptions -/\nstructure TwoSumAssumptions (M\u2081 M\u2082 : Matroid \u03b1) : Prop where\n  /-- `M\u2081` is finite -/\n  M\u2081fin : M\u2081.Finite\n  /-- `M\u2082` is finite -/\n  M\u2082fin : M\u2082.Finite\n  /-- `M\u2081` contains at least 2 elements -/\n  M\u2081card : M\u2081.E.encard \u2265 2\n  /-- `M\u2082` contains at least 2 elements -/\n  M\u2082card : M\u2082.E.encard \u2265 2\n  /-- `M\u2081` and `M\u2082` have exactly one element in common -/\n  interSingleton : (M\u2081.E \u2229 M\u2082.E).encard = 1\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2081` -/\n  M\u2081sep : \u00acM\u2081.Separator (M\u2081.E \u2229 M\u2082.E)\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2082` -/\n  M\u2082sep : \u00acM\u2082.Separator (M\u2081.E \u2229 M\u2082.E)\n\n-- question: can avoid this assumption? -- which assumption? the finiteness?\n\n/-- Ground set of `M\u2081 \u2295\u2082 M\u2082` -/\ndef twoSumGround (M\u2081 M\u2082 : Matroid \u03b1) : Set \u03b1 :=\n  (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)\n\n/-- Type 1 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2081` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType1 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 2 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2082` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType2 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2082.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 3 of circuits in `M\u2081 \u2295\u2082 M\u2082`:\n    sets `(C\u2081 \u222a C\u2082) \\ (M\u2081.E \u2229 M\u2082.E)` where `C\u2081` and `C\u2082` are circuits in `M\u2081` and `M\u2082`, respectively,\n    and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2081` and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2082` -/\ndef TwoSumCircuitType3 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit ((C \u2229 M\u2081.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 M\u2082.Circuit ((C \u2229 M\u2082.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 C \u2286 twoSumGround M\u2081 M\u2082\n\n/-- Circuit predicate of `M\u2081 \u2295\u2082 M\u2082`, which defines 2-sum as `CircuitMatroid` -/\ndef TwoSumCircuitPred (M\u2081 M\u2082 : Matroid \u03b1) : CircuitPredicate \u03b1 :=\n  fun C : Set \u03b1 =>\n    TwoSumCircuitType1 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType2 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType3 M\u2081 M\u2082 C\n\nend MainDefinitions\n\n\nsection PropertiesAssumptions\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1}\n\n", "theoremStatement": "/-- 2-sum assumptions are symmetric -/\nlemma TwoSumAssumptions.symm (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    TwoSumAssumptions M\u2082 M\u2081 ", "theoremName": "TwoSumAssumptions.symm", "fileCreated": {"commit": "d0eaaa305c96cd81ac061f505a81614db6856b21", "date": "2025-01-09"}, "theoremCreated": {"commit": "439c72996f29168161b974bc602629cac773728f", "date": "2025-01-08"}, "file": "Seymour/Seymour/Matroid/Operations/Sum2/Basic.lean", "module": "Seymour.Matroid.Operations.Sum2.Basic", "jsonFile": "Seymour.Matroid.Operations.Sum2.Basic.jsonl", "positionMetadata": {"lineInFile": 70, "tokenPositionInFile": 2407, "theoremPositionInFile": 5}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 9, "repositoryPremises": true, "numRepositoryPremises": 10, "numPremises": 30}, "proofMetadata": {"hasProof": true, "proof": ":=\n  \u27e8\n    assumptions.M\u2082fin,\n    assumptions.M\u2081fin,\n    assumptions.M\u2082card,\n    assumptions.M\u2081card,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.interSingleton,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2082sep,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2081sep,\n  \u27e9", "proofType": "term", "proofLengthLines": 9, "proofLengthTokens": 263}}
{"srcContext": "import Seymour.Matroid.Classes.Binary\nimport Seymour.Matroid.Constructors.CircuitMatroid\nimport Seymour.Matroid.Notions.DisjointCircuitFamily\n\n\nvariable {\u03b1 : Type}\n\n\nsection BasicDefinitions\n\n/-- Circuits in `M\u2081 \u0394 M\u2082` are nonempty subsets of the ground set of form `X\u2081 \u0394 X\u2082`\n    where `X\u2081` and `X\u2082` are disjoint unions of circuits in `M\u2081` and `M\u2082` respectively. -/\ndef DeltaSumCircuitsAux [DecidableEq \u03b1] (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C X\u2081 X\u2082 : Set \u03b1) : Prop :=\n  C = (X\u2081 \u222a X\u2082) \\ (X\u2081 \u2229 X\u2082) \u2227 M\u2081.toMatroid.IsUnionDisjointCircuits X\u2081 \u2227 M\u2082.toMatroid.IsUnionDisjointCircuits X\u2082\n\n/-- A set satisfies circuit form if for some `X\u2081` and `X\u2082` it has the form above. -/\ndef DeltaSumCircuitForm [DecidableEq \u03b1] (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C : Set \u03b1) : Prop :=\n  C.Nonempty \u2227 C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E) \u2227 \u2203 X\u2081 X\u2082 : Set \u03b1, DeltaSumCircuitsAux M\u2081 M\u2082 C X\u2081 X\u2082\n\n/-- Circuits of \u0394-sum are minimal non-empty subsets of `M\u2081.E \u0394 M\u2082.E` of the form `X\u2081 \u0394 X\u2082`\n    where `X\u2081` and `X\u2082` is a disjoint union of circuits of `M\u2081` and `M\u2082` respectively. -/\ndef DeltaSumCircuitPred [DecidableEq \u03b1] (M\u2081 M\u2082 : BinaryMatroid \u03b1) : CircuitPredicate \u03b1 :=\n  Minimal (DeltaSumCircuitForm M\u2081 M\u2082)\n\nend BasicDefinitions\n\n\nsection BasicProperties\n\n/-- A set of circuit form is nonempty. -/\nlemma deltaSumCircuitForm.nonempty [DecidableEq \u03b1] {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm M\u2081 M\u2082 C) :\n    C.Nonempty :=\n  hC.left\n\n/-- A set of circuit form is a subset of the ground set. -/\nlemma DeltaSumCircuitForm.subset_ground [DecidableEq \u03b1] {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm M\u2081 M\u2082 C) :\n    C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E) :=\n  hC.right.left\n\n/-- A set of circuit form is the symmetric difference of `X\u2081` and `X\u2082` -/\nlemma DeltaSumCircuitsAux.eq_symmDiff [DecidableEq \u03b1] {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C X\u2081 X\u2082 : Set \u03b1}\n    (hC : DeltaSumCircuitsAux M\u2081 M\u2082 C X\u2081 X\u2082) :\n    C = (X\u2081 \u222a X\u2082) \\ (X\u2081 \u2229 X\u2082) :=\n  hC.left\n\n/-- A set of circuit form is related to a union of disjoint circuits of `M\u2081` -/\nlemma DeltaSumCircuitsAux.udc_left [DecidableEq \u03b1] {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C X\u2081 X\u2082 : Set \u03b1}\n    (hC : DeltaSumCircuitsAux M\u2081 M\u2082 C X\u2081 X\u2082) :\n    M\u2081.toMatroid.IsUnionDisjointCircuits X\u2081 :=\n  hC.right.left\n\n/-- A set of circuit form is related to a union of disjoint circuits of `M\u2082` -/\nlemma DeltaSumCircuitsAux.udc_right [DecidableEq \u03b1] {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C X\u2081 X\u2082 : Set \u03b1}\n    (hC : DeltaSumCircuitsAux M\u2081 M\u2082 C X\u2081 X\u2082) :\n    M\u2082.toMatroid.IsUnionDisjointCircuits X\u2082 :=\n  hC.right.right\n\nend BasicProperties\n\n\nsection CircuitAxioms\n\n", "theoremStatement": "/-- In circuit construction of \u0394-sum, empty set is not circuit -/\nlemma deltaSumCircuitPred_not_circuit_empty [DecidableEq \u03b1] (M\u2081 M\u2082 : BinaryMatroid \u03b1) :\n    \u00acDeltaSumCircuitPred M\u2081 M\u2082 \u2205 ", "theoremName": "deltaSumCircuitPred_not_circuit_empty", "fileCreated": {"commit": "aae07a69b2ec95e3d9a1436952a123dcb7d0d06f", "date": "2025-01-03"}, "theoremCreated": {"commit": "67629d2b74be7b972786897531b678f585a7af28", "date": "2025-02-03"}, "file": "Seymour/Seymour/Matroid/Operations/SumDelta/Basic.lean", "module": "Seymour.Matroid.Operations.SumDelta.Basic", "jsonFile": "Seymour.Matroid.Operations.SumDelta.Basic.jsonl", "positionMetadata": {"lineInFile": 65, "tokenPositionInFile": 2542, "theoremPositionInFile": 8}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 6, "numPremises": 51}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp only [DeltaSumCircuitPred, Minimal, DeltaSumCircuitForm, DeltaSumCircuitsAux,\n    Set.not_nonempty_empty, Set.empty_subset, Set.le_eq_subset, Set.subset_empty_iff,\n    true_and, false_and, exists_const, exists_and_left, implies_true, and_true, not_false_eq_true]", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 275}}
{"srcContext": "import Mathlib.Data.Set.SymmDiff\nimport Mathlib.Order.CompletePartialOrder\nimport Mathlib.Order.Disjoint\nimport Mathlib.Order.SymmDiff\nimport Mathlib.Tactic\n\nimport Seymour.Basic\n\n/-!\nThis provides lemmas about sets (mostly dealing with disjointness) that are missing in Mathlib.\n-/\n\nvariable {\u03b1 : Type}\n\nsection Other\n\nlemma set_union_union_eq_rev (X Y Z : Set \u03b1) : X \u222a Y \u222a Z = Z \u222a Y \u222a X := by\n  rw [Set.union_assoc, Set.union_comm, Set.union_comm Y Z]\n\nlemma setminus_inter_union_eq_union {X Y : Set \u03b1} : X \\ (X \u2229 Y) \u222a Y = X \u222a Y := by\n  tauto_set\n\nlemma nonempty_inter_not_ssubset_empty_inter {A B E : Set \u03b1} (hA : (A \u2229 E).Nonempty) (hB : B \u2229 E = \u2205) :\n    \u00ac(A \u2282 B) := by\n  intro \u27e8hAB, _\u27e9\n  obtain \u27e8x, hxAE\u27e9 := hA\n  have hxBE : x \u2208 B \u2229 E := (Set.inter_subset_inter hAB fun _ => id) hxAE\n  rw [hB] at hxBE\n  tauto\n\nlemma ssubset_self_union_other_elem {a : \u03b1} {X : Set \u03b1} (ha : a \u2209 X) :\n    X \u2282 X \u222a {a} := by\n  constructor\n  \u00b7 exact Set.subset_union_left\n  \u00b7 by_contra hX\n    rw [Set.union_subset_iff] at hX\n    obtain \u27e8_, haa\u27e9 := hX\n    tauto\n\nlemma singleton_union_ssubset_union_iff {a : \u03b1} {A B : Set \u03b1} (haA : a \u2209 A) (haB : a \u2209 B) :\n    A \u222a {a} \u2282 B \u222a {a} \u2194 A \u2282 B := by\n  constructor\n  \u00b7 intro hAB\n    obtain \u27e8hABl, hABr\u27e9 := hAB\n    constructor\n    \u00b7 intro x hx\n      apply ne_of_mem_of_not_mem hx at haA\n      cases hABl (Set.mem_union_left {a} hx) <;> tauto\n    \u00b7 by_contra hBA\n      apply Set.union_subset_union_left {a} at hBA\n      tauto\n  \u00b7 intro hAB\n    obtain \u27e8hABl, hABr\u27e9 := hAB\n    constructor\n    \u00b7 exact Set.union_subset_union_left {a} hABl\n    \u00b7 by_contra hBA\n      rw [Set.union_singleton, Set.union_singleton] at hBA\n      apply (Set.insert_subset_insert_iff haB).\u2192 at hBA\n      tauto\n\nlemma ssub_parts_ssub {A B E\u2081 E\u2082 : Set \u03b1}\n    (hA : A \u2286 E\u2081 \u222a E\u2082) (hB : B \u2286 E\u2081 \u222a E\u2082) (hAB\u2081 : A \u2229 E\u2081 \u2282 B \u2229 E\u2081) (hAB\u2082 : A \u2229 E\u2082 \u2282 B \u2229 E\u2082) :\n    A \u2282 B := by\n  constructor\n  \u00b7 obtain \u27e8hE\u2081, _\u27e9 := hAB\u2081\n    obtain \u27e8hE\u2082, _\u27e9 := hAB\u2082\n    rw [Set.left_eq_inter.\u2190 hA, Set.left_eq_inter.\u2190 hB, Set.inter_union_distrib_left, Set.inter_union_distrib_left]\n    exact Set.union_subset_union hE\u2081 hE\u2082\n  \u00b7 intro hBA\n    obtain \u27e8_, hE\u2081\u27e9 := hAB\u2081\n    obtain \u27e8x, hxBE\u2081, hxnAE\u2081\u27e9 := Set.not_subset.\u2192 hE\u2081\n    have hxB : x \u2208 B := Set.mem_of_mem_inter_left hxBE\u2081\n    have hxE\u2081 : x \u2208 E\u2081 := Set.mem_of_mem_inter_right hxBE\u2081\n    tauto\n\nlemma HasSubset.Subset.parts_eq {A E\u2081 E\u2082 : Set \u03b1} (hA : A \u2286 E\u2081 \u222a E\u2082) : (A \u2229 E\u2081) \u222a (A \u2229 E\u2082) = A :=\n  ((subset_of_subset_of_eq\n    (Set.subset_inter (fun _ => id) hA)\n    (Set.inter_union_distrib_left A E\u2081 E\u2082)).antisymm\n  (Set.union_subset Set.inter_subset_left Set.inter_subset_left)).symm\n\nlemma elem_notin_set_minus_singleton (a : \u03b1) (X : Set \u03b1) : a \u2209 X \\ {a} := Set.not_mem_diff_of_mem rfl\n\nlemma sub_union_diff_sub_union {A B C : Set \u03b1} (hA : A \u2286 B \\ C) : A \u2286 B :=\n  fun _ hA' => Set.diff_subset (hA hA')\n\nlemma singleton_inter_in_left {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : a \u2208 X :=\n  Set.mem_of_mem_inter_left (ha.symm.subset rfl)\n\nlemma singleton_inter_in_right {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : a \u2208 Y :=\n  Set.mem_of_mem_inter_right (ha.symm.subset rfl)\n\nlemma singleton_inter_subset_left {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : {a} \u2286 X := by\n  rw [Set.singleton_subset_iff]\n  exact singleton_inter_in_left ha\n\nlemma singleton_inter_subset_right {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : {a} \u2286 Y := by\n  rw [Set.singleton_subset_iff]\n  exact singleton_inter_in_right ha\n\n/-- Being a subset is preserved under subtracting sets. -/\nlemma diff_subset_parent {X\u2081 X\u2082 E : Set \u03b1} (hX\u2081E : X\u2081 \u2286 E) :\n    X\u2081 \\ X\u2082 \u2286 E :=\n  Set.diff_subset_iff.\u2190 (Set.subset_union_of_subset_right hX\u2081E X\u2082)\n\n/-- Being a subset is preserved under taking intersections. -/\nlemma inter_subset_parent_left {X\u2081 X\u2082 E : Set \u03b1} (hX\u2081E : X\u2081 \u2286 E) :\n    X\u2081 \u2229 X\u2082 \u2286 E :=\n  (Set.inter_subset_inter_left X\u2082 hX\u2081E).trans Set.inter_subset_left\n\n/-- Being a subset is preserved under taking intersections. -/\nlemma inter_subset_parent_right {X\u2081 X\u2082 E : Set \u03b1} (hX\u2082E : X\u2082 \u2286 E) :\n    X\u2081 \u2229 X\u2082 \u2286 E := by\n  rw [Set.inter_comm]\n  exact inter_subset_parent_left hX\u2082E\n\n/-- Intersection of two sets is subset of their union. -/\nlemma inter_subset_union {X\u2081 X\u2082 : Set \u03b1} :\n    X\u2081 \u2229 X\u2082 \u2286 X\u2081 \u222a X\u2082 :=\n  inter_subset_parent_left Set.subset_union_left\n\nlemma subset_diff_empty_eq {A B : Set \u03b1} (hAB : A \u2286 B) (hBA : B \\ A = \u2205) : A = B :=\n  A.union_empty \u25b8 hBA \u25b8 Set.union_diff_cancel hAB\n\nend Other\n\n\nsection Disjoint\n\nlemma Disjoint.ni_of_in {X Y : Set \u03b1} {a : \u03b1} (hXY : X \u2ad7 Y) (ha : a \u2208 X) :\n    a \u2209 Y := by\n  intro ha'\n  simpa [hXY.inter_eq] using Set.mem_inter ha ha'\n\nlemma disjoint_of_singleton_inter_left_wo {X Y : Set \u03b1} {a : \u03b1} (hXY : X \u2229 Y = {a}) :\n    X \\ {a} \u2ad7 Y := by\n  tauto_set\n\nlemma disjoint_of_singleton_inter_right_wo {X Y : Set \u03b1} {a : \u03b1} (hXY : X \u2229 Y = {a}) :\n    X \u2ad7 Y \\ {a} := by\n  rw [disjoint_comm]\n  rw [Set.inter_comm] at hXY\n  exact disjoint_of_singleton_inter_left_wo hXY\n\nlemma disjoint_of_singleton_inter_both_wo {X Y : Set \u03b1} {a : \u03b1} (hXY : X \u2229 Y = {a}) :\n    X \\ {a} \u2ad7 Y \\ {a} :=\n  Disjoint.disjoint_sdiff_left (disjoint_of_singleton_inter_right_wo hXY)\n\nlemma disjoint_of_singleton_inter_subset_left {X Y Z : Set \u03b1} {a : \u03b1} (hXY : X \u2229 Y = {a}) (hZ : Z \u2286 X) (haZ : a \u2209 Z) :\n    Z \u2ad7 Y := by\n  have hY : (Y \\ {a}) \u222a {a} = Y := (Set.diff_union_of_subset (singleton_inter_subset_right hXY))\n  rw [\u2190hY, Set.disjoint_union_right]\n  constructor\n  \u00b7 exact Set.disjoint_of_subset_left hZ (disjoint_of_singleton_inter_right_wo hXY)\n  \u00b7 exact Set.disjoint_singleton_right.\u2190 haZ\n\n", "theoremStatement": "lemma disjoint_of_singleton_inter_subset_right {X Y Z : Set \u03b1} {a : \u03b1} (hXY : X \u2229 Y = {a}) (hZ : Z \u2286 Y) (haZ : a \u2209 Z) :\n    X \u2ad7 Z ", "theoremName": "disjoint_of_singleton_inter_subset_right", "fileCreated": {"commit": "b44bff2f1ee71349fa9fa251579a0f5a0e575538", "date": "2024-12-19"}, "theoremCreated": {"commit": "f9d717ecfb54b3a7b794411b4c1af1f5c8ffb7c3", "date": "2024-12-26"}, "file": "Seymour/Seymour/ForMathlib/SetTheory.lean", "module": "Seymour.ForMathlib.SetTheory", "jsonFile": "Seymour.ForMathlib.SetTheory.jsonl", "positionMetadata": {"lineInFile": 157, "tokenPositionInFile": 5461, "theoremPositionInFile": 23}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 1, "numPremises": 29}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [Set.inter_comm] at hXY\n  rw [disjoint_comm]\n  exact disjoint_of_singleton_inter_subset_left hXY hZ haZ", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 114}}
{"srcContext": "import Seymour.ForMathlib.MatrixTU\n\n/-!\nThis file provides notation used in the project and conversions between set-theoretical and type-theoretical definitions.\n-/\n\n/-- The finite field on 2 elements; write `Z2` for \"value\" type but `Fin 2` for \"indexing\" type. -/\nabbrev Z2 : Type := ZMod 2\n\n/-- The finite field on 3 elements; write `Z3` for \"value\" type but `Fin 3` for \"indexing\" type. -/\nabbrev Z3 : Type := ZMod 3\n\n/-- Roughly speaking `a \u1543 A` is `A \u222a {a}`. -/\ninfixr:66 \" \u1543 \" => Insert.insert\n\n/-- Writing `X \u2ad7 Y` is slightly more general than writing `X \u2229 Y = \u2205`. -/\ninfix:61 \" \u2ad7 \" => Disjoint\n\n/-- The left-to-right direction of `\u2194`. -/\npostfix:max \".\u2192\" => Iff.mp\n\n/-- The right-to-left direction of `\u2194`. -/\npostfix:max \".\u2190\" => Iff.mpr\n\n\nsection utils\n\nlemma Fin2_eq_1_of_ne_0 {a : Fin 2} (ha : a \u2260 0) : a = 1 := by\n  omega\n\nlemma Fin3_eq_2_of_ne_0_1 {a : Fin 3} (ha0 : a \u2260 0) (ha1 : a \u2260 1) : a = 2 := by\n  omega\n\n\nvariable {\u03b1 : Type}\n\n/-- Given `X \u2286 Y` cast an element of `X` as an element of `Y`. -/\ndef HasSubset.Subset.elem {X Y : Set \u03b1} (hXY : X \u2286 Y) (x : X.Elem) : Y.Elem :=\n  \u27e8x.val, hXY x.property\u27e9\n\nlemma HasSubset.Subset.elem_injective {X Y : Set \u03b1} (hXY : X \u2286 Y) : hXY.elem.Injective := by\n  intro x y hxy\n  ext\n  simpa [HasSubset.Subset.elem] using hxy\n\n/-- Convert `(X \u222a Y).Elem` to `X.Elem \u2295 Y.Elem`. -/\ndef Subtype.toSum {X Y : Set \u03b1} [\u2200 a, Decidable (a \u2208 X)] [\u2200 a, Decidable (a \u2208 Y)] (i : (X \u222a Y).Elem) : X.Elem \u2295 Y.Elem :=\n  if hiX : i.val \u2208 X then Sum.inl \u27e8i, hiX\u27e9 else\n  if hiY : i.val \u2208 Y then Sum.inr \u27e8i, hiY\u27e9 else\n  (i.property.elim hiX hiY).elim\n\n/-- Convert `X.Elem \u2295 Y.Elem` to `(X \u222a Y).Elem`. -/\ndef Sum.toUnion {X Y : Set \u03b1} (i : X.Elem \u2295 Y.Elem) : (X \u222a Y).Elem :=\n  i.casesOn Set.subset_union_left.elem Set.subset_union_right.elem\n\n/-- Converting `(X \u222a Y).Elem` to `X.Elem \u2295 Y.Elem` and back to `(X \u222a Y).Elem` gives the original element. -/\nlemma toSum_toUnion {X Y : Set \u03b1} [\u2200 a, Decidable (a \u2208 X)] [\u2200 a, Decidable (a \u2208 Y)] (i : (X \u222a Y).Elem) :\n    i.toSum.toUnion = i := by\n  if hiX : i.val \u2208 X then\n    simp_all [Subtype.toSum, Sum.toUnion, HasSubset.Subset.elem]\n  else if hiY : i.val \u2208 Y then\n    simp_all [Subtype.toSum, Sum.toUnion, HasSubset.Subset.elem]\n  else\n    exfalso\n    exact i.property.elim hiX hiY\n\n/-- Converting `X.Elem \u2295 Y.Elem` to `(X \u222a Y).Elem` and back to `X.Elem \u2295 Y.Elem` gives the original element, assuming that\n`X` and `Y` are disjoint. -/\nlemma toUnion_toSum {X Y : Set \u03b1} [\u2200 a, Decidable (a \u2208 X)] [\u2200 a, Decidable (a \u2208 Y)] (hXY : X \u2ad7 Y) (i : X.Elem \u2295 Y.Elem) :\n    i.toUnion.toSum = i := by\n  rw [Set.disjoint_right] at hXY\n  cases i <;> simp [Subtype.toSum, Sum.toUnion, HasSubset.Subset.elem, hXY]\n\nvariable {T\u2081 T\u2082 S\u2081 S\u2082 : Set \u03b1} {\u03b2 : Type}\n  [\u2200 a, Decidable (a \u2208 T\u2081)]\n  [\u2200 a, Decidable (a \u2208 T\u2082)]\n  [\u2200 a, Decidable (a \u2208 S\u2081)]\n  [\u2200 a, Decidable (a \u2208 S\u2082)]\n\n/-- Convert a block matrix to a matrix over set unions. -/\ndef Matrix.toMatrixUnionUnion (C : Matrix (T\u2081.Elem \u2295 T\u2082.Elem) (S\u2081.Elem \u2295 S\u2082.Elem) \u03b2) :\n    Matrix (T\u2081 \u222a T\u2082).Elem (S\u2081 \u222a S\u2082).Elem \u03b2 :=\n  ((C \u2218 Subtype.toSum) \u00b7 \u2218 Subtype.toSum)\n\n/-- Convert a matrix over set unions to a block matrix. -/\ndef Matrix.toMatrixSumSum (C : Matrix (T\u2081 \u222a T\u2082).Elem (S\u2081 \u222a S\u2082).Elem \u03b2) :\n    Matrix (T\u2081.Elem \u2295 T\u2082.Elem) (S\u2081.Elem \u2295 S\u2082.Elem) \u03b2 :=\n  ((C \u2218 Sum.toUnion) \u00b7 \u2218 Sum.toUnion)\n\n/-- Converting a block matrix to a matrix over set unions and back to a block matrix gives the original matrix, assuming that\nboth said unions are disjoint. -/\nlemma toMatrixUnionUnion_toMatrixSumSum (hT : T\u2081 \u2ad7 T\u2082) (hS : S\u2081 \u2ad7 S\u2082) (C : Matrix (T\u2081 \u2295 T\u2082) (S\u2081 \u2295 S\u2082) \u03b2) :\n    C.toMatrixUnionUnion.toMatrixSumSum = C := by\n  ext\n  simp_all [Matrix.toMatrixUnionUnion, Matrix.toMatrixSumSum, toUnion_toSum]\n\n/-- Converting a matrix over set unions to a block matrix and back to a matrix over set unions gives the original matrix. -/\nlemma toMatrixSumSum_toMatrixUnionUnion (C : Matrix (T\u2081 \u222a T\u2082).Elem (S\u2081 \u222a S\u2082).Elem \u03b2) :\n    C.toMatrixSumSum.toMatrixUnionUnion = C := by\n  ext\n  simp_all [Matrix.toMatrixUnionUnion, Matrix.toMatrixSumSum, toSum_toUnion]\n\n", "theoremStatement": "/-- A totally unimodular block matrix stays totally unimodular after converting to a matrix over set unions. -/\nlemma Matrix.IsTotallyUnimodular.toMatrixUnionUnion [CommRing \u03b2] {C : Matrix (T\u2081 \u2295 T\u2082) (S\u2081 \u2295 S\u2082) \u03b2}\n    (hC : C.IsTotallyUnimodular) :\n    C.toMatrixUnionUnion.IsTotallyUnimodular ", "theoremName": "Matrix.IsTotallyUnimodular.toMatrixUnionUnion", "fileCreated": {"commit": "0e3e9cb42d2f02ece37a2344545c339b09a60217", "date": "2024-11-30"}, "theoremCreated": {"commit": "2abc822c6f0f2b6b65acb2c6c637c73d1bd8b1cc", "date": "2024-12-20"}, "file": "Seymour/Seymour/Basic.lean", "module": "Seymour.Basic", "jsonFile": "Seymour.Basic.jsonl", "positionMetadata": {"lineInFile": 103, "tokenPositionInFile": 4033, "theoremPositionInFile": 18}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 45}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [Matrix.isTotallyUnimodular_iff] at hC \u22a2\n  intros\n  apply hC", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 71}}
{"srcContext": "import Seymour.Matroid.Operations.MatrixSums.BinaryMatroids\n\n/-!\nThis file contains everything about 3-sum of binary matroids \u2014 the old version (in terms of explicit matrices).\n-/\n\nvariable {\u03b1 : Type}\n\n/-- `Matrix`-level 3-sum for matroids defined by their standard representation matrices; does not check legitimacy. -/\nnoncomputable abbrev Matrix_3sumComposition {\u03b2 : Type} [CommRing \u03b2] {X\u2081 Y\u2081 X\u2082 Y\u2082 : Set \u03b1}\n    (A\u2081 : Matrix X\u2081 (Y\u2081 \u2295 Fin 2) \u03b2) (A\u2082 : Matrix (Fin 2 \u2295 X\u2082) Y\u2082 \u03b2)\n    (z\u2081 : Y\u2081 \u2192 \u03b2) (z\u2082 : X\u2082 \u2192 \u03b2) (D : Matrix (Fin 2) (Fin 2) \u03b2) (D\u2081 : Matrix (Fin 2) Y\u2081 \u03b2) (D\u2082 : Matrix X\u2082 (Fin 2) \u03b2) :\n    Matrix ((X\u2081 \u2295 Unit) \u2295 (Fin 2 \u2295 X\u2082)) ((Y\u2081 \u2295 Fin 2) \u2295 (Unit \u2295 Y\u2082)) \u03b2 :=\n  -- Unfortunately `Ring.inverse` is `noncomputable` and upgrading `\u03b2` to `Field` does not help.\n  let D\u2081\u2082 : Matrix X\u2082 Y\u2081 \u03b2 := D\u2082 * D\u207b\u00b9 * D\u2081\n  Matrix.fromBlocks\n    (Matrix.fromRows A\u2081 (Matrix.row Unit (Sum.elim z\u2081 ![1, 1]))) 0\n    (Matrix.fromBlocks D\u2081 D D\u2081\u2082 D\u2082) (Matrix.fromCols (Matrix.col Unit (Sum.elim ![1, 1] z\u2082)) A\u2082)\n\nvariable [DecidableEq \u03b1] {M\u2081 M\u2082 : StandardRepresentation \u03b1}\n\n/-- `StandardRepresentation`-level 3-sum of two matroids.\nThe second part checks legitimacy (invertibility of a certain 2x2 submatrix and specific 1s and 0s on concrete positions). -/\nnoncomputable def StandardRepresentation_3sum {x\u2081 x\u2082 x\u2083 y\u2081 y\u2082 y\u2083 : \u03b1}\n    (hXX : M\u2081.X \u2229 M\u2082.X = {x\u2081, x\u2082, x\u2083}) (hYY : M\u2081.Y \u2229 M\u2082.Y = {y\u2081, y\u2082, y\u2083}) (hXY : M\u2081.X \u2ad7 M\u2082.Y) (hYX : M\u2081.Y \u2ad7 M\u2082.X) :\n    StandardRepresentation \u03b1 \u00d7 Prop :=\n  have hxxx\u2081 : {x\u2081, x\u2082, x\u2083} \u2286 M\u2081.X := hXX.symm.subset.trans Set.inter_subset_left\n  have hxxx\u2082 : {x\u2081, x\u2082, x\u2083} \u2286 M\u2082.X := hXX.symm.subset.trans Set.inter_subset_right\n  have hyyy\u2081 : {y\u2081, y\u2082, y\u2083} \u2286 M\u2081.Y := hYY.symm.subset.trans Set.inter_subset_left\n  have hyyy\u2082 : {y\u2081, y\u2082, y\u2083} \u2286 M\u2082.Y := hYY.symm.subset.trans Set.inter_subset_right\n  have x\u2081inX\u2081 : x\u2081 \u2208 M\u2081.X := hxxx\u2081 (Set.mem_insert x\u2081 {x\u2082, x\u2083})\n  have x\u2081inX\u2082 : x\u2081 \u2208 M\u2082.X := hxxx\u2082 (Set.mem_insert x\u2081 {x\u2082, x\u2083})\n  have x\u2082inX\u2081 : x\u2082 \u2208 M\u2081.X := hxxx\u2081 (Set.insert_comm x\u2081 x\u2082 {x\u2083} \u25b8 Set.mem_insert x\u2082 {x\u2081, x\u2083})\n  have x\u2082inX\u2082 : x\u2082 \u2208 M\u2082.X := hxxx\u2082 (Set.insert_comm x\u2081 x\u2082 {x\u2083} \u25b8 Set.mem_insert x\u2082 {x\u2081, x\u2083})\n  have x\u2083inX\u2081 : x\u2083 \u2208 M\u2081.X := hxxx\u2081 (by simp)\n  have x\u2083inX\u2082 : x\u2083 \u2208 M\u2082.X := hxxx\u2082 (by simp)\n  have y\u2083inY\u2081 : y\u2083 \u2208 M\u2081.Y := hyyy\u2081 (by simp)\n  have y\u2083inY\u2082 : y\u2083 \u2208 M\u2082.Y := hyyy\u2082 (by simp)\n  have y\u2082inY\u2081 : y\u2082 \u2208 M\u2081.Y := hyyy\u2081 (Set.insert_comm y\u2081 y\u2082 {y\u2083} \u25b8 Set.mem_insert y\u2082 {y\u2081, y\u2083})\n  have y\u2082inY\u2082 : y\u2082 \u2208 M\u2082.Y := hyyy\u2082 (Set.insert_comm y\u2081 y\u2082 {y\u2083} \u25b8 Set.mem_insert y\u2082 {y\u2081, y\u2083})\n  have y\u2081inY\u2081 : y\u2081 \u2208 M\u2081.Y := hyyy\u2081 (Set.mem_insert y\u2081 {y\u2082, y\u2083})\n  have y\u2081inY\u2082 : y\u2081 \u2208 M\u2082.Y := hyyy\u2082 (Set.mem_insert y\u2081 {y\u2082, y\u2083})\n  -- The actual definition starts here:\n  let A\u2081 : Matrix (M\u2081.X \\ {x\u2081, x\u2082, x\u2083}).Elem ((M\u2081.Y \\ {y\u2081, y\u2082, y\u2083}).Elem \u2295 Fin 2) Z2 := -- the top left submatrix\n    Matrix.of (fun i j => M\u2081.B\n        \u27e8i.val, Set.mem_of_mem_diff i.property\u27e9\n        (j.casesOn (fun j' => \u27e8j'.val, Set.mem_of_mem_diff j'.property\u27e9) ![\u27e8y\u2082, y\u2082inY\u2081\u27e9, \u27e8y\u2081, y\u2081inY\u2081\u27e9]))\n  let A\u2082 : Matrix (Fin 2 \u2295 (M\u2082.X \\ {x\u2081, x\u2082, x\u2083}).Elem) (M\u2082.Y \\ {y\u2081, y\u2082, y\u2083}).Elem Z2 := -- the bottom right submatrix\n    Matrix.of (fun i j => M\u2082.B\n        (i.casesOn ![\u27e8x\u2082, x\u2082inX\u2082\u27e9, \u27e8x\u2083, x\u2083inX\u2082\u27e9] (fun i' => \u27e8i'.val, Set.mem_of_mem_diff i'.property\u27e9))\n        \u27e8j.val, Set.mem_of_mem_diff j.property\u27e9)\n  let z\u2081 : (M\u2081.Y \\ {y\u2081, y\u2082, y\u2083}).Elem \u2192 Z2 := -- the middle left \"row vector\"\n    (fun j => M\u2081.B \u27e8x\u2081, x\u2081inX\u2081\u27e9 \u27e8j.val, Set.mem_of_mem_diff j.property\u27e9)\n  let z\u2082 : (M\u2082.X \\ {x\u2081, x\u2082, x\u2083}).Elem \u2192 Z2 := -- the bottom middle \"column vector\"\n    (fun i => M\u2082.B \u27e8i.val, Set.mem_of_mem_diff i.property\u27e9 \u27e8y\u2083, y\u2083inY\u2082\u27e9)\n  let D_\u2081 : Matrix (Fin 2) (Fin 2) Z2 := -- the bottom middle 2x2 submatrix\n    Matrix.of (fun i j => M\u2081.B (![\u27e8x\u2082, x\u2082inX\u2081\u27e9, \u27e8x\u2083, x\u2083inX\u2081\u27e9] i) (![\u27e8y\u2082, y\u2082inY\u2081\u27e9, \u27e8y\u2081, y\u2081inY\u2081\u27e9] j))\n  let D_\u2082 : Matrix (Fin 2) (Fin 2) Z2 := -- the middle left 2x2 submatrix\n    Matrix.of (fun i j => M\u2082.B (![\u27e8x\u2082, x\u2082inX\u2082\u27e9, \u27e8x\u2083, x\u2083inX\u2082\u27e9] i) (![\u27e8y\u2082, y\u2082inY\u2082\u27e9, \u27e8y\u2081, y\u2081inY\u2082\u27e9] j))\n  let D\u2081 : Matrix (Fin 2) (M\u2081.Y \\ {y\u2081, y\u2082, y\u2083}).Elem Z2 := -- the bottom left submatrix\n    Matrix.of (fun i j => M\u2081.B (![\u27e8x\u2082, x\u2082inX\u2081\u27e9, \u27e8x\u2083, x\u2083inX\u2081\u27e9] i) \u27e8j.val, Set.mem_of_mem_diff j.property\u27e9)\n  let D\u2082 : Matrix (M\u2082.X \\ {x\u2081, x\u2082, x\u2083}).Elem (Fin 2) Z2 := -- the bottom left submatrix\n    Matrix.of (fun i j => M\u2082.B \u27e8i.val, Set.mem_of_mem_diff i.property\u27e9 (![\u27e8y\u2082, y\u2082inY\u2082\u27e9, \u27e8y\u2081, y\u2081inY\u2082\u27e9] j))\n  \u27e8\n    \u27e8\n      (M\u2081.X \\ {x\u2081, x\u2082, x\u2083}) \u222a M\u2082.X,\n      M\u2081.Y \u222a (M\u2082.Y \\ {y\u2081, y\u2082, y\u2083}),\n      inferInstance,\n      inferInstance,\n      by\n        rw [Set.disjoint_union_right, Set.disjoint_union_left, Set.disjoint_union_left]\n        exact\n          \u27e8\u27e8M\u2081.hXY.disjoint_sdiff_left, hYX.symm\u27e9, \u27e8hXY.disjoint_sdiff_right.disjoint_sdiff_left, M\u2082.hXY.disjoint_sdiff_right\u27e9\u27e9,\n      Matrix.of (fun i j =>\n        Matrix_3sumComposition A\u2081 A\u2082 z\u2081 z\u2082 D_\u2081 D\u2081 D\u2082 (\n          if hi\u2081 : i.val \u2208 M\u2081.X \\ {x\u2081, x\u2082, x\u2083} then Sum.inl (Sum.inl \u27e8i, hi\u2081\u27e9) else\n          if hi\u2082 : i.val \u2208 M\u2082.X \\ {x\u2081, x\u2082, x\u2083} then Sum.inr (Sum.inr \u27e8i, hi\u2082\u27e9) else\n          if hx\u2081 : i.val = x\u2081 then Sum.inl (Sum.inr ()) else\n          if hx\u2082 : i.val = x\u2082 then Sum.inr (Sum.inl 0) else\n          if hx\u2083 : i.val = x\u2083 then Sum.inr (Sum.inl 1) else\n          (i.property.elim hi\u2081 (by simp_all)).elim\n          -- TODO can `Matrix.toMatrixUnionUnion` be combined with something else to simplify this definition?\n        ) (\n          if hj\u2081 : j.val \u2208 M\u2081.Y \\ {y\u2081, y\u2082, y\u2083} then Sum.inl (Sum.inl \u27e8j, hj\u2081\u27e9) else\n          if hj\u2082 : j.val \u2208 M\u2082.Y \\ {y\u2081, y\u2082, y\u2083} then Sum.inr (Sum.inr \u27e8j, hj\u2082\u27e9) else\n          if hy\u2081 : j.val = y\u2081 then Sum.inl (Sum.inr 1) else\n          if hy\u2082 : j.val = y\u2082 then Sum.inl (Sum.inr 0) else\n          if hy\u2083 : j.val = y\u2083 then Sum.inr (Sum.inl ()) else\n          (j.property.elim (by simp_all) hj\u2082).elim\n        )\n      )\n    \u27e9,\n    IsUnit D_\u2081 \u2227 D_\u2081 = D_\u2082 -- the matrix `D_\u2081 = D_\u2082` (called D-bar in the book) is invertible\n    \u2227 M\u2081.B \u27e8x\u2081, x\u2081inX\u2081\u27e9 \u27e8y\u2081, y\u2081inY\u2081\u27e9 = 1\n    \u2227 M\u2081.B \u27e8x\u2081, x\u2081inX\u2081\u27e9 \u27e8y\u2082, y\u2082inY\u2081\u27e9 = 1\n    \u2227 M\u2081.B \u27e8x\u2082, x\u2082inX\u2081\u27e9 \u27e8y\u2083, y\u2083inY\u2081\u27e9 = 1\n    \u2227 M\u2081.B \u27e8x\u2083, x\u2083inX\u2081\u27e9 \u27e8y\u2083, y\u2083inY\u2081\u27e9 = 1\n    \u2227 M\u2082.B \u27e8x\u2081, x\u2081inX\u2082\u27e9 \u27e8y\u2081, y\u2081inY\u2082\u27e9 = 1\n    \u2227 M\u2082.B \u27e8x\u2081, x\u2081inX\u2082\u27e9 \u27e8y\u2082, y\u2082inY\u2082\u27e9 = 1\n    \u2227 M\u2082.B \u27e8x\u2082, x\u2082inX\u2082\u27e9 \u27e8y\u2083, y\u2083inY\u2082\u27e9 = 1\n    \u2227 M\u2082.B \u27e8x\u2083, x\u2083inX\u2082\u27e9 \u27e8y\u2083, y\u2083inY\u2082\u27e9 = 1\n    \u2227 (\u2200 x : \u03b1, \u2200 hx : x \u2208 M\u2081.X, x \u2260 x\u2082 \u2227 x \u2260 x\u2083 \u2192 M\u2081.B \u27e8x, hx\u27e9 \u27e8y\u2083, y\u2083inY\u2081\u27e9 = 0) -- the rest of the rightmost column is `0`s\n    \u2227 (\u2200 y : \u03b1, \u2200 hy : y \u2208 M\u2082.Y, y \u2260 y\u2082 \u2227 y \u2260 y\u2081 \u2192 M\u2082.B \u27e8x\u2081, x\u2081inX\u2082\u27e9 \u27e8y, hy\u27e9 = 0) -- the rest of the topmost row is `0`s\n  \u27e9\n\n/-- Binary matroid `M` is a result of 3-summing `M\u2081` and `M\u2082` in some way. -/\ndef StandardRepresentation.Is3sumOf (M : StandardRepresentation \u03b1) (M\u2081 M\u2082 : StandardRepresentation \u03b1) : Prop :=\n  \u2203 x\u2081 x\u2082 x\u2083 y\u2081 y\u2082 y\u2083 : \u03b1,\n    \u2203 hXX : M\u2081.X \u2229 M\u2082.X = {x\u2081, x\u2082, x\u2083}, \u2203 hYY : M\u2081.Y \u2229 M\u2082.Y = {y\u2081, y\u2082, y\u2083}, \u2203 hXY : M\u2081.X \u2ad7 M\u2082.Y, \u2203 hYX : M\u2081.Y \u2ad7 M\u2082.X,\n      let M\u2080 := StandardRepresentation_3sum hXX hYY hXY hYX\n      M.toMatroid = M\u2080.fst.toMatroid \u2227 M\u2080.snd\n\nvariable {M : StandardRepresentation \u03b1}\n\n-- API for access to individual assumptions and identities in the definition of 3-sum\n\nlemma StandardRepresentation.Is3sumOf.interXX (hM : M.Is3sumOf M\u2081 M\u2082) :\n    \u2203 x\u2081 x\u2082 x\u2083 : \u03b1, M\u2081.X \u2229 M\u2082.X = {x\u2081, x\u2082, x\u2083} := by\n  obtain \u27e8x\u2081, x\u2082, x\u2083, -, -, -, hXX, -\u27e9 := hM\n  exact \u27e8x\u2081, x\u2082, x\u2083, hXX\u27e9\n\nlemma StandardRepresentation.Is3sumOf.interYY (hM : M.Is3sumOf M\u2081 M\u2082) :\n    \u2203 y\u2081 y\u2082 y\u2083 : \u03b1, M\u2081.Y \u2229 M\u2082.Y = {y\u2081, y\u2082, y\u2083} := by\n  obtain \u27e8-, -, -, y\u2081, y\u2082, y\u2083, -, hYY, -\u27e9 := hM\n  exact \u27e8y\u2081, y\u2082, y\u2083, hYY\u27e9\n\n", "theoremStatement": "lemma StandardRepresentation.Is3sumOf.disjoXY (hM : M.Is3sumOf M\u2081 M\u2082) :\n    M\u2081.X \u2ad7 M\u2082.Y ", "theoremName": "StandardRepresentation.Is3sumOf.disjoXY", "fileCreated": {"commit": "614ecc7fe89749171933326a0f077e8d8a24cecb", "date": "2025-02-03"}, "theoremCreated": {"commit": "74722a3f54befb275eb7729e168db1478932de5e", "date": "2024-12-05"}, "file": "Seymour/Seymour/Matroid/Operations/MatrixSums/Sum3.lean", "module": "Seymour.Matroid.Operations.MatrixSums.Sum3", "jsonFile": "Seymour.Matroid.Operations.MatrixSums.Sum3.jsonl", "positionMetadata": {"lineInFile": 127, "tokenPositionInFile": 7327, "theoremPositionInFile": 5}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 6, "numPremises": 32}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  obtain \u27e8-, -, -, -, -, -, -, -, hXY, -\u27e9 := hM\n  exact hXY", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 65}}
{"srcContext": "import Mathlib.Order.RelClasses\nimport Mathlib.Data.Matroid.Basic\n\nimport Seymour.Basic\nimport Seymour.Matroid.Notions.IndepAxioms\n\n\n/-- Circuit predicate, defines which sets are circuits. -/\nabbrev CircuitPredicate (\u03b1 : Type) := Set \u03b1 \u2192 Prop\n\n\nvariable {\u03b1 : Type}\n\n\nsection ValidFamily\n\n/-- Family of circuits satisfying assumptions of circuit axiom (C3) from Bruhn et al. -/\nstructure ValidFamily (P : CircuitPredicate \u03b1) (X : Set \u03b1) where\n  F : X.Elem \u2192 Set \u03b1\n  hPF : \u2200 x : X.Elem, P (F x)\n  hF : \u2200 x y : X.Elem, x.val \u2208 F y \u2194 x = y -- `F y` may nevertheless contain multiple elements of `X\u1d9c`\n\n/-- Shorthand for union of sets in `ValidFamily` -/\nabbrev ValidFamily.union {P : CircuitPredicate \u03b1} {X : Set \u03b1} (F : ValidFamily P X) : Set \u03b1 :=\n  Set.iUnion F.F\n\n-- question: unused API?\nlemma ValidFamily.mem_of_elem {P : CircuitPredicate \u03b1} {X : Set \u03b1} (F : ValidFamily P X) (x : X.Elem) :\n    x.val \u2208 F.F x := by\n  rw [F.hF]\n\n-- question: unused API?\n", "theoremStatement": "lemma ValidFamily.outside {P : CircuitPredicate \u03b1} {C X : Set \u03b1} {F : ValidFamily P X} {z : \u03b1} (hzCF : z \u2208 C \\ F.union) :\n    z \u2209 X ", "theoremName": "ValidFamily.outside", "fileCreated": {"commit": "ee35fddd27b04eb576eb64b8bb74af513408f6ef", "date": "2024-12-21"}, "theoremCreated": {"commit": "3937be9ff2724b131db903ab8cd973ac32bc21de", "date": "2025-01-14"}, "file": "Seymour/Seymour/Matroid/Notions/CircuitAxioms.lean", "module": "Seymour.Matroid.Notions.CircuitAxioms", "jsonFile": "Seymour.Matroid.Notions.CircuitAxioms.jsonl", "positionMetadata": {"lineInFile": 33, "tokenPositionInFile": 953, "theoremPositionInFile": 3}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 5, "repositoryPremises": true, "numRepositoryPremises": 5, "numPremises": 38}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  intro hz\n  have := F.hF \u27e8z, hz\u27e9 \u27e8z, hz\u27e9\n  simp_all", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 58}}
{"srcContext": "import Seymour.Matroid.Operations.Sum2.Basic\nimport Seymour.Matroid.Operations.SumDelta.CircuitForms\n\n\nvariable {\u03b1 : Type} [DecidableEq \u03b1] {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n\n\nsection CircuitFormsProperties\n\n/-- Circuit of form 1 satisfies circuit predicate of `M\u2081 \u0394 M\u2082` if `M\u2081.E` and `M\u2082.E` satisfy the 2-sum assumptions -/\nlemma DeltaSumCircuitForm1.sum2_circuit_pred {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) (assumptions : TwoSumAssumptions M\u2081.toMatroid M\u2082.toMatroid) :\n    DeltaSumCircuitPred M\u2081 M\u2082 C := by\n  constructor\n  \u00b7 exact hC.circuit_form\n  \u00b7 intro C' hC' hCC'\n    replace \u27e8hC, _\u27e9 := hC\n    obtain \u27e8C'_nonempty, _, X\u2081, X\u2082, hXX, hX\u2081, hX\u2082\u27e9 := hC'\n    cases hX\u2082.dep_or_empty with\n    | inl X\u2082_dep =>\n      have X\u2082_eq : X\u2082 = M\u2081.E \u2229 M\u2082.E :=\n        have symDiff_sub_E\u2081 := symmDiff_eq_alt X\u2081 X\u2082 \u25b8 hXX \u25b8 hCC'.trans hC.subset_ground\n        have X\u2082_sub_E\u2081 := M\u2081.toMatroid_E \u25b8 symmDiff_subset_ground_right symDiff_sub_E\u2081 hX\u2081.subset_ground\n        have X\u2082_sub_inter := Set.subset_inter X\u2082_sub_E\u2081 X\u2082_dep.subset_ground\n        have inter_finite := Set.finite_of_encard_eq_coe assumptions.interSingleton\n        have inter_encard_le_X\u2082_encard := le_of_eq_of_le assumptions.interSingleton\n          (Set.one_le_encard_iff_nonempty.\u2190 X\u2082_dep.nonempty)\n        inter_finite.eq_of_subset_of_encard_le X\u2082_sub_inter inter_encard_le_X\u2082_encard\n      have \u27e8p, hp\u27e9 := assumptions.inter_singleton\n      have M\u2082_loop_p : M\u2082.toMatroid.Loop p := \u27e8singleton_inter_in_right hp, hp \u25b8 X\u2082_eq \u25b8 X\u2082_dep\u27e9\n      exfalso\n      exact assumptions.inter_singleton_not_loop_M\u2082 hp M\u2082_loop_p\n    | inr X\u2082_empty =>\n      rw [X\u2082_empty, Set.union_empty, Set.inter_empty, Set.diff_empty] at hXX\n      rw [hXX] at hCC' C'_nonempty \u22a2\n      have X\u2081_dep := hX\u2081.nonempty_dep C'_nonempty\n      exact hC.right X\u2081_dep hCC'\n\n/-- Circuit of form 2 satisfies circuit predicate of `M\u2081 \u0394 M\u2082` if `M\u2081.E` and `M\u2082.E` satisfy the 2-sum assumptions -/\nlemma DeltaSumCircuitForm2.sum2_circuit_pred {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) (assumptions : TwoSumAssumptions M\u2081.toMatroid M\u2082.toMatroid) :\n    DeltaSumCircuitPred M\u2081 M\u2082 C := by\n  constructor\n  \u00b7 exact hC.circuit_form\n  \u00b7 intro C' hC' hCC'\n    replace \u27e8hC, _\u27e9 := hC\n    obtain \u27e8C'_nonempty, _, X\u2081, X\u2082, hXX, hX\u2081, hX\u2082\u27e9 := hC'\n    cases hX\u2081.dep_or_empty with\n    | inl X\u2081_dep =>\n      have X\u2081_eq : X\u2081 = M\u2081.E \u2229 M\u2082.E :=\n        have symDiff_sub_E\u2082 := symmDiff_eq_alt X\u2081 X\u2082 \u25b8 hXX \u25b8 hCC'.trans hC.subset_ground\n        have X\u2081_sub_E\u2082 := M\u2082.toMatroid_E \u25b8 symmDiff_subset_ground_left symDiff_sub_E\u2082 hX\u2082.subset_ground\n        have hX\u2081sub_inter := Set.subset_inter X\u2081_dep.subset_ground X\u2081_sub_E\u2082\n        have inter_finite := Set.finite_of_encard_eq_coe assumptions.interSingleton\n        have inter_encard_le_X\u2081_encard := le_of_eq_of_le assumptions.interSingleton\n          (Set.one_le_encard_iff_nonempty.\u2190 X\u2081_dep.nonempty)\n        inter_finite.eq_of_subset_of_encard_le hX\u2081sub_inter inter_encard_le_X\u2081_encard\n      obtain \u27e8p, hp\u27e9 := assumptions.inter_singleton\n      have M\u2081_loop_p : M\u2081.toMatroid.Loop p := \u27e8singleton_inter_in_left hp, hp \u25b8 X\u2081_eq \u25b8 X\u2081_dep\u27e9\n      exfalso\n      exact assumptions.inter_singleton_not_loop_M\u2081 hp M\u2081_loop_p\n    | inr X\u2081_empty =>\n      rw [X\u2081_empty, Set.empty_union, Set.empty_inter, Set.diff_empty] at hXX\n      rw [hXX] at hCC' C'_nonempty \u22a2\n      have X\u2082_dep := hX\u2082.nonempty_dep C'_nonempty\n      exact hC.right X\u2082_dep hCC'\n\n", "theoremStatement": "/-- Under 2-sum assumptions, `{p}` in definition of circuits of form 3 is exactly `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm3.sum2_singleton_eq {C : Set \u03b1} {p : \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) (assumptions : TwoSumAssumptions M\u2081.toMatroid M\u2082.toMatroid) :\n    M\u2081.E \u2229 M\u2082.E = {p} ", "theoremName": "DeltaSumCircuitForm3.sum2_singleton_eq", "fileCreated": {"commit": "aae07a69b2ec95e3d9a1436952a123dcb7d0d06f", "date": "2025-01-03"}, "theoremCreated": {"commit": "67629d2b74be7b972786897531b678f585a7af28", "date": "2025-02-03"}, "file": "Seymour/Seymour/Matroid/Operations/SumDelta/SpecialCase2Sum.lean", "module": "Seymour.Matroid.Operations.SumDelta.SpecialCase2Sum", "jsonFile": "Seymour.Matroid.Operations.SumDelta.SpecialCase2Sum.jsonl", "positionMetadata": {"lineInFile": 68, "tokenPositionInFile": 3365, "theoremPositionInFile": 2}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 11, "numPremises": 63}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  have inter_encard_eq_1 := M\u2081.toMatroid_E \u25b8 M\u2082.toMatroid_E \u25b8 assumptions.interSingleton\n  have inter_finite := Set.finite_of_encard_eq_coe inter_encard_eq_1\n  have inter_subsingleton_encard := ((Set.encard_singleton p).symm \u25b8 inter_encard_eq_1).le\n  exact (inter_finite.eq_of_subset_of_encard_le hC.singleton_subset_inter inter_subsingleton_encard).symm", "proofType": "tactic", "proofLengthLines": 4, "proofLengthTokens": 360}}
{"srcContext": "import Seymour.Matroid.Operations.SumDelta.Basic\nimport Seymour.ForMathlib.SetTheory\n\nset_option linter.unusedVariables false\n\nvariable {\u03b1 : Type} [DecidableEq \u03b1]\n\n\nsection Basic\n\n/-- Nonempty union of disjoint circuits of `M\u2081` satisfies circuit form of `M\u2081 \u0394 M\u2082`  -/\nlemma deltaSumCircuitForm_left {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : C.Nonempty) (hCE : C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)) (hCM\u2081 : M\u2081.toMatroid.IsUnionDisjointCircuits C) :\n    DeltaSumCircuitForm M\u2081 M\u2082 C :=\n  \u27e8hC, hCE, C, \u2205, by simp, hCM\u2081, M\u2082.toMatroid.emptyUnionDisjointCircuits\u27e9\n\n/-- Nonempty union of disjoint circuits of `M\u2082` satisfies circuit form of `M\u2081 \u0394 M\u2082`  -/\nlemma deltaSumCircuitForm_right {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : C.Nonempty) (hCE : C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)) (hCM\u2082 : M\u2082.toMatroid.IsUnionDisjointCircuits C) :\n    DeltaSumCircuitForm M\u2081 M\u2082 C :=\n  \u27e8hC, hCE, \u2205, C, by simp, M\u2081.toMatroid.emptyUnionDisjointCircuits, hCM\u2082\u27e9\n\nend Basic\n\n\nsection CircuitForm1\n\n/-- Form 1 of circuits in `M\u2081 \u0394 M\u2082`: circuits of `M\u2081` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef DeltaSumCircuitForm1 (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.toMatroid.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Circuit of form 1 is a circuit in `M\u2081` -/\nlemma DeltaSumCircuitForm1.circuit_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    M\u2081.toMatroid.Circuit C :=\n  hC.left\n\n/-- Circuit of form 1 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm1.disjoint_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of form 1 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma DeltaSumCircuitForm1.subset_union {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_left hC.circuit_M\u2081.subset_ground M\u2082.E\n\n/-- Circuit of form 1 lies in ground set of `M\u2081 \u0394 M\u2082` -/\nlemma DeltaSumCircuitForm1.subset_ground {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of form 1 lies in `M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma DeltaSumCircuitForm1.subset_M\u2081_diff_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2286 M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2081.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of form 1 is disjoint with `M\u2082.E` -/\nlemma DeltaSumCircuitForm1.disjoint_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2ad7 M\u2082.E := by\n  have hMM := diff_inter_disjoint_diff_inter M\u2081.E M\u2082.E\n  have hCM\u2082 := Set.disjoint_of_subset_left hC.subset_M\u2081_diff_inter hMM\n  have hCM\u2082 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2082, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_right] at hCM\u2082\n  exact hCM\u2082\n\n/-- Circuit of form 1 satisfies circuit form of `M\u2081 \u0394 M\u2082` -/\nlemma DeltaSumCircuitForm1.circuit_form {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    DeltaSumCircuitForm M\u2081 M\u2082 C :=\n  deltaSumCircuitForm_left hC.circuit_M\u2081.nonempty hC.subset_ground hC.circuit_M\u2081.isUnionDisjointCircuits\n\n/-- If `C` satisfies circuit predicate and is a union of disjoint circuits of `M\u2081`, then `C` is a circuit of `M\u2081` -/\nlemma DeltaSumCircuitPred.udc_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (C_pred : DeltaSumCircuitPred M\u2081 M\u2082 C) (C_udc : M\u2081.toMatroid.IsUnionDisjointCircuits C) :\n    M\u2081.toMatroid.Circuit C :=\n  have \u27e8\u27e8hC, hCE, _\u27e9, hCmin\u27e9 := C_pred\n  \u27e8C_udc.nonempty_dep hC, fun D hD hDC =>\n    have \u27e8_, D', hD', hDD'\u27e9 := M\u2081.toMatroid.dep_iff_has_circuit.\u2192 hD\n    (hCmin\n        (DeltaSumCircuitForm1.circuit_form \u27e8hD', (Set.subset_diff.\u2192 ((hDD'.trans hDC).trans hCE)).right\u27e9)\n        (hDD'.trans hDC)\n      ).trans hDD'\u27e9\n\nend CircuitForm1\n\n\nsection CircuitForm2\n\n/-- Form 2 of circuits in `M\u2081 \u0394 M\u2082`: circuits of `M\u2082` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef DeltaSumCircuitForm2 (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2082.toMatroid.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Circuit of form 2 is a circuit in `M\u2081` -/\nlemma DeltaSumCircuitForm2.circuit_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    M\u2082.toMatroid.Circuit C :=\n  hC.left\n\n/-- Circuit of form 2 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm2.disjoint_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of form 2 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma DeltaSumCircuitForm2.subset_union {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_right hC.circuit_M\u2082.subset_ground M\u2081.E\n\n/-- Circuit of form 2 lies in ground set of `M\u2081 \u0394 M\u2082` -/\nlemma DeltaSumCircuitForm2.subset_ground {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of form 2 lies in `M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma DeltaSumCircuitForm2.subset_M\u2082_diff_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2286 M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2082.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of form 2 is disjoint with `M\u2082.E` -/\nlemma DeltaSumCircuitForm2.disjoint_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2ad7 M\u2081.E := by\n  have hMM := diff_inter_disjoint_diff_inter M\u2081.E M\u2082.E\n  have hCM\u2082 := Set.disjoint_of_subset_right hC.subset_M\u2082_diff_inter hMM\n  have hCM\u2082 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2082.symm, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_left] at hCM\u2082\n  exact hCM\u2082\n\n/-- Circuit of form 2 satisfies circuit form of `M\u2081 \u0394 M\u2082` -/\nlemma DeltaSumCircuitForm2.circuit_form {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    DeltaSumCircuitForm M\u2081 M\u2082 C :=\n  deltaSumCircuitForm_right hC.circuit_M\u2082.nonempty hC.subset_ground hC.circuit_M\u2082.isUnionDisjointCircuits\n\n/-- If `C` satisfies circuit predicate and is a union of disjoint circuits of `M\u2082`, then `C` is a circuit of `M\u2082` -/\nlemma DeltaSumCircuitPred.udc_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hCpred : DeltaSumCircuitPred M\u2081 M\u2082 C) (hCudc : M\u2082.toMatroid.IsUnionDisjointCircuits C) :\n    M\u2082.toMatroid.Circuit C :=\n  have \u27e8\u27e8C_nempty, hCE, _\u27e9, hCmin\u27e9 := hCpred\n  \u27e8hCudc.nonempty_dep C_nempty, fun D hD hDC =>\n    have \u27e8_, D', hD', hDD'\u27e9 := M\u2082.toMatroid.dep_iff_has_circuit.\u2192 hD\n    (hCmin\n        (DeltaSumCircuitForm2.circuit_form \u27e8hD', (Set.subset_diff.\u2192 ((hDD'.trans hDC).trans hCE)).right\u27e9)\n        (hDD'.trans hDC)\n      ).trans hDD'\u27e9\n\nend CircuitForm2\n\n\nsection CircuitForm3\n\n/-- Form 3 of circuits in `M\u2081 \u0394 M\u2082`:\n    sets `C\u2081 \u0394 C\u2082` where `C\u2081` and `C\u2082` are circuits in `M\u2081` and `M\u2082`, respectively,\n    with `C\u2081 \u2229 (M\u2081.E \u2229 M\u2082.E)` and `C\u2082 \u2229 (M\u2081.E \u2229 M\u2082.E)` being the same one-element set.\n    Here we use equivalent definition by denoting `p` the single element in `C\u2081 \u2229 C\u2082` and\n    expressing `C\u2081` and `C\u2082` via `p`, `C`, and ground sets of `M\u2081` and `M\u2082`. -/\ndef DeltaSumCircuitForm3 (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C : Set \u03b1) (p : \u03b1) : Prop :=\n  M\u2081.toMatroid.Circuit ((C \u2229 M\u2081.E) \u222a {p}) \u2227\n  M\u2082.toMatroid.Circuit ((C \u2229 M\u2082.E) \u222a {p}) \u2227\n  C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)\n\n/-- Existential version of form 3 of circuits -/\ndef IsDeltaSumCircuitForm3 (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C : Set \u03b1) : Prop :=\n  \u2203 p \u2208 M\u2081.E \u2229 M\u2082.E, DeltaSumCircuitForm3 M\u2081 M\u2082 C p\n\nvariable {C : Set \u03b1} {p : \u03b1}\n\n/-- Circuit of form 3 yields a circuit in `M\u2081` after intersecting it with `M\u2081.E` and adding `p` -/\ndef DeltaSumCircuitForm3.to_circuit_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    M\u2081.toMatroid.Circuit ((C \u2229 M\u2081.E) \u222a {p}) :=\n  hC.left\n\n/-- Circuit of form 3 yields a circuit in `M\u2082` after intersecting it with `M\u2081.E` and adding `p` -/\ndef DeltaSumCircuitForm3.to_circuit_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    M\u2082.toMatroid.Circuit ((C \u2229 M\u2082.E) \u222a {p}) :=\n  hC.right.left\n\n/-- Circuit of form 3 is subset of ground set of `M\u2081 \u0394 M\u2082` -/\ndef DeltaSumCircuitForm3.subset_ground {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E) :=\n  hC.right.right\n\n/-- Singleton element in definition of circuit form 3 lies in `M\u2081.E` -/\nlemma DeltaSumCircuitForm3.singleton_subset_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    {p} \u2286 M\u2081.E :=\n  (Set.union_subset_iff.\u2192 hC.to_circuit_M\u2081.subset_ground).right\n\n/-- Singleton element in definition of circuit form 3 lies in `M\u2082.E` -/\nlemma DeltaSumCircuitForm3.singleton_subset_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    {p} \u2286 M\u2082.E :=\n  (Set.union_subset_iff.\u2192 hC.to_circuit_M\u2082.subset_ground).right\n\n/-- Singleton element in definition of circuit form 3 lies in `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm3.singleton_subset_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    {p} \u2286 M\u2081.E \u2229 M\u2082.E :=\n  Set.subset_inter hC.singleton_subset_M\u2081 hC.singleton_subset_M\u2082\n\n/-- Circuit of form 3 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma DeltaSumCircuitForm3.subset_union {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    C \u2286 M\u2081.E \u222a M\u2082.E :=\n  sub_union_diff_sub_union hC.subset_ground\n\n/-- Circuit of form 3 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm3.disjoint_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  Set.disjoint_of_subset_left hC.subset_ground Set.disjoint_sdiff_left\n\n/-- Circuit of form 3 intersected with `M\u2081.E` is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm3.disjoint_inter_M\u2081_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    C \u2229 M\u2081.E \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.disjoint_inter.inter_left M\u2081.E\n\n/-- Circuit of form 3 intersected with `M\u2081.E` is disjoint with `M\u2082.E` -/\nlemma DeltaSumCircuitForm3.disjoint_inter_M\u2081_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    C \u2229 M\u2081.E \u2ad7 M\u2082.E := by\n  rw [Set.disjoint_iff_inter_eq_empty, Set.inter_assoc, \u2190Set.disjoint_iff_inter_eq_empty]\n  exact hC.disjoint_inter\n\n/-- Circuit of form 3 intersected with `M\u2081.E` is disjoint with its intersection with `M\u2082.E` -/\nlemma DeltaSumCircuitForm3.disjoint_inter_M\u2081_inter_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    C \u2229 M\u2081.E \u2ad7 C \u2229 M\u2082.E :=\n  Set.disjoint_of_subset_right Set.inter_subset_right hC.disjoint_inter_M\u2081_M\u2082\n\n/-- Circuit of form 3 intersected with `M\u2082.E` is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm3.disjoint_inter_M\u2082_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    C \u2229 M\u2082.E \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.disjoint_inter.inter_left M\u2082.E\n\n", "theoremStatement": "/-- Circuit of form 3 intersected with `M\u2082.E` is disjoint with `M\u2081.E` -/\nlemma DeltaSumCircuitForm3.disjoint_inter_M\u2082_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    C \u2229 M\u2082.E \u2ad7 M\u2081.E ", "theoremName": "DeltaSumCircuitForm3.disjoint_inter_M\u2082_M\u2081", "fileCreated": {"commit": "aae07a69b2ec95e3d9a1436952a123dcb7d0d06f", "date": "2025-01-03"}, "theoremCreated": {"commit": "67629d2b74be7b972786897531b678f585a7af28", "date": "2025-02-03"}, "file": "Seymour/Seymour/Matroid/Operations/SumDelta/CircuitForms.lean", "module": "Seymour.Matroid.Operations.SumDelta.CircuitForms", "jsonFile": "Seymour.Matroid.Operations.SumDelta.CircuitForms.jsonl", "positionMetadata": {"lineInFile": 251, "tokenPositionInFile": 10864, "theoremPositionInFile": 34}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 5, "numPremises": 38}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [Set.disjoint_iff_inter_eq_empty, Set.inter_assoc, \u2190Set.disjoint_iff_inter_eq_empty, Set.inter_comm]\n  exact hC.disjoint_inter", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 137}}
{"srcContext": "import Seymour.Matroid.Operations.Sum1.Basic\nimport Seymour.Matroid.Operations.SumDelta.CircuitForms\n\n\nvariable {\u03b1 : Type} [DecidableEq \u03b1] {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n\n\nsection CircuitFormsProperties\n\n/-- Circuit of form 1 satisfies circuit predicate of `M\u2081 \u0394 M\u2082` if `M\u2081.E` and `M\u2082.E` are disjoint -/\nlemma DeltaSumCircuitForm1.disjoint_circuit_pred {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) (hMM : M\u2081.E \u2ad7 M\u2082.E) :\n    DeltaSumCircuitPred M\u2081 M\u2082 C := by\n  constructor\n  \u00b7 exact hC.circuit_form\n  \u00b7 intro C' hC' hCC'\n    obtain \u27e8hC, hCE\u27e9 := hC\n    obtain \u27e8C'_nonempty, _, X\u2081, X\u2082, hXX, hX\u2081, hX\u2082\u27e9 := hC'\n    rw [(Set.disjoint_of_subset hX\u2081.subset_ground hX\u2082.subset_ground hMM).inter_eq, Set.diff_empty] at hXX\n    have X\u2082_empty : X\u2082 = \u2205 := Set.subset_eq_empty\n      (Set.disjoint_of_subset_left (hCC'.trans hC.subset_ground) hMM (Set.subset_union_right.trans hXX.symm.subset)\n        hX\u2082.subset_ground) rfl\n    rw [X\u2082_empty, Set.union_empty] at hXX\n    rw [hXX] at hCC' C'_nonempty \u22a2\n    exact hC.right (hX\u2081.nonempty_dep C'_nonempty) hCC'\n\n", "theoremStatement": "/-- Circuit of form 2 satisfies circuit predicate of `M\u2081 \u0394 M\u2082` if `M\u2081.E` and `M\u2082.E` are disjoint -/\nlemma DeltaSumCircuitForm2.disjoint_circuit_pred {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) (hMM : M\u2081.E \u2ad7 M\u2082.E) :\n    DeltaSumCircuitPred M\u2081 M\u2082 C ", "theoremName": "DeltaSumCircuitForm2.disjoint_circuit_pred", "fileCreated": {"commit": "aae07a69b2ec95e3d9a1436952a123dcb7d0d06f", "date": "2025-01-03"}, "theoremCreated": {"commit": "67629d2b74be7b972786897531b678f585a7af28", "date": "2025-02-03"}, "file": "Seymour/Seymour/Matroid/Operations/SumDelta/SpecialCase1Sum.lean", "module": "Seymour.Matroid.Operations.SumDelta.SpecialCase1Sum", "jsonFile": "Seymour.Matroid.Operations.SumDelta.SpecialCase1Sum.jsonl", "positionMetadata": {"lineInFile": 27, "tokenPositionInFile": 1043, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 14, "numPremises": 87}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  constructor\n  \u00b7 exact hC.circuit_form\n  \u00b7 intro C' hC' hCC'\n    obtain \u27e8hC, hCE\u27e9 := hC\n    unfold DeltaSumCircuitForm at hC'\n    obtain \u27e8C'_nonempty, _, X\u2081, X\u2082, hXX, hX\u2081, hX\u2082\u27e9 := hC'\n    rw [(Set.disjoint_of_subset hX\u2081.subset_ground hX\u2082.subset_ground hMM).inter_eq, Set.diff_empty] at hXX\n    have X\u2081_empty : X\u2081 = \u2205 := Set.subset_eq_empty\n      ((Set.disjoint_of_subset_right (hCC'.trans hC.subset_ground) hMM).symm (Set.subset_union_left.trans hXX.symm.subset)\n        hX\u2081.subset_ground) rfl\n    rw [X\u2081_empty, Set.empty_union] at hXX\n    rw [hXX] at hCC' C'_nonempty \u22a2\n    exact hC.right (hX\u2082.nonempty_dep C'_nonempty) hCC'", "proofType": "tactic", "proofLengthLines": 13, "proofLengthTokens": 632}}
{"srcContext": "import Mathlib.Data.Matroid.Closure\nimport Seymour.Basic\n\n-- we should use https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Data/Matroid/Circuit.lean instead\n\nvariable {\u03b1 : Type}\n\n/-- Circuit is minimal dependent subset. -/\ndef Matroid.Circuit (M : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  Minimal M.Dep C\n\n/-- Every circuit is dependent. -/\nlemma Matroid.Circuit.dep (M : Matroid \u03b1) {C : Set \u03b1} (hC : M.Circuit C) : M.Dep C :=\n  hC.left\n\n/-- Every circuit is a subset of the ground set. -/\nlemma Matroid.Circuit.subset_ground (M : Matroid \u03b1) {C : Set \u03b1} (hC : M.Circuit C) : C \u2286 M.E :=\n  hC.left.right\n\n/-- Equivalence with explicit definition of circuits. -/\nlemma Matroid.circuit_iff_def (M : Matroid \u03b1) (C : Set \u03b1) :\n    M.Circuit C \u2194 M.Dep C \u2227 \u2200 C' : Set \u03b1, M.Dep C' \u2192 C' \u2286 C \u2192 C \u2286 C' :=\n  rfl.to_iff\n\n/-- Every strict subset of a circuit is independent. -/\nlemma Matroid.Circuit.indep_ssub {M : Matroid \u03b1} {C C' : Set \u03b1} (hC : M.Circuit C) (hC' : C' \u2282 C) :\n    M.Indep C' := by\n  by_contra notIndep_M_C'\n  have C'_sub_C : C' \u2286 C := subset_of_ssubset hC'\n  have C_sub_E : C \u2286 M.E := hC.subset_ground\n  have C'_sub_E : C' \u2286 M.E := hC'.subset.trans C_sub_E\n  exact hC'.ne.symm ((hC.right (M.dep_of_not_indep notIndep_M_C' C'_sub_E) C'_sub_C).antisymm C'_sub_C)\n\n/-- Deleting one element from a circuit produces an independent set. -/\nlemma Matroid.Circuit.indep_diff_singleton {M : Matroid \u03b1} {C : Set \u03b1} {a : \u03b1} (hC : M.Circuit C) (ha : a \u2208 C) :\n    M.Indep (C \\ {a}) :=\n  hC.indep_ssub (Set.diff_singleton_sSubset.\u2190 ha)\n\n", "theoremStatement": "/-- Empty set is not a circuit. -/\nlemma Matroid.Circuit.not_empty {M : Matroid \u03b1} (hM : M.Circuit \u2205) : False ", "theoremName": "Matroid.Circuit.not_empty", "fileCreated": {"commit": "b44bff2f1ee71349fa9fa251579a0f5a0e575538", "date": "2024-12-19"}, "theoremCreated": {"commit": "01dccb2ce3fd86d02c4d4e8717683bc40d78fa42", "date": "2025-01-15"}, "file": "Seymour/Seymour/Matroid/Notions/Circuit.lean", "module": "Seymour.Matroid.Notions.Circuit", "jsonFile": "Seymour.Matroid.Notions.Circuit.jsonl", "positionMetadata": {"lineInFile": 39, "tokenPositionInFile": 1540, "theoremPositionInFile": 6}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 1, "numPremises": 16}, "proofMetadata": {"hasProof": true, "proof": ":=\n  hM.left.left M.empty_indep", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 31}}
{"srcContext": "import Mathlib.Data.Matroid.IndepAxioms\n\nimport Seymour.Basic\nimport Seymour.ForMathlib.SetTheory\n\n\n/-- Data describing a binary matroid on the ground set `X \u222a Y` where `X` and `Y` are bundled.\nNot in sync with `Matroid.Constructors.VectorMatroid/StandardRepr` currently! -/\nstructure StandardRepresentation (\u03b1 : Type) [DecidableEq \u03b1] where\n  /-- Basis elements \u2192 row indices of [`1 | B`] -/\n  X : Set \u03b1\n  /-- Non-basis elements \u2192 column indices of `B` -/\n  Y : Set \u03b1\n  /-- Necessary decidability -/\n  decmemX : \u2200 a, Decidable (a \u2208 X)\n  /-- Necessary decidability -/\n  decmemY : \u2200 a, Decidable (a \u2208 Y)\n  /-- Basis and nonbasis elements are disjoint -/\n  hXY : X \u2ad7 Y\n  /-- The standard representation matrix -/\n  B : Matrix X Y Z2\n\n-- Automatically infer decidability when `StandardRepresentation` is present.\nattribute [instance] StandardRepresentation.decmemX\nattribute [instance] StandardRepresentation.decmemY\n\nvariable {\u03b1 : Type} [DecidableEq \u03b1] {X Y : Set \u03b1} [\u2200 a, Decidable (a \u2208 X)] [\u2200 a, Decidable (a \u2208 Y)]\n\n/-- Given matrix `B`, whether the set of columns `S` in the (standard) representation [`1 | B`] `Z2`-independent. -/\ndef Matrix.IndepCols (B : Matrix X Y Z2) (S : Set \u03b1) : Prop :=\n  \u2203 hs : S \u2286 X \u222a Y, LinearIndependent Z2 ((Matrix.fromCols 1 B).submatrix id (Subtype.toSum \u2218 hs.elem)).transpose\n\n\n/-- The empty set of columns is linearly independent. -/\ntheorem Matrix.indepCols_empty {B : Matrix X Y Z2} : B.IndepCols \u2205 := by\n  use Set.empty_subset (X \u222a Y)\n  exact linearIndependent_empty_type\n\n/-- A subset of a linearly independent set of columns is linearly independent. -/\ntheorem Matrix.indepCols_subset {B : Matrix X Y Z2} (I J : Set \u03b1) (hBJ : B.IndepCols J) (hIJ : I \u2286 J) :\n    B.IndepCols I := by\n  obtain \u27e8hJ, hB\u27e9 := hBJ\n  use hIJ.trans hJ\n  show LinearIndependent Z2 (fun i x => Matrix.fromCols 1 B x ((hJ.elem (Subtype.map id hIJ i)).toSum))\n  apply hB.comp\n  intro _ _ hf\n  apply Subtype.eq\n  simpa [Subtype.map] using hf\n\n/-- A nonmaximal linearly independent set of columns can be augmented with another linearly independent column. -/\ntheorem Matrix.indepCols_augment {B : Matrix X Y Z2} (I J : Set \u03b1)\n    (hBI : B.IndepCols I) (hBI' : \u00acMaximal B.IndepCols I) (hBJ : Maximal B.IndepCols J) :\n    \u2203 x \u2208 J \\ I, B.IndepCols (x \u1543 I) := by\n  sorry\n\n/-- Any set of columns has the maximal subset property. -/\ntheorem Matrix.indepCols_maximal {B : Matrix X Y Z2} (S : Set \u03b1) :\n    Matroid.ExistsMaximalSubsetProperty B.IndepCols S := by\n  sorry\n\n/-- Binary matroid given by its standard representation matrix expressed as `IndepMatroid`. -/\ndef Matrix.toIndepMatroid (B : Matrix X Y Z2) : IndepMatroid \u03b1 where\n  E := X \u222a Y\n  Indep := B.IndepCols\n  indep_empty := B.indepCols_empty\n  indep_subset := B.indepCols_subset\n  indep_aug := B.indepCols_augment\n  indep_maximal S _ := B.indepCols_maximal S\n  subset_ground _ := Exists.fst\n\n\n/-- Binary matroid generated by its standard representation matrix, expressed as `Matroid`. -/\ndef Matrix.toMatroid (B : Matrix X Y Z2) : Matroid \u03b1 := B.toIndepMatroid.matroid\n\n/-- Convert `StandardRepresentation` to `Matroid`. -/\ndef StandardRepresentation.toMatroid (M : StandardRepresentation \u03b1) : Matroid \u03b1 :=\n  M.B.toMatroid\n\n@[simp] -- API\nlemma StandardRepresentation.E_eq (M : StandardRepresentation \u03b1) : M.toMatroid.E = M.X \u222a M.Y :=\n  rfl\n\n", "theoremStatement": "@[simp] -- API\nlemma StandardRepresentation.indep_eq (M : StandardRepresentation \u03b1) : M.toMatroid.Indep = M.B.IndepCols ", "theoremName": "StandardRepresentation.indep_eq", "fileCreated": {"commit": "614ecc7fe89749171933326a0f077e8d8a24cecb", "date": "2025-02-03"}, "theoremCreated": {"commit": "74722a3f54befb275eb7729e168db1478932de5e", "date": "2024-12-05"}, "file": "Seymour/Seymour/Matroid/Operations/MatrixSums/BinaryMatroids.lean", "module": "Seymour.Matroid.Operations.MatrixSums.BinaryMatroids", "jsonFile": "Seymour.Matroid.Operations.MatrixSums.BinaryMatroids.jsonl", "positionMetadata": {"lineInFile": 83, "tokenPositionInFile": 3304, "theoremPositionInFile": 8}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 8, "repositoryPremises": true, "numRepositoryPremises": 8, "numPremises": 13}, "proofMetadata": {"hasProof": true, "proof": ":=\n  rfl", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 8}}
{"srcContext": "import Seymour.Matroid.Operations.SumDelta.Basic\nimport Seymour.ForMathlib.SetTheory\n\nset_option linter.unusedVariables false\n\nvariable {\u03b1 : Type} [DecidableEq \u03b1]\n\n\nsection Basic\n\n/-- Nonempty union of disjoint circuits of `M\u2081` satisfies circuit form of `M\u2081 \u0394 M\u2082`  -/\nlemma deltaSumCircuitForm_left {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : C.Nonempty) (hCE : C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)) (hCM\u2081 : M\u2081.toMatroid.IsUnionDisjointCircuits C) :\n    DeltaSumCircuitForm M\u2081 M\u2082 C :=\n  \u27e8hC, hCE, C, \u2205, by simp, hCM\u2081, M\u2082.toMatroid.emptyUnionDisjointCircuits\u27e9\n\n/-- Nonempty union of disjoint circuits of `M\u2082` satisfies circuit form of `M\u2081 \u0394 M\u2082`  -/\nlemma deltaSumCircuitForm_right {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : C.Nonempty) (hCE : C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)) (hCM\u2082 : M\u2082.toMatroid.IsUnionDisjointCircuits C) :\n    DeltaSumCircuitForm M\u2081 M\u2082 C :=\n  \u27e8hC, hCE, \u2205, C, by simp, M\u2081.toMatroid.emptyUnionDisjointCircuits, hCM\u2082\u27e9\n\nend Basic\n\n\nsection CircuitForm1\n\n/-- Form 1 of circuits in `M\u2081 \u0394 M\u2082`: circuits of `M\u2081` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef DeltaSumCircuitForm1 (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.toMatroid.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Circuit of form 1 is a circuit in `M\u2081` -/\nlemma DeltaSumCircuitForm1.circuit_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    M\u2081.toMatroid.Circuit C :=\n  hC.left\n\n/-- Circuit of form 1 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm1.disjoint_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of form 1 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma DeltaSumCircuitForm1.subset_union {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_left hC.circuit_M\u2081.subset_ground M\u2082.E\n\n/-- Circuit of form 1 lies in ground set of `M\u2081 \u0394 M\u2082` -/\nlemma DeltaSumCircuitForm1.subset_ground {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of form 1 lies in `M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma DeltaSumCircuitForm1.subset_M\u2081_diff_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2286 M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2081.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of form 1 is disjoint with `M\u2082.E` -/\nlemma DeltaSumCircuitForm1.disjoint_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    C \u2ad7 M\u2082.E := by\n  have hMM := diff_inter_disjoint_diff_inter M\u2081.E M\u2082.E\n  have hCM\u2082 := Set.disjoint_of_subset_left hC.subset_M\u2081_diff_inter hMM\n  have hCM\u2082 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2082, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_right] at hCM\u2082\n  exact hCM\u2082\n\n/-- Circuit of form 1 satisfies circuit form of `M\u2081 \u0394 M\u2082` -/\nlemma DeltaSumCircuitForm1.circuit_form {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm1 M\u2081 M\u2082 C) :\n    DeltaSumCircuitForm M\u2081 M\u2082 C :=\n  deltaSumCircuitForm_left hC.circuit_M\u2081.nonempty hC.subset_ground hC.circuit_M\u2081.isUnionDisjointCircuits\n\n/-- If `C` satisfies circuit predicate and is a union of disjoint circuits of `M\u2081`, then `C` is a circuit of `M\u2081` -/\nlemma DeltaSumCircuitPred.udc_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (C_pred : DeltaSumCircuitPred M\u2081 M\u2082 C) (C_udc : M\u2081.toMatroid.IsUnionDisjointCircuits C) :\n    M\u2081.toMatroid.Circuit C :=\n  have \u27e8\u27e8hC, hCE, _\u27e9, hCmin\u27e9 := C_pred\n  \u27e8C_udc.nonempty_dep hC, fun D hD hDC =>\n    have \u27e8_, D', hD', hDD'\u27e9 := M\u2081.toMatroid.dep_iff_has_circuit.\u2192 hD\n    (hCmin\n        (DeltaSumCircuitForm1.circuit_form \u27e8hD', (Set.subset_diff.\u2192 ((hDD'.trans hDC).trans hCE)).right\u27e9)\n        (hDD'.trans hDC)\n      ).trans hDD'\u27e9\n\nend CircuitForm1\n\n\nsection CircuitForm2\n\n/-- Form 2 of circuits in `M\u2081 \u0394 M\u2082`: circuits of `M\u2082` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef DeltaSumCircuitForm2 (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2082.toMatroid.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Circuit of form 2 is a circuit in `M\u2081` -/\nlemma DeltaSumCircuitForm2.circuit_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    M\u2082.toMatroid.Circuit C :=\n  hC.left\n\n/-- Circuit of form 2 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm2.disjoint_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of form 2 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma DeltaSumCircuitForm2.subset_union {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_right hC.circuit_M\u2082.subset_ground M\u2081.E\n\n/-- Circuit of form 2 lies in ground set of `M\u2081 \u0394 M\u2082` -/\nlemma DeltaSumCircuitForm2.subset_ground {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of form 2 lies in `M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma DeltaSumCircuitForm2.subset_M\u2082_diff_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2286 M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2082.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of form 2 is disjoint with `M\u2082.E` -/\nlemma DeltaSumCircuitForm2.disjoint_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    C \u2ad7 M\u2081.E := by\n  have hMM := diff_inter_disjoint_diff_inter M\u2081.E M\u2082.E\n  have hCM\u2082 := Set.disjoint_of_subset_right hC.subset_M\u2082_diff_inter hMM\n  have hCM\u2082 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2082.symm, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_left] at hCM\u2082\n  exact hCM\u2082\n\n/-- Circuit of form 2 satisfies circuit form of `M\u2081 \u0394 M\u2082` -/\nlemma DeltaSumCircuitForm2.circuit_form {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hC : DeltaSumCircuitForm2 M\u2081 M\u2082 C) :\n    DeltaSumCircuitForm M\u2081 M\u2082 C :=\n  deltaSumCircuitForm_right hC.circuit_M\u2082.nonempty hC.subset_ground hC.circuit_M\u2082.isUnionDisjointCircuits\n\n/-- If `C` satisfies circuit predicate and is a union of disjoint circuits of `M\u2082`, then `C` is a circuit of `M\u2082` -/\nlemma DeltaSumCircuitPred.udc_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1} {C : Set \u03b1}\n    (hCpred : DeltaSumCircuitPred M\u2081 M\u2082 C) (hCudc : M\u2082.toMatroid.IsUnionDisjointCircuits C) :\n    M\u2082.toMatroid.Circuit C :=\n  have \u27e8\u27e8C_nempty, hCE, _\u27e9, hCmin\u27e9 := hCpred\n  \u27e8hCudc.nonempty_dep C_nempty, fun D hD hDC =>\n    have \u27e8_, D', hD', hDD'\u27e9 := M\u2082.toMatroid.dep_iff_has_circuit.\u2192 hD\n    (hCmin\n        (DeltaSumCircuitForm2.circuit_form \u27e8hD', (Set.subset_diff.\u2192 ((hDD'.trans hDC).trans hCE)).right\u27e9)\n        (hDD'.trans hDC)\n      ).trans hDD'\u27e9\n\nend CircuitForm2\n\n\nsection CircuitForm3\n\n/-- Form 3 of circuits in `M\u2081 \u0394 M\u2082`:\n    sets `C\u2081 \u0394 C\u2082` where `C\u2081` and `C\u2082` are circuits in `M\u2081` and `M\u2082`, respectively,\n    with `C\u2081 \u2229 (M\u2081.E \u2229 M\u2082.E)` and `C\u2082 \u2229 (M\u2081.E \u2229 M\u2082.E)` being the same one-element set.\n    Here we use equivalent definition by denoting `p` the single element in `C\u2081 \u2229 C\u2082` and\n    expressing `C\u2081` and `C\u2082` via `p`, `C`, and ground sets of `M\u2081` and `M\u2082`. -/\ndef DeltaSumCircuitForm3 (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C : Set \u03b1) (p : \u03b1) : Prop :=\n  M\u2081.toMatroid.Circuit ((C \u2229 M\u2081.E) \u222a {p}) \u2227\n  M\u2082.toMatroid.Circuit ((C \u2229 M\u2082.E) \u222a {p}) \u2227\n  C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)\n\n/-- Existential version of form 3 of circuits -/\ndef IsDeltaSumCircuitForm3 (M\u2081 M\u2082 : BinaryMatroid \u03b1) (C : Set \u03b1) : Prop :=\n  \u2203 p \u2208 M\u2081.E \u2229 M\u2082.E, DeltaSumCircuitForm3 M\u2081 M\u2082 C p\n\nvariable {C : Set \u03b1} {p : \u03b1}\n\n/-- Circuit of form 3 yields a circuit in `M\u2081` after intersecting it with `M\u2081.E` and adding `p` -/\ndef DeltaSumCircuitForm3.to_circuit_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    M\u2081.toMatroid.Circuit ((C \u2229 M\u2081.E) \u222a {p}) :=\n  hC.left\n\n/-- Circuit of form 3 yields a circuit in `M\u2082` after intersecting it with `M\u2081.E` and adding `p` -/\ndef DeltaSumCircuitForm3.to_circuit_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    M\u2082.toMatroid.Circuit ((C \u2229 M\u2082.E) \u222a {p}) :=\n  hC.right.left\n\n/-- Circuit of form 3 is subset of ground set of `M\u2081 \u0394 M\u2082` -/\ndef DeltaSumCircuitForm3.subset_ground {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    C \u2286 (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E) :=\n  hC.right.right\n\n/-- Singleton element in definition of circuit form 3 lies in `M\u2081.E` -/\nlemma DeltaSumCircuitForm3.singleton_subset_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    {p} \u2286 M\u2081.E :=\n  (Set.union_subset_iff.\u2192 hC.to_circuit_M\u2081.subset_ground).right\n\n/-- Singleton element in definition of circuit form 3 lies in `M\u2082.E` -/\nlemma DeltaSumCircuitForm3.singleton_subset_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    {p} \u2286 M\u2082.E :=\n  (Set.union_subset_iff.\u2192 hC.to_circuit_M\u2082.subset_ground).right\n\n/-- Singleton element in definition of circuit form 3 lies in `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm3.singleton_subset_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    {p} \u2286 M\u2081.E \u2229 M\u2082.E :=\n  Set.subset_inter hC.singleton_subset_M\u2081 hC.singleton_subset_M\u2082\n\n/-- Circuit of form 3 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma DeltaSumCircuitForm3.subset_union {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    C \u2286 M\u2081.E \u222a M\u2082.E :=\n  sub_union_diff_sub_union hC.subset_ground\n\n/-- Circuit of form 3 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm3.disjoint_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  Set.disjoint_of_subset_left hC.subset_ground Set.disjoint_sdiff_left\n\n/-- Circuit of form 3 intersected with `M\u2081.E` is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm3.disjoint_inter_M\u2081_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    C \u2229 M\u2081.E \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.disjoint_inter.inter_left M\u2081.E\n\n/-- Circuit of form 3 intersected with `M\u2081.E` is disjoint with `M\u2082.E` -/\nlemma DeltaSumCircuitForm3.disjoint_inter_M\u2081_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    C \u2229 M\u2081.E \u2ad7 M\u2082.E := by\n  rw [Set.disjoint_iff_inter_eq_empty, Set.inter_assoc, \u2190Set.disjoint_iff_inter_eq_empty]\n  exact hC.disjoint_inter\n\n/-- Circuit of form 3 intersected with `M\u2081.E` is disjoint with its intersection with `M\u2082.E` -/\nlemma DeltaSumCircuitForm3.disjoint_inter_M\u2081_inter_M\u2082 {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    C \u2229 M\u2081.E \u2ad7 C \u2229 M\u2082.E :=\n  Set.disjoint_of_subset_right Set.inter_subset_right hC.disjoint_inter_M\u2081_M\u2082\n\n/-- Circuit of form 3 intersected with `M\u2082.E` is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma DeltaSumCircuitForm3.disjoint_inter_M\u2082_inter {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    C \u2229 M\u2082.E \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.disjoint_inter.inter_left M\u2082.E\n\n/-- Circuit of form 3 intersected with `M\u2082.E` is disjoint with `M\u2081.E` -/\nlemma DeltaSumCircuitForm3.disjoint_inter_M\u2082_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    C \u2229 M\u2082.E \u2ad7 M\u2081.E := by\n  rw [Set.disjoint_iff_inter_eq_empty, Set.inter_assoc, \u2190Set.disjoint_iff_inter_eq_empty, Set.inter_comm]\n  exact hC.disjoint_inter\n\n/-- Circuit of form 3 intersected with `M\u2082.E` is disjoint with its intersection with `M\u2081.E` -/\nlemma DeltaSumCircuitForm3.disjoint_inter_M\u2082_inter_M\u2081 {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    C \u2229 M\u2082.E \u2ad7 C \u2229 M\u2081.E :=\n  hC.disjoint_inter_M\u2081_inter_M\u2082.symm\n\n/-- Circuit of form 3 has nonempty intersection with `M\u2081.E` provided {p} is not a circuit in `M\u2081` -/\nlemma DeltaSumCircuitForm3.inter_M\u2081_nonempty {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) (hp : \u00ac(M\u2081.toMatroid.Circuit {p})) :\n    (C \u2229 M\u2081.E).Nonempty := by\n  by_contra! C_inter_E\u2081_empty\n  have hCM\u2081 := hC.to_circuit_M\u2081\n  rw [C_inter_E\u2081_empty, Set.empty_union] at hCM\u2081\n  exact hp hCM\u2081\n\n/-- Circuit of form 3 has nonempty intersection with `M\u2082.E` provided {p} is not a circuit in `M\u2082` -/\nlemma DeltaSumCircuitForm3.inter_M\u2082_nonempty {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) (hp : \u00ac(M\u2082.toMatroid.Circuit {p})) :\n    (C \u2229 M\u2082.E).Nonempty := by\n  by_contra! C_inter_E\u2082_empty\n  have hCM\u2082 := hC.to_circuit_M\u2082\n  rw [C_inter_E\u2082_empty, Set.empty_union] at hCM\u2082\n  exact hp hCM\u2082\n\n", "theoremStatement": "/-- Circuit of form 3 intersected with `M\u2081.E` is disjoint with `{p}` -/\nlemma DeltaSumCircuitForm3.disjoint_inter_M\u2081_p {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n    (hC : DeltaSumCircuitForm3 M\u2081 M\u2082 C p) :\n    C \u2229 M\u2081.E \u2ad7 {p} ", "theoremName": "DeltaSumCircuitForm3.disjoint_inter_M\u2081_p", "fileCreated": {"commit": "aae07a69b2ec95e3d9a1436952a123dcb7d0d06f", "date": "2025-01-03"}, "theoremCreated": {"commit": "67629d2b74be7b972786897531b678f585a7af28", "date": "2025-02-03"}, "file": "Seymour/Seymour/Matroid/Operations/SumDelta/CircuitForms.lean", "module": "Seymour.Matroid.Operations.SumDelta.CircuitForms", "jsonFile": "Seymour.Matroid.Operations.SumDelta.CircuitForms.jsonl", "positionMetadata": {"lineInFile": 282, "tokenPositionInFile": 12316, "theoremPositionInFile": 38}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 6, "numPremises": 23}, "proofMetadata": {"hasProof": true, "proof": ":=\n  Set.disjoint_of_subset_right hC.singleton_subset_inter hC.disjoint_inter_M\u2081_inter", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 86}}
{"srcContext": "import Mathlib.Data.Set.SymmDiff\nimport Mathlib.Order.CompletePartialOrder\nimport Mathlib.Order.Disjoint\nimport Mathlib.Order.SymmDiff\nimport Mathlib.Tactic\n\nimport Seymour.Basic\n\n/-!\nThis provides lemmas about sets (mostly dealing with disjointness) that are missing in Mathlib.\n-/\n\nvariable {\u03b1 : Type}\n\nsection Other\n\nlemma set_union_union_eq_rev (X Y Z : Set \u03b1) : X \u222a Y \u222a Z = Z \u222a Y \u222a X := by\n  rw [Set.union_assoc, Set.union_comm, Set.union_comm Y Z]\n\nlemma setminus_inter_union_eq_union {X Y : Set \u03b1} : X \\ (X \u2229 Y) \u222a Y = X \u222a Y := by\n  tauto_set\n\nlemma nonempty_inter_not_ssubset_empty_inter {A B E : Set \u03b1} (hA : (A \u2229 E).Nonempty) (hB : B \u2229 E = \u2205) :\n    \u00ac(A \u2282 B) := by\n  intro \u27e8hAB, _\u27e9\n  obtain \u27e8x, hxAE\u27e9 := hA\n  have hxBE : x \u2208 B \u2229 E := (Set.inter_subset_inter hAB fun _ => id) hxAE\n  rw [hB] at hxBE\n  tauto\n\nlemma ssubset_self_union_other_elem {a : \u03b1} {X : Set \u03b1} (ha : a \u2209 X) :\n    X \u2282 X \u222a {a} := by\n  constructor\n  \u00b7 exact Set.subset_union_left\n  \u00b7 by_contra hX\n    rw [Set.union_subset_iff] at hX\n    obtain \u27e8_, haa\u27e9 := hX\n    tauto\n\nlemma singleton_union_ssubset_union_iff {a : \u03b1} {A B : Set \u03b1} (haA : a \u2209 A) (haB : a \u2209 B) :\n    A \u222a {a} \u2282 B \u222a {a} \u2194 A \u2282 B := by\n  constructor\n  \u00b7 intro hAB\n    obtain \u27e8hABl, hABr\u27e9 := hAB\n    constructor\n    \u00b7 intro x hx\n      apply ne_of_mem_of_not_mem hx at haA\n      cases hABl (Set.mem_union_left {a} hx) <;> tauto\n    \u00b7 by_contra hBA\n      apply Set.union_subset_union_left {a} at hBA\n      tauto\n  \u00b7 intro hAB\n    obtain \u27e8hABl, hABr\u27e9 := hAB\n    constructor\n    \u00b7 exact Set.union_subset_union_left {a} hABl\n    \u00b7 by_contra hBA\n      rw [Set.union_singleton, Set.union_singleton] at hBA\n      apply (Set.insert_subset_insert_iff haB).\u2192 at hBA\n      tauto\n\nlemma ssub_parts_ssub {A B E\u2081 E\u2082 : Set \u03b1}\n    (hA : A \u2286 E\u2081 \u222a E\u2082) (hB : B \u2286 E\u2081 \u222a E\u2082) (hAB\u2081 : A \u2229 E\u2081 \u2282 B \u2229 E\u2081) (hAB\u2082 : A \u2229 E\u2082 \u2282 B \u2229 E\u2082) :\n    A \u2282 B := by\n  constructor\n  \u00b7 obtain \u27e8hE\u2081, _\u27e9 := hAB\u2081\n    obtain \u27e8hE\u2082, _\u27e9 := hAB\u2082\n    rw [Set.left_eq_inter.\u2190 hA, Set.left_eq_inter.\u2190 hB, Set.inter_union_distrib_left, Set.inter_union_distrib_left]\n    exact Set.union_subset_union hE\u2081 hE\u2082\n  \u00b7 intro hBA\n    obtain \u27e8_, hE\u2081\u27e9 := hAB\u2081\n    obtain \u27e8x, hxBE\u2081, hxnAE\u2081\u27e9 := Set.not_subset.\u2192 hE\u2081\n    have hxB : x \u2208 B := Set.mem_of_mem_inter_left hxBE\u2081\n    have hxE\u2081 : x \u2208 E\u2081 := Set.mem_of_mem_inter_right hxBE\u2081\n    tauto\n\nlemma HasSubset.Subset.parts_eq {A E\u2081 E\u2082 : Set \u03b1} (hA : A \u2286 E\u2081 \u222a E\u2082) : (A \u2229 E\u2081) \u222a (A \u2229 E\u2082) = A :=\n  ((subset_of_subset_of_eq\n    (Set.subset_inter (fun _ => id) hA)\n    (Set.inter_union_distrib_left A E\u2081 E\u2082)).antisymm\n  (Set.union_subset Set.inter_subset_left Set.inter_subset_left)).symm\n\nlemma elem_notin_set_minus_singleton (a : \u03b1) (X : Set \u03b1) : a \u2209 X \\ {a} := Set.not_mem_diff_of_mem rfl\n\nlemma sub_union_diff_sub_union {A B C : Set \u03b1} (hA : A \u2286 B \\ C) : A \u2286 B :=\n  fun _ hA' => Set.diff_subset (hA hA')\n\nlemma singleton_inter_in_left {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : a \u2208 X :=\n  Set.mem_of_mem_inter_left (ha.symm.subset rfl)\n\nlemma singleton_inter_in_right {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : a \u2208 Y :=\n  Set.mem_of_mem_inter_right (ha.symm.subset rfl)\n\nlemma singleton_inter_subset_left {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : {a} \u2286 X := by\n  rw [Set.singleton_subset_iff]\n  exact singleton_inter_in_left ha\n\nlemma singleton_inter_subset_right {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : {a} \u2286 Y := by\n  rw [Set.singleton_subset_iff]\n  exact singleton_inter_in_right ha\n\n/-- Being a subset is preserved under subtracting sets. -/\nlemma diff_subset_parent {X\u2081 X\u2082 E : Set \u03b1} (hX\u2081E : X\u2081 \u2286 E) :\n    X\u2081 \\ X\u2082 \u2286 E :=\n  Set.diff_subset_iff.\u2190 (Set.subset_union_of_subset_right hX\u2081E X\u2082)\n\n/-- Being a subset is preserved under taking intersections. -/\nlemma inter_subset_parent_left {X\u2081 X\u2082 E : Set \u03b1} (hX\u2081E : X\u2081 \u2286 E) :\n    X\u2081 \u2229 X\u2082 \u2286 E :=\n  (Set.inter_subset_inter_left X\u2082 hX\u2081E).trans Set.inter_subset_left\n\n/-- Being a subset is preserved under taking intersections. -/\nlemma inter_subset_parent_right {X\u2081 X\u2082 E : Set \u03b1} (hX\u2082E : X\u2082 \u2286 E) :\n    X\u2081 \u2229 X\u2082 \u2286 E := by\n  rw [Set.inter_comm]\n  exact inter_subset_parent_left hX\u2082E\n\n/-- Intersection of two sets is subset of their union. -/\nlemma inter_subset_union {X\u2081 X\u2082 : Set \u03b1} :\n    X\u2081 \u2229 X\u2082 \u2286 X\u2081 \u222a X\u2082 :=\n  inter_subset_parent_left Set.subset_union_left\n\nlemma subset_diff_empty_eq {A B : Set \u03b1} (hAB : A \u2286 B) (hBA : B \\ A = \u2205) : A = B :=\n  A.union_empty \u25b8 hBA \u25b8 Set.union_diff_cancel hAB\n\nend Other\n\n\nsection Disjoint\n\nlemma Disjoint.ni_of_in {X Y : Set \u03b1} {a : \u03b1} (hXY : X \u2ad7 Y) (ha : a \u2208 X) :\n    a \u2209 Y := by\n  intro ha'\n  simpa [hXY.inter_eq] using Set.mem_inter ha ha'\n\nlemma disjoint_of_singleton_inter_left_wo {X Y : Set \u03b1} {a : \u03b1} (hXY : X \u2229 Y = {a}) :\n    X \\ {a} \u2ad7 Y := by\n  tauto_set\n\nlemma disjoint_of_singleton_inter_right_wo {X Y : Set \u03b1} {a : \u03b1} (hXY : X \u2229 Y = {a}) :\n    X \u2ad7 Y \\ {a} := by\n  rw [disjoint_comm]\n  rw [Set.inter_comm] at hXY\n  exact disjoint_of_singleton_inter_left_wo hXY\n\nlemma disjoint_of_singleton_inter_both_wo {X Y : Set \u03b1} {a : \u03b1} (hXY : X \u2229 Y = {a}) :\n    X \\ {a} \u2ad7 Y \\ {a} :=\n  Disjoint.disjoint_sdiff_left (disjoint_of_singleton_inter_right_wo hXY)\n\nlemma disjoint_of_singleton_inter_subset_left {X Y Z : Set \u03b1} {a : \u03b1} (hXY : X \u2229 Y = {a}) (hZ : Z \u2286 X) (haZ : a \u2209 Z) :\n    Z \u2ad7 Y := by\n  have hY : (Y \\ {a}) \u222a {a} = Y := (Set.diff_union_of_subset (singleton_inter_subset_right hXY))\n  rw [\u2190hY, Set.disjoint_union_right]\n  constructor\n  \u00b7 exact Set.disjoint_of_subset_left hZ (disjoint_of_singleton_inter_right_wo hXY)\n  \u00b7 exact Set.disjoint_singleton_right.\u2190 haZ\n\nlemma disjoint_of_singleton_inter_subset_right {X Y Z : Set \u03b1} {a : \u03b1} (hXY : X \u2229 Y = {a}) (hZ : Z \u2286 Y) (haZ : a \u2209 Z) :\n    X \u2ad7 Z := by\n  rw [Set.inter_comm] at hXY\n  rw [disjoint_comm]\n  exact disjoint_of_singleton_inter_subset_left hXY hZ haZ\n\nlemma disjoint_nonempty_not_subset {A B : Set \u03b1} (hAB : A \u2ad7 B) (hA : A.Nonempty) :\n    \u00ac(A \u2286 B) := by\n  intro contr\n  simp [Disjoint.eq_bot_of_le hAB, contr] at hA\n\n", "theoremStatement": "lemma disjoint_nonempty_not_ssubset {A B : Set \u03b1} (hAB : A \u2ad7 B) (hA : A.Nonempty) :\n    \u00ac(A \u2282 B) ", "theoremName": "disjoint_nonempty_not_ssubset", "fileCreated": {"commit": "b44bff2f1ee71349fa9fa251579a0f5a0e575538", "date": "2024-12-19"}, "theoremCreated": {"commit": "dfc0fd9206db9d5842f974860199dc7aff1fb0f5", "date": "2024-12-14"}, "file": "Seymour/Seymour/ForMathlib/SetTheory.lean", "module": "Seymour.ForMathlib.SetTheory", "jsonFile": "Seymour.ForMathlib.SetTheory.jsonl", "positionMetadata": {"lineInFile": 168, "tokenPositionInFile": 5872, "theoremPositionInFile": 25}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 1, "numPremises": 21}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  apply disjoint_nonempty_not_subset hAB at hA\n  intro \u27e8_, _\u27e9\n  tauto", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 75}}
{"srcContext": "import Mathlib.Data.Set.SymmDiff\nimport Mathlib.Order.CompletePartialOrder\nimport Mathlib.Order.Disjoint\nimport Mathlib.Order.SymmDiff\nimport Mathlib.Tactic\n\nimport Seymour.Basic\n\n/-!\nThis provides lemmas about sets (mostly dealing with disjointness) that are missing in Mathlib.\n-/\n\nvariable {\u03b1 : Type}\n\nsection Other\n\nlemma set_union_union_eq_rev (X Y Z : Set \u03b1) : X \u222a Y \u222a Z = Z \u222a Y \u222a X := by\n  rw [Set.union_assoc, Set.union_comm, Set.union_comm Y Z]\n\nlemma setminus_inter_union_eq_union {X Y : Set \u03b1} : X \\ (X \u2229 Y) \u222a Y = X \u222a Y := by\n  tauto_set\n\nlemma nonempty_inter_not_ssubset_empty_inter {A B E : Set \u03b1} (hA : (A \u2229 E).Nonempty) (hB : B \u2229 E = \u2205) :\n    \u00ac(A \u2282 B) := by\n  intro \u27e8hAB, _\u27e9\n  obtain \u27e8x, hxAE\u27e9 := hA\n  have hxBE : x \u2208 B \u2229 E := (Set.inter_subset_inter hAB fun _ => id) hxAE\n  rw [hB] at hxBE\n  tauto\n\nlemma ssubset_self_union_other_elem {a : \u03b1} {X : Set \u03b1} (ha : a \u2209 X) :\n    X \u2282 X \u222a {a} := by\n  constructor\n  \u00b7 exact Set.subset_union_left\n  \u00b7 by_contra hX\n    rw [Set.union_subset_iff] at hX\n    obtain \u27e8_, haa\u27e9 := hX\n    tauto\n\nlemma singleton_union_ssubset_union_iff {a : \u03b1} {A B : Set \u03b1} (haA : a \u2209 A) (haB : a \u2209 B) :\n    A \u222a {a} \u2282 B \u222a {a} \u2194 A \u2282 B := by\n  constructor\n  \u00b7 intro hAB\n    obtain \u27e8hABl, hABr\u27e9 := hAB\n    constructor\n    \u00b7 intro x hx\n      apply ne_of_mem_of_not_mem hx at haA\n      cases hABl (Set.mem_union_left {a} hx) <;> tauto\n    \u00b7 by_contra hBA\n      apply Set.union_subset_union_left {a} at hBA\n      tauto\n  \u00b7 intro hAB\n    obtain \u27e8hABl, hABr\u27e9 := hAB\n    constructor\n    \u00b7 exact Set.union_subset_union_left {a} hABl\n    \u00b7 by_contra hBA\n      rw [Set.union_singleton, Set.union_singleton] at hBA\n      apply (Set.insert_subset_insert_iff haB).\u2192 at hBA\n      tauto\n\nlemma ssub_parts_ssub {A B E\u2081 E\u2082 : Set \u03b1}\n    (hA : A \u2286 E\u2081 \u222a E\u2082) (hB : B \u2286 E\u2081 \u222a E\u2082) (hAB\u2081 : A \u2229 E\u2081 \u2282 B \u2229 E\u2081) (hAB\u2082 : A \u2229 E\u2082 \u2282 B \u2229 E\u2082) :\n    A \u2282 B := by\n  constructor\n  \u00b7 obtain \u27e8hE\u2081, _\u27e9 := hAB\u2081\n    obtain \u27e8hE\u2082, _\u27e9 := hAB\u2082\n    rw [Set.left_eq_inter.\u2190 hA, Set.left_eq_inter.\u2190 hB, Set.inter_union_distrib_left, Set.inter_union_distrib_left]\n    exact Set.union_subset_union hE\u2081 hE\u2082\n  \u00b7 intro hBA\n    obtain \u27e8_, hE\u2081\u27e9 := hAB\u2081\n    obtain \u27e8x, hxBE\u2081, hxnAE\u2081\u27e9 := Set.not_subset.\u2192 hE\u2081\n    have hxB : x \u2208 B := Set.mem_of_mem_inter_left hxBE\u2081\n    have hxE\u2081 : x \u2208 E\u2081 := Set.mem_of_mem_inter_right hxBE\u2081\n    tauto\n\nlemma HasSubset.Subset.parts_eq {A E\u2081 E\u2082 : Set \u03b1} (hA : A \u2286 E\u2081 \u222a E\u2082) : (A \u2229 E\u2081) \u222a (A \u2229 E\u2082) = A :=\n  ((subset_of_subset_of_eq\n    (Set.subset_inter (fun _ => id) hA)\n    (Set.inter_union_distrib_left A E\u2081 E\u2082)).antisymm\n  (Set.union_subset Set.inter_subset_left Set.inter_subset_left)).symm\n\nlemma elem_notin_set_minus_singleton (a : \u03b1) (X : Set \u03b1) : a \u2209 X \\ {a} := Set.not_mem_diff_of_mem rfl\n\nlemma sub_union_diff_sub_union {A B C : Set \u03b1} (hA : A \u2286 B \\ C) : A \u2286 B :=\n  fun _ hA' => Set.diff_subset (hA hA')\n\nlemma singleton_inter_in_left {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : a \u2208 X :=\n  Set.mem_of_mem_inter_left (ha.symm.subset rfl)\n\nlemma singleton_inter_in_right {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : a \u2208 Y :=\n  Set.mem_of_mem_inter_right (ha.symm.subset rfl)\n\nlemma singleton_inter_subset_left {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : {a} \u2286 X := by\n  rw [Set.singleton_subset_iff]\n  exact singleton_inter_in_left ha\n\nlemma singleton_inter_subset_right {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : {a} \u2286 Y := by\n  rw [Set.singleton_subset_iff]\n  exact singleton_inter_in_right ha\n\n", "theoremStatement": "/-- Being a subset is preserved under subtracting sets. -/\nlemma diff_subset_parent {X\u2081 X\u2082 E : Set \u03b1} (hX\u2081E : X\u2081 \u2286 E) :\n    X\u2081 \\ X\u2082 \u2286 E ", "theoremName": "diff_subset_parent", "fileCreated": {"commit": "b44bff2f1ee71349fa9fa251579a0f5a0e575538", "date": "2024-12-19"}, "theoremCreated": {"commit": "4d9233309fad6a3c9d3d0d88dcfa6420fcb14dcb", "date": "2024-12-18"}, "file": "Seymour/Seymour/ForMathlib/SetTheory.lean", "module": "Seymour.ForMathlib.SetTheory", "jsonFile": "Seymour.ForMathlib.SetTheory.jsonl", "positionMetadata": {"lineInFile": 101, "tokenPositionInFile": 3399, "theoremPositionInFile": 13}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 10}, "proofMetadata": {"hasProof": true, "proof": ":=\n  Set.diff_subset_iff.\u2190 (Set.subset_union_of_subset_right hX\u2081E X\u2082)", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 69}}
{"srcContext": "import Mathlib.Order.RelClasses\nimport Mathlib.Data.Matroid.Basic\n\nimport Seymour.Basic\nimport Seymour.Matroid.Notions.IndepAxioms\n\n\n/-- Circuit predicate, defines which sets are circuits. -/\nabbrev CircuitPredicate (\u03b1 : Type) := Set \u03b1 \u2192 Prop\n\n\nvariable {\u03b1 : Type}\n\n\nsection ValidFamily\n\n/-- Family of circuits satisfying assumptions of circuit axiom (C3) from Bruhn et al. -/\nstructure ValidFamily (P : CircuitPredicate \u03b1) (X : Set \u03b1) where\n  F : X.Elem \u2192 Set \u03b1\n  hPF : \u2200 x : X.Elem, P (F x)\n  hF : \u2200 x y : X.Elem, x.val \u2208 F y \u2194 x = y -- `F y` may nevertheless contain multiple elements of `X\u1d9c`\n\n/-- Shorthand for union of sets in `ValidFamily` -/\nabbrev ValidFamily.union {P : CircuitPredicate \u03b1} {X : Set \u03b1} (F : ValidFamily P X) : Set \u03b1 :=\n  Set.iUnion F.F\n\n-- question: unused API?\nlemma ValidFamily.mem_of_elem {P : CircuitPredicate \u03b1} {X : Set \u03b1} (F : ValidFamily P X) (x : X.Elem) :\n    x.val \u2208 F.F x := by\n  rw [F.hF]\n\n-- question: unused API?\nlemma ValidFamily.outside {P : CircuitPredicate \u03b1} {C X : Set \u03b1} {F : ValidFamily P X} {z : \u03b1} (hzCF : z \u2208 C \\ F.union) :\n    z \u2209 X := by\n  intro hz\n  have := F.hF \u27e8z, hz\u27e9 \u27e8z, hz\u27e9\n  simp_all\n\nend ValidFamily\n\n\nsection CircuitAxioms\n\n/-- Circuit predicate `P` defines independence predicate: independent sets are all non-circuits. -/\ndef CircuitPredicate.toIndepPredicate (P : CircuitPredicate \u03b1) (E : Set \u03b1) : IndepPredicate \u03b1 :=\n  fun I : Set \u03b1 => I \u2286 E \u2227 \u2200 C : Set \u03b1, C \u2286 I \u2192 \u00ac(P C)\n\n/-- Axiom (C1): empty set is not a circuit. -/\ndef CircuitPredicate.NotCircuitEmpty (P : CircuitPredicate \u03b1) : Prop :=\n  \u00ac(P \u2205)\nalias CircuitPredicate.BruhnC1 := CircuitPredicate.NotCircuitEmpty\n\n/-- Axiom (C2): no circuit is a subset of another circuit. -/\ndef CircuitPredicate.CircuitNotSsubset (P : CircuitPredicate \u03b1) : Prop :=\n  \u2200 C C' : Set \u03b1, P C \u2192 P C' \u2192 \u00ac(C' \u2282 C)  -- todo: swap to \u00acC \u2282 C'\nalias CircuitPredicate.BruhnC2 := CircuitPredicate.CircuitNotSsubset\n\n/-- Axiom (C3) from Bruhn et al. -/\ndef CircuitPredicate.BruhnC3 (P : CircuitPredicate \u03b1) : Prop :=\n  \u2200 X C : Set \u03b1, \u2200 F : ValidFamily P X, \u2200 z \u2208 C \\ F.union, \u2203 C' : Set \u03b1, P C' \u2227 z \u2208 C' \u2227 C' \u2286 (C \u222a F.union) \\ X\n\n/-- Axiom (CM) from Bruhn et al.: set of all independent sets has the maximal subset property. -/\ndef CircuitPredicate.CircuitMaximal (P : CircuitPredicate \u03b1) (E : Set \u03b1) : Prop :=\n  \u2200 X : Set \u03b1, X \u2286 E \u2192 Matroid.ExistsMaximalSubsetProperty (P.toIndepPredicate E) X\nalias CircuitPredicate.BruhnCM := CircuitPredicate.CircuitMaximal\n\n/-- Every circuit is a subset of the ground set. -/\ndef CircuitPredicate.SubsetGround (P : CircuitPredicate \u03b1) (E : Set \u03b1) : Prop :=\n  \u2200 C : Set \u03b1, P C \u2192 C \u2286 E\nalias CircuitPredicate.BruhnCE := CircuitPredicate.SubsetGround\n\n/-- Strong circuit elimination axiom: if `C\u2081` and `C\u2082` are circuits with `e \u2208 C\u2081 \u2229 C\u2082` and `f \u2208 C\u2081 \\ C\u2082`,\n    then there is circuit `C\u2083` such that `f \u2208 C\u2083 \u2286 C\u2081 \u222a C\u2082 \\ {e}`. -/\ndef CircuitPredicate.StrongCircuitElim (P : CircuitPredicate \u03b1) : Prop :=\n  \u2200 C\u2081 C\u2082 : Set \u03b1, \u2200 e f, P C\u2081 \u2227 P C\u2082 \u2227 e \u2208 C\u2081 \u2229 C\u2082 \u2227 f \u2208 C\u2081 \\ C\u2082 \u2192 \u2203 C\u2083, P C\u2083 \u2227 f \u2208 C\u2083 \u2227 C\u2083 \u2286 (C\u2081 \u222a C\u2082) \\ {e}\n\n/-- Weak circuit elimination axiom: if `C\u2081` and `C\u2082` are distinct circuits and `e \u2208 C\u2081 \u2229 C\u2082`,\n    then there is circuit `C\u2083` such that `C\u2083 \u2286 C\u2081 \u222a C\u2082 \\ {e}`. -/\ndef CircuitPredicate.WeakCircuitElim (P : CircuitPredicate \u03b1) : Prop :=\n  \u2200 C\u2081 C\u2082 : Set \u03b1, C\u2081 \u2260 C\u2082 \u2192 P C\u2081 \u2192 P C\u2082 \u2192 \u2200 e \u2208 C\u2081 \u2229 C\u2082, \u2203 C\u2083, P C\u2083 \u2227 C\u2083 \u2286 (C\u2081 \u222a C\u2082) \\ {e}\n\nend CircuitAxioms\n\n\nsection CircuitAxiomRelations\n\n/-- Alternative formulation of axiom (C2). -/\nlemma CircuitPredicate.circuit_not_ssubset_iff (P : CircuitPredicate \u03b1) :\n    P.CircuitNotSsubset \u2194 \u2200 C C' : Set \u03b1, P C \u2192 P C' \u2192 C' \u2286 C \u2192 C \u2286 C' := by\n  constructor\n  \u00b7 intro hP C C' hC hC' hCC'\n    apply hP C C' hC at hC'\n    rw [ssubset_iff_subset_ne] at hC'\n    push_neg at hC'\n    exact (hC' hCC').symm.subset\n  \u00b7 intro hP C C' hC hC' hCC'\n    apply hP C C' hC at hC'\n    rw [ssubset_iff_subset_ne] at hCC'\n    exact hCC'.right.symm (Set.Subset.antisymm (hC' hCC'.left) hCC'.left)\n\n/-- Axiom (C3) implies strong circuit elimination. -/\nlemma CircuitPredicate.C3_strong_circuit_elim (P : CircuitPredicate \u03b1) :\n    P.BruhnC3 \u2192 P.StrongCircuitElim := by\n  intro hPC3 C\u2081 C\u2082 x z hxz\n  obtain \u27e8_hC\u2081, hC\u2082, hx, hz\u27e9 := hxz\n  let F : ValidFamily P {x} :=\n  \u27e8\n    (fun _ => C\u2082),\n    (fun _ => hC\u2082),\n    (by simpa using Set.mem_of_mem_inter_right hx)\n  \u27e9\n  specialize hPC3 {x} C\u2081 F\n  simp only [ValidFamily.union, Set.iUnion_coe_set, Set.mem_singleton_iff, Set.iUnion_iUnion_eq_left] at hPC3\n  specialize hPC3 z hz\n  exact hPC3\n\n/-- Strong circuit elimination implies weak circuit elimination. -/\nlemma CircuitPredicate.strong_circuit_elim_weak_circuit_elim (P : CircuitPredicate \u03b1) :\n    P.StrongCircuitElim \u2192 P.WeakCircuitElim := by\n  intro hP C\u2081 C\u2082 hCC hC\u2081 hC\u2082 e he\n  if hf : \u2203 f : \u03b1, f \u2208 C\u2081 \\ C\u2082 then\n    obtain \u27e8f, hf\u27e9 := hf\n    specialize hP C\u2081 C\u2082 e f (And.intro hC\u2081 (And.intro hC\u2082 (And.intro he hf)))\n    obtain \u27e8C\u2083, \u27e8hC\u2083, \u27e8-, _\u27e9\u27e9\u27e9 := hP\n    use C\u2083\n  else\n    push_neg at hf\n    simp only [Set.mem_diff, not_and, not_not] at hf\n    have C\u2081_sub_C\u2082 : C\u2081 \u2286 C\u2082 := hf\n    obtain \u27e8f, hff\u27e9 : (C\u2082 \\ C\u2081).Nonempty\n    \u00b7 rw [Set.diff_nonempty]\n      by_contra C\u2082_sub_C\u2081\n      exact hCC (C\u2081_sub_C\u2082.antisymm C\u2082_sub_C\u2081)\n    specialize hP C\u2082 C\u2081 e f (And.intro hC\u2082 (And.intro hC\u2081 (And.intro he.symm hff)))\n    obtain \u27e8C\u2083, \u27e8hC\u2083, \u27e8-, hCCCe\u27e9\u27e9\u27e9 := hP\n    rw [Set.union_comm] at hCCCe\n    use C\u2083\n\n/-- todo: desc -/\ndef CircuitPredicate.support (P : CircuitPredicate \u03b1) : Set \u03b1 :=\n  { C : Set \u03b1 | P C }.sUnion\n\n/-- todo: desc -/\nlemma CircuitPredicate.support_eq (P : CircuitPredicate \u03b1) :\n    Minimal (fun S : Set \u03b1 => \u2200 C : Set \u03b1, P C \u2192 C \u2286 S) P.support := by\n  sorry\n\n/-- Condition for circuit predicate to have finite support. -/\nlemma CircuitPredicate.finite_support_iff (P : CircuitPredicate \u03b1) :\n    P.support.Finite \u2194 \u2203 S : Set \u03b1, S.Finite \u2227 \u2200 C : Set \u03b1, P C \u2192 C \u2286 S := by\n  sorry\n\n/-- If `P` is finitely supported and `P` satisfies weak circuit elimination, then `P` satisfies (C3). -/\nlemma CircuitPredicate.finSup_weakCircuitElim_bruhnC3 {P : CircuitPredicate \u03b1} (hP_fin : P.support.Finite) :\n    P.WeakCircuitElim \u2192 P.BruhnC3 := by\n  sorry\n\nend CircuitAxiomRelations\n\n\nsection PredicateRelations\n\n/-- Independence predicate defines following circuit predicate: circuits are minimal dependent sets. -/\ndef IndepPredicate.ToCircuitPredicate (P : IndepPredicate \u03b1) (E : Set \u03b1) : CircuitPredicate \u03b1 :=\n  fun C : Set \u03b1 => Minimal (fun D : Set \u03b1 => \u00ac(P D) \u2227 D \u2286 E) C\n\n/-- Converting circuit predicate to independence predicate and then to circuit predicate\n    yields original independence predicate.-/\nlemma CircuitPredicate.toIndep_toCircuit (P : CircuitPredicate \u03b1) (E C : Set \u03b1) :\n    (P.toIndepPredicate E).ToCircuitPredicate E C \u2192 C \u2286 E \u2227 P C := by\n  intro \u27e8\u27e8C_dep, hCE\u27e9, C_min\u27e9\n  constructor\n  \u00b7 exact hCE\n  \u00b7 unfold CircuitPredicate.toIndepPredicate at C_dep C_min\n    push_neg at C_dep\n    obtain \u27e8D, hDC, hD\u27e9 := C_dep hCE\n    have D_ok : \u00ac(D \u2286 E \u2227 \u2200 C \u2286 D, \u00acP C) \u2227 D \u2286 E := \u27e8(by push_neg; intro; use D), hDC.trans hCE\u27e9\n    exact Set.eq_of_subset_of_subset (C_min D_ok hDC) hDC \u25b8 hD\n\n/-- todo: desc-/\nlemma CircuitPredicate.toIndep_toCircuit_iff {P : CircuitPredicate \u03b1} (hP : P.CircuitNotSsubset) (E C : Set \u03b1) :\n    (P.toIndepPredicate E).ToCircuitPredicate E C \u2194 C \u2286 E \u2227 P C := by\n  constructor\n  \u00b7 exact P.toIndep_toCircuit E C\n  \u00b7 intro \u27e8hCE, hC\u27e9\n    constructor\n    \u00b7 exact \u27e8fun \u27e8_, C_subset_E\u27e9 => (C_subset_E C Set.Subset.rfl) hC, hCE\u27e9\n    \u00b7 intro D \u27e8D_notIndep, hDE\u27e9 hDC\n      unfold CircuitPredicate.toIndepPredicate at D_notIndep\n      push_neg at D_notIndep\n      obtain \u27e8D', hDD, hD'\u27e9 := D_notIndep hDE\n      rw [CircuitPredicate.circuit_not_ssubset_iff] at hP\n      exact (hP C D' hC hD' (hDD.trans hDC)).trans hDD\n\n/-- Converting independence predicate to circuit predicate and then to independence predicate\n    yields original independence predicate.-/\nlemma IndepPredicate.toCircuit_toIndep_iff (P : IndepPredicate \u03b1) (E I : Set \u03b1) :\n    (P.ToCircuitPredicate E).toIndepPredicate E I \u2194 P I \u2227 I \u2286 E := by\n  constructor\n  \u00b7 intro \u27e8hIE, hI\u27e9\n    constructor\n    \u00b7 sorry\n    \u00b7 exact hIE\n  \u00b7 intro \u27e8hPI, hIE\u27e9\n    constructor\n    \u00b7 exact hIE\n    \u00b7 sorry\n\n/-- Converting independence predicate of matroid to circuit predicate and then to independence predicate\n    yields original independence predicate. -/\nlemma IndepPredicate.matroid_toCircuit_toIndep_iff (M : Matroid \u03b1) (I : Set \u03b1) :\n    (M.IndepPredicate.ToCircuitPredicate M.E).toIndepPredicate M.E I \u2194 I \u2286 M.E \u2227 M.Indep I := by\n  constructor\n  \u00b7 intro \u27e8hIE, hI\u27e9\n    constructor\n    \u00b7 exact hIE\n    \u00b7 -- hI : I contains no circuit\n      let hIE' := hIE\n      apply M.maximality at hIE\n      specialize hIE \u2205 M.empty_indep I.empty_subset\n      obtain \u27e8J, -, \u27e8J_indep, hJI\u27e9, hJ\u27e9 := hIE\n      simp at hJ\n      have J_eq_I : J = I\n      \u00b7 by_contra hJneqI\n        have haIJ : \u2203 a : \u03b1, a \u2208 I \\ J := Set.nonempty_of_ssubset (HasSubset.Subset.ssubset_of_ne hJI hJneqI)\n        obtain \u27e8a, ha\u27e9 := haIJ\n        have notIndep_J_a : \u00acM.Indep (J \u222a {a}) := sorry\n        have hC : \u2203 C : Set \u03b1, C \u2286 J \u222a {a} \u2227 \u00acM.Indep C \u2227 \u2200 C' \u2282 C, M.Indep C' := sorry\n        obtain \u27e8C, hCJa, C_notIndep, indep_ssub_C\u27e9 := hC\n        have hJE : J \u2286 M.E := fun \u2983a\u2984 a_1 => hIE (hJI a_1)\n        have haE : {a} \u2286 M.E := Set.singleton_subset_iff.\u2190 (hIE (Set.mem_of_mem_diff ha))\n        have hCE : C \u2286 M.E := fun _ a_1 => (Set.union_subset hJE haE) (hCJa a_1)\n        have haI : {a} \u2286 I := (Set.singleton_subset_iff.\u2190 (Set.mem_of_mem_diff ha))\n        have hJaI : J \u222a {a} \u2286 I := Set.union_subset hJI haI\n        have hCI : C \u2286 I := hCJa.trans hJaI\n        unfold IndepPredicate.ToCircuitPredicate Minimal at hI\n        push_neg at hI\n        specialize hI C hCI \u27e8C_notIndep, hCE\u27e9\n        obtain \u27e8D, \u27e8hDdep, hDE\u27e9, \u27e8hDC, hCD\u27e9\u27e9 := hI\n        sorry -- todo: finish\n      exact J_eq_I \u25b8 J_indep\n  \u00b7 intro \u27e8hIE, I_indep\u27e9\n    constructor\n    \u00b7 exact hIE\n    \u00b7 intro C hCI \u27e8\u27e8C_dep, hCE\u27e9, hCmin\u27e9\n      exact C_dep (Matroid.Indep.subset I_indep hCI)\n\nend PredicateRelations\n\n\nsection CircuitToIndepAxioms\n\n/-- Independence predicate constructed from circuit predicate satisfies (I1): empty set is independent. -/\nlemma CircuitPredicate.toIndepPredicate_indepEmpty {P : CircuitPredicate \u03b1}\n    (hP : P.NotCircuitEmpty) (E : Set \u03b1) :\n    (P.toIndepPredicate E).IndepEmpty :=\n  \u27e8E.empty_subset, fun _ C_empty hC => hP (Set.subset_eq_empty C_empty rfl \u25b8 hC)\u27e9\n\n/-- Independence predicate constructed from circuit predicate satisfies (I2): subsets of independent sets are independent. -/\nlemma CircuitPredicate.toIndepPredicate_indepSubset (P : CircuitPredicate \u03b1) (E : Set \u03b1) :\n    (P.toIndepPredicate E).IndepSubset := by\n  unfold IndepPredicate.IndepSubset\n  exact fun I J hJ hIJ => \u27e8hIJ.trans hJ.left, fun C hCI hPC => hJ.right C (hCI.trans hIJ) hPC\u27e9\n\n/-- Independence predicate constructed from circuit predicate satisfies (I3): independent sets have augmentation property. -/\nlemma CircuitPredicate.toIndepPredicate_indepAug {P : CircuitPredicate \u03b1} {E : Set \u03b1}\n    (hPCM : P.CircuitMaximal E) (hPC3 : P.BruhnC3) :\n    (P.toIndepPredicate E).IndepAug := by\n  -- Proof adapted from Bruhn et al., Theorem 4.2 (ii), backward direction\n  intro I B hI hInmax hBmax\n  sorry -- todo : fix\n\n    -- (hI : P.toIndepPredicate E I)\n    -- (hPI : \u00acMaximal (P.toIndepPredicate E) I)\n    -- (hPI' : Maximal (P.toIndepPredicate E) I')\n\n  -- have hB := hI\n  -- apply hPCM at hB\n  -- specialize hB hI.1\n  -- obtain \u27e8B, hIB, hBmax\u27e9 := hB\n  -- simp only [Maximal, Set.le_eq_subset, and_imp] at hBmax\n  -- obtain \u27e8\u27e8hBindep, hBground\u27e9, hBmax\u27e9 := hBmax\n\n  -- have hIBstrict : I \u2282 B\n  -- \u00b7 rw [Set.ssubset_def]\n  --   by_contra! hBI\n  --   unfold Maximal at hInmax\n  --   push_neg at hInmax\n  --   obtain \u27e8J, hJindep, hIJ, hnJI\u27e9 := hInmax hI\n  --   have hIJneq : I \u2260 J := (ne_of_not_le hnJI).symm\n  --   have hBJ : B \u2286 J := (hBI hIB).trans hIJ\n  --   rw [hIB.antisymm (hBI hIB), hBJ.antisymm (hBmax hJindep hJindep.1 hBJ)] at hIJneq\n  --   exact hIJneq rfl\n\n  -- obtain \u27e8z, hzB, hzI\u27e9 := Set.exists_of_ssubset hIBstrict\n\n  -- if hzI' : z \u2208 I' then\n  --   exact \u27e8z, Set.mem_diff_of_mem hzI' hzI, indep_subset hBindep (Set.insert_subset hzB hIB)\u27e9\n  -- else\n  --   have J' := z \u1543 I'\n  --   have hJ'ground : J' \u2286 E := Set.insert_subset (hBground hzB) hPI'.1.1\n  --   have hJ' : \u00acP.toIndepPredicate E J'\n  --   \u00b7 intro hJ'indep\n  --     obtain \u27e8hI'indep, hI'max\u27e9 := hPI'\n  --     exact hzI' (hI'max hJ'indep (Set.subset_insert z I') (Or.inl rfl))\n\n  --   unfold CircuitPredicate.toIndepPredicate at hJ'\n  --   push_neg at hJ'\n  --   specialize hJ' hJ'ground\n  --   obtain \u27e8C, \u27e8hCcirc, hCJ'\u27e9\u27e9 := hJ'\n\n  --   have X := C \\ B\n  --   have hXJ' : X \u2286 J' := fun _ x => hCJ' (Set.diff_subset x)\n  --   have hzX : z \u2209 X := Set.not_mem_diff_of_mem hzB\n  --   have hXI' : X \u2286 I' := (Set.subset_insert_iff_of_not_mem hzX).\u2192 hXJ'\n  --   have hBX : B \u2229 X = \u2205 := Set.inter_diff_self B C\n  --   have tmp : I \u2229 X \u2286 B \u2229 X := Set.inter_subset_inter hIB Set.Subset.rfl\n  --   have hIX : I \u2229 X = \u2205 := Set.subset_eq_empty tmp hBX\n  --   have hIXsubnone : I \u2229 X \u2286 \u2205 := Set.subset_empty_iff.\u2190 hIX\n  --   have hIXdisj : Disjoint I X := Set.disjoint_iff.\u2190 hIXsubnone\n  --   have hXII' : X \u2286 I' \\ I := Set.subset_diff.\u2190 \u27e8hXI', hIXdisj.symm\u27e9\n\n  --   by_contra hx\n  --   unfold CircuitPredicate.toIndepPredicate at hx\n  --   push_neg at hx\n\n  --   have hIxground : \u2200 x \u2208 E, x \u1543 I \u2286 E := fun x a => Set.insert_subset a (fun _ hxI => hBground (hIB hxI))\n  --   have hI'mIground : I' \\ I \u2286 E := fun _ hII' => hPI'.1.1 (Set.diff_subset hII')\n  --   have hI'mIxground : \u2200 x \u2208 I' \\ I, x \u1543 I \u2286 E := fun x a => hIxground x (hI'mIground a)\n\n  --   have hz : \u2200 x \u2208 X, z \u2209 x \u1543 I\n  --   \u00b7 intro x hxx\n  --     have hxI'mI : x \u2208 I' \\ I := hXII' hxx\n  --     have hxIground : x \u1543 I \u2286 E := hIxground x (hJ'ground (hXJ' hxx))\n  --     obtain \u27e8Cx, \u27e8hCx, hCxI\u27e9\u27e9 := hx x hxI'mI hxIground\n  --     have hzx : z \u2260 x := (ne_of_mem_of_not_mem (hXI' hxx) hzI').symm\n  --     exact nmem_insert hzx hzI\n\n  --   -- for every `x \u2208 X`, take corresponding `C` from `hx` and put it into `F`\n  --   have F : ValidFamily P C X := sorry -- todo: construction\n  --   have hzxF : \u2200 x, F.F x \u2286 (x : \u03b1) \u1543 I := sorry -- holds by constructoin\n  --   have hzF : z \u2208 C \\ F.union := sorry -- holds by construction\n  --   apply hPC3 at hzF\n  --   obtain \u27e8C', hC', hzC', hCC'FX\u27e9 := hzF\n\n  --   have hCxI : \u2200 x, F.F x \\ X \u2286 I := sorry -- follows from `hzxF`\n  --   have hCxB : \u2200 x, F.F x \\ X \u2286 B := fun x _ hFFxX => hIB (hCxI x hFFxX)\n  --   have hCalt : C' \u2286 (C \\ X) \u222a Set.iUnion (F.F \u00b7 \\ X) := sorry -- holds by construction of `C'`\n  --   have hUB : Set.iUnion (F.F \u00b7 \\ X) \u2286 B := Set.iUnion_subset hCxB\n  --   have hCXB : C \\ X \u2286 B := Set.diff_subset_comm.\u2192 (fun _ => id)\n  --   have hC'exprB : (C \\ X) \u222a Set.iUnion (F.F \u00b7 \\ X) \u2286 B := Set.union_subset hCXB hUB\n  --   have hC'B : C' \u2286 B := hCalt.trans hC'exprB\n\n  --   -- contradiction: `C'` is a cycle and a subset of an independent set\n  --   obtain \u27e8hC'ground, hC'nosubcircuit\u27e9 := indep_subset hBindep hC'B\n  --   exact hC'nosubcircuit C' hC' (fun _ => id)\n\n  -- rfl\n\n/-- Independence predicate constructed from circuit predicate satisfies (IM): independent sets have maximal property. -/\nlemma CircuitPredicate.toIndepPredicate_indepMaximal (P : CircuitPredicate \u03b1) (E : Set \u03b1) :\n    (P.toIndepPredicate E).IndepMaximal E :=\n  sorry\n\n", "theoremStatement": "/-- Independence predicate constructed from circuit predicate satisfies (IE): independent sets are subsets of ground set. -/\nlemma CircuitPredicate.toIndepPredicate_subsetGround (P : CircuitPredicate \u03b1) (E : Set \u03b1) :\n    (P.toIndepPredicate E).SubsetGround E ", "theoremName": "CircuitPredicate.toIndepPredicate_subsetGround", "fileCreated": {"commit": "ee35fddd27b04eb576eb64b8bb74af513408f6ef", "date": "2024-12-21"}, "theoremCreated": {"commit": "43c746e51146ac13aa709eefe36b9f185633ea8b", "date": "2025-02-03"}, "file": "Seymour/Seymour/Matroid/Notions/CircuitAxioms.lean", "module": "Seymour.Matroid.Notions.CircuitAxioms", "jsonFile": "Seymour.Matroid.Notions.CircuitAxioms.jsonl", "positionMetadata": {"lineInFile": 365, "tokenPositionInFile": 15261, "theoremPositionInFile": 28}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 3, "numPremises": 8}, "proofMetadata": {"hasProof": true, "proof": ":=\n  fun _ => And.left", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 22}}
{"srcContext": "import Mathlib.Data.Set.SymmDiff\nimport Mathlib.Order.CompletePartialOrder\nimport Mathlib.Order.Disjoint\nimport Mathlib.Order.SymmDiff\nimport Mathlib.Tactic\n\nimport Seymour.Basic\n\n/-!\nThis provides lemmas about sets (mostly dealing with disjointness) that are missing in Mathlib.\n-/\n\nvariable {\u03b1 : Type}\n\nsection Other\n\nlemma set_union_union_eq_rev (X Y Z : Set \u03b1) : X \u222a Y \u222a Z = Z \u222a Y \u222a X := by\n  rw [Set.union_assoc, Set.union_comm, Set.union_comm Y Z]\n\nlemma setminus_inter_union_eq_union {X Y : Set \u03b1} : X \\ (X \u2229 Y) \u222a Y = X \u222a Y := by\n  tauto_set\n\nlemma nonempty_inter_not_ssubset_empty_inter {A B E : Set \u03b1} (hA : (A \u2229 E).Nonempty) (hB : B \u2229 E = \u2205) :\n    \u00ac(A \u2282 B) := by\n  intro \u27e8hAB, _\u27e9\n  obtain \u27e8x, hxAE\u27e9 := hA\n  have hxBE : x \u2208 B \u2229 E := (Set.inter_subset_inter hAB fun _ => id) hxAE\n  rw [hB] at hxBE\n  tauto\n\nlemma ssubset_self_union_other_elem {a : \u03b1} {X : Set \u03b1} (ha : a \u2209 X) :\n    X \u2282 X \u222a {a} := by\n  constructor\n  \u00b7 exact Set.subset_union_left\n  \u00b7 by_contra hX\n    rw [Set.union_subset_iff] at hX\n    obtain \u27e8_, haa\u27e9 := hX\n    tauto\n\nlemma singleton_union_ssubset_union_iff {a : \u03b1} {A B : Set \u03b1} (haA : a \u2209 A) (haB : a \u2209 B) :\n    A \u222a {a} \u2282 B \u222a {a} \u2194 A \u2282 B := by\n  constructor\n  \u00b7 intro hAB\n    obtain \u27e8hABl, hABr\u27e9 := hAB\n    constructor\n    \u00b7 intro x hx\n      apply ne_of_mem_of_not_mem hx at haA\n      cases hABl (Set.mem_union_left {a} hx) <;> tauto\n    \u00b7 by_contra hBA\n      apply Set.union_subset_union_left {a} at hBA\n      tauto\n  \u00b7 intro hAB\n    obtain \u27e8hABl, hABr\u27e9 := hAB\n    constructor\n    \u00b7 exact Set.union_subset_union_left {a} hABl\n    \u00b7 by_contra hBA\n      rw [Set.union_singleton, Set.union_singleton] at hBA\n      apply (Set.insert_subset_insert_iff haB).\u2192 at hBA\n      tauto\n\nlemma ssub_parts_ssub {A B E\u2081 E\u2082 : Set \u03b1}\n    (hA : A \u2286 E\u2081 \u222a E\u2082) (hB : B \u2286 E\u2081 \u222a E\u2082) (hAB\u2081 : A \u2229 E\u2081 \u2282 B \u2229 E\u2081) (hAB\u2082 : A \u2229 E\u2082 \u2282 B \u2229 E\u2082) :\n    A \u2282 B := by\n  constructor\n  \u00b7 obtain \u27e8hE\u2081, _\u27e9 := hAB\u2081\n    obtain \u27e8hE\u2082, _\u27e9 := hAB\u2082\n    rw [Set.left_eq_inter.\u2190 hA, Set.left_eq_inter.\u2190 hB, Set.inter_union_distrib_left, Set.inter_union_distrib_left]\n    exact Set.union_subset_union hE\u2081 hE\u2082\n  \u00b7 intro hBA\n    obtain \u27e8_, hE\u2081\u27e9 := hAB\u2081\n    obtain \u27e8x, hxBE\u2081, hxnAE\u2081\u27e9 := Set.not_subset.\u2192 hE\u2081\n    have hxB : x \u2208 B := Set.mem_of_mem_inter_left hxBE\u2081\n    have hxE\u2081 : x \u2208 E\u2081 := Set.mem_of_mem_inter_right hxBE\u2081\n    tauto\n\nlemma HasSubset.Subset.parts_eq {A E\u2081 E\u2082 : Set \u03b1} (hA : A \u2286 E\u2081 \u222a E\u2082) : (A \u2229 E\u2081) \u222a (A \u2229 E\u2082) = A :=\n  ((subset_of_subset_of_eq\n    (Set.subset_inter (fun _ => id) hA)\n    (Set.inter_union_distrib_left A E\u2081 E\u2082)).antisymm\n  (Set.union_subset Set.inter_subset_left Set.inter_subset_left)).symm\n\nlemma elem_notin_set_minus_singleton (a : \u03b1) (X : Set \u03b1) : a \u2209 X \\ {a} := Set.not_mem_diff_of_mem rfl\n\nlemma sub_union_diff_sub_union {A B C : Set \u03b1} (hA : A \u2286 B \\ C) : A \u2286 B :=\n  fun _ hA' => Set.diff_subset (hA hA')\n\nlemma singleton_inter_in_left {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : a \u2208 X :=\n  Set.mem_of_mem_inter_left (ha.symm.subset rfl)\n\nlemma singleton_inter_in_right {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : a \u2208 Y :=\n  Set.mem_of_mem_inter_right (ha.symm.subset rfl)\n\nlemma singleton_inter_subset_left {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : {a} \u2286 X := by\n  rw [Set.singleton_subset_iff]\n  exact singleton_inter_in_left ha\n\nlemma singleton_inter_subset_right {X Y : Set \u03b1} {a : \u03b1} (ha : X \u2229 Y = {a}) : {a} \u2286 Y := by\n  rw [Set.singleton_subset_iff]\n  exact singleton_inter_in_right ha\n\n/-- Being a subset is preserved under subtracting sets. -/\nlemma diff_subset_parent {X\u2081 X\u2082 E : Set \u03b1} (hX\u2081E : X\u2081 \u2286 E) :\n    X\u2081 \\ X\u2082 \u2286 E :=\n  Set.diff_subset_iff.\u2190 (Set.subset_union_of_subset_right hX\u2081E X\u2082)\n\n/-- Being a subset is preserved under taking intersections. -/\nlemma inter_subset_parent_left {X\u2081 X\u2082 E : Set \u03b1} (hX\u2081E : X\u2081 \u2286 E) :\n    X\u2081 \u2229 X\u2082 \u2286 E :=\n  (Set.inter_subset_inter_left X\u2082 hX\u2081E).trans Set.inter_subset_left\n\n/-- Being a subset is preserved under taking intersections. -/\nlemma inter_subset_parent_right {X\u2081 X\u2082 E : Set \u03b1} (hX\u2082E : X\u2082 \u2286 E) :\n    X\u2081 \u2229 X\u2082 \u2286 E := by\n  rw [Set.inter_comm]\n  exact inter_subset_parent_left hX\u2082E\n\n/-- Intersection of two sets is subset of their union. -/\nlemma inter_subset_union {X\u2081 X\u2082 : Set \u03b1} :\n    X\u2081 \u2229 X\u2082 \u2286 X\u2081 \u222a X\u2082 :=\n  inter_subset_parent_left Set.subset_union_left\n\nlemma subset_diff_empty_eq {A B : Set \u03b1} (hAB : A \u2286 B) (hBA : B \\ A = \u2205) : A = B :=\n  A.union_empty \u25b8 hBA \u25b8 Set.union_diff_cancel hAB\n\nend Other\n\n\nsection Disjoint\n\nlemma Disjoint.ni_of_in {X Y : Set \u03b1} {a : \u03b1} (hXY : X \u2ad7 Y) (ha : a \u2208 X) :\n    a \u2209 Y := by\n  intro ha'\n  simpa [hXY.inter_eq] using Set.mem_inter ha ha'\n\nlemma disjoint_of_singleton_inter_left_wo {X Y : Set \u03b1} {a : \u03b1} (hXY : X \u2229 Y = {a}) :\n    X \\ {a} \u2ad7 Y := by\n  tauto_set\n\nlemma disjoint_of_singleton_inter_right_wo {X Y : Set \u03b1} {a : \u03b1} (hXY : X \u2229 Y = {a}) :\n    X \u2ad7 Y \\ {a} := by\n  rw [disjoint_comm]\n  rw [Set.inter_comm] at hXY\n  exact disjoint_of_singleton_inter_left_wo hXY\n\nlemma disjoint_of_singleton_inter_both_wo {X Y : Set \u03b1} {a : \u03b1} (hXY : X \u2229 Y = {a}) :\n    X \\ {a} \u2ad7 Y \\ {a} :=\n  Disjoint.disjoint_sdiff_left (disjoint_of_singleton_inter_right_wo hXY)\n\nlemma disjoint_of_singleton_inter_subset_left {X Y Z : Set \u03b1} {a : \u03b1} (hXY : X \u2229 Y = {a}) (hZ : Z \u2286 X) (haZ : a \u2209 Z) :\n    Z \u2ad7 Y := by\n  have hY : (Y \\ {a}) \u222a {a} = Y := (Set.diff_union_of_subset (singleton_inter_subset_right hXY))\n  rw [\u2190hY, Set.disjoint_union_right]\n  constructor\n  \u00b7 exact Set.disjoint_of_subset_left hZ (disjoint_of_singleton_inter_right_wo hXY)\n  \u00b7 exact Set.disjoint_singleton_right.\u2190 haZ\n\nlemma disjoint_of_singleton_inter_subset_right {X Y Z : Set \u03b1} {a : \u03b1} (hXY : X \u2229 Y = {a}) (hZ : Z \u2286 Y) (haZ : a \u2209 Z) :\n    X \u2ad7 Z := by\n  rw [Set.inter_comm] at hXY\n  rw [disjoint_comm]\n  exact disjoint_of_singleton_inter_subset_left hXY hZ haZ\n\nlemma disjoint_nonempty_not_subset {A B : Set \u03b1} (hAB : A \u2ad7 B) (hA : A.Nonempty) :\n    \u00ac(A \u2286 B) := by\n  intro contr\n  simp [Disjoint.eq_bot_of_le hAB, contr] at hA\n\nlemma disjoint_nonempty_not_ssubset {A B : Set \u03b1} (hAB : A \u2ad7 B) (hA : A.Nonempty) :\n    \u00ac(A \u2282 B) := by\n  apply disjoint_nonempty_not_subset hAB at hA\n  intro \u27e8_, _\u27e9\n  tauto\n\nlemma ssubset_union_disjoint_nonempty {X Y : Set \u03b1} (hXY : X \u2ad7 Y) (hY : Y.Nonempty) :\n    X \u2282 X \u222a Y := by\n  constructor\n  \u00b7 exact Set.subset_union_left\n  \u00b7 by_contra hX\n    apply Set.diff_subset_diff_left at hX\n    rw [Set.union_diff_cancel_left (Set.disjoint_iff.\u2192 hXY), Set.diff_self] at hX\n    exact Set.not_nonempty_empty (Set.eq_empty_of_subset_empty hX \u25b8 hY)\n\nlemma union_ssubset_union_iff {A B X : Set \u03b1} (hAX : A \u2ad7 X) (hBX : B \u2ad7 X) :\n    A \u222a X \u2282 B \u222a X \u2194 A \u2282 B := by\n  constructor\n  \u00b7 intro hAB\n    rw [Set.ssubset_iff_subset_ne] at hAB \u22a2\n    constructor\n    \u00b7 have hXX : X \u2286 X := Set.Subset.rfl\n      have hAXXBXX := Set.diff_subset_diff hAB.left hXX\n      rwa [Set.union_diff_cancel_right, Set.union_diff_cancel_right] at hAXXBXX\n      \u00b7 rwa [Set.disjoint_iff] at hBX\n      \u00b7 rwa [Set.disjoint_iff] at hAX\n    \u00b7 intro\n      simp_all\n  \u00b7 intro hAB\n    have hAB' : A \u2286 B := hAB.subset\n    rw [Set.ssubset_iff_of_subset hAB'] at hAB\n    obtain \u27e8x, hx\u27e9 := hAB\n    rw [Set.ssubset_iff_of_subset (Set.union_subset_union_left X hAB')]\n    refine \u27e8x, Set.mem_union_left X hx.left, fun hx' => ?_\u27e9\n    rw [Set.mem_union] at hx'\n    cases hx' with\n    | inl hA => exact hx.right hA\n    | inr hX => exact hBX.ni_of_in hx.left hX\n\nlemma union_subset_union_iff {A B X : Set \u03b1} (hAX : A \u2ad7 X) (hBX : B \u2ad7 X) :\n    A \u222a X \u2286 B \u222a X \u2194 A \u2286 B := by\n  constructor\n  \u00b7 intro hABX\n    have hXX : (A \u222a X) \\ X \u2286 (B \u222a X) \\ X := Set.diff_subset_diff_left hABX\n    have hXA : (A \u222a X) \\ X = A := Set.union_diff_cancel_right (Set.disjoint_iff.\u2192 hAX)\n    have hXB : (B \u222a X) \\ X = B := Set.union_diff_cancel_right (Set.disjoint_iff.\u2192 hBX)\n    rwa [hXA, hXB] at hXX\n  \u00b7 exact Set.union_subset_union_left X\n\nlemma ssubset_disjoint_union_nonempty {X\u2081 X\u2082 : Set \u03b1} (hXX : X\u2081 \u2ad7 X\u2082) (hX\u2082 : X\u2082.Nonempty) :\n    X\u2081 \u2282 X\u2081 \u222a X\u2082 := by\n  rw [Set.ssubset_iff_of_subset Set.subset_union_left]\n  obtain \u27e8x, hx\u27e9 := hX\u2082\n  exact \u27e8x, Set.mem_union_right X\u2081 hx, Disjoint.ni_of_in hXX.symm hx\u27e9\n\nlemma ssubset_disjoint_nonempty_union {X\u2081 X\u2082 : Set \u03b1} (hXX : X\u2081 \u2ad7 X\u2082) (hX\u2081 : X\u2081.Nonempty) :\n    X\u2082 \u2282 X\u2081 \u222a X\u2082 := by\n  rw [disjoint_comm] at hXX\n  rw [Set.union_comm]\n  exact ssubset_disjoint_union_nonempty hXX hX\u2081\n\n/-- If two sets are disjoint, then any set is disjoint with their intersection -/\nlemma disjoint_inter_disjoint {A B : Set \u03b1} (C : Set \u03b1) (hAB : A \u2ad7 B) : C \u2ad7 A \u2229 B := by\n  rw [hAB.inter_eq]\n  exact Set.disjoint_empty C\n\nlemma diff_inter_disjoint_diff_inter (X\u2081 X\u2082 : Set \u03b1) :\n    X\u2081 \\ (X\u2081 \u2229 X\u2082) \u2ad7 X\u2082 \\ (X\u2081 \u2229 X\u2082) := by\n  rw [Set.diff_self_inter, Set.diff_inter_self_eq_diff]\n  exact disjoint_sdiff_sdiff\n\nend Disjoint\n\n\nsection symmDiff\n\n", "theoremStatement": "/-- Symmetric difference of two sets is their union minus their intersection. -/\nlemma symmDiff_eq_alt (X Y : Set \u03b1) : symmDiff X Y = (X \u222a Y) \\ (X \u2229 Y) ", "theoremName": "symmDiff_eq_alt", "fileCreated": {"commit": "b44bff2f1ee71349fa9fa251579a0f5a0e575538", "date": "2024-12-19"}, "theoremCreated": {"commit": "63b56dd8a370c1683610ec347733573ce006dddd", "date": "2025-01-03"}, "file": "Seymour/Seymour/ForMathlib/SetTheory.lean", "module": "Seymour.ForMathlib.SetTheory", "jsonFile": "Seymour.ForMathlib.SetTheory.jsonl", "positionMetadata": {"lineInFile": 244, "tokenPositionInFile": 8640, "theoremPositionInFile": 33}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 46}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  tauto_set", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 17}}
{"srcContext": "import Mathlib.Data.Matroid.Dual\nimport Seymour.Matroid.Operations.SumDelta.Basic\nimport Seymour.Matroid.Classes.Regular\n\n\nvariable {\u03b1 : Type} [DecidableEq \u03b1]\n\nsection Definition\n\n/-- Assumptions for \u0394-sum in the 3-sum case. -/\nstructure ThreeSumAssumptions (M\u2081 M\u2082 : BinaryMatroid \u03b1) where\n  /-- `M\u2081` is finite -/\n  M\u2081_finite : M\u2081.E.Finite\n  /-- `M\u2082` is finite -/\n  M\u2082_finite : M\u2082.E.Finite\n  /-- `M\u2081` contains at least 7 elements -/\n  M\u2081_card : M\u2081.E.encard \u2265 7\n  /-- `M\u2082` contains at least 7 elements -/\n  M\u2082_card : M\u2082.E.encard \u2265 7\n  -- `M\u2081` and `M\u2082` meet at a set `T` that is a triangle in both\n  Triangle_inter : (M\u2081.E \u2229 M\u2082.E).encard = 3\n  Triangle_in_M\u2081 : M\u2081.toMatroid.Circuit (M\u2081.E \u2229 M\u2082.E)\n  Triangle_in_M\u2082 : M\u2082.toMatroid.Circuit (M\u2081.E \u2229 M\u2082.E)\n  /-- Neither `M\u2081` nor `M\u2082` has a cocircuit contained in `T` -/\n  Triangle_no_cocircuit : \u2200 T' \u2286 M\u2081.E \u2229 M\u2082.E, \u00ac(M\u2081.toMatroid\u2736.Circuit T') \u2227 \u00ac(M\u2082.toMatroid\u2736.Circuit T')\n\nset_option linter.unusedVariables false in\n/-- The main way of creating a 3-sum of binary matroids. -/\ndef ThreeSumAssumptions.build3sum {M\u2081 M\u2082 : BinaryMatroid \u03b1} (assumptions : ThreeSumAssumptions M\u2081 M\u2082) : Matroid \u03b1 :=\n  deltaSumMatroid M\u2081 M\u2082\n\nend Definition\n\n\nsection Properties\n\n-- todo: probably need properties of cocircuits\n-- todo: Lemma 9.3.3 from Oxley\n-- todo: Lemma 9.3.4 from Oxley\n\nend Properties\n\n\nsection Representation\n\n-- todo: if M is representable and contains a triangle, then it can be represented by (8.5.2.left) from Truemper\n-- optional: if M is representable and contains a triangle, then it can be represented by (8.5.2.right) from Truemper\n-- todo: if M is representable and contains a triangle, then it can be represented by (8.5.3) from Truemper\n-- todo: compose (8.5.2) and (8.5.3) into (8.5.1) from Truemper\n-- todo: etc, see Sum2\n\nend Representation\n\n\nsection Regularity\n\nvariable {M\u2081 M\u2082 : BinaryMatroid \u03b1}\n\n/-- Any 3-sum of regular matroids is regular. -/\nlemma ThreeSumAssumptions.composition_isRegular (assumptions : ThreeSumAssumptions M\u2081 M\u2082)\n    (regularity\u2081 : M\u2081.toMatroid.IsRegular) (regularity\u2082 : M\u2082.toMatroid.IsRegular) :\n    assumptions.build3sum.IsRegular :=\n  sorry\n\n/-- If a regular matroid is a 3-sum of binary matroids, the left summand is regular. -/\nlemma ThreeSumAssumptions.decomposition_isRegular_left (assumptions : ThreeSumAssumptions M\u2081 M\u2082)\n    (regularity : assumptions.build3sum.IsRegular) :\n    M\u2081.toMatroid.IsRegular :=\n  sorry\n\n/-- If a regular matroid is a 3-sum of binary matroids, the right summand is regular. -/\nlemma ThreeSumAssumptions.decomposition_isRegular_right (assumptions : ThreeSumAssumptions M\u2081 M\u2082)\n    (regularity : assumptions.build3sum.IsRegular) :\n    M\u2082.toMatroid.IsRegular :=\n  sorry\n\n", "theoremStatement": "/-- If a regular matroid is a 3-sum of binary matroids, both summand matroids are regular. -/\nlemma ThreeSumAssumptions.decomposition_isRegular_both (assumptions : ThreeSumAssumptions M\u2081 M\u2082)\n    (regularity : assumptions.build3sum.IsRegular) :\n    M\u2081.toMatroid.IsRegular \u2227 M\u2082.toMatroid.IsRegular ", "theoremName": "ThreeSumAssumptions.decomposition_isRegular_both", "fileCreated": {"commit": "aae07a69b2ec95e3d9a1436952a123dcb7d0d06f", "date": "2025-01-03"}, "theoremCreated": {"commit": "82da3e879b5e70117f930d5c7ceac4783bc3fe8c", "date": "2025-02-01"}, "file": "Seymour/Seymour/Matroid/Operations/SumDelta/SpecialCase3Sum.lean", "module": "Seymour.Matroid.Operations.SumDelta.SpecialCase3Sum", "jsonFile": "Seymour.Matroid.Operations.SumDelta.SpecialCase3Sum.jsonl", "positionMetadata": {"lineInFile": 77, "tokenPositionInFile": 2684, "theoremPositionInFile": 4}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 8, "numPremises": 19}, "proofMetadata": {"hasProof": true, "proof": ":=\n  \u27e8assumptions.decomposition_isRegular_left regularity, assumptions.decomposition_isRegular_right regularity\u27e9", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 112}}
{"srcContext": "import Mathlib.Data.Matroid.Basic\nimport Seymour.Basic\n\n\n/-- Independence predicate, defines which sets are independent. -/\nabbrev IndepPredicate (\u03b1 : Type) := Set \u03b1 \u2192 Prop\n\n\nvariable {\u03b1 : Type}\n\n/-- Independence predicate of matroid. -/\ndef Matroid.IndepPredicate (M : Matroid \u03b1) : IndepPredicate \u03b1 := M.Indep\n-- TODO why does this definition exist?\n\n\nsection IndepAxioms\n\n/-- Axiom (I1): empty set is independent. -/\ndef IndepPredicate.IndepEmpty (P : IndepPredicate \u03b1) : Prop := P \u2205\nalias IndepPredicate.BruhnI1 := IndepPredicate.IndepEmpty\n\n/-- Axiom (I2): subset of independent set is independent. -/\ndef IndepPredicate.IndepSubset (P : IndepPredicate \u03b1) : Prop := \u2200 I J : Set \u03b1, P J \u2192 I \u2286 J \u2192 P I\nalias IndepPredicate.BruhnI2 := IndepPredicate.IndepSubset\n\n/-- Axiom (I3): augmentation property. -/\ndef IndepPredicate.IndepAug (P : IndepPredicate \u03b1) : Prop :=\n  \u2200 I B : Set \u03b1, P I \u2192 \u00acMaximal P I \u2192 Maximal P B \u2192 \u2203 x \u2208 B \\ I, P (x \u1543 I)\nalias IndepPredicate.BruhnI3 := IndepPredicate.IndepAug\n\n/-- Axiom (IM): set of all independent sets has the maximal subset property. -/\ndef IndepPredicate.IndepMaximal (P : IndepPredicate \u03b1) (E : Set \u03b1) : Prop :=\n  \u2200 X : Set \u03b1, X \u2286 E \u2192 Matroid.ExistsMaximalSubsetProperty P X\nalias IndepPredicate.BruhnIM := IndepPredicate.IndepMaximal\n\n/-- Every independent set is a subset of the ground set. -/\ndef IndepPredicate.SubsetGround (P : IndepPredicate \u03b1) (E : Set \u03b1) : Prop := \u2200 C : Set \u03b1, P C \u2192 C \u2286 E\nalias IndepPredicate.BruhnCE := IndepPredicate.SubsetGround\n\nend IndepAxioms\n\n\nsection MatroidIndepAxioms\n\n/-- Independence predicate of matroid satisfies (I1): empty set is independent. -/\nlemma Matroid.indepEmpty (M : Matroid \u03b1) :\n    M.IndepPredicate.IndepEmpty :=\n  M.empty_indep\n\n/-- Independence predicate of matroid satisfies (I2): subset of independent set is independent. -/\nlemma Matroid.indepSubset (M : Matroid \u03b1) :\n    M.IndepPredicate.IndepSubset :=\n  fun _ _ => Matroid.Indep.subset\n\n/-- Independence predicate of matroid satisfies (I3): augmentation property. -/\nlemma Matroid.indepAug (M : Matroid \u03b1) :\n    M.IndepPredicate.IndepAug :=\n  fun _ _ hI nonmaximal_M_I maximal_M_I' => Indep.exists_insert_of_not_maximal M hI nonmaximal_M_I maximal_M_I'\n\n/-- (Alternative proof.) Independence predicate of matroid satisfies (I3): augmentation property. -/\nlemma Matroid.indepAug' (M : Matroid \u03b1) :\n    M.IndepPredicate.IndepAug := by\n  -- Follows part of proof from Theorem 4.1 (i) from Bruhn et al.\n  intro I I' hI nonmaximal_M_I maximal_M_I'\n  have \u27e8B, hIB, maximal_B\u27e9 := M.maximality M.E Set.Subset.rfl I hI (Matroid.Indep.subset_ground hI)\n  if hBI : (B \\ I).Nonempty then\n    obtain \u27e8x, hx\u27e9 := hBI\n    if hxI' : x \u2208 I' then\n      exact \u27e8x,\n        Set.mem_diff_of_mem hxI' (Set.not_mem_of_mem_diff hx),\n        Matroid.Indep.subset maximal_B.left.left (Set.insert_subset (Set.mem_of_mem_diff hx) hIB),\n      \u27e9\n    else\n      have hB : Maximal M.Indep B :=\n        \u27e8maximal_B.left.left, fun C hC hBC => maximal_B.right \u27e8hC, Matroid.Indep.subset_ground hC\u27e9 hBC\u27e9\n      unfold Matroid.IndepPredicate at maximal_M_I'\n      rw [\u2190Matroid.base_iff_maximal_indep] at maximal_M_I' hB\n      obtain \u27e8y, hy, hMyBx\u27e9 := M.base_exchange B I' hB maximal_M_I' x (Set.mem_diff_of_mem (Set.mem_of_mem_diff hx) hxI')\n      exact \u27e8y,\n        Set.mem_diff_of_mem (Set.mem_of_mem_diff hy) (fun a => (Set.not_mem_of_mem_diff hy) (hIB a)),\n        Matroid.Indep.subset (Matroid.Base.indep hMyBx)\n          (Set.insert_subset_insert (Set.subset_diff_singleton hIB (Set.not_mem_of_mem_diff hx))),\n      \u27e9\n  else\n    have I_eq_B : I = B := Set.union_empty I \u25b8 (Set.not_nonempty_iff_eq_empty.\u2192 hBI) \u25b8 Set.union_diff_cancel hIB\n    have maximal_B : Maximal M.Indep B :=\n      \u27e8maximal_B.left.left, fun _ hC hBC => maximal_B.right \u27e8hC, Matroid.Indep.subset_ground hC\u27e9 hBC\u27e9\n    exact (nonmaximal_M_I (I_eq_B \u25b8 maximal_B)).elim\n\n", "theoremStatement": "/-- Independence predicate of matroid satisfies (IM): set of all independent sets has the maximal subset property. -/\nlemma Matroid.indepMaximal (M : Matroid \u03b1) :\n    M.IndepPredicate.IndepMaximal M.E ", "theoremName": "Matroid.indepMaximal", "fileCreated": {"commit": "ee35fddd27b04eb576eb64b8bb74af513408f6ef", "date": "2024-12-21"}, "theoremCreated": {"commit": "43c746e51146ac13aa709eefe36b9f185633ea8b", "date": "2025-02-03"}, "file": "Seymour/Seymour/Matroid/Notions/IndepAxioms.lean", "module": "Seymour.Matroid.Notions.IndepAxioms", "jsonFile": "Seymour.Matroid.Notions.IndepAxioms.jsonl", "positionMetadata": {"lineInFile": 90, "tokenPositionInFile": 3852, "theoremPositionInFile": 11}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 5}, "proofMetadata": {"hasProof": true, "proof": ":=\n  M.maximality", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 17}}
{"srcContext": "import Mathlib.Data.Set.Card\nimport Mathlib.Data.Matroid.Dual\n\nimport Seymour.ForMathlib.SetTheory\nimport Seymour.Matroid.Notions.Circuit\nimport Seymour.Matroid.Notions.CircuitAxioms\nimport Seymour.Matroid.Notions.Connectivity\nimport Seymour.Matroid.Constructors.CircuitMatroid\n\n/-!\nThis file defines 2-sum of two (general) matroids `M\u2081` and `M\u2082`, denoted as `M\u2081 \u2295\u2082 M\u2082`.\n-/\n\nvariable {\u03b1 : Type}\n\n\nsection MainDefinitions\n\n/-- `M\u2081 \u2295\u2082 M\u2082` is defined if `M\u2081` and `M\u2082` satisfy the following assumptions -/\nstructure TwoSumAssumptions (M\u2081 M\u2082 : Matroid \u03b1) : Prop where\n  /-- `M\u2081` is finite -/\n  M\u2081fin : M\u2081.Finite\n  /-- `M\u2082` is finite -/\n  M\u2082fin : M\u2082.Finite\n  /-- `M\u2081` contains at least 2 elements -/\n  M\u2081card : M\u2081.E.encard \u2265 2\n  /-- `M\u2082` contains at least 2 elements -/\n  M\u2082card : M\u2082.E.encard \u2265 2\n  /-- `M\u2081` and `M\u2082` have exactly one element in common -/\n  interSingleton : (M\u2081.E \u2229 M\u2082.E).encard = 1\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2081` -/\n  M\u2081sep : \u00acM\u2081.Separator (M\u2081.E \u2229 M\u2082.E)\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2082` -/\n  M\u2082sep : \u00acM\u2082.Separator (M\u2081.E \u2229 M\u2082.E)\n\n-- question: can avoid this assumption? -- which assumption? the finiteness?\n\n/-- Ground set of `M\u2081 \u2295\u2082 M\u2082` -/\ndef twoSumGround (M\u2081 M\u2082 : Matroid \u03b1) : Set \u03b1 :=\n  (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)\n\n/-- Type 1 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2081` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType1 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 2 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2082` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType2 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2082.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 3 of circuits in `M\u2081 \u2295\u2082 M\u2082`:\n    sets `(C\u2081 \u222a C\u2082) \\ (M\u2081.E \u2229 M\u2082.E)` where `C\u2081` and `C\u2082` are circuits in `M\u2081` and `M\u2082`, respectively,\n    and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2081` and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2082` -/\ndef TwoSumCircuitType3 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit ((C \u2229 M\u2081.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 M\u2082.Circuit ((C \u2229 M\u2082.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 C \u2286 twoSumGround M\u2081 M\u2082\n\n/-- Circuit predicate of `M\u2081 \u2295\u2082 M\u2082`, which defines 2-sum as `CircuitMatroid` -/\ndef TwoSumCircuitPred (M\u2081 M\u2082 : Matroid \u03b1) : CircuitPredicate \u03b1 :=\n  fun C : Set \u03b1 =>\n    TwoSumCircuitType1 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType2 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType3 M\u2081 M\u2082 C\n\nend MainDefinitions\n\n\nsection PropertiesAssumptions\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1}\n\n/-- 2-sum assumptions are symmetric -/\nlemma TwoSumAssumptions.symm (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    TwoSumAssumptions M\u2082 M\u2081 :=\n  \u27e8\n    assumptions.M\u2082fin,\n    assumptions.M\u2081fin,\n    assumptions.M\u2082card,\n    assumptions.M\u2081card,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.interSingleton,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2082sep,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2081sep,\n  \u27e9\n\n/-- Intersection of ground sets is nonempty -/\nlemma TwoSumAssumptions.inter_nonempty (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (M\u2081.E \u2229 M\u2082.E).Nonempty :=\n  Set.one_le_encard_iff_nonempty.\u2192 assumptions.interSingleton.symm.le\n\n/-- Intersection of ground sets is a singleton set -/\nlemma TwoSumAssumptions.inter_singleton (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    \u2203 p : \u03b1, M\u2081.E \u2229 M\u2082.E = {p} :=\n  Set.encard_eq_one.\u2192 assumptions.interSingleton\n\nvariable {p : \u03b1}\n\n/-- Singleton element in intersection of ground sets in not a loop in `M\u2081` -/\nlemma TwoSumAssumptions.inter_singleton_not_loop_M\u2081 (assumptions : TwoSumAssumptions M\u2081 M\u2082)\n    (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2081.Loop p) :=\n  (hp \u25b8 assumptions.M\u2081sep <| Matroid.separator_loop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a coloop in `M\u2081` -/\nlemma TwoSumAssumptions.inter_singleton_not_coloop_M\u2081 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2081.Coloop p) :=\n  (hp \u25b8 assumptions.M\u2081sep <| Matroid.separator_coloop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a loop in `M\u2082` -/\nlemma TwoSumAssumptions.inter_singleton_not_loop_M\u2082 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2082.Loop p) :=\n  (hp \u25b8 assumptions.M\u2082sep <| Matroid.separator_loop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a coloop in `M\u2082` -/\nlemma TwoSumAssumptions.inter_singleton_not_coloop_M\u2082 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2082.Coloop p) :=\n  (hp \u25b8 assumptions.M\u2082sep <| Matroid.separator_coloop \u00b7)\n\nend PropertiesAssumptions\n\n\nsection PropertiesGroundSet\n\n/-- Ground set of 2-sum is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma twoSumGround_disjoint_inter (M\u2081 M\u2082 : Matroid \u03b1) :\n    twoSumGround M\u2081 M\u2082 \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  Set.disjoint_sdiff_left\n\n/-- Ground sets minus their intersection are disjoint sets -/\nlemma twoSum_disjoint_grounds_diff_inter (M\u2081 M\u2082 : Matroid \u03b1) :\n    M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) \u2ad7 M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E) := by\n  rw [Set.diff_self_inter, Set.diff_inter_self_eq_diff]\n  exact disjoint_sdiff_sdiff\n\nend PropertiesGroundSet\n\n\nsection PropertiesCircuitType1\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1} {C : Set \u03b1}\n\n/-- Circuit of type 1 is a circuit in `M\u2081` -/\nlemma TwoSumCircuitType1.circuit_M\u2081 (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : M\u2081.Circuit C :=\n  hC.left\n\n/-- Circuit of type 1 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType1.disjoint_inter (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n", "theoremStatement": "/-- Circuit of type 1 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma TwoSumCircuitType1.subset_union (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \u222a M\u2082.E ", "theoremName": "TwoSumCircuitType1.subset_union", "fileCreated": {"commit": "d0eaaa305c96cd81ac061f505a81614db6856b21", "date": "2025-01-09"}, "theoremCreated": {"commit": "439c72996f29168161b974bc602629cac773728f", "date": "2025-01-08"}, "file": "Seymour/Seymour/Matroid/Operations/Sum2/Basic.lean", "module": "Seymour.Matroid.Operations.Sum2.Basic", "jsonFile": "Seymour.Matroid.Operations.Sum2.Basic.jsonl", "positionMetadata": {"lineInFile": 147, "tokenPositionInFile": 5300, "theoremPositionInFile": 16}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 3, "numPremises": 11}, "proofMetadata": {"hasProof": true, "proof": ":=\n  Set.subset_union_of_subset_left hC.circuit_M\u2081.subset_ground M\u2082.E", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 69}}
{"srcContext": "import Mathlib.Data.Matroid.IndepAxioms\n\nimport Seymour.Basic\nimport Seymour.ForMathlib.SetTheory\n\n\n/-- Data describing a binary matroid on the ground set `X \u222a Y` where `X` and `Y` are bundled.\nNot in sync with `Matroid.Constructors.VectorMatroid/StandardRepr` currently! -/\nstructure StandardRepresentation (\u03b1 : Type) [DecidableEq \u03b1] where\n  /-- Basis elements \u2192 row indices of [`1 | B`] -/\n  X : Set \u03b1\n  /-- Non-basis elements \u2192 column indices of `B` -/\n  Y : Set \u03b1\n  /-- Necessary decidability -/\n  decmemX : \u2200 a, Decidable (a \u2208 X)\n  /-- Necessary decidability -/\n  decmemY : \u2200 a, Decidable (a \u2208 Y)\n  /-- Basis and nonbasis elements are disjoint -/\n  hXY : X \u2ad7 Y\n  /-- The standard representation matrix -/\n  B : Matrix X Y Z2\n\n-- Automatically infer decidability when `StandardRepresentation` is present.\nattribute [instance] StandardRepresentation.decmemX\nattribute [instance] StandardRepresentation.decmemY\n\nvariable {\u03b1 : Type} [DecidableEq \u03b1] {X Y : Set \u03b1} [\u2200 a, Decidable (a \u2208 X)] [\u2200 a, Decidable (a \u2208 Y)]\n\n/-- Given matrix `B`, whether the set of columns `S` in the (standard) representation [`1 | B`] `Z2`-independent. -/\ndef Matrix.IndepCols (B : Matrix X Y Z2) (S : Set \u03b1) : Prop :=\n  \u2203 hs : S \u2286 X \u222a Y, LinearIndependent Z2 ((Matrix.fromCols 1 B).submatrix id (Subtype.toSum \u2218 hs.elem)).transpose\n\n\n/-- The empty set of columns is linearly independent. -/\ntheorem Matrix.indepCols_empty {B : Matrix X Y Z2} : B.IndepCols \u2205 := by\n  use Set.empty_subset (X \u222a Y)\n  exact linearIndependent_empty_type\n\n/-- A subset of a linearly independent set of columns is linearly independent. -/\ntheorem Matrix.indepCols_subset {B : Matrix X Y Z2} (I J : Set \u03b1) (hBJ : B.IndepCols J) (hIJ : I \u2286 J) :\n    B.IndepCols I := by\n  obtain \u27e8hJ, hB\u27e9 := hBJ\n  use hIJ.trans hJ\n  show LinearIndependent Z2 (fun i x => Matrix.fromCols 1 B x ((hJ.elem (Subtype.map id hIJ i)).toSum))\n  apply hB.comp\n  intro _ _ hf\n  apply Subtype.eq\n  simpa [Subtype.map] using hf\n\n/-- A nonmaximal linearly independent set of columns can be augmented with another linearly independent column. -/\ntheorem Matrix.indepCols_augment {B : Matrix X Y Z2} (I J : Set \u03b1)\n    (hBI : B.IndepCols I) (hBI' : \u00acMaximal B.IndepCols I) (hBJ : Maximal B.IndepCols J) :\n    \u2203 x \u2208 J \\ I, B.IndepCols (x \u1543 I) := by\n  sorry\n\n/-- Any set of columns has the maximal subset property. -/\ntheorem Matrix.indepCols_maximal {B : Matrix X Y Z2} (S : Set \u03b1) :\n    Matroid.ExistsMaximalSubsetProperty B.IndepCols S := by\n  sorry\n\n/-- Binary matroid given by its standard representation matrix expressed as `IndepMatroid`. -/\ndef Matrix.toIndepMatroid (B : Matrix X Y Z2) : IndepMatroid \u03b1 where\n  E := X \u222a Y\n  Indep := B.IndepCols\n  indep_empty := B.indepCols_empty\n  indep_subset := B.indepCols_subset\n  indep_aug := B.indepCols_augment\n  indep_maximal S _ := B.indepCols_maximal S\n  subset_ground _ := Exists.fst\n\n\n/-- Binary matroid generated by its standard representation matrix, expressed as `Matroid`. -/\ndef Matrix.toMatroid (B : Matrix X Y Z2) : Matroid \u03b1 := B.toIndepMatroid.matroid\n\n/-- Convert `StandardRepresentation` to `Matroid`. -/\ndef StandardRepresentation.toMatroid (M : StandardRepresentation \u03b1) : Matroid \u03b1 :=\n  M.B.toMatroid\n\n", "theoremStatement": "@[simp] -- API\nlemma StandardRepresentation.E_eq (M : StandardRepresentation \u03b1) : M.toMatroid.E = M.X \u222a M.Y ", "theoremName": "StandardRepresentation.E_eq", "fileCreated": {"commit": "614ecc7fe89749171933326a0f077e8d8a24cecb", "date": "2025-02-03"}, "theoremCreated": {"commit": "74722a3f54befb275eb7729e168db1478932de5e", "date": "2024-12-05"}, "file": "Seymour/Seymour/Matroid/Operations/MatrixSums/BinaryMatroids.lean", "module": "Seymour.Matroid.Operations.MatrixSums.BinaryMatroids", "jsonFile": "Seymour.Matroid.Operations.MatrixSums.BinaryMatroids.jsonl", "positionMetadata": {"lineInFile": 79, "tokenPositionInFile": 3186, "theoremPositionInFile": 7}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 4, "numPremises": 11}, "proofMetadata": {"hasProof": true, "proof": ":=\n  rfl", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 8}}
{"srcContext": "import Seymour.ForMathlib.MatrixTU\n\n/-!\nThis file provides notation used in the project and conversions between set-theoretical and type-theoretical definitions.\n-/\n\n/-- The finite field on 2 elements; write `Z2` for \"value\" type but `Fin 2` for \"indexing\" type. -/\nabbrev Z2 : Type := ZMod 2\n\n/-- The finite field on 3 elements; write `Z3` for \"value\" type but `Fin 3` for \"indexing\" type. -/\nabbrev Z3 : Type := ZMod 3\n\n/-- Roughly speaking `a \u1543 A` is `A \u222a {a}`. -/\ninfixr:66 \" \u1543 \" => Insert.insert\n\n/-- Writing `X \u2ad7 Y` is slightly more general than writing `X \u2229 Y = \u2205`. -/\ninfix:61 \" \u2ad7 \" => Disjoint\n\n/-- The left-to-right direction of `\u2194`. -/\npostfix:max \".\u2192\" => Iff.mp\n\n/-- The right-to-left direction of `\u2194`. -/\npostfix:max \".\u2190\" => Iff.mpr\n\n\nsection utils\n\nlemma Fin2_eq_1_of_ne_0 {a : Fin 2} (ha : a \u2260 0) : a = 1 := by\n  omega\n\nlemma Fin3_eq_2_of_ne_0_1 {a : Fin 3} (ha0 : a \u2260 0) (ha1 : a \u2260 1) : a = 2 := by\n  omega\n\n\nvariable {\u03b1 : Type}\n\n/-- Given `X \u2286 Y` cast an element of `X` as an element of `Y`. -/\ndef HasSubset.Subset.elem {X Y : Set \u03b1} (hXY : X \u2286 Y) (x : X.Elem) : Y.Elem :=\n  \u27e8x.val, hXY x.property\u27e9\n\nlemma HasSubset.Subset.elem_injective {X Y : Set \u03b1} (hXY : X \u2286 Y) : hXY.elem.Injective := by\n  intro x y hxy\n  ext\n  simpa [HasSubset.Subset.elem] using hxy\n\n/-- Convert `(X \u222a Y).Elem` to `X.Elem \u2295 Y.Elem`. -/\ndef Subtype.toSum {X Y : Set \u03b1} [\u2200 a, Decidable (a \u2208 X)] [\u2200 a, Decidable (a \u2208 Y)] (i : (X \u222a Y).Elem) : X.Elem \u2295 Y.Elem :=\n  if hiX : i.val \u2208 X then Sum.inl \u27e8i, hiX\u27e9 else\n  if hiY : i.val \u2208 Y then Sum.inr \u27e8i, hiY\u27e9 else\n  (i.property.elim hiX hiY).elim\n\n/-- Convert `X.Elem \u2295 Y.Elem` to `(X \u222a Y).Elem`. -/\ndef Sum.toUnion {X Y : Set \u03b1} (i : X.Elem \u2295 Y.Elem) : (X \u222a Y).Elem :=\n  i.casesOn Set.subset_union_left.elem Set.subset_union_right.elem\n\n/-- Converting `(X \u222a Y).Elem` to `X.Elem \u2295 Y.Elem` and back to `(X \u222a Y).Elem` gives the original element. -/\nlemma toSum_toUnion {X Y : Set \u03b1} [\u2200 a, Decidable (a \u2208 X)] [\u2200 a, Decidable (a \u2208 Y)] (i : (X \u222a Y).Elem) :\n    i.toSum.toUnion = i := by\n  if hiX : i.val \u2208 X then\n    simp_all [Subtype.toSum, Sum.toUnion, HasSubset.Subset.elem]\n  else if hiY : i.val \u2208 Y then\n    simp_all [Subtype.toSum, Sum.toUnion, HasSubset.Subset.elem]\n  else\n    exfalso\n    exact i.property.elim hiX hiY\n\n/-- Converting `X.Elem \u2295 Y.Elem` to `(X \u222a Y).Elem` and back to `X.Elem \u2295 Y.Elem` gives the original element, assuming that\n`X` and `Y` are disjoint. -/\nlemma toUnion_toSum {X Y : Set \u03b1} [\u2200 a, Decidable (a \u2208 X)] [\u2200 a, Decidable (a \u2208 Y)] (hXY : X \u2ad7 Y) (i : X.Elem \u2295 Y.Elem) :\n    i.toUnion.toSum = i := by\n  rw [Set.disjoint_right] at hXY\n  cases i <;> simp [Subtype.toSum, Sum.toUnion, HasSubset.Subset.elem, hXY]\n\nvariable {T\u2081 T\u2082 S\u2081 S\u2082 : Set \u03b1} {\u03b2 : Type}\n  [\u2200 a, Decidable (a \u2208 T\u2081)]\n  [\u2200 a, Decidable (a \u2208 T\u2082)]\n  [\u2200 a, Decidable (a \u2208 S\u2081)]\n  [\u2200 a, Decidable (a \u2208 S\u2082)]\n\n/-- Convert a block matrix to a matrix over set unions. -/\ndef Matrix.toMatrixUnionUnion (C : Matrix (T\u2081.Elem \u2295 T\u2082.Elem) (S\u2081.Elem \u2295 S\u2082.Elem) \u03b2) :\n    Matrix (T\u2081 \u222a T\u2082).Elem (S\u2081 \u222a S\u2082).Elem \u03b2 :=\n  ((C \u2218 Subtype.toSum) \u00b7 \u2218 Subtype.toSum)\n\n/-- Convert a matrix over set unions to a block matrix. -/\ndef Matrix.toMatrixSumSum (C : Matrix (T\u2081 \u222a T\u2082).Elem (S\u2081 \u222a S\u2082).Elem \u03b2) :\n    Matrix (T\u2081.Elem \u2295 T\u2082.Elem) (S\u2081.Elem \u2295 S\u2082.Elem) \u03b2 :=\n  ((C \u2218 Sum.toUnion) \u00b7 \u2218 Sum.toUnion)\n\n/-- Converting a block matrix to a matrix over set unions and back to a block matrix gives the original matrix, assuming that\nboth said unions are disjoint. -/\nlemma toMatrixUnionUnion_toMatrixSumSum (hT : T\u2081 \u2ad7 T\u2082) (hS : S\u2081 \u2ad7 S\u2082) (C : Matrix (T\u2081 \u2295 T\u2082) (S\u2081 \u2295 S\u2082) \u03b2) :\n    C.toMatrixUnionUnion.toMatrixSumSum = C := by\n  ext\n  simp_all [Matrix.toMatrixUnionUnion, Matrix.toMatrixSumSum, toUnion_toSum]\n\n/-- Converting a matrix over set unions to a block matrix and back to a matrix over set unions gives the original matrix. -/\nlemma toMatrixSumSum_toMatrixUnionUnion (C : Matrix (T\u2081 \u222a T\u2082).Elem (S\u2081 \u222a S\u2082).Elem \u03b2) :\n    C.toMatrixSumSum.toMatrixUnionUnion = C := by\n  ext\n  simp_all [Matrix.toMatrixUnionUnion, Matrix.toMatrixSumSum, toSum_toUnion]\n\n/-- A totally unimodular block matrix stays totally unimodular after converting to a matrix over set unions. -/\nlemma Matrix.IsTotallyUnimodular.toMatrixUnionUnion [CommRing \u03b2] {C : Matrix (T\u2081 \u2295 T\u2082) (S\u2081 \u2295 S\u2082) \u03b2}\n    (hC : C.IsTotallyUnimodular) :\n    C.toMatrixUnionUnion.IsTotallyUnimodular := by\n  rw [Matrix.isTotallyUnimodular_iff] at hC \u22a2\n  intros\n  apply hC\n\nend utils\n\n\nsection TU_tautologies\n\n", "theoremStatement": "lemma Matrix.overZ2_isTotallyUnimodular {X Y : Type} (A : Matrix X Y Z2) : A.IsTotallyUnimodular ", "theoremName": "Matrix.overZ2_isTotallyUnimodular", "fileCreated": {"commit": "0e3e9cb42d2f02ece37a2344545c339b09a60217", "date": "2024-11-30"}, "theoremCreated": {"commit": "79a2e8a93901f81219352d778aab9fbd19093116", "date": "2025-01-09"}, "file": "Seymour/Seymour/Basic.lean", "module": "Seymour.Basic", "jsonFile": "Seymour.Basic.jsonl", "positionMetadata": {"lineInFile": 116, "tokenPositionInFile": 4434, "theoremPositionInFile": 19}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 51}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  intro k f g hf hg\n  if h0 : (A.submatrix f g).det = 0 then\n    use 0\n    rewrite [h0]\n    rfl\n  else\n    use 1\n    rewrite [Fin2_eq_1_of_ne_0 h0]\n    rfl", "proofType": "tactic", "proofLengthLines": 9, "proofLengthTokens": 161}}
{"srcContext": "import Mathlib.Data.Set.Card\nimport Mathlib.Data.Matroid.Dual\n\nimport Seymour.ForMathlib.SetTheory\nimport Seymour.Matroid.Notions.Circuit\nimport Seymour.Matroid.Notions.CircuitAxioms\nimport Seymour.Matroid.Notions.Connectivity\nimport Seymour.Matroid.Constructors.CircuitMatroid\n\n/-!\nThis file defines 2-sum of two (general) matroids `M\u2081` and `M\u2082`, denoted as `M\u2081 \u2295\u2082 M\u2082`.\n-/\n\nvariable {\u03b1 : Type}\n\n\nsection MainDefinitions\n\n/-- `M\u2081 \u2295\u2082 M\u2082` is defined if `M\u2081` and `M\u2082` satisfy the following assumptions -/\nstructure TwoSumAssumptions (M\u2081 M\u2082 : Matroid \u03b1) : Prop where\n  /-- `M\u2081` is finite -/\n  M\u2081fin : M\u2081.Finite\n  /-- `M\u2082` is finite -/\n  M\u2082fin : M\u2082.Finite\n  /-- `M\u2081` contains at least 2 elements -/\n  M\u2081card : M\u2081.E.encard \u2265 2\n  /-- `M\u2082` contains at least 2 elements -/\n  M\u2082card : M\u2082.E.encard \u2265 2\n  /-- `M\u2081` and `M\u2082` have exactly one element in common -/\n  interSingleton : (M\u2081.E \u2229 M\u2082.E).encard = 1\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2081` -/\n  M\u2081sep : \u00acM\u2081.Separator (M\u2081.E \u2229 M\u2082.E)\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2082` -/\n  M\u2082sep : \u00acM\u2082.Separator (M\u2081.E \u2229 M\u2082.E)\n\n-- question: can avoid this assumption? -- which assumption? the finiteness?\n\n/-- Ground set of `M\u2081 \u2295\u2082 M\u2082` -/\ndef twoSumGround (M\u2081 M\u2082 : Matroid \u03b1) : Set \u03b1 :=\n  (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)\n\n/-- Type 1 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2081` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType1 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 2 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2082` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType2 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2082.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 3 of circuits in `M\u2081 \u2295\u2082 M\u2082`:\n    sets `(C\u2081 \u222a C\u2082) \\ (M\u2081.E \u2229 M\u2082.E)` where `C\u2081` and `C\u2082` are circuits in `M\u2081` and `M\u2082`, respectively,\n    and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2081` and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2082` -/\ndef TwoSumCircuitType3 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit ((C \u2229 M\u2081.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 M\u2082.Circuit ((C \u2229 M\u2082.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 C \u2286 twoSumGround M\u2081 M\u2082\n\n/-- Circuit predicate of `M\u2081 \u2295\u2082 M\u2082`, which defines 2-sum as `CircuitMatroid` -/\ndef TwoSumCircuitPred (M\u2081 M\u2082 : Matroid \u03b1) : CircuitPredicate \u03b1 :=\n  fun C : Set \u03b1 =>\n    TwoSumCircuitType1 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType2 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType3 M\u2081 M\u2082 C\n\nend MainDefinitions\n\n\nsection PropertiesAssumptions\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1}\n\n/-- 2-sum assumptions are symmetric -/\nlemma TwoSumAssumptions.symm (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    TwoSumAssumptions M\u2082 M\u2081 :=\n  \u27e8\n    assumptions.M\u2082fin,\n    assumptions.M\u2081fin,\n    assumptions.M\u2082card,\n    assumptions.M\u2081card,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.interSingleton,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2082sep,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2081sep,\n  \u27e9\n\n/-- Intersection of ground sets is nonempty -/\nlemma TwoSumAssumptions.inter_nonempty (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (M\u2081.E \u2229 M\u2082.E).Nonempty :=\n  Set.one_le_encard_iff_nonempty.\u2192 assumptions.interSingleton.symm.le\n\n/-- Intersection of ground sets is a singleton set -/\nlemma TwoSumAssumptions.inter_singleton (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    \u2203 p : \u03b1, M\u2081.E \u2229 M\u2082.E = {p} :=\n  Set.encard_eq_one.\u2192 assumptions.interSingleton\n\nvariable {p : \u03b1}\n\n/-- Singleton element in intersection of ground sets in not a loop in `M\u2081` -/\nlemma TwoSumAssumptions.inter_singleton_not_loop_M\u2081 (assumptions : TwoSumAssumptions M\u2081 M\u2082)\n    (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2081.Loop p) :=\n  (hp \u25b8 assumptions.M\u2081sep <| Matroid.separator_loop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a coloop in `M\u2081` -/\nlemma TwoSumAssumptions.inter_singleton_not_coloop_M\u2081 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2081.Coloop p) :=\n  (hp \u25b8 assumptions.M\u2081sep <| Matroid.separator_coloop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a loop in `M\u2082` -/\nlemma TwoSumAssumptions.inter_singleton_not_loop_M\u2082 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2082.Loop p) :=\n  (hp \u25b8 assumptions.M\u2082sep <| Matroid.separator_loop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a coloop in `M\u2082` -/\nlemma TwoSumAssumptions.inter_singleton_not_coloop_M\u2082 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2082.Coloop p) :=\n  (hp \u25b8 assumptions.M\u2082sep <| Matroid.separator_coloop \u00b7)\n\nend PropertiesAssumptions\n\n\nsection PropertiesGroundSet\n\n/-- Ground set of 2-sum is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma twoSumGround_disjoint_inter (M\u2081 M\u2082 : Matroid \u03b1) :\n    twoSumGround M\u2081 M\u2082 \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  Set.disjoint_sdiff_left\n\n/-- Ground sets minus their intersection are disjoint sets -/\nlemma twoSum_disjoint_grounds_diff_inter (M\u2081 M\u2082 : Matroid \u03b1) :\n    M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) \u2ad7 M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E) := by\n  rw [Set.diff_self_inter, Set.diff_inter_self_eq_diff]\n  exact disjoint_sdiff_sdiff\n\nend PropertiesGroundSet\n\n\nsection PropertiesCircuitType1\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1} {C : Set \u03b1}\n\n/-- Circuit of type 1 is a circuit in `M\u2081` -/\nlemma TwoSumCircuitType1.circuit_M\u2081 (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : M\u2081.Circuit C :=\n  hC.left\n\n/-- Circuit of type 1 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType1.disjoint_inter (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of type 1 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma TwoSumCircuitType1.subset_union (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_left hC.circuit_M\u2081.subset_ground M\u2082.E\n\n/-- Circuit of type 1 lies in ground set of `M\u2081 \u2295\u2082 M\u2082` -/\nlemma TwoSumCircuitType1.subset_ground (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 twoSumGround M\u2081 M\u2082 :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 1 lies in `M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma TwoSumCircuitType1.subset_M\u2081_diff_inter (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2081.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 1 is disjoint with `M\u2082.E` -/\nlemma TwoSumCircuitType1.disjoint_M\u2082 (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2ad7 M\u2082.E := by\n  have hMM := twoSum_disjoint_grounds_diff_inter M\u2081 M\u2082\n  have hCM\u2082 := Set.disjoint_of_subset_left hC.subset_M\u2081_diff_inter hMM\n  have hCM\u2082 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2082, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_right] at hCM\u2082\n  exact hCM\u2082\n\nend PropertiesCircuitType1\n\n\nsection PropertiesCircuitType2\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1} {C : Set \u03b1}\n\n/-- Circuit of type 2 is a circuit in `M\u2082` -/\nlemma TwoSumCircuitType2.circuit_M\u2082 (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : M\u2082.Circuit C :=\n  hC.left\n\n/-- Circuit of type 2 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType2.disjoint_inter (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of type 2 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma TwoSumCircuitType2.subset_union (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_right hC.circuit_M\u2082.subset_ground M\u2081.E\n\n/-- Circuit of type 2 lies in ground set of `M\u2081 \u2295\u2082 M\u2082` -/\nlemma TwoSumCircuitType2.subset_ground (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2286 twoSumGround M\u2081 M\u2082 :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 2 lies in `M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma TwoSumCircuitType2.subset_M\u2082_diff_inter (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2286 M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E) :=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2082.subset_ground, hC.disjoint_inter\u27e9\n\n/-- Circuit of type 2 is disjoint with `M\u2081.E` -/\nlemma TwoSumCircuitType2.disjoint_M\u2081 (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E := by\n  have hMM := twoSum_disjoint_grounds_diff_inter M\u2081 M\u2082\n  have hCM\u2081 := (Set.disjoint_of_subset_right hC.subset_M\u2082_diff_inter hMM).symm\n  have hCM\u2081 := Set.disjoint_union_right.\u2190 \u27e8hCM\u2081, hC.disjoint_inter\u27e9\n  rw [Set.diff_union_of_subset Set.inter_subset_left] at hCM\u2081\n  exact hCM\u2081\n\nend PropertiesCircuitType2\n\n\nsection PropertiesCircuitType3\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1} {C : Set \u03b1}\n\n/-- Circuit of type 3 yields a circuit in `M\u2081` after intersecting it with `M\u2081.E` and adding `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType3.to_circuit_M\u2081 (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : M\u2081.Circuit ((C \u2229 M\u2081.E) \u222a (M\u2081.E \u2229 M\u2082.E)) :=\n  hC.left\n\n/-- Circuit of type 3 yields a circuit in `M\u2082` after intersecting it with `M\u2081.E` and adding `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType3.to_circuit_M\u2082 (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : M\u2082.Circuit ((C \u2229 M\u2082.E) \u222a (M\u2081.E \u2229 M\u2082.E)) :=\n  hC.right.left\n\n/-- Circuit of type 3 is subset of ground set of `M\u2081 \u2295\u2082 M\u2082` -/\ndef TwoSumCircuitType3.subset_ground (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2286 twoSumGround M\u2081 M\u2082 :=\n  hC.right.right\n\n/-- Circuit of type 3 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma TwoSumCircuitType3.subset_union (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \u222a M\u2082.E :=\n  sub_union_diff_sub_union hC.subset_ground\n\n/-- Circuit of type 3 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType3.disjoint_inter (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  Set.disjoint_of_subset_left hC.subset_ground (twoSumGround_disjoint_inter M\u2081 M\u2082)\n\n/-- Circuit of type 3 intersected with `M\u2081.E` is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType3.disjoint_inter_M\u2081_inter (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2229 M\u2081.E \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.disjoint_inter.inter_left M\u2081.E\n\n/-- Circuit of type 3 intersected with `M\u2082.E` is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType3.disjoint_inter_M\u2082_inter (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) : C \u2229 M\u2082.E \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.disjoint_inter.inter_left M\u2082.E\n\n/-- Circuit of type 3 has nonempty intersection with `M\u2081.E` -/\nlemma TwoSumCircuitType3.inter_M\u2081_nonempty (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (C \u2229 M\u2081.E).Nonempty := by\n  by_contra! hCM\u2081\n  have hM\u2081 := hC.to_circuit_M\u2081\n  have \u27e8p, hp\u27e9 := assumptions.inter_singleton\n  rw [hCM\u2081, Set.empty_union, hp, \u2190Matroid.loop_iff_circuit M\u2081] at hM\u2081\n  have hpM\u2081 := assumptions.inter_singleton_not_loop_M\u2081 hp\n  exact hpM\u2081 hM\u2081\n\n/-- Circuit of type 3 has nonempty intersection with `M\u2082.E` -/\nlemma TwoSumCircuitType3.inter_M\u2082_nonempty (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (C \u2229 M\u2082.E).Nonempty := by\n  by_contra! hCM\u2082empty\n  have hCM\u2082 := hC.to_circuit_M\u2082\n  have \u27e8p, hp\u27e9 := assumptions.inter_singleton\n  rw [hCM\u2082empty, Set.empty_union, hp, \u2190Matroid.loop_iff_circuit M\u2082] at hCM\u2082\n  exact assumptions.inter_singleton_not_loop_M\u2082 hp hCM\u2082\n\nend PropertiesCircuitType3\n\n\nsection PropertiesCircuitTypePairs1\n\n/-- Circuit of type 1 is not a strict subset of any circuit of type 1 -/\nlemma TwoSumCircuitType1.not_ssubset_circuit_type_1 {M\u2081 M\u2082 : Matroid \u03b1} {C C' : Set \u03b1}\n    (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) (hC' : TwoSumCircuitType1 M\u2081 M\u2082 C') :\n    \u00ac(C \u2282 C') :=\n  hC.circuit_M\u2081.not_ssubset_circuit hC'.circuit_M\u2081\n\n/-- Circuit of type 1 is disjoint with any circuit of type 2 -/\nlemma TwoSumCircuitType1.disjoint_circuit_type_2 {M\u2081 M\u2082 : Matroid \u03b1} {C\u2081 C\u2082 : Set \u03b1}\n    (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) :\n    C\u2081 \u2ad7 C\u2082 := by\n  have hC\u2081M\u2081 := hC\u2081.subset_M\u2081_diff_inter\n  have hC\u2082M\u2082 := hC\u2082.subset_M\u2082_diff_inter\n  have hMM := twoSum_disjoint_grounds_diff_inter M\u2081 M\u2082\n  exact Set.disjoint_of_subset hC\u2081M\u2081 hC\u2082M\u2082 hMM\n\n/-- Circuit of type 1 is not a strict subset of any circuit of type 2 -/\nlemma TwoSumCircuitType1.not_ssubset_circuit_type_2 {M\u2081 M\u2082 : Matroid \u03b1} {C\u2081 C\u2082 : Set \u03b1}\n    (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) :\n    \u00ac(C\u2081 \u2282 C\u2082) :=\n  disjoint_nonempty_not_ssubset (hC\u2081.disjoint_circuit_type_2 hC\u2082) hC\u2081.circuit_M\u2081.nonempty\n\n/-- Circuit of type 1 is not a strict subset of any circuit of type 3 -/\nlemma TwoSumCircuitType1.not_ssubset_circuit_type_3 {M\u2081 M\u2082 : Matroid \u03b1} {C\u2081 C\u2083 : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) (hC\u2083 : TwoSumCircuitType3 M\u2081 M\u2082 C\u2083) :\n    \u00ac(C\u2081 \u2282 C\u2083) :=\n  fun hCC =>\n    hC\u2081.circuit_M\u2081.not_ssubset_circuit hC\u2083.to_circuit_M\u2081\n      (Set.ssubset_of_ssubset_of_subset (ssubset_union_disjoint_nonempty hC\u2081.disjoint_inter assumptions.inter_nonempty)\n        (Set.union_subset_union_left (M\u2081.E \u2229 M\u2082.E) (Set.subset_inter hCC.left hC\u2081.circuit_M\u2081.subset_ground)))\n\n/-- Circuit of type 1 is not a strict subset of any other circuit -/\nlemma TwoSumCircuitType1.not_ssubset_circuit {M\u2081 M\u2082 : Matroid \u03b1} {C\u2081 C : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) (hC : TwoSumCircuitPred M\u2081 M\u2082 C) :\n    \u00ac(C\u2081 \u2282 C) := by\n  cases hC with\n  | inl hC => exact hC\u2081.not_ssubset_circuit_type_1 hC\n  | inr hC => cases hC with\n    | inl hC => exact hC\u2081.not_ssubset_circuit_type_2 hC\n    | inr hC => exact hC\u2081.not_ssubset_circuit_type_3 assumptions hC\n\nend PropertiesCircuitTypePairs1\n\n\nsection PropertiesCircuitTypePairs2\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1}\n\n/-- Circuits of type 2 are disjoint with circuits of type 1 -/\nlemma TwoSumCircuitType2.disjoint_circuitType1 {C\u2081 C\u2082 : Set \u03b1}\n    (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) :\n    C\u2082 \u2ad7 C\u2081 :=\n  (hC\u2081.disjoint_circuit_type_2 hC\u2082).symm\n\n/-- Circuit of type 2 is not a strict subset of any circuit of type 1 -/\nlemma TwoSumCircuitType2.not_ssubset_circuitType1 {C\u2081 C\u2082 : Set \u03b1}\n    (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) :\n    \u00ac(C\u2082 \u2282 C\u2081) :=\n  disjoint_nonempty_not_ssubset (hC\u2082.disjoint_circuitType1 hC\u2081) hC\u2082.circuit_M\u2082.nonempty\n\n/-- Circuit of type 2 is not a strict subset of any circuit of type 2 -/\nlemma TwoSumCircuitType2.not_ssubset_circuitType2 {C C' : Set \u03b1}\n    (hC : TwoSumCircuitType2 M\u2081 M\u2082 C) (hC' : TwoSumCircuitType2 M\u2081 M\u2082 C') :\n    \u00ac(C \u2282 C') :=\n  hC.circuit_M\u2082.not_ssubset_circuit hC'.circuit_M\u2082\n\n/-- Circuit of type 2 is not a strict subset of any circuit of type 3 -/\nlemma TwoSumAssumptions.circuitType2_not_ssubset_circuitType3 {C\u2082 C\u2083 : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) (hC\u2083 : TwoSumCircuitType3 M\u2081 M\u2082 C\u2083) :\n    \u00ac(C\u2082 \u2282 C\u2083) :=\n  fun hCC =>\n    hC\u2082.circuit_M\u2082.not_ssubset_circuit hC\u2083.to_circuit_M\u2082\n      (Set.ssubset_of_ssubset_of_subset (ssubset_union_disjoint_nonempty hC\u2082.disjoint_inter assumptions.inter_nonempty)\n        (Set.union_subset_union_left (M\u2081.E \u2229 M\u2082.E) (Set.subset_inter hCC.left hC\u2082.circuit_M\u2082.subset_ground)))\n\n/-- Circuit of type 2 is not a strict subset of any other circuit -/\nlemma TwoSumAssumptions.circuitType2_not_ssubset {C\u2082 C : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) (hC : TwoSumCircuitPred M\u2081 M\u2082 C) :\n    \u00ac(C\u2082 \u2282 C) := by\n  cases hC with\n  | inl hC => exact hC\u2082.not_ssubset_circuitType1 hC\n  | inr hC => cases hC with\n    | inl hC => exact hC\u2082.not_ssubset_circuitType2 hC\n    | inr hC => exact assumptions.circuitType2_not_ssubset_circuitType3 hC\u2082 hC\n\nend PropertiesCircuitTypePairs2\n\n\nsection PropertiesCircuitTypePairs3\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1}\n\n/-- Circuit of type 3 is not a strict subset of any circuit of type 1 -/\nlemma TwoSumAssumptions.circuitType3_not_ssubset_circuitType1 {C\u2081 C\u2083 : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2083 : TwoSumCircuitType3 M\u2081 M\u2082 C\u2083) (hC\u2081 : TwoSumCircuitType1 M\u2081 M\u2082 C\u2081) :\n    \u00ac(C\u2083 \u2282 C\u2081) :=\n  nonempty_inter_not_ssubset_empty_inter (hC\u2083.inter_M\u2082_nonempty assumptions) hC\u2081.disjoint_M\u2082.inter_eq\n\n/-- Circuit of type 3 is not a strict subset of any circuit of type 2 -/\nlemma TwoSumAssumptions.circuitType3_not_ssubset_circuitType2 {C\u2082 C\u2083 : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2083 : TwoSumCircuitType3 M\u2081 M\u2082 C\u2083) (hC\u2082 : TwoSumCircuitType2 M\u2081 M\u2082 C\u2082) :\n    \u00ac(C\u2083 \u2282 C\u2082) :=\n  nonempty_inter_not_ssubset_empty_inter (hC\u2083.inter_M\u2081_nonempty assumptions) hC\u2082.disjoint_M\u2081.inter_eq\n\n/-- Circuit of type 3 is not a strict subset of any circuit of type 3 -/\nlemma TwoSumCircuitType3.not_ssubset_circuitType3 {C C' : Set \u03b1}\n    (hC : TwoSumCircuitType3 M\u2081 M\u2082 C) (hC' : TwoSumCircuitType3 M\u2081 M\u2082 C') :\n    \u00ac(C \u2282 C') := by\n  intro \u27e8hCC', hnCC'\u27e9\n  have M\u2081_circ_nssub := Set.ssubset_def \u25b8 hC.to_circuit_M\u2081.not_ssubset_circuit hC'.to_circuit_M\u2081\n  have M\u2082_circ_nssub := Set.ssubset_def \u25b8 hC.to_circuit_M\u2082.not_ssubset_circuit hC'.to_circuit_M\u2082\n  push_neg at M\u2081_circ_nssub\n  push_neg at M\u2082_circ_nssub\n  have M\u2081_circ_sub := (union_subset_union_iff hC'.disjoint_inter_M\u2081_inter hC.disjoint_inter_M\u2081_inter).\u2192\n    (M\u2081_circ_nssub (Set.union_subset_union_left (M\u2081.E \u2229 M\u2082.E) (Set.inter_subset_inter_left M\u2081.E hCC')))\n  have M\u2082_circ_sub := (union_subset_union_iff hC'.disjoint_inter_M\u2082_inter hC.disjoint_inter_M\u2082_inter).\u2192\n    (M\u2082_circ_nssub (Set.union_subset_union_left (M\u2081.E \u2229 M\u2082.E) (Set.inter_subset_inter_left M\u2082.E hCC')))\n  exact hnCC' (hC.subset_union.parts_eq \u25b8 hC'.subset_union.parts_eq \u25b8 Set.union_subset_union M\u2081_circ_sub M\u2082_circ_sub)\n\n/-- Circuit of type 3 is not a strict subset of any other circuit -/\nlemma TwoSumAssumptions.circuitType3_not_ssubset_circuit {C\u2083 C : Set \u03b1}\n    (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hC\u2083 : TwoSumCircuitType3 M\u2081 M\u2082 C\u2083) (hC : TwoSumCircuitPred M\u2081 M\u2082 C) :\n    \u00ac(C\u2083 \u2282 C) := by\n  cases hC with\n  | inl hC => exact assumptions.circuitType3_not_ssubset_circuitType1 hC\u2083 hC\n  | inr hC => cases hC with\n    | inl hC => exact assumptions.circuitType3_not_ssubset_circuitType2 hC\u2083 hC\n    | inr hC => exact hC\u2083.not_ssubset_circuitType3 hC\n\nend PropertiesCircuitTypePairs3\n\n\nsection PropertiesCircuitPred\n\n/-- In definition of 2-sum, empty set is not a circuit -/\nlemma TwoSumAssumptions.twoSumCircuitPred_notCircuitEmpty {M\u2081 M\u2082 : Matroid \u03b1} (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (TwoSumCircuitPred M\u2081 M\u2082).NotCircuitEmpty := by\n  unfold CircuitPredicate.NotCircuitEmpty TwoSumCircuitPred\n  push_neg\n  refine \u27e8(\u00b7.circuit_M\u2081.nonempty.ne_empty rfl), (\u00b7.circuit_M\u2082.nonempty.ne_empty rfl), fun \u27e8hpM\u2081, hpM\u2082, hE\u27e9 => ?_\u27e9\n  have \u27e8p, hp\u27e9 := assumptions.inter_singleton\n  rw [Set.empty_inter, Set.empty_union, hp, \u2190Matroid.loop_iff_circuit M\u2081] at hpM\u2081\n  exact (hp \u25b8 assumptions.M\u2081sep) (Matroid.separator_loop hpM\u2081)\n\n/-- In definition of 2-sum, no circuit is a strict subset of another -/\nlemma TwoSumAssumptions.twoSumCircuitPred_circuitNotSsubset {M\u2081 M\u2082 : Matroid \u03b1} (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (TwoSumCircuitPred M\u2081 M\u2082).CircuitNotSsubset := by\n  intro C\u2081 C\u2082 hC\u2081 hC\u2082\n  cases hC\u2082 with\n  | inl hC\u2082 => exact hC\u2082.not_ssubset_circuit assumptions hC\u2081\n  | inr hC\u2082 => cases hC\u2082 with\n    | inl hC\u2082 => exact assumptions.circuitType2_not_ssubset hC\u2082 hC\u2081\n    | inr hC\u2082 => exact assumptions.circuitType3_not_ssubset_circuit hC\u2082 hC\u2081\n\n-- todo: remaining circuit axioms\n\n/-- todo: desc -/\nlemma TwoSumAssumptions.CircuitPred.subset_ground (M\u2081 M\u2082 : Matroid \u03b1) :\n    (TwoSumCircuitPred M\u2081 M\u2082).SubsetGround (twoSumGround M\u2081 M\u2082) := by\n  intro C hC\n  cases hC with\n  | inl hC => exact hC.subset_ground\n  | inr hC => cases hC with\n    | inl hC => exact hC.subset_ground\n    | inr hC => exact hC.subset_ground\n\nend PropertiesCircuitPred\n\n\nsection TwoSumDefinition\n\n/-- `CircuitMatroid` defining `M\u2081 \u2295\u2082 M\u2082` -/\ndef TwoSumAssumptions.build2sumCircuitMatroid {M\u2081 M\u2082 : Matroid \u03b1} (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    CircuitMatroid \u03b1 where\n  E := twoSumGround M\u2081 M\u2082\n  CircuitPred := TwoSumCircuitPred M\u2081 M\u2082\n  not_circuit_empty := assumptions.twoSumCircuitPred_notCircuitEmpty\n  circuit_not_ssubset := assumptions.twoSumCircuitPred_circuitNotSsubset\n  circuit_c3 := sorry -- todo: should simplify in finite case\n  circuit_maximal := sorry -- todo: should simplify in finite case\n  subset_ground := CircuitPred.subset_ground M\u2081 M\u2082\n\n@[simp]\nlemma TwoSumAssumptions.build2sumCircuitMatroid_circuitPred {M\u2081 M\u2082 : Matroid \u03b1} (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    assumptions.build2sumCircuitMatroid.CircuitPred = TwoSumCircuitPred M\u2081 M\u2082 :=\n  rfl\n\n/-- The main way of creating a 2-sum of any matroids. -/\ndef TwoSumAssumptions.build2sum {M\u2081 M\u2082 : Matroid \u03b1} (assumptions : TwoSumAssumptions M\u2081 M\u2082) : Matroid \u03b1 :=\n  assumptions.build2sumCircuitMatroid.toMatroid\n\n@[simp]\nlemma TwoSumAssumptions.build2sum_E {M\u2081 M\u2082 : Matroid \u03b1} (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    assumptions.build2sum.E = (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E) :=\n  rfl\n\n", "theoremStatement": "@[simp]\nlemma TwoSumAssumptions.build2sum_circuit {M\u2081 M\u2082 : Matroid \u03b1} (assumptions : TwoSumAssumptions M\u2081 M\u2082) (C : Set \u03b1) :\n    assumptions.build2sum.Circuit C \u2194 C \u2286 twoSumGround M\u2081 M\u2082 \u2227 TwoSumCircuitPred M\u2081 M\u2082 C ", "theoremName": "TwoSumAssumptions.build2sum_circuit", "fileCreated": {"commit": "d0eaaa305c96cd81ac061f505a81614db6856b21", "date": "2025-01-09"}, "theoremCreated": {"commit": "439c72996f29168161b974bc602629cac773728f", "date": "2025-01-08"}, "file": "Seymour/Seymour/Matroid/Operations/Sum2/Basic.lean", "module": "Seymour.Matroid.Operations.Sum2.Basic", "jsonFile": "Seymour.Matroid.Operations.Sum2.Basic.jsonl", "positionMetadata": {"lineInFile": 456, "tokenPositionInFile": 19948, "theoremPositionInFile": 55}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 5, "repositoryPremises": true, "numRepositoryPremises": 7, "numPremises": 13}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  apply CircuitMatroid.toMatroid_circuit_iff", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 50}}
{"srcContext": "import Mathlib.Data.Set.Card\nimport Mathlib.Data.Matroid.Dual\n\nimport Seymour.ForMathlib.SetTheory\nimport Seymour.Matroid.Notions.Circuit\nimport Seymour.Matroid.Notions.CircuitAxioms\nimport Seymour.Matroid.Notions.Connectivity\nimport Seymour.Matroid.Constructors.CircuitMatroid\n\n/-!\nThis file defines 2-sum of two (general) matroids `M\u2081` and `M\u2082`, denoted as `M\u2081 \u2295\u2082 M\u2082`.\n-/\n\nvariable {\u03b1 : Type}\n\n\nsection MainDefinitions\n\n/-- `M\u2081 \u2295\u2082 M\u2082` is defined if `M\u2081` and `M\u2082` satisfy the following assumptions -/\nstructure TwoSumAssumptions (M\u2081 M\u2082 : Matroid \u03b1) : Prop where\n  /-- `M\u2081` is finite -/\n  M\u2081fin : M\u2081.Finite\n  /-- `M\u2082` is finite -/\n  M\u2082fin : M\u2082.Finite\n  /-- `M\u2081` contains at least 2 elements -/\n  M\u2081card : M\u2081.E.encard \u2265 2\n  /-- `M\u2082` contains at least 2 elements -/\n  M\u2082card : M\u2082.E.encard \u2265 2\n  /-- `M\u2081` and `M\u2082` have exactly one element in common -/\n  interSingleton : (M\u2081.E \u2229 M\u2082.E).encard = 1\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2081` -/\n  M\u2081sep : \u00acM\u2081.Separator (M\u2081.E \u2229 M\u2082.E)\n  /-- the common element of `M\u2081` and `M\u2082` is not a separator in `M\u2082` -/\n  M\u2082sep : \u00acM\u2082.Separator (M\u2081.E \u2229 M\u2082.E)\n\n-- question: can avoid this assumption? -- which assumption? the finiteness?\n\n/-- Ground set of `M\u2081 \u2295\u2082 M\u2082` -/\ndef twoSumGround (M\u2081 M\u2082 : Matroid \u03b1) : Set \u03b1 :=\n  (M\u2081.E \u222a M\u2082.E) \\ (M\u2081.E \u2229 M\u2082.E)\n\n/-- Type 1 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2081` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType1 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 2 of circuits in `M\u2081 \u2295\u2082 M\u2082`: circuits of `M\u2082` that are disjoint with `M\u2081.E \u2229 M\u2082.E` -/\ndef TwoSumCircuitType2 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2082.Circuit C \u2227 C \u2ad7 M\u2081.E \u2229 M\u2082.E\n\n/-- Type 3 of circuits in `M\u2081 \u2295\u2082 M\u2082`:\n    sets `(C\u2081 \u222a C\u2082) \\ (M\u2081.E \u2229 M\u2082.E)` where `C\u2081` and `C\u2082` are circuits in `M\u2081` and `M\u2082`, respectively,\n    and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2081` and `M\u2081.E \u2229 M\u2082.E \u2286 C\u2082` -/\ndef TwoSumCircuitType3 (M\u2081 M\u2082 : Matroid \u03b1) (C : Set \u03b1) : Prop :=\n  M\u2081.Circuit ((C \u2229 M\u2081.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 M\u2082.Circuit ((C \u2229 M\u2082.E) \u222a (M\u2081.E \u2229 M\u2082.E)) \u2227 C \u2286 twoSumGround M\u2081 M\u2082\n\n/-- Circuit predicate of `M\u2081 \u2295\u2082 M\u2082`, which defines 2-sum as `CircuitMatroid` -/\ndef TwoSumCircuitPred (M\u2081 M\u2082 : Matroid \u03b1) : CircuitPredicate \u03b1 :=\n  fun C : Set \u03b1 =>\n    TwoSumCircuitType1 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType2 M\u2081 M\u2082 C \u2228\n    TwoSumCircuitType3 M\u2081 M\u2082 C\n\nend MainDefinitions\n\n\nsection PropertiesAssumptions\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1}\n\n/-- 2-sum assumptions are symmetric -/\nlemma TwoSumAssumptions.symm (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    TwoSumAssumptions M\u2082 M\u2081 :=\n  \u27e8\n    assumptions.M\u2082fin,\n    assumptions.M\u2081fin,\n    assumptions.M\u2082card,\n    assumptions.M\u2081card,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.interSingleton,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2082sep,\n    Set.inter_comm M\u2081.E M\u2082.E \u25b8 assumptions.M\u2081sep,\n  \u27e9\n\n/-- Intersection of ground sets is nonempty -/\nlemma TwoSumAssumptions.inter_nonempty (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    (M\u2081.E \u2229 M\u2082.E).Nonempty :=\n  Set.one_le_encard_iff_nonempty.\u2192 assumptions.interSingleton.symm.le\n\n/-- Intersection of ground sets is a singleton set -/\nlemma TwoSumAssumptions.inter_singleton (assumptions : TwoSumAssumptions M\u2081 M\u2082) :\n    \u2203 p : \u03b1, M\u2081.E \u2229 M\u2082.E = {p} :=\n  Set.encard_eq_one.\u2192 assumptions.interSingleton\n\nvariable {p : \u03b1}\n\n/-- Singleton element in intersection of ground sets in not a loop in `M\u2081` -/\nlemma TwoSumAssumptions.inter_singleton_not_loop_M\u2081 (assumptions : TwoSumAssumptions M\u2081 M\u2082)\n    (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2081.Loop p) :=\n  (hp \u25b8 assumptions.M\u2081sep <| Matroid.separator_loop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a coloop in `M\u2081` -/\nlemma TwoSumAssumptions.inter_singleton_not_coloop_M\u2081 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2081.Coloop p) :=\n  (hp \u25b8 assumptions.M\u2081sep <| Matroid.separator_coloop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a loop in `M\u2082` -/\nlemma TwoSumAssumptions.inter_singleton_not_loop_M\u2082 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2082.Loop p) :=\n  (hp \u25b8 assumptions.M\u2082sep <| Matroid.separator_loop \u00b7)\n\n/-- Singleton element in intersection of ground sets in not a coloop in `M\u2082` -/\nlemma TwoSumAssumptions.inter_singleton_not_coloop_M\u2082 (assumptions : TwoSumAssumptions M\u2081 M\u2082) (hp : M\u2081.E \u2229 M\u2082.E = {p}) :\n    \u00ac(M\u2082.Coloop p) :=\n  (hp \u25b8 assumptions.M\u2082sep <| Matroid.separator_coloop \u00b7)\n\nend PropertiesAssumptions\n\n\nsection PropertiesGroundSet\n\n/-- Ground set of 2-sum is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma twoSumGround_disjoint_inter (M\u2081 M\u2082 : Matroid \u03b1) :\n    twoSumGround M\u2081 M\u2082 \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  Set.disjoint_sdiff_left\n\n/-- Ground sets minus their intersection are disjoint sets -/\nlemma twoSum_disjoint_grounds_diff_inter (M\u2081 M\u2082 : Matroid \u03b1) :\n    M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) \u2ad7 M\u2082.E \\ (M\u2081.E \u2229 M\u2082.E) := by\n  rw [Set.diff_self_inter, Set.diff_inter_self_eq_diff]\n  exact disjoint_sdiff_sdiff\n\nend PropertiesGroundSet\n\n\nsection PropertiesCircuitType1\n\nvariable {M\u2081 M\u2082 : Matroid \u03b1} {C : Set \u03b1}\n\n/-- Circuit of type 1 is a circuit in `M\u2081` -/\nlemma TwoSumCircuitType1.circuit_M\u2081 (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : M\u2081.Circuit C :=\n  hC.left\n\n/-- Circuit of type 1 is disjoint with `M\u2081.E \u2229 M\u2082.E` -/\nlemma TwoSumCircuitType1.disjoint_inter (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2ad7 M\u2081.E \u2229 M\u2082.E :=\n  hC.right\n\n/-- Circuit of type 1 lies in `M\u2081.E \u222a M\u2082.E` -/\nlemma TwoSumCircuitType1.subset_union (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \u222a M\u2082.E :=\n  Set.subset_union_of_subset_left hC.circuit_M\u2081.subset_ground M\u2082.E\n\n/-- Circuit of type 1 lies in ground set of `M\u2081 \u2295\u2082 M\u2082` -/\nlemma TwoSumCircuitType1.subset_ground (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 twoSumGround M\u2081 M\u2082 :=\n  Set.subset_diff.\u2190 \u27e8hC.subset_union, hC.disjoint_inter\u27e9\n\n", "theoremStatement": "/-- Circuit of type 1 lies in `M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E)` -/\nlemma TwoSumCircuitType1.subset_M\u2081_diff_inter (hC : TwoSumCircuitType1 M\u2081 M\u2082 C) : C \u2286 M\u2081.E \\ (M\u2081.E \u2229 M\u2082.E) ", "theoremName": "TwoSumCircuitType1.subset_M\u2081_diff_inter", "fileCreated": {"commit": "d0eaaa305c96cd81ac061f505a81614db6856b21", "date": "2025-01-09"}, "theoremCreated": {"commit": "439c72996f29168161b974bc602629cac773728f", "date": "2025-01-08"}, "file": "Seymour/Seymour/Matroid/Operations/Sum2/Basic.lean", "module": "Seymour.Matroid.Operations.Sum2.Basic", "jsonFile": "Seymour.Matroid.Operations.Sum2.Basic.jsonl", "positionMetadata": {"lineInFile": 155, "tokenPositionInFile": 5725, "theoremPositionInFile": 18}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 4, "numPremises": 27}, "proofMetadata": {"hasProof": true, "proof": ":=\n  Set.subset_diff.\u2190 \u27e8hC.circuit_M\u2081.subset_ground, hC.disjoint_inter\u27e9", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 71}}
{"srcContext": "import Seymour.Matroid.Operations.MatrixSums.BinaryMatroids\n\n/-!\nThis file contains everything about 2-sum of binary matroids \u2014 the old version (in terms of explicit matrices).\n-/\n\nvariable {\u03b1 : Type}\n\n/-- `Matrix`-level 2-sum for matroids defined by their standard representation matrices; does not check legitimacy. -/\nabbrev Matrix_2sumComposition {\u03b2 : Type} [Semiring \u03b2] {X\u2081 Y\u2081 X\u2082 Y\u2082 : Set \u03b1}\n    (A\u2081 : Matrix X\u2081 Y\u2081 \u03b2) (x : Y\u2081 \u2192 \u03b2) (A\u2082 : Matrix X\u2082 Y\u2082 \u03b2) (y : X\u2082 \u2192 \u03b2) :\n    Matrix (X\u2081 \u2295 X\u2082) (Y\u2081 \u2295 Y\u2082) \u03b2 :=\n  Matrix.fromBlocks A\u2081 0 (fun i j => y i * x j) A\u2082\n\nvariable [DecidableEq \u03b1] {M\u2081 M\u2082 : StandardRepresentation \u03b1}\n\n/-- `StandardRepresentation`-level 2-sum of two matroids.\nThe second part checks legitimacy: the ground sets of `M\u2081` and `M\u2082` are disjoint except for the element `a \u2208 M\u2081.X \u2229 M\u2082.Y`,\nand the bottom-most row of `M\u2081` and the left-most column of `M\u2082` are each nonzero vectors. -/\ndef StandardRepresentation_2sum {a : \u03b1} (ha : M\u2081.X \u2229 M\u2082.Y = {a}) (hXY : M\u2082.X \u2ad7 M\u2081.Y) :\n    StandardRepresentation \u03b1 \u00d7 Prop :=\n  let A\u2081 : Matrix (M\u2081.X \\ {a}).Elem M\u2081.Y.Elem Z2 := M\u2081.B \u2218 Set.diff_subset.elem -- the top submatrix of `B\u2081`\n  let A\u2082 : Matrix M\u2082.X.Elem (M\u2082.Y \\ {a}).Elem Z2 := (M\u2082.B \u00b7 \u2218 Set.diff_subset.elem) -- the right submatrix of `B\u2082`\n  let x : M\u2081.Y.Elem \u2192 Z2 := M\u2081.B \u27e8a, Set.mem_of_mem_inter_left (by rw [ha]; rfl)\u27e9 -- the bottom row of `B\u2081`\n  let y : M\u2082.X.Elem \u2192 Z2 := (M\u2082.B \u00b7 \u27e8a, Set.mem_of_mem_inter_right (by rw [ha]; rfl)\u27e9) -- the left column of `B\u2082`\n  \u27e8\n    \u27e8\n      (M\u2081.X \\ {a}) \u222a M\u2082.X,\n      M\u2081.Y \u222a (M\u2082.Y \\ {a}),\n      inferInstance,\n      inferInstance,\n      by\n        rw [Set.disjoint_union_right, Set.disjoint_union_left, Set.disjoint_union_left]\n        exact \u27e8\u27e8M\u2081.hXY.disjoint_sdiff_left, hXY\u27e9, \u27e8disjoint_of_singleton_inter_both_wo ha, M\u2082.hXY.disjoint_sdiff_right\u27e9\u27e9,\n      (Matrix_2sumComposition A\u2081 x A\u2082 y).toMatrixUnionUnion\n    \u27e9,\n    (M\u2081.X \u2ad7 M\u2082.X \u2227 M\u2081.Y \u2ad7 M\u2082.Y) \u2227 (x \u2260 0 \u2227 y \u2260 0)\n  \u27e9\n\n/-- Binary matroid `M` is a result of 2-summing `M\u2081` and `M\u2082` in some way. -/\ndef StandardRepresentation.Is2sumOf (M : StandardRepresentation \u03b1) (M\u2081 M\u2082 : StandardRepresentation \u03b1) : Prop :=\n  \u2203 a : \u03b1, \u2203 ha : M\u2081.X \u2229 M\u2082.Y = {a}, \u2203 hXY : M\u2082.X \u2ad7 M\u2081.Y,\n    let M\u2080 := StandardRepresentation_2sum ha hXY\n    M.toMatroid = M\u2080.fst.toMatroid \u2227 M\u2080.snd\n\n\nvariable {M : StandardRepresentation \u03b1}\n\nlemma StandardRepresentation.Is2sumOf.disjoXX (hM : M.Is2sumOf M\u2081 M\u2082) :\n    M\u2081.X \u2ad7 M\u2082.X := by\n  obtain \u27e8a, -, -, -, \u27e8hXX, -\u27e9, -\u27e9 := hM\n  exact hXX\n\nlemma StandardRepresentation.Is2sumOf.disjoYY (hM : M.Is2sumOf M\u2081 M\u2082) :\n    M\u2081.Y \u2ad7 M\u2082.Y := by\n  obtain \u27e8a, -, -, -, \u27e8-, hYY\u27e9, -\u27e9 := hM\n  exact hYY\n\nlemma StandardRepresentation.Is2sumOf.interXY (hM : M.Is2sumOf M\u2081 M\u2082) :\n    \u2203 a : \u03b1, M\u2081.X \u2229 M\u2082.Y = {a} := by\n  obtain \u27e8a, ha, -\u27e9 := hM\n  exact \u27e8a, ha\u27e9\n\nlemma StandardRepresentation.Is2sumOf.disjoYX (hM : M.Is2sumOf M\u2081 M\u2082) :\n    M\u2081.Y \u2ad7 M\u2082.X := by\n  obtain \u27e8a, -, hXY, -\u27e9 := hM\n  exact hXY.symm\n\nlemma StandardRepresentation.Is2sumOf.indep (hM : M.Is2sumOf M\u2081 M\u2082) :\n    \u2203 a : \u03b1, \u2203 ha : M\u2081.X \u2229 M\u2082.Y = {a},\n      let A\u2081 : Matrix (M\u2081.X \\ {a}).Elem M\u2081.Y.Elem Z2 := M\u2081.B \u2218 Set.diff_subset.elem -- the top submatrix of `B\u2081`\n      let A\u2082 : Matrix M\u2082.X.Elem (M\u2082.Y \\ {a}).Elem Z2 := (M\u2082.B \u00b7 \u2218 Set.diff_subset.elem) -- the right submatrix of `B\u2082`\n      let x : M\u2081.Y.Elem \u2192 Z2 := M\u2081.B \u27e8a, Set.mem_of_mem_inter_left (by rewrite [ha]; rfl)\u27e9 -- the bottom row of `B\u2081`\n      let y : M\u2082.X.Elem \u2192 Z2 := (M\u2082.B \u00b7 \u27e8a, Set.mem_of_mem_inter_right (by rewrite [ha]; rfl)\u27e9) -- the left column of `B\u2082`\n      (Matrix_2sumComposition A\u2081 x A\u2082 y).toMatrixUnionUnion.IndepCols =\n      M.toMatroid.Indep := by\n  obtain \u27e8a, ha, _, hMM, -\u27e9 := hM\n  use a, ha\n  rewrite [hMM]\n  rfl\n\nlemma Matrix_2sumComposition_isTotallyUnimodular {X\u2081 Y\u2081 X\u2082 Y\u2082 : Set \u03b1} {A\u2081 : Matrix X\u2081 Y\u2081 \u211a} {A\u2082 : Matrix X\u2082 Y\u2082 \u211a}\n    (hA\u2081 : A\u2081.IsTotallyUnimodular) (hA\u2082 : A\u2082.IsTotallyUnimodular) (x : Y\u2081 \u2192 \u211a) (y : X\u2082 \u2192 \u211a) :\n    (Matrix_2sumComposition A\u2081 x A\u2082 y).IsTotallyUnimodular := by\n  sorry\n\n", "theoremStatement": "lemma StandardRepresentation_2sum_B {a : \u03b1} (ha : M\u2081.X \u2229 M\u2082.Y = {a}) (hXY : M\u2082.X \u2ad7 M\u2081.Y) :\n    \u2203 haX\u2081 : a \u2208 M\u2081.X, \u2203 haY\u2082 : a \u2208 M\u2082.Y,\n      (StandardRepresentation_2sum ha hXY).fst.B =\n      (Matrix_2sumComposition\n        (M\u2081.B \u2218 Set.diff_subset.elem)\n        (M\u2081.B \u27e8a, haX\u2081\u27e9)\n        (M\u2082.B \u00b7 \u2218 Set.diff_subset.elem)\n        (M\u2082.B \u00b7 \u27e8a, haY\u2082\u27e9)\n      ).toMatrixUnionUnion ", "theoremName": "StandardRepresentation_2sum_B", "fileCreated": {"commit": "614ecc7fe89749171933326a0f077e8d8a24cecb", "date": "2025-02-03"}, "theoremCreated": {"commit": "74722a3f54befb275eb7729e168db1478932de5e", "date": "2024-12-05"}, "file": "Seymour/Seymour/Matroid/Operations/MatrixSums/Sum2.lean", "module": "Seymour.Matroid.Operations.MatrixSums.Sum2", "jsonFile": "Seymour.Matroid.Operations.MatrixSums.Sum2.jsonl", "positionMetadata": {"lineInFile": 87, "tokenPositionInFile": 3925, "theoremPositionInFile": 9}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 11, "numPremises": 56}, "proofMetadata": {"hasProof": true, "proof": ":=\n  have haXY : a \u2208 M\u2081.X \u2229 M\u2082.Y := ha \u25b8 rfl\n  \u27e8Set.mem_of_mem_inter_left haXY, Set.mem_of_mem_inter_right haXY, rfl\u27e9", "proofType": "term", "proofLengthLines": 2, "proofLengthTokens": 117}}
