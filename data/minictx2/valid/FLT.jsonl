{"srcContext": "/-\nCopyright (c) 2024 Ya\u00ebl Dillies, David Loeffler. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Ya\u00ebl Dillies, David Loeffler\n-/\nimport Mathlib.MeasureTheory.Measure.Haar.Basic\nimport Mathlib.NumberTheory.Padics.ProperSpace\nimport FLT.Mathlib.NumberTheory.Padics.PadicIntegers\n\n/-!\n# Measurability and measures on the p-adics\n\nThis file endows `\u2124_[p]` and `\u211a_[p]` with their Borel sigma-algebra and their Haar measure that\nmakes `\u2124_[p]` (or the copy of `\u2124_[p]` inside `\u211a_[p]`) have norm `1`.\n-/\n\nopen MeasureTheory Measure TopologicalSpace Topology\n\nvariable {p : \u2115} [Fact p.Prime]\n\nnamespace Padic\n\ninstance instMeasurableSpace : MeasurableSpace \u211a_[p] := borel _\ninstance instBorelSpace : BorelSpace \u211a_[p] := \u27e8rfl\u27e9\n\n-- Should we more generally make a map from `CompactOpens` to `PositiveCompacts`?\nprivate def unitBall_positiveCompact : PositiveCompacts \u211a_[p] where\n  carrier := {y | \u2016y\u2016 \u2264 1}\n  isCompact' := by simpa only [Metric.closedBall, dist_zero_right] using\n    isCompact_closedBall (0 : \u211a_[p]) 1\n  interior_nonempty' := by\n    rw [IsOpen.interior_eq]\n    \u00b7 exact \u27e80, by simp\u27e9\n    \u00b7 simpa only [Metric.closedBall, dist_zero_right] using\n        IsUltrametricDist.isOpen_closedBall (0 : \u211a_[p]) one_ne_zero\n\nnoncomputable instance instMeasureSpace : MeasureSpace \u211a_[p] :=\n  \u27e8addHaarMeasure unitBall_positiveCompact\u27e9\n\ninstance instIsAddHaarMeasure : IsAddHaarMeasure (volume : Measure \u211a_[p]) :=\n  isAddHaarMeasure_addHaarMeasure _\n\n", "theoremStatement": "lemma volume_closedBall_one : volume {x : \u211a_[p] | \u2016x\u2016 \u2264 1} = 1 ", "theoremName": "Padic.volume_closedBall_one", "fileCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "theoremCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "file": "FLT/FLT/HaarMeasure/MeasurableSpacePadics.lean", "module": "FLT.HaarMeasure.MeasurableSpacePadics", "jsonFile": "FLT.HaarMeasure.MeasurableSpacePadics.jsonl", "positionMetadata": {"lineInFile": 43, "tokenPositionInFile": 1491, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 3, "numPremises": 42}, "proofMetadata": {"hasProof": true, "proof": ":= addHaarMeasure_self", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 22}}
{"srcContext": "import Mathlib.Algebra.CharZero.Infinite\nimport Mathlib.NumberTheory.Padics.PadicIntegers\nimport FLT.Mathlib.GroupTheory.Index\n\n/-!\n# TODO\n\n* Rename `Coe.ringHom` to `coeRingHom`\n* Protect `PadicInt.norm_mul`, `PadicInt.norm_units`, `PadicInt.norm_pow`\n-/\n\nopen Function Topology Subgroup\nopen scoped NNReal nonZeroDivisors Pointwise\n\nvariable {p : \u2115} [Fact p.Prime]\n\nnamespace PadicInt\nvariable {x : \u2124_[p]}\n\nattribute [simp] coe_eq_zero\n\n", "theoremStatement": "@[simp, norm_cast] lemma coe_coeRingHom : \u21d1(Coe.ringHom (p := p)) = (\u2191) ", "theoremName": "PadicInt.coe_coeRingHom", "fileCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "theoremCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "file": "FLT/FLT/Mathlib/NumberTheory/Padics/PadicIntegers.lean", "module": "FLT.Mathlib.NumberTheory.Padics.PadicIntegers", "jsonFile": "FLT.Mathlib.NumberTheory.Padics.PadicIntegers.jsonl", "positionMetadata": {"lineInFile": 22, "tokenPositionInFile": 439, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 28}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "/-\nCopyright (c) 2024 Andrew Yang, Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang, Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras\n-/\nimport Mathlib.MeasureTheory.Measure.Haar.Unique\n\nopen scoped NNReal Pointwise ENNReal\n\nnamespace MeasureTheory.Measure\n\nvariable {G A : Type*} [Group G] [AddCommGroup A] [DistribMulAction G A]\n  [MeasurableSpace A]\n  -- We only need `MeasurableConstSMul G A` but we don't have this class. So we erroneously must\n  -- assume `MeasurableSpace G` + `MeasurableSMul G A`\n  [MeasurableSpace G] [MeasurableSMul G A]\nvariable {\u03bc \u03bd : Measure A} {g : G}\n\nlemma domSMul_apply (\u03bc : Measure A) (g : G\u1d48\u1d50\u1d43) (s : Set A) :\n    (g \u2022 \u03bc) s = \u03bc ((DomMulAct.mk.symm g) \u2022 s) := by\n  refine ((MeasurableEquiv.smul ((DomMulAct.mk.symm g : G)\u207b\u00b9)).map_apply _).trans ?_\n  congr 1\n  exact Set.preimage_smul_inv (DomMulAct.mk.symm g) s\n\nlemma integral_domSMul {\u03b1} [NormedAddCommGroup \u03b1] [NormedSpace \u211d \u03b1] (g : G\u1d48\u1d50\u1d43) (f : A \u2192 \u03b1) :\n    \u222b x, f x \u2202g \u2022 \u03bc = \u222b x, f ((DomMulAct.mk.symm g)\u207b\u00b9 \u2022 x) \u2202\u03bc :=\n  integral_map_equiv (MeasurableEquiv.smul ((DomMulAct.mk.symm g : G)\u207b\u00b9)) f\n\nvariable [TopologicalSpace A] [BorelSpace A] [TopologicalAddGroup A] [LocallyCompactSpace A]\n  [ContinuousConstSMul G A] [\u03bc.IsAddHaarMeasure] [\u03bd.IsAddHaarMeasure]\n\ninstance : SMulCommClass \u211d\u22650 G\u1d48\u1d50\u1d43 (Measure A) where\n  smul_comm r g \u03bc := show r \u2022 \u03bc.map _ = (r \u2022 \u03bc).map _ by simp\n\ninstance : SMulCommClass G\u1d48\u1d50\u1d43 \u211d\u22650 (Measure A) := .symm ..\n\ninstance (g : G\u1d48\u1d50\u1d43) [Regular \u03bc] : Regular (g \u2022 \u03bc) :=\n  Regular.map (\u03bc := \u03bc) (Homeomorph.smul ((DomMulAct.mk.symm g : G)\u207b\u00b9))\n\ninstance (g : G\u1d48\u1d50\u1d43) : (g \u2022 \u03bc).IsAddHaarMeasure :=\n  (DistribMulAction.toAddEquiv _ (DomMulAct.mk.symm g\u207b\u00b9)).isAddHaarMeasure_map _\n    (continuous_const_smul _) (continuous_const_smul _)\n\nvariable (\u03bc \u03bd) in\nlemma addHaarScalarFactor_domSMul (g : G\u1d48\u1d50\u1d43) :\n    addHaarScalarFactor (g \u2022 \u03bc) (g \u2022 \u03bd) = addHaarScalarFactor \u03bc \u03bd := by\n  obtain \u27e8\u27e8f, f_cont\u27e9, f_comp, f_nonneg, f_zero\u27e9 :\n    \u2203 f : C(A, \u211d), HasCompactSupport f \u2227 0 \u2264 f \u2227 f 0 \u2260 0 := exists_continuous_nonneg_pos 0\n  have int_f_ne_zero : \u222b x, f x \u2202g \u2022 \u03bd \u2260 0 :=\n    (f_cont.integral_pos_of_hasCompactSupport_nonneg_nonzero f_comp f_nonneg f_zero).ne'\n  apply NNReal.coe_injective\n  rw [addHaarScalarFactor_eq_integral_div (g \u2022 \u03bc) (g \u2022 \u03bd) f_cont f_comp int_f_ne_zero,\n    integral_domSMul, integral_domSMul]\n  refine (addHaarScalarFactor_eq_integral_div _ _ (by fun_prop) ?_ ?_).symm\n  \u00b7 exact f_comp.comp_isClosedEmbedding (Homeomorph.smul _).isClosedEmbedding\n  \u00b7 rw [\u2190 integral_domSMul]\n    exact (f_cont.integral_pos_of_hasCompactSupport_nonneg_nonzero f_comp f_nonneg f_zero).ne'\n\nvariable (\u03bc) in\nlemma addHaarScalarFactor_smul_congr (g : G\u1d48\u1d50\u1d43) :\n    addHaarScalarFactor \u03bc (g \u2022 \u03bc) = addHaarScalarFactor \u03bd (g \u2022 \u03bd) := by\n  rw [addHaarScalarFactor_eq_mul _ (g \u2022 \u03bd), addHaarScalarFactor_domSMul,\n    mul_comm, \u2190 addHaarScalarFactor_eq_mul]\n\nvariable (\u03bc) in\n", "theoremStatement": "lemma addHaarScalarFactor_smul_congr' (g : G\u1d48\u1d50\u1d43) :\n    addHaarScalarFactor (g \u2022 \u03bc) \u03bc = addHaarScalarFactor (g \u2022 \u03bd) \u03bd ", "theoremName": "MeasureTheory.Measure.addHaarScalarFactor_smul_congr'", "fileCreated": {"commit": "0624e5a452d5645b8a3766b4169a48010d2a725f", "date": "2024-12-10"}, "theoremCreated": {"commit": "56eefd9c57e734021b0820034e4a6f1b66434952", "date": "2024-12-08"}, "file": "FLT/FLT/HaarMeasure/DomMulActMeasure.lean", "module": "FLT.HaarMeasure.DomMulActMeasure", "jsonFile": "FLT.HaarMeasure.DomMulActMeasure.jsonl", "positionMetadata": {"lineInFile": 66, "tokenPositionInFile": 2940, "theoremPositionInFile": 4}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 56}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [addHaarScalarFactor_eq_mul _ (g \u2022 \u03bd), addHaarScalarFactor_domSMul,\n    mul_comm, \u2190 addHaarScalarFactor_eq_mul]", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 122}}
{"srcContext": "/-\nCopyright (c) 2024 Andrew Yang, Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang, Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras\n-/\nimport FLT.HaarMeasure.DomMulActMeasure\n\n/-!\n# The distributive character of Haar measures\n\nGiven a group `G` acting on an measurable additive commutative group `A`, and an element `g : G`,\none can pull back the Haar measure `\u03bc` of `A` along the map `(g \u2022 \u00b7) : A \u2192 A` to get another Haar\nmeasure `\u03bc'` on `A`. By unicity of Haar measures, there exists some nonnegative real number `r` such\nthat `\u03bc' = r \u2022 \u03bc`. We can thus define a map `distribHaarChar : G \u2192 \u211d\u22650` sending `g` to its\nassociated real number `r`. Furthermore, this number doesn't depend on the Haar measure `\u03bc` we\nstarted with, and `distribHaarChar` is a group homomorphism.\n\n## See also\n\n[Zulip](https://leanprover.zulipchat.com/#narrow/channel/217875-Is-there-code-for-X.3F/topic/canonical.20norm.20coming.20from.20Haar.20measure/near/480050592)\n-/\n\nopen scoped NNReal Pointwise ENNReal\n\nnamespace MeasureTheory.Measure\n\nvariable {G A : Type*} [Group G] [AddCommGroup A] [DistribMulAction G A]\n  [MeasurableSpace A]\n  [MeasurableSpace G] -- not needed actually\n  [MeasurableSMul G A] -- only need `MeasurableConstSMul` but we don't have this class.\nvariable {\u03bc \u03bd : Measure A} {g : G}\n\nvariable [TopologicalSpace A] [BorelSpace A] [TopologicalAddGroup A] [LocallyCompactSpace A]\n  [ContinuousConstSMul G A] [\u03bc.IsAddHaarMeasure] [\u03bd.IsAddHaarMeasure]\n\nvariable (\u03bc A) in\n@[simps (config := .lemmasOnly)]\nnoncomputable def distribHaarChar : G \u2192* \u211d\u22650 where\n  toFun g := addHaarScalarFactor (DomMulAct.mk g \u2022 addHaar) (addHaar (G := A))\n  map_one' := by simp\n  map_mul' g g' := by\n    simp_rw [DomMulAct.mk_mul]\n    rw [addHaarScalarFactor_eq_mul _ (DomMulAct.mk g' \u2022 addHaar (G := A))]\n    congr 1\n    simp_rw [mul_smul]\n    rw [addHaarScalarFactor_domSMul]\n\nvariable (\u03bc) in\nlemma addHaarScalarFactor_smul_eq_distribHaarChar (g : G) :\n    addHaarScalarFactor (DomMulAct.mk g \u2022 \u03bc) \u03bc = distribHaarChar A g :=\n  addHaarScalarFactor_smul_congr' ..\n\nvariable (\u03bc) in\nlemma addHaarScalarFactor_smul_inv_eq_distribHaarChar (g : G) :\n    addHaarScalarFactor \u03bc ((DomMulAct.mk g)\u207b\u00b9 \u2022 \u03bc) = distribHaarChar A g := by\n  rw [\u2190 addHaarScalarFactor_domSMul _ _ (DomMulAct.mk g)]\n  simp_rw [\u2190 mul_smul, mul_inv_cancel, one_smul]\n  exact addHaarScalarFactor_smul_eq_distribHaarChar ..\n\nvariable (\u03bc) in\nlemma addHaarScalarFactor_smul_eq_distribHaarChar_inv (g : G) :\n    addHaarScalarFactor \u03bc (DomMulAct.mk g \u2022 \u03bc) = (distribHaarChar A g)\u207b\u00b9 := by\n  rw [\u2190 map_inv, \u2190 addHaarScalarFactor_smul_inv_eq_distribHaarChar \u03bc, DomMulAct.mk_inv, inv_inv]\n\nlemma distribHaarChar_pos : 0 < distribHaarChar A g :=\n  pos_iff_ne_zero.mpr ((Group.isUnit g).map (distribHaarChar A)).ne_zero\n\nvariable [Regular \u03bc] {s : Set A}\n\nvariable (\u03bc) in\n", "theoremStatement": "lemma distribHaarChar_mul (g : G) (s : Set A) : distribHaarChar A g * \u03bc s = \u03bc (g \u2022 s) ", "theoremName": "MeasureTheory.Measure.distribHaarChar_mul", "fileCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "theoremCreated": {"commit": "8786316e35a009e5d8fc0ffc56ad2ca5765dc8c7", "date": "2024-12-02"}, "file": "FLT/FLT/HaarMeasure/DistribHaarChar/Basic.lean", "module": "FLT.HaarMeasure.DistribHaarChar.Basic", "jsonFile": "FLT.HaarMeasure.DistribHaarChar.Basic.jsonl", "positionMetadata": {"lineInFile": 71, "tokenPositionInFile": 2884, "theoremPositionInFile": 4}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 5, "numPremises": 97}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  have : (DomMulAct.mk g \u2022 \u03bc) s = \u03bc (g \u2022 s) := by simp [domSMul_apply]\n  rw [eq_comm, \u2190 nnreal_smul_coe_apply, \u2190 addHaarScalarFactor_smul_eq_distribHaarChar \u03bc,\n    \u2190 this, \u2190 smul_apply, \u2190 isAddLeftInvariant_eq_smul_of_regular]", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 232}}
{"srcContext": "import Mathlib.NumberTheory.NumberField.Completion\nimport Mathlib.Topology.Algebra.Module.ModuleTopology\nimport FLT.Mathlib.Algebra.Algebra.Pi\nimport FLT.Mathlib.Algebra.Algebra.Bilinear\nimport FLT.Mathlib.Analysis.Normed.Ring.WithAbs\nimport FLT.Mathlib.Topology.Algebra.UniformRing\nimport FLT.NumberField.Embeddings\n\nopen scoped TensorProduct\n\n/-!\n# The completion of a number field at an infinite place\n-/\n\nnoncomputable section\n\nnamespace NumberField.InfinitePlace.Completion\n\nopen AbsoluteValue.Completion UniformSpace.Completion\n\nvariable {K L : Type*} [Field K] [Field L] [Algebra K L] {v : InfinitePlace K} {w : InfinitePlace L}\n\ndef comapSemialgHom (h : w.comap (algebraMap K L) = v) :\n    v.Completion \u2192\u209b\u2090[algebraMap (WithAbs v.1) (WithAbs w.1)] w.Completion :=\n  mapSemialgHom _ <| (WithAbs.uniformContinuous_algebraMap (v.comp_of_comap_eq _ h)).continuous\n\n", "theoremStatement": "theorem comapSemialgHom_cont (h : w.comap (algebraMap K L) = v) :\n    Continuous (comapSemialgHom h) ", "theoremName": "NumberField.InfinitePlace.Completion.comapSemialgHom_cont", "fileCreated": {"commit": "127241373eb7d4afd5ff86dc0e5082497c364f08", "date": "2025-02-05"}, "theoremCreated": {"commit": "127241373eb7d4afd5ff86dc0e5082497c364f08", "date": "2025-02-05"}, "file": "FLT/FLT/NumberField/Completion.lean", "module": "FLT.NumberField.Completion", "jsonFile": "FLT.NumberField.Completion.jsonl", "positionMetadata": {"lineInFile": 27, "tokenPositionInFile": 868, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 4, "numPremises": 49}, "proofMetadata": {"hasProof": true, "proof": ":= continuous_map", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 17}}
{"srcContext": "import Mathlib.GroupTheory.Index\n\n/-!\n# TODO\n\n* Rename `relindex` to `relIndex`\n* Rename `FiniteIndex.finiteIndex` to `FiniteIndex.index_ne_zero`\n-/\n\nopen Function\nopen scoped Pointwise\n\n-- This is cool notation. Should mathlib have it? And what should the `relindex` version be?\nscoped[GroupTheory] notation \"[\" G \":\" H \"]\" => @AddSubgroup.index G _ H\n\nnamespace Subgroup\nvariable {G G' : Type*} [Group G] [Group G'] {f : G \u2192* G'} {H K : Subgroup G}\n\nclass _root_.AddSubgroup.FiniteRelIndex {G : Type*} [AddGroup G] (H K : AddSubgroup G) : Prop where\n  protected relIndex_ne_zero : H.relindex K \u2260 0\n\n@[to_additive] class FiniteRelIndex (H K : Subgroup G) : Prop where\n  protected relIndex_ne_zero : H.relindex K \u2260 0\n\n", "theoremStatement": "@[to_additive]\nlemma relIndex_ne_zero [H.FiniteRelIndex K] : H.relindex K \u2260 0 ", "theoremName": "Subgroup.relIndex_ne_zero", "fileCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "theoremCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "file": "FLT/FLT/Mathlib/GroupTheory/Index.lean", "module": "FLT.Mathlib.GroupTheory.Index", "jsonFile": "FLT.Mathlib.GroupTheory.Index.jsonl", "positionMetadata": {"lineInFile": 25, "tokenPositionInFile": 718, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 9}, "proofMetadata": {"hasProof": true, "proof": ":= FiniteRelIndex.relIndex_ne_zero", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 34}}
{"srcContext": "import Mathlib.Algebra.CharZero.Infinite\nimport Mathlib.NumberTheory.Padics.PadicIntegers\nimport FLT.Mathlib.GroupTheory.Index\n\n/-!\n# TODO\n\n* Rename `Coe.ringHom` to `coeRingHom`\n* Protect `PadicInt.norm_mul`, `PadicInt.norm_units`, `PadicInt.norm_pow`\n-/\n\nopen Function Topology Subgroup\nopen scoped NNReal nonZeroDivisors Pointwise\n\nvariable {p : \u2115} [Fact p.Prime]\n\nnamespace PadicInt\nvariable {x : \u2124_[p]}\n\nattribute [simp] coe_eq_zero\n\n@[simp, norm_cast] lemma coe_coeRingHom : \u21d1(Coe.ringHom (p := p)) = (\u2191) := rfl\n\nlemma coe_injective : Injective ((\u2191) : \u2124_[p] \u2192 \u211a_[p]) := Subtype.val_injective\n\n@[simp] lemma coe_inj {x y : \u2124_[p]} : (x : \u211a_[p]) = (y : \u211a_[p]) \u2194 x = y := coe_injective.eq_iff\n\ninstance : Infinite \u2124_[p] := CharZero.infinite _\n\n@[simp]\nprotected lemma nnnorm_mul (x y : \u2124_[p]) : \u2016x * y\u2016\u208a = \u2016x\u2016\u208a * \u2016y\u2016\u208a := by simp [nnnorm, NNReal]\n\n@[simp]\nprotected lemma nnnorm_pow (x : \u2124_[p]) (n : \u2115) : \u2016x ^ n\u2016\u208a = \u2016x\u2016\u208a ^ n := by simp [nnnorm, NNReal]\n\n@[simp] lemma nnnorm_p : \u2016(p : \u2124_[p])\u2016\u208a = (p : \u211d\u22650)\u207b\u00b9 := by simp [nnnorm]; rfl\n\n@[simp] protected lemma nnnorm_units (u : \u2124_[p]\u02e3) : \u2016(u : \u2124_[p])\u2016\u208a = 1 := by simp [nnnorm, NNReal]\n\nlemma exists_unit_mul_p_pow_eq (hx : x \u2260 0) : \u2203 (u : \u2124_[p]\u02e3) (n : \u2115), (u : \u2124_[p]) * p ^ n = x :=\n  \u27e8_, _, (unitCoeff_spec hx).symm\u27e9\n\n", "theoremStatement": "lemma isOpenEmbedding_coe : IsOpenEmbedding ((\u2191) : \u2124_[p] \u2192 \u211a_[p]) ", "theoremName": "PadicInt.isOpenEmbedding_coe", "fileCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "theoremCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "file": "FLT/FLT/Mathlib/NumberTheory/Padics/PadicIntegers.lean", "module": "FLT.Mathlib.NumberTheory.Padics.PadicIntegers", "jsonFile": "FLT.Mathlib.NumberTheory.Padics.PadicIntegers.jsonl", "positionMetadata": {"lineInFile": 43, "tokenPositionInFile": 1268, "theoremPositionInFile": 8}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 63}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  refine (?_ : IsOpen {y : \u211a_[p] | \u2016y\u2016 \u2264 1}).isOpenEmbedding_subtypeVal\n  simpa only [Metric.closedBall, dist_eq_norm_sub, sub_zero] using\n    IsUltrametricDist.isOpen_closedBall (0 : \u211a_[p]) one_ne_zero", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 208}}
{"srcContext": "import Mathlib.RepresentationTheory.Basic\nimport FLT.Mathlib.LinearAlgebra.Span.Defs\n\nopen Pointwise\n\nuniverse u\n\nvariable {A : Type*} [CommRing A]\n\nvariable {G : Type*} [Group G]\n\nvariable {W : Type*} [AddCommMonoid W] [Module A W]\n\nvariable {\u03c1 : Representation A G W}\n\nvariable (\u03c1) in\nstructure Subrepresentation where\n  toSubmodule : Submodule A W\n  apply_mem_toSubmodule (g : G) \u2983v : W\u2984 : v \u2208 toSubmodule \u2192 \u03c1 g v \u2208 toSubmodule\n\nnamespace Subrepresentation\n\nlemma toSubmodule_injective : Function.Injective (toSubmodule : Subrepresentation \u03c1 \u2192 Submodule A W) := by\n  rintro \u27e8_,_\u27e9\n  congr!\n\ninstance : SetLike (Subrepresentation \u03c1) W where\n  coe \u03c1' := \u03c1'.toSubmodule\n  coe_injective' := SetLike.coe_injective.comp toSubmodule_injective\n\ndef toRepresentation (\u03c1' : Subrepresentation \u03c1): Representation A G \u03c1'.toSubmodule where\n  toFun g := (\u03c1 g).restrict (\u03c1'.apply_mem_toSubmodule g)\n  map_one' := by ext; simp\n  map_mul' x y := by ext; simp\n\ninstance : Max (Subrepresentation \u03c1) where\n  max \u03c1\u2081 \u03c1\u2082 := .mk (\u03c1\u2081.toSubmodule \u2294 \u03c1\u2082.toSubmodule) <| by\n      simp only [Submodule.forall_mem_sup, map_add]\n      intro g x\u2081 hx\u2081 x\u2082 hx\u2082\n      exact Submodule.mem_sup.mpr\n        \u27e8\u03c1 g x\u2081, \u03c1\u2081.apply_mem_toSubmodule g hx\u2081, \u03c1 g x\u2082, \u03c1\u2082.apply_mem_toSubmodule g hx\u2082, rfl\u27e9\n\ninstance : Min (Subrepresentation \u03c1) where\n  min \u03c1\u2081 \u03c1\u2082 := .mk (\u03c1\u2081.toSubmodule \u2293 \u03c1\u2082.toSubmodule) <| by\n      simp only [Submodule.mem_inf, and_imp]\n      rintro g x hx\u2081 hx\u2082\n      exact \u27e8\u03c1\u2081.apply_mem_toSubmodule g hx\u2081, \u03c1\u2082.apply_mem_toSubmodule g hx\u2082\u27e9\n\n\n", "theoremStatement": "@[simp, norm_cast]\nlemma coe_sup (\u03c1\u2081 \u03c1\u2082 : Subrepresentation \u03c1) : \u2191(\u03c1\u2081 \u2294 \u03c1\u2082) = (\u03c1\u2081 : Set W) + (\u03c1\u2082 : Set W) ", "theoremName": "Subrepresentation.coe_sup", "fileCreated": {"commit": "14bd4f65b4f45e7747da8e4c0d90d02a58dec086", "date": "2024-12-21"}, "theoremCreated": {"commit": "14bd4f65b4f45e7747da8e4c0d90d02a58dec086", "date": "2024-12-21"}, "file": "FLT/FLT/Deformations/RepresentationTheory/Subrepresentation.lean", "module": "FLT.Deformations.RepresentationTheory.Subrepresentation", "jsonFile": "FLT.Deformations.RepresentationTheory.Subrepresentation.jsonl", "positionMetadata": {"lineInFile": 50, "tokenPositionInFile": 1506, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 4, "numPremises": 24}, "proofMetadata": {"hasProof": true, "proof": ":=\n  Submodule.coe_sup \u03c1\u2081.toSubmodule \u03c1\u2082.toSubmodule", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 52}}
{"srcContext": "import Mathlib.Algebra.CharZero.Infinite\nimport Mathlib.NumberTheory.Padics.PadicIntegers\nimport FLT.Mathlib.GroupTheory.Index\n\n/-!\n# TODO\n\n* Rename `Coe.ringHom` to `coeRingHom`\n* Protect `PadicInt.norm_mul`, `PadicInt.norm_units`, `PadicInt.norm_pow`\n-/\n\nopen Function Topology Subgroup\nopen scoped NNReal nonZeroDivisors Pointwise\n\nvariable {p : \u2115} [Fact p.Prime]\n\nnamespace PadicInt\nvariable {x : \u2124_[p]}\n\nattribute [simp] coe_eq_zero\n\n@[simp, norm_cast] lemma coe_coeRingHom : \u21d1(Coe.ringHom (p := p)) = (\u2191) := rfl\n\nlemma coe_injective : Injective ((\u2191) : \u2124_[p] \u2192 \u211a_[p]) := Subtype.val_injective\n\n@[simp] lemma coe_inj {x y : \u2124_[p]} : (x : \u211a_[p]) = (y : \u211a_[p]) \u2194 x = y := coe_injective.eq_iff\n\ninstance : Infinite \u2124_[p] := CharZero.infinite _\n\n@[simp]\nprotected lemma nnnorm_mul (x y : \u2124_[p]) : \u2016x * y\u2016\u208a = \u2016x\u2016\u208a * \u2016y\u2016\u208a := by simp [nnnorm, NNReal]\n\n@[simp]\nprotected lemma nnnorm_pow (x : \u2124_[p]) (n : \u2115) : \u2016x ^ n\u2016\u208a = \u2016x\u2016\u208a ^ n := by simp [nnnorm, NNReal]\n\n@[simp] lemma nnnorm_p : \u2016(p : \u2124_[p])\u2016\u208a = (p : \u211d\u22650)\u207b\u00b9 := by simp [nnnorm]; rfl\n\n@[simp] protected lemma nnnorm_units (u : \u2124_[p]\u02e3) : \u2016(u : \u2124_[p])\u2016\u208a = 1 := by simp [nnnorm, NNReal]\n\nlemma exists_unit_mul_p_pow_eq (hx : x \u2260 0) : \u2203 (u : \u2124_[p]\u02e3) (n : \u2115), (u : \u2124_[p]) * p ^ n = x :=\n  \u27e8_, _, (unitCoeff_spec hx).symm\u27e9\n\nlemma isOpenEmbedding_coe : IsOpenEmbedding ((\u2191) : \u2124_[p] \u2192 \u211a_[p]) := by\n  refine (?_ : IsOpen {y : \u211a_[p] | \u2016y\u2016 \u2264 1}).isOpenEmbedding_subtypeVal\n  simpa only [Metric.closedBall, dist_eq_norm_sub, sub_zero] using\n    IsUltrametricDist.isOpen_closedBall (0 : \u211a_[p]) one_ne_zero\n\n@[simp] lemma image_coe_smul_set (x : \u2124_[p]) (s : Set \u2124_[p]) :\n    ((\u2191) '' (x \u2022 s) : Set \u211a_[p]) = x \u2022 (\u2191) '' s := Set.image_comm fun _ \u21a6 rfl\n\n-- Ya\u00ebl: Do we really want this as a coercion?\nnoncomputable instance : Coe \u2124_[p]\u02e3 \u211a_[p]\u02e3 where coe := Units.map Coe.ringHom.toMonoidHom\n\n/-- For a `\u2124_[p]`-submodule `s` of `\u211a_[p]`, `x \u2022 s` has index `\u2016x\u2016\u207b\u00b9` in `s`.\n\nNote that `s` is of the form `y\u2124_[p]` for some `y : \u211a_[p]`, but this is syntactically less\ngeneral. -/\nlemma smul_submodule_relindex (x : \u2124_[p]) (s : Submodule \u2124_[p] \u211a_[p]) :\n    (x \u2022 s.toAddSubgroup).relindex s.toAddSubgroup = \u2016x\u2016\u208a\u207b\u00b9 :=\n  -- https://github.com/ImperialCollegeLondon/FLT/issues/279\n  -- Note: You might need to prove `smul_submoduleSpan_finiteRelIndex_submoduleSpan` first\n  sorry\n\n/-- For a `\u2124_[p]`-submodule `s` of `\u211a_[p]`, `x \u2022 s` has finite index if `x \u2260 0`.\n\nNote that `s` is the form `y\u2124_[p]` for some `y : \u211a_[p]`, but this is syntactically less\ngeneral. -/\nlemma smul_submodule_finiteRelIndex (hx : x \u2260 0) (s : Submodule \u2124_[p] \u211a_[p]) :\n    (x \u2022 s.toAddSubgroup).FiniteRelIndex s.toAddSubgroup where\n  relIndex_ne_zero := by simpa [\u2190 Nat.cast_ne_zero (R := \u211d\u22650), smul_submodule_relindex]\n\n-- Ya\u00ebl: Do we really want this as a coercion?\nnoncomputable instance : Coe \u2124_[p]\u2070 \u211a_[p]\u02e3 where\n  coe x := .mk0 x.1 <| map_ne_zero_of_mem_nonZeroDivisors (M := \u2124_[p]) Coe.ringHom coe_injective x.2\n\n/-- Non-zero p-adic integers generate non-zero p-adic numbers as a group. -/\nlemma closure_nonZeroDivisors_padicInt :\n    Subgroup.closure (Set.range ((\u2191) : \u2124_[p]\u2070 \u2192 \u211a_[p]\u02e3)) = \u22a4 := by\n  set H := Subgroup.closure (Set.range ((\u2191) : \u2124_[p]\u2070 \u2192 \u211a_[p]\u02e3))\n  rw [eq_top_iff']\n  intro x\n  obtain \u27e8y, z, hz, hyzx\u27e9 := IsFractionRing.div_surjective (A := \u2124_[p]) x.val\n  have hy : y \u2208 \u2124_[p]\u2070 := by simp; rintro rfl; simp [eq_comm] at hyzx\n  convert div_mem (H := H) (subset_closure <| Set.mem_range_self \u27e8y, hy\u27e9)\n    (subset_closure <| Set.mem_range_self \u27e8z, hz\u27e9) using 1\n  ext\n  simpa using hyzx.symm\n\nend PadicInt\n\nnamespace Padic\n\n", "theoremStatement": "lemma submodule_one_eq_closedBall :\n    (1 : Submodule \u2124_[p] \u211a_[p]) = Metric.closedBall (0 : \u211a_[p]) 1 ", "theoremName": "Padic.submodule_one_eq_closedBall", "fileCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "theoremCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "file": "FLT/FLT/Mathlib/NumberTheory/Padics/PadicIntegers.lean", "module": "FLT.Mathlib.NumberTheory.Padics.PadicIntegers", "jsonFile": "FLT.Mathlib.NumberTheory.Padics.PadicIntegers.jsonl", "positionMetadata": {"lineInFile": 93, "tokenPositionInFile": 3534, "theoremPositionInFile": 12}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 95}, "proofMetadata": {"hasProof": true, "proof": ":= by ext x; simp; simp [PadicInt]", "proofType": "tactic", "proofLengthLines": 0, "proofLengthTokens": 34}}
{"srcContext": "import Mathlib.Algebra.Group.Subgroup.Ker\nimport Mathlib.Topology.Algebra.Monoid\n\nvariable {G H : Type*} [Group G] [Group H] [TopologicalSpace G] [TopologicalSpace H]\n  [ContinuousMul G]\n-- TODO: `ContinuousMulConst` would be enough but it doesn't exist, and `ContinuousConstSMul G\u1d50\u1d52\u1d56 G`\n-- should work but doesn't\n\nsection induced\n\nvariable {R : Type*} [\u03c4R : TopologicalSpace R]\nvariable {A : Type*} [SMul R A]\nvariable {S : Type*} [\u03c4S : TopologicalSpace S] {f : S \u2192 R} (hf : Continuous f)\nvariable {B : Type*} [SMul S B]\n\nopen Topology\n\n-- note: use convert not exact to ensure typeclass inference doesn't try to find topology on B\n@[to_additive]\ntheorem induced_continuous_smul [\u03c4A : TopologicalSpace A] [ContinuousSMul R A] (g : B \u2192\u2091[f] A)\n    (hf : Continuous f) : @ContinuousSMul S B _ _ (TopologicalSpace.induced g \u03c4A) := by\n  convert IsInducing.continuousSMul (IsInducing.induced g) hf (fun {c} {x} \u21a6 map_smul\u209b\u2097 g c x)\n\n", "theoremStatement": "@[to_additive]\ntheorem induced_continuous_mul [CommMonoid A] [\u03c4A : TopologicalSpace A] [ContinuousMul A]\n    [CommMonoid B] (h : B \u2192* A) :\n    @ContinuousMul B (TopologicalSpace.induced h \u03c4A) _ ", "theoremName": "induced_continuous_mul", "fileCreated": {"commit": "0624e5a452d5645b8a3766b4169a48010d2a725f", "date": "2024-12-10"}, "theoremCreated": {"commit": "0624e5a452d5645b8a3766b4169a48010d2a725f", "date": "2024-12-10"}, "file": "FLT/FLT/Mathlib/Topology/Algebra/Monoid.lean", "module": "FLT.Mathlib.Topology.Algebra.Monoid", "jsonFile": "FLT.Mathlib.Topology.Algebra.Monoid.jsonl", "positionMetadata": {"lineInFile": 24, "tokenPositionInFile": 928, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 16}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  convert (IsInducing.induced h).continuousMul h", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 54}}
{"srcContext": "import Mathlib.RepresentationTheory.Basic\nimport FLT.Mathlib.LinearAlgebra.Span.Defs\n\nopen Pointwise\n\nuniverse u\n\nvariable {A : Type*} [CommRing A]\n\nvariable {G : Type*} [Group G]\n\nvariable {W : Type*} [AddCommMonoid W] [Module A W]\n\nvariable {\u03c1 : Representation A G W}\n\nvariable (\u03c1) in\nstructure Subrepresentation where\n  toSubmodule : Submodule A W\n  apply_mem_toSubmodule (g : G) \u2983v : W\u2984 : v \u2208 toSubmodule \u2192 \u03c1 g v \u2208 toSubmodule\n\nnamespace Subrepresentation\n\n", "theoremStatement": "lemma toSubmodule_injective : Function.Injective (toSubmodule : Subrepresentation \u03c1 \u2192 Submodule A W) ", "theoremName": "Subrepresentation.toSubmodule_injective", "fileCreated": {"commit": "14bd4f65b4f45e7747da8e4c0d90d02a58dec086", "date": "2024-12-21"}, "theoremCreated": {"commit": "14bd4f65b4f45e7747da8e4c0d90d02a58dec086", "date": "2024-12-21"}, "file": "FLT/FLT/Deformations/RepresentationTheory/Subrepresentation.lean", "module": "FLT.Deformations.RepresentationTheory.Subrepresentation", "jsonFile": "FLT.Deformations.RepresentationTheory.Subrepresentation.jsonl", "positionMetadata": {"lineInFile": 23, "tokenPositionInFile": 461, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 4, "numPremises": 40}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rintro \u27e8_,_\u27e9\n  congr!", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 29}}
{"srcContext": "import Mathlib.RepresentationTheory.Basic\nimport FLT.Mathlib.LinearAlgebra.Span.Defs\n\nopen Pointwise\n\nuniverse u\n\nvariable {A : Type*} [CommRing A]\n\nvariable {G : Type*} [Group G]\n\nvariable {W : Type*} [AddCommMonoid W] [Module A W]\n\nvariable {\u03c1 : Representation A G W}\n\nvariable (\u03c1) in\nstructure Subrepresentation where\n  toSubmodule : Submodule A W\n  apply_mem_toSubmodule (g : G) \u2983v : W\u2984 : v \u2208 toSubmodule \u2192 \u03c1 g v \u2208 toSubmodule\n\nnamespace Subrepresentation\n\nlemma toSubmodule_injective : Function.Injective (toSubmodule : Subrepresentation \u03c1 \u2192 Submodule A W) := by\n  rintro \u27e8_,_\u27e9\n  congr!\n\ninstance : SetLike (Subrepresentation \u03c1) W where\n  coe \u03c1' := \u03c1'.toSubmodule\n  coe_injective' := SetLike.coe_injective.comp toSubmodule_injective\n\ndef toRepresentation (\u03c1' : Subrepresentation \u03c1): Representation A G \u03c1'.toSubmodule where\n  toFun g := (\u03c1 g).restrict (\u03c1'.apply_mem_toSubmodule g)\n  map_one' := by ext; simp\n  map_mul' x y := by ext; simp\n\ninstance : Max (Subrepresentation \u03c1) where\n  max \u03c1\u2081 \u03c1\u2082 := .mk (\u03c1\u2081.toSubmodule \u2294 \u03c1\u2082.toSubmodule) <| by\n      simp only [Submodule.forall_mem_sup, map_add]\n      intro g x\u2081 hx\u2081 x\u2082 hx\u2082\n      exact Submodule.mem_sup.mpr\n        \u27e8\u03c1 g x\u2081, \u03c1\u2081.apply_mem_toSubmodule g hx\u2081, \u03c1 g x\u2082, \u03c1\u2082.apply_mem_toSubmodule g hx\u2082, rfl\u27e9\n\ninstance : Min (Subrepresentation \u03c1) where\n  min \u03c1\u2081 \u03c1\u2082 := .mk (\u03c1\u2081.toSubmodule \u2293 \u03c1\u2082.toSubmodule) <| by\n      simp only [Submodule.mem_inf, and_imp]\n      rintro g x hx\u2081 hx\u2082\n      exact \u27e8\u03c1\u2081.apply_mem_toSubmodule g hx\u2081, \u03c1\u2082.apply_mem_toSubmodule g hx\u2082\u27e9\n\n\n@[simp, norm_cast]\nlemma coe_sup (\u03c1\u2081 \u03c1\u2082 : Subrepresentation \u03c1) : \u2191(\u03c1\u2081 \u2294 \u03c1\u2082) = (\u03c1\u2081 : Set W) + (\u03c1\u2082 : Set W) :=\n  Submodule.coe_sup \u03c1\u2081.toSubmodule \u03c1\u2082.toSubmodule\n\n", "theoremStatement": "@[simp, norm_cast]\nlemma coe_inf (\u03c1\u2081 \u03c1\u2082 : Subrepresentation \u03c1) : \u2191(\u03c1\u2081 \u2293 \u03c1\u2082) = (\u03c1\u2081 \u2229 \u03c1\u2082 : Set W) ", "theoremName": "Subrepresentation.coe_inf", "fileCreated": {"commit": "14bd4f65b4f45e7747da8e4c0d90d02a58dec086", "date": "2024-12-21"}, "theoremCreated": {"commit": "14bd4f65b4f45e7747da8e4c0d90d02a58dec086", "date": "2024-12-21"}, "file": "FLT/FLT/Deformations/RepresentationTheory/Subrepresentation.lean", "module": "FLT.Deformations.RepresentationTheory.Subrepresentation", "jsonFile": "FLT.Deformations.RepresentationTheory.Subrepresentation.jsonl", "positionMetadata": {"lineInFile": 54, "tokenPositionInFile": 1666, "theoremPositionInFile": 2}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 3, "numPremises": 19}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "/-\nCopyright (c) 2024 Andrew Yang, Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang, Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras\n-/\nimport FLT.HaarMeasure.DomMulActMeasure\n\n/-!\n# The distributive character of Haar measures\n\nGiven a group `G` acting on an measurable additive commutative group `A`, and an element `g : G`,\none can pull back the Haar measure `\u03bc` of `A` along the map `(g \u2022 \u00b7) : A \u2192 A` to get another Haar\nmeasure `\u03bc'` on `A`. By unicity of Haar measures, there exists some nonnegative real number `r` such\nthat `\u03bc' = r \u2022 \u03bc`. We can thus define a map `distribHaarChar : G \u2192 \u211d\u22650` sending `g` to its\nassociated real number `r`. Furthermore, this number doesn't depend on the Haar measure `\u03bc` we\nstarted with, and `distribHaarChar` is a group homomorphism.\n\n## See also\n\n[Zulip](https://leanprover.zulipchat.com/#narrow/channel/217875-Is-there-code-for-X.3F/topic/canonical.20norm.20coming.20from.20Haar.20measure/near/480050592)\n-/\n\nopen scoped NNReal Pointwise ENNReal\n\nnamespace MeasureTheory.Measure\n\nvariable {G A : Type*} [Group G] [AddCommGroup A] [DistribMulAction G A]\n  [MeasurableSpace A]\n  [MeasurableSpace G] -- not needed actually\n  [MeasurableSMul G A] -- only need `MeasurableConstSMul` but we don't have this class.\nvariable {\u03bc \u03bd : Measure A} {g : G}\n\nvariable [TopologicalSpace A] [BorelSpace A] [TopologicalAddGroup A] [LocallyCompactSpace A]\n  [ContinuousConstSMul G A] [\u03bc.IsAddHaarMeasure] [\u03bd.IsAddHaarMeasure]\n\nvariable (\u03bc A) in\n@[simps (config := .lemmasOnly)]\nnoncomputable def distribHaarChar : G \u2192* \u211d\u22650 where\n  toFun g := addHaarScalarFactor (DomMulAct.mk g \u2022 addHaar) (addHaar (G := A))\n  map_one' := by simp\n  map_mul' g g' := by\n    simp_rw [DomMulAct.mk_mul]\n    rw [addHaarScalarFactor_eq_mul _ (DomMulAct.mk g' \u2022 addHaar (G := A))]\n    congr 1\n    simp_rw [mul_smul]\n    rw [addHaarScalarFactor_domSMul]\n\nvariable (\u03bc) in\nlemma addHaarScalarFactor_smul_eq_distribHaarChar (g : G) :\n    addHaarScalarFactor (DomMulAct.mk g \u2022 \u03bc) \u03bc = distribHaarChar A g :=\n  addHaarScalarFactor_smul_congr' ..\n\nvariable (\u03bc) in\nlemma addHaarScalarFactor_smul_inv_eq_distribHaarChar (g : G) :\n    addHaarScalarFactor \u03bc ((DomMulAct.mk g)\u207b\u00b9 \u2022 \u03bc) = distribHaarChar A g := by\n  rw [\u2190 addHaarScalarFactor_domSMul _ _ (DomMulAct.mk g)]\n  simp_rw [\u2190 mul_smul, mul_inv_cancel, one_smul]\n  exact addHaarScalarFactor_smul_eq_distribHaarChar ..\n\nvariable (\u03bc) in\n", "theoremStatement": "lemma addHaarScalarFactor_smul_eq_distribHaarChar_inv (g : G) :\n    addHaarScalarFactor \u03bc (DomMulAct.mk g \u2022 \u03bc) = (distribHaarChar A g)\u207b\u00b9 ", "theoremName": "MeasureTheory.Measure.addHaarScalarFactor_smul_eq_distribHaarChar_inv", "fileCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "theoremCreated": {"commit": "8786316e35a009e5d8fc0ffc56ad2ca5765dc8c7", "date": "2024-12-02"}, "file": "FLT/FLT/HaarMeasure/DistribHaarChar/Basic.lean", "module": "FLT.HaarMeasure.DistribHaarChar.Basic", "jsonFile": "FLT.HaarMeasure.DistribHaarChar.Basic.jsonl", "positionMetadata": {"lineInFile": 61, "tokenPositionInFile": 2464, "theoremPositionInFile": 2}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 3, "numPremises": 75}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [\u2190 map_inv, \u2190 addHaarScalarFactor_smul_inv_eq_distribHaarChar \u03bc, DomMulAct.mk_inv, inv_inv]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 102}}
{"srcContext": "import Mathlib.LinearAlgebra.Span.Defs\n\nopen Pointwise\n\nvariable {R : Type*} [Semiring R]\n\nvariable {M : Type*} [AddCommMonoid M] [Module R M]\n\nvariable {p p' : Submodule R M}\n\nvariable {P : M \u2192 Prop}\n\nnamespace Submodule\n\n", "theoremStatement": "@[simp high]\nlemma forall_mem_sup : (\u2200 x \u2208 p \u2294 p', P x) \u2194 (\u2200 x\u2081 \u2208 p, \u2200 x\u2082 \u2208 p', P (x\u2081 + x\u2082)) ", "theoremName": "Submodule.forall_mem_sup", "fileCreated": {"commit": "14bd4f65b4f45e7747da8e4c0d90d02a58dec086", "date": "2024-12-21"}, "theoremCreated": {"commit": "14bd4f65b4f45e7747da8e4c0d90d02a58dec086", "date": "2024-12-21"}, "file": "FLT/FLT/Mathlib/LinearAlgebra/Span/Defs.lean", "module": "FLT.Mathlib.LinearAlgebra.Span.Defs", "jsonFile": "FLT.Mathlib.LinearAlgebra.Span.Defs.jsonl", "positionMetadata": {"lineInFile": 15, "tokenPositionInFile": 223, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 38}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp [mem_sup]\n  aesop", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 30}}
{"srcContext": "import Mathlib.NumberTheory.NumberField.Embeddings\n\n/-!\n# Embeddings of number fields\n-/\n\nnamespace NumberField.InfinitePlace\n\nvariable {K : Type*} (L : Type*) [Field K] [Field L]\n\n/--\nIf `L / K` are fields and `v` is an infinite place of `K`, then we say an infinite place `w`\nof `L` _extends_ `v` if `w` can be constructed from a complex embedding `L \u2192+* \u2102` whose\nrestriction to `K` is an associated complex embedding `K \u2192+* \u2102` of `v`.\n-/\nabbrev ExtensionPlace [Algebra K L] (v : InfinitePlace K) :=\n  { w : InfinitePlace L // w.comap (algebraMap K L) = v }\n\nvariable {L}\n\n", "theoremStatement": "@[simp]\ntheorem comap_apply (w : InfinitePlace L) (f : K \u2192+* L) (x : K) :\n    w.comap f x = w (f x) ", "theoremName": "NumberField.InfinitePlace.comap_apply", "fileCreated": {"commit": "127241373eb7d4afd5ff86dc0e5082497c364f08", "date": "2025-02-05"}, "theoremCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "file": "FLT/FLT/NumberField/Embeddings.lean", "module": "FLT.NumberField.Embeddings", "jsonFile": "FLT.NumberField.Embeddings.jsonl", "positionMetadata": {"lineInFile": 21, "tokenPositionInFile": 575, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 14}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "/-\nCopyright (c) 2024 Andrew Yang, Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang, Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras\n-/\nimport FLT.HaarMeasure.DomMulActMeasure\n\n/-!\n# The distributive character of Haar measures\n\nGiven a group `G` acting on an measurable additive commutative group `A`, and an element `g : G`,\none can pull back the Haar measure `\u03bc` of `A` along the map `(g \u2022 \u00b7) : A \u2192 A` to get another Haar\nmeasure `\u03bc'` on `A`. By unicity of Haar measures, there exists some nonnegative real number `r` such\nthat `\u03bc' = r \u2022 \u03bc`. We can thus define a map `distribHaarChar : G \u2192 \u211d\u22650` sending `g` to its\nassociated real number `r`. Furthermore, this number doesn't depend on the Haar measure `\u03bc` we\nstarted with, and `distribHaarChar` is a group homomorphism.\n\n## See also\n\n[Zulip](https://leanprover.zulipchat.com/#narrow/channel/217875-Is-there-code-for-X.3F/topic/canonical.20norm.20coming.20from.20Haar.20measure/near/480050592)\n-/\n\nopen scoped NNReal Pointwise ENNReal\n\nnamespace MeasureTheory.Measure\n\nvariable {G A : Type*} [Group G] [AddCommGroup A] [DistribMulAction G A]\n  [MeasurableSpace A]\n  [MeasurableSpace G] -- not needed actually\n  [MeasurableSMul G A] -- only need `MeasurableConstSMul` but we don't have this class.\nvariable {\u03bc \u03bd : Measure A} {g : G}\n\nvariable [TopologicalSpace A] [BorelSpace A] [TopologicalAddGroup A] [LocallyCompactSpace A]\n  [ContinuousConstSMul G A] [\u03bc.IsAddHaarMeasure] [\u03bd.IsAddHaarMeasure]\n\nvariable (\u03bc A) in\n@[simps (config := .lemmasOnly)]\nnoncomputable def distribHaarChar : G \u2192* \u211d\u22650 where\n  toFun g := addHaarScalarFactor (DomMulAct.mk g \u2022 addHaar) (addHaar (G := A))\n  map_one' := by simp\n  map_mul' g g' := by\n    simp_rw [DomMulAct.mk_mul]\n    rw [addHaarScalarFactor_eq_mul _ (DomMulAct.mk g' \u2022 addHaar (G := A))]\n    congr 1\n    simp_rw [mul_smul]\n    rw [addHaarScalarFactor_domSMul]\n\nvariable (\u03bc) in\nlemma addHaarScalarFactor_smul_eq_distribHaarChar (g : G) :\n    addHaarScalarFactor (DomMulAct.mk g \u2022 \u03bc) \u03bc = distribHaarChar A g :=\n  addHaarScalarFactor_smul_congr' ..\n\nvariable (\u03bc) in\nlemma addHaarScalarFactor_smul_inv_eq_distribHaarChar (g : G) :\n    addHaarScalarFactor \u03bc ((DomMulAct.mk g)\u207b\u00b9 \u2022 \u03bc) = distribHaarChar A g := by\n  rw [\u2190 addHaarScalarFactor_domSMul _ _ (DomMulAct.mk g)]\n  simp_rw [\u2190 mul_smul, mul_inv_cancel, one_smul]\n  exact addHaarScalarFactor_smul_eq_distribHaarChar ..\n\nvariable (\u03bc) in\nlemma addHaarScalarFactor_smul_eq_distribHaarChar_inv (g : G) :\n    addHaarScalarFactor \u03bc (DomMulAct.mk g \u2022 \u03bc) = (distribHaarChar A g)\u207b\u00b9 := by\n  rw [\u2190 map_inv, \u2190 addHaarScalarFactor_smul_inv_eq_distribHaarChar \u03bc, DomMulAct.mk_inv, inv_inv]\n\nlemma distribHaarChar_pos : 0 < distribHaarChar A g :=\n  pos_iff_ne_zero.mpr ((Group.isUnit g).map (distribHaarChar A)).ne_zero\n\nvariable [Regular \u03bc] {s : Set A}\n\nvariable (\u03bc) in\nlemma distribHaarChar_mul (g : G) (s : Set A) : distribHaarChar A g * \u03bc s = \u03bc (g \u2022 s) := by\n  have : (DomMulAct.mk g \u2022 \u03bc) s = \u03bc (g \u2022 s) := by simp [domSMul_apply]\n  rw [eq_comm, \u2190 nnreal_smul_coe_apply, \u2190 addHaarScalarFactor_smul_eq_distribHaarChar \u03bc,\n    \u2190 this, \u2190 smul_apply, \u2190 isAddLeftInvariant_eq_smul_of_regular]\n\n", "theoremStatement": "lemma distribHaarChar_eq_div (hs\u2080 : \u03bc s \u2260 0) (hs : \u03bc s \u2260 \u221e) (g : G) :\n    distribHaarChar A g = \u03bc (g \u2022 s) / \u03bc s ", "theoremName": "MeasureTheory.Measure.distribHaarChar_eq_div", "fileCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "theoremCreated": {"commit": "8786316e35a009e5d8fc0ffc56ad2ca5765dc8c7", "date": "2024-12-02"}, "file": "FLT/FLT/HaarMeasure/DistribHaarChar/Basic.lean", "module": "FLT.HaarMeasure.DistribHaarChar.Basic", "jsonFile": "FLT.HaarMeasure.DistribHaarChar.Basic.jsonl", "positionMetadata": {"lineInFile": 76, "tokenPositionInFile": 3204, "theoremPositionInFile": 5}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 73}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [\u2190 distribHaarChar_mul, ENNReal.mul_div_cancel_right] <;> simp [*]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 77}}
{"srcContext": "/-\nCopyright (c) 2024 Andrew Yang, Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang, Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras\n-/\nimport FLT.HaarMeasure.DomMulActMeasure\n\n/-!\n# The distributive character of Haar measures\n\nGiven a group `G` acting on an measurable additive commutative group `A`, and an element `g : G`,\none can pull back the Haar measure `\u03bc` of `A` along the map `(g \u2022 \u00b7) : A \u2192 A` to get another Haar\nmeasure `\u03bc'` on `A`. By unicity of Haar measures, there exists some nonnegative real number `r` such\nthat `\u03bc' = r \u2022 \u03bc`. We can thus define a map `distribHaarChar : G \u2192 \u211d\u22650` sending `g` to its\nassociated real number `r`. Furthermore, this number doesn't depend on the Haar measure `\u03bc` we\nstarted with, and `distribHaarChar` is a group homomorphism.\n\n## See also\n\n[Zulip](https://leanprover.zulipchat.com/#narrow/channel/217875-Is-there-code-for-X.3F/topic/canonical.20norm.20coming.20from.20Haar.20measure/near/480050592)\n-/\n\nopen scoped NNReal Pointwise ENNReal\n\nnamespace MeasureTheory.Measure\n\nvariable {G A : Type*} [Group G] [AddCommGroup A] [DistribMulAction G A]\n  [MeasurableSpace A]\n  [MeasurableSpace G] -- not needed actually\n  [MeasurableSMul G A] -- only need `MeasurableConstSMul` but we don't have this class.\nvariable {\u03bc \u03bd : Measure A} {g : G}\n\nvariable [TopologicalSpace A] [BorelSpace A] [TopologicalAddGroup A] [LocallyCompactSpace A]\n  [ContinuousConstSMul G A] [\u03bc.IsAddHaarMeasure] [\u03bd.IsAddHaarMeasure]\n\nvariable (\u03bc A) in\n@[simps (config := .lemmasOnly)]\nnoncomputable def distribHaarChar : G \u2192* \u211d\u22650 where\n  toFun g := addHaarScalarFactor (DomMulAct.mk g \u2022 addHaar) (addHaar (G := A))\n  map_one' := by simp\n  map_mul' g g' := by\n    simp_rw [DomMulAct.mk_mul]\n    rw [addHaarScalarFactor_eq_mul _ (DomMulAct.mk g' \u2022 addHaar (G := A))]\n    congr 1\n    simp_rw [mul_smul]\n    rw [addHaarScalarFactor_domSMul]\n\nvariable (\u03bc) in\n", "theoremStatement": "lemma addHaarScalarFactor_smul_eq_distribHaarChar (g : G) :\n    addHaarScalarFactor (DomMulAct.mk g \u2022 \u03bc) \u03bc = distribHaarChar A g ", "theoremName": "MeasureTheory.Measure.addHaarScalarFactor_smul_eq_distribHaarChar", "fileCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "theoremCreated": {"commit": "8786316e35a009e5d8fc0ffc56ad2ca5765dc8c7", "date": "2024-12-02"}, "file": "FLT/FLT/HaarMeasure/DistribHaarChar/Basic.lean", "module": "FLT.HaarMeasure.DistribHaarChar.Basic", "jsonFile": "FLT.HaarMeasure.DistribHaarChar.Basic.jsonl", "positionMetadata": {"lineInFile": 49, "tokenPositionInFile": 1956, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 3, "numPremises": 54}, "proofMetadata": {"hasProof": true, "proof": ":=\n  addHaarScalarFactor_smul_congr' ..", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 39}}
{"srcContext": "import Mathlib -- because there are sorries in this file\nimport FLT.Mathlib.Algebra.Order.Hom.Monoid\nimport FLT.Mathlib.Algebra.Algebra.Hom\nimport FLT.Mathlib.Algebra.Algebra.Pi\nimport FLT.Mathlib.Algebra.Algebra.Bilinear\nimport FLT.Mathlib.Topology.Algebra.UniformRing\n\n\n/-!\n\n# Base change of adele rings.\n\nIf `A` is a Dedekind domain with field of fractions `K`, if `L/K` is a finite separable\nextension and if `B` is the integral closure of `A` in `L`, then `B` is also a Dedekind\ndomain. Hence the rings of finite adeles `\ud835\udd38_K^\u221e` and `\ud835\udd38_L^\u221e` (defined using `A` and `B`)\nare defined. In this file we define the natural `K`-algebra map `\ud835\udd38_K^\u221e \u2192 \ud835\udd38_L^\u221e` and\nthe natural `L`-algebra map `\ud835\udd38_K^\u221e \u2297[K] L \u2192 \ud835\udd38_L^\u221e`, and show that the latter map\nis an isomorphism.\n\n## Main definition\n\n* `FiniteAdeleRing.baseChangeEquiv : L \u2297[K] FiniteAdeleRing A K \u2243\u2090[L] FiniteAdeleRing B L`\n\n-/\n\nopen scoped Multiplicative\n\n-- The general set-up.\n\nvariable (A K L B : Type*) [CommRing A] [CommRing B] [Algebra A B] [Field K] [Field L]\n    [Algebra A K] [IsFractionRing A K] [Algebra B L] [IsDedekindDomain A]\n    [Algebra K L] [Algebra A L] [IsScalarTower A B L] [IsScalarTower A K L]\n    [IsIntegralClosure B A L] [FiniteDimensional K L]\n\nvariable [Algebra.IsSeparable K L]\n\nexample : Function.Injective (algebraMap B L) := IsIntegralClosure.algebraMap_injective' A\n\nexample : IsDomain B := by\n  have foo : Function.Injective (algebraMap B L) := IsIntegralClosure.algebraMap_injective' A\n  have bar : IsDomain L := inferInstance\n  exact Function.Injective.isDomain _ foo -- exact? failed\nvariable [IsDomain B]\n\nexample : Algebra.IsIntegral A B := IsIntegralClosure.isIntegral_algebra A L\nvariable [Algebra.IsIntegral A B]\n\nexample : Module.Finite A B :=\n  have := IsIntegralClosure.isNoetherian A K L B\n  Module.IsNoetherian.finite A B\nvariable [Module.Finite A B]\n\nexample : IsDedekindDomain B := IsIntegralClosure.isDedekindDomain A K L B\nvariable [IsDedekindDomain B]\n\nexample : IsFractionRing B L := IsIntegralClosure.isFractionRing_of_finite_extension A K L B\nvariable [IsFractionRing B L]\n\n-- We start by filling in some holes in the API for finite extensions of Dedekind domains.\nnamespace IsDedekindDomain\n\nnamespace HeightOneSpectrum\n\n-- first need a way to pull back valuations on B to A\nvariable {B L} in\ndef comap (w : HeightOneSpectrum B) : HeightOneSpectrum A where\n  asIdeal := w.asIdeal.comap (algebraMap A B)\n  isPrime := Ideal.comap_isPrime (algebraMap A B) w.asIdeal\n  ne_bot := mt Ideal.eq_bot_of_comap_eq_bot w.ne_bot\n\nomit [Module.Finite A B] in\nlemma mk_count_factors_map\n    (hAB : Function.Injective (algebraMap A B))\n    (w : HeightOneSpectrum B) (I : Ideal A) [DecidableEq (Associates (Ideal A))]\n  [DecidableEq (Associates (Ideal B))] [\u2200 p : Associates (Ideal A), Decidable (Irreducible p)]\n  [\u2200 p : Associates (Ideal B), Decidable (Irreducible p)] :\n    (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) I)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk I).factors := by\n  classical\n  induction I using UniqueFactorizationMonoid.induction_on_prime with\n  | h\u2081 =>\n    rw [Associates.mk_zero, Ideal.zero_eq_bot, Ideal.map_bot, \u2190 Ideal.zero_eq_bot,\n      Associates.mk_zero]\n    simp [Associates.count, Associates.factors_zero, w.associates_irreducible,\n      associates_irreducible (comap A w), Associates.bcount]\n  | h\u2082 I hI =>\n    obtain rfl : I = \u22a4 := by simpa using hI\n    simp only [Submodule.zero_eq_bot, ne_eq, top_ne_bot, not_false_eq_true, Ideal.map_top]\n    simp only [\u2190 Ideal.one_eq_top, Associates.mk_one, Associates.factors_one]\n    rw [Associates.count_zero (associates_irreducible _),\n      Associates.count_zero (associates_irreducible _), mul_zero]\n  | h\u2083 I p hI hp IH =>\n    simp only [Ideal.map_mul, \u2190 Associates.mk_mul_mk]\n    have hp_bot : p \u2260 \u22a5 := hp.ne_zero\n    have hp_bot' := (Ideal.map_eq_bot_iff_of_injective hAB).not.mpr hp_bot\n    have hI_bot := (Ideal.map_eq_bot_iff_of_injective hAB).not.mpr hI\n    rw [Associates.count_mul (Associates.mk_ne_zero.mpr hp_bot) (Associates.mk_ne_zero.mpr hI)\n      (associates_irreducible _), Associates.count_mul (Associates.mk_ne_zero.mpr hp_bot')\n      (Associates.mk_ne_zero.mpr hI_bot) (associates_irreducible _)]\n    simp only [IH, mul_add]\n    congr 1\n    by_cases hw : (w.comap A).asIdeal = p\n    \u00b7 have : Irreducible (Associates.mk p) := Associates.irreducible_mk.mpr hp.irreducible\n      rw [hw, Associates.factors_self this, Associates.count_some this]\n      simp only [UniqueFactorizationMonoid.factors_eq_normalizedFactors, Multiset.nodup_singleton,\n        Multiset.mem_singleton, Multiset.count_eq_one_of_mem, mul_one]\n      rw [count_associates_factors_eq hp_bot' w.2 w.3,\n        Ideal.IsDedekindDomain.ramificationIdx_eq_normalizedFactors_count hp_bot' w.2 w.3]\n    \u00b7 have : (Associates.mk (comap A w).asIdeal).count (Associates.mk p).factors = 0 :=\n        Associates.count_eq_zero_of_ne (associates_irreducible _)\n          (Associates.irreducible_mk.mpr hp.irreducible)\n          (by rwa [ne_eq, Associates.mk_eq_mk_iff_associated, associated_iff_eq])\n      rw [this, mul_zero, eq_comm]\n      by_contra H\n      rw [eq_comm, \u2190 ne_eq, Associates.count_ne_zero_iff_dvd hp_bot' (irreducible w),\n        Ideal.dvd_iff_le, Ideal.map_le_iff_le_comap] at H\n      apply hw (((Ideal.isPrime_of_prime hp).isMaximal hp_bot).eq_of_le (comap A w).2.ne_top H).symm\n\nomit [Module.Finite A B] in\nlemma intValuation_comap (hAB : Function.Injective (algebraMap A B))\n    (w : HeightOneSpectrum B) (x : A) :\n    (comap A w).intValuation x ^\n    (Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal) =\n    w.intValuation (algebraMap A B x) := by\n  classical\n  have h_ne_zero : Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal \u2260 0 :=\n    Ideal.IsDedekindDomain.ramificationIdx_ne_zero\n      ((Ideal.map_eq_bot_iff_of_injective hAB).not.mpr (comap A w).3) w.2 Ideal.map_comap_le\n  by_cases hx : x = 0\n  \u00b7 simpa [hx]\n  simp only [intValuation, Valuation.coe_mk, MonoidWithZeroHom.coe_mk, ZeroHom.coe_mk]\n  show (ite _ _ _) ^ _ = ite _ _ _\n  by_cases hx : x = 0\n  \u00b7 subst hx; simp [h_ne_zero]\n  rw [map_eq_zero_iff _ hAB, if_neg hx, if_neg hx, \u2190 Set.image_singleton, \u2190 Ideal.map_span,\n    mk_count_factors_map _ _ hAB, mul_comm]\n  simp\n\n-- Need to know how the valuation `w` and its pullback are related on elements of `K`.\nomit [IsIntegralClosure B A L] [FiniteDimensional K L] [Algebra.IsSeparable K L]\n    [Module.Finite A B] in\nlemma valuation_comap (w : HeightOneSpectrum B) (x : K) :\n    (comap A w).valuation x ^\n    (Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal) =\n    w.valuation (algebraMap K L x) := by\n  obtain \u27e8x, y, hy, rfl\u27e9 := IsFractionRing.div_surjective (A := A) x\n  simp [valuation, \u2190 IsScalarTower.algebraMap_apply A K L, IsScalarTower.algebraMap_apply A B L,\n    \u2190 intValuation_comap A B (algebraMap_injective_of_field_isFractionRing A B K L), div_pow]\n\nomit [IsIntegralClosure B A L] [FiniteDimensional K L] [Algebra.IsSeparable K L]\n    [Module.Finite A B] in\nlemma _root_.IsDedekindDomain.HeightOneSpectrum.adicValued.continuous_algebraMap\n    (v : HeightOneSpectrum A) (w : HeightOneSpectrum B) (hvw : v = comap A w) :\n    letI : UniformSpace K := v.adicValued.toUniformSpace;\n    letI : UniformSpace L := w.adicValued.toUniformSpace;\n    Continuous (algebraMap K L) := by\n  letI : UniformSpace K := v.adicValued.toUniformSpace;\n  letI : UniformSpace L := w.adicValued.toUniformSpace;\n  subst hvw\n  refine continuous_of_continuousAt_zero (algebraMap K L) ?hf\n  delta ContinuousAt\n  simp only [map_zero]\n  rw [(@Valued.hasBasis_nhds_zero K _ _ _ (comap A w).adicValued).tendsto_iff\n    (@Valued.hasBasis_nhds_zero L _ _ _ w.adicValued)]\n  simp only [HeightOneSpectrum.adicValued_apply, Set.mem_setOf_eq, true_and, true_implies]\n  rw [WithZero.unitsWithZeroEquiv.forall_congr_left, Multiplicative.forall]\n  intro a\n  rw [WithZero.unitsWithZeroEquiv.exists_congr_left, Multiplicative.exists]\n  let m := Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal\n  let e : \u2124 \u2243 \u2124\u2098\u2080\u02e3 := Multiplicative.ofAdd.trans OrderMonoidIso.unitsWithZero.symm.toEquiv\n  have e_apply (a : \u2124) : e a = OrderMonoidIso.unitsWithZero.symm (Multiplicative.ofAdd a) := rfl\n  have hm : m \u2260 0 := by\n    refine Ideal.IsDedekindDomain.ramificationIdx_ne_zero ?_ w.2 Ideal.map_comap_le\n    exact (Ideal.map_eq_bot_iff_of_injective\n      (algebraMap_injective_of_field_isFractionRing A B K L)).not.mpr (comap A w).3\n  refine \u27e8a / m, fun x hx \u21a6 ?_\u27e9\n  simp_rw [\u2190 valuation_comap A]\n  calc\n    (comap A w).valuation x ^ m < e (a / \u2191m) ^ m := by gcongr; exacts [zero_le', hx]\n  _ = e (m \u2022 (a / \u2191m)) := by\n    dsimp [e]\n    norm_cast\n    rw [map_pow]\n  _ \u2264 e a := by\n    simp only [nsmul_eq_mul, e_apply, Units.val_le_val, OrderIsoClass.map_le_map_iff]\n    rw [mul_comm]\n    exact Int.mul_le_of_le_ediv (by positivity) le_rfl\n\nnoncomputable def adicCompletionComapSemialgHom (v : HeightOneSpectrum A) (w : HeightOneSpectrum B)\n    (hvw : v = comap A w) :\n    (HeightOneSpectrum.adicCompletion K v) \u2192\u209b\u2090[algebraMap K L]\n      (HeightOneSpectrum.adicCompletion L w) :=\n  letI : UniformSpace K := v.adicValued.toUniformSpace;\n  letI : UniformSpace L := w.adicValued.toUniformSpace;\n  UniformSpace.Completion.mapSemialgHom _ <|\n  IsDedekindDomain.HeightOneSpectrum.adicValued.continuous_algebraMap A K L B v w hvw\n\n-- Do we even need to prove that this map is continuous? It will follow from\n-- the fact that it's K_v-linear once we know L_w has the K_v-module topology,\n-- which is the next lemma.\n-- omit [IsIntegralClosure B A L] [FiniteDimensional K L] [Algebra.IsSeparable K L]\n--     [Module.Finite A B] in\n-- lemma adicCompletionComapSemialgHom_continuous\n--     (v : HeightOneSpectrum A) (w : HeightOneSpectrum B) (hvw : v = comap A w) :\n--     Continuous (adicCompletionComapSemialgHom A K L B v w hvw) := by\n--   convert UniformSpace.Completion.continuous_extension (\u03b2 := (adicCompletion L w))\n\n\nlemma adicCompletionComap_isModuleTopology\n    (v : HeightOneSpectrum A) (w : HeightOneSpectrum B) (hvw : v = comap A w) :\n    -- temporarily make L_w a K_v-algebra\n    let inst_alg : Algebra (HeightOneSpectrum.adicCompletion K v)\n      (HeightOneSpectrum.adicCompletion L w) := RingHom.toAlgebra <|\n        adicCompletionComapSemialgHom A K L B v w hvw\n    -- the claim that L_w has the module topology.\n    IsModuleTopology (HeightOneSpectrum.adicCompletion K v)\n      (HeightOneSpectrum.adicCompletion L w) := by\n  sorry -- FLT#326\n\nomit [IsIntegralClosure B A L] [FiniteDimensional K L] [Algebra.IsSeparable K L]\n    [Module.Finite A B] in\nlemma adicCompletionComapSemialgHom_coe\n    (v : HeightOneSpectrum A) (w : HeightOneSpectrum B) (hvw : v = comap A w) (x : K) :\n    adicCompletionComapSemialgHom A K L B v w hvw x = algebraMap K L x :=\n  (adicCompletionComapSemialgHom A K L B v w hvw).commutes x\n\nomit [IsIntegralClosure B A L] [FiniteDimensional K L] [Algebra.IsSeparable K L]\n    [Module.Finite A B] in\nopen WithZeroTopology in\n", "theoremStatement": "lemma v_adicCompletionComapSemialgHom\n  (v : HeightOneSpectrum A) (w : HeightOneSpectrum B) (hvw : v = comap A w) (x) :\n    Valued.v (adicCompletionComapSemialgHom A K L B v w hvw x) = Valued.v x ^\n      Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal ", "theoremName": "IsDedekindDomain.HeightOneSpectrum.v_adicCompletionComapSemialgHom", "fileCreated": {"commit": "17ea847a3d0172f39eea0bc008cd70a2755df629", "date": "2024-11-01"}, "theoremCreated": {"commit": "f463c53242f2ad3f5bdbee5b2078741ebf425207", "date": "2025-01-31"}, "file": "FLT/FLT/DedekindDomain/FiniteAdeleRing/BaseChange.lean", "module": "FLT.DedekindDomain.FiniteAdeleRing.BaseChange", "jsonFile": "FLT.DedekindDomain.FiniteAdeleRing.BaseChange.jsonl", "positionMetadata": {"lineInFile": 231, "tokenPositionInFile": 11092, "theoremPositionInFile": 7}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 4, "repositoryPremises": true, "numRepositoryPremises": 6, "numPremises": 121}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  revert x\n  apply funext_iff.mp\n  symm\n  letI : UniformSpace K := v.adicValued.toUniformSpace\n  letI : UniformSpace L := w.adicValued.toUniformSpace\n  apply UniformSpace.Completion.ext\n  \u00b7 exact Valued.continuous_valuation.pow _\n  \u00b7 exact Valued.continuous_valuation.comp UniformSpace.Completion.continuous_extension\n  intro a\n  simp_rw [adicCompletionComapSemialgHom_coe, adicCompletion, Valued.valuedCompletion_apply,\n    adicValued_apply]\n  subst hvw\n  rw [\u2190 valuation_comap A K L B w a]", "proofType": "tactic", "proofLengthLines": 13, "proofLengthTokens": 497}}
{"srcContext": "import Mathlib.NumberTheory.NumberField.Embeddings\n\n/-!\n# Embeddings of number fields\n-/\n\nnamespace NumberField.InfinitePlace\n\nvariable {K : Type*} (L : Type*) [Field K] [Field L]\n\n/--\nIf `L / K` are fields and `v` is an infinite place of `K`, then we say an infinite place `w`\nof `L` _extends_ `v` if `w` can be constructed from a complex embedding `L \u2192+* \u2102` whose\nrestriction to `K` is an associated complex embedding `K \u2192+* \u2102` of `v`.\n-/\nabbrev ExtensionPlace [Algebra K L] (v : InfinitePlace K) :=\n  { w : InfinitePlace L // w.comap (algebraMap K L) = v }\n\nvariable {L}\n\n@[simp]\ntheorem comap_apply (w : InfinitePlace L) (f : K \u2192+* L) (x : K) :\n    w.comap f x = w (f x) := rfl\n\n", "theoremStatement": "theorem comp_of_comap_eq {v : InfinitePlace K} {w : InfinitePlace L} (f : K \u2192+* L)\n    (h : w.comap f = v) (x : K) :\n    w (f x) = v x ", "theoremName": "NumberField.InfinitePlace.comp_of_comap_eq", "fileCreated": {"commit": "127241373eb7d4afd5ff86dc0e5082497c364f08", "date": "2025-02-05"}, "theoremCreated": {"commit": "127241373eb7d4afd5ff86dc0e5082497c364f08", "date": "2025-02-05"}, "file": "FLT/FLT/NumberField/Embeddings.lean", "module": "FLT.NumberField.Embeddings", "jsonFile": "FLT.NumberField.Embeddings.jsonl", "positionMetadata": {"lineInFile": 25, "tokenPositionInFile": 683, "theoremPositionInFile": 2}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 19}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp [\u2190 h]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 18}}
{"srcContext": "/-\nCopyright (c) 2024 Andrew Yang, Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang, Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras\n-/\nimport FLT.HaarMeasure.DomMulActMeasure\n\n/-!\n# The distributive character of Haar measures\n\nGiven a group `G` acting on an measurable additive commutative group `A`, and an element `g : G`,\none can pull back the Haar measure `\u03bc` of `A` along the map `(g \u2022 \u00b7) : A \u2192 A` to get another Haar\nmeasure `\u03bc'` on `A`. By unicity of Haar measures, there exists some nonnegative real number `r` such\nthat `\u03bc' = r \u2022 \u03bc`. We can thus define a map `distribHaarChar : G \u2192 \u211d\u22650` sending `g` to its\nassociated real number `r`. Furthermore, this number doesn't depend on the Haar measure `\u03bc` we\nstarted with, and `distribHaarChar` is a group homomorphism.\n\n## See also\n\n[Zulip](https://leanprover.zulipchat.com/#narrow/channel/217875-Is-there-code-for-X.3F/topic/canonical.20norm.20coming.20from.20Haar.20measure/near/480050592)\n-/\n\nopen scoped NNReal Pointwise ENNReal\n\nnamespace MeasureTheory.Measure\n\nvariable {G A : Type*} [Group G] [AddCommGroup A] [DistribMulAction G A]\n  [MeasurableSpace A]\n  [MeasurableSpace G] -- not needed actually\n  [MeasurableSMul G A] -- only need `MeasurableConstSMul` but we don't have this class.\nvariable {\u03bc \u03bd : Measure A} {g : G}\n\nvariable [TopologicalSpace A] [BorelSpace A] [TopologicalAddGroup A] [LocallyCompactSpace A]\n  [ContinuousConstSMul G A] [\u03bc.IsAddHaarMeasure] [\u03bd.IsAddHaarMeasure]\n\nvariable (\u03bc A) in\n@[simps (config := .lemmasOnly)]\nnoncomputable def distribHaarChar : G \u2192* \u211d\u22650 where\n  toFun g := addHaarScalarFactor (DomMulAct.mk g \u2022 addHaar) (addHaar (G := A))\n  map_one' := by simp\n  map_mul' g g' := by\n    simp_rw [DomMulAct.mk_mul]\n    rw [addHaarScalarFactor_eq_mul _ (DomMulAct.mk g' \u2022 addHaar (G := A))]\n    congr 1\n    simp_rw [mul_smul]\n    rw [addHaarScalarFactor_domSMul]\n\nvariable (\u03bc) in\nlemma addHaarScalarFactor_smul_eq_distribHaarChar (g : G) :\n    addHaarScalarFactor (DomMulAct.mk g \u2022 \u03bc) \u03bc = distribHaarChar A g :=\n  addHaarScalarFactor_smul_congr' ..\n\nvariable (\u03bc) in\n", "theoremStatement": "lemma addHaarScalarFactor_smul_inv_eq_distribHaarChar (g : G) :\n    addHaarScalarFactor \u03bc ((DomMulAct.mk g)\u207b\u00b9 \u2022 \u03bc) = distribHaarChar A g ", "theoremName": "MeasureTheory.Measure.addHaarScalarFactor_smul_inv_eq_distribHaarChar", "fileCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "theoremCreated": {"commit": "8786316e35a009e5d8fc0ffc56ad2ca5765dc8c7", "date": "2024-12-02"}, "file": "FLT/FLT/HaarMeasure/DistribHaarChar/Basic.lean", "module": "FLT.HaarMeasure.DistribHaarChar.Basic", "jsonFile": "FLT.HaarMeasure.DistribHaarChar.Basic.jsonl", "positionMetadata": {"lineInFile": 54, "tokenPositionInFile": 2142, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 4, "numPremises": 84}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  rw [\u2190 addHaarScalarFactor_domSMul _ _ (DomMulAct.mk g)]\n  simp_rw [\u2190 mul_smul, mul_inv_cancel, one_smul]\n  exact addHaarScalarFactor_smul_eq_distribHaarChar ..", "proofType": "tactic", "proofLengthLines": 3, "proofLengthTokens": 167}}
{"srcContext": "import Mathlib.Algebra.CharZero.Infinite\nimport Mathlib.NumberTheory.Padics.PadicIntegers\nimport FLT.Mathlib.GroupTheory.Index\n\n/-!\n# TODO\n\n* Rename `Coe.ringHom` to `coeRingHom`\n* Protect `PadicInt.norm_mul`, `PadicInt.norm_units`, `PadicInt.norm_pow`\n-/\n\nopen Function Topology Subgroup\nopen scoped NNReal nonZeroDivisors Pointwise\n\nvariable {p : \u2115} [Fact p.Prime]\n\nnamespace PadicInt\nvariable {x : \u2124_[p]}\n\nattribute [simp] coe_eq_zero\n\n@[simp, norm_cast] lemma coe_coeRingHom : \u21d1(Coe.ringHom (p := p)) = (\u2191) := rfl\n\nlemma coe_injective : Injective ((\u2191) : \u2124_[p] \u2192 \u211a_[p]) := Subtype.val_injective\n\n@[simp] lemma coe_inj {x y : \u2124_[p]} : (x : \u211a_[p]) = (y : \u211a_[p]) \u2194 x = y := coe_injective.eq_iff\n\ninstance : Infinite \u2124_[p] := CharZero.infinite _\n\n@[simp]\nprotected lemma nnnorm_mul (x y : \u2124_[p]) : \u2016x * y\u2016\u208a = \u2016x\u2016\u208a * \u2016y\u2016\u208a := by simp [nnnorm, NNReal]\n\n@[simp]\nprotected lemma nnnorm_pow (x : \u2124_[p]) (n : \u2115) : \u2016x ^ n\u2016\u208a = \u2016x\u2016\u208a ^ n := by simp [nnnorm, NNReal]\n\n@[simp] lemma nnnorm_p : \u2016(p : \u2124_[p])\u2016\u208a = (p : \u211d\u22650)\u207b\u00b9 := by simp [nnnorm]; rfl\n\n@[simp] protected lemma nnnorm_units (u : \u2124_[p]\u02e3) : \u2016(u : \u2124_[p])\u2016\u208a = 1 := by simp [nnnorm, NNReal]\n\n", "theoremStatement": "lemma exists_unit_mul_p_pow_eq (hx : x \u2260 0) : \u2203 (u : \u2124_[p]\u02e3) (n : \u2115), (u : \u2124_[p]) * p ^ n = x ", "theoremName": "PadicInt.exists_unit_mul_p_pow_eq", "fileCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "theoremCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "file": "FLT/FLT/Mathlib/NumberTheory/Padics/PadicIntegers.lean", "module": "FLT.Mathlib.NumberTheory.Padics.PadicIntegers", "jsonFile": "FLT.Mathlib.NumberTheory.Padics.PadicIntegers.jsonl", "positionMetadata": {"lineInFile": 40, "tokenPositionInFile": 1135, "theoremPositionInFile": 7}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 35}, "proofMetadata": {"hasProof": true, "proof": ":=\n  \u27e8_, _, (unitCoeff_spec hx).symm\u27e9", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 37}}
{"srcContext": "/-\nCopyright (c) 2024 Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras\n-/\nimport FLT.Mathlib.MeasureTheory.Group.Action\nimport FLT.HaarMeasure.DistribHaarChar.Basic\nimport FLT.HaarMeasure.MeasurableSpacePadics\n\n/-!\n# The distributive Haar characters of the p-adics\n\nThis file computes `distribHaarChar` in the case of the actions of `\u2124_[p]\u02e3` on `\u2124_[p]` and of\n`\u211a_[p]\u02e3` on `\u211a_[p]`.\n\nThis lets us know what `volume (x \u2022 s)` is in terms of `\u2016x\u2016` and `volume s`, when `x` is a\np-adic/p-adic integer and `s` is a set of p-adics/p-adic integers.\n\n## Main declarations\n\n* `distribHaarChar_padic`: `distribHaarChar \u211a_[p]` is the usual p-adic norm on `\u211a_[p]\u02e3`.\n* `distribHaarChar_padicInt`: `distribHaarChar \u2124_[p]` is constantly `1` on `\u2124_[p]\u02e3`.\n* `Padic.volume_padic_smul`: `volume (x \u2022 s) = \u2016x\u2016\u208a * volume s` for all `x : \u211a_[p]` and\n  `s : Set \u211a_[p]`.\n* `PadicInt.volume_padicInt_smul`: `volume (x \u2022 s) = \u2016x\u2016\u208a * volume s` for all `x : \u2124_[p]` and\n  `s : Set \u2124_[p]`.\n-/\n\nopen Padic MeasureTheory Measure Metric Set\nopen scoped Pointwise ENNReal NNReal nonZeroDivisors\n\nvariable {p : \u2115} [Fact p.Prime]\n\nprivate lemma distribHaarChar_padic_padicInt (x : \u2124_[p]\u2070) :\n    distribHaarChar \u211a_[p] (x : \u211a_[p]\u02e3) = \u2016(x : \u211a_[p])\u2016\u208a := by\n  -- Let `K` be the copy of `\u2124_[p]` inside `\u211a_[p]` and `H` be `xK`.\n  let K : AddSubgroup \u211a_[p] := (1 : Submodule \u2124_[p] \u211a_[p]).toAddSubgroup\n  let H := (x : \u211a_[p]) \u2022 K\n  -- We compute that `volume H = \u2016x\u2016\u208a * volume K`.\n  refine distribHaarChar_eq_of_measure_smul_eq_mul (s := K) (\u03bc := volume) (G := \u211a_[p]\u02e3)\n    (by simp [K, Padic.submodule_one_eq_closedBall, closedBall, Padic.volume_closedBall_one])\n    (by simp [K, Padic.submodule_one_eq_closedBall, closedBall, Padic.volume_closedBall_one]) ?_\n  change volume (H : Set \u211a_[p]) = \u2016(x : \u211a_[p])\u2016\u208a * volume (K : Set \u211a_[p])\n  -- This is true because `H` is a `\u2016x\u2016\u208a\u207b\u00b9`-index subgroup of `K`.\n  have hHK : H \u2264 K := by\n    simpa [H, K, -Submodule.smul_le_self_of_tower]\n      using (1 : Submodule \u2124_[p] \u211a_[p]).smul_le_self_of_tower (x : \u2124_[p])\n  have : H.FiniteRelIndex K :=\n    PadicInt.smul_submodule_finiteRelIndex (p := p) (mem_nonZeroDivisors_iff_ne_zero.1 x.2) 1\n  have H_relindex_Z : (H.relindex K : \u211d\u22650\u221e) = \u2016(x : \u211a_[p])\u2016\u208a\u207b\u00b9 :=\n    congr(ENNReal.ofNNReal $(PadicInt.smul_submodule_relindex (p := p) x 1))\n  rw [\u2190 index_mul_addHaar_addSubgroup_eq_addHaar_addSubgroup hHK, H_relindex_Z, ENNReal.coe_inv,\n    ENNReal.mul_inv_cancel_left]\n  \u00b7 simp\n  \u00b7 simp\n  \u00b7 simp\n  \u00b7 simpa [H, K, Padic.submodule_one_eq_closedBall]\n      using measurableSet_closedBall.const_smul (x : \u211a_[p]\u02e3)\n  \u00b7 simpa [K, Padic.submodule_one_eq_closedBall] using measurableSet_closedBall\n\n", "theoremStatement": "/-- The distributive Haar character of the action of `\u211a_[p]\u02e3` on `\u211a_[p]` is the usual p-adic norm.\n\nThis means that `volume (x \u2022 s) = \u2016x\u2016 * volume s` for all `x : \u211a_[p]` and `s : Set \u211a_[p]`.\nSee `Padic.volume_padic_smul` -/\n@[simp]\nlemma distribHaarChar_padic (x : \u211a_[p]\u02e3) : distribHaarChar \u211a_[p] x = \u2016(x : \u211a_[p])\u2016\u208a ", "theoremName": "distribHaarChar_padic", "fileCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "theoremCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "file": "FLT/FLT/HaarMeasure/DistribHaarChar/Padic.lean", "module": "FLT.HaarMeasure.DistribHaarChar.Padic", "jsonFile": "FLT.HaarMeasure.DistribHaarChar.Padic.jsonl", "positionMetadata": {"lineInFile": 61, "tokenPositionInFile": 2746, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": true, "numRepositoryPremises": 4, "numPremises": 150}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  -- Write the RHS as the application of a monoid hom `g`.\n  let g : \u211a_[p]\u02e3 \u2192* \u211d\u22650 := {\n    toFun := fun x => \u2016(x : \u211a_[p])\u2016\u208a\n    map_one' := by simp\n    map_mul' := by simp\n  }\n  revert x\n  suffices distribHaarChar \u211a_[p] = g by simp [this, g]\n  -- By density of `\u2124_[p]\u2070` inside `\u211a_[p]\u02e3`, it's enough to check that `distribHaarChar \u211a_[p]` and\n  -- `g` agree on `\u2124_[p]\u2070`.\n  refine MonoidHom.eq_of_eqOn_dense (PadicInt.closure_nonZeroDivisors_padicInt (p := p)) ?_\n  -- But this is what we proved in `distribHaarChar_padic_padicInt`.\n  simp\n  ext x\n  simp [g]\n  rw [distribHaarChar_padic_padicInt]\n  rfl", "proofType": "tactic", "proofLengthLines": 17, "proofLengthTokens": 606}}
{"srcContext": "import Mathlib.RepresentationTheory.Basic\nimport FLT.Mathlib.LinearAlgebra.Span.Defs\n\nopen Pointwise\n\nuniverse u\n\nvariable {A : Type*} [CommRing A]\n\nvariable {G : Type*} [Group G]\n\nvariable {W : Type*} [AddCommMonoid W] [Module A W]\n\nvariable {\u03c1 : Representation A G W}\n\nvariable (\u03c1) in\nstructure Subrepresentation where\n  toSubmodule : Submodule A W\n  apply_mem_toSubmodule (g : G) \u2983v : W\u2984 : v \u2208 toSubmodule \u2192 \u03c1 g v \u2208 toSubmodule\n\nnamespace Subrepresentation\n\nlemma toSubmodule_injective : Function.Injective (toSubmodule : Subrepresentation \u03c1 \u2192 Submodule A W) := by\n  rintro \u27e8_,_\u27e9\n  congr!\n\ninstance : SetLike (Subrepresentation \u03c1) W where\n  coe \u03c1' := \u03c1'.toSubmodule\n  coe_injective' := SetLike.coe_injective.comp toSubmodule_injective\n\ndef toRepresentation (\u03c1' : Subrepresentation \u03c1): Representation A G \u03c1'.toSubmodule where\n  toFun g := (\u03c1 g).restrict (\u03c1'.apply_mem_toSubmodule g)\n  map_one' := by ext; simp\n  map_mul' x y := by ext; simp\n\ninstance : Max (Subrepresentation \u03c1) where\n  max \u03c1\u2081 \u03c1\u2082 := .mk (\u03c1\u2081.toSubmodule \u2294 \u03c1\u2082.toSubmodule) <| by\n      simp only [Submodule.forall_mem_sup, map_add]\n      intro g x\u2081 hx\u2081 x\u2082 hx\u2082\n      exact Submodule.mem_sup.mpr\n        \u27e8\u03c1 g x\u2081, \u03c1\u2081.apply_mem_toSubmodule g hx\u2081, \u03c1 g x\u2082, \u03c1\u2082.apply_mem_toSubmodule g hx\u2082, rfl\u27e9\n\ninstance : Min (Subrepresentation \u03c1) where\n  min \u03c1\u2081 \u03c1\u2082 := .mk (\u03c1\u2081.toSubmodule \u2293 \u03c1\u2082.toSubmodule) <| by\n      simp only [Submodule.mem_inf, and_imp]\n      rintro g x hx\u2081 hx\u2082\n      exact \u27e8\u03c1\u2081.apply_mem_toSubmodule g hx\u2081, \u03c1\u2082.apply_mem_toSubmodule g hx\u2082\u27e9\n\n\n@[simp, norm_cast]\nlemma coe_sup (\u03c1\u2081 \u03c1\u2082 : Subrepresentation \u03c1) : \u2191(\u03c1\u2081 \u2294 \u03c1\u2082) = (\u03c1\u2081 : Set W) + (\u03c1\u2082 : Set W) :=\n  Submodule.coe_sup \u03c1\u2081.toSubmodule \u03c1\u2082.toSubmodule\n\n@[simp, norm_cast]\nlemma coe_inf (\u03c1\u2081 \u03c1\u2082 : Subrepresentation \u03c1) : \u2191(\u03c1\u2081 \u2293 \u03c1\u2082) = (\u03c1\u2081 \u2229 \u03c1\u2082 : Set W) := rfl\n\n", "theoremStatement": "@[simp]\nlemma toSubmodule_sup (\u03c1\u2081 \u03c1\u2082 : Subrepresentation \u03c1) :\n  (\u03c1\u2081 \u2294 \u03c1\u2082).toSubmodule = \u03c1\u2081.toSubmodule \u2294 \u03c1\u2082.toSubmodule ", "theoremName": "Subrepresentation.toSubmodule_sup", "fileCreated": {"commit": "14bd4f65b4f45e7747da8e4c0d90d02a58dec086", "date": "2024-12-21"}, "theoremCreated": {"commit": "14bd4f65b4f45e7747da8e4c0d90d02a58dec086", "date": "2024-12-21"}, "file": "FLT/FLT/Deformations/RepresentationTheory/Subrepresentation.lean", "module": "FLT.Deformations.RepresentationTheory.Subrepresentation", "jsonFile": "FLT.Deformations.RepresentationTheory.Subrepresentation.jsonl", "positionMetadata": {"lineInFile": 57, "tokenPositionInFile": 1770, "theoremPositionInFile": 3}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 3, "repositoryPremises": true, "numRepositoryPremises": 3, "numPremises": 21}, "proofMetadata": {"hasProof": true, "proof": ":= rfl", "proofType": "term", "proofLengthLines": 0, "proofLengthTokens": 6}}
{"srcContext": "/-\nCopyright (c) 2024 Andrew Yang, Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang, Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras\n-/\nimport Mathlib.MeasureTheory.Measure.Haar.Unique\n\nopen scoped NNReal Pointwise ENNReal\n\nnamespace MeasureTheory.Measure\n\nvariable {G A : Type*} [Group G] [AddCommGroup A] [DistribMulAction G A]\n  [MeasurableSpace A]\n  -- We only need `MeasurableConstSMul G A` but we don't have this class. So we erroneously must\n  -- assume `MeasurableSpace G` + `MeasurableSMul G A`\n  [MeasurableSpace G] [MeasurableSMul G A]\nvariable {\u03bc \u03bd : Measure A} {g : G}\n\nlemma domSMul_apply (\u03bc : Measure A) (g : G\u1d48\u1d50\u1d43) (s : Set A) :\n    (g \u2022 \u03bc) s = \u03bc ((DomMulAct.mk.symm g) \u2022 s) := by\n  refine ((MeasurableEquiv.smul ((DomMulAct.mk.symm g : G)\u207b\u00b9)).map_apply _).trans ?_\n  congr 1\n  exact Set.preimage_smul_inv (DomMulAct.mk.symm g) s\n\nlemma integral_domSMul {\u03b1} [NormedAddCommGroup \u03b1] [NormedSpace \u211d \u03b1] (g : G\u1d48\u1d50\u1d43) (f : A \u2192 \u03b1) :\n    \u222b x, f x \u2202g \u2022 \u03bc = \u222b x, f ((DomMulAct.mk.symm g)\u207b\u00b9 \u2022 x) \u2202\u03bc :=\n  integral_map_equiv (MeasurableEquiv.smul ((DomMulAct.mk.symm g : G)\u207b\u00b9)) f\n\nvariable [TopologicalSpace A] [BorelSpace A] [TopologicalAddGroup A] [LocallyCompactSpace A]\n  [ContinuousConstSMul G A] [\u03bc.IsAddHaarMeasure] [\u03bd.IsAddHaarMeasure]\n\ninstance : SMulCommClass \u211d\u22650 G\u1d48\u1d50\u1d43 (Measure A) where\n  smul_comm r g \u03bc := show r \u2022 \u03bc.map _ = (r \u2022 \u03bc).map _ by simp\n\ninstance : SMulCommClass G\u1d48\u1d50\u1d43 \u211d\u22650 (Measure A) := .symm ..\n\ninstance (g : G\u1d48\u1d50\u1d43) [Regular \u03bc] : Regular (g \u2022 \u03bc) :=\n  Regular.map (\u03bc := \u03bc) (Homeomorph.smul ((DomMulAct.mk.symm g : G)\u207b\u00b9))\n\ninstance (g : G\u1d48\u1d50\u1d43) : (g \u2022 \u03bc).IsAddHaarMeasure :=\n  (DistribMulAction.toAddEquiv _ (DomMulAct.mk.symm g\u207b\u00b9)).isAddHaarMeasure_map _\n    (continuous_const_smul _) (continuous_const_smul _)\n\nvariable (\u03bc \u03bd) in\n", "theoremStatement": "lemma addHaarScalarFactor_domSMul (g : G\u1d48\u1d50\u1d43) :\n    addHaarScalarFactor (g \u2022 \u03bc) (g \u2022 \u03bd) = addHaarScalarFactor \u03bc \u03bd ", "theoremName": "MeasureTheory.Measure.addHaarScalarFactor_domSMul", "fileCreated": {"commit": "0624e5a452d5645b8a3766b4169a48010d2a725f", "date": "2024-12-10"}, "theoremCreated": {"commit": "2d142bb6c8fc86583ce6bb6bafe467552298e27e", "date": "2025-01-23"}, "file": "FLT/FLT/HaarMeasure/DomMulActMeasure.lean", "module": "FLT.HaarMeasure.DomMulActMeasure", "jsonFile": "FLT.HaarMeasure.DomMulActMeasure.jsonl", "positionMetadata": {"lineInFile": 45, "tokenPositionInFile": 1838, "theoremPositionInFile": 2}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 2, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 110}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  obtain \u27e8\u27e8f, f_cont\u27e9, f_comp, f_nonneg, f_zero\u27e9 :\n    \u2203 f : C(A, \u211d), HasCompactSupport f \u2227 0 \u2264 f \u2227 f 0 \u2260 0 := exists_continuous_nonneg_pos 0\n  have int_f_ne_zero : \u222b x, f x \u2202g \u2022 \u03bd \u2260 0 :=\n    (f_cont.integral_pos_of_hasCompactSupport_nonneg_nonzero f_comp f_nonneg f_zero).ne'\n  apply NNReal.coe_injective\n  rw [addHaarScalarFactor_eq_integral_div (g \u2022 \u03bc) (g \u2022 \u03bd) f_cont f_comp int_f_ne_zero,\n    integral_domSMul, integral_domSMul]\n  refine (addHaarScalarFactor_eq_integral_div _ _ (by fun_prop) ?_ ?_).symm\n  \u00b7 exact f_comp.comp_isClosedEmbedding (Homeomorph.smul _).isClosedEmbedding\n  \u00b7 rw [\u2190 integral_domSMul]\n    exact (f_cont.integral_pos_of_hasCompactSupport_nonneg_nonzero f_comp f_nonneg f_zero).ne'", "proofType": "tactic", "proofLengthLines": 11, "proofLengthTokens": 715}}
{"srcContext": "import Mathlib.GroupTheory.Complement\nimport Mathlib.MeasureTheory.Group.Action\nimport Mathlib.MeasureTheory.Group.Pointwise\nimport Mathlib.Topology.Algebra.InfiniteSum.ENNReal\nimport FLT.Mathlib.Algebra.Group.Subgroup.Defs\nimport FLT.Mathlib.GroupTheory.Index\n\n/-!\n# TODO\n\n* Make `\u03b1` implicit in `SMulInvariantMeasure`\n* Rename `SMulInvariantMeasure` to `Measure.IsSMulInvariant`\n-/\n\nopen Subgroup Set\nopen scoped Pointwise\n\nnamespace MeasureTheory\nvariable {G \u03b1 : Type*} [Group G] [MeasurableSpace G] [MeasurableSpace \u03b1]\n  {H K : Subgroup G}\n\n@[to_additive]\ninstance [MeasurableMul\u2082 G] : MeasurableMul\u2082 H where measurable_mul := by measurability\n\n@[to_additive]\ninstance [MeasurableInv G] : MeasurableInv H where measurable_inv := sorry\n\nvariable [MeasurableMul G]\n\n@[to_additive]\ninstance : MeasurableMul H where\n  measurable_mul_const c := by measurability\n  measurable_const_mul c := sorry -- https://github.com/ImperialCollegeLondon/FLT/issues/276\n\n@[to_additive]\ninstance (\u03bc : Measure G) [\u03bc.IsMulLeftInvariant] :\n    (\u03bc.comap Subtype.val : Measure H).IsMulLeftInvariant where\n  map_mul_left_eq_self g := sorry -- https://github.com/ImperialCollegeLondon/FLT/issues/276\n\n@[to_additive]\ninstance (\u03bc : Measure G) [\u03bc.IsMulRightInvariant] :\n    (\u03bc.comap Subtype.val : Measure H).IsMulRightInvariant where\n  map_mul_right_eq_self g := sorry -- https://github.com/ImperialCollegeLondon/FLT/issues/276\n\n", "theoremStatement": "@[to_additive index_mul_addHaar_addSubgroup]\nlemma index_mul_haar_subgroup [H.FiniteIndex] (hH : MeasurableSet (H : Set G)) (\u03bc : Measure G)\n    [\u03bc.IsMulLeftInvariant] : H.index * \u03bc H = \u03bc univ ", "theoremName": "MeasureTheory.index_mul_haar_subgroup", "fileCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "theoremCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "file": "FLT/FLT/Mathlib/MeasureTheory/Group/Action.lean", "module": "FLT.Mathlib.MeasureTheory.Group.Action", "jsonFile": "FLT.Mathlib.MeasureTheory.Group.Action.jsonl", "positionMetadata": {"lineInFile": 45, "tokenPositionInFile": 1402, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 107}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  obtain \u27e8s, hs, -\u27e9 := H.exists_isComplement_left 1\n  have hs' : Finite s := hs.finite_left_iff.mpr inferInstance\n  calc\n    H.index * \u03bc H = \u2211' a : s, \u03bc (a.val \u2022 H) := by\n      simp [measure_smul]\n      rw [\u2190 Set.Finite.cast_ncard_eq hs', \u2190 Nat.card_coe_set_eq, hs.card_left]\n      norm_cast\n    _ = \u03bc univ := by\n      rw [\u2190 measure_iUnion _ fun _ \u21a6 hH.const_smul _]\n      \u00b7 simp [hs.mul_eq]\n      \u00b7 exact fun a b hab \u21a6 hs.pairwiseDisjoint_smul a.2 b.2 (Subtype.val_injective.ne hab)", "proofType": "tactic", "proofLengthLines": 11, "proofLengthTokens": 489}}
{"srcContext": "import Mathlib.NumberTheory.NumberField.Basic\n\nopen scoped NumberField\n\n-- Mathlib PR #20544\n", "theoremStatement": "theorem Rat.ringOfIntegersEquiv_eq_algebraMap (z : \ud835\udcde \u211a) :\n    (Rat.ringOfIntegersEquiv z : \u211a) = algebraMap (\ud835\udcde \u211a) \u211a z ", "theoremName": "Rat.ringOfIntegersEquiv_eq_algebraMap", "fileCreated": {"commit": "ebbb6f2506888a21f3541cc71f1c5ba0181056e5", "date": "2025-01-06"}, "theoremCreated": {"commit": "ebbb6f2506888a21f3541cc71f1c5ba0181056e5", "date": "2025-01-06"}, "file": "FLT/FLT/Mathlib/NumberTheory/NumberField/Basic.lean", "module": "FLT.Mathlib.NumberTheory.NumberField.Basic", "jsonFile": "FLT.Mathlib.NumberTheory.NumberField.Basic.jsonl", "positionMetadata": {"lineInFile": 6, "tokenPositionInFile": 93, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 59}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  obtain \u27e8z, rfl\u27e9 := Rat.ringOfIntegersEquiv.symm.surjective z\n  simp", "proofType": "tactic", "proofLengthLines": 2, "proofLengthTokens": 75}}
{"srcContext": "import Mathlib.Algebra.CharZero.Infinite\nimport Mathlib.NumberTheory.Padics.PadicIntegers\nimport FLT.Mathlib.GroupTheory.Index\n\n/-!\n# TODO\n\n* Rename `Coe.ringHom` to `coeRingHom`\n* Protect `PadicInt.norm_mul`, `PadicInt.norm_units`, `PadicInt.norm_pow`\n-/\n\nopen Function Topology Subgroup\nopen scoped NNReal nonZeroDivisors Pointwise\n\nvariable {p : \u2115} [Fact p.Prime]\n\nnamespace PadicInt\nvariable {x : \u2124_[p]}\n\nattribute [simp] coe_eq_zero\n\n@[simp, norm_cast] lemma coe_coeRingHom : \u21d1(Coe.ringHom (p := p)) = (\u2191) := rfl\n\nlemma coe_injective : Injective ((\u2191) : \u2124_[p] \u2192 \u211a_[p]) := Subtype.val_injective\n\n@[simp] lemma coe_inj {x y : \u2124_[p]} : (x : \u211a_[p]) = (y : \u211a_[p]) \u2194 x = y := coe_injective.eq_iff\n\ninstance : Infinite \u2124_[p] := CharZero.infinite _\n\n", "theoremStatement": "@[simp]\nprotected lemma nnnorm_mul (x y : \u2124_[p]) : \u2016x * y\u2016\u208a = \u2016x\u2016\u208a * \u2016y\u2016\u208a ", "theoremName": "PadicInt.nnnorm_mul", "fileCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "theoremCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "file": "FLT/FLT/Mathlib/NumberTheory/Padics/PadicIntegers.lean", "module": "FLT.Mathlib.NumberTheory.Padics.PadicIntegers", "jsonFile": "FLT.Mathlib.NumberTheory.Padics.PadicIntegers.jsonl", "positionMetadata": {"lineInFile": 30, "tokenPositionInFile": 746, "theoremPositionInFile": 3}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 57}, "proofMetadata": {"hasProof": true, "proof": ":= by simp [nnnorm, NNReal]", "proofType": "tactic", "proofLengthLines": 0, "proofLengthTokens": 27}}
{"srcContext": "/-\nCopyright (c) 2024 Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras\n-/\nimport Mathlib.Analysis.Complex.ReImTopology\nimport Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar\nimport Mathlib.RingTheory.Complex\nimport Mathlib.RingTheory.Norm.Transitivity\nimport FLT.HaarMeasure.DistribHaarChar.Basic\nimport FLT.Mathlib.LinearAlgebra.Determinant\n\n/-!\n# The distributive Haar characters of `\u211d` and `\u2102`\n\nThis file computes `distribHaarChar` in the case of the actions of `\u211d\u02e3` on `\u211d` and of `\u2102\u02e3` on `\u2102`.\n\nThis lets us know what `volume (x \u2022 s)` is in terms of `\u2016x\u2016` and `volume s`, when `x` is a\nreal/complex number and `s` is a set of reals/complex numbers.\n\n## Main declarations\n\n* `distribHaarChar_real`: `distribHaarChar \u211d` is the usual norm on `\u211d`.\n* `distribHaarChar_complex`: `distribHaarChar \u2102` is the usual norm on `\u2102` squared.\n* `Real.volume_real_smul`: `volume (x \u2022 s) = \u2016x\u2016\u208a * volume s` for all `x : \u211d` and `s : Set \u211d`.\n* `Complex.volume_complex_smul`: `volume (z \u2022 s) = \u2016z\u2016\u208a ^ 2 * volume s` for all `z : \u2102` and\n  `s : Set \u2102`.\n-/\n\nopen Real Complex MeasureTheory Measure Set\nopen scoped Pointwise\n\n", "theoremStatement": "lemma Real.volume_real_smul (x : \u211d) (s : Set \u211d) : volume (x \u2022 s) = \u2016x\u2016\u208a * volume s ", "theoremName": "Real.volume_real_smul", "fileCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "theoremCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "file": "FLT/FLT/HaarMeasure/DistribHaarChar/RealComplex.lean", "module": "FLT.HaarMeasure.DistribHaarChar.RealComplex", "jsonFile": "FLT.HaarMeasure.DistribHaarChar.RealComplex.jsonl", "positionMetadata": {"lineInFile": 33, "tokenPositionInFile": 1225, "theoremPositionInFile": 0}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 94}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp [\u2190 enorm_eq_ofReal_abs, enorm_eq_nnnorm]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 53}}
{"srcContext": "import Mathlib\nimport FLT.Mathlib.Algebra.Algebra.Hom\n\nvariable {R S : Type*} [CommSemiring R] [CommSemiring S] {\u03c6 : R \u2192+* S}\n    {A B : Type*}  [Semiring A] [Semiring B] [Algebra R A] [Algebra S B]\n\nopen scoped TensorProduct in\n/-- Given S an R-algebra, and a ring homomorphism `\u03c8` from an R-algebra A to an S-algebra B\ncompatible with the algebra map R \u2192 S, `baseChange_of_algebraMap \u03c8` is the induced\n`S`-algebra map `S \u2297[R] A \u2192 B`.\n-/\nnoncomputable\ndef SemialgHom.baseChange_of_algebraMap [Algebra R S] (\u03c8 : A \u2192\u209b\u2090[algebraMap R S] B) :\n    S \u2297[R] A \u2192\u2090[S] B :=\n  letI : Algebra R B := Algebra.compHom _ (algebraMap R S)\n  have : IsScalarTower R S B := .of_algebraMap_eq fun _ \u21a6 rfl\n  let \u03c1 : A \u2192\u2090[R] B := {\n    toRingHom := \u03c8.toRingHom\n    commutes' := \u03c8.commutes\n  }\n  Algebra.TensorProduct.lift (Algebra.ofId S _) \u03c1 fun s a \u21a6 Algebra.commutes s (\u03c1 a)\n\n", "theoremStatement": "@[simp]\ntheorem SemialgHom.baseChange_of_algebraMap_tmul_right [Algebra R S] (\u03c8 : A \u2192\u209b\u2090[algebraMap R S] B)\n    (a : A) :\n    \u03c8.baseChange_of_algebraMap (1 \u2297\u209c[R] a) = \u03c8 a ", "theoremName": "SemialgHom.baseChange_of_algebraMap_tmul_right", "fileCreated": {"commit": "f463c53242f2ad3f5bdbee5b2078741ebf425207", "date": "2025-01-31"}, "theoremCreated": {"commit": "127241373eb7d4afd5ff86dc0e5082497c364f08", "date": "2025-02-05"}, "file": "FLT/FLT/Mathlib/Algebra/Algebra/Bilinear.lean", "module": "FLT.Mathlib.Algebra.Algebra.Bilinear", "jsonFile": "FLT.Mathlib.Algebra.Algebra.Bilinear.jsonl", "positionMetadata": {"lineInFile": 23, "tokenPositionInFile": 856, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 3, "numPremises": 49}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp [baseChange_of_algebraMap, SemialgHom.toLinearMap_eq_coe]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 70}}
{"srcContext": "/-\nCopyright (c) 2024 Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras\n-/\nimport FLT.Mathlib.MeasureTheory.Group.Action\nimport FLT.HaarMeasure.DistribHaarChar.Basic\nimport FLT.HaarMeasure.MeasurableSpacePadics\n\n/-!\n# The distributive Haar characters of the p-adics\n\nThis file computes `distribHaarChar` in the case of the actions of `\u2124_[p]\u02e3` on `\u2124_[p]` and of\n`\u211a_[p]\u02e3` on `\u211a_[p]`.\n\nThis lets us know what `volume (x \u2022 s)` is in terms of `\u2016x\u2016` and `volume s`, when `x` is a\np-adic/p-adic integer and `s` is a set of p-adics/p-adic integers.\n\n## Main declarations\n\n* `distribHaarChar_padic`: `distribHaarChar \u211a_[p]` is the usual p-adic norm on `\u211a_[p]\u02e3`.\n* `distribHaarChar_padicInt`: `distribHaarChar \u2124_[p]` is constantly `1` on `\u2124_[p]\u02e3`.\n* `Padic.volume_padic_smul`: `volume (x \u2022 s) = \u2016x\u2016\u208a * volume s` for all `x : \u211a_[p]` and\n  `s : Set \u211a_[p]`.\n* `PadicInt.volume_padicInt_smul`: `volume (x \u2022 s) = \u2016x\u2016\u208a * volume s` for all `x : \u2124_[p]` and\n  `s : Set \u2124_[p]`.\n-/\n\nopen Padic MeasureTheory Measure Metric Set\nopen scoped Pointwise ENNReal NNReal nonZeroDivisors\n\nvariable {p : \u2115} [Fact p.Prime]\n\nprivate lemma distribHaarChar_padic_padicInt (x : \u2124_[p]\u2070) :\n    distribHaarChar \u211a_[p] (x : \u211a_[p]\u02e3) = \u2016(x : \u211a_[p])\u2016\u208a := by\n  -- Let `K` be the copy of `\u2124_[p]` inside `\u211a_[p]` and `H` be `xK`.\n  let K : AddSubgroup \u211a_[p] := (1 : Submodule \u2124_[p] \u211a_[p]).toAddSubgroup\n  let H := (x : \u211a_[p]) \u2022 K\n  -- We compute that `volume H = \u2016x\u2016\u208a * volume K`.\n  refine distribHaarChar_eq_of_measure_smul_eq_mul (s := K) (\u03bc := volume) (G := \u211a_[p]\u02e3)\n    (by simp [K, Padic.submodule_one_eq_closedBall, closedBall, Padic.volume_closedBall_one])\n    (by simp [K, Padic.submodule_one_eq_closedBall, closedBall, Padic.volume_closedBall_one]) ?_\n  change volume (H : Set \u211a_[p]) = \u2016(x : \u211a_[p])\u2016\u208a * volume (K : Set \u211a_[p])\n  -- This is true because `H` is a `\u2016x\u2016\u208a\u207b\u00b9`-index subgroup of `K`.\n  have hHK : H \u2264 K := by\n    simpa [H, K, -Submodule.smul_le_self_of_tower]\n      using (1 : Submodule \u2124_[p] \u211a_[p]).smul_le_self_of_tower (x : \u2124_[p])\n  have : H.FiniteRelIndex K :=\n    PadicInt.smul_submodule_finiteRelIndex (p := p) (mem_nonZeroDivisors_iff_ne_zero.1 x.2) 1\n  have H_relindex_Z : (H.relindex K : \u211d\u22650\u221e) = \u2016(x : \u211a_[p])\u2016\u208a\u207b\u00b9 :=\n    congr(ENNReal.ofNNReal $(PadicInt.smul_submodule_relindex (p := p) x 1))\n  rw [\u2190 index_mul_addHaar_addSubgroup_eq_addHaar_addSubgroup hHK, H_relindex_Z, ENNReal.coe_inv,\n    ENNReal.mul_inv_cancel_left]\n  \u00b7 simp\n  \u00b7 simp\n  \u00b7 simp\n  \u00b7 simpa [H, K, Padic.submodule_one_eq_closedBall]\n      using measurableSet_closedBall.const_smul (x : \u211a_[p]\u02e3)\n  \u00b7 simpa [K, Padic.submodule_one_eq_closedBall] using measurableSet_closedBall\n\n/-- The distributive Haar character of the action of `\u211a_[p]\u02e3` on `\u211a_[p]` is the usual p-adic norm.\n\nThis means that `volume (x \u2022 s) = \u2016x\u2016 * volume s` for all `x : \u211a_[p]` and `s : Set \u211a_[p]`.\nSee `Padic.volume_padic_smul` -/\n@[simp]\nlemma distribHaarChar_padic (x : \u211a_[p]\u02e3) : distribHaarChar \u211a_[p] x = \u2016(x : \u211a_[p])\u2016\u208a := by\n  -- Write the RHS as the application of a monoid hom `g`.\n  let g : \u211a_[p]\u02e3 \u2192* \u211d\u22650 := {\n    toFun := fun x => \u2016(x : \u211a_[p])\u2016\u208a\n    map_one' := by simp\n    map_mul' := by simp\n  }\n  revert x\n  suffices distribHaarChar \u211a_[p] = g by simp [this, g]\n  -- By density of `\u2124_[p]\u2070` inside `\u211a_[p]\u02e3`, it's enough to check that `distribHaarChar \u211a_[p]` and\n  -- `g` agree on `\u2124_[p]\u2070`.\n  refine MonoidHom.eq_of_eqOn_dense (PadicInt.closure_nonZeroDivisors_padicInt (p := p)) ?_\n  -- But this is what we proved in `distribHaarChar_padic_padicInt`.\n  simp\n  ext x\n  simp [g]\n  rw [distribHaarChar_padic_padicInt]\n  rfl\n\n@[simp]\nlemma Padic.volume_padic_smul (x : \u211a_[p]) (s : Set \u211a_[p]) : volume (x \u2022 s) = \u2016x\u2016\u208a * volume s := by\n  obtain rfl | hx := eq_or_ne x 0\n  \u00b7 simp [(finite_zero.subset s.zero_smul_set_subset).measure_zero]\n  \u00b7 lift x to \u211a_[p]\u02e3 using hx.isUnit\n    rw [\u2190 distribHaarChar_padic, distribHaarChar_mul, Units.smul_def]\n\n@[simp] lemma Padic.volume_padicInt_smul (x : \u2124_[p]) (s : Set \u211a_[p]) :\n    volume (x \u2022 s) = \u2016x\u2016\u208a * volume s := by simpa [-volume_padic_smul] using volume_padic_smul x s\n\n", "theoremStatement": "@[simp] lemma PadicInt.volume_padicInt_smul (x : \u2124_[p]) (s : Set \u2124_[p]) :\n    volume (x \u2022 s) = \u2016x\u2016\u208a * volume s ", "theoremName": "PadicInt.volume_padicInt_smul", "fileCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "theoremCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "file": "FLT/FLT/HaarMeasure/DistribHaarChar/Padic.lean", "module": "FLT.HaarMeasure.DistribHaarChar.Padic", "jsonFile": "FLT.HaarMeasure.DistribHaarChar.Padic.jsonl", "positionMetadata": {"lineInFile": 95, "tokenPositionInFile": 4157, "theoremPositionInFile": 4}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 5, "numPremises": 64}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simpa [-volume_padicInt_smul, \u2190 image_coe_smul_set] using Padic.volume_padicInt_smul x ((\u2191) '' s)", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 105}}
{"srcContext": "/-\nCopyright (c) 2024 Andrew Yang, Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang, Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras\n-/\nimport Mathlib.MeasureTheory.Measure.Haar.Unique\n\nopen scoped NNReal Pointwise ENNReal\n\nnamespace MeasureTheory.Measure\n\nvariable {G A : Type*} [Group G] [AddCommGroup A] [DistribMulAction G A]\n  [MeasurableSpace A]\n  -- We only need `MeasurableConstSMul G A` but we don't have this class. So we erroneously must\n  -- assume `MeasurableSpace G` + `MeasurableSMul G A`\n  [MeasurableSpace G] [MeasurableSMul G A]\nvariable {\u03bc \u03bd : Measure A} {g : G}\n\nlemma domSMul_apply (\u03bc : Measure A) (g : G\u1d48\u1d50\u1d43) (s : Set A) :\n    (g \u2022 \u03bc) s = \u03bc ((DomMulAct.mk.symm g) \u2022 s) := by\n  refine ((MeasurableEquiv.smul ((DomMulAct.mk.symm g : G)\u207b\u00b9)).map_apply _).trans ?_\n  congr 1\n  exact Set.preimage_smul_inv (DomMulAct.mk.symm g) s\n\n", "theoremStatement": "lemma integral_domSMul {\u03b1} [NormedAddCommGroup \u03b1] [NormedSpace \u211d \u03b1] (g : G\u1d48\u1d50\u1d43) (f : A \u2192 \u03b1) :\n    \u222b x, f x \u2202g \u2022 \u03bc = \u222b x, f ((DomMulAct.mk.symm g)\u207b\u00b9 \u2022 x) \u2202\u03bc ", "theoremName": "MeasureTheory.Measure.integral_domSMul", "fileCreated": {"commit": "0624e5a452d5645b8a3766b4169a48010d2a725f", "date": "2024-12-10"}, "theoremCreated": {"commit": "2d142bb6c8fc86583ce6bb6bafe467552298e27e", "date": "2025-01-23"}, "file": "FLT/FLT/HaarMeasure/DomMulActMeasure.lean", "module": "FLT.HaarMeasure.DomMulActMeasure", "jsonFile": "FLT.HaarMeasure.DomMulActMeasure.jsonl", "positionMetadata": {"lineInFile": 25, "tokenPositionInFile": 934, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 44}, "proofMetadata": {"hasProof": true, "proof": ":=\n  integral_map_equiv (MeasurableEquiv.smul ((DomMulAct.mk.symm g : G)\u207b\u00b9)) f", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 78}}
{"srcContext": "import Mathlib.LinearAlgebra.Span.Defs\n\nopen Pointwise\n\nvariable {R : Type*} [Semiring R]\n\nvariable {M : Type*} [AddCommMonoid M] [Module R M]\n\nvariable {p p' : Submodule R M}\n\nvariable {P : M \u2192 Prop}\n\nnamespace Submodule\n\n@[simp high]\nlemma forall_mem_sup : (\u2200 x \u2208 p \u2294 p', P x) \u2194 (\u2200 x\u2081 \u2208 p, \u2200 x\u2082 \u2208 p', P (x\u2081 + x\u2082)) := by\n  simp [mem_sup]\n  aesop\n\n", "theoremStatement": "@[simp high]\nlemma exists_mem_sup : (\u2203 x \u2208 p \u2294 p', P x) \u2194 (\u2203 x\u2081 \u2208 p, \u2203 x\u2082 \u2208 p', P (x\u2081 + x\u2082)) ", "theoremName": "Submodule.exists_mem_sup", "fileCreated": {"commit": "14bd4f65b4f45e7747da8e4c0d90d02a58dec086", "date": "2024-12-21"}, "theoremCreated": {"commit": "14bd4f65b4f45e7747da8e4c0d90d02a58dec086", "date": "2024-12-21"}, "file": "FLT/FLT/Mathlib/LinearAlgebra/Span/Defs.lean", "module": "FLT.Mathlib.LinearAlgebra.Span.Defs", "jsonFile": "FLT.Mathlib.LinearAlgebra.Span.Defs.jsonl", "positionMetadata": {"lineInFile": 20, "tokenPositionInFile": 348, "theoremPositionInFile": 1}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 31}, "proofMetadata": {"hasProof": true, "proof": ":= by\n  simp [mem_sup]", "proofType": "tactic", "proofLengthLines": 1, "proofLengthTokens": 22}}
{"srcContext": "import Mathlib.GroupTheory.Index\n\n/-!\n# TODO\n\n* Rename `relindex` to `relIndex`\n* Rename `FiniteIndex.finiteIndex` to `FiniteIndex.index_ne_zero`\n-/\n\nopen Function\nopen scoped Pointwise\n\n-- This is cool notation. Should mathlib have it? And what should the `relindex` version be?\nscoped[GroupTheory] notation \"[\" G \":\" H \"]\" => @AddSubgroup.index G _ H\n\nnamespace Subgroup\nvariable {G G' : Type*} [Group G] [Group G'] {f : G \u2192* G'} {H K : Subgroup G}\n\nclass _root_.AddSubgroup.FiniteRelIndex {G : Type*} [AddGroup G] (H K : AddSubgroup G) : Prop where\n  protected relIndex_ne_zero : H.relindex K \u2260 0\n\n@[to_additive] class FiniteRelIndex (H K : Subgroup G) : Prop where\n  protected relIndex_ne_zero : H.relindex K \u2260 0\n\n@[to_additive]\nlemma relIndex_ne_zero [H.FiniteRelIndex K] : H.relindex K \u2260 0 := FiniteRelIndex.relIndex_ne_zero\n\n@[to_additive]\ninstance FiniteRelIndex.to_finiteIndex_subgroupOf [H.FiniteRelIndex K] :\n    (H.subgroupOf K).FiniteIndex where\n  finiteIndex := relIndex_ne_zero\n\n", "theoremStatement": "@[to_additive]\nlemma index_map_of_bijective (S : Subgroup G) (hf : Bijective f) : (S.map f).index = S.index ", "theoremName": "Subgroup.index_map_of_bijective", "fileCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "theoremCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "file": "FLT/FLT/Mathlib/GroupTheory/Index.lean", "module": "FLT.Mathlib.GroupTheory.Index", "jsonFile": "FLT.Mathlib.GroupTheory.Index.jsonl", "positionMetadata": {"lineInFile": 33, "tokenPositionInFile": 994, "theoremPositionInFile": 2}, "dependencyMetadata": {"inFilePremises": false, "numInFilePremises": 0, "repositoryPremises": false, "numRepositoryPremises": 0, "numPremises": 35}, "proofMetadata": {"hasProof": true, "proof": ":=\n  index_map_eq _ hf.2 (by rw [f.ker_eq_bot_iff.2 hf.1]; exact bot_le)", "proofType": "term", "proofLengthLines": 1, "proofLengthTokens": 72}}
{"srcContext": "/-\nCopyright (c) 2024 Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Ya\u00ebl Dillies, Javier L\u00f3pez-Contreras\n-/\nimport FLT.Mathlib.MeasureTheory.Group.Action\nimport FLT.HaarMeasure.DistribHaarChar.Basic\nimport FLT.HaarMeasure.MeasurableSpacePadics\n\n/-!\n# The distributive Haar characters of the p-adics\n\nThis file computes `distribHaarChar` in the case of the actions of `\u2124_[p]\u02e3` on `\u2124_[p]` and of\n`\u211a_[p]\u02e3` on `\u211a_[p]`.\n\nThis lets us know what `volume (x \u2022 s)` is in terms of `\u2016x\u2016` and `volume s`, when `x` is a\np-adic/p-adic integer and `s` is a set of p-adics/p-adic integers.\n\n## Main declarations\n\n* `distribHaarChar_padic`: `distribHaarChar \u211a_[p]` is the usual p-adic norm on `\u211a_[p]\u02e3`.\n* `distribHaarChar_padicInt`: `distribHaarChar \u2124_[p]` is constantly `1` on `\u2124_[p]\u02e3`.\n* `Padic.volume_padic_smul`: `volume (x \u2022 s) = \u2016x\u2016\u208a * volume s` for all `x : \u211a_[p]` and\n  `s : Set \u211a_[p]`.\n* `PadicInt.volume_padicInt_smul`: `volume (x \u2022 s) = \u2016x\u2016\u208a * volume s` for all `x : \u2124_[p]` and\n  `s : Set \u2124_[p]`.\n-/\n\nopen Padic MeasureTheory Measure Metric Set\nopen scoped Pointwise ENNReal NNReal nonZeroDivisors\n\nvariable {p : \u2115} [Fact p.Prime]\n\nprivate lemma distribHaarChar_padic_padicInt (x : \u2124_[p]\u2070) :\n    distribHaarChar \u211a_[p] (x : \u211a_[p]\u02e3) = \u2016(x : \u211a_[p])\u2016\u208a := by\n  -- Let `K` be the copy of `\u2124_[p]` inside `\u211a_[p]` and `H` be `xK`.\n  let K : AddSubgroup \u211a_[p] := (1 : Submodule \u2124_[p] \u211a_[p]).toAddSubgroup\n  let H := (x : \u211a_[p]) \u2022 K\n  -- We compute that `volume H = \u2016x\u2016\u208a * volume K`.\n  refine distribHaarChar_eq_of_measure_smul_eq_mul (s := K) (\u03bc := volume) (G := \u211a_[p]\u02e3)\n    (by simp [K, Padic.submodule_one_eq_closedBall, closedBall, Padic.volume_closedBall_one])\n    (by simp [K, Padic.submodule_one_eq_closedBall, closedBall, Padic.volume_closedBall_one]) ?_\n  change volume (H : Set \u211a_[p]) = \u2016(x : \u211a_[p])\u2016\u208a * volume (K : Set \u211a_[p])\n  -- This is true because `H` is a `\u2016x\u2016\u208a\u207b\u00b9`-index subgroup of `K`.\n  have hHK : H \u2264 K := by\n    simpa [H, K, -Submodule.smul_le_self_of_tower]\n      using (1 : Submodule \u2124_[p] \u211a_[p]).smul_le_self_of_tower (x : \u2124_[p])\n  have : H.FiniteRelIndex K :=\n    PadicInt.smul_submodule_finiteRelIndex (p := p) (mem_nonZeroDivisors_iff_ne_zero.1 x.2) 1\n  have H_relindex_Z : (H.relindex K : \u211d\u22650\u221e) = \u2016(x : \u211a_[p])\u2016\u208a\u207b\u00b9 :=\n    congr(ENNReal.ofNNReal $(PadicInt.smul_submodule_relindex (p := p) x 1))\n  rw [\u2190 index_mul_addHaar_addSubgroup_eq_addHaar_addSubgroup hHK, H_relindex_Z, ENNReal.coe_inv,\n    ENNReal.mul_inv_cancel_left]\n  \u00b7 simp\n  \u00b7 simp\n  \u00b7 simp\n  \u00b7 simpa [H, K, Padic.submodule_one_eq_closedBall]\n      using measurableSet_closedBall.const_smul (x : \u211a_[p]\u02e3)\n  \u00b7 simpa [K, Padic.submodule_one_eq_closedBall] using measurableSet_closedBall\n\n/-- The distributive Haar character of the action of `\u211a_[p]\u02e3` on `\u211a_[p]` is the usual p-adic norm.\n\nThis means that `volume (x \u2022 s) = \u2016x\u2016 * volume s` for all `x : \u211a_[p]` and `s : Set \u211a_[p]`.\nSee `Padic.volume_padic_smul` -/\n@[simp]\nlemma distribHaarChar_padic (x : \u211a_[p]\u02e3) : distribHaarChar \u211a_[p] x = \u2016(x : \u211a_[p])\u2016\u208a := by\n  -- Write the RHS as the application of a monoid hom `g`.\n  let g : \u211a_[p]\u02e3 \u2192* \u211d\u22650 := {\n    toFun := fun x => \u2016(x : \u211a_[p])\u2016\u208a\n    map_one' := by simp\n    map_mul' := by simp\n  }\n  revert x\n  suffices distribHaarChar \u211a_[p] = g by simp [this, g]\n  -- By density of `\u2124_[p]\u2070` inside `\u211a_[p]\u02e3`, it's enough to check that `distribHaarChar \u211a_[p]` and\n  -- `g` agree on `\u2124_[p]\u2070`.\n  refine MonoidHom.eq_of_eqOn_dense (PadicInt.closure_nonZeroDivisors_padicInt (p := p)) ?_\n  -- But this is what we proved in `distribHaarChar_padic_padicInt`.\n  simp\n  ext x\n  simp [g]\n  rw [distribHaarChar_padic_padicInt]\n  rfl\n\n@[simp]\nlemma Padic.volume_padic_smul (x : \u211a_[p]) (s : Set \u211a_[p]) : volume (x \u2022 s) = \u2016x\u2016\u208a * volume s := by\n  obtain rfl | hx := eq_or_ne x 0\n  \u00b7 simp [(finite_zero.subset s.zero_smul_set_subset).measure_zero]\n  \u00b7 lift x to \u211a_[p]\u02e3 using hx.isUnit\n    rw [\u2190 distribHaarChar_padic, distribHaarChar_mul, Units.smul_def]\n\n", "theoremStatement": "@[simp] lemma Padic.volume_padicInt_smul (x : \u2124_[p]) (s : Set \u211a_[p]) :\n    volume (x \u2022 s) = \u2016x\u2016\u208a * volume s ", "theoremName": "Padic.volume_padicInt_smul", "fileCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "theoremCreated": {"commit": "c5f03bc0f2f770a9a47bd4fcf6d323acc988f69b", "date": "2024-12-11"}, "file": "FLT/FLT/HaarMeasure/DistribHaarChar/Padic.lean", "module": "FLT.HaarMeasure.DistribHaarChar.Padic", "jsonFile": "FLT.HaarMeasure.DistribHaarChar.Padic.jsonl", "positionMetadata": {"lineInFile": 92, "tokenPositionInFile": 3987, "theoremPositionInFile": 3}, "dependencyMetadata": {"inFilePremises": true, "numInFilePremises": 1, "repositoryPremises": true, "numRepositoryPremises": 2, "numPremises": 53}, "proofMetadata": {"hasProof": true, "proof": ":= by simpa [-volume_padic_smul] using volume_padic_smul x s", "proofType": "tactic", "proofLengthLines": 0, "proofLengthTokens": 60}}
